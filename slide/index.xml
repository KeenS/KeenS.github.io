<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Slides on κeenのHappy Hacκing Blog</title>
    <link>/slide/</link>
    <description>Recent content in Slides on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 06 Mar 2016 14:54:30 +0900</lastBuildDate>
    <atom:link href="/slide/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ビッグデータしないDrill、ローカルで快適に使うために</title>
      <link>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</link>
      <pubDate>Sun, 06 Mar 2016 14:54:30 +0900</pubDate>
      
      <guid>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ビッグデータしないDrill、ローカルで快適に使うために
----------------------
[Tokyo Apache Drill Meetup](http://drill.connpass.com/event/27414/)  
2016-03-22

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + サイバーエージェントのエンジニア
   + アドテクスタジオ所属
   + データエンジニアじゃなくてもデータを触ることはある


# なぜローカルか
---------------

* ビッグデータ重い
* 使いたいデータが絞れる時には大袈裟
  + 「売り上げ上位1000のユーザの行動」とか
* 同じようなクエリの重複
  + 新しいテーブル作れないDBとかview作れないDBとか
* 結果をRに渡したりとかが面倒
  + CSVダウンロードがGUI

# キャッシュ的な
----------------

```
+---------------------------------+
| BIG DATA (BigQuery, Spark, etc) |
+---------------------------------+
        ^ |  ^  |
        | |  |  |
        | v  |  v
   +-------------------+
   | ローカルキャッシュ | &lt;- ???
   +-------------------+
     ^ | ^ | ^ | ^ |
     | v | v | v | |
     +----------+  |
     |   自分   |  |
     +----------+  v
     +---+    +-----+
     | R | &lt;--| CSV |
     +---+    +-----+
```


# やりたいこと
--------------

* パパッっと処理を始められる
  + だいたい「CSVを簡単に読める」に同じ
  + たまにJSONとか
* 簡単に処理出来る
  + 自分が馴れているかどうか
* CSVを吐ける
  + 最後はRに渡したい


# 候補
-------

* ローカルMySQL
  + 事前のScheme定義が必要
* R
  + 扱い馴れない
* SQLite
  + 事前のScheme定義が必要
* (Python)
  + あまり向いてない？



&lt;pre style=&#39;font-size: 200%&#39;&gt;
＿人人人人人人人＿
＞　突然のDrill　＜
￣Y^Y^Y^Y^Y^Y￣
&lt;/pre&gt;


# なぜ Drill
------------

* (デーモン立ち上げておけば)サクっと始められる
* CSVをそのまま読める
  + Schema定義がいらない!
* ついでにJSONも読める
* 馴れたSQLで操作出来る
* CSV吐ける


# Drillを便利にするために
-------------------------

* いくつかのシェル関数
* Drillのデーモン/クライアントの起動を便利に

```sh
drill-start() {
    ~/compile/zookeeper-3.4.8/bin/zkServer.sh start
    drillbit.sh start
}

drill-cli() {
    sqlline -u jdbc:drill:zk=localhost:2181
}

drill-web() {
   firefox http://localhost:8047
}
```


# もっと便利に
--------------

* REPLでの操作が面倒
  + ヒストリ遡るのとか
  + ミスった時の訂正が地味に不便
* シンタックスハイライト欲しい
* 馴れたツールで編集したい


# sql-drill.el
--------------

* [KeenS/sql-drill.el](https://github.com/KeenS/sql-drill.el)
* Emacsのsql-modeのDrillサポート
  + emacsのsql-modeは拡張可能
* シンタックスハイライト
* REPL


# DEMO
------
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# まとめ
--------

* ローカルでデータ分析したい時があるよ
* その時にDrillは便利だよ
* Emacs向けのDrillプラグイン作ったよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustとは何か。どんな言語か。</title>
      <link>/slide/Rusttohananika_donnagengoka_/</link>
      <pubDate>Sun, 06 Mar 2016 05:27:39 +0900</pubDate>
      
      <guid>/slide/Rusttohananika_donnagengoka_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustとは何か。どんな言語か。
----------------------
[異種プログラミング言語格闘勉強会](http://kbkz.connpass.com/event/26677/)  
2016-03-20


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# Rustって?
----------

* システムプログラミング言語
* だけど函数型言語から影響を受けた
* 安全かつ高速
* ゼロコスト抽象化


## システムプログラミング言語
---------------------------

* スレッドはネイティブ、Cとの相互呼び出し、小さなバイナリサイズ
* ゲームエンジンとか作れる([piston](https://github.com/PistonDevelopers/piston))
* レンダリングエンジンとか作れる([Servo](https://github.com/servo/servo))
* Lチカとか出来る
* OSとか作れる([Redox](https://github.com/redox-os/redox))


## 函数型言語的からの影響
-----------------------

最近ではめずらしくなくなった


* デフォルトイミュータブル
* 代数的データ型
* コンビネータ
* トレイト (型クラス)


## 安全かつ高速
--------------

* データ競合が起きない
  + 所有権システム
  + だいたいコンパイル時Read Writeロック
  + Read only参照複数 or Write可能参照1つ
* LLVMベースの強力な最適化
* スレッド周辺のAPIが揃ってる


## ゼロコスト抽象化
------------------
省略

* [Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/)


# Rustの誤解
-----------

* 安定してないって聞いたよ
* 函数型言語ってホント?
* GCがなくて大丈夫?
* 継承がなくて大丈夫?


## 安定してないって聞いたよ

* 1.0以前の話
* 1.0(2015-05以降)はAPIの変更がルール化された
* 新規APIのstablizeはあれどdeprecateはまれ


## 函数型言語ってホント?

* 函数型言語の機能をつまみぐいしてるだけ
* 標準ライブラリとかはバリバリ手続的
* Lispよりも函数型言語っぽくない。
* とはいえ抽象力は高いのでそこまで煩雑にはならない


## GCがなくて大丈夫?

* GCはなくてもメモリ管理は自動でする
* コンパイル時にメモリ管理
  + コンパイラが必要なところにmalloc/freeを挟むイメージ
* むしろメモリ以外(fd、ロックなど)も自動管理
  + GCがある言語よりリソース管理の自動化が徹底してる
* [リージョンについて | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/)


## 継承がなくて大丈夫?

* むしろ継承必要？インターフェースだけでよくない？
* Rustはデータ型とメソッドを分離するので継承のメリットそんなにない
  + トレイトが強力ともいう
* 逆にサブタイプ関係による複雑さの上昇のデメリットが多い
  + 3回以上継承してるの全部把握出来るの？
* ジェネリクスとかはあるよ


# Rustをとりまく環境
-------------------

* racer/rustfmt
* Cargo
* crates.io
* [Rust Playground](https://play.rust-lang.org/)
* The Rust Programming Language



# racer/rustfmt
---------------

* racerがコーディング支援ツール
  + 補完
  + 定義元ジャンプ
  + 型情報
  + 各種エディタプラグインあり
* rustfmtがコードフォーマッタ
  + エディタプラグインあり
  + ビルドツール連携あり


# Cargo
-------

* Rustのビルドツール兼パッケージマネージャ
* これだけ覚えとけば困らない


# crates.io
-----------

* Rustパッケージのセントラルレポジトリ
* 必ずビルドが通るような工夫
  + cargo yank
  + 同じライブラリの違うバージョンがいても大丈夫
* Cargoとの連携
* Cargoからpublishも可能


# [Rust Playground](https://play.rust-lang.org/)
---------------------------------------

* webからRustを試せる
* とりあえず試すと色々分かる
  + 所有権難しいとか


# [The Rust Programming Language](https://doc.rust-lang.org/book/)
------------------------------

* Rustの入門用ドキュメント
* とりあえずこれ読めば始められる
* [和訳版](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)もある
  + [GitHub](https://github.com/rust-lang-ja/the-rust-programming-language-ja)で作業中
  + これの宣伝しに来ただけ
* 1.6ほぼ終わり、1.7はまだ


# ライブラリ紹介
----------------
## MIO

* [mio](https://github.com/carllerche/mio)
* 低レベルな非同期IOライブラリ
  + libuvやlibev2相当
  + イベントスレッドではなくイベントループ
* これを純Rustで実装
* つまり(比較的)高水準なAPIで使える
* 色んなライブラリの下地になっている


# ライブラリ紹介
----------------
## diesel

* [diesel](https://github.com/sgrif/diesel)
* ORM &amp; クエリビルダ
  + mioとはうってかわって高水準なライブラリ
* `infer_schema!(dotenv!(&#34;DATABASE_URL&#34;));` でコンパイル時に
  + DBにアクセスしてスキーマ情報抜いて
  + コード生成
* モデルもCRUDでちゃんと使い分けている


# 所有権難しい
--------------
下記のコードは動かない。

``` rust
fn main(){
    let hello = &#34;Hello, &#34;.to_owned();
    let world = &#34;World!&#34;;
    let hello_world =  hello + world;
    println!(&#34;{}&#34;, hello);
    println!(&#34;{}&#34;, world);
    println!(&#34;{}&#34;, hello_world);
}

```



# まとめ
--------

* Rustはシステムプログラミング言語だよ
* 面白い機能いっぱいあるよ
* もう「安定待ち」じゃないよ
* Try it now!



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでSSPを作った話</title>
      <link>/slide/ClojuredeSSPwotsukuttahanashi/</link>
      <pubDate>Mon, 22 Feb 2016 20:19:11 +0900</pubDate>
      
      <guid>/slide/ClojuredeSSPwotsukuttahanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClojureでSSPを作った話
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# SSPとは
-------
※今回作ったものの話なので実際は少し違う

* Supplier Side Platform
* メディアからの広告リクエストを受けて表示権をオークションに掛け、落札された広告を表示する
  0. 広告リクエストを受け取って
  1. 各DSPに競りの通知を投げて
  2. 入札を受け取って
  3. 落札者と落札価格を決めて
  4. 落札通知を出す


# アドテクコンペ
---------------

* [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380)
* サイバーエージェントの学生向けインターン
* 3日間、3、4人のチームで **DSP** を作る
* 学生は7チーム、1チームあたり2000q/sを捌くことになってる
* 学生のDSPを繋ぐための **SSP** が必要になったので作ることに。


&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/92I5tQt6q6IjII&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/prir/ss-35918532&#34; title=&#34;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&#34; target=&#34;_blank&#34;&gt;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/prir&#34; target=&#34;_blank&#34;&gt;CyberAgent, Inc.&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;


# 作るもの
----------

* 各DSPに競りの通知(HTTPリクエスト)を投げる大規模HTTPクライアント
  + 各DSPが2000q/s x 7チーム + 落札通知 = 16000q/s
  + 丁度2000q/sになるような制御も必要
* 入札を受けてのオークション、結果のロギングなど
* 管理画面


# s7pについて
-------------

* 今回作ったSSP
* [KeenS/s7p](https://github.com/KeenS/s7p)
* Clojure製
* 3日くらいで作った
* やや粗い部分も


# 今日話すこと
--------------

* なぜClojureか
* 16000q/s出すための工夫
* 16000q/sに抑えるための制御
* 運用して困った話とか



# なぜClojureか

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# なぜClojureか
---------------

* リクエストの数が多いので非同期IOは必須
* 100msでタイムアウトする仕様なのでタイムアウト処理も
* もともとはScala(akka)で作ったs6pがあった
* Actorの設計が良くなかったので遅かった
* あと非同期HTTPクライアントにタイムアウトがなかった
* プロダクションコードを流用したのでインターンが終わった後公開出来なかった
* 別言語で書き直すにあたってGo, Clojure, Common Lisp, Rust, Erlangが検討された

# なぜClojureか
---------------

* Common Lisp: 一番慣れてるが、非同期HTTPクライアント(とfutureライブラリ)が使いづらそうなのでやめた
* Rust: とりあえずパフォーマンスは出そうだし使いたかったが非同期HTTPクライアントが見付からなかった
* Clojure: そこそこ慣れてるし速そうな非同期HTTPクライアントがあった。core.asyncで非同期プログラミングもし易い
* Erlang: 恐らく一番向いてるが、ほとんど経験がない
* Go: 結構向いてそうだがあまり経験がないのでClojureを選んだ


# 16kq/s出すための工夫
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 16kq/s出すための工夫
------------------------
非同期IO（一部同期しちゃったけど）

``` clojure
(defn work [test req result]
  (-&gt;&gt; @dsps
       (sequence (comp
       ;; 全DSPにPOSTしてから(timeout 100ms)
                  (map (fn [dsp] {:dsp dsp :response (http/post (:url dsp) (json-request-option req))}))
       ;; 結果を待ち合わせる
                  (map destruct)
                  ...))
       ...))
    ....
```


# 16kq/s出すための工夫2
------------------------
一部同期したのでとにかくスレッド。スレッドへのディスパッチはチャネルで一発解決。

``` clojure
(defn worker [c]
  (thread
   ...))
```

```clojure
(defn make-workers [ch n]
  (doall (map (fn [_] (core/worker ch)) (range n))))
```

``` clojure
 workers (manage/make-workers ch 1024)
```


# 16kq/s出すための工夫3
------------------------
ZeroMQを使ったmaster-slave構成
(最終的にSlave18台)

![master-slave構成図](/images/s7p/s7p.svg)



# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------

* DSPの買い付け能力というビジネス的な問題ではなくサーバの負荷という技術的な問題による制御
* 1秒で160kクエリ投げて9秒休むとかは出来ない。もう少し細かく制御する必要がある。
* しかし制御をあまり細かくしすぎると今度はそこで遅くなりそう。
* リクエストを実際に投げるSlaveは分散してるけど統一した制御が必要


# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------
Master側で100ms毎にに200個だけZeroMQのキューに積む

![QPS制御の図](/images/s7p/qps_control.svg)


# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------
実装にはcore.asyncの `chan` と `timeout` を使用。(非同期プログラミング便利!)

```Clojure
(defn start-query [sender reqs]
  (let [timer (timer 100)]
    (go-loop []
      (let [t (&lt;! timer)
            took (take @qp100ms @reqs)]
        (doall
         (doseq [req took]
           (zmq/send-str sender (json/generate-string req))))
        (swap! reqs #(drop @qp100ms %))
        (if (and t (not (empty? took)))
          (recur)
          (println &#34;request done&#34;))))
    timer))
```


# 運用して困った話とか
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 50%&#34;&gt;レスポンスが遅いDSPにSSPのパフォーマンスが引き摺られる&lt;/span&gt;
* DSPが速ければ余裕を見ても10台あれば十分だった
* DSPのパフォーマンスに仮定をおけないので上限ギリギリの18台
* 同期: 「DSP作ってる時はちょっとくらい待ってくれよ、って思ってたけどSSP運用したら遅いDSPガンガン切りたくなる気持分かった」

# 運用して困った話とか
---------------------
## パフォーマンス検証が大変
* リクエストを捌くサーバのパフォーマンスをどうするか悩む
* サーバをチューニングすればSSPも速くなるが、検証にならない
* かといって投げたクエリを捌けないサーバに対して検証する訳にもいかない
* 結局安全側に倒したパフォーマンス見積りに。


# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 80%&#34;&gt;Masterがログ吐きすぎてDisk Full&lt;/span&gt;
* 最初の予定ではMasterはディスクをそんなに使わなかったのでディスクの小さいインスタンスだった
* ディスクスペース空けてMaster再起動で復旧。焦った。

# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 60%&#34;&gt;timeoutし続けるDSPがいてSlave完全沈黙&lt;/span&gt;
* コネクションのクローズ待ちで固まってた
* 該当DSPを切った上でSlaveの再起動で復旧
  * カーネルのチューニングかtimeout頻度の検知が必要そう
* timeoutを考慮に入れた構成にしてた筈なので想定外だった

# まとめ
---------

* ClojureでSSP作ったよ
* Clojure使えば非同期プログラミングが簡単に出来るよ
* 運用って大変だよ


# 参考
-------

* [KeenS/s7p: sexp version of s6p; a toy SSP.](https://github.com/KeenS/s7p)
* [ClojureでDSPを作った話 | κeenのHappy Hacκing Blog](http://keens.github.io/slide/ClojuredeDSPwotsukuttahanashi/)
* [KeenS/b11d: A toy DSP](https://github.com/KeenS/b11d)
* [アドテクコンペ | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/recruit/fresh/program_detail/id=11303&amp;season=2016)
* [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>HAMT ~ イミュータブルで高速なハッシュマップ ~</title>
      <link>/slide/HAMT/</link>
      <pubDate>Sun, 31 Jan 2016 16:17:35 +0900</pubDate>
      
      <guid>/slide/HAMT/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# &lt;span style=&#34;font-size: 90%&#34;&gt;Hash-Array Mapped Trie&lt;/span&gt;
----------------------
 ~ イミュータブルで高速なハッシュマップ ~  
サイバーエージェント AdTech Scala Meetup LT大会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループの新卒
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# &lt;span style=&#34;font-size: 60%&#34;&gt;scala.collections.immutable.HashMap&lt;/span&gt;
-------------------------------------

* 今日の話題。これの実装をみていく。
* イミュータブル
* キー-バリューペア
* 値を追加する度に新たなハッシュマップを作る &lt;!-- .element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;


# HashMap
----------------

* `O(1)`のアクセス効率
* 空間効率は悪い
* ハッシュ関数が定義出来れば何でもキーに使える
* 普通はミュータブルに使う
  + 大量のメモリをアロケートするのでコピーはつらい


# メモリ効率悪そう？
-------------------------

```scala
val hash = HashMap.empty + (3 -&gt; 1)
// +---+---+---+---+---+----
// | / | 3 | / | / | / | ...
// +---+---+---+---+---+----
//       |
//      +-+
//      |1|
//      +-+
```


# メモリ効率悪そう？
-------------------------

```scala
val hash2 = hash + (2 -&gt; 2)
// +---+---+---+---+---+----
// | / | 3 | / | / | / | ...
// +---+---+---+---+---+----
//       |
//      +-+
//      |1|
//      +-+
//  &gt; Copy &lt;
// +---+---+---+---+---+----
// | / | 3 | / | 2 | / | ...
// +---+---+---+---+---+----
//       |       |
//      +-+     +-+
//      |1|     |2|
//      +-+     +-+
```


# メモリ効率的データ構造?
----------------------------
## TreeMap

* O(log(n))のアクセス効率
* 空間効率はほどほど
  + イミュータブルに使えばかなり良い
  + 部分構造を再利用出来る
* 全順序関数が定義出来れば何でもキーに出来る
* キーが複数回比較される問題がある


# キー同士の比較
---------------
長いキー同士の比較がO(log(n))回走る可能性がある

```scala
treeMap.get(&#34;very long ... key1&#34;)

        ....
       /
&#34;very long ... key3&#34; -&gt; &#34;value3&#34;
       \
   &#34;very long ... key2&#34; -&gt; &#34;value2&#34;
         \
      &#34;very long ...key1&#34; -&gt; &#34;value1&#34;
```


# HashMap vs TreeMap
-----------------

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th&gt;HashMap&lt;/th&gt;&lt;th&gt;TreeMap&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;アクセス効率&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34;&gt;`O(1)`&lt;/td&gt;&lt;td&gt;`O(log(n))`&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;イミュータブルな時の空間効率&lt;/th&gt;&lt;td&gt;悪い(毎回コピー)&lt;/td&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;良い(部分構造を共有)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;キーの比較&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;定数回&lt;/td&gt;&lt;td&gt;`O(log(n))`回&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;キーの要件&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;Hash関数が定義されている&lt;/td&gt;&lt;td&gt;全順序関数が定義されている&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

# &lt;span style=&#34;font-size: 90%&#34;&gt;Hash-Array Mapped Trie&lt;/span&gt;
------------------------

* `O(1)`のアクセス効率
* 部分構造を共有してメモリ効率も良い
* キーの比較は定数回
* Hash関数が定義されていればキーに出来る


# 動作
------

* ざっくり言うと、「Hashして分割してトライ」


# 動作
------
## Hashする

* 40bitくらいの値が生成される

``` scala
hash(&#34;key&#34;)
// =&gt; 0b10101101010101001010110101010100
```


# 動作
------
## 分割する

* 下位から5bit毎に分割する
  + 5bit = 0 ~ 31
  + 32分木になる

```
11111 00010 10110 10101 01001 01011 01010 10100
```


# 動作
------
## トライ

* 32分のトライ木になる
* トライ木の実装は32bitのbitmapを使ったArray Mapped Trieを使う


(図が分かりづらいというか不適切)

```
8     7     6     5     4     3     2     1
11111 00010 10110 10101 01001 01011 01010 10100

1    2    3  4
   ...
  /
10100     ...
  \        /
   \    01011
    \   /  \
     \ /   01001....
     01010
       \
        ...
```


# 特徴
------

* ハッシュ値が固定長なので`O(1)`で動作
* Treeなので部分構造の共有が簡単
* 木を辿る時の比較はhash値（の一部）なので高速
* キーに全順序がなくてもハッシュ関数さえ定義されていれば木を構築出来る


# まとめ
--------

* Scalaのimmutable.HashMapはコピーしても高速だよ
* 裏で動くアルゴリズムを紹介したよ
  + ざっくりなので本物はもう少し工夫してる
  + prefix treeになってる


# 参考
------

* PDF [Ideal Hash Trees](http://lampwww.epfl.ch/papers/idealhashtrees.pdf)
  + HAMTの元論文
* [HAMT(Hash Array Mapped Trie) - sileのブログ](http://sile.hatenablog.jp/entry/20100926/1285467529)
  + HAMTの解説ブログ
* PDF [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections](http://michael.steindorfer.name/publications/oopsla15.pdf)
  + HAMTを改善したCHAMPというデータ構造の論文。Clojureにこれが入りそう。
* [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections | the morning paper](http://blog.acolyer.org/2015/11/27/hamt/)
  + CHAMPを解説したブログ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>DSLとTagless Final</title>
      <link>/slide/DSLtoTagless_Final/</link>
      <pubDate>Sun, 13 Dec 2015 22:42:39 +0900</pubDate>
      
      <guid>/slide/DSLtoTagless_Final/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# DSLとTagless Final
----------------------
サイバーエージェント アドテクスタジオ  
Scala Meet Up 2015-12-18

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒エンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
   - Scalaは初心者 ※ [Scala初心者の新卒が頑張ってLispを作ってみた](http://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/)

# 注意
------

* Scala初心者なのでScalaではなくScalaっぽい疑似コードで説明します
  + ~~コード例動かす時間が無かっただけ~~
* Scala初心者なのでScalaのコードは少なめに説明します


# DSLを作る
-----------

以下のようなHTTPなユーザをエミュレートするDSLを考える

``` scala
val scenario = and(
  get(&#34;/&#34;),
  get(&#34;/users&#34;).andThen(res =&gt;
    post(&#34;/follow&#34;, first(users.getJsonData))))
val Right(_) = runScenario(scenario, &#34;user&#34;)
```


# DSLを作る
-----------

普通は以下のようなAST作ってをラップする

``` scala
trait ScenarioDSL
sealed case class Get(url: String) extends ScenarioDSL
sealed case class Post(url: String, data: JSON) extends ScenarioDSL
sealed case class And(first, ScenarioDSL, second ScenarioDSL) extends ScenarioDSL
sealed case class AndThen(first: ScenarioDSL,
   callBack: (Response) =&gt; ScenarioDSL) extends ScenarioDSL

def get(url: String): ScenarioDSL= Get(url)
....

```


# DSLを作る
-----------

そして`runScenario`を作る

``` scala
def runScenario(scenario: ScenarioDSL, user: String) = {
  scenario match {
    Get(url) =&gt; Client.getInstance(user).get(url)
    Post(url) =&gt; Client.getInstance(user).post(url)
    And(first, second) =&gt; {runSenario(first, user); runSenario(second, user)}
    ....
  }
}


```




# DSLを便利に
-------------

例えば、このDSLを`curl`コマンド関数を追加する

``` scala
def toCurl(scenario: ScenarioDSL, user: String) =
  val auth = makeAuth(user)
  scenario match {
    Get(url) =&gt; &#34;curl ${auth} ${SERVICE_HOST}/url&#34;
    Post(url) =&gt; &#34;curl ${auth} -XPOST ${SERVICE_HOST}/url&#34;
    And(first, second) =&gt; toCurl(first) + &#34;\n&#34; + toCurl(second)
    ....
  }
}

```


# DSLの拡張
-----------

このDSLに新たに`select`を追加する

``` scala
val scenario = and(
  get(&#34;/&#34;),
  select(get(&#34;/users&#34;),
         post(&#34;/update&#34;)))
val _ = runScenario(scenario, &#34;user&#34;)
```


# Expression Problem
-------------------

この時に問題が出る

* DSLを使う全てのコードに変更が必要
  + `runScenario`と`toCurl`で`select`に対応する
* DSLそのものに手を加える必要がある
  + DSLがsealed traitされてる
  + そもそも、DSLがライブラリだったら変更出来るの？
* 実際には使ってなくても全ての関数で新しい機能に対応しないといけない
  + `toCurl`では`select`に対応しないとか
  + 逆に、`toCurl`がプラグインでコードいじれなかったらどうしよう

# Tagless Finalで解決出来るよ
----------------------------

* 元のコードをいじらず
* 必要な所だけを記述して
* しかも元々の実装よりも速い

DSLの作り方があります。それは型クラスを使ったやり方です。


# 型クラスの復習
---------------

型クラスは

* 型の振る舞うインターフェースを定めて
* インスタンスの型ごとに「後付けで」実装を与えると
* 多相的に扱えるアドホックポリモーフィズム

でした


# 型クラスの復習
---------------

``` rust
trait Hello { //型クラス
  fn hello(&amp;self) -&gt; String;
}

impl Hello for isize { //isize型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;I&#39;m {} years old&#34;, self)}
}
impl &lt;&#39;a&gt;Hello for &amp;&#39;a str {//&amp;str型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;My name is {}&#34;, self)}
}
fn main() {
  println!(&#34;{}&#34;, 23.hello());     // =&gt; &#34;I&#39;m 23 years old&#34;
  println!(&#34;{}&#34;, &#34;κeen&#34;.hello()); // =&gt; &#34;My name is κeen&#34;
}
```


# DSLをRustに翻訳
-------------

Scalaで型クラスを説明するとややこしいので一旦先のDSL例をRustに翻訳します

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getJsonData().first)));
runScenario(scenario, &#34;user&#34;).unwrap();
```


# Rustに翻訳
-------------
DSLのASTはこうなります。

``` rust
enum ScenarioDSL {
  Get{url: String},
  Post{url: String, data: RequestData},
  And{first: Box&lt;ScenarioDSL&gt;, second: Box&lt;ScenarioDSL&gt;},
  AndThen{first: Box&lt;ScenarioDSL&gt;,
   callBack: FnOnce&lt;(Scenario, Request) -&gt; ScenarioDSL&gt;},
}
```

# Rustに翻訳
-------------
runScenarioはこうなります。

``` rust
fn runScenario(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; Result&lt;()&gt; {
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; Client::instance(user).get(url),
    &amp;ScenarioDSL::Post{ref url} =&gt; Client::instance(user).post(url),
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      try!(runSenario(first));
      runSenario(second)
    },
   ...
  };
}
```


# Rustに翻訳
-------------
`toCurl`はこうなります

``` rust
fn toCurl(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; String {
  let auth = makeAuth(user)
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; format!(&#34;curl {} {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::Post{ref url} =&gt; format!(&#34;curl {} -X POST {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      let first_str = toCurl(first, user);
      let second_str = toCurl(second, user);
      format!(&#34;{}\n{}&#34;, first_str, second_str)
    },
   ...
  }
}
```


# Tagless Final
---------------

Rustの準備が終わったのでTagless Finalの説明に入ります。


# Tagless Final
----------------

* ASTをデータではなく関数で表わす
* 同じ関数でも欲しい結果によって計算を変えるために型クラスを使う
* どの型クラスのインスタンスとして扱うかで結果を変える
  + そもそもASTは計算を抽象化してデータにしたもの。
  + 抽象的な計算があるならデータにする必要はない

* 型クラスでジェネリックに作って
* 欲しい型を伝えるだけで挙動が変わる


# 型クラス
----------
DSLの文法の型クラスを定義する。  
DSLっぽく見せるため、ラッパを書く(Rust特有)。


``` rust
trait ScenarioSYM {
  fn get(url: String) -&gt; Self;
  fn post(url: String) -&gt; Self;
  fn and(first: Self, second: Self) -&gt; Self;
  ...
}

fn get&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::get(url)}
fn post&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::post(url)}
fn and&lt;C: ScenarioSYM&gt;(first: C, second: C) -&gt; C {C::and(first, second)}
...
```



# `runScenario`
------
結果に`Result`型が結果として欲しいなら`Result`型に`ScenarioSYM`を実装する

```rust
impl ScenarioSYM for Result&lt;()&gt; {
  fn get(self,url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn runScenario(res: Result&lt;()&gt;) -&gt; Result&lt;()&gt; {
  res
}
```


# `toCurl`
----------
`String`が欲しいなら`String`に実装すれば良い。

``` rust
impl ScenarioSYM for String {
  fn get(self, url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn toCurl(str: String) -&gt; String {
  str
}
```


# 完成形
--------

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getData().iter().next())));
  // ↑ここまではジェネリックなScenarioSYM型
  // ↓ここで呼ばれることでResult&lt;()&gt;型にインスタンス化される
runScenario(scenario, &#34;user&#34;).unwrap();
```


# DSLの拡張
-----------

拡張したい文法のDSLを定義して、欲しいものに実装するだけ。

`runScenario`に変更は要らないしサポートしない`toCurl`は気にしなくて良い。

``` rust
trait SelectSYM {
  fn select(self, first: Self, second: Self) -&gt; Self;
}

impl SelectSYM for Result&lt;()&gt; {
  fn select(self, first: Self, second: Self) -&gt; Self {...}
}
```


# Tagless Finalまとめ
---------------------

* この方式だと実行時にタグでパターンマッチしないので速い
* DSLの拡張も機能の拡張も容易
* 型クラス便利


# ScalaでのTagless Final
------------------------
Rustで分かりやすく解説したのでScalaでどうなるか見ていきます。

まずは型クラスを定義

``` scala
trait ScenarioSYM[C] {
  def get(self: C, url: String): C
  def post(self: C, url: String): C
  ...
}
def get(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.get(self, url)
def post(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.post(self, url)
...
```


# `runScenario`
------

``` scala
implicit val resultScenario = new ScenarioSYM[Either[Err, ()]] {
  def get(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  def post(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  ...
}

def runScenario(ast: Either[Err, ()], user: String)
      (implicit i: ScenarioSYM[Either[Err, ()]]) = ast
```


# 完成形
--------
Scalaの型クラスの制約上最初の例と少し異なる
(`val`じゃなくて`implicit`を取る`def`になる)


``` scala
def scenario(implict i: ScenarioSYM[C]) = Scenario
   get(&#34;/&#34;)
   get(&#34;/users&#34;) andThen((scenario, res) =&gt;
    scenario post(&#34;/follow&#34;, first(users.getJsonData)))
val Right(_) = runScenario(scenario, &#34;user&#34;)

```


# まとめ
--------

* Expression Problemについて説明した
* Tagless Finalを紹介した
* 型クラス便利
* Rust便利
* [参考](http://okmij.org/ftp/tagless-final/course/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでDSPを作った話</title>
      <link>/slide/ClojuredeDSPwotsukuttahanashi/</link>
      <pubDate>Tue, 27 Oct 2015 21:04:20 +0900</pubDate>
      
      <guid>/slide/ClojuredeDSPwotsukuttahanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClojureでDSPを作った話
----------------------
Lisp Meet Up #3
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# DSPとは
--------

* Demand Side Platform
* 広告主から広告を集めて広告の表示権を競り落し、適切な広告を出す
  0. 広告主を集めて
  1. 競りの通知を受け取って
  2. 一番コスパが良さそうな広告を選んで
  3. 入札して
  4. 落札通知を受け取る
  5. 落札したら広告を出す



# ひとりDSP
----------

* AdTech Studioの新卒研修
* 2ヶ月間、業務時間の20%を使ってDSPを作る
  + 実質8営業日
* 業務ロジックを理解することが目的
* 最後に新卒の作ったDSP同士で競争、利益が得点になる
* 他には最終発表での得点も
* **研修なので好きにやっていい**
  + Clojureで書くことに
* サーバーの他は広告主データと学習用データが与えられる



&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/92I5tQt6q6IjII&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/prir/ss-35918532&#34; title=&#34;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&#34; target=&#34;_blank&#34;&gt;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/prir&#34; target=&#34;_blank&#34;&gt;CyberAgent, Inc.&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;


# 作るもの
---------

* 競りの通知を受け取って入札するJSON REST API
* 落札の通知を受け取るJSON REST API
  + 割とシンプル
* 「一番コスパが良さそうな広告を選ぶ」部分は色々と工夫する
* 今回は広告を出すところまではやらない
* クリック情報は落札通知に入ってる


# b11dについて
-------------

* 今回作ったDSP
* [KeenS/b11d](https://github.com/KeenS/b11d)
* Clojure製
* 5日くらいで作った
* あまりゴテゴテしない方針
  + 今回パフォーマンスは無視していい
  + Clojureに慣れてないので学習コストも抑えたい
* NginXとAppとMySQL構成+α
* DBは綺麗に設計したい
* 1リクエスト毎にDBを引きにいく素敵仕様


# WAP
-----

* Compojure
* Sinatra likeなやつ
* ringの上に乗っかてる
* かなりシンプルな部類だがJSON REST API程度ならこれで十分
* ringミドルウェアのでJSON部分も抽象化
* 学習コストが低いので気軽に始められる


# JSONライブラリ
--------------

* ring.middleware.json/wrap-json-{body, response}
  + JSON-&gt;マップとマップ-&gt;JSON
  + bodyの方はキーがStringになるのが微妙
    - セキュリティ的に仕方ない
  + Content-Typeを指定しないと動かない罠
* cheshire
  + 事前データをインポートするのに使った
  + ringのJSONミドルウェアの依存なのでそのまま使った
  + 自然で使い易いAPI


# データベース接続
----------------

* java.jdbc
* JDBCのClojure向けラッパ?
* DataSourceを自分で渡すのでコネクションプールも簡単
* SQL手書きしたら良い感じにマップを返してくれる
* Storeはカラムと値の対応を手書き
* 便利マクロもいくつか


# データベース接続
----------------

* eager loading面倒問題
  + 入れ子オブジェクトを保存する方も面倒だった
  + ORMの便利さを実感。
* bulk insert難しい問題
  + 実行時可変長引数難しい
* ORMはXXXを使うかJavaのやつをそのまま使う?
* JavaはXMLさえ我慢すれば割と良い奴揃ってる
* しかしレスポンスはマップで欲しいかも


# 運用
-----

* warに固めてTomcat vs スタンドアロンなfat jar
* 今回はfat jarを選択
* スタンドアロンだとsupervisordとかでの管理が楽
* Tomcatの運用経験がない
* Jetty中々優秀らしい
* jstatを使ってMackerelでメトリクス取った


# 非同期化
---------

* core.async/goで手軽に非同期
* DBへの書き込みを非同期にした
* DB書き込みでエラーが出ても500にならない恐怖
* 最初の方で支払いを記録出来てなくて予算管理が死亡
  + 予算管理失敗ペナルティで、大分点数引かれたらしい
* goroutineでの例外処理どうやるんだろう。


# 開発環境
---------

* nREPL + Emacs + CIDER
* 補完の設定上手くいかなかった
* 諸々地味に不便
* 起動遅い
* Emacs側からnREPL立ち上げたい
* サーバーのライブリロード欲しい
* 正解が欲しい



# その他Clojureについて
---------------------

* コンスのCarを取るのに`hd`か`head`か`car`か分かんなかった
  + 結局どれでもなくて`first`だった
* 引数のパターンマッチが便利
  + JSON REST APIだとリクエストに何を期待してるのか分かりづらい
  + パターンマッチがドキュメントになる
* やっぱJavaのライブラリ使えるの便利


# 落穂拾い
---------

* デプロイにはシェルスクリプト
  + お家芸
* 「一番コスパが良さそうな広告を選んで入札」で統計か機械学習が必要
  + 1回表示した時の収益の期待値を計算する
* 今回は事前データの統計を使った
  + 理想的には機械学習。時間変化についていける
* In Appでオンライン学習出来るライブラリが思ったよりない
  + 分散処理向けの大袈裟なのが多い
  + Weka? liblinear-java?
* 後で考えたらIncanter使えばよかった


# まとめ
-------

* 給料貰いながらLisp書いた
* ClojureでDSP作った
* Clojureで機械学習したかったけど間に合わなかった


# 参考
------

* [Internal of b11d | κeenのHappy Hacκing Blog](//KeenS.github.io/slide/Internal_of_b11d/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Internal of b11d</title>
      <link>/slide/Internal_of_b11d/</link>
      <pubDate>Mon, 19 Oct 2015 21:33:00 +0900</pubDate>
      
      <guid>/slide/Internal_of_b11d/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Internal of b11d
----------------------
サイバーエージェント新卒研修  
ひとりDSP最終発表会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdのサーバーサイド（？）エンジニア
 + 趣味でLisp, ML, Shell Scriptあたりを書きます
 + 仕事でScalaとShell Scriptあたりを書きます


# 今回作ったもの
----------------

* b11d (ぶらっくんどごーるど)
* Clojure (compojure + middleware)製
  + + NginX + MySQL + Supervisord
* 出来る限りシンプルになるように作った
  + 310行
* デプロイその他はシェルスクリプト
* 監視はmackerel


# シンプルということ
-------------------

* アプリケーションは状態を持たない
* IO以外副作用を持たない
* つまり、キャッシュを持たない
  + キャッシュはパフォーマンス上の意味しかない
  + 早過ぎる最適化は諸悪の根源
* スケールアウトが容易
* compojureのミドルウェアを上手く使った


# シンプルということ2
--------------------

* データベースはだいたい第4正規形（ﾀﾌﾞﾝ）
  + 全てのカラムは`NOT NULL`
  + 広告主の所だけ拡張性を持たせるために第1正規形に落とした
  + 1広告主に対して複数の広告が持てるようになる
* 外部キー制約も全部付ける
* データが綺麗なのでアプリケーション側でのやることが少ない
* 分析する時にも活きる筈


# デプロイ
---------

* 全てシェルスクリプトでオペレーション出来る
* 手作業を無くしてミスを無くす
  + 「あれ？設定書き換えたのに反映されてない」 → 「再起動忘れてた」とかを防ぐ
* ☆秘伝☆のシェルテクニック満載！ 
* アプリケーションが1jarに収まるのでデプロイが楽。


# 監視
------

* mackerelで色々モニタリング
* Linux, NginX, MySQL, JVM, レスポンスステータス
* ほとんどMackerelに乗っかることで本質的でないことに労力を割かない
  + 本質 = 業務ロジックを理解すること
* アプリケーションの死活監視にはsupervisord
  + 本当はsystemdでやりたかったけどUbuntuのバージョンが古かった


# 落穂拾い
----------

* DBへの書き込みは非同期。Clojureなら簡単に書ける
  + `(go ...)` で囲むだけ
* だいたい1700qps。データが増えると多分もうちょい下がる。
  + キャッシュすればデータに依存しない速度。もう少しパフォーマンスも出る。
* アプリケーションサーバには組込みjettyを使った。
  + War + Tomcatでも出来るがデプロイ/運用が楽なのでこちらを採用
* コア数に対してスケールするのでスケールアップも出来る
* CTR予測は訓練データを 広告主xサイトxUA で統計を取って使う
  + 途中からシグモイド関数で変化をつける


# 改善点とか今後とか
---------

* win rate, 入札/落札価格, CTRとかをmackerelでモニタリングしたかった
* 管理画面的なの必要？
* フォールトトラレンス性はないのでその辺
  + MySQLが死ぬとヤバい。
* ホットデプロイしたかった
* 折角JVMだし機械学習したかった
* Unix Domain Socket使うの忘れてた
* データベースにタイムスタンプ入れるの忘れてた………orz

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ISUCONこれまでの流れ</title>
      <link>/slide/ISUCONkoremadenonagare/</link>
      <pubDate>Fri, 04 Sep 2015 08:47:05 +0900</pubDate>
      
      <guid>/slide/ISUCONkoremadenonagare/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ISUCONこれまでの流れ
----------------------
雑に書き殴った
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + ISUCON3、 4の予選、本戦に出場（学生枠）

# ISUCON1 ブログ
---------------

* node perl ruby
* kazeburoの罠
* ブログのサイドバーが重いやつ
* 割と親切なルール


# ISUCON2 チケット予約サイト
---------------------------

* perl ruby node php java python
* 席ランダムにしてなくてもベンチマーカー通っちゃう
* 変更が1秒以内に反映されていること → 0.9秒毎に裏でバッチを回す
* JOINが3連になってる所があってみんなそこに引っ掛かったがボトルネックはそこじゃない
* ちょっとルールが雑になった


# ISUCON3予選 スニペット投稿サイト
--------------------------------
* go node perl python ruby php
* AWS1台
* Markdown変換がperl製の重いやつ
* AWSだとプロセスのフォークも重い
* titleの抜き出しも重い
* チェッカーが甘くてVarnishを導入しただけで点数爆上がり
* SQLの典型問題とかも
* workloadに気付かなかった人多数
* 学生枠が出来た
* ベンチマーカが通れば何でもアリな風潮


# ISUCON3本戦 画像SNS
--------------------
* go node perl python ruby
* オンプレ5台
* 画像の変換が重い
* 実は帯域もつらい
* 画像のチェッカがあってチェッカが通れば画質を落としても良かった
* 組長の罠
* ベンチマーカーに通れば何でもアリ
* 複数サーバーでのファイルの共有にWebDAVが盲点
* 点数計算の罠に嵌まる人多数
  + 基本点より追加点に目が眩む人がそれなりに
* 推測するな計測せよ
* nodeで初期パスワードが間違っているトラブル


# ISUCON4予選 銀行
--------------------------------------

* go node perl php python ruby
* AWS1台
* ワークロードを桁外れに指定するとベンチマーカーが走り続けるバグ
* ベンチマーカーにアクセスして行動パターンを解析した人が出る（その情報は使ってない。スポーツマンシップ。）
* テンプレートエンジンをやめて静的ファイル
* Go勢のon memory戦略が跋扈
* 「メモリに載せれば勝てるぜ」風潮
* 静的ファイルを返さない反則ギリギリのチューニング
* ベンチマーカーのチューニング
* Varnish潰し
* アプリをC++で書き換えて予選突破したチームも出る


# ISUCON4本戦 動画広告
----------------

* go perl php python ruby
* オンプレ3台
* 最初からRedisに動画が載ってる
* それ外したらスコア頭打ち(帯域がつまる)
* ベンチマーク同士が干渉しあう
* 実はCache-Controlをしたらスコアが爆上がり(上位2チームだけ気付いた)
* 3位のチームは外向きと内向きの2枚のNICを使って団子状のスコアから頭1つだけ出た


#ISUCON5予選 ???
----------------
* perl ruby node php python go java (scala)
* GCP 
* 今までの予選だとベンチマーカが競技者の手元に渡る問題があった。
* かといって外部からのベンチマークは安定しない。
* GCPならGoogleの謎の技術によって安定するらしい。
* @tagomoris 「もはやISUCONは予選で落ちる人の方が多くなった。その人達にとっては予選こそがISUCONなのだ」
  
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SMLでPNGデコーダを作ろうとして分かったこと</title>
      <link>/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</link>
      <pubDate>Fri, 04 Sep 2015 06:45:19 +0900</pubDate>
      
      <guid>/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLでPNGデコーダを作ろうとして分かったこと
------------------------------------------
サイバーエージェント アドテクスタジオ  
エンジニア月初会
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
----------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒
 + Lisp, ML, Shell Scriptあたりを書きます


&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うーむ。画像フォーマットの扱い一回くらい書いてみないとなーと思ってたけどやっぱり既存なんだよなー。Common LispかSMLあたりならフロンティアになれそう。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639303085240643584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 仕様を理解するためにデコーダから実装するのがオススメです&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639304790766305281&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; そんな詳しいわけではないんですが、jpegかpngがおすすめです。webpは動画コーデック由来で難しいと思います。tiffは画像コンテナみたいな立ち位置なので画像フォーマット感がないかなと。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639307400244137984&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

明日の朝までに  
&lt;span style=&#39;font-size:150%;&#39;&gt;SMLでpngデコーダを実装しよう&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Standard ML
-------------

* ML系の函数型言語
* 文法はOCamlよりF#に似てる（というかF#が似せてきた）
* 結構書き易い
* 仕様は SML&#39;90とSML&#39;97がある
* 仕様で言語のformal semanticsが定められてたりする
* 要は研究向き
  + **ライブラリほぼなし**
  + **コミュニティほぼなし**


&lt;span style=&#39;font-size:250%;&#39;&gt;＞　無理ゲー　＜&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 一応フォーマットを調べる
------------------------


```
+-----------------+
|     Chunk       | 画像はChunkの集合。
++---------------++ Chunk自体は簡単なフォーマット
|| length | name ||
|+---------------+|
||    data       ||
||    ...        ||
|+---------------+|
||    CRC        ||
++---------------++
|    Chunk        |
|    ...          |
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
意外と単純？
&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# とりあえず書いてみる
---------------------

```sml
structure PNG = struct
    fun readChunk data i = ...
end
```


# 案外苦戦
------------
* 型が厳密なので型の行き来が面倒
  + 8bit &lt;-&gt; 32bit
  + 符号付き &lt;-&gt; 符号無し
  + byte &lt;-&gt; char

```sml
val op &lt;&lt; = Word.&lt;&lt;
val op &gt;&gt; = Word.&gt;&gt;

fun nameToWord name = CharVector.foldl (fn(c, acc) =&gt; &lt;&lt;(acc, 0w8) + (Word.fromInt (ord c))) 0w0 name
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
3時間後
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;さて、メインのデータ抜き出すところまでは行ったけど次復号だ。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639501771430211584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 今更PNGについて
----------------

* GIFの特許問題を回避するために作られたフォーマット
  + LZ77がマズいらしい
* **可逆圧縮アルゴリズムを使う** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + **アルゴリズムは1つとは限らない** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
  + 但し仕様で指定されているのはzlibのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
* フィルタを噛ませることでプログレッシブな表示も可能


# SMLのZLibライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
zlib……実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ZLib
------

* RFC-1950
* zipやpngで使われるフォーマット
* ZLib自体は圧縮データのコンテナで **圧縮アルゴリズム自体は1つとは限らない**  &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + 但し仕様で指定されているのはdeflateのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;


# SMLのDeflateライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
deflate…実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Deflate
---------

* RFC-1951
* ハフマン符号の変種の可逆圧縮アルゴリズム
  + **3種類の符号化方式を自由に使ってよい** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;



&lt;span style=&#39;font-size:250%;&#39;&gt;(心)ボキッ&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 学んだこと
-----------

* PNGは一晩でデコーダを書ける程柔じゃない
  + 事前調査も大事
* 書き易い言語でもコミュニティが大事
* 1晩でLTの準備はつらい


# 付録
------

* [今回のコード](https://github.com/KeenS/sml-png)
* [SMLのパッケージマネージャ](https://github.com/standardml/smackage)
* [PNG](http://www.w3.org/TR/2003/REC-PNG-20031110/)
* [RFC-1950 ZLIB](https://www.ietf.org/rfc/rfc1950.txt)
* [RFC-1951 DEFLATE](https://www.ietf.org/rfc/rfc1950.txt)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Method Drawでお手軽LGTM生成</title>
      <link>/slide/Method_DrawdeotegaruLGTMseisei/</link>
      <pubDate>Fri, 14 Aug 2015 00:55:37 +0900</pubDate>
      
      <guid>/slide/Method_DrawdeotegaruLGTMseisei/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Method Drawでお手軽LGTM生成
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# Method Draw
-------------

* シンプルなSVG エディタ
* オープンソース
* [editor.method.ac](http://editor.method.ac/)


# デモ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 以上
------
Have a happy hacking life
&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>構文解析にまつわる小話たち</title>
      <link>/slide/koubunkaisekiarekore/</link>
      <pubDate>Sat, 08 Aug 2015 04:16:50 +0900</pubDate>
      
      <guid>/slide/koubunkaisekiarekore/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# 構文解析にまつわる小話たち
----------------------
[#peg_study](https://twitter.com/search?q=%23peg_study&amp;src=typd&amp;vertical=default&amp;f=tweets)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバエージェントの新卒エンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# ウォームアップ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文解析はバッドノウハウ
-------------------------

* プログラム言語を使っているなら既にパーサはある
  + 文法も定義されてる
* 目の前のパーサを使え
  + パーサAPIがある言語もある(Lispとか)
* そうでなくても内部DSLを考えろ
  + 内部DSLで解決出来ないときだけ構文解析

# 本質はAST
-----------

* 結局はASTになればどんな文法でも同じ
* 文法はただの外皮、欲しいのはAST
* シンタックスシュガーは飾り
  + DRY出来るなら別
* S式を使え
  + ASTをそのまま書き下せる


# AST First
-----------

* 最初にASTを考える。そして文法を考える
* 何が欲しいのかイメージし易くなる
* 構文解析はAST生成の自動化。普段してないことを自動化するのは愚か。
* 早めに間違いに気付ける
  + `+`は二項演算子。じゃあ `&amp;&amp;` は？ `=` は？

Note: Lispだと+は関数、andはマクロ、setqはスペシャルフォーム


# 構文解析の流れ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文解析の流れ
---------------

1. Lexer generaterからlexerを作る
  + Lexとか
2. Parser generaterからparserを作る
  + yaccとか
  + BNFという記法
3. ソースファイルをlexerで処理してトークン化する
4. トークン列をparserで処理してASTを作る



```
         [Lexer]        [parser]
[Source]-------&gt;[Tokens]------&gt;[AST]
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# LexerとParserを分ける意味
--------------------------

* (上向き構文解析だと分けないとつらい)
* 役割の分担
  + 困難は分割せよ
* 文字列をシンボル化して比較が高速に
* 思考のフレームワークとして



&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;字句解析器手づくりの簡単さに対して構文解析器手づくりはわりと人を殺しにかかる&lt;/p&gt;&amp;mdash; gfn (@bd_gfngfn) &lt;a href=&#34;https://twitter.com/bd_gfngfn/status/578908166785671168&#34;&gt;2015, 3月 20&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 正規表現の使いどころ
---------------------

* 高速な実装がある
* 部品化しにくい
* 括弧の対応とか入れ子構造(`if .. then .. else`とか)は扱えない
  + perlの正規表現は厳密には正規表現ではない
* 構文解析には向かない
  + 「マッチ」は出来ても「抜き出し」は面倒
* Lexerには向いてる
  + トークン自体末端の部品なので部品化する必要がない

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;依存型のある言語でlexとか作ったら出てくるトークンの型変数に正規表現出てくるのかな&lt;/p&gt;&amp;mdash; eld-r-esh-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/597772476244885505&#34;&gt;2015, 5月 11&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;「bnf = (大雑把に言って)正規表現+括弧の対応」というのはchomsky–schützenbergerの定理という結構マニアックな定理(ドラゴンブックには載ってないと思う)をさらに僕なりに超訳したものなのであまり知られてないと思います．&lt;/p&gt;&amp;mdash; ryoma sin&amp;#39;ya (@sinya8282) &lt;a href=&#34;https://twitter.com/sinya8282/status/597465565654024192&#34;&gt;2015, 5月 10&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 構文クラス

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文クラス
------------

* 学術的だが知っておくと幸せになれる
* 文脈自由文法を解析するためのものを話す
  + 多くのプログラム言語は文脈自由文法
  + 正規言語 ⊂ 文脈自由文法
* 大きく分けると上向き構文解析と下向き構文解析
* 詳しくは[ドラゴンブック](http://www.amazon.co.jp/%e3%82%b3%e3%83%b3%e3%83%91%e3%82%a4%e3%83%a9%e2%80%95%e5%8e%9f%e7%90%86%e3%83%bb%e6%8a%80%e6%b3%95%e3%83%bb%e3%83%84%e3%83%bc%e3%83%ab-information-computing-a-v-%e3%82%a8%e3%82%a4%e3%83%9b/dp/478191229x)参照


# LL(1)
----

* 下向き
  + 再帰降下パーサ
* 定義した言語しか厳密に受け取らない
* 線形線形時間でパース可能
* 手書きに向く
* パーサーコンビネータとかも


# LR(1)
----

* 上向き
  + トークンをくっつけて構文要素に、構文要素をくっつけてさらに上の構文要素に…
* LL(n)⊂LR(n)
* LRそのものの解析は難しくて、いくつかサブクラスがある
  + 単純LR (SLR):  貧弱
  + 先読みLR (LALR): パーサジェネレータでよく使われる
  + 正準LR: 計算コストが高い。メモリ喰う
* 事前計算のコスト（面倒くささ）が高い
  + パーサジェネレータ


# LRパーサジェネレータ
-----

* 基本はBNF(Backus-Naur-Form)
* いくつか方式がある
  + 演算子順位解析も合わせる
    - EmacsのSMIEとか
  + BNFだけでやる
    - 別の言語も受理する可能性がある ドラゴンブック 上 p. 247
    - 普通は問題にならない


# LRの限界とか
-------------

* `-`の単項演算子と二項演算子の衝突
  1. SMLみたいに諦める(単項の`-`を`~`で表す)
  2. Lexerで区別する
* 左再帰で無限ループ
  + 手動でどうにか出来る
  + 自動でどうにかしてくれるジェネレータもある
* BNFの書き方によっては文法があいまいになる
  + `if .. then .. if .. then .. else ..` とか
  + 自動ではどうにもできないので気をつけるしかない


# BNFとパーサージェネレータの良さ
------------

* BNFは言語を定義する。
  + 言語仕様にも使われる
* 要は「仕様からプログラムを生成する」
* 宣言的


# 複数文法のサポートとグローバル変数の衝突
---------------------------------------

* 複数の文法をサポートしたい時がある
  + 独自記法と互換記法とか
* 雑なパーサジェネレータ/コンビネータを使っているとグローバル変数が衝突する
  + パーサライブラリの作者は配慮して下さい。


# 言語仕様の配慮
---------------

* LispはLL
* Java 1.0はLALR
  + 今はLALRではないらしい
* PrologはLALRだった気がする


# 非文脈自由文法
----------------

* 文脈を持つ（雑）
* ひねりなくパーサージェネレータ使っただけじゃ解析出来ない言語のこと。


## sedのs///
-----------

* 実は `s|||`のように区切文字は何でもいい
  + パスネームの置換に便利
* 対応関係が文脈で変わるので非文脈自由


## Markdown
-----------

* 元々のperlの実装は正規表現
  + 再帰を使っているので正規言語ではなく文脈自由文法
* GFMなどのTable記法はカラム数という文脈があるので非文脈自由
* Table記法をサポートする時は覚悟を持って。


# その他
--------

* 関数の仮引数の数と実引数の数の一致
* 変数の使用の前に変数宣言
* 要は構文解析で出来ることには限界がある。


# パーサの実際

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 速度と手軽さ
--------------

* 外部DSLやコンフィグファイルだとパーサの速度は必要ない
  + メインループで使われないので起動時間にしか影響しない。
  + むしろ手軽に作れた方がいい
* HTTPだとかメインループで使うものはどうやってでも速くしたい
  + 労力は惜しまない

# 手書きとジェネレータとコンビネータ
----------------------------------

* 速度が必要ならジェネレータ
* LLでないならジェネレータ
* 手軽さが欲しいならコンビネータ
* 色々手を加えたいなら手書き…かも


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;パーサ手書きするのダサイよなぁ。クラスが分からなくなる。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/597751470834855938&#34;&gt;2015, 5月 11&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ジェネレータの扱いにくさ
--------------------------

* あんまり人気ない気がする
* 2回も前処理必要なのダサいよね
* 新たな文法覚える必要がある
* そもそも作るのにもコストが高い
  + 言語の文法に合わせたプリンタ
  + 拡張性持たせると厄介
* かといって正規表現はやめましょうね

# DSLパーサジェネレータ
----------------------

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;PEGが正規表現と違って辛いところは言語組み込みじゃないのとワンライナーに向かないことなんだよな… &lt;a href=&#34;https://twitter.com/hashtag/peg_study?src=hash&#34;&gt;#peg_study&lt;/a&gt;&lt;/p&gt;&amp;mdash; わかめ@TypeScriptカッコガチ (@vvakame) &lt;a href=&#34;https://twitter.com/vvakame/status/629881217320550401&#34;&gt;2015, 8月 8&lt;/a&gt;&lt;/blockquote&gt; 

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# DSLパーサジェネレータ
----------------------

* あったらそれなりに人気出そう
* メタプログラミングが出来る必要がある
* Common Lisp
  + 作者自身作ってる途中でジェネレータとコンビネータを勘違いする
  + ドキュメントでジェネレータといってるのに実際はコンビネータだったりする
* D
  + なんか作ってる人いるらしい


# 複雑性と分かりやすさ
---------------------

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;オーバーエンジニアリングを「あいつは力に溺れた」と言い変えていくといいと思う&lt;/p&gt;&amp;mdash; イカid:mizchi0x (@mizchi) &lt;a href=&#34;https://twitter.com/mizchi/status/565662999063838720&#34;&gt;2015, 2月 12&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 複雑性と分かりやすさ
---------------------
* パーサが複雑な文法に対応出来ても人間が追い付かない
* 周辺のサポートも必要になるのでやっぱりシンプルな方が良い。
  + LRよりLL
  + S式とかシンプルの極み
  + [Clojureシンタックスハイライター開発から考えるこれからのlispに必要なもの](http://www.slideshare.net/sohta/clojurelisp?ref=http://athos.hatenablog.com/entry/2015/07/29/222535)
* 「出来る」と「した方がいい」は別の話


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;S式はどう考えても読み易い……&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/590528791677546496&#34;&gt;2015, 4月 21&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;}]))みたいなのを書いてると、括弧が一種類の言語、いいなぁ、と思ったりします。&lt;/p&gt;&amp;mdash; mzp (@mzp) &lt;a href=&#34;https://twitter.com/mzp/status/587941717451481088&#34;&gt;2015, 4月 14&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ソースロケーション保持法

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# ソースロケーション保持法
-------------------------

* エラーメッセージを出すためにはソースロケーションを保持する必要がある
* flymakeの情報: ファイル名、開始行/列 終了行/列 エラーメッセージ
  + 最悪これがあればどうにかなる
  + 「分かりやすい」メッセージはツールに任せる
* 字句解析だけでなく意味解析、さらにはつまるところコンパイルが終わるまで保存する必要がある
  + トークンやASTにメンバが増える
  + オブジェクト指向のカプセル化って素晴らしい


# 1. インクルード
----------------------

* トークンのデータに入れてしまうパターン
* `datatype token = Plus of int * int | Symbol of int * int * string` ...
* OOPなら自然だが函数型だとパターンマッチがつらくなる


# 2. ラップ
--------

* ロケーションのレコードでトークンをラップする
* `{start:int, end: int, token: token}`
* パターンマッチは少し楽になる
  + 多相レコードがないとそもそもレコードつらいけどな！！
* MLtonがやってるらしい


# 3. テーブル
-------------

* ロケーションテーブルを持って、トークンにはテーブルへのキーだけ持たせる
* トークンが軽くなるので速そう
* でも面倒そう


# エラー処理
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# エラーメッセージ
------------------------

* 一応ロケーションがとれればエラー箇所は出せる。
* メッセージの親切さはツールとヒューリスティックと根気
* clangとか頑張ってる

```
ERROR: expected tEnd before &#39;&lt;EOF&gt;&#39;
each do {}
          ^
```


# エラー回復
-------------

* シンタックスハイライターは壊れた文法も解析しないといけない
* 1回のコンパイルでできるだけ多くのエラーメッセージを出したい
* シンタックスエラーから回復したい


# Cの易しさ
-----------

* エラーがあってもセミコロンまで読み飛ばせば回復出来る
  + CやJavaは結構コンパイラが教えてくれる
* そういう言語設計も大事


# 拡張方法

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# リードマクロ
--------------

* トークンレベルの拡張
* 特定の「文字」がきた時にユーザ定義関数を使ってパースする
* リテラルをユーザが定義することが出来る
  + 正規表現リテラルとか
  + [Common Lispの正規表現](http://weitz.de/cl-interpol/)


# マクロ
--------

* ASTレベルの拡張
* LispとかScalaとかRustとか
  + Lispは自由度が高い
  + 関数マクロはないよりマシ程度
* ~衛生性~
* [マクロについて整理してみる | κeenのHappy Hacκing Blog](//KeenS.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru/)


## Cのマクロ
------------

* プリプロセッサなのでコンパイラの拡張ではない
* プリプロセッサ自体レキサを持つ
  + パーサとレキサを分ける意味
* ASTに関知しないのでやりたい放題


# 中置演算子
-----------

* 新しい中置演算子と優先順位を定義できる言語は多い
  + Haskell, SML, Prolog…
* パーサをその場で書き換えるのは難しいので後で処理する
  + [\[コンパイラ\]\[Haskell\]\[OCaml\] Haskellのinfixの仕組み - mad日記](http://d.hatena.ne.jp/MaD/touch/20090108)
* シンタックスのプラグインをセマンティクスに入れてるのでちょっと無茶


# 中置演算子
-----------

* 人間が同時に覚えられるのは3つまで
  + 優先順位がいくつもあっても覚えられない
  + 優先度40とか900とか無理。
* 本質はAST
  + 文法に問題を抱えるくらいならS式を使え


# Coq
-----

Coqは謎のテクノロジーにより `Notation`を使えば新しい文法を定義出来る

```coq
Notation &#34;&#39;SKIP&#39;&#34; :=
  CSkip.
Notation &#34;X &#39;::=&#39; a&#34; :=
  (CAss X a) (at level 60).
Notation &#34;c1 ; c2&#34; :=
  (CSeq c1 c2) (at level 80, right associativity).
Notation &#34;&#39;WHILE&#39; b &#39;DO&#39; c &#39;END&#39;&#34; :=
  (CWhile b c) (at level 80, right associativity).
Notation &#34;&#39;IFB&#39; e1 &#39;THEN&#39; e2 &#39;ELSE&#39; e3 &#39;FI&#39;&#34; :=
  (CIf e1 e2 e3) (at level 80, right associativity).

Definition fact_in_coq : com :=
  Z ::= AId X;
  Y ::= ANum 1;
  WHILE BNot (BEq (AId Z) (ANum 0)) DO
    Y ::= AMult (AId Y) (AId Z);
    Z ::= AMinus (AId Z) (ANum 1)
  END.
```
  

# 雑な話題

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# テスト
-------

* ASTのテストは案外難しい
  + 微妙な仕様変更で結果が変わる
  + でも言語の動作には関係なかったり

1. あきらめる
2. 不屈の精神でテストを直し続ける
3. 木に対するクエリ言語を使う


# 先読みと副作用
--------------

* 先読みしてバックトラックすると副作用があった時に困る
  1. 副作用を許さない
  2. 副作用は自己責任
  3. 一旦先読みで正しいパスを記憶してから正しいパスでもう一度パース
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Clojureおじさん</title>
      <link>/slide/Clojureojisan/</link>
      <pubDate>Mon, 22 Jun 2015 22:53:39 +0900</pubDate>
      
      <guid>/slide/Clojureojisan/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Clojureおじさん
----------------------
サイバーエージント新卒  
第5回 Fresh勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# Clojure 
---------

* 2007年から
* JVMで動くLisp系言語
* 函数型
* 動的型付き
* 値は基本immutable
* 遅延シーケンス
* STMがあり、並列処理に強い


# Hello World
-------------

```clojure
(println &#34;Hello, World&#34;)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# JVM
------
## Javaのコードをシームレスに呼べる

* `obj.method()` ではなく `(.method obj)`
* `Class.staticField` ではなく `Class/staticField`
* `obj.method1().method2()` ではなく `(.. obj method1 method2)`


# JVM
-----

```clojure
(.println System/out &#34;Hello JVM&#34;)
```

```clojure
(Math/random)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Immutable
-----------

* 状態を持たないのでコードの見通しが良い
  + 並列で考える時には重要
  + 複雑さだけでなく不整合などバグの原因になりやすい
* 変更可能な値もある
  + それらはトランザクション内でのみ変更可能
  + 不整合が起きない


# 函数型
--------

```clojure
(filter odd? (map #(+ 1 %) &#39;(1 2 3)))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 遅延シーケンス
---------------

```clojure
(def natural_number (iterate inc 1))
(take 5 natural_number) ;=&gt; (1 2 3 4 5)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# リスト内包表記
----------------

```clojure
(for [x (range 5)] (* x x))
;=&gt; (1 4 9 16 25)
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;


#並列処理に強い
---------------

* 簡単にはJavaのスレッドを呼べばいい
  + Clojureの関数は全てCallableでRunnablea

```clojure
(.start (Thread. (fn [] 
                   (Thread/sleep 1000)
                   (println &#39;foo))))
```


#並列処理に強い
---------------
## core.async

* goroutineとgochannelが使える


## core.async
-------------

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (go (&gt;! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! (go (&lt;! c)))))
  (close! c))
```

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (thread (&gt;!! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! c)))
  (close! c))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 今回紹介し切れなかったの
-------------------------

* マクロ
* メタデータ
* protocolとかの多態性
* ClojureScript/Om
* Typed Clojure


# まとめ
--------

* Clojureを使えばJavaが使える
* Clojureを使えばPythonのリスト内包表記が使える
* Clojureを使えばGoのgoroutine/gochannelが使える



&lt;span style=&#34;font-size:200%;&#34;&gt;Why not start Clojure?&lt;/span&gt;
&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lisp処理系拡張の探求 SBCLのマルチスレッドサポート</title>
      <link>/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</link>
      <pubDate>Sat, 20 Jun 2015 18:30:52 +0900</pubDate>
      
      <guid>/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
### Common Lisp 処理系拡張の探求
SBCLのマルチスレッドサポート

----------------------
Lisp Meet Up #29

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# CLのマルチスレッド
----------------------------
## [bordeaux-threads](https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation)
* 色々な処理系のマルチスレッドサポートの抽象レイヤー
* デファクトスタンダード
  + スレッド
  + ロック
  + コンディションヴァリアル


# SBLCのマルチスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# SBLCのマルチスレッド
----------------------------

* スレッド
  + スレッド内エラー
* アトミック操作&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
  + CAS&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* 排他制御（ロック）
* セマフォ
* コンディションヴァリアル
* バリア
* キュー&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* メールボックス&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* ゲート&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* frlock&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;


# アトミック操作

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# アトミック操作
----------------
複雑な動作は同じデータに並行に動かすと壊れうる

```
        [var = 1]
[incf]      |      [decf]
 [1]&lt;-------|
  |         |------&gt;[1]
 [2]---&gt;[var = 2]    |
            |        | 
        [var = 0]&lt;--[0]
```

# アトミック操作
----------------

* `atomic-{incf, decf}`
  + 動作出来る場所が限られている
* `atomic-{pop, push, update}`
  + CASプロトコルを実装していればどこでも


# CASプロトコル
---------------
* compare and swap
* アトミック操作の基本中の基本
  + ハードウェアレベルのサポート
* ざっくり言うと並行版setf
* `(cas place old new env)`
  + もし`place`が`old`に等しければ`new`を代入
* `(defun (cas foo) (old new))`
  + `cas`版の`setf`定義
* 他にも`setf`相当の機能は揃ってる

# CASプロトコル
---------------

```lisp
(defvar *foo* nil)

(defun (cas foo) (old new)
  (cas (symbol-value &#39;*foo*) old new))
```


# キュー
--------

* 普通のキュー
* スレッドセーフ
* `enqueue`, `dequeue`が基本操作
* `dequeue`が多値で、ブロックしない
  + 空なら第二値がnilになる


# メールボックス
---------------

* キューとほぼ同じ
* スレッドセーフ
* `send-message`, `recieve-message`が基本操作
* `recieve-message`はブロックする
  + タイムアウトも設定出来る
* `recieve-message-no-hangはdequeue`と同じ挙動
* `recieve-pending-messages`もある


# ゲート
--------

* 複数のスレッドが1つのイベントを待つ時に使う
* `wait-on-gate`, `open-gate`, `close-gate`が基本操作


```
[gate (closed)]  [T1] [T2] [T3]
     |            |    |    |
     |     wait   |    |    |
     |&lt;----------------+----+
     |            |    .    .
     |     open   |    .    .
[gate (opened)]&lt;--+    .    .
     +----------------&gt;+---&gt;+
         go            |    |
                       V    V
```


# frlock
--------

* Fast Read Lock
* またの名をRead-Write Lock
* Read Lockは多重に取れる。Write Lockは1つしか取れない。
* 基本操作は`frlock-read`と`frlock-write`
* 普通のlockと違って複数のReadが速くなる


# まとめ
--------

* SBCLのマルチスレッドサポートはbordeaux-threadsよりもリッチ
* 処理系の独自サポート面白い
* 処理系に依存してしまってもいいんじゃないだろうか
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ボトルネックのイイ話</title>
      <link>/slide/botorunekkunoiihanashi/</link>
      <pubDate>Thu, 04 Jun 2015 00:03:14 +0900</pubDate>
      
      <guid>/slide/botorunekkunoiihanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ボトルネックのイイ話
----------------------
サイバーエージェント15新卒  
FRESH勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# ボトルネック
-------------

&gt; ボトルネック (bottleneck) とは、システム設計上の制約の概念。英語の「瓶の首」の意。一部（主に化学分野）においては律速（りっそく、「速さ」を「律する（制御する）」要素を示すために使われる）、また『隘路（あいろ）』と言う同意語も存在する。 


# Webアプリの主な登場人物
------------------------

* リバースプロキシ
* アプリケーションサーバ
* データベース


![relation of reverse proxy, app and DB](/images/webapp.png)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# レスポンスタイムとスループット
------------------------------

* レスポンスタイム 
  + リクエストを投げてレスポンスが返ってくるまでの時間
  + ユーザから見たメトリクス
* スループット&lt;!-- .element: class=&#34;fragment highlight-red&#34;--&gt;
  + 一定時間内にシステムがどれだけのリクエストを捌けるか
  + 中の人から見たメトリクス


# スループット
-------------

* スループットの最大 ≒ リソースの限界
  + ネットワーク帯域
  + ディスクIO
  + メモリ使用量
  + CPU負荷
* リソースのどれか1つでも限界になったらそれ以上パフォーマンスは上がらない

# パフォマンスの目安
-------------------

* ネットワーク帯域: bpsで表わす。NICによるが 1Gbpsとか
* CPU: パーセンテージで表わす。100xコア数が最大マシンに依る。
* メモリ: Bで表わす。ピンキリだが1GB ~ 128GBくらい？
* ディスクIO: Bpsで表わす。HDDなら 100Bpsとか。SSDなら10倍くらい。

テキトーに調べたので間違ってるかも

# 誰が何を
---------

* リバースプロキシ: ネットワーク、メモリ、CPUなど
* アプリケーションサーバl: CPU、メモリなど
* データベース: CPU、ディスクIOなど


&lt;span style=&#34;font-size: 200%&#34;&gt;「CPUは100%に行ってないのにアプリケーションが遅いんだよ」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* ボトルネックはCPUとは限らない
* 他のメトリクスも一緒に見るべき


# 推測するな。計測せよ
---------------------

* 実際に測ってみないとどこがボトルネックか分からない
* 何をしてどれくらいパフォーマンスが上がったのかも分からない
  + コストパフォーマンスも重要


&lt;span style=&#34;font-size: 200%&#34;&gt;「パフォーマンスが悪いからCPUをグレードアップしよう」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* ボトルネックはCPUとは限らない
* 例えばネットワーク帯域が詰まっているのにCPUを改善しても意味がない
* 帯域が詰まってるならデータを減らす、NIC（マシン）を増やすなどをする


&lt;span style=&#34;font-size: 200%&#34;&gt;「多分アプリケーションを高速化したよ」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* 計測せずに高速化しても意味がない
  + テストの無いリファクタリングがただの破壊なのと同じ
* 高速化した気になって実際はコードが汚なくなっただけの可能性もある

# ボトルネックは変わりうる
------------------------

* 一箇所をずっと改善してても意味がない
* ある程度改善したら次のリソースの限界がきてるかもしれない

&lt;span style=&#34;font-size: 200%&#34;&gt;「アプリケーションを10倍高速化したのにあんまり速くなってない」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* 10倍くらい極端に高速化すると次のリソースがボトルネックになる
* ディスクやネットワークの改善を考えるべき

# リソースの食い合い
-------------------

* 1マシンで完結している場合、リソースの食い合いが発生しうる
  + リバースプロキシとアプリケーションがCPUを食い合うとか
* この時、どのようにして解決するのが適切か？

# 例題
------

* アプリが80%くらいの負荷
* Rプロキシが20%くらいの負荷


# 例題
------

1. アプリが多くCPUを喰ってるからアプリを高速化すべき
2. アプリが多くCPUを必要としてるからRプロキシはアプリにCPUを譲るべき

# 例題
------

1. アプリが多くCPUを喰ってるからアプリを高速化すべき
2. &lt;span style=&#34;color: #aaa;&#34;&gt;アプリが多くCPUを必要としてるからRプロキシはアプリにCPUを譲るべき&lt;/span&gt;

# アムダールの法則
-----------------

* [アムダールの法則 - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%A0%E3%83%80%E3%83%BC%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87)
* ざっくり言うと比率の小さな部分を高速化しても全体の高速化は高が知れてる

&lt;span style=&#34;font-size: 200%&#34;&gt;「ORマッパ使うと遅そうだから生のSQL使おう」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* ORマッピングにかかるコストは微小
* 他にもっと効率的に改善出来る部分に手をつけるべき

# リソースの配分
---------------

* 逆に、与えられたリソースからどれをどこに割り当てるかの問題もある
* 理論的には負荷の高い部分に多くリソースを割り当てれば良い。
* しかしアプリケーションの構成を先に決めないといけないので事前に計測は出来ない
  + 知識と経験と勘

# 例題
------

* 画像配信アプリケーション
* VPS5台 
  + ネット1Mbps/メモリ1G/CPU4コア/HDD
* Rプロキシ、アプリ、DBにそれぞれ何台割り当てる？
  + 1つのマシンに複数機能を持たせても良い。

# チューニングは難しい
---------------------

* 様々な部分の知識が必要
* システム全体を見渡した設計力も大事
* 細かなチューニングテクニックも一杯
  + 今回話してないが、キャッシュ戦略とかも
  + Cache-Control
* 知識がないと計測しても数値の意味が分からない

&lt;span style=&#34;font-size: 200%&#34;&gt;「やった。5%高速化した」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* パフォーマンスは計測の度にゆらぎがある
* 5%くらいなら普通に測定誤差の範囲内
* 逆に、5%くらいの改善をしても意味がない

# チューニングは楽しい
---------------------

* パズルゲームみたいな部分もある
* チューニング次第でスループット何十倍とかいく
* 難しい分一気にパフォーマンスが上がると喜びも一入

# ISUCON

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ISUCON
--------

* [ISUCON公式Blog](http://isucon.net/)
* Webアプリケーションチューニングコンテスト
* 優勝賞金100万円
* 何でもアリ。どこをいじってもいい。
* 要はさっきの知識をフルで活用出来る


# ISUCON
--------

* 何でもアリは実は珍しい。
  + 他はデータベースのみ、とかアプリは触っちゃだめ、とか雁字搦め
* 前回は185組（1チーム2~3人）の大きな大会
  + 予選で27チームに絞られる
* 界隈の有名人が揃う天下一武闘会の様相
* 楽しい


# 良質な問題
-----------

* 過去問は教育的な問題が多数。
* 過去問は全て公開。
* 腕試しに丁度良い。

# 今年のISUCON
--------------

* 予選 9/26,27
* 本戦 10/31
* 2~3人のチーム
* Google Cloud Platform
* 出題は[@tagomoris](https://twitter.com/tagomoris)さんと[@kamipo](https://twitter.com/kamipo)さん


&lt;span style=&#34;font-size: 300%&#34;&gt;Let&#39;s ISUCON&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 参考
------
* [ISUCONで学ぶ Webアプケーションのパフォーマンス向上のコツ 実践編 完全版](http://www.slideshare.net/kazeburo/isucon-summerclass2014action2final)
* [ISUCONの話(夏期講習2014)](http://www.slideshare.net/tagomoris/isucon2014)
* [kamipoさんはすごい人](https://twitter.com/search?q=kamipo%E3%81%95%E3%82%93%E3%81%AF%E3%81%99%E3%81%94%E3%81%84%E4%BA%BA&amp;src=typd&amp;vertical=default&amp;f=tweets)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Transducerについて</title>
      <link>/slide/transducernitsuite/</link>
      <pubDate>Wed, 03 Jun 2015 22:29:50 +0900</pubDate>
      
      <guid>/slide/transducernitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Transducerについて
----------------------
サイバーエージェント  
朝の3分スピーチ
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# Transducerって？
------------------

* Clojure 1.7で入るフレームワーク
* 関数のパイプライン化を簡単にする
* 入力、出力には依存しない


# Reduce関数について
-------------------

* `reduce: (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* `(&#39;a -&gt; &#39;b -&gt; &#39;a)` でシーケンスを集約する
* `(reduce + 0 &#39;(1 2 3)) ;=&gt; 6`
* 要はreduceは関数を使って集約する。

# Transducerについて
-------------------

* `transduce:((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a)) (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* 集約関数を変換する関数もとる
* `(transduce xf + 0 &#39;(1 2 3))`
* transducerで集約する前に処理を挟める

# すごいところ
-------------------------
## コンポーサビリティ

* `((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a))`
* 変換関数は入力と出力が同じ。
* つまり変換関数を合成出来る
* ex) `(comp (filter odd?) (map inc))`


# すごいところ2
--------------------------
## 汎用性

* 各関数は入力や出力について知る必要はない
  + シーケンスではなく要素に対して定義される
* シーケンスだけでなく遅延シーケンス、ストリーム、チャネルなどなどにも使える
* 中間シーケンスを作らない
  + 遅延シーケンスやストリームには大きなメリット
* 集約先をシーケンスなどにすることも出来る
  + 関数の汎用性が上がる

# すごいところ3
--------------
## 並列/非同期

* core.asyncもtransducerをサポート
* 各変換関数を並列/非同期に実行が可能
* さらに各関数に割り当てるプロセッサの数も細かく制御出来る


&lt;span style=&#34;font-size: 500%;&#34;&gt;変換して&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 500%;&#34;&gt;集約する&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 300%;&#34;&gt;何かに似てない？&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 600%;&#34;&gt;MapReduce&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; ozaさんの近しい環境というとHadoop...多段Mapreduceをtransdecerみたいにしようってはなしとかですか？&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605368356393218048&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; まさにその通りです．MapReduce には Combiner という中間集約をする API があるのですが，それをもっと汎用的にしようという話です． &lt;a href=&#34;http://t.co/injEiPjePG&#34;&gt;http://t.co/injEiPjePG&lt;/a&gt;&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605369771505221633&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; すごい楽しそうですね。Clojure向けのAPIがtransducerのバッグエンドになって普段書いてるコードがそのままHadoopで動いたりしたら、とか夢が無限に広がります&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605370461476646912&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; おお，その案は良いですね！！&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605370619509637121&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 200%;&#34;&gt;Clojure 1.7 + Transducer&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 400%;&#34;&gt;Comming Soon&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 参考
------
* [Clojure 1.7のtransducersを動かしてみよう - Qiita](http://qiita.com/tokomakoma123/items/1ca3fb0dddc5b901b032)
* [core.async+transducers Shibuya.lisp #21](http://www.slideshare.net/ktsujister/coreasynctransducers-shibuyalisp-21)
* [Hadoop Combinerメモ(Hishidama&#39;s Hadoop Combiner Memo)](http://www.ne.jp/asahi/hishidama/home/tech/apache/hadoop/Combiner.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>