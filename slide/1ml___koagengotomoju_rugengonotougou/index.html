<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="1ML - コア言語とモジュール言語の統合 | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="&lt;a src=&#39;https://connpass.com/event/63454/&#39;&gt;型システム論文読書会 Vol.1&lt;/a&gt;での発表用. &lt;a src=&#39;https://people.mpi-sws.org/~rossberg/1ml/1ml.pdf&gt;1ML – Core and Modules United (F-ing First-Class Modules)&lt;/a&gt;についてざくっと解説" />

        <title>1ML - コア言語とモジュール言語の統合 | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href="//KeenS.github.io/reveal.js/css/reveal.css">
        <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css'>
        <link rel="stylesheet" href="//KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="//KeenS.github.io/css/liquorice.css" />
        <link rel="stylesheet" href="//KeenS.github.io/highlight.js/styles/agate.css">
        <link rel="stylesheet" href="//KeenS.github.io/css/cleanveal.css" type="text/css" />
        <link rel="apple-touch-icon" sizes="180x180" href="//KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="//KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="//KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <link rel="apple-touch-icon-precomposed" href="//KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="alternate" href="" type="application/rss+xml" title="κeenのHappy Hacκing Blog" />
        
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script>
         if( window.location.search.match( /print-pdf/gi ) ) {
             var link = document.createElement( 'link' );
             link.rel = 'stylesheet';
             link.type = 'text/css';
             link.href = '\/\/KeenS.github.io\/reveal.js/css/print/pdf.css';
             document.getElementsByTagName( 'head' )[0].appendChild( link );
         }
        </script>
        
    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="//KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="//KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="//KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






<article id="article-container" class="li-article" style="height: 100%">
    <header id="article-header" class="li-article-header" style="position:fixed;z-index:10;">
        <h1 class="li-article-title">1ML - コア言語とモジュール言語の統合</h1>
        <div class="li-article-meta">
    <time class="li-article-date">2017-09-24</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="//KeenS.github.io/categories/ml">ML</a>
        </li>
    
        <li>
            <a href="//KeenS.github.io/categories/%e5%9e%8b">型</a>
        </li>
    
</ul>

</div>

    </header>
    <div class="reveal">
        <div class="slides">
            <!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="about-me">About Me</h1>
<hr>
<p><img src="//KeenS.github.io/images/kappa.png" alt="κeenのアイコン"> <!-- raw HTML omitted --></p>
<ul>
<li>κeen</li>
<li><a href="https://twitter.com/blackenedgold">@blackenedgold</a></li>
<li>Github: <a href="https://github.com/KeenS">KeenS</a></li>
<li><a href="https://idein.jp/">Idein Inc.</a>のエンジニア</li>
<li>Lisp, ML, Rust, Shell Scriptあたりを書きます</li>
<li>型システム初心者です</li>
<li>論文初心者です
===</li>
</ul>
<h1 id="ml">MLのモジュールについておさらい</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading">モジュール、シグネチャ</h1>
<hr>
<ul>
<li>ストラクチャは型、関数、値をまとめたもの
<ul>
<li>なんかレコードっぽい</li>
</ul>
</li>
<li>シグネチャはその型</li>
<li>モジュールはシグネチャを充足すればよい（余計なフィールドがあってもよい）
<ul>
<li>もちろん余計なフィールドは隠蔽される
===</li>
</ul>
</li>
</ul>
<pre><code class="language-sml" data-lang="sml">signature S = sig
    type t
    val f: t -&gt; t
    val zero: t
end

structure M: S = struct
    type t = int
    fun f x = x
    val zero = 0
    fun g x = x
end
</code></pre><p>===</p>
<h1 id="heading1">ファンクタ</h1>
<hr>
<ul>
<li>ストラクチャを引数にとってストラクチャを返す
<ul>
<li>なんか関数っぽい</li>
</ul>
</li>
<li>受け取ったモジュールに依存して型が変わったりする</li>
</ul>
<p>===</p>
<pre><code class="language-sml" data-lang="sml">functor F(X: sig type 'a t end):
        sig
            type 'a t
            val id: 'a t -&gt; 'a t
        end
= struct
    open X
    fun id x = x
end
</code></pre><p>===</p>
<h1 id="include"><code>include</code></h1>
<hr>
<ul>
<li>なんかシグネチャをincludeできちゃう</li>
<li>ストラクトもopenできちゃう</li>
</ul>
<p>===</p>
<pre><code class="language-sml" data-lang="sml">signature T = sig
    include S
    val g: t -&gt; t
end

structure N : T
= struct
    open M
    fun g x = x
end
</code></pre><p>===</p>
<h1 id="heading2">オペーク</h1>
<hr>
<ul>
<li>シグネチャの型をトランスパレントにするかオペークにするか選べる</li>
<li><code>M: S</code> vs <code>M :&gt; S</code></li>
<li>オペークなストラクチャの型は存在型になる</li>
<li><code>:&gt;</code> をsealing operatorというらしい</li>
<li>transparent(透明)とopaque(不透明)があるのでtranslucent(半透明)と呼ぶひともいるとかいないとか</li>
</ul>
<p>===</p>
<pre><code class="language-sml" data-lang="sml">structure M: S = struct ... end
val _ = M.f 1 (* Ok *)
</code></pre><pre><code class="language-sml" data-lang="sml">structure M:&gt; S = struct ... end
val _ = M.f 1 (* Error *)
</code></pre><p>===</p>
<h1 id="sharing"><code>sharing</code></h1>
<hr>
<ul>
<li>2つの型が同じである制約を書ける
<ul>
<li>refinement??</li>
</ul>
</li>
<li>オペークな型に使うと便利</li>
<li>型が別のストラクチャのフィールドに依存するようになる</li>
</ul>
<p>===</p>
<pre><code class="language-sml" data-lang="sml">signature X = sig
    structure M: sig type t end
    type t
    sharing type t = M.t
end
</code></pre><p>===</p>
<h1 id="generative-vs-applicative">Generative vs Applicative</h1>
<hr>
<ul>
<li>同じストラクチャを同じファンクタを通したものは同じもの？違うもの？</li>
<li>Generative → 違うもの</li>
<li>Applicative → 同じもの</li>
<li>SMLはGenerative</li>
<li>OCamlはApplicative（らしい）</li>
</ul>
<p>===</p>
<pre><code class="language-sml" data-lang="sml">(* 再掲 *)
signature S = sig
    type t
    val f: t -&gt; t
    val zero: t
end

functor Id(X: S):&gt; S
= struct
    open X
end

structure M1 = Id(M)
structure M2 = Id(M)

val _ = M1.f M2.zero (* Error *)
</code></pre><p>===</p>
<h1 id="1ml--core-and-modules-united-fing-firstclass-moduleshttpspeoplempiswsorgrossberg1ml1mlpdf"><a href="https://people.mpi-sws.org/~rossberg/1ml/1ml.pdf">1ML – Core and Modules United (F-ing First-Class Modules)</a></h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading3">落合先生のフォーマット</h1>
<hr>
<ul>
<li>どんなもの？
<ul>
<li>→ MLのコア言語とモジュール言語を1つの言語に統一</li>
</ul>
</li>
<li>先行研究と比べてどこがすごい？
<ul>
<li>→ 第一級モジュールでありながら型が決定可能かつ型推論もある</li>
</ul>
</li>
<li>技術や手法のキモはどこ？
<ul>
<li>→ System Fωに変換した、型にsmallとlargeの区別を入れた</li>
</ul>
</li>
<li>どうやって有効だと検証した？
<ul>
<li>証明、実装</li>
</ul>
</li>
<li>議論はある？
<ul>
<li>完全には型推論されないなど</li>
</ul>
</li>
<li>次に読むべき論文は？
<ul>
<li><a href="https://people.mpi-sws.org/~dreyer/courses/modules/f-ing.pdf">F-ing Modules</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-319-30936-1_18">1ML with Special Effects | SpringerLink</a> WadlerFest 2016. Extends 1ML with effect polymorphism and generativity polymorphism.
===</li>
</ul>
</li>
</ul>
<h1 id="1ml">1MLの論文</h1>
<ul>
<li>論文 A. Rosburg. <a href="http://dl.acm.org/citation.cfm?id=2784738">1ML – core and modules united (F-ing first-class modules)</a>. In ICFP, 2015.</li>
</ul>
<ul>
<li><a href="https://people.mpi-sws.org/~rossberg/1ml/">https://people.mpi-sws.org/~rossberg/1ml/</a></li>
</ul>
<ul>
<li>拡張（次に読む）<a href="https://link.springer.com/chapter/10.1007/978-3-319-30936-1_18">1ML with Special Effects | SpringerLink</a> WadlerFest 2016. Extends 1ML with effect polymorphism and generativity polymorphism.</li>
<li>ベースになるやつ<a href="https://people.mpi-sws.org/~dreyer/courses/modules/f-ing.pdf">F-ing Modules</a>
<ul>
<li><a href="https://people.mpi-sws.org/~rossberg/f-ing/">https://people.mpi-sws.org/~rossberg/f-ing/</a></li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="abstract">Abstract</h1>
<hr>
<ul>
<li>MLには2つの言語がある。コア言語とモジュール言語
<ul>
<li>コア: 型、式</li>
<li>モジュール: シグナチャ、ストラクチャ、ファンクタ</li>
</ul>
</li>
<li>コア言語の上の層にモジュール言語がある感じ</li>
<li>それぞれを分離せずに扱えたら便利
<pre><code>module Table = if size &gt; threshold
               then HashMap
               else TreeMap
</code></pre></li>
</ul>
<p>===</p>
<h1 id="abstract-cont">Abstract (Cont.)</h1>
<hr>
<ul>
<li>1MLでそれを実現した
<ul>
<li>関数とファンクタと型コンストラクタが同じ表現</li>
<li>レコードとタプルとstructも同じ表現</li>
<li>てかほとんどをモジュールにエンコードする</li>
</ul>
</li>
<li>System Fωにエンコードできる程度の表現能力
<ul>
<li>依存型までは使わない</li>
<li>元々あったF-ing modulesの拡張</li>
</ul>
</li>
<li>ある意味ではSystem Fωのシンタックスシュガーと捉えることもできる</li>
<li>ある程度の型推論もある</li>
</ul>
<p>===</p>
<h1 id="1-intro--">1. Intro - 既存研究からの流れ</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="packaged-modules">packaged modules</h1>
<hr>
<ul>
<li>ocamlで採用されてるやつ</li>
<li>first class moduleではない
<ul>
<li>module &lt;-&gt; 値は手でやる</li>
</ul>
<pre><code>module Table = (val (if size &gt; threshold
                     then (module HashMap : MAP)
                     else (module TreeMap : MAP)) : MAP)
</code></pre></li>
<li>type sharingも弱い
<ul>
<li><code>f : (module S with type t = ’a) → (module S with type t = ’a) → ’a</code></li>
<li>本来はこう書きたい<code>f : (X : S) → (S with type t = X.t) → X.t</code></li>
<li>タイプコンストラクタに至ってはそもそも表現できない</li>
</ul>
</li>
<li>→ もうちょっとリッチなのが欲しい</li>
</ul>
<p>===</p>
<h1 id="first-class-modules">first class modules</h1>
<hr>
<ul>
<li>もしコアとモジュールの区別を完全になくしたら？</li>
<li>なんかオペーク型にファンクタがきたりエグそう</li>
<li>実際<a href="https://dl.acm.org/citation.cfm?id=176927">型が決定不能</a>
<ul>
<li>ファンクタと反変関数とサブタイプとopaqueのせい</li>
<li>opaqueを任意の型でサブタイプできるとマズいらしい</li>
</ul>
</li>
<li>実用上も諸々問題ある
<ul>
<li>サブタイピングが入るとユニフィケーションが…とか</li>
<li>型が束にならないので扱いづらいとか</li>
</ul>
</li>
<li>→ リッチすぎると崩壊する</li>
</ul>
<p>===</p>
<h1 id="first-class-modules1">first class modules</h1>
<hr>
<pre><code>type T = {type A; f : A → ()}
type U = {type A; f : (T where type A = A) → ()}
type V = T where type A = U
g (X : V) = X : U   (* V ≤ U ? *)

</code></pre><p>===</p>
<h1 id="fing-modules">F-ing modules</h1>
<hr>
<ul>
<li>これ自体はfirst class modulesではない
<ul>
<li>論文内のapplicationでpackaged first class moduleに言及はしている</li>
</ul>
</li>
<li>moduleをF(ω)にエンコードすることに成功
<ul>
<li>元々モジュールは<a href="https://people.mpi-sws.org/~dreyer/courses/modules/macqueen86.pdf">依存型ベースの議論がされていた</a></li>
<li>ファンクタがApplicativeだとωが必要らしい</li>
</ul>
</li>
<li>→F(ω)にエンコードできるのならある程度first-classに扱えるのでは？</li>
</ul>
<p>===</p>
<h1 id="1ml1">1ML</h1>
<hr>
<ul>
<li>moduleをfirst classに扱いつつFωにエンコードすることに成功
<ul>
<li>但し一部にsmall typeしか使えない制約がある</li>
</ul>
</li>
<li>既存のモジュールは不整合を防ぐための「構文的」制約が強すぎる→「意味論的」制約に緩和</li>
<li>コア言語の方はSystem F</li>
<li><a href="https://dl.acm.org/citation.cfm?id=169696">small typeとlarge type</a>に区別(カインドとは言わないんだね)</li>
<li>small typeの推論はほぼできる（レコード幅についてのみ注釈必要）
<ul>
<li>実用上まあ、しゃあないよね</li>
<li>SMLもレコード注釈必要な場面あるしね</li>
</ul>
</li>
<li>large typeは注釈必要
<ul>
<li>モジュールも元々そうだしね</li>
</ul>
</li>
</ul>
<p>===</p>
<h2 id="1mlcontribution">1MLのContribution</h2>
<hr>
<ul>
<li>First-Class Moduleをもちつつ決定可能な型システムの構築</li>
<li>それのSystem Fωへのエンコード</li>
<li>Damas/Milner-styleの型推論</li>
<li>これらを使ったML方言の設計</li>
</ul>
<p>===</p>
<h1 id="2-1ml-with-explicit-types">2. 1ML with Explicit Types</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="1ml-with-explicit-types">1ML with Explicit Types</h1>
<hr>
<ul>
<li>(4ページ目のFigure 1参照)</li>
<li>bool型の他はレコード、関数、<code>type</code>型、transparent型、sharing制約など</li>
<li>関数はpureとimpureに分かれる</li>
<li><code>let</code>がレコードなどほとんどの構文は糖衣になってる
<ul>
<li><code>(fun (n : int) ⇒ n + n) 3</code></li>
<li>→ <code>let f = fun (n : int) ⇒ n + n; x = 3 in f x</code></li>
<li>→ <code>{f = fun (n : int) ⇒ n + n; x = 3; body = f x} .body</code></li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading4">どんなコードが書けるか</h1>
<hr>
<ul>
<li>Functional Core</li>
<li>Reified Types</li>
<li>Translucency</li>
<li>Functor</li>
<li>Applicative vs Generative</li>
<li>Higher Order Polymorphism</li>
<li>Computed Modules</li>
<li>Recursion</li>
<li>Impredicativity Reloaded</li>
</ul>
<p>===</p>
<h2 id="reified-types">Reified Types</h2>
<hr>
<ul>
<li>多相型やタイプコンストラクタなど</li>
<li>匿名モジュールの省略記法とも捉えられる</li>
</ul>
<pre><code>id = fun (a : type) ⇒ fun (x : a) ⇒ x
</code></pre><pre><code>pair = fun (a : type) ⇒ fun (b : type) ⇒ type {fst : a; snd : b}
second = fun (a : type) ⇒ fun (b : type) ⇒ fun (p : pair a b) ⇒ p.snd
</code></pre><p>===</p>
<h2 id="translucency">Translucency</h2>
<ul>
<li>opaque: 型が<code>type</code>で詳細が分からない</li>
<li>transparent: 型の詳細が<code>(= type ...)</code>で書いてある
<ul>
<li><code>(= E)</code> はシングルトン型。</li>
<li><code>(= E)</code> は <code>E</code> のサブタイプだって。</li>
</ul>
</li>
</ul>
<pre><code>size : type
pair : (a : type) ⇒ (b : type) ⇒ type
</code></pre><pre><code>size : (= type int)
pair : (a : type) ⇒ (b : type) ⇒ (= type {fst : a; snd : b})
</code></pre><p>===</p>
<h2 id="functor">Functor</h2>
<hr>
<ul>
<li>だいたいMLっぽいシンタックスで書ける</li>
<li><code>empty a : map a;</code>が<code>empty : (a : type) ⇒ map a</code>などの構文糖がある</li>
<li>なんか引数の型に依存してるっぽいけど後で消える</li>
<li>sealing operatorがある</li>
<li>type refinement syntaxがある</li>
</ul>
<p>===</p>
<pre><code>type EQ = {
  type t;
  eq : t → t → bool
};

type MAP = {
  type key;
  type map a;
  empty a : map a;
  add a : key → a → map a → map a;
  lookup a : key → map a → opt a
};

</code></pre><p>===</p>
<pre><code>Map (Key : EQ) :&gt; MAP where (type .key = Key.t) = {
  type key = Key.t;
  type map a = key → opt a;
  empty a = fun (k : key) ⇒ none a;
  lookup a (k : key) (m : map a) = m k;
  add a (k : key) (v : a) (m : map a) =
    fun (x : key) ⇒ if Key.eq x k then some a v else m x : opt a
}

</code></pre><p>===</p>
<h2 id="applicative-vs-generative">Applicative vs Generative</h2>
<hr>
<ul>
<li>基本的にはSMLスタイルのGenerative Functor
<ul>
<li>全てApplicativeだと面倒毎が起こるらしい</li>
<li>First-Class moduleとコンフリクトするとかなんとか</li>
</ul>
</li>
<li>型コンストラクタも内部ではFunctor
<ul>
<li><code>pair a b</code>とかもFunctor</li>
<li>型コンストラクタはApplicativeであってほしい</li>
</ul>
</li>
<li>→ 関数にPureとImpureの区別を付ける
<ul>
<li>pure(<code>=&gt;</code>) はapplicative</li>
<li>impure(<code>-&gt;</code>) はgenerative</li>
</ul>
</li>
<li>ひとまずコア言語の方は全て<code>impure</code>で議論</li>
</ul>
<p>===</p>
<h2 id="higher-order-polymorphism">Higher Order Polymorphism</h2>
<hr>
<ul>
<li>コアにSystem F採用したからやりたい放題</li>
</ul>
<pre><code>f (id : (a : type) ⇒ a → a) = {x = id int 5; y = id bool true}
</code></pre><pre><code>type SHAPE = {type t; area : t → float; v : t}
volume (height : int) (x : SHAPE) = height * x.area (x.v)
</code></pre><p>===</p>
<h2 id="higher-order-polymorphism1">Higher Order Polymorphism</h2>
<hr>
<pre><code>type COLL c = {
  type key;
  type val;
  empty : c;
  add : c → key → val → c;
  lookup : c → key → opt val;
  keys : c → list key
};
entries c (C : COLL c) (xs : c) : list (C.key × C.val) = ...
</code></pre><p>===</p>
<pre><code>type MONAD (m : type ⇒ type) = {
  return a : a → m a;
  bind a b : m a → (a → m b) → m b
};
</code></pre><p>===</p>
<h2 id="computed-modules">Computed Modules</h2>
<hr>
<pre><code>Table = if size &gt; threshold then HashMap else TreeMap : MAP
</code></pre><p>===</p>
<h2 id="predicativity">Predicativity</h2>
<hr>
<ul>
<li><code>type</code>型はsmall type(型シグネチャに<code>type</code>型を持たない型、つまり単相型)にのみマッチできる
<ul>
<li>large typeは例えばこんなの<code>type T = (a : type) ⇒ {};</code></li>
</ul>
</li>
<li>この制約によって型が決定可能になってる</li>
<li>そもそもMLにはこんな制約は入ってるし既存のMLより表現力が劣ることはない</li>
<li>因みにTransparent Typeならこの制約はない</li>
</ul>
<p>===</p>
<h1 id="3-type-system-and-elaboration">3. Type System and Elaboration</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="1ml2">明示的型付き1ML</h1>
<hr>
<ul>
<li>(6ページのFigure 2, 3を参考に)</li>
<li>Fωに変換(elaborate)される
<ul>
<li>まずはSyntactic Type -&gt; Semantic Type</li>
<li>次にSemantic Type Directedにelaborate</li>
</ul>
</li>
<li>Fωは型の進行と保存が成り立つよ</li>
<li>この辺はF-ingを読みながらやった方がいいかも</li>
</ul>
<p>===</p>
<h2 id="semantic-types">Semantic Types</h2>
<hr>
<ul>
<li>(7ページの左上の図を参考に)</li>
<li>型は <code>Ξ = ∃ α. Σ</code> に変換されるよ
<ul>
<li>∃を外に出すことで依存型を避けてる</li>
</ul>
</li>
<li>基本的にレコードのフィールドに出てくる<code>type</code>を∃にして外に出す戦略</li>
<li>ただし関数の引数の位置では∀になる
<ul>
<li>返り値でもこのパラメータを参照することで依存型を避ける</li>
</ul>
</li>
<li>pure(applicative)とimpure(generative)で∃の位置が変わる
<ul>
<li>なんか<a href="https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%AC%E3%83%A0%E6%A8%99%E6%BA%96%E5%BD%A2">スコーレム標準形</a>にしたりして頑張るらしい</li>
</ul>
</li>
<li>transparent type <code>[= α]</code>もある</li>
</ul>
<p>===</p>
<h1 id="elaboration">Elaboration</h1>
<hr>
<ul>
<li>(8ページのFigure 4を参考に)</li>
<li>波矢印でelaboration規則</li>
<li>グレーの規則は値レベル</li>
<li>細かい話はF-ingに書いてある</li>
<li>サブタイピングは変換関数にelaborateされる</li>
</ul>
<p>===</p>
<h1 id="metatheory">Metatheory</h1>
<hr>
<ul>
<li>Sound</li>
<li>System FωへのelaborationもSound</li>
<li>elaborationはdecidable</li>
</ul>
<p>===</p>
<h1 id="4-full-1ml">4. Full 1ML</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h2 id="full-1ml">Full 1ML</h2>
<hr>
<ul>
<li>
<blockquote>
<p>A language without type inference is not worth naming ML.</p>
</blockquote>
</li>
<li>(10ページのFigure 5参考に)</li>
<li>_ で推論
<ul>
<li>small typeしか推論できない</li>
<li><code>type</code> が入っている型はダメ</li>
</ul>
</li>
<li>なんかimplicit functionが導入された</li>
<li>→ &lsquo;a の引数を無言で受け付けるための関数</li>
<li>implicit functionはpureな関数にのみ導入される</li>
<li>→value restrictionより緩い制限</li>
<li>少しMLっぽくなった</li>
</ul>
<p>===</p>
<pre><code>type MAP = {
  type key;
  type map a;
  empty ’a : map a;
 lookup ’a : key → map a → opt a;
 add ’a : key → a → map a → map a
};
Map (Key : EQ) :&gt; MAP where (type .key = Key.t) = {type key = Key.t;
 type map a = key → opt a;
 empty = fun x ⇒ none;
 lookup x m = m x;
 add x y m = fun z ⇒ if Key.eq z x then some y else m z
}
</code></pre><p>===</p>
<h1 id="5-type-inference">5. Type Inference</h1>
<hr>
<ul>
<li>(12ページのFigure 6を参考に)</li>
<li>なんかつらそう</li>
<li>サブタイピングあるとつらそう
<ul>
<li>→ small typeに限るとほとんどtype equivalenceになるよ</li>
<li>例外はrecord width</li>
</ul>
</li>
<li>型推論はincomplete
<ul>
<li>record width
<ul>
<li>前述</li>
<li><code>r.id</code>って書いたときに<code>r</code>の型(<code>id</code>以外のフィールド)を決定できない</li>
</ul>
</li>
<li>type scoping
<ul>
<li>よく分かんないけど推論のフェーズの問題で一般的な型にならないらしい？</li>
</ul>
</li>
<li>purity annotations
<ul>
<li>effect subtypingのせい</li>
</ul>
</li>
</ul>
</li>
<li>Sound</li>
<li>terminates</li>
</ul>
<p>===</p>
<h1 id="6-related-works">6. Related Works</h1>
<hr>
<ul>
<li>Packaged Modules
<ul>
<li>案外一杯あるっぽい</li>
<li>OCaml, Moscow ML, Alice ML</li>
</ul>
</li>
<li>First-Class Modules
<ul>
<li>レッドオーシャンっぽい</li>
<li>歴史が書いてあるので読むと面白い</li>
</ul>
</li>
<li>Applicative Functors
<ul>
<li>Moscow MLにGenerativeとApplicative両方入ってるらしい</li>
<li>full applicative functorsはfirst class modulesとコンフリクトする</li>
</ul>
</li>
<li>型推論
<ul>
<li>モジュールの型推論システムとかあるけど1MLはmonomorphic typeしか推論しないよ</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="7-future-work">7. Future Work</h1>
<hr>
<ul>
<li>実装 (Toyはあるよ)</li>
<li>Applicative Functors</li>
<li>implicit (type class)
<ul>
<li><code>type</code> しかないところに色々制約書けるようにしたらできそう</li>
</ul>
</li>
<li>型推論（今のところ単純だよね）</li>
<li>row polymorphismとかeffect polymorphismとか</li>
<li>Recursive Module(既にSystem Fに落とす先行研究がある)</li>
<li>依存型</li>
</ul>
<p><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->

        </div>
    </div>
</article>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2019. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="http://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script src="//KeenS.github.io/reveal.js/lib/js/head.min.js"></script>
<script src="//KeenS.github.io/reveal.js/js/reveal.js"></script>

<script>

 
 
 Reveal.initialize({
     controls: true,
     progress: true,
     history: false,
     center: false,
     slideNumber: true,

     
     transition: Reveal.getQueryHash().transition || 'none', 

     
     
     

     
     dependencies: [
	 { src: '\/\/KeenS.github.io\/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/highlight.js/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
         { src: '\/\/KeenS.github.io\/reveal.js/plugin/math/math.js', async: true }
     ]
 });

</script>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>


<script>
 window.onload = 
     
     (function(document, Reveal) {
         return function() {
             var page_header = document.getElementById("page-header");
             var article_header = document.getElementById("article-header");


             function displayHeader() {
                 article_header.style.display = "block";
                 page_header.style.display = "block";

             }
             function hideHeader() {
                 article_header.style.display = "none";
                 page_header.style.display = "none";
             }
             Reveal.addEventListener( 'slidechanged', function( event ) {
                 if (event.indexh === 0 && event.indexv === 0) {
                     displayHeader();
                 } else {
                     hideHeader();
                 }
             } );

         }
     })(document, Reveal);
</script>
