let data = [
  {"body":"κeenです。表題のとおりのことをやりたかったのですが、ピンポイントのAPIが見当らなかったのでやり方を書き留めます。\nやりたいこととしてはCとのFFIをやっていて要素列へのポインタと要素数があるときに、それをRustの世界に持ち込みたいというもの。\nコードはこういう感じですね。\nusestd::ffi::c_void;usestd::mem;extern\u0026#34;C\u0026#34;{fn calloc(nmemb: usize,size: usize)-\u0026gt; *mutc_void;}fn main(){unsafe{letnitems=512;letptr=calloc(nitems,mem::size_of::\u0026lt;i32\u0026gt;());// ↑このポインタを `Box\u0026lt;[i32]\u0026gt;` として扱いたい }} 一発で変換するメソッドがないので2段に分けてやります。まずstd::slice::slice_from_raw_parts_mutで配列のfat pointerを作り、std::boxed::Box::from_rawで Box に変換します。\nusestd::ffi::c_void;usestd::mem;usestd::ptr;extern\u0026#34;C\u0026#34;{fn calloc(nmemb: usize,size: usize)-\u0026gt; *mutc_void;fn memset(s: *mutc_void,c: u8,n: usize);}fn main(){letbuffer=unsafe{letnitems=512;letptr=calloc(nitems,mem::size_of::\u0026lt;i32\u0026gt;());// ↑このポインタを `Box\u0026lt;[i32]\u0026gt;` として扱いたい // ただのサンプルだけど一応メモリは初期化しておく memset(ptr,0,nitems*mem::size_of::\u0026lt;i32\u0026gt;());// ポインタと要素数から配列のfatポインタを作る letfat_ptr: *mut[i32]=ptr::slice_from_raw_parts_mut(ptras*muti32,nitems);// fatポインタになればBoxを素直に作れる Box::\u0026lt;[i32]\u0026gt;::from_raw(fat_ptr)};// do something } 小ネタでした。\n","categories":["Rust","小ネタ"],"category_urls":["/categories/rust","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2022-02-21","title":"Rustでポインタから`Box\u003c[T]\u003e`を作る","url":"https://KeenS.github.io/blog/2022/02/21/rustdepointakara_box_t__wotsukuru/"},
  {"body":"κeenです。以前の記事の続きで、 /proc を監視するのではなくeBPFで取得してみます。ついでにRustのコードをeBPFで動かせるライブラリのayaも使ってみます。\n以前の記事では /proc 以下の監視をビジーループで回すという力技で新しく作られたプロセスを補足していました。これだとCPU使用率が上がって美しくありませんし、何より原理的には見逃しもありえてしまいます。そこでカーネルの機能を使って全てのプロセスの作成を監視して低CPU使用率かつ捕捉率100%の実装を目指します。\neBPFとは？ なんかLinuxカーネルでユーザの書いたコード動かせるやつです。私は説明できるほど詳しくないので適当にググって下さい。\n1つやっかいな点として、独自のバイナリを動かすのでカーネル内で動かすコードはコンパイラがeBPFに対応したものでないといけません。また、カーネル内で動かすコードをユーザランドから制御するプログラムも同時に書く必要があります。\nAyaとは？ RustでeBPFのコードが書けるライブラリです。 LLVMがeBPFに対応してるので、頑張ってRustをeBPFにコンパイルする部分、eBPFのコード内で使えるライブラリ、eBPFのコードを走らせるユーザランドプログラムなどの面倒をみてくれます。\n公式チュートリアルなんかもあります。ドキュメントの更新が追い付いてないようでちょくちょくそのままだと動かない所もありますが、落ち着いて最新のコードを読みにいくなどすれば完走できます。\nAyaで docker --password を抜き出そう eBPFでどうやるかは前回のやつで調べてたときにみつけました。\n process - How to track newly created processes in Linux? - Unix \u0026amp; Linux Stack Exchange  ここの回答を参考に、以下の bpftrace のプログラムを書けば取り出せることが分かっています。\n$ sudo bpftrace -e \u0026#39;tracepoint:syscalls:sys_enter_exec* /str(*args-\u0026gt;argv) == \u0026#34;docker\u0026#34;/{ printf(\u0026#34;pid: %d, comm: %s, args: \u0026#34;, pid, comm); join(args-\u0026gt;argv); }\u0026#39; Attaching 2 probes... pid: 884154, comm: zsh, args: docker login --password hoge これをAyaを使ったRustのコードに移植することを目標にしましょう。\nAyaのチュートリアルにある内容はある程度省略するとして進めましょう。 tracepoint のテンプレートで作成し、 syscalls の sys_enter_execve を目標とするように入力します。 するとユーザランド側のプログラムが以下のように syscalls の sys_enter_execve にアタッチされるようになります。\nletprogram: \u0026amp;mutTracePoint=bpf.program_mut(\u0026#34;docker_password_aya\u0026#34;).unwrap().try_into()?;program.load()?;program.attach(\u0026#34;syscalls\u0026#34;,\u0026#34;sys_enter_execve\u0026#34;)?; 本当は execve の他に execveat も必要みたいですが、この際まあいいでしょう。\neBPF側のプログラムを書き進めていきます。まず -common に以下を書きます。これに抜き出したパスワードを入れてやりとりします。\n#[derive(Clone, Copy)]#[repr(C)]pubstruct DockerLog{pubcount: usize,pubdata: [u8;32],}#[cfg(feature = \u0026#34;user\u0026#34;)]unsafeimplaya::PodforDockerLog{} 見てのとおりデータが最大32バイトになってます。任意長のデータのやりとりをどうするか分からなかったのでこうしました。ユーザ側で確保したメモリのポインタを送ってeBPF側で書いてあげればいいんですかね？それとも普通に文字列へのポインタ渡せば読み出せる？\n-common はこれだけで、 -ebpf の方でやっていきます。\nまず、 ctx から argv 情報を取り出したいので ctx のデータアラインメントを調べます。今回の例だと /sys/kernel/debug/tracing/events/syscalls/sys_enter_execve/format を見れば載っています。\n$ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_execve/format name: sys_enter_execve ID: 711 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:const char * filename; offset:16; size:8; signed:0; field:const char *const * argv; offset:24; size:8; signed:0; field:const char *const * envp; offset:32; size:8; signed:0; print fmt: \u0026#34;filename: 0x%08lx, argv: 0x%08lx, envp: 0x%08lx\u0026#34;, ((unsigned long)(REC-\u0026gt;filename)), ((unsigned long )(REC-\u0026gt;argv)), ((unsigned long)(REC-\u0026gt;envp)) const char *const * argv のオフセットが24です。この情報を元に作業していきましょう。\nまず argv を取り出して、 *argv が \u0026quot;docker\\0\u0026quot; と一致しているかを確認します。\nuseaya_bpf::helpers::{bpf_probe_read_user,bpf_probe_read_user_str},unsafefn try_docker_password_aya(ctx: \u0026amp;TracePointContext)-\u0026gt; Result\u0026lt;u32,i64\u0026gt;{lettarget=b\u0026#34;docker\\0\u0026#34;;letargv=ctx.read_at::\u0026lt;*const*constu8\u0026gt;(24)?;ifargv.is_null(){returnErr(0);}letmutexe=[0u8;7];letexe_ptr=bpf_probe_read_user(argv)?;bpf_probe_read_user_str(exe_ptr,\u0026amp;mutexe)?;if\u0026amp;exe==target{// ... }Ok(0)} このときメモリの読み出しに bpf_probe_read_ 系の関数を使わないといけないのに気付かずにハマりました。あとこのデータってカーネルじゃなくてユーザ側にあるんですね。そこでもハマりました。\n*argv が \u0026quot;docker\\0\u0026quot; だったら次に進みます。本当は /usr/bin/docker とかもケアした方がいいんでしょうが、細けえことはいいんだよ。\nif の中身では argv を1つ1つ確認していって --password が見付かったら次の引数を DockeLog に入れて送り出すということをします。イテレータとかが使えずにちょっと煩雑ですがトリッキーなところはありません。\nif\u0026amp;exe==target{#[derive(Eq, PartialEq)]enum ReadState{NotYet,ReadNext,Done,}lettarget=b\u0026#34;--password\\0\u0026#34;;letmutarg=[0u8;32];letmutread_password=ReadState::NotYet;letmutcount=0;foriin0..100{arg=[0u8;32];letarg_ptr=bpf_probe_read_user(argv.offset(i))?;ifarg_ptr.is_null(){returnOk(0);}count=bpf_probe_read_user_str(arg_ptr,\u0026amp;mutarg)?;ifread_password==ReadState::ReadNext{read_password=ReadState::Done;break;}if\u0026amp;arg[..count]==\u0026amp;target[..]{read_password=ReadState::ReadNext;}}ifread_password==ReadState::Done{letentry=DockerLog{count,data: arg};EVENTS.output(ctx,\u0026amp;entry,0);}} これでeBPF側は完成です。\n最後にユーザランド側で DockerLog を受け取って表示する部分です。 loop { /* ... */ } の中身だけ書くと以下のようになります。\nletevents=buf.read_events(\u0026amp;mutbuffers).await.unwrap();foriin0..events.read{letbuf=\u0026amp;mutbuffers[i];letptr=buf.as_ptr()as*constDockerLog;letdata=unsafe{ptr.read_unaligned()};letpassword=\u0026amp;data.data[0..data.count];letpassword=std::ffi::CStr::from_bytes_with_nul(\u0026amp;password);println!(\u0026#34;LOG: password: {:?}\u0026#34;,password);} NUL終端されてるので CStr を使ってる点以外では特段変なところはありません。\n実行してみましょう。チュートリアルと違ってeBPFバイナリがプログラムに埋め込まれる設計なので carg xtask build-ebpf のあとに cargo build をする必要がある点以外は特筆することはありません。\n$ cargo xtask build-ebpf $ cargo build $ sudo ./target/debug/docker-password-aya ... LOG: password: Ok(\u0026#34;hoge\u0026#34;) ---------別ターミナル------- $ docker login --password hoge 動きましたね。めでたしめでたし。\nまとめ Ayaを使ってeBPFで新しく作られたプロセスを監視し、--password を抜き出すプログラムを書いてみました。まあ、実行に sudo が必要な点で前回よりも攻撃性は下がってますが、練習なのでね。文字列のやりとりをちゃんと調べきれてませんが、一旦はRustだけでeBPFを動かすことに成功したのでよしとしましょう。\neBPFに触れて満足しました。ソースコードは以下に置いています。参考にどうぞ。\nKeenS/docker-password-aya\nまた、今回のエントリは以下の記事を参考にしました。ありがとうございます。\nRustでeBPFを操れるAyaを触ってみた - Qiita\n","categories":["Docker","Linux","eBPF","Rust"],"category_urls":["/categories/docker","/categories/linux","/categories/ebpf","/categories/rust"],"date":"2022-01-04","title":"eBPFでDockerの--passwordで入力したパスワードを盗む","url":"https://KeenS.github.io/blog/2022/01/04/ebpfdedockerno__passworddenyuuryokushitapasuwa_dowonusumu/"},
  {"body":"κeenです。よくある言語同士や言語実装同士の速さの比較に使われるベンチマークが実際にどんなところの性能を調べているのかを理解してないので軽く調べてみます。\n色々調べようかと思ったんですが、一番よく見るのはComputer Language Benchmarks Gameの結果かなと思うのでここで使われているベンチマーク10種について調べていきます。 調べるとはいっても説明を読んで、ベンチマークに使われてるプログラムを読んで感想を言っていくだけです。実際にプロファイルをとってどこがボトルネックになるとかまではやらずに想像で喋ってるので参考程度に見ていって下さい。\nfannkuch-redux fannkuch-reduxは数字列を操作するプログラムです。\n求める計算は以下です\n ${1,\\cdots,n}$の並べ替えを受け取る 例: ${4,2,1,5,3}$ 最初の要素を見て（ここでは4）、先頭からその数の要素分だけ順序を反転させる: ${5,1,2,4,3}$ これを先頭の要素が1になるまで繰り返す: ${3,4,2,1,5}$ → ${2,4,3,1,5}$ → ${4,2,3,1,5}$ → ${1,3,2,4,5}$ 何回反転させたかを数える: 5 以下のどちらかの式でチェックサムを計算する（どちらでも等価）:  $checksum = checksum + (\\mathrm{if}\\;{}permutation\\_index\\;\\mathrm{is}\\;\\mathrm{even}\\;\\mathrm{then}\\;{}flips\\_count\\;\\mathrm{else}-flips\\_count)$ $checksum = checksum + (toggle\\_sign_{-1\\_1} * flips\\_count)$  これを全ての $1$ から $n$ までの数の並べ替えで計算する チェックサムと、最大の反転回数を出力する  個々の数字列に対しては並列に計算できるので、処理系の並列計算能力や配列操作、場合によっては数値の扱いあたりが効いてきそうですね。\n因みにこれはベンチマーク用のプログラムみたいで、あんまり意味のあることはしてなさそうです。fannkuchはパンケーキ（ホットケーキ）の意味で、ホットケーキを裏返すのを繰り返してる…らしいです。\nn-body n-bodyは木星型惑星の軌道を計算するプログラムです。木星型惑星は太陽系でいうと木星、土星、天王星、海王星です。日本語でも普通にN体問題で知られていますね。\nプログラムの中身はそこまで難しいものではなく、主にループと浮動小数点数計算で構成されています。 ベンチマークプログラムとして浮動小数点数計算がメインなので数値計算屋さんの戦場になっておりSIMD命令などを使った最適化の戦いが繰り広げられています。 SIMDを使えない言語ではシンプルな演算の性能のベンチマークになるようです。\nspectal-norm spectral-normは行列のスペクトルノルムの近似値をべき乗法で計算するプログラムです。スペクトルノルムについてはWikipediaの行列ノルムのページや特異値のページも参考にして下さい。 計算の元になる行列の要素は以下の式で与えられています。\n\\[ a_{ij} = \\frac{1}{(i+j)(i+j+1)/2+i+1} \\]\n添字を渡されたらどんなサイズの行列でも要素を計算できるのでベンチマーク向けにサイズを増やすのに向いてます。\n具体的なスペクトルノルムの計算は $A^TA$ を20回掛けて求めています。\n行列計算なので粗粒度並列性（≒スレッド）と細粒度並列性（≒SIMD）の両方が使えるところであり、かつキャッシュの有効活用なんかも重要なのでそれぞれを使える/使えないが大きく点数に響きます。\nmandelbrot mandelbrotはマンデルブロ集合を描画するプログラムです。マンデルブロ集合は投げ付けたら痛そうなアレですね。\n画素ごとの計算が可能で自由な並列化ができるのでそのあたりの速さが必要そうです。あと地味にバイナリデータを出力するのでバイナリデータの出入力が弱いとマイナスポイントかもしれません。\npidigits pidigitsは円周率πの10進表記を求め、表示するプログラムです。アルゴリズムに指定があります。内部で多倍長整数を使うので多倍長整数ライブラリの出来の良さが効いてきます。\nregex-redux regex-reduxは正規表現でDNA列のフォーマットのFASTAを処理するプログラムです。\n入力の改行を正規表現処理したり、特定の塩基列とその逆相補配列をさがしたり、特定のパターンを置き換えたりします。\n正規表現エンジンの速度や文字列確保の効率などが効いてきます。\nfasta fastaは先述のDNA列のフォーマットであるFASTAを生成するプログラムで、アルゴリズムに指定があります。DNA列を繰り返したりランダム生成したりします。\nループの中で分岐や（プログラムの作りによっては）文字列確保をするので基礎スペックが効いてきます。ランダムとはいってもアルゴリズム指定があり、結果の一致も求められるのですが、工夫すると並列化もできるようなので並列化性能も効くみたいです。\nk-nucleotide k-nucleotideはハッシュマップを使ってFASTAフォーマットで与えられる塩基を数えるプログラムです。各塩基の単体、2つ組の全てのカウントを出力し、3、4、6、12、18つ組の全てをカウントして特定の組のカウントを出力することが求められます。\nハッシュマップ自作が認められない、容量も手動確保せずに自動スケーリングに任せるなどの制約があり、組み込み/ライブラリのハッシュマップの速度を競う内容になっています。\nreverse-complement reverse-complementはFASTAフォーマットで与えられたDNAの逆相補配列を出力するプログラムです。アルゴリズムの指定があり、入力を1行ずつ自動バッファリングに任せて読み込むなどの制約があります。\nナイーブな出入力の速度と反転に必要な文字列処理が効いてくるベンチマークになります。…が、入力と反転処理を並行でやるために工夫したり反転操作は上手くスレッド並列やSIMD化したりもできるので、やっぱり並列処理に強い言語が強くなります。\nbinary-trees binary-treesは完全二分木を操作するプログラムです。アロケーションに指定があり、最低でも参照実装のプログラムと同じ回数だけのアロケーションが求められます。また、独自のメモリ管理手段を用意することは禁止されています。\nアロケーションに指定がある通り、メモリの扱いが効いてくるベンチマークです。あと地味にポインタを行ったり来たりするのでポインタの効率が悪いとマイナスポイントになります。アロケーションの指定で自作アロケータは禁止されているものの、外部ライブラリのアロケータを使うのは許されているようで、そういった手動メモリ管理ができる言語が大幅に有利になっています。\nざっと眺めてみましたが、結構大変ですね。前半で数値計算が多くて「大丈夫か？」とも思ったのですが後半で文字列処理やハッシュマップ、メモリアロケーションなどが登場したのでそれなりにバランスの取れたベンチマークなんじゃないでしょうか。\n余談ですがベンチマークスイートのネタとしてypsilonのベンチマークなんかもあったのですが、大変なのでやめました。\nとりあえず個人的にはどんなベンチマークを取ってるのか納得できたのですっきりしました。\n","categories":["言語実装"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2022-01-03","title":"よくあるベンチマークを調べたい","url":"https://KeenS.github.io/blog/2022/01/03/yokuarubenchima_kuwoshirabetai/"},
  {"body":"κeenです。InkscapeとかでSVGをよく扱うので表現の幅を増やすためにSVGのアニメーションを触ってみます。\nSVGを動かすにはCSSで指定するやつとSVGの \u0026lt;animate\u0026gt;などのタグを使うやつがありますが、今回は \u0026lt;animate\u0026gt; 系の方です。\n\u0026lt;animate\u0026gt; 系は \u0026lt;animateMotion\u0026gt; 、 \u0026lt;animateTransform\u0026gt; があります。歴史的には \u0026lt;animateColor\u0026gt; もあるようですが \u0026lt;animate\u0026gt; に統合されたようです。\n主に \u0026lt;animate\u0026gt; が属性を変化させるもの、 \u0026lt;animateMotion\u0026gt; が位置の移動に特化したもの、 \u0026lt;animateTransform\u0026gt; が変換をするやつっぽいですね。\n まずはMDNに載ってるやつをば。\n\u0026lt;svg viewBox=\u0026#34;0 0 10 10\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=100 height=100\u0026gt; \u0026lt;rect width=\u0026#34;10\u0026#34; height=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;animate attributeName=\u0026#34;rx\u0026#34; values=\u0026#34;0;5;0\u0026#34; dur=\u0026#34;10s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; /\u0026gt; \u0026lt;/rect\u0026gt; \u0026lt;/svg\u0026gt;  \nrx を0〜5の間でいったりきたりさせてます。元の rect が10なのでrxが5だと丁度円になるのかな。ループで繋がるように 0;5;0 と0からはじめて0に戻るようになっていて、 repeatCount=\u0026quot;indefinite\u0026quot; で無限ループさせています。\n当然、パラメータをいじればループを速くすることもできます。\n\u0026lt;svg viewBox=\u0026#34;0 0 10 10\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=100 height=100\u0026gt; \u0026lt;rect width=\u0026#34;10\u0026#34; height=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;animate attributeName=\u0026#34;rx\u0026#34; values=\u0026#34;0;5;0\u0026#34; dur=\u0026#34;3s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; /\u0026gt; \u0026lt;/rect\u0026gt; \u0026lt;/svg\u0026gt;  \n恐らく数値を取るattributeなら何でもanimateできるっぽくてぼかしエフェクトのぼかし度合いもanimateできます。\n\u0026lt;svg viewBox=\u0026#34;0 0 10 10\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=100 height=100\u0026gt; \u0026lt;filter id=\u0026#34;blur\u0026#34;\u0026gt; \u0026lt;feGaussianBlur stdDeviation=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;animate attributeName=\u0026#34;stdDeviation\u0026#34; from=\u0026#34;0\u0026#34; to=\u0026#34;5\u0026#34; dur=\u0026#34;3s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; /\u0026gt; \u0026lt;/feGaussianBlur\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;rect width=\u0026#34;10\u0026#34; height=\u0026#34;10\u0026#34; filter=\u0026#34;url(#blur)\u0026#34;\u0026gt; \u0026lt;/rect\u0026gt; \u0026lt;/svg\u0026gt;    \n値の変化は線型だけでなく、 calcMode で指定できます。極端には \u0026ldquo;discrete\u0026rdquo; を指定するとパッパッと切り替わります。\n\u0026lt;svg viewBox=\u0026#34;0 0 10 10\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=100 height=100\u0026gt; \u0026lt;filter id=\u0026#34;blur2\u0026#34;\u0026gt; \u0026lt;feGaussianBlur stdDeviation=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;animate attributeName=\u0026#34;stdDeviation\u0026#34; from=\u0026#34;0\u0026#34; to=\u0026#34;5\u0026#34; dur=\u0026#34;3s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; calcMode=\u0026#34;discrete\u0026#34; /\u0026gt; \u0026lt;/feGaussianBlur\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;rect width=\u0026#34;10\u0026#34; height=\u0026#34;10\u0026#34; filter=\u0026#34;url(#blur)\u0026#34;\u0026gt; \u0026lt;/rect\u0026gt; \u0026lt;/svg\u0026gt;    \nこれは非数値にも適用できるので丸と四角を交互に表示とかもできます。\n\u0026lt;svg viewBox=\u0026#34;0 0 10 10\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=100 height=100\u0026gt; \u0026lt;rect width=\u0026#34;10\u0026#34; height=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;animate attributeName=\u0026#34;display\u0026#34; from=\u0026#34;none\u0026#34; to=\u0026#34;inline\u0026#34; dur=\u0026#34;3s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; calcMode=\u0026#34;discrete\u0026#34;/\u0026gt; \u0026lt;/rect\u0026gt; \u0026lt;circle cx=\u0026#34;5\u0026#34; cy=\u0026#34;5\u0026#34; r=5\u0026gt; \u0026lt;animate attributeName=\u0026#34;display\u0026#34; from=\u0026#34;inline\u0026#34; to=\u0026#34;none\u0026#34; dur=\u0026#34;3s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; calcMode=\u0026#34;discrete\u0026#34;/\u0026gt; \u0026lt;/circle\u0026gt; \u0026lt;/svg\u0026gt;   \nvalues で複数値を指定するときにそれぞれの値にどのくらいの時間をかけて変化するかを指定できる keyTimes もあります。MDNからのコピペ。\n\u0026lt;svg viewBox=\u0026#34;0 0 120 120\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=100 height=100\u0026gt; \u0026lt;circle cx=\u0026#34;60\u0026#34; cy=\u0026#34;10\u0026#34; r=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;animate attributeName=\u0026#34;cx\u0026#34; dur=\u0026#34;4s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; values=\u0026#34;60; 110; 60; 10; 60\u0026#34; keyTimes=\u0026#34;0; 0.25; 0.5; 0.75; 1\u0026#34;/\u0026gt; \u0026lt;animate attributeName=\u0026#34;cy\u0026#34; dur=\u0026#34;4s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; values=\u0026#34;10; 60; 110; 60; 10\u0026#34; keyTimes=\u0026#34;0; 0.25; 0.5; 0.75; 1\u0026#34;/\u0026gt; \u0026lt;/circle\u0026gt; \u0026lt;/svg\u0026gt;  \nこれをkeySplinesにすると緩急がつきます。\n\u0026lt;svg viewBox=\u0026#34;0 0 120 120\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=100 height=100\u0026gt; \u0026lt;circle cx=\u0026#34;60\u0026#34; cy=\u0026#34;10\u0026#34; r=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;animate attributeName=\u0026#34;cx\u0026#34; dur=\u0026#34;4s\u0026#34; calcMode=\u0026#34;spline\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; values=\u0026#34;60; 110; 60; 10; 60\u0026#34; keyTimes=\u0026#34;0; 0.25; 0.5; 0.75; 1\u0026#34; keySplines=\u0026#34;0.5 0 0.5 1; 0.5 0 0.5 1; 0.5 0 0.5 1; 0.5 0 0.5 1\u0026#34;/\u0026gt; \u0026lt;animate attributeName=\u0026#34;cy\u0026#34; dur=\u0026#34;4s\u0026#34; calcMode=\u0026#34;spline\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; values=\u0026#34;10; 60; 110; 60; 10\u0026#34; keyTimes=\u0026#34;0; 0.25; 0.5; 0.75; 1\u0026#34; keySplines=\u0026#34;0.5 0 0.5 1; 0.5 0 0.5 1; 0.5 0 0.5 1; 0.5 0 0.5 1\u0026#34;/\u0026gt; \u0026lt;/circle\u0026gt; \u0026lt;/svg\u0026gt;  \n他にも色々ありますが、飽きてきたのでこのくらいで。\n\u0026lt;animateTransform\u0026gt; 変換するやつですね。まずはMDNに載ってるやつをば。\n\u0026lt;svg width=\u0026#34;120\u0026#34; height=\u0026#34;120\u0026#34; viewBox=\u0026#34;0 0 120 120\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;polygon points=\u0026#34;60,30 90,90 30,90\u0026#34;\u0026gt; \u0026lt;animateTransform attributeName=\u0026#34;transform\u0026#34; attributeType=\u0026#34;XML\u0026#34; type=\u0026#34;rotate\u0026#34; from=\u0026#34;0 60 70\u0026#34; to=\u0026#34;360 60 70\u0026#34; dur=\u0026#34;10s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34;/\u0026gt; \u0026lt;/polygon\u0026gt; \u0026lt;/svg\u0026gt;  \nぐるぐる周ります。\nこれはそれっぽく作れば時計も作れますね。\n\u0026lt;svg width=\u0026#34;120\u0026#34; height=\u0026#34;120\u0026#34; viewBox=\u0026#34;0 0 120 120\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;polygon points=\u0026#34;59,60 60,0 61,60 60,80\u0026#34;\u0026gt; \u0026lt;animateTransform attributeName=\u0026#34;transform\u0026#34; attributeType=\u0026#34;XML\u0026#34; type=\u0026#34;rotate\u0026#34; from=\u0026#34;0 60 60\u0026#34; to=\u0026#34;360 60 60\u0026#34; dur=\u0026#34;60s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34;/\u0026gt; \u0026lt;/polygon\u0026gt; \u0026lt;polygon points=\u0026#34;57,60 60,10 63,60 60,70\u0026#34;\u0026gt; \u0026lt;animateTransform attributeName=\u0026#34;transform\u0026#34; attributeType=\u0026#34;XML\u0026#34; type=\u0026#34;rotate\u0026#34; from=\u0026#34;0 60 60\u0026#34; to=\u0026#34;360 60 60\u0026#34; dur=\u0026#34;3600s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34;/\u0026gt; \u0026lt;/polygon\u0026gt; \u0026lt;polygon points=\u0026#34;55,60 60,30 65,60 60,65\u0026#34;\u0026gt; \u0026lt;animateTransform attributeName=\u0026#34;transform\u0026#34; attributeType=\u0026#34;XML\u0026#34; type=\u0026#34;rotate\u0026#34; from=\u0026#34;60 60 60\u0026#34; to=\u0026#34;420 60 60\u0026#34; dur=\u0026#34;43200s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34;/\u0026gt; \u0026lt;/polygon\u0026gt; \u0026lt;rect id=mark width=3 height=5 x=60 /\u0026gt; \u0026lt;use href=\u0026#34;#mark\u0026#34; transform=\u0026#34;rotate(90 60 60)\u0026#34; /\u0026gt; \u0026lt;use href=\u0026#34;#mark\u0026#34; transform=\u0026#34;rotate(180 60 60)\u0026#34; /\u0026gt; \u0026lt;use href=\u0026#34;#mark\u0026#34; transform=\u0026#34;rotate(270 60 60)\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt;    \nSVGで時間をとれないので現在時刻はJSとかで取得してDOMを使って設定することになるかと思いますが、駆動部分はSVGだけで書けるのはいいですね。\n他にもtransformにはscaleやskewなどいくつかがあります。詳細は MDNののtypeのドキュメントを参照下さい。\n\u0026lt;animateMotion\u0026gt; 動かせます。MDNからのコピペ\n\u0026lt;svg viewBox=\u0026#34;0 0 200 100\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=200 height=200\u0026gt; \u0026lt;path fill=\u0026#34;none\u0026#34; stroke=\u0026#34;lightgrey\u0026#34; d=\u0026#34;M20,50 C20,-50 180,150 180,50 C180-50 20,150 20,50 z\u0026#34; /\u0026gt; \u0026lt;circle r=\u0026#34;5\u0026#34; fill=\u0026#34;red\u0026#34;\u0026gt; \u0026lt;animateMotion dur=\u0026#34;10s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; path=\u0026#34;M20,50 C20,-50 180,150 180,50 C180-50 20,150 20,50 z\u0026#34; /\u0026gt; \u0026lt;/circle\u0026gt; \u0026lt;/svg\u0026gt;  \nこれを使って伝説の動く点Pを作れます\n\u0026lt;svg viewBox=\u0026#34;0 0 100 100\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=100 height=100\u0026gt; \u0026lt;path fill=\u0026#34;none\u0026#34; stroke=\u0026#34;lightgrey\u0026#34; d=\u0026#34;M20,20 L80,20 L80,80 L20,80 L20,20 z\u0026#34; /\u0026gt; \u0026lt;g\u0026gt; \u0026lt;text x=-5 y=-5 \u0026gt;P\u0026lt;/text\u0026gt; \u0026lt;circle r=\u0026#34;5\u0026#34; fill=\u0026#34;red\u0026#34; /\u0026gt; \u0026lt;animateMotion dur=\u0026#34;10s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; path=\u0026#34;M20,20 L80,20 L80,80 L20,80 L20,20 z\u0026#34; /\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt;  P  \n他のアニメーション、例えば \u0026lt;animateTransform\u0026gt; と組み合わせて手裏剣を飛ばしたりもできます。\n\u0026lt;svg width=\u0026#34;480\u0026#34; height=\u0026#34;120\u0026#34; viewBox=\u0026#34;0 0 480 120\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;g\u0026gt; \u0026lt;polygon points=\u0026#34;10,60 45,45 60,10 75,45 110,60 75,75 60,110 45,75\u0026#34; /\u0026gt; \u0026lt;circle cx=\u0026#34;60\u0026#34; cy=\u0026#34;60\u0026#34; r=10 fill=\u0026#34;white\u0026#34; /\u0026gt; \u0026lt;animateMotion dur=\u0026#34;3s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34; path=\u0026#34;M 0,0 380,0\u0026#34; /\u0026gt; \u0026lt;animateTransform attributeName=\u0026#34;transform\u0026#34; attributeType=\u0026#34;XML\u0026#34; type=\u0026#34;rotate\u0026#34; from=\u0026#34;0 60 60\u0026#34; to=\u0026#34;360 60 60\u0026#34; dur=\u0026#34;2s\u0026#34; repeatCount=\u0026#34;indefinite\u0026#34;/\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt;   \n遊んだので満足。\n","categories":["SVG"],"category_urls":["/categories/svg"],"date":"2022-01-02","title":"SVGのアニメーションのお勉強","url":"https://KeenS.github.io/blog/2022/01/02/svgnoanime_shonnoobenkyou/"},
  {"body":" κeenです。2021注目していきたい技術、やっていきたいことを書いておく。\nAxum Rustの新しいウェブアプリケーションフレームワーク。Tokioから出たということで触っときたい。\n Announcing Axum | Tokio - An asynchronous Rust runtime  やっぱTowerで動くというのが良くて、例えばgRPCフレームワークのtonicと一緒に動かせるとかの利点があるのでそれなりに支持は得るんじゃないかなと思ってる。\nKoka 代数的効果（とハンドラ）が使える言語。その他GCに工夫があったりもする。 個人的に非同期IOと同期IOで型が変わってしまう点を問題視していて、代数的効果ならそれを解決できるんじゃないかと思ってるのでKokaをやってその辺の肌感を掴みたい。\nBlender 去年入門書を一通りやったので今年は自分の作りたいものを作れるようになるといいな。3Dアバターを動かすのが目標。\nWASMのException Handling WebAssemblyに例外ハンドリングを入れようという動きがある。自分の作っているSML処理系はWASMで動くのでこの例外処理がどうなるかを結構気にしている。いまPhase 3まで完了していて、Phase 4も半分くらいは進んでいるところなのでそろそろ手を動かさないといけないなと思っているところ。\n Plan for Phase 4 · Issue #179 · WebAssembly/exception-handling  SIMDプログラミング 私の周りではSIMDプログラミングが盛んなんですが私は大して触ったことがないので触っとかないとなーという気持です。AVX2でマージソート書いてみるとかそういうのを試そうと思います。\nGPUプログラミング 去年の年明けくらいにGPUを買ったんですよね。眠らせとくのもなんなのでなんか使ってみようかなという漠然とした目標です。 RustからGPUを叩けるプロジェクトもいくつか進んでいることですし潮時かなって。\nDeep Learing あんまり流行り物には乗りたくないんですが、仕事柄多少はやっとかないと困りそうなのでやってみます。あとGPU使いたいというモチベーションもあります。AMD GPUででまともに動くのか分かりませんが。\n特にやりたいタスクがないのでKaggleにチャレンジとかになるんですかね。なんか良いタスクある方教えて下さい。\nゲーム GPUとかWASMとかとも繋るんですが、ゲームをサクっと作れるようになっとくと一発芸の幅が広がるかなって思うので軽い2Dゲーム作ってみようと思います。\n生物学 去年に引き続き目標に。去年は漠然とした「やっていく」でしたが、今年は絞って「キャンベルを読む」にしておく。\n執筆 忙しくなるからやりたくないと良いつつそれなりに楽しいので軽いやつ（1万字程度）を2本くらいを目標にどこかに寄稿できたらいいな。 2021年に出したWeb Book2冊はどっちも20万字程度の大作で大変だったので軽いやつなら大丈夫でしょうという見込です。\n毎年入れていたWebMLについては今年から書かないことにした。わざわざ目標に入れるまでもなく、息をするようにやっていくという意気込み。\n今年は成果物重視でいきたい。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2022-01-01","title":"2022年抱負","url":"https://KeenS.github.io/blog/2022/01/01/2022nenhoufu/"},
  {"body":"κeenです。このタイトルで正しく説明できてるか分かりませんが、ちょいちょい遭遇するのでメモ。\n手っ取り早く説明すると、dkmsのビルドに失敗するとamdgpuモジュールがblacklist行きになるので、blacklistから削除してあげると解決します。\nsudo rm /etc/modprobe.d/blacklist-amdgpu.conf このあと再起動するか、amdgpuのモジュールをロードしてあげます。\nmodprobe amdgpu 因みにamdgpuのカーネルモジュールがロードできているかどうかは lsmod で確認できます。以下のように amdgpu をはじめとしていくつかのカーネルモジュールがロードされていればOK。\n$ lsmod | grep amdgpu amdgpu 6389760 54 iommu_v2 24576 1 amdgpu gpu_sched 36864 1 amdgpu drm_ttm_helper 16384 1 amdgpu ttm 69632 2 amdgpu,drm_ttm_helper drm_kms_helper 262144 1 amdgpu drm 561152 25 gpu_sched,drm_kms_helper,amdgpu,drm_ttm_helper,ttm i2c_algo_bit 16384 2 igb,amdgpu また、amdgpuのロードに失敗していると現象として /dev に以下のファイルがみつからなくなります。\n$ ls -l /dev/kfd crw-rw---- 1 root render 506, 0 12月 22 23:32 /dev/kfd $ ls -l /dev/dri 合計 0 drwxr-xr-x 2 root root 80 12月 22 23:32 by-path crw-rw----+ 1 root video 226, 0 1月 1 16:13 card0 crw-rw----+ 1 root render 226, 128 12月 22 23:32 renderD128 /dev/dma_heap もだったかな？\nたまにひっかかっては思い出せなくなるのでメモでした。\n","categories":["Linux","Ubuntu","amdgpu","備忘録"],"category_urls":["/categories/linux","/categories/ubuntu","/categories/amdgpu","/categories/%e5%82%99%e5%bf%98%e9%8c%b2"],"date":"2022-01-01","title":"Ubuntuでamdgpuのドライバインストールに失敗したあとGPUが使えなくなったときの対処法","url":"https://KeenS.github.io/blog/2022/01/01/ubuntudeamdgpunodoraibainsuto_runishippaishitaatogpugatsukaenakunattatokinotaishohou/"},
  {"body":"κeenです。長年Mendeleyを使っていましたが、モバイル版のMendeleyのサポート終了などのイベントがあったのでZoteroに乗り換えました。そのお話。結構前にやったのでかなり記憶が怪しいので適当に参考にして下さい。\n私は論文を執筆するとかの用途はなく、ただ単にダウンロードしたPDFを管理したいだけ。 Mendeleyは過剰スペックでしたが、大は小を兼ねるのでそのまま使っていました。 ですがアカウントが増えるのが面倒、PDFを手元（Dropbox）で管理したい、Firefoxのプラグインがなんかちゃんと動かない、などの不満があり、最後のモバイル版のサポート終了を契機に乗り換えることにしました。\n乗り換え先としてシンプルにメタデータとPDFをDropboxに置いて管理できるオープンソースのソフトを探したらZotero + ZotFileがひっかかったのでそれにしました。このあたりは人それぞれ好みがあるので参考までに。\nZoteroのインストール 確か以下の記事を参考にしました。\n 【令和最新版】文献管理ソフト Zoteroのすゝめ｜SD｜note  Zoteroを公式サイトから落としてきてインストール、なんやかんやセットアップします。そのあとZotFileもダウンロードしてプラグインをインストールします。この辺記憶があいまいなので適当に調べて下さい。\nそのあとZoteroのメタデータやZotFileのPDF置き場をDropboxのディレクトリに変更します。\nFirefoxプラグインのZotero Connectorもインストールします。初見で動作確認できなくて困ったのですが、Zoteroを起動してるときにしか動かないようなので注意。\n移行 私の使ってるバージョンのMendeleyは乗り換え対策がされていて、文献一覧のエクスポートができなくなってました。 仕方ないのでMendeleyで全文献のBibTeXデータを取得してそれをZoteroに喰わせる形で取り込みました。 たまに取り込めない文献があるので、それは手動で入力しました。ちょっと大変ですね。\n感想とか ひとまずブラウザプラグインがちゃんと動くようになったのでよかったです。 あとPDFリーダをOSのデフォルトで読める。Mendeleyは恐らくマーカとかを共有できるようにするために自前のPDFリーダを持ってるんですが、私はマーカを使わないタイプなのでOSのデフォルトリーダの方が好みでした。\n他にMendeleyで問題にしていたPDFを自分で管理したい、モバイルのサポートがないについては\n MendeleyでもPDFの置き場を指定してDropbox内にも保存できた（し、その設定を既にしていた） Zoteroのモバイルアプリはかなり微妙  なのでMendeleyと大差ないことが分かりました。まあ、プラグイン分でややプラスってことで。\n","categories":["備忘録","Mendeley","Zotero"],"category_urls":["/categories/%e5%82%99%e5%bf%98%e9%8c%b2","/categories/mendeley","/categories/zotero"],"date":"2022-01-01","title":"文献管理をMendeleyからZoteroに移行した","url":"https://KeenS.github.io/blog/2022/01/01/bunkenkanriwomendeleykarazoteroniikoushita/"},
  {"body":"κeenです。まだ大掃除終わってないけどこれ書かないと一年が締まらないので筆を執ります。\n2021年の抱負を振り返り Idris めちゃくちゃ触ったという訳ではないけど入門のWeb Book書いたしそれなりに活動した。\nCloudronとNextCloud それなりに検討したけど、使わない選択になった。一番の理由はサーバ代。やりたいこと色々やろうとするとスペック的に月額7000円くらいかかりそうだったので、遊びで維持するには高すぎるなと思ってあきらめた。メイン用途のクラウドストレージはDropboxで困ってないし。 まあ、あきらめるって判断ができるくらいには触ったということで。\nマルチメディア 絵書いたりモデリングしたりしたいって言ったけどほとんどやってない。一応Inkspcape使って何枚か絵は書いたし、Blenderの入門書踏破してそのあと新機能を追ったりはしてる。しかし圧倒的に手を動かしきれていない。\nやったけど消化不良ってところで。\n新しい言語 ほとんどやってない。一応Idrisの入門書を書くにあたってForthのインタプリタを作るチュートリアルを書くためにForthの勉強はしてる。あとKokaもコンパイラ動かすくらいまではやった。\nこれもやったけど消化不良ってところで。\nio_uring 触った。記事書いた。\n io_uringで高速IO処理（？） | κeenのHappy Hacκing Blog io_uringで高速IO処理（！） | κeenのHappy Hacκing Blog  これはマイクロベンチマーク用のプログラムなので実アプリケーションというか、もう少し大きいアプリケーションで使えたらよかったけどひとまず満足。\n生物学？ ゆるふわ生物学チャネル経由で色々勉強したし推薦図書をはじめとし生物系の本を何冊か読んだ。\n 品種改良の世界史・作物編 ［新版］植物 DVDつき | 小学館の図鑑NEOシリーズ | 小学館 花 DVDつき | 小学館の図鑑NEOシリーズ | 小学館 【東京書籍】 一般書籍 自然科学 FLORA 図鑑 植物の世界 進化で読み解く　バイオインフォマティクス入門｜森北出版株式会社 シダハンドブック クモの巣ハンドブック ウニハンドブック 日本のカエル４８　偏愛図鑑 :迫野　貴大｜河出書房新社 育て方がよくわかる　世界の食虫植物図鑑 - 株式会社日本文芸社 かたち──自然が創り出す美しいパターン１ | 種類,ハヤカワ文庫NF | ハヤカワ・オンライン  意外と読んでるな。他にもキャンベルなどの本がまだ積読に入ってる。まだキャンベルに手をつけてないので自己評価では全然だけど去年よりは成長してるし、何より継続的に取り組めてるので評価よし。\nバイオインフォマティクス入門はエンジニアにも読めてお薦め。\nスマブラ オンライン大会に出たしレーティング対戦も一期だけやってみた。VIPの戦闘力もおおむね魔境街道と言われるあたりまできた。\nWebML やってないです…。\n個人的振り返り メトリクス ブログ+zennの記事23、スライド2綴、Web Book 2冊、雑誌への寄稿1本。論文管理をMendeleyからZoteroに移行した影響で今年追加した論文数不明。買った技術書は不明だが、かなり少ない模様。GitHubのContribution 3,151。\n総括 年始の抱負で\n 今年は執筆とか講演とかの時間のかかるプロジェクトをできるだけせずに好き勝手遊べる時間を確保できるといいな。\n って言ってるんですが、Web Book 2冊と雑誌の寄稿1本やってるのでかなり執筆に時間とられてますね。その割には新しいこと（生物学）に手を伸ばせたしそこそこ頑張ったのかな。\nとはいえ技術的にはあんまりインプットがない状況なのでそろそろ出涸らしになりそうという危機感がある。来年はもうちょっと勉強会とかの新しい技術に興味をもつ窓口になりそうな活動を増やしていきたい。ブログの本数も年間30本くらいは目標にしたい。\n生物学は足突っ込んでみたけどこのあとどう持っていくかは不明。人生のスパイスとして教養的に覚えておくくらいになりそうなので冷静に考えると時間は大きく割かずに細く長く続けていくのがよさそうだが、楽しけりゃそれでいいんだよという気もする。まだ目的地が目に見えるまで進んでないので基礎を固めるのが目先の目標かな。\n去年に引き続きGitHubでの活動があんまり盛んでなかったのが心残り。もっとコード書かなきゃですね。\n一方で執筆は色々書いた。まとまった量のアウトプットを出すにはそれなりに自分の中で構成とか練る期間が必要なので忙しくならない程度に取り組むのは悪くないのかなという気もします。\n2021年は今までとは違うペースで活動したかなという印象でした。自分の出したい成果と実際にやったことがずれてたのでちょっと消化不良感が残るのですが新しいことに取り組めてるのは悪いことじゃないので来年は自分がどうしたいのかと向き合っていけたらなと思います。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2021-12-31","title":"2021年振り返り","url":"https://KeenS.github.io/blog/2021/12/31/2021nenfurikaeri/"},
  {"body":"このエントリはRust Advent Calendarの9日目の記事です。\n空いてる日を埋める担当のκeenです。9日目が空いてたので遡って記事を投稿します。RustというよりLinuxの知識を使った記事ですが。Docker CLIでログインするときに --password オプションを使うとパスワードが盗まれる可能性があるよという警告が出たことありませんか？あれを実際にやってみたいと思います。\ndocker login に --password オプションを渡すと以下のようにCLIからパスワードを渡すと安全でないよという警告が出ます。\n$ docker login --password MY_PASSWORD WARNING! Using --password via the CLI is insecure. Use --password-stdin. Login with your Docker ID to push and pull images from Docker Hub. If you don\u0026#39;t have a Docker ID, head over to https://hub.docker.com to create one. Username: 口で言われるだけだとどのくらい安全でないか分からないので実際にコードを書いてパスワードを盗んでみましょう。\nLinuxでは他のプロセスがどのように実行されているかを /proc/PID で確認できます。この機能を用います。\n例えば私が今使っているシェルのPIDは 265989 です。\n$ echo $$ 265989 そこで /proc/265989/ を覗けば色々なものが見えるようになっています。\n$ ls /proc/265989/ arch_status clear_refs cpuset fdinfo map_files mountstats oom_score projid_map setgroups statm timers attr cmdline cwd gid_map maps net oom_score_adj root smaps status timerslack_ns autogroup comm environ io mem ns pagemap sched smaps_rollup syscall uid_map auxv coredump_filter exe limits mountinfo numa_maps patch_state schedstat stack task wchan cgroup cpu_resctrl_groups fd loginuid mounts oom_adj personality sessionid stat timens_offsets この中に cmdline というファイルがあり、その中身にコマンドと引数が書かれています。\n$ cat /proc/265989/cmdline /usr/bin/zsh 同様に docker login プロセスのこれを見ればパスワードが書いてある訳です。 となると、あとはdockerコマンドがくるのを待ち受けてあげればよいですね。コードを書いてみましょう。\n/proc 下にある数字名のディレクトリを全部開いて cmdline を読み、 docker と --password という文字列が含まれていたら標準出力に書き出すコードを書けばよさそうです。\n/proc 以下は普通のファイルとして読めるので標準ライブラリだけで処理できてしまいます。\nusestd::fs;forentryinfs::read_dir(\u0026#34;/proc\u0026#34;)?{lete=entry?;// ... } エントリがディレクトリでありかつ名前が全て数字のものだけを対象にします。\nlete=entry?;letis_dir=e.file_type()?.is_dir();letis_number_named=e.file_name().to_str().unwrap().chars().all(|c|\u0026#34;1234567890\u0026#34;.contains(c));ifis_dir\u0026amp;\u0026amp;is_number_named{// ... } そしてそのディレクトリ下にある cmdline というファイルを読み出し、 docker と password が含まれているかを検査し、含まれていれば出力します。\nletcmdline=fs::read_to_string(e.path().join(\u0026#34;cmdline\u0026#34;))?;ifcmdline.contains(\u0026#34;docker\u0026#34;)\u0026amp;\u0026amp;cmdline.contains(\u0026#34;--password\u0026#34;){println!(\u0026#34;cmdline: {}\u0026#34;,cmdline);returnOk(());} というのをヒットするまで繰り返します。全体としてはこういうコードになります。\nusestd::fs;usestd::io;fn main()-\u0026gt; io::Result\u0026lt;()\u0026gt;{loop{forentryinfs::read_dir(\u0026#34;/proc\u0026#34;)?{lete=entry?;letis_dir=e.file_type()?.is_dir();letis_number_named=e.file_name().to_str().unwrap().chars().all(|c|\u0026#34;1234567890\u0026#34;.contains(c));ifis_dir\u0026amp;\u0026amp;is_number_named{letcmdline=fs::read_to_string(e.path().join(\u0026#34;cmdline\u0026#34;))?;ifcmdline.contains(\u0026#34;docker\u0026#34;)\u0026amp;\u0026amp;cmdline.contains(\u0026#34;--password\u0026#34;){println!(\u0026#34;cmdline: {}\u0026#34;,cmdline);returnOk(());}}}}} これを走らせてみましょう。 cargo run している間に別ターミナルで docker login --password hoge を入力してみます。\n$ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/docker-password` cmdline: dockerlogin--passwordhoge ───────────別ターミナル───────────────────────────────── $ docker login --password hoge WARNING! Using --password via the CLI is insecure. Use --password-stdin. Login with your Docker ID to push and pull images from Docker Hub. If you don\u0026#39;t have a Docker ID, head over to https://hub.docker.com to create one. Username: ^C はい、コマンドラインが取得できましたね。引数がヌル文字区切りなので間がつまってるように見えますが、まあよいでしょう。\n荒い部分はありますし、ヒットするまでループを回すという力技ですがパスワードを抜き出すことができました。同様にして environ から環境変数も抜き出せるので環境変数でパスワードを渡すようなプログラムも危険です。この記事を通して出されている警告の意味が分かるようになれば幸いです。\n余談 最初は /proc にinotifyをかけて新規プロセスを取得しようと思ってたんですが、新規プロセスができても /proc にCREATEイベントが発生しないんですね。仕方ないのでループで回すという力技にしました。\n後で調べたら新規プロセスを監視するのはeBPFなど何種類かのAPIによる実現方法があるようです。詳しい方がいたらやってみて下さい。\n","categories":["Rust","Advent Calendar","Advent Calendar 2021","Rust Advent Calendar","Docker","Linux"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2021","/categories/rust-advent-calendar","/categories/docker","/categories/linux"],"date":"2021-12-20","title":"RustでDockerの--passwordで入力したパスワードを盗む","url":"https://KeenS.github.io/blog/2021/12/20/rustdedockerno__passworddenyuuryokushitapasuwa_dowonusumu/"},
  {"body":"このエントリはRust Advent Calendarの2日目の記事です。\n空いてる日を埋める担当のκeenです。2日目が空いてたので遡って記事を投稿します。\n最近v1.0.0がリリースされたリンカ、moldを使うとビルドが高速化するよというお話です。\nRustのビルド、特にインクリメンタルビルドにおいてはRustコンパイラの速さと同じくらいリンカの速度がコンパイル時間に影響します。 この最後のバイナリを作る時間は意外と効いてきます。\n具体例としてActix Webにあるexample、 basic をインクリメンタルビルドする例をみてみましょう。\nこの basic はたった42行の小さなアプリケーションです。\n$ wc -l basic.rs 42 basic.rs ただし、依存に Actix Webという巨大なライブラリを使っているので最終的なバイナリには非常に多くのコードが含まれます。フレームワークを使ってアプリケーションを開発してるときに似た状況な訳です。多くの人にとっては実感のある例でしょう。これを mold ありなしでビルドしたときのコンパイル時間の差をみてみます。\nまずはビルドキャッシュを有効にするために cargo build を走らせておきます。\n$ cd actix-web $ cargo build --example basic そのあとインクリメンタルビルドの速度を time コマンドで測ってみます。一度 examples/basics.rs に touch すれば再度ビルドが走ってくれます。\n$ touch examples/basic.rs \u0026amp;\u0026amp; time cargo build --example basic Compiling actix-web v4.0.0-beta.15 (/home/shun/Rust/actix-web) Finished dev [unoptimized] target(s) in 2.48s cargo build --example basic 1.93s user 3.88s system 228% cpu 2.545 total すると約2.5秒かかります。何も変更がないはずなのにけっこう長いですね。Actix Webで開発するコードにおいては cargo run や cargo test する度にこのリードタイムが税金のように乗ってくる訳です。できる限り減らしたいですよね。\n次に mold を使ってビルドしてみましょう。 mold はGitHubから clone してきて依存を揃えたら make \u0026amp;\u0026amp; sudo make install でインストールできます。公式の案内に従って下さい。\nmold をRustのプロジェクトで使うのは簡単です。 mold -run cargo ... のように cargo の前に mold -run を置くだけで使えます。\n$ mold -run cargo build --example basic これでさきほどの basic を再度ビルドしてみましょう。\n$ touch examples/basic.rs \u0026amp;\u0026amp; time mold -run cargo build --example basic Compiling actix-web v4.0.0-beta.15 (/home/shun/Rust/actix-web) Finished dev [unoptimized] target(s) in 0.78s mold -run cargo build --example basic 0.59s user 1.06s system 195% cpu 0.848 total 約0.85秒とかなり高速化しました。2.545 / 0.848 ≒ 3 なのでおおむね3倍高速化しています。 この数値はプロジェクトの大きさやマシンスペックなどに応じて変わるので素直に3倍とは言い切れませんが、 mold を使ってインクリメンタルビルドすると少なくない高速化が見込めるのは事実でしょう。\ncargo test のように小さな修正をしては実行してみるようなユースケースを考えると mold によるコンパイルの高速化、手返しの改善は大きな恩恵があります。 導入も手軽にできますしお試しで手元で開発するときのテスト用途などで使ってみてはいかがでしょうか。\n","categories":["Rust","Advent Calendar","Advent Calendar 2021","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2021","/categories/rust-advent-calendar"],"date":"2021-12-20","title":"moldを使うとRustのビルドが速くなる","url":"https://KeenS.github.io/blog/2021/12/20/moldwotsukautorustnobirudogahayakunaru/"},
  {"body":"このエントリはRust Advent Calendarの1日目の記事です。\n空いてる日を埋める担当のκeenです。1日目が空いてたので遡って記事を投稿します。 Rustでテストをするときに渡すオプションが2種類あるという話について。\nテストを実行するときに cargo test を使うかと思います。この cargo test のヘルプメッセージは以下のようになっています。\n cargo-test Execute all unit and integration tests and build examples of a local package USAGE: cargo test [OPTIONS] [TESTNAME] [-- ...] OPTIONS: -q, --quiet Display one character per test instead of one line --lib Test only this package's library unit tests --bin ... Test only the specified binary --bins Test all binaries --example ... Test only the specified example --examples Test all examples --test ... Test only the specified test target --tests Test all tests --bench ... Test only the specified bench target --benches Test all benches --all-targets Test all targets --doc Test only this library's documentation --no-run Compile, but don't run tests --no-fail-fast Run all tests regardless of failure -p, --package ... Package to run tests for --workspace Test all packages in the workspace --exclude ... Exclude packages from the test --all Alias for --workspace (deprecated) -j, --jobs  Number of parallel jobs, defaults to # of CPUs --release Build artifacts in release mode, with optimizations --profile  Build artifacts with the specified profile --features ... Space or comma separated list of features to activate --all-features Activate all available features --no-default-features Do not activate the `default` feature --target ... Build for the target triple --target-dir  Directory for all generated artifacts --manifest-path  Path to Cargo.toml --ignore-rust-version Ignore `rust-version` specification in packages --message-format ... Error format --unit-graph Output build graph in JSON (unstable) --future-incompat-report Outputs a future incompatibility report at the end of the build (unstable) -v, --verbose Use verbose output (-vv very verbose/build.rs output) --color  Coloring: auto, always, never --frozen Require Cargo.lock and cache are up to date --locked Require Cargo.lock is up to date --offline Run without accessing the network --config ... Override a configuration value (unstable) -Z ... Unstable (nightly-only) flags to Cargo, see 'cargo -Z help' for details -h, --help Prints help information ARGS:  If specified, only run tests containing this string in their names ... Arguments for the test binary Run `cargo help test` for more detailed information.   何やら色々オプションが並んでいますね。多くは cargo build などにもありますが、例えば --exclude や --no-fail-fast などはテスト専用のオプションに見えます。\nこの影響でここにリストアップされているものが全てのような気がしますが、実はテストのオプションはまだまだあります。上記はCargo側のオプションで、コンパイルされたテスト側にもまだオプションはあるのです。テストバイナリ側のヘルプメッセージは cargo test -- --help と -- を挟んでからオプションを渡してあげると見れます。\n $ cargo test -- --help Usage: --help [OPTIONS] [FILTERS...] Options: --include-ignored Run ignored and not ignored tests --ignored Run only ignored tests --force-run-in-process Forces tests to run in-process when panic=abort --exclude-should-panic Excludes tests marked as should_panic --test Run tests and not benchmarks --bench Run benchmarks instead of tests --list List all tests and benchmarks -h, --help Display this message --logfile PATH Write logs to the specified file --nocapture don't capture stdout/stderr of each task, allow printing directly --test-threads n_threads Number of threads used for running tests in parallel --skip FILTER Skip tests whose names contain FILTER (this flag can be used multiple times) -q, --quiet Display one character per test instead of one line. Alias to --format=terse --exact Exactly match filters rather than by substring --color auto|always|never Configure coloring of output: auto = colorize if stdout is a tty and tests are run on serially (default); always = always colorize output; never = never colorize output; --format pretty|terse|json|junit Configure formatting of output: pretty = Print verbose output; terse = Display one character per test; json = Output a json document; junit = Output a JUnit document --show-output Show captured stdout of successful tests -Z unstable-options Enable nightly-only flags: unstable-options = Allow use of experimental features --report-time [plain|colored] Show execution time of each test. Available values: plain = do not colorize the execution time (default); colored = colorize output according to the `color` parameter value; Threshold values for colorized output can be configured via `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and `RUST_TEST_TIME_DOCTEST` environment variables. Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`. Durations must be specified in milliseconds, e.g. `500,2000` means that the warn time is 0.5 seconds, and the critical time is 2 seconds. Not available for --format=terse --ensure-time Treat excess of the test execution time limit as error. Threshold values for this option can be configured via `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and `RUST_TEST_TIME_DOCTEST` environment variables. Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`. `CRITICAL_TIME` here means the limit that should not be exceeded by test. --shuffle Run tests in random order --shuffle-seed SEED Run tests in random order; seed the random number generator with SEED The FILTER string is tested against the name of all tests, and only those tests whose names contain the filter are run. Multiple filter strings may be passed, which will run all tests matching any of the filters. By default, all tests are run in parallel. This can be altered with the --test-threads flag or the RUST_TEST_THREADS environment variable when running tests (set it to 1). By default, the tests are run in alphabetical order. Use --shuffle or set RUST_TEST_SHUFFLE to run the tests in random order. Pass the generated \"shuffle seed\" to --shuffle-seed (or set RUST_TEST_SHUFFLE_SEED) to run the tests in the same order again. Note that --shuffle and --shuffle-seed do not affect whether the tests are run in parallel. All tests have their standard output and standard error captured by default. This can be overridden with the --nocapture flag or setting RUST_TEST_NOCAPTURE environment variable to a value other than \"0\". Logging is not captured by default. Test Attributes: `#[test]` - Indicates a function is a test to be run. This function takes no arguments. `#[bench]` - Indicates a function is a benchmark to be run. This function takes one argument (test::Bencher). `#[should_panic]` - This function (also labeled with `#[test]`) will only pass if the code causes a panic (an assertion failure or panic!) A message may be provided, which the failure string must contain: #[should_panic(expected = \"foo\")]. `#[ignore]` - When applied to a function which is already attributed as a test, then the test runner will ignore these tests during normal test runs. Running with --ignored or --include-ignored will run these tests.   こっちのオプションを使うとより精細にテストの実行をコントロールできます。\n例えば --no-capture オプションを使えばテストが吐いた出力を見ることができます。\n#[test]fn foo(){println!(\u0026#34;foo test\u0026#34;);}#[test]fn foo2(){println!(\u0026#34;foo2 test\u0026#34;);}$ cargo test -- --nocapture cargo test -- --nocapture Finished test [unoptimized + debuginfo] target(s) in 0.00s Running unittests (target/debug/deps/test_example-87b3befdea076842) running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Running tests/tests.rs (target/debug/deps/tests-ed358733425f347a) running 2 tests foo test foo2 test test foo ... ok test foo2 ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s あるいは正確に foo だけ実行したい場合に --exact フラグも有効です。 普通のテストの引数に名前を渡すものだと部分一致していればそのままテストされるので foo と foo2 や foo と foo_fail のようなテストが並んでいるときに foo だけを実行したくてもできません。\n$ cargo test foo Finished test [unoptimized + debuginfo] target(s) in 0.00s Running unittests (target/debug/deps/test_example-87b3befdea076842) running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Running tests/tests.rs (target/debug/deps/tests-ed358733425f347a) running 2 tests test foo ... ok test foo2 ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s そこでテストバイナリ側にある --exact フラグを使うと望んだものだけを実行できます。\n$ cargo test -- --exact foo Finished test [unoptimized + debuginfo] target(s) in 0.00s Running unittests (target/debug/deps/test_example-87b3befdea076842) running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Running tests/tests.rs (target/debug/deps/tests-ed358733425f347a) running 1 test test foo ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s 他にも実行スレッド数を制御したりといくつか必要になりそうな機能があるのでテストの実行のしかたを変えたいという人は一度バイナリ側のヘルプも読んでみて下さい。\n","categories":["Rust","Advent Calendar","Advent Calendar 2021","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2021","/categories/rust-advent-calendar"],"date":"2021-12-20","title":"Rustのテストは2種類のオプションがある","url":"https://KeenS.github.io/blog/2021/12/20/rustnotesutoha2shuruinoopushongaaru/"},
  {"body":" κeenです。SML# 3.7.0から実験的機能として _dynamiccase に存在型のサポートが入ったので試してみます。\n本記事はSML# 4.0.0 with LLVM 12.0.0で動作確認を行っています。\nDynamicについて _dynamiccase 以前にDynamicの説明から入りましょう。 DynamicはSML# 3.5.0から入った機能です。 型を消して代わりにデータに埋め込んでおき、使うときにその型を復元して使えるものです。\n型を消す（型をデータに埋め込む）のは Dynamic.dynamic などのプリミティブを、型を復元するのは _dynamic などの制御構造を使います。\nval x = Dynamic.dynamic {a = 1, b = \u0026#34;c\u0026#34;} (* val x = _ : Dynamic.void Dynamic.dyn *) val y = _dynamic x as {a:int, b:string} (* val y = {a = 1, b = \u0026#34;c\u0026#34;} : {a : int, b : string} *) Dynamicは色々面白い使い方ができます。一旦型情報をデータにしてしまえばリフレクションが可能なのでどんな型にも使えるpretty printも実装可能になります。\nDynamic.pp {a = 1, b = \u0026#34;c\u0026#34;} (* =\u0026gt; {a = 1, b = \u0026#34;c\u0026#34;} *) 他にも面白い話題はありますが、今回のトピックは _dynamiccase なのでそれに触れます。 _dynamiccase は _dynamic のパターンマッチ版で、マッチした型を復元します。\nval x = Dynamic.dynamic {a = 1, b = \u0026#34;c\u0026#34;} _dynamiccase x of {a: int, b: int} =\u0026gt; \u0026#34;first\u0026#34; (* 変数aとbが使える *) | {a: int, b: string} =\u0026gt; \u0026#34;second\u0026#34; (* \u0026#34;second\u0026#34; *) ここまで、Dynamicと _dynamiccase の紹介でした。\n_dynamiccase のexistential typeサポート SML# 3.7.0から入った実験的なexistential typeサポートでは _dynamiccase で存在型が使えます。 節の冒頭で {'a} の形で型変数を導入し、パターン内でその 'a が使えます。 パターンの腕では {'a} の中身は分からりません。 'a 型がついた値はパターンの腕からは脱出できないので関数を値に適用するなどして型を潰す必要があります。\nfun apply x = _dynamiccase x of {\u0026#39;a} (f:\u0026#39;a -\u0026gt; int, x:\u0026#39;a) =\u0026gt; f x; apply (Dynamic.dynamic (foldl (op +) 0, [1, 1])); apply (Dynamic.dynamic (trunc, 2.34)); 上記の例では 'a にそれぞれ int 、 real が代入されますが、最終的には int を返しています。 ちょっと使い道が分かりづらいかもしれませんが、いくつか面白いことができます。\nダックタイピング 存在型を使うとダックタイピングができます。 ダックタイピングは「アヒルのように鳴きアヒルのように歩くならそれはアヒルだ」という例えに表されるようにデータの型ではなくメッセージを受け取れるかに着目します。 これからデータの型は異なるが同じ振る舞いをするオブジェクトを作っていきます。\nまずは準備からはじめましょう。必須ではないですが、分かりやすいようDynamicをラップした型を定義しておきます。\ndatatype obj = Obj of Dynamic.dynamic toString を呼べるオブジェクトを作りたいのでそのオブジェクトを表わす型を作っておきます。データとメソッドのレコードです。\ntype \u0026#39;self objRec = {data: \u0026#39;self, toString: \u0026#39;self -\u0026gt; string} 型パラメータに 'self と名付けているように、data がいわゆるselfのつもりです。ユーザがこの型を用意したらオブジェクトが作れます。\n雰囲気を出すために new 関数も用意しておきましょう。\nfun \u0026#39;self#reify new (obj: \u0026#39;self objRec) = Obj (Dynamic.dynamic obj) 'self に #reify という修飾がついているのはSML# 独自の拡張です。 型をデータとして書き込むために（=Dynamic.dynamicを呼ぶために）型情報を取り出せる必要があるのでついています。ここはあまり深くは踏み込まずに次に進みます。\nこの new で作ったデータ型に対して toString を呼べるようにしてみます。 dynamic を _dynamiccase にかけてデータを復元します。このとき多相になっていた 'self を存在型で表現してあげるとうまくいきます。\nfun toString (Obj obj) = _dynamiccase obj of {\u0026#39;self} {data: \u0026#39;self, toString: \u0026#39;self -\u0026gt; string} =\u0026gt; toString data selfとselfを第一引数に取るメソッドがあればそれっぽくなる、というのはある程度ダックタイピングに慣れた人なら理解頂けると思います。\nこれで役者が揃ったのでREPLで使ってみましょう。まずは new を使ってオブジェクトをいくつか作ってみます。\n# val intObj = new {data = 1, toString = Int.toString}; val intObj = Obj _ : obj # val realObj = new {data = 0.1, toString = Real.toString}; val realObj = Obj _ : obj intObj と realObj はそれぞれ型が異なりますが、どちらも obj になっています。これらの obj に toString を呼んでみましょう。\n# toString intObj; val it = \u0026#34;1\u0026#34; : string # toString realObj; val it = \u0026#34;0.1\u0026#34; : string 元の型は異なるのに1つの関数で双方を扱えました。intObj と realObj は同じ obj 型なのでリストに共存させることも可能です。\n# map toString [intObj, realObj]; val it = [\u0026#34;1\u0026#34;, \u0026#34;0.1\u0026#34;] : string list こうしてSMLでダックタイピングができるようになりました。\n拡張可能なオブジェクト 上記のオブジェクトは面白いんですが、フィールドが増えたときに _dynamiccase に失敗するという問題があります。\n例えばメソッド toInt を増やした場合にオブジェクトの実体はこうなります。\ntype \u0026#39;self objRec = {data: \u0026#39;self, toString: \u0026#39;self -\u0026gt; string, toInt: \u0026#39;self -\u0026gt; int} しかし toString がそのままだと toInt フィールドがないのでマッチせずに呼出に失敗してしまいます。 必要なフィールドは揃っているはずなのにもどかしいですよね。そこで、必要なオブジェクトだけを取り出すようにしてみます。\n_dynamiccase には余計なフィールドを無視する機能はなさそうでした。例えばレコードのパターンマッチに ... を使うとICEになります。\nfun toString (Obj obj) = _dynamiccase obj of {\u0026#39;self} {data: \u0026#39;self, toString: \u0026#39;self -\u0026gt; string, ...} =\u0026gt; toString data (* Bug.Bug: PolyTyElimination: compileTy: BOUNDVARty at src/compiler/compilePhases/polytyelimination/main/PolyTyElimination.sml:17.14(302) *) そこでDynamic側をいじって必要なデータだけを持つDynamicを作ることにします。 このあたりはSML#のリフレクションAPIに踏み込むので深くは触れませんが、以下のようなキャスト関数を定義すると上手くいきそうでした。\nfun cast dyn labels = let val terms = map (fn label =\u0026gt; (label, Dynamic.dynamicToTerm (Dynamic.## label dyn))) labels in Dynamic.termToDynamic (Dynamic.Record terms) end このキャストを使って obj と toString フィールドだけを抜き出すようにした toString を定義してみます。\nfun toString (Obj obj) = _dynamiccase (cast obj [\u0026#34;data\u0026#34;, \u0026#34;toString\u0026#34;]) of {\u0026#39;self} {data: \u0026#39;self, toString: \u0026#39;self -\u0026gt; string} =\u0026gt; toString data _dynamiccase にかける前に cast を呼ぶことで必要なフィールドのみ取り出しています。 同様に toInt も定義可能なので定義しておきます。\nfun toInt (Obj obj) = _dynamiccase (cast obj [\u0026#34;data\u0026#34;, \u0026#34;toInt\u0026#34;]) of {\u0026#39;self} {data: \u0026#39;self, toInt: \u0026#39;self -\u0026gt; int} =\u0026gt; toInt data これでREPLで試しましょう。 intObj と realObj を再定義して toInt も持つようにします。\n# type \u0026#39;self objRec = {data: \u0026#39;self, toString: \u0026#39;self -\u0026gt; string, toInt: \u0026#39;self -\u0026gt; int}; # fun \u0026#39;self#reify new (obj: \u0026#39;self objRec) = Obj (Dynamic.dynamic obj); # val intObj = new {data = 1, toString = Int.toString, toInt = fn x =\u0026gt; x}; # val realObj = new {data = 0.1, toString = Real.toString, toInt = Real.round}; Dynamicを使って既存のオブジェクトを拡張することもできますが、ちょっとややこしいので素直に再度定義します。\nこれらの拡張したオブジェクトを toString や toInt に適用します。\n# toString intObj; val it = \u0026#34;1\u0026#34; : string # toInt realObj; val it = 0 : int 呼べていますね。ということでSML#でダックタイピングでした。\nこのあと真面目にオブジェクト指向っぽくやるなら作り込み要素はいっぱいありますが、遊ぶだけならこれで十分でしょう。\n第一級モジュールっぽいやつ 思ったよりダックタイピングで疲れたのでこっちは雑にいきます。\n第一級モジュールはモジュールを値として扱えるやつです（雑）。 OCamlとかにはありますが、SMLにはありません。\nモジュールを値として扱うときはほとんどレコードのようなものにエンコードできます。 val がそのままレコードにエンコードされるのですが、 type は存在型へエンコードすることになります。 そこで _dynamiccase の存在型を使うとそれっぽくなるんじゃないかという趣旨です。 第一級モジュールの存在型周りはかなりややこしかった気がしますが疲れたのでそれっぽければ良いことにします。\nまずはエンコードする前のモジュールのシグネチャと構造を提示します。\nsignature Color = sig type t val toCode: t -\u0026gt; string end structure RGBColor: Color = struct datatype t = RGB of word8 * word8 * word8 fun toCode (RGB (r, g, b)) = let fun to c = if c \u0026lt;= 0wxff then \u0026#34;0\u0026#34; ^ (Word8.toString c) else Word8.toString c in \u0026#34;#\u0026#34; ^ (to r) ^ (to g) ^ (to b) end end はい。これをレコード（など）にエンコードしていきましょう。 初っ端からインチキですが、モジュールのレコードと、t の値の両方をデータに持つことにします。\ntype \u0026#39;a fstColor = {color: \u0026#39;a, toCode: \u0026#39;a -\u0026gt; string} 例によって雰囲気出すためにpackを関数を作っておきます。\nfun \u0026#39;a#reify packColor (m: \u0026#39;a fstColor) = Dynamic.dynamic m あとはなんか _dynamiccase でunpackするだけ！\nfun toCode d = _dynamiccase d of {\u0026#39;a} {color: \u0026#39;a, toCode: \u0026#39;a -\u0026gt; string} =\u0026gt; toCode color … M.t とかの型を書けないのでダックタイピングと一緒ですね。ダメだったよ…\nまとめ SML# 3.7.0で入った _dynamiccase の存在型のサポートを使ってダックタイピングをやってみました。 試してないですが、reificationで型情報を取り出せるのでクラスやプロトタイプの仕組みを知っている人なら自分でオブジェクト指向っぽい枠組みを作れるんじゃないかと思います。\n","categories":["SML#","SML"],"category_urls":["/categories/sml","/categories/sml"],"date":"2021-10-03","title":"SML#のexistential typeで遊ぶ","url":"https://KeenS.github.io/blog/2021/10/03/sml_noexistential_typedeasobu/"},
  {"body":"# Idris2の数量的型が解決した問題導入した問題 ---------------------- [第一回関数型プログラミング（仮）の会 - connpass](https://opt.connpass.com/event/222709/) === # About Me --------- ![κeenのアイコン](/images/kappa2_vest.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * GitHub: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === Agenda ------- * IdrisとIdris 2の紹介 * Idrisでの問題意識 * Idris 2での解決 * Idris 2の問題 === # Idrisとは？ ------------- * *型駆動開発* のために作られた言語 * [最新版は1.3.3](https://github.com/idris-lang/Idris-dev) * だいたい「依存型のあるHaskell」 * 読んで→[プログラング言語Idrisに入門させたい](https://zenn.dev/blackenedgold/books/introduction-to-idris) ``` haskell main : IO () main = putStrLn \"Hello World\" ``` === # Idris2とは？ ------------- * Idrisを改善した言語 + 以後便宜的に現IdrisをIdris 1と呼ぶ + Idris 1とはおおむね互換 * [最新版は0.5.1](https://github.com/idris-lang/Idris2) * Idris 1との違いの1つはコア言語が数量的型システムベース * その他色々速いなど === # Idrisで依存型入門 ------------------- * 感覚的には「型の位置に値が置ける」システム + 計算もできる ``` haskell import Data.Vect v : Vect 3 Integer v = [1, 2, 3] -- 数値の計算 append: Vect n a - Vect m a - Vect (n+m) a -- ... ``` === # Idrisでの依存型 ------------------- * Idrisでは依存型に書いた値を取り出せる ``` haskell import Data.Vect len: Vect n a - Nat len {n} _ = n ``` === # Idrisでの依存型 ------------------- * 内部的には型を引数で受け取ってる ``` haskell import Data.Vect len: {n:Nat} - {a:Type} - Vect n a - Nat len {n} _ = n ``` === # Idrisで型駆動開発 ------------------ * Idrisでは型を書いたらそれをガイドに実装できる * →デモ ``` haskell append: Vect n a - Vect m a - Vect (n+m) a append xs ys = ?appendV_rhs ``` === # Idrisで型駆動開発 ------------------ ```text - + Main.appendV_rhs [P] `-- a : Type m : Nat ys : Vect m a n : Nat xs : Vect n a -------------------------------------- Main.appendV_rhs : Vect (plus n m) a ``` === # Idris 1の型の問題点 --------------------- * 依存型の引数 * 型駆動開発の変数 === # 依存型の引数 ------------- * 型にその型を値として使っているかの情報がない + 下の例でnは使っているがaは使っていないなどが分からない * コンパイル時に型消去していいか分からない + → Idris 1はあんまり速くなかった ``` haskell import Data.Vect len: {n:Nat} - {a:Type} - Vect n a - Nat len {n} _ = n ``` === # 型駆動開発の変数 ------------------ * 型と値が両方環境に入っていて何が使えるのか分かりづらい ```text - + Main.appendV_rhs [P] `-- a : Type m : Nat ys : Vect m a n : Nat xs : Vect n a -------------------------------------- Main.appendV_rhs : Vect (plus n m) a ``` === # Idris 2の数量的型 ------------------ * その型の値を使える回数を表現できる + 0, 1, n（∞）がある + 1は実験的 + デフォルトはn * 数値は半環になってればよい === # 例: id --------- * デフォルトはnなので従来のプログラムと同じ ``` haskell id : (x : a) - a id x = x ``` === # 例: id1 --------- * xを1回しか使わないことを表明できる ``` haskell id1 : (1 x : a) - a id1 x = x ``` === # 例: double ------------- * 1回以上使うとエラー ``` haskell double : (1 x : a) - (a, a) double x = (x, x) ``` === # 例: double ------------- * 1回以上使うとエラー ``` text 1/1: Building playground (playground.idr) Error: While processing right hand side of double. Trying to use linear name x in non-linear context. playground:10:16--10:17 06 | id1 : (1 x : a) - a 07 | id1 x = x 08 | 09 | double : (1 x : a) - (a, a) 10 | double x = (x, x) ``` === # 例: id0 --------- * 0は使えないのでこの関数は実装できない ``` haskell id0 : (0 x : a) - a id0 x = x ``` === # 例: id0 --------- * 0は使えないのでこの関数は実装できない ``` text 1/1: Building playground (playground.idr) Error: While processing right hand side of id0. x is not accessible in this context. playground:7:9--7:10 3 | main : IO () 4 | main = putStrLn \"Hello\" 5 | 6 | id0 : (0 x : a) - a 7 | id0 x = x ^ ``` === # 例: ignore1 -------------- * 1を一度も使わないとエラー ``` haskell ``` === # 例: ignore1 -------------- * 1を一度も使わないとエラー ``` text Error: While processing right hand side of ignore1. There are 0 uses of linear name (implicit) _. playground:7:13--7:15 3 | main : IO () 4 | main = putStrLn \"Hello\" 5 | 6 | ignore1 : (1 x : a) - () 7 | ignore1 _ = () ^^ Suggestion: linearly bounded variables must be used exactly once. Error(s) building file playground.idr ``` === # 数量的型による解決 ## 依存型の型消去 * 使う型引数だけnにすればよい + 型引数は省略するとデフォルト0 ``` haskell len: {n:Nat} - Vect n a - Nat len {n} _ = n ``` === # 数量的型による解決 ## 型駆動開発の変数問題 * 型に0がつくことで使える値と使えない値が分かりやくなる ``` text 0 m : Nat 0 a : Type 0 n : Nat ys : Vect m a xs : Vect n a ------------------------------ hole : Vect (plus n m) a ``` === # Idris 2の型の問題点 --------------------------- * 多重度が違うと違う型になるので扱いづらい + `id1` は `map` には渡せない * v0.2までは多重度のサブタイピングをしていた * → サブタイピングにより[健全性が壊れていた](https://github.com/idris-lang/Idris2/issues/73) * 今はサブタイピングを止めた + 将来的には多重度の多相などが入るかも === # まとめ --------- * 数量的型で依存型の実行効率が良くなった * 数量的型で型駆動開発が便利になった * 関数の世界が分かれるので扱いづらい面も + 将来改善されるかもね   ","categories":["Idris","Idris2","型"],"category_urls":["/categories/idris","/categories/idris2","/categories/%e5%9e%8b"],"date":"2021-09-26","title":"Idris 2の数量的型が解決した問題、導入した問題","url":"https://KeenS.github.io/slide/idris_2nosuuryoutekikatagakaiketsushitamondai_dounyuushitamondai/"},
  {"body":"# PLDI論文読み会: Perceus: Garbage Free Reference Counting with Reuse ---------------------- 社内勉強会 === # About Me --------- ![κeenのアイコン](/images/kappa2_vest.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * GitHub: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # 概要 （[高速で論文がバリバリ読める落合先生のフォーマットがいい感じだったのでメモ - 書架とラフレンツェ](https://lafrenze.hatenablog.com/entry/2015/08/04/120205)） === # 概要 ## どんなもの？ 参照カウントのdup/dropを挿入するすごいアルゴリズム === # 概要 ## 先行研究と比べてどこがすごい？ * ゴミが発生しない * メモリの開放/確保を短絡して再利用ができる + 再利用を保証できる + Functional but In-Placeという書き方ができるようになる * 参照カウントを形式化して今回のアルゴリズムの正当性を証明した * （遅いと言われる参照カウントながら）他のメモリ管理システムと同等の速度が出る === # 概要 ## 技術や手法のキモはどこ？ * 参照カウントの操作（dup/drop）を明示的に扱うことでメモリ操作の最適化ができるようにした * 参照カウントのdup/dropをゴミが発生した箇所に正確に挿入する、線型論理に似た形式的な規則（アルゴリズム）を開発した。 * 変数環境に線形環境と借用環境を用意し、それら不変条件を維持しながらdup/dropを挿入するようにしてby constructionで正しく変換した === # 概要 ## どうやって有効だと検証した？ * 健全性（必要なデータが破棄されないこと）→証明 * 正確性（計算の途中でゴミが発生しないこと）→証明 + 正当性（最終的にゴミがないこと）よりも強い * パフォーマンス/メモリ使用量→Kokaという言語に実装していくつかの言語とベンチマークを比較した === # 概要 ## 議論はある？ * 参照カウントの循環参照問題には対応できていない。 + ただし入っているのが関数型言語で可変参照を使わない限りcycleは起きないので大きな問題にはなってない + 例えばswiftなどでもcycle collectionはないがうまくやっている。 === # 概要 ## 次に読むべき論文は？ * Sebastian Ullrich and Leonardo de Moura. Counting immutable beans – reference counting optimized for purely functional programming. In Proceedings of the 31st symposium on Implementation and Application of Functional Languages (IFL’19), September 2019. + 参考にしたLean言語について * Phillip Wadler. Linear types can change the world! In Programming Concepts and Methods, 1990. + 線形型について === # 1. Introduction * 参照カウントは手軽に実装できてメモリ負荷も低いけど最近は下火 * 静的な保証の強い言語で効率的な参照カウントを目指す + Leanに実装された参照カウントのアイディアを一般化してKokaで扱う + Lean（定理証明支援系）とは違い、Kokaには例外などがある === # やったこと * ゴミが出ない参照カウントをする * 正確な参照カウントにより最適化ができることを示す + ※論文中では具体的なアルゴリズムは示されていない * 特定の書き方でin-placeな更新になることを保証する + それによりFBIPというパラダイムが可能にる + TCOにより関数だけでループが書けるようになるのに似てる * $\\lambda^1$ という計算体系を提案し参照カウントを定式化する * PerceusというKoka言語に搭載されているアルゴリズムを提案する * Kokaに実装されたPerceusを他のメモリ管理システムとベンチマーク比較する === # 2. Overview * 参照カウントには3つの問題がある * 並行性 * 正確性 * 循環参照 * 積極評価で関数型で不変なデータ型でで強い静的型付きでエフェクトシステムのある言語という設定でアプローチする === ## 2.1 Types and Effects * Kokaでやるよ * 例外やasync/awaitみたいに関数を最後まで実行しないやつはコンパイラが変換して消してくれるよ + 関数末尾に書いたdropが呼ばれないみたいなのは気にしなくてよくなる * コンパイルするとC11になってランタイム不要で動く === ## 2.2 Precise Reference Counting * よくある手法（Rustなど）だと中間にゴミが出るよ ``` fun foo() { val xs = list(1,1000000) // ここでxsを開放したい val ys = map(xs, inc) print(ys) drop(xs) drop(ys) } ``` === ## 例: map ``` fun map( xs : list ⟨a⟩, f : a - e b ) : e list ⟨b⟩ { match(xs) { Cons(x,xx) - Cons(f(x), map(xx,f)) Nil - Nil } } ``` === ## 例: map dup/dropが多い ``` fun map( xs, f ) { match(xs) { Cons(x,xx) { dup(x); dup(xx); drop(xs) Cons(dup(f)(x), map(xx, f)) } Nil { drop(xs); drop(f); Nil } } } ``` === ## 2.3 Drop Specialization dropのis-uniqueをまとめたい ``` fun drop( x ) { if (is-unique(x)) then drop children of x; free(x) else decref(x) } ``` === ## 例: map ``` fun map( xs, f ) { match(xs) { Cons(x,xx) { dup(x); dup(xx) if (is-unique(xs)) then drop(x); drop(xx); free(xs) else decref(xs) Cons( dup(f)(x), map(xx, f)) } Nil { drop(xs); drop(f); Nil } } } ``` === ## 例: map dup→dropをfusionできる ``` fun map( xs, f ) { match(xs) { Cons(x,xx) { if (is-unique(xs)) then free(xs) else dup(x); dup(xx); decref(xs) Cons( dup(f)(x), map(xx, f)) } Nil { drop(xs); drop(f); Nil } } } ``` === ## 2.4 Reuse Analysis * カウントが1のときにdropして再度コンストラクタで構築するのがもったいない * →カウントが1ならdropせずにメモリに上書きする ``` fun Cons@ru(x, xx) { if (ru!=NULL) then { ru-head := x; ru-tail := xx; ru } // in-place else Cons(x,xx) // malloc’d } ``` === ## 例: map ``` fun map( xs, f ) { match(xs) { Cons(x,xx) { dup(x); dup(xx); val ru = drop-reuse(xs) Cons@ru(dup(f)(x), map(xx, f)) } Nil { drop(xs); drop(f); Nil } } } ``` === ## 例: map さっきまでの最適化も併用できる ``` fun map( xs, f ) { match(xs) { Cons(x,xx) { val ru = if (is-unique(xs)) then \u0026xs else dup(x); (dup xx); decref(xs); NULL Cons@ru(dup(f)(x), map(xx, f)) } Nil { drop(xs); drop(f); Nil } } } ``` === ## 2.5 Reuse Specialization * reuseするときにフィールドの一部しか変わらないならそこだけ変更するよ === ## 2.6 A New Paradigm: Functional but In-Place (FBIP) * （コード例がでてきて長い） * パターンマッチして即同じ大きさのデータを作り直す系の操作をデータがユニークならin-placeにできる + → それに依拠することで新しい書き方が生まれるのでは === `tmap` が末尾再帰でないのでスタックは使う ``` type tree { Tip Bin(left: tree, value : int, right: tree ) } fun tmap(t : tree, f : int - int ) : tree { match(t) { Bin(l,x,r) - Bin(tmap(l,f), f(x), tmap(r,f) ) Tip - Tip } } ``` === Fig. 3 tmapが末尾再帰だしreuseされてるのでin-placeになってる ``` type visitor { Done BinR(right:tree, value : int, visit : visitor ) BinL(left:tree, value : int, visit : visitor ) } type direction { Up; Down } fun tmap(f : int - int, t : tree, visit : visitor, d : direction ) : tree { match(d) { Down - match(t) { // going down a left spine Bin(l,x,r) - tmap(f,l,BinR(r,x,visit),Down) // A Tip - tmap(f,Tip,visit,Up) // B } Up - match(visit) { // go up through the visitor Done - t // C BinR(r,x,v) - tmap(f,r,BinL(t,f(x),v),Down) // D BinL(l,x,v) - tmap(f,Bin(l,x,t),v,Up) // E } } } ``` === ## 2.7 Static Guarantees and Language Features 今回の前提となる機能について * 2.7.1 Non-Linear Control Flow + 例外やasync/awaitはコンパイル時に潰せる * 2.7.2 Concurrent Execution + 並行な実行はどの値が共有されてるか静的に分かる前提 + でないと実行の50%くらいがリファレンスカウントの同期を取る操作に使われるという調査もある === ## 2.7 Static Guarantees and Language Features 今回の前提となる機能について2 * 2.7.3 Mutation + 可変な参照はあまり使われない+共有される場合は分かる + dropの挿入に注意が必要（double-CASとかが必要になる） * 2.7.4 Cycles + ほとんど発生しない前提 + 可変参照はヤバいけどあんまり使われないよ === # 3. A Linear Resource Calculus * $\\lambda^1$ という計算を提案する。 * 線型論理にちょっと似てる。 ``` syntax - derivation -- standard semantics | \\- heap semantics \\- syntax driven derivation (= Perceus) ``` === ## 3.1 Syntax Fig. 4 * 灰背景の式はderivationで作られる * 変数環境に $\\Delta$ と $\\Gamma$ があって多重集合 * $\\lambda^{ys}\\ x. e$ はクロージャ（$ys$ をキャプチャする） === ## 3.2 The Linear Resource Calculus Fig. 5 * 環境の値は丁度一度使う。例えば2回使う変数はdupをはさむ。1回も使わない変数はdropする * $\\lambda\\ x y. x$ は $\\lambda\\ x y. \\mathbf{drop}\\ y; x$ * $\\Delta$ は借用環境、 $\\Gamma$ は線型環境。 Note: [VAR] 線型環境は空じゃないといけない [DUP] $x \\in \\Delta, \\Gamma$ （つまり既にxが使われている）かつ環境にxがある（=xが2回以上使われてる）ならdupする [DROP] 余計な変数はdropする [APP] $e1\\ e2$ をe1を先に評価するので $Gamma_1$ は $e1$ しか使えず、$\\Gamma_2$ はe1で借用できる [LAM] 全ての線型変数をキャプチャする [BIND], [BIND], [CON] あんまコメントなし === ## 例 借用環境が生きるケース $\\lambda\\ f g x. (f\\ x)\\ (g\\ x)$を変換することを考える。 借用がないと$\\lambda\\ f g x. \\mathbf{dup}\\ x;(f\\ x)\\ (g\\ x)$になる。 借用に入れとくと実際に使う（VAR、LAM、MATCH）直前にDUPをはさめる。 $\\lambda\\ f g x.(f\\ (\\mathbf{dup}\\ x; x))\\ (g\\ x)$ === ## 補題 $\\lceil e\\rceil$でeからdropとdupを除いたものとする。 Lemma 1 (この変換は元の式にdup/dropを挟むだけである) $\\Delta \\| \\Gamma \\vdash e \\rightsquigarrow e'$ ならば $e = \\lceil e' \\rceil$ 証明: 自明 === ## 3.3 Semantics * Fig.6 に普通の意味論（普通のとは） * Fig.7 にヒープの意味論がある * 定理1 ヒープ意味論は健全 * 定理2 評価の途中にヒープにある値は全てreachableである + ただし可変参照を入れると循環になる可能性がある * 略 Note: ヒープセマンティクスは (lam), (con) gensymしてヒープに変数を保存し、その変数を返す (app), (match) でgensymした変数をdropする (dup), (drop) 値のリファレンスカウント増減 (dlam), (dcon) 複合型のデストラクタ === ## 3.3 Semantics これでとりあえず正しくはなるが、dropが遅いケースもある。 $y \\mapsto ^1 () | (\\lambda x. x) (\\mathbf{drop} y; ())$ など。dropそのものがreachableの定義に入っているので不要になるタイミングより遅くdropしても正しいことになってしまう。 === ## 3.4 Perceus Fig. 8 * （ふつうの）derivationと似たやつ。ただし4つの不変条件をby constructionで維持する 1. 借用と線形は排他 2. $\\Gamma$ にはexpressionに必要な変数しかない 3. expressionに必要な変数は$\\Delta$と$\\Gamma$でカバーできる 4. （$\\Delta$と$\\Gamma$は多重集合だが）多重度を1にする Note: [SVAR] 変化なし [SVAR-DUP] 借用してる変数のみdupするように [SAPP], [SBIND], [SCON] 不変条件を守るためになんかややこしい式に [SLAM] 借用してる変数だけをdupするように [SLAM-DROP], [SBIND-DROP], [SMATCH] 使ってない変数はすぐさまdropするように === ## 定理（Perceusは健全） Theorem 3 $ \\Delta \\| \\Gamma \\vdash_s e \\rightsquigarrow e'$ ならば $\\Delta \\| \\Gamma \\vdash e \\rightsquigarrow e'$ 証明: Appendix D.4 ※逆は成り立たない === ## 逆の反例 例えば $(\\mathbf{val}\\ y = C_0; (\\lambda x. x)\\ (\\mathbf{drop}\\ y; C_1))$ は $\\vdash$ なら導出できる ``` ----------- [VAR] --------------- [CON] x |- x to x ∅ |- C_1 to C_1 ------------------------- [LAM] ------------------------- [DROP] ∅ |- (λ x. x) to (λ x. x) y |- C_1 to (drop y; C_1) -------------- [CON] ------------------------------------------------------------ [APP] ∅ |- C_0 - C_0 y |- (λ x. x) C_1 - (λ x. x) (drop y; C_1) ------------------------------------------------------------------------ [BIND] ∅ |- (val y = C_0; (λ x. x) C_1) - (val y = C_0; (λ x. x) (drop y; C_1)) ``` が、$\\vdash_s$はSBIND-DROPにいくので $(\\mathbf{val}\\ y = C_0; \\mathbf{drop}\\ y; (\\lambda x. x)\\ C_1)$にしかいけない === ## 定理（Perceusはgarbage free） Theorem 4 dup/drop以外の場面ではpreciseかつgarbage free dup/dropを除去した式でもreachableなのでprecise やっぱり可変参照があるとor in cycleの言明が入る === # 4. Benchmark 対象 * Koka:（perceusを実装している言語、C-ネイティブコードにコンパイルされる） * Koka no-opt:（Overviewで紹介した最適化をしてないやつ） + この論文のベンチマークとしてはこっちの方が適切 * OCaml: Stop the worldする世代別コレクタminorだとcopying GCでmajorだとtracing + 一般論としてStWするよりはしない方がいい + Kokaのほぼ直訳で実装 * Haskell: 多世代別GC。最適化がすごいことで有名 + Kokaのほぼ直訳だがstrictnessのアノテーションをつけた === # 4. Benchmark 対象 * Swift 参照カウントする処理系代表 + だいたい直訳だがtail callはループに直した * Java G1GC（参照カウントと同じく）low latencyを謳う + Swiftからの直訳 * C++ + 手動メモリ管理のベースラインとして。 + 挙動は微妙に違う。 === # 4. Benchmark ベンチマーク * 中規模で非自明でメモリにストレスをかけるタイプ。 * rbtree: 赤黒木への4200万アイテムの挿入 * rbtree-ck: rbtreeと似ているが、5回に1回の結果を保存 + subtreeの共有をするのでGCへの影響が大きい * deriv: 記号微分 * nqueens: n-queens問題のサイズ13の結果をリストに保存（してその長さを返す）。 + 子問題の結果を多数共有する * cfold: 簡単な計算式の定数畳み込み * [コード](https://github.com/koka-lang/koka/tree/master/test/bench) === ## 結果 * Fig.9に結果（Appendix Bに詳細な結果がある） * 10回の平均でKokaを1として何倍になるかを実行時間と最大物理メモリ使用量（rss）で計測 === ## 解釈 * KokaはC++のstd::mapに肉薄する速度（Kokaは関数型、C++はin-place） + C++は16byteアラインされたメモリが必要だがKokaは8byteアラインで済むから？ * rbtreeではKokaとKoka-no-optで2倍差がついてるから最適化大事 === ## 解釈 * それ以外（メモリ共有のある計算）では最適化があんまり効いてない。 + そもそもメモリ共有がないケースの最適化だからそれはそう * garbage freeを標榜してる以上全てのケースでメモリ最適でありたかったけどderivでOCamlに負けてる + メモリ以外の最適化（case of case）によりアロケーションが減ってそうだった + not (yet) implemented in Kokaなので実装されると改善されるかも === # 5. Related Work * Leanの参照カウントに似てる + reuse specializationとLean以外の言語に一般化した点が違う。 + 参照カウントを形式化して * メモリの再利用やdup/dropを明示的に使ってメモリ使用を最適化する手法はいくつか先行研究がある + 配列の更新の最適化が注目されていた。Kokaにはいるかも。なんかBTreeっぽいやつ作ればいけるっしょ === # 5. Related Work * $\\lambda^1$ はだいたい線形論理がベースになっている。ただし線形型は静的にカウントするがこっちは動的にカウントする。 + 線形型のヒープセマンティクスとして静的にメモリ保証するものや動的にメモリ保証するものなどがある * Swiftは参照カウントでreuse-analysisをしないが、そもそも可変性を許容するのであんまり関係なさそう * これは静的に参照カウントの操作を減らすが、逆に動的に参照カウントをどうにかするシステムもある + 参照カウントの操作をサボって定期的にスタックを走査してカウントを合わせる === # 6. Conclusion * 正確かつreuseとspecializationをする参照カウントシステムのPerceusを提示した * $\\lambda^1$計算を提案した * Kokaに実装しており、既存のメモリ管理システムと肩を並べる程度の速度がある * 将来は循環参照問題や借用などに取り組みたい   ","categories":["GC","ランタイム","言語処理系"],"category_urls":["/categories/gc","/categories/%e3%83%a9%e3%83%b3%e3%82%bf%e3%82%a4%e3%83%a0","/categories/%e8%a8%80%e8%aa%9e%e5%87%a6%e7%90%86%e7%b3%bb"],"date":"2021-09-17","title":"PLDI論文読み会: Perceus: Garbage Free Reference Counting with Reuse","url":"https://KeenS.github.io/slide/pldironbunyomikai__perceus__garbage_free_reference_counting_with_reuse/"},
  {"body":"前回の続きで実例を書いていきます。\n$ \\def\\cat{\\mathrm{++}} \\def\\hom#1{{#1}\\mathrm{-}準同型} \\def\\leftwards#1{{#1}\\mathrm{-}左方向} \\def\\rightwards#1{{#1}\\mathrm{-}右方向} $\nおさらい 今回の導出を追う上で必要になる知識を思い出します。\nリストの第三準同型定理はざっくりいうと「ある処理が foldr でも foldl でも書けるなら分割統治で書き換えられる」という定理なのでした。それを証明する道中でいくつかの性質も確認しました。\n定義（リストの準同型）： 二項演算 $\\odot$ に対してリスト上の $h$ 関数が以下の条件を満たすとき、 $h$ を $\\hom{\\odot}$ という\n\\[ h\\ (x \\cat y) = h\\ x \\odot h\\ y \\]\n結合的な演算子 $\\odot$ とその単位元 $e$ に対して $hom\\ (\\odot)\\ f\\ e$ と書いて、 $\\hom{\\odot}$ な $h \\circ [\\cdot] = f$ である（一意な）関数 $h$ を表わす。\n定義（左方向関数）： $h: List a \\to b$ が二項演算子 $\\oplus: a \\times b \\to b$ に関して以下の条件を満たすとき、 $h$ を $\\leftwards{\\oplus}$ という。\n\\[ h ([a] \\cat y) = a \\oplus h\\ y \\]\n$\\leftwards{\\oplus}$ 関数 $h$ が $h\\ [] = e$ を満たすとき、 $foldr\\ (\\oplus)\\ e$ と書く。このとき $h$ は一意である。\nここで $foldr$ の重要な性質を提示します。 $\\cat$ の $foldr$ は2つの $foldr$ に分解できるということ。\n\\[ foldr\\ (\\oplus)\\ e\\ (x \\cat y) = foldr\\ (\\oplus)\\ (foldr\\ (\\oplus)\\ e\\ y)\\ x \\]\n左方向関数と同様に、右方向関数も定義できます。\n定義（右方向関数）： $h: List\\ a \\to b$ が二項演算子 $\\otimes: b \\times a \\to b$ に関して以下の条件を満たすとき、 $h$ を $\\rightwards{\\otimes}$ という。\n\\[ h\\ (x \\cat [a]) = h\\ x \\otimes a \\]\n左方向関数と同様に $foldl$ も導入しましょう。 $\\rightwards{\\otimes}$ 関数 $h$ が $h\\ [] = e$ を満たすとき、 $foldl\\ (\\otimes)\\ e$ と書く。このとき $h$ は一意である。\n左方向関数と同様に、 foldl には重要な性質があります。\n\\[ foldl\\ (\\otimes)\\ e\\ (x \\cat y) = foldl\\ (\\otimes)\\ (foldl\\ (\\otimes)\\ e\\ x)\\ y \\]\nです。\n補題1： 全ての計算可能で全関数である、列挙可能な定義域をもつ $h$ に対して、 計算可能（だが部分関数である可能性もある）関数 $g$ が存在して $h \\circ g \\circ h = h$ を満たす。\n定理（第三準同型定理）： リスト上の関数 $h$ が左方向かつ右方向であるとき、 $h$ は準同型である。\nそれと前回の内容には含まれていませんが $foldr$ と $foldl$ の追加の性質についても確認しておきます。\n\\[ \\begin{align} foldr\\ (\\oplus)\\ x\\ (b:y) \u0026amp; = b \\oplus\\ foldr\\ (\\oplus)\\ x\\ y \\\\\nfoldl\\ (\\otimes)\\ x\\ (b:y) \u0026amp; = foldl\\ (\\otimes)\\ (x \\otimes b)\\ y \\end{align} \\]\nこれらを元に進めていきます\n実例：ソート 挿入ソート（$O(n^2)$）をリストの第三準同型定理（など）を用いてマージソート（$O(n\\log n)$）へと変換していきます。\nソートは左方向かつ右方向 ソートは $ins$ を用いて $foldr$ を使って実装できるので左方向です。\n\\[ sort\\ = foldr\\ ins\\ [] \\]\nここで $ins$ の定義は以下です。\n\\[ \\begin{align} ins\\ a\\ [] \u0026amp; = [a] \\\\\nins\\ a\\ (b:x) \u0026amp; = \\begin{cases} a : ins\\ b\\ x \u0026amp;, \\mathrm{if}\\ a \\le b \\\\\nb : ins\\ a\\ x \u0026amp;, \\mathrm{otherwise} \\end{cases} \\end{align} \\]\n同時に右方向でもあります。 何故なら ins の引数を逆にした ins' を用いて foldl で書けるからです。\n\\[ \\begin{align} sort\\ \u0026amp;= foldl\\ ins\u0026rsquo;\\ [] \\\\\nins\u0026rsquo;\\ x\\ a \u0026amp;= ins\\ a\\ x \\end{align} \\]\nリストの第三準同型定理の適用 $sort$ が右方向かつ左方向であることが分かったので、リストの第三準同型定理より $sort$ はリストの準同型です。つまり、ある二項演算 $\\odot$ を用いて以下のように書けるということです。\n\\[ sort (x \\cat y) = sort\\ x \\odot sort\\ y \\]\nリストの第三準同型定理を証明する中での補題1の使い方を思い出すと $\\odot$ は $sort \\circ unsort \\circ sort$ を満たす関数 $unsort$ を用いた以下の定義が条件を満たします。\n\\[ u \\odot v = sort (unsort\\ u \\cat unsort\\ v) \\]\n条件さえ満たせば $unsort$ は何でもいいので $id$ を選びます。すると $\\odot$ が簡単になります。\n\\[ u \\odot v = sort (u \\cat v) \\]\nまとめると、 リストの第三準同型定理を使えば $sort$ は以下の等式を満たすことが分かります。\n\\[ sort (x \\cat y) = sort(sort\\ x \\cat sort\\ y) \\]\n…あれ？あんまり簡単になってる気がしませんね。実際効率は悪いです。そこでここから効率化していきます。 $\\odot$ に渡るリストがソート済みであることに着目すれば効率化できそうです。\n$\\odot$ の効率化 リスト $u$ がソート済みである場合 $u = sort\\ u$ であることに注目しましょう。 その上で $\\odot$ への引数 $u$ と $v$ がソート済みであることに着目して式変形していきます。\n\\[ \\begin{align} u \\odot v \u0026amp; = sort (u \\cat v) \u0026amp; （定義より） \\\\\n\u0026amp; = foldl\\ ins\u0026rsquo;\\ []\\ (u \\cat v) \u0026amp; （sortは右方向より） \\\\\n\u0026amp; = foldl\\ ins\u0026rsquo;\\ (foldl\\ ins\u0026rsquo;\\ u) v \u0026amp; （foldlの性質より） \\\\\n\u0026amp; = foldl\\ ins\u0026rsquo;\\ (sort\\ u) v \u0026amp; （sortは右方向より） \\\\\n\u0026amp; = foldl\\ ins\u0026rsquo;\\ u\\ v \u0026amp; （uはソート済みより） \\\\\n\u0026amp; = merge\\ u\\ v \u0026amp; （merge = foldl\\ ins\u0026rsquo; と定義） \\end{align} \\]\n最後に $foldl\\ ins\u0026rsquo;$ のことを $merge$ と呼ぶようにしました。この $merge$ はマージソートで使われるマージと同じ挙動をします。実際、以下の2つ事実から確認できます。\n\\[ \\begin{align} merge\\ u\\ [] \u0026amp; = foldl\\ ins\u0026rsquo;\\ u\\ [] \\\\\n\u0026amp; = [] \\\\\nmerge\\ u\\ (b:v) \u0026amp; = foldl\\ ins\u0026rsquo;\\ u\\ (b:v) \\\\\n\u0026amp; = foldl\\ ins\u0026rsquo;\\ (ins\u0026rsquo;\\ u\\ b)\\ v \\\\\n\u0026amp; = merge\\ (ins\u0026rsquo;\\ u\\ b) \\end{align} \\]\nこれは $u$ がソート済みであるという仮定の下簡易的に使われる $merge$ の実装と同じものです。 ただし簡易的にと書いた通りこれまた効率は悪いので $merge$ も効率化しましょう。\n$merge$ の効率化 $merge$ は $merge\\ u\\ v$ の形で使われていて、 $u$ がソート済みであれば正しい実装になっていそうなことを確認しました。ここでは $v$ もソート済みであることを用いて効率化します。\n値 $a$ とリスト $v$ について $v$ の全ての要素が $a$ 以上であることを $a \\le v$ と表わすことにします。\n補題3： 値 $a$ 、 リスト $x$ 、 $y$ について $a \\le x$ かつ $a \\le y$ であるとき以下が成り立つ\n\\[ foldl\\ ins\u0026rsquo;\\ (a : x)\\ y = a : foldl\\ ins\u0026rsquo;\\ x\\ y \\]\n証明：数学的帰納法による。 任意の値 $a$ リスト $x$ について考える。 $y = []$ の場合、両辺ともに $a:x$ になる。 $y\u0026rsquo;$ の場合に成り立つとして $y = b : y\u0026rsquo;$ の場合について考える。\n\\[ \\begin{align} foldl\\ ins\u0026rsquo;\\ (a:x)\\ (b:y\u0026rsquo;) \u0026amp; = foldl\\ ins\u0026rsquo;\\ (ins\u0026rsquo;\\ (a:x)\\ b)\\ y\u0026rsquo; \u0026amp; （foldlの性質より） \\\\\n\u0026amp; = foldl\\ ins\u0026rsquo;\\ (a : ins\u0026rsquo;\\ x\\ b)\\ y\u0026rsquo; \u0026amp; （ins\u0026rsquo;のa \\le bより） \\\\\n\u0026amp; = a : foldl\\ ins\u0026rsquo;\\ (ins\u0026rsquo;\\ x\\ b)\\ y\u0026rsquo; \u0026amp; （帰納法の仮定より） \\\\\n\u0026amp; = a : foldl\\ ins\u0026rsquo;\\ x\\ (b:y\u0026rsquo;) \u0026amp; （foldlの性質より） \\end{align} \\]\n□\n補題を証明したので $merge$ の性質を確認していきます。リスト$u$ 、 $v$ をソート済み、値 $a$ 、 $b$ を $a \\le u$ 、 $b \\le v$ を満たすとして $merge\\ u\\ []$ 、 $merge\\ []\\ v$ 、 $merge\\ (a:u)\\ (b:v)$ について考えます。\n$merge\\ u\\ []$\n\\[ \\begin{align} merge\\ u\\ [] \u0026amp; = foldl\\ ins\u0026rsquo;\\ u\\ [] \u0026amp; （mergeの定義より） \\\\\n\u0026amp; = u \u0026amp; （foldlの定義より） \\end{align} \\]\n$merge\\ []\\ v$\n\\[ \\begin{align} merge\\ []\\ v \u0026amp; = foldl\\ ins\u0026rsquo;\\ []\\ v \u0026amp; （mergeの定義より） \\\\\n\u0026amp; = sort\\ v \u0026amp; （sortは右方向より） \\\\\n\u0026amp; = v \u0026amp; （vはソート済みより） \\end{align} \\]\n$merge\\ (a:u)\\ (b:v)$\n\\[ \\begin{align} merge\\ (a:u)\\ (b:v) \u0026amp; = foldl\\ ins\u0026rsquo;\\ (a:u)\\ (b:v) \u0026amp; （mergeの定義より） \\\\\n\u0026amp; = foldl\\ ins\u0026rsquo;\\ (ins\u0026rsquo;\\ (a:u)\\ b)\\ v \u0026amp; （foldlの性質より） \\end{align} \\]\nここから $a \\le b$ と $a \\gt b$ で場合分けします。\n$a \\le b$ の場合。 仮定より $a \\le u$。$a \\le b$ と仮定より $a \\le v$。さらに $a \\le ins\u0026rsquo;\\ u\\ b$ がいえます。\n\\[ \\begin{align} foldl\\ ins\u0026rsquo;\\ (ins\u0026rsquo;\\ (a:u)\\ b) v \u0026amp; = foldl\\ ins\u0026rsquo;\\ (a : ins\u0026rsquo;\\ u\\ b)\\ v \u0026amp; （ins\u0026rsquo;のa \\le b）\\\\\n\u0026amp; = a : foldl\\ ins\u0026rsquo;\\ (ins\u0026rsquo;\\ u\\ b)\\ v \u0026amp; （補題3より） \\\\\n\u0026amp; = a : foldl\\ ins\u0026rsquo;\\ u\\ (b:v) \u0026amp; （foldlの性質より） \\\\\n\u0026amp; = a : merge\\ u\\ (b:v) \u0026amp; （mergeの定義より） \\end{align} \\]\n$a \\gt b$の場合。 仮定より $b \\le v$。 $b \\lt a$ と仮定より $b \\lt u$。\n\\[ \\begin{align} foldl\\ ins\u0026rsquo;\\ (ins\u0026rsquo;\\ (a:u)\\ b) v \u0026amp; = foldl\\ ins\u0026rsquo;\\ (b:a:u)\\ v \u0026amp; （ins\u0026rsquo;のa \\gt b）\\\\\n\u0026amp; = b : foldl\\ ins\u0026rsquo;\\ (a:u)\\ v \u0026amp; （補題3より） \\\\\n\u0026amp; = b : merge\\ (a:u)\\ v \u0026amp; （mergeの定義より） \\end{align} \\]\n総合すると、 $merge$ は引数が2つともソート済みである場合以下の性質を持つことが分かります。\n\\[ \\begin{align} merge\\ []\\ v \u0026amp; = v \\\\\nmerge\\ u\\ [] \u0026amp; = u \\\\\nmerge\\ (a:u)\\ (b:v) \u0026amp; = \\begin{cases} a : merge\\ u\\ (b:x) \u0026amp;, \\mathrm{if}\\ a \\le b \\\\\nb : merge\\ (a:u)\\ v \u0026amp;, \\mathrm{otherwise} \\end{cases} \\end{align} \\]\nこれはそのまま関数として定義できて、よくみるマージソートのマージ関数そのものですね。\nこうして挿入ソートからマージソートが導出できました。\nまとめ リストの第三準同型定理やらなんやらを使う実例として挿入ソートをマージソートに運算できることを示しました。\n","categories":["論文メモ"],"category_urls":["/categories/%e8%ab%96%e6%96%87%e3%83%a1%e3%83%a2"],"date":"2021-08-22","title":"論文メモの続き：The Third Homomorphism Theorem","url":"https://KeenS.github.io/blog/2021/08/22/ronbunmemonotsuzuki_the_third_homomorphism_theorem/"},
  {"body":"κeenです。コンパイル時に定数を処理する最適化技法あるじゃないですか。あれの名称がイマイチはっきりしないのでモヤモヤするなーという記事です。\n技法 コンパイル時に定数を処理する最適化技法は色々あるんですがそれらを包括した名称だったり個別の名称だったりがごっちゃになってるのがはっきりしない要因です。 ここでは個別の技法を7つ挙げておきます。\n技法A 定数と分かっている変数を定数におきかえるやつ\n例\nA = 100; B = A + 10; ↓\nA = 100; B = 100 + 10; 技法B 変数から変数への代入を削除し、代入先の変数への参照を代入元の変数への参照に置き換えるやつ\n例\nA = 100; B = A; C = B + 10;A = 100; C = A + 10; 技法C 条件分岐の条件が定数の場合に条件なしジャンプにするやつ\n例\nif (true) { do_something1(); } else { do_something2(); } ↓\ngoto THEN; THEN: do_something1(); goto JOIN; ELSE: do_something2(); JOIN: 技法C\u0026rsquo; 無条件に条件実行されないコードは削除するやつ\n例\ngoto THEN; THEN: do_something1(); goto JOIN; ELSE: do_something2(); JOIN:do_something1(); 技法D 定数の値の計算をコンパイラが知っている計算（=プリミティブ）ならしてしまうやつ\n例\nA = 100 + 10; ↓\nA = 110; 技法E ユーザが定義した関数を計算してしまうやつ\n例\nadd(a, b) { return a + b; } A = add(100, 10); ↓\nadd(a, b) { return a + b; } A = 110; 技法F ユーザが定義した関数に渡る引数が部分的に分かっている場合に部分的に計算した関数を用意するやつ\n例\nadd(a, b) { return a + b; } A = add(x, 10); ↓\nadd(a, b) { return a + b; } add10(a) { return a + 10; } A = add10(x); 技法G ユーザが定義した関数の定義を呼び出し箇所に展開するやつ\n例\nadd(a, b) { return a + b; } A = add(x, 10); ↓\nadd(a, b) { return a + b; } A = x + 10; 色々話題に上げるためにちょっと細かく分類したり、多めに技法を挙げたりしました。\n名前 で、何の話題かというと「定数伝播（constant propagation）」とか「定数畳み込み（constant folding）」とか言われているやつです。意外とこれらの呼び分けにゆれがあります。\n Wikipediaは定数畳み込みの見出しがあり、A, B, Dあたりの技法を定数畳み込みと呼んで、そのうちAを定数伝播と呼び分けているような記述になっている 定数畳み込み - Wikipedia  その他C, E, Fは技法も紹介しつつも別技術として扱っているよう  ドラゴンブックは「定数伝播、すなわち\u0026rdquo;定数の畳み込み\u0026rdquo;」と両者をほぼ同じものとして扱っている。  書籍中で具体的に定数の畳み込みとして言及があるのは手法A, C, Dを確認。 Bはコピー伝播という別の名前で扱っているが、定数伝播の枠組みにも入っている  タイガーブックはそれぞれ別の名前をつけているが、以下は全て1つのアルゴリズムに統合できるとしている。  A - 定数伝播、 B - 複写伝播（copy propagation）、C - 定数条件（constant condition）、C\u0026rsquo; - 不到達コード（unreachable code）、 D, E - 定数畳み込み   さらっと見た感じドラゴンブックとタイガーブックではFについては言及なさそうでした。Gはまあ、普通はインライン化と呼ばれますね。\n実際のところ 技法A〜Dまでは同時にできるアルゴリズムが存在するのでユーザの立場からは全部ひとまとめに定数畳み込みや定数伝播と呼んでいいんじゃないですかね。 私個人としては技法Aを定数伝播、A〜Dまでを総括したものを定数\u0026rdquo;式の\u0026rdquo;畳み込みと呼びたいなって思ってます。数は畳み込めないんや。\nCTFE？ 技法Eは言語によって色々変わるかなと思ってます。\nある立場（主に手続型言語）では関数の呼び出しは本来はコンパイル結果のコードの呼び出しなのでコンパイル中に呼び出すのは特別扱いしてコンパイル時関数呼び出し（compile time function execution, CTFE）と呼ぶもの。 これは実装上は実際にコードを生成して実行したりコンパイラ内にインタプリタを持っていたりします。\nもう1つの立場（主に関数型言語）では関数呼び出しはその定義への置き換えとしているので割とカジュアルにコンパイル中にやってしまうもの。 この場合技法D、E、F、Gの区別があまりなく（そもそも引数が1つしかないのでFが存在しない場合も多い）ひっくるめてβ簡約と呼ぶこともある気がします。 実装上はコンパイラが（部分的に）インタプリタを持っていることに相当します。\n特にHaskellの場合は純粋かつ遅延評価なので引数が定数か非定数かに関わらずβ簡約してしまえます。 そのことを以って全てを定数畳み込みと呼ぶこともあるようですが、式と簡約済みの値を区別したいなという気持もあり…。\n部分評価？ 技法Fのことを私は部分評価（partial evaluation）や特殊化（specialization）と呼んでたんですがそれぞれもうちょっと広い意味を持っていて特定の最適化技法を指す言葉とは限らなそうでした。 なんか良い名前ないですか。部分適用？あ、因みにこれをカリー化（currying）と呼ぶのは間違いです。\nまとめ コンパイラ難しい\n","categories":["compiler"],"category_urls":["/categories/compiler"],"date":"2021-08-22","title":"コンパイル時に定数を処理してしまうアレ","url":"https://KeenS.github.io/blog/2021/08/22/konpairutokiniteisuuwoshorishiteshimauare/"},
  {"body":"κeenです。漢字変換高精度に行うためにSKK辞書をいくつか作ったので報告です。\n辞書 GitHubに上げています。手元にダウンロードして各々好きなように使って下さい。ライセンスはCC BY-SA 3.0です。\nSKK_JISYO.wiktionary\n解決したい問題と対応する辞書 SKKに限らずほとんどの日本語での漢字変換は読みを入力してそれに該当する候補から漢字を選択していると思います。この方法は直感的で分かりやすいのですが、私は2つ問題を感じています。\n 同じ読みに対する候補が多すぎる 読みが分からない漢字を変換できない  1の候補の数については特に音読の入力に対して顕著です。例えば「しょう」で変換するとSKK_JISYO.Lにある候補は174あり、その中から目的の漢字を目grepで探す作業がはじまります。変換したい漢字は思い浮かんでいるはずなので、この目grepはインタフェースが洗練されていないが故の無駄ですよね。もっと選択性の高い入力方法があれば目grepの手間を少なくできます。\n2については人それぞれでしょうか。私は知らない漢字を見たら調べたくなるので音義共々分からない漢字を入力したい需要があります。例えば「罕」とかは読みや意味を答えられる人は少ないんじゃないでしょうか。文字データならコピペが使えるんですが画像や活字だとどうしても自分で入力しないといけません。字形はそこまで複雑ではないのでどうにかして字形をベースに入力できる方法があると嬉しいです。\n四角号碼辞書 上記の主に2、補助的に1を解決するのが四角号碼辞書です。四角号碼という漢字に振られた番号で入力できます。四角号碼は漢字字典なんかの索引にも使われています。\n四角号碼を日本語にすると「四隅コード」になるそうです。その名の通り漢字の四隅の画（と補助的に右下の画のすぐ上）の形から数字を割り当てます。例えば「罕」なら37401のコードが割り当てられます。この数字から変換できるようにしたのが四角号碼辞書です。例えば以下の入力で\n▽3740 以下のように罕が変換できます。\n▼罕 3740に該当する漢字は「罕」の他にも「写」もありますが、補助的な数字（附画）である1をつて37401で変換すれば「罕」のみ候補に出てきます。 辞書には以下のように数字4つのものと附画を加えた5つのもののエントリが入っています。\n3740 /罕/ 37401 /罕/ このように極めて高精度に入力したい漢字が入力できるのが四角号碼辞書です。\nここでみなさんが疑問に思うのは四角号碼を覚えられるのか？ということだと思います。四角号碼は字形のみから決まるのでルールさえ覚えれば個々の漢字のコードは覚えなくてよいです。そして慣れれば個々の漢字のコードはすぐに分かるようになります。具体的には30分ほど思いついた漢字の四角号碼を想像してみて、調べて合ってるかを認するゲームをやってみると慣れます。\n一応注意点としては（多分中国の）楷書の書体を元に四角号碼が割り当てられているのでフォントの字形を元に想像すると間違うことがあるということです。例えば「戸」の一画目は横棒に見えるので1（横棒）かと思いきや、3（点）として扱われて四角号碼は30207となります。戸に関しては户の方の字形からとられた可能性もありますが、こういうフォント見た目と四角号碼が一致しないケースがあることは覚えておいて下さい。\n歴史的仮名遣い辞書（experimental） 上記の主に1の問題を解決するのが歴史的仮名遣い辞書です。歴史的仮名遣いは正假名と呼ぶ人もいるようなので短いそちらを採用して以後正假名と呼びます。正假名により現代仮名遣いよりは選択性の高い変換を提供します。\n例えば「巧匠」、「考証」、「高笑」、「工商」は現代仮名遣いでは全て「こうしょう」ですが、正假名ではそれぞれ「かうしゃう」、「かうしょう」、「かうせう」、「こうしゃう」と書き分けられます。これを利用して比較的選択性の高い変換を提供するのが正假名辞書です。そのまま正假名でのエントリが入っています。\n正假名辞書はまだ実験的と位置付けています。理由は熟語に対応しておらず、上記の「かうしゃう」などは変換できません。単一の漢字のみに対応しているので「かう」と「しゃう」でそれぞれ別に変換しないといけません。将来的にはどうにかしたいですが、有力なソースがないので泥臭く既存の辞書を変換することになりそうで頭を痛めています。簡単な「こう」→「かう」の変換などで済めばまだいい（それでも大変）のですが、「桐生」は現代仮名遣いでは「きりゅう」ですが正假名では「きりふ」なので何かしら正假名と現代仮名遣いの対応ルールを作らないといけないので大変そうだな思ってます。\n辞書には正假名によるエントリの他に現代仮名遣いのエントリに歴史的仮名遣いのアノテーションを付与したエントリも入れてあります。\nせう /笑/ しょう /笑;セウ/ せふ /渉/ しょう /渉;セフ/ 正假名は1つ1つ覚えるしかなくてつらいのでアノテーションで学習の補助になればと思います。\n辞書の生成について 辞書のデータは日本語版Wiktionaryの漢字のページを元にしています。Wiktionaryに限らずWikipediaなどのWikimediaプロジェクトはダンプデータが利用可能です。少なくとも月に1度はダンプが生成されているらしいです。そのデータをダウンロードしてきて漢字のページを抜き出し、そこから四角号碼や正假名のデータをスクレイピングしています。\n四角号碼は割とフォーマットが揃っていたので楽だったのですが、正假名のデータはかなり自由に書かれていてスクレイピングに苦労しました。例えば「桜」のページはかなりやんちゃでセミコロンなんかも使われています。このページは面倒なので対応してません。編集の方針を相談できるところがあればフォーマットを統一して回るのもできそうですがよく分からないので放置しています。\nダンプが月1で生成されるので辞書の方も同じ頻度で更新したいのですが、まだ辞書の生成には数ステップ必要になっています。漢字記事を絞り込むのにMySQLを立てる必要があるなど面倒なんですよね。せめてスクリプト1発で生成できるようにしたいなぁと思ってます。\n結びに ひとまず個人用に生成していますが、上記2つの辞書でSKKユーザの漢字変換が楽になれば幸いです。正假名の熟語対応についてはノープランなので何か良い方法が思い付く方は教えて下さい。\n","categories":["SKK"],"category_urls":["/categories/skk"],"date":"2021-05-02","title":"高精度に漢字変換できるSKK辞書を作った（四角号碼、正假名）","url":"https://KeenS.github.io/blog/2021/05/02/kouseidonikanjihenkandekiruskkjishowotsukutta_shikakugouma_seikana_/"},
  {"body":"κeenです。ちょっと気紛れでCPUの拡張命令を使ってみようかなと思ったのでRustから叩いてみます。\nRustから叩くとはいってもあんまり難しいものではなくて、intrinsicsとして実装されているのでそれを呼ぶだけです。今回はBMI2拡張のPDEP/PEXTを呼んでみます。\nPDEP/PEXT BMI（Bit Manipulation Instruction Set）はその名のとおりビット操作を提供するx86の拡張命令です。IntelのHaswellから導入されてAMDのCPUもサポートしているようです。ABM、 BMI1、 BMI2と関連する拡張が色々あってややこしいので詳しくはWikipediaの記事を参考にして下さい。今回はBMI2を使います。その中のPDEP/PEXTはビットフラグ関連の操作を提供します。PEXTは「ビットマスクでマスクしてシフトでLSBに移動」、PDEPは逆で「マスクの下位の0の分だけMSB側に移動」という操作をします。\nCTZ = count trailing zerosとして、以下の等式が成り立つのかな？\nPEXT(data, mask) = (data \u0026amp; mask) \u0026gt;\u0026gt; CTZ(mask) PDEP(data, mask) = data \u0026lt;\u0026lt; CTZ(mask) 追記 Twitterで指摘がきました。\nRustでCPU拡張命令が使えるという本題には関係ないけど、PDEPとPEXTはWikipedia見た感じだとビットマスクとシフトだけの等式で表せるほど単純な命令ではないように見えた。 https://t.co/TmxDfhSmyX\n\u0026mdash; megumish (@megumish_unsafe) April 4, 2021 \nbitmapが連続していない場合はただのmaskしてshiftでは表わせない挙動をするので私の書いた式は誤りでした。詳しくは末尾の追補を参照下さい。\n/追記\nうん、便利そう。ということでPDEPとPEXTを使ってみます。\nRustから使うPDEP/PEXT まあ、普通にintrinsicsとして実装されています。具体的にはcore::arch::x86_64に_pdep_u32と_pext_u32、あとそれぞれの _u64 版が実装されています。core::arch::x86にも _u32 はありますが付け加えるまでもないですね。\nこの2つの関数を使ってみましょう。データのLSBから数えて5bit目から8bit目までを取り出したいとします。\n0b11110111_00110001 ^^^^ この4bitを取り出したい すると以下のようなコードを書くことになります。\nusestd::arch::x86_64::_pext_u64;fn main(){letdata=0b11110111_00110001;letmask=0b00000000_11110000;unsafe{println!(\u0026#34;0b{:016b}\u0026#34;,_pext_u64(data,mask));}} BMI2をサポートしているCPU上で実行すると結果は期待とおり 0b0000000000000011 になります。\n逆に PDEP だとデータをマスクにフィットするようにします。\n0b11110111_00110001 ^^^^ この4bitをマスクの位置に移動したい 先のコードの pext を pdep に書き換えてみましょう。\nusestd::arch::x86_64::_pdep_u64;fn main(){letdata=0b11110111_00110001;letmask=0b00000000_11110000;unsafe{println!(\u0026#34;0b{:016b}\u0026#34;,_pdep_u64(data,mask));}} BMI2をサポートしているCPU上で実行すると結果は期待どおり 0b0000000000010000 になります。\n因みにRustのPlaygroundを動かしているCPUはBMI2をサポートしているようなので上記コードはPlayground上で動きます。\nまとめ RustからCPUの拡張命令を使うにはIntrinsicsを使えばよいです。今回はサボりましたがCPUが特定の拡張命令をサポートしているかを確認するには cpuidクレートで実行時に判断するか #[cfg(target_feature = \u0026quot;xxx\u0026quot;)] でコンパイル時に判断することになります。PEXT/PDEPはビットフラグやビットマップを操作するときに使えて便利ですね。私の用途だったらビットマップGCを実装するときにビットマップ操作で使うかなーとぼんやり考えています。今回は純粋な命令でしたがMPKみたいに面白いことのできる命令もいつか試してみたいですね（まだRustのサポートはない）。\n追補 PEXT/PDEPの挙動の説明が間違っていたので訂正します。私の説明はmask bitが連続している場合は正しかったのですが、離れていた場合には異なる挙動をします。例えば以下のようにmask bitが離れていた場合、\n0b11110111_00110001 ^ ^ ^ ^ この4bitを取り出したい 取り出されるのはこれらを一箇所に集めた 0b00000000_00001111 です。実際、以下のコードを走らせるとそのような結果が得られます\nusestd::arch::x86_64::_pext_u64;fn main(){letdata=0b11110111_00110001;letmask=0b00010001_00010001;unsafe{println!(\u0026#34;0b{:016b}\u0026#34;,_pext_u64(data,mask));}} 逆に PDEPは 0b00000000_00001111 に対して 0b00010001_00010001 のマスクをあてがうと、 下位4bitをそれぞれマスクのビットが立っている位置までもってきて 0b00010001_00010001 を返します。これも以下のコードを書けば確認できます。\nusestd::arch::x86_64::_pdep_u64;fn main(){letdata=0b00000000_00001111;letmask=0b00010001_00010001;unsafe{println!(\u0026#34;0b{:016b}\u0026#34;,_pdep_u64(data,mask));}} 色々用途は考えられますが、GCを実装するときにも便利そうですね。例えば8byteアラインメントされた48bitポインタを64bit整数に納めると下位3bitと上位16bitが余っています。そこにメタデータを突っ込みたい場合なんかに使えそうです。\n","categories":["小ネタ","Rust","CPU","x86"],"category_urls":["/categories/%e5%b0%8f%e3%83%8d%e3%82%bf","/categories/rust","/categories/cpu","/categories/x86"],"date":"2021-04-04","title":"RustからCPU拡張命令を使ってみる","url":"https://KeenS.github.io/blog/2021/04/04/rustkaracpukakuchoumeireiwotsukattemiru/"},
  {"body":"κeenです。今年のエイプリルフールの記事の解説をします。\nプログラミングをはじめたてで最初につまづくのが用語じゃないでしょうか。知らない単語やカタカナ語が多くて用語が中々頭に入ってきません。 一度基礎的な用語を押えればある程度読めるようになるのですが、そうなるまではまるで知らない外国語で書かれているようです。\nそこで今回は知らない用語が多くて全然記事が読めなかった頃を思い出してもらおうと、普通の技術記事の単語を全部別のものに置き換えてみました。 対応関係は以下になります。\n   元の単語 置き換え ラテン文字表記 意味     高階 アヴィウム avium セイヨウミザクラ   関数 プルヌス prunus モモ属   引数 ラパ rapa アブラナ   リスト インテグラ integra モチノキ   変数 リリウム lilium ユリ属   データ フルチコサ fruticosa オーストラリアンローズマリー   コード オブツサ obtusa ヒノキ    春を感じる草花の学名に置き換えています。頭文字を使ってApril foolが構築できるように名前を選びました。It\u0026rsquo;s Greek to meということでギリシャ語から選んでも面白かったかもしれませんね。\nこのご時世で中々家の外に出る機会がありませんが窓の向こうではもう桜吹雪が舞っています。春の風物詩エイプリルフールを機に訪れる季節に思いを馳せてみてはいかがでしょうか。\n単語を置き換える前の元の記事も掲載しておきます。因みにコードはJuliaで書かれています。\n今さら聞けない高階関数入門\nハ〜イ、κeenさんだよー。今日は年度が変わって大学でプログラミングをはじめたり、新卒でプログラマになったりする人もいるでしょうということで高階関数について解説したいと思います。高階関数は慣れると便利に使えますが最初はとっつきにくいですよね。\n高階関数とは 普通の関数なら分かりますけど高階ってついたらよく分かりませんよね。でも怖がらなくて大丈夫です。高階関数も普通の関数です。ただし引数に関数をとります。関数の中でも引数に関数をとるものを高階関数と呼ぶのです。\n今の説明で「なるほど分かった」と納得した方もいるかもしれませんが「余計に訳が分からなくなった」という方の方が多いんじゃないでしょうか。順を追って説明しましょう。\n高階関数は何をしているのか さきほど高階関数は関数を引数にとる関数と説明しました。 説明だけだと分かりづらいので具体例をみながら理解していきましょう。 関数の振る舞いを調べるためにいくつか具体的な値を与えて調べたくなることがあります。 例えば1, 2, 3, 4, 5を与えてみてその値のリストをほしいことがありますね。\n# f(x) = x に対して [f(1), f(2), f(3), f(4), f(5)] これは f(x) = x に限らず f(x) = 1/x なんかでもやりたいですよね。\n# f(x) = 1/x に対して [f(1), f(2), f(3), f(4), f(5)] 他にも x^2 なんかもありえそうです。\n# f(x) = x^2 に対して [f(1), f(2), f(3), f(4), f(5)] なんとなくパターンが見えてきましたね。上3つの具体例で変わっているのは一箇所です。変化する部分を □ で表わすとこうなるでしょうか。\n# f(x) = □ に対して [f(1), f(2), f(3), f(4), f(5)] 同じようなものは関数でまとめられるのでした。でも今回は普段と違って□にあてはまるのが関数です。そう、ここで高階関数が登場するのです。高階関数でいままでのやつをまとめるとこのようになります。\ng(f) = [f(1), f(2), f(3), f(4), f(5)] 変数 f に f(x) = x や f(x) = 1/x など色々な関数が入ります。 どうでしょう？分かりましたか？具体例を見たら案外「そういうことか」となりますよね。\n高階関数をいつ使うのか 高階関数が何なのかは分かりましたが、ではいつ使うのでしょうか。だいたいは上記のような同じようなパターンがでてきたときです。 普通の関数がデータの変化をまとめるのに対して高階関数はコードの変化をまとめます。「あ、このコード似てる！」と思ったときにまとめられないか考えてみましょう。\nまとめ 高階関数とは関数を引数にとる関数のことでした。\n","categories":["入門"],"category_urls":["/categories/%e5%85%a5%e9%96%80"],"date":"2021-04-01","title":"今さら聞けないアヴィウムプルヌス入門のタネ明かし","url":"https://KeenS.github.io/blog/2021/04/01/imasarakikenaiaviumupurunusunyuumonnotaneakirakashi/"},
  {"body":"ハ〜イ、κeenさんだよー。今日は年度が変わって大学でプログラミングをはじめたり、新卒でプログラマになったりする人もいるでしょうということでアヴィウムプルヌスについて解説したいと思います。アヴィウムプルヌスは慣れると便利に使えますが最初はとっつきにくいですよね。\nアヴィウムプルヌスとは 普通のプルヌスなら分かりますけどアヴィウムってついたらよく分かりませんよね。でも怖がらなくて大丈夫です。アヴィウムプルヌスも普通のプルヌスです。ただしラパにプルヌスをとります。プルヌスの中でもラパにプルヌスをとるものをアヴィウムプルヌスと呼ぶのです。\n今の説明で「なるほど分かった」と納得した方もいるかもしれませんが「余計に訳が分からなくなった」という方の方が多いんじゃないでしょうか。順を追って説明しましょう。\nアヴィウムプルヌスは何をしているのか さきほどアヴィウムプルヌスはプルヌスをラパにとるプルヌスと説明しました。 説明だけだと分かりづらいので具体例をみながら理解していきましょう。 プルヌスの振る舞いを調べるためにいくつか具体的な値を与えて調べたくなることがあります。 例えば1, 2, 3, 4, 5を与えてみてその値のインテグラをほしいことがありますね。\n# f(x) = x に対して [f(1), f(2), f(3), f(4), f(5)] これは f(x) = x に限らず f(x) = 1/x なんかでもやりたいですよね。\n# f(x) = 1/x に対して [f(1), f(2), f(3), f(4), f(5)] 他にも x^2 なんかもありえそうです。\n# f(x) = x^2 に対して [f(1), f(2), f(3), f(4), f(5)] なんとなくパターンが見えてきましたね。上3つの具体例で変わっているのは一箇所です。変化する部分を □ で表わすとこうなるでしょうか。\n# f(x) = □ に対して [f(1), f(2), f(3), f(4), f(5)] 同じようなものはプルヌスでまとめられるのでした。でも今回は普段と違って□にあてはまるのがプルヌスです。そう、ここでアヴィウムプルヌスが登場するのです。アヴィウムプルヌスでいままでのやつをまとめるとこのようになります。\ng(f) = [f(1), f(2), f(3), f(4), f(5)] リリウム f に f(x) = x や f(x) = 1/x など色々なプルヌスが入ります。 どうでしょう？分かりましたか？具体例を見たら案外「そういうことか」となりますよね。\nアヴィウムプルヌスをいつ使うのか アヴィウムプルヌスが何なのかは分かりましたが、ではいつ使うのでしょうか。だいたいは上記のような同じようなパターンがでてきたときです。 普通のプルヌスがフルチコサの変化をまとめるのに対してアヴィウムプルヌスはオブツサの変化をまとめます。「あ、このオブツサ似てる！」と思ったときにまとめられないか考えてみましょう。\nまとめ アヴィウムプルヌスとはプルヌスをラパにとるプルヌスのことでした。\n","categories":["入門"],"category_urls":["/categories/%e5%85%a5%e9%96%80"],"date":"2021-04-01","title":"今さら聞けないアヴィウムプルヌス入門","url":"https://KeenS.github.io/blog/2021/04/01/imasarakikenaiaviumupurunusunyuumon/"},
  {"body":"κeenです。最近YubiKeyを買ったので色々試しています。今回はそのうちのLinuxログイン回です。\nYubiKeyについて YubiKeyは米瑞企業のYubico社が販売している認証デバイスです。FIDOやらWebAuthnやらの文脈で耳にした方も多いんじゃないしょうか。YubiKeyは日本ではソフト技研社が販売代理店をしています。\nYubiKeyはラインナップがいくつかありますが私が買ったのはYubiKey 5 NFCです。\nYubiKeyでできることは色々あります。\n FIDO U2F FIDO2 / WebAuthn Challenge and Response OATH-TOTP / OATH-HOTP Yubico OTP PIV OpenPGP 静的パスワード  参考：Yubikey 5をArchLinuxで使う - Qiita\nこのうち今回はFIDO U2F、Challenge and Responseの機能を使います。\n今回やること 以下のことをやろうと思ってます。\n YubiKeyでLinuxにログイン sudoの認証もYubiKeyで YubiKeyを引っこ抜くと画面ロック  ロックとロック解除をYubiKeyで行えるのでまさしく「鍵」っぽいですね。これはお遊びというか、実用性はあと一歩といったところなので「へー、面白い」と思いながら眺めて下さい。\nPAMを使ったYubiKey認証 Linux Pluggable Authentication Modules (PAM) はその名の通りLinuxのログインやsudoなどの認証を担当するフレームワークです。PAMで認証方法を色々カスタマイズできるので、YubiKeyで認証できるようにしていこうという趣旨です。先立って参考リンクをいくつか挙げておきます。\n PAM - ArchWiki PAM設定ファイルの意味と書き方メモ - Qiita Ubuntu Linux Login Guide - U2F – Yubico Ubuntu Linux 20+ Login Guide - Challenge Response – Yubico  Challenge Response / FIDO U2F PAMでYubiKey認証ができるようにするには2つの手段があるようです。Challenge ResponseかFIDO U2Fかです。Challenge Responseの方を試してないので推測ですが、Challenge Responseはユーザの操作不要、FIDO U2FはYubiKeyに触れるプロセスが必要っぽいです。\nそれぞれでインストールするモジュールが異なります。私は今回FIDO U2Fを選択します。Challenge Responseを設定する場合は公式ドキュメントを読んで下さい。FIDO U2Fなら libpam-u2f をインストールします。\n$ sudo apt install libpam-u2f あとなんか初期設定を吐く必要があるっぽいです。\n$ mkdir -p ~/.config/Yubico $ pamu2fcfg \u0026gt; ~/.config/Yubico/u2f_keys PAMの設定 以後FIDO U2Fを設定するものとします。\n今回私はパスワードなしでYubiKeyを挿してYに触れたらログインできるように設定します。U2Fはその名の通り2要素認証のためのものなので、変則的な使い方であることを了承下さい。\nさて、まずは /etc/pam.d/ に u2f-sufficient というファイルを作って以下の内容を書きます。\nauth sufficient pam_u2f.so debug_file=/var/log/pam_u2f.log sufficient を設定しているとその認証が成功したらそれだけでログイン成功します。2段階認証にしたければ required を設定します。\nログファイルを作っておきます。\n$ sudo touch /var/log/pam_u2f.log それでは各種認証方法にYubiKeyを追加しましょう。\nまずは安全な sudo から。ログインの設定を最初にやってしまうと失敗したときにログインできなくなりますからね。 /etc/pam.d/sudo を編集して @include common-auth の行の上に @include u2f-sufficient を追加します。\n$ sudo vi /etc/pam.d/sudo $ tail -n 5 /etc/pam.d/sudo session required pam_env.so readenv=1 envfile=/etc/default/locale user_readenv=0 @include u2f-sufficient @include common-auth @include common-account @include common-session-noninteractive 今作業したターミナルは閉じないで下さい。大事な sudo セッションが残ってるので失敗したときのリカバリに使います。別ターミナルを開いてYubiKeyが挿さった状態で sudo echo test とかを打ちます。YubiKeyがピコピコ光って、触ると sudo が通って test がechoされるのを確認します。さらに別ターミナルを開いて、今度はYubiKeyを抜いて sudo echo test と打ち、パスワード入力が促されるのを確認します。\n以上2つの確認が通れば sudo の設定は大丈夫そうです。ログインの設定に進みましょう。\nログインの設定は使っているディストリビューションやフレーバーによって異りそうですが、私は素のUbuntuを使っているのでGDMのパスワードのところを上書きすればよいようです。 /etc/pam.d/gdm-password を開いて @include common-auth の行の上に @include u2f-sufficient を追加します。\n$ sudo vi /etc/pam.d/gdm-password $ head -n6 /etc/pam.d/gdm-password #%PAM-1.0 auth requisite pam_nologin.so auth required pam_succeed_if.so user != root quiet_success @include u2f-sufficient @include common-auth auth optional pam_gnome_keyring.so 一旦ロックしてみてYubiKeyを挿した状態でパスワード入力画面に入ったらYubiKeyがピコピコ光って触るとロック解除できるようになっていればよし。次はYubiKeyを抜いてロックしてみて、パスワードでそのままログインできればよし。\n以上2つの確認が通ればPAMの設定は終了です。\nudevを使った自動ロック udevはLinuxのデバイス管理ツールで、デバイスを抜き差ししたときにフックしてコマンドを実行できます。普通はマウントとかに使っているようですが今回はそれを画面のロックに使います。こちらも先立って参考リンクを挙げておきます。\n udev - ArchWiki Passwordless logins with Yubikey Linux: Login/sudo with Yubikey  作業は2ステップです。\n YubiKeyのデバイスID（とか）を調べる 調べたデバイスIDにフックしてロックコマンドを走らせる設定をする  まずはデバイスIDを調べます。以下のコマンドでデバイスの動向をモニタします。\n$ udevadm monitor --environment --udev その間にYubiKeyを抜くと色々情報が出てきます。その中からYubiKeyの情報をさがし、ID_VENDOR_ID と ID_MODEL_ID の値を調べます。YubiKeyの情報はだいたい一番上にあるようです。\nそれでは調べたIDにフックして画面のロックが走るようにします。因みに私のデバイスでは ID_VENDOR_ID が 1050、 ID_MODEL_ID が0407だったので以下ではそれを使います。画面のロックをする方法はいくつかあるようですが、GNOMEのセッション外にあるudevからキックしてもちゃんとロックしてくれるのは loginctl lock-sessions でした。それをふまえて /etc/udev/rules.d/40-u2fkey.rules に以下の設定を書きます。\nACTION==\u0026#34;remove\u0026#34;, ENV{ID_VENDOR_ID}==\u0026#34;1050\u0026#34;, ENV{ID_MODEL_ID}==\u0026#34;0407\u0026#34;, RUN+=\u0026#34;/usr/bin/loginctl lock-sessions\u0026#34; これを書いたらudevに今書いたルールを反映させます。\nsudo udevadm control --reload-rules これでYubiKeyを抜いて画面がロックされれば成功です。失敗したらそもそも /usr/bin/loginctl lock-sessions でログインできるかやデバイスのIDがあってるかを確認して下さい。ログは適当に /var/log/syslog を grep udev するとかして取得して下さい。\n既知の問題 紹介しといてなんですが、この方法は色々と問題が残ってます。\nセキュリティは向上しない パスワードに加えて認証可能な方法を提供するのでセキュリティ的にはマイナスです。例えばYubiKeyを失くした場合にそのPCへログインされてsudoまで使われる可能性があります。\n私は自分しか物理アクセスできないマシンでやってるのでそこまで問題にはならないんですがオフィスやコワーキングスペースなどでやろうと思ってる方は注意して下さい。\n2段階認証のバックアップ…？ 私がやった設定とは違って u2f を required にして本当に2段階認証にした場合の話です。YubiKeyを失くした場合に認証の代替手段がないので詰みます。やるとしたらシングルユーザモードでログインしてPAMの設定を外すくらいですがちょっと大変そうですね。\nログインの判定がシビア YubiKeyログインは、ログイン画面にいった瞬間にYubiKeyが挿さっていないとYubiKey認証は失敗したと見做すらしく、そのままパスワード認証に進んでしまいます。なので先にYubiKeyを挿してログイン画面に進むか、パスワード画面まで進んでしまったらYubiKeyを挿してパスワードを間違えれば認証が先頭から再開されるのでYubiKey認証をするチャンスが訪れます。\nYubicoソフトウェアとの相性 Yubico AuthenticatorやYubikey Personalization Toolを起動するときに内部的に1回YubiKeyを挿し直しているようで、udevが反応して画面がロックされます。特にYubikey Personalization Toolはロックを解除した瞬間にも挿し直しているようで無限ロックに陥ります。\n仕方ないので現状Yubico製ソフトウェアを起動するときは一旦udevの設定をコメントアウトしてルールをリロードしてから起動しています。そこまで頻度は多くないのでこれくらいなら我慢の範疇かなというところです。\nまとめ YubiKeyの抜き差しで画面のロック/アンロックができる仕組みを構築しました。細かな点で問題は残るものの仕組みとしては面白いんじゃないでしょうか。今回の作業は以下のスクラップの末尾の方にログが残ってるので参考にして下さい。\nyubikeyを買ったので色々セットアップのメモ\n","categories":["YubiKey","Linux","PAM"],"category_urls":["/categories/yubikey","/categories/linux","/categories/pam"],"date":"2021-03-28","title":"YubiKeyをLinuxの「鍵」にする","url":"https://KeenS.github.io/blog/2021/03/28/yubikeywolinuxno_kagi_nisuru/"},
  {"body":"κeenです。最近YubiKeyを買ったので色々試しています。今回はそのうちのWeb認証回です。\nYubiKeyについて YubiKeyは米瑞企業のYubico社が販売している認証デバイスです。FIDOやらWebAuthnやらの文脈で耳にした方も多いんじゃないしょうか。YubiKeyは日本ではソフト技研社が販売代理店をしています。\nYubiKeyはラインナップがいくつかありますが私が買ったのはYubiKey 5 NFCです。\nYubiKeyでできることは色々あります。\n FIDO U2F FIDO2 / WebAuthn Challenge and Response OATH-TOTP / OATH-HOTP Yubico OTP PIV OpenPGP 静的パスワード  参考：Yubikey 5をArchLinuxで使う - Qiita\nこのうち今回はFIDO U2F、FIDO/WebAuthn、OATH-TOTP / OATH-HOTPの機能を使います。\nYubiKeyとWeb認証 YubiKey（のうち私の持ってるYubiKey 5）がWebでの認証に持てる役割は3つあります。\n WebAuthn：いわゆるパスワードレスログイン FIDO U2F：いわゆるセキュリティキーとしての機能 OATH-TOTP / OATH-HOTP：いわゆるワンタイムパスワードのキーストア  1番目のWebAuthnについては知ってる方も知らない方もマチマチといったところでしょうか。SSHの公開鍵暗号認証のように公開鍵でWebサービスにログインする仕組みです。YubiKeyはその秘密鍵を保持する役割を持ちます。今回は私はお世話になりませんでした。FIDO2 / WebAuthnについて詳しくはYahooのテックブログなどを参照下さい。\nYahoo! JAPANでの生体認証の取り組み（FIDO2サーバーの仕組みについて） - Yahoo! JAPAN Tech Blog\n2番目のFIDO U2Fは2段階認証のための仕組みです。Webサービスにパスワードで認証を進めたあと、YubiKeyなどのセキュリティキーをNFCにかざしたりUSBに挿したりして2段目の認証をします。パスワードの知識による認証に加えてセキュリティキーの所有による認証を提供することで2要素の認証が実現できます。\n3番目のOATH-TOTP / OATH-HOTPはいわゆるワンタイムパスワードに使います。これは対応していないYubiKeyもあるので購入の際は気をつけて下さい。よくスマホでなんちゃらAuthenticatorとかで2次元バーコードを読んで設定しているやつですね。あれはスマホ内にサーバとの共通鍵を保存してます（多分）。その共通鍵を（Yubico Authenticatorを使えば）YubiKeyに保存できるという機能です。Yubico AuthenticatorはデスクトップPC向けにも提供されているのでスマホに依存せず2段階認証が可能になります。スマホを買い替えたり故障したりしても安心ですね。\nよく「YubiKeyが使えるサービスが少ない」と言われるのは大抵2番目のセキュリティキーとしての機能についてです。3番目のワンタイムパスワードは多くのサービスが対応しているのでそこまで含めるとYubiKeyが活躍する範囲はかなり広いです。\nという訳でYubiKeyのセキュリティキーとワンタイムパスワードの共通鍵ストアとしての機能を使って色々なサービスの安全性を確保しようというのがこの記事の趣旨の1つです。\nWebサービスのトラストチェーン トラストチェーンという言葉が適切かどうかは分かりませんが適当な用語を思い当たらなかったのでひとまずそう呼びます。それぞれのサービスがどうやって「私であるか」を保証しているかについてです。それに関連して私個人が以前やっていた管理の問題点を挙げつつ説明します。\n私はいくつかのサービスのログインにTwitterログインを使っています。この場合、これらのサービスは「このTwitterアカウントを持っている者はκeenである」と定めている訳です。Twitterに本人性の保証を委任してるとも言えます。\nではTwitterは私のことをどう認証しているかというとGMailのアドレスとパスワードです。しかしパスワードは補助的なもので、emailによるパスワードリセットがあるので実質的にはemailアドレスで認証しています。つまりTwitterは「このemailアドレスを持っている者はκeenである」と定めている訳です。\nではGMailは私のことをどう認証しているかというとemailアドレス（ID）とパスワードです。このパスワードは覚えている訳ではなくてパスワードマネージャに預けています。具体的にはDropboxに保存したKeePassのDBが担当します。つまり（KeePassのDBにパスワードがあるのである程度間接的にですが）Googleアカウントの安全性はDropboxが担保しています。\nじゃあDropboxアカウントの安全性はというとGMailでアカウントを作っているのでパスワードリセットのことを考えるとGMailが本人性を担保しています（因みにDropboxのパスワードは脳味噌で覚えています）。さらに、Androidを使ってるとGoogleのパスワードマネージャがDropboxを含むいくつかのアカウントのパスワードを記憶してしまっています\nさらに加えて、Firefox Syncのアカウントに記憶させているので実質的にはFirefox Syncのアカウントが破られるとDropboxやGoogle、その他Webサービスのアカウントが掌握されます。因みにFirefox SyncのアカウントははGMailで作ってパスワードはDropbox（に保存したKeePassのDB）管理です。\nここでグラフに閉路が出てきてしまいましたね。GoogleアカウントかDropboxアカウントかFirefox Syncアカウントのどれかが乗っ取られると私のWebアカウント全体が掌握されてしまいます。死守しないといけないものは少ない方がいいのでどうにかの依存を減らせないでしょうか。さらにおまけを加えると、私のGoogleアカウントにはいつ取得したかも覚えてないフリーメール（死語）のアドレスをバックアップ用のアカウントに設定していました。つまり、そのアカウントが乗っ取られるとGoogleアカウントのパスワードリセットでGoogleアカウントも乗っ取られてしまいます。\n因みにそのフリーメールアカウントにはスパムメールが1日20件くらい届いてます。一番大事にしないといけないアンカーの部分を一番信用ならないものに預けてしまっていますね。このグダグダなWebアカウントの管理を整理してもうちょっと信頼の置けるものにしようというのが今回の趣旨の2つ目です。具体的にはパスワードマネージャをアンカーにして以下のように整理したいです。\nそのためにまず適切なパスワードマネージャを選ぶところからです。\nパスワードマネージャの選定（BitWarden） パスワードマネージャの選定には多少個人の好みも乗るので先に結論を書くとBitWardenを選びました。以下に選定理由を書きます。\n私がパスワードマネージャに求めた要件は以下です。\n トラストアンカーとして使えること  ≒ ログインに使ったemailアドレスが掌握されてもアカウントが乗っ取られないこと  Linuxのデスクトップクライアントがあること Androidクライアントがあること オフラインでも動くこと （可能なら）Firefox向けのアドオンがあること アカウントが不意に凍結されないこと  KeePassはDBの共有に別途オンラインアカウントを必要とする点と、スマホから更新したときにDropboxの同期が微妙な点で使うのを止めることにしました。Firefox Syncはでデスクトップクライアントがありません。Googleアカウントはアカウントが不意に凍結されるのでパスワードを預けられません。その他のLastPassなどのパスワードマネージャを検討して、確か1PasswordとBitWardenが候補に残りました。正直どちらでもよかったのですが、BitWardenはオープンソースだったので気休め程度ですが最後の1推しということでBitWardenを採用しました。\nBitWardenが要件を満たしているか確認します。\n トラストアンカーとして使えること：メールアドレスでできるのはアカウントのリセット（データ削除）のみで乗っ取りはできない Linux、Androidのクライアント：ある オフラインでも動くか：動く（多分） Firefox向けのアドオン：ある。Firefox for Androidのアドオンもある アカウントが不意に凍結されない：不明（凍結された情報はない）  アカウントが凍結されてもパスワードのDBは手元に残るので最悪凍結されても大丈夫   良さそうですね。最後の1推しになったオープンソースについて補足しておきます。実際に使っているサービスが企業が説明する仕組み通りに動いているかやバックドアがないかは普通は確かめる術がなく、企業を信頼するしかありません。企業に悪意がなくてもとあるWebサービスで事実誤認でE2Eで暗号化をしてないのにE2E暗号化していると宣伝するケースだってありました。そこに来てオープンソースなら自分の目でコードを読んで安全性を確認できます。さらに、ソースコードがあれば企業側からサポート終了されてもコミュニティで開発を継続できるという利点もあります（特にLinuxはサポート切られがち）。BitWardenはサーバのソースコードも公開していて最悪自分でサーバを立てて運用もできるのでBitWarden社が倒産しても安心ですね。…とは書いたものの実際はコードを読んで自分でビルドしたものを使っているどころか公開されているコードは一読もせずパッケージを使っていますしコードを手元に確保することすらしていません。なので気休め程度ですね。殊勝などこかの誰かが確認してくれていることを信じて使っていきましょう。\nアカウントの大整理 まずはBitWardenのアカウントを作ってKeePass、Firefox Sync、Googleパスワードマネージャに散らばった各種アカウントをBitWardenにまとめます。そのときの作業ログは以下のスクラップにあるので興味のある方は読んでみて下さい。\nbitwardenのセットアップ\nここで問題になるのがGoogleアカウントのバックアップ用に設定していたフリーメール（死語）についてです。代替を用意してフリーメールは解約するとして、代替をどうしましょう。\nSMSによるバックアップもありますが、これは基本的には設定しない方がマシです。SMSは権限のあるAndroidアプリなら誰でも読めてしまうのでSMSバックアップを設定していると悪意のあるアプリから簡単にアカウントが乗っ取られます。\nGood morning to everyone except those who think SMS is a secure type of 2FA.\n\u0026mdash; Yubico | #YubiKey (@Yubico) March 4, 2021 \n考えられる手段はインターネットを契約したときについてくるプロバイダのメールアドレスを設定するか、いっそバックアップを設定しないかかなと思います。プロバイダのメールアドレスは使ったことがなくてイマイチ信用していいのか分からないのでバックアップを設定しない選択をとりました。この辺ベストプラクティスがよく分からないので知っている方いましたら教えて下さい。\nあとはそもそも諸々の認証に使うメールアドレスをGMailにしていいのかという問題もあります。Googleは事前告知や説明なくアカウントを凍結することで有名ですし、色々なサービスに紐付いていてどこかでGoogle様の癇に障ったら全てのアクセスを停止されてしまうのでかなりリスクが高いですね。Webアカウント作成用にはProtonMailとかの安心して使えるメールアドレスやSimpleLoginとかの元のメールアドレスに依存しないプロキシ使った方がいいのかなという気がしています。とはいえ寄らば大樹の陰って言葉もありますし難しいですね。ひとまず惰性でGMailをそのまま使っていきます。\nYubiKeyによる安全性の強化 ようやくYubiKeyが活躍します。先述のとおりYubiKey 5はセキュリティキーとしての機能とワンタイムパスワードの共通鍵ストアとしての機能があるのでした。それらを使っていきます。セキュリティキーが使えるならセキュリティキーを、使えないならワンタイムパスワードを使うのが推奨されるようです。\n基本的にはつらつら設定していくだけなのですが、いくつかポイントを解説しておきます。\nセキュリティキー（FIDO U2F） いくつかのサービスはセキュリティをサポートしています。大抵の場合はワンタイムパスワードを設定したあとに追加でセキュリティキーを設定するようです。セキュリティキーは設定するときも使うときもセキュリティキーを操作しろとの案内が出るのでYubiKeyの「Y」マークのところに触れると操作ができます。\n因みにFirefox on Linuxだとセキュリティキーに対応してますがFirefox for Android (87.0.0)だと対応していませんでした 追記 92.0で対応しました /追記。なのでどのみちU2Fとワンタイムパスワードはセットで設定しないといけないようです。Android版Chromeは対応しているとの噂ですのでChromeユーザは（設定できるなら）ワンタイムパスワードなしでも生きていけるのかもしれません。\nトラストチェーンでいくつかハブになっているものがありました。パスワードマネージャや第3者認証（認可）でログインによく使っているTwitterやGitHub、Googleなどでです。幸いにもBitWarden、Twitter、GitHub、Googleは全てFIDO U2Fに対応していました。これで安心してアカウントが使えますね。\nデスクトップクライアントの使い方 デスクトップクライアントをインストールしておきます。\nsudo apt install yubioauth-desktop あんまり記憶にないのですが、 pcscd も必要という記述がWebには転がっていました。必要に応じてインストールして下さい。\nセットアップは、YubiKeyをUSBに挿した状態でデスクトップ画面にQRコードを表示して右上の＋を押すと勝手に認識して登録してくれるようです。\nデスクトップクライアントを使えばPCでワンタイムパスワードを表示できるのでコピペでワンタイムパスワードが入力できてとても便利です。\nモバイルアプリの使い方 PlayストアからYubico Authenticatorをインストールして使います。鍵はYubiKeyにあるのでUSBで挿すかNFCでかざすとワンタイムパスワードが表示されます。新しくワンタイムパスワードを設定するときも同様に挿すかかざすかします。\n私はデスクトップPCで信頼して使えるのがUSB Type-Aで、スマホはUSB Type-CだったのでType A + NFCのモデルを買いましたが、PCの方もUSB Type-Cが使えるならUSB Type-Cのみのモデルを買ってもいいかもしれませんね。因みに値段は謎にType A + NFCのモデルが一番安いです。多分ですが口金不要で基盤1枚でできてて作りがシンプルだからですかね？\nリカバリーコードの保存 2段階認証の全てをYubiKeyに預けてしまうのでYubiKeyをうっかり失くしたときに大惨事になりそうです。ですが2段階認証を設定するときはリカバリーコードが発行されるはずなのでそれさえキッチリ管理しておけば問題ありません。リカバリーコードで2段階認証を一時的に外せるのでその間に使って買い直したYubiKeyをセットアップするまでです。\nリカバリーコードの適切な管理については、私はGPGで暗号化してUSBメモリに保存し、家の中で安全に管理しています。念のため作業は全てtmpfsの上で行っています。詳細はOpenPGPの記事を参照して下さい。\nYubikeyでOpenPGP鍵をセキュアに使う | κeenのHappy Hacκing Blog\nバックアップ用に2つ目のYubiKeyをセットアップする人もいるようですが、個人的にはセットアップが煩雑になる点、YubiKeyを失くしたらどのみち再設定をしないと安全性が脅かされるのであまり意味がない点、管理しないといけないものが増える点、サービスによっては2つ目のキーを許していない点（認証可能なもの複数があると安全性が下がりますからね）、などから好きじゃないです。\nBitWardenのセットアップ ちょっとだけBitWardenのセットアップに触れておきます。アカウントは無料でも作れますが、私が今回欲しいFIDO U2Fによる2段階認証は有料プランでないと使えないので納金しました。有料とはいっても年間$10という破格なのでほとんどタダみたいなものです。クライアントによってFIDO U2Fが使えたり使えなかったり色々あるのでワンタイムパスワードの設定も忘れないで下さいね。\nBitWardenのアカウントを作るときにマスターパスワードを設定することになりますが、これが実質的なトラストアンカーになるので慎重に設定します。 words がだいたい10万語くらいあるので8つ単語を並べると128bit以上の情報量があることになります。\n$ cat /usr/share/dict/words | wc -l 102774 $ ruby -e \u0026#39;p Math.log2(102274 ** 8)\u0026#39; 133.13663924444612 wordsからランダムに8語選んで一部は記号や数字に置き換えたり挟んだりすればまあ安全なんじゃないでしょうか。\n$ cat /usr/share/dict/words | shuf | head -n 8 derringer educators vacationer\u0026#39;s toting pilgrims reassert spy\u0026#39;s demoing あとはこれを打ち損じないように cat \u0026gt; /dev/null に何度もタイプ練習して目を瞑っていても打てるようになったら（だいたいパスワード入力は伏せ字になるので）、マスターパスワードに設定しましょう。\n因みにYubiKeyには固定パスワードを1つだけ記録させる機能があるのでマスターパスワードを記録させると丁度よさそうです。ひとによっては一部覚えて残りをYubiKeyに焼いてる人もいるとか。ですが私はマスターパスワードは所有による認証ではなく知識による認証になっててほしいので脳味噌で覚えてます。\nまとめ YubiKey購入をきっかけに私が行なったWebのログイン周りの整理を紹介しました。トラストアンカーをBitWardenにしてYubiKeyで2段階認証をすることでごちゃごちゃした関係がすっきりしました。BitWardenもYubiKeyもLinuxのクライアントがあるのでLinuxユーザでも便利に使えます。また、YubiKeyを2段階認証に設定することでスマホに依存しなくなるのでスマホの買い替えが楽になりました。\n","categories":["yubikey","bitwarden"],"category_urls":["/categories/yubikey","/categories/bitwarden"],"date":"2021-03-28","title":"YubiKeyとBitWardenで安心Web生活","url":"https://KeenS.github.io/blog/2021/03/28/yubikeytobitwardendeanshinwebseikatsu/"},
  {"body":"κeenです。最近Yubikeyを買ったので色々試しています。今回はそのうちのPGP回です。\nYubikeyについて Yubikeyは米瑞企業のYubico社が販売している認証デバイスです。FIDOやらWebAuthnやらの文脈で耳にした方も多いんじゃないしょうか。Yubikeyは日本ではソフト技研社が販売代理店をしています。\nYubikeyはラインナップがいくつかありますが私が買ったのはYubikey 5 NFCです。\nYubikeyでできることは色々あります。\n FIDO U2F FIDO/WebAuthn Challenge and Response OATH-TOTP / OATH-HOTP Yubico OTP PIV OpenPGP 静的パスワード  参考：Yubikey 5をArchLinuxで使う - Qiita\nこのうち今回はOpenPGPサポートの機能を使います。\nOpenPGPについて OpenPGPはデータの完全性を提供するためのプロトコルです。RFC4880で標準化されています。主な用途は電子署名や暗号化などでしょうか。その他頑張ればSSHの認証にも使えるようです。私は以下の用途に使っています。\n Gitのコミットの署名 メールの署名  CF 「Thunderbird」がメール暗号化・デジタル署名「OpenPGP」を標準サポートへ - 窓の杜  keybaseでの紐付け  Gitのコミットの署名について補足しておきましょう。Gitに設定するユーザ名やメールアドレスは自己申告なので簡単に詐称可能です。さらにGitLabやGitHubはそのメールアドレスでコミットをアカウントに紐付けるので偽装コミットが簡単に作れます。署名をしておけばそういう偽装を防げます。GitLabやGitHubもOpenPGPの公開鍵を登録しておけばコミットが本人により署名されたものかを確認してくれる機能がついています。\nOpenPGPの用途は他にも私が公開している鍵を使って他の人が私に暗号化したファイルを送ったり（現実的には暗号化メールかな）できるのですが、まだ暗号化ファイルを受け取った経験はありません。\nOpenPGPを使うときのツールはLinuxならGnu Privacy Guard（GPG）を使うことになるでしょう。この記事でもGPGを前提として紹介していきます。\nYubikeyとOpenPGPについて OpenPGPでは公開鍵暗号を使うので公開鍵と秘密鍵があります。公開鍵はインターネットに公開し、秘密鍵を自分しか知らないように大切に保管します。SSHと雰囲気が似てますね。ですがOpenPGPの鍵は所有者本人に結びつくのでSSHの秘密鍵以上に扱いに注意が必要です。OpenPGPの鍵はそれが本人と結び付いていることを周りに信用してもらってはじめて意味を持ちます。そのためには利用実績の積み重ねと本人による適切な秘密鍵の管理が不可欠です。そして秘密鍵は電脳空間で本人そのものになるので秘密鍵が流出すると自身の人格が乗っ取られることに等しいです。そういった点で流出したら接続先マシンから公開鍵を削除して鍵ペアを作り直せばいいSSH鍵とは扱いが異なります。\nなのでOpenPGPの秘密鍵を安全に保管したいというモチベーションがあり、そのための機能を実際に提供するのがYubikeyのOpenPGPサポートです。Yubikeyのデバイス内にOpenPGPの鍵を焼き込み、二度と外に出さない運用が可能です。ということでYubikeyにOpenPGPの鍵を焼き込みましょう。\nOpenPGPの機能と鍵 鍵を焼く前にOpenPGPにどんな鍵があり、どう使うのか押えましょう。OpenPGPを使うときにはいくつかの種類の公開暗号鍵対を使い分けます。\n鍵の機能 OpenPGPでは鍵に機能を割り当てることができます。仕様上は細かくいくつか分かれているようですが、現実には以下の三つが使われます。\n 認証 署名 暗号化  鍵の失効と有効期限 もし万が一秘密鍵が流出したときのために鍵を失効することができます。そのときは秘密鍵で失効証明書というのを発行し、それを配ることで周りの人に以前公開した公開鍵を失効させることを宣言できます。\nまた、鍵には有効期限が設定できます。もし万が一秘密鍵を紛失した場合には失効証明書が発行できないので既に発行した公開鍵をどうすることもできなくなります。そういうときに有効期限があれば勝手に失効してくれるので知らずに意味のない鍵を使われる可能性が減ります。有効期限はあとから延長することもできるので、1年くらいに設定して毎年延長する運用するスタイルもあるようです。\n主鍵と副鍵 私も最初混乱したのですが、OpenPGPには主鍵と副鍵があるようです。副鍵は主鍵からいくらでも作ることができます。副鍵は主鍵に紐付いていて、主鍵とは独立して鍵の有効期限を設定したり失効したりできます。主鍵も副鍵も公開暗号鍵対です。なので厳密には主鍵\u0026rdquo;対\u0026rdquo;、副鍵\u0026rdquo;対\u0026rdquo;ですし、主鍵の公開鍵、主鍵の秘密鍵、副鍵1の公開鍵、副鍵1の秘密鍵、副鍵2の…と色々な鍵が登場します。\n鍵の実際の運用 よくある運用としては主鍵に認証と署名の機能を持たせて有効期限を無期限にし、副鍵に暗号化の機能を持たせて有効期限を設定することが多いようです。 認証と署名は本人に紐付くため一生に一つあれば十分なので有効期限は無期限で問題ありません。\n主鍵の失効証明書を事前に発行して保管しておきます。 もし鍵が流出したときは気付いた時点で失効証明書をみんなに配れば被害は最小限で済みます。 秘密鍵が流出しても、流出前に行った署名が無効になったり偽造されるようになったりましませんからね。\n一方、暗号化は前方秘匿性の観点から流出した時点で被害が最大になります。 すなわち、秘密鍵を手にした人は過去に自分向けに暗号化されたデータ全てを復号できるようになってしまいます。 そこで鍵の有効期限は1年程度にして毎年鍵を交換することで被害を小さくできます。 副鍵は主鍵に紐付いていて、鍵の信用は主鍵が担保してくれるので副鍵はある程度頻繁に替えても問題ないという寸法です。\n色々書きましたが以下の2つ（4つ）の鍵があること押えて下さい\n 署名と認証に使う主鍵（の秘密鍵と公開鍵） 暗号化に使う副鍵（の秘密鍵と公開鍵）  運用と保管 鍵は盗まれてはならないし失くしてもならないけど普段気軽に使えるようにしないといけません。 この辺の匙加減は個々人に任されるころではあります。 例えばローカルマシン内は安全としてそのまま保存してしまう場合もあります（そのままとはいってもパスワードで保護されていますが）。 あるいはインターネットに繋ったマシンは全て危険として主鍵の秘密鍵を紙、あるいはUSBメモリなどに書いて家の中で大切に保管し、ローカルマシンには副鍵のみ置く場合もあります。そういう場合は一度もインターネットに繋がったことのないマシン（Live CDとか）の上でOpenPGP鍵を生成するようです。\n今回の我々にはYubikeyがあるので考えることが少なくて済みます。 インターネットに繋っているマシンは安全でないとして、普段使いにはYubikeyに保存した主鍵と副鍵（の秘密鍵）を、バックアップとしてUSBメモリに主鍵と副鍵の秘密鍵のコピーを保存します。 これでインターネットから秘密鍵がアクセスされることはなく安全に使えるようになります。 まあ、作業は普段使ってるインターネットにバリバリで繋がってるマシンでやるので徹底はしてませんけどね。気になる方は上手いことやって下さい。 秘密鍵を保存したUSBメモリはインターネットでの自身の人格に相当するので門外不出に安全に管理し、火事で焼け出されるときも通帳や印鑑よりも優先して持ち出します。\n鍵の生成からYubikeyへの焼き込みまで ちょっと前置きが長かったのでやることをおさらいしておきましょう。\n (事前準備) 署名・認証の主鍵と暗号化の副鍵を生成する  このとき副鍵の有効期限を1年にする  主鍵、副鍵のバックアップをUSBメモリに置く 主鍵、副鍵をYubikeyに焼き込む  これらの作業をやっていきます。Yubicoの公式ドキュメントも併読しながら進んで下さい。\nUsing Your YubiKey with OpenPGP – Yubico\n事前準備 YubikeyをOpenPGP鍵のストアとして使うためにscdaemonをインストールしておきます。\n$ sudo apt install scdaemon どうやらOpenPGP鍵を安全に保管できるデバイスはスマートカードと呼称されるらしいです。\n鍵の生成 OpenPGP鍵は gpg コマンドで作成できます。このとき生成する鍵のアルゴリズムはYubikeyに保存できるものを選ばないといけません。Yubikey 5ならRSA 4096 をサポートしている他、楕円曲線暗号も使えます。\nSee also: YubiKey 5.2.3 Enhancements to OpenPGP 3.4 Support – Yubico\nここではセキュリティビット数が256bit相当（RSA 4096より多い）ある nistp521 を使うことにします。以下のようにダイアログを進めていきます。\n gpg --expert --full-gen-key で鍵の生成を開始 9 で鍵の種類に楕円曲線暗号（ECC）を選択 5 で楕円曲線にNIST P-521を選択 0 で有効期限に無期限を選択 y で了承 本名、メールアドレス、コメントなどを入力 O で了承 マウスやキーボードを動作させてエントロピーを生成 鍵のパスワードを設定  鍵のパスワードは長いものを設定しておきましょう。コンソールではこうなります。\n$ gpg --expert --full-gen-key gpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. ご希望の鍵の種類を選択してください: (1) RSA と RSA (デフォルト) (2) DSA と Elgamal (3) DSA (署名のみ) (4) RSA (署名のみ) (7) DSA (機能をあなた自身で設定) (8) RSA (機能をあなた自身で設定) (9) ECC と ECC (10) ECC (署名のみ) (11) ECC (機能をあなた自身で設定) (13) 既存の鍵 (14) カードに存在する鍵 あなたの選択は? 9 ご希望の楕円曲線を選択してください: (1) Curve 25519 (3) NIST P-256 (4) NIST P-384 (5) NIST P-521 (6) Brainpool P-256 (7) Brainpool P-384 (8) Brainpool P-512 (9) secp256k1 あなたの選択は? 5 鍵の有効期限を指定してください。 0 = 鍵は無期限 \u0026lt;n\u0026gt; = 鍵は n 日間で期限切れ \u0026lt;n\u0026gt;w = 鍵は n 週間で期限切れ \u0026lt;n\u0026gt;m = 鍵は n か月間で期限切れ \u0026lt;n\u0026gt;y = 鍵は n 年間で期限切れ 鍵の有効期間は? (0) 0 鍵は無期限です これで正しいですか? (y/N) y GnuPGはあなたの鍵を識別するためにユーザIDを構成する必要があります。 本名: 田中太郎 電子メール・アドレス: taro@tanaka.town コメント: あなたは文字集合\u0026#39;utf-8\u0026#39;を使っています。 次のユーザIDを選択しました: \u0026#34;田中太郎 \u0026lt;taro@tanaka.town\u0026gt;\u0026#34; 名前(N)、コメント(C)、電子メール(E)の変更、またはOK(O)か終了(Q)? たくさんのランダム・バイトの生成が必要です。キーボードを打つ、マウスを動か す、ディスクにアクセスするなどの他の操作を素数生成の間に行うことで、乱数生 成器に十分なエントロピーを供給する機会を与えることができます。 たくさんのランダム・バイトの生成が必要です。キーボードを打つ、マウスを動か す、ディスクにアクセスするなどの他の操作を素数生成の間に行うことで、乱数生 成器に十分なエントロピーを供給する機会を与えることができます。 gpg: 鍵83AD9B71D78B7AA7を究極的に信用するよう記録しました gpg: 失効証明書を \u0026#39;/home/shun/.gnupg/openpgp-revocs.d/094ACC65CE981E96AA063B0483AD9B71D78B7AA7.rev\u0026#39; に保管しました。 公開鍵と秘密鍵を作成し、署名しました。 pub nistp521 2021-03-23 [SC] 094ACC65CE981E96AA063B0483AD9B71D78B7AA7 uid 田中太郎 \u0026lt;taro@tanaka.town\u0026gt; sub nistp521 2021-03-23 [E] これで署名・認証の主鍵と暗号化の副鍵が生成されました。しかし有効期限は両方とも無期限です。副鍵を編集して有効期限を1年にします。今生成された鍵の指紋が 094ACC65CE981E96AA063B0483AD9B71D78B7AA7 なのでこれを指定して編集します。\n gpg --edit-key 094ACC65CE981E96AA063B0483AD9B71D78B7AA7 で鍵の編集を開始 key 1 で暗号化用の副鍵を選択 expire で有効期限の編集を開始  1y で1年を指定、y で了承  save で編集を保存  コンソールではこうなります。\n$ gpg --edit-key 094ACC65CE981E96AA063B0483AD9B71D78B7AA7 gpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 秘密鍵が利用できます。 sec nistp521/83AD9B71D78B7AA7 作成: 2021-03-23 有効期限: 無期限 利用法: SC 信用: 究極 有効性: 究極 ssb nistp521/21D1788C632258F9 作成: 2021-03-23 有効期限: 無期限 利用法: E [ 究極 ] (1). 田中太郎 \u0026lt;taro@tanaka.town\u0026gt; gpg\u0026gt; key 1 sec nistp521/83AD9B71D78B7AA7 作成: 2021-03-23 有効期限: 無期限 利用法: SC 信用: 究極 有効性: 究極 ssb* nistp521/21D1788C632258F9 作成: 2021-03-23 有効期限: 無期限 利用法: E [ 究極 ] (1). 田中太郎 \u0026lt;taro@tanaka.town\u0026gt; gpg\u0026gt; expire 副鍵の有効期限を変更します。 鍵の有効期限を指定してください。 0 = 鍵は無期限 \u0026lt;n\u0026gt; = 鍵は n 日間で期限切れ \u0026lt;n\u0026gt;w = 鍵は n 週間で期限切れ \u0026lt;n\u0026gt;m = 鍵は n か月間で期限切れ \u0026lt;n\u0026gt;y = 鍵は n 年間で期限切れ 鍵の有効期間は? (0) 1y 鍵は2022年03月23日 09時46分25秒 JSTで期限切れとなります これで正しいですか? (y/N) y sec nistp521/83AD9B71D78B7AA7 作成: 2021-03-23 有効期限: 無期限 利用法: SC 信用: 究極 有効性: 究極 ssb* nistp521/21D1788C632258F9 作成: 2021-03-23 有効期限: 2022-03-23 利用法: E [ 究極 ] (1). 田中太郎 \u0026lt;taro@tanaka.town\u0026gt; gpg\u0026gt; save 有効期限の編集くらいならGUIクライアントからでもできます。そっちが好みの方はseahorseとかで編集してみて下さい。\nまた、ユーザ情報は複数登録できます。プライベートと仕事などで複数のメールアドレスを使い分けたいケースなどで有用ですね。ユーザ情報を追加で登録する場合は gpg --edit-key \u0026lt;key id\u0026gt; から adduid を選択して下さい。あるいはGUIからやるならseahorseでポチポチと追加できます。\nこれで鍵の生成は完了です。\n鍵のバックアップをとる OpenPGP鍵をYubikeyに焼くと二度とYubikeyの外に取り出せなくなります。あらかじめバックアップをとっておきましょう。この作業は一時的に鍵が書き出されるので細心の注意を払いながら進めます。\nまず念のためにtmpfsを用意します。見た目上ファイルを消してもディスクにはデータが残っていることがあります。特に私の使っているbtrfsだとCopy on Writeなので shred コマンドなどで消しても実際にはディスクに残ります。すると安全な場所に保管しているはずの秘密鍵が実は安全でない場所に残り続けていたという事態になりかねません。そういった問題を避けるためにtmpfs上で作業してデータをディスク上に残さないようにします。\ntmpfsをマウントします。\n$ mkdir workspace $ sudo mount -t tmpfs tmpfs workspace $ cd workspace tmpfs上で秘密鍵をエクスポートします。\n$ gpg --armor --export-secret-keys 094ACC65CE981E96AA063B0483AD9B71D78B7AA7 \u0026gt; secret_key.gpg 一旦この鍵をインポートできるか確認しておきます。\n$ gpg --import secret_key.gpg gpg: 鍵83AD9B71D78B7AA7:\u0026#34;田中太郎 \u0026lt;taro@tanaka.town\u0026gt;\u0026#34;変更なし gpg: 鍵83AD9B71D78B7AA7: 秘密鍵をインポートしました gpg: 処理数の合計: 1 gpg: 変更なし: 1 gpg: 秘密鍵の読み込み: 1 gpg: 無変更の秘密鍵: 1 よさそうなら手持ちのUSBメモリに保存しておいて下さい。鍵はパスワードで保護されているのでこのまま保管して大丈夫でしょう。USBメモリの不良セクタとかが怖ければ同じファイルをUSB内の2箇所に保存しておけばリスクヘッジできるんじゃないですかね。これは他人が触れない場所に大切に保管します。\n終わったら後片づけをします。\n$ shred secret_key.gpg $ cd ../ $ sudo umount workspace これで鍵のバックアップは完了です\n秘密鍵をYubikeyに焼く それでは秘密鍵をYubikeyに焼きます。 と、その前にYubikeyのPINを変更しておきましょう。PINがデフォルトのままだと危ないですからね。 PINはデフォルトで123456、管理者PINはデフォルトで12345678だそうです。 これを変更します。 この操作も gpg でできるようです。 YubikeyをPCに挿して以下の操作を行います。\n gpg --edit-card でYubikeyの編集を開始 passwd でPINの変更  現在のPIN（123456）、新しいPIN、新しいPINの確認を入力  admin で管理者用の編集モードに入る passwd でPINの変更。管理者用なので複数のメニューが出る。 3 で管理者用のPINを変更  現在の管理者PIN（12345678）、新しい管理者PIN、新しい管理者PINの確認を入力  Q でパスワードの変更完了 quit でYubikeyの編集完了  コンソールだとこうなります。\n$ gpg --edit-card gpg/card\u0026gt; passwd gpg: OpenPGPカードno. D2760001240103040006120841120000を検出 PIN changed. gpg/card\u0026gt; admin 管理者コマンドが許可されています gpg/card\u0026gt; passwd gpg: OpenPGPカードno. D2760001240103040006120841120000を検出 1 - change PIN 2 - unblock PIN 3 - change Admin PIN 4 - set the Reset Code Q - quit あなたの選択は? 3 PIN changed. 1 - change PIN 2 - unblock PIN 3 - change Admin PIN 4 - set the Reset Code Q - quit あなたの選択は? Q gpg/card\u0026gt; quit その他Reset PINもあるので必要に応じて設定しましょう。\nそれでは準備の万端が整ったので本当に秘密鍵をYubikeyに焼きます。Yubikeyには署名、認証、暗号化それぞれにスロットがあるようなので個別に焼きます。 YubikeyをPCに挿したまま以下の操作を行います。\n gpg --edit-key で鍵の編集を開始 keytocard で主鍵をYubikeyに移動させる  1 を選んで署名鍵を選択 （たしか）管理者PINが求められる  keytocard で主鍵をYubikeyに移動させる  3 を選んで認証鍵を選択 （たしか）管理者PINが求められる  key 1 で暗号化用の副鍵を選択 keytocard で副鍵をYubikeyに移動させる  2 を選んで認証鍵を選択 （たしか）管理者PINが求められる  quit で終了  y 了承   コンソールだとこうなります。昔焼いたときのログなので上記とは鍵の指紋やアルゴリズムが異なりますがやることは変わらないので別にいでしょう。\n$ gpg --edit-key 01FEF2424389F000BE9A7DA529B9340D65C60646 gpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 秘密鍵が利用できます。 sec rsa4096/29B9340D65C60646 作成: 2021-02-28 有効期限: 無期限 利用法: SC 信用: 究極 有効性: 究極 ssb rsa4096/A7F529BF0FCD8B54 作成: 2021-02-28 有効期限: 無期限 利用法: E [ 究極 ] (1). Peter George Phill \u0026lt;pgp@example.com\u0026gt; gpg\u0026gt; keytocard この主鍵を本当に移動しますか? (y/N) y 鍵を保管する場所を選択してください: (1) 署名鍵 (3) 認証鍵 あなたの選択は? 1 sec rsa4096/29B9340D65C60646 作成: 2021-02-28 有効期限: 無期限 利用法: SC 信用: 究極 有効性: 究極 ssb rsa4096/A7F529BF0FCD8B54 作成: 2021-02-28 有効期限: 無期限 利用法: E [ 究極 ] (1). Peter George Phill \u0026lt;pgp@example.com\u0026gt; gpg\u0026gt; keytocard この主鍵を本当に移動しますか? (y/N) y 鍵を保管する場所を選択してください: (1) 署名鍵 (3) 認証鍵 あなたの選択は? 3 sec rsa4096/29B9340D65C60646 作成: 2021-02-28 有効期限: 無期限 利用法: SC 信用: 究極 有効性: 究極 ssb rsa4096/A7F529BF0FCD8B54 作成: 2021-02-28 有効期限: 無期限 利用法: E [ 究極 ] (1). Peter George Phill \u0026lt;pgp@example.com\u0026gt; gpg\u0026gt; key 1 sec rsa4096/29B9340D65C60646 作成: 2021-02-28 有効期限: 無期限 利用法: SC 信用: 究極 有効性: 究極 ssb* rsa4096/A7F529BF0FCD8B54 作成: 2021-02-28 有効期限: 無期限 利用法: E [ 究極 ] (1). Peter George Phill \u0026lt;pgp@example.com\u0026gt; gpg\u0026gt; keytocard 鍵を保管する場所を選択してください: (2) 暗号化鍵 あなたの選択は? 2 sec rsa4096/29B9340D65C60646 作成: 2021-02-28 有効期限: 無期限 利用法: SC 信用: 究極 有効性: 究極 ssb* rsa4096/A7F529BF0FCD8B54 作成: 2021-02-28 有効期限: 無期限 利用法: E [ 究極 ] (1). Peter George Phill \u0026lt;pgp@example.com\u0026gt; gpg\u0026gt; quit 変更を保存しますか? (y/N) y ちゃんと焼けているか確認しましょう。適当なファイルに署名をしてみます。Yubikeyが挿さっているときに署名できること、Yubikeyが挿さっていないときに署名ができないことを確認します。\n$ echo test \u0026gt; test.txt $ gpg --sign test.txt $ rm test.txt.gpg これでYubikeyが挿さっているときにPINが求められ、Yubikeyが挿さっていないときにカードがないよってエラーが出たら成功です。\n運用 私はOpenPGPを多少は使っていますが扱いに失敗すると財産や生命が危険に晒されるような用途には使っていません。遊びというか、失敗しても笑えるくらいの用途でのみ使っています。内容については一切の責任を負わないので参考にする際は自己責任でお願いします。 私のブログより信頼できる情報としてGPGのハンドブックを挙げておきます。\nThe GNU Privacy Handbook\n鍵サーバ OpenPGPには鍵サーバというのがあって、みんなが公開鍵を登録できるらしいです。が、私は特に登録してないです。興味のある方はGPGが運営している鍵サーバを覗いてみて下さい。\nOpenPGP Keyserver\nKeybase コマンドで鍵を登録できます。\n$ keybase pgp update --all Thunderbird Thunderbird 78からPGPによる署名に対応しました。メールアカウントの [設定] → [エンドツーエンド暗号化]のOpenPGPの項目からGnuPG経由で外部の鍵を取り込んで、署名に取り込んだ鍵を指定します。\n署名する鍵に登録したメールアドレスの中にメールアカウントのメールアドレスが入ってないといけないことに注意して下さい。\nGIT 私はgitのコミットに署名しているので以下の設定を ~/.gitconfig に書いています。signingkey に渡す値は自分の鍵のIDか指紋を指定して下さい。\n[user] # ... signingkey = 2F3944FD72D3F1BD590C7309F88CE432DCC5FCBC [credential] helper = seahorse [commit] gpgsign = true これを設定しておくとPCにログインして最初の git commit のときにPINが求められます。以後は入力しなくてもコミットできます。\nGitLabやGitHubには公開鍵を登録できるので手動で登録します。まず gpg コマンドで公開鍵を出力します。\n$ gpg --armor --export 2F3944FD72D3F1BD590C7309F88CE432DCC5FCBC \u0026gt; public_key.gpg この public_key.gpg の中身をそれぞれのサービスに登録します。先述の鍵サーバからとってきてくれたら嬉しかったんですがそういう機能はないので手でコピペです。\n GitLab: preferencesのGPGキーに鍵を貼って登録 GitHub: settingsのSSH and GPG KeysからNew GPG Keyで登録  Yubikeyの扱い Yubikeyを普段どう使っているかについて紹介します。\nまずYubikeyはどのくらい取り扱い注意が必要か考えます。 ソフトウェア的には秘密鍵を取り出せないので、離席して一瞬同僚が触れる環境に置いたり、うっかり落して後ろの人に「落としましたよ」って声をかけられるくらいなら大丈夫じゃないですかね。 しかし秘密鍵が何らかの形でICに焼き込まれてるはずなので悪い人の手に渡って被膜を剥がれてなんか特殊な機械で読み取られたらマズいんじゃないかなと思ってます。 つまり、「他人に触られてもいいけど失くすのはダメ」のルールで取り扱います。 実際の運用としては家の鍵と同じくらいの扱いかなと思ったのでキーホルダーで家の鍵とまとめて使っています。\nそもそもYubikeyはOpenPGP秘密鍵の絶対的に安全な保管場所なのか何なのかですが、私は「比較的安全かつ便利に使える方法でOpenPGP秘密鍵を持ち運ぶツール」として使っています。 Yubikeyを家の中でしか使わないという人なら安全な保管場所としても使えるんじゃないですかね。\n次に使い方です。私のデスクトップPCの筐体が微妙に遠くにあって抜き差しがちょっと手間なので机の上にUSBを延長してそこに挿しています。具体的にはこれを使っています。\nヨドバシ.com - Digio デジオ UH-C3143BK [USB3.1 Type-C 3ポートハブ 120cm ブラック] 通販【全品無料配達】\nUSB Type-Aの延長はType-CからType-Aでないとできないようだったのでそういうケーブルを探しました。1つだけUSB Type-CのポートがあるPCでよかった。\nYubikeyを失くしたら もし鍵が家の中で失くなった、海に落とした、あるいはYubikeyが壊れて使えなくなったならYubikeyを買い直してバックアップの秘密鍵を再度Yubikeyに焼けばよいです。\n誰かの手に渡ったら先述のとおり悪い人に鍵を読み出されてしまうかもしれません。 そうでなくてもたまたまPINを当てられて勝手に使われる可能性もあります。 安全のため失効させましょう。\nもしOpenPGP鍵を生成したPCをそのまま使っているなら ~/.gnupg/openpgp-revocs.d/ 以下に失効証明書が残っているはずです。それを gpg --import します。 残っていないならバックアップの秘密鍵から gpg --gen-revoke で失効証明書を発行してから gpg --import します。 どちらかのアクションを行うとOpenPGP鍵が失効状態になるはずなので公開鍵を公開したときと同じフローで失効状態の公開鍵を公開すればよいようです。\nそのあとでYubikeyは買い直して再度セットアップをしましょう。\nまとめ YubikeyとOpenPGPについて紹介しました。そしてYubikeyにOpenPGP鍵を登録して運用するようにしたときのログを公開しました。\n諸々のリアルタイムな作業や調べもののログは下記のscrapに残してあるので必要な方は参考にして下さい。\nyubikeyを買ったので色々セットアップのメモ\nおまけ（鍵の移行） 今回私は新しい鍵を生成したのですが、Yubikeyを買う前から使っていたOpenPGP鍵も持っていました。しかしこれは一時期安全でない方法で保管していたので念のため退役させることにしました。 こういう、古い鍵も新しい鍵も揃っている場合に鍵の移行をする際にはtransition statementというのを発行することがあるようです。\nCreating a new GPG key with subkeys | Into.the.Void.\n私も発行してみました。\nκeenのtransition statement一式\nここには本体である transition_statement.txt と新旧鍵での署名 sig1.txt 、 sig2.txt があります。このtransition statementを私が書いたものであると確認するには以下のコマンドを使います（新旧鍵両方を持っている人向け）。\n$ gpg --verify sig1.txt transition_statement.txt gpg: 2021年03月23日 12時10分31秒 JSTに施された署名 gpg: RSA鍵866D76462E1140F5C6744CE90DB75EDC93CA52CBを使用 gpg: \u0026#34;κeen \u0026lt;3han5chou7@gmail.com\u0026gt;\u0026#34;からの正しい署名 [究極] $ gpg --verify sig2.txt transition_statement.txt gpg: 2021年03月23日 12時10分51秒 JSTに施された署名 gpg: ECDSA鍵2F3944FD72D3F1BD590C7309F88CE432DCC5FCBCを使用 gpg: \u0026#34;Shimura Rin \u0026lt;3han5chou7@gmail.com\u0026gt;\u0026#34;からの正しい署名 [究極] 因みに署名は以下のコマンドで作成しました。\n$ gpg --armor -b -u 866D76462E1140F5C6744CE90DB75EDC93CA52CB -o sig1.txt transition_statement.txt $ gpg --armor -b -u 2F3944FD72D3F1BD590C7309F88CE432DCC5FCBC -o sig2.txt transition_statement.txt","categories":["Yubikey","OpenPGP","GPG"],"category_urls":["/categories/yubikey","/categories/openpgp","/categories/gpg"],"date":"2021-03-23","title":"YubikeyでOpenPGP鍵をセキュアに使う","url":"https://KeenS.github.io/blog/2021/03/23/yubikeywotsukau_openpghen/"},
  {"body":"κeenです。前回の記事にもうちょっと実験を加えたのでその結果を書き留めます。\n前回の結果 前回の結果を貼っておきます。\nベンチマーク対象は標準ライブラリの write (std)、io_uringの Write (uring)、io_uringのfdやバッファの事前登録を使った WriteFixed (uring\u0026rsquo;)で、それぞれ4KiBのバッファを使って5GiB分書き込むコードでした。その結果が以下です。\n   name time(ms)     std 2031   uring 4486   uring\u0026rsquo; 1917    M.2のNVMe SSD x 4の上にbtrfsでRAID 5を組んだファイルシステム上で実験しており、Linuxカーネルは5.8.0でした。\n公平性の調整 ネタバレになるですが、キャッシュの具合やファイルが残ってるかどうかで速度が結構変わるのでベンチマーク後にファイルは削除し、ベンチマークの間に sync() を挟むことでキャッシュの影響をなくすようにしました。\nLinuxのアップデート 本件とは別の事情で最新版のLinuxを使う用事が発生したのでLinux 5.11.0を使っています。リリースノートを見るとbtrfsの高速化なども含んでいるので一応ベンチマークを取り直してみます。\n   name time(ms)     std 1779   uring 5088   uring\u0026rsquo; 2097    stdは速くなった一方uringはむしろ遅くなりましたね…。まあ、それぞれ1回しか測ってないのであんまり比べてもしょうがなさそうですが。\nパラメータチューニング 前回の記事を書いた直後くらいに元ScyllaDBの中の人が書いたブログをみつけました。\nModern storage is plenty fast. It is the APIs that are bad. | by Glauber Costa | ITNEXT\nバッファサイズなどをいじると速くなるよとのことです。ページサイズである4KiBが最適とばかり思っていたので意外でした。バッファサイズを512KiBにし、io_uringのsubmitするバッチサイズを1024から64に減らしたのが以下のベンチマークです。\n   name time(ms)     std 1472   uring 1668   uring\u0026rsquo; 1527    stdの速度向上が目覚しいですね…。\nSync 上記のベンチマークはシンプルに write してるだけです。OSがファイルへの書き込みをキャッシュするので実はストレージには大した量の書き込みが走っていません。普通はソフトウェア的にはそれでいいんですが、今回の目的の1つにNVMe SSDの特性を知るというのがあるので勿体無いですね。ストレージへの書き込みまで含めて実験してみましょう。\nストレージにまで書き込むには、ざっくりファイルを開くときに O_DIRECT | O_SYNC をつける方法と、書き込みが終わったら fsync を呼ぶ方法があるようです。io_uringにも fsync に対応する命令はあるので両方ともベンチマークできそうです。試してみましょう。\nO_DIRECT | O_SYNC をつけるのは標準ライブラリを使ったコードでもio_uringを使ったコードでも共通で、以下のようにやります。\nletmutopt=OpenOptions::new();opt.custom_flags(libc::O_DIRECT|libc::O_SYNC);// オプションからファイルを作る opt.write(true).create(true).open(path) 本当はファイルを開くのもio_uringでやることもできるんですが、どの途ファイルが開かれたのを待たないとIOを開始できないので普通にブロッキングなシステムコールを使ってます。\nfsync は標準ライブラリとio_uringで異なります。標準ライブラリなら sync_all です。\nfile.sync_all()?; io_uringなら Fsync オペコードを使います。\nunsafe{letentry=Fsync::new(Fd(file.as_raw_fd())).build();sq.available().push(entry).map_err(|_|io::Error::new(io::ErrorKind::Other,\u0026#34;failed to push entry to sq\u0026#34;))?;}submitter.submit()?; それぞれでベンチマークを走らせてみましょう。\nO_DIRECT | O_SYNC\n   name time(ms)     std 84190   uring 7290   uring\u0026rsquo; 3196    fsync\n   name time(ms)     std 3281   uring 3430   uring\u0026rsquo; 2781    全体的に uring\u0026rsquo; の優秀さが目立ちますね。そして O_DIRECT | O_SYNC は特にstdで圧倒的に遅いです。ある意味で私が見たかったのはこのベンチマークだった気がします。 fsync についてはどれも最終的に一気に書き出すコードになっているのでそこまで差はつかないようです。\nFallocate 先に書いた通り、前のベンチマークで作ったファイルが残ってるかどうかが速度に影響しました。恐らく書き足していくとストレージ上のファイルを大きくする処理が入って遅くなるのでしょう。今回は書く量が5GiBと先に決まっているのであらかじめファイルサイズを適切に変更してから書き出してみましょう。\nファイルサイズをあらかじめ確保するのは fallocate、 posix_fallocate 、 truncate などのシステムコールがあるようです。今回みたいにストレージ上の領域の確保を目的とするなら fallocate / posix_fallocate の方が向いているらしいですが、まあ truncate でも大丈夫でしょう。\n標準ライブラリなら File::set_len が使えます。\nfile.set_len(TOTALasu64)?; これはソースを読むとLinuxでは truncate を呼んでいるようでした。適切とされる fallocate ではありませんが細けぇことはいいんだよ！\nio_uringなら Fallocate オペコードが使えます。\nletentry=Fallocate::new(Fd(file.as_raw_fd()),TOTALasi64).build();sq.available().push(entry).map_err(|_|io::Error::new(io::ErrorKind::Other,\u0026#34;failed to push entry to sq\u0026#34;))?;submitter.submit()?; 特に確認はしてないですが名前からして fallocate 相当のオペコードだと信じていいんじゃないでしょうか。\nということで工夫なし、fsync 、 O_DIRECT | O_SYNC のそれぞれについて fallocate してから書き込みを開始したもののベンチマークもとってみます。\nfallocate\n   name time(ms)     std 1376   uring 1585   uring\u0026rsquo; 1426    fallocate + O_DIRECT | O_SYNC\n   name time(ms)     std 80043   uring 12501   uring\u0026rsquo; 2520    fallocate + fsync\n   name time(ms)     std 3337   uring 3425   uring\u0026rsquo; 2835    素の write と fsync ではあまり効果がなさそうですが O_DIRECT | O_SYNC と一緒なら fallocate しておいた方がかなり速いですね。特に、 uring\u0026rsquo; を fallocate + O_DIRECT | O_SYNC で走らせたときがストレージへの書き込みまで含んだ処理の中で最速になります。 uring が何故か遅くなってるのはよく分かりません。\nまとめ 前回雑にベンチマークを取った結果を見直し、OSのキャッシュやストレージ上のファイル領域の確保まで踏み込んだベンチマークをとりました。ただのwriteだと依然シンプルに write を走らせる方が速かったものの、ストレージ上の領域への書き込み完了まで含めた処理だとio_uringを工夫して使った方が速いという結果になりました。\nuringでfallocateした方が遅くなるなど多少不可解な挙動はありましたがひとまず私は満足しました。今回のコードは前回同様こちらに置いておきます。\nKeenS/io-uring-write-file\n","categories":["Linux","Rust","非同期"],"category_urls":["/categories/linux","/categories/rust","/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f"],"date":"2021-02-24","title":"io_uringで高速IO処理（！）","url":"https://KeenS.github.io/blog/2021/02/24/io_uringdekousokuioshori____/"},
  {"body":"κeenです。数年ブログをやってきて記事が溜まったので目的の記事をさがしやすいように全文検索をつけてみました。\nこのページです。右上のsearchから飛べます。実装は至ってシンプルで、本当に全文を検索しているだけです。ですがここに至るまでにちょっと経緯があったので紹介します。\n候補の検討 このissueでいくつか検討しています。私のブログは静的サイトジェネレータのHugoで作られているのでサーバで動作するコードはありません。全てをフロントエンドでやる必要があります。全文検索はフロントエンドでやるには少し重いタスクですが最近だとWebAssemlyがあるので徐々にフロントエンド全文検索が浸透してきているようです。\n今回検討の元になったというか全文検索を載せようと思ったのは以下の記事が発端です。\n WebAssembly Search Tools for Static Sites — Andrew Healey  ここで挙げられている検索エンジンを検討しました。\n stork：普通の検索エンジン。スニペットを埋め込むだけで使える。 tinysearch：Bloomフィルタべースの検索エンジン。検索部分だけでUIは自分で作る。  false positiveがあるのは嫌だしStorkをまずは検討してみました。\nStork 公式サイトにインストールガイドがあるのでそれに従うだけでインストールできます。とりあえず動くものを試すだけならそれで簡単に動いてよかったのですが、色々試すうちにちょいちょい不便な部分がみつかりました。\n UIがstork側持ちなので手を入れるのが少し面倒だった インデックス対象を1つ1つコンフィグに書かないといけなかった インデックスが大きすぎた  UIについてはフロントエンドに詳しくないくせにas-isで使わずに検索バーをいじろうとしたりブログのテーマに合わせてデザインを変えようとしたりした結果です。地味にブログテーマのCSSが適用されてちょっと表示がおかしくなったり、DOMノードが勝手に追加される影響で表示が崩れたりして苦戦しました。特に、私はinputの内容が空になったら検索結果ウィンドウを閉じてほしかったのにStork側が挿入したボタンを押さないとウィンドウが消えないなど、細かな点で不満が溜まりました。\nインデックス対象については数百ある記事を1つ1についてURLとファイル名とタイトルをTOMLで書く必要がありました。まあ、Hugoで頑張って生成できるんですが、なんかTOMLにつらつらと記事情報を並べていくのは微妙だなという気持に。\nStorkの一番ダメだった部分はインデックスの大きさですね。インデックスファイルが200MBくらいありました。当然、そんなものロードしてるとブラウザが固まるレベルで重くなりました。ということでこれはちょっと採用できないですね。\nTinysearch TinysearchはBloomフィルタベースなのでインデックスが小さく（268KB！）、APIも search を提供しているのみでUIはこちら持ちなので完全に制御できます。インデックス対象はJSONにURL、タイトル、本文を並べる形式ですが、HugoはJSONの生成までは想定しているのでまあ許容範囲でしょう。\nただちょっと気になる点がありまして、昔同僚がtinysearchの検索結果が非常に悪いと言っていたんですよね。Bloomフィルタだし多少はそうかもねと思ってたんですが今回使ってみてようやく分かりました。\nTinysearchはインデックスが小さく、ブログに載せられそうだと思って色々試してみると日本語の検索結果が壊滅的なことに気付きます。対象のワードを含んだ記事が一切引っ掛からず、関係ない記事がいくつか結果に出てくるのみです。Bloomフィルタの仕組みからして関係ない記事が上がることはあっても関係ある記事が引っ掛からないことはないはずです。よくよく調べてみるとtinysearchは入力のトークナイズに split_whitespace を使ってるだけの簡素なものでした。これだと日本語は全く扱えませんね。\nTinysearchに形態素解析を使うかn-gramを導入するかの提案をしようか迷ったのですが開発もあまり活発でなさそうですし、Rustで動く（TinysearchはRust製です）形態素解析エンジンで絶対おすすめと言えるのが見当たらなかったのでやめておきました。\nあと私はあんまり気にしなかったのですが、Tinysearchは容量削減のために一旦Bloomフィルタを埋め込んだRustのコードを生成してWebAssemblyにコンパイルする方式だったのでインデックスの生成に時間がかかります。その点で受け入れられない人もいるかもしれません。\n全文検索…？ ところで、そもそも私のブログに対して全文検索をするのは正しいのでしょうか。転置インデックスを生成するとしたらどのくらいのサイズになるのでしょうか。\n丁度、Tinysearchのときに全文入りのJSONを生成しているのでそのサイズを測ってみると3.5MBでした。ちょっと「うっ」となりますがこれだけならまあ読み込めないサイズじゃないですね。ですがここからbigramで転置インデックスを作ると、1byteあたりbiなので+1byte、インデックスが4byteとして最低でもサイズが6倍くらいになります。スマホユーザがそれなりにいることを考えると数十MBのデータの転送はちょっと許容できませんね。\nTinysearchは数百KBに収まっていたのでアプローチとしてはBloomフィルタとかの方向になりそうですが、ふと素のままのJSONファイルが数MBと転送できそうなサイズだったことを思い出します。\n試しにTinysearchのときに生成したJSONファイルをブラウザにロードして、検索ワードを記事1つ1つに対して match するコードを書いていみたら思いの外軽快に動くことに気付きました。流石に1入力ごとにインクリメンタルに検索するのはちょっとつらいですが、入力して検索ボタンを押す方式であれば問題なく動きます。\nということで私が今回採用した検索アルゴリズムは以下です。\nfunction search(word) { let result = []; for (i = 0; i \u0026lt; data.length; i++) { if (data[i].body.match(word)) { result.push(data[i]); } } return result; } 個人の作るデータ量は大したことないので案外線形探索でもどうにかなってしまうんですね。スマホでもサクサク動きました。8年ブログやっててこの量なのであと10年くらいは同じコードでも問題ないはずです。10年後にはコンピュータのスペックも上がってるでしょうし、それ以前にもっと賢い方法が登場するでしょうからしばらくはこのまま運用できそうです。\nまとめ 静的サイトに全文検索エンジンを導入しました。転置インデックス、Bloomフィルタを試してみて、結局個人のブログで使う量であれば線形探索で十分であることが分かりました。検索分野はかなり発達してる領域ですし転置インデックスの圧縮方法くらいいくらでもありそうですが、そういう実装ないんですかね？\n","categories":["Hugo"],"category_urls":["/categories/hugo"],"date":"2021-02-23","title":"Hugoのブログに全文検索をつけた","url":"https://KeenS.github.io/blog/2021/02/23/hugonoburogunizenbunkensakuwotsuketa/"},
  {"body":" search Results:    function search(word) { let result = []; for (i = 0; i ","categories":[],"category_urls":[],"date":"2021-02-23","title":"Search","url":"https://KeenS.github.io/search/"},
  {"body":"κeenです。普段お世話になってるけど使ったことのないAPIを叩いてみよう、ということで io_uring を使ってみます。\nio_uringが何なのかは以下の記事が詳しかったです。\n Linuxにおける非同期IOの実装について - Qiita  ざっくり、io_uringはLinuxで非同期IOをするためのAPIです。 ユーザランドとカーネルランドで2つのキューを共有し、そこを通じて会話をします。 1つのキューはユーザランドからカーネルへのリクエストの提出用、もう1つのキューはカーネルからユーザランドへの完了の通知用です。 また、epollを制御するためにfdもあります。こんなイメージですかね。\nuser | ^ ^ submit ||| || ||| completion -------|||--fd-|||---------- ||| || ||| v v | kernel それぞれのキューはリングバッファで実装されています。\nio_uringではIO処理の依頼とその完了待ちが分離されているので処理を発行しておいて自分のタイミングで結果を受け取ることができます。例えば3つのIO処理をするときにio_uringなしに普通の処理をやろうとすると3回分IOの待ちが発生します。\n| | +---\u0026gt;| | | |\u0026lt;---+ +---\u0026gt;| | | |\u0026lt;---+ +---\u0026gt;| | | |\u0026lt;---+ しかしio_uringを使えばIOリクエストを矢継ぎ早に送れるので待ち時間を短縮できます。\n| | +---\u0026gt;| +---\u0026gt;| +---\u0026gt;| | | |\u0026lt;---+ |\u0026lt;---+ |\u0026lt;---+ 特にSSDだとコマンドキューにどれだけ命令を詰め込めるかが勝負らしい（？）のでio_uringだと有利なのかもしれません。\nということでio_uringを使ってIO処理を高速化してみましょう。\nliburing io_uringはLinuxのAPIですが、そのまま使うにはいささか手間が大きいです。 今までカーネルで全てやってきたことをユーザでコントロールできるようにするということはユーザでやることが増えるということでもあります。そこでio_uringを簡単に使えるライブラリとしてliburingがあります。\n axboe/liburing  Ubuntuならaptで入ります。\n$ apt get install liburing-dev liburingの有無で使い勝手がどう違うかは以下のリポジトリが参考になりました。\n shuveb/io_uring-by-example: A companion repository for the io_uring by Example article series  まあ、今回私はRustのラッパを使うのでliburingは関係ないんですけどね。\nRustからio_uringを使ってみる ということでio_uringを使ってみましょう。Rustからだといくつかラッパが存在するようですがTokioのio_uringラッパを使ってみましょう。\n tokio-rs/io-uring: The io_uring library for Rust  これはliburingを使わずにlibcのio_uringを直接ラップしたライブラリです。\nやることはシンプルに \u0026lsquo;aaaaaaa\u0026hellip;\u0026rsquo; と5GiBの \u0026lsquo;a\u0026rsquo; が書かれたファイルを作ってみます。 今回のコード全体は以下に置いておきます。\n KeenS/io-uring-write-file  以後は重要なところだけを拾って解説していきます。\n標準ライブラリでの実装 io_uringを使ずに標準ライブラリだけで書いたシンプルなコードであれば以下のように書けるでしょう。\nusestd::fs::File;usestd::io;usestd::io::prelude::*;pubconstTOTAL: usize =5*1024*1024*1024;pubstaticDATA: [u8;4096]=[0x61;4096];letmutfile=File::create(\u0026#34;std.text\u0026#34;)?;letnpages=TOTAL/DATA.len();for_in0..npages{file.write_all(\u0026amp;DATA)?;} これと同等のことをio_uringで実装します。\nio-uringを使った実装 io_uringで書き直してみます。 まずはファイルを開いておきましょう。\nusestd::fs::File;letfile=File::create(\u0026#34;iouring.text\u0026#34;)?; そしてio_uringを初期化します。\nuseio_uring::opcode::types::Fd;useio_uring::opcode::Write;useio_uring::IoUring;letmuturing=IoUring::new(2048)?; 引数はリングバッファのサイズです。 2048という数値はまあ、なんか雰囲気で決めました。 Linuxのio_uringではsubmitのキュー（sq）とcompletionのキュー（cq）それぞれ長さを指定できるはずですがTokioのバインディングでは両方とも同じ長さを指定しているようです。\n上の方でio_uringにはfd、sq、cqがあるといいましたが、Tokioのバインディングも3つのコンポーネントが取り出せます。\nlet(submitter,sq,cq)=uring.split(); submitterはfd経由でsubmissionを管理するからのネーミングなんでしょう。\n一旦データサイズとかを用意して\npubconstTOTAL: usize =5*1024*1024*1024;pubstaticDATA: [u8;4096]=[0x61;4096];letnpages=TOTAL/DATA.len(); タスクを発行したときに完了まで待たないので完了したタスクを管理する変数を別途用意します。\nletmutcompleted=0; さて、ここからIOリクエストを提出する段に入ります。 IOリクエストを entry として、以下の3行でIOリクエストを提出できます。\nunsafe{letentry=/* ... */sq.available().push(entry).map_err(...)?submitter.submit()?;} sq.available() というのがTokioのバインディングのユニークな点で、その時点で空いているキューのビューを提供します。 一瞬「それスレッドセーフじゃなくね？」って思いますがRustなので大丈夫です。所有権システムが守ってくれます。\nこの submit ですが一気に複数のIOリクエストを溜めて一気に提出できます。 submit の回数は少ない方がカーネルとのやり取りが減って速そうなので1024回分のリクエストを溜めて一気に送ってみます。\nforjin0..1024{unsafe{letentry=/* ... */;sq.available().push(entry)?;}}submitter.submit()?; つまり、全体はこういうイメージです。\nletouter=npages/1024;foriin0..outer{forjin0..1024{unsafe{letentry=/* ... */;sq.available().push(entry).map_err(...)?;}}submitter.submit()?;} ここで先送りにしていた entry を作りましょう。 Cだと IORING_OP_XXX で操作を指定してデータを詰めるんですがTokioのバインディングはOPごとに構造体が用意されていて、それをビルダとして Entry を作る設計のようです。\n単刀直入にentryを作るコードを書くとこうです。\n// libc crateをdependencyに追加しておく uselibc::off_t;useio_uring::opcode::types::Fd;useio_uring::opcode::Write;letn=i*1024+j;letentry=Write::new(Fd(file.as_raw_fd()),\u0026amp;DATAas*constu8,DATA.len()asu32).offset((n*DATA.len())asoff_t).build(); 要点を解説すると以下です。\n Write で書き込みのIOリクエスト Write にはファイルを表わすfd、バッファと長さを指定  今回は固定の内容を書き込むのでバッファを使い回してる  そのままだとファイルの先頭に書くだけなので offset でファイルのどこに書くかを指定  総合して、以下のコードになります。\nletouter=npages/1024;foriin0..outer{forjin0..1024{letn=i*1024+j;unsafe{letentry=Write::new(Fd(file.as_raw_fd()),\u0026amp;DATAas*constu8,DATA.len()asu32).offset((n*DATA.len())asoff_t).build();sq.available().push(entry).map_err(...)?;}}submitter.submit()?;} なんですが、これだと cq が詰まってしまうらしくエラーになります。device busyのエラーだったんですがなんでなんでしょうね。 なので適度に cq も消費します。 今回は返り値には興味がないので返り値が成功かどうかはみずにそのまま消費します。 cq.available() はイテレータになっているので count を呼んであげると completed も計算できて丁度よさそうです。\nforiin0..outer{forjin0..1024{/* ... */}submitter.submit()?;// cqを消費する ifi%4==0{completed+=cq.available().count();}} これでIOリクエストを提出できました。\n次はIOリクエストの完了待ちです。それには submitter の submit_and_wait を使うとよさそうです。 残ってる分のリクエストを順次消費していきます。\nwhilecompleted!=npages{letrest=npages-completed;submitter.submit_and_wait(rest)?;letcount=cq.available().count();completed+=count} rest を計算していますがそもそもキューの長さが2048なので最大で2048までしか返ってきませんがまあ、気にしなくてよいでしょう。どのみち while で完了するまで待ちます。\nベンチマーク 高速なIO処理を目指して書いたのでベンチマークを取ってみましょう。 雑に処理の開始と終了の時間の差をとります。 標準ライブラリを使った実装をstd、io_uringを使った実装をuringとします。\n   name time (ms)     std 2031   uring 4486    …………。stdの方が倍以上速いという結果になりました。 因みに time コマンドによるとuringの方が使っているCPU時間は短いです。\n$ /usr/bin/time ./target/release/std 2031 ms 0.04user 1.98system 0:02.03elapsed 99%CPU (0avgtext+0avgdata 1888maxresident)k 0inputs+10485760outputs (0major+90minor)pagefaults 0swaps $ /usr/bin/time ./target/release/iouring 4486 ms 0.02user 0.19system 0:04.48elapsed 4%CPU (0avgtext+0avgdata 1948maxresident)k 0inputs+0outputs (0major+91minor)pagefaults 0swaps キューの待ちでも発生したんですかねぇ？\nio_uringの高速化 ちょっとこのままだと収まりが悪いのでio_uringを高速化してみます。 ポイントは2つあって、ファイルfdの事前登録とバッファの事前登録です。\nカーネルのことはよく分からないんですがfdをカーネルに渡してそれをカーネル側であれこれしてもらうのは時間がかかるらしいです。 そこでカーネルに事前に使う予定のfdを事前に渡しておけばその時間を短縮できるらしいです。\nもう1つがバッファの事前登録です。これは分かりやすいですね。 submit の度にRustのメモリ領域からカーネル内にデータをコピーして使っています。 これは無駄なので事前にデータ提出に使うバッファをユーザランドとカーネルランドで共有しておけばコピーの手間が省けます。 ただしこれにはカーネルと共有できるメモリを確保したり共有メモリ専用のIOリクエストを使ったりの作業が必要になります。\nこれら2つの操作はlibc的には io_uring_register で、Tokioのio-uring的にはsubmitterに生えてる register_xxx 系の関数でやります。\nファイルの事前登録 これは単純ですね。関数を呼ぶだけです。\nsubmitter.register_files(\u0026amp;[file.as_raw_fd()])?; バッファの事前登録 これはちょっと厄介です。まず、 mmap でANONYMOUSなメモリを確保します。\nuselibc::{mmap,MAP_ANONYMOUS,MAP_PRIVATE,PROT_READ,PROT_WRITE};usestd::ffi::c_void;usestd::ptr::null_mut;letbuf;unsafe{buf=mmap(null_mut::\u0026lt;c_void\u0026gt;(),DATA.len(),PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0,);if(bufasisize)==-1{returnErr(io::Error::last_os_error());}foriin0..DATA.len(){*((bufas*mutu8).offset(iasisize))=DATA[i];}} それを register_buffers します。\nuselibc::iovec;submitter.register_buffers(\u0026amp;[iovec{iov_base: buf,iov_len: DATA.len(),}])?; そして entry を作るところで Write の代わりに WriteFixed を使います。\nletentry=WriteFixed::new(Fd(file.as_raw_fd()),bufas*constu8,DATA.len()asu32,0).offset((n*DATA.len())asoff_t).build(); WriteFixed は Write と比べて1つ引数が増えており、最後の引数で register したどのバッファを使うのかを指定します。 全体を知りたい方はGitHubのコードを読んで下さい。\nベンチマーク これを走らせてみます。uring\u0026rsquo;と呼びましょうか。\n   name time (ms)     uring\u0026rsquo; 1917    わずかにstdよりも速く見えますが、測定でそこそこバラつきがあったので多分有意な差はないです。 少なくとも工夫のないio_uringよりは速いことだけは分かります。\n因みにですが time コマンドによると相変わらずCPU使用率が低いようです。\n$ /usr/bin/time ./target/release/iouring_tuned 1917 ms 0.02user 0.29system 0:01.97elapsed 16%CPU (0avgtext+0avgdata 1956maxresident)k 0inputs+64outputs (0major+91minor)pagefaults 0swaps stdと実時間では変わらないけどsystemのCPU使用時間と全体のCPU使用率が低いのは気になりますね。\n私にはこれ以上深く追求するための知識が足りないのでここまでとします。 perfの結果なんかも微妙に違ってたんですが解釈できないデータを貼っても意味がないので気になった方は手元で走らせてみて下さい。\nそもそも、 dd で同様の処理をしてもRustのコードより遅いのでそういうもんなのかもしれません。\n$ /bin/time dd if=/dev/zero of=dd.bin bs=4K count=1310720 1310720+0 レコード入力 1310720+0 レコード出力 5368709120 bytes (5.4 GB, 5.0 GiB) copied, 2.88155 s, 1.9 GB/s 0.09user 2.89system 0:02.99elapsed 99%CPU (0avgtext+0avgdata 2352maxresident)k 0inputs+10486112outputs (0major+91minor)pagefaults 0swaps dd がそこまでパフォーマンスを気にして書かれてるか分かりませんが。\nまとめ io_uring APIの雑な紹介とそれをRustから叩くコード3種を紹介しました。 io_uringで処理を高速化する目論みでしたが失敗しました。 よく考えたらどのみちOSのバッファに載って処理されるのでio_uringあんまり関係なかったのではという説もあります。 やるんなら高速化ではなくマルチタスクの方がよかったかもしれませんね。\n今出すかよって感じですが実行環境はM.2のNVMe SSD x 4の上にbtrfsでRAID 5を組んだファイルシステムで、ちょっとパフォーマンス特性に癖があったのかもしれません。 調べたらbtrfsはジャーナリングする関係でシーケンシャルアクセスに弱いとかSSDはブロック単位で操作するからどうこうとか色々出てくるのですが、こういうのはfolkloreとかも多くてどこまで信じていいのか分からないので追求しないことにしました。 @naota さんとかが解説してくれないかな…。因みにカーネルのバージョンは5.8.0-41です。\n再掲になりますが今回のコードはこちらです。\n KeenS/io-uring-write-file  何回か走らせて平均と分散とんないと何も議論できなくない？とかファイルキャッシュどうなってるの？とか色々気になるかと思います。そういう方は手元で走らせて実験してみて下さい。\n最後に、参考にした資料を貼っておきます。\n Linuxにおける非同期IOの実装について - Qiita axboe/liburing  特にexamplesとREADMEに貼ってあるPDF  shuveb/io_uring-by-example: A companion repository for the io_uring by Example article series man io_uring_enter 、 man io_uring_register io_uring - Rust  締まりのない記事になりましたが参考になる方がいれば幸いです。\n","categories":["Linux","Rust","非同期"],"category_urls":["/categories/linux","/categories/rust","/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f"],"date":"2021-02-08","title":"io_uringで高速IO処理（？）","url":"https://KeenS.github.io/blog/2021/02/08/io_uringdekousokuioshori___/"},
  {"body":"κeenです。 普段お世話になってるけど使ったことのないAPIを叩いてみよう、ということで epoll(7) を使ってみます。\nEpollとは epoll(7) はLinux固有のAPIで、パイプやソケットなど出入力に待ちが発生する対象を複数同時に待つ、いわゆるIOの多重化の機能を提供します。 同等のことをするAPIはUNIX全般で使える select(2) や poll(2) などもありますが、使い勝手やパフォーマンスの面で epoll が勝るようです。\n一方で epoll(7) はLinux固有のAPIなのでmacOSやFreeBSDでは使えません。それらのOSでは別のAPI（kqueue(2)）を叩くことになります。 Rustならmioが互換レイヤとして存在し、LinuxでもBSDでもmacOSでも使えるライブラリになっています。 mioはTokioなんかで使われていますね。ですが今回はその内側を覗いてみようという趣旨なので直接 epoll(7) を叩きます。。\nEpoll API epoll(7) と呼んでますが、実際のAPIは複数の関数からなります。\n epoll_create , epoll_create1: 初期化 epoll_ctl: 待つ対象の登録、変更などの操作 epoll_wait, epoll_pwait: 実際に待つ  ざっくりと、Rust風の疑似コードで以下のようなコードを書くことになります。\n// 初期化 letepoll_fd=epoll_create();// 監視対象の追加 letsome_fd=/* 監視対象 */;letsome_event=/* 監視するイベント + データ */;letepoll_ctl(epoll_fd,EPOLL_CTL_ADD,some_fd,some_event);letevents=/* バッファの確保 */lettimeout=-1;// -1 = タイムアウトしない loop{// 実際に待つ letn=epoll_wait(epoll_fd,events,timeout);foreventinevents[0..n]{// 何かする // 次に必要なイベントを登録する epoll_ctl(epoll_fd,EPOLL_CTL_ADD,some_fd,some_event);}} epoll_create() してループの中で epoll_wait します。 そして適宜 epoll_ctl でpoll対象を操作します。\nfd はFile Descriptorのことです。fdについて知らない方は適当にググって下さい。\nここで、 epoll_wait の結果得られるのは event であることに注目です。 event の中身はCで以下のように定義されています。\ntypedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events に何が起きたか（read/writeが可能になった、クライアントが切断した、など）、data に epoll_ctl のときに任意に持たせたデータを保持しています。 簡単には fd を持たせればそのまま読み書きができます。 しかし複雑なアプリケーションになるともうちょっと色々データを持たせたくなります。 そこで data にIDを登録しておいて、アプリケーション側で HashMap なんかで実際のデータを管理することになるでしょう。\nEpollで作るチャットサーバ in Rust IOの多重化を必要とするアプリケーションとしてチャットサーバをRustで作ってみようと思います。コードはGitHubに上げておくので、この記事内では要点を絞って解説していきます。\n epoll-chat  作るチャットサーバは簡素なものです。telnetで接続すると名前を聞かれるので答えます。 するとログインに相当し、以後入力したものがそのまま自分の発言として他のユーザに表示されます。 入力は1行（telnetなので改行は \\r\\n）が1単位です。 ログアウトするにはコネクションを切断します。\nこのチャットサーバを作っていきましょう。\nNix Rustからepollを叩く手段はいくつかありますが、ここでは nixによるラッパを使います。nix::sys::epoll のドキュメントを見て分かるとおり割と素直にRustでラップできているので使い勝手がよいです。\n例えば epoll_create は以下のように使えます。\nusenix::sys::epoll::*;letepoll_fd=epoll_create().expect(\u0026#34;can create epoll queue\u0026#34;) unsafe がなく、しかも epoll_create はRustの Result として返っているのでRustにとって自然に使えるようになっています。\nコネクションの受け付け TcpListener でアドレスにバインドしておきます。そして epoll で使うために set_nonblocking しておきます。\nletlistener=TcpListener::bind(addr)?;listener.set_nonblocking(true)?; これも新しいコネクションがきたことを epoll で観察できるので epoll_ctl で監視対象に追加します。\nconstNEW_CONNECTION: u64 =100;letevent=EpollEvent::new(EpollFlags::EPOLLRDHUP|EpollFlags::EPOLLIN,NEW_CONNECTION);letfd=listener.as_raw_fd()epoll_ctl(epoll_fd,EpollOp::EpollCtlAdd,fd,event).map_err(|e|io::Error::new(io::ErrorKind::Other,e)) ポイントは以下の2点です。\n listener のfdを EPOLLRDHUP （切断検知）と EPOLLIN （read ready待ち）で監視対象にいれる listener に固有のID 、 NEW_CONNECTION を与える  上の epoll(7) の紹介のところでも触れたのですが、 epoll_wait で読み取りできるようになった fd を管理するのにIDを使います。 ここでは listener の管理をするIDに NEW_CONNECTION を使っています。\nメインループ 受け付け準備ができたらメインループを書きましょう。 新しいコネクションがきたら handle_new_connection を呼ぶことにして、以下のようなコードを書きます。\nletmutevents=vec![EpollEvent::empty();1024];loop{println!(\u0026#34;clients connected: {}\u0026#34;,self.users.len());letres=matchepoll_wait(epoll_fd,\u0026amp;mutevents,-1){Ok(v)=\u0026gt;v,Err(e)=\u0026gt;panic!(\u0026#34;error during epoll wait: {}\u0026#34;,e),};forevin\u0026amp;events[0..res]{matchev.data(){NEW_CONNECTION=\u0026gt;handle_new_connection(\u0026amp;listener)?,_=\u0026gt;todo!(),}}} ポイントは以下の3点です。\n epoll_wait の第2引数に事前に確保した配列を渡す epoll_wait の第3引数にタイムアウト値を渡す（-1はタイムアウトしない） epoll_wait の返り値で読み書き可能になった対象の数を知る  ユーザを作る handle_new_connection では accept でコネクションを取り出せます。\nfn handle_new_connection(listener: \u0026amp;TcpListener)-\u0026gt; io::Result\u0026lt;()\u0026gt;{matchlistener.accept(){Ok((stream,addr))=\u0026gt;{stream.set_nonblocking(true)?;// do something }Err(e)=\u0026gt;eprintln!(\u0026#34;couldn\u0026#39;t accept: {}\u0026#34;,e),};Ok(())} この stream が1クライアントに相当します。これを管理する構造体 User を定義しましょう。\n#[derive(Debug)]struct User{stream: TcpStream,queue: VecDeque\u0026lt;Arc\u0026lt;String\u0026gt;\u0026gt;,// and other fields }implUser{fn new(stream: TcpStream)-\u0026gt; Self{Self{stream,queue: VecDeque::new(),// and other fields }}fn push_message(\u0026amp;mutself,message: Arc\u0026lt;String\u0026gt;){self.queue.push_back(message)}fn pop_message(\u0026amp;mutself)-\u0026gt; Option\u0026lt;Arc\u0026lt;String\u0026gt;\u0026gt;{self.queue.pop_front()}fn raw_fd(\u0026amp;self)-\u0026gt; i32 {self.stream.as_raw_fd()}} User はコネクションとそのユーザに送られるメッセージキューを保持します。 メッセージを実際に送る部分は後で実装するとして、ひとまず初回接続時のメッセージを出すのはこう書けます。\nOk((stream,addr))=\u0026gt;{stream.set_nonblocking(true)?;letmutuser=User::new(stream);user.push_message(Arc::new(\u0026#34;Enter your name: \u0026#34;.into()));// and others } さて、ここで作った User を epoll に登録したりIDで管理したりしたいのですが、このままだとやりづらいですね。Server 構造体を作りましょう。\nサーバを作る ユーザなどを管理するためのサーバを作りましょう。\nID生成器 …とその前に User のIDを管理するためのID生成器を作ります。 User のIDはメインループで使った NEW_CONNECTION のものと被ってはいけないので NEW_CONNECTION の次の番号から返すようにしておきます。\n#[derive(Debug)]struct IdGenerator(u64);implIdGenerator{fn new()-\u0026gt; Self{Self(NEW_CONNECTION)}fn next(\u0026amp;mutself)-\u0026gt; u64 {self.0+=1;self.0}} Server Server を以下のように定義します。\n#[derive(Debug)]struct Server{epoll_fd: RawFd,id_gen: IdGenerator,users: HashMap\u0026lt;u64,User\u0026gt;,} 今まで出てきたコードは以下のように整理しておきましょう。\nimplUser{fn new()-\u0026gt; Self{Self{epoll_fd: epoll_create().expect(\u0026#34;can create epoll queue\u0026#34;),id_gen: IdGenerator::new(),users: HashMap::new(),}}fn add_interest(\u0026amp;self,fd: RawFd,event: \u0026amp;mutEpollEvent)-\u0026gt; io::Result\u0026lt;()\u0026gt;{epoll_ctl(self.epoll_fd,EpollOp::EpollCtlAdd,fd,event).map_err(|e|io::Error::new(io::ErrorKind::Other,e))}fn handle_new_connection(\u0026amp;mutself,listener: \u0026amp;TcpListener)-\u0026gt; io::Result\u0026lt;()\u0026gt;{// ... }fn run\u0026lt;A: ToSocketAddrs\u0026gt;(\u0026amp;mutself,addr: A)-\u0026gt; io::Result\u0026lt;()\u0026gt;{letlistener=TcpListener::bind(addr)?;listener.set_nonblocking(true)?;self.add_interest(listener.as_raw_fd(),\u0026amp;mutlistener_read_event(NEW_CONNECTION),)?;letmutevents=vec![EpollEvent::empty();1024];loop{println!(\u0026#34;clients connected: {}\u0026#34;,self.users.len());letres=matchepoll_wait(self.epoll_fd,\u0026amp;mutevents,-1){Ok(v)=\u0026gt;v,Err(e)=\u0026gt;panic!(\u0026#34;error during epoll wait: {}\u0026#34;,e),};forevin\u0026amp;events[0..res]{matchev.data(){NEW_CONNECTION=\u0026gt;self.handle_new_connection(\u0026amp;listener)?,_=\u0026gt;todo!(),}}}}} 監視するイベントについてもここでまとめてしまっています。 イベントについては色々ありえるのですが、今回のチャットサーバにおいては2種類しか必要ありません。すなわちコネクションの切断+read readyか、それに加えてwrite readyまで見るかです。それを以下のように定義してしまいます。\nfn listener_read_event(key: u64)-\u0026gt; EpollEvent{EpollEvent::new(EpollFlags::EPOLLRDHUP|EpollFlags::EPOLLIN,key)}fn listener_read_write_event(key: u64)-\u0026gt; EpollEvent{EpollEvent::new(EpollFlags::EPOLLRDHUP|EpollFlags::EPOLLIN|EpollFlags::EPOLLOUT,key,)} ユーザの管理 これからユーザを管理するので、そのためのメソッドを生やしておきます。\nimplServer{fn add_user(\u0026amp;mutself,key: u64,user: User){self.users.insert(key,user);}fn watch(\u0026amp;self,user: \u0026amp;User,event: \u0026amp;mutEpollEvent)-\u0026gt; io::Result\u0026lt;()\u0026gt;{epoll_ctl(self.epoll_fd,EpollOp::EpollCtlAdd,user.raw_fd(),event).map_err(|e|io::Error::new(io::ErrorKind::Other,e))}fn change_event(\u0026amp;self,user: \u0026amp;User,event: \u0026amp;mutEpollEvent)-\u0026gt; io::Result\u0026lt;()\u0026gt;{epoll_ctl(self.epoll_fd,EpollOp::EpollCtlMod,user.raw_fd(),event).map_err(|e|io::Error::new(io::ErrorKind::Other,e))}fn unwatch(\u0026amp;self,user: \u0026amp;User)-\u0026gt; io::Result\u0026lt;()\u0026gt;{epoll_ctl(self.epoll_fd,EpollOp::EpollCtlDel,user.raw_fd(),None).map_err(|e|io::Error::new(io::ErrorKind::Other,e))}} add_user はいいとして、 watch / change_event / unwatch について触れます。これらは全て epoll_ctl のラッパです。 watch は epoll への登録、 unwatch は登録解除、 change_event は監視イベントの変更を担当し、それぞれ EpollCtlAdd 、 EpollCtlDel 、 EpollCtlMod を呼んでいます。\nこれらのAPIを使って handle_new_connection を完成させられます。\nfn handle_new_connection(\u0026amp;mutself,listener: \u0026amp;TcpListener)-\u0026gt; io::Result\u0026lt;()\u0026gt;{matchlistener.accept(){Ok((stream,addr))=\u0026gt;{stream.set_nonblocking(true)?;println!(\u0026#34;new client: {}\u0026#34;,addr);letkey=self.id_gen.next();letmutuser=User::new(stream);user.push_message(Arc::new(\u0026#34;Enter your name: \u0026#34;.into()));self.watch(\u0026amp;user,\u0026amp;mutlistener_read_write_event(key))?;self.add_user(key,user);}Err(e)=\u0026gt;eprintln!(\u0026#34;couldn\u0026#39;t accept: {}\u0026#34;,e),};Ok(())} user を watch していますね。\nユーザイベントを処理する ここまでで User を作ってメッセージをキュー入れ、 epoll に登録するところまできました。 epoll_wait で User も監視できるようになっているので、 User で何か動向があったときの処理も書きましょう。 処理本体は handle_user_event というメソッドに書くとして、メインループでは以下のように NEW_CONNECTION か否かで処理を振り分けることになるでしょう。\nloop{// ... forevin\u0026amp;events[0..res]{matchev.data(){NEW_CONNECTION=\u0026gt;self.handle_new_connection(\u0026amp;listener)?,// ここ↓↓ _=\u0026gt;self.handle_user_event(*ev)?,}}} そして肝心の handle_user_event についてです。 このメソッドユーザに動向があったときに毎回呼ばれるので内部でどのイベントで呼ばれたのかで処理を振り分けることにします。 中々本丸に到達しませんね。\nfn handle_user_event(\u0026amp;mutself,ev: EpollEvent)-\u0026gt; io::Result\u0026lt;()\u0026gt;{letkey=ev.data();letevents=ev.events();ifletSome(mutuser)=self.users.remove(\u0026amp;key){ifevents.contains(EpollFlags::EPOLLIN){self.handle_user_readable(\u0026amp;mutuser)?;}ifevents.contains(EpollFlags::EPOLLOUT){self.handle_user_writable(\u0026amp;mutuser,key)?;}ifevents.contains(EpollFlags::EPOLLRDHUP){self.handle_user_closed(\u0026amp;mutuser)?;}else{self.add_user(key,user)}}Ok(())} ところでこのコード、 if { ... } else if { ... } ではなく if { ... } の連続である点に注意して下さい。 User が同時にreadableかつwritableになることもあるので複数のイベントを同時に処理します。\nそれではwritableの場合の処理に進みましょう。 User がwritableになったらwritableのコールバックを呼びます。そしてキューが空になっていたらwritableの購読をやめます。\nfn handle_user_writable(\u0026amp;mutself,user: \u0026amp;mutUser,key: u64)-\u0026gt; io::Result\u0026lt;()\u0026gt;{user.write_cb()?;ifuser.queue.is_empty(){self.change_event(\u0026amp;user,\u0026amp;mutlistener_read_event(key))?;}Ok(())} User::write_cb はキューにあるメッセージを書けるだけ書くだけです。\nfn write_cb(\u0026amp;mutself)-\u0026gt; io::Result\u0026lt;()\u0026gt;{whileletSome(msg)=self.pop_message(){matchself.stream.write(msg.as_bytes()){Ok(_)=\u0026gt;(),Err(e)ife.kind()==io::ErrorKind::WouldBlock=\u0026gt;break,Err(e)=\u0026gt;eprintln!(\u0026#34;could not write message to {:?}, {}\u0026#34;,self.name,e),};}Ok(())} set_nonblocking しているのでブロックしそうになったら（＝OS内部のバッファが一杯になったら） WouldBlock が返ります。そうしたら書き出しを止めて次にバッファが空になるのを epoll_wait で待つようにします。\nざっとこういう流れで epoll を使っていきます。\nhandle_user_readable については状態を持っていてややこしいのでこの記事では触れないことにします。handle_user_closed は自明なので気にしなくていいですよね。\n書き終わったら実行してみましょう。\n動作例 サーバとクライアント2つがいるのでターミナル（A、B、C）を2つ開きます。\nまずはターミナルCでサーバを立てます。\n$ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/epoll-chat` clients connected: 0 ターミナルAでAliceをログインさせましょう。\n$ telnet localhost 8000 Trying 127.0.0.1... Connected to localhost. Escape character is \u0026#39;^]\u0026#39;. Enter your name: alice ターミナルBでBobをログインさせます。\n$ telnet localhost 8000 Trying 127.0.0.1... Connected to localhost. Escape character is \u0026#39;^]\u0026#39;. Enter your name: bob あとはなんか適当に会話するとチャットっぽくなります。 tmuxで左右分割をしたターミナルでの動作例を貼っておきます。\n$ telnet localhost 8000 │$ telnet localhost 8000 Trying 127.0.0.1... │Trying 127.0.0.1... Connected to localhost. │Connected to localhost. Escape character is \u0026#39;^]\u0026#39;. │Escape character is \u0026#39;^]\u0026#39;. Enter your name: alice │Enter your name: bob bob: hello │hello hello, I\u0026#39;m Alice │alice: hello, I\u0026#39;m Alice bob: I\u0026#39;m Bob │I\u0026#39;m Bob bob: bye │bye ^] │^] telnet\u0026gt; Connection closed. │telnet\u0026gt; Connection closed. こんな具合にチャットができます。\nまとめ IOの多重化をしてくれるEpoll APIを使ってチャットサーバを作りました。ざっくりと epoll_create で用意したfdに監視したいfdを epoll_ctl で登録し、 epoll_wait で待つループを書けば作れました。 関連するURLを貼っておきます。\n epoll-chat：今回のコード Basic non-blocking IO using epoll in Rust - zupzup：今回参考にした記事  また、Epoll APIに関連していくつか面白fdを作れるAPIが存在するようです。\n timerfd signalfd eventfd  興味のある方は触ってみて下さい。\n","categories":["Rust","Linux"],"category_urls":["/categories/rust","/categories/linux"],"date":"2021-02-01","title":"epollで作るチャットサーバ","url":"https://KeenS.github.io/blog/2021/02/01/epolldetsukuruchattosa_ba/"},
  {"body":"κeenです。最近JEITAのソフトウェアエンジニアリング技術ワークショップ2020に参加したんですが、そこで五十嵐先生、柴田さん、Matzとパネルティスカッションをしました。その議論が面白かったので個人的に話を広げようと思います。\n年末年始休暇に書き始めたんですが体調を崩したりと色々あって執筆に時間がかかってしまいました。 時間を置いて文章を書き足していったので継ぎ接ぎ感のある文体になってるかもしれませんがご容赦下さい。 というのを踏まえて以下をお読み下さい。\nいくつか議題があったのですが、ここで拾うのは一番最後の「プログラミング言語の未来はどうなるか」という話題です。 アーカイブが1月末まで残るようです。もうあと数日しかありませんが間に合うかたはご覧下さい。\n そのとき各人の回答を要約すると以下でした。\n 五十嵐先生：DSLを簡単に作れる言語というのが重要。それとプログラム検証、プログラム合成などの仕組みが普及すると楽しい。 κeen：五十嵐先生とほぼ同意見で、DSLを簡単に作れる言語。プログラム検証に興味があるのでIdrisなどの依存型のある言語とか流行るといいな。 柴田さん：これからはマルチコアをちゃんと扱えるかが重要になる。特に複雑なことをやっても破綻しない仕組み（特にメモリモデルとか）を言語側でどうにかしてほしい。 Matz：いかに自分のやりたいことを簡潔にコンピュータに伝えられるかに興味がある。また、IDEとのインタラクションによってコーディング体験を向上させるような言語設計も重要。  一応文脈を説明しておくと、五十嵐先生はFeatherlight Javaや書籍プログラミング言語の基礎概念などのプログラミング言語の基礎理論で知られる方です。 κeenは一応Rustのことを知ってそうな人として呼ばれました。 柴田さんはEffective Javaやプログラミング言語Goの和訳などで有名で、特にGoに詳しい方として呼ばれてます。 Matzは説明不要かと思いますがRubyの作者です。\nそれぞれ特色が出ていて面白いなと思ったのですが、どれも納得できる内容です。 このディスカッションが面白かったのでここから発展して、私個人の考察を色々語ります。\nプログラング言語が影響を受けるもの 新しく流行るプログラング言語が影響を受けるものをパッと思いつくも範囲で挙げてみました\n 新しいアイディア 実行環境 開発マシン 周辺環境（エコシステム） 開発する人 開発ツール 言語の開発体制 コミュニティ  上記の発言を上に当て嵌めるとすれば五十嵐先生や私の発言は新しいアイディア、柴田さんは実行環境、Matzは開発ツールですかね。\nちょっと私見を並べてみます。 私はWebプログラマなので見てる世界が偏ってることに注意して下さい。\n新しいアイディア 既存の言語にない設計で、かつそれが上手く既存の言語の問題を解決していれば使いたいですよね。 RustのライフタイムやGoのCSP（goroutineとチャネルのベースになった基礎理論）などは既存の主流の言語にはなく、かつメモリ管理や並行性といった難しかった問題にアプローチできているので使ってみようかなという気になる訳です。\n実行環境 業務用マシンでなく普通のデスクトップやノートPCでもマルチコアは当たり前になりましたよね。 しかしスクリプト言語を筆頭にマルチコアを上手く扱えない言語は未だ多くあります。 そういった課題を解決する、マルチコアを簡単に扱える言語の需要は高いでしょう。\n本来はここにスマートフォンも並べたいのですが、スマートフォンはプラットフォーマの制約が強くてあまり言語選択に自由度がないので挙げるだけ無駄ですかね。\nもう1つ、コンテナやWebAssemblyなどのある程度制限された環境での実行もあります。 となると依存の少なさやランタイムの軽さやクロスコンパイルの容易さなども重要視されるようになるかもしれません。\n開発マシン 現在は個人のデスクトップマシンやノートPCが主流ですがそのうちタブレットやスマートフォンからの開発が多くなってもおかしくありません。 するとタッチデバイスで開発しやすい言語がある程度普及するかもしれません。\n特にプログラミング言語教育や「ちょっと興味があるからプログラミング齧ってみる」という人からの需要が多いでしょう。 あるいは、プログラマでなくともプログラミングっぽいことをする（分かりやすい例だとIFTTTとか）人にも需要があるかもしれません。\n逆に、デスクトップマシンやノートPCを使い続けるならマルチコア環境が主流になります。 となるとコンパイラやLSPなどの開発サポートツールもマルチコアを使えるような設計が望まれます。\n周辺環境（エコシステム） 新しい言語が既存のエコシステムを使えると流行の初速にブーストがかかりますよね。 分かりやすい話がJVM言語とかaltJSとか。FFIでCのライブラリを呼び出せるかとか。\nあるいはWebAssemblyへのコンパイルが容易な言語としてRustが注目されていたり、Jupyter Notebookから使えるJuliaの熱が高まっていたりなんて例もあります。\n開発する人 最近の大学入試では情報系の学科の人気が高いらしいですね。 噂によるとかなり成績がよくないと情報系には入れないんだとか。 現状、プログラマには私も含めて非情報系の人間が割と多くいますが、そういう優秀な後輩達に業界が底上げされるかもしれません。 すると難しめの言語機能なんかも割とすんなり受け入れられる可能性があります。\n一方で既卒で一からプログラミングを勉強して始める人もいるでしょう。 もう少し話を広げると、プログラマでない人がちょっとだけプログラムを書くようなケースも考えられます。 そういう人にはとっつきやすい言語が人気になりそうです。\n開発ツール プログラマが当たり前に使うツールによって言語の需要が変化することもあります。 先述のディスカッションで気付いたのですが、現在はプログラミング言語側に多人数開発向けの機能とかは要求されませんよね。 GitなどのVCSを使って開発していれば困ることはそんなにないですし、そもそも色々な機能が絡まりあう実装はよくないものとされていますからね。\nそのように周辺ツールが言語へ影響することもあるようです。 例えば自動補完が当たり前になると記述の短さよりも分かりやすさが重視されるようになったり、自動補完が効きやすい設計が好まれるようになったり。 最近だとLSPなんかもあるので、言語と直接は関係ないですが、LSPを作りやすい言語設計の言語が多く登場するなんてこともあるかもしれません。\n言語の開発体制 これと次のコミュニティの項は新しい言語設計はどこからやってくるかではなく、新しい言語がどうやったら流行るかになるんですがついでなので書いておきますね。\n新しい言語を学ぶのを投資と考えると、どうせなら将来に価値が上がるものに投資したいですよね。 言語の価値が上がるのに色々要因はありますが、1つは開発リソースが挙げられます。 というか、大抵の問題は開発リソースで殴れば解決するのでリソースがほぼ全てです。 となると開発体制、もうちょっと言うとどんな企業がサポートしているかが重要なファクターになります。\nこの話を広げると企業が開発をサポートしたくなる言語が次に流行る言語ということになるんですが、私は企業それぞれの事情には詳しくないので次にいきましょう。\nコミュニティ 言語を使う人が増えるプロセスを考えましょう。 興味を持った人が処理系をインストールして、サンプルプログラムを動かしはじめ、ドキュメントや入門書を読み、小さなプログラムを書いてみて、手応えを感じたらもうちょっと使ってみて、次第に習熟してライブラリを公開したり、質問サイトやコミュニティで他の初心者を導いたりします。\nそれぞれの「興味をもつ」「処理系をインストールする」「サンプルプログラムを動かす」などのステップの間で一定数のが脱落します。 この離脱率を減らせると使う人が増えやすくなります。特に重要なのが最初、処理系のインストールやサンプルプログラムを動かすなどの部分の易しさじゃないでしょうか。 もう1つ重要なのが習熟して初心者のためになるリソースを残す層の存在です。 これは人依存なので言語開発者からしたらほぼ運ゲーですが、逆にいうと言語のユーザは自分の努力でコミュニティを大きくできるということでもあります。 コミュニティが大きくなればなるほど自身がコミュニティから受ける恩恵も大きくなるので先行投資としては悪くないんじゃないでしょうか。\n個々の言語機能への所感とか ここから前項に輪をかけて一般論というより私個人の意見が強くなるんですが「ここのあたりをこうしてほしい」とかを書き連ねていきます。\n一応触れておくと、私の考え方の根底には「プログラムはアプリケーションを書くための巨大なDSLライブラリと、そのDSLを使った小さなプログラムからなる」の思想があります。\n Lispでは，プログラムをただプログラミング言語に従って書くことはしない． プログラミング言語を自分の書くプログラムに向けて構築するのだ \u0026ndash; Paul Graham (On Lispより)\n どう書くと便利かはアプリケーションごとによって違うので、言語処理系はプリミティブだけど色々なことに使える機能を提供し、ユーザ側でそれを便利機能としてリメイクすべきという方針です。ドメイン駆動設計もドメインに集中するために外側に大きなDSLを作るので似たようなものですね。\n言語を作るにはどうしてもプリミティブな機能が必要になります。逆に、高級な機能はどうせ自分で作ってしまうのであまり必要ありません。 なので紹介する機能もどちらかというとプリミティブなものが多いです。\n並行性の扱い 上でも触れたようにマルチコアのマシンが普及するにつれ、プログラムでも並行性を扱うことが増えてきます。 並行なプログラムを書くために言語側では何が必要でしょうか。\n個人的にはpthreadの（ような）APIはよくないと思ってます。 「よし、並行なプログラムを書くぞ」と思わないとプログラムが並行にならないからです。 もっと自然に設計に並行性が入ってきてほしいです。\nつまり、並行性を提供する言語機能単体ではなく並行性を含んだ設計のフレームワークがまずあって、言語機能はそれを補助するようにできていてほしいです。 そして並行性の持ち込むバグや複雑性から守ってほしいです。\nGoのgoroutineはチャネルがある分pthreadに比べるとまだマシですが、理想からはほど遠いです。 チャネルでのやりとりが手続き的すぎます。 手続的ということは相手の状態を考えながらプログラミングしないといけません。 これでは並行性による複雑性がそのまま表出してしまいます。 もうちょっと言うと、スレッド間のやりとりに「データを送る」しかないのが不便です。 何かの処理をお願いしたいのにデータしか送れないのではいちいちお願いをデータにエンコードしないといけません。 通信プロトコルを手書きしているようなものですね。 そういうプログラミングは手間ですし、コードの見通しが悪くなります。\nそういった意味ではErlang/OTPのようなフレームワークは理想形に近いです。 機能単体ではなくフレームワークとして存在しているので自然と並行性を設計に組込めます。 しかしあれはBEAM VMだからこそ生きるフレームワークなので難しいですね。\nActorモデルを他の言語向けにアレンジするなら、インスタンスを作るときに「このインスタンスは並行に動く」と指定するとかですかね。 指定すると裏でインスタンスが別（軽量）スレッドに作られて、メソッド呼び出しはそのスレッドにメッセージが送られることになる。 これならActorモデルのメッセージパッシングとインスタンスのメソッドの呼び出しに自然に対応がとれますし、裏側の通信プロトコルを意識する必要もなくなります。 スレッドとプロセスの違いはありますがdRubyが近いかな？ まあ、スレッド間でのデータ共有はどうするのかとかの問題は残りますが大枠としてはいいんじゃないでしょうか。\nもう1つのトピックとしてデータ並列がありますが、これは簡単なものならFork Join Poolとイテレータインタフェースで割とどうにかなると思ってるのでそこまで興味はないです。 GPU使いたいとかまでくると考えものですが、それはデータ並列以前にヘテロプロセッサの扱いの問題があるのであんまり気にしなくてよいでしょう。\n非同期処理 ぐだぐだ書きましたが、実際のところ私の領域であるWebプログラミングではそんなにスレッドを気にすることはないです。 なぜならリクエスト単位での並行性というものすごく粒度も丁度いい並行性があるからです。 そういうのはWebフレームワークが解決してくれるので、プログラマはあんまりスレッドとかを気にしなくてよいです。\nどちかというとIOをどう捌くかの方が関心が高いです。 WebアプリケーションはDBや他のサービスとの通信などのネットワークを介した処理がよくあります。 そこでまともに通信が終わるのを待ってるとほとんどの時間が待ち時間で終わってしまうのでスレッドが完全に遊んでしまいます。 となるとIOでブロックしない仕組みとタスクを中断したり再開したりできる仕組みが必要になります。\nタスクを中断したり再開したりする仕組みはぼ言語のサポートが必須といっていいでしょう。 CPS変換したりステートマシンを書いたりする方法がなくはないですが、とても面倒です。 なので言語によるグリーンスレッド、あるいは便利構文のサポートか、（限定）継続が必要になります。 async/awaitがよく採用されますが、高階関数との親和性がよくないので個人的には微妙だなって思ってます。 このあたりは話すと長くなるのでこのくらいでやめておきましょう。\nIOでブロックしない仕組みは多くの場合は言語ではなくライブラリの問題です。 ただしブロックするIOとブロックしないIOは混ぜてはいけないので注意が必要です。 2つを混ぜないとなると、ブロックするIOとブロックしないIOの2系統のAPIを提供しないといけなくなります。 あるいは1系統のみに徹するか。 ここの方針の影響を受けるのが標準ライブラリの設計です。 なので広い意味での言語設計上、IOをどうしたいかは決めておく必要があります。\nIOでブロックしない仕組みを言語（ランタイム）で解決する方法もあります。 IO処理を必ずランタイムで捕捉できるようにしておけばランタイムでいかようにもできますからね。 ただし、これをやるにはタスクを中断したり再開したりする仕組みもランタイムで実装する必要があります。\n標準ライブラリを非同期のみにしたのがnode、ランタイムでIOがブロックしない仕組みを作ろうとしたのがErlangやGoですね（あとHaskellもかな？）。\nあるいはAlgebraic Effects and HandlersがあればIOでブロックする/しないはアプリケーションで制御できるし、IOは2系統に分かれないし、タスクを中断したり再開したりする仕組みも自動でついてきます。\nメモリ（リソース）管理 ここでいうGCはいわゆる古典的なMark and SweepだとかCopy GCだとかの実行時にゴミを発見して回収するシステムのことを指しています。\nガーベジコレクションはない方がいいですよね。 どんなにデータローカリティを最適化していようが、応答速度を気にしていようが、Copy on Writeを意識した作りをしていようが、GCが走ると全ての努力を無に帰します。 Hello Worldのプログラムにさえリンクされますし、アプリケーションがどんなに速くてもGCが遅ければ全体が遅くなります。 さらにはちゃんと作らないと言語に並行性を導入できませんし、並行性に耐えられるように作ってもどうしてもStop the Worldが発生します。 また、GCによるリソースの回収はタイミングが遅いのでファイルディスクリプタなんかは別途手で管理しないとならなくなります。\nこういうと「Rustを使えば解決じゃん」と言われそうですが、Rustのライフタイムによるメモリ管理は銀の弾丸ではないです。 Rustはシステムプログラミング言語だから許されるのであって他の言語でライフタイムとかを意識しながら書くのはつらいです。 Rustよりももう少し緩い仕組みが必要です。\nもう1つ、使ったメモリをそのまま再利用する仕組みがあると嬉しいです。 さっきまで使ってたメモリというのはキャッシュに載ったホットなデータなのでそのまま捨てるには惜しいです。 メモリを捨てずに別のデータを上書ける仕組み、要にはC++のplacement newのようなものをコンパイラが頑張ってやってくれたら便利ですよね。\n最悪、GCはあってもいいのですがメモリを即座に開放できる仕組みもセットで欲しくなります。 個人的に有望だなと思ってるのは以下の3つです。\n ML Kit with Regionsみたいに処理系がデータの生存期間をある程度推論して開放する仕組み C# みたいにユーザが特定の書き方をしたらメモリを即座に開放できる仕組み  C# にあまり詳しくないんですがローカル変数に null を代入したらその場で開放してくれるんですよね？  Lobster みたいにいくつかの仕組みを組み合わせて参照カウントでも安心して使える仕組み Idris 2みたいに線形型と他の型をシームレスに連携できる仕組み  実装上メモリ管理まで手が回ってるかは不明だが、原理的にはできるはず   ちょっとIdris 2の型について触れますね。 Rustみたいに値を1人しか使えないシステムの、すぐに思い付く拡張として値を高々n人しか使えないシステムがあります。 さらにnを定数ではなくパラメータ化、つまり変数ごとに「この変数は1回使う、こっちの変数は5回使う」と利用数を変えられるシステムも思い付きます。 ここで参照カウントに思いを馳せると、所有者が1人のときのみカウントの情報量がゼロになるのでRustみたいにGCレスでメモリを管理できるのが分かると思います。 つまるところ、1とそれ以外だけ区別すればよいです。 そこでIdris 2は0回使える型（メタ情報向け）、1回のみ使える型、何回でも使える型を持っています。 そして何回でも使える型は1回使える型の部分型になるので両者が共存できるのです。 …と書いてたらIdris2は0.3で利用回数（Multiplicities）の部分型付けをやめてしまった。 まあ、そのうちLinear HaskellみたいなMultiplicity Polymorphismとか入るでしょ。\nGCによって発生する問題は基本的にアロケーションの問題です。 ユーザの書き方の工夫でアロケーションを減らせたりGCが走る前にメモリを回収できるならGCによる問題はそこまで発生しません。 GC一本槍ではなくいくつかの仕組みを組み合わせたハイブリッドなシステムができるといいですね。\nメモリ解析 これは比較的コンパイラ内部の話です。だけどユーザにもちょっと関係があります。\nコンパイラってメモリが絡んだ最適化に弱いんですよね。 どのポインタとどのポイタが同じところを指しているのかとか、メモリ上の値がいつ書き変わってるのかなどを追うのが難しいからです。 とはいえメモリの絡んだ最適化ができないとどうしようもないので、コンパイラもそりなりに頑張ってはいますし、色々な手法が発明されています。 ですがCやC++のように自由にメモリを書き換えられるモデルでは原理的に全てのポインタエイリアスとかの解析を行うのはできなかったはず （もしかしたらただのNP完全だったかも）。\nRustのようにポインタの操作に制限のある言語であればかなりの部分が改善するんですが、どうしても最後の砦が残ります。 配列へのアクセスです。 実行時に計算した結果を添字に使えるのでどの要素にアクセスしているかはおろか境界外アクセスをしているかどうかさえ静的には完全には分かりません。 Rustもスライスへのインデックスアクセスは動的に境界チェックをしています（境界内であることが簡単に分かる場合には最適化で境界チェックのコードは消えます）。\nメモリアクセスの解析、特に配列のインデックスアクセスを解析できる手法が出てきたらなと思ってます。解析できれば境界外アクセスをコパイラでエラーにしたり、境界チェックのコードを省けたりします。 方針として私が思い付くのはいくつかあります。\n1つはRustのようにメモリアクセス系の操作に制限を加えた言語を作る方法です。 配列のインデックスまでケアしようとすると、今の私の知識では依存型か篩型が必要になるんですが、もしかしたらもうちょっと楽な仕組みが生れるかもしれません。 例えばシンボリック実行エンジンをユーザにも見せる設計とか（これって実質篩型と同じ？詳しい方教えて下さい）。\nもう1つはJITのように動的解析で使える情報を増やして踏み込んだ解析をする方法です。 解析した結果、最適化したり未定義動作かもよという警告が出せたら面白いですね。 境界外アクセスは、複雑な仕組みがなくても範囲チェックすれば起きていることだけは分かるのですが、「この計算で範囲外の値が出てきてるよ」って言えたら夢がありますよね。\n例外 既存の例外の仕組みってどれも便利じゃないですよね。\n例外って扱いが面白くて、コード内で関心がある部分とない部分がくっきり分かれるんですよね。 例外は何か処理をしてるときにどうにもできないことが起きたら呼び出し元に報告する仕組みです。 ですがその呼び出し元もどうしたら良いか分からなかったらさらにその呼び出し元にカスケードして報告します。 例外をどう扱えばいいか知ってる人のところまできたらその人がどうにかします。\nが、多くの言語ではそこで止まってしまいます。 本当は責任を持てる人が例外が起きた現場に指示を出して差し戻すのも必要なはずです。 例えばJSONをパースしていて、処理できない文字が出た場合に「その文字をスキップして進めなさい」「その文字をこの文字に置き換えて進めなさい」「今パースできてる分だけで処理を継続しなさい」とかの要求ができて然るべきです。 一応、 onError のコールバックを持つAPIがあることもありますが、CPS変換を手でするのはつらいというのは非同期処理で人類が既に通った道です。 例外を送出したところからリスタートする機能があると嬉しいですね。\nまた、Javaを筆頭に例外が嫌われますが、個人的にはあれは構文が重いせいと、例外を特別扱いしすぎてるせいだと思ってます。 例外を気軽に値として取り出したり、「例外を返すかもしれない関数」に対するメソッド呼び出しなどができると随分楽になると思っています。\n例外が大域脱出をするかしないかという設計の問題もあります。これは一長一短あるのでどういう言語にしたいかですね。\n先に触れたように例外処理は普通複数の関数呼び出しを越えるものだとすると、例外に大域脱出させる設計をすることになります。 大域脱出は正常系の処理に集中できるという点では良いのですが、値として取り出したりするのが難しくなります。また、例外を特別扱いすることになるので言語が複雑になります。\n言語のシンプルさを取れば大域脱出しないことになります。関数を呼び出した人がその関数で起きる例外に責任を持つというモデルですね。 大域脱出しない例外だとエラー値を取り出すのが楽になるのでエラーハンドリングはしやすくなりますが、 エラーをそのままカスケードするのは手間になります。特に無名関数などと相性が悪くなりがちです。\nこれらの問題を解決する例外システムがあればなと思ってます。 つまり、私は以下の全てを満たす例外システムがあるといいなと思っています。\n 例外を送出するのが簡単 例外を再開できる 例外を値に変換するのが簡単  特に、複数起きるかもしれない例外をちゃんと区別して扱える必要がある  「例外が起きるかもしれない関数呼び出しの結果」を第一級の値として扱える仕組み  再開できる例外はCommon Lispのコンディションシステムや、Schemeの raise-conituable なんかにあります。 あるいはAlgebraic Effects and Handlersや（限定）継続でもできそうです。\n例外を値として取り出したり「例外が起きるかもしれない関数呼び出しの結果」を第一級の値として扱える仕組みはいわゆるEitherモナドのある言語であれそのまま満たします。 ただ、エラー値をまとめたりがちょっと苦しいのでOpen Unionか多相ヴァリアントがほしいところです。 例外を送出するのはRustのように ? を持つか、Eitherモナドは扱いが簡単と言い張るかするとよいでしょう。 Eitherモナド単体はそんなに大変でもないんですが他のモナドと組み合わせたときに不便になるのだけどうにかなりませんかね。\n大域脱出する例外を値として取り出すのは結構難しいですが、Scalaの Try なんかは実現していますね。\n総合すると、2つの選択肢が見えてきます。 大域脱出しない例外を採用するならヴァリアント集合の合併などヴァリアントに対して操作ができる代数的データ型を用意した言語。 大域脱出する例外を採用するならAlgebraic Effects and HandlersとCall by nameを持つ言語か、Lisp。\n例外に対する課題意識はおおむね以下で説明されています。\n Swiftのエラーハンドリングはなぜ最先端なのか - Qiita  ただ、私は何のエラーが上がってくるか型で明示してほしいのと、例外はリスタート可能であってほしいと思っています。\nヴィジュアルプログラミング言語 テキスト形式のプログラミング言語が未来永劫のあらゆる場面ににおいて最適解とも限りませんし、そのうち新しい形式の言語も出てくるだろうと思ってます。 そのうち有望そうなのがヴィジュアルプログラミング言語です。\nここでちょっと慎重になりたいのですが、ヴィジュアルプログラミング言語は2つに分けた方が良いと思ってます。 1つがScratchのようにテキスト形式のプログラミング言語のヴィジュアルエディタになっているものです。 もう1つがViscuitのように、描いたものが動く、本当にヴィジュアルプログラミング言語になっているものです。 どっちも面白いと思ってます。\nヴィジュアルエディタはNo Code/Low Codeとかの文脈で話題ですよね。 そうでなくても目覚まし時計の設定もある意味ではプログラミングですし（某教授の受け売り）、IFTTTやBlenderのシェーダノードエディタなどの手軽にプログラミングできるエディタは多くあります。 もうちょっと本気出した例だとFF XVの開発ではプログラマがゲームを作るためのヴィジュアルエディタを開発して、ゲームデザイナがそれを使ってゲームを作ったという話などがあるでしょうか。 まさしく「プログラムはアプリケーションを書くための巨大なDSLライブラリと、そのDSLを使った小さなプログラムからなる」の好例です。 No Code/Low Codeがビジネス的に成功するかは怪しいと思ってますが、副産物としてアプリケーションを書くための巨大なDSLライブラリのヴィジュアルエディタを作るためのフレームワークが世に出てこないかなと期待しています。 DSLはまず背後にあるモデルをしっかり作り込むところがスタートラインで、それをどう見せたら書きやすいかを考えるのがDSLなんですが、どうせNo Codeとか叫ぶ人は背後のモデルとかあんまり考えずに場当たり的に言語を作って使いづらいものができあがってあんまり使われずに爆散して「プログラマ以外がコードを書くのは難しすぎた」みたいな雑な責任転嫁して終わるんでしょうと思ってます（偏見）。\nヴィジュアルエディタに期待しているもう1つの理由はスマホやタブレットの存在です。 今テキスト形式のプログラミング言語が最適とされている理由はみんなキーボードを使っているからだと思うんですよね。 ですがスマホでコードを書いてみると恐ろしく書きづらいのが分かると思います。 そうなるとタッチデバイスでの入力に最適化された言語が出てきてもいいんじゃないかと思ってます。 そして多分それはヴィジュアルエディタになるんじゃないかなーと踏んでます。 まあ、（不本意ながら）プラットフォーマ側で外部からプログラムを受け付けるアプリは禁止しているようなので簡単には普及しなそうですが、アイディアというかPoCだけでもでてきたら良いですね。\n本物のヴィジュアルプログラミング言語についてはプログラミングの可能性を模索していってほしいと思ってます。 ループと分岐だけがプログラムを書く手段ではないはずですからね。 残念ながら私にはこうなるだろうとかのアイディアはまったくないのですが、天才的ひらめきの人がいつか全く新しいプログラミング体験を提供してくれると思ってます。 そういった意味ではViscuitはあれを発想して実装して教育用途で実用してるのは本当にすごいと思います。\nメタプログラミング メタプログラミングはほぼ必須の機能だと思ってます。 マクロだとかコードジェネレータだとかの類ですね。私は両方とも必要だと思います。 ただ、色々な問題を孕むので導入に弱腰になる言語があるのも理解できます。\nコードジェネレータの場合、ビルドフローどうなるのとか（そもそもスクリプト言語ではビルドフローが存在しない場合もある）の問題があります。\nマクロの場合、ルールベースのマクロと手続マクロどっちにするかとか、自動補完とかのサポートどうなるんだっけとか、マクロの入力と出力は何（文字列？トークン？AST？コア言語？型推論前と後どっち？）とか、手続マクロでIOを許したときに再コンパイル判定どうなるのとか、手続マクロっていつコンパイルされていつどうやって実行されるのとかの問題があります。\nやっぱり外部情報（API定義やDBスキーマなど）からコードを生成するにはコードジェネレータは必要ですし、DSLを作るにはマクロが必要です。 マクロについてはLispに一日の長があるので、極論を言えば全員Lispを使えばいいんですが、Lisp相当の表現力を持ったマクロを他言語で実現するとどうなるのかには興味があります。\n他には多段階計算だとかの仕組みがありますが、どこまで有用なんでしょうね。\n形式手法 現在のソフトウェアって数個の値で動かしてみて望む結果が得られるなら正しいとされることが多いですが、それって全然正しくないですよね。 少なくとも数学の試験でそれをやったら×になります。\n別にソフトウェアテストが完全に間違ってるとは思ってませんが、テスト以外にもソフトウェアの振舞いを検証する手段があってもいいじゃんと思ってます。 もう少しちゃんと正しさを保証できる手法、数学の試験でやっても○がもらえる手法として形式手法が普及して欲しいなと思ってます。 形式手法には形式仕様記述やモデル検査など色々ありますが、私が注目しているのは定理証明、特に依存型を使った定理証明です。\n定理証明は昔からあるのにあんまり普及してないのはツールの問題があるんじゃないかと思ってます。 すなわち、プログラムを書いてるときに「あ、この部分証明できそう」と思ったら一旦そのプログラムを定理証明支援系に移植して証明してExtractするのが面倒すぎるのです。\nこれに対する反論として普段から定理証明支援系でプログラムを書けばいいじゃんというのがあります。 それで問題ないならいいんですが、定理証明支援系ってプログラムを書くのにそんなに便利じゃなくないですか？ 私が想定している証明の使い方は、普通にプログラムを書いて、普通にテストして、特に重要そうな部分は証明つけよっかってなるフローです。\nそこにきて依存型のあるプログラミング言語ならプログラムを書きつつ、気が向いたときに証明ができます。 まあ、依存型のあるプログラミング言語と定理証明支援系の本質的違いはないんですが構文や標準ライブラリの設計、利用者層の違いがあります。 特に、依存型はプログラムのパーツとしても便利なので何の気なしにプログラムを書いていたらうっかり足を滑らして定理証明をはじめてしまえるのもポイントですね。 既存の言語に依存型が入るのでも依存型のある言語が流行るのでもいいんですが、依存型を簡単に使える環境が整うと嬉しいです。\n定理証明は昨今だとブロックチェーンやスマートコントラクトの文脈でも需要があるんじゃないでしょうか。\n型 最も成功した形式手法こと型にも注目ですね。 型もある種の誤りを機械的に検出する仕組みの1つです。\n動的型と静的型の組み合わせ 型に関する話題では動的型付き言語への型の導入がホットトピックです。 TypsScriptにPythonのType HintsやRuby 3のRBS/TypeProfなど、動的型付き言語に型が導入される流れがきてますね。\nこの中でも特に成功したのはTypeScriptでしょうか。 TypeScriptが広く使われているのは私からすると意外でした。 型システムは複雑なくせに健全性（型チェックに通ったら実行時に型エラーが出ないという保証）はありません。 ビルドの手間やコンパイル時間は必要な（しかも初期の実装はかなり遅かった）のに特に実行が速くなる訳でもありません。 私が発案者だったら5秒でボツにするような仕組みが世に出され、普及するとは思いませんでした。\nTypeScriptが普及した理由が分かれば他の言語に型を導入するときのヒントになるかもしれません。 別にTypeScriptユーザじゃないですがTypeScriptが普及した理由を多少考察してみます。 語尾に「知らんけど」を補いながら読んで下さい。\n フロントエンドはJavaScriptしか選択肢がなかったので無理矢理にでも型をつけたかった altJSは色々あったが、TypeScriptは生のJSをコピペしても動くように作られていた点で優れていた 元々ビルドツールが必要だったのでワークフローへの導入が楽だった 型の健全性を気にしない人が多いか、部分的に型検査ができるだけでもありがたいような状況だった TypeScriptの型がJavaScriptを書く人のメンタルモデルによくマッチしていた  この中でも特に2番目と3番目が効いてるのかなーと思ってます。 既存のコードベースから手間なく小さく始められるというのは大事ですよね。 そう考えるとRuby（on Rails）も rake test で自動でRBS/TypeProfの検査が走るようにすれば普及しそうな気がします。\nところでTypeScriptはJavaScriptへとコンパイルできる言語ですが、PythonのType Hintsは言語仕様の拡張、RubyのRBS/TypeProfは新しいソースコードの追加です。それぞれアプローチが違って面白いですね。 Pythonの型やその検査ツールがどれだけ使われてるかは分かりませんが（そもそも私のマシンの python コマンドはType Hintsがまだ搭載されていないPython 2.7です）、Rubyの型はドキュメントやテストの一種として普及していくんじゃないかなと思ってます。 まあ、まだ初期実装の段階のようなので今後を占うには少し早いかもしれませんね（実装の完成度によって普及度が変わるため）。\n…というのが既存の言語に後から型を導入する話でした。 しかし最初からオプショナルな型を持つ言語を設計するならまた状況は変わってきます。 新しい言語なら既存のコードとの互換性を気にしなくていいので理想的な機能が入れられます。\n例えば言語仕様内に型宣言が入るでしょう。 言語仕様内に型宣言がある例だとJuliaがあります。Juliaはデフォルトで動的でありつつ型宣言も持っていますね。 オプショナルな型宣言自体は古くはCommon Lispの時代からある仕組みですが、それがちゃんと検査されることを保証している言語で市民権を得ているものは私はJuliaくらいしか知りません。\nあとは漸進的型付けも採用されるんじゃないでしょうか。 それも上に挙げた言語の型拡張のようなものではなく、正しくキャストを実装した理想的な漸進的型です。 正しいキャストとはキャストを行なった時点で動的に型チェックが行なわれ、期待しない型だった場合のその場でエラーになる仕組みです。 これは既存のコードのセマンティクスを変えないという方針のTypeScript、Type Hints、RBS/TypeProfでは実現できませんね。 理想的な漸進的型けは以下の記事を参考にして下さい。\n 漸進的型付けの未来を考える - yigarashi のブログ  もしかしたらdenoのTypeScriptサポートでキャストをちゃんと実装するかもしれません。\nあとは部分型を構造的にするか名前的にするかはどうなるんでしょうね。 というかそもそも部分型って実装されるんですかね。 クラスベースのオブジェクト指向が入れば名前的な部分型が入るでしょうし、プロトタイプベースのオブジェクト指向が入れば構造的な部分型が入るでしょう。 ただ、クラスやプロトタイプを21世紀に作られる言語が採用するかはちょっと怪しいです。\n面白型システム Rustとかで型システムで面白いことやったら面白い言語が作れるというのが知られたので、面白い型システムを搭載した言語がいくつか登場するんじゃないでしょうか。 個人的には線形型、依存型、セッション型あたりが来るんじゃないかなと思ってます。というか線形型はRustのことを考えると既に来てますね。 線形型と依存型はそれぞれメモリ管理と形式検証のところで触れたのでセッション型について触れます。\nセッション型は通信に型をつける仕組みです。 普通のチャネルを使った通信だと1種類のデータしか送れません。 ですが、セッション型を使えば「数値を送って次に文字列を送れば文字列の配列が返ってくるチャネル」のような型も表現できます。 分岐や繰り返しもあるのでそこそこ複雑な通信でもちゃんと型をつけられます。\nチャネルを使った通信が流行るならこういった仕組みも流行るんじゃないかなと思ってます。 ただ、並行性のところでも書いたように私はそもそもチャネルを使った手続き的な書き方は微妙だなと思っています。 じゃあなんでわざわざ言及したんだよっていうのは私の目指したい方向とは逆のものが流行ることの方が多いからです。\n継続 継続欲しいですよね。 プログラムを開始状態から終了状態まで状態遷移していくものと考えると、値だけを使ったプログラムはスタートからゴールに向かう方向のみの縛りで状態遷移を書いている状態です。 ですがゴールから逆順に状態遷移を書く方法があってもいいと思うんですよ。 「正常に終了するプログラムは必ずこの処理に到達する」とか「異常終了するプログラムはこういう処理をして終わる」とか書きたいじゃないですか。 グラフ探索だって初期状態だけから探索するより初期状態と終了状態の両側から探索した方が高速ですよね。 この終了状態側からプログラムを書くのが継続です。\nSchemeには継続を第一級市民として扱う機能がありますが、あまりにも貧弱です。 継続を値として扱えるのみです。継続は継続、値は値として扱えてほしいです。 $\\bar{\\lambda}\\mu\\tilde{\\mu}$ 計算ベースの言語とか出てきませんかね。 まあ、お前が作れっよて話なんですが…。\nそれとは別に、限定継続に皮を被せてとっつきやすくしたAlgebraic Effects and Handlersにも注目です。 これは既に実装した言語がいくか出ているので試そうと思えば試せます。\n koka Eff  私もそのうち試さないとですねー。\nパターンマッチ 便利なことがある程度知られてきましたしそのうち色々な言語に取り入れられるんじゃないでしょうか。 最近Rubyに入ったパターンマッチを見て気付いたんですが、パターンマッチってデータを照合するのでその言語でのデータの定義の仕方によって色々変わるんですね。 お気に入りの言語にパターンマッチが入るとしたらどんな仕様になるか考えてみるのも面白いかもしれません。 もしかしたらEgisonみたいな複雑なパターンをサポートする言語も出てくるかもしれませんね。\nプログラミング言語の未来はどうなるか 色々語ったところで、少し大胆ですがプログラミング言語の未来はどうなるかを予測してみましょう。\n既存の言語の進化 既に使われてて開発に慣性の乗ってる言語はそうそうに消えないんじゃないですかね。 とはいえ古い時代の設計のままの言語がそのままずっと通用するという訳でもないので相応のアップデートを重ねていくことになります。 Rubyに3.0でJITや並列サポートが入ったのは記憶に新しいですね。 昔はMatzが速度の問題はCPUの性能向上で解決するって言ってましたが、ここのところCPUの性能向上は頭打ちになってるので処理系側の変化が必要になる訳です。 （一応補足しておくとRubyはずっと性能改善に向き合っていて、その取り組みの一環としてJITがあります。「JITが入った」が分かりやすいマイルストーンなので取り上げました。）\nRubyに限らず「マルチスレッド上手く扱いたい」「非同期IOしたい」「インタプリタやVMじゃ限界だしJITが見えてきた」「どうやら型はあると便利っぽい」あたりはどの言語も通っていくんじゃないでしょうか。\n領域ごとの言語が増えるかも？ プログラミングをするようになった領域や、プログラムで実現したいことの幅が大きくなってきたので領域ごとに使われがちな言語が分かれるのは増えていくんじゃないですかね。 想像しやすいのは教育用言語とか、あとはスマートコントラクト用の契約言語だとか。 量子コンピュータ向け言語とか自動微分とかも夢があっていいなって思います。\nもちろん、これらの領域向けの処理も既存の汎用言語のDSLとして実現しても書けないことはないのですが、やっぱり記述が煩雑になりがちです。 それにプログラマではなくその領域のエキスパートが必要に応じてプログラムを書くようなケースを想定すると、汎用言語とDSLの両方を覚えないといけないモデルはハードルが高いんじゃないかとも思ってます。\nコンパイル時間に重点を置いた言語？ 多くの言語が機能を増やす方向に向かっていて、その結果コンパイル時間も長くなりがちです。 これが言語によっては耐えられないくらいコンパイルが遅いこともあって、コンパイル時間を理由に忌避されるケースもあるほどです。 実際、コンパイルが遅いと開発のテンポが悪くて作業が進んでる気がしないというのはよく分かります。\nそうなると、並列化などを頑張るか、機能を減らしてコンパイルが速くなるようにした言語の需要があるんじゃないかなと思います。 まあ、機能を減らした方はGoがあるんですが、機能はリッチなままコンパイラの高速化を頑張った言語はみてみたいですね。\nコンパイラって書きましたがスクリプト言語でも一緒です。 ライブラリのロード時間とかの立ち上がりが遅い処理系だと開発の手返しが悪いので速くなってほしいですよね。 まあ、これについては1ファイルにまとめるだとかバイトコンパイルだとかの目に見えた解決策があるので需要があれば実装されるんじゃないでしょうか。\n静的型つき言語の時代になるかも？ 「型はどうやら便利っぽい」「全部型を書かなくても推論できる技術があるらしい」というのが知られてきたので今後出る言語は静的に型がつくものが多くなるんじゃないでしょうか。\n型があると便利というのはバグを防ぐ仕組みというのの他に補完などのコーディング支援を受けやすいというのもあります。 どのオブジェクトのどのメソッドを呼び出してるのかが簡単に分かると嬉しいですよね。\n頑張れば動的型付き言語でもできるんじゃと思うかもしれませんが、部分的には可能でも全部は無理です。 分かりやすい例だと伝家の宝刀evalを使われるとどう頑張っても静的に解析はできません。 やるとしたら実際に実行させながら処理系に問い合わせるような仕組みになるかと思いますが、裏でDBアクセスしてメソッドを生やすようなことをやられてると難しいです。 そういったのを排除して静的に解析できる範囲だけで書こうとするなら最初から静的な解析がついている言語で書いた方が手っ取り早いですよね？\n汎用ランタイムとそれを使った処理系が出る？ 早い話がジェネリック版Goのランタイム。 ランタイムに求められるものが割と見えてきたしどっかで汎用ランタイムが作られたらそれに乗っかる処理系もできるんじゃないですかね。 ここでいうランタイムはlibgcみたいなライブラリを想定していますが、JVMみたいなVM実装もあるかもしれませんね。 今見えている範囲だとWebAssemblyのシステムインタフェース（WASI）の拡張として非同期サポートが入るとそれっぽくなるんじゃないでしょうか。\nまあこういう汎用部品は結局メインターゲットの言語が1つに絞られなくて誰が使っても微妙に便利じゃない感じになって結局誰も使わないまま終わることになりがちですが…。\nオブジェクト指向は残るんじゃないかな 最近色々言われがちですがオブジェクト指向は残るんじゃないかなと思ってます。 オブジェクト指向というか obj.method() の記法です。 あれは . をタイプしただけでデータを操作するメソッドの補完候補が簡単に出せます。 そういうツールにやさしい構文は今後生き残るでしょうし、むしろ増えていくんじゃないでしょうか。\n色々言われるというのはオブジェクト指向vs関数型の論争のことです。 個人的にはあれは論争というより話が噛み合ってないだけなんじゃないかなって思ってます。\nオブジェクト指向側はオブジェクト指向に限らない設計の原則までオブジェクト指向ととらえていて、それを使わずにプログラムを書くなんて想定できないって言ってるように見えます。 象徴的なのがオブジェクト指向入門 第2版 原則・コンセプト です。 冷静に考えて1000ページ近くもある本で説明しないといけない原則は原則として破綻しています。 あれは色々な設計の原則をオブジェクト指向風に実現するとこうなるとかの内容がほとんどです。 それなのにあの本の内容がオブジェクト指向で、オブジェクト指向を捨てるということはそれを全てしないということだなんて思ってると話が噛み合いません。\n一方、関数型側の主張はよく見るとオブジェクト指向に直接言及してることは少ないです。 「破壊的変更をすると分かりづらいよね」とか「高階関数って便利だよね」くらいのことしか言ってないことが多々あります。 まあ、たまに特定の言語というか特定の処理系のユーザが暴れ回ってることもありますけどね。 強いていうならクラスの継承とそれによる差分プログラミングはスパゲティコードになるので個人的にはよくないと思ってます。 ですがクラスと継承だけがオブジェクト指向という訳ではないですし、それさえやめてしまえば別に問題ないと思ってます。\nということでobj.method()の記法をする言語は生き残るんじゃないでしょうか。\nまとめ 最近のプログラミング言語について思っていることを吐き出しました。 人それぞれ見ている世界が違ったり異なる意見があったりするかと思います。 私もここに書いたことが全て正しいとは思ってませんし、色々な人の期待、様々な将来予想があるでしょう。 気が向いた人は5年後、10年後、あるいはもっと未来のプログラミング言語がどうなってるかの未来予想図を認(したた)めてみて下さい。\n","categories":["散文"],"category_urls":["/categories/%e6%95%a3%e6%96%87"],"date":"2021-01-04","title":"プログラミング言語の未来はどうなるか","url":"https://KeenS.github.io/blog/2021/01/04/future_of_proguramming_languages/"},
  {"body":"κeenです。 去年末にhatsugaiさんが面白い問題を出してたのでIdrisで解いてみます。\n大晦日クイズ\nP は自然数についての述語 pic.twitter.com/YfaI2QyNeS\n\u0026mdash; hatsugai ∈ PRINCIPIA (@hatsugai) December 31, 2020 \nTwitterの埋め込み画像を見れない人のためにこちらにも書くとこういう命題を証明せよという問題です。\n\\[ (\\forall n. P(n) \\implies \\exists m. m \\lt n \\land P(m)) \\implies \\lnot \\exists n. P(n) \\]\nこれは無限降下法とよばれる原理です。 自然言語で書くと、「「任意の $n$ について、 $P(n)$ ならば $m \\lt n$ なる $m$ が存在して $P(m)$ となる」ならば $P(n)$ となる $n$ は存在しない」となります。任意の $n$ について、それより小さい $m$ が存在することを保証してしまうといつかは0に辿りついて行きづまってしまうのでそんなことはありえない、すなわち $P(n)$ となる $n$ は存在しないはずですので、感覚的には正しそうです。\n数学書なんかではほぼ自明なものとしてそのまま使ってしまうことが多い（主観）のですが、ここではそれを証明しろといっています。 原理を証明というのがちょっと面白いので少し触れますね。\n数学的帰納法とペアノの公理 中学校で数学的帰納法を習ったかと思います。あれは証明しなくていいのでしょうか。 ペアノの公理の立場に立つと、数学的帰納法は公理として与えられます。つまり証明なく正しいと認めてよい原理です。\n一方他にも帰納法っぽいものはあります。 先の無限降下法の他にも $n = k$ ではなく $n \\le k$ で成り立つと仮定する完全帰納法など。 これらは公理でないので証明が必要です。 こういう帰納的な原理の証明はやはり数学的帰納法を使うことになります。\nということで今回は「普段あたり前のように使っている無限降下法の原理をちゃんと数学的帰納法で証明できますか」という問いな訳です。やってみましょう。\nIdrisによる回答 Idrisで解いてみます。\nまず証明するときの書き出しはこうでしたね。\n%default total 最初は命題をIdrisの型にエンコードします。\nところで、暗黙に P(n) なる述語が登場しましたね。Idrisのimplicit parameterで {P: Nat -\u0026gt; Type} として受け取ってもいいのですが、Idrisには文脈上定義されている値を扱う構文があるのでそれを使ってみましょう。 using(変数 : 型, 変数: 型) ... の構文です。\nP を暗黙に定義しておきましょう。\nusing(P : Nat -\u0026gt; Type) ... ... using ブロック内にある諸々の定義は勝手に using の引数にあるパラメータが追加されます。\nさて、これを用いて問題は以下のようにIdrisにエンコードできるでしょうか。\nusing(P : Nat -\u0026gt; Type) infDescent : ((n: Nat) -\u0026gt; P n -\u0026gt; (m : Nat ** (m `LT` n, P m))) -\u0026gt; Not (n: Nat ** P n) これを解いていきましょう。方針としては (n: Nat) -\u0026gt; P n -\u0026gt; (m : Nat ** (m `LT` n, P m)) と (n: Nat ** P n) を仮定して矛盾を証明すればいいのは分かりますね。 本体の書き出しはこうなりそうです。\ninfDescent h (n ** pn) = ... ここで、 h を即座に n と pn に適用できてしまうので with 構文でひとまとめにやってしまいましょう。こうなります。\ninfDescent h (n ** pn) with (h n pn) infDescent h (n ** pn) | (m ** (smaller, pm)) = ... h: (n: Nat) -\u0026gt; P n -\u0026gt; (m : Nat ** (m `LT` n, P m)) 、 n: Nat 、 pn: P n 、 m: Nat 、 smaller: m `LT` n 、 pm: P m で証明していきます。\n安直にはそのまま再帰して infDescent h (m ** pm) とやっていくとよさそうな気がしますが、これではIdrisが許してくれません。 Idrisコンパイラに m `LT` n という情報が伝わってないので無限ループとみなされてしまいます。 そもそものことを思い出してもらうと、数学的帰納法で証明する必要がありそう、という考察があるのでした。 n か m 、あるいは両方で帰納法を回せないか考えましょう。\nn （または m） で帰納法を回そうとすると P n の存在がやっかいなことに気付きます。 n = S n' として取り出すと、 P n' が成り立たない（成り立つとは限らない）ので仮定が使えなくなります。\n私自身これでかなり悩んだのですが、結論をいってしまうと P n を捨てると上手くいきます。すなわち以下のような補題を定義してそれを使えば簡単に証明できるのです。\ninfDescent h (n ** pn) | (m ** (smaller, pm)) = lemma n m smaller pm where lemma : (n : Nat) -\u0026gt; (m : Nat) -\u0026gt; m `LT` n -\u0026gt; P m -\u0026gt; Void ... この補題を証明していきましょう。 方針としては、仮定の (n: Nat) -\u0026gt; P n -\u0026gt; (m : Nat ** (m `LT` n, P m))を使って m をどんどん小さくしていきます。ですがこれだけではIdrisが納得しないのは既に説明した通りです。そこで n も1ずつ小さくしていきます。 仮定を適用する度に l \u0026lt; m \u0026lt; n な l が取得でき、これは l \u0026lt; n - 1 も成り立つので次のサイクルにいけます。 要は n で帰納法を回す訳ですね。\nそれでは n で帰納法を回していきましょう。 n = Z の場合、 m `LT` n なる m は存在しないので矛盾します。\nlemma : (n : Nat) -\u0026gt; (m : Nat) -\u0026gt; m `LT` n -\u0026gt; P m -\u0026gt; Void lemma Z m contra pm = uninhabited contra ... n = k で成り立つ（lemma k ... の呼び出しはできる）と仮定して n = S kの場合を証明します。 S k と m \u0026lt;= k の関係（smaller）が取り出せます。\nlemma (S k) m (LTESucc smaller) pm = そして仮定を使って l \u0026lt; m なる l で P l を満たすものが取得できます。\nlet (l ** (lIsSmallerThanM, pl)) = h m pm in すると l \u0026lt; m \u0026lt;= k の関係により l \u0026lt; k が証明できます。\nlet lIsSmallerThanK : (l `LT` k) = lteTransitive lIsSmallerThanM smaller in あとは n = k で成り立つという仮定を使って証明完了です。\nlemma k l lIsSmallerThanK pl まとめると証明全体はこうなります。\n%default total using(P : Nat -\u0026gt; Type) infDescent : ((n: Nat) -\u0026gt; P n -\u0026gt; (m : Nat ** (m `LT` n, P m))) -\u0026gt; Not (n: Nat ** P n) infDescent h (n ** pn) with (h n pn) infDescent h (n ** pn) | (m ** (smaller, pm)) = lemma n m smaller pm where lemma : (n : Nat) -\u0026gt; (m : Nat) -\u0026gt; m `LT` n -\u0026gt; P m -\u0026gt; Void lemma Z m contra pm = uninhabited contra lemma (S k) m (LTESucc smaller) pm = let (l ** (lIsSmallerThanM, pl)) = h m pm in let lIsSmallerThanK : (l `LT` k) = lteTransitive lIsSmallerThanM smaller in lemma k l lIsSmallerThanK pl 余談 無限降下法は数学的帰納法と同値らしいです。\n数学的帰納法と同値なのでそれほど難しくないけど、定理証明支援系でやると少し面倒だった。もっといい方法があるかもしれない。\n\u0026mdash; hatsugai ∈ PRINCIPIA (@hatsugai) December 31, 2020 \n今数学的帰納法を使って無限降下法を証明したので、無限降下法を使って数学的帰納法を証明すれば同値であることの証明になります。 無限降下法は否定の証明なので Not (P n) を証明することにして以下を証明すればよいでしょう。\nnatInd : Not (P Z) -\u0026gt; ((k: Nat) -\u0026gt; Not (P k) -\u0026gt; Not (P (S k))) -\u0026gt; Not (n: Nat ** P n) 数学的帰納法の帰結は (n: Nat) -\u0026gt; Not (P n) ですが Not (n: Nat ** P n) としても同値なので無限降下法の帰結にあわせて変えました。\nこれを再帰を使わずに infDescent を使って証明しようとしたんですが、難しいのでやめました。 無限降下法の仮定で (n: Nat) と P n を得ても、数学的帰納法の仮定が (k: Nat) -\u0026gt; Not (P k) -\u0026gt; Not (P (S k)) なので何もできないんですよね。 もちろん帰納法の仮定を P Z に n 回適用して Not P n を作ることはできるんですがそれって数学的帰納法と同じことをやってるので無意味ですし（それやるなら直接 Not (n: Nat ** P n) を作った方が早い）。\nうまく証明できる方は教えて下さい。\n追記 形式証明のプロから排中律が必要そうとの示唆をもらいました。\n数学的帰納法で無限降下法を証明するのは直観主義論理でできそうに見えるけど，逆はなんか排中律要りそうな気がする（完全に見た目だけで判断しています）\n\u0026mdash; . (@fetburner) January 1, 2021 \n排中律を仮定して証明しましょう。\nlawOfExcludedMiddle : {A: Type} -\u0026gt; Either A (Not A) lawOfExcludedMiddle = believe_me \u0026#34;axiom\u0026#34; すると以下のように再帰を使わずに証明できます。\nnatInd : (P : Nat -\u0026gt; Type) -\u0026gt; Not (P Z) -\u0026gt; ((k: Nat) -\u0026gt; Not (P k) -\u0026gt; Not (P (S k))) -\u0026gt; Not (n: Nat ** P n) natInd P npz step = infDescent sub where sub : (n: Nat) -\u0026gt; P n -\u0026gt; (m : Nat ** (m `LT` n, P m)) sub Z pz = absurd $ npz pz sub (S k) psk = case lawOfExcludedMiddle {A = P k} of Left pk =\u0026gt; (k ** (lteRefl, pk)) Right npk =\u0026gt; absurd $ (step k npk) psk プロの直感ってすごいですね。\nまとめ 素朴な数学的帰納法を使って発展的な無限降下法を証明しました。 見た目の異なる原理を数学的帰納法に乗せるのは意外と頭を使ったので完全帰納法の証明とかもやってみて下さい。\n","categories":["Idris","証明"],"category_urls":["/categories/idris","/categories/%e8%a8%bc%e6%98%8e"],"date":"2021-01-01","title":"Idrisといくつかの帰納法","url":"https://KeenS.github.io/blog/2021/01/01/idristoikutsukanokinouhou/"},
  {"body":"κeenです。2021注目していきたい技術、やっていきたいことを書いておく。\nIdris Advent Calendar用のプログラムとか書いているうちにそこそこ深堀できたのでもうちょっと継続してみると見えてくるものがありそう。\nそれとは別にIdris2もある。まだ開発段階で試すには早そうだけど年内に動きがあったら触ってみようかな\nCloudronとNextCloud NextCloudはいわゆるオウンクラウドの1つ。 Dropbox的なストレージとかの機能を提供する。 CloudronはNextCloudを含めた色々なアプリを簡単に管理できる代物。\n最近Googleのアカウントbanの雑さに嫌気がさして脱Googleを進めていて、その一環としてストレージを自分でコントロールできるところに確保しておきたい。\n今のところDropBoxで困ってないんだけど備えあれば憂いなしということで準備しておきたい。あと単純に自分でホストするって夢あるじゃないですか。\nCloudronで管理できるアプリも色々あってそれも試したい。Mastodon（オープンソース版Twitter）とかMatrix（オープンソース版Slack）とか。 メールはさすがにやめといた方がいいかな…。\nマルチメディア 去年はInkscapeとかBlenderとかShotCutとか触ったので実を結ぶまでもうちょっと触ってみてもいいかなと思ってる。特に何をしたいとかはないけどチャンスがあれば積極的に使っていく方向で。今のところ勉強会用の動画を作って、それに多少の編集を加える需要はある。\nBlenderにSVGをインポートする機能があるっぽいのでそれでアニメーションとか作れると楽しそう。\nそういえばWebAudioも触ったんだった。あんまり興味はないけど動画作るにあたって音は必要だし何かやるかも…？\n新しい言語 最近全然新しい言語を触ってないのでそろそろ何かやらなきゃなと思っている。 Algebraic Effectに寄せてKokaかEffをやるか、TLで話題のJuliaやElmあたりをやるか。 フロントエンドは興味ないしJuliaかなと思いつつ別に数値計算にもあんまり興味はない。あ、でも多段階計算があるのは面白そう。\nio_uring ファイルIOを非同期化してくれるシステムコール（とそのラッパライブラリ）。 Rust的にも非同期で盛り上がってて、io_uringを使う流れがきてるし個人的に試しておきたい。まあ、まだepollも触ったことないんですけどね。 遊びで非同期ランタイム作ってみるのがいいかな？\n生物学？ ゆるふわ生物学チャネルのおかげで（マクロ）生物学に興味湧いたしちょっとは勉強してみようかな。ひとまずキャンベルとか。\nスマブラ このあいだ見たらプレイ時間が1000時間越えてた。 ずっとVIPしかやってないけどそろそろオンラインレーティングサイトとか大会とかのコミュニティに首つっこんでもいいかなと思ってるところ。\nWebML 作りかけのコンパイラ。 ちょっとずつ開発進められたらいいですね。 リファクタとか派生形式のやっつけとかいろいろあるけど、メモリレイアウト系を決定できたらなと思う。そこが決まれば文字列もGCも進む。\n今年は執筆とか講演とかの時間のかかるプロジェクトをできるだけせずに好き勝手遊べる時間を確保できるといいな。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2021-01-01","title":"2021年抱負","url":"https://KeenS.github.io/blog/2021/01/01/2021nenhoufu/"},
  {"body":"κeenです。何もしてないのにパソコン壊れた。 まだ直ってないけどこの記事書かないと1年が締まらないのでノートPC引っ張り出してブログを書く。\n2020年の抱負を振り返り Async Rust 大きな話題としてはTokio 1.0がリリースされた。 まだコミュニティの趨勢は決まってないけどtokioに寄っていきそうな雰囲気を感じる。 仕事で書いてるコードも async / await に移行したし個人的には非同期元年といってよい。\nWebAssembly/WASI WASMのExceptionはまだドラフトのままだけど、自作コンパイラをブラウザで動かすというネタを消化できたので満足。 あとはWASMのコードをローカルで動かしてテストするというのもやった。\nWASIについてもmozillaのWASMランタイムチームがfastlyに統合されるということで動きがあった。\nWebAuthn いくつかのサービスで実際に認証機能として実装されているけど個人的には試してない。\n情報幾何 一応情報幾何の基礎は読んだけどあまり咀嚼できてない。 もう一回読み返すか別の本で別の視点からも眺めるのをやった方がよさそう。\nSVG スライドにSVGを入れるのは試した。 DOMやアニメーションで動かすのは年末にやろうとしたらPCが壊れたので年明けにPCが直ってたらやる。\nInkscapeでスライド作るのは調べたけど茨の道っぽかった。\nBlender Blender 2.80対応の入門書を買ってちまちまやってる（半分ちょいくらい進んだ）。 まだ大したモデリングとかはやってないけどそのうち進捗あるといいですね。\n運動再開 リングフィットアドベンチャー買ったしそれでいいってことでどうですか。\n個人的振り返り メトリクス ブログ記事53本、スライド5綴、mendeleyに入れた論文30本、買った技術書は数えるの面倒だからいいや、GitHubのcontribution 2294。その他のメディアへの投稿が多少。\n総括 ブログ記事はIdris Advent Calendarのブーストのおかげで多いように見えるけどそれを除いたら活動は控え目だったかな。 原因としてはBlenderの手習いのように成果に出ない活動があったのと、ラムダノートで書いてるパターンマッチの続きを世に出せなかったのかな。あとゲーム（スマブラ）やりすぎ。\nラムダノートで書いてるパターンマッチのコンパイルの本は量を書きすぎてn月刊に載せられないと言われたので一旦凍結してる。 n月刊に合わせなくていいならもうちょっと内容増やすかもしれない。これ読んで喜ぶ人がどのくらいいるかは分からないけど…。\n外に見える活動だと、カジュアルな勉強会じゃない講演が2つあった。RustFest.GlobalとJEITAのソフトウェアエンジニアリング技術部会のワークショップ。 こういうところの講演は事前準備にけっこう時間を使うのでどう向き合っていくかは考えた方がよさそう。 数をこなして効率を上げるか、断るか、妥協するか。とはいえ指名で依頼がくるのはすごく嬉しいことなのであんまり断りたくないし、頑張る方向かな。\nBlenderとかSVGとか、講演の動画を撮影/編集したりとかマルチメディアを扱うことが多かった。今まで自分に作れなかったものを作れるようになるのは楽しいので来年はこの領域をもうちょっと深堀してみようかな。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2020-12-31","title":"2020年振り返り","url":"https://KeenS.github.io/blog/2020/12/31/2020nenfurikaeri/"},
  {"body":"この記事は去年末に書いていた記事です。 執筆中にパソコンがクラッシュして修理に1ヶ月くらいかかったので公開が遅くなりました。 それを踏まえて記事をご覧下さい。\nκeenです。 そろそろAdvent Calendarも終盤になってきましたね。 今回は前回の標準ライブラリ紹介であえて外したモナドについて紹介します。\nMonad（ や Applicative ）には便利な記法が用意されているのである型がモナドを実装しているかどうかは大きな関心ごとになります。 また、「モナド」として提供されている型もあるのでそれらについて紹介していきます。 例によってpreludeとbaseの中から紹介していきます。\nPrelude.List おなじみですね。\n以下のコードは九九の計算を全部やります。\ndo x \u0026lt;- [1..9] y \u0026lt;- [1..9] pure $ x * y 熟語括弧（idiom brackets）を思い出してもらうと、以下のコードでも同等です。\n[| [1..9] * [1..9] |] Prelude.Maybe Just 側の値を取り出します。1つでも Nothing があると即座に Nothing になります。\ndo { x \u0026lt;- Just 1 ; y \u0026lt;- Just 2 ; pure $ x + y } -- Just 3 : Maybe Integer do { x \u0026lt;- Nothing ; y \u0026lt;- Just 2 ; pure $ x + y } -- Nothing : Maybe Integer do { x \u0026lt;- Just 1 ; y \u0026lt;- Nothing ; pure $ x + y } -- Nothing : Maybe Integer Prelude.Either Either は本来なら左と右が対等な関係にあるのですが、Haskellからの伝統で左がエラーの値、右が正しい値として使われています。 右側を優先するという規約の下 Either はモナドを実装していて、右側の値を取り出せます。\ndo x \u0026lt;- Right 1 y \u0026lt;- Right 2 pure $ x + y -- Right 3 : Either String Int 複数の Left があった場合は最初の Left のエラーが優先されます。\ndo x \u0026lt;- Left \u0026#34;First error\u0026#34; y \u0026lt;- Left \u0026#34;Second error\u0026#34; pure $ x + y -- Left \u0026#34;First error\u0026#34; : Either String Int Prelude.Stream Stream はちょっとトリッキーです。 Stream の前に List の動作を確認しておきましょう。\nList の場合は二重 for 文のように最初のリストの要素に対して次のリストの要素のリストを繰り返していきます。\nIdris\u0026gt; do { x \u0026lt;- [0..3]; y \u0026lt;- [0..3]; pure (x, y) } [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3)] : List (Integer, Integer) Stream ではこれはできません。 何故なら Stream は無限に続くことがあるので2番目の要素の繰り返しが終わらず、最初のリストの要素が1つしか取り出されないからです。\nそこで Stream は全ての要素を同時に取り出します。 実例をみてみましょう。 cycle で [0, 1, 2, 3, 0, 1, 2, ...] と無限に続くストリームを2つ作り、 そこから do 記法で取り出したものをペアにして最初の10個取り出してみます。\nIdris\u0026gt; take 10 $ do { x \u0026lt;- cycle [0..3]; y \u0026lt;- cycle [0..3]; pure (x, y) } [(0, 0), (1, 1), (2, 2), (3, 3), (0, 0), (1, 1), (2, 2), (3, 3), (0, 0), (1, 1)] : List (Integer, Integer) すると List とは異なりそれぞれの要素が順番に取り出されています。 下の表でいう対角線上の要素が取り出されているのです。\n    0 1 2 3     0 (0, 0) (0, 1) (0, 2) (0, 3)   1 (1, 0) (1, 1) (1, 2) (1, 3)   2 (2, 0) (2, 1) (2, 2) (2, 3)   3 (3, 0) (3, 1) (3, 2) (3, 3)    Data.Vect Stream と同じく対角成分をとります。\ndo x \u0026lt;- [1, 2, 3] y \u0026lt;- [1, 2, 3] pure (x, y) -- [(1, 1), (2, 2), (3, 3)] : Vect 3 (Integer, Integer) 注意しないといけないのは Vect k がモナドになっている点です。 ベクタの長さ k まで含めているので、モナドとして扱っている途中で長さを変えられません。 つまり全て同じ長さのベクタでないと do 文で使えないのです。\nData.Morphism, Control.Arrow 略。「Haskell Arrow」とかのワードで調べるとると色々出てきます。 ざっくりいうと関数を組み合わせるときに一時変数を使わずにパイプを繋ぎ合わせるようなやり方で合成するフレームワークです。\nControl.Monad.Reader ようやくモナドらしいモナドがでてきました。 Reader は文脈から値が取り出せるモナドです。 以下の3つのAPIがキーになります。\nReader : Type -\u0026gt; Type -\u0026gt; Type ask : Reader r r asks : (r -\u0026gt; a) -\u0026gt; Reader r a local : (r -\u0026gt; r) -\u0026gt; Reader r a -\u0026gt; Reader r a Reader r a と書いて 「文脈から r の値を取り出せる a の計算」です。 普通に計算しつつ、 r の値がほしくなったら v \u0026lt;- ask と書くと文脈から値を取り出せます。 「文脈」ってなんだよって話ですが、まあ、感覚で理解して下さい。\n四の五のいわずに実例を出しましょう。 Reader は任意の場所で値を取り出せるということで、Dependency Injectionや設定を渡すのに使われます。 ここでは設定を渡す例を挙げましょう。\nまず設定を定義しておきます。\nimport Control.Monad.Reader record Config where constructor MkConfig width : Nat 設定に基いて指定された横幅にそろえる関数 format: String -\u0026gt; Reader Config String を定義します。 Reader Config String になっているので String を返しつつ Config を読み出せます。\nformat: String -\u0026gt; Reader Config String format s = do config \u0026lt;- ask let pad = pack $ replicate (minus (width config) (length s)) \u0026#39; \u0026#39; pure $ pad ++ s config \u0026lt;- ask の部分ですね。Reader のAPIの ask の型が Reader r r なので \u0026lt;- すると Reader のもっている r の値が読み出せるのが分かるかと思います。\nこの関数を使ってみたいのですが、その前に便利関数を定義しておきましょう。 後程説明しますが Reader はちょっと入り組んだ構造になってるのでAPIも複雑になってます。 それを緩和するコードです。\nrunReader : Reader r t -\u0026gt; r -\u0026gt; t runReader m r = runIdentity $ runReaderT m r Reader モナドを走らせる関数です。モナドと Reader で読み出す値を渡して、モナドを走らせます。 ライブラリ側で提供してしかるべき関数なんですがなぜかないので自分で定義します。\nそれでは format を走らせてみましょう。\nIdris\u0026gt; runReader (format \u0026#34;Hello\u0026#34;) (MkConfig 10) \u0026#34; Hello\u0026#34; : String runReader での与えた (MkConfig 10) を読み出して横幅10にフォーマットしていますね。\nask で読み出す値は最初に runReader で与えたもので固定されます。 これが文脈といってるやつですね。一時的にこの値を上書きするのが local です。\nControl.Monad.Writer Reader の逆で文脈に値を書き出せます。\nWriter : Type -\u0026gt; Type -\u0026gt; Type tell : w -\u0026gt; Writer w () listen : Writer w a -\u0026gt; Writer w (a, w) listens : (w -\u0026gt; b) -\u0026gt; Writer w a -\u0026gt; Writer w (a, b) pass : Writer w (a, w -\u0026gt; w) -\u0026gt; Writer w a censor : (w -\u0026gt; w) -\u0026gt; Writer w a -\u0026gt; Writer w a ただし Writer の w には Monoid の制約がついています。\nMonoid w =\u0026gt; Monad (Writer w) 例えば List String から List Integer へ変換する関数を書くとしましょう。 中には変換に失敗する値もあります。 そういうときに Writer を使えば失敗した値を記録しつつ成功したものだけ集めることができます。\nimport Control.Monad.Writer import Data.String tryConvert : List String -\u0026gt; Writer (List String) (List Integer) tryConvert [] = pure [] tryConvert (x::xs) = case parseInteger x of Just i =\u0026gt; map (i::) (tryConvert xs) Nothing =\u0026gt; do -- 失敗した値を書き出す tell [x] tryConvert xs tell を使っている部分が Writer モナドに値を書き込んでいるところです。\n実行してみましょう。 Writer には runWriter があります。\nIdris\u0026gt; runWriter $ tryConvert [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;] ([1, 2, 3], []) : (List Integer, List String) Idris\u0026gt; runWriter $ tryConvert [\u0026#34;1\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;3\u0026#34;] ([1, 3], [\u0026#34;two\u0026#34;]) : (List Integer, List String) タプルで成功した値と失敗した値が返ってきていますね。\nControl.Monad.State State は状態を持ち回るモナドです。 get で読み出し、 put で書き出しができます。\nState : (stateType : Type) -\u0026gt; (ty : Type) -\u0026gt; Type get : State stateType stateType gets : (stateType -\u0026gt; a) -\u0026gt; State stateType a put : stateType -\u0026gt; State stateType () modify : (stateType -\u0026gt; stateType) -\u0026gt; State stateType () 同じ State s を使い回してる限りにおいてグローバル変数のように使えます。\nこれも実例を出しましょう。 疑似乱数のコードです。 疑似乱数は乱数の状態を更新してまわる必要がありますね？\nimport Data.Bits data Rand = RandomState Bits64 seed : Rand seed = RandomState 88172645463325252 infixl 7 ^, \u0026lt;\u0026lt;, \u0026gt;\u0026gt; nextRand: Rand -\u0026gt; (Bits32, Rand) nextRand (RandomState x) = let x = x ^ (x \u0026gt;\u0026gt; 13) in let x = x ^ (x \u0026lt;\u0026lt; 7) in let x = x ^ (x \u0026gt;\u0026gt; 17) in let ret = (x \u0026lt;\u0026lt; 32) \u0026gt;\u0026gt; 32 in (prim__truncB64_B32 ret, RandomState x) where (^): Bits64 -\u0026gt; Bits64 -\u0026gt; Bits64 (^) = xor\u0026#39; {n = 8} (\u0026lt;\u0026lt;): Bits64 -\u0026gt; Bits64 -\u0026gt; Bits64 (\u0026lt;\u0026lt;) = shiftLeft\u0026#39; {n = 64} (\u0026gt;\u0026gt;): Bits64 -\u0026gt; Bits64 -\u0026gt; Bits64 (\u0026gt;\u0026gt;) = shiftRightLogical\u0026#39; {n = 8} nextRand: Rand -\u0026gt; (Bits64, Rand) の型がそれです。 Rand を受け取って Rand を返していますね。 Rand を受け取ったり次の関数に回したりは面倒です。 これは State Rand を使うと解決します。\ngetRandom: State Rand Bits32 getRandom = do rand \u0026lt;- get let (i, rand) = nextRand rand put rand pure i このAPIにしてしまえば乱数の状態を気にすることなく乱数を使う関数が書けます。\ngetRandomPair : State Rand (Bits32, Bits32) getRandomPair = do x \u0026lt;- getRandom y \u0026lt;- getRandom pure (x, y) State には実行する関数が3つあります。実行の結果と持ち回った状態をそれぞれ返すか返さないかでの変種です。\nrunState : State stateType a -\u0026gt; stateType -\u0026gt; (a, stateType) evalState : State stateType a -\u0026gt; stateType -\u0026gt; a execState : State stateType a -\u0026gt; stateType -\u0026gt; stateType 今回は乱数の状態は捨てることにして evalState を使ってみましょう。\nevalState getRandomPair seed -- (D212EB9E, C7E45E25) となるはずです。\nところがREPLで試すと最後まで計算してくれず、巨大な式が表示されます。 これはIdrisのREPLがコンパイラではなくHaskellのインタプリタで実装されていることによる限界です。 仕方ないのでコンパイラにコンパイルしてもらって実行しましょう。\nIdris\u0026gt; :exec printLn $ evalState getRandomPair seed これならちゃんと (D212EB9E, C7E45E25) と表示されます。\nControl.Monad.Trans 複数のモナドを組み合わせたいことがあります。 例えばIOでファイルを処理しつつその結果をWriterに記録するなど。 そういうときに愚直に書くととても大変なことになります。\n実際のコードを見てみましょう。 標準入力から1行読んで Writer に記録するコードです。\nreadLine : IO (Writer (List String) Integer) readLine = do line \u0026lt;- getLine pure $ do tell [line] pure 1 やりたいことは単純なのに do がネストしていてやっかいですね。 両方ともモナドなので1つの do で書けると嬉しいですよね。 そこで2つのモナドの合成っぽいことをしたくなります。\nモナドの合成のようなことをするのがモナドトランスフォーマ（モナド変換子）です。 あるモナドAを、別のモナドBも混ぜた新しいモナドABに変換します。\n先程のコードはモナドトランスフォーマを使うと楽に書けるようになります。\nreadLine\u0026#39; : WriterT (List String) IO Integer readLine\u0026#39; = do line \u0026lt;- lift getLine tell [line] pure 1  WriterT モナドトランスフォーマで IO モナドを変換する  WriterT (List String) IO が新しいモナドになる  IO モナドのアクション getLine は lift することで do 内で使えるようになる  モナドトランスフォーマはTで終わる名前をつけるのが慣習です。 いくつかモナドトランスフォーマに関連する話題を並べておきます。\n モナドトランスフォーマはモナドに適用され、結果モナドになるのでモナドトランスフォーマを重ね掛けすることができる  モナドトランスフォーマスタックとも呼ばれる  全てのモナドがモナドトランスフォーマとしても実装できる訳ではない  できるなら勝手にやってしまえばいいのでトランスフォーマという概念を持ち出すまでもない  モナドトランスフォーマスタックの底には（もし使うなら） IO モナドを置くのがベストプラクティス  モナドトランスフォーマそのものについてはかなり深いトピックなのでここでは紹介するだけに留めて詳しい解説はWeb上にある記事に譲ることにします（私が詳しくないとも言う）。\nControl.Monad.Identity モナドトランスフォーマに関連する重要なモナドが Control.Monad.Identity で定義されている Identity モナドです。 Identity a は何も意味のあることをしません。 a を直接使うのとほとんど変わりません。\nIdentity は何もしないのでモナドトランスフォーマと組み合わせて使うとモナドトランスフォーマの方の機能だけを使うことができます。 すなわち WriterT w Identity a と Writer w a が同じ機能になるのです。\nIdentity があれば任意のモナドトランスフォーマをモナドにできるので、モナドでもモナドトランスフォーマでも実装できるものはモナドトランスフォーマで実装してしまえば、それを Identity に適用するとモナドも得られるのです。\n実際、 Reader や Writer はまずモナドトランスフォーマとして定義されていて、それを Identity に適用したものになっています。\n-- Reader Reader : Type -\u0026gt; Type -\u0026gt; Type Reader r a = ReaderT r Identity a -- Writer Writer : Type -\u0026gt; Type -\u0026gt; Type Writer w a = WriterT w Identity a -- State State : (stateType : Type) -\u0026gt; (ty : Type) -\u0026gt; Type State = \\s, a =\u0026gt; StateT s Identity a まとめ Idrisの標準ライブラリにあるモナドを紹介しました。 これらは基本的な道具なのでみなさん道具箱の中に入れておいて下さい。\n","categories":["Idris"],"category_urls":["/categories/idris"],"date":"2020-12-29","title":"Idrisモナドアソート","url":"https://KeenS.github.io/blog/2020/12/29/idrismonadoaso_to/"},
  {"body":"このエントリはML Advent Calendar 2020の17日目の記事です。空いてるのも寂しいので埋めます。\nタイトルの通りなんですが、もうちょっと説明しますね。 まず「処理系組み込み」は実装によるので正しくないです。 厳密にいうと仕様に載っている例外ですね。 SML \u0026lsquo;97のAppendix C, DにInitial Basisが載っていて、そこで定義されている例外はなんでしょうというクイズです。\nこれは知識でも解けますが、落ち着いてよく考えると導き出せます。 例えば Subscript は配列の境界外アクセスのときに出る例外ですがそれって仕様で必要なんだっけ…とか。\n答えは\n Bind と Match です。それそれ val と case (fn) でパターンマッチに失敗したときにでる例外です。 - val NONE = SOME 1;; uncaught exception Bind [nonexhaustive binding failure] raised at: stdIn:1.6-1.19  - case NONE of SOME x = x;; stdIn:1.2-1.26 Warning: type vars not generalized because of value restriction are instantiated to dummy types (X1,X2,...) stdIn:1.2-1.26 Warning: match nonexhaustive SOME x = ... uncaught exception Match [nonexhaustive match failure] raised at: stdIn:1.26  これらはSMLの文法に組込まれているのでどうしようもないですね。 ","categories":["ML","ML Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/ml","/categories/ml-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-28","title":"SMLの処理系組み込み例外ってなーんだ","url":"https://KeenS.github.io/blog/2020/12/28/smlnoshorikeikumikomireigaittenanda/"},
  {"body":"κeenです。俺たちのAdvent Calendarはまだまだ続くぜ！ Idrisの標準ライブラリ、preludeとbaseをサクっと解説していきます。\nprelude Builtins コンパイラから特別扱いされている型などが入っています。\n例えば () に対応する Unit 型や (A, B) に対応する Pair 型など。\nまだ紹介していないものをいくつか紹介しましょう。\n replace : {a:_} -\u0026gt; {x:_} -\u0026gt; {y:_} -\u0026gt; {P : a -\u0026gt; Type} -\u0026gt; x = y -\u0026gt; P x -\u0026gt; P y x = yならば P x を P y に書き換えられるよね。 sym : {left:a} -\u0026gt; {right:b} -\u0026gt; left = right -\u0026gt; right = left 等式の左右を入れ替える。 rewrite sym $ ... in ... の形で使うことが多い Inf : Type -\u0026gt; Type （遅延した）無限の計算を表わす。Stream ででてくる。  IO IOモナド関連の内部実装。直接お世話になることは少ないですかね。\nPrelude.Algebra 2つのインタフェースが定義されています。\ninterface Semigroup ty where (\u0026lt;+\u0026gt;) : ty -\u0026gt; ty -\u0026gt; ty interface Semigroup ty =\u0026gt; Monoid ty where neutral : ty それぞれ半群とモノイドです。\n特に Semigroup に定義されている二項演算は強力で、リストの結合など、色々な操作を抽象化しています。\nIdris\u0026gt; [1, 2, 3] \u0026lt;+\u0026gt; [4, 5, 6] [1, 2, 3, 4, 5, 6] : List Integer Prelude.Functor ファンクタが定義されています。\ninterface Functor (f : Type -\u0026gt; Type) where map : (func : a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b Prelude.Applicative 既に紹介した Applicative が定義されています。\ninfixl 3 \u0026lt;*\u0026gt; interface Functor f =\u0026gt; Applicative (f : Type -\u0026gt; Type) where pure : a -\u0026gt; f a (\u0026lt;*\u0026gt;) : f (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b もう1つ重要なのが、 Alternative です。\ninfixr 2 \u0026lt;|\u0026gt; interface Applicative f =\u0026gt; Alternative (f : Type -\u0026gt; Type) where empty : f a (\u0026lt;|\u0026gt;) : f a -\u0026gt; f a -\u0026gt; f a 例えば Maybe のように失敗するかもしれない計算上で || 演算子のような働きをします。\nIdris\u0026gt; Just 1 \u0026lt;|\u0026gt; Just 2 Just 1 : Maybe Integer Idris\u0026gt; Just 1 \u0026lt;|\u0026gt; Nothing Just 1 : Maybe Integer Idris\u0026gt; Nothing \u0026lt;|\u0026gt; Just 1 Just 1 : Maybe Integer Idris\u0026gt; the (Maybe Int) Nothing \u0026lt;|\u0026gt; Nothing Nothing : Maybe Int 他には guard や when などの処理もあります。\nguard : Alternative f =\u0026gt; Bool -\u0026gt; f () guard a = if a then pure () else empty when : Applicative f =\u0026gt; Bool -\u0026gt; Lazy (f ()) -\u0026gt; f () when True f = Force f when False f = pure () これらはモナドと一緒に使うと便利です。\ndo n \u0026lt;- [1..10] guard $ n `mod` 2 == 0 pure n -- [2, 4, 6, 8, 10] : List Integer Prelude.Monad モナドが定義されています。\ninfixl 1 \u0026gt;\u0026gt;= interface Applicative m =\u0026gt; Monad (m : Type -\u0026gt; Type) where (\u0026gt;\u0026gt;=) : m a -\u0026gt; ((result : a) -\u0026gt; m b) -\u0026gt; m b join : m (m a) -\u0026gt; m a -- default implementations (\u0026gt;\u0026gt;=) x f = join (f \u0026lt;$\u0026gt; x) join x = x \u0026gt;\u0026gt;= id Prelude.Foldable foldl と foldr 、他の言語でいうイテラブル相当のインタフェースを提供します。\ninterface Foldable (t : Type -\u0026gt; Type) where foldr : (func : elem -\u0026gt; acc -\u0026gt; acc) -\u0026gt; (init : acc) -\u0026gt; (input : t elem) -\u0026gt; acc foldl : (func : acc -\u0026gt; elem -\u0026gt; acc) -\u0026gt; (init : acc) -\u0026gt; (input : t elem) -\u0026gt; acc foldl f z t = foldr (flip (.) . flip f) id t z イテレータにありがちな操作も提供しています。\nconcat : (Foldable t, Monoid a) =\u0026gt; t a -\u0026gt; a concat = foldr (\u0026lt;+\u0026gt;) neutral concatMap : (Foldable t, Monoid m) =\u0026gt; (a -\u0026gt; m) -\u0026gt; t a -\u0026gt; m concatMap f = foldr ((\u0026lt;+\u0026gt;) . f) neutral and : Foldable t =\u0026gt; t (Lazy Bool) -\u0026gt; Bool and = foldl (\u0026amp;\u0026amp;) True or : Foldable t =\u0026gt; t (Lazy Bool) -\u0026gt; Bool or = foldl (||) False any : Foldable t =\u0026gt; (a -\u0026gt; Bool) -\u0026gt; t a -\u0026gt; Bool any p = foldl (\\x,y =\u0026gt; x || p y) False all : Foldable t =\u0026gt; (a -\u0026gt; Bool) -\u0026gt; t a -\u0026gt; Bool all p = foldl (\\x,y =\u0026gt; x \u0026amp;\u0026amp; p y) True concat は先程紹介したとおり List なんかが Monoid を実装しているので以下のように使えます。\nIdris\u0026gt; concat [[1, 2, 3], [4, 5, 6], [7, 8, 9]] [1, 2, 3, 4, 5, 6, 7, 8, 9] : List Intege あとは Alternative を使ったAPIもあります。\nchoice : (Foldable t, Alternative f) =\u0026gt; t (f a) -\u0026gt; f a choice x = foldr (\u0026lt;|\u0026gt;) empty x choiceMap : (Foldable t, Alternative f) =\u0026gt; (a -\u0026gt; f b) -\u0026gt; t a -\u0026gt; f b choiceMap f x = foldr (\\elt, acc =\u0026gt; f elt \u0026lt;|\u0026gt; acc) empty x これは最初の成功した値を取り出します。\nIdris\u0026gt; choice [Nothing, Nothing, Just 1, Nothing, Just 2] Just 1 : Maybe Integer Idris\u0026gt; the (Maybe Int) $ choice [Nothing, Nothing, Nothing] Nothing : Maybe Int Prelude.Basics かなり基本的な操作が入っています。\nNot : Type -\u0026gt; Type Not a = a -\u0026gt; Void id : a -\u0026gt; a id x = x the : (a : Type) -\u0026gt; (value : a) -\u0026gt; a the _ = id const : a -\u0026gt; b -\u0026gt; a const x = \\value =\u0026gt; x fst : (a, b) -\u0026gt; a fst (x, y) = x snd : (a, b) -\u0026gt; b snd (x, y) = y (.) は関数合成をします。\ninfixr 9 . (.) : (b -\u0026gt; c) -\u0026gt; (a -\u0026gt; b) -\u0026gt; a -\u0026gt; c (.) f g = \\x =\u0026gt; f (g x) flip は2引数関数の引数の順序を入れ替えます。 (.) と組み合わせて使うときなんかに便利ですね。\nflip : (f : a -\u0026gt; b -\u0026gt; c) -\u0026gt; b -\u0026gt; a -\u0026gt; c flip f x y = f y x ちょっと変わったものとしては証明用途のデータ型があります。\n||| Decidability. A decidable property either holds or is a contradiction. data Dec : Type -\u0026gt; Type where ||| The case where the property holds ||| @ prf the proof Yes : (prf : prop) -\u0026gt; Dec prop ||| The case where the property holding would be a contradiction ||| @ contra a demonstration that prop would be a contradiction No : (contra : prop -\u0026gt; Void) -\u0026gt; Dec prop 気持としては Bool に近いんですが、「なぜTrueなのか」、「なぜFalse」なのかの証明つきです。\nthe (Dec 1 = 1) (Yes Refl) や the (Dec (1 = 0)) (No SIsNotZ) など。\nPrelude.Bits Bits8 などのビット数指定の型の軽い処理が入っています。\nPrelude.Cast Cast インタフェースが定義されています。\ninterface Cast from to where cast : (orig : from) -\u0026gt; to 以外な型同士にも Cast が定義されているのは紹介したとおりです。\nCast Double String where -- ... データ型 Prelude.Bool, Prelude.Chars Prelude.Either, Prelude.Double, Prelude.List, Prelude.Maybe, Prelude.Nat, Prelude.Stream, Prelude.String\nそれぞれのデータ型や関連するコードが定義されています。 このうち Stream だけ触れてないので紹介します。\nStream リストと似ていますが、終わりのないデータ型です。\ndata Stream : Type -\u0026gt; Type where (::) : (value : elem) -\u0026gt; Inf (Stream elem) -\u0026gt; Stream elem 例えば無限に1が続くデータ型なんかを作れます。\nIdris\u0026gt; :let ones = the (Stream Int) $ repeat 1 Idris\u0026gt; take 10 ones [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] : List Int 素数一覧みたいに無限に続くデータ型をひとまず作っておいて、必要になったら take や index などで取り出すのが主な使い方ですかね。\nそれこそFizzBuzzなんかもそうですね。\nPrelude.File ファイル操作が入っています。\nPrelude.Interactive putStrLn などが入っています。\nPrelude.Interfaces Eq などの基本的なインタフェースが入っています。\nPrelude.Pairs タプル系の操作かと思いきや依存ペア系の補助データ構造が入っています。\nPrelude.Providers まだ紹介していないIdris面白機能の1つ、Type Providerで使うデータ型が入っています。\nPrelude.Show Show インタフェースが定義されています。\ninterface Show ty where partial show : (x : ty) -\u0026gt; String show x = showPrec Open x -- Eta expand to help totality checker partial showPrec : (d : Prec) -\u0026gt; (x : ty) -\u0026gt; String showPrec _ x = show x Prelude.Traversable Foldable と Applicative を組み合わせるときに使います。 Foldable の要素の1つ1つに操作を加えます。\ninterface (Functor t, Foldable t) =\u0026gt; Traversable (t : Type -\u0026gt; Type) where traverse : Applicative f =\u0026gt; (a -\u0026gt; f b) -\u0026gt; t a -\u0026gt; f (t b) まあ、一番分かりやすいのは for_ 関数ですかね。\nfor_ : (Foldable t, Applicative f) =\u0026gt; t a -\u0026gt; (a -\u0026gt; f b) -\u0026gt; f () for_ = flip traverse_ こう使います。\nIdris\u0026gt; :exec for_ [1..10] $ \\n =\u0026gt; printLn n 1 2 3 4 5 6 7 8 9 10 Prelude.Uninhabited 証明で使うインタフェースが入っています。\ninterface Uninhabited t where total uninhabited : t -\u0026gt; Void Prelude.WellFounded 整礎帰納法をします。\nDecidable.Equality 等値関係に絞った Dec の補助パッケージですかね。\ninterface DecEq t where total decEq : (x1 : t) -\u0026gt; (x2 : t) -\u0026gt; Dec (x1 = x2) Language リフレクション系のAPIが揃っています。\nbase baseの方が複雑なんですが便利なライブラリがあるんですよね。頑張って紹介します。\nData.Morphisms モーフィズム（射）が定義されています。\nrecord Morphism a b where constructor Mor applyMor : a -\u0026gt; b infixr 1 ~\u0026gt; (~\u0026gt;) : Type -\u0026gt; Type -\u0026gt; Type (~\u0026gt;) = Morphism record Endomorphism a where constructor Endo applyEndo : a -\u0026gt; a record Kleislimorphism (f : Type -\u0026gt; Type) a b where constructor Kleisli applyKleisli : a -\u0026gt; f b 射、自己準同型、クライスリ射です。 まあ、これは射に色々便利なインタフェースを定義するためのデータ型ですね。\nControl.Category 圏の定義があります。\ninterface Category (cat : k -\u0026gt; k -\u0026gt; Type) where id : cat a a (.) : cat b c -\u0026gt; cat a b -\u0026gt; cat a c 射は圏になりますね。\nimplementation Category Morphism where id = Mor id (Mor f) . (Mor g) = with Basics (Mor (f . g)) これは $\\mathbf{Set}$ 圏であってるかな？\n射の合成の別記法も用意されています。\ninfixr 1 \u0026gt;\u0026gt;\u0026gt; (\u0026gt;\u0026gt;\u0026gt;) : Category cat =\u0026gt; cat a b -\u0026gt; cat b c -\u0026gt; cat a c f \u0026gt;\u0026gt;\u0026gt; g = g . f Control.Arrow arrow系の定義がいっぱいあります。 arrowは矢印のことで、要するに射の合成とかその辺を担当します。\ninfixr 5 \u0026lt;++\u0026gt; infixr 3 *** infixr 3 \u0026amp;\u0026amp;\u0026amp; infixr 2 +++ infixr 2 \\|/ interface Category arr =\u0026gt; Arrow (arr : Type -\u0026gt; Type -\u0026gt; Type) where arrow : (a -\u0026gt; b) -\u0026gt; arr a b first : arr a b -\u0026gt; arr (a, c) (b, c) second : arr a b -\u0026gt; arr (c, a) (c, b) second f = arrow swap \u0026gt;\u0026gt;\u0026gt; first f \u0026gt;\u0026gt;\u0026gt; arrow swap (***) : arr a b -\u0026gt; arr a\u0026#39; b\u0026#39; -\u0026gt; arr (a, a\u0026#39;) (b, b\u0026#39;) f *** g = first f \u0026gt;\u0026gt;\u0026gt; second g (\u0026amp;\u0026amp;\u0026amp;) : arr a b -\u0026gt; arr a b\u0026#39; -\u0026gt; arr a (b, b\u0026#39;) f \u0026amp;\u0026amp;\u0026amp; g = arrow dup \u0026gt;\u0026gt;\u0026gt; f *** g where dup : x -\u0026gt; (x,x) dup x = (x,x) interface Arrow arr =\u0026gt; ArrowZero (arr : Type -\u0026gt; Type -\u0026gt; Type) where zeroArrow : arr a b interface ArrowZero arr =\u0026gt; ArrowPlus (arr : Type -\u0026gt; Type -\u0026gt; Type) where (\u0026lt;++\u0026gt;) : arr a b -\u0026gt; arr a b -\u0026gt; arr a b interface Arrow arr =\u0026gt; ArrowChoice (arr : Type -\u0026gt; Type -\u0026gt; Type) where left : arr a b -\u0026gt; arr (Either a c) (Either b c) right : arr a b -\u0026gt; arr (Either c a) (Either c b) right f = arrow mirror \u0026gt;\u0026gt;\u0026gt; left f \u0026gt;\u0026gt;\u0026gt; arrow mirror (+++) : arr a b -\u0026gt; arr c d -\u0026gt; arr (Either a c) (Either b d) f +++ g = left f \u0026gt;\u0026gt;\u0026gt; right g (\\|/) : arr a b -\u0026gt; arr c b -\u0026gt; arr (Either a c) b f \\|/ g = f +++ g \u0026gt;\u0026gt;\u0026gt; arrow fromEither interface Arrow arr =\u0026gt; ArrowApply (arr : Type -\u0026gt; Type -\u0026gt; Type) where app : arr (arr a b, a) b interface Arrow arr =\u0026gt; ArrowLoop (arr : Type -\u0026gt; Type -\u0026gt; Type) where loop : arr (Pair a c) (Pair b c) -\u0026gt; arr a b 記号だらけで、個人的にこれを本当に全部覚えてつかいこなしている人がいるのかは疑問に思ってます。\nCategory と Arrow は関数の抽象化を提供しています。 関数の抽象化しているというのは「普通じゃない」関数とかを定義してもそれを他の関数と同じように扱えるということです。\n例えばCPS変換した関数とかですね。\nimport Control.Category import Control.Arrow record CpsMorphism r a b where constructor Cps applyCps : a -\u0026gt; ((b -\u0026gt; r) -\u0026gt; r) cps : (a -\u0026gt; b) -\u0026gt; (a -\u0026gt; (b -\u0026gt; r) -\u0026gt; r) cps f a k = k $ f a cpsCompose : (b -\u0026gt; ((c -\u0026gt; r) -\u0026gt; r)) -\u0026gt; (a -\u0026gt; ((b -\u0026gt; r) -\u0026gt; r)) -\u0026gt; a -\u0026gt; ((c -\u0026gt; r) -\u0026gt; r) cpsCompose f g x k = g x $ \\b =\u0026gt; f b k Category (CpsMorphism r) where id = Cps $ cps id (.) (Cps f) (Cps g) = Cps (cpsCompose f g) Arrow (CpsMorphism r) where arrow f = Cps (\\x, k =\u0026gt; k $ f x) first (Cps f) = Cps $ \\(a, c), k =\u0026gt; f a (\\b =\u0026gt; k (b, c)) ArrowChoice (CpsMorphism r) where left f = f +++ (arrow id) right f = (arrow id) +++ f f +++ g = (f \u0026gt;\u0026gt;\u0026gt; (arrow Left)) \\|/ (g \u0026gt;\u0026gt;\u0026gt; (arrow Right)) (Cps f) \\|/ (Cps g) = Cps (either f g) ArrowApply (CpsMorphism r) where app = Cps $ \\(Cps f, x) =\u0026gt; f x Control.Isomorphism 同型を表わすデータ型です。 ちゃんと証明オブジェクトもついていてえらいですね。\nrecord Iso a b where constructor MkIso to : a -\u0026gt; b from : b -\u0026gt; a toFrom : (y : b) -\u0026gt; to (from y) = y fromTo : (x : a) -\u0026gt; from (to x) = x Category などいくつかのインタフェースも実装されています。 基本は証明用かな？\nControl.Catchable 失敗するかもしれない計算の失敗を処理する機能を提供します。\ninterface Catchable (m : Type -\u0026gt; Type) t | m where throw : t -\u0026gt; m a catch : m a -\u0026gt; (t -\u0026gt; m a) -\u0026gt; m a catch を 中置記法で使うとそれっぽいですかね。\n*Control/Catchable\u0026gt; Right \u0026#34;Correct\u0026#34; `catch` \\_ =\u0026gt; Left \u0026#34;Failed\u0026#34; Right \u0026#34;Correct\u0026#34; : Either String String *Control/Catchable\u0026gt; the (Either String String) $ Left \u0026#34;Incorrect\u0026#34; `catch` \\_ =\u0026gt; Left \u0026#34;Failed\u0026#34; Left \u0026#34;Failed\u0026#34; : Either String String Control.IOExcept IO (Either err a) のパターンが頻出なのでそれをまとめた型です。\nrecord IOExcept\u0026#39; (f:FFI) err a where constructor IOM runIOExcept : IO\u0026#39; f (Either err a) Data.IORef 変更可能な変数のデータ型を定義しています。\n||| A mutable variable in the IO monad. export data IORef a = MkIORef a APIは以下です。\nnewIORef : a -\u0026gt; IO (IORef a) readIORef : IORef a -\u0026gt; IO a writeIORef : IORef a -\u0026gt; a -\u0026gt; IO () modifyIORef : IORef a -\u0026gt; (a -\u0026gt; a) -\u0026gt; IO () 以下のようにして使います。\ndo result \u0026lt;- newIORef 0 for_ [0..10] $ \\n =\u0026gt; modifyIORef result (+n) readIORef result -- 55 Data.Buffer バッファが定義されています。 主にファイルとの一括IOで使うのが用途のよう。\nIdrisでバイナリIOをしたくなると使うことになると思います。\nData.Complex 複素数を定義しています。\ninfix 6 :+ data Complex a = (:+) a a Data.Vect 長さの決まっているリストを定義しています。\ndata Vect : (len : Nat) -\u0026gt; (elem : Type) -\u0026gt; Type where Nil : Vect Z elem (::) : (x : elem) -\u0026gt; (xs : Vect len elem) -\u0026gt; Vect (S len) elem Data.Fin 有限の自然数を定義しています。\ndata Fin : (n : Nat) -\u0026gt; Type where FZ : Fin (S k) FS : Fin k -\u0026gt; Fin (S k) 例えば Fin 3 なら3未満の整数しかとれません。\nIdris\u0026gt; :module Data.Fin *Data/Fin\u0026gt; the (Fin 3) 0 FZ : Fin 3 *Data/Fin\u0026gt; the (Fin 3) 1 FS FZ : Fin 3 *Data/Fin\u0026gt; the (Fin 3) 2 FS (FS FZ) : Fin 3 *Data/Fin\u0026gt; the (Fin 3) 3 (input):1:13:When checking argument prf to function Data.Fin.fromInteger: When using 3 as a literal for a Fin 3 3 is not strictly less than 3 Vect に対するインデックスのように len 未満の値を指定したいときに便利ですね。\nindex : Fin len -\u0026gt; Vect len elem -\u0026gt; elem index FZ (x::xs) = x index (FS k) (x::xs) = index k xs Data.HVect ヘテロジーニアスなベクタ型を定義しています。\ndata HVect : Vect k Type -\u0026gt; Type where Nil : HVect [] (::) : t -\u0026gt; HVect ts -\u0026gt; HVect (t::ts) 以下のように異なる型の値を格納できます。\n*Data/HVect\u0026gt; the (HVect [Integer, Bool, String]) [1, False, \u0026#34;hetero\u0026#34;] [1, False, \u0026#34;hetero\u0026#34;] : HVect [Integer, Bool, String] Data.Bits Prelude.Bits に加えてもう少し操作を定義しています。\nData.List Preldhude.List に加えてもう少し操作を定義しています。 intersect などもありますが、主に証明用ですね。\nData.String Preldhude.String に加えてもう少し操作を定義しています。\nData.List.Quantifiers List の証明に使えそうな量化子が定義されています。\nData.List.Views List に対するビューが定義されています。\nData.Vect.Quantifiers Vect の証明に使えそうな量化子が定義されています。\nData.Vect.Views Vect に対するビューが定義されています。\nData.Nat.Views Nat に対するビューが定義されています。\nData.Primitives.Views Interger などのプリミティブに対するビューが定義されています。\nData.Erased 実行時に消去された値を表現できるデータ型を定義しています。\ndata Erased : Type -\u0026gt; Type where Erase : .(x : a) -\u0026gt; Erased a Idrisでは引数の前に . があるとそれは消去されているようです。\nData.Mod2 2^n で割った値を保持する Mod2 n が定義されています。\npublic export data Mod2 : Nat -\u0026gt; Type where MkMod2 : {n : Nat} -\u0026gt; Bits n -\u0026gt; Mod2 n Data.So 型レベル Bool 相当の機能を提供します。\ndata So : Bool -\u0026gt; Type where Oh : So True 公式ライブラリだと usleep なんかで使われています。\nusleep : (i : Int) -\u0026gt; { auto prf : So (i \u0026gt;= 0) } -\u0026gt; IO () = なら型にあるんですが、 \u0026gt;= はありません。 こういう計算で結果を求めるタイプの証明に便利ですね。\nDebug.* Debug.Error と Debug.Traceはそれぞれデバッグ用に使います。 IO 文脈でなくてもIO処理ができてしまう魔法の関数です。\nimport Debug.Trace add : Integer -\u0026gt; Integer -\u0026gt; Integer add x y = trace \u0026#34;debbuging\u0026#34; $ x + y main : IO () main = printLn $ 3 * (add 1 2)$ idris -o add add.idr $ ./add debbuging 9 中身は unsafePerformIO というヤバい機能で実装されているのでデバッグ用途以外では使わないようにしましょう。\nLanguage.Reflection.Utils 証明とかに便利そうな関数がちょこっと実装されています。 他はElabに色々なインタフェースを実装する役割。\nSystem getEnv や exit などのシステム関連の機能です。\nSystem.Info backend などの処理系情報です。\nSystem.Concurrency.* System.Concurrency.Raw と System.Concurrency.Channels プロセスとチャネルを使ったコミュニケーションを提供します。 Raw は低レベルで型安全でないAPIなので Channels の方を使いましょう。\n\u0026quot;PING\u0026quot; を送ったら \u0026quot;PONG\u0026quot; を返してくれるプロセスを立ち上げてみます。 spawn に IO () の値を渡すとプロセスをスタートしてくれます。その他チャネルのAPIはドキュメントとか見て下さい。\nimport System.Concurrency.Channels pong : IO () pong = do Just channel \u0026lt;- listen 10 req \u0026lt;- unsafeRecv String channel if req == Just \u0026#34;PING\u0026#34; then ignore $ unsafeSend channel \u0026#34;PONG\u0026#34; else pure () ping : PID -\u0026gt; IO () ping pid = do Just channel \u0026lt;- connect pid unsafeSend channel \u0026#34;PING\u0026#34; Just resp \u0026lt;- unsafeRecv String channel putStrLn resp main : IO () main = do -- spawnを呼ぶ Just pongPid \u0026lt;- spawn pong putStrLn \u0026#34;pong spawned\u0026#34; ping pongPid pure () unsafeRecv の引数に型をとるので1つのチャネルで任意の型の値をやりとりできるのがポイントですね。\nプロセス内部はCバックエンドではpthreadが立ち上がっているようです。 ただしプロセスという名前だけあってメモリは共有していないようです。 以下のようにクロージャに持たせた IORef を通じてメモリを共有するコードを書いてみました。\nimport System.Concurrency.Channels import Data.IORef countDown : Nat -\u0026gt; IORef Int -\u0026gt; IO () countDown Z _ = pure () countDown (S n) v = do writeIORef v (cast n) countDown n v polling : Nat -\u0026gt; IORef Int -\u0026gt; IO () polling Z _ = pure () polling (S n) v = do i \u0026lt;- readIORef v printLn i polling n v main : IO () main = do v \u0026lt;- newIORef 100 spawn $ countDown 100 v polling 20 v これは実行時に処理系が落ちました。\nchannel_ioref: idris_rts.c:912: doCopyTo: Assertion `0\u0026#39; failed. zsh: abort (core dumped) ./channel_ioref 同じくクロージャではなくチャネルを介しても同様でした。\nimport System.Concurrency.Channels import Data.IORef countDown : Nat -\u0026gt; IO () countDown n = do Just channel \u0026lt;- listen 100 Just v \u0026lt;- unsafeRecv (IORef Int) channel loop n v where loop : Nat -\u0026gt; IORef Int -\u0026gt; IO () loop Z _ = pure () loop (S n) v = do writeIORef v (cast n) loop n v polling : Nat -\u0026gt; PID -\u0026gt; IO () polling n pid = do v \u0026lt;- newIORef (the Int 100) Just channel \u0026lt;- connect pid unsafeSend channel v loop n v where loop : Nat -\u0026gt; IORef Int -\u0026gt; IO () loop Z _ = pure () loop (S n) v = do i \u0026lt;- readIORef v printLn i loop n v main : IO () main = do Just pid \u0026lt;- spawn $ countDown 100 polling 20 pid コンパイル時に防げる仕組みがあったらよかったんですが残念ですね。\nまとめ Idrisの標準ライブラリをさっくり解説しました。\n","categories":["Idris"],"category_urls":["/categories/idris"],"date":"2020-12-27","title":"Idrisの標準ライブラリを解説していくよ","url":"https://KeenS.github.io/blog/2020/12/27/idrisnohyoujunraiburaiwokaisetsushiteikuyo/"},
  {"body":"κeenです。Jeremy Gibbsons. 1995. \u0026ldquo;The Third Homomorphism Theorem\u0026rdquo; を読んだメモ。 いわゆるリストの第三準同型定理と呼ばれるものについて、原典をあたってみたのでメモを残しておく。\nリストの第三準同型定理はざっくりいうと「ある処理が foldr でも foldl でも書けるなら分割統治で書き換えられる」という定理です。 運算というプログラムを書き換えて効率的なアルゴリズムを導出する分野でよく使われています。\nよく使われる定理なんですが、「どこが準同型なの？」とか「第一と第二どこいった」とか色々気になるので掘り返してみます。 昔、Qiitaによくまとまった記事があったんですが今探したら見当りませんでした。 自分が分かりやすいように色々いじって書くので興味のある人はこのブログで納得せずに原文を読んで下さい。\n$ \\def\\cat{\\mathrm{++}} \\def\\hom#1{{#1}\\mathrm{-}準同型} \\def\\leftwards#1{{#1}\\mathrm{-}左方向} \\def\\rightwards#1{{#1}\\mathrm{-}右方向} $\nリストとは 情報系の論文にありがちですが、どういう対象に対して議論しているのかあまりはっきりせずに書かれています。 雰囲気で察してあげましょう。\n「リストは全てが同じ型の要素の有限列である。リストはempty、singleton、2つのリストの結合からなる」と書かれているのでHaskell風に書くと以下のようなデータ構造のようです。\ndata List a = Empy | Singleton a | Concat (List a) (List a) ジェネリクスであるとかはちゃんと書かれてないですが察してあげました。\nここで便利記法を導入します。\n[] = Empty [a] = Singleton a a ++ b = Concat a b [a, b, c] = [a] ++ [b] ++ [c] a : x = [a] ++ x (右結合) 「++ は結合的かつ [] はその単位元である」とあるので Concat a (Concat b c) = Concat (Concat a b) c とみなす特別な等値関係があるのかもしれません。謎です。 一応この等値関係の元では ++ を適切に定義してあげれば List a = Nil | Cons a (List a) と同型になるのかな？ちゃんと確認してないですが。\n因みに関数適用は $f$ を $x$ に適用するときは $f\\ x$ と書きます。 $\\circ$ で関数結合を表わすと書いてあります。どの順序か明記されてないですが、 $f\\ \\circ\\ g = f\\ (g\\ \\mathrm{-} )$ のようです。\nリストの準同型 例えば群の準同型なら $f(x \\cdot y) = f(x) \\cdot f(y)$ が成り立つこと。 リストの準同型は $\\cat$ に対する準同型のよう。\n定義（リストの準同型）： 二項演算 $\\odot$ に対してリスト上の $h$ 関数が以下の条件を満たすとき、 $h$ を $\\hom{\\odot}$ という\n\\[ h\\ (x \\cat y) = h\\ x \\odot h\\ y \\]\n何も書かれてないですが、 $h: List\\ a \\to b$ と $\\odot: b \\times b \\to b$ についての記述のようです。\nこの条件から （$h$ のコドメイン上で） $\\odot$ も結合的であり、 $h []$ は（存在すれば） $\\odot$ の単位元であることがすぐさま分かります。\n例： リストの要素の総和をとる関数 $sum: List\\ Integer \\to Integer$ は $\\hom{+}$ である。 実際、以下が成り立つ\n\\[ sum\\ (x \\cat y) = sum\\ x + sum\\ y \\]\n例： リストのを長さを計算する関数 $length: List\\ a \\to Integer$ は $\\hom{+}$ である。 実際、以下が成り立つ。\n\\[ length\\ (x \\cat y) = length\\ x + length\\ y \\]\n論文には $sum$ や $length$ の型は一切書かれてないですが、名前から察しました。\n$h\\ []$ は存在しないこともあるらしいです。それ準同型って言っていいのかなぁ。 例えば $head$ $a \u0026lt;\u0026lt; b = a$ で定義される演算子 $\u0026lt;\u0026lt; : List a \\times List a \\to List a$ は $\\hom{\u0026lt;\u0026lt;}$ ですが $head\\ []$ は未定義です。 これは $\u0026lt;\u0026lt;$ に単位元が存在しないことにも対応します。\n結合的な演算子 $\\odot$ とその単位元 $e$ に対して $hom\\ (\\odot)\\ f\\ e$ と書いて、 $\\hom{\\odot}$ な $h \\circ [\\cdot] = f$ である（一意な）関数 $h$ を表わす。 何の言及もなく $f$ がでてきましたが、 $f: a \\to b$ 、 $h: List\\ a \\to b$ のようです。 $h$ の一意性について特に言及がないので確認しましょう。empty、singleton、concatenationでそれぞれ場合分けすればよさそうです。\n\\[ \\begin{align} h\\ [] \u0026amp; = e \u0026amp; （hは準同型より） \\\\\nh\\ [a] \u0026amp; = f\\ a \u0026amp; （h \\circ [\\cdot] = fより） \\\\\nh\\ (x \\cat y) \u0026amp; = h\\ x \\odot h\\ y \u0026amp; （hは準同型より） \\end{align} \\]\n$e$ 、 $\\odot$ 、 $f$ が固定されているので正しそうです。\n原文では特に名前がないのですが、 $h$ のことを $(\\odot, e, f)$ から導出される関数とでも呼びましょうか。\n例： $sum$ は $(+, id, 0)$ から導出される関数である。つまり、 $sum = hom\\ (+)\\ id\\ 0$である。そもそも $sum$ の定義が与えられてないので確かめられませんが、そうなんでしょう。あるいはこれを $sum$ の定義とみなしましょう。\n例： $length$ $(+, one, 0)$ から導出される関数である。つまり、 $length = hom\\ (+)\\ one\\ 0$ である。ここで $one: a \\to Integer$ は $one\\ x = 1$ で定義される関数である。\n左方向関数、右方向関数 定義（左方向関数）： $h: List a \\to b$ が二項演算子 $\\oplus: a \\times b \\to b$ に関して以下の条件を満たすとき、 $h$ を $\\leftwards{\\oplus}$ という。\n\\[ h ([a] \\cat y) = a \\oplus h\\ y \\]\nleftwordsの訳に左方向を充てたら珍妙な用語が誕生してしまいましたがこのままいきましょう。 $\\oplus$ は結合的でなくてもよいことに注意して下さい。\n$\\leftwards{\\oplus}$ 関数 $h$ が $h\\ [] = e$ を満たすとき、 $foldr\\ (\\oplus)\\ e$ と書く。このとき $h$ は一意である。\nまた $h$ の一意性を確かめましょう。 $[]$ と $[a]$ の場合は簡単です。\n\\[ \\begin{align} h\\ [] \u0026amp; = e \u0026amp; （条件より） \\\\\nh\\ [a] \u0026amp; = a \u0026amp; （h\\ [a] = h\\ ([a] \\cat [])と条件より） \\end{align} \\]\n$h\\ (x \\cat y)$ についてですが、恐らく $\\cat$ が結合的であることを利用して $h\\ ([] \\cat z)$ または $h\\ ([a] \\cat z)$ に書き換えるんだと思います。 そうすれば残りも以下のように確認できます。\n\\[ \\begin{align} h\\ ([] \\cat z) \u0026amp; = h\\ z \u0026amp; （\\catは[]の単位元より） \\\\\nh\\ ([a] \\cat z) \u0026amp; = a \\oplus h\\ y \u0026amp; （条件より） \\end{align} \\]\n$h$ が一意であることが確認できました。\n例（$lsp$）： リストの最長整列済み接頭辞（longest sorted prefix）を求める関数 $lsp$ は以下の定義をもつ二項演算子 $\\oplus$ により $\\leftwards{\\oplus}$ である。\n\\[ \\begin{align} a \\oplus [] \u0026amp;= [a] \\\\\na \\oplus (b:x) \u0026amp;= \\begin{cases} a : b : x \u0026amp;, \\mathrm{if}\\ x \\le b \\\\\n[a] \u0026amp;, \\mathrm{otherwise} \\end{cases} \\end{align} \\]\nさらに $lsp\\ [] = []$ であるので $lsp = foldr\\ (\\oplus)\\ []$ である。\nここで $foldr$ の重要な性質を2つ提示します。 1つは foldr の計算が右から左に走るということ。\n\\[ foldr\\ (\\oplus)\\ e\\ [a_1, a_2, a_3] = a_1 \\oplus (a_2 \\oplus (a_3 \\oplus e)) \\]\nもう1つ、これを一般化して concatenateの $foldr$ は2つの $foldr$ に分解できるということ。\n\\[ foldr\\ (\\oplus)\\ e\\ (x \\cat y) = foldr\\ (\\oplus)\\ (foldr\\ (\\oplus)\\ e\\ y)\\ x \\]\n左方向関数と同様に、右方向関数も定義できます。\n定義（右方向関数）： $h: List\\ a \\to b$ が二項演算子 $\\otimes: b \\times a \\to b$ に関して以下の条件を満たすとき、 $h$ を $\\rightwards{\\otimes}$ という。\n\\[ h\\ (x \\cat [a]) = h\\ x \\otimes a \\]\n左方向が $\\oplus$ で右方向が $\\otimes$ です。 こちらも $\\otimes$ は結合的である必要はありません。\n左方向関数と同様に $foldl$ も導入しましょう。 $\\rightwards{\\otimes}$ 関数 $h$ が $h\\ [] = e$ を満たすとき、 $foldl\\ (\\otimes)\\ e$ と書く。このとき $h$ は一意である。 一意性の確認は省略します。\n左方向関数と同様に、 foldl には2つの重要な性質があります。\n\\[ foldl\\ (\\otimes)\\ e\\ [a_1, a_2, a_3] = ((e \\otimes a_1) \\otimes a_2) \\otimes a_3 \\]\nと、これを一般化したもの\n\\[ foldl\\ (\\otimes)\\ e\\ (x \\cat y) = foldl\\ (\\otimes)\\ (foldl\\ (\\otimes)\\ e\\ x)\\ y \\]\nです。\n第一、第二準同型 「第一と第二どこいった」と気になる人のために第一準同型定理と第二準同型定理のステートメントが紹介されています。 その前に2つの用語定義しておきます。\n定義(畳み込み)： ある $\\odot$ を用いて $hom\\ (\\odot)\\ id\\ e$ と書ける関数を畳み込みと呼ぶ。\nここで $id$ は引数をそのまま返す関数、 $e$ は言及がないですが、 $\\odot$ の単位元なんでしょう。\n定義（マップ）： 関数 $f$ に対して $hom\\ (\\cat)\\ ([\\cdot] \\circ f)\\ []$ を $map\\ f$ と書き、マップと呼ぶ。\nmapを写像と訳すか迷ったんですがマップとしておきます。 これで第一、第二準同型定理を述べられます。\n定理（第一準同型定理）： 全てのリストの準同型関数は畳み込みとマップの合成で書ける。 すなわち、準同型関数が $hom\\ (\\odot)\\ f\\ e$ と書けるとすると、以下のようにマップと畳み込みの合成の形に分解できる。\n\\[ hom\\ (\\odot)\\ f\\ e = hom\\ (\\odot)\\ id\\ e \\circ map\\ f \\]\n逆に、ある関数がこのような合成で書けるならリストの準同型である。\n定理（第二準同型定理、特殊化定理）： 全てのリストの準同型関数は左方向関数であり、かつ右方向関数である。 すなわち $\\odot$ が結合的ならば以下の等式が成り立つ\n\\[ \\begin{align} hom\\ (\\odot)\\ f\\ e \u0026amp; = foldr\\ (\\oplus)\\ e \u0026amp; \\mathrm{where}\\ a \\oplus s = f\\ a \\odot s \\\\\n\u0026amp; = foldl\\ (\\otimes)\\ e \u0026amp; \\mathrm{where}\\ r \\otimes a = a \\odot f\\ a \\end{align} \\]\n第三準同型定理 第三準同型定理は証明まで載っています。 まずはステートメントです。\n定理（第三準同型定理）： リスト上の関数 $h$ が左方向かつ右方向であるとき、 $h$ は準同型である。\n第二準同型定理の逆ですね。\n証明にあたって補題を2つ準備します。\n補題1： 全ての計算可能で全関数である、列挙可能な定義域をもつ $h$ に対して、 計算可能（だが部分関数である可能性もある）関数 $g$ が存在して $h \\circ g \\circ h = h$ を満たす。\n証明： $g$ を以下の疑似コードで定義する。\ng t = for x in domain of h if h x == t return x せやな。 $h\\ x = t$ を満たす $x$ がないこともあるので $g$ は部分関数になることがあります。\n補題2：次の2つは同値である。\n $h$ がリストの準同型である $h\\ v = h\\ x$ かつ $h\\ w = h\\ y$ ならば $h\\ (v \\cat w) = h\\ (x \\cat y)$  証明： $1 \\to 2$ は簡単。 $h$ をリストの準同型関数とする。 $h\\ v = h\\ x$ かつ $h\\ w = h\\ y$ を仮定すると\n\\[ \\begin{align} h (v \\cat w) \u0026amp; = h\\ v \\cat h\\ w \u0026amp; （hの準同型性より） \\\\\n\u0026amp; = h\\ x \\cat h\\ y \u0026amp; （仮定より） \\\\\n\u0026amp; = h\\ (x \\cat y) \u0026amp; （hの準同型性より） \\end{align} \\]\n$2 \\to 1$ を示す。 任意のリスト上の関数 $h$ が $h\\ v = h\\ x$ かつ $h\\ w = h\\ y$ ならば $h\\ (v \\cat w) = h\\ (x \\cat y)$ であるとする。 $h$ をリスト上の関数とする。 補題1より $h \\circ g \\circ h = h$ を満たす $g$ が存在するのでそれをとる。 この $g$ を用いて二項演算子 $\\odot$ を以下のように定義する\n\\[ t \\odot u = h\\ (g\\ t \\cat g\\ u) \\]\n$h$ が $\\hom{\\odot}$ であることを示す。 $g$ のとり方により $h\\ x = h\\ (g\\ (h\\ x))$ 、 $h\\ y = h\\ (g\\ (h\\ y))$ である。\n\\[ \\begin{align} h (x \\cat y) \u0026amp; = h (g (h x) \\cat h (h y)) \u0026amp; （仮定より） \\\\\n\u0026amp; = h\\ x \\odot h\\ y \u0026amp; （\\odot の定義より） \\end{align} \\]\n仮定よりのところで悩んでたんですが、 $h\\ x = h\\ (g\\ (h\\ x))$ かつ $h\\ y = h\\ (g\\ (h\\ y))$ が成り立つので $h\\ (x \\cat y) = h\\ (g\\ (h\\ x) \\cat h\\ (h\\ y))$ がいえるんですね。 これ書いてて気付きました。スッキリスッキリ。\n準備の万端が整ったのでリストの第三準同型定理を証明します。\n証明： リスト上の関数 $h$ を左方向かつ右方向とする。 $h$ は単位元 $e$ （= $h\\ []$）、二項演算子 $\\oplus$ 、 $\\otimes$ を用いて $h = foldr\\ (\\oplus)\\ e = foldl\\ (\\otimes)\\ e$ と書ける。\n補題2を用いて証明する。 適当なリスト $v, w, x, y$ について $h\\ v = h\\ x$ かつ $h\\ w = h\\ y$ であるとする。 すると\n\\[ \\begin{align} h\\ (v \\cat w) \u0026amp; = foldr\\ (\\oplus)\\ e\\ (v \\cat w) \u0026amp; （hは左方向より） \\\\\n\u0026amp; = foldr\\ (\\oplus)\\ (foldr\\ (\\oplus)\\ e\\ w)\\ v \u0026amp; （foldrの性質より） \\\\\n\u0026amp; = foldr\\ (\\oplus)\\ (foldr\\ (\\oplus)\\ e\\ y)\\ v \u0026amp; （h\\ w = h\\ yとfoldr\\ (\\oplus)\\ e = hより） \\\\\n\u0026amp; = foldr\\ (\\oplus)\\ e\\ (v \\cat y) \u0026amp; （foldrの性質より） \\\\\n\u0026amp; = h\\ (v \\cat y) \u0026amp; （foldr\\ (\\oplus)\\ e = h より） \\\\\n\u0026amp; = foldl\\ (\\otimes)\\ e\\ (v \\cat y) \u0026amp; （hは左方向より） \\\\\n\u0026amp; = foldl\\ (\\otimes)\\ (foldl\\ (\\otimes)\\ e\\ v)\\ y \u0026amp; （foldlの性質より） \\\\\n\u0026amp; = foldl\\ (\\otimes)\\ (foldl\\ (\\otimes)\\ e\\ x)\\ y \u0026amp; （h\\ v = h\\ xとfoldl\\ (\\otimes)\\ e = hより） \\\\\n\u0026amp; = foldl\\ (\\otimes)\\ e\\ (x \\cat y) \u0026amp; （foldlの性質より） \\\\\n\u0026amp; = h\\ (x \\cat y) \u0026amp; （foldl\\ (\\otimes)\\ e = h より） \\end{align} \\]\n補題2より $h$ はリストの準同型。\n論文ではこのあと実例が続くんですが（insert が右方向かつ左方向であることを使ってインサートソートからマージソートを導出する）、長くなるのでメモは一旦ここまで。 気が向いたら続きを書きます。\n追記： 書きました論文メモの続き：The Third Homomorphism Theorem | κeenのHappy Hacκing Blog\n","categories":["論文メモ"],"category_urls":["/categories/%e8%ab%96%e6%96%87%e3%83%a1%e3%83%a2"],"date":"2020-12-27","title":"論文メモ：The Third Homomorphism Theorem","url":"https://KeenS.github.io/blog/2020/12/27/ronbunmemo_the_third_homomorphism_theorem/"},
  {"body":"κeenです。俺たちのAdevnt Calendarはまだまだ終わらないぜ！ Idrisの標準ライブラリを含め、世間でモノイド（などの代数構造）とされる型クラスって正しくないよねという話と、正しい定義をする話をします。\nモノイドの定義 集合 $S$ とその上の二項演算 $\\cdot : S \\times S \\to S$ が以下の2つの条件を満たすときモノイドという\n 結合律： $S$ の任意の元 $a$ 、 $b$ 、 $c$ に対して $(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$ が成り立つ 単位元: $S$ の元 $e$ が存在して、 $S$ の任意の元 $a$ に対して $e \\cdot a = a \\cdot e = a$ が成り立つ  ポイントはモノイドは集合と演算の組に対して定義されている点と、モノイドであるためにはある程度の性質を満たさないといけない点です。\n例えば自然数と + の組はモノイドですし、 自然数 と * の組もモノイドです。\nよくあるモノイドの定義 Idrisのプレリュードにも定義はありますが、半群を継承していて話がややこしくなるので1まとめにした定義を出します。\ninterface Monoid ty where neutral : ty (\u0026lt;+\u0026gt;) : ty -\u0026gt; ty -\u0026gt; ty これを見て「うん、モノイドだね」と思った方はかなり毒されてます。 モノイドの定義に全然従ってないですよね。\nよくあるモノイドの定義の問題点 定義の対象が違う 本来のモノイドは集合と演算の組に対して定義されるのに対して、こちらは型（=集合）に対してのみ定義しています。\nこれは結構な問題で、例えば自然数には + や * 、あるいは max などの演算で複数のモノイド構造があるのにそれを表現できません（Idrisではインタフェースの実装は原則1型につき1つ）。\n標準ライブラリではどうしているかというと、自然数をラップする新しい型を定義して、それぞれに別の演算を定義しています。\nrecord Multiplicative where constructor GetMultiplicative _ : Nat record Additive where constructor GetAdditive _ : Nat Monoid Multiplicative where (\u0026lt;+\u0026gt;) left right = GetMultiplicative $ left\u0026#39; * right\u0026#39; where left\u0026#39; : Nat left\u0026#39; = case left of GetMultiplicative m =\u0026gt; m right\u0026#39; : Nat right\u0026#39; = case right of GetMultiplicative m =\u0026gt; m neutral = GetMultiplicative $ S Z Monoid Additive where left \u0026lt;+\u0026gt; right = GetAdditive $ left\u0026#39; + right\u0026#39; where left\u0026#39; : Nat left\u0026#39; = case left of GetAdditive m =\u0026gt; m right\u0026#39; : Nat right\u0026#39; = case right of GetAdditive m =\u0026gt; m neutral = GetAdditive Z めちゃくちゃ使いづらそうですよね。\n一応Idrisにはインタフェースの名前つき実装というのがあって、別々のインスタンスを作ることもできます。\n[MultNatMonoid] Monoid Nat where neutral = S Z (\u0026lt;+\u0026gt;) = mult [AddNatMonoid] Monoid Nat where neutral = Z (\u0026lt;+\u0026gt;) = plus ですがこれはこれで問題です。 何故なら同じ演算子に対して複数のインスタンスを作れてしまうからです。\n[AddNatMonoid] Monoid Nat where neutral = Z (\u0026lt;+\u0026gt;) = plus [AddNatMonoid2] Monoid Nat where neutral = Z (\u0026lt;+\u0026gt;) = plus さらに、これを使うときに面倒です。 concat @{AddNatMonoid} のように名前を指定しないといけなくなります。 できれば型から良い感じに推測してほしいですよね。\n条件を表現できていない まあ、これは分かりやすいでしょう。 結合律と単位元の満たすべき条件が表現できていません。\nこれら2つの問題を解決したモノイドを定義したい、というのが今回の趣旨です。\nパラメータに演算を 真っ先に思い付くのはインタフェースのパラメータで演算まで受け取ってしまうものですよね。\ninterface CorrectMonoid s (op : s -\u0026gt; s -\u0026gt; s) where これで定義の対象が違う問題が解決します。\nそして続く中身は以下のようになります。\ninterface CorrectMonoid s (op : s -\u0026gt; s -\u0026gt; s) where unit : s unitNeutral : (x : s) -\u0026gt; (op unit x = x, op x unit = x) monoidAssociative : (x, y, z : s) -\u0026gt; op x (op y z) = op (op x y) z  （よくある定義と同じように）単位元を定義に持つ （よくある定義と異なり）演算は定義にない 2つの条件を定義に持つ。要は証明オブジェクトを要求する。  これはコンパイルが通ります。\nよさそうなので例えば (Nat, plus) の組に定義してみましょう。 小文字はじまりのシンボルは勝手に型パラメータ扱いされるので Prelude.Nat.plus と完全修飾名を使っています。\nCorrectMonoid Nat Prelude.Nat.plus where unit = Z unitNeutral n = (plusZeroLeftNeutral n, plusZeroRightNeutral n) monoidAssociative = plusAssociative 残念ながらこれはコンパイルエラーです。\n- + Errors (1) `-- correctMonoid.idr line 8 col 0: plus cannot be a parameter of Main.CorrectMonoid (Implementation arguments must be type or data constructors) いくらIdrisといっても関数を型パラメータに書くことはできません。 型パラメータに書けるのは型や型コンストラクタ、データ型から作った値などです。 多分関数の同一性の問題とかそのあたりの制約なんでしょう。\nという訳で試み1は失敗しました。\n演算に対応する型 関数を直接置けないなら関数と対応関係にあるダミーの型を作ってそれを置けばいいじゃんという発想に至ります。\ndata Add interface Op s o where (\u0026lt;\u0026gt;) : s -\u0026gt; s -\u0026gt; s Op Nat Add where (\u0026lt;\u0026gt;) = plus interface Op s o =\u0026gt; CorrectMonoid s o where unit : s unitNeutral : (x : s) -\u0026gt; (unit \u0026lt;\u0026gt; x = x, x \u0026lt;\u0026gt; unit = x) monoidAssociative : (x, y, z : s) -\u0026gt; x \u0026lt;\u0026gt; (y \u0026lt;\u0026gt; z) = (x \u0026lt;\u0026gt; y) \u0026lt;\u0026gt; z 残念ながらこれもコンパイルが通りません。\n- + Errors (1) `-- correctMonoid.idr line 22 col 10: When checking type of Main.unitNeutral: Can\u0026#39;t find implementation for Op s o どうやら interface Op s o の o がどこでも使われていないことで解決に失敗するようです。\nインタフェースを使った方法は難しいようですね。別の方法を探しましょう。\n自作インタフェース 次に思い付くのはインタフェースの仕組みを1から作ればどうにかできるんじゃないかということですよね。\nインタフェースは実装レベルではただのレコードです。\nrecord CorrectMonoid a o where constructor MkCorrectMonoid _unit : a _op : a -\u0026gt; a -\u0026gt; a _unitNeutral : (x : a) -\u0026gt; (_op _unit x = x, _op x _unit = x) _opAssociative : (x, y, z : a) -\u0026gt; _op x (_op y z) = _op (_op x y) z ここまではよいでしょう。\nでは CorrectMonoid a o =\u0026gt; ... という制約はどう書くんだとなります。 これは事実上自動で渡されるimplicit argumentsですよね。 Idrisにはauto implicit argumentsがあります。 それを使えば以下のように各関数が作れます。\nnamespace CorrectMonoid unit : {auto impl : CorrectMonoid a o} -\u0026gt; a unit {impl} = _unit impl op : {auto impl : CorrectMonoid a o} -\u0026gt; a -\u0026gt; a -\u0026gt; a op {impl} = _op impl unitNeutral : {auto impl : CorrectMonoid a o} -\u0026gt; (x : a) -\u0026gt; ((_op impl) (_unit impl) x = x, (_op impl) x (_unit impl) = x) unitNeutral {impl} = _unitNeutral impl opAssociative : {auto impl : CorrectMonoid a o} -\u0026gt; (x, y, z : a) -\u0026gt; (_op impl) x ((_op impl) y z) = (_op impl) ((_op impl) x y) z opAssociative {impl} = _opAssociative impl それではこのインスタンスを作ってみましょう。 %hint ディレクティブをつけるとauto implicit argumentsの探索対象に入ります。\ndata Add %hint natAddCorrectMonoid : CorrectMonoid Nat Add natAddCorrectMonoid = MkCorrectMonoid unit op unitNeutral opAssociative where unit : Nat unit = 0 op : Nat -\u0026gt; Nat -\u0026gt; Nat op = plus unitNeutral : (x : Nat) -\u0026gt; (op unit x = x, op x unit = x) unitNeutral n = (plusZeroLeftNeutral n, plusZeroRightNeutral n) opAssociative : (x, y, z : Nat) -\u0026gt; op x (op y z) = op (op x y) z opAssociative = plusAssociative ここまで問題なく定義できます。 もう1つくらいインスタンスを作ってみます。\ndata Max %hint natMaxCorrectMonoid : CorrectMonoid Nat Max natMaxCorrectMonoid = MkCorrectMonoid unit op unitNeutral opAssociative where unit : Nat unit = 0 op : Nat -\u0026gt; Nat -\u0026gt; Nat op = maximum unitNeutral : (x : Nat) -\u0026gt; (op unit x = x, op x unit = x) unitNeutral n = (maximumZeroNRight n, maximumZeroNLeft n) opAssociative : (x, y, z : Nat) -\u0026gt; op x (op y z) = op (op x y) z opAssociative = maximumAssociative これを使う関数も定義してみましょう。 ここでもauto implicit argumentsを使います。\nfoldAll : {auto impl : CorrectMonoid a o} -\u0026gt; List a -\u0026gt; a foldAll = foldl op unit もうちょっと踏み込んでみましょう。演算を Add に限定した sum も定義してみます。\nsumAll : {auto impl : CorrectMonoid a Add} -\u0026gt; List a -\u0026gt; a sumAll = foldAll これを使ってみます。\nIdris\u0026gt; sumAll [Z, 1, 2, 3] 6 : Nat デフォルトでIntegerに推論されるので無理矢理 Nat にするために Z を突っ込んでますが、おおむね自然に使えてますね。\nfoldAll のように演算が決まってない関数は o のimplicit argumentsに使いたい演算（と対応関係にある型）を渡してあげるとそれを使ってくれます。\nIdris\u0026gt; foldAll {o = Max} [Z, 1, 2, 3] 3 : Nat どうやらauto implicit argumentsとインタフェースでは探索する条件が違うっぽくて、auto implicit argumentsを使えばちゃんとインスタンスをさがせるようです。 多分インタフェースが関数から型を逆算してるのに対してauto implicit argumentsは最初に書いた型から探索してて探しやすいんですかね。\nひとまず正しいモノイドが定義でたようです。\nインタフェースを拡張する モノイドと定義できて満足したあなたはモノイドを拡張して可換モノイドも定義したくなりましたね。 ちょっとボイラープレートが多いですがそれも可能です。\nrecord CorrectCommMonoid a o where constructor MkCorrectCommMonoid _super : CorrectMonoid a o _opCommutative : (x, y : a) -\u0026gt; (_op _super) x y = (_op _super) y x namespace CorrectCommMonoid fromCorrectMonoid : (super : CorrectMonoid a o) -\u0026gt; ((x, y : a) -\u0026gt; (_op super) x y = (_op super) y x) -\u0026gt; CorrectCommMonoid a o fromCorrectMonoid super _opCommutative = MkCorrectCommMonoid super _opCommutative unit : {auto impl : CorrectCommMonoid a o} -\u0026gt; a unit {impl} = _unit (_super impl) op : {auto impl : CorrectCommMonoid a o} -\u0026gt; a -\u0026gt; a -\u0026gt; a op {impl} = _op (_super impl) unitNeutral : {auto impl : CorrectCommMonoid a o} -\u0026gt; (x : a) -\u0026gt; ((_op (_super impl)) (_unit (_super impl)) x = x, (_op (_super impl)) x (_unit (_super impl)) = x) unitNeutral {impl} = _unitNeutral (_super impl) opAssociative : {auto impl : CorrectCommMonoid a o} -\u0026gt; (x, y, z : a) -\u0026gt; (_op (_super impl)) x ((_op (_super impl)) y z) = (_op (_super impl)) ((_op (_super impl)) x y) z opAssociative {impl} = _opAssociative (_super impl) opCommutative : {auto impl : CorrectCommMonoid a o} -\u0026gt; (x, y : a) -\u0026gt; (_op (_super impl)) x y = (_op (_super impl)) y x opCommutative {impl} = _opCommutative impl %hint natAddCorrectCommMonoid : CorrectCommMonoid Nat Add natAddCorrectCommMonoid = fromCorrectMonoid natAddCorrectMonoid opCommutative where opCommutative : (x, y : Nat) -\u0026gt; plus x y = plus y x opCommutative = plusCommutative %hint natMaxCorrectCommMonoid : CorrectCommMonoid Nat Max natMaxCorrectCommMonoid = fromCorrectMonoid natMaxCorrectMonoid opCommutative where opCommutative : (x, y : Nat) -\u0026gt; maximum x y = maximum y x opCommutative = maximumCommutative かくして目的が達成できました。\n余談 その1 foldAll はインタフェースのように CorrectMonoid a o =\u0026gt; で書くこともできます。\nfoldAll : CorrectMonoid a o =\u0026gt; List a -\u0026gt; a foldAll = foldl op unit 多分「インタフェースが暗黙の引数になる」+「auto implicit parametersはローカル変数からも探索する」の合わせ技だと思います。 これだけならOKです。\nですがそれをやると sumAll で死にます。\nsumAll : CorrectMonoid a Add =\u0026gt; List a -\u0026gt; a sumAll = foldAll- + Errors (1) `-- correctMonoid.idr line 59 col 9: When checking right hand side of sumAll with expected type List a -\u0026gt; a Can\u0026#39;t find implementation for CorrectMonoid a o 暗黙の引数の探索まわりは謎が多いです。\nその2 Idrisのcontribには既存の（正しくない）代数構造を継承して演算に課される条件の証明を持つようにしたインタフェース群が定義されています。\nIdrisDoc: Interfaces.Verified\n実装する対象が違う問題は名前付き実装を使っているようです。\nまとめ Idrisで正しいモノイドを定義する方法を模索しました。 その過程でインタフェースやauto implicit argumentsなどの詳細に踏み込みました。\n","categories":["Idris"],"category_urls":["/categories/idris"],"date":"2020-12-26","title":"Idrisで正しいモノイドを定義したい","url":"https://KeenS.github.io/blog/2020/12/26/idrisdetadashiimonoidowoteigishitai/"},
  {"body":"このエントリはRust 3 Advent Calendar 2020の16日目の記事です。 前はbantechさんでactix-webでformいろいろ、後はkaz399さんで2020年 Rust で使える Bluetooth Low Energy ライブラリはどうなってるの (Windows10) - Qiitaでした。\n空いている日を埋める担当のκeenです。 最近RustのMutexのPoisoningについて動向があったので紹介します。\nMutex::lock は以下の型をしています。\npubfn lock(\u0026amp;self)-\u0026gt; LockResult\u0026lt;MutexGuard\u0026lt;\u0026#39;_,T\u0026gt;\u0026gt; ここで LockResult はこう定義されています。\ntype LockResult\u0026lt;Guard\u0026gt;=Result\u0026lt;Guard,PoisonError\u0026lt;Guard\u0026gt;\u0026gt;; なにやら PoisonError というのが返っていますね。 ドキュメントを読んでみましょう。\nロックというのは他のスレッドに割り込まれたくない一連の操作（クリティカルセクション）を保護するのに使いますよね。つまり操作の途中の状態を見られたくない訳です。 ではその操作の途中でスレッドがパニックしたらどうなるでしょう。 見られたくない中途半端な状態で処理が止まってしまいます。 そういう場合にロックを開放するのもロックを掴みっぱなしにするのもどうなの、ということで標準ライブラリの Mutex は「このロックで保護されてる値は中途半端な状態かもよ」というマークをつけます。それがPoisoningです。\n以下のコードを走らせるとPoisoningが確認できます。\nusestd::sync::{Arc,Mutex};usestd::thread;letmutex=Arc::new(Mutex::new(1));// poison the mutex letc_mutex=Arc::clone(\u0026amp;mutex);let_=thread::spawn(move||{letmutdata=c_mutex.lock().unwrap();*data=2;panic!();}).join();matchmutex.lock(){Ok(_)=\u0026gt;unreachable!(),Err(p_err)=\u0026gt;{letdata=p_err.get_ref();println!(\u0026#34;recovered: {}\u0026#34;,data);}}; ロックを取ったスレッドがパニックして、ロックが汚染された状態になります。 それを検知したメインッスレッドでは println!(\u0026quot;recovered: {}\u0026quot;, data) と、エラーから回復します。\nthread \u0026#39;\u0026lt;unnamed\u0026gt;\u0026#39; panicked at \u0026#39;explicit panic\u0026#39;, poison.rs:12:9 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace recovered: 2 Poisoningの問題点 2点問題点が指摘されています。\nゼロオーバーヘッド原理 Poisoning自体はすごく有用なテクニックです。ですが、それを標準ライブラリでやる必要ある？というツッコミです。 ロックを掴んだままスレッドがパニックしたときに「中途半端な状態」になるケースもあればならないケースもあります。 これはどういうコードを書いたか次第です。\n中途半端にならないケースではPoisoningの処理は無駄になる訳です。 C++の標語ですが、「ゼロオーバヘッド原理」というのがあります。 「使ってないもののコストを支払わなくていい」と説明されるように、あらゆる処理は必要な人にしか行なわないようにしようという目標です。 RustもC++と同じくシステムプログラミング言語ですから必要のないものはできればやらない方がいいですよね。 その観点からするとPoisoningは余計な処理になってしまう訳です。\nここで「Rustは安全な言語だから仕方がない」という意見があります。 しかしRustの保証する安全性はプログラムのロジックにバグがないことではなく、メモリ破壊などの未定義動作が起きないということです。 Poisoningで防げるバグはプログラムのロジックのバグなので、テリトリーが違うのではないかと言われています。\nエラーとパニック問題 プログラムのエラーには2種類あります。 1つは予期されたエラー。これはユーザの入力が期待と違うなどの、プログラムを書いている時点で想定されたエラーです。もう1つは予期しないエラー。これは言ってしまえばプログラムのバグです。 Rustでは前者を Result\u0026lt;T, E\u0026gt; で、 後者をパニックで表現します。\nここでPoisoningを振り返ってみましょう。 ロックが汚染された状態はスレッドがパニックした場合に起きます。つまりプログラムバグがあった場合ですね。 ですが、 Mutex::lock が返すのは Result です。想定内のエラーということになっています。 このパニック → Result の変換はよくないんじゃないのというツッコミです。\n今後の話 問題があるとして、そのあとに取れるアクションの可能性は複数あります。 既にあるAPIだから変えない、Poisoningをやめる、Poisonしてたら Result を返すのではなくパニックする、ロックとPoisoningをそれぞれ別のAPIで提供するなどなど。\nRustの公式でどうしようというサーベイが走っています。\n Launching the Lock Poisoning Survey | Rust Blog Poisoning Survey  期限がいつまでなのかわかりませんが、今のところまだアンケートは回答可能なようなので興味を持った方は回答してみて下さい。\n本件についてrust-analyzerの中の人のmatklad氏が大変示唆に富むブログを書いていたので併せて紹介しておきます。\nNotes On Lock Poisoning\n","categories":["Rust","Rust Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/rust","/categories/rust-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-25","title":"RustのMutexのPoisoning","url":"https://KeenS.github.io/blog/2020/12/25/rustnomutexnopoisoning/"},
  {"body":"このエントリはIdris Advent Calendar 2020の25日目の記事です。\n今回はIdrisの面白機能の1つElaboratorのリフレクションを利用したメタプログラミング紹介しようと思います。 かなりコアな部分に踏み込むので分からなかったら「へー、そんな機能もあるんだ」と思っておいて下さい。\nElaboratorリフレクションとは ElaboratorリフレクションとはElaborator reflection: extending Idris in Idrisで提案された機能です。 Elaboratorを何と訳すか難しいのですが、強いて訳すなら推敲器とかになりますかね？\nElaboratorとは多くの（関数型言語の）コンパイラの内部に存在する変換器です。 コンパイラはユーザにはリッチな表現を提供しつつ、内部で扱う言語はかなりシンプルに保っています。\nElaboratorリフレクションではそのElaboratorへのアクセスを提供します。 つまりユーザの書いたコードでコンパイルプロセスに割り込めるのです。\nElaboratorリフレクションの中ではIdrisそのものを対象にプログラムが書けるので、メタプログラミングができます。 すなわちIdrisのプログラムを生成するプログラムが書けるのです。\nここでユーザスクリプトで割り込むのがElaboratorというのが絶妙です。 Elaboratorで推敲した結果、小さなコア言語になります。 そしてそのコア言語で型推論が行われるのです。 つまりハチャメチャなElaboratorスクリプトを書いてもその後の型推論に通らなかったらコンパイルは通りません。 Idrisの担保する安全性を脅かすことなく自由にメタプログラミングができる訳です。\nElaboratorリフレクション難しい機能になるので公式ドキュメントなども参考にしながら読んで下さい。\nElaborator Reflection Introduction — Idris 1.3.3 documentation\nElaboratorリフレクションの使い方 4ステップで使えます。\n Elaboratorリフレクションの機能をonにする\n%language ElabReflection エスパー能力に目覚める\n エスパー能力を使ってElaboratorスクリプトを書く\n %runElab でElaboratorスクリプトを走らせる\n  やってみましょう。\nid 関数を生成する ドキュメントに載っている例です\nまずはElaboratorリフレクションをonにします。\n%language ElabReflection 次にエスパー能力ですが、今回はドキュメントに載っているものを使うので使う必要はありません。\nElaboratorスクリプトを書きましょう。 Elaboratorスクリプトは Elab モナドで記述します。 こういう書き出しになります。\nmkId : Elab () 実装する前に使用例を出しておくと、以下のように使います。\nidNat : Nat -\u0026gt; Nat idNat = %runElab mkId \\x =\u0026gt; x を生成するイメージですね。\nこの実装は以下のスクリプトで与えられます。\nmkId : Elab () mkId = do intro `{{x}} fill (Var `{{x}}) solve 軽く解説しておきましょう。 `{{x}} はリフレクションで使う機能で、変数名の内部表現を手軽に書く記法です。\nIdris\u0026gt; `{{x}} UN \u0026#34;x\u0026#34; : TTName Idris\u0026gt; `{{Prelude.Basics.id}} NS (UN \u0026#34;id\u0026#34;) [\u0026#34;Basics\u0026#34;, \u0026#34;Prelude\u0026#34;] : TTName それぞれのスクリプトは以下のような意味です。\n intro `{{x}} は \\x =\u0026gt; ... 相当 fill (Var `{{x}}) は変数 x を返り値としていることに相当 solve は （恐らく） 変数 x が \\x =\u0026gt; ... から取得できることを確認  それでは先程紹介したとおり使ってみます。\nidNat : Nat -\u0026gt; Nat idNat = %runElab mkId 今定義した idNat を軽く使ってみましょう。\nIdris\u0026gt; idNat 1 1 : Nat Idris\u0026gt; idNat 0 0 : Nat Idris\u0026gt; idNat 1000 1000 : Nat 想定通り動いていますね。\nREPLには :core という組み込みコマンドがあります。 任意の式のコア言語での表現を取得できます。 これで生成された idNat の中身を見てみましょう。\nIdris\u0026gt; :core idNat Main.idNat : (__pi_arg : Prelude.Nat.Nat) → Prelude.Nat.Nat Main.idNat ↦ λ x . x これも想定通りの中身ですね。\n使えるコマンドなどはAPIドキュメントを見ましょう。\n IdrisDoc: Language.Reflection.Elab IdrisDoc: Language.Reflection  Elaboratorリフレクションの使いどころ Elaboratorリフレクションにはいくつか使いどころがあります。\n1つは証明です。 intro とか fill とかは証明を意識したネーミングになっています。\nもう1つは穴（Hole）を埋めるためです。 Advent Calendar内で触れそびれたのですが、Idrisには部分的に未完成なプログラムをロードする機能があります。 そしてそのHoleの型や、利用できる型を表示できるので、難しい部分をひとまずHoleにしておき、あとで型をみながら埋めることができます。 そのときにElaboratorリフレクションを使ってインタラクティブにHoleの型を変化させながらプログラミングできるのです。 これは証明をするときに使うテクニックですね。\nそして今回紹介するのがメタプログラミングです。 手で実装するのが面倒な関数の自動生成に挑戦したいと思います。\n余談ですがElaboratorリフレクションのスクリプトはElabと呼んでしまうことが多いようです。 全然関係ないですがIdris Elbaという俳優がいるらしいです。\nElabで関数生成 さきほどは関数の本体部分のみを生成しました。 ここでは型宣言や関数名への定義も含めた関数定義全体を生成します。\nつまり、以下のコードで\n%runElab genMyId 以下のコード相当のものが定義されるのを目指します。\nmyId : a -\u0026gt; a myId = \\(x: a) =\u0026gt; x ElabかASTか さきほどはドキュメントに載っているとおり intro や fill などの命令を使って関数を書きました。 関数を定義するにはもう1つ方法があって、ASTを直接書くこともできます。\nASTを直接書くのはかなり手間が掛かるので正直にいうとゴリラ向けの手法になります。\nしかしここではElabを使ったコードは挙動が分かりづらいので、ゴリラになってASTを直接定義する方向で頑張ります。 エスパー能力はもっと難しいことをするために温存しておきましょう。\nそれでは genMyId を書きはじめましょう。\ngenMyId : Elab () genMyId = do -- ... 使うAPIは declareType と defineFunction です。 ドキュメントから関連する型を辿ってみて下さい。\nそしてエスパーして使い方を習得します。 するとこう使えるはずです。\ngenMyId : Elab () genMyId = do let name = `{{myId}} let x = `{{x}} let a = `{{a}} -- myId : {a: Type} -\u0026gt; a -\u0026gt; a let ty = Declare name [MkFunArg a RType Implicit Erased, MkFunArg x (Var a) Explicit Erased] (Var a) -- myId = \\{a: Type} =\u0026gt; \\(x: a) =\u0026gt; x let clause = MkFunClause (Var name) (RBind a (Lam RType) (RBind x (Lam (Var a)) (Var x))) let f = DefineFun name [clause] declareType ty defineFunction f ちょっと分かりづらい部分だけ解説します。 解説とはいっても私がエスパーした結果なので合ってるか分かりませんが。\nコアでの構文 今回生成するのは \\x =\u0026gt; x ですが、ジェネリクスなので内部ではそのパラメータが増えてます。 \\{a: Type} =\u0026gt; (\\(x: a) =\u0026gt; x) 相当のものをASTで書いています。\nMkFunArg MkFunArg a RType Implicit Erased\nと書かれている部分です。 MkFunArg 名前 型 Plicity Erased? です。\n 名前：Idrisの型宣言では引数に名前を書くことができますが、ASTでは必須です。 型：型の名前を書きます。ただし Type 型だけは組込みなので RType を書きます。 Plicity： {} な引数は Implicit 、 () な引数はExplicitです。 Erased?：基本 Erased です。型を値として取り出すときだけ NotErased を使います  MkFunClause 変数を導入する系の構文はすべて RBind にまとめられているようです。 関数は RBind 変数名 (Lam 型) 本体 の構文で作ります。\nこれで生成された関数のcore表現を見てみましょう。\nIdris\u0026gt; :core myId myId : (a : Type) → (x : a) → a myId ↦ λ a . λ x . x 解説通りですね。\nElabで関数生成その2 先程は以下のような関数を生成しました。\nmyId : a -\u0026gt; a myId = \\(x: a) =\u0026gt; x 次は少しだけ構文を変えて、以下のように定義します。\nmyId : a -\u0026gt; a myId x = x これは以下のようなスクリプトで生成できます。\ngenMyId2 : Elab () genMyId2 = do let name = `{{myId2}} let a = `{{a}} let x = `{{x}} -- myId2 : {a: Type} -\u0026gt; a -\u0026gt; a let ty = Declare name [MkFunArg a RType Implicit Erased, MkFunArg x (Var a) Explicit Erased] (Var a) -- myId2 x = x let clause = MkFunClause (RBind a (PVar RType) (RBind x (PVar (Var a)) (RApp (RApp (Var name) (Var a)) (Var x)))) (RBind a (PVar RType) (RBind x (PVar (Var a)) (Var x))) let f = DefineFun name [clause] declareType ty defineFunction f これもややこしいところだけ解説しておきます。\n変数の導入 新しい変数を導入するのにも RBind を使うようです。 新しい変数というのは myId x = の x のことです。 (RBind x (PVar (Var a)) ...) の構文になってますね。 そしてここで a という変数がでてきました。これも引数で受け取るので、こうなります。 (RBind a (PVar RType) (RBind x (PVar (Var a)) ...))\nさらに加えてややこしいのが、右辺、 x の方にも同時に変数の導入が必要です。 なので右辺もこうなってます。 (RBind a (PVar RType) (RBind x (PVar (Var a)) ...))\n関数定義の構文 myId a = は\n(RApp (Var name) (Var x)) 。 App 使うんだって驚きですね。\nこれもコア表現を見てみましょう。\nIdris\u0026gt; :core myId2 myId2 : (a : Type) → (x : a) → a var a : Type, x : a . myId2 a x ↦ x パターンマッチ パターンマッチするコードを生成してみましょう。\nmyNot : Bool -\u0026gt; Bool myNot True = False myNot False = True こうなります。\ngenNot : Elab () genNot = do let name = `{{myNot}} let bool = `{{Prelude.Bool.Bool}} let true = `{{Prelude.Bool.True}} let false = `{{Prelude.Bool.False}} b \u0026lt;- gensym \u0026#34;b\u0026#34; -- myNot : Bool -\u0026gt; Bool let ty = Declare name [MkFunArg b (Var bool) Explicit NotErased] (Var bool) -- myNot True = False let clauseTrue = MkFunClause (RApp (Var name) (Var true)) (Var false) -- myNot False = True let clauseFalse = MkFunClause (RApp (Var name) (Var false)) (Var true) let f = DefineFun name [clauseTrue, clauseFalse] declareType ty defineFunction f %runElab genNot 以下のことを押えましょう。\n 既存の名前は完全修飾名で指定する gensym がある パターンマッチは節を複数にすればできる  ジェネリクスがないので簡単ですね。\nderiving の実装 IdrisにはHaskellにある deriving Show, Eq のような機能がありません。 しかしメタプログラミングを使えばこれも実装できるはずです。やってみましょう。\n最終的には以下のコードを書くと\ndata Janken = Gu | Choki | Pa %runElab deriveShow `{{Main.Janken}} 以下が生成されるスクリプトを目指します。\nShow Janken where show Gu = \u0026#34;Gu\u0026#34; show Choki = \u0026#34;Choki\u0026#34; show Pa = \u0026#34;Pa\u0026#34; myShow まずは実験的にデータ型の型名を受け取ったら「そのデータ型を文字列にする関数 myShow」 を定義するスクリプトを書いてみましょう。\nイメージとしては以下のコードを書くと\ndata Janken = Gu | Choki | Pa %runElab (genShow `{{Main.Janken}}) 以下のコードを生成する感じです。\nmyShow : Janken -\u0026gt; String myShow Gu = \u0026#34;Gu\u0026#34; myShow Choki = \u0026#34;Choki\u0026#34; myShow Pa = \u0026#34;Pa\u0026#34; あんまり難しくなっても訳がわからなくなるので、データ型に型引数はなく、コンストラクタも全て引数をとらないものとします。\n実装を与えるとこうなります。\ngenShow : TTName -\u0026gt; Elab () genShow name = do let fname = `{{myShow}} dt \u0026lt;- lookupDatatypeExact name x \u0026lt;- gensym \u0026#34;x\u0026#34; let ty = Declare fname [MkFunArg x (Var name) Explicit NotErased] (RConstant StrType) let clauses = map (genClause fname) $ constructors dt let f = DefineFun fname clauses declareType ty defineFunction f where genClause : TTName -\u0026gt; (TTName, List CtorArg, Raw) -\u0026gt; FunClause Raw genClause fname (cname, _, _) = let NS (UN cnameStr) _ = cname in MkFunClause (RApp (Var fname) (Var cname)) (RConstant (Str cnameStr)) genClause で myShow Choki = \u0026quot;Choki\u0026quot; などの節を生成しています。 落ち着いて読めば難しくないですね。\nShow インタフェースの実装 今日一番のエスパーの使いどころですよ。\nElabでインタフェース関連の機能はこれだけです。\nIdris\u0026gt; :doc addImplementation Language.Reflection.Elab.Tactics.addImplementation : (ifaceName : TTName) -\u0026gt; (implName : TTName) -\u0026gt; Elab () Register a new implementation for interface resolution. Arguments: ifaceName : TTName -- the name of the interface for which an implementation is being registered implName : TTName -- the name of the definition to use in implementation search The function is: Total \u0026amp; export インタフェースの実装を追加するのですが、インタフェース名と実装名のみ引数にとります。 実装は…？\nちょっとよく分からないので show のコア表現をみてみましょう。\nλΠ\u0026gt; :core show Prelude.Show.show : (ty : Type) → (__interface : Prelude.Show.Show ty) → (x : ty) → String var ty : Type, {meth_0} : (x : ty) → String, {meth_1} : (d : Prelude.Show.Prec) → (x5 : ty) → String . Prelude.Show.show ty (constructor of Prelude.Show.Show \u0026lt;\u0026lt;\u0026lt;erased\u0026gt;\u0026gt;\u0026gt; {meth_0} {meth_1}) ↦ {meth_0} ふむふむ。ここで温存しておいたエスパー能力をフルに発揮します。 …はい。 __interface : Prelude.Show.Show ty や constructor of Prelude.Show.Show などからエスパーできましたね。 インタフェースの内部表現を作ればよいのです。\n例えば以下のようなインタフェースを定義したとします。\ninterface Name a where name: a -\u0026gt; String するとコア的にはだいたい以下のような表現へと変換されます。\ndata Name a = MkName (a -\u0026gt; a) name : (a : Type) -\u0026gt; Name a -\u0026gt; a -\u0026gt; a name _ (MkName f) = f 次にこれをStringに実装します。\nName String where name x = x すると以下のようなコア表現へとなります。\nstrName : Name String strName = MkName name where name : String -\u0026gt; String name x = x そして Name を使うコードを書きましょう。\ngetName : String -\u0026gt; String genName = name この関数にはコンパイラが型から strName が適切だとみつけ、暗黙に渡すのです。\ngetName : String -\u0026gt; String genName = name Strig strName ここまでくればもう分かりましたね。 「コンパイラが型から strName が適切だとみつけ」るために、コンパイラ内のDBに実装を登録する関数が addImplementation な訳です。\nこれで Show の実装方法が分かりました。 deriveShow 関数を書いていきましょう。\nderiveShow : TTName -\u0026gt; Elab () deriveShow name = ... ところで、上記の MkName に相当する Show のコンストラクタ名はなんでしょう。 コア言語では constructor of Prelude.Show.Show と表示されているので名前がなさそうですね。 名前がものを在らしめるなんて言葉がありますが、名前のないものを使うことはできません。 どうしたもんでしょう。\nでも大丈夫。Elabならデータ型さえ分かればリフレクションでコンストラクタを取り出せます。 そしてデータ型は Prelude.Show.Show です。これで完璧！\nShow の定義には2つのメソッドがあります。\ninterface Show ty where show : (x : ty) -\u0026gt; String show x = showPrec Open x -- Eta expand to help totality checker showPrec : (d : Prec) -\u0026gt; (x : ty) -\u0026gt; String showPrec _ x = show x Show のコンストラクタを仮に MkShow とすると、 MkShow myShow myShowPrec という呼び出しになるはずです。 あとは myShow と myShowPrec を定義するだけですね。 ここでデフォルト実装が与えられているのでそれを使いたいのですが、どこにあるか分からなかったのであきらめました。 myShow と myShowPrec 両方を定義します。\nmyShow と myShowPrec をそれぞれ定義する関数が書けたとして、 implement Show name は以下のように書けます。\nderiveShow : TTName -\u0026gt; Elab () deriveShow name = do dt \u0026lt;- lookupDatatypeExact name fshow \u0026lt;- genShow dt fshowPrec \u0026lt;- genShowPrec fshow dt let ifc = `{{Prelude.Show.Show}} inst \u0026lt;- gensym \u0026#34;showInst\u0026#34; ifcData \u0026lt;- lookupDatatypeExact ifc let [(ctor, _, _)] = constructors ifcData let instTy = Declare inst [] (RApp (Var ifc) (Var name)) let instClause = MkFunClause (Var inst) (RApp (RApp (RApp (Var ctor) (Var name)) (Var fshow)) (Var fshowPrec)) let instF = DefineFun inst [instClause] declareType instTy defineFunction instF addImplementation ifc inst where genShow : Datatype -\u0026gt; Elab TTName ... genShowPrec : TTName -\u0026gt; Datatype -\u0026gt; Elab TTName ... genShow はほぼさっき定義したものとおなじです。\ngenClause : TTName -\u0026gt; (TTName, List CtorArg, Raw) -\u0026gt; FunClause Raw genClause fname (cname, _, _) = let NS (UN cnameStr) _ = cname in MkFunClause (RApp (Var fname) (Var cname)) (RConstant (Str cnameStr)) genShow : Datatype -\u0026gt; Elab TTName genShow dt = do fshow \u0026lt;- gensym \u0026#34;show\u0026#34; x \u0026lt;- gensym \u0026#34;x\u0026#34; let ty = Declare fshow [MkFunArg x (Var name) Explicit NotErased] (RConstant StrType) let clauses = map (genClause fshow) $ constructors dt let f = DefineFun fshow clauses declareType ty defineFunction f pure fshow genShowPrec は新規コードですが、 show を呼び出すだけなのでそこまで難しくないでしょう。\ngenShowPrec fshow dt = do fshowPrec \u0026lt;- gensym \u0026#34;showPrec\u0026#34; let prec = `{{Prelude.Show.Prec}} a \u0026lt;- gensym \u0026#34;a\u0026#34; x \u0026lt;- gensym \u0026#34;x\u0026#34; ign \u0026lt;- gensym \u0026#34;ignore\u0026#34; -- showPrec : Prec -\u0026gt; name -\u0026gt; String let ty = Declare fshowPrec [MkFunArg `{{_er}} (Var prec) Explicit Erased, MkFunArg `{{y}} (Var name) Explicit Erased] (RConstant StrType) let clauseArg = (RApp (RApp (Var fshowPrec) (Var ign)) (Var x)) let clauseBody = (RBind ign (PVar (Var prec)) (RBind x (PVar (Var name)) (RApp (Var fshow) (Var x)))) -- showPrec _ x = show x let clause = MkFunClause (RBind ign (PVar (Var prec)) (RBind x (PVar (Var name)) clauseArg)) clauseBody let f = DefineFun fshowPrec [clause] declareType ty defineFunction f pure fshowPrec これで完成しました。全体を再掲するとこうです。\nderiveShow : TTName -\u0026gt; Elab () deriveShow name = do dt \u0026lt;- lookupDatatypeExact name fshow \u0026lt;- genShow dt fshowPrec \u0026lt;- genShowPrec fshow dt let ifc = `{{Prelude.Show.Show}} inst \u0026lt;- gensym \u0026#34;showInst\u0026#34; ifcData \u0026lt;- lookupDatatypeExact ifc let [(ctor, _, _)] = constructors ifcData let instTy = Declare inst [] (RApp (Var ifc) (Var name)) let instClause = MkFunClause (Var inst) (RApp (RApp (RApp (Var ctor) (Var name)) (Var fshow)) (Var fshowPrec)) let instF = DefineFun inst [instClause] declareType instTy defineFunction instF addImplementation ifc inst where genClause : TTName -\u0026gt; (TTName, List CtorArg, Raw) -\u0026gt; FunClause Raw genClause fname (cname, _, _) = let NS (UN cnameStr) _ = cname in MkFunClause (RApp (Var fname) (Var cname)) (RConstant (Str cnameStr)) genShow : Datatype -\u0026gt; Elab TTName genShow dt = do fshow \u0026lt;- gensym \u0026#34;show\u0026#34; x \u0026lt;- gensym \u0026#34;x\u0026#34; let ty = Declare fshow [MkFunArg x (Var name) Explicit NotErased] (RConstant StrType) let clauses = map (genClause fshow) $ constructors dt let f = DefineFun fshow clauses declareType ty defineFunction f pure fshow genShowPrec : TTName -\u0026gt; Datatype -\u0026gt; Elab TTName genShowPrec fshow dt = do fshowPrec \u0026lt;- gensym \u0026#34;showPrec\u0026#34; let prec = `{{Prelude.Show.Prec}} a \u0026lt;- gensym \u0026#34;a\u0026#34; x \u0026lt;- gensym \u0026#34;x\u0026#34; ign \u0026lt;- gensym \u0026#34;ignore\u0026#34; -- showPrec : Prec -\u0026gt; name -\u0026gt; String let ty = Declare fshowPrec [MkFunArg `{{_er}} (Var prec) Explicit Erased, MkFunArg `{{y}} (Var name) Explicit Erased] (RConstant StrType) let clauseArg = (RApp (RApp (Var fshowPrec) (Var ign)) (Var x)) let clauseBody = (RBind ign (PVar (Var prec)) (RBind x (PVar (Var name)) (RApp (Var fshow) (Var x)))) -- showPrec _ x = show x let clause = MkFunClause (RBind ign (PVar (Var prec)) (RBind x (PVar (Var name)) clauseArg)) clauseBody let f = DefineFun fshowPrec [clause] declareType ty defineFunction f pure fshowPrec それでは使ってみましょう。\ndata Janken = Gu | Choki | Pa %runElab deriveShow `{{Main.Janken}} これを動かしてみます。\nIdris\u0026gt; show Gu \u0026#34;Gu\u0026#34; : String Idris\u0026gt; show Choki \u0026#34;Choki\u0026#34; : String Idris\u0026gt; show Pa \u0026#34;Pa\u0026#34; : String Idris\u0026gt; :t show show : Show ty =\u0026gt; ty -\u0026gt; String ただしく動いていますね。 Idrisのpain pointであったderivingがないという問題を克服できました。\nまとめ Idrisのかなりユニークな機能であるElaboratorリフレクションを紹介しました。 そしてElabを使ったメタプログラミングのデモとして複雑でないデータ型に対して Show を生成できるスクリプトも示しました。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-25","title":"IdrisのElaboratorリフレクションでメタプログラミング","url":"https://KeenS.github.io/blog/2020/12/25/idrisnoelaboratorderifurekushon/"},
  {"body":"このエントリはIdris Advent Calendar 2020の24日目の記事です。 前はhiropon21さんでSnocList recursive viewを型駆動開発してみよう in Idris2 でした。 Idris2は1と比べて型システムが微妙に変わっており、ところどころ 0 a のようにその値を使える回数が表示されていたりしますね。\nκeenです。今回はIdrisのFFIとCodegenについて触れたいと思います。\nC Codegen いままであまり触れてきませんでしたが、Idrisは裏でCのコードを生成し、Cコンパイラがバイナリを作っています。コンパイラオプションをいじることでそれを垣間見ることができます。\n簡単なコードを書いて実験してみましょう。 codegen.idr という名前でファイルを保存します。\nmain : IO () main = putStrLn \u0026#34;Hello\u0026#34; コンパイラに -S （--codegenonly）オプションを渡すことで生成したCコードがみれます。\n$ idris -S codegen.idr -o codegen.c $ ls codegen.c codegen.c 中身を覗いてみましょう。長いので一部省略します。\n#include \u0026#34;math.h\u0026#34;#include \u0026#34;idris_rts.h\u0026#34;#include \u0026#34;idris_bitstring.h\u0026#34;#include \u0026#34;idris_stdfgn.h\u0026#34;void* _idris_assert_95_unreachable(VM*, VAL*); void* _idris_call_95__95_IO(VM*, VAL*); void* _idris_idris_95_crash(VM*, VAL*); void* _idris_io_95_bind(VM*, VAL*); void* _idris_io_95_pure(VM*, VAL*); void* _idris_Main_46_main(VM*, VAL*); void* _idris_mkForeignPrim(VM*, VAL*); void* _idris_prim_95__95_asPtr(VM*, VAL*); void* _idris_prim_95__95_eqManagedPtr(VM*, VAL*); void* _idris_prim_95__95_eqPtr(VM*, VAL*); void* _idris_prim_95__95_managedNull(VM*, VAL*); void* _idris_prim_95__95_null(VM*, VAL*); void* _idris_prim_95__95_peek16(VM*, VAL*); void* _idris_prim_95__95_peek32(VM*, VAL*); void* _idris_prim_95__95_peek64(VM*, VAL*); void* _idris_prim_95__95_peek8(VM*, VAL*); void* _idris_prim_95__95_peekDouble(VM*, VAL*); void* _idris_prim_95__95_peekPtr(VM*, VAL*); void* _idris_prim_95__95_peekSingle(VM*, VAL*); void* _idris_prim_95__95_poke16(VM*, VAL*); void* _idris_prim_95__95_poke32(VM*, VAL*); void* _idris_prim_95__95_poke64(VM*, VAL*); void* _idris_prim_95__95_poke8(VM*, VAL*); void* _idris_prim_95__95_pokeDouble(VM*, VAL*); void* _idris_prim_95__95_pokePtr(VM*, VAL*); void* _idris_prim_95__95_pokeSingle(VM*, VAL*); void* _idris_prim_95__95_ptrOffset(VM*, VAL*); void* _idris_prim_95__95_readChars(VM*, VAL*); void* _idris_prim_95__95_readFile(VM*, VAL*); void* _idris_prim_95__95_registerPtr(VM*, VAL*); void* _idris_prim_95__95_sizeofPtr(VM*, VAL*); void* _idris_prim_95__95_stderr(VM*, VAL*); void* _idris_prim_95__95_stdin(VM*, VAL*); void* _idris_prim_95__95_stdout(VM*, VAL*); void* _idris_prim_95__95_vm(VM*, VAL*); void* _idris_prim_95__95_writeFile(VM*, VAL*); void* _idris_prim_95__95_writeString(VM*, VAL*); void* _idris_prim_95_io_95_bind(VM*, VAL*); void* _idris_run_95__95_IO(VM*, VAL*); void* _idris_unsafePerformPrimIO(VM*, VAL*); void* _idris_world(VM*, VAL*); void* _idris__123_APPLY_95_0_125_(VM*, VAL*); void* _idris__123_APPLY2_95_0_125_(VM*, VAL*); void* _idris__123_EVAL_95_0_125_(VM*, VAL*); void* _idris__123_runMain_95_0_125_(VM*, VAL*); void* _idris_io_95_bind_95_IO_95__95_idr_95_108_95_34_95_108_95_36_95_case(VM*, VAL*); // ....  void* _idris_Main_46_main(VM* vm, VAL* oldbase) { INITFRAME; loop: RESERVE(1); ADDTOP(1); LOC(1) = MKSTR(vm, \u0026#34;Hello\u0026#34;\u0026#34;\\x0a\u0026#34;\u0026#34;\u0026#34;); LOC(1) = MKINT((i_int)(idris_writeStr(stdout,GETSTR(LOC(1))))); RVAL = NULL_CON(0); TOPBASE(0); REBASE; } // ...  典型的なCコードジェネレータですね。\n因みにここで使われている idris_writeStr は idris_stdfgn.c で定義されていて、以下のような実装になっています。\nint idris_writeStr(void* h, char* str) { FILE* f = (FILE*)h; if (fputs(str, f) \u0026gt;= 0) { return 0; } else { return -1; } } 意外と素直な実装です。 その他大文字のものはマクロ（や関数）で定義されています。\n#define ADDTOP(x) vm-\u0026gt;valstack_top += (x) JavaScript Codegen Cのコードを吐くのがデフォルトの挙動ですが、別のコードジェネレータを使うこともできます。 コードジェネレータ自体はプラグインとして作れるのでサードパーティも含めれば色々あるのですが、コンパイラに同梱されているものにJavaScriptがあります。\nこちらもコード生成してみましょう。 --codegen javascript をつけるとJavaScriptのコードを吐いてくれます。\n$ idris --codegen javascript -S codegen.idr -o codegen.js JavaScriptのバックエンドの方は比較的小さいのでそのまま貼ってみます。\n\u0026#34;use strict\u0026#34;; (function(){ const $JSRTS = { throw: function (x) { throw x; }, Lazy: function (e) { this.js_idris_lazy_calc = e; this.js_idris_lazy_val = void 0; }, force: function (x) { if (x === undefined || x.js_idris_lazy_calc === undefined) { return x } else { if (x.js_idris_lazy_val === undefined) { x.js_idris_lazy_val = x.js_idris_lazy_calc() } return x.js_idris_lazy_val } }, prim_strSubstr: function (offset, len, str) { return str.substr(Math.max(0, offset), Math.max(0, len)) } }; $JSRTS.prim_systemInfo = function (index) { switch (index) { case 0: return \u0026#34;javascript\u0026#34;; case 1: return navigator.platform; } return \u0026#34;\u0026#34;; }; $JSRTS.prim_writeStr = function (x) { return console.log(x) }; $JSRTS.prim_readStr = function () { return prompt(\u0026#39;Prelude.getLine\u0026#39;) }; $JSRTS.die = function (message) { throw new Error(message) }; const $HC_0_0$MkUnit = ({type: 0}); // Main.main  function Main__main($_0_in){ const $_1_in = $JSRTS.prim_writeStr(\u0026#34;Hello\\n\u0026#34;); return $HC_0_0$MkUnit; } // {runMain_0} function $_0_runMain(){ return $JSRTS.force(Main__main(null)); } $_0_runMain(); }.call(this)) 生成したコードはそのままNodeで動かせます。\n$ node codegen.js Hello 試してないですがブラウザでも動くはずです。\n因みにNode専用ならNodeバックエンドもあるので --codegen node という書き方もできます。 未確認ですがこっちの方が標準出入力の扱いが上手そうです。\n// Node codegenのランタイムのコード抜粋 $JSRTS.prim_writeStr = function (x) { return process.stdout.write(x) }; $JSRTS.prim_readStr = function () { var ret = \u0026#39;\u0026#39;; var b = Buffer.alloc(1024); var i = 0; while (true) { $JSRTS.fs.readSync(0, b, i, 1) if (b[i] == 10) { ret = b.toString(\u0026#39;utf8\u0026#39;, 0, i); break; } i++; if (i == b.length) { var nb = Buffer.alloc(b.length * 2); b.copy(nb) b = nb; } } return ret; }; C FFI IdrisにはFFIの仕組みがあります。 特にデフォルトのcodegenバックエンドであるCのFFIは重要です。 例えばプレリュードの File は以下のようにFFIをベースに組み立てられています。\ndata File : Type where FHandle : (p : Ptr) -\u0026gt; File export fflush : File -\u0026gt; IO () fflush (FHandle h) = foreign FFI_C \u0026#34;fflush\u0026#34; (Ptr -\u0026gt; IO ()) h 公式でバックエンドを複数提供しつつプレリュードでCに依存するのはどうなんだというツッコみはありますが、それはおいておいてファイルIOなどの基本的操作が言語組み込みではなくてユーザランドで実装されているのは楽しいですね。\nさて、もう少しFFIについて解説しておくと、キーになるのは foreign 関数です。\nIdris\u0026gt; :type foreign foreign : (f : FFI) -\u0026gt; ffi_fn f -\u0026gt; (ty : Type) -\u0026gt; {auto fty : FTy f [] ty} -\u0026gt; ty Idris\u0026gt; :doc FTy Data type FTy : FFI -\u0026gt; List Type -\u0026gt; Type -\u0026gt; Type The function is: public export Constructors: FRet : ffi_types f t -\u0026gt; FTy f xs (IO\u0026#39; f t) The function is: public export FFun : ffi_types f s -\u0026gt; FTy f (s :: xs) t -\u0026gt; FTy f xs (s -\u0026gt; t) The function is: public export C FFIに限っていえば foreign C_FFI \u0026quot;関数名\u0026quot; (対応するIdrisの型) という使い方になるでしょうか。\nC FFIを使うにあたって、Cのオブジェクトファイルをリンクする必要がありますよね？ それ専用のIdrisのディレクティブもあります。 実例で確かめてみましょう。\nまずはリンクするCのオブジェクトファイルを用意しておきましょう。 一番シンプルな内容でいきます。 以下の内容を ffi.h に保存しておきます。\nint add(int, int); そして ffi.c に以下を記述します。\n#include \u0026#34;ffi.h\u0026#34; int add(int x, int y) { return x + y; } これは一旦コンパイルしておきましょう。\n$ gcc -c -o ffi.o ffi.c これを使うIdrisのコードを書きます。\nCのオブジェクトファイルを使う手段として、2つのディレクティブがあります。 %include と %link です。それぞれ %include バックエンド \u0026quot;インクルードするファイル名\u0026quot; 、 %link バックエンド \u0026quot;リンクするファイル名\u0026quot; の構文です。 ちゃんとドキュメントには載ってないのですが、CにおいてはそれぞれCPPの #include 、コンパイラの引数へと変換されると思っていてよさそうです。\nこれをふまえて、まず ffi.idr の先頭に以下を書きます。\n%include C \u0026#34;ffi.h\u0026#34; %link C \u0026#34;ffi.o\u0026#34; int add(int, int); を呼び出すコードを書きましょう。 FFIをした返り値は IO でないといけないようなので以下のコードを書きます。\nffiAdd : Int -\u0026gt; Int -\u0026gt; IO Int ffiAdd = foreign FFI_C \u0026#34;add\u0026#34; (Int -\u0026gt; Int -\u0026gt; IO Int) これを使う main はこう書きましょう。\nmain : IO () main = do ret \u0026lt;- ffiAdd 1 2 printLn ret これをコンパイル・実行します。\n$ idris ffi.idr -o ffi $ ./ffi 3 簡単にではありますがC FFIを実行できました。\n因みに %include は本当に #include \u0026quot;...\u0026quot; しているだけのようです。 試しに %include してcodegenしてみたらファイルの先頭に #include が足されてました。\n#include \u0026#34;ffi.h\u0026#34; #include \u0026#34;math.h\u0026#34; #include \u0026#34;idris_rts.h\u0026#34; #include \u0026#34;idris_bitstring.h\u0026#34; #include \u0026#34;idris_stdfgn.h\u0026#34; void* _idris_Prelude_46_Bool_46__38__38_(VM*, VAL*); // ... JavaScript FFI Cと同様にJavaScrptバックエンドでもFFIができます。\nCと同じように add 関数を定義した ffi.js を用意します。\nfunction add(x, y) { return x + y; } %include はCと同様です。 %link はどうも意味を成さないようです。\n%include JavaScript \u0026#34;ffi.js\u0026#34; C FFIと同じようなコードを書くと、このような書き方になります。\nffiAdd : Int -\u0026gt; Int -\u0026gt; JS_IO Int ffiAdd = foreign FFI_JS \u0026#34;add(%0, %1)\u0026#34; (Int -\u0026gt; Int -\u0026gt; JS_IO Int)  IO は JS_IO になる 関数名のところは関数名ではなく、テンプレートを書く  %0.method(%1, %2) のような書き方もできるよう   これを使う mainも以下のようになります。\nmain : JS_IO () main = do ret \u0026lt;- ffiAdd 1 2 printLn\u0026#39; ret main も IO ではなく JS_IO になります。\nこのコードをコンパイル・実行してみましょう。\n$ idris --codegen javascript ffi.idr -o ffi_gen.js $ node ffi_gen.js 3 動いているようです。\n因みに Node バックエンドを使うときは %include の第一引数が JavaScript ではなく Node になります。それ以外は共通です。 両方とも同じファイルをインクルードするなら2つともまとめて書いてしまえばよいでしょう。\n%include JavaScript \u0026#34;ffi.js\u0026#34; %include Node \u0026#34;ffi.js\u0026#34; JavaScriptバックエンドに関しては興味のある方が多いかと思いますが、申し訳ないことに私がそこまで詳しくないのであんまり詳細な内容が書けません。 参考リンクを貼っておくので各自で試行錯誤してみて下さい。\n IdrisでWebアプリを書く New Foreign Function Interface — Idris 1.3.3 documentation  因みにCと同様、 %include は本当にファイルの中身を展開しているだけのようです。\n// ...  $JSRTS.prim_writeStr = function (x) { return console.log(x) }; $JSRTS.prim_readStr = function () { return prompt(\u0026#39;Prelude.getLine\u0026#39;) }; $JSRTS.die = function (message) { throw new Error(message) }; $JSRTS.jsbn = (function () { // ... }).call(this); function add(x, y) { return x + y; } // ...  まとめ Idrisがバックエンドを複数持つこと、それぞれのバックエンドにFFIがあることを紹介しました。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-24","title":"IdrisのFFIとCodegen（C、JavaScript）","url":"https://KeenS.github.io/blog/2020/12/24/idrisnoffitocodegen_c_javascript_/"},
  {"body":"このエントリはIdris Advent Calendar 2020の22日目の記事です。\nκeenです。今回は依存型を使って部分的に正しさを証明したデータ構造を作っていきたいと思います。 慣れてない人には難しめの内容になるかもしれません。\n証明オブジェクト 本題に入る前に、依存型の難しさについて触れたいと思います。\n自然数から1引く dec 関数を定義します。 以下のようなコードになりますよね？\ndec : Nat -\u0026gt; Nat dec n = n - 1 ところがこれ、コンパイルエラーになります。 メッセージは以下です。\n- + Errors (1) `-- dec.idr line 3 col 10: When checking right hand side of dec with expected type Nat When checking argument smaller to function Prelude.Nat.-: Can\u0026#39;t find a value of type LTE 1 n 何故か \u0026ldquo;Can\u0026rsquo;t find a value of type\u0026rdquo; といってますね。これは Nat.(-) のドキュメントを見ると分かります。\nPrelude.Nat.(-) : (m : Nat) -\u0026gt; (n : Nat) -\u0026gt; {auto smaller : LTE n m} -\u0026gt; Nat infixl 8 The function is: Total \u0026amp; public export 引数に m と n の他に {auto smaller : LTE n m} がありますね。 これは 証明オブジェクト を要求しているのです。 どういうことか説明しましょう。\nまず、今計算している対象は自然数なので負になれません。 そもそも自由に引き算できない対象な訳です。 ですが、引かれる数が引く数以上であれば結果が0以上であることが保証できるので計算できますね。 Nat.(-) はそういうケースを想定したAPIです。 この「引かれる数が引く数以上である」を表わす値が証明オブジェクトです。 このことは LTE のドキュメントからも確認できます。\nIdris\u0026gt; :doc LTE Data type Prelude.Nat.LTE : (n : Nat) -\u0026gt; (m : Nat) -\u0026gt; Type Proofs that n is less than or equal to m Arguments: n : Nat -- the smaller number m : Nat -- the larger number The function is: public export LTE n m で n \u0026lt;= m を表わします。\nこれを踏まえて Prelude.Nat.(-) の型を意訳すると、 「m から n を引きたければ n が m 以下である証明をもってこい」となるのです。 言われてみればそうですよね。\nここまでの話が分からなかったら、以下のことだけ覚えておいて下さい\n「自然数同士の引き算は面倒くさい」\nこれを押さえたら本題に入ります。\nAVL木 AVL木とは平衡二分探索木の1種です。 二分木なので左右の腕がある訳ですが、その腕同士の高さが、高々1しか違わない木です。 ここではあまり説明しないのでWikipediaの記事を読んで下さい\n1つだけ重要なのは木の回転という操作があることです。 新たに要素を追加した結果、左右の腕の高さが2違うようになることがあります。 そうなった場合に木を組み替えて左右の腕の高さが高々1しか違わないようにする操作が回転です。\nこの木の高さを正しく維持するのは複雑で、よく間違えます。 なので依存型を使ってコンパイル時に正しいことを保証しよう、というのが今回の趣旨です。\n依存型を使ったAVL木の定義 定義1 高さ h のAVL木の左右の腕の高さは h - 1 または h - 2 （ただし左右同時に h - 2 にはならない）です。 正確には木の高さを $h$ 、左の木の高さを $hl$ 、 右の木の高さを $hr$ としたとき、以下の関係式を満たします。\n\\[ (hl = h - 2 \\land hr = h - 1) \\lor (hl = h - 1 \\land hr = h - 1) \\lor (hl = h - 1 \\land hr = h - 2) \\]\nこれを型にエンコードしたAVL木を定義すればよさそうです。 ただし先程紹介したように - は扱いが面倒なので移項して足し算にして、以下の定義が考えられます。\ninfixr 1 \\/, /\\ (\\/) : Type -\u0026gt; Type -\u0026gt; Type (\\/) a b = Either a b (/\\) : Type -\u0026gt; Type -\u0026gt; Type (/\\) a b = (a, b) data Tree : (n: Nat) -\u0026gt; (a : Type) -\u0026gt; Type where Leaf: Tree Z a Node : {l, m: Nat} -\u0026gt; ((2 + l = n) /\\ (1 + m = n)) \\/ ((1 + l = n) /\\ (1 + m = n)) \\/ ((1 + l = n) /\\ (2 + m = n)) -\u0026gt; Tree l a -\u0026gt; a -\u0026gt; Tree m a -\u0026gt; Tree n a Node 引数のの前半が重いですね。 これは何をしているかというと、証明オブジェクトを受け取っているということになります。\nこれでも正しくエンコードできているのですが、例の「面倒くさい」証明オブジェクトが登場してしまいました。 証明オブジェクトが出てきても面倒なだけでプログラムは書けるのですが、どうしても冗長になりがちです。 試しにこの定義に対して操作を書いてみたら、後で出てくる6行の関数 rotateR がこの定義だと48行になってました。 ちょっとやってられないので別の定義を採ることにします。\n定義2 先程は条件分岐を1箇所に押し込もうとして冗長になってました。 条件分岐は左が右より1高い、左右が同じ高さ、右が左より1高いの3通りです。 であれば、3通りをバラしてしまえばよさそうです。 するとこういう定義ができあがります。\ndata Tree : Nat -\u0026gt; (a : Type) -\u0026gt; Type where Leaf: Tree Z a Lefty : Tree (S n) a -\u0026gt; a -\u0026gt; Tree n a -\u0026gt; Tree (S (S n)) a Mid : Tree n a -\u0026gt; a -\u0026gt; Tree n a -\u0026gt; Tree (S n) a Righty : Tree n a -\u0026gt; a -\u0026gt; Tree (S n) a -\u0026gt; Tree (S (S n)) a これでもおおむねよいのですが、左右の高さに関係のない関数が冗長になってしまいます。 例えば要素が含まれるかを検査する member 関数は3回同じことを書かないといけなくなります。\ntotal member : Ord a =\u0026gt; a -\u0026gt; Tree n a -\u0026gt; Bool member _ Leaf = False member x (Lefty l v r) with (compare x v) | LT = member x l | EQ = True | GT = member x r member x (Mid l v r) with (compare x v) | LT = member x l | EQ = True | GT = member x r member x (Righty l v r) with (compare x v) | LT = member x l | EQ = True | GT = member x r このくらいであれば必要経費とすることもできるのですが、もうちょっと上手くやる方法があります。\n定義3 Viewのことを思い出してほしいのですが、依存型で値同士の関係をうまいこと制御できるのでした。 この仕組みを使うともう少し整理できます。 左右の木の高さを表現するビューと、実際のデータ構造に分けて管理するのです。\ndata Balance : Nat -\u0026gt; Nat -\u0026gt; Nat -\u0026gt; Type where Lefty : Balance (S n) (S (S n)) n Mid : Balance n (S n) n Righty : Balance n (S (S n)) (S n) data Tree : Nat -\u0026gt; (a : Type) -\u0026gt; Type where Leaf : Tree Z a Node : Balance l n r -\u0026gt; Tree l a -\u0026gt; a -\u0026gt; Tree r a -\u0026gt; Tree n a これなら十分整理されていると言えるでしょう。この定義を使っていきます。\nAVL木の簡単な操作 以下のような簡単な操作ならすぐさま書けるでしょう。\ntotal empty : Tree Z a empty = Leaf total singleton : a -\u0026gt; Tree (S Z) a singleton x = Node Mid Leaf x Leaf total member : Ord a =\u0026gt; a -\u0026gt; Tree n a -\u0026gt; Bool member _ Leaf = False member x (Node _ l v r) with (compare x v) | LT = member x l | EQ = True | GT = member x r member 関数がちゃんと短かくなってるのがポイントですね。\nAVL木への挿入 AVL木は強めに平衡のとれた木なので要素を増減させる操作が重いです。\nちょっとずつ便利関数を積み重ねていきましょう。 まずはノードを作る関数3つ。\ntotal createR : Tree n a -\u0026gt; a -\u0026gt; Tree (S n) a -\u0026gt; Tree (S (S n)) a createR l x r = Node Righty l x r total createM : Tree n a -\u0026gt; a -\u0026gt; Tree n a -\u0026gt; Tree (S n) a createM l x r = Node Mid l x r total createL : Tree (S n) a -\u0026gt; a -\u0026gt; Tree n a -\u0026gt; Tree (S (S n)) a createL l x r = Node Lefty l x r ちゃんと高さが正しいものしか作れないような型になっています。 一方でそのために create 関数が3種類に分かれてしまっています。\n次が木の右回転をする rotateR 関数です。\ntotal rotateR : Tree (S (S n)) a -\u0026gt; a -\u0026gt; Tree n a -\u0026gt; Either (Tree (S (S n)) a) (Tree (S (S (S n))) a) rotateR (Node Lefty ll lv lr) v r = Left $ createM ll lv (createM lr v r) rotateR (Node Mid ll lv lr) v r = Right $ createR ll lv (createL lr v r) rotateR (Node Righty ll lv (Node Lefty lrl lrv lrr)) v r = Left $ createM (createM ll lv lrl) lrv (createR lrr v r) rotateR (Node Righty ll lv (Node Mid lrl lrv lrr)) v r = Left $ createM (createM ll lv lrl) lrv (createM lrr v r) rotateR (Node Righty ll lv (Node Righty lrl lrv lrr)) v r = Left $ createM (createL ll lv lrl) lrv (createM lrr v r) 実装は二分木の回転を実装したことのある方なら見慣れてるかと思いますが、型がちょっと独特です。 返り型 Either (Tree (S (S n)) a) (Tree (S (S (S n))) a) と Either の形になっています。 木の回転をすると高さが1増える場合と増えない場合があるのです。その場合分けのために Either を使っています。 Left が高さが変わらない場合で、 Right が高さが1増える場合ですね。 依存型のついていない普通の関数なら高さが違っても型は同じなので気にしなくていいのですが、今回は必要な分岐です。\nこれと同様に左回転の rotateL も実装できます。\ntotal rotateL : Tree n a -\u0026gt; a -\u0026gt; Tree (S (S n)) a -\u0026gt; Either (Tree (S (S n)) a) (Tree (S (S (S n))) a) rotateL l v (Node Lefty (Node Lefty rll rlv rlr) rv rr) = Left $ createM (createM l v rll) rlv (createR rlr rv rr) rotateL l v (Node Lefty (Node Mid rll rlv rlr) rv rr) = Left $ createM (createM l v rll) rlv (createM rlr rv rr) rotateL l v (Node Lefty (Node Righty rll rlv rlr) rv rr) = Left $ createM (createL l v rll) rlv (createM rlr rv rr) rotateL l v (Node Mid rl rv rr) = Right $ createL (createR l v rl) rv rr rotateL l v (Node Righty rl rv rr) = Left $ createM (createM l v rl) rv rr それでは準備が整ったので挿入を定義しましょう。 挿入は回転と同じく木の高さが変わったり変わらなかったりする操作です。 なので型は以下のようになります。\ntotal insert : Ord a =\u0026gt; a -\u0026gt; Tree n a -\u0026gt; Either (Tree n a) (Tree (S n) a) 続いて簡単な場合から潰していきましょう。 Leaf への挿入はシングルトンで一撃です。高さは1増えます。\ninsert x Leaf = Right $ singleton x それ以外の場合はノードの値と挿入しようとしてる値の大小関係を比較して with 構文でひとまとめにパターンマッチしましょう。\ninsert x (Node bal l v r) with (compare x v) それぞれ場合分けしていくのですが、 x と v が等しい場合は挿入せずにそのまま終了します。\ninsert x (Node bal l v r) | EQ = Left $ Node bal l v r x が v より小さい場合は左の木に x を挿入します。\nここで Balance の値に応じて依存型で使っている数値が変化することを思い出して下さい。 この挙動を利用するには Balance の値に対してパターンマッチしないといけません。 ちょっと面倒ですが Balance の値で分岐したあとに x を左の木に挿入することになります。。 つまりこのようなコードになります。\ninsert x (Node Lefty l v r) | LT = case insert x l of ... insert x (Node Mid l v r) | LT = case insert x l of ... insert x (Node Righty l v r) | LT = case insert x l of ... それぞれのケースで、 Left の場合、すなわち挿入前と挿入後で木の高さが変わらなかった場合は挿入前と Balance は変わりません。\ninsert x (Node Lefty l v r) | LT = case insert x l of Left l =\u0026gt; Left $ Node Lefty l v r ... insert x (Node Mid l v r) | LT = case insert x l of Left l =\u0026gt; Left $ Node Mid l v r ... insert x (Node Righty l v r) | LT = case insert x l of Left l =\u0026gt; Left $ Node Righty l v r ... Right の場合、すなわち挿入前から高さが1増えた場合は Righty → Mid 、 Mid → Lefty へと変化します。では Lefty の場合はどうなるかというと、回転が発生します。左に寄りすぎたので右回転ですね。\ninsert x (Node Lefty l v r) | LT = case insert x l of ... Right l =\u0026gt; rotateR l v r insert x (Node Mid l v r) | LT = case insert x l of ... Right l =\u0026gt; Right $ Node Lefty l v r insert x (Node Righty l v r) | LT = case insert x l of ... Right l =\u0026gt; Left $ Node Mid l v r これと同様に x が v より大きい場合も書けますね。 総合して insert は以下のような見た目になります。\ntotal insert : Ord a =\u0026gt; a -\u0026gt; Tree n a -\u0026gt; Either (Tree n a) (Tree (S n) a) insert x Leaf = Right $ singleton x insert x (Node bal l v r) with (compare x v) insert x (Node bal l v r) | EQ = Left $ Node bal l v r insert x (Node Lefty l v r) | LT = case insert x l of Left l =\u0026gt; Left $ Node Lefty l v r Right l =\u0026gt; rotateR l v r insert x (Node Mid l v r) | LT = case insert x l of Left l =\u0026gt; Left $ Node Mid l v r Right l =\u0026gt; Right $ Node Lefty l v r insert x (Node Righty l v r) | LT = case insert x l of Left l =\u0026gt; Left $ Node Righty l v r Right l =\u0026gt; Left $ Node Mid l v r insert x (Node Lefty l v r) | GT = case insert x r of Left r =\u0026gt; Left $ Node Lefty l v r Right r =\u0026gt; Left $ Node Mid l v r insert x (Node Mid l v r) | GT = case insert x r of Left r =\u0026gt; Left $ Node Mid l v r Right r =\u0026gt; Right $ Node Righty l v r insert x (Node Righty l v r) | GT = case insert x r of Left r =\u0026gt; Left $ Node Righty l v r Right r =\u0026gt; rotateL l v r 依存型で高さを保ったAVL木の操作が書けました。 型で高さに矛盾がないことを表現しているので、テストなどを書かなくても高さについてはバグがないことが保証できます。\nこれで木を作れるようになったので試してみましょう。 (insert 1 (insert 10 (insert 3 (insert 1 empty)))) で 1 、 10 、 3 が入った木を作れるはずです。\nIdris\u0026gt; :let tree = (insert 1 (insert 10 (insert 3 (insert 1 empty)))) (input):1:14-61:When checking an application of function Main.insert: Type mismatch between Tree n1 a2 \\/ Tree (S n1) a2 (Type of insert _ _) and Tree n a (Expected type) Specifically: Type mismatch between Either (Tree n1 a2) (Tree (S n1) a2) and Tree n a …あれ？何やらエラーが出ていますね。 思い出すと insert の返り型は Either (Tree n a) (Tree (S n) a) なので木ではなく Either 型の値が返っています。これでは連続して insert できませんね。\nもう少し言うとこの木を使うユーザに、木の高さで分岐を強要するAPIになっています。 これはいささか以上に不便です。 内部の正しさを保証するのに木の高さを型にエンコードするのはよいのですが、APIでは型から木の高さを消しましょう。\n依存ペアによる型消去 APIでは型から木の高さを消しましょうといいましたが、型を消去するなんてできるのでしょうか。 結論からいうと、できます。 くどい話は先送りにして、以下のように書けば型から高さの情報を消せます。\ndata Set : Type -\u0026gt; Type where MkSet : (n: Nat ** Tree n a) -\u0026gt; Set a ここでポイントになるのが (n: Nat ** Tree n a) という型です。 「ある自然数 n が存在して、高さ n なる木 Tree n a 」を表現しています。\nこの型は依存ペア、依存和、Σ型などと呼ばれます（公式ドキュメントでは依存ペア）。 文法がちょっと変わってるのですが、 (変数名: 型 ** \u0026lt;変数を使った型\u0026gt;) の構文です。 さきほど「ある 〜 が存在して」と紹介しましたが、論理学でいう存在量化に相当する機能です。\n依存ペアを使うことで依存型を消去できるのです。説明が難しいので細かな解説はあきらめます。\nさて、この定義を使ってAPIを定義していきましょう。\n手始めに、さっきまでのコードを Internal の名前空間に押し込めましょう。\nnamespace Internal data Balanse ... ... total inssert : ... ... そしてAPIを定義しはじめます。\ndata Set : Type -\u0026gt; Type where MkSet : (n: Nat ** Internal.Tree n a) -\u0026gt; Set a なんだかんだ、APIとして提供できるのは empty 、 insert 、 member くらいですね。これらのラッパーを書きましょう。\nまずは empty 。\ntotal empty : Set a empty = MkSet (_ ** Internal.empty) 依存ペアの値は (値 ** 値) の構文で作ります。 ところが左側の値、ここでいうの高さは右側の値から簡単に分かります。 そういう場合は _ と書くとコンパイラが勝手に埋めてくれます。\nmember 関数も簡単ですね。\ntotal member : Ord a =\u0026gt; a -\u0026gt; Set a -\u0026gt; Bool member x (MkSet (_ ** tree)) = Internal.member x tree insert もほぼラップするだけですが、返り値が Either なのを思い出して Left と Right で処理を分けます。\ntotal insert : Ord a =\u0026gt; a -\u0026gt; Set a -\u0026gt; Set a insert x (MkSet (_ ** tree)) = case Internal.insert x tree of Left t =\u0026gt; MkSet (_ ** t) Right t =\u0026gt; MkSet (_ ** t) 因みに木の高さは値として保存されているので取り出すこともできます。\ntotal height : Set a -\u0026gt; Nat height (MkSet (height ** _)) = height さてさて、これで役者が揃ったので今度こそ動いているか試せます。\nIdris\u0026gt; :let tree = (insert 1 (insert 10 (insert 3 (insert 1 empty)))) defined Idris\u0026gt; member 1 tree True : Bool Idris\u0026gt; member 2 tree False : Bool Idris\u0026gt; member 3 tree True : Bool Idris\u0026gt; member 9 tree False : Bool Idris\u0026gt; member 10 tree True : Bool ちゃんと動いてますね。\nまとめ 依存型によって木の高さが正しいことが保証されたAVL木を作りました。 その過程で証明オブジェクトや依存ペアなどの機能も学びました。\n付録: 今回のコード ","categories":["依存型","Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/%e4%be%9d%e5%ad%98%e5%9e%8b","/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-23","title":"Idrisの依存型で高さが100%正しいAVL木を定義する","url":"https://KeenS.github.io/blog/2020/12/23/idrisdetakasaga100_tadashiiavlkiwoteigisuru/"},
  {"body":"このエントリはIdris Advent Calendar 2020の21日目の記事です。 前はmock_beginnerさんでIdrisとはじめる型駆動開発でした。\nκeenです。大ネタが続いたのでそろそろ小ネタでも。文芸的プログラミングの機能です。\n文芸的プログラミングはドナルド・クヌースの提唱したプログラミングスタイルです。 普通のプログラムがプログラムの中にコメントとして文章を埋め込むのに対して文芸的プログラミングでは文章の中にプログラムを埋め込みます。 さらに加えてプログラムは断片に分解でき、ラベルの参照を使って自由に組み合わせることができます。\n断片の参照の機能はありませんがIdrisには多少の文芸的プログラミングのサポートがあります。\n文芸的Idrisでは普通の文章の中にIdrisのコードを埋め込みます。 `\u0026gt;` ではじまる行がIdrisのコードとして扱われます。 例：Idrisで2数の和をとるコード \u0026gt; add : Integer -\u0026gt; Integer -\u0026gt; Integer \u0026gt; add x y = x + y `main` なども書けます。 \u0026gt; main : IO () \u0026gt; main = printLn $ add 1 2 拡張子は `.lidr` を使います。 このファイルを `LiterateIdris.lidr` に保存したとしましょう。 以下のように普通にコンパイル・実行できます。 ```text $ idris -o LiterateIdris LiterateIdris.lidr $ ./LiterateIdris 3 ``` プログラムの中に自信のコンパイル方法を書いたりできるの楽しいですよね。 これをどう使うかというと、例えば証明をするときなんかには証明の流れや文章での証明の方針の補助などが必要なので向いてますね。 私の使っているハイライトエンジンにliterate idrisのサポートがなかったので残念なことになってますが、エディタなどはちゃんと対応しているようです。\n以上小ネタでした。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-22","title":"Idris面白機能：文芸的Idris","url":"https://KeenS.github.io/blog/2020/12/22/idrisomoshirokinou_bungeitekiidris/"},
  {"body":"このエントリはIdris Advent Calendar 2020の19日目の記事です。 次はmock_beginnerさんでIdrisとはじめる型駆動開発です。\nκeenです。今回はこのAdvent Calendarの山場の1つ、定理証明について解説しようと思います。\n依存型で証明ができる原理 カリー＝ハワード同型対応といって、プログラムのと論理学の定理には対応関係があることが知られています。 これはすなわち、我々が普段プログラムを書いているときは同時に論理学の命題を証明していることでもある、ということです。 そんな大それたことしてないよーと思うかもしれませんが、それもそのはず。 普通のプログラムではあまり面白い命題を表現できないので、わざわざ証明というほどでもないからです。\nしかしIdrisには依存型があります。 依存型があると型の表現力が上がるので対応する論理学の命題の表現力が上がります。 すると面白いことも書けるのです。\n三段論法 $P \\to Q$ かつ $P$ ならば $Q$ というやつです。有名なのは\n 全ての人間は死ぬ ソクラテスは人間である ソクラテスは死ぬ  でしょうか。これをIdrisで表現すると以下のようになります。\nmodusPonens : ((p -\u0026gt; q), p) -\u0026gt; q これは以下の対応関係による表現です。\n 命題はIdrisの型で表現する 命題変数 $P$ 、 $Q$ …はジェネリクス変数 p 、 q … で表現する $\\to$ （ならば）は関数型 -\u0026gt; で表現する $\\land$ (かつ)はタプルで表現する  これを証明しましょう。命題は型で表現しましたが、証明はプログラムで表現します。 型に合うプログラムを書けばそれで証明したことになります。 これは優しいですかね。 以下のプログラムで型が合います（＝証明できます）。\nmodusPonens : ((p -\u0026gt; q), p) -\u0026gt; q modusPonens (hpq, hp) = hpq hp 雰囲気掴めましたか？ 論理学のアイテムに対応するIdrisの型を選んで命題を表現し、あとはコンパイルを通せばいい訳です。\n$\\lor$（または） $\\lor$（または）に対応するのは Either になります。\n例えば $A \\lor B \\to B \\lor A$ をIdrisの型で表現するとこうなります。\norComm : Either a b -\u0026gt; Either b a これは簡単に証明できますね？\norComm : Either a b -\u0026gt; Either b a orComm (Left a) = Right a orComm (Right b) = Left b ここまでは難しくないんじゃないでしょうか。\n全関数 プログラムと証明が対応すると書きましたが、どんなプログラムとも対応する訳ではなくて、ある程度条件を満たす必要があります。それはプログラムが全関数（total function）であるということです。\n全関数とは（型の合う）入力を与えたら必ず値を返す関数です。 一見当たり前のように見えますが、2つの落とし穴、すなわち関数に値を与えても値が返ってこないケースがあります。\n場合分け 1つの穴は場合分けの失敗です。 Idrisではパターンマッチで全ての場合を尽していなくてもコンパイルできるのでした。 そして対応していない値がきた場合はプログラムがクラッシュします。\nこれは証明でいったら場合分けの考慮漏れに相当します。\n循環論法 もう1つの穴は無限ループです。 無限ループすると値は返ってこないですね。\nこれは証明でいったら循環論法に相当します。\nよくあるプログラミング言語ならこの他にも例外があてはまるのですが、Idrisには例外がないので気にしなくてよいです。\ntotal さて、これらを避けないと証明として成立しないのですが、Idrisはそのための機能を提供しています。 関数に total という修飾子をつけると全関数であるかを確認してくれるのです。\n例えば以下のように書きます。\ntotal orComm : Either a b -\u0026gt; Either b a orComm (Left a) = Right a orComm (Right b) = Left b 少し試してみましょう。上記 orComm の1節を削って以下のようにします。\ntotal orComm : Either a b -\u0026gt; Either b a orComm (Left a) = Right a これは total がなければコンパイルが通るコードです。 しかし total をつけているとエラーになります。\n$ idris --check proving.idr proving.idr:8:1-26: | 8 | orComm (Left a) = Right a | ~~~~~~~~~~~~~~~~~~~~~~~~~~ Main.orComm is not total as there are missing cases --check は型検査などの検査のみやってくれるオプションです。 証明をするときは型さえ合えばいいので常にこのオプションを使うことになるでしょう。\n同様に無限ループについても検査してくれます。 ただし無限ループについては注意が必要です。 全てのループ（関数の再帰呼出）について無限ループになるかならないかを判定する機能はありません（理論的に不可能）。 代わりに、ループの引数が構造的に確実に減少しているなど「コンパイラが確実に無限ループでないと保証できる」場合にのみ total の検査が通ります。 ここだけ必要十分条件ではなく十分条件なんですね。ここは理論的限界なので上手くつきあっていきましょう。\nさて、この便利な total ですがファイル内の全ての関数をデフォルトで total 修飾子が付いているように振る舞わせることができます。%default total というディレクティブです。 これを使えば orComm の total 修飾子は不要になります。\n%default total orComm : Either a b -\u0026gt; Either b a orComm (Left a) = Right a orComm (Right b) = Left b 逆に %default total の中で total でない関数 （部分関数、partial function）を書くには partial 修飾子をつけます。\n以後この記事内では %default total を有効にした上でコンパイラは idris --check でコンパイルしているものとして進めます。\nド・モルガンの法則 命題の否定（$\\lnot A$）は a -\u0026gt; Void で表します。 Void はプレリュードで定義されているデータ型です。 Not a = a -\u0026gt; Void なるエイリアスもあります。\nIdris\u0026gt; :doc Void Data type Void : Type The empty type, also known as the trivially false proposition. Use void or absurd to prove anything if you have a variable of type Void in scope. The function is: public export No constructors. No constructorsとあるように、コンストラクタがありません。つまり、 Void の値は作れないのです。 もし Void の値を作れたとしたら矛盾ですね。 矛盾からは何でも証明できます（$\\bot \\to A$）。 この規則はIdrisでは void 関数が対応します。\nIdris\u0026gt; :doc void void : Void -\u0026gt; a The eliminator for the Void type. The function is: Total \u0026amp; public export 否定を上手く扱えそうですか？ それでは練習問題としてド・モルガンの法則を証明してみましょう。 ド・モルガンの法則はいくつかありますが、まずはこれです。\n\\[ \\lnot(A \\lor B) \\to (\\lnot A \\land \\lnot B) \\]\nこの命題をIdrisに対応させると以下の型になります。\ndeMorgan : (Not (Either p q) ) -\u0026gt; (Not p, Not q) これを証明していきましょう。\nまずは関数なので引数を取ります。\ndeMorgan : (Not (Either p q) ) -\u0026gt; (Not p, Not q) deMorgan hnpq = … ここで hnpq の型は Not (Either p q) （= Either p q -\u0026gt; Void） です。 ここから (Not p, Not q) （= (p -\u0026gt; Void, q -\u0026gt; Void)）の値を作ります。 落ち着いて np : p -\u0026gt; Void と nq : q -\u0026gt; Void の値をそれぞれ作るところからはじめましょう。 そうすれば (np, nq) を返すだけになります。\ndeMorgan : (Not (Either p q) ) -\u0026gt; (Not p, Not q) deMorgan hnpq = let np = … in let nq = … in (np, nq) p -\u0026gt; Void はよく考えると Either p q -\u0026gt; Void を使って簡単に作れますね。 \\hp =\u0026gt; hnpq (Left hp) です 1。 同様に q -\u0026gt; Void も \\hq =\u0026gt; hnpq (Right hq) から作れます。\n総合すると、以下のコードでコンパイルが通ります（=証明できます）。\ndeMorgan : (Not (Either p q) ) -\u0026gt; (Not p, Not q) deMorgan hnpq = let np = hnpq . Left in let nq = \\hq =\u0026gt; hnpq (Right hq) in (np, nq) ここまでは 5日目の記事 でも紹介されています。 この記事では読者への課題として以下の命題を証明する問題が出されています。\n\\[ \\lnot a \\land \\lnot b \\to \\lnot (a \\lor b) \\]\nここで答え合わせといきましょう。\nまず、Idrisにエンコードするとこういう型ですね。\ndeMorgan\u0026#39; : (Not p, Not q) -\u0026gt; (Not (Either p q) ) このプログラムを書いていきます。 まずは関数かつ引数がタプルなのでこういう書き出しです。\ndeMorgan\u0026#39; : (Not p, Not q) -\u0026gt; (Not (Either p q) ) deMorgan\u0026#39; (hnp, hnq) = … ここで Not a = a -\u0026gt; Void であることと a -\u0026gt; (b -\u0026gt; c) = a -\u0026gt; b -\u0026gt; c であることを思い出しましょう。 すると Either p q も関数の引数として受け取れることが分かりますね。しかも Eitherなのでパターンマッチしましょう。こうなります。\ndeMorgan\u0026#39; : (Not p, Not q) -\u0026gt; (Not (Either p q) ) deMorgan\u0026#39; (hnp, hnq) (Left p) = … deMorgan\u0026#39; (hnp, hnq) (Right q) = … これであとは Void を返すだけです。 Void は hnp : p -\u0026gt; Void と hnq : q -\u0026gt; Void から 出てきます。\n結果、回答は以下のコードになります。\ndeMorgan\u0026#39; : (Not p, Not q) -\u0026gt; (Not (Either p q) ) deMorgan\u0026#39; (hnp, hnq) (Left p) = hnp p deMorgan\u0026#39; (hnp, hnq) (Right q) = hnq q 等価性の証明 Idrisにはほぼ証明専用の型、 = があります。 例えば以下のような型が書けるのです。\noneEqualOne : 1 = 1 これの証明はそれ専用の値 Refl を使います。\noneEqualOne : 1 = 1 oneEqualOne = Refl Refl は x = x の値となります。 ここで x = x となる条件ですが、Idrisは「ある程度」計算をしてくれます。 例えば以下のコードはコンパイルが通ります。\nonePlusOneEqualTwo : 1 + 1 = 2 onePlusOneEqualTwo = Refl 定数は全部計算してくれるようです。 逆に変数が絡むと途端に諦めるようになります。 例えば以下のコードはコンパイルエラーになります。\nonePlusNEqualNPlusOne : 1 + n = n + 1 onePlusNEqualNPlusOne = Refl- + Errors (1) `-- proving.idr line 31 col 24: When checking right hand side of onePlusNEqualNPlusOne with expected type 1 + n = n + 1 Type mismatch between prim__addBigInt n 1 = prim__addBigInt n 1 (Type of Refl) and prim__addBigInt 1 n = prim__addBigInt n 1 (Expected type) Specifically: Type mismatch between prim__addBigInt n 1 and prim__addBigInt 1 n ちょうどいいとっかかりなのでこれを証明してみましょう。\n例題 $1 + n = n + 1$ を証明します。\nまず、命題を少しいじります。 n をプログラム内で扱いたいので関数の引数で受け取ることにします。\nonePlusNEqualNPlusOne : (n: Nat) -\u0026gt; 1 + n = n + 1 これは命題でいえば $\\forall n \\in \\mathbf{N}. 1 + n = n + 1$ に相当します。\nそしてこれを証明していくのですが、数学的帰納法を使います。 すなわち $n = 0$ の場合を証明して、$n = k$ で成り立つならば $n = k + 1$ でも成り立つことを証明します。 Idris的にいうと n = Z の場合と n = S k の場合で場合分けして、 n = S k のときは再帰するということです。 やってみましょう。\n$n = 0$ の場合 まず n = Z の場合は 1 + 0 = 0 + 1 で、全て定数なのでIdrisが計算してくれて、 Refl で済みます。\nonePlusNEqualNPlusOne = Refl $n = k + 1$ の場合 次に $n = k$ で成立する、つまり onePlusNEqualNPlusOne k の呼出はできると仮定して n = S k の場合を証明します。\nonePlusNEqualNPlusOne (S k) = … n = S k の場合は 1 + (S k) = (S k) + 1 となります。 ここで、 n + m は plus n m で定義されていることと、 plus の定義から S (S k) = S (plus k 1) へと計算されます。Idrisは関数呼出も多少は計算してくれるようです。\n-- S (S k) = S (plus k 1) を返す onePlusNEqualNPlusOne (S k) = … ここで onePlusNEqualNPlusOne k : 1 + k = k + 1 の存在を思い出しましょう。 これも多少Idrisが計算してくれるので S k = plus k 1 となります。 S (S k) = S (plus k 1) の plus k 1 の部分を S k = plus k 1 を使って書き換えられたら S (S k) = S (S k) になるので Refl で証明できますね。\n実際、等式を使って型を書き換える構文があります。 rewrite 等式 in 値 の構文です。 これを使うと S k の節はこう書けます。\nonePlusNEqualNPlusOne (S k) = rewrite onePlusNEqualNPlusOne k in Refl これで証明完了です。 プログラム全体は以下のようになります。\nonePlusNEqualNPlusOne : (n: Nat) -\u0026gt; 1 + n = n + 1 onePlusNEqualNPlusOne Z = Refl onePlusNEqualNPlusOne (S k) = rewrite onePlusNEqualNPlusOne k in Refl 何のために証明するの？ 上記まででIdrisで証明ができることは分かったかと思います。 では、どうしてIdrisを使って証明するのでしょう。 紙とペンで証明するのと何が違うのでしょう。\n1つは機械で検査できる証明として。 上記まででIdrisのコードのコンパイルが通れば証明完了と紹介してきました。 つまりコンパイラが証明が正しいことを証明してくれるのです。 人間誰しも誤りはあるものなので機械がチェックしてくれると嬉しいですよね。\nもう1つ、現実的な理由があります。 依存型を使ったコードを書くときに型を合わせるために証明が必要になるケースがあるのです。 例えば以下のコードをみてみましょう。\nrotateVec : Vect n a -\u0026gt; Vect n a rotateVec [] = [] rotateVec (x::xs) = xs ++ [x] 一見問題ないように見えます。しかしこれをコンパイルするとエラーになります。\n- + Errors (1) `-- proving.idr line 40 col 20: When checking right hand side of rotateVec with expected type Vect (S len) a Type mismatch between Vect (len + 1) a (Type of xs ++ [x]) and Vect (S len) a (Expected type) Specifically: Type mismatch between plus len 1 and S len x::xs のパターンマッチで n = 1 + k であることが分かった一方で xs ++ [x] は k + 1 になります。 まさしく先程証明した 1 + n = n + 1 が必要になるのです。実際、 onePlusNEqualNPlusOne を使って rewrite してあげればコンパイルは通ります。\nrotateVec : Vect n a -\u0026gt; Vect n a rotateVec [] = [] rotateVec {n = S k} (x::xs) = rewrite onePlusNEqualNPlusOne k in xs ++ [x] 依存型は強力な保証をしてくれる一方でユーザにも保証の一端を担わせる諸刃の剣です。 Advent Calendar初日で「依存型のあるHaskell」と紹介しつつもあまり依存型について触れてこなかったのはこういう訳があるのです。\nさて、最後にもう1つ、夢のある話をしましょう。Idrisで書ける証明で、プログラムの正しさも証明できるのです。 フィボナッチ数列を求める関数を例に採りましょう。\nn番目のフィボナッチ数列を求めるナイーブな実装はこうですね？\nfib1 : Nat -\u0026gt; Nat fib1 Z = 1 fib1 (S Z) = 1 fib1 (S (S k)) = fib1 (S k) + fib1 (k) これは定義に従っていて正しさが目で見て分かりやすい一方でとても効率が悪いです。\nそこで先頭から順番に計算していく別の実装を与えたくなります。\nloop : Nat -\u0026gt; Nat -\u0026gt; Nat -\u0026gt; Nat loop prev2 prev Z = prev loop prev2 prev (S k) = loop prev (prev + prev2) k fib2 : Nat -\u0026gt; Nat fib2 n = loop 0 1 n すると今度はこの実装が正しいか（fib1と同じ挙動をするか）パッとは自信がもてません。 ですがIdrisなら「100%正しい」と言える方法がありますよね。 以下の命題を証明すればいいのです。\ntwoFibEq : (n: Nat) -\u0026gt; fib2 n = fib1 n 実際、これは以下のようにして証明できます。\n-- 補題 loopIsLikeFib : (i, j, n: Nat) -\u0026gt; loop (i + j) (i + j + j) n = (loop j (i + j) n) + (loop i j n) loopIsLikeFib i j Z = Refl loopIsLikeFib i j (S k) = rewrite plusCommutative i j in rewrite plusCommutative (j + i) j in rewrite loopIsLikeFib j (j + i) k in Refl -- 証明 twoFibEq : (n: Nat) -\u0026gt; fib2 n = fib1 n twoFibEq Z = Refl twoFibEq (S Z) = Refl twoFibEq (S (S k)) = rewrite loopIsLikeFib 0 1 k in rewrite twoFibEq k in rewrite twoFibEq (S k) in Refl かくして fib2 は100% fib1 と同じ振る舞いをすることが証明できました。\n証明さえあれば数個の値で挙動を確かめるいい加減な方法（テストと呼ばれます）よりずっと確実に正しさを保証できるのです。夢があっていいですね。\nまとめ 型とは命題であり、プログラムとは証明であると紹介しました。 実際にいくかの命題を証明したあとプログラミング言語を用いて証明をする意義も紹介しました。\n あるいは hnqp . Left でもいいのですが、ウッカリ . を紹介し忘れてるので本文では扱わないことにします。 [return]  ","categories":["依存型","Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/%e4%be%9d%e5%ad%98%e5%9e%8b","/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-22","title":"Idrisで依存型を使った定理証明入門","url":"https://KeenS.github.io/blog/2020/12/22/idrisdeizongatawotsukattashoumeinyuumon/"},
  {"body":"このエントリはIdris Advent Calendar 2020の18日目の記事です。\nκeenです。Idrisで個人的に面白いなーと思ってる機能、 with 構文とそれを利用したViewについて紹介します。\nパターンマッチを補助する with 構文 関数を書くときに条件分岐したくなることがありますよね。 データ型の構造に沿う条件であれば引数でのパターンマッチで済むんですが、もう少し複雑な条件だと if や case を使わざるを得なくなります。 例えば「リストに値がなければ追加する」関数 addToList はこう書けるでしょう。\naddToList : Eq a =\u0026gt; a -\u0026gt; List a -\u0026gt; List a addToList x xs = if elem x xs then xs else x::xs こういうのも引数のパターンマッチで書けると綺麗ですよね。 これは with 構文で解決できます。 関数名 引数… with (補助式) 節… の構文です。 節は 関数名 引数… | 補助パターン = 本体 と書きます。\n例えば先程の addToList だと以下の構文になります。\naddToList : Eq a =\u0026gt; a -\u0026gt; List a -\u0026gt; List a addToList x xs with (elem x xs) addToList x xs | True = xs addToList x xs | False = x :: xs 関数の本体が = xs と = x :: xs でサッパリしたので気持良いですね。\nところで、上記の記述 addToList x xs が続いてちょっとくどいですよね。これは省略できます。 以下のようにも書けるのです。\naddToList : Eq a =\u0026gt; a -\u0026gt; List a -\u0026gt; List a addToList x xs with (elem x xs) | True = xs | False = x :: xs もっとサッパリしましたね。\nwith の発展的利用例 with 構文の面白いところは、計算した結果をパターンマッチにかけられるところです。\n例えばUNIXタイムスタンプが定義してあるとします。\ndata Timestamp = MkTimestamp Int これを受け取って時刻の文字列を返す関数を定義してみましょう。 タイムスタンプから時刻を抜き出す関数と時刻から文字列を作る関数に分けると具合がよさそうです。\nということでまずはタイムスタンプから時刻を抜き出しましょう。JSTにあわせて+9時間しています。\ntoTime : Timestamp -\u0026gt; (Int, Int, Int) toTime (MkTimestamp t) = let time = t `mod` (60 * 60 * 24) in let h = time `div` (60 * 60) in let m = (time `div` 60) `mod` 60 in let s = time `mod` 60 in ((h + 9) `mod` 24, m, s) これと with 構文を使えば時刻を表示する関数 showTime は至極完結に書けます。\nshowTime : Timestamp -\u0026gt; String showTime t with (toTime t) | (h, m, s) = (show h) ++ \u0026#34;:\u0026#34; ++ (show m) ++ \u0026#34;:\u0026#34; ++(show s) toTime により Timestamp の別表現が与えられたような形になっていますね。\n依存パターンマッチ Viewの話をする前に依存パターンマッチを紹介しましょう。 Idrisでは型パラメータなども {} で取り出せることは説明しましたね？ 例えば Vect n a の n は以下のように取り出せます。\nlength : Vect n a -\u0026gt; Nat length {n = n} _ = n この n の部分でパターンマッチができるのですが、ちょっと面白い振る舞いをします。 以下の関数を見てみて下さい。\nappend : Vect n a -\u0026gt; Vect m a -\u0026gt; Vect (n + m) a append {n=Z} [] ys = ys append {n=S k} (x :: xs) ys = append (x :: xs) ys n と Vect で2つのパターンマッチが走っていますね。 n には Z と Suc n 、 Vect には [] と x :: xs のパターンがあるので普通なら 2 x 2 = 4 種類のパターンがあるはずです。ところが、ここでは2通りのパターンマッチしかしていません。 n は Vect の長さに連動しているので n = Z のときには Vect は [] ですし、 n = S k のときは Vect は x :: xs です。それ以外の可能性はありません。 なので上記2通りで全ての場合を尽しているのです。\n証拠に例えば n = S k かつ Vect が [] のパターンを追加するとエラーになります。\nappend : Vect n a -\u0026gt; Vect m a -\u0026gt; Vect (n + m) a append {n=Z} [] ys = ys append {n=S k} [] ys = append (x :: xs) ys append {n=S k} (x :: xs) ys = append (x :: xs) ys これをコンパイルすると以下のエラーが出ます。\n- + Errors (1) `-- withAndView.idr line 48 col 0: When checking left hand side of append: When checking an application of Main.append: Type mismatch between Vect 0 elem (Type of []) and Vect (S k) a (Expected type) Specifically: Type mismatch between 0 and S k このように依存型を使うと型と値が軛で繋がれたように連動するのです。 この仕組みを利用したのがViewです。\nView 依存型を使うとパターンマッチのときに型と値が連動すると紹介しました。 では、とある値を受け取ったときにそれに依存する型を作れば値のパターンマッチを自由に制御できるのではないかという発想に至ります。実際可能で、それを利用するプログラミングパターンがViewです。 具体例をいくつか紹介しましょう。\nData.List.Views には List 型に対するViewがいくつかあります。 その中でも Split Viewを使ってみましょう。\nData type Data.List.Views.Split : List a -\u0026gt; Type View for splitting a list in half, non-recursively The function is: public export Constructors: SplitNil : Split [] The function is: public export SplitOne : Split [x] The function is: public export SplitPair : Split (x :: xs ++ y :: ys) The function is: public export コンストラクタが3つあって、それぞれの型が Split [] 、 Split [x] 、 Split (x :: xs ++ y :: ys) ですね。Split の値は split 関数で作れます。使ってみましょう。\nsplitView : List a -\u0026gt; List a splitView l with (split l) splitView [] | SplitNil = [] splitView [x] | SplitOne = [] splitView (x :: xs ++ y :: ys) | SplitPair = [] splitView の引数のパターンマッチ (| の左)が Split の値に応じて変化しているのが分かりますか？ そして特に目につくのが3節目の (x :: xs ++ y :: ys) です。 ++ は関数なので普通はパターンマッチでは使えません。ところがリストに依存している Split の方がそういう型をしているのでこういうパターンも書けてしまうのです。\n例えばこれを使ってマージソートが書けるでしょう。\nmergeSort : Ord a =\u0026gt; List a -\u0026gt; List a mergeSort l with (split l) mergeSort [] | SplitNil = [] mergeSort [x] | SplitOne = [x] mergeSort (x::xs ++ y::ys) | SplitPair = merge (mergeSort (x::xs)) (mergeSort (y::ys)) -- mergeはpreludeで定義されている この機能は他の言語では中々見掛けないんじゃないでしょうか。\n再帰View Viewの中には再帰的に定義されるものがあります。例えば SnocList などです。 snoc というのは cons をさかさまにした文字列で、 cons がリストの先頭に要素を加えるのに対して snoc はリストの末尾に要素を加えます。なので SnocList はパターンマッチでリストの末尾からデータを取り出すときに使います。\n今までの知識で書くとこうなりますよね？\nreverseList : List a -\u0026gt; List a reverseList l with (snocList l) reverseList [] | Empty = [] reverseList (xs ++ [x]) | Snoc _ = x :: (reverseList xs) これでも動くんですが、効率が悪いです。 snocList はリストの末尾まで辿ります。 それを reverseList の呼び出しごとに呼んでいるので無駄です。\nSnocList の Snoc には実は xs の分の SnocList の値も保持されています。 _ で無視している部分ですね。これを使うと効率的に再帰ができそうです。 ですが、これをどうやって使いましょう？\n1つの方法は補助関数を作ることです。\nreverseList : List a -\u0026gt; List a reverseList l = helper l (snocList l) where helper : (l : List a) -\u0026gt; SnocList l -\u0026gt; List a helper [] Empty = [] helper (xs ++ [x]) (Snoc rec) = x :: (helper xs rec) これでもいいんですが、ちょっと野暮ったいですよね？ Idrisには with で使うViewを外から差し込む構文があります。 関数 引数 | view という構文です。\nreverseList : List a -\u0026gt; List a reverseList l with (snocList l) reverseList [] | Empty = [] reverseList (xs ++ [x]) | Snoc rec = x :: (reverseList xs | rec) reverseList xs | rec の部分がそれです。ちょっと奇妙ですが便利ですね。\n因みに内部的には with と | を使った関数は helper のような定義に展開されているらしいです。\n多重 with with 使ってる途中で追加の with をはじめることもできます。\nisSuffix : Eq a =\u0026gt; List a -\u0026gt; List a -\u0026gt; Bool isSuffix l1 l2 with (snocList l1) isSuffix [] _ | Empty = True isSuffix (xs ++ [x]) l2 | Snoc rec with (snocList l2) isSuffix _ [] | _ | Empty = False isSuffix (xs ++ [x]) (ys ++ [y]) | Snoc r1 | Snoc r2 = if x == y then isSuffix xs ys | r1 | r2 else False 使いすぎると訳がわからなくなりそうですが、覚えておいて損はないでしょう。\nまとめ with 構文と依存型によるパターンマッチの面白い挙動、それを使ったViewについて紹介しました。 with 構文のもう1つの使い方として証明があるのですが、それはまた後日ということで。\n","categories":["依存型","Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/%e4%be%9d%e5%ad%98%e5%9e%8b","/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-22","title":"Idris面白機能：with構文と依存型、View","url":"https://KeenS.github.io/blog/2020/12/22/idrisomoshirokinou_withkoubuntoview/"},
  {"body":"このエントリはIdris Advent Calendar 2020の17日目の記事です。\nκeenです。今回は小ネタとしてシンタックスシュガー（糖衣構文）やオーバーロードについて紹介します。 あとIdrisにはユーザが構文を拡張できる機能もあるのでそれも紹介します。\nif 式 Idrisでは if expr1 then expr2 else expr3 が糖衣構文として定義されています。 では展開すると何になるかというと、 ifThenElse 関数です。 「えっ？無理じゃない？」と思った方、正しいです。普通の言語では if は関数では書けません。 しかしIdrisでは関数で書けるのです。\n昔紹介したようにIdrisではLazyという機能を使うと遅延評価ができます （IdrisはHaskellと違ってデフォルトではEager Evaluationをします）。 この Lazy を使って ifThenElse 関数はこう定義されています。\nifThenElse : Bool -\u0026gt; Lazy a -\u0026gt; Lazy a -\u0026gt; a ifThenElse True t e = t ifThenElse False t e = e ところで、Idrisでは関数をオーバーロードできるのでした。 ifThenElse をオーバーロードするとどうなると思いますか？ そう、 if 式をオーバーロードできるのです。 少し試してみましょう。\n以下の関数を定義します。\nifThenElse: Maybe a -\u0026gt; (a -\u0026gt; b) -\u0026gt; Lazy b -\u0026gt; b ifThenElse (Just a) f _ = f a ifThenElse Nothing _ b = b これを読み込んだREPLでは Maybe 型の式に対して if が使えます。\nIdris\u0026gt; if Just 1 then (+1) else -1 2 : Integer Idris\u0026gt; if Nothing then (+1) else -1 -1 : Integer 面白いですね。\n因みにLazyの記事で紹介しましたがショートサーキットする論理積の \u0026amp;\u0026amp; も Lazy を使ったただの関数です。 Idrisでは演算子もユーザが定義できるのでこういった部分もユーザランドで定義できてしまうんですね。\ndo 記法 do 記法もシンタックシュガーです。 以下の do 式は\ndo x \u0026lt;- hoge y \u0026lt;- fuga x z \u0026lt;- piyo y pure $ chun z 以下のように展開されます。\nhoge \u0026gt;\u0026gt;= (\\x =\u0026gt; fuga x \u0026gt;\u0026gt;= (\\y =\u0026gt; piyo y \u0026gt;\u0026gt;= (\\z =\u0026gt; pure $ chun z ))) ここで (\u0026gt;\u0026gt;=) もオーバーロード可能なので変テコな定義も可能なはずなんですが、パースエラーになってしまいました。\n(\u0026gt;\u0026gt;=) : String -\u0026gt; a -\u0026gt; String (\u0026gt;\u0026gt;=) s _ = s hoge : String hoge = do \u0026#34;This is string\u0026#34; \u0026#34;Others will be ignored\u0026#34; [\u0026#34;Nothing Happen\u0026#34;]Type checking ./doNotation.idr doNotation.idr:6:8-9:20: | 6 | hoge = do | ~~ ... Incomplete term do \u0026#34;This is string\u0026#34; \u0026#34;Others will be ignored\u0026#34; [\u0026#34;Nothing Happen\u0026#34;] Holes: Main.hoge 謎です。\nその他モナド関連記法 Idrisには何故か do 記法と役割の被る構文がいっぱいあります。\n以下の関数を書き換えながら紹介します。\naddDo : Maybe Int -\u0026gt; Maybe Int -\u0026gt; Maybe Int addDo xs ys = do x \u0026lt;- xs y \u0026lt;- ys pure $ x + y 内包表記 以前リスト内包表記と紹介しましたが、より一般にはモナド内包表記です。 例えば Maybe に対しても使えます。\naddComplehensions : Maybe Int -\u0026gt; Maybe Int -\u0026gt; Maybe Int addComplehensions xs ys = [x + y | x \u0026lt;- xs, y \u0026lt;- ys] ガード式も書けるんですが、Alternativeに触れないといけなくなるのでここでは流します。\n! 記法 もうちょっと簡潔に書く方法として ! 記法もあります。\naddBang : Maybe Int -\u0026gt; Maybe Int -\u0026gt; Maybe Int addBang x y = pure $ !x + !y 熟語括弧（idiom brackets） これはMonadではなくApplicativeの記法です。\naddBracket : Maybe Int -\u0026gt; Maybe Int -\u0026gt; Maybe Int addBracket xs ys = [| xs + ys |] これは以下に同じです。\naddBracket : Maybe Int -\u0026gt; Maybe Int -\u0026gt; Maybe Int addBracket xs ys = (+) \u0026lt;$\u0026gt; xs \u0026lt;*\u0026gt; ys これはまあ、分かる。\nユーザ定義構文 Idrisには中置演算子をユーザが定義できる機能があるというのはAdvent Calendarで紹介した通りですが、もうちょっと一般にn項演算子を定義する機能があります。syntax 構文.... = 内容 の構文です。構文のところにはダブルクォートで囲ったキーワード （\u0026quot;キーワード\u0026quot;）か、式を表わす [仮引数] 、 変数を表わす {仮変数} が書けます 1。\n内容のところにはIdrisの式を書きます。\nif then else は既にあるので unless then else を定義してみましょう。\nsyntax \u0026#34;unless\u0026#34; [test] \u0026#34;then\u0026#34; [t] \u0026#34;else\u0026#34; [e] = ifThenElse test e tIdris\u0026gt; unless True then 1 else 2 2 : Integer Idris\u0026gt; unless False then 1 else 2 1 : Integer 次に変数を使うユーザ定義構文も定義してみましょう。 for 式です。\nsyntax for {x} \u0026#34;in\u0026#34; [xs] \u0026#34;:\u0026#34; [body] = forLoop xs (\\x =\u0026gt; body) forLoop : List a -\u0026gt; (a -\u0026gt; b) -\u0026gt; List b forLoop l f = map f l {x} と仮変数を使っていますね。\nREPLで試すと動いているのが分かります。\nIdris\u0026gt; for x in [1, 2, 3]: x + 1 [2, 3, 4] : List Integer 因みに syntax で定義した構文はパターンとしても使えます。 例えば以下のように定義すると、 Some を Just の代わりに使えます。\nsyntax \u0026#34;Some\u0026#34; [x] = Just x syntax \u0026#34;None\u0026#34; = Nothing パターンとして使うときはこうですね。\nhoge : Maybe Int -\u0026gt; Int hoge x = case x of Some x =\u0026gt; x None =\u0026gt; -1 値として使うときはこうです。\nIdris\u0026gt; hoge (Some 1) 1 : Int Idris\u0026gt; hoge None -1 : Int パターンでだけ、値でだけ定義したいときは pattern syntax と term syntax という構文もあります。\n詳しくは syntax rulesのドキュメントを参照して下さい。文法にあいまい性が生じそうなケースはエラーになるようです。\nリテラルのオーバーロード \\x =\u0026gt; body と書いたらユーザ定義データの Lambda x body になったり f x と書いたら App f x になったりのヤバそうな機能もあるようです。詳細は論文読んでねスタイルなのでここではスルーします。\n興味のある方は dsl notationのドキュメント を読んでみて下さい。\nまとめ Idrisのシンタックスシュガーとそれをオーバーロードする方法を紹介しました。 また、 syntax rulesというn項演算子を作れる機能も紹介しました。\n ドキュメントには言語のキーワードならダブルクォートなしで書けるとあるのですが、実際に試したらエラーになりました。 [return]  ","categories":["Idris","Idris Advent Calendar","Advent Calendar 202","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-202","/categories/advent-calendar"],"date":"2020-12-20","title":"Idris面白機能：シンタックスシュガーとオーバーロード、あとユーザ定義構文","url":"https://KeenS.github.io/blog/2020/12/20/idrisnoshintakkusushuga_too_ba_ro_do_atoyu_zateigikoubun/"},
  {"body":"このエントリはML Advent Calendar 2020の21日目の記事です。 前はelpinalさんで「長さn以上のリストをファンクタで」、後はnymphuimさんで「OCaml の小ネタを書く」です。\nκeenです。小ネタなんですが、SMLのDerived Formsについて書きます。\nDerived Formsとは The Definition of Standard ML (revised)では基本文法の他にAppendix AでDerived Forms（派生形式）というのが定義されています。平たくいうと糖衣構文ですね。\n普段SMLのコードを書く上ではあまり意識する必要はないのですが、SMLのコンパイラを作るときにはよく確認することになります。そしてDerived Formsを見ると「へー、XXって実はYYの構文糖衣だったんだ」と気付くことがあります。この記事ではそういう「へー」を紹介しようかなと思います。\n意外なDerived Forms タプル これは有名ですかね。タプルはラベルが数値なレコードです。() は {} です。\n- () = {};; val it = true : bool - {1 = \u0026#34;one\u0026#34;, 2 = \u0026#34;two\u0026#34;};; val it = (\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;) : string * string ただしラベルは1はじまりの2以上なので {1 = \u0026quot;one\u0026quot;} に対応するタプルはありません。\n- {1 = \u0026#34;one\u0026#34;}; val it = {1=\u0026#34;one\u0026#34;} : {1:string} 余談ですが SML# で () = {} を試したらエラーになりました。\nSML# 3.6.0 (2020-05-29 09:58:49 JST) for x86_64-pc-linux-gnu with LLVM 10.0.1 # () = {};; (interactive):1.0-1.6 Error: (type inference 026) operator and operand don\u0026#39;t agree operator domain: unit * unit operand: unit * {} # {};; val it = {} : {} # ();; val it = () : unit 仕様違反なのでバグですかね。\nラベル タプルの要素は #n で、レコードの要素は #label で取り出せますね。これもDerived Formです。\nfn {label = tmp, ...} =\u0026gt; tmp へと展開されます。\nandalso と orelse を最後まで展開すると… exp1 andalso exp2 はDerived Formです（orelse も同じ、以後同様）。 Derived Formsを展開した結果さらにDerived Formsが現われたらまた展開することになっています。最後にはコア言語に到達して展開が停止します。では exp1 andalso exp2 をコア言語まで展開したらどんな式になるか分かりますか？\n exp1 andalso exp2 は if exp1 then exp2 else false へと展開されます。 if exp1 then exp2 else exp3 は case exp1 of true =\u0026gt; exp2 | false =\u0026gt; exp3 へと展開されます。 case exp of match は (fn match)(exp) へと展開されます。  これらを総合すると\n exp1 andalso exp2 → if exp1 then exp2 else false → case exp1 of true =\u0026gt; exp2 | false =\u0026gt; false → (fn true =\u0026gt; exp2 | false =\u0026gt; false)(exp1)  と展開され、最後には fn とその適用になります。 そもそも fn は fn pattern1 =\u0026gt; expr1 | pattern2 =\u0026gt; expr2 ... という構文なんですがご存知でしたか？\nセミコロン let ... in expr end の expr の部分ではセミコロンで区切って複数の式が書けます。\n- let in print \u0026#34;hello\u0026#34;; print \u0026#34;, world\\n\u0026#34; end;; hello, world val it = () : unit このセミコロンもDerived Formです。 let ... in expr1; expr2; ...; exprn; exp end は let ... in (expr1; expr2; ...; exprn; exp) end へと展開されます。 そして (expr1; expr2; ...; exprn; exp) もDerived Formです。これはちょっとびっくりですが、case 式の連鎖へと展開されます。\ncase expr1 of (_) =\u0026gt; case expr2 of (_) =\u0026gt; ... case exprn of (_) =\u0026gt; exp この後 case が fn へと展開されていきます。展開結果を見るのがちょっと怖いDerived Formですね。\nファンクタ 逆に「あ、そんな構文あったんだ」となるのがファンクタの引数。 ファンクタを適用するときにこんなコード書きますよね？\nstructure CharHashTable = HashTable(struct val eq = Char.eq val hash = Char.hash end ) (* 適当コード、多分コンパイルは通らない *) 実は struct と end はなくてもOKです\nstructure CharHashTable = HashTable( val eq = Char.eq val hash = Char.hash ) (* 適当コード、多分コンパイルは通らない *) structureの構文を書いたら struct と end が補われ、 Struct とstructureの名前を書いたらそのまま使われる仕組みになってます。パーサが大変そうですね。\nit SMLでREPLを使うとき、直前の式の評価結果に it を束縛してくれるので次の入力で直前の結果を it として参照できますよね？\n- 1 + 2;; val it = 3 : int - it * 3;; val it = 9 : int 実はこれも仕様で定められたDerived Formです。\n書き換え規則は exp;\u0026lt;program\u0026gt; → val it = exp;\u0026lt;program\u0026gt; です。 REPLで式を直接入力できる理由が分かりましたね。\n仕様にあるのでREPLだけでなくファイルでも使えます。 流石に it を使う人はいないかと思いますが、トップレベルに式を直接書いてそのまま実行されるのを期待する人は多いんじゃないでしょうか。\n以上、SMLのDerived Formsの紹介でした。\n","categories":["SML","ML Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/sml","/categories/ml-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-20","title":"SMLのDerived Forms","url":"https://KeenS.github.io/blog/2020/12/20/smlnoderived_form/"},
  {"body":"このエントリはIdris Advent Calendar 2020の16日目の記事です。\nκeenです。今回はipkgを使ったIdrisのテストとCIを紹介していきます。CIはGitLab CIとGitHub Actions両方の設定を紹介します。\nIdrisのテストフレームワーク フレームワークというほど大層なものではないですが、テストができる仕組みがあります。 contribに Test.Unit というモジュールがあり 1、それらを使ってテストが書けるのです。\nテストの本体となるのは genericTest です。\n*Test/Unit\u0026gt; :doc genericTest Test.Unit.Generic.genericTest : Show a =\u0026gt; (title : Maybe String) -\u0026gt; (given : a) -\u0026gt; (expected : a) -\u0026gt; (tFunc : a -\u0026gt; a -\u0026gt; Bool) -\u0026gt; IO Bool Run a generic test. Arguments: title : Maybe String -- Optional Test title given : a -- The given string to parse expected : a -- The expected result tFunc : a -\u0026gt; a -\u0026gt; Bool -- The testing function to compare the results. The function is: Total \u0026amp; export とはいえ、これだけだと使いづらいので assertXxx などの便利関数も用意されています。\nassertEquals : Eq a =\u0026gt; Show a =\u0026gt; a -\u0026gt; a -\u0026gt; IO Bool assertFalse : Bool -\u0026gt; IO Bool assertJust : Show a =\u0026gt; Maybe a -\u0026gt; IO Bool assertLeft : Show a =\u0026gt; Show b =\u0026gt; Either a b -\u0026gt; IO Bool assertNotEquals : Eq a =\u0026gt; Show a =\u0026gt; a -\u0026gt; a -\u0026gt; IO Bool assertNothing : Show a =\u0026gt; Maybe a -\u0026gt; IO Bool assertRight : Show a =\u0026gt; Show b =\u0026gt; Either a b -\u0026gt; IO Bool assertTrue : Bool -\u0026gt; IO Bool 例えば assertTrue であれば以下のように動作します。\n*Test/Unit\u0026gt; :exec assertTrue True Test: Assert True True *Test/Unit\u0026gt; :exec assertTrue False Test: Assert True ++++++++++++++++++++++++++++++++++++++++ An error occured: Given: False Expected: True ++++++++++++++++++++++++++++++++++++++++ False ちょっと手札が少ないですがこれでどうにかテストは書けそうです。\nipkgとテスト ipkgにもテストのサポートがあります。 tests = に IO () の値を書き連ねておけば、 idris --testpkg IPKG でテストしてくれます。\n例えばipkgに以下を書いたとします。\ntests = Tests.Hoge.test , Tests.Fuga.test すると裏で以下のようなファイルを生成、実行します。\nmodule Test_______ -- 必要ならばここにimportが並ぶ namespace Main main : IO () main = do Tests.Hoge.test Tests.Fuga.test このプログラムを実行した終了ステータスでそのまま idris --testpkg も終了します。\nテストを書く 先日のanagramにテストを書いてみましょう。\nanagramパッケージは以下のようなディレクトリ構成なのでした。\n$ tree . ├── anagram.ipkg └── src ├── Anagram.idr └── AnagramMain.idr そして anagram.ipkg は以下のような内容なのでした。\npackage anagram version = \u0026#34;0.1.0\u0026#34; author = Your name sourcedir = src modules = Anagram , AnagramMain main = AnagramMain executable = anagram pkgs = contrib これにテストを加えてみましょう。\n失敗するテスト まずは失敗するテストを書いてみます。\nanagram.ipkgを以下のように書き換えます。\npackage anagram version = \u0026#34;0.1.0\u0026#34; author = Your name sourcedir = src modules = Anagram , AnagramMain , Tests.Anagram main = AnagramMain executable = anagram tests = Tests.Anagram.test pkgs = contrib modules に Tests.Anagram が増えたのと、 tests = Tests.Anagram.test の行が増えました。\nこれに対応して src/Tests/Anagram.idr に以下の内容を書きます。\nmodule Tests.Anagram import Test.Unit import Anagram export test : IO () test = runTests [ assertTrue False ] ここで、 runTests は以下のような関数です。\n*Test/Unit\u0026gt; :doc runTests Test.Unit.Runners.NonReporting.runTests : List (IO Bool) -\u0026gt; IO () Run the given set of tests, but don\u0026#39;t return the results. これを走らせてみましょう。 idris --testpkg です。\n$ idris --testpkg anagram.ipkg Entering directory `./src\u0026#39; Type checking /tmp/idris192645-0.idr Test: Assert True ++++++++++++++++++++++++++++++++++++++++ An error occured: Given: False Expected: True ++++++++++++++++++++++++++++++++++++++++ All Tests have been performed. ========================= $ echo $? 0 期待通りテストが失敗しましたね。\nしかし終了ステータスが0です。 実装を読んだところ、どうやら runTests は終了ステータスには無関心のようです。 人間が目で確認する分にはこれでもいいのですが、今回はCIでテストをしたいので失敗したら終了ステータスも0以外になってほしいです。ちょっとだけ工夫しましょう。\n失敗するテストを失敗させる 実は runTests にはもう1つの（オーバーロードされた）実装があります。\n*Test/Unit\u0026gt; :doc runTests Test.Unit.Runners.Reporting.runTests : List (IO Bool) -\u0026gt; IO (List Bool) Run the given set of tests and return the results. こちらは返り値が IO (List Bool) とテストの成否を返すようになっています。 これを利用して1つでも失敗したテストがあれば異常終了するようにしてみましょう。\nまずはこのようなヘルパ関数を用意します。\n-- exitをインポートする import System exitIfFail : IO (List Bool) -\u0026gt; IO () exitIfFail action = do results \u0026lt;- action if not (all id results) then do putStrLn \u0026#34;Some tests failed\u0026#34; exit 1 else pure () test 側もこれを使うようにしましょう。\nexport test : IO () test = exitIfFail $ runTests [ assertTrue False ] 再度これで走らせてみます。\n$ idris --testpkg anagram.ipkg Entering directory `./src\u0026#39; Type checking ./Tests/Anagram.idr Type checking /tmp/idris193751-0.idr Test: Assert True ++++++++++++++++++++++++++++++++++++++++ An error occured: Given: False Expected: True ++++++++++++++++++++++++++++++++++++++++ All tests have been performed. ======================================== Some tests failed Leaving directory `./src\u0026#39; $ echo $? 1 今度はちゃんと終了ステータスが1になりましたね。 それではこれを使ってテストを書いていきます。\nanagramのテスト 準備が整ったのでテストを書いていきましょう。こんな感じになるんじゃないでしょうか。\nimport Data.SortedSet testEmptyQuery : IO Bool testEmptyQuery = do let result = query emptyDB \u0026#34;hoge\u0026#34; assertTrue $ contains \u0026#34;hoge\u0026#34; result testRegisterQuery : IO Bool testRegisterQuery = do let db = register emptyDB \u0026#34;eat\u0026#34; let result = query db \u0026#34;tea\u0026#34; assertTrue $ contains \u0026#34;tea\u0026#34; result export test : IO () test = exitIfFail $ runTests [ testEmptyQuery, testRegisterQuery ] ベストプラクティスがある訳ではないので難しいんですが、ipkgの tests に書くのは1ファイル1テストにして1ファイル内のテストは runTests で1まとめにすることにします。\nテストを走らせてみましょう。\n$ idris --testpkg anagram.ipkg Entering directory `./src\u0026#39; Type checking ./Tests/Anagram.idr Type checking /tmp/idris195171-0.idr Test: Assert True Test: Assert True All tests have been performed. ======================================== Leaving directory `./src\u0026#39; 無事通っているようですね。\n今回は assertTrue しか使ってませんが、様々なテストするにあたって assertXxx が色々ほしくなるはずです。そういうときは genericTest を使って assertXxx を自作しましょう。\nひとまずテストが書けたということでCIを設定していきます。\nCI CIでテストを走らせつつmasterにpushするときはIdrisdocで生成したドキュメントを更新するようにしましょう。\n多様性に配慮してGitLab CIとGitHub Actionsの両方を紹介します。 設定の簡潔さではGitLab CIの方が勝るので個人的にはGitLab CIをおすすめします。\nGitリポジトリの準備 どちらのCIを使うにせよ、まずはGitリポジトリとしての準備をしましょう。\nこんな感じで初期化します。\n$ git init . $ cat \u0026lt;\u0026lt;EOF \u0026gt; .gitignore *.ibc anagram EOF $ git add . $ git commit -m\u0026#39;inital commit\u0026#39; 余談: CIで使えるIdrisのDockerイメージ GitLab CIでもGitHubActionsでもIdrisコンパイラが入ったDockerイメージを使うことになります。 IdrisのDockerイメージは公式配布のものがないので個人で配布しているものを使うか、自分でビルドすることになります。\n私はmmhelloworld/docker-idrisを使っていますが、残念ながら現時点では1.3.2までしか対応しておらず、最新版の1.3.3がありません。 自分でビルドする手もあるのですが話がややこしくなるので一旦1.3.2に甘んじて設定を書きます。\nDockerイメージの設定はどのみち1行だけなので、別のイメージを使うのも特段難しいことはないでしょう。\nGitLab CI GitLab CIは .gitlab-ci.yml に設定ファイルを置くだけで勝手にセットアップされます。\n.gitlab-ci.yml に以下のファイルを置きます。\n# インターネットに転がっていたイメージ# 気にする人は自分でイメージを作ると良いimage:mmhelloworld/idris:1.3.2test:script:- idris --testpkg anagram.ipkgpages:script:- idris --mkdoc anagram.ipkg# docker内で生成するとパーミッションの問題が発生するらしく、一旦作り直すと解決する- mkdir public- cp -R anagram_doc/* publicartifacts:paths:- publiconly:- master あとはGitLabにリポジトリを作ってpushするだけです。\npushすると私が作ったリポジトリのGitLabのパイプラインのようにジョブが走ります。生成されたドキュメントも確認できます。\nGitLab CIについて詳しくはGitLab CIのドキュメントを参照して下さい。\nGitHub Actions Actionsは .github/workflows/ 以下に設定ファイルを置くと勝手にセットアップされます。\nActionsではテストとドキュメントの生成でファイルが分かれます。 トリガー条件が異なるからですね。\nまずはテストの方。名前はなんでもいいんですが、 ci.yml という名前で作りました。\nname:Run testson:push:pull_request:jobs:test:runs-on:ubuntu-latestcontainer:mmhelloworld/idris:1.3.2steps:- name:Checkoutuses:actions/checkout@v2- run:idris --testpkg anagram.ipkg 次はドキュメントの方。doc.yml という名前で作りました。\nname:Generate docon:push:branches:- masterjobs:doc:runs-on:ubuntu-latestcontainer:mmhelloworld/idris:1.3.2steps:- name:Checkoutuses:actions/checkout@v2- run:|idris --mkdoc anagram.ipkg mkdir public cp -R anagram_doc/* public- name:Deploy to GitHub Pagesif:success()uses:crazy-max/ghaction-github-pages@v2with:target_branch:gh-pagesbuild_dir:publicjekyll:falseenv:GITHUB_TOKEN:${{ secrets.GITHUB_TOKEN }} この2つを置いたらGitHubにリポジトリを作ってpushするとCIが走ります。\npushすると私が作ったリポジトリのGitHub Actionsのようにジョブが走ります。\nGitHub Pagesはもうちょっと設定が必要です。リポジトリのSettingsのGitHub Pagesの項目で、Sourceを gh-pages ブランチの / にしてSaveします。すると生成されたドキュメントを確認できます。\nGitHub Actionsについて詳しくはGitHub Actionsのドキュメントを参照して下さい。\nまとめ Idrisのテストの書きかた、テストの走らせかた、CIのセットアップ方法を紹介しました。\n contribのdocには載っていません。更新が追い付いてないようです。 [return]  ","categories":["Idris","GitHub","GitLab","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/github","/categories/gitlab","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-20","title":"IdrisのテストとCI","url":"https://KeenS.github.io/blog/2020/12/20/idrisnotesutotoci/"},
  {"body":"このエントリはIdris Advent Calendar 2020の15日目の記事です。\nκeenです。今回はIdrisのドキュメントコメントとそれを使ったドキュメント生成ツールの使い方を紹介します。\nベースになるのは 公式リファレンスです。簡素な説明しかないので少し補いながら説明していきます。\nドキュメントコメント トップレベルの宣言の前に ||| ではじまる行を置くことでドキュメントコメントになります。\n例えば以下のように書けます。\n||| モジュールにドキュメントを書ける module Docs 書いたドキュメントはいくつか用途がありますが、例えばREPLから参照することができます。\nIdris\u0026gt; :doc Docs Module Docs: モジュールにドキュメントを書ける ドキュメントコメントは連続して書けば複数行でも書けます。 また、Javadocと同様の構文、 @ パラメータ名 説明 でパラメータに説明を加えることもできます（要名前つきパラメータ）。\nimport Data.Vect ||| ベクタを連結する ||| @ a ベクタの内容 ||| @ xs 先頭のベクタ（再帰引数） ||| @ ys 次のベクタ（場合分けに使われない） appendV : (xs : Vect n a) -\u0026gt; (ys : Vect m a) -\u0026gt; Vect (add n m) a appendV [] ys = ys appendV (x::xs) ys = x :: appendV xs ys これはREPLだと以下のように表示されます。\nIdris\u0026gt; :doc appendV Docs.appendV : (xs : Vect n a) -\u0026gt; (ys : Vect m a) -\u0026gt; Vect (add n m) a ベクタを連結する Arguments: (implicit) a : Type -- ベクタの内容 xs : Vect n a -- 先頭のベクタ（再帰引数） ys : Vect m a -- 次のベクタ（場合分けに使われない） The function is: Total \u0026amp; public export ドキュメントコメントではマークダウン記法が使えます。\n||| 数値を足す ||| ||| 足し算はめちゃくちゃすごいよね。この段落はOverviewに含まれない。 ||| 後続の行も1つの段落に入る。 ||| ||| ドキュメント内に表示されるコードサンプルを書くこともできる ||| ```idris example ||| add 4 5 ||| ``` ||| ||| リスト記法： ||| * はい ||| * いいえ ||| * コードの `add` や **太字** なども使える ||| @ n は再帰パラメータ ||| @ m は再帰パラメータでない add : (n, m : Nat) -\u0026gt; Nat add Z m = m add (S n) m = S (add n m) これをREPLで表示すると以下のようになります。\nIdris\u0026gt; :doc add Docs.add : (n : Nat) -\u0026gt; (m : Nat) -\u0026gt; Nat 数値を足す 足し算はめちゃくちゃすごいよね。この段落はOverviewに含まれない。 後続の行も1つの段落に入る。 ドキュメント内に表示されるコードサンプルを書くこともできる \u0026gt; add 4 5 9 リスト記法： * はい * いいえ * コードの add や 太字 なども使える Arguments: n : Nat -- は再帰パラメータ m : Nat -- は再帰パラメータでない The function is: Total \u0026amp; public export テキストで貼ってしまうと分かりづらいですが、REPLを表示している上ではコードのシンタックスハイライトや等幅、太字なども処理されています。\nマークダウンエンジンはcheapskateが使われているようです。画像へのリンクなどもサポートしていますが、ターミナルでは表示できません。後述のidrisdocによるHTML生成などではできるようです。\nOverviewという用語が登場していますが、これは :apropos や search で検索したときに表示されます。\nIdris\u0026gt; :apropos add ... Docs.add : Nat -\u0026gt; Nat -\u0026gt; Nat 数値を足す ... ドキュメントの最初の1行だけが表示されていますね。\nさて、ドキュメントを書けるのはトップレベルの宣言以外にもデータ型のコンストラクタなどもあります。\n||| シンプルなデータ型 data Ty = ||| Unit型 UNIT | ||| 関数型 ARR Ty Ty GADTを使うと名前付きパラメータが使えるのでコンストラクタの引数のドキュメントも書けるようになります。\n||| 型文脈での場所を指す data Elem : Vect n Ty -\u0026gt; Ty -\u0026gt; Type where Here : {ts : Vect n Ty} -\u0026gt; Docs.Elem (t::ts) t There : {ts : Vect n Ty} -\u0026gt; Docs.Elem ts t -\u0026gt; Docs.Elem (t\u0026#39;::ts) t ||| もうちょっと面白いデータ型 ||| @ n 自由変数の数 ||| @ ctxt 自由変数の型文脈 ||| @ ty 項の型 data Term : (ctxt : Vect n Ty) -\u0026gt; (ty : Ty) -\u0026gt; Type where ||| Unit型のコンストラクタ ||| もっとコメント ||| @ ctxt 型文脈 UnitCon : {ctxt : Vect n Ty} -\u0026gt; Term ctxt UNIT ||| 関数適用 ||| @ f 適用する関数 ||| @ x 引数 App : {ctxt : Vect n Ty} -\u0026gt; (f : Term ctxt (ARR t1 t2)) -\u0026gt; (x : Term ctxt t1) -\u0026gt; Term ctxt t2 ||| ラムダ抽象 ||| @ body 関数本体 Lam : {ctxt : Vect n Ty} -\u0026gt; (body : Term (t1::ctxt) t2) -\u0026gt; Term ctxt (ARR t1 t2) ||| 変数 ||| @ i de Bruijn インデックス Var : {ctxt : Vect n Ty} -\u0026gt; (i : Elem ctxt t) -\u0026gt; Term ctxt t もちろん、レコードにもドキュメントコメントが書けます。\n||| フィールドやコンストラクタを含めてレコードにもドキュメントが書けるよ record Yummy where ||| Yummyを作る constructor MkYummy ||| 食べるもの food : String それぞれ以下のように表示されます。\nIdris\u0026gt; :doc Term Data type Docs.Term : (ctxt : Vect n Ty) -\u0026gt; (ty : Ty) -\u0026gt; Type もうちょっと面白いデータ型 Arguments: (implicit) n : Nat -- 自由変数の数 ctxt : Vect n Ty -- 自由変数の型文脈 ty : Ty -- 項の型 The function is: public export Constructors: UnitCon : Term ctxt UNIT Unit型のコンストラクタ もっとコメント Arguments: (implicit) ctxt : Vect n Ty -- 型文脈 The function is: public export App : (f : Term ctxt (ARR t1 t2)) -\u0026gt; (x : Term ctxt t1) -\u0026gt; Term ctxt t2 関数適用 Arguments: f : Term ctxt (ARR t1 t2) -- 適用する関数 x : Term ctxt t1 -- 引数 The function is: public export Lam : (body : Term (t1 :: ctxt) t2) -\u0026gt; Term ctxt (ARR t1 t2) ラムダ抽象 Arguments: body : Term (t1 :: ctxt) t2 -- 関数本体 The function is: public export Var : (i : Elem ctxt t) -\u0026gt; Term ctxt t 変数 Arguments: i : Elem ctxt t -- de Bruijn インデックス The function is: public export Idris\u0026gt; :doc Yummy Record Yummy フィールドやコンストラクタを含めてレコードにもドキュメントが書けるよ Constructor: MkYummy : (food : String) -\u0026gt; Yummy Yummyを作る Arguments: food : String -- 食べるもの The function is: public export Projections: food : (rec : Yummy) -\u0026gt; String 食べるもの The function is: public export もうちょっと凝った文法があるかなと思って実装を読んだんですがマークダウンエンジンに丸投げだったのでマークダウン記法と @ パラメータ名 説明 の文法以外は特になさそうでした。\nIdrisdoc 次にドキュメントコメントからHTMLを生成する方法を解説します。\nREPLから :mkdoc コマンドでHTMLを生成できます。その際、 doc/ 以下に生成します。\n例えば Docs.idr を読み込みつつREPLを開き、 :mkdoc Docs でHTMLを生成するとこうなります。\n$ idris Docs.idr ____ __ _ / _/___/ /____(_)____ / // __ / ___/ / ___/ Version 1.3.3 _/ // /_/ / / / (__ ) https://www.idris-lang.org/ /___/\\__,_/_/ /_/____/ Type :? for help Idris is free software with ABSOLUTELY NO WARRANTY. For details type :warranty. Idris\u0026gt; :mkdoc Docs IdrisDoc generated *Docs\u0026gt; Bye bye $ ls doc IdrisDoc docs index.html styles.css これで生成されたドキュメントを見るとpreludeなどに混じってDocs モジュールのドキュメントがあるのが確認できます。\nコマンドラインから 残念ながら単一のファイルのドキュメントを生成するコマンドはなさそうでした （コンパイラの実装を見ましたが、 --mkdoc しかなかったです）。しかしパッケージのドキュメントを生成することはできます。\nさっきの Docs をパッケージにしましょう。サクッと以下のようなディレクトリを作ります。\n$ tree . ├── Docs.ipkg └── src └── Docs.idr そして Docs.ipkg には以下の記述をします。\npackage Docs version = \u0026#34;0.1.0\u0026#34; author = your name sourcedir = src modules = Docs あとは idris --mkdoc Docs.ipkg を打つだけです。\n$ idris --mkdoc Docs.ipkg Type checking src/Docs.idr $ ls Docs.ipkg docs_doc src こっちは 小文字のモジュール名_doc にドキュメントが生成されます。 内容はREPLのものと変わりません。\nインストールとdocdir ちょっと何に使うのか分かってないのですが、ドキュメントをインストールすることもできます。 --installdoc IPKG のコマンドです。\n$ idris --installdoc Docs.ipkg これは idris --docdir で表示される場所にドキュメントをインストールします。\n$ ls $(idris --docdir) base contrib docs effects prelude pruviloj ls の結果の中に docs がいますね。 …ですがこれをどうしたらいいのかよく分かってません。Idris側ではこれらを表示するコマンドやサーバを立てる方法は用意してないようです。\n強いていうなら以下のようにワンライナーサーバを立てるくらいでしょうか。\n$ ruby -run -e httpd $(idris --docdir) まとめ Idrisdocの記法と生成ツールの使い方を紹介しました。 Idrisdocにはマークダウンと引数の説明の文法がありました。 生成ツールにはREPLから起動して名前空間を指定する方法とCLIから起動してパッケージのドキュメントを生成する方法がありました。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-19","title":"Idrisdocの使い方","url":"https://KeenS.github.io/blog/2020/12/19/idrisdocnotsukaikata/"},
  {"body":"このエントリはIdris Advent Calendar 2020の14日目の記事です。\nκeenです。今回はIdrisのパッケージ機能とipkgについて説明します。\nidris コマンドは単体でかなり高機能で、パッケージシステムも内包します。\n標準ライブラリにpreludeとbaseがあるのは既に説明したとおりですが、他にもcontrib、effects、pruvilojというパッケージも添付されています。これらはパッケージシステムを使ってリンクしないと使えないようになっています。\nこれらの中でもcontribは重要です。 Idrisは標準ライブラリへの貢献に対してかなり保守的な態度を取っており、大抵のライブラリ強化の提案はcontribへとマージされることになっています。結果としてcontribがないとライブラリが貧弱な言語になってしまいます。\ncontribを使う：アナグラム まずはパッケージを使ってみましょう。アナグラムを検知するプログラムです。例えば\u0026rdquo;eat\u0026rdquo;と\u0026rdquo;ate\u0026rdquo;は文字を並べ替えると互いに変換できるのでアナグラムの関係にあります。\n実装方針としてはアナグラムの正規形、文字をアルファベット順に整列したものをキーとしてアナグラムの集合をバリューにもつマップを作ればよさそうです。上の例だと \u0026quot;aet\u0026quot; -\u0026gt; [\u0026quot;eat\u0026quot;, \u0026quot;ate\u0026quot;] の関係を保持します。\nキーバリューペアはcontribの Data.SortedMap にあり、集合は Data.SortedSetにあります。早速使っていきましょう。\nmodule Anagram import Data.SortedMap import Data.SortedSet まずは SortedMap をインポートしました。\n最初の値 空のDBも定義しておきましょう。\nexport AnagramDB : Type AnagramDB = SortedMap String (SortedSet String) export emptyDB : AnagramDB emptyDB = empty 単語の登録 新しい値を登録する処理 register は、まずは登録する単語の正規形を計算して、それをキーにDBにエントリがあればリストにデータを加え、なければ新たにデータを登録すればよさそうです。\nまずは正規形を計算する関数を。\nnormalize : String -\u0026gt; String normalize = pack . sort . unpack normalize は少し説明が必要でしょうか。ここで使っている . は関数の合成です。 そして unpack: String -\u0026gt; List Char と pack: List Char -\u0026gt; String はそれぞれ String \u0026lt;-\u0026gt; List Char の変換を担当します。\n合成の様子を順番に見ると、以下のような動きをします。\nIdris\u0026gt; unpack \u0026#34;eat\u0026#34; [\u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;t\u0026#39;] : List Char Idris\u0026gt; (sort . unpack) \u0026#34;eat\u0026#34; [\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;t\u0026#39;] : List Char Idris\u0026gt; (pack . sort . unpack) \u0026#34;eat\u0026#34; \u0026#34;aet\u0026#34; : String あとの register は簡単に書けます。\nexport register: AnagramDB -\u0026gt; String -\u0026gt; AnagramDB register db word = let key = normalize word in case lookup key db of Just set =\u0026gt; insert key (insert word set) db Nothing =\u0026gt; insert key (insert word empty) db insert word set と insert word empty をみてどうにか頑張れば1つにまとめられるのではと気付いた方、勘がいいです。 SortedMap と union 演算は（自由）半群なので多少楽に書けるAPIもありますが、今回はパッケージ以外はあんまり変なことをしない方針なので一旦スルーします。興味があればドキュメントを読んで別の実装を与えてみて下さい。\n単語のクエリ ある単語のアナグラムを検索する関数 query も作っておきましょう。 1つ注意しないといけないのが、その単語は自身のアナグラムなので必ずアナグラムは1つ以上あるということです。 さらに、その単語自体は登録されてなくてもアナグラムが登録されていれば返す値に検索ワードも入れないといけない点です。 それに注意して実装すると以下のようになります。\nexport query : AnagramDB -\u0026gt; String -\u0026gt; SortedSet String query db word = let key = normalize word in case lookup key db of Just set =\u0026gt; insert word set Nothing =\u0026gt; insert word empty パッケージのリンク 一旦REPLで様子を見たいんですが、REPLでcontribを使えるようにしないといけませんね。 -p パッケージ名 でパッケージをロードした状態でREPLをはじめられます。\n$ idris -p contrib Anagram.idr ... Anagram*\u0026gt;  型チェックまで通ったら試してみましょう。\n*Anagram\u0026gt; :let db = register (register emptyDB \u0026#34;eat\u0026#34;) \u0026#34;ate\u0026#34; *Anagram\u0026gt; query db \u0026#34;tea\u0026#34; SetWrapper (M 1 (Branch3 (Leaf \u0026#34;ate\u0026#34; ()) \u0026#34;ate\u0026#34; (Leaf \u0026#34;eat\u0026#34; ()) \u0026#34;eat\u0026#34; (Leaf \u0026#34;tea\u0026#34; ()))) : SortedSet String ちょっとみづらいですが \u0026ldquo;ate\u0026rdquo; 、 \u0026ldquo;eat\u0026rdquo; 、 \u0026ldquo;tea\u0026rdquo; が含まれているのでよさそうです。\nファイルからの読み込み さっきまでの内容はライブラリとして、 Main を作っていきましょう\nmodule Main import Anagram さて、単語が沢山書かれているファイルから読み込んで、DBに登録してみましょう。 UNIX系OSを使っているなら /usr/share/dict/words というファイルがあるはずです。ここに10万くらいの単語が入っています。\n$ wc -l /usr/share/dict/words 102774 /usr/share/dict/words 1/5000くらいランダムサンプリングしてみましょう。\n$ cat /usr/share/dict/words | awk \u0026#39;int(rand()*5000) == 1 { print $0 }\u0026#39; Chengdu\u0026#39;s Edinburgh Poitier aforementioned ambulatory busbies confetti courier\u0026#39;s cowslip decorous demurred deviants dotcom\u0026#39;s fabricates freebasing glorification libellers male neocolonialism plasticity\u0026#39;s reduces sough temptation\u0026#39;s wrapping\u0026#39;s このように本当に単語が改行で並べられているだけのファイルです。 ここからアナグラムDBを作りましょう。 /usr/share/dict/words がなかった方は適当にファイルを用意して下さい。\nもうそろそろ解説がなくても読めるようになった頃ですかね。\nimportFromFile : (filename: String) -\u0026gt; IO (Either FileError AnagramDB) importFromFile filename = do Right file \u0026lt;- openFile filename Read | Left e =\u0026gt; pure (Left e) loop file emptyDB where loop : File -\u0026gt; AnagramDB -\u0026gt; IO (Either FileError AnagramDB) loop file db = do isEOF \u0026lt;- fEOF file if isEOF then pure $ Right db else do Right word \u0026lt;- fGetLine file | Left e =\u0026gt; pure (Left e) let db = register db (trim word) loop file db これも一旦REPLにロードして実行してみましょう。 -p contrib を忘れずに。\nここで /usr/share/dict/words をロードしたいところですが問題があります。 今まで説明してませんでしたがREPLだとコンパイラを通さずインタプリタで実行するので遅いです。 そのREPLで10万語を読み込むのには不安があります。\nということで一旦100語くらいの辞書を作りましょう。\n$ cat /usr/share/dict/words | awk \u0026#39;int(rand()*1000) == 1 { print $0 }\u0026#39; \u0026gt; smalldict.txt これくらいだったらブログにも載るので付録に置いておきます。\nでは、これを実行してみましょう。\n*AnagramMain\u0026gt; :x (importFromFile \u0026#34;smalldict.txt\u0026#34;) Can\u0026#39;t convert handles back to TT after execution. 成功したか分かりづらいですがエラーは出てないので大丈夫でしょう。\n表示、実行 そろそろパッケージから離れてきたのでサクっといきましょう。\nSortedSet はそのままだと表示できないので加工する必要があります。 Data.SortedSet をいインポートしておきましょう。\nimport Data.SortedSet 表示、 main は以下です。\nshowResult: AnagramDB -\u0026gt; String -\u0026gt; IO () showResult db word = let anagrams = Anagram.query db word in printLn $ SortedSet.toList anagrams main : IO () main = do [_, key] \u0026lt;- getArgs Right db \u0026lt;- importFromFile \u0026#34;/usr/share/dict/words\u0026#34; showResult db key 今回はコンパイルして実行するので /usr/share/dict/words を読み込んでます。\n以下のコマンドでコンパイル/実行します。\n$ idris -o AnagramMain -p contrib AnagramMain.idr $ ./AnagramMain tea [\u0026#34;ate\u0026#34;, \u0026#34;eat\u0026#34;, \u0026#34;eta\u0026#34;, \u0026#34;tea\u0026#34;] 多少時間がかかりますが、正しく動いています。\nパッケージを作る さきほどのアナグラムをパッケージにしてみましょう。 パッケージにすることでビルドが楽になります。\n新しくディレクトリを作り、さらにその下に src/ を作ります。 そして先程の Anagram.idr と AnagramMain.idr を src に入れます。\n$ mkdir -p anagram/src $ mv Anagram.idr anagram/src $ mv AnagramMain.idr anagram/src $ cd anagram ipkg Idrisにはパッケージ機構があるのは説明した通りです。そのためのファイルを書きましょう。 anagram.ipkg に以下の内容を書きます。\npackage anagram version = \u0026#34;0.1.0\u0026#34; author = your name sourcedir = src modules = Anagram , AnagramMain main = AnagramMain executable = anagram pkgs = contrib 少し解説しましょう。 ipkgはIdrisの独自フォーマットで、パッケージのメタデータやビルド情報などを記述します。\n中身は package から始まります。\npackage anagram そして version 、 author などのメタ情報を書きます。\nversion = \u0026#34;0.1.0\u0026#34; author = your name ソースコード情報として sourcedir や modules も書きます。\nsourcedir = src modules = Anagram , AnagramMain main のあるファイルや作成する実行可能ファイルも書きます。\nmain = AnagramMain executable = anagram ビルドするときにリンクするパッケージを書きます。\npkgs = contrib 詳細はドキュメントを読んで下さい。\nこれをビルドしてみましょう。\n$ idris --build anagram.ipkg $ ls anagram anagram.ipkg src カレントディレクトリに anagram ができました。実行してみましょう。\n$ ./anagram ocean [\u0026#34;canoe\u0026#34;, \u0026#34;ocean\u0026#34;] 正しく動いていますね。\nこのようにパッケージを作るとコマンド一発でビルドできるようになります。\nパッケージをインストールする idris --install IPKG でライブラリをインストールすることもできます。 IdrisのWikiにはサードパーティのライブラリが載っていて、それをダウンロードしてインストールできる仕組みになっています。\nLibraries · idris-lang/Idris-dev Wiki\nライブラリを使わないまでも、インストールだけでも試してみましょう。lightyearをインストールしてみます。\n$ git clone https://github.com/ziman/lightyear.git $ cd lightyear $ idris --install lightyear.ipkg Type checking ./Lightyear/Position.idr Type checking ./Lightyear/Core.idr Type checking ./Lightyear/Combinators.idr Type checking ./Lightyear.idr Type checking ./Lightyear/Char.idr Type checking ./Lightyear/Strings.idr Type checking ./Lightyear/StringFile.idr Type checking ./Lightyear/Testing.idr Installing Lightyear.ibc to /home/shun/.cabal/store/ghc-8.8.3/idris-1.3.3-0851a67ad4b1dcdc142d91174b2e9b6104a6df9b6243943de3f9ab0e56756b9a/share/libs/lightyear Installing Lightyear/Position.ibc to /home/shun/.cabal/store/ghc-8.8.3/idris-1.3.3-0851a67ad4b1dcdc142d91174b2e9b6104a6df9b6243943de3f9ab0e56756b9a/share/libs/lightyear/Lightyear Installing Lightyear/Core.ibc to /home/shun/.cabal/store/ghc-8.8.3/idris-1.3.3-0851a67ad4b1dcdc142d91174b2e9b6104a6df9b6243943de3f9ab0e56756b9a/share/libs/lightyear/Lightyear Installing Lightyear/Combinators.ibc to /home/shun/.cabal/store/ghc-8.8.3/idris-1.3.3-0851a67ad4b1dcdc142d91174b2e9b6104a6df9b6243943de3f9ab0e56756b9a/share/libs/lightyear/Lightyear Installing Lightyear/StringFile.ibc to /home/shun/.cabal/store/ghc-8.8.3/idris-1.3.3-0851a67ad4b1dcdc142d91174b2e9b6104a6df9b6243943de3f9ab0e56756b9a/share/libs/lightyear/Lightyear Installing Lightyear/Strings.ibc to /home/shun/.cabal/store/ghc-8.8.3/idris-1.3.3-0851a67ad4b1dcdc142d91174b2e9b6104a6df9b6243943de3f9ab0e56756b9a/share/libs/lightyear/Lightyear Installing Lightyear/Char.ibc to /home/shun/.cabal/store/ghc-8.8.3/idris-1.3.3-0851a67ad4b1dcdc142d91174b2e9b6104a6df9b6243943de3f9ab0e56756b9a/share/libs/lightyear/Lightyear Installing Lightyear/Testing.ibc to /home/shun/.cabal/store/ghc-8.8.3/idris-1.3.3-0851a67ad4b1dcdc142d91174b2e9b6104a6df9b6243943de3f9ab0e56756b9a/share/libs/lightyear/Lightyear Installing 00lightyear-idx.ibc to /home/shun/.cabal/store/ghc-8.8.3/idris-1.3.3-0851a67ad4b1dcdc142d91174b2e9b6104a6df9b6243943de3f9ab0e56756b9a/share/libs/lightyear このようにインストールできます。インストールが済んでしまえば idris -p lightyear やipkgの pkgs に書くと使えるようになります。 シンプルながらも簡単に使えていいですね。\nipkgの他の機能 --build や --install を紹介しましたが、REPLに読み込む --repl やドキュメントの作成などがあります。 idris --help などで確認してみて下さい。\nまとめ Idrisのパッケージやipkgの紹介をしました。\nipkgは便利ですが、コマンドが長いのといつも .ipkg の書き方を忘れるので私は便利コマンドを作っていたりします。\nblackenedgold/ipkg\nもし興味があれば使ってみて下さい。\n付録 100語の辞書\nAlba\u0026#39;s Ceylon Goddard\u0026#39;s Guggenheim Ines Kubrick\u0026#39;s Muslims Paderewski\u0026#39;s Phillipa\u0026#39;s Reinhardt Rumsfeld\u0026#39;s Salome\u0026#39;s Saudi\u0026#39;s Schlitz Titanic Waldheim\u0026#39;s Xi\u0026#39;an\u0026#39;s abide aborted acceded adaptability affirm amiability asphalting belligerency blasphemed boars bowl caldrons carefullest cesarian commissioner conciliators conclusion\u0026#39;s constituents cowardly crush\u0026#39;s defender dewy downers drabs drouthes finality\u0026#39;s gaskets giggle glamour\u0026#39;s greasy grouting headgear hied hookworm\u0026#39;s hurry knot lab lavishest louvered mallet markdown minuscule misdeals misquote\u0026#39;s mitosis mountaineers objectionably overawing ovule pertinacious phototypesetting phrased polliwog promiscuity quadruplet replete repugnance\u0026#39;s safekeeping salt\u0026#39;s spanks spun steamship\u0026#39;s supermen suspenseful suspicion\u0026#39;s taxidermists teetotaller testosterone\u0026#39;s tints totalitarians tramming typography wafers wear weasel whined workingman","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-17","title":"Idrisのパッケージとipkg","url":"https://KeenS.github.io/blog/2020/12/17/idrisnopakke_jitoipkg/"},
  {"body":"このエントリはIdris Advent Calendar 2020の13日目の記事です。\nκeenです。 今回は座学パートとして標準ライブラリでよく使われてるけどまだ触れてない記法に触れていこうと思います。\n名前つきパラメータ Idrisでは関数の型でもパラメータ名を与えられます。 例えば前回出てきた replicate の定義なんかがそうですね。\nreplicate : (n : Nat) -\u0026gt; (x : a) -\u0026gt; List a n と x がパラメータ名です。 このケースでは以下のようにパラメータ名がなくても意味は変わりません。\nreplicate : Nat -\u0026gt; a -\u0026gt; List a ただのドキュメント的存在として名前がついています。 特に標準ライブラリでは多用されているので覚えておきましょう。 エディタサポートでもこの名前は有用なのですが、それはいつか紹介したいと思います。\nさて、この名前つきパラメータが重要な意味をもつこともあります。 List ではなく Vect の replicate を見てみましょう。\nreplicate : (len : Nat) -\u0026gt; (x : elem) -\u0026gt; Vect len elem 最初にでてきた len のパラメータが返り型 Vect len elem で使われてますね。 こういう引数に応じて返り型が変わるときにも有用です。\n理論的には依存積やΠ型と呼ばれ、論理学では全称量化に対応します。\nGADT data name = ... で定義するデータ型がありますよね？ あれは代数的データ型（Algebraic Data Types、 ADT）と呼ばれるんですが、それを一般化した Generalized ADT、略してGADTというのがあります。普通のADTの定義の別記法のようなものですが、表現力が増してます。 これも標準ライブラリでよく使われています。\nList a をサクっと定義すると以下のようになりますよね。？\ndata List a = Nil | (::) a (List a) この宣言で List 、 Nil 、 (::) の3つのシンボルが定義された訳です。 そしてそれぞれの型は以下のようになります。\nIdris\u0026gt; :t List List : Type -\u0026gt; Type Idris\u0026gt; :t Nil Nil : List elem Idris\u0026gt; :t (::) (::) : elem -\u0026gt; List elem -\u0026gt; List elem ここまでは大丈夫ですね？\nこの型を強調する書き方がGADTで、 data 名前: 型 where コンストラクタ: 型 ... の書き方をします。 例えばプレリュードでの List の定義は以下のようになっています。\ndata List : (elem : Type) -\u0026gt; Type where Nil : List elem (::) : (x : elem) -\u0026gt; (xs : List elem) -\u0026gt; List elem 名前つきパラメータと一緒にGADTが使われていますね。 定義としては上の方のシンプルな定義と同等です。 標準ライブラリのドキュメントとかでよく出てくるので覚えておきましょう。\nさて、GADTはADTに比べて表現力が増してると書きました。 GADTは Nil の List elem や (::) の -\u0026gt; List elem のようにそれぞれのコンストラクタがどの型になるかを指定できます。 型を細かく指定できるIdrisではこれが有用なのです。\nADTで書けなくてGADTで書ける例を見てみましょう。baseの Vect の定義です。\ndata Vect : (len : Nat) -\u0026gt; (elem : Type) -\u0026gt; Type where Nil : Vect Z elem (::) : (x : elem) -\u0026gt; (xs : Vect len elem) -\u0026gt; Vect (S len) elem Nil は Vect Z elem と長さ0であることが指定されています。 (::) は (x : elem) -\u0026gt; (xs : Vect len elem) -\u0026gt; Vect (S len) elem と長さ len の xs に x を加えて長さ S len になることが指定されています。\nようやくIdrisらしさが出てきましたね。\nまとめ Idrisの名前つきパラメータとGADTを紹介しました。 この2つを押えたらAPIドキュメントは大体読めるはずです。 残るは依存和と証明オブジェクトですがそれはまたの機会に。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-16","title":"Idrisの名前つきパラメータとGADT","url":"https://KeenS.github.io/blog/2020/12/16/idrisnonamaetsukiparame_tatogadt/"},
  {"body":"このエントリはIdris Advent Calendar 2020 の12日目の記事です。\nκeenです。今回は手を動かすパートとしてビットマップ画像の書き出しをIdrisでやってみます。 依存型やIdrisの標準ライブラリ、ファイルの扱いなどの練習になればなと思ってます。\nビットマップ画像とは ビットマップ画像（正確にはBMP、Windows bitmap）とはほぼ色のデータをそのまま持っていることで有名なシンプルな画像フォーマットですね。Wikipediaなんかに画像フォーマットが載っています。\nフォーマットにはいくつか変種があるのですが、その中で一番簡単なフォーマットを書き出してみようと思います。 具体的には画像フォーマットにはいくつかパラメータがあるのですが、以下の設定に固定して書き出します。\n 1ピクセルあたりのビット数：24  こうすることでカラーパレットが不要になる  圧縮形式：0  無圧縮   一番簡単なデータの場合はBMPは以下のような構造をしています。\n+-------------------+ | ファイルヘッダ | (BITMAPFILEHEADER) +-------------------+ | 情報ヘッダ | (BITMAPINFOHEADER) +-------------------+ | ビットマップデータ | +-------------------+ 特筆すべきはカラーパレットが不要になる点です。\nそれぞれ見ていきましょう。\nBITMAPFILEHEADER    オフセット サイズ 格納する情報 値・備考     0x0000 2バイト ファイルタイプ 常にBM (0x42, 0x4d)（マジックナンバー）   0x0002 4バイト ファイルサイズ ビットマップファイルのサイズを格納する（単位はバイト）。   0x0006 2バイト 予約領域1 常に0   0x0008 2バイト 予約領域2 常に0   0x000a 4バイト オフセット ファイルヘッダの先頭アドレスからビットマップデータの先頭アドレスまでのオフセット（単位はバイト）。    引用元: Windows bitmap - Wikipedia\n今回の形式だとカラーパレットがないのでオフセットが固定値になります。\nBITMAPINFOHEADER    オフセット サイズ 格納する情報 値・備考     0x000e 4バイト ヘッダサイズ 40   0x0012 4バイト ビットマップの横幅 単位はピクセル   0x0016 4バイト ビットマップの縦幅 単位はピクセル。値が負の場合はトップダウン画像となる   0x001a 2バイト プレーン数 常に1   0x001c 2バイト 1ピクセルあたりのビット数 0,1,4,8,16,24,32   0x001e 4バイト 圧縮形式 0,1,2,3,4,5 ※1   0x0022 4バイト 画像データサイズ 単位はバイト   0x0026 4バイト 水平方向の解像度 単位はピクセル/m   0x002a 4バイト 垂直方向の解像度 単位はピクセル/m   0x002e 4バイト 使用する色数 ビットマップで実際に使用するカラーパレット内のカラーインデックスの数。   0x0032 4バイト 重要な色数 ビットマップを表示するために必要なカラーインデックスの数。    引用元: Windows bitmap - Wikipedia\n1ピクセルあたりのビット数は24bit、圧縮形式は0にするとしました。 水平方向の解像度と垂直方向の解像度はよくわからない（設定しても表示に変わりがない）ので0にします。 今回カラーパレットがないので使用する色数と重要な色数は0にできます。\nすると残るパラメータはビットマップの横幅、ビットマップの縦幅、画像データサイズです。\nビットマップデータ 1ピクセルあたり24bitならばBGR形式でデータを置いていきます。 ただし1行のデータが4の倍数でない場合は4の倍数になるように末尾に 0x00 を詰めてあげます。\n例えば3x3の画像だとこんな感じですかね。\n0123456789ab +------------+ |BGRBGRBGR000| +------------+ |BGRBGRBGR000| +------------+ |BGRBGRBGR000| +------------+ 因みにBMPは座標系が数学と一緒で0行目が一番下、最終行が一番上です。 他のよくある画像フォーマットと天地が逆になってるので注意して下さい。\nイメージ掴めましたか？\nやってみよう ビットマップデータを受け取ってそれをBMP形式として書き出すプログラムを書いてみます。 ほとんどのパラメータは固定なので、ビットマップデータから以下の4つのパラメータさえ計算できればあとは簡単に書き出せます。\n ファイルサイズ ビットマップの横幅 ビットマップの縦幅 画像データサイズ  Vect 今回は依存型に触れてみるというテーマもあるので Vect 型を使います。 アドベントカレンダー初日でも紹介しましたが、Vect は長さ情報を型に持つリストです。 baseの Data.Vect に定義されています。\n少しだけREPLで Vect を使ってみましょう。\nIdris\u0026gt; :module Data.Vect *Data/Vect\u0026gt; the (Vect _ _) [1, 2, 3] [1, 2, 3] : Vect 3 Integer *Data/Vect\u0026gt; the (Vect _ _) [1, 2, 3, 4] [1, 2, 3, 4] : Vect 4 Integer *Data/Vect\u0026gt; the (Vect _ _) ([1, 2, 3, 4] ++ [1, 2, 3]) [1, 2, 3, 4, 1, 2, 3] : Vect 7 Integer このようにちゃんと要素数と型の Vect n Integer の n の部分が対応しています。 しかも (++) で結合しても正しく要素数が保持されています。\nこれを使えば入力画像のデータを表現できそうです。\n画像のデータ型 画像のデータ型 BitMap を定義しましょう。\n…とその前に色を表わす型、 Color を定義しておきます。\npublic export Color : Type Color = (Bits8, Bits8, Bits8) 復習するとIdrisでは型も値として扱えるので、グローバル変数の定義でもって型エイリアスが作れるのでした。 ここで登場する Bits8 は（あんまりドキュメントに載っていない）Idrisのプリミティブで、8bitの数を表わします。符号があるかないかは分かりません。\n可視性に public export がついています。 外部とのやりとりにも Color を使いたいので export が、中身が (Bits8, Bits8, Bits8) であることも公開したいので public がついています。\nさて、色も定義し終わって BitMap レコードを定義します。\nimport Data.Vect export record BitMap (x : Nat) (y : Nat) where constructor MkBitMap imgData: Vect y (Vect x Color) 画像データは Vect y (Vect x Color) と表現しています。シンプルで分かりやすいですね。\nレコードの定義部分が record BitMap (x : Nat) (y : Nat) と、パラメータ x 、 y が (x : Nat) の形になっています。レコードのパラメータは無言でパラメータを書くと型として扱われるのですが、今回は Vect に渡す数値をパラメータとしたいのでその宣言です。\n画像データの定義に Vect を使っているので入力は正確に横幅 x 高さ y であることが保証できます。 リストのリストや可変長ベクトルの可変長ベクトルのようなデータ型だとサイズを正確に表現することができません。こういったところで正確になれるのは依存型の利点かなと思います。\nBitMap の定義から直ちに fromData のような関数は書けますね。\nexport fromData : Vect y (Vect x Color) -\u0026gt; BitMap x y fromData img = MkBitMap img MkBitMap そのまま公開するよりもあとで他の操作を加える余地が残ります。 実際、BitMapの複雑なフォーマットに対応しようと思ったらカラーパレットの計算などの処理が挟まります。\n因みに、Idrisは関数型言語なので関数は一級市民です。 上記の関数は仮引数を取らずに以下のようにも書けます。\nexport fromData : Vect y (Vect x Color) -\u0026gt; BitMap x y fromData = MkBitMap 好きな方で定義してみて下さい。上級者ほど仮引数を取らない書き方を好むようです。\nパラメータの計算 復習すると、必要なパラメータは以下の4つでした。\n ファイルサイズ ビットマップの横幅 ビットマップの縦幅 画像データサイズ  まずは簡単なビットマップの縦横幅を計算しましょう。\nType reification 正確な用語は分からないのですが、Idrisでは型を実行時に取り出すことができます。これをひとまずtype reificationと呼ぶことにします。 どういうことかというと、普通の言語で上記 BitMap x y から y を取り出そうとすると以下のようなコードを書くことになるかと思います。\ngetY : BitMap x y -\u0026gt; Int getY b = cast $ length $ imgData b Vect のデータの長さを計算していますね。これが普通です。\nですが、Idrisは Vect y _ のようにデータの長さを型に持っています。 これを取り出せないでしょうか。結論を言うと取り出せます。\n以下のようなコードで取り出せます。\ngetY : BitMap x y -\u0026gt; Int getY {y} _ = cast y getY の仮引数の前に {y} を置くことで型にある y を取り出せるのです。 すごいですね。\nこの記法はいくつかの機能が混ざってるのでちょっとほぐしましょう。\nまず、 {y} と書いてあるのは {y = y} の省略形です。 {パラメータ名 = 変数名} の構文です。 型にある変数 y を値にある変数 length に束縛するには以下のように書きます。\ngetY : BitMap x y -\u0026gt; Int getY {y = length} _ = cast length さらに、 {y = ...} で取り出せるのは暗黙のパラメータ（implicit parameter）という機能のおかげです。 BitMap x y と無言で書くと x 、 y が自然数の型パラメータであることが宣言されるのが不思議に思った方はいませんか？これはコンパイラが裏でパラメータを追加しているからです。\n暗黙のパラメータを省略せずに書くとこうなります。\ngetY : {x: Nat} -\u0026gt; {y: Nat} -\u0026gt; BitMap x y -\u0026gt; Int getY {y = length} _ = cast length 暗黙のパラメータは {変数名: 型} の構文で定義します。複数ある場合は上記のように1つづつ書くか、 型が同じなら {変数名1, 変数名2...: 型} とカンマで区切って書いてもよいです。\ngetY : {x, y: Nat} -\u0026gt; BitMap x y -\u0026gt; Int getY {y = length} _ = cast length 暗黙のパラメータは普段はコンパイラが勝手に埋めてくれるので気にしなくていいんですが、手で与えることもできます。\nIdris\u0026gt; :t getY getY : BitMap x y -\u0026gt; Int Idris\u0026gt; :t getY {x = 1} {y = 1} getY : BitMap 1 1 -\u0026gt; Int さて、ちょっと色々情報を詰め込みすぎましたかね。 さしあたっては getX と getY は以下のように定義できるとだけ了解しておいて下さい。\ngetX : {x: Nat} -\u0026gt; BitMap x y -\u0026gt; Int getX {x} _ = cast x getY : {y: Nat} -\u0026gt; BitMap x y -\u0026gt; Int getY {y} _ = cast y 計算せずにサイズがとれる！ついでにいうと getX 行のサイズを計算するために1行目の要素を取り出すけど値がなかったら場合は…とかを考えなくてすみます。\nIdris2からは暗黙のパラメータは {...} -\u0026gt; で明示的に書かないと取り出せないようになってるらしいので今のうちにその書き方をすることにします。\nファイルサイズとデータサイズ 続けてファイルサイズとデータサイズを計算しましょう。こっちは地道に計算するだけです。\nデータサイズを計算しましょう。1ピクセル3バイトなので $x \\times y \\times 3$ かと思いきや、1行を4バイトの倍数に切り上げるという仕様なのでちょっとだけ計算が必要です。\nまず、切り上げるときのパディングサイズの計算はこうできますね。\npadSize: Nat -\u0026gt; Int padSize x = (4 - ((cast $ x * 3) `mod` 4)) `mod` 4 `mod` 4 が2回挟まってますが、2回目の `mod` 4 は4を0にするための計算です。\nこれを使って BitMap x y からデータサイズを計算する関数は以下のように書けます。\ndataSize : {x, y: Nat} -\u0026gt; BitMap x y-\u0026gt; Int dataSize {x} {y} _ = let rowSize = (cast $ x * 3) + (padSize x) in rowSize * (cast y) ここでもtype reification（？）を使ってます。\nヘッダサイズが54でそれ以外にはビットマップデータしかないのでファイルサイズは簡単に計算できます。\noffset : Int offset = 14 + 40 fileSize : BitMap x y -\u0026gt; Int fileSize bitmap = offset + (dataSize bitmap) これで必要なパラメータが揃ったのでデータを書き出していきます。\nファイルとバッファ これからBMPフォーマットのファイルを作ります。 最終的にはファイルに書き出すんですが、プログラム内では一旦バッファに書き出して、それをあとでまとめてファイルに書き出しましょう。 その方がファイル関連のエラーを1まとめにできますからね。（あとIdrisのファイルAPIに欠陥があってバイトを書き出す手段がないというのもあります。）\nファイルに書き出せるバッファは Data.Buffer に定義されているのでインポートします。\nimport Data.Buffer import 文はファイルの先頭の方で書かないといけないので注意して下さいね。\nさて、 Buffer のAPIなんですが、主に使うのは setByte : Buffer -\u0026gt; (loc : Int) -\u0026gt; (val : Bits8) -\u0026gt; IO () と setInt : Buffer -\u0026gt; (loc : Int) -\u0026gt; (val : Int) -\u0026gt; IO () です。 これらは書き込む場所を引数にとりますね。 我々の用途では1バイトずつずらしながら書き込んでいくので loc を持って回らないといけません。 それはちょっと面倒なので Buffer と loc をまとめたデータ型を定義しておきましょう。\ndata Output = MkOutput Buffer Int もうちょっとユーティリティ関数を定義します。\nまずは Output に Int を書き込んでくれる関数 writeInt です。\n||| Write int in little endian writeInt : Output -\u0026gt; Int -\u0026gt; IO Output writeInt (MkOutput buffer loc) int = do setInt buffer loc int pure $ MkOutput buffer (loc + 4) 返り値に loc が更新された Output を返します。 ||| ではじまる行はドキュメントコメントです。いつか解説します。 ドキュメントでは明示されてませんが実装を読む限り setInt はリトルエンディアンで4バイト書くAPIのようです。 今回の目的に適ってるのでそれを使います。\n複数のバイトを受け取って書き出す writeBytes も定義しましょう。\nwriteBytes : Output -\u0026gt; List Bits8 -\u0026gt; IO Output writeBytes o [] = pure o writeBytes (MkOutput buffer loc) (b::bs) = do setByte buffer loc b writeBytes (MkOutput buffer (loc + 1)) bs これで準備OKです。\nイメージフォーマットの書き出し 復習するとBMPフォーマットは以下の形をしているのでした。\n+-------------------+ | ファイルヘッダ | (BITMAPFILEHEADER) +-------------------+ | 情報ヘッダ | (BITMAPINFOHEADER) +-------------------+ | ビットマップデータ | +-------------------+ これに対応して、画像フォーマットを書き出すAPIは以下のような見た目になります。\nexport writeBitMap : File -\u0026gt; BitMap x y -\u0026gt; IO () writeBitMap f bitmap = do -- ... let o = MkOutput buf 0 o \u0026lt;- writeHeader o bitmap o \u0026lt;- writeInfoHeader o bitmap o \u0026lt;- writeImgData o bitmap -- ... 前後にバッファを用意する作業やファイルに書き出す作業が挟まりますがイメージは掴めるでしょう。 こうやって使うことを想定して、 writeHeader 、 writeInfoHeader 、 writeImgData を定義します。\nwriteHeader writeHeader はパラメータはファイルサイズしかなかったので直線的なコードになります。\nwriteHeader : Output -\u0026gt; BitMap x y -\u0026gt; IO Output writeHeader o bitmap = do -- file type o \u0026lt;- writeBytes o [0x42, 0x4d] -- file size o \u0026lt;- writeInt o (fileSize bitmap) -- reserved 1 o \u0026lt;- writeBytes o [0x00, 0x00] -- reserved 2 o \u0026lt;- writeBytes o [0x00, 0x00] -- offset o \u0026lt;- writeInt o offset pure o offset は「ファイルサイズとデータサイズ」のところで定義した変数です。\nwriteInfoHeader writeInfoHeader も writeHeader に続いて直線的なコードです。 パラメータが横幅、高さ、データサイズだけです。\nwriteInfoHeader : Output -\u0026gt; BitMap x y -\u0026gt; IO Output writeInfoHeader o bitmap = do -- header size o \u0026lt;- writeInt o 40 -- windows format -- width o \u0026lt;- writeInt o (getX bitmap) -- height o \u0026lt;- writeInt o (getY bitmap) -- # of plane o \u0026lt;- writeBytes o [0x01, 0x00] -- # of bits of the colors o \u0026lt;- writeBytes o [24, 0] -- compression format o \u0026lt;- writeBytes o [0x00, 0x00, 0x00, 0x00] -- no compression -- image data size o \u0026lt;- writeInt o (dataSize bitmap) -- TODO: horizontal resolution (px/m) o \u0026lt;- writeInt o 0 -- TODO: vertical resolution (px/m) o \u0026lt;- writeInt o 0 -- # of colors in the pallet o \u0026lt;- writeInt o 0 -- # of important colors o \u0026lt;- writeInt o 0 pure o writeImgData writeImgData だけはちょびっとだけ複雑です。 画像を書き出す処理は2重ループになるからです。 とはいえ、ループを分けて書けばそんなに難しくありません。\n1行を（パディングをせずに）書き出す処理はこう書けます。\nwriteRow : Output -\u0026gt; Vect m Color -\u0026gt; IO Output writeRow o [] = pure o writeRow o ((r, g, b)::ds) = do o \u0026lt;- writeBytes o [b, g, r] writeRow o ds BMPが画像をRGBではなくBGRで期待することを思い出して下さい。\nwriteRow を使って全ての画像データを書き出す処理はこう書けます。\nwriteImgData : Output -\u0026gt; BitMap x y -\u0026gt; IO Output writeImgData o bitmap = loop o $ imgData bitmap where loop : {m: Nat} -\u0026gt; Output -\u0026gt; Vect n (Vect m Color) -\u0026gt; IO Output loop {m} o [] = pure o loop {m} o (r::rs) = do o \u0026lt;- writeRow o r o \u0026lt;- writeBytes o (replicate (cast (padSize m)) 0x00) loop o rs 普通にループを回しているだけですね。 1行書き出したあとでパディングをする処理が入っている程度です。\nここで使った replicate: Nat -\u0026gt; a -\u0026gt; List a は Prelude.Listで定義されている関数で、x が n 個あるリストを作ります。\nIdris\u0026gt; :t replicate replicate : Nat -\u0026gt; a -\u0026gt; List a Idris\u0026gt; :doc replicate Prelude.List.replicate : (n : Nat) -\u0026gt; (x : a) -\u0026gt; List a Construct a list with n copies of x Arguments: n : Nat -- how many copies x : a -- the element to replicate The function is: Total \u0026amp; public export Idris\u0026gt; replicate 3 \u0026#34;hoge\u0026#34; [\u0026#34;hoge\u0026#34;, \u0026#34;hoge\u0026#34;, \u0026#34;hoge\u0026#34;] : List String writeBitMap 必要な役者が揃ったので writeBitMap を作ってみましょう。\n一気に全体を載せてしまうとこうなります。\nexport writeBitMap : File -\u0026gt; BitMap x y -\u0026gt; IO () writeBitMap f bitmap = do Just buf \u0026lt;- newBuffer (fileSize bitmap) | Nothing =\u0026gt; putStrLn \u0026#34;memory allocation failed\u0026#34; let o = MkOutput buf 0 o \u0026lt;- writeHeader o bitmap o \u0026lt;- writeInfoHeader o bitmap o \u0026lt;- writeImgData o bitmap let MkOutput buffer _ = o buffer \u0026lt;- writeBufferToFile f buffer (fileSize bitmap) pure () Buffer は newBuffer で作成します。そしてファイルに書き出すのは writeBufferToFile を使います。 ここまで読んできた方には解説は不要でしょう。\n使ってみよう 先程のコードを EasyBitMap.idr に保存していたとします。 EasyBitMapMain.idr を作成して呼び出してみましょう。\nmodule Main import Data.Vect import EasyBitMap ひとまず必要なものをインポートします。\n画像データは手書きします。\nbitMapData : Vect 16 (Vect 16 Color) bitMapData = [ [w, w, w, w, w, w, w, w, w, w, w, w, w, w, w, w], [w, b, b, b, b, b, b, b, b, b, b, b, b, b, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, w, w, w, w, w, w, w, w, w, w, w, w, b, w], [w, b, b, b, b, b, b, b, b, b, b, b, b, b, b, w], [w, w, w, w, w, w, w, w, w, w, w, w, w, w, w, w] ] where w : Color w = (255, 255, 255) b : Color b = (0, 0, 0) 今回のデータは上下対称ですが、BMPフォーマットでは天地逆さになるので他の画像を試す方は注意して下さい。\nさて、データはこれを使うとして、 main はこう書きます。\nmain : IO () main = do [_, file] \u0026lt;- getArgs | _ =\u0026gt; putStrLn \u0026#34;Usage: FILENAME\u0026#34; Right file \u0026lt;- openFile file WriteTruncate | Left =\u0026gt; putStrLn (\u0026#34;failed to open file: \u0026#34; ++ file) writeBitMap file (fromData bitMapData) fflush file closeFile file openFile 、 WriteTruncate 、 fflush 、 closeFile などは Prelude.Fileで定義されたAPIです。 getArgs は Prelude.Interactiveで定義されています。\nそれではこれをコンパイル・実行してみましょう。\n$ idris -o EasyBitMapMain EasyBitMapMain.idr $ ./EasyBitMapMain test.bmp 私は test.bmp にBMP形式のデータが書き出されました。 適当に開いてみて下さい。Linuxなら eog test.bmp とかで開けます。macOSだと open test.bmp かな？あるいはファイラーでディレクトリを開いてダブルクリックしてみて下さい。 こんな感じの画像が見れるはずです。\nサイズが小さいので豆粒みたいですが、白地に黒い正方形が描かれています。これが表示されたら成功です。\nまとめ IdrisでBMP画像を書き出してみました。 その過程で依存型やType Reification、BufferやFileなどの操作を学びました。\n実はColor Bitsを24に限定すると実装を簡略化できるというのに気付かず、一度任意のColor Bitsに対応したプログラムも作っています。そちらは今回のものよりも踏み込んだ依存型の使い方をしているのでいつか紹介できたらなと思ってます。\n参考文献 今回の記事は一度以下の記事を参考にBMPフォーマットを書き出すプログラムを書いてみたのがベースになっています。\n【バイナリファイル入門】Bitmapファイルを手書きで作って遊んでみる - Qiita\n詳しいフォーマットは記事中でも触れましたがWikipediaを参考にしました。\nWindows bitmap - Wikipedia\n付録A: 今回のコード  付録B: 生成されるBMP画像のバイナリデータ デバッグ用途にどうぞ\n00000000: 424d 3603 0000 0000 0000 3600 0000 2800 BM6.......6...(. 00000010: 0000 1000 0000 1000 0000 0100 1800 0000 ................ 00000020: 0000 0003 0000 0000 0000 0000 0000 0000 ................ 00000030: 0000 0000 0000 ffff ffff ffff ffff ffff ................ 00000040: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000050: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000060: ffff ffff ffff ffff ff00 0000 0000 0000 ................ 00000070: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000080: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000090: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 000000a0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000000b0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000000c0: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 000000d0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000000e0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000000f0: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 00000100: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000110: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000120: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 00000130: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000140: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000150: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 00000160: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000170: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000180: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 00000190: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000001a0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000001b0: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 000001c0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000001d0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000001e0: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 000001f0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000200: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000210: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 00000220: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000230: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000240: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 00000250: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000260: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000270: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 00000280: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000290: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000002a0: 0000 00ff ffff ffff ff00 0000 ffff ffff ................ 000002b0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000002c0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000002d0: 0000 00ff ffff ffff ff00 0000 0000 0000 ................ 000002e0: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 000002f0: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000300: 0000 00ff ffff ffff ffff ffff ffff ffff ................ 00000310: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000320: ffff ffff ffff ffff ffff ffff ffff ffff ................ 00000330: ffff ffff ffff ......","categories":["依存型","Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/%e4%be%9d%e5%ad%98%e5%9e%8b","/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-16","title":"Idris手習い: ビッットマップ画像の書き出し","url":"https://KeenS.github.io/blog/2020/12/16/idristenarai__bitsuttomappugazounokakidashi/"},
  {"body":"このエントリはIdris Advent Calendar 2020の11日目の記事です。\nκeenです。今回はIdrisの複数のファイルだとか標準ライブラリだとかを扱おうと思います。\nモジュール ファイルの先頭で module モジュール名 と宣言するとモジュールが宣言されます。\n例：モジュール Hoge を宣言するコード\nmodule Hoge -- ... モジュールからアテムをエクスポートするには可視性の修飾子をつけます。 可視性の修飾子（export modifiers）は以下の3つがあります。\n private: エクスポートしない export: 型をエクスポートする public export: 定義の詳細をエクスポートする  関数なんかは export 、 インタフェースやデータ型なんかは public export が基本の選択肢になるでしょう。\n他のファイルをインポートするには import ファイル名 を使います。\n例：他のファイルをインポートするコード\nimport Hoge すると Hoge.idr でエクスポートされたアイテムが全て見えるようになります。\n少し試してみましょう。\nHoge.idr に以下の内容を書きます。\n例： Hoge.idr に書く内容\nmodule Hoge private privateHoge : String privateHoge = \u0026#34;private\u0026#34; export exportHoge : String exportHoge = \u0026#34;export\u0026#34; export data exportData = MkExportData String public export data publicData = MkPublicData String モジュール名とファイル名は独立ですが、一致させることが推奨されています。確かIdris2からは一致が強制だったはず。\n次に HogeMain.idr という名前のファイルに以下の内容を書きます。\n例： HogeMain.idr に書く内容\nmodule Main import Hoge main : IO () main = do putStrLn privateHoge putStrLn exportHoge ex: ExportData ex = MkExportData \u0026#34;export\u0026#34; pub: PublicData pub = MkPublicData \u0026#34;public\u0026#34; これをコンパイルしてみましょう。\n例： HogeMain.idr をコンパイルするコマンド\n$ idris -o HogeMain HogeMain.idr HogeMain.idr:6:8-8:21: | 6 | main = do | ~~ ... When checking right hand side of main with expected type IO () When checking an application of function Prelude.Interactive.putStrLn: No such variable privateHoge HogeMain.idr:12:6-26: | 12 | ex = MkExportData \u0026#34;export\u0026#34; | ~~~~~~~~~~~~~~~~~~~~~ When checking right hand side of ex with expected type ExportData No such variable MkExportData 2箇所エラーが出ました。1つ目はここ。\n例：エラーになるコード（1箇所目）\nputStrLn privateHoge Hoge では private で宣言したのでインポートできないんですね。\n2つ目はここ。\n例：エラーになるコード（2箇所目）\nex: ExportData ex = MkExportData \u0026#34;export\u0026#34; この MkExportData の方です。 ExportData は export 宣言されているので型はエクスポートされていますが、 public export でないので定義、すなわちコンストラクタがエクスポートされていません。 こういう細かい制御ができるんですね。\nモジュールとパス さっきのコンパイルコマンド、気付いたことありませんか？再掲すると以下です。\n例：HogeMain.idrをコンパイルするコマンド（再掲）\n$ idris -o HogeMain HogeMain.idr Hoge.idr が登場してませんね。 HogeMain.idr をコンパイルするときにどこから Hoge.idr を探す情報を得ているかというと、 import Hoge です。\nびっくりなことに、 import 文はインポートする ファイル名 を指定する構文なのです。 import ディレクトリ名.ディレクトリ名.ファイル名 とパスを指定する構文になっています。 ファイル内に書かれている module 文は一切関係ありません。\n実験してみましょう。 Hoge/Fuga/Piyo.idr というファイルに Foo というモジュールを作ってみます。\n例： Hoge/Fuga/Piyo.idr を作成するコマンド\n$ mkdir -p Hoge/Fuga $ cat \u0026gt; Hoge/Fuga/Piyo.idr \u0026lt;\u0026lt;EOF module Foo export foo : String foo = \u0026#34;foo\u0026#34; EOF これを利用する Bar.idr というファイルを作ってみて、 Foo ではなく Hoge.Fuga.Piyo をインポートします。\n例： Bar.idr を作成するコマンド\n$ cat \u0026gt; Bar.idr \u0026lt;\u0026lt;EOF module Main import Hoge.Fuga.Piyo main : IO () main = putStrLn foo コンパイル/実行してみましょう。\n例： Bar.idr をコンパイルするコマンド\n$ idris -o Bar Bar.idr $ ./Bar foo 動いてますね。\nでは module は何に使うかというと、名前空間\nモジュールと名前空間 インポートしたアイテムを foo のようにそのまま使っていましたが、名前空間を修飾した形でも使えます。 名前空間.アイテム名 の構文です。\n先程の例だと Hoge.Fuga.Piyo のモジュール名は Foo なので foo の代わりに Foo.foo と書くこともできます。\n例： foo の修飾名を使うコード\nmain : IO () main = putStrLn Foo.foo モジュール名は . で区切ることができるんですが、これで階層構造を作っているようです。 例えば module Hoge.Fuga.Piyo に foo が定義されているとします。 この場合 foo 、 Piyo.foo 、 Fuga.Piyo.foo 、 Hoge.Fuga.Piyo.foo が有効な修飾名です。\nこれも試してみましょう。 先程の Hoge/Fuga/Piyo.idr を以下のように変更します。\n例： Hoge/Fuga/Piyo.idr に書くコード\nmodule Hoge.Fuga.Piyo export foo : String foo = \u0026#34;foo\u0026#34; そして Bar.idr には以下のコードを書きます。\n例： Bar.idr に書くコード\nmodule Main import Hoge.Fuga.Piyo main : IO () main = do putStrLn foo putStrLn Piyo.foo putStrLn Fuga.Piyo.foo putStrLn Hoge.Fuga.Piyo.foo これをコンパイルしてみると、正常に動くことが分かります。\n$ idris -o Bar Bar.idr 名前空間とmain ところで、さっきから main : IO () を書くモジュールに全て Main とつけていたのに気付きましたか？Idrisは Main.main を実行しようとするのです。なので main を置くモジュールは Main と名付ける必要があります。 今までモジュール宣言がなくても動いたのは、宣言がなかったら自動で Main として扱ってくれるからです。\n再エクスポート インポートしたアイテムを再度エクスポートしたい場合は import pubil パス の構文を使います。\nデフォルト可視性 可視性修飾子をつけなければデフォルトでは private です。ですが、ファイル内でこのデフォルトを変更できます。\nIdrisにはディレクティブというのがあるんですが、ひとまずその事実を受け入れて下さい。 そして可視性を変更するには access ディレクティブを使って %access 可視性 と書きます。 すると以降のアイテムにはデフォルトでその可視性が適用されます。 例えば以下のように書きます。\n例： access ディレクティブを使った可視性の制御\nprivateItem : String privateItem = \u0026#34;private\u0026#34; %access export exportItem1 : String exportItem1 = \u0026#34;export\u0026#34; exportItem2 : String exportItem2 = \u0026#34;export\u0026#34; namespaceとオーバーロード Idrisの名前空間の特徴の1つとして名前空間さえ異なれば同じ名前のアイテムを定義できるという点にあります。すなわちオーバーロードできるんですね。\nこれをもう一歩すすめると、オーバーロードのために名前空間を作りたくなります。 そのための機能が namespace です。 namespace 名前 本体 の構文で使います。\n例えば以下のように書きます。\n例： namespace 文を使ったオーバーロード\nmodule Namespace namespace Int add : Int -\u0026gt; Int -\u0026gt; Int add x y = x + y namespace Double add : Double -\u0026gt; Double -\u0026gt; Double add x y = x + y REPLにロードして少し遊んでみましょう。\nIdris\u0026gt; add 1 2 Can\u0026#39;t disambiguate name: Namespace.Double.add, Namespace.Int.add Idris\u0026gt; add 1.0 2.0 3.0 : Double Idris\u0026gt; Int.add 1 2 3 : Int Idris\u0026gt; Double.add 1 2 3.0 : Double Idris\u0026gt; :t add Namespace.Double.add : Double -\u0026gt; Double -\u0026gt; Double Namespace.Int.add : Int -\u0026gt; Int -\u0026gt; Int Idris\u0026gt; add Can\u0026#39;t disambiguate name: Namespace.Double.add, Namespace.Int.add オーバーロードは型で判別できれば勝手にコンパイラが解決してくれるのですが、 add 1 2 のように Int にも Double にもとれるものだとエラーになります。\nDuplicate Record Fields 名前空間のおかげで複数のレコードでラベルが被っても問題なく使えます。\n例えばラベルがモロ被りなレコード User と Group を定義したとしましょう。\n例\nrecord User where constructor MkUser id : Integer name: String record Group where constructor MkGroup id : Integer name: String これらのアクセサ関数はそれぞれ namespace User と namespace Group に定義されるのでした\nIdris\u0026gt; :browse User Namespaces: Names: id : User -\u0026gt; Integer name : User -\u0026gt; String set_id : Integer -\u0026gt; User -\u0026gt; User set_name : String -\u0026gt; User -\u0026gt; User Idris\u0026gt; :browse Group Namespaces: Names: id : Group -\u0026gt; Integer name : Group -\u0026gt; String set_id : Integer -\u0026gt; Group -\u0026gt; Group set_name : String -\u0026gt; Group -\u0026gt; Group このおかげで id や name はオーバーロードされて、両方が同時に使えます。\nIdris\u0026gt; name (MkUser 1 \u0026#34;user\u0026#34;) \u0026#34;user\u0026#34; : String Idris\u0026gt; name (MkGroup 1 \u0026#34;group\u0026#34;) \u0026#34;group\u0026#34; : String preludeとbase ようやくこのときがやってきました。プレリュードと標準ライブラリについて説明します。\npreludeとはコンパイラに付属してついてくるライブラリのうち、インポート状態のものです。 import 文を書かなくても使えます。\nbaseはコンパイラに付属してついてくるライブラリのうち、インポートしないと使えないものです。\n普通の言語ではプレリュード相当のものは小さいか、クラスなどに小分けにされているんですがIdrisでは結構色々なものがプレリュードに入っています。 baseはデータ型などが入っています。\npreludeとbaseに何が定義されているかは以下から見れます。\n prelude base  これら2つにはお世話になることでしょう。ブックマークしておいて下さい。\nbaseを使ってみる 折角なのでbaseを使ってみましょう。\nData.Comple あたりが手頃ですかね。 BaseExample.idr に以下のコードを書きます。\n例：複素数ライブラリを使ったコード\nmodule Main import Data.Complex main : IO () main = do -- Complexのコンストラクタ :+ let cpx = 3 :+ 2 printLn cpx -- 共役 let cnj = conjugate cpx -- 共役な複素数の積 printLn $ cpx * cnj これをコンパイル/実行するとこうなります。\n例：複素数ライブラリを使ったコードをコンパイル/実行するコマンド\n$ idris -o BaseExample BaseExample.idr $ ./BaseExample 3 :+ 2 13 :+ 0 使えているようですね。\npreludeには今までさんざん使ってきた putStrLnや +、baseには初日で紹介した Vectなどが入っています。\nまとめ Idrisのモジュールとインポート、エクスポート、名前空間、オーバーロード、ライブラリなどを紹介しました。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-15","title":"Idrisのモジュールとプレリュード、標準ライブラリ","url":"https://KeenS.github.io/blog/2020/12/15/idrisnomoju_rutopureryu_do_hyoujunraiburari/"},
  {"body":"このエントリはRust 2 Advent Calendar 2020の10日目の記事です。 前は mocyutoさんでRustでEC2検索を簡単にするCLIの作り方 - Screaming Loud、\n後は mas-yoさんでRustでstaticなEntity Component System - Qiitaでした\n空いてる日を埋める担当のκeenです。 気付いたら空きができてたので埋めます。 Rustのリリースノートなどでよくみる const fn についてです。\nconst文脈 Rustにはグローバルに値に名前をつける手段として const と static がありますね。\nstaticVERSION: u64 =130;constPAGE_SIZE: usize =4096; これらの右辺の値に注目しましょう。 これらはコンパイル時に計算されて、生成されたバイナリの中に埋め込まれます。 となるとこの中に書ける式には制約がつきます。IOなどはできないのはもちろんのこと、ヒープにアクセスするコードも書けません。\nconstVEC: Vec\u0026lt;i32\u0026gt;=vec![1];error[E0010]: allocations are not allowed in constants --\u0026gt; const.rs:1:23 | 1 | const VEC: Vec\u0026lt;i32\u0026gt; = vec![1]; | ^^^^^^^ allocation not allowed in constants | = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info) この制限された static や const の右辺に書くときの文脈を const文脈 と呼びます。 この他には配列初期化構文 [init; size] の size の部分やその型 [Type; Size] の Size 、あとはC-like列挙型の判別子の設定に書ける式もconst文脈で評価されます。\n昔はconst文脈に書ける式の制限がかなり強かったです。具体的にはタプルやデータ型のコンストラクタなどに制限されていました。 これで困るのが一部のデータ型です。例えば static 変数に Vec を持たせようにも、 Vec のフィールドは公開されていないので Vec::new() などの関数を呼ないとなりません。でも関数呼び出しは const 文脈じゃ書けないので八方塞がりです。\nということである程度条件を満たした関数をconst文脈で書けるようにしよう、というのがconst fnです。\nconst fn const fnはRust 1.31.0で導入された機能です。そのときのリリースブログ。\n普通の関数定義に const を前置して const fn name() {} の構文で定義します。\nconst fn はざっくり言うと以下の2つの機能を持ちます。\n const文脈で呼べる（そのときはコンパイル時に評価される） 関数本体で呼べる機能に制約がある  const文脈とは微妙に違う制約   1は分かりやすいですね。const文脈でconst fnを呼べます。例えば Vec::newは const fn なのでconst文脈で呼べます。\nconstVEC: Vec\u0026lt;i32\u0026gt;=Vec::new(); const文脈で呼べる関数は増えるに越したことはないのでconst fnにできそうな関数は順次const fnにされていってます。\nあるいは、const文脈でできることが増えたので昔はハックが必要だったことも簡単にできるようになりました cf: lazy_static はもう古い！？ once_cell を使おう。\n2は、おおむねconst文脈といっしょです。 ですが浮動小数点数の演算ができないなど、いくつか異なる制約があります。\nconstFLT: f64 =1.0+2.0;// OK constfn flt()-\u0026gt; f64 {1.0+2.0// error[E0658]: floating point arithmetic is not allowed in constant functions // --\u0026gt; const.rs:6:5 // | // 6 | 1.0 + 2.0 // | ^^^^^^^^^ // | // = note: see issue #57241 \u0026lt;https://github.com/rust-lang/rust/issues/57241\u0026gt; for more information } まあ、これは細かい話なのでエラーになったらはじめて調べればいいでしょう。\nconst fnでできること const fn に限らずconst文脈でできることも多いですが、意外と表現力があります。 例えば変数の破壊的代入と while ループが書けるのでこういうことも書けます。\n// const文脈 constSUM: i32 ={letv=\u0026amp;[1,2,3];letmuti=0;letlen=v.len();letmutresult=0;whilei\u0026lt;len{result+=v[i];i+=1;}result};// const fn constfn sum(v: \u0026amp;[i32])-\u0026gt; i32 {letmuti=0;letlen=v.len();letmutresult=0;whilei\u0026lt;len{result+=v[i];i+=1;}result} for 式は内部で Iterator::next を呼び出しているのですが、これが const fn でないので使えません。\nあるいは if と再帰呼出もできるので n 番目のフィボナッチ数を求めるコードも簡単に書けます。\nconstfn fib(n: u32)-\u0026gt; u64 {ifn\u0026lt;2{1}else{fib(n-1)+fib(n-2)}} おもしろいですね。\nまとめ const文脈についてと、const文脈で関数を呼べるようになる機能const fnについて紹介しました。\n","categories":["Rust","Rust Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/rust","/categories/rust-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-15","title":"Rustのconst fnって何？","url":"https://KeenS.github.io/blog/2020/12/15/rustnoconst_fnttenani_/"},
  {"body":"このエントリはIdris Advent Calendar 2020の10日目の記事です。\nκeenです。 今回はIdrisで簡単な競技プログラミングの問題を解いてみたいと思います。\n参考にしたのは以下の記事です。\nAtCoder に登録したら次にやること ～ これだけ解けば十分闘える！過去問精選 10 問 ～ - Qiita\n競技プログラミングというのは与えられた問題を解くプログラムをできるだけ速く書くコンテストです。 入力と出力にあまり凝ったものがなく、プログラミングの技法よりもどちらかというと解く方針を考える方に重点が置かれるのが特徴です。 であれば慣れてないプログラミング言語の練習の題材に丁度いいのでここで採り上げることとします。\nAtCoderというのは国内最大手の競技プログラミングのサイトです。\n今回は練習問題として採り上げるだけで特に競技には参加しません（そもそもAtCoderはIdrisでの提出を受け付けていないようです）。 なので競技プログラミング風の速く解く書き方ではなくできる限りIdris風になるような書き方をします。\n第1問 問題 A - Product\n $a$ 、 $b$ の2つの入力が与えられるのでその積が偶数か奇数かを判定して下さい\n制約  $1 ≤ a,b ≤ 10000$ $a,b$ は整数  入力 入力は以下の形式で標準入力から与えられる。\na b\n出力 積が奇数なら Odd と、 偶数なら Even と出力する\n 例えば入力が以下の場合\n3 4 $3 \\times 4 = 12$ は偶数なので出力は以下になります。\nEven コード まず、問題を解く solve という関数を定義しましょう。 そして出入力を担当するコードを書きます。\n結果は Even または Odd なのでそのデータ型を定義しましょう。\ndata Result = Even | Odd これを表示するときは Even または Odd とするのでした。 Show を実装しましょう。\nShow Result where show Even = \u0026#34;Even\u0026#34; show Odd = \u0026#34;Odd\u0026#34; さて、 solve です。 a 、 b を受け取って Even または Odd を返します。\nこう書けるでしょう。\nsolve : Integer -\u0026gt; Integer -\u0026gt; Result solve a b = if a * b `mod` 2 == 0 then Even else Odd これを一旦REPLにロードして動作を確認してみましょう。\nλΠ\u0026gt; solve 3 4 Even : Result λΠ\u0026gt; solve 1 21 Odd : Result λΠ\u0026gt; solve 1000 101 Even : Result よさそうです。それでは出入力を担当するコードを書いてみます。 いくつか新要素が出てきます。\nmain : IO () main = do line \u0026lt;- getLine let [a, b] = words line printLn (solve (cast a) (cast b)) まず main : IO () から line \u0026lt;- getLine まではいいでしょう。今まで出てきました。\nlet [a, b] = words line の行は新要素が3つあります。 1つずつやっていきましょう。\nwords 関数 words は文字列を空白で分解する関数です。\nIdris\u0026gt; :doc words Prelude.Strings.words : String -\u0026gt; List String Splits a string into a list of whitespace separated strings. \u0026gt; words \u0026#34; A B C D E \u0026#34; [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;] The function is: Total \u0026amp; public export Idris\u0026gt; words \u0026#34;1 2 3\u0026#34; [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;] : List String この関数は String -\u0026gt; List String で :search すると2番目に出てきます。\nIdris\u0026gt; :search String -\u0026gt; List String = Prelude.Strings.lines : String -\u0026gt; List String Splits a string into a list of newline separated strings. = Prelude.Strings.words : String -\u0026gt; List String Splits a string into a list of whitespace separated strings. ... do 記法内の let 行 普通の let と同様に変数を束縛します。ただし末尾の in が不要です。\ndo l1 \u0026lt;- getLine l2 \u0026lt;- getLine let twoLines = l1 ++ l2 ... do 記法内ではオフサイドルールが適用されているのでそれに合わせた構文になっているんですね。\nlet でのパターンマッチ let [a, b] = ... の部分です。 パターンマッチできる構文として既に case と関数定義の引数を紹介しました。 それらに let が加わります。\nしかしこの let 、パターンが網羅的ではありません。 words line の結果が [] や [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;] の場合にマッチしません。 マッチしない入力がきた場合はどうなるのでしょうか？答えはIdrisのプログラムが終了します。 ちょっと激しいですが、競技プログラミングでは変な入力がこない想定でプログラムを組めるのでまあ、許容範囲でしょう。 とはいえ安全にプログラムを組めるならそれに越したことはないので次の問題でもう少し安全にプログラムを組める方法も紹介します。\nということで let [a, b] = words line の行で入力の行を空白で分割し、それが2要素であった場合にのみ取り出していることになります。\n最終行は以下のようになっています。\nprintLn (solve (cast a) (cast b)) 文字列から数値に変換するには Cast インタフェースの cast 関数が使えます。\nIdris\u0026gt; the Integer (cast \u0026#34;1\u0026#34;) 1 : Integer Idris\u0026gt; the Integer (cast \u0026#34;-1\u0026#34;) -1 : Integer Idris\u0026gt; the Integer (cast \u0026#34;hoge\u0026#34;) 0 : Integer これも :search String -\u0026gt; Integer すると出てきます。\nprintLn: Show ty =\u0026gt; ty -\u0026gt; IO () は Show を実装した値を出力できます。\n全体の解説が終わったのでプログラムをコンパイル・実行してみましょう。\n$ idris -o Product Product.idr $ ./Product 1 2 Even $ ./Product 3 4 Even $ ./Product 1 21 Odd 正しく動作しているようです。\n正しくない入力を与えたらどうなるか見てみましょう。\n$ ./Product 1 *** Product.idr:17:16-25:unmatched case in Main.case block in main at Product.idr:17:16-25 *** $ ./Product 1 2 3 *** Product.idr:17:16-25:unmatched case in Main.case block in main at Product.idr:17:16-25 *** 見事にクラッシュしていますね。 次の問題ではもう少しまともにします。\n第2問 問題 A - Placing Marbles\n 1、2、3の番号のついたマス目があります。各マスには 0 か 1 が書かれています。 マス $i$ には $s_i$ が書かれています。 1 が書かれたマスにビー玉を起きます。ビー玉が置かれるマスがいくつあるか求めて下さい。\n制約 $s1,s2,s3$ は 1 あるいは 0\n入力 入力は以下の形式で標準入力から与えられる。\ns1s2s3\n出力 答えを出力する\n 例えば入力が以下の場合\n101 1が2つあるので出力は2です。\n2 コード まずは solve を書きましょう。 $s_1$ 、 $s_2$ 、 $s_3$ と3つの数値を引数で取ってもいいんですが、せっかく $s_i$ と一般化してくれているのでリストで引数をとることにしましょう。 また、各マス目に書かれているものが何なのか難しいですがここでは文字 Char ということにしておきます。\nすると solve は文字のリストを受け取って、 1 が含まれている数をカウントする関数ということになります。\nsolve: List Char -\u0026gt; Integer solve ss = cast (length (filter (== \u0026#39;1\u0026#39;) ss)) filter : (a -\u0026gt; Bool) -\u0026gt; List a -\u0026gt; List a は引数の関数の条件にマッチする要素だけ集めてくる関数です。\n(== '1') 、あるいは度々出てきている (演算子 引数) や (引数 演算子) はセクションという機能です。 演算子に引数を部分適用します。(+1) は何度か出てきましたね。\nIdris\u0026gt; :t (+ 1) \\ARG =\u0026gt; ARG + 1 : Integer -\u0026gt; Integer Idris\u0026gt; :t (== \u0026#39;1\u0026#39;) \\ARG =\u0026gt; ARG == \u0026#39;1\u0026#39; : Char -\u0026gt; Bool ということで (== '1') は 「引数が '1' なら True を返しそれ以外なら False を返す関数」ということになります。 紹介してませんでしたがIdrisの文字リテラルは '文字' です。\nlength のあとに cast がついているのは length の返り値が Nat だからです。\nIdris\u0026gt; :t length Prelude.List.length : List a -\u0026gt; Nat ところで、今回の solve は括弧が多いですね。 括弧を減らせる便利演算子 $ を紹介しておきます。 func $ arg は func arg と同じ意味なのですが、 $ の優先順位が低いので事実上 $ から式の末尾までの括弧のように振舞います。 例えば先程の solve は以下のように書き換えられます。\nsolve: List Char -\u0026gt; Integer solve ss = cast $ length $ filter (== \u0026#39;1\u0026#39;) ss 出入力の部分は以下です。\nmain : IO () main = do line \u0026lt;- getLine let ss = unpack line printLn $ solve ss 今回はパターンマッチは出てきませんでしたね。\nunpack: String -\u0026gt; List Char は文字列を1文字ずつに分解する関数です。\nIdris\u0026gt; unpack \u0026#34;101\u0026#34; [\u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;] : List Char それではこのプログラムをコンパイル・実行してみましょう。\n$ idris -o PlacingMarbles PlacingMarbles.idr $ ./PlacingMarbles 101 2 $ ./PlacingMarbles 000 0 動いているようです。\n第3問 問題 B - Shift only\n $A_1$ から $A_N$ までの $N$ 個の整数があります。 これらの整数が全て偶数であるとき、次の操作を行うことができます\n 全ての整数を2で割ったものに置き換える  この操作は最大で何回行うことができるか求めて下さい。\n制約  $ 1 \\le N \\le 200$ $ 1 \\le A_i \\le 10^9$  入力 入力は以下の形式で標準入力から与えられる\n$N$\n$A_1$ $A_2$ \u0026hellip; $A_n$\n出力 最大で何回操作を行うことができるかを出力せよ\n 例えば以下の入力が与えられたとき\n3 8 12 40 結果は以下です。\n2 コード 各整数の素因数に2が何個含まれるか数えて、その最小値を答えればよいですね。\n素因数に2が何個含まれるかはビット操作に強い言語ならCTZ（count trailing zeros）で一発で出せたりするんですが、Idrisにはないのでまずは素因数に2が何個含まれるか数える関数を作るところからはじめましょう。\nisEven: Integer -\u0026gt; Bool isEven n = n `mod` 2 == 0 countTwos : Integer -\u0026gt; Nat countTwos n = if isEven n then 1 + (countTwos (n `div` 2)) else 0 n が偶数であれば n / 2 の素因数に含まれる2の数を数えて、それに1を足してあげればよいです。\nこれを使って solve は以下のように書けます。\nsolve: List Integer -\u0026gt; Integer solve l = cast $ foldl min 100 $ map countTwos l 最初の方針通り map countTwos l で各数値の素因数の中にある2の数を数えます。 そこから最小値を取り出すのに foldl min 100 を使っています。ちょっとこれは解説をしましょう。\nfoldl は「畳み込み」をする演算子です。 二項演算子と演算の最初の値、そしてリストを引数にとり、畳み込んだ結果を返します。 例えば [1, 2, 3] があったときに foldl (+) 0 [1, 2, 3] は以下の計算をします。\n(((0 + 1) + 2) + 3) その結果6を返します。\nIdris\u0026gt; foldl (+) 0 [1, 2, 3] 6 : Integer ここで初期値に 0 を使っているのは 0 が + の単位元、すなわち $n + 0 = 0 + n = n$ を満たす値だからです。\n同様のことを min で行ったのが solve です。 foldl min 100 [1, 2, 3] は (((100 `min` 1) `min` 2) `min` 3) を計算するので結果1が返ります。\nIdris\u0026gt; foldl min 100 [1, 2, 3] 1 : Integer ここででてきた100というのが妥協の産物です。 本来なら min の単位元を使いたいところですが、今回の対象である Nat には min の単位元が存在しません。 min の単位元はその型の値の最大値ですが、 Nat には最大値がないからです。 なので単位元は使えません。 そこで妥協案として「今回のどの入力よりも大きい値」を据えることにします。 今回の入力の $A_i$ の最大値は $10^9$ なので素因数に含まれる2の個数はせいぜい30個程度です。ということでどんなに大きめにみても100は越えないので100を据えました。\n因みにですが foldl は Foldable インタフェースに定義されていて、 List での foldl の定義は以下です。\n-- foldl : ( acc -\u0026gt; elem -\u0026gt; acc) -\u0026gt; acc -\u0026gt; List elem -\u0026gt; acc foldl f q [] = q foldl f q (x::xs) = foldl f (f q x) xs さてさて、 solve が定義できたので一旦REPLで試してみましょう。\nλΠ\u0026gt; solve [8, 12, 40] 2 : Integer λΠ\u0026gt; solve [5, 6, 8, 10] 0 : Integer λΠ\u0026gt; solve [382253568, 723152896, 37802240, 379425024, 404894720, 471526144] 8 : Integer 動いていますね。\nそれでは入力を受け取る部分を書きます。\nmain : IO () main = do _ \u0026lt;- getLine line \u0026lt;- getLine let input = map cast $ words line printLn $ solve input 最初に入力の個数を教えてくれていますが、 個数に関係なく words でバラしてしまうので無視してしまいます。\nそれではこれをコンパイル・実行してみましょう。\n$ ./ShiftOnly 3 8 12 40 2 $ ./ShiftOnly 4 5 6 8 10 0 $ ./ShiftOnly 6 382253568 723152896 37802240 379425024 404894720 471526144 8 動いていますね。\nここまで解いたら 最初は10問全部やろうとしたのですが、疲れたのでこれでラストにします。 ラストは高橋君の出てくる問題です。\n問題 B - Trained?\n 筋力をつけたい高橋君は、AtCoder 社のトレーニング設備で、トレーニングをすることにしました。\nAtCoder 社のトレーニング設備には $N$ 個のボタンがついており、ちょうど $1$ 個のボタンが光っています。 ボタンには、$1$ から $N$ までの番号がついています。 ボタン $i$ が光っているときにそのボタンを押すと、ボタン $i$ の明かりが消え、その後ボタン $ai$ が光ります。 $i=ai$ であることもあります。 光っていないボタンを押しても、何も起こりません。\n最初、ボタン $1$が光っています。高橋君は、ボタン $2$ が光っている状態で、トレーニングをやめたいと思っています。\nそのようなことは可能かどうか判定し、もし可能なら最低で何回ボタンを押す必要があるかを求めてください。\n制約  $2 \\le N \\le 10^5$ $1 \\le a_i \\le N$  入力 入力は以下の形式で標準入力から与えられる。\n$N$\n$a_1$\n$a_2$\n$:$\n$a_N$\n出力 ボタン2を光らせることが不可能な場合は -1を出力せよ。 そうでない場合はボタン2を光らせるために必要なボタンを置く回数の最小値を出力せよ。\n コード 困りましたね…。 高橋君のいる問題を選んだらまだ説明してない機能が必要になりました。 本来は集合とキーバリューマップが必要になる問題なのですが、それを使うにはモジュールや標準ライブラリ、パッケージ、コンパイラオプションなどの説明が必要になります。 ここでは非効率を承知の上で集合とキーバリューマップをリストで代用します。\nさて、問題ですが、解けますよね？ $1$ を押したら $a_i$ が点灯し、 $a_i$ を押したら $a_j$ が点灯し…を繰り返していくとどこかで今まで押した番号に合流し、操作がループします。 今回の問題はループに突入する前に $2$ を引いたらそれまでの操作回数を、ループに突入したら $-1$ を返せばよさそうです。\nまず集合とキーバリューマップの代用品を作ります。\n集合は empty と insert と contains があれば十分です。\n-- Set Set : Type -\u0026gt; Type Set = List empty : Set a empty = [] insert : Eq a =\u0026gt; a -\u0026gt; Set a -\u0026gt; Set a insert a s = a :: s contains : Eq a =\u0026gt; a -\u0026gt; Set a -\u0026gt; Bool contains a s = elem a s Idrisは純粋関数型言語なので値が変更されることはありません。 なので empty は関数ではなく値です。 同じく insert は値を追加した新しい集合を返します。 使っている関数については、見てとれるかと思いますが、 elm は a が s に含まれるか検査する関数です。\nキーバリューマップは fromList と lookup があれば十分です。\n-- Map Map : Type -\u0026gt; Type -\u0026gt; Type Map k v = List (k, v) fromList : List (k, v) -\u0026gt; Map k v fromList l = l lookup : Eq k =\u0026gt; k -\u0026gt; Map k v -\u0026gt; Maybe v -- ... List (k, v) に対する lookup はプレリュードに既に定義されているので特に定義しなくてもよいです（というか定義すると多重定義で怒られます）。\nでは solve を定義していきましょう。 まずは List a から List (Integer, a) を作る indexed 関数です。\nindexed : List a -\u0026gt; List (Integer, a) indexed l = loop l 1 where loop : List a -\u0026gt; Integer -\u0026gt; List (Integer, a) loop [] _ = [] loop (x::xs) i = (i, x) :: loop xs (i + 1) Idrisではループは再帰関数で表わすのでした。 ループで持ち回る値（ここではインデックス）は引数で渡します。 indexed に無駄な引数を増やす訳にはいかないのでローカル関数を定義して、そこでループを回します。\nsolve も indexed と同じようにループをするローカル関数を定義して、そちらで実行します。\nsolve : List Integer -\u0026gt; Integer solve l = let map = fromList $ indexed l in let set = empty in case loop map set 1 0 of Just i =\u0026gt; i Nothing =\u0026gt; -1 where loop : Map Integer Integer -\u0026gt; Set Integer -\u0026gt; Integer -\u0026gt; Integer -\u0026gt; Maybe Integer -- ... ループで持ち回る値は以下です。\n map : $i$ 番目のボタンを押したら $a_i$ 番目のボタンが光るという対応関係 set : 今までに押したことのあるボタン cur : 現在光っているボタン count : ボタンを押した回数  map は入力から最初に作ってしまって以後特に増減しません。\nlet map = fromList $ indexed l in set は初期値は空集合です。\nlet set = empty in cur は問題文にあるとおり1が、ボタンを押した回数は最初は0です。\nloop map set 1 0 それでは loop の実装を見ていきましょう\nwhere loop : Map Integer Integer -\u0026gt; Set Integer -\u0026gt; Integer -\u0026gt; Integer -\u0026gt; Maybe Integer loop _ _ 2 count = Just count loop map set cur count = let set = insert cur set in let Just next = lookup cur map | _ =\u0026gt; Nothing in if contains next set then Nothing else loop map set next (count + 1) まず、現在光っているボタンが2なら今までにボタンを押した回数を返して終了です。\nloop _ _ 2 count = Just count それ以外の場合はボタンを押します。\nloop map set cur count = -- ... 押したボタンを記録しましょう。\nlet set = insert cur set in すると次のボタンが光るはずです。それを next とします。\nlet Just next = lookup cur map | _ =\u0026gt; Nothing in ここで、ようやく let とパターンマッチが出てきました。let パターン = 式 | 他の場合 =\u0026gt; 式 in の構文です。 パターンマッチで lookup の結果が Just の場合のみ変数を束縛しています。 では Nothing の場合はどうなるかというと、 | _ =\u0026gt; Nothing の方にいきます。 Nothing は _ パターンにマッチし、腕の Nothing が返ります。\n全体として、上記の式は以下のように読み替えられます。\ncase lookup cur map of Just next =\u0026gt; .... _ =\u0026gt; Nothing パターンにマッチしなかったら強制終了するよりずっと安全に想定していないケースを扱うことができました。\nさて、プログラムの続きをみていきましょう。 もし次に光ったランプが今までに光ったことのあるランプだったらループに突入するので Nothing です。それ以外の場合は次のボタンを調べるため、ループを回します。\nif contains next set then Nothing else loop map set next (count + 1) ボタンを押したら同じボタンが光ることもあると書いてあったので、その辺の処理にも気を配りましょう。今回は先に insert cur set しているので大丈夫です。\n最終的に、2に到達すればそのときの操作数を、到達できなければ-1を返します。\ncase loop map set 1 0 of Just i =\u0026gt; i Nothing =\u0026gt; -1 REPLで動作を確認してみましょう。\nλΠ\u0026gt; solve [3, 1, 2] 2 : Integer λΠ\u0026gt; solve [3, 4, 1, 2] -1 : Integer λΠ\u0026gt; solve [3, 3, 4, 2, 4] 3 : Integer 正しく動いていそうです。\nそれでは入力を受け取る部分を書きます。\nmain : IO () main = do n \u0026lt;- getLine l \u0026lt;- getNIntegers (cast n) printLn $ solve l where getNIntegers : Nat -\u0026gt; IO (List Integer) getNIntegers Z = pure [] getNIntegers (S n) = do i \u0026lt;- getLine is \u0026lt;- getNIntegers n pure $ (cast i) :: is 今回は N を使います。 N で受け取った数の分だけ getLine してその数値をリストに入れます。 そのためにローカル関数 getNIntegers を定義しています。\ngetNIntegers は自然数を受け取って IO (List Integer) を返します。\ngetNIntegers : Nat -\u0026gt; IO (List Integer) Nat は Z | S Nat で定義されているのでした。パターンマッチもそれを使います。\nZ の場合は 0 要素のリストを返します。 IO モナドに入れるために pure を使っています。\ngetNIntegers Z = pure [] Z でない場合は S n にマッチします。\ngetNIntegers (S n) = do S n でマッチしているので getNIntegers 10 と呼ばれたら n には 9 が入っていることに注意して下さい。\nまずは1行読み込みます。\ni \u0026lt;- getLine 残り n 個の自然数を読めばいいので再帰呼び出しします。\nis \u0026lt;- getNIntegers n あとは結合して返すだけです。\npure $ (cast i) :: is こちらも IO モナドに入れるために pure を使っています。\nそれではプログラムが完成したのでコンパイル・実行してみましょう。\n$ idris -o Trained Trained.idr $ ./Trained 3 3 1 2 2 $ ./Trained 4 3 4 1 2 -1 $ ./Trained 5 3 3 4 2 4 3 正しく動いているようです。\nまとめ リストや文字列、IOの操作の練習に競技プログラミングの問題を解いていみました。 ある程度は練習になったものの、ライブラリがないと足りない機能があることも分かりました。\n次は標準ライブラリやモジュールを紹介できたらなと思います。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-10","title":"Idrisと高橋君","url":"https://KeenS.github.io/blog/2020/12/10/idristotakahashikun/"},
  {"body":"このエントリはIdris Advent Calendar 2020の9日目の記事です。\nκeenです。Idrisのインタフェースやモナドについて紹介します。\nインタフェース 色々な言語にあるやつとだいたい一緒です。 厳密にいうとアドホックポリモーフィズムのための機構なのでHaskellの型クラスやRustのトレイトに例えた方がいいのですが、細かい話は置いておきましょう。\ninterface インタフェース名 型変数 where 本体 の構文で書きます。 本体の部分には値の型や実装などを書きます。値とは関数も含みます。 例えば任意の型の値を文字列にするインタフェース Show の定義は以下のように書けます。\n例：インタフェース Show の定義\ninterface Show a where show : a -\u0026gt; String a が Show を実装する型を表します。 そして show には実装がありません。型だけ示しているのでインタフェースっぽいですね。 因みに、 Show はプレリュードに定義されているので自分で書かなくても使えます。\nこれを実装するには インタフェース名 型名 where 本体 の構文を使います。\n例： Name 型にインタフェース Show を実装するコード\nrecord Name where constructor MkName firstName, lastName: String Show Name where show (MkName firstName lastName) = firstName ++ \u0026#34; \u0026#34; ++ lastName 実装の方には逆に型の宣言がありません。\n実装した Show は普通の関数のように呼び出すだけで使えます。\nIdris\u0026gt; show (MkName \u0026#34;Edwin\u0026#34; \u0026#34;Brady\u0026#34;) \u0026#34;Edwin Brady\u0026#34; : String デフォルト実装 先ほどインタフェースの本体には関数の型や 実装 を書くと説明しました。 インタフェースに実装を持つこともできるんですね。\n例えば等価比較を行なうためのインタフェース Eq はデフォルト実装を持ちます。\n例：インタフェース Eq の定義\ninterface Eq a where (==) : a -\u0026gt; a -\u0026gt; Bool (/=) : a -\u0026gt; a -\u0026gt; Bool x /= y = not (x == y) x == y = not (x /= y) 等しい（ == ）は等しくない（ /= ）の逆だしその逆もまた然りという定義ですね。 どちらか一方だけ実装すればもう一方は自動でついてくる仕組みです。\n関連型 Idrisでは特に特別なものではないんですが、HaskellやRustで関連型（associated type）と呼ばれているものも書けます。\n例えばとある別の型からその型の値を取得できる Extract というインタフェースを考えてみましょう。それは以下のように定義できます。\n例：インタフェース Extract の定義\ninterface Extract a where From: Type extract: From -\u0026gt; a この From が関連型です。 Idrisでは型も値なので関数や値のように普通にメンバーに書けばそれで済みます。\n上記の型を Name に実装してみましょう。 まず準備として Name を保持する型 Person を定義しておきます。\n例：Person 型の定義\nrecord Person where constructor MkPerson age: Int name: Name すると Person から Name を extract できるので、以下のように Extract を name に実装できます。\n例：Extract を Name に実装するコード\nExtract Name where From = Person extract = name 多パラメータのインタフェース インタフェースの型パラメータは複数書くことができます。 例えばある型から別の型に変換するインタフェース Cast は以下のように定義されています。\n例：プレリュードでのインタフェース Cast の定義\ninterface Cast from to where cast : (orig : from) -\u0026gt; to from と to の2つのパラメータがありますね。 実装するときも2つのパラメータを指定します。\n例： Cast を Double と Int に定義するときの書き出し\nCast Double Int where -- ... Cast のパラメータに Double と Int を指定しています。 cast の実装はプリミティブの呼び出しになるので省略しました。\nインタフェースを実装できる条件 インタフェースの実装は1つの型につき1つしか持てません 1。また関数はインタフェースを実装できません。\n例えば Name に対してもう1つの Show のインタンスを追加しようとするとコンパイルエラーになります。\n例：2つ目の Show インタフェースを Name に実装しようとした際に出るエラー\n- + Errors (1) `-- (no file) line 0 col -1: interface.idr:21:1-9:Main.Name implementation of Prelude.Show.Show already defined 逆に、意外と実装できるケースにプリミティブを含む既存の型にインタフェースを実装できるというものが挙げられます。\n以下にその例を示します。\n例：インタフェース Zero を定義し、それをプリミティブ Int に実装するコード\ninterface Zero a where zero : a Zero Int where zero = 0 プリミティブである Int に対してインタフェースを実装できました。\nジェネリクスとインタフェース ジェネリクスで扱う型に特定のインタフェースを実装していることを要求したい場合があります。\nジェネリクス関数へのインタフェース制約 例えば引数を2つ受け取って、その小さい方、大きい方の順で並べて返す関数を定義したいとします。そのときに \u0026lt; で比較する必要がありますよね。 今までの知識で関数を定義すると \u0026lt; が実装されていないのでコンパイルエラーになります\n例： a 同士を比較できないためエラーになるコード例\nordered: a -\u0026gt; a -\u0026gt; (a, a) ordered a b = if a \u0026lt; b then (a, b) else (b, a)- + Errors (1) `-- interface.idr line 35 col 2: When checking right hand side of ordered with expected type (a, a) When checking argument b to function Prelude.Bool.ifThenElse: Can\u0026#39;t find implementation for Ord a そういうときは特定のインタフェースを実装している型のみ受け付ける制約を書きます。インタフェース名 変数名 =\u0026gt; 型 の構文です。\u0026lt; 演算子は Ord インタフェースで定義されているため、上記の ordered を修正すると以下のようになります。\nordered: Ord a =\u0026gt; a -\u0026gt; a -\u0026gt; (a, a) ordered a b = if a \u0026lt; b then (a, b) else (b, a) また、複数の制約を書きたい場合は (インタフェース名 変数名, インタフェース名 変数名, ....) =\u0026gt; 型 と丸括弧で括ってカンマで区切って書きます。\n例：ジェネリクスの型変数に複数のインタフェース制約を書いたコード\norderedMsg: (Ord a, Show a) =\u0026gt; a -\u0026gt; a -\u0026gt; String orderedMsg a b = let (a, b) = ordered a b in (show a) ++ \u0026#34; \u0026lt; \u0026#34; ++ (show b) インタフェース実装へのインタフェース制約 インタフェース自身にも関数を含みますからインタフェースの実装にインタフェース制約を加えたいというのも自然な要求です。実際、そういう機能があります。 インタフェース制約 =\u0026gt; インタフェース名 型名 where 本体 の構文です。 以下に例を示します。\n例：プレリュードのタプルへの Eq の実装例\n(Eq a, Eq b) =\u0026gt; Eq (a, b) where (==) (a, c) (b, d) = (a == b) \u0026amp;\u0026amp; (c == d) 余談ですが、Idrisの3つ組以上のタプルは2つ組の組み合わせの糖衣構文となっています。例えば (A, B, C) は (A, (B, C)) です。 なので上記の2つ組のタプルの実装で全てのタプルの実装をカバーできるのです。\nインタフェースの拡張 インタフェース制約をインタフェースの宣言に書くこともできます。 これは事実上既存のインタフェースを拡張した新しいインタフェースを定義していると捉えることもできますね。 interface インタフェース制約 =\u0026gt; インタフェース名 型変数 where 本体 の構文になります。\n例えばプレリュードの Neg は Num を拡張したインタフェースです。\n例：プレリュードの Num と Neg のコード\n||| The Num interface defines basic numerical arithmetic. interface Num ty where (+) : ty -\u0026gt; ty -\u0026gt; ty (*) : ty -\u0026gt; ty -\u0026gt; ty ||| Conversion from Integer. fromInteger : Integer -\u0026gt; ty ||| The `Neg` interface defines operations on numbers which can be negative. interface Num ty =\u0026gt; Neg ty where ||| The underlying of unary minus. `-5` desugars to `negate (fromInteger 5)`. negate : ty -\u0026gt; ty (-) : ty -\u0026gt; ty -\u0026gt; ty 高カインド多相とファンクタ 少し難しめの機能に入ります。 特に複雑という訳ではないんですが、抽象度が高いので慣れてないと理解に時間のかかる機能です。\nList a や Maybe a のようにジェネリクスなデータ型がありますね？ これに対してインタフェースを定義したいとします。 例えば map なんかは分かりやすいでしょう。\n例： List a と Maybe a に対する素朴な map の実装\n-- List map : (a -\u0026gt; b) -\u0026gt; List a -\u0026gt; List b map f [] = [] map f (x::xs) = f x :: map f xs -- Maybe map : (a -\u0026gt; b) -\u0026gt; Maybe a -\u0026gt; Maybe b map f (Just x) = Just (f x) map f Nothing = Nothing これを抽象化するインタフェースを定義します。 するとパラメータになるのは List や Maybe の部分です。 これらは型コンストラクタ、Idris的にいうと Type -\u0026gt; Type の値です。\nIdris\u0026gt; :t List List : Type -\u0026gt; Type Idris\u0026gt; :t Maybe Maybe : Type -\u0026gt; Type 従来の型変数（Idris的にいうと Type の値）とは異なるのでインタフェースの定義に少し手を加えます。具体的には型変数が Type ではなく Type -\u0026gt; Type であることを表わすために型注釈を加えます。構文は interface インタフェース名 (変数名: Type -\u0026gt; Type) where 本体 です。\n例： プレリュードのインタフェース Functor の定義\ninterface Functor (f : Type -\u0026gt; Type) where map : (func : a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b Functor （関手）は List や Maybe などのように「map できる型」を抽象化する型です。f の部分に List や Maybe などが当て嵌ります。\nFunctor インタフェースのおかげでこのように List や Maybe の値に対して1を足す関数を適用できます。\nIdris\u0026gt; map (1+) (Just 1) Just 2 : Maybe Integer Idris\u0026gt; map (1+) [1, 2, 3] [2, 3, 4] : List Integer このように Type ではなく Type -\u0026gt; Type などの複雑な「型の型」を持つものに対するジェネリクスを高カインド多相と呼びます（「型の型」はカインド（kind）と呼ばれています）。\n因みに map の代わりに \u0026lt;$\u0026gt; という演算子も使えます。\ninfixr 4 \u0026lt;$\u0026gt; (\u0026lt;$\u0026gt;) : Functor f =\u0026gt; (func : a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b func \u0026lt;$\u0026gt; x = map func xIdris\u0026gt; (1+) \u0026lt;$\u0026gt; (Just 1) Just 2 : Maybe Integer Idris\u0026gt; (1+) \u0026lt;$\u0026gt; [1, 2, 3] [2, 3, 4] : List Integer 後述するApplicativeと組み合わせるときに便利です。\n余談ですがHaskellだとリスト専用の map と Functor で定義される fmap で分かれています。恐らくですが先にリストの map を作ったあとに Functor という抽象化に気付いたので要らぬ複雑性が入ってるんじゃないかと思います。その点IdrisはHaskellの後発なのもあってシンプルですね。\n多引数関数とApplicative map は便利ですが、痒いところに手が届かないことがあります。 多引数関数には使いづらいのです。\n例えば2引数関数 (+) を Just 1 と Just 2 に適用したいとしましょう。 そこで素朴に map で適用しようとするとエラーになります。\n例： map を使って素朴に (+) を Just 1 と Just 2 に適用した式\nIdris\u0026gt; map (+) (Just 1) (Just 2) (input):1:1-25:When checking an application of function Prelude.Functor.map: Type mismatch between Maybe a1 (Type of Just x) and (\\uv =\u0026gt; _ -\u0026gt; uv) a (Expected type) Specifically: Type mismatch between Maybe and \\uv =\u0026gt; _ -\u0026gt; uv これは落ち着いて型を考えるとエラーになる理由が分かります。 map の型は (a -\u0026gt; b) -\u0026gt; Maybe a -\u0026gt; Maybe b です。 (+) の型は Integer -\u0026gt; Integer -\u0026gt; Integer で、これは Integer -\u0026gt; (Integer -\u0026gt; Integer) です。 これらを組み合わせると、 map (+) は Maybe Integer -\u0026gt; Maybe (Integer -\u0026gt; Integer) になります。これを Just 1 に適用すると Maybe (Integer -\u0026gt; Integer) になります。 ここで関数ではなくて Maybe 型の値が出てきてしまいました。これでは Just 2 に適用できません。\nしかしながらみなさんは無理矢理適用させる実装を思い付くんじゃないでしょうか。 以下のようにパターンマッチで取り出してしまえばいいのです。\n例： Maybe に包まれた関数を無理矢理適用してしまうコード\nap: Maybe (a -\u0026gt; b) -\u0026gt; Maybe a -\u0026gt; Maybe b ap (Just f) (Just x) = Just (f x) ap _ _ = Nothing 実現できそうなのでインタフェースで抽象化しましょう。 Functor を拡張したインタフェースにするのが具合がよさそうです。 これはプレリュードで Applicative と呼ばれています。\n例：プレリュードの Applicative の定義\ninfixl 3 \u0026lt;*\u0026gt; interface Functor f =\u0026gt; Applicative (f : Type -\u0026gt; Type) where pure : a -\u0026gt; f a (\u0026lt;*\u0026gt;) : f (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b ap ではなく \u0026lt;*\u0026gt; という演算子になっていますが、やってることは先程定義した ap と同じものです。 これに対する Maybe の実装は以下のようになっています。\n例：プレリュードの Applicative の Maybe への実装\nApplicative Maybe where pure = Just (Just f) \u0026lt;*\u0026gt; (Just a) = Just (f a) _ \u0026lt;*\u0026gt; _ = Nothing ちゃんと \u0026lt;*\u0026gt; の実装が ap と同じものになっていますね。\nmap を \u0026lt;$\u0026gt; と書けることと組み合わせて、以下のように使えます。\n例： Functor と Applicative の利用\nIdris\u0026gt; (+) \u0026lt;$\u0026gt; (Just 1) \u0026lt;*\u0026gt; (Just 2) Just 3 : Maybe Integer 因みにインタフェースであるからには複数の型（型コンストラクタ）に実装されている訳です。例えば List での実装がどうなっているかというと、全ての要素に対して繰り返すようになっています。\n例： List での Functor と Applicative の利用\nIdris\u0026gt; (+) \u0026lt;$\u0026gt; [1, 2, 3] \u0026lt;*\u0026gt; [10, 11, 12] [11, 12, 13, 12, 13, 14, 13, 14, 15] : List Integer ところで Applicative に pure というのがいますね。 これの役割に触れておきましょう。 func を x に適用するとします。 func と x の型がそれぞれ Maybe （一般化して f）に包まれている/いないで4つの組み合わせがありますね？それぞれどう適用するか見てみましょう。\n   関数 引数 適用     a -\u0026gt; b a func x   a -\u0026gt; b f a map func x   f (a -\u0026gt; b) a ????   f (a -\u0026gt; b) f a func \u0026lt;*\u0026gt; x    f (a -\u0026gt; b) を a に適用する場合だけまだ出てきてませんね。 この隙間を pure が埋めてくれます。 func \u0026lt;*\u0026gt; (pure x) と書けばいいのです。\n余談ですがFunctor を使った map func x も (pure func) \u0026lt;*\u0026gt; x と Applicative の機能だけで書くことができますね。そういった意味で Applicative は Functor の拡張になっています。\nプログラムとモナド Applicative で Maybe などのジェネリクス型に包まれているデータや関数に対して操作できるようになりました。では新しく包む操作についてはどうでしょう。\n例えば割る数が0以外では割った商を、0では Nothing を返す safeDiv を考えます。\n例：safeDiv 関数\nsafeDiv : Integer -\u0026gt; Integer -\u0026gt; Maybe Integer safeDiv _ 0 = Nothing safeDiv d m = d `div` m これを \u0026lt;$\u0026gt; と \u0026lt;*\u0026gt; で組み合わせることもできますが、結果はあまり嬉しくありません。\n例：safeDiv を Functor と Applicative と一緒に使った例\nIdris\u0026gt; safeDiv \u0026lt;$\u0026gt; (Just 1) \u0026lt;*\u0026gt; (Just 0) Just Nothing : Maybe (Maybe Integer) 返り型が Maybe (Maybe Integer) と Maybe が二重に出てきてしまいました。そして返り値も Just Nothing になってしまっています。これは数値が返ってきていないという意味では Nothing と変わりません。Maybe Integer に「潰せ」たらうれしいですよね。\nそういう操作は一般に、flatten、あるいはjoinと呼ばれますね。 さらにflattenの派生型であると嬉しいのがflatMapです。Idrisの型で書くと Maybe a -\u0026gt; (a -\u0026gt; Maybe b) -\u0026gt; Maybe b です。flattenとflatMapは片方があればもう片方を定義できるので双子のような存在です。\nそんなjoinとflatMapをインタフェースにしたのがモナドです。\n例：プレリュードでの Monad の定義\ninfixl 1 \u0026gt;\u0026gt;= interface Applicative m =\u0026gt; Monad (m : Type -\u0026gt; Type) where ||| Also called `bind`. (\u0026gt;\u0026gt;=) : m a -\u0026gt; ((result : a) -\u0026gt; m b) -\u0026gt; m b ||| Also called `flatten` or mu join : m (m a) -\u0026gt; m a -- default implementations (\u0026gt;\u0026gt;=) x f = join (f \u0026lt;$\u0026gt; x) join x = x \u0026gt;\u0026gt;= id この Monad を使えば先程の safeDiv は Maybe Integer を返すように使えるようになります。\nIdris\u0026gt; join (safeDiv \u0026lt;$\u0026gt; (Just 1) \u0026lt;*\u0026gt; (Just 0)) Nothing : Maybe Integer Idris\u0026gt; Just 1 \u0026gt;\u0026gt;= \\d =\u0026gt; (Just 0 \u0026gt;\u0026gt;= \\m =\u0026gt; safeDiv d m) Nothing : Maybe Integer do 記法 先程の例、 Just 1 \u0026gt;\u0026gt;= \\d =\u0026gt; (Just 0 \u0026gt;\u0026gt;= \\m =\u0026gt; safeDiv d m) は見づらいですよね。演算子や無名関数が乱舞してどこに何が書いてあるのか分かりません。そこでこれを書きやすくする do 記法というのがあります。\n先程のコードを do 記法で書き直すと以下のようになります。\n例\ndo d \u0026lt;- Just 1 m \u0026lt;- Just 0 safeDiv d m これだとぐっと見やすくなりますね。\nところで基本文法のところで触れ忘れたんですが、オフサイドルールには別の記法もあります。{記述1; 記述2; ...} と {} で包んでそれぞれの記述を ; で分けます。こうすることで1行でも書けるようになります。 REPLなどでは1行で書きたいケースもあると思うのでお試し下さい。\n例： do 記法をREPLで使うコード\nIdris\u0026gt; do {d \u0026lt;- Just 1; m \u0026lt;- Just 0; safeDiv d m } Nothing : Maybe Integer モナドを使うときは大抵 do 記法を使うことになるでしょう。\nMonad もまたインタフェースなので Maybe 以外の型も実装を持ちます。例えば List はその要素について繰り返します。 リスト内包表記のようなことを do 記法でもできるのです。\n例：九九の左斜め下半分を do 記法で計算するコード\ndo x \u0026lt;- [0..9] y \u0026lt;- [0..x] pure (x * y) モナドはDSL? Functor 、 Applicative 、 Monad で何かに包まれた値を計算できるようになりました。では、包まれた値から取り出すにはどうしたらいいでしょう。 残念ながらいい方法はありません。 Nothing なんかは値がないから Nothing な訳で、そこから値を取り出せません。\n逆に言うとモナドにすることで操作を「閉じ込めて」しまうことができます。 使える操作は Functor と Applicative で「持ち上げた」操作と、 Monad で「結合」できる a -\u0026gt; m b の型の関数のみです。\nそういった意味でモナドはDSLと捉えることができます。 ライブラリなんかでもモナドを提供し、主な操作は do 記法でやるものが多くあります。\nIOモナド いままで、まともにHollo Worldを解説してませんでしたね。 それはIO操作もモナドで書かれているからです。\nということでモナドを知った今、改めてHello Worldをしてみましょう。 putStrLn は以下のような型をしています。\nIdris\u0026gt; :t putStrLn putStrLn : String -\u0026gt; IO () そしてIdrisは main : IO () な値からプログラムの実行を始めます。 なのでHello Worldは以下のように書きます。\n例：IdrisでのHello World\nmain : IO () main = putStrLn \u0026#34;Hello, World\u0026#34; これを Hello.idr として保存し、以下のように実行します。\n例：Hello Worldをコンパイル・実行するコマンド\n$ idris -o Hello Hello.idr $ ./Hello Hello, World -o オプションをつけて idris コマンドを起動するとREPLではなくコンパイラが起動し、 -o で指定したファイルへとコンパイル結果を出力します。\nもうちょっと複雑なことをしましょう。 getLine: IO String で標準入力から1行取得できます。 これと putStrLn で入力をエコーバックするプログラムはこう書けます。\n例： getLine と putStrLn を使ってユーザの入力を表示するプログラム\nmain : IO () main = getLine \u0026gt;\u0026gt;= \\s =\u0026gt; putStrLn (\u0026#34;Your input is \u0026#34; ++ s) あるいは、 do 記法で書くこともできます。\n例： getLine と putStrLn を使ってユーザの入力を表示するプログラムを do 記法で書いたもの\nmain : IO () main = do s \u0026lt;- getLine putStrLn (\u0026#34;Your input is \u0026#34; ++ s) これを Echo.idr に保存し、コンパイル、実行すると以下のように動作します。\n$ idris -o Echo Echo.idr $ ./Echo echooooo Your input is echooooo ところでIOって何？ IO の型にちょっと違和感を覚えた方もいるんじゃないかと思います。 main の型は IO () という値です。関数じゃありません。 同じく getLine も IO String という値です。 これだと書いたそばから実行されてしまわないでしょうか。 まあ、動いてるからにはそうならないんのは分かるんですが、どういう仕組みなんでしょう。\nIdrisのプログラムからは IO の値を実行することができません。 getLine と書いたからといって即座に標準入力から文字列を取り出したりしないのです。 唯一 main に書いた IO の値のみが処理系側で実行されます。 処理系側で実行されてはじめて標準入力から文字列を取り出すというアクションが行なわれます。 IO は実行される前のプログラムのようなものなのです。\nIO を実行できるのは mainの1箇所のみとなると、複数のIO処理をしたいときは IO の値を合成する必要があります。 その仕組みに選ばれたのがモナドという訳です。 \u0026gt;\u0026gt;= は別名 bind （結合）ですが、先程の getLine と putStrLn のように複数のIO処理を結合するのに使われているのです。\n純粋関数型言語とIO さて、 main でしか IO を実行できないとなると他の関数内でIO処理をしたい場合はどうすればいいのでしょう。\n1つの答えは「そういう関数は設計が悪いから書くな」です。 純粋関数型言語であるIdrisの基本方針として、IOや変数への破壊的代入などの計算以外の処理はよくないものとされています。 関数を呼んだときに何が起こるか分からなくなるからです。 なので関数内でIO処理を書きたくなったときはまずは「計算部分とIO部分に分離できないか」と考えてみましょう。\nもう1つの答えは 「全て IO モナドの中で書く」です。 IO モナドをリレーのように main まで伝えればIOを実行できます。 なので関数の中でIOをしたければ IO モナドの中で書くことにすれば実現できます。 とはいえやっぱりIOの中でプログラムを書くのは面倒なので基本的には純粋な計算部分とIO部分に分けて、 IO部分でだけ IO モナドを使うようになります。\nじゃあデバッグプリントを関数の中に仕込みたかったらどうなるの、という疑問はあるかもしれません。 まあ、普通に IO を使ってそれを呼ぶ関数を全て IO モナドの中で書くように変更します。 ちょっと面倒ですよね。一応そういった用途のためのバックドアの機構はあるのでそのうち紹介します。\nまとめ Idrisの重要な機能インタフェースと、重要なインタフェース Monad 、重要なモナド IO を立て続けに紹介しました。 IO まで辿りついたことでIdrisのプログラムを書けるようになりました。\n未紹介のIdrisの機能もあるのでAdvent Calendarの残りでは手を動かしつつ他の機能も紹介していけたらなと思います。\n 名前付き実装という機能を使えばその限りではないのですが、話がややこしくなるので一旦置いておきます。 [return]  ","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-09","title":"Idrisのインタフェースとモナドなどなど","url":"https://KeenS.github.io/blog/2020/12/09/idrisnointafe_sutomonadonadonado/"},
  {"body":"このエントリはIdris Advent Calendar 2020の8日目の記事です。\nκeenです。昨日の予告通り今回は手を動かすパートとしてIdrisのREPLを紹介することにします。\nidris を引数なしで起動するとインタラクティブシェルに入ります。\n$ idris ____ __ _ / _/___/ /____(_) / // __ / ___/ / ___/ Version 1.3.3 _/ // /_/ / / / (__ ) https://www.idris-lang.org/ /___/\\__,_/_/ /_/____/ Type :? for help Idris is free software with ABSOLUTELY NO WARRANTY. For details type :warranty. Idris\u0026gt;  ここに式を入力するとその評価結果を表示してくれます。\nIdris\u0026gt; 1 + 1 2 : Integer Idris\u0026gt;  これは入力の読み取り（Read）、評価（Eval）、表示（Print）を繰り返して（Loop）くれるのでREPLと呼ばれます。\n言語の初学者にはいちいちファイルを書いてコンパイルして実行しなくても挙動を確認できるので便利ですね。 さらにIdrisはかなりREPLを作り込んでるので玄人にも重要な機能です。\nそれではこれを使っていきましょう。\n式の評価 上にも書いたとおり、式を入力するとそれを計算して表示してくれます。\nIdris\u0026gt; [1..10] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : List Integer Idris\u0026gt; [ i | i \u0026lt;- [1..10], i `mod ` 2 == 0] [2, 4, 6, 8, 10] : List Integer Idrisでは型も値として扱えることを思い出すと、型名を入力するとそれも評価して表示してくれることが分かります。\nIdris\u0026gt; List List : Type -\u0026gt; Type Idris\u0026gt; Integer Integer : Type Idris\u0026gt; List List : Type -\u0026gt; Type idris\u0026gt; List Integer List Integer : Type とはいえ型は実体がないので特に計算とかは走りません。\n一応計算を含む型であればそれを計算した結果が表示されます。\nIdris\u0026gt; if True then Integer else String Integer : Type ところで「型の型」である Type の型、 「型の型の型」が気になりませんか？ これを打ち込むとこう表示されます。\nIdris\u0026gt; Type Type : Type Type 自身が Type のインスタンスになってますね。 これではかの有名なラッセルのパラドックスになってしまいます。 しかし（私も自信はないですが）恐らくこれは表示を省略しているだけでそういう矛盾はIdrisには含まれていません。\nREPLコマンド さて、ここからが本番です。 IdrisのREPLには豊富なコマンドがあります。 その全貌はREPLに :? または :help と打つと表示されます。\nIdris\u0026gt; :? Idris version 1.3.3 ------------------- Command Arguments Purpose \u0026lt;expr\u0026gt; Evaluate an expression :t :type \u0026lt;expr\u0026gt; Check the type of an expression :core \u0026lt;expr\u0026gt; View the core language representation of a term :miss :missing \u0026lt;name\u0026gt; Show missing clauses :doc \u0026lt;name\u0026gt; Show internal documentation :mkdoc \u0026lt;namespace\u0026gt; Generate IdrisDoc for namespace(s) and dependencies :apropos [\u0026lt;package list\u0026gt;] \u0026lt;name\u0026gt; Search names, types, and documentation :s :search [\u0026lt;package list\u0026gt;] \u0026lt;expr\u0026gt; Search for values by type :wc :whocalls \u0026lt;name\u0026gt; List the callers of some name :cw :callswho \u0026lt;name\u0026gt; List the callees of some name :browse \u0026lt;namespace\u0026gt; List the contents of some namespace :total \u0026lt;name\u0026gt; Check the totality of a name :r :reload Reload current file :w :watch Watch the current file for changes :l :load \u0026lt;filename\u0026gt; Load a new file :! \u0026lt;command\u0026gt; Run a shell command :cd \u0026lt;filename\u0026gt; Change working directory :module \u0026lt;module\u0026gt; Import an extra module :e :edit Edit current file using $EDITOR or $VISUAL :m :metavars Show remaining proof obligations (metavariables or holes) :p :prove \u0026lt;hole\u0026gt; Prove a metavariable :elab \u0026lt;hole\u0026gt; Build a metavariable using the elaboration shell :a :addproof \u0026lt;name\u0026gt; Add proof to source file :rmproof \u0026lt;name\u0026gt; Remove proof from proof stack :showproof \u0026lt;name\u0026gt; Show proof :proofs Show available proofs :x \u0026lt;expr\u0026gt; Execute IO actions resulting from an expression using the interpreter :c :compile \u0026lt;filename\u0026gt; Compile to an executable [codegen] \u0026lt;filename\u0026gt; :exec :execute [\u0026lt;expr\u0026gt;] Compile to an executable and run :dynamic \u0026lt;filename\u0026gt; Dynamically load a C library (similar to %dynamic) :dynamic List dynamically loaded C libraries :? :h :help Display this help text :set \u0026lt;option\u0026gt; Set an option (errorcontext, showimplicits, originalerrors, autosolve, nobanner, warnreach, evaltypes, desugarnats) :unset \u0026lt;option\u0026gt; Unset an option :color :colour \u0026lt;option\u0026gt; Turn REPL colours on or off; set a specific colour :consolewidth auto|infinite|\u0026lt;number\u0026gt;Set the width of the console :printerdepth [\u0026lt;number\u0026gt;] Set the maximum pretty-printer depth (no arg for infinite) :q :quit Exit the Idris system :version Display the Idris version :warranty Displays warranty information :let (\u0026lt;top-level declaration\u0026gt;)...Evaluate a declaration, such as a function definition, instance implementation, or fixity declaration :unlet :undefine(\u0026lt;name\u0026gt;)... Remove the listed repl definitions, or all repl definitions if no names given :printdef \u0026lt;name\u0026gt; Show the definition of a function :pp :pprint \u0026lt;option\u0026gt; \u0026lt;number\u0026gt; \u0026lt;name\u0026gt;Pretty prints an Idris function in either LaTeX or HTML and for a specified width. :verbosity \u0026lt;number\u0026gt; Set verbosity level まだ紹介してない機能向けのコマンドなどもあるのでこれを見ただけだと混乱するかもしれません。 ゆっくり1つずつ試していきましょう。\n関数を定義する REPLに打ち込んで評価できるのは式までで、 foo = 1 のような変数定義は扱えません。 その代わり :let コマンドで定義できます。 試してみましょう。\nIdris\u0026gt; :let foo : Integer Idris\u0026gt; foo foo : Integer Idris\u0026gt; :let foo = 1 Idris\u0026gt; foo 1 : Integer 定義できていますね。\n関数も定義できますが、少し癖があるようです。\nIdris\u0026gt; :let add : Integer -\u0026gt; Integer -\u0026gt; Integer Idris\u0026gt; :let add x y = x + y When checking an application of function Prelude.Interfaces.+: No such variable x Idris\u0026gt; :let add = \\x, y =\u0026gt; x + y Idris\u0026gt; :t add add : Integer -\u0026gt; Integer -\u0026gt; Integer 関数は後述するファイルを読み込む方法を使った方がよさそうです。\n定義した関数は :unlet （:undefine）で未定義に戻すことができます。\nIdris\u0026gt; :undefine Undefined foo,foo,add,add. 型の表示 :t あるいは :type コマンドで式の型を表示できます。\nIdris\u0026gt; :t 1 1 : Integer Idris\u0026gt; :t Integer Integer : Type Idris\u0026gt; :t putStrLn putStrLn : String -\u0026gt; IO () 式の評価とあまり変わらなそうな気がしますが、評価に時間のかかる式で型情報だけほしい場合に便利です。\nここで例の Type の型を見てみましょう。\nIdris\u0026gt; :t Type Type : Type 1 Type 1 と表示されました。 じゃあその型は…となると察しのとおり Type 2 になるはずですが、今のところユーザが手で書く手段がないので実験的に確かめることはできません。\nIdris\u0026gt; :t (Type 1) builtin:Type mismatch between Type (Type of Type) and _ -\u0026gt; _ (Is Type applied to too many arguments?) 詳しくは省きますがIdrisの型システムはラッセルのパラドックスが起きなように設計されていて、型の型、型の型の型、型の型の型の型…はそれぞれ異なるようになっています。その階層を表わすのが Type 1 についている1という数字です。\nファイルを扱う REPLにファイルを読み込んでみましょう。\nrecodr.idr というファイルに以下の内容を書いて保存します。\nrecord Person where constructor MkPerson age: Int name: String ロード :cd コマンドで record.idr を書いたディレクトリまで移動します。\nIdris\u0026gt; :cd ../Idris そして :l （ :load ）コマンドでファイルを読み込みましょう。 ファイル名はTABによる補完が効きます。\nIdris\u0026gt; :l record.idr Type checking ./record.idr *record\u0026gt; プロンプトの表示が変わりましたね。record.idr を読み込むとファイルの内容を型チェックし、REPLにロードしてくれます。\n例えば Person 型のコンストラクタ MkPerson が読み込まれてるのが確認できます。\n*record\u0026gt; :t MkPerson MkPerson : Int -\u0026gt; String -\u0026gt; Person リロード 次に record.idr を編集して incAge を追加してみましょう\n-- ... incAge: Person -\u0026gt; Person incAge = record { age $= (1+) } これにはやり方が2種類あります。 1つは普通にエディタで編集して、 IdrisのREPLで :r （ :reload ）するものです。\n*record\u0026gt; :r 編集 もう1つはターミナルにひきこもってる人向けにIdrisのREPLから :e （ :edit ） でファイルを編集するものです。 EDITOR または VISUAL 環境変数に設定されているエディタを起動し、ファイルを編集するよう促します。 編集し終わるとIdrisのREPLに戻ってきて、以下のように続きます。\n*record\u0026gt; :e Type checking ./record.idr Loading ./record.ibc failed: Module needs reloading: SRC : \u0026#34;./record.idr\u0026#34; Modified at: 2020-12-07 14:25:15.707323014 UTC IBC : \u0026#34;./record.ibc\u0026#34; Modified at: 2020-12-07 14:18:51.578095669 UTC *record\u0026gt; :r Type checking ./record.idr :e のあとに型チェックしてくれるんですが、何故かエラーになってしまいました。コンパイル結果の中間ファイル（*.ibc） が悪さをしたのかな？しかし慌てずに :r を打てば問題ありません。\nでは今読み込んだ incAge 関数を試してみましょう。\n*record\u0026gt; incAge (MkPerson 28 \u0026#34;Tom\u0026#34;) MkPerson 29 \u0026#34;Tom\u0026#34; : Person こうやってファイルを編集しては試しての繰り返しの作業フローができました。\n継続的リロード 因みに型チェックしたいだけなら :w （ :watch ）でファイル変更を監視して継続的にリロードすることもできます。\n*record\u0026gt; :w record.idr Watching for .idr changes in [\u0026#34;record.idr\u0026#34;], press enter to cancel. Type checking ./record.idr 探索する IdrisのREPLはIdrisが知っていることを教えてくれます。 例えば :browse は名前空間に定義されているシンボル一覧を教えてくれます。 名前空間はまだ出てきてない機能ですが、雰囲気で察して下さい。\n今回の record.idr には名前空間を指定してなかったので Main という名前が割り当てられています。\n一覧する :browse コマンドで名前空間に定義されているアイテムを一覧することができます。Main で定義されているアイテムを表示してみましょう。\n*record\u0026gt; :browse Main Namespaces: Main.Person Names: MkPerson : Int -\u0026gt; String -\u0026gt; Person Person : Type incAge : Person -\u0026gt; Person 表示されましたね。因みに Main.Person という名前空間もあるようです。これも表示してみましょう。\n*record\u0026gt; :browse Main.Person Namespaces: Names: age : Person -\u0026gt; Int name : Person -\u0026gt; String set_age : Int -\u0026gt; Person -\u0026gt; Person set_name : String -\u0026gt; Person -\u0026gt; Person これは record 構文で生成された関数が格納されています。\nドキュメントを表示する Idrisには言語組み込みでドキュメントの機能があります（基本文法のところでドキュメントコメント構文を紹介しましたね）。それをREPLから表示できます。\n例えば標準ライブラリの List のドキュメントを表示してみましょう。\n*record\u0026gt; :doc List Data type Prelude.List.List : (elem : Type) -\u0026gt; Type Generic lists The function is: public export Constructors: Nil : List elem Empty list The function is: public export (::) : (x : elem) -\u0026gt; (xs : List elem) -\u0026gt; List elem A non-empty list, consisting of a head element and the rest of the list. infixr 7 The function is: public export しっかりと表示できてますね。 見なれない記述があってもひとまず無視して自然言語だけでも理解するようにして下さい。 まだ説明してない機能もたくさんあるので分からないことがあっても当然です。\n探す ほしい機能がないか探すこともできます。\n例えば List を結合する関数を探しているとしましょう。 その関数は List a -\u0026gt; List a -\u0026gt; List a という型をしているはずです。これを検索してみましょう。 :s （ :search ） でその型を使って検索できます。\n*record\u0026gt; :s List a -\u0026gt; List a -\u0026gt; List a = Prelude.List.(++) : List a -\u0026gt; List a -\u0026gt; List a Append two lists = Prelude.List.reverseOnto : List a -\u0026gt; List a -\u0026gt; List a Reverse a list onto an existing tail. \u0026gt; Prelude.List.(\\\\) : Eq a =\u0026gt; List a -\u0026gt; List a -\u0026gt; List a The \\\\ function is list difference (non-associative). In the result of xs \\\\ ys, the first occurrence of each element of ys in turn (if any) has been removed from xs, e.g., \u0026gt; Prelude.List.union : Eq a =\u0026gt; List a -\u0026gt; List a -\u0026gt; List a Compute the union of two lists according to their Eq implementation. \u0026gt; Prelude.List.merge : Ord a =\u0026gt; List a -\u0026gt; List a -\u0026gt; List a Merge two sorted lists using the default ordering for the type of their elements. .... いくつか候補がで出てきました。 このうち、 先頭に = がついているものは完全一致、 \u0026gt; がついているものはより狭い型、 \u0026lt; がついているものはより広い型の関数のようです。\nひとまず最初の候補である Prelude.List.(++) に 「Append two lists」 と書かれているのでこれが求める演算子のようです。 使ってみましょう。\n*record\u0026gt; [1, 2, 3] ++ [4, 5, 6] [1, 2, 3, 4, 5, 6] : List Intege 想定どおりですね。\nもう1つ探し方があります。自然言語で全文検索する方法です。こちらは :apropos を使います。 同じく List を結合する関数を「append」 のキーワードで検索してみましょう。\n*record\u0026gt; :apropos append Prelude.List.(++) : List a -\u0026gt; List a -\u0026gt; List a Append two lists Prelude.Strings.(++) : String -\u0026gt; String -\u0026gt; String Appends two strings together. Prelude.File.Append : Mode Prelude.File.ReadAppend : Mode Prelude.Strings.addToStringBuffer : StringBuffer -\u0026gt; String -\u0026gt; IO () Append a string to the end of a string buffer Prelude.List.appendAssociative : (l : List a) -\u0026gt; (c : List a) -\u0026gt; (r : List a) -\u0026gt; l ++ c ++ r = (l ++ c) ++ r Appending lists is associative. Prelude.List.appendCong2 : (x1 = y1) -\u0026gt; (x2 = y2) -\u0026gt; x1 ++ x2 = y1 ++ y2 Appending pairwise equal lists gives equal lists ... こちらの場合も Prelude.List.(++) が表示されていますね。\n適宜2つを使い分けながらほしい関数を探してみて下さい。\n定義を表示する :printdef で関数の定義を表示することもできます。\n*record\u0026gt; :printdef Prelude.List.(++) (++) : List a -\u0026gt; List a -\u0026gt; List a [] ++ right = right (x :: xs) ++ right = x :: xs ++ right 恐らくソースコードに書いてあるものそのままではなくIdrisの内部表現をユーザが読める形に再出力してるんですかね？\n実行する 一旦今開いてるREPLを閉じて、別のセッションを開くことにします。 REPLを閉じるには :q （ :quit ） を打ち込むかEOFを送り込む（Ctrl+D）かをします。\nそして以下の内容の hello_world.idr を用意しておきます。\nmain : IO () main = putStrLn \u0026#34;Hello, World\u0026#34; そして idris の引数に hello_world.idr を与えながら起動します。\n$ idris hello_world.idr ____ __ _ / _/___/ /____(_)____ / // __ / ___/ / ___/ Version 1.3.3 _/ // /_/ / / / (__ ) https://www.idris-lang.org/ /___/\\__,_/_/ /_/____/ Type :? for help Idris is free software with ABSOLUTELY NO WARRANTY. For details type :warranty. Type checking ./hello_world.idr *hello_world\u0026gt; これでファイルの中身を読み込みながらREPLが起動してくれます。 一旦REPLを起動してから :l で読み込んでも同じですが、複数の方法を覚えておいて損はないでしょう。\nさて、このファイルには main が定義されています。 つまり実行可能です。 :exec でファイルをコンパイ/実行できます。\n*hello_world\u0026gt; :exec Hello, World :c （ :compile ） でコンパイルするこもできます。\n*hello_world\u0026gt; :c hello_world また、読み込んだ main の名前を指定して実行することもできます。 :x です。\n*hello_world\u0026gt; :x main Hello, World MkIO (\\w =\u0026gt; prim_io_pure ()) : IO\u0026#39; (MkFFI C_Types String String) () ちょっと見えちゃいけないものが見えてるような気がしますが、大丈夫です。\nこれだけ揃えば「あれIdrisでどう書くんだっけ」というのはなんとかなるんじゃないでしょうか。\nIdris小旅行 結果は貼りませんが、以下のようなコマンドでIdrisの基本の手札を確認できるんじゃないでしょうか。\nIdris\u0026gt; :browse Builtins idris\u0026gt; :browse Prelude Idris\u0026gt; :browse Prelude.List Idris\u0026gt; :doc Prelude.List.head\u0026#39; Idris\u0026gt; :printdef the Idris\u0026gt; :printdef id -- などなど まとめ IdrisでのREPLの使い方、そしてそれを通じたIdrisの探索方法を紹介しました。 IdrisのREPLは非常に高機能で、それだけでプログラミングできてしまいます。 ぜひREPLを使いこなしましょう。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-07","title":"REPLでIdris小旅行","url":"https://KeenS.github.io/blog/2020/12/07/repldeidrisshouryokou/"},
  {"body":"κeenです。 以前雑な実装でブログにOGP画像を生成するようにしましたが、禁則処理が気になったのでそれを工夫したときの記録です。\nモチベーション 以前の作業はこれです。\nInkscapeを使ってSVGからOGPイメージを半自動生成する | κeenのHappy Hacκing Blog\n読んでない方に説明すると、SVGのERBテンプレートを作って記事データをあてはめたものからInkscapeでPNG画像を生成しているのでした。 その際に改行が自動で入らないので自分で改行をいれる必要があります。 今回はその改行を入れる位置を工夫したというお話。\n文書に改行をいれるにあたって禁則処理というのがあります。 恐らく小学校でも習ったと思いますが、行末に開き鉤括弧（「）を置かない、句点（。）読点（、）を行頭に置かない、などです。\nもうちょっというと、今回の対象は文章ではなく中央揃えのタイトルなので禁則事項に触れないだけでなく「ちょうどいい」場所で改行してほしいです。\n何故改行を入れる位置にこだわるかというと、このツイートがわかりやすいかもしれません。\nブログのOGPの生成をちょっと工夫した。それっぽいかたまりをトークンとしてまとめて、トークンの境目でしか改行しないようにした。\n←before after→ pic.twitter.com/kbRUwag7sp\n\u0026mdash; κeen (@blackenedgold) December 6, 2020 \n「使\nって」\nと格好悪い見た目になってますね。これを防ぎたい訳です。他にも英単語の途中で改行されたくないだとか色々と条件があります。\n本気出してやるなら自然言語処理して文節単位で区切って〜となるのですが、あんまり頑張りたくないので適当なヒューリスティックで近似します。\n方針 最初に細かい実装上の都合なんですが、文字の正確な横幅の情報を取り出せるのがInkscapeに渡して画像としての準備ができてからになります。 そこからデータを取り出すのが少し手間ですし、遅いです。なので数回Inkscapeに横幅を問い合わせるだけでアルゴリズムを完了させたいです。\n幸いにもInkscapeには1度のクエリで複数の結果を返す機能がついています。 なので細切れにした情報を送り込めれば一度に色々な情報を取り出せます。 ということで以下の方針で実装することにします。\n タイトルを改行しない塊（トークン）に区切る トークン単位でタグ付けしたタイトルのSVGを生成する  \u0026lt;title\u0026gt;\u0026lt;tsapn\u0026gt;トークン1\u0026lt;/tspan\u0026gt;\u0026lt;tspan\u0026gt;トークン2\u0026lt;/tspan\u0026gt; ... \u0026lt;/title のような見た目  生成したSVGをInkscapeに読み込み、タイトルの全体の長さとトークンの長さを取得する タイトル全体の長さが画像の横幅より大きければトークンのどれかに改行文字を入れる  2、3は私の書いたOGP画像生成スクリプトの都合です。 4は先頭から1つ1つトークンを取得して横幅を足していって、規定の長さを越えたトークンの1つ前で改行すればいいだけなので難しいことはありません。\nなので1について解説します。\nトークン分割処理 まず、対象データがどういうものかを確認します\n 漢字かなカナ英字記号交じり 漢字かなカナ英字は同じくらいの割合で交じっている 約物（。や！など）は少ないが、ないことはない  ここから、字種（漢字かなカナ英字）が変わるタイミングで区切ればそれっぽいのではないかと仮説を立てます。 ただしいくつか例外規定も設けます。\n 鉤括弧の行末禁止などは別途実装する 漢字からひらがなへの変化は区切りとしない  「使ってる」を「使」と「ってる」に区切りたくない  その他細則  この規則を実装していきましょう。\nまず、字種を判別するメソッドから。\ndef char_class_of(c) case c when /[a-zA-Zα-ωΑ-Ω]/ :alphabetic when /[0-9０−９]/ :numeral when /\\s/ :spaces when /[「（(\\[\u0026#34;\u0026#39;※『{〔〘〈《【〖]/ :yaku_start when /[。、…)）」!?？！\\]ー』}〕〙》〉】〗]/ :yaku_end when /[\\p{Hiragana}]/ :hiragana when /[\\p{Katakana}]/ :katakana when /[\\p{Han}]/ :kanji else :other end end 私のブログのタイトルに使われそうなものしか考慮してないので雑ですね。\n:alphabetic にギリシャ文字も含んでいるのは私のハンドルネームのκeenのκがギリシャ文字だからです。たまにはブログタイトルに自分の名前を使うこともあるだろうという判断です。\n正規表現の \\p{Hogehoge} というのはUnicode Propertyというやつです。\n参考: 正規表現 \\p{\u0026hellip;} メモ - Qiita\n探せば色々プロパティがあるのでしょうが、探すのが面倒だったのでパッとみつかった漢字かなカナにのみ使ってます。\n次に2つの文字種を受け取って、その文字種の間に改行を入れるべきかを返す split_point メソッドです。\ndef japanese_classes [:hiragana, :katakana, :kanji] end def split_point?(before, after) # 行頭の場合 if before == nil return false end if after == :yaku_start return true end if before == :yaku_start return false end if after == :yaku_end return false end if japanese_classes.map{|j| [:kanji, j]}.include?([before, after]) return false end if [[:alphabetic, :hiragana]].include?([before, after]) return false end before != after end いくつかの禁則処理や漢字+ひらがな、英字+ひらがなで例外が入ってますが、基本は before != after の文字種が違ったら分割するという処理です。\nあとはこれらを使って split_point? がtrueだった場合に分割するメソッドを書くだけです。\ndef tokenize(str) result = [] current = \u0026#34;\u0026#34; last_char_class = nil str.each_char do |c| char_class = char_class_of(c) if split_point?(last_char_class, char_class) result \u0026lt;\u0026lt; current last_char_class = nil current = c else current += c end last_char_class = char_class end result \u0026lt;\u0026lt; current if current != \u0026#34;\u0026#34; result end これはirbなどにロードして動作を確認できます。\nirb(main):079:0\u0026gt; tokenize(\u0026#34;Inkscapeを使ってSVGからOGPイメージを半自動生成する\u0026#34;) =\u0026gt; [\u0026#34;Inkscapeを\u0026#34;, \u0026#34;使って\u0026#34;, \u0026#34;SVGから\u0026#34;, \u0026#34;OGP\u0026#34;, \u0026#34;イメー\u0026#34;, \u0026#34;ジ\u0026#34;, \u0026#34;を\u0026#34;, \u0026#34;半自動生成する\u0026#34;] irb(main):080:0\u0026gt; tokenize(\u0026#34;Inkscapeで生成するOGP画像の禁則処理をちょっとだけ頑張る\u0026#34;) =\u0026gt; [\u0026#34;Inkscapeで\u0026#34;, \u0026#34;生成する\u0026#34;, \u0026#34;OGP\u0026#34;, \u0026#34;画像の\u0026#34;, \u0026#34;禁則処理をちょっとだけ\u0026#34;, \u0026#34;頑張る\u0026#34;] まあ、悪くないんじゃないでしょうか。\n一応既知の問題として長音符（ー）が約物になるのでカタカナ語の分割が下手というのはあります。\nirb(main):082:0\u0026gt; tokenize(\u0026#34;ロード時間を短くする\u0026#34;) =\u0026gt; [\u0026#34;ロー\u0026#34;, \u0026#34;ド\u0026#34;, \u0026#34;時間を\u0026#34;, \u0026#34;短くする\u0026#34;] あとは2, 3, 4を実装してあげれば完成です。\n雑にそれっぽい成果が欲しい方は真似してみて下さい。\n","categories":["Inkscape","NLP"],"category_urls":["/categories/inkscape","/categories/nlp"],"date":"2020-12-07","title":"Inkscapeで生成するOGP画像の禁則処理をちょっとだけ頑張る","url":"https://KeenS.github.io/blog/2020/12/07/inkscapedeseiseisuruogpgazounokinsokushoriwochottodakeganbaru/"},
  {"body":"このエントリはIdris Advent Calendar 2020の7日目の記事です。 前はrigh1113さんで自然数の加法の交換法則 by Idrisでした。\nκeenです。今日は型とデータ型を紹介します。\nプリミティブ 先日紹介したとおり、プリミティブは以下です。\n   名前 説明     Int 固定長整数   Integer 多倍長整数   Double 倍精度浮動小数点数   Char 文字   String 文字列   Ptr FFI用    Haskellに慣れている方に注意ですが、 String は List Char ではありません。\nデータ型 先日紹介したとおり、データ型は data 名前 = 定義 の構文で定義します。 定義のところには ヴァリアント | ヴァリアント… と書きます。 ヴァリアントには コンストラクタ 引数の型 … と書きます。 ヴァリアントは少なくとも1つ、コンストラクタの引数は0以上を書きます。\n例：引数のないコンストラクタのヴァリアントを2つ持つデータ型\ndata Bool = True | False 例：引数の2つあるコンストラクタのヴァリアントを1つ持つデータ型\ndata Person = MkPerson Int String 引数ありのコンストラクタのヴァリアントを1つ持つデータ型は頻出パターンで、構造体のように使えます。 そのときのコンストラクタが構造体のコンストラクタのようになります。こういうときは MkHoge と Mk （makeの略）を前置するのが慣例です。\n例： 引数のあるコンストラクタや引数のないコンストラクタのヴァリアントのあるデータ型\ndata FizzBuzz = F | B | FB | I Integer データ型は自身を定義に使う再帰的定義もできます。\n例：任意個の整数を保持できる型の定義\ndata IntList = Cons Int IntList | Nil Cons 1 (Cons 2 (Cons 3 Nil)) データ型とパターンマッチ データ型のコンストラクタは値を構築するときだけでなく分解するときにも使います。 パターンマッチでそのままマッチできるのです。\n例： Person 型から1つ目の引数、2つ目の引数の値を取り出す関数の定義\nage : Person -\u0026gt; Int age (MkPerson age _) = age name : Person -\u0026gt; String name (MkPerson _ name) = name | で複数のバリアントを定義しているデータ型には分岐を使うことになるでしょう。\n例： 複数バリアントのあるデータ型へのパターンマッチで分岐するコード\nshow : FizzBuzz -\u0026gt; String show F = \u0026#34;fizz\u0026#34; show B = \u0026#34;buzz\u0026#34; show FB = \u0026#34;fizzbuzz\u0026#34; show (I n) = toString n -- toStringは実際は存在しないが、説明の簡単さのために使う。 再帰的データ型なら呼応するように再帰関数を使うことになります。\n例： 再帰関数を用いて IntList の長さを求めるコード\nlength : IntList -\u0026gt; Int length Nil = 0 length (Cons _ tl) = 1 + (length tl) このようにデータ型からプログラムの構造が自然と決まるのでデータ型は便利かつ重要な機能です。\nジェネリクス 上記の IntList は Int の値のみ保持できました。 これを任意のデータを保持できるようにするにはジェネリクスを使います。 つまり IntList を保持するデータ型について一般化するのです。\n一般化したときの型は引数で受け取れるようにし、それを型変数で表します。\nジェネリクスで使う型変数は関数の引数のように List a と置きます。 小文字の変数が自動で型変数として扱われます。 そして List の定義のところで Int だった部分を a で置き換えます。\n例：任意の型について、その型の値を任意個保持できるデータ型の定義\ndata List a = Cons a IntList | Nil Cons 1 (Cons 2 (Cons 3 Nil)) Cons \u0026#39;a\u0026#39; (Cons \u0026#39;b\u0026#39; (Cons \u0026#39;c\u0026#39; Nil)) 関数定義も同様にジェネリクスにできます。 関数定義は特に引数などを導入せずにそのまま小文字の変数を使うだけでジェネリクスになります。\n例： List a の長さを求めるコード\nlength : List a -\u0026gt; Int length Nil = 0 length (Cons _ tl) = 1 + (length tl) レコード Person 型のように事実上構造体として扱うデータ型の定義は専用の便利構文が用意されています。\nPerson 型とそのメンバーへのアクセサは以下のように定義されているのでした。\n例：データ型を構造体のように使うコード（再掲）\ndata Person = MkPerson Int String age : Person -\u0026gt; Int age (MkPerson age _) = age name : Person -\u0026gt; String name (MkPerson _ name) = name これとほぼ同等のことを record 構文でできます。 レコードは record 名前 [型引数…] where 本体 で定義します。 本体には constructor コンストラクタ名 か フィールド, …: 型 を書きます。 例えば以下のように使います。\n例： MkPerson をレコードで定義するコード\nrecord Person where constructor MkPerson age: Int name: String これは裏では以下のようなコードが生成されているようです。\n例： MkPerson をレコードで定義するコードを展開したイメージ\ndata Person = MkPerson Int String age : Person -\u0026gt; Int age (MkPerson age _) = age name : Person -\u0026gt; String name (MkPerson _ name) = name set_age : Int -\u0026gt; Person -\u0026gt; Person set_age age (MkPerson _ name) = MkPerson age name set_name : String -\u0026gt; Person -\u0026gt; Person set_name name (MkPerson age _) = MkPerson age name Idrisは純粋関数型言語なので値を変更することはできません。 代わりにフィールドの値の違う新しい値を返します。\nレコードの関数型更新構文 set_xxx を呼び出すだけですが、レコードを更新する（フィールドの値を変更した新しい値を返す）構文が用意されています。 record { … } の形をしています。 … の中に入る構文はいくつか種類があります。\n例： レコードの関数型更新構文のいくつか\n-- フィールド = 値 record { age = 29 } -- フィールド $= 更新関数 record { age $= (+ 1) } -- (+ 1) は1を足す関数 -- 複数のフィールドの更新 record { age $= (+ 1), name = \u0026#34;anonymous\u0026#34; } 他にもネストしたフィールドの更新構文なんかもあります。\nさて、これらの構文は関数へと展開されます。\n例：関数型更新構文が関数として振る舞うことがわかる例\nincAge: Person -\u0026gt; Person incAge = record { age $= $(+ 1) } なので実際に使うときは record { age $= (+ 1) } p のようにレコード p を引数として渡すことになります。\n関数の型 先日関数の型は 引数1の型 -\u0026gt; 引数2の型 -\u0026gt; … -\u0026gt; 引数nの型 -\u0026gt; 返り値の型 と紹介しましたが、あれは嘘です。 嘘というか事実上は合ってるんですが、厳密には異ります。\nIdrisの関数の型は 引数の型 -\u0026gt; 返り値の型 のみです。 じゃあ Int -\u0026gt; Int -\u0026gt; Int とかの型は何というと、 -\u0026gt; が右結合なので Int -\u0026gt; (Int -\u0026gt; Int) と解釈される訳です。\n同じく、関数の適用も 関数 引数 のみです。 関数 引数1 引数2 は (関数 引数) 引数 と解釈されます。\nさらに、関数定義の構文 関数名 引数1 … 引数n = 本体 もこれ以外の定義もありえます。 結果として型の帳尻さえあっていれば引数の個数は柔軟です。 例えば以下の add の定義は全て同等です。\n例： add を関数定義構文やラムダ式やその組み合わせで定義するコード\n-- 関数定義構文による定義 add: Int -\u0026gt; Int -\u0026gt; Int add x y = x + y -- 引数を1つ関数定義構文で受け取り、1つラムダ式で受け取る定義 add: Int -\u0026gt; Int -\u0026gt; Int add x = \\y =\u0026gt; x + y -- 引数を全てラムダ式で受け取る定義 add: Int -\u0026gt; Int -\u0026gt; Int add = \\x =\u0026gt; \\y =\u0026gt; x + y -- 複数引数をとるラムダ式による定義 add: Int -\u0026gt; Int -\u0026gt; Int add = \\x, y =\u0026gt; x + y ところで Int -\u0026gt; (Int -\u0026gt; Int) は「 Int を与えると Int -\u0026gt; Int を返す関数」 です。 試してみましょう。 add に引数を1つだけ与えてみます。\ninc: Int -\u0026gt; Int inc = add 1 つまり add 1 2 は一度 add 1 を計算して、その結果の関数を 2 に適用しているということになります。 毎回関数を作っては適用してを繰り返したら遅いじゃないかと思われるかもしれませんが、コンパイラの作者もそれは百も承知です。 ちゃんと最適化でそこら辺のコードは綺麗に消えます。\n関数の引数を1つにして、代わりに「関数を返す関数を返す関数を…」とすることで言語のシンプルサを保っています。 また、そのオマケとして inc の定義のように引数を部分適用した関数も作りやすくなっています。\n便利な型 処理系を起動したときに最初から使える型をいくつか紹介したいと思います。\n処理系を起動したときに最初から使える型はいくつかの場所で定義されています。\n   名前 説明     プリミティブ コンパイラに組込まれている   ビルトイン 定義は組み込みではないが、コンパイラに特別扱いされる   プレリュード 起動時に読み込まれるファイルで定義されている    プリミティブとビルトインはあまり区別しないでいいかもしれません。\nプレリュードとは何なのかについては日を改めて説明するとしましょう。 ここではプレリュードが何なのかについては触れずにそこで定義されている型を紹介するだけに留めます。\nプミティブは冒頭で紹介したのでビルトインとプレリュードで定義された型を紹介します。\nビルトイン ビルトインで定義されているデータ型を紹介します。\nユニット 意味のある値がないことを表わすときに使う型です。 Cなどにある void と似ていますが、ユニットは値を持ちます。\n値も型も () で表わします。\nunit : () unit = () よく使う値なのでそのうち出てきます。\nタプル 値の組を表わす型です。 異なる型の値の組を保持できます。 リストなどと違って分割したり結合したりするものではないです。\n(値, 値, …, 値) の構文で記述します。型も (型, 型, …, 型) と書きます。\n例：タプルの値と型\ntriple : (Int, String, Bool) triple = (1, \u0026#34;string\u0026#34;, True) その他 込み入った説明が必要になるので詳しくは解説しませんが、いくつか興味深いビルトインの型を紹介します。\n 依存ペア（a: Type ** P a）: 依存ペア。存在量化に相当する。 Void ： 値がないことを表わす。矛盾に相当する。 Lazy a ：遅延計算に使う  プレリュード プレリュードで定義されている型を紹介します。\nBool ブール型です。以下のように定義されています。\n||| Boolean Data Type data Bool = False | True Idrisはかなり色々な機能をもつのでブール値をライブラリで定義してしまえます。 例えば if ~ then ~ else ~ やショートサーキット演算子 \u0026amp;\u0026amp; / || なんかもライブラリ定義です。 これはアドベントカレンダーのどこかで紹介できたらなと思います。\nEither 「どちらか」 を表わす型です。おおむね以下のように定義されています。\n||| A sum type data Either a b = ||| One possibility of the sum, conventionally used to represent errors Left a | ||| The other possibility, conventionally used to represent success Right b 典型的にはエラーを表わすのに使います。\n例： Either を使ってエラーを表わすコード\ndivide: Int -\u0026gt; Int -\u0026gt; Either String Int divide _ 0 = Left \u0026#34;division by zero\u0026#34; divide m n = Right (m `div` n) 慣例的に、 Left がエラー、 Right が正しい値を表わします。 よく、 「Right がright（正しい）と覚えましょう」と言われてます。\nList 任意の型について、その型の値を任意個保持できるコレクションです。\nおおむね以下のように定義されています。\ninfixr 7 :: ||| Generic lists data List elem = ||| Empty list Nil | ||| A non-empty list, consisting of a head element and the rest of ||| the list. (::) elem (List elem) 上の方で定義した List とほぼ同じですね。 ただし Cons の代わりに中置演算子 :: が用いられています。\n紹介し忘れましたがデータ型のコンストラクタは関数と同等に振る舞うので関数と同様に中置演算子として扱えます。 パターンマッチするときにも中置のままパターンマッチできます。 例をみてみましょう。\n例： List 型のパターンマッチと構築を行うコード\naddAll : Int -\u0026gt; List Int -\u0026gt; List Int addAll _ Nil = Nil addAll a (x::xs) = (a + x) :: (addAll a xs) 関数の引数で Nil と :: へのパターンマッチを、 関数の本体で Nil と :: の構築を行っています。\nListの構文 さて、 List にはいくつか特別な構文が用意されています。\n[1, 2, 3] と書くと 1 :: 2 :: 3 :: Nil と書いたのと同じことになります（:: は右結合の演算子なので 1 :: 2 :: 3 :: Nil は 1 :: (2 :: (3 :: Nil)) と解釈されます）。 これは値としてもパターンとしても使えます。\n[start..end] と書くとstartからendまで（endを含む）の値のリスト返します。\n例：1, 2, 3のリストの構築\n[1..3] 刻み幅を変更することもできます。\n例：1から2つ飛ばしで10以下の値、1, 3, 5, 7, 9を含むリストの構築\n[1, 3..10] また、PythonやHaskellにあるリスト内包表記もあります。 [式 | 修飾] の構文です。 修飾に書ける構文は 変数 \u0026lt;- リスト をカンマ区切りで置けるなどがあります。 例えば九九を生成するリスト内包表記は以下です。\n例：1×1〜9×9までの結果を生成するリスト内包表記\n[ i * j | i \u0026lt;- [1..9], j \u0026lt;- [1..9]] あるいは、修飾の部分に条件式を書くことでその条件に合った値のみを集めることもできます。\n例：2, 4, 6, 8, 10のリストを生成するリスト内包表記\n[n | n \u0026lt;- [1..10], n `mod` 2 == 0] Maybe Maybe は「値があるか、あるいはない」を表わす型です。おおむね以下のように定義されています。\n||| An optional value. This can be used to represent the possibility of ||| failure, where a function may return a value, or not. data Maybe a = ||| No value stored Nothing | ||| A value of type `a` is stored Just a Just x のとき値があり、 Nothing のとき値がないことを表わします。 例えばリストの先頭を取り出す関数 head' は以下のように定義されています。\nhead\u0026#39; : (l : List a) -\u0026gt; Maybe a head\u0026#39; [] = Nothing head\u0026#39; (x::xs) = Just x [] だと先頭の値がないので Nothing を返しています。\n失敗を表わすという意味では Either と似ています。 実際、最初に Maybe で書き始めた関数が失敗するケースが増えてきて Either に書き直すなどはよくあります。\nNat ちょっとここで紹介するか迷いましたが、よく出てくるので先に紹介しておきましょう。 Nat は自然数を表わす型です。0からはじまり無限に続きます。 以下のように定義されています。\n||| Natural numbers: unbounded, unsigned integers which can be pattern ||| matched. data Nat = ||| Zero Z | ||| Successor S Nat これのどこが自然数なんだと思うかもしれません。 これはペアノの公理に基く定義です。 ペアノの公理とは以下のような記述です。\n 自然数は次の5条件を満たす\n 自然数 0 が存在する。 任意の自然数 a にはその後者 (successor)、suc(a) が存在する（suc(a) は a + 1 の \u0026ldquo;意味\u0026rdquo;）。 0 はいかなる自然数の後者でもない（0 より前の自然数は存在しない）。 異なる自然数は異なる後者を持つ：a ≠ b のとき suc(a) ≠ suc(b) となる。 0 がある性質を満たし、a がある性質を満たせばその後者 suc(a) もその性質を満たすとき、すべての自然数はその性質を満たす。   このうち1. は Z 、 2 は S が担当しています。 Idrisのデータ型では3.、4.は自動で満たされます。5はIdrisの型システムが担当します。\nということで上記 Nat は自然数とみなしてよさそうです。 Nat を直接使って数字を表わすのは以下のようにします。\n例： S と Z を使って Nat の3を構築\nthree : Nat three = S (S (S Z)) S が 1 + 相当なので S の数を数えれば何の数値か分かります。 ですがコンパイラの方で数値から Nat へ変換してくれるので以下のようにも書けます。\n例：数値リテラルを使ってNat の3を構築\nthree : Nat three = 3 自然数はインデックスや長さとして使われたりします。 例えばリストの長さを求める関数 length は以下のように定義されています。\nlength : List a -\u0026gt; Nat length [] = Z length (x::xs) = S (length xs) 型の型？ さて、以前Idrisは値を型の一部として扱えると書きましたが、型を値の一部としても扱えます。 すると関数や変数の型を書くときに「型の型」も必要になります。 「型の型」は Type です。\n型エイリアス 「型とデータ型」というタイトルでありながら、いままで型エイリアスの紹介がありませんでしたね。 それもそのはず、Idrisには型エイリアスの機能がありません。 いや、あるんですが、「型エイリアス」という機能としては存在しません。\nどういうことかというと、型も値として扱えるので、グローバル変数を束縛してしまえばそのまま型エイリアスとして機能するのです。\n例：型を変数に束縛して型エイリアスとして使うコード\nIntList : Type IntList = List Int 型アノテーション いくつかの言語では式中で 1 : Int のように式がどの型になるかを明示する機能があります。 しかしIdrisにはありません。 型エイリアスと同じく「型アノテーション」という機能としては存在しません。\n型アノテーションは関数として書けてしまいます。 プレリュードで the という関数として定義されています。\n||| Manually assign a type to an expression. ||| @ a the type to assign ||| @ value the element to get the type the : (a : Type) -\u0026gt; (value : a) -\u0026gt; a the _ = id 例えば the Nat 3 のように使えます。\nまとめ Idrisのデータ型やレコードの構文を紹介しました。 関数の型についても解説し、1引数1返り値の関数型を組み合わせて複数引数の型のように扱っていることも紹介しました。 また、デフォルトで使えるデータ型をいくつか紹介し、データ型の利用例としました。\nまだインターフェースや名前空間系の機能を紹介できてないのですが、次回は一旦手を動かす回にしようかなと思います。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-06","title":"Idrisの型とデータ型","url":"https://KeenS.github.io/blog/2020/12/06/idrisnokatatode_takata/"},
  {"body":"このエントリはML Advent Calendar 2020の3日目の記事です。 前はelpinalさんでStandardMLのwithtypeの挙動でした。\nκeenです。Haskelなどにある ` ~ ` の記法（のようなもの）をSMLで実現する話です。\nMLやHaskellには中置演算子を作る infix 系の構文があります。 そしてHaskellにはそれとは別に ` ~ ` で普通の関数を中置演算子として使える機能があります。\nadd :: Integer -\u0026gt; Integer -\u0026gt; Integer add x y = x + y 1 `add` 2 さらに演算子を部分適用するセクションという機能もあります。\nmap (2 *) list map (- 1) list SMLでもこういう機能ほしいよね、という題材です。\n最初に答えを書いてしまうとこういう演算子を定義します。\ninfix 3 \u0026lt;\\ fun x \u0026lt;\\ f = fn y =\u0026gt; f (x, y) (* Left section *) infix 3 \\\u0026gt; fun f \\\u0026gt; y = f y (* Left application *) infixr 3 /\u0026gt; fun f /\u0026gt; y = fn x =\u0026gt; f (x, y) (* Right section *) infixr 3 \u0026lt;/ fun x \u0026lt;/ f = f x (* Right application *) そうすれば以下のように使えます。\nfun add(x, y) = x + y 1 \u0026lt;\\add\\\u0026gt; 2 \u0026lt;\\add\\\u0026gt; 3 これは以下と同じ意味になります。\nadd(add(1, 2), 3) \u0026lt;\\ と \\\u0026gt; の変わりに \u0026lt;/ と /\u0026gt; を使うと右結合になります。\n1 \u0026lt;/add/\u0026gt; 2 \u0026lt;/add/\u0026gt; 3 (* = add(1, add(2, 3)) *) どうしてこうなるのか詳しく見ていきましょう。\nまずは 1 \u0026lt;\\add\\\u0026gt; 2 からはじめます。これは \u0026lt;\\ と \\\u0026gt; が左結合の infix 3 で定義されているので以下のように脱糖されます。\nop\\\u0026gt;(op\u0026lt;\\(1, add), 2) それではこれを内側から評価していきましょう。 \u0026lt;\\ は以下のように定義されているのでした。\nfun x \u0026lt;\\ f = fn y =\u0026gt; f (x, y) すると上の式はこうなります。\nop\\\u0026gt;(fn y =\u0026gt; add(1, y), 2) 次に \\\u0026gt; です。これは以下のように定義されているのでした。\nfun f \\\u0026gt; y = f y すると上の式はこうなります。\n(fn y =\u0026gt; add(1, y)) 2 これを簡約するとこうなる訳です。\nadd(1, 2) ちゃんと、関数適用に簡約されましたね。 \u0026lt;/ と /\u0026gt; も開と閉の役割が入れ替わるだけなので気になる人は各自で追ってみて下さい。\nさて、これを使うとセクションも実現できます。\nList.map (2\u0026lt;\\op*) list List.map (op- /\u0026gt; 1) list すごい！\n因みに余った \\\u0026gt; と \u0026lt;/ も役割があります。 \\\u0026gt; がHaskellでいう $ 相当で、 \u0026lt;/ がF# でいう |\u0026gt; 相当の演算子です。 ただし優先順位がこちらは3なのに対して $ と |\u0026gt; は1ですが。\nちなみにこの記事にま元ネタがあって、MLtonの中の人が書いた記事です：\nInfixingOperators\nこちらではもう少し色々紹介されています。\nML Advent Calendarの中で他の面白い記事も紹介していけたらなと思います。\n","categories":["SML","ML Advent Calendar","Advent Calendar 2020","Advent Calendar","小ネタ"],"category_urls":["/categories/sml","/categories/ml-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2020-12-03","title":"SMLでバッククォート記法を実現する","url":"https://KeenS.github.io/blog/2020/12/03/smldebakkukuo_tokihouwojitsugensuru/"},
  {"body":"このエントリはIdris Advent Calendar 2020の4日目のエントリです。前はhelloyukiさんで「IdrisにHello World on VSCode \u0026amp; Mac」でした。\nκeenです。今回は基本文法を解説します。\nコメント 1行コメント -- ではじめます。\n例：\n-- これはコメントです 複数行コメント {- から -}\n例：\n{- 複数行で コメントが 書けます -} ドキュメントコメント ||| ではじまる1行コメントです。 詳しくはAdvent Calendarのどこかで紹介したいと思います。\n関数と変数 ドキュメントには書かれてないのですが、コンパイラのコードを見る限り識別子に使えるのは [[:alphabet:]_][[:alphanum:]'_.]* のようです。 ここで [:alphabet:] に入るのはUnicodeでAlphabeticなもので、[:alphanumeric:] は Alphabetic + Numeric全般のようです。 例えば hog'.'e12_ や 漢字の識別子１ は適格なIdrisの変数です。\nグローバル変数 変数は以下の構文で定義します。\n名前 : 型 名前 = 式 例：\nversion : Integer version = 100 関数 関数は以下の構文で定義します。\n名前 : 型 名前 引数1 引数2 .. 引数n = 式 関数の型は 引数1の型 -\u0026gt; 引数2の型 -\u0026gt; 引数2の型 -\u0026gt; 返り値の型 です。\n例：\nadd : Integer -\u0026gt; Integer -\u0026gt; Integer add x y = x + y 変数や関数はcamelCaseの命名が慣例です。 コンパイラ側でも先頭に小文字がきたら変数と思って処理している箇所があるようです。\nローカル変数 let 変数 = 式 in 続く式 の構文で定義します。\n例：\nadd3 : Integer -\u0026gt; Integer -\u0026gt; Integer -\u0026gt; Integer add3 x y z = let tmp = x + y in tmp + z 他にも式の後ろに where を続けて書く記法もあります。\n例：\nadd3 : Integer -\u0026gt; Integer -\u0026gt; Integer -\u0026gt; Integer add3 x y z = tmp + z where tmp : Integer tmp = x + y Idrisは オフサイドルールを採用しているのでインデントが同じなら同じブロックとみなしてくれます。 where のあとに続く定義はインデントを揃えれば複数書けます。\nローカル関数 where の記法で定義できます。\n例：\nisLeapYear : Integer -\u0026gt; Bool isLeapYear y = isM4 y \u0026amp;\u0026amp; not (isM100 y) \u0026amp;\u0026amp; isM400 y where isM4 : Integer -\u0026gt; Bool isM4 y = y `mod` 4 == 0 isM100 : Integer -\u0026gt; Bool isM100 y = y `mod` 100 == 0 isM400 : Integer -\u0026gt; Bool isM400 y = y `mod` 400 == 0 無名関数 \\引数 =\u0026gt; 式 の構文で作れます。\nquatro: Integer -\u0026gt; Integer quatro n = let double = \\i =\u0026gt; i * 2 in double (double n) 制御構造 if if 式は if 条件 then then節 else else節 の構文をしています。\n例：\nif n == 0 then \u0026#34;Zero\u0026#34; else \u0026#34;Not zero\u0026#34; Idrisは式指向言語なので if も値を返します（なので if 「式」と呼ばれます）。 他の言語でいういわゆる三項演算子のようなものは必要ありませんん。\nmain : IO () main = putStrLn (if 1 == 0 then \u0026#34;Zero\u0026#34; else \u0026#34;Not zero\u0026#34;) パターンマッチ パターンマッチは case 条件 of パターン =\u0026gt; 式 ... の構文をしています。 パターン =\u0026gt; 式 の部分にはオフサイドルールが適用されます。\n例：\ncase n of 1 =\u0026gt; \u0026#34;one\u0026#34; 2 =\u0026gt; \u0026#34;two\u0026#34; 3 =\u0026gt; \u0026#34;three\u0026#34; _ =\u0026gt; \u0026#34;many\u0026#34; 最後の _ は特殊なパターンで、どんな値にもマッチしてその値を無視します。\nパターンマッチはもうちょっと複雑なこともできます。 値の構造がパターンに合致すればマッチ成功となります。 さらに、その値を変数に束縛できます。\n例：\ncase list of [] =\u0026gt; 0 [x, y] =\u0026gt; x + y [x, y, z] =\u0026gt; x + y + z _ =\u0026gt; -1 これの list が [1, 2, 3] ならば [x, y, z] の節にマッチして x + y + z 、つまり 1 + 2 + 3 が計算されて6が返ります。\n関数の引数でのパターンマッチ 関数の引数でもパターンマッチが可能です。 関数の名前を連ねる形になります。\n例：\nfib: Int -\u0026gt; Int fib 0 = 1 fib 1 = 1 fib n = fib (n - 1) + fib (n - 2) ループ、 return 、 break ないよ。\nIdrisは関数型言語なのでループは関数を使います。 自身を呼び出すことでループを作れるのです（再帰関数）。 break や return は必要ありません。自身を呼び出すことをやめれば自然とループが止まりますし、その場で値が返ります。\n例：1 から n までの和を求める関数\nsumFromOne: Integer -\u0026gt; Integer sumFromOne n = loop 1 n 0 where loop: Integer -\u0026gt; Integer -\u0026gt; Integer -\u0026gt; Integer loop i end sum = let sum = sum + i in if i == end then sum else loop (i + 1) end sum loop i end sum = ... ではじまって loop (i + 1) end sum を呼んでいるので i を1つづつ増やしていっているのが読み取れるでしょうか。\nプリミティブ 思ったより少ないです。\n   名前 説明     Int 固定長整数   Integer 多倍長整数   Double 倍精度浮動小数点数   Char 文字   String 文字列   Ptr FFI用    ブール値なんかもありません。 Bool はユーザ定義型として定義されています。\n演算子 Idrisには組み込みの演算子がありません。もうちょっというと演算子というものはありません。 代わりに、関数を中置記法で書けるようにする方法が2つあります。中置演算子を自由に作れる訳ですね。\n1つ目の方法が ` 〜 ` で関数を囲むもの。\n例： 2引数関数を ` 〜 `中置演算子として使う\nadd : Integer -\u0026gt; Integer -\u0026gt; Integer add x y = x + y 1 `add` 2 逆に、中置演算子は () で囲って普通の関数のように使うこともできます。\n(+) 1 2 2つ目の方法が infix 系の構文です。 infix 、 infixl 、 infixr があります。 infixl 4 +,- のように infix 優先順位 演算子1,演算子2.. と書きます。\ninfixl 4 -? prefix 2 -! (-?) : Integer -\u0026gt; Integer -\u0026gt; Integer (-?) x y = x - y (-!) : Integer -\u0026gt; Integer (-!) x = 0 - x -! 1 -? 2 -? 3 -- これは -! ((-?) ((-?) 1 2) 3) と解釈されて4になる データ型 data 名前 = 定義 の構文で定義します。 定義のところには ヴァリアント | ヴァリアント… と書きます。 ヴァリアントには コンストラクタ 引数の型 … と書きます。 ヴァリアントは少なくとも1つ、コンストラクタの引数は0以上を書きます。\n例：引数のないコンストラクタのヴァリアントを2つ持つデータ型\ndata Bool = True | False 例：引数の2つあるコンストラクタのヴァリアントを1つ持つデータ型\ndata Person = MkPerson Int String 引数ありのコンストラクタのヴァリアントを1つ持つデータ型は頻出パターンで、構造体のように使えます。 そのときのコンストラクタが構造体のコンストラクタのようになります。こういうときは MkHoge と Mk （makeの略）を前置するのが慣例です。\n例： 引数のあるコンストラクタや引数のないコンストラクタのヴァリアントのあるデータ型\ndata FizzBuzz = F | B | FB | I Integer データ型は語ることが多いので回を新ためて説明しようと思います。\nまとめ Idrisの基本文法を説明しました。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-02","title":"Idrisの基本文法","url":"https://KeenS.github.io/blog/2020/12/02/idrisnokihonbunpou/"},
  {"body":"このエントリはRust 3 Advent Calendar 2020の2日目の記事です。前回はstnaoさんでRust,Wasm,Dockerで\u0026rdquo;hello world\u0026rdquo;をする MacOs catalinaでした。\nアドベントカレンダー埋まってないところを埋める担当のκeenです。そういえばRustの環境構築の記事を最近みかけないなと思ったので書きます。 それと私がEmacs使いなのでEmacsのセットアップや開発方法なども記します。\nコンパイラのインストール rustupを使います。\n以下のrustup.rsにアクセスしたら出てくるとおり以下のコマンドを叩くだけです。\n$ curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh たまに得体の知れないコマンドシェルスクリプトを直接 sh に流すのを嫌う人がいますが、 そもそも得体のしれないバイナリ（rustコンパイラ）をインストールしようとしてるので気にしすぎでしょう。\nさて、上記コマンドを実行すると以下のようにインストールが走ります。\ninfo: downloading installer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: /home/shun/.rustup This can be modified with the RUSTUP_HOME environment variable. The Cargo home directory located at: /home/shun/.cargo This can be modified with the CARGO_HOME environment variable. The cargo, rustc, rustup and other commands will be added to Cargo\u0026#39;s bin directory, located at: /home/shun/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile files located at: /home/shun/.profile /home/shun/.bash_profile /home/shun/.bashrc /home/shun/.zshenv You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-unknown-linux-gnu default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation 選択肢がでてきますが、そのまま1を選びましょう。\n1を選ぶとさらに進んでコンパイラツールチェーンのインストールがはじまります。\ninfo: profile set to \u0026#39;default\u0026#39; info: default host triple is x86_64-unknown-linux-gnu info: syncing channel updates for \u0026#39;stable-x86_64-unknown-linux-gnu\u0026#39; info: latest update on 2020-11-19, rust version 1.48.0 (7eac88abb 2020-11-16) info: downloading component \u0026#39;cargo\u0026#39; info: downloading component \u0026#39;clippy\u0026#39; info: downloading component \u0026#39;rust-docs\u0026#39; 13.3 MiB / 13.3 MiB (100 %) 10.7 MiB/s in 1s ETA: 0s info: downloading component \u0026#39;rust-std\u0026#39; 22.0 MiB / 22.0 MiB (100 %) 10.7 MiB/s in 2s ETA: 0s info: downloading component \u0026#39;rustc\u0026#39; 66.2 MiB / 66.2 MiB (100 %) 10.3 MiB/s in 6s ETA: 0s info: downloading component \u0026#39;rustfmt\u0026#39; info: installing component \u0026#39;cargo\u0026#39; info: using up to 500.0 MiB of RAM to unpack components info: installing component \u0026#39;clippy\u0026#39; info: installing component \u0026#39;rust-docs\u0026#39; info: installing component \u0026#39;rust-std\u0026#39; 22.0 MiB / 22.0 MiB (100 %) 15.7 MiB/s in 1s ETA: 0s info: installing component \u0026#39;rustc\u0026#39; 66.2 MiB / 66.2 MiB (100 %) 18.1 MiB/s in 3s ETA: 0s info: installing component \u0026#39;rustfmt\u0026#39; info: default toolchain set to \u0026#39;stable-x86_64-unknown-linux-gnu\u0026#39; stable-x86_64-unknown-linux-gnu installed - rustc 1.48.0 (7eac88abb 2020-11-16) Rust is installed now. Great! To get started you need Cargo\u0026#39;s bin directory ($HOME/.cargo/bin) in your PATH environment variable. Next time you log in this will be done automatically. To configure your current shell, run: source $HOME/.cargo/env 最後に、表示されたコマンドを読み込んで現在のシェルで有効にします。\n$ source $HOME/.cargo/env ツールのインストール フォーマッタ、リンタ 公式で配布されているrustfmt（フォーマッタ）とclippy（リンタ）が鉄板です。 インストールは…既に上記の方法でインストールされています。 確認してみましょう。\n$ which rustfmt /home/shun/.cargo/bin/rustfmt $ which cargo-clippy /home/shun/.cargo/bin/cargo-clippy もしインストールされていなかったら下記のコマンドでインストールできます。\n$ rustup component add rustfmt clippy LSPサーバ LSPはマイクロソフトが提唱した言語処理系とエディタ/IDEがやりとりするためのプロトコルです。 ざっくり言うとLSPをサポートしている言語ならEmacsがEclipseやIntelliJ並にリッチな環境になります。\nさて、RustのLSPサーバの状況なのですが、ツールが2つあります。\n1つがrlsで現行の公式推奨のLSPサーバです。\nもう1つがrust-analyzerで、一応実験的な実装とされています。 しかし出来がよく、rust-analyzerを公式のツールにしようとする動きもあります。\nここでは両方のインストール方法を紹介するので好きな方をインストールしてみて下さい。\n因みに私はrust-analyzerを使っています。\nRLS rustupでインストールできます。\n$ rustup component add rls rust-analyzer 毎週バイナリリリースがGitHubに作られるので、そこからダウンロードして使います。\n私はLinux（Ubuntu）使いでかつ、 ~/bin にパスを通しているので以下のコマンドを毎週叩いています。\n$ curl -L https://github.com/rust-analyzer/rust-analyzer/releases/latest/download/rust-analyzer-linux -o ~/bin/rust-analyzer rust-analyzerは毎週更新されるので使う方はGitHubの右上にある[Watch]から[Custom]の[Releases]にチェックを入れて、毎週のリリースの通知を受け取るとよいでしょう1\nその他 cargo install でRust製ツールをインストールできます。\n個人的には cargo-editをよく使っています。\n以下のコマンドでインストールできます。\n$ cargo install cargo-edit あとで紹介するcargo-minor-modeでもサポートがあるのでおすすめです。\nエディタ（Emacs）のセットアップ 私がEmacs使いなのでEmacsのセットアップ方法を紹介します。 因みにRustの開発に一番使われているのはVSCodeらしいです。\n使ってるパッケージは以下です。\n rust-mode: Rustのメジャーモード lsp-mode: 上述のLSPのEmacsサポート。Rustサポートも同梱されます。 lsp-ui: LSPの表示レイヤー cargo: CargoをEmacsから呼び出せるキーバインド  私はuse-packageユーザなので以下のように設定をしています。\n(setq exec-path (cons (expand-file-name \u0026#34;~/bin\u0026#34;) exec-path)) (setq exec-path (cons (expand-file-name \u0026#34;~/.cargo/bin\u0026#34;) exec-path)) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; #rust (use-package rust-mode :ensure t :custom rust-format-on-save t) (use-package cargo :ensure t :hook (rust-mode . cargo-minor-mode)) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; #lsp (use-package lsp-mode :ensure t :hook (rust-mode . lsp) :bind (\u0026#34;C-c h\u0026#34; . lsp-describe-thing-at-point) :custom (lsp-rust-server \u0026#39;rust-analyzer)) (use-package lsp-ui :ensure t) 1つづつ解説していきます。\n(setq exec-path (cons (expand-file-name \u0026#34;~/bin\u0026#34;) exec-path)) ~/bin を exec-path に加えます。私はrust-analyzerをここにインストールしているので必要です。\n(setq exec-path (cons (expand-file-name \u0026#34;~/.cargo/bin\u0026#34;) exec-path)) ~/.cargo/bin を exec-path に加えます。cargoやrustfmtなどをEmacsから使うために必要です。\n(use-package rust-mode :ensure t ; ... ) rust-modeのパッケージを使う宣言です。なければインストールします。\n:custom rust-format-on-save t ファイルを保存する度に rustfmt を適用します。\n(use-package cargo :ensure t ; ... ) cargoのパッケージを使う宣言です。なければインストールします。\n:hook (rust-mode . cargo-minor-mode) rust-mode-hook に cargo-minor-mode を追加します。 これで rust-mode が起動するときは cargo-minor-mode がonになります。\n(use-package lsp-mode :ensure t ; ...) lsp-modeのパッケージを使う宣言です。なければインストールします。\n:hook (rust-mode . lsp) rust-mode-hook に lsp を追加します。 これで rust-mode が起動するときは lsp-mode がonになります。\n:bind (\u0026#34;C-c h\u0026#34; . lsp-describe-thing-at-point) lsp-mode では C-c h に lsp-describe-thing-at-point を割り当てます。\n因みに lsp-rust のデフォルトのLSPバックエンドはrust-analyzerです。 RLSを使う方は :custom (lsp-rust-server 'rls) などの設定が必要になるでしょう。\n(use-package lsp-ui :ensure t) lsp-uiのパッケージを使う宣言です。なければインストールします。\nその他お好みで設定して下さい。\n設定した環境の使いかた 基本編 基本は自動で動いてくれます。ちょっとプロジェクトを作ってテストしてみましょう。\ncargo new でプロジェクトを作ります。\n$ cargo new test-project Created binary (application) `test-project` package プロジェクトをEmacsで開いてみましょう（find-fileで src/main.rs を選択）。 lsp-modeがワークスペースをインポートするか尋いてくるので i と入力してインポートします。\n初回はrust-analyzer/rlsの初期化に少し時間がかかります。\ncargo new で動くプロジェクトが作られているのでcargo-minor-modeのキーバインドを使って走らせてみましょう。\nC-c C-c r です。\n下のウィンドウに \u0026ldquo;Hello world!\u0026rdquo; と表示されていますね。成功です。\nそれではlsp-modeの補完を試してみましょう。 ファイルの先頭に use std::collections::HashMap; と入力しようとしてみて下さい。 するとcompanyで補完がされるはずです。\n次にツールでインストールしたcargo-editを使っていみましょう。cargo-minor-mode経由で使えます。 C-c C-c a RET regex RET と入力してみて下さい。\ncargo-editでインストールされたサブコマンド、 cargo add を使ってパッケージを追加してくれます。 これは Cargo.toml の [dependencies] に regex = \u0026quot;最新のバージョン\u0026quot; を追記する指示です。 どうやらlsp-modeが追記を読み込んでくれないようなので M-x lsp-restart-workspace でリロードしましょう。\n今追加したregexパッケージを使ってみましょう。 let regex = Regex::new(\u0026quot;foo.*\u0026quot;).unwarp(); と入力しようとしてみて下さい。\n補完候補がでてきます。 このうち regex::Regex を選択するとファイルの先頭に use regex::Regex; が自動で追記されます。 なんとオートインポートまでされるんですね。 なんかドキュメントがオーバーレイ表示されて邪魔な場合は M-x lsp-ui-doc-hide とでもしてみて下さい。\n続いて関連関数の new を入力するシーンでももちろん補完されます。\nそれではこれの型検査（cargo check）をしてみましょう。 cargo-minor-modeの C-c C-c k を使います。\n未使用アイテムの警告が出て、エラーが0なのでチェックは通っているようですね。\n発展編 普段の開発では私は以下の機能をよく使います。\n LSPの補完 LSPの定義ジャンプ（M-.）と元の場所に戻る（M-,） LSPのActions（s-l a a） cargo-minor-modeのcheck（C-c C-c k）  Rustの型検査だけやってくれる cargo check を起動する  cargo-minor-modeのcheck（C-c C-c K）  Rustのlinterの cargo clippy を起動する  cargo-minor-modeのtest（C-c C-c t）  テストを走らせる cargo test を起動する  cargo-minor-modeのadd（C-c C-c a）  cargo-editプラグインの依存パッケージ追加コマンド cargo add を起動する  C-c C-c k のあとの M-g M-n/M-g M-p （next-error/previous-error）  Cargoの出したエラーの起きたソースの位置に飛べる   そんなに多くないので簡単に覚えられると思います。 このうち、Actionについて知らないと分からないと思うので説明しておきます。\nLSPにはActionというものがあるようです。 コードの特定の場所にカーソルを合わせたときにLSPサーバがActionを提示できるならそれが表示されます。 例えば変数のリネームなどです。\nrust-analyzerは結構面白いActionを提示してくれます。 例えば以下は match の空の腕の部分にカーソルを合わせた状態です。\n右上に赤字で表示されているようにパターンが足りていないのでエラーになります。 その下に \u0026ldquo;Fill match arms\u0026rdquo; とありますね。これがActionです。\nこのActionを実行してみましょう。マウスを使ってクリックするか、s-l a a と入力すると実行できます。 上の画像はマウスカーソルを合わせたところです。Emacsでもマウス操作ができるんですね。 なお、yasnippetが必要なので yas-minor-mode がonになってるかは確認しましょう。\nActionを適用すると以下のように補完されます。\n今回なmatchに必要な Ok と Err が補完されています。 型までみて賢く動作してくれるんですね。すごいですね。\nあとはこれを埋めてコードを完成させましょう。\n便利ですね。\nまとめ Rustのツール群のインストール方法、Emacsのセットアップ方法、Emacsでの開発環境を紹介しました。\n 毎週のリリースの他に毎晩のプレリリースもあり、そちらも通知されてしまいますが、私は我慢して表示させるがままにしています。 [return]  ","categories":["Rust","Rust Advent Calendar","Advent Calendar 2020","Advent Calendar"],"category_urls":["/categories/rust","/categories/rust-advent-calendar","/categories/advent-calendar-2020","/categories/advent-calendar"],"date":"2020-12-01","title":"Rustの環境構築（Emacs）","url":"https://KeenS.github.io/blog/2020/12/01/rustnokankyoukouchiku_emacs_/"},
  {"body":"このエントリはIdris Advent Calendar 2020の2日目の記事です。前回は依存型のあるHaskellことIdrisってどんな言語？でした。\nκeenです。 Idrisの紹介が済んだので処理系のインストール方法を紹介します。\n処理系 IdrisはIdris 1とIdris 2があります。\n公式で特に言及されてないのですが、1.0を刻んだ1が推奨で、まだ0.2な2が開発版のプレビューと思ってよさそうです。 今回は1のインストール方法を紹介します。\nAdvent Calendarのどこかで2についても紹介するかもしれません。\nインストール Windows/Mac バイナリダウンロードのところからダウンロードすれば動くんじゃないですかね。 Linuxユーザなので詳しくは分かりません。\nUbuntu 公式で推奨されてるのがCabalによるインストールです。 wikiにUbuntuでのインストールが書かれてますが、コマンドがちょっと古いので別の方法を紹介します。\n使ってる環境はUbuntu 20.10です。\nまずcabalをインストールするところは変わりません。\n$ sudo aptinstall cabal-install make ついでに libffi もインストールしておくと便利です。\n$ sudo apt install libffi-dev cabalのバージョンはこうです。\n$ cabal --version cabal-install version 3.0.0.0 compiled using version 3.0.1.0 of the Cabal library cabalは色々と問題が指摘されてきて、CLIが刷新されています。 Idrisのwikiとは違い、3系ならば new- 系コマンドを使うとよさそうです。\n$ cabal new-update $ cabal new-install idris さきほど libffi をインストールした方はFFIを有効にしてビルドしましょう。\n$ cabal new-install -f FFI idris インストールにしばらくかかるので気長に待ちましょう。\n完了すれば ~/.cabal/bin/ にidris系コマンドがイントールされます。\n$ ls ~/.cabal/bin idris idris-codegen-c idris-codegen-javascript idris-codegen-node ~/.caba/bin にパスを通しておきましょう。\n$ echo \u0026#39;export PATH=~/.cabal/bin:$PATH\u0026#39; \u0026gt;\u0026gt; ~/.bashrc $ source ~/.bashrc とかすればよさそうです。\nソースからビルド 以前ブログに書いたのでそちらを参考にしてみて下さい。\nidris環境構築 | κeenのHappy Hacκing Blog\n処理系の起動 前回の記事ではコンパイルコマンドを紹介しました。 今一度Hello Worldをコンパイル、実行してみましょう。\n$ cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026gt; hello.idr main : IO () main = putStrLn \u0026#34;Hello World\u0026#34; EOF $ idris hello_world.idr -o hello_world $ ./hello_world Hello World Idrisには対話環境もあります。 引数を何も与えずに起動すると対話環境が起動します。\n$ idris ____ __ _ / _/___/ /____(_)____ / // __ / ___/ / ___/ Version 1.3.3 _/ // /_/ / / / (__ ) https://www.idris-lang.org/ /___/\\__,_/_/ /_/____/ Type :? for help Idris is free software with ABSOLUTELY NO WARRANTY. For details type :warranty. Idris\u0026gt; 式を与えたらそのまま評価して返してくれるので簡単に動作を確かめたいときは重宝します。\nIdris\u0026gt; 1 + 1 2 : Integer IO系のものは :exec で実行できます。\nIdris\u0026gt; :exec putStrLn \u0026#34;Hello REPL\u0026#34; Hello REPL 他にも色々できることはあるのですが、 細かい使い方は別の記事にゆずることにしましょう。\nまとめ Idrisの処理系のインストール方法を紹介しました。\n","categories":["Idris","Idris Advent Calendar","Advent Calendar","Advent Calendar 2020"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar","/categories/advent-calendar-2020"],"date":"2020-12-01","title":"Idrisのインストール","url":"https://KeenS.github.io/blog/2020/12/01/idrisnoinsuto_ru/"},
  {"body":"このエントリはIdris Advent Calendar 2020の1日目の記事です。\nκeenです。 Idrisのことを知らない人も多いと思うのでIdrisの紹介からはじめていきたいと思います。\nコード例 ひとまずコードを見てみましょう。\nHello World main : IO () main = putStrLn \u0026#34;Hello World\u0026#34;$ idris hello_world.idr -o hello_world $ ./hello_world Hello World FizzBuzz import Data.String data FizzBuzz = F | B | FB | I Integer Show FizzBuzz where show F = \u0026#34;fizz\u0026#34; show B = \u0026#34;buzz\u0026#34; show FB = \u0026#34;fizzbuzz\u0026#34; show (I n) = show n fizzBuzz : Integer -\u0026gt; FizzBuzz fizzBuzz n = case (n `mod` 3, n `mod` 5) of (0, 0) =\u0026gt; FB (_, 0) =\u0026gt; B (0, _) =\u0026gt; F _ =\u0026gt; I n fizzBuzzSeq : Integer -\u0026gt; List FizzBuzz fizzBuzzSeq n = map fizzBuzz [1..n] main : IO () main = do [_, arg] \u0026lt;- getArgs | _ =\u0026gt; putStrLn \u0026#34;prease specify N\u0026#34; let Just n = parseInteger arg | Nothing =\u0026gt; putStrLn \u0026#34;arg must be an integer\u0026#34; for_(fizzBuzzSeq n) (putStrLn . show)$ idris fizz_buzz.idr -o fizz_buzz $ ./fizz_buzz 15 1 2 fizz 4 5 fizz 7 8 fizz 10 11 fizz 13 14 fizzbuzz Idrisとは Idrisとは 型駆動開発 のために設計されたプログラミング言語です。 静的型付きの関数型言語で、コンパイル方式の処理系を持ちます。\n大きな特徴としては型駆動開発のために強力な型、特にプログラミング言語としては珍しい依存型を持つこと、文法がHaskellに似ていることが挙げられます。\n色々キーワードが出てきましたがAdvent Calendarの続きで紹介するとして、ここでは依存型とは何かを紹介します。\n依存型とは 依存型とは項でインデックス付けされた型です（TaPLより）。\nざっくりと言うと型を書く場所に値を書けます。\n例えばこういう関数の実装の型を考えてみましょう。\nfoo True = \u0026#34;True\u0026#34; foo False = 0 引数が True のときに String 型の値を返して、 False のときに Integer 型の値を返しています。 これは大抵の言語では型づけできません1。\nしかしIdrisなら簡単に型付けできます。まさしく「引数が True のときに String 型、 False のときに Integer 型」と記述するだけです。\nfoo: (b: Bool) -\u0026gt; if b then String else Integer foo True = \u0026#34;True\u0026#34; foo False = 0 どうですか？面白くないですか？\nもうちょっとユースケースが分かりやすい例にベクタ型などもあります。 リスト型のようですが、 Vect n a と型引数にその長さ n を保持できます。\n例えばそのベクタを結合する関数 ++ は以下のような型をしています。\n(++) : (xs : Vect m elem) -\u0026gt; (ys : Vect n elem) -\u0026gt; Vect (m + n) elem 長さ m のベクタと長さ n のベクタを結合すると長さ m + n のベクタになるというシンプルですが強力な表明が書けます。\nあるいは要素 n 個を取り出す関数 take は以下のような型をしています。\ntake : (n : Nat) -\u0026gt; Vect (n + m) elem -\u0026gt; Vect n elem n 個取り出すからには n 個以上のベクタを渡さないといけないんですね。\nこのように詳細な制約を書けるのが特徴です。 もう一歩進めるとこの制約を使って数学的な証明を書いたりもできます。 いつかそういった面も紹介していきたいですね。\nまとめ Idrisについてかるーく紹介しました。続く記事でもうちょっと色々紹介できたらなと思います。\n TypeScriptのように型付けできる変態もいますが… [return]  ","categories":["Idris","Idris Advent Calendar","Advent Calendar","Advent Calendar 2020"],"category_urls":["/categories/idris","/categories/idris-advent-calendar","/categories/advent-calendar","/categories/advent-calendar-2020"],"date":"2020-11-30","title":"依存型のあるHaskellことIdrisってどんな言語？","url":"https://KeenS.github.io/blog/2020/11/30/idristtedonnagengo_/"},
  {"body":"このエントリは言語実装 Advent Calendar 2020の1日目の記事です。 次はsisshiki1969さんで「RustでつくるRuby、その後の進捗」です。\nκeenです。 昔からちまちま作ってるSML処理系をブラウザ上で動かすことができたのでその進捗報告です。\nちまちま作ってるSML処理系とはこれのことです。\nKeenS/webml: A Standard ML Compiler for the Web\n今回実装したオンラインコンパイラは以下で試すことができます：\nWebML Online Compiler\nまあ、ブラウザで動くのでここに貼ることもできるんですけどね。\n fun fib 0 = 1 | fib 1 = 1 | fib n = fib (n - 1) + fib (n - 2) val _ = print (fib 10)  Loading the compiler   Error:\n Output:\n   こういうのどうやって作ったの？っていうのを話していけたらなと思います。\n設計 そもそもの話、WebMLはブラウザで動かすために設計、実装されています。 スタートから違うじゃんと思うかもしれませんが、スタートから違うとして、どう違えばいいのかも必要な情報でしょう。 では、ブラウザで動かすための設計とはというと、以下のことに気をつけて書かれています。\n 実装言語にブラウザ上で動く仕組みをもっているものを選ぶ コンパイルターゲットにブラウザ上で動く仕組みをもっているものを選ぶ コンパイル中にファイルや外部プロセスに依存しない コンパイル結果やランタイムがWebでも動くように配慮する  2以外はemscriptenでゴリ押しするという手もあるのですが、色々な理由で私は選択肢から外しました。\nemscriptenを選択肢から外すとWeb上で言語を動かす仕組みはJavaScriptかWebAssembly（WASM）になります。 私はWASMに全振りする選択をとりました。というかWASMで遊ぶためにこのプロジェクトをはじめました。\nというのを踏まえて上記の条件をWebMLにあてはめてみましょう。\n実装言語 Rustで書きました。 RustはWASMへのコンパイルターゲット（wasm32-unkonwn-unknown）をもっているので容易にブラウザ上で動かすことができます。\nWebMLを始めた頃はまだ実験的機能扱いでしたが、今やRustがWASMを使うときの最有力候補になっています。\nコンパイルターゲット WASMを選びました。 これは前述のように「WASMをターゲットにするコンパイラを作ればブラウザ上でコンパイルできるのでは」というアイディアに基いて始めたプロジェクトなので当たり前っちゃ当たり前ですね。\nコンパイルプロセス 全てメモリ内で完結するようにしました。 ここでネックになるのがアセンブラです。 WASMアセンブラはbinaryenなどの公式CLIツールが配られてますが、CLIツールなので外部プロセスを起動しなければなりません。さらに入力も出力もファイルです。 しかしながらブラウザ上で外部プロセスやファイルなどは扱えません。\n仕方ないので全てメモリ内で完結するWASMアセンブラ、WebAssembler-rsを作りました。WASMが正式勧告になる前から作ってたので途中でバイナリフォーマットが変わって泣きの目をみたなんて開発秘話もあります。\nWebで動くオブジェクトやランタイム まあ、要するに libc に依存しないようにすればいいわけです。\nランタイムはいくつかのパーツに分かれます。GCと標準ライブラリ。 GCと標準ライブラリさえどうにかすれば吐いたバイナリはそれらだけに依存するように作れば話は済みます。 なのでGCと標準ライブラリをどうするかが問題です。\nGC GCはRustで書いてWASMにコンパイルしています。 ただしlibcを使えないので #![no_std] にして、intrinsicのmemory_growやmemory_sizeを使ってイチからメモリ管理しようとしています。…が実態は実装がおいついてなくてゴミを回収しない、いわゆるZeroGCになっています。\n私は過去にWASM生書きでGCを実装したことがあるのですが、アロケータAPIとかの兼ね合いで流用はできないので再実装することになる見込です。\n標準ライブラリ 標準ライブラリはWASMで表現できるもの（+ など）はコンパイラの組み込みにして、それ以外はFFIとして実装しています。 FFIはWASMの import の仕組みを利用して実装されています。 print を例に採ると prelude.sml で以下のように定義されています。\nfun print x = _externcall(\u0026#34;js-ffi\u0026#34;.\u0026#34;print\u0026#34;: (int) -\u0026gt; unit)(x) そしてブラウザ上で動かすときに以下のようにして print の実装を与えています。\nlet buffer = compile_string(str).buffer; let importObj = { \u0026#34;js-ffi\u0026#34;: { print: showOutput }, // ... }; WebAssembly.instantiate(buffer, importObj) SML側で型さえ与えられれば実行時に自由にJS側で実装を与えられるので print も簡単に実装できてしまえます。 ついでにいうと print をどう実装するかに裁量が残るので今回のようにページ内に結果を出力するなんてこともできます。\nオンラインコンパイラの実装のためにしたこと 上記のようなコンパイラの設計をしたとして、オンラインコンパイラの実装のためにやったことを書いておきます。\n コンパイラをWASMにコンパイル ブラウザでリンクする仕組みの開発 WASMをサーバやブラウザ内から取得して実行  コンパイラをWASMにコンパイル ちょっとWASMがごちゃごちゃするのでIとTの記法を使って状況を説明します。\n以下のような図を書いたときに\n+-----+----------+--------+ | src | compiler | target | +-----+----------+--------+ | runtime | +----------+ runtime上で動くcompilerを使ってsrcからtargetに変換するということを表わします。\nまた以下のような図を書いたときに\n+--------+ | code | +--------+ | interp | +--------+ interpを使ってcodeを解釈するということを表わします。\nこれらの記法を使うと、以前は以下のような状況でした。\n+------------+-------+---------------+ | webml(src) | rustc | webml(x86_64) | +------------+-------+---------------+ | OS | +-------+ +---------------+-------+----------------+ | webml-rt(src) | rustc | webml-rt(wasm) | +---------------+-------+----------------+ | OS | +-------+ +-----+-------+------+ | SML | webml | WASM | +-----+-------+------+ | OS | +-------+ +-----------------+ | WASM + webml-rt | +-----------------+ | browser | +-----------------+ | OS | +-----------------+ 手元のPC上で動くWebMLコンパイラを使って事前にSMLのコードをコンパイルしておき、それをブラウザにロードしていました。\n今回のオンラインコンパイラの実装でコンパイラもブラウザ上で動くようになりました。\n+------------+-------+-------------+ | webml(src) | rustc | webml(wasm) | \u0026lt;-- ターゲットがwasmになった +------------+-------+-------------+ | OS | +-------+ +---------------+-------+----------------+ | webml-rt(src) | rustc | webml-rt(wasm) | +---------------+-------+----------------+ | OS | +-------+ +-----+---------+------+ | SML | webml | WASM | +-----+---------+------+ | borwser | \u0026lt;---------------------- ブラウザで動くようになった +---------+ | OS | +---------+ +-----------------+ | WASM + webml-rt | +-----------------+ | browser | +-----------------+ | OS | +-----------------+ ブラウザでリンクする仕組みの開発 上を見てもらったら分かるように、WASMとランタイムはそれぞれ別でコンパイルされ、ブラウザ上でリンクしています。 ブラウザ上でWASMファイルをパースしてリンクした新しいWASMファイルを生成するのは骨ですが、幸いにもブラウザ上でWASMモジュールを上手く組み合わせる仕組みがあります。\nWASMはブラウザ上ではモジュールという単位で管理されます。 上記例でいうとwebml、webml-rt、SMLのコンパイル結果などがそうですね。 モジュールにはexportsといってJavaScriptから関数のように見えるAPIが生えています。 一方でモジュールを作るときにはimportsといってJavaScriptから関数や値などを渡せます。 これらを使ってexportsとimportsをJavaScriptで繋げてあげることでリンクを実現しています。\n面白いことに、WASMのモジュールのexportsにはメモリ（メモリ全体）もあります。 importsで他のモジュールのメモリを読み込むこともできます。 現時点ではメモリ空間は1つしかないのでモジュールは自分でメモリを作ってexportするかメモリを作らずにimportするかしかありません。 この仕組みを上手く使ってるのがGCです。 GCのモジュールはメモリと alloc 関数をexportしていて、SMLのコードの方でそれらをインポートして使っています。\n冒頭の方で print の例として載せたコードの省略した部分をちゃんと載せるとこうなっています。\nlet buffer = compile_string(str).buffer; let importObj = { \u0026#34;js-ffi\u0026#34;: { print: showOutput }, \u0026#34;webml-rt\u0026#34;: { alloc: rtObj.alloc, init: rtObj.init, memory: rtObj.memory }, }; WebAssembly.instantiate(buffer, importObj) importObj にランタイム（rtObj） のメモリ（memory）や alloc 関数を渡しています。\nWASMを取得して実行 WASMを取得して実行するにあたっていくつか解決しないといけない問題がありました\n 謎のセキュリティ機構でロードできない問題 WASMのプリミティブ型以外は受け渡せない問題 WASMのコンパイル/実行  1は未だもって不明です。JavaScriptの文法で import \u0026quot;wasm=_ile.wasm\u0026quot; と書けば自然とロードしてくれるはずだったのですが、MIMEタイプが許可されてないとかでロードエラーが起きました。 どうやらサーバの設定の問題（開発に使ったのはRubyのWEBrickです）のようなのですが、それっぽい設定をしてもダメでした。\n2は問題としては分かりやすいです。WASMには先程説明したとおり、 i32 、 i64 、 f32 、 f64 の型しかありません。 独自定義の構造体はおろか、文字列なども存在しません。もちろん、imports/exportsでもこれらの型しか扱えません。 これでは今回のように文字列を渡してコンパイルしてもらってバイト列を返してもらうような関数を定義できません。 これには一応解決策があります。メモリはJavaScriptから読めるのでポインタだけ関数の引数でやりとりして、実データメモリ経由でやりとりする方法で解決できます。 とはいえ、これを1つ1つやるのは人間のやることではないので自動でやってくれる仕組みを導入します。\n3はまあ分かりやすいです。JS APIの WebAssembly を実行するだけです。 ただし（ロードやコンパイルに時間がかかることを想定して）APIが非同期に設計されているので少しだけ面倒です。\n3は言ってしまえばやるだけなので1、2の解決策だけ紹介します。とはいってもツールを使うだけですが。\nwasm-bindgen/wasm-pack wasm-bindgenがRustとWASMの橋渡しをするためのRustライブライで、wasm-packがRustのコードをブラウザで扱いやすいようにビルドしてくれるビルドツールです。 おおむねwasm-bindgenが2を、wasm-packが1、2を解決してくれます。\nwasm-bindgen 使い方はシンプルです。 WASMビルドの際にJS側に晒したいAPIに #[wasm_bindgen] を付与するだけです。 今回の私のコンパイラではこのようなコードを書きました。\n#[cfg(target_arch = \u0026#34;wasm32\u0026#34;)]usewasm_bindgen::prelude::*;#[cfg(target_arch = \u0026#34;wasm32\u0026#34;)]#[cfg_attr(target_arch = \u0026#34;wasm32\u0026#34;, wasm_bindgen)]pubfn compile_string(input: String)-\u0026gt; Result\u0026lt;Vec\u0026lt;u8\u0026gt;,JsValue\u0026gt;{letmutprelude=include_str!(\u0026#34;../ml_src/prelude.sml\u0026#34;).to_string();prelude.push_str(\u0026amp;input);letconfig=Config::default();compile_str(\u0026amp;prelude,\u0026amp;config).map_err(|e|format!(\u0026#34;Compile failed: {}\u0026#34;,e).into())} 関数の返り値に Result を指定したかったら Result\u0026lt;Vec\u0026lt;u8\u0026gt;, JsValue\u0026gt; のように Err 側に必ず JsValue を指定しないといけないだとか、いくつかのデータ型はJSに渡せないなどの制約はありますがおおむね素直に動いてくれます。\nwasm-pack こっちも使い方はシンプルです。Cargoの代わりに wasm-pack を使ってビルドします。\n$ wasm-pack build --target web wasm-packにはいくつかビルドモードがありますが、私はnpmツール群を避けて通りたいのでピュアなWeb向けの成果物を出してくれる web を選択しています。デフォルトでは bundler になっています。\nビルドが終わると pkg/ 以下にいくつかのファイルが生成されます。\n$ ls pkg README.md package.json webml.d.ts webml.js webml_bg.wasm webml_bg.wasm.d.ts このうちブラウザ上では webml.js のみをロードすればよいことになっています。 *.wasm が本体、*.ts は（TypeScript向けの）補助ファイル、 *.js がWASM \u0026lt;-\u0026gt; JSのグルーコードです。\nグルーコードについて言及しましょう。 例えば今回の compile_string は webml.js で以下のように定義されています。 wasm.compile_string をラップする形で文字列やバイト列の操作を請け負ってるのが見てとれるかと思います。\n/** * @param {string} input * @returns {Uint8Array} */ export function compile_string(input) { try { const retptr = wasm.__wbindgen_export_0.value - 16; wasm.__wbindgen_export_0.value = retptr; var ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; wasm.compile_string(retptr, ptr0, len0); var r0 = getInt32Memory0()[retptr / 4 + 0]; var r1 = getInt32Memory0()[retptr / 4 + 1]; var v1 = getArrayU8FromWasm0(r0, r1).slice(); wasm.__wbindgen_free(r0, r1 * 1); return v1; } finally { wasm.__wbindgen_export_0.value += 16; } } ところでこのグルーコドはロード問題なども請け負ってくれます。 コードを読んだところ import でWASMファイルとして読み込むとエラーになりますが、 fetch でバイナリ列として取り出して WebAssembly APIでコンパイルするとエラーにならなようです。\nまとめ ブラウザでコンパイラを動かすためのコンパイラの設計や、その設計をした上でどのようなことをすれば動くのかを紹介しました。\n設計としてはコンパイラやコンパイル結果がWeb上で動くように配慮する必要があります。 実装としてはRustを使って開発した上でwasm-bindgen/wasm-packを使ってコンパイルし、ブラウザ上でランタイムとコンパイル結果をリンクする形になります。\n今回実装したオンラインコンパイラはtextareaの内容をそのままコンパイルしただけでした。 将来aceなどのWebエディタと統合したり1行づつ評価するREPLを作ったりをやっていきたいですね。\n付録 A: WebAssemblyとは ここまで話題に出てきたWebAssemblyとは何かという話を軽くします。\nWebAssemblyはブラウザ上で（も）動く言語です。 2019年12月にW3C正式勧告となり主要ブラウザで実装されています。 フォーマットはバイナリで、スタックマシンです。 機械語を直接ブラウザで動かせる仕組みと勘違いしてる人がたまにいますが、名前に反してアセンブリではありません。 中間言語、JVMでいうバイトコードのようなポジションですね。\n以下のような見た目をしています。\n(module (func $i (import \u0026#34;imports\u0026#34; \u0026#34;imported_func\u0026#34;) (param i32)) (func $new_page (grow_memory (i32.const 3)) (call $i)) (func (export \u0026#34;exported_func\u0026#34;) (i32.const 42) (call $new_page) (call $i)) (memory 1 10)) モジュールや関数などがあり、機械語とは程遠いですね。\nWebAssemblyの生い立ち  CをJavaScriptにコンパイルするempscriptenが登場する どうせ機械生成ならと、特殊記法で高速に実行できるasm.jsが登場する  JavaScriptのサブセットなのでasm.jsをサポートしてないブラウザでも動く  asm.jsは実行は高速だがロードが遅い問題があった JavaScriptの文法を捨ててバイナリにしたらコンパクトになってダウンロードもパースも速くなるんじゃね？ →WebAssemblyの誕生  その生い立ちから、まずはC/C++ to WASMのコンパイラを満足に書ける程度の仕様が策定されました。 つまり、最小限のWASMはJavaScriptに表現力で勝ることはないです。 じゃあ何故WASMを選ぶのかというと1つはバイナリが動いて面白いから。もう1つが将来への期待です。\n最小限のWASMはJavaScriptに及ばないのですが、その後の方向性としてJSにはないSIMDやスレッドなどのAPIが足される予定です。\nRoadmap - WebAssembly\nそういった意味で将来が期待されるプロジェクトです。\nWebAssemblyの使いどころ 基本的にはブラウザで速度が欲しいときに使います。 例えばゲームエンジンのUnityはWebAssemblyへの出力が可能です\nあとはブラウザで動く関係上サンドボックス機構がついてるのでそれを利用するケースがあります。 Kebernetes上でDockerコンテナの代わりにWASMを動かすだとか。 名前に反してブラウザで動くとは限らないんですね。\nコンパイルターゲットとしてのWebAssembly ブラウザで動かすにしてもJavaScriptやemscripten経由じゃだめなの？という疑問に答えておこうと思います。\n1つはセマンティクスの問題。 WebAssemblyには数値型が i32 、 i64 、 f32 、 f64 と4つあります。 一方でJavaScriptの数値型はnumber と BigInt のみです。 Cのような32bit整数型がJavaScriptにないんですね。 なのでCの 1 + 1 を素直に 1 + 1 にコンパイルできないのです。 これはJavaScriptに限らず高級言語から高級言語にコンパイルすると常にこういったセマンティクスの違いの問題がつきまといます。 なので比較的低級で意味論も素直なWebAssemblyにコンパイルするのは理に適っています。\n1つは利用ケース。 上で紹介したように、WebAssemblyはブラウザ以外でも利用例があります。 なんなら、ローカルマシンで実行できるバイナリを吐くコンパイラもあります。「ポータブルなバイナリフォーマット」としてのWebAssemblyは価値があります。\n1つはWebAssemblyでしかできないことを狙って。 先程言及したように、将来WebAssemblyでしかできない機能が導入される予定です。 そういったものを見越してWebAssemblyを使ってみるのも面白いでしょう。\nemscripten問題 直接JavaScriptにコンパイルするのはつらくても、細かなところまで面倒をみてくれるemscriptenならどうなのという疑問にも答えておきます。 数年前にちょろっと調べたときの記憶で書いてるので色々間違ってるかもしれませんが、当時私がemscriptenでなくWebAssemblyを選んだ理由を書いておきます。\nホスト環境の再現はほしくない emscriptenは既存のコードをそのままWebブラウザで動かせるように色々気を使ってます。 特にlibcもブラウザで動くように再実装しています（ファイルシステムとかも実装されてます）。\nですが私がやりたいのはWeb向けに設計された言語の設計と実装です。 print の例のように裏はそのままJavaScriptと繋がっていてほしいのです。 そういった点で、emscriptenの方向性は私の目指すものと違いました。\nバイナリサイズが大きい 上記のlibcを移植してる話に繋がるのですが、バイナリサイズ1がとても大きいです。 Hello Worldをするのにしばらく待たされるくらい重いです。 一方でWebMLのランタイムとHello Worldをコンパイルした程度のコードなら両者合わせても1KiBにも満たないサイズなのでロードは一瞬です。\nゲームのようにそもそも重いものを動かすなら我慢できるかもしれませんが、私のようにちょろっと動くプログラミング言語を作るのには向いてなさそうでした。\nカスタマイズ性が分からなかった チュートリアルをやって少しだけ調べた状態での印象です。 puts(\u0026quot;Hello, World\u0026quot;); するとアラートで画面にメッセージが表示されたりと期待しない挙動をよくしていました。 また、特定のAPIを叩くと勝手にロード、実行される仕組みになってるのでGCのようにライブラリとして使いたいものの動かし方が分かりませんでした。\nちゃんと調べれば出てくるのでしょうが、前述のいくつかの理由もあいまってそこまで調べずにあきらめてしまいました。\n現時点ではWebAssembly周りのエコシステムが発達してきているのでemscriptenは使わなくてよかったのかな、と振り返ってます。\nB: オンラインコンパイラのコード \u0026lt;div\u0026gt; \u0026lt;form id=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;textarea id=\u0026#34;program\u0026#34; cols=\u0026#34;25\u0026#34; rows=\u0026#34;10\u0026#34;\u0026gt; fun fib 0 = 1 | fib 1 = 1 | fib n = fib (n - 1) + fib (n - 2) val _ = print (fib 10) \u0026lt;/textarea\u0026gt; \u0026lt;button id=\u0026#34;button\u0026#34; type=\u0026#34;button\u0026#34; disabled\u0026gt;Loading the compiler\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div id=\u0026#34;error\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Error:\u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;error-message\u0026#34;, class=\u0026#34;message-box error\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;output\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;output-message\u0026#34; class=\u0026#34;message-box correct\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .message-box { padding: 5px; } .correct { background: #eeeebb; } .error { background: #eebbbb; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { default as compilerInit, compile_string } from \u0026#39;https://KeenS.github.io/webml/compiler/webml.js\u0026#39;; import { default as rtInit } from \u0026#39;https://KeenS.github.io/webml/compiler/webml_rt.js\u0026#39;; let input = document.getElementById(\u0026#34;program\u0026#34;); let output = document.getElementById(\u0026#34;output\u0026#34;); let outputMessage = document.getElementById(\u0026#34;output-message\u0026#34;); let error = document.getElementById(\u0026#34;error\u0026#34;); let errorMessage = document.getElementById(\u0026#34;error-message\u0026#34;); let button = document.getElementById(\u0026#34;button\u0026#34;); function showOutput(str) { outputMessage.innerHTML = str; output.style.display = \u0026#34;inline\u0026#34;; errorMessage.innerHTML = \u0026#34;\u0026#34;; error.style.display = \u0026#34;none\u0026#34;; } function showError(str) { outputMessage.innerHTML = \u0026#34;\u0026#34;; output.style.display = \u0026#34;none\u0026#34;; errorMessage.innerHTML = str; error.style.display = \u0026#34;inline\u0026#34;; } async function init() { let [compilerObj, rtObj] = await Promise.all([ compilerInit(), rtInit() ]); function compileAndRun(str, output) { try { let buffer = compile_string(str).buffer; let importObj = { \u0026#34;js-ffi\u0026#34;: { print: showOutput }, \u0026#34;webml-rt\u0026#34;: { alloc: rtObj.alloc, init: rtObj.init, memory: rtObj.memory }, }; WebAssembly.instantiate(buffer, importObj) .catch(err =\u0026gt; showError(\u0026#34;Browser returned an error: \u0026#34; + err)) } catch (e) { showError(e) } } return compileAndRun; } init().then(compileAndRun =\u0026gt; { button.removeAttribute(\u0026#34;disabled\u0026#34;); button.onclick = arg =\u0026gt; compileAndRun(input.value, output); button.innerHTML = \u0026#34;Run\u0026#34;; }); \u0026lt;/script\u0026gt;   .message-box { padding: 5px; } .correct { background: #eeeebb; } .error { background: #eebbbb; }  import { default as compilerInit, compile_string } from 'https://KeenS.github.io/webml/compiler/webml.js'; import { default as rtInit } from 'https://KeenS.github.io/webml/compiler/webml_rt.js'; let input = document.getElementById(\"program\"); let output = document.getElementById(\"output\"); let outputMessage = document.getElementById(\"output-message\"); let error = document.getElementById(\"error\"); let errorMessage = document.getElementById(\"error-message\"); let button = document.getElementById(\"button\"); function showOutput(str) { outputMessage.innerHTML = str; output.style.display = \"inline\"; errorMessage.innerHTML = \"\"; error.style.display = \"none\"; } function showError(str) { outputMessage.innerHTML = \"\"; output.style.display = \"none\"; errorMessage.innerHTML = str; error.style.display = \"inline\"; } async function init() { let [compilerObj, rtObj] = await Promise.all([ compilerInit(), rtInit() ]); function compileAndRun(str, output) { try { let buffer = compile_string(str).buffer; let importObj = { \"js-ffi\": { print: showOutput }, \"webml-rt\": { alloc: rtObj.alloc, init: rtObj.init, memory: rtObj.memory }, }; WebAssembly.instantiate(buffer, importObj) .catch(err = showError(\"Browser returned an error: \" + err)) } catch (e) { showError(e) } } return compileAndRun; } init().then(compileAndRun = { button.removeAttribute(\"disabled\"); button.onclick = arg = compileAndRun(input.value, output); button.innerHTML = \"Run\"; });    厳密にはJavaScriptなのでバイナリではなくテキスト [return]  ","categories":["SML","compiler","言語実装","言語実装 Advent Calendar","Advent Calendar","Advent Calendar 2020"],"category_urls":["/categories/sml","/categories/compiler","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-advent-calendar","/categories/advent-calendar","/categories/advent-calendar-2020"],"date":"2020-11-30","title":"自作コンパイラをブラウザ上で動かす","url":"https://KeenS.github.io/blog/2020/11/30/jisakukonpairawoburauzauedeugokasu/"},
  {"body":"# Rust with Fearless Concurrency ---------------------- === # About Me --------- ![κeenのアイコン](/images/kappa2_vest.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * GitHub: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # Rust with Fearless Concurrency --------------------------------- * 前半Rustの紹介 * 後半RustのFearless Concurrencyについて Note: 普段のRustのイントロだと言語機能の紹介だけで50分まるまる使う。 今回はConcurrencyに言及してほしいという依頼だったので言語機能の紹介が少なめ === # Rustとは ------------ * 比較的最近できた **システムプログラミング言語** + 2015年に1.0リリース + C/C++並に[速い](https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fastest.html) * システムソフトウェアを作るのに便利 + [OS](https://redox-os.org), [ブラウザ](https://servo.org), [DB](https://www.influxdata.com/blog/announcing-influxdb-iox/)など * Rustは「安全」 + 未定義動作がない === # Rustは安全 ------------ * ざっくり言うとC/C++でいう未定義動作がない * メモリ安全 + Null PointerやDangling Pointerなど発生しない機構 + FYI: [「Chrome」の深刻なセキュリティ脆弱性、70％はメモリー安全性の問題](https://japan.zdnet.com/article/35154338/) * データ競合がない + 今日の後半の話 * などなど === # 安全である価値 ---------------- * 重要なパーツからRustに置き換えられていく流れがきている * マイクロソフトがWindowsのコンポーネントの一部にRustを使うことを[検討](https://msrc-blog.microsoft.com/2019/11/07/using-rust-in-windows/) * Amazonのセキュリティコンテナの実装に[使われてる](https://github.com/firecracker-microvm/firecracker/) * Rust製TLSライブラリの監査の結果[高評価](https://github.com/ctz/rustls/blob/master/audit/TLS-01-report.pdf) * cURLにRustバックエンド追加の[計画](https://www.abetterinternet.org/post/memory-safe-curl/) + ついでに↑のRust製TLSライブラリも === # Hello, Rust -------------- [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=811e91c9fd9230f2c2d1db1182abe1ac) ``` rust fn main() { println!(\"Hello, Rust\"); } ``` === # FizzBuzz ---------- [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=7e5653ef7b1b7fb2cb292ed22f448d56) ``` rust fn fizz_buzz(n: u64) { for i in 0..n { match (i % 3, i % 5) { (0, 0) = println!(\"FizzBuzz\"), (0, _) = println!(\"Fizz\"), (_, 0) = println!(\"Buzz\"), _ = println!(\"{}\", i), } } } ``` === # Sum? ------ [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=3eda2f981b8a001d791983e912f468cb) ``` rust fn sum(vec: Vec) - i64 { let result = 0; for e in vec { result += e; } return result; } ``` === # Sum ------ [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=0f6bfff337d14d071e309052ee1f01f9) ``` rust fn sum(vec: Vec) - i64 { let mut result = 0; for e in vec { result += e; } return result; } ``` === # Sum! ------ [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=8c040eb82c4c117d103f211bf109c17e) ``` rust fn sum(vec: Vec) - i64 { vec .into_iter() .fold(0, |e, acc| e + acc) } ``` Note: returnがない === # Rustの特徴 ------------ * MLやHaskellなどの関数型言語から影響を受けた + 変数が不変だったり式指向だったり + 代数的データ型とパターンマッチなど * `obj.method()` などの構文はあるが、クラスがない * メモリを自動で管理しつつもGCなどのランタイムがない === # 構造体 --------- * クラスと継承はない + 継承は最近はアンチパターンとされつつある（要出典） ``` rust struct Point { x: f32, y: f32, } struct Rectangle { top_left: Point, bottom_right: Point, } ``` === # 構造体のメモリレイアウト -------------------------- ポインタを挟まず `f32` が4つ並ぶ ``` text Rectangle +-----+-----+-----+-----+ | f32 | f32 | f32 | f32 | +-----+-----+-----+-----+ ``` === # 構造体とメソッドの例 --------------------- ``` rust impl Rectangle { fn space(\u0026self) - f32 { let width = self.bottom_right.x - self.top_left.x; let height = self.top_left.y - self.bottom_right.y; width * height } } let rect = Rectangle { top_left: Point { x: 0.0, y: 0.0 }, bottom_right: Point { x: 200.0, y: 100.0 }, }; rect.space(); ``` === # 列挙型 -------- * 可能な値を列挙できる from [std::net::Shutdown](https://doc.rust-lang.org/std/net/enum.Shutdown.html) ``` rust pub enum Shutdown { Read, Write, Both, } ``` === # 複雑な列挙型 -------- * 列挙子は値を持てる + Javaでいう抽象クラス+継承相当？ from [std::net::IpAddr](https://doc.rust-lang.org/std/net/enum.IpAddr.html) ``` rust pub enum IpAddr { V4(Ipv4Addr), V6(Ipv6Addr), } ``` === # Option --------- * Rustにnullはない + `Option` を使う ``` text //  はジェネリクス enum Option { Some(T), None } ``` === # Optionの利用例 ---------------- [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=bf778a36c19e40b4227c66ae2c8a607a) ``` rust impl UserDb { fn find(\u0026self, id: \u0026u64) - Option { self.db.get(\u0026id) } } match db.find(\u00261) { Some(user) = println!(\"User found\"), None = println!(\"User not found\"), } ``` === # Result -------- * Rustに例外はない + `Result` を使う ``` rust enum Result{ Ok(T), Err(E) } ``` === # Resultの利用例 ---------------- * 「例外が投げられる」という了解的ものだったのが第一級市民となることで扱いやすくなった [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=4e483d5a76a6ba0bf840200921cc07bc) ``` rust let arg = env::args().nth(1); let env = env::var(\"PARAM\"); match (arg, env) { (Some(s), _) = println!(\"Param is given via arg: {}\", s), (_, Ok(s)) = println!(\"Param is given via env: {}\", s), _ = println!(\"No param given \"), } ``` === # 所有権 -------- * 値には唯一の所有者がいる * 変数に代入すると所有権が移る + 関数呼び出しでも [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=83f71af33ce956c6fb222432288eba29) ``` rust let x = vec![1, 2, 3]; let y = x; // \u0026i32 { let x = 1; \u0026x // impl FnMut() - u64 { let mut x = 0; || { x +=1; x } } ``` ``` rust fn inc() - impl FnMut() - u64 { let mut x = 0; move || { x +=1; x } } ``` === # unsafe -------- * Rustの制約を一時的に外すことができる + `unsafe {}` で囲む * `unsafe` ブロックの中ではC並に安全でないことができる + NULL pointerとか色々 === # unsafeなコード --------------- [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2015\u0026gist=6a04ca87dc616a2dfece0aae00e9e981) ```rust use std::ffi::c_void; use std::ptr::null_mut; extern \"C\" { // FFIの関数のプロトタイプ宣言 // 参照とは別のマジのポインタ型 fn free(p: *mut c_void); } fn main() { // unsafeで囲むとやりたい放題 unsafe { // ヌルポが作れる！！ let p: *mut i32 = null_mut::(); // ヌルポに書き込める！！ *p = 1; // freeできる！！ free(p.cast()); // use after freeできる！！ println!(\"{}\", *p); } } ``` === # FFI ----- * Cの関数を呼び出せる * CにAPIを提供できる [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=96f62fd8635f09e4ba1b9eee071c148d) ``` rust use libc::{suseconds_t, time_t}; use std::mem; use std::os::raw::c_int; use std::ptr; // #[repr(C)]をつけることでCと相互運用できる型になる。 // メモリ上の表現がC互換になるというだけで、それ以外は普通のRustの構造体として扱える。 // struct timeval { // time_t tv_sec; /* seconds */ // suseconds_t tv_usec; /* microseconds */ // }; #[repr(C)] #[derive(Debug)] struct Timeval { tv_sec: time_t, tv_usec: suseconds_t, } // struct timezone { // int tz_minuteswest; /* minutes west of Greenwich */ // int tz_dsttime; /* type of DST correction */ // }; #[repr(C)] #[derive(Debug)] struct Timezone { tz_minuteswest: c_int, tz_dsttime: c_int, } extern \"C\" { // 上記で定義した型をFFIの型に使える。 // int gettimeofday(struct timeval *tv, struct timezone *tz); fn gettimeofday(tv: *mut Timeval, tz: *mut Timezone) - c_int; } fn main() { unsafe { // Cによって初期化するメモリは`mem::zeroed`で確保できる。 // もちろん、Rustの構造体の初期化構文も使える。 let mut tv: Timeval = mem::zeroed(); // あるいはNULLを渡したい場合は`ptr::null_mut`も使える。 let tz: *mut Timezone = ptr::null_mut(); let ret = gettimeofday(\u0026mut tv as *mut _, tz); if ret == -1 { println!(\"failure\"); return; } println!(\"{:?}\", tv); } } ``` === # Fearless Concurrency === # Fearless Concurrency ------------------ * Rustではバグの心配なく並行処理が書ける * データ競合が起きない + 借用のおかげ * データの管理者がわかりやすい + 所有権のおかげ * ミスを防ぐAPI設計 * 便利ライブラリなど === # Goとの違い ------------ * Goの「便利なパーツが揃ってる」とは違う * Rustにgoroutineはない + async/awaitみたいに近いものはある * Goにバグを防ぐ仕組みはない + 便利な道具で起きにくくはある * 善し悪しというより設計の違い + システムプログラミング言語vsアプリケーション言語 === # Rustで並行処理 ----------------- * `spawn` 関数でスレッドを作れる + 中身はOSスレッド ``` rust use std::thread; let handler = thread::spawn(|| { // thread code }); handler.join().unwrap(); ``` === # 並行処理とライフタイム ---------------------- * スレッドに渡すデータには `'static` が要求される [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=ab08caa85dc05937a53e862308f11a33) ``` rust use std::thread; let mut x = 0; let handler = thread::spawn(|| { x += 1; }); println!(\"{}\", x); handler.join().unwrap(); println!(\"{}\", x); ``` === # データ競合を防ぐ仕組み ---------------------------- * スレッド間で移動していいデータにはマークがついている + トレイトをマーカとして使う * マーカがついていないデータを送ろうとするとコンパイルエラー * `Rc` などのスレッドセーフでないデータ型にはマーカがついていない === # スレッドとRc -------------- * `Rc` を別スレッドに渡そうとするとコンパイルエラー [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=99b14133ec329cac0511f3d8c6b71918) ``` rust use std::thread; use std::rc::Rc; let x = Rc::new(\"data\".to_string()); let handler = thread::spawn(move || { let x = x.clone(); println!(\"{}\", x); }); println!(\"{}\", x); handler.join().unwrap(); println!(\"{}\", x); ``` === # スレッドとArc -------------- * `Arc` （Atomic reference count）なら別スレッドに渡せる [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=5a09fcd00028b2c26b596371e65d26de) ``` rust use std::thread; use std::sync::Arc; let x = Arc::new(\"data\".to_string()); let y = x.clone(); let handler = thread::spawn(move || { println!(\"{}\", y); }); println!(\"{}\", x); handler.join().unwrap(); println!(\"{}\", x); ``` === # ロック -------- * `Arc` だと値を変更できない * 値を変更するにはアトミック型やロックが必要 * ロック: [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) + Mutexは守る値を明示するスタイル * アトミック型: [`atmoic`](https://doc.rust-lang.org/std/sync/atomic/index.html) === # `Mutex` --------- * `lock` したあとに値を変更できる * `File` と同じく `unlock` はない + ライフタイムが終わったら自動でunlockされる [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=6fc46b52ba35c70eda4c1e791f6fc458) ``` rust use std::thread; use std::sync::{Mutex, Arc}; let x = Arc::new(Mutex::new(\"data\".to_string())); let y = x.clone(); let handler = thread::spawn(move || { let mut lock = y.lock().unwrap(); *lock = \"modified\".to_string(); println!(\"{}\", lock); }); handler.join().unwrap(); let lock = x.lock().unwrap(); println!(\"{}\", x); ``` === # デッドロック -------------- * Rustでもデッドロックは防げない * Rustが防げるのは同じメモリを読み書きして起きるエラー + = データ競合 === # チャネル ---------- * スレッド間でデータを送る仕組み + メモリを共有するよりバグりづらいとされる * Rustでは所有権ごと別のスレッドに送る [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=24c6f7aff9d4241be74fabe5c568b7d1) ``` rust use std::thread; use std::sync::mpsc::channel; // Create a simple streaming channel let (tx, rx) = channel(); thread::spawn(move|| { tx.send(10).unwrap(); }); assert_eq!(rx.recv().unwrap(), 10); ``` === # チャネルとSend ---------------- * `spawn` と同じく `Send` でないデータは送れない [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=66d0da55e9ebbe77ab66c5f4570e28f4) ``` rust use std::sync::mpsc::channel; use std::thread; use std::rc::Rc; let (tx, rx) = channel(); thread::spawn(move || { let rc = Rc::new(1); tx.send(rc.clone()).unwrap(); }); assert_eq!(rx.recv().unwrap(), Rc::new(1)); ``` === # チャネル小話 -------------- * Goのチャネルとは違う + スケジューラが絡まなに * Rustのチャネルはいくつか種類がある + bounded/unbounded + ブロックする/しない === # spawnの中身 --------------- * `spawn` は言語組込み **ではない** + C FFIで呼んでる ``` rust // UNIX系OSの場合 pub struct Thread { id: libc::pthread_t, } ``` + [spawnの中身](https://doc.rust-lang.org/src/std/sys/unix/thread.rs.html#43-91) * 言語組み込みで安全なのではなく、安全に作る仕組みで安全に作ってる + → 他のFFIでもRustを通して使うと安全にすることができる === # コード例 ---------- * IOスレッドを立ててチャネルで書き込むデータを送る [Run](https://play.rust-lang.org/?version=stable\u0026mode=release\u0026edition=2018\u0026gist=b7818e1251990858fe11eaccf2a7351c) ``` rust use std::fmt::Display; use std::io::{prelude::*, stdout}; use std::sync::mpsc::{channel, Receiver}; use std::thread::{self, spawn, JoinHandle}; fn start_writer(rx: Receiver) - JoinHandle { spawn(move || { let stdout = stdout(); let mut out = stdout.lock(); for data in rx { match writeln!(out, \"{}\", data) { Ok(()) = (), Err(e) = { eprintln!(\"Error: {}\", e) } } } }) } fn main() - thread::Result { let (tx, rx) = channel(); let handle = start_writer(rx); if let Err(e) = tx.send(\"hello\") { eprintln!(\"Error while sending: {}\", e) } { let tx = tx; } handle.join()?; Ok(()) } ``` === # 並行性とライブラリ -------------------- * 実際のところ自分でスレッドを作ることはそんなにない + もちろん、場面による * 大抵はライブラリを使う + [rayon](https://crates.io/crates/rayon) など * 生のスレッドよりも非同期プログラミングが主流 + `async` / `await` === # Rayon ------- * Rustの並行プログラミングライブラリ * データ並列を気軽に書ける [Run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=3e4e6f7ddb084666c55ef0e397f81b2f) ``` rust use rayon::prelude::*; fn sum_of_squares(input: \u0026[i32]) - i32 { input.par_iter() // (rx: Receiver) - JoinHandle { spawn(move || { let stdout = stdout(); let mut out = BufWriter::new(stdout.lock()); for data in rx { match writeln!(out, \"{}\", data) { Ok(()) = (), Err(e) = { eprintln!(\"Error: {}\", e) } } } }) } fn main() { let file = env::args().nth(1).expect(\"arg: FILE\"); let re = Regex::new(\"[rR]ust\").expect(\"Regex syntax error\"); let (tx, rx) = channel(); let handle = start_writer(rx); let rdr = csv::Reader::from_path(file).expect(\"failed to open input file\"); rdr.into_records() .par_bridge() .for_each_with(tx, move |tx, rcd| { let rcd = rcd.expect(\"failed to parse line\"); let text = \u0026rcd[5]; if re.is_match(text) { tx.send(text.to_string()).expect(\"failed to send data\"); } }); handle.join().expect(\"thread join error\"); } ``` === # 非同期プログラミング ---------------------- * Rustには `async` / `await` 構文がある + 協調的マルチタスク + スレッドより細かい単位でタスクを管理できる * 言語側は構文だけ提供して、ランタイムはライブラリが担当 + 言語本体はランタイムレスのまま + 組み込みとかでも `async` / `await` が使える === # 同期の問題点 --------------------------- * 他にやりたいことがあってもスレッドが止まる ``` rust fn sync_do() - Result{ write(b\"Hello, \")?; // Result{ // async専用関数 async_write(b\"Hello, \").await?; //  ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2020-11-15","title":"Rust with Fearless Concurrency","url":"https://KeenS.github.io/slide/rust_with_fearless_concurrency/"},
  {"body":"κeenです。めずらしくWebの話題でも。ブラウザ上で音出したいときってどうすればいいんだっけとなって調べた結果です。\nWeb Audio API 個人的にはSVGのオーディオ版の、楽譜っぽいものをテキストで入力したら勝手に音が鳴ってくれるフォーマットをさがしてたのですがみつかりませんでした（辛うじてMusicXMLが近いくらい？）。MIDIとかにも期待したんですがあれはバイナリ\n代わりに、Web Audio APIというのを使えばブラウザ上で音が出せそうというのがみつかりました。\n Web Audio API - Web APIs | MDN  この中の OscillatorNode を使えば手で音が出せそうです。\nOscillatorNode OscillatorNode を使ったサンプルを実装してみたのがこれ（クリックすると大きめの音が鳴ります）。\n▶️ Play  コードは以下。\n\u0026lt;div id=\u0026#34;oscPlayer\u0026#34;\u0026gt;▶\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const audioCtx = new (window.AudioContext || window.webkitAudioContext)(); let oscillator = null; const playButton = document.getElementById(\u0026#34;oscPlayer\u0026#34;); playButton.addEventListener(\u0026#34;mousedown\u0026#34;, function(event) { if (oscillator === null) { playButton.innerHTML = \u0026#34;⏸ Stop\u0026#34;; oscillator = audioCtx.createOscillator(); oscillator.type = \u0026#39;square\u0026#39;; oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // value in hertz  oscillator.connect(audioCtx.destination); oscillator.start(); } else { playButton.innerHTML = \u0026#34;▶️ Play\u0026#34;; oscillator.stop(); oscillator.disconnect(audioCtx.destination); oscillator = null } }, false); \u0026lt;/script\u0026gt; ノードをコネクトしていって有向グラフを作り、音源から audioCtx.destination まで到達できたら音が鳴る仕組みです。 その音源にあたるのが OscillatorNode で、コード中のこの部分で作って実行してます。\noscillator = audioCtx.createOscillator(); oscillator.type = \u0026#39;square\u0026#39;; oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // value in hertz  oscillator.connect(audioCtx.destination); oscillator.start(); 440Hzの矩形波を鳴らしています。440Hzというのはおなじみラの音です。\n音源をstopする手段はあるのですが、一度stopすると再開できないのでこういう再生/停止を繰り返す場合は音源を削除、disconnectするのが常套手段のようです。\n今回は使ってませんが、 OscillatorNode には frequency の他に detune というパラメータがあります。 これは平均律でのセントを指定します。 12音階での隣の音がちょうど100セントで、1オクターブ上がるとちょうど1200セントです。 上記のラが440Hzなのでこれに100セントずつ+-していけば音階を表現できるという仕組みです。\n演奏時間を指定する 周波数と演奏する長さがあればひとまず演奏できそうですね。 上記のAPIで周波数は指定できるようになったので演奏時間を指定するのが目標です。\nOscillatorNode などの AudioScheduledSourceNode の start （と呼応する stop）はオプショナルな引数 when でいつ操作をするか選べるのでそれを使います。 すなわち、1秒演奏するなら start(startTime) と stop(startTime + 1) を呼んであげればいい訳です。 ただし演奏が終わったら disconnect したり null を代入したりする処理が必要になります。そういうのは onended にコールバックで指定できるのでそうします。\nそれを実装したのが以下。\n▶️ Play  コードは以下。\n\u0026lt;div id=\u0026#34;oscPlayer\u0026#34;\u0026gt;▶\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const audioCtx = new (window.AudioContext || window.webkitAudioContext)(); let oscillator = null; const playButton = document.getElementById(\u0026#34;oscPlayer2\u0026#34;); playButton.addEventListener(\u0026#34;mousedown\u0026#34;, function(event) { if (oscillator === null) { playButton.innerHTML = \u0026#34;⏸ Stop\u0026#34;; oscillator = audioCtx.createOscillator(); oscillator.type = \u0026#39;square\u0026#39;; oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // value in hertz  oscillator.connect(audioCtx.destination); // 1秒だけ鳴らしたあとお片付けする  let currentTime = audioCtx.currentTime; oscillator.onended = function() { oscillator.disconnect(audioCtx.destination); oscillator = null } oscillator.start(currentTime); oscillator.stop(currentTime + 1); } else { playButton.innerHTML = \u0026#34;▶️ Play\u0026#34;; oscillator.stop(); oscillator.disconnect(audioCtx.destination); oscillator = null } }, false); \u0026lt;/script\u0026gt; 音量を調整する GainNode というのでできます。 音源とスピーカの間に挟まるエフェクト扱いです。\nこんな感じ（動作例略）\nconst gainNode = audioCtx.createGain(); gainNode.gain.value = 0.025; gain.connect(audioCtx.destination); osc.connect(gain) 演奏する まあ、あとはプログラマなら適当にコード書けば演奏できるようになるでしょう。\n実装したのがこちら。今度はボリュームが調整できます。\n▶️ play   Volume:     コードは後程gistを貼りますが、だいたい以下のようなコードを書いたら演奏できるようになってます。\nconst music = Music.parse(\u0026#34;\\ C C G G | A A G2 |\\ F4 F E E | D D C2 |\\ G4 G F F | E E D2 |\\ G4 G F F | E E D2 |\\ C4 C G G | A A G2 |\\ F4 F E E | D D C2 |\u0026#34;); const player = new Player(90, new SimpleTone(\u0026#39;sine\u0026#39;)); player.playMusic(music) ひとまずやりたいことができました。\nピアノの音色？ ところで、演奏したときの音色気になりませんでしたか？ 正弦波なのでちょっと機械っぽい音色になります。\nしかしあらゆる波は正弦波の組み合わせで表現できますし、ピアノの鍵盤を叩いたときの音の起伏もプログラムで表現できるので今までにでてきた道具でピアノの音色っぽいものも作れます。ちょっと挑戦してみましょう。\nやってみたのがこれです。\n▶️ play   Volume:     どうですか？少なくとも先程の正弦波よりは楽器っぽくきこえないですか？\n実装は以下のようなコードです。\nclass PianoTone extends Tone { createOsc(detune, gain, start, duration, output) { const attack = 0.2; const decay = 0.1; const sustain = gain * 0.7; const release = 0.3; const osc = this.ctx.createOscillator(); osc.frequency.value = this.concertPitch; osc.detune.value = detune; osc.type = \u0026#39;sine\u0026#39;; const gainNode = this.ctx.createGain(); const t0 = start; const t1 = t0 + attack; const t2 = t1 + decay; const t3 = t0 + duration; const t4 = t3 + release; gainNode.gain.linearRampToValueAtTime(gain, t1); gainNode.gain.setTargetAtTime(sustain, t1, decay) gainNode.gain.setTargetAtTime(0, t3, release); osc.connect(gainNode); gainNode.connect(output); osc.onended = function() { osc.disconnect(gainNode); gainNode.disconnect(output); } osc.start(t0); osc.stop(t4); return osc; } play(detune, start, duration, output) { let o1 = this.createOsc(detune - 3600, 0.512, start, duration * 0.064, output); let o2 = this.createOsc(detune - 2400, 0.64 , start, duration * 0.16 , output); let o3 = this.createOsc(detune - 1200, 0.8 , start, duration * 0.4 , output); let o4 = this.createOsc(detune , 1 , start, duration , output); let o5 = this.createOsc(detune + 1200, 0.4 , start, duration * 0.8 , output); let o6 = this.createOsc(detune + 2400, 0.16 , start, duration * 0.64 , output); let o7 = this.createOsc(detune + 3600, 0.064, start, duration * 0.512, output); return { oscs: [o1, o2, o3, o4, o5, o6, o7], stop: function(when) { for(let osc of this.oscs) { osc.stop(when) } } }; } } ポイントは2つ。1つはADSRで、もう1つは複数の波の組み合わせです。 どっちも私は詳しい訳じゃないんですがちょっと解説してみます。\nADSR ADSRはAttack、Decay、Sustain、Releaseの略でそれぞれ立ち上がり、減衰、減衰後の保持、余韻と訳されるようです。\nピアノ的に解釈すると鍵盤に触れてからを叩き終わるまでがAttack、叩いた瞬間から音が落ち着くまでがDecay、鍵盤を押しっぱなしの時間がSustain、鍵盤を離したあとにも鳴ってる時間がReleaseですかね？\n音を作る人はこういうパラメータで音（エンベロープ）を作るらしいです。\n上記のコードでは以下の部分ですね。\nconst attack = 0.35; const decay = 0.2; const sustain = gain * 0.7; const release = 0.3; // ...  const gainNode = this.ctx.createGain(); const t0 = start; const t1 = t0 + attack; const t2 = t1 + decay; const t3 = t0 + duration; const t4 = t3 + release; gainNode.gain.linearRampToValueAtTime(gain, t1); gainNode.gain.setTargetAtTime(sustain, t1, decay) gainNode.gain.setTargetAtTime(0, t3, release); duration が全体の演奏時間（鍵盤に触れてから離すまで）で、そのうち物理特性で attack と decay に使われる時間が決まります。 本当は鍵盤の叩き方で attack の方は変わると思いますがこの人は同じ強さで叩く人と思いましょう。\n波の組み合わせ コードでいうとこの部分です。 detune が1200で1オクターブなので、対象の音の3オクターブ下から3オクターブ上までの音を合成しています。\nlet o1 = this.createOsc(detune - 3600, 0.512, start, duration * 0.064, output); let o2 = this.createOsc(detune - 2400, 0.64 , start, duration * 0.16 , output); let o3 = this.createOsc(detune - 1200, 0.8 , start, duration * 0.4 , output); let o4 = this.createOsc(detune , 1 , start, duration , output); let o5 = this.createOsc(detune + 1200, 0.4 , start, duration * 0.8 , output); let o6 = this.createOsc(detune + 2400, 0.16 , start, duration * 0.64 , output); let o7 = this.createOsc(detune + 3600, 0.064, start, duration * 0.512, output); これは数学的に解釈すればフーリエ変換的に複数の周波数の正弦波を組み合わせてピアノの音色を再現しようとしています。 物理的に解釈すれば固有振動数が倍数関係にあるピアノ線が共鳴するはずなので、それを表現しています。 本当はピアノ線の長さ（音の高さ）で物理特性が変わるはずなのでADSRも変わるはずですが面倒なので無視しましょう。\nまとめ Web Audio APIを使って音を鳴らしてみました。 Web Audio APIは周波数を指定して定音を鳴らす機能しかないので、自分で演奏機能や音色などを再現してみる試みをしました。その過程でADSRや波の合成などを知りました。\n参考文献  Example and tutorial: Simple synth keyboard - Web APIs | MDN Controlling multiple parameters with ConstantSourceNode - Web APIs | MDN エンベロープジェネレータ | Web Audio APIの基本処理 | WEB SOUNDER - Web Audio API 解説 - Web Audio API でピアノの音色に近づけたい | q-Az  付録: コード 今回実装したPlayerのコードはこちらに置いておきます。 楽譜部分を書き換えたら他の楽曲も演奏できるので気に入った方は試してみて下さい。\n ライセンスはMIT/Apache-2.0のデュアルライセンスとします。\n","categories":["JavaScript","Web Audio API"],"category_urls":["/categories/javascript","/categories/web-audio-api"],"date":"2020-11-14","title":"ブラウザ上で音楽を演奏する","url":"https://KeenS.github.io/blog/2020/11/14/burauzauedeongakuwoensousuru/"},
  {"body":"κeenです。重い腰を上げてブログ記事のOGPを設定するようにしたので共有します。\nやりたいこととしてはQiitaのOように記事のタイトルを使った画像を生成し、OGPに設定するというもの。あとTwitterCardも。 TwitterやSlackなどで共有したときに目立ちます。\nウワサのBlawnを触ってみた on @Qiita https://t.co/yv6DC4Mjal\n\u0026mdash; κeen (@blackenedgold) October 23, 2019 \n実はこれには先駆者がいて、@ladicleさんがやっています。\nHugoでもTwitterCard画像を自動生成したい\n最初はこれをそのまま使おうとしたのですが、ふとSVGならもっと簡単にできるのではと試してみた次第です。 どういうことかというと\n 画像のテンプレートは決まっていてテキストを差し替えるだけ SVGはテキストデータなのでテンプレートエンジンで扱える  という観測からブログのメタデータを元にテンプレートエンジンでSVGを生成し、それをInkscapeでPNGに変換してあげればお手軽に画像を作れるのではという発想です。\nデザイン TwitterやFacebookでは600x315、あるいは高解像度に対応したいなら1200x630を使うとよいらしいので1200x630のキャンバスを使ってSVGでデザインします。\nまた、私のブログはHugoを使っているので全ての記事で以下のメタデータが取得できます。\ncategories:[\u0026lt;tag1\u0026gt;, \u0026lt;tag2\u0026gt;, ...]date:\u0026lt;datetime\u0026gt;title:\u0026lt;title\u0026gt; これらを使うことにし、今回のデザインはブログのテーマにあわせてこんな感じにしてみました。 なんかSVGそのまま貼ったら色々とずれてますが御愛嬌。手元では位置とかフォントとかはちゃんとしてます。\n         rdf:RDF dc:formatimage/svg+xml/dc:format /cc:Work /rdf:RDF  Linux κeenのHappy Hacκing Blog Linuxで発表動画を撮る 2020-11-08 動画 SimpleScreenRecorder Shotcut  \n生成 これであとはテンプレートにあてはめるだけです。テンプレートエンジンはRubyのERBを使うことにします。 メンテナンスしやすいようにスタイルを \u0026lt;style\u0026gt; タグに切り出すなどして整理して以下のような形になりました。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;svg width=\u0026#34;1200\u0026#34; height=\u0026#34;630\u0026#34; viewBox=\u0026#34;0 0 1200 630\u0026#34; version=\u0026#34;1.1\u0026#34; id=\u0026#34;svg8\u0026#34; \u0026gt; \u0026lt;defs id=\u0026#34;defs2\u0026#34;\u0026gt; .... \u0026lt;/defs\u0026gt; \u0026lt;metadata id=\u0026#34;metadata5\u0026#34;\u0026gt; \u0026lt;rdf:RDF\u0026gt; \u0026lt;cc:Work rdf:about=\u0026#34;\u0026#34;\u0026gt; \u0026lt;dc:format\u0026gt;image/svg+xml\u0026lt;/dc:format\u0026gt; \u0026lt;dc:type rdf:resource=\u0026#34;http://purl.org/dc/dcmitype/StillImage\u0026#34; /\u0026gt; \u0026lt;dc:title /\u0026gt; \u0026lt;/cc:Work\u0026gt; \u0026lt;/rdf:RDF\u0026gt; \u0026lt;/metadata\u0026gt; \u0026lt;style id=\u0026#34;style11\u0026#34;\u0026gt; .... \u0026lt;/style\u0026gt; \u0026lt;g inkscape:label=\u0026#34;レイヤー 1\u0026#34; inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;layer1\u0026#34;\u0026gt; \u0026lt;rect id=\u0026#34;header\u0026#34; width=\u0026#34;1200\u0026#34; height=\u0026#34;190\u0026#34; x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; ry=\u0026#34;0\u0026#34; style=\u0026#34;fill:#202020;fill-opacity:1;stroke:#1a1a1a;stroke-width:2.99572;stroke-linecap:round\u0026#34; /\u0026gt; \u0026lt;text id=\u0026#34;site-name\u0026#34; class=\u0026#34;site-name\u0026#34; x=\u0026#34;186\u0026#34; y=\u0026#34;120\u0026#34; xml:space=\u0026#34;preserve\u0026#34;\u0026gt;κeenのHappy Hacκing Blog\u0026lt;/text\u0026gt; \u0026lt;text id=\u0026#34;title\u0026#34; class=\u0026#34;title\u0026#34; x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; xml:space=\u0026#34;preserve\u0026#34;\u0026gt;\u0026lt;%= title %\u0026gt;\u0026lt;/text\u0026gt; \u0026lt;text id=\u0026#34;date\u0026#34; class=\u0026#34;date\u0026#34; x=\u0026#34;246\u0026#34; y=\u0026#34;229\u0026#34; xml:space=\u0026#34;preserve\u0026#34;\u0026gt;\u0026lt;%= date %\u0026gt;\u0026lt;/text\u0026gt; \u0026lt;% if tags %\u0026gt; \u0026lt;% tags.each_with_index do |tag, i| %\u0026gt; \u0026lt;text id=\u0026#34;tag\u0026lt;%= i %\u0026gt;\u0026#34; class=\u0026#34;tag\u0026#34; x=\u0026#34;320\u0026#34; y=\u0026#34;229\u0026#34; xml:space=\u0026#34;preserve\u0026#34;\u0026gt;\u0026lt;%= tag %\u0026gt;\u0026lt;/text\u0026gt; \u0026lt;% end %\u0026gt; \u0026lt;% end %\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt; これであとは記事のメタデータを抜き出してテンプレーティングするRubyスクリプトを書くだけ！ …としたかったのですが、2つ問題がありました。\n タグ数が可変長 タイトルが可変長  これらをどう対処したかを紹介します。\nタグ数が可変長問題 SVGはグラフィックなのでHTMLのように自動で配列してくれたりはしません。全部X座標Y座標を与えてあげる必要があります。 ところでタグ数が可変長な（かつ個々のタグの長さも異なる）ので、2つ目以降のタグの置き場が簡単には分かりません。 InkscapeのUI上だったら等間隔に並べるような処理もありますがこれはInkscapeが画像として表示したときの横幅をメモリ内に持っているからできる芸当です。\nではどうしたかというと、Inkscapeを使いました。 実はInkscapeのCLIにはヘッドレスでInkscapeに問合せたり、UI上で操作できることの一部をできたりします。 残念ながちょうど欲しかった等間隔に並べる処理がCLIからできなかったのですが、個々のタグの横幅を取得することは可能です。 さらに、ノードのIDを指定して座標を動かすこともできるのでこれらを使ってどうにかします。 すなわち\n Inkscapeに（座標は仮のまま）画像データを読み込ませてサイズなどを計算させる Inkscapeに各タグのノードの横幅を問い合わせる Inkspaceに各タグのX座標を「前のタグのX座標+前のタグの横幅」にするよう指示を出す (その他の処理もしたあと)PNG画像をエクスポートさせる  という処理をします。\n1., 2.は以下のコマンドで実現できます。\ninkscape file.svg --actions=\u0026#39;select-by-selector:.tag;query-width\u0026#39; 2\u0026gt; /dev/null --actions= に続いてInkscapeに処理させるアクションを指定します。 まずは select-by-selector でタグを表わすノードを全て選択します。 CSSセレクタが使えるんですね。 今回指定しているのは .tag です。複数該当するので複数選択されます。 ちょっとこの辺のCSSの仕様は詳しくないのですが、多分XMLドキュメントに登場した順のはずです。 そして query-width で選択したノード全ての横幅をカンマ区切りで出力します。 あとはこれを受け取ってシンプルに , で分割して浮動小数点数としてパースすればOKです。\n次がそれぞれのタグノードの位置を適切な場所に動かします。 タグはERBでテンプレーティングするときに tag0 、 tag1 、…とIDを振ってあるのでそれを使います。 動かすアクションは transform-translate:x,y です。 これはRuby側で位置を計算して、Inkscapeに指示を出します。\nwidths = さっき取得したタグの横幅たち # 最後のタグの横幅は不要 widths.pop dx = 0 i = 0 actions = \u0026#34;\u0026#34; for width in widths do # タグの間は6px空ける dx += width + 6 i +=1 actions += \u0026#34;select-by-id:tag#{i};transform-translate:#{dx},0;unselect-by-id:tag#{i};\u0026#34; end # このあとこんな感じのことをする # system \u0026#34;\u0026#34;inkscape file.svg --actions=\u0026#39;#{actions}\u0026#39; 2\u0026gt; /dev/null\u0026#34; 都度Inkscapeを起動してもいいのですが、少し起動が重いので全てのタグ分のアクションを用意して最後にまとめてInkscapeに指示を出しています。\nselect-by-id でタグをID指定で選択したあと、都度 unselect-by-id で選択を外しています。 これはselectしたあともう1度selectすると複数選択扱いになるのでunselectしないと以前操作したタグも動いてしまうからです。\nまた、 actionで行なった操作は別途ファイルに保存する操作をしない限り元のSVGには反映されず、Inkscapeのプロセスが終了したら揮発してしまいます。 なのでファイルに上書き保存するかPNGのエクスポートまで一気にやってしまうかですが、今回はPNGのエクスポートまで一気にやってしまう方針をとりました。プロセス起動は少ない方がいいですしね。\nひとまず、タグの問題は解決しました。\nタイトルが可変長問題 実はこれはあんまりちゃんと解決できてないです。\nタイトルが長すぎて横幅に収まりきらない場合に改行が必要になります。SVG側で自動折り返しとかやってくれたら嬉しかったんですが、残念ながら現行の仕様にはなさそうでした。 頑張って自前で折り返しを実装します。\n自前の実装はとてもお粗末なものになりました。 ひとまず改行なしでInkscapeに読み込んで横幅を計算してもらって、はみ出そうだったらタイトルの真ん中あたりに改行文字を入れます。幸いにも改行文字は扱ってくれるようでした。 中にはタイトルが長すぎて3行以上になる記事もあるのでそこは2箇所、3箇所と改行文字を入れています。\nこの処理は禁則とかなんとかを一切無視しているので生成されるタイトルが非常に残念なことになっています。 また「真ん中あたり」を文字数でカウントしてるので横幅の狭いアルファベットと幅広な日本語文字でバランスが取れてないケースもあります。\nさらに改行すると中心位置がずれるので、座標計算も必要になります。これがちょっと面白かったので紹介します。\n今回のテキストにはスタイルで text-align: center を当てています。するとどうやらX座標はテキストオブジェクトの中心がオブジェクトの座標になるらしく、そのままキャンバスの中心を設定するだけでよかったです。 一方でY座標は入り組んでいました。どうやら1行目のbase lineがY座標になるらしく、「中心からテキストオブジェクトの高さの半分だけ上にいったところからさらに1行の高さ分だけ下」のような計算になりました。\nこのあたりのつらさは先程貼ったladicleさんの記事でも書かれていますね。 本当は禁則処理をもうちょっと賢くやりたかったのですが、Inkscapeへの問い合わせが重いので精緻な計算はしづらいだろうということで妥協した実装になっています。\n結果 上記のごちゃごちゃをやってInkscapeにPNGでエクスポートさせるRubyスクリプトを書きました。 結果、以下のような画像ができあがります。\nあとはこれを記事のファイル名とbasenameが同じになるように画像を生成して、Hugoのテンプレート側で対応するOGP用画像があればOGPのメタタグを生成するというようなことをしています。\nこれでよいはずなんですが、どうしてかTwitterでだけプレビューがうまくいきません。 TwitterはTwitterCardという独自のフォーマットなのでなんかその辺が原因かなーと思いつつよく分かってません。\n記事からPNGを生成するまでは自動化できましたが、記事を書いて上記のツールを叩いて…と生成のトリガは手動になっています。なので「半自動生成」でした\n今後 まずは記事書いたら自動でOGP用の画像が生成できるようにしたいですね。\n次は高速化かな？ 今、1画像を生成するのに3〜4回Inkscapeを起動していますがこれを減らしたいです。 多分 inkscape --shell と file-open / file-close とかを上手く組み合わせれば複数の記事の処理の中で1回だけInkscapeを起動するということも可能かもしれません。\nあとは禁則処理ですね。 Inkscapeの扱いが高速化できたら細かな処理も可能になると思うので挑戦したいです。 あるいは libicu とかを触ってみるいい機会かもしれません\nおまけ SVG画像をプレビューする 意外とSVGって画像ビュワーで表示できないんですよね。 でも大丈夫。ブラウザがあります。\n$ firefox file.svg あとはInkscapeに付属の inkview というコマンドでも表示できます。\n$ inkview こっちはInkscapeと同じSVGエンジンを使ってるのでエクスポート画像の仕上がりを事前に確認したいとかのケースでは有用そうです。\nSVGで背景を設定する タグの部分に背景がついてるのに気付きましたか？ 実はこれ、HTMLと違って結構設定するのが難しかったです。 SVGのフィルタのうち、 feFlood で設定できます。 今回の設定は以下のようになっています。\n\u0026lt;filter inkscape:label=\u0026#34;Fill Background\u0026#34; inkscape:menu=\u0026#34;Fill and Transparency\u0026#34; inkscape:menu-tooltip=\u0026#34;Adds a colorizable opaque background\u0026#34; style=\u0026#34;color-interpolation-filters:sRGB;\u0026#34; x=\u0026#34;-0.015\u0026#34; width=\u0026#34;1.03\u0026#34; id=\u0026#34;filter154\u0026#34;\u0026gt; \u0026lt;feFlood result=\u0026#34;result1\u0026#34; flood-color=\u0026#34;rgb(240,240,240)\u0026#34; flood-opacity=\u0026#34;1\u0026#34; id=\u0026#34;feFlood142\u0026#34; /\u0026gt; \u0026lt;feMerge result=\u0026#34;result3\u0026#34; id=\u0026#34;feMerge152\u0026#34;\u0026gt; \u0026lt;feMergeNode in=\u0026#34;result1\u0026#34; id=\u0026#34;feMergeNode148\u0026#34; /\u0026gt; \u0026lt;feMergeNode in=\u0026#34;SourceGraphic\u0026#34; id=\u0026#34;feMergeNode150\u0026#34; /\u0026gt; \u0026lt;/feMerge\u0026gt; \u0026lt;/filter\u0026gt; 蓋を開けてみればなるほどといったところなんですが、Inkscapeで設定した背景が不必要に複雑なXMLになっていて、タグの文字を差し替えたときに背景がついてきてくれないなどのトラブルがありました。 また、 filter に x と width を設定していますがこれがないと長いタグ名のときに横に背景が広がってしまうというよく分からない現象に遭遇しました。今でもなんなのかよく分かってないです。\nInkscapeのCLIでできる操作 actionとverbというのがあるようです。 見た感じactionがCLI向けに用意されたコマンドで、verbがInkscapeのGUIでの処理に対応するコマンドっぽいです。 今Wikiを見たらverbは将来actionに置き換えられると書かれてました。\nひとまずactionは以下のものが定義されています。\n$ inkscape --action-list action-list : Print a list of actions and exit. convert-dpi-method : Import DPI convert method. export-area : Export area. export-area-drawing : Export drawing area. export-area-page : Export page area. export-area-snap : Export snap area to integer values. export-background : Export background color. export-background-opacity: Export background opacity. export-do : Do export. export-dpi : Export DPI. export-filename : Export file name. export-height : Export height. export-id : Export id(s). export-id-only : Export id(s) only. export-ignore-filters: Export ignore filters. export-latex : Export LaTeX. export-margin : Export margin. export-overwrite : Export over-write file. export-pdf-version : Export PDF version. export-plain-svg : Export as plain SVG. export-ps-level : Export PostScript level. export-text-to-path : Export convert text to paths. export-type : Export file type. export-use-hints : Export using saved hints. export-width : Export width. file-close : Close active document. file-new : Open new document using template. file-open : Open file. inkscape-version : Print Inkscape version and exit. no-convert-baseline : Import convert text baselines. object-set-attribute: Set or update an attribute on selected objects. Usage: object-set-attribute:attribute name, attribute value; object-set-property : Set or update a property on selected objects. Usage: object-set-property:property name, property value; object-to-path : Convert shapes to paths. object-unlink-clones: Unlink clones and symbols. open-page : Import page number. query-all : Query \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;width\u0026#39;, and \u0026#39;height\u0026#39;. query-height : Query \u0026#39;height\u0026#39; value(s) of object(s). query-width : Query \u0026#39;width\u0026#39; value(s) of object(s). query-x : Query \u0026#39;x\u0026#39; value(s) of selected objects. query-y : Query \u0026#39;y\u0026#39; value(s) of selected objects. quit-inkscape : Immediately quit Inkscape. select : Select by ID (Deprecated) select-all : Select all. Options: \u0026#39;all\u0026#39; (every object including groups), \u0026#39;layers\u0026#39;, \u0026#39;no-layers\u0026#39; (top level objects in layers), \u0026#39;groups\u0026#39; (all groups including layers), \u0026#39;no-groups\u0026#39; (all objects other than groups and layers, default). select-by-class : Select by class select-by-element : Select by SVG element (e.g. \u0026#39;rect\u0026#39;). select-by-id : Select by ID select-by-selector : Select by CSS selector select-clear : Selection clear select-invert : Invert selection. Options: \u0026#39;all\u0026#39;, \u0026#39;layers\u0026#39;, \u0026#39;no-layers\u0026#39;, \u0026#39;groups\u0026#39;, \u0026#39;no-groups\u0026#39; (default). select-list : Print a list of objects in current selection. system-data-directory: Print system data directory and exit. transform-remove : Remove any transforms from selected objects. transform-rotate : Rotate selected objects by degrees. transform-scale : Scale selected objects by scale factor. transform-translate : Translate selected objects (dx,dy). unselect : Unselect by ID (Deprecated) unselect-by-id : Unselect by ID user-data-directory : Print user data directory and exit. vacuum-defs : Remove unused definitions (gradients, etc.). verb : Execute verb(s). verb-list : Print a list of verbs and exit. window-close : Close the active window. window-open : Open a window for the active document. GUI only. 基本的な処理はできるといったところです。 因みにverbはInkscapeのGUIの個々の操作に対応するので数だけはたくさんあります。\n$ inkscape --verb-list | wc -l 1227 とはいえGUIがないと動かないverbも多いのでCLIから使えるのはそのうちの一部になります。 まあ、 GUI起動してしまえばいいって話もありますが。\n","categories":["Inkscape","SVG","website"],"category_urls":["/categories/inkscape","/categories/svg","/categories/website"],"date":"2020-11-09","title":"Inkscapeを使ってSVGからOGPイメージを半自動生成する","url":"https://KeenS.github.io/blog/2020/11/09/inkscapewotsukattesvgkaraogpime_jiwohanjidouseiseisuru/"},
  {"body":"κeenです。 最近テックイベントに参加するにあたって発表動画を提出する機会があったので使用したツールを紹介します。\n私が使っているのはUbuntu 20.10ですが大抵のLinuxなら同様のことができると思います。 また、今回は右下にワイプで本人が喋ってる様子を出したりはしてません。 人間が口をパクパクさせてるのを見てもしょうがないので。 どうしても人間が口をパクパクさせてる姿が必要な方はスマホで撮って合成するなりして頑張って下さい。\nTL;DL  SimpleScreenRecorder使って録画 (機材の問題で)音声にトラブルがあったのでスマホで録音して Shotcut で音声を合成 ↑普通にFFmpegでもよかったわ  録画 スクリーンショットならGNOME Screenshotがあるのですが、録画ってやったことないなと思ったので探してみたらSimpleScreenRecorderがひっかかりました。\n以下のコマンドでインストールできます。\n# apt install simplescreenrecorder SSRで特に難しいところなく録画できるのですが、私のやった操作を共有します。 私のディスプレイは3840x2160あってそのままだと他人に共有したときに文字が潰れがちなので1920x1080の枠で録画します。 ちょうどスピーカーノートを開いて喋りたかったのでVideo inputをRecord a fixed rectangleにして、そこにスライドをピタリと合わせて撮りました。\n私の場合はブラウザベースのスライドなのでサイズ調整が楽ですが、一般的なスライドツールだと全画面にしないといけないので画面の解像度を落として録画することになるかもしれません。\n機材の問題で私の場合は音声をオフにしてますが、マイク入力もちゃんと録音できるので機材が揃ってればそのまま収録が完了します。\nこの画面あと出力の場所やフォーマットを選ぶ画面、録画画面と続きます。 プレビューとかも見れるので安心して録画できますね。\n最終的には特に圧縮とかされてないmp4ができあがります。\n録音 上手くいけばSSRで全て済むんですが、私の場合はマザボの不具合なのかデバイスドライバが合ってないのか、音声が途切れ途切れだったりノイズが入ったりしてまともに聞き取れるクオリティではありませんでした。 ちょっとPCだけではどうしようもなさそうだったので音声だけスマホで録音して、あとで合成することにしました。\nスマホで適当なアプリ使って録音します。 PCの録画ボタンとスマホの録音ボタンを同時に押す運用で。\n合成 録画と録音が終わったら動画編集ソフトを使って合成します。 Linuxで使えるツールはいくつかあるようなのですが、Shotcutを選びました。\n以下のコマンドでインストールできます\n# apt install shotcut 使用中の画面がこちら。\ncurrent status pic.twitter.com/fSjEgZVXcH\n\u0026mdash; κeen (@blackenedgold) October 31, 2020 \n画面下にあるタイムラインにトラックを追加することで色々なメディアファイルを合成できます。\nファイルを開く→タイムラインにトラックを追加→「＋」ボタンで開いたファイルをトラックに追加でメディアを追加できます。今回はシンプルに動画と音声の合成なので映像トラック（画面中V1）と音声トラック（画面中V2）の2つがあります。\n動画編集ソフトなのでもちろん切り抜いたりなんたりできますが、ただの発表動画なら難しいことは必要ないでしょう。\n最後に「書き出し」で動画を作って完成です。 ちょっと分かりづらいんですが、動画の書き出しはジョブとしてバックグラウンドで動いてるっぽくてパッと見ボタンを押しても何も動いてないように感じるので注意です。\nFFmpeg 私の場合は動画編集ソフトの練習もしたかったのでShotcutを使いましたが、単純に音声と動画を合成したいだけならFFmpegで十分でしたね。\n以下のコマンドでインストールできます。\n# apt install ffmpeg 使い方も簡単で、録画と録音をインプットファイルに指定するだけです。\n$ ffmpeg -i video.mp4 -i audio.m4a output.mp4 ffmpeg version 4.3.1-4ubuntu1 Copyright (c) 2000-2020 the FFmpeg developers built with gcc 10 (Ubuntu 10.2.0-9ubuntu2) configuration: --prefix=/usr --extra-version=4ubuntu1 --toolchain=hardened --libdir=/usr/lib/x86_64-linux-gnu --incdir=/usr/include/x86_64-linux-gnu --arch=amd64 --enable-gpl --disable-stripping --enable-avresample --disable-filter=resample --enable-gnutls --enable-ladspa --enable-libaom --enable-libass --enable-libbluray --enable-libbs2b --enable-libcaca --enable-libcdio --enable-libcodec2 --enable-libdav1d --enable-libflite --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgme --enable-libgsm --enable-libjack --enable-libmp3lame --enable-libmysofa --enable-libopenjpeg --enable-libopenmpt --enable-libopus --enable-libpulse --enable-librabbitmq --enable-librsvg --enable-librubberband --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libspeex --enable-libsrt --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx265 --enable-libxml2 --enable-libxvid --enable-libzmq --enable-libzvbi --enable-lv2 --enable-omx --enable-openal --enable-opencl --enable-opengl --enable-sdl2 --enable-pocketsphinx --enable-libmfx --enable-libdc1394 --enable-libdrm --enable-libiec61883 --enable-nvenc --enable-chromaprint --enable-frei0r --enable-libx264 --enable-shared libavutil 56. 51.100 / 56. 51.100 libavcodec 58. 91.100 / 58. 91.100 libavformat 58. 45.100 / 58. 45.100 libavdevice 58. 10.100 / 58. 10.100 libavfilter 7. 85.100 / 7. 85.100 libavresample 4. 0. 0 / 4. 0. 0 libswscale 5. 7.100 / 5. 7.100 libswresample 3. 7.100 / 3. 7.100 libpostproc 55. 7.100 / 55. 7.100 Input #0, mov,mp4,m4a,3gp,3g2,mj2, from \u0026#39;video.mp4\u0026#39;: Metadata: major_brand : isom minor_version : 512 compatible_brands: isomiso2avc1mp41 encoder : Lavf58.45.100 Duration: 00:20:48.73, start: 0.000000, bitrate: 234 kb/s Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 1920x1080 [SAR 1:1 DAR 16:9], 228 kb/s, 59.99 fps, 60 tbr, 15360 tbn, 120 tbc (default) Metadata: handler_name : VideoHandler Input #1, mov,mp4,m4a,3gp,3g2,mj2, from \u0026#39;audio.m4a\u0026#39;: Metadata: major_brand : mp42 minor_version : 0 compatible_brands: isommp42 creation_time : 2020-10-31T13:54:23.000000Z com.android.version: 11 Duration: 00:20:48.65, start: 0.000000, bitrate: 97 kb/s Stream #1:0(eng): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, mono, fltp, 96 kb/s (default) Metadata: creation_time : 2020-10-31T13:54:23.000000Z handler_name : SoundHandle Stream mapping: Stream #0:0 -\u0026gt; #0:0 (h264 (native) -\u0026gt; h264 (libx264)) Stream #1:0 -\u0026gt; #0:1 (aac (native) -\u0026gt; aac (native)) Press [q] to stop, [?] for help [libx264 @ 0x563cd2ea2c00] using SAR=1/1 [libx264 @ 0x563cd2ea2c00] using cpu capabilities: MMX2 SSE2Fast SSSE3 SSE4.2 AVX FMA3 BMI2 AVX2 [libx264 @ 0x563cd2ea2c00] profile High, level 4.2, 4:2:0, 8-bit [libx264 @ 0x563cd2ea2c00] 264 - core 160 r3011 cde9a93 - H.264/MPEG-4 AVC codec - Copyleft 2003-2020 - http://www.videolan.org/x264.html - options: cabac=1 ref=3 deblock=1:0:0 analyse=0x3:0x113 me=hex subme=7 psy=1 psy_rd=1.00:0.00 mixed_ref=1 me_range=16 chroma_me=1 trellis=1 8x8dct=1 cqm=0 deadzone=21,11 fast_pskip=1 chroma_qp_offset=-2 threads=34 lookahead_threads=5 sliced_threads=0 nr=0 decimate=1 interlaced=0 bluray_compat=0 constrained_intra=0 bframes=3 b_pyramid=2 b_adapt=1 b_bias=0 direct=1 weightb=1 open_gop=0 weightp=2 keyint=250 keyint_min=25 scenecut=40 intra_refresh=0 rc_lookahead=40 rc=crf mbtree=1 crf=23.0 qcomp=0.60 qpmin=0 qpmax=69 qpstep=4 ip_ratio=1.40 aq=1:1.00 Output #0, mp4, to \u0026#39;output.mp4\u0026#39;: Metadata: major_brand : isom minor_version : 512 compatible_brands: isomiso2avc1mp41 encoder : Lavf58.45.100 Stream #0:0(und): Video: h264 (libx264) (avc1 / 0x31637661), yuv420p(progressive), 1920x1080 [SAR 1:1 DAR 16:9], q=-1--1, 60 fps, 15360 tbn, 60 tbc (default) Metadata: handler_name : VideoHandler encoder : Lavc58.91.100 libx264 Side data: cpb: bitrate max/min/avg: 0/0/0 buffer size: 0 vbv_delay: N/A Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, mono, fltp, 69 kb/s (default) Metadata: creation_time : 2020-10-31T13:54:23.000000Z handler_name : SoundHandle encoder : Lavc58.91.100 aac frame=74925 fps=578 q=-1.0 Lsize= 46121kB time=00:20:48.70 bitrate= 302.6kbits/s dup=10 drop=0 speed=9.63x video:33530kB audio:10587kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 4.540816% [libx264 @ 0x563cd2ea2c00] frame I:321 Avg QP:17.74 size: 52621 [libx264 @ 0x563cd2ea2c00] frame P:19077 Avg QP:15.53 size: 530 [libx264 @ 0x563cd2ea2c00] frame B:55527 Avg QP:16.40 size: 132 [libx264 @ 0x563cd2ea2c00] consecutive B-frames: 0.9% 0.8% 0.5% 97.9% [libx264 @ 0x563cd2ea2c00] mb I I16..4: 33.6% 51.8% 14.6% [libx264 @ 0x563cd2ea2c00] mb P I16..4: 0.1% 0.1% 0.1% P16..4: 0.2% 0.0% 0.0% 0.0% 0.0% skip:99.6% [libx264 @ 0x563cd2ea2c00] mb B I16..4: 0.0% 0.0% 0.0% B16..8: 0.5% 0.0% 0.0% direct: 0.0% skip:99.4% L0:63.4% L1:36.5% BI: 0.1% [libx264 @ 0x563cd2ea2c00] 8x8 transform intra:48.8% inter:23.1% [libx264 @ 0x563cd2ea2c00] coded y,uvDC,uvAC intra: 12.1% 5.6% 5.2% inter: 0.0% 0.0% 0.0% [libx264 @ 0x563cd2ea2c00] i16 v,h,dc,p: 71% 24% 4% 0% [libx264 @ 0x563cd2ea2c00] i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 51% 15% 33% 0% 0% 0% 0% 0% 0% [libx264 @ 0x563cd2ea2c00] i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 44% 22% 11% 3% 3% 4% 4% 4% 4% [libx264 @ 0x563cd2ea2c00] i8c dc,h,v,p: 95% 2% 2% 0% [libx264 @ 0x563cd2ea2c00] Weighted P-Frames: Y:0.0% UV:0.0% [libx264 @ 0x563cd2ea2c00] ref P L0: 75.4% 4.6% 13.9% 6.1% [libx264 @ 0x563cd2ea2c00] ref B L0: 44.3% 55.2% 0.6% [libx264 @ 0x563cd2ea2c00] ref B L1: 99.0% 1.0% [libx264 @ 0x563cd2ea2c00] kb/s:219.96 [aac @ 0x563cd2ea1980] Qavg: 121.461 おまけ： 動画の再生 何故かUbuntuには動画の再生ソフトがインストールされていません。\nですが、普通にブラウザでファイルを開いたら再生できます。\n$ firefox output.mp4 あるいは有名なVLCでもいいですね。 以下のコマンドでインストールできます。\n# apt install vlc こっちだとnautilusでダブルクリックで開けます。\nもちろん、コマンドラインからでも開けます。\n$ vlc output.mp4 動画のファイル名がオーバーレイして表示されるのでちょっとビビります。\n","categories":["Linux","動画","SimpleScreenRecorder","Shotcut"],"category_urls":["/categories/linux","/categories/%e5%8b%95%e7%94%bb","/categories/simplescreenrecorder","/categories/shotcut"],"date":"2020-11-08","title":"Linuxで発表動画を撮る","url":"https://KeenS.github.io/blog/2020/11/08/linuxdehappyoudougawotoru/"},
  {"body":"κeenです。最近紙芝居みたいなSVGをブログ（スライド）に載せる需要があったときに調べたのでそのメモ。 Inkscapeで描いたSVGを組み合わせます。Inkscape 1.0.1での情報です。\n紙芝居みたいにちょっとずつ内容が違う画像をたくさん作るのは面倒です。 Inkscapeで描くこと自体はレイヤとかを使えばパーツのon/offを切り替えられるのでいいんですが、それを画像に出力するのが面倒です。 1枚1枚どのレイヤをonにしてどのレイヤをoffにして出力先のファイル名は何々で〜というのを管理しないといけません。ちょっと気になったところがあって微調整するとまた全部出力し直しになります。 そして私のブログの管理上も画像が沢山あると面倒です。 可能ならパーツだけ出力しておいてブラウザ上で合成したいですし、画像ファイルを置くのが面倒なのでテキストでブログのソースに直打ちできると嬉しいです。そういったお話。\nざっくりいうと以下の手順で実現できます\n 図を描く  このとき1パーツに1レイヤを割り当てる  SVGをソースにコピペ  不要な要素は消してよい  レイヤをシンボルにする  このとき分かりやすいidもつける  使う  実例を交じえて解説します。\n解説 図を描く 適当な図をInkscapeで描きます。\nここで、矩形2つと矢印1つの都合3つをバラバラのパーツにしたいとします。 1パーツあたり1レイヤを割り当てます。\nSVGをソースにコピペ こういうSVGが生成されるはずです。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;svg xmlns:dc=\u0026#34;http://purl.org/dc/elements/1.1/\u0026#34; xmlns:cc=\u0026#34;http://creativecommons.org/ns#\u0026#34; xmlns:rdf=\u0026#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#\u0026#34; xmlns:svg=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xmlns:sodipodi=\u0026#34;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\u0026#34; xmlns:inkscape=\u0026#34;http://www.inkscape.org/namespaces/inkscape\u0026#34; width=\u0026#34;512\u0026#34; height=\u0026#34;512\u0026#34; viewBox=\u0026#34;0 0 512 512\u0026#34; version=\u0026#34;1.1\u0026#34; id=\u0026#34;svg8\u0026#34; inkscape:version=\u0026#34;1.0.1 (3bc2e813f5, 2020-09-07)\u0026#34; sodipodi:docname=\u0026#34;test.svg\u0026#34;\u0026gt; \u0026lt;defs id=\u0026#34;defs2\u0026#34;\u0026gt; \u0026lt;marker style=\u0026#34;overflow:visible;\u0026#34; id=\u0026#34;Arrow1Lend\u0026#34; refX=\u0026#34;0.0\u0026#34; refY=\u0026#34;0.0\u0026#34; orient=\u0026#34;auto\u0026#34; inkscape:stockid=\u0026#34;Arrow1Lend\u0026#34; inkscape:isstock=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;path transform=\u0026#34;scale(0.8) rotate(180) translate(12.5,0)\u0026#34; style=\u0026#34;fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1\u0026#34; d=\u0026#34;M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \u0026#34; id=\u0026#34;path856\u0026#34; /\u0026gt; \u0026lt;/marker\u0026gt; \u0026lt;marker style=\u0026#34;overflow:visible\u0026#34; id=\u0026#34;Arrow1Lstart\u0026#34; refX=\u0026#34;0.0\u0026#34; refY=\u0026#34;0.0\u0026#34; orient=\u0026#34;auto\u0026#34; inkscape:stockid=\u0026#34;Arrow1Lstart\u0026#34; inkscape:isstock=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;path transform=\u0026#34;scale(0.8) translate(12.5,0)\u0026#34; style=\u0026#34;fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1\u0026#34; d=\u0026#34;M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \u0026#34; id=\u0026#34;path853\u0026#34; /\u0026gt; \u0026lt;/marker\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;sodipodi:namedview id=\u0026#34;base\u0026#34; pagecolor=\u0026#34;#ffffff\u0026#34; bordercolor=\u0026#34;#666666\u0026#34; borderopacity=\u0026#34;1.0\u0026#34; inkscape:pageopacity=\u0026#34;0.0\u0026#34; inkscape:pageshadow=\u0026#34;2\u0026#34; inkscape:zoom=\u0026#34;1.4\u0026#34; inkscape:cx=\u0026#34;75.429374\u0026#34; inkscape:cy=\u0026#34;348.53947\u0026#34; inkscape:document-units=\u0026#34;px\u0026#34; inkscape:current-layer=\u0026#34;layer3\u0026#34; inkscape:document-rotation=\u0026#34;0\u0026#34; showgrid=\u0026#34;false\u0026#34; units=\u0026#34;px\u0026#34; showguides=\u0026#34;true\u0026#34; inkscape:guide-bbox=\u0026#34;true\u0026#34; inkscape:window-width=\u0026#34;1998\u0026#34; inkscape:window-height=\u0026#34;1217\u0026#34; inkscape:window-x=\u0026#34;420\u0026#34; inkscape:window-y=\u0026#34;595\u0026#34; inkscape:window-maximized=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;sodipodi:guide position=\u0026#34;62.142857,367.71429\u0026#34; orientation=\u0026#34;1,0\u0026#34; id=\u0026#34;guide26\u0026#34; /\u0026gt; \u0026lt;/sodipodi:namedview\u0026gt; \u0026lt;metadata id=\u0026#34;metadata5\u0026#34;\u0026gt; \u0026lt;rdf:RDF\u0026gt; \u0026lt;cc:Work rdf:about=\u0026#34;\u0026#34;\u0026gt; \u0026lt;dc:format\u0026gt;image/svg+xml\u0026lt;/dc:format\u0026gt; \u0026lt;dc:type rdf:resource=\u0026#34;http://purl.org/dc/dcmitype/StillImage\u0026#34; /\u0026gt; \u0026lt;dc:title /\u0026gt; \u0026lt;/cc:Work\u0026gt; \u0026lt;/rdf:RDF\u0026gt; \u0026lt;/metadata\u0026gt; \u0026lt;g inkscape:label=\u0026#34;layer1\u0026#34; inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;layer1\u0026#34; style=\u0026#34;display:inline\u0026#34;\u0026gt; \u0026lt;rect style=\u0026#34;fill:none;fill-opacity:1;stroke:#1a1a1a;stroke-width:3;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1\u0026#34; id=\u0026#34;rect72\u0026#34; width=\u0026#34;174.63353\u0026#34; height=\u0026#34;136.63985\u0026#34; x=\u0026#34;62.380371\u0026#34; y=\u0026#34;279.50797\u0026#34; ry=\u0026#34;24.02396\u0026#34; /\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;g inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;layer2\u0026#34; inkscape:label=\u0026#34;layer2\u0026#34;\u0026gt; \u0026lt;path style=\u0026#34;display:inline;fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#Arrow1Lend)\u0026#34; d=\u0026#34;m 240.5433,359.93792 c 0,0 124.40282,-15.25408 117.51317,-95.20412 C 351.16682,184.78376 236.16935,127.09817 236.16935,127.09817\u0026#34; id=\u0026#34;path28\u0026#34; /\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;g inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;layer3\u0026#34; inkscape:label=\u0026#34;layer3\u0026#34;\u0026gt; \u0026lt;rect style=\u0026#34;fill:none;fill-opacity:1;stroke:#1a1a1a;stroke-width:3;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1\u0026#34; id=\u0026#34;rect7-3\u0026#34; width=\u0026#34;174.63353\u0026#34; height=\u0026#34;136.63985\u0026#34; x=\u0026#34;62.142857\u0026#34; y=\u0026#34;63.106865\u0026#34; ry=\u0026#34;24.02396\u0026#34; /\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt; このとき冒頭の \u0026lt;?xml ...?\u0026gt; は不要です。 sodipodi:namedview と metadata は消してよいです。 また、 \u0026lt;svg\u0026gt; タグのwidth、height、viewBoxも消しとかないと場所をとってしまいます。 さらにそれに伴っていくつか不要なxmlnsが消せます。 XMLの名前空間が分からない人は適当にググって下さい。\n結果、以下のようにダイエットできます。\n\u0026lt;svg xmlns:svg=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xmlns:inkscape=\u0026#34;http://www.inkscape.org/namespaces/inkscape\u0026#34; version=\u0026#34;1.1\u0026#34; id=\u0026#34;svg8\u0026#34; inkscape:version=\u0026#34;1.0.1 (3bc2e813f5, 2020-09-07)\u0026#34;\u0026gt; \u0026lt;defs id=\u0026#34;defs2\u0026#34;\u0026gt; \u0026lt;marker style=\u0026#34;overflow:visible;\u0026#34; id=\u0026#34;Arrow1Lend\u0026#34; refX=\u0026#34;0.0\u0026#34; refY=\u0026#34;0.0\u0026#34; orient=\u0026#34;auto\u0026#34; inkscape:stockid=\u0026#34;Arrow1Lend\u0026#34; inkscape:isstock=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;path transform=\u0026#34;scale(0.8) rotate(180) translate(12.5,0)\u0026#34; style=\u0026#34;fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1\u0026#34; d=\u0026#34;M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \u0026#34; id=\u0026#34;path856\u0026#34; /\u0026gt; \u0026lt;/marker\u0026gt; \u0026lt;marker style=\u0026#34;overflow:visible\u0026#34; id=\u0026#34;Arrow1Lstart\u0026#34; refX=\u0026#34;0.0\u0026#34; refY=\u0026#34;0.0\u0026#34; orient=\u0026#34;auto\u0026#34; inkscape:stockid=\u0026#34;Arrow1Lstart\u0026#34; inkscape:isstock=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;path transform=\u0026#34;scale(0.8) translate(12.5,0)\u0026#34; style=\u0026#34;fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1\u0026#34; d=\u0026#34;M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \u0026#34; id=\u0026#34;path853\u0026#34; /\u0026gt; \u0026lt;/marker\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;g inkscape:label=\u0026#34;layer1\u0026#34; inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;rect1\u0026#34; style=\u0026#34;display:inline\u0026#34;\u0026gt; \u0026lt;rect style=\u0026#34;fill:none;fill-opacity:1;stroke:#1a1a1a;stroke-width:3;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1\u0026#34; id=\u0026#34;rect72\u0026#34; width=\u0026#34;174.63353\u0026#34; height=\u0026#34;136.63985\u0026#34; x=\u0026#34;62.380371\u0026#34; y=\u0026#34;279.50797\u0026#34; ry=\u0026#34;24.02396\u0026#34; /\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;g inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;path\u0026#34; inkscape:label=\u0026#34;layer2\u0026#34;\u0026gt; \u0026lt;path style=\u0026#34;display:inline;fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#Arrow1Lend)\u0026#34; d=\u0026#34;m 240.5433,359.93792 c 0,0 124.40282,-15.25408 117.51317,-95.20412 C 351.16682,184.78376 236.16935,127.09817 236.16935,127.09817\u0026#34; id=\u0026#34;path28\u0026#34; /\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;g inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;rect2\u0026#34; inkscape:label=\u0026#34;layer3\u0026#34;\u0026gt; \u0026lt;rect style=\u0026#34;fill:none;fill-opacity:1;stroke:#1a1a1a;stroke-width:3;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1\u0026#34; id=\u0026#34;rect7-3\u0026#34; width=\u0026#34;174.63353\u0026#34; height=\u0026#34;136.63985\u0026#34; x=\u0026#34;62.142857\u0026#34; y=\u0026#34;63.106865\u0026#34; ry=\u0026#34;24.02396\u0026#34; /\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt; レイヤをシンボルにする 上記SVG、大枠で見ると以下のような構造になっています。\n\u0026lt;svg\u0026gt; \u0026lt;defs\u0026gt; ... \u0026lt;/defs\u0026gt; \u0026lt;g inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;...\u0026#34;\u0026gt; ... \u0026lt;/g\u0026gt; \u0026lt;g inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;...\u0026#34;\u0026gt; ... \u0026lt;/g\u0026gt; \u0026lt;g inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;...\u0026#34;\u0026gt; ... \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt; inkscape:groupmode=\u0026quot;layer\u0026quot; となっている \u0026lt;g\u0026gt; を \u0026lt;symbol\u0026gt; にします。 SVGで \u0026lt;g\u0026gt; も \u0026lt;symbol\u0026gt; もオブジェクトをまとめる働きをしますが、役割が異ります。 \u0026lt;g\u0026gt; はその場で表示します。\u0026lt;symbol\u0026gt; はその場には表示せずに後でIDで参照する用途で使います。\n g - SVG: Scalable Vector Graphics | MDN \u0026lt;symbol\u0026gt; - SVG: Scalable Vector Graphics | MDN  今回はまさに後でIDで参照したいので \u0026lt;symbol\u0026gt; に書き換えます。\n\u0026lt;svg\u0026gt; \u0026lt;defs\u0026gt; ... \u0026lt;/defs\u0026gt; \u0026lt;symbol inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;...\u0026#34;\u0026gt; ... \u0026lt;/symbol\u0026gt; \u0026lt;symbol inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;...\u0026#34;\u0026gt; ... \u0026lt;/symbol\u0026gt; \u0026lt;symbol inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;...\u0026#34;\u0026gt; ... \u0026lt;/symbol\u0026gt; \u0026lt;/svg\u0026gt; また、 \u0026lt;symbol\u0026gt; は \u0026lt;defs\u0026gt; に入れた方が行儀がいいとされているようです。\n defs - SVG: Scalable Vector Graphics | MDN  実は \u0026lt;defs\u0026gt; に移動するならシンボルにしなくてもいい説ありますが、まあいいでしょう。 さらに後で参照したいので id 属性も分かりやすいようにしておきましょう。 結果、こうなります。\n\u0026lt;svg\u0026gt; \u0026lt;defs\u0026gt; ... \u0026lt;symbol inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;rect1\u0026#34;\u0026gt; ... \u0026lt;/symbol\u0026gt; \u0026lt;symbol inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;path\u0026#34;\u0026gt; ... \u0026lt;/symbol\u0026gt; \u0026lt;symbol inkscape:groupmode=\u0026#34;layer\u0026#34; id=\u0026#34;rect2\u0026#34;\u0026gt; ... \u0026lt;/symbol\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;/svg\u0026gt; オブジェクトだったらInkscape内でオブジェクトのプロパティからIDいじれるんですが、レイヤだとできないみたいです。\nここまでくれば準備OK。あとは使います。\n使う XMLにはxlinkという仕様があって、それ経由で他の \u0026lt;svg\u0026gt; タグのシンボルを参照できるようです。\n XML, XLink and XPointer use - SVG: Scalable Vector Graphics | MDN  例えば先程の全てのオブジェクトを参照するならこう書きます。\n\u0026lt;svg width=\u0026#34;512\u0026#34; height=\u0026#34;512\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34;\u0026gt; \u0026lt;use xlink:href=\u0026#34;#rect1\u0026#34; /\u0026gt; \u0026lt;use xlink:href=\u0026#34;#path\u0026#34; /\u0026gt; \u0026lt;use xlink:href=\u0026#34;#rect2\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; それがこう表示されます。\n\n一部のパーツだけの参照も可能です。\n\u0026lt;svg width=\u0026#34;512\u0026#34; height=\u0026#34;512\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34;\u0026gt; \u0026lt;use xlink:href=\u0026#34;#rect2\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; \nいくらでも使い回せて楽しいですね。\n\u0026lt;svg width=\u0026#34;512\u0026#34; height=\u0026#34;512\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34;\u0026gt; \u0026lt;use xlink:href=\u0026#34;#rect1\u0026#34; /\u0026gt; \u0026lt;use xlink:href=\u0026#34;#path\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; \n以上使い方でした。\nFAQ 非表示にしたオブジェクトが表示されないんだけど？ 非表示にしたからですね。SVG的にはCSSで style=\u0026quot;display:none;\u0026quot; と設定されてるはずなので inline にしときましょう。\nレイヤじゃなくてグループでもいいのでは？ Yes。グループだとInkscape内からオブジェクトのプロパティでID設定できるしそっちもあり。 ただし描くときにレイヤの方が扱いやすい（表示/非表示の単位が分かりやすい）し、SVGタグ内でもレイヤがトップレベルにあって探しやすいので私はこうしてます。\nテキストが表示されないんだけど？ どうやらInkscapeがSVGの未来の仕様を使ってるっぽいんですが、現実的には1.1の機能までしかサポートしてないのが原因らしいです。\njavascript - SVG Inkscape generated file does not show flowRoot objects on browser - Stack Overflow\n↑の問答にもあるようにInkspace内で該当テキストを選択したあと [テキスト] → [テキストに変換] でテキストオブジェクトになるので表示されます。ただしフォントが変わるのと、微妙に位置がずれます。 もしかしたらエクステンションのグリフとかを使ったらもうちょっと綺麗に解決できるのかもしれませんが、未確認です。\nSVGコピペじゃなくて外部ファイルとして読み込みたいんだけど？ \u0026lt;object\u0026gt; タグで読み込めます！\n\u0026lt;object data=\u0026#34;sample.svg\u0026#34; type=\u0026#34;image/svg+xml\u0026#34;\u0026gt;\u0026lt;/object\u0026gt; See also:\n \u0026lt;object\u0026gt; - HTML: HyperText Markup Language | MDN HTML5でのSVGファイル操作のおさらい - Qiita        \n","categories":["SVG","Inkscape"],"category_urls":["/categories/svg","/categories/inkscape"],"date":"2020-11-03","title":"Inkscapeで描いたパーツをブラウザ上で合成する","url":"https://KeenS.github.io/blog/2020/11/03/inkscapedeegaitapa_tsuwoburauzauedegouseisuru/"},
  {"body":"# 言語自作を通して学んだRust---------------------- [RustFest Global 2020](https://rustfest.global/) Note: Good morning, everyone. I'm κeen. First of all, I'd like to say thank you to RustFest's organizers. This is my first time to have a talk at an international conference. Because I'm not good at English, attending international conferences is not easy. I guess this is true for most of those who are not native to English. However, in this time, as we have translated subtitles and interpreters there was a chance for me. Thank you. Then, I'm going to give the rest of my tolk in Japanese. それでははじめていきます。「言語自作を通して学んだRust」というタイトルで発表していきます。 === # About Me --------- ![κeenのアイコン](/images/kappa2_vest.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * GitHub: [KeenS](https://github.com/KeenS) * Engineer at [Idein Inc.](https://idein.jp/) + working on Rust job! * An author of 実践Rust入門 * A translator (to Japanese) of the Book 1st edition and (old) Rust's official website Note: 私はκeenといいます。 TwitterやGitHubのアカウントを持っていて、Ideinという会社で仕事でRustを使っています。 右にある画像がTwitterやGitHubで使っているアイコンです。 日本で出版された実践Rust入門という本の著者の一人です。 またプログラミング言語Rustの初版やRustの公式ウェブサイトの旧版の翻訳に協力したりもしました。 === # Background ------------ * Have created many (toy) languages + [a Scheme implementation](https://github.com/picrin-scheme/picrin) (one of commiter) + [Lisp in Scala Types](https://github.com/KeenS/scala-lisp) + [Whitespace compiler in Whitespace](https://github.com/KeenS/whitelie) + ..and many others * Love functional languages like ML and Lisp + ADTs and pattern matches is suitable for interpreters * Like C + fast and low level Note: さて、Rustに入門する前に私がどういうことをしてきたかというと、おもちゃ言語を色々作ってました。 一例を挙げるとScheme処理系のコミッタをやってたり、Scalaの型でLispを作ったり、WhitespaceでWhitespaceのコンパイラを書いていたりしました。 MLやLispといった関数型プログラミング言語が好きです。 Algebraic data typesやパターンマッチといった機能がインタプリタを書くのに適していたからです。 Cもほどほどに好きです。 速くてローレベルなことができるからです。 === # Between C and FPL ------------ * FP languages are good for writing interpreters + 😊 ADT and pettern matches + 😊 readable and safe + 😖 have runtimes * C is low level + 😊 fast + 😊 rutime-less + 😖 unsafe (no more SEGV!) * I was seeking for a safe, fast, and runtime-free language with ADT and pattern matches Note: ただし関数型プログラミング言語もCも一長一短あります。 関数型言語にはADTやパターンマッチがあり、可読性が高く安全である一方ランタイムがあるので速いインタプリタを作るのには向いてません。 逆にCは速くてランタイムを持ちませんが、安全ではありません。 なので安全で速くてランタイムがなくてADTとパターンマッチのある言語を探していました。 === # Met Rust ---------- * One day I met Rust * When rust was 0.12.0 (just before 1.0-alpha) * Seemed an ultimate language to write a language + 😊 ADT and pettern matches + 😊 Readable and Safe + 😊 Fast + 😊 Rutime-less * → Started using Rust for writing languages Note: そうしてある日Rustに出会いました。 出会ったのはRust 0.12.0の頃で、1.0-alphaが出る直前でした。 Rustには先程あげた機能が全部揃っていたので言語を作るときはRustを使うようになりました。 === # Languages Wrote in Rust ---------------------- * 2015-09: [κLisp](https://github.com/KeenS/kappaLisp) (subset of Emacs Lisp) * 2016-09: [igaguri](https://github.com/KeenS/igaguri) (Shell) * 2016-11: [rustlisp](https://github.com/KeenS/rustlisp) (small lisp in Rust Type) * 2016-12: [WebML](https://github.com/KeenS/webml) (Standard ML compiler) * 2016-12: [WebAssembler-rs](https://github.com/KeenS/WebAssembler-rs) (in-memory WebAssembly assembler) * 2017-11: [chema](https://github.com/KeenS/chema) (alt JSON Schema) * ..and some misc languages Note: そうしてRustで作った言語をいくつか挙げるとこんな感じです。 まずはLisp方言。 それから1年後くらいにシェルだとか、また型レベルLispだとか、SMLコンパイラだとかインメモリのWebAssemblyアセンブラだとかを作りました そしてまた1年後くらいにalt JSON Schemaだとかを作りました。 細かいものを含めたら他にもあるんですがひとまずこんなところです。 === # In this talk --------------- * κLisp: Learned basics * WebML: Maintaining * chema: Making usable product Note: 本当はこれらの言語を全部話したかったんですが時間が足りないので3つ選んで、それぞれの言語を作って何を学んだかを紹介します。 選んだ3つがこれで、まずκLispからは基礎を学びました。 次はWebMLで、メンテナンスするということを学びました。 最後がchemaで、使えるものを作るということを学びました。 それではこの三本立てで話していきたいと思います。 === # κLisp Note: まずはκLispです。 === # What is κLisp --------------- * Designed to interpret SKK Lisp + SKK is a input method for Japanese + It's not important in this talk :) * (Almost) my first Rust project * I tried to write in 4 days + I was confident because I was experienced to write Lisp interpreters ``` lisp (skk-gadget-units-conversion \"mile\" 1 \"km\") ``` Note: κLispはSKK Lispを解釈するために作られました。 SKKというのは日本語入力メソッドの名前なんですが、この話にはあまり関係ないので気にしなくてよいです。 ほぼ私の最初のRustのプロジェクトでした。 当初はこれを4日で作ろうと意気込んでました。 4日というのは日本では秋頃に4連休があるのでその間に作りたかった訳です。 Lisp処理系は何度か作ったことがあるので4日あれば作れるだろうと踏んでました。 下に貼ってあるコードがκLispのコードです。 `skk-gadget-units-conversion` 関数を呼び出して1マイルを1kmに変換する計算をしています。 === # Learned Basics ------------------ * Writing a language requires basic knowledge of the host language * Language featuers: + structs, methods + enums, pattern matches + macros + ... * Standard Libraries + iterators + HashMap + ... Note: 言語処理系を作るのにはホスト言語の色々な基本機能が必要になります。 使った機能の一例を挙げると、 言語側だと構造体、メソッド、列挙型、パターンマッチ、マクロなどなど。 標準ライブラリだとイテレターやハッシュマップなどです。 こういうった基本機能を駆使しつつインタプリタを書いていきました。 === # How I failed -------------- * Failed to complete it in 4 days * Faced many difficulties + Garbage collection (GC) + Lifetime / ownership + Error handling * Was taught Rust was a difficult language Note: そして、失敗しました。4日では終わりませんでした。 失敗した理由としてはいくつか難しいところがあったからです。 具体的にはガベージコレクション、ライフタイムと所有権、エラーハンドリングあたりです。 ここでRustは難しい言語というのを思い知ることになります。 === # GC and Box ------------- * My first attempt of Lisp expression used `Box` s as pointer: ```rust pub enum Expr { Int(isize), Cons(Box, Box), // ... } ``` Note: GCで躓いたのはこういう部分です。 Lispの式（expression）を `Expr` というenumで表現するのですが、そこに出てくるポインタに `Box` 型を使っていました。 下にコードスニペットがあって `enum Expr` を定義していますね。 そこの2つ目のヴァリアントが `Cons` で、ポインタを2つ保持します。 そのポインタに `Box` を使っていた訳です。 === # GC and RC ----------- * Rust doesn't have GC! + Unlike FP languages * Values must be shared! + Lisp allows share values * Correct approach is use `Rc` instead of `Box`: + RC (Reference Count) manages the data for you ```rust pub enum Expr { Int(isize), Cons(Rc, Rc), // ... } ``` Note: 何がよくなかったかというとRustにはGCが無い点です。 関数型言語だとGCはあるのでそういうことをすっかり忘れてました。 Rustの `Box` 型だとその値を一人しか使えませんが、今回実装しているLispは値を共有できるので、ダメでした。 正しくは `Box` の代わりに `Rc` を使わないといけません。 RC、参照カウントを使うとデータを管理してくれます。 下のコードスニペットでは先程の `Expr` とほぼ同じですが、 `Cons` の保持しているポインタが `Rc` になったものになっています。 これが正しい実装です === # Lifetime / Ownership ----------------------- * It was new notion to me (and I guess to most of you) * Taking ownership at argument makes writing funcions easy, but calling them very hard ```rust fn eval(env: \u0026mut Env, expr: \u0026Expr) - Result { /* */} ``` ```rust fn eval(env: \u0026mut Env, expr: Expr) - Result { /* */} ``` Note: 次に困ったのがライフタイムと所有権です。 恐らくほとんどの人もそうだと思いますがこれは初めて体験した概念です。 関数を定義するときに引数で所有権を取ってしまうと書くのは楽になりますが、呼ぶのが大変になります。 例えば下に貼った2つの `eval` 関数を見てみましょう。 上の `eval` は引数に `\u0026mut Env` と、 `\u0026Expr` を取っています。2つ目の引数の `Expr` が参照になっているんですね。 下の `eval` は引数に `\u0026mut Env` と、 `Expr` を取っています。こちらは2つ目の引数の `Expr` が参照になっていません。 上の方の `eval` は引数が参照になっているので定義するときに `clone` が必要で大変なのですが、呼び出すときには値を貸すだけでいいので楽です。 一方で下の方が `eval` を定義するには `clone` などを挟まなくていいので便利なのですが、 `eval` を呼び出すときには `clone` が必要になり、大変です。 このどちらが正しい設計なのか当時は分かりませんでした。 === # Lifetime / Ownership ----------------------- * Eventually I noticed overall design is important + Like \"This data is registered to the runtime and should live to the end of execution, thus you cannot take its ownership\" * (The borrow checker was lexical) + `get` then `insert` against `HashMap` was illegal at that time Note: 最終的に全体の設計が大事ということに気付きました。 全体の設計というのは「このデータはランタイムに登録されるから実行が終わるまで生きないといけない、だから所有権を奪ってはいけない」などです。 あと当時はボローチェッカがレキシカルだったというのもあります。 有名な `HashMap` に対して `get` して `insert` しようとするとエラーというのも実際に体験していました。 === # Error Handling ----------------- * I had no idea of how to handle errors * The first code used `panic`s everywhere ```rust fn k_add_aux(x: \u0026Expr, y: \u0026Expr) - Expr { match (x, y) { (\u0026Expr::Int(x), \u0026Expr::Int(y)) = Expr::Int(x + y), _ = panic!(\"non int args {:?} and {:?} are given to +\", x, y) } } ``` Note: 困った3つ目がエラーハンドリングです。 正直、どうすればいいか分かりませんでした。 最初のコードは各所で `panic` を使っていました。 下に貼ってあるコードスニペットでは `k_add_aux` という関数を定義していて、関数の返り型は素の `Expr` になっています。 関数本体の方では引数に対してパターンマッチするときに想定していないデータだった場合にパニックしています。 === # Option --------- * I started use `Option` when failed to prepare correct values ```rust fn read_aux( mut input: \u0026mut Peekable, first: char ) - Option { ... } ``` Note: 次に正しい値を用意できなかったら `Option` を使いはじめました。 下に貼ってあるコードスニペットでは `read_aux` という関数を定義していて、関数の返り型が `Option` になっています。 === # String Errors --------------- * Then I learned `Result` is recommended * However, all the error was `String` ``` rust fn k_funcall( mut env: \u0026mut Env, args: Expr ) - Result{ match args { Expr::Cons(f, args) = { funcall(env, f.deref(), args.deref().clone()) }, args = { Err(format!(\"illeagal form of funcall {:?}\", args)) } } } ``` Note: 次にエラーには `Result` 型を使うと学んだので使いはじめました。 しかしエラーは全て `String` でした。 下に貼ってあるコードスニペットでは `k_funcall` という関数を定義していて、 返り型が `Result` になっています。 関数本体の方では引数に対してパターンマッチするときに想定していないデータだった場合に `Err(format!())` を返しています。 === # Custom Errors ---------------- * Finally, I learned the correct way + [Error Handling in Rust - Andrew Gallant's Blog](https://blog.burntsushi.net/rust-error-handling/) * Defined custom erros: ``` rust pub enum Error { InvalidArgument, Type, ArityShort, ArityExceed, Form, NotFunction, Unbound, User(String) } ``` Note: 最後に正しい方法を知りました。 「Error Handling in Rust」というAndrew Gallantさんのブログです。 このブログを読んで独自のエラー型を定義することを覚えました。 下に貼ってあるコードスニペットでは `Error` という名前のenumを定義していてκLispで起きるエラーをヴァリアントで表現しています。 === # Lessons learned from κLisp ----------------- * Many basics of Rust * Variants of pointers + `\u0026`, `Box` and `Rc` * Ownership / lifetime and design of data lifetimes * Error handling Note: κLispで学んだこととしては、まずはRustの基礎です。 そしてポインタがいくつかあることも学びました。κLispで使ったのは参照、 `Box` 、 `Rc` ですね。 所有権、ライフタイム、そしてデータのライフタイムの設計についても学びました。 最後にエラーハンドリングについても学びました。 === # WebML Note: 次はWebMLです。 === # What is WebML ---------------- * A Standard ML to WebAssembly compiler + [WebAssembler-rs](https://github.com/KeenS/WebAssembler-rs) is a side project of this * The biggest among my hobby projcets * My \"bonsai\" project + You take care of it constantly when you have times + A long term project A Japanese Black Pine (Pinus thunbergii) bonsai on display at the National Bonsai \u0026 Penjing Museum at the United States National Arboretum. According to the tree's display placard, it has been in training since 1936. It was donated by Yee-sun Wu. 2007 CC BY-SA 4.0  Note: WebMLはStandard MLからWebAssemblyへのコンパイラです。 WebAssembler-rsこれのサイドプロジェクトです。 私の趣味プロジェクトの中で一番規模が大きいです。 そして私の盆栽プロジェクトでもあります。 下にある画像が盆栽ですが盆栽は長い時間をかけて手入れします。 その盆栽のように、盆栽プロジェクトというのは、時間のあるときにちょくちょく手入れして、ずっと続けていくようなプロジェクトのことです。 === # Difficulties -------------- * It's big + Better code organization is required * SML has complex syntax compared to Lisp + It's too complicated to write a parser by hand * Many similar types + You'll write many similar functions to treat them ``` sml infix /: :/ \\: :\\ fun init /: operator = List.foldl operator init fun f :/ data = f data fun data \\: operator = fn init = List.foldr operator init data fun f :\\ init = f init ``` Note: WebMLを作るにあたって何が難しいかというと、まずは大きいということです。 コードベースが大きいのでコードの管理についても工夫が必要です。 次にSMLの構文がLispと比べて複雑ということです。 Lispと違って手でパーサを書く訳にはいきません。 そしてコンパイラ特有の似たような型が沢山でてくる問題もあります。 他にもそもそもコンパイラは難しいとかあるのですが、それは置いておいてこの3つに焦点を当てて喋っていきます。 === # Code organization -------------------- * It's time to use submodules + i.e. `directory/mod.rs` * But it was complex to me... + \"Why I cannot declare `mod a;` in `b.rs`?\" + \"Where should I put `mod.rs`?\" * I try-and-errored and finally understood + [Rustのモジュールの使い方 | κeenのHappy Hacκing Blog](https://keens.github.io/blog/2017/01/15/rustnomoju_runokirikata/) Note: コードの管理ですが、サブモジュールを使うタイミングですね。 サブモジュールというのはつまり `directory/mod.rs` とかです。 ですが、これが複雑でした。 「`b.rs` の中で `mod a;` を宣言したいけどできないんだけど？」 「`mod.rs` ってどこに置けばいいの？」 という具合でした。 色々試行錯誤して最終的には理解できて、ブログにまとめたりもしました。 === # Parser -------- * Hand written parsers aren't suitable for SML * I employed a [parser combinator](https://en.wikipedia.org/wiki/Parser_combinator) library + Namely [nom](https://crates.io/crates/nom) (2.0) * It was macro-full + Because `impl Trait` hadn't been arrived yet at that time ``` rust named!(top , do_parse!( opt!(multispace)  tops: separated_list!(multispace, map!(bind, AST::Top))  opt!(multispace)  (tops) )); ``` Note: 次にパーサについてです。 SMLパーサは手書きするものではないです。 ということでパーサコンビネータライブラリを使いました。nomっていうやつです。当時バージョン2.0でした。 これがマクロまみれでした。というのも当時は `impl Trait` がまだなかったので、パフォーマンスの都合でこうなっていたようです。 下に貼ってあるのがnomを使ったパーサのコードです。 `named!` というマクロの引数の中に `do_parse!` だとか `separated_list!` だとか `opt!` だとかマクロがたくさん書かれてます。 APIドキュメントを見るとマクロがすごいことになっています。 （nom 2.0のAPIドキュメント） これがnomのAPIドキュメントなんですが、マクロのところを見るとすごい数のマクロが定義されています。 10や20ではなくて50とかひょっとしたら100くらいのマクロが定義されています。 （スライドに戻る） これらを駆使しながらパーサを書くのですが、マクロのエラーメッセージが分かりづらくてデバッグが大変でした。 === # Similar Types ---------------- * Many similar types with slightly different definitions appear + `UntypedExpr` + `UntypedCoreExpr` + `TypedCoreExpr` * They are relatively large + 10+ variants * I wrote all of them at first Note: 続いて型が多い問題です。 コンパイラの中には似てるけど微妙に違う型が沢山でてきます。 `UntypedExpr`、`UntypedCoreExpr`、`TypedCoreExpr`などです。 それぞれ比較的大きくて、10個以上のヴァリアントがあります。 最初はこれを全部書いていました。 === # Type Aliases --------------- * Employed type aliases ``` rust enum ExprKind, DS = DerivedDeclaration {/* ... */} struct Annot{/* ... */} type Expr, DS = DerivedDeclaration = Annot; type UntypedExpr = Expr; type CoreExpr = Expr; type CoreExprKind = ExprKind; type UntypedCoreExpr = CoreExpr; type UntypedCoreExprKind = CoreExprKind; type TypedCoreExpr = CoreExpr; type TypedCoreExprKind = CoreExprKind; ``` Note: 色々試行錯誤するうちに型エイリアスでどうにかできることに気付きました。 下に掲載したコードはちょっとごちゃっとしてますが、型エイリアスを使った解決です。 型パラメータで振る舞いを変える `Expr` という型を用意しておいて、望ましい振る舞いをする型パラメータを与えたものに名前を与えています。 例えば `UntypeddExpr` は `Expr` に `Empty` を与えたものです。 他にも `CoreExpr` というのを定義していて、それに `Empty` を与えたのが `UntypedExpr` 、 `Type` を与えたのが `TypedExpr` です。 をそれぞれ `UntypedExpr` とか `TypedCoreExpr` とかのエイリアスを定義しています。 === # Alias and Methods ------------------- * Type aliases are flexible compared to other languages ``` rust impl CoreExpr { /* ... */ } implfmt::Display for Exprwhere Ty: fmt::Display, DE: fmt::Display, DS: fmt::Display, { /* ... */ } ``` Note: Rustの型エイリアスはかなり柔軟なのでエイリアスにしてしまえます。 例えば `CoreExpr` は `Expr` のエイリアスであり、かつ `UntypedCoreExpr` と `TypedCoreExpr` へとエイリアスされます。 `UntypedCoreExpr` と `TypedCoreExpr` 両方に同じメソッドを定義したかったら `CoreExpr` に `impl` してあげればい訳です。 また、 `Display` のように `Expr` 属全てに実装したいトレイトは型パラメータを全てジェネリクスにすればよいのです。 === # Lessons learned from WebML ------------------- * The experience of writing interpreters helps writing compilers + Defining data types desiging lifetimes were straightforward * Rust's module system is complex * Debugging macro-full code is a tough task * We need `impl Trait` * Rust's type system is awesome Note: WebMLから学んだこととしては、まずはインタプリタを作った経験がコンパイラを作るときにも生きたという点です。 内部で使うデータ型とかライフタイムの設計とかで躓くことはありませんでした。 そして、紹介したとおりモジュールシステムが複雑だったり、マクロを使って書かれたコードのデバッグがつらいということだったり `impl Trait` が早く欲しいだとかを学びました。 他にもRustの型システムがよくできているというのも学びました。 === # By the way ------------ * I changed my job at that time * I started writing Rust in daily work * My Rust skill advanced blazingly Note: ちょっと話が脇道に逸れるんですが、ここで今の職場に転職しました。 そうして普段の仕事でRustを使うようになって、Rust力がメキメキ上がっていきました。 そういう状態で次のchemaに移ります。 === # chema Note: ということでchemaです。発音はSchemaのSを取ったものです。 === # What is chema -------- * A orginal notation to [JSON Schema](https://json-schema.org) compiler + i.e. an alt JSON Schema * A tool used in company's project + → should be usable one ```text /** @title User */ type user = struct { /** unique id of the user */ id: id, name: string?, type: enum {\"admin\", \"writer\", \"reader\"}, SNSs: [string], }; ``` Note: chemaが何かというと独自記法からJSON Schemaへのコンパイラです。 要するにalt JSON Schemaとでも呼ぶべきものです。 これは会社のプロジェクトで使うために作ったので「使える」ものじゃないといけません。 下に貼ってあるのがchemaの記述例です。 `/**` 〜 `*/` でコメントを書いたり、 `type name =` で型を定義したりします。 === # What is needed ----------------- * The compiler + It's no problem to me at that time :) + → It helped tackling other difficulties * Command line interface * Binary releases Note: chemaに求められるものなんですが、まずはコンパイラ部分です。 この時点ではもう問題なく作れるようになってました。 なので他の問題に集中することができました。 WebMLで困っている部分をここで試してWebMLに持ち帰ったりもしました。 そして他にはコマンドラインインタフェースとバイナリのリリースが必要でした === # CLI ----- * A Parser of command line arguments is needed * → Employed [structopt](https://crates.io/crates/structopt) ``` rust #[derive(StructOpt)] pub struct Config { #[structopt(long = \"no-swagger\", help = \"don't use swagger spesific notation\")] pub no_swagger: bool, #[structopt(help = \"input file\")] pub input: String, } ``` Note: 同僚に使ってもらわないといけないので、コマンドラインインタフェースをリッチにしないといけません。 という訳でコマンドライン引数のパーサが必要でした。 そこで `structopt` を採用しました。 `structopt` の利用例を下に貼りました。 構造体定義に `#[derive(StructOpt)]` をつけて、それぞれのフィールドの定義に `#[structopt()]` のアトリビュートをつけます。アトリビュートの中には `long` や `help` などが書けます。 `long` は長いオプションを指定します。 ここでは `no-swagger` を指定しているのでコマンドラインで `--no-swagger` って書くオプションを指定しています。 `help` は `--help` で見れるヘルプメッセージですね。 === # CLI examples -------------- ``` text $ chema --help chema 0.0.8 Sunrin SHIMURA (keen)  An external DSL for JSON Schema USAGE: chema [FLAGS] [OPTIONS]  FLAGS: -h, --help Prints help information --no-swagger don't use swagger spesific notation --pack if pack the output -V, --version Prints version information OPTIONS: --format  output format (json|yaml) [default: json] --path-prefix  path prefix of paths [default: /definitions] ARGS:  input file ``` Note: これがstructoptで生成したヘルプメッセージです。 先程説明した `--no-swagger` や `input file` などが生成に使われています。 === # Binary releases ----------------- * Build distributions on local machine and uploading them is a hard task + And it have problems arount cross-compiling * Releasing from CI is desired * → Introduced [trust](https://github.com/japaric/trust) + A template configuration of Travis CI for Rust + It helps you creating binary releases for many architectures Note: 次がバイナリリリースです。 手元のマシンで配布物を作ってGitHubにアップロードするのは手間ですし、クロスコンパイルの問題もあります。 CIでリリースできるならそれに越したことはありません。 そういう訳でtrustを導入しました。 trustはTravis CIの設定の雛形で、これを使うと複数ターゲットのバイナリを簡単に作れます。 chemaのリリースをちょっと見てみましょう（chemaのリリースページ） こういう風に色んなプラットフォーム向けのリリースを簡単に作れる訳です。 例えばaarch64のLinuxだとかx86_64のLinuxだとかx86のappleだとか、x86のNetBSDなんかのバイナリも作れます。 === # Lessons learned from chema ----------------- * Creating a \"usable\" product requires additional labor * There are many resources available that helps such labor Note: chemaから学んだこととしては「使える」ものを作るには一手間必要である点、そしてその一手間を助けてくれるものが既に揃っている点です。 === # Looking back --------------- * I growed through writing languages + The first attempt was all about the language + Then overall code + Then while project * Some of difficulties have resolved by updates of Rust + `impl Trait` (1.26.0) + module system (2018 edition) + NLL (2018 edition) Note: まとめに入る前に少し振り返ってみましょう。 私は言語を色々書きながら成長していきました。 最初はRustでどうやって書くかでいっぱいっぱいでしたが、コード全体をどうすればいいか、そしてプロジェクト全体としてどうリリースするかなどまで気が回るようになりました。 もう1つ気付いた方もいるかと思いますが、私が遭遇した壁のいくつかは既にRustのアップデートで解決されています。 `impl Trait` は今でも覚えてますが1.26.0で入りました。 複雑なモジュールシステムや融通の効かないライフタイムは2018 editionで解決しました。 === # Conclusion ------------- * Writing a small Lisp interpreter tells you many thing about Rust * You can gradually know details by tackling one theme repeatedly + Because you already have know the overview, you can concentrate other details * Rust is an evolving language Note: ということでまとめに入ると一度Lispのインタプリタを書いてみるとRustのかなりの部分を理解できるようになります。 そして同じテーマの問題、私の場合は言語ですが、に繰り返し取り組むただんだんと細部まで理解できるようになります。 というのも既に概観は理解できているので詳細にまで踏み込めるからです。 最後にRustは進化しつづけている言語ということでした。 ありがとうございました。   ","categories":["Rust","RustFest"],"category_urls":["/categories/rust","/categories/rustfest"],"date":"2020-10-26","title":"言語自作を通して学んだRust","url":"https://KeenS.github.io/slide/gengojisakuwotoushitemanandarust/"},
  {"body":"κeenです。先日発表したRustで作るインメモリキャッシュが全然話し足りなかったので色々補足します。\n実は今回の話題はソフトウェアというよりはハードウェアの仕組みに由来するものなのですが、ソフトウェアにも応用できるだろうということで試してみた結果です。\nハードウェアでもソフトウェアでもアクセスするデータは時間局所性、つまり短期間にアクセスするデータには偏りがあるというのが仮定としてあります。 よくある例が冪乗則、あるいは80:20の法則とよばれるもので、アクセス数上位20%のものが全体の80%のアクセスを占めたりします。 データ全部はメモリに乗らないけど20%くらいだったら載るようなケースではその20%を上手く選んでメモリに載せられる仕組みがあればパフォーマンスがあがるはずです。 ということでそのような仕組み、キャッシュがほしいよねというのがモチベーションです。\nキャッシュの話 まずはキャッシュの一般論から。 Wikipediaなんかも参考にして下さい。 キャッシュメモリ - Wikipedia\nキャッシュとは容量制限のあるハッシュマップのようなものです。 ハッシュマップとの違いは、アイテムを新たに挿入するときに十分なスペースが足りなければ容量を増やすのではなく既存のアイテムを削除する点です。\nこのときにどのアイテムを削除するかがパフォーマンスに直結する工夫点です。\n場所 削除と密接に絡む、「どのデータをどこに挿入するか」の話から。\nハッシュマップのようなものなので、まずはキーのハッシュ値を計算して挿入したい場所をみつけます。\nhash(k) = 1 insert(k, v) v +---+---+---+-- | | | | ... +---+---+---+-- このときそこが空いていれば何も問題なく挿入できます。\nhash(k) = 1 insert(k, v) v +---+---+---+-- | |???| | ... +---+---+---+-- 一杯だった場合にとれる方法がいくつかあります。\nhash(k) = 1 insert(k, v) v +---+---+---+-- | |///| | ... +---+---+---+-- ひとつはその場にあるデータをそのまま追い出して、置き換えてしまう方式。\nhash(k) = 1 insert(k, v) v +---+---+---+-- | |???| | ... +---+---+---+-- ↓ /// これは ダイレクトマップ 方式とよばれます。愚直で速そうですね。 しかし他に領域が空いていてもそれを使わないので空間効率は悪そうです。\nもう1つは本来の場所を起点にして空いているところを探していく方式。 ずっとみつからなければ配列を一周します。\nhash(k) = 1 insert(k, v) ........v +---+---+---+---+-- | |///|///|???|... +---+---+---+---+-- これは フルアソシアティブ 方式と呼ばれます。 ダイレクトマップ方式の真逆で空間効率は最高ですが、最悪のケースで配列を全て舐めるので速度は悪いです。\nダイレクトマップとフルアソシアティブの折衷案として、衝突したら数個だけ近辺をみてまわるというのがあります。 例えば3つだけ近辺をみてまわるとしましょう。\nhash(k) = 1 insert(k, v) +........+| v .....+| +---+---+---+---+-- |???|///|///|???|... +---+---+---+---+-- 配列を3つごとのブロックに区切って、その中で一周するように探索します。 その中に空きがあればそこを、なければ何かしらのデータを追い出します。\nこれは セットアソシアティブ 方式と呼ばれます。 1セットにn要素ある方式を n-ウェイセットアソシアティブ方式と呼びます。 上の例は3-ウェイセットアソシアティブ方式ですね。\nn = 1の場合はダイレクトマップ方式になりますし、n = 配列の長さの場合はフルアソシアティブ方式になります。 そういう意味で両者の折衷案となっています。\n両者の折衷案ということで、ほどほどの空間効率とほどほどの速度が期待できます。 もちろん、nが小さければ特徴がダイレクトマップ方式に寄りますし、nが大きければフルアソシアティブ方式に近い特徴になります。\n削除 ダイレクトマップ方式はそのまま削除するデータまで指定するのでフルアソシアティブ方式とセットアソシアティブ方式が対象です。\n「将来再度使われるのが最も遅いデータ」を削除できると効率的にメモリを使えるのですが、未来予知はできないので絵に描いた餅。 次善の策として「将来一番使われなそうな」データを削除するのが目標になります。\n輪番削除などの方法もあるのですが、あまり効率はよくないようです。 似たような気がするランダム削除は実はそこまで悪くないらしいです。 実装も簡単そうですしいざとなったらこれで実装するのもよさそうです。\nある程度効率がいいとされているのがLeast Recently Used（LRU）、最後に使ったのが最も古いデータを削除する方法です。 時間局所性の仮定下では最近使われていないデータは将来も使われる可能性が低いので合理的な気がします。\nLRUの基本的な動きを説明しておきます。\nまず 1 というデータがきたらリストの先頭に置きます。\n  \n次に 2 というデータがきたら 1 のデータを1つ下にずらして2のデータを置きます。\n \n3 がきたら同様に 1 、 2 をずらして3を置きます。\n  \n次にデータが一杯の状態で 4 がきたら 1 、 2 、 3 をずらしてデータを置きます。 このとき溢れた 1 は削除されます。\n    \n最後に、既に保持されている 2 というデータがきたらそれより後にきたデータを1つずらし、 2 を先頭にもってきます。\n  \nというのがキャッシュの一般論でした。これを踏まえて、実装についてみていきましょう。\n今回の実装の話 今回は16-ウェイセットアソシアティブ方式を実装しました。 コードは以下にあります。\nκeen / chechire · GitLab\nこれについて色々話題があるので拾っていきます。\nLRUの実装 LRUの説明でリストのようなものがでてきたことからも分かるように、LRUはリスト（又はベクタ）があれば実装できます。 教科書的には順番の入れ替えが得意なリストの出番ですが、残念ながら最近のCPUではベクトルの処理は速くリストのようなポインタ処理は遅いです。 RustのLinkedListのドキュメントにもこう書かれています。\n NOTE: It is almost always better to use Vec or VecDeque because array-based containers are generally faster, more memory efficient, and make better use of CPU cache.\n訳 注: 一般に配列ベースのコンテナの方が速く、メモリ効率的でかつCPUキャッシュをより利用できるので、ほぼ常に Vec や VecDeque を使った方がよいです。\n 今回必要な操作は先頭にデータを追加する処理、リストの途中にあるデータを先頭にもってくる処理と、一番古いデータを捨てる処理です。 Vec は末尾にデータを挿入する処理が得意なので末尾に新しいデータを挿入し、古いデータを捨てるときだけ先頭から取り出すようにすればそこまで効率は悪くないはずです。\nというのがわかりやすい実装です。\n実はLRUは少数であればbit演算でも管理できることが知られています。 主にセットアソシアティブ方式を想定したアルゴリズムですね。\n上の例ではキャッシュのキーを直接管理してましたが、こちらはそのキーが置かれる場所、バケットのインデックスで管理します。\n0 1 2 +---+---+---+ | | | | +---+---+---+ 「0番目のバケットが使われた」「2番目のバケットの内容は古いから捨ててもよい」のように管理すれば数値を扱うことになるのでbit演算ができます。\nさて、肝心のアルゴリズムですが、まずはN x Nのビットテーブルを用意します。今回は3x3ですね。 ひとまず0で埋めておきましょうか。\n0 1 2 0 0 0 0 1 0 0 0 2 0 0 0 N番目が使われたとき、 N列目を全て0にして、N行目を全て1にします。\n例えば0、2、1、2の順で使われたとしましょう。\nまず0が使われたので0列目を全て0にします。\n0列目 v 0 1 2 0 0 0 0 1 0 0 0 2 0 0 0 そして0行目を全て1にします。\n0 1 2 0 1 1 1 \u0026lt; 0列目 1 0 0 0 2 0 0 0 次に2が使われたので2列目を全て0にします。\n2列目 v 0 1 2 0 1 1 0 1 0 0 0 2 0 0 0 そして2行目を全て1にします。\n0 1 2 0 1 1 0 1 0 0 0 2 1 1 1 \u0026lt; 0列目 次に1が使われたので1列目を全て0にします。\n1列目 v 0 1 2 0 1 0 0 1 0 0 0 2 1 0 1 そして1行目を全て1にします。\n0 1 2 0 1 0 0 1 1 1 1 \u0026lt; 1行目 2 1 0 1 最後に再度2が使われたので2列目を全て0にします。\n2列目 v 0 1 2 0 1 0 0 1 1 1 0 2 1 0 0 そして2行目を全て1にします。\n0 1 2 0 1 0 0 1 1 1 0 2 1 1 1 \u0026lt; 2行目 こうやって管理したbitを行単位で1つの数値と思うと、その数値の大小が最後に使われた順序になっています。 上の例だと\n0: 100 = 4 1: 110 = 6 2: 111 = 7 なので 0 \u0026lt; 1 \u0026lt; 2 と、最後に使われた順序と等しいです。\n数値の大小が最後に使われた順ということは、数値が最小のものがLRUとなります。 あとはLRUを削除するときにそこの行を全て0にしてあげれば完成です。\n今回16-wayを選んだのはRust的に u16 を16個の配列であれば効率的に実装できるかなと思ったからです。\n私が実装したのも、ほぼ上記のままです。行を数値として比較したいので1行を u16 で表現することにして、それを16行分まとめたものを [u16;16] として表現しています\npubstruct LeastRecentlyUsed{bit_table: [u16;16],}implLeastRecentlyUsed{pubconstSIZE: usize =16;pubfn refer(\u0026amp;mutself,index: usize){debug_assert!(index\u0026lt;Self::SIZE);letmask=!(1\u0026lt;\u0026lt;index);forbin\u0026amp;mutself.bit_table{*b\u0026amp;=mask;}self.bit_table[index]=!0;}pubfn delete(\u0026amp;mutself,index: usize){debug_assert!(index\u0026lt;Self::SIZE);self.bit_table[index]=0;}pubfn least(\u0026amp;self)-\u0026gt; usize {letmutmin=u16::MAX;letmutmin_index=0;for(i,\u0026amp;b)inself.bit_table.iter().enumerate(){// ignoring b == 0 because hashbrown assumes there is at least 1 blank bucket // thus there is at least 1 unavailable bucket. if0\u0026lt;b\u0026amp;\u0026amp;b\u0026lt;min{min=b;min_index=i;}}min_index}} テーブル側 LRUでテーブルの内部実装にある配列の各インデックスにアクセスできるという仮定を置きました。 しかし標準ライブラリの HashMap ではそういう機能はありません。\nところで標準ライブラリの HashMap と同じものがcrates.ioに公開されています。 hashbrownといいます。 というか元々は標準ライブラリ互換の速いハッシュマップとして公開されていたものが標準ライブラリ側が取り込んだ形になります。 普通の言語だとそもそもユーザレベルでハッシュマップを効率的に実装できなかったり、できたとしても自動で標準ライブラリに依存してしまうので標準ライブラリに取り込めなかったりするのですが no_std などの仕組みが整ったRustではこういうことができてしまう訳です。\nちょっと話が逸れましたね。 このhashbrowですが実験的機能としてrawというモジュールを公開しています。 これはハッシュマップの実装に使われているデータ構造の内部実装を公開するAPIで、先程言及した内部で使ってる配列へのインデックスアクセスも含みます。 あるいは insert_no_grow のように領域が足りなくてもメモリを拡張しない（領域が足りなかったら未定義動作）APIなどのキャッシュの実装にはおあつらえ向きなAPIがあります。 これらをありがたく使わせてもらうことにします。\n一方で、ハッシュマップを前提にした実装なので困った点などもいくつかあるのですが、それは後ろの方で紹介したいと思います。\n全体の実装 キャッシュポリシーとテーブが出揃ったので全体の話をします。 hashbrownの raw を使っている関係上、また設計を真似る意味でも低レベルな RawCache とその上に作られた CacheTable の2つを作っていくことにします。 RawCache のAPIをhashbrownの RawTable に似せれば CacheTable 部分はほぼコピペで実装できるだろうという魂胆です。\n今回の実装は16-ウェイアソシアティブなキャッシュなので、小さなキャッシュテーブルを複数束ねた形になります。これはRustのコードを見た方が話が早いですかね。\npubstruct Block\u0026lt;T\u0026gt;{pub(crate)table: RawTable\u0026lt;T\u0026gt;,policy: RefCell\u0026lt;LRU\u0026gt;,}pubstruct RawCache\u0026lt;T\u0026gt;{blocks: Vec\u0026lt;Block\u0026lt;T\u0026gt;\u0026gt;,} これを使って、気になる insert は以下のように実装されています。\npubfn insert(\u0026amp;mutself,hash: u64,value: T)-\u0026gt; Bucket\u0026lt;T\u0026gt;{letblock_index=self.block_index(hash);letcache_hash=self.block_hash(hash);letblock=self.block_mut(hash);unsafe{// もしテーブルが満杯だったら if(block.table.capacity()-block.table.len())==0{// Least Recently Usedなデータを取得して letleast=block.policy.borrow().least();letleast_bucket=block.table.bucket(least);// それを消して block.table.erase(least_bucket);// LRUの方からも消す block.policy.borrow_mut().delete(least);}debug_assert!(0\u0026lt;block.table.capacity()-block.table.len());// 必ず空きがあるはずなので `insert_no_grow` letbucket=block.table.insert_no_grow(cache_hash,value);// LRU を更新する letbucket_index=block.table.bucket_index(\u0026amp;bucket);block.policy.borrow_mut().refer(bucket_index);Bucket{bucket,block: block_index,}}} ほぼ理論通りの実装です。 find などの参照系の実装でもLRUを更新する処理が入っています。\nさて、ここでブロックとハッシュの話をしましょう。 Block の Vec があって、さらに Block の中のハッシュテーブルの中に配列（のようなもの）があるので2段階のインデックスアクセスが必要になります。\nRawCache +-------+-- | Block | ... +-------+-- | | / \\ Block +--------+-- | Bucket | ... +--------+-- ブロックを選択する方を block_index 、ブロック内でデータにアクセスする方は普通のハッシュテーブルに任せてハッシュ値をそのまま使うのでて block_hash （あるいは cache hash）と呼んでいます（もっと良い名前が欲しい）。 insert の先頭部分で計算しているのがそれです。\npubfn insert(\u0026amp;mutself,hash: u64,value: T)-\u0026gt; Bucket\u0026lt;T\u0026gt;{letblock_index=self.block_index(hash);letcache_hash=self.block_hash(hash);// ... } これらの計算には普通のハッシュテーブルのようにハッシュ値を使うのですが、注意が必要です。 安直に思いつくのは block_index にハッシュ値を Vec の長さで割った余り、 block_hash にハッシュ値そのままというものです。\nfn block_index(\u0026amp;self,hash: u64)-\u0026gt; usize {letnum_blocks=self.blocks.len();(hashasusize)%num_blocks}fn block_hash(\u0026amp;self,hash: u64)-\u0026gt; u64 {hash} しかしこれだとよくないです。 hash % num_blocks でブロックを振り分けているということは、1ブロック内でハッシュ値の下位bitが揃ってしまいます。\nRawCache +-------+-- | Block | ... +-------+-- | hash % num_block = 0 を振り分け | / \\ Block +--------+--------+-- | Bucket | Bucket | +--------+--------+-- 0100 1100 ^ ^ 下2bitが全部00で揃ってしまう ハッシュテーブルはハッシュ値がきれいにバラけたときに効率的なので、これだとパフォーマンスが下がってしまいます。\nもう1つ、hashbrown特有の罠もあります。 下位bitを使い回すのがダメなら下のbitを捨ててしまえという発想もありえます。\nfn block_index(\u0026amp;self,hash: u64)-\u0026gt; usize {letnum_blocks=self.blocks.len();(hashasusize)%num_blocks}fn block_hash(\u0026amp;self,hash: u64)-\u0026gt; u64 {letnum_blocks=self.blocks.len();// block_indexの計算に使ったbitを捨てる hash/(num_blocksasu64)} あるいは下位bitが駄目なら上位bitで計算すればいいじゃないかという案もあるでしょう。 しかし、hashbrownは簡単に（false positiveありで）キーが一致するかを確認するために上位7bitをテーブル内に保持しています。 下位bitを捨てて上位bitに0を埋めたり、上位bitでブロックを振り分けたりするとまたハッシュ値が衝突します。\nつまり、上位7bitと下位数bit（今回は16-wayなので4bit）は予約済みで動かせないと考えてよいです。\n上位7bit 下位4bit ________________ _______ / \\ / \\ +--+--+--+--+--+--+--....-+--+--+--+--+ 63 62 61 60 59 58 57 4 3 2 1 0 ということで block_index の方で工夫するとして、効率のいい実装は以下です。\nfn block_index(\u0026amp;self,hash: u64)-\u0026gt; usize {letnum_blocks=self.blocks.len();// ハッシュで使う分のbitを除けて計算 ((hashasusize)/LRU::SIZE)%num_blocks}fn block_hash(\u0026amp;self,hash: u64)-\u0026gt; u64 {// ハッシュ値そのまま hash} ベンチマーク 効率とかの話をしたのでベンチマークをとりましょう。\nアクセス頻度にばらつきのあるベンチマークをとることになります。 そういう偏りのある乱数を得るのに、rand_distrクレートにあるWeightedIndexがまさしくな機能を提供しています。 例えば WeightedIndex::new([6, 3, 1]) とすれば 0 が60%、1 が30%、 2 が10%の確率ででてくる分布になります。\nこれを使ってベンチマークのデータ生成の方をこう実装します。\nimplWorkLoad{fn next\u0026lt;R: Rng\u0026gt;(\u0026amp;mutself,rng: \u0026amp;mutR)-\u0026gt; usize {self.weights.sample(rng)}} それぞれの重みは適当に計算しています。 本当はべき乗則に従った実装をしたつもりだったのですが、よく調べずに書いたので間違ってました（ $x^n$ を計算しないといけないところを、 $a^x$ を計算してました）。 はずかしいので実装は載せません。まあ、ベンチマークには最終的なキャッシュヒット率の方が大事なので問題ないでしょう。\nベンチマーク対象は以下のようになっています。\nstruct Subject\u0026lt;C\u0026gt;{cache: C,hits: u64,}impl\u0026lt;C\u0026gt;Subject\u0026lt;C\u0026gt;whereC: Cache,{fn new(cache: C)-\u0026gt; Self{Self{cache,hits: 0}}fn test(\u0026amp;mutself,data: usize){matchself.cache.get(\u0026amp;data){Some(\u0026amp;data)=\u0026gt;{self.hits+=1;data}None=\u0026gt;{thread::sleep(Duration::from_micros(500));self.cache.insert(data,0);0}};}} キャッシュがヒットしなかったら500μsスリープする実装です。 500μsというのは速めのDBアクセスがこのくらいかなという感覚値です。 また、キャッシュヒット率計算のために hits を保持しています。\nそしてベンチマーク本体はおおむね以下の形です。\nfn run_bench\u0026lt;C: Cache\u0026gt;(name: \u0026amp;str,s: \u0026amp;mutSubject\u0026lt;C\u0026gt;){letcount=1_000_000;letmutw=WorkLoad::new(100_000_000_000).unwrap();letmutrng=thread_rng();// ... for_in0..count{s.test(w.next(\u0026amp;mutrng))}// ... } このベンチマークコードで以下の3つをベンチマークしてみました。\n chechire: 今回実装したコード easy cache (vec): LRUにstdの Vec、テーブルにstdの HashTable easy cache (deque): LRUに VecDeque、テーブルにstdの HashTable  LRUをベクタで実装する際に先頭と末尾両方の操作があるので念のため Vec と VecDeque 両方を試してみました。 本当は LinkedList も比較したかったのですが remove がnightlyのみ なのであきらめました。コレクションで削除ってかなり基本的な気がするんですが、それが安定化していないあたり LinkedList の需要の少なさが伺えますね。\nさてさて、余談は置いておいてベンチマークをしましょう。 chechireは16-ウェイセットアソシアティブでeasy cacheはフルアソシアティブなのでキャッシュヒット率ではchechireが劣りますが、基礎パフォーマンスは高いはずです。\nベンチマークした結果が以下です。\n.graph{ background:#aaa; border-radius:5px; white-space: nowrap; text-align: left; } td { white-space: nowrap; }     subject hit rate time     chechire 98.9537% 5958ms   easy cache (vec) 99.1176% 6266ms   easy cache (deque) 99.1117% 6469ms    キャッシュのヒット率は劣るものの、全体的な速度ではchechireが上回ってます。 乱数要素があるのですが、くりかえし回数（ count ）が十分大きいので何度か計測してみてもおおむねこのような結果になりました。\nという訳で速い実装ができました。 めでたしめでたし…としたいところなのですが、これはまやかしです。 LTするときに綺麗な落ちがほしかったのでこういう結果を載せました。 ちょっと事情を詳しく説明しましょう。\nキャッシュのパフォーマンスはほぼキャッシュヒット率で決まります。 もうちょっと正確にいうと、(1 - キャシュヒット率)をキャッシュミス率とすると\n$a$ をキャッシュミス率 、 $X$ をキャッシュミスしたときにかかる時間 、 $Y$ をキャッシュヒットしたときにかかる時間 とすると、平均パフォーマンスは\n\\[ aX + (1 - a)Y \\]\nとなります。ここでほとんどの場合では $X \u0026gt;\u0026gt; Y$ なので、キャシュの性能はほぼ以下となります。\n\\[ aX \\]\n$X$ はコントロールできないのでキャッシュミス率がほぼそのままキャッシュのパフォーマンスを左右するのです。\nこの原則に従わないのは $a$ が極端に小さいか、 $X$ と $Y$ の差がそこまで大きくないかの場合になります。\n上記のベンチマークでchechireが速いように見えたのはまさにそれです。 キャッシュミス率が1%前後と小さいですし、 $Y$ が $X$ より十分小さくなかったからです。 実際、スリープの時間を500μsから1msにすると結果が逆転します。\n   subject hit rate time     chechire 98.9549% 11159ms   easy cache (vec) 99.1131% 10767ms   easy cache (deque) 99.1094% 11040ms    みなさん数値に騙されないようにしましょうね。\nこぼれ話とか 話の流れをスムーズにするために省いた話題を拾っていきます。\nプランAが失敗した話 今回のキャッシュは、なんとなくアイディアだけあってLTに申し込んで、その後に実装をはじめました。 そのとき思い浮かんでいた実装がプランA、それが失敗したときの代替案のプランBとCがありました。 A、B、Cの順で実装難易度が高いです。 そしてベンチマークのところででてきたchechireがプランB、easy cacheがプランCです。\nではAはというと、 RawTable をカスタマイズする案でした。 カスタマイズするのはいくつかの理由があります。\nデータ構造的効率 1つはデータ構造的効率です。\nRawCache は同じサイズの RawTable を複数個 Vec に格納しています。 RawTable 内にポインタが1つ、 Vec 内にポインタが1つでデータにアクセスするのに都合2つのポインタを経由します。これが無駄なので1つにまとめられないかと考えていました。 メモリアロケーション的にも1回でドカンとメモリを確保した方が効率がいいはずです。 また、それぞれのハッシュマップはサイズ情報を持ちますが、今回は16で固定なのでその情報も無駄ですので、これを省こうという意図もありました。\nアルゴリズム的効率 もう1つはアルゴリズム的効率です。\nハッシュマップは場合によっては巨大にもなる要素数に対応しています。 ハッシュマップの空き部分が少なくなると極端に効率が悪くなるので、hashbrowでは持っているデータ領域の85%が埋まるとデータ領域を拡張するようにできています。 バケットを走査するときに「空きバケットがみつかるまで続ける」などの処理をしているので適度に空き領域がないといけません。そして最低でも1つは空きがないと無限ループしてしまいます。\n一方でキャッシュの実装では16個と決めてたので巨大なデータは想定しなくていいですし、空きバケットなく完全に埋めてしまっても問題ありません。\nこういった部分で妥協したくなかったのですが、ちょっと難しかったです。 RawTable と Vec のポインタを統合するということは2つのデータ構造を同時に実装するということでもあります。さらにはポインタを減らすために RawTable に保持しているフィールドもどこかのメモリ領域に埋め込んだりなど、メモリレイアウトの工夫も必要でした。これは考えるのも実装するのもかなり大変でした。\nまた、 RawTable にはイテレータなど関連するデータ型が多かったのも障壁の一つでした。 実装を変えるときにどこをいじったらどのデータ型に影響があるのかがわかりづらかったので途中で思考を放棄してあきらめてしまいました。\nProbeSeq が面白い 上述のようにhashbrownのコードを読んでいたのですが、その中で使われている ProbeSeq が面白かったので紹介します。\nProbeSeq はあるバケットに着地したあと、そこに要素があったら他のバケットを探しにいくときに使うイテレータです。次の候補となるインデックスを返してくれます。\n愚直にやるならすぐ隣をみにいけばよさそうです。\n1 2 3 4 5 v v v v v +---+---+---+---+---+ | | | | | | +---+---+---+---+---+ 0 1 2 3 4 しかしこれだと一度要素が埋まってるカタマリが産まれると、周辺のアクセス効率がひどく悪くなります。 例えば下の例だと0、1、2、3のどれからスタートしても隣が埋まってるので右に辿りつづけて、全て4に落ち着きます。そしてそこにデータを挿入するとさらにカタマリが大きくなってしまします。\n1 2 3 4 5 v v v v v 1 2 3 4 5 v v v v v 1 2 3 4 5 v v v v v +---+---+---+---+---+ |///|///|///|///|???| +---+---+---+---+---+ 0 1 2 3 4 これは隣に限らず、規則的なアクセスだと大抵起こってしまう問題です。 だからといえって不規則にアクセスしていたらどれにアクセスしてどれにアクセスしてないかが分からなくなります。 そこで「不規則っぽくアクセスする規則」があるとうれしいです。 特に全ての要素を丁度1度づつ訪問できると最高です。\nhashbrownの ProbSeq はそれを実現しています。しかもめちゃくちゃ簡単なアルゴリズムで。\n使っているのは三角数です。 これは一辺がnの正三角形に含まれる○の数で、具体的には1、3、6、10、15…となっています。n番目の三角数を $T_n$ で表わします。\n1 3 6 10 O O O O O O O O O O O O O O O O O O O O hashbrowのデータを保持する配列（のようなもの）は2のべき乗なのですが、最初の $2^n$ 個の三角数をそれぞれ $2^n$ で割ったあまりの集合がちょうど $\\{0, 1, \\cdots, 2^n - 1\\}$ となっているそうです。これなら全ての要素をちょうど一回ずつ訪問できますね。\n実装上は $T_n - T_\\{n - 1\\} = n$ を利用して、1つ隣、そこから2つ隣、そこから3つ隣…と1つずつアクセス幅を増やしていけばよいです。\n1 2 3 4 v v v v +---+---+---+---+---+---+---+-- | | | | | | | | ... +---+---+---+---+---+---+---+-- 0 1 2 3 4 5 6 実はこれ、Art of Compute Programming, Volume 3の6.4章に載っているらしいです。持ってないので知りませんでした。\nまた、2の羃と三角数のあまりについての証明はこちらの記事にあります。\nTriangular numbers mod 2^n | The ryg blog\nところで、三角数は無限にあるのでこのイテレータは終わりません。 実装をみても常に Some(result) を返しています。\nstruct ProbeSeq{bucket_mask: usize,pos: usize,stride: usize,}implIteratorforProbeSeq{type Item=usize;#[inline]fn next(\u0026amp;mutself)-\u0026gt; Option\u0026lt;usize\u0026gt;{// We should have found an empty bucket by now and ended the probe. debug_assert!(self.stride\u0026lt;=self.bucket_mask,\u0026#34;Went past end of probe sequence\u0026#34;);letresult=self.pos;// SIMD幅単位でアクセスしてるので // self.stride += 1 // でない self.stride+=Group::WIDTH;self.pos+=self.stride;self.pos\u0026amp;=self.bucket_mask;Some(result)}} これが上の方で説明した、バケットを走査するときに「空きバケットがみつかるまで続ける」などの処理をしているの部分です。 イテレータ側ではずっとインデックスを返し続けていて、それを使う側で空きバケットがあったら終了という処理をいれています。\n外部に公開してないデータ構造だから許される攻め具合ですね。\nCriterionが使えなかった話 ベンチマークに素朴な繰り返しと素朴な Instant::now を使いました。 しかしベンチマークライブラリにcriterionがあります。 こちらの方がこなれてますし、誤差とかもうまく処理してくれます。 最初はこれを使ったのですが、正しくベンチマークがとれなかったのでやめました。\n使えなかったのは外れ値処理の問題です。 集団から大きくはずれた値を計算に入れると平均などの統計値が大きく狂ってしまいます。 なので統計的処理をするにあたって外れ値を除外する処理は重要です。 実際、criterionも外れ値処理をします。\nしかし残念ながらこの外れ値処理が問題でcriterionがベンチマークに使えませんでした。 今回のキャッシュのパフォーマンス測定では、大多数のキャッシュヒットと少数のキャッシュミスからなります。 さらにキャッシュヒットはとても速く、キャッシュミスは極端に遅いです。 その結果をみてcriterionはキャッシュミスした場合の計測値を外れ値とみなして除外してしまってたのです。 criterionのAPIやCLIを見ても外れ値処理をスキップする機能はなさそうだったのでcriterionをあきらめました。\nキャッシュのパフォーマンス測定で本質的に外れ値のようなものがでてしまって、統計的ベンチマークが役に立たないのは面白いなと思いました。\n             1  2  1   3  2 1   4  3 2 1   3 2 1  4 3 2  2 4 3    \n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2020-10-20","title":"Rustでインメモリキャッシュ作った話","url":"https://KeenS.github.io/blog/2020/10/20/rustdeinmemorikyasshutsukuttahanashi/"},
  {"body":"# Rustで作るインメモリキャッシュ ---------------------- [RustのLT会 Shinjuku.rs #12 @オンライン - connpass](https://forcia.connpass.com/event/187287/) === # About Me --------- ![κeenのアイコン](/images/kappa2_vest.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # モチベーション -------------- * アプリケーションでキャッシュしたいよね + アクセス数の80%はアクセス頻度上位20%のアイテム + もうちょっと極端なケースも * 例えば [crates.io](https://crates.io)のmost downloaded * 少量ならメモリに載るのでDBアクセスを省きたい === # ハッシュマップ？ -------------- ```rust struct CachedDao { cache: HashMap, dao: Dao } impl CacheedDao { fn get(\u0026mut self, key: \u0026Key) - Result { match self.cache.get(key) { Some(v) = Ok(Some(v)), None = { let v = dao.get(key)?; if let Some(v) = \u0026v { self.cache.insert(k.clone(), v.clone()) } Ok(v) } } } } ``` === # 🙅‍ ------- * 使ってないデータを捨てる処理がない * 最終的に全てのデータをメモリに載せてしまう * →メモリ使用量制限のあるハッシュマップを作ろう + 現実にはアイテム数制限 === # インメモリキャッシュ ---------------------- * ほとんどハッシュマップと一緒 * 容量が足りなくなったときの挙動が違う マップキャッシュ 容量を増やすアイテムを削除  === # キャッシュポリシー -------------------- * 容量が一杯になったときにどのアイテムを削除するか？ * 色々ポリシーがある + ランダム + ハッシュが衝突したもの + 一番古い要素(FIFO) + … * ポリシーによってパフォーマンス（ヒット率）が変わる === # Least Recently Used --------------------- * 最後に参照したのが最も古いアイテムを削除 * そこそこキャッシュヒット率が良いことで知られる * →これで実装してみよう === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # LRU Explained ----------------   === # 実装 ------ * LRU + ハッシュマップ  image/svg+xml                  LRU HashMap   === # 実装 ------ * LRU + ハッシュマップ * LRUは リスト（あるいはベクタ）で簡単に実装できる + しかし効率が悪い + $O(n)$ の計算量 * ハッシュマップは標準ライブラリのものを使える + でもちょっと無駄がある === # 実装(LRU) ------ * 少数（定数）個のバケットを保持するブロックに分ける        image/svg+xml        LRU HashMap     LRU HashMap     LRU HashMap {     fixed   === # 実装(LRU) ------ * LRUを効率的に実装したい * 少数（定数）個のバケットを保持するブロックに分ける + 今回は16個 + 少数ならビット演算でLRUを実装できる * ブロックへの振り分けはハッシュ値を使う + 下4bitをブロック内の振り分けに + 5bit目以降をブロックの振り分けに * キャッシュヒット率を捨てて速度をとった === # 実装(ハッシュマップ) ------ * ハッシュマップにはキャッシュに必要のない機能がある + 容量が足りなくなったら拡大など * LRUで管理する関係上ハッシュマップ内部のインデックスを使いたい === # hashbrown ------------ * [hashbrown](https://crates.io/crates/hashbrown) * 標準ライブラリのハッシュマップはcrates.ioに公開されている * 低レベルAPIの[`RawTable`](https://docs.rs/hashbrown/0.9.1/hashbrown/raw/struct.RawTable.html)が公開されている * → これを使うと実装できそう === # chechire ----------- * [blackenedgold/chechire](https://gitlab.com/blackenedgold/chechire) + 発音はチェシャ猫のcheshireと同じ * 16-way assosiativeなhashbrownベースのキャッシュ * ほぼ標準ライブラリの `HashMap` と同じAPI * 時間の都合で紹介は省略 === # ベンチマーク -------------- * 以下の3つが対象 + chechire + LRUを `Vec` で実装した簡易キャッシュ + LRUを `VecDeque` で〃 * キャッシュサイズ16348 * ベキ分布なランダムアクセス1,000,000回 * キャッシュミスすると500usのスリープ + DB叩くとだいたいこのくらい？ === # 結果 ------ .graph{ background:#aaa; border-radius:5px; white-space: nowrap; text-align: left; } td { white-space: nowrap; }  | subject | hit rate | time |:--------------------|----------|----------------------------------------------------------------- | chechire | 98.9537% | 5958ms | easy cache (vec) | 99.1176% | 6266ms | easy cache (deque) | 99.1117% | 6469ms === # まとめ -------- * 定数個のアイテムを保持できるキャッシュを作ったよ * アイテム管理にはLRUというポリシーがあるよ * fully associativeだと遅いから16-wayくらいにしたよ * Rustの `HashMap` は改造できるよ                1  2  1   3  2 1   4  3 2 1   3 2 1  4 3 2  2 4 3    \n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2020-10-18","title":"Rustで作るインメモリキャッシュ","url":"https://KeenS.github.io/slide/rustdetsukuruinmemorikyasshu/"},
  {"body":"# 安全な言語Rust ---------------------- [【オンライン】フィンテックエンジニア養成勉強会9（最新技術特集） - connpass](https://fintech-engineer.connpass.com/event/178015/) === # About Me --------- ![κeenのアイコン](/images/kappa2_vest.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # Rustとは？ ------------ * 2015年にリリースされた **システムプログラミング言語** + CとかC++とかのライバル * MozillaやAWS、Microsoft Azureなどが[支援](https://www.rust-lang.org/sponsors) * 安全なシステムプログラミング言語として注目 * 5年連続で[最も愛された言語](https://insights.stackoverflow.com/survey/2020) === # Rustの利用事例 ---------------- * Firefox: レンダラの[WebRenderer](https://github.com/servo/webrender)（a.k.a. Quantum Renderer）やCSSエンジンの[Stylo](https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/)プロジェクト（a.k.a. Quantum CSS） * AWS: Lambda/Fargateのランタイムの[Firecraker](https://github.com/firecracker-microvm/firecracker/) * Microsoft: Azure IoTの[エッジセキュリティデーモン](https://msrc-blog.microsoft.com/2019/09/30/building-the-azure-iot-edge-security-daemon-in-rust/) * 暗号通貨: Ethereumクライアントの[OpenEthereum](https://github.com/openethereum/openethereum) === # 何故Rust? ----------- * 今までなかった新しいシステムプログラミング言語 * 安全性が特徴 * 所有権などの新しい概念を導入 * 関数型言語の特徴を取り入れた === # Rustのパフォーマンス ---------------------- * 基本性能はC/C++と[同等](https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fastest.html) * 所有権のおかげで自動でメモリ管理をするが、GCがない * ゼロコスト抽象化のおかげで綺麗なコードがそのまま速い === # 例1 平均二乗誤差 ----- 平均二乗誤差 [[asm](https://gcc.godbolt.org/z/ffwvT2)] ``` rust // データの参照 `\u0026` をとれる fn mean_square_error(v1: \u0026[f32], v2: \u0026[f32]) - f32 { let len = v1.len() as f32; // 繰り返し処理はイテレータで一発 let square_sum = v1 .iter() .zip(v2) .map(|(x1, x2)| (x1 - x2).powi(2)) .sum::(); square_sum / len } ``` === # Rustの安全性 -------------- * 一言で言ってしまえば未定義動作が起きない + ヌルポ、SEGV、境界外アクセスなど * ポインタでトラブルが起きない設計 + [「Chrome」の深刻なセキュリティ脆弱性、70％はメモリー安全性の問題 - ZDNet Japan](https://japan.zdnet.com/article/35154338/) * 強い静的型で不正な入力はコンパイルエラー === # 例2 参照 ----- これはちゃんとコンパイルエラー [[run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=1c348e83914bc400a7dcab4b136e5549)] ``` rust fn int_ref() - \u0026i32 { // ローカル変数を用意。 // スコープは関数末尾で終わる let i = 1; // ローカル変数の参照を返す // （dangling pointer） \u0026i } ``` === # 例3 RAII ---- * Cの `malloc` だと返り値は `void *` + `struct point *` や `double *` など好きなデータにキャストできてしまう ``` c void *ptr; struct point *data = (struct point*) ptr; double *d = (double*) ptr; ``` * `malloc` してから値を入れるまでに、有効な値が入ってない期間がある * `malloc` した値を `free` し忘れたり、 `free` したあとに参照してしまう問題がある === # 例3 RAII ---- RAII [[run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=7ddb0fb13500f2e181be913869aa64dc)] ``` rust struct Point(i32, i32); { // メモリ確保は値による初期化と一緒 // `data` は `Box::` 型 let data = Box::new(Point(0, 0)); // スコープを抜けると確保したメモリは開放される } ``` === # 所有権 --------- * 値にはただ1つの所有者がいる * 所有者がいなくなると値は破棄される + このおかげでGCレス + ものによってはデストラクタが走る * 値の所有者を移動（ムーブ）することができる * 値は参照で貸し借りできる * 所有権をスレッド間でやりとりできる === # 例4 所有権 ----- 所有権と開放 [[run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=2898bcb8d4ce3104672418dcf6f7fa3b)] ``` rust // data は Stringの所有者 let data = \"owned\".to_string(); // Stringの所有権がdata2にムーブした let data2 = data; // ムーブ済みの変数にアクセスするとエラー println!(\"{}\", data); ``` === # 例5 ライフタイム ----------------- * 多くのGC付き言語は値の破棄をGCに任せる * でもファイルディスクリプタなどの破棄は手でやる + GCでやるとタイミングが遅い * 手でやるとバグるので専用構文がある * でも完全じゃない === # 例5 ライフタイム ----------------- これはエラー ``` ruby file = nil File.open(\"file.rb\") do |f| file = f end puts file.read ``` === # 例5 ライフタイム ----------------- 値の開放はライフタイムに基く [[run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=80c761adee6b5eeeaa37af730934a8d1)] ``` rust let file; { let tmp = File::open(\"hoge.txt\")?; // fileに`File`をムーブ file = tmp } // ここでfileは有効 // 末尾でfileのライフタイムが終わる // それと同時にFileが閉じられる ``` === # 例6 並行と所有権 ----------------- [[run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=12c992d81dcab3a16a024712b06d8c72)] ``` rust let mut data = \"single thread\".to_string(); // 別スレッドに `data` を送る let handle = thread::spawn(move || { // スレッドを使いつつ値を変更しているが、 // マルチスレッドバグは起きない data.push_str(\" in another thread\"); println!(\"{}\", data); }); // `data` の所有権を別スレッドに送ったので // `data` にアクセスできない // data.push_str(\"hoge\") handle.join(); ``` === # 関数型言語の機能 ------------------ * Rustは堅牢性が高いと言われる関数型言語の機能を取り入れた * デフォルトイミュータブル * 型推論 * 代数的データ型とパターンマッチ * などなど === # 型推論 -------- * 型を書かなくても推論してくれる仕組み + ただしRustは設計上関数の型はユーザに書かせる * だたの略記だけではなく「逆向き」の推論ができる === # 例7 型推論 ------------ [[run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=9960dde1904599b960a78f4afc068e0d)] ``` rust fn bind(addr: IpAddr) { /* do something */} // この時点では何にパースするか分からない let addr = \"127.0.0.1\".parse().unwrap(); // 後で `IpAddr` 型として使われているので `IpAddr` 型として // パースすべきであることが分かる bind(addr); ``` === # 例8 パターンマッチ ------------------- 値の生成と同じ構文で分解できる [[run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=1a6d1c7bd8d9543b54722f0a366a7b95)] ``` rust enum Command { Move(u32), Left, Right, } use Command::*; let commands = vec![Left, Move(10), Right, Move(5)]; for command in commands { match command { Move(amount) = println!(\"move {}\", amount), Left = println!(\"Turn left\"), Right = println!(\"Turn right\"), } } ``` === # 例9 代数的データ型 ------------------- * Rustに例外はない * 組み込みのNullable型もない * どちらも代数的データ型で表現できる + 標準ライブラリで定義 ``` rust enum Option { Some(T), None } enum Result{ Ok(T), Err(E), } ``` === # 例9 代数的データ型 ------------------- ``` rust struct DivByZero; let x = 3; let y = 0; if y == 0 { Err(DivByZero) } else { Ok(x/y) } ``` === # その他 --------- * インストーラやビルドツール、パッケージマネージャ完備 * ジェネリクス（パラメトリック多相）やトレイト（アドホック多相） * わかりやすいエラーメッセージ * 豊富なクレート（パッケージ） * …などなど === # まとめ --------- * Rustは新しいシステムプログラミング言語 * Rustはメモリエラーが起きないという意味で「安全」 * Rustは所有権などの目新しい概念を取り入れてる * Rustはロジックエラーが起きづらいという意味で「安全」 * Rustは色々な言語から便利な機能を取り入れている * Rustは意識外の例外が飛んできたりしないという意味で「安全」   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2020-06-25","title":"「安全」な言語Rust","url":"https://KeenS.github.io/slide/anzennagengorust/"},
  {"body":"κeenです。 Rustに限った話ではないのですが、よくRustを触ってみた人がシャドイングが気持ち悪いという反応をしているのを見かけるのでシャドイングがどういう機能かを解説します。\nRustのシャドイング まずは「気持ち悪い」と言われることもあるRustのシャドイングについて。 Rustでは以下のコードが合法です。\nletinput=\u0026#34;42\u0026#34;;letinput=input.parse::\u0026lt;i32\u0026gt;().unwrap();// 以後、i32 型のinputが見える letresult=input*2; input という名前の変数を2回導入しています。 最初の input は \u0026amp;str 型で、2つ目の input は i32 型です。 このコード以降では後に定義した i32 型の方の input が有効になっています。 後から導入した変数が先にあった変数を覆い隠す（shadow）ので、シャドイングと呼ばれます。\nこれを見てどう感じたでしょうか。 色々感想はあるかと思いますが、他の言語の例も見ながらこれが何をしているのかを調べたいと思います。\n変数は箱ではない 最初に確認しておきたいのは、上記のRustのコードは1つの変数を \u0026amp;str 型に使ったり i32 型に使ったりしている訳ではないという点です。 1つ目の input と2つ目の input は別物です。 強調するなら以下のように input_1 、 input_2 と別の変数を導入しているのと考えることもできます。\nletinput_1=\u0026#34;42\u0026#34;;letinput_2=input_1.parse::\u0026lt;i32\u0026gt;().unwrap(); このような変数のリネーミングをコンパイラが自動でやっているわけです。\nここで少し束縛（binding）と代入（assignment）の違いに触れておきましょう。 どちらも変数と値の関係を作る操作ですが、それぞれ使い分けられています。 言語によって言葉の使い方がそれぞれ微妙に違うので厳密にどうこう言えるものではないですが、おおまかな傾向として違いをみてみましょう。\n束縛 束縛は変数を値に紐付ける操作です。 「変数は値に一時的につけた名前」という気持ちです。 変数があるなしに関わらず値は存在し、それに人間に分かりやすいように名札をつけたのが変数です。 値に紐付けられた変数は他の値につけかえられないのが一般的です。 特別なことがなければ、一度値に名前をつけたら値と名前の関係は変わりませんし値が変更されることもありません。 シャドイングも変数をつけかえるのではなく、新しい変数で覆い隠すと説明しましたね。\nRustの let や、ほとんどの関数型言語での変数束縛がこの挙動です。\n代入 代入は変数が用意した領域に値を置く操作です。 まず領域を指し示す変数というものがあり、そこに値を書き込みます。 このとき、変数の型と値の型が一致してないといけません。 大抵の手続型言語ではこのような気持で変数を使っているかと思います。 このようなモデルだと変数と領域が結び付いているので、気軽に変数宣言を覆い隠したり名前は一緒なのに別の型で変数を宣言したりするともとの領域が気になって仕方がないですよね。\nRustでは let mut で導入した変数には代入が可能です。 代入と束縛の違いを強調したいときは代入の方を再代入や破壊的代入と呼んだりします。\n束縛と代入の違い Rustには束縛と（再）代入両方があります。 少し挙動の違いを見てみましょう。\nまずは再代入を使ったコードです。 let mut で変数を宣言すると変数に再代入ができるようになります。\nletmutn=0;foriin0..10{// 再代入 n=n+i;}println!(\u0026#34;n = {}\u0026#34;,n); このコードはループ内で再代入しているので外側で定義された変数 n を更新しています。 結果、 n = 45 という出力が得られます。\n次に束縛を使ったコードを見てみましょう。\nletn=0;foriin0..10{// 束縛 letn=n+i;// n のスコープはここで終わる }println!(\u0026#34;n = {}\u0026#34;,n); ループの中で束縛をしています。 ですが、n のスコープは for 内に閉じているので外側には影響ありません。 結果、 n = 0 という出力が得られます。\n結果に釈然としない方は先程のように変数名を変えると分かりやすいですかね。\nletn_0=0;foriin0..10{// 束縛 letn_1=n_0+i;// n_1 のスコープはここで終わる }println!(\u0026#34;n = {}\u0026#34;,n_0); n_0 は特に更新されていないのが見てとれると思います。\n束縛と代入の使い分け 束縛と代入は言語の設計の違いを反映しています。 関数型言語では値を変更するとバグに繋るから破壊的変更は許さないといい、手続型言語では値を書き換えながら処理を進めるのが自然だといいます。\n因みにコンパイラの内部では束縛に近いコード、値の書き換えを許さないSSAという形式に変換してからマシン語へとコンパイルします。 なのでどちらが効率的とかはないです。\nRustはデフォルトでは再代入できないようになっていますね。 関数型言語の破壊的変更があるとバグに繋がるという言を採用したようです。 let mut があるので必要なところでは破壊的変更はできますが、可能な限り減らすことでバグの入る余地を減らそうという設計です。\nここまでで以下のことが分かりました。\n 冒頭のコードは変数を使い回しているのではなく、同じ名前の変数を2回導入している 変数束縛と変数への代入は別物  次はシャドイングについてみていきましょう。\nシャドイングは色々な言語にある 「シャドイングが気持ち悪い」と言われがちですが、実はシャドイングそのものは大抵の言語にあります。\n例えばCでもシャドイングがあります。\n// char *の変数を宣言 char *i = \u0026#34;i\u0026#34;; { // intで宣言しなおし  int i = 42; // 以後 `int` 型の `i` が見える } // `int` の `i` のスコープが終わったので // hogeここからは `char*` 型の `i` が見える  内側のスコープで外側のスコープの変数をシャドイングするのは一般的といっていいでしょう。 シャドイングそのものは大抵の言語にある機能なのです。\nRustで見慣れないのはシャドイングではなく、スコープの作り方です。 Rustでは let 文1つにつき1つスコープが作られているのです。 先のRustのコードは大袈裟な書き方をすれば以下のようになっています。\nletinput=\u0026#34;42\u0026#34;;{letinput=input.parse::\u0026lt;i32\u0026gt;().unwrap();// 以後、i32 型のinputが見える } なので正確に言えば「Rustのシャドイングが気持ち悪い」ではなく、「Rustのシャドイングを推進するようなスコープが気持ち悪い」ですね。 このような設計はMLなどの関数型言語ではよくあります。MLはRustが設計時に参考にした言語の1種類ですね。 一旦MLに寄り道して変数をどう扱っているか様子を眺めてみましょう。\nMLの let 基本的に破壊的変更を許さない関数型言語では変数が再利用できるのは重要です。 手続型言語とは違って、操作を加えるときに値を変更するのではなく新しい値を返すのでその都度変数が必要になるからです。\nリストに要素を追加する例を手続的な言語と関数型言語でみてみましょう。\nJavaだとこうなります。\nList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); // 以後 `1` を格納したリストが使える  list という変数を変更して1を追加しています。\n同じようなコードをOCamlでも書いてみましょう。 OCamlのローカルの変数束縛は let 変数 = 値 in 変数を使う式 という構文です。 ほぼRustの let 変数 = 値; 後続の式 と同じような使い方をします。 この let 式を使ったコードがこちら。\nlet list = [] in let list = 1 :: list in (* 以後 `1` を格納したリストが使える *) list という変数を元に作った新たな値に list という名前をつけています。 この場合、古い方の list にはもう用事がないのでシャドイングで見えなくしてしまうのは理に適っています。\n手続型のコードで破壊的変更していた部分で、関数型のコードではシャドイングが使われています。 値の更新はよくある操作ですから頻繁にシャドイングしたくなりますね。 シャドイングが簡単にできるような設計は合理性があるのです。\n蛇足ですが値の破壊的変更とシャドイングはシャドイングの方がコード上追いかけやすいです。 値の変更はプログラムのフロー全てを（場合によっては呼び出した関数の先まで）追わないと分かりませんが、シャドイングの関係はプログラムの字面から簡単に分析できます。\nRustとの関連 ここでRustに戻ってきます。 OCamlの let を参考にしましたといえばそれまでですが、一応このような設計がRustでも合理的か考えてみます。 Rustは所有権の関係上、値を新しく生成して返すというAPIが多くあります。 それを考えると破壊的変更を許す言語であってもこのようにど新しい値をどんどの新しい変数に束縛していけるような設計は便利そうです。 さらに、Rustにはムーブがあるので「名前空間には存在しているがもう使えない変数」というのも発生します。 その面でも名前を再利用できるシャドイングは相性がいいんじゃないかと思います。\nここまでで以下のことを確認しました。\n Rustで見慣れないのはシャドイングではなくスコープ こういうスコープの作り方には一定の合理性がある  最後に、可読性の話題をとりあげます。\nシャドイングと可読性 シャドイング（というか変数宣言のスコープ）の便利さを理解してもらったところで、次に言われるのが可読性の話です。 「それ、可読性下がらないの？」「意図せずシャドイングしてバグを生みそう」などの声が聞こえてきます。 実際に使ってる人は「そんなことはない」ときっぱり否定するので試したことのない人が言っているようですが、その言を紹介しておきましょう。 ついでにシャドイングがないことによる可読性の低下やバグも紹介しておきます。\nシャドイングをすることによるバグ まだ使っている変数を意図せずシャドイングしてしまい、あまつさえそれに気付かずに使ってしまうというものです。\nletdata=get_data();// ... letdata=new_data();// ... data.do_something();// ↑ ここで最初の方の `data` を使っているつもりだが、 // 実際に使われるのは2つ目の方  経験上、こういうバグを出してしまうことはほぼないです。 スコープにある変数が管理できなくなるほど大きな関数でも書かない限りまずやらないです。\nシャドイングをしないことによるバグ 一方でシャドイングがあれば防げたような類のバグもあります。 既に使わない、あるいは使ってはいけないような値にアクセスしてしまうものです。\nletdata=get_data();// ... letdata2=new_data();// ... data.do_something();// ↑ ここで2つ目の方の `data2` を使っているつもりだが、 // 実際に使われるのは最初の方  シャドイングしないと変数のスコープが不要に長くなってしまうので起きる問題です。 これも、変数が管理できなくなるほど大きなメソッドを書かない限りまずやらないでしょう。\nシャドイングをすることによる可読性の低下 変数が頻繁に上書かれるので最終的にどの値が有効なのかよく分からないというものです。 コードだとまさしく最初に上げたようなものがあてはまるでしょうか。\nletinput=\u0026#34;42\u0026#34;;letinput=input.parse::\u0026lt;i32\u0026gt;().unwrap();// 以後、i32 型のinputが見える  私はむしろ変数が散らばるよりも使わなくなった変数を隠してくれた方が読みやすいと感じるのですが、こういう意見もあるようです。\nシャドイングをしないことによる可読性の低下 一方でシャドイングせずに不適切に変数を使い回すのも考えものです。 違うものなのにたまたま同じスコープにあって、たまたま型が同じ値に1つの変数を使い回す例があります。 典型的なのはCの返り値などでしょうか。\nint ret; ret = func1(); if (ret) { return ret; } ret = func2(); if (ret) { return ret; } これを自然と捉える人もいるかもしれませんが、私は変数の役割が途中で変化してて分かりづらいなぁと思います。\nまとめ Rustのシャドイングが気持ち悪いと言われる件について、背景を説明しました。 ごちゃごちゃ言わずに使ってみればいいと思います。\n","categories":["言語設計","Rust"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e8%a8%ad%e8%a8%88","/categories/rust"],"date":"2020-06-20","title":"シャドイングの嬉しさ","url":"https://KeenS.github.io/blog/2020/06/20/shadoingunoureshisa/"},
  {"body":"κeenです。WebAssembly/WASIのランタイムWasmtimeをちょっと触ってみたのでそのときのメモを残します。\n私の手元にブラウザ上で動作するWebAssemblyがあるのですが、その動作のためにJavaScriptの関数をimportsで渡していました。 console.log とか。 このwasmを毎回ブラウザで動作確認してると手間なので、ローカルで実行することを試みます。そこで console.log 相当の関数をローカルでも用意する必要がでてきました、というお話。\nWebAssemblyのランタイムはいくつかあるのですが、今回はRustのライブラリとして使える wasmtimeを使って、カスタマイズした処理系を用意します。\nプロジェクトを用意しましょう。\n$ cargo new wasmtime_imports $ cd wasmtime_imports $ cargo add wasmtime@0.17.0  まずはシンプルな、Rustの関数を渡さないモジュールを作ってみましょう。\nusewasmtime::{Instance,Module,Store};fn main(){letstore=Store::default();letmodule=Module::new(store.engine(),r#\u0026#34; (module (func $add (param i32 i32) (result i32) (return (i32.add (get_local 0) (get_local 1)))) (func $main (drop (call $add (i32.const 1) (i32.const 2)))) (start $main) )\u0026#34;#, ) .expect(\u0026#34;failed to create module\u0026#34;);let_=Instance::new(\u0026amp;store,\u0026amp;module,\u0026amp;[]).expect(\u0026#34;failed to instantiate\u0026#34;);} これを実行してみると、何も起きずに終了します。\n$ cargo run  これだと何が起きてるか分かりませんね。結果をコンソールに表示しましょう。 とはいってもWebAssemblyにはコンソールを扱う機能がありません。 コンソールに表示する関数をRustから渡してみましょう。\nモジュールに imports を渡す機能を担うのが Linkerです。 そして Linker::func でRustの関数をリンカに登録できます。やってみましょう。\nusewasmtime::{Linker,Module,Store};fn main(){letstore=Store::default();// linkerを準備し、 letmutlinker=Linker::new(\u0026amp;store);// 関数を登録する linker.func(\u0026#34;ffi\u0026#34;,\u0026#34;print\u0026#34;,|x: i32|println!(\u0026#34;{}\u0026#34;,x)).expect(\u0026#34;function registration failed\u0026#34;);letmodule=Module::new(store.engine(),// \u0026#34;ffi\u0026#34;モジュールの\u0026#34;print\u0026#34;をimportして使う r#\u0026#34; (module (func $print (import \u0026#34;ffi\u0026#34; \u0026#34;print\u0026#34;) (param i32)) (func $add (param i32 i32) (result i32) (return (i32.add (get_local 0) (get_local 1)))) (func $main (call $print (call $add (i32.const 1) (i32.const 2)))) (start $main) )\u0026#34;#, ) .expect(\u0026#34;failed to create module\u0026#34;);// linkerを使ってインスタンス化する let_=linker.instantiate(\u0026amp;module).expect(\u0026#34;failed to instantiate module\u0026#34;);} Linkerを使ってモジュールにRustの関数を渡し、モジュール内でimport funcとして使っています。 これを実行してみましょう。\n$ cargo run 3  ちゃんと3が印字されました。\nということでWasmtimeのランタイムにRustの関数を渡す方法を紹介しました。 今回のコードはこちらに置いておきます。\n","categories":["Rust","WebAssembly"],"category_urls":["/categories/rust","/categories/webassembly"],"date":"2020-06-07","title":"WasmtimeのimportsにRustの関数を差し込む","url":"https://KeenS.github.io/blog/2020/06/07/wasmtimenoimportsnirustnokansuuwosashikomu/"},
  {"body":"κeenです。個人的によく設計したなと思っているRustのEntry APIについて紹介します。 標準ライブラリのHashMapの操作を無駄なく書きたい人におすすめ。\nEntry APIとは HashMap のEntry APIというのは私が勝手に呼んでる名前ですが、 HashMap::entry を起点にして使えるメソッド群のことを指しています。 これは「HashMap に に対応する値があればそれにXXし、なければYYする」をするときに使います。 例えば HashMap\u0026lt;String, Vec\u0026lt;String\u0026gt;\u0026gt; にキーに対応する値（Vec\u0026lt;String\u0026gt;）があれば新たな文字列をpushし、なければ空 Vec を作って新たに文字列をpushするという操作をしてみましょう。\n素直に HashMap::get_mut とパターンマッチを使って書くとこうなりますね。\n// 準備 letmutmap=HashMap::\u0026lt;String,Vec\u0026lt;String\u0026gt;\u0026gt;::new();letkey=\u0026#34;Hoge\u0026#34;.to_string();letvalue=\u0026#34;Huga\u0026#34;.to_string();// パターンマッチを使ったコード matchmap.get_mut(\u0026amp;key){Some(v)=\u0026gt;v.push(value),None=\u0026gt;{map.insert(key,vec![value]);}}; これをEntry APIを使えば以下のように1式で書けます。\n// 準備 letmutmap=HashMap::\u0026lt;String,Vec\u0026lt;String\u0026gt;\u0026gt;::new();letkey=\u0026#34;Hoge\u0026#34;.to_string();letvalue=\u0026#34;Huga\u0026#34;.to_string();// Entry APIを使ったコード map.entry(key).or_insert_with(||vec![]).push(value); 綺麗ですね。\n上記のコードをよく見ると1つ気付くことがあるかと思います。 map に対して key で検索している回数が2回から1回に減っています。こういった点も含めてEntry APIを深堀りしてみましょう。\nEntry API 先程みたとおり、 HashMap::entry から始まるAPIです。map.entry(key) のように、探したいキーを渡します。探した結果、なければそのままデータとして挿入するのに使うので、 \u0026amp;key ではなく key になっていることに注意してください。 entry の返り値は Entry になっています。。 この定義を見てみましょう。\npubenum Entry\u0026lt;\u0026#39;a,K: \u0026#39;a,V: \u0026#39;a\u0026gt;{/// A view into a single entry in a map, which may either be vacant or occupied. /// /// This `enum` is constructed from the [`entry`] method on [`HashMap`]. /// /// [`HashMap`]: struct.HashMap.html /// [`entry`]: struct.HashMap.html#method.entry #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]pubenum Entry\u0026lt;\u0026#39;a,K: \u0026#39;a,V: \u0026#39;a\u0026gt;{/// An occupied entry. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]Occupied(#[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]OccupiedEntry\u0026lt;\u0026#39;a,K,V\u0026gt;),/// A vacant entry. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]Vacant(#[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]VacantEntry\u0026lt;\u0026#39;a,K,V\u0026gt;),} Entry は列挙型で定義されていて、キーに対応する値を探した結果キーと値の組があればそれ（Occupied）、なければないことを表わす値（Vacant）をとります。一見 Option でよさそうに見えますが、もうちょっと複雑なことをやっています。\nさて、列挙型のの定義を紹介しましたが、実際にこの列挙子を直接使うことは稀でしょう。Entry に生えているメソッドを叩くことが多いです。 例えば冒頭に出てきた Entry::or_insert_with は「キーに対応する値があればそれを使い、なければ引数に渡されたクロージャを評価した値をハッシュマップに挿入した上で使う」という動作をします。これの兄弟メソッドに Entry::or_insert や Entry::or_default があります。 用途によって使い分けましょう。\nEntry APIの真価 説明が長くなるのでまずは使い方だけ説明しました。 しかしハッシュマップの動作原理を理解しているとEntry APIのありがたみというか、何をしているAPIなのかが分かります。\nハッシュマップの復習 ハッシュマップの動作原理完全理解とはいきませんが、知らない人のために少しだけ説明します。 以下の事実を知ってる人は飛ばして構いません。\n ハッシュマップはキーに対応づけられた場所にキーと値のペアを格納する ハッシュマップでキーに対応づけられた場所を探すのは多少の計算を要する  また、もっと詳しく知りたい方はOpen Data Structuresの和訳とかをあたって下さい。 因みにハッシュテーブルというかハッシュマップというか迷いましたが、ハッシュテーブルをマップとして使っているのでハッシュマップでいきます。\nまずはハッシュ関数をおさえましょう。 ハッシュ関数は与えられた値から、非負整数を算出する関数です。整数になるとコンピュータで扱いやすくなります。 このとき、「できるだけ値がバラける」ようにハッシュ関数を工夫します。「できるだけ」なので、値が被ることもあります。ハッシュ関数を h としたとき、例えば h(\u0026quot;Hoge\u0026quot;) = 2 、 h(\u0026quot;fuga\u0026quot;) = 110 、 h(\u0026quot;Fuga\u0026quot;) = 2 のような結果であることもあります。ハッシュ関数で計算した値をハッシュ値と呼びます。\nハッシュ関数が分かったところでハッシュマップに移りましょう。 ハッシュマップのデータの実体はただの配列です。配列の要素はキーと値のペアです。\nハッシュマップ +------+---- | K, V | ... +------+---- このハッシュマップにデータを挿入する処理をみてみましょう。 ハッシュマップにキー \u0026quot;Hoge\u0026quot; でデータを挿入しようとすると、まず \u0026quot;Hoge\u0026quot; のハッシュ値を計算します。 仮に 2 と出たとしましょう。すると配列の2番目をみにいきます。 これは空いているので無事データを書き込めて、ハッシュマップに \u0026quot;Hoge\u0026quot;, \u0026quot;fuga\u0026quot; というデータを保管できました。\nh(\u0026#34;Hoge\u0026#34;) = 2, 2番目のセルにデータを書く ハッシュマップ +------+------+----------------+----- | //// | //// | \u0026#34;Hoge\u0026#34;, \u0026#34;hoge\u0026#34; | ... +------+------+----------------+----- ↑ put data 値を取り出すときも同様です。 \u0026quot;Hoge\u0026quot; に対応する値が欲しいとします。 \u0026quot;Hoge\u0026quot; に対応するハッシュ値を計算して2を得ます。 そして配列の2番目のセルを見るとキーと値が格納されています。 配列内のキー \u0026quot;Hoge\u0026quot; と検索に使ったキー \u0026quot;Hoge\u0026quot; が一致しているのでこのセルで正解です。 という訳で対応する値 \u0026quot;hoge\u0026quot; を得ます。\nh(\u0026#34;Hoge\u0026#34;) = 2, 2番目のセルを見にいく ハッシュマップ +------+------+----------------+----- | //// | //// | \u0026#34;Hoge\u0026#34;, \u0026#34;hoge\u0026#34; | ... +------+------+----------------+----- ↑ get data これで h(\u0026quot;Hoge\u0026quot;) は操作できました。 ハッシュ値が \u0026quot;Hoge\u0026quot; と同じ \u0026quot;Fuga\u0026quot; はどうでしょう。 今までの方法だとハッシュ値に2が出て、そこに書こうとすると既に \u0026quot;Hoge\u0026quot; のデータがあります。\nh(\u0026#34;Fuga\u0026#34;) = 2, 2番目のセルにデータを書きたい ハッシュマップ +------+------+----------------+----- | //// | //// | \u0026#34;Hoge\u0026#34;, \u0026#34;hoge\u0026#34; | ... +------+------+----------------+----- ↑ 別のデータが既にある この場合の解決方法は色々ありますが、ここでは「空いてる場所に置く」という方法を紹介しておきます。\nh(\u0026#34;Fuga\u0026#34;) = 2, 2番目のセルにデータを書きたい ハッシュマップ +------+------+----------------+----------------+---- | //// | //// | \u0026#34;Hoge\u0026#34;, \u0026#34;hoge\u0026#34; | \u0026#34;Fuga\u0026#34;, \u0026#34;fuga\u0026#34; | ... +------+------+----------------+----------------+---- ↑ 2番目ではなく、近くの空いている場所に書く 「その場所は他のキーのハッシュ値とぶつかるのでは？」「他にもハッシュ値が被ったキーがあった場合どうするの？」など色々疑問が湧くかと思いますが、一旦忘れて下さい。 ハッシュマップは色々な変種があるのでそれぞれで対応方法が違います。 今回の目的はEntry APIの解説なので微には入らず次に進みます。\nEntry が表すもの ここまできたら Entry が表すものが分かりますね。「K, V があるはずの場所」です。 Entry が Occupied なら「ここにあります」、 Vacant なら「そこになければないですね」を表しています。\nh(\u0026#34;Hoge\u0026#34;) = 2, 2番目のセル ハッシュマップ `Occupied` ↓ +------+------+----------------+----- | //// | //// | \u0026#34;Hoge\u0026#34;, \u0026#34;hoge\u0026#34; | ... +------+------+----------------+----- ↑データがある `Vacant` ↓ +------+------+----------------+----- | //// | //// | ////////////// | ... +------+------+----------------+----- ↑データがない Entry に対して or_insert を呼ぶときは Occupied ならそこにある値を返せばいいですし、なければ or_insert の引数をその場に値を置いた上で返せばいいです。既に場所が確定したあとなので、値を置くのは一瞬です。 map.get_mut(\u0026amp;key) からの map.insert(key, value) と比べると場所を探す回数が2回から1回に減っています。\nEntry APIは、ハッシュマップの「場所を検索して値を返す」や「場所を検索して値を挿入する」の「場所を検索する」の部分を抜き出したAPIだと言えます。 因みにこのAPIを安全に提供できるのはRustの借用/所有権システムのおかげです。他言語でこれをやると、 Entry を保持している間にその「場所」に別の値を上書かれてしまった場合に破滅します。 Rustの場合は所有権のおかげで Entry がある間にハッシュマップを更新できなくなるので破滅を回避できます。 これを思いついた人すごいなーって思います。\nEntry APIの歴史的価値 余談になりますが、Entry APIにはもう1つの側面がありました。 古いRustではパターンマッチを用いた方のコードはコンパイルが通らなかったのです。\nRust 1.35.0で冒頭のコードをコンパイルしてみましょう。\n$ rustc +1.35.0 hashmap_entry.rs error[E0499]: cannot borrow `map` as mutable more than once at a time --\u0026gt; hashmap_entry.rs:11:13 | 8 | match map.get_mut(\u0026amp;key) { | --- first mutable borrow occurs here ... 11 | map.insert(key, vec![value]); | ^^^ second mutable borrow occurs here 12 | } 13 | }; | - first borrow ends here error: aborting due to previous error For more information about this error, try `rustc --explain E0499`.  これは昔のRustの借用検査が粗く、 match 式全体で map を借用していると判断していたためです。 「ハッシュマップの値を検索して、なければ値を挿入する」というありがちな操作でさえコンパイルエラーになるので初心者殺しのエラーでした。昔に比べるとRustも進化していますね。\nまとめ Rustの標準ライブラリのEntry APIについて解説しました。 Entry APIはハッシュマップの特性をRustの特徴を上手く使って設計されたAPIで興味をそそるものがあります。 HashMap を使うときは使ってみて下さい。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2020-05-23","title":"RustのHashMapはentryが便利","url":"https://KeenS.github.io/blog/2020/05/23/rustnohashmaphaentrygabenri/"},
  {"body":"κeenです。 ここ半年くらいTwitter上でプログラミングに入門してる人、入門してエンジニアとして働きはじめたばかりの人を観察していました。 そろそろ潮時かなと思ったので観察結果を報告します。\n観察結果をまとめようと思ったのは、どっかのタイミングで書こうと思っていたところに丁度いい記事が目に入ったからです。\n プログラミングスクールに通わず、プログラミングを学ぶ方法 プログラミングをともに学ぶ仲間をTwitterで探すのはやめておこう（追記）  私が初心者を観測していて、これらの記事と概ね同じ意見に至ったので補足説明として記事を書きます。\n観察に至るまで 結果を書く前に、どういう経緯で観察をはじめてどうやって観察対象を集めたかを記しておきたいと思います。\nモチベーション だいたいこの2ツイートに要約されます。\n小耳に挟んだ話なので眉唾ものなんですがXSSとかSQLインジェクションみたいな古典的な脆弱性が最近復活してきてるって聞いたんですよね。そういうところは歴史を繰り返しちゃいかんだと思うんですよ。本当かどうかは知りませんが。\n\u0026mdash; κeen (@blackenedgold) October 13, 2019 \n自分の周りに初心者が全然いないので、自分のいるエンジニアコミュニティの外で群れてるんだろうという仮説の下、積極的に探しにいくことにしました。 初心者コミュニティという意味では同じクラスタに属するかなと思ったので、既に入門は終わってエンジニアとして働いている人もつぶやいている内容によっては観察対象にしました。\nたまに知り合いにプログラミングのはじめ方を訊かれるので最近の入門方法を知っておきたいというのもあります。\n方法 それっぽいアカウントを探して非公開リストに突っ込んでいきました。 非公開にしたのは一方的に観察されると気分を悪くする人もいるかなと思ったからです。 こまめに観察対象を増やしていって、現時点で332人がリストに入っています。\nアカウントを探すときは最初は [プログラミング 初心者] とかのキーワードでTwitter検索をかけてみましたが、ダメでした。 実際の初心者よりもスクールや情報商材屋の方が多く引っ掛かり、まともに検索できませんでした。 [#駆け出しエンジニアと繋りたい] などの有名なタグも同様でした。\nもう少しまとも、少なくともプログラミング初心者を食い物にする人じゃなくて初心者がヒットするワードは [#今日の積み上げ] や各種スクールのタグなどでした。 しかし後述しますが、スクールのタグを使っている人はあまりプログラミングを勉強している風ではありませんでした。\n他には評判の高い [#Progate] のタグもありますが、今回の目的からすると少しノイズが多くて不便でした。 普通にエンジニアとして活躍している人も利用しているので初心者はそんなに多くなかったのです。 よくよく考えてみればちゃんと学習できるサービスなら早々に初心者を卒業できないといけないのでこれがあるべき姿だったのかもしれません。\nクラスターにリーチしたいという意味ではハブを狙うのが手っ取り早いのでWebで「プログラミング初心者が今すぐフォローすべき人○選」みたいなのを探したりもしました。 後で判明しますが、これは大失敗でした。 だいたい選ばれるのは情報商材屋なのですが、その人の周りにいるのはほとんどが信者なので駆け出しエンジニアというよりは駆け出し情報商材屋が多かったです。\n観察結果 ちょっと観察対象がよくなかった気がしますが、一応これで観察結果をまとめます。\nプログラミングをはじめる動機 やはり、現時点での仕事/待遇に不満があってエンジニアに転職するためにプログラミングを始める人が多いようです。 これには色々なタイプがいるので後回しにするとして、それ以外の動機を先に挙げましょう：\n 業界人: IT業界の非技術職、プロマネとかが仕事で扱うものを理解するために学習している 習い事感覚: ピアノや英会話と同じノリでプログラミングをやっている 暇だから: 産休、育休中だとか主婦だとかが暇潰しにやっている  今の時分だと自宅待機で暇という人もいるようです  副業のタネ: 休日に片手間で稼ぐ目的でプログラミングをやっている 大学生: 非情報系の学生が興味あってか就活のためかは知らないが勉強している  当初、ほぼ全員がエンジニアになる目的でプログラミングを勉強していると思っていたので趣味でやってる人をみつけて驚きました。 よくあるプログラミング初心者（というより初心者向けの教材）へのマウントに「そんなコード書く人とは仕事したくない」というのがありますが、そもそもエンジニアとして働く気がない人には意味のない行為ですね。 趣味には趣味なりのやり方があるので相手によって言葉を使い分けた方がよさそうです。まあ、そもそもどんな相手であれマウントはとってほしくないですが…。初心者はその分野の宝なので大切にしましょうね。\nさて、エンジニアになりたくてプログラミングを始めた人に話を戻しましょう。 そういう人からみると、エンジニアは以下のようなものらしいです。\n 人手不足なので引く手数多 高給取り リモートワークやフレックスタイムで柔軟な働き方ができる  実際、そういう働き方をしている人もいるので嘘ではなさそうですが、全員が全員そういう待遇な訳ではないというのは知っててほしいなとぼんやり思いながら眺めてました。\nよくあるストリーは、例えば\n 「ブラック企業に就職してしまい、脱出したいけどまともなスキルが身に付いてないから転職もできない。人手不足と聞いたのでエンジニア目指します」 「高卒ひきニートから人生一発逆転を目指してプログラミング始めました。年収一千万が目標です」 「誰にも縛られたくないのでリモートワークできる仕事がいい。フリーランスのエンジニアになって自由気ままに暮らしたい」 「子供の面倒みなきゃいけないのでフレックスタイムの職場希望です。エンジニアになったらフレックスタイムで働けるかな？」  産休/育休中に勉強してる人も   なんてのがあります。 人によって現状や期待するものにバラツキはあるので「それならいい選択かもね」って人もいれば「それはちょっと無茶じゃないかなぁ」って人もいます。 ここは一概には何ともいえませんね。\n他には「エンジニアだと待遇の男女差が少ない」というのを挙げている女性もいましたが、そもそも観測範囲に女性が少ないのでよくある動機なのかは定かではないです。\n年齢層は30〜40代が多いかなという印象です。20代が次ぐくらいで、50代はあまり見ないです。 スクールタグで収集したので、資金のある年代が多めだったのかもしれません。\n学習時間 だいたいの人は仕事が終わってから家で1、 2時間程勉強しているようです。忙しい人は週末にまとめてやったりもしてるようです。 この勉強時間で「3ヶ月で未経験からエンジニアに！」と言ってる人もいますが、これは流石に厳しいんじゃないでしょうか。 めちゃくちゃ速いケースで5ヶ月で転職に成功した例を見たことありますが、普通は1年以上かかりそうです。\n年末年始やGWに思い立って勉強をはじめた人もいますが、その後継続してる人はそんなにいないかな？\n一人一人を継続的に追跡できてないのでざっくりですが、自己申告を信じるならこんな感じです。\n日々の行動 ここでちょっと誤算があったのですが、一般的には毎日Twitterに投稿するのは重労働に分類されるらしく、日常を観測できているのは毎日投稿を続けられているごく一部のアカウントのみです。 さらに言えば若い人は目的別にアカウントを使い分ける傾向にあり、勉強用アカウントを作ったものの全然稼動してないというものが多いです。\nツイート内容は教材を進めた成果、おすすめの教材、おすすめの学習方法、おすすめのnote（情報商材）、Twitterの運用方法、「デキる人はXXをしてる」や「年収xxx万稼ぐならXXが必要」、「勘違いしてる人が多いけどエンジニアってのはXXなんだよ」系のコトバなどです。 その他日常や時事への言及など。技術情報のツイートはほぼないです。あるとしたら「この教材みててXXやったけどエラーになった。助けて」くらいです。\n利用している教材は、スクールのタグ経由で捕捉した人はその教材を、それ以外だとProgateが多いようです。 本を読んでる人はごく稀です。 曰く、本はスクールの月謝/Progateの1コースよりも高く、挫折したときのリスクが大きいからコスパが悪いそうです。 教材の善し悪しについて語っている人が少ないので、どれが良い教材なのかは分かりません。しかしやはりProgateはおすすめされやすいようです。\n学習している内容はWeb系の技術、HTML、CSS、JS、PHP、Railsあたりがほとんどです。GitとかGitHubの使い方もたまに流れてくるかな？ JSはjQueryをやってる人がそこそこいて、2020年やぞって気持になります。 しかしまあ、現実には未だにjQueryが現役で使われているところも多々あるようですし、食い扶持が欲しいならあながち間違った選択ではないのかもしれません。\n情報商材屋周辺だと、技術情報が流れてくることはあまりなくて、「それっぽいこと」を言ってることが多いです。先程も挙げた「面接でこういうことを言っちゃう人は採用されません」とか。 そしてTwitterの運用方法、フォロワー数の増やし方とかの情報をやりとりしてるようです。あとは有料noteやサロンへの案内がよく流れてきます。 エンジニアになりたいのではなく高収入を目指してる人が多いので、目の前にいる高収入の教祖様を真似た駆け出しの「駆け出しエンジニアをターゲットにした情報商材屋」がそこそこいるみたいです。 正直に告白しますと、最初のうちは私もこれらの人を駆け出しエンジニアと誤認して観察対象に入れてしまってました。 駆け出しエンジニアに擬態した情報商材屋が結構多いのです。\n私のタイムラインに流れてくるような技術ニュースがシェアされていることはまずないです。 稀にQiitaのURLが流れてくるくらい。 もちろん、現状に追い付こうとしている初学者が最新の技術動向を追う訳はないのですが、例えばテスラの新車の記事だとかXXという新しいサービスがあるだとかの技術者が興味を持ちがちな情報も全然流れてこないです。\n総じて、客観的にちゃんと勉強して身に付いているように見えるアカウントはそう多くありませんでした。 教材を進めた進捗はよくツイートされますが、成果物のURLだとか完成した画面だとかはほとんど見掛けません。 あるいは、勉強してたら当然ぶつかるような壁にぶつかって解決方法を探している、あるいは解決できたというTweetもあまりありません。 もちろん、中にはちゃんと勉強していそうなアカウントもありますし、目を瞠るような進捗を出している人もいます。 しかし多くの人には外から観測できる成果物はないようです。 わざわざ公開しないだけで手元で色々作ってる人もいるかと思いますが、私がほしかった「何を使って勉強したらどれくらいの技能が身につくのか」の情報は得られませんでした。\n未経験からエンジニアになれるのか？ よく分からなかったです。\n私が観測した範囲では観測期間中に「未経験からエンジニアになれました」って言ってた人はいませんでした。 リストのツイートを全部見てる訳ではないので見落してるだけかもしれませんが、やっぱりほとんど見掛けない程度には少ないようです。 よく、「思い付く人は100人いても実際にやり遂げる人は1人しかいない」って言われますよね。 この数字は適当だとは思いますが、仮に信じるとしましょう。 私の観測範囲が300人ちょっと、既にエンジニアとして働いてる人も含んでいますし、数ツイートしただけで稼動してないアカウントも入ってるので「未経験でプログラミングを今勉強している人」は200人くらいかもしれません。 そして観測期間が半年くらいなので、仮に1年勉強し続けると未経験からエンジニアに転職できるとすると、期待値は1人です。 だとすると実際にエンジニアになれたのが数えるほどなのは納得できます。\n因みに、正社員で働きはじめた人はいませんでしたが、フリーランスで案件取れたって言ってた人はいました。案件がその後どうなったかまでは追ってませんが。 フリーランスは発注する側も初心者が多くて、ひとまず単価を下げれば案件がとれそうな気がするのでまあ、妥当かなって気はします。\nここで疑問が湧くのが、エンジニアに転職した瞬間は目撃できてないのに「未経験から転職して今エンジニアやってます」って人は結構いる点です。 この人達はどこからやってくるのでしょうか。私の中で仮説がいくつかあります。\n 私が間違ったクラスタを観測している。 観測範囲が狭い。もっと大人数を観測すると転職した瞬間を目撃できる。 Twitterでは観測できない場所にいる。 「未経験からエンジニアになれました」って言ってるのは実は情報商材屋で、エンジニアではない。  情報商材屋周辺など、手を動かしてる人が少なそうな界隈を観測してるので間違ったクラスタを観測してる説が私の中では濃厚です。\n気付いたこと 観察結果から気付いたことや考察を書きます。\nスクール 「みんなやってる」くらいの情報しか得られませんでした。 やってるのは初学者ですし、教材の善し悪しを判断できないのも無理はないでしょう。 また、挫折した人は静かに消えていくので挫折率を計測するのも難しそうでした。\nツイート数でみるとTwitter投稿割引を実施しているスクールのユーザが多そうに見えます。 多そうに見えるだけで質の善し悪しは全く関係ないですが。\nいくつかのスクールは遵法意識がなかったり、受講者ともめごとを起こして訴訟沙汰になったりしてます。 しかしそういうスクールに限ってWebマーケティングが上手いのでどこ吹く風と受講者はそれなりにいるようです。\n情報商材屋 「未経験からエンジニアになる」をスローガンに色々情報を出してますが、具体的な技術や学習方法を提示してることはあまりないです。 それっぽいことを言って有料ノートを宣伝しています。サロンまで作ってるのは情報商材屋でも上位のみですね。\n私のタイムラインでは間違ったり未熟だったりする技術情報や現場の意見とは異なる意見を投稿している情報商材屋が叩かれるのをたまに目にしますが、それらはかなりマシな部類です。 少なくとも技術情報の話をしている。 多くの情報商材屋は（恐らくボロが出ないように）正誤を断じれるようなことはまず言いいません。\nその他 スクールやProgateなどの教材でグルグルしている人が多い気がします（Progateは2周するものらしいです）。それより先に進むには一定のハードルがありそうです。 そこより先のサポートがあればなあと思うのですが、どこでつまづいてるんでしょうね。\n技術書を読んでる人がほとんどいないのが気になります。 私はネット上の入門記事と技術書で勉強したのでみんな技術書を読むものだと思ってました。 ただ、私が勉強してた頃に学んだ記録をTwitterに書いてたかというと別にそうでもなかったので他の人も同様で、観測できてないだけな可能性も十分にあります。\nさっきも書きましたが、自分のタイムラインでシェアされている情報が出回ってることはほぼないです。 これは、まだ入門中だからということで仕方ないのかなぁという気がします。\n同じく、既存のエンジニアのコミュニティに入ってこない人が多いのも仕方ないのかなという気がします。 コミュニティを探すとかより前の段階の人が圧倒的に多いです。\nとはいえ、詰まったところを呟いたり、Qiitaの記事とかteratailとかスタック・オーバーフローとかは見ててもいいんじゃないかなって思わないでもないです。 好意的に捉えるなら教材の出来がよくて自分で調べる必要がないってことになるんですが、私はその説には懐疑的です。\nコードを書いてスキルを査定だとか、GitHub占い系のサービスの需要が分かった気がします。 まずそこでレベルを判定できる時点でかなり勉強が進んでいます。\nやっぱり定常的に手を動かしている人は稀です。少なくともTwitter上にはあまりいません。 このあたりはTwitterを使ってないだけという可能性もあるので確かなことは言えませんが。\n「毎日1、2時間の勉強」でどのくらいの期間があれば未経験からエンジニアになるのか知りたかったのですが、実際にエンジニアになれた人を観測してないので分かりませんでした。 半年の間で観測してないということは、もっと長い期間が必要なんだと思います。 個人的な感覚としても「毎日1、2時間の勉強」じゃずいぶん時間がかかるよなぁと思います。\nスクール講師の証言 ここで飛び道具ですが、知人のスクール講師に生徒層について聞いたので併せて書いておきます。\n貪欲独学タイプ： プロゲイトとかのフリー教材フル活用しまくって天井見えたら書籍買って何周かして、実際にポートフォリオ作って就活。 こういう人は大抵イベントとかもじゃんじゃか言ってるから身内採用されている場合がほとんど\n独学挫折タイプ： 貪欲独学タイプの方法を試しても詰んで、スクール検索して入会。スクールの教材をひたすら勉強。 こういう人は一回自分なりに挫折しているから行動が非常に消極的。 どこまでで業務レベルだとか、どうすれば転職できるかとかをすごく気にする。基本はエージェント転職\nインフルエンサータイプ： 金を稼ぎたいとか、楽に稼げるっていう謳い文句のSNS経由でサロンなどに入会。 学習方法は貪欲独学タイプも独学挫折タイプもどちらもいるが、外に対しておらつきがち。 イベントというよりはtwitterなどのSNSが活発で、なぜか「エンジニアになったぞ」と言いつつ情報商材作り出すブロガーになる感じ\n一番最後がとっても厄介\nエンジニアとしてどういうプログラムを書いているよみたいなアウトプットじゃなくて、エンジニア稼げるわろたwみたいな記事ばっか量産する\n個人的には、エンジニアになったってよりかは自分のブログ作れるくらいのにわか技術はつけて、あとはブロガーなりますって感じがすごい\nスクールで実際に生徒面談すると、６割以上は独学してるね（ある程度までは勉強してる）。 後の４割は、やろうとしてほんまに初手で詰んだって感じ\n独学挫折タイプは、これでいうと６割に入る。 ４割の挫折勢はもはや挫折ですらない、IT知識の問題レベルの人たち\nスクールの客引き方法がそもそも技術記事で、わからなかったらコチラーみたいな言い方が多いのもあるかも知れん。\nあと、ほんまもんの初心者はサロンに入る方が多いらしい。\n技術に興味あって足突っ込んだ人は技術記事調べて詰んでスクールへ吸収\n金に興味あってとか楽に稼ぎたくて勢は最初からそういう釣り記事読んでサロン入ってオラオラって感じ\nXXX（自主規制）に限ってはスクールという名前のサロンになりつつあって同業種的にほんま怖い\nでもなんかあれなんだよね。 周り見てると感覚、SNSとかに浮上するのってめっちゃ初心者の時かめっちゃ強強になった時のみな感じする。 分断というよりは、初心者だった人たちはどっかのタイミングを経てふっとちゃんとしたエンジニアになってってる感じある\n私の観測結果とおおむね一致していますが、「スクールの生徒の6割は一旦独学してる」などの新情報もありました。 そういや「独学で限界を感じたのでスクールに入会しました」というプロフィールの人がちょくちょくいました（完全に頭から抜けてた）。\nまとめ Twitter上で300人程度のプログラミング初心者を半年ほど観察した記録を書きました。 ある程度雰囲気は掴めたのですが、あまり有力な情報を得られなかったのでもう少し大規模に、長期間観察する必要がありそうです。 また、観測するクラスタを間違えたような気がするのでもっと良いクラスタをご存じの方は教えて下さい。\n私がプログラミングを勉強した7、8年前と比べると環境はずいぶん改善したものだと思ってました。 しかし蓋を開けてみると得体の知れないスクールや情報商材屋が跳梁跋扈し、適切に情報を選択する難易度はむしろ上がっているようにも思えました。 また、門を叩いてからくぐるまではそりなりにサポートされるようになったものの、それより先で迷子になっている人が多いようにも感じました。 このあたりで改善の余地がありそうです。\nスムーズに勉強が進む人が増えるといいですね。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2020-05-20","title":"Twitter上のプログラミング入門者観察記","url":"https://KeenS.github.io/blog/2020/05/20/twitteruenopuroguramingunyuumonshakansatsunikki/"},
  {"body":"κeenです。「強めに型をつける」シリーズです。 いつか書こうと思って後回しにしてたら全然書かなかったので寝れない夜に筆をとります。 特にスクリプト言語を使ってた人にありがちな「なんでも文字列」について。\nスクリプト言語だと文字列の扱いが簡単ですし、操作する関数も色々あるのでついつい何にでも文字列を使ってしまいがちです。\n例えば状態をあらわすのに文字列を使ったりしてませんか？\n// \u0026#34;朝\u0026#34;, \u0026#34;昼\u0026#34;, \u0026#34;夜\u0026#34;で時間帯を表わす fn hello(period: \u0026amp;str)-\u0026gt; \u0026amp;str {// 文字列にパターンマッチできる。便利！ matchperiod{\u0026#34;朝\u0026#34;=\u0026gt;\u0026#34;おはようございます\u0026#34;,\u0026#34;昼\u0026#34;=\u0026gt;\u0026#34;こんにちは\u0026#34;,\u0026#34;夜\u0026#34;=\u0026gt;\u0026#34;こんばんは\u0026#34;,// Rustがエラーを出すのでそれ以外の場合も処理しておく _=\u0026gt;unreachable!(),}} あるいは、構造を表わすのにも文字列を使ったりしてませんか？ 例えば座標 $(1,1)$ を表わすのに \u0026quot;1,1\u0026quot; を使うだとか。 流石に座標でこれをやる人は少ないでしょうが（私はRubyでやったことがあります）、URLとかだとやったことがある人もいるんじゃないでしょうか：\n# rubyだと正規表現が便利なのでこういう書き方をしたことがある人もいるかも url = \u0026#34;https://example.com/foo/bar\u0026#34; domain = url[/(https?):\\/\\/([a-zA-Z0-9.]+)/, 2] こういうのは気軽に使えて便利な一方、特に静的型付き言語ではデメリットもあります。\n バリデーションをいつ行っているか分かりづらい 構造のパースが何度も走って無駄  URLのように仕様が複雑なものだと間違ってパースする可能性が高い パース処理があちこちに散らばるのでフォーマットの変更に弱くなる  メソッドを呼ぶときに何を期待しているのか、型を見ただけでは分かりづらい どのタイミングでも不正な入力を渡せてしまうので、常に例外のことを考えないといけない  加えて、Rustでは文字列処理はスクリプト言語ほど気軽ではないのでただただつらいだけになります。 こういうところでは用途ごとに型を定義してあげて、それを使うことで上記のデメリトを解消できます。\n最初の hello の例だとこうですね。\n// 期待する値しかとらないデータ型を定義しておく enum Period{Morning,Day,Night}fn hello(period: Period)-\u0026gt; \u0026amp;\u0026#39;static str {usePeriod::*;matchperiod{Morning=\u0026gt;\u0026#34;おはようございます\u0026#34;,Day=\u0026gt;\u0026#34;こんにちは\u0026#34;,Night=\u0026gt;\u0026#34;こんばんは\u0026#34;,// enumなので期待しない値のことは考慮しなくてよくなる }} 3種類のラベルしか受け取らないなら、3種類の値しかとらない enum を定義してあげます。 簡単ですね。パターンマッチでも例外的な値のことを考えなくてすみます。\n座標は \u0026quot;1,1\u0026quot;ではなくて Point 型を作るほうがよさそうです。\n// 文字列に構造があるなら、構造体を作ったほうがいい struct Point(i32,i32);Point(1,1) URLの例だと、外部ライブラリ、 urlなんかを使います。\n// Rustだと外部ライブラリを使った方が便利 useurl::Url;leturl=Url::parse(\u0026#34;https://example.com/foo/bar\u0026#34;).expect(\u0026#34;invalid url format\u0026#34;);letdomain=url.domain(); あとは外部とのやりとりのために文字列とデータ型を行き来するだけです。 外部とのやりとりのとこでだけフォーマットのパースや値のバリデーションを行い、残りのプログラムでは綺麗な世界だけでプログラミングができます。\n私感ですがRustの文字列処理が難しいといっている人の何割かは不要に文字列を使ってるせいで難しくなってるんじゃないかと思っています。 もちろん、Rustでは文字列に String と \u0026amp;str があったり \u0026amp;str のライフタイムを考えたりと扱いが難しいことは否定しません。 ただ私がRustを書いていて文字列処理をすることはそう多くないので、やたら文字列をこねくり回してるなーと思ったら一度本当に文字列が適切か見直してみてもいいんじゃないでしょうか。\n","categories":["Rust","rustで強めに型をつける"],"category_urls":["/categories/rust","/categories/rust%e3%81%a7%e5%bc%b7%e3%82%81%e3%81%ab%e5%9e%8b%e3%82%92%e3%81%a4%e3%81%91%e3%82%8b"],"date":"2020-05-14","title":"Rustで強めに型をつけるPart 5: 「なんでも文字列」をやめる","url":"https://KeenS.github.io/blog/2020/05/14/rustdetsuyomenikatawotsukerupart_5___nandemomojiretsu_woyameru/"},
  {"body":"# rust-analyzerの紹介 ---------------------- [下町.rs #1 (オンライン） - connpass](https://shitamachi.connpass.com/event/173972/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # rust-analyzer --------------- * 最近開発が盛んなRustのIDEバックエンド + この発表より先に紹介記事でてきちゃった… https://rust-analyzer.github.io/blog/2020/04/20/first-release.html * 最近alphaがリリースされたよ 最近成熟してきているrust-analyzer、勧告が提案されてる\nTransition to rust-analyzer as our official LSP (Language Server Protocol) implementation by nikomatsakis · Pull Request #2912 · rust-lang/rfcshttps://t.co/O0Wvi4nGAL\n\u0026mdash; κeen (@blackenedgold) April 23, 2020 === # RustのIDEバックエンド ----------------------- * 昔: racer * 今: rls * 未来: rust-analyzer === # rlsとLSP ----------- * rlsのバックグラウンドについておさらい * LSP: IDEバックエンドのプロトコル * rls: RustのLSPサーバ + rust language server + 現在公式の推奨ツール + みんな使ってるよね？ === # LSP ----- * [これ](https://microsoft.github.io/language-server-protocol/) * Microsoft主導で策定したIDEバックエンドのプロトコル + JSON RPCベース * コーディング支援をIDE（フロントエンド）と解析ツール（バックエンド）に分離する * 型とかドキュメントとか定義ジャンプとか * 言語解析が必要なので言語ごとに必要 * 一回バックエンドツールを作れば使い回せる === # LSP ![lspとエディタ、バックエンドの関係](/images/lsp.png) === # 余談1: rust survey ------------------- * [Rust Survey 2019 Results | Rust Blog](https://blog.rust-lang.org/2020/04/17/Rust-survey-2019.html) * Rustの使用歴とか開発環境とかのアンケート * エディタ（IDE）はVSCode, Vim, IntelliJが3大巨頭でEmacs, Sublimeが次ぐくらい * IDEバックエンドは43%がrls, 21.7%がIntelliJ, 15.2%がrust-analyzer === # 余談2: IntelliJ Rust ----------------------- * IntelliJ Rustは自前でRustを解析している * rlsもrust-analyzerも使ってない * あとフォーマッタも独自っぽい + それはちょっと… === # IDEバックエンド比較 ---------------------  ツール開発適用範囲特徴 rls公式LSPコンパイルして中間生成物としてIDE向けの情報を出す（遅い） IntelliJ RustJetBrainIntelliJでのみ使える編集にあわせてオンデマンドで情報を出す（速い） rust-analyzer公式LSP編集にあわせてオンデマンドで情報を出す（速い）。開発途上  === # library-ification ---------------- * rls → rust-analyzerは単にフルスクラッチしただけではない * Rustコンパイラを周辺ツールフレンドリに再構成する流れもきてる + [library-ification](https://smallcultfollowing.com/babysteps/blog/2020/04/09/libraryification/) + [demand-driven compilation](https://rustc-dev-guide.rust-lang.org/query.html) * 例えば[Chalk](https://blog.rust-lang.org/inside-rust/2020/03/28/traits-sprint-1.html)とか === # 使ってみた ------ * 少しだけrust-analyzer使ってみた * 感覚的に、慣れもあってrlsの方が使いやすい気がする + 補完とか賢い気がする…？ * rust-analyzerはコマンドがいっぱいあって便利 + 今後の発展に期待 === # デモ ------- === # まとめ -------- * rust-analyzerはRustの新しいlspサーバだよ * 荒削りだけど現時点でもrlsより優れているところもあるよ * 見えづらいけどコンパイラ言語以外の面でも進化してるよ + 言語は総合力！ * 多分そのうち公式になるから覚えておいてね   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2020-04-27","title":"rust-analyzerの紹介","url":"https://KeenS.github.io/slide/rust_analyzernoshoukai/"},
  {"body":"κeenです。 先日の記事で言及した最小限のELFが需要ありそうだったので解説してみます。 コンパイラを作るときの参考にしてみて下さい\nELFはExecutable and Linkable Formatを表わし、Linuxなどで標準の実行可能ファイルのフォーマットとなっています。 なんらかの形でこのファイルを生成するのがコンパイラの最終目標となります。 一般にはアセンブラまで吐いて外部のアセンブラやリンカにELFファイルの生成を任せることが多いのですが、自作するなら最後までやりたいという人向けにとっかかりになる最小限のELFファイルを解説します。 まずはこのファイルを生成するのを目指して、後から色々追加していけばインクリメンタルにできるよね、という訳です。\n一部、「どうしてかは分からないけどこうしたら動く」みたいな箇所もあるので詳しい人がいたら教えて下さい。\n全体構成 プログラムそのものの他に、プログラムのメタデータ2種類とファイルのメタデータが1つついています。\nフォーマットはおおむね以下のような形になっています。\n+------------------------+ | ELF header | +------------------------+ |+----------------------+| || Program header table || |+----------------------+| ||+--------------------+|| ||| ||| ||| data ||| ||| ||| ||+--------------------+|| |+----------------------+| || Setion header table || |+----------------------+| +------------------------+ ELFヘッダファイル全体のメタデータで、ELFのバージョンだとか、アーキテクチャだとか、プログラムヘッダテーブルやセクションヘッダテーブルの位置だとかを保持しています。\nプログラムヘッダは実行時に関係するメタデータを持っています。プログラムをメモリアドレスのどこにロードするだとかを指定します。\nセクションヘッダはリンク時に使う情報を保持しています。プログラムのここからここまでが何々という関数で〜のような情報を指定します。リンクの他にはGDBでデバッグするときの情報なんかも入ってるのかな？\nプログラムヘッダとセクションヘッダはそれぞれ独立しているので1つのプログラムに対して別々にメタデータを指定します。極端な話、全然違う領域にメタデータをつけたり片方がなかったりしても問題ないのですが、だいたいのELFはプログラムヘッダが指定した領域を細分するようにセクションヘッダがついているようです。\nプログラムヘッダ「テーブル」、セクションヘッダ「テーブル」とあるように、ELFファイル内でそれぞれのヘッダは複数あります。テーブルというかプログラム的な見方をすれば配列ですね。\n今回は実行だけできればいいのでセクションヘッダは利用せずにプログラムヘッダだけでいきます。つまり、こうなります。\n+------------------------+ | ELF header | +------------------------+ |+----------------------+| || Program header table || |+----------------------+| ||+--------------------+|| ||| ||| ||| data ||| ||| ||| ||+--------------------+|| |+----------------------+| +------------------------+ 実際のデータ べんっと貼ります。Linux on amd64向けのELFファイルです。\n00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000 .ELF............ 00000010: 0200 3e00 0100 0000 b000 4000 0000 0000 ..\u0026gt;.......@..... 00000020: 4000 0000 0000 0000 0000 0000 0000 0000 @............... 00000030: 0000 0000 4000 3800 0200 4000 0000 0000 ....@.8...@..... 00000040: 0600 0000 0400 0000 4000 0000 0000 0000 ........@....... 00000050: 4000 4000 0000 0000 4000 4000 0000 0000 @.@.....@.@..... 00000060: 7000 0000 0000 0000 7000 0000 0000 0000 p.......p....... 00000070: 8000 0000 0000 0000 0100 0000 0500 0000 ................ 00000080: 0000 0000 0000 0000 0000 4000 0000 0000 ..........@..... 00000090: 0000 4000 0000 0000 bc00 0000 0000 0000 ..@............. 000000a0: bc00 0000 0000 0000 0000 2000 0000 0000 .......... ..... 000000b0: b83c 0000 00bf 0000 0000 0f05 .\u0026lt;.......... 思ったより小さいですね。\nxxd で出力しているので、 xxd -r でバイナリに逆変換できます。\n$ xxd -r \u0026lt;\u0026lt;EOF \u0026gt; elf data EOF $ chmod +x elf $ ./elf さて、これだけだと分かりずらいのでもうちょっと分解してみましょう。 ELFヘッダ、プログラムヘッダ2つ、実際のプログラムが入っています。\n+-----------------------------------------+ 00000000:| 7f45 4c46 0201 0100 0000 0000 0000 0000 | 00000010:| 0200 3e00 0100 0000 b000 4000 0000 0000 | ELFヘッダ 00000020:| 4000 0000 0000 0000 0000 0000 0000 0000 | 00000030:| 0000 0000 4000 3800 0200 4000 0000 0000 | +-----------------------------------------+ +-----------------------------------------+ 00000040:| 0600 0000 0400 0000 4000 0000 0000 0000 | 00000050:| 4000 4000 0000 0000 4000 4000 0000 0000 | プログラムヘッダ1 00000060:| 7000 0000 0000 0000 7000 0000 0000 0000 | 00000070:| 8000 0000 0000 0000 +-------------------+ +---------------------+ +---------------------+ +-------------------+ 0100 0000 0500 0000 | 00000080:| 0000 0000 0000 0000 0000 4000 0000 0000 | プログラムヘッダ 2 00000090:| 0000 4000 0000 0000 bc00 0000 0000 0000 | 000000a0:| bc00 0000 0000 0000 0000 2000 0000 0000 | +-----------------------------------------+ +-----------------------------------------+ 000000b0:| b83c 0000 00bf 0000 0000 0f05 | プログラム +-----------------------------------------+ これをそれぞれ見ていきます。\nWikipediaも併読書としてご利用下さい。\nELFヘッダ ほとんど固定値が入ります。全部で0x40バイトあります。\n意味を持つデータ単位で区切るとこんな感じです。\n1 2 3 4 5 6 7 +-------------------+----+----+----+----+----+----------------------------------+ 00000000:| 7f 45 4c 46 | 02 | 01 | 01 | 00 | 00 | 00 00 00 00 00 00 00 | +-------------------+----+----+----+----+----+----------------------------------+ 8 9 10 11 +---------+---------+-------------------+---------------------------------------+ 00000010:| 02 00 | 3e 00 | 01 00 00 00 | b0 00 40 00 00 00 00 00 | +---------+---------+-------------------+---------------------------------------+ 12 13 +---------------------------------------+---------------------------------------+ 00000020:| 40 00 00 00 00 00 00 00 | 00 00 00 00 00 00 00 00 | +---------------------------------------+---------------------------------------+ 14 15 16 17 18 19 20 +-------------------+---------+---------+---------+---------+---------+---------+ 00000030:| 00 00 00 00 | 40 00 | 38 00 | 02 00 | 40 00 | 00 00 | 00 00 | +-------------------+---------+---------+---------+---------+---------+---------+ それぞれの番号で説明していきます。\n マジックナンバー。ELFファイルであることを表わす。7f 45 4c 46固定。 クラス。32bit = 0x01、64bit = 0x02。ここでは64向けなので0x02。 エンディアン。little endian = 0x01、big endian = 0x02。ここではlittle endianで0x01。以降のマルチバイトの数値はリトルエンディアンで解釈される。 バージョン。0x01。 OS ABI。どれが何に対応するかはWikipediaの通りだが、多くの場合で0x00（要出典）らしいので0x00にする。 ABIの細かなバージョン。LinuxかつOS ABIに0x00を指定していれば無視されるらしい。 空き領域。 オブジェクトのタイプ。今回はシンプルな実行可能ファイルなので0x02。libcをダイナミックリンクしたりするなら0x03かな？ マシンタイプ。amd64なので0x3e。 バージョン。0x01。バージョンが登場するの2回目な気がするんですけどなんででしょうね。 プログラムのエントリポイント。ここから実行がはじまる。プログラムヘッダでどこにロードするかに依るが、今回は0x4000b0（後述） ファイル内でのプログラムヘッダの位置。ELFヘッダの直後に始まっているので0x40。 ファイル内でのセクションヘッダの位置。今回はセクションヘッダはないので0x00。 フラグ。ターゲットアーキテクチャ依存でなんか読まれるらしい。よくわからないので0x00。 このヘッダのサイズ。0x40。 プログラムヘッダのサイズ。64bitなので0x38。 プログラムヘッダの数。今回は0x02。 セクションヘッダのサイズ。64bitなので0x40。 セクションヘッダの数。今回は0x00。 セクション名を管理するセクションヘッダのセクションヘッダテーブル内のインデックス。今回は存在しないので0x00を入れといた。  11のエントリポイントについて補足します。今回はこのあとに続くプログラムヘッダでELFファイル全体を0x400000にロードしています。そしてELFファイル内でプログラムは0xb0から始まっているので0x400000に0xb0を足して0x4000b0という訳です。\nこれらの値は readelf -h で確認できます。\n$ readelf -h elf ELF ヘッダ: マジック: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 クラス: ELF64 データ: 2 の補数、リトルエンディアン Version: 1 (current) OS/ABI: UNIX - System V ABI バージョン: 0 型: EXEC (実行可能ファイル) マシン: Advanced Micro Devices X86-64 バージョン: 0x1 エントリポイントアドレス: 0x4000b0 プログラムヘッダ始点: 64 (バイト) セクションヘッダ始点: 0 (バイト) フラグ: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 2 Size of section headers: 64 (bytes) Number of section headers: 0 Section header string table index: 0 プログラムヘッダ1 続いてプログラムヘッダ1です。これはプログラムヘッダのある領域のメタデータです。 ぶっちゃけ、このプログラムヘッダが必要なのかよく分かってないのですが、ないと動かなかったので置いています。 詳しい方、どうしてか教えて下さい。\n1 2 3 +-------------------+-------------------+---------------------------------------+ 00000040:| 06 00 00 00 | 04 00 00 00 | 40 00 00 00 00 00 00 00 | +-------------------+-------------------+---------------------------------------+ 4 5 +---------------------------------------+---------------------------------------+ 00000050:| 40 00 40 00 00 00 00 00 | 40 00 40 00 00 00 00 00 | +---------------------------------------+---------------------------------------+ 6 7 +---------------------------------------+---------------------------------------+ 00000060:| 70 00 00 00 00 00 00 00 | 70 00 00 00 00 00 00 00 | +---------------------------------------+---------------------------------------+ 8 +---------------------------------------+ 00000070:| 80 00 00 00 00 00 00 00 | +---------------------------------------+ プログラムヘッダは構成がおおぶりで解説が楽ですね。\n プログラムヘッダのタイプ。プログラムヘッダそのものの領域を指示する(PT_PHDR)ので0x00000006。 セグメントに依存したフラグ。Linuxのヘッダファイルを読む限り0x01 = executable、0x02 = writable、0x04 = readableで今回はread onlyの指定で0x04。 ファイル内でのセグメントのオフセット。プログラムヘッダはELFヘッダの直後（0x40）から始まってるので0x40。 メモリ内での仮想アドレス。セマンティクスがよく分からないが、恐らく「メモリ内のどこに存在するか」。ELFファイルを0x400000にロードして、プログラムヘッダは0x40から開始するので0x400040。 メモリ内での物理アドレス。物理アドレスが関係するOS向けらしく、Linuxには関係ない。他のELFを見たら仮想アドレスと同じ値を設定していたのでそれに倣った。 セグメントのファイル内のサイズ。プログラムヘッダが2つあるので 0x38 + 0x38 = 0x70。 セグメントのメモリ内のサイズ。ファイル内のサイズと同じく0x70。 アラインメント。2の羃な値を指定する。どの値が適当か分からなかったので適当に0x80を入れた。0x08を指定してしているファイルもあったしもっと小さくてもよさそう。  プログラムヘッダ2 1と同様に2も解説していきます。2は、プログラムをメモリにロードする方法を指示します。\n1 2 +-------------------+-------------------+ | 01 00 00 00 | 05 00 00 00 | +-------------------+-------------------+ 3 4 +---------------------------------------+---------------------------------------+ 00000080:| 00 00 00 00 00 00 00 00 | 00 00 40 00 00 00 00 00 | +---------------------------------------+---------------------------------------+ 5 6 +---------------------------------------+---------------------------------------+ 00000090:| 00 00 40 00 00 00 00 00 | fe 00 00 00 00 00 00 00 | +---------------------------------------+---------------------------------------+ 7 8 +---------------------------------------+---------------------------------------+ 000000a0:| fe 00 00 00 00 00 00 00 | 00 00 20 00 00 00 00 00 | +---------------------------------------+---------------------------------------+ バイト数や構成は1と変わらないですね。\n プログラムヘッダのタイプ。ロードする領域を指示する(PT_LOAD)ので0x00000001。 セグメントに依存したフラグ。Linuxのヘッダファイルを読む限り0x01 = executable、0x02 = writable、0x04 = readableで今回はread + executableの指定で0x05。 ファイル内でのセグメントのオフセット。ファイルの先頭から読むので0x00。 メモリ内での仮想アドレス。セマンティクスがよく分からないが、恐らく「メモリ内のどこにロードするか」。 メモリ内での物理アドレス。物理アドレスが関係するOS向けらしく、Linuxには関係ない。他のELFを見たら仮想アドレスと同じ値を設定していたのでそれに倣った。 セグメントのファイル内のサイズ。ファイルサイズに等しく、今回は0xbc。 セグメントのメモリ内のサイズ。ファイル内のサイズと同じく0xbc。 アラインメント。2の羃な値を指定する。他のELFファイルに倣って0x200000を入れた。  プログラムヘッダは readelf -l で読み取ることができます。\n$ readelf -l Elf ファイルタイプは EXEC (実行可能ファイル) です エントリポイント 0x4000b0 There are 2 program headers, starting at offset 64 プログラムヘッダ: タイプ オフセット 仮想Addr 物理Addr ファイルサイズ メモリサイズ フラグ 整列 PHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040 0x0000000000000070 0x0000000000000070 R 0x80 LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x00000000000000bc 0x00000000000000bc R E 0x200000 libcをダイナミックリンクする際はタイプに PT_DYNAMIC や PT_INTERP を指定するプログラムヘッダが入るっぽいです。\nプログラム ただのアセンブラなんですが、解説しますね。 手作りのELFファイルでは通常Cを書くときに使う main のような高級なものはありません。 そういうのはcrt1.oというファイルに既述されており、Cのファイルをコンパイルするときに暗黙的にリンクされます。これをリンクしていないので開始から終了まで全て自分の手書きです。\nつまり、プログラムを終了させるのも自分で書かなければなりません。それをアセンブラで書いたのがこれです。 exit(0) 相当のアセンブラです。\nmov rax, 60 mov rdx, 0 syscall +------------------------+------------------------+---------+ 000000b0:| b8 3c 00 00 00 | bf 00 00 00 00 | 0f 05 | +------------------------+------------------------+---------+ ということでこのファイルを実行すると「無事」exit status 0で終了します。\nまとめ ひとまず、最小限に動くELFファイルの全てのバイトを解説しました。 まだよく分かってないところもあったり、セクションヘッダを扱ってなかったりするので不十分なところもあるでしょうが、何かのとっかかりになれば幸いです。\n","categories":["ELF","compiler"],"category_urls":["/categories/elf","/categories/compiler"],"date":"2020-04-12","title":"最小限のELF","url":"https://KeenS.github.io/blog/2020/04/12/saishougennoelf/"},
  {"body":"κeenです。今朝、エイプリルフールのネタ記事を書いたのでそのタネ明かしをします。タネとはいっても、ほぼ手書きなんですけどね。\nWhitespaceはEdwin BradyとChris Morrisにより2003年4月1日に発表された言語です。 この言語自体エイプリルフールのジョークなんですね。 公式ページはあるのですが、繋がらないのでWebArchiveとかからアクセスして下さい。\n特徴としては空白文字、タブ文字、改行文字だけで構成されているのでパッと見では何も書いてないようになる点があります。 いわゆるesoteric languageです。\n今回の私のエイプリルフールのジョークは、Whitespaceを知らない人には「正直者にしか見えないコードですか？」、Whitespaceを知ってる人には「Whitespace！？んなもん書ける書けるわけないだろ！あ、そうか今日はエイプリルフールか」、私を知ってる人には「Whitespaceのコンパイラは普通はありえないけどコイツならやりかねない」と思われそうな絶妙なラインを狙ったつもりです。 最終的にはちゃんと動く処理系を出してるのでジョークかどうかやや怪しいですが楽しんでいただけたなら幸いです。 因みにソースコードは4000コマンド近くあります。\n空白だと意思伝達に難があるので、以降この記事内では空白文字、タブ文字、改行文字をそれぞれ s 、 t 、 n と表記します。\nWhitespaceの詳細 Whitespaceは命令型のスタックマシンです。ヒープも扱えます。値は任意長の整数のみです。\nそれぞれのコマンドの前には命令修飾パラメータ（Instruction Modification Parameter、IMP）がつきます。 IMPは5つあり、コマンドの種類を大別しています。\n   IMP 分類     s スタック操作   ts 算術   tt ヒープアクセス   n 制御構造   tn I/O    それぞれのIMP毎にコマンドがあります。また、コマンドによってはパラメータを取ります。 パラメータには数値とラベルがあります。\n数値は符号（s が+で t が-）に続いて2進数（s が0で t が1）を書き、 n で終端します。2の補数表現ではないので注意して下さい。\nラベルは s と t の文字列で、 n で終端します。\n以下に、コマンドを列挙します。 名前がないと不便なので名前もつけておきます。これは私独自のものなので注意して下さい。\nスタック操作    コマンド 別名 パラメータ 操作     s push 数値 スタックに数値をプッシュする   ns dup  スタックトップを複製する   ts copy 数値 スタックのトップからn番目の値をスタックトップにコピーしてプッシュする   nt swap  スタックのトップ2値を入れ替える   nn discard  スタックのトップの値を捨てる   tn slide 数値 スタックのトップの値を残してn個の値を捨てる    このうち、 copy と discard は Whitespace 0.3で追加されたコマンドだそうです。\nこれら2つのコマンドはキモチとしては、ローカル変数用のコマンドです。 関数は引数に与えられた値からスタックがスタートします。\n| v1 | | v2 | | v3 | +-----+ これらの値をcopyで参照しながら関数を実行します。\n| v3 |\u0026lt;-+ | v | | | v1 | | copy 3 | v2 | | | v3 |+-+ +-----+ で、最後にローカル変数の上に返り値を作ります。\n| ret | | v1 | | v2 | | v3 | +-----+ この状態でdiscardを呼ぶと、キレイに返り値を呼び出し元に返せる訳です。\ndiscard 3 | ret | +-----+ 算術 2値消費して1値を生成するコマンドです。\n   コマンド 別名 パラメータ 操作     ss add  足し算 (top[1] + top[0])   st sub  引き算 (top[1] - top[0])   sn mul  掛け算 (top[1] * top[0])   ts div  割り算 (top[1] / top[0])   tt mod  乗余算 (top[1] % top[0])    ヒープアクセス    コマンド 別名 パラメータ 操作     s store  ヒープに値を保存する (heap[stack[1]] \u0026lt;- stack[0] )   t retrieve  ヒープから値をとってくる (stack.push(heap[stack[0]]))    制御構造    コマンド 別名 パラメータ 操作     ss label ラベル プログラムにラベルをつける   st call ラベル コールスタックに今のプログラムの場所を記録し、ラベルに飛ぶ   sn jump ラベル ラベルに飛ぶ   ts jz ラベル スタックトップが0ならラベルに飛ぶ   tt jneg ラベル スタックトップが負ならラベルに飛ぶ   tn ret  callに呼応し、記録されたプログラムの場所に戻る   nn end  プログラムを終了する    call と ret があるので思ったよりマトモなプログラミングができます。\nI/O    コマンド 別名 パラメータ 操作     ss outchar  スタックトップを文字として出力する   st outnumber  スタックトップを数値として出力する   ts readchar  文字を読んで、ヒープの指定されたアドレスに置く   tt readnumber  数値を読んで、ヒープの指定されたアドレスに置く    その他 エッジケースの仕様が与えられてないので実装から紐解きます。\nリファレンスにできそうな実装は、WebArchiveから辿れるオリジナル（Haskell実装）と、Whitespace作者によるIdris実装があります。これらを読んでみます。\n 未初期化のヒープを読んだときは0が返るときと返らないときがあるぞい  Idris実装は0を返してる。Haskell実装今までにstoreしたヒープアドレスの最大値以下なら0、最大値を越えると例外っぽい  スタックの底をついたときは未定義っぽい  Idris実装は0を返して、Haskell実装は例外  存在しないラベルにジャンプしようとするのは未定義っぽい  Haskellは実行時エラー、つまり存在しないラベルにジャンプするコマンドにさしかかったところでエラー Idrisは検査エラー、つまり実際には実行されないコマンドでも実行に入る前にエラーになる  outcharとreadcharの細かな仕様が不明  それぞれHaskellとIdrisが数値\u0026lt;-\u0026gt;文字変換でできるもののみ扱える。 実質ASCIIのみ？  readnumとreadcharのEOFの扱いが不明  多分エラー。でもEOFは扱えてほしいな…。   因みにHaskell実装は手元にGHC処理系がなくて、Idris実装は最新版のIdrisコンパイラでコンパイルできないのでどちらもコンパイラ作成には使ってないです。\nあ、あとs 、 t 、 n 以外の文字はコメント扱いで無視されます。\nところで、熱心なHaskellプログラマなら上記のコマンドセットに見覚えがあるかもしれません。これはG-Machineに由来するものだそうです。\nIncidentally, for those who are interested in this sort of thing, Whitespace is essentially the G-machine with a weird syntax. You could probably use it as a target for a functional language. I keep thinking I should try that\u0026hellip;\n\u0026mdash; Edwin Brady (@edwinbrady) May 14, 2019 \nアセンブラ 流石に s 、 t 、 n だけでプログラミングするのは発狂ものなのでアセンブラを作ります。 直接Whitespaceを書いてないのでセルフホストのレギュレーションからは外れそうですが、アセンブラの1コマンドがWhitespaceの1コマンドに対応するという意味では実質Whitespaceでプログラミングしてます。\n今回のWhitespaceのコンパイラのアセンブリソースの冒頭部分はこんな見た目です。\nFlow call 0x00 # main Flow end # fn 0x00 # main { Flow label 0x00 # init start/top of ops Stack push 0x02 Stack push 0x08 Heap store Stack push 0x03 Stack push 0x08 Heap store Flow call 0x10 # parseInstAll # init start/top of labels Stack push 0x04 Stack push 0x03 Heap retrieve Heap store Stack push 0x05 Stack push 0x03 Heap retrieve Heap store Flow call 0xd0 # collectLabelsAndRewrite # Flow call 0xb0 # dumpOps # Flow end # init start/top of mcode Stack push 0x06 Stack push 0x05 Heap retrieve Heap store Stack push 0x07 Stack push 0x05 Heap retrieve Heap store # initialize labels Flow call 0xf0 # asmCode # reset top of mcode and run asmCode again Stack push 0x07 Stack push 0x06 Heap retrieve Heap store Flow call 0xf0 # asmCode Flow call 0x130 # dumpELF Flow return # } スタックマシンというつらさはありますが、call 、 ret やコメント、インデントを工夫することでそれなりにまともな見た目でプログラミングできるようになります。\n開発 方針 結構プリミティブなコマンドが多く、そのままアセンブラにできそうなのでだいたいパース→機械語生成のシンプルな流れでやります。 ただしラベルの扱いが難物です。 プログラムを一度全て走査しないとジャンプ先のラベルがどこにあるか分かりませんし、一旦マシン語を生成しないとバイナリ内のラベルの位置が分かりません。 それらを勘案して、以下の流れでコンパイルします\n パース  ヒープに仮想命令を並べる  ラベル走査（リネーム）  ラベルの出現順に名前を振る。メモリ内でジャンプとラベルの対応がとれる  マシン語仮生成  ラベルの位置を決めるためにマシン語を生成する。ジャンプ先アドレスは仮  マシン語本生成  決まったラベルの位置に基いて正しいマシン語を生成する  ELF出力  マシン語列にELFのヘッダをつけて出力する   連想配列とかがなくて苦しいのでラベル走査の段はちょっと苦労しました。\nその他、細かな点で仕様が変わってたりします。\n 値は64bit整数とする  任意長整数からの変更  ラベルは2進数の整数としてパースする  あとで考えたら st と sst が同じ値になってしまうのでNGだった  スタックが底をついたら未定義動作とする  確保してないメモリ領域にいくので多分SEGV  未初期化のヒープにアクセスしたら未定義動作とする  mmap で確保してるので0が返るのかな？  readchar 、 outchar は任意のオクテットを扱えるものとする  バイナリを扱うのに必須 逆にUnicodeのコードポイントとかは扱えなくなった  readchar 、 readnum はEOFにあたったらヒープに値を保存しないものとする  ファイルの末尾まで読みたいのでエラーだと困る   主にcharの扱いの問題で既存の処理系が使えないのでネットに転がっていた処理系にパッチを当てて使っていました。 どこで拾ったか覚えてないのと、確かライセンスが明記されていなかったのでこれは公開できないやつですね。 ブートストラップに必要な処理系が世の中に存在しないという残念なことになってしまいました。\n実装 ELFヘッダ 一番最初に作ったのはELFヘッダの出力でした。\nWikipediaやリンカ・ローダ実践開発テクニックを見ながらフィールドを埋めていきましたが、まあまあつらかったです。 Program Headerで機械語だけをメモリにロードして実行しようとしたらどうしても動かなくて、慣例に従ってELFファイル全体をロードしたら動いたりと、「よく分からないけどこうしたら動く」状態になりました。カーゴカルトですね。\nELFをいじいじしてもなんとかEXEを作れるのが精一杯だったのでlibcだとかのリンクが必要なものは使えそうにありませんでした。コンパイラは頑張ってマシン語を並べていく方針でいきます。\nパース ELFが作れるようになったら次はパースです。 これはまあ、手慣れてるので特筆することはないです。 界隈の人ならWhitespaceの文法を一瞥すればそれを受理するオートマトンが勝手に生成されると思うのでそのまま実装するだけです。\nパースのコードを書いたら、一旦パースしたコマンドをそのまま push とか readchar とかの文字列で出力するようにしました。これでパーサ（と自作アセンブラ）のデバッグをします。\nメモリ設計 データ構造とかそういうのがないのでメモリの何番地を何に使うかは事前に計画しないと破綻します。 コンパイラのコードのコメントから抜粋すると、以下のようなレイアウトにしました。\n# Heap layout # 0/1 1/1 # +----------+--------------------+- # | readchar | parse number/label | # +----------+--------------------+- # 2/1 3/1 4/1 5/1 6/1 7/1 # -+--------------+------------+-----------------+---------------+----------------+--------------+- # | start of ops | top of ops | start of labels | top of labels | start of mcode | top of mcode | # -+--------------+------------+-----------------+---------------+----------------+--------------+- # 8/l 8+l/m 8+l+m/n # -+------------+--------+--------------+ # | parsed ops | labels | machine code | # -+------------+--------+--------------+ # where ops forms | op | arg | # ops: # 0x00 push # 0x01 dup # 0x02 copy # 0x03 swap # 0x04 discard # 0x05 slide # 0x10 add # 0x11 sub # 0x12 mul # 0x13 div # 0x14 mod # 0x20 store # 0x21 retrieve # 0x30 label # 0x31 call # 0x32 jump # 0x33 jz # 0x34 jneg # 0x35 return # 0x36 end # 0x40 outchar # 0x41 outnumber # 0x42 readchar # 0x43 readnumber 0, 1番地は作業用。それ以降に可変長データへのポインタ、可変長データの実体が並びます。 可変長データはパースしたコード、プログラム中に含まれるラベル一覧、機械語の3つがあります。\n今回の作業はデータレイアウトを正しく設計するのが一番の鬼門でした。 それが決まったあとはわりとすんなり進みました。 まあ、データレイアウトを決めるときに実装のことも考えないといけないからというのもあります。\nラベル設計 プログラム中で扱うラベルはグローバルな名前空間しかないので工夫しないとバッティングして破綻します。\n関数のラベルには 0x10 、 0x20 … と16の倍数を割り当て、関数内で下1桁を1づつインクリメントして使ってました。 いくつか、関数内での分岐が多くて16個以上のラベルを使ったものがありましたが、それは次以降の関数のラベルをずらすことで解決しました。\nラベルのコンパイル 既に少し説明しましたがラベルの扱いが手に余りました。 まず、ラベルは任意長の s と t の文字列として与えられます。 それを64bitの符号なし整数にとしてパースします。これだと実は情報に欠損があるのは既述のとおりですが、一旦忘れましょう。\n次にラベルを出現順のインデックスでリネームします。これはlabelやjumpなど全てのラベルを扱うコマンドから拾います。 例えば以下のプログラムであれば\nFlow call 0x00 Flow end Flow label 0x00 Stack push 0x02 Stack push 0x08 Heap store Stack push 0x03 Stack push 0x08 Heap store Flow call 0x10 ラベルを出現順に並べるとこうなります。\n0x00 0x00 0x10 これはこうリネームされます。\n0x00 -\u0026gt; 0 0x10 -\u0026gt; 1 そしてラベル一覧のところにも記録します。\n0 1 +------+------+-- | 0x00 | 0x10 | +------+------+-- こうすることで、「ラベル一覧内のインデックス」 = 「リネームされたラベル」にできます。\nあとはラベルをみつけたら、\n ラベル一覧にラベルがある → そのインデックスにリネーム ラベル一覧にラベルがない → ラベル一覧にラベルを追加し、そのインデックスにリネーム  という処理を繰り返せばラベルの下処理は完了です。\n一度下処理が終わればラベル一覧内のデータは不要になるのでマシン語内のポジションの確定に再利用します。 labelコマンドのマシン語生成時に、現在のマシン語のtop（要はマシン語内でのポジション）をラベル一覧の自分のラベルのセルに記録します。 そしてジャンプ系コマンドのマシン語生成時にここからラベルのマシン語位置を読み取って、現在のマシン語topと引き算して相対アドレスを算出します。 ジャンプ系コマンドの方がラベルより後にくることもあるのでこの走査を二回やれば確実にアドレスを計算できることになります。 これが仮生成、本生成と呼んでいるものです。\n機械語の生成 ほとんどのコマンドはアセンブラ数命令で表現可能なのであまり困りませんでした。 ただし、先にランタイムを設計しておく必要があります。\nランタイム 今回はLinuxで動けばいいやの気持ちだったので雑に実装します。 必要そうなのはWhitespaceで使うスタックとヒープ、スタックのトップを指すポインタとヒープのベースを指すポインタ、コールスタックです。コンパイラのコメントから抜粋するとそれぞれこういう設計です。\n## runtime architecture # runtime heap map # # +------------+-------------+- -+---------------+ # | ws heap -\u0026gt; | ws stack -\u0026gt; | ... | \u0026lt;- call stack | # +------------+-------------+- -+---------------+ # registers # rbp ... base of ws heap # rbx ... top of ws stack # rsp ... ordinal rsp. # and some registers are used to hold temporal values # values # all values are 64-bit コールスタックとrspは普通のやつそのまま、Whitespaceのヒープとスタックはmmapでそれぞれ確保します。 スタックとヒープを指すポインタに rbx と rbp を選んだのはシステムコールを呼んでも保存される汎用レジスタで、命令にエンコードしたときに短いものだからです。 スタックのポインタに rbp を使えよって突っ込まれるかもしれませんがコールスタックとは逆向きにスタックが伸びる設計にしてしまったので気にせずにヒープ用に使っています。\nmmapやread、write、exitのシステムコール番号は こちらのまとめから拾いました。どのレジスタにどの値を入れればいいのかも載ってたので分かりやすかったです。mmapに渡すフラグやプロテクションフラグなどはLinuxのヘッダファイルから読みとりました。\nコマンドと機械語の対応 あんまり難しいことはやってないです。例えばpushコマンドならこうです。\n# mov QWORD PTR [rbx], arg # 48 c7 03 xx xx xx xx Stack push 0x48 Stack push 0xc7 Stack push 0x03 Stack copy 3 Heap retrieve Flow call 0x110 # decodeLE Stack push 7 Flow call 0x120 # storeMCode # add rbx, 0x08 # 48 83 c3 08 Stack push 0x48 Stack push 0x83 Stack push 0xc3 Stack push 0x08 Stack push 4 Flow call 0x120 # storeMCode これがreturnコマンドとかになるともっと簡単ですね。\n# ret # c3 Stack push 0xc3 Stack push 1 Flow call 0x120 # storeMCode マシン語はhttps://godbolt.orgにアセンブラを打って取得しました。\nここで苦労したのが readnum と writenum です。 他は数命令で済むのにこれらは数十命令あります。頑張って実装しました。 数十命令ですがこれでもサボっていて、符号の扱いは未実装です。\n特段アセンブラのデバッグ環境は用意しなかったのでWhitespaceコンパイラを動かして挙動が変だったらバイナリをデバッグして…というようにしました。つらいですね。\n苦労した点とか まあまあ大変だったので色々掃き出します。\nセマンティクスが不明 公式サイトに繋がらなくて、正しい情報を集められませんでした。特に苦労したのがslideコマンドです。 私が手元で使った処理系も作者によるIdris実装もバグっていて、WebArchiveからオリジナルの実装を掘り出してようやく理解できました。\n正しいELFの吐き方が分からなかった 「Linuxで動く最小のELF」とかがあれば使いたかったんですが（あんまり熱心に検索しなかったのもあって）見付からず、試行錯誤しながら生成していきました。\nバイナリエディタで開いて1バイトずつ指差し確認してデバッグしていきました。 既存のELFもいくつか眺めたのですがプログラムをロードするアドレスが様々で面白かったです。\n生成されたバイナリのデバッグが大変 今回生成するのはEXEなのと、労力削減のためにセクションヘッダを生成しなかったのでシンボルなしでデバッグする必要がありました。シンプルにつらいですね。\nところでgdbで機械語をデバッグするTipsが少し得られました。\n layout asm → 今実行しているアセンブラを表示する starti → プログラムを実行し、アセンブラの一番最初の命令でbreakする stepi → アセンブラ1命令実行する info registers → レジスタの中身を表示する  最終的に info registers を毎回打つのはやってられないのでgdb dashboardを使いました。\n末尾の数コマンドの実行でSEGV 現象としては分かりやすくて、ELFの指定したファイルサイズを越えた箇所にアクセスしています。 しかし現象が分かっても原因は全然分かりませんでした。 ELFの生成コードの問題を疑ったのですが、ELF生成とは関係なくマシン語の長さをデバッグ出力してみたら正しそうなのでお手上げでした。 結局、マシン語サイズを適当に水増ししてごまかしました。\nしかし今になってよく考えたらメモリにロードするときにELFファイルのヘッダごとロードしてるのでそこで100byteくらい想定より長くなってるのかもしれません となると、末尾の数コマンド（outcharがあるのでマシン語にすると長め）+ 最後のexitの呼び出しで100byteくらいありそうなので納得ですね。 あとで修正しよ。\n第2世代コンパイラのデバッグが大変 whitespaceで書かれたコンパイラを第0世代、それを使って自身をコンパイルしたものを第1世代、第1世代を使ってwhitespaceで書かれたコンパイラをコンパイルしたのを第2世代と呼ぶことにします。 完全なセルフホストコンパイラであれば第1世代と第2世代はバイナリレベルで完全一致します。\n第1世代コンパイラはなんとなく動いてるけど、第2世代コンパイラを生成するとバイナリレベルで一致しないし変な挙動をするときのお話。 直接書いたコードがバグっている訳ではないのでかなり厳しいものがあります。第2世代の挙動を見て、バグっていそうな第1世代のコンパイラの怪しいところに検討をつけて、そこの部分を生成する第0世代のコンパイラの該当箇所を血眼になってデバッグします。正直、自分が今何をデバッグしているのか分からなくなります。\ngdbで第1世代をデバッグできたらよかったんですが先述の通りシンボルがないのと、コンパイラは大きくてバイナリ内でバグってる箇所が分かったとしてもソースコードとの対応が中々とれないので難航しました。\n結局、バグが再現するコードをどんどん縮めていって小さなバイナリでデバッグしました。\n因みにバグっていたのは負の値のリテラルのパースでした。 コンパイラ内では1箇所しか負の値を使っていたので「おおむね動くけどたまに変なコードを食わせるとバグる」という挙動になりました。つらい。\n結びに Whitespaceでセルフホストコンパイラを作ろうというfoolなことを思い付いたのは先に引用したEdwin Bradyのツイートを見たときでした。 最初はWhitespaceにコンパイルする関数型言語でも作ろうかと思ってたのですが、脳内で色々こねくり回している間にエイプリルフールにWhitespaceのセルフホストコンパイラを作るという発想に至りました。\n計画は随分前からあったものの、実際に取り掛かったのは3月中だったので時間が足りず、有給を2日使ってようやく3月31日の22時というギリギリの時間に完成しました。 有給まで使って何してるんでしょうね。我ながらfoolだなと思います。\n今年はもう終わりましたが来年はみなさんもfoolなことやっていきましょう。\n今回のコンパイラのアセンブラとアセンブリのコードはこちらに置いておきます。ライセンスはGPLv2とします。\nhttps://gist.github.com/KeenS/6081b0c802a4e575ddbacb1930680870\n","categories":["Whitespace","compiler"],"category_urls":["/categories/whitespace","/categories/compiler"],"date":"2020-04-01","title":"タネ明かし: Whitespaceコンパイラを作った話の裏側","url":"https://KeenS.github.io/blog/2020/04/01/taneakirakashi__whitespacekonpairawotsukuttahanashinouragawa/"},
  {"body":"ハ〜イ、κeenさんだよー。Whitespaceのセルフホストコンパイラを作ったから紹介するねー。\nWhitespace1ってのはあまり知名度がないけどこういう感じの言語。\n 見ての通りクリアな構文が売りの言語で、簡単に覚えられるのが特徴。 文法が綺麗だとパースも簡単だろうということで、セルフホストコンパイラを書いてみた。\nこんな感じでコンパイラに自身のソースを食わせると完全に一致するバイナリを吐くよ。\n$ whitelie \u0026lt; whitelie.ws \u0026gt; whitelie2 $ md5sum whitelie whitelie2 418b0b9a58caaa9e99a2d5e3649f6faf whitelie 418b0b9a58caaa9e99a2d5e3649f6faf whitelie2  一応注意点を挙げておくと、オリジナルの言語とは多少の非互換がある。一番大きいのは  で、バイナリを扱いたいので非ASCII文字もそのまま通すようにした。この非互換の関係で恐らく既存の処理系では動かないので注意（自分は手元でパッチを当てて動かした）。あとは数値が多倍長整数でないだとか、とが符号に対応してないとか。 一応全部ちゃんと実装したつもりだけど一部ちゃんと動かないソースコードもみつかってるので粗は大目に見てもらえるとありがたい。\n実装は、おおむねそのまま書けばいいんだけどいくつか詰まりがちだった所を紹介するね。\n実装にとりかかってまず最初に目につくのは\n 。セマンティクスが分かりづらい。「スタックのトップを残したまま、その後のn個のアイテムを捨てる」という動作をする。 一見すると何をしたいのか分かりづらいけど、いくつかのローカル変数をスタックに残したま関数を走らせるときに便利。 最後に関数から抜けるときに、スタックトップに値を残したいけどそのままだとスタックにローカル変数が残ってしまうからこれで消すと都合がいい。\n次が\n 。まあ、目に見えて面倒。今回は機械語を一旦生成して、ポジションを確定したあとにラベルのポジションを抽出して、その上でもう一度機械語を生成することで対応した。ジャンプは面倒だったので全部nearにした。\nあとは地味に大変だったのが\n と\n 。これはどうしようもないので気合でアセンブリで実装した。\nあ、書き忘れてたけど今回はlibcなどは使わずに全て自分で実装した。\n終わった感想としてはまあ、大変でしたw。 とくにELFを吐きはじめたあたりで苦しくなって、gdbとにらめっこしたりバイナリを目diffしたりしてデバッグがつらかったです。\nよかったら見てみて下さい。\nKeenS/whitelie: A self hosted whitespace compiler\n Edwin BradyとChris Morrisにより2003年 4月1日 に発表された言語 [return]  ","categories":["Whitespace","compiler"],"category_urls":["/categories/whitespace","/categories/compiler"],"date":"2020-04-01","title":"Whitespaceのセルフホストコンパイラ作ったよ！","url":"https://KeenS.github.io/blog/2020/04/01/whitespacenoserufuhosutokonpairatsukuttayo/"},
  {"body":"κeenです。 GitHub Pagesからこんにちは。 私はこのGitHub Pagesのブログの他にGitLab Pagesのブログも持ってるんですが、それが使いやすいので宣伝します。\nGitLab Pagesを使うと\n Markdownでブログがかける Markdownのまま git push で記事の公開ができる コンテンツの管理が(GitHub Pagesより)楽 サイトでHTMLやJavaScriptが使い放題  になります。 JavaScriptが自由に使えるということは私のようにreveal.jsなどのスライドエンジンを使ってMarkdownでスライドを書いて公開することもできます。 ブログに自由度が欲しいという方におすすめです。\nGitHub PagesとGitLab Pages GitHub PagesとGitLab Pagesはだいたい似たようなことができます。\nユーザのGitHub Pagesは {username}.github.io というリポジトリを作って、そこのmasterにpushしたものが https://{username}.github.io で公開されます。 プロジェクトのGitHub Pagesだと拾うブランチやディレクトリをいじれたはずですが、ユーザの {username}.github.io はmasterにpushしたもの全部公開だけだったと記憶しています。 あと一応、pushしたものは Jekyll で処理されます。なので特段セットアップしなくてもJekyllでサイトを作れます。\nGitLab Pagesもユーザのページは {username}.gitlab.io というリポジトリを作って、そこにpushするのですが、GitLab CIが走ったあとに public という名前のディレクトリの中身を https://{username}.gitlab.io に公開します。 プロジェクトのページはGitHubと同じく https://{username}.gitlab.io/{project_name} になります。 See also Getting started part one · Pages · Project · User · ヘルプ · GitLab\nまた、どちらもカスタムドメインを使うことができます。\n参考までに、私の両者のリポジトリを置いておきます。\n KeenS.github.io blackenedgold.gitlab.io  書き忘れてましたがどちらも無料で、特別なセットアップなく、指定のリポジトリを作ってpushするだけで公開されます。\n静的サイトジェネレータを使うならGitLab Pagesが便利 GitHub Pagesはpushしたらそのまま公開される手軽さ、Jekyllを用意してくれている親切心はあるのですが、それを使わないユーザには結構不便です。 例えばJekyllは仕様で _ で始まるファイル名のファイルを無視するのですが、そのせいで手元で試すときとpublishしたときで挙動が変わったりします。\n翻ってGitLab Pagesはユーザの好きな静的サイトジェネレータを使うのに向いています。 一度GitLab CIを通ったあとに public ディレクトリを見にいくのでCIでサイト生成をして public に成果物を置けば完成です。\nGitLab Pagesのいいところはサイト生成した成果物をGitで管理しなくてよくなる点です。 GitHub Pagesの仕様だとどうしてもソースと成果物で二重管理が必要になりますし、masterの内容が全て公開されてしまうので別途ソースの管理場所を探さないといけなくなります。 See also Github pagesで意地でもサブディレクトリをルートにする | Matsuura Tomoya|松浦知也。 二重管理になって私がよくやらかすのは、成果物を公開して満足して、ソースをpushし忘れるケースです。 その後に別のPCから内容を変更しようとしてソースコードがなかったりコンフリクトを起こして破滅したりします（git subtreeはヒストリが綺麗じゃないと破滅します）。 そこにきてGitLab Pagesはソースをpushしたらデプロイフローが走る仕組みなのでgitのハックは必要ないですし、二重管理も発生しません。\n静的サイトジェネレータはHugoがおすすめ おすすめといっても色々試した訳ではないんですが、私は長らくHugoを使っています。GitHub Pages （このブログ）とGitLab Pages （日常ブログ） 両方ともHugoです。 よくメンテナンスされていますし、エコシステムも発達していて、テーマも300種類以上作られているようです。\nまた、Go製でキビキビ動くのもポイントが高いです。 元々Jekyllの上に構築されたブログエンジンOctopressを使っていたのですがブログが100ページを越えたあたりから遅くて使いものにならなくなったのでHugoに移行したという経緯があります。 今300ページありますが、Hugoで生成するのに1秒未満です。もちろん、Octopressを使っていた当時とはマシンスペックが違うので直接比較はできませんがかなり速度差があるのは事実だと思います。\nHugoの使い方は公式ドキュメントなどを読んでもらうとして、GitLab PagesのセットアップはこのCI設定をコピペするだけでいけるはずです。 というか、GitLabがプロジェクトテンプレートを持っている筈なのでポチポチやるだけでセットアップは終わります。 このように手軽に始められるのもおすすめの理由です。\nGitHub Pages / GitLab Pagesのデメリット 褒めてばかりなのでデメリットも書いておきます。全てはブログをGitで管理することに起因します。\n スマホなどから更新しづらい 下書きの扱いが難しい  Pagesを公開にしたまま、ソースは非公開にすると解決するかも  画像の処理が面倒  私はPCからしか書かないですし、下書きを溜めるタイプでもないので上2つは困ってないのですが最後のはちょっと困ってます。 ブログに画像を入れようとするとプロジェクト下に画像ファイルをコピーしてきて、そのパスをMarkdownから参照する必要があります。 また、画像をgitに突っ込むと操作が重くなります。\nこのあたりはCLIから気軽に更新できることと表裏一体ですね。\nコンテンツマネジメント的な機能が欲しいならcloudronなんかを使ってWordpressとかのCMSをホスティングするのがいいと思います。\nまとめ 「なんとなく自分の技術ブログを始めようかなー」と思っている方にはGitLab PagesとHugoがおすすめです。\n","categories":["ブログ"],"category_urls":["/categories/%e3%83%96%e3%83%ad%e3%82%b0"],"date":"2020-03-27","title":"BlogやるならGitLab Pagesがおすすめ","url":"https://KeenS.github.io/blog/2020/03/27/blogyarunaragitlab_pagesgaosusume/"},
  {"body":"κeenです。ふとした興味からEssential PhoneにAndroidのカスタムROMの1つ、CarbonROMを焼いたのでそれをメモします。\nEssential Phoneを買ったあと、1年も経たずにPixel 3aに買い替えてしまっていました。綺麗なまま死蔵するのももったいないのでカスタムROMを焼いて遊んでみます。\nカスタムROMとは？ Androidはオープンソースで開発されています（Android Open Source Project）。なのででGoogleが配ってるROM以外にも有志が配布しているROMがあります。それがカスタムROMです。 有名どころだとLineageOSなんかがあります。\nあんまりROMという言葉が馴染まないのですが、Linuxでいうディストリと同じ意味という理解であってますかね？ブートローダまでは含んでないようなので微妙に違う？\nちょっとGoogleに依存しないAndroid、AOSPにできるだけ近いAndroidに興味があったので、Google以外のところが配っているROMを試してみることにしました。\nCarbonROMとは？ CarbonROMはStock Android（手を加えていない生のAndroid）に近い形で配られているROMです。安定性に重点を置いているようです。\n our vision is to be the best alternative to a stock operating system for your device.\n とのことなので今回の私の目的に適っていそうです。\nCarbonROMのインストール CarbonROMをインストールしていきます。 おおまかには\n OEMアンロック TWRPのインストール CarbonROMのインストール  の順番でやっていきます。\nこれは一般的な手順とは少し異なっています。Google PlayなどのGoogleが配っているアプリ（gapps）をインストールしていません。今回の目的はGoogleに依存しないAndroid環境の構築なのでそういうもんです。Google Playを入れずにアプリを使う方法は後述します。\nインストールにはパソコン（ターミナル）をほとんど使わないやりかたもあるみたいですが、私はむしろターミナルを使った操作の方がやりやすいのでターミナル操作中心にやっていきます。\n途中、スマホにマウスを挿す手段が必須になります。私は手元にUSB Type-A to Type-Cのアダプタがあったのでそれを使って普通のマウスを使いました。\n余談ですが今回のインストールにあたってはまず英語記事を漁りました。 どうせ日本語情報はないだろうと踏んだので。 ですが思ったよりめぼしい情報がありませんでした。 最後にダメ元で日本語で情報をさがしてみたら下記の記事にあたりました。\nEssential Phone PH-1をLineageOSにした話 (追記)(再び追記 細かい修正等) - Gadget\u0026amp;LifeStyle Blog\n今回の記事は上記の記事をおおいに参考にして書かれています。感謝します。\nその他には以下の記事を読みました。\n How to Root and Install Official TWRP Recovery on Essential Phone PH-1 Update CarbonROM on Essential Phone based on Android 8.1 Oreo How to Wipe Data using TWRP Recovery  0. 諸々のダウンロード CarbonROMのダウンロードはこちらから。Essential Phoneのコードネームはmataなのでmataの最新版をダウンロードします。サイズは600MBちょい。\nTWRPはこちらからダウンロードします。TWRPはカスタムリカバリツールだそうです。よく分かってないですが、ファクトリリセットする機能を上手く使って別物のROMを焼くソフトウェアなのかな？\nあとはadbとfastbootを手元のUbuntuにインストールします。 apt install adb fastboot で入ります。\n1. OEMアンロック これは以前Ubuntu Touchをインストールしたときと共通ですね。\n1.1. AndroidのUSBデバッグを有効にする 1.1.1. 開発者モードの開放 [設定のアプリ] → [一般] → [端末情報] → [ソフトウェア情報]\nと進んで[ビルド番号]を7回タップすると開発者モードが解放されます。\n1.1.2. USBデバッグの有効化 さて、これで[一般]タブに戻ると[開発者向けのオプション]という項目が出てくるのでそこからUSBデバッグを有効にしましょう。\n1.2. OEMロックの解除 ちょっと記憶があいまいなんですが、同じく[開発者向けのオプション]に[OEMロック解除]のメニューがあるらしいので有効にします。ターミナル叩かなくてもアンロックできるんですね。\n1.3. データのバックアップ 略。以前のUbuntu Touchをインストールしたときの記事を読んで下さい。 私はやってません。\n2. TWRPのインストール Essential Phoneをパソコンに繋いで画面のロックを解除しましょう。 adb devices でそれっぽい表示が出たらOK。\nブートローダに入ります。\n$ adb reboot bootloader  再起動してブートローダに入ったらtwrpをインストールします。\n$ fastboot flash boot twrp-VERSION-mata.img  私の場合はVERSIONは3.2.3-0でした。\n終わったら再起動するらしいです（覚えてない）\n$ fastboot reboot  3. CarbonROMのインストール 先程のコマンドで再起動したらtwrpの画面に入ります。 この画面ではなんとタッチパネルも音量ボタンも効きません。マウスを繋いで操作します。 ひとまずロックを解除すればOK。\nロック解除したらデータを消します（データ保護のため、既存のデータを消さないとROMを焼けない仕組みになってるらしい）\n$ adb shell twrp wipe data $ adb shell twrp wipe system  パソコンからROMを流し込みます（sideload）\n$ adb shell twrp sideload $ adb sideload CARBON-CR-7.0-OPAL-RELEASE-mata-DATE-TIME.zip  DATEとTIMEは自分でダウンロードしたファイル名に合わせて下さい。\nあとは再起動するだけです。\n$ adb reboot  これでCarbonROMが立ち上がってくるはずです。\nインストール後のセットアップ 以下は私がやったセットアップです。各人の好みに合わせて判断して下さい。\nシステムの言語を日本語に 記憶にないけど多分やってるはず。\nSettingsから [System] → [Languages \u0026amp; Input] → [Languages] → [Add a language]で日本語を選択。\n戻った画面でまだ英語のままのはずなので。右上のメニューからremoveを選んで英語を削除。 これで日本語になるはず。\n高度なリブートメニューをOFFにする デフォルトでは端末を再起動しようとするとtwrp関連の選択肢が増えています。twrpはもう用済みなのでこの選択肢を出さず、素のAndroidと同じようにします。\n設定から[Carbon Fibers] → [システム] → [高度な再起動] をOFFに。\n電源ボタンで画面の録画をONにする スクショ以外にも録画もできるみたいです。\n設定から [Carbon Fibers] → [システム] → [電源メニュー] → [画面の録画] をONに\nホームボタンを上にスワイプをONに いつデフォルトになったか覚えてないですが、今まで使ってたのと同じ動きにします。\n設定から [Carbon Fibers] → [ジェスチャー] → [ホームボタンを上にスワイプ] → [ホームボタンを上にスワイプ] をONに\nテーマをブラックに Carbonって名前なのでカーボンっぽい色にします。因みにデフォルトの壁紙は炭ですね。\n設定から [ディスプレイ] → [詳細設定] → [端末のテーマを使用] を[常にON] に。その下にある[ブラックテーマを使用] をONに\nブラックテーマよりダークテーマの方が目にやさしい気がしますがCarbonROMのページだと多分ブラックテーマのスクショが貼られてる気がするのでそれにあわせます。\nF-Droidをインストール F-DroidAdroidアプリの自由ソフトウェアのストアです。 Google Playに比べるとアプリ数は少ないですがGoogleに依存していません。\nプリインストールのブラウザから https://f-droid.org にアクセスして[Download F-Droid]を選択します。システムに怒られるはずなのでブラウザからのapkのインストールを許可するようにして、インストールします。\n慎重な方はパソコンでダウンロードしてPGPを検査してからadbでインストールするとよいかもしれません。\n因みにアプリはFirefoxのフォーク（？）のFennecやNextCloudの公式クライアント、Simple Mobile Tools、OpenStreetMapクライアントのOsmAndなどがあります。\nF-Droidの他にはGoogle Play Storeの非公式クライアントのAuroraOSSなんかもありますが、利用規約に違反しているらしいです。 うっかりAuroraOSSからログインしてPlay StoreにアクセスするとBANされる可能性もあるとか。\n感想とか OS自体は今までと遜色なく使えて満足しています。 ただまあ、Play Storeがないと不便極まりないですね。Slackとか使いたい。 Play StoreをインストールするかAuroraOSSをどうにかして使えるようにするかしたいですね。 Term of serviceに違反しても偽計業務妨害とかに問われないんなら使ってみようかなって気になるんですがね…。\n","categories":["Android","備忘録"],"category_urls":["/categories/android","/categories/%e5%82%99%e5%bf%98%e9%8c%b2"],"date":"2020-03-01","title":"Essential PhoneにCarbonROMを焼く","url":"https://KeenS.github.io/blog/2020/03/01/essential_phonenicarbonromwoyaku/"},
  {"body":"κeenです。前回に続いて自宅用のデスクトップマシン2号を組んだのでメモします。\n新調しようと思ったのは64コア/128スレッドのRyzen Threadripper 3990Xが発売されたから。Zen 2アーキテクチャが発表されたときからThreadripperの最上位モデルを買うと決めてたので発売当日に買いにいきました。 1号機も稼動してから2年弱しか経ってないのですがソフトウェアエンジニアがパソコンにお金使ってもバチは当たらないだろうということで気にせず買うことにします。\n元々、石だけ買って1号機に換装するつもりだったのですがソケットの規格が代わっててマザボも買い替える必要がでてきましたし、スレッド数が増えたということはメモリも増やさないとなーとか、TDP上がってるから電源もアップグレードした方がいいかなーとか考えて筐体まるごと新しくすることにしました。\n構成は1号機とあまり変わらず、Threadripper 3990XにASRockのTRX40 Taichi、あとはメモリを128GiB（1スレッド1GiB計算）と、それっぽい電源と、簡易水冷のファン。GPUは後述しますがRadeonのSapphireを買って後悔しました。ケースは1号機よりひとまわり小さいものにしました。1号機で多少経験を積んだので2号機はもう少し難易度が高くてもいけるだろうという判断です。あとストレージがNVMeのSSDを6本です。\nCPU 異常なスレッド数のCPUを選んだのは、面白いからというのとソフトウェア的にチャレンジングな環境にしたかったからです。 並列スケールすると謳っているソフトウェアでも異常なコア数のマシンに載せてみると意外と性能が出ないことがあるらしい、という話を同僚から聞いたので試してみたくなりました。 視点を変えると自分もそういう風にメニーコアでスケールするプログラムを書かないといけないのでその練習の意味もあります。 あとは一応、最近Rustとかのビルドが重い言語を触ってるのでビルド速度改善の意味もあるのですがRustのコンパイルはコア数であんまりスケールしないのでそんなに効果はないです。\nメモリ 特に何も考えずにDDR4-2666を選びましたがマザボ的にはもうちょっと上の規格までサポートしてるっぽい（？）ので気が向いたら試してみたいなと思います。 実験してないので推測ですがRustのコンパイルはメモリ速度が効く気がするんですよね。\nGPU GPUに「画面が映るだけ」程度の機能を持つ3000円くらいのものを選んだのですが、失敗でした。 うちのディスプレイとの相性の問題もあるかもしれませんが、4Kで出力できませんでした。 あと音響機能がないので音が出ない。 うちのディスプレイが4Kで出力するにはHDMI 2.0接続が必要なのですがGPU側がHDMI 2.0未対応のようでした。 4K自体はHDMI 1.4から使えるらしく、世の中にはSapphireで4K出力に成功した報告もあるのですが、うちでは使えず。 結局、ここだけ1号機のGPUを移植することにしました。\nストレージ せっかく高性能なCPUなのでコア数以外にもそれを生かせる構成にしようと思い、SSDをNVMeで6本用意しました。 3990XはPCIe 4.0のピン数が多くて、6本までPCIeでSSDを接続できるのです。\nこのあたりややこしくて買うときに混乱したのですが、NVMeプロトコルでPCIe接続する、M.2端子のSSDを買いました。 マザボにM.2が直接刺さる箇所が2つあります。\nあとはグラボとかと同じようなPCIeスロットに刺さるケースが用意されていて、その中に4本のSSDを入れてPCIeスロットに差し込みます。\nマザボの規格的にハードウェアRAIDも組めるっぽいですが、私はソフトウェアエンジニアなのでソフトウェアRAIDを試してみます（？？？）。 まずUbuntu 19.10から実験的にZFSルートで動く機能が入ったので試してみましたが、ダメでした。 RAIDZを試そうとしましたがZFSはあとからストレージを増減させる機能に制約が多く、思った通りの構成にできませんでした。\nグロ画像です。今のUbuntuのzfsのバージョンだとremoveができないのでこのまま生活するしかない。 pic.twitter.com/JqCZrm3NMM\n\u0026mdash; κeen (@blackenedgold) February 15, 2020 \n今のところ、Root ZFSをあきらめて前回と似たような形でbtrfsとmdadmの混成でRAIDを組んでます。 4本を本体用に、2本をバックアップ用に使う予定です。 本体は/bootをmdadmで4ミラーのRAID1でext4に、/を4本構成のRAID5にしました。 2本のバックアップはZFSのミラー構成にできないかなと思いつつ、まだ初期化していないです。\nあ、そうそう。NVMeストレージを4本刺してあるPCIeスロットはBIOSの設定でPCIe x16からPCIe x4 x4にする必要があります。 これをしないとストレージをBIOSレベルで認識してくれなくなるので注意。\nNVMeの利点としてコマンドキューが長くて帯域をきっちり埋められる点があるらしい（？）ですがまだそういうプログラムを書いてないのでよく分かってません。 いつかちゃんと性能を引き出せる方法を勉強したいですね。\nケース ケースを小さいやつにしたのは正解だった気がします。 大きいやつより軽くて取り回しが楽ですし、ケーブル長が足りないこともありません。 とりわけ今回はストレージをPCIeにしたのでSATAケーブルや電源ケーブルが必要なくなり、かなり手順が楽になりました。 エアフローとかそういう難しい話はよく分かりません。 CPUの温度は /sys/class/thermal/thermal_zone0/temp によると40℃ちょっとで安定してるみたいです。\nOSのインストール 2号機にUbuntu 19.10をインストールしようとしましたが、インストーラが起動せずに失敗しました。 最初は組立不良かなと思ったのですが他のOS (FreeBSD) のインストーラだと起動するので19.10のインストーラの問題とあたりがつきました。\n色々調べた結果、Linux 5.0.0では問題なくてLinux 5.3.0だとカーネルパニックすることが分かりました。 なのでUbuntu 18.04のインストーラだと起動します。 しかし私はZFSのために19.10をのインストーラを使いたかったので19.10を使えるようにします。\nDuckDuckGoで調べるとカーネルの起動オプションに mce=off を渡せばひとまずカーネルパニックを回避できることが分かります。 それならば、とgrubが起動しているあたりで Esc を連打して起動メニューに入って F6 で起動オプションをいじって mce=off を足してから起動します。 これでインストールまでできるので、あとはインストール後の起動時にも同様のことをして立ち上げます。 最後に /etc/default/grub をいじって GRUB_CMDLINE_LINUX_DEFAULT に mce=off を追記して update-grub か何かでこの設定を永続化します。\n最後に OSのインストールで苦戦しましたがなんとかハイスペックマシンを動かせてよかったです。ハイスペックマシンでも性能を引き出せるソフトウェアを書けるように頑張ります。\n","categories":["日記","番外編"],"category_urls":["/categories/%e6%97%a5%e8%a8%98","/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2020-02-16","title":"自作マシン2号組んだ","url":"https://KeenS.github.io/blog/2020/02/16/jisakumashin2goukunda/"},
  {"body":" κeenです。 先日、Microsoft Research (MSR)からVeronaという言語が公開されました。\n マイクロソフト、Rustベースのセキュアなプログラミング言語を探求中 - ZDNet Japan マイクロソフト、「Rust」に基づくプログラミング言語プロジェクト「Project Verona」がGitHubに - ZDNet Japan  これを見た人達の反応が様々で（婉曲表現）面白いな（婉曲表現）ーと思いました。\n最近は企業や大きな団体の作った言語がメインストリームで使われることも増えたことから、本来の目的以上に期待を背負ってしまった感じがします。 プログラミング言語は思ったよりも気軽に作られているものです。 例えばGoogleの開発したohmuという言語はほとんど誰も知りませんよね。 そういうもんです。\n以下には私がドキュメントとかコードとか読んだ感想を書きます。 主に読んだのはdocsのFAQやExplore、そしてテストスイートです。 残念ながら実装までは踏み込めませんでした。 VMとか結構面白いらしいので解説してくれる人がいたら嬉しいですね。\nこのプロジェクトの立ち位置 MSRのプロジェクトということからも分かるように、研究目的の言語です。 決して既存の言語を置き換えようとかそういうものではないです。FAQにも明記されています：\n When will this be a product? This is a research project not a product.\n 。なのでMicrosoftがC/C++/Rustを使わなくなるということでもないですし、既存の言語を拡張するのは目的が違うというのも理解できると思います。\nMSRは色々な言語を作っていて、PやF*など色々なコンセプトの言語があります。 Veronaもその1つです。\n研究目的で開発されている機能がメインストリームに降りてくるのは10年、20年先のことでしょう。 例えばRustは実績のある言語機能を採用するという方針もあり、Rustで使われている所有権やトレイトなどのシステムは20年以上前に論文が出ています。 現段階では「これがあるとしたらどんなことができるかな」くらいの代物と受け取っておくとよいと思います。\nVeronaの目指すもの 「Rustベースの」なんて言われている通り、システムプログラミングをサポートしたいです。 システムプログラミングに求められるものを分解すると以下の2要素が挙げられます。\n 予測可能性  レイテンシ リソース使用量  \u0026ldquo;生の\u0026rdquo;アクセス  メモリをバイト/ビット単位で扱える ハードウェアを抽象化しない/あまりしない   こういうものを 安全に 扱いたいよね、というのがRustから続くモチベーションです。 VeronaもおおむねRustと同じく、型システムで安全性を保証しようというアプローチです。 しかし型システムで安全性を保証しようとするのは生のアクセスの方は無理がありそうです（Rustも結局 unsafe を使いますしね）。 ところが予測可能性の方はできるんじゃないか、というのが仮説で、それを検証していうプロジェクトのようです。\nなのでVeronaは性格にはシステムプログラミング言語ではなくインフラプログラミング言語を謳っています。 性能が安定してるだとか急にレイテンシが跳ねないだとかの方を目指しているようです。 なのでVeronaでOSを書くことはできないですが、データベースなら（将来的には）できるんじゃないでしょうか。\nつまるところ、Veronaを評価するときは「どうやってメモリを管理してるか」、「どうやって並行処理に関連する困難を扱っているか」に着目すると良さそうです。 FAQを見るとC++とのFFIは重要視してるようなので生のアクセスの方はC++に任せる肚なのかもしれません。\n実際、Veronaがどういう目的（どういう研究）のために作られたかというと、これもFAQに3つ挙げられています。\n 並行な破壊的変更をしない言語を設計したらメモリ管理をスケーラブルにできるか？ 線型リージョンを使うとメモリ管理は残しつつオブジェクト単位の線形性を緩められるか？ 言語レベルでリージョンをサポートすると区分け（compartmentalisations）をサポートするのに使えるか？  です。並行な破壊的変更、リージョン、などなどいくつかキーワードが出てきましたね。これはExploreで解説されています。 キーワードと絡めつつVeronaの設計を見ていきましょう。\nVeronaの設計 並行な破壊的変更とメモリ安全性 メモリの管理は難しいです。 早めに開放するとdangling pointerになりますし、開放しなかったらメモリリークになります。 とくに並行性が絡むと全てのスレッドを検査してオブジェクトが使われているか調べなければなりません。 要するにGCのStop the Worldですね。 Stop the Worldはアプリケーション全体を止めますし、スレッド数が増えるとパフォーマンスが落ちがちなことが知られています。\n一方でRustなどの言語はGCなしでメモリを管理しています。 これは複数スレッドからのアクセスを抑制して1スレッドからのみアクセスできる（所有権）ようにすることで実現しています。\n1スレッドからしかアクセスできないと一見不便ですね。これは所有権を別のスレッドに送るれるようにすることで解決しています。 結局スレッド間の相互作用が入ってしまうのですが、2スレッドしか絡まないので全てのスレッドを検査するGCよりは複雑でない動作です。\nというのが前提知識。 VeronaはRustやPonyのように所有権を使ってメモリを管理しています。 ところがVeronaは並行な破壊的変更を排除する方向に舵を切りました。 これでは並行キュー（チャネル）などの並行ライブラリをユーザランドで実装することができません。 なので言語にもう少し機能を加えて並行処理を便利にできるようにしたいです。 このとき、2つの方針があります。\n Rustの unsafe のように限定的な状況で安全でない操作を許す  Rustの並行ライブラリ（ std::thread::spawn や std::sync::mpsc::channel はユーザレベルで実装されている）  Ponyのように言語側で安全に操作できるモデルを構築してユーザにはその枠組みの中でプログラムさせる  ここでPonyという言語が出てきました。 4年前のスライドなので古い部分もあるかと思いますが私は以下のスライドが参考になりました。\nPony concurrency built into the type system\ncapabilityというのが6種類あって、それで並行なアクセスを細かく制御しています。 Rustでいう所有権にあたる iso からはじまり trn 、 box 、 val 、 ref 、最後はポインタの同値比較のみができる tag などがあるようです。\n余談ですが上記のPonyの発表のあった会で私はRustの発表をしました。 該当勉強会の参加者は4年越しにピースが繋がった感じがするんじゃないでしょうか。\n話を戻すとVeronaはPony方式、つまり言語の規定した並行モデルの上でプログラミングさせる方式のようです。 ただしPonyのモデルそのものではなくて色々アレンジが入っています。それが線形性やリージョンなどです。\n並行所有権 Rustでいう所有権は型理論では線型型と呼ばれています。 なので所有権システムを持つことを線形性があるなんて言ったりします。\nVeronaには並行所有権があります。Concurrent owners、略してcown（コウン）です。 並行所有権ということは複数のスレッドが所有権を共有している訳です。 複数のスレッドから同時にアクセスすると結局何でもありになってしましそうですね。 しかしVeronaのcownは「同時に」アクセスすることはできないようです。 Exploreにあるコード片を眺めてみます。\n// x is some isolated object graph var c = cown.create(x) // c is a cown that mediates access to x. // We have lost direct access to x here コメントにある通り、cownを作るとその変数への直接アクセスを失ってしまいます。 アクセスするときは when ブロックを使ってアクセスを得てから実行します。\nwhen (var x = c) { // Access internals of cown(c) using name x in here Builtin.print(\u0026#34;Hello\\n\u0026#34;) } Builtin.print(\u0026#34;Goodbye\\n\u0026#34;) さて、面白いことに when ブロックは非同期に実行されます。つまり、上記のコードを実行するとHelloをGoodbyeのどちらが先に実行されるか分かりません。\nなんとなくモニタに似ていますが、モニタと違ってブロックしないところが違います。\nまた、実装レベルの話をすると when の中は実質クロージャ相当なのでクロージャをキューに入れてスケジューラで順に実行してあげればランタイムをロックフリーにできます。 よく考えたなーという感じですね。\nさらに言うとこのcownはただのアクセス制御だけでなく、リージョンでも重要な役割を果たすので「ただのロックの亜種」と思わない方がいいでしょう。\nリージョン プログラミング言語の文脈でリージョンというといくつかあってややこしいのですが、メモリ管理の方のリージョンです。 RustやVeronaが参考にしているCycloneで導入されている概念です。 拙いですが以前（もう5年前）ブログに書いたので気になる人は読んでみて下さい。\nリージョンについて | κeenのHappy Hacκing Blog\n軽くリージョンの特徴をまとめておきます。\n リージョンはメモリを管理する単位。 リージョンにメモリをアロケートし、リージョンが終わるときにメモリが開放される リージョンは入れ子にできる。 メモリをアロケートするときはどのリージョンにアロケートするかを指定できる  ここがスタック変数などとは違うところ   元々のリージョンは1つの木になっています。 すなわち、プログラム終了まで生きるリージョンを根としてその他のリージョンは全てそのリージョンにぶら下がってる形になります。\n翻ってVeronaのリージョンは森になります。木々の根になるのはスタック変数やcownです。cownがリージョンに密接に絡んでるのです。 これを見たときになるほどなーと思いました。 雑に解釈するとスタックをルートとするリージョンはスレッドローカルな値を、cownをルートとするリージョンはスレッド間で使われる値を管理するリージョンという訳ですね。\nところでVeronaのリージョンは私のようにRustを普段使いしてる人からすると驚きの機能があります。 同じリージョン内のオブジェクト同士なら相互参照できるのです。 つまり、グラフを簡単に作れます。 別の解釈をするとRustは1オブジェクト1リージョンに制限されているとも考えられます。 この意味で、VeronaはRustにあった制限を緩めた言語とも捉えられます。\nコードを眺める Veronaのキーとなる機能を理解したところで、これらの機能を実際に試してみましょう。\nビルド buildingに書かれてます。 CMakeとninjaを使います。\n$ git clone --recursive https://github.com/microsoft/verona $ mkdir build_ninja $ cd build_ninja $ cmake .. -GNinja -DCMAKE_BUILD_TYPE=Debug $ ninja install  これを走らせると build_ninja/dist/veronac が出来上がります。\n食事する哲学者 並行処理といえばまず最初に挙がる例ですね。 セッティングを知らない方はWikipediaの記事を読んで下さい。\nコードはこちらにあります。 以下ではエッセンスだけ眺めていきます。\nまずは Philosopher クラス。cownな Fork をimmutableに保持しています。\nclass Philosopher { // id used for printing the trace of what happened. id: U64 \u0026amp; imm; // The two forks this Philosopher is using to eat fork1: cown[Fork] \u0026amp; imm; fork2: cown[Fork] \u0026amp; imm; // The door is used, so we can synchronise the finish to eating. door: cown[Door] \u0026amp; imm; // The number of times left for this philosopher to eat. hunger: U64 \u0026amp; imm; } 後で Fork を変更しているので恐らくここの imm は cown にのみ適用されて内側の Fork の管理はまた別なんだと思います。 Philosopher のコンストラクタは以下。\n/** * This static method creates a Philosopher * * It returns the Philosopher with the capability `iso`. This is linear * capability that expresses unique ownership of this object (and potentially * other objects in the same regions). **/ create( n: U64 \u0026amp; imm, f1: cown[Fork] \u0026amp; imm, f2: cown[Fork] \u0026amp; imm, d: cown[Door] \u0026amp; imm): iso \u0026amp; Philosopher { var p = new Philosopher; p.hunger = 10; p.fork1 = f1; p.fork2 = f2; p.door = d; p.id = n; p } iso \u0026amp; Philosopher と、 isoなPhilosopherを返しています。 isoは恐らくPony由来の名前でしょう。\nそして肝心の request_eat。\n/** * This instance method perform the requests to acquire the forks for this * Philosopher. * * The Philosopher is passed as an `iso`, so that its linear capability can be * sent into the closure of the when expression. **/ request_eat(self: iso) { // Request the philosophers forks // This captures the self parameter in the closure that it schedules. when (var f1 = self.fork1, var f2 = self.fork2) { // mut-view is an annotation to coerce the `iso` capability to a `mut` // capability for this call. When we have more inference for capabilities // this will be inferred. (mut-view self).eat(f1, f2); if (self.hunger) { // Not zero hunger, so recurse. // Though, this is not technically recursion, as this call is actually // in the closure created and scheduled by `request_eat`. self.request_eat(); } else { // This Philosopher is finished, so leave the room through the door. Builtin.print1(\u0026#34;philosopher {} leaving\\n\u0026#34;, self.id); Door.leave(self.door); } }; // Accessing self here is an error as it has been captured by the closure // Uncommenting the following line illustrates this: // self.fork1; } when でフォーク2つを取得するスケジュールを開始しています。 取得できたらeat メソッドを呼んでいます。 その後にまだお腹が空いてたらまた self.request_eat を呼んでもう1度スケジューラに自身を積みます。\nさて、問題はこれの実行部分。\nclass Main { main() { var f1 = Fork.create(); Builtin.print1(\u0026#34;fork 1: {}\\n\u0026#34;, f1); var f2 = Fork.create(); Builtin.print1(\u0026#34;fork 2: {}\\n\u0026#34;, f2); var f3 = Fork.create(); Builtin.print1(\u0026#34;fork 3: {}\\n\u0026#34;, f3); var f4 = Fork.create(); Builtin.print1(\u0026#34;fork 4: {}\\n\u0026#34;, f4); var d = Door.create(f1, f2, f3, f4); var p1 = Philosopher.create(1, f1, f2, d); var p2 = Philosopher.create(2, f2, f3, d); var p3 = Philosopher.create(3, f3, f4, d); var p4 = Philosopher.create(4, f4, f1, d); p1.request_eat(); p2.request_eat(); p3.request_eat(); p4.request_eat(); } } Philosopher.create にそれぞれ左手、右手の順にフォークを渡しています。 これだと全員同時に左手から食べ始めるデッドロックが起きそうな気がしますね。 ところがこれで動いているようです。 恐らく when ブロックに渡す cown はスケジューラがいい感じに賢く管理してくれて、デッドロックが起きない仕組みなんでしょう。\nリージョン コードはここにあります。 循環のある連結リストを作る例。\nデストラクタでプリントするノードを定義しています。\nclass Node { id: U64; field: (Node \u0026amp; mut) | (None \u0026amp; imm); // Self should really be read-only, but not implemented yet. // This is called when the runtime deallocates this object. final(self: mut) { Builtin.print1(\u0026#34;Deallocating id {}\\n\u0026#34;, self.id); } } (Node \u0026amp; mut) | (None \u0026amp; imm) のように、 \u0026amp; や | の記号が使われていますね。 それぞれ交差型と合併型だと思います。\nこれらを使って閉路を作っていきます。 まずはノードを作るところ。\n// Allocate a new node in its own region. var r1 = new Node; // Allocate two nodes in the same region as r1. var r2 = new Node in r1; var r3 = new Node in r1; // Give nodes an id for logging r1.id = 1; r2.id = 2; r3.id = 3; 注目してほしいのは r2 、 r3 の in r1 の部分です。 この記法で r1 と同じリージョンにアロケートしています。\n同じリージョンにノードを確保できたら閉路を作ります。\n// Create a little graph that has a cycle r1.field = r2; r2.field = r3; r3.field = mut-view(r1); 最後の r3 だけそのままの代入ではなく mut-view を噛ませていますね。 流石に所有権があるので iso では渡せなくてviewで渡しているようです。 実際、最後の mut-view を外すとエラーになります。\n$ ./dist/veronac --run ../testsuite/demo/run-pass/region101.verona ../testsuite/demo/run-pass/region101.verona:42:3: error: Inference failed for method test1 test1() ^~~~~~~ 1 error generated mut-view を外す前の世界線に戻って、 r1 を別のノードで上書きしてみます。\nr1 = new Node; r1.id = 4; Builtin.print(\u0026#34;Update\\n\u0026#34;); こうすると r1 が開放されるのはもちろんのこと、 r2 、 r3 も開放されます。 実際、この行のあとに r2 を使おうとするとコンパイルエラーです。\nBuiltin.print1(\u0026#34;r2.id = {}\\n\u0026#34;, r2.id);$ ./dist/veronac --run ../testsuite/demo/run-pass/region101.verona ../testsuite/demo/run-pass/region101.verona:79:36: error: Cannot use variable \u0026#39;4\u0026#39; Builtin.print1(\u0026#34;r2.id = {}\\n\u0026#34;, r2.id); ^~ ../testsuite/demo/run-pass/region101.verona:73:5: note: Its parent, \u0026#39;3\u0026#39;, was overwitten here r1 = new Node; ^~~~~~~~~~~~~ これまたコンパイルが通る時の世界線に戻って実行してみると、確かに id 1のノードを開放したらすぐさまid 2、id 3も開放されて、関数の最後にid 4のオブジェクトが開放されているのが分かります。\n$ ./dist/veronac --run ../testsuite/demo/run-pass/region101.verona Deallocating id 1 Deallocating id 3 Deallocating id 2 Update Deallocating id 4 その他 型システムは構造的部分型で交差型と合併型があるようです。 例えば以下のように返るのが A だか B だか分からないようなものもちゃんと（不動点をとって？） A | B と判定できます。\nclass A { f: B \u0026amp; mut; } class B { f: A \u0026amp; mut; } class Main { main() { } fixpoint(a: A \u0026amp; mut) : (A | B) \u0026amp; mut { var current = a; while 1 { current = current.f; }; current } } コードは これ。\nあとはテスト用にスケジューラの挙動を制御できるだとかの面白い機能もあります。\n結びに MSRの研究プロジェクト、Veronaを紹介しました。 まだ論文も出ていない、はじまりかけですが十分面白いプロジェクトだと思います。\n個人的にはユーザが陽に扱えるリージョンやリージョンとcownの関係、リージョン内での相互参照は可能な設計など、リージョンを上手く使ってるなーと感心しながら見てました。\n今回はさらっとドキュメントやコードを眺めただけなので複雑なコードやコンパイラ、ランタイムには踏み込めませんでした。 ランタイムもメッセージパッシング向けのアロケータnmallocを使っているなど、探せば話題に事欠かなそうです。 興味のある方は是非実装を眺めてみて下さい。\n","categories":["言語処理系","Verona"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%87%a6%e7%90%86%e7%b3%bb","/categories/verona"],"date":"2020-01-26","title":"ウワサのVeronaを眺めてみる","url":"https://KeenS.github.io/blog/2020/01/26/uwasanoveronawonagametemiru/"},
  {"body":"κeenです。 大きめ(130P程度)のPDFを印刷する用事があり、両面印刷したくなったのでそのときのメモ。\n高めのプリンタだと両面印刷の機能があることもありますし、プリンタドライバが優秀なら偶数ページのみ印刷や奇数ページのみ印刷のオプションがあって両面印刷できることもあります。今回はその両方ともが使えなかったときのお話。\n方針としては奇数ページを印刷、偶数ページを印刷の順番に行えればどうにか両面にできるのでそうします。つまり、奇数ページのみを集めたPDFファイル、偶数ページのみを集めたPDFファイルを作ります。\nまずはpdftkでページを1枚1枚バラします。pdftk自体は apt install pdftk とかでインストールしておいて下さい。\n$ pdftk file.pdf burst  するとカレントディレクトリに pg_0001.pdf 、 pg_0002.pdf 、 …とページ数分のPDFファイルが展開されます。これを奇数ページだけ、偶数ページだけ拾っていきます。\n$ pdftk $(ls pg_* | sort | xargs -n2 echo | cut -d\\  -f1 ) cat output odd.pdf $ pdftk $(ls pg_* | sort | xargs -n2 echo | cut -d\\  -f2 ) cat output even.pdf  これで作業終わりです。\nあとは\n odd.pdf を印刷 紙束の表裏を返す（紙束を左右に180°回す） even.pdf を印刷  の流れで両面に印刷できます。印刷はEvinceかFirefoxで適当にやって下さい。 普通のプリンタならページ番号が若い方が下になるように印刷されていくので、奇数ページを印刷したあとにそのまま左右に返してセットしなおせば1pの裏に2p、3pの裏に4pが印刷されます。製本っぽいことしたいなら端に水糊を塗ってティッシュペーパをくっつけるとそれっぽくまとまるのであとはガムテープとかで保護してあげて下さい。\n製本している pic.twitter.com/D6ZL36eiwX\n\u0026mdash; κeen (@blackenedgold) January 12, 2020 \npdftkにこういう($k \\mod N$ ページ毎にファイルに振り分ける)機能あってもいいと思うんですけどねー。\nという訳で小ネタでした\n","categories":["PDF","Utility","CLI","備忘録","小ネタ"],"category_urls":["/categories/pdf","/categories/utility","/categories/cli","/categories/%e5%82%99%e5%bf%98%e9%8c%b2","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2020-01-12","title":"pdftkを使って両面印刷する","url":"https://KeenS.github.io/blog/2020/01/12/pdftkwotsukatteryoumen_insatsusuru/"},
  {"body":"κeenです。久しぶりに「強めに型をつける」シリーズです。 マーカとして使われる型について。呼び方が分からなかったので「タグ型」と呼ぶことにします。\nアドホックポリモーフィズム 同じ名前の関数で、（静的に分かる）型に応じて振る舞いを変えるポリモーフィズムのことをアドホックポリモーフィズムと言います。代表的なものはオーバーロードでしょう。\nRustでも「オーバーロード」という名前では呼ばれてませんがアドホックポリモーフィズムがあります。 例えば str::parse メソッドは渡された型パラメータに応じてパースする処理を切り替えます。\n// 整数値としてパースする letinteger=\u0026#34;127\u0026#34;.parse::\u0026lt;i32\u0026gt;().unwrap();usestd::net::IpAddr;// IPアドレスとしてパースする letaddr=\u0026#34;127.0.0.1\u0026#34;.parse::\u0026lt;IpAddr\u0026gt;().unwrap(); 同じ str::parse メソッドですが返り値の型が i32 であるか IpAddr であるかで振る舞いを変えています。\nこの例は型パラメータと返り値の関係が直接的ですね。型パラメータに IpAddr を指定したら IpAddr 用のパース処理が走って、 IpAddr 型が返っています。 しかし返り値（や引数）の型によっては期待する振る舞いが複数あるなど、単純な対応関係にない場合もあります。\n例えばバイト列からu32型を取り出すときにビッグエンディアンかリトルエンディアンかを選びたいことがあるでしょう。\nletmutdata: \u0026amp;[u8]=\u0026amp;[1,0,0,0];// リトルエンディアンで読み出したい letuint: u32 =data.read_u32();// \u0026lt;- ??? assert_eq!(uint,1);letmutdata: \u0026amp;[u8]=\u0026amp;[0,0,0,1];// ビッグエンディアンで読み出したい letuint: u32 =data.read_u32();// \u0026lt;- ??? assert_eq!(uint,1); このコードのままではリトルエンディアンかビッグエンディアンかが使い分けられてなさそうです。 read_u32_be 、 read_u32_le などのように名前を使い分ける手もありますが、読み出す型 x エンディアンで増えていくので作る方も使う方も面倒ですね。 そういった時にタグ型を使うと複数の振る舞いを使い分けられます。 具体的には以下のように書けるようになります。\nletmutdata: \u0026amp;[u8]=\u0026amp;[1,0,0,0];// リトルエンディアンで読み出す letuint: u32 =data.read_u32::\u0026lt;LittleEndian\u0026gt;();// \u0026lt;- !!! assert_eq!(uint,1);letmutdata: \u0026amp;[u8]=\u0026amp;[0,0,0,1];// ビッグエンディアンで読み出す letuint: u32 =data.read_u32::\u0026lt;BigEndian\u0026gt;();// \u0026lt;- !!! assert_eq!(uint,1); タグ型 先述の例を見てもらったら分かるとおり、 LittleEndian と BigEndian という型を使っていますが、値には現われません。タグとしてしか使っていないので作る必要がないからです。\nそういうときに、 LittleEndian と BigEndian に以下のような定義を与えると便利です。\nenum LittleEndian{}enum BigEndian{} struct LittleEndian; ではなく enum LittleEndian {} です。 enum の値は列挙子をコンストラクタとして作られますが、コンストラクタが1つもないので値を作ることができません。これで値の世界には住んでなくて、型の世界の住人であることが明示できます。\nあとはこれらの LittleEndian と BigEndian に「所望のエンディアンで読み出す」機能をつけてあげるだけです。これはトレイトで実現できます。\n// エンディアンを表わすトレイト traitByteOrder{fn read_u32(buf: \u0026amp;[u8])-\u0026gt; u32;// ... }// それぞれのエンディアンに実装していく implByteOrderforLittleEndian{fn read_u32(buf: \u0026amp;[u8])-\u0026gt; u32 {// ... }//... }implByteOrderforBigEndian{fn read_u32(buf: \u0026amp;[u8])-\u0026gt; u32 {// ... }//... } 最後に data.read_u32::LitleEndian() と呼ぶために以下のような便利トレイトを定義します。\nusestd::io;traitReadBytesExt: Read{fn read_u32\u0026lt;BE: ByteOrder\u0026gt;(\u0026amp;mutself)-\u0026gt; u32 {letmutbuf=[0;4];self.read_exact(\u0026amp;mutbuf).unwrap();Ok(BE::read_u32(\u0026amp;buf))}}// Tip: `\u0026amp;[u8]` は `Read` を実装している implReadBytesExtforRead{} こうすれば例のように data.read_u32::\u0026lt;LittleEndian\u0026gt;() と呼び出すことができます。\nletmutdata: \u0026amp;[u8]=\u0026amp;[1,0,0,0];// リトルエンディアンで読み出す letuint: u32 =data.read_u32::\u0026lt;LittleEndian\u0026gt;();// \u0026lt;- !!! assert_eq!(uint,1);letmutdata: \u0026amp;[u8]=\u0026amp;[0,0,0,1];// ビッグエンディアンで読み出す letuint: u32 =data.read_u32::\u0026lt;BigEndian\u0026gt;();// \u0026lt;- !!! assert_eq!(uint,1); めでたしめでたし。\n今回の例は byteorder クレートから採りました。\n別の解釈 軽めのStrategy Patternとも解釈できます。 FullのStrategy Patternと違って値がなくて状態を持てませんが、変わりにストラテジを作るときにアレコレ考える必要がなくて名前をポンッと置けば機能します。\n","categories":["Rust","Rustで強めに型をつける"],"category_urls":["/categories/rust","/categories/rust%e3%81%a7%e5%bc%b7%e3%82%81%e3%81%ab%e5%9e%8b%e3%82%92%e3%81%a4%e3%81%91%e3%82%8b"],"date":"2020-01-11","title":"Rustで強めに型をつけるPart 4: タグ型","url":"https://KeenS.github.io/blog/2020/01/11/rustdetsuyomenikatawotsukerupart_4__tagukata/"},
  {"body":"κeenです。2020年ですね。スレッドを2020個走らせてみましょう。\nMassiveThreadsとは これ 。東大の田浦研が開発している超軽量スレッドライブラリで、通常よりも2桁高速にスレッドを作れるらしいです。\nAPIはだいたいpthreadに似てます。\nSML#とMassiveThreads SML# 3.3.0からデフォルトでMassiveThreadsを使うようになりました。 また、最近リリースされたSML# 3.5.0からpthreadとMassiveThreadsを同時に使うことができるようになりました。 SML#でスレッドをじゃぶじゃぶ扱える訳です。 もうそろそろ64コア128スレッドのThreadripper 3990Xも出るようですしスレッド沢山作れると嬉しいですよね。\nということでナチュラルにSML#からMassiveThreadsを使ってみましょう。\nAPI ベラっと張るとこうなっています。\nstructure Myth = struct type thread (= *) structure Thread = struct type thread = thread val create : (unit -\u0026gt; int) -\u0026gt; thread val detach : thread -\u0026gt; unit val join : thread -\u0026gt; int val exit : int -\u0026gt; unit val yield : unit -\u0026gt; unit val self : unit -\u0026gt; thread val equal : thread * thread -\u0026gt; bool end type mutex (= array) structure Mutex = struct type mutex = mutex val create : unit -\u0026gt; mutex val lock : mutex -\u0026gt; unit val unlock : mutex -\u0026gt; unit val trylock : mutex -\u0026gt; bool val destroy : mutex -\u0026gt; unit end type cond (= array) structure Cond = struct type cond = cond val create : unit -\u0026gt; cond val signal : cond -\u0026gt; unit val broadcast : cond -\u0026gt; unit val wait : cond * mutex -\u0026gt; unit val destroy : cond -\u0026gt; unit end type barrier (= array) structure Barrier = struct type barrier = barrier val create : int -\u0026gt; barrier val wait : barrier -\u0026gt; bool val destroy : barrier -\u0026gt; unit end end See on GitHub\nFFIなのでfinalizerである join や destroy は自分で呼ぶ規約です。\nところで、これだけだと使いづらいのでいくつかスレッドライブラリの上に構築されたライブラリもあります。ConcurrentやCMLなど。 これらも使おうとしたのですが色々あって使ってません。気になる人は使ってみて下さい。\nQuickSort 良い題材が全く思い浮かばなかったのでQuickSortを実装してみます。\nまずはインタフェースファイルに以下を書きます。\n_require \u0026#34;basis.smi\u0026#34; _require \u0026#34;thread.smi\u0026#34; そして並列実行用の関数 join を定義しておきましょう。rayonの joinを意識してみました。\nstructure Thread = Myth.Thread fun join (f1, f2) = let val chan = ref NONE val th = Thread.create (fn () =\u0026gt; 0 before chan := SOME(f2 ())) val r1 = f1 () val _ = Thread.join th val r2 = Option.valOf $ !chan in (r1, r2) end マルチスレッドで ref を使ってるのが気持ち悪いですが一応競合状態にはならないはずなので大丈夫でしょう。\nさて、これを使ってQuickSortを書いていきます。 関係ない関数はバッサり省いて以下のように書けますね。\nfun qsortSlice arr = if ArraySlice.length(arr) \u0026lt;= 1 then () else let open ArraySlice val (l, h) = partition arr (* vvvv ここで `join` を使った*) in ignore $ join((fn () =\u0026gt; qsortSlice l), (fn () =\u0026gt; qsortSlice h)) end fun qsort arr = qsortSlice (ArraySlice.full arr) 普通のアルゴリズムの1箇所を書き換えるだけで並列化できます。\nしかしまあ、これだと遅いので要素数が少なくなったらシングルスレッドにしたり挿入ソートにしたりしましょう。 それが以下のコード。\nval cutOff = 50 val singleThread = 400 fun qsortSlice arr = (* 要素数が少なければ挿入ソートに変更 *) if ArraySlice.length(arr) \u0026lt;= cutOff then insertionSortSlice arr else let open ArraySlice val (l, h) = partition arr (* 要素数に応じてスレッドを使うかを変える *) val join = if length(arr) \u0026lt;= singleThread then joinSingle else join in ignore $ join((fn () =\u0026gt; qsortSlice l), (fn () =\u0026gt; qsortSlice h)) end ここで、 insertionSortSlice は挿入ソートをする関数で、 joinSingle は join のシングルスレッド版、つまり fun joinSingle (f1, f2) = (f1(), f2()) です。 cutOff や singleThread のパラメータは何度か走らせてチューニングしたものです。\nそれでは、実行してみましょう。 雑な線形合同法で初期化した配列をソートしてみます。\nfun rng seed = let open Word32 val seed = fromInt seed val state = ref seed fun next () = let val v = (!state * 0w2017 + 0w2020) mod 0w2027 in toInt v before state := v end in next end val rand = rng 7 val n = case CommandLine.arguments () of [] =\u0026gt; 2020 | arg::_ =\u0026gt; Option.valOf $ Int.fromString arg val arr = Array.tabulate(n, fn i =\u0026gt; rand () + 1) val () = qsort arr このコードを -O3 をつけてコンパイルしてみます。\n$ smlsharp -O3 -o qsort qsort.sml  デフォルトではMassiveThreadsのワーカが1つしか立ち上がらないのでコア数分立ち上がるようにしながら実行します。 Ubuntu 19.10、16コア32スレッドのマシンで time で計測した結果が以下。\n$ time MYTH_NUM_WORKERS=0 ./qsort 808080 MYTH_NUM_WORKERS=0 ./qsort 808080 93.84s user 1.36s system 1244% cpu 7.648 total  7.6秒くらいで終わりました。 配列がおおむねランダム、400要素ごとに並列化しているので808080要素の配列をソートするとざっくり2020個のスレッドが立ち上がってるはずです。\n他のパラメータでもやってみましょう。 MYTH_NUM_WORKERS を設定せずに1並列で実行してみます。\n$ time ./qsort 808080 ./qsort 808080 28.55s user 0.76s system 117% cpu 24.884 total  フルの並列の3倍くらいの時間ですかね。16コアあるのに3倍は世知辛い。\nところでスレッドを立てるのにもコストがかかります。スレッドを一切立てない(= val singleThread = 808080)で実行してみましょう。\n$ time ./qsort 808080 ./qsort 808080 8.29s user 0.05s system 100% cpu 8.293 total  んー、速い。スレッドを立てるだけでかなりのオーバーヘッドがあるのが分かりますね。\nとはいえそもそもスレッドを2000個も立てるの自体普通はやりませんし、まともに動きません。 むしろ、2000個もスレッドを立てた上に何もしないコードより速いと見るべきでしょう。\nということでゆるーくMassiveThreadsを触ってみました。\n今回のコードはこちらに置いておきます。\n余談 当初はCMLなどの高レベルなAPIを触ろうとしてたのですがやめて、シンプルに Myth を触る方向に舵を切りました。 select を使ってスリープソート的なことでもしようかと思ったのですが CML.sameChannel や CML.timeOutEvt が未実装だったり、 Concurrent の Mvar などを使うと遅くなったりしてやめました。 Goくらい雑にスレッドとチャネルを使えると嬉しいんですが。あとIOは勝手にスケジューリングしてくれるんですかね？\nあと全然関係ないですがGCがMassiveThreadsのスタックをどう見にいってるのか気になってます。\n","categories":["SML","SMLSharp","MassiveThreads"],"category_urls":["/categories/sml","/categories/smlsharp","/categories/massivethreads"],"date":"2020-01-04","title":"SML# x MassiveThreadsでスレッドを2020個走らせる","url":"https://KeenS.github.io/blog/2020/01/04/sml__x_massivethreadsdesureddowo2020kohashiraseru/"},
  {"body":"κeenです。2020年注目していきたい技術とか書いていきます。去年までからタイトル変えました。\nAsync Rust async/awaitが安定化されましたね。これで言語側の諸々は終わったので次はコミュニティサイドです。今のところ非同期エコシステムが複数に分断しているので今後のエコシステムの動きに注目です。\nWebAssembly/WASI 2017年以来3年ぶり2度目の注目リストに入りました。 2019年のニュースとしてはWebAssemblyが12/5に正式勧告になりました。これからエコシステムが広がっていくのが期待できますし、WebAssembly自体まだまだMVPなのでWebAssembly本体の発展も期待したいところです。例えばDOMやGCの統合、SIMD、スレッドなどなど今後の拡張が色々あります。私個人としてはWebAssemblyがターゲットのコンパイラを作っているのもあってExceptionの提案に注目しています。\nもう1つWebAssemblyで注目しているのがWASI(WebAssembly System Interface)です。これも2019年の3月にMozillaが標準化を目指すとアナウンスされました。ランタイムのwasmtimeやコンパイラのLucetなどいくつかの実装がBytecode Allianceから出ています。私のコンパイラの吐いたWASMコードをローカル環境で動かすのに使えないかなと思って注目しています。\nWebAuthn Webで公開鍵認証を行なうための仕様として今年3月にWeb Authentication APIが勧告されました。 パスワード認証には薄々限界を感じていて、はやく公開鍵認証が広く世間一般にも使われるようになってほしいと思っているエンジニアの方も多いかと思います。\nやっぱり筋の良いと思う技術は積極的に利用したいですし、一回くらい実装しとかないとなーと思っています。2020年中に触る機会あるかな？\n情報幾何 まだ勉強中の身でよく分かってないですが、確率だとか統計だとかのパラメータを多様体と見做すことでさまざまな分野に散逸していた定理やアルゴリズムを統一的に扱えるようにする学問だそうです。\n情報幾何の埋みの親で2019年に文化勲章を受賞された甘利先生の言葉を引用すると\n 情報要素の一つ一つを分離して考えるのではなく，つながった全体つまり多様体として考えてそこに豊かな構造を導入すれば，情報の分野に新しい方法論を提供できるに違いない．これが情報幾何学の目指すところである\n応用数理2巻(1992)1号 情報幾何学 甘利俊一\n とのことです。\n今のところ機械学習のモデルに解釈を与える手段として注目されているようですが、情報量とかの話は好きなので勉強してみようと思います。 現在、藤原 彰夫 情報幾何学の基礎を読んでいます。まだ2章なので数学的準備ですがとても丁寧で分かりやすいです。多分幾何学を知らなくても読めるんじゃないかと思います。\nSVG 私はよくInkscapeを使うのですが、その保存フォーマットにSVGが使われています。 SVGはWeb技術と親和性が高いですしちょっと使ってみようかなと思いました。 SVG DOMでグリグリ動かしたり、スライドに入れたり（いっそInkscapeでスライドを作るとか？）、色々やってみようと思います。\nBlender 2019年の買い物の1つにOCulus Questがあります。 まあ、あんまり使ってないんですが、折角なので3Dモデリングでもはじめてみようかなと思います。 VRChatに自作アバターで参加するのが目標ですがあんまりVRChatを面白いと思わないのでモチベーションを保てるか不安です。 まあ、VRChatを抜きにしても3Dモデリングは興味あるのでちょっとづずやってみます。\n運動再開 これを入れるためにタイトルから「技術」を抜きました。\n何かの運動を再開したいと思ってます。 中、高、大とスポーツの部活をやっていましたが、大学出る前後から体の調子が悪くなり、社会人になってから運動をやめてしまっていました。 そろそろ体が鈍ってきてるので何かを再開しようかと。\n体の負荷を考えると弓道あたりが妥当なんですがもう一人で稽古できない程勘が失われてるので難しそうです。 どうせなら交友関係が広がるものがいいかなって思ってます。ボルダリングなんかも俎上に載ってるんですがあれも一人なんでね。\nまず何をしたいのか決めるところから考えたいと思います。\n2020年は当たり前に出来ることを増やすのが目標です。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2020-01-02","title":"2020年抱負","url":"https://KeenS.github.io/blog/2020/01/02/2020nenhoufu/"},
  {"body":"κeenです。2019年を振り返る。\n長いので今年からタイトルを短くした。\n2019年注目していきたかった技術 2019年注目していきたかった技術は書いてなかった。 個人的抱負はSMLコンパイラなどの言語処理系をちゃんとやること。 一応SMLコンパイラはちまちま進捗を出したしn月刊ラムダノートに寄稿したりと多少の活動はあった。\n個人的振り返り メトリクス ブログ記事42本、スライド8綴、mendeleyに入れた論文53綴、買った技術書26冊、GitHubのcontribution 3477。共著の出版2本。 その他のメディア（Qiita、会社のブログなど）にも十指で足りる程度書いた。\n総括 大きな話題は実践Rust入門を世に出せたこと。 二度とやるかってくらい大変だった。 それでも頑張った甲斐あってかそれなりに手に取ってもらったようで何より。 Rustは公式ドキュメントがしっかりしてるので差別化の意味でも標準ライブラリのテイストとは変えて実践寄りにしたら色々な反応があって面白かった。 公式ドキュメント（やテイストが似てるオライリーのプログラミングRust）より分かりやすいという人もいれば、実践Rust入門は詳しい説明がないまま知らない機能使いはじめて無理だったっていう人もいた。 それぞれ個々人に合った入門書を選べばいいと思う。\nあとはn月刊ラムダノート Vol. 1, No. 3に寄稿した。 先述のSMLコンパイラを作るときに調べた知識をベースにパターンマッチのコンパイルについて書いた。 本当はコンパイルアルゴリズムを書く予定だったけど長くなりすぎて分割されたので導入部分だけ載った。 次（多分No. 3, Vol. 2かな）にアルゴリズムを寄稿する。原稿はまだ2割くらいだけど実装はある。 まだナイーブな実装だけで最適化もやんないとだけど紙面的にも入るか怪しい。もしかしたら最適化は紙面を諦めてブログに載せることになるかも。\n細々した話だとブログが増えてスライドが減った、論文が減って技術書が増えた。 GitHubのcontribution去年から+700くらいしてる。contributionはパブリックもプライベートもおおむね+25%くらいしてるっぽい。 実践Rust入門が終わったからかな？ ブログは去年より増えたとはいえまだ少ない。週1のペース（年52本ペース）まで回復したいので頑張る。 ペースが落ちた原因としてはインプットが減ったのと1つ1つのブログが重くなってきたので書くのにかかる時間が増えたのが考えられる。 もう少し気軽に書くことにする。\nスライドが減ったのは意図的で、時間を作るために勉強会にあまり行かないことにしたから。まあまあ悪くなさそうなので来年もこのくらいのペースでいきたい。\n2019年も相変わらずRustをやってたけどチマチマIdrisもやってた。 ビルドツールラッパのipkgとかいくつかIdrisで書いたものがあるし、ブログ記事も多少書いた。 最近新しい言語を学ぶペースが落ちてるので火を絶やさずに続けていきたい。\n今年まで執筆とかであまり時間が取れなくて負債が溜まってるので来年はもうちょっとアクティブになるのが目標。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2019-12-30","title":"2019年振り返り","url":"https://KeenS.github.io/blog/2019/12/30/2019nenfurikaeri/"},
  {"body":"このエントリはRustその2 Advent Calendar 2019 - Qiita 25日目の記事です。\nκeenです。私は既に冬休みに突入してます。Happy Holiday！ 「Rustで簡単なコードの書き換えを自動化したいよなー」と思っていたら cargo fix でできるよという啓示を貰ったのでやってみました。\n↓ 啓示。リプライ元は私じゃないですけどね :)\nwrite a lint plugin that uses the diagnostics API, then just use cargo fix\n\u0026mdash; Manish (@ManishEarth) December 12, 2019 \nなるほど。Lintプラグインとcargo fixを使えばいいようです。\nコンパイラプラグイン unstable featureですがRustにはコンパイラプラグインの仕組みがあります。\nplugin - The Rust Unstable Book\nRustのコンパイル中に動くコードを自分で作れるんですね。 proc_macroで代替される予定っぽいのでdeprecated扱いですが一応現時点ではまだ動きます。\nLintプラグイン このプラグインの一種にLintプラグインがあります。 よくRustコンパイラやClippyが「この書き方よくないよ」とか「これこう書けるよ」とか出してくれるやつをユーザが書ける訳です。 上の啓示で触れられているLintプラグインはこれのことです。\ncargo fix 恐らく多くの方がご存知かと思いますが、コンパイラ（や実験的にClippy）が出すLintを自動で適用してくれるツールとしてcargo fixがあります。\nrust-lang/rustfix: Automatically apply the suggestions made by rustc\nそれ以外にもEditionの移行にも使われているので2018 Editionに移行するときにお世話になった方も多いと思います。\nこれらを合わせるとコンパイラのLintプラグインを書けばcargo fixで自動リファクタリングができるようになる訳です。 ちょっと面白そうなのでやってみましょう。\nLint自作入門 先程のコンパイラプラグインの所のドキュメントに大体書いてあります。 Lintがどういう仕組みで動いているかはこちらのブログが参考になりました。\nRust 公式 linter の clippy に新しいルールを実装した - はやくプログラムになりたい\nClippyの話ですがClippy自身もLintプラグインの仕組みを使っているのでだいたい共通します。\n軽くまとめると\n コンパイラの内部APIにアクセスしてLintを出す  そのためコンパイラはnightly必須 ついでにrustc-devコンポーネントも必要  Rustc内部で使われているLintの仕組みがあるのでそのまま乗っかる  EarlyLintPass または LateLintPass を実装してregisterしてあげるだけ   となっております。 EarlyLintPass はコンパイラ内部でASTと呼ばれるフェーズでのLinterで、ほぼソースコードの見た目を構造体にしたものにアクセスできます。 LateLintPass はその次のHIRと呼ばれるフェーズでのLinterで、マクロ展開してたり型情報にアクセスできたりしてます。\nさて、今回の目的はコードの自動修正です。 Lintにはいくつか種類があるようなので自動修正できるLintを出しましょう。\n細々した詳細は省いて元のpluginのドキュメントで以下のように書かれたLintルールがあります。\ndeclare_lint!(TEST_LINT,Warn,\u0026#34;Warn about items named \u0026#39;lintme\u0026#39;\u0026#34;);declare_lint_pass!(Pass=\u0026gt;[TEST_LINT]);implEarlyLintPassforPass{// アイテムに対するLinterを作る fn check_item(\u0026amp;mutself,cx: \u0026amp;EarlyContext,it: \u0026amp;ast::Item){// もしアイテムの名前が \u0026#34;lintme\u0026#34;だったら ifit.ident.name.as_str()==\u0026#34;lintme\u0026#34;{//lintを出す cx.span_lint(TEST_LINT,it.span,\u0026#34;item is named \u0026#39;lintme\u0026#39;\u0026#34;);}}} これは lintme と名付けられたアイテム \u0026ndash; 関数定義やモジュール定義 \u0026ndash; を検出するものです。 これを 「lintme と名付けられたアイテムがあったら lintyou と改名するように提案する」というルールに変えてみましょう。関数定義部分だけ変更していてそれを呼び出す部分は変更しないのでそのままやるとコードが壊れますが、実験的コードなのでまあいいでしょう。\n先に書き換えたコードを見せるとこうなっています。\nimplEarlyLintPassforPass{fn check_item(\u0026amp;mutself,cx: \u0026amp;EarlyContext,it: \u0026amp;ast::Item){ifit.ident.name.as_str()==\u0026#34;lintme\u0026#34;{// \u0026#34;lintme\u0026#34; を見付けるまでは同じ // lintメッセージも同じだが、 `struct_span_lint` を使っている。さらに情報を足せる letmutdiag=cx.struct_span_lint(TEST_LINT,it.span,\u0026#34;item is named \u0026#39;lintme\u0026#39;\u0026#34;);letspan=it.ident.span;// メッセージに提案を含める diag.span_suggestion(// 変更したい部分 span,// 提案のメッセージ \u0026#34;you can rename it\u0026#34;,// 提案内容。これがそのまま適用される \u0026#34;lintyou\u0026#34;.into(),// この提案はツールでどう扱うか。MachineApplicableは一番強くて、cargo fixで自動適用される Applicability::MachineApplicable,).emit()}}} メッセージに追加情報で提案を載せて、機械で扱えるようにします。 変更するときのAPIはこことかから辿っていきましょう。APIが多いのである程度エスパー能力が求められます。\nさて、これをコパイラプラグインとしてビルドし、既存のソースコードに変更を適用してみましょう。\nコンパイラプラグインとしてビルドするには以下のようにCargo.tomlの lib セクションに plugin = true をつけるだけです。\n[package] name = \u0026#34;minimal-lint\u0026#34; # ... [lib] plugin = true ビルドするときはnightlyコンパイラが必要ですし、rustc-devコンポーネントも必要なので rustup component add rustc-dev を忘れないようにしましょう。\nそしてこのルールを適用したいソースコード側でプラグインとしてロードします。 これは普通の依存クレートとして書いてあげます。\n[dependencies] minimal-lint = { path = \u0026#34;/path/to/minimal-lint\u0026#34; } そしてソースコードの lib.rs なり main.rs なりでプラグインを有効にします。\n#![feature(plugin)]#![plugin(minimal_lint)] 試しにlintme という名前の関数を定義してみましょう。\nfn lintme(){} これをビルドすると警告とともに提案が出ます。\nwarning: item is named \u0026#39;lintme\u0026#39; --\u0026gt; tests/lintme.rs:6:1 | 6 | fn lintme() {} | ^^^------^^^^^ | | | help: you can rename it: `lintyou` | = note: `#[warn(test_lint)]` on by default Finished test [unoptimized + debuginfo] target(s) in 0.72s Running target/debug/deps/minimal_lint-6460443341f748b2 cargo fix で修正してみましょう。\n$ cargo fix $ cat source.rs #![feature(plugin)] #![plugin(minimal_lint)] #[allow(dead_code)] fn lintyou() {} // ^^^^^^^ // 変更されている 修正されていますね。\n今回試したコードはこちらに置いています。良かったら参考にして下さい。\nKeenS/minimal-lint\n実践Lint \u0026amp; Fix 「自作Lintルールを書いてcargo fixでリファクタする」だと長いので「Lint \u0026amp; Fix」と呼んでいきましょう。 もう少し大きなプロジェクトでLint \u0026amp; Fixしてみます。\n超個人的な話なのですが、そもそもこれをやろうとしたモチベーションとなるルールがあります。 趣味でコンパイラを書いているのですが、そこによく Box::new(expr) というコードが出てきます。 expr というのはコンパイラのコードに出てくる Expr という名前のデータ型の式です。 こういうコードを書く度に、式を書いたあとに先頭に戻って Box::new() で包むのが面倒と感じていました。 そこで Expr::boxed() というメソッドを生やして expr.boxed() と書けるようにしました。 書けるようにしたはいいのですが今度は既存のコードを修正して回るのが面倒です。 なので自動でやりたいなというのが今回のモチベーションです。\n要約すると、以下の書き換えをします。\nBox::new(expr: Expr) =\u0026gt; expr.boxed() ルールとしてはシンプルですね。これを実装していきましょう。\nLateLintPass Expr 型 の式を Box::new で包んでいる部分をみつけたい訳です。 ここに型情報が登場したので EarlyLintPass ではダメで、 LateLintPass が必要になります。\nつまり書き出しはこうなります。\nimpl\u0026lt;\u0026#39;a,\u0026#39;tcx\u0026gt;LateLintPass\u0026lt;\u0026#39;a,\u0026#39;tcx\u0026gt;forPass{// ... } ライフタイムパラメータが増えた以外は変わらないですね\ncheck_expr 最初の例ではアイテムのLintだったので check_item を使いましたが式をLintしたいので式のList関数をオーバーライドします。こんな感じ\nimpl\u0026lt;\u0026#39;a,\u0026#39;tcx\u0026gt;LateLintPass\u0026lt;\u0026#39;a,\u0026#39;tcx\u0026gt;forPass{fn check_expr(\u0026amp;mutself,cx: \u0026amp;LateContext\u0026lt;\u0026#39;a,\u0026#39;tcx\u0026gt;,expr: \u0026amp;\u0026#39;tcx hir::Expr){// ... }} ここまでは順調ですね。\nBox::new にマッチする これは中々大変です。 複雑に入り組んだデータ型から目的に合うものを捜します。 ExprKindを眺めてどういう表現になっているかエスパーしましょう。\nいくつか絞り込み条件を並べてみます。\n 関数呼び出しである ( Box::new() ) 引数は1つである 関数はパス形式 ( Box::new ) である パス名は \u0026quot;std::boxed::Box::\u0026lt;T\u0026gt;::new\u0026quot; である 唯一の引数の型のパスは \u0026quot;ast::Expr\u0026quot; である  これを丁寧にやっていきます。\n// find Box::new(expr: hir::Expr) letbox_span=expr.span;iflethir::ExprKind::Call(fun,args)=\u0026amp;expr.kind{ifargs.len()\u0026lt;1{return;}letfun_hir_id=fun.hir_id;iflethir::ExprKind::Path(fun)=\u0026amp;fun.kind{letres=cx.tables.qpath_res(fun,fun_hir_id);ifletSome(defid)=res.opt_def_id(){letfunpath=cx.tcx.def_path_str(defid);iffunpath.as_str()==\u0026#34;std::boxed::Box::\u0026lt;T\u0026gt;::new\u0026#34;{letexpr=\u0026amp;args[0];ifletTyKind::Adt(def,_)=cx.tables.expr_ty(expr).kind{letname=cx.tcx.def_path_str(def.did);ifname.as_str()==\u0026#34;ast::Expr\u0026#34;{// ... }}}}}} ごつい見た目ですね。しかしよく見るとちゃんと絞り込み条件通りにやってるのが見てとれるかと思います。 if_chainを使って大変さを軽減するのが常套手段っぽいですが、まだ不慣れでif_chain由来のエラーなのかコード由来のエラーなのか調べるのがきつそうだったので素のまま書きました。 今回で慣れたので次からは if_chain 使っていきます。\n因みにここでパス名を文字列化して比較しているのが正解かは知りません。 どうせ動けばいいだけのコードなので適当に書いてます。 行儀の良い書き方（同等のASTを組み立てて構造体同士で比較など）があれば教えて下さい。\n変更を提案する さて、suggestionを作っていきます。\nパッと思いつくのは Box::new(expr) のうち、 「Box::new(」 を削って 「)」 を .boxed() に変更する提案をすればよさそうです。 真ん中のexpr部分は箇所によってさまざまですが Box の部分は固定文字列なので扱いが簡単そうですからね。 これは変更箇所が複数になるので multipart_suggestionを使っていたのですが、cargo fixしたときに適用されない問題がありました。 調べるとcargo fixでmultipart suggestionが未実装でした。残念…。\nということで頑張って 「Box::new(expr) を expr.boxed() に変更する」 ルールを書いていきます。\nまずは expr からそこに該当する文字列を取り出します。 ソースの文字列は Session に入っているようだったのでそこから該当する範囲のスニペッットを取り出します。\nletexpr_str=cx.tcx.sess.source_map().span_to_snippet(expr.span).unwrap(); これさえあればあとは format!(\u0026quot;{}.boxed()\u0026quot;, expr_str) で済みますね。 残りの部分はこう書けます。\nletmutdiag=cx.struct_span_lint(EXPR_LINT,box_span,\u0026#34;using Box::new() is not recommended\u0026#34;,);diag.span_suggestion(box_span,\u0026#34;you can use .boxed()\u0026#34;,format!(\u0026#34;{}.boxed()\u0026#34;,expr_str),Applicability::MachineApplicable,).emit() 適用する あとは先程と同じくプラグインとしてロードしてcargo fixしてあげるだけです。 出来上がった差分はこちらにあります。また、Lint \u0026amp; Fixに使ったコードはこちら です。\nまとめ コンパイラプラグインとcargo fixを使うことでLint \u0026amp; Fixができます。 最初に触れた通りコンパイラプラグインの機能はdeprecatedなので今書いたコードが将来動かなくなる可能性はありますが、こういうワンショットのためのツールは文字通り書き捨てなので今の一瞬だけ動けばいいですよね。\nもし手元に単純だけど面倒な修正がある方がいたら試してみて下さい。\n","categories":["Rust","Advent Calendar","Rust Advent Calendar","Advent Calendar 2019"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/rust-advent-calendar","/categories/advent-calendar-2019"],"date":"2019-12-23","title":"自作lintルールとcargo fixでRustのコードをリファクタする","url":"https://KeenS.github.io/blog/2019/12/23/jisakulintru_rutocargo_fixderustnoko_doworifakutasuru/"},
  {"body":"このエントリは型 Advent Calendar 2019 - Qiita 22日目の記事です。\nκeenです。Session Typeの話をするつもりでしたが気が変わったのでリソースを管理する型の話をします。 リソースといっても所有権の話ではないです。 DBにWriteできるだとかS3からGetできるだとかです。リソースというよりはアクセス権限の方が正確かもしれません。\n他のエントリが学術的なものばかりなのに対してこれは実装テクニック的な記事です。 型理論のアドベントカレンダーですが、まあいいや。\nモチベーション Webアプリケーションを作っていると、アプリケーションが触るリソースを静的に知りたいことがあります。 例えば、以下のような需要があります。\n データベースが壊れてReadしかできなくなった時にそれでも動く機能はどれか知りたい この機能遅そうだけどキャッシュしたりしてる？ このアプリケーションに渡すAWSの権限はどれが適切か  例えば「このリソース使ってなさそうだから権限外したいんだけど大丈夫？」とか   そのくらい作った人が知っとけよと思うかもしれませんが、複雑になったアプリケーションで正確に把握するのは簡単ではありません。 そういうときに型で静的に「この関数を呼ぶにはこのリソースへのこの権限によるアクセスが必要になる」というのが分かると嬉しいです。\nもうちょっと言うと、それが自動的に求まると嬉しいです。 以下の抽象的な例を見ましょう。\nfetchData: let result = getFromCache if result is null: let data = getFromDB writeToCache(data) result \u0026lt;- data enfif return result キャッシュにRead/Write、DBにReadしています。 このコードから fetchData がアクセスするリソースが「キャッシュにread/write、dbにread」であることが自動で求まって欲しいです。\nこの例だとリソースは2種類、権限もreadとwriteの2種類ですが、現実ではもっと沢山のリソースと権限が必要になります。 例えばawsのリソースはサービス、さらにその中での特定のパスのようにいくらでも細かく分けられますし、そのリソースの各操作単位で権限を管理できるので多様なリソースと権限が出てきます。 以下はawsのドキュメントのポリシーとアクセス許可から引用した設定json。\n{ \u0026#34;version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;statement\u0026#34;: [ { \u0026#34;sid\u0026#34;: \u0026#34;firststatement\u0026#34;, \u0026#34;effect\u0026#34;: \u0026#34;allow\u0026#34;, \u0026#34;action\u0026#34;: [\u0026#34;iam:changepassword\u0026#34;], \u0026#34;resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;sid\u0026#34;: \u0026#34;secondstatement\u0026#34;, \u0026#34;effect\u0026#34;: \u0026#34;allow\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;s3:listallmybuckets\u0026#34;, \u0026#34;resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;sid\u0026#34;: \u0026#34;thirdstatement\u0026#34;, \u0026#34;effect\u0026#34;: \u0026#34;allow\u0026#34;, \u0026#34;action\u0026#34;: [ \u0026#34;s3:list*\u0026#34;, \u0026#34;s3:get*\u0026#34; ], \u0026#34;resource\u0026#34;: [ \u0026#34;arn:aws:s3:::confidential-data\u0026#34;, \u0026#34;arn:aws:s3:::confidential-data/*\u0026#34; ], \u0026#34;condition\u0026#34;: {\u0026#34;bool\u0026#34;: {\u0026#34;aws:multifactorauthpresent\u0026#34;: \u0026#34;true\u0026#34;}} } ] } リソースやアクション（権限）が色々あるのが分かるかと思います。\nこういうのを（ある程度）表現できる型があると実行時に権限が足りなくて落ちるなんてことがないので嬉しいよね、というのがモチベーションです。\n要件を詰める 何が欲しいのかもうちょっとはっきりさせていきましょう。\n前提として、コードはDBやキャッシュなど外部にアクセスする部分とロジックを組み立てる部分に分かれてますしロジックは具体的なDBに依存せずに書かれているとします。\nつまり先程の例をもう少し詳細に書くと以下ではなくて\nfetchData(): let cache = connect to redis let result = cache.query(\u0026#34;get data\u0026#34;) if result is null: let db = connect to postgres let data = db.query(\u0026#34;SELECT * from DATA\u0026#34;) cache.setData(\u0026#34;set ?\u0026#34;, data) result \u0026lt;- data enfif return result fetchData() 以下のように書かれています。\ngetFromCache(conn): return conn.query(\u0026#34;get data\u0026#34;) writeToCache(conn, data): return conn.setData(\u0026#34;set ?\u0026#34;, data) getFromDB(conn): return db.query(\u0026#34;SELECT * from DATA\u0026#34;) fetchData(ctx): let result = getFromCache(ctx.cache) if result is null: let data = getFromDB(ctx.db) writeToCache(data) result \u0026lt;- data enfif return result let cache = connect to redis let db = connect to postgres let ctx = {cache, db} fetchData(ctx) こういう状況から\n fetchData がアクセスするリソースはDBとキャッシュである  つまり ctx はDBとキャシュへのアクセスを提供するコンテキストでないといけない  fetchData がアクセスするDBにはRead権限が必要である  つまり ctx が提供するDBへのアクセスにはRead権限が含まれる  fetchData がアクセスするキャッシュにはReadとWriteの権限が必要である  つまり ctx が提供するキャッシュへのアクセスにはReadとWriteの権限が含まれる   というのを抜き出して欲しいです。 もちろん、 fetchData はDBへのReadしか要求していませんが ReadとWrite両方のアクセス権限があるコンテキストを渡されてもコンパイルが通ってほしいです。\nこれらの要件をそれっぽい言い方をすると\n アクセスするリソースのintersectionを自動でとってほしい リソースの中でもさらにその権限のintersectionを自動でとってほしい リソースの一覧や権限の一覧はサブタイピングなどの構造的多相性が欲しい  ということになります。\nfetchData の話をしましたが流石に getFromCache などは外部ライブラリになるので手でアノテーションをつけます。\nこういったシステムに見覚えないですか？\n…そう、レコード多相です。\nSML#による解法 上記の例をSML#で実装してみます。\nその前にSML#のレコード多相の記法についておさらいしておきましょう。\nSMLの多相パラメータ (SML#とは限らない一般の)SMLの関数定義では fun に続いて多相パラメータを導入できます。\n(* 型アノテーションなしの `id` 関数 *) fun id x =x (* 型アノテーションありの `id` 関数。 `fun` に続いて型パラメータ \u0026#39;a を導入している。 *) fun \u0026#39;a id (x: \u0026#39;a): \u0026#39;a = x SML# のレコード多相 SML# はこの 'a に続いて 'a#{..} と書いて型にアノテーションを書けます。 例えば 「name フィールドを持つレコード」 を表わす型パラメータ以下のように書けます。\n\u0026#39;a#{name: \u0026#39;b} レコード多相によるリソースの管理 それではSML#でリソースを管理してみましょう。\nまずはデータベースへのコネクションは幽霊型を付けておきます。 この幽霊型で権限を表わします。\ndatatype \u0026#39;a db_conn = DbConn datatype \u0026#39;a cache_conn = CacheConn 権限はReadならば {read : unit} 、 Writeならば {write: unit} とつけることにします。\nそしてそれぞれデータアクセス関数には最小限の権限のアノテーションをつけておきます。\n(* それぞれの実装は空 *) fun \u0026#39;a#{ read: unit } readDb (DbConn: \u0026#39;a db_conn) = () fun \u0026#39;a#{ write: unit } writeDb (DbConn: \u0026#39;a db_conn) = () fun \u0026#39;a#{ read: unit } readCache (CacheConn: \u0026#39;a cache_conn) = () fun \u0026#39;a#{ write: unit } writeCache (CacheConn: \u0026#39;a cache_conn) = () これを使って fetchData を定義します。 この関数には型アノテーションが一切出てこないことに注目して下さい。\nfun fetchData ctx = let val () = readCache (#cache_conn ctx) val () = readDb (#db_conn ctx) val () = writeCache (#cache_conn ctx) in () end この関数をREPLにロードすると望み通りDBにRead、キャッシュにWriteの型がついていることが分かります。\nval fetchData = fn : [\u0026#39;a#{cache_conn: \u0026#39;b cache_conn, db_conn: \u0026#39;c db_conn}, \u0026#39;b#{read: unit, write: unit}, \u0026#39;c#{read: unit}. \u0026#39;a -\u0026gt; unit] 一応ちゃんと型検査で弾けるか試してみましょう。\n各のリソースにread only、 read writeな権限を持つコンテキストを用意します。\ntype read_context = { db_conn: {read: unit} db_conn, cache_conn: {read: unit} cache_conn } type read_write_context = { db_conn: {read: unit, write: unit} db_conn, cache_conn: {read: unit, write: unit} cache_conn } val readContext: read_context = { db_conn = DbConn, cache_conn = CacheConn } val readWriteContext: read_write_context = { db_conn = DbConn, cache_conn = CacheConn } 今回の fetchData はキャッシュに書き込んでいてWriteを要求するので readContext ではだめで、 readWriteContext が必要になります。 fetchData に readContext と readWriteContext をそれぞれ与えて実行できるか試してみましょう。\n(* `readContext` を与えると型エラー *) # fetchData readContext; (interactive):14.0-14.20 Error: (type inference 016) operator and operand don\u0026#39;t agree operator domain: \u0026#39;BTNJ#{cache_conn: \u0026#39;BTNK#{read: unit, write: unit} (lambdaDepth: 2147483647 ) cache_conn, db_conn: \u0026#39;BTNL#{read: unit} (lambdaDepth: 2147483647 ) db_conn} operand: {cache_conn: {read: unit} cache_conn, db_conn: {read: unit} db_conn}(* `readWriteContext` を与えると実行される *) # fetchData readWriteContext; val it = () : unit 目論見通り正しいコンテキストでのみ実行されました。 fetchという名前からReadアクセスしかしないだろと思って痛い目に遭わずに済みますね。\nまとめ SML#を使えば安全なWebアプリケーションが作れることが分かりました。\n余談 アクセスするリソースを型で管理するというアイディアはドワンゴのFujitaskからきています。 これを真似て作ったRustのトランザクション抽象化ライブラリではリソースの管理まではしていませんでした。 そのときは特にやるモチベーションがなかったのと、サブタイピングを使ったアクセス権限管理がRustとは相性が悪そうだったのでためらったという経緯があります。 また、AWSのようにアクセス権限管理が必ずしも包含関係にないケースもあるのでそもそもサブタイピングを使うことに疑問がありました（というより個人的にはアクセス権限は直交しててほしいし、Write権限にRead権限を含意しないでほしいと思っています）。 時が流れて権限エラーでアプリケーションが起動に失敗する経験があったり、「データベースのmasterが壊れてreplicaしか読めなくなったらどうなるんだっけ？」などと考えていたりすると権限管理が欲しくなりました。 最初はRustでガッと書こうとしたのですがその前に落ち着いて何があれば表現できるかを考えた結果、レコード多相に行き着きました。 多分同様の表現をRustでもトレイトと関連型で表現できる気がするので試してみようかと思います。\n","categories":["型","SMLSharp"],"category_urls":["/categories/%e5%9e%8b","/categories/smlsharp"],"date":"2019-12-21","title":"リソースを管理する型","url":"https://KeenS.github.io/blog/2019/12/21/riso_suwokanrisurukata/"},
  {"body":"κeenです。Advent Calendarが賑う時期ですが特に関係なくSMLの話します。今年MLアドベントカレンダーやってないんですね。O.Danvyのprintfとその逆のscanfについて。\nPrintf printfはO.DanvyのFunctional unparsing(\u0026lsquo;98)で紹介されたテクニックです。 C言語の printf はフォーマットに依存して引数が変わるので一見すると依存型が必要そうに見えます。 しかし多少のテクニックを用いてSML内のDSLで実現してしまったというのがO.Danvyのprintfです（今回紹介するのは sprintf ですが瑣末な違いですね）。 以下のように使えます。\n(* 文字列は `lit \u0026#34;str\u0026#34;` 、改行は `eol` 、 指定子の結合は `++` 。 *) - sprintf (lit \u0026#34;Hello world!\u0026#34; ++ eol) val it = \u0026#34;Hello world!\\n\u0026#34; : string (* `%` に続いてフォーマッタ （`str`） を指定すると引数が1つ増える *) sprintf (lit \u0026#34;Hello \u0026#34; ++ % str ++ lit \u0026#34;!\u0026#34; ++ eol) val it = fn : string -\u0026gt; string (* 引数を埋めるとフォーマットされる *) - sprintf (lit \u0026#34;Hello \u0026#34; ++ % str ++ lit \u0026#34;!\u0026#34; ++ eol) \u0026#34;world\u0026#34; val it = \u0026#34;Hello world!\\n\u0026#34; : string (* `int` など他のフォーマッタも使える。順に引数が増えていく。 *) - sprintf (lit \u0026#34;The value of \u0026#34; ++ % str ++ lit \u0026#34; is \u0026#34; ++ % int ++ eol) val it = fn : string -\u0026gt; int -\u0026gt; string (* 適用する *) - sprintf (lit \u0026#34;The value of \u0026#34; ++ % str ++ lit \u0026#34; is \u0026#34; ++ % int ++ eol) \u0026#34;x\u0026#34; 3 val it = \u0026#34;The value of x is 3\\n\u0026#34; : string ちょっと不思議な動きですよね。 フォーマッタに何を書くかによって型が変わり、引数が増えたり減ったりしています。 この動きが限定継続を使って実現されています。 実装は以下。意外とシンプルですね。\nstructure Printf = struct infix ++ fun lit x s k = k (s ^ x) fun eol s k = k (s ^ \u0026#34;\\n\u0026#34;) fun f1 ++ f2 = (fn s =\u0026gt; (fn k =\u0026gt; (f1 s (fn s =\u0026gt; f2 s k)))) fun int x = Int.toString x fun str x = x fun % to_str s k = (fn x =\u0026gt; k (s ^ to_str x)) fun sprintf p = p \u0026#34;\u0026#34; (fn x =\u0026gt; x) end 結合している中間の状態 (s: string) と限定継続 (k: string -\u0026gt; 'a) を引き回していますが、 lit から ++ までは比較的スムーズに読めるんじゃないでしょうか。string -\u0026gt; (string -\u0026gt; 'a) -\u0026gt; 'a がフォーマッタの型ですね。\nここでテクニックが入っているのは % です。つぶさに見てみましょう。\nfun % to_str s k = (fn x =\u0026gt; k (s ^ to_str x)) 関数から返るところに継続の起動 (k の適用) ではなくただのクロージャ(fn x =\u0026gt; ...)を置いています。 継続を一旦止めてフォーマッタの外に出て、引数(x)を受け取ってから改めて継続を起動しています。 これでフォーマッタの外に並んだ値を1つ取り出せます。そして受け取った値は文字列にしたいので to_str で文字列化しています。\nsprintf については仕組みが分かれば簡単ですね。 成果物の文字列の初期状態 (\u0026quot;\u0026quot;) と限定継続の初期継続((fn x =\u0026gt; x)) を渡してフォーマッタを起動しているだけです。\nScanf で、その双対のscanfを考えてみましょう。 printfが20年前のものですし多分既知の結果があるかと思いますが、こういうのは答えを見ずに考えるのが楽しいですよね。\n値のリーダー さて、 scanf を実装するにあたってSMLで整数やブール値をパースする技法を紹介しておきます。 簡単な処理なら fromString などもあるのですが今回のように複数のscanを連接したい場合は StringCvt モジュール（に関連した機能）を使うことになります。\nStringCvt.scanString はリーダーと文字列を取ってリーダーの指定した値を読み取ります。リーダーはそれぞれの型に scan などの名前で定義されています。Bool の scan を見てみましょう。\n- Bool.scan; val it = fn : (char,\u0026#39;a) StringCvt.reader -\u0026gt; (bool,\u0026#39;a) StringCvt.reader これを StringCvt.scanString で使って整数値を読み取ってみましょう。\nまず、 StringCvt.scanString に Bool.scan を渡すと以下のように string を受け取って bool option を返す型ができます。\n- StringCvt.scanString Bool.scan; val it = fn : string -\u0026gt; bool option これを使っていくつかの文字列を読み取ってみましょう。\n- StringCvt.scanString Bool.scan \u0026#34;true\u0026#34;; val it = SOME true : bool option - StringCvt.scanString Bool.scan \u0026#34;false\u0026#34;; val it = SOME false : bool option - StringCvt.scanString Bool.scan \u0026#34;hoge\u0026#34;; val it = NONE : bool option このように読み取れました。\nところで、この関数は末尾に余計な文字列があってもそのままパースできます。\n- StringCvt.scanString Bool.scan \u0026#34;truetrue\u0026#34;; val it = SOME true : bool option というか、パースしたときにどこまで読んだかが分かりませんね。 この動きは便利な場面もあるかと思いますが、今回のように複数の値を読み出したいときには不便です。 2つ目の値をどこから読み始めたらいいか分かりません。 scanString を使うのではなく別の方法を考えましょう。\n実は、既にパースした結果と残りの文字列を得る方法はあります。最初に Bool.scan を紹介したときに出てきた型、 StringCvt.reader の中身を見せてませんでしたね。これは以下のように定義されています。\ntype (\u0026#39;a,\u0026#39;b) reader = \u0026#39;b -\u0026gt; (\u0026#39;a * \u0026#39;b) option 'a が読み出したい型、 'b がストリームの型です。 ここでは 'a が bool 、 'b が文字列だとすると文字列から bool 値を読み取ってその結果と残りの値を返す関数になります。 これをそのまま文字列に適用してあげればよさそうですね。ここで改めて Bool.scan の型を見てみましょう。\nval scan: (char, \u0026#39;a) StringCvt.reader -\u0026gt; (bool, \u0026#39;a) StringCvt.reader (bool, 'a) StringCvt.reader を得るにはストリーム char を読み出すリーダーがまず必要になっています。 それ相当の関数やデータ型は String や Char には定義されていません。 しかしSubstringにはあります。 getc です。\nval getc : substring -\u0026gt; (char * substring) option Substring は string の上に構築されたビューで、典型的な実装は string とその範囲を表わす整数2つで表現されます。Substring を作るには string から Substring.full で作れます。ちょっと動きを見てみましょう。\n(* `Substring.full` で `substring` を作る *) - val s = Substring.full \u0026#34;truetrue\u0026#34;; val s = - : substring (* ↑の通り `substring` は綺麗に表示されないので自分で表示関数を作る（↓） *) - val printSubstring = print o Substring.string; val printSubstring = fn : substring -\u0026gt; unit (* `Substring.getc` を使ってみる *) - case Substring.getc s of SOME((char, s)) =\u0026gt; printSubstring s | NONE =\u0026gt; (); ruetrue (* ↑ 先頭の `#\u0026#34;t\u0026#34;` が消費されて残りの `\u0026#34;ruetrue\u0026#34;` が返ってきてることが分かる。 *) これで望んだ動きをしているようです。 なので Substring.getc を Bool.scan などの scan 関数に渡せばパースする関数を得られます。 少し大袈裟ですがこれをモジュールにしておきましょう。\nstructure SubstringCvt = struct fun scanWith scan = scan Substring.getc end ちょっと使ってみます。\n(* `Bool.scan` と組み合わせて `bool` 値ろリーダーを作っておく *) - val boolReader = SubstringCvt.scanWith Bool.scan; val boolReader = fn : (bool,substring) StringCvt.reader (* 前回同様に `substring` の文字列を用意しておく *) - val s = Substring.full \u0026#34;truetrue\u0026#34;; val s = - : substring (* 読み出す。相変わらず `substring` は表示されてないが `\u0026#34;true\u0026#34;` が残っている *) - boolReader s; val it = SOME (true,-) : (bool * substring) option 因みに整数値のリーダーはパースするときの基数を指定するので引数が1つ多くになってます。\n(* 10進数の整数値リーダー *) - val intReader = SubstringCvt.scanWith (Int.scan StringCvt.DEC); val intReader = fn : (int,substring) StringCvt.reader 固定文字列のリーダー 順番逆だろって気がしなくもないですが、値のリーダーが作れたので固定文字列のリーダーを作りましょう。 これは用意された仕組みがないので自分で作ります。 そのためのパーツを紹介します。 まずは固定文字列と前方一致しているか確認する Substring.isPrefix 。\nSubstring.isPrefix: string -\u0026gt; substring -\u0026gt; bool 読み込んだ部分を切り取るのは triml でできそうです。切り取る長さを指定して左から切り取ります。\nval triml: int -\u0026gt; substring -\u0026gt; substring これを組み合わせて以下です。\nfun readFixed s input = if Substring.isPrefix s input then SOME(s, (Substring.triml (String.size s) input)) else NONE Scanf その1 リーダーが揃ったところでscanfを作っていきましょう。 いきなり実装を載せると以下です。\nstructure Scanf = struct infix ++ fun lit x s v = case readFixed x s of SOME(_, rest) =\u0026gt; SOME(v, rest) | NONE =\u0026gt; NONE fun eol s v = lit \u0026#34;\\n\u0026#34; s v fun f1 ++ f2 = (fn s =\u0026gt; (fn v =\u0026gt; Option.mapPartial (fn (v, s) =\u0026gt; f2 s v) (f1 s v))) fun int rdr = Int.scan StringCvt.DEC rdr fun bool rdr = Bool.scan rdr fun % scan s v1 = Option.map (fn (v2, s) =\u0026gt; ((v1, v2), s)) (SubstringCvt.scanWith scan s) fun sscanf p s = p (Substring.full s) () (* end 基本は読み出すsubstring (s) と読み出した値 (v) を持ち回ってパースしています。パース結果が option に包まれているので Option.map: ('a -\u0026gt; 'b) -\u0026gt; 'a option -\u0026gt; 'b option や Option.mapPartial: ('a -\u0026gt; 'b option) -\u0026gt; 'a option -\u0026gt; 'b option が登場してますがあんまり気にしなくていいです。\nそして今回も % の実装がキモになります。見ていきましょう。\nfun % scan s v1 = Option.map (fn (v2, s) =\u0026gt; ((v1, v2), s)) (SubstringCvt.scanWith scan s) 引数に渡ってるのはリーダーの scan と読み出すストリーム s 、引き回している値 v1 です。 関数本体ではまず (SubstringCvt.scanWith scan s) で値をパースして取り出しています。 そのあと Option.map で結果が成功だった関数を適用します。リーダは読み出した値 v2 と、読み出した残り s を返すのでそれを返して終わりです。 返すときに (v1, v2) のように今までに読んだ値と今読んだ値1つのタプルにまとめています。\nあとは sscanf ですが p にストリームの初期値 ((Substring.full s)) と値の初期値 (()) を与えているだけです。\nこれを使ってみましょう。\n- sscanf (lit \u0026#34;input: \u0026#34; ++ %int ++ lit \u0026#34;, \u0026#34; ++ %int) \u0026#34;input: 5, 17\u0026#34; val it = SOME ((((),5),17),-) : (((unit * int) * int) * substring) option 一応読み出せています。一応と言ったのは返り値を見ると分かります。 ((((),5),17),-) とちょっと渋いことになってますね。 SMLにはヘテロなリストはありませんしタプルの要素を増やすこともできないので仕方のない話ではあります。\nしかし printf に渡す値はそうなってませんでしたよね。 カリー化された関数として複数の値を受け取っていました。 じゃあscanfも同様にして複数の値を返してみましょう。 つまり、カリー化された継続を受け取って複数の値を返すのです。\nScanfその2 継続をユーザから受け取ることにした実装が以下です。\nstructure Scanf2 = struct infix ++ fun lit x s v = case readFixed x s of SOME(_, rest) =\u0026gt; SOME(v, rest) | NONE =\u0026gt; NONE fun eol s v = lit \u0026#34;\\n\u0026#34; s v fun f1 ++ f2 = (fn s =\u0026gt; (fn v =\u0026gt; Option.mapPartial (fn (v, s) =\u0026gt; f2 s v) (f1 s v))) fun int rdr = Int.scan StringCvt.DEC rdr fun bool rdr = Bool.scan rdr fun % scan s k = Option.map (fn (v, s) =\u0026gt; (k v, s)) (SubstringCvt.scanWith scan s) fun sscanf p s = p (Substring.full s) end lit などはほぼそのまま受け流しているだけなので変わっていません。 変わったのは % の値のタプルを作っていた箇所だけです。 (v1, v2) となっていた部分が k v と継続に値を渡すように変化しています。多値の継続に1つづず値を埋めていくイメージです。 あとは地味に sscanf も値の初期値を取らなくなってますがまあそこはいいですかね。\nこれを使ってみましょう。\n(* `sscanf` を呼ぶと継続を受け取るように型が変わっている*) - sscanf (lit \u0026#34;input: \u0026#34; ++ %int ++ lit \u0026#34;, \u0026#34; ++ %int) \u0026#34;input: 5, 17\u0026#34; val it = fn : (int -\u0026gt; int -\u0026gt; ?.X1) -\u0026gt; (?.X1 * substring) option (* 継続として2つの値を受け取ってタプルにして返す関数を書くとちゃんと読み取れてる *) - sscanf (lit \u0026#34;input: \u0026#34; ++ %int ++ lit \u0026#34;, \u0026#34; ++ %int) \u0026#34;input: 5, 17\u0026#34; (fn x =\u0026gt; fn y =\u0026gt; ((x, y))) val it = SOME ((5,17),-) : ((int * int) * substring) option ということでscanfも実装できました。めでたしめでたし。\nメタ SMLのコードがハイライトされずに読みづらいのは今しばしお待ち下さい。そのうち解消されます。\nhugoでSMLのコードがハイライトされないのにキレてhugo内部で使ってるハイライトエンジンにSMLサポート追加してもらったhttps://t.co/65SWaguBwp\n\u0026mdash; κeen (@blackenedgold) December 2, 2019 \n","categories":["ML","SML","継続"],"category_urls":["/categories/ml","/categories/sml","/categories/%e7%b6%99%e7%b6%9a"],"date":"2019-12-21","title":"SMLで継続を使ってprintf/scanf","url":"https://KeenS.github.io/blog/2019/12/21/smldekeizokuwotsukatteprintf_scanf/"},
  {"body":"このエントリは言語実装 Advent Calendar 2019 - Qiita 16日目の記事です。1日ばかりフライングですが先に記事が完成してしまったので投稿します。\nκeenです。最近最適化コンパイラの本の読書会をやっているのですが、そこで学んだことの一部をアウトプットします。\nDependencyとは ここで扱うDependencyとは何なのか、Dependencyが分かると何が嬉しいのかを見ていきます。\n例えば以下のプログラムを考えましょう。\n\nletmutv=1;v+=1;println!(\u0026#34;{}\u0026#34;,v); 最初のプログラム \n変数 v を1に束縛したあと v に1を足し込み、それを表示しています。結果は2が表示されますね。\n\n2 最初のプログラムの実行結果 \nもしこのプログラムの2行目と3行目を入れ替えて以下のようにしたとしましょう。\n\nletmutv=1;println!(\u0026#34;{}\u0026#34;,v);v+=1; 最初のプログラム書き換えたもの \nこれだと v に1足し込む前に v の値を表示しているので1が表示されますね。\n\n1 最初のプログラム書き換えたものの実行結果 \n結果が変わってしまいました。一般に、プログラムを書き換えると結果が変わってしまうことがあります。\nもう1つ、例を見てみましょう。以下のプログラムを考えます。変数が1つ増えました。\n\nletmutv=1;letmutw=1;v+=1;w+=1;println!(\u0026#34;{}\u0026#34;,v+w); 2つめのプログラム \n実行すると4が表示されますね。\n\n4 2つめのプログラムの実行結果 \nこのプログラムも先程と同様に3行目と4行目を入れ替えて1を足し込む順番を変えたらどうなるでしょう。\n\nletmutv=1;letmutw=1;w+=1;v+=1;println!(\u0026#34;{}\u0026#34;,v+w); 2つめのプログラムを書き換えたもの \nこの場合は結果は変わらず4が表示されます。\n\n4 2つめのプログラムを書き換えたものの実行結果 \nプログラムの順番を変更したにもかかわらず、結果が変わっていません。 最初の例とこの例違い、もちろん感覚では分かるかと思いますが、ちゃんと理路整然と説明できますか？ もうちょっと言うとプログラムの順番の変更で結果が変わるかと変わらないかを判定するプログラムを書けますか？\nこの違いを説明するために使う語彙が「Dependency」、それをプログラムで調べて書き換えられるかを検査するのが「Dependency Analysis」です。\nさて、Dependencyが分かると何が嬉しいのかを見ていきましょう。 先程までの例だと少し単純すぎるのでもうちょっと実用的な例を出します。 以下のシンプルなプログラムを考えます。\n\nfn f(v: \u0026amp;mut[f32]){foriin0..(v.len()-1){v[i+1]=v[i]+1.0;}} シンプルなループ \n次の要素に今の要素 + 1.0をしているだけのかわいいループです。\nこの関数を実行するときは全て1.0で埋まった128要素の配列（要するに[1.0; 128]）を渡してあげることにします。\n実行せずにいきなり書き換えてしまいますが、このプログラムはloop unrollして以下のように書き換えられますね。\n\nconstSIZE: usize =8;fn f(v: \u0026amp;mut[f32]){letlimit=v.len()-1;foriin(0..(limit-(SIZE-1))).step_by(SIZE){v[i+1]=v[i]+1.0;v[i+2]=v[i+1]+1.0;v[i+3]=v[i+2]+1.0;v[i+4]=v[i+3]+1.0;v[i+5]=v[i+4]+1.0;v[i+6]=v[i+5]+1.0;v[i+7]=v[i+6]+1.0;v[i+8]=v[i+7]+1.0;}foriin(limit/SIZE*SIZE)..limit{v[i+1]=v[i]+1.0;}} unrollしたループ \nここまではプログラムの結果は変わらず1.0づつ増える数列になります。\n\n1, 2, 3, 4, 5, 6, 7, 8 9, 10, 11, 12, 13, 14, 15, 16 17, 18, 19, 20, 21, 22, 23, 24 25, 26, 27, 28, 29, 30, 31, 32 33, 34, 35, 36, 37, 38, 39, 40 41, 42, 43, 44, 45, 46, 47, 48 49, 50, 51, 52, 53, 54, 55, 56 57, 58, 59, 60, 61, 62, 63, 64 65, 66, 67, 68, 69, 70, 71, 72 73, 74, 75, 76, 77, 78, 79, 80 81, 82, 83, 84, 85, 86, 87, 88 89, 90, 91, 92, 93, 94, 95, 96 97, 98, 99, 100, 101, 102, 103, 104 105, 106, 107, 108, 109, 110, 111, 112 113, 114, 115, 116, 117, 118, 119, 120 121, 122, 123, 124, 125, 126, 127, 128 シンプルなループ/unrollしたループの実行結果 \nこれをSIMD化してみましょう。ループ内の8回の足し算を一度に同時に行なってしまう訳です。\n\nfn f(v: \u0026amp;mut[f32]){// アラインメントの扱いが面倒 \u0026amp; + 1してるのでどのみちアライメントが崩れるのでloadu/storeuを使う usestd::arch::x86_64::{_mm256_add_ps,_mm256_loadu_ps,_mm256_set1_ps,_mm256_storeu_ps};unsafe{letlimit=v.len()-1;letones=_mm256_set1_ps(1.0);letptr=v.as_mut_ptr();foriin(0..(limit-(SIZE-1))).step_by(SIZE){letdata=_mm256_loadu_ps(ptr.offset(iasisize));letret=_mm256_add_ps(data,ones);_mm256_storeu_ps(ptr.offset((i+1)asisize),ret);}foriin((limit-(SIZE-1))/SIZE*SIZE)..limit{v[i+1]=v[i]+1.0;}}} SIMD化したループ \nちょっと厳ついプログラムになってしまいました。\nこれを実行してみると、結果が変わってしまっていることが分かます。\n\n1, 2, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 2, 2, 2, 2, 2, 2 2, 3, 4, 5, 6, 7, 8, 9 SIMD化したループの実行結果 \nこのプログラムはSIMD化できないんですね。 じゃあSIMD化が常に悪かというと、そうでもありません。 今度は書き込む場所を v[i + 1] から v[i - 1] にしてみましょう。\n\nfn f(v: \u0026amp;mut[f32]){foriin1..v.len(){v[i-1]=v[i]+1.0;}} 書き込み場所を v[i - 1] にしたループ \nこれは結果はこうなります。\n\n2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 1 書き込み場所を v[i - 1] にしたループ \nこの関数をSIMD化してみましょう。\n\nfn f2(v: \u0026amp;mut[f32]){usestd::arch::x86_64::{_mm256_add_ps,_mm256_loadu_ps,_mm256_set1_ps,_mm256_storeu_ps};unsafe{letlimit=v.len();letones=_mm256_set1_ps(1.0);letptr=v.as_mut_ptr();foriin(1..(limit-(SIZE-1))).step_by(SIZE){letdata=_mm256_loadu_ps(ptr.offset(iasisize));letret=_mm256_add_ps(data,ones);_mm256_storeu_ps(ptr.offset((i-1)asisize),ret);}foriin((limit-(SIZE-1))/SIZE*SIZE)..limit{v[i-1]=v[i]+1.0;}}} 書き込み場所を v[i - 1] にしたループをSIMD化したプログラム \nこの結果は変わらずこうなります。\n\n2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 2 2, 2, 2, 2, 2, 2, 2, 1 書き込み場所を v[i - 1] にしたループをSIMD化したプログラムの実行結果 \nこっちの場合だとSIMD化は合法な変換となりました。 SIMD化ができればプログラムは速くなるので、書き換えられる場合書き換えられない場合を見極められると嬉しいですよね。\n依存関係基本のキ 最初のプログラムを再掲します。\n\nletmutv=1;v+=1;println!(\u0026#34;{}\u0026#34;,v); 最初のプログラム（再） \nこれの2行目と3行目を入れ替えるとプログラムの結果が変わるのでした。 それぞれ何をしているか少し抽象的に書くとこうなります。\n 2行目: 変数 v に値を書き込んでいる 3行目: 変数 v から値を呼び出している  同じ変数 に対する 書き込み のあとに 読み出し です。一般にこれらの順番を入れ替えるとプログラムが壊れるのです。また、入れ替えたあとに元に戻すことを考えると、読み出しのあとに書き込みをしてもプログラムが壊れるのが分かるかと思います。さらに、書き込み同士でも順番を入れ替えるとプログラムの結果が変わります。\n\nletmutv=1;v=0;v=2;println!(\u0026#34;{}\u0026#34;,v); 同じ変数に2回書き込むプログラム \nこの2行目と3行目を入れ替えると結果が変わりますね。\nこのように同じ変数に対する読み書きは順番を入れ替えるとプログラムの結果が変わってしまいます。このことをデータの 依存関係 （Dependency）があると言います。先程紹介した読み出し-書き込み、書き込み-読み出し、書き込み-書き込みの依存関係にはそれぞれ名前がついています。\n 読み出し-書き込み: フロー依存 (flow dependence) 書き込み-読み出し: 逆依存 (anti-dependence) 書き込み-書き込み: 出力依存 (output dependence)  なお、読み出し-読み出しは入れ替えても結果が変らないので気にしないことにします。 一応これにも 入力依存 (input dependence) という名前がついていて、入力依存のあるプログラム同士を近くに配置するとレジスタやキャッシュの再利用が捗るなどの使い途はあるのですが今回の主眼ではないので扱いません。\nさて、プログラムの1行目を $\\mathit{L1}$ 、 2行目を $\\mathit{L2}$ などと表記することにすると、 $\\mathit{LN}$ から $\\mathit{LM}$ へフロー依存関係があることを、もったいぶって以下のように書きます。\n\\[ \\mathit{LN}\\ \\delta{}^f\\ \\mathit{LM} \\]\n他にも逆、出力依存はそれぞれ $\\mathit{LN}\\ \\delta{}^a\\ \\mathit{LM}$ 、 $\\mathit{LN}\\ \\delta{}^o\\ \\mathit{LM}$ と書きます。あとどの種類でもいいので依存があることを $\\delta^*$ と書いたりもします。\n最初のプログラムの例でいうと $\\mathit{L1}\\ \\delta^f\\ \\mathit{L2}$ 、 $\\mathit{L2}\\ \\delta^a\\ \\mathit{L2}$ （v += 1 は v = v + 1 なので）、 $\\mathit{L2}\\ \\delta^f\\ \\mathit{L3}$ ですね。フロー依存と逆依存から構成されています。\n記法を紹介しましたが以後も「どこどこからここそこにフロー依存がある」と説明するので特に使う予定はありません。ホワイトボードなんかに書くときに使って下さい。あと論文読んでるとたまに出てきます。\n偽りの依存とSSA さて、3つの依存のうち、フロー依存が真の依存、それ以外は偽りの依存と言われています。 出力依存があるプログラムを思い出してみましょう。\n\nletmutv=1;v=0;v=2;println!(\u0026#34;{}\u0026#34;,v); 同じ変数に2回書き込むプログラム（再） \nこのプログラムは簡単な書き換えで出力依存が消えます。\n\nletv1=1;letv2=0;letv3=2;println!(\u0026#34;{}\u0026#34;,v3); 同じ変数に2回書き込むプログラムを書き換えて出力依存をなくしたもの \n同様に逆依存も変数名のつけかえで依存関係を消せます。 もう少し言うと、変数の上書きを禁止して、上書く場合は新しい変数を導入することにすると、変数の書き換えがそもそもなくなるので逆や出力の依存関係が発生しなくなります。\nさてこの変換、便利なのであらゆるプログラムに適用したいのですが1つ障害があります。 if やループなど制御フローの絡むプログラムだと詰んでしまいます。\n\nfn f(cond: bool)-\u0026gt; i32 {letmutv=0;ifcond{v=1;}else{v-=1;}returnv;} if文のあるプログラム \n\nfn sum(n: i32)-\u0026gt; i32 {letmuti=0;letmutsum=0;loop{ifi\u0026lt;n{break;}i+=1;sum+=i;}returnsum;} loop文のあるプログラム \nこれらはプログラムのある地点に至るまでに通った経路がその時々で変わるのでバシっと「この値を使う」と言えません。 そこで「こちらから来たときはこの値、そちらから来たときはその値」を取る演算子 φ を導入してあげます。 φ 演算子を使うと先程のプログラムも変数の書き換えがないように変換できます。\n\nfn f(cond: bool)-\u0026gt; i32 {letv1=0;ifcond{letv2=1;}else{letv3=v1-1;}// 「変数名」と「変数が定義された場所」と「どの経路を通ってきたか」が簡単に対応づくので // 「then節から来たときはv2、else節から来たときはv3」の略記として以下を採用する letv4=φ(v2,v3);returnv4;} if文のあるプログラムの変換 \n\nfn sum(n: i32)-\u0026gt; i32 {leti1=0;letsum1=0;loop{leti2=φ(i1,i3);letsum2=φ(sum1,sum3);ifi2\u0026lt;n{break;}leti3=i2+1;letsum3=sum2+i3;}returnsum3;} loop文のあるプログラムの変換 \nこうしてできあがった「変数の上書き禁止」、つまり1変数あたり1代入のプログラムは 静的単一代入 （Static Single Assignment、SSA）形式と呼ばれます。\nSSAは3種類あった依存関係を1種類にまで落としているのでプログラムの諸々解析がやりやすく、LLVMやGCCなど多くのコンパイラで内部表現として使われています。 LLVMを使っている人には馴染みのある形式でしょう。\nSSAの限界 前節のストーリーのまま進めばよかったのですが、残念ながらSSAには限界があります。 ポインタが来ると無力です。LLVMでもスタックやヒープの値は書き換え可能ですよね。 さらに配列とループが来ると死にます。例えばQuick Sortのプログラムを思い浮かべてみて下さい。これの依存関係を実行前に事前に除去するのは無理そうですね。 一応SSAを拡張して配列も扱えるようにする話もなくはないみたいですが、大人しく諦めた方がよさそうです。\nSSAで配列を扱うのは諦めましたが、これは一般の場合で扱うのが難しいだけです。 条件が揃えば配列とループを使うコードでも依存関係の分析ができます。 それをやっていきましょうというのが今回の主題です。\nループの正規化 今回扱うのがループと配列ということが決まったので、ループを扱いやすくしておきましょう。 ループの繰り返しに使う変数（誘導変数 （induction variable））ってループ展開の例で出てきたように8つ飛ばしだったりします。\n\nconstSIZE: usize =8;foriin(1..(limit-(SIZE-1))).step_by(SIZE){v[i-1]=v[i]+1.0;v[i]=v[i+1]+1.0;v[i+1]=v[i+2]+1.0;v[i+2]=v[i+3]+1.0;v[i+3]=v[i+4]+1.0;v[i+4]=v[i+5]+1.0;v[i+5]=v[i+6]+1.0;v[i+6]=v[i+7]+1.0;} unrollされて誘導変数が8刻みになったループ \nこれをループの回転に使う変数とループ内で使う変数に分離します。 ループの回転に使う変数の方は0から始まって1刻みで進むようにします。 要するに「今ループのn回目」というのを表現する変数です。 これをループの 正規誘導変数 （normalized induction variable）といいます。 元の誘導変数は正規誘導変数から計算します。\n\nconstSIZE: usize =8;// 正規誘導変数 ni を使って0から1刻みでループを回す forniin0..(limit-(SIZE-1)-1)/SIZE{// 元の誘導変数 i は正規誘導変数 ni から計算する leti=SIZE*ni+1;v[i-1]=v[i]+1.0;v[i]=v[i+1]+1.0;v[i+1]=v[i+2]+1.0;v[i+2]=v[i+3]+1.0;v[i+3]=v[i+4]+1.0;v[i+4]=v[i+5]+1.0;v[i+5]=v[i+6]+1.0;v[i+6]=v[i+7]+1.0;} unrollされて誘導変数が8刻みになったループ \nループの正規形が得られました。 そして今回扱う対象ですが、ループの 反復空間 （iteration space）が正規誘導変数のアフィン式で書けるようなループのみ扱うことにします。以下に正規誘導変数のアフィン式で書ける反復空間、書けない反復空間の例を挙げます。\n例: (i を正規誘導変数、N を適当な定数とする)\n OK: 0 \u0026lt; i, i \u0026lt; N (= i \u0026gt; 0 , -1 * i + N \u0026gt; 0) OK: 1 \u0026lt; i, 4 * i + 1 \u0026lt; N (= i - 1 \u0026gt; 0, -4 * i + (-1 + N) \u0026gt; 0) NG: 0 \u0026lt; i, i * i \u0026lt; N  配列を舐める素直なループは大抵該当しますが、 loop でグルグル回って特定の条件を満たしたら break するような変則的なループだと該当しません。\n依存関係の分析 準備の万端が整ったので依存性の解析をしていきましょう。\nまずはシンプルなループについてです。\n\nfn f(v: \u0026amp;mut[f32]){foriin0..(v.len()-1){v[i+1]=v[i]+1.0;}} シンプルなループ（再） \nこのループを正規化します。といってもほぼ正規化されてるのであんまり変化はないです。\n\nfn f(v: \u0026amp;mut[f32]){forniin0..(v.len()-1){leti=ni;v[i+1]=v[i]+1.0;}} 正規化したシンプルなループ \nこのループの繰り返しの間での依存関係を求めたいです。 ループ内では1つ配列から1回読み出して1回書き込んでるので話は簡単ですね。 「読み出しと書き込みで同じ場所を触るのはいつか」という問いを立てればよさそうです。\nもうちょっと言うと「$i_1$ 番目のループでの読み出しと $i_2$ 番目のループでの書き込みが一致する条件」を問えばよいです。読み出しはインデックスに i 、書き込みはインデックスに i + 1 を使っていて、 let i = ni なので以下の式が立ちます。\n\\[ i_1 = i_2 + 1 \\]\nこの式から書き込みと読み出しの関係を計算します。配列の要素に書き込んだあと、ループが何回転回ったら読み込むかを計算すればよさそうです。この値を 依存距離（dependence distance）といいます。\n\\[ i_1 - i_2 = 1 \\]\n1と出ました。書き出した値を次のループで読み出しているということです。 つまり、 ループの繰り返しの間にフロー依存があります。 一般に依存距離が正ならループの繰り返し間にフロー依存があります。 フロー依存のあるプログラムをSIMD化した（書き込む前に読み出した値で計算した）のでプログラムが壊れた訳です。\nさて、では書き込む要素を v[i - 1] にしたバージョンでやってみましょう。\n\nfn f(v: \u0026amp;mut[f32]){foriin1..v.len(){v[i-1]=v[i]+1.0;}} 書き込み場所を v[i - 1] にしたループ（再） \nこれもループを正規化します。\n\nfn f(v: \u0026amp;mut[f32]){forniin0..v.len()-1{leti=ni+1;v[i-1]=v[i]+1.0;}} 正規化した書き込み場所を v[i - 1] にしたループ \nここから色々あって次の式が立ちます。\n\\[ i_1 + 1 = i_2 + 1 - 1 \\]\n依存距離を計算します。\n\\[ i_1 - i_2 = -1 \\]\n今度は-1が出ました。一般に依存距離が負ならループの繰り返し間に逆依存があります。 逆依存（読み出したあとに書き込まれる依存）のあるプログラムで書き込む前に読み出した値を使って計算しても特に問題はないのでプログラムが壊れなかった訳です。\nこれでループのあるプログラムでも特定の条件を満たせば依存関係を分析できましたし、SIMD化もできるようになりました。\n依存関係の分析の一般化 先程の依存関係の分析はかなりシンプルなもののみ扱っていました。 例えば行列の乗算なんかを扱おうとすると一般化が必要です。 具体的には\n ループはネストする  正規誘導変数が複数になるのでそれらのベクトルを考えることになる 反復空間が多次元化するので正規誘導変数ベクトルのアフィン式 $\\mathbf{A}\\mathbf{i} + \\mathbf{b} \u0026gt; \\mathbf{0}$ を考えることになる 依存距離がベクトル化する（距離ベクトル、distance vector）  配列が多次元化する  配列の添字も多次元化するのでベクトルにすることになる 依存関係の式もベクトル化するので行列とのかけ算やらベクトルの大小関係やらを考えることになる   依存距離がベクトル化することで依存関係がちょっと複雑化します。 「一番外側のループでは依存関係はないけど2番目ではフロー依存があってあって一番内側ではなくなって…」のようになります。 そうすると外側はスレッド並列化できますし、内側はSIMD並列化できますが、真ん中のループはいじれないなんかの「部分的に変換可能な箇所がある」という結果が出たりします。 都合のいい依存関係でなかった場合はループの順番を入れ替えることで都合のいい依存関係にするような変換もあります。\nこれらは落ち着いて考えればどうにかなるものが多いのですが、ちょっと長くなってしまうので割愛します。参考文献を参照して下さい。\nまとめ データの依存関係について整理しました。 そしてフロー依存以外はSSA形式に変換することで取り除けることも確認しました。 しかし配列とループを扱うときはSSAだけでは対処できないのでループの正規化や正規誘導変数などを用いて依存関係を分析できることを紹介しました。 さらに今回紹介した簡単な例だけでなく一般化した手法が存在することも紹介しました。\n今回の記事は日本語で依存関係の分析を扱った資料ってないよなーと思って書き始めたのですが、よく調べたら中田先生のコンパイラの構成と最適化に載ってました。 ちゃんと読んでないことがバレますね。\n参考文献  M. Wolfe, High performance compilers for parallel computing 中田育男、コンパイラの構成と最適化 R. Allen, K. Kennedy, Optimizing compilers for modern architectures ","categories":["言語実装","Advent Calendar","Advent Calendar 2019","言語実装 Advent Calendar"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/advent-calendar","/categories/advent-calendar-2019","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-advent-calendar"],"date":"2019-12-15","title":"Dependency Analysis入門","url":"https://KeenS.github.io/blog/2019/12/15/dependency_analysisnyuumon/"},
  {"body":"# 話題のGUIツールキットOrbtkを読む ---------------------- [Rust LT #7 - connpass](https://rust.connpass.com/event/156436/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # Orbtkとは ----------- * [これ](https://github.com/redox-os/orbtk) * SNSで[話題沸騰中](https://twitter.com/vaaaaanquish/status/1203618077557981184) * [Redoxプロジェクト](https://redox-os.org)発 * RedoxのWindow System、[Orbital](https://gitlab.redox-os.org/redox-os/orbital)で使われている * マルチプラットフォーム対応 + Cライブラリに依存してないっぽい * 最近stableコンパイラで動くようになった === # デモ ------ * calcurator * canvas * canvas wasm * widgets * widgets wasm === # ある機能 --------- * widgetいくつか * レイアウトいくつか * ちゃんとマウスやキーボードも扱える * Webでも動く === # Orbtk解剖 ----------- * Application * Window + WindowShell * Widget + Layout + Behaviour + Cursor + ... === # Orbtkがマルチプラットフォームで動く仕組み ---------------------------------- * フルスクラッチしてるのでOS依存は少なめ + そもそも色々動かないRedox上で動いてるし * GUIに必要なものは意外と少ない + ウィンドウ/マウス/キーボードを扱う仕組み + グラフィック * あとはボタンなどは自分で描く === # 互換レイヤ ------------- * ネイティブ + ウィンドウ/マウス/キーボード: [minfb](https://github.com/emoon/rust_minifb) + グラフィック: [raqote](https://github.com/jrmuizel/raqote) * Web: + Canvasとイベントハンドラでどうにかなる === # アーキテクチャ === # 他のGUIツールキット --------------------- * 継承ベースで記述 + [GTK](https://developer.gnome.org/gtk3/stable/GtkCellAreaBox.html) + [Qt](https://doc.qt.io/qt-5/qtabwidget.html) + [Swing](https://docs.oracle.com/javase/jp/8/docs/api/javax/swing/JToolTip.html) * まあ、合理的 + だいたい似たような振舞 + だいたい似たようなフィールド * でもRustは？ === # ECS ------ * Entity Componet System + EntityとComponentとSystemからなる + \"[Composition over inheritance](https://en.wikipedia.org/wiki/Entity_component_system)\" * Entity: もの。通常中身はIDだけ * Component: Entityのアスペクト。 * System: とあるコンポーネントを持つEntityを動作させる === # Example (1) ---------- from [decs](https://gitlab.redox-os.org/redox-os/dces-rust) [view](https://gitlab.redox-os.org/redox-os/dces-rust/blob/develop/examples/minimal.rs) === # Example (2) ---------- from [decs](https://gitlab.redox-os.org/redox-os/dces-rust) [view](https://gitlab.redox-os.org/redox-os/dces-rust/blob/develop/examples/basic.rs) === # OrbtkとECS ------------ * アプリケーションはECSで動いてる + レンダリングループが[Systemの組み合わせ](https://github.com/redox-os/orbtk/blob/develop/crates/api/src/application/mod.rs#L165-L216) * [ウィジェットはEntity](https://github.com/redox-os/orbtk/blob/develop/crates/api/src/macros.rs#L321) + EntityStoreは木構造も管理するようになってる * ウィジェットの[フィールドはComponentとしても登録される](https://github.com/redox-os/orbtk/blob/develop/crates/api/src/macros.rs#L375-L395) * [docs.rs](https://docs.rs/orbtk) === # メインループ ------------- * Functional Reactive Programming 1. イベント入力（内部状態の変更） 2. 内部状態とテーマなどに基いてステートの更新（追従） 3. ステートに基いてレイアウト計算/描画 * Reactとかを参考にしたらしい * 「表示の書き換え」はしない + ステートの更新と描画が分離されてる === # CSS ----- * スタイルの指定にCSSが使える + セレクタ + プロパティ * もちろんHTMLにあるやつと中身は別 + タグ名→ウィジェット名 - 正確にはウィジェットの定義時に自分で指定 + プロパティ→コンポーネント === # Exampleを読む ----- * [calculator](https://github.com/redox-os/orbtk/blob/develop/examples/calculator.rs) === # Widgetを読む -------------- * [button](https://github.com/redox-os/orbtk/blob/develop/crates/widgets/src/button.rs) * [toggle_button](https://github.com/redox-os/orbtk/blob/develop/crates/widgets/src/toggle_button.rs) + buttonのコピペ * [switch](https://github.com/redox-os/orbtk/blob/develop/crates/widgets/src/switch.rs) + 動くUIの描画 * [scroll_indicator](https://github.com/redox-os/orbtk/blob/develop/crates/widgets/src/scroll_indicator.rs) === # まとめ --------- * Orbtkを紹介した * 案外GUIツールキットに必要なものは少ない * OrbtkはECSをベースに作られていた * OrbtkはFRPで動いていた * 今後に期待   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2019-12-10","title":"話題のGUIツールキットOrbtkを読む","url":"https://KeenS.github.io/slide/wadainoguitsu_rukittoorbtkwoyomu/"},
  {"body":"このエントリは型 Advent Calendar 2019 - Qiita 2日目に遡って投稿しているエントリです。 担当に遅刻した訳ではなくて空いてたので前から詰めて投稿しただけです。\nκeenです。世の中に型推論アルゴリズムは色々知られていると思いますが、それを一切無視して型推論を実装してみたので報告します。\n型推論の基本的理解 式に型変数を割り当てて、既に分かっている型から制約条件をつけてその制約の連立方程式を解けばいいです。\n例えば以下のようなSMLの式を考えましょう。\nval printLn = fn s =\u0026gt; (print (s ^ \u0026#34;\\n\u0026#34;)) まずはそれぞれの式に変数を割り当てます。\nprintLn: \u0026#39;a s: \u0026#39;b print: \u0026#39;c op^ :\u0026#39;d \u0026#34;\\n\u0026#34;: \u0026#39;e (s ^ \u0026#34;\\n\u0026#34;): \u0026#39;f print (s ^ \u0026#34;\\n\u0026#34;): \u0026#39;g 使われ方から以下の等式が出ます。\n\u0026#39;a = \u0026#39;b -\u0026gt; \u0026#39;g (* 一時的な変数 \u0026#39;h, \u0026#39;i を導入 *) \u0026#39;c = \u0026#39;h -\u0026gt; \u0026#39;i (* 一時的な変数 \u0026#39;j, \u0026#39;k, \u0026#39;l を導入 *) \u0026#39;d = \u0026#39;j * \u0026#39;k -\u0026gt; \u0026#39;l \u0026#39;h = \u0026#39;f \u0026#39;i = \u0026#39;g \u0026#39;j = \u0026#39;b \u0026#39;k = \u0026#39;e \u0026#39;l = \u0026#39;f これから変数の値を全て確定させる （= 全ての変数の制約について、 'x = type という形に変形する）のが目標です。 ひとまずそれぞれの変数の制約状況を見てみましょう。\n\u0026#39;a = \u0026#39;b -\u0026gt; \u0026#39;g \u0026#39;b = ??? \u0026#39;c = \u0026#39;h -\u0026gt; \u0026#39;i \u0026#39;d = \u0026#39;j * \u0026#39;k -\u0026gt; \u0026#39;l \u0026#39;e = ??? \u0026#39;f = ??? \u0026#39;g = ??? \u0026#39;h = \u0026#39;f \u0026#39;i = \u0026#39;g \u0026#39;j = \u0026#39;b \u0026#39;k = \u0026#39;e \u0026#39;l = \u0026#39;f ここで print: string -\u0026gt; unit 、 op^: string * string -\u0026gt; string 、 \u0026quot;\\n\u0026quot;: string という制約が事前に分かっていたとします。 この式を1つ1つあてはめていきます。\nまずは print: string -\u0026gt; unit より 'c = string -\u0026gt; unit 。 'c = 'h -\u0026gt; 'i でもあるので 構造的に比較 して、 'h = string 、 'i = unit も得られます。 さらに 'h = 'f や 'i = 'g などからいくつかの変数の値が 自動的に決まります\n\u0026#39;a = \u0026#39;b -\u0026gt; unit \u0026#39;b = ??? \u0026#39;c = string -\u0026gt; unit \u0026#39;d = \u0026#39;j * \u0026#39;k -\u0026gt; string \u0026#39;e = ??? \u0026#39;f = string \u0026#39;g = unit \u0026#39;h = string \u0026#39;i = unit \u0026#39;j = \u0026#39;b \u0026#39;k = \u0026#39;e \u0026#39;l = string 同様に op^: string * string -\u0026gt; string から 'j = string 、 'k = string 、 string = string などが得られます。 最後の string = string は恒真なのでスルーします。ここで string = unit などが出ると、矛盾としてエラーを出します。\n\u0026#39;a = string -\u0026gt; unit \u0026#39;b = string \u0026#39;c = string -\u0026gt; unit \u0026#39;d = string * string -\u0026gt; string \u0026#39;e = string \u0026#39;f = string \u0026#39;g = unit \u0026#39;h = string \u0026#39;i = unit \u0026#39;j = string \u0026#39;k = string \u0026#39;l = string これで既に変数が全部埋まりましたが、これが残りの制約と矛盾してないかの確認も必要なので推論を続けます。 \u0026quot;\\n\u0026quot;: string より 'e = string 。 これは矛盾しないですね。\nということで型推論が終わりました。特に、 printLn には string -\u0026gt; unit 型が付くことが分かりました。\nこの手計算を 手続型脳で プログラムにしていきたいと思います。\nゆにふぁい！ プログラムに移る前に、先程の例で、ちょっと非自明なことを2つしてました。 そこを掘り下げておきましょう。\n1つは構造的比較です。 string -\u0026gt; unit = 'h -\u0026gt; 'i という制約から 'h = string 、 'i = unit という式を導き出しました。 この導出はユニフィケーション（unification、単一化とも）と呼ばれ、いくつかのルールにより動作しています。\n string = string のように恒真式なら正常終了 string = unit のように矛盾していたら異常終了 'x = ty のように、変数と具体的な型のユニフィケーションなら 'x に string を代入する 'x = 'y のように、変数同士のユニフィケーションなら将来どちらかに代入された場合に他方も同じ値になるように、結び付ける 'a -\u0026gt; 'b = 'x -\u0026gt; 'y のように同じ種類の合成型同士のユニフィケーションなら、構成要素のそれぞれでユニフィケーションする。 この例なら 'a と 'x 、 'b と 'y でユニフィケーションする。 それ以外 ('a -\u0026gt; 'b = string のように合成型と基本型、あるいは 'a -\u0026gt; 'b = 'a * 'bのように違う合成型同士)の場合は異常終了  もう1つは、1つの制約式の追加でいくつかの変数の値が自動的に決まった点です。自動的というか推移的というか。 例えば 'a = 'b -\u0026gt; 'c という制約があったところに、 'a = string -\u0026gt; unit という制約を加えると、'b や 'c は直接は登場してないのに 'b = string 、 'c = unit という制約が得られます。 数式としては至極自然な挙動なのですが、実装は1つ1つ辿っていくとすると大変そうです。 しかしまあ、なんかポインタで1箇所指してれば実現できそうな挙動ではあります。\n方針 型同士をユニファイするコードと、制約を推移的に適用する部分を別々に実装しましょう。\n型同士を単一化するやつは簡単なパターンマッチで書けそうです。推移的に適用する部分をもう少し掘り下げましょう。\nユニフィケーションプール 制約を推移的に適用する部分はポインタにしとくと、どうにかなりそうという観測がありました。 もう少し物理的なイメージを膨らませましょう。\n表現 まずは型は全てポインタとします。ポイント先は型の実体の配列です。 例えば string 型はこうです。\nstring | v +---+--- | * | ... +-|-+--- | S ここで S は string 型を表わす内部表現とします。\nstring -\u0026gt; unit 型はこうです。\nstring -\u0026gt; unit | unit | string | | | ++ +----+ v v v +---+---+---+ | * | * | * | +-|-+-|-+-|-+ | | +----+ S U | F(string, unit) ここで U は unit 型を表わす内部表現、 F は関数型を表わす内部表現とします。 F の引数が S や U ではなく string や unit になっていることに注意して下さい。 F はポインタを引数にとっているので、ポイントの中身が変化したら自動で追従してくれます。\nゆにふぁい！（１） 変数と string をユニファイしてみましょう。ゆにふぁい！\nまずは 'a と string があります。変数 'x の内部表現は V(\u0026quot;x\u0026quot;) とします。\n\u0026#39;a string | | v v +---+---+ | * | * | +-|-+-|-+ | | | S V(\u0026#34;a\u0026#34;) ユニフィケーションすると変数の内部表現がポインタに変わります。\n\u0026#39;a string | | v v +---+---+ | * | * | +-|-+-|-+ | | | S string これで出てくるポインタをどんどん辿っていけば 'a から S に到達するので 'a が S になることが分かります。無事ユニフィケーションできているようです。\nゆにふぁい！（２） もう1例、 件の 'b -\u0026gt; 'c = 'a = string -\u0026gt; unit のユニフィケーションをしてみましょう。ゆにふぁい！\nまず、変数 \u0026lsquo;a, \u0026lsquo;b, \u0026lsquo;c があります。\n\u0026#39;a \u0026#39;b \u0026#39;c | | | v v v +---+---+---+ | * | * | * | +-|-+-|-+-|-+ | | | V(\u0026#34;a\u0026#34;)| V(\u0026#34;c\u0026#34;) V(\u0026#34;b\u0026#34;) 'a = 'b -\u0026gt; 'c です。\n\u0026#39;a \u0026#39;b \u0026#39;c | | | v v v +---+---+---+ | * | * | * | +-|-+-|-+-|-+ | | | | | V(\u0026#34;c\u0026#34;) | V(\u0026#34;b\u0026#34;) F(\u0026#39;b, \u0026#39;c) string -\u0026gt; unit があります。\nstring -\u0026gt; unit | unit | \u0026#39;a \u0026#39;b \u0026#39;c string | | | | | | ++ +----+ v v v v v v +---+---+---+---+---+---+ | * | * | * | * | * | * | +-|-+-|-+-|-+-|-+-|-+-|-+ | | | | | +----+ | | V(\u0026#34;c\u0026#34;)S U | | V(\u0026#34;b\u0026#34;) F(string, unit) F(\u0026#39;b, \u0026#39;c) 'a と string -\u0026gt; unit をユニファイします。\n'a を辿ると F('b, 'c) 、 string -\u0026gt; unit を辿ると F(string, unit) があります。 ユニフィケーションのルールに則って、それぞれの構成子どうしでユニフィケーションします。 つまり、 'b と string 、 'c と unit でユニフィケーションします。\n結果\nstring -\u0026gt; unit | unit | \u0026#39;a \u0026#39;b \u0026#39;c string | | | | | | ++ +----+ v v v v v v +---+---+---+---+---+---+ | * | * | * | * | * | * | +-|-+-|-+-|-+-|-+-|-+-|-+ | | | | | +----+ | | unit S U | | string F(string, unit) F(\u0026#39;b, \u0026#39;c) これで 'a を辿っていくと F('b, 'c) 、さらに 'b と 'c を辿ると string と unit に到達するので 'a = string -\u0026gt; unit になってますし、 'b = string 、 'c = unit もでてきました。\nこの表現でうまくいきそうです。\n簡約 このままでも問題ないのですが、少しだけ懸案事項があるので解消しておきましょう。\n'a = 'b = 'c = 'd = string のように、長い制約の連鎖があったとします。\n\u0026#39;a \u0026#39;b \u0026#39;c \u0026#39;d | | | | v v v v +---+---+---+---+ | * | * | * | * | +-|-+-|-+-|-+-|-+ | | | | \u0026#39;b \u0026#39;c \u0026#39;d S このときに 'a = string であることは間違いなく表現できているのですが、少し経由するポインタの数が多いですね。 何度も参照すると遅そうです。 もうちょっと定量的に言うと読み取りがセルの数の $O(n)$ に比例する表現はできるだけ避けたいです。 $O(\\log n)$ かそれ以下くらいに抑えたいものです。\nこれには簡単な解決策があります。中間のポインタを省いて値を保持している型に書き換えてしまえばいいのです。先程の例でいくとこうです。\n\u0026#39;a \u0026#39;b \u0026#39;c \u0026#39;d | | | | v v v v +---+---+---+---+ | * | * | * | * | +-|-+-|-+-|-+-|-+ | | | | \u0026#39;d \u0026#39;d \u0026#39;d S この状態なら $O(1)$ です。 あとは操作する度にポイタが変わるので、こういう簡約をいつ行うかという問題だけです。 参照を作る度に神経質にやってては遅そうです。読み取るときに参照を辿っていく道すがらにあるポインタを変換するのがよくある手法らしいです。 しかし今回はRustを使うので、読み取り操作で値を書き換えるのはできるだけ避けたいです。ということで私の実装はユニフィケーションを呼んだときについでに簡約することになってます。 私の実装とは違いますが道すがらのポインタをまとめて最短のポインタに変換する最適化を入れれば全体としては $O(1)$ に近いくらいの速度で動くんじゃないかなと思ってます。\n実装 それでは実装していきましょう。 というか、私が開発中のコンパイラでのコードを紹介していきましょう。 Rustで書いているStandard MLのコンパイラです。\n全体的に、式は 型なし → 型付け中 → 型あり の2段階の変化をします。\n最終的にはこういう型になります。 型変数は気の迷いで入ってますが今のところ多相をサポートしてないので使うと後の方で「多相はサポートしてないよ」のエラーが出ます。\npubenum Type{Variable(u64),Int,Real,Fun(Box\u0026lt;Type\u0026gt;,Box\u0026lt;Type\u0026gt;),} そして型付け中の型を表わすのがこのデータ型の定義です。型付け中には変数が必要なのでこっちの変数は気の迷いじゃないです。\nenum Typing{Variable(u64),Int,Real,Fun(NodeId,NodeId),} NodeId はあとで出てきますが、「型はポインタとします」といったときのポインタ相当です。 Typing は内部表現相当です。\nそれでは型のユニフィケーションと、制約式のユニフィケーションプールを見ていきましょう。\nまずはユニフィケーションプールから。\npubstruct UnificationPool\u0026lt;T\u0026gt;{pool: Vec\u0026lt;Node\u0026lt;T\u0026gt;\u0026gt;,}pubstruct NodeId(usize); セルの列はベクタで表現します。 セルに保持するデータは Node という型をあとで用意することにします。 NodeId は要するに先程の説明でいう「型はポインタとします」のポインタのことです。\nセルの中の値は実際に値を持っているか、それとも別のポインタを持っているかなのでした。 それを表現するコードがこちら。\nenum Node\u0026lt;T\u0026gt;{Value(T),Refer(NodeId),} この T には実際には型の内部表現、 Typing が入るのですがここでは抽象化しておきます。\nこの NodeId 、 UnificationPool 、 Node と先程の図による説明、対応がとれますかね？\n\u0026#39;a \u0026lt;- NodeId | v ~~~~~~~ +---+ | * | \u0026lt;- UnificationPool +-|-+ | ~~~~~~~ | V(\u0026#34;a\u0026#34;) \u0026lt;- Node さて、いくつかのユーティリティメソッドを生やしましょう。\nimpl\u0026lt;T\u0026gt;Node\u0026lt;T\u0026gt;{fn new(t: T)-\u0026gt; Self{Node::Value(t)}}impl\u0026lt;T\u0026gt;UnificationPool\u0026lt;T\u0026gt;{pubfn new()-\u0026gt; Self{Self{pool: vec![]}}fn register(\u0026amp;mutself,node: Node\u0026lt;T\u0026gt;)-\u0026gt; NodeId{self.pool.push(node);NodeId(self.pool.len()-1)}pubfn node_new(\u0026amp;mutself,t: T)-\u0026gt; NodeId{self.register(Node::new(t))}/// idが指しているノードを返す fn at(\u0026amp;self,node_id: NodeId)-\u0026gt; \u0026amp;Node\u0026lt;T\u0026gt;{\u0026amp;self.pool[node_id.0]}fn at_mut(\u0026amp;mutself,node_id: NodeId)-\u0026gt; \u0026amp;mutNode\u0026lt;T\u0026gt;{\u0026amp;mutself.pool[node_id.0]}/// idが指しているノードから辿っていって値を返す pubfn value_of(\u0026amp;self,mutid: NodeId)-\u0026gt; \u0026amp;T{loop{matchself.at(id){Node::Value(t)=\u0026gt;returnt,Node::Refer(new_id)=\u0026gt;id=*new_id,}}}} これでもうユニフィケーションまであと一息です。 簡約を定義します。\nimpl\u0026lt;T\u0026gt;UnificationPool\u0026lt;T\u0026gt;{fn value_id(\u0026amp;self,mutid: NodeId)-\u0026gt; NodeId{loop{matchself.at(id){Node::Value(_)=\u0026gt;returnid,Node::Refer(new_id)=\u0026gt;id=*new_id,}}}fn reduction(\u0026amp;mutself,mutstart: NodeId){// 一旦値のあるノードまで辿ってIDを取得して、 // もう一度舐めて道すがらの参照を変換していくサボり実装 letvalue_id=self.value_id(start);loop{matchself.at_mut(start){Node::Value(_)=\u0026gt;{return;}Node::Refer(refmutid)=\u0026gt;{start=*id;*id=value_id;}}}}} これでもう制約のユニフィケーションを定義できます。 今回型単体のユニフィケーションと制約式を跨いだ処理は分けて書く方針なので引数で型単体のユニフィケーション関数を受け取ります。\nimpl\u0026lt;T\u0026gt;Node\u0026lt;T\u0026gt;{// 値なら取り出し、別セルの参照なら捨てる fn take(\u0026amp;mutself)-\u0026gt; Option\u0026lt;T\u0026gt;{// 所有権の関係でダミー用の値と差し替えることでデータを取り出す // NodeIdはダミーになっているのでこのNodeは使えなくなっている letnode=std::mem::replace(self,Node::Refer(NodeId(std::usize::MAX)));matchnode{Node::Value(t)=\u0026gt;Some(t),Node::Refer(_)=\u0026gt;None,}}}impl\u0026lt;T\u0026gt;UnificationPool\u0026lt;T\u0026gt;{pubfn try_unify_with\u0026lt;E\u0026gt;(\u0026amp;mutself,id1: NodeId,id2: NodeId,// 型単体のユニフィケーションは外部からもらう try_unify: implFnOnce(\u0026amp;mutSelf,T,T)-\u0026gt; Result\u0026lt;T,E\u0026gt;,)-\u0026gt; Result\u0026lt;NodeId,E\u0026gt;{// それぞれの値を保持するノードのIDを取得して letlid=self.value_id(id1);letrid=self.value_id(id2);// それぞれの値を取り出す letl=self.at_mut(lid).take().unwrap();letr=self.at_mut(rid).take().unwrap();// 値をゆにふぁい！ // 結果が新しい値となる。 letnew=try_unify(self,l,r)?;// ユニファイした左の方のノードに値を持たせる。 // これは別にどっちでもいい。 *self.at_mut(lid)=Node::Value(new);*self.at_mut(rid)=Node::Refer(lid);// ついでに簡約 self.reduction(id1);self.reduction(id2);Ok(lid)}} これで制約式部分が完成です。 …といいたいところですがこのコード（try_unify_with）にはバグがあります。どこだか分かりますか？ 関数内の2-4行目です。左右の参照先が同じ場合は最初の self.at_mut(lid).take() で値が無になったあと、 続く self.at_mut(rid).take().unwrap() が既に無になったデータを取り出そうとしてパニックになってしまいます。 正しくは2-3行目の間にガードを入れた以下のコードです。\nimpl\u0026lt;T\u0026gt;UnificationPool\u0026lt;T\u0026gt;{pubfn try_unify_with\u0026lt;E\u0026gt;(\u0026amp;mutself,id1: NodeId,id2: NodeId,try_unify: implFnOnce(\u0026amp;mutSelf,T,T)-\u0026gt; Result\u0026lt;T,E\u0026gt;,)-\u0026gt; Result\u0026lt;NodeId,E\u0026gt;{letlid=self.value_id(id1);letrid=self.value_id(id2);// 左右が同じ場合はもうすることがない iflid==rid{returnOk(lid);}letl=self.at_mut(lid).take().unwrap();letr=self.at_mut(rid).take().unwrap();letnew=try_unify(self,l,r)?;*self.at_mut(lid)=Node::Value(new);*self.at_mut(rid)=Node::Refer(lid);self.reduction(id1);self.reduction(id2);Ok(lid)}} これで本当に制約式部分が完成です。\n最後に型単体のユニフィケーション。 型単体のユニフィケーションの途中で変数が出てくると推移的なユニフィケーションが走るので両者は相互再帰します。\nfn try_unify\u0026lt;\u0026#39;b,\u0026#39;r\u0026gt;(pool: \u0026amp;\u0026#39;b mutUnificationPool\u0026lt;Typing\u0026gt;,t1: Typing,t2: Typing,)-\u0026gt; Result\u0026lt;\u0026#39;r,Typing\u0026gt;{useTyping::*;match(t1,t2){// 両者が等価ならそれで終わり (t1,t2)ift1==t2=\u0026gt;Ok(t1),// 片方が変数ならもうに合わせる (Variable(_),ty)|(ty,Variable(_))=\u0026gt;Ok(ty),// 構造的型は構造が同じ場合は構成子それぞれでゆにふぁい！ (Fun(p1,b1),Fun(p2,b2))=\u0026gt;{letp=pool.try_unify_with(p1,p2,try_unify)?;letb=pool.try_unify_with(b1,b2,try_unify)?;Ok(Fun(p,b))}/// それ以外はエラー (t1,t2)=\u0026gt;Err(TypeError::MisMatch{expected: conv_ty(pool,t1),actual: conv_ty(pool,t2),}),}} はい、これでユニフィケーションの仕組みが整いました。 これらをベースに NodeId 同士でユニフィケーションする unify メソッドを定義するのは容易いでしょう。 また、型の内部表現(= Typing)を受け取って、裏側で一旦 UnificationPool に登録して NodeId を取得してから別の型とユニフィケーションする関数 give なども簡単に書けます。\nそこまで用意できたらあとは式にあわせて推論していくだけです。例えばApplyは以下のように書かれています。\nApp{ty,fun,arg}=\u0026gt;{self.infer_expr(fun)?;self.infer_expr(arg)?;self.give(fun.ty(),Typing::Fun(arg.ty(),*ty))?;Ok(())} 再帰的なアルゴリズムなので infer_expr を再帰呼び出してます。 制約式に順序はないので self.give と self.infer_expr の順序は（多分）どうでもいいですが、なんとなくこの順番で呼んでます。\nさて、最終的に型付けが終わったら Typing から Type に変換します。 これはプールから取得していくだけなので簡単ですね。\nfn resolve(pool: \u0026amp;UnificationPool\u0026lt;Typing\u0026gt;,id: NodeId)-\u0026gt; Type{conv_ty(pool,pool.value_of(id).clone())}fn conv_ty(pool: \u0026amp;UnificationPool\u0026lt;Typing\u0026gt;,ty: Typing)-\u0026gt; Type{useTyping::*;matchty{Variable(id)=\u0026gt;Type::Variable(id),Int=\u0026gt;Type::Int,Real=\u0026gt;Type::Real,Fun(param,body)=\u0026gt;Type::Fun(Box::new(resolve(pool,param)),Box::new(resolve(pool,body)),),}} ということで型推論のコードの紹介は断片的でしたが腕力で実装したユニフィケーションの実装でした。\nノート  既存のアルゴリズムを（うっすらとは知ってますが）一切ちゃんと調べずに書いたコードなので間違ってる可能性もあります。 このコードを書こうと思ったのは「型推論ってUnion-Find木（森）の挙動に似てない？」と思ったからです。 途中で簡約とか計算量の話がでてきたのはそのためです。  真面目に分析してませんが、「ユニフィケーションするときにノードの大きい方を根にする」「ノードから値を読み出すときに毎度簡約する」をちゃんとやればUnion-Find木と同じく $O(α(n))$ （ $α(n)$ はアッカーマン関数の逆関数）になるんじゃないかと思ってますが定かではないです。$α(n)$ は実用の範囲ではほぼ定数なので 「$O(1)$ に近いくらいの速度」と言った訳です。  実装してる途中で「これ、Prologの実装ってこんな感じじゃなかったっけ？」という気持になりました。まあ、当たり前っちゃあたりまえなんですけど。  おまけ: オーバーロードのサポート SMLには困った仕様としてオーバーロードがあります。 組み込み関数 + はオーバーロードされているので int にも real にも使えます。\n- 1 + 1; val it = 2 : int - 1.1 + 1.0; val it = 2.1 : real しかし型システム上はオーバーロードは存在しないので「+ は int にも real にも使えるけど、どっちかに決まらなかったら int 決め打ちになる」という仕様があります。\n(* x + y では型が決まらないのでintにフォールバックする *) - fun add x y = x + y; val add = fn : int -\u0026gt; int -\u0026gt; int (* なんなら単体でも型は決まらない *) - op+; val it = fn : int * int -\u0026gt; int しかし型推論は式全体全体を見てくれるので局所的に型が分からなくても全体で定まっていれば real にも推論してくれます。\n- fun add x y = x + y + 0.0; val add = fn : real -\u0026gt; real -\u0026gt; real この対応面倒ですね。Prolog風にバックトラックを実装しようかとも思いましたが + が連鎖すると多分死ぬのでやめました。\n面倒なのでやっつけで実装します。 こいつは Typing に数値演算向けのオーバーロードされた型を入れておきます。\nenum Typing{// ... OverloadedArith,} これのユニフィケーション規則はこう。\n(Int,OverloadedArith)|(OverloadedArith,Int)=\u0026gt;Ok(Int),(real,overloadedarith)|(overloadedarith,real)=\u0026gt;ok(real), もちろん、数値演算は OverloadedArith として推論されます。\nBinOp{op,ty,l,r}=\u0026gt;{if[\u0026#34;+\u0026#34;,\u0026#34;-\u0026#34;,\u0026#34;*\u0026#34;].contains(\u0026amp;op.0.as_str()){self.infer_expr(l)?;self.infer_expr(r)?;self.unify(l.ty(),r.ty())?;self.unify(l.ty(),overloaded_arith)?;self.unify(*ty,l.ty())?;Ok(())}// ... } 最終的に Typing から Type に変換するところで、オーバーロードが残ったままだったら Int にフォールバックするという処理を加えます。\nfn conv_ty(pool: \u0026amp;UnificationPool\u0026lt;Typing\u0026gt;,ty: Typing)-\u0026gt; Type{useTyping::*;matchty{// ... OverloadedArith=\u0026gt;Type::Int,}} 今のところこれで動いてるみたいです。\nちゃんとやるならオーバーロードには型の集合を定義して、ユニフィケーションのときは交差集合をとって…と実装することになるでしょうが、そもそも仕様がやっつけ感あるのでこのくらいで十分でしょう。\n","categories":["型","型推論","言語実装","Advent Calendar","Advent Calendar 2019"],"category_urls":["/categories/%e5%9e%8b","/categories/%e5%9e%8b%e6%8e%a8%e8%ab%96","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/advent-calendar","/categories/advent-calendar-2019"],"date":"2019-12-08","title":"手続き型脳で型推論を実装してみた","url":"https://KeenS.github.io/blog/2019/12/08/tetsuzukigatanoudekatasuironwojissoushitemita/"},
  {"body":"κeenです。このエントリはRust Advent Calendar 2019 - Qiita 8日目の記事です。 昔書いたRustのコードをもけもけ漁ってたら、しばらく前にRustでCPS変換しようとしてた下書きをたまたま発見しました。\n当時はコンパイラの制約で簡単には書けなかったのですが今見ると簡単に書けるようになってたのでRustも進歩してるね、という確認をしたいと思います。\nCPS変換とは CPS変換とは、プログラムを継続渡し形式(Continuation-Passing Style)に変換することです。 じゃあCPSとはというと、雑に言えば「ネストした関数の呼び出し禁止」の形式です。 …ちょっと雑すぎますね。 プログラムのコントロールフロー(if 式や 関数呼出)を陽に受け取った継続で記述する形式です。 この形式はよくコンパイラの内部表現なんかに使われます。 変数束縛の右側に if 式や関数呼び出しがこないという制約がつくので解析がやりやすくなるんですね。\n例えば以下のコードをCPS変換してみましょう。\nfn add(x: i32,y: i32)-\u0026gt; i32 {x+y}fn sub(x: i32,y: i32)-\u0026gt; i32 {x-y}// ↓ これ sub(add(1,2),5) 関数呼出がネストしてますね。これを書き換えたいです。 しかし変数束縛の右側に関数呼び出しを置くのは禁止なのでちょっと困ります。\n関数内の末尾で関数を呼出すのは可能なので、「後でやりたい事を関数で渡して関数内で呼んでもらう」という戦略でいきましょう。\nそのためには add を「最後に呼ぶ関数」を受け取るように変換する必要があります。\nfn add_cps\u0026lt;R\u0026gt;(x: i32,y: i32,c: implFnOnce(i32)-\u0026gt; R)-\u0026gt; R{c(x+y)}fn sub(x: i32,y: i32)-\u0026gt; i32 {x-y}add_cps(1,2,|ret|sub(ret,5)) add だけ変換してると今度は add して sub したくなったときにまた不都合なので sub の方も変換しておきましょう。 sub の引数が1つ浮つくので id を渡してそのまま結果を返すようにしておきましょう。\nfn add_cps\u0026lt;R\u0026gt;(x: i32,y: i32,c: implFnOnce(i32)-\u0026gt; R)-\u0026gt; R{c(x+y)}fn sub_cps\u0026lt;R\u0026gt;(x: i32,y: i32,c: implFnOnce(i32)-\u0026gt; R)-\u0026gt; R{c(x-y)}fn id\u0026lt;T\u0026gt;(t: T)-\u0026gt; T{t}add_cps(1,2,|ret|sub_cps(ret,5,id)) こういうのがCPS変換です（雑）。 制御フロー構文の多いRustで「RustにおけるCPS変換」をバシっと定義するのは難しいのでふわっとしたまま進んでいきます。\nもう少し例を見ましょう if 式の場合です。\nfn max_1(x: i32,y: i32)-\u0026gt; i32 {letmax=ifx\u0026lt;y{y}else{x};add(max,1)} 変数束縛の右側にif を置くのも禁止なのでこれも変換します。\nこれも if から返ったあとの処理を一旦関数にまとめて、then/else節でそれを呼んであげます。\nfn max_1_cps\u0026lt;R\u0026gt;(x: i32,y: i32,c: implFnOnce(i32)-\u0026gt; R)-\u0026gt; R{letc=|max|{add_cps(max,1,c)};ifx\u0026lt;y{c(y)}else{c(x)}} 変数束縛の関数「呼び出し」は禁止されてますが、関数（クロージャ）の「定義」は可能なのでこれで問題ありません。\nCPS変換は自然に体が求めるものなので、いつでもできるようにしておきたいですね。\n問題のコード 「関数呼び出しや if の後の処理（＝継続）を一旦クロージャにして引数に渡す」という戦略でCPS変換はできるのですが、Rustでは別の問題が起きます。\nフィボナッチ数列を求める関数をCPSで書いてみましょう。\nfn add_cps\u0026lt;R\u0026gt;(x: u64,y: u64,c: implFnOnce(u64)-\u0026gt; R)-\u0026gt; R{c(x+y)}fn sub_cps\u0026lt;R\u0026gt;(x: u64,y: u64,c: implFnOnce(u64)-\u0026gt; R)-\u0026gt; R{c(x-y)}fn fib_cps\u0026lt;R\u0026gt;(n: u64,c: implFnOnce(u64)-\u0026gt; R)-\u0026gt; R{ifn\u0026lt;2{c(1)}else{// fib(n - 1) + fib(n - 2)の変換 // -\u0026gt; add(fib(sub(n, 1)), fib(sub(n, 2))) // -\u0026gt; let n1 = sub(n, 1); // let f1 = fib(n1); // let n2 = sub(n, 2); // let f2 = fib(n2); // add(f1, f2) // -\u0026gt; sub_cps(n,1,move|n1|{fib_cps(n1,move|f1|{sub_cps(n,2,move|n2|fib_cps(n2,move|f2|add_cps(f1,f2,c)))})})}} これでロジックは正しいんですが、呼び出そうとするとコンパイルエラーです。\nfib_cps(10,id)error: reached the type-length limit while instantiating `sub_cps::\u0026lt;u64, [closure@cps_fib....64 {id::\u0026lt;u64\u0026gt;}]]]]]]]]]]]]]]]]]\u0026gt;` --\u0026gt; cps_fib.rs:23:1 | 23 | / fn sub_cps\u0026lt;R\u0026gt;(x: u64, y: u64, c: impl FnOnce(u64) -\u0026gt; R) -\u0026gt; R { 24 | | c(x - y) 25 | | } | |_^ | = note: consider adding a `#![type_length_limit=\u0026#34;1310713\u0026#34;]` attribute to your crate Rustのジェネリクス（impl FnOnce）はC++のテンプレートと同じく実装をコピーしていることを思い出して下さい。 さらに、クロージャも1回書く毎に別々の型が生成されることを思い出して下さい。 その上で fib_cps の末尾を見てみましょう。fib_cps は引数の型に応じて本体をコピーしますが、その中でクロージャを fib_cps に渡しているので新たな本体のコピーを作らないといけません。 するとまたクロージャのコピーが増えて…新しい生まれてしまい…と、いくつコピーが必要か計算しようとすると無限に再帰してしまうので型チェックに失敗するのです。\n別の解釈をすると、CPS変換はスタックを使うコードをヒープを使うコードに変換します。 Rustはジェネリクスで受け取ったデータ型の大きさを静的に決定しようとします。 ところが fib で使うスタックサイズ（呼び出しのネストの深さ）は静的には決まらないので当然 fib_cps が受け取る c のサイズも決定できずにコンパイルエラーになっています。\nこれはジェネリクスをやめれば解決するはずです。 Box\u0026lt;dyn FnOnce\u0026gt; を使ってみましょう。\nfn add_cps\u0026lt;R\u0026gt;(x: u64,y: u64,c: Box\u0026lt;dynFnOnce(u64)-\u0026gt; R\u0026gt;)-\u0026gt; R{c(x+y)}fn sub_cps\u0026lt;R\u0026gt;(x: u64,y: u64,c: Box\u0026lt;dynFnOnce(u64)-\u0026gt; R\u0026gt;)-\u0026gt; R{c(x-y)}fn fib_cps\u0026lt;R: \u0026#39;static\u0026gt;(n: u64,c: Box\u0026lt;dynFnOnce(u64)-\u0026gt; R\u0026gt;)-\u0026gt; R{ifn\u0026lt;2{c(1)}else{sub_cps(n,1,Box::new(move|n1|{fib_cps(n1,Box::new(move|f1|{sub_cps(n,2,Box::new(move|n2|fib_cps(n2,Box::new(move|f2|add_cps(f1,f2,c)))),)}),)}),)}} Box::new が増えた分冗長になりましたがまあ、前と変わらないコードです。 Box::new の呼び出しがネストしてる点については目を瞑って下さい。\nこれを実行してみましょう。\nfn main(){letret=fib_cps(10,Box::new(id));println!(\u0026#34;fib(10) = {}\u0026#34;,ret);}fib(10) = 89 無事実行できました。めでたしめでたし。\nRust 1.35.0 …と、今のRust (1.39)であれば問題ないんですが、つい最近まではこのコードはコンパイルできませんでした。 試しに 1.35.0 より前のコンパイラでこのコードをコンパイルしてみましょう。\n$ rustc +1.34.2 cps_fib.rs error[E0161]: cannot move a value of type (dyn std::ops::FnOnce(u64) -\u0026gt; R + \u0026#39;static): the size of (dyn std::ops::FnOnce(u64) -\u0026gt; R + \u0026#39;static) cannot be statically determined --\u0026gt; cps_fib.rs:74:5 | 74 | c(x + y) | ^ error: aborting due to previous error For more information about this error, try `rustc --explain E0161`. エラーが出てしまいました。当時のRustでは Box\u0026lt;dyn FnOnce\u0026gt; を呼び出せなかったのです。 FnOnce は捕捉した環境をby moveで渡す + FnOnceはクロージャなのでサイズが静的に決まらない + Rustはサイズが静的に決まらない値を関数の引数に渡せないというコンボが決まった結果です。 詳しくは以下のブログを読んで下さい。こちらでもfibのCPS変換が出てきていますね。人類の自然な欲求なのでまあ、よくあることでしょう。\nFnBoxについて - 簡潔なQ\nというのが1.35.0より前の話。 Rust 1.35.0からこの問題が解決されました。1.35.0のリリースノートを見てみるとこう書かれてます。\n FnOnce, FnMut, and the Fn traits are now implemented for Box\u0026lt;FnOnce\u0026gt;, Box\u0026lt;FnMut\u0026gt;, and Box\u0026lt;Fn\u0026gt; respectively.\n こうやってRustでもCPS変換が簡単に書けるようになりました。\nRust 1.35.0より前 CPS変換は体が自然に求めるものなので 1.35.0より前でも人類はどうにかしてRustでCPS変換をしていました。 折角なのでそのときのテクニックを紹介します。\nまず、 Box にされたトレイトが呼び出せないならはじめから Box を受け取るようなコードを書けばいいだけです。 こういうトレイトを用意しましょう。\ntraitFnBox\u0026lt;A\u0026gt;{type Out;fn call(self: Box\u0026lt;Self\u0026gt;,A)-\u0026gt; Self::Out;} これはNightlyにあるFnBoxと同じものですが、4行のためにNightlyを使う意味は薄いのでコピペしてStableコンパイラで使います。\nあとはこれを使ってクロージャを作ります。 クロージャはただの Fn* トレイトを実装した構造体なのでした。 それくらいならマクロで自動生成できます。\nmacro_rules!cls{// 捕捉する環境、引数、返り型、本体を受け取る ([$($env:ident: $env_ty: ty),*]|$($param:ident: $param_ty: ty),*|-\u0026gt; $out_ty: ty{$body:expr})=\u0026gt;{{// 捕捉する環境は構造体にエンコード struct Cls{$($env: $env_ty),*}// あとはそれにFnトレイトを実装 implFnBox\u0026lt;($($param_ty,)*)\u0026gt;forCls{type Out=$out_ty;fn call(self: Box\u0026lt;Self\u0026gt;,$($param),*: ($($param_ty,)*))-\u0026gt; Self::Out{$(let$env=self.$env;)*;$body}}// ここからFnBoxを作る letbx:Box\u0026lt;dynFnBox\u0026lt;($($param_ty,)*),Out=$out_ty\u0026gt;\u0026gt;=Box::new(Cls{$($env),*});bx}}} さて、 fib_cps を定義しましょう。\nfn add_cps\u0026lt;R\u0026gt;(x: u64,y: u64,c: Box\u0026lt;dynFnBox\u0026lt;(u64,),Out=R\u0026gt;\u0026gt;)-\u0026gt; R{c.call((x+y,))}fn sub_cps\u0026lt;R\u0026gt;(x: u64,y: u64,c: Box\u0026lt;dynFnBox\u0026lt;(u64,),Out=R\u0026gt;\u0026gt;)-\u0026gt; R{c.call((x-y,))}fn fib_cps\u0026lt;R: \u0026#39;static\u0026gt;(n: u64,c: Box\u0026lt;dynFnBox\u0026lt;(u64,),Out=R\u0026gt;\u0026gt;)-\u0026gt; R{ifn\u0026lt;2{c.call((1,))}else{sub_cps(n,1,// ここで関数のジェネリックパラメータを参照してエラー cls!([c:Box\u0026lt;dynFnBox\u0026lt;u64,Out=R\u0026gt;\u0026gt;]|n1: u64|-\u0026gt; R{c.call(n1)}),)}} 残念ながら、この戦略は失敗します。 FnBox を実装するときに fib の帰り型の R を参照する必要が出てきますが、これは許可されていません。\nさて、失敗してしまったので戦略を練り直します。 もっと視座を高くして継続の気持になってみましょう。 第一級市民になって引数を渡り歩く生活。道すがら環境を捕捉して旅をしつつ呼び出されていきます。 旅の終着点は？最後は初期継続を得て値となります。\nそう、分かりましたね。つまるところ、「既に受け取ってしまった継続」で使われている型パラメータを参照してしまうのが問題です。 受け取った時点で型が固定されているのに、ジェネリクスなので参照できないというジレンマが生じている訳です。\nということは「継続を後で受け取る」ようにすれば、型パラメータはそのときまで固定されないので問題は解決します。\n「継続を後で受け取る」トレイトを定義してあげましょう。\n// 今までの traitFnBox\u0026lt;A\u0026gt;{type Out;fn call(self: Box\u0026lt;Self\u0026gt;,arg: A)-\u0026gt; Self::Out;}// 継続変換された値を表わすトレイト。 型パラメータは値と継続の返り値の型 traitCont\u0026lt;A,R\u0026gt;{fn cont(self: Box\u0026lt;Self\u0026gt;,c: Box\u0026lt;dynFnBox\u0026lt;A,Out=R\u0026gt;\u0026gt;)-\u0026gt; R;} Cont はメソッド cont で起動できます。 このときに初期継続を渡してあげます。 Cont に型パラメータ R を保持しているので関数のジェネリクスにある浮いたパラメータを参照しなくてよくなります。\n定数のCPS変換は Cont 流にやるとこうなります。\nstruct Const\u0026lt;C\u0026gt;(C);impl\u0026lt;C,R\u0026gt;Cont\u0026lt;C,R\u0026gt;forConst\u0026lt;C\u0026gt;{fn cont(self: Box\u0026lt;Self\u0026gt;,c: Box\u0026lt;dynFnBox\u0026lt;C,Out=R\u0026gt;\u0026gt;)-\u0026gt; R{c.call(self.0)}} 難しいですか？まあ、でも使ってみれば簡単です。\nfn add_cps\u0026lt;R\u0026gt;(x: u64,y: u64)-\u0026gt; Box\u0026lt;dynCont\u0026lt;u64,R\u0026gt;\u0026gt;{Box::new(Const(x+y))}fn sub_cps\u0026lt;R\u0026gt;(x: u64,y: u64)-\u0026gt; Box\u0026lt;dynCont\u0026lt;u64,R\u0026gt;\u0026gt;{Box::new(Const(x-y))} さて、 fib はネストした継続が出てくるので少しばかり面倒です。\nまずは cls マクロを改造しておきます。型パラメータを取れるようになりました。\nmacro_rules!cls{(\u0026lt;$($ty: ident),*\u0026gt;[$($env:ident: $env_ty: ty),*]|$($param:ident: $param_ty: ty),*|-\u0026gt; $out_ty: ty{$body:expr})=\u0026gt;{{usestd::marker::PhantomData;struct Cls\u0026lt;$($ty),*\u0026gt;{$($env: $env_ty,)*_p: PhantomData\u0026lt;($($ty),*)\u0026gt;,}impl\u0026lt;$($ty: \u0026#39;static),*\u0026gt;FnBox\u0026lt;($($param_ty),*)\u0026gt;forCls\u0026lt;$($ty),*\u0026gt;{type Out=$out_ty;fn call(self: Box\u0026lt;Self\u0026gt;,$($param),*: ($($param_ty),*))-\u0026gt; Self::Out{lets=*self;letCls{_p,$($env),*}=s;$body}}letbx:Box\u0026lt;dynFnBox\u0026lt;($($param_ty),*),Out=$out_ty\u0026gt;\u0026gt;=Box::new(Cls{$($env,)*_p: PhantomData});bx}}} その上で、便利な道具として and_then を定義しておきましょう。\nfn and_then\u0026lt;A: \u0026#39;static,B: \u0026#39;static,R: \u0026#39;static\u0026gt;(c: Box\u0026lt;dynCont\u0026lt;A,R\u0026gt;\u0026gt;,f: Box\u0026lt;dynFnBox\u0026lt;A,Out=Box\u0026lt;dynCont\u0026lt;B,R\u0026gt;\u0026gt;\u0026gt;\u0026gt;,)-\u0026gt; Box\u0026lt;dynCont\u0026lt;B,R\u0026gt;\u0026gt;{Box::new(AndThen{c: c,f: f,_phantom: PhantomData,})}usestd::marker::PhantomData;struct AndThen\u0026lt;A,B,R\u0026gt;{c: Box\u0026lt;dynCont\u0026lt;A,R\u0026gt;\u0026gt;,f: Box\u0026lt;dynFnBox\u0026lt;A,Out=Box\u0026lt;dynCont\u0026lt;B,R\u0026gt;\u0026gt;\u0026gt;\u0026gt;,_phantom: PhantomData\u0026lt;B\u0026gt;,}impl\u0026lt;A: \u0026#39;static,B: \u0026#39;static,R: \u0026#39;static\u0026gt;Cont\u0026lt;B,R\u0026gt;forAndThen\u0026lt;A,B,R\u0026gt;{fn cont(self: Box\u0026lt;Self\u0026gt;,cont: Box\u0026lt;dynFnBox\u0026lt;B,Out=R\u0026gt;\u0026gt;)-\u0026gt; R{lets=*self;letAndThen{c,f,..}=s;c.cont(cls!(\u0026lt;A,B,R\u0026gt;[f: Box\u0026lt;dynFnBox\u0026lt;A,Out=Box\u0026lt;dynCont\u0026lt;B,R\u0026gt;\u0026gt;\u0026gt;\u0026gt;,cont: Box\u0026lt;dynFnBox\u0026lt;B,Out=R\u0026gt;\u0026gt;]|arg: A|-\u0026gt; R{(f).call(arg).cont(cont)}))}} 見た目はごちゃっとしてますけど「よくある」 and_then のコードです。\nいよいよラスト、and_then と cls を駆使して fib のCPS変換をします。\nfn fib_cps\u0026lt;R: \u0026#39;static\u0026gt;(n: u64)-\u0026gt; Box\u0026lt;dynCont\u0026lt;u64,R\u0026gt;\u0026gt;{ifn\u0026lt;2{Box::new(Const(1))}else{and_then(and_then(sub_cps(n,1),cls!([]\u0026lt;R\u0026gt;|n1: u64|-\u0026gt; Box\u0026lt;dynCont\u0026lt;u64,R\u0026gt;\u0026gt;{fib_cps(n1)}),),cls!([n: u64]\u0026lt;R\u0026gt;|f1: u64|-\u0026gt; Box\u0026lt;dynCont\u0026lt;u64,R\u0026gt;\u0026gt;{and_then(and_then(sub_cps(n,2),cls!([]\u0026lt;R\u0026gt;|n2: u64|-\u0026gt; Box\u0026lt;dynCont\u0026lt;u64,R\u0026gt;\u0026gt;{fib_cps(n2)})),cls!([f1: u64]\u0026lt;R\u0026gt;|f2: u64|-\u0026gt; Box\u0026lt;dynCont\u0026lt;u64,R\u0026gt;\u0026gt;{add_cps(f1,f2)}))}),)}} やった！できた！ あとは適当に初期継続 Id を用意してあげれば呼び出せます。\nfn main(){struct Id;impl\u0026lt;T\u0026gt;FnBox\u0026lt;T\u0026gt;forId{type Out=T;fn call(self: Box\u0026lt;Self\u0026gt;,t: T)-\u0026gt; Self::Out{t}}letret=fib_cps::\u0026lt;u64\u0026gt;(10).cont(Box::new(Id));println!(\u0026#34;fib(10) = {}\u0026#34;,ret);} Rust 1.34.2でコンパイルしてみましょう。\n$ rustc +1.34.2 cps_fib.rs $ ./cps_fib fib(10) = 89 できました！！いつの時代でも欲求は満たされることが分かりました。\nまとめ Rust 1.35.0より前の世界では苦労して得ていたCPS形式のプログラムも1.35.0からは簡単に得られるようになりました。 時代は進むし世の中便利になっていくのです。\n","categories":["Rust","Advent Calendar","Rust Advent Calendar","Advent Calendar 2019","継続","CPS"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/rust-advent-calendar","/categories/advent-calendar-2019","/categories/%e7%b6%99%e7%b6%9a","/categories/cps"],"date":"2019-12-07","title":"RustでCPS変換が簡単になったよという話","url":"https://KeenS.github.io/blog/2019/12/07/rustdecpshenkangakantanninattayotoiuhanashi/"},
  {"body":"κeenです。このエントリはRustその3 Advent Calendar 2019 - Qiitaの7日目の記事です。空いてたので飛び入り参加しました。\n軽い小ネタです。Dieselで select する時にいちいちカラム名書くの面倒だよねって話です。\n長い前置きは端折って、以下のようなコードを考えます。\n[dependencies] chrono = \u0026#34;0.4.10\u0026#34; diesel = { version = \u0026#34;1.4.3\u0026#34;, features = [\u0026#34;chrono\u0026#34;] }#[macro_use]externcratediesel;usechrono::prelude::*;usediesel::prelude::*;usediesel::result::Error;usediesel::table;table!{users{id-\u0026gt; Integer,name-\u0026gt; Text,email-\u0026gt; Text,created_at-\u0026gt; Timestamp,}} ひとまず created_at を使わないとして、 User を定義しておきましょう。\n#[derive(Queryable, Identifiable)]struct User{id: i32,name: String,email: String,} 即座にこれを find するコードが書けるはずです。\n// 具体的なDBに依存するのが面倒なのでジェネリクスで書いたが、 // 実用上は `PgConnection` など具体的なDBのコネクションを指定した方が楽 fn find_user\u0026lt;Cn,B\u0026gt;(cn: \u0026amp;Cn,id: i32)-\u0026gt; Result\u0026lt;Option\u0026lt;User\u0026gt;,Error\u0026gt;whereCn: Connection\u0026lt;Backend=B\u0026gt;,B: diesel::backend::Backend\u0026lt;RawValue=[u8]\u0026gt;,{useself::users::dsl::*;users.find(id).select((self::users::id,name,email)).get_result(cn).optional()} あるいは、検索するコードも書けますね\nusediesel::sql_types::Timestamp;usediesel::types::ToSql;fn load_recent_users\u0026lt;Cn,B\u0026gt;(cn: \u0026amp;Cn,threshold: DateTime\u0026lt;Utc\u0026gt;)-\u0026gt; Result\u0026lt;Vec\u0026lt;User\u0026gt;,Error\u0026gt;whereCn: Connection\u0026lt;Backend=B\u0026gt;,B: diesel::backend::Backend\u0026lt;RawValue=[u8]\u0026gt;,NaiveDateTime: ToSql\u0026lt;Timestamp,B\u0026gt;,{useself::users::dsl::*;users.filter(created_at.ge(threshold.naive_utc())).select((id,name,email)).load(cn)} さて、ここで問題になるのがdieselの良いところでも悪いところでもあるselectするカラムについてです。 Dieselはモデルがテーブルとは直接関係を持たないORMなので users テーブルから User を取得するには毎度カラムを指定する必要があります。 このおかげでRustのコードとSQLのインタフェースを綺麗に分けることができますし、例えば deleted_users のように別のテーブルからも User を取得できます。 代わりにロードするカラムは手で指定しないといけません。規模が小さいうちはそれでもいいのですが規模が大きくなるとフィールドを追加するたびにあちこち変更して周らないといけなくなり、とても手に負えなくなります。\nそこで部分的にですがRustのデータ型とデータベースのテーブルを関連付けてカラム名の取得を省略できる方法を紹介します。\nまあ、話は単純でこういうトレイトを用意してあげて、\ntraitSelectable{type Columns;fn columns()-\u0026gt; Self::Columns;} こういう実装を与えるだけです。\nimplSelectableforUser{type Columns=(users::id,users::name,users::email);fn columns()-\u0026gt; Self::Columns{(users::id,users::name,users::email)}} そうすればクエリの select 部分にカラム名を書かなくてよくなります。\nfn find_user\u0026lt;Cn,B\u0026gt;(cn: \u0026amp;Cn,id: i32)-\u0026gt; Result\u0026lt;Option\u0026lt;User\u0026gt;,Error\u0026gt;whereCn: Connection\u0026lt;Backend=B\u0026gt;,B: diesel::backend::Backend\u0026lt;RawValue=[u8]\u0026gt;,{useself::users::dsl::*;users.find(id)// カラム名を直接書かなくてよくなった .select(User::columns()).get_result(cn).optional()} この手法のいいところは合成可能な点です。\n例えば users と関係のある crates というテーブルを考えてみましょう。\ntable!{crates{id-\u0026gt; Integer,name-\u0026gt; Text,version-\u0026gt; Text,author_id-\u0026gt; Integer,created_at-\u0026gt; Timestamp,}}joinable!(crates-\u0026gt; users(author_id));allow_tables_to_appear_in_same_query!(users,crates); これに対応するデータ型をこう定義したとします。\n#[derive(Queryable, Identifiable)]struct Crate{id: i32,name: String,version: String,// Users構造体を保持 author: User,} author_id ではなく author と User 構造体そのまま保持してることに注意して下さい。\nこれには以下のように Selectable を実装できます。\nimplSelectableforCrate{type Columns=(crates::id,crates::name,crates::version,// UserのColumnsをそのまま使える \u0026lt;UserasSelectable\u0026gt;::Columns,);fn columns()-\u0026gt; Self::Columns{// Userのcolumnsをそのまま使える (crates::id,crates::name,crates::version,User::columns())}} これはこのままクエリに使えます。\nfn load_create_of\u0026lt;Cn,B\u0026gt;(cn: \u0026amp;Cn,author_id: i32)-\u0026gt; Result\u0026lt;Vec\u0026lt;Crate\u0026gt;,Error\u0026gt;whereCn: Connection\u0026lt;Backend=B\u0026gt;,B: diesel::backend::Backend\u0026lt;RawValue=[u8]\u0026gt;,{useself::crates::dsl;useself::users::dsl::users;dsl::crates.filter(dsl::author_id.eq(author_id)).inner_join(users).select(Crate::columns()).load(cn)} 便利ですね。\n注意点としてはテーブルとカラム名を指定してるので例えば User を deleted_users から取得するときは手でカラム名を書く必要があります。 Selectable にパラメータを持たせて SelectableFrom\u0026lt;users\u0026gt; とか SelectableFrom\u0026lt;deleted_users\u0026gt; とか書けるようにする手もありますが手間の割にあんまり便利にならなそうですね。実用の観点ではバランスを考えて導入しましょう。\nということでdisel小ネタでした。是非お試しあれ。\n","categories":["Rust","Advent Calendar","Rust Advent Calendar","Advent Calendar 2019","Diesel","小ネタ"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/rust-advent-calendar","/categories/advent-calendar-2019","/categories/diesel","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2019-12-07","title":"dieselでselectするカラムを1箇所にまとめる","url":"https://KeenS.github.io/blog/2019/12/07/dieseldeselectsurukaramuwo1tsunimatomeru/"},
  {"body":"κeenです。このエントリはRust Advent Calendar 2019 - Qiita 6日目のエントリです。 空いてたので飛び入りました。 飛び入りなので軽い小ネタ。便利クレート itertoolsの紹介です。\nitertools は標準ライブラリの Iterator を拡張し、今まで痒いところに手が届かなかった部分をサクっと埋めてくれるライブラリです。\n使い方 cargo add itertools などしてあとは use itertools::Itertools; するだけです。これだけでイテレータが便利になります。\n何ができるの Itertools 「そう、それ！」と言いたくなるようなメソッドが生えてきます。 例えばイテレータの要素をまとめて処理する chunks と、セパレータで文字列を結合する join を組み合わせるとこういうコードが書けます。\nforchunkin\u0026amp;(0..100).chunks(20){println!(\u0026#34;{}\u0026#34;,chunk.map(|i|format!(\u0026#34;{:2}\u0026#34;,i)).join(\u0026#34;, \u0026#34;))} この実行結果はこうです。\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99 chunks は実用では大きいデータを一括で処理すると負荷が高いから100個づつくらいやりたい、なんかのケースで有用そうですね。\n因みに上記の例はもうちょっと便利メソッドを使って書き直せます。 for 式相当処理をする for_each メソッド（これは標準ライブラリの Iterator にある）と、気持ち悪いですが「フォーマット文に渡されると各要素にそのフォーマット指定子を適用し、さらに引数の文字列で結合する」処理をする format メソッドです。\n(0..100).chunks(20).into_iter().for_each(|chunk|println!(\u0026#34;{:2}\u0026#34;,chunk.format(\u0026#34;, \u0026#34;))) 例えば Vec\u0026lt;u8\u0026gt; を表示するのにも便利なんじゃないでしょうか。\nletbytes=\u0026#34;あいうえお\u0026#34;.as_bytes();println!(\u0026#34;{:2x}\u0026#34;,bytes.iter().format(\u0026#34;, \u0026#34;))e3, 81, 82, e3, 81, 84, e3, 81, 86, e3, 81, 88, e3, 81, 8a あとは sorted はイテレータをソートしてくれます。ソートしようとして「えっ、一旦 Vec にしないとダメなの」と思ったことのある方も多いんじゃないでしょうか。itertoolsならイテレータのままソートできます。\nprintln!(\u0026#34;{:?}\u0026#34;,\u0026#34;bdacfe\u0026#34;.chars().sorted().collect_vec()) 因みにここで使っている collect_vec() は collect::\u0026lt;Vec\u0026lt;_\u0026gt;() 相当です。\n結果はこう。\n[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] この他にも cartesian_product だとか tuple_windows だとか merge だとか group_by だとか便利そうなメソッドが一杯生えてます。\nマクロ 2つ生えてます。 izip と iproduct 。 zip と cartesian_product の可変長引数版ですね。\n関数 いくつか関数も生えてます。だいたいはイテレータのメソッドを関数にして map なんかに渡しやすくしたものですが、中には面白い関数もあります。\n例えば repeat_n 。同じデータを繰り返してくれます。\nfn mask(s: String)-\u0026gt; String {format!(\u0026#34;{}{}\u0026#34;,itertools::repeat_n(\u0026#39;x\u0026#39;,32).format(\u0026#34;\u0026#34;),\u0026amp;s[32..])} cons_tuples なんかも面白いですね。 zip の繰り返しで積ったタプルをフラットにしてくれます。\nitertools::cons_tuples((0..10i32).zip(10..20i32).zip(20..30i32)).for_each(|t|println!(\u0026#34;{:?}\u0026#34;,t)) 本来なら zip を2回やってるので要素は ((i32, i32), i32) ですがこれを (i32, i32, i32) にしてくれます。\n(0, 10, 20) (1, 11, 21) (2, 12, 22) (3, 13, 23) (4, 14, 24) (5, 15, 25) (6, 16, 26) (7, 17, 27) (8, 18, 28) (9, 19, 29) 練習問題 言語処理100本ノックをitertoolsを使って問いてみましょう。 面白い問題をいくつか選んでやっていきます。\n02. 「パトカー」＋「タクシー」＝「パタトクカシーー」  「パトカー」＋「タクシー」の文字を先頭から交互に連結して文字列「パタトクカシーー」を得よ．\n まさしくな interleave というメソッドがあります。\nfn p02()-\u0026gt; String {lets1=\u0026#34;パトカー\u0026#34;;lets2=\u0026#34;タクシー\u0026#34;;s1.chars().interleave(s2.chars()).collect()} 05. n-gram  与えられたシーケンス（文字列やリストなど）からn-gramを作る関数を作成せよ．この関数を用い，\u0026rdquo;I am an NLPer\u0026rdquo;という文から単語bi-gram，文字bi-gramを得よ．\n bi-gramなら tuple_windows で簡単に作れます。\nfn bi_gram\u0026lt;I\u0026gt;(input: I)-\u0026gt; implIterator\u0026lt;Item=[I::Item;2]\u0026gt;whereI: Iterator,I::Item: Clone,{input.tuple_windows::\u0026lt;(_,_)\u0026gt;().map(|(t1,t2)|[t1,t2])}fn p05()-\u0026gt; (Vec\u0026lt;[char;2]\u0026gt;,Vec\u0026lt;[\u0026amp;\u0026#39;staticstr;2]\u0026gt;){lets=\u0026#34;I am an NLPer\u0026#34;;letchar_bigram=bi_gram(s.chars()).collect_vec();letword_bigram=bi_gram(s.split_whitespace()).collect_vec();(char_bigram,word_bigram)} tuple_windows は4つ組までにしか対応してないので 5-gram以上はできません。 tuple_windows のタプルじゃない版欲しい…。\nという訳でいくつか練習問題を解いてみました。\nまとめ itertoolsという便利なライブラリを紹介しました。 log とかと同じで使うかは分からなくてもプロジェクトを作ったら取り敢えず入れておくくらいの勢いで使っていけばいいと思います。\n","categories":["Rust","Advent Calendar","Advent Calendar 2019","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2019","/categories/rust-advent-calendar"],"date":"2019-12-06","title":"itertoolsの紹介","url":"https://KeenS.github.io/blog/2019/12/06/itertoolsnoshoukai/"},
  {"body":"このエントリはRustその3 Advent Calendar 20193日目に飛び入り参加しているエントリです。 Rustの型パラメータ指定の構文、通称ターボフィッシュ(turbofish)について。\nRustでジェネリクス関数は以下のように関数名に続いて \u0026lt;パラメータ名\u0026gt; で指定しますよね？\nfn generics\u0026lt;T\u0026gt;(t: T){// ... } これを呼び出すときはどうやって指定しましょう？直感的にはこうですよね？\ngenerics\u0026lt;u8\u0026gt;(0) しかしこれは構文エラーです。\nerror: chained comparison operators require parentheses --\u0026gt; turbofish.rs:6:13 | 6 | generics\u0026lt;u8\u0026gt;(0); | ^^^^^ | = help: use `::\u0026lt;...\u0026gt;` instead of `\u0026lt;...\u0026gt;` if you meant to specify type arguments = help: or use `(...)` if you meant to specify fn arguments error: aborting due to previous error エラーメッセージにも書いてある通り、型を指定するときは名前と型パラメータの間に :: を置く必要があります。\ngenerics::\u0026lt;u8\u0026gt;(0) この ::\u0026lt;\u0026gt; という構文は魚がロケットエンジンで右に進んでいるように見えるからか、turbofishと呼ばれています。\n::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; ::\u0026lt;\u0026gt; よくターボフィッシュのお世話になる関数の1つは str::parse でしょうか。以下のように使います。\nusestd::net::Ipv4Addr;// 型推論が効かない環境でもターボフィシュを使えば `Ipv4Addr` を指定できる letaddr=\u0026#34;127.0.0.1\u0026#34;.parse::\u0026lt;Ipv4Addr\u0026gt;(); ところでなんで :: が必要なの？というと、どうも :: がないと他の構文と区別がつかないケースがあるからです。\nfn generics2\u0026lt;T1,T2\u0026gt;(_: (T1,T2)){// ... }lettuple=(\u0026#39;a\u0026#39;,0);// 関数呼び出し + 型パラメータの指定のつもりのコード (generics2\u0026lt;char,i32\u0026gt;(tuple))letgenerics2=\u0026#39;b\u0026#39;;letchar=\u0026#39;a\u0026#39;;leti32=0;lettuple=1;// 2つの比較演算のタプルのつもりのコード (generics2\u0026lt;char,i32\u0026gt;(tuple)) 現行のRustでは後者の方が既に合法なコードとして存在するので簡単には入れられません。\nさて、この文法さえ覚えれば基本はオッケーなんですが、どこに書くのか意外と迷いやすいです。\n例えば以下のように str の値を String に変換したいとします。\nlets: String =\u0026#34;str\u0026#34;.into(); 今回のケースは単純なので変数の方に型アノテーションを書くこともできますが、メソッドチェーンの途中だと型アノテーションを書ける場所がなく、ターボフィッシュを使いたいこともあるでしょう。そういうケースでのお話しです。\nparse の類推から、 into にターボフィッシュをあてがえばコンパイルできそうに思えます。\nlets=\u0026#34;str\u0026#34;.into::\u0026lt;String\u0026gt;(); しかし残念ながら、このように unexpected type argument が出てしまいます。\nerror[E0107]: wrong number of type arguments: expected 0, found 1 --\u0026gt; turbofish.rs:6:26 | 6 | let s = \u0026#34;str\u0026#34;.into::\u0026lt;String\u0026gt;(); | ^^^^^^ unexpected type argument error: aborting due to previous error For more information about this error, try `rustc --explain E0107`. これは Into の定義を見ると納得がいきます。\npubtraitInto\u0026lt;T\u0026gt;{fn into(self)-\u0026gt; T;} よくみると into メソッドではなくて Into のトレイトの方に型パラメータがついていますね。 なので Into の方にターボフィッシュが必要です。\nlets=Into::\u0026lt;String\u0026gt;::into(\u0026#34;str\u0026#34;); まあ、このケースでは From があるので From を使った方が手っ取り早いでしょう。\nlets=String::from(\u0026#34;str\u0026#34;); 今回のは From があるという細かい話はありますが、基本は型パラメータのあるところにターボフィッシュが必要と覚えて下さい。\n例えば Vec の new はこう。\nletv=Vec::\u0026lt;u32\u0026gt;::new(); これでターボフィッシュをマスターできましたか？\n実はまだよく分からないケースがあります。 enum の型パラメータはどうやらバリアントにも付けられるようです。\nOption は以下のように定義されています。\npubenum Option\u0026lt;T\u0026gt;{None,Some(T),} 順当にいけば None の型パラメータは以下のように指定するのが正しいですね。\nleto=Option::\u0026lt;String\u0026gt;::None; 実際、これは正しくコンパイできます。\nしかし、以下のような書き方も許容されています。\nleto=None::\u0026lt;String\u0026gt;; どうも、昔のRustは Option::None という書き方ができず、ターボフィッシュを置く場所がなかったのでバリアントに型パラメータが書けるようになったようです。 複雑ですね。\nということで飛び入りの小ネタでした。\n","categories":["Rust","Advent Calendar","Advent Calendar 2019","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2019","/categories/rust-advent-calendar"],"date":"2019-12-03","title":"Rustのturbofishを理解する","url":"https://KeenS.github.io/blog/2019/12/03/rustnoturbofishworikaisuru/"},
  {"body":"This is κeen. Here is my thoughts on Rust 2020. Though I\u0026rsquo;m a Japanese speaker, and I don\u0026rsquo;t think the Rust Developers accept only English-written blog posts, I write this post for non-Japanese speakers.\nHere I describe my personal experience with Rust. I have written Rust for 3 years in daily office work to develop a Web service (actcast.io), which consists of about 60k lines of Rust codes. I feel Rust is enough expressive to write web applications (especially with async/await). We published a 600 pages of book about Rust in May, which fully supports Rust 2018. I guess this is the world\u0026rsquo;s first book written about Rust 2018!. And I use Rust for most of my hobby programming, such as writing compilers. My compiler targets WebAssembly and runtime is also written in Rust. Thanks to neat WASM support of Rust, I managed to write entire system in Rust. Rust is great!\nHere is my wish list for Rust 2020. In a nut shell:\n I\u0026rsquo;m happy with Rust Error handling is not awesome RLS should utilize multicore I want some ergonomic features of the language  First of all, I thank all of the Rust Developers for finishing the work of async/await. As I wrote, we have successfully migrated to futures 0.3 and async/await, which greatly simplified our application. To say more, we have smoothly migrated Rust 2018 edition thanks to the great tool cargo fix.\nI\u0026rsquo;m happy with Rust in most of cases. However, there are some pain points of Rust.\nThere are some variants of error handling. Though I prefer to use std::error::Error because it\u0026rsquo;s standard, some libraries require failure, and some other libraries require other error handling crates. It\u0026rsquo;s okay because diversity is good. However, when you combine some of these crates, you\u0026rsquo;ll have a nightmare. You need to learn all of these error handling. You need to write compatibility codes for the variants of errors. During that, some of information (like backtrace) drops when converting one error to another style of error. I guess fix the error trait resolves some of these problems. BTW, I haven\u0026rsquo;t heard about try block for a while. I wish it will be done in Rust 2018 edition.\nOne more pain point is RLS. In the view of features, it works fine. It helps me to knowning the type and documentation of items, it suggests completion for me. However, it doesn\u0026rsquo;t work with multicore. I have 16-core machine for buildng Rust programs (because Rust needs machine power to build), but RLS doesn\u0026rsquo;t utilize the available resources. RLS blocks me from writing codes fluently in the scale of our project. It extremely slows down when I edit comments and string literals but I haven\u0026rsquo;t mutch investigated whethe the cause is RLS or Emacs\u0026rsquo;s lsp-mode. I guess parallelizing RLS means pararllelizing rustc. In that sence, my wish is parallelizing rustc.\nTo mention language specifications, I feel some of features lack affinity.\nWhile Rust supports fluent writing of method chains (and .await), some API requires applying 1-arity functions (like Ok, Box::new), which forces the user to back to the head of expression and enclose the entire expression with parens. It\u0026rsquo;s cumbersome. I want some neat syntax sugar of such application, say, pipe operator (|\u0026gt;) like in F#. To say more, I\u0026rsquo;d like to write long_expression |\u0026gt; return; rather writing return long_expression;, but as it complicates the specification I don\u0026rsquo;t wish so far.\nI\u0026rsquo;d like for traits and related features to be more flexible. In our project, which is relatively large, we split the application into some crates. Data definitions and codes using them are decoupled. In such situations, you cannot implement external traits to data types. For instance, we have a generic data type which shouldn\u0026rsquo;t depend on anything and a code that use it with diesel. Diesel provides derive macros, but you cannot apply the derive macro to the data type because it\u0026rsquo;s definition isn\u0026rsquo;t here. To use derive macro, we need to rewrite the data definition and write convertion codes between this definition and the other definiiton. It\u0026rsquo;s cumbersome.\nThe last thing is match ing against Box. When you write a compiler you often need to write Box\u0026lt;Expr\u0026gt;s, like enum Expr { Add { l: Box\u0026lt;Expr\u0026gt;, r: Box\u0026lt;Expr\u0026gt;}}. With Expr enveloped in Box, you cannot write nested patterns to match against it. To address this problem, there are some options.\n Treat Box specially. Automatically deref it  You may want to apply that rule to Rc, Arc, etc.  Introduce view patterns or pattern guards like in Haskell (GHC).  I don\u0026rsquo;t care which of those adopted, or even other methods are wellcome. I merely want the problem fixed.\nLastly I thank the Rust Developer and all the community members again.\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2019-11-30","title":"Rust 2020","url":"https://KeenS.github.io/blog/2019/11/30/rust_2020/"},
  {"body":"# 安全なシステムプログラミング言語Rustへの招待 ---------------------- [IIJ Labセミナー](https://iijlab-seminars.connpass.com/event/152079/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア + 2年半くらい仕事でRustを書いている * Lisp, ML, Rust, Shell Scriptあたりを書きます * [実践Rust入門](https://gihyo.jp/book/2019/978-4-297-10559-4)の共著者 === # Rustって言語があるよ --------------------- * システムプログラミング言語 * 2015年に1.0.0がリリース + リリース前に破壊的変更しまくったので1.0以降はかなり安定してる + 0.x時代はもちろんのこと、1.0-alphaのあとに1.0-alpha2が出たりもした * 6週間毎にコンパイラのリリースで、今は1.39.0 * C++03, C++11 みたいなノリでRust 2015とRust 2018の2つの仕様がある + コンパイラはずっと両方サポート === # 事例 ------ * [firecracker](https://github.com/firecracker-microvm/firecracker): AWS Lambdaのセキュアコンテナ * [Magick Pocket](https://www.wired.com/2016/03/epic-story-dropboxs-exodus-amazon-cloud-empire/): DropBoxのストレージマネージャ。 * [Servo](https://servo.org/): Mozillaの新ブラウザエンジンの実験プロジェクト。一部の成果がFirefoxに反映されている。 * [Redox](https://redox-os.org/): OS * [TiKV](https://github.com/tikv/tikv): KVS === # システムプログラミング言語っぽさ ------------------------------- * ランタイムレス + でもメモリは自動管理 * Cと相互に連携できる + C FFIだけでなくCからRustも呼べる * それっぽいプロジェクトもいくつか + [libpnet](https://github.com/libpnet/libpnet): 生パケット扱うライブラリ + [awesome-embedded-rust](https://github.com/rust-embedded/awesome-embedded-rust): 組み込み系のキュレーション + [tokio](https://tokio.rs/): 非同期イベントループのライブラリ === # メモリ配置 ------------ この構造体のサイズは？ [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=fd32ac47011842c8f12c0fc1425131c1) ```rust use std::mem; struct Hoge { c1: u8, i2: u32, c2: u8, } println!(\"{}\", mem::size_of::()); ``` === # メモリ配置 ------------ デフォルトでサイズが最小になるように詰める ```console +----+----+----+---------+ | c1 | c1 |\\\\\\\\| i2 | +----+----+----+---------+ ``` === # メモリ配置 ------------ この構造体のサイズは？ [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=d4290de0065ba2951a486676fafe2ecf) ```rust use std::mem; #[repr(C)] struct Hoge { c1: u8, i2: u32, c2: u8, } println!(\"{}\", mem::size_of::()); ``` === # メモリ配置 ------------ `repr(C)` をつけると見慣れたメモリ配置になる ```console +----+----+---------+----+----+ | c1 |\\\\\\\\| i2 | c1 |\\\\\\\\| +----+----+---------+----+----+ ``` === 構造体をそのままchar*にキャストしてsocketに突っ込むことで通信ができるという幻想こそがC支持者の心の拠り所なわけで、その間違った考えにのっとるなら48bit整数とかが欲しくなるのはそこまで不自然な話ではないと思う。\n\u0026mdash; 7594591200220899443 (@shyouhei) September 19, 2019 === # 普通のRust ------------ * 便利なイテレータ * 素数最初の25個を列挙 [run](https://is.gd/Hh0H42) [asm](https://godbolt.org/z/JC-DRx) ```rust fn main() { (2..) .filter(|\u0026n| (2..n).all(|i| n % i != 0)) .take(25) .for_each(|n| println!(\"{}\", n)) } ``` === # 普通のRust ------------ * トレイト便利 + C++のconcept相当らしい * ポリモーフィズムは大抵トレイト経由で実現 + 静的ディスパッチ + 演算子のオーバーローオ + 動的ディスパッチ * メタプログラミングでいくつかのトレイトは自動で実装できる === # 普通のRust ------------ トレイト [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2015\u0026gist=e9ba56aa24da63eed8eb3787f2b10ac5) ```rust // `derive(トレイト)` アトリビュートをつけると // 自動でトレイトを実装してくれる #[derive(Debug, Clone, PartialEq, Eq)] struct Cartesian(f64, f64); #[derive(Debug, Clone, PartialEq, Eq)] struct Polar(f64, 664); // トレイトを定義 trait ToCartesian { fn to_cartesian(self) - Cartesian; } それぞれの型に実装 impl ToCartesian for Cartesian { fn to_cartesian(self) - Cartesian { self } } impl ToCartesian for Polar { fn to_cartesian(self) - Cartesian { Cartesian(self.0 * self.1.cos(), self.0 * self.sin) } } // ToCartesianを実装している型のみ渡せる fn print_point(p: P) { let p = p.to_cartesian(); println!(\"({}, {})\", p.0, p.1); } fn main() { let p = Polar(1.0, 0); // Debugをderiveしたので印字できる println!(\"{:?}\", p); // PartialEqをderiveしたので比較できる p == p; // ToCartesianを実装したので `print_point` に渡せる print_point(p) } ``` === # 普通のRust ------------ * 割と型検査で事前に不正なコードを弾く * テンプレートと違ってジェネリクス定義時点で型が合ってないとコンパイルできない + 以下のコードはこれを書いた時点でコンパイルエラー ``` fn print_point(p: P) { let p = p.to_cartesian(); println!(\"({}, {})\", p.0, p.1); } ``` === # 普通のRust ------------ * 便利な `enum` (代数的データ型) * [`Ordering`](https://doc.rust-lang.org/std/cmp/enum.Ordering.html) も便利 * `impl` ブロックでデータ型にメソッドを生やせる [run](https://is.gd/Cpgdpo) ```rust enum Color { Red, Black, } enum Tree { Leaf, Node { color: Color, l: Box, v: T, r: Box, }, } use std::cmp::Ordering; implTree { fn is_member(\u0026self, t: \u0026T) - bool { use Tree::*; match self { Leaf = false, Node { l, v, r, .. } = match t.cmp(v) { Ordering::Less = l.is_member(t), Ordering::Equal = true, Ordering::Greater = r.is_member(t), }, } } } ``` === # 普通のRust ------------ * [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html) 型とパターンマッチはエラーハンドリングに便利 + Rustに例外はない。 * 「例外が上がる」という概念ではなくてデータ型という第一級の値で表現することで扱いやすさが向上 + メソッドを生やしたりできる ``` use std::io::{self, Write}; use std::fs::File; fn write_string(filename: \u0026str, content: \u0026str) - io::Result { let mut file = match File::create(filename) { Ok(file) = file, Err(e) = { eprintln!(\"an error occured when opening file: {}\", e); return } }; match file.write_all(\u0026content.as_bytes())? { Ok(file) = (), Err(e) = { eprintln!(\"an error occured when writing to file: {}\", e); return } } Ok(()) } ``` === # 普通のRust ------------ * 早期リターンする記法もある * `Result` (または`Option`) 型に `?` 演算子でエラーなら関数から返る ``` use std::io::{self, Write}; use std::fs::File; fn write_string(filename: \u0026str, content: \u0026str) - io::Result { let mut file = File::create(filename)?; file.write_all(\u0026content.as_bytes())?; Ok(()) } ``` === # 普通のRust ------------ * UNIX APIの便利ラッパー * パターンマッチに便利な仕組み ```rust use nix::unistd::{fork, ForkResult}; fn main() { match fork() { Ok(ForkResult::Parent { child, .. }) = { println!(\"Continuing execution in parent process, new child has pid: {}\", child); } Ok(ForkResult::Child) = println!(\"I'm a new child process\"), Err(_) = println!(\"Fork failed\"), } } ``` === # 普通のRust ------------ * Cargo + 便利なビルドツール/パッケージマネージャ + プラグインの仕組みもある + 今回は `cargo-edit` を使ってる (`cargo install cargo-edit` で入る) ```console $ cargo new fork-example $ cargo add nix $ cd fork_example $ edit src/main.rs $ cargo run ``` === # Why Rust (over C/C++)? ------------------------ * 安全 + セキュリティ的な嬉しさ + 開発面での余計なデバッグの不要 * 生産性が高い + 便利な機能があることと低レイヤが扱えることは両立する + 例えば最近入った `async` / `await` はOSがなくても動く * Cargo(ビルドツール) + crates.io(パッケージレジストリ)が便利 * 活発なコミュニティ === # 速度と機能の話 -------------- * [Why is Rust slightly slower than C?](https://github.com/ixy-languages/ixy-languages/blob/master/Rust-vs-C-performance.md) + ネットワークドライバを各言語で実装してみる実験 * RustはCより少しだけ遅い。でもIPCはRustの方が断然いい。 * → CはCPUを使ってる気になってるけど使いきれてないのでは？ * → CPUも進化してるんだから言語も進化しましょう === # Rustの安全性について ----------------------------- 安全 ≒ 未定義動作を踏まない * NULL Pointerはない。 + 令和にもなってセグフォのデバッグはしたくない * use after freeができない * 配列の範囲外アクセスが検査される * データ競合(data race)が起きない + ≒ 多数のスレッドから1つのデータに同時にアクセスできない * 競合状態(race condition) は防げないので注意 + デッドロックとか === # 範囲外アクセス ---------------- * (他の安全性とは違って)範囲外アクセスは実行時に検査される + 範囲外アクセスを静的に弾くのはかなり難しいことが知られている ```rust let v = vec![1, 2, 3]; // コンパイルは通るけど実行時にパニック v[3] ```  ```console thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 3', /rustc/4560ea788cb760f0a34127156c78e2552949f734/src/libcore/slice/mod.rs:2717:10 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace. ```  === # 範囲外アクセス ---------------- * ただし固定長配列に定数でアクセスする場合はコンパイルエラーにしてくれる ```rust let v = [1, 2, 3]; // コンパイルエラー v[3] ```  ```console error: index out of bounds: the len is 3 but the index is 3 --\u0026gt; src/main.rs:5:1 | 5 | v[3]; | ^^^^ | = note: `#[deny(const_err)]` on by default ```  === # 所有権 -------- * 値にはライフタイムがある ```rust { let data = Data::new(); // `data` のライフタイムはこのスコープ } // ← ここで `data` がfreeされる // ここでは `data` にアクセスできない ``` === # 所有権 -------- * 所有権は移動する ```rust let data = Data::new(); // ここで `data` の所有権が `tmp` に移る let tmp = data; // 以降 `data` にアクセスするとコンパイルエラー // tmpが死ぬと `data` はfreeされる ``` === # 所有権 -------- * 関数に渡しても移動する ```rust fn take_data(_: Data) {} let data = Data::new(); take_data(data); // 以降 `data` にアクセスするとコンパイルエラー // take_data(data); ``` === # 所有権 -------- * 関数に渡しても移動する * …えっ === # 借用 -------- * データを一時的に「貸す」こともできる * `\u0026` で参照を取ると貸すことになる ```rust fn borrow_data(_: \u0026Data) {} let data = Data::new(); // 貸す borrow_data(\u0026data); // 返してもらったらまた使える borrow_data(\u0026data); ``` === # 借用 -------- * `\u0026` で参照を取ると貸すことになる * 参照はポインタの意味もあるけど普段はあんまりポインタとしては意識してない + カジュアルに構造体の値渡しをする + 「借用するかどうか」で使い分ける + 所有するポインタ (`Box`) もあるけどたまにしか使わない === # 借用とライフタイム ------------------- * 借りたデータを元のデータより長く生かせない + 要するにdangling pointer禁止 * 長く生かそうとするとコンパイルエラー ```rust // このコードはコンパイルエラー fn new_data() - \u0026Data { let data = Data::new(); \u0026data // data はここで死ぬので関数から返せない } ``` === # 借用と変更 ------------------- * 以下の関数の返り値は？ ```C int func(int *a, int *b) { *a = 0; *b = 1; return *a; } ``` === # 借用と変更 ------------------- * 以下の関数の返り値は？ + `\u0026mut` は可変ら参照を表わす + Cでいう普通の `\u0026` ```rust fn func(a: \u0026mut i32, b: \u0026mut i32) - i32 { *a = 0; *b = 1; *a } ``` === # 借用と変更 ------------------- * Rustでは1つの変数の可変な参照を複数作れない + 以下はコンパイルエラー ``` let mut a = 1; func(\u0026mut a, \u0026mut a) ``` + Rustの `memcpy` は簡単になる * RustはPointer Aliasの制約が強い + → 挙動が分かりやすい + → コンパイラが最適化しやすい * 不変な借用があるときに可変な参照も作れない + 要するにコンパイル時 Read-Write Lock === # 借用と変更 ------------------- * 不変な借用があるときに可変な参照も作れない [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2015\u0026gist=2d2d3e2fbb67247147ef1cbde75fcbbc) ```rust let v = vec![1, 2, 3]; for e in \u0026v { v.push(*e); } ```  ```console error[E0596]: cannot borrow `v` as mutable, as it is not declared as mutable --\u0026gt; src/main.rs:4:9 | 2 | let v = vec![1, 2, 3]; | - help: consider changing this to be mutable: `mut v` 3 | for e in \u0026v { 4 | v.push(*e); | ^ cannot borrow as mutable ```  === # Nullableな値 --------------- * 全てのポインタがNullableなのは酷いけどNullがないのも不便な気がする + findして結果がなかったらNullを返したい * ポインタとは関係なくNullableであることを表わすデータ型を用意して解決 + `i32` とかもnullableにできる + メソッドを生やせる * [Option](https://doc.rust-lang.org/std/option/enum.Option.html) * `Option` は最適化でただのポインタになる ```rust pub enum Option { None, Some(T), } ``` === # 所有権の例外 -------------- * `i32` とか小さい型をいちいち貸し借りしたくない - 湯水のごとくじゃぶじゃぶ使いたい * そういう型は無制限に使える仕組みがある * [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html)トレイトを実装した型は勝手にコピーしてくれる + よくRustで所有権を試そうとしてる人がはまりがち ```rust fn take_i32(_: i32) {} let a = 1; take_i32(a); // 何度でも呼べる take_i32(a); take_i32(a); ``` === # 所有権とか --------------------------- * 正直スライドだけでは伝えきれない * 理解しようとすると[公式ドキュメント](https://doc.rust-jp.rs/book/second-edition/ch04-00-understanding-ownership.html)を読むのがよい + あとは手を動かさないと分からない。 * 雑にまとめると + データには所有者がいる + ポインタは実体があると保証できる範囲でしか作れない - NULL poinerやdangling pointerは存在しない + Writeは排他 === # 所有権とか --------------------------- * 結構アプリケーションの設計に関わってくる + 雑な設計だとすぐに破綻する + それゆえ難しいといわれがち * 所有者を意識すると綺麗になりがち + 長寿のデータ型に持たせる - `App` とか `Config` とか + データ構造は所有者になりがち - `HashMap` とか + 処理のフローを考えると余計なコピーを省ける - HTTPの場合は `Request` の生存期間で十分だったり === # 所有権小話1 ------------- * `HashMap` はデータを所有するので `get` / `get_mut` だとデータを借りることしかできない + 取り出したいのが不変の参照か可変の参照かでメソッドが分かれてるのが普通 * データを取り出したいときは `remove` を使う [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2018\u0026gist=c633e1e2a6935a12238795f68c22b156) ```rust use std::collections::HashMap; let mut map = vec![ (1, \"one\".to_string()), (2, \"two\".into()), (3, \"three\".into()), ] .into_iter() .collect::(); match map.remove(\u00263) { None = println!(\"no data\"), Some(data) = println!(\"got data: {}\", data), } ``` === # 所有権小話2 ------------- * Rustにリソースを開放するAPIはない + `File` の `open` はあるけど `close` はない + `Lock` の `lock` はあるけど `free` はない * RAIIで管理されるのでデータの `free` のときに一緒に開放される [run](https://is.gd/KKm9Vb) ```run use std::io::{self, Write}; use std::fs::File; fn write_string(filename: \u0026str, content: \u0026str) - io::Result { // Fileをwriteモードでopen let mut file = File::create(filename)?; file.write_all(\u0026content.as_bytes())?; Ok(()) // fileがスコープを抜けるときに自動でcloseされる } ``` === # Rustの進歩 ------------ * Rustは問題がある「かもしれない」コードを弾く + 不思議な力で安全になる訳ではなくて、養成ギプス的にユーザに安全なコードを書かせる * 安全にはなるが窮屈 + 極端な話、全てのコードを弾けば実行時エラーは出ない * Rustの進歩でコンパイルが通る範囲もちょっとづつ広がっている === # Rustの進歩 ------------ * 昔は以下のコードがコンパイルできなかった - 昔 = 1年前 * 最近は制御フローまで見て問題なければコンパイルを通す [run](https://is.gd/ALWpec) ```rust use std::collections::HashMap; fn insert_or_update(map: \u0026mut HashMap, key: i32, value: i32) { // get_mutで可変の参照 match map.get_mut(\u0026key) { Some(v) = *v = value, None = { // その参照が生きている間に更新 map.insert(key, value); }, } } ``` === # 所有権をopt out ---------------- * 所有権は便利だけどそれだと書けないデータ構造が発生する + グラフとか * そういう場合に実行時に所有権/ミュータビリティ検査をするAPIがある + [`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) (参照カウント) … 複数人でデータを共有できる [doc](https://doc.rust-jp.rs/book/second-edition/ch15-04-rc.html) + [`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) … 実行時に借用検査をする [doc](https://doc.rust-jp.rs/book/second-edition/ch15-05-interior-mutability.html) === # 所有権をopt out ---------------- * Rustだけど「何でもあり」にできてしまう例 [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2015\u0026gist=f7b7e132be264a3de565669565c4e454) ```rust use std::rc::Rc; use std::cell::RefCell; let data = Rc::new(RefCell::new(1)); let data2 = data.clone(); // data2を変更。 data2はイミュータブルだが // `RefCell` なので変更できる *data2.borrow_mut() = 2; // `Rc` なのでdata2の変更がdataにも反映される assert_eq!(*data.borrow(), 2); ``` === # 並列 ------- * Rustはスレッドセーフでないプログラムをマルチスレッドで使うとエラーにする * 例えば `Rc` はスレッドアンセーフ(裏でcountの変更があるため) [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2015\u0026gist=9198d0f301cc24e503992ed9b127ef59) ```rust use std::rc::Rc; use std::thread; use std::cell::RefCell; let data = Rc::new(RefCell::new(1)); let data2 = data.clone(); let handle = thread::spawn(move || { *data2.borrow_mut() = 2; }); handle.join().unwrap(); assert_eq!(*data.borrow(), 2); ```  ```console --\u0026gt; src/main.rs:9:14 | 9 | let handle = thread::spawn(|| { | ^^^^^^^^^^^^^ `std::rc::Rc` cannot be shared between threads safely | = help: the trait `std::marker::Sync` is not implemented for `std::rc::Rc` = note: required because of the requirements on the impl of `std::marker::Send` for `\u0026std::rc::Rc` = note: required because it appears within the type `[closure@src/main.rs:9:28: 14:2 data2:\u0026std::rc::Rc]` ```  === # 並列 ------- * スレッドセーフなAPIにしたり `Mutex` を使ったりするとコンパイルが通る + `Arc` = Atomic Reference Count + `Mutex` = mutual exclution、要はロック [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2015\u0026gist=13757c7015d10f5954a4978baa8d17e5) ```rust use std::sync::{Arc, Mutex}; use std::thread; let data = Arc::new(Mutex::new(1)); let data2 = data.clone(); let handle = thread::spawn(move || { *data2.lock().unwrap() = 2; }); handle.join().unwrap(); assert_eq!(*data.lock().unwrap(), 2); ``` === # 並列の安全性の舞台裏 ---------------------- * トレイトで制御している * `thread::spawn` に渡せるのは `Send` トレイトを実装した型のみ。 * `Rc` や `RefCell` は `Send` トレイトを実装していない * → `Rc` や `RefCell` を渡そうとするとコンパイルエラーになる * ドキュメントを読まなくてもスレッドセーフか分かるの素敵 === # 安全性を捨てるとき ------------------- * Rustを使ってても安全性を捨てないといけないケースがある + Cと連携するとき + Rustから見たらCはデフォルトで危険 + データ構造を実装するとき + ハッシュテーブルみたいに未初期化かもしれないメモリを扱うとき * そういうときのエスケープハッチがある + その名も `unsafe` * `unsafe` な部分とsafeな部分を区別する仕組みがある === # 安全性を捨ててみる ------------------- * `unsafe` で囲むとやりたい放題できる [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2015\u0026gist=6a04ca87dc616a2dfece0aae00e9e981) ```rust use std::ffi::c_void; use std::ptr::null_mut; extern \"C\" { // FFIの関数のプロトタイプ宣言 // 参照とは別のマジのポインタ型 fn free(p: *mut c_void); } fn main() { // unsafeで囲むとやりたい放題 unsafe { // ヌルポが作れる！！ let p: *mut i32 = null_mut::(); // ヌルポに書き込める！！ *p = 1; // freeできる！！ free(p.cast()); // use after freeできる！！ println!(\"{}\", *p); } } ``` === # `unsafe` の仕組み ------------------- * Rustはいくつかの操作や関数を `unsafe` とみなす + 関数は自分で `unsafe` とマークできる * `unsafe` な操作は `unsafe` の内側でしかできないようになっている + `unsafe` の境界の安全性はユーザが保証する [run](https://play.rust-lang.org/?version=stable\u0026mode=debug\u0026edition=2015\u0026gist=3e1c98392da16fea45ed23e0d945ff72) ```rust use std::ptr::null_mut; fn main() { // ヌルポインタを作るだけならsafe let p: *mut i32 = null_mut::(); // ポインタに触るのはunsafe *p = 1; } ```  ```console error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block --\u0026gt; src/main.rs:7:5 | 7 | *p = 1; | ^^^^^^ dereference of raw pointer | = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior ```  === # `unsafe` の使いどころ ---------------------- * 基本は使わない。 * どう頑張っても `unsafe` を使わないと実装できないものは仕方なく使う + データ構造の実装に多い + 標準ライブラリの [`Vec`](https://doc.rust-lang.org/beta/src/alloc/raw_vec.rs.html#315-359) とか * めちゃくちゃ速度が重要で、 `unsafe` を使うとすごく高速化できる場合にはトレードオフを考えて使う + スライスの境界外アクセスを無視して行なう [`get_unchecked`](https://doc.rust-lang.org/beta/std/primitive.slice.html#method.get_unchecked)とか * C FFIのラッパを書くときはまあ、仕方ない + でも最小限に === # 活発なコミュニティ ------------------- * 「技術的投資」というならその資産のグロースも考えよう * stack overflowの[最も愛されている言語](https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted) + 2016年から4年連続1位 * [Microsoft](https://msrc-blog.microsoft.com/2019/11/07/using-rust-in-windows/)も導入に乗り気 * パッケージのセントラルレポジトリ([crates.io](https://crates.io))がある + 30,000+ クレート + 参考: rubygemsは150,000+ gems === # コミュニティ中心 ------------------- * コミュニティベースの開発 + 「Mozillaの言語」ではない。 + Mozilaが初期から支援しているだけ。今は[AWS](https://www.atmarkit.co.jp/ait/articles/1910/17/news088.html)とかもサポート。 * 開発はチームによる。チームの会議もDiscordなどで公開 + やさしい終身の独裁者的な人はいない * コミュニティから意見を吸い上げる→開発チームがロードマップを出すのサイクル + [サーベイ](https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html) とか [#rust2020](https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html) + 機能追加の提案も [GitHub](https://github.com/rust-lang/rfcs) から誰でもできる === # まとめ -------- * Rustは安全なシステムプログラミング言語だよ + 安全とはUBが起きないことだよ * 普通にプログラミング言語としても便利だよ * コミュニティに勢いがあるよ * お試しとしても新天地としても良い言語なんじゃないでしょうか   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2019-11-18","title":"安全なシステムプログラミング言語Rustへの招待","url":"https://KeenS.github.io/slide/anzennashisutemupuroguramingugengorusthenoshoutai/"},
  {"body":"κeenです。 n月刊ラムダノートに書いた「代数的データ型とパターンマッチの基礎」のところで「パターンマッチがあるとこんなに便利になるよ」というのと紹介し忘れていたので勝手に補遺します。 まあ、紙面の都合もあって覚えていたとしても入りませんでしたね。 代数的データ型とパターンマッチの題材としては定番の赤黒木を紹介します。\n赤黒木についてはこちらのページを参考にして下さい。特に、比較になるので掲載されているソースコードを読んで下さい。\n Red-Black Tree by Java \u0026ndash; これで分かった赤黒木  ソースコードはPython版もあるようです：Red-Black Tree by Python \u0026ndash; Python による赤黒木。\n読みましたか？\nそれでは赤黒木をStandard MLで書いていきます。 パターンマッチ関係ないところでややこしくならないように保持するデータ型は int とします。\n色とデータ型は文句なく以下で決まります。\ndatatype color = Red | Black datatype t = Leaf | Node of color * t * int * t ここからすぐさま簡単な操作は書けます。\nval empty = Leaf fun isEmpty Leaf = true | isEmpty _ = false fun isMember Leaf _ = false | isMember (Node (_, left, label, right)) x = (case Int.compare (label, x) of LESS =\u0026gt; isMember right x | EQUAL =\u0026gt; true | MORE =\u0026gt; isMember left x) さて、それでは insert と balance を書いていきます。Java（あるいはPython）の実装から分かるとおり、結構泥臭いというか何をやっているのか分かりづらい処理が続きます。これをパターンマッチで書き直したらどうなるか見てみましょう。\nまずは便利関数を定義しておきます。\nfun red l x r = Node(Red, l, x, r) fun black l x r = Node(Black, l, x, r) balance は以下で定義できます。\nfun balance (Node(Black, Node(Red, Node(Red, a, x, b), y, c), z, d)) = red (black a x b) y (black c z d) | balance (Node(Black, Node(Red, a, x, Node(Red, b, y, c)), z, d)) = red (black a x b) y (black c z d) | balance (Node(Black, a, x, Node(Red, Node(Red, b, y, c), z, d))) = red (black a x b) y (black c z d) | balance (Node(Black, a, x, Node(Red, b, y, Node(Red, c, z, d)))) = red (black a x b) y (black c z d) | balance t = t ここから insert を定義していきますが、その前に Int.compare 関数を紹介します。 Int.compare は以下の型を持つ関数です。\nInt.compare: int * int -\u0026gt; order ここで、 order は以下のように定義されています。\ndatatype order = LESS | EQUAL | GREATER Rubyでいう \u0026lt;=\u0026gt; メソッドのような存在ですね。\n以下のように動作します。\n# Int.compare (1, 2); val it = LESS : order # Int.compare (2, 2); val it = EQUAL : order # Int.compare (3, 2); val it = GREATER : order これを用いて insert は以下で定義できます。\nfun insert tree x = let fun ins Leaf x = red Leaf x Leaf | ins (t as Node(color, left, label, right)) x = (case Int.compare (label, x) of LESS =\u0026gt; balance (Node(color, left, label, (ins right x))) | EQUAL =\u0026gt; t | MORE =\u0026gt; balance (Node(color, (ins left x), label, right)) ) in case ins tree x of (* unreachable *) Leaf =\u0026gt; Leaf | Node(_, left, label, right) =\u0026gt; black left label right end ins のパターンマッチで使っている t as Node(...) という構文は、RubyのAsパターンと同様に Node(...) でパターンマッチしつつ全体を t に束縛する構文です。\nあとは以下のような関数を1つ用意してあげればREPLで遊べます。\nfun fromList [] = empty | fromList (x::xs) = insert (fromList xs) x REPLでの様子：\n# val tree = RedBlackTree.fromList [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; val tree = Node ( Black, Node ( Black, Node ( Red, Node (Black,Node (Red,Leaf,1,Leaf),2,Leaf), 3, Node (Black,Leaf,4,Leaf) ), 5, Node (Black,Leaf,6,Leaf) ), 7, Node (Black,Node (Black,Leaf,8,Leaf),9,Node (Black,Leaf,10,Leaf)) ) : t # isEmpty tree; val it = false : bool # isMember tree 0; val it = false : bool # isMember tree 2; val it = true : bool # isMember tree 10; val it = true : bool # isMember tree 11; val it = false : bool ここまで見てきたとおり、パターンマッチを使うことで複雑なデータ構造を簡潔に実装できます。 さらに、コードのほとんどが代数的データ型とパターンマッチで構成されていたことから分かるように、関数型言語ではちょっと便利なツール程度ではなくプログラムを構成する主たるパーツになっています。\n今回のコードをちゃんとした書き方に直したものを貼っておきます。 1つ注意しておくと関数型な書き方なのでいわゆる永続データ構造と呼ばれる形になっています。遊んでみる方は留意して下さい。\n","categories":["ML","SML","データ構造"],"category_urls":["/categories/ml","/categories/sml","/categories/%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0"],"date":"2019-11-02","title":"代数的データ型とパターンマッチの補遺: 赤黒木","url":"https://KeenS.github.io/blog/2019/11/02/daisuutekide_takatatopata_nmatchinohoi__akakuroki/"},
  {"body":"κeenです。 n月刊ラムダノート Vol.1, No.3(2019)に代数的データ型とパターンマッチの基礎の章を寄稿しました。 どんな内容か、どうやって執筆までに至ったのかを話そうと思います。\n書いたこと 目次:\n   節 タイトル     1.1 動作環境   1.2 SML#のREPLで速習SML   1.3 代数的データ型とパターンマッチ入門   1.4 パターンマッチの意味   1.5 パターンマッチのC言語へのコンパイル   1.6 発展的なパターン   1.7 代数的データ型がない言語とパターンマッチ   1.8 まとめと次回予告   1.9 参考文献    代数的データ型とパターンマッチの基礎について書きました。 まずはさしあたって必要になるSMLの文法を紹介したあと、代数的データ型やパターンマッチ、パターンがネストできること、網羅性検査や非冗長性検査などを紹介しました。 次に軽く意味論に触れ、そのままCに変換したコードを見せて「コンパイラは結構複雑なことをしてるんだよ」というのを示しました。 あとは発展編としてORパターンやパターンガード、バリアントのない代数的データ型を眺め、Common LispのoptimaやJavaのProject Amberを紹介しました。\n特に意識した訳ではないんですが、パターンマッチだけでなく代数的データ型もセットで使えることの重要性を説いた内容になりました。 代数的データ型とセットで使えることで網羅性検査や非冗長性検査ができるのが大きいからですね。 その結果、タイトルにも代数的データ型が入っています。これはML系言語を使ったことのある読者なら納得するところでしょう。\nまた、後で経緯を説明しますが元々コンパイラのトピックとしてパターンマッチのコンパイル技法を説明する予定だったことから、どういうコードに落ちるかもちゃんと説明しています。 パターンマッチを見て、どういうアセンブラに落ちるかが分かる人は実はそんなに多くないんじゃないかなと思います。 コンパイルアルゴリズム次第ですが、最終的には決定木に落ちて、ジャンプテーブルになります。 データ構造じゃなくてコードなのでそう呼んでいいのかは分かりませんがtrie木のようなものができあがります。\n興味の湧いた方は是非読んでみて下さい。\n経緯とか 最初にn月刊ラムダノートを知ったのはプログラミング言語系のワークショップ、PPLでした。\nこれツイートしていいやつですか？ @golden_lucky ラムダノートに技術文書を渡して編集しともらって出版までしてもらえるサービス開始するらしいですよ pic.twitter.com/BOMXkywaZF\n\u0026mdash; κeen (@blackenedgold) March 6, 2019 ちなみに学会誌とかの感覚だと掲載料は著者が払いますが、n月刊ラムダノートは著者が貰うらしいです。\n当社がもらう、という発想はなかった！\n\u0026mdash; keiichiro shikano λ♪ (@golden_lucky) March 6, 2019 \n私が書くとしたらRustか言語処理系かなーと思いつつ当時まだ実践Rust入門の執筆が終わってなかったので一旦はスルーしておきました。 そして間も無く実践Rust入門が校了し、余裕ができたので寄稿することにしました。\n執筆ネタとして思い当たったのがパターンマッチのコンパイル。 パターンマッチのコンパイルアルゴリズムについては以前、ML Dayで発表したのですが、そのとき調べた限りでは日本語どころか英語でもパターンマッチのコンパイルについて書かれた教科書がありませんでした。 論文ならいくつかあるのですが、そこで参照されている大本の参考文献1が絶版で手に入らないなどの惨憺たる状況で、まとめて日本語で読める資料の必要性を感じていました。\n私のML Dayの発表資料がそうなっていればよかったのですが、スライドなので資料としては不十分なのと、準備不足で満足な発表ができなかったのでそのままではいささか以上に質が足りません。 それに論文で紹介されているアルゴリズムはデータの持ち方の工夫などが省かれて抽象的に書かれており、実際の動くコードによる解説の必要性も感じていました。\nそこで本腰を入れてサーベイしてまとめて、n月刊ラムダノートに寄稿することにしました。 こういうのは中々アウトプットの目標がないと途中でモチベーションが切れたりピントのずれたサーベイをしたりしてしまいがちなので先に目標を据えるのは重要です。\nまた、ML系言語にあるパターンマッチの知名度が案外低く、網羅性検査や非冗長性検査を伴なわないパターンマッチしか知らない人も多いようです。 逆にML系言語を使う人はあんまりアセンブラまでは興味を払わないようで、上から順に試していくと思ってる人や if 文の連鎖と switch 文で生成されるコードが違うことを知らない人もいるようです。 そういう人に中身を見せる目的もありました。 特に最近はRubyやJavaにパターンマッチが入ろうとしていて俄に注目を浴びているのでタイミングとしても丁度よさそうです。\nそうやってサーベイしはじめたのがゴールデンウィーク。 当初は前半で調べものを終えて後半で執筆し終える予定でしたが、まあ、無理ですよね。 ゴールデンウィーク一杯を使って調べものと実装を終えました。\nゴールデンウィークが終わったらひとまず準備完了ということでラムダノート社に連絡し、執筆をはじめました。このとき提案したタイトルは「コンパイラワントピック： パターンマッチ」。 内容にフォーカスしたタイトルの方がいいと、提案された改題は「パターンマッチはどうコンパイルされるか」でした。\n執筆をはじめて、すぐに「あっ、これ思ったより内容多いな」と気付きます。 どう考えてもn月刊1冊に入りきらないので導入と実装以降を分ける提案がされたのが7月の中旬。 導入編を書き終えたのが8月末。 そこからラムダノート側の編集が入ったり、組版の相談をしたりののやりとりをして、最後の変更は10月の29日まで続いていました。 最終的に今回のタイトルになったのは全部の内容を書き上げたあとです。\nかくしてみなさんの手元にn月刊ラムダノート Vol.1 No. 3が届けられました。\nたまたま辻本さんのRubyのパターンマッチとコロケーションしたのでパターンマッチの回になりました。 しかし経緯を見てもらうと分かる通り、Rubyでパターンマッチの話題が盛り上がってるのを見て書くことにしたので偶然ではなく必然だったのかもしれません。\nn月刊ラムダノートに関するお気持ちとか 気軽に執筆して編集してもらって、出版までしてもらえるサービスが出てくれてすごく助かります。\nここ最近は技術書展の盛り上がりのおかげでエンジニア界隈で執筆ブームが来ているようです。 私も知り合いに誘われて参加を検討したことがありますが、今のところまだ行ったことはないです。\n私はOSSが好きなのですが、その理由の1つに「（無料であることも含めて）自由である代わりに自己責任が伴なう」という思想にあります。 これのお陰でアウトプット側のハードルがすごく下がります。 私のブログも同じような気持ちで書いていて、割と適当なことが書かれていることもよくあります。\n「無料の仕事に責任は伴わない」という言葉を裏返すと有償のものには責任が伴います。 そういった意味で、一人で書いた技術書を販売するのは少し気が引けます。 技術的内容はエンジニアをやってるならある程度は保証できる2でしょうが、その他の日本語などはそうはいかないでしょう。 編集が入ってない日本語は読みづらいですし、一人でやってたら誤字脱字衍字が多発するのは目に見えてます。 そういう質の悪いと自認する内容でお金を取りたくなくて二の足を踏んでいました。 編集者の人に頼んでやってもらおうかとも考えましたが、どこで頼んだらやってくれるのか、いくらで引き受けてくれるか、そもそもやってくれるのかは知りません。\nそれに折角人に見せられる文章を書いたなら、イベントに参加してたまたま自分のブースに目が止まった数十人に読んでもらうだけじゃなくてもっと多くの人に読んで欲しいです。\nあとこれは私のお金に関する感覚が狂ってるという話なんですが、人からお金を取るのが好きじゃないんですよね。 支払いを立替えたあとに、立替え元に代金を請求するのも気が引けるくらい、好きじゃないんです。 なのでできれば(直接は)お金をとらないで済む方法があると嬉しいです。\nそこにくるとn月刊ラムダノートは私にとって最良の選択肢です。 書くのは技術書のイベントなんかで売ってるものと変わらないくらいの分量で、ちゃんと編集を通ります。面倒な組版や印刷、出版は全部やってくれます。 商業出版なので少なくとも数十以上は売れるでしょうし、執筆した原稿はCC BY-NC-SA 4.0国際ライセンスの下、著者が頒布する権利も残ります3。 それに私の一番やりたくない直接お金を取る部分は代わってやってくれます。 嘘偽りなく、最初にn月刊ラムダノートの告知を見たときに「あ、2,3万払えばここまでやってくれるんだ」と思いました。 それが払う方じゃなくて貰う方だったとは…。仏のように慈悲深いサービスですね。 ラムダノート社が本当にこれで儲かるのか不安になるくらい良いシステムです。\nまだn月刊ラムダノートへの寄稿はパターンマチの実装編も残ってますし、他に書きたいネタもあるので、 ある程度n月刊ラムダノートで経験を積んで、一人でも書籍を書けるようになったら私も技術書のイベントに参加してみたいなと思ってます。\nn月刊ラムダノートは寄稿者を募集しているそうなので興味のある方は書いてみて下さい。 因みに募集は1万字程度だそうですが、2時間くらいで書いたこのエントリは5000字くらいです。持ちネタのある方なら気軽に書けると思います。\n SPJ のThe Implementation of Functional Programming Languages。SPJがPDFをMSRで公開してるので読もうと思えば読めます→ https://www.microsoft.com/en-us/research/wp-content/uploads/1987/01/slpj-book-1987-small.pdf [return] それも本当か怪しいですが… [return] 私の今回の原稿もどこかのタイミングで公開したいと思っています [return]  ","categories":["ML","SML","言語実装"],"category_urls":["/categories/ml","/categories/sml","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2019-11-02","title":"n月刊ラムダノートにパターンマッチについて寄稿しました","url":"https://KeenS.github.io/blog/2019/11/02/ngekkanramudano_tonipata_nmatchinitsuitekikoushimashita/"},
  {"body":"κeenです。ネタ記事です。ふと、構造体に配列のようなアクセスができる方法を思い付いたので共有します。\nざっくり言うとこういうことが書けるようになります。\nfn main(){letmutuser=User::new(1,\u0026#34;user\u0026#34;.into());// 名前でアクセス assert_eq!(user[name],\u0026#34;user\u0026#34;);// アップデートもできる user[id]+=1;assert_eq!(user[id],2);} もちろん、構造体はごく自然にこういう風に定義されています。\npubstruct User{id: u64,name: String,}implUser{pubfn new(id_var: u64,name_var: String)-\u0026gt; Self{User{id: id_var,name: name_var,}}} Rustでは [] はオーバーロード可能です。インデックスに使う値もオーバーロード毎に変えることができます。 なので以下のようにそれぞれのフィールド専用の構造体を定義してあげて、それをインデックスに使うことで上記のようなコードを実現できます。\nusestd::ops::{Index,IndexMut};// Userへのインデクシング専用の型を定義する #[allow(non_camel_case_types)]pubstruct id;#[allow(non_camel_case_types)]pubstruct name;// それぞれのインデックスとフィールドを対応づけてIndexとIndexMutを実装する implIndex\u0026lt;id\u0026gt;forUser{type Output=u64;fn index(\u0026amp;self,_: id)-\u0026gt; \u0026amp;Self::Output{\u0026amp;self.id}}implIndexMut\u0026lt;id\u0026gt;forUser{fn index_mut(\u0026amp;mutself,_: id)-\u0026gt; \u0026amp;mutSelf::Output{\u0026amp;mutself.id}}implIndex\u0026lt;name\u0026gt;forUser{type Output=String;fn index(\u0026amp;self,_: name)-\u0026gt; \u0026amp;Self::Output{\u0026amp;self.name}}implIndexMut\u0026lt;name\u0026gt;forUser{fn index_mut(\u0026amp;mutself,_: name)-\u0026gt; \u0026amp;mutSelf::Output{\u0026amp;mutself.name}} 因みにこのコードは id や name が構造体のコンストラクタでもあるので、パターンとしても書けてしまいます。 なので以下のコードは id がパーターンと認識されて型エラーになります。\nletid=user[id]; コンパイルするとこう。\n57 | let id = user[id]; | ^^ expected u64, found struct `id` | = note: expected type `u64` found type `id`  気をつけましょう。\nコード\n playground\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2019-10-31","title":"Rustで構造体に配列のようなインデックスアクセス","url":"https://KeenS.github.io/blog/2019/10/31/rustdekouzoutainihairetsunoyounaindekkusuakusesu/"},
  {"body":"κeenです。昔変な構成でRAID1を組んだのですが、その状態でUbuntuのアップグレードをしたらgrubが壊れたらしくどうにもならなくなったのでそれを復旧したときのメモです。\ngrub rescueに落ちたら普段ならカーネルの場所さえ分かれば復帰できるんですが今回はgrub rescueが壊れてるようなのでそれもできません。\ncurrent status pic.twitter.com/2yxwSMrdnL\n\u0026mdash; κeen (@blackenedgold) October 21, 2019 \n色々調べた結果、これはgrubを再インストールする他ないようです。 外部から起動して、元のシステム内にchrootで入ってから grub-install を叩きます。\nという訳でUbuntuのインストールメディアをもってきて、そちらから起動します。\nインストールメディアには「Ubuntuを試す」のオプションがあるのでそこからUbuntuに入りましょう。 そこからGNOME Terminalなどのターミナルを立ち上げます。\nここから先は記憶で書いているので注意です。\nデバイスを見付ける rootが載っていたデバイスの他に、今挿したインストールメディアや、バックアップ用のディスクもあるのでgrubがrootが載っていたデバイスを探します。\n色々方法があるかと思いますが、私は gpartedでパーティションを見て探します。 今回は /sdb と /sdd がそれだったみたいです。\nmdadm の復元 /boot を格納している筈の /dev/md0 がありませんでした。なのでmd0を復元させます。これはコマンド1つでできるみたいです。\n$ mdadm --assemble --scan  これで /dev/md0 ができました。\nroot fsをマウントする / はbtrfsなのでそれをマウントします。 RAIDを構成しているデバイスを全部列挙し、サブボリュームも指定してあげましょう。\n$ sudo mount -t btrfs -o device=/dev/sdb5,device=/dev/sdd5,subvol=@ /dev/sdb5 /mnt  /boot をマウントする 普通にマウントすればいいです。\n$ sudo mount /dev/md0 /mnt/boot  その他疑似ファイルシステムをマウントする マウントしましょう。 See also linux - mount dev, proc, sys in a chroot environment? - Super User\n$ sudo mount -t proc proc /mnt/proc $ sudo mount --rbind /sys sys/ $ sudo mount --rbind /dev dev/  chrootする chrootします。\n$ chroot /mnt /bin/bash grubの再インストール 前をブログのようにやればよいです。\n$ sudo grub-install /dev/sdb $ sudo grub-install /dev/sdd $ sudo update-grub  これであとは再起動するだけ。\nファイルシステムのマウントのところは人それぞれだと思うので各自で判断してやって下さい。\n","categories":["Linux"],"category_urls":["/categories/linux"],"date":"2019-10-21","title":"grub rescueで'grub_file_filters' not foundが出るときの対処方","url":"https://KeenS.github.io/blog/2019/10/21/grub_rescuede_grub_file_filters__not_foundgaderutokinotaishohou/"},
  {"body":"κeenです⸜( ¯⌓¯ )⸝。\nずっとuim-skkを使っていての困り事がユニコードの扱いでした。 uimの内部コーディングはEUC-JPなんですが、「⸜( ¯⌓¯ )⸝」に含まれる「⌓」がEUJ-JP外なので入力できないのです。そこでuim-skk内部や辞書をUTF-8化して入力できるようにしたお話です。\n偉そうに書いてますが本体はこのブログによるものです： 「𠁣」の文字をどのようにキーボード入力するか\nここに書いてある通りでほぼ動くのですが、地味にパッチがコケたりですんなりとは動かなかったのでその作業メモです。\n既に sudo apt install uim uim-skk skkdic skkdic-extra くらいは済んでる想定です。\nブログのパッチを当てる /usr/share/uim 以下にuimのSchemeファイルがあるのでそれらにパッチを当てます。 しかしパッチはuimの1.8.6用に作られてますが、Ubuntu 19.10だと1.8.8が入るので綺麗にパッチが当たりません。 そこで私がパッチを修正して1.8.8に当たるようにしたものを出しておきます。\nこれです。 https://gitlab.com/snippets/1905594\nこれを使って以下のスクリプトでえいやと変換できるはずです。\ncd /usr/share/uim for f in japanese-act.scm japanese-azik.scm japanese-custom.scm japanese-kana.scm japanese-kzik.scm japanese.scm skk.scm skk-custom.scm do new=\u0026#34;$(echo $f | sed \u0026#39;s/\\.scm$/-utf8.scm/\u0026#39;)\u0026#34; iconv -f EUC-JP -t UTF-8 \u0026lt; \u0026#34;$f\u0026#34; | sudo tee \u0026#34;$new\u0026#34; \u0026gt; /dev/null done wget -O /tmp/uim-skk-1.8.8-utf8.patch https://gitlab.com/snippets/1905594/raw cat /tmp/uim-skk-1.8.8-utf8.patch | sudo patch -p0 -b --follow-symlink sudo mv skk.scm skk.scm.orig \u0026amp;\u0026amp; sudo mv skk-utf8.scm skk.scm sudo mv skk-custom.scm skk-custom.scm.orig \u0026amp;\u0026amp; sudo mv skk-custom-utf8.scm skk-custom.scm sudo rm japanese-custom-utf8.scm.orig japanese-utf8.scm.orig skk-utf8.scm.orig ここで一旦再起動して、uimでひらがなが入力できるかくらいは確認した方が良いでしょう。\n辞書のUTF-8化 次に、既存のSKK辞書をUTF-8化したいです。\nここで問題になるのが私が使っているyaskkservです。 yaskkservはEUC-JPにハードコードされているらしいのでyaskkservはやめて辞書ファイルに移行することにします。 uimは1つの辞書ファイルしかサポートしていないので辞書ファイルを結合する処理もします。\nuimのGUIから設定する人は[SKK 辞書]からskkservを使わないようにし、テキストで設定する人は~/.uim.d/customs/custom-skk-dict.scm の skk-use-skkserv を #f に設定しましょう。\nさて、これで辞書を変換にかかります。 /usr/share/skk に辞書ファイルが並んでる筈なので、一旦これらを *.utf8 変換したあと、全部入りの辞書ファイル SKK-JISYO.all.utf8 を作ります。 そしてデフォルトの辞書を /usr/share/skk/SKK-JISYO.all.utf8 にしておきましょう。\n以下のスクリプトで一気にできるはずです。\ncd /usr/share/skk for f in SKK-JISYO.*; do iconv -f EUC-JP -t UTF-8 \u0026lt; \u0026#34;$f\u0026#34; | sudo tee \u0026#34;$f.utf8\u0026#34; \u0026gt; /dev/null done skkdic-expr2 *.utf8 | sudo tee SKK-JISYO.all.utf8 \u0026gt; /dev/null sudo ln -sf /usr/share/skk/SKK-JISYO.all.utf8 /etc/alternatives/SKK-JISYO /usr/share に書き込むのが嫌な人は /usr/local/share に作ってもいいでしょう。\nあとは別途、 ~/.skk-jisyo や ~/.skk-uim-jisyo も変換しておいて下さい。\n絵文字辞書のインストール ここまで来ると絵文字辞書が使えるようになります。skk-emoji-jisyoとかSKK-JISYO.emoji-jaとか。\nこれはさっきの辞書を変換するコマンドの引数に絵文字辞書を加えてあげると実現できます。\nskkdic-expr2 /usr/share/skk/*.utf8 /path/to/other_dicks | \\  sudo tee /usr/share/skk/SKK-JISYO.all.utf8 \u0026gt; /dev/null これでSKKユーザでも絵文字が使えるようになりました✌\nトラブルシューティング uimのログ どこにあるのか分かりませんでした。詳しい人教えて下さい。\nuimの再起動 どうやってやるのか分かりませんでした。 GNOME Shellが管轄してる気がするので多分ですが再起動が一番確実だと思います。\n辞書のリロード これはログアウトでできるみたいです。\nその他絵文字などを追加したい \\u とコードポイントで新しい文字を入力できます。 普段、シフトによる漢字変換や / によるアルファベット変換ばかり使ってるかと思いますが、 \\ によるコードポイントの入力もあるのです。そこで u に続いてユニコードのコードポイントを入れると入力できます。 例えば ✌ であれば \\u270c と入力すると入ります。\n","categories":["SKK","Ubuntu"],"category_urls":["/categories/skk","/categories/ubuntu"],"date":"2019-10-20","title":"パッチを当ててuim-skkをUTF-8化する","url":"https://KeenS.github.io/blog/2019/10/20/patchiwoateteuim_skkwoutf_8kasuru/"},
  {"body":"κeenです。Ubuntu 19.10出ましたね。Ubuntu 19.10からZFSをroot fsにしたインストールがサポートされるようになったので試しました。\n一番気になるのはライセンスですよね。 過去に何度もやるって言ってはライセンスで揉めて取り下げてます。 この記事によるとCanonicalは問題ないというスタンスだということです。本当に大丈夫なのかな…。\nさて、インストールは特に難しいことはなくて、いつものパーティションどうする？と聞いてくるところでzfsの選択肢が出てきます。それを選択すればよいようです。\nやっていきー pic.twitter.com/91g5cAwGKb\n\u0026mdash; κeen (@blackenedgold) October 18, 2019 インストール後は、LTSの直前のリリースにしては何も問題がないくらい普通に動いてます。 よく壊れるSlack for Linux (β)も問題なく動いてます。\n因みにDropboxは最近btrfsやzfsのサポートを再開したらしいです。 私もちゃんと動きました。Dropboxユーザも安心してzfsを試せますね。\nところでDropboxがbtrfsとかzfsとかのサポート再開してたの知らなかったhttps://t.co/8PV6yA7Bdq\n\u0026mdash; κeen (@blackenedgold) October 18, 2019 \nさて、少しだけの機能をzfsを使ってみましょう。\nzfsのプールはこのように切られているようです。\n$ zpool list NAME SIZE ALLOC FREE CKPOINT EXPANDSZ FRAG CAP DEDUP HEALTH ALTROOT bpool 1.88G 66.1M 1.81G - - - 3% 1.00x ONLINE - rpool 460G 15.3G 445G - - 0% 3% 1.00x ONLINE - $ zfs list bpool NAME USED AVAIL REFER MOUNTPOINT bpool 65.8M 1.69G 176K /boot $ zfs list rpool NAME USED AVAIL REFER MOUNTPOINT rpool 15.3G 430G 96K /  ちょっとスナップショットを試してみましょう。\n適当なファイルを用意します。\n$ mkdir tmp $ cd tmp $ echo hogehoge \u0026gt; text.txt  スナップショットを取りましょう。 rpool/USERDATA/shun_2meu5j がユーザのホームディレクトリを指しているようです。 そこのスナップショットを test という名前で撮ります。\n$ sudo zfs snapshot rpool/USERDATA/shun_2meu5j@test  zfs list に -t snapshot を渡すとスナップショットの一覧が取れます。\n$ zfs list -t snapshot NAME USED AVAIL REFER MOUNTPOINT rpool/USERDATA/shun_2meu5j@test 332K - 11.2G -  スナップショットのリネームもできるらしいです。\n$ sudo zfs rename rpool/USERDATA/shun_2meu5j@test backup $ zfs list -t snapshot NAME USED AVAIL REFER MOUNTPOINT rpool/USERDATA/shun_2meu5j@backup 648K - 11.2G -  さて、これでrollbackも試してみましょう。 適当に用意したファイルの内容を上書きます。\n$ echo fugafuga \u0026gt; text.txt  そしてロールバック\n$ sudo zfs rollback rpool/USERDATA/shun_2meu5j@backup  これで中身を見ると変更が差し戻されているのが分かります。すごい。\n$ cat text.txt hogehoge  因みにrollbackしても該当のスナップショットは消えません。 該当のスナップショット以降に撮ったスナップショットは消えるらしいです。\n$ zfs list -t snapshot NAME USED AVAIL REFER MOUNTPOINT rpool/USERDATA/shun_2meu5j@backup 468K - 11.2G -  最後にスナップショットを消しましょう。 zfs destroy でできるらしいです。\n$ sudo zfs destroy rpool/USERDATA/shun_2meu5j@backup $ zfs list -t snapshot no datasets available  今回試したのはノートパソコンだったのでホットプラグとかは試せませんでした。 詳しくはFSとかに詳しそうな人のブログをあたって下さい。\n","categories":["Linux","Ubuntu","zfs"],"category_urls":["/categories/linux","/categories/ubuntu","/categories/zfs"],"date":"2019-10-19","title":"Ubuntu 19.10でzfs root試してみた","url":"https://KeenS.github.io/blog/2019/10/19/ubuntu_19_10dezfs_roottameshitemita/"},
  {"body":" .narrow { letter-spacing: -30px; } .narrow span { transform: scaleX(0.7); transform-origin: left; display: inline-block; }  # その正規表現エンジン、\nインタプリタで満足(サティスファイ)してる？！ ---------------------- [Regex Festa - connpass](https://opt.connpass.com/event/140566/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # 今日話すこと -------------- * SATySFi * 部分評価と二村射影 * 多段階計算 * (正規表現のコンパイル) === # SATySFi --------- * 政府の支援によりTeXを倒すために作られた組版処理系 + ※多少の誇張を含みます * 日本語が扱えて、PDFを直接吐ける * ML系の言語で拡張ができる + 静的に型が付く * ↓ 作者 ？\n\u0026mdash; 画力・博士号・油田 (@bd_gfngfn) August 11, 2019 ！\n\u0026mdash; 画力・博士号・油田 (@bd_gfngfn) October 17, 2019  === # Hello SATySFi --------- ```text @require: stdjareport let-inline \\show-int n = embed-string (arabic n) in document (| title = {サンプル文書}; author = {組 版太郎}; |) '``` === # Hello SATySFi --------------- ``` console $ satysfi hello.saty $ ls hello.pdf hello.saty hello.satysfi-aux ``` === # インタプリタとコンパイラの関係 ------------------------------ * インタプリタとコンパイラって似てない？？ * `1 + 1` がきたときに + `1 + 1` を計算する + 「`1 + 1` を計算する」コードを生成する * インタプリタの「計算をする」部分をそのまま吐き出せればコンパイラになりそう === # インタプリタとコンパイラの関係 ------------------------------ * Q: インタプリタからコンパイラって作れないの？ * A: 実際にできるかは知らないけどそれっぽい原理ならあるよ === # (第一)二村射影 ---------- * インタプリタはinputとソースコードを受け取る * もしソースだけ先に渡されて最大限準備できたらどうなる？ + = インタプリタをソースで部分評価 ```text +---------+ +--------+ | in/data | | source | +---------+ +--------+ | | +-------------+ | interpreter | +-------------+ | +----------+ | out/data | +----------+ ``` === # (第一)二村射影 ---------- * 実行可能ファイルが作れる筈 ```text +---------+ +--------+ +---------+ | in/data | | source |-----+ | in/data | +---------+ +--------+ | +---------+ | | | | +-------------+ +----+ +-----+ | interpreter |-------| F1 |--| exe | +-------------+ +----+ +-----+ | | +----------+ +----------+ | out/data | | out/data | +----------+ +----------+ ``` === # 第二、第三二村射影 ---------- * 補足程度に * 第二: 第一二村射影をソースで部分評価するとコンパイラができる * 第三: 第二二村射影を第一二村射影で部分評価するとコンパイラジェネレータができる === # 展望 --------------- * ソースだけ「先に計算」できたらコンパイルできそう * つまり何かしらのインタプリタからコンパイラが作れそう * でも「先に計算」、「後の計算」を考えると計算が多段階になるんじゃない？ * → 多段階計算 === # 多段階計算 ----------- * プログラムの実行を多段階に行なう + ステージ0で「ステージ1で実行されるプログラム」の生成 + ステージ1でプログラムの実行 * SATySFiがサポート！ * プリミティヴ + `~` - 気持はeval - 次のステージにいく * `\u0026` - 気持はquasi-quote - 前のステージにいく * `\u0026ty` で 「次のステージで `ty` 型になる式」の意味 === # 例0 ----- ```ml (* ステージ0 *) (* 式の前に\u0026をつけると\u0026の型になる *) \u002642: \u0026int ``` ```ml (* ステージ1 *) (* \u0026の式の前に ~ をつけると評価する *) ~(\u002642): int ``` === # 例1 ----- * 足し算を部分評価する例 * ステージ0でnを先に渡してしまう ```ml let add n m = n + m ``` === # 例1 ----- ```ml (* ステージ0 *) let add n = \u0026(fun m - ~n + m) ``` ```ml (* ステージ1 *) (* `1 +` を計算する関数をステージ0で生成する *) let inc = ~(add \u00261) (* let inc = fun m - 1 + m *) (* ステージ1で生成した関数を使う *) inc 3 ``` === # 例2 ----- * 指数を計算する関数を考える * これを肩について部分評価したい + = $base^n$ を $base * base * \\cdot * base$ に展開したい * 普通のコード ```ml let-rec power n base = if n ~(aux n \u0026base)) ``` ```ml (* ステージ1 *) (* b * b * b を計算する関数をステージ0で生成する*) let cube = ~(power 3) (* let cube = fn base = base * base * base * 1*) (* ステージ1で生成した関数を使う *) cube 9 ``` === # 例3 ----- * ショートサーキット + SATySFiにはショートサーキットする論理or/andがない ```ml (* stage 0 *) let ( \u0026\u0026\u0026 ) b1 b2 = \u0026(if ~b1 then ~b2 else false) ``` ```ml (* stage 1 *) ~(\u0026(1 + 1 = 2) \u0026\u0026\u0026 \u0026(2 + 3 = 4)) ``` ↓ ``` ml ~\u0026(if ~(\u0026(1 + 1 = 2)) then ~(\u0026(2 + 3 = 4)) else false) ~\u0026(if (1 + 1 = 2) then (2 + 3 = 4) else false) if (1 + 1 = 2) then (2 + 3 = 4) else false ``` === # 多段階計算の疑問 ------------------ * マクロじゃないの？ + 似てるけど違う + マクロと違って式から式への変換しかできない + アナフォリックマクロを書けない * evalがあると破滅しない？ + stage 0で生成したコードを評価するだとか + コードじゃない値をevalするだとか + うまい具合に制約が入って破天荒なことはできない * 生成されたコードがコンパイルエラーになったりしないの？ + 生成されるコードまで含めて型がつくので、ない。 === # 今日の話 ----------- * SATySFiの多段階を使って正規表現をコンパイルする === # 正規表現インタプリタ -------------------- * 数十行で書ける * 命令の列をリストで持つことにする * εと連接がfor freeでついてくる * ↓ のプリミティヴをサポート ```ml type vm-inst = | CHAR of string | KLEENE of vm-inst list | OR of vm-inst list * vm-inst list ``` === # 正規表現インタプリタ -------------------- ```ml let run iseq = let-rec loop iseq sp len s = (* ここで iseq の処理 *) in let f s = let sp = 0 in let len = string-length s in loop iseq 0 sp len s in f ``` === # 正規表現インタプリタ -------------------- CHAR さっきのショートサーキットを使う ``` | CHAR c - if ~(\u0026(sp インタプリタ -------------------- KLEENE(強欲マッチ) ``` | KLEENE code - let-rec kleene sp = match loop code sp len s with | Some(sp) - kleene sp | None - sp in let sp = kleene sp in loop iseq sp len s ``` === # 正規表現インタプリタ -------------------- ``` | OR (code1, code2) - (match loop code1 sp len s with | Some(v) - Some(v) | None - loop code2 sp len s) ``` === # 正規表現インタプリタ -------------------- ```ml let matcher = ( let iseq = [KLEENE([CHAR(`a`)]); CHAR(`b`); CHAR(`c`)] in run iseq) in let input = `aaaaaaaaaaaaabc` in let result = matcher input in match result with | Some(at) - `matched to `# ^ (string-sub input 0 at) | None - `not matched` ``` === # 静的動的 ---------- * これらを多段階計算を使ってコンパイルしたい。 * 基本は全部 `\u0026` で、 静的なものだけを `~` するとよい + ここでは静的なものはiseqのみ * ほとんどインタプリタと変わらない === # 正規表現のコンパイル ------------------- ```ml let compile iseq = let-rec loop iseq sp len s = (* ここでiseqの処理 *) in \u0026(let f s = let sp = 0 in let len = string-length s in ~(loop iseq 0 \u0026sp \u0026len \u0026s) in f) ``` === # 正規表現のコンパイル ------------------- KLEENE ```ml | KLEENE code - \u0026(let sp = ~(sp) in let-rec kleene sp = match ~(loop code \u0026sp len s) with | Some(sp) - kleene sp | None - sp in let sp = kleene sp in ~(loop iseq \u0026sp len s) ) ``` === # 正規表現のコンパイル ------------------- OR ```ml | OR (code1, code2) - \u0026(let sp = ~(sp) in match ~(loop code1 \u0026sp len s) with | Some(v) - Some(v) | None - ~(loop code2 \u0026sp len s) ) ``` === # 正規表現のコンパイル ------------------- CHAR ```ml | CHAR c - \u0026(let sp = ~(sp) in if ~(\u0026(sp 一応 dev-macro-on-multi-stage というbranchで開発中のものには lift-int や lift-string などのリフト用のプリミティヴをいくつか入れています\n\u0026mdash; 画力・博士号・油田 (@bd_gfngfn) October 14, 2019 === # 正規表現のコンパイル ------------------- CHAR ```ml | CHAR c - \u0026(let sp = ~(sp) in if ~(\u0026(sp コンパイル -------------------- ```ml let matcher = ~( let iseq = [KLEENE([CHAR(`a`)]); CHAR(`b`); CHAR(`c`)] in compile iseq) in let input = `aaaaaaaaaaaaabc` in let result = matcher input in match result with | Some(at) - `matched to `# ^ (string-sub input 0 at) | None - `not matched` ``` === # 比較 ------- * （パーサを適切に実装したら）インタプリタと違って静的に(stage 0で)エラーを検出できる * インタプリタと違って、正規表現は静的に(stage 0で)与えられないといけない + stage 1の実行時にファイルから読んだりはできない * インタプリタより少し速い + とあるワークロードで 4.70s vs 4.83s + サボって強欲マッチにしたのでpathological caseを作れなかった === # まとめ -------- * 多段階計算があるとインタプリタを簡単にコンパイラに変換できる * SATySFiを使ってそれをデモンストレーションした * [コード](https://github.com/KeenS/satysfi-rejit)   ","categories":["正規表現","SATySFi","多段階計算"],"category_urls":["/categories/%e6%ad%a3%e8%a6%8f%e8%a1%a8%e7%8f%be","/categories/satysfi","/categories/%e5%a4%9a%e6%ae%b5%e9%9a%8e%e8%a8%88%e7%ae%97"],"date":"2019-10-18","title":"その正規表現エンジン、インタプリタで満足してる？！","url":"https://KeenS.github.io/slide/sonoseikihyougenenjin_intapuritademanzokushiteru__/"},
  {"body":"κeenです。型レベル迷路作ったよ！コンパイルが通ったらゴール！！\nRustで型レベルステートマシン定義できるじゃないですか 1。 ということは1マス単位で移動できる方向を使い分けられるし迷路くらい作れるんじゃね？というお話。\nサクっといきます。\nマス型。\nusestd::marker::PhantomData;pubstruct Cell\u0026lt;Maze,X,Y\u0026gt;{m: PhantomData\u0026lt;Maze\u0026gt;,x: PhantomData\u0026lt;X\u0026gt;,y: PhantomData\u0026lt;Y\u0026gt;,}impl\u0026lt;Maze,X,Y\u0026gt;Cell\u0026lt;Maze,X,Y\u0026gt;{constfn new()-\u0026gt; Self{Self{m: PhantomData,x: PhantomData,y: PhantomData,}}} 迷路間で定義を使い回したいので迷路もパラメータに持ってます。 また、任意のマスが作られては困るのでフィールドも new もプライベートです。 あと static 変数にバインドしたい関係で const にしてます。\n次、自然数型。\npubtraitNat{fn to_n()-\u0026gt; u32;}pubstruct Z;pubstruct S\u0026lt;N\u0026gt;(N);type _0=Z;type _1=S\u0026lt;_0\u0026gt;;type _2=S\u0026lt;_1\u0026gt;;implNatforZ{fn to_n()-\u0026gt; u32 {0}}impl\u0026lt;N: Nat\u0026gt;NatforS\u0026lt;N\u0026gt;{fn to_n()-\u0026gt; u32 {N::to_n()+1}} ついでにマスを座標でプリントできるようにする。\nimpl\u0026lt;Maze,X,Y\u0026gt;Cell\u0026lt;Maze,X,Y\u0026gt;whereX: Nat,Y: Nat,{fn to_point()-\u0026gt; (u32,u32){(X::to_n(),Y::to_n())}} ここまできたらあとは迷路を作るだけ。こういう迷路を作りましょう。\n0 1 + +---+ | g | 0 +---+ + | | s | 1 +---+ + すなわち、\n (1, 1)がスタートである (1, 1)から(0, 1)へ移動できる (0, 1)から(1, 1)へ移動できる (0, 1)から(0, 0)へ移動できる (0, 0)から(0, 1)へ移動できる (0, 0)はゴールである  とします。\n素直にステートマシンで実装しましょう。\npubmod maze1{usesuper::{_0,_1};pubstruct Maze1;pubtype Cell\u0026lt;X,Y\u0026gt;=super::Cell\u0026lt;Maze1,X,Y\u0026gt;;implCell\u0026lt;_1,_1\u0026gt;{pubfn up(self)-\u0026gt; Cell\u0026lt;_1,_0\u0026gt;{println!(\u0026#34;{:?}\u0026#34;,Self::to_point());Cell::new()}}implCell\u0026lt;_1,_0\u0026gt;{pubfn left(self)-\u0026gt; Cell\u0026lt;_0,_0\u0026gt;{println!(\u0026#34;{:?}\u0026#34;,Self::to_point());Cell::new()}}implCell\u0026lt;_1,_0\u0026gt;{pubfn down(self)-\u0026gt; Cell\u0026lt;_1,_1\u0026gt;{println!(\u0026#34;{:?}\u0026#34;,Self::to_point());Cell::new()}}implCell\u0026lt;_0,_0\u0026gt;{pubfn down(self)-\u0026gt; Cell\u0026lt;_0,_1\u0026gt;{println!(\u0026#34;{:?}\u0026#34;,Self::to_point());Cell::new()}}pubtype Start=Cell\u0026lt;_1,_1\u0026gt;;pubtype Goal=Cell\u0026lt;_0,_0\u0026gt;;pubconstSTART: Start=Cell::new();} モジュール内で Maze1 と Cell\u0026lt;X, Y\u0026gt; を定義しているので、内部では自然にステートマシンを定義できます。 各移動メソッドは self を消費しているので前の状態が消えるようになっていて、ちゃんとステートマシンになってますね。 そして表示用に println! を挟んでます。これはちょっと汚ないので経路は別に返せるようにしたいですね。\nさてさて、この迷路を遊ぶには以下のような関数を定義します。\nfn solve_maze1(start: maze1::Start)-\u0026gt; maze1::Goal{// 迷路の回答 } 迷路のステートマシンを巧みに操ってゴールまでいけたらコンパイルが通るので迷路が解けました。\nあとはこのように main を書いてあげると経路が表示されます。\nfn main(){println!(\u0026#34;starting from {:?}\u0026#34;,maze1::Start::to_point());let_goal=solve_maze1(maze1::START);println!(\u0026#34;goal!\u0026#34;);}starting from (1, 1) (1, 0) (0, 0) goal!  やったね！\n迷路を生成する これで迷路を遊べるようにはなりましたが、ちょっと定義が面倒ですね。 大体機械的に生成できるのでマクロでやっつけてしまいましょう。 マクロは長くなるので付録に回しますが、以下のように迷路を定義できるようになります。\nmod maze2{maze!{Maze2,[g.],[#s]}} これも先程と同じように解けます。\nfn solve_maze2(start: maze2::Start)-\u0026gt; maze2::Goal{start.up().left()} これで大規模迷路もできますね！ 例えばこういうものを置いてておきます。\nmod maze3{maze!{Maze3,[.........#..g],[.###.#####.#.],[.#.#.......#.],[.#.#######.#.],[...#.....#.#.],[####.#.#.###.],[.....#.#.....],[.#####.######],[.....#.#.....],[.###.#.#.###.],[.#...#.#...#.],[##.###.#####.],[s..#.........]}} 是非チャレンジしてみて下さい。\n今回のコードはこちら。\n付録A. マクロ macro_rules!gen_cell{($ty: ty,.,($upty: ty,$up:tt),($rightty: ty,$right:tt),($downty:ty,$down:tt),($leftty:ty,$left: tt))=\u0026gt;{gen_cell!{$ty,($upty,$up),($rightty,$right),($downty,$down),($leftty,$left)}};($ty: ty,s,($upty: ty,$up:tt),($rightty: ty,$right:tt),($downty:ty,$down:tt),($leftty:ty,$left: tt))=\u0026gt;{pubtype Start=$ty;pubconstSTART: $ty=Cell::new();gen_cell!{$ty,($upty,$up),($rightty,$right),($downty,$down),($leftty,$left)}};($ty: ty,g,($upty: ty,$up:tt),($rightty: ty,$right:tt),($downty:ty,$down:tt),($leftty:ty,$left: tt))=\u0026gt;{pubtype Goal=$ty;gen_cell!{$ty,($upty,$up),($rightty,$right),($downty,$down),($leftty,$left)}};($ty: ty,#,($upty: ty,$up:tt),($rightty: ty,$right:tt),($downty:ty,$down:tt),($leftty:ty,$left: tt))=\u0026gt;{};($ty: ty,($upty: ty,g),($rightty: ty,$right:tt),($downty:ty,$down:tt),($leftty:ty,$left: tt))=\u0026gt;{gen_cell!{$ty,($upty,.),($rightty,$right),($downty,$down),($leftty,$left)}};($ty: ty,($upty: ty,$up:tt),($rightty: ty,g),($downty:ty,$down:tt),($leftty:ty,$left: tt))=\u0026gt;{gen_cell!{$ty,($upty,$up),($rightty,.),($downty,$down),($leftty,$left)}};($ty: ty,($upty: ty,$up:tt),($rightty: ty,$right:tt),($downty:ty,g),($leftty:ty,$left: tt))=\u0026gt;{gen_cell!{$ty,($upty,$up),($rightty,.),($downty,.),($leftty,$left)}};($ty: ty,($upty: ty,$up:tt),($rightty: ty,$right:tt),($downty:ty,$down:tt),($leftty:ty,g))=\u0026gt;{gen_cell!{$ty,($upty,$up),($rightty,.),($downty,$down),($leftty,.)}};($ty: ty,($upty: ty,.),($rightty: ty,$right:tt),($downty:ty,$down:tt),($leftty:ty,$left: tt))=\u0026gt;{impl$ty{#[allow(dead_code)]pubfn up(self)-\u0026gt; $upty{println!(\u0026#34;{:?}\u0026#34;,\u0026lt;$upty\u0026gt;::to_point());\u0026lt;$upty\u0026gt;::new()}}gen_cell!{$ty,($upty,#),($rightty,$right),($downty,$down),($leftty,$left)}};($ty: ty,($upty: ty,$up:tt),($rightty: ty,.),($downty:ty,$down:tt),($leftty:ty,$left: tt))=\u0026gt;{impl$ty{#[allow(dead_code)]pubfn right(self)-\u0026gt; $rightty{println!(\u0026#34;{:?}\u0026#34;,\u0026lt;$rightty\u0026gt;::to_point());\u0026lt;$rightty\u0026gt;::new()}}gen_cell!{$ty,($upty,#),($rightty,#),($downty,$down),($leftty,$left)}};($ty: ty,($upty: ty,$up:tt),($rightty: ty,$right:tt),($downty:ty,.),($leftty:ty,$left: tt))=\u0026gt;{impl$ty{#[allow(dead_code)]pubfn down(self)-\u0026gt; $downty{println!(\u0026#34;{:?}\u0026#34;,\u0026lt;$downty\u0026gt;::to_point());\u0026lt;$downty\u0026gt;::new()}}gen_cell!{$ty,($upty,#),($rightty,#),($downty,#),($leftty,$left)}};($ty: ty,($upty: ty,$up:tt),($rightty: ty,$right:tt),($downty:ty,$down:tt),($leftty:ty,.))=\u0026gt;{impl$ty{#[allow(dead_code)]pubfn left(self)-\u0026gt; $leftty{println!(\u0026#34;{:?}\u0026#34;,\u0026lt;$leftty\u0026gt;::to_point());\u0026lt;$leftty\u0026gt;::new()}}gen_cell!{$ty,($upty,#),($rightty,#),($downty,#),($leftty,#)}};($ty: ty,($upty: ty,$up:tt),($rightty: ty,$right:tt),($downty:ty,$down:tt),($leftty:ty,$left:tt))=\u0026gt;{};}macro_rules!gen_maze_row{($x: ty,$y: ty,[$up_left:tt$up:tt$($up_rest:tt)*],[$left:tt$cell:tt$right:tt$($rest:tt)*],[$down_left:tt$down:tt$($down_rest:tt)*])=\u0026gt;{gen_cell!{Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$cell,(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$y\u0026gt;,$up),(Cell\u0026lt;$crate::S\u0026lt;$crate::S\u0026lt;$x\u0026gt;\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$right),(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$crate::S\u0026lt;$y\u0026gt;\u0026gt;\u0026gt;,$down),(Cell\u0026lt;$x,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$left)}gen_maze_row!{$crate::S\u0026lt;$x\u0026gt;,$y,[$up$($up_rest)*],[$cell$right$($rest)*],[$down$($down_rest)*]}};($x: ty,$y: ty,[$up_left:tt$up:tt],[$left:tt$cell:tt],[$down_left:tt$down:tt])=\u0026gt;{gen_cell!{Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$cell,(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$y\u0026gt;,$up),(Cell\u0026lt;$crate::S\u0026lt;$crate::S\u0026lt;$x\u0026gt;\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,#),(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$crate::S\u0026lt;$y\u0026gt;\u0026gt;\u0026gt;,$down),(Cell\u0026lt;$x,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$left)}};($x: ty,$y: ty,[$up_left:tt$up:tt$($up_rest:tt)*],[$left:tt$cell:tt$right:tt$($rest:tt)*],@bottom)=\u0026gt;{gen_cell!{Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$cell,(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$y\u0026gt;,$up),(Cell\u0026lt;$crate::S\u0026lt;$crate::S\u0026lt;$x\u0026gt;\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$right),(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$crate::S\u0026lt;$y\u0026gt;\u0026gt;\u0026gt;,#),(Cell\u0026lt;$x,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$left)}gen_maze_row!{$crate::S\u0026lt;$x\u0026gt;,$y,[$up$($up_rest)*],[$cell$right$($rest)*],@bottom}};($x: ty,$y: ty,[$up_left:tt$up:tt],[$left:tt$cell:tt],@bottom)=\u0026gt;{gen_cell!{Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$cell,(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$y\u0026gt;,$up),(Cell\u0026lt;$crate::S\u0026lt;$crate::S\u0026lt;$x\u0026gt;\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,#),(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$crate::S\u0026lt;$y\u0026gt;\u0026gt;\u0026gt;,#),(Cell\u0026lt;$x,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$left)}};($x: ty,$y: ty,@top,[$left:tt$cell:tt$right:tt$($rest:tt)*],[$down_left:tt$down:tt$($down_rest:tt)*])=\u0026gt;{gen_cell!{Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$cell,(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$y\u0026gt;,#),(Cell\u0026lt;$crate::S\u0026lt;$crate::S\u0026lt;$x\u0026gt;\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$right),(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$crate::S\u0026lt;$y\u0026gt;\u0026gt;\u0026gt;,$down),(Cell\u0026lt;$x,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$left)}gen_maze_row!{$crate::S\u0026lt;$x\u0026gt;,$y,@top,[$cell$right$($rest)*],[$down$($down_rest)*]}};($x: ty,$y: ty,@top,[$left:tt$cell:tt],[$down_left:tt$down:tt])=\u0026gt;{gen_cell!{Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$cell,(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$y\u0026gt;,#),(Cell\u0026lt;$crate::S\u0026lt;$crate::S\u0026lt;$x\u0026gt;\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,#),(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$crate::S\u0026lt;$y\u0026gt;\u0026gt;\u0026gt;,$down),(Cell\u0026lt;$x,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$left)}};($x: ty,$y: ty,@top,[$left:tt$cell:tt$right:tt$($rest:tt)*],@bottom)=\u0026gt;{gen_cell!{Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$cell,(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$y\u0026gt;,#),(Cell\u0026lt;$crate::S\u0026lt;$crate::S\u0026lt;$x\u0026gt;\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$right),(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$crate::S\u0026lt;$y\u0026gt;\u0026gt;\u0026gt;,#),(Cell\u0026lt;$x,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$left)}gen_maze_row!{$crate::S\u0026lt;$x\u0026gt;,$y,@top,[$cell$right$($rest)*],@bottom}};($x: ty,$y: ty,@top,[$left:tt$cell:tt],@bottom)=\u0026gt;{gen_cell!{Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$cell,(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$y\u0026gt;,#),(Cell\u0026lt;$crate::S\u0026lt;$crate::S\u0026lt;$x\u0026gt;\u0026gt;,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,#),(Cell\u0026lt;$crate::S\u0026lt;$x\u0026gt;,$crate::S\u0026lt;$crate::S\u0026lt;$y\u0026gt;\u0026gt;\u0026gt;,#),(Cell\u0026lt;$x,$crate::S\u0026lt;$y\u0026gt;\u0026gt;,$left)}};}macro_rules!gen_maze{($x: ty,$y: ty,@top,[$($row:tt)*],[$($down:tt)*]$(,[$($rest:tt)*])*,@bottom)=\u0026gt;{gen_maze_row!{$x,$y,@top,[$($row)*],[$($down)*]}gen_maze!{$x,$crate::S\u0026lt;$y\u0026gt;,[$($row)*],[$($down)*]$(,[$($rest)*])*,@bottom}};($x: ty,$y: ty,[$($up:tt)*],[$($row:tt)*],[$($down:tt)*]$(,[$($rest:tt)*])*,@bottom)=\u0026gt;{gen_maze_row!{$x,$y,[$($up)*],[$($row)*],[$($down)*]}gen_maze!{$x,$crate::S\u0026lt;$y\u0026gt;,[$($row)*],[$($down)*]$(,[$($rest)*])*,@bottom}};($x: ty,$y: ty,[$($up:tt)*],[$($row:tt)*],@bottom)=\u0026gt;{gen_maze_row!{$x,$y,[$($up)*],[$($row)*],@bottom}};($x: ty,$y: ty,@top,[$($row:tt)*],@bottom)=\u0026gt;{gen_maze_row!{$x,$y,@top,[$($row)*],@bottom}};}macro_rules!maze{($name: ident,$([$($row:tt)*]),*)=\u0026gt;{pubstruct $name;pubtype Cell\u0026lt;X,Y\u0026gt;=$crate::Cell\u0026lt;$name,X,Y\u0026gt;;gen_maze!{$crate::Z,$crate::Z,@top$(,[#$($row)*])*,@bottom}};} blog/2018/12/15/rustdetsuyomenikatawotsukerupart_2__type_level_state_machine/ [return]  ","categories":["Rust","型"],"category_urls":["/categories/rust","/categories/%e5%9e%8b"],"date":"2019-10-06","title":"Rustで型レベル迷路","url":"https://KeenS.github.io/blog/2019/10/06/rustdekatareberumeiro/"},
  {"body":"κeenです。ブログタイトルが長い。 普段、どれがいいとか特に気にせず書いている「文字が特定の文字集合に含まれるか」の判定をするのはどの方法が速いかが気になったのでベンチマークを取ってみました。\n想定しているのは何かのパーサを書いていて、例えば識別子に使える文字が [a-zA-Z0-9_!?=\u0026lt;\u0026gt;] だったときにそれを判定する方法です。\n今回試すのは3種類。\n 文字集合を HashSet に入れて、 contains で判定する 文字集合を文字列(文字ベクトル)に入れて、 contains で判定する  contains の代わりに先に文字列をソートしておいて、 binary_search で探索する  char::is_alphanumeric などのメソッドを組み合わせる 正規表現を使う  教科書的な知識だと、 1. は $O(1)$ で文字集合の濃度に依らず高速に動作するはずです。 一方 2. は $O(n)$ なので文字集合の濃度に比例してしまい、分は悪そうです。 しかし実際には 2. が使われることが多いような気がします。 1. は多少複雑な計算が必要なので少し遅く、 2. は連続した要素の探索なので現代のCPUは得意な操作で有利なのかもしれません。 2.1. は教科書的には 2. より速そうですが、やはり 2. は連続した要素の探索なのでそちらが速い可能性もあります。 3. はどう考えても速いやつですが、 alphanumeric 以外の文字を c = '-' \u0026amp;\u0026amp; ... と繋ぐと分岐が多くなるのでもしかしたら不利かもしれません。 4. は一見遅そうですが、Rustの正規表現はかなりよく出来てるので実は速いかもしれません。\nそれではベンチマークを取ってみましょう。 線形探索が一番不利になるように、また、 alphanumeric にも引っ掛からないように、 \u0026lt; を対象に探索してみます。\nコードはこちら。 ベンチマークにはbencherを使っています。\n#[macro_use]externcratebencher;usebencher::Bencher;constCHAR: char =\u0026#39;\u0026gt;\u0026#39;;constCHARSET: \u0026amp;str =\u0026#34;abcdefghijklmnopqrstuvwxyz1234567890_!?=\u0026lt;\u0026gt;\u0026#34;;fn hashset(bench: \u0026amp;mutBencher){usestd::collections::HashSet;lethash=CHARSET.chars().collect::\u0026lt;HashSet\u0026lt;_\u0026gt;\u0026gt;();bench.iter(||hash.contains(\u0026amp;CHAR))}fn contains(bench: \u0026amp;mutBencher){// contains は str には使えないので Vec\u0026lt;char\u0026gt; を作る letvec=CHARSET.chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;();bench.iter(||vec.contains(\u0026amp;CHAR));}fn contains_binary_search(bench: \u0026amp;mutBencher){letmutvec=CHARSET.chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;();vec.sort();bench.iter(||vec.binary_search(\u0026amp;CHAR).is_ok());}fn is_alphanumeric(bench: \u0026amp;mutBencher){// 今回は小文字しか扱わないので `is_ascii_alphanumeric` は直接には使わない bench.iter(||{(CHAR.is_ascii_alphabetic()\u0026amp;\u0026amp;CHAR.is_ascii_lowercase())||CHAR.is_digit(10)||CHAR==\u0026#39;_\u0026#39;||CHAR==\u0026#39;!\u0026#39;||CHAR==\u0026#39;?\u0026#39;||CHAR==\u0026#39;=\u0026#39;||CHAR==\u0026#39;\u0026lt;\u0026#39;||CHAR==\u0026#39;\u0026gt;\u0026#39;});}fn regex(bench: \u0026amp;mutBencher){useregex::Regex;letregex=Regex::new(\u0026#34;[a-zA-Z0-9_!?=\u0026lt;\u0026gt;]\u0026#34;).unwrap();letc=CHAR.to_string();bench.iter(||regex.is_match(\u0026amp;c))}benchmark_group!(benches,hashset,contains,contains_binary_search,is_alphanumeric,regex);benchmark_main!(benches); 追記: コードを修正しました。 is_alphanumeric() よりも is_ascii_alphanumeric() などの方がこの場合適切なのでは (is_lowercase() と is_ascii_lowercase() も同様)\n\u0026mdash; らりお・ザ・何らかの🈗然㊌㋞㋰㋷㋓ (Mastodon に引っ越しました) (@lo48576) October 6, 2019 \n/追記\nHashSetや正規表現などは事前に準備してからベンチマークにかけています。\n実行結果は\ntest contains ... bench: 10 ns/iter (+/- 2) test contains_binary_search ... bench: 3 ns/iter (+/- 1) test hashset ... bench: 13 ns/iter (+/- 1) test is_alphanumeric ... bench: 0 ns/iter (+/- 0) test regex ... bench: 18 ns/iter (+/- 3)  と、 is_alphanumeric \u0026gt; binary search \u0026gt; contains \u0026gt; HashSet \u0026gt; 正規表現 の結果になりました。 まあ、全部ns単位なのであんまり意味ないんですけどね。\nということでシンプルに is_alphanumeric を使いましょう。\n参考  is_alphabetic の実装 今回のコード ","categories":["Rust","小ネタ"],"category_urls":["/categories/rust","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2019-10-06","title":"Rustで「文字が特定の文字集合に含まれるか」を判定するのはどれが速いか","url":"https://KeenS.github.io/blog/2019/10/06/rustde_mojigatokuteinomojishuugounifukumareruka_wohanteisurunohadoregahayaika/"},
  {"body":"# Idrisの話とIdris2のウワサ ---------------------- [Proof Summit 2019](https://proof-summit.connpass.com/event/141191/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # Idris ------- * Edwin Brady 2013 〜 * 証明支援系ではなくてプログラミング言語 * 依存型のあるHaskell * Eager Evaluation * コンパイルするとバイナリが出る + C経由 + JSバックエンドなども === # Hello, Idris -------------- ```idris main : IO () main = putStrLn \"Hello\" ``` --- ``` console $ idris -o hello hello.idr $ ./hello \"Hello\" ``` === # 依存型 --------------- * 値を型に書ける ```idris data Vect : (len : Nat) - (elem : Type) - Type where Nil : Vect Z elem (::) : (x : elem) - (xs : Vect len elem) - Vect (S len) elem ``` --- ```idris v : Vect 3 Int v = [1, 2, 3] ``` === # 依存型 --------------- * 型で計算がでる ```console append: Vect n a - Vect m a - Vect (n+m) a append [] y = y append (x :: xs) y = x :: append xs y ``` === # 依存型 --------------- * 値として型を書ける ```idris the : (a : Type) - a - a ``` --- ``` idris λΠ 1 1 : Integer ``` --- ``` idris λΠ the Double 1 1.0 : Double1 ``` === # 型と型の型 ------------ * `(a : Type)` って何 * `a` : 名前 + Idrisでは型シグネチャにも名前が書ける * `Type` : `a` の型 * `Type` 型の値 + `Int` + `Double` + `Vect 3 Int` + … === # 型と型の型 ------------ * `Type` の型は？ + → `Type 1` * `Type 0` (=`Type`), `Type 1` , `Type 2` … と続く + Idrisの文法上は `Type n` とは書けない * (Demo1.idr) === # 証明の話 ---------- * もちろんカリー・ハワード対応で証明が書ける + プログラミング言語と論理学に対応関係がある + 型 ⇔ 命題 + プログラム ⇔ 証明 + … * Idrisには依存型がある→述語論理の証明が書ける * 多少証明専用の機能もある === # Modus Ponens -------------- * $A \\to (A \\to B) \\to B$ * 大文字は定数扱いなのでカインド宣言 `{A, B: Type}` を挟んでおく ```idris total modusPonens : {A, B: Type} - A - (A - B) - B modusPonens a ab = ab a ``` === # `partial` と `total` ---------------------- * 一般にプログラムが停止するかは判定できない * Idrisは型にプログラムを書ける * → コンパイル終わるの？ * → 証明として見たときに循環論法になったりしないの？ ``` idris specialTheorem : {A, B: Type} - A - B specialTheorem x = specialTheorem x ``` === # `partial` と `total` ---------------------- * 関数に `partial` や `total` の修飾子を付けられる + デフォルトで `partial` * `total` を付けるとIdrisが停止すると確認できるものしかコンパイルが通らない === # `partial` と `total` ---------------------- ``` idris total specialTheorem : {A, B: Type} - A - B specialTheorem x = specialTheorem x ``` --- ```console | 21 | specialTheorem x = specialTheorem x | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Main.specialTheorem is possibly not total due to recursive path Main.specialTheorem -- Main.specialTheorem ``` === # `partial` と `total` ---------------------- * 再帰でもこっちは通る + 構造的に最初の引数が小さくなってるから ``` idris total append: Vect n a - Vect m a - Vect (n+m) a append [] y = y append (x :: xs) y = x :: append xs y ``` === # 型環境とHole -------------- * プログラムの一部を未完成のまま(=Hole)コンパイルできる * `?ident` でHoleを作れる ```idr map : List a - (a - b) - List b map xs f = ?hole ``` * IdrisがHoleの型を教えてくれる === # 型環境とHole -------------- ```idr map : List a - (a - b) - List b map xs f = ?hole ``` --- ```console b : Type a : Type xs : List a f : a - b -------------------- hole : List b ``` === # Type Driven Development ------------------- * Holeといくつかのコマンドを使うと型からプログラムを生成できる * プログラム⇔証明でいうと証明支援に対応 * 「型定義から本体の雛形を作る」 * 「引数でパターンマッチする」 * 「Holeをいい感じに埋める」 === # Type Driven Development ------------------- ```idris append : Vect n a - Vect m a - Vect (n + m) a ``` === # Type Driven Development ------------------- 型定義から本体の雛形を作る ```idris append : Vect n a - Vect m a - Vect (n + m) a append xs ys = ?append_rhs ``` === # Type Driven Development ------------------- 引数 `xy` でパターンマッチする ```idris append : Vect n a - Vect m a - Vect (n + m) a append [] ys = ?append_rhs_1 append (x :: xs) ys = ?append_rhs_2 ``` === # Type Driven Development ------------------- Hole `append_rhs_1` をいい感じに埋める ```idris append : Vect n a - Vect m a - Vect (n + m) a append [] ys = ys append (x :: xs) ys = ?append_rhs_2 ``` === # Type Driven Development ------------------- Hole `append_rhs_2` をいい感じに埋める ```idris append : Vect n a - Vect m a - Vect (n + m) a append [] ys = ys append (x :: xs) ys = x :: append xs ys ``` === # Dependent Pair ---------------- * 述語論理だから $\\forall$ と $\\exists$ が書きたいよね * $\\forall x \\in T, P(x)$ ⇔ `(x: T) - P x` + こっちは組み込みの機能 * $\\exists x \\in T, P(x)$ ⇔ `x: T ** P x` + こっちはユーザランドで定義 ```idris data DPair : (a : Type) - (P : a - Type) - Type where MkDPair : .{P : a - Type} - (x : a) - (pf : P x) - DPair a P ``` === # Dependent Pair ---------------- * ${}^\\exists n \\in \\mathbf{N} \\to$ `Vect n Int` ```idris someVect: (n: Nat ** Vect n Int) someVect = (_ ** [1, 2, 3]) ``` === # Dependent Pair ---------------- * 実用的(?)な例 * `filter` したあとの長さは分からないのでDPairを使う ```idris filter: (a - Bool) - Vect n a - (p ** Vect p a) filter p [] = (\\_ ** []) filter p (x :: xs) with (p x, filter p xs) filter p (x :: xs) | (True, (_ ** xs')) = (_ ** x :: xs') filter p (x :: xs) | (False, (_ ** xs')) = (_ ** xs') ``` === # Reification(?) ------------- * 型情報を実行時に取り出せる + やばいよね ```idris length : Vect n a - Nat length {n=n} _ = n ``` === # 証明っぽい証明 --------------- * 簡単な命題の書き方は分かった * もう少し証明らしい証明を書いてみる + 証明特有の書き方みたいなのがある === # 1 + 1 = 2 ------------ 命題 ```idris total onePlusOneEqualsTwo : 1 + 1 = 2 ``` === # 1 + 1 = 2 ------------ * コマンドだけで証明できる * `Refl` で `a = a` の証明 ``` total onePlusOneEqualsTwo : 1 + 1 = 2 onePlusOneEqualsTwo = Refl ``` === # 自然数 -------- * 自然数もデータ型で定義 + 1進数(`S` の数 = 数値) * 最適化で多倍長整数になるらしい ``` idris data Nat = ||| Zero Z | ||| Successor S Nat ``` --- ```idris three : 3 three = S (S (S Z)) ``` === # 足し算 -------- ``` idris total plus : (n, m : Nat) - Nat plus Z right = right plus (S left) right = S (plus left right) ``` === # n + m = m + n --------------- * ちょっと長い + いくつかの関数に分ける * いくつかの機能を使う + 依存型のパターンマッチができる + `rewrite  in ` で結果の型をrewriteできるよ + `%default total` で全部の関数を `total` に宣言できる === # n + m = m + n --------------- ## `0 + m = m + 0` ```idris %default total plus_commutes_Z : Z + m = m + Z plus_commutes_Z {m=Z} = Refl plus_commutes_Z {m=(S k)} = rewrite plus_commutes_Z {m=k} in Refl ``` === # n + m = m + n --------------- ## `n = n + 0` ```idris plus_reduces_Z: {n: Nat} - n = n + Z plus_reduces_Z {n=Z} = Refl plus_reduces_Z {n=(S k)} = rewrite plus_reduces_Z {n=k} in Refl ``` === # n + m = m + n --------------- ## `S (m + k) = m + (S k)` ```idris plus_commutes_S : S (plus m k) = plus m (S k) plus_commutes_S {k=k} {m=Z} = rewrite plus_reduces_Z {n=k} in Refl plus_commutes_S {k=k} {m=(S j)} = rewrite plus_commutes_S {k=k} {m=j} in Refl ``` === # n + m = m + n --------------- ```idris plus_commutes: {n, m: Nat} - n + m = m + n plus_commutes {n = Z} = plus_commutes_Z plus_commutes {n = (S k)} {m=m} = rewrite plus_commutes {n=k} {m=m} in plus_commutes_S ``` === # タクティックの話 ------------------ * いちおう、ある * 昔： Tacticというのがあった + 今はdeprecated * 今： Elaboration Reflectionがある + メタプログラミングっぽさ * どっちも正直つらい + ドキュメントほとんどない + エラーが分からない === # Elaboration -------------- ```idris modusPonens' : p - (p - q) - q modusPonens' = %runElab (do intro `{{Hp}} intro `{{Hpq}} apply (Var `{{Hpq}}) [False] solve hypothesis ) ``` === # Idris2のウワサ ------------ * Idris実装 * バックエンドはChez Scheme + Cバックエンドより速いらしい * Quantattive Type Theory + Linear Typeの拡張っぽい + 値が何回使えるかが型に付く * 正直まだ書けない + IDEプロトコルが未完成 === # 他の定理証明支援系との比較 --------------------- * Agda vs Idris: 違いが分からん + meta varやimplicit argumentsの扱いが違うらしい * Coq vs Idris: 言語が3つに分かれてない * Lean vs Idris: 違いが分からん * Haskell vs Idris: Idrisはトップレベルの型をユーザに書かせるのであんまり複雑にならないらしい * **Idrisはプログラミング言語** === # まとめ -------- * [コード](https://github.com/KeenS/proof-summit-demo) * 依存型の使えるプログラミング言語Idrisがあるよ * 命題と型、証明とプログラムは対応するよ * 依存型のある言語だと述語論理が証明できるよ   ","categories":["Idris","依存型"],"category_urls":["/categories/idris","/categories/%e4%be%9d%e5%ad%98%e5%9e%8b"],"date":"2019-09-21","title":"Idrisの話とIdris2のウワサ","url":"https://KeenS.github.io/slide/idrisnohanashitoidris2nouwasa/"},
  {"body":"κeenです。最近ちょくちょく標準ライブラリの Error とfailureライブラリの Fail が比べられる（というより Fail を推奨する）のが増えてきたようです。 個人的にちょっと気になってる点があって、みんなそれを抜きに議論してるようなので少しお話します。\nタイトルにあるとおり、ベンチマークの話なのでいきなりですがベンチマークを使いましょう。 Box\u0026lt;dyn Error\u0026gt; を作るコストと failureライブラリの Error を作るコストを比べます。 何故 Fail ではなくfailureの Error かというと Fail は少し込み入ったベストプラクティスがあり、コードが長くなるからです。 ベンチマーク的にはベストプラクティスを使った Fail とfailureの Error は変わらないと思います。ベストプラクティスについては以下を参照して下さい。\nrust のエラーライブラリは failure を使え！ - Qiita\nさて、ベンチマークにはbencherを使いましょう。\nCargo.toml\n[package] # .... [[bench]] name = \u0026#34;bench\u0026#34; harness = false [dependencies] failure = \u0026#34;0.1.5\u0026#34; [dev-dependencies] bencher = \u0026#34;0.1.5\u0026#34; benches/bench.rs\nusefailure::ErrorasFailureError;usestd::error::ErrorasStdError;usestd::fmt;// エラー型を準備 #[derive(Debug)]struct MyError;implfmt::DisplayforMyError{fn fmt(\u0026amp;self,f: \u0026amp;mutfmt::Formatter)-\u0026gt; fmt::Result{write!(f,\u0026#34;My Error\u0026#34;)}}implStdErrorforMyError{}// ベンチマークコード usebencher::{benchmark_group,benchmark_main,Bencher};fn bench_error(b: \u0026amp;mutBencher){b.iter(||-\u0026gt; Box\u0026lt;dynStdError\u0026gt;{Box::new(MyError)})}fn bench_fail(b: \u0026amp;mutBencher){b.iter(||-\u0026gt; FailureError{MyError.into()})}// セットアップ benchmark_group!(benches,bench_error,bench_fail);benchmark_main!(benches); シンプルに Box\u0026lt;dyn Error\u0026gt; と Error を作ります。 bencherは対象の実行速度を見てイテレーション回数を勝手に増やしてくれるので「何回実行したら有意な数値が取れるかな」とか考えなくてもよいのが利点です。\nこれをベンチマークしてみます。\n$ cargo bench running 2 tests test bench_error ... bench: 1 ns/iter (+/- 0) test bench_fail ... bench: 18 ns/iter (+/- 1) test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured  Box\u0026lt;dyn Error\u0026gt; が1ns（ナノ秒）、failureの Error が 18ns。 failureライブラリの方が18倍遅いという結果です。 単位が ns なので誤差ではと思うかもしれませんが右の括弧書きで書かれている測定誤差をみてもせいぜい1nsくらいです。\nこれ、どうしてか分かる方いますか？\nヒントというかほぼ答えですが追加のベンチマークを取ってみましょう。コールスタックの深いところでエラー値を作ってみます。\n// スタックを深くする関数 fn deep_stack_call\u0026lt;T\u0026gt;(n: u32,f: implFnOnce()-\u0026gt; T)-\u0026gt; T{ifn==0{f()}else{deep_stack_call(n-1,f)}}//コールスタックを100掘ってからエラー値を作る fn bench_error_stack(b: \u0026amp;mutBencher){b.iter(||-\u0026gt; Box\u0026lt;dynStdError\u0026gt;{deep_stack_call(100,||Box::new(MyError))})}fn bench_fail_stack(b: \u0026amp;mutBencher){b.iter(||-\u0026gt; FailureError{deep_stack_call(100,||MyError.into())})}benchmark_group!(deep_stack_bench,bench_error_stack,bench_fail_stack);benchmark_main!(deep_stack_bench); これを測ります。\n$ cargo bench running 2 tests test bench_error_stack ... bench: 1 ns/iter (+/- 0) test bench_fail_stack ... bench: 131 ns/iter (+/- 12) test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured  Box\u0026lt;dyn Error\u0026gt; が変わらず1ns（ナノ秒）、failureの Error が 131ns。failureの Error は7倍以上コストが上がってます。\nこのあたりでもうお分かりでしょうか。プロファイルまで取った訳ではないので多少推測ですが、failureの Error はバックトレースを取るのでその分のコストが乗るのです。\n実際、impl\u0026lt;F: Fail\u0026gt; From\u0026lt;F\u0026gt; for failure::Error の実装を辿っていくとこういうコードにいきつきます(failure 0.1.5)。\nimpl\u0026lt;F: Fail\u0026gt;From\u0026lt;F\u0026gt;forErrorImpl{fn from(failure: F)-\u0026gt; ErrorImpl{letinner: Inner\u0026lt;F\u0026gt;={letbacktrace=iffailure.backtrace().is_none(){Backtrace::new()}else{Backtrace::none()};Inner{failure,backtrace}};ErrorImpl{inner: Box::new(inner)}}} ここまでが測定結果のお話。ここから個人的な意見です。\nRustのコードはエラー値を作るのが軽いのを前提に作られているものがちょくちょくあります。 例えばバリデーションの結果を Result 型で返すだとか。これは例外ではなく値でエラーを表わすことの利点の1つだと思ってます。 そういう所でもfailureを使ってると意図しないパフォーマンスの劣化を招きかねません。 必要なところで使う分には全く問題ないのですが無闇矢鱈に使うのはいただけないなと思っています。\nもちろん、コストが掛かるといってもせいぜい100ns程度ですしスタックトレースが取れるメリットに比べたら大した問題ではないでしょう。 臆せず使って下さい。\n余談:\n 今回のコードはGitLabにあります bench_error_stack が bench_error とパフォーマンス変わらないのは末尾呼び出しの最適化が効いたか、インライン化されたんじゃないかと思いますが定かではないです。 bench_fail_stack と bench_fail のパフォーマンスが大きく異なるのはスタックトレースを取得している部分があるのでその手の最適化が効かなかったんじゃないかと思いますが定かではないです。 非常に個人的な話ですがバックトレースはそんなに好きじゃないです。どうせ見てもフレームワークのトレースが多かったりクロージャがあると問題の箇所とずれたりしてあんまり役に立たないので。その割にターミナルの画面を吹き飛ばして迷惑ですし。 ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2019-07-20","title":"RustのErrorとFailureのベンチマーク見たことある？","url":"https://KeenS.github.io/blog/2019/07/20/rustnoerrortofailurenobenchima_kumitakotoaru_/"},
  {"body":"κeenです。Rust 1.36.0がリリースされましたね。 ここで標準ライブラリにFutureが入ったので試しに実装してみます。\nRust 1.36.0ではFutureとそれに関連したいくつかのアイテムが安定化されました。 これは今までcrates.ioにあったfuturesのAPIとは異なるもので、 1.38.0 で安定化される予定の async / await 導入の布石になるものです。futuresと標準ライブラリのFutureの関係や async / await についてはここでは詳しく触れないので別の記事を参照して下さい。\n参考:\n Rustの未来いわゆるFuture - OPTiM TECH BLOG Rustのasync/awaitの特徴4つ - Qiita  何もしないFutureの実装 ひとまず Future のAPIを確認するために何もしない、ただ値を返すだけのFutureを作ってみましょう。 Future と関連する型は以下のように定義されています。\n// std::future pubtraitFuture{type Output;fn poll(self: Pin\u0026lt;\u0026amp;mutSelf\u0026gt;,cx: \u0026amp;mutContext)-\u0026gt; Poll\u0026lt;Self::Output\u0026gt;;}pubenum Poll\u0026lt;T\u0026gt;{Ready(T),Pending,} poll でFutureが準備できているか確認し、できていれば Ready を、 できていなければ Pending を返す仕組みです。 準備ができていなかった際は Context を使ってごにょごにょするのですが、今回は待たせないので一旦無視しましょう。\nところで self が Pin\u0026lt;\u0026amp;mut Self\u0026gt; になっていますね。 Pin はデータを移動できないことを示すデータ型です。 async / await を導入した際に起こる面倒事を回避するためにこうなっています。また、 Pin で包まれていてもデータを移動できることを表わす Unpin と呼ばれる自動トレイトもあります。\nPin のメソッドはいくつかあるのですが、さしあたって必要になるAPIを紹介しておきます。\n// std::pin pubstruct Pin\u0026lt;P\u0026gt;{/* fields omitted */}impl\u0026lt;T\u0026gt;From\u0026lt;Box\u0026lt;T\u0026gt;\u0026gt;forPin\u0026lt;Box\u0026lt;T\u0026gt;\u0026gt;whereT: ?Sized;impl\u0026lt;P\u0026gt;Pin\u0026lt;P\u0026gt;whereP: Deref,\u0026lt;PasDeref\u0026gt;::Target: Unpin,{pubfn new(pointer: P)-\u0026gt; Pin\u0026lt;P\u0026gt;}impl\u0026lt;P\u0026gt;Pin\u0026lt;P\u0026gt;wherewhereP: DerefMut,{pubfn get_mut(self)-\u0026gt; \u0026amp;\u0026#39;a mutTwhereT: Unpin;} 作るときは new 関連関数もあるのですが Box から into でも作れます（追記： もっと直接的な Box::pin というAPIもあるようです）。違いは T に Unpin を要求するかどうかです。\nさて、必要なAPIを確認したのでただ値を返すだけのFutureを実装してみましょう。\nusestd::future::Future;usestd::pin::Pin;usestd::task::{Context,Poll};pubstruct ReturnFuture\u0026lt;T\u0026gt;(Option\u0026lt;T\u0026gt;);impl\u0026lt;T\u0026gt;ReturnFuture\u0026lt;T\u0026gt;{pubfn new(t: T)-\u0026gt; Self{Self(Some(t))}}impl\u0026lt;T\u0026gt;FutureforReturnFuture\u0026lt;T\u0026gt;whereT: Unpin,{type Output=T;fn poll(self: Pin\u0026lt;\u0026amp;mutSelf\u0026gt;,_: \u0026amp;mutContext)-\u0026gt; Poll\u0026lt;Self::Output\u0026gt;{Poll::Ready(self.get_mut().0.take().expect(\u0026#34;A future should never be polled after it returns Ready\u0026#34;),)}} ほぼ値を保持して返すだけですが、 Option を使っています。これは \u0026amp;mut Self になっているので所有権をムーブできないからです。こういうときは Option\u0026lt;T\u0026gt; と Option::take でどうにかするイディオムが知られているのでそれを使います。\nここで、 Pin\u0026lt;\u0026amp;mut Self\u0026gt; から \u0026amp;mut Self を作るために Pin::get_mut を使っていて、さらにそのために T に Unpin を要求しています。分析してみると、 take で保持した値をムーブして返しているのでこれは必要な要求です。\n追記:\n記述に誤りがありました。\nReturnFutureはPin\u0026lt;\u0026amp;mut Self\u0026gt;からPin\u0026lt;\u0026amp;mut T\u0026gt;を構築しないので無条件にUnpinを実装します\n参考:https://t.co/q4CEqq9wzrhttps://t.co/EjHfwSj4nW\n\u0026mdash; 井山梃子歴史館 (@pandaman64) July 7, 2019 \nReturnFuture では T に Unpin を要求する必要はありませんでした。 ざっくりいうと内部にフィールドに Pin が必要なものが存在しないし、外部にフィールドが Pin されていることが要求されない（= \u0026lt;\u0026amp;mut Field\u0026gt; を作るようなAPIが存在しない）から、ってことで合ってるかな？ Unpin は自動トレイトですが、自分で実装を与えることもできますので、 T に Unpin を要求しないように手で実装するとこうなります。\npubstruct ReturnFuture\u0026lt;T\u0026gt;(Option\u0026lt;T\u0026gt;);impl\u0026lt;T\u0026gt;ReturnFuture\u0026lt;T\u0026gt;{pubfn new(t: T)-\u0026gt; Self{Self(Some(t))}}// Unpinを手で実装する impl\u0026lt;T\u0026gt;UnpinforReturnFuture\u0026lt;T\u0026gt;{}// 自動で導出される場合は以下のようにパラメータにも `Unpin` が要求される。今回はそれは不要だった。 // impl\u0026lt;T: Unpin\u0026gt; Unpin for ReturnFuture\u0026lt;T\u0026gt; {} // T: Unpinの制約がなくても実装できるようになった impl\u0026lt;T\u0026gt;FutureforReturnFuture\u0026lt;T\u0026gt;{type Output=T;fn poll(self: Pin\u0026lt;\u0026amp;mutSelf\u0026gt;,_: \u0026amp;mutContext)-\u0026gt; Poll\u0026lt;Self::Output\u0026gt;{Poll::Ready(self.get_mut().0.take().expect(\u0026#34;A future should never be polled after it returns Ready\u0026#34;),)}} 付録のコードも併せて更新しておきます。\n/追記\nところで Option::expect を呼んでいるのが気になりますね。 しかしメッセージにも書いているように、 Future は Poll::Ready を返したらそれ以上は poll が呼ばれない規約になっています (pollのドキュメントに書いてあります)。なのでここでは二度目が呼ばれたらパニックすることにしておきます。\n試しにこのFutureを使ってみましょう。\nfn main(){letmutfuture=ReturnFuture::new(42);// futureを実行する } 使おうと思いましたが、実行する手立てがありませんね。 poll を呼ぶにしても Context がありません。 仕方ないのでFutureのRunnerも作りましょう。\n工夫のないRunner ということでFutureを実行するために Context が必要なので Context のAPIを確認します。\n// std::task pubstruct Context\u0026lt;\u0026#39;a\u0026gt;{/* fields omitted */}impl\u0026lt;\u0026#39;a\u0026gt;Context\u0026lt;\u0026#39;a\u0026gt;{pubfn from_waker(waker: \u0026amp;\u0026#39;a Waker)-\u0026gt; Context\u0026lt;\u0026#39;a\u0026gt;;pubfn waker(\u0026amp;self)-\u0026gt; \u0026amp;\u0026#39;a Waker;} なんと Waker を準備しないと Context が作れません。では Waker を。\n// std::task pubstruct Waker{/* fields omitted */}implWaker{pubfn wake(self);pubfn wake_by_ref(\u0026amp;self);pubfn will_wake(\u0026amp;self,other: \u0026amp;Waker)-\u0026gt; bool;pubunsafefn from_raw(waker: RawWaker)-\u0026gt; Waker;} Waker はさらに RawWaker から作られます。では RawWaker を。\n// std::task pubstruct RawWaker{/* fields omitted */}implRawWaker{pubconstfn new(data: *const(),vtable: \u0026amp;\u0026#39;static RawWakerVTable)-\u0026gt; RawWaker;} RawWaker さらに RawWakerVTable から作られます。では RawWakerVTable を。\n// std::task pubstruct RawWakerVTable{/* fields omitted */}implRawWakerVTable{pubconstfn new(clone: unsafefn(*const())-\u0026gt; RawWaker,wake: unsafefn(*const()),wake_by_ref: unsafefn(*const()),drop: unsafefn(*const()))-\u0026gt; RawWakerVTable;} ここまできてようやく作れそうです。ですが unsafe や生ポインタが出てきて不穏ですね。 一旦ここまで出たデータ型を見返してみると、主な部分は RawWaker に渡す *const () と RawWakerVTable の組が担います。Waker はそのラッパで Context は将来 Waker 以外の機能も提供するために一枚噛ませてるんですかね？\n*const () と RawWakerVTable ですが、vtableという名前を知っている人には何なのか一目で分かるでしょう。\nvtableを知らない人に軽く説明します。Rustのメソッド呼び出しは何も特別なことをしない関数呼び出しです。 以下の3つの呼び出しは同じ挙動をします。\n// 1 data.clone()// 2 Clone::clone(\u0026amp;data)// 3 \u0026lt;DataasClone\u0026gt;::clone(\u0026amp;data) \u0026lt;Data as Clone\u0026gt;::clone はただの関数ですので、ざっくりいうと data へのポインタと clone 関数があれば clone メソッドを呼び出せるのです。普段はこの関数をコンパイラが適当なものを探索して呼出してくれているのです。 この 「data へのポインタ」 部分が *const () で、 「clone 関数」が RawWakerVTable に渡している clone です。 データ部分は普通なら \u0026amp;Data のように参照を使いますが、 Waker はジェネリクスになっていないので型を消すためにポインタにして () にキャストしているのでしょう。 具体的な型を消しつついくつかのメソッドを提供するのはやっていることは Box\u0026lt;dyn Trait\u0026gt; とあまり変わらないのですが（というか dyn Trait も上記と同じような仕組みで動いている）、 Box 部分を抽象化するためなのか Sized 制約の扱いの問題からなのか、それを分解したものすごく低レベルなAPIになっていますね。\nVTableに入っているメソッドは、 clone と drop は Waker の Clone と Drop で使われ、wake と wake_by_ref はそのままWaker の wake と wake_by_ref で使われるようです。\nこれで Waker の作り方が分かったので Context も作れて、 Runner も作れます。 Waker (Context) は実際は何もしないので先に Runner の方を作ります。 あまり褒められた実装ではないですが、Ready が返ってくるまでビジーループで poll し続けるRunner、 SpinRunner を実装します。\npubstruct SpinRunner;usestd::ops::{Deref,DerefMut};implSpinRunner{pubfn new()-\u0026gt; Self{Self}pubfn run\u0026lt;F\u0026gt;(\u0026amp;mutself,future: F)-\u0026gt; F::OutputwhereF: Future,{letmutfuture=Pin::from(Box::new(future));self.run_pin(future.as_mut())}pubfn run_pin\u0026lt;F\u0026gt;(\u0026amp;mutself,mutfuture: Pin\u0026lt;F\u0026gt;)-\u0026gt; \u0026lt;\u0026lt;FasDeref\u0026gt;::TargetasFuture\u0026gt;::OutputwhereF: DerefMut,\u0026lt;FasDeref\u0026gt;::Target: Future,{letwaker=SpinWaker::waker();letmutcx=Context::from_waker(\u0026amp;waker);// loopでpollするだけ loop{matchfuture.as_mut().poll(\u0026amp;mutcx){Poll::Ready(ret)=\u0026gt;{returnret;}Poll::Pending=\u0026gt;continue,}}}} ここではwaker から cx を作ってはいますがそのあと Future に渡すだけで何もしていませんね。 ということで何もしない Waker を作りましょう。\nusestd::task::{RawWaker,RawWakerVTable,Waker};#[derive(Debug, Clone)]struct SpinWaker;staticSPIN_WAKER_VTABLE: RawWakerVTable=RawWakerVTable::new(SpinWaker::unsafe_clone,SpinWaker::unsafe_wake,SpinWaker::unsafe_wake_by_ref,SpinWaker::unsafe_drop,);implSpinWaker{fn waker()-\u0026gt; Waker{// this is safe because waker\u0026#39;s data and vtable is consistent unsafe{Waker::from_raw(Self::new().into_raw_waker())}}fn new()-\u0026gt; Self{Self}unsafefn into_raw_waker(self)-\u0026gt; RawWaker{letptr=Box::into_raw(Box::new(self))as*const();RawWaker::new(ptr,\u0026amp;SPIN_WAKER_VTABLE)}unsafefn unsafe_clone(this: *const())-\u0026gt; RawWaker{letptr=thisas*constSelf;Box::new(ptr.as_ref().unwrap().clone()).into_raw_waker()}fn wake(self: Self){}unsafefn unsafe_wake(this: *const()){letptr=thisas*mutSelf;Box::from_raw(ptr).wake()}fn wake_by_ref(\u0026amp;self){Box::new(self.clone()).wake()}unsafefn unsafe_wake_by_ref(this: *const()){letptr=thisas*constSelf;ptr.as_ref().unwrap().wake_by_ref()}unsafefn unsafe_drop(this: *const()){letptr=thisas*mutSelf;Box::from_raw(ptr);}} *const () の部分は Box::into_raw で作っています。 これは unsafe_drop の Box::from_raw で復元し、Rustに開放させています。 実は今回の SpinWaker はデータを持たないので Box を使わなくてもNULLポインタでも差し支えないのですが例示として Box のポインタを使っています。\nwake_by_ref は clone を使う実装にしておきます。 wake は何もしないメソッドとして定義します。 unsafe_* 関数は主には *const () から Self を復元する役目を負います。 全て同じ *const () ですが、実際は呼出した側からすると \u0026amp;self のつもりだったり Box\u0026lt;Self\u0026gt; のつもりだったりするので適切に状況判断をして Self を復元しましょう。\nこれで役者が揃ったので Future を実行してみましょう。\nfn main(){letmutrunner=SpinRunner::new();letfuture=ReturnFuture::new(42);letret=runner.run(future);println!(\u0026#34;answer is {}\u0026#34;,ret);}answer is 42  結果を取り出せました。 しかしビジーループで実装されています。 今扱っているFutureはすぐに返りますが全てがそうではありません。 これでは結果が出てくるまでCPUを使いっきりですね。 それに、 poll を何度も呼ぶと結果の確認にコストのかかるFutureだったらFutureの計算自体も遅くなりかねません。\n結果が出てくるまでは休むようにできないでしょうか。 これは Waker をちゃんと実装してあげるとできるようになります。 そのために、もう少しまともな Runnerを実装しましょう。\n工夫のあるRunner 条件を満たすまで待つには、channelを使う方法もありますがここでは条件変数を使ってみましょう。\n条件変数（Condvar） はロックと組で使います。\n待つ側は以下のように、ロックに対してそれが通知されるのを Condvar::wait で待ちます。\nletlock=mutex.lock().unwrap();condvar.wait(lock).unwrap(); 通知する側は適当に Condvar::notify_all などを呼びます。\ncondvar.notify_all(); これを使って Future を poll して Poll::Pending なら wait する Runnerを書いてみましょう。\nusestd::sync::{Arc,Mutex,Condvar};struct CondRunner(Arc\u0026lt;(Mutex\u0026lt;()\u0026gt;,Condvar)\u0026gt;);implCondRunner{// 略 pubfn run_pin\u0026lt;F\u0026gt;(\u0026amp;mutself,mutfuture: Pin\u0026lt;F\u0026gt;)-\u0026gt; \u0026lt;\u0026lt;FasDeref\u0026gt;::TargetasFuture\u0026gt;::OutputwhereF: DerefMut,\u0026lt;FasDeref\u0026gt;::Target: Future,{letwaker=CondWaker::waker(self.0.clone());letmutcx=Context::from_waker(\u0026amp;waker);loop{matchfuture.as_mut().poll(\u0026amp;mutcx){Poll::Ready(ret)=\u0026gt;{returnret;}Poll::Pending=\u0026gt;{// 一回pollしてまだだったら条件変数の通知を待つ letlock=(self.0).0.lock().unwrap();*(self.0).1.wait(lock).unwrap();// 条件が通知されたら再度pollする }};}}} ビジーループに Condvar::wait が足されました。 Mutex は実際にはデータを使ってないので () を持たせています。 wait したあとに poll したら結果が返ってくることが保証されてもよさそうな気がしますが、Futureの計算が多段階に分かれる場合などは wake のあとにさらに計算があることもあるので結果が返ってくるとは限りません。\nこれに対応する Waker を作ります。 今度は Runner と Waker でデータを共有するので Box ではなく Arc を使います。\n#[derive(Debug)]struct CondWaker(Arc\u0026lt;(Mutex\u0026lt;()\u0026gt;,Condvar)\u0026gt;); 先程は Box\u0026lt;SpinWaker\u0026gt; と外側でポインタを扱ってましたが今度は CondWaker の中にポインタ型があるので混乱しないで下さいね。\nそれでは CondWaker を実装していきます。\nstaticCOND_WAKER_VTABLE: RawWakerVTable=RawWakerVTable::new(CondWaker::unsafe_clone,CondWaker::unsafe_wake,CondWaker::unsafe_wake_by_ref,CondWaker::unsafe_drop,);implCondWaker{fn waker(inner: Arc\u0026lt;(Mutex\u0026lt;()\u0026gt;,Condvar)\u0026gt;)-\u0026gt; Waker{// this is safe because waker\u0026#39;s data and vtable is consistent unsafe{Waker::from_raw(Box::new(Self::new(inner)).into_raw_waker())}}fn new(inner: Arc\u0026lt;(Mutex\u0026lt;()\u0026gt;,Condvar)\u0026gt;)-\u0026gt; Self{Self(inner)}unsafefn into_raw_waker(self)-\u0026gt; RawWaker{letptr=Arc::into_raw(self.0)as*const();RawWaker::new(ptr,\u0026amp;COND_WAKER_VTABLE)}unsafefn unsafe_clone(this: *const())-\u0026gt; RawWaker{letptr=thisas*const(Mutex\u0026lt;()\u0026gt;,Condvar);letarc=Arc::from_raw(ptr);letret=Self::new(arc.clone()).into_raw_waker();std::mem::forget(arc);ret}fn wake(self){(self.0).1.notify_all()}unsafefn unsafe_wake(this: *const()){letptr=thisas*const(Mutex\u0026lt;()\u0026gt;,Condvar);Self::new(Arc::from_raw(ptr)).wake()}unsafefn unsafe_wake_by_ref(this: *const()){letptr=thisas*const(Mutex\u0026lt;()\u0026gt;,Condvar);letarc=Arc::from_raw(ptr);letret=Self::new(arc.clone());std::mem::forget(arc);ret.wake()}unsafefn unsafe_drop(this: *const()){letptr=thisas*const(Mutex\u0026lt;()\u0026gt;,Condvar);Self::new(Arc::from_raw(ptr));}} いくつか目立ったところを解説します。 まず、 wake で notify_all を呼んでいますね。 ポインタの操作は Arc にも from_raw と into_raw があるので SpinRunner のときとさほど変わりません。 唯一違うのは unsafe_clone です。 SpinRunner と違って Mutex などは clone できないので Arc の clone を呼びます。 そのために一旦ポインタから Arc を復元するのですがそのままにすると drop が走ってデクリメント、開放されてしまうので forget で drop が走らないようにしています。\nさて、このRunnerを使ってみましょう。\nfn main(){letmutrunner=CondRunner::new();letfuture=ReturnFuture::new(42);letret=runner.run(future);println!(\u0026#34;answer is {}\u0026#34;,ret);}answer is 42  計算できました。 しかし思い出すと ReturnFuture は Context を呼び出さなかったので条件変数は使われていませんね。 これでは正しく実装できているか分かりません。 ちゃんと別スレッドで計算して Context も使うFutureを作りましょう。\nスレッドを使うFuture Waker を使う例を見るためにスレッドを使うFutureを作ります。今回は結果のやりとりにchannelを使いましょう。 Wakerは計算スレッドと呼び出し側で共有するので Arc\u0026lt;Mutex\u0026lt;_\u0026gt;\u0026gt; を使います。 さらに poll されるまでは Waker は存在しないので Option\u0026lt;_\u0026gt; に包まれます。\nusestd::sync::mpsc::{channel,Receiver};usestd::thread;pubstruct ThreadFuture\u0026lt;T\u0026gt;{rx: Receiver\u0026lt;T\u0026gt;,waker: Arc\u0026lt;Mutex\u0026lt;Option\u0026lt;Waker\u0026gt;\u0026gt;\u0026gt;,} このFutureの開始でスレッドをスタートします。\nimpl\u0026lt;T\u0026gt;ThreadFuture\u0026lt;T\u0026gt;whereT: Send +\u0026#39;static,{pubfn start\u0026lt;F\u0026gt;(f: F)-\u0026gt; SelfwhereF: FnOnce()-\u0026gt; T+Send+\u0026#39;static,{let(tx,rx)=channel();letwaker=Arc::new(Mutex::new(None::\u0026lt;Waker\u0026gt;));letw=waker.clone();thread::spawn(move||{tx.send(f()).unwrap();ifletSome(waker)=\u0026amp;*w.lock().unwrap(){waker.wake_by_ref()}});Self{rx,waker}}} スレッドの中身は f の計算結果をチャネルに突っ込んだら waker を使って計算が終わったことを通知します。 waker がなかったときか気になるかもしれませんが、そのときはまだ poll が呼ばれていないので特に wake を呼ぶ必要はありません。\nこれのFuture側の実装はこうです。\nimpl\u0026lt;T\u0026gt;FutureforThreadFuture\u0026lt;T\u0026gt;whereT: Send +Sync+\u0026#39;static,{type Output=T;fn poll(mutself: Pin\u0026lt;\u0026amp;mutSelf\u0026gt;,cx: \u0026amp;mutContext)-\u0026gt; Poll\u0026lt;Self::Output\u0026gt;{*self.waker.lock().unwrap()=Some(cx.waker().clone());matchself.rx.try_recv(){Ok(t)=\u0026gt;Poll::Ready(t),Err(_)=\u0026gt;Poll::Pending,}}} 受け取った Waker をスレッドに共有してから try_recv を呼びます。 Waker は何度も poll が呼ばれた場合は最新の Waker を使って wake する規約なので呼ばれる度に上書きます。 try_recv はブロックせず、 Ok が返れば値が準備できていて、 Err なら値は（まだ）ありません。\n因みにスレッドのチャネルに send して waker の確認、Futureの waker をセットしてから try_recv の順番は重要です。これが逆だと二度と poll されない場合が出てきます。具体的には以下のようなトレースです。\nfutureがpollしてからwakerをsetする場合:\n [Future]: pollされたので try_recv する。まだ値がない [スレッド]: 計算が終わったので値を send する [スレッド]: waker を取り出そうとするが、まだない。これでスレッドは終了する [Future]: waker をセットし、 Pending を返す。wake が呼ばれるまで poll は呼ばれない  スレッドがwakeしてから計算をsendする場合:\n [スレッド]: 計算が終わったので waker を取り出そうとするがまだない。スルーする [Future]: pollされたので waker をセットする [Future]: try_recv する。まだ値はないので Pending を返す。wake が呼ばれるまで poll は呼ばれない [スレッド]: チャネルに値を send する。これでスレッドは終了する  どちらの場合もタイミングによってはFutureが Pending を返したあとに wake が呼ばれないままスレッドが終了しており、このまま poll が呼ばれないようなトレースが存在します。注意しましょう。\nさて、これを使ってみましょう。適当なワークロードとして fib 関数を置いておきます。\nfn fib(n: u64)-\u0026gt; u64 {ifn\u0026lt;2{1}else{fib(n-1)+fib(n-2)}} それでは走らせてみます。\nfn main(){letmutrunner=CondRunner::new();letfuture=ThreadFuture::start(||fib(42));letret=runner.run(future);println!(\u0026#34;answer is {}\u0026#34;,ret);}answer is 433494437  ひとまず走ることは確認しました。でも、ちゃんとwaitできてるか不安ですよね。 Runnerをすこし弄ってpoll した回数を測ってみましょう。 2つのRunnerのループの部分でカウンタを設け、 poll で Poll::Ready が返ったときにカウンタを表示してみましょう。\nfn run_pin(...)// ... letmuti=0;loop{i+=1;matchfuture.as_mut().poll(\u0026amp;mutcx){Poll::Ready(ret)=\u0026gt;{println!(\u0026#34;{}\u0026#34;,i);returnret;},// ... }// .... }} 2つとも書き換えたら走らせてみます。\nfn main(){letmutrunner=CondRunner::new();letfuture=ThreadFuture::start(||fib(42));println!(\u0026#34;cond runner\u0026#34;);letret=runner.run(future);println!(\u0026#34;answer is {}\u0026#34;,ret);letmutrunner=SpinRunner::new();letfuture=ThreadFuture::start(||fib(42));println!(\u0026#34;spin runner\u0026#34;);letret=runner.run(future);println!(\u0026#34;answer is {}\u0026#34;,ret);}cond runner 2 answer is 433494437 spin runner 49128182 answer is 433494437  はい、 CondRunner は2回しか poll してませんが SpinRunner は 49,128,182 回 poll したようです。ちゃんと wait できてますね。めでたしめでたし。\nまとめ 単純なFutureとスレッドを使うFuture、単純なRunnerと同期プリミティブを使ったRunnerを実装してみました。 その過程で、関連するデータ型の使い方も示しました。\n今回作ったFutureとRunnerはどちらも単純なものでしたので、実際はもう少し複雑なものになるでしょう。 Futureはスレッドを使うにしてもスレッドプールを用意した方が効率的でしょうし、IO待ちの場合は select や poll 、 epoll 、 kqueue などのシステムコールを使うケースが多いでしょう。 Runnerも今回は1度に1 Futureだけ扱いましたが複数のFutureをまとめて処理できた方がよさそうです。 そうするとFutureのpollのスケジューラを実装することになるでしょう。\n今回は複数のFutureを組み合わせるFutureは作りませんでした。 2つともの結果を待ってそのタプルを返す join(f1, f2) やどちらか早い方の結果を返すchoice(f1, f2) 、 1つの結果を受けてさらにFutureの計算をする and_then(f1,|ret| f2(ret)) などを実装してみると理解が深まるかもしれません。\n付録 ソースコード全文\n","categories":["Rust","Future"],"category_urls":["/categories/rust","/categories/future"],"date":"2019-07-07","title":"RustのFutureとそのRunnerを作ってみた","url":"https://KeenS.github.io/blog/2019/07/07/rustnofuturetosonorunnerwotsukuttemita/"},
  {"body":"日夜CPSに励む紳士淑女のみなさなまこんにちは、κeenです。CPS変換について掘り返してたら発散していったので適当に書き留めておきます。 主に自分向けのメモで、あとで思い出すために書いてるので私自身以外には分かりづらいと思います。\nCPS 最初はcall-by-nameをcall-by-valueでエミュレーションするために導入されたっぽい。\nPlotkin, G. D. \u0026ldquo;Call-by-name, call-by-value, and the λ-calculus,\u0026rdquo; Theoretical Computer Science, Vol. 1, No. 2,pp. 125–159 (December 1975).\n変換規則は以下。\n\\[ \\begin{align} [x] \u0026amp;= \\lambda\\kappa.\\kappa x \\\\\n[\\lambda x.M] \u0026amp;= \\lambda\\kappa.\\kappa (\\lambda{}x.[M]) \\\\\n[M N] \u0026amp;= \\lambda\\kappa[M] (\\lambda{}m.[N] (\\lambda{}n.(m n) \\kappa)) \\end{align} \\]\n存外シンプル。CPSと呼ばれだしたのはSchemeのRabbitコンパイラ（Steele Jr., G. L. 1978）からっぽい？\nただしこれは動くだけで便利じゃない。例えば以下のような式を考える。\n\\[ \\lambda{}f.\\lambda{}x.\\lambda{}y.(f y) x \\]\nこれをCPSすると以下のようになる。\n\\[ \\lambda\\kappa.\\kappa (\\lambda{}f.\\lambda\\kappa.k (\\lambda{}x.\\lambda\\kappa.k(\\lambda{}y.\\lambda\\kappa.(\\lambda\\kappa.(\\lambda\\kappa.\\kappa f)(\\lambda{}m.(\\lambda\\kappa.k y)(\\lambda{}n.(m n)\\kappa))) (\\lambda{}m.(\\lambda\\kappa.\\kappa x)(lambda{}n.(m n) \\kappa))))) \\]\nこれには簡約基(redex)があるので簡約するとこうなる（post-reduction）。\n\\[ \\lambda\\kappa.\\kappa (\\lambda{}f.\\lambda\\kappa.k (\\lambda{}x.\\lambda\\kappa.k(\\lambda{}y.\\lambda\\kappa.(f y)(\\lambda{}m.(m x) k)))) \\]\nこれで変換したものが得られたが、途中で簡約を挟んでいる。今回は元の式に簡約基がなかったがもし簡約基を持つ式をCPSするとpost-reductionで元の式の簡約基まで潰れてしまう。\nこれでは困るのでCPSに工夫を加える。 CPSの結果として残る項と変換処理の都合上導入された項を区別する。 それが\nDanvy, O and Filinski, A. \u0026ldquo;Representing contril: a study of the CPS transformation,\u0026rdquo; Math. Struct. in Comp. Science (1992), vol. 2, pp. 361-391.\n関数適用にもアノテーションが必要なため、記法の都合で適用に $@$ 印を付けることにすると、こういうような規則になる。\n\\[ \\begin{align} [x] \u0026amp;= \\overline{\\lambda}\\kappa.\\overline{@}\\kappa x \\\\\n[\\lambda{}x.M] \u0026amp;= \\overline{\\lambda}\\kappa.\\overline{@}\\kappa (\\underline{\\lambda}x.\\underline{\\lambda}\\kappa.\\overline{@}[M] (\\overline{\\lambda}m.\\underline{@}\\kappa m)) \\\\\n[@M N] \u0026amp;= \\overline{\\lambda}\\kappa.\\overline{@}[M] (\\overline{\\lambda}m.\\overline{@}[N] (\\overline{\\lambda}n.\\underline{@}(\\underline{@}m n) (\\underline{\\lambda}a.\\overline{@}\\kappa a))) \\end{align} \\]\n上線がstaticな項で、CPS変換中に簡約してよい。下線がdynamicな項で、CPS変換後も残らないといけない。\nというのが基本。\n理論的なCPS変換としては上記でいいが、実用上はやっぱり不便、というか遅い。 $\\lambda$ 抽象が多すぎる。 そもそもなんのためにCPS変換するの、というのを考えないといけないが自分の場合は call/cc や shift / reset を実装したいから。 となると継続が必要になる式だけCPSしたら速いんじゃねというのがSelective CPS。\n色々な切り口から色々な手法が出てるけどこれ出しとけばいいのかな。\nNielsen, L.R. \u0026ldquo;A Selective CPS Transformation,\u0026rdquo; Electronic Notes in Theoretical Computer Science 45 (2001)\nこれはeffect分析を用いて変換する。 雑にいうと callcc や throw を内包する式を内側から順にマークしていって、マークのついている式だけを変換する。 多分みんなの思ってる通りのやつ。\nあとは型主導だと浅井研のこれが好き。\nAsai, K. and Uehara, C. \u0026ldquo;Selective CPS transformation for shift and reset,\u0026rdquo; PEPM \u0026lsquo;18 Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation Pages 40-52 (2018)\n型主導なのでShift/Resetに型が付く言語という縛りが出るけどやっぱ型主導翻訳って楽しいよね。\n型 あんまり型には興味ない。浅井先生の printf が有名。\nAsai, K. \u0026ldquo;On Typing Delimited Continuations: Three New Solutions to the Printf Problem,\u0026rdquo; Higher-Order and Symbolic Computation, Vol. 22, No. 3, pp. 275-291, Springer (2009).\nこれはCPSとか型付けとかShift/ResetとかAnswer Typeとかを丁寧に解説してるのでオススメ。\n元はDanvyがCPSで書いたコードだけどそれを限定継続で再実装してみるとFilinskiのshift/resetの実装で型チェック通らないという話。 俎上に上がってる (s)printf は以下のように使う。\n(* string *) sprintf (lit \u0026#34;Hello world!\u0026#34; ++ eol) (* -\u0026gt; \u0026#34;Hello world!\\n\u0026#34; *) (* string -\u0026gt; string *) sprintf (lit \u0026#34;Hello \u0026#34; ++ % str ++ lit \u0026#34;!\u0026#34; ++ eol) (* string *) sprintf (lit \u0026#34;Hello \u0026#34; ++ % str ++ lit \u0026#34;!\u0026#34; ++ eol) \u0026#34;world\u0026#34; (* -\u0026gt; \u0026#34;Hello world!\\n\u0026#34; *) (* string -\u0026gt; int -\u0026gt; string *) sprintf (lit \u0026#34;The value of \u0026#34; ++ % str ++ lit \u0026#34; is \u0026#34; ++ % int ++ eol) (* string *) sprintf (lit \u0026#34;The value of \u0026#34; ++ % str ++ lit \u0026#34; is \u0026#34; ++ % int ++ eol) \u0026#34;x\u0026#34; 3 (* -\u0026gt; \u0026#34;The value of x is 3\\n\u0026#34; *) 見てのとおり引数に応じて型が変わる仕組みになってる。\n元々はCPSだけど少し複雑なのでshift/resetで再実装したものだけ載せるとこう。 全体的にパターンは文字列を受け取って文字列を返す関数になってる。\n(* lit : string -\u0026gt; string -\u0026gt; string *) let lit x = fun s -\u0026gt; s ^ x (* eol : string -\u0026gt; string *) let eol = fun s -\u0026gt; s ^ \u0026#34;\\n\u0026#34; (* (++) : (’a -\u0026gt; ’b) -\u0026gt; (’b -\u0026gt; ’c) -\u0026gt; ’a -\u0026gt; ’c *) let (++) f1 f2 = fun s -\u0026gt; f2 (f1 s) (* int : int -\u0026gt; string *) let int x = string_of_int x (* str : string -\u0026gt; string *) let str (x : string) = x (* ??? *) let % to_str = fun s -\u0026gt; shift (fun k -\u0026gt; fun x -\u0026gt; k (s ^ to_str x)) (* ??? *) let sprintf p = reset (fun () -\u0026gt; p \u0026#34;\u0026#34;) % が一旦継続を破棄して reset まで返り、必要な引数を受け取ってから継続を再起動する設計。 素直に k をtail callしていないのがポイントで、このせいで型付けが難しくなっている。\n% と reset の型は一旦棚上げしておいて、もし動的型付言語などで実行すると以下のように簡約が進む。\nsprintf (lit \u0026#34;Hello \u0026#34; ++ % str ++ lit \u0026#34;!\u0026#34; ++ eol) → reset (fun () -\u0026gt; (lit \u0026#34;Hello \u0026#34; ++ % str ++ lit \u0026#34;!\u0026#34; ++ eol) \u0026#34;\u0026#34;) → reset (fun () -\u0026gt; eol (lit \u0026#34;!\u0026#34; (% str (lit \u0026#34;Hello \u0026#34; \u0026#34;\u0026#34;)))) → reset (fun () -\u0026gt; eol (lit \u0026#34;!\u0026#34; (% str \u0026#34;Hello \u0026#34;))) → fun x -\u0026gt; reset (fun () -\u0026gt; eol (lit \u0026#34;!\u0026#34; (\u0026#34;Hello \u0026#34; ^ str x))) パッと見 lit とか使ってるので string が出てきそうなbodyから fun x -\u0026gt; ... が出てきちゃいました、というのが型の問題。\nここで一旦Answer Typeが出てくる。Answer Typeは初期継続の返り値型で、要するに reset の返り値の型になる。 Answer Typeの概念を用いてCPSを説明すると、直接形式のプログラム S -\u0026gt; T をCPS変換すると (T -\u0026gt; Ans) -\u0026gt; S -\u0026gt; Ans になる。対偶っぽい見た目。\n直接形式のプログラムだけならそれでいいのだが、 shift が出てくると話がややこしくなる。 先の例のように、元々 string 型が出てくる予定だった reset から fun x -\u0026gt; ... が出てきた訳で、 shift を呼ぶとAnswer Typeが変化することが分かる。 Filinskiのshift/resetの実装はこのAnswer Type Modificationをサポートしていなかったので問題が起きた。\n元々のshift/resetの理論ははAnswer Type Modificacionをサポートしていたらしい。 S -\u0026gt; T をCPSすると (T -\u0026gt; A) -\u0026gt; S -\u0026gt; A になっていたが、Answer Typeが変わりうることを考慮すると (T -\u0026gt; A) -\u0026gt; S -\u0026gt; B になる。 これを shift / reset の体系で（陽に継続を扱わない体系で） 表現しようとするとAnswer Type Modificationをする関数は S/A -\u0026gt; T/B と表記することになる。 shift を呼ばないpureな関数はAnswer Typeに影響がないので S/'p -\u0026gt; T/'p と型が付く。\nこれを導入すると % に型が付く。\n(* % : (’b -\u0026gt; string) -\u0026gt; (string / ’a -\u0026gt; string / (’b -\u0026gt; ’a)) *) let % to_str = fun s -\u0026gt; shift (fun k -\u0026gt; fun x -\u0026gt; k (s ^ to_str x)) answer typeが 'a から 'b -\u0026gt; 'a に変わっているのが分かる。\n同様に sprintf にも型が付く。\n(* sprintf : (string / string -\u0026gt; string / ’a) -\u0026gt; ’a *) let sprintf p = reset (fun () -\u0026gt; p \u0026#34;\u0026#34;) ちゃんと「string が出てきそうな body から fun x -\u0026gt; ... ('a) が出てきちゃった」が表現されている。\n計算体系 初期の $\\lambda_v-C$ とかもあるっぽいけどよく分かんないのでSLCから。 浅井先生のスライドが分かりやすい。\nA Reinvestigation of Filinski’s Symmetric Lambda Calculus PDF\nFilinskiの論文はこれ。\nFilinski, A. \u0026ldquo;Declarative Continuations and Categorical Duality,\u0026rdquo; Master\u0026rsquo;s thesis, DIKU Report89/11, University of Copenhagen (1989).\nSymmetric Lambda Calculsは「継続って値の双対だよね」という話から始まる（あとcall-by-valueとcall-by-nameも双対）。 なので継続も値と同じように第一級に扱える計算体系になっている。 関数も値 A を 値 B に変換する A -\u0026gt; B と B の継続を A の継続に変換する ¬A \u0026lt;- ¬B がある。\nSLCが何故そのまま研究されなかったかは知らないけど（見た目がキモいから？）、そのあと $\\lambda$ 計算に call/cc を入れた $\\lambda\\mu$ 計算が登場した。\nParigot, M. \u0026ldquo;λμ-calculus: An Algorithmic Interpretation of Classical Natural Deduction,\u0026ldquo;\u0026rdquo; In A.Voronkov, editor,Logic Programming and Automated Reasoning (LNCS 624), pp. 190–201 (1992).\nこれ、Classical Natural Deductionといってシーケント計算が使われてるんですがそういうもんですかね（注意書きでProofs of usual natural deduction are easely translated in this systemとは書かれている）。 $\\lambda\\mu$ 計算は自然演繹。\nさらにその後計算に対称性を持たせて自然演繹ではなくLKのシーケント計算に対応させた $\\overline{\\lambda}\\mu\\tilde\\mu$ (ラムダ・バー・ミュー・ミュー・チルダ) 計算が出た。\nCurien, P.-L., and H. Herbelin \u0026ldquo;The Duality of Computation,\u0026rdquo; Proceedings of the ACM SIGPLANInternational Conference on Functional Programming (ICFP\u0026rsquo;00), pp. 233–243 (2000).\nこれは読みやすいのでおすすめ。ただしシーケント計算を知ってないと文脈が分かりづらい。 $\\overline{\\lambda}$ になるとシーケント計算になって、それに $\\mu$ と $\\tilde\\mu$ を加えたっぽい？ $\\tilde\\mu$ はcall-by-nameの上でcall-by-valueをするための演算子で、 $\\mu$ の双対になる。実質 let。\n以下が $\\overline{\\lambda}\\mu\\tilde\\mu$ の構文。\n\\[ \\begin{align} c \u0026amp;::= \\langle{}v|e\\rangle \\\\\nv \u0026amp;::= x ‖ \\mu\\beta.c ‖ \\lambda{}x.v \\\\\ne \u0026amp;::= \\alpha ‖ \\tilde\\mu{}x.c ‖ v\\cdot{}e \\\\\n\\end{align} \\]\n普通の $\\lambda$ 計算に慣れてると戸惑うが、値に継続（評価文脈）を当て嵌めるとそれはコマンドになる。 $\\mu$ が継続を受け取ってコマンドを返す項で、 $\\tilde\\mu$ が値を受け取ってコマンドを返す項。 $\\lambda{}x.v$ は何かしらの値を受け取りある値を返す項で、 $v\\cdot{}e$ はある値 $v$ を供出し、何かしらの値を $e$ で受け取る項。\n評価規則は以下のようになる。\n\\[ \\begin{align} (\\to^\\prime) \\quad \u0026amp; \\langle\\lambda{}x.v_1|v_2\\cdot{}e\\rangle \u0026amp; \\to \\quad \u0026amp; \\langle{}v_2|\\tilde\\mu{}x.\\langle{}v_1|e\\rangle\\rangle \\\\\n(\\mu) \\quad \u0026amp; \\langle\\mu\\beta.c|e\\rangle \u0026amp; \\to \\quad \u0026amp; c[\\beta \\leftarrow e] \\\\\n(\\tilde\\mu ) \\quad \u0026amp; \\langle{}v|\\tilde\\mu{}x.c\\rangle \u0026amp; \\to \\quad \u0026amp; c[x \\leftarrow v] \\end{align} \\]\nこれの $(\\mu)$ を先に適用すればCBVになり、 $(\\tilde\\mu)$ を先に適用すればCBNになる。\n型判断が初見だと分かりづらい。記法に以下の3種類がある。\n\\[ c: (\\Gamma \\vdash \\Delta) \\\\\n\\Gamma \\vdash v : A | \\Delta \\\\\n\\Gamma | e : A \\vdash \\Delta \\]\nコマンドは値と継続が揃ってるので判断式の型がつく。 $\\Gamma$ が値の型環境で、 $\\Delta$ が継続の型環境。 値の型判断は $\\Gamma \\vdash v : A | \\Delta$ で、 $\\Delta$ は使ってないので $|$ で隔離されている。 継続の型判断は $\\Gamma | e : A \\vdash \\Delta$ で、 $\\Gamma$ は使ってないので $|$ で隔離されている。\n継続の方、確かに値と双対な書き方なんだけどそう書くのかーという感じ。\nこの記法を用いて型付け規則はこう書かれる。\n\\[ \\frac{\\Gamma \\vdash v : A | \\Delta \\qquad \\Gamma | e : A \\vdash \\Delta}{\\langle{}v|e\\rangle : (\\Gamma \\vdash \\Delta)} \\\\\n\\frac{}{\\Gamma | \\alpha : A \\vdash \\alpha : A, \\Delta} \\quad \\frac{}{\\Gamma, x : A \\vdash x : A | \\Delta} \\\\\n\\frac{c : (\\Gamma \\vdash \\beta : B, \\Delta)}{\\Gamma \\vdash \\mu\\beta.c : B | \\Delta} \\quad \\frac{c : (\\Gamma , x : A \\vdash \\Delta)}{\\Gamma | \\tilde\\mu{}x.c : B \\vdash \\Delta} \\\\\n\\frac{\\Gamma \\vdash v : A | \\Delta \\qquad \\Gamma | e : B \\vdash \\Delta}{\\Gamma | v\\cdot{}e : A \\to B \\vdash \\Delta} \\quad \\frac{\\Gamma, x : A \\vdash v : B | \\Delta}{\\Gamma \\vdash \\lambda{}x.v : A \\to B | \\Delta} \\]\nなんか最後の2つだけ対称性が悪い。なので値に $e\\cdot{}v$ を、継続に $\\beta\\lambda.e$ を加えて対称にする拡張もある。\nこれより先は知らない。浅井先生のスライドによるとWadlerのやつがあるらしいけど未読。\n先というか応用例だとSequent Coreがある。\nDownen, P. Maurer, L. Ariola, Z. M. and Peyton Jones, S. \u0026ldquo;Sequent calculus as a compiler intermediate language,\u0026rdquo; Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, Nara, Japan, September 18-22, 2016, pages 74–88 (2016).\nMaurer, L. Downen, P. Ariola, Z. M. and Peyton Jones, S. \u0026ldquo;Compiling without continuations,\u0026rdquo; PLDI 2017 Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation, Pages 482-494 (2017)\n実行 継続を陽に扱える仮想機械にCEKマシンがある。あんまり情報がない。 Felleisen, M. Flatt, M. \u0026ldquo;Programming languages and lambda caluculi\u0026rdquo; で紹介されているのは確認した。 元論文は以下？\nM. Felleisen and D. P. Friedman. \u0026ldquo;Control Operators, the SECD-Machine, and the λ-Calculus,\u0026rdquo; Indiana University, Computer Science Department (1986).\n継続を陽に扱う処理系作るならSelective CPSかCEKマシンかなーと思いつつCEKマシンの情報が少ない。\nその他 そういえばshift/resetってどこが発祥なんだろう。というのが気になった。これかな？\nshift/reset: Danvy, O. and Filinski, A. \u0026ldquo;A Functional Abstraction of Typed Contexts,\u0026rdquo; Technical Report89/12, DISK, University of Copenhagen, (1989).\ncontrol/prompt: Felleisen, M. \u0026ldquo;The Theory and Practice of First-Class Prompts,\u0026rdquo; proceedings of the Fifteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages pp 180-190, San Diego, California (1988).\n","categories":["継続"],"category_urls":["/categories/%e7%b6%99%e7%b6%9a"],"date":"2019-06-27","title":"継続とかの話題サーベイ","url":"https://KeenS.github.io/blog/2019/06/27/keizokutokanowadaisa_bei/"},
  {"body":"# Effective Idris: Effects ---------------------- [effect system勉強会](https://connpass.com/event/124786/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # 今日の話 -------------- * Effectのハンドラを自分で書く === # Effectsって？ -------------- * Idrisの標準添付ライブラリ * Algebraic Effectの実装ライブラリ + Eff言語のEffectを参考に設計したらしい * IOとかRandomとかStateとか色々あるよ === # 使ってみよう ------------- Step 1 .ipkgに `effects` を足す ``` package hoge version = \"0.1.0\" -- .. -- これ pkgs = effects ``` === # 使ってみよう ------------- Step 2 Effectsをインポート ```idris module Main import Effects import Effect.StdIO ``` === # 使ってみよう ------------- Step 3 Effectを使って好きなプログラムを書こう ```idris hello : Eff () [STDIO] hello = do putStr \"what's your name: \" name Type - (x - Type) - Type data EFFECT : Type where MkEff : Type - Effect - EFFECT ``` === # Effectたち ----------- State ```idris data State : Effect where Get : sig State a a Put : b - sig State () a b STATE : Type - EFFECT STATE t = MkEff t State get : Eff x [STATE x] get = call $ Get put : x - Eff () [STATE x] put val = call $ Put val ``` === # Effectたち ----------- StdIO ``` idris data StdIO : Effect where PutStr : String - sig StdIO () GetStr : sig StdIO String PutCh : Char - sig StdIO () GetCh : sig StdIO Char STDIO : EFFECT STDIO = MkEff () StdIO -- putStr, putStrLnなどなど ``` === # Effect文脈 ------------- * `hello` についてた `Eff () [STDIO]` の話 * 複数の `Effect` をまとめた「どんな種類のEffectが起きるか」の文脈。 * `Eff` は元を辿ると長い `EffM` * `EffM` = モナドっぽいの \\* 返り値 \\* Effect文脈 \\* 文脈更新関数 ``` idris data EffM : (m : Type - Type) - (x : Type) - (es : List EFFECT) - (ce : x - List EFFECT) - Type where -- ... ``` === # Effect文脈 ------------- * Effectの更新をしないならもう少し簡単にできる * さらにモナドっぽいのは一般化して使うので省略してよさそう ``` idris Eff : (x : Type) - (es : List EFFECT) - Type Eff x es = {m : Type - Type} - EffM m x es (\\v = es) EffT : (m : Type - Type) - (x : Type) - (es : List EFFECT) - Type EffT m x es = EffM m x es (\\v = es) ``` === # Effect文脈 ------------- * 重要なのは `EffM` はモナドトランスフォーマじゃ **ない** 点 + Effectの更新が入る + Extensible Effectとはそこが違う？ * Idrisの `do` 記法は `(=)` の糖衣構文なのでモナドじゃなくても使える ``` idris (=) : EffM m a xs xs' - ((val : a) - EffM m b (xs' val) xs'') - EffM m b xs xs'' (=) = EBind ``` === # `run` について ---------------- * モナドっぽいものはモナドじゃない + `pure` さえあればいい * `m` を `Identity` にとればただの型にもなる + `IO` とかのため一般化 * あと本来はEffectの初期値も必要 ```idris run : Applicative m = (prog : EffM m a xs xs') - {default MkDefaultEnv env : Env m xs} - m a runWith : (a - m a) - Env m xs - EffM m a xs xs' - m a runPure : (prog : EffM Basics.id a xs xs') - {default MkDefaultEnv env : Env Basics.id xs} - a ``` === # 小まとめ ---------- * Effect単体は `Effect` * それらをまとめた文脈が `Eff a [EFFECT]` * `Eff` を `run` するとモナドっぽいものが出てくる === # ハンドラの話 ------------- * 所望の `Effect` に `Handler` を実装すると `run` できるようになる * そのときに実装する型で `run` のあとに取り出せる型が変わる ``` idris interface Handler (e : Effect) (m : Type - Type) where handle : (r : res) - (eff : e t res resk) - (k : ((x : t) - resk x - m a)) - m a ``` === # ハンドラの例 ------------- * この例だと `StdIO` を `run` すると `IO` モナドが出てくることが分かる ``` idris implementation Handler StdIO IO where handle () (PutStr s) k = do putStr s; k () () handle () GetStr k = do x Eff ret [STDIO] - (ret, List String, List String) runToStr input eff = ?unimplemented ``` === # 型定義 ------- * 入力と出力でそれぞれ `State` を使うよ + 外側が出力、内側が入力 + タプルにして1つのステートにした方がよかったかも？ * `run` するとこの型が出てくるよ ``` idris StringIO : Type - Type StringIO a = StateT (List String) (State (List String)) a ``` === # 操作関数 ----------- * 入力は色々面倒くさい ``` idris read : StringIO String read = do ss StringIO () write s = modify (\\ss = the (List String) (s::ss)) ``` === # ハンドラ ---------- * インターフェースの実装には型エイリアスは書けないみたい？ * `StdIO` を `run` すると `StateT (List String) (StateT (List String) Identity)` が出てくるよ！ ``` idris implementation Handler StdIO (StateT (List String) (StateT (List String) Identity)) where handle () (PutStr s) k = do write s; k () () handle () GetStr k = do s Eff ret [STDIO] - (ret, List String, List String) runToStr input eff = let writer = run eff reader = runStateT writer (the (List String) []) ((ret, output), input) = runState reader input in (ret, output, input) ``` === # 実行 ------ * テストするときとかは `print` せずに結果を比較しようね ``` idris main : IO () main = printLn $ runToStr [\"keen\", \"-san\"] hello ``` --- ``` console $ ./main ((), ([\"Hello keen-san\\n\", \"what title do you prefer: \", \"what's your name: \"], [])) ``` === # まとめ -------- * Effectsは `Eff` 、 `Effect` 、 `run` をおさえよう * `Effect` の `Handler` は上書きできるよ * `run` した結果は `Handler` が実装されてる型だよ === # 参考文献 ---------- * [The Effects Tutorial](http://docs.idris-lang.org/en/latest/effects/introduction.html) * Edwin Brady. 2013. Programming and reasoning with algebraic effects and dependent types. SIGPLAN Not. 48, 9 (September 2013)   ","categories":["Idris","Algebraic Effect"],"category_urls":["/categories/idris","/categories/algebraic-effect"],"date":"2019-05-25","title":"Effective Idris: Effects","url":"https://KeenS.github.io/slide/effective_idris__effects/"},
  {"body":"κeenです。勉強会参加報告を書くのも久しぶりですね。RustのLT会 Shinjuku.rs #4 @FORCIA でライブコーディングしてきたのでそれを書き留めておきます。\n当日になって発表枠が2つ分くらい余ってるとのことだったので尺とりそうなライブコーディングをしてきました。 題材は拙著(共著)実践Rust入門の「9章 パーサを作る」より。 9章の締めの文にはこう書かれています。\n ここで構成したインタプリタは簡素なものではありますが、骨子は同じまま複雑な処理をするインタプリタへの応用もできるでしょう。変数、関数、制御構造、ユーザ定義型、と徐々に拡張していけば 1 つ 1 つのステップは難しくないでしょう。\n これを証明するために変数の追加をライブコーディングしました。何の準備もないぶっつけ本番のやつです。あまり褒められたものではないですね。\n9章を通して作るコードはGitHubで公開されているのでこれをベースに作業をします。\n元の電卓と新しい仕様 元のコードは以下のようにして式を打ち込むとパースして計算して結果を出してくれる対話環境です。\n\u0026gt; 1 + 1 Annot { value: BinOp { op: Annot { value: Add, loc: Loc(2, 3) }, l: Annot { value: Num(1), loc: Loc(0, 1) }, r: Annot { value: Num(1), loc: Loc(4, 5) } }, loc: Loc(0, 5) } 2 1 1 +  デバッグプリントが出てますが気にせず進めます。2行目にちゃんと 2 と出ているのが見えるかと思います。こうやって結果を出してくれます。\nこれにRust風の let \u0026lt;変数\u0026gt; = \u0026lt;式\u0026gt;; を加えるというのが今回の題材です。\nレキサまで 新しく let 、変数、 = 、 ; がトークンに加わります。これはそのまま TokenKind に加えればよいでしょう。\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]enum TokenKind{// ... /// let Let,/// = Equal,/// ; Semicolon,/// x Var(String),} Var の引数に Stringが 入った影響で Copy が自動導出から消えてます。 この定義変更から直ちに作業的にヘルパ関数ができあがります。\nimplToken{// ... fn let_(loc: Loc)-\u0026gt; Self{Self::new(TokenKind::Let,loc)}fn equal(loc: Loc)-\u0026gt; Self{Self::new(TokenKind::Equal,loc)}fn semicolon(loc: Loc)-\u0026gt; Self{Self::new(TokenKind::Semicolon,loc)}fn var(s: implInto\u0026lt;String\u0026gt;,loc: Loc)-\u0026gt; Self{Self::new(TokenKind::Var(s.into()),loc)}} さて、これからレキサを書いていきますが、その前にテストを準備しましょう。ライブコーディング中はロケーション情報の修正を忘れてたりしましたが、このコードは修正後のものです。\n#[test]fn test_lexer2(){assert_eq!(lex(\u0026#34;let x = 1;\u0026#34;),Ok(vec![Token::let_(Loc(0,3)),Token::var(\u0026#34;x\u0026#34;,Loc(4,5)),Token::equal(Loc(6,7)),Token::number(1,Loc(8,9)),Token::semicolon(Loc(9,10)),]))} これでレキサを書き始められます。 まずはエントリポイントの lex 関数に処理を加えましょう。今回加わったのは = 、 ; 、 let 、 変数ですが、変数と let は最初の文字が被ってる可能性があるので一緒に処理します。なので都合3つの節が新たに加わります。 ここでaからzまでの範囲の記法を間違えて会場に助けてもらったりしてました。\n/// 字句解析器 fn lex(input: \u0026amp;str)-\u0026gt; Result\u0026lt;Vec\u0026lt;Token\u0026gt;,LexError\u0026gt;{// ... whilepos\u0026lt;input.len(){// ここでそれぞれの関数に`input`と`pos`を渡す matchinput[pos]{// ... b\u0026#39;=\u0026#39;=\u0026gt;lex_a_token!(lex_equal(input,pos)),b\u0026#39;;\u0026#39;=\u0026gt;lex_a_token!(lex_semicolon(input,pos)),// ... b\u0026#39;a\u0026#39;...b\u0026#39;z\u0026#39;=\u0026gt;lex_a_token!(lex_str(input,pos)),// ... }}Ok(tokens)} このうち = と ; はそのまま実装が決まります。\nfn lex_equal(input: \u0026amp;[u8],start: usize)-\u0026gt; Result\u0026lt;(Token,usize),LexError\u0026gt;{consume_byte(input,start,b\u0026#39;=\u0026#39;).map(|(_,end)|(Token::equal(Loc(start,end)),end))}fn lex_semicolon(input: \u0026amp;[u8],start: usize)-\u0026gt; Result\u0026lt;(Token,usize),LexError\u0026gt;{consume_byte(input,start,b\u0026#39;;\u0026#39;).map(|(_,end)|(Token::semicolon(Loc(start,end)),end))} 変数または let は複数のトークンを読む必要があるので、 lex_number をコピペして作りましょう。 ひとまずアルファベットの塊を抜き出してみて let だったら let キーワードに、それ以外だったら変数にするようにします。\nfn lex_str(input: \u0026amp;[u8],pos: usize)-\u0026gt; Result\u0026lt;(Token,usize),LexError\u0026gt;{usestd::str::from_utf8;letstart=pos;letend=recognize_many(input,start,|b|b\u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;.contains(\u0026amp;b));lets=from_utf8(\u0026amp;input[start..end])// start..posの構成から `from_utf8` は常に成功するため`unwrap`しても安全 .unwrap();ifs==\u0026#34;let\u0026#34;{Ok((Token::let_(Loc(start,end)),end))}else{Ok((Token::var(s,Loc(start,end)),end))}} これでレキサ部分は実装を終えましたが後の方でコンパイルエラーが出ているので直します。 TokenKind のDisplayに新たに加えたものの実装を足します。この実装不足をコンパイラが教えてくれるのはいい所ですね。\nimplfmt::DisplayforTokenKind{fn fmt(\u0026amp;self,f: \u0026amp;mutfmt::Formatter)-\u0026gt; fmt::Result{useself::TokenKind::*;matchself{// ... Let=\u0026gt;write!(f,\u0026#34;let\u0026#34;),Semicolon=\u0026gt;write!(f,\u0026#34;;\u0026#34;),Equal=\u0026gt;write!(f,\u0026#34;=\u0026#34;),Var(s)=\u0026gt;write!(f,\u0026#34;{}\u0026#34;,s),}}} そして TokenKind から Copy を消した影響で parse_expr1 に変更が必要になります。1行目の tok.value に clone がつきます。\n// expr1 fn parse_expr1\u0026lt;Tokens\u0026gt;(tokens: \u0026amp;mutPeekable\u0026lt;Tokens\u0026gt;)-\u0026gt; Result\u0026lt;Ast,ParseError\u0026gt;whereTokens: Iterator\u0026lt;Item=Token\u0026gt;,{matchtokens.peek().map(|tok|tok.value.clone()){...} これでテストが通るようになった(会場ではテストのロケーションの修正をやった)のでレキサは完成です。\ntest test_lexer2 ... ok  パーサ パーサも作業の流れはレキサと同じです。 let 文を表わすバリアントを追加します。\n/// ASTを表すデータ型 #[derive(Debug, Clone, PartialEq, Eq, Hash)]enum AstKind{// ... /// Let文 Let{var: String,body: Box\u0026lt;Ast\u0026gt;},}// ヘルパメソッドを定義しておく implAst{fn let_(var: String,body: Ast,loc: Loc)-\u0026gt; Self{Self::new(AstKind::Let{var,body: Box::new(body),},loc,)}} そして対応するテストを追加します。\n#[test]fn test_parser2(){// let x = 1; letast=parse(vec![Token::let_(Loc(0,3)),Token::var(\u0026#34;x\u0026#34;,Loc(4,5)),Token::equal(Loc(6,7)),Token::number(1,Loc(8,9)),Token::semicolon(Loc(9,10)),]);assert_eq!(ast,Ok(Ast::let_(\u0026#34;x\u0026#34;.to_string(),Ast::num(1,Loc(8,9)),Loc(0,10))))} テストができました。パーサを作りましょう。\nいままでは式だけでしたが、let は文なので新たに parse_stmt という関数を追加します。これは parse_expr1 からコピペして作ったと思います。長いですが let 、 変数 、 = 、 式 、 ; を順番に取り出してるだけです。もし先頭が let でなかったら parse_expr3 のパースにフォールバックします。\nfn parse_stmt\u0026lt;Tokens\u0026gt;(tokens: \u0026amp;mutPeekable\u0026lt;Tokens\u0026gt;)-\u0026gt; Result\u0026lt;Ast,ParseError\u0026gt;whereTokens: Iterator\u0026lt;Item=Token\u0026gt;,{matchtokens.peek().map(|tok|tok.value.clone()){Some(TokenKind::Let)=\u0026gt;{// (\u0026#34;+\u0026#34; | \u0026#34;-\u0026#34;) letloc_start=matchtokens.next(){Some(Token{value: TokenKind::Let,loc,})=\u0026gt;loc,_=\u0026gt;unreachable!(),};letvar=matchtokens.next(){Some(Token{value: TokenKind::Var(s),loc,})=\u0026gt;s,_=\u0026gt;unreachable!(),};matchtokens.next(){Some(Token{value: TokenKind::Equal,loc,})=\u0026gt;(),_=\u0026gt;unreachable!(),};letbody=parse_expr(tokens)?;letloc_end=matchtokens.next(){Some(Token{value: TokenKind::Semicolon,loc,})=\u0026gt;loc,_=\u0026gt;unreachable!(),};letloc=loc_start.merge(\u0026amp;loc_end);//let loc = op.loc.merge(\u0026amp;e.loc); Ok(Ast::let_(var,body,loc))}_=\u0026gt;parse_expr3(tokens),}} 会場では = を取り出すのを忘れていました。また、 unreachable をところどころ使っていますがよく考えると先頭の let 以外は到達可能で、 unexpected tokenのエラーを出すべきですね。 煩雑なので consume_token 的な関数を定義しておけばよかったんですがアドリブではそこまで機転が利きませんでした。\nloc のところでコメントアウトが見られますが最初混乱して書けなくて後回しにしたせいです。\nレキサと同じくこれで動作はしますが、後の方でコンパイルエラーが発生してるので直します。 Interpreter の eval です。ここでは unimplemented を使ってコンパイルを通します。\nimplInterpreter{// ... pubfn eval(\u0026amp;mutself,expr: \u0026amp;Ast)-\u0026gt; Result\u0026lt;i64,InterpreterError\u0026gt;{useself::AstKind::*;matchexpr.value{// ... Let{..}=\u0026gt;unimplemented!()}} 同様に、 RpnCompiler でもエラーが出ますが、 unimplemented!() にします。\nこれでテストを走らせてみましょう。\n---- test_parser2 stdout ---- thread \u0026#39;test_parser2\u0026#39; panicked at \u0026#39;assertion failed: `(left == right)` left: `Err(NotExpression(Annot { value: Let, loc: Loc(0, 3) }))`, right: `Ok(Annot { value: Let { var: \u0026#34;x\u0026#34;, body: Annot { value: Num(1), loc: Loc(8, 9) } }, loc: Loc(0, 10) })`\u0026#39;, src/main.rs:658:5 note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.  おや、エラーになります。。どうやら let のパースに失敗してます。よく考えたら parse_stmt を定義したいいですが、使うのを忘れてました。 parse 関数内で parse_expr の代わりに parse_stmt を呼ぶようにしましょう。\nfn parse(tokens: Vec\u0026lt;Token\u0026gt;)-\u0026gt; Result\u0026lt;Ast,ParseError\u0026gt;{// 入力をイテレータにし、 `Peekable` にする letmuttokens=tokens.into_iter().peekable();// その後 `parse_expr` を呼んでエラー処理をする letret=parse_stmt(\u0026amp;muttokens)?;matchtokens.next(){Some(tok)=\u0026gt;Err(ParseError::RedundantExpression(tok)),None=\u0026gt;Ok(ret),}} 今度こそ。\ntest test_parser2 ... ok  通りました。会場では = の処理を忘れていたり、ロケーション情報を修正したりしましたが概ねこのまま動きました。\nインタプリタ RPNコンパイラはそもそもバックエンドの実行器が変数に対応してないのでインタプリタを作ります。 Interpreter 構造体に変数と値の対応を保持するハッシュマップを持っておきましょう。\nusestd::collections::HashMap;/// 評価器を表すデータ型 struct Interpreter(HashMap\u0026lt;String,i64\u0026gt;);implInterpreter{pubfn new()-\u0026gt; Self{Interpreter(HashMap::new())}} これであとは eval の unimplemented の部分を埋めるだけです。 が、文の値というものがここで発生します。普通は文の値は void ですね。 綺麗にやるなら enum Value {Int(i64), Void} を定義するところですが、時間がないので 0 を返すことにしました。 会場ではライフタイムエラーなどありましたがこのコードが出来上がりました。\npubfn eval(\u0026amp;mutself,expr: \u0026amp;Ast)-\u0026gt; Result\u0026lt;i64,InterpreterError\u0026gt;{useself::AstKind::*;matchexpr.value{Let{refvar,refbody,..}=\u0026gt;{lete=self.eval(body)?;self.0.insert(var.clone(),e);Ok(0)} これで動くのですが、RPNコンパイラを実装してないのでそれはコメントアウトしておきましょう。\nfn main(){// ... // let rpn = compiler.compile(\u0026amp;ast); // println!(\u0026#34;{}\u0026#34;, rpn); } それでは試してみます。\n\u0026gt; let x = 1; Annot { value: Let { var: \u0026#34;x\u0026#34;, body: Annot { value: Num(1), loc: Loc(8, 9) } }, loc: Loc(0, 10) } 0  ちゃんと0が返ってきました。めでたしめでたし。ここまで20分ほどだったようです。\n…と会場では締めたのですがこれでは変数を定義するだけで利用できないですね。ついでなのでそれも実装しましょう。\n変数の参照 懇親会中に一人でやってました。レキサは変数を既に扱えるのでパーサ以降をいじります。 ASTにバリアントを追加してヘルパ関数を定義。\n/// ASTを表すデータ型 #[derive(Debug, Clone, PartialEq, Eq, Hash)]enum AstKind{// ... /// 変数 Var(String),}// ヘルパメソッドを定義しておく implAst{// .. fn var(var: String,loc: Loc)-\u0026gt; Self{Self::new(AstKind::Var(var),loc)}} 変数はアトムなので parse_atom をちょこちょこっといじります。\nfn parse_atom\u0026lt;Tokens\u0026gt;(tokens: \u0026amp;mutPeekable\u0026lt;Tokens\u0026gt;)-\u0026gt; Result\u0026lt;Ast,ParseError\u0026gt;whereTokens: Iterator\u0026lt;Item=Token\u0026gt;,{tokens.next().ok_or(ParseError::Eof).and_then(|tok|matchtok.value{// ... // Var TokenKind::Var(s)=\u0026gt;Ok(Ast::new(AstKind::Var(s),tok.loc)),// ... })} インタプリタに取り掛かりますが、その前に存在しない変数の参照はエラーなので InterpreterErrorKind を増やします。 description の実装要らない気がするけどなんで残ってるんだろう。\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]enum InterpreterErrorKind{DivisionByZero,UnboundVariable(String),}implfmt::DisplayforInterpreterError{fn fmt(\u0026amp;self,f: \u0026amp;mutfmt::Formatter)-\u0026gt; fmt::Result{useself::InterpreterErrorKind::*;matchself.value{DivisionByZero=\u0026gt;write!(f,\u0026#34;division by zero\u0026#34;),UnboundVariable(refv)=\u0026gt;write!(f,\u0026#34;variable {} is not bound\u0026#34;,v),}}}implStdErrorforInterpreterError{fn description(\u0026amp;self)-\u0026gt; \u0026amp;str {useself::InterpreterErrorKind::*;matchself.value{DivisionByZero=\u0026gt;\u0026#34;the right hand expression of the division evaluates to zero\u0026#34;,UnboundVariable(_)=\u0026gt;\u0026#34;variable is not bound\u0026#34;,}}} それではインタプリタをば。 ハッシュマップからの get で Option が返るので ok_or で None を UnboundVariable エラーに変換して返ります。\npubfn eval(\u0026amp;mutself,expr: \u0026amp;Ast)-\u0026gt; Result\u0026lt;i64,InterpreterError\u0026gt;{useself::AstKind::*;matchexpr.value{// ... Var(refs)=\u0026gt;self.0.get(s).cloned().ok_or(InterpreterError::new(InterpreterErrorKind::UnboundVariable(s.clone()),expr.loc.clone(),)),}} RPNコンパイラの方は相変わらず unimplemented のスタブを刺しておいて下さい。\nこれで実行できます。\n\u0026gt; let x = 1 + 1; Annot { value: Let { var: \u0026#34;x\u0026#34;, body: Annot { value: BinOp { op: Annot { value: Add, loc: Loc(10, 11) }, l: Annot { value: Num(1), loc: Loc(8, 9) }, r: Annot { value: Num(1), loc: Loc(12, 13) } }, loc: Loc(8, 13) } }, loc: Loc(0, 14) } 0 \u0026gt; x + x * 2 Annot { value: BinOp { op: Annot { value: Add, loc: Loc(2, 3) }, l: Annot { value: Var(\u0026#34;x\u0026#34;), loc: Loc(0, 1) }, r: Annot { value: BinOp { op: Annot { value: Mult, loc: Loc(6, 7) }, l: Annot { value: Var(\u0026#34;x\u0026#34;), loc: Loc(4, 5) }, r: Annot { value: Num(2), loc: Loc(8, 9) } }, loc: Loc(4, 9) } }, loc: Loc(0, 9) } 6 \u0026gt; x + y Annot { value: BinOp { op: Annot { value: Add, loc: Loc(2, 3) }, l: Annot { value: Var(\u0026#34;x\u0026#34;), loc: Loc(0, 1) }, r: Annot { value: Var(\u0026#34;y\u0026#34;), loc: Loc(4, 5) } }, loc: Loc(0, 5) } variable y is not bound x + y ^ variable y is not bound  変数の扱いもunbound variableも扱えます。めでたしめでたし。\n","categories":["Rust","Shinjuku.rs"],"category_urls":["/categories/rust","/categories/shinjuku.rs"],"date":"2019-05-22","title":"Shinjuku.rs #4 でライブコーディングしてきた","url":"https://KeenS.github.io/blog/2019/05/22/shinjuku_rs__4deraibuko_dingushitekita/"},
  {"body":"κeenです。実践Rust入門 言語仕様から開発手法まで(技術評論社)を書いた(3人で共著)のでどういう本なのか解説します。 5/8発売です。電子版もありますよ。Gihyo Digital PublishingだとPDFが手に入るので人気らしいです。\nSee Also 書籍『実践Rust入門』の詳細な目次です\n目指したもの Rustの入門書といえば公式ドキュメントのThe Book、TRPLなどと呼ばれるThe Rust Programming Languageやその有志による和訳が一番に挙がるでしょう。 それ以外にもオライリーよりProgramming Rustやその和訳版も出ています。 どちらもRustについてよく書かれており、本書の購入を検討されている方は上記2冊との違いが気になるかと思います。 本書の大きな特徴は以下の2点です。\n Rust 2018 Editionに対応している 実践を重視している  Rust 2018 Editionに対応している Rustを知らない方にはEditionという概念に馴染みがないかと思いますが、C++03とかC++14とかのようなものです。 Rustは2015年にリリースされたあと、後方互換性を守りつつ言語を発展させてきました。それでしばらくは良かったのですがどうしても後方互換性を壊すけど便利な機能が欲しくなります。 そこで2018年に既存のコードは動くようにしつつ新たに書き始めるコードは先進的な機能を使えるようにする仕組みとしてEditionを導入しました。 上述のTRPLの和訳版やプログラミングRustはまだ2018 Editionに対応した Rust 1.31がリリースされていない時期のものなので2015 Editionを元に解説されています。 本書は2018 Editionを解説しています。現在でもどちらのEditionも使えるのですがRustのパッケージマネージャのCargoはデフォルトで2018を使う設定になっています。 和書では一番最初、現時点では唯一の2018 Edition対応の本になると思います。\n実践を重視している Rustの日本語コミュニティでの会話を見ていると、「公式ドキュメントを読んでRustの機能は理解できたけど実際にアプリケーションを書く方法が分からない」という感想が多いようです。 TRPLは公式ドキュメントという性質上、言語機能を紹介しないと意味がないので仕方ない話ですがユーザからしたらもう少し実践的な内容も欲しくなります。 「プログラミングRust」もどちらかと言うとTPRLに似た内容で、言語機能や標準ライブラリの紹介に重点が置かれています。\n本書では言語仕様の紹介は緩急つけつつ、実践の部を設けることでアプリケーションの作り方を示しています。本書一冊で読者が自立してRustでプログラミングできるようになる本に仕上がっているはずです。 言語仕様については網羅的ではなく、最初にアプリケーションを書く上で必要にならなそうな言語仕様の細かな点の解説は省いています。 例えば「2つの存在 impl Trait が同じ型とみなされる条件」「||がいつクロージャの引数としてパースされていつ論理和の演算子としてパースされるか」などは解説していません。あるいは、マクロについてもTRPLやプログラミングRustで1章割かれていますが、本書では多少触れるだけにとどめています。 細かな点はTRPLへのポインタを示しているので必要になったら読めばいいでしょう。\n簡単に書きましたがRustで言語仕様を程々に紹介するというのはかなり難しいです。 Rustはリソースを細かく管理してマシンの性能を引き出す目的で作られた言語なので、なんとなくで書いたらとりあえず動く言語の入門とは一線を画します。 適当に書いてもコンパイルエラーになるのは目に見えてますし、そこから格闘してランダムにコードを書き換えて、よしんば動いたとしても当初の目的であったマシンの性能を引き出すのとは程遠い結果になるでしょう。 そうなってはRustはただのコンパイラが口うるさいだけの書きづらい言語になってしまいます。 結局こういう部分は実践よりもガッと座学で原理を理解してメンタルモデルを築くのが習得への近道だと思います(個人の意見です)。 とはいえ動くコードがないと飽きるのもまた事実です。 本書では実例を交えつつ、理解すべき点は丁寧に説明して、必要とあらばメモリレイアウトの図も載せて、と(個人的感想では)バランス良く書かれています。 コミュニティでの質疑でよく見受けられるつまづきやすい所、疑問に思いやすいところをしっかりカバーしているのもポイントですね。\n執筆しての感想 初めての経験なので大変でした(小並感)。実は編集者の方とのやり取りは2016年末頃から始まっており、振り返ると足掛け4年のプロジェクトでした。 4年もあると色々変わるもので、書き始めた頃からRustの仕様は大きく変わり、将来に期待と書いたはずの未来が訪れ、紹介していたフレームワークがメンテナンスされなくなり、2018 Editionが出たり、と様々な変化がありました。 著者のスケジュールやそれぞれが書きたい内容も色々なことがあって章が減ったり増えたりもしました。\n完成までに時間がかかったのは申し訳ないことに著者の怠惰もありますが、シンプルに書いた内容が多いというのもあります。 最初に指定された字数制限を最終的に守った章は1つとしてなかったと記憶しています。 本のサイズ感も概ね「マスタリングTCP/IP」くらい、TAoCP Vol. 1より少し薄いくらいです。もしかしたら世界で一番内容が多いRustの本なのかもしれません。\n私はブログをちょくちょく書いているので筆の速さには自信があったのですが、ちゃんとした内容を書くとなると書き捨てのブログとは勝手がずいぶん違いました。 初速こそ出るもののすぐに息切れしてしまいますし、後から見返すと構成が全然ダメで上手く内容が伝わってきませんでした。 テクニカルライティングの技能って大事だなーとひしひしと感じているところです。大学の専門教育って重要ですね。 何度も書き直して最終的に形になったと信じていますが、実際に手に取って読まれてどう評価されるのか今でも不安でいっぱいです。\n因みに原稿はGitHubにMarkdownをpushする形で、コミュニケーションはSlackでした。普段どおりのツーリングなので違和感なく進められました。 基本的には章単位で担当なのでコンフリクトは気にしなくていいのですが、たまに編集が入ってmasterが書き換わることがあるのでmasterへのpush通知は常に見てました。 進行管理もGitHubのIssueやProject、Wikiなどを使っていましたし、ピアレビューはプルリクでした。便利！ 出版社とのやりとりは結構ローテクなことが多いと聞いていたのでエンジニアに寄せた作業フローが意外でした。\nその他 勘の良い方なら気づいたかと思いますが本書の著者陣はTRPL旧版の和訳に貢献した人たちで構成されています。河野さんと私がリポジトリの中の人、小松さんがこのissueによると最も翻訳に貢献した人です。その3人が執筆で忙しをしてしまったので結果として翻訳が止まってしまいました。 「すぐに書き終えるから少し待って」と思いつつ想定より時間がかかってしまったのでコミュニティには大変申し訳無く思っています。 しかし新版のドキュメントが出てから旧版とは独立に翻訳がプロジェクト始まったりしてコミュニティに助けられました。ありがとうございます。\nところでRustの公式ドキュメントについては変遷があったので少し纏めておきます。\n   呼称 別名 和訳 備考     旧版 1st Edition 河野さん、κeenなどの有志    新版 2nd Edition hazama-yuinyanさん 紙の本が出ている   2018 Edition  -    現行版  -     旧版と新版では章レベルで内容がガラリと変わっています。新版以降は言語の進化に合わせて内容をアップデートしているみたいで、連続的な変化です。\n本書は著者陣がTRPLの翻訳をやっていたので訳語も概ねTRPLの和訳に準じています(doc.rust-jp.rsにあるドキュメントはほぼ対訳表を共有(フォーク)しながら訳しているので訳語がある程度揃っています)。\nプログラミングRustの翻訳はどうも独自で訳語を決めているみたいです。 プログラミングRustの訳者が大学のサークルのOBだったのでOB会で実際どうなのか聞こうと思ってたのですが私がOB会にいきそびれたので聞けませんでした。次の機会に聞こうと思います。\n(こう書くと他の著者に失礼ですが)自分の書いた本が本当に刊行されていいのか今でも不安です。しかしちゃんと目指した通りの本になっていると思うので是非手に取ってみてください。 これを機にRustに入門する方が1人でも増えたら著者冥利に尽きます。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2019-04-21","title":"「実践Rust入門」を書いたよ","url":"https://KeenS.github.io/blog/2019/04/21/jissenrustnyuumon_wokaitayo/"},
  {"body":"# Rustから扱うAWS API ---------------------- [Shinjuku.rs #3 @FORCIA ](https://forcia.connpass.com/event/117142/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # AWSとは --------- * https://aws.amazon.com/jp/ *  アマゾン ウェブ サービス（AWS）は、信頼性と拡張性に優れたクラウドコンピューティングサービスを低料金で提供して(中略)います。 * クラウドサービス = オンデマンドの利用 + **API** (私見) * AWSは豊富なサービスとそれを叩けるAPIが用意されている === ![AWSのサービス一覧](/images/rusoto/AWSのサービス一覧.png) === # AWS SDK --------- * AWSが公式にAPIバインディングを用意してくれている * 残念ながらRustは入ってない ![AWS SDKの一覧](/images/rusoto/AWS_SDKの一覧.png) === # Rusoto -------- * [ドキュメント](https://rusoto.org/) * RustのAWS APIバインディング * 公式ではない * Pythonの[SDK](https://github.com/boto/botocore)から自動生成 * rusotoのユーザが増えるとAWSから公式サポートくる[かも](https://users.rust-lang.org/t/getting-rust-official-support-on-aws/20079/4) + → みんなRustからAWS API叩こう * 初見だと圧倒される + → === ![Rusotoのサービス一覧](/images/rusoto/Rusotoのサービス一覧.png) === ひとまずS3だけみてみる === ![Rusoto S3の定義一覧](/images/rusoto/Rusoto_S3の定義一覧.png) === # Rusotoの使い方 ----------------- * 一見すると手の付け所が分からない * 基本を押さえれば簡単 1. rusoto_core は必ず使う 2. 使いたいサービスに合わせて他のクレートを選ぶ 3. クレートのトレイトとクライアントを使う * やってみよう === # RusotoでS3 ------------- * お題: S3のバケットを作ってオブジェクトを置いてそれを取得してみる * 使うのは[rusoto_core](https://rusoto.github.io/rusoto/rusoto_core/)と[rusoto_s3](https://rusoto.github.io/rusoto/rusoto_s3/) * AWSのクライアントの設定は各自で === # RusotoでS3 ------------- ## ステップ1 * プロジェクトを作る ``` console $ cargo new rusoto-example-s3 Created binary (application) `rusoto-example-s3` package $ cd rusoto-example-s3 $ cargo add rusoto_core rusoto_s3 Adding rusoto_core v0.36.0 to dependencies Adding rusoto_s3 v0.36.0 to dependencies ``` === # RusotoでS3 ------------- ## ステップ2 * クライアントを作る ``` rust use rusoto_s3::{S3Client, S3}; fn main() { let client = S3Client::new(\"ap-northeast-1\".parse().unwrap()); } ``` === # RusotoでS3 ------------- ## ステップ2 ポイント * サービス毎にクライアントとトレイトが定義されてる + `S3Client` - 実体。ほぼ `S3` を実装するためのもの + `S3` - S3への操作の全て * テストしやすい構造 === # RusotoでS3 ------------- ## ステップ3 * クライアントを使う ``` rust use rusoto_s3::{CreateBucketConfiguration, CreateBucketRequest}; client .create_bucket(CreateBucketRequest { bucket: bucket.clone(), create_bucket_configuration: Some(CreateBucketConfiguration { location_constraint: Some(\"ap-northeast-1\".into()), }), ..Default::default() }) .sync() .expect(\"create bucket failed\"); ``` === # RusotoでS3 ------------- ## ステップ3 ポイント * API単位で型が定義されている(自動生成) + O 型から使い方がわかる + X 型定義多すぎ * 必須パラメータ以外は `Option` だから デフォルト値で埋める + [構造体更新構文](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax)は知ってるかな？ + `..Default::default()` * 返り値は `Future` だから必要に応じて `sync` しよう === # RusotoでS3 ------------- ## ステップ4 * 完成 ``` rust use rusoto_s3::{ CreateBucketConfiguration, CreateBucketRequest, GetObjectRequest, PutObjectRequest, }; use rusoto_s3::{S3Client, S3}; use std::io; fn main() { let client = S3Client::new(\"ap-northeast-1\".parse().unwrap()); let bucket = \"test.blacekenedgold\".to_string(); client .create_bucket(CreateBucketRequest { bucket: bucket.clone(), create_bucket_configuration: Some(CreateBucketConfiguration { location_constraint: Some(\"ap-northeast-1\".into()), }), ..Default::default() }) .sync() .expect(\"create bucket failed\"); client .put_object(PutObjectRequest { bucket: bucket.clone(), key: \"test\".into(), body: Some(\"κeenさんだよー ⸜( ¯⌓¯ )⸝ \".to_string().into_bytes().into()), ..Default::default() }) .sync() .expect(\"put object failed\"); let out = client .get_object(GetObjectRequest { bucket: bucket.clone(), key: \"test\".into(), ..Default::default() }) .sync() .expect(\"get object failed\"); if let Some(body) = out.body { let mut body = body.into_blocking_read(); let mut out = io::stdout(); io::copy(\u0026mut body, \u0026mut out).expect(\"output failed\"); } } ``` === # RusotoでS3 ------------- ## ステップ4 ``` console $ cargo run Compiling rusoto-example-s3 v0.1.0 (/home/shun/Rust/rusoto-example-s3) Finished dev [unoptimized + debuginfo] target(s) in 2.61s Running `target/debug/rusoto-example-s3` κeenさんだよー ⸜( ¯⌓¯ )⸝ ``` === # まとめ -------- * RustからAWSのAPIが叩けるRusotoがあるよ * Rusotoは一見複雑だけど基本を押さえたら難しくないよ * Rusotoをみんな使うと公式サポートくるかもね === # 次回予告 ---------- * AWS LambdaをRustで書く完全ガイド * @[Rust LT #3 ](https://rust.connpass.com/event/122377/) (3/25)   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2019-03-12","title":"Rustから扱うAWS API","url":"https://KeenS.github.io/slide/rustkaraatsukauaws_api/"},
  {"body":"κeenです。Atsushi Ohori, Katsuhiro Ueno, and Hisayuki Mima. 2018. Finitary Polymorphism for Optimizing Type- Directed Compilation. Proc. ACMProgram. Lang. 2, ICFP, Article 81 (September 2018), 29 pages. を読んだメモ。 見ての通り大堀研からの論文で、29ページある長めの論文です。 私の、私による私のためのメモなので正確性やわかりやすさなどは求めないで下さい。\n大堀研の論文なので理論からSML#への実装まで一気通貫で書かれていますが、私が興味あるのは最適化以降の部分。\n背景とか 論文ではさらっと流されていますが、いくつか押さえておいた方が良いSML#の機能があります。\nランク1多相 SMLは冠頭多相ですがSML#はランク1多相ができます。 例えば以下のような foo 関数を定義したとします。\n# fun foo x y z = (x, y + 1, z); val foo = fn : [\u0026#39;a. \u0026#39;a -\u0026gt; int -\u0026gt; [\u0026#39;b. \u0026#39;b -\u0026gt; \u0026#39;a * int * \u0026#39;b]] これを以下のように x と y だけ適用しても多相な関数が返ってきます。\n# foo 3.14 1; val it = fn : [\u0026#39;a. \u0026#39;a -\u0026gt; real * int * \u0026#39;a] $\\lambda$ と $\\Lambda$ で書くとこうですかね。2階のラムダ計算になります。\n\\[ \\Lambda \u0026lsquo;a: *. \\lambda x: \u0026lsquo;a. \\lambda y: int. \\Lambda \u0026lsquo;b: *. \\lambda z: \u0026lsquo;b. (x, y, z) \\]\n詳しくは以下を読んで下さい。 ランク１多相性の理論\nオーバーロード SMLではびみょーにオーバーロードが導入されていますが、型が決まらない場合は int 型に推論されるという中途半端な仕様になっています。 SML#ではちゃんとオーバーロードされた型が推論されます。\n# op +;; val it = fn : [\u0026#39;a::{int, word, int8, word8,...}. \u0026#39;a * \u0026#39;a -\u0026gt; \u0026#39;a] カインドが * ではなく、もう少し情報が増えます。\n多相レコード SMLはレコードに多相性はありませんがSML#は多相レコードがあります。 例えば以下のように person 型を定義したとします。\n# type person = {name: string, age: int};; type person = {age: int, name: string} これを更新する関数のつもりで以下の incAge 関数を定義すると、 age フィールドを持つレコード全般に対する関数として推論されます。\n# fun incAge (p as {age,...}) = p#{age = age + 1};; val incAge = fn : [\u0026#39;a#{age: int}. \u0026#39;a -\u0026gt; \u0026#39;a] 多相レコードを実現するために、SML#ではレコードの中における age フィールドのオフセットを一緒に渡しています。つまり普通のレコードと比べていくらかオーバーヘッドがあります。 多相であることに越したことはないんですが、これはたまに困ったことになります。 例えば struct Person 内で 引数 p といえば person 型と思って書いていても、SML#は多相レコードとして推論してしまうので無駄に多相に、無駄に遅くなってしまいます。\n多相レコードとそのコンパイルに関しては多少はレコード多相性の理論にかかれていますが、カインドを用いてコンパイルする手法などは挙げられている論文を読んだ方がいいと思います。\nFFI SML#はタプルとCの構造体のABI互換を保証します。\n例えばCの以下のような構造体を考えます。\nstruct foo { int a; double b; }; これはSML#の int * real 型と互換です。さらに、'a * real 型の 'a に int を当てはめた型も struct foo と互換です。\n一見当たり前のように見えて、GC付き言語でこういうABIを実現するのは結構骨です。例えばRubyだと値は全部 VALUE 型になっていて、Cの構造体とは互換性がありません。 なのであくまでRubyとCの連携ははC拡張を書く形になっていて、RubyだけからCを呼び出すようにはできていません。 ところがSML#ではSML#だけからCを呼び出せるようになっています。データレイアウトやGCアルゴリズムを工夫したおかげですね。 さらに、先に挙げたように多相なデータ型についてもCに渡す時点では単相になっていれば互換であるとされているので、もうちょっと工夫が必要です。 全部静的に分かるのと一部実行時に型が分かるのとでは大違いですからね。データの後ろにGC向けのタグを入れたりして実現しています。\n分割コンパイル OCamlの分割コンパイルは.cmoファイルに依存するので(合ってる？)完全に依存関係を断ち切ってはコンパイルできませんが、SML#は1ファイル単位でバラバラにコンパイルできます。make -j32 すると本当に32並列でコンパイルできます。 そのため、ファイルを跨ぐコードはどうしても保守的にABIを決めないといけません。 例えば多相関数はどのような型を当てはめて使われるか分からないままコンパイルされます。 テンプレートのように使われる型が分かってからインスタンス化するような戦略は取れないんですね。 なのでどうしても実行時に情報を渡すようになります。\ntype reification SML# 3.3.0からtype reificationが使えます。オーバーロードや多相レコードと同じくカインドに情報を持たせる形で実現されています。\n# pp;; val it = fn : [\u0026#39;a#reify. \u0026#39;a -\u0026gt; unit] # pp 1; 1 val it = () : unit # pp {name = \u0026#34;κeen\u0026#34;, age = 26};; {age = 26, name = \u0026#34;κeen\u0026#34;} val it = () : unit 概要 レコード多相だとか型クラスだとかのカインドに色々な情報を持たせるスタイルだと、単純なパラメータ多相の実装(多分 void * 相当のことかな)では間に合わなくなります。 特にSML#のようにランク1多相があると顕著ですね。\nそこで型主導でコンパイルし、関数の引数を増やして型情報を渡してコンパイルする手法があります。それこそ多相レコードのコンパイルとか。しかし余計な引数を増やすと遅くなるのは当たり前です。 これをどうにかできないかというのを 理論方面から 解決したのがこの論文です。MLtonみたいに全ての型の使用を調べてインスタンス化するだとか前にブログに書いたようにSwiftみたくカインド情報を部分評価して最適化するなどの実装は存在しました。SML#は分割コンパイルがあるのでMLtonのようにWhole Program AnalysisはできませんがSwiftくらいのものはできます。 そういうことができる計算体を導入して、最適化も形式化したというお話ですね。\nSwiftのように多相な関数を型に合わせてインスタンス化できる背景には、コンパイル時には型の使用状況が分かっていて、それが有限個なので個別に特殊化できるというのがあります。 この論文でも有限個に対する多相、 有限多相(finitary polymorphism) が導入されています。有限性大事。 オーバーロードっぽい雰囲気を感じますが、 ロケーション $l_1$ では 型 int として扱われて ロケーション $l_2$ では 型 real として扱われて…というように {l_1: int, l_2: real, ...} となるので多相レコードじみています。 というか実際、多相レコードに帰着して解決しています。\nこの論文のコントリビューションは以下です。\n 有限多相計算を定義した: 二階の計算で、それぞれの型抽象が有限の型宇宙に制限されている。  このページの読者には釈迦に説法かと思いますが、「全ての型を表す集合」を型として扱ってしまうとラッセルのパラドックスになってしまうので型ではなくて宇宙という別の概念にしないといけません。 この計算は型主導最適化の形式化の副産物ですが、それ自体研究の興味の対象になりうると書かれています。私は研究者じゃないのであまり興味はないですが。  二階のλ計算の宇宙再構築アルゴリズムを開発した: 二階のλ計算は非可述(impredicative)なので型が付く場合にのみ再構築できる。 有限多相に基づいた型主導最適化のアルゴリズムの開発: どうやら、宇宙から型属性を引き出せるようにして、コンパイル時に簡約できるようにしたようです。 上記アルゴリズムの分割コンパイルへの拡張: SML#分割コンパイルのスキームだと多相関数の最適化(単相化)は「あきらめる」が最良になりそうですが、ちゃんとコンパイル単位を跨いでも最適化できるようにしたようです。ついでに多相関数内で使われる多相関数も単相化できるようです。 SML#への実装: 論文へは添付されているようですが、まだSML#としてはリリースされていないようです。 計測: 83.79%の多相が取り除かれ、平均して15%速くなったようです。  2章で有限多相計算の定義、3章でその値呼び操作的意味論下での健全性の証明、4章で有限多相計算をもう少し低レベルにした(宇宙を閉じた)計算の導入、5章で二階のラムダ計算の有限多相へのコンパイルアルゴリズム、6章で本命の型主導最適化、7章で分割コンパイルへの拡張、8章で実装とベンチマークが載せられています。\n以後、6章以降の解説を書こうとしたのですが論文にも書いてあるとおり、形式化したのが主な内容なので最初の計算体系部分を飛ばすと「うん、そうだね」となってしまいます。 元論文読みましょう。私のまとめ力の足りなさが露呈しましたね。\n因みに6章のおおまかなステップを抜き出すと、1. kinded type reconstruction 2. type directed transformation 2(a). type-attribute term generation 2(b).type attribute passing transformationとなっています。 カインド情報からメタデータを取り出してパラメータに渡す訳なのでカインド付き型を再構築してから型属性を生成して、それを渡すのは自然な流れですね。 流れは自然ですがちゃんとやるのはつらいというのが伝わってきます。\n感想とか 頑張って解説しようとしましたが、普通に元論文読んだほうが早いことに気づいてやめました。 今回あまり触れなかったfinitary calculsも二階なのに可術という点で面白いので理論面で興味ある方は読むといいと思います。\nカインドに色々情報もたせるのはSML#ではオーバーロードに多相レコード、type reificationと色々あるのでこれはかなり効く最適化なんじゃないでしょうか。 特に、ABIではなくて最適化として導入されたので分割コンパイルを保ったまま速くできるのが良いと思います。 実際、8割強の型抽象を除去できたとあるので大方の「抽象化されてすぎてしまう」問題は気にならなくなると思います。 個人的にはtype reificationの機能を増やしてほしかったので「この手法をtype reificationに適用してSML#に実装しました」とかの報告がくるのを待っています。 type reificationでimplicit modulesを殴って欲しい。\nところで、performance evaluationではコンパイルオプションが書かれてないのですがLLVMの最適化オプションはどうなってるんでしょうね。 手法的には有効だけど既にLLVMがやってくれてて、SML#的にはあまり速くなってなかったとかだと悲しいなぁ。\n","categories":["論文メモ"],"category_urls":["/categories/%e8%ab%96%e6%96%87%e3%83%a1%e3%83%a2"],"date":"2019-03-02","title":"論文メモ: Finitary Polymorphism for Optimizing Type-Directed Compilation","url":"https://KeenS.github.io/blog/2019/03/02/ronbunmemo__finitary_polymorphism_for_optimizing_type_directed_compilation/"},
  {"body":"κeenです。なんか雑にIdrisでキューライブラリを作ったので紹介します。\nひとまずコードはこれ。\n関数型キューというのがあります。関数型プログラミングでよく使うデータ構造にリストがあります。 リストは先頭への操作が速いのでスタックとして使うのに向いています。 一方でキューは後ろに入れて前から取り出します。 後ろから入れるのがリストには向いていないのですが、リストを2つ用意して入れるときは後ろのリスト、取り出すときは前のリストから操作すれば両方速いだろというのが基本的なアイディアです。 前のリストが空になったら後ろのリストをreverseして前のリストにします。1要素につき1回しかreverseが走らないので平均するとenqueue/dequeueが $O(1)$ で実現できます。 だいたいこんな感じで実装されます。\ndata Queue : Type -\u0026gt; Type where MkQueue: (front : List a) -\u0026gt; (back : List a) -\u0026gt; Queue a empty : Queue a empty = MkQueue [] [] enqueue : Queue a -\u0026gt; a -\u0026gt; Queue a enqueue (MkQueue front back) x = MkQueue front (x :: back) dequeue : Queue a -\u0026gt; (Maybe a, Queue a) dequeue (MkQueue (x :: xs) back) = (Just x, MkQueue xs back) dequeue (MkQueue [] []) = (Nothing, MkQueue [] []) dequeue (MkQueue [] back) = dequeue (MkQueue (reverse back) []) 関数型キューなので変更前のデータも残るのが特徴です。上記のコードは操作前のデータを再利用するとパフォーマンス的によろしくない場合があるのですが詳しくはググって下さい。\nで、今回はこれの依存型版、長さ情報も型に持ったものを作ろうというお話です。List に対して Vect があるように 普通のキューに対して長さ情報を持ったキューを作ります。\nデータ型の定義はこのようになります。\nimport Data.Vect export data Queue : Nat -\u0026gt; Type -\u0026gt; Type where MkQueue: {l, m: Nat} -\u0026gt; (front : Vect l a) -\u0026gt; (back : Vect m a) -\u0026gt; Queue (l + m) a リストではなく Vect を使っていますね。 Queue : Nat -\u0026gt; Type -\u0026gt; Type と型コンストラクタの引数が1つ増えて長さ情報を持ちます。 また、 MkQueue の方も front と back の長さ合計が全体の長さなのでそのような定義になっています。\n上記定義から即座に以下のような関数は書けますね。\nexport empty : Queue 0 a empty = MkQueue [] [] export isEmpty : Queue n a -\u0026gt; Bool isEmpty (MkQueue [] []) = True isEmpty _ = False export length : Queue n a -\u0026gt; Nat length (MkQueue front back) = (length front) + (length back) Idrisの関数はオーバーロードできるので Queue の length の定義中で Vect の length を呼んでいます。\nさて、このまま enqueue を実装しようとするとエラーになります。\nexport enqueue : Queue n a -\u0026gt; a -\u0026gt; Queue (1 + n) a enqueue (MkQueue front back) x = MkQueue front (x :: back)- + Errors (1) `-- Queue.idr line 26 col 3: When checking right hand side of enqueue with expected type Queue (1 + (l + m)) a Type mismatch between Queue (l + S m) a (Type of MkQueue front (x :: back)) and Queue (S (plus l m)) a (Expected type) Specifically: Type mismatch between plus l (S m) and S (plus l m) Idrisの自然数は1進数を採用しているので 1+m は S m と表記されていますし、 1 + (l + m) は S (plus l m) と表記されています。\n返り値の型は 1 + n と書いています。 実際の型は front の長さを l 、back の長さを m とすると、返している値の型は front は変化しないので長さ l のまま、 back は1要素追加しているので 1 + m になっています。 これを併せると l + (1 + m) になります。 もちろん、 l + m = n が成り立っているので人間が手で計算する限りでは正しい型の値を返しています。しかしIdrisはそこまで計算してくれないのでコンパイルエラーになります。 なのでIdrisコンパイラに「両者の型は同じなんだよ」と教えてあげる必要があります。 今回は l + m = n というのが分かっているので l + (1 + m) が 1 + (l + m) と等しいことを納得させてあげるとコンパイルが通ります。\nまず、 MkQueue の内部で使われている変数 l と m を捕捉しましょう。くるくる括弧で暗黙のパラメータを捕捉できます。\nexport enqueue : Queue n a -\u0026gt; a -\u0026gt; Queue (1 + n) a enqueue (MkQueue {l} {m} front back) x = ... 次に l + (1 + m) と 1 + (l + m) が等しいと納得させる手段ですが、 Prelude.Nat に以下のような関数が定義されています。\nplusSuccRightSucc : (left : Nat) -\u0026gt; (right : Nat) -\u0026gt; S (left + right) = left + S right 完全に我々が求めているものですね。これを使ってIdrisを納得させるのは rewrite 構文が使えます。 なので enqueue は以下のように書けます。\nexport enqueue : Queue n a -\u0026gt; a -\u0026gt; Queue (1 + n) a enqueue (MkQueue {l} {m} front back) x = rewrite plusSuccRightSucc l m in MkQueue front (x :: back) rewrite で返り値の型の Queue (1 + n) a を S (left + right) = left + S right を使って左辺 → 右辺の書換えをしています。\nさて、同様に dequeue です。 まずはナイーブに実装してみると enqueue 同様にエラーが出ます。\nexport dequeue : Queue (1+n) a -\u0026gt; (a, Queue n a) dequeue (MkQueue (x :: xs) back) = (x, MkQueue xs back) dequeue (MkQueue [] back) = dequeue (MkQueue (reverse back) [])- + Errors (1) `-- Queue.idr line 33 col 3: When checking right hand side of dequeue with expected type (a, Queue n a) When checking an application of Queue.dequeue: Type mismatch between Queue (S n + 0) a (Type of MkQueue (reverse back) []) and Queue (1 + n) a (Expected type) Specifically: Type mismatch between plus (S n) 0 and S n 同様に書換えてあげればよさそうですね。今回は +0 を潰したいので同じく Prelude.Nat にある以下の関数を使います。\nplusZeroRightNeutral : (left : Nat) -\u0026gt; left + fromInteger 0 = left はい、これで１丁あがり。\nexport dequeue : Queue (1+n) a -\u0026gt; (a, Queue n a) dequeue (MkQueue (x :: xs) back) = (x, MkQueue xs back) dequeue {n = n} (MkQueue [] back) = rewrite plusZeroRightNeutral n in dequeue (MkQueue (reverse back) []) …と思いきや以下のエラーが出ます。\n- + Errors (1) `-- Queue.idr line 32 col 2: When checking right hand side of dequeue with expected type (a, Queue n a) rewriting plus n 0 to n did not change type (a, Queue n a) エラーを見ると「rewrite しようとしたけど書き直せる部分がなかったぜ」と言っています。 よくみると plus (S n) 0 → S n の書換えをしたいのに、 右辺 → 左辺を見ると left → left + 0 なので書き換える方向が逆ですね。 rewrite の向きを逆にしたくなります。 Idrisにはそういう機能が用意されていて、組み込み関数に sym というのがあります。\nsym : (left = right) -\u0026gt; right = left rewrite そのものを変えるのではなくて書換えルールの型の方を変えます。 この sym を用いて dequeue は以下のように実装できます。\nexport dequeue : Queue (1+n) a -\u0026gt; (a, Queue n a) dequeue (MkQueue (x :: xs) back) = (x, MkQueue xs back) dequeue {n = n} (MkQueue [] back) = rewrite sym (plusZeroRightNeutral n) in dequeue (MkQueue (reverse back) []) はい、これで関数型キューができました。繰り返しますが、これは値の再利用を考えたら中途半端なので詳細はBanker\u0026rsquo;s Queueなどでググって下さい。 今回は主に依存型と少しばかりの証明のお話でした。\n","categories":["Idris","型","依存型"],"category_urls":["/categories/idris","/categories/%e5%9e%8b","/categories/%e4%be%9d%e5%ad%98%e5%9e%8b"],"date":"2019-02-28","title":"Idrisで依存キュー","url":"https://KeenS.github.io/blog/2019/02/28/idrisdeizonkyu_/"},
  {"body":"κeenです。いわれてみれば当たり前なんですが最近気づいたこと pthread_create に渡してるのって要するにクロージャなんですね。\npthread_create は以下のようなシグネチャです。\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); ここの void *arg が void *(*start_routine) (void *) に引数として渡されます。 void * だと情報量がないですが、要はジェネリクスですよね。ML風に型を付けるとこうなるでしょうか。\nval pthread_create: pthread_t * pthread_attr_t * (\u0026#39;a -\u0026gt; ()) * \u0026#39;a -\u0026gt; int しかしどちらかというと start_routine が引数に受け取る型を知っていて、それに合わせてデータを渡すので存在型をつけたくなります。 引数内の存在型なのでML多相と同値ですし問題ないでしょう。\nexists \u0026#39;a, (\u0026#39;a -\u0026gt; ()) * \u0026#39;a この形、どこかで見覚えがあります。 Closure Conversion as CoYoneda に出てくるクロージャの型とそっくりですね。\n\\[ A \\to B \\cong \\exists \\Gamma.\\Gamma \\times (\\Gamma \\times A \\to B) \\]\nよく考えたら高級な言語(クロージャのある言語)だとspawnの引数に渡すクロージャは () -\u0026gt; () なことが多いですね。\n実装上の解釈をすると、クロージャは関数とそれが捕捉した環境の組で実装されることが多いです。その関数と環境を2つに分けて引数に渡していると考えれば納得できます。 なるほどー。\n","categories":["小ネタ"],"category_urls":["/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2019-02-17","title":"pthread_createに渡してるのってクロージャだったんだ","url":"https://KeenS.github.io/blog/2019/02/17/pthread_createniwatashiterunottekuro_jadattanda/"},
  {"body":"G. Ottoni. \u0026ldquo;HHVM JIT: A Profile-Guided, Region-Based Compiler for PHP and Hack,\u0026rdquo; PLDI 2018 を読んだメモ。\nPLDIのaccepted paper。FacebookよりHHVMの第2世代JITエンジンで使われている手法の紹介。 Method JITでもTracing JITでもなくRegionベースでJITする話。\nHHVMはHackとPHPを動かすが、Hackの型情報は捨ててしまう。Hackの型システムはunsoundらしい。世知辛い。\nバイトコードインタプリタとJITでOSRして相互に実行を交代できる「よくある」JITエンジン。\nHHVMのJITでは以下の4つをしている。\n type specialization profile-guided optimizations side exits region-based compilation  このうちside exitsとregion-based compilationが私は初見だった。\nside exitsはコンパイルされたコードの途中で抜けるやつ。インタプリタに戻ったり、さらに最適化されたコードに跳んだりする。 TraceMonkeyとかHotSpotとかで使われているらしい。\nregion-based compilationはタイトルにもなっているように設計上重要な部分。JITコンパイルするときの粒度。 メソッド単位、基本ブロック単位、トレース単位など色々にある。 リージョンベースコンパイルについては以下を参照とのこと Richard E Hank, Wen-Mei W Hwu, and B Ramakrishna Rau. 1995. Region-based compilation: An introduction and motivation. In Pro- ceedings ofthe International Symposium on Microarchitecture. 158–168 。リージョンがなんなのか具体的な説明がないまま進んでいく…。 恐らく任意の粒度のバイトコードかな？例えば 「a の型が int と分かっている区間」のような単位でバイトコードを切り取っていそう。\nJavaなどの静的な言語に比べて動的な言語ではよりリージョンの恩恵が大きいらしい。\n面白いのが最適化のところ。\n 1つのトリガで全部のコンパイルをするらしい。Whole Program Optimizaionが可能になる。 関数をよく呼び出す組同士で並べるとTLBミスが減ってパフォーマンスが改善するらしい Huge Pageによく呼ばれるコードを置くとやはりI-TLBミスが減って速くなるらしい。 code bloatを防ぐために前提条件ゆるくしてコンパイルする  自分にとって目新しい部分だけ抜き出したので気になった人は論文読んで。\n","categories":["論文メモ"],"category_urls":["/categories/%e8%ab%96%e6%96%87%e3%83%a1%e3%83%a2"],"date":"2019-02-16","title":"論文メモ: HHVM JIT: A Profile-Guided, Region-Based Compiler for PHP and Hack","url":"https://KeenS.github.io/blog/2019/02/16/ronbunmemo__hhvm_jit__a_profile_guided__region_based_compiler_for_php_and_hack/"},
  {"body":"L. Yinan, N. R. Katsipoulakis, B. Chandramouli, J. Goldstein, D. Kossmann. \u0026ldquo;Mison: A Fast JSON Parser for Data Analytics,\u0026rdquo; Proceedings of the VLDB Endowment, Volume 10 Issue 10, June 2017, p1118-1129. を読んだメモ。 本当にただのメモなので内容を知りたければ論文を読むように。\nApache Spark や Apache Drill などいわゆるビッグデータを処理するソフトウェアでJSONをパースするのに無視できないコストが掛かる。 特に、JSONにクエリを投げるのに一旦パースしてからクエリを処理するのにはかなり無駄が多い。Parquetなどのフォーマットもあるが、MisonはJSONのまま処理を高速化した。 事前変換が必要ないので手軽に利用できる。\n面白いのがパースの技法。岐の塊である有限状態機械(FSM)を使ったパースではなく、構造インデックスを目的とすることでSIMDによる処理を可能にした。\nJSONの構造に興味があるので着目するのは {, }, : など。: を見つければ直前がキーだし、 { や } を見つければネスト関係が分かる。 なので : の位置をビットマップで保持すると簡単にキーが見つかる。さらに、クエリに応じてネストレベルが決まるのでネストレベル毎に情報を持つと手っ取り早い。\n例えば以下のようにJSONにインデックス付けされる。\nJSON {\u0026#34;id\u0026#34;:\u0026#34;id:\\\u0026#34;a\\\u0026#34;\u0026#34;,\u0026#34;reviews\u0026#34;:50,\u0026#34;attributes\u0026#34;:{\u0026#34;breakfast\u0026#34;:false,\u0026#34;lunch\u0026#34;:true,\u0026#34;dinner\u0026#34;:true,\u0026#34;latenight\u0026#34;:true},\u0026#34;categories\u0026#34;:[\u0026#34;Restaurant\u0026#34;,\u0026#34;Bars\u0026#34;],\u0026#34;state\u0026#34;:\u0026#34;WA\u0026#34;,\u0026#34;city\u0026#34;:\u0026#34;seattle\u0026#34;} Lv1 0000010000000000000000000010000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000010000000000010000000000 Lv2 0000000000000000000000000000000000000000000000000000000100000000000001000000000000010000000000000000100000000000000000000000000000000000000000000000000000000000000000000000 これがあれば簡単にクエリを処理できることが分かると思う。\nこのインデックスは現実的にはワード単位で処理し、さらにリトルエンディアンでひっくり返ったりするがだいたいこのまま。\nさて、ここで問題になるのがクォート。\u0026quot; や \\ を意識しながらパースしないといけない。 しかしこれもbitmapに落とし込める。{, }, : に加えて \u0026quot; と \\ のbitmapも作る。 例えば上記JSONの最初の256bitだとこう。\nJSON {\u0026#34;id\u0026#34;:\u0026#34;id:\\\u0026#34;a\\\u0026#34;\u0026#34;,\u0026#34;reviews\u0026#34;:50,\u0026#34;a `\\` 00000000001001000000000000000000 `\u0026#34;` 01001010000100110100000001000010 `:` 00000100010000000000000000100000 `{` 10000000000000000000000000000000 `}` 00000000000000000000000000000000 構造を見ずにデータだけを見てるので簡単にSIMDで処理できることが見て取れる。\n\\ のbitmapを1シフトして自身とANDを取るなどすればエスケープされてない \\ の位置が取れる。 エスケープされていない \\ を1シフトしたものとクォートでANDを取ればエスケープされたクォートが取れる。 それ以外が構造的クォートだ。\nこの処理をすると以下のように構造的クォートだけが得られる。\nJSON {\u0026#34;id\u0026#34;:\u0026#34;id:\\\u0026#34;a\\\u0026#34;\u0026#34;,\u0026#34;reviews\u0026#34;:50,\u0026#34;a S-\u0026#34; 01001010000000010100000001000010 ここから文字列部分を表すマスクを作る。詳しいアルゴリズムは論文を読んでくれ。\nJSON {\u0026#34;id\u0026#34;:\u0026#34;id:\\\u0026#34;a\\\u0026#34;\u0026#34;,\u0026#34;reviews\u0026#34;:50,\u0026#34;a mask 00111001111111110011111111000001 ワード単位で処理しているので前のワードで文字列中に入っていたらこのマスクをflipしないといけない。 このマスクから構造的 : や { , } の位置が分かる。 あとは多少のアルゴリズムでレベル別の : のインデックスが作れる。詳細は論文を読んでくれ。\nさらにはクエリに応じた投機的パースなんかもやってるらしい。\nクエリ処理用なので、プロトコルでやり取りするようなJSONのパースに向いているかは知らないが、エスケープ文字の処理の扱いが面白かった。\n","categories":["論文メモ"],"category_urls":["/categories/%e8%ab%96%e6%96%87%e3%83%a1%e3%83%a2"],"date":"2019-02-16","title":"論文メモ: Mison: A Fast JSON Parser for Data Analytics","url":"https://KeenS.github.io/blog/2019/02/16/ronbunmemo__mison__a_fast_json_parser_for_data_analytics/"},
  {"body":"κeenです。たまにお薦めコンパイラの本教えてなどのやりとりをTwitterで見かけるのでまとめておきます。 私の主観が入っているので他の方の意見も参考にして下さい。\n普通の入門書三書 よく挙げられるのは通称「ドラゴンブック」、「タイガーブック」、「中田先生の最適化なんちゃらの本」です。 このうちのどれかを読むと良いでしょう。 こういう教科書系の本によくあることですが、本だけでなく挙げられている参考文献の情報も重要なので読み終わっても売らないで本棚に残しておくことをお薦めします。\nコンパイラ[第2版]～ 原理・技法・ツール ～ いわゆるドラゴンブックです。結構古くからある本です。前半が構文解析の理論で、後半でコンパイラ関連の技法などが載っています。 割と技法の紹介が多く、幅は広いですがそれぞれの説明に割かれた紙面は小さいです。\n章分けが雑なので目次だけで内容を判断せず、手にとって確かめたほうが良いです。 因みに初版と二版で結構内容が変わっているので必ず二版を買いましょう。\n想定している言語がCやFortranなので複雑な言語機能の実現方法はあまり載っていません。 代わりにコード解析やコード生成の話が多く載っています。\nコンパイラのお勉強、裏で何をしているかを知るには良いですが実際に実装したい人には向かないです。\n最新コンパイラ構成技法 いわゆるタイガーブックです。ドラゴンブックに比べてコンパクトです。 ドラゴンブックのように色々な技法を紹介したりはしていませんが、コードや疑似コードが載っているので覚えたことをそのまま実装しやすくなっています。 あと、著者がAppelです。Appelは Standard ML of New Jersey の開発者なので実装も交えた本を書きます。個人的にAppelの本は面白くて好きです。コードもSMLですし。\nTiger言語を作りながら解説していくスタイルです。Tiger言語に必要ない技法はあまり触れられていないです。 しかし発展編でオブジェクト指向、関数型なども扱いますし、ガベージコレクションも1章割いて説明しています。 代わりに最適化の話題は少ないです。\n自作言語を作りたいという人に向いています。\nコンパイラの構成と最適化 通称はないですが、よく「中田先生の最適化なんちゃらの本」と呼ばれます。みんな名前覚えないんですね。\nタイトルに最適化が入っているように、第III部を丸々最適化に割いているのが特徴です。 配列の解析やループ最適化にも1章づつ割いてますし、他にも例えばJITへの言及なんかもあります。\n最適化を抜いた解析の話題はドラゴンブックとそう変わらないです。図が多い分こちらの方が分かりやすいです。 構文解析(フロントエンド)にページを割いたドラゴンブックか、最適化(バックエンド)にページを割いたこの本といったところです。\nModern Compiler Design 4書目。最近良さそうだなと思った本です。まだ読んでないです。Springerのサイト落ちてるけど大丈夫かな。\n内容はサンプルコードを出しつつ色々な技法に触れているのでタイガーブックを理論で肥らせたような本です。 オブジェクト指向、関数型、論理型プログラミング言語の実現方法も載っています。WAMが載っているのが素晴らしい。\n私は読んだこと無いのでどなたか紹介して下さい。\n片手間入門書 自作言語とまではいかないけど、野暮用で言語を作る必要があるという際に読む本です。\n言語実装パターン――コンパイラ技術によるテキスト処理から言語実装まで 言語の実装のパターンです。「こういうことをしたいときには3種類のパターンがある」のように実装例を挙げている本です。\nその他入門 ((Pythonで) 書く (Lisp) インタプリタ) Webの記事です。とりあえず動く、程度のLispインタプリタを作ります。短いので飽きっぽい人にお薦め。\nBuild Your Own Lisp 本もありますが、オンラインでも読めます。Cに入門しつつLispインタプリタを作ります。 コンパイラを書いているとCを避けられないことがあるので、一度入門するのは悪くないと思います。\n速攻MinCamlコンパイラ概説 MLコンパイラをMLで作る解説です。簡単な機能を簡単に実装しているだけなのでコンパクトで分かりやすいです。 簡単とはいってもクロージャなどCコンパイラよりは複雑な機能がありますのでやっつけCコンパイラよりはコンパイラ感があります。\nCompiling with Continuations Appelの本です。継続をベースにMLコンパイラをMLで書く本です。\nThe Implementation of Functional Programming Languages Simon Peyton Jonesの本です。似たような名前の同じくSPJの本がありますが、厚い方です。 読んだことはないのですが、お薦めされました。 対象がMirandaらしいですが、関数型一般の話題もあるようです。特にパターンマッチのコンパイルが恐らくこの本にしかないので貴重です。 後半は遅延評価のグラフ簡約だとかG-machineだとかを取り扱っているようです。いつか読みたい。\n薄い方、 Implementing Functional Languages はG-macineやTIMなど、ほぼグラフ簡約の話題でした。\n発展的話題 コンパイラに必要な部分だけに絞った本です。\nHigh Performance Compilers for Parallel Computers 主にベクトル最適化に絞った本です。多少Fortran特有の話もありますが、理論とアルゴリズムがメインなのであまりFortranは関係ないです。\n前半で解析に必要になる基本の線形代数から解説し、ループ誘導変数の発見だとかloop carried dependencyの発見だとかも触れられています。 後半でそれを活かした最適化をやる模様。 まだ読書会では解析の部分しかやってませんがself-containedですしアルゴリズムの疑似コードも載っていますし好評です。 ただし組版がひどいのと例題の数値などに誤りが多いので一人で読むには少しきつそうです。\nOptimizing Compilers for Modern Architectures NUMAやSIMD、マルチコア向けの最適化の本です。上記の本と被りそうであまり被らないです。 適当にしか読んでないのですがキャッシュのヒット率が上がる変換とか手続き間最適化などが載っています。 こちらもアルゴリズムが掲載されています。\nガベージコレクション 自動的メモリ管理を構成する理論と実装 いわゆるGC Handbook。 GCの基本から解説し、長年の研究成果を様々に紹介しています。メモリ管理にある程度踏み込むとOSやCPUのメモリ管理機構の知識が必要になりますが、それも解説されています。 GCは未だにOracle Labから新作がでていたりと最新の知識を身につけるのは難しいですがそれなりの基本知識を身につけるのにこの本は向いています。\n型システム入門 プログラミング言語と型の理論 いわゆるTaPL。tanakhさんの解説も参考にして下さい。\n型理論の入門書です。少しコンパイラの話題からは逸れますが周辺分野です。 主にコンパイラに機能を追加しようとするときに「本当に大丈夫か」と確認する手段になります。 「この機能を入れたい」「それを入れると決定不能になるから無理」のような判断が紙とペンだけでできます。\nLLVM 誰か良書知りませんか。きつねさん本は概要を知るには良い本ですがLLVMのバージョンが上がって知識をそのままは適用できないそうです。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2019-02-16","title":"お薦めのコンパイラの本とか","url":"https://KeenS.github.io/blog/2019/02/16/osusumenokonpairanohontoka/"},
  {"body":"κeenです。textlintを導入しようとしたら案の定nodeのツーリングで困ったので解決策を書き留めます。\nnodeくらい素直にインストールすればよさそうですが、あらゆる手段がダメでした。\n Emacsからtextlintを叩きたいので相性の悪いnodenvとnvmはなし apt経由だとnodeは入るがnpmは入らない。そしてnpmは依存関係が壊れていてインストールできない node公式のtarballにはインストールスクリプトがない  aptでnpmが壊れている様子です。\n$ sudo apt install npm パッケージリストを読み込んでいます... 完了 依存関係ツリーを作成しています 状態情報を読み取っています... 完了 インストールすることができないパッケージがありました。おそらく、あり得 ない状況を要求したか、(不安定版ディストリビューションを使用しているの であれば) 必要なパッケージがまだ作成されていなかったり Incoming から移 動されていないことが考えられます。 以下の情報がこの問題を解決するために役立つかもしれません: 以下のパッケージには満たせない依存関係があります: npm : 依存: node-gyp (\u0026gt;= 0.10.9) しかし、インストールされようとしていません E: 問題を解決することができません。壊れた変更禁止パッケージがあります。  nodenvやnvmのemacsプラグインを使う手もありますが別にnodeのバージョン管理をしたい訳ではないのでやりません。 デフォルトのパスくらい用意して欲しい……。ちゃんと調べたらあるのかな。\nnpmだけダウンロードしてこようとしたら、「nodeと一緒に配布されてるからそれ使え」と書いてありました。\nnode公式のtarballはbinとかlibとかが置かれているだけです。インストールスクリプト INSTALL ファイルはありませんし README にもインストール方法が書かれていませんでした。\n仕方ないので自分でスクリプトを書きました。 一応インストール、アンインストールともに動かして確認してます。\n  小言ですがインストール方法を提示するときは必ずアンインストール方法も提示しましょうね。 アンインストールが自明にインストールの逆操作ならいいんですが多くの場合そうでもないので。\n公式から落としてきたtarballを展開すると出てくるディレクトリにこのスクリプトを放り込んで叩くと1インストールできます。\n因みにtarballのSHA256のチェックサムはここにあるようです https://nodejs.org/dist/v10.15.1/SHASUMS256.txt.asc 。 どうしてダウンロードボタンの横にリンクを置いてくれないんだろう…。\nともあれ、これでインストールできました。つらい。\n 実際にはスクリプトを叩いたカレントディレクトリが該当ディレクトリであればいいのでスクリプトパスはどこでもいいのですが [return]  ","categories":["Linux","Ubuntu","nodejs","npm","JavaScript"],"category_urls":["/categories/linux","/categories/ubuntu","/categories/nodejs","/categories/npm","/categories/javascript"],"date":"2019-02-16","title":"Ubuntuにnodeとnpmをインストールする","url":"https://KeenS.github.io/blog/2019/02/16/ubuntuninodetonpmwoinsuto_rusuru/"},
  {"body":"κeenです。最近はIdrisで簡易ビルドツール作ってます。ある程度出来上がったらお披露目しますね。 さて、今回はIdrisで遅延評価を実現する型、 Lazy を紹介します。\n遅延評価とは 恐らくみなさんのお使いの言語では関数をネストして呼ぶ時、内側から評価しすよね。\n// これは f(n) を評価したあと g(..) を評価する g(f(n)) Idrisも同じです。ごく自然ですね。 この評価の順番(評価戦略)は 先行評価 (eager evaluation) と呼ばれます。 わざわざ名前がついているからも分かるとおり、これ以外の評価戦略もありえます。\n例えば、引数を評価しきって値になるのを待たずに関数を適用するのも考えられます。 例を出しましょう。今、 f と g を以下のように定義したとしましょう。\nf(x) = x + 1 g(x) = x * x このとき先行評価だと g(f(1)) は\ng(f(1)) // f(x) の x を 1 で置換 g(1 + 1) g(2) // g(x) の x を 2 で置換 2 * 2 4 と評価が進みますね。引数が値になってから関数が呼び出されます。\nところが、値になるのを待たずにそのまま置換すると、\ng(f(1)) // g(x) の x を f(1) で置換 f(1) + f(1) // f(x) の x を 1 で置換 (1 + 1) + f(1) 2 + f(1) // f(x) の x を 1 で置換 2 + (1 + 1) 2 + 2 4 のようになります。良し悪しはおいておいて、こういう評価戦略も考えられます。少しマクロに似ていますね。別物ですが。 この外側から評価する戦略は 名前呼び (call by name)と呼ばれます。 ただし賢明な読者ならお気づきのように f(1) の評価が2回走ってしまいます。これでは効率が悪いですね。 そこで、「1度計算した値を覚えておく」というのが考えられます。いわゆるメモ化です。\ng(f(1)) // g(x) の x を f(1) で置換 f(1) + f(1) // f(x) の x を 1 で置換。 (1 + 1) + f(1) 2 + f(1) // f(1) = 2 を覚えておく // f(1) = 2 なのでそのまま結果を使う 2 + 2 4 こういうメモ化する名前呼び評価は 必要呼び (call by need) だとか 遅延評価 (lazy evaluation) だとか呼ばれます。\nこれら3つの評価戦略は副作用がなければ同じ計算結果を返すことが知られています。\nさて、副作用がなければと但し書きしたのでもちろん副作用があると挙動に違いがあります。 よく言われるのが先行評価だと「if 関数」が書けないのです。以下はLispでよく引き合いに出される例です。\n(defun my-if (cond then else) (if cond then else)) 引数をそのまま if に渡しているので if と同じ挙動をしそうですが、関数が引数を先に計算してしまうので次のような呼び出しで挙動に違いが出ます。\n;; else節まで評価されてしまう (my-if t (print t) (print nil)) ;; =\u0026gt; t ;; =\u0026gt; nil ;; else節は評価されない (if t (print t) (print nil)) ;; =\u0026gt; t それ以外にも、先行評価は引数を丁度一回評価するのに対して、遅延評価は引数を高々一回しか評価しないので計算量が減ります。 よく知られた例は竹内関数を遅延評価で計算すると速い、というのがあります。\nIdrisでのLazyの使い方 普段と少し違う動きをする遅延評価ですが、Idrisでも使えます。使い方は簡単で、型に Lazy を適用するだけです。 するとその引数は遅延評価されます。 例えば、Idrisで 「if 関数」は以下のように定義できます。 Lazy が適用されている2つの a 型、仮引数でいうと t と e が遅延評価されます。\nifThenElse : Bool -\u0026gt; Lazy a -\u0026gt; Lazy a -\u0026gt; a ifThenElse True t e = t ifThenElse False t e = e 実際、if 式の内部実装としてこの関数が Prelude.Boolで定義されています。\nLazy は処理系で特別扱いされているので Lazy a 型の値から 結果の a 型の値を取得する処理を書く必要はありません。\nIdrisでのLazyの利用例 Lazy は不要な計算をしたくないだとか、if 式を関数で抽象化したいだとかで有用です。 例えば、 Maybe 型に値があればそれを返し、なければ計算するような処理は次のように書けますね。\ncase maybe of Just x =\u0026gt; x Nothing = calcX 10000 これを関数に抽象化するときに Nothing と分かるまで計算したくないので Lazy が便利です。以下は Prelude.Maybeより。\n||| Convert a `Maybe a` value to an `a` value by providing a default `a` value ||| in the case that the `Maybe` value is `Nothing`. fromMaybe : (Lazy a) -\u0026gt; Maybe a -\u0026gt; a fromMaybe def Nothing = def fromMaybe def (Just j) = j 例えば Rustでは同様の関数は即時評価してしまう unwrap_or(exp) と少し面倒な代わりに必要でなければ評価しなくて済む unwrap_or_else(|| exp) に分かれています。Idrisではこういう使い分けは必要ありません。\n同じく Ordering を辞書順に合成する関数にも Lazy が使われています。以下は Prelude.Interfacesより。\n||| Compose two comparisons into the lexicographic product thenCompare : Ordering -\u0026gt; Lazy Ordering -\u0026gt; Ordering thenCompare LT y = LT thenCompare EQ y = y thenCompare GT y = GT あるいは、 \u0026amp;\u0026amp; 演算子も Lazy を使った関数です。以下は Prelude.Boolより。\n||| Boolean AND only evaluates the second argument if the first is `True`. (\u0026amp;\u0026amp;) : Bool -\u0026gt; Lazy Bool -\u0026gt; Bool (\u0026amp;\u0026amp;) True x = x (\u0026amp;\u0026amp;) False _ = False 演算子のオーバーロードを許す大抵の言語ではショートサーキットできないので \u0026amp;\u0026amp; はオーバーロードできません。しかし Lazy があれば実現できるのです。\n他言語でのケース もちろん、遅延評価が使えるのはIdrisだけではありません。 Haskellは基本の評価戦略が遅延評価1なので有名ですし、他にもMirandaなど遅延評価を基本とする言語もあるようです。\nあるいはIdrisのように部分的にサポートしている言語だとScalaには lazy val というのがあって、変数を遅延評価するよう宣言できます。また、なんと、pass by nameというのもあり、名前渡しができます。\nライブラリレベルだとSchemeではプロミスと呼ばれていたり、SML/NJではサスペンドと呼んでいたりする機能があります。\nsignature SUSP = sig type \u0026#39;a susp val delay : (unit -\u0026gt; \u0026#39;a) -\u0026gt; \u0026#39;a susp val force : \u0026#39;a susp -\u0026gt; \u0026#39;a end ライブラリレベルなので他言語への移植は簡単ですが、一々 delay と force をつける必要があって面倒です。 言語レベルサポートとユーザレベルサポートの違いですね。\nまとめ 遅延評価は先行評価と違って引数を高々一回しか評価しないので計算が高速になるケースがあったり、 「if 関数」が作れたりと面白い特徴があります。 Idrisでもこれを簡単に使えて、いくつかの if 式の上に構築された処理を関数で抽象化できます。 また、Idrisだけでなくいくつか言語でも同様に遅延評価が使えます。\nたまにあると便利な機能、遅延評価を是非使ってみて下さい。\n 厳密には仕様上は「非正格」かな？どうせみんなGHCしか使わないし細かいことはいいんだよ。 [return]  ","categories":["Idris","Effective Idris"],"category_urls":["/categories/idris","/categories/effective-idris"],"date":"2019-02-14","title":"Effective Idris: Lazy","url":"https://KeenS.github.io/blog/2019/02/14/effective_idris__lazy/"},
  {"body":"κeenです。async/awaitって実装の都合と利便性の良い所取ってるよなーと常々思ってるのを言語化してインターネットに放流します。 何度か似たようなことを言ってるのですがスライドであることが多くてあまり情報量を詰め込めなかったのでブログにまとめます。\n非同期処理と継続 非同期処理は時間のかかる処理を待ち合わせずに別の処理をし、時間のかかる処理が終わってから元の処理を継続する仕組みです。\nlet url = \u0026#34;http://example.com\u0026#34; let html = fetch url (* この結果を待たずに別の計算をする *) (* fetch urlが終わったあとでここに戻ってきて後続の処理をする *) print html 「継続」や「後続」などのキーワードが出てきているとおり、継続の影がチラチラ見えます。 継続とはいってもスレッドのようなタスク単位で分割したいのでフルの継続ではなくて限定継続ですね。\n現実的には限定継続が使える言語はそう多くないのでユーザにCPS変換させて、コールバックという名前で継続を取ることが多いようです。\nlet url = \u0026#34;http://example.com\u0026#34;; fetch_url_cb(url, (html) =\u0026gt; { console.log(html); }); これで一応非同期実行は実現できるのですが、2つ問題があります。 1つは書きづらい点。コールバック地獄なんかの名前がついているのでも有名ですね。 本来は限定継続を使っていれば発生しない問題ですが、ユーザにCPS変換させるとまあ、そうなりますよね。 もう一つは過剰な要求をしている点。殆どの言語では関数(クロージャ)は何度も呼べます。 しかしコールバックは一度しか呼ばれないので何度も呼べる関数を要求するのは過剰です。 もうちょっと具体的に言うとローカル変数のアロケートはタスク単位でスタックになるのに、クロージャはヒープに置かれるので無駄になります。\nなのでワンショットで使える限定継続があれば問題は解決します。\nコルーチン そういうワンショットで使える限定継続はコルーチンという名前で知られています。 フルネームでいうとstackful asymmetric coroutineと言われるらしいです。\n実際、非同期処理とコルーチンを組み合わせた例はいくつかあって、crystalのfiberだとかgoのgoroutineだとかJavaのProject Loomだとかがあります。\nしかしこれらは言語設計の段階から準備しないとつらいものがあります。 Project Loomのように尋常ならざる努力をするなら別として、殆どの言語には後付けでコルーチンを入れるのはつらいでしょう。 ランタイムをかなりいじり、関数の呼び出しモデルを変えるなどしないと実装できないはずです。 30億のデバイスで動くJavaで既存の関数の互換性を損なわず、しかもパフォーマンス的にもペナルティのない実装をしようとしているJavaは本当にすごい。\nコルーチンの実装のどこがつらいかというとユーザレベルスレッドとも言われるように、スレッド相当の機能を実装しないといけない点です。 OSのスレッドの上にべったり実装していた関数呼び出し(コールスタックの実装)なんかがユーザレベルスレッドに移ってしまいます。 単純なインタプリタならそれもそこまで難しくないのですが大抵の実用言語はC拡張も持っているのでCの関数呼び出しまで制御下に置かないといけなくなります。 やるとしたら一大プロジェクトになるでしょう。\n一応Cレベルではコルーチンライブラリはありますが、実装はアセンブラになっているはずです(読んだこと無い)。可搬性を気にする人は注意しましょう。 もちろん、これで切り取れるスタックはCのスタックなのでインタプリタ言語での実装には使えません。あとネイティブ言語でもGC付き言語だとroot setがどうなるかは知りません。\nスタックレスコルーチン 関数呼び出しをサポートしない、1関数内で閉じたコルーチンだと簡単に実装できます。これはコールスタックが必要ないからか、stackless coroutineと呼ばれるようです。 言語によってはジェネレータと呼ばれるものがこれに相当するものもあります。 stackless coroutineはかなり簡単な仕組みで実装できます。 ステートマシンにすればそれで済みます。\n ランタイムに手を入れず、1関数内のプログラム変換だけで実装できるので後付けで言語に入れるにはもってこいです。 さらに特別な仕組みが必要ないということはパフォーマンス的にも優れます。最速なプログラムは何もしないプログラムですからね。 ただし関数呼び出しを飛び越えられないので恐ろしく不便です。ライブラリでコルーチン処理をする関数すら提供できません。\n合成可能性 言語次第ですが、スタックレスコルーチン(ジェネレータ)を合成可能にしているものもあります。というか合成可能なものをジェネレータということが多いかな？ 1つ1つのジェネレータは1関数内でしか制御できませんが、それらを合成可能にすることで関数を超えて組み合わせることができます。 例えばPythonのジェネレータは yield from で合成できます。\n# ジェネレータ関数を定義する。 # yield単体はそれが使われている関数内しか制御できない def upto(n): for i in range(1, 10): yield i def downto(n): for i in range(n,0,-1): yield i # ジェネレータ関数を組み合わせて使う def triangle(n): yield from upto(n) yield from downto(n) JavaScriptでも yield* というキーワードでジェネレータを合成できるみたいですね。\n1つ1つの機能は小さくても組み合わせられることで利便性が広がります。\nFuture 話が少し脇道に逸れて(戻って?)、非同期の話です。 言語によっては同じものをPromiseと呼ぶこともありますし、PromiseとFutureは別のものとして扱っている言語もあります。\n非同期処理の「いつか完了する」という概念を値にしたものです。 値なので第一級市民として扱えて、メソッドを定義できたり関数の引数に渡せたりします。 コールバック関数の設定をメソッド呼び出しにできます。\nlet url = \u0026#34;http://example.com\u0026#34;; fetch_url_ft(url) // ここの返り値がFutueとする  // Futureのthenメソッドが呼べて、それでコールバックを指定できる  .then((html) =\u0026gt; { console.log(html); }); こちらも値なので合成ができます。\nしかしコールバックよりは便利とはいえ、後続の処理を関数で渡すのでコールバックと同様の扱いづらさは残ります。\nasync/await Futureをジェネレータと同様に構文でラップしたものです。 Futureが内部モデルで、async/awaitが表層構文という関係です。\nlet url = \u0026#34;http://example.com\u0026#34;; let html = await fetch_async(url); console.log(html); さらなる一般化 Futureとジェネレータで同様の実装ができるということは、もっと一般化できるということです。 例えばScalaのfor式はそのようになっています。\n// ジェネレータの使い方 for (i \u0026lt;- 1 to 3) println(i) // Futureの使い方 val purchase = for { usd \u0026lt;- usdQuote chf \u0026lt;- chfQuote if isProfitable(usd, chf) } yield connection.buy(amount, chf) このほうが便利ですよね。 しかしこれには(脱糖と型システムの関係次第ですが)型システムに高カインド多相が必要になり、それなりの言語設計が要求されます。 高カインド多相は実用されている言語ではScalaくらいにしか実装されていないようです1。\nまとめ 非同期処理を簡潔に書けるようにするには(限定)継続やコルーチンなどの機能が欲しくなりますが、これらは実装/実行コストが重いです。 一方でFuture+async/awaitだと比較的楽に入れられる上にそこまで利便性を損ないません。\nここでよくある勘違いを指摘しておきます。\n async/awaitはCPS変換で実装されている → CPS変換でも実装できるけどもっと軽い方法があるよ async/awaitよりもFutureの方が好き → 直交する概念じゃないよ。Futureのためにasync/awaitがあるんだよ。 何故モナドを入れないのか → モナドを入れるには高カインド多相とかそれなりの機能が必要なんやで  たまーにこういう言説を見てもやもやしてたのでムシャムシャしてこの記事を書いた。\n Scalaのfor式は高カインド多相に依存してないのでややこしいですが… [return]  ","categories":["非同期"],"category_urls":["/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f"],"date":"2019-02-09","title":"async/awaitと合成可能性","url":"https://KeenS.github.io/blog/2019/02/09/async_awaittogouseikanousei/"},
  {"body":"κeenです。ちょっとづつGitLabを使っていこうとしてます。 RustでCIとクロスビルドができたので紹介します。\nGitLab CIとは GitLabはGitHubと違って1開発からデプロイまでの面倒をみるのでCIも付属しています。 外部サービスでない分コンフィグファイル置くだけで走り始めたり、CIの成果物をそのままバイナリリリースに置けたりします。\nまた、GitLabは利用形態にサービスとオンプレがありますが私は今回サービスの方で試しているのでオンプレで使いたい方は自分に合わせて読んでください。\n方針  想定ケースとしてはRustで書かれたCLIツールのCI  プラットホーム依存のコードはない想定  ひと目で何してるか分かる範囲で頑張る 1ファイルで済ませる 素性のよく分からないDockerイメージとかは使わない  コード これ。バイナリリリースの例はここ。適当にコピペしてお使い下さい。\n残念ながらmacOS向けには簡単はできそうになかったのであきらめました。SaaSでもmacOSのrunner提供してくれないかなー。 一応Linuxからのクロスコンパイルは成功例があるものの、よくわからないdockerイメージを使っているのと、ベースに使われているdockerプロジェクトが更新されていないようなので避けることにしました。手軽に出来る方法がありましたら情報、マージリクエストともにお待ちしております。\nWindowsはmingwのみビルドしています。クロスビルドのガイドを見るにMSVCは手軽にはビルドできなそうです。 それにバイナリを提供するという目的ではどちらか1つがあれば十分でしょう。\n次回予告 GitHub + Travis CIならtrustというおばけのようなプロジェクトがあります。 さまざまな環境でビルド/テストできるように整えられています。\nそれをGitLab CIに移植しようとしているのですが内部で使われているツールの問題で詰まってしまいました。 問題が解決できたらまた紹介記事を書こうと思います。\nノート GitLab 11.7からReleaseがリッチになりました。 しかしまだAPIレベルでのサポートで、CI/CDからスムーズに登録できるよう鋭意開発中とのことです。 今はリリースノートにリンクを手で書いてますがいずれ自動化されると思われます。\n 最近だとGitHub Actionsもありますが…。 [return]  ","categories":["Rust","GitLab"],"category_urls":["/categories/rust","/categories/gitlab"],"date":"2019-02-03","title":"GitLab CIでRustのCIとクロスコンパイル: お手軽編","url":"https://KeenS.github.io/blog/2019/02/03/gitlab_ciderustnocitokurosukonpairu__otegaruhen/"},
  {"body":"κeenです。Idris入門: 数当てゲーム | κeenのHappy Hacκing Blog、Idris入門: 二分木 | κeenのHappy Hacκing Blogで紹介したものをまとめつつ、適当に飛ばしていた部分を補います。\nぶっちゃけ公式ドキュメント見れば良さそうなんですがself-containedでない記事も嫌なので2つのチュートリアルで出てきたものを拾います。 ここではチュートリアルに出てきた構文しか拾わないのでその他の構文は各自書きながら覚えて下さい。\n念を押しますが私はIdrisにはそんなに詳しくないです。勢いで書いてるだけです。一次情報は公式ドキュメントです。\n構文 変数と型の字句 ドキュメントには書かれてないのですが、コンパイラのコードを見る限り識別子に使えるのは [a-zA-Z][a-zA-Z'_.]* のようです。 例えば hog'.'e12_ は適格なIdrisの変数定義です。\n変数に小文字始まり、型やバリアントには大文字始まりの識別子をつけるみたいです。\ndata Hoge = Fuga piyo : Hoge -\u0026gt; () piyo hoge = () 一応型やバリアントに小文字を使ったり変数に大文字を使ったりもできますが色々不都合が生じます。\ndata 代数的データ型と呼ばれるものです。色々な使いみちがあります。 例えば、列挙型のように可能な値を列挙することができます。\ndata Direction = Up | Down | Right | Left ここでの Up 、 Down 、 Right 、 Left のように列挙されたものをバリアント(列挙子)と呼びます。 バリアントそれぞれがコンストラクタになっています。どのバリアントを書いても Direciton 型の値が作れます。\nλΠ\u0026gt; Up Up : Direction λΠ\u0026gt; Down Down : Direction 列挙子はそれぞれ値を持てます。\ndata Few = None | One Int | Two Int Int | Three Int Int Int 値を持つ列挙子は単体では関数のように振る舞います。\nλΠ\u0026gt; One One : Int -\u0026gt; Few 具体的な値を渡してあげると Few 型の値を作れます。\nλΠ\u0026gt; One 3 One 3 : Few 代数的データ型のバリアントを1つにすれば構造体のような使い方もできます。\ndata Person = MkPerson Int String data からデータを取り出すにはパターンマッチを使います。\ngetName : Person -\u0026gt; String getName (MkPerson age name) = name コンストラクタと同じ形でエクストラクタを書けるので視覚的に分かりやすいですね。\nジェネリクス data 文はジェネリクスにできます。つまり、型引数を取れます。 名前に続けて型引数を導入し、定義部分で使います。小文字で書くと型変数になるようです。\ndata Tree a = Leaf | Node (Tree a) a (Tree a) 何も書いてませんでしたが型は自身を参照することもできます。 括弧は結合の優先順位を決めるのに使います。\n複数の引数を受け取るときは空白で並べて書きます。\ndata Either a b = Left a | Right b タプル タプルは組です。いくらでも異なる型のデータをまとめられます。\nλΠ\u0026gt; (1, 2.0, \u0026#34;3\u0026#34;) (1, 2.0, \u0026#34;3\u0026#34;) : (Integer, Double, String) その実はデータ型 Pair です。上記の定義は以下と同じです。\nλΠ\u0026gt; MkPair 1 (MkPair 2.0 \u0026#34;3\u0026#34;) (1, 2.0, \u0026#34;3\u0026#34;) : (Integer, Double, String) ところで、二分木のところで\n 今更ですが、ちょくちょく出てきていた () は空のタプルのことでした。\n と書きましたがこれは誤りでした。 () は明らかにペアじゃないですね。() はそれで1つのデータ型、 Unit 型です。\nλΠ\u0026gt; MkUnit () : () GADT data は別の記法もあります。 正式な呼び方がわからないのですが、ドキュメントではGADTスタイル構文と書かれています。以下のような構文です。\ndata 名前 : カインド where バリアント1: 型 バリアント2: 型 ... バリアントは関数としても振る舞うと説明しましたが、ここで書くバリアントの型は関数の型そのものなので分かりやすいですね。 因みにカインドとは型の型です。今回型を定義していて、その型を書くので型の型が必要になります。\n先程の Few はGADTスタイル構文でこのようにも書けます。\ndata Few : Type where None : Few One : Int -\u0026gt; Few Two : Int -\u0026gt; Int -\u0026gt; Few Three : Int -\u0026gt; Int -\u0026gt; Int -\u0026gt; Few カインドは今回は Type ですし、ジェネリクスのように型パラメータを取る型なら Type -\u0026gt; Type にもなるでしょう。\nIdrisは型の記述が柔軟なので明示的に型を書くこのスタイルだと都合が良いことが多いのです。\nまた、GADTだと各引数に名前を付けられるので構造体風定義もわかりやすくなります。\ndata Person : Type where MkPerson: (age : Int) -\u0026gt; (name : String) -\u0026gt; Person これに構文糖衣をかぶせると レコード 構文になります。\n値/関数定義 最初のチュートリアルで紹介したように以下の構文で値を定義します。\n名前 : 型 名前 = 式 関数の場合は引数を並べて書きます。\n名前 : 型 名前 引数1 引数2 .. 引数n = 式 Idrisは式指向ですのでreturn文のようなものはありません。関数の本体は計算したい式だけ書けば十分です。\n引数の位置ではパターンマッチができます。その際は節を並べます。\nshowDirection : Direction -\u0026gt; String showDirection Up = \u0026#34;Up\u0026#34; showDirection Down = \u0026#34;Down\u0026#34; showDirection Right = \u0026#34;Right\u0026#34; showDirection Left = \u0026#34;Left\u0026#34; 小文字で始まる識別子だと変数になります。\nmoveHorizontal : Direction -\u0026gt; Integer moveHorizontal Up = 1 moveHorizontal Down = -1 moveHorizontal other = 0 マッチした変数を使わないなら特別なパターン _ で無視することもできます。\nmoveHorizontal : Direction -\u0026gt; Integer moveHorizontal Up = 1 moveHorizontal Down = -1 moveHorizontal _ = 0 つまり、関数定義はもう少し複雑で、こういう構文です。\n名前 : 型 名前 バターン1_1 バターン1_2 .. バターン1_n = 値 名前 バターン2_1 バターン2_2 .. バターン2_n = 値 ... 名前 バターンm_1 バターンm_2 .. バターンm_n = 値 中置演算子 Idrisではユーザが任意の中置演算子を定義できます。 :+-*\\/=.?|\u0026amp;\u0026gt;\u0026lt;!@$%^~# の組み合わせを中置演算子に使えます。\n中置演算子を宣言するには infixl 優先度 記号 または infixr 優先度 記号 を使います。それぞれ左結合、右結合の演算子を定義します。 例えば +? を左結合の優先度4の演算子として定義するには以下のように書きます。\ninfixl 4 +? 中置演算子を定義する時は括弧で包んで関数と同じように定義します。\n(+?): Maybe Integer -\u0026gt; Integer -\u0026gt; Maybe Integer (+?) (Just x) y = Just (x + y) (+?) _ _ = Nothing こう定義してしまえば自由に使えます。\nλΠ\u0026gt; (Just 1) +? 2 +? 3 Just 6 : Maybe Integer λΠ\u0026gt; (Nothing) +? 2 +? 3 Nothing : Maybe Integer また、括弧で包めば関数としても使えます。\nλΠ\u0026gt; (+?) (+?) : Maybe Integer -\u0026gt; Integer -\u0026gt; Maybe Integer データ型のバリアントを中置演算子で定義することもできます。 これは標準ライブラリで定義されている例です。\ninfixr 10 :: data List a = Nil | (::) a (List a) 関数を中置で 任意の2引数関数を ` で囲むと中置で書けます。バックティック記法と呼ばれるようです。 バリアントも関数でしたからこのようにも書けます。\n1 `Two` 2 また、パターンマッチでも同様に中置記法で書けます。\nsum : Few -\u0026gt; Int sum None = 0 sum (One x) = x -- 中置記法でパターンマッチ sum (x `Two` y) = x + y sum (Three x y z) = x + y + z case とパターン 関数の引数でパターンマッチができますが、case を使えばそれ以外の場所でもパターンマッチができます。\nパターンはだいたいコンストラクタと1対1対応します。パターンはネスト可能です。 例えばFizz Buzz判定するパターンマッチはこう書けます。\nfizzBuzz : Integer -\u0026gt; String fizzBuzz n = case (n `mod` 3, n `mod` 5) of (0, 0) =\u0026gt; \u0026#34;FizzBuzz\u0026#34; (0, _) =\u0026gt; \u0026#34;Fizz\u0026#34; (_, 0) =\u0026gt; \u0026#34;Buzz\u0026#34; _ =\u0026gt; show n case 式があれば不要に思えますが if 式もあります。\nlet 計算の途中式に名前をつける構文です。\nlet パターン = 式 in 式 のように使います。\nquadruple : Integer -\u0026gt; Integer quadruple x = let double = x + x in double + double インターフェース インターフェースはデータ型間で共通の操作を定義する機能です。 インターフェースは以下の構文で定義でます。\n-- わかりやすさのため微妙に嘘をついてます interface インターフェース名 対象の型 where 関数1 : 型 関数2 : 型 ... デフォルト実装(あれば) ... where 以降はオフサイドルールですね。インターフェースの関数はメソッドと呼びます。\n例えば同値比較のインターフェースはこう定義されています。\ninterface Eq a where (==) : a -\u0026gt; a -\u0026gt; Bool (/=) : a -\u0026gt; a -\u0026gt; Bool x /= y = not (x == y) x == y = not (x /= y) ジェネリクス型にインターフェース制約をつけるにはこう書きます。\nインターフェース名 対象の型 =\u0026gt; 型 複数のインターフェース制約はこうです。\nインターフェース名 対象の型 =\u0026gt; インターフェース名 対象の型 =\u0026gt; .. =\u0026gt; 型 例えば Either 型の値を文字列にする関数はこう書けます。\nshowEither : Show a =\u0026gt; Show b =\u0026gt; Either a b -\u0026gt; String showEither (Left l) = \u0026#34;Left \u0026#34; ++ show l showEither (Right r) = \u0026#34;Right \u0026#34; ++ show r do 記法 do 記法はMonadインターフェースのための構文糖衣です。IO だけでなく Monad を実装している型ならなんでも do 記法が使えます。 インターフェースの構文糖衣なので do そのものには意味がないのですが、キモチとしては「中身を取り出す」ような働きをします。 例えば Maybe は Monad を実装しているのでこう使えます。\naddMaybe : Maybe Integer -\u0026gt; Maybe Integer -\u0026gt; Maybe Integer addMaybe x y = do x\u0026#39; \u0026lt;- x y\u0026#39; \u0026lt;- y Just $ x\u0026#39; + y\u0026#39; このコードのキモチは Maybe に包まれた x と y からInteger 型の値 x', y' を取り出し、足し算しています。もちろん取り出せるのは Just のときのみで、 Nothing のときはすぐさま Nothing が返ります。\nパターン \u0026lt;- で取り出した値に更にパターンマッチできます。 パターン \u0026lt;- 式 | パターン =\u0026gt; 式 | パターン =\u0026gt; 式 ...の形です。\n荒唐無稽な例ですが受け取った値が1と2だった場合だけ足し算するにはこう書きます。\naddOneAndTwo : Maybe Integer -\u0026gt; Maybe Integer -\u0026gt; Maybe Integer addOneAndTwo x y = do 1 \u0026lt;- x | _ =\u0026gt; Nothing 2 \u0026lt;- y | _ =\u0026gt; Nothing Just $ 1 + 2 コメントとドキュメントコメント -- ではじまるのがコメント、 ||| ではじまるのがドキュメントコメント。\nドキュメントコメントは色々書式があるみたいです。\n名前空間 Idrisのコードは以下のような形になっています。\n\u0026lt;モジュールヘッダ\u0026gt;? \u0026lt;インポート文\u0026gt; \u0026lt;コード\u0026gt; モジュールヘッダ module モジュール名 です。あってもなくてもいいです。1ファイル1モジュールです。 ドットで区切った階層構造です。一応ファイル名とは関連がないことになってますが、Foo/Bar.idr には module Foo.Bar モジュールを定義するのが通例です。たまに Foo.Bar と書いてモジュールではなくファイル Foo/Bar.idr のことを指す記法もあるので注意が必要です。\nインポート文 import モジュール名 です。人によっては混乱すると思いますが、 import Data.Vect で Vect モジュール内の全てのアイテムが今の名前空間にインポートされます。 単純にモジュール名を略記したいなら import Data.Vect as V などで別名をつけることになります。\n値と型 関数 関数も値です。気軽に変数を束縛できます。\nadd : Integer -\u0026gt; Integer -\u0026gt; Integer add = (+) Idrisの関数は1引数をとり、1返り値を返します。複数の引数を受け取りたい時は関数をネストすると複数の引数を受け取れるように見えます。\n例えば以下の2つの定義は同等です。\nadd: Integer -\u0026gt; Integer -\u0026gt; Integer add = \\x =\u0026gt; \\y =\u0026gt; x + y add : Integer -\u0026gt; Integer -\u0026gt; Integer add x y = x + y 同様に、関数適用も1引数の適用の連続です。 以下の2つは同等の表現です。\nadd 1 2 (add 1) 2 型も、 Integer -\u0026gt; Integer -\u0026gt; Integer は Integer -\u0026gt; (Integer -\u0026gt; Integer) の意味です。\n複数引数関数にみえるのは実は関数の集合体なので中途半端に使うこと(部分適用)もできます。\ninc : Integer -\u0026gt; Integer inc = add 1 型の扱い Idrisでは型も第一級です。型の型は Type です。\nλΠ\u0026gt; Int Int : Type ジェネリクスになっている型は引数を受け取ると型になる、要は型を受け取って型を返す関数なのでType -\u0026gt; Type 型になります。\nλΠ\u0026gt; Maybe Int Maybe Int : Type λΠ\u0026gt; Maybe Maybe : Type -\u0026gt; Type ジェネリクスと関数適用が同じ構文な理由が理解できたかと思います。 型エイリアスも値と同じように定義できます。\nOption : Type -\u0026gt; Type Option = Maybe 余談ですが Type の型は Type 1 です。\nλΠ\u0026gt; :t Type Type : Type 1 あとは想像出来ますね。 Type 1 : Type 2, Type 2 : Type 3, .. とずっと続いていきます。\nプリミティブ型 Idrisのプリミティブ型は思ったより少ないです。\n Int : 固定長整数 Integer : 多倍長整数 Double : 倍精度浮動小数点数 Char : 文字 String : 文字列 Ptr : FFI用  あとは裏では8bitから64bitまでの整数もあるようですがドキュメントには載ってないです。\n真偽値などはライブラリで定義されています。\ndata Bool = False | True ライブラリ ドキュメントに記述が見つけられなかったのですが、Idrisはデフォルトでいくつかのライブラリをリンクしています。\n プリミティブ : 処理系組み込みの機能 ビルトイン : Idrisで書かれているが処理系が特別扱いする プレリュード : デフォルトでインポートされているライブラリ群 ベース : インポートはされていないがいつでもインポートできるライブラリ群  プリミティブは型のところで紹介したプリミティブ型の他に雑多な関数などがあるようです。ビルトインはタプルやユニット、 ifThenElse などです。\nプレリュードはトップレベル関数相当で、例えば何気なく使っていた putStrLn はPrelude.Interactiveで定義されています。\nベースはデフォルトでリンクするライブラリで、標準ライブラリ相当です。Data.ComplexやSystemのようなものがあります。\nその他にもIdrisと一緒に配布されている contribやeffectsなんかもあります。Data.SortedMapなんかもcontribにあるのでcontribを使う機会は多いでしょう。\n以下に、出てきた関数やデータ型を紹介します。\nプリミティブ - は負号ではなく、符号反転の前置演算子のようです。どのユーザ定義演算子より優先順位は高いです。\n$ はプリミティブの中置演算子のようです。結合は右結合で、どのユーザ定義演算子より弱い優先順位を持ちます。 下記2式は等価です。\nf (g (h x)) f $ g $ h x プレリュード Prelude Prelude にはシンプルな関数が定義されています。\nチュートリアルで使ったのはshiftL ですね\nshiftL: Int -\u0026gt; Int -\u0026gt; Int Prelude.Basics Prelude.Basics には基本的な操作が定義されています。\nthe the : (a : Type) -\u0026gt; a -\u0026gt; a 型アノテーションを書く関数です。他言語なら型アノテーションは専用の構文になってますが、Idrisだと型も第一級なのでこういう関数が書けます。\nλΠ\u0026gt; the Int 1 1 : Int λΠ\u0026gt; the Integer 1 1 : Integer 指定した型になっているのが分かると思います。\n(.) (.) : (b -\u0026gt; c) -\u0026gt; (a -\u0026gt; b) -\u0026gt; a -\u0026gt; c 一瞬混乱しますが、 (.) は関数を合成する関数(中置演算子)です。数学で $f(g(x))$ を $f \\circ g (x)$ と書くのに似せた記法ですね。 実際にはこう定義されています。\ninfixr 9 . ||| Function composition (.) : (b -\u0026gt; c) -\u0026gt; (a -\u0026gt; b) -\u0026gt; a -\u0026gt; c (.) f g = \\x =\u0026gt; f (g x) Prelude.Cast Prelude.Cast には型変換を管理するインターフェース、 Cast が定義されています。\ninterface Cast from to where cast : (orig : from) -\u0026gt; to いくつかの変換が用意されています。\nλΠ\u0026gt; the String (cast 1) \u0026#34;1\u0026#34; : String λΠ\u0026gt; the Integer (cast (the Int 1)) 1 : Integer λΠ\u0026gt; the Double (cast 1) 1.0 : Double びっくりなことに、文字列→数値の変換もあります。しかし無効な文字列を与えると0が返ってきてしまうようです。\nλΠ\u0026gt; the Integer (cast \u0026#34;123abc\u0026#34;) 0 : Integer Prelude.Interfaces Prelude.Interfaces には基本的な二項演算などのインターフェースが定義されています。\ndata Ordering = LT | EQ | GT infix 6 \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= interface Eq ty =\u0026gt; Ord ty where compare : ty -\u0026gt; ty -\u0026gt; Ordering (\u0026lt;) : ty -\u0026gt; ty -\u0026gt; Bool (\u0026lt;) x y with (compare x y) (\u0026lt;) x y | LT = True (\u0026lt;) x y | _ = False (\u0026gt;) : ty -\u0026gt; ty -\u0026gt; Bool (\u0026gt;) x y with (compare x y) (\u0026gt;) x y | GT = True (\u0026gt;) x y | _ = False (\u0026lt;=) : ty -\u0026gt; ty -\u0026gt; Bool (\u0026lt;=) x y = x \u0026lt; y || x == y (\u0026gt;=) : ty -\u0026gt; ty -\u0026gt; Bool (\u0026gt;=) x y = x \u0026gt; y || x == y max : ty -\u0026gt; ty -\u0026gt; ty max x y = if x \u0026gt; y then x else y min : ty -\u0026gt; ty -\u0026gt; ty min x y = if (x \u0026lt; y) then x else y チュートリアルでは Ordering と compare を使いましたがその他の演算子も用意されています。\n同様に数値演算も定義されています。\ninfixl 8 + infixl 9 * interface Num ty where (+) : ty -\u0026gt; ty -\u0026gt; ty (*) : ty -\u0026gt; ty -\u0026gt; ty fromInteger : Integer -\u0026gt; ty interface Num ty =\u0026gt; Neg ty where negate : ty -\u0026gt; ty (-) : ty -\u0026gt; ty -\u0026gt; ty infixl 9 `div`, `mod` interface Num ty =\u0026gt; Integral ty where div : ty -\u0026gt; ty -\u0026gt; ty mod : ty -\u0026gt; ty -\u0026gt; ty mod や div は n `mod` m の形で使われることを想定して演算子の結合性や優先順位が指定されています。\nPrelude.Strings Prelude.String には文字列操作に関する関数が定義されています。 意外にもチュートリアルで使ったのは2つだけでした。\ninfixl 7 ++ unpack : String -\u0026gt; List Char (++) : String -\u0026gt; String -\u0026gt; String Idrisのようにデータ型が便利な言語だと文字列は人間とのやりとりくらいでしか使わないので思ったほど出番は多くないです。\nPrelude.Chars Prelude.Chars には文字に関する関数が定義されています。文字を扱うことはあまりないと思いますが、Idrisでも操作はそんなに多くないです。\n今回使ったのは文字→数値変換の ord ですね。\nord : Char -\u0026gt; Int Idrisはバックエンドが複数あるのでどう変換されるかはバックエンド依存としています。 が、REPLではユニコードのスカラ値が返っているようです。\nλΠ\u0026gt; ord \u0026#39;κ\u0026#39; 954 : Int Prelude.List Prelude.List にはリストに対する操作が定義されています。 実はリストに固有の操作はチュートリアルでは使っていません。 map や foldl などはリストに限らない汎用の関数として定義されているのです。\nリストはこのように定義されています。\ninfixr 7 :: data List : (elem : Type) -\u0026gt; Type where Nil : List elem (::) : (x : elem) -\u0026gt; (xs : List elem) -\u0026gt; List elem 関数型言語のユーザには馴染みの在る定義ですね。以下のようにいくつかの (::) と末尾の Nil で構成されます。\nλΠ\u0026gt; 1 :: 2 :: 3 :: Nil [1, 2, 3] : List Integer 再帰関数を書くときも (::) と Nil で分岐します。分かりやすいですね。\nsum : List Integer -\u0026gt; Integer sum Nil = 0 sum (x::xs) = x + (sum xs) Prelude.Maybe Prelude.Maybe には Maybe 型とそれに関連する関数が定義されています。\nMaybe は以下のように定義されています。\ndata Maybe : (a : Type) -\u0026gt; Type where Nothing : Maybe a Just : (x : a) -\u0026gt; Maybe a Maybe はあるかないか分からない値を表すのに使います。 チュートリアルでは Maybe 本体しか触らず、他の関数は使いませんでした。 do 記法のところで紹介した通り、 Maybe にも do は使えますしその他 map なんかも使えます。\nPrelude.Either Prelude.Either には Either 型とそれに関連する関数が定義されています。\nEither は以下のように定義されています。\ndata Either : (a, b : Type) -\u0026gt; Type where Left : (l : a) -\u0026gt; Either a b Right : (r : b) -\u0026gt; Either a b Either もデータ型本体しか使わず、周辺の関数は使いませんでした。\nEither は2つの型をとるジェネリクスですが、関数と同じく部分適用できるので左の型だけ決めた Either なんかも作れます。\nλΠ\u0026gt; Either Int Either Int : Type -\u0026gt; Type 逆に右の型だけ決めた(左を自由にした) Either は作れません。 こういう事情があるので右の型のほうが少し扱いやすくなっています。\nPrelude.Functor Prelude.Functor には Functor インターフェースが定義されています。\ninterface Functor (f : Type -\u0026gt; Type) where map : (func : a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b Functor は 「map 可能な型」のイメージです。 List にある map を一般化して色々な型に使えるようにしたものです。\nf はカインド Type -\u0026gt; Type を持ちます。f に List を当てはめると map : (func : a -\u0026gt; b) -\u0026gt; List a -\u0026gt; List b ですし、 Maybe をあてはめると map : (func : a -\u0026gt; b) -\u0026gt; Maybe a -\u0026gt; Maybe b です。 左の型だけ決めたEither Int も Type -\u0026gt; Type でしたので Functor の実装がされています。\n因みに、 map を中置演算子にした \u0026lt;$\u0026gt; というのもあります。\nλΠ\u0026gt; negate \u0026lt;$\u0026gt; (Just 1) Just -1 : Maybe Integer Prelude.Applicative Prelude.Applicative には Applicative インターフェース と Alternative インターフェースが定義されています。\ninfixl 3 \u0026lt;*\u0026gt; interface Functor f =\u0026gt; Applicative (f : Type -\u0026gt; Type) where pure : a -\u0026gt; f a (\u0026lt;*\u0026gt;) : f (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b infixr 2 \u0026lt;|\u0026gt; interface Applicative f =\u0026gt; Alternative (f : Type -\u0026gt; Type) where empty : f a (\u0026lt;|\u0026gt;) : f a -\u0026gt; f a -\u0026gt; f a チュートリアルで使ったのはApplicative の pure です。\nすこし分かりづらいですが、 Applicative は1つの捉え方として Functor を多引数関数に拡張したものとみれます。 例えばMaybe Integer 同士を足し算するとしましょう。 map (\u0026lt;$\u0026gt;) を多引数関数に適用すると Maybe (Integer -\u0026gt; Integer) と Maybe に包まれた関数がでてきてしまいます。\nλΠ\u0026gt; add \u0026lt;$\u0026gt; (Just 1) Just Integer : Maybe (Integer -\u0026gt; Integer) そこで Applicative の \u0026lt;*\u0026gt; を使うと Maybe に包まれた関数と Maybe に包まれた値を計算できます。\nλΠ\u0026gt; add \u0026lt;$\u0026gt; (Just 1) \u0026lt;*\u0026gt; (Just 2) Just 3 : Maybe Integer pure というのは何もしないコンストラクタです。List なら pure x = [x] ですし Maybe なら pure x = Just x です。 これがあるとMaybe に包まれた型と包まれてない型を混ぜて計算できます。\nλΠ\u0026gt; add \u0026lt;$\u0026gt; (Just 1) \u0026lt;*\u0026gt; (pure 2) Just 3 : Maybe Integer Alternative にいついては説明を省きます。以下の例でなんとなく分かるかと思います。\nλΠ\u0026gt; Nothing \u0026lt;|\u0026gt; (Just 1) Just 1 : Maybe Integer λΠ\u0026gt; (Just 1) \u0026lt;|\u0026gt; Nothing Just 1 : Maybe Integer λΠ\u0026gt; the (Maybe Integer) empty Nothing : Maybe Integer Prelude.Monad Prelude.Monad には Monad インターフェースが定義されています。do 記法の中身ですね。 join または \u0026gt;\u0026gt;= で実装が与えられます。相互に変換できるので本質的には両者には代わりはありません。\ninfixl 1 \u0026gt;\u0026gt;= interface Applicative m =\u0026gt; Monad (m : Type -\u0026gt; Type) where (\u0026gt;\u0026gt;=) : m a -\u0026gt; ((result : a) -\u0026gt; m b) -\u0026gt; m b join : m (m a) -\u0026gt; m a -- default implementations (\u0026gt;\u0026gt;=) x f = join (f \u0026lt;$\u0026gt; x) join x = x \u0026gt;\u0026gt;= id join は flatten というと分かりやすいでしょうか。Functor では包んでる型を変えず、Applicative では包んでる型を増やし (pure) 、 Monad になって型を減らす(join)操作がでてきました。\nMonad (\u0026gt;\u0026gt;=)のキモチは、「前のアクション(m a)から結果(a)を受け取って次のアクション(m b)を作る」操作です。 getLine \u0026gt;\u0026gt;= putStrLn とかですね。これを do 記法で書くとこうなります。\ndo input \u0026lt;- getLine putStrLn input Prelude.Foldable チュートリアル中でも紹介したとおり、 Foldable は関数型的内部イテレータです。\ninterface Foldable (t : Type -\u0026gt; Type) where foldr : (func : elem -\u0026gt; acc -\u0026gt; acc) -\u0026gt; (init : acc) -\u0026gt; (input : t elem) -\u0026gt; acc foldl : (func : acc -\u0026gt; elem -\u0026gt; acc) -\u0026gt; (init : acc) -\u0026gt; (input : t elem) -\u0026gt; acc コレクションならだいたい実装できそうですよね。\nFunctor , Applicative , Monad, Foldable あたりでコレクションというかジェネリックなデータ型の操作は一通りできるんじゃないでしょうか。あとはPrelude.Traversableにも多少操作があります。\n例えば for_ 。\nmain : IO () main = for_ [1, 2, 3] $ \\x =\u0026gt; printLn x Prelude.Interactive Prelude.Interactive には標準出入力に関わる関数が定義されています。\nputStr : String -\u0026gt; IO () putStrLn : String -\u0026gt; IO () 見た目の通り文字列を表示します。Ln が付くと改行も表示します。\ngetLine : IO String 標準入力から文字列を取得する IO アクションです。\nPrelude.File Prelud.File にはァイル操作関連の関数が定義されています。\nopenFile : String -\u0026gt; Mode -\u0026gt; IO (Either FileError File) fGetChars : File -\u0026gt; Int -\u0026gt; IO (Either FileError String) closeFile : File -\u0026gt; IO () data Mode = Read | WriteTruncate | Append | ReadWrite | ReadWriteTruncate | ReadAppend 特筆することはないですね。\nBase Idrisはプレリュードがリッチすぎるのでチュートリアルの範囲ではBaseはほとんど使いませんでしたね。\nData.String ほんの少しだけ文字列操作関数が定義されています。 チュートリアルではこの関数を使いました。\nparsePositive : String -\u0026gt; Maybe Integer なんかバグってるくさい のですが直される気配なし\nその他 ひとまずこれでチュートリアルシリーズは締めようと思います。 気が向いたらEffective Idrisとかそういうのを書くかもしれません。\n","categories":["Idris","Idris入門"],"category_urls":["/categories/idris","/categories/idris%e5%85%a5%e9%96%80"],"date":"2019-01-25","title":"Idris入門: リファレンス","url":"https://KeenS.github.io/blog/2019/01/25/idrisnyuumon__rifarensu/"},
  {"body":"κeenです。コミットを1つに纏めたいときに git rebase -i を使って最初のコミットだけ pick 、それ以外は squash にするのはよくやりますよね。 定形作業をするのが煩わしくなったのでそれをワンライナーにまとめてみました。\nTL;DR $ EDITOR=\u0026#39;sed -i \u0026#34;2,\\$s/^pick/squash/\u0026#34;\u0026#39; git rebase -i \u0026lt;リベース元コミット\u0026gt; \u0026amp;\u0026amp; git commit --amend  git rebase はとても危険なコマンドなので馴れてる人が手間を省くために使って下さい。 何も知らずにこのページにたどり着いた方は悪いことを言わないので git rebase --interactive の使い方を調べるところから始めましょう。\n解説 まず、このようなログがあるとします。\ncommit bb3db0607fb5730f0726f581485aed54f951dde3 (HEAD -\u0026gt; master) Author: κeen \u0026lt;3han5chou7@gmail.com\u0026gt; Date: Thu Jan 24 14:28:42 2019 +0900 add d commit 2db04c2cbb4d8d519da8aeccd3a3b21395a8364e Author: κeen \u0026lt;3han5chou7@gmail.com\u0026gt; Date: Thu Jan 24 14:11:06 2019 +0900 add c commit 2ca1e93e628a69dd630b371273f7a7f7d8a9b253 Author: κeen \u0026lt;3han5chou7@gmail.com\u0026gt; Date: Thu Jan 24 14:10:49 2019 +0900 add b commit 66cd45364b1d1d39330b1c647cf2221afd505e47 Author: κeen \u0026lt;3han5chou7@gmail.com\u0026gt; Date: Thu Jan 24 14:10:44 2019 +0900 add a これを普通に git rebase -i したらエディタが立ち上がりこうなりますね。\npick 2ca1e93 add b pick 2db04c2 add c pick bb3db06 add d # Rebase 66cd453..bb3db06 onto 66cd453 (3 commands) # # Commands: # p, pick \u0026lt;commit\u0026gt; = use commit # r, reword \u0026lt;commit\u0026gt; = use commit, but edit the commit message # e, edit \u0026lt;commit\u0026gt; = use commit, but stop for amending # s, squash \u0026lt;commit\u0026gt; = use commit, but meld into previous commit # f, fixup \u0026lt;commit\u0026gt; = like \u0026#34;squash\u0026#34;, but discard this commit\u0026#39;s log message # x, exec \u0026lt;command\u0026gt; = run command (the rest of the line) using shell # d, drop \u0026lt;commit\u0026gt; = remove commit # l, label \u0026lt;label\u0026gt; = label current HEAD with a name # t, reset \u0026lt;label\u0026gt; = reset HEAD to a label # m, merge [-C \u0026lt;commit\u0026gt; | -c \u0026lt;commit\u0026gt;] \u0026lt;label\u0026gt; [# \u0026lt;oneline\u0026gt;] # . create a merge commit using the original merge commit\u0026#39;s # . message (or the oneline, if no original merge commit was # . specified). Use -c \u0026lt;commit\u0026gt; to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # # Note that empty commits are commented out 2つ目以降の pick を squash にしてこうしたいはずです。\npick 2ca1e93 add b squash 2db04c2 add c squash bb3db06 add d Viならコマンド :2,$/^pick/squash/ でできますがワンライナーに組み込めません。そこでsedを使って編集します。 それが EDITOR='sed -i \u0026quot;2,\\$s/^pick/squash/\u0026quot;' git rebase -i \u0026lt;リベース元コミット\u0026gt; の部分。sedもviも源流はedなのでコマンドを使い回せて便利ですね。 ただしこれだとgitのプロセス中のエディタ全部がsedに置き換わってしまいます。特にrebase戦略を編集したあとコミットメッセージを編集する部分までエディタを乗っ取ってしまいます。 どうしようか悩んだのですがそこは諦めることにしてコミットしたあとでメッセージを編集することにします。それが git commit --amend の部分。\n気に入ったらサブコマンドにする選択肢もあるかもしれません FYI: 便利な「git-サブコマンド」を作成する\nHappy Hacκing~\n","categories":["小ネタ","Git"],"category_urls":["/categories/%e5%b0%8f%e3%83%8d%e3%82%bf","/categories/git"],"date":"2019-01-24","title":"gitのrebaseでsquashをワンライナーで","url":"https://KeenS.github.io/blog/2019/01/24/gitnorebasedesquashwowanraina_de/"},
  {"body":"文系でプログラマーになったけど色々失敗して３年半で会社を辞めた話｜denkigai｜noteという記事を読みました。 この記事に書かれていることが私の身にも覚えがあります。特に私と同い年の方のようなので自分に重ねてしまうところもあります。 ですが多少似たところはあってもやっぱり他人なので全然違う体験もしています。そういう体験を書いてみようと思います。もし該当記事を読んで絶望した人がいるなら別の例もあるよということで参考にしてください。\n私は「パソコンの中身が知りたい。多分プログラミングとかいうやつを勉強したら分かる気がする。」くらいのモチベーションでプログラミングをはじめました。 ゴールがあやふやですし、結局のところ「プログラミングをする」が目標になってるので迷子になるのは必至ですね。実際そういう時期がありました。 そんな私でも今はプログラマとして生きています。以下に、私が遭遇した課題とそれをどう解決(あるいは迂回)したかを示します。\nところで、該当記事中でも文系プログラマという呼称は不適切とされていますが、私は理系の人間でした。 プログラミングはあまり教育法の確立されていない領域なので多くの人が大なり小なり似たような問題を抱えていると思います。\n課題1: 何をすればいいか分からなかった 私は大学生の内にプログラミングに入門しました。 独りで勝手にやってるので良さげなチュートリアルも見つけられず、インターネットにあるRubyの入門記事で言語機能を勉強しました。 するとどんな機能があるかは分かってもそれで何をしたらいいのか、何を作れるのかが全然分からない状況になりました。\n解決1-1: 本を読んだ 大学生は知識で困ったら図書館に頼るのが吉です。Rubyの入門書をみつけて読みました。 内容は同じ入門でも切り口が違うと自分の勘違いが解けたり疑問が解消したりします。 また、チュートリアルのように「作って学ぶ」系の本だと何をしたらいいかが多少分かるようになりました。\n解決1-2: コードを読んだ 自分独りではどうしようもなさそうなので他人の書いたコードを読んでました。 Rubyの標準ライブラリとか。WEBRickが教科書的なコードときいて読みましたがそもそもHTTPが何をしてるのかもわからないので「分からん」となったりもしました。 何をしているのかは分からなくても「コードをファイルに分けるんだ」とか「だいたいクラスとかモジュールとかで機能を分けるんだ」などは分かりました。\n課題2: プログラミングで作りたいものがなかった プログラミングを勉強しはじめて半年とかそのくらいの時期ですかね。 この頃には動くものを作れるくらいにはなりました。 しかしプログラミング自体が目的なので作りたいものがありません。 シューティングゲームを作るチュートリアルをやってみてもゲームに興味がないのでその後の進展がありません。 それにチュートリアルをやっても自分で考える能力は身につかないので先に行きづらいんですよね。 このあたりで迷子になりました。\n迂回2-1: 勉強を目的にした 自分のやりたいことがないので「知らないこと、わからないことを勉強する」を目的にしました。 本を読んだりWebの記事を読んだり。流石にインプットばかりだと飽きるのでブログを作って学んだことをまとめたりしました。\n迂回2-2: OSSに貢献した 自分の作りたいものがないので既に作られているものに乗っかる戦略を採りました。 OSSとはいっても最初は翻訳とかで、gitとGitHubに慣れてから少しづつプログラムの方にも貢献していきました。 レッドオーシャンなRubyなどではかなり難しい戦略かもしれませんが、Common Lispのようにブルーオーシャンな言語なら案外貢献の余地は残っています。\n課題3: 今後の方向性が分からなかった 入門から1,2年経った頃ですかね。ある程度普段の作業というか、やることは決まるようになりました。 しかし今後の方向性というか雰囲気というか、プログラマと呼ばれる人たちが何をしているのか、何が常識的知識で何を当たり前のようにこなせばいいのかが分かりませんでした。 このときには行動原理として「プログラミングとは勉強だ」となってました。それでも勉強をするにもどっちに向かって進めばいいのかが全然わからないのです。\n解決3-1: 勉強会に参加した 実在のプログラマが集うとされる地、勉強会に参加しました。 このときはじめて、自分しか知らない宇宙語と思ってた言葉がその場に居る人に通じたのを見て感動しました。プログラマは本当にいたんだ。 そこで職業プログラマの方をつかまえて「普段どんなことをしているんですか」とか聞いてイメージを作っていたりしました。 あと、発表を聞いて聴衆の反応をみて「ここは常識なんだ」とか「こういうことをすると面白がられるんだ」とか色々学ぶ点がありました。\n解決3-2: コンテストに参加した 実際には解決を求めて行動したわけではないですが、結果論として解決になりました。 Webアプリケーションを高速化するコンテストに参加したら、何もできませんでした。そこで自分に足りない能力というのを把握できました。 ありがたいことにコンテストの解説ブログがあったので、そこから色々なことを学べました。\nだいたいこのあたりで自立したというか閉塞感はなくなりました。周りを見渡せるようになったので自分で目的地を探して歩いていけるようになったのです。 概ね入門から3年とかそのくらいです。この時点でもやっぱりプログラミングは目的、「プログラミングとは勉強だ」となっていましたし、なんなら今でもそうです。\n冒頭で紹介した記事の彼も入社から3年半でフリーランスになっているのでプログラミングをやるにはそのくらいの時間が必要なんでしょう。 最も、バックエンドにフロントエンドにデザイン、会社員からフリーランスと経験した多才な彼とは違って私はバックエンドだけですが。\nちょっとここからオフトピックで私の考えを書きます。\n環境の違いとか 彼と私の入門時の環境を比べてみると丁度真逆になってることに気づくと思います。 彼は一応研修を受けて現場に配属され、やることが与えられました。しかし仕事なので時間の余裕がなかったようです。 私は誰にも縛られないので時間の余裕はありましたが、独りなので最初から手探りでした。 彼は急ぎすぎですし私は遠回りしすぎですね。 千仭の谷に突き落とすと自ら這い上がって成長する人も居るにはいますが、これにはその人の見極めが必要です。多くの人には手厚いサポートが必要でしょう。 逆に私のようなケースは今ならプログラミング学習支援も充実してますし独り四苦八苦するのは絶滅危惧種かもしれません。\n何をすればよかったのか 「xxxのタスクをする」くらい具体的な目標があっても今自分が立ってる場所からあまりに遠いところに目標があると迷子になります。 回りの人が途中にいくつかの道しるべを置いてあげるとよかったのではないでしょうか。具体的にはタスクのブレイクダウンですね。\n目標がないけど色んな所を探索したい人には地図が必要です。 具体的には自分と似たような領域に興味を持つ先人、ロールモデルがいるといいと思います。\nプログラマになろうとしている時点で向いていないのか 好きこそものの上手なれとか言葉を変えて色々に言われますよね。 個人的にはある程度真だと思いますが向いてないまではいいすぎかなと思います。 この言葉の言わんとするところは「口より先に手を動かせ」だと思いますが、それは環境の整った人に向けて言うべき言葉です。 入り口が見つからずにうろうろしている人も入り口さえつかめれば一気に進んだりもします。 調べて実装するスキルは必要ですが最初から持ってなくてもいいのです。 それに、之を楽しむ者に如かざれど、それは上位の一握りに入れないだけです。 「プログラマになりたい」という意思があるだけ十分素質はあると思います。\nプログラミングを目的にしてもいいと思う 「プログラマになろうとしている時点で向いていない」と似たような言葉で「プログラミングは手段であって目的ではない」があると思います。 私はちょっとこの言葉は危険だなと思っています。 技術だけに寄りがちなプログラマに対して諌める意味ではいいのですが、誰にも彼にも言うのは良くないです。 これを言っていいのはちゃんと手段としてプログラミングができるようになってからです。\nそもそも手段に秀でているから専門職をやってるわけで、そのためにはどこかでプログラミングを目的として勉強するフェーズが必要です。 私の経験でもほとんど目的としてプログラミングをしています。「シュートは得点への手段であって目的ではない」といってシュートの練習をしないスポーツマンはいませんよね。 シュートだけでは選手としてプレイできないだけです。\nあまりにも遠くにある目標を眺めてると先を急ぎたくなります。 でも急がば回れ、可能ならのんびりプログラミングを目的にして過ごす時間があってもいいんじゃないでしょうか。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2019-01-21","title":"プログラミングを目的にしてもいいと思う","url":"https://KeenS.github.io/blog/2019/01/21/puroguraminguwomokutekinishitemoiitoomou/"},
  {"body":"κeenです。Idris入門: 数当てゲーム | κeenのHappy Hacκing Blogに続いて入門記事を書いてみます。 前回はバイナリを作ったので今回はライブラリを作ります。題材は(非平衡)二分木。\n非平衡なのは平衡にすると複雑になるのと、平衡にするときは別のネタ(依存型)があるのでそれまでとっておくためです。\n対象読者は前回の数当てゲームのチュートリアルを終えた人に設定します。\n今回のコード全体像はこちらにあります。\nプロジェクト作成 以下のような構成でディレクトリを作りましょう。\n├── btree.ipkg └── src └── BTree.idr btree.ipkgには以下を書きます。\npackage btree sourcedir = src modules = BTree そして BTree.idr に今から二分木を実装していきます。\n二分木とは 二分木はデータ構造です。 値の保持、検索、削除ができるので集合やKey-Valueストアの実装に使われます。 手続き型言語ではそれらの実装にハッシュセットやハッシュマップがよく使われますが、関数型言語では二分木の方がよく使われるようです。\n二分木はノード(節)とリーフ(葉)からなります。リーフは何もデータを持ちません。 ノードは1つの値と2つ(左右)の子(部分木)を持ちます。 ノードには「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい。」という条件が成つように作ります。\n図にするとこんな感じでしょうか\n1, 2, 3, 4, 5がノードに保持されている値です。一番上にあるノード(ここでは3を保持しているノード)を根と呼びます。 「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい。」という条件もちゃんと成り立っています。\n今回は非平衡二分木なので条件はここまでです。 平衡二分木だとここからさらに「左右が大体同じくらいの高さ」という条件が付きます。\n二分木への操作 まずは検索と挿入を説明しましょう。\n検索 検索は二分探索をそのまま行えます。 例えば先程の1, 2, 3, 4, 5を保持している木に2が含まれるか検索してみましょう。\nまず3と2を比較します。2は3より小さいので、あるとしたら左の子にあるはずです。右の子は3より大きい値しか保持していないので絶対ありません。左の子を見てみましょう。\n左の子は1を保持しています。2は1より大きいのであるとしたら右の子にあるはずです。右の子をみてましょう。\n右の子は2を保持しています。検索している値が見つかったのでこの木に2が含まれることが分かります。\n同様の検索をして、葉に行き当たったら検索している値はなかったということが分かります。\n挿入 挿入も検索と似たようなことをします。先程の木に6という値を挿入してみましょう。\n6は3より大きいので右の子を見ます。\n右の子を見ると6は4より大きいのでさらに右の子を見ます。\n6は5より大きいので更に右の子を見ます。\n右の子はリーフなのでこの木には6がいないことが分かりました。 そこで6だけを保持する 新しいノードを作ります。\n5を保持するノードの右の子を今作ったノードにした 新しいノードを作ります。\n4を保持するノードの右の子を今作ったノードにした 新しいノードを作ります。\n3を保持するノードの右の子を今作ったノードにした 新しいノードを作ります。\nこれで更新が完了しました。\n更新というよりは挿入する値も保持した新しい木を作る操作ですね。 Idrisは純粋関数型言語なので破壊的変更ができません。 なので更新ではなく新しい値を作ることになります。そういったときに部分構造を共有できる二分木は無駄が少なく、効率的なデータ構造になるのです。 また、更新したあとも古い値が使える、データが順に保持される、などのおまけ付きです。\n二分木の実装 さて、座学はこのくらいにして実装していきましょう。\nデータ型の定義 まずはデータ構造の定義です。二分木とはリーフ、または2つの子と値を持ったノードからなるのでした。 BTree.idrに以下を実装します。\nmodule BTree data BTree a = Leaf | Node (BTree a) a (BTree a) これはデータ型の定義です。BTree a というのは a 型の値を保持するBTreeという意味です。ジェネリクスになってますね。 定義の中身は Leaf または Node です。 Leaf はデータを持ちません。 Node は2つの子(BTree a)と 値(a)を持ちます。 Leaf や Node のことをヴァリアントだとか列挙子だとかコンストラクタだとか呼びます。 コンストラクタの別名のとおり、BTree の値を作るにはこれらのコンストラクタを使います。Leaf は値のように、 Node は関数のように使えます。 数当てゲームのところで Either などを扱ったので馴染んでいますね。\nREPLで少し遊んでみましょう。 まずは Leaf はBTreeです。\nλΠ\u0026gt; Leaf (input):Can\u0026#39;t infer argument a to Leaf おっと、いきなり起こられました。BTree は多相(ジェネリクス)なので Leaf だけではパラメータの部分、 BTree a の a の部分の型が決まらないのです。 BTree Integer であることを明示しましょう。それには the 型名 式 が使えます。\nλΠ\u0026gt; the (BTree Integer) Leaf Leaf : BTree Integer 余談ですが the はキーワードではなくただの関数です。\nλΠ\u0026gt; :t the the : (a : Type) -\u0026gt; a -\u0026gt; a 型を関数の引数に渡せてしまうところがIdrisの特徴です。\n閑話休題。ノードの方を試してみましょう。ノードを使うといくらでも複雑な構造を作れます。\nλΠ\u0026gt; Node Leaf 1 Leaf Node Leaf 1 Leaf : BTree Integer λΠ\u0026gt; Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf) Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf) : BTree Integer 必ず最後は Leaf になってることが分かるかと思います。\nところで、以下のような定義も実行できてしまいます。\nλΠ\u0026gt; Node (Node Leaf 1 Leaf) 3 (Node Leaf 2 Leaf) Node (Node Leaf 1 Leaf) 3 (Node Leaf 2 Leaf) : BTree Integer これは3の右の子に2がきているので今回扱おうとしている二分木としては不適格です。\n不適格なデータを作れてしまう問題はデータ型だけではどうしようもないのでプログラマが気をつける必要があります。\n挿入 このデータ型に対して挿入を実装してみましょう。まずは型は木 BTree a と値 a を受け取って新しい BTree a を返すのでこうなりそうです。\ninsert : BTree a -\u0026gt; a -\u0026gt; BTree a 実装の方はリーフかノードかで分岐が発生します。 以下のように書けるでしょう。\ninsert tree x = case tree of Leaf =\u0026gt; -- ... Node l v r =\u0026gt; -- ... しかし引数で分岐するときは別の記法があります。以下のように書けるのです。\ninsert Leaf x = -- ... insert (Node l v r) x = -- ... こちらの方がより宣言的で読みやすいスタイルだとされています。 数学の記法に似ていますね。\n\\[ \\begin{align} 0! \u0026amp; = \u0026amp; 0 \\\\\nn! \u0026amp; = \u0026amp; n * (n-1)! \\end{align} \\]\n余談: エディタサポート 今の実装は実は自動化できます。 型を書いたところまで巻き戻ってみましょう。\ninsert : BTree a -\u0026gt; a -\u0026gt; BTree a この状態でinsertにカーソルを合わせてaddclauseと呼ばれるコマンド(EmacsならC-c C-s, Vimなら \\d)を打つとこうなります。\ninsert : BTree a -\u0026gt; a -\u0026gt; BTree a insert x y = ?insert_rhs 変数名が適当ですが定義のモックが自動生成されました。? マークで始まるのは穴(Hole)と呼ばれ、「あとで実装する」のマークです。詳しくはドキュメントを読んで下さい。\n名前はおいておいて、エディタサポートの話を続けます。ここでの x で分岐したいのでした。 x にカーソルを合わせてcasesplitと呼ばれるコマンド(Emacsなら C-c C-c, Vimなら \\c)を打つとこうなります。\ninsert : BTree a -\u0026gt; a -\u0026gt; BTree a insert Leaf y = ?insert_rhs_1 insert (Node x z w) y = ?insert_rhs_2 ここまで自動生成できました。\n自動生成はできたので満足ですが、生成された変数の名前が x, y と適当なのが気になりますよね。 自動生成される名前を制御するにはこのチュートリアルを大きく超える内容が必要です。 型には %name ディレクティブを、ヴァリアントにはGADTを使ってそれぞれこう定義したら目的を達成できます。\ndata BTree : (a : Type) -\u0026gt; Type where Leaf : BTree a Node : (l: BTree a) -\u0026gt; (v: a) -\u0026gt; (r: BTree a) -\u0026gt; BTree a %name BTree tree, tree1, tree2 これで生成したコードは以下です。\ninsert: BTree a -\u0026gt; a -\u0026gt; BTree a insert Leaf x = ?insert_rhs_1 insert (Node l v r) x = ?insert_rhs_2 記法やコンパイラ補助の違いだけで、元の記法もこちらの記法も同じデータ型を定義しているので盲目的に定義を置き換えてしまうのも手です。\nさて、これから実装していきましょう。 まずはLeafの方です。Leaf なら新しい値を持ったノードで置き換えるのでした。 Leaf はこう実装できるでしょう。\ninsert: Ord a =\u0026gt; BTree a -\u0026gt; a -\u0026gt; BTree a insert Leaf x = Node Leaf x Leaf insert (Node l v r) x = ... Node の方は大きいか小さいかで分岐が発生しますね。 先程は触れませんでしたが既に同じ値がある場合も新しくノードを作って返すことにします。 比較の3種類の分岐は compare が便利でした。早速こう書いてみましょう。\ninsert: Ord a =\u0026gt; BTree a -\u0026gt; a -\u0026gt; BTree a insert Leaf x = Node Leaf x Leaf insert (Node l v r) x = case compare x v of LT =\u0026gt; ?LT EQ =\u0026gt; ?EQ GT =\u0026gt; ?GT しかしこれはエラーになります。\n- + Errors (1) `-- BTree.idr line 18 col 24: When checking right hand side of insert with expected type BTree a Can\u0026#39;t find implementation for Ord a 少し分かりづらいですが、「a に Ord の実装がない」と言っています。 ジェネリクス a はなんでも受け取れます。どんな型がくるか分からないので値の比較が出来る保証もありません。 比較可能かも分からない a を比較しているのでエラーが出ている、というのが直接的原因です。 ではどうやったら修正できるか、はインターフェースの知識が必要なのでインターフェースについて説明します。\nインターフェース インターフェースはデータ型間で共通の操作を定義する機能です。 インターフェースは以下の構文で定義でます。\n-- わかりやすさのため微妙に嘘をついてます interface インターフェース名 対象の型 where 関数1 : 型 関数2 : 型 ... デフォルト実装(あれば) ... where 以降はオフサイドルールですね。インターフェースの関数はメソッドと呼びます。 例えば色々な型の値を文字列として表示可能にするインターフェース Show はこう定義されています。\ninterface Show a where show : a -\u0026gt; String あるいは同値比較のインターフェース Eq はこう定義されています。\n-- 括弧がついている関数名は中置記法で使われる(あまり気にしなくていいです) interface Eq a where (==) : a -\u0026gt; a -\u0026gt; Bool (/=) : a -\u0026gt; a -\u0026gt; Bool x /= y = not (x == y) x == y = not (x /= y) インターフェースは以下の構文で個々のデータ型に実装できます。\nインターフェース名 対象の型 where 関数1 = 実装 関数2 = 実装 適当なデータ型を定義して Show と Eq を実装してみましょう。\ndata Camellia = Japonica | Sasanqua Eq Camellia where (==) Japonica Japonica = True (==) Sasanqua Sasanqua = True (==) _ _ = False Show Camellia where show Japonica = \u0026#34;Japonica\u0026#34; show Sasanqua = \u0026#34;Sasanqua\u0026#34; そして「Show を実装した型を受け取る」はこう書けます。型定義の前に Show a =\u0026gt; を置くのです。\nprint : Show a =\u0026gt; a -\u0026gt; IO () print = putStr $ show この型定義を読み下すなら「Show を実装した型 a に対して、 a を受け取って IO () を返す関数」となるでしょう。\nということで先程の答えが出ました。 Ord が目的のインターフェースなので Ord a =\u0026gt; を追加すればよさそうです。 insert 関数の型定義に戻って Ord a =\u0026gt; を追加しましょう。\ninsert: Ord a =\u0026gt; BTree a -\u0026gt; a -\u0026gt; BTree a これで比較ができるようになったのであとは実装するだけです。 等しい場合は簡単ですね。そのまま作り直すだけです。\ninsert (Node l v r) x = case compare x v of LT =\u0026gt; ?LT EQ =\u0026gt; Node l v r GT =\u0026gt; ?GT 小さい場合は左の子(l)を、それに x 挿入したもので置き換えるのでした。大きい場合はその対称ですね。 つまり実装はこうなります。\ninsert (Node l v r) x = case compare x v of LT =\u0026gt; Node (insert l x) v r EQ =\u0026gt; Node l v r GT =\u0026gt; Node l v (insert r x) insert が実装できました。\n検索の方は簡単なので適当に実装して下さい。\nmember : Ord a =\u0026gt; BTree a -\u0026gt; a -\u0026gt; Bool member Leaf x = False member (Node l v r) x = case compare x v of LT =\u0026gt; member l x EQ =\u0026gt; True GT =\u0026gt; member r x さて、ひとまずデータを入れて検索するところまでいけました。\n地味に、空の木を表す empty も作っておきましょう。\nempty : BTree a empty = Leaf 関数ではなく値です。Idrisは純粋関数型言語なので更新される心配がなく、empty を値として定義して使いまわしても何も問題がありません。\n少しREPLで試してみて下さい。 :let で束縛を作れるのでそれを使うと良いでしょう。\nλΠ\u0026gt; :let tree = insert empty 1 defined λΠ\u0026gt; tree Node Leaf 1 Leaf : BTree Integer λΠ\u0026gt; member tree 1 True : Bool λΠ\u0026gt; member tree 2 False : Bool λΠ\u0026gt; :let tree = insert tree 3 defined λΠ\u0026gt; tree Node Leaf 1 (Node Leaf 3 Leaf) : BTree Integer λΠ\u0026gt; member tree 1 True : Bool λΠ\u0026gt; member tree 2 False : Bool λΠ\u0026gt; member tree 3 True : Bool テスト 機能するものができたので自動テストをしてみましょう。 テストは2, 3個の例を試して正しく動くか試す、ソフトウェアの品質検査法です。 数学の試験で2, 3個の例を試して正しい、などと書いたら正解になりませんが、明らかな誤りを見つけるにはこれでも効果はあります。\n新しくテストディレクトリを作り、そこに BTree.idr を作りましょう。\n├── btree.ipkg └── src ├── BTree.idr └── Tests └── BTree.idr そして btree.ipkg を編集します。\npackage btree sourcedir = src modules = BTree , Tests.BTree tests = Tests.BTree.test pkgs = contrib テストモジュールをモジュールリストに加える、テストのエントリーポイントを指定する、依存パッケージにcontribを追加する、をやっています。\ncontribはIdrisコンパイラと一緒に配布されているパッケージですが、デフォルトではリンクされません。 idrisは標準ライブラリへの機能追加に保守的な方針を取っています。まずはcontribライブラリに入れ、誰が見ても必要だと判断できたらデフォルトでリンクされるpreludeやbaseに入ります。 今回はcotribにあるテストライブラリを使います。\nさて、テストを書いていくのですが、その前に先程定義したデータ型を公開しないといけません。\nモジュールと可視性 前回のチュートリアルでモジュールについては学習したと思います。まだの人はドキュメントを読んでおいて下さい。\nIdrisには3つの可視性の修飾子があります。\n private - モジュール内でのみ見える export - モジュール外から型が見える。他言語でいうパブリックに近い public export - モジュール外から型と実装が見える。つまり実装の詳細まで公開APIになる  public export はかなり危険ですが、データ型だとコンストラクタまで公開したいケースは多々あるので便利でしょう。 今回は二分木に「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい。」という条件があります。 ユーザにコンストラクタまで公開すると条件を満たさない木を作られかねないので public export ではなく export にします。 今ある4つの定義に export をつけましょう。\nexport data BTree .. export empty: BTree a ... export insert: Ord a =\u0026gt; BTree a -\u0026gt; a -\u0026gt; BTree a export member : Ord a =\u0026gt; BTree a -\u0026gt; a -\u0026gt; Bool さて、これでテストが書けます。 Test.Unit.Assertionsを使ってテストを書いてみましょう。 Tests/BTree.idrにこう書きます。\nmodule Tests.BTree import BTree import Test.Unit.Assertions testInsertMember : IO () testInsertMember = let tree = insert empty 1 in let tree = insert tree 5 in let tree = insert tree 3 in do assertTrue $ member tree 1 assertTrue $ member tree 5 assertTrue $ member tree 3 pure () assertTrue を使って insert して member したら存在するということをテストしています。 let 変数 = 式1 in 式2 はローカル変数を導入する構文です。 ネストするときはこのようにインデントを揃えると見慣れたコードに近くなります。\n最後にテストのエントリーポイントを書きます。\nexport test : IO () test = do testInsertMember test はipkgで指定した名前です。\nこのテストを走らせます。コマンドラインで idris --testpkg btree.ipkg を打つとテストが走ります。\n$ idris --testpkg btree.ipkg Entering directory `./src\u0026#39; Type checking /tmp/idris74355-0.idr Test: Assert True Test: Assert True Test: Assert True Leaving directory `./src\u0026#39;  上手くいっているようです。\nテストをもう少し追加しましょう。 insert してない値を member したら False になるテストです。 テストを書き、\ntestNotInsertMember : IO () testNotInsertMember = let tree = insert empty 1 in let tree = insert tree 5 in let tree = insert tree 3 in do assertFalse $ member tree 2 assertFalse $ member tree 4 pure () エントリーポイントに追加し、\nexport test : IO () test = do testInsertMember testNotInsertMember 実行します。\n$ idris --testpkg btree.ipkg Entering directory `./src\u0026#39; Type checking ./Tests/BTree.idr Type checking /tmp/idris74537-0.idr Test: Assert True Test: Assert True Test: Assert True Test: Assert False Test: Assert False Leaving directory `./src\u0026#39;  問題ないですね。\n削除 削除はまず検索と同じ要領で要素を見つけます。 例えば3を削除するとしましょう。3は簡単に見つかります。\nここから3以外(要は左右の子)で新しく木を作ります。\nノードを1つ追加すれば出来るのですが、ノードに保持する値が必要です。 左の子の最大値を持ってきてあげると上手くいきます。\nこれにはサブルーチン、popMaxを使います。 「ノードの値が木の最大値である⇒右の子がリーフ」なので簡単に発見、削除できます。 ずっと右の子を辿っていって右の子がリーフであるノードを見つけたらそのノードの値が最大値です。 空の木の場合は最大値がないので注意しましょう。\nexport popMax : BTree a -\u0026gt; (BTree a, Maybe a) popMax Leaf = (Leaf, Nothing) popMax (Node l v Leaf) = (l, Just v) popMax (Node l v r) = let (r\u0026#39;, max) = popMax r in (Node l v r\u0026#39;, max) ここで (BTree a, Maybe a) と書いてあるのはタプル(組)の型です。 簡易版構造体のようなもので、複数の値をひとまとめにできます。そして (Leaf, Nothing) のように書いてあるのがタプルの値です。 今更ですが、ちょくちょく出てきていた () は空のタプルのことでした。\nこの popMax を使うと delete はこう書けます。 member とほとんど似た見た目ですが EQ の腕で popMax を呼ぶようになっています。\nexport delete : Ord a =\u0026gt; BTree a -\u0026gt; a -\u0026gt; BTree a delete Leaf x = Leaf delete (Node l v r) x = case compare x v of LT =\u0026gt; Node (delete l x) v r GT =\u0026gt; Node l v (delete r x) EQ =\u0026gt; case popMax l of (l\u0026#39;, Just max) =\u0026gt; Node l\u0026#39; max r (l\u0026#39;, Nothing) =\u0026gt; r -- l\u0026#39; = Leaf これもテストしておきましょう。\ntestDelete : IO () testDelete = let tree = insert (the (BTree Integer) empty) 1 in let tree = insert tree 5 in let tree = insert tree 3 in do assertTrue $ member tree 1 let tree = delete tree 1 assertFalse $ member tree 1 pure () testPopMax : IO () testPopMax = let tree = insert empty 1 in let tree = insert tree 5 in let tree = insert tree 3 in do let (tree, max) = popMax tree assertEquals max (Just 5) let (tree, max) = popMax tree assertEquals max (Just 3) let (tree, max) = popMax tree assertEquals max (Just 1) let (tree, max) = popMax tree assertEquals max Nothing pure () export test : IO () test = do -- ... testPopMax testDelete 練習問題として popMin も実装してみて下さい。\n雑多な操作 二分木には色々な操作ができます。\n最大値、最小値 例えば最大値、最小値は簡単に求まります。popMax, popMin の亜種ですね。\nexport max: BTree a -\u0026gt; Maybe a max Leaf = Nothing max (Node _ v Leaf) = Just v max (Node _ _ r) = max r export min: BTree a -\u0026gt; Maybe a min Leaf = Nothing min (Node Leaf v _) = Just v min (Node l _ _) = min l 分割 木を分割してみましょう。値 x を取り、「x より小さい値を含んだ木、x が含まれれば x 、 x より大きい値を含んだ木」の3つ組を返します。\nexport split: Ord a =\u0026gt; BTree a -\u0026gt; a -\u0026gt; (BTree a, Maybe a, BTree a) split Leaf x = (Leaf, Nothing, Leaf) split (Node l v r) x = case compare x v of LT =\u0026gt; let (ll, lv, lr) = split l x in (ll, lv, Node lr v r) EQ =\u0026gt; (l, Just v, r) GT =\u0026gt; let (rl, rv, rr) = split r x in (Node l v rl, rv, rr) Foldabe Foldable というインターフェースがプレリュードで定義されています。\n||| The `Foldable` interface describes how you can iterate over the ||| elements in a parameterised type and combine the elements ||| together, using a provided function, into a single result. ||| ||| @t The type of the \u0026#39;Foldable\u0026#39; parameterised type. interface Foldable (t : Type -\u0026gt; Type) where ||| Successively combine the elements in a parameterised type using ||| the provided function, starting with the element that is in the ||| final position i.e. the right-most position. ||| ||| @func The function used to \u0026#39;fold\u0026#39; an element into the accumulated result. ||| @input The parameterised type. ||| @init The starting value the results are being combined into. foldr : (func : elem -\u0026gt; acc -\u0026gt; acc) -\u0026gt; (init : acc) -\u0026gt; (input : t elem) -\u0026gt; acc ||| The same as `foldr` but begins the folding from the element at ||| the initial position in the data structure i.e. the left-most ||| position. ||| ||| @func The function used to \u0026#39;fold\u0026#39; an element into the accumulated result. ||| @input The parameterised type. ||| @init The starting value the results are being combined into. foldl : (func : acc -\u0026gt; elem -\u0026gt; acc) -\u0026gt; (init : acc) -\u0026gt; (input : t elem) -\u0026gt; acc foldl f z t = foldr (flip (.) . flip f) id t z foldl 、 foldr は概ねループをする関数です。foldl が左から、 foldre が右からの巡回です。 foldl は数当てゲームで使いましたね。 Foldable は他言語でいう Iterable みたいなものです。ただし関数型風味です。 変更可能な状態を持てないので外部イテレータではなく内部イテレータで定義されています。そしてループの途中の計算状態 acc を持ち回ります。\nこれを二分木に実装しましょう。foldl は 「まず左、値、そして右」の順(通りがけ順)に走査していけばよさそうです。\nfoldr はその対称ですね。 素直にこう実装できます。\nFoldable BTree where foldr f init Leaf = init foldr f init (Node l v r) = let r = foldr f init r in let v = f v r in foldr f v l foldl f init Leaf = init foldl f init (Node l v r) = let l = foldl f init l in let v = f l v in foldl f v r これを用いてリストとの相互変換を実装してみましょう。 煩雑だった値の構築が少し楽になります。\nexport toList: BTree a -\u0026gt; List a toList tree = foldr (::) [] tree export toTree: Ord a =\u0026gt; List a -\u0026gt; BTree a toTree xs = foldl insert empty xs ここで、 (::) はリストのコンストラクタです。\nλΠ\u0026gt; the (List Integer) $ 1 :: 2 :: 3 :: [] [1, 2, 3] : List Integer fold 先程の foldr, foldl とは別に fold という関数が定義できます。 BTree は以下のように定義されているのでした。\ndata BTree a = Leaf | Node (BTree a) a (BTree a) BTree は定数 Leaf と3引数関数 Node で構成されているとも読めます。fold は この構成子を別の定数と3引数関数で置き換えてあげる操作です。 リストは foldr がそのまま fold に対応するのですが BTree はそうではないので自分で定義します。\nexport fold: BTree a -\u0026gt; b -\u0026gt; (b -\u0026gt; a -\u0026gt; b -\u0026gt; b) -\u0026gt; b fold Leaf x f = x fold (Node l v r) x f = f (fold l x f) v (fold r x f) Leaf -\u0026gt; x 、 Node -\u0026gt; f を再帰的にやっているのが見て取れると思います。\nfold を使っていくつか関数を定義してみましょう。\n木のサイズ(保持している要素数)はこう定義できます。\nexport size : BTree a -\u0026gt; Integer size tree = fold tree 0 (\\l, _, r =\u0026gt; l + 1 + r) 木の高さは以下のように定義できます\n リーフの高さは0である ノードの高さは左右の子の高さのうち大きい方+1である  これも同様に fold で求められます。\nexport height : BTree a -\u0026gt; Integer height t = fold t 0 (\\lh,_,rh =\u0026gt; (max lh rh) + 1) これは一番深い方を求めています。浅い方を求めるのも考えられるのでそれも実装してみましょう。\nexport maxHeight : BTree a -\u0026gt; Integer maxHeight t = fold t 0 (\\lh,_,rh =\u0026gt; (max lh rh) + 1) export minHeight : BTree a -\u0026gt; Integer minHeight t = fold t 0 (\\lh,_,rh =\u0026gt; (min lh rh) + 1) export height : BTree a -\u0026gt; Integer height = maxHeight 余談: fold の一般化 fold はBTreeやリストに限らず色々なデータ型にも定義できますが、それをインターフェースで一般化するのはかなり難易度が上がります。 列挙子に応じて引数の数や型が変わるので共通のインターフェースが定められないのです。 やるとしたらデータ型の定義ごと管理下に置くような仕組みが必要になるでしょう。 そういうのは\u0026rdquo;recursion scheme\u0026rdquo;という名前で色々整備されているようです。fold はcatamorphismと呼ばれます。 resursion schemeは日本語でもいくつか解説があるようですが以下のブログを紹介しておきます。 #003 代数的データ型 - λx.x K S K ＠ はてな\n集合操作 二分木は集合のように扱えるので合併、交叉、差分などの操作も欲しくなりますよね。\nfoldl を使うと簡単に実装できます。\nunion : Ord a =\u0026gt; BTree a -\u0026gt; BTree a -\u0026gt; BTree a union tree1 tree2 = foldl insert tree1 tree2 -- `if` 式は `if 条件 then 式 else 式` で書く intersection : Ord a =\u0026gt; BTree a -\u0026gt; BTree a -\u0026gt; BTree a intersection tree1 tree2 = foldl (\\acc,elm =\u0026gt; if member tree1 elm then insert acc elm else acc) empty tree2 difference : Ord a =\u0026gt; BTree a -\u0026gt; BTree a -\u0026gt; BTree a difference tree1 tree2 = foldl delete tree1 tree2 union は少し良くない点があるのですが気にしないことにしましょう。\nさて、これらの雑多な操作のテストも書いておきましょう。\ntestToTreeMember : IO () testToTreeMember = let tree = toTree [1, 5, 3] in do assertTrue $ member tree 1 assertTrue $ member tree 5 assertTrue $ member tree 3 pure () testToTreeToList : IO () testToTreeToList = let tree = toTree [1, 5, 3] in let list = toList tree in do assertEquals list [1, 3, 5] pure () testMax : IO () testMax = let tree = toTree [1, 4, 3, 5, 2] in do assertEquals (max tree) (Just 5) pure () testMin : IO () testMin = let tree = toTree [1, 4, 3, 5, 2] in do assertEquals (min tree) (Just 1) pure () testSplit1 : IO () testSplit1 = let tree = toTree [1, 5, 3, 2, 4] in let (l, v ,r) = split tree 3 in do assertEquals (toList l) [1, 2] assertEquals v (Just 3) assertEquals (toList r) [4, 5] pure () testSplit2 : IO () testSplit2 = let tree = toTree [1, 5, 2, 4] in let (l, v ,r) = split tree 3 in do assertEquals (toList l) [1, 2] assertEquals v Nothing assertEquals (toList r) [4, 5] pure () testSplit3 : IO () testSplit3 = let tree = toTree [1, 5, 2, 4] in let (l, v ,r) = split tree 6 in do assertEquals (toList l) [1, 2, 4, 5] assertEquals v Nothing assertEquals (toList r) [] pure () testSplit4 : IO () testSplit4 = let tree = toTree [1, 5, 2, 4] in let (l, v ,r) = split tree 0 in do assertEquals (toList l) [] assertEquals v Nothing assertEquals (toList r) [1, 2, 4, 5] pure () testSplit : IO () testSplit = do testSplit1 testSplit2 testSplit3 testSplit4 testUnion : IO () testUnion = let tree1 = toTree [1, 3, 5] in let tree2 = toTree [2, 3, 4] in let tree = union tree1 tree2 in do assertEquals (toList tree) [1, 2, 3, 4, 5] pure () export test : IO () test = do -- ... testToTreeMember testToTreeToList testMax testMin testSplit testUnion パッケージを整える btree.ipkgには最低限の内容しか書いてませんでした。色々埋めましょう。\nbrief = \u0026#34;A non-balanced Binary Tree library\u0026#34; version = \u0026#34;0.1.0\u0026#34; readme = \u0026#34;README.md\u0026#34; license = \u0026#34;MIT\u0026#34; author = \u0026#34;κeen\u0026#34; maintainer = \u0026#34;κeen\u0026#34; sourceloc = \u0026#34;https://gitlab.com/blackenedgold/idris-btree\u0026#34; bugtracker = \u0026#34;https://gitlab.com/blackenedgold/idris-btree/issues\u0026#34; ドキュメントを生成してみましょう。\n$ idris --mkdoc btree.ipkg  btree_doc/index.html を開くとドキュメントを確認できます。\nあとは .gitignore を書いて適当にコミットしましょう。\n*.ibc btree_doc コードホスティングサービスにGitLabを使うならGitLab CIで以下のようにテスト/ドキュメント生成ができます。\n# インターネットに転がっていたイメージ# 得体のしれないイメージを使いたくない人は自分でイメージを作ると良いimage:mmhelloworld/idris:1.3.1test:script:- idris --testpkg btree.ipkgpages:script:- idris --mkdoc btree.ipkg# docker内で生成するとパーミッションの問題が発生するらしく、ディレクトリを一旦作り直すと解決する- mkdir public- cp -R btree_doc/* publicartifacts:paths:- publiconly:- master 生成されたドキュメントはこちら。 GitHubでも外部サービスやGitHub Actionsで同様にはできると思います。ドキュメントの方はGitLab Pagesとは違って一苦労必要そうですが。\nまとめ このチュートリアルでは二分木のライブラリを作りつつIdrisでのデータ型の定義、インターフェース、テスト、パッケージなどについて学びました。\n","categories":["Idris","Idris入門"],"category_urls":["/categories/idris","/categories/idris%e5%85%a5%e9%96%80"],"date":"2019-01-17","title":"Idris入門: 二分木","url":"https://KeenS.github.io/blog/2019/01/17/idrisnyuumon__nibungi/"},
  {"body":"# void ---------------------- [Shinjuku.rs #2 @FORCIA](https://forcia.connpass.com/event/110888/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * GitLab: [blackenedgold](https://gitlab.com/blackenedgold) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # 発散型 -------- * `!` * [ドキュメント](https://doc.rust-jp.rs/the-rust-programming-language-ja/1.6/book/functions.html#%E7%99%BA%E6%95%A3%E3%81%99%E3%82%8B%E9%96%A2%E6%95%B0) + 標準ライブラリだと [exit](https://doc.rust-lang.org/std/process/fn.exit.html) とか + 他には無限ループ、パニック、 `return`/`continue` など * 呼び出し元に制御が返らない * どんな型にもなれる === # 発散型 -------- ``` rust use std::process::exit; // pub fn exit(code: i32) - ! let hoge: i32 = exit(0); let fuga: () = exit(0); ``` === # `match` と型 -------------- * `match` の返り値は腕の型で決まる * 発散型と他の型の組み合わせだと他の型になる ``` rust let piyo: i32 = match 0 { // ! 0 = exit(0), // i32 n = 1i32, }; ``` === # `Void` -------- ``` rust enum Void {} ``` === # `Void` -------- * バリアント(=コンストラクタ)がない + 値を作れない * もしその値を受け取れるとしたらどうなる？ === # `Void` の作り方 ----------------- * 発散型を使うと(コード上は)作れる * 発散型なので実行時にはこのコードに到達しない ``` rust let void: Void = unimplemented!(); //... ``` === # `Void` の作り方2 ----------------- * 関数を使うと(コード上は)受け取れる * 実際にはこの関数は呼べない ``` rust fn take_void(void: Void) { // ... } ``` === # `Void` にマッチ --------------- * Q: これはコンパイルが通る？ * A: 通る``` rust fn absurd(void: Void) { match void {}; } ``` === # `Void` にマッチ --------------- * 返り値型はなんでもいい ``` rust fn absurd(void: Void) - () { match void {} } ``` === # `Void` にマッチ --------------- * 返り値を発散型にもできる! ``` rust fn absurd(void: Void) - ! { match void {} } ``` === # `Void` と列挙型 ----------------- * `Result` という型を考える * `Void` は作れないので `Err` はありえない * `Ok` しか存在しない `Result` 型に === # `Void` と列挙型 ----------------- * Q: これはコンパイルが通る？ * A: 通らない``` rust let result: Result= Ok(()); match result { Ok(()) = // } ``` === # `absurd` の使いどころ ----------------------- * これはコンパイルが通る ``` rust let result: Result= Ok(()); match result { Ok(()) = // Err(void) = absurd(void), } ``` === # `absurd` の使いどころ ----------------------- * こういうのも作れる ``` rust fn safe_unwrap(result: Result) - T { match result { Ok(t) = t, Err(void) = absurd(void), } } ``` === # まとめ -------- * `!` は特殊な型だよ * 空の列挙型 (`Void`) から `!` が作れるよ * `Void` を使うと面白いことができるよ * See also [voidクレート](https://crates.io/crates/void) - 今回の内容を実装してるやつ * See also [never type](https://doc.rust-lang.org/std/primitive.never.html) と [RFC](https://github.com/rust-lang/rfcs/blob/master/text/1216-bang-type.md) - `!` を空の列挙型にする提案   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2019-01-16","title":"void","url":"https://KeenS.github.io/slide/void/"},
  {"body":"# イマドキと言われる言語機能について ---------------------- [第60回プログラミングシンポジウム](http://www.ipsj.or.jp/prosym/60/60program.html) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア + 情報科学の教育は受けていない純粋なエンジニア * 実際に仕事で使った(ている)のはJava, Scala, Rust === # 最近っぽい言語 ---------------- 言語 | 1.0リリース | 特徴 :-----------------------------------------------|------------|:------ [Go](https://golang.org/) | 2012 | goroutineが使えるシンプルな言語 [Rust](https://www.rust-lang.org/) | 2015 | 安全なシステムプログラミング言語 [Swift](https://developer.apple.com/jp/swift/) | 2014 | iOSアプリが作れる [Scala](https://www.scala-lang.org/) | 2004 | 関数型パラダイムを取り入れたJVM言語 [Kotlin](https://kotlinlang.org/) | 2016 | 整理されたJava === # 最近のトレンド --------------- * 静的型付言語が増えてきた + 動的型付言語が主流だった反動？ * 静的コンパイルする言語が増えてきた * インタプリタ言語にも速度が求められるようになってきた * 関数型言語の機能を取り入れるようになってきた * 速度やマルチコア対応が気にされ始めた * マルチタスクのサポートが増えてきた === # 静的型(解析) -------- * 動的型付言語に(部分的に)静的型を入れるのが増えてきた + [漸進的型付け (2006)](http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/)かな？ + [TypeScript](https://www.typescriptlang.org/) + Pythonの[Type Hints](https://www.python.org/dev/peps/pep-0484/) + Ruby 3に型を入れたいらしい * Null値の静的解析が増えた + Scala, Rustの`Option` 型 + Swift, Kotlinのnullable/non-nullableの区別 * 型推論 === # TypeScript ------------ * TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. ```typescript function greeter(person: string) { return \"Hello, \" + person; } ``` * 型がかなり多機能 CF [TypeScriptで最低一つは必須なオプションオブジェクトの型を作る](https://qiita.com/uhyo/items/583ddf7af3b489d5e8e9) * 型のないコードも許容する === # Rustの `Option` ------- ``` rust pub enum Option { None, Some(T), } let x: Option = Some(2); assert_eq!(x.is_some(), true); let x: Option = None; assert_eq!(x.is_some(), false); ``` === # Rustの `Option` ------- * 代数的データ型で定義される * 特に `Option` が特別扱いされているわけではない === # KotlinのNull許容型 -------- ``` kotlin val listWithNulls: List = listOf(\"Kotlin\", null) for (item in listWithNulls) { item?.let { println(it) } // prints A and ignores null } ``` === # KotlinのNull許容型 -------- * Nullable Typeのための構文が用意されている === # 継承に依らないポリモーフィズム ------------------------------ * 今まで主流の言語は継承によるポリモーフィズムが多かった + Ruby, Perl, Python, Java, C++ * それ以外の方法が増えてきた + [型クラス(1988)](https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf)とか構造的ポリモーフィズムとか + Scalaの貧者の型クラス, Rustのトレイト + Goのインターフェース === # Rustのトレイト ------ ``` rust struct Sheep { naked: bool, name: \u0026'static str } trait Animal { // Instance method signatures; these will return a string. fn name(\u0026self) - \u0026'static str; fn noise(\u0026self) - \u0026'static str; } // Implement the `Animal` trait for `Sheep`. impl Animal for Sheep { fn name(\u0026self) - \u0026'static str { self.name } fn noise(\u0026self) - \u0026'static str { if self.is_naked() { \"baaaaah?\" } else { \"baaaaah!\" } } } ``` === # Rustのトレイト ------ * 割と普通の型クラス === # Scalaの型クラス ------- ``` scala trait Show[A] { def show(a: A): String } implicit val intCanShow: Show[Int] = new Show[Int] { def show(int: Int): String = s\"int $int\" } def showExp(implicit sh: Show[A]) = sh.show(a) ``` === # Scalaの型クラス ------- * dictinary passing方式のimplicit parameterを生で実装 === # Goのインターフェース ----- ``` go type I interface { M() } type T struct { S string } // This method means type T implements the interface I, // but we don't need to explicitly declare that it does so. func (t T) M() { fmt.Println(t.S) } ``` === # Goのインターフェース ----- * 構造的ポリモーフィズムっぽい？ === # 所有権 --------- * GCを使わないメモリ管理 + [線形型 (1990?)](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.5002) + Rust, (部分的に)C++のムーブセマンティクス === # Rustの所有権 -------------- ``` rust let s1 = String::from(\"hello\"); // s1はここでs2に所有権が移った let s2 = s1; // ここでs1を使おうとするとエラー println!(\"{}, world!\", s1); // s2はスコープの終わりで解放される ``` === # Rustの所有権 -------------- * Rustの最大の特徴とされるが難しいという声も === # 非同期処理 ----------------- * async/await + C#, JavaScript, (Scala), (Rust) * コルーチン + kotlin, (Java) * goroutine + [CSP(1978)](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf) + goroutineはコルーチンではない + goroutineは軽量スレッドではない + Go === # C#の `async` / `await` ----- ``` c# private readonly HttpClient _httpClient = new HttpClient(); downloadButton.Clicked += async (o, e) = { // This line will yield control to the UI as the request // from the web service is happening. // // The UI thread is now free to perform other work. var stringData = await _httpClient.GetStringAsync(URL); DoSomethingWithData(stringData); }; ``` === # C#の `async` / `await` ----- * `async` / `await` を最初に発明したのが C# らしい？ * `async` ブロック内で `await` を呼ぶことでIOでブロックしなくなる + シンタックスシュガーで内部ではステートマシンになる + コルーチンと違ってスタックレス * ユーザが非同期タスクを作ることも出来る === # Goのgoroutine ----------------- ``` go func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c ) - usize;\\n}\\n\"))) client-notification Fri Jan 11 03:54:52 2019: (:jsonrpc \"2.0\" :method \"workspace/didChangeConfiguration\" :params (:settings nil)) ``` === # Language Server ----- * クライアント(エディタなど)からのクエリに答える + 型情報、補完情報などなど + オンラインにクエリに答えないといけない * プロトコルが統一化されたので言語に依存せずに使えるようになった * 割と処理系開発元と同じところが提供することが多くなった * 静的解析よりなので動的型付き言語には少し不満 === # まとめ -------- * 静的解析 * 継承から離れつつある * 所有権がきてる * 開発支援ツールも言語に求められるように   ","categories":["プログラミングシンポジウム"],"category_urls":["/categories/%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0%e3%82%b7%e3%83%b3%e3%83%9d%e3%82%b8%e3%82%a6%e3%83%a0"],"date":"2019-01-11","title":"イマドキと言われる言語機能について","url":"https://KeenS.github.io/slide/imadokitoiwarerugengokinounitsuite/"},
  {"body":"κeenです。 Idrisの入門記事ってあまりないなと思ったので少し書いてみます。 私は別にIdrisに詳しいわけではないので間違っているかもしれないことに注意してください。\nIdris は依存型を持つ汎用プログラミング言語で、Haskellっぽい文法や機能を持ちます。 依存型を持っていてかつ汎用のプログラミング言語というのがめずらしいのでその手の文脈ではだいたい名前が上がります。 Idrisの型システムはものすごく雑にいうと型がプログラム可能です。型を書く位置に関数を書いたり逆に型を値としてプログラムに渡したり出来ます。 これらの機能を使って型を詳細に書けるので正しい入力しか受け付けないぜ！みたいなことが書けます。\nところでIdrisに入門しようとすると難解な記事が多いのが現状です。 Idrisの関連記事はどうしても依存型に目が行ってしまうので普通のプログラミング言語としての紹介が中々見当たらないのです。 そこで今回は依存型の部分を完全に無視してプログラムを書いてみます。\n対象読者はプログラミング言語を最低1つは理解している人に設定しますが、ぶっちゃけHaskell読める人(書けなくてもいい)じゃないときついよなーと思いつつ書いてます。IO とか do とか。\n因みに一次情報として公式チュートリアルもあります。 HaskellやOCamlに馴染んでいる人向けに高速で言語機能を1巡りしています。\nこの記事ではIdris 1.3.1を使ってコードを書いていきます。\nはじめに このチュートリアルは正直なところ題材があまりチュートリアル向きでないです。 もちろん「数当てゲーム」自体は簡単なプログラムですし出来上がるアプリケーションも小さなものです。 しかし純粋関数型言語であるIdrisで、ユーザとの連携や乱数取得という副作用の多いプログラムを書こうとすると色々な機能を使わざるを得ません。 そのため、1つのコードを説明するのに出てくる概念が多くなります。Haskellの入門書でも \u0026ldquo;Hello World\u0026rdquo; は後の方に出てくることが多いようです。 それを承知の上で、やっぱり動くアプリケーションを作らないと気がすまない人向けに「数当てゲーム」を実装するチュートリアルがこれです。\n数当てゲームを簡単に説明すると、ゲームが立ち上がると裏で1から100までの数値(答え)を1つ決めます。 そしてユーザがなにか数値を入力します。 ユーザの入力が答えと一致したらその場でゲーム終了、違えば入力が答えより大きいか小さいかを教えてくれ、また入力を促します。\nこういうゲームを作りながらIdrisを学んでいきます。\n環境構築 別記事 参照\nHello World まずは動くものを作りましょう。 hello.idr に以下を書きます。\nmain: IO () main = putStrLn \u0026#34;Hello world\u0026#34; コンパイル、実行してみましょう。\n$ idris hello.idr -o hello $ ./hello Hello world  ひとまず動きました。\nHello World解剖 Idrisの値/関数定義は以下のような形をしています。 型と値で2行に分けて書きます。\n名前 : 型 名前 [引数 ...] = 値 先のプログラムの例でいくと main が名前、 IO () が型、 putStrLn \u0026quot;Hello world\u0026quot; が値です。 putStrLn \u0026quot;Hello world\u0026quot; は putStrLn 関数に \u0026quot;Hello world\u0026quot; という値を渡しています。関数呼び出しに括弧は不要なので注意してください。\nIdrisのプログラムは main から実行されます。\nCの main の返り値は int ですしJavaの main の返り値は void ですね。 Idrisの main はおおむね () 型を返していますが、IOというのがついています。 IO () という書き方はJavaでいう IO\u0026lt;()\u0026gt; のように型パラメータを渡す記法です。 IO というのは出入力をするプログラムであることを表しています。 今回は出力をしていますね。 これについて踏み込むとモで始まる名状し難いなにかが出てくるのですがその前に次のプログラムに進みましょう。\n入力を得る 次は世界ではなくユーザに挨拶してみましょう。先程のプログラムを以下のように書換えます。 インデントは大事ですので変えないで下さいね。\nmain: IO () main = do putStr \u0026#34;What\u0026#39;s your name? \u0026#34; name \u0026lt;- getLine putStrLn (\u0026#34;Hello \u0026#34; ++ name) このコードも先程と同様にコンパイル、実行できますが、今度はインタラクティブシェル(REPL)を使ってみます。 idris コマンドでREPLを起動し、 :load hello.idr でロード、 :exec main で main を実行します。\n$ idris ____ __ _ / _/___/ /____(_)____ / // __ / ___/ / ___/ Version 1.3.1-git:1510fce92 _/ // /_/ / / / (__ ) http://www.idris-lang.org/ /___/\\__,_/_/ /_/____/ Type :? for help Idris is free software with ABSOLUTELY NO WARRANTY. For details type :warranty. Idris\u0026gt; :load hello.idr *hello\u0026gt; :exec main What\u0026#39;s your name? keen Hello keen  : ではじまるのはREPLのコマンドです。 :help で一覧が見れます。 REPLを終了する :quit 、 ロードしたファイルの変更を監視してリロードする :watch などがあります。 今後は実行方法は指定しないので好きな方法で実行して下さい。\nさて、先程のプログラムを解説しましょう。\nmain: IO () main = do putStr \u0026#34;What\u0026#39;s your name? \u0026#34; name \u0026lt;- getLine putStrLn (\u0026#34;Hello \u0026#34; ++ name) 新しく登場した putStr 、 getLine の関数については説明不要ですかね。 do と \u0026lt;- について解説します。\ndo を正確に説明するにはそこそこの前提知識が必要なので雰囲気で説明します。 do はプログラムを連接するときに使う記法です。 do はオフサイドルールでブロックが書けるのでここでは続く3行を連接しています。 以下のように波括弧で括ったりさらにセミコロンをつけても同じことです。\nmain: IO () main = do { putStr \u0026#34;What\u0026#39;s your name? \u0026#34;; name \u0026lt;- getLine; putStrLn (\u0026#34;Hello \u0026#34; ++ name); } 複数行のプログラムを書くだけでもったいぶってるようですが、Idrisは純粋関数型言語なのでIOのように純粋でない操作は特別な対処をしてあげないといけないのです。 Idrisは純粋なのでIOや値の変更などができません。 じゃあさっき書いたプログラムはどうなってるんだと思いますよね。 main に書いたのは「IOを行うプログラム」という 値 です。よく考えてみると main には引数がありませんでしたよね。 main は関数ではなく値です。 値を書いただけなので副作用はありません。 Idrisのランタイムが main に書いてある値を読み取って勝手にIOを実行しただけです。\n屁理屈じみてますが、これで純粋性との折り合いが付いているようです。実際、main 以外ではIOを行えないので純粋性は保たれますしね。 しかし main に値として渡さないと実行されないので複数回IOをするときに困ります。値は1つだけなので複数のIOをするプログラムを1まとめにしてmainに渡さないといけません。 そこで do は複数の(ある条件を満たした)値を1つに連接する働きをします。\n繰り返しますが、雰囲気で説明しています。いつか正確な説明を受けて下さい。\nここでの do が何を連接しているか確認するためにREPLで今回使った3つの関数の型を見てみましょう。 :t \u0026lt;expr\u0026gt; あるいは :type \u0026lt;expr\u0026gt; で式の型が見れます。\n*hello\u0026gt; :t putStr putStr : String -\u0026gt; IO () *hello\u0026gt; :t getLine getLine : IO String *hello\u0026gt; :t putStrLn putStrLn : String -\u0026gt; IO () -\u0026gt; は関数の型で、 String -\u0026gt; IO () は「String を受け取って IO () を返す関数」という意味の型です。 引数を埋めたあとだと今回の do は IO () 、 IO String 、 IO () を繋げています。 IO () は「IOをして () を返すプログラム」、 IO String は 「IOをして String を返すプログラム」です。\nここでようやく \u0026lt;- の説明ができます。 プログラムを合成するときに前のプログラムが返した値を取り出したいですよね。 それをするのが \u0026lt;- です。\nここまできたら先程のプログラムは理解できるかと思います。 因みに ++ はここでは文字列の連結です。\nmain: IO () main = do putStr \u0026#34;What\u0026#39;s your name? \u0026#34; name \u0026lt;- getLine putStrLn (\u0026#34;Hello \u0026#34; ++ name) ビルドシステム Idrisには一応パッケージシステムが付いています。 パッケージシステムとはいってもインターネットから依存をダウンロードしたりはできません。しかしビルドだけならこれで十分です。\n数当てゲームのパッケージを作りましょう。 プロジェクトテンプレートを作る機能はないので自分で作ります。 以下のようなディレクトリ構成でディレクトリを作りましょう。\n├── idris-guessing-game.ipkg └── src └── Main.idr idris-guessing-game.ipkgには以下を書きます。内容はコメントから推察して下さい。\npackage idris-guessing-game -- バッケージ名 -- ソースコードの場所 sourcedir = src -- ビルドするモジュール(ファイル名) modules = Main -- 生成する実行可能ファイルの名前 executable = \u0026#34;guessing_game\u0026#34; -- `Main.main` を定義するモジュール(ファイル名) main = Main Main.idrには以下を書きます。\nmodule Main main : IO () main = putStrLn \u0026#34;Hello ipkg\u0026#34; 今まで出てこなかった module というのがでてきましたね。名前空間です。 なくても動きますし、ファイル名と関連づく必要もないです。しかしソースディレクトリの Foo/Bar.idr ファイル内には module Foo.Bar を書くことが多いようです。 モジュール名は自由ですが、バイナリを作る際は Main モジュールに main を書く必要があります。\nさて、これをビルドしましょう。 idris --build idris-guessing-game.ipkg でできます。\n$ idris --build idris-guessing-game.ipkg Entering directory `./src\u0026#39; Type checking ./Main.idr Leaving directory `./src\u0026#39;  成功すれば guessing_game という名前で実行可能ファイルができます。\n$ ./guessing_game Hello ipkg  ビルドできました。\n因みに ipkg ファイルを書いておくとだいたいのエディタプラグインはそれを読み込んでくれるようです。 また、REPLを起動するのも idris --repl hoge.ipkg のようにipkgファイルを指定してプロジェクトを読み込めます。\nさて、プロジェクトができたのでこのままゲームを開発していきます。\n数字を得る 最初の例で文字列を取得できたので今度は文字列を数値にしてみます。 baseライブラリのData.StringにあるparsePositiveが目的のもののようです。 これは一度REPLで試した方が良いでしょう。 一旦REPLに Data.String をロードします。\nIdris\u0026gt; :module Data.String parsePositive は String を受け取って Maybe Integer を返す関数です。\n*Data/String\u0026gt; parsePositive parsePositive : String -\u0026gt; Maybe Integer Maybe は他言語で言うところのNullableとかOptionalとかに相当します。 値がある Just か、値がない Nothing のどちらかです。 REPLで入力を与えてみましょう。\n*Data/String\u0026gt; parsePositive \u0026#34;10\u0026#34; Just 10 : Maybe Integer *Data/String\u0026gt; parsePositive \u0026#34;-1\u0026#34; Nothing : Maybe Integer *Data/String\u0026gt; parsePositive \u0026#34;0\u0026#34; Just 0 : Maybe Integer *Data/String\u0026gt; parsePositive \u0026#34;100\u0026#34; Just 100 : Maybe Integer *Data/String\u0026gt; parsePositive \u0026#34;hoge\u0026#34; Nothing : Maybe Integer これを使ってユーザから数値を得るプログラムを書きます。 ところで、 parsePositive の返り値が Just か Nothing かで場合分けが必要ですよね。 case 式をみてみましょう。\ncase による条件分岐 Idrisには if 式もありますが case をみてみます。 case は以下のような構文で使います\ncase 条件 of パターン1 =\u0026gt; 式1 パターン2 =\u0026gt; 式2 ... ここでもオフサイドルールが適用されます。 これを使ってひとまず「ユーザから得た入力が正の数値ならそれを、そうでなければ-1を返す」アクションを作ってみましょう。 これは IO のアクションで、返り値が整数なので型は IO Integer になります。 素朴に書くとこうなりそうですかね。\nimport Data.String -- これはコンパイルエラー getInteger : IO Integer getInteger = do putStr \u0026#34;guess a number: \u0026#34; n \u0026lt;- getLine case parsePositive n of Just n =\u0026gt; n Nothing =\u0026gt; -1 しかしこれはエラーです。\nEntering directory `./src\u0026#39; Type checking ./Main.idr Main.idr:10:15: | 10 | Just n =\u0026gt; n | ^ When checking right hand side of Main.case block in getInteger at Main.idr:9:9-22 with expected type IO Integer Type mismatch between Integer (Type of n) and IO Integer (Expected type) do 記法で IO アクションを合成しようとしているのに case から整数値を返しているのでエラーになっているのです。 これは整数値の方を IO に合わせてあげると解決します。純粋な値から IO に合わせるには pure 関数を使います。\ngetInteger : IO Integer getInteger = do putStr \u0026#34;guess a number: \u0026#34; n \u0026lt;- getLine case parsePositive n of Just n =\u0026gt; pure n Nothing =\u0026gt; pure (-1) - が減算演算子と解釈されないように括弧が必要ですが素直にこれで動きます。\nさて、取得はできたのですが数値以外が入力されたら -1 が返ってしまいます。 数値以外が入力されたらもう一度入力を促すようにしましょう。これにはループが必要です。\nループ Idrisは関数型言語なので制御構造のループはないです。関数をもう一度呼ぶとループになります。 case の Nothing の部分で getInteger を呼びましょう。\ngetInteger : IO Integer getInteger = do putStr \u0026#34;guess a number: \u0026#34; n \u0026lt;- getLine case parsePositive n of Just n =\u0026gt; pure n Nothing =\u0026gt; do putStrLn (n ++ \u0026#34; is not a number.\u0026#34;) getInteger 厳密にいうと getInteger は引数を取らないので関数ではなく値なのですが、まあ細かいことはいいですよね。\nゲーム ここまできたら一気にゲームを書けそうです。 因みにユーザの入力値と秘密の値の比較結果には「小さい」、「合った」、「大きい」の3種類がありますね。そういう用途には compare 関数が便利です。2値を比較して LT 、 EQ 、 GT のいずれかを返してくれます\nλΠ\u0026gt; compare 1 1 EQ : Ordering λΠ\u0026gt; compare 1 2 LT : Ordering λΠ\u0026gt; compare 2 1 GT : Ordering これを使ってゲームはこう書けます。ただし秘密の数字は適当に渡ってくるものとします。\ngame : Integer -\u0026gt; IO () game secret = do n \u0026lt;- getInteger case compare n secret of LT =\u0026gt; do putStrLn \u0026#34;Too small\u0026#34; game secret EQ =\u0026gt; putStrLn \u0026#34;You got it\u0026#34; GT =\u0026gt; do putStrLn \u0026#34;Too big\u0026#34; game secret -- 秘密の数字を適当に渡す main : IO () main = game 42 これで秘密の数値が固定な以外はゲームが動くようになりました。 最後に秘密の数値を乱数にしましょう。これには一仕事必要です。\nファイルIO UNIX系システムでは /dev/random ファイルを読むと乱数が得られます。Windowsは私は詳しくないので適当に調べてください。ここから4バイトほど読み出して乱数を取得しましょう。 ファイルIOは Prelude.File に多少の操作が定義されています。\n今回使うのは openFile 、 fGetChars 、 closeFile です。REPLでドキュメントをみてみましょう。 ドキュメントを読んでびっくりしたのですがバイト(列)を読み出すAPIがないみたいなので fGetChars で文字として読み出してから数値に変換します。\nλΠ\u0026gt; :doc openFile Prelude.File.openFile : (f : String) -\u0026gt; (m : Mode) -\u0026gt; IO (Either FileError File) Open a file Arguments: f : String -- the filename m : Mode -- the mode; either Read, WriteTruncate, Append, ReadWrite, ReadWriteTruncate, or ReadAppend The function is Total λΠ\u0026gt; :doc Mode Data type Prelude.File.Mode : Type Modes for opening files Constructors: Read : Mode WriteTruncate : Mode Append : Mode ReadWrite : Mode ReadWriteTruncate : Mode ReadAppend : Mode λΠ\u0026gt; :doc fGetChars Prelude.File.fGetChars : (h : File) -\u0026gt; (len : Int) -\u0026gt; IO (Either FileError String) Read up to a number of characters from a file Arguments: h : File -- a file handle which must be open for reading The function is Total λΠ\u0026gt; :doc closeFile Prelude.File.closeFile : File -\u0026gt; IO () The function is Total openFile の返り値に出てくる File というのがファイルハンドルを表すデータ型です。 FileError は名前の通りエラーですね。 Mode はドキュメントの通りファイルを開く時のモードです。今回は Read が必要なもののようです。\nところで地味にここで初めて2引数関数がでてきましたね。 T -\u0026gt; U -\u0026gt; S で概ね「T 型の値と U 型の値を受け取って S 型の返り値を返す関数」の意味です。本当は違います。気になる人は「カリー化」でググってみて下さい。役に立たない情報がいくらでもでてきます。 2引数の関数を呼び出すときは openFile \u0026quot;/dev/random\u0026quot; Read のようにスペースを空けて引数を並べます。これも本当は違います。同様にググってみて下さい。\n上記以外で初めて出てきたのは Either でしようか。それについて軽く紹介します。\nEither Either はパラメータを2つ取るデータ型です。 Either E T は Java風に書けばだいたい Either\u0026lt;E, T\u0026gt; になります。 この型は名前通りに「E 型の値、もしくは T 型の値」を表すデータ型です。 例えば Integer と String を混ぜて扱うことができるのです。以下の例を見てみましょう。\ntryParse : String -\u0026gt; Either String Integer tryParse input = case parsePositive input of -- パースに失敗したら `String` 型の値。`Left` で `Either` にする Maybe =\u0026gt; Left input -- パースに成功したら `Integer` 型の値。 `Right` で `Either` にする Just n =\u0026gt; Right n さて、この Either の使い道ですが、エラーの扱いでよくでてきます。 多くの関数は「失敗してエラー値を返す、または成功して正常値を返す」という挙動をするので Either がもってこいなのです。\n元の openFile を見てみると Either FileError File とエラー値、または正常値を返していますね。例外ではないのでエラーも値として扱えます。 慣習的に左 (Left) がエラー値、 右 (Right) が正常値を表します。 一部のAPIも右だけ優遇されていたりします。\n読み出す Either について理解したのでひとまずファイルを開くところまでは一気に書けそうですね。 openFile の返り値が Either なので case で分岐してあげます。\ngetRandom : IO (Either FileError Int) getRandom = do efile \u0026lt;- openFile \u0026#34;/dev/random\u0026#34; Read case efile of Left e =\u0026gt; pure (Left e) Right file =\u0026gt; ?Unimplemented 因みに Int は固定精度整数、 Integer は任意精度整数です。\nλΠ\u0026gt; :doc Int Primitive type Int : Type Fixed-precision integers of undefined size λΠ\u0026gt; :doc Integer Primitive type Integer : Type Arbitrary-precision integers 流石に任意長の乱数を取得してると終わらないので固定長にします。あとで Integer に変換して使います。 さて、ここから処理が続きます。 fGetChars で読み出します。返り値のEitherから同じく分岐で文字列を取り出します。 上の ?Unimplemented の部分をこう書換えます。\ndo echars \u0026lt;- fGetChars file 4 case echars of Left e =\u0026gt; pure (Left e) Right chars =\u0026gt; ?Unimplemented Char と Int のサイズはわからないのですが、 4文字くらい読んだらそれなりのサイズの乱数になるだろうという判断で4文字読み取ります。 文字列を取り出した後は普通の処理です。次に進みましょう。\n文字列処理 文字列から数値に変換しましょう。 unpack, ord などで文字列から数値の列に変換します。 まずはREPLで挙動を試してみましょう。\nλΠ\u0026gt; unpack \u0026#34;1234\u0026#34; [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;] : List Char λΠ\u0026gt; map ord (unpack \u0026#34;1234\u0026#34;) [49, 50, 51, 52] : List Int map が出てきましたがこれは多くの言語にも似たような関数があるので分かるかと思います。\n次は数値の列をバイト列として結合して1つの数値にします。 Javaならだいたいこんな感じの処理になりますかね。\nint acc = 0; for (int i : intList) { acc = (acc \u0026lt;\u0026lt; 8) + i; } return acc; 関数型言語ではループは関数で書くのでした。 ループを関数で書くとこういう感じになりますかね。\n-- `loop 0 intList` と呼ばれることを想定 loop : Int -\u0026gt; List Int -\u0026gt; Int loop acc intList = case intList of [] =\u0026gt; acc i :: intList =\u0026gt; loop ((shiftL acc 8) + i) intList しかしこういう処理はあまりに定形すぎます。そこで foldl という専用の関数が用意されています。 loop 0 intList 相当の処理はこう書けます。\nfoldl (\\acc, i =\u0026gt; (shiftL acc 8) + i) 0 intList \\引数1, .. ,引数n =\u0026gt; 本体 はクロージャの構文です。\nこれをREPLで試してみましょう\nλΠ\u0026gt; foldl (\\acc, i =\u0026gt; (shiftL acc 8) + i) 0 (map ord (unpack \u0026#34;1234\u0026#34;)) 825373492 : Int 結果、getRandom はこうなります。\ngetRandom : IO (Either FileError Int) getRandom = do efile \u0026lt;- openFile \u0026#34;/dev/random\u0026#34; Read case efile of Left e =\u0026gt; pure (Left e) Right file =\u0026gt; do echars \u0026lt;- fGetChars file 4 case echars of Left e =\u0026gt; pure (Left e) Right chars =\u0026gt; pure (Right (foldl (\\acc, i =\u0026gt; (shiftL acc 8) + i) 0 (map ord (unpack chars)))) 結合 main で getRandom を使いましょう。 getRandom はエラーを返す可能性がありますが、その場合は無言で終了しましょう。\nmain : IO () main = do eint \u0026lt;- getRandom case eint of -- エラーが起きたらそのまま終了する Left _ =\u0026gt; pure () Right int =\u0026gt; game (cast (1 + (mod int 100))) 1から100までの数値が欲しいので (1 + (mod int 100)) と計算しています。 cast は型変換をする関数です。ここでは Int から Integer に変換します。 これで動かしてみましょう。\n1回目\nguess a number: 50 Too big guess a number: 25 Too big guess a number: 12 Too small guess a number: 16 Too big guess a number: 14 Too small guess a number: 15 You got it 2回目\nguess a number: 50 Too small guess a number: 75 Too big guess a number: 63 Too big guess a number: 56 Too small guess a number: 60 Too big guess a number: 58 Too small guess a number: 59 You got it うまく動いているようです。 ゲームは完成しました。 しかし少しコードが不格好ですね。それに開いた /dev/random を閉じ忘れてます。 もう少しIdrisの機能に踏み込んでリファクタリングしましょう。\nリファクタリング いくつかのIdrisの構文や機能を使いながらリファクタリングしていきます。\nwhere 関数の中で使う関数を定義できます。\n関数定義 where サブ関数定義 の構文です。 getRandom の中で文字列から数値に変換する部分を関数として抜き出しましょう。\n-- ... Right chars =\u0026gt; pure (Right (stringToInt chars)) where stringToInt : String -\u0026gt; Int stringToInt chars = foldl (\\acc, int =\u0026gt; (shiftL acc 8) + int) 0 (map ord (unpack chars)) さらにファイルから数値を読み出す関数も用意しましょう。\nfGetInt : File -\u0026gt; IO (Either FileError Int) fGetInt file = do echars \u0026lt;- fGetChars file 4 case echars of Left e =\u0026gt; pure (Left e) Right chars =\u0026gt; pure (Right (stringToInt chars)) 全体として getRandom はこうなります。\ngetRandom : IO (Either FileError Int) getRandom = do efile \u0026lt;- openFile \u0026#34;/dev/random\u0026#34; Read case efile of Left e =\u0026gt; pure (Left e) Right file =\u0026gt; fGetInt file where stringToInt : String -\u0026gt; Int stringToInt chars = foldl (\\acc, int =\u0026gt; (shiftL acc 8) + int) 0 (map ord (unpack chars)) fGetInt : File -\u0026gt; IO (Either FileError Int) fGetInt file = do echars \u0026lt;- fGetChars file 4 case echars of Left e =\u0026gt; pure (Left e) Right chars =\u0026gt; pure (Right (stringToInt chars)) これは where の紹介のために使ったので別にサブ関数にせずに独立した関数でもよかったかもしれません。\nガード 何箇所かで case .. of Left e =\u0026gt; pure (Left e) と書かれていますね。これはもう少し楽に書けます。 do の中で \u0026lt;- を取り出すときに同時にパターンマッチできるのです。そしてマッチに失敗したら即座に返ります。返るときの値も自分で指定できます。 fGetInt をこう書き直しましょう。\nfGetInt : File -\u0026gt; IO (Either FileError Int) fGetInt file = do -- Rightにマッチしたら値を取り出す。失敗したら(= Leftだったら) 別の値で即座に返る Right chars \u0026lt;- fGetChars file 4 | Left e =\u0026gt; pure (Left e) pure (Right (stringToInt chars)) ネストが減って楽になりました。\n$ stringToInt 、括弧が多くてカッコ悪いですよね。\nstringToInt chars = foldl (\\acc, int =\u0026gt; (shiftL acc 8) + int) 0 (map ord (unpack chars)) idrisには $ という演算子があります。これは末尾まで続く括弧を省略できる演算子です。 以下の2つの式は等価です。\nmap ord (unpack chars) map ord $ unpack chars 括弧と違って「どこまで続くんだ」と考えながら読まなくていいので読みやすくなります。 ということで stringToInt はこう書けます。\nstringToInt chars = foldl (\\acc, int =\u0026gt; (shiftL acc 8) + int) 0 $ map ord $ unpack chars 同様に書換えられる箇所はいくつもあるでしょう。\nファイルを閉じる 閉じ忘れていたファイルを閉じましょう。 ファイル操作は例外を投げなかったのでシンプルに「開く→処理する→閉じる」でよさそうです。 これは一般的な操作なので関数として定義してしまいましょう。 「処理する」の部分だけ変えられるように関数で受け取ることにして、 withOpenFile 関数をこう定義しましょう。\nwithOpenFile : String -\u0026gt; Mode -\u0026gt; (File -\u0026gt; IO (Either FileError a)) -\u0026gt; IO (Either FileError a) withOpenFile filename mode f = do Right file \u0026lt;- openFile filename mode | Left e =\u0026gt; pure (Left e) ret \u0026lt;- f file closeFile file pure ret 説明がなくてもだいたい読めるようになったと思います。 a は型変数です。要するにジェネリクスですね。\nさて、 withOpenFile を使って getRandom を書き直しましょう。\ngetRandom : IO (Either FileError Int) getRandom = withOpenFile \u0026#34;/dev/random\u0026#34; Read fGetInt where stringToInt : String -\u0026gt; Int stringToInt chars = foldl (\\acc, int =\u0026gt; (shiftL acc 8) + int) 0 $ map ord $ unpack chars fGetInt : File -\u0026gt; IO (Either FileError Int) fGetInt file = do Right chars \u0026lt;- fGetChars file 4 | Left e =\u0026gt; pure (Left e) pure $ Right $ stringToInt chars 大分すっきりしましたね。\n中置記法 ある程度好みの問題になりますが、関数を中置で書けます。 main に mod int 100 という部分があったかと思います。 関数を ` で囲むとこれを中置で書けます。 以下は同等の表現です。\nmod int 100 int `mod` 100 同様に stringToInt 関数の shiftL も中置で書き直せます。\n結びに 大体こんなところでしょうか。あんまり関数型言語っぽい部分に触れなかったので物足りない人もいるかもしれません。 今回のコードはこちらに置いておくので参考にして下さい。\n繰り返しますが、私も全然詳しくないので間違ったことを書いてるかもしれません。なんか深夜テンションで書き始めてしまったので最後まで書ききっただけです。 詳しい方、誤りなどあれば教えて下さい。\nその他の記事 Idrisの特徴である依存型のチュートリアルは「こわくないIdris」シリーズなどがあります。 Idris 0.9.9時点での情報なので少し古いかもしれませんが。\n こわくない Idris (1) こわくない Idris (2) こわくない Idris (3) こわくない Idris (4) こわくない Idris (5) こわくない Idris (6) こわくない Idris (6) 補足 こわくない Idris (7)  他は証明の紹介だとこういうのがあります。\nプログラミング言語 idris - wkwkesのやつ\n","categories":["Idris","Idris入門"],"category_urls":["/categories/idris","/categories/idris%e5%85%a5%e9%96%80"],"date":"2019-01-07","title":"Idris入門: 数当てゲーム","url":"https://KeenS.github.io/blog/2019/01/07/idrisnyuumon__kazuatege_mu/"},
  {"body":"κeenです。最近にわかにIdrisが話題になってるようですね。 私の知ってる範囲でIdrisの環境構築について書こうと思います。\n多分話題になったのはMisreading Chatが震源地でかね。私はまだ聞いてないです。\nIdrisは依存型のある汎用プログラミング言語で、Haskellっぽい雰囲気の構文を持ちます。 バックエンドはいくつかありますが、デフォルトではCが選ばれるのでおおむねネイティブコンパイルされると思ってよさそうです。他にはJavaScriptなどもあります。 Idrisそのものについてはこちらのブログを案内しておきます。 私からはインストールとかその辺を書きます。\nインストール macOSではbrewがあるようですがLinuxだとバイナリがありません。 cabalでインストールすると失敗しがちなのでstackでインストールしましょう。 だいたい以下のような感じで入ると思います。\n$ git clone https://github.com/idris-lang/Idris-dev.git $ cd Idris-dev $ git checkout v1.3.1 $ stack build $ stack install  Emacsの設定 idris-modeがあります。 処理系と対話しながらサポートしてくれるので中々便利です。 プログラムを書くのか証明を書くのかで結構変わりますが、 C-c C-s 、 C-c C-c 、 C-c C-a 、 C-c C-l あたりはよく使います。後述のipkgファイルもちゃんと認識してくれます。\nVimのサポートとatomのサポートもあるようなのでそちらもどうぞ。\nビルド 原始的には1ファイル単位でコンパイルすればいいのですがビルドシステムも一応あります。 ipkgファイルの書き方はあまりドキュメントがかかれてないのでこの辺とかこの辺見ながら書くとよいでしょう。\nパッケージマネージャ ない。お前がパッケージマネージャになるんだよ。\n使いたいライブラリはダウンロードしてきて idris --install hoge.ipkg するとインストールされます。使うときにipkgファイルで opts = \u0026quot;-p hoge\u0026quot; とかするとリンクしてくれるので使えます。 使いたいライブラリはWikiとかから探してきましょう。\n新興の elba というパッケージマネージャ/ビルドツールがありますがまだ未熟なところがあり使いづらいようです(0.2.0時点)。 具体的には既存の ipkg と互換性がない点と、登録されているパッケージを検索するインターフェースがないので何が登録されているか分からない点です。\nその他 Idrisのメイン開発者がIdris 2を開発しているらしい。\n","categories":["Idris"],"category_urls":["/categories/idris"],"date":"2019-01-06","title":"idris環境構築","url":"https://KeenS.github.io/blog/2019/01/06/idriskankyoukouchiku/"},
  {"body":"κeenです。最近、Rustのタプルに「tuple[0] じゃなくて tuple.0 のようにアクセスするのなんでだろ」というのをみかけてびっくりしたのでそれについて。\nTL;DR: タプルは構造体の一種。ユニット型は0要素タプル。\nRustのタプルの要素へのアクセスは tuple.0 のようにアクセスしたい要素の番号をドットで繋げるような記法で書きます。構造体のフィールドアクセスと似ていますね。 これについて、私のようにML系言語のバックグラウンドがある人は当たり前のように感じるでしょう。 しかし別の言語のバックグラウンド(PythonとかDとかがそうらしい？)を持つ人には驚かれるようです。 また、特段バックグラウンドがなくてもドキュメントで配列と比較するような書き方がされているのでそこからも疑問が湧くようです。\nタプルとレコード Rustだと分かりづらいのでRustが参考にしたというML系言語をみてみましょう。 ML系言語ではタプルとレコードは密接な関係があります。因みにレコードというのは構造体のようなものです。\n例えばOCamlではレコードはラベルのついたタプルだとされています。\nSMLでは逆に、タプルは特別なラベルのレコードだとされています。 これは実際に動かすと分かりやすいです。 2要素のタプルは ラベル 1 と ラベル 2 を持ったレコードです。 以下のようにタプル記法でもレコード記法でもタプルが作れます。\n$ sml Standard ML of New Jersey v110.79 [built: Tue Aug 8 23:21:20 2017] (* タプル記法 *) - (1, 2);; val it = (1,2) : int * int (* レコード記法 *) - {1 = 1, 2 = 2};; val it = (1,2) : int * int  どちらでも、 タプルはレコード(構造体)の一種なのです。\nRustのタプル Rustのタプルも同様に、フィールド名がたまたま数字になっている無名構造体という扱いです。 Rustには無名構造体がタプルしかないので分かりづらいですが、名前ありのタプル構造体だとよくかります。 タプル構造体を フィールド 0 と フィールド 1 を指定して初期化できるのです。\nstruct T(i32,i32);// タプル記法 lett1=T(1,2);// 構造体記法 lett2=T{0: 1,1: 2};// どちらも格納されるデータは同じ assert_eq!(t1.0,t2.0);assert_eq!(t1.1,t2.1); これなら要素を取り出すのに配列のようなアクセスではなく、構造体のようなアクセスなのも理解できると思います。\n同様に「タプルの要素をイテレートして取り出したい」という要望も聞きますが、これも無理な相談だと分かるかと思います。\n因みに思想関係なく今からRustでタプルに [] 記法を使ったりタプルをイテレータとして扱ったりできるかというと、できません。 Rustの [] やイテレータはそれぞれトレイトで定義されており返り値の型が同一でないといけません。それぞれ異なる型が入るかもしれないタプルにそれらのトレイトは実装できません。\nタプルとユニット タプルの話が出たのでユニット型にも触れておきます。 ユニット型は0要素のタプルです。ML系言語だと0要素のレコードでもあります。 これもSMLだと分かりやすいです。\n$ sml Standard ML of New Jersey v110.79 [built: Tue Aug 8 23:21:20 2017] (* 0要素のレコードを作る *) - {}; (* 0要素のタプル、unitと区別されていない *) val it = () : unit  Rustだと陽には表れなくて、コンパイラのコードを読んで初めて分かるので意外に思った方もいると思います。\n蛇足: 1要素タプル Rustには1要素タプルがありますが、ML系言語には1要素タプルがありません。\n$ ocaml OCaml version 4.05.0 # (1,);; Error: Syntax error: operator expected.  特にSMLは {1 = ...} だけタプルにならず、上で示した通り {} や {1 = ..., 2 = ...} だとタプルができます。不思議ですね。\n$ sml Standard ML of New Jersey v110.79 [built: Tue Aug 8 23:21:20 2017] - (1,);; = ; stdIn:1.4-1.7 Error: syntax error: deleting COMMA RPAREN SEMICOLON - { 1 = 1};; val it = {1=1} : {1:int} -  まとめ  タプルは特殊な構造体であり、ドット記法でフィールドにアクセスするのは妥当 ユニット型は0要素タプル ","categories":["Rust","SML","OCaml"],"category_urls":["/categories/rust","/categories/sml","/categories/ocaml"],"date":"2019-01-05","title":"タプル小話","url":"https://KeenS.github.io/blog/2019/01/05/tapurukobanashi/"},
  {"body":"The rest of this article is written in Japanese. For those who don\u0026rsquo;t understand Japanese, auto translation tools may help you. I\u0026rsquo;m writing my blog in Japanese because I put importance on Japanese community and the situation \u0026ldquo;information is available in mother tongue\u0026rdquo;.\nκeenです。 #rust2019 の投稿として自分の考えをまとめます。自動翻訳で翻訳しやすいように1文1文を短めに書きます。\n2018年は大きな変更が多かった。言語がかなり進化した。特にRust 2018 Editionが出た。 ライブラリも大きく変わった。Tokio 0.1が出たし、Hyper 0.12も出た。 これらの大きな変更にコミュニティが追いついていない。コミュニティに時間が必要だと思う。 アプリケーションに必要なのはフレームワークやそのエコシステムなので今出来上がりつつあるコアライブラリからさらにステップが必要だ。\n2019年のスローガンは \u0026ldquo;Ecosystem\u0026rdquo; で\n 既存のプロジェクトを完遂する (async/await, chalkify) 言語は大きく変えない  代わりに未実装のRFCを実装する  ユーザにフレームワークや周辺ライブラリを書きやすくする  基盤となるライブラリを安定化させる  ユーザに新機能を定着させる  \u0026ldquo;This library does not work with the new feature\u0026hellip;\u0026rdquo; をなくす   が必要だと思う。もちろん、コンパイラが速くなると嬉しいし、実行も速くなると嬉しい。\nその他の問題 私が最近気づいた細々した問題を挙げる。\nリンク時間 リンクが遅い。テストファイルが多いときに顕著になる。 以下のようにテストファイルが多いとリンクにすごく時間がかかる。\nCargo.toml tests/ test1.rs test2.rs test3.rs テストの数だけリンクが走るのでリンク時間が問題になる。さらに並列にビルドされるのでメモリが溢れる。\nツールとマクロの相性が悪い マクロを使うとエラーメッセージが分かりづらい。 例えば以下ようなマクロを書いたとする。\nmacro_rules!my_struct{(struct $name:ident{$($field: ident: $ty: ty),*})=\u0026gt;{struct $name{$($field: $ty),*}}} これを以下のように使うとエラーになる。\nmy_struct!{struct MyStruct{hoge: i32,fuga: i64,}} メッセージはこうだ\nerror: no rules expected the token `}` --\u0026gt; macro_struct.rs:15:5 | 15 | } | ^ error: aborting due to previous error error: Could not compile `macro_struct`. 何が悪いのか分かりづらい。\nもう1つの問題は、このマクロが正しい struct 定義の構文を受け取らない点にある。 マクロ毎に「struct 定義っぽい構文」があることになる。\nさらにrustfmtも効かなくなる。 以下のように書いてもrustfmtは何も変更しない。\nmy_struct!{struct MyStruct{hoge: i32,fuga: i64,}} これらの問題の解決策として、高レベルなマクロパターンがあると良さそうに思う。 例えば struct_def パターン。\nmacro_rules!my_struct{($struct: struct_def)=\u0026gt;{$struct;// some items (like name, fieles, arrtibutes, etc) is accessible via `#` notation impl$struct#name{// .. }}} 手続きマクロが扱いづらい 手続きマクロのためにCargoバッケージを1つ作るのは面倒だ。 1バッケージ内でライブラリ/バイナリと手続きマクロを同居させたい。 エントリーポイントに macro.rs を増やすのはどうだろう。\nsrc/macro.rs// entry point for proc_macro crate lib.rs// entry point for lib crate bin.rs// entry point for bin crate ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2019-01-01","title":"My wishilist for Rust 2019","url":"https://KeenS.github.io/blog/2019/01/01/my_wishilist_for_rust_2019/"},
  {"body":"κeenです。2018年注目していきたい技術とかをベースに1年を振り返ります。\n2018年注目していきたかった技術 Swagger 思ったより進展がなかった。業務でいえばスキーマ定義から実装されたAPIの妥当性の検査とかも入ったしだんだん浸透してきている。 拙作のchemaも少しづつ進化してる。\ndiesel 2018年の大きなイベントとして1.0がリリースされた。 記述できるSQLの表現力も豊かになったしデータとのマッピングも柔軟になった。\nGotham 思ったより奮わなかった。開発がそこまで活発ではなく、他のフレームワークに押され気味。isucon7予選のアプリをRustに移植したから解説するねで試した時もイマイチな印象だったので今後どうなるんですかね。\nCoq 全然書いてない…。\nIdris あんまり書いてない気がする。というか最近趣味でコードを書く機会が減った\n線形論理 論文読んでない(完)\nベクトル最適化 読書会やってる。 ドラゴンブックみたいな入門書とは違ってかなり実践的なことが書いてある。 依存関係をディオファントス方程式に落として解析したりとかもやってるが、ちゃんとその基礎の整数論とか線形代数とかもカバーしてるのでself-containedになってる。 ただし誤植が多すぎるので１人じゃ読めなそう。\n量子コンピュータ ひとまず量子コンピュータと量子アルゴリズム II を読んだ。 過去記事を参照 その1 その2 その3\n個人的振り返り メトリクス ブログ記事33本、スライド10綴、mendeleyに突っ込んだ論文156綴、amazonで買った技術書12冊、GitHubのcontribution 2758。\n論文と本は全て読んだわけじゃない(むしろ本は読んだ方が少ない)けどだいたいこんな感じ。\n総括 仕事ではずっと作ってたサービスが世に出た。 CF Actcast α版をリリースしました。 それ以外では会社も(また)引っ越して大きくなったしactcastの開発メンバーもかなり増えた。 確か去年末時点から比べて社員数もactcastの開発メンバー数も倍増くらいしてるんじゃないかな。 環境が変化しつつ(=仕事が増える)いままでやってた業務も変わらずやるのは辛くて開発体制変えてもらったりした。 来年からはactcastをやるのは変わらないけど別のサブシステムを一から書くことになりそう。\nプライベートではあまり活動できなかった。 一応メトリクスでは2017年を全部上回ってるので2018年の目標「もうちょっと進捗を出す」は達成した。 しかし2018年頭に終わらせる予定だったクローズドプロジェクトがまだ終わってないのでつらい。今年こそ年度末までには完遂したい。 あ、あと自作パソコン買った。そろそろノートパソコンを軽量化したい(現在2.1 Kg)。 因みに論文が多いのは春頃にarXiveのRSSを購読してたせいなんだけど結局消化が間に合わなくて購読をやめた。\n来年は プライベートであまり活動できてないせいで「2019年注目していきたい技術」みたいなのが書けない。のでここで書いてしまう。 来年の抱負は言語処理系をもう少し書く。 作りかけでとまってるSMLコンパイラやPrologインタプリタを進めたい。 というかPrologの方はWAMの論文ちゃんと読んでWAMベースの実装にしたい。今の所雰囲気で書いてる。 あとはなんだかんだLLVMをちゃんと使ったことがないのでそれ使ったプロジェクトも1つやりたい。シンプルにCコンパイラ(実はまだCコンパイラ書いたこと無い)かSchema(or ISLisp)のコンパイラかな？ 地味にGitLabが便利なのとGitHub一極集中を避けるためにGitLabも使っていきたい。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2018-12-31","title":"2018年注目していきたかった技術の振り返りと個人的振り返り","url":"https://KeenS.github.io/blog/2018/12/31/2018nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri/"},
  {"body":"このエントリは Rustその2 Advent Calendar 2018の19日目のの記事です。時空を遡って書いています。\nκeenです。\nマクロのためのユーティリティマクロを書いていると呼び出しをネストしたくなりますが、簡単には実現できないのでそれについて。 あるいは過去記事の前半と後半のギャップについて。\nTL;DR: CPSする\n例えば構造体定義をラップしてそれをJSON風に出力するメソッドを生やすマクロを考えてみましょう。 こんなのです。\nmacro_rules!json{(struct $name: ident{$($field: ident: $ty: ty,)*})=\u0026gt;{struct $name{$($field: $ty),+}impl$name{fn print_json(\u0026amp;self){println!(\u0026#34;{{\u0026#34;);$(println!(\u0026#34; {}: {},\u0026#34;,stringify!($field),self.$field);)*println!(\u0026#34;}}\u0026#34;);}}};} こういう風に使います。\njson!{struct Person{name: String,age: u32,}}fn main(){letp=Person{name: \u0026#34;κeen\u0026#34;.into(),age: 26,};p.print_json()// { // name: κeen, // age: 26, // } } クォートを忘れてますがご愛嬌。これをもう少し拡張して、フィールドに #[json] とつけたもののみ出力したいとしましょう。 以下のような動きです。\n// nameにのみ #[json] を付ける json!{struct Person{#[json]name: String,age: u32,}}fn main(){letp=Person{name: \u0026#34;κeen\u0026#34;.into(),age: 26,};p.print_json()// nameのみ出力される // { // name: κeen, // } } それがかなり面倒だよ、というお話。 まず、今のRust(1.31)ではあってもなくてもいいというパターンは書けません(つい最近nightlyに入った)。 ではどうするかというとひとまず「なんでもあり」のパターンで受け取って、あとで自分でパースします。 何でもありのパターンは tt の繰り返しで書けます。こんな感じですね。\nmacro_rules!json{(struct $name: ident{$($tt: tt)*})=\u0026gt;{// ... };} ここから構造体のフィールド定義パターンを抜き出すユーティリティマクロを定義しましょう。 こんな感じですかね。この時点で結構Hackyなんですがコメントを読めば大体分かるかと思います。 因みにマクロの「ループ = 再帰」、「マクロの分岐 = パターンマッチ」です。\n// 全体的に、 `collect_fields!(中間結果 | 入力)` という形になっている // 入力を少しずつ切り出して中間結果に加えていく。 macro_rules!collect_fields{// `#[json]` が付かないフィールドをそのまま抜き出す ($($fields:ident: $tys:ty,)*|$field: ident: $ty: ty,$($tt:tt)*)=\u0026gt;{collect_fields!($($fields: $tys,)*$field: $ty,|$($tt)*);};// `#[json]` が付くフィールドは `#[json]` 以外を抜き出す ($($fields:ident: $tys:ty,)*|#[json]$field: ident: $ty: ty,$($tt:tt)*)=\u0026gt;{collect_fields!($($fields: $tys,)*$field: $ty,|$($tt)*);};// 入力が終わったら集めた値を返す ($($fields:ident: $tys:ty,)*|)=\u0026gt;{$($fields: $tys,)*};} このマクロを用いて以下のように構造体を定義してみましょう。\nmacro_rules!json{(struct $name: ident{$($tt: tt)*})=\u0026gt;{struct $name{collect_fields!(|$($tt)*)}// ... };} しかしコンパイルするとエラーになります。\nerror: expected `:`, found `!` --\u0026gt; macro_cps.rs:50:27 | 50 | collect_fields!(|$($tt)*) | ^ expected `:` ... 67 | / json! { 68 | | struct Person { 69 | | name: String, 70 | | age: u32, 71 | | } 72 | | } | |_- in this macro invocation error: aborting due to previous error  構造体定義にはマクロを書けないんですね。まあ、言われてみれば当たり前です。 ならば、と構造体を定義するマクロを定義してみましょう。collect_fields の返り値を受け取って構造体定義に展開します。\nmacro_rules!def_struct{($name: ident,$($field: ident: $ty: ty,)*)=\u0026gt;{struct $name{$($field: $ty),+}}} これを使ってみましょう。\nmacro_rules!json{(struct $name: ident{$($tt: tt)*})=\u0026gt;{def_struct!($name,collect_fields!(|$($tt)*));};} しかしやはりこれもエラーになります。\nerror: no rules expected the token `!` --\u0026gt; macro_cps.rs:48:42 | 48 | def_struct!($name, collect_fields!(|$($tt)*)); | ^ ... 63 | / json! { 64 | | struct Person { 65 | | name: String, 66 | | age: u32, 67 | | } 68 | | } | |_- in this macro invocation error: aborting due to previous error  少し意外かもしれまれん。普段書いているプログラムはネストした式の内側から計算するので何も考えずに引数に書くと上手く計算してくれます。 しかしマクロは外側から計算するのでこれはネストした式のように見えてそうではありません。 実際には def_struct に4つの引数 $name, $collect_fields, !, (|$($tt)*) を渡しているだけなのです(括弧のある式の数え方は場合によります)。\nこれを上手くやるのが今回の主題です。 外側から計算されるなら先に計算したい collect_fields を外側に持ってくればいいのです。 その代わり、結果を使いたい def_struct マクロをコールバックとして渡してあげます。 collect_fields を改造して引数の先頭にコールバックを受け取るようにしてみましょう。 コールバックは中途半端に引数が与えられた状態で、 collect_fields の結果を引数の最後に加えると正しくなるとしましょう。\n// 全体的に、 `collect_fields!(コールバック!(部分引数)|中間結果 | 入力)` という形になっている // 入力を少しずつ切り出して中間結果に加えていく。 macro_rules!collect_fields{// `#[json]` が付かないフィールドをそのまま抜き出す ($callback:ident!($($args:tt)*)|$($fields:ident: $tys:ty,)*|$field: ident: $ty: ty,$($tt:tt)*)=\u0026gt;{collect_fields!($callback!($($args)*)|$($fields: $tys,)*$field: $ty,|$($tt)*);};// `#[json]` が付くフィールドは `#[json]` 以外を抜き出す ($callback: ident!($($args:tt)*)|$($fields:ident: $tys:ty,)*|#[json]$field: ident: $ty: ty,$($tt:tt)*)=\u0026gt;{collect_fields!($callback!($($args)*)|$($fields: $tys,)*$field: $ty,|$($tt)*);};// 入力が終わったら集めた値を返す ($callback: ident!($($args:tt)*)|$($fields:ident: $tys:ty,)*|)=\u0026gt;{$callback!($($args)*$($fields: $tys,)*);};} 呼び出しはこう書きます。\nmacro_rules!json{(struct $name: ident{$($tt: tt)*})=\u0026gt;{collect_fields!(def_struct!($name,)||$($tt)*);// ... };} これは意図通りコンパイルが通ります。めでたしめでたし。\nあとは同様に collect_json_fields と print_json を書いて下さい。\n最終的なコードはここに置いておきます。\n","categories":["Rust","Advent Calendar","Advent Calendar 2018","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2018","/categories/rust-advent-calendar"],"date":"2018-12-25","title":"Rustのマクロでネストした呼び出しを実現するために","url":"https://KeenS.github.io/blog/2018/12/25/rustnomakurodenesutoshitayobidashiwojitsugensurutameni/"},
  {"body":"このエントリはRustその2 Advent Calendar 2018 8日目の記事を時空を遡って書いています。\nκeenです。寝れないので空いてる日の分を埋めに行きます。次はSession Type。完全に趣味に走ったので実用性はないです。\n前回のType Level State Machineの発展形のようなものです。通信に型を付けます。 まず、ステートマシンは概ねオートマトンくらいの表現力があります。パッと考えて連接、選択、繰り返しはできそうですね。前回の例で連接と繰り返しはやったのであとはメソッドを複数用意して分岐できるようにしたら選択もできそうです。 これを双方向通信にも応用しようとすると少し複雑さが増します。 通信になると送信/受信の区別が必要になるのと、「選択」が送信か受信かで扱いが変わるためです。「選択」は送信側にとってはどちらか好きな方を選べます(積極的選択)が受信側にとってはどちらが来るかわからない(消極的選択)からどちらにも対応できるようにしなければなりません。あ、あと通信終了も必要です。\nまとめると、以下のプリミティブが存在します。\n 送信を表す Send 受信を表す Recv 積極的選択を表す Choose 消極的選択を表す Offer ループ(再帰)を表す Rec 。これはラベル相当。 ループ(再帰)を表す Var 。これはジャンプ相当。 通信の終了(ε)を表す Eps  これらを組み合わせると自由に通信を記述できます。 例えば「数値を受け取って真偽値を返す」通信はこう書けます。\nRecv\u0026lt;i64,Send\u0026lt;bool,Eps\u0026gt;\u0026gt; また、サーバとクライアントの型は一対一に対応するので片方の型が決まったら自動的にもう片方の型も決まります。今回はこうですね。\nSend\u0026lt;i64,Recv\u0026lt;bool,Eps\u0026gt;\u0026gt; それではではライブラリを使って遊んでみましょう。 session_types を使います。 「数値を送って100以上だったらtrueを返してさらに数値を受け取る(以下ループ)、100未満だったらfalseを返しそこで通信終了」を実装してみましょう。\nサーバ: +------------------+ | | V \u0026lt;i64 \u0026gt;bool | (S)------\u0026gt;[]--------+--\u0026gt;(E) クライアント: +------------------+ | | V \u0026gt;i64 \u0026lt;bool | (S)------\u0026gt;[]--------+--\u0026gt;(E) 選択の消極/積極が表れてませんがこういうステートマシンです。 これを型に起こします。\nusesession_types::*;type Server=Rec\u0026lt;Recv\u0026lt;i64,Send\u0026lt;bool,Choose\u0026lt;Var\u0026lt;Z\u0026gt;,Eps\u0026gt;\u0026gt;\u0026gt;\u0026gt;; 終了するかはサーバが選びます。 クライアントの型は自動的に求められます。\ntype Client=\u0026lt;ServerasHasDual\u0026gt;::Dual; まあ、双対になりますよね。\nこれに基づいたサーバの実装はこれです。sel1、sel2などと積極的選択をしているのが分かるかと思います。\nfn srv(c: Chan\u0026lt;(),Server\u0026gt;){letmutc=c// Rec\u0026lt;Recv\u0026lt;i64, Send\u0026lt;bool, Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt;\u0026gt;\u0026gt; -\u0026gt; Recv\u0026lt;i64, Send\u0026lt;bool, Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt;\u0026gt; // 環境にラベルを追加 .enter();loop{let(c_,n)=c.// Recv\u0026lt;i64, Send\u0026lt;bool, Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt;\u0026gt; -\u0026gt; Send\u0026lt;bool, Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt; recv();if100\u0026lt;=n{c=c_// Send\u0026lt;bool, Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt; -\u0026gt; Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt; .send(true)// Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt; -\u0026gt; Var\u0026lt;Z\u0026gt; .sel1()// Var\u0026lt;Z\u0026gt; -\u0026gt; Recv\u0026lt;i64, Send\u0026lt;bool, Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt;\u0026gt; .zero();}else{c_// Send\u0026lt;bool, Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt; -\u0026gt; Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt; .send(false)// Choose\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt; -\u0026gt; Eps .sel2()// Eps → 終了 .close();break;}}} クライアントはこうです。終了するかどうかはサーバが選ぶのでクライアント側にはサーバの判断を確認する分岐が必要になります。\nfn cli(c: Chan\u0026lt;(),Client\u0026gt;){letmutc=c// Rec\u0026lt;Send\u0026lt;i64, Recv\u0026lt;bool, Offer\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt;\u0026gt;\u0026gt; -\u0026gt; Send\u0026lt;i64, Recv\u0026lt;bool, Offer\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt;\u0026gt; // 環境にラベルを追加 .enter();fornin\u0026amp;[101,100001,42,200]{letc_=c// Send\u0026lt;i64, Recv\u0026lt;bool, Offer\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt;\u0026gt; -\u0026gt; Recv\u0026lt;bool, Offer\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt; .send(*n);let(c_,b)=c_// Recv\u0026lt;bool, Offer\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt; -\u0026gt; Offer\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt; .recv();ifb{println!(\u0026#34;{} is big\u0026#34;,n);}else{println!(\u0026#34;{} is small\u0026#34;,n);}c=matchc_// Offer\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt; -\u0026gt; .offer(){// Var\u0026lt;Z\u0026gt; Left(c)=\u0026gt;c// Var\u0026lt;Z\u0026gt; -\u0026gt; Send\u0026lt;i64, Recv\u0026lt;bool, Offer\u0026lt;Var\u0026lt;Z\u0026gt;, Eps\u0026gt;\u0026gt;\u0026gt; .zero(),// Eps Right(c)=\u0026gt;{println!(\u0026#34;server stopped\u0026#34;);c.close();break;}};}} あとはmainを書いてあげれば完成です。\nusestd::thread;fn main(){let(server_chan,client_chan)=session_channel();letsrv_t=thread::spawn(move||srv(server_chan));letcli_t=thread::spawn(move||cli(client_chan));let_=(srv_t.join(),cli_t.join());} さらっとしか触れませんでしたが1つのチャネルでintとboolを混ぜて通信しています。 普通にやるとunsafeになりそうですがsession typeをつけることでAPI上はunsafeが現れずにプログラミングできました。\nsession typeすごい。\n","categories":["Rust","Advent Calendar","Advent Calendar 2018","Rustで強めに型をつける","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2018","/categories/rust%e3%81%a7%e5%bc%b7%e3%82%81%e3%81%ab%e5%9e%8b%e3%82%92%e3%81%a4%e3%81%91%e3%82%8b","/categories/rust-advent-calendar"],"date":"2018-12-15","title":"Rustで強めに型をつけるPart 3: Session Type","url":"https://KeenS.github.io/blog/2018/12/15/rustdetsuyomenikatawotsukerupart_3__session_type/"},
  {"body":"このエントリはRustその2 Advent Calendar 2018 7日目の記事を時空を遡って書いています。\nκeenです。寝れないので空いてる日の分を埋めに行きます。次はType Level State Machine。あるいはやりすぎてない方のBuilderバターン。 過去記事で当たり前のように書いたコードをもう少し丁寧に説明します。\n以下のようなデータ型のビルダーを作りたいとします。\n#[derive(Debug)]struct Person{id: u32,name: String,age: u32,address: Option\u0026lt;String\u0026gt;,zipcode: Option\u0026lt;String\u0026gt;,} ビルダは以下のように使いたいとします。\nletperson=PersonBuilder::new().id(1).name(\u0026#34;κeen\u0026#34;.to_string()).age(26).address(\u0026#34;Tokyo\u0026#34;.to_string()).build(); このとき、 Person には id、name、ageのフィールドは自明なデフォルト値を持たないので必須にしたいです。 つまり少なくとも .id()、.name()、.age() の3つのメソッドを呼ばないと .build() を呼べないようにしたいです。さて、どうしましょう。\n3つのメソッドを呼ばないと.build()を実装した型がでてこないようにすればいいのです。 型の話は置いておいて、ひとまず以下のようなステートマシンをイメージしましょう。\n.zipcode() .address() +----------+ | | .id() .name() .age() v | .build() (S)-------[1]---------[2]--------[3]---------+----------(E) メソッドを呼ぶ度そのラベルのついた状態に遷移すると思って下さい。 id、name、age を呼ばないと build が呼べないですね。zipcode や address が複数回呼べてしまいますがまあ、それは目を瞑りましょう。 これを型にエンコードします。遷移はメソッド呼び出しで表現します。\n// Sに対応 struct PersonBuilderId;implPersonBuilderId{pubfn new()-\u0026gt; Self{PersonBuilderId}// idの次はname pubfn id(self,id: u32)-\u0026gt; PersonBuilderName{PersonBuilderName{id: id}}}// 1に対応 struct PersonBuilderName{id: u32,}implPersonBuilderName{// nameの次はage pubfn name(self,name: String)-\u0026gt; PersonBuilderAge{PersonBuilderAge{id: self.id,name: name,}}}// 2に対応 struct PersonBuilderAge{id: u32,name: String,}implPersonBuilderAge{// ageは最後 pubfn name(self,age: u32)-\u0026gt; PersonBuilder{PersonBuilder{id: self.id,name: self.name,age: age,address: None,zipcode: None,}}}// 3に対応 struct PersonBuilder{id: u32,name: String,age: u32,address: Option\u0026lt;String\u0026gt;,zipcode: Option\u0026lt;String\u0026gt;,}implPersonBuilder{pubfn new()-\u0026gt; PersonBuilderId{...}pubfn address(self,address: String)-\u0026gt; Self{...}pubfn zipcode(self,zipcode: String)-\u0026gt; Self{...}pubfn build(self)-\u0026gt; Person{...}} これで目的の「id、name、ageが揃うまでbuild」が呼べないが達成されました。\n因みにこのコードはRustの所有権を上手く使っています。各メソッドで self の所有権を取るので古い状態が消えるのが都合がいいんですね。 こういう状態遷移はビルダーに限らず色々あると思います。例えばヘッダを書いてからボディを書きたいとか特定のメソッドを呼ぶとアクティブになって特定のメソッドを呼ぶとパッシブになるとか。 そういうのの状態管理に使えると便利です。\nなんかあんまり丁寧な解説にならなかった\n","categories":["Rust","Advent Calendar","Advent Calendar 2018","Rustで強めに型をつける","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2018","/categories/rust%e3%81%a7%e5%bc%b7%e3%82%81%e3%81%ab%e5%9e%8b%e3%82%92%e3%81%a4%e3%81%91%e3%82%8b","/categories/rust-advent-calendar"],"date":"2018-12-15","title":"Rustで強めに型をつけるPart 2: Type Level State Machine","url":"https://KeenS.github.io/blog/2018/12/15/rustdetsuyomenikatawotsukerupart_2__type_level_state_machine/"},
  {"body":"このエントリはRustその2 Advent Calendar 2018 6日目の記事を時空を遡って書いています。\nκeenです。頭痛い。寝れない。寝れないので空いてる日の分を埋めに行きます。 「Rustで強めに型をつける」シリーズではある程度有名なテクニックを紹介しようかと思います。 みんな当たり前のように書くと知らない人はいつまで経っても知る機会が無いですからね。まずはNew Type Patternから。\n基本 例えばcrates.ioを作るとしましょう。エンティティがいくつかありますね。クレートやユーザなど。\nstruct Crate{id: u64,authors: Vec\u0026lt;User\u0026gt;,// ... }struct Release{id: u64,crate_id: u64,}struct User{id: u64,// ... } どのエンティティも大体 id フィールドを持つと思います。このような状況で以下の関数を見て下さい。\nfn list_releases(id: u64)-\u0026gt; Vec\u0026lt;Release\u0026gt;{unimplemented!()} この id には何を渡すべきでしょうか。クレートのIDを渡してそのリリース一覧を取得する関数？それともユーザIDを渡してそのユーザがauthorのリリース一覧？ パッとはわからないですね。 この問題への対処は関数がおかしいとか仮引数の名前をちゃんとつけろだとかドキュメントを書けとか色々意見があるかと思いますが、我々の頼れるコンパイラに任せてしまうのがNew Type Patternです。 まず、IDを表す型を導入します。\nstruct CrateId(u64);struct ReleaseId(u64);struct UserId(u64); そしてそれらを使います。\nstruct Crate{id: CrateId,authors: Vec\u0026lt;User\u0026gt;,// ... }struct Release{id: ReleaseId,crate_id: CrateId,}struct User{id: UserId,// ... } これで型からどのエンティティのIDを意図していたかが分かります。 これで先程の関数を書き直すと、意図がはっきりします。\nfn list_releases(id: CrateId)-\u0026gt; Vec\u0026lt;Release\u0026gt;{unimplemented!()} ドキュメントや変数名など人に頼るのではなくコンパイラの型チェックに乗せた自動化された仕組みで正しさを保証できるようになりました。\nところでこのバターン、別の見方もできます。IDの実装の隠蔽です。 IDとは別に u64 である必要はなくて、 u32 かもしれませんし UUIDかもしれません。 ユーザIDはGitHubのIDで持ってるかもしれません。 それを隠蔽するために新しい型を導入したとも見れます。\n幽霊型 ところで先程の XxxId 、エンティティが増えたら XxxId も増えるのでしょうか。増えます。大体のID型に求められる実装は同じ(Copy を導出するなど)なのでコピペが捗りますね。 これはマクロで対処することもできるのですが、もう少し楽に出来る方法があります。幽霊型(Phantom Type)を使う方法です。 まず、IDの実体は以下のように定義されます。\nusestd::marker::PhantomData;#[derive(Copy, Clone, Debug, Hash, Default, PartialEq, Eq, Ord, PartialOrd)]struct Id\u0026lt;T\u0026gt;{id: u64,_phantom: PhantomData\u0026lt;T\u0026gt;}impl\u0026lt;T\u0026gt;Id\u0026lt;T\u0026gt;{pubfn new(id: u64)-\u0026gt; Self{id,_phantom: PhantomData,}pubfn get(\u0026amp;self)-\u0026gt; u64 {self.id}} 本来ならIDに必要ない T というパラメータが増えています。 Rustは使われていない型パラメータを許さないので適当にダミーの値を作って型パラメータを消費します。そのためのデータ型が PhantomData です。 これは型パラメータを消費するためだけの存在で、サイズを持ちません。 これを使って先程の例はこう書けます。\nstruct Crate{id: Id\u0026lt;Crate\u0026gt;,authors: Vec\u0026lt;User\u0026gt;,// ... }struct Release{id: Id\u0026lt;Release\u0026gt;,crate_id: CrateId,}struct User{id: Id\u0026lt;User\u0026gt;,// ... } 内部実装は u64 に固定されてしまいますが、実装を繰り返すことなくID型を定義できました。\nノート  New Type Pattternは公式のスタイルガイドにも載っています IDに幽霊型を付けるアイディアはScala文化から借りました。元になったスライドはあるのですが今探したら見当たりませんでした。 Rustの PhantomData の扱いは罠があるのですが詳しくはqnighyさんのブログを参考にして下さい。  因みにここの例は説明を省くために罠を踏んだ形になってます。注意。  ","categories":["Rust","Advent Calendar","Advent Calendar 2018","Rustで強めに型をつける","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2018","/categories/rust%e3%81%a7%e5%bc%b7%e3%82%81%e3%81%ab%e5%9e%8b%e3%82%92%e3%81%a4%e3%81%91%e3%82%8b","/categories/rust-advent-calendar"],"date":"2018-12-15","title":"Rustで強めに型をつけるPart 1: New Type Pattern","url":"https://KeenS.github.io/blog/2018/12/15/rustdetsuyomenikatawotsukerupart_1__new_type_pattern/"},
  {"body":"このエントリーはRust Advent Calendar 20187日目の記事です。\nκeenです。Rust 2018が来ましたね。最近本業も副業(?)も大詰めで中々時間がとれずAdvent Calendarに遅刻してしまいました。 それはさておき、私はRustのモジュールの使い方を過去に書きました。 この記事は中々好評だったようですが、状況が変わりまして2018 Editionでモジュールが大幅に変更され、分かりやすくなりました。 巷に2018での変更点は多く喧伝されていますが2015との差分ばかりで、今からモジュールシステムを学ぶ方はまず複雑な2015を理解してから差分を読んで、簡単な2018を理解しないといけなくなっています。 そこで2018からはじめて学習する方向けにモジュールシステムの解説をしようと思います。\nとりあえずサンプルプロジェクトを作ります。\n$ cargo new module2018 エライのは lib.rs と main.rs モジュールの話をする前にクレートの話をしないといけません。 クレートはRustのプログラムの一番大きな単位です。 大きく分けてライブラリを作るlibクレートと実行可能ファイルを作るbinクレートがあります。\nlibクレートならばlib.rsが、binクレートならばmain.rsがルートにあたるファイルです。ここから辿れるモジュールが全てです。プロジェクトにファイルが存在していてもこれらから辿れなかったらコンパイルされません。\nモジュールの作り方は2種類  ファイルの中にインラインで作る 1ファイルで作る  のやり方があります。あと別解もあります。 1.はそんなに使われなくて、説明のために1ファイルにまとめたい時や、可視性でアレコレする時のテクニックなんかに使われます。\n2.のファイルで作る時はまず以下のようにファイルを作ります。\n$ tree src src ├── lib.rs └── new_module.rs  そして lib.rs の中で以下のようにmodで参照してあげれば使えます。\nmod new_module; サブモジュールをディレクトリで作る モジュールは入れ子にできます。 new_module.rs のファイル内に書く方法もありますがここではディレクトリで作る方を紹介します。 以下のようにnew_module.rsの他に new_module/new_submodule.rs を用意します。\n$ tree src src ├── lib.rs ├── new_module │ └── new_sub_module.rs └── new_module.rs  そして new_module.rs に以下を書いてあげます。\nmod new_sub_module; すると src/new_module/new_sub_module.rs の中身が new_module のサブモジュールになります。\n別解: 2015の遺産 new_module.rs の代わりに new_module/mod.rs も使えます。多分後方互換のために残してるんですかね。 先の例でいくと以下のような形です。\n最初のモジュールを作る例は以下のようにも書けます。\n$ tree src src ├── lib.rs └── new_module └── mod.rs  サブモジュールを作る例は以下のようにも書けます。 mod.rs に mod new_sub_module; を書きます。\n$ tree src src ├── lib.rs └── new_module ├── mod.rs └── new_sub_module.rs  昔はディレクトリを切ったら mod.rs が lib.rs の代わりの役割をしていたんですね。\n兄弟モジュール同士の可視性 モジュールの身分 さて、次のように2つのモジュールを作ってみましょう。lib.rsにはmodule_aのみmod宣言しておきます。\n$ tree src src ├── lib.rs ├── module_a.rs └── module_b.rs  lib.rs\nmod module_a; この状態でmodule_a.rsにmodule_bをサブモジュールとして宣言してみましょう。\nmod module_b; これをコンパイルすると\n$ cargo build Compiling module2018 v0.1.0 (/home/shun/Rust/module2018) error[E0583]: file not found for module `module_b` --\u0026gt; src/module_a.rs:1:5 | 1 | mod module_b; | ^^^^^^^^ | = help: name the file either module_a/module_b.rs or module_a/module_b/mod.rs inside the directory \u0026#34;src\u0026#34; error: aborting due to previous error For more information about this error, try `rustc --explain E0583`. error: Could not compile `module2018`. To learn more, run the command again with --verbose.  と怒られます。一番エラいのはlib.rsですから、身分の低い module_aではmod宣言出来ません。\nモジュールのパスネーム 同じディレクトリ構成で、今度はlib.rsにmodule_aとmodule_b両方をmod宣言しておきます。\n$ tree src src ├── lib.rs ├── module_a.rs └── module_b.rs  lib.rs\nmod module_a;mod module_b; ついでに中身を追加しましょう。module_a.rsに以下を書きます。\npubfn name(){println!(\u0026#34;module_aだよ\u0026#34;);} この時、module_bがlib.rsから見た時とmodule_a.rsから見た時で名前が変わります。\nlib.rsから見た時は、以下の2つが使えます。\nuse crate::module_a::name; // 絶対パス use self::module_a::name; // 相対パス キーワード crate と self がでてきました。 crateというのは冒頭で説明したとおりRustのプロジェクトの単位です。ここでは「このプロジェクトの module_a に所属する name 関数」と指定しているわけです。 selfというのはディレクトリでいうところの.に相当します。「いまいるモジュールのサブモジュールの module_a に所属する name 関数」と指定しています。\nmodule_b.rsからは同じく2つが使えますが、相対パスが変わります。\nuse crate::module_a::name; // 絶対パス use super::module_a::a; // 相対パス superも予約語で、..に相当します。 ファイルが同じディレクトリにいるので分かりづらいですが、libが1つ上の階層で、その下にmodule_aとmodule_bがぶら下がってる感じですね。\n2020-06-07追記: 上記の絶対パスが crate::module_a::module_a::name になっていたのを crate::module_a::name に修正しました。 /追記\nおじさんと隠し子 次のように、サブモジュールを作ってみます。\n$ tree src src ├── lib.rs ├── module_a │ └── submodule.rs ├── module_a.rs └── module_b.rs lib.rsに以下を書きます。\nmod module_a;mod module_b; module_a.rsに以下を書きます。\nmod submodule; さて、この時sumbmoduleから見たmodule_bの名前はどうなるでしょうか。もうお分かりかと思いますが、以下の2つです。\nusecrate::module_a;// 絶対パス usesuper::super::module_a;// 相対パス  じゃ、逆にmodule_bから見たsubmoduleはどうなるでしょうか。実は、module_bからsubmoduleは見えません（lib.rsからも見えません）。module_a1つで所帯を持っているので、子であるsubmoduleを外に出すかはmodule_aの一存で決まります。今回は隠し子にしている訳ですね。いくら兄弟モジュールとはいえ家庭にまでは入り込めないのです。\n子供をちゃんと公開するには\nmodule_a.rs の\nmod submodule; となっていたモジュール宣言にpub を付けてあげて\npubmod submodule; としてあげればOKです。そうするとmodule_bからも見えて、以下の2種類で参照出来ます。\nusecrate::module_a::submodule;usesuper::module_a::submodule; 家庭裁判 モジュールは名前を変えられます。\nmod module_a;useself::module_aasa; これで以後、 a というモジュールがあるかのように扱えます。 改名したものを公開したければ\nmod module_a;pubuseself::module_aasa; のように use の方に pub を付けてあげれば目的を達成できます。\n木箱の外から さて、今までは1クレート内での話でした。クレートの外から見るとどうなるでしょうか。\n新たにmain.rsを追加しましょう。先程 lib.rsとmain.rsがエライと話しましたが、どちらも別々のクレートを作るのでmain.rsは完全にクレートの外です。\nこんな感じですね。\n$ tree src src ├── lib.rs ├── main.rs ├── module_a │ └── submodule.rs ├── module_a.rs └── module_b.rs lib.rs は以下です。\nmod module_a;mod module_b; module_a.rs は以下です。\npubmod submodule; まず、binクレートなのでmain関数も必要ですね。\nmain.rs\nfn main(){} では、module_bはどういう名前で見えるでしょうか。見えません。一番エライlib.rsがmodule_bをpubにしていないのでクレートの外からは見えなくなっています。 見たければ lib.rs を以下のようにします。\nmod module_a;pubmod module_b; mod module_b の前に pub が付きました。\nさて、これでmain.rsからどのように見えるかというと、以下のようになります。\nusemodule2018::module_b; crate:: なしでアクセスしてます。 crate:: がなかったら外様という扱いなんですね。\n外部クレートのリネーム Cargo.toml でできます。今回は1クレートで説明している関係で詳しく説明できません。 ドキュメントを参照してください。\n福は内 module2018 を内部のモジュールのように扱う方法もあります。 2015まではこの方法しかありませんでした。 extern crate module2018; と、 extern crate 宣言してあげます。 するとあとは内部モジュールと同じようにアクセスできます。\nexterncratemodule2018;usecrate::module2018::module_b;// crate::.. と内部モジュールのように扱える  これは extern crate したモジュールのサブモジュール扱いになっています。UNIXファイルシステムに例えるとマウントしてるようなイメージですね\n因みにextern crate を使ったリネームもできます。\nexterncratemodule2018asm18;usecrate::m18::module_b; 家出 さて、同じようにlib.rsでmodule_aをpub modすればmodule::module_a::submoduleも参照出来るようになります。ところで、例えばmodule_aは外に出さずにsubmoduleだけを公開したい時にはどうしたらいいでしょうか。そんなケースあるのかと疑問に思うかもしれませんが、あります。同じクレートであってもpubにしないとサブモジュールにアクセス出来ないことを思い出して下さい。そうすると\npubmod submodule;pubmod internal_submodule_a;pubmod internal_submodule_b; みたいなケースが発生するのは想像出来ると思います。そういう時は、lib.rs側でどうにかいじれます。\nmod module_a;pubmod module_b; となっていると思いますが、\nmod module_a;pubmod module_b;pubuseself::module_a::submodule; と、pub use を加えてあげることでmodule_aの下から出すことが出来ます。\nこれをmain.rsから使う時は\nusemodule2018::submodule; のように名字のmodule_aが取れます。\nさらに踏み込めば、useはasを使ってリネーム出来るのでlib.rsから以下のようにリネームuseしてあげれば\nmod module_a;pubmod module_b;pubuseself::module_a::submoduleasmodule_c; main.rs から以下のように参照することも出来ます。\nusemodule::module_c; 完全に籍を外れて名前の上では別人ですね。\n実装する時の都合とAPIとして公開する時の都合が違うので公開用にいじれる作りになってるんですね。\nクレート内限定公開 クレート内からは自由に参照したいけど外部には公開したくないこともあると思います。そんなときはpub(範囲) が使えます。 一番よく使うのはpub(crate) でしょう。クレート内全体からはアクセスできるけど外部クレートからはアクセスできなくなります。 このように使います。\npub(crate)fn name(){println!(\u0026#34;module_aだよ\u0026#34;);} もうちょっと色々書けるのですがこのくらいにしておきましょう。\nlib.rsとmain.rs 上ではlib.rsを使って説明しましたが、main.rsでも同じことが出来ます。\nさて、ここからはスタイルの話ですが、私がRustを書く時はmain.rsの中にmodを書くことはないです。必ずlib.rsを作って、そこでライブラリとしてまとめてからmain.rsで使います。「アプリケーションはアプリケーションを記述するための巨大なDSLとそれを使った小さな実装からなる」という思想ですね。明示的に境界を作ることで自然とAPIを設計出来るのでコードが整理しやすくなります。\nまとめ  lib.rsとmain.rsが一番エラい。 mod で「モジュールがある」宣言 pub mod で加えて上位のモジュールにも公開 crate と selfとsuperの予約語 pub use で改名  公式ドキュメントも参考にして下さい\n","categories":["Rust","Advent Calendar","Advent Calendar 2018","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2018","/categories/rust-advent-calendar"],"date":"2018-12-08","title":"Rustのモジュールの使い方 2018 Edition版","url":"https://KeenS.github.io/blog/2018/12/08/rustnomoju_runotsukaikata_2018_editionhan/"},
  {"body":"κeenです。遅刻してしまいましたがこのエントリーは 言語実装 Advent Calendar 2018 1日目の記事です。 最近私の観測範囲内でJITが流行っているのですが一口にJITと言っても色々あるよなーと思ったので私がJITについて知っていることをグダクダ話します。\nこのブログでも何度がJITや周辺技術について取り上げてますが話の流れがスムーズになるので最初から説明していきます。\n2018-12-03: 加筆修正しました。差分はこちら\nJITって？ Just in Time(コンパイル)のことで、日本語にすると「間に合ってコンパイル」になりますかね。 インタプリタの高速化テクニックの1つです。 最初はインタプリタのようにコードをコンパイルせずプロセスが起動しますが、メソッドを実行するまでにはメソッドをコンパイルして、ネイティブコードで実行する方式です。\n本来ならJITはこのような意味なのですがここではもう少し範囲を広めに取って実行プロセス起動後にコードを生成して実行するものを全部JITと呼ぶことにします。 たとえばCommon Lispの実装の1つ、SBCLは関数を定義するときにネイティブコンパイルするのでJITとして扱うことにします。\n余談ですが動的型付言語がネイティブコンパイルできることに驚く方もいますが動的型付言語のインタプリタもCで書かれてコンパイルされているのでコンパイルできない道理はないです。 「動的に型チェックするコード」を生成すればいいだけです。\nコンパイルのタイミング プロセスが起動してから実行するまでにコンパイルすればいいのでコンパイルするタイミングはいくつかオプションがあります。\n1つはプロセスが起動したタイミングで全部コンパイルするもの。 コンパイルして実行とあまり変わらないですね。 雑な実装だとたまに見かけます。\n1つはメソッド定義時にコンパイルする方法で、上述のSBCLなどいくつか例があります。\n似たようなもので、メソッド定義したらタスクをキューに積んで別スレッドのワーカがコンパイルするモデルもTwitterで見たことありますがどの処理系かは覚えてないです。\n一番遅いタイミングだとメソッドが呼ばれる直前にコンパイルするものがあります。 呼ばれないメソッドはコンパイルされないというメリットがあります。\nいずれの場合もコンパイル時間が実行時間に含まれますのであまり大掛かりな最適化はできません。\nJITはどうして速いのか 大体の人は「コンパイルするんだからそりゃ速いだろ」くらいの感覚でしょう。しかしそんなに自明な話ではないです。 インタプリタは大抵Cで書かれてコンパイルされています。これは特にコンパイル時間に制約がないので全力で最適化できます。 時間の制約で適当にしか最適化をできないJITと全力で最適化をしたインタプリタ、本当にJITの方が速いと思いますか？\nとは言ったもののインタプリタは遅いです。 なぜなら抽象構文木(AST)を辿りながら実行するからです。 実行のコスト+木の巡回のコストが必要になるのでループなどで何度も同じコードを実行すると木の巡回コストが何倍にもなってのしかかってきます。\nVM シンプルなインタプリタだと遅いので大抵のインタプリタは一旦(インタプリタよりは)低レベルな命令列にコンパイルし、それを実行するという戦略をとります。 VM型というやつですね。\nちょっと実装してみました。 このVMではこういうことをすると関数が定義できます。 IP_INST_CONST(1) などと並んでいるのがVMの命令ですね。\nip_proc_ref_t ip_register_fib(struct ip_vm *vm) { ip_proc_ref_t fib; /* registering proc first to recursive call */ /* creating en empty proc */ fib = ip_vm_reserve_proc(vm); if (fib \u0026lt; 0) { return fib; } /* 0(arg) - n */ size_t nargs = 1; size_t nlocals = 0; #define n 0  struct ip_inst body[] = { /* 0 */ IP_INST_CONST(1), /* 1 */ IP_INST_GET_LOCAL(n), /* 2 */ IP_INST_SUB(), /* 3 */ IP_INST_JUMP_IF_NEG(5/* else */), /* then */ /* 4 */ IP_INST_CONST(1), /* 5 */ IP_INST_RETURN(), /* else */ /* 6 */ IP_INST_GET_LOCAL(n), /* 7 */ IP_INST_CONST(1), /* 8 */ IP_INST_SUB(), /* 9 */ IP_INST_CALL(fib), /* 10 */ IP_INST_GET_LOCAL(n), /* 11 */ IP_INST_CONST(2), /* 12 */ IP_INST_SUB(), /* 13 */ IP_INST_CALL(fib), /* 14 */ IP_INST_ADD(), /* 15 */ IP_INST_RETURN(), }; #undef n  int ret; struct ip_proc *proc; ret = ip_proc_new(nargs, nlocals, sizeof(body)/sizeof(body[0]), body, \u0026amp;proc); if (ret) { return -1; } ip_vm_register_proc_at(vm, proc, fib); return fib; } これを実行するVM部分はこうなります。\nint ip_vm_exec(struct ip_vm *vm, ip_proc_ref_t procref) { size_t ip = 0; size_t fp; struct ip_proc *proc; #define LOCAL(i) ip_stack_ref(ip_value_t, \u0026amp;vm-\u0026gt;stack, fp - (proc-\u0026gt;nargs + proc-\u0026gt;nlocals) + i) #define POP(ref) do{if (ip_stack_pop(ip_value_t, \u0026amp;vm-\u0026gt;stack, ref)) { return 1;}} while(0) #define PUSH(v) do{if (ip_stack_push(ip_value_t, \u0026amp;vm-\u0026gt;stack, v)) { return 1;}} while(0) #define POPN(n, ref) do{size_t i; for (i = 0; i \u0026lt; (n); i++) POP(ref);} while(0) #define PUSHN(n, v) do{size_t i; for (i = 0; i \u0026lt; (n); i++) PUSH(v); } while(0)  proc = vm-\u0026gt;procs[procref]; PUSHN(proc-\u0026gt;nlocals, IP_LLINT2VALUE(0)); fp = ip_stack_size(ip_value_t, \u0026amp;vm-\u0026gt;stack); while (1) { struct ip_inst inst = proc-\u0026gt;insts[ip]; switch(inst.code) { case IP_CODE_CONST: { ip_stack_push(ip_value_t, \u0026amp;vm-\u0026gt;stack, inst.u.v); break; } case IP_CODE_GET_LOCAL: { int i; ip_value_t v; i = inst.u.i; v = LOCAL(i); PUSH(v); break; } case IP_CODE_SET_LOCAL: { int i; ip_value_t v; i = inst.u.i; POP(\u0026amp;v); LOCAL(i) = v; break; } case IP_CODE_ADD: { ip_value_t v1, v2, ret; long long int x, y; POP(\u0026amp;v1); POP(\u0026amp;v2); y = IP_VALUE2LLINT(v1); x = IP_VALUE2LLINT(v2); ret = IP_INT2VALUE(x + y); PUSH(ret); break; } case IP_CODE_SUB: { ip_value_t v1, v2, ret; long long int x, y; POP(\u0026amp;v1); POP(\u0026amp;v2); y = IP_VALUE2LLINT(v1); x = IP_VALUE2LLINT(v2); ret = IP_LLINT2VALUE(x - y); PUSH(ret); break; } case IP_CODE_JUMP: { ip = inst.u.pos; break; } case IP_CODE_JUMP_IF_ZERO: { ip_value_t v; POP(\u0026amp;v); if (!IP_VALUE2LLINT(v)) { ip = inst.u.pos; } break; } case IP_CODE_JUMP_IF_NEG: { ip_value_t v; POP(\u0026amp;v); if (IP_VALUE2LLINT(v) \u0026lt; 0) { ip = inst.u.pos; } break; } case IP_CODE_CALL: { int ret; ip_callinfo_t ci = {.ip = ip, .fp = fp, .proc = proc}; ret = ip_stack_push(ip_callinfo_t, \u0026amp;vm-\u0026gt;callstack, ci); if (ret) { return 1; } proc = vm-\u0026gt;procs[inst.u.p]; PUSHN(proc-\u0026gt;nlocals, IP_LLINT2VALUE(0)); ip = -1; fp = ip_stack_size(ip_value_t, \u0026amp;vm-\u0026gt;stack); break; } case IP_CODE_CALL_INDIRECT: { int ret; ip_value_t p; ip_callinfo_t ci = {.ip = ip, .fp = fp, .proc = proc}; POP(\u0026amp;p); ret = ip_stack_push(ip_callinfo_t, \u0026amp;vm-\u0026gt;callstack, ci); if (ret) { return 1; } proc = vm-\u0026gt;procs[IP_VALUE2PROCREF(p)]; PUSHN(proc-\u0026gt;nlocals, IP_INT2VALUE(0)); ip = -1; fp = ip_stack_size(ip_value_t, \u0026amp;vm-\u0026gt;stack); break; } case IP_CODE_RETURN: { int ret; ip_value_t v; ip_value_t ignore; ip_callinfo_t ci; POP(\u0026amp;v); POPN(proc-\u0026gt;nlocals + proc-\u0026gt;nargs, \u0026amp;ignore); PUSH(v); ret = ip_stack_pop(ip_callinfo_t, \u0026amp;vm-\u0026gt;callstack, \u0026amp;ci); if (ret) { return 1; } ip = ci.ip; fp = ci.fp; proc = ci.proc; break; } case IP_CODE_EXIT: { ip_value_t v; ip_value_t ignore; POP(\u0026amp;v); POPN(proc-\u0026gt;nlocals + proc-\u0026gt;nargs, \u0026amp;ignore); PUSH(v); return 0; } default: { printf(\u0026#34;code: %d, u: %d\u0026#34;, inst.code, inst.u.i); return 1; } } ip += 1; } #undef POP #undef PUSH } 長いですが\nwhile(1) { struct ip_inst inst = proc-\u0026gt;insts[ip]; switch(inst.code) { case XXX: { ...; break; } ... } ip+=1; } というのが全体の構造です。 配列を舐めているだけなので木を巡回するよりずっと速いです。\nですが、これでもまだ遅いです。必要なコードを実行する以外にwhile 、 switch 、 break の3回のジャンプが必要になります。 これをどうにか節約できないでしょうか。\nThreaded VM どうにか節約するのがThreaded VMです。 break に到達した時点で次に実行する inst は計算できますし inst が分かれば switch でのジャンプ先も分かります。 それに、 switch はただのジャンプテーブルなのでswitchを使わなくてもどうにか自前で実装できます。 なので\n switch の case に相当するジャンプテーブルを自分で作る。 break の代わりにそのジャンプテーブルを作って自力で飛ぶ。  をやればジャンプ回数を節約できそうです。\nこれも実装してみました。ただし実装にはGCC拡張のLabels as Valuesを使います。\nまず、先程の case の部分はラベルになります。\nL_CONST: { ... } L_GET_LOCAL: { ... } ... そしてこれを用いてジャンプテーブルは以下のように準備できます。ただのラベルの配列ですね。\nstatic void *labels[] = { \u0026amp;\u0026amp;L_CONST, \u0026amp;\u0026amp;L_GET_LOCAL, \u0026amp;\u0026amp;L_SET_LOCAL, \u0026amp;\u0026amp;L_ADD, \u0026amp;\u0026amp;L_SUB, \u0026amp;\u0026amp;L_JUMP, \u0026amp;\u0026amp;L_JUMP_IF_ZERO, \u0026amp;\u0026amp;L_JUMP_IF_NEG, \u0026amp;\u0026amp;L_CALL, \u0026amp;\u0026amp;L_CALL_INDIRECT, \u0026amp;\u0026amp;L_RETURN, \u0026amp;\u0026amp;L_EXIT, }; \u0026amp;\u0026amp; がLabels as Valuesの機能です。ここまでくればこれだけのコードで自前ジャンプができます。\ninst = proc-\u0026gt;insts[++ip]; goto *labels[inst.code] 毎度呼ぶのでマクロでまとめるなどして、結局こんな感じのコードになります。\n#define JUMP() do{inst = proc-\u0026gt;insts[++ip]; goto *labels[inst.code];} while(0);  inst = proc-\u0026gt;insts[ip]; goto *labels[inst.code]; L_CONST: { ip_stack_push(ip_value_t, \u0026amp;vm-\u0026gt;stack, inst.u.v); JUMP(); } L_GET_LOCAL: { int i; ip_value_t v; i = inst.u.i; v = LOCAL(i); PUSH(v); JUMP(); } ... while と break が消えて switch の代わりに各 case に JUMP が入りました。\nこれを先程のシンプルなVMと比べてみましょう。ベンチマークに使うのは最初の方に出てきた fib のコードです。引数は36を与えてみます。\n$ time ./main_simple result of fib: 24157817 2.45user 0.00system 0:02.45elapsed 99%CPU (0avgtext+0avgdata 1608maxresident)k $ time ./main_threaded result of fib: 24157817 1.61user 0.00system 0:01.61elapsed 99%CPU (0avgtext+0avgdata 1536maxresident)k  $ (2.45 - 1.61) / 2.45 = 0.342\u0026hellip; $ 34%の高速化です。\nDirect Threaded VM これでもまだ無駄があります。 先程のコードはジャンプテーブルを使っていました。 しかし次に実行するVM命令は関数を定義した時点で決まっているはずなのでテーブルすら不要です。 要するに inst.code というのがテーブルのインデックスになってましたが、インデックスの代わりに直接ジャンプ先のコードを入れてしまえば速いだろということです。\nこれも実装してみました。関数定義時には一旦 inst.code を使いますがすぐにアドレスに書換えてしまいます。それがこのコード。\nfor(i = 0; i \u0026lt; ninsts; i++) { struct ip_inst_internal inst; inst.label = labels[insts[i].code]; // ...  result[i] = inst; } return 0; あとはJUMP を少しだけ書換えたら完了です。\n// `goto *labels[inst.code]` が `goto *inst.label` になっている #define JUMP() do{inst = proc-\u0026gt;insts[++ip]; goto *inst.label;} while(0); 同じくベンチマークを取ってみましょう。\n$ time ./main_direct_threaded result of fib: 24157817 1.52user 0.00system 0:01.52elapsed 99%CPU (0avgtext+0avgdata 1536maxresident)k  元のVMから比べて $ (2.45 - 1.52) / 2.45 = 0.379\u0026hellip; $ 38%の高速化です。 因みにThreaded VMから比べると $ (1.61 - 1.52) / 1.61 = 0.055\u0026hellip; $ 6%の高速化です。 わずかながら高速化しました。\nそれでもまだ、ジャンプが1つ残っています。 メソッド定義時点で次に実行するコードは分かっているのでした。 残ったジャンプも取り除けないでしょうか。\nなんちゃってJIT ジャンプが嫌ならコードをくっつけてしまえばいいのです。 VM命令に対応するネイティブコード片を集めてきて1箇所のメモリに書き込めばジャンプが消えます。\nこれも実装してみました。\n下準備としてVM部分を以下のように書換えます。\n#define NEXT() arg = proc-\u0026gt;args[++ip];  L_CONST: { ip_stack_push(ip_value_t, \u0026amp;vm-\u0026gt;stack, arg.u.v); arg = proc-\u0026gt;args[++ip]; NEXT(); } L_CONST_END: L_GET_LOCAL: { int i; ip_value_t v; i = arg.u.i; v = LOCAL(i); PUSH(v); NEXT(); } L_GET_LOCAL_END: ジャンプが消えるのでJUMP 内にあったgotoは消えますが、 ip をインクリメントして仮想命令の引数を取り出すところは残ります。 このL_CONST から L_CONST_END までが IP_CODE_CONST に対応するネイティブコードですね。 事前準備としてこれを1命令毎にバッファに書き込んでいきます。\ncase IP_CODE_CONST: { code_size = \u0026amp;\u0026amp;L_CONST_END - \u0026amp;\u0026amp;L_CONST tmp = realloc(tmp, total_code_size + code_size); memcpy(tmp+total_code_size, \u0026amp;\u0026amp;L_CONST, code_size); total_code_size += code_size; } 他にも多少変更点はあるのですがだいたいこんなところです。 ただしコードを書き込んだメモリは扱いに注意が必要です。 詳しくは2015年のAdvent Calendarに書きましたので気になる方は一読下さい。\n準備が済んだコードの実行は goto するだけです\narg = proc-\u0026gt;args[ip]; goto *proc-\u0026gt;code; さて、これもベンチマークを取ってみましょう\n$ time ./main_simple_jit Command terminated by signal 11 0.00user 0.00system 0:00.10elapsed 0%CPU (0avgtext+0avgdata 1168maxresident)k  はい、あえなくSEGVしてしまいました。 これは code_size = \u0026amp;\u0026amp;L_CONST_END - \u0026amp;\u0026amp;L_CONST の部分が嘘だったようです。 コンパイルでラベル位置が意図したところに来ないので\u0026amp;\u0026amp;L_CONST_END - \u0026amp;\u0026amp;L_CONSTが負になるケースがあるようでした。 これをやりたければアセンブラで頑張るしかないようですね。1日でシンプルなVMからJITまで実装するのは無理だったようです。\n動かないのは置いておいて、もし動いたとしたらこれは理想的なコードでしょうか。 これは最適化されたコードをくっつけています。でもやっぱり、くっつけた後に最適化したいですよね？ たとえば以下のような命令列は\nIP_INST_GET_LOCAL(0), IP_INST_GET_LOCAL(1), IP_INST_SUB(), コードの並びとしてはこのようになります。\n{ ip_value_t v; v = LOCAL(0); PUSH(v); } { ip_value_t v; v = LOCAL(1); PUSH(v); } { ip_value_t v1, v2, ret; long long int x, y; POP(\u0026amp;v1); POP(\u0026amp;v2); y = IP_VALUE2LLINT(v1); x = IP_VALUE2LLINT(v2); ret = IP_LLINT2VALUE(x - y); PUSH(ret); } でも、 PUSH して POP と無駄を挟んでいるので最適化して\nip_value_t v1, v2, ret; long long int x, y; v1 = LOCAL(0); v2 = LOCAL(1); y = IP_VALUE2LLINT(v1); x = IP_VALUE2LLINT(v2); ret = IP_LLINT2VALUE(x - y); PUSH(ret); のように短くできるはずです。 これはコード同士の並びがわからないとできないのでくっつけたあとに最適化したいですよね。\nコンパイラを使ったJIT コードをくっつけたあとにコンパイルする話です。\nコードは概ねこのような見た目なのでした。\nL_CONST: { ip_stack_push(ip_value_t, \u0026amp;vm-\u0026gt;stack, arg.u.v); arg = proc-\u0026gt;args[++ip]; NEXT(); } これをマクロにしてみます。\n#define OP_CONST(v) { \\ ip_stack_push(ip_value_t, \u0026amp;vm-\u0026gt;stack, (v)); \\ arg = proc-\u0026gt;args[++ip]; \\ NEXT(); \\ } すると、このような命令列から\n/* 0 */ IP_INST_CONST(1), /* 1 */ IP_INST_GET_LOCAL(n), /* 2 */ IP_INST_SUB(), /* 3 */ IP_INST_JUMP_IF_NEG(5/* else */), /* then */ /* 4 */ IP_INST_CONST(1), /* 5 */ IP_INST_RETURN(), /* else */ /* 6 */ IP_INST_GET_LOCAL(n), /* 7 */ IP_INST_CONST(1), /* 8 */ IP_INST_SUB(), /* 9 */ IP_INST_CALL(fib), /* 10 */ IP_INST_GET_LOCAL(n), /* 11 */ IP_INST_CONST(2), /* 12 */ IP_INST_SUB(), /* 13 */ IP_INST_CALL(fib), /* 14 */ IP_INST_ADD(), /* 15 */ IP_INST_RETURN(),  以下のようなCのコードを吐くことはたやすいですね。\nint run(struct ip_vm *vm) { // 諸々の準備 OP_CONST(1); OP_GET_LOCAL(n); OP_SUB(); OP_JUMP_IF_NEG(L_5); OP_CONST(1); OP_RETURN(); L_5: OP_GET_LOCAL(n); OP_CONST(1); OP_SUB(); OP_CALL(fib); OP_GET_LOCAL(n); OP_CONST(2); OP_SUB(); OP_CALL(fib); OP_ADD(); OP_RETURN() // 諸々の後始末 }  これをコンパイルしたら望み通りコードをくっつけた後にコンパイルすることができます。目標達成です。\nところ実行中にCコンパイラを呼んで新しい実行可能ファイルを作ったところでどう実行するんだと思うかもしれません。 これはDLLを作ってロードしてあげれば実行できます。 そういう話は話はやはり2015年のAdvent Calendarに書いたので参考にして下さい。\nこれも実装してみようとしましたが先のJITの例が動かなかったので萎えて書いてないです。 ちゃんと実装したら多分動きます。\nもうちょっと 最終的にCのコードを吐くところまでいきました。実行性能は申し分無いはずです。これより先はあるでしょうか。\nやっぱり、実行中にCコンパイラのプロセスを呼ぶのは筋が悪いです。 外部システムに依存しますしプロセスの起動はそこそこ重い処理です。 最適化もCのセマンティクスを通すので本来処理系が知ってるはずの情報が落ちたりもします。 さらにDLLにしてロードというだけで時間的にも空間的にもオーバーヘッドがあります。 そこを気にしだすとインメモリでアセンブルして自前でコード生成になったりします。\nならば、とLLVMを使う例もありますがLLVMはコンパイラ向けの中間言語を使うので軽い気持ちで使うと思ったより面倒なことになるでしょう。 LLVMを使ってJITをしていたRubyのRubiniusやPythonのPystonが奮わないのもそのせいかもしれません。あとLLVMつらいらしい(あんまりLLVM使ったことがないので伝聞)。\nあるいはアセンブラを直接書けるとその処理系に特化したコード生成できたりします。 Common LispだとCのコードを吐いてコンパイルする処理系にECLというのがありますが、ほとんどのベンチマークで、自分でアセンブラまで持ってるSBCLより遅いです。 これはCコンパイラが弱い訳ではなくてSBCLがかなり工夫を凝らした実装をしているからです。 たとえば多値と単値を区別するのにキャリーフラグを使っておりレジスタ使用量を抑えたりしています。この話題は最近話したので良かったら見てみて下さい。\n歴史あるCommon Lisp処理系のSBCLは様々なプラットホーム向けに頑張ってアセンブラを実装していますが流石にそこまでやれる処理系はそう多くないでしょう。ライブラリの助けを借りることになります。 JITライブラリもいくつかあります。LibJITやGNU Lightning、もう少し軽いのならXbyakなど。あとLuaJITのやつなんだっけ。\nツールは主眼であった問題を解決してくれますが、今度はツールを上手く使いこなすという問題がでます。 たとえば命令の並びが決定すると PUSH と POP が減らせるという話もメモリが絡む最適化はCコンパイラが苦手とするところなのでやってくれないかもしれません。 結局は作者側での工夫が必要でしょう。\nJITを超えた先へ JITの常識を超えてみましょう。何があるでしょうか。\nたとえば、2度コンパイルする。\nたとえば、コンパイルしない。\n適応的最適化 折角ランタイムにコード生成しているのでもうちょっとダイナミックなことをしてみましょう。\nある関数が何度も呼ばれることが分かった場合、時間を掛けてでも最適化する価値があります。 たとえばHTTPサーバのハンドラは何日間ものあいだ無数に実行されるのでコンパイルに1分掛かろうがペイするでしょう。 何度も呼ばれる関数はもう一度、最適化レベルを上げてコンパイルし直すというのが考えられます。\n適応的コンパイル 先程までは全てのコードを最適な状態で動かす前提で話していました。 しかしDirect Threaded VMあたりから事前準備が必要になりました。 これは各々の関数定義にオーバーヘッドを加えるのであまり実行させない関数に対して行うとかえって遅くなったりします。 そこでまずはオーバーヘッドのかからない実行方式で実行し、それなりに実行される関数と判明したらもうちょっと速く実行できる方式に切り替えるというのが考えられます。 つまり、必要なければコンパイルしない。\nこの方法はコンパイルが間に合ってないのでJust in Timeではなないですね。 なので厳密にいうとJITには含まれませんがこういうのも含めてJITと呼ぶことが多いようです。\n一見良さそうなアイディアですが今までの方式と比べて大きな技術的トレードオフがあります。 VMとコンパイルされるコード、2種類のインタプリタを実装する必要があるのです。 これは手間なだけではなく両者で挙動が違うと、たとえば256回実行すると結果が変わるバグなどになります。 この大きなトレードオフにも関わらず適応的コンパイルを選択するケースが多いようです(要出典)。みなさん頑張りやさんですね。\nTracing JIT 今まで、関数(メソッド)単位でコンパイルする話をしてきました。別の方法がないか考えてみましょう。\nたとえばこのような命令列を考えます\n/* 0 */ IP_INST_CONST(0), /* 1 */ IP_INST_SET_LOCAL(i), /* 2 */ IP_INST_CONST(0), /* 3 */ IP_INST_SET_LOCAL(sum), /* loop */ /* 4 */ IP_INST_GET_LOCAL(n), /* 5 */ IP_INST_GET_LOCAL(i), /* 6 */ IP_INST_SUB(), /* 7 */ IP_INST_JUMP_IF_NEG(16 /* exit */), /* 8 */ IP_INST_GET_LOCAL(sum), /* 9 */ IP_INST_GET_LOCAL(i), /* 10 */ IP_INST_ADD(), /* 11 */ IP_INST_SET_LOCAL(sum), /* 12 */ IP_INST_GET_LOCAL(i), /* 13 */ IP_INST_CONST(1), /* 14 */ IP_INST_ADD(), /* 15 */ IP_INST_SET_LOCAL(i), /* 16 */ IP_INST_JUMP(3 /* loop */), /* exit */ /* 17 */ IP_INST_GET_LOCAL(sum), /* 18 */ IP_INST_RETURN(),  これを実行するともちろんループ内のコードが繰り返し実行されますね。 もし実行されるVM命令列のトレースを取ったらこのような見た目になるでしょう。\nGET_LOCAL(0) GET_LOCAL(1) SUB() JUMP_IF_NEG(16) GET_LOCAL(2) GET_LOCAL(1) ADD() SET_LOCAL(2) GET_LOCAL(1) CONST(1) ADD() SET_LOCAL(1) JUMP(3) /* 2周目 */ GET_LOCAL(0) GET_LOCAL(1) SUB() JUMP_IF_NEG(16) GET_LOCAL(2) GET_LOCAL(1) ADD() SET_LOCAL(2) GET_LOCAL(1) CONST(1) ADD() SET_LOCAL(1) JUMP(3) ...  これは簡単な例でしたがループ内で関数呼び出しがあったり分岐があったりするともう少し状況が複雑になります。 それでも、「よく実行されるトレースパターン」というのが浮かび上がるはずです。 このトレースベースでコンパイルしよう、というのがトレーシングJITです。\n私はTracing JITについてPyPyの人のブログを読んで感動した記憶があります。 2012年の記事ですがサンプル実装コードがPrologだったりかなりのニンジャであることが伺える楽しい連載なので是非一読下さい。\nComparing Partial Evaluation and Tracing, Part 1 \n素晴らしいことに和訳もあります\n部分評価とトレーシングの比較 Part 1 \nつながりが見づらいですが左のアーカイブから2012年の1月と2月の記事を開くと続きが見つかります。\nさて、Tracing JITですがこれはとてつもなく強力です。 関数に縛られないので数度しか呼ばれないけどものすごく重いループを回す関数もループ内だけ最適化できます。 関数を跨いでのトレースを取れば関数を跨いでの最適化ができます。 ifのthen節がよく実行されるならthen節のみのトレースが出てくるのでifの条件節が常にtrueであることを前提に最適化できます。 たとえば if x isinstanceof Int がtrueならば以後は動的型チェックを省いて実行できたりします。\nしかしやはりこれにもトレードオフが入ります。これも適応的コンパイルの一種なので適応的コンパイルのデメリットはそのまま残りますが、さらなるデメリットがあります。 メソッドの実行途中でVMから抜けてネイティブコードになったりネイティブコードを実行してたら急にVMに戻ったりするわけです。 そういう橋渡しがかなり難しいと聞きます。 が、私は詳しくないので詳しい方に説明をゆずります。言語実装 Advent Calendarの続きにご期待下さい。\n最後に 遅刻して大変申し訳ありませんでした。敗因は「VMくらい2時間程度あれば書けるだろ」とタカをくくってたらDirect Threaded VMとJITのデバッグでかなり時間を取られたことです。あと数年ぶりにCを書いた。 因みにVM自体はWebassemblyやHuman Resource Machineを真似して命令セットを書いたら書きやすかったです。\n「JITを超えた先へ」のところはぶっちゃけ全然知らないです。PyPyのブログを読むまでは適応的コンパイルのことをTracing JITと思ってました。\nノート  今回書いたコードはこちらです VM, Threaded VM, Direct Threaded VMに関しては毎度ながらこの記事を参考にさせていただきました。 YARV Maniacs 【第 3 回】 命令ディスパッチの高速化 今回私が書いたVMはメモリの扱いがないので比較的 1命令あたりの計算量が少ないです。実際の処理系だと少し結果が変わるかもしれません とはいえ過去に数十%の高速化に成功したこともあるので場合によりけり。 CF Onigmoを最大49%高速化した話  余談ですが当時Threaded VMとDirect Threaded VMの違いを分かってなかったのでThreaded VMなのにDirect Threaded VMと呼んでしまってます。  ラベルとラベルの間のコードをコピーするJITの話はOracle Labのどこかのスライドで見た記憶から実装しましたが思い出せませんでした。 マクロを定義してCコードを生成するのは確かmoclで見た気がします。恐らくKCLの頃からやってるんじゃないでしょうか。 JITにCコンパイラを使うと無駄が多いという話をしましたがRubyのJITは色々工夫を凝らしているようです。言語実装 Advent Calendarの最終日にその話があるようなので期待しましょう。  付録 JITあれこれ https://t.co/pwdpM5jzVA 分かりやすくて丁寧なJITの解説。私が試した時は、Threaded VMはそれほど速くならなかった気がするので、使ったコンパイラとOSを書いてくれるとより良いかなと思った\n\u0026mdash; Miura Hideki (@miura1729) 2018年12月2日 \n確かにそうですね。本文中でベンチマークを取った環境は以下です。\n コンパイラ: gcc (Ubuntu 8.2.0-7ubuntu1) 8.2.0 OS: Ubuntu 18.10 CPU: AMD Ryzen Threadripper 1950X 16-Core Processor  AMDマシンですね。\nところで私はもう一つマシンを持ってるのでこちらでもベンチマークをしてみます。\n コンパイラ: gcc (Ubuntu 7.3.0-27ubuntu1~18.04) 7.3.0 OS: Ubuntu 18.04 CPU: Intel\u0026reg; Core\u0026trade; i7-4910MQ CPU @ 2.90GHz  こちらはIntelマシンです。ベンチマークの結果はこうなりました。\n$ time ./main_simple result of fib: 24157817 1.23user 0.00system 0:01.24elapsed 99%CPU (0avgtext+0avgdata 1556maxresident)k $ time ./main_threaded result of fib: 24157817 1.24user 0.00system 0:01.24elapsed 100%CPU (0avgtext+0avgdata 1552maxresident)k $ time ./main_direct_threaded result of fib: 24157817 1.19user 0.00system 0:01.19elapsed 100%CPU (0avgtext+0avgdata 1532maxresident)k  うおー、Threaded VMで遅くなってる。 コンパイラのバージョンとCPUの両方が変わってるのでわかりませんがIntel CPUの方が分岐予測が賢いかGCCのバージョンが上がって while (){switch (){}} のコンパイルが賢くなったか、あるいはそのどちらともでしょう。\nところで、上記までのベンチマークは最適化オプションを -O3 にしていました。アーキテクチャ間の差異が気になったので -march=native を付けて使っているCPU向けに最適化してみます。\nAMDマシン\n$ time ./main_simple result of fib: 24157817 1.66user 0.00system 0:01.66elapsed 99%CPU (0avgtext+0avgdata 1612maxresident)k 0inputs+0outputs (0major+68minor)pagefaults 0swaps $ time ./main_threaded result of fib: 24157817 1.60user 0.00system 0:01.61elapsed 99%CPU (0avgtext+0avgdata 1548maxresident)k 0inputs+0outputs (0major+67minor)pagefaults 0swaps $ time ./main_direct_threaded result of fib: 24157817 1.50user 0.00system 0:01.50elapsed 99%CPU (0avgtext+0avgdata 1536maxresident)k 0inputs+0outputs (0major+66minor)pagefaults 0swaps  Intelマシン\n$ time ./main_simple result of fib: 24157817 1.21user 0.00system 0:01.21elapsed 100%CPU (0avgtext+0avgdata 1488maxresident)k $ time ./main_threaded result of fib: 24157817 1.23user 0.00system 0:01.23elapsed 99%CPU (0avgtext+0avgdata 1560maxresident)k $ time ./main_direct_threaded result of fib: 24157817 1.22user 0.00system 0:01.22elapsed 99%CPU (0avgtext+0avgdata 1508maxresident)k まとめてみます\n   . Simple VM Threaded VM vs Simple Direct Threaded VM vs Simple     マシン1/-O3 2.45 1.61 34% 1.52 38%   マシン1/-O3 -march=native 1.66 1.60 3.6% 1.50 10%   マシン2/-O3 1.23 1.24 -0.8% 1.19 3.2%   マシン2/-O3 -march=native 1.21 1.23 -1.7% 1.22 -0.8%    マシン1 = AMD/Ubuntu 18.10/gcc 8.2.0\nマシン2 = Intel/Ubuntu 18.04/gcc 7.3.0\n参考になれば。\n","categories":["言語処理系","言語実装 Adevnt Calendar","Advent Calendar","Advent Calendar 2018"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%87%a6%e7%90%86%e7%b3%bb","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-adevnt-calendar","/categories/advent-calendar","/categories/advent-calendar-2018"],"date":"2018-12-01","title":"JITあれこれ","url":"https://KeenS.github.io/blog/2018/12/01/jitarekore/"},
  {"body":"κeenです。言語処理系勉強会 Vol.1 に参加してきました。そこでの@omochimetaruさんのSwiftのGenericsとProtocolの実装の話が面白かったので少し感想を。\nJavaのジェネリクスは型消去で実装されており、全てのジェネリクスを1関数でまかなえます。一方で統一的に扱うために参照型しかジェネリクスに使えず、プリミティブの取り回しに苦労します。 C++のテンプレートやRustのジェネリクスは型毎に実装を作るのでどんな型でも扱えますし、高速です。代わりに関数の数が増えてバイナリサイズが大きくなりがちです。 Swiftはその中間ようなアプローチを取っていました。\nSwiftのジェネリクスの話を要約すると、\n ジェネリクス関数には値型も全て参照になって渡される。ただし型のメタデータ(Metatype)を渡してゴニョゴニョして失われた型情報(Value Witness Table)を補完している  つまり1つ引数が増える  プロトコル準拠の制約が入ったジェネリクスにはその型のプロトコル実装情報を渡して(Protocol Witness Table)いる  つまりもう1つ引数が増える   ここまではSwiftコンパイラの仕事。 そして後段のLLVMが最適化をする。 VWTやPWDはコンパイル時には分かっている静的情報なのでLLVMは部分評価をしてそれぞれの型に合わせたコードを生成する。 なのでSwiftが吐いたLLVM IRでは参照渡しになっていても実際に生成されるコードが生成渡しになるとは限らない。\nこの話を聞いてものすごく筋のいい実装だなと思いました。 コンパイラは往々にして複雑になりやすいので「機能を効率的に実装」しようとすると泥沼になってしまいます。 故に「機能を実装する」と「それを効率的にする」は分けた方が開発効率の面で有利です。 Swiftの場合はさらに「機能を実装する」の部分をSwift開発者が、「それを効率的にする」の部分をLLVMに投げています。 これが本当に重要で、関心への集中を実現できています。 すなわち、Swiftコンパイラの作者にしかできない「Swiftに機能を追加する」ことだけをやってそれを効率的にする部分はありものを流用しているのです。 本当にお手本のようなエンジニアリングだなと思いました。まる。\nところでC++やRust、Javaの筋が悪いかというとそういうわけでもありません。 C++やRustはシステムプログラミング言語としてゼロオーバーヘッド原理を実現したいので「設計上」そういう選択をしたのだと思います。 また、Javaは登場当初はジェネリクスが入っておらず、後にジェネリクスが入りました。 Javaは後方互換性を大事にしているのでバイトコードへの大幅変更が必要ない今の方式が採用されたのだと聞いています。 それぞれの言語に各々の正しいエンジニアリングが存在するのでしょうが、多くの高級言語にとってはSwiftのようなアプローチがお手本になるのかなと思います。\n追記: こういう話が好きな方は是非言語実装 Advent Calendar 2018に記事を書いて下さい。\n","categories":["言語実装","Lisp","Common Lisp"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/lisp","/categories/common-lisp"],"date":"2018-11-17","title":"言語処理系勉強会に参加してきた","url":"https://KeenS.github.io/blog/2018/11/17/gengoshorikeibenkyoukainisankashitekita/"},
  {"body":"# Common Lispの多値とその実装達 ---------------------- [言語処理系勉強会 Vol.1 - connpass](https://connpass.com/event/104863/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # 今日話すこと -------------- * 多値のこと * Common Lispの多値のこと * Common Lispの多値の実装のこと === # 引数と返り値の数 -----------------  .border-table { width: 100%; height: 100%; } .border-table tr, .border-table td, .border-table th { border: solid 1px #000; }  引数  単複 返り値単MLなど多数  複???Lispなど  === # MLの引数 ----------------- * 複数引数に見えるがタプルを1つ取っている ``` standard-ml fun foo(v1, v2) = v1 + v2 ``` * 複数引数と違うの？ + 違う + いい悪いではなく違う。 ``` standard-ml val tuple = (1, 2) foo tuple (* - 3 *) ``` === # Lispの多値 ------------ * 複数の値を返せる ``` common-lisp CL-USER (values 1 2) 1 2 ``` * タプルと違うの？ + 違う + いい悪いではなく違う。 ``` common-lisp CL-USER (identity (values 1 2)) 1 ``` === # 多値でないもの ---------------- * rubyの配列の分配束縛 ``` ruby irb(main):001:0 v1, v2 = 1, 2 # [v1, v2] = [1, 2] = [1, 2] irb(main):002:0 v1 = 1 irb(main):003:0 v2 = 2 ``` === # 多値でないもの ---------------- * Pythonのタプルの分配束縛 ``` python  v1, v2 = 1, 2 # (v1, v2) = (1, 2)  v1 1  v2 2 ``` === # Common Lispの多値 ------------------- * 特徴的な挙動をみていく * 非常に一貫した挙動になっている === # 多値を返す ----------- * 標準関数の `VALUES` を使う ``` common-lisp CL-USER (values 1 2) 1 2 ``` === # 多値を受け取る --------------- * 専用の構文(スペシャルフォーム)で関数の引数に渡せる ``` common-lisp (multiple-value-call #'+ (values 1 2)) ; - 3 ``` === # 多値に束縛する --------------- * マクロでできる ``` common-lisp (multiple-value-bind (v1 v2) (values 1 2) (+ v1 v2)) ; - 3 ``` === # ダイナミックに多値 ------------------- * 動的な言語なので多値の数を変えるのも可能 ``` common-lisp (defun dynamic-mv (x) (case x ((1) (values 1)) ((2) (values 1 2)) ((3) (values 1 2 3)) (otherwise (values 1 2 3 4)))) ``` === # ダイナミックに多値 ------------------- ``` common-lisp CL-USER (dynamic-mv 1) 1 CL-USER (dynamic-mv 2) 1 2 CL-USER (dynamic-mv 3) 1 2 3 ``` === # 少なく受け取る ---------------- * 無言で無視できる ``` common-lisp (multiple-value-bind (v1 v2) (values 1 2 3) (+ v1 v2)) ``` === # 単値で受け取る ---------------- * もちろんできる + 「少なく受け取る」の自然な流れ ``` common-lisp (let ((v (values 1 2 3))) v) ; - 1 ``` === # 多く受け取る -------------- * nilが入る ``` common-lisp (multiple-value-bind (v1 v2 v3) (values 1 2) (list v1 v2 v3)) ; - (1 2 NIL) ``` === # 零値 ------ * 値を0個返すこともできる ``` common-lisp CL-USER (values) ; No value ``` === # 零値を受け取る -------------- * nilが入る + 「多く受け取る」の自然な流れ ``` common-lisp (let ((v (values))) v) ; - NIL ``` === # 標準ライブラリ ---------------- * ハッシュテーブル * 2値目にキーが存在したかが入る + 1値目は存在しなかったらnil ``` common-lisp (let ((hash (make-hash-table))) (setf (gethash :nil hash) nil) (gethash :nil hash)) ; - NIL ; - T ``` === # 標準ライブラリ ---------------- * ハッシュテーブルの次があるか、キー、値が多値で返る ``` common-lisp (let ((hash (make-hash-table))) (setf (gethash :nil hash) nil) (with-hash-table-iterator (next hash) (loop ; ここ (multiple-value-bind (more key value) (next) (unless more (return nil)) (print (list key value)))))) ``` === # 激しい例 ---------- * `sb-unix:unix-getrusage` * SBCLの処理系拡張のUNIX API * まずは手元で `man 2 getrusage` してみて * いくよ… === # 激しい例 ---------- * 多値が16個返る ``` common-lisp (sb-unix:unix-getrusage sb-unix:rusage_self) ;; T ;; 650886 ;; 69591 ;; 547536 ;; 0 ;; 0 ;; 0 ;; 35833 ;; 0 ;; 0 ;; 16 ;; 480 ;; 0 ;; 0 ;; 0 ;; 507 ;; 78 ``` === # Common Lisp小話 ------------------ * `eval` 関数がある + 実行時にインタプリタが呼べる * `compile` 関数がある + 実行時にコンパイラが呼べる * `disassemble` 関数がある + 実行時にディスアセンブラが呼べる * ダイナミック!! === # Common Lisp小話 ------------------ * 2行でJITが書ける ``` common-lisp (eval '(defun inc (x) (1+ x))) (compile 'inc) ``` === # Common Lisp小話 ------------------ * さらに即座にディスアセンブルできる ``` common-lisp (disassemble #'inc) ; disassembly for INC ; Size: 35 bytes. Origin: #x100209ED64 ; 64: 498B4D60 MOV RCX, [R13+96] ; no-arg-parsing entry point ; thread.binding-stack-pointer ; 68: 48894DF8 MOV [RBP-8], RCX ;;;; GCのタグがあるので1bitシフトされてる ; 6C: BF02000000 MOV EDI, 2 ; 71: 488BD3 MOV RDX, RBX ; 74: FF1425A800B021 CALL QWORD PTR [#x21B000A8] ; GENERIC-+ ; 7B: 488B5DF0 MOV RBX, [RBP-16] ; 7F: 488BE5 MOV RSP, RBP ; 82: F8 CLC ; 83: 5D POP RBP ; 84: C3 RET ; 85: CC0F BREAK 15 ; Invalid argument count trap ``` === # 多値の実装 ------------ * disassemble関数を使って多値の実装を見てみよう * 複数の処理系で比べるよ * Steel Bank Common Lisp (SBCL): ネイティブコンパイル、レジスタマシン * GNU CLISP (CLISP): バイトコード、スタックマシン === # 単値を返す ------------ ``` common-lisp (defun one-value () (values 1)) ``` === # 単値を返す ------------ CLISP ``` text Disassembly of function ONE-VALUE (CONST 0) = 1 0 required arguments 0 optional arguments No rest parameter No keyword parameters 2 byte-code instructions: 0 (CONST 0) ; 1 1 (SKIP\u0026RET 1) ``` === # 単値を返す ------------ SBCL ``` common-lisp ; disassembly for ONE-VALUE ; Size: 21 bytes. Origin: #x2278662C ; 2C: 498B4D60 MOV RCX, [R13+96] ; no-arg-parsing entry point ; thread.binding-stack-pointer ; 30: 48894DF8 MOV [RBP-8], RCX ; 34: BA02000000 MOV EDX, 2 ; 39: 488BE5 MOV RSP, RBP ; 3C: F8 CLC ; 3D: 5D POP RBP ; 3E: C3 RET ; 3F: CC0F BREAK 15 ; Invalid argument count trap ``` === # 多値を返す ----------- ``` common-lisp (defun two-values () (values 1 2)) (disassemble #'two-values) ``` === # 多値を返す ----------- CLISP ``` text (CONST 0) = 1 (CONST 1) = 2 0 required arguments 0 optional arguments No rest parameter No keyword parameters 4 byte-code instructions: 0 (CONST\u0026PUSH 0) ; 1 1 (CONST\u0026PUSH 1) ; 2 2 (STACK-TO-MV 2) 4 (SKIP\u0026RET 1) ``` === # 多値を返す ----------- SBCL ``` common-lisp ; disassembly for TWO-VALUE ; Size: 40 bytes. Origin: #x2278637C ; 7C: 498B4D60 MOV RCX, [R13+96] ; no-arg-parsing entry point ; thread.binding-stack-pointer ; 80: 48894DF8 MOV [RBP-8], RCX ;; 1 ; 84: BA02000000 MOV EDX, 2 ;; 2 ; 89: BF04000000 MOV EDI, 4 ; 8E: 488D5D10 LEA RBX, [RBP+16] ;; 多値の数 ; 92: B904000000 MOV ECX, 4 ;; 恐らく多めに受け取ったときのためにNILで埋めてる ; 97: BE17001020 MOV ESI, #x20100017 ; NIL ;; キャリーフラグで多値であることを伝える ; 9C: F9 STC ; 9D: 488BE5 MOV RSP, RBP ; A0: 5D POP RBP ; A1: C3 RET ; A2: CC0F BREAK 15 ; Invalid argument count trap ``` === # 多値を返す ----------- SBCL (3値) ``` common-lisp ; disassembly for THREE-VALUES ; Size: 40 bytes. Origin: #x2278640C ; 0C: 498B4D60 MOV RCX, [R13+96] ; no-arg-parsing entry point ; thread.binding-stack-pointer ; 10: 48894DF8 MOV [RBP-8], RCX ; 14: BA02000000 MOV EDX, 2 ; 19: BF04000000 MOV EDI, 4 ; 1E: BE06000000 MOV ESI, 6 ; 23: 488D5D10 LEA RBX, [RBP+16] ; 27: B906000000 MOV ECX, 6 ; 2C: F9 STC ; 2D: 488BE5 MOV RSP, RBP ; 30: 5D POP RBP ; 31: C3 RET ; 32: CC0F BREAK 15 ; Invalid argument count trap ``` === # 多値を返す ----------- SBCL (4値) レジスタが溢れた ``` common-lisp ; disassembly for FOUR-VALUES ; Size: 55 bytes. Origin: #x2278649C ; 9C: 498B4D60 MOV RCX, [R13+96] ; no-arg-parsing entry point ; thread.binding-stack-pointer ; A0: 48894DF8 MOV [RBP-8], RCX ; A4: BA02000000 MOV EDX, 2 ; A9: BF04000000 MOV EDI, 4 ; AE: BE06000000 MOV ESI, 6 ; B3: 48C745F008000000 MOV QWORD PTR [RBP-16], 8 ; BB: 488D5D10 LEA RBX, [RBP+16] ; BF: B908000000 MOV ECX, 8 ; C4: F9 STC ; C5: 488D65F0 LEA RSP, [RBP-16] ; C9: 488B6D00 MOV RBP, [RBP] ; CD: FF73F8 PUSH QWORD PTR [RBX-8] ; D0: C3 RET ; D1: CC0F BREAK 15 ; Invalid argument count trap ``` === # 多値を受け取る --------------- ``` common-lisp (defun recieve2-two-values () (multiple-value-bind (v1 v2) (two-values) (+ v1 v2))) ``` === # 多値を受け取る --------------- CLISP ``` text Disassembly of function RECIEVE2-TWO-VALUES (CONST 0) = TWO-VALUES 0 required arguments 0 optional arguments No rest parameter No keyword parameters 6 byte-code instructions: 0 (CALL0 0) ; TWO-VALUES 2 (NV-TO-STACK 2) 4 (LOAD\u0026PUSH 1) 5 (LOAD\u0026PUSH 1) 6 (CALLSR 2 55) ; + 9 (SKIP\u0026RET 3) ``` === # 多値を受け取る --------------- SBCL ``` common-lisp ; disassembly for RECIEVE2-TWO-VALUES ; Size: 52 bytes. Origin: #x227867FC ; 7FC: 498B4D60 MOV RCX, [R13+96] ; no-arg-parsing entry point ; thread.binding-stack-pointer ; 800: 48894DF8 MOV [RBP-8], RCX ; 804: 4883EC10 SUB RSP, 16 ; 808: 31C9 XOR ECX, ECX ; 80A: 48892C24 MOV [RSP], RBP ; 80E: 488BEC MOV RBP, RSP ; 811: E86217D8FD CALL #x20507F78 ; #;; キャリーフラグで分岐 ; 816: 7208 JB L0 ; 818: BF17001020 MOV EDI, #x20100017 ; NIL ; 81D: 488BDC MOV RBX, RSP ; 820: L0: 488BE3 MOV RSP, RBX ; 823: E818A237FF CALL #x21B00A40 ; GENERIC-+ ; 828: 488BE5 MOV RSP, RBP ; 82B: F8 CLC ; 82C: 5D POP RBP ; 82D: C3 RET ; 82E: CC0F BREAK 15 ; Invalid argument count trap ``` === # まとめ -------- * 多値とタプルは違うよ * Common Lispの多値はダイナミックだよ * Common Lispはダイナミックだよ * スタックマシンの多値は特別扱いされてるよ * レジスタマシンの多値はハックが詰まってるよ * [コード](https://gitlab.com/snippets/1779413)   ","categories":["言語処理系","言語実装","Lisp","Common Lisp"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%87%a6%e7%90%86%e7%b3%bb","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/lisp","/categories/common-lisp"],"date":"2018-11-15","title":"Common Lispの多値とその実装達","url":"https://KeenS.github.io/slide/common_lispnotachitosonojissoutachi/"},
  {"body":"# WebAssemblyとABI ---------------------- [コンパイラ勉強会 - connpass](https://connpass.com/event/103976/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # WebAssmblyとは ---------------- * Webブラウザで動く* アセンブリ* ではない=== # WASMの動作環境 ------------------------ * ブラウザ * NodeJS * [CommonWA](https://github.com/CommonWA/cwa-spec) * [losfair/IceCore](https://github.com/losfair/IceCore) : Build efficient and reliable backend applications in WebAssembly. * [Introducing Wasmjit: A kernel mode WebAssembly runtime for Linux | Packt Hub](https://hub.packtpub.com/introducing-wasmjit-a-kernel-mode-webassembly-runtime-for-linux/) * [piranna/wasmachine: Put WebAssembly in your washing machine](https://github.com/piranna/wasmachine) === # 言語としてのWASM ----------------- * アセンブラっぽい雰囲気 * スタックマシン * 無限のレジスタ(変数)とスタックがある * コードの単位は関数 * 上位にモジュールがある * モジュール毎に1仮想マシン(インスタンス) === # コード例1 ----------- ```webassembly (module (func $add (param $lhs i32) (param $rhs i32) (result i32) get_local $lhs get_local $rhs i32.add) (export \"add\" (func $add))) ``` === # コード例2 ----------- ``` webassembly (func $sum1 (param $n i32) (result i32) (local $sum i32) (local $i i32) block $break loop $loop get_local $i get_local $n i32.ge_s br_if $break get_local $sum get_local $i i32.add set_local $sum get_local $i i32.const 1 i32.add set_local $i br $loop end end get_local $sum return) ``` === # コード例3 ------------ ``` webassembly (func $sum2 (param $n i32) (result i32) (local $sum i32) (local $i i32) (block $break (loop $loop (br_if $break (i32.ge_s (get_local $i) (get_local $n))) (set_local $sum (i32.add (get_local $sum) (get_local $i))) (set_local $i (i32.add (get_local $i) (i32.const 1))) (br $loop))) (return (get_local $sum))) ``` === # WASM詳細 ----------- * 型は4つ (`i32`, `i64`, `f32`, `f64`) * モジュールに色々ついてくる * メモリ * 関数import/export * グローバル変数 * インスタンスの情報はJS側から色々アクセスできる === # import/export ---------------- ``` webassembly (module (type $alert_type (func (param i32))) (import \"module\" \"alert\" (func $alert (type $alert_type))) (func $add (param $lhs i32) (param $rhs i32) (result i32) get_local $lhs get_local $rhs i32.add) (func $run (call $alert (call $add (i32.const 1) (i32.const 2)))) (export \"run\" (func $run))) ``` === # import/export ---------------- ``` webassembly fetch('../out/main.wasm').then(response = response.arrayBuffer() ).then(bytes = WebAssembly.instantiate(bytes, {\"module\": {\"alert\": alert}}) ).then(results = { instance = results.instance; instance.exports.run(); }).catch(console.error); ``` === # メモリのexport ---------------- ``` webassembly (module (memory $mem 10) (export \"memory\" (memory $mem))) ``` ``` javascript // メモリを直接いじれる instance.exports.memory.buffer ``` === # 本題 ------ * この仕様でJS-WASM間のABIどうしたらいい？ + 型は4種類の即値のみ + メモリは触れる === # 答え ------ * Rustが既に実装している * [Rust and WebAssembly](https://github.com/rustwasm) * 以後追っていく === # JS - Rust ------------- * Rustでメモリを確保してJSが渡す === # JS - Rust ------------- ``` webassembly #[wasm_bindgen] fn greet(name: \u0026str) { alert(\u0026format!(\"hello, {}!\", name)) } ``` === # JS - Rust ------------- ``` webassembly function passStringToWasm(arg) { const buf = cachedTextEncoder.encode(arg); const ptr = wasm.__wbindgen_malloc(buf.length); getUint8Memory().set(buf, ptr); return [ptr, buf.length]; } ``` === # JS - Rust ------------- ``` webassembly export function greet(arg0) { const [ptr0, len0] = passStringToWasm(arg0); try { return wasm.greet(ptr0, len0); } finally { wasm.__wbindgen_free(ptr0, len0 * 1); } } ``` === # Rust - JS ------------ * 可能ならポインタのまま渡す * 不可能なら指定されたメモリに書き込む === # Rust - JS ------------ ポインタ ``` rust #[wasm_bindgen] impl Universe { pub fn new() - Universe { // ... } } ``` === # Rust - JS ------------ ポインタ ``` javascript export class Universe { static __wrap(ptr) { const obj = Object.create(Universe.prototype); obj.ptr = ptr; return obj; } free() { const ptr = this.ptr; this.ptr = 0; freeUniverse(ptr); } /** * @returns {Universe} */ static new() { return Universe.__wrap(wasm.universe_new()); } } ``` === # Rust - JS -------- メモリ ``` rust #[wasm_bindgen] impl Universe { pub fn render(\u0026self) - String { self.to_string() } } ``` === # Rust - JS -------- メモリ ``` javascript export class Universe { render() { const retptr = globalArgumentPtr(); wasm.universe_render(retptr, this.ptr); const mem = getUint32Memory(); const rustptr = mem[retptr / 4]; const rustlen = mem[retptr / 4 + 1]; const realRet = getStringFromWasm(rustptr, rustlen).slice(); wasm.__wbindgen_free(rustptr, rustlen * 1); return realRet; } } ``` === # メモリ ------------ メモリ ``` javascript let cachedGlobalArgumentPtr = null; function globalArgumentPtr() { if (cachedGlobalArgumentPtr === null) { cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr(); } return cachedGlobalArgumentPtr; } ``` === # Rust - JS -------- メモリ ``` text JS retprt | rustptr ---- | | データ v v v WASM [...| |...|ptr|size|...| |...] | ^ | ^ +-------+ +----------+ ``` === # まとめ --------- * WebAssemblyというWebとは限らないアセンブリでないものがあるよ * シンプルな仕様だよ * 任意のコンパイラ - JS連携できるよ * RustからJSオブジェクトを扱う話はしてないよ   ","categories":["WebAssembly","Compiler"],"category_urls":["/categories/webassembly","/categories/compiler"],"date":"2018-11-10","title":"WebAssemblyとABI","url":"https://KeenS.github.io/slide/webassemblytoabi/"},
  {"body":"κeenです。ミスってコーヒーと濃いめの緑茶を喫してしまって眠れないのて一筆執ります。 ふとソフトウェア界を見渡すにブログやドキュメントなどを継続的に書いてる人って意外と少ないのかなと思ったので自分なりに続く方法を書いてみます。\n下記が統計コマンドと結果です。2018年はまだ3ヶ月弱残ってる上にアドベントカレンダーがまだなのでもう少し伸びる可能性がありますがまあ、+10程度でしょう。\n$ find content/post -type f | xargs grep -h date: | grep -o -E \u0026#39;[0-9]{4}-[0-9]{2}-[0-9]{2}\u0026#39; | grep -o -E \u0026#39;[0-9]{4}\u0026#39; | sort | uniq -c 24 2013 39 2014 52 2015 48 2016 32 2017 25 2018 $ find content/slide -type f | xargs grep -h date: | grep -o -E \u0026#39;[0-9]{4}-[0-9]{2}-[0-9]{2}\u0026#39; | grep -o -E \u0026#39;[0-9]{4}\u0026#39; | sort | uniq -c 9 2014 19 2015 15 2016 9 2017 8 2018  年に依ってばらつきはありますがここ数年は平均してブログ月2~3本、発表は月1回前後しているようです。 この数はソフトウェア業界では多い方に入る気がします。 自分なりにこのモチベーションが続く理由はこれかなーというのを挙げてみます。\n1つ目はタイプ速度。2015, 2016年が顕著にアウトプットが多いですね。 丁度その時期はDvorak配列+SKKを使っていた頃であり、日本語を入力するストレスが一番低い時期でした。 文章を書くときに心理的ブレーキになるのは文章を考えるよりも入力する面倒さの方が多い気がします。 一度自分に合う入力方式を探す旅に出ると筆が速くなるかもしれません。 因みに私は今はJP配列かな入力+Mozcです。Ubuntu 17.10でデフォルトIMがIBusになったのをきっかけに使い始めました。 1年経つはずですがまだ馴れないです。右小指が忙しすぎて誤タイプが多い。どこかのタイミングでDvorak+SKKに戻します。\n2つ目は手軽にブログを書けるようにすることです。 私の場合はGitHub PagesとHugoを使っていて、シェル関数1つでブログテンプレートを生成してそのファイルをEmacsで開くところまで自動化してます。 人間は面倒なことはやりたがらないのでとにかくブログを書き始めるのを面倒と思わないように工夫するといいと思います。 Qiitaとかはてなブログとかの人は適当に手元でMarkdownを書いてそのまま勝手に公開されるエディタプラグインでも探して下さい。\n3つ目はインプット量。特に、自分にとって目新しいことです。 2015年で私は社会人になったので上記の通り新鮮なことが多くてよくブログに感動を綴ってました。 あと会社が渋谷にあったので勉強会に行きやすくてインプットが多かったというのも大きいと思います。 最近アウトプットが落ちてるのはインプットも落ちてるということなのでよくないですね。\n4つ目は最初は他人の目を気にしないこと。 「どうせ誰も見ないし好き勝手書こう」です。むしろ「よし、今からインターネットの藻屑を作るぞ」くらいでいいんじゃないですかね。 段々馴れてくると「分かりやすい記事を書きたい」と色気が出てくるのでそのあたりで過去記事を見返して悶絶して改善していけばいいと思います。 誤りを指摘されたらありがたく拝領して直せばいいしなんか勝手に怒ってるひとがいたら「なんかワカメに向かって怒ってる人がいる」くらいで流せばいいし他人の言うことは三分くらい耳を貸しとくくらいでちょうどいいと思います。 まあ、私の過去の記事が結構いい加減書いてあるって話でもあるんですが。 あと完成度を高めようと溜めないのも重要だと思います。 私はブログ執筆開始から数時間で出してしまいます。 中途半端に時間掛けるとそれなりの品質を求めたくなってまた時間を書けてしまうループに入る気がします。すぐ公開するからやったことないけど。 「バズりやすい時間を狙って」とか意味不明なこと言ったり未公開記事いくつも溜め込んだり溜め込んだ末に旬を逃してお蔵入りしたりした人は反省しましょう。\nあとは基本的スタンスとして「自分が死んだら自分の知識が世界から失われるのがもったいない」とか「頭の中でもやもやしてるものをまとめて外に掃き出して頭の中をキレイにしたい」とかいうのがあります。 「そもそも継続的に自然言語のアウトプットを出す意味はあるのか」という疑問もあるかと思いますが私は意識してやってるわけではなく、ただ好きでやってたら継続してました。 続けてたらいい感じにポートフォリオになってるようなのでそのまま続けてる感じですね。別に無理して書く必要はないと思います。\nまとめとしてはみんなDvorak+SKKを使いましょう。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2018-10-11","title":"自然言語のアウトプットを継続的に出すためには","url":"https://KeenS.github.io/blog/2018/10/11/shizengengonoautoputtowokeizokutekinidasutameniha/"},
  {"body":"κeenです。情報科学若手の会 #51に参加してきましたのでその報告です。\nCAのときの同期のくろちゃんが代表幹事をやってるのでその縁でIdein社が懇親会スポンサーをし、1人分の参加権で私が行ってきました。 あとくろちゃんに個人的に発表もしてと言われたので一般発表もしてきました。\nFutureとその周辺 | Lispエイリアンの狂想曲\n最初タイトルにサーベイも付いていたんですがサーベイというにはぞんざいすぎて恥ずかしいので削りました。 私は情報科学は全然分からないですし情報科学をやってる人に現実のプログラミング言語で悩んでる問題を知ってもらって興味を持っていただけたらなと思ってテーマを決めました。 正直想定聴衆をミスったようで、あまり伝わってなかったみたいでした。たとえば冒頭で限定継続やCPSは説明なしに喋ってましたがちゃんと伝わった人が1人もいなかった可能性すらあります。 情報科学を冠してる点、若手の会がプログラミングシンポジウムの下位組織である点からかなりプログラミング言語の概念には詳しい人が多いだろうと踏んでたのですが思った以上に多様性のある参加者でした。\nガチにやってる人でも分野違うと全然わからんとかありますし、なにかしらの分野を深く掘り下げている人は多いんだろうとは思いますが、情報科学って広いので、情報科学の中の特定の分野に絞った場合はなんの前提知識も持ってないっていう想定で話した方がいいのかもしれませんね\n\u0026mdash; さほ (@saho_bofffff) 2018年10月7日 反省してます。あと時間足りないだろと思ってマキで喋ったら時間を余してしまった。それにスライドの準備がかなりギリギリになってしまったので全体的に完成度が低いですね。\nさて、その他の発表ですがまずは1日目がプログラミング言語系。 プログラミング言語系は私の他は量子計算の話とHalide to Dataflow Architectureの話くらいでした。 Halide to Dataflow Architectureの話は問題意識の導入から取り組みまでの流れがスムーズで分かりやすいなーと関心してました。\n次が主にセキュリティやCTFのセッション。特に若手特別講演で黒米さんからマルウェアの難読化と難読化解除の話がありました。\nThe Art of De-obfuscation\n難読化と難読化解除では思った以上にプログラミング言語との関わりが深くて興味深かったです。 たとえば難読化のために(インタプリタ的意味の)VMを作ったりDirect Threadingしたりする手法があるそうです。 さらに解析のためにシンボリック実行やSMTソルバを使ったりもしてるようでした。 マルウェア解析ってバイナリとにらめっこみたいなイメージがあったので身近に感じられて新鮮でした。\n次はインフラや物理の話に移っていきました。 特に招待講演は宇田さんで、例のコンテナデータセンターの話がありました。 一般には未公開の映像なども交えて話されていました。 コンテナをデータセンターでホスティングする時代はもう古い！これからはデータセンターをコンテナでホスティングする時代！ 他には高校生の発表もあり若手ですね。\n夜はLTセッションがありました。LTはカジュアルですね。私はRustのエヴァンジェリストじゃないの？と圧を掛けられたので飛び込みLTしてました。\nRust around you | Lispエイリアンの狂想曲\nというか割とRustの人として認識されてたみたいで意外でした。こういうクラスタにも知られてたんだ…。色んな分野の人がいることがわかったので色々な分野で活躍するRustの話をしました。 話をしたというか一方的に情報を叩きつけました。LTですし勢い重視で、自分の中で最速のテンポで進めました。 スライドは12ページ+リンクが大量にありますが、4分で全部終わらせてます。\n3日目はAIの話。脳とDeep Learningの関係の話とimosさんのお話。\nそして恙無く終わりました。台風が懸念される会でしたが大きな影響なくて大変良かったです。新幹線が少し遅れたくらい。\nその他の話題としては軽井沢研修所の裏庭が植物園になってました。キノコが一杯生えてた。\n夜のお散歩。秋の七草の朝貌ときのこ達 pic.twitter.com/RsjCfr7puY\n\u0026mdash; κeen (@blackenedgold) 2018年10月6日 黒くて見づらいのはヒトヨダケかな？\n朝の散歩 pic.twitter.com/SWMXE6UIWz\n\u0026mdash; κeen (@blackenedgold) 2018年10月6日 あとは雉がいた。\nキジ pic.twitter.com/gr8iHOnYfe\n\u0026mdash; κeen (@blackenedgold) 2018年10月6日 \nこれ以外にも帰り道に2羽雉を見かけました。\n幹事及び参加者のみなさんお疲れ様でした。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2018-10-08","title":"情報科学若手の会 #51 に参加してきた","url":"https://KeenS.github.io/blog/2018/10/08/jouhoukagakuwakatenokai__51_nisankashitekita/"},
  {"body":"# Rust around you ---------------------- [第51回 情報科学若手の会](https://wakate.org/2018/07/28/51th-general/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # Rust ------ * 安全なC++ * ML/Haskellみたいな機能 + タプル + 代数的データ型 + トレイト + 式指向 === ![](/images/rust_kappa.jpg) みなさんの脳にRustを叩き込みます === # Rustは色々な領域で使われている ------------------------------- * OS * ネットワーク * ブラウザ * コンパイラ * WebAssembly * マイコン * VCS === # Rustは色々な領域で使われている ------------------------------- * CLI * ウェブアプリケーション * DB * ゲーム * 暗号通貨 * GPU === # OS ----- * [redos](https://gitlab.redox-os.org/redox-os/redox): フルセットのOS + [tfs](https://gitlab.redox-os.org/redox-os/tfs): zfs的なの。並行で動く。 + [ion](https://gitlab.redox-os.org/redox-os/ion): シェル + [orbital](https://gitlab.redox-os.org/redox-os/orbital): Windowシステム * [intermezzOS](https://intermezzos.github.io/): 小さいOS * [Writin an OS in Rust](https://os.phil-opp.com/) + RustでOSを書くチュートリアル + 30日OS本みたいなの === # ネットワーク ------------- * [libpnet](https://github.com/libpnet/libpnet): バケットからネットワークを扱えるライブラリ * [trust-dns](https://github.com/bluejekyll/trust-dns): DNSクライアント、サーバ、リゾルバ === # CLI ----- * [uutils](https://github.com/uutils/coreutils): catとかlsとかのrust実装 * [ripgrep](https://github.com/BurntSushi/ripgrep): プロジェクト単位で `grep` * [exa ](https://github.com/ogham/exa): 高級 `ls` * [fd](https://github.com/sharkdp/fd): 高級 `find` * [xsv](https://github.com/BurntSushi/xsv): CSVツール * [tokei](https://github.com/Aaronepower/tokei): clocを取る === # WebAssembly ------------- * 現状の最有力候補 * [wasm-bindgen](https://github.com/rustwasm/wasm-bindgen): Rust-JSブリッジ * [stdweb](https://github.com/koute/stdweb): ブラウザサイドライブラリ * [js-sys](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys): JS標準ライブラリのバインディング * [web-sys](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys): WebGLなどのバインディング === # その他 -------- * [tock](https://github.com/tock/tock): Cortex-Mで動く組み込みOS * [pijul](https://pijul.org): 分散VCS * [REmacs] https://github.com/Wilfred/remacs * [Rust](https://github.com/rust-lang/rust): rustコンパイラ * [parity](https://github.com/paritytech/parity-ethereum): ethereum実装 === # その他 -------- * [TiKV](https://github.com/tikv/tikv): KVS * [Piston](http://www.piston.rs/): ゲームエンジン * [amethyst](https://www.amethyst.rs/): ゲームエンジン * [accel](https://github.com/rust-accel/accel): GPGPUライブラリ * [ndarray](https://github.com/bluss/ndarray): 多次元配列ライブラリ   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2018-10-07","title":"Rust around you","url":"https://KeenS.github.io/slide/rust_around_you/"},
  {"body":"# Futureとその周辺 ---------------------- [情報科学若手の会 #51](https://wakate.org/2018/07/28/51th-general/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます * 言語処理系と継続が好き * 科学っぽい話はできないです === # 非同期計算 ------------- * 待ってる間別のことをやりたい * 処理の切り替えどうするの ![非同期計算](/images/async.png) === # 非同期計算 ------------- * (限定)継続が取り出せればいい * 解決！ ![限定継続](/images/cont.png) === # 限定継続 ---------- * 多くの言語では限定継続は扱えない + Schemeなら簡単なんだけどねー * CPS変換すれば限定継続じみたことができる + 要はコールバック形式 === # 問題意識 ---------- * コールバック地獄 * デッドロック === # コールバック地獄 -------------- * コールバックがどんとんネストしていく問題 * 非同期呼び出しする度に深くなる * 視認性が悪くなる === # コールバック地獄 -------------- ```javascript fs.readdir(source, function (err, files) { if (err) { console.log('Error finding files: ' + err) } else { files.forEach(function (filename, fileIndex) { console.log(filename) gm(source + filename).size(function (err, values) { if (err) { console.log('Error identifying file size: ' + err) } else { console.log(filename + ' : ' + values) aspect = (values.width / values.height) widths.forEach(function (width, widthIndex) { height = Math.round(width / aspect) console.log('resizing ' + filename + 'to ' + height + 'x' + height) this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) { if (err) console.log('Error writing file: ' + err) }) }.bind(this)) } }) }) } }) ``` http://callbackhell.com/ === # デッドロック ------------ * 個人的経験 * [Aerospike](https://www.aerospike.jp/)のJavaクライアント + 非同期IO + コールバックが設定できる * readしてコールバックでwriteした * → デッドロックした * 非同期処理はIOスレッドが実行していた * コールバックもIOスレッドて呼ばれていた === # デッドロック ------------ 1. 非同期ReadでIOスレッドを専有 2. IOスレッドでコールバック発火 3. 非同期Write発行 4. WriteはIOスレッド待ち \u0026 IOスレッドはWrite待ち 5. デッドロック === # 色々な視点 ------------ * 実行モデル + デッドロックの件は実行モデルの知識が足りなかったから起きた * ユーザインタフェース ← メイン + コールバック地獄は主にユーザインタフェースの問題 * 実装方式 + 処理系の中身みんな知りたいよね！ === # 実行モデル ----------- * 多分無数にある * ただの遅延計算 * IOスレッド1つ * スレッドプール + ブロックするスレッドとさせたくないスレッドを分離 + スケジューラに無数のバリエーション * イベントループ + スレッドをブロックせずに一杯タスクをこなす * その他応用 === # ユーザインタフェース --------------------- * コールバック * Future + futureにも色々 + 少し実装も絡む * `async`/`await` * `do` 式 / `for` 式 * coroutine + coroutineにも色々 * goroutine === # 実装方式 ---------- * 完全ユーザレベル * 完全処理系レベル * 処理系レベルだけど一部ユーザレベル * ユーザレベルだけど特殊な処理系の機能を使う === # コールバック ------------- * ユーザインタフェース: コールバック + 扱いづらい * 実行モデル: ものによる * 実装方式: 完全ユーザレベル === # Future -------- * ユーザインタフェース: Future + 少しマシになった * 実行モデル: ものによる * 実装方式: 完全ユーザレベル === # Future -------- * 並行デザインパターン * 計算を非同期実行 * 値の引換券(先物 = future)を返す * 実行した値を受け取れる * みなさん知ってますよね === # diff to コールバック ----------------------------- * 値になる + 「あとで呼ばれる」という暗黙の文脈が「値」という一級市民になった * 続けて処理を書ける + map, andThen, ... + 要はモナド * そのままだとコールバック地獄は変わらない === Scala標準ライブラリ ``` scala val purchase = usdQuote flatMap { usd = chfQuote .withFilter(chf = isProfitable(usd, chf)) .map(chf = connection.buy(amount, chf)) } ``` https://docs.scala-lang.org/ja/overviews/core/futures.html === # Future x 実行モデル -------------------- * Futureは基本的にはコールバックの抽象化 * 特定の実行モデルとは結びつかない * …とでも思ったか！ * 実装によって千差万別 === # Future x 実行モデル -------------------- * Scala: 標準ライブラリの`Future` + Futureそのものは実行モデルと結びつかない + `Future` の作成にスレッドプールが必要 + 実装レベルでは分離 + APIレベルでは結合してる * Clojure: clojure.coreの`future` + 雑にスレッドプールに処理を投げる + 完全に密結合 === # Future x 実行モデル -------------------- * Scala: TwitterUtilの`Future` + Futureそのものは実行モデルと結びつかない + APIレベルでも分離 + 別途スレッドプールも用意される * Rust: futures-rs + Futureそのものは実行モデルと結びつかない + APIレベルでも分離 + 別途スレッドプールも用意される === # Future x 実行モデル -------------------- * Futureとスレッドプールが密結合 + 手軽に並列化できる * Futureと実行モデルは粗結合 + 計算を合成してからスレッドプールに投げられる - 計算と実行を別々のライブラリにできる === # Futureはいつ実行される -------------------- * 前のタスクが終了した直後に実行 * ジョブキューに積まれていつか実行 * 値をgetするとき * イベントループがpollする * … === # Futureの構文糖衣 ------------------ * Futureを使ってもコールバック地獄は変わらない + 構文糖衣でどうにかする * Futureはモナド + 普通のプログラムっぽい書き方ができるはず * 普通は構文糖衣は処理系のサポートが必要 === # Futureの構文糖衣 ------------------ * `async`/`await` + 大半処理系、一部ユーザ + ジェネレーターが必要 * `do` 式/`for`式 + 処理系の機能に乗っかる + 高階多相が必要 * Lispだとマクロでユーザレベルで可能 === # `async`/`await` ----------------- ``` c# // Signature specifies Task async Task TaskOfTResult_MethodAsync() { int hours; // . . . // Return statement specifies an integer result. return hours; } // Calls to TaskOfTResult_MethodAsync Task returnedTaskTResult = TaskOfTResult_MethodAsync(); int intResult = await returnedTaskTResult; // or, in a single statement int intResult = await TaskOfTResult_MethodAsync(); ``` === # `do` 式 ------ ``` haskell do a1 :fugafuga ``` https://docs.ruby-lang.org/ja/latest/method/Fiber/i/transfer.html === ![対称コルーチン](/images/coroutine.png) === ![非対称コルーチン](/images/semicoroutine.png) === # Futureとの関係 ---------------- * `async`/`await`はstack less非対称コルーチン(=generator)の上に実装されることが多い + jsの`async`/`await`とか + Rustの`async`/`await`もそうなる予定 * `do`式/`for`式はstack less非対称コルーチンを実装できる http://hackage.haskell.org/package/monad-coroutine-0.9.0.4/docs/Control-Monad-Coroutine.html === ![async/awaitと機能の依存](/images/async-await.png) === ![do式と機能の依存](/images/do-async.png) === # goroutine ------------ * Goのあれ + 他の言語にもある * 完全処理系レベルの実現 * stackfullな対称coroutine(多分) + IOをトリガとした自動スケジュール + 直接形式で書ける * 自分でtransferを書かないのでスレッドに近い見た目 === ``` go func say(s string) { for i := 0; i   mermaid.initialize({startOnLoad:true}); ","categories":["非同期","Future"],"category_urls":["/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f","/categories/future"],"date":"2018-10-05","title":"Futureとその周辺","url":"https://KeenS.github.io/slide/futuretosonoshuuhensa_bei/"},
  {"body":"κeenです。何度か「Rustでenumのタイプエイリアスしたときにヴァリアントもエイリアスして欲しい」という話を聞くので自分なりにどうにか出来ないかなと考えたやつをまとめます。\nモチベーション やりたいことはこんなの。 enumにtypeで別名を付けたときに 別名::ヴァリアント名 でアクセスしたいというもの。 特にジェネリクスを使ってるときにやりたくなる。\nenum Foo\u0026lt;V\u0026gt;{Hoge,Piyo(V),}type IntFoo=Foo\u0026lt;i64\u0026gt;;// ここで `IntFoo::Piyo` とアクセスしたい。  一応RFCにもなっているのでいつかは解決される。 しかしTracking issueはOpenでありいつ解決されるかは分からない。\nそこでワークアラウンドを考えてみた。\nコード 要は型だけでなく名前空間もエイリアスしたのでイメージとしてはやりたいことはこうなる。 単相化する必要があるのでシンプルに use Foo::* するのはできなくて、真心込めて関数やConstを書いていく必要がある。\nenum Foo\u0026lt;V\u0026gt;{Hoge,Fuga{x: i64,y: i64 },Piyo(V),}type IntFoo=Foo\u0026lt;i64\u0026gt;;mod IntFoo{usesuper::{Foo,IntFoo};// Fooがpubでないので可視性を`pub(super)`にしてある。この辺は臨機応変に。 pub(super)constHoge: IntFoo=Foo::Hoge;pub(super)fn Piyo(v: i64)-\u0026gt; IntFoo{Foo::Piyo(v)}} ただし問題が2つある。1つ目はシンプルにコンパイルエラーになる点。型名とモジュール名は被ってはいけないらしい。というかモジュールって型名空間に入るんだ。\nerror[E0428]: the name `IntFoo` is defined multiple times \u0026ndash;\u0026gt; enum_typename.rs:9:1 | 7 | type IntFoo = Foo\u0026lt;i64\u0026gt;; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; previous definition of the type `IntFoo` here 8 |  9 | mod IntFoo { | ^^^^^^^^^^ `IntFoo` redefined here | = note: `IntFoo` must be defined only once in the type namespace of this module  \nもう一つは構造体型のヴァリアントをエイリアス出来ない点。上の例でも Fuga だけエイリアスがない。\nこれを回避したワークアラウンドがいくつかある。\n1つ目の問題の解決策は2つある。 1つはモジュール名を変える。IntFoo_ とか。ダサいけど。 もう一つはtype IntFooの方を変える。モジュール内に入れてしまって名前を T とかにする。\nmod IntFoo { use super::Foo; pub(super) type T = Foo\u0026lt;i64\u0026gt;; } RustっぽくはないけどMLのモジュールっぽい使い方。 残念ながらどちらの方法もRustにヴァリアントのエイリアスが実装されたら既存コードを変更して回らないといけない。\n2つめの問題はシンプルに単相化を諦めるしかなさそう。\nmod IntFoo{usesuper::Foo;pub(super)constHoge: T=Foo::Hoge;// FooのFugaをそのまま使う pub(super)usesuper::Foo::Fuga;pub(super)fn Piyo(v: i64)-\u0026gt; T{Foo::Piyo(v)}} Fuga だけ多相のままにすることであるいは諦めて全部多相のままにすれば幾分がシンプルになる。\nmod IntFoo { use super::Foo; pub(super) use super::Foo::*; } これも状況に応じて。\nまとめ 「Rustでenumのタイプエイリアスしたときにヴァリアントもエイリアスして欲しい」という欲求にはには言語側で対応中だが今すぐには使えない。 そこでいくつかワークアラウンドの案を挙げたがどれも言語側の対応が済むとコードの変更が必要になり中途半端。 また、実現したいことを全て出来るわけではない。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2018-09-17","title":"Rustでenumのタイプエイリアスでヴァリアントもエイリアスして欲しい問題のワークアラウンドとか","url":"https://KeenS.github.io/blog/2018/09/17/rustdeenumnotaipueiriasudevariantomoeiriasushitehoshiimondainowa_kuaraundotoka/"},
  {"body":"# Inside Pattern Matchings ---------------------- [ML Day #2](https://ml-lang.connpass.com/event/94284/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [ちゅーんさんだよー](https://shindanmaker.com/789932) * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます ===  ( ^o^)パターンマッチって便利だなー ( ˘⊖˘) 。o(待てよ？なんでこんなに簡単にコードが書けるんだ) |コンパイラ|┗(☋｀ )┓三 ( ◠‿◠ )☛そこに気づいたか・・・消えてもらう ▂▅▇█▓▒░(’ω’)░▒▓█▇▅▂うわああああああ  === # 発表について ------------- * 元ネタ [Optimizing Pattern Matching](http://pauillac.inria.fr/~maranget/papers/opat/) (Fabrice Le Fessant, Luc Maranget) * 自作SMLコンパイラにパターンマッチを入れようとしたら難しかった + 「コードを生成」が割と厄介 + 次の中間言語の設計に影響を与える - というか専用の中間言語作るくらいの心意気が必要 === # 発表について ------------- * 既存手法を調べたら非自明だった + → 既存手法の紹介だけでも価値がありそう + → 発表するか + (本当は実装までしたかったけど進捗だめです) * 変数束縛の話はしない + ワイルドカードで我慢して === # パターンについて ------------------ * パターンは値の集合にマッチする * ワイルドカードパターンがある * 直積にマッチするときは _横_ に伸びる * 直和にマッチするときは _縦_ に伸びる * パターンをネストするときは _奥_ に伸びる * パターンが _網羅的_ であるかに関心がある * 複数マッチする場合は最初のものにマッチする === # 例 ---- ``` standard-ml case (lx, ly) of ([], _) = 1 | (_, []) = 2 | (x::xs, y::ys) = 3 ``` === # パターンマッチの実装 --------------------- * いくつか方法がある + 素朴なifのチェーン + decision tree + backtracking automata * それぞれメリットデメリットがある === # ifのチェーン ------------- ``` C if (lx == [] \u0026\u0026 true) { return 1; } else if (true \u0026\u0026 ly == []) { return 2; } else if (lx == (::) \u0026\u0026 ly == (::)) { // discriminantとデータは別 x = lx.0; xs = lx.1; y = ly.0; ys = ly.1; return 3; } else { // match fail } ``` === # ifのチェーン ------------- * パターンを1つ1つifで検査する * 最初に思いつく * O 素朴 * O 実装が楽 * X 遅い(横、縦、深さ全てに比例) * X 網羅性検査は別途実装 === # decision tree ---------------- ``` C swith(lx) { case []: return 1; case (::): switch (ly) { case []: return 2; case (::): return 3; } } ``` === # decision tree -------------- * パターンから決定木を作る * 直和は `switch` に変換する * 直積は `switch` のネストに変換する * パターンのネストは`switch`のネストに変換する * ifのチェーンの次に思いつく * O 実行が(横幅と深さに)線形 * O 網羅性検査がfor freeでついてくる * X コードが嵩む(パターンがコピーされうる) === # decision tree -------------- * 最初に実装しようとした * パターンがネストしたケースで実装が難しかった + 主にデータの持ち方の問題 + 1つの節の中にネストさせるパターンを集めるのが大変 * 直積とパターンのネストどっちを先にやるかは調べてない * ORパターンを入れるとdecision diagramになりそう？ + CFGが欲しくなる === # backtracking automata ------------------------ ``` catch catch switch lx with case []: 1 default: exit with catch switch ly with case []: 2 default: exit with catch switch lx with case (::): switch ly with case (::): 3 default: exit default: exit with (failwith \"Patrtial match\") ``` === # backtracking automata ------------------------ * 順番に検査しつつ失敗したら巻き戻す + パターンの並びのままprefixが共通なら共有する + 例外とハンドラを使う * O コードがコンパクト(パターンはコピーされない) * X decision treeほど速くない * O 最適化ができる + まずは動くものを作ってあとで高速化 === # backtracking automata ------------------------ * 今回紹介する内容 * DT vs BA * 少し正規表現のDFA vs NFAに似てる + ただしパターンマッチはコード生成の話 * Backtracking Automataを最適化するとそれなりに速い === # イメージ ---------- ## if ``` .-.- .-.- .-.- .-.- ``` === # イメージ ---------- ## DT ``` / . / \\ . \\./ \\ ``` === # イメージ ---------- ## BA ``` .-.- \\ .-.- \\ ``` === # 準備 ------- ## データ * データは直和と直積からなるとする + intも無限の直和からなるとする * 値はコンストラクタで作られる $v ::= c(v1, .., vn)$ * パターンへの入力はベクトルで与えられる $\\vec{v} = (v_1 \\cdots v_n)$ === # 準備 ------- ## パターン * パターンは2つ $p ::=$ + $\\mathbf{\\\\\\_}$ (ワイルドカード) + $c(p_1, .., p_n)$ (コンストラクタ) * パターンもベクトルになる $\\vec{p} = (p_1 \\cdots p_n)$ === # 準備 ------- ## 節行列 * パターンは節が複数あるので行列になる ``` standard-ml case (lx, ly) of ([], _) = 1 | (_, []) = 2 | (_::_, _::_) = 3 ``` を \\\\[ \\begin{equation\\*} (P \\to L) = \\begin{pmatrix} [] \u0026 \\mathbf{\\\\\\_} \u0026 → \u0026 1 \\\\\\\\ \\mathbf{\\\\\\_} \u0026 [] \u0026 → \u0026 2 \\\\\\\\ (::) \u0026 (::) \u0026 → \u0026 3 \\end{pmatrix} \\end{equation\\*} \\\\] に === # 準備 ------- ## ターゲット言語 * `let`バインディング * `catch l1 with l2` と `exit` * `switch` 式 + `default` 節は省いて良い + 定義上は`case` に引っかからず `default` もなければUB + 実際はそういうコードを吐かない * フィールドアクセス `field n x` === # コンパイル ------------ * 値 $\\vec{x}$ を節行列 $P \\to L$ にマッチさせるとする * 手続き $\\mathcal{C}((x), P \\to L)$ でコンパイルする * $\\vec{x} = (x_1 \\cdots x_n)$ * \\\\[ \\begin{equation\\*} (P \\to L) = \\begin{pmatrix} p^1\\_1 \u0026 \\cdots \u0026 p^1\\_n \u0026 → \u0026 l^1 \\\\\\\\ \u0026 \u0026 \\vdots \u0026 \u0026 \\\\\\\\ p^m\\_1 \u0026 \\cdots \u0026 p^m\\_n \u0026 → \u0026 l^m \\end{pmatrix} \\end{equation\\*} \\\\] === # コンパイル ------------ * ただしパターンは少なくとも1つはあるとする + つまり $m  0$ * 節なしマッチは許可されない or 特別扱いが多いので一般性を損ねない * 最初はマッチ失敗のガードから始める ``` standard-ml catch C((x), P → L) with (failwith \"Patrtial match\") ``` === # $n == 0$ ------- * $n$ が0、つまりパターンが残っていなければ最初のパターンがマッチする \\\\[ \\begin{equation\\*} \\mathcal{C}((), \\begin{pmatrix} → \u0026 l^1 \\\\\\\\ \\vdots \u0026 \\\\\\\\ → \u0026 l^m \\end{pmatrix}) = l^1 \\end{equation\\*} \\\\] === # $n  0$ ------- ## (a)変数則 * 最初の列のパターンが全てワイルドカードならマッチさせない。つまり $\\mathcal{C}(\\vec{x}, P \\to L) = \\mathcal{C}(\\vec{x^{\\prime}}, P^{\\prime} \\to L^{\\prime})$ * $\\vec{x^{\\prime}} = (x_2 \\cdots x_n)$ * \\\\[ \\begin{equation\\*} (P \\to L) = \\begin{pmatrix} p^1\\_2 \u0026 \\cdots \u0026 p^1\\_n \u0026 → \u0026 l^1 \\\\\\\\ \u0026 \u0026 \\vdots \u0026 \u0026 \\\\\\\\ p^m\\_2 \u0026 \\cdots \u0026 p^m\\_n \u0026 → \u0026 l^m \\end{pmatrix} \\end{equation\\*} \\\\] === # $n  0$ ------- ## (b)コンストラクタ則 * 最初の列のパターンが全てコンストラクタならコンストラクタ毎に分解する * 雑にいうとこうなる ``` switch x1 with case c1: C(...) case c2: C(...) ... default: exit ``` === # $n  0$ ------- ## (b)コンストラクタ則 * コンストラクタ $c$ に特殊化された節行列$\\mathcal{S}(c, P \\to L)$を次のように定義する + $p^i_1 = c(q^i_1, \\cdots, q^i_a)$のとき$q^i\\_2 \\cdots q^i\\_a p^i\\_2 \\cdots p^i\\_n \\to l^i$ + $p^i_1$ が $c^{\\prime} \\not= c$ のときナシ * 各コンストラクタの腕を以下のようにする ``` (let (y_1 (field 0 x_1)) ... (y_a (field (a-1) x_1)) C((y_1, ..., y_a, x_2, ..., x_n), S(c, P → L))) ``` === # $n  0$ ------- ## (c) ORパターン則 * ORパターンは扱わないので飛ばす * 元論文だとORパターンの最適化も扱っており重要 === # $n  0$ ------- ## (d) 混合則 * 上記どのルールにも当てはまらない場合は節行列を2分割する + 先頭から(a), (b), (c)のどれかが適用できる最大の集合を前半、残りを後半とする * コードは以下のように生成する ``` catch C(\\vec{x}, P_1 → L_1) with C(\\vec{x}, P_2 → L_2) ``` === # 例 ---- ``` standard-ml case (lx, ly) of ([], _) = 1 | (_, []) = 2 | (x::xs, y::ys) = 3 ``` === # 例 ----- * 混合則を2回適用する ``` standard-ml catch catch C((lx ly), ([] _ → 1)) with catch C((lx ly), (_ [] → 2)) with C((lx ly), (x::xs y::ys → 3)) with (failwith \"Patrtial match\") ``` === # 例 ----- * 順にコンストラクタ則、変数則、コンストラクタ則を適用する ``` catch catch switch lx with case []: C((ly), (_ → 1)) default: exit with catch C((ly), ([] → 2)) with switch lx with case (::): C((ly), (y::ys → 3)) default: exit with (failwith \"Patrtial match\") ``` === # 例 ----- * 順に変数則、コンストラクタ則、コンストラクタ則を適用する ``` catch catch switch lx with case []: C((), (→ 1)) with catch switch ly with case []: C((), (→ 2)) default: exit with switch lx with case (::): switch ly with case (::): C((), (→ 3)) default: exit with (failwith \"Patrtial match\") ``` === # 例 ----- * n == 0のケースで終了 ``` catch catch switch lx with case []: 1 default: exit with catch switch ly with case []: 2 default: exit with switch lx with case (::): switch ly with case (::): 3 default: exit default: exit with (failwith \"Patrtial match\") ``` === # 最適化(概要) -------- * 初手3分割だった * 2節目と3節目が入れ替わってたら2分割で済んでた * 勝手に入れ替えればいいのでは？ + ただしマッチの順番を変えてはいけない * → マッチの順番を変えずに入れ替えられる条件を調べよう * 他にはバックトラックで遠くに飛ぶためにcatchにラベルを付けたり * 続きは論文で === # まとめ --------- * パターンマッチには少なくとも3種類の実装があるよ * そのうちバックトラッキングのアルゴリズムを紹介したよ + 変数とORパターンは紹介してないよ * 最適化もありうるよ + 紹介してないよ   ","categories":["ML","OCaml","言語実装","Compiler"],"category_urls":["/categories/ml","/categories/ocaml","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/compiler"],"date":"2018-09-16","title":"Inside Pattern Matchings","url":"https://KeenS.github.io/slide/inside_pattern_machings/"},
  {"body":"数日Twitterで散発的に呟いていたことをまとめる。\nきっかけはkazuhoさんのツイート。 細かいこと言うと、メモリを逐次解放するつもりがないなら、malloc呼ぶのは誤り。大きなブロックを確保して、先頭から順次使っていくのが正しい戦略です。処理が単純化し使用メモリ量が減り局所性が向上する結果、速度が向上する。世代GCやサーバ等多くのプログラムで用いられる一般的な手法です\n\u0026mdash; Kazuho Oku (@kazuho) 2018年9月6日\n世代別GCの件は誤りで、コンパクションをするGCのことかな？\nこの「大きなブロックを確保して、先頭から順次使っていく」、まったくもって正しいんだけど話を単純化しすぎてて、実用上はいくつか問題が発生する。いつブロックを確保していつ解放するのだとか。 「サーバ等」ではリクエストを受け付けてからメモリを確保してレスポンスを返したら解放すればだいたい上手くいく。しかしそれでもリクエストローカルではないデータもあるしこういうカスタムなメモリアロケーションはCじゃないとできない。\nこういうリージョンベースアロケーティング、いろんな言語でやりたいんだけどそういうAPIがないのとたまに含まれる長寿オブジェクトをちゃんと扱えないといけないから難しい。たしかGHCには入ってたはず。\n\u0026mdash; κeen (@blackenedgold) 2018年9月6日 GHCにリージョンとかの名前で入ってた気がしたけど探しても見つからず。GHCのメモリにはみんな困ってるらしく、検索ノイズが大きかった。\n下記の世代別GCはこれで合ってる。\nこの状況を近似したのが世代別GCではあるんだけどいかんせんグローバルに走るのでリクエスト単位でみると全然近似できてない\n\u0026mdash; κeen (@blackenedgold) 2018年9月6日 因みにH2Oはアロケーションを使い分けてるらしい。\nリクエストで使う文字列→リクエスト毎のプールで確保し、完了時にまとめて解放\n同一H2接続のリクエスト間で共有するHPACK文字列→参照カウンタで確保しプールに登録。全てのリクエスト完了時に解放\nPOSTデータ→tmpfsにフォールバックするバッファに確保\nH2接続を表現するオブジェクト→malloc/free\n\u0026mdash; Kazuho Oku (@kazuho) 2018年9月6日 CならH2Oのように適材適所のアロケーション戦略がとれるがやっぱり手動メモリ管理を放棄したGC付き言語だと厳しい。\nまた、今回の自分の話はサーバとかを念頭に置いていて、常にこれが最適とは限らない。\nアプリケーション毎に適したGC戦略があるんだけど残念ながら先に言語とGCがあってあとでアプリケーションが出来上がるので先出しジャンケンになってしまう。処理系作者にできるのはErlangみたいに用途を限定するかJVMみたいに色んなGCを書くくらいしかない。\n\u0026mdash; κeen (@blackenedgold) 2018年9月6日 ところでlldはメモリを開放しないというのをruiさんが度々アピールしているけどそれはGCのある言語でもできる。\nアプリケーション毎の適したGC戦略ってのはGCしないというのも含まれてて、バッチ処理で完走するまでにメモリが枯渇しないならGCしない方が速い。これはlldとかでも取られてる戦略。\n\u0026mdash; κeen (@blackenedgold) 2018年9月6日 本当にGCはない方がいい。\nで、やっぱりGCのある言語でもH2Oのようにリクエスト毎にリージョンを作って破棄したい。色々考えるに、このリージョンは丁度fiberとかと寿命が一致するのではと思いつく。\n昨日のGC戦略の続き。最近Project Loomの件とかでfiberが気になってるんだけどそれに対応して階層的リージョンとか出来ないかな。リージョンは自身か祖先のリージョンのメモリしか触れない。そうするとfiber毎にリージョン作ってfiberと一緒に破棄が簡単に出来るようになる。\n\u0026mdash; κeen (@blackenedgold) 2018年9月7日 階層化したのはfiberに親子関係があるからと、長寿オブジェクトも親のリージョンに置いとけば寿命長く出来るだろみたいなノリ。もちろんfiberのリージョンの上にはスレッドのリージョンがあるしグローバルなリージョンもある。\nしかしやはりAPIの問題がある。ところでここまででてきたリージョンは「一時的に用意されたメモリのカタマリ」くらいのゆるふわな用語だけど下記のregionはちゃんとした方のリージョン。(CF リージョンについて)\nしかしこれはかなりメモリを明示的に扱えるような言語仕様じゃないとだめで、言語設計から考えないといけない。研究レベルだとλ_{Region}の変種になると思うけど実用言語だと存在しないかなぁ。\n\u0026mdash; κeen (@blackenedgold) 2018年9月7日 これは似たようなものがあったはず。\nICFP 2016でstack based gcの話があった気がするけど全然覚えてないや\n\u0026mdash; κeen (@blackenedgold) 2018年9月7日 今調べたらこれだった。 Hierarchical memory management for parallel programs まだ読んでないので自分の考えと近いかは分からない。\nで、自分の考えが合理的か考えてみた。\nGCの話続き。fiberみたいな実行単位とメモリを結びつけるのはある程度合理的。メモリをアロケートするのも使うのもコードだから。それをもう少し細かくしたのが関数単位にしたスタック変数になる。\n\u0026mdash; κeen (@blackenedgold) 2018年9月8日 これは少し間違ってて、自分は親のメモリにもアクセスしようとしてるからスタック変数よりは柔軟になる。しかしやっぱりそれをやろうとするとリージョンになる。 つまりリージョンを前提にした言語設計になる。\n結局、既存の言語に簡単には入らなそう。世知辛い。\n余談\nfiber毎とかもうちょっと言うとthread毎とかにメモリプールを持つと副産物としてfiber_local, thread_localが必要なくなる。thread_localの細かい仕様は覚えてないから完全互換ではないと思うけどやりたいことは大抵実現できるはず。\n\u0026mdash; κeen (@blackenedgold) 2018年9月8日 \n","categories":["GC","メモリ管理","言語実装"],"category_urls":["/categories/gc","/categories/%e3%83%a1%e3%83%a2%e3%83%aa%e7%ae%a1%e7%90%86","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2018-09-09","title":"Thoughts on GCs","url":"https://KeenS.github.io/blog/2018/09/09/thoughts_on_gcs/"},
  {"body":"κeenです。こういう流れがあったので移植しました。 keenさんが「2028年、Rust でイケてる web application framework はこれだ！」みたいな記事を書くとと \u0026quot;余力\u0026quot; が生まれるかもしれません…！！\n\u0026mdash; FUJI Goro (@gfx) 2018年8月28日 \nまずISUCONを知らない方に雑に説明しておくと、意図的に遅く作られたWebアプリケーションが与えられるので7時間くらいでどれくらい高速化できるかを競うコンテストです。 このお題のWebアプリケーションが参加者や流行りに合わせて複数言語で提供されるのですが、今年はRustが来そうだということで参加者の肩慣らしのために過去問を移植しましたというお話。\nひとまずソースコードは こちら\n手元でベンチマークをしてみた限り、Pythonの2倍くらいは速いもののGoには劣るようでした。これの考察については後で書きますが、1つ注意してほしいのは実際の予選では1コアマシンが複数与えられたそうですが手元では16コア/32スレッドマシンでベンチマークを取っているので実戦でのスコアを反映するものではありません。\n使い方はREADMEを見てもらうとして、以下は主にライブラリやコード例などを解説します。\nライブラリ RustのWebアプリケーションフレームワーク 出来る限り非同期フレームワークを使いたいですが、今Rustの非同期は丁度バタバタしている領域なので決定版といえるものがありません。\n今回検討したというか実際に途中まで書いてみたのは以下の3つ\n tower-web - mioやtokioなどRustの非同期ライブラリの大本をやっているcarllerche氏によるフレームワークです。使い勝手もよく期待が持てそうでしたがまだ若く、必要なライブラリが足りなかった(具体的にはセッションサポートがなかった)のでやめました。 Gotham - 設計上パフォーマンスが出そうと踏んでいたのですがDBコネクションの持たせ方が分からなかったので諦めました。調べ方が悪かったのかもしれません。 actix-web - actorフレームワークの上に乗っかったHTTPフレームワークですがactorを無視して使うこともできます。普段の仕事でも使っていますし無難にこれを使いました。  他にもあるかと思いますが検討できていないです。他社でもactix-webの採用事例を聞くので多分外してないと思います。\nその他のライブラリ sha-1 今SHA-1を扱いたいならRustCryptoプロジェクトのsha-1になると思います。気をつけてほしいのはcrates.ioにはrust-cryptoクレートも sha1 クレートもありますがどちらも別物です、 sha-1 を使いましょう。私は両方とも踏みました。\nテンプレートエンジン あまりRustでテンプレートエンジンを扱う話を聞かないので決定版がわかりません。 一応handlebarsが人気のようですし、私もよく使っているのでそれを採用しました。\n速度や他のエンジンと比べたときの使いやすさはわかりません。みんなが使っている安心感があります。\nJSON serde_json一択です。\nMySQL これは迷いました。普段ならdiselを使いますがISUCONではそこまで大げさなものは必要にならないので適当に見つけたmysqlを使いました。 兄弟ライブラリにmysql_asyncもあるようですがこちらはまだ試せてないです。\n余談ですがこのライブラリ、MySQLのプロトコルを自前で実装しているのでlibmysqlclientに依存しません。\nエラー actix-webを使うと自動的にFailureを使うことになります。 移植元のコードも例外は全然気にせず書いてますしこちらもブラックホールのようにエラーを全部Failureに投げ込むことにしました。\nコード Rubyのコードを見ながら移植しました。\nコード全体を Result を使って書くか Future を使って書くか迷いましたが Result にしました。\nmdo! などの代用品はあるものの ?記法が使えないのは結構辛かったです。\nactix-webの基本的な使い方 まず、DBコネクションなどを保持するデータ型を定義します。\n#[derive(Clone)]struct Isu{pool: my::Pool,templates: Arc\u0026lt;Handlebars\u0026gt;,} Rubyでいう App クラスに近い役割を果たします。Appという名前はフレームワーク側で既に使われているので Isu にしました。\nそしてハンドラはこう書きます。Sinatraに雰囲気を併せるためにクロージャでハンドラを書きます。\nfn app(isu: Isu)-\u0026gt; App\u0026lt;Isu\u0026gt;{letmutapp: App\u0026lt;Isu\u0026gt;=App::with_state(isu);// ... app=app.route(\u0026#34;/initialize\u0026#34;,Method::GET,|state: State\u0026lt;Isu\u0026gt;|-\u0026gt; Result\u0026lt;HttpResponse,Error\u0026gt;{state.exec_sql(\u0026#34;DELETE FROM user WHERE id \u0026gt; 1000\u0026#34;,())?;state.exec_sql(\u0026#34;DELETE FROM user WHERE id \u0026gt; 1000\u0026#34;,())?;state.exec_sql(\u0026#34;DELETE FROM image WHERE id \u0026gt; 1001\u0026#34;,())?;state.exec_sql(\u0026#34;DELETE FROM channel WHERE id \u0026gt; 10\u0026#34;,())?;state.exec_sql(\u0026#34;DELETE FROM message WHERE id \u0026gt; 10000\u0026#34;,())?;state.exec_sql(\u0026#34;DELETE FROM haveread\u0026#34;,())?;Ok(http_status(204))},);//... } actix-webはハンドラの引数にほしいものを書いたら自動で渡してくれるタイプのフレームワークです。 State\u0026lt;Isu\u0026gt; がRubyの App 内での self に近い存在です。 Deref\u0026lt;Target = Isu\u0026gt; を実装しているので Isu のメソッドがそのまま使えます。\nパスパラメータ、クエリパラメータなどの取り出しは一旦型を定義してあげて\n#[derive(Deserialize)]struct ParamChannelId{channel_id: u64,} 以下のようにハンドラの引数に Path\u0026lt;ParamChannelId と書いておくと channel_id という名前のプレースホルダから値を取得してくれます。\napp=app.route(\u0026#34;/channel/{channel_id}\u0026#34;,Method::GET,|state: State\u0026lt;Isu\u0026gt;,session: Session,path: Path\u0026lt;ParamChannelId\u0026gt;|-\u0026gt; Result\u0026lt;HttpResponse,Error\u0026gt;{// ... }); 型を定義する手間はありますが #[derive(Deserialize)] のようにメタプログラミングで色々やってくれるメリットもあるので一長一短です。\nこれでフレームワークは大体使えると思うのであとは書いていくだけです。\nJSON マクロがあるのでjsonをそのまま書けます。\njson!({\u0026#34;user\u0026#34;: user,\u0026#34;channels\u0026#34;: channels}) エラー あらゆるエラーを一旦Failureのエラーに潰してからactix-webのエラーに変換する関数です。 どんなエラーが来ても.map_err(err)で処理できるようになります。\nfn err(e: impl::failure::Fail)-\u0026gt; Error{lete: FailureError=e.into();e.into()} エラーハンドリングをまともにしないISUCON用のものなのであまり真似しないで下さい。\nマルチパート アイコンの扱いのところでマルチパートが出てきます。 actix-web は一応使えないことはないくらいのサポート具合でしたのでかなりつらい対応になりました。 MultipartItemなどのほぼプロトコルそのままマッピングしたデータ型を扱います。 POST /profile のハンドラだけ異様な形をしていますが半分がマルチパートサポートの貧弱さのせい、もう半分が非同期プログラミングのせいです。\nDB まずテープルに対応するデータ型を定義して\n#[derive(Debug, Clone, Serialize, Deserialize)]struct User{id: u64,name: String,salt: String,password: String,display_name: String,avatar_icon: String,created_at: NaiveDateTime,} DBから取得したデータとのマッピングを書いて\nimplFromRowforUser{fn from_row(row: my::Row)-\u0026gt; Self{Self::from_row_opt(row).expect(\u0026#34;failed to deserialize data\u0026#34;)}fn from_row_opt(row: my::Row)-\u0026gt; Result\u0026lt;Self,my::FromRowError\u0026gt;{FromRow::from_row_opt(row).map(|(id,name,salt,password,display_name,avatar_icon,created_at)|Self{id,name,salt,password,display_name,avatar_icon,created_at,},)}} 使うのは1行です\nfn db_get_user(\u0026amp;self,user_id: u64)-\u0026gt; Result\u0026lt;Option\u0026lt;User\u0026gt;,Error\u0026gt;{self.first_sql(\u0026#34;SELECT * FROM user WHERE id = ?\u0026#34;,(user_id,))} DBとデータとのマッピングはフルスタックのORMならメタプログラミングで自動生成してくれるのですがこれは軽量ライブラリなので手書きのようです。\nまた、データ型の定義が面倒ならタプルで取り出す方法もあります。\nlet(name,display_name,avatar_icon): (String,String,String)=state.first_sql(\u0026#34;SELECT name, display_name, avatar_icon FROM user WHERE id = ?\u0026#34;,(message.user_id,)).map(|opt|opt.expect(\u0026#34;application reached inconsistent state\u0026#34;))?; Rubyとの比較とか Rubyから移植したのでRubyっぽいコードになってます。 Rustのお手本的コードは無駄がなく速いコードになるんですがそもそも遅いアプリケーションがお題なのでどこまで効率的に書くか悩ましかったです。\nRustはコストやリスクが目に見える言語です。\nたとえばRubyの\npass_digest = Digest::SHA1.hexdigest(salt + password) というコードはRustではほぼ直訳して\nletpass_digest=format!(\u0026#34;{:x}\u0026#34;,Sha1::digest_str(\u0026amp;(salt.clone()+password))); としています。しかし salt.clone() のようにデータをコピーしていたりそもそも結合する必要のない文字列を結合していたりしてあまりよろしくないです。\nあるいはRubyの\nstatement = db.prepare(\u0026#39;SELECT name, display_name, avatar_icon FROM user WHERE id = ?\u0026#39;) statement.execute(row[\u0026#39;user_id\u0026#39;]).first というコードはRustでは\nstate.first_sql(\u0026#34;SELECT name, display_name, avatar_icon FROM user WHERE id = ?\u0026#34;,(message.user_id,),).map(|opt|opt.expect(\u0026#34;application reached inconsistent state\u0026#34;))?; と翻訳しています。 opt.expect(\u0026quot;application reached inconsistent state\u0026quot;) とリスクが目に見える形になっています。\n上記のように基本的にRustで書くとRubyより冗長になるのですが案外Rustの方が短いケースもあります。\nrubyのこのコードは\ndescription = \u0026#39;\u0026#39; channels.each do |channel| if channel[\u0026#39;id\u0026#39;] == focus_channel_id description = channel[\u0026#39;description\u0026#39;] break end end このように翻訳されます。\nletdescription=channels.iter().find(|ch|Some(ch.id)==focus_channel_id).and_then(|ch|ch.description.clone()).unwrap_or_else(||\u0026#34;\u0026#34;.into()); パフォーマンスとか 先述のとおり初期状態でPythonより速くてGoより遅かったです。 N+1クエリが仕込まれてるので最初はアプリケーションの速さはあまり問題にはならなくて、ほぼDBの速度で決まります。 そんな中Goだとgoroutineでブロッキングする部分を上手く分離できるので効率が良かったんじゃないかなと推測します。 Rustもmysql_asyncを使ったら速くなるかもしれません。\nしかしそんなことより普通にN+1クエリを解消してインデックスを張ってDBを速くするのであまり初期スコアには意味がないと思います。 DBアクセスを非同期にするのはまずは筋が悪い部分を消してからでしょう。\nRustで出るチームへのアドバイス 私は参加登録してないので好き放題言えます。\n言語の基本性能ではRustはGoよりは速いはずなのである程度アプリケーションにボトルネックが移ったらRustの方が有利になる可能性があります。 競技中にそこまでボトルネックが移らない可能性も十分にあります。\ncargo build に --release を付け忘れないようにしましょう。\ncargo watchでソースが更新されたらビルドされるようにしておくと古いバイナリを見ることがないかも?\n非同期コードを書く時はnightlyを使ってasync/awaitで挑む手があるかもしれません。少なくとも生のFutureだとかなりつらいので何かしらを手を用意した方がよさそうです。\ncargo build に --release を付け忘れないようにしましょう。\n普段使わないところはライブラリ選びからになるので一通り肩慣らししておくといいと思います。\nクロスコンパイルはどうせハマるので大人しくサーバでコンパイルした方がいいと思います。\ncargo build に --release を付け忘れないようにしましょう。\n移植してみた感想 思ったより大変でした。マルチパートのユーティリティを除いても900行オーバーのアプリケーションになりました。Goが750行くらいなので20%くらい長いですね。\n実装もそうですがライブラリの選定で苦労しました。 一回実装して中途半端に使いづらくて別ライブラリで実装し直したりしてました。普段扱わないことやると大変ですね。\n因みにRustで書きあがった後ベンチマーカが完走するまでに出たバグは5,6個(種類)でした。 ほとんどがhandlebarsの記法由来で、Rust側ではほとんどバグはなかったです。 こういう点は静的型付き言語の良いところでしょうか。\n最後に とりあえずで実装したので荒いコードですが皆様是非練習にお使い下さい。\n","categories":["Rust","ISUCON"],"category_urls":["/categories/rust","/categories/isucon"],"date":"2018-09-02","title":"isucon7予選のアプリをRustに移植したから解説するね","url":"https://KeenS.github.io/blog/2018/09/02/isucon7yosennoapuriworustniishokushitakarakaisetsusurune/"},
  {"body":"κeenです。久しぶりのブログですね。 LLイベントに行ってきたらパッケージマネージャの話がありました。 その懇親会でcargoについて振られたんですがタイミングがなくて喋れなかったのでブログに書いておきます。\nざっくりまとめると\n パッケージマネージャ/ビルドツールに要求される要件を卒なくこなしている 面倒を見る範囲が広く、要はワンストップソリューションだから便利 コンパイラと同じ母体が開発してるのでグダグダがない  じゃないかなと思います。あとバイナリなのでキビキビ動く。 因みにcargoが便利という声の中にはcrates.ioで欲しいパッケージを探しやすいだとかみんな割とセマンティックバージョニングを守るので理不尽にビルドがコケたりしないなどもあると思います。\n1に関しては最近のよくあるベストプラクティスを全部やったらこうなったって感じですね。\n セマンティックバージョニングで依存関係を管理 必要とあればgitからソースを取得することも可能 依存関係のプロジェクト毎の隔離。他のプロジェクトをビルドしてグローバル環境が壊れたりしない。 lockファイルで再現性のあるビルド パッケージのフェッチからビルドまで1アクション 設定を書かなくてもソースはsrc以下に放り込んだら勝手にビルド ビルド成果物も他のプロジェクトとコンフリクトしたりしない ライブラリもバイナリも扱える テスト用などの開発時専用依存関係も書ける  ほとんどの他のパッケージマネージャも8, 9割くらいは同じことを実現できてると思いますがcargoは全部やってます。\n2に関しては\n スケルトン作成 (cargo new) エラーチェック (cargo check) プロジェクト定義/パッケージ定義/依存関係定義 (Cargo.toml) ビルド (cargo build) なんなら(プロジェクトのFFIで呼び出す)Cのソースのビルド/リンクも出来る (build.rs) 実行 (cargo run) テスト (cargo test)  これはRustが言語組み込みでテスト機能を持ってるのにも依存している  exampleの実行 (cargo run \u0026ndash;example) ドキュメント生成  依存ライブラリのも含むので開発用に参照する用途にも使える  パッケージの登録 (cargo publish) パッケージバイナリのインストール (cargo install) パッケージレジストリも(今の所)唯一のcrates.ioだけなのでゼロコンフィギュレーションで使える  この他には細かいところだとワークスペース機能があるので複数のプロジェクトをまとめることもできます。 あとはプラグインシステムでサブコマンドを自由に作れるのでCargo.tomlをCLIで編集するcargo-edit、プロジェクトのソースコード全てをフォーマットするcargo-fmt等も有ります。\nとにかくパッケージを登録するまで全てcargoが面倒を見るのでユーザ側もCargo.tomlだけ書いていればいいのが非常に楽です。 ライブラリのソースコードを読むときも私は大体Cargo.tomlから見ます。\n3はたとえばrustがeditionという概念を導入したら同時にcargoがeditionディレクティブを入れたり最新の機能がスムーズに利用できるようになってます。 地味にコンパイラと一緒に配布されているのでコンパイラバージョンとビルドツールバージョンの組み合わせを考えなくていいのもいいポイントですね。\n有志で作ると個人の限界で複数のツールに分かれがちなところをマンパワーで殴ってワンストップソリューションまでもっていけたのが効いてるんですかね。\nもちろん、cargo以外にも良いパッケージマネージャ/ビルドツールはあると思います。cargoを一例として挙げてみました。\n逆にCargoに足りないものもあります。\n1つには名前空間があります。 たとえばIronというフレームワークのミドルウェアの1つが\u0026ldquo;mount\u0026rdquo;という名前になっていたりする世界観です。 そのせいか名前予約のために空のクレートを登録するなどの治安事案も発生していたりします。\nあるいはシンプルにcrates.ioのウェブサイトが遅い。代替のcrates.rsなんかが作られたりしています。\n並列ビルドや差分コンパイルも悩みの種です。 cargoというかrustは1プロジェクト(クレート)単位でコンパイルするので1つの巨大なコードベースだとコンパイルが遅くなりますし、1行編集するだけで全体が再コンパイルになります。 一応インクリメンタルコンパイルが入っていたりはしますが…。\nまとめ cargoは巨大なマンパワーで快適さが実現されてる\n","categories":["Rust","Cargo"],"category_urls":["/categories/rust","/categories/cargo"],"date":"2018-08-26","title":"cargoのどこがいいのか","url":"https://KeenS.github.io/blog/2018/08/26/cargonodokogaiinoka/"},
  {"body":"# Rustこれまでとこれから---------------------- [Learn Languages 2018 in ODC (LL2018) ](https://llevent.connpass.com/event/95443/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [ちゅーんさんだよー](https://shindanmaker.com/789932) * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア + Rustで開発してるよ * Lisp, ML, Rust, Shell Scriptあたりを書きます === # 今日話すこと ------------- * X Rustの勉強法 * X Rust言語の紹介 * O Rustの歩み * O Rustの開発体制 === # Rustとは ---------- * システムプログラミング言語 * 安定性、信頼性が売り * 2015年に[1.0リリース](https://blog.rust-lang.org/2015/05/15/Rust-1.0.html) + ~~いつまで20年ものの言語使ってるの~~ * 大体の便利な言語機能を取り入れてる * 所有権システムにより **GCがない** * コンパイラが `free` を自動挿入 === ```rust // ジェネリクス+トレイト境界 // move セマンティクス fn dup(t: T) - (T, T) { // タプルあるよ (t.clone(), t) } fn main() { // マクロ let vec = vec![1, 2, 3]; // パターンマッチで分配束縛 let (v1, v2) = dup(vec); // 雑にデータ型を印字できる println!(\"v1: {:?}, v2: {:?}\", v1, v2); // `v1`, `v2`はコンパイラが勝手にfreeしてくれる // (`vec`はmoveしてるのでそもそも関係ない) } ``` === # 特徴 ------ * エルゴノミクスに拘った設計 + explicitな言語 * 後方互換を大事に + SemVerベースの管理 + バージョンアップでコードが壊れることは殆ど無い * 学習難易度は高め === # 学習難易度 ---------------- * 難しい(直球) * 悪い難しさではない + プログラミング本来の難しさ * その代わり学習補助が手厚い + エラーメッセージが親切 + 公式ドキュメントがよく出来てる === ![Rustの学習曲線の図](/images/ll_rust/rust_learning_curve.png) === # ドキュメント文化 ----------------- * [The Rust Programming Language](https://doc.rust-lang.org/book/)がよく出来てる * 他にも[Rust by Example](https://doc.rust-lang.org/rust-by-example/index.html)、[Rustnomicon](https://doc.rust-lang.org/nomicon/index.html)、[The Unstable Book](https://doc.rust-lang.org/unstable-book/index.html)などなど * 全クレート(ライブラリ)のドキュメントも[ある](https://docs.rs/) * [This Week in Rust](https://this-week-in-rust.org/)などのニュースレター === # 日本 ------ * ドキュメントの和訳とか頑張ってる + [Rustの日本語ドキュメント/Japanese Docs for Rust](https://doc.rust-jp.rs/) * [Slackコミュニティ](http://rust-jp.herokuapp.com/) * [勉強会](https://rust.connpass.com/) + [初心者向けハンズオン](https://rust.connpass.com/event/56275/)なども * などなど === # Rustの開発体制 --------------- * コミュニティベースの開発 + [担当チーム](https://www.rust-lang.org/ja-JP/team.html)などあり組織的 * Mozillaが開発を支援 + 「Mozillaが作った言語」ではない * [RFC](https://github.com/rust-lang/rfcs)で言語機能を決める + 意思決定がオープン * 6週間ごとにリリース + stable, beta, nightlyの3チャネルのサイクル + 新機能はfeature gateで一旦試してからbeta, stableに降ってくる === ![Rustの開発サイクル](/images/ll_rust/rust_dev_cicle.png) === # 意思決定とか ------------- * サーベイしてデータドリブンで注力領域を決めてる + [Survey 2017](https://blog.rust-lang.org/2017/09/05/Rust-2017-Survey-Results.html) + [2018](https://blog.rust-lang.org/2018/08/08/survey.html)もやってる([和訳](https://docs.google.com/forms/d/e/1FAIpQLSeueHtp6L0hPGy6h9tUxgNEnUv1xBxBqBdJlHsKCCx37yGMug/viewform)もあるよ) * サーベイの結果Domain Working Groupが[発足](https://internals.rust-lang.org/t/announcing-the-2018-domain-working-groups/6737) * WGのミーティングなども公開されてる + [GitHub](https://github.com/rust-lang-nursery/wg-net) + 徹底的にオープンだよね。 === ## 4つのWorking Groupとその目標  #grid-container .box26 { position: relative; margin: 0.5em 1em; padding: 0.5em 1em; border: solid 3px #000; border-radius: 8px; } #grid-container .box26 .box-title { position: absolute; display: inline-block; top: -13px; left: 10px; padding: 0 9px; line-height: 1; font-size: 24px; background: #FFF; font-weight: bold; } #grid-container .box26 p { margin: 0; padding: 0; }  Network  非同期、IoT、ウェブの3つに注力\n CLI クロスプラットフォームでよくテストされてモダンなCLIツールを作れるように\n WASM Rustを最高のWASM開発言語にする\n Embed 組み込みプログラミングをもっと簡単に\n  === # 最近の話題 -------------- * SIMD Intrinsic * メモリアロケータが選択可能に * 非同期 + futureやasync/awaitなど * Generic Associated Type + [Chalkプロジェクト](https://github.com/rust-lang-nursery/chalk) + 雑にいうとProlog処理系をコンパイル時に動かす * Compile Time Function Execution + [Miriプロジェクト](https://github.com/solson/miri) + 雑に言うとRustインタプリタをコンパイル時に動かす === # SIMD ``` rust #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"), target_feature = \"avx2\"))] fn foo() { #[cfg(target_arch = \"x86\")] use std::arch::x86::_mm256_add_epi64; #[cfg(target_arch = \"x86_64\")] use std::arch::x86_64::_mm256_add_epi64; unsafe { _mm256_add_epi64(...); } } ``` === # メモリアロケータ ``` rust use std::alloc::System; #[global_allocator] static GLOBAL: System = System; fn main() { let mut v = Vec::new(); // This will allocate memory using the system allocator. v.push(1); } ``` === # Rustのこれから === # Rust 2018 Edition === # Rust 2018 ----------- * 言語に非互換アップデート入るよ + キーワードの追加とか * 今までのを2015、新しいのを2018と呼ぶ + Rust 2015: stability + Rust 2018: productivity * 3年に1度更新される * 互換性はないけど相互運用性はある + コンパイラは2015と2018同時サポート + 2015と2018は混ぜて使える * さらに移行ツールも提供されてる === # 変わるところ ------------- * 新規構文 + `async` / `await` + `try` * ライフタイムの省略や自動推論などの強化 * 2015も継続して改善される + 急に大きく変わる訳ではない + 2018の機能が既に入っているものも * いままでの変更のまとめ的な意味もある + [edition guide](https://rust-lang-nursery.github.io/edition-guide/introduction.html)で2015(1.0.0)との差分が見れる === # まとめ -------- * Rustは新しい言語だよ * Rustはオープンな開発体制をしてるよ * アウトリーチの努力がすごいよ * 今も継続的に改善されてるよ   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2018-08-25","title":"Rustのこれまでとこれから","url":"https://KeenS.github.io/slide/rustnokoremadetokorekara/"},
  {"body":"# Rustと3種のDSL ---------------------- [Running Rust in Production](https://d-cube.connpass.com/event/90317/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # DSLとは  Lispでは，プログラムをただプログラミング言語に従って書くことはしない． プログラミング言語を自分の書くプログラムに向けて構築するのだ  -- Paul Graham (On Lispより) === # DSLとは ---------- * ドメイン特化言語 * 自分の解きたい問題に合わせてミニ言語を作る + 関心に集中 + 言語を設計することでドメインへの考察が深まる * 2種類ある + 内部DSL: ホスト言語の式でそれっぽく作る + 外部DSL: 外部化してパーサから作る * まずは内部DSLを検討しよう === # DSLの使いどころ ---------------- * だいたい以下の条件 + 素直に書くと記述が多い + 細かなバリエーションがあって関数一つにはまとめられない + → スイートスポットがDSL * 典型的にはビジネスロジックとか === # Actcast --------- * Idein社で開発中のサービス * IoTデバイスを管理する + 人、管理グループ、デバイス、アプリケーションなどエンティティが多め * APIはOpen API(旧Swagger)を使う * まだ開発中 + 一緒に開発してくれる人募集してます! * 今回はこれで使ったDSLの話 === # 珠玉の内部DSL === # アクセス権限チェック ``` rust fn update_device(operator: User, device: Device) - Result { use dsl::*; let conn = get_conn(); if !is_user_readable_to_device(operator, device, \u0026conn)? { return Err(Error::ReadPrivilege); } if !is_user_writeable_to_device(operator, device, \u0026conn)? { return Err(Error::WritePrivilege); } // do update Ok(device.clone()) } ``` === # アクセス権限チェック ```rust fn update_device(operator: User, device: Device) - Result { use dsl::*; let conn = get_conn(); check_if( \u0026conn, // 権限チェックのDSL operator.is_readable().is_writable().to(device), )?; // do update Ok(device.clone()) } ``` === # モデリング ------------ ``` rust // これを実装しているものがDSLになる気持ち trait Precondition { fn check(\u0026self, conn: \u0026DbConn) - Result; } struct And(P, Q); implPrecondition for Andwhere P: Precondition, Q: Precondition, { fn check(\u0026self, conn: \u0026DbConn) - Result { self.0.check(conn).and_then(|()| self.1.check(conn)) } } struct IsReadable(A, B); struct IsWritable(A, B); impl Precondition for IsReadable{ fn check(\u0026self, _conn: \u0026DbConn) - Result { // do ckeck Ok(()) } } impl Precondition for IsWritable{ fn check(\u0026self, _conn: \u0026DbConn) - Result { // do ckeck Err(Error::WritePrivilege) } } ``` === # DSLの構築 ----------- ``` rust mod dsl { use super::*; pub struct IncompleteIsReadable(T); pub trait IsReadableDsl { type Out; fn is_readable(self) - Self::Out; } impl IsReadableDsl for User { type Out = IncompleteIsReadable; fn is_readable(self) - Self::Out { IncompleteIsReadable(self) } } // 長いので略 } ``` === # 内部DSL --------- * [コード全体](https://gist.github.com/KeenS/d8ef8c95110742d31c74c750ed456ecb) * 正道 * トレイトをうまく使う + メソッド記法でそれっぽく + 演算子オーバーロードはあまり悪用しない * DSLはあくまで略記のための手法 + 何がしたいかよくモデリングする * モデルと記法分離することで内部実装を変更できたりも === # 特殊化 ------- ``` rust impl Precondition for IsReadableWritable{ fn check(\u0026self, _conn: \u0026DbConn) - Result { // 本当はAnd, IsWritableでも可能 // DBアクセスを減らすために特殊化 Err(Error::WritePrivilege) } } mod dsl { impl ToDsl for IncompleteIsReadableWritable { type Out = IsReadableWritable; fn to(self, to: Device) - Self::Out { // ユーザインタフェースを(見た目レベルでは)変えずに内部実装を変更可能 // And(IsReadable(self, to), IsWritable(self, to)) IsReadableWritable(self.0, to) } } } ``` === # 諸刃の剣のマクロDSL === # API定義 --------- ``` rust { #[derive(Serialize, Deserialize, Debug, Clone)] pub struct PathParameters { app_id: api::AppId, } app = app.route( \"/apps/{app_id}\", Method::GET, | (req, path, sess): (HttpRequest, Path, Session)|- FutureResponse { let _user: model::User = match sess.get::(SESSION_KEY) { Ok(Some(user)) = user, Ok(None) = return Box::new(Err(hoge).into_future()).responder(), Err(e) = return Box::new(Err(e).into_future()).responder(), }; let path = path.into_inner(); // 関心があるのはここ service::api::find_app(\u0026*ctx, path.app_id) // and do more let fut = fut.map(Into::into) .from_err(); let fut: Box = Box::new(fut); fut.responder() }); } ``` === # API定義 --------- ``` rust def_api!{ Method: GET, // ルーティングと引数を同時記述 Path: { /apps/{app_id:api::AppId} }, Session, Response: api::api::apps_::get::Response, // この`path`に`app_id`が入る。 // 引数もマクロの書き方で増減する Handler: |ctx, path, _user| { service::api::find_app(\u0026*ctx, path.app_id) // and do more } }; ``` === # マクロDSL ------------- * マクロの実装は出せない + 出しても多分読めない + 合計300行くらいのマクロ群 * 可能なら使わない方が良い + マクロは第一級でない(関数の引数に渡せない) * マクロにしかできないこともある * arityの調整、シンボルから文字列の生成、構造体の定義の生成などなど * まあまあトリッキー + [The Little Book of Rust Macros](https://danielkeep.github.io/tlborm/book/index.html)読んで === # マクロと型 ------------ ``` rust macro_rules! take_tt { ($t:tt) = { stringify!($t) }; } // エラー: `::std::string::String`はそのままだと複数のttになる let _ = take_tt!(::std::string::String); macro_rules! wrap_ty { ($t:ty) = { take_tt!($t) }; } // OK: 一旦tyとしてパースすると1つのttになる let _ = wrap_ty!(::std::string::String); ``` === # マクロのCPS変換 --------- ``` rust macro_rules! id_ty { ($t:ty) = { $t }; } // エラー: マクロの入れ子呼び出しはできない let _ = take_tt!(id_ty!(::std::string::String)); macro_rules! id_ty_cps { ($t:ty, $callback:ident) = { $callback!($t) }; } // OK: コールバックとして受け取ればよい let _ = id_ty_cps!(::std::string::String, take_tt); ``` === # みぞの鏡の外部DSL  erised stra ehru oyt ube cafru oyt on wohsi -- The Mirror of Erised === # JSON Schema ------------- ``` json { \"type\":\"object\", \"properties\": { \"id\": {\"type\": \"integer\"}, \"name\": {\"type\": \"string\"} } \"required\": [\"id\", \"name\"] } ``` === jsonで型付きデータスキーマを定義するときによくある\n{name: \u0026quot;hoge\u0026quot;, type: \u0026quot;typename\u0026quot;, required: false}\nとかやるやつダサくない？\nhoge: typename option\nって書きたくない？\n\u0026mdash; κeen (@blackenedgold) 2017年10月18日 === # JSON Schema ------------- 略記できるツールを作った ``` struct { id: integer, name: string, } ``` === # 外部DSL --------- * [KeenS/chema](https://github.com/KeenS/chema) * ほしいものがなんでも手に入る * 最後の手段 * 文字列からRustのデータ型を構成する + 今回はJSON SchemaがターゲットなのでJSONにダンプ + ある意味ではコンパイラ * 最後の手段 * 開発支援ツールやエラーメッセージが壊滅的 * 最後の手段 === # まとめ -------- * DSLは色々なケースで役に立つよ * 3種のDSLを使いこなそう * 珠玉の内部DSL + 普段はこれを使おう * 諸刃の剣のマクロDSL + デメリットをよく考えて使おう * みぞの鏡の外部DSL + なんでも出来るけど溺れるな   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2018-07-01","title":"Rustと3種のDSL","url":"https://KeenS.github.io/slide/rustto3tanenodsl/"},
  {"body":"# nom勘所 ---------------------- [Rust LT](https://rust.connpass.com/event/88656/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # nom ----- * [GitHub](https://github.com/Geal/nom) * マクロベースのパーサコンビネータ * ゼロコピー、速い、バイト指向 === # nomの使い方 ------------ * [ドキュメント](https://docs.rs/nom/4.0.0/nom/)に大量にパーツがあるので分かりづらい * 基本的なパーツは以下 + `named!` - パーサを定義 + `do_parse!` - 連接 + `alt(_complete)!` - 選択 + `tag!` - トークン + `map!` - 型変換 * 1データ型1パーサくらいの感覚 * あとは必要に応じて覚える + 似たような実装を探して真似る === # 例: 四則演算 ------------- まずは列挙型を定義 ```rust #[derive(Debug, Clone, PartialEq)] enum Expr { BinOp(BinOp), Number(Number), } ``` === # 例: 四則演算 ------------- 対応するパーサを`alt!`で定義 ``` rust named!( expr, alt_complete!( map!(binop, Expr::BinOp) | map!(number, Expr::Number) ) ); ``` === # 二項演算 ------ まずは構造体を定義 ``` rust #[derive(Debug, Clone, PartialEq)] struct BinOp { l: Box, op: Op, r: Box, } #[derive(Debug, Clone, PartialEq)] enum Op { Add, Sub, Mul, Div, } ``` === # 二項演算 ------ 対応するパーサを定義(ただしバグあり) ``` rust named!(binop, do_parse! ( l: map!(expr, Box::new)  multispace0  op: op  multispace0  r: map!(expr, Box::new)  (BinOp{l, op, r}) )); named!(op, alt!( map!(tag!(\"+\"), |_|Op::Add) | map!(tag!(\"-\"), |_|Op::Sub) | map!(tag!(\"*\"), |_|Op::Mul) | map!(tag!(\"/\"), |_|Op::Div) )); ``` === # 数値 ------ 型そのものは簡単 ``` rust #[derive(Debug, Clone, PartialEq)] struct Number(i64); named!(number, map!(atom_number, Number)); ``` 数値のフォーマットのパースは？ === # 数値 ------ * `{符号}?{数値}` のフォーマット * rustの`parse!`が使いたい - `do_parse!` だと符号と数値が別になる - 別々にパースしてconcatも出来るけどゼロコピーしたい * `recognize!` があるよ === # 数値 ------ ``` rust named!( atom_number, map!( // recognizeで文字列全体を受け取る recognize!( // do_parse!で文字列のみ認識。変換はしない do_parse!( opt!(tuple!(tag_s!(\"-\"), multispace0))  digit  () )), |n: \u0026str| n.parse().unwrap() ) ); ``` === # 優先順位 ---------- * 四則演算に優先順位をつけたい * 左結合 | | 優先度 | |---------|--------| | 数値 | 3 | | `*` `/` | 2 | | `+` `-` | 1 | === # 左結合 ---------- ``` rust 1 + 2 + 3 ``` ↓ ``` rust + / \\ + 3 / \\ 1 2 ``` === # 優先順位 ----------- * 優先度に合わせてパーサも3つに分ける * `binop3`, `binop2`, `binop1` === # 優先順位 ----------- まだバグってる ``` rust named!(expr1 , alt_complete!( map!(binop1, Expr::BinOp) | expr2 )); named!(binop1, do_parse! ( l: map!(expr1, Box::new)  multispace0  op: alt!(map!(tag!(\"+\"), |_|Op::Add) | map!(tag!(\"-\"), |_|Op::Sub))  multispace0  r: map!(expr2, Box::new)  (BinOp {l, op, r}) )); ``` === # 左再帰 -------- * `binop1` - `expr1` - `binop1` で無限ループ * 手でインライン化すると解決 + 頑張って`loop`を書く === # 左再帰の除去 -------- ``` rust fn binop1(input: \u0026str) - IResult{ named!(parse_op , alt!(map!(tag!(\"+\"), |_|Op::Add) | map!(tag!(\"-\"), |_|Op::Sub))); let (input, l) = expr2(input)?; let (input, _) = multispace0(input)?; let (input, op) = parse_op(input)?; let (input, _) = multispace0(input)?; let (input, r) = expr2(input)?; let mut ret = BinOp { l: Box::new(l), op: op, r: Box::new(r), }; let mut input_mut = input; loop { let (input, op) = match parse_op(input_mut) { Ok(ok) = ok, Err(_) = return Ok((input_mut, ret)), }; let (input, _) = multispace0(input)?; let (input, r) = expr2(input)?; ret = BinOp { l: Box::new(Expr::BinOp(ret)), op: op, r: Box::new(r), }; input_mut = input; } } ``` === # マクロエラー ------------- このエラーの原因分かる人？ ``` rust named!(expr3 , map!(number Expr::Number)); ``` ↓  error: no rules expected the token `i` -- src/main.rs:117:1 | 117 | named!(expr3 , map!(number Expr::Number)); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)  === # 今日話さなかったこと -------------------- * 手軽なエラーの出し方 * 空白の扱い + 多分一番難易度高い === # まとめ -------- * nomはマクロベースのパーサコンビネータだよ * `named`, `do_parse`, `alt`, `tag`, `map` を覚えよう * だいたい型とパーサが対応するよ * 演算子の扱いは難易度高いよ * コード: [KeenS/calc](https://github.com/KeenS/calc)   ","categories":["Rust","構文解析"],"category_urls":["/categories/rust","/categories/%e6%a7%8b%e6%96%87%e8%a7%a3%e6%9e%90"],"date":"2018-06-26","title":"nom勘所","url":"https://KeenS.github.io/slide/nomkandokoro/"},
  {"body":"# GCと1bit ---------------------- [TCFMミートアップ](https://techplay.jp/event/680870) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます * 言語処理系が好き === # GCと(メタ)情報 -------------- * レジスタ/スタック上の値のpointer or not * Mark and Sweepのマーク * ヒープ上オブジェクトの「どこにポインタがいるか」 これらを節約する話 === # レジスタ中のポインタ ------------- * レジスタ上の値がポインタか数値か + GCのrootsetなので判断が必要 + 1bitの情報量が必要 * 多くはLSBをタグに使う + ポインタは0 + 4バイトアラインメントされてると自然にそうなる + 数値は1にする - 数値が31bit/63bitになる - タグを外して計算して戻すので遅い * bit stealしない方法は？ === ## レジスタ分別 --------------- * レジスタを半分に分ける + 片方はポインタ用 + もう片方は値用 * 物理的に1bit取らなくても1bitの情報量が確保できる * ただしレジスタが多いアーキじゃないと死ぬ === # Mark Bit ---------- * マーク済みかどうかのメタデータ + 1bitの情報量 * 素朴にはセルのメタデータに1byte確保 ``` +---+-------+---+-------+-- | 0 | ... | 1 | ... | +---+-------+---+-------+-- +---+-------+---+-------+-- | 1 | ... | 0 | ... | +---+-------+---+-------+-- ``` * 1bitに1byte？ * 1byteって中途半端では？ + 4byteアラインメントすると3byteのpadが入るのでは === ## BitMap --------- * MarkBitだけを集めて効率化 ``` +------+-------+-------+-- | 0110 | ... | ... | +------+-------+-------+-- +-------+-------+-- | ... | ... | +-------+-------+-- ``` * 省スベース * キャッシュ効率がいい * bit演算で扱える * allocatedフラグも同じ仕組みで出来る === ## BitMap --------- * どうやってオブジェクトからマークを探す？ * ページを $2^n$ バイトアラインメント * オブジェクトアドレスの下位 $n$ bitをクリア * いつでもページの先頭に飛べる ``` 0xab00 0xab08 +------+-------+-------+-- | 0110 | ... | ... | +------+-------+-------+-- +-------+-------+-- | ... | ... | +-------+-------+-- ``` === # オブジェクト中のポインタ----------------------- * オブジェクトをマークするときにどこにポインタがあるか？ ```standard-ml type t = {a: string, b: int, c: int list} ``` ↓ ``` +--------+ | 20byte | +--------+ ``` === ## Type Id ---------- * Typeデータをランタイムにも持っておき、メタデータにIDを付ける ``` {1 = {a: string, b: int, c: int list}} +------+--------+------+--------+-- | id=1 | 20byte | id=1 | 20byte | +------+--------+------+--------+-- ``` * 素直 * 動的型付言語やオブジェクト指向言語なら自然 * リフレクションに使える * GCにしたら少し遠回り === ## Big Bag of Pages ------------------- * ヒープページ全体で1つの型のみを扱う ``` {1 = {a: string, b: int, c: int list}} +------+--------+--------+-- | id=1 | 20byte | 20byte | +------+--------+--------+-- ``` * ページが無駄になるかも？ * アロケーションが遅いかも？ === ## 双方向レイアウト ------------- * オブジェクトのフィールドをポインタと値に分ける * ポインタをオブジェクトポインタの前、値を後に置く + 物理で1bit使わなくても情報を持てる ``` +-- ptr v +-------+---+ | a | c | b | +---+---+---+ ``` === # まとめ -------- * 情報の持ち方は色々あるよ * ランタイムの表現も工夫が色々あるよ * ランタイムとデータ表現面白いよ   ","categories":["GC"],"category_urls":["/categories/gc"],"date":"2018-06-24","title":"GCと1bit","url":"https://KeenS.github.io/slide/gcto1bit/"},
  {"body":"κeenです。前々回、前回に引き続き量子コンピュータと量子通信を読んでいます。 今回は6章の量子探索アルゴリズム。読み切ってから少し間が空いてしまいましたが頑張ってまとめます。 勉強中の身で自分の理解を書いているのでみなさん内容は一切信用しないでくださいね。\n前回が位相を使って計算する話だったのに対して今回は振幅(観測確率)を上手く調整して目的の値を観測する話です。\nGroverのアルゴリズムというやつです。 「探索空間の要素を1つ1つ検査してそれが解足りうるならその値を返す」操作を $O(N^{\\frac{1}{2}})$ で実行します。 計算複雑性理論を全然知らないんですがこれって要はNP完全問題を $O(2^{n/2})$ で解けるってことでいいんですよね？ NPは「探索空間の要素が与えられたときにそれが解であるかは簡単に(多項式時間で?)決定できる」で、その自明な解法が「探索空間の要素を1つ1つ検査してそれが解足りうるならその値を返す」という認識なんですが合ってますか？\nさて、Groverのアルゴリズムは計算複雑性的に古典コンピュータの性能を上回る例として有名なので割愛します。重ね合わせ状態に対して繰り返しオラクルを使った演算を適用することで解の観測確率を上げます。 以下個人的に興味深かった点を挙げます。\n1つ。解釈が面白かったです。Groverのアルゴリズムは、時間発展し問題の解に状態が収束する系を考え、それをエミュレーションしていると捉えられます。 4章のところで量子コンピュータの有用性の1つに量子状態のシミュレーションが挙がっていたので伏線だった模様。\n1つ。解の観測確率を1/2にするために探索空間を水増しする処理が入る点。Groverのアルゴリズムは解集合の濃度が探索空間の濃度の1/2以下の仮定を置いているため、解集合があらかじめ分からない場合は探索空間を水増しすることで濃度を1/2以下にします。これはオラクルの自明な拡張で実現できます。操作も簡単ですし計算上それで速くなるのは確かめられるのですが直観に反していて面白いですね。\n最後。これ重要で、アルゴリズム中の反復の中でオラクルを参照している点。このオラクルは問題の検算をしている訳なので多少の複雑な計算が予想されます。自分は量子コンピュータはアクセラレータのつもりでいたのでそういう複雑な計算はは古典コンピュータのものと思っていました。しかしGroverのアルゴリズムでそういった計算が必要になるなら量子コンピュータに思ったより複雑な演算が必要になるのかもしれません。このあたりはI巻に書いてそうな雰囲気なのでやっぱ読まないとだめそうですね。\nGroverのアルゴリズム以外にも量子計数(数え上げ)やブラックボックスアルゴリズムなども載っているのですがちょっとおもしろかったのが量子データベース探索。 データベースというからには流石にデータはレジスタではなくメモリにあるのですが、量子アルゴリズムを使うには重ね合わせができないと面白いことができません。 メモリ素子も量子重ね合わせができるハードウェアを考えるのかなと思ったらそうではないようでした。 LOAD するアドレスを重ね合わせにして、メモリから複数の値を読み出しその複数の値を重ね合わせ状態にしてレジスタに返すマシンを考えていました。こっちの方がまだ実現可能性がありそうでいいですね。\n引き続き7章を読みます。\n","categories":["量子コンピュータ"],"category_urls":["/categories/%e9%87%8f%e5%ad%90%e3%82%b3%e3%83%b3%e3%83%94%e3%83%a5%e3%83%bc%e3%82%bf"],"date":"2018-06-10","title":"量子コンピュータに入門してるその3 量子探索アルゴリズム","url":"https://KeenS.github.io/blog/2018/06/10/ryoushikonpyu_taninyuumonshiterusono3_ryoushitansakuarugorizumu/"},
  {"body":"詳しい経緯は省きますがHaskellを書こうとしたらghc-modが新しいマシンに入ってなく、新規に入れようとしたら躓いたので解決方法をネットの海に投げておきます。\ncabalを使うと解決しそうな気がしますがdependency hellはもう懲り懲りなのでstackしか使わない縛りでやってます。\n2018-06-05 追記: タイトルを直しました。URLは据え置きます /追記\n大本はこれなのですがこのパッチの影響でさらにで1行だけ変更が入ります。\nまず、コマンド一発でインストールとかはあきらめましょう。ソースコードをビルドします。しかしそれですら難易度が高いのでここで解説してます。\n1. ghc-modのghc802ブランチを用意 $ git clone git@github.com:ariskou/ghc-mod.git -b ghc802  2. cabal-helperをチェックアウト えーcabalーと思いましたがライブラリとして使ってるみたいなので問題なさそう？\n$ git clone https://github.com/DanielG/cabal-helper.git  3. ghc-modのディレクトリに移動 $ cd ghc-mod  4. stack.yamlを作成 内容はこれ。\nresolver: lts-10.0 packages: - location: . - location: ./core # \u0026lt;- この行が元のコメントとの差分 - location: ../cabal-helper extra-dep: true extra-deps: - extra-1.5.3 - monad-journal-0.7.2 - optparse-applicative-0.13.2.0 - unix-compat-0.4.3.1 - either-4.4.1.1 flags: {} extra-package-dbs: [] 5. インストール $ stack install  これで完了。因みにstackのバージョンは1.7.1です。\n","categories":["Haskell"],"category_urls":["/categories/haskell"],"date":"2018-06-03","title":"ghc-modのインストールが難しかった","url":"https://KeenS.github.io/blog/2018/06/03/haskell_stacknoinsuto_rugamuzukashikatta/"},
  {"body":"κeenです。前回に引き続き量子コンピュータと量子通信を読んでいます。 今回は5章の量子フーリエ変換。勉強中の身で自分の理解を書いているのでみなさん内容は一切信用しないでくださいね。\n$ \\def\\bra#1{\\mathinner{\\left\\langle{#1}\\right|}} \\def\\ket#1{\\mathinner{\\left|{#1}\\right\\rangle}} \\def\\braket#1#2{\\mathinner{\\left\\langle{#1}\\middle|#2\\right\\rangle}} $\nフーリエ変換達 みんな大学の授業でやったフーリエ変換…って書こうとしたけど習った記憶がない。 いや、もちろん波動の授業ではやったけどああいういい加減な授業でなくてゃんとした習い方をしてない気がする。 まあ、おおざっぱには「周期関数は三角関数の和でかける」ってやつですね。\n離散フーリエ変換変換はその離散版。 $N$ 個の点で標本をとるものです。\n\\[ F(t) = \\frac{1}{\\sqrt{N}}\\sum^{N-1}_{x=0} f(x) e^{-2\\pi{}i\\frac{tx}{N}} \\]\nの式で表されます。 $e^{-2\\pi{}i}$ の有理数乗なので心の目で三角関数が見えると思います。 ここで、 $x$ が $0$ から $N-1$ まで1刻みと決まっているので$f(x)$ は予め計算してベクトルか数列かなにかにしておくことができます(雑)。 これを $\\{x_n\\}_{n \\in \\{0, \\cdots, N - 1\\}}$ で表すことにすると\n\\[ F(t) = \\frac{1}{\\sqrt{N}}\\sum^{N-1}_{j=0} x_j e^{-2\\pi{}i\\frac{jt}{N}} \\]\nとも書けます。実用上 $\\{x_n\\}$ を復元するには $N$ 個の点の値が知れればいいので$F(t)$も$N$個あればよく、 $k \\in \\{0,\\cdots,N-1\\}$に対して\n\\[ y_k = \\sum^{N-1}_{j=0} x_j e^{-2\\pi{}i\\frac{jk}{N}} \\]\nがよく使う形になります。\nそして量子フーリエ変換は正規直行基底$\\ket{0}, \\cdots ,\\ket{N-1}$ 上の状態 $\\sum^{N-1}_{j=0}x_j\\ket{j}$ の各係数$x_j$を離散フーリエ変換したもの、すなわち\n\\[ \\sum^{N-1}_{j=0}x_j\\ket{j} \\to \\sum^{N-1}_{k=0}y_k\\ket{k} \\]\nですが各基底がどう変換されるのかを表示した方がわかりやすいようです。それがこちら。\n\\[ \\ket{j} \\to \\frac{1}{\\sqrt{N}}\\sum^{N-1}_{k=0} e^{-2\\pi{}i\\frac{jk}{N}}\\ket{k} \\]\n整数値 $j$ を位相にエンコードしてるイメージですね。\nこの変換はユニタリーなので(演習5.1)逆変換が存在します。 量子計算は観測以外が可逆なので簡単に逆変換が構成できるんですね。 計算アルゴリズムを与えたら回路の随伴をとればよし。計算量(ゲート数)も変わらないので解析がしやすいですね。\nフーリエ変換は整数値を位相にエンコードするものですから逆変換は位相を整数値にデコードできるということになります。 位相といえばユニタリ行列の固有値。望ましい位相を持つユニタリを作って掛け回して量子フーリエ逆変換をすれば欲しい値が求められます。\n位相推定 量子フーリエ逆変換の使い方の1つが位相推定で、ユニタリ行列の固有値の位相を得ることができます。 もちろん、位相は連続値を取るのに対して量子レジスタは有限長で離散値をとるので離散化に伴う誤差が生じます。\nこの位相をフーリエ逆変換に掛けられる形にエンコードする方法が面白かったので紹介します。\n逆変換なので先の式の左右が入れ替わります。\n\\[ \\frac{1}{\\sqrt{N}}\\sum^{N-1}_{k=0} e^{-2\\pi{}i\\frac{jk}{N}}\\ket{k} \\to \\ket{j} \\]\nここでで$\\phi = -2\\pi{}i\\frac{j}{N}$とおくと\n\\[ \\frac{1}{\\sqrt{N}}\\sum^{N-1}_{k=0} e^{\\phi{}k}\\ket{k} \\to \\ket{j} \\]\nとなります。$\\frac{1}{\\sqrt{N}}\\sum^{N-1}_{k=0} \\ket{k}$ は重ね合わせ状態で、Hadamardゲートで簡単に作れるのであとは$k$が与えられたときに$e^{\\phi{}k}$を計算する手段さえあれば左辺の式を簡単に作れます。 これは$U\\ket{u} = e^{\\phi}\\ket{u}$ なるユニタリ $U$、固有値 $e^{\\phi}$、固有ベクトル$\\ket{u}$ を用いて $U^k\\ket{u} = e^{\\phi{}k}\\ket{u}$のように構成できます。\n(ツール表現力の問題でわかりにくいですが$q0$はn - qubitのレジスタ、制御 $U^k$ は $q0$から$k$を読み取って$U^k$を計算する、の意味です)\n重ね合わせ状態ってこうやって使うんだな〜と感動しました。\n因みにこの$U^j$を求めるのは、量子フーリエ変換も同様なのですが、qubit数に対して多項式ゲート数で可能です。n個のqubitで表現できる数は$2^n$までなので非常に効率的ですね。 「2進表記で$n$桁目が1ならば$2^{n-1}$足す、0ならば何もしない」が制御演算でできるので重ね合わせ状態のまま計算できるのが効いてるんですかね。\n応用: 周期関数とか フーリエ変換なのである種の周期関数の周期を発見できます。たとえば互いに素な$x$と$N$に対して\n\\[ x^r \\equiv 1 \\pmod{N} \\]\nを満たすような最小の正整数$r$を見つけることができます(こういう$r$を位数といいますね)。 これの周期性は$f(n) = x^n \\pmod{N}$とすれば$f(n+r) = x^{n+r} \\pmod{N} = x^n \\pmod{N} = f(n)$から分かるかと思います。 教科書にはこれを量子フーリエ逆変換で求めるために周期$r$の計算を作ったり(剰余指数化)$r$に依存せずに固有ベクトルの和を作ったり(演習5.13)(正n角形の重心は原点みたいな話)観測した位相から$r$を復元したり(連分数展開)、と回路の構築に必要な構成方法が載っています。\nさらに、位数が効率的に分かるならばそれをオラクル的に扱って古典的アルゴリズムで素因数分解が可能です(shorのアルゴリズム)。\n他にも量子フーリエ逆変換で離散対数問題を解けたりだとか。より一般には隠れ部分群問題が解けます。 教科書では剰余類とか部分群とか難しそうな話をしてますが要は単純な(周期内では単射な)周期関数の周期を見つけられるというステートメントですかね。κeenは物事を単純化して捉えがちなので群論によるステートメントの方が周期関数によるステートメントより一般的かもしれませんがよく分からないです。\n感想 4章までではユニタリ変換で生じる位相は全体位相だから消えてしまうのではないかと思っていたが位相推定のところでと制御演算を使うと$\\ket{1}$のときにのみ位相がずれるので$\\ket{0}+\\ket{1}$が$\\ket{0}+e^\\phi\\ket{1}$になるのに気づいて意味を理解した。同時に制御演算は制御に使う方のレジスタは変化しないと思っていたが「$\\ket{1}$の場合のみ位相がずれる」という形でフィードバックを受けるのも新鮮だった。本当は4章で理解しておくべき内容だった気がするが…。\n最初は位数発見問題とかは何をやってるのかあまり理解していなかったがこのブログにまとめるうちに理解できた。 5章は演習問題は紙には解かずに頭の中で考えるだけにしたが読むのは格段に速くなった。しかしプログにまとめるのが遅くなった。この辺うまくバランスを取りたい。\nその他 $x^r \\equiv 1 \\pmod{N}$のレンダリングがキモいんですがそういうものですか？\n追記\n(mod N)は \\pmod{N}と書けば綺麗になるはずです\n\u0026mdash; koba(社畜化待ったなし) (@kobae964) 2018年5月19日 \n/ 追記\n文章内でケットを表記するにあたって以下の記事を参考にしました。yyuさんありがとうございます。\nQiitaでディラック記法を綺麗に表示する方法\n","categories":["量子コンピュータ"],"category_urls":["/categories/%e9%87%8f%e5%ad%90%e3%82%b3%e3%83%b3%e3%83%94%e3%83%a5%e3%83%bc%e3%82%bf"],"date":"2018-05-18","title":"量子コンピュータに入門してるその2 量子フーリエ変換","url":"https://KeenS.github.io/blog/2018/05/18/ryoushikonpyu_taninyuumonshiterusono2_ryoushifu_riehenkan/"},
  {"body":"κeenです。ただの日記。初心者が自作マシンを組む時のメモ。\nなぜ自作マシンか。一番大きな理由はやってみたかったから。工作って楽しいよね。 あとはRyzenが評判いいので試してみたかったから。 Rustのコンパイルが遅くて困ってるんですよ。\n秋葉原へ 知り合いに相談したらとりあえずドスパラに行くといいよと言われた。 ゴールデンウィークにドスパラへいくとRyzenどこに置いてるの、とかあんまよくわかんなくて、一旦店を出る。 他の店も見ようと思ってソフマップ、ツクモときてツクモに自作PC相談カウンターがあったのでそこで相談して買うことにした。\nRyzen 7のマシン組みたいですといったらはいはいと誘導してくれた。 どうせ7までしかないだろと思ったらThreadripperがあったので迷って一旦Threadripperで見積もりを取ることに。\nそのまま店員さんとパーツを見て回る。要件は決まってたので割とサクサク決まっていった。 電源の選び方教えてらったり(電力容量は知ってたけどピンの数とか変換効率とかあるんだね。)した。 あとThreadripperは空冷だと冷却が間に合わないらしく、簡易水冷になった。 ゲームはしない人なのでGPUにこだわりはなく知人から余ってるのをもらった、OSはUbuntuなのでフリー。 ディスプレイもどうせ黒い画面しかみないので解像度だけ高い適当なものを見繕った。 SSDはNVMeにしたかったけど予定外のThreadripperで完全に予算オーバーなのでSATAで。 Threadripperをamazon.comで買うと大分安くなって差分でNVMeにできたけどここまで相談しといて買わないのもなんなのでツクモで買ってしまった。 いつかNVMeにして今のやつをバックアップ用にしよう。\n組み立て 数学科の授業でPCを一回組み立てたことがあったのであまり心配はしてなかった。\n困ったのは\n マニュアルには電源は24pin + 8pinしか書いてなかったけど実際は + 4pin必要だった。 ケースが両面から作業するタイプで、扱いづらかった。特に電源へのアクセスが非常に悪い。 マザボの X399 Taichi が C0 エラー(メモリ関連)で起動しない。  先述の電源pinの問題やBIOSアップデートなどを試すが解決せず 結局CPUを取り付け直すと解決した。そこかー。   性能とか 元のマシンもコンパイル速度重視で買ったT440p。Core i7 4910MQの4コア 8スレッド。 今度のマシンがAMD Ryzen threadripper 1950x 16コア32スレッド。\nRustのプロジェクトのコンパイルをしてみると思ったよりコアを使い切れず1.6倍程度。\n新マシンで業務開発してるやつのcargo clean \u0026amp;\u0026amp; cargo buildが1.6倍くらいに高速化してる。今のマシンの1.5倍くらいしたしこんなものかな。\n\u0026mdash; κeen (@blackenedgold) 2018年5月12日 cargo testだったら並列性能が効いて1.8倍くらいになる\n\u0026mdash; κeen (@blackenedgold) 2018年5月12日 \nRustのコンパイル単位はクレートという大きめなもので、依存順にコンパイルされる。 最初こそ32スレッド全部使い切るもののすぐに並列度が落ちてコアを半分くらいしか使えない状態に。 まあ、CPUが余ってるので他の作業はできるけど。 特にコンパイルしながらEmacsで編集してもracerやrlsが重くならないので生産性への影響は大きい。\n最後に 日記なのでまとめとかはない。\nデスクトップマシンにするにあたってキーボードを買う必要が出たのでHappy Hacking Keyboardを買った。 5年くらいこのタイトルでブログをやってるけどようやくHappy Hacκingするようになった。\n","categories":["日記","番外編"],"category_urls":["/categories/%e6%97%a5%e8%a8%98","/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2018-05-13","title":"ツクモで自作マシン買った","url":"https://KeenS.github.io/blog/2018/05/13/tsukumodejisakumashinkatta/"},
  {"body":"κeenです。Ubuntu 18.04 LTSリリースに合わせてマシンを新調し、ついでにrootfsをRAID1にしたのでそのメモを。 因みに後述するようにブートに問題を抱えているので一般におすすめできるかは怪しいです。\n動機と構成 動機は単純で、普段あまり使わない技術を試してみたかったから。本当はRAID5をやりたかったのですがSSD2つしか用意しなかったのでRAID1で。\nUbuntuのRAID1化にはmdadmというRAID化モジュールとファイルシステムによるRAID化があるようです。 面白いことをしたかったのでmdadmではなくファイルシステムによるものを選択。それなりに多機能でかつ興味のあったbtrfsを選択しました。\n結果の構成は\n ブートローダ \u0026ndash; grub2を各ディスクに手作業でインストール / \u0026ndash; btrfsによるソフトウェアRAID1 /boot \u0026ndash; ext2 + mdadmによるソフトウェアRAID1  というようにしました。/bootはブートローダからも読めるように保守的に単純なファイルシステムにしましたが/bootまでbtrfsにする例もあるようです。\nUbuntuのインストール 公式のインストーラを使ってインストールしていきます。ここでは直接RAIDに関わることをしないので既存のシステムがある場合はここを飛ばしても構わないと思います。 インストール時点でRAID1化してしまって手間を省きたかったのですが叶わず。\n言語は日本語を選択してキーボードもそのように。インストールオプションは失敗したらやり直すので最小インストール+アップデートなしが良いでしょう\nディスク構成はカスタムにし、インストールディスクを\n ディスク1  512MB, ext2 /boot 残り全部, btrfs /  ディスク2  512MB, ext2 残り全部, btrfs   のようにします。要はRAID array全てで同じパーティション構成にします。\n残りはインストーラの導きに従ってポチポチしていきます。\nインストールが終わったら再起動しましょう。\n/bootのRAID1化 /と/bootは別々に作業した方がいいでしょう。起動しなかったときに問題の切り分けが難しいので\n作業は概ねこのエントリの通りに進めると上手く行きます。\nただし/bootしか作業しないのとfdisk相当の処理をインストーラでやってしまったでかなり簡略化されます。\nまずはUbuntuがinstallされていない方のデバイスを準備します。\n$ sudo apt install mdadm # RAID1 の準備。なんかメタデータでwarning出るけど強行突破しても問題なさそう $ sudo mdadm --create /dev/md0 --auto=yes --level=raid1 --raid-devices=2 missing /dev/sdb1 # 設定ファイルの生成 $ mdadm --detail --scan | sudo tee -a /etc/mdadm.conf # ファイルシステムの作成 $ sudo mkfs.ext2 /dev/md0 # /bootをコピーするため作成したファイルシステムをmount $ sudo mount /dev/md0 /mnt # /bootをコピー $ sudo rsync -avz -e ssh --delete /boot /mnt # 新しいファイルシステムにinitramfsをインストールするため/bootを/dev/md0に入れ替え $ sudo umount /mnt $ sudo umount /boot $ sudo mount /dev/md0 /boot # ここでfstabを編集して /boot の起動デバイスを/dev/md0にする $ vi /etc/fstab # mdadmを使った構成をブートシーケンスに反映させる $ sudo update-initramfs -u  因みにupdate-initramfsは失敗すると起動しなくなるコマンドなので盲目的に叩くのではなくて何をするコマンドなのかは調べてから使いましょう。 余談ですが私はこのタイミングで/etc/fstabのswapfsの行を削除して/swapのファイルを消しました。\nそして再起動します。\n再起動後 ここでは既にディスク2の/bootから起動しているはずです。ディスク1の/bootパーティションをこれのRAID1 Arrayに加えます。\n$ sudo mdadm /dev/md0 --add /dev/sda1  最後にgrubをインストールします。\n$ sudo install-grub2 /dev/ディスク1 $ sudo install-grub2 /dev/ディスク2 $ sudo update-grub  これで再起動して正常に起動したら/bootはmdadm化できました。\n/ のRAID化 簡単ですが鬼門です。本来ならここの通りに進めれば上手く行くはずです。\n今は / はディスク1から読まれていて、ディスク2が空いてるはずです。これにディスク2を加えます。\nbtrfsの機能を使うのですぐに終わります。\n$ sudo btrfs device add -f /dev/ディスク2 /mnt $ sudo btrfs balance start -dconvert=raid1 -mconvert=raid1 /  これだけ。\n…のはずですがinitramfsにバグがあるらしく、これだと起動時にディスク2が見つからずにエラーが出ます。 色々回避策を試行錯誤したのですが決定的なものは見つかりませんでした。一応観測した状況を書くと、\n カーネルのコマンドラインオプションに rootfstype=btrfs rootflags=device=ディスク1,device=ディスク2 と書いても起動失敗 もちろん同様にfstabをいじっても不能 initramfsに落ちた後に ディスク2を マウントしようとするとマウントできる  ディスク1だとエラー  initramfsに落ちた後にbtrfs device scan をしてからディスク1をマウントすると通る  しかしinitramsが叩くスクリプトを編集してマウント前にbtrfs device scanを発行するようにしてもエラー  grubのメニューからコマンドラインオプションをいじってroot=ディスク2とすると起動する  ディスク1だとエラー   ということで今安定して起動できる方法は「毎度grubのメニューにいって root=ディスク2 を指定」になっています。 もうちょっとマシな方法があるやろという気もしますが私では見つけられませんでした。\n上手くいったのかいってないのかわかりませんがこれで生活してます。どうにかブートシーケンスを改善できたらまた記事を書くことにします。\nトラブルシューティングの助け grub2のメニューに遷移 デフォルトだと暗黙にメニューを飛ばしてしまいます。 Shiftを押しながら起動時するとgrubのメニューにいくようです\ninitramfsで落ちたときにbusyboxのコンソールにいく Ubuntuの紫の画面の後に黒い画面にいったときの対処方法です。\nCtrl+Alt+F6,Ctrl+Alt+F1とタイプするとコンソールにいくようです。なぜこのシーケンスなのかはよくわかってないので遷移しないときはF7とか色々試してからCtrl+Alt+F1をタイプするとコンソールにいけるようです。 因みにUbuntuはデフォルトでCtrl+Alt+Fxでコンソール間を遷移できます。\ninitramfsからrootfsにいく 適切なシーケンスを踏んでない(systemdとかを起動してない)ので修正作業用の一時処理です。\nUbuntuのインストーラでbtrfsでフォーマットすると裏で勝手に/用の@と/home用の@homeの2つのsubvolumeを作るようです。\n(initramfs) mount -o subvol=@ /dev/ディスク2 /root (initramfs) mount -o subvol=@home /dev/ディスク2 /root/home (initramfs) mount -o move /sys /root/sys (initramfs) mount -o move /proc /root/proc (initramfs) mount -o move /dev /root/dev (initramfs) chroot root bash # mdadm --assemble --scan bash # mount /dev/md0 /boot  これでfstabやgrubやinitramfsを修正できます。\n参考  非RAIDシステムのRAID化 Using Btrfs with Multiple Devices Btrfs/System Root Guide Ubuntu Weekly Recipe 第384回　Initramfsのしくみ ","categories":["Linux","Ubuntu","btrfs","RAID1"],"category_urls":["/categories/linux","/categories/ubuntu","/categories/btrfs","/categories/raid1"],"date":"2018-05-12","title":"UbuntuでrootfsをbtrfsのRAID1インストール","url":"https://KeenS.github.io/blog/2018/05/12/ubuntuderootfswobtrfsnoraid1insuto_ru/"},
  {"body":"κeenです。最近アウトプットしてないなーと思ってなんか書きます。アウトプットといってもエッセイですが。 ざっくり量子コンピュータと量子通信の4章の感想みたいな。 私の2018年注目していきたい技術に入ってるのでやってます。\n雑感 量子コンピュータと量子通信はI、II、IIIに分かれてて、4章はII巻の最初の章。なんでいきなりII巻を読んでるかというとどこかでおすすめされてるのを見たからです。 正直Iから読んだ方が良かった気がします。 II巻の全体を追うには量子コンピュータ Advent Calendar 2017のどこかの記事にある導入くらいを把握してれば済むのですが、演習問題などで詰まります。 I巻の結果を前提としていたりI巻の章の内容を受けて書かれていたりするのでI巻を持ってないとダメですね。\nところで、この本は演習問題を解くことを推奨していて、演習が本文の合間にあります。ところがその量が多く、4章だけで51問あります。最初の方は演習問題の合間に本文が書いてあるくらいの密度ですね。 はじめは割と頑張って解いてたのですが先程の前提知識の問題や普通に私の能力の問題で全然解けないこともあり、早々にあきらめてしまいました。たとえば「Hadamardゲートを$R_z$回転、$R_x$回転、およびある$\\varphi$に対する$e^{i \\varphi}$の積として表わせ(演習4.4)」という問題で1日使ったりと。 しかしまあ読み進めていくと問題密度も減っているようなので気合を入れ直して全部解いた方がいいかもしれませんね。\n面白いと思ったものとか と、愚痴めいたことはおいといて興味深い結果を書きます。私は量子コンピュータ言語向けのコンパイラに興味があるので「ユーザが好き勝手書いた高級な表現をどう低級に表現するか」「どうやってゲート数を削減するか」「どのようなプリミティブがあるとユーザは書きやすいか」などが気になります。\nゲートの結合 シンプルな例ですが\n\\[ XY = iZ; YZ = iX; ZX = iY \\]\nや\n(演習4.13)\n\\[ HXH = Z; HYH = -Y; HZH = X \\]\nなどいくつかの等式が成り立ちます。これらを用いてゲート数の削減が出来るでしょう。\nCNOT基底変換 この記事によると今の量子コンピュータ(IBM qx4)ではCNOTを取れる方向が決まっているようです。q1からq2は取れるけどq2からq1は取れないだとか。 そういうのはコンパイラが頑張って制約問題を解くのかなーと思ってました。しかしどうやらCNOT基底変換を使うとCNOTの方向をソフトウェア的に逆転できるようです。\nCNOT基底変換はこのようなものです。\nこれを計算するとCNOTのコントロールとターゲットを反転したものに等しいです(演習 4.20)。\n色々工夫があるんですね。\nユニタリ行列と近似 ハードウェアに実装されるゲートは有限種類ですが量子計算に使うユニタリ行列は連続値を取り無限にあるので両者の間にギャップがあります。 なのでゲートを何回も適用してユニタリ行列を近似する必要があります。もちろん、ハードウェアに実装されるゲートは任意のユニタリ行列を近似できる(普遍性がある)ように設計されます。\nこれは言語的にはどうなるのかなーと考えてみたところ、古典コンピュータでいうルンゲ=クッタ法で任意の微分可能関数を近似できるというのに似てるんですかね。 なので三角関数とかと同じ扱いで、いくつかの重要なユニタリ行列がライブラリで実装されるのかな？\n一歩くらい量子コンピュータ言語に近寄れた。\n余談 量子回路を載せるためにqasm2pngというのを用いたのですがcshで書かれている上に起動ディレクトリを動かせなくて不便だったのでbshで書き直しました。やっつけで作ったので荒い部分もありますがもとのcshスクリプトよりはマシです。 qasm2circをダウンロードし、 QASM_DIRをご自身のものに変えてお使い下さい。\n#!/bin/sh # templated by http://qiita.com/blackenedgold/items/c9e60e089974392878c8 usage() { cat \u0026lt;\u0026lt;HELP NAME: $0 -- convert qasm to png SYNOPSIS: $0 FILE $0 [-h|--help] $0 [--verbose] DESCRIPTION: convert qasm to png. FILE name must end with .qasm -h --help Print this help. --verbose Enables verbose mode. EXAMPLE: $ $0 foo.qasm HELP } main() { SCRIPT_DIR=\u0026#34;$(cd $(dirname \u0026#34;$0\u0026#34;); pwd)\u0026#34; while [ $# -gt 0 ]; do case \u0026#34;$1\u0026#34; in --help) usage; exit 0;; --verbose) set -x; shift;; --) shift; break;; -*) OPTIND=1 while getopts h OPT \u0026#34;$1\u0026#34;; do case \u0026#34;$OPT\u0026#34; in h) usage; exit 0;; esac done shift ;; *) break;; esac done set -e QASM_DIR=/your/path/to/original_qasm2circ source_dir=\u0026#34;$(dirname $1)\u0026#34; file_base=\u0026#34;$(basename \u0026#34;$1\u0026#34; .qasm)\u0026#34; work_dir=\u0026#34;$(mktemp -d)\u0026#34; base=\u0026#34;$work_dir/$file_base\u0026#34; work_file=\u0026#34;${base}.qasm\u0026#34; trap \u0026#34;exit 1\u0026#34; HUP INT PIPE QUIT TERM trap \u0026#34;rm -rf $work_dir\u0026#34; EXIT cp \u0026#34;$1\u0026#34; \u0026#34;$work_dir\u0026#34; python \u0026#34;$QASM_DIR/qasm2tex.py\u0026#34; \u0026#34;$work_file\u0026#34; \u0026gt; \u0026#34;${base}.tex\u0026#34; (cd \u0026#34;$QASM_DIR\u0026#34;; latex --output-directory=\u0026#34;$work_dir\u0026#34; \u0026#34;${base}.tex\u0026#34;) dvips -D2400 -E -o \u0026#34;${base}.eps\u0026#34; \u0026#34;${base}.dvi\u0026#34; gs -sDEVICE=pnmraw -r400 -dNOPAUSE -sOutputFile=\u0026#34;${base}.pbm\u0026#34; \u0026#34;${base}.eps\u0026#34; -c quit pnmcrop \u0026#34;${base}.pbm\u0026#34; | pnmtopng \u0026gt; \u0026#34;${base}.png\u0026#34; cp \u0026#34;${base}.png\u0026#34; \u0026#34;$source_dir\u0026#34; rm -rf \u0026#34;$work_dir\u0026#34; } main \u0026#34;$@\u0026#34; tex(ubuntuでいうtexliveとtexlive-pictures)依存なのでなんかさくっと作り直したいですねー。\n","categories":["量子コンピュータ"],"category_urls":["/categories/%e9%87%8f%e5%ad%90%e3%82%b3%e3%83%b3%e3%83%94%e3%83%a5%e3%83%bc%e3%82%bf"],"date":"2018-05-01","title":"量子コンピュータに入門してる","url":"https://KeenS.github.io/blog/2018/05/01/ryoushikonpyu_taninyuumonshiteru/"},
  {"body":"κeenです。寝れないので小ネタを。数年悩んでた問題がようやく解決しましたのでそれについて。\n経緯 30GBくらいのファイルのバックアップをdejadupを使って500GBのHDDに取ろうと思ったらディスクの空き領域がないって言われるんだけど何が原因なんだろう。因みにホストのSSDも500GBある。Ubuntu 16.04と16.10で起きた。\n\u0026mdash; κeen (@blackenedgold) 2016年12月3日 Ubuntuのバックアップがとれない病に掛かってるんだけどこの度17.04に上げてもダメだった。因みにバックアップデータ数十GBに対してバックアップ先は500GBと十分にある。 pic.twitter.com/vgSE8uoLtB\n\u0026mdash; κeen (@blackenedgold) 2017年4月18日 エラーメッセージの情報量が少ないので打てる手が少ないですね…。\nこのあとバックアップ用のHDDを買い替えて2TBのものを用意しましたがダメでした。 ハードの問題ではないと判明したのでUbuntuのバックアップ(ソフトウェア名はdeja-dup)のバグを疑い、しばらく放置することにしました。 流石に再現条件を割り出せてないので自らバグレポートをすることはせず、熱心な他人に委ねようという判断です。\n原因究明 最初に問題が発生してから2年くらいになりますがふと思い立って少しずつバックアップを取ったらどうかと試し始めます。\nubuntuのdejadupがバックアップに失敗する問題、ちょっとずつやれば成功するな。どこのサイズが足りてないんだろう。\n\u0026mdash; κeen (@blackenedgold) 2018年4月26日 少し進展しましたね。\nさらにここでデバッグする気力が湧いたので色々試し始めます。 top でCPU Usageをみてるとdeja-dupはただのフロントエンドでバックアップをしているのはduplicityということに気づきます。 そこで ps aux でコマンド引数を抜き出して自分の手でduplicityを操作し始めます。\nとりあえずduplicity叩いたらエラーメッセージは見えた。150Gくらいのバックアップに4TB必要と言っている。ほんまか？\n\u0026mdash; κeen (@blackenedgold) 2018年4月27日 150Gというのは du ~/ で測ったものです。そもそもUbuntuをインストールしているディスク全体でも500GBなので何か設定を間違っていたとしても流石に500GBには収まる筈。バックアップのメタデータでちょっと嵩むとしてもこれはおかしいですね。\nさらにこのあと --dry-run ではなく実際にコピーを走らせてみると、とあるファイルでずっと止まってることに気づきます。\n理解した。pijulのdbファイルが中身はほぼ空だけどサイズ上4TBあることになってた。\n\u0026mdash; κeen (@blackenedgold) 2018年4月27日 ということで犯人がわかりました。余談ですがpijulというのは新興バージョン管理システムの1つです。このファイルはpijulがバージョン0.1くらいのときに作ったもののようでした。その時のpijulはメタデータDBにひとまずでかいファイルを作るようになってたんですね。\nということでこのファイルを消して無事バックアップを取れました。\nしかし4TBのファイルを作っているのに du は 150GBと報告しました。これはどういうことなのでしょうか。これが今日のお話。\nディスク上のサイズとファイルサイズ du のマニュアルを見ると、 du は ディスク上のサイズ 、いわば物理サイズを見積もるツールだと言っています。一方 ls などでみるのは ファイルサイズ 、論理的なサイズです。 両者に違いがあるかというと、スパースファイルの場合実際のディスクサイズはずっと小さくなります。\nLinuxだと0ページ最適化してくれるから4TBあってもディスクスペースは食わないんだけどそれをtarにすると4TBのtarが出来上がるんだろうか。\n\u0026mdash; κeen (@blackenedgold) 2018年4月27日 \nということで実験しましょう(終わった後で上のArch Wikiに全部書いてることに気づきましたが気にしない)。tarが出てきたのはduplicityがフォーマットとしてtarを用いているからです。\ntruncate コマンドでファイルを無意味に伸ばすことができます(普段はファイルをサイズ0に切り詰めるコマンドですね:) )\n$ truncate -s10M file  さて、これを du と ls -l で確認してみましょう。\n$ ls -lh file -rw-r--r-- 1 kim kim 10M 4月 28 02:59 file $ du -h 4.0K .  見かけ上のサイズと実際のサイズが異なっていますね。これをtarballにしてみましょう。\n$ tar cf file.tar file $ ls -lh 合計 11M -rw-r--r-- 1 kim kim 10M 4月 28 02:59 file -rw-r--r-- 1 kim kim 11M 4月 28 03:00 file.tar $ du -h 11M .  tarballにすると本来のサイズに膨らむことがわかりました。\nそしてArch Wikiによると tar はオプションでsparse fileを扱えるようなのでそれも実験してみましょう。\n$ rm file.tar $ tar Scf file.tar file $ ls -lh 合計 11M -rw-r--r-- 1 kim kim 11M 4月 28 03:00 --sparse -rw-r--r-- 1 kim kim 10M 4月 28 02:59 file -rw-r--r-- 1 kim kim 10K 4月 28 03:01 file.tar $ du -h 16K . 本当に小さくなってますね。\nまとめ  ext4などのファイルシステムはsparse fileを効率的に保存してるよ duがデフォルト表示するのはディスク上のサイズであってファイルサイズではないよ sparse fileを上手く扱えないとバックアップが元のディスクサイズより巨大になることがあるよ ","categories":["Linux","小ネタ"],"category_urls":["/categories/linux","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2018-04-28","title":"Ubuntuでバックアップが失敗する話、あるいはディスクサイズとファイルサイズについて","url":"https://KeenS.github.io/blog/2018/04/28/ubuntudebakkuappugashippaisuruhanashi_aruihadisukusaizutofairusaizunitsuite/"},
  {"body":"κeenです。やや釣りっぽいタイトルですがRustのデータ並列ライブラリのrayonについて。イテレータを並列に計算できるだけでなくjoinで自分で並列処理を書くこともできるんだよという記事です。\nrayonとpar_iter rayonはRustのデータ並列ライブラリです。あの化学繊維のレーヨンです。Thread(糸)にちなんだ名前なんですかね。\nrayonで一番良く使われるのはpar_iterでしょう。このように使えます。\nuserayon::prelude::*;letvec=vec![1,2,3,4,5,6];// _par_iter でデータ並列計算 letmax=vec.par_iter().max();assert_eq!(max,Some(6)); このようにほぼRustのイテレータを置き換える形で使えます。\nその反面、イテレータらしい処理でないとpar_iterは使えません。 たとえば次のminとmaxを同時に求めるアルゴリズムはどうでしょう。 要素を同時に2つ取って、大小の区別をつけてからmin、maxと比較するのでminとmaxを個別に求めるのに比べて比較回数が3/4くらいになります。 しかし同時に2つ取るのでidiomaticなイテレータからは外れてしまいます。\nfn main(){letvec=vec![1,2,3,4,5,6];let(min,max)=min_max(\u0026amp;vec);assert_eq!(min,Some(\u0026amp;1));assert_eq!(max,Some(\u0026amp;6));}fn min_max\u0026lt;T: Ord\u0026gt;(v: \u0026amp;[T])-\u0026gt; (Option\u0026lt;\u0026amp;T\u0026gt;,Option\u0026lt;\u0026amp;T\u0026gt;){ifv.is_empty(){return(None,None);}else{let(min,max)=min_max_(v);(Some(min),Some(max))}}fn min_max_\u0026lt;T: Ord\u0026gt;(v: \u0026amp;[T])-\u0026gt; (\u0026amp;T,\u0026amp;T){usestd::cmp;debug_assert!(0\u0026lt;v.len());letmutiter=v.iter();letmutmin;letmutmax;ifv.len()%2==0{min=iter.next().unwrap();max=iter.next().unwrap();}else{min=iter.next().unwrap();max=min;}whileletSome(a)=iter.next(){letb=iter.next().unwrap();let(small,large)=ifa\u0026lt;b{(a,b)}else{(a,b)};min=cmp::min(min,small);max=cmp::max(max,large);}(min,max)} このアルゴリズムはrayonのイテレータでは記述出来ないでしょう。 こういうときにデータ並列操作を自分で書けるのがjoinです。\njoin par_iterが高レベルAPIなのに対してjoinはカスタムジョブを書くためのAPIとされています。以下のような型シグネチャを持つ関数です。\npub fn join\u0026lt;A, B, RA, RB\u0026gt;(oper_a: A, oper_b: B) -\u0026gt; (RA, RB) where A: FnOnce() -\u0026gt; RA + Send, B: FnOnce() -\u0026gt; RB + Send, RA: Send, RB: Send, 少しややこしいですが、普通のスレッドのspawnのように新たなタスクを始める関数です。ただし引数に処理関数を2つ取ります。このシグネチャから「タスクを半分に分割しなさい。そうすればそれぞれを並列に解くことが出来ます。」というメッセージが伝わりますね。\n今回のmin_maxの例でいくとまずスライスを半分に分割し、それぞれでmin_maxを求めたあとでmin同士、max同士を比べるとよさそうです。こうなるでしょうか。\nfn main(){letvec=vec![1,2,3,4,5,6];let(min,max)=min_max_rayon(\u0026amp;vec);assert_eq!(min,Some(\u0026amp;1));assert_eq!(max,Some(\u0026amp;6));}fn min_max_rayon\u0026lt;T: Ord +Send+Sync\u0026gt;(v: \u0026amp;[T])-\u0026gt; (Option\u0026lt;\u0026amp;T\u0026gt;,Option\u0026lt;\u0026amp;T\u0026gt;){matchv.len(){0=\u0026gt;(None,None),1=\u0026gt;(Some(\u0026amp;v[0]),Some(\u0026amp;v[0])),_=\u0026gt;{let(min,max)=min_max_rayon_(v);(Some(min),Some(max))}}}fn min_max_rayon_\u0026lt;T: Ord +Send+Sync\u0026gt;(v: \u0026amp;[T])-\u0026gt; (\u0026amp;T,\u0026amp;T){usestd::cmp;debug_assert!(1\u0026lt;v.len());matchv.len(){2=\u0026gt;{leta=\u0026amp;v[0];letb=\u0026amp;v[1];ifa\u0026lt;b{(a,b)}else{(b,a)}}_=\u0026gt;{fn doit\u0026lt;T: Ord +Send+Sync\u0026gt;(v: \u0026amp;[T])-\u0026gt; (\u0026amp;T,\u0026amp;T){letmid=matchv.len()%4{0=\u0026gt;v.len()/2,2=\u0026gt;v.len()/2+2,_=\u0026gt;unreachable!(),};let((min1,max1),(min2,max2))=// ここで `rayon::join` を用いている rayon::join(||min_max_rayon_(\u0026amp;v[..mid]),||min_max_rayon_(\u0026amp;v[mid..]));(cmp::min(min1,min2),cmp::max(max1,max2))}ifv.len()%2==1{lett=\u0026amp;v[0];letv=\u0026amp;v[1..];let(min,max)=doit(v);(cmp::min(t,min),cmp::max(t,max))}else{doit(v)}}}} コメントに書きましたが rayon::join(|| min_max_rayon_(\u0026amp;v[..mid]), || min_max_rayon_(\u0026amp;v[mid..])); が今回の核心です。ほとんど並列を意識させずにコードを書けていますね。 事実 (min_max_rayon_(\u0026amp;v[..mid]), min_max_rayon_(\u0026amp;v[mid..])) のようにただのタプルにしても結果は変わりません。\njoinと再帰とWork Stealing rayon::join(|| min_max_rayon_(\u0026amp;v[..mid]), || min_max_rayon_(\u0026amp;v[mid..]));をよく見ると再帰呼び出ししています。すると再帰先でもまたjoinを呼び、今回の基底ケースはv.len() == 2なので 100万要素のスライスに対して50万個のタスクができることになります。 素直に50万個のスレッドを作るわけにもいきませんしシンプルなジョブキューを作っても50万回の排他ロックはとてつもなく遅いでしょう\n// 1タスクスレッドは重すぎる [Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread][Thread]....// キューでもロックが遅い |---|\u0026#39;,||||---|||.|50万|.|||---||||,\u0026#39;+---+\u0026gt;lock\u0026lt;........................[Thread][Thread][Thread][Thread][Thread] rayonが採用しているのはWork Stealingです。他の言語でも使われているのでご存知の方も多いでしょう。 私は元論文は読んだことはないのですが興味のある方は目を通してみて下さい。ここではスピリチュアルに説明します。 まず、各スレッドが各自のDequeを持っています。\n||||||||+---++---++---++---+||||||||+---++---++---++---+||||||||+---++---++---++---+||||[Thread][Thread][Thread][Thread] このうちの1つのスレッドの動きに着目しましょう。 最初は大きなJobがいます。\n+---+|100|+---+|[Thread] このタスクを実行すると先程のmin_maxのようにjoinを使うと半分に分割されますね。 それは1つは即座に実行、もう一つはDequeにpush_frontされます。\n+---+|50|+---+|+---+|50|+---+[Thread] これを何度か繰り返します。再帰しているので小さなタスクが手前にきます。\n+---+|50|+---+|26|+---+|12|+---+|6|+---+|+---+|6|+---+[Thread] ここまでは全て自分のスレッド内での作業なのでロックは必要ありません。 ここで何か他のスレッドが全てのタスクを終えて空いているとしましょう\n+---+|50|+---+|26|+---+|12|+---+|6|+---+|+---+|||6|+---++---+|[Thread1][Thread2] するとThread2はThread1からJobを奪います。奪うのは一番後ろ、50です。これは他のたとえばThread3も同じように奪いに来る可能性もあるのでロックを取ります。\n\u0026gt;lock\u0026lt;-----++---+||26||+---+||12||+---+||6||+---+v|+---++---+|50||6|+---++---+|[Thread1][Thread2] これでロックを出来る限り少なく、一番大きなタスクを他のスレッドに渡すことができました。 このようにrayonはrayon::joinと再帰呼出しに向いたスケジューリングを採用しています。\njoin と scope rayonにはカスタムjobのためのAPIとしてjoinの他に scopeも用意されています。こちらは2つとは限らずに好き勝手タスクをspawnできるので自由度が高いです。なんならscopeを用いてjoinを実装することも可能です。\nしかし可能な限りjoinの方を使えとあります。joinの方がWork Stealingに合わせたAPIなのでこっちの方が内部実装が高速だとのこと。 上記の通り恐らくrayonはWork Stealingを前提に作られているのでjoinが本体でscopeは副産物なのでしょう。\nベンチマーク さて、並列というものはby definitionで速くないといけません。ベンチマークをとりましょう。\nnightlyの機能のベンチマークを使います。また、適当な配列を用意するのにrandを使い、このような関数で実装します。\nexterncraterand;fn random_vec(n: usize)-\u0026gt; Vec\u0026lt;i32\u0026gt;{letmutrng=rand::thread_rng();(0..n).into_iter().map(|_|rng.gen::\u0026lt;i32\u0026gt;()).collect()} これを用いて以下のようにベンチマークをとります。実行するのは4コア8スレッドのIntel\u0026reg; Core\u0026trade; i7-4910MQ CPU @ 2.90GHzです。\n#[bench]fn bench_min_max(b: \u0026amp;mutBencher){letv=random_vec(1024*1024*32);b.iter(||min_max(\u0026amp;v))}#[bench]fn bench_min_max_rayon(b: \u0026amp;mutBencher){letv=random_vec(1024*1024*32);b.iter(||min_max_rayon(\u0026amp;v))} 結果は\n$cargo+nightlybenchtestbench_min_max...bench: 2,001,679ns/iter(+/-236,508)testbench_min_max_rayon...bench: 5,608,823ns/iter(+/-1,225,619) なんとrayonを使ったほうが遅いです。\n詳細なグラフはこちら。\n これは第一にrayon化するだけでどうやらオーバーヘッドが乗るから。もう一つに、いくらwork stealingとはいえ毎度jobを作っているとバカにならないコストが発生するからです。 なのである程度のサイズ以下になったらmin_max_rayonにスイッチするとよいでしょう。\nmin_max_rayon_の\nmatchv.len(){2=\u0026gt;{leta=\u0026amp;v[0];letb=\u0026amp;v[1];ifa\u0026lt;b{(a,b)}else{(b,a)}}_=\u0026gt;{ の部分を\nifv.len()\u0026lt;=8192{min_max_(v)}else{ に書換えます。この8192というのは私の手元のベンチマークに合わせてチューニングした結果です。 どうしてもrayonに載せるだけでそれなりにオーバーヘッドがかかるので並列化がペイするためにはそれなりに大きくないといけなくなります。\nこうするとぐっと速くなって\ntestbench_min_max...bench: 1,982,283ns/iter(+/-124,381)testbench_min_max_rayon...bench: 412,036ns/iter(+/-89,327) と大体(/ 1982283.0 412036.0) = 4.9倍速くなってますね。\n join と分割統治 joinの素晴らしい点は思考のフレームワークにもなっている点です。 小さな問題に分割して解いて、その解を組み合わせて全体の問題を解く。分割統治って言うらしいです。 クイックソートやマージソートがよく知られる例ですね。私はアルゴリズムに詳しいわけでは無いので細かな点は近日中にネットに出没するらしい詳しい記事に譲るとします。\nこの例の他にはたとえば最大上位者数問題、つまり全ての要素の中での「自身より右側にあって自身より大きい要素の数(上位者数)」の最大値を求める問題は素朴にはこう書けます。\nfn msc\u0026lt;T: PartialOrd +Send+Sync\u0026gt;(v: \u0026amp;[T])-\u0026gt; usize {v.iter().enumerate().map(|(n,t)|scount(t,\u0026amp;v[n..])).max().unwrap()}fn scount\u0026lt;T: PartialOrd +Send+Sync\u0026gt;(t: \u0026amp;T,v: \u0026amp;[T])-\u0026gt; usize {v.iter().filter(|s|t\u0026lt;s).count()} これは $O(n^2)$ の計算量を持ちますがこれをうまく分割統治統治すると $O(n \\log n)$ で求められます。\nfn msc_divide\u0026lt;T: PartialOrd +Send+Sync\u0026gt;(v: \u0026amp;[T])-\u0026gt; usize {table(v).into_iter().map(|(_,n)|n).max().unwrap()}fn table\u0026lt;T: PartialOrd +Send+Sync\u0026gt;(v: \u0026amp;[T])-\u0026gt; Vec\u0026lt;(\u0026amp;T,usize)\u0026gt;{ifv.len()==1{vec![(\u0026amp;v[0],0)]}else{letmid=v.len()/2;letxs=\u0026amp;v[0..mid];letys=\u0026amp;v[mid..];letxs=table(xs);letys=table(ys);join(\u0026amp;xs,\u0026amp;ys)}}fn join\u0026lt;\u0026#39;a,\u0026#39;v,T: PartialOrd +Send+Sync\u0026gt;(mutxs: \u0026amp;\u0026#39;a [(\u0026amp;\u0026#39;vT,usize)],mutys: \u0026amp;\u0026#39;a [(\u0026amp;\u0026#39;vT,usize)],)-\u0026gt; Vec\u0026lt;(\u0026amp;\u0026#39;vT,usize)\u0026gt;{letmutv=Vec::new();loop{ifys.is_empty(){v.extend(xs);returnv;}elseifxs.is_empty(){v.extend(ys);returnv;}else{letxt=\u0026amp;xs[0];letyt=\u0026amp;ys[0];ifxt.0\u0026lt;yt.0{v.push((xt.0,xt.1+ys.len()));xs=\u0026amp;xs[1..];}else{v.push(yt.clone());ys=\u0026amp;ys[1..];}}}} このコードはほぼストレートにtableをrayon化できるのは見て取れるでしょう。 良いアルゴリズムと良い並列化が両立するのは素晴らしいですね。\nまとめ  rayonにはpar_iter以外にもjoinがあるよ joinを使うといろんなアルゴリズムを並列化出来るよ  ただし無闇に並列化すると遅くなるから注意  joinと分割統治は相性がいいよ  ノート  このブログの大半の内容はrayonの作者による解説でカバーされています。 min_max の例はアルゴリズムイントロダクションから採りました 最大上位者数問題は関数プログラミング 珠玉のアルゴリズムデザインから採りました 今回用いたコードはこちらにあります。 以下にチューニングの結果を示します。閾値を小さくするとオーバーヘッドが無視出来ず、大きくすると並列性能が出ないことが見て取れると思います。 データが多くて見づらいですがラベルをクリックするとデータ毎に表示/非表示を切り替えられるので色々比べてみて下さい。   余談 因みにですが個別にminとmaxで求めたものと比べると\nconstN: usize =1024*1024;#[bench]fn bench_min_and_max(b: \u0026amp;mutBencher){letv=random_vec(N);b.iter(||(v.iter().min(),v.iter().max()))}#[bench]fn bench_min_max(b: \u0026amp;mutBencher){letv=random_vec(N);b.iter(||min_max(\u0026amp;v))}#[bench]fn bench_min_and_max_rayon(b: \u0026amp;mutBencher){userayon::prelude::*;letv=random_vec(N);b.iter(||(v.par_iter().min(),v.par_iter().max()))}#[bench]fn bench_min_max_rayon(b: \u0026amp;mutBencher){letv=random_vec(N);b.iter(||min_max_rayon(\u0026amp;v))} なんと全体的にはminとmaxを個別に求めた方が速い結果になりました。\ntestbench_min_and_max...bench: 593,406ns/iter(+/-21,954)testbench_min_and_max_rayon...bench: 416,664ns/iter(+/-68,554)testbench_min_max...bench: 1,982,283ns/iter(+/-124,381)testbench_min_max_rayon...bench: 412,036ns/iter(+/-89,327) min_max_rayonは辛勝…。\n 色々試すとどうやらループの中でifを使ってるのが遅いらしく、ループ内のifを取り除いたら、つまり比較演算の削減を諦めてmin, maxを個別に求めるのと変わらないループを書くと速くなりました。不思議…。 別にイテレータのminやmaxがSIMDを生成していたとかではなくて、単に生成されるコードの品質の問題でした。\n var labels = []; for(var i = 0; i { config.data.datasets.push({ label: data.label, backgroundColor: data.color, borderColor: data.color, data: data.data, fill: false }); }) return config } var vanilla_vs_rayon = document.getElementById('vanilla_vs_rayon').getContext('2d'); new Chart(vanilla_vs_rayon, genConfig(\"min_max vs min_max_rayon\", [ { label: 'min_max_rayon', color: 'rgb(256, 128, 128)', data: [1, 4969, 6263, 8260, 10238, 11591, 13227, 15180, 17157, 23007, 33231, 47599, 75734, 133570, 241004, 421043, 804201, 1572861, 3136177, 5995852], }, { label: 'min_max', color: 'rgb(128, 128, 256)', data: [0, 2, 5, 9, 21, 39, 73, 144, 289, 686, 3740, 8591, 17501, 42219, 69543, 135583, 275131, 530968, 1019684, 1976327], } ])); var vanilla_vs_rayon_tuned = document.getElementById('vanilla_vs_rayon_tuned').getContext('2d'); new Chart(vanilla_vs_rayon_tuned, genConfig(\"min_max vs min_max_rayon(チューニング後)\", [ { label: 'min_max_rayon', color: 'rgb(256, 128, 128)', data: [1, 2, 6, 10, 18, 35, 70, 139, 277, 632, 2252, 6758, 15635, 46270, 47309, 51649, 83701, 152410, 275619, 532008], }, { label: 'min_max', color: 'rgb(128, 128, 256)', data: [0, 2, 5, 9, 21, 39, 73, 144, 289, 686, 3740, 8591, 17501, 42219, 69543, 135583, 275131, 530968, 1019684, 1976327], } ])); var rayon_thresholds = document.getElementById('rayon_thresholds').getContext('2d'); new Chart(rayon_thresholds, genConfig(\"thresholdを変えたときのmim_max_rayonのパフォーマンス\", [ { label: '2', data: [1, 4969, 6263, 8260, 10238, 11591, 13227, 15180, 17157, 23007, 33231, 47599, 75734, 133570, 241004, 421043, 804201, 1572861, 3136177, 5995852] }, { label: '4', data: [1, 2, 5377, 6789, 7559, 9979, 11886, 13038, 14988, 18823, 23705, 31624, 53671, 92329, 161459, 279781, 547332, 1029873, 2043434, 3989602] }, { label: '0000008', data: [2, 2, 6, 5718, 7489, 8650, 11075, 12323, 13605, 15674, 18473, 25299, 34824, 55843, 99329, 188902, 341966, 648656, 1258574, 2354102] }, { label: '0000016', data: [2, 3, 6, 11, 5370, 6605, 8975, 11009, 11961, 13482, 16042, 19543, 27623, 42773, 73452, 136375, 242573, 449895, 894581, 1711311] }, { label: '0000032', data: [2, 3, 7, 16, 23, 8106, 7789, 10858, 11720, 12659, 13847, 16564, 22043, 31661, 54789, 93711, 162402, 311356, 599225, 1264995] }, { label: '0000064', data: [1, 3, 6, 13, 25, 42, 7565, 8450, 11010, 12113, 13547, 15418, 19406, 28498, 45491, 74264, 130119, 229457, 423164, 816093] }, { label: '0000128', data: [1, 2, 6, 13, 19, 37, 72, 5739, 9677, 11677, 12904, 14111, 17413, 23945, 36427, 56699, 105557, 187037, 355136, 652626] }, { label: '0000256', data: [1, 3, 7, 13, 22, 58, 110, 184, 12032, 11574, 12861, 14554, 16853, 22186, 32045, 49191, 90558, 163303, 307767, 593919] }, { label: '0000512', data: [1, 2, 6, 12, 19, 37, 73, 141, 284, 7833, 10931, 12553, 15002, 20304, 29863, 47826, 79071, 144858, 272874, 531286] }, { label: '0001024', data: [1, 2, 5, 11, 20, 35, 95, 184, 390, 698, 18329, 19275, 18980, 23640, 34736, 56762, 96810, 164784, 302074, 584485] }, { label: '0002048', data: [1, 3, 5, 13, 23, 41, 81, 162, 347, 645, 2011, 17156, 16931, 19250, 28485, 44241, 76107, 132698, 252528, 491360] }, { label: '0004096', data: [1, 2, 5, 9, 19, 51, 86, 173, 343, 687, 3225, 7011, 29425, 29276, 31519, 48384, 81598, 150722, 277016, 540963] }, { label: '0008192', color: 'rgb(256, 128, 128)', data: [1, 2, 6, 10, 18, 35, 70, 139, 277, 632, 2252, 6758, 15635, 46270, 47309, 51649, 83701, 152410, 275619, 532008] }, { label: '0016384', data: [1, 2, 6, 11, 20, 42, 84, 157, 312, 617, 2341, 6095, 14035, 30036, 64901, 68928, 76370, 138835, 243741, 473987] }, { label: '0032768', data: [1, 2, 5, 11, 18, 35, 70, 139, 282, 588, 2380, 7300, 16692, 37347, 73819, 182132, 168316, 155573, 353786, 565423] }, { label: '0065536', data: [1, 3, 6, 10, 21, 40, 79, 162, 294, 611, 2040, 6633, 13929, 30203, 63107, 121916, 226008, 246603, 244836, 482809] }, { label: '0131072', data: [1, 2, 5, 11, 19, 35, 69, 137, 274, 624, 2241, 6736, 14389, 30630, 63357, 124594, 250942, 395238, 466010, 481440] }, { label: '0262144', data: [1, 2, 5, 10, 18, 36, 71, 140, 280, 559, 2211, 6056, 14412, 30083, 61307, 125313, 251839, 519617, 751774, 979082] }, { label: '0524288', data: [1, 2, 5, 12, 21, 38, 77, 144, 294, 609, 2311, 6007, 13846, 30177, 69691, 144964, 275105, 545024, 1060201, 1353068] }, { label: '1048576', data: [1, 2, 5, 10, 18, 36, 77, 156, 303, 606, 1740, 5905, 14085, 29457, 63666, 130469, 260893, 518881, 986104, 2013271] }, ])); var min_and_max_vs_min_max = document.getElementById('min_and_max_vs_min_max').getContext('2d'); new Chart(min_and_max_vs_min_max, genConfig(\"min_and_max, min_and_max_rayon, min_max, min_max_rayon\", [ { label: 'min_max_rayon', color: 'rgb(256, 128, 128)', data: [1, 2, 6, 10, 18, 35, 70, 139, 277, 632, 2252, 6758, 15635, 46270, 47309, 51649, 83701, 152410, 275619, 532008], }, { label: 'min_max', color: 'rgb(128, 128, 256)', data: [0, 2, 5, 9, 21, 39, 73, 144, 289, 686, 3740, 8591, 17501, 42219, 69543, 135583, 275131, 530968, 1019684, 1976327], }, { label: 'min_and_max_rayon', color: 'rgb(256, 64, 64)', data: [9116, 11592, 16563, 20167, 22646, 33490, 37236, 38469, 41873, 44973, 47956, 51669, 59828, 69602, 82043, 107234, 150433, 203012, 309735, 496755], }, { label: 'min_and_max', color: 'rgb(64, 64, 256)', data: [2, 5, 7, 12, 20, 36, 68, 136, 279, 559, 1102, 2180, 4366, 9030, 18182, 35873, 71861, 144179, 293551, 580270], } ])); ","categories":["Rust","rayon","アルゴリズム"],"category_urls":["/categories/rust","/categories/rayon","/categories/%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0"],"date":"2018-04-08","title":"rayonの真価は分割統治にアリ","url":"https://KeenS.github.io/blog/2018/04/08/rayonnoshinkahabunkatsutouchiniari/"},
  {"body":"κeenです。 RustはたとえばBoxを使っていても必ずしもヒープにアロケートされる訳ではないなど、メモリの扱いを多少最適化してるらしいです。 しかし何がどう最適化されるのかは実際にコードを書いてみて実験しないとわからないことが多いので実験してみます。\nrust 1.25.0です。\ncargo asm 実験の前にツールを紹介します。cargo asmです。 クレートの関数名を指定するとディスアセンブルしてくれます。\nたとえば\npubfn add(x: i32,y: i32)-\u0026gt; i32 {x+y} という関数をsome_crateに用意すれば以下のようにディスアセンブルできます。\n$ cargo asm some_crate::add some_crate::add: lea eax, [rdi, +, rsi] ret  ここでは味気ないですがコンソール上では色がついています。 因みにデフォルトでreleaseビルドのものが使われます。\ncargoプロジェクトを作らないといけないのでやや手間ですがgdbやobjdumpよりは格段に使いやすいでしょう。\n他にはllvm-irを出力したりJSON形式で出力したりもできるようですがここでは使いません。\nBoxの実験 普通のBox Boxをアロケートして関数から返して見ましょう。これは最適化の余地が無いので普通にヒープにアロケートすると予想されます。\npubfn heap_box()-\u0026gt; Box\u0026lt;i32\u0026gt;{Box::new(1)} これをディスアセンブルすると\nsub rsp, 56 lea rdx, [rsp, +, 8] mov edi, 4 mov esi, 4 ; allocが呼ばれている call __rust_alloc ; アロケート失敗したら失敗処理へ test rax, rax je .LBB6_1 ; 成功したらそのままreturn mov dword, ptr, [rax], 1 add rsp, 56 ret ; 失敗処理。 .LBB6_1: movups xmm0, xmmword, ptr, [rsp, +, 16] movaps xmmword, ptr, [rsp, +, 32], xmm0 movaps xmm0, xmmword, ptr, [rsp, +, 32] movups xmmword, ptr, [rsp, +, 16], xmm0 lea rdi, [rsp, +, 8] call alloc::heap::exchange_malloc::{{closure}} ud2 とアロケートしています。まずは当たり前のことが確認できました。\n別の関数に渡すBox 値をエスケープさせる先として別の関数に渡すのも試してみましょう。恐らく仕方なくアロケートするでしょう。\n渡す先の関数はこれを用意します。\n#[inline(never)]fn take\u0026lt;T\u0026gt;(t: T){let_=t;} で、これ。\npubfn take_box(){letb=Box::new(1);take(b)} ディスアセンブルします。\nsub rsp, 56 lea rdx, [rsp, +, 8] mov edi, 4 mov esi, 4 ; allocして call __rust_alloc test rax, rax je .LBB7_1 mov dword, ptr, [rax], 1 mov rdi, rax ; takeを呼ぶ call memory_check::take add rsp, 56 ret ; 失敗処理。 .LBB7_1: movups xmm0, xmmword, ptr, [rsp, +, 16] movaps xmmword, ptr, [rsp, +, 32], xmm0 movaps xmm0, xmmword, ptr, [rsp, +, 32] movups xmmword, ptr, [rsp, +, 16], xmm0 lea rdi, [rsp, +, 8] call alloc::heap::exchange_malloc::{{closure}} ud2 やはりアロケートしてますね。\n関数内で閉じたBox 先程は関数の外に返していましたが今度は内部で消費してみます。これは最適化できそうです。\npubfn stack_box()-\u0026gt; i32 {letb=Box::new(1);letb=*b+1;b} これをディスアセンブルすると\nmov eax, 2 ret アロケートどころか全部消し飛んでますね。\nアグレッシブー。\n別の関数に渡すBox - inline化あり 2つ前のやつ、takeの#[inline(never)]をはずすとどうなるかというと\nret アグレッシブー。\n別の関数に\u0026amp;mutで渡すBox では、中途半端に\u0026amp;mutで渡してみて関数内で消費してみましょう。これは最適化でアロケートが消えてスタック上の値の参照を渡すようになるんですかねー。\npubfn mut_stack_box()-\u0026gt; i32 {letmutb=Box::new(1);take(\u0026amp;mutb);*b+1} ディスアセンブルすると\nmov eax, 2 ret ？！？！？！take が何もしないことを見抜いている！？\n恐らくこれはpurity解析をしていて、takeが純粋なのでoptimize outしてもよいと判断できるのでしょう。\n適当に副作用を起こすtake_printを用意して\n#[inline(never)]fn take_print\u0026lt;T\u0026gt;(t: T){let_=t;println!(\u0026#34;hello\u0026#34;);} それを使うコードにすると\npubfn mut_stack_box_print()-\u0026gt; i32 {letmutb=Box::new(1);take_print(\u0026amp;mutb);*b+1} こうなります。\npush rbp push rbx sub rsp, 56 lea rdx, [rsp, +, 8] mov edi, 4 mov esi, 4 ; allocして call __rust_alloc mov rbx, rax test rbx, rbx je .LBB11_4 mov dword, ptr, [rbx], 1 call memory_check::take_print mov ebp, dword, ptr, [rbx] add ebp, 1 mov esi, 4 mov edx, 4 mov rdi, rbx ; dealloc call __rust_dealloc mov eax, ebp add rsp, 56 pop rbx pop rbp ret ; 失敗処理。 .LBB11_4: movups xmm0, xmmword, ptr, [rsp, +, 16] movaps xmmword, ptr, [rsp, +, 32], xmm0 movaps xmm0, xmmword, ptr, [rsp, +, 32] movups xmmword, ptr, [rsp, +, 16], xmm0 lea rdi, [rsp, +, 8] call alloc::heap::exchange_malloc::{{closure}} ud2 .LBB11_3: mov rbp, rax mov rdi, rbx call core::ptr::drop_in_place mov rdi, rbp call _Unwind_Resume ud2 ふむふむ。スタックは使わずにヒープにアロケートしてすぐにデアロケートするんですね。\nしかしちょっと気になる点が。これ、\u0026amp;mut Box\u0026lt;i32\u0026gt;をとってませんかね。\n型を明示してみます。\npubfn i32_mut_stack_box_print()-\u0026gt; i32 {letmutb=Box::new(1);take_print::\u0026lt;\u0026amp;muti32\u0026gt;(\u0026amp;mutb);*b+1} これでどうですか\nmemory_check::i32_mut_stack_box_print: push rbp push rbx sub rsp, 56 lea rdx, [rsp, +, 8] mov edi, 4 mov esi, 4 ; allocして call __rust_alloc mov rbx, rax test rbx, rbx je .LBB13_4 mov dword, ptr, [rbx], 1 call memory_check::take_print mov ebp, dword, ptr, [rbx] add ebp, 1 mov esi, 4 mov edx, 4 mov rdi, rbx ; dealloc call __rust_dealloc mov eax, ebp add rsp, 56 pop rbx pop rbp ret ; 失敗処理。 .LBB13_4: movups xmm0, xmmword, ptr, [rsp, +, 16] movaps xmmword, ptr, [rsp, +, 32], xmm0 movaps xmm0, xmmword, ptr, [rsp, +, 32] movups xmmword, ptr, [rsp, +, 16], xmm0 lea rdi, [rsp, +, 8] call alloc::heap::exchange_malloc::{{closure}} ud2 .LBB13_3: mov rbp, rax mov rdi, rbx call core::ptr::drop_in_place mov rdi, rbp call _Unwind_Resume ud2 だめですか。\n構造体の実験 今度はBoxではなくて構造体で実験します。\n用意するのはこれ。40byteの構造体。\n#[derive(Default)] pub struct Struct { a: i64, b: i64, c: i64, d: i64, e: i64, } 構造体の値返し まずはBoxと同じくそのまま関数から返してみます。\npubfn stack_struct()-\u0026gt; Struct{Struct::default()} これをディスアセンブルするとこうなります。\n; 128bit(=16byte)レジスタを0初期化 xorps xmm0, xmm0 ; メモリに16byte書き込む。書き込み先は引数で与えられたポインタ movups xmmword, ptr, [rdi, +, 16], xmm0 ; メモリに16byte書き込む movups xmmword, ptr, [rdi], xmm0 ; メモリに8byte書き込む。 ; SIMD命令は16byteアラインされていないといけないので端数は`mov`を使う mov qword, ptr, [rdi, +, 32], 0 mov rax, rdi ret へー。SIMD使って初期化するんですね。 それはともかく外部からポインタが渡されてますね。\nこのstack_structを#[inline(never)]して別の関数で受け取ってみましょう。\npubfn receive_struct(){let_=stack_struct();} これをディスアセンブルすると\n; スタックを40byte広げて sub rsp, 40 ; その領域へのポインタを`stack_struct`に渡す mov rdi, rsp call memory_check::stack_struct add rsp, 40 ret となっています。ふむふむ、スタック返しになっているんですね。\n構造体の値返し大小 40byteではスタック返しでした。では、もっと小さかったり大きかったりするとどうなんでしょう。\n8byteの場合: レジスタ返しのようです\n#[derive(Default)]pubstruct SmallStruct{a: i64,b: i64,}xor eax, eax xor edx, edx ret 8192byteの場合: スタック返しのようです。これはmemsetを使うんですね。\n#[derive(Default)]pubstruct BigStruct([[i64;32];32]);push rbx mov rbx, rdi xor esi, esi mov edx, 8192 call memset mov rax, rbx pop rbx ret 因みに8192byteの場合は受取側はスタックが溢れないかチェックするようです。\nmov eax, 262152 ; なんか呼ばれてる call __rust_probestack sub rsp, rax lea rdi, [rsp, +, 8] call memory_check::stack_big_struct add rsp, 262152 この__rust_probestack、ドキュメントによると、普段stack overflow検出にはガードページか使われていますがあまりにstackを伸ばす幅が大きいとガードページを飛び越えて伸ばしてしまう可能性があるため手動で検査する必要があるんだそうです。へー。因みに予想どおり確保サイズが4096byte以上になったらprobestackされるようです。\n構造体をBoxで受け取る 運が良ければBoxで確保した領域に直接書き込めるでしょう。運が悪ければ一旦スタックで受け、そこから Box に書き込むでしょう。\npubfn recieve_struct_in_box()-\u0026gt; Box\u0026lt;Struct\u0026gt;{letb=Box::new(stack_struct());b} 因みにstack_structには#[inline(never)]がついてます。\nディスアセンブルしてみましょう\n; スタックを伸ばして sub rsp, 88 lea rdi, [rsp, +, 48] ; stack_structを呼ぶ call memory_check::stack_struct lea rdx, [rsp, +, 8] mov edi, 40 mov esi, 8 ; メモリを確保して call __rust_alloc test rax, rax je .LBB20_1 mov rcx, qword, ptr, [rsp, +, 80] mov qword, ptr, [rax, +, 32], rcx movups xmm0, xmmword, ptr, [rsp, +, 48] movups xmm1, xmmword, ptr, [rsp, +, 64] ; 確保した領域に書き込み movups xmmword, ptr, [rax, +, 16], xmm1 movups xmmword, ptr, [rax], xmm0 add rsp, 88 ret ; 失敗処理。 .LBB20_1: movups xmm0, xmmword, ptr, [rsp, +, 16] movaps xmmword, ptr, [rsp, +, 32], xmm0 movaps xmm0, xmmword, ptr, [rsp, +, 32] movups xmmword, ptr, [rsp, +, 16], xmm0 lea rdi, [rsp, +, 8] call alloc::heap::exchange_malloc::{{closure}} ud2 残念な方でしたね。普通に最適化できないのかメモリ確保の失敗を勘案すると関数呼び出しと順番を入れ替えられないのか気になりますね。\n因みにnightlyのrustにはplace構文が用意されていて、メモリ確保した領域に直接書き込むことができます。\n#![feature(box_syntax)]pubfn receive_struct_in_place_box()-\u0026gt; Box\u0026lt;Struct\u0026gt;{letb=boxstack_struct();b} ディスアセンブルしてみると、ちゃんと先にメモリを確保しています。\npush rbx sub rsp, 48 lea rdx, [rsp, +, 8] mov edi, 40 mov esi, 8 ; メモリを確保してから call __rust_alloc mov rbx, rax test rbx, rbx je .LBB21_1 ; そこに書き込ませる mov rdi, rbx call memory_check::stack_struct mov rax, rbx add rsp, 48 pop rbx ret ; 失敗処理。 .LBB21_1: movups xmm0, xmmword, ptr, [rsp, +, 16] movaps xmmword, ptr, [rsp, +, 32], xmm0 movaps xmm0, xmmword, ptr, [rsp, +, 32] movups xmmword, ptr, [rsp, +, 16], xmm0 lea rdi, [rsp, +, 8] call alloc::heap::exchange_malloc::{{closure}} ud2 良いですね。\nまとめ  Boxは最適化で消えることはあるけどスタックに変わることはなかったよ Rustのスタックアロケートは本当にスタック返しをしてたよ Box::new(Struct)は一旦スタック経由で書き込んでたよ Placeの機能が入ると直接書き込めるようになりそうだね  こぼれ話 ずっとRustのメモリ周りの最適化が実際どうなっているのか調べたいと思っていました。 しかし毎度ディスアセンブルしてマングリングされた名前をさがすのも手間なのでしばらく放置していました。 ところがcargo-asmが登場したことにより手間が大分削減できるようになったのでこの記事が作成されました。ツールって偉大ですね。\n","categories":["Rust","Cargo"],"category_urls":["/categories/rust","/categories/cargo"],"date":"2018-04-04","title":"cargo asmでRustのメモリ周り最適化をチェック","url":"https://KeenS.github.io/blog/2018/04/04/cargo_asmderustnomemorimawarisaitekikawochekku/"},
  {"body":"# はじめに ---------- * 椅子のキーストラップは是非お持ち帰り下さい * 主にプログラミング言語を1つ覚えたくらいの人を対象にしています * トークで40分全部使い切る予定なので質問はこのあとの職員室でお願いします * たまに細かい話が出てきますがスルーして下さい + 主に重箱の角をつつく人への対策です ===  オブジェクト指向言語 と 関数型言語  ---------------- [MANABIYA](https://manabiya.tech/) 2日目5時間目@ギャラリーB [#manabiya](https://twitter.com/search?src=typd\u0026q=%23manabiya\u0026lang=ja) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * 言語処理系を作るのが好き * 仕事での経験: Java, Scala, Rust * 趣味: C, Common Lisp, Standard ML, Rust === # 話すこと -------- * オブジェクト指向/関数型\"プログラミング\"とはパラダイムのことだよ * オブジェクト指向/関数型\"言語\"とはそのパラダイムを支援する言語のことだよ * 言語とパラダイムの区別を明確に！ === # 理想のソフトウェア ------------------- * 変更に強いソフトウェア * バグの少ないソフトウェア * 凝集度を高めて結合度を低めたい + 似たようなものは同じところに + 互いの依存関係を減らす * 理想のソフトウェアを作るには？ === # パラダイム ----------- * [Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0) * プログラミングにおける思考のフレームワーク + 一貫性の取れた設計 + 組み合わせたときの相性の良さ + 一度理解するとその後の学習コストが下がる * 特定の言語に依存しない概念 * ある程度成功しやすい手法のパターン化 === # 色々なパラダイム ------------------ * 手続き型 - プログラムとは機械の操作の記述だ * オブジェクト指向 - プログラムとはオブジェクト間のメッセージのやりとりだ * 関数型 - プログラムとは計算だ * 論理型 - ... * などなど === # 複数のパラダイムを知ろう---------------------------- [](https://employment.en-japan.com/engineerhub/entry/2017/05/19/110000) 「ハンマーしか持っていなかったら、なんでも釘に見える」という戒めがありますが、第二言語を学ぶことは、まさにハンマー以外の道具を持つことだといえます。 === # オブジェクト指向プログラミング と 関数型プログラミング ---------- * 何故この２つのパラダイム？ + → よく使われるパラダイム2つ * 片方しか経験ない人はもう片方も学んでみよう + パラダイムが違うので最初は馴れない + コツは過去の成功体験を捨てること - パラダイムが違うと作法も違う * ベタな手続き型プログラミングよりいいコードを書きたい === # 参考図書 ---------- [](http://gihyo.jp/book/2016/978-4-7741-8361-9) [](http://gihyo.jp/book/2016/978-4-7741-8390-9) === # OOPって？ ---------------------- **オブジェクト** 同士の **メッセージング** によるプログラミング手法 * コード同士の依存関係を上手く管理したい * 依存関係を上手く扱うことで変更に強いソフトウェアへ * [DDD](https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88)などの設計手法 * コードの分割 * コードの再利用 === # FPって？ -------------------- **副作用** を出来るだけ使わないプログラミング手法[※](https://twitter.com/esumii/status/638591159518887936) * 副作用 = 計算以外のもの + 破壊的変更、出入力など(深入りするとややこしい) * 状態を排除→文脈に依存しないコードへ * 読みやすくなる * バグが少なくなる * コードの分割と合成 === # 何が違うの？ ------------ OOPFP 状態隠蔽排除 誰がオブジェクト関数 対象メッセージデータ 抽象データ処理  === # 手続き的(自然言語) ------------------------- 入力: `array` - 配列, `n` - 配列の長さ 出力: `array`の要素の合計 1. `sum = 0`, `i=0` とする 2. もし`i` が`n`未満なら4へ飛ぶ 3. 7へ飛ぶ 4. `sum`に`array`の`i`番目を足したものを`sum`に代入 5. `i`をインクリメント 6. 2へ飛ぶ 7. `sum`を返す === # 手続き的(C言語) ---------------- ``` c int procedual_sum(const int array[], size_t n) { int sum = 0; for(size_t i = 0; i === # OOPコード例(C言語) ------------------- ``` c struct iterable { struct iter *(*iter)(const struct iterable *); void (*fin)(struct iterable *); }; struct iter { int (*next)(struct iter *); bool (*has_next)(const struct iter *); void (*fin)(struct iter *); }; int objective_sum(const struct iterable *data) { int sum = 0; struct iter *iter = data-iter(data); while (iter-has_next(iter)) { sum += iter-next(iter); } iter-fin(iter); return sum; } ``` === # 実装イメージ === # OOPコード例(C言語) 実装------------------- ``` c++ struct array_list { struct iterable super; int (*get)(const struct array_list *, size_t i); size_t (*len)(const struct array_list *); int *inner; size_t n; }; struct array_list_iter { struct iter super; const struct array_list *array; size_t i; }; struct iter *array_list_iter(const struct iterable *); void array_list_fin(struct iterable *); int array_list_get(const struct array_list *, size_t); size_t array_list_len(const struct array_list *); struct array_list_iter *array_list_iter_new(const struct array_list *); void array_list_iter_fin(struct iter *); int array_list_iter_next(struct iter *); bool array_list_iter_has_next(const struct iter *); struct array_list * array_list_new(int *inner, size_t n) { struct array_list *array = (struct array_list *)malloc(sizeof(struct array_list)); if (! array) { return array; } array-super.iter = array_list_iter; array-super.fin = array_list_fin; array-get = array_list_get; array-len = array_list_len; array-inner = inner; array-n = n; return array; } void array_list_fin(struct iterable *super) { struct array_list *self = (struct array_list *) super; free(self); } struct iter * array_list_iter(const struct iterable *super) { struct array_list *self = (struct array_list *) super; return (struct iter *)array_list_iter_new(self); } int array_list_get(const struct array_list *self, size_t i) { return self-inner[i]; } size_t array_list_len(const struct array_list *self) { return self-n; } struct array_list_iter * array_list_iter_new(const struct array_list *array) { struct array_list_iter *iter = malloc(sizeof(struct array_list_iter)); if (! iter) { return iter; } iter-array = array; iter-i = 0; iter-super.fin = array_list_iter_fin; iter-super.next = array_list_iter_next; iter-super.has_next = array_list_iter_has_next; return iter; } void array_list_iter_fin(struct iter *super) { struct array_list_iter *self = (struct array_list_iter *)super; free(self); } int array_list_iter_next(struct iter *super) { struct array_list_iter *self = (struct array_list_iter *)super; int ret = self-array-get(self-array, self-i); self-i++; return ret; } ``` === # OOPコードの特徴 ----- * オブジェクトにメッセージを送ってループを書いた + オブジェクト = `iter` + メッセージ = `has_next`、`next` * インターフェースと実装を分離してコードを書いた + インターフェース = `iterable`、`iter` + 実装 = `array_list`、`array_list_iter` * データの中身を知らなくてもコードを書けた + 木構造や辞書などにも適用できる * 具体的実装がなくてもコードを書けた + コードの分割ができる === # FP的発想 ---------- * 配列の中身の合計を求める式を立てよう * 計算を一般化して汎用性をあげよう * それをプログラムとして書き下そう === # FP的記述 ---------- \\\\\\[ \\begin{align} S\\_0 \u0026= 0 \\\\\\\\ S\\_n \u0026= S\\_{n-1} + arr[n - 1] \\end{align} \\\\\\] === # FP的記述 ---------- \\\\\\[ \\begin{align} S\\_0 \u0026= init \\\\\\\\ S\\_n \u0026= f(S\\_{n-1}, arr[n - 1]) \\end{align} \\\\\\] === # FPコード例(C言語) ------------------- ``` c++ int reduce(const int array[], const size_t n, const int init, int(*f)(const int, const int)) { if (n == 0) { return init; } else { return f(reduce(array, n - 1, init, f), array[n - 1]); } } int add(const int x, const int y) { return x + y; } int functional_sum(const int array[], const size_t n) { return reduce(array, n, 0, add); } ``` === # FP的コードの特徴 ---------------- * ループと中身に分解してコードを書いた + ループ = `for文` → `reduce` + 中身 = `sum += array[i]` → `add` + 制御構造を関数にできた * 副作用(変数の更新)を行わずにコードを書いた * 宣言的になった === # OOPコードの問題点 ---------------- * メッセージパッシングの書き方が冗長 ``` obj-msg(obj) ``` * 普通のコードより遅そう + 毎回関数ポインタ経由でメッセージ + ことある毎にオブジェクトを作る - 今回は余計にイテレータオブジェクトを作った * `int`と`+`はオブジェクトとメッセージになってない + 設計の一貫性がとれてない * メッセージ増やすとデータサイズが増えそう === # FPコードの問題点 --------------- * 余計な関数定義が増える + 足し算するための`add`関数を定義した * データに依存したコードになっている + 他のデータ型に対して適用できない * 副作用を使わない + 機械の操作とは大分違う * 一般には毎回データのコピーが発生する + 今回の例では運良く`int`しかコピーしなかった === # 問題の解決案 -------------- 言語による* 対象にしているものが広すぎる* 具体的な言語抜きに語っても意味がない=== そのまえに # XXX言語とは ------------ [関数型プログラミングの今昔](https://www.slideshare.net/ksknac/120901fp-key) * オブジェクト指向(プログラミングを支援する)言語 * 関数型(プログラミングを支援する)言語 * マルチパラダイム言語もある + 複数のプログラミングパラダイムを支援 + それらを混ぜて使うことも === # OOP言語色々 --------------------- * メソッド呼び出し構文があればOOPを支援(?) + `obj-msg(obj)` → `obj.msg()` * クラスベース + Ruby Java C# Python C++ ... + 単一継承/多重継承の違いも * プロトタイプベース + Smalltalk JS ... * その他 + go rust ... === # クラスベースの特徴 --------------------- * メッセージはクラスが知っている + メッセージを増やしてもオブジェクトは肥大化しない * クラス継承によるインターフェースと実装の再利用 + ある意味では親と子の密結合 * リスコフの置換則 + 親クラスはいつでもサブクラスに置き換えられるべき * 差分プログラミングをするとスパゲッティコードになる  「オブジェクトの階層構造をコストとして払う代わりに、メッセージの移譲は無料で手に入れられる」 === === 抽象の境界と差分プログラミングとスパゲッティコード === 抽象の境界と差分プログラミングとスパゲッティコード === # Javaの特徴 ------ * クラスベース単一継承 * 抽象クラスやインターフェースによる抽象化 * プリミティブ型はオブジェクトじゃない * 遅くならない工夫 + → 実行しながら高速化 + → メモリ管理の改善 * 割とクラスの機能が強い + クラスが名前空間も兼任 + スタンドアロンな関数が書けない（かった） + コールバックには無名クラスとか === # Javaのコード例 ------ ``` java abstract class Figure { void draw() {} abstract void move(int dx, int dy); } class Triangle extends Figure { Point a; Point b; Point c; @Override void draw() { drawLine(a, b); drawLine(b, c); drawLine(c, a); } @Override void move(int dx, int dy) { a.move(dx, dy); b.move(dx, dy); c.move(dx, dy); } void drawLine(Point from, Point to) {} class Point { int x; int y; void move(int dx, int dy) { x += dx; y += dy; } } } ``` === # Javaのコード例について------ * 設計は難しい * `drawLine` はだれが持つべき？ + `drawLine` ってTriangleだけのものじゃないよね + 本来は `new Line().draw()` では？ + でも毎回オブジェクト作るの？ * `ColoredTriangle` を作ろうとしたらどうする？ + `drawLine` をオーバーライドする？ + `new ColoredLine` にする？ === # Rubyの特徴 ------- * クラスベース単一継承 * 生産性を重視した設計 * 数値や`+`などもオブジェクト/メソッド * ダックタイピング + メッセージに応答すればなんでもいい * クラスだけでなくモジュールも * mix-in * クラスの権限がそんなに強くない + オープンクラス === # Rubyらしさ(主観) ----------- * for文なしでの繰り返し + ブロック構文 ``` ruby (1..10).each{|i| puts i} ``` * [ActiveSupport](https://railsguides.jp/active_support_core_extensions.html#time)による数値の拡張など + オープンクラス 数値もオブジェクト `+`もメソッド ```ruby 1.week - 2.days ``` === # Goの特徴 ---------- * メソッド呼び出し構文がある * クラスや継承はない + 代わりにインターフェースとインクルードがある === # 関数型言語色々 --------------- * ML系 + SML + OCaml + F# * Haskell系 + Haskell (GHC) + Agda + Idris * Erlang * Lisp系 + Clojure === # ありがちな機能 --------------- * 破壊的変更できないorあまりしない * 関数の便利な扱い + 無名関数 + 演算子も関数 + 関数合成 + 高階関数 + カリー化(関数を返す関数) * ※「関数型 = Haskell」はHaskellプログラマの麻疹 === # 便利な関数の扱い ----------------- * 高階関数 演算子も関数 関数合成 ``` sml val sum = List.foldl op+ 0; ``` ``` standard-ml val inner_product = List.foldl op+ 0 o List.map op* o ListPair.zip; inner_product ([1, 2, 3], [1, 2, 3]); (* = 14 *) ``` * カリー化 ``` standard-ml fun findManabiya list = List.find (String.isPrefix \"manabiya\") list val findManabiya = List.find (String.isPrefix \"manabiya\") ``` * 無名関数 ``` standard-ml String.tokens (fn c = c = #\" \" orelse c = #\"\\n\") ``` === # データコピーの話 ------------------ * リストを2回コピーしてるけど遅くない？ ``` standard-ml fun inner_product l1 = let val l2 = ListPair.zip l1 val l3 = List.map op* l2 in List.foldl op+ 0 l3 end ``` * もうちょっと一般に世の中のアルゴリズムを実装すると遅くない？ === # データコピーの話 ------------------ * リストを2回コピーしてるけど遅くない？ + 言語による + [1倍〜100倍遅い](https://gist.github.com/KeenS/35345a4661dc696f467abd2de830568d) - 関数型言語に向いたGCアルゴリズムの採用 - 最適化で消せる * もうちょっと一般に世の中のアルゴリズムを実装すると遅くない？ + A1. 遅い部分は諦めて副作用を使う + A2. 関数型向きデータ構造/アルゴリズムを使う - [純粋関数型データ構造](http://asciidwango.jp/post/160831986220/%E7%B4%94%E7%B2%8B%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0) - [関数プログラミング 珠玉のアルゴリズムデザイン](http://shop.ohmsha.co.jp/shopdetail/000000004066/) === # Clojureの特徴 --------------- * デフォルトイミュータブルなLisp方言 * イミュータブルHashMap/Set + イミュータブルだけどデータを全部コピーする訳ではない + [HAMT](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) ``` clojure (assoc {:name \"κeen\"} :age 25) ; -{:age 25, :name \"κeen\"} ``` * 並列プログラミングに強い + データ競合が起きない === # SMLの特徴 ------ * 強い静的型付 * 普通に破壊的変更あるよ * モジュールによるカプセル化 * ファンクタによる依存の注入 === # SMLのコード例 ------ * モジュールによるカプセル化 + データに対する操作を一箇所に集めるのは変わらない ``` standard-ml structure MyList: sig type t val len: t - int val get: t - int - int end = struct type t = int list val len = List.length fun get (x::xs) 0 = x | get (x::xs) n = get xs (n-1) end ``` === # SMLのコード例 ------ * ファンクタによる依存の注入 ``` standard-ml functor Make(Foldable: sig type 'a t val fold: ('a * 'b - 'b) - 'b - 'a t - 'b end) = struct val sum = Foldable.fold op+ 0 end ``` === # Haskell(GHC)の特徴 ---------- * 強い静的型付け * 強力な型システム * 型クラスによるデータ抽象 * 純粋 + 破壊的変更とIOを基本許さない + 全て式になる - 雑にいうとセミコロンなしでプログラミングする + 入力からのみ出力が決まる → 型をみたら関数の使い方が大体分かる * 遅延評価 + 必要になるまで値を計算しない - 評価の順番も変わる + 純粋なのでプログラムの結果は変わらない - (細かいことを言うと無限ループの挙動が違うけど) === # Haskell(GHC)のコード例---------- * 型クラスによるデータ抽象 ``` haskell {-# LANGUAGE NamedFieldPuns #-} class Drawable a where draw :: a - () class Movable a where move :: a - (Int, Int) - a data Point = Point Int Int deriving Show instance Movable Point where move (Point x y) (dx, dy) = Point (x + dx) (y + dy) data Triangle = Triangle { a:: Point, b:: Point, c:: Point } deriving Show instance Drawable Triangle where draw _ = () instance Movable Triangle where move Triangle{a, b, c} d = Triangle { a = move a d, b = move b d, c = move c d } ``` === # Haskell(GHC)と逐次処理----------------  雑にいうとセミコロンなしでプログラミングする * 逐次処理はどうするの？(e.g. 1行読んでそれを出力) 1. プログラムを値として扱って合成する ```haskell Program1 ○ Program2 - Program2' ``` 2. 直前の値も受け取れるようにする ```haskell Program1 ○ (a - Program2 ) - Program2' ``` 3. 色々な種類のプログラムに対応可能 ```haskell Program a ○ (a - Program b) - Program b ``` 4. 具体的には`=`という演算子で合成 ```haskell getLine = putStrLn ``` 5. シンタックスシュガー ```haskell do s === # Haskell(GHC)の遅延評価---------- * 遅延評価 + 同等のCのコードよりずっと速い + 計算量が変わる + `tarai(12, 6, 0)`で2,604,860回 vs 110回 ``` haskell tarai:: Int - Int - Int - Int tarai x y z = if x === # 関数型言語のOOP ----------------- * OCamlのO * SMLのモジュールは割とOOPに似てる？ * `|` は割とメソッドチェーンに似てる？ ``` elixir 1..999 | Enum.filter(\u0026(rem(\u00261, 3) == 0 || rem(\u00261, 5) == 0)) | Enum.sum | IO.puts ``` === # オブジェクト指向言語のFP------------------------- * 高階関数 + Rubyのブロックも * JavaのStream API + [FP in Java](https://www.amazon.co.jp/dp/1937785467) === # 結局どういう関係なの？---------------------- * 大きな部分では変わらない + 関心毎にコードを集めて粗結合な部品を組み立てる * オブジェクト指向は設計より * 関数型はコーディングより * 完全に相反するものでもない + マルチパラダイム言語 * 相性の悪い点もある === # プログラミング言語のこれから-------------------------- * 今回挙げた言語はかなり古い言語 + Ruby, Java, Haskell, SMLは20年以上前に出来た * 古い言語は当時技術を元に設計される + ハードウェア + コンパイル技法 + ベストプラクティス * これからは新しい概念、いいとこ取りの言語設計も出てくる？ + 並列並行サポート + 代数的データ型とパターンマッチ、無名関数 + 所有権 + などなど === # まとめ -------- * オブジェクト指向/関数型プログラミングとはパラダイムのことだよ * オブジェクト指向/関数型言語とはそのパラダイムを支援する言語のことだよ + 言語とパラダイムの区別を明確に！ * それぞれ目的もアプローチも違うよ * 両方手札に持って使い分けようね * これ以外にも新しい言語にも注目   ","categories":["オブジェクト指向","関数型"],"category_urls":["/categories/%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e6%8c%87%e5%90%91","/categories/%e9%96%a2%e6%95%b0%e5%9e%8b"],"date":"2018-03-14","title":"オブジェクト指向言語と関数型言語","url":"https://KeenS.github.io/slide/obujiekutoshikougengotokansuugatagengo/"},
  {"body":"κeenです。個人メモ。dieselでリテラルのNULLをSELECTしたいケースでの書き方。\ntable.select(None::\u0026lt;String\u0026gt;.into_sql::\u0026lt;Nullable\u0026lt;Text\u0026gt;\u0026gt;()) 結果だけみると当たり前っぽいけど into_sql とか None と into_sql 両方に型書かないとコンパイル通らないとか色々はまった。\n","categories":["Rust","Diesel"],"category_urls":["/categories/rust","/categories/diesel"],"date":"2018-02-26","title":"DieselでSELECT NULLする","url":"https://KeenS.github.io/blog/2018/02/26/dieseldenullwosentakusuru/"},
  {"body":"κeenです。簡単にいうと「OCamlが関数の引数を右から評価する件について」。\nこれは他人から聞いた話なのですがよく目にするので文章として纏めておきます。\nOCamlは仕様では評価順序は未定義とし(らしい)つつも現在の実装(4.06.0)は引数を右から評価します。\n追記\n丁度読んでいたので参考情報です。OCaml の関数適用の評価順序が not specified と名言しているのは、 https://t.co/0Zd6Cl7Qgy の Function application の項だと思います。（識者の方によると仕様はないそうですが…）\n\u0026mdash; takl (@takl) 2018年2月24日 /追記\n(* OCaml *) # let f x y = ();; # f (print_endline \u0026#34;1st\u0026#34;) (print_endline \u0026#34;2nd\u0026#34;);; 2nd 1st - : unit = () ただ、「右から評価」はやや不正確です。関数はカリー化されているので引数は各々1つです。 関数適用のf x yは優先順位を明確にすると(f x) yになるので正確には「関数適用は引数から評価」ということになります。 このことは以下のようにして確かめられます。\n(* OCaml *) # (print_endline \u0026#34;f\u0026#34;; f) (print_endline \u0026#34;1st\u0026#34;) (print_endline \u0026#34;2nd\u0026#34;);; 2nd 1st f - : unit = () 因みにSMLだと仕様で関数から評価することになっています。\n(* SML *) # fun print_endline x = print (x ^ \u0026#34;\\n\u0026#34;); val print_endline = fn : string -\u0026gt; unit # fun f x y = ();; val f = fn : [\u0026#39;a. \u0026#39;a -\u0026gt; [\u0026#39;b. \u0026#39;b -\u0026gt; unit]] # (print_endline \u0026#34;f\u0026#34;; f) (print_endline \u0026#34;1st\u0026#34;) (print_endline \u0026#34;2nd\u0026#34;); f 1st 2nd val it = () : unit 詳しくは仕様のDynamic Semantics for the Coreから探して下さい。\n一見、SMLの方が直観に沿った挙動ですが実装側からするとOCamlの挙動の方が嬉しいケースがあります。\n特にOCamlやSMLの実装コードを読んだわけではないですが「概念上こういうケースがありうる」という例をいくつか紹介します。\nUncurry Optimization 一般論としてcurry化された関数は複数回関数適用をするので遅いです。 そこでuncurry化する、つまり引数をまとめてタプルで渡すようにする最適化があります。\n先程の関数をuncurry化してみます。すると印字される結果はどうなるでしょう。\n(* OCaml *) # let f(x, y) = ();; # (print_endline \u0026#34;f\u0026#34;; f) ((print_endline \u0026#34;1st\u0026#34;), (print_endline \u0026#34;2nd\u0026#34;));; 2nd 1st f - : unit = () OCamlは変わらず\n(* SML *) # fun f(x, y) = ();; val f = fn : [\u0026#39;a, \u0026#39;b. \u0026#39;a * \u0026#39;b -\u0026gt; unit] # (print_endline \u0026#34;f\u0026#34;; f) ((print_endline \u0026#34;1st\u0026#34;), (print_endline \u0026#34;2nd\u0026#34;)); f 1st 2nd val it = () : unit SMLも変わりません。\nOCamlは少し意外ですがタプルも右から評価するので結果が変わらないのです。 恐らく関数適用を引数から評価することに合わせたのでしょう。\nさて、ではこのuncurry化、任意の関数で行えるでしょうか。 答えはSMLは出来ませんがOCamlではできます。\nSMLの方は1つ引数を受け取った後に副作用を起こしてからもう1つの引数を受け取る関数を書くと壊れてしまいます。\n(* SML *) (* uncurry化前 *) # (fn x =\u0026gt; (print_endline \u0026#34;mid\u0026#34;; fn y =\u0026gt; ())) (print_endline \u0026#34;1st\u0026#34;) (print_endline \u0026#34;2nd\u0026#34;); 1st mid 2nd val it = () : unit (* uncurry化後 *) # (fn (x, y) =\u0026gt; (print_endline \u0026#34;mid\u0026#34;)) ((print_endline \u0026#34;1st\u0026#34;), (print_endline \u0026#34;2nd\u0026#34;)); 1st 2nd mid (* ←壊れた *) val it = () : unit 一方OCamlでは\n(* OCaml *) (* uncurry化前 *) # (fun x -\u0026gt; (print_endline \u0026#34;mid\u0026#34;; fun y -\u0026gt; ())) (print_endline \u0026#34;1st\u0026#34;) (print_endline \u0026#34;2nd\u0026#34;);; 2nd 1st mid - : unit = () (* uncurry化後 *) # (fun (x, y) -\u0026gt; (print_endline \u0026#34;mid\u0026#34;; ())) ((print_endline \u0026#34;1st\u0026#34;), (print_endline \u0026#34;2nd\u0026#34;));; 2nd 1st mid - : unit = () 問題は起こりません。\nSMLは f x y は「f, x, x への適用, y, y への適用」 と引数の評価の間に関数適用の評価が入っているので問題になりますがOCamlでは「y, x, f, x への適用, y への適用」とフェーズが分かれているので問題が起きないのです。\nスタック渡しとレジスタ渡し 雑に説明します。\nコンパイル言語でもスタックベースVMを使うことがあったりABIによってはスタックベースだったりしますね。 そういうときに可変長引数を扱うためだとかで引数の後ろをスタックに積む規約があります。 そういう規約の元では逆から評価した方が具合が良いでしょう。\n逆にレジスタ渡しだと引数は左から順に並べた方が自然でしょう。\nレジスタ最小化 要は中間変数を出来る限り減らしたいという話です。\nこれはMLに限らない話ですが、マシンのレジスタは有限なのでコンパイラは頑張ってレジスタを減らそうとします。 コンパイル結果のマシン語の使用するレジスタは評価順序で変わります。 なので評価順序を好きにいじれると上手く減らせるのです。\n(a * b) - (c + d) / (e + f)\nのような式、何も考えず左から評価してみましよう。疑似マシン語です。\nr1 \u0026lt;- load a r2 \u0026lt;- load b r1 \u0026lt;- r1 + r2 // a * b r3 \u0026lt;- load c r4 \u0026lt;- load d r3 \u0026lt;- c + d // c + d r4 \u0026lt;- load e r5 \u0026lt;- load f r4 \u0026lt;- r4 + r5 // e + f r3 \u0026lt;- r3 / r4 // (c + d) / (e + f) r1 \u0026lt;- r1 - r3 // (a * b) - (c + d) / (e + f) 頑張って不要になったレジスタを再利用しましたがr5まで出てきたのでレジスタを5つ使ったことになります。\n追記\nr1 \u0026lt;- load a\nr2 \u0026lt;- load b\nr1 \u0026lt;- r1 + r2 // a * b\nr2 \u0026lt;- load c\nr3 \u0026lt;- load d\nr2 \u0026lt;- c + d // c + d\nr3 \u0026lt;- load e\nr4 \u0026lt;- load f\nr3 \u0026lt;- r3 + r4 // e + f\nr2 \u0026lt;- r2 / r3 // (c + d) / (e + f)\nr1 \u0026lt;- r1 - r2 // (a * b) - (c + d) / (e + f)\nでr4までになりませんか?\n\u0026mdash; エヌユル (@ncaq) 2018年2月24日 \n/追記\n今度は-の右辺から計算してみます。\nr1 \u0026lt;- load c r2 \u0026lt;- load d r1 \u0026lt;- r1 + r2 // c + d r2 \u0026lt;- load e r3 \u0026lt;- load f r2 \u0026lt;- r2 + r3 // e + f r1 \u0026lt;- r1 / r2 // (c + d) / (e + f) r2 \u0026lt;- load a r3 \u0026lt;- load b r2 \u0026lt;- r2 * r3 // a * b r1 \u0026lt;- r2 - r1 // (a * b) - (c + d) / (e + f) r3までしか使っていないのでレジスタは3つしか使用していません。\nこれは-の右辺の方が使用する引数が多いのでこうなったまでで、一般に右から評価した方がいいというわけではありません。 仕様上は評価順序は「式に依って異なる」、つまり未定義が最適でしょう。\nまとめ いくつか「なぜ引数の評価が右からなのか」「なぜ仕様では未定義だと嬉しいのか」の理由になるような例を示しました。 あくまで考えられる一例で、必ずしもOCamlがこの理由で現状になっているのを保証するわけではありません。\nOCamlはVMコンパイラとネイティブコンパイラを持ち、さらにネイティブコンパイラは複数アーキテクチャをサポートするのでそれぞれで最適な評価順序が異なります。 恐らくですがその兼ね合いもあるのでしょう。 評価順序が未定義でも全然驚きはありませんし、むしろ少なくとも手元のx86_64ではVMとネイティブ両方で同じ評価順序なのはよく出来ていると思います。\n因みにSMLでcurry化した関数を何度も関数適用しているかというとそうでもなく、いくつかの最適化でちゃんと関数呼び出しは消えるようです。\nまとまりに欠きますが仕様上は評価順序が未定義でも理由があるんだよという話でした。\n","categories":["ML","SML","OCaml","言語実装"],"category_urls":["/categories/ml","/categories/sml","/categories/ocaml","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2018-02-24","title":"関数適用、関数から評価するか？引数から評価するか？","url":"https://KeenS.github.io/blog/2018/02/24/kansuutekiyou_kansuukarahyoukasuruka_hikisuukarahyoukasuruka/"},
  {"body":"マクロ・クラブのルール\n マクロを書くな それがパターンをカプセル化する唯一の方法ならば、マクロを書け 例外: 同等の関数に比べて、 呼び出し側が楽になるならば、マクロを書いても構わない  κeenです。レーシックを受けようとしたら角膜が薄くて手術拒否されました。予定が狂って時間が空いたのでブログを書きます。\n冒頭のルールはプログラミングClojureに出てくるマクロの書き方の指南です。 Rustのマクロって色々できるんだよという記事を書くにあたってマクロに一日の長があるLispの知見を引用されていただきました。 ルールにあるとおり、マクロは関数と違ってRustの第一級オブジェクトでないので扱いづらいですし本体がコピーされるのでコードサイズも膨らんでしまいます。 よく考えながら使いましょう。とはいってもRustの構文はLispに比べると複雑ですし型やパターンマッチなどLispに存在しない構文要素もあるのでLispより使いどころは多くありそうです。\nマクロって何？ 簡潔に言うとRustのプログラムをプログラミングする仕組みです。 関数がデータを受け取ってデータを返すのに対してマクロはRustの構文の一部(構文木)を受け取ってRustの構文の一部を返します。\nマクロはRustコンパイラがコンパイル中に実行するので関数とは全然違うタイミングで動きます。 初めのうちはマクロも意識せずに使えますがまれにマクロについて理解してないと使えないケースもあります。 必要になったらマクロを意識しはじめましょう。\nマクロのドキュメントはTRPLやTRPL 2nd、リファレンスマニュアル、非公式ですがThe Little Book of Macrosなどがあるので詳しく見たい方はそちらを当たるといいかもしれません。ここではあまり難しいことは言わずにマクロを使っていきます。ポジションとしてはTRPLのマクロの章を実際のユースケースに合わせて補完できたらなというところです。\nまた、Rustにはここで扱う宣言的マクロの他に手続き的マクロもあります。 手続きによってRustの構文を作るので生成されるコードがわかりづらく難しい反面、自由度は高いので宣言的マクロで出来ないことも手続き的マクロでは可能になります。 proc_macroはここでは扱わないので気になる方は適当に調べてみて下さい。\nマクロでできること 大抵のことはできます。\n値 要は関数のようにも扱えるわけですね\nmacro_rules!add{($e1: expr,$e2: expr)=\u0026gt;{$e1+$e2};}fn main(){letret=add!(1,2);println!(\u0026#34;{}\u0026#34;,ret);// -\u0026gt; 3 } 関数呼び出し 関数名を受け取ってそれを呼び出したりもできます。\nfn print2(i: i32,j: i32){println!(\u0026#34;{}, {}\u0026#34;,i,j);}macro_rules!call_by_double{($name: ident,$e: expr)=\u0026gt;{$name($e,$e)}}fn main(){call_by_double!(print2,1);// -\u0026gt; 1, 1 } 変数束縛 新たな束縛を導入したりもできます。 詳しくは触れませんがRustのマクロは衛生的なのでユーザが指定した以外の変数を導入することはできません。\nmacro_rules!bind{($var: ident,$val: expr)=\u0026gt;(let$var=$val;)}fn main(){bind!(x,1+2);println!(\u0026#34;{}\u0026#34;,x);// -\u0026gt; 3 } パターン パターンも書けます。今試したら|パターンは書けないようでした。残念ですね。\nmacro_rules!exact_one{()=\u0026gt;(Some(1))}macro_rules!two{($x: ident)=\u0026gt;(Some($x@2))}macro_rules!three{($x: ident)=\u0026gt;(Some($x@3))}macro_rules!many_or_none{()=\u0026gt;(_)}fn main(){matchSome(2){exact_one!()=\u0026gt;println!(\u0026#34;exact one\u0026#34;),two!(x)|three!(x)=\u0026gt;println!(\u0026#34;{}\u0026#34;,x),many_or_none!()=\u0026gt;(),}} 型 型の位置にもマクロが使えます。残念ながらトレイト制約の一には書けませんでした\nmacro_rules!result{()=\u0026gt;{Result\u0026lt;i32,()\u0026gt;}}fn function()-\u0026gt; result!(){Ok(0)} アイテムの定義 structやimplやtraitなどの定義もできます。\nmacro_rules!define_id_type{($name: ident)=\u0026gt;{pubstruct $name(pubu64);impl$name{pubfn new(id: u64)-\u0026gt; Self{$name(id)}}}}define_id_type!(UserId); マクロをどこで使えるかはイマイチドキュメントがなく、実験的に確かめるしかありません。\nマクロを定義する 基本の「き」 マクロで何が書けるかを見てきたので次はマクロを書いてみましょう。とはいってもいままで定義してきましたね。 最初のadd!マクロを取り出してみましょう。\nmacro_rules!add{($e1: expr,$e2: expr)=\u0026gt;{$e1+$e2};} これの引数のところを取り出してみましょう\n($e1: expr, $e2: expr) $e1, $e2 などはいいですね。引数の変数です。 マクロは引数でパターンマッチできるので変数はそれとの違いを明確にするために$をつけます。\n:exprの方です。マクロの引数にも型があります。構文を受け取るので型は構文の型です。ここではexpr型の構文を受け取ると言っています。 expr 型はRustの構文でいう式、つまりは計算すると値を返す構文の型です。\n他にも構文の型はいくつかあります。\n item: fn定義struct定義などのトップレベルに置かれるものです block: ブロック。雑に言うと波括弧で括られた式/文ですね。{let x = 1; x * 2}など。 stmt: 文。雑に言うと;で終わるやつです。let x = 1;など。 pat: パターン。matchやif let、letなどで使えるやつです。 expr: 式。先程説明したとおり、計算すると値を返すものです。1 + 2など。 ty: 型。 ident: 識別子。関数名、変数名などですね。 path: パスです。std::collections::HashMapなどです。 tt: トークンツリー。1塊になってる構文要素です。まあ、なんかなんでもアリみたいなやつです。 meta: メタアイテムです。雑にいうと#[]の中身です。  これを覚えておけばマクロの引数には困りません。 あと比較的最近、可視性(pubやpub(crate)など)も導入された筈ですがドキュメントが見当たらないので流します。\nよく使うのはexpr, ty, identあたりかなーといったところです。\nパターン マクロの引数の位置にはパターンが書けます。試しにVecを作るvec!マクロのようにHashMapを作るmap!マクロを作ってみましょう。\nmacro_rules!map{($($k: expr=\u0026gt;$v: expr),*)=\u0026gt;{{letmutmap=::std::collections::HashMap::new();$(map.insert($k,$v);)*map}};}fn main(){letnums=map!{1=\u0026gt;\u0026#34;one\u0026#34;,2=\u0026gt;\u0026#34;two\u0026#34;};println!(\u0026#34;{}\u0026#34;,nums[\u0026amp;2]);} 一気に詰め込みすぎましたかね？ひとつづつ見ていきます。\nまずはパターンの$k: expr =\u0026gt; $v: exprの部分。 1 =\u0026gt; \u0026quot;one\u0026quot;や2 =\u0026gt; \u0026quot;two\u0026quot;にマッチしています。 それっぽくパターンを書くとrustコンパイラがいい感じにマッチしてくれます。 ここでの=\u0026gt;のようにマクロを使うとRustにない構文でも自由に受け取れるようになります。マクロ便利ですね。 ところでadd!マクロで($e1: expr, $e2:expr)のようにカンマで区切っていたのもカンマに対するマッチだった訳ですね。\nこの新しい記号の導入はある程度制限があります。たとえばここで+を区切りに使うと怒られます。 map![1+1+1]と渡した場合に+がマクロの区切りなのか足し算をしているのか区別が付かないからです。 これはどの記号が許容されるかはドキュメントに書いてあるので気になる人は確認して下さい。 ドキュメントを読まない人はRustの構文解析器の気持ちになって察して下さい。間違ってたらコンパイラが教えてくれるのでそれでもいいと思います。\n次に$(...),*の部分。これは0回以上のパターンの繰り返しです。 複数個使おうと思ったら必要ですね。 地味に,の扱いが特別で、map!{1 =\u0026gt; \u0026quot;one\u0026quot;, 2 =\u0026gt; \u0026quot;two\u0026quot;}の使用からみても分かるとおり区切りの位置にのみマッチします。map!{1 =\u0026gt; \u0026quot;one\u0026quot;, 2 =\u0026gt; \u0026quot;two\u0026quot;,}と最後にカンマを書くとエラーになります。\nパターンはいいのですが、使用箇所も見ておきましょう。$(map.insert($k, $v);)*です。 使用時にも$(...)*包んでいます。ここでは$()の中に;を入れているので区切りを使ってませんね。 区切りを外に出して$(map.insert($k, $v));*;と書くことも可能ですが、最後のセミコロンに注意しましょう。\n最後に、マクロの本体が複文になったので全体が{{ }}で囲まれています。 外側の{}がマクロの本体を括る括弧で、内側の{}がマクロの返り値を1つの構文要素にするための括弧です。\nさて、これでだいたいマクロは説明した気がするので実例をみていきましょう。\nマクロ実例集 match_vec! 説明していませんでしたが、マクロのパターンは複数書けます。関数定義よりはmatchを書いている気分に近いですね。\nmacro_rules!ignore{($pat: tt)=\u0026gt;{}}macro_rules!match_vec{// `vec![]`パターンの末尾カンマに対応するために末尾カンマを取り除いて本体に渡すための節 (letvec![$($pat:pat),*,]=$v:expr;)=\u0026gt;(match_vec!(letvec![$($pat),*]=$v;));// 本体 (letvec![$($pat:pat),*]=$v:expr;)=\u0026gt;(let($($pat),*)={// * exprで受けたので`vec![1, 2, 3]`などのまだ評価されていない式も来うる。 // 一旦変数に格納して評価させる。 // * ついでに`mut`をつけたりイテレータを取り出したり。 letmuti=$v.into_iter();// * `$()*`を使いたいが`$pat`は使わないので`ignore`を使って無視する // * お粗末だが`next()`に対して`unwrap()`している。 // 実行時のマッチ失敗panicを投げる余裕があるなら投げるべき。 letret=($({ignore!($pat);i.next().unwrap()}),*);// 同じくvecが余った場合の検査を`assert!`に丸投げしている。 assert!(i.next().is_none());ret};)} 使い方\nfn main(){letv=vec![1,2,3];match_vec!{letvec![x,y,z]=v;}// 上の式を展開するとこうなるはず。 // // // 複数のパターンマッチをタプルのマッチに落とし込んでいる。 // let (x, y, z) = { // // (マニアックな話):Rustのマクロは衛生的なのでマクロ内で定義した`i`がgensym(rename)される。 // let mut i_xxx = v.into_iter(); // let ret = ( // {ignore!(x);i_xxx.next().unwrap()}, // {ignore!(y);i_xxx.next().unwrap()}, // {ignore!(z);i_xxx.next().unwrap()}, // ); // assert!(i_xxx.next().is_none()); // ret // }; println!(\u0026#34;x: {}, y: {}, z: {}\u0026#34;,x,y,z);// -\u0026gt; x: 1, y: 2, z: 3 } 興味があるならHashMap向けのものも書くと練習になるかもしれません。\nerr! 定義自体はシンプルです。\nmacro_rules!err{($e: expr)=\u0026gt;{returnErr($e.into())}} 使うのもシンプル\nfn fact(n: i32)-\u0026gt; Result\u0026lt;i32,String\u0026gt;{ifn\u0026lt;0{err!(\u0026#34;n is negative\u0026#34;)}letmutret=1;foriin1..(n+1){ret*=i;}Ok(ret)}fn main(){println!(\u0026#34;{:?}\u0026#34;,fact(-3));// -\u0026gt; Err(\u0026#34;n is negative\u0026#34;) } シンプルですがreturnのようにコントロールフローに干渉するようなものは関数では書けなくて、マクロが必要になります。\ndefine_error_enum! エラーハンドリングのときに複数のエラーを束ねるenumの実装を生成するやつです。 現実的にはerror_chainなどのちゃんとしたものを使うべきですが、似たようなケースに遭遇したときに自分でボイラープレートを削減出来るマクロを書けると便利です。\nmacro_rules!define_error_enum{// 普通のenumっぽく書けるようにパターンを工夫してある。 // 無骨に型名、列挙子と対応するエラー型名だけを受け取っても本質は変わらない。 ($(#[$meta:meta])*pubenum $name: ident{$($variant: ident($ty: ty),)*})=\u0026gt;{// この`$(#[$meta])*`を用意しておくとユーザは好きにderiveなどを書ける。 $(#[$meta])*pubenum $name{// 本当はvariantにもmetaをつけれるようにすべきだが、面倒なので読者の課題とする $($variant($ty),)*}// 各型毎に`From`を実装 $(implFrom\u0026lt;$ty\u0026gt;for$name{fn from(e: $ty)-\u0026gt; Self{$name::$variant(e)}})*// この型自体もErrorになるように諸々実装。 // 実装は内部のエラーにdelegateするだけ。 impl::std::fmt::Displayfor$name{fn fmt(\u0026amp;self,f: \u0026amp;mut::std::fmt::Formatter)-\u0026gt; ::std::fmt::Result{useself::$name::*;matchself{$(\u0026amp;$variant(refe)=\u0026gt;e.fmt(f),)*}}}impl::std::error::Errorfor$name{fn description(\u0026amp;self)-\u0026gt; \u0026amp;str {useself::$name::*;matchself{$(\u0026amp;$variant(refe)=\u0026gt;e.description(),)*}}fn cause(\u0026amp;self)-\u0026gt; Option\u0026lt;\u0026amp;::std::error::Error\u0026gt;{useself::$name::*;matchself{$(\u0026amp;$variant(refe)=\u0026gt;Some(e),)*}}}}} 結構大きいですがほぼボイラープレートなのでマクロとしてはあんまりおもしろいことはやってないです。\n使い方ですが、まずエラー型を適当に用意しましょう。\nusestd::fmt;usestd::error::Error;#[derive(Debug)]pubstruct Error1;implfmt::DisplayforError1{fn fmt(\u0026amp;self,f: \u0026amp;mutfmt::Formatter)-\u0026gt; fmt::Result{write!(f,\u0026#34;this is error1\u0026#34;)}}implErrorforError1{fn description(\u0026amp;self)-\u0026gt; \u0026amp;str {\u0026#34;error1 occurred\u0026#34;}fn cause(\u0026amp;self)-\u0026gt; Option\u0026lt;\u0026amp;Error\u0026gt;{None}}#[derive(Debug)]pubstruct Error2;implfmt::DisplayforError2{fn fmt(\u0026amp;self,f: \u0026amp;mutfmt::Formatter)-\u0026gt; fmt::Result{write!(f,\u0026#34;this is error2\u0026#34;)}}implErrorforError2{fn description(\u0026amp;self)-\u0026gt; \u0026amp;str {\u0026#34;error2 occurred\u0026#34;}fn cause(\u0026amp;self)-\u0026gt; Option\u0026lt;\u0026amp;Error\u0026gt;{None}} そして\n//ほぼenumの定義っぽく書ける define_error_enum!{#[derive(Debug)]pubenum GenericError{E1(Error1),E2(Error2),}}fn main(){// intoを自動で実装した lete: GenericError=Error1.into();// displayを自動で実装した println!(\u0026#34;{}\u0026#34;,e);// -\u0026gt; this is error1 } 便利ですね。\nこういった、「もうちょっとすっきり書けないかな」「ほぼコピペなコードが量産されるんだけどどうにかならないの」な状況にマクロが便利です。\nマクロプログラミング ここからはプログラミングの余興、サーカス的プログラミングの世界です。\nRustのマクロには再帰(ループ)とパターンマッチ(分岐)があるのでチューリング完全です。 そう訊いたらとりあえずプログラミングしてみたくなりますよね？\n最初の試み そう聞いたあなたはすぐさま(1, ...)で数値を表すことにして以下のようなマクロを書き下すでしょう。\nmacro_rules!add{(($($l: tt),*),())=\u0026gt;{($($l),*)};(($($l: tt),*),(1))=\u0026gt;{(1,$($l),*)};(($($l:tt),*),(1,$($r: tt),*))=\u0026gt;{add!((1,$($l),*),($($r),*))};}macro_rules!sub{(($($l: tt),*),())=\u0026gt;{($($l),*)};((1$(,$l: tt)*),(1))=\u0026gt;{($($l),*)};((1$(,$l:tt)*),(1$(,$r: tt)*))=\u0026gt;{sub!(($($l),*),($($r),*))};}macro_rules!fib{(())=\u0026gt;{(1)};((1))=\u0026gt;{(1)};(($($n:tt),*))=\u0026gt;{add!(fib!(sub!(($($n),*),(1))),fib!(sub!(($($n),*),(1,1))))};}fn main(){letn=fib!((1,1,1));println!(\u0026#34;{:?}\u0026#34;,n);} しかしこれはうまく動作しません。\nerror: no rules expected the token `fib` --\u0026gt; macro.rs:29:14 | 29 | add!(fib!(sub!(($($n),*), (1))), fib!(sub!(($($n),*), (1, 1)))) | ^^^ ... 34 | let n = fib!((1, 1, 1)); | --------------- in this macro invocation error: aborting due to previous error error: Could not compile `macro`. To learn more, run the command again with --verbose. internal error: cargo failed with status 101 これはマクロの展開の順序が絡んできます。 普通の関数だと内側から展開されますが、マクロは外側から展開するので問題が起きます。 fib!の第3節の本体はadd!(sub!($($n),*, (1)), sub!($($n),*, (1, 1)))ですね。 このマクロ式の呼び出しは外側から、つまりadd!から展開されます。 add!は(sub!($n, (1)), sub!($n, (1, 1)))に対してパターンマッチしようとして失敗しているのです。\nさて、どうしましょう。普通にはプログラミングできません。外側から展開していたものを内側から展開するようにうまいことやる手段はあるでしょうか。\nそう、みなさんならおわかりですね。「CPSするとlazyをeagerに変換できる」というやつです。正確にはCPSじゃありませんが。\nck! コードと継続からなる抽象マシン、CKマシンをマクロで適当にエミュレートするのがck!マクロです。詳しくはこの記事を→ syntax-rulesズンドコキヨシ、またはマクロ展開時ズンドコキヨシ。 雑に言うとコールスタックを自前で実装したらネストしたマクロ呼び出しもできるよねってやつです。 ただちょっと面倒なのが引数が複数あるので呼び出しの深さに応じてスタックを縦に積むのと引数の数に応じて中身を横に広げるの2つの操作がある点ですね。これはスタックにタプルを積むことで解決します。\nまた、rust特有の問題として、マクロ呼び出しがname ! (args...)と3トークンに分かれてしまうのでやや扱いに気をつける必要があります。 もう一つ、値をマクロと同じように扱わないと対応するパターンが爆発してしまうのでLispでいうquote相当のものとしてq!という目印を使います。 これはck!マクロ内で目印として使っているだけのものなので特に実体は必要ありません。\n// ck(スタック, 式)という形で評価していく。なんとなく継続を起動してるイメージ // 評価が終わったら`q!(値)`という形で目印を付ける // // スタックは以下のような形。 // [(マクロ名, (まだ評価していない引数...), (評価が終わった引数 ...)), ...] // // ここで受け取るマクロは全てスタックを第一引数に取るものとする。CPSでいう継続っぽいもの。 macro_rules!ck{// スタックが空で値が出来ているなら値を返す ([],q!($value:tt))=\u0026gt;{$value};// 評価対象がマクロ呼び出しならスタックに積んで第一引数から評価を始める ([$($stack:tt),*],$name:ident!($argn:ident!$arga:tt,$($args: tt)*))=\u0026gt;{ck!([($name,($($args)*),())$(,$stack)*],$argn!$arga)};// コンマの扱いのために1引数の場合も別途定義 ([$($stack:tt),*],$name:ident!($argn:ident!$arga:tt))=\u0026gt;{ck!([($name,(),())$(,$stack)*],$argn!$arga)};// 無引数マクロは即時評価 ([$($stack:tt),*],$name:ident!())=\u0026gt;{name!([$($stack),*])};// 1つの引数の評価が終わって、まだ評価していない引数があるなら // 評価が終わったリストにその値を加えてまだ評価していない引数を評価する ([($name:ident,($todon:ident!$todoa:tt,$($todos:tt)*),($($dones:tt),*))$(,$stack:tt)*],q!($value:tt))=\u0026gt;{ck!([($name,($($todos)*),($($dones,)*$value))$(,$stack)*],$todon!$todoa)};// コンマの扱いのためにtodoが1つの場合も別途定義 ([($name:ident,($todon:ident!$todoa:tt),($($dones:tt),*))$(,$stack:tt)*],q!($value:tt))=\u0026gt;{ck!([($name,(),($($dones,)*$value))$(,$stack)*],$todon!$todoa)};// 全ての引数を評価したなら満を持してマクロを呼ぶ。コールスタックを渡しているので帰ってこれる。 ([($name:ident,(),($($dones:tt),*))$(,$stack:tt)*],q!($value:tt))=\u0026gt;{$name!([$($stack),*],$($dones,)*$value)};} このCKマクロを使うと次のようにマクロを定義できます。\nmacro_rules!add{($s:tt,($($l:tt),*),())=\u0026gt;{ck!($s,q!(($($l),*)))};($s:tt,($($l:tt),*),(1))=\u0026gt;{ck!($s,q!((1,$($l),*)))};($s:tt,($($l:tt),*),(1$(,$r:tt)*))=\u0026gt;{ck!($s,add!(q!((1,$($l),*)),q!(($($r),*))))};}macro_rules!sub{($s:tt,($($l: tt),*),())=\u0026gt;{ck!($s,q!(($($l),*)))};($s:tt,(1$(,$l: tt)*),(1))=\u0026gt;{ck!($s,q!(($($l),*)))};($s:tt,(1$(,$l:tt)*),(1$(,$r: tt)*))=\u0026gt;{ck!($s,sub!(q!(($($l),*)),q!(($($r),*))))};}macro_rules!fib{($s: tt,())=\u0026gt;{ck!($s,q!((1)))};($s: tt,(1))=\u0026gt;{ck!($s,q!((1)))};($s: tt,($($n:tt),*))=\u0026gt;{ck!($s,add!(fib!(sub!(q!(($($n),*)),q!((1)))),fib!(sub!(q!(($($n),*)),q!((1,1))))))};} これで念願のfib!マクロが動きます。\nfn main(){letn=ck!([],fib!(q!((1,1,1,1,1))));println!(\u0026#34;{:?}\u0026#34;,n);// -\u0026gt; (1, 1, 1, 1, 1, 1, 1, 1) } ただしマクロの再帰が深くなるので#![recursion_limit = \u0026quot;256\u0026quot;]が必要となります。\nおわりに マクロは便利な使い方もアホな使い方もできるよって話でした。\n","categories":["Rust","マクロ"],"category_urls":["/categories/rust","/categories/%e3%83%9e%e3%82%af%e3%83%ad"],"date":"2018-02-17","title":"マクロクラブ Rust支部","url":"https://KeenS.github.io/blog/2018/02/17/makurokurabu_rustshibu/"},
  {"body":"κeenです。寝れない。前回のエントリでRocksDBのことを勘違いしていたようだったので改めてRocksDBについて書きます。\n個人的理解をメモした雑多な記述です。\nLSM-Tree まず、私は勝手にRocksDBはロックフリーなスキップリストを使って並列性能をあげたDBだと思ってたんですが間違ってました。 使っているのはLog-Structured_Merge-Treeのようです。 Log Structured File Systemに名前が似てるな〜思ったらやはりそこ由来のデータ構造のようです。 ファイルシステムも一貫性が必要なKVSですからまあ、参考になりますよね。 LSM-Treeについては元論文の他このスライドが多少参考になります。\n重要なのは\n 削除や更新は論理操作。ストレージのデータは基本はイミュータブル メモリのデータとストレージのデータ2つ合わせて完全 読み取りはメモリとストレージなど複数箇所から読んで複数値をマージする ストレージのデータは時々コンパクションされる  この辺がRocksDBのAPIに反映されています。\nRocksDB LSM-Treeベースの実装が色々ある中RocksDBはかなり実装上の工夫を加えたらしいです。 ここにすごい量載っています。これはLevelDBとの差分だけなのでLevelDBでの工夫も加えたらすごいことになるんですかね。 RangeやPrefixクエリにbloom filterが使えたりトランザクションをサポートしていたりRDBのバックエンドとして使うには嬉しそうな機能が一杯ですね。\n勘違いとか 前回の記事の勘違いを指摘していきます。\n RocksDBのDelete自体は Status を返すので判別可能\n これはDelete操作がエラーになったかどうかしかわかりません。多分論理削除なので元の値が存在したかどうかは高速には判断できないんでしょう。putが存在したかどうか判定できないのも恐らく同じ理由。\n keyMayExistのラッパも存在しないので\n KeyMayExistはMayがあるようにtrueを返したところで値が存在することは保証しません。falseだったら存在しないのは確実。恐らくbloom filterしか見ないんでしょう。因みに実装見に行ったら常にtrue返すように見えたんですが気のせいですかね？だとしても仕様には違反しませんが。\n  どうやら非同期クエリもできるらしい？だったらTokioと相性よさそう   これは WriteOptions の sync を見て言ったのですがこの sync の意味はOSのバッファリングもストレージに同期する、つまりシステムコールの sync の意味でした。\nその他APIについて APIでなんかよくわからない概念があったりこれなんだろみたいな関数があったりしたのがよく調べたらわかったのでメモ\n ColumnFamilyはただの名前空間 SnapShotが気軽に取れるのに納得。 SingleDeleteは追記されていない場合にのみ使える。論理削除じゃなくて物理削除？ megrgeは恐らくreadの副産物 ","categories":["DB","RockDB","Rust"],"category_urls":["/categories/db","/categories/rockdb","/categories/rust"],"date":"2018-02-08","title":"改めましてRocksDBさん","url":"https://KeenS.github.io/blog/2018/02/08/aratamemashiterockdbsan/"},
  {"body":"κeenです。進捗ダメです。最近全然コード書いてないのでたまには手を動かすかということでRocksDBにHello Worldしてみます。\nRocksDBとは RocksDBはアプリケーション組み込み向けに作られた永続化KVSです。 主に高速性、SSDなどの高速なストレージに合わせたアーキテクチャ、アプリケーションとの親和性、基本操作の他マージなどの高度なオペレーションを特徴としているようです。\nFacebookのDBエンジニアリングチームが作っていて、MyRocksなんかのバックエンドに使われています。 GoogleのLevelDBを下敷きに作られている模様。\n私が知ったきっかけはやはりMySQL互換プロトコルを喋る分散DBのTiDBがバックエンドに使っているからでした。\nHello, RocksDB いくら新しいとはいえ、ただのKVSなので使い方はそんなの難しくないはず。とりあえず使ってみましょう。 RocksDB自体はC++で書かれているのですが私はC++はわからないのでRustから叩いてみます。\n色々ラッパはあるようですがひとまず一番ダウンロードされているrocksdbを使います。 これはあまりラッピングが上手くなく、先述のTiDBはフォークしているなど不穏なのですが問題があるなら直せばいいの気持ちでやっていきます。\nまずはクレートドキュメントのサンプルコードを動かしてみましょう。\nuserocksdb::DB;// NB: db is automatically closed at end of lifetime letdb=DB::open_default(\u0026#34;path/for/rocksdb/storage\u0026#34;).unwrap();db.put(b\u0026#34;my key\u0026#34;,b\u0026#34;my value\u0026#34;);matchdb.get(b\u0026#34;my key\u0026#34;){Ok(Some(value))=\u0026gt;println!(\u0026#34;retrieved value {}\u0026#34;,value.to_utf8().unwrap()),Ok(None)=\u0026gt;println!(\u0026#34;value not found\u0026#34;),Err(e)=\u0026gt;println!(\u0026#34;operational problem encountered: {}\u0026#34;,e),}db.delete(b\u0026#34;my key\u0026#34;).unwrap(); open_default したあとは put , get , delete とわかりやすいですね。 実行してみます。\n$ cargo run retrieved value my value  はい。動きました。\nmemcached このままだと面白くないのでmemcachedのプロトコルを喋ってみましょう。\nプロトコルのドキュメントはここにあります。\nエンジン たくさん実装するのはだるいのでひとまずは set, get, delete を実装します。no_replyとcasは無視しましょう。 プロトコルを読むに、以下のデータ型を用意すればよさそう。\ntype Result\u0026lt;T\u0026gt;=::std::result::Result\u0026lt;T,rocksdb::Error\u0026gt;;#[derive(Debug, Clone, PartialEq, Eq)]struct Value{pubdata: Vec\u0026lt;u8\u0026gt;,pubflags: u32,pubexptime: i64,}#[derive(Debug, Clone, PartialEq, Eq)]enum Command\u0026lt;\u0026#39;a\u0026gt;{Set{key: \u0026amp;\u0026#39;a [u8],value: Value},Get{keys: \u0026amp;\u0026#39;a [\u0026amp;\u0026#39;a[u8]]},Delete{key: \u0026amp;\u0026#39;a [u8]},}#[derive(Debug, Clone, PartialEq, Eq)]enum CommandRet\u0026lt;\u0026#39;a\u0026gt;{Stored,Got(Vec\u0026lt;(\u0026amp;\u0026#39;a[u8],Value)\u0026gt;),Deleted,NotFound,} getのキーを複数にした人の気がしれませんが仕様にそう書いてあるのでこれでいきます。\nまずは実行部分から。 イメージ、これが動くようにします。\nfn main(){letengine=Engine::new(\u0026#34;path/for/rocksdb/storage\u0026#34;).unwrap();letcommands=vec![Command::Set{key: b\u0026#34;key\u0026#34;,value: Value{data: b\u0026#34;value\u0026#34;.to_vec(),exptime: 0,flags: 0,},},Command::Get{keys: \u0026amp;[b\u0026#34;key\u0026#34;]},Command::Get{keys: \u0026amp;[b\u0026#34;no such key\u0026#34;]},Command::Delete{key: b\u0026#34;key\u0026#34;},Command::Get{keys: \u0026amp;[b\u0026#34;key\u0026#34;]},Command::Delete{key: b\u0026#34;key\u0026#34;},];forcmdincommands{println!(\u0026#34;query: {:?}\u0026#34;,cmd);matchengine.exec(cmd){Ok(ret)=\u0026gt;println!(\u0026#34;{}\u0026#34;,ret),Err(e)=\u0026gt;println!(\u0026#34;error: {}\u0026#34;,e),}}} まあ、ただのインタプリタですね。ディスパッチ部分まではサクッと作れます。\nと、その前にvalueのシリアライザ/デシリアライザを作っておきましょう。 データの末尾8byteを使って flags と exptime を保存すればいいですかね。 exptime はクライアントとのやりとりのために i64 にしてますが負値の場合は保存せずにそのまま捨てるので32bitで十分です。\nfn encode_be(b: u32)-\u0026gt; [u8;4]{[((b\u0026gt;\u0026gt;24)\u0026amp;0xff)asu8,((b\u0026gt;\u0026gt;16)\u0026amp;0xff)asu8,((b\u0026gt;\u0026gt;8)\u0026amp;0xff)asu8,(b\u0026amp;0xff)asu8,]}fn decode_be(bytes: [u8;4])-\u0026gt; u32 {(bytes[0]asu32)\u0026lt;\u0026lt;24+(bytes[1]asu32)\u0026lt;\u0026lt;16+(bytes[2]asu32)\u0026lt;\u0026lt;8+bytes[3]}implValue{fn pack(self)-\u0026gt; Vec\u0026lt;u8\u0026gt;{letmutdata=self.data;data.extend_from_slice(\u0026amp;encode_be(self.flags));data.extend_from_slice(\u0026amp;encode_be(self.exptimeasu32));data}fn from_vec(mutdata: Vec\u0026lt;u8\u0026gt;)-\u0026gt; Value{letlen=data.len();assert!(len\u0026gt;8);letflags=decode_be([data[len-8],data[len-7],data[len-6],data[len-5]]);letexptime=decode_be([data[len-4],data[len-3],data[len-2],data[len-1]]);letexptime=exptimeasi64;data.truncate(len-8);Value{data,flags,exptime,}}} はい、ではディスパッチ部分まで。\nstruct Engine{db: DB,}implEngine{pubfn new\u0026lt;P: AsRef\u0026lt;Path\u0026gt;\u0026gt;(path: P)-\u0026gt; Result\u0026lt;Self\u0026gt;{letdb=DB::open_default(path)?;Ok(Self{db: db})}pubfn exec\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;self,cmd: Command\u0026lt;\u0026#39;a\u0026gt;)-\u0026gt; Result\u0026lt;CommandRet\u0026lt;\u0026#39;a\u0026gt;\u0026gt;{matchcmd{Command::Set{key,value}=\u0026gt;{let()=self.set(key,value)?;Ok(CommandRet::Stored)}Command::Get{keys}=\u0026gt;{letv=self.get(keys)?;Ok(CommandRet::Got(v))}Command::Delete{key}=\u0026gt;{ifself.delete(key)?{Ok(CommandRet::Deleted)}else{Ok(CommandRet::NotFound)}}}}fn set\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;self,key: \u0026amp;\u0026#39;a [u8],value: Value)-\u0026gt; Result\u0026lt;()\u0026gt;{...}fn get\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;self,keys: \u0026amp;\u0026#39;a [\u0026amp;\u0026#39;a[u8]])-\u0026gt; Result\u0026lt;Vec\u0026lt;(\u0026amp;\u0026#39;a[u8],Value)\u0026gt;\u0026gt;{...}fn delete\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;self,key: \u0026amp;\u0026#39;a [u8])-\u0026gt; Result\u0026lt;bool\u0026gt;{...}} この set, get, delete のそれぞれの関数を実装していきます。\nまずは set 。 exptimeが負値ならばその場でexpireとのことなのでそうします。 put のセマンティクスがcreate or updateらしいのでそれを使えばOK。\n/// create, update or delete the kv pair fn set\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;self,key: \u0026amp;\u0026#39;a [u8],value: Value)-\u0026gt; Result\u0026lt;()\u0026gt;{ifvalue.exptime\u0026lt;0{self.db.delete(\u0026amp;key)}else{self.db.put(\u0026amp;key,\u0026amp;value.pack())}} つぎはget。\n取得したデータが期限切れしてたら消します。時刻を扱うのに chronoを使いましょう。\n返り値はベクトルです。keysのうち、見つからないものはスルーするらしいです。すごい仕様ですね。 Result と Vec と Option が出てきて煩雑ですが Iterator のテクニックを弄することなく地道に手続き的にがんばりましょう。 因みにRocksDB自体にはMultiGetがありますがラッパは作られていません。\n/// find data and collect only found data fn get\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;self,keys: \u0026amp;\u0026#39;a [\u0026amp;\u0026#39;a[u8]])-\u0026gt; Result\u0026lt;Vec\u0026lt;(\u0026amp;\u0026#39;a[u8],Value)\u0026gt;\u0026gt;{letmutret=Vec::new();for\u0026amp;keyinkeys{matchself.db.get(\u0026amp;key)?{None=\u0026gt;(),Some(v)=\u0026gt;{letentry=Value::from_vec(v.to_vec());ifentry.exptime==0{ret.push((key,entry))}else{letnow=Utc::now();ifentry.exptime\u0026lt;now.timestamp(){self.db.delete(\u0026amp;key)?}else{ret.push((key,entry))}}}}}Ok(ret)} 次に delete です。残念なことに delete のラッパはキーの有無を区別してくれないので削除前に区別する必要があります(RocksDBのDelete自体は Status を返すので判別可能)。 さらに残念なことにkeyMayExistのラッパも存在しないので get をつかってチェックしましょう。\nfn delete\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;self,key: \u0026amp;\u0026#39;a [u8])-\u0026gt; Result\u0026lt;bool\u0026gt;{letexists=self.db.get(key)?.is_some();self.db.delete(key).map(|()|exists)} あとは出力のために CommandRet に to_vec を用意し、\nimpl\u0026lt;\u0026#39;a\u0026gt;CommandRet\u0026lt;\u0026#39;a\u0026gt;{fn to_vec(\u0026amp;self)-\u0026gt; Vec\u0026lt;u8\u0026gt;{useself::CommandRet::*;match*self{Stored=\u0026gt;b\u0026#34;STORED\\r\\n\u0026#34;.to_vec(),Got(refresults)=\u0026gt;{usestd::str::from_utf8;letmutret=Vec::new();for\u0026amp;(refkey,refvalue)inresults{ret.extend(format!(\u0026#34;VALUE {} {} {}\\r\\n\u0026#34;,from_utf8(key).unwrap(),value.flags,value.data.len()).as_bytes(),);ret.extend(\u0026amp;value.data);ret.extend(b\u0026#34;\\r\\n\u0026#34;);}ret.extend(b\u0026#34;END\\r\\n\u0026#34;);ret}Deleted=\u0026gt;b\u0026#34;DELETED\\r\\n\u0026#34;.to_vec(),NotFound=\u0026gt;b\u0026#34;NOT_FOUND\\r\\n\u0026#34;.to_vec(),}}} Display を実装してあげます。\n行儀が悪いですがデバッグでしか使わないので from_utf8 して unwrap しちゃいます。\nimpl\u0026lt;\u0026#39;a\u0026gt;fmt::DisplayforCommandRet\u0026lt;\u0026#39;a\u0026gt;{fn fmt(\u0026amp;self,f: \u0026amp;mutfmt::Formatter)-\u0026gt; fmt::Result{usestd::str::from_utf8;write!(f,\u0026#34;{}\u0026#34;,from_utf8(\u0026amp;self.to_vec()).unwrap())}} これで先程の main が動きます。\n$cargorunquery: Set{key: [107,101,121],value: Value{data: [118,97,108,117,101],flags: 0,exptime: 0}}STOREDquery: Get{keys: [[107,101,121]]}VALUEkey05valueENDquery: Get{keys: [[110,111,32,115,117,99,104,32,107,101,121]]}ENDquery: Delete{key: [107,101,121]}DELETEDquery: Get{keys: [[107,101,121]]}ENDquery: Delete{key: [107,101,121]}NOT_FOUND よし。\nプロトコル set key 0 0 value\\r\\n や get key* なんかのプロトコルをTCP経由で喋ります。 やや大仰ですがTCPの扱いに tokio を、パーサに nom を使います。tokioを使うとバッファリングを考えなくてよくなります。\n実行部分は作ったのでサービス部分はこのコードで十分です。\nusetokio_service::Service;usefutures::{Future,IntoFuture};struct MemcachedServer{engine: Engine,}implServiceforMemcachedServer{type Request=Command;type Response=CommandRet;type Error=io::Error;type Future=Box\u0026lt;Future\u0026lt;Item=Self::Response,Error=Self::Error\u0026gt;\u0026gt;;fn call(\u0026amp;self,cmd: Self::Request)-\u0026gt; Self::Future{Box::new(self.engine.exec(cmd).map_err(|err|io::Error::new(io::ErrorKind::Other,err)).into_future(),)}} Parser 実際のパーサを作ります。これはRocksDBへのHello, Worldなので適当に。\nusestd::str;usestd::str::FromStr;usenom::{digit,IResult,alphanumeric,space};named!(parse_cmd\u0026lt;\u0026amp;[u8],Command\u0026gt;,alt!(parse_set|parse_get|parse_delete));named!(parse_set\u0026lt;Command\u0026gt;,do_parse!(tag!(b\u0026#34;set\u0026#34;)\u0026gt;\u0026gt;space\u0026gt;\u0026gt;key: alphanumeric\u0026gt;\u0026gt;space\u0026gt;\u0026gt;flags: parse_u32\u0026gt;\u0026gt;space\u0026gt;\u0026gt;exptime: parse_i64\u0026gt;\u0026gt;space\u0026gt;\u0026gt;len: parse_u32\u0026gt;\u0026gt;tag!(b\u0026#34;\\r\\n\u0026#34;)\u0026gt;\u0026gt;data: take!(len)\u0026gt;\u0026gt;tag!(b\u0026#34;\\r\\n\u0026#34;)\u0026gt;\u0026gt;({letdata: \u0026amp;[u8]=data;Command::Set{key: key.to_vec(),value: Value{flags: flags,exptime: exptime,data: data.to_vec(),}}})));named!(parse_get\u0026lt;Command\u0026gt;,do_parse!(tag!(b\u0026#34;get\u0026#34;)\u0026gt;\u0026gt;space\u0026gt;\u0026gt;keys: separated_nonempty_list!(space,alphanumeric)\u0026gt;\u0026gt;tag!(b\u0026#34;\\r\\n\u0026#34;)\u0026gt;\u0026gt;(Command::Get{keys: keys.iter().map(|k|k.to_vec()).collect(),})));named!(parse_delete\u0026lt;Command\u0026gt;,do_parse!(tag!(b\u0026#34;delete\u0026#34;)\u0026gt;\u0026gt;space\u0026gt;\u0026gt;key: alphanumeric\u0026gt;\u0026gt;tag!(b\u0026#34;\\r\\n\u0026#34;)\u0026gt;\u0026gt;(Command::Delete{key: key.to_vec(),})));named!(parse_u32\u0026lt;u32\u0026gt;,map_res!(map_res!(digit,str::from_utf8),FromStr::from_str));named!(parse_i64\u0026lt;i64\u0026gt;,map_res!(map_res!(recognize!(do_parse!(opt!(tag!(b\u0026#34;-\u0026#34;))\u0026gt;\u0026gt;digit\u0026gt;\u0026gt;())),str::from_utf8),FromStr::from_str));#[test]fn test_parser(){assert_eq!(parse_cmd(b\u0026#34;delete key\\r\\n\u0026#34;),IResult::Done(\u0026amp;b\u0026#34;\u0026#34;[..],Command::Delete{key: b\u0026#34;key\u0026#34;.to_vec()}));assert_eq!(parse_cmd(b\u0026#34;get key1 key2\\r\\n\u0026#34;),IResult::Done(\u0026amp;b\u0026#34;\u0026#34;[..],Command::Get{keys: vec![b\u0026#34;key1\u0026#34;.to_vec(),b\u0026#34;key2\u0026#34;.to_vec()]}));assert_eq!(parse_cmd(b\u0026#34;set key 1 0 5\\r\\nhello\\r\\n\u0026#34;),IResult::Done(\u0026amp;b\u0026#34;\u0026#34;[..],Command::Set{key: b\u0026#34;key\u0026#34;.to_vec(),value: Value{exptime: 0,flags: 1,data: b\u0026#34;hello\u0026#34;.to_vec(),}}));} はい、できました。\nCodec パーサを使ってtokioのCodecとProtoを実装します。multiplexはしたくないのでpipelineで。\nusebytes::BytesMut;usetokio_io::codec::{Encoder,Decoder};usetokio_proto::pipeline::ServerProto;struct MemcachedCodec;implEncoderforMemcachedCodec{type Item=CommandRet;type Error=io::Error;fn encode(\u0026amp;mutself,cmd: Self::Item,buf: \u0026amp;mutBytesMut)-\u0026gt; io::Result\u0026lt;()\u0026gt;{Ok(buf.extend(cmd.to_vec()))}}implDecoderforMemcachedCodec{type Item=Command;type Error=io::Error;fn decode(\u0026amp;mutself,buf: \u0026amp;mutBytesMut,)-\u0026gt; ::std::result::Result\u0026lt;Option\u0026lt;Self::Item\u0026gt;,Self::Error\u0026gt;{let(read,cmd)=matchparse_cmd(buf){IResult::Done(rest,cmd)=\u0026gt;{letread=buf.len()-rest.len();(read,cmd)}IResult::Incomplete(_)=\u0026gt;returnOk(None),IResult::Error(_)=\u0026gt;{returnErr(io::Error::new(io::ErrorKind::Other,\u0026#34;invalid protocol\u0026#34;))}};buf.advance(read);Ok(Some(cmd))}}struct MemcachedProto;impl\u0026lt;T: AsyncRead+AsyncWrite+\u0026#39;static\u0026gt;ServerProto\u0026lt;T\u0026gt;forMemcachedProto{// For this protocol style, `Request` matches the `Item` type of the codec\u0026#39;s `Decoder` type Request=Command;// For this protocol style, `Response` matches the `Item` type of the codec\u0026#39;s `Encoder` type Response=CommandRet;// A bit of boilerplate to hook in the codec: type Transport=Framed\u0026lt;T,MemcachedCodec\u0026gt;;type BindTransport=::std::result::Result\u0026lt;Self::Transport,io::Error\u0026gt;;fn bind_transport(\u0026amp;self,io: T)-\u0026gt; Self::BindTransport{Ok(io.framed(MemcachedCodec))}} Main 最後にmainをサーバに書き換えます。\nfn main(){// Specify the localhost address letaddr=\u0026#34;0.0.0.0:12345\u0026#34;.parse().unwrap();// The builder requires a protocol and an address letserver=TcpServer::new(MemcachedProto,addr);// We provide a way to *instantiate* the service for each new // connection; here, we just immediately return a new instance. server.serve(||{Ok(MemcachedServer{engine: Engine::new(\u0026#34;path/for/rocksdb/storage\u0026#34;).unwrap(),})});} 動きます。\n$cargorun#別ターミナルで$telnetlocalhost12345Trying127.0.0.1...Connectedtolocalhost.Escapecharacteris\u0026#39;^]\u0026#39;.setkey005helloSTOREDgetkeyVALUEkey05helloENDdeletekeyDELETEDgetkeyEND 良かったですね\n課題 へっぽこmemcachedサーバは置いとくとして、RustのRocksDBラッパには問題がありましたね。\n keyMayExistがない deleteがstatusを見ない  さらに、他の問題もあります。\n どうやら非同期クエリもできるらしい？だったらTokioと相性よさそう 複数コマンドを発行しているが、スレッドセーフでない。トランザクションが必要だが、Rustのラッパが存在しない  今回はHello Worldなのでまだラッパの方の問題にばかり目が行きますがもう少し掘ると何か出てくるかもしれません。 今日はこの辺で。\n","categories":["DB","RockDB","Rust"],"category_urls":["/categories/db","/categories/rockdb","/categories/rust"],"date":"2018-02-05","title":"Hello, RocksDB","url":"https://KeenS.github.io/blog/2018/02/05/hello__rocksdb/"},
  {"body":"κeenです。情報科学若手の会冬の陣2018 #wakate2018wでライブコーディングしてきたのでその補足です。 Rustはunwrapを多用する言語ではありません。\nコード お題はカレントディレクトリ以下のファイルのサイズを数えるduみたいなもの。 書いたコードはこれ。\nusestd::path::Path;usestd::fs::read_dir;usestd::env;fn count_dir\u0026lt;P: AsRef\u0026lt;Path\u0026gt;\u0026gt;(path: P)-\u0026gt; u64 {read_dir(path).unwrap().map(|e|{lete=e.unwrap();ife.metadata().unwrap().is_file(){e.metadata().unwrap().len()}elseife.metadata().unwrap().is_dir(){count_dir(e.path())}else{0}}).sum()}fn main(){letpath=env::args().nth(1).unwrap();println!(\u0026#34;{}\u0026#34;,count_dir(path));} unwrapまみれでひどいですね。\nこれを書き直したらこうなります。\nusestd::path::Path;usestd::fs::read_dir;usestd::env;usestd::io;fn count_dir\u0026lt;P: AsRef\u0026lt;Path\u0026gt;\u0026gt;(path: P)-\u0026gt; io::Result\u0026lt;u64\u0026gt;{read_dir(path)?.map(|e|{lete=e?;letmeta=e.metadata()?;ifmeta.is_file(){Ok(meta.len())}elseifmeta.is_dir(){Ok(count_dir(e.path())?+meta.len())}else{Ok(0)}}).sum()}fn main(){letpath=env::args().nth(1).unwrap();println!(\u0026#34;{}\u0026#34;,count_dir(path).unwrap());} ほぼcount_dirの返り値をio::Result\u0026lt;u64\u0026gt;にしてunwrapを?にしただけですね。?便利!。\nduと出力が合わない問題 $ du ./ ... 5553252 ./ $ rust du.rs ./ 4404925617650  ライブコーディングの時はちょっとずれてると思ったんですがよくみたら桁が違いますね。 これはどうやらduがディスク上の専有スペースの推定を出すかららしく、ちゃんとオプションをつけたらそれっぽくなりました。\n#-bでファイルサイズの合計を出す$du-b./4403619672761./ だいだい合ってそう。\n何故かrust版の方がファイルサイズが多い問題 duと出力が合わない問題突き詰めるとrust版の方が処理しているファイルが多くなってます。 原因不明。duはバイナリやrlibファイルの一部をスルーしているようですが規則性分からず。識者求む。\n何故か読めないファイルがある問題 ただのsymlinkでした\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2018-02-03","title":"情報科学若手の会冬の陣2018でライブコーディングしてきた","url":"https://KeenS.github.io/blog/2018/02/03/jouhoukagakuwakatenokaifuyunojin2018deraibuko_dingushitekita/"},
  {"body":"κeenです。「XX言語はデフォルトイミュータブルだ」とか「この機能を使うとイミュータブルになる」とかのもの、よく混乱が見受けられますよね。 ユーザの勘違いもありますし言語毎に指しているものが違ったりするので整理してみます\nシャドーイング イミュータブルなはずなのに変数が上書きできてしまう、あれ？というやつです。\n以下のようなClojureのコードを考えます。\n(def x 1) (println x) (def x 2) (println x) 馴れてないと（どちらかというと束縛と代入を一緒くたにする言語に毒されてると）「xに2回代入しようとしてるからエラーになるか2回目は無視されて1のままのはず」と考えてしまいます。 しかし実際の実行結果はエラーにはならず、\n1 2 と更新されています。 これは先述のとおり束縛と（再）代入を混同していると起きる勘違いです。 (def x 2)はもともとあったxという変数を上書きしているわけではなく、xとは別の新しい変数xを作っているだけです。 わかりやすく書くとこうです\n(def x_1 1) (println x_1) (def x_2 2) (println x_2) 変数束縛の度に新たにスコープが導入されると考えるのです。 Clojureには再代入がないので分かりづらいですがイミュータブルな変数宣言と再代入の両方があるScalaならわかりやすいでしょう。\nobject Main extends App { val x = 1; println(x); // x = 2 // error: reassignment to val  locally { val x = 2; println(x); } }1 2 これはユーザの勘違いでよく起きる問題です。\nイミュータブルな値 これは半分は言語機能、半分はインターフェースの問題なのですが、値を変更できない(変更するような言語機能や関数が存在しない)言語もあります。 たとえばSMLには\n{ x = 1 } という値（レコード）を変更する手段はありません。 しかし\nval a = Array.fromList([1, 2, 3]); a (* =\u0026gt; [|1,2,3|] *) Array.update(a, 0, 2); a (* =\u0026gt; [|2,2,3|] *) のように変更するインターフェースを持つ型もあります。\n「デフォルトイミュータブル」といったときに「ほとんどの/全ての型は変更するインターフェースを持たない」ことを指す言語もあるようです。\n（イ）ミュータビリティの推移律 Scalaにはイミュータブルな変数宣言がありますが、値を変更することができます\nimport scala.collection.mutable.ArrayBuffer; object Main extends App { // イミュータブルな変数を宣言  val a = ArrayBuffer(1); println(a) // aに破壊的変更を加える  a += 2; println(a); } これを実行すると\nArrayBuffer(1) ArrayBuffer(1, 2) と書き換わってます。varを使っていないにもかかわらず変更ができてしまうんですね。\n同じようなことはJSでもできます。 constといういかにも定数を導入しそうな変数束縛の構文があります。\nconst a = { x: 1 }; console.log(a); a.x = 2; console.log(a); これを実行するとこうなります。\n{ x: 1 } { x: 2 } 一方、Rustで同じようなことをやるとエラーになります。\nfn main(){leta=String::new();println!(\u0026#34;{}\u0026#34;,a);a.push(\u0026#39;a\u0026#39;);// cannot borrow immutable local variable `a` as mutable println!(\u0026#34;{}\u0026#34;,a);} この「イミュータブルな変数に束縛されたオブジェクトを破壊的変更できるか」は（イ）ミュータビリティの推移律という言葉で分類されるそうです。イミュータブルな変数に束縛されたオブジェクトを変更できないなら推移律が成り立ち、逆ならば成り立たないというそう。 何かの言語を学ぶときに「この変数宣言はイミュータブルな変数を作る」と書いてあったら推移律が成り立つか気にしてみると学習が速くなるかもしれません。\n因みにここまで出てきた例だと方針に一貫性はあります。 変数に束縛してあるのはポインタだから再代入を禁止するのはポインタまでで、そのポイント先は自由に変更可能という考え方ですね。 Rustの値は暗黙に参照になっておらず、そのまま変数に束縛されているのでイミュータブルになるという考えるのです。 Rustでも(ミュータブルな)ポインタを経由すればイミュータブルな変数に束縛された値（のポイント先の値）を変更できます。\nfn main(){letmuta=1;letb=\u0026amp;muta;println!(\u0026#34;{}\u0026#34;,b);*b=2;println!(\u0026#34;{}\u0026#34;,b);}1 2 ただしこの考え方は飽くまでここに挙げた言語ではの話で、他にこの規則を破る言語もあるかと思います。\n追記 これなんだけどRustのinherited mutabilityは参照に対しても適用される点が非常に独特で、 \u0026amp;\u0026amp;mut Tから\u0026amp;mut Tは作れない。ところが変数のmutabilityは話が別で、これはその変数自体の\u0026amp;mut referencingを禁止するという限定的な効果しかない。κeenさんの例はそっちに該当している。\n\u0026mdash; Masaki=就寝=Hara (@qnighy) 2018年1月27日 \nRustのミュータビリティの扱いは突き詰めると中々複雑なのでおいとくとして、「ミュータビリティの推移律」と言っていたのは「ミュータビリティの継承」（継承したミュータビリティの方が近い？）の間違いでした。 これはひどい。\n","categories":["小ネタ"],"category_urls":["/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2018-01-27","title":"「イミュータブル」って多義的だよね","url":"https://KeenS.github.io/blog/2018/01/27/imyu_taburu_ttetagitekidayone/"},
  {"body":"κeenです。 非エンジニアのマネージャがエンジニアチームと上手くやる方法の記事に影響を受けてエンジニアとしての意見を書いてみようかなと。 非エンジニア向けのつもりです。\nここでいうエンジニアはソフトウェアエンジニアのことです。\nDisclaimer  ある程度客観的になるように気をつけてますがあくまで私個人の意見です。エンジニアを代表するようなものではありません。 κeenはまだエンジニア3年目くらいの若造なのて「それは違うんじゃねーの」と思ったところがあったら多分あなたが正しいです。  仕事内容 エンジニアの仕事は外から見たら何してるかよくわからないらしいですね。 ふつう仕事の成果物はエンジニアの間でしか共有してないのでまあ、そうなるでしょう。 なので「何をしているか」を説明するのはやめて「仕事しているときにどんな気持ちか」を話しましょう。\nエンジニアの仕事は頭脳労働です。 それも問題解決が主な仕事で、解決策を考えてはプログラムとして打ち込んでいくので、学校の試験を受けているときの感覚に近いでしょうか。 この感覚があればエンジニアの生態の謎の半分くらいは理解出来るようになるかと思います。\n 部屋がうるさいと嫌なのは集中出来ないからです 作業中に話しかけられると嫌なのは集中が途切れるからです  一旦切れると「あれ、今何してたっけ」と思考が振り出しに戻ってしまいます 会話や電話でなくチャットツールを好むのは自分のタイミングで見に行けるからです この感覚がわからない人は3桁x3桁の掛け算をやってる途中で話しかけられると分かるようになるらしいです  お菓子やコーヒーを消費するのは集中力は長続きしないからです  ドラゴン桜によると90分が限界らしいです 限界がきたらリフレッシュが必要です   試験のたとえを続けましょうか。 試験は人によって出来/不出来があったと思います。 プログラミングにもあります。 東大の入試のような難しい問題は優秀なエンジニアでないと解けず、凡人をいくら集めても解決できません。 難しい問題とは逆に夏休みの宿題のような簡単だけど量が多くて煩雑な問題もあります。 これもみなさんの経験にあるように頭のいい人は大体こういうのも手際よくこなしますね。 優秀なエンジニアも概ね量だけ多い作業も速く終わらせます。 さらにはエンジニアは簡単な機械的作業は自動化するので「機械的作業を自動化する問題」を簡単に解ける人、解けない人でまた差が付きます。 こうした解ける/解けない、手際がいい/わるいがあるのがエンジニアの生産性は人によって10倍、100倍違うと言われる部分です。\nさて、仕事を試験に例えましたが教科はなんだと思いますか？ 一見数学っぽいですが国語に近い部分もあります。扱っているのがプログラミング「言語」ですからね。 もちろん、やりたいことと現状のギャップを考えてどの手順を踏めば簡単に、確実に実現できるかを考えるのがエンジニアリングの大部分です。 そういった解法を考えるのは知識や論理的思考能力が試される部分でしょう。 でも、その解法はほとんどがプログラミング言語を通して記述されます。 プログラミング言語は人間が読むためのものなので読みやすいプログラム、読みづらいプログラムというのがあります。 作業の手順の説明が上手い人下手な人がいるようにエンジニアにも読みやすいプログラムを書く人、読みづらいプログラムを書く人がいます。 そこの上手さが優秀さの指標の一つですね。 ただし、この「読みやすい」が万人に読みやすいとは限りません。それなりの知識を要求することがあるからです。 これはどうでしょうか。\n二次方程式 $ax^2 + bx + c (a \\not= 0)$ の解は\n $b$を自乗したものから$4$と$a$と$c$を乗じたものを引いて開平したものを$b$の符号を反転したものに加減し、$2$と$a$を乗じたもので除すれば求められる 解の公式 $\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$ で求められる  上記の2つの説明、数式の知識があれば2の方がすぐに理解できるかと思います。 しかし数式がわからなければただの呪文です。 このように良いコードは読み手(=チームメンバー)のレベルに応じて変わります。 なので平凡な人の集まりに一人だけ優秀な人が交じると力をセーブしながらプログラミングしなければいけません。 この辺が採用や転職とも関わってくるところです。\nここまでの説明で元の記事にある\n  コーディングは作業ではなく、「アート」らしい。「何行コードを書いて、どれくらいバグが少ないか」などという指標で評価しようとすると「お前は画家を書いた絵の数で評価するのか？」と怒られるし、良いエンジニアは辞めていく。 数名の優秀な人が製品・サービスを動かしているという事実を受け入れる。非属人化は高いレベルでは無理。 一緒に働いているエンジニアはお互いの技量がわかっているらしい。人事の人が外から見てもわからないのに。   あたりは理解できるんじゃないかと思います。 最後の技量についてはだいたいコードに現れるのでコードを見ないことには何も評価できないのは当然ですね。 そして簡潔に問題を解決できる(大抵短い)のが良いコードなので量で評価するのもナンセンスです。\n人によって解ける問題が違うという話をしましたがこれは同じ人でも時々によって変わります。 寝不足だったり集中できてなかったりして頭が回ってないと問題を解決できないことがあります。それが次の働き方に関わってきます。\n働き方 営利企業の従業員は会社の利益を最大化するのが役目ですね。 エンジニアにとってはいかに効率的に問題解決をするかが鍵です。 特にパソコンは人間の作業を効率的にするための道具ですからその使い手であるエンジニアは効率化の鬼です。 効率化できるはずなのにしてないもの、合理的理由のないものは蛇蝎の如く嫌います。 社員は利益の最大化のために働くべきですし、評価は仕事の成果でのみ行われるべきです。 成果は出してるけど残業しないから評価は低いなんてものは受け付けません。\n勤務 たとえば朝遅い人が多いのはしっかり寝て集中力を発揮できる状態で仕事に取り組みたいからです。 先述のように集中できてないと出来るはずの作業も進まなくなります。 一日の中で最も集中できる8時間を仕事のために使おうとしてる訳なのでむしろプロ意識が高いんじゃないでしょうか。\n会議が嫌いなのも会議に遅れないように時間に気をつけてたら集中できなくなるからですし、 「参加者全員の時給を考えたらこの会議はそれだけの価値を生み出したのか」と考えているからです。 その会議、本当に価値がありますか？\n道具 椅子やパソコンやキーボードなど仕事道具が結構高いですよね。これはちゃんと合理的な理由があります。\nまず、これは絶対なのですが椅子は安物を使ってはいけません。 毎日長時間座りっぱなしなので椅子がよくないと腰を痛めます。腰痛はエンジニアの職業病の最たるものです。 整体通いの人が少なくない数いる程度には深刻な問題です。\nパソコンが高いのはプロの道具だからです。 もうちょっとちゃんとした説明をすると、エンジニアの作業は事務作業に使うよりもかなり多くの計算力を必要とするからです。 計算力の足りないパソコンで作業していると5秒に1回芯の折れるシャープペンで物書きをしている気持ちになります。 さらに作業は自動化すると書きましたが計算力の高いパソコンだと自動化されたタスクも速く終わるので結果仕事がよく進みます。\nキーボードやディスプレイなど人とのインターフェースになる機器にお金が必要なのももちろん作業の効率化のためです。 いくらエンジニアが優秀でパソコンがハイスペックでも互いのやりとりのためのキーボードやディスプレイに限界があったら効率は上がりません。\nエンジニアの給料とこれらの値段と寿命を考えるにお金を出した方が得なはずです。\n少し脇道に逸れると、ソフトウェア(アプリ)にも自由を与えた方がいいです。これもプロの道具ですから。 「セキュリティのために…」というのであれば少なくとも社員のエンジニアよりもソフトウェアに詳しい人が決めたルールで運用して下さい。\n嫌いなもの 先述のように効率的でないもの、合理的でないものが嫌いです。\n書類は電子データであれば場所も取らないし手間もないはずなので嫌いです。 書類仕事が苦手なのは目の前の作業よりそういった理不尽さへの不満が頭の大部分を占めるからです。\nスーツを着たくないのは着る合理的理由がないからです。 あれって見た目のために着心地を犠牲にしたものですよね。 見た目が業績に関係する仕事でもないのに着る意味はありません。 あと全く不合理なのにスーツを強要する組織そのものも嫌いです。\n手作業も嫌いです。 これは嫌いというより嫌えと教えられるものです。 手作業は非効率的だしコストがかかるし人間なのでミスをするし同じミスを何度もするしどこでミスをするかもわからない代物です。 可能なら機械に作業をやらせるべきです。 また、「ミスがありました。改善策は注意することです。」というのも嫌いです。 どうせまたミスをするので解決策になってないからです。人間を介在させないようにするのが解決策なはずです。\nメールが苦手なのは単純に社会人力が低いからです。 エンジニアはあなたが人と向き合ってきた時間を機械と向き合うのに使ってきた人たちなので対人能力が低めです。 社会人然とした文章を中々書けないのです。ごめんなさい。\n社内政治も嫌いです。「こっちの方が合理性がある、こうしよう」「データによるとこの方が効率的らしい」で決まるのが正しい姿だと思ってます。 営利企業が合理性以外で物事を進めようとするのは理解に苦しみます。\nあとはルールや過度なマネジメントを嫌う人も多いです。私も嫌いです。 それなりに「干渉されたくない」というわがままも入ってるでしょう。 しかし合理的理由なしに「そういうものだから」「伝統だから」などの理由で存在し続けるルールは無意味ですね。 あるいは全体でみると合理的理由はあるけど比較的ITリテラシーの高いエンジニアには無意味みたいなルールも嫌ったりします。 他にも性悪説で運用されるルールは大多数にとってはただ単に不便なだけなので不満だったり。 人数が100人未満なら性善説、100人を超えたら性悪説になるらしいのでそういう人は小さな会社に転職したりします。 これに関してはあんまり客観的理由が思いつかないのでわがままだけどできれば理解してくれ、という気持ちです。\nあとは対人能力が低いのでパーティや社員旅行など「みんなで集まってワイワイやろうぜ」なイベントは嫌う人がいます。 特に大勢集まるのが嫌という人もいます。 あるいは「その時間で勉強してた方がよっぽど身のためになる」というストイックな考え方も。 就活やインターンとかでの懇親会が嫌でその会社はやめたという人がちらほらいます。 因みに私はそういうのは好きです。\n好きなもの 言わずもがなで技術のことは好きです。特に新しい技術は。 なぜ「新しい」技術が好きなのかは私の中でいくつか仮説があります。\n1つにはそもそも知的好奇心からエンジニアになった人が多いからです。 新しいおもちゃを欲しがる子供のように知的好奇心を満たすために新しい技術を求める。\n1つには生きるために必要と考えているからです。 IT業界は変化の速い世界なので泳ぎ続けないと死んでしまうマグロのように新しい技術を取り込まないと死んでしまうという考え方ですね。 私はこのことを説明するのに鏡の国のアリスの赤の女王の「その場にとどまるためには、全力で走り続けなければならない」の比喩が好きです。 これは個人だけでなく会社にも当てはまる考え方です。\n1つには投資と考えているからです。今あるものをどうにかしてよりよくしたい。今はまだないけどもしかしたら将来解決できるかもしれない。 そんな期待を込めて新しい技術を調査する訳です。誰しも「今はまだ実用的でないけど1年後には使えるかもしれない技術リスト」のようなものがある筈です。 これも半分は個人のため、半分は会社のためですね。\n現実的にはこれらの複合なんですかね。\n綺麗に問題を解決したシステムも好きです。 どれだけ単純に問題を解決できているか、どれだけエラー(障害)に強いか、どれだけ速いか、どけだけ仕様変更に強いかなどなどが優れていれば興味深いシステムになります。 自社のシステムをもっと改善できると思うなら改善(リファクタリング)したくなりますし、もうどうしょうもないと思ってしまったら転職したくなります。 これは業績にかなり影響することもあれば、たまにただの自己満足なこともあります。 自己満足を窘めるのに「壊れてないものは直すな」なんて言われたりします。加減が難しいですね。\nフリードリンクやフリーなおやつを求める人が多い気がします。 あるいはもうちょっといって卓球台などの軽く体を動かせる設備も。 これは先述のとおり集中が切れたときにリフレッシュするために必要ですが、別に自分で買うこともできるのでわがままの範疇かなと思ってます。 ただ、コスパよく社員を満足させられるので福利厚生を充実させたいならアリだと思います。 単純にうれしいだけでなく、こうすると作業が捗るんだよね？と理解があることのアピールになります。\n文化 元の記事で指摘されているように仕事と趣味の境界がない人が一定数います。 そういう人は他人より技術に触れる時間が長いので優秀な人が多いでしょう。 優秀な人ほど目立つのでみんなそのように感じるかもしれませんが仕事は仕事、な人もそれなりにいると思います。 仕事でしか技術に関わらないけどすごく優秀な人もいるはずですが、恐らくそういう人は特にSNSとかには現れないので我々が目にすることはないでしょう。\n「家に帰ってまで仕事をするのは理解できない」と思われるかもしれませんが、趣味と仕事でやってることが違います。 趣味は完全に自分の好きなことをやっています。 お金にならないからこそ面白いものがあったり仕事ではまだ使えないような尖った技術を試したり単純に自分が満足するためにやるものです。 仕事はワクワクするようなこともありますが基本は会社がお金儲けをするためのものです。運良く面白い仕事にありつけることもありますが大体は少し興味から外れたことだったりただの作業のようなものです。\n最新の技術ニュースに向けて常にアンテナを張っているのでSNSをよく使います。業務中も。 遊んでいることもありますが新しいニュースが流れてこないかなと待ち構える意味もあります。\n勉強会をよくします。有志で集まって好きな人が登壇してなんか喋るやつです。 勉強会とはいっても「うちはこんなシステムでやってるんだぞ、すごいだろ」「最近こんなこと考えたんだけどみんなどう思う？」といった自慢大会みたいな側面があります。 あるいは同業者で集まる同窓会だったり。それを以って勉強会に行くくらいなら家で勉強してろなんて意見もあります。 個人的にはすごいシステムや最新技術の解説を自慢されると参考になりますし、失敗事例も他山の石になるので有益かなと思ってます。 特に社内勉強会はそういう情報共有の場になってるので非常にためになります。 社外に向けては採用の機会に、社内に向けては横のつながりの促進と技術の向上につながるので可能なら会議室やセミナールームを貸してくれると嬉しいなと思います。\n年収の話を他職種より、よくする気がします。全体的に売り手市場で転職すれば年収が上がる傾向にあるから、というのが一因と思います。 しかしそれだけでなくて年収を戦闘力のように一種の技術力のステータスとして使ってるような気もします。 「あそこは年収2000万円のエンジニアをずらりと集めてる」「あなたはもっと年収が高くて然るべき。転職したら？」など。 年収を高くすると他職種以上に喜ぶかもしれませんね。\nキャリア エンジニアは転職が多いですね。 先述の通り売り手市場というのも原因の一端でしょう。あるいは新しい会社がどんどん出来てくるので興味を惹かれて。 もう一つにはもし現状に満足していても「今が本当に最適な形なのだろうか」という疑問を払いきれないからかなと思います。 最適な技術構成、最適な職場、最適な組織を探す旅に出る感覚で組織を変えている気がします。 「同じ組織に10年\u0026rdquo;も\u0026rdquo;居てしまった」なんて言葉はよく耳にします。 この文化は基本的には個人の利益のためのものです。 会社のメリットがあるかと言われるとうーん。 業界全体で多様な見識を持った人が育つとはいえ採用コストや最初の業務に馴れるまでのスロースタート期間のコストを払う訳です。 そのコストはどうなるの？と考えてみると他社との競争コストになるのかなと考えます。 ここが最適解だと思わせる職場を作るか競争コストとして受け入れるかしかないのかなあと思います。\n1つ重要な話に昇進をしたくないというのがあります。 正確にいうとマネジメントをする側になりたくない。 野球少年が夢見るのはイチローであって監督ではありません。 そして優れた選手であっても監督に向くとは限らないように優れたエンジニアであってもマネジメントがうまいとは限りません。 マネージャーにはマネジメントに向いた人がなるべきで、プレーヤに向いているだけでマネジメントは出来ない人を割り当てても全員が不幸になるだけです。 なので、\n エンジニアリング能力を評価されると何故かマネージャーにされる会社 同じ話ですがマネジメント能力を評価されてる訳でもない人が何故かマネージャーをやってる会社 何故かマネージャーにならないと給料が上がらない会社  はとことん嫌います。昇進の機会を増やすために中間管理職を一杯作って結果意思決定が遅くなってるような会社は見向きもしないでしょう。 「昇進する=人の上に立つ=偉い=給料が高い」と考えはしません。 技術力で利益に貢献して対価として給料が上がればそれで満足です。 もし別の形で実力を認めたいとしても「スキルレベル」のような技術力を元にした評価が求められています。 たとえばS1からS7までのランクがあってある程度実力が認められると昇格するなど。\nもちろん現場への理解のあるマネージャーが必要というのも分かってます。 エンジニアの中にはマネージャーを目指すような人もいますしあるいは現場サイドのリーダー、スポーツチームでいうキャプテンくらいならやれるという人もます。 それでもやっぱり現場への理解とマネジメント能力両方を備えている人は稀有で優秀なエンジニア以上に求め難いのかなーと感じてます。 多分本人の意思を聞きつつ社内で育てるのが一番確実なんですかね。\n最後に 元記事の補完をしつつ被りつつ脱線しつつという感じですかね。 もうちょっと書きたいこともありますが十分すぎるほど長いのでここまで。\n本当に拙い文章で思いの丈を綴ったら長くなってしまって恥ずかしい限りです。 特に「エンジニアは」などと主語の大きい書き方ばかりしているので随分炎上しそうな気がしますね。 本当に公開したくない。でも書いたからには公開します。\n最後までお読みいただきありがとうございます。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2018-01-12","title":"エンジニアの働き方とかについてのエモい記事","url":"https://KeenS.github.io/blog/2018/01/12/enjinianohatarakihoutokanitsuitenoemoikiji/"},
  {"body":"κeenです。New Year\u0026rsquo;s Rust: A Call for Community Blogpostsの一環のつもりです。 恐らく英語の記事が望まれてるんだろうなと思いつつも試しに日本から声を上げてみます。\n私はRustは1.0前後の頃から触っていて、ドキュメントの翻訳をしたりここ1年くらいはIdein Inc.での業務でも使っています。\n1年ほど使ってみて何が足りないか考えてみます。\n言語 Associated HKT 本当は一般のHKTがあると便利ですがひとまずはAssociatedなものが欲しいです。RFCでいうとこれです Generic associated types (associated type constructors) 。 欲しい状況は1つにはRFCと似たようなものなので割愛します。\nGeneralなHigher Kinded Typesが欲しいのはtransaction-rsの解説でも説明したように、返り値をResult\u0026lt;T, E\u0026gt;とBoxFut\u0026lt;T, E\u0026gt;どちらでもいいように抽象化したいケースなどです。\n\u0026amp;[u8]と[u8;32]の相互運用 32要素を手で詰め替えるのでつらいです。例えばこのコードとか。\nこれはAdd TryFrom and TryInto traitsが入れば解決します。\n上記で「できない」はなくなりますが、例えば[u8;32]-\u0026gt;[u8;16]のように切り詰めたいケースで少し不便です。一旦\u0026amp;[u8]を経由しないといけないからです。 しかしこれを直接変換できるようにするとそれはそれで困難が付いてきます。[u8; n] -\u0026gt; [u8; m] where m \u0026lt;= nの制約が必要になってConst Genericsでもまだ機能が足りないですね。難しい。\nライフタイムとTCOの保証 簡潔にいうと、一部でいいのでTail Call(Recursion) Optimizationを保証して欲しいです。今は最適化を有効にするとrustcは事実上TCOをしますが言語的に保証はしていなかったかと思います。 ループで書けばいいじゃんという気もしますが 末尾再帰をループにできないRustプログラムの例 にあるようにライフタイムの関係でループだとダメなケースもあるわけです。 #[inline]アトリビュートのように#[tco]アトリビュートがあると良いなーという気持ちです。\nZero Cost New Type New Type Pattern, つまり何かの型Tをstruct S(T);のようにunary structで包むパターンがあります。 これをあらゆるケースでゼロコストにしたいです。 例えば以下のようなケースでコピーコストが発生しますが、本当はcoerceで済むはずです。\n#![feature(test)]externcratetest;usetest::Bencher;#[derive(Clone)]struct Wrap(i32);#[bench]fn no_op(b: \u0026amp;mutBencher){b.iter(||vec![1;1024*1024].into_iter().collect::\u0026lt;Vec\u0026lt;i32\u0026gt;\u0026gt;());}#[bench]fn rewrap(b: \u0026amp;mutBencher){b.iter(||{vec![1;1024*1024].into_iter().map(Wrap).collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;()});}$ rustc --version rustc 1.23.0 (766bd11c8 2018-01-01) $ rustc +nightly -Copt-level=3 --test nop_optimize.rs $ ./nop_optimize --bench running 2 tests test no_op ... bench: 794,861 ns/iter (+/- 36,187) test rewrap ... bench: 1,800,202 ns/iter (+/- 136,487) test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured; 0 filtered out  ツール 書いてて思ったのですがやっぱりマクロ周りのサポートが欲しいですね。\nインタラクティブ環境 一つにはrustiのようなREPLが欲しいです。 私はLisperなのでどうしてもREPLで動作確認してからコードを書きたくなります。\nもう一つにはGHCiのように「この値の型」「この型が実装しているトレイト一覧」のようなコンパイラが知っている情報を引き出したいです。 Rustはマクロがあるので知らないコードが生えてきがちです。コードだけでは全貌がわからないのでマクロまで解析したコンパイラから情報が引き出せると便利です。\nrustfmt, clippy, rlsなどのstable化 みなさんがどう使っているのか知りたいというのも含めて、開発ツールがnightlyでしか動かないのがちょっと困ります。 業務でRustを書いているのでstableで動くツールのみ使っています。 rustfmtの旧版を使っていますし、人が増えたときのことも考えてclippyも使いたいのですがそれにはnightlyを要求されます。 コンパイラ内部のASTを利用しているのでstable化しづらいのは分かりますがどうにか頑張ってほしいところ。\nrustfmtのマクロサポート stable版のrustfmtを使っているのでもしかしたら最新のrustfmtではもう対応されているのかもしれませんが、マクロ内のRustコードが整形されません。 マクロ引数内ではシンタックス情報が取れないのは分かりますがexprだけでも整形してくれると嬉しいなと。\nrustcに速くなって欲しい dieselを使っているとDBスキーマから大量のコードが生成されます。 そして型安全にするためにトレイトを駆使した型付けがされてます。 これが結構コンパイルに時間が掛かります。 cargo checkで90%の問題は解決してるのですがCIでのビルドなどのようにどうにもならないケースがあるので可能なら速くしたいです。\nコミュニティ 公式Webなどが翻訳の差分が追いづらい 最近何もしてなくてあまり言えた口じゃないんですが、rust-wwwの翻訳の話です。無造作に更新されるので翻訳者はどこまで翻訳してどこを更新したかが非常に追いづらいです。 git localizeなどのツールを導入してほしいなと思います。\nあと地味にRust is Universalが永遠に執筆されないのは構造的問題なのではと思っています。 英語でドキュメントを書けてかつ他言語への翻訳もやっている人は少ないと思うので。\n終わりに 「今年の抱負」のような大きな目標ではなく細々した内容が多かったですね。 概ねRust Teamに信頼を置いているというか大きな方針には不満がないのでこういう小手先の話が多くなりました。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2018-01-05","title":"Rustに何が欲しいだろう","url":"https://KeenS.github.io/blog/2018/01/05/rustninanigahoshiidarou/"},
  {"body":"κeenです。毎年恒例です。個人的に注目していきたい技術と飛び込んでみたい技術を書いていきます。\nあくまで個人的な内容なので悪しからず。\nSwagger (OpenAPI Specifitation) YAMLで書いたREST APIの仕様からドキュメント、クライアントコード、サーバコードのテンプレートを生成するツール。\nネットワーク経由でなんらかのプロトコルを喋るとき、仕様とクライアントとサーバで独立してしまうとそれぞれで齟齬が出る。 プロトコルの詳細以外コードはどれも似たようなものになる訳だし自動生成できると望ましい。 仕様からクライアントとサーバのテンプレートが出てくる感じ。 一応「コードが仕様だ」みたいなものはいっぱいあるしサーバコードから生成も考えられる。 けどサーバが出来上がるまでクライアントが生成できないのはいただけないし何より言語に依存してしまう。 言語非依存に書けるのはやっぱり仕様。\nそのようなツールスタックを持ったものとしてThriftがある。 個人的にThriftのツーリングは好きなんだけどThriftの(シリアライズ)プロトコルが独自でThriftにロックインされてしまうので公開APIとかには使いづらい。\n一方Swaggerはツーリング自体はThriftと似ているが対象ドメインがREST APIなので公開APIにも使える。 さらにドキュメントも書けるしJSONやXML以外にも画像ファイルなんかも扱える、認証もある、と大体機能が揃ってる。\n個人的にはADTをもうちょっとスマートにエンコード出来たら嬉しいなという気持ち。\nSwaggerの対抗馬としてGraphQLもある。 ほぼデータベースのラッパのようなREST APIにとってはこちらの方がサーバの実装もクライアントの使い勝手も良さそう。 あとはツーリングの問題だけどそこがコミュニティベースなので言語によって温度感マチマチになるだろうなあという感想。\ndiesel Rustのクエリビルダー/ORM。\nそれだけだと「ああ、そう」という気分だが、型安全性を追求した点が面白い。 型安全性を追求した結果いくつか興味深い性質が付いてきている。 1つには大堀先生の目指す「式は型が正しい限り自由に組み合わせることができる」を実現出来ている件。 サブクエリに名前を付けたりして可読性の高いコードが書ける。 もう1つにはその逆、正しく型付けされたクエリDSLはほとんどSQLエラーを起こさない件。 RustとSQLの多言語開発がある程度Rustのみの開発に落とせる。 最後に、型付が細かくできているので型からSQLがほぼ従い、プリペアドステートメントを最大限活用出来る件。 文字列クエリよりクエリビルダーを使ったほうが速いのは驚き。\nもう一つ興味深い点はクエリビルダーファーストで開発されている点。 SQLをRustの上に再現し、その結果から可能な範囲でデータ型にマップする。データ型が対応するのはテーブルでなくてクエリ結果。 オブジェクト指向に寄せるために宣言的なSQLの詳細を隠して手続き的にする方向でなくてSQLを出来る限りそのまま使わせる。 それにSELECT, INSERT, UPDATEでデータ型を分けるのもよく分かってる感じがする。\nそして一番の驚きはこれの作者がRails/ActiveRecordの開発もしている点。かなり設計思想が違う気がするけどActiveRecordで悟りを開いた結果なんだろうか。\nGotham RustのWebアプリケーションフレームワーク。\n非同期かつマルチスレッドで、Stable主義なのが良い。 非同期かつマルチスレッドを目指すとRustでは1つ問題が生じる。 サーバのデータをどう持つか。Rustはデータ競合を許さないので共有状態はMutexで包む必要がある。 多くのRustのWAFはそうしている。しかし個人的にはそこに疑問がある。 どうせ1マシンで完結しないのだからマシン内で(スレッド間)共有状態を持つ必要はないのではないか。 スレッドごとにデータをコビーして共有状態はRedisやRDBに置いておくのが自然な設計なのではないか。\n実はhyperの非同期版(つまり0.11)はそういう設計になっている。 非同期WAF側が余計なことをしなければ自然と実現できるはずだ。\nGothamはそれを実現できている。逆に、Gotham以外にそれを実現できているものが見当たらなかった。 もう一つのGothamのセールスポイントはhyperのデータを生で扱える点。 とりあえずhyperで使えるHTTP系の拡張（例えばmultipartなど）を上流のコード変更なしに使える。\nCoq 酉年も終わったけどまだ引き続き。SF終わったあとにCPDTとVFAやるまで継続。\nIdris 去年に引き続き。思ったより依存型プログラミングが楽しかった。 あと型情報が強いし基本的にtotalだったりと静的な情報が多くてかなりアグレッシブな最適化ができるはずなのでそこも期待したい。最適化の論文とかないかな。\n線形論理 Girardの元論文やまとめたやつ（？）を読むぞというだけ。 線形論理そのものは竹内外史の本を読んだのだが照井先生の線形論理の誕生を読むにその基礎づけやproof netが面白そうなのでそこに踏み込んでみたい。\nベクトル最適化 これもHigh Performance Compilers for Parallel Computingを読むというだけ。社内で読書会やるとかやらないとかいいつつ結局何も動いてない。\n2018-01-05追記 量子コンピュータ 量子コンピュータ Advent Calendar 2017に触発されて。 量子コンピュータのためのプログラミング言語がいくつか出てるけど自分でも設計してみたくなった。 ここによるとCNOT取れるQUBitにも制限があるみたいだしある程度コンパイラが頑張るのかなあとか思ってる。\n量子プログラミング言語がどうなるのかまだイメージがつかめてない。 チューリングマシンを模倣出来るらしいし普通のプログラミング言語にbit演算的なノリでアダマール演算とかが入るんだろうか。それとも実質アクセラレータとして使われるだけだから半分アセンブラみたいな言語になるんだろうか。 少なくともそれくらいは判断付くように勉強したい。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2018-01-04","title":"2018年注目していきたい技術","url":"https://KeenS.github.io/blog/2018/01/04/2018nenchuumokushiteikitaigijutsu/"},
  {"body":"κeenです。年始に2017年注目していきたい技術 | κeenのHappy Hacκing Blogってのを書いたので雑に振り返ります。あと個人的な一年の総括を。\n※個人メモなので雑多な記述が多いです。\n2017年注目していきたかった技術 今年一年でどうなったかを見ていく。\nWebAssembly 各ブラウザでも使えるようになったし盛り上がってる。 WebAssembly Advent Calendarも盛況だったし個人的にもGCを書いた。\nRustやClangがemscriptenを通さず吐けるようになってるしツーリング周りでも改善された。\n今の所ゲーム系の人が注目してるみたいだけどもっと裾野が広がったらいいな。\nQUIC 確実に進んでるはずなんだけど今年あんまり話題にならなかった。 個人的には古いやつだけど仕様を読んだ。 推奨になるのいつだろう。\nIdris 1.1.1も出てる。Idris Tutorialをこの年末でやった。 totalityを要求する部分と要求しない部分を分けたり、型から得られる情報が多い分インタラクティブ開発機能に力が入ってたり中々面白い。 来年も時間があればもう少しやっていきたい。\nLean ちらほら使ってる人がいるけど個人的には何もしなかった。\nCoq かなりスピードが落ちたけどまだソフトウェアの基礎をやってる。 この先AppelのVerified Functional AlgorithmsやAdam先生のCertified Programming with Dependent Typesもあるしまだまだ継続。CPDTは和訳もでるらしいし期待。\nFinagle そもそも今年はScalaを触ってない\nTokio tokioの0.1は出たしhyperも0.11からTokioを使うようになったし確実に普及してる。よかったよかった。\nTiDB 1.0もリリースされたし順調。 今までは技術的に面白いから注目してたけどそろそろ実用的かの目線で見るべきなんだろうか。\ntantivy 注目してなかったけど活発に開発されてるみたい。Apache Luceneのdrop-in-replacementになっていくのかな。\n個人的振り返り メトリクス ブログ記事32本、スライド9綴、mendeleyに突っ込んだ論文112綴、amazonで買った技術書10冊、GitHubのcontribution 1773回作ったレポジトリ10個。\n論文と本は全て読んだわけじゃない(むしろ本は読んだ方が少ない)けどだいたいこんな感じ。\n総括 一番大きな出来事は年始の転職とそれに付随する引っ越し。 Scala(Javaも少し)を使っていた職場からよくわからないところに入ってRustを書くようになった。なのでRustのコードを書く時間は圧倒的に多くなったし仕事から派生していくつかライブラリも作った1 2 3 4 5 6。\nもう一つ大きなのはクローズドなプロジェクトが1つ走っていて、プライベートがそっちに割かれた。なので例年に比べてアウトプットもインプットも少ない。できれば年内にカタを付けたかったが間に合わそうなのでもうちょっと。 あと年明けからなんか始まる感じなのでクローズドなのが2つになる。\nこれらの影響で致命的にまずいのがRustのドキュメントの翻訳がほぼ止まってしまった件。先述のとおり来年もまだ忙しそうなので後任を探したい。\nあと地味に危機感を持ってるのがやっぱプライベートが削られてオープンなコードを書く習慣が 減ってきた件。本も読めてない。エンジニアとして死にそう。\n2017年は何も出来なかったので2018年はもうちょっと進捗を出したい。小説なんかも含めて積読が21あるのでそれの消化とか。岳飛伝の刊行に消化が追いついてない。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2017-12-31","title":"2017年注目していきたかった技術の振り返りと個人的振り返り","url":"https://KeenS.github.io/blog/2017/12/31/2017nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri/"},
  {"body":"κeenです。 どこかで紹介したつもりでしたが意外に書いてなかったのでSMLのツールとかそういうのを紹介します。\n仕様 通称SML \u0026lsquo;97のThe Definition of Standard ML Revisedが現行の最新仕様です。最終更新は通称どおり1997年ですね。 本もありますがGitHub版の方がアクセスが良いでしょう。\nポータル SML Familyというところがあります。最終更新2016-04-04。大体の欲しい情報はここに書いてます。\nコンパイラ 上記SML Familyに列挙されてます。一応口コミを書いておくと、以下が有名どころでしょうか\nMLton: ソースはちょくちょく更新されてますが最終リリースは2013年。 実行速度が速い、拡張が多い、ランタイム表現も素敵と三拍子揃ったコンパイラですがwhole-program optimizationするためコンパイルはかなり遅いです。 Hello Worldするにも標準ライブラリごとコンパイルするので数秒かかります。\nSML/NJ: 最終リリースは2017-10-16。 MLtonには劣りますがそれなりに速く拡張が（おそらく一番）豊富な処理系です。 ただしx86しかサポートしてないのとインタラクティブシステムがメインなので最近だとちょっと使いづらいかもです。\nPoly/ML: 最終リリースは2917-11-27。 上記２つと比べて尖ったところはないですがピーキーなところもなく平均点を取るタイプのコンパイラです。 Isabelleはこれを使っています。\nMoscow ML: 最終リリースは2014-08-28。 Caml lightのフロントエンドをSMLに仕立てたコンパイラです。OCaml並みに使いやすいんじゃないですかね。\nSML#: 最終リリースは2017-08-31。 東北大で開発されているコンパイラです。実用的な処理系を目指して作られています。PolyやMoscowと何が違うのと言われると苦しいが個人的によく使います。 たまに謎拡張が入ります。\nエディタ EmacsとかVimとか古くからあるものはシンタックスハイライトとインデンティングくらいはサポートしてると思います。私はEmacsを使ってます。\nドキュメント 標準ライブラリ扱いのBasisのドキュメントがあります。\nパッケージマネージャ smackageというのがあります。最終更新 2016-03-07。 登録数は…21。正直smackageに頼るよりGitHub漁ったほうが良いです。\nビルドツール smbtというのがあります。最終更新 2015-09-16。 一応処理系に依存せずにビルドを宣言的に書けるはずですがあまり期待せずに各処理系推奨のビルド方法を使ったほうが無難。 昔サンプルを書いたことがあるので適当に参考にして下さい。\nテスト SML#付属のSMLUnitがよさそう？\nLint SML-Lintというのがあります。最終更新2013-03-24。\n未来 流石に仕様が1997年から変わらないのはきついので有志で仕様の拡張をしようと言うプロジェクトがあります。 その名もSuccessor ML。 最終更新2017-07-26。 細かなシンタックスシュガーの追加やプレリュードの追加などが入っているようです。\n同じくBasisを拡張しようとする動きもあります。最終更新 2016-08-16。 これは今見つけたので追えてませんがEitherが入ってたりするよう。\n終わりに SMLのエコシステムらしいものはありませんでしたね。 自分のブログざっと漁った感じ過去にこういうの書いてないらしいんですが本当ですかね？すごい既視感が…\n","categories":["ML","SML","Advent Calendar","Advent Calendar 2017","ML Advent Calendar"],"category_urls":["/categories/ml","/categories/sml","/categories/advent-calendar","/categories/advent-calendar-2017","/categories/ml-advent-calendar"],"date":"2017-12-24","title":"SMLのエコシステム（？）","url":"https://KeenS.github.io/blog/2017/12/24/smlnoekoshisutemu___/"},
  {"body":"κeenです。方々で言われる話ですがRustコンパイラの吐くバイナリはそこそこ大きいです。 この理由を自分で納得してなかったので追います。\n様々な理由からnightlyを使います。\n初期 $ cat hello.rs fn main() { println!(\u0026#34;Hello, World\u0026#34;); } $ rustc +nightly hello.rs $ ls -l hello -rwxr-xr-x 1 kim kim 5049344 12月 18 23:30 allocator  5MBくらいあります。等価なCのコード(gccでオプションなし)が8.2Kだったのでかなり大きいですね\n最適化 cargo --releaseと同じく-Copt-level=3を付けましょう。-Copt-level=sの方が小さくなりますが普段やらないので。\n$ rustc +nightly -Copt-level=3 hello.rs $ $ ls -l hello -rwxr-xr-x 1 kim kim 5049200 12月 18 23:27 hello ほんの少しだけ小さくなりました。\nデバッグシンボル stripしてませんね。デバッグシンボルを落とします。\n$ rustc +nightly -Copt-level=3 hello.rs $ strip hello $ ls -l hello -rwxr-xr-x 1 kim kim 461768 12月 18 23:35 hello 460KBくらいに減りました。 大体ここまでやったのがスタートラインですかね。 こっからもうちょいけずっていきます。\nLTO コンパイル時だけでなくリンク時にも最適化をします。\n$ rustc +nightly -Copt-level=3 -Clto hello.rs $ strip hello $ ls -l hello -rwxr-xr-x 1 kim kim 453544 12月 18 23:37 hello 数KB減りました\nアロケータ Rustはlibcのmallocでなくjemallocを使っています。そこが効いてるかもしれません。\n#![feature(alloc_system)]externcratealloc_system;fn main(){println!(\u0026#34;Hello, World\u0026#34;);} このように書き換えて\n$ rustc +nightly -Copt-level=3 -Clto hello.rs $ strip hello $ ls -l hello -rwxr-xr-x 1 kim kim 453544 12月 18 23:38 hello あれ！？減ってない strings hello | grep jemalloc でまだjemallocのシンボルが残ってるようですし何か失敗してるのかもしれません。\n原因がわからないので後回し。\npanicをやめる Rustはpanicしたときのために色々してます。panicしたら即座にabortするようにしてみましょう。\n$ rustc +nightly -Copt-level=3 -Clto -Cpanic=abort hello.rs $ strip hello $ ls -l hello -rwxr-xr-x 1 kim kim 433064 12月 18 23:41 hello 20KBくらい痩せました。\nstaticリンク staticします\n$ rustc +nightly -Copt-level=3 -Clto -Clink-args=-static -Cpanic=abort hello.rs $ strip hello $ ls -l hello -rwxr-xr-x 1 kim kim 412504 12月 18 23:46 hello もうちょい痩せました。\nopt-level=s ここまできたら最初は使わないと言っていたopt-level=sも試してみましょう\n$ rustc +nightly -Copt-level=s -Clto -Clink-args=-static -Cpanic=abort hello.rs $ strip hello $ ls -l hello -rwxr-xr-x 1 kim kim 408328 12月 18 23:49 hello もう数KBばかり。\n終わりに Rustのバイナリサイズが(デバッグシンボルを除いても)大きいのはjemallocのせいと思ってたんですがシステムアロケータを使っても改善しませんでしたね。\n因みに並行サポートを意識したRustは標準出力に吐くだけでも標準出力のロックを取って、と複雑なコードになっているので単純に見えるコードでもオーバーヘッドがありますね。\nシステムアロケータの件は納得いってないので追求したい。\n参考 Why is a Rust executable large?\nこちらではバイナリサイズが小さい上にjemallocをやめるとバイナリサイズが1/3くらいになってるのでやっぱり自分のやつは何かまちがってそう\n2017-12-19 追記: システムアロケータの本気 古いドキュメントを参考にしていると指摘されました。 ちゃんと書いたらできました。\n#![feature(alloc_system, allocator_api, global_allocator)]externcratealloc_system;usealloc_system::System;#[global_allocator]staticA: System=System;fn main(){println!(\u0026#34;Hello, World\u0026#34;);}$ rustc +nightly -Copt-level=z -Clto -Clink-args=-static -Cpanic=abort hello.rs $ strip hello $ ls -l hello -rwxr-xr-x 1 kim kim 145816 12月 19 10:06 hello 143KiB。Cと比べるとまだまだ大きいですが十分小さくなりました。\n因みに「よくやる」コンパイルオプションだとこうなります。\n$ rustc +nightly -Copt-level=3 hello.rs $ ls -l hello -rwxr-xr-x 1 kim kim 2587696 12月 19 10:10 hello $ strip hello $ ls -l hello -rwxr-xr-x 1 kim kim 186960 12月 19 10:10 hello 元のstrip前の5MBやstrip後の460KBに比べて半分(以下)です。 jemallocで最低限のバイナリへのオーバーヘッドの半分を占めていたことになります。\njemallocはlibcのmallocに比べて速かったりRustに都合の良い(消費メモリが少なくて済む)アロケーションをしてくれたりするので使われているのですがバイナリサイズを気にするならシステムアロケータを使うのも手でしょう。\njemallocとlibcのmallocのベンチマークは読者の課題とする。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2017-12-18","title":"Rustのバイナリが大きい理由","url":"https://KeenS.github.io/blog/2017/12/18/rustnobainarigaookiiriyuu/"},
  {"body":"# Rust \u0026 Swagger ---------------------- [【増席】RustのLT会！ Rust入門者の集い #4 ](https://rust.connpass.com/event/72649/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # Swagger ---------- * [The World's Most Popular API Tooling](https://swagger.io/) * JSON APIの定義からドキュメントとコードを生成 === # rust-server ------------- * 最近Rustのサポートが[入った](https://github.com/swagger-api/swagger-codegen/pull/6613) * 軽くデモ + [petstore](http://petstore.swagger.io/) * [issue](https://github.com/swagger-api/swagger-codegen/issues)なげよう   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2017-12-18","title":"Rust \u0026 Swagger","url":"https://KeenS.github.io/slide/rust___swagger/"},
  {"body":"κeenです。これはRust Advent Calendar 2017の記事です。 RustのORM、クエリビルダ、マイグレーションツールのdieselについて。 dieselについては公式チュートリアルを読めばだいたい使い始められるのですが、それだけでは足りないのでいくつか持ちネタを書きます。\ndiesel-1.0.0-beta1での情報です。\ntable! マクロ チュートリアルにはinfer_schema!を使ったDSLの自動生成が書かれてますが、table!マクロを使って自分で書くこともできます。\ntable!{posts{id-\u0026gt; Integer,Title-\u0026gt; Text,body-\u0026gt; Text,published-\u0026gt; Bool}} このときの型はdieselで定義されているSQL型を書きます。 このSQL型は特定のDBMにあるものも用意されていて、例えばPostgreSQLならこの辺やこの辺にあります。\nviewの扱い dieselは基本的にはviewをサポートしてません。 もちろんinfer_schema!はviewは見てくれないのでどうしても使いたい場合は上記table!マクロで生成します。 実際にSQLを発行してDBMに怒られるまでtypoとかに気づかないのでつらいですね。\nあとdieselの型的にはINSERTが書けてしまいます。もちろん実行時にはエラーになります。気をつけましょう。\nNewType Pattern 0.99.0からQueryableがネスト可能になったので\n#[derive(Queryable)]pubstruct PostId(pubi32);#[derive(Queryable)]pubstruct Post{pubid: PostId,pubtitle: String,pubbody: String,pubpublished: bool,} のようにidに個別の型を与えることができるようになりました。\nしかしちょっと注意が必要です。\nまずクエリがidのためにタプルを作らないといけなくなります。\ndsl::posts...// idを`(dsl::id,)` のようにしていしないといけない .select(((dsl::id,),dsl::title,dsl::body,dsl::published)).get_result(conn) また、find(id)のようにクエリビルダの引数に渡そうと思うともうちょっと工夫が必要です。 dieselのクエリビルダのDSLに混ぜるにはExpressionやToSqlのトレイトを実装しないといけません。\nとはいえ、どのidでも中身は同型なのでワンパターンです。これはマクロを用意すれば解決できて、\nusediesel::types::{Integer,ToSql,ToSqlOutput,IsNull};usediesel::backend::Backend;usestd::io::Write;usestd::error::Error;macro_rules!derive_for_ids{($ty: ty)=\u0026gt;{// `Expression`系を自動定義。 // このマクロはdieselで定義されている。 expression_impls!(BigInt-\u0026gt; $ty);// `ToSql`を定義 impl\u0026lt;DB: Backend\u0026gt;ToSql\u0026lt;BigInt,DB\u0026gt;for$ty{fn to_sql\u0026lt;W: Write\u0026gt;(\u0026amp;self,out: \u0026amp;mutToSqlOutput\u0026lt;W,DB\u0026gt;,)-\u0026gt; Result\u0026lt;IsNull,Box\u0026lt;Error+Send+Sync\u0026gt;\u0026gt;{ToSql::\u0026lt;BigInt,DB\u0026gt;::to_sql(\u0026amp;self.0,out)}}}} というマクロで一撃です。\nこのマクロは以下のように使います。\n#[derive(Queryable, Debug)]pubstruct PostId(i32);derive_for_ids!(PostId); このようにしてあげれば\npubfn find_post\u0026lt;\u0026#39;a\u0026gt;(conn: \u0026amp;SqliteConnection,id: PostId)-\u0026gt; Option\u0026lt;Post\u0026gt;{useschema::posts::dsl;dsl::posts// findの引数に`PostId`の値を渡せる .find(id).select(((dsl::id,),dsl::title,dsl::body,dsl::published)).get_result(conn).optional().expect(\u0026#34;Error finding\u0026#34;)} のようにPostIdのままDSLが使えます。\nenum dieselはSQLのenumをサポートしていません。なのでDB側ではIntegerで定義して、Rustのenumにマッピングしてあげることを考えます。\n因みに、復習も兼ねて、Rustのenumは全ての列挙子が引数を取らなければ(いわゆるC-like enumであれば)\npubenum Visibility{Public=0,Limited=1,Private=2,} のように数値を割り当てられますね(何も指定しなければ0始まりの連番です)。 そしてVisibility::Public as i32のように数値にキャスト可能です(逆はできません)。\nこれを用いて諸々のDSL化に使われているトレイトを実装します。先程と同じくExpression、ToSql、Queryableですがderive(Queryable)が使えないのでちょっと大変です。\n同じくワンパターンなのでマクロを定義してあげます。 enumの列挙子を全て捕捉しないといけないので先程とちょっと変わってenumの定義をラップする形にします。\nusediesel::types::{Integer,ToSql,ToSqlOutput,IsNull,FromSql,FromSqlRow,HasSqlType};usediesel::row::Row;usediesel::Queryable;usediesel::backend::Backend;usestd::io::Write;usestd::error::Error;macro_rules!define_enum{($(#[$meta:meta])*pubenum $name: ident{$($variant: ident=$val: expr,)*})=\u0026gt;{// 元のenumを定義 $(#[$meta])*pubenum $name{$($variant=$val,)*}// `ToSql`を定義 impl\u0026lt;DB: Backend\u0026gt;ToSql\u0026lt;Integer,DB\u0026gt;for$name{fn to_sql\u0026lt;W: Write\u0026gt;(\u0026amp;self,out: \u0026amp;mutToSqlOutput\u0026lt;W,DB\u0026gt;,)-\u0026gt; Result\u0026lt;IsNull,Box\u0026lt;Error+Send+Sync\u0026gt;\u0026gt;{ToSql::\u0026lt;Integer,DB\u0026gt;::to_sql(\u0026amp;(*selfasi32),out)}}// `Expression`系を自動定義 expression_impls!(Integer-\u0026gt; $name);// `Queryable`のために`FromSql`と`FromSqlRow`を定義 impl\u0026lt;DB: Backend\u0026gt;FromSql\u0026lt;Integer,DB\u0026gt;for$namewherei32: FromSql\u0026lt;Integer,DB\u0026gt;{fn from_sql(bytes: Option\u0026lt;\u0026amp;DB::RawValue\u0026gt;)-\u0026gt; Result\u0026lt;Self,Box\u0026lt;Error+Send+Sync\u0026gt;\u0026gt;{useself::$name::*;match\u0026lt;i32asFromSql\u0026lt;Integer,DB\u0026gt;\u0026gt;::from_sql(bytes)?{$($val=\u0026gt;Ok($variant),)*s=\u0026gt;Err(format!(\u0026#34;invalid {} value: {}\u0026#34;,stringify!($name),s).into()),}}}impl\u0026lt;DB: Backend\u0026gt;FromSqlRow\u0026lt;Integer,DB\u0026gt;for$namewherei32: FromSql\u0026lt;Integer,DB\u0026gt;{fn build_from_row\u0026lt;T: Row\u0026lt;DB\u0026gt;\u0026gt;(row: \u0026amp;mutT)-\u0026gt; Result\u0026lt;Self,Box\u0026lt;Error+Send+Sync\u0026gt;\u0026gt;{useself::$name::*;match\u0026lt;i32asFromSqlRow\u0026lt;Integer,DB\u0026gt;\u0026gt;::build_from_row(row)?{$($val=\u0026gt;Ok($variant),)*s=\u0026gt;Err(format!(\u0026#34;invalid {} value: {}\u0026#34;,stringify!($name),s).into()),}}}// `Queryable`を定義 impl\u0026lt;DB\u0026gt;Queryable\u0026lt;Integer,DB\u0026gt;for$namewhereDB: Backend+HasSqlType\u0026lt;Integer\u0026gt;,$name: FromSqlRow\u0026lt;Integer,DB\u0026gt;,{type Row=Self;fn build(row: Self::Row)-\u0026gt; Self{row}}}} というマクロを用意してあげます。\nこのマクロは\ndefine_enum!{#[derive(Debug, Clone, Copy)]pubenum Visibility{Public=0,Limited=1,Private=2,}} のように使います。\nそしたら以下のように構造体に含められますし、\n#[derive(Queryable)]pubstruct Post{pubid: PostId,pubtitle: String,pubbody: String,// `Visibility`が`Queryable`の中に pubpublished: Visibility,}#[derive(Insertable)]#[table_name = \u0026#34;posts\u0026#34;]pubstruct NewPost\u0026lt;\u0026#39;a\u0026gt;{pubtitle: \u0026amp;\u0026#39;a str,pubbody: \u0026amp;\u0026#39;a str,// `Visibility`が`Insertable`の中に pubvisibility: Visibility,} あるいはクエリビルダの中で\ndsl::posts.find(id)// `visibility`をselect .select(((dsl::id,),dsl::title,dsl::body,dsl::visibility)).get_result(conn) や\nletnew_post=NewPost{title: title,body: body,visibility: Visibility::Private,};insert_into(posts::table)// `visibility`をinsert .values(\u0026amp;new_post).execute(conn) のように使えます。\n終わりに 小ネタ集といいつつ3つくらいしか出てきませんでした。 まあ、その代わり内容が濃いめだったのでバランスが取れたかな？\nまた思いついたら随時投稿しようと思います。\n","categories":["Rust","Diesel","小ネタ","Advent Calendar","Advent Calendar 2017","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/diesel","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf","/categories/advent-calendar","/categories/advent-calendar-2017","/categories/rust-advent-calendar"],"date":"2017-12-16","title":"diesel小ネタ集","url":"https://KeenS.github.io/blog/2017/12/16/dieselshounetashuu/"},
  {"body":"κeenです。これは言語実装 Advent Calendar 201714日目の記事です。 JVMのコンパイラエンジンGraalと高速インタプリタ作成フレームワークのTruffleについて。\nこの記事の前に昨日の記事を読んでおくと理解の助けになるかもしれません。\nGraalについて 公式ページ/GitHub。\nOracle Labで開発されているJavaのJITエンジンの1つです。 JVMのコンパイラインタフェース(JVMCI)を利用してJavaでコンパイラを書いたものです。 従来はコンパイル部分はC++で書かれてましたが曰くJavaも十分速くなったし高級で安全なJavaでコンバイラを書いてもいいだろとのこと。 この絶妙にランタイムが拡張可能でかつパフォーマンスを損なわない感じはJavaならではですね。 また、Javaで書かれているのでユーザがJavaで拡張可能でもあり、最適化や機械語生成を拡張できます。\nGraalはピーク性能の改善を目標としていて、Scalaアプリケーションなど一部のケースで既に従来のJVMの性能を上回ってるそうです。\nGraalをデフォルトでonにしたGraalVMというのもOracle Labから配布されているようです。\nTruffleについて GitHub。\nJavaのASTインタプリタフレームワークです。 多少言語実装をかじった人ならASTインタプリタは遅いことをご存知かと思いますがTruffleはそのままASTで解釈するだけではありません。 昨日のRPythonのようにASTインタプリタは意味論を与えるのが主な目的で、実行時にはGraalと連携して最適化していきます。\nTruffleが行う最適化は自己最適化です。 Javaで実装された各ASTノードがexecuteメソッドを持っていて実行される訳ですが、ASTを実行中に書き換えることで高速化していきます。 抽象的なインタプリタからセマンティクスを得て高速化していく点では似てますが、昨日のRPythonのJITとは違って全てがJVMの実行中に起きるのでちょっと図には書けないですね…。 このゲスト言語のソースコードに合わせた(部分評価した)最適化と評価器そのものの最適化が表裏一体な感じがなんともいえませんね。\nさて、Truffleの目的は高速化以外にもあります。polyglot、つまり同じVM上で複数の言語を動かすのです。 現状Ruby、Python、JavaScript、R、LLVM IRなどが動きます。 なにやらCLI/CLRとIronプロジェクトが去来しますがRuby、Python、JS、RはJVM実装の実績がありますしまあ大丈夫でしょう。 Truffle Tutorial: Embedding Truffle Languages in Javaを見ても分かるように相互連携はそれなりに出来るようです。\nSubstrate VM 資料。 あまり情報がないのですが、どうやらTruffleで書かれたインタプリタをコンパイルしてくれるようです。 出来上がるバイナリはJVMやJava Byte Codeを含まないらしいので面白いですね。\nTruffleチラ見 simplelanguageというレポジトリがあって、おもちゃ言語をTruffleで実装するデモが置いてあります。\nエントリポイント 日本語コメントはκeenによる。\n// SLMain.java public final class SLMain { /** * The main entry point. */ public static void main(String[] args) throws IOException { Source source; if (args.length == 0) { // @formatter:off  source = Source.newBuilder(new InputStreamReader(System.in)). name(\u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;). // MIME Typeを指定することでその言語のインタプリタを指定する  mimeType(SLLanguage.MIME_TYPE). build(); // @formatter:on  } else { source = Source.newBuilder(new File(args[0])).build(); } executeSource(source, System.in, System.out); } private static void executeSource(Source source, InputStream in, PrintStream out) { out.println(\u0026#34;== running on \u0026#34; + Truffle.getRuntime().getName()); PolyglotEngine engine = PolyglotEngine.newBuilder().setIn(in).setOut(out).build(); assert engine.getLanguages().containsKey(SLLanguage.MIME_TYPE); try { // ここで実行  Value result = engine.eval(source); if (result == null) { throw new SLException(\u0026#34;No function main() defined in SL source file.\u0026#34;); } else if (result.get() != SLNull.SINGLETON) { out.println(result.get()); } } ... } ... } Nodeと解釈 // nodes/expression/SLMulNode.java  package com.oracle.truffle.sl.nodes.expression; import java.math.BigInteger; import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary; import com.oracle.truffle.api.dsl.Specialization; import com.oracle.truffle.api.nodes.NodeInfo; import com.oracle.truffle.sl.nodes.SLBinaryNode; /** * This class is similar to the extensively documented {@link SLAddNode}. */ @NodeInfo(shortName = \u0026#34;*\u0026#34;) // 辿っていくと、`com.oracle.truffle.api.nodes.Node`の子クラスになっている public abstract class SLMulNode extends SLBinaryNode { @Specialization(rewriteOn = ArithmeticException.class) protected long mul(long left, long right) { return Math.multiplyExact(left, right); } @Specialization @TruffleBoundary protected BigInteger mul(BigInteger left, BigInteger right) { // 本当に計算するだけ。  return left.multiply(right); } } Builtin ビルトイン関数も定義されます。\n// builtins/SLPrintlnBuiltin @NodeInfo(shortName = \u0026#34;println\u0026#34;) public abstract class SLPrintlnBuiltin extends SLBuiltinNode { ... @TruffleBoundary private static void doPrint(PrintWriter out, Object value) { out.println(value); } } まとめ またしても締まりがないですが\n GraalというJavaで拡張可能なJITエンジンがあるよ Truffleという簡単にインタプリタを書けるフレームワークがあるよ TruffleはGraalを使いながら裏ですごい最適化をするよ Truffleで書いたインタプリタはSVMというツールでバイナリにもできるよ。  参考資料  Graal/Truffleの資料 Understanding How Graal Works - a Java JIT Compiler Written in Java Graal Project Truffle Tutorial TruffleRuby on the Substrate VM One VM to Rule Them All スライド One VM to Rule Them All, One VM to Bind Them YouTube ","categories":["言語実装","JVM","Advent Calendar","Advent Calendar 2017","言語実装 Advent Calendar"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/jvm","/categories/advent-calendar","/categories/advent-calendar-2017","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-advent-calendar"],"date":"2017-12-13","title":"Graal/Truffleについて軽く","url":"https://KeenS.github.io/blog/2017/12/13/graal_trufflenitsuitekaruku/"},
  {"body":"κeenです。これは 言語実装 Advent Calendar 201713日目の記事です。 RPythonやPyPyについて勘違いしてる人向けに誤解を解こうかと。あんまコードは出てこないやつです。\nいきなり話が逸れますが、PyPyとRPythonの話前に二村射影を知っておくと理解が深まるかもしれないので触れて起きます。\n二村射影と部分評価 詳しくはWikipediaを見て下さい。 ここでは直感的な話をします。\n第一: インタプリタとExecutable インタプリタは抽象的にはソースコードと入力データを受け取って出力データを出しています。\n+---------+ +--------+ | in/data | | source | +---------+ +--------+ | | +-------------+ | interpreter | +-------------+ | +----------+ | out/data | +----------+ このインタプリタをソースコードについて部分評価するとどうなるでしょう。 この部分評価する関数が第一二村射影なのでF1と呼びますね。\n+---------+ +--------+ +---------+ | in/data | | source |-----+ | in/data | +---------+ +--------+ | +---------+ | | | | +-------------+ +----+ +-----+ | interpreter |-------| F1 |--| ??? | +-------------+ +----+ +-----+ | | +----------+ +----------+ | out/data | | out/data | +----------+ +----------+ この第一二村射影の結果出来上がったものは何でしょうか。\n +---------+ | in/data | +---------+ | +-----+ | ??? | +-----+ | +----------+ | out/data | +----------+ これはただのプログラム、実行可能ファイルですね。\n第二: コンパイラとインタプリタ さて、もう一度第一二村射影を眺めましょう。\n+---------+ +--------+ +---------+ | in/data | | source |-----+ | in/data | +---------+ +--------+ | +---------+ | | | | +-------------+ +----+ +-----+ | interpreter |-------| F1 |--| exe | +-------------+ +----+ +-----+ | | +----------+ +----------+ | out/data | | out/data | +----------+ +----------+ このF1に注目して下さい。\n+--------+ +-------------+ | source | | interpreter | +--------+ +-------------+ | | +-------------+ | F1 | +-------------+ | +-----+ | exe | +-----+ 見覚えのある構図ですね。先程と同じくF1をinterpreterで部分評価してみましょう。この部分評価がF2です。\n+--------+ +-------------+ +--------+ | source | | interpreter |---+ | source | +--------+ +-------------+ | +--------+ | | | | +-------------+ +----+ +----------+ | F1 |---------| F2 |--| compiler | +-------------+ +----+ +----------+ | | +-----+ +-----+ | exe | | exe | +-----+ +-----+ 答え書いちゃってますがF2の結果生まれるのはコンパイラです。\n第三: コンパイラジェネレータ もう馴れたと思うので一気にF3まで書きますね。結論も書くとF3の結果コンパイラジェネレータが出来ます。\n+-------------+ +----+ +-------------+ | interpreter | | F1 |---+ | interpreter | +-------------+ +----+ | +-------------+ | | | | +-------------+ +----+ +--------------------+ | F2 |----| F3 |--| compiler generator | +-------------+ +----+ +--------------------+ | | +----------+ +----------+ | compiler | | compiler | +----------+ +----------+ F1、F2、F3さえ実装できればインタプリタからコンパイラが生成できるという魔法のような話でした。 とはいってもF1の時点でもかなり無理があるので実現可能性は低いでしょう。\nようやくPyPyの話に移ります。\nPyPyって？ 公式。 そこそこ有名なのであまり説明は必要ないかもしれませんが、Python処理系の1つです。 JITをすることでかなり高速に動作します。\nRPythonって？ ドキュメント。ひとまず、PyPyのサブプロジェクトです。 「RPython」が指す範囲が広いので慎重にいきます。\n言語仕様はPythonのサブセットです。PyPyのインタプリタを実装する目的で策定されました。 面白いのは処理系実装の方で、RPythonのプログラムをC(など)に変換するコンパイラになってます。\nこの説明だとPythonをコンパイルする夢の処理系かと早合点する人が多いですが、Cに変換できる程に制限したサブセットなので実際はPython風に書ける小さな言語処理系記述DSL程度です。\nRubyのJIT処理系を目指して作られたTopazもこのRPythonで書かれていたので色々勘違いされて「Rubyはあまりに遅くて、RubyインタプリタをPythonで書き直したら5倍速くなった」なんて冗談じみた話も出回ってましたが完全に誤解です。\nもうちょっとRPython 「RPython」からC言語に至るまでのツーリングが素敵にややこしいので少し触れます。\nまず、RPython処理系はPythonで実装されています。\n+---------------+ | `rpython.py` | +---------------+ | `python` | +---------------+ そしてRPytnonのプログラムはPythonのソースコードからやってきます。 どういうことかというと、「RPythonとして有効な関数を返すPythonの関数」の実行結果がRPythonのプログラムとして処理されます。 普通のPythonの普通の関数オブジェクト(RPythonのドキュメントでは コードオブジェクト )がRPythonの仕様の範囲内ならRPythonのプログラムになるわけです。 「ソースコードじゃなくてコードオブジェクト？Pythonのメモリにあるただのデータでいいの？」と思うかもしれませんがRPythonの処理系はコンパイルされたPythonのバイトコードを解析(正確には抽象解釈)して、同じセマンティクスを持つCのソースコードを吐いているので大丈夫です。むしろソースコードは扱えません。\nところでなぜ一旦Pythonのインタプリタを噛ませてるかというと、1つにはPythonをメタ言語として使えるからです。\nドキュメントの例を引用すると、\ndef generator(operation): if operation == \u0026#39;add\u0026#39;: def f(a, b): return a + b else: def f(a, b): return a - b return f add = generator(\u0026#39;add\u0026#39;) sub = generator(\u0026#39;sub\u0026#39;) def entry_point(argv): print add(sub(int(argv[1]), 3) 4) return 0 上記のentry_pointとそこから辿れるadd、subはRPythonですがgeneratorはそうではありません。しかし\ndef target(*args): return entry_point, None のようにRPythonのエントリーポイントをentry_pointにすれば、別にgeneratorはRPythonでなくともよいのです。 つまりは最終的にコンパイルされる部分以外ではPythonでメタプログラミングが出来るのです。\n最後に、もちろんRPythonに吐かれたCのコードはCコンパイラを通して実行可能ファイルになります。\nこれら関係を図に加えると、\n+-[source.py]--+ | Python | | +---------+ +---+ +-----+ | | RPython | =\u0026gt; | C | =\u0026gt; | | | +-+---------+ +---+ | | | |+-----------------++-------+| exe | +--+| `rpython.py` || || | +---------------------+| `gcc` || | | `python` || || | +---------------------++-------++-----+ こうなります。\nさて、PyPyの処理系はRPythonで書かれていたわけですからそれも書いてみましょう。\n +--------+ +-[pypy.py]----+ | Python | | Python | +--------+ | +---------+ +---+ +--------+ | | RPython | =\u0026gt; | C | =\u0026gt; | | | +-+---------+ +---+ | | | |+-----------------++-------+| `pypy` | +--+| `rpython.py` || || | +---------------------+| `gcc` || | | `python` || || | +---------------------++-------++--------+ PythonとRPythonが入り乱れて楽しいですね。 因みに簡単な方のアーキテクチャで、後述のようにJITも入れるともっと複雑です。\nさて、少し脇道に逸れるとよくある勘違いの1つに「RPythonをPyPyで動かしたらもっとPyPyが速くなるんじゃないか」というのがあります。 しかし図をみたら分かるようにRPythonを速く動かしたところで速くなるのはpypy処理系の生成で、pypyそのものが速くなる訳ではないことが見て取れると思います。\n閑話休題。ここまでだと結局はCで書かれたPythonインタプリタが出てくるのでCPythonとそう変わらなそうですね。 こっちは多少言語処理系に特化した分少し速いくらいでしょうか。 しかしJITが入ってくるとRPythonで抽象的にインタプリタの意味論を与えたことが効いてきて、「効率的に」効率的な実行ができるようになります。\nRPythonとJIT さて、シンプルな話が終わったのでJITの話をします。\nインタプリタが遅かったらJITをしますね？でもJITは実装が大変ですし、「普通のインタプリタ」と「JITで生成するコード用のインタプリタと同じ挙動をするアセンブリ」で実質2回同じインタプリタを実装しないといけません。 面倒なだけでなく、両者で挙動に違いがあればそれはバグです。大変ですね。\nこれをうまいことするのがRPythonのJIT Optimization。 なんとRPythonで書かれたインタプリタからJITエンジンを生成してしまうのです。 実行時情報を取りながらという条件付きですが第一二村射影を実現してしまった感じですね。\n私の理解が足りてないので間違ってるかもしれませんがこんな感じでしょうか。\n [JIT Lib]-+ | +--------+ +-[pypy.py]----+ +--------+ | | Python | | Python | =\u0026gt; | JIT | | +--------+ | +---------+ +--------+ V +--+-----+ | | RPython | =\u0026gt; | C | =\u0026gt; | | JIT | | +-+---------+ +--------+ | +-----+ | |+-----------------++-------+ | `pypy` | +--+| `rpython.py` || | | | +---------------------+| `gcc` | | | | `python` || | | | +---------------------++-------+ +--------+ 終わりに 締まらないですが終わりです。 本当はRPythonでBFのJITインタプリタを作るチュートリアル1と2 をやりたかったのですが2の方がAPIが変わったらしく動かないので断念しました。2011年のものですしまだRPythonがPyPyから切り出されてない頃のもののようなので当然っちゃ当然ですね。\n明日は続けて似たようなフレームワーク(と思ってる)JVMのGraalとTruffleについて調べようと思います。\n","categories":["言語実装","RPython","Interpreter","Advent Calendar","Advent Calendar 2017","言語実装 Advent Calendar"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/rpython","/categories/interpreter","/categories/advent-calendar","/categories/advent-calendar-2017","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-advent-calendar"],"date":"2017-12-12","title":"RPythonについて軽く","url":"https://KeenS.github.io/blog/2017/12/12/rpythonnitsuitekaruku/"},
  {"body":"κeenです。この記事はWebAssembly Advent Calendar 2017 8日目の記事です。WebAssemblyでガーベジコレクションする話。 2017-12-08: ページサイズに関する誤りを訂正しました。その他加筆。\nはじめてWebAssemblyを聞いたとき、「ブラウザでアセンブラが動くのか、よし、コンパイラを作ろう」と思ったかと思います。 私もそのうちの一人で去年頃こんなコンパイラを作り始めました。 しかしご覧のように進捗芳しくありません。 進捗が悪い理由の1つにGCがあります。最初はGCをCかRustで書いてemscriptenを通すつもりでしたがemscriptenを通したコードはどうにも扱いづらく、すぐに断念しました。 今でこそRustのwasm32-unknown-unknownのターゲットがありますが当時はemscriptenしか選択肢がありませんでした。\nまた、wasmにはGCサポートが追加される予定ですがまだ使えないので絵に書いた餅。\n残る手段は1つ。アセンブラ手書きです。アセンブラ手書きでGCを書いていきます。\nリニアメモリ GCの前にリニアメモリを押さえておきましょう。詳しくはドキュメントをみて下さい。ここで覚えておいてほしいのは\n アドレスは 0から始まって 飛びがない データはナチュラルアラインされた方がアクセスは速いがアラインされていなくてもアクセス可能 メモリは(wasm32では)Max 4GiB。ポインタも32bit メモリはgrow_memoryで16KiB64KiB単位で増やせる tzikさん指摘ありがとうございます。 メモリはモジュール間でimport/exportできる  GCモジュールとミューテータ(言語)に分けられる   アドレスが0から始まるので保守的GCが少しやりづらそう？\n肩慣らし いきなりどんとGCが来ても困ると思うので軽くwasmのコードを書いてみましょう。 とはいっても生の.watは少々書きづらくマクロを使いたいので生成することを考えます。 ここは餅は餅屋、S式はLispで異論ないと思います。\nまずは準備。外部コマンドを使うのでuiopを使い、シンボルが大文字にならないようにread-caseを:invertにしておきます。\n(require \u0026#39;uiop) (setf (readtable-case *readtable*) :invert) さて、生成自体は簡単で、\n(print \u0026#39;(module (func $i (import \u0026#34;imports\u0026#34; \u0026#34;imported_func\u0026#34;) (param i32)) (func $new_page (grow_memory (i32.const 3)) (call $i)) (func (export \u0026#34;exported_func\u0026#34;) (i32.const 42) (call $new_page) (call $i)) (memory 1 10) )) のように.watのコードをprintしてあげればOKです。もう少し皮を被せてアセンブルまでやるようにすれば\n(defun write-wasm (filename wasm) (with-open-file (f filename :direction :output :if-does-not-exist :create :if-exists :supersede) (print wasm f))) (let ((wasm ~~~~)) (write-wasm \u0026#34;simple.wat\u0026#34; wasm) (uiop:run-program \u0026#34;wast2wasm simple.wat -o simple.wasm\u0026#34;)) こうなり、ファイルを実行するとsimple.wasmの生成までやってくれます。\nあとはこういうファイルを用意してブラウザで開けば動きます。\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var importObject = { imports: { imported_func: function(arg) { console.log(arg); } } }; fetch(\u0026#39;simple.wasm\u0026#39;).then(response =\u0026gt; response.arrayBuffer() ).then(bytes =\u0026gt; WebAssembly.instantiate(bytes, importObject) ).then(results =\u0026gt; { results.instance.exports.exported_func(); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; GC 肩も馴れてもうwasmはいくらでも書けると思うのでGCを実装していきます。\n戦略  GCにも色々ありますがブラウザで動かす以上JSとのFFIもあるでしょうしnon-movingなものにしましょう grow_memoryでキリの良いアドレスが帰ってくるのでそれを使いましょう C言語と違って「このマクロをデータ型定義に埋め込めば何でもGCできます」とはいかないので(単純にマクロがないため)メタデータとデータは分離しましょう 地味にスタックとレジスタの走査ができないのでポインタは手でヒープに退避しましょう。これがルートセットになります。  ということでbitmap式のMark and Sweepを採用します。またかよと思った方、ええ、好きなんです。\nイメージ このGCを使うときのイメージはこんな感じです。\n(defwfun $main (\u0026amp;aux (gc i32) (state i32)) nil `( ; GCデータを初期化 (set_local ,gc (call $new-gc)) (call $gc-init (get_local ,gc)) ; この時点ではまだデータは0 (call $print (call $gc--allocated-data (get_local ,gc))) ; 今から確保するメモリのポインタをヒープに退避する準備。多くは関数の先頭でやる (set_local ,state (call $gc-save-state (get_local ,gc))) ; 4byteのメモリを確保し、ポインタを保護 (call $gc-protect (get_local ,gc) (call $gc-alloc (get_local ,gc) (i32.const 4))) (call $gc-protect (get_local ,gc) (call $gc-alloc (get_local ,gc) (i32.const 4))) (call $gc-protect (get_local ,gc) (call $gc-alloc (get_local ,gc) (i32.const 4))) ; この時点で3つデータを確保している (call $print (call $gc--allocated-data (get_local ,gc))) ; GCを走らせる (call $gc-run (get_local ,gc)) ; ポインタは退避されているので回収されない (call $print (call $gc--allocated-data (get_local ,gc))) ; 退避する前の状態に戻す。多くは関数の末尾でやる (call $gc-restore-state (get_local ,gc) (get_local ,state)) ; ポインタを保護してない状態でGCを走らせる (call $gc-run (get_local ,gc)) ; 回収される (call $print (call $gc--allocated-data (get_local ,gc))))) さて、イメージも湧いたところで作って行きます。\nデータレイアウト 2種類の構造体を使います。それぞれ1ページ、16KiB64KiB使います。 C言語風に書くとこうです。\nstruct gc { struct heap_page (*pages)[11], // 4 x 2^0 byte, 4 x 2^1 byte, ..., 4 x 2^10 byte  size_t arena_top, // in the number of pointers  size_t arena_size, void (*arena)[] }; struct heap_page { // bitmaps enough to manage the 4byte-sized data pages  uint64_t bitmaps[*page-size* / 4 / 64], struct page *next, // in bytes  size_t data_size // in the number of cell  size_t heap_size, void (*data)[] }; 図にするとこうです。\n ポインタの一時退避場所↓ +---+- ... -+---+-----------+------------+- ... -+ | + | pages | + | arena_top | arena_size | arena | gc +-|-+- ... -+-|-+-----------+------------+- ... -+ 0 | 4 | 44 2^16 | | 実際のデータ領域↓ +---------+---+-----------+-----------+- .. -+ | bitmaps | + | data_size | heap_size | data | heap_page +---------+-|-+-----------+-----------+- .. -+ +---------+ . . | +---------+---+-----------+-----------+- .. -+ | bitmaps | + | data_size | heap_size | data | heap_page +---------+-|-+-----------+-----------+- .. -+ +---------+ | x 図には1種類しか書かれてませんがheap_pageは4byteから4096byteまで11種類のサイズ毎にリンクトリストが用意されています。\nアリーナ アリーナは代替スタック変数領域で、スタックとして使います。関数内でアロケートしたポインタはルートセットに含まれておらず、放っておくと回収されるのでアリーナに置いて保護します。 GC時にはアリーナはルートセットになります。\nheap_pageとbitmaps 宣言どおりデータとメタデータを分離してます。その他にもBitmap GCには色々利点があるので気になる方は調べてみて下さい。\nbitmapsとデータ領域は連動していて、bitmapsのn bit目が1ならデータ領域のnセル目が使用中です。アロケートするときはbitmapsを舐めて0なbitに対応するセルを使います。もちろんbitmapsのbitも立てます。 GC時には一旦すべてのbitmapをクリアし、ルートセットから辿れるものにのみマークすればOKです。\nポインタとマーク さて、アロケートはマークからデータに飛ぶので問題ないのですが、マーク時はポインタからマークに飛ぶのでやや厄介です。 ここはページが16KiB64KiBアラインされていることを使います。\nページが16KiB64KiBアラインされているのでページのアドレスは下位14bit16bitが0です。なので単にポインタの下位14bit16bitをクリアしてあげると自分が所属しているページのアドレスが手に入るのです。\n2017-12-08 追記: 限界 ここでは4096 byteまでのページしか用意していません。それ以上はこのGCではアロケートに失敗というかunreachableに入ってエラーになります。ちゃんと実装するならフリーリストなどで管理しましょう。 / 追記\n実装 淡々と実装していきます。Common Lispには解説を入れないので雰囲気で追って下さい\nまず使いそうな定数とWASMの関数を便利に書くマクロを準備します。\n; 訂正 ; (defparameter *page-size* (* 16 1024)) (defparameter *page-size* (* 64 1024)) (defparameter *null-ptr* \u0026#39;(i32.const 0)) (defparameter *sizeof-i32* 4) (defparameter *sizeof-i64* 8) (defparameter *sizeof-ptr* 4) (eval-when (:compile-toplevel :load-toplevel :execute) (defun split-list (list sep) (labels ((recc (left rest) (cond ((null rest) (cons (nreverse left) rest)) ((eql (car rest) sep) (cons (nreverse left) (cdr rest))) (t (recc (cons (car rest) left) (cdr rest)))))) (recc () list)))) (defparameter *wasm-funs* nil) (defmacro defwfun (name param-list result \u0026amp;body body) (let* ((param-list (split-list param-list \u0026#39;\u0026amp;aux)) (params (car param-list)) (auxs (cdr param-list)) (param-types (mapcar #\u0026#39;cadr params)) (param-vars (mapcar #\u0026#39;car params)) (aux-types (mapcar #\u0026#39;cadr auxs)) (aux-vars (mapcar #\u0026#39;car auxs))) (let ((bindings (loop :for var :in (append param-vars aux-vars) :for i := 0 then (1+ i) :collect (list var i))) (param (if (null param-types) () (list (cons \u0026#39;param param-types)))) (local (if (null aux-types) () (list (cons \u0026#39;local aux-types)))) (result (if (eql nil result) () (list (list \u0026#39;result result))))) `(push (let ,bindings (append `(func ,\u0026#39;,name ,@\u0026#39;,param ,@\u0026#39;,result ,@\u0026#39;,local ) ,@body)) *wasm-funs*)))) このマクロで関数はこのように書けます。\n(defwfun $add ((x i32) (y i32)) i32 `((i32.add (get_local ,x) (get_local ,y)))) Common Lispの関数定義に倣って引数リストの\u0026amp;aux以降はローカル変数とします。\nユーティリティ\n;;; utils (defwfun $new-page () i32 `((i32.mul (i32.const ,*page-size*) (grow_memory (i32.const 1))))) 先の構造体に対応する定数を手作業で定義していきます。 11のポインタの初期化などはCommon Lisp側のloopで自動生成します。\n#| struct gc { struct heap_page (*pages)[11], // 4 x 2^0 byte, 4 x 2^1 byte, ..., 4 x 2^10 byte size_t arena_top, // in the number of pointers size_t arena_size, void (*arena)[] }; |# (defparameter *sizeof-gc* (+ (* 11 *sizeof-ptr*) *sizeof-ptr* *sizeof-ptr*)) (defparameter *offset-gc-heap-page* 0) (defparameter *offset-gc-arena-top* (+ *offset-gc-heap-page* (* 11 *sizeof-ptr*))) (defparameter *offset-gc-arena-size* (+ *offset-gc-arena-top* *sizeof-ptr*)) (defparameter *offset-gc-arena* (+ *offset-gc-arena-size* *sizeof-ptr*)) #| struct heap_page { // bitmaps enough to manage the 4byte-sized data pages uint64_t bitmaps[*page-size* / 4 / 64], struct page *next, // in bytes size_t data_size // in the number of cell size_t heap_size, void (*data)[] }; |# (defparameter *bitmap-size* (/ *page-size* 4 64)) (defparameter *sizeof-heap-page* (+ (* 8 *bitmap-size*) *sizeof-ptr* *sizeof-ptr*)) (defparameter *offset-heap-page-bitmaps* 0) (defparameter *offset-heap-page-next* (+ *offset-heap-page-bitmaps* (* 8 *bitmap-size*))) (defparameter *offset-heap-page-data-size* (+ *offset-heap-page-next* *sizeof-ptr*)) (defparameter *offset-heap-page-heap-size* (+ *offset-heap-page-data-size* *sizeof-ptr*)) (defparameter *offset-heap-page-heap-data* (+ *offset-heap-page-heap-size* *sizeof-ptr*)) ;;; struct gc; (defwfun $new-gc () i32 \u0026#39;((call $new-page))) (defwfun $gc-init ((gc i32)) nil `(;; pages ,@(loop :for i :from 0 :below 11 :collect `(i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; (+ *offset-gc-heap-page* (* i *sizeof-ptr*)))) (get_local ,gc) ,*null-ptr*)) ;; arena_top (i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-arena-top*)) (get_local ,gc) (i32.const 0)) ;; arena_size (i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-arena-size*)) (get_local ,gc) (i32.const ,(floor (- *page-size* *sizeof-gc*) *sizeof-ptr*))))) ;;; struct heap_page; ; heap data must be 8 byte aligned (assert (zerop (rem *sizeof-heap-page* 8))) (defwfun $new-heap-page () i32 \u0026#39;((call $new-page))) (defwfun $init-heap-page ((page i32) (size i32)) nil `(;; bitmaps ,@(loop :for i :from 0 :below *bitmap-size* :collect `(i64.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; (+ *offset-heap-page-bitmaps* (* i 8)))) (get_local ,page) (i64.const 0))) ;; next (i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-next*)) (get_local ,page) ,*null-ptr*) ;; data-size (i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-data-size*)) (get_local ,page) (get_local ,size)) ;; heap-size (i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-heap-size*)) (get_local ,page) (i32.div_u (i32.const ,(- *page-size* *sizeof-heap-page*)) (get_local ,size))))) ちょっとトリッキーなのがload/storeのオフセットの指定。 (i32.store offset=4 hoge fuga)のように書くのですがCommon Lispではoffset=4一つでシンボル扱いになって動的生成が面倒です。,(intern (format nil \u0026quot;OFFSET=~a\u0026quot; 4))のように毎度internで生成するゴリ押しでやってます。 本当は関数に纏めたかったけどアセンブラ感が減るのでやめました。\n(assert (zerop (rem *sizeof-heap-page* 8)))ですが、heap_pageから取得したポインタが全て64bitアラインになるように配慮です。\n次にサイズから2の累乗に丸めあげる処理です。Cでいうマクロのように毎度インライン展開するようにCommon Lispの関数として定義します。単純な２分探索ですが、本当は4, 8 byteがよく使われるのでそれに合わせてアンバランスドな２分探索をした方がいいらしいです。\n(defun calc-heap-index (size) ;; Simple binary search. ;; Should be optimized to common size (frequently 4 bytes and 8bytes) `(if i32 (i32.le_u ,size (i32.const 128)) ; size \u0026lt;= 128 (if i32 (i32.le_u ,size (i32.const 8)) ; size \u0026lt;= 8 (if i32 (i32.le_u ,size (i32.const 4)) ; size \u0026lt;= 4 (i32.const 0) ; 4 \u0026lt; size \u0026lt;= 8 (i32.const 1)) ; 8 \u0026lt; size \u0026lt;= 128 (if i32 (i32.le_u ,size (i32.const 32)) ; 8 \u0026lt; size \u0026lt;= 32 (if i32 (i32.le_u ,size (i32.const 16)) ; 8 \u0026lt; size \u0026lt;= 16 (i32.const 2) ; 16 \u0026lt; size \u0026lt;= 32 (i32.const 3)) ; 32 \u0026lt; size \u0026lt;= 128 (if i32 (i32.le_u ,size (i32.const 64)) ; 32 \u0026lt; size \u0026lt;= 64 (i32.const 4) ; 64 \u0026lt; size \u0026lt;= 128 (i32.const 5)))) ; 128 \u0026lt; size (if i32 (i32.le_u ,size (i32.const 1024)) ; 128 \u0026lt; size \u0026lt;= 1024 (if i32 (i32.le_u ,size (i32.const 512)) ; 128 \u0026lt; size \u0026lt;= 512 (if i32 (i32.le_u ,size (i32.const 256)) ; 128 \u0026lt; size \u0026lt;= 256 (i32.const 6) ; 256 \u0026lt; size \u0026lt;= 512 (i32.const 7)) ; 512 \u0026lt; size \u0026lt;= 1024 (i32.const 8)) ; 1024 \u0026lt; size (if i32 (i32.le_u ,size (i32.const 2048)) ; 1024 \u0026lt; size \u0026lt;= 2048 (i32.const 9) (if i32 (i32.le_u ,size (i32.const 4096)) ; 2048 \u0026lt; size \u0026lt;= 4096 (i32.const 10) ; 4096 \u0026lt; size (unreachable)))))) ヒーブを増やす内部処理。\n(defwfun $gc--append-heap-page ((gc i32) (heap-page i32) (size i32) \u0026amp;aux (heap-index i32) (heap-page-ptr i32) (heap-page-next-ptr i32)) nil `((set_local ,heap-index (i32.mul (i32.const 4) ,(calc-heap-index `(get_local ,size)))) (set_local ,heap-page-ptr (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-heap-page*)) (i32.add (get_local ,gc) (get_local ,heap-index)))) (if (i32.eqz (get_local ,heap-page-ptr)) ;; if no page exist let it be the first page (i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-heap-page*)) (i32.add (get_local ,gc) (get_local ,heap-index)) (get_local ,heap-page)) ;; if at least 1 page exist, append it to the end (loop $loop (set_local ,heap-page-next-ptr (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-next*)) (get_local ,heap-page-ptr))) (if (i32.eqz (get_local ,heap-page-next-ptr)) (block (i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-next*)) (get_local ,heap-page-ptr) (get_local ,heap-page)) (return)) (set_local ,heap-page-ptr (get_local,heap-page-next-ptr))) (br $loop))))) (defwfun $gc-extend-heap-page ((gc i32) (size i32) \u0026amp;aux (heap-page i32)) nil `((set_local ,heap-page (call $new-heap-page)) (call $init-heap-page (get_local ,heap-page) (get_local ,size)) (call $gc--append-heap-page (get_local ,gc) (get_local ,heap-page) (get_local ,size)))) アロケーション処理。ごちゃごちゃしてますがコメントだけ拾い読みすると何をやってるかはわかります。\nGCからヒープのリストを指定して、ヒーブのリストから空いてるヒーブを探して、ヒーブの中から空いてるセルを探すので関数が3つに分かれてます。 また、大本のalloc関数はメモリが足りなければGCを起動したりメモリを増やしたりします。\n(defwfun $gc--alloc-page ((page i32) (size i32) \u0026amp;aux (bitmap i64) (i i32) (j i32) (index i32)) i32 `( ; for i from 0 below *bitmap-size* (block $outer (loop $loop (if (i32.le_u (i32.const ,*bitmap-size*) (get_local ,i)) (br $outer)) ; bitmap \u0026lt;- page.bitmap[i] (set_local ,bitmap (i64.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-bitmaps*)) (i32.add (get_local ,page) (get_local ,i)))) ; if bitmap == 1111...1111 (if (i64.eq (i64.const -1) (get_local ,bitmap)) ; next (br $loop)) ; j \u0026lt;- index of the first 0 in bitmap (set_local ,j (i32.wrap/i64(i64.ctz (i64.sub (i64.const -1) (get_local ,bitmap))))) ; index \u0026lt;- i*64+j (set_local ,index (i32.add (i32.mul (get_local ,i) (i32.const 64)) (get_local ,j))) ; if page.heap_size \u0026lt;= index (if (i32.le_u (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-heap-size*)) (get_local ,page)) (get_local ,index)) ; return null (return ,*null-ptr*) ; else (block ; page.bitmap[i] \u0026lt;- bitmap | (1 \u0026lt;\u0026lt; j) (i64.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-bitmaps*)) (i32.add (get_local ,page) (get_local ,i)) (i64.or (get_local ,bitmap) (i64.shl (i64.const 1) (i64.extend_u/i32 (get_local ,j))))) ; return \u0026amp;page.data[index*size] (return (i32.add (i32.add (get_local ,page) (i32.const ,*offset-heap-page-heap-data*)) (i32.mul (get_local ,index) (get_local ,size)))))) (br $loop))) ; return null ,*null-ptr*)) (defwfun $gc--alloc-pages ((pages i32) (size i32) \u0026amp;aux (ptr i32)) i32 `( ; loop (loop $loop ; if (page.next is null) (if (i32.eqz (get_local, pages)) ; fail (return (i32.const 0))) ; try alloc-page(page, size) (if (i32.eqz (tee_local ,ptr (call $gc--alloc-page (get_local ,pages) (get_local ,size)))) (set_local ,ptr (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-next*)) (get_local ,pages))) (return (get_local ,ptr))) (br $loop)) (unreachable) ) ) (defwfun $gc--alloc ((gc i32) (size i32) \u0026amp;aux (pages i32) (index i32)) i32 `( ; index \u0026lt;- calc-index-by-size(size) (set_local ,index ,(calc-heap-index `(get_local ,size))) ; alloc-pages(gc.heaps[index], size) (set_local ,pages (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-heap-page*)) (i32.add (get_local ,gc) (get_local ,index)))) (call $gc--alloc-pages (get_local ,pages) (get_local ,size)))) (defwfun $gc-alloc ((gc i32) (data-size i32) \u0026amp;aux (size i32) (ptr i32)) i32 `( ; try alloc (if (i32.eqz (tee_local ,ptr (call $gc--alloc (get_local ,gc) (get_local ,data-size)))) (block ; gc-run (call $gc-run (get_local ,gc)) ; try alloc (if (i32.eqz (tee_local ,ptr (call $gc--alloc (get_local ,gc) (get_local ,data-size)))) (block ; FIXME: round up power of 2 (set_local ,size (get_local ,data-size)) ; extend-page (call $gc-extend-heap-page (get_local ,gc) (get_local ,size)) ; alloc (if (i32.eqz (tee_local ,ptr (call $gc--alloc (get_local ,gc) (get_local ,data-size)))) (unreachable)))))) (get_local ,ptr))) ヒープにポインタを退避する関数群。ただのスタックなのでシンプル。\n(defwfun $gc-save-state ((gc i32)) i32 `((i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-arena-top*)) (get_local ,gc)))) (defwfun $gc-protect ((gc i32) (ptr i32) \u0026amp;aux (arena-top i32)) nil `((set_local ,arena-top (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-arena-top*)) (get_local ,gc))) (i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-arena*)) (i32.add (get_local ,gc) (get_local ,arena-top)) (get_local ,ptr)) (i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-arena-top*)) (get_local ,gc) (i32.add (i32.const 4) (get_local ,arena-top))))) (defwfun $gc-restore-state ((gc i32) (state i32)) nil `((i32.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-arena-top*)) (get_local ,gc) (get_local ,state)))) マーク処理。 先程解説してなかったのですが、アロケートしたデータをどうマークするかはユーザに任せます。 動的型付き言語ならデータに埋め込まれたタグで型を判別してマークするでしょう。 静的型付き言語ならタグを入れるか保守的にポインタっぽい値を全部マークする手もあるでしょう。 ここではダミーの何もせずマーク完了を返す関数にしています。\n(defwfun $gc--clear-marks-page ((page i32)) nil ;; clear the bitmaps of the page (loop :for i :from 0 :below *bitmap-size* :collect `(i64.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; (* i 8))) (get_local ,page) (i64.const 0)))) (defwfun $gc--clear-marks-pages ((current-page i32)) nil ;; call for $gc--clear-marks-page all the pages connected to this page `((loop $loop (if (i32.eqz (get_local ,current-page)) (return)) (call $gc--clear-marks-page (get_local ,current-page)) (set_local ,current-page (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-next*)) (get_local ,current-page))) (br $loop)))) (defwfun $gc--clear-marks ((gc i32)) nil ;; cal $gc--clear-marks-pages for all the size of pages (loop :for i :from 0 :below 11 :collect `(call $gc--clear-marks-pages (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; (* i *sizeof-ptr*))) (get_local ,gc))))) (defwfun $gc--mark-data ((ptr i32)) i32 ; user defined data marking function `((i32.const 1))) (defun get-page (ptr) `(i32.and (i32.const ,(lognot(1- (ash 1 (round (log *page-size* 2)))))) (get_local ,ptr))) (defwfun $gc--mark-ptr ((ptr i32) \u0026amp;aux (page i32) (size i32) (bitmap i64) (mask i64) (index-in-heap i32) (index-in-array i32) (index-in-i64 i32)) i32 ; mark the ptr and recursively the data `( ; page \u0026lt;- get_page(ptr) (set_local ,page ,(get-page ptr)) ; size \u0026lt;- get_size(page (set_local ,size (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-data-size*)) (get_local ,page))) ; index \u0026lt;- calc index(page, ptr) (set_local ,index-in-heap (i32.div_u (i32.sub (get_local ,ptr) (i32.add (get_local,page) (i32.const ,*offset-heap-page-heap-data*))) (get_local ,size))) (set_local ,index-in-array (i32.div_u (get_local ,index-in-heap) (i32.const 64))) (set_local ,index-in-i64 (i32.rem_u (get_local ,index-in-heap) (i32.const 64))) ; if (! is_marked(page, index)) (set_local ,bitmap (i64.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-bitmaps*)) (i32.add (get_local ,page) (i32.mul (get_local ,index-in-array) (i32.const 8))))) (set_local ,mask (i64.shl (i64.const 1) (i64.extend_u/i32 (get_local ,index-in-i64)))) (if (i64.eqz (i64.and (get_local ,bitmap) (get_local ,mask))) ; mark(page, index) (block (i64.store ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-bitmaps*)) (i32.add (get_local ,page) (i32.mul (get_local ,index-in-array) (i32.const 8))) (i64.or (get_local ,bitmap) (get_local ,mask))) ; $gc--mark-data(ptr) (return (call $gc--mark-data (get_local ,ptr))))) (return (i32.const 1)))) (defwfun $gc--mark ((gc i32) \u0026amp;aux (arena-top i32) (i i32)) nil `(; for each arena data call $gc--mark-ptr (set_local ,arena-top (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-arena-top*)) (get_local ,gc))) (loop $loop (if (i32.le_u (get_local ,arena-top) (get_local ,i)) (return)) (drop (call $gc--mark-ptr (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-gc-arena*)) (i32.add (get_local ,i) (get_local ,gc))))) (set_local ,i (i32.add (get_local ,i (i32.const 4)))) (br $loop)))) GC実行。普通のMark and Sweepとは違ってclear and mark。\n(defwfun $gc-run ((gc i32)) nil `((call $gc--clear-marks (get_local ,gc)) (call $gc--mark (get_local ,gc)))) デバッグ用の何か。確保されているセルの数を数えます。\n;;; other utils (defwfun $gc--allocated-data-page ((page i32) \u0026amp;aux (sum i32)) i32 `(,@(loop :for i :from 0 :below *bitmap-size* :collect `(set_local ,sum (i32.add (get_local ,sum) (i32.wrap/i64 (i64.popcnt (i64.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; (* i 8))) (get_local ,page))))))) (get_local ,sum))) (defwfun $gc--allocated-data-pages ((current-page i32) \u0026amp;aux (sum i32)) i32 `((loop $loop (if (i32.eqz (get_local ,current-page)) (return (get_local ,sum))) (set_local ,sum (i32.add (get_local ,sum) (call $gc--allocated-data-page (get_local ,current-page)))) (set_local ,current-page (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; *offset-heap-page-next*)) (get_local ,current-page))) (br $loop)) (unreachable))) (defwfun $gc--allocated-data ((gc i32) \u0026amp;aux (sum i32)) i32 `(,@(loop :for i :from 0 :below 11 :collect `(set_local ,sum (i32.add (get_local ,sum) (call $gc--allocated-data-pages (i32.load ,(intern (format nil \u0026#34;OFFSET=~a\u0026#34; (* i *sizeof-ptr*))) (get_local ,gc)))))) (get_local ,sum))) はい。まだFIXMEが残ってるなど甘いところがありますがWASMでBitMap GCを書きました。 多分他人の書いたよくわかんバグってそうなGCを使う人はいないと思うので自作するときの参考にして下さい。\n所感としてはget_localとconstが面倒、loopがbrを呼ばないと先頭に戻ってくれないことに気づいた、などがあります。\n今回のソースコードはここにあります。\n2017-12-08 追記: 今回のGCは2011年の上野先生の論文1 に多大な影響を受けています。 また、そのBitMap GCは2016年に並行版も開発されています2。 興味のある方はぜひご一読下さい。\n/追記\n付録 生成された .wat 全文 2017-12-08 編集: ページサイズを16KiB -\u0026gt; 64KiBの変更を取り入れました\n(module (func $print (import \u0026#34;imports\u0026#34; \u0026#34;print\u0026#34;) (param i32)) (func $new-page (result i32) (i32.mul (i32.const 65536) (grow_memory (i32.const 1)))) (func $new-gc (result i32) (call $new-page)) (func $gc-init (param i32) (i32.store offset=0 (get_local 0) (i32.const 0)) (i32.store offset=4 (get_local 0) (i32.const 0)) (i32.store offset=8 (get_local 0) (i32.const 0)) (i32.store offset=12 (get_local 0) (i32.const 0)) (i32.store offset=16 (get_local 0) (i32.const 0)) (i32.store offset=20 (get_local 0) (i32.const 0)) (i32.store offset=24 (get_local 0) (i32.const 0)) (i32.store offset=28 (get_local 0) (i32.const 0)) (i32.store offset=32 (get_local 0) (i32.const 0)) (i32.store offset=36 (get_local 0) (i32.const 0)) (i32.store offset=40 (get_local 0) (i32.const 0)) (i32.store offset=44 (get_local 0) (i32.const 0)) (i32.store offset=48 (get_local 0) (i32.const 16371))) (func $new-heap-page (result i32) (call $new-page)) (func $init-heap-page (param i32 i32) (i64.store offset=0 (get_local 0) (i64.const 0)) (i64.store offset=8 (get_local 0) (i64.const 0)) (i64.store offset=16 (get_local 0) (i64.const 0)) (i64.store offset=24 (get_local 0) (i64.const 0)) (i64.store offset=32 (get_local 0) (i64.const 0)) (i64.store offset=40 (get_local 0) (i64.const 0)) (i64.store offset=48 (get_local 0) (i64.const 0)) (i64.store offset=56 (get_local 0) (i64.const 0)) (i64.store offset=64 (get_local 0) (i64.const 0)) (i64.store offset=72 (get_local 0) (i64.const 0)) (i64.store offset=80 (get_local 0) (i64.const 0)) (i64.store offset=88 (get_local 0) (i64.const 0)) (i64.store offset=96 (get_local 0) (i64.const 0)) (i64.store offset=104 (get_local 0) (i64.const 0)) (i64.store offset=112 (get_local 0) (i64.const 0)) (i64.store offset=120 (get_local 0) (i64.const 0)) (i64.store offset=128 (get_local 0) (i64.const 0)) (i64.store offset=136 (get_local 0) (i64.const 0)) (i64.store offset=144 (get_local 0) (i64.const 0)) (i64.store offset=152 (get_local 0) (i64.const 0)) (i64.store offset=160 (get_local 0) (i64.const 0)) (i64.store offset=168 (get_local 0) (i64.const 0)) (i64.store offset=176 (get_local 0) (i64.const 0)) (i64.store offset=184 (get_local 0) (i64.const 0)) (i64.store offset=192 (get_local 0) (i64.const 0)) (i64.store offset=200 (get_local 0) (i64.const 0)) (i64.store offset=208 (get_local 0) (i64.const 0)) (i64.store offset=216 (get_local 0) (i64.const 0)) (i64.store offset=224 (get_local 0) (i64.const 0)) (i64.store offset=232 (get_local 0) (i64.const 0)) (i64.store offset=240 (get_local 0) (i64.const 0)) (i64.store offset=248 (get_local 0) (i64.const 0)) (i64.store offset=256 (get_local 0) (i64.const 0)) (i64.store offset=264 (get_local 0) (i64.const 0)) (i64.store offset=272 (get_local 0) (i64.const 0)) (i64.store offset=280 (get_local 0) (i64.const 0)) (i64.store offset=288 (get_local 0) (i64.const 0)) (i64.store offset=296 (get_local 0) (i64.const 0)) (i64.store offset=304 (get_local 0) (i64.const 0)) (i64.store offset=312 (get_local 0) (i64.const 0)) (i64.store offset=320 (get_local 0) (i64.const 0)) (i64.store offset=328 (get_local 0) (i64.const 0)) (i64.store offset=336 (get_local 0) (i64.const 0)) (i64.store offset=344 (get_local 0) (i64.const 0)) (i64.store offset=352 (get_local 0) (i64.const 0)) (i64.store offset=360 (get_local 0) (i64.const 0)) (i64.store offset=368 (get_local 0) (i64.const 0)) (i64.store offset=376 (get_local 0) (i64.const 0)) (i64.store offset=384 (get_local 0) (i64.const 0)) (i64.store offset=392 (get_local 0) (i64.const 0)) (i64.store offset=400 (get_local 0) (i64.const 0)) (i64.store offset=408 (get_local 0) (i64.const 0)) (i64.store offset=416 (get_local 0) (i64.const 0)) (i64.store offset=424 (get_local 0) (i64.const 0)) (i64.store offset=432 (get_local 0) (i64.const 0)) (i64.store offset=440 (get_local 0) (i64.const 0)) (i64.store offset=448 (get_local 0) (i64.const 0)) (i64.store offset=456 (get_local 0) (i64.const 0)) (i64.store offset=464 (get_local 0) (i64.const 0)) (i64.store offset=472 (get_local 0) (i64.const 0)) (i64.store offset=480 (get_local 0) (i64.const 0)) (i64.store offset=488 (get_local 0) (i64.const 0)) (i64.store offset=496 (get_local 0) (i64.const 0)) (i64.store offset=504 (get_local 0) (i64.const 0)) (i64.store offset=512 (get_local 0) (i64.const 0)) (i64.store offset=520 (get_local 0) (i64.const 0)) (i64.store offset=528 (get_local 0) (i64.const 0)) (i64.store offset=536 (get_local 0) (i64.const 0)) (i64.store offset=544 (get_local 0) (i64.const 0)) (i64.store offset=552 (get_local 0) (i64.const 0)) (i64.store offset=560 (get_local 0) (i64.const 0)) (i64.store offset=568 (get_local 0) (i64.const 0)) (i64.store offset=576 (get_local 0) (i64.const 0)) (i64.store offset=584 (get_local 0) (i64.const 0)) (i64.store offset=592 (get_local 0) (i64.const 0)) (i64.store offset=600 (get_local 0) (i64.const 0)) (i64.store offset=608 (get_local 0) (i64.const 0)) (i64.store offset=616 (get_local 0) (i64.const 0)) (i64.store offset=624 (get_local 0) (i64.const 0)) (i64.store offset=632 (get_local 0) (i64.const 0)) (i64.store offset=640 (get_local 0) (i64.const 0)) (i64.store offset=648 (get_local 0) (i64.const 0)) (i64.store offset=656 (get_local 0) (i64.const 0)) (i64.store offset=664 (get_local 0) (i64.const 0)) (i64.store offset=672 (get_local 0) (i64.const 0)) (i64.store offset=680 (get_local 0) (i64.const 0)) (i64.store offset=688 (get_local 0) (i64.const 0)) (i64.store offset=696 (get_local 0) (i64.const 0)) (i64.store offset=704 (get_local 0) (i64.const 0)) (i64.store offset=712 (get_local 0) (i64.const 0)) (i64.store offset=720 (get_local 0) (i64.const 0)) (i64.store offset=728 (get_local 0) (i64.const 0)) (i64.store offset=736 (get_local 0) (i64.const 0)) (i64.store offset=744 (get_local 0) (i64.const 0)) (i64.store offset=752 (get_local 0) (i64.const 0)) (i64.store offset=760 (get_local 0) (i64.const 0)) (i64.store offset=768 (get_local 0) (i64.const 0)) (i64.store offset=776 (get_local 0) (i64.const 0)) (i64.store offset=784 (get_local 0) (i64.const 0)) (i64.store offset=792 (get_local 0) (i64.const 0)) (i64.store offset=800 (get_local 0) (i64.const 0)) (i64.store offset=808 (get_local 0) (i64.const 0)) (i64.store offset=816 (get_local 0) (i64.const 0)) (i64.store offset=824 (get_local 0) (i64.const 0)) (i64.store offset=832 (get_local 0) (i64.const 0)) (i64.store offset=840 (get_local 0) (i64.const 0)) (i64.store offset=848 (get_local 0) (i64.const 0)) (i64.store offset=856 (get_local 0) (i64.const 0)) (i64.store offset=864 (get_local 0) (i64.const 0)) (i64.store offset=872 (get_local 0) (i64.const 0)) (i64.store offset=880 (get_local 0) (i64.const 0)) (i64.store offset=888 (get_local 0) (i64.const 0)) (i64.store offset=896 (get_local 0) (i64.const 0)) (i64.store offset=904 (get_local 0) (i64.const 0)) (i64.store offset=912 (get_local 0) (i64.const 0)) (i64.store offset=920 (get_local 0) (i64.const 0)) (i64.store offset=928 (get_local 0) (i64.const 0)) (i64.store offset=936 (get_local 0) (i64.const 0)) (i64.store offset=944 (get_local 0) (i64.const 0)) (i64.store offset=952 (get_local 0) (i64.const 0)) (i64.store offset=960 (get_local 0) (i64.const 0)) (i64.store offset=968 (get_local 0) (i64.const 0)) (i64.store offset=976 (get_local 0) (i64.const 0)) (i64.store offset=984 (get_local 0) (i64.const 0)) (i64.store offset=992 (get_local 0) (i64.const 0)) (i64.store offset=1000 (get_local 0) (i64.const 0)) (i64.store offset=1008 (get_local 0) (i64.const 0)) (i64.store offset=1016 (get_local 0) (i64.const 0)) (i64.store offset=1024 (get_local 0) (i64.const 0)) (i64.store offset=1032 (get_local 0) (i64.const 0)) (i64.store offset=1040 (get_local 0) (i64.const 0)) (i64.store offset=1048 (get_local 0) (i64.const 0)) (i64.store offset=1056 (get_local 0) (i64.const 0)) (i64.store offset=1064 (get_local 0) (i64.const 0)) (i64.store offset=1072 (get_local 0) (i64.const 0)) (i64.store offset=1080 (get_local 0) (i64.const 0)) (i64.store offset=1088 (get_local 0) (i64.const 0)) (i64.store offset=1096 (get_local 0) (i64.const 0)) (i64.store offset=1104 (get_local 0) (i64.const 0)) (i64.store offset=1112 (get_local 0) (i64.const 0)) (i64.store offset=1120 (get_local 0) (i64.const 0)) (i64.store offset=1128 (get_local 0) (i64.const 0)) (i64.store offset=1136 (get_local 0) (i64.const 0)) (i64.store offset=1144 (get_local 0) (i64.const 0)) (i64.store offset=1152 (get_local 0) (i64.const 0)) (i64.store offset=1160 (get_local 0) (i64.const 0)) (i64.store offset=1168 (get_local 0) (i64.const 0)) (i64.store offset=1176 (get_local 0) (i64.const 0)) (i64.store offset=1184 (get_local 0) (i64.const 0)) (i64.store offset=1192 (get_local 0) (i64.const 0)) (i64.store offset=1200 (get_local 0) (i64.const 0)) (i64.store offset=1208 (get_local 0) (i64.const 0)) (i64.store offset=1216 (get_local 0) (i64.const 0)) (i64.store offset=1224 (get_local 0) (i64.const 0)) (i64.store offset=1232 (get_local 0) (i64.const 0)) (i64.store offset=1240 (get_local 0) (i64.const 0)) (i64.store offset=1248 (get_local 0) (i64.const 0)) (i64.store offset=1256 (get_local 0) (i64.const 0)) (i64.store offset=1264 (get_local 0) (i64.const 0)) (i64.store offset=1272 (get_local 0) (i64.const 0)) (i64.store offset=1280 (get_local 0) (i64.const 0)) (i64.store offset=1288 (get_local 0) (i64.const 0)) (i64.store offset=1296 (get_local 0) (i64.const 0)) (i64.store offset=1304 (get_local 0) (i64.const 0)) (i64.store offset=1312 (get_local 0) (i64.const 0)) (i64.store offset=1320 (get_local 0) (i64.const 0)) (i64.store offset=1328 (get_local 0) (i64.const 0)) (i64.store offset=1336 (get_local 0) (i64.const 0)) (i64.store offset=1344 (get_local 0) (i64.const 0)) (i64.store offset=1352 (get_local 0) (i64.const 0)) (i64.store offset=1360 (get_local 0) (i64.const 0)) (i64.store offset=1368 (get_local 0) (i64.const 0)) (i64.store offset=1376 (get_local 0) (i64.const 0)) (i64.store offset=1384 (get_local 0) (i64.const 0)) (i64.store offset=1392 (get_local 0) (i64.const 0)) (i64.store offset=1400 (get_local 0) (i64.const 0)) (i64.store offset=1408 (get_local 0) (i64.const 0)) (i64.store offset=1416 (get_local 0) (i64.const 0)) (i64.store offset=1424 (get_local 0) (i64.const 0)) (i64.store offset=1432 (get_local 0) (i64.const 0)) (i64.store offset=1440 (get_local 0) (i64.const 0)) (i64.store offset=1448 (get_local 0) (i64.const 0)) (i64.store offset=1456 (get_local 0) (i64.const 0)) (i64.store offset=1464 (get_local 0) (i64.const 0)) (i64.store offset=1472 (get_local 0) (i64.const 0)) (i64.store offset=1480 (get_local 0) (i64.const 0)) (i64.store offset=1488 (get_local 0) (i64.const 0)) (i64.store offset=1496 (get_local 0) (i64.const 0)) (i64.store offset=1504 (get_local 0) (i64.const 0)) (i64.store offset=1512 (get_local 0) (i64.const 0)) (i64.store offset=1520 (get_local 0) (i64.const 0)) (i64.store offset=1528 (get_local 0) (i64.const 0)) (i64.store offset=1536 (get_local 0) (i64.const 0)) (i64.store offset=1544 (get_local 0) (i64.const 0)) (i64.store offset=1552 (get_local 0) (i64.const 0)) (i64.store offset=1560 (get_local 0) (i64.const 0)) (i64.store offset=1568 (get_local 0) (i64.const 0)) (i64.store offset=1576 (get_local 0) (i64.const 0)) (i64.store offset=1584 (get_local 0) (i64.const 0)) (i64.store offset=1592 (get_local 0) (i64.const 0)) (i64.store offset=1600 (get_local 0) (i64.const 0)) (i64.store offset=1608 (get_local 0) (i64.const 0)) (i64.store offset=1616 (get_local 0) (i64.const 0)) (i64.store offset=1624 (get_local 0) (i64.const 0)) (i64.store offset=1632 (get_local 0) (i64.const 0)) (i64.store offset=1640 (get_local 0) (i64.const 0)) (i64.store offset=1648 (get_local 0) (i64.const 0)) (i64.store offset=1656 (get_local 0) (i64.const 0)) (i64.store offset=1664 (get_local 0) (i64.const 0)) (i64.store offset=1672 (get_local 0) (i64.const 0)) (i64.store offset=1680 (get_local 0) (i64.const 0)) (i64.store offset=1688 (get_local 0) (i64.const 0)) (i64.store offset=1696 (get_local 0) (i64.const 0)) (i64.store offset=1704 (get_local 0) (i64.const 0)) (i64.store offset=1712 (get_local 0) (i64.const 0)) (i64.store offset=1720 (get_local 0) (i64.const 0)) (i64.store offset=1728 (get_local 0) (i64.const 0)) (i64.store offset=1736 (get_local 0) (i64.const 0)) (i64.store offset=1744 (get_local 0) (i64.const 0)) (i64.store offset=1752 (get_local 0) (i64.const 0)) (i64.store offset=1760 (get_local 0) (i64.const 0)) (i64.store offset=1768 (get_local 0) (i64.const 0)) (i64.store offset=1776 (get_local 0) (i64.const 0)) (i64.store offset=1784 (get_local 0) (i64.const 0)) (i64.store offset=1792 (get_local 0) (i64.const 0)) (i64.store offset=1800 (get_local 0) (i64.const 0)) (i64.store offset=1808 (get_local 0) (i64.const 0)) (i64.store offset=1816 (get_local 0) (i64.const 0)) (i64.store offset=1824 (get_local 0) (i64.const 0)) (i64.store offset=1832 (get_local 0) (i64.const 0)) (i64.store offset=1840 (get_local 0) (i64.const 0)) (i64.store offset=1848 (get_local 0) (i64.const 0)) (i64.store offset=1856 (get_local 0) (i64.const 0)) (i64.store offset=1864 (get_local 0) (i64.const 0)) (i64.store offset=1872 (get_local 0) (i64.const 0)) (i64.store offset=1880 (get_local 0) (i64.const 0)) (i64.store offset=1888 (get_local 0) (i64.const 0)) (i64.store offset=1896 (get_local 0) (i64.const 0)) (i64.store offset=1904 (get_local 0) (i64.const 0)) (i64.store offset=1912 (get_local 0) (i64.const 0)) (i64.store offset=1920 (get_local 0) (i64.const 0)) (i64.store offset=1928 (get_local 0) (i64.const 0)) (i64.store offset=1936 (get_local 0) (i64.const 0)) (i64.store offset=1944 (get_local 0) (i64.const 0)) (i64.store offset=1952 (get_local 0) (i64.const 0)) (i64.store offset=1960 (get_local 0) (i64.const 0)) (i64.store offset=1968 (get_local 0) (i64.const 0)) (i64.store offset=1976 (get_local 0) (i64.const 0)) (i64.store offset=1984 (get_local 0) (i64.const 0)) (i64.store offset=1992 (get_local 0) (i64.const 0)) (i64.store offset=2000 (get_local 0) (i64.const 0)) (i64.store offset=2008 (get_local 0) (i64.const 0)) (i64.store offset=2016 (get_local 0) (i64.const 0)) (i64.store offset=2024 (get_local 0) (i64.const 0)) (i64.store offset=2032 (get_local 0) (i64.const 0)) (i64.store offset=2040 (get_local 0) (i64.const 0)) (i32.store offset=2048 (get_local 0) (i32.const 0)) (i32.store offset=2052 (get_local 0) (get_local 1)) (i32.store offset=2056 (get_local 0) (i32.div_u (i32.const 63480) (get_local 1)))) (func $gc--append-heap-page (param i32 i32 i32) (local i32 i32 i32) (set_local 3 (i32.mul (i32.const 4) (if i32 (i32.le_u (get_local 2) (i32.const 128)) (if i32 (i32.le_u (get_local 2) (i32.const 8)) (if i32 (i32.le_u (get_local 2) (i32.const 4)) (i32.const 0) (i32.const 1)) (if i32 (i32.le_u (get_local 2) (i32.const 32)) (if i32 (i32.le_u (get_local 2) (i32.const 16)) (i32.const 2) (i32.const 3)) (if i32 (i32.le_u (get_local 2) (i32.const 64)) (i32.const 4) (i32.const 5)))) (if i32 (i32.le_u (get_local 2) (i32.const 1024)) (if i32 (i32.le_u (get_local 2) (i32.const 512)) (if i32 (i32.le_u (get_local 2) (i32.const 256)) (i32.const 6) (i32.const 7)) (i32.const 8)) (if i32 (i32.le_u (get_local 2) (i32.const 2048)) (i32.const 9) (if i32 (i32.le_u (get_local 2) (i32.const 4096)) (i32.const 10) (unreachable))))))) (set_local 4 (i32.load offset=0 (i32.add (get_local 0) (get_local 3)))) (if (i32.eqz (get_local 4)) (i32.store offset=0 (i32.add (get_local 0) (get_local 3)) (get_local 1)) (loop $loop (set_local 5 (i32.load offset=2048 (get_local 4))) (if (i32.eqz (get_local 5)) (block (i32.store offset=2048 (get_local 4) (get_local 1)) (return)) (set_local 4 (get_local 5))) (br $loop)))) (func $gc-extend-heap-page (param i32 i32) (local i32) (set_local 2 (call $new-heap-page)) (call $init-heap-page (get_local 2) (get_local 1)) (call $gc--append-heap-page (get_local 0) (get_local 2) (get_local 1))) (func $gc--alloc-page (param i32 i32) (result i32) (local i64 i32 i32 i32) (block $outer (loop $loop (if (i32.le_u (i32.const 256) (get_local 3)) (br $outer)) (set_local 2 (i64.load offset=0 (i32.add (get_local 0) (get_local 3)))) (if (i64.eq (i64.const -1) (get_local 2)) (br $loop)) (set_local 4 (i32.wrap/i64 (i64.ctz (i64.sub (i64.const -1) (get_local 2))))) (set_local 5 (i32.add (i32.mul (get_local 3) (i32.const 64)) (get_local 4))) (if (i32.le_u (i32.load offset=2056 (get_local 0)) (get_local 5)) (return (i32.const 0)) (block (i64.store offset=0 (i32.add (get_local 0) (get_local 3)) (i64.or (get_local 2) (i64.shl (i64.const 1) (i64.extend_u/i32 (get_local 4))))) (return (i32.add (i32.add (get_local 0) (i32.const 2060)) (i32.mul (get_local 5) (get_local 1)))))) (br $loop))) (i32.const 0)) (func $gc--alloc-pages (param i32 i32) (result i32) (local i32) (loop $loop (if (i32.eqz (get_local 0)) (return (i32.const 0))) (if (i32.eqz (tee_local 2 (call $gc--alloc-page (get_local 0) (get_local 1)))) (set_local 2 (i32.load offset=2048 (get_local 0))) (return (get_local 2))) (br $loop)) (unreachable)) (func $gc--alloc (param i32 i32) (result i32) (local i32 i32) (set_local 3 (if i32 (i32.le_u (get_local 1) (i32.const 128)) (if i32 (i32.le_u (get_local 1) (i32.const 8)) (if i32 (i32.le_u (get_local 1) (i32.const 4)) (i32.const 0) (i32.const 1)) (if i32 (i32.le_u (get_local 1) (i32.const 32)) (if i32 (i32.le_u (get_local 1) (i32.const 16)) (i32.const 2) (i32.const 3)) (if i32 (i32.le_u (get_local 1) (i32.const 64)) (i32.const 4) (i32.const 5)))) (if i32 (i32.le_u (get_local 1) (i32.const 1024)) (if i32 (i32.le_u (get_local 1) (i32.const 512)) (if i32 (i32.le_u (get_local 1) (i32.const 256)) (i32.const 6) (i32.const 7)) (i32.const 8)) (if i32 (i32.le_u (get_local 1) (i32.const 2048)) (i32.const 9) (if i32 (i32.le_u (get_local 1) (i32.const 4096)) (i32.const 10) (unreachable)))))) (set_local 2 (i32.load offset=0 (i32.add (get_local 0) (get_local 3)))) (call $gc--alloc-pages (get_local 2) (get_local 1))) (func $gc-alloc (param i32 i32) (result i32) (local i32 i32) (if (i32.eqz (tee_local 3 (call $gc--alloc (get_local 0) (get_local 1)))) (block (call $gc-run (get_local 0)) (if (i32.eqz (tee_local 3 (call $gc--alloc (get_local 0) (get_local 1)))) (block (set_local 2 (get_local 1)) (call $gc-extend-heap-page (get_local 0) (get_local 2)) (if (i32.eqz (tee_local 3 (call $gc--alloc (get_local 0) (get_local 1)))) (unreachable)))))) (get_local 3)) (func $gc-save-state (param i32) (result i32) (i32.load offset=44 (get_local 0))) (func $gc-protect (param i32 i32) (local i32) (set_local 2 (i32.load offset=44 (get_local 0))) (i32.store offset=52 (i32.add (get_local 0) (get_local 2)) (get_local 1)) (i32.store offset=44 (get_local 0) (i32.add (i32.const 4) (get_local 2)))) (func $gc-restore-state (param i32 i32) (i32.store offset=44 (get_local 0) (get_local 1))) (func $gc--clear-marks-page (param i32) (i64.store offset=0 (get_local 0) (i64.const 0)) (i64.store offset=8 (get_local 0) (i64.const 0)) (i64.store offset=16 (get_local 0) (i64.const 0)) (i64.store offset=24 (get_local 0) (i64.const 0)) (i64.store offset=32 (get_local 0) (i64.const 0)) (i64.store offset=40 (get_local 0) (i64.const 0)) (i64.store offset=48 (get_local 0) (i64.const 0)) (i64.store offset=56 (get_local 0) (i64.const 0)) (i64.store offset=64 (get_local 0) (i64.const 0)) (i64.store offset=72 (get_local 0) (i64.const 0)) (i64.store offset=80 (get_local 0) (i64.const 0)) (i64.store offset=88 (get_local 0) (i64.const 0)) (i64.store offset=96 (get_local 0) (i64.const 0)) (i64.store offset=104 (get_local 0) (i64.const 0)) (i64.store offset=112 (get_local 0) (i64.const 0)) (i64.store offset=120 (get_local 0) (i64.const 0)) (i64.store offset=128 (get_local 0) (i64.const 0)) (i64.store offset=136 (get_local 0) (i64.const 0)) (i64.store offset=144 (get_local 0) (i64.const 0)) (i64.store offset=152 (get_local 0) (i64.const 0)) (i64.store offset=160 (get_local 0) (i64.const 0)) (i64.store offset=168 (get_local 0) (i64.const 0)) (i64.store offset=176 (get_local 0) (i64.const 0)) (i64.store offset=184 (get_local 0) (i64.const 0)) (i64.store offset=192 (get_local 0) (i64.const 0)) (i64.store offset=200 (get_local 0) (i64.const 0)) (i64.store offset=208 (get_local 0) (i64.const 0)) (i64.store offset=216 (get_local 0) (i64.const 0)) (i64.store offset=224 (get_local 0) (i64.const 0)) (i64.store offset=232 (get_local 0) (i64.const 0)) (i64.store offset=240 (get_local 0) (i64.const 0)) (i64.store offset=248 (get_local 0) (i64.const 0)) (i64.store offset=256 (get_local 0) (i64.const 0)) (i64.store offset=264 (get_local 0) (i64.const 0)) (i64.store offset=272 (get_local 0) (i64.const 0)) (i64.store offset=280 (get_local 0) (i64.const 0)) (i64.store offset=288 (get_local 0) (i64.const 0)) (i64.store offset=296 (get_local 0) (i64.const 0)) (i64.store offset=304 (get_local 0) (i64.const 0)) (i64.store offset=312 (get_local 0) (i64.const 0)) (i64.store offset=320 (get_local 0) (i64.const 0)) (i64.store offset=328 (get_local 0) (i64.const 0)) (i64.store offset=336 (get_local 0) (i64.const 0)) (i64.store offset=344 (get_local 0) (i64.const 0)) (i64.store offset=352 (get_local 0) (i64.const 0)) (i64.store offset=360 (get_local 0) (i64.const 0)) (i64.store offset=368 (get_local 0) (i64.const 0)) (i64.store offset=376 (get_local 0) (i64.const 0)) (i64.store offset=384 (get_local 0) (i64.const 0)) (i64.store offset=392 (get_local 0) (i64.const 0)) (i64.store offset=400 (get_local 0) (i64.const 0)) (i64.store offset=408 (get_local 0) (i64.const 0)) (i64.store offset=416 (get_local 0) (i64.const 0)) (i64.store offset=424 (get_local 0) (i64.const 0)) (i64.store offset=432 (get_local 0) (i64.const 0)) (i64.store offset=440 (get_local 0) (i64.const 0)) (i64.store offset=448 (get_local 0) (i64.const 0)) (i64.store offset=456 (get_local 0) (i64.const 0)) (i64.store offset=464 (get_local 0) (i64.const 0)) (i64.store offset=472 (get_local 0) (i64.const 0)) (i64.store offset=480 (get_local 0) (i64.const 0)) (i64.store offset=488 (get_local 0) (i64.const 0)) (i64.store offset=496 (get_local 0) (i64.const 0)) (i64.store offset=504 (get_local 0) (i64.const 0)) (i64.store offset=512 (get_local 0) (i64.const 0)) (i64.store offset=520 (get_local 0) (i64.const 0)) (i64.store offset=528 (get_local 0) (i64.const 0)) (i64.store offset=536 (get_local 0) (i64.const 0)) (i64.store offset=544 (get_local 0) (i64.const 0)) (i64.store offset=552 (get_local 0) (i64.const 0)) (i64.store offset=560 (get_local 0) (i64.const 0)) (i64.store offset=568 (get_local 0) (i64.const 0)) (i64.store offset=576 (get_local 0) (i64.const 0)) (i64.store offset=584 (get_local 0) (i64.const 0)) (i64.store offset=592 (get_local 0) (i64.const 0)) (i64.store offset=600 (get_local 0) (i64.const 0)) (i64.store offset=608 (get_local 0) (i64.const 0)) (i64.store offset=616 (get_local 0) (i64.const 0)) (i64.store offset=624 (get_local 0) (i64.const 0)) (i64.store offset=632 (get_local 0) (i64.const 0)) (i64.store offset=640 (get_local 0) (i64.const 0)) (i64.store offset=648 (get_local 0) (i64.const 0)) (i64.store offset=656 (get_local 0) (i64.const 0)) (i64.store offset=664 (get_local 0) (i64.const 0)) (i64.store offset=672 (get_local 0) (i64.const 0)) (i64.store offset=680 (get_local 0) (i64.const 0)) (i64.store offset=688 (get_local 0) (i64.const 0)) (i64.store offset=696 (get_local 0) (i64.const 0)) (i64.store offset=704 (get_local 0) (i64.const 0)) (i64.store offset=712 (get_local 0) (i64.const 0)) (i64.store offset=720 (get_local 0) (i64.const 0)) (i64.store offset=728 (get_local 0) (i64.const 0)) (i64.store offset=736 (get_local 0) (i64.const 0)) (i64.store offset=744 (get_local 0) (i64.const 0)) (i64.store offset=752 (get_local 0) (i64.const 0)) (i64.store offset=760 (get_local 0) (i64.const 0)) (i64.store offset=768 (get_local 0) (i64.const 0)) (i64.store offset=776 (get_local 0) (i64.const 0)) (i64.store offset=784 (get_local 0) (i64.const 0)) (i64.store offset=792 (get_local 0) (i64.const 0)) (i64.store offset=800 (get_local 0) (i64.const 0)) (i64.store offset=808 (get_local 0) (i64.const 0)) (i64.store offset=816 (get_local 0) (i64.const 0)) (i64.store offset=824 (get_local 0) (i64.const 0)) (i64.store offset=832 (get_local 0) (i64.const 0)) (i64.store offset=840 (get_local 0) (i64.const 0)) (i64.store offset=848 (get_local 0) (i64.const 0)) (i64.store offset=856 (get_local 0) (i64.const 0)) (i64.store offset=864 (get_local 0) (i64.const 0)) (i64.store offset=872 (get_local 0) (i64.const 0)) (i64.store offset=880 (get_local 0) (i64.const 0)) (i64.store offset=888 (get_local 0) (i64.const 0)) (i64.store offset=896 (get_local 0) (i64.const 0)) (i64.store offset=904 (get_local 0) (i64.const 0)) (i64.store offset=912 (get_local 0) (i64.const 0)) (i64.store offset=920 (get_local 0) (i64.const 0)) (i64.store offset=928 (get_local 0) (i64.const 0)) (i64.store offset=936 (get_local 0) (i64.const 0)) (i64.store offset=944 (get_local 0) (i64.const 0)) (i64.store offset=952 (get_local 0) (i64.const 0)) (i64.store offset=960 (get_local 0) (i64.const 0)) (i64.store offset=968 (get_local 0) (i64.const 0)) (i64.store offset=976 (get_local 0) (i64.const 0)) (i64.store offset=984 (get_local 0) (i64.const 0)) (i64.store offset=992 (get_local 0) (i64.const 0)) (i64.store offset=1000 (get_local 0) (i64.const 0)) (i64.store offset=1008 (get_local 0) (i64.const 0)) (i64.store offset=1016 (get_local 0) (i64.const 0)) (i64.store offset=1024 (get_local 0) (i64.const 0)) (i64.store offset=1032 (get_local 0) (i64.const 0)) (i64.store offset=1040 (get_local 0) (i64.const 0)) (i64.store offset=1048 (get_local 0) (i64.const 0)) (i64.store offset=1056 (get_local 0) (i64.const 0)) (i64.store offset=1064 (get_local 0) (i64.const 0)) (i64.store offset=1072 (get_local 0) (i64.const 0)) (i64.store offset=1080 (get_local 0) (i64.const 0)) (i64.store offset=1088 (get_local 0) (i64.const 0)) (i64.store offset=1096 (get_local 0) (i64.const 0)) (i64.store offset=1104 (get_local 0) (i64.const 0)) (i64.store offset=1112 (get_local 0) (i64.const 0)) (i64.store offset=1120 (get_local 0) (i64.const 0)) (i64.store offset=1128 (get_local 0) (i64.const 0)) (i64.store offset=1136 (get_local 0) (i64.const 0)) (i64.store offset=1144 (get_local 0) (i64.const 0)) (i64.store offset=1152 (get_local 0) (i64.const 0)) (i64.store offset=1160 (get_local 0) (i64.const 0)) (i64.store offset=1168 (get_local 0) (i64.const 0)) (i64.store offset=1176 (get_local 0) (i64.const 0)) (i64.store offset=1184 (get_local 0) (i64.const 0)) (i64.store offset=1192 (get_local 0) (i64.const 0)) (i64.store offset=1200 (get_local 0) (i64.const 0)) (i64.store offset=1208 (get_local 0) (i64.const 0)) (i64.store offset=1216 (get_local 0) (i64.const 0)) (i64.store offset=1224 (get_local 0) (i64.const 0)) (i64.store offset=1232 (get_local 0) (i64.const 0)) (i64.store offset=1240 (get_local 0) (i64.const 0)) (i64.store offset=1248 (get_local 0) (i64.const 0)) (i64.store offset=1256 (get_local 0) (i64.const 0)) (i64.store offset=1264 (get_local 0) (i64.const 0)) (i64.store offset=1272 (get_local 0) (i64.const 0)) (i64.store offset=1280 (get_local 0) (i64.const 0)) (i64.store offset=1288 (get_local 0) (i64.const 0)) (i64.store offset=1296 (get_local 0) (i64.const 0)) (i64.store offset=1304 (get_local 0) (i64.const 0)) (i64.store offset=1312 (get_local 0) (i64.const 0)) (i64.store offset=1320 (get_local 0) (i64.const 0)) (i64.store offset=1328 (get_local 0) (i64.const 0)) (i64.store offset=1336 (get_local 0) (i64.const 0)) (i64.store offset=1344 (get_local 0) (i64.const 0)) (i64.store offset=1352 (get_local 0) (i64.const 0)) (i64.store offset=1360 (get_local 0) (i64.const 0)) (i64.store offset=1368 (get_local 0) (i64.const 0)) (i64.store offset=1376 (get_local 0) (i64.const 0)) (i64.store offset=1384 (get_local 0) (i64.const 0)) (i64.store offset=1392 (get_local 0) (i64.const 0)) (i64.store offset=1400 (get_local 0) (i64.const 0)) (i64.store offset=1408 (get_local 0) (i64.const 0)) (i64.store offset=1416 (get_local 0) (i64.const 0)) (i64.store offset=1424 (get_local 0) (i64.const 0)) (i64.store offset=1432 (get_local 0) (i64.const 0)) (i64.store offset=1440 (get_local 0) (i64.const 0)) (i64.store offset=1448 (get_local 0) (i64.const 0)) (i64.store offset=1456 (get_local 0) (i64.const 0)) (i64.store offset=1464 (get_local 0) (i64.const 0)) (i64.store offset=1472 (get_local 0) (i64.const 0)) (i64.store offset=1480 (get_local 0) (i64.const 0)) (i64.store offset=1488 (get_local 0) (i64.const 0)) (i64.store offset=1496 (get_local 0) (i64.const 0)) (i64.store offset=1504 (get_local 0) (i64.const 0)) (i64.store offset=1512 (get_local 0) (i64.const 0)) (i64.store offset=1520 (get_local 0) (i64.const 0)) (i64.store offset=1528 (get_local 0) (i64.const 0)) (i64.store offset=1536 (get_local 0) (i64.const 0)) (i64.store offset=1544 (get_local 0) (i64.const 0)) (i64.store offset=1552 (get_local 0) (i64.const 0)) (i64.store offset=1560 (get_local 0) (i64.const 0)) (i64.store offset=1568 (get_local 0) (i64.const 0)) (i64.store offset=1576 (get_local 0) (i64.const 0)) (i64.store offset=1584 (get_local 0) (i64.const 0)) (i64.store offset=1592 (get_local 0) (i64.const 0)) (i64.store offset=1600 (get_local 0) (i64.const 0)) (i64.store offset=1608 (get_local 0) (i64.const 0)) (i64.store offset=1616 (get_local 0) (i64.const 0)) (i64.store offset=1624 (get_local 0) (i64.const 0)) (i64.store offset=1632 (get_local 0) (i64.const 0)) (i64.store offset=1640 (get_local 0) (i64.const 0)) (i64.store offset=1648 (get_local 0) (i64.const 0)) (i64.store offset=1656 (get_local 0) (i64.const 0)) (i64.store offset=1664 (get_local 0) (i64.const 0)) (i64.store offset=1672 (get_local 0) (i64.const 0)) (i64.store offset=1680 (get_local 0) (i64.const 0)) (i64.store offset=1688 (get_local 0) (i64.const 0)) (i64.store offset=1696 (get_local 0) (i64.const 0)) (i64.store offset=1704 (get_local 0) (i64.const 0)) (i64.store offset=1712 (get_local 0) (i64.const 0)) (i64.store offset=1720 (get_local 0) (i64.const 0)) (i64.store offset=1728 (get_local 0) (i64.const 0)) (i64.store offset=1736 (get_local 0) (i64.const 0)) (i64.store offset=1744 (get_local 0) (i64.const 0)) (i64.store offset=1752 (get_local 0) (i64.const 0)) (i64.store offset=1760 (get_local 0) (i64.const 0)) (i64.store offset=1768 (get_local 0) (i64.const 0)) (i64.store offset=1776 (get_local 0) (i64.const 0)) (i64.store offset=1784 (get_local 0) (i64.const 0)) (i64.store offset=1792 (get_local 0) (i64.const 0)) (i64.store offset=1800 (get_local 0) (i64.const 0)) (i64.store offset=1808 (get_local 0) (i64.const 0)) (i64.store offset=1816 (get_local 0) (i64.const 0)) (i64.store offset=1824 (get_local 0) (i64.const 0)) (i64.store offset=1832 (get_local 0) (i64.const 0)) (i64.store offset=1840 (get_local 0) (i64.const 0)) (i64.store offset=1848 (get_local 0) (i64.const 0)) (i64.store offset=1856 (get_local 0) (i64.const 0)) (i64.store offset=1864 (get_local 0) (i64.const 0)) (i64.store offset=1872 (get_local 0) (i64.const 0)) (i64.store offset=1880 (get_local 0) (i64.const 0)) (i64.store offset=1888 (get_local 0) (i64.const 0)) (i64.store offset=1896 (get_local 0) (i64.const 0)) (i64.store offset=1904 (get_local 0) (i64.const 0)) (i64.store offset=1912 (get_local 0) (i64.const 0)) (i64.store offset=1920 (get_local 0) (i64.const 0)) (i64.store offset=1928 (get_local 0) (i64.const 0)) (i64.store offset=1936 (get_local 0) (i64.const 0)) (i64.store offset=1944 (get_local 0) (i64.const 0)) (i64.store offset=1952 (get_local 0) (i64.const 0)) (i64.store offset=1960 (get_local 0) (i64.const 0)) (i64.store offset=1968 (get_local 0) (i64.const 0)) (i64.store offset=1976 (get_local 0) (i64.const 0)) (i64.store offset=1984 (get_local 0) (i64.const 0)) (i64.store offset=1992 (get_local 0) (i64.const 0)) (i64.store offset=2000 (get_local 0) (i64.const 0)) (i64.store offset=2008 (get_local 0) (i64.const 0)) (i64.store offset=2016 (get_local 0) (i64.const 0)) (i64.store offset=2024 (get_local 0) (i64.const 0)) (i64.store offset=2032 (get_local 0) (i64.const 0)) (i64.store offset=2040 (get_local 0) (i64.const 0))) (func $gc--clear-marks-pages (param i32) (loop $loop (if (i32.eqz (get_local 0)) (return)) (call $gc--clear-marks-page (get_local 0)) (set_local 0 (i32.load offset=2048 (get_local 0))) (br $loop))) (func $gc--clear-marks (param i32) (call $gc--clear-marks-pages (i32.load offset=0 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=4 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=8 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=12 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=16 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=20 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=24 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=28 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=32 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=36 (get_local 0))) (call $gc--clear-marks-pages (i32.load offset=40 (get_local 0)))) (func $gc--mark-data (param i32) (result i32) (i32.const 1)) (func $gc--mark-ptr (param i32) (result i32) (local i32 i32 i64 i64 i32 i32 i32) (set_local 1 (i32.and (i32.const -65536) (get_local 0))) (set_local 2 (i32.load offset=2052 (get_local 1))) (set_local 5 (i32.div_u (i32.sub (get_local 0) (i32.add (get_local 1) (i32.const 2060))) (get_local 2))) (set_local 6 (i32.div_u (get_local 5) (i32.const 64))) (set_local 7 (i32.rem_u (get_local 5) (i32.const 64))) (set_local 3 (i64.load offset=0 (i32.add (get_local 1) (i32.mul (get_local 6) (i32.const 8))))) (set_local 4 (i64.shl (i64.const 1) (i64.extend_u/i32 (get_local 7)))) (if (i64.eqz (i64.and (get_local 3) (get_local 4))) (block (i64.store offset=0 (i32.add (get_local 1) (i32.mul (get_local 6) (i32.const 8))) (i64.or (get_local 3) (get_local 4))) (return (call $gc--mark-data (get_local 0))))) (return (i32.const 1))) (func $gc--mark (param i32) (local i32 i32) (set_local 1 (i32.load offset=44 (get_local 0))) (loop $loop (if (i32.le_u (get_local 1) (get_local 2)) (return)) (drop (call $gc--mark-ptr (i32.load offset=52 (i32.add (get_local 2) (get_local 0))))) (set_local 2 (i32.add (get_local 2 (i32.const 4)))) (br $loop))) (func $gc-run (param i32) (call $gc--clear-marks (get_local 0)) (call $gc--mark (get_local 0))) (func $gc--allocated-data-page (param i32) (result i32) (local i32) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=0 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=8 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=16 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=24 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=32 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=40 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=48 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=56 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=64 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=72 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=80 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=88 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=96 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=104 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=112 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=120 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=128 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=136 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=144 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=152 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=160 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=168 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=176 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=184 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=192 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=200 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=208 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=216 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=224 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=232 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=240 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=248 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=256 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=264 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=272 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=280 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=288 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=296 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=304 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=312 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=320 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=328 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=336 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=344 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=352 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=360 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=368 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=376 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=384 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=392 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=400 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=408 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=416 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=424 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=432 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=440 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=448 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=456 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=464 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=472 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=480 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=488 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=496 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=504 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=512 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=520 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=528 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=536 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=544 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=552 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=560 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=568 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=576 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=584 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=592 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=600 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=608 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=616 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=624 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=632 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=640 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=648 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=656 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=664 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=672 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=680 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=688 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=696 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=704 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=712 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=720 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=728 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=736 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=744 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=752 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=760 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=768 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=776 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=784 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=792 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=800 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=808 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=816 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=824 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=832 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=840 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=848 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=856 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=864 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=872 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=880 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=888 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=896 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=904 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=912 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=920 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=928 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=936 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=944 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=952 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=960 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=968 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=976 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=984 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=992 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1000 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1008 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1016 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1024 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1032 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1040 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1048 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1056 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1064 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1072 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1080 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1088 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1096 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1104 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1112 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1120 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1128 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1136 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1144 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1152 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1160 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1168 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1176 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1184 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1192 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1200 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1208 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1216 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1224 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1232 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1240 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1248 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1256 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1264 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1272 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1280 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1288 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1296 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1304 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1312 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1320 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1328 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1336 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1344 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1352 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1360 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1368 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1376 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1384 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1392 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1400 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1408 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1416 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1424 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1432 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1440 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1448 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1456 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1464 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1472 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1480 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1488 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1496 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1504 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1512 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1520 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1528 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1536 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1544 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1552 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1560 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1568 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1576 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1584 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1592 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1600 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1608 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1616 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1624 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1632 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1640 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1648 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1656 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1664 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1672 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1680 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1688 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1696 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1704 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1712 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1720 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1728 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1736 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1744 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1752 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1760 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1768 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1776 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1784 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1792 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1800 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1808 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1816 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1824 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1832 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1840 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1848 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1856 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1864 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1872 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1880 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1888 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1896 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1904 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1912 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1920 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1928 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1936 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1944 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1952 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1960 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1968 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1976 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1984 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=1992 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=2000 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=2008 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=2016 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=2024 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=2032 (get_local 0)))))) (set_local 1 (i32.add (get_local 1) (i32.wrap/i64 (i64.popcnt (i64.load offset=2040 (get_local 0)))))) (get_local 1)) (func $gc--allocated-data-pages (param i32) (result i32) (local i32) (loop $loop (if (i32.eqz (get_local 0)) (return (get_local 1))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-page (get_local 0)))) (set_local 0 (i32.load offset=2048 (get_local 0))) (br $loop)) (unreachable)) (func $gc--allocated-data (param i32) (result i32) (local i32) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=0 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=4 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=8 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=12 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=16 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=20 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=24 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=28 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=32 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=36 (get_local 0))))) (set_local 1 (i32.add (get_local 1) (call $gc--allocated-data-pages (i32.load offset=40 (get_local 0))))) (get_local 1)) (func $main (local i32 i32) (set_local 0 (call $new-gc)) (call $gc-init (get_local 0)) (call $print (call $gc--allocated-data (get_local 0))) (set_local 1 (call $gc-save-state (get_local 0))) (call $gc-protect (get_local 0) (call $gc-alloc (get_local 0) (i32.const 4))) (call $gc-protect (get_local 0) (call $gc-alloc (get_local 0) (i32.const 4))) (call $gc-protect (get_local 0) (call $gc-alloc (get_local 0) (i32.const 4))) (call $print (call $gc--allocated-data (get_local 0))) (call $gc-run (get_local 0)) (call $print (call $gc--allocated-data (get_local 0))) (call $gc-restore-state (get_local 0) (get_local 1)) (call $gc-run (get_local 0)) (call $print (call $gc--allocated-data (get_local 0)))) (start $main) (memory 1 10))  /編集\n An efficient non-moving garbage collector for functional languages, K. Ueno, A. Ohori, T. Otomo, In Proc. ACM ICFP Conference, pp:196-208, 2011. [return] A Fully Concurrent Garbage Collector for Functional Programs on Multicore Processors. Katsuhiro Ueno, Atsushi Ohori. To appear in Proc. ICFP, 2016. [return]  ","categories":["WebAssembly","言語実装","GC","Advent Calendar","Advent Calendar 2017"],"category_urls":["/categories/webassembly","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/gc","/categories/advent-calendar","/categories/advent-calendar-2017"],"date":"2017-12-07","title":"WebAssemblyでGC","url":"https://KeenS.github.io/blog/2017/12/07/webassemblynogc/"},
  {"body":"κeenです。Rustその2 Advent Calendar 20173日目の記事です。\nクレートをcargo publishする前に何すればいいんだっけと毎回なるので備忘録 publishするまでの手順自体は過去記事を参考にして下さい\nversion 上げ忘れないようにしましょう。cargo-bumpが便利かもしれません。\nlicense 独自記法のライセンス表記をします。例えばMITとApache-2.0のデュアルライセンスなら\u0026quot;MIT OR Apache-2.0\u0026quot;など。略称はここで調べられます。\n1つ気をつけないといけないのが依存ライブラリのライセンスに違反しないように気をつけないといけないということです。Rustは本体がそうなのでMIT OR Apache-2.0が多いようですがGPLのものもあるかもしれません。一々調べるのは難しいのでcargo-licenseを使うと便利です。\ndescription 好きに書きましょう\ndocumentation 最近はdocs.rsがあるのでhttps://docs.rs/crate-nameが多いでしょうか。 細かくバージョンを指定してhttps://docs.rs/crate-name/version/crate-nameとしてもいいですが、私はよく上げ忘れるので上のものを使っています。\nreadme 概ね readme = \u0026quot;README.md\u0026quot; でしょう。最近はcrates.ioでREADMEを展開するようになったので重要です。\nREADME.mdの内容ですが、\n [![crate-name at crates.io](https://img.shields.io/crates/v/crate-name.svg)](https://crates.io/crates/crate-name) [![crate-name at docs.rs](https://docs.rs/crate-name/badge.svg)](https://docs.rs/crate-name)  などのバッジを付けると親切でしょう。\nrepository 大抵githubのレポジトリです。\nkeywords 好きにつけられます。と言われても困るのですが、依存ライブラリのキーワードなどを見て決めましょう。 昨日紹介した iron_inspect は [\u0026quot;iron\u0026quot;, \u0026quot;log\u0026quot;, \u0026quot;error\u0026quot;, \u0026quot;debug\u0026quot;]というキーワードを付けています。\ncategories 個人的に難敵です。ここにあるものから選ぶのですが、表示名と実際に書く文字列が異なります。\u0026rdquo;Web programming\u0026rdquo;なら[\u0026quot;web-programming\u0026quot;]です。小文字にしてスペースをハイフンにした感じですね。 変なものを書くとcargo packageの時点で怒られます。\n書ける情報はもうちょいあるのですが(badgeとか)ひとまずこれを埋めとけば大丈夫そうです。\nということで小ネタでした\n","categories":["Rust","Advent Calendar","Advent Calendar 2017","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2017","/categories/rust-advent-calendar"],"date":"2017-12-03","title":"クレートを公開する前に埋めておくべきメタデータ","url":"https://KeenS.github.io/blog/2017/12/03/kure_towokoukaisurumaeniumeteokubekimetade_ta/"},
  {"body":"κeenです。Rustその2 Advent Calendar 20172日目の記事です。 タイトルのままです。\n作ったライブラリはiron_inspectで、crates.ioにあります。\nモチベーションとしてはloggerによる通常のアクセスログの他にInternal Server Errorも別途ログ吐きたいよねというもの。 良さげなライブラリがなかったので雑に作りました。 Ironミドルウェアなので Chain に link_after してあげればすぐ使えます。\nResult を取るかそのOkのみをとるかErrを取るか選べます。\nResultを取るのは READMEにある使い方だと\nletmutchain=Chain::new(handler);chain.link_after(Inspect::new(|_req,res|matchres{Ok(r)=\u0026gt;println!(\u0026#34;ok: {:?}\u0026#34;,r),Err(e)=\u0026gt;println!(\u0026#34;err: {:?}\u0026#34;,e),})); な感じですね。\n欲しかったのはこんな感じに Err だけ受けて雑にログ取る仕組みです。\nch.link_after(Inspect::error(|_,err|{error!(\u0026#34;internal errror occurred because of {}\u0026#34;,err);})); 以上\n","categories":["Rust","Advent Calendar","Advent Calendar 2017","Iron","小ネタ","Web","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2017","/categories/iron","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf","/categories/web","/categories/rust-advent-calendar"],"date":"2017-12-02","title":"Ironのレスポンスの中身を覗き見るライブラリを雑に作った","url":"https://KeenS.github.io/blog/2017/12/02/ironnoresuponsunonakamiwonozokimiruraiburariwozatsunitsukutta/"},
  {"body":"κeenです。Rustその2 Advent Calendar 2017が空いてたので小ネタをば。1日目の記事です。 Dependency Injectionの話。\n例えば３層アーキテクチャで組む時には以下のような依存関係が発生します。\n[user interface(web)] | V [logic(service)] | V [database access(dao)] これを他の実装に依存せずにそれぞれの層を書きたい、どうしようという問題設定です。\nナイーブな実装 簡単に考えたらRustならトレイトで抽象化してあげればよさそうです。\nコードにするなら共通インターフェイスにトレイトを定義してあげて\npubtraitUserDao{fn find_user(\u0026amp;self,id: i32)-\u0026gt; Result\u0026lt;Option\u0026lt;User\u0026gt;\u0026gt;;} Dao側は実際のDBに合わせた実装、\nstruct UserPgDao(PgConnection);implUserDaoforUserPgDao{fn find_user(\u0026amp;self,id: i32)-\u0026gt; Result\u0026lt;Option\u0026lt;User\u0026gt;\u0026gt;{// ... }} そしてサービスレイヤはトレイトにのみ依存した実装をかけば１丁あがりです。\nstruct UserService\u0026lt;U: UserDao\u0026gt;(U);impl\u0026lt;U:UserDao\u0026gt;UserService\u0026lt;U\u0026gt;{pubfn get_user_by_id(\u0026amp;self,id: i32)-\u0026gt; Result\u0026lt;Option\u0026lt;User\u0026gt;\u0026gt;{self.0.find_user(id)}} 問題点 シンプルなものなら上のもので問題ありません。問題は複雑な依存関係が発生したときに起こります。\n[Web]/\\/\\[GroupService][UserService]|\\||\\||\\||\\||\\|[GroupDao][UserDao] ここでのUserDaoへの依存のように複数からの依存関係があるとRustの所有権機能によって簡単にはコードを書けなくなります。\n解決策は色々とあろうかと思いますが、ここではその一つ、Cake Patternの亜種によって解決したいと思います。\nRustでCake Pattern Cake PatternはScala由来のDIパターンで、Scala界隈ではそれなりに使われているように思います。 詳しくは 実戦での Scala: Cake パターンを用いた Dependency Injection (DI)  をあたって下さい。以下、Cake Patternは既知のものとして話を進めます。\n幸いなことにCake Patternで必要とされる言語機能はRustにも対応するものがある程度揃っているのでRustに翻訳できます。\n   Scala Rust     トレイト トレイト   自分型アノテーション トレイトの継承   class in class モジュール   抽象メンバー getterメソッド    この対応で翻訳してあげるとDaoとそのComponentはこうなり、\n// 上述記事中のUserRepository相当 pubtraitUserDao{/* ... */}// 上述記事中のUserRepositoryComponent相当 pubtraitHaveUserDao{type UserDao: UserDao;fn user_dao(\u0026amp;self)-\u0026gt; Self::UserDao;} ServiceとそのComponentはこうなります。\n// 上述記事中のUserService相当 traitUserService: HaveUserDao{pubfn get_user_by_id(\u0026amp;self,id: i32)-\u0026gt; Result\u0026lt;Option\u0026lt;User\u0026gt;\u0026gt;{self.user_service().find_user(id)}}// UserServiceはHaveUserDaoにのみ依存するのでそれさえ実装していれば自動で実装を与えられます。 // もちろんテストなどで挙動を上書きしたければ具体的な型での実装で上書きできます。 impl\u0026lt;T:HaveUserDao\u0026gt;UserServiceforT{}// 上述記事中のUserServiceComponent相当 traitHaveUserService{type UserService: UserService;fn user_service(\u0026amp;self)-\u0026gt; Self::UserService;} これで UserService が UserDao を専有しなくなりました。 同じように Group{Dao,Service} も同じようにつくってあげます。\nするとサーバが以下のようにかけます。\nstruct Server { user_dao: UserPgDao, group_dao: GroupPgDao, } impl HaveUserDao for Server { type UserDao = UserPgDao; fn user_dao(\u0026amp;self) -\u0026gt; Self::UserDao { \u0026amp;self.user_dao } } impl HaveUserService for Server{ type UserService = Self; fn user_service(\u0026amp;self) -\u0026gt; Self::UserService { self } } // 同じくGroupも Server の依存する user_dao と gropu_dao も型パラメータで抽象化できますが、実際にその抽象化が必要になることはないでしょう。\nDaoからServerまで矛盾なくコードが書けたので晴れて複依存問題が解決出来ました。以上小ネタでした。\n他の解決策 Daoをコピーする 複数回必要なら複数用意すればいいじゃないという発想。 悪くはないんですが例えばDaoでクエリ結果のキャッシュを持ちたい場合などに不都合です。\nDaoを参照で持つ 悪くはないんですがライフタイムパラメータが増えて型が煩雑になります。\nDaoをArcで持つ HTTPフレームワークが大抵Syncを要求してくるのでRcではだめで、Arcです。 これでもいいと思います。\n結びに 業務でDIするにあたっていい案もなかったので前職でのScalaの経験からCake Patternを使ってみたらとりあえずできたという感じです。 めちゃくちゃ便利という訳でもないですが今の所問題もないのでそのまま使っているのが現状で、誰か他の知見を下さい。\n","categories":["Rust","Advent Calendar","Advent Calendar 2017","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2017","/categories/rust-advent-calendar"],"date":"2017-12-01","title":"RustのDI","url":"https://KeenS.github.io/blog/2017/12/01/rustnodi/"},
  {"body":"κeenです。雰囲気でシェルを使ってる人が多いとのことだったので少しばかり込み入った知識を。 あと一応POSIX準拠かどうかも気にしながらやっていきます。\n基礎知識編 シェルの種類 まず、POSIXにシェルが定義されています。\nこれに最低限の機能で準拠しているものをPOSIXシェルと呼ぶことにします。いわゆる/bin/shです。具体的な実装はbsh、ash、dashあたりでしょうか。 最低限の機能以上に色々拡張されているシェルを拡張POSIXシェルと呼ぶことにします。具体的な実装はbash、zsh、kshなどでしょうか。 ここでは触れませんがPOSIX準拠でないシェルも存在してcshやtcshなどのシェルがあります。あと確か最近話題のfishも違ったような。\nさて、1つ問題になるのは普段使いのコマンドラインはおおむね拡張POSIXシェルでしょうが、サーバで使うシェルやデプロイスクリプトで呼び出すシェルなどは拡張でないPOSIXシェルだったりすることです。なので普段のコマンドラインで使える機能とシェルスクリプトで使える機能を分けて覚えなければなりません。ということでここではPOSIX準拠かどうかを気にしながらやっていきます。\n面倒ならデプロイスクリプトを .sh じゃなくて .bash にしてshebangもbashにしてBashスクリプトにすることで罠を避ける方法もあります。そのときはちゃんとサーバにBashが入っているか確認しておきましょう。ついでにBashのバージョンも。4.x系からの機能もちょいちょいあるので3.x系だと動かないとかたまにあります。\n変数 シェルにも変数があります。代入するときは名前のまま、使うときは $ を前置して使います。[0-9a-zA-Z_]+ が変数名だった気がするのでそれ以外の文字で区切られます。\nversion=1.0 echo /path/to/lang/$version/bin/lang-$version # =\u0026gt; /path/to/lang/1.0/bin/lang-1.0 因みに代入の = の前後に空白を入れるとエラーです。\n展開する変数名がアレな場合や変数名へ区切が必要な場合は {変数名} とすることで任意の名前の変数を展開できます。\necho lang_$version_date # \u0026#34;version_date\u0026#34; という変数名と認識される # =\u0026gt; lang_ echo lang_${version}_date # これだとちゃんと`version`という変数名で認識される # =\u0026gt; lang_1.0_date さらに変数置換などの複雑な記法もありますが、複雑なシェルスクリプトを読むときくらいしか要らない知識なのでやめておきます。一言触れておくと、POSIX準拠のものと拡張シェルにのみ存在するものがあるので気をつけましょう。\n環境変数 シェル変数より環境変数をよく使うと思います。 シェルからみたらシェル変数も環境変数もあまり変わりませんが他のコマンドを起動したときに引き継がれるかが異なります。\n# シェル変数を環境変数に export hoge # 新たに環境変数を定義 export hoge=fuga あるいは1つのコマンド実行時にだけ環境変数を設定できればいいのであれば\nhoge=fuga command1 という構文で設定しつつ実行できます。 ややこしいのですが、同様のことをする外部コマンドenvもあって、\nenv hoge=fuga command1 としても実行できます。まあ、前者がよく使われますかね。\nStringly Typed POSIXシェルには文字列しかありません。 たまに数値計算をするコマンドがありますがあれは数字だけが並んだ文字列を内部で数値に変換して計算、文字列にして返しているだけです。\n拡張POSIXシェルでは配列変数や連想配列変数があるようですが私は使わないので知りません。\n文字列 特にクォートしなければ空白文字区切で文字列と認識されます(重要)。\nクォートしたければ記法は2種類あって、それぞれ意味が異なります。\n\u0026quot;文字列\u0026quot; は内部でエスケープ記号や変数の展開が行なわれます。\nhoge=world echo \u0026#34;hello\\n$hoge\u0026#34; # -\u0026gt; hello # -\u0026gt; world '文字列' は一切のエスケープ処理や変数展開を行いません\nhoge=world echo \u0026#39;hello\\n$hoge\u0026#39; # -\u0026gt; hello\\n$hoge ※この結果はbashでのものです。後述のechoコマンドの移植性の問題でzshなどを使っているとこの結果になりません\n'文字列' 内では ' のエスケープが行われないので ' を入れられません。どうしても入れたい場合は一旦文字列を終了させてからシェルのエスケープを使って'を打ち、また'を始めることになるでしょう。\n$ echo \u0026#39;this contains a single quote(\u0026#39;\\\u0026#39;\u0026#39;) mark\u0026#39; this contains a single quote(\u0026#39;) mark クォート単位が複数になっていてもスペースさえ空いていなければ1つの文字列として認識されちゃうんですね。\nおおまかな指針として、特に何もなければ '文字列' を、変数展開したい場合は \u0026quot;文字列\u0026quot; を使うとよいでしょう。 拡張シェルを使っていると$以外の記号(例えばzshで!など)も展開対象になるので気をつけましょう。\n2017-10-30 追記 hoge=world\necho \u0026quot;hello\\n$hoge\u0026quot;\n# -\u0026gt; hello\n# -\u0026gt; world\nこれ↑ですが、\\n を解釈するのはある種の echo が行なっていることです。\nprintf \u0026#39;%s\u0026#39; \u0026quot;hello\\n$hoge\u0026quot; |od -tcx1\nなどとして確認を。\n\u0026mdash; ふみやす＠シェルまおう(自称でない)🚲 (@satoh_fumiyasu) 2017年10月30日\n/追記\nヒアドキュメント ヒアドキュメントがあります。Rubyとかにあるやつですね。これは文字列ではなく標準入力として扱われます。\nクォートの有無で変数展開の有無が変わるので気をつけましょう。\nクォートなし\nhoge=fuga cat \u0026lt;\u0026lt;EOF This is $hoge EOF # -\u0026gt; This is fuga クォートあり\nhoge=fuga cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; This is $hoge EOF # -\u0026gt; This is $hoge パイプをつなげるときはこう書きます。\ncat \u0026lt;\u0026lt;EOF | tr a-z A-Z hello EOF # -\u0026gt; HELLO コマンド置換 コマンドは基本的には標準出入力でやり取りしますが、たまに結果を変数に格納したい、引数に渡したいなどの需要が発生します。 そういうときにはコマンド置換で出力を文字列にしてあげます。記法が2つありますが、ネストの扱い以外振る舞いはおなじです。\nバッククォート記法\necho `echo ok` # -\u0026gt; ok # ネストはバックスラッシュでエスケープ echo `echo \\`echo ok\\`` # -\u0026gt; ok $()記法\necho $(echo ok) # -\u0026gt; ok # ネストは自然に echo $(echo $(echo ok)) 確か$()記法はPOSIX標準ではないけど事実上ほとんどのシェルで使えるとかだったきがします。\n組み込みコマンド echoやcdなどいくつかのコマンドはシェルの組み込みコマンドとして実装されています。 これらは外部コマンドとして実行出来ないので例えばxargsやsudoに渡しても実行できなかったりします。 しかしここでややこしいことに組み込みコマンドであるはずのものでも利便性のために外部コマンドとしても用意されていることもあります。\n$ which echo echo: shell built-in command $ ls /bin/echo /bin/echo  まあなので「echoは基本的にはxargsやsudoに渡せないけど渡せる可能性もある」くらいにおぼえておいて下さい。\nあとは互換性問題。組み込みコマンドということは実装ごとに挙動が違う訳です。 例えばこの記事にあるようにechoに非互換があります。 echoコマンドが \\n などのエスケープシーケンスを解釈するかで違いがあります。 なので上の方の例は''リテラルにはエスケープは解釈されなくてもzshのechoには解釈されて改行されてしまいます。\nその他timeは出力フォーマットがバラバラです。というかtimeはPOSIXに定義されてない組み込みコマンドですね。 あとやっぱり外部コマンドも存在します。timeの結果をパースするときは注意しましょう。\n$ bash -c \u0026#39;time expr 1 + 1\u0026#39; 2 real 0m0.001s user 0m0.001s sys 0m0.000s $ zsh -c \u0026#39;time expr 1 + 1\u0026#39; 2 expr 1 + 1 0.00s user 0.00s system 89% cpu 0.001 total $ /usr/bin/time expr 1 + 1 2 0.00user 0.00system 0:00.00elapsed 100%CPU (0avgtext+0avgdata 2096maxresident)k 0inputs+0outputs (0major+79minor)pagefaults 0swaps  2017-10-30 追記 time(1)コマンドについても、POSIXで定義されています: https://t.co/tf1IHCfgOz\n記述にある通り、デフォルトの出力形式がバラバラですが、イマドキのOSなら「-p」オプションつければ最低限の互換性は確保できるかと\n\u0026mdash; SODA Noriyuki (@n_soda) 2017年10月30日\nとのことですが、普通にUbuntu(の少なくとも14.10)に入っていないので実用上気をつけましょう。 /追記\nシェルとコマンドの区別 昔のエントリでも触れましたがシェルレベルとコマンドレベルを区別しましょう。\nroot権限でファイルに書くつもりで\ncommand1 | sudo command2 \u0026gt; file と書いたとき\no | o \u0026gt; file | | | +- sudo command2 | +- command と解釈されてsudoの範囲が \u0026gt; file にまで及びません。\ncommand1 | command2 | sudo tee file ならば\no | o | o | | | | | +- sudo tee file | +- command2 +- command1 と解釈されるので意図通りです。\nさて、基本を終えたのでコマンドラインで便利なもの、シェルスクリプトで便利なものに分けて紹介していきましょう。\nコマンドライン編 リダイレクト ちょっと細かく説明します。\nプログラムを箱に例えると、箱には外部とやり取りするための穴が必要です。 さもなくば我々にできることはプログラムを実行してCPUが熱くなるのを眺めるくらいしかありません。 ということでプログラムには穴が空いています。最大1024個くらい。これをfd(ファイルディスクリプタ)といいます。 ファイルを開いたりソケットに繋いだりするのに使われます。 0, 1, 2番のfdは標準で開いていて、それぞれ標準入力、標準出力、標準エラー出力です。\nシェルはデフォルトでターミナルからの入力を0に、1と2をターミナルへの出力につないでいます。 このfdと出入力先の繋ぎ変えをするのがリダイレクトです。\n例えば下記はrubyでfd 9に書いてシェルで9を1に繋ぎ変えてターミナルに表示する例です。\n$ ruby -e \u0026#39;IO.open(9) {|out| out.puts \u0026#34;Hello, fd 9\u0026#34;}\u0026#39; 9\u0026gt;\u0026amp;1 Hello, fd 9  あるいはよくあるのはこういうやつですね。標準出力、標準エラー出力を /dev/null/ に捨てる例です。\n$ some_command \u0026gt; /dev/null 2\u0026gt;\u0026amp;1  どこにどの数値や記号を書くのか混乱しがちですが下記のよな構文になってます。\n [n]\u0026gt; file で fd n を file にリダイレクト、 n が省略されたら標準出力です。 [n]\u0026gt;\u0026amp; m で fd n を fd m とおなじものに。 n が省略されたら標準出力です。  そして罠なのがいかにも宣言的っぽい見た目をしていながら書いた順に処理されます。上の例は\n 標準入力を /dev/null に 2 (標準エラー出力)を 1 と同じもの、つまり /dev/null に  という処理をします。イメージは手続き型言語でfd_1=/dev/null; fd_2=fd_1としている感じですね。\nちなみにパイプは標準出力のみを次のコマンドに繋ぎ変えます。\nリダイレクトの愉快な仲間はここに色々乗っていますが上の２つと\u0026gt;\u0026gt;くらいしか使わないでしょう。 雑学として基礎知識のところで出てきたヒアドキュメントもリダイレクトの一種だったりします。\nさて、これがPOSIX全般のの話で、拡張POSIXシェルにはもうちょい機能があります。 zshとかは複数リダイレクトなど色々拡張してるのですがひとまず覚えるのはこれ。\n$ some_command \u0026gt;\u0026amp; /dev/null  \u0026gt;\u0026amp; あるいは \u0026amp;\u0026gt; は大抵の拡張POSIXシェルで使えるリダイレクトで、標準出力と標準エラー出力を同時にリダイレクトします。 上述のように /dev/null にリダイレクトすることが多いでしょうか。前者の記法はfdのリダイレクトと被ってますが数値かそれ以外で分けてるらしいです。\n因みにリダイレクトでなくてパイプに繋ぎたいなら |\u0026amp; があります。\nfor シェルで繰り返しをしたいなら一応 for があります。\nカレントディレクトリの.jpgの拡張子を.jpegに書き換えたければ\n$ for f in $(ls *.jpg); do mv \u0026#34;$f\u0026#34; \u0026#34;$(basename $f .jpg).jpeg\u0026#34; ; done  です(実行してないので怪しいですが)。 セミコロンの位置が覚えづらいかもしれませんが\nfor 変数 in スペース区切りの列 do 本体 done を1行で書くために改行をセミコロンにしているだけです。普通に改行して書いても構いません。\n繰り返し対象に*を指定すると死ぬとか繰り返しが多いとプロセスフォークのオーバーヘッドで死ぬとかは自分でぐぐっておいてください。\nwhile read 割と評判が悪いのですが他にも繰り返しの手段はあります。 シェル組み込みのwhileとreadを組み合わせた方法です。 さきほどのものと同じコードを書くと、\n$ ls *.jpg | while read f; do mv \u0026#34;$f\u0026#34; \u0026#34;$(basename $f .jpg).jpeg\u0026#34; done  となります。forと似たようなものですがforが$(ls *.jpg)と一旦繰り返し対象の文字列を作ってるのに対しこちらはパイプなので効率的です。 また、readは分配束縛ができるなどのメリットもあります。\nデメリットはreadに罠が多い(らしい)点です。\nxargs おそらく繰り返しで一番有名なのが xargs でしょう。コマンドを並列実行してくれたり頼れるコマンドです。 しかしxargsだと先程のコードは正しく書き換えられません。\nls *.jpg | xargs -I@ mv @ \u0026#34;$(basename @ .jpg).jpeg\u0026#34;  と書いても意図通りにならないのです。これもシェルレベルとコマンドレベルの話です。\n o | o | | | +- xargs -I@ mv @ \u0026#34;$(o).jpeg\u0026#34; | | | +- basename @ .jpg +- ls *.jpg このような構造になっているので basename の方の@が basename を評価したあとにプレースホルダ展開されるのです。\nこのように置換のプレースホルダが変数でないために不便が生じることもあります。 大抵はxargsが適当でしょうがこのようなケースや複数のコマンドを叩きたいケースでは上記のforやwhile readを使うことになるでしょう。\nブレース展開 $ echo 1{0..9} 10 11 12 13 14 15 16 17 18 19  とかですね。これは拡張POSIXシェルの機能なので気をつけましょう。 あとこれはすべてメモリに展開されるのにも気をつけましょう。\necho {000000000..9999999999}ってどうなるんだっけ？\n桁は適当 #情報漏洩\n\u0026mdash; Ryuichi Ueda (@ryuichiueda) 2015年10月27日 プロセス置換 拡張POSIXシェルでは実行したコマンドをファイルのように扱えます。\n人によって直感的かが結構違うようですが、\u0026gt;() で書き込み可能な、\u0026lt;()で読み出し可能なファイルを作ります。\n$ echo pohe \u0026gt; \u0026gt;(cat) pohe  大抵のコマンドが標準入力からもコマンドに渡された引数からも入力を受け付けるのでありがたみが分かりづらいかもしれませんが複数の入力を渡すときに便利です。\ndiff \u0026lt;(command1) \u0026lt;(command2)  シェルスクリプトならファイルに書き出せばいいのでこれはコマンドラインで複雑なことをしようとするときに使われるようです。\n因みに実体は /proc にあるfdです。\n$ echo \u0026gt;(cat) /proc/self/fd/12  バックグラウンド実行とnohup, disown, supend 詳しくは技術/UNIX/なぜnohupをバックグランドジョブとして起動するのが定番なのか？(擬似端末, Pseudo Terminal, SIGHUP他) - Glamenv-Septzen.netとかHUPシグナルとnohupとdisownとバック/フォアグラウンドジョブの理解 - Qiitaとかを読んで下さい。\nシェルから実行されるコマンドにはひとまず3つのステータスがあって、フォアグラウンド、サスペンド、バックグラウンドがある。んでそれらを操作する組み込みコマンドもある。状態を確認する組み込みコマンドもある。 それらがややこしいしみなさん雰囲気で使ってますよねーって話です。私も説明できるほど詳しくないのでみなさん手元で実験しながら覚えて下さい。状態の確認コマンドはjobsで、状態変化コマンドは下図の通りです。\nF: フォアグラウンド S: サスペンド B: バックグラウンド `cmd` `cmd \u0026amp;` `setsid cmd` | | | +---+ `fg` +---+ `disown` | | |\u0026lt;------| |--------+ | +-| F | | B | | | | | | | | v v | +---+ +---+ vvvv | ^ | ^ \u0026gt;解脱\u0026lt; | | | Ctrl+z | `bg` ^^^^ | | | | ^ | | | +---+ | | | | +-\u0026gt;| |--+ | | +----| S |---------------+ | `fg`| | `disown` | +---+ | Ctrl+c vv +--------\u0026gt;\u0026gt;死\u0026lt; ^^  ここには載ってませんがkill %jobidで殺すことも可能です。 disownは拡張POSIXシェルの機能のようです。 setsid はPOSIXコマンドでないどころか多分Linux固有です。 setsidの解脱とdisownの解脱は多分違う機能です。disownの処理のソース読んでないですが。 nohupは解脱せずに不死属性つける感じです。多分。  まあつまり何を言いたいかというとκeenも雰囲気で使ってます。\n2017-10-30 追記 setsidコマンドにがPOSIX外なのはその通りですが、Linux固有というわけでもなくて、たぶんSVR4発祥だったと思います。\n\u0026mdash; SODA Noriyuki (@n_soda) 2017年10月30日 /追記\nあとzshやbash 4.0以降にコプロセスというのがありますが詳しくないです。\nシェルスクリプト編 シェルスクリプトは雰囲気で書いてる人が多いでしょう。 普通にやるとただのシェル入門になるので危なげなところだけひろっていきます。\nifとtestと論理演算 if test_command then then_command else else_command fi else節はオプショナルです。\ntest_command のexit statusが0ならthen節が、それ以外ならelse節が実行されます。例えば以下のように使います。\nif grep pohe /etc/password \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;Hello, pohe\u0026#34; else echo \u0026#34;pohe is absent\u0026#34; fi 上の例ではgrepを使いましたが、test_commandに使われる代表的なコマンドがtest、別名[コマンドです。[として呼んだときは最後の引数が]でないといけません。 いいですか、最後の引数がです。[ 1 = 1] は最後の引数が1]なので不正です。\nさて、2通り書き方があるとどちらが推奨かという話になりますが、[]が多いようです。 確か随分古いシステムで[]が使えないとかでtestの方を使うスクリプトもありますが多くはないです。\n肝心の書き方ですが、\n [ A = B ] [ A != B ] 文字列比較 [ N -eq M ] [ N -ne M ] 数値比較(数値も実際は文字列なので上記コマンドでも比較可能な点に注意) [ N -lt M ] [ N -gt M ] \u0026lt; と \u0026gt; [ N -le M ] [ N -ge M ] \u0026lt;= と \u0026gt;= [ -z A ] [ -n A ] Aが空文字列か非空文字列か [ -e P ] [ -s P ] [ -d P] Pにファイルが存在するか、存在して中身があるか、Pがディレクトリか  などなどかなり沢山定義されています。 ここでちょっとややこしいのがtestコマンドはシェルスクリプトで多用されるため外部コマンドにしておくと遅いので多くの場合シェル組み込みになっています。 まれに互換問題が発生するので怖い人はちゃんとPOSIXの定義をみておきましょう。\nこのtestコマンド、ある操作が足りないのに気づいたでしょうか。論理演算です。それはシェル組み込みの\u0026amp;\u0026amp;、||、!を使います。 ちゃんとショートサーキットもやってくれます。\n# 前述のとおりzshなどでは`!`の扱いに注意 echo 1 \u0026amp;\u0026amp; echo 2 | cat # =\u0026gt; 1 # =\u0026gt; 2 echo 1 || echo 2 | cat # =\u0026gt; 1 ! echo 1 \u0026amp;\u0026amp; ! echo 2 | cat # =\u0026gt; 1 ! echo 1 || ! echo 2 | cat # =\u0026gt; 1 # =\u0026gt; 2 これで一通りの条件式が書けますね。\nn=1 if [ \u0026#34;$n\u0026#34; -lt 0 ]; then echo \u0026#34;n is negative\u0026#34; elif [ 0 -le \u0026#34;$n\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$n\u0026#34; -lt 10 ]; then echo \u0026#34;n is small\u0026#34; else echo \u0026#34;n is big\u0026#34; fi そしてまた拡張POSIX Shellの話です。奴らは独自に [[]] というコマンドも持っていて、書ける内容は大体[]のスーパーセットになってるようです。 論理和や論理積が書けるなどちゃんと考えて設計した?という気になるものから[[ str =~ regex ]] など便利なものもあるようですが例によって私は使わないので知りません。 1つ苦言を呈しておくとこの[[]]は無自覚に行われるbashismの代表格(κeen脳内調べ)であり、「よくわかんないけど強いらしいからこれ使う」でもいいとは思いますが流石にどのシェルで動かすつもりなのか意識して書きましょうね。 Shell Shockのときに分かったようにいざというときに困ります。\nサブシェルとコマンドグループ 複数のコマンドを1つに纏めたいとき、2種類の方法があります。\n1つはサブシェル起動の()、もう一つはコマンドグループの{}です。\nサブシェルは新たにシェルを立ち上げるので環境を汚し放題です。典型的にはcdを使うでしょうか。あとは変数も親のシェルに影響しません。\n( cd build ./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install ) # ここではbuildディレクトリから抜けている 上級な使い方にサブシェルを使うことでfdをまとめて色々したりと使いみちは様々です。 CF 標準入力同士の diff - Qiita\nコマンドグループはただコマンドをまとめるだけです。サブシェルのコストがないのとcdや変数への変更が残るなどの違いがあります。複数の出力をつなげたいときとか次のパイプに行く前にごにょごにょしたいときに使うでしょうか。\n{ echo header; cat nullpo.csv; } | ... まあ、別にこれを()でやってもいいんですけどね。\n難しい話をするとね、AT\u0026amp;T ksh や zsh では (command) はサブシェルではあるが fork(2) はしない実装もあるんだ。(条件に依るが詳しくは知らね) https://t.co/R4yhLLpMzC\n\u0026mdash; ふみやす＠シェルまおう(自称でない)🚲 (@satoh_fumiyasu) 2017年10月26日 どうでもいい話をすると ( ) は文字として特別な意味があるので ( echo 1 )のように ; が必要ないけど { } の方は { echo 1; } のように ; が必須だったりする（そのぶん { } はクォートせずに書ける\n\u0026mdash; でこれき (@dico_leque) 2017年10月26日 関数 関数名() コマンド で定義します。大抵はコマンドグループを使って\n関数名() { コマンド } の形で使うでしょうか。拡張POSIXシェルでfunction 関数名() コマンドの構文も使えたりしますが私は使わないので違いは知りません。ローカル変数の扱いが違ったりするんですかね。\n有名な関数はこれでしょうか。\n$ :(){: | : \u0026amp;};: #危険シェル芸\n\u0026mdash; Ryuichi Ueda (@ryuichiueda) 2014年8月20日 \n試さないでくださいね。PCがフリーズします。余談ですが:というコマンドは存在していて、何もしないのでpyhtonにおけるpassみたいな使われ方をします。\n閑話休題。POSIXシェルでのローカル変数ですが、そんなものはありません。頑張って下さい。関数の入れ子呼び出しで変数を上書きされて死んだことあります。頑張って下さい。 拡張POSIXシェルには流石にありますが、シェル毎に構文が違うらしいです。頑張って下さい。ステートレスプログラミングを推奨する感じですね。\nあと基本的な考え方の話をすると、関数の返り値 = 標準出力への書き出しです。あとは一応exit statusも。return nです。exit nにするとシェル(スクリプト)ごと終了します。 入力は標準入力と引数。引数はスクリプトと同じく$nで参照できます。唯一ローカルに使える変数なので賢く使いましょう。\nあとはシェル組み込みコマンドと同じくxargsやsudoには渡せないので注意。 bashならShell Shockで一躍有名になった関数export構文でどうにかできそうな気がしますが、やめときましょう。\nexprと$(()) シェル組み込み構文の$(()) で計算できます。exprコマンドでもできます。\necho $((1+1)) # =\u0026gt; 2 expr 1 + 1 $(())の方はシェル組み込みなのでこれまた実装ごとの拡張があります。 例えば$(())の方はシェル拡張で0xの表記が使えるなど。 互換性を意識してexprを使うべきか速度をとって$(())を使うべきかわからないので雰囲気で使っていきましょう。\n最後に 普段雰囲気で使ってるシェルが身近になったでしょうか。それととも余計怖くなったでしょうか。 ご覧の通りシェルを深堀すると互換性問題、複数の実装の知識、OSへの理解、ステートレスプログラミングの経験など様々なものが求められます。 普段使いするもの、ちょっとずつでいいので理解してあげてください。\n本をお求めならこれがおすすめですO\u0026rsquo;Reilly Japan - 詳解 シェルスクリプト。 ここには書いてないシェルの評価規則とかが載ってます。\nメタ この記事を書き始めたタイミングでOSアップデートしたらuim-skk+dvorak配列が使えなくなってしまいました。 この機にとdvorakもSKKも捨て、qwerty配列にibusの かな入力 を使い始めました。 そしたらまあ全然書けなくて執筆開始が10-17なのに公開が10-30になってしまいました。 まだかな入力には馴れきってないです。\n","categories":["Shell","Shell Script","CLI"],"category_urls":["/categories/shell","/categories/shell-script","/categories/cli"],"date":"2017-10-17","title":"雰囲気でシェルを使っている人のためのシェル入門","url":"https://KeenS.github.io/blog/2017/10/17/fun_ikideshieruwotsukatteiruninnotamenoshierunyuumon/"},
  {"body":"κeenです。そろそろそういう時期になってきたので。 結論からいうと心配無用です。\n私は毎年寒くなると心臓の調子が悪くなります。参考。 丁度ここのところ寒くなってきたので今年第一波が来ました。\n調子が悪くなったのは4年前、大学3年生の頃です。 その頃、精神的に荒んでましたし、昼夜逆転生活をしていたのが祟ったのでしょう。 子供の頃から循環器が弱かったり突然胸痛がすることもあったのでそこまで不思議ではありませんでした。 症状としては不整脈が頻繁に出たり、あるいは出なくても胸のあたりに違和感があったり（よく「心臓が重い」と表現してます）していました。 お酒を飲む、あるいは運動するなど心拍が上がりそうなことをすると酷くなる、睡眠不足や寒気で発症するなどの経験則が得られました。 あとはお茶を啜ろうとすると不整脈が出易いので火傷しそうになるなど。 余談ですが当時合気道サークルの副将をしていて運動がかなり負荷になってそうな気はしつつも辞める訳にもいかないので無理したりもしてました。 当時は酷い生活をしている自覚があったので生活を戻せば元に戻るだろうくらいの気持でいました。\n大学4年生の冬、大分生活が改善されているにも関らずまた不調になりました。 調子が悪いからといって運動をしないとそれはそれで弱っていくだけですし合気道は続けていました。 3年生の頃に比べると不整脈も少なく、「比較的」マシではありましたが流石に異常だなと思って病院へいきました。 最初の病院では特に異常はないと診断され、流石にそれはないだろうといって大きな病院を紹介してもらってホルター検査をすることにしてもらいました。 ホルター検査というのは1日中胸に電極を貼って心拍を取るやつです。参考。\nホルター検査の結果、「不整脈は認められるが、1日10万回鼓動する心臓にとっては誤差程度」とのことで特に何もない、つまり自覚症状があったとしても治療不能と言われました。 一応きついなら抑える薬自体はあるらしいのですが、元の血圧が低いため飲めないとのことで本当に何もなく終わりました。\nひとまず「心配無用」の医者のお墨付きを頂きました。 どうしようもないのでダメそうな日は動かないなどの自己管理をしてすごすことになりました。 大学生なのである程度は自由は効きました。\n次の年社会人になりました。 学生と違って毎朝出勤しないといけないのでつらいときにどうしようと心配しましたが、比較的寛容な職場なので本当にダメなときは休ませてもらったりなどしてどうにか社会に適応できました。 因みにオフィスに無料のコーヒーがあったのでよく飲んでいたら悪化したのでコーヒーはあまりよくないらしい、という経験則も得られました。 社会人になって合気道もあまりしなくなり、心臓の調子はかなり落ち着きました。 しかしたまに稽古にいくとかなり調子が悪くなったりと健全ではない様子が伺われました。\nその次の年の4月、まだ肌寒く調子の悪いシーズン、1年生（まだ動きも覚えておらず、太極拳くらいの動きをする）と組んでいるときにかなり動悸がして稽古を途中で抜けたのを切っ掛けに稽古に行かなくなりました。 それ以後運動は控えるようにしています。 しかしその年の冬は心臓は重くなりはしましたが不整脈は一度も出なかったので結構改善したようでした。転職などして冬の間しばらく家に籠っていたのが効いたのでしょう。\nそして今年、社会人3年目。フルフレックスな職場になり調子悪くても自分で時間を調節できる環境です。今年こそ完治かと思っていましたが発症してしまって残念です。 それでも体には負担がかからない環境になっているのでここ数年で冬も平気になったらなと願うところです。\nこの件から得られる教訓は、Twitterなどでもよく叫ばれていますが\n 学生の頃に無理した生活をしてると後々まで引き摺る 一度体を壊すと弱るのではなく最大体力が減る 失って初めて気付く健康の大切さ  改善傾向にあるとはいえまた今年もそういう時期なので皆様には心配かけますが「あの人花粉症つらそうだな」くらいの気持で眺めて頂けたら幸いです。\n","categories":["番外編","散文"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8","/categories/%e6%95%a3%e6%96%87"],"date":"2017-10-09","title":"心臓のこと","url":"https://KeenS.github.io/blog/2017/10/09/shinzounokoto/"},
  {"body":"κeenです。Rustで何も考えずに標準出力に吐いてると遅いよねーって話です。\n今回、標準出力に「yes」と1000万回出力するアプリケーションを書いてみたいと思います。\nprintln! まあ、最初に思いつくのはこれでしょうか。\nfn main(){for_in0..10_000_000{println!(\u0026#34;yes\u0026#34;);}}$ rustc -O yes.rs $ time ./yes \u0026gt; /dev/null ./yes \u0026gt; /dev/null 1.19s user 0.49s system 99% cpu 1.681 total  はい、1.681秒。結構時間掛かります。\nロックレス 上記のprintln!が遅いのは毎度ロックを取ってるからなので、直接stdoutを取得して一度だけロックを取るようにすると速度は改善します。\nusestd::io::{stdout,Write};fn main(){letout=stdout();letmutout=out.lock();for_in0..10_000_000{writeln!(out,\u0026#34;yes\u0026#34;).unwrap();}}$ rustc -O yes.rs $ time ./yes \u0026gt; /dev/null ./yes \u0026gt; /dev/null 0.62s user 0.49s system 99% cpu 1.111 total  1.111秒。多少は速くなりましたがあんまり変わんないですね。\n改行？ ところで上記のプログラム、writeln!の代わりにwrite!を使うと（改行を挟まないと）急激に速くなります。\nusestd::io::{stdout,Write};fn main(){letout=stdout();letmutout=out.lock();for_in0..10_000_000{write!(out,\u0026#34;yes\u0026#34;).unwrap();}}$ rustc -O yes.rs $ time ./yes \u0026gt; /dev/null ./yes \u0026gt; /dev/null 0.25s user 0.00s system 98% cpu 0.255 total  0.255秒、4.4倍くらいになりました。 何故だか分かりますか？\nwriteln!の方は改行でフラッシュされるからです。write!だと（改行がないと）されない。あれ？フラッシュ？\nバッファリング はい、ということで忘れがちですが標準出力もデフォルトではバッファリングされないのでバッファリングしてあげましょう。バッファリングしなくてIOが遅い、Rustあるあるですね。\nusestd::io::{stdout,Write,BufWriter};fn main(){letout=stdout();letmutout=BufWriter::new(out.lock());for_in0..10_000_000{writeln!(out,\u0026#34;yes\u0026#34;).unwrap();}}$ rustc -O yes.rs $ time ./yes \u0026gt; /dev/null ./yes \u0026gt; /dev/null 0.15s user 0.00s system 97% cpu 0.152 total  はい、最初から比べると10倍以上速くなりました。めでたしめでたし。\nさらなる高み 一般的にはここまでで十分ですが、興味としてさらに高速化してみましょう。\n1行yesを書く度に毎度write!を呼んでいては遅いです。ある程度まとめてwrite!を呼びましょう。\n今回2048 yes毎にwrite_allを呼ぶようにしてみます。\nusestd::io::{stdout,Write,BufWriter};fn main(){letout=stdout();letmutout=BufWriter::new(out.lock());letyes={letmuts=String::with_capacity(4096);for_in0..2048{s+=\u0026#34;yes\\n\u0026#34;;}s};letrest={letmuts=String::with_capacity(4096);for_in0..(10_000_000%2048){s+=\u0026#34;yes\\n\u0026#34;;}s};for_in0..(10_000_000/2048){out.write_all(yes.as_bytes()).unwrap();}out.write_all(rest.as_bytes()).unwrap();}$ rustc -O yes.rs $ time ./yes \u0026gt; /dev/null ./yes \u0026gt; /dev/null 0.00s user 0.00s system 0% cpu 0.003 total  比べようもないくらい速くなりました。\n参考  Drop the default buffer size to 8K by sfackler · Pull Request #32695 · rust-lang/rust How is GNU yes so fast? : unix  因みにですが手元の環境だとGNU yesより速いです。※Rust版の方は出力数を10億回に増やしたものを使用\n$ ./yes | pv \u0026gt; /dev/null 3.73GiB 0:00:00 [7.73GiB/s] $ yes | pv \u0026gt; /dev/null ^C.6GiB 0:00:06 [7.29GiB/s] $ yes --version yes (GNU coreutils) 8.26 Copyright (C) 2016 Free Software Foundation, Inc. ライセンス GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt;. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 作者 David MacKenzie。  2017-10-08 追記 バッファリングするやつの\nwriteln!(out, \u0026quot;yes\u0026quot;).unwrap();\nを\nout.write(b\u0026quot;yes\\n\u0026quot;).unwrap();\nにするだけで最期の 2048 ごとのに匹敵するほどはやくなりました。\n文字列からバイトへの変換にコピーが発生していそう。\n\u0026mdash; いじゅういん (@kei10in) 2017年10月5日 ありがとうございます。言われてみれば確かwritelnは一旦改行文字を結合してから（新たにアロケートしてから）出力していた気がします。後程追記しますね。\n\u0026mdash; κeen (@blackenedgold) 2017年10月5日 \nということで実験してみましょう。\nまずは指摘されたコード。\nusestd::io::{stdout,Write,BufWriter};fn main(){letout=stdout();letmutout=BufWriter::new(out.lock());for_in0..10_000_000{out.write(b\u0026#34;yes\\n\u0026#34;).unwrap();}}$ rustc -O yes.rs $ time ./yes \u0026gt; /dev/null ./yes \u0026gt; /dev/null 0.02s user 0.00s system 89% cpu 0.027 total  かなり速くなってます。ふむむむ。\nもう1つ、私が言及したwriteln!よりもwrite!の方が速いというやつ。\nusestd::io::{stdout,Write,BufWriter};fn main(){letout=stdout();letmutout=BufWriter::new(out.lock());for_in0..10_000_000{out.write(b\u0026#34;yes\\n\u0026#34;).unwrap();}}$ rustc -O yes.rs $ time ./yes \u0026gt; /dev/null ./yes \u0026gt; /dev/null 0.15s user 0.00s system 98% cpu 0.155 total  あれ！？write!を使うと遅い…。write!は単にwrite_fmtに置き換えられるだけなので大したコストじゃないと思ってたんですがwrite_fmtって以外とコストかかるんですね。\nところでwriteln!はマクロのconcat!を呼んでいるので実行時にはアロケーションコストが掛からなそうです（汗。調べもせずに適当なことを言うのはやめましょう（戒め）\n/追記\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2017-10-05","title":"Rustで高速な標準出力","url":"https://KeenS.github.io/blog/2017/10/05/rustdekousokunahyoujunshutsuryoku/"},
  {"body":"# 1ML - コア言語とモジュール言語の統合 ---------------------- [型システム論文読書会 Vol.1 - connpass](https://connpass.com/event/63454/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます * 型システム初心者です * 論文初心者です === # MLのモジュールについておさらい === # モジュール、シグネチャ ---- * ストラクチャは型、関数、値をまとめたもの + なんかレコードっぽい * シグネチャはその型 * モジュールはシグネチャを充足すればよい（余計なフィールドがあってもよい） + もちろん余計なフィールドは隠蔽される === ``` sml signature S = sig type t val f: t - t val zero: t end structure M: S = struct type t = int fun f x = x val zero = 0 fun g x = x end ``` === # ファンクタ ----------- * ストラクチャを引数にとってストラクチャを返す + なんか関数っぽい * 受け取ったモジュールに依存して型が変わったりする === ``` sml functor F(X: sig type 'a t end): sig type 'a t val id: 'a t - 'a t end = struct open X fun id x = x end ``` === # `include` ----------- * なんかシグネチャをincludeできちゃう * ストラクトもopenできちゃう === ``` sml signature T = sig include S val g: t - t end structure N : T = struct open M fun g x = x end ``` === # オペーク ---------- * シグネチャの型をトランスパレントにするかオペークにするか選べる * `M: S` vs `M : S` * オペークなストラクチャの型は存在型になる * `:` をsealing operatorというらしい * transparent(透明)とopaque(不透明)があるのでtranslucent(半透明)と呼ぶひともいるとかいないとか === ``` sml structure M: S = struct ... end val _ = M.f 1 (* Ok *) ``` ``` sml structure M: S = struct ... end val _ = M.f 1 (* Error *) ``` === # `sharing` --------- * 2つの型が同じである制約を書ける + refinement?? * オペークな型に使うと便利 * 型が別のストラクチャのフィールドに依存するようになる === ``` sml signature X = sig structure M: sig type t end type t sharing type t = M.t end ``` === # Generative vs Applicative -------------------------- * 同じストラクチャを同じファンクタを通したものは同じもの？違うもの？ * Generative → 違うもの * Applicative → 同じもの * SMLはGenerative * OCamlはApplicative（らしい） === ``` sml (* 再掲 *) signature S = sig type t val f: t - t val zero: t end functor Id(X: S): S = struct open X end structure M1 = Id(M) structure M2 = Id(M) val _ = M1.f M2.zero (* Error *) ``` === # [1ML – Core and Modules United (F-ing First-Class Modules)](https://people.mpi-sws.org/~rossberg/1ml/1ml.pdf) === # 落合先生のフォーマット --------- * どんなもの？ + → MLのコア言語とモジュール言語を1つの言語に統一 * 先行研究と比べてどこがすごい？ + → 第一級モジュールでありながら型が決定可能かつ型推論もある * 技術や手法のキモはどこ？ + → System Fωに変換した、型にsmallとlargeの区別を入れた * どうやって有効だと検証した？ + 証明、実装 * 議論はある？ + 完全には型推論されないなど * 次に読むべき論文は？ + [F-ing Modules](https://people.mpi-sws.org/~dreyer/courses/modules/f-ing.pdf) + [1ML with Special Effects | SpringerLink](https://link.springer.com/chapter/10.1007/978-3-319-30936-1_18) WadlerFest 2016. Extends 1ML with effect polymorphism and generativity polymorphism. === # 1MLの論文 * 論文 A. Rosburg. [1ML – core and modules united (F-ing first-class modules)](http://dl.acm.org/citation.cfm?id=2784738). In ICFP, 2015. + https://people.mpi-sws.org/~rossberg/1ml/ * 拡張（次に読む）[1ML with Special Effects | SpringerLink](https://link.springer.com/chapter/10.1007/978-3-319-30936-1_18) WadlerFest 2016. Extends 1ML with effect polymorphism and generativity polymorphism. * ベースになるやつ[F-ing Modules](https://people.mpi-sws.org/~dreyer/courses/modules/f-ing.pdf) + https://people.mpi-sws.org/~rossberg/f-ing/ === # Abstract ----------- * MLには2つの言語がある。コア言語とモジュール言語 + コア: 型、式 + モジュール: シグナチャ、ストラクチャ、ファンクタ * コア言語の上の層にモジュール言語がある感じ * それぞれを分離せずに扱えたら便利 ``` module Table = if size  threshold then HashMap else TreeMap ``` === # Abstract (Cont.) ----------- * 1MLでそれを実現した + 関数とファンクタと型コンストラクタが同じ表現 + レコードとタプルとstructも同じ表現 + てかほとんどをモジュールにエンコードする * System Fωにエンコードできる程度の表現能力 + 依存型までは使わない + 元々あったF-ing modulesの拡張 * ある意味ではSystem Fωのシンタックスシュガーと捉えることもできる * ある程度の型推論もある === # 1. Intro - 既存研究からの流れ === # packaged modules ------------------ * ocamlで採用されてるやつ * first class moduleではない + module  値は手でやる ``` module Table = (val (if size  threshold then (module HashMap : MAP) else (module TreeMap : MAP)) : MAP) ``` * type sharingも弱い + `f : (module S with type t = ’a) → (module S with type t = ’a) → ’a` + 本来はこう書きたい`f : (X : S) → (S with type t = X.t) → X.t` + タイプコンストラクタに至ってはそもそも表現できない * → もうちょっとリッチなのが欲しい === # first class modules --------------------- * もしコアとモジュールの区別を完全になくしたら？ * なんかオペーク型にファンクタがきたりエグそう * 実際[型が決定不能](https://dl.acm.org/citation.cfm?id=176927) + ファンクタと反変関数とサブタイプとopaqueのせい + opaqueを任意の型でサブタイプできるとマズいらしい * 実用上も諸々問題ある + サブタイピングが入るとユニフィケーションが…とか + 型が束にならないので扱いづらいとか * → リッチすぎると崩壊する === # first class modules --------------------- ``` type T = {type A; f : A → ()} type U = {type A; f : (T where type A = A) → ()} type V = T where type A = U g (X : V) = X : U (* V ≤ U ? *) ``` === # F-ing modules ---------------- * これ自体はfirst class modulesではない + 論文内のapplicationでpackaged first class moduleに言及はしている * moduleをF(ω)にエンコードすることに成功 + 元々モジュールは[依存型ベースの議論がされていた](https://people.mpi-sws.org/~dreyer/courses/modules/macqueen86.pdf) + ファンクタがApplicativeだとωが必要らしい * →F(ω)にエンコードできるのならある程度first-classに扱えるのでは？ === # 1ML ----- * moduleをfirst classに扱いつつFωにエンコードすることに成功 + 但し一部にsmall typeしか使えない制約がある * 既存のモジュールは不整合を防ぐための「構文的」制約が強すぎる→「意味論的」制約に緩和 * コア言語の方はSystem F * [small typeとlarge type](https://dl.acm.org/citation.cfm?id=169696)に区別(カインドとは言わないんだね) * small typeの推論はほぼできる（レコード幅についてのみ注釈必要） + 実用上まあ、しゃあないよね + SMLもレコード注釈必要な場面あるしね * large typeは注釈必要 + モジュールも元々そうだしね === ## 1MLのContribution -------------------- * First-Class Moduleをもちつつ決定可能な型システムの構築 * それのSystem Fωへのエンコード * Damas/Milner-styleの型推論 * これらを使ったML方言の設計 === # 2. 1ML with Explicit Types === # 1ML with Explicit Types ------------------------- * (4ページ目のFigure 1参照) * bool型の他はレコード、関数、`type`型、transparent型、sharing制約など * 関数はpureとimpureに分かれる * `let`がレコードなどほとんどの構文は糖衣になってる + `(fun (n : int) ⇒ n + n) 3` + → `let f = fun (n : int) ⇒ n + n; x = 3 in f x` + → `{f = fun (n : int) ⇒ n + n; x = 3; body = f x} .body` === # どんなコードが書けるか --------------------- * Functional Core * Reified Types * Translucency * Functor * Applicative vs Generative * Higher Order Polymorphism * Computed Modules * Recursion * Impredicativity Reloaded === ## Reified Types ---------------- * 多相型やタイプコンストラクタなど * 匿名モジュールの省略記法とも捉えられる ``` id = fun (a : type) ⇒ fun (x : a) ⇒ x ``` ``` pair = fun (a : type) ⇒ fun (b : type) ⇒ type {fst : a; snd : b} second = fun (a : type) ⇒ fun (b : type) ⇒ fun (p : pair a b) ⇒ p.snd ``` === ## Translucency * opaque: 型が`type`で詳細が分からない * transparent: 型の詳細が`(= type ...)`で書いてある + `(= E)` はシングルトン型。 + `(= E)` は `E` のサブタイプだって。 ``` size : type pair : (a : type) ⇒ (b : type) ⇒ type ``` ``` size : (= type int) pair : (a : type) ⇒ (b : type) ⇒ (= type {fst : a; snd : b}) ``` === ## Functor ---------- * だいたいMLっぽいシンタックスで書ける * `empty a : map a;`が`empty : (a : type) ⇒ map a`などの構文糖がある * なんか引数の型に依存してるっぽいけど後で消える * sealing operatorがある * type refinement syntaxがある === ``` type EQ = { type t; eq : t → t → bool }; type MAP = { type key; type map a; empty a : map a; add a : key → a → map a → map a; lookup a : key → map a → opt a }; ``` === ``` Map (Key : EQ) : MAP where (type .key = Key.t) = { type key = Key.t; type map a = key → opt a; empty a = fun (k : key) ⇒ none a; lookup a (k : key) (m : map a) = m k; add a (k : key) (v : a) (m : map a) = fun (x : key) ⇒ if Key.eq x k then some a v else m x : opt a } ``` === ## Applicative vs Generative --------------------------- * 基本的にはSMLスタイルのGenerative Functor + 全てApplicativeだと面倒毎が起こるらしい + First-Class moduleとコンフリクトするとかなんとか * 型コンストラクタも内部ではFunctor + `pair a b`とかもFunctor + 型コンストラクタはApplicativeであってほしい * → 関数にPureとImpureの区別を付ける * pure(`=`) はapplicative * impure(`-`) はgenerative * ひとまずコア言語の方は全て`impure`で議論 === ## Higher Order Polymorphism ---------------------------- * コアにSystem F採用したからやりたい放題 ``` f (id : (a : type) ⇒ a → a) = {x = id int 5; y = id bool true} ``` ``` type SHAPE = {type t; area : t → float; v : t} volume (height : int) (x : SHAPE) = height * x.area (x.v) ``` === ## Higher Order Polymorphism ---------------------------- ``` type COLL c = { type key; type val; empty : c; add : c → key → val → c; lookup : c → key → opt val; keys : c → list key }; entries c (C : COLL c) (xs : c) : list (C.key × C.val) = ... ``` === ``` type MONAD (m : type ⇒ type) = { return a : a → m a; bind a b : m a → (a → m b) → m b }; ``` === ## Computed Modules -------------------- ``` Table = if size  threshold then HashMap else TreeMap : MAP ``` === ## Predicativity ---------------- * `type`型はsmall type(型シグネチャに`type`型を持たない型、つまり単相型)にのみマッチできる + large typeは例えばこんなの`type T = (a : type) ⇒ {};` * この制約によって型が決定可能になってる * そもそもMLにはこんな制約は入ってるし既存のMLより表現力が劣ることはない * 因みにTransparent Typeならこの制約はない === # 3. Type System and Elaboration === # 明示的型付き1ML ------------------ * (6ページのFigure 2, 3を参考に) * Fωに変換(elaborate)される + まずはSyntactic Type - Semantic Type + 次にSemantic Type Directedにelaborate * Fωは型の進行と保存が成り立つよ * この辺はF-ingを読みながらやった方がいいかも === ## Semantic Types ----------------- * (7ページの左上の図を参考に) * 型は `Ξ = ∃ α. Σ` に変換されるよ + ∃を外に出すことで依存型を避けてる * 基本的にレコードのフィールドに出てくる`type`を∃にして外に出す戦略 * ただし関数の引数の位置では∀になる + 返り値でもこのパラメータを参照することで依存型を避ける * pure(applicative)とimpure(generative)で∃の位置が変わる + なんか[スコーレム標準形](https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%AC%E3%83%A0%E6%A8%99%E6%BA%96%E5%BD%A2)にしたりして頑張るらしい * transparent type `[= α]`もある === # Elaboration ------------- * (8ページのFigure 4を参考に) * 波矢印でelaboration規則 * グレーの規則は値レベル * 細かい話はF-ingに書いてある * サブタイピングは変換関数にelaborateされる === # Metatheory ------------- * Sound * System FωへのelaborationもSound * elaborationはdecidable === # 4. Full 1ML === ## Full 1ML ----------- *  A language without type inference is not worth naming ML. * (10ページのFigure 5参考に) * _ で推論 + small typeしか推論できない + `type` が入っている型はダメ * なんかimplicit functionが導入された * → 'a の引数を無言で受け付けるための関数 * implicit functionはpureな関数にのみ導入される * →value restrictionより緩い制限 * 少しMLっぽくなった === ``` type MAP = { type key; type map a; empty ’a : map a; lookup ’a : key → map a → opt a; add ’a : key → a → map a → map a }; Map (Key : EQ) : MAP where (type .key = Key.t) = {type key = Key.t; type map a = key → opt a; empty = fun x ⇒ none; lookup x m = m x; add x y m = fun z ⇒ if Key.eq z x then some y else m z } ``` === # 5. Type Inference ------------------ * (12ページのFigure 6を参考に) * なんかつらそう * サブタイピングあるとつらそう + → small typeに限るとほとんどtype equivalenceになるよ + 例外はrecord width * 型推論はincomplete + record width - 前述 - `r.id`って書いたときに`r`の型(`id`以外のフィールド)を決定できない + type scoping - よく分かんないけど推論のフェーズの問題で一般的な型にならないらしい？ + purity annotations - effect subtypingのせい * Sound * terminates === # 6. Related Works ---------------- * Packaged Modules + 案外一杯あるっぽい + OCaml, Moscow ML, Alice ML * First-Class Modules + レッドオーシャンっぽい + 歴史が書いてあるので読むと面白い * Applicative Functors + Moscow MLにGenerativeとApplicative両方入ってるらしい + full applicative functorsはfirst class modulesとコンフリクトする * 型推論 + モジュールの型推論システムとかあるけど1MLはmonomorphic typeしか推論しないよ === # 7. Future Work ------------- * 実装 (Toyはあるよ) * Applicative Functors * implicit (type class) + `type` しかないところに色々制約書けるようにしたらできそう * 型推論（今のところ単純だよね） * row polymorphismとかeffect polymorphismとか * Recursive Module(既にSystem Fに落とす先行研究がある) * 依存型   ","categories":["ML","型"],"category_urls":["/categories/ml","/categories/%e5%9e%8b"],"date":"2017-09-24","title":"1ML - コア言語とモジュール言語の統合","url":"https://KeenS.github.io/slide/1ml___koagengotomoju_rugengonotougou/"},
  {"body":"κeenです。昨日のエントリにmermaid.jsを試すといいよとのコメントを頂いたので試します。\n昨日のエントリでいう2のやつ、ブラウザ上でレンダリングしてくれます。\n導入は簡単で、\nheadに\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css\u0026#34;\u0026gt; を、\nbodyの下の方に\n\u0026lt;script src=\u0026#34;https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;mermaid.initialize({startOnLoad:true});\u0026lt;/script\u0026gt; を記述するだけです。私のテーマ（liquoriceのフォーク）ではそれぞれcustom/head.html、tail.htmlだったんですが恐らくテーマ毎に違うと思うのでよしなにやって下さい。\nそして\n\u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; CHART DEFINITION GOES HERE \u0026lt;/div\u0026gt; と書くとmermaid.jsがこれを拾って処理してくれるようです。\n例えばこれが\n\u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; graph LR A --- B B--\u0026gt;C[fa:fa-ban forbidden] B--\u0026gt;D(fa:fa-spinner); \u0026lt;/div\u0026gt; こう\ngraph LR A --- B B--C[fa:fa-ban forbidden] B--D(fa:fa-spinner);  あるいはこれが\n\u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; sequenceDiagram Alice -\u0026gt;\u0026gt; Bob: Hello Bob, how are you? Bob--\u0026gt;\u0026gt;John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a long\u0026lt;br/\u0026gt;long time, so long\u0026lt;br/\u0026gt;that the text does\u0026lt;br/\u0026gt;not fit on a row. Bob--\u0026gt;Alice: Checking with John... Alice-\u0026gt;John: Yes... John, how are you? \u0026lt;/div\u0026gt; こう\nsequenceDiagram Alice - Bob: Hello Bob, how are you? Bob--John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a longlong time, so longthat the text doesnot fit on a row. Bob--Alice: Checking with John... Alice-John: Yes... John, how are you?  最後のやつ、左向きの矢印の頭がレンダリングされてない（SVGレベルでarrowheadがない）… 公式のデモページでもそうなのでバグか何かですかね。\nひとまず昨日の方法よりはマシになったのでこれでいこうと思います。\n","categories":["Hugo","Mermaid.js"],"category_urls":["/categories/hugo","/categories/mermaid.js"],"date":"2017-08-27","title":"Hugoにシーケンス図を埋め込むその2","url":"https://KeenS.github.io/blog/2017/08/27/hugonishi_kensuzuwoumekomusono2/"},
  {"body":"κeenです。ブログに図を入れるお話です。 このブログの長らくの読者ならお気付きかもしれませんが、アスキーアートを多用していました。inkscapeを開いて図を生成してコピーして手で画像へのリンクを張るのがだるいためです。特段自動生成とかはしてなくて、全て手書きです。 流石にそろそろどうにかしようと思い立っていじった次第です。\n手で画像を書くのはやりたくないのでアスキーアートか何かしらの記法から画像を自動生成する方針です。ここで\n ブログアップロード前にmarkdownを解析して自動で生成、リンクを埋め込む ブラウザでレンダリングしてもらう emacsプラグインでどうにかする  の3つの方針があり、上の方が優先度が高いかなと思って調べ始めました。 多少調べましたが、1、2が難しそうだったので諦めて3にしました。1についてはhugoがスニペットにフックを掛けさせてくれたらよかったのですが、まだ出来ないようでした（#796）。2はあってもよさそうなので何かご存知の方は教えて下さい。\nと、結局3のemacsプラグインで外部のコマンドに投げる方針で実装します。外部コマンドは今のところditaaとPlantUMLをサポート。文化的にそうなのか、両方ともJava実装なのでもっさりしてます。一応両者aptで入ります。\nで、書いたemacs lispはこちら。\n(defun current-line-string () (save-excursion (let (start end) (beginning-of-line) (setq start (point)) (end-of-line) (setq end (point)) (buffer-substring start end)))) (defun ditaa-region (start end filename) (interactive (progn (unless (mark) (user-error \u0026#34;The mark is not set now, so there is no region\u0026#34;)) (list (region-beginning) (region-end) (read-file-name)))) (call-shell-region start end \u0026#34;ditaa -\u0026#34; nil (list :file filename))) (defun plantuml-region (start end filename) (interactive (progn (unless (mark) (user-error \u0026#34;The mark is not set now, so there is no region\u0026#34;)) (list (region-beginning) (region-end) (read-file-name)))) (call-shell-region start end \u0026#34;plantuml -pipe\u0026#34; nil (list :file filename))) (defun markdown-ext-parse-header (header-line) (if (string-match \u0026#34;\u0026lt;pre +style=\\\u0026#34;display:none;\\\u0026#34;\u0026gt;\\\\([[:alnum:]]+\\\\)[[:space:]]*,[[:space:]]*\\\\([[:alnum:]]+\\\\)\u0026#34; header-line) (list (match-string 1 header-line) (match-string 2 header-line)) nil)) (defun markdown-ext-region (start end) \u0026#34; \u0026lt;pre style=\\\u0026#34;display:none;\\\u0026#34;\u0026gt;{format},{filename} ... ... \u0026lt;/pre\u0026gt; \u0026#34; (interactive (progn (unless (mark) (user-error \u0026#34;The mark is not set now, so there is no region\u0026#34;)) (list (region-beginning) (region-end)))) (save-excursion ; trim trailing blanks (goto-char end) (skip-chars-backward \u0026#34;\\n\\t \u0026#34;) (setq end (point)) (narrow-to-region start end) (let ((prefix (file-name-base (buffer-file-name))) (header-line (save-excursion (beginning-of-buffer) (current-line-string))) (text-start (save-excursion (beginning-of-buffer) (next-line) (point))) (text-end (save-excursion (end-of-buffer) (beginning-of-line) (point)))) (destructuring-bind (format filename) (markdown-ext-parse-header header-line) (make-directory (format \u0026#34;../../static/images/%s\u0026#34; prefix) t) (cond ((string= format \u0026#34;ditaa\u0026#34;) (ditaa-region text-start text-end (format \u0026#34;../../static/images/%s/%s.png\u0026#34; prefix filename))) ((string= format \u0026#34;plantuml\u0026#34;) (plantuml-region text-start text-end (format \u0026#34;../../static/images/%s/%s.png\u0026#34; prefix filename)))) (end-of-buffer) (widen) (forward-char) (if (markdown-link-p) (kill-line)) (insert (format \u0026#34;![%s](/images/%s/%s.png)\u0026#34; filename prefix filename)) )))) かなり雑実装なのでコピペして使わずに参考実装程度にしてください。画像の保存場所なんか適当も適当。あとplantumlとditaaにはexec-pathを通しておいて下さい。\n使い方は特定のフォーマットに従って書いたらそのリージョンを選択してM-x markdown-ext-region。するとそのリージョンを解析して図を生成、リンクを挿入してくれます。\nフォーマットはかなり苦しかったのですがdisplay:noneな\u0026lt;pre\u0026gt;で囲むようにしてあって\n\u0026lt;pre style=\u0026#34;display:none;\u0026#34;\u0026gt;{format},{filename} ... ... \u0026lt;/pre\u0026gt; というようになっています。HTMLのコメントだと記法中に--\u0026gt;とかカジュアルに出てきてダメでした。\n例1 ditaa このテキスト\n\u0026lt;pre style=\u0026#34;display:none\u0026#34;\u0026gt;ditaa,file +--------+ +-------+ +-------+ | | --+ ditaa +--\u0026gt; | | | Text | +-------+ |diagram| |Document| |!magic!| | | | {d}| | | | | +---+----+ +-------+ +-------+ : ^ | Lots of work | +-------------------------+ \u0026lt;/pre\u0026gt; をリージョン選択してmarkdown-ext-regionを呼ぶと![file](/images/Hugonishi_kensuzuwoumekomu/file.png)のようなリンクを生成してくれて、実際はこのような見た目になります。\nditaa,file +\u0026mdash;\u0026mdash;\u0026ndash;+ +\u0026mdash;\u0026mdash;-+ +\u0026mdash;\u0026mdash;-+ | | \u0026ndash;+ ditaa +\u0026ndash;\u0026gt; | | | Text | +\u0026mdash;\u0026mdash;-+ |diagram| |Document| |!magic!| | | | {d}| | | | | +\u0026mdash;+\u0026mdash;-+ +\u0026mdash;\u0026mdash;-+ +\u0026mdash;\u0026mdash;-+ : ^ | Lots of work | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+  例2 PlantUML こう書くと\n\u0026lt;pre style=\u0026#34;display:none;\u0026#34;\u0026gt;plantuml,file2 @startuml [*] --\u0026gt; Active state Active { [*] -\u0026gt; NumLockOff NumLockOff --\u0026gt; NumLockOn : EvNumLockPressed NumLockOn --\u0026gt; NumLockOff : EvNumLockPressed -- [*] -\u0026gt; CapsLockOff CapsLockOff --\u0026gt; CapsLockOn : EvCapsLockPressed CapsLockOn --\u0026gt; CapsLockOff : EvCapsLockPressed -- [*] -\u0026gt; ScrollLockOff ScrollLockOff --\u0026gt; ScrollLockOn : EvCapsLockPressed ScrollLockOn --\u0026gt; ScrollLockOff : EvCapsLockPressed } @enduml \u0026lt;/pre\u0026gt; こうなります\nplantuml,file2 @startuml [*] \u0026ndash;\u0026gt; Active\nstate Active { [] -\u0026gt; NumLockOff NumLockOff \u0026ndash;\u0026gt; NumLockOn : EvNumLockPressed NumLockOn \u0026ndash;\u0026gt; NumLockOff : EvNumLockPressed \u0026ndash; [] -\u0026gt; CapsLockOff CapsLockOff \u0026ndash;\u0026gt; CapsLockOn : EvCapsLockPressed CapsLockOn \u0026ndash;\u0026gt; CapsLockOff : EvCapsLockPressed \u0026ndash; [*] -\u0026gt; ScrollLockOff ScrollLockOff \u0026ndash;\u0026gt; ScrollLockOn : EvCapsLockPressed ScrollLockOn \u0026ndash;\u0026gt; ScrollLockOff : EvCapsLockPressed }\n@enduml  ブログを見易くしていきたい。\n","categories":["Hugo","PlantUML","Ditaa"],"category_urls":["/categories/hugo","/categories/plantuml","/categories/ditaa"],"date":"2017-08-26","title":"Hugoにシーケンス図を埋め込む","url":"https://KeenS.github.io/blog/2017/08/26/hugonishi_kensuzuwoumekomu/"},
  {"body":"# 最近のSML#の話題 ---------------------- [ML勉強会 #2 - connpass](https://ml-lang.connpass.com/event/58151/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # 話すこと ------ * SML# 3.0。0以降立て続けにリリースが続いてる * 最近の変更を追いきれないのでまとめて追う ver. | date ------|----- 3.3.0 | 2017-06-20 3.2.0 | 2016-09-16 3.1.1 | 2016-07-15 3.1.0 | 2016-05-26 3.0.1 | 2016-04-04 3.0.0 | 2016-03-31 2.0.0 | 2014-04-04 1.2.0 | 2012-11-14 === # そもそもSML#って？ ------------------- * SML '97 互換のコンパイラ + [The Definition of Standard ML, Revised](http://sml-family.org/sml97-defn.pdf) + Self Hosted + 2.0.0からLLVMベース * 実用的な処理系を目指して作られてる * 独自機能も多数 * コンパイラとして使いやすい + 分割コンパイル + REPL * 速度は遅め === # SML#の独自機能 ---------------- 3.0.0以降の変更を追うのに一部前提知識として必要。 とりあえず型を読めるようになって * 第一級オーバーロード * ランク1多相 * 多相レコード * SQL連携 * C FFI * マルチスレッドサポート === # ランク1多相 ------------- * SMLでは冠頭多相しかない ``` sml - fun pair x y = (x, y); val pair = fn : 'a - 'b - 'a * 'b (* pair 1: 'b - (int, 'b) にはならない *) - pair 1; stdIn:4.1-4.7 Warning: type vars not generalized because of value restriction are instantiated to dummy types (X1,X2,...) val it = fn : ?.X1 - int * ?.X1 ``` * SML#では返り値の関数も多相にできる ``` sml # fun pair x y = (x , y); val pair = fn : ['a. 'a - ['b. 'b - 'a * 'b]] # pair 1; val it = fn : ['a. 'a - int * 'a] ``` * `['a. ty]` が ${}^\\forall a. ty$ の気分 * 因みに冠頭多相な型パラメータは`,`で並べる ``` sml val pair = fn : ['a, 'b. 'a - 'b - 'a * 'b] ``` === # 第一級オーバーロード --------------------- * SMLの演算子はオーバーロードされてるけど中途半端 + 関数として多相になれなくて、推論できなければデフォルトint + `1.0 + 2.0: real` だけど `op+: int * int - int` * SML#はオーバーロードされた関数をサポート + `op+: ['a::{int, word, int64, word64,...}. 'a * 'a - 'a]` * `['a. ty]` に条件が付いた感じの型 * 自分でオーバーロードも書けるけど今回は触れない === # 多相レコード ------------- * SMLでのレコードのフィールドの選択は多相になれない + アノテーションを与えないといけない ``` sml - #id; stdIn:1.2-1.5 Error: unresolved flex record (can't tell what fields there are besides #id) - #id: {id:int, name: string} - int; val it = fn : {id:int, name:string} - int ``` * SML#は多相になれる ``` sml # #id; val it = fn : ['a#{id: 'b}, 'b. 'a - 'b] ``` * 適用可能なレコードの上限がついた感じの型 === # SQL連携 --------- ``` sml (* DBの宣言。テーブルの型は全て手で書く *) val server = _sqlserver \"postgres://hoge:password@localhost/sample1\" : {people: {name:string, age:int}}; (* `_sql` に続けてSMLでSQLっぽ書ける *) val q = _sql db = insert into #db.people (name, age) values (\"Alice\", 24); (* コネクションを作って実行 *) val conn = SQL.connect server; val _ = _sqlexec q conn; ``` === # SQL連携 --------- select 文は型に注目 ``` sml # _sql db =  select #person.name as name,  #person.age as age  from #db.people as person  where SQL.=(#person.age, 25); val it = fn : ['a#{people: 'b}, 'b#{age: int, name: 'c}, 'c::{int, intInf, word, char,...}, 'd::{int, intInf, word, char,...}. 'a SQL.db - {age: int, name: 'c} SQL.query] ``` === # C FFI -------- * `_import` 一行でCの関数を呼べる * そのためにGCをnon-movingにしたり工夫している ``` sml # val puts = _import \"puts\": (string) - (); val puts = fn : string - unit # puts \"hello\"; hello val it = () : unit ``` === # マルチスレッドサポート ----------------------- * `_import` で`pthread_create`を呼べる ``` sml type pthread_t = unit ptr; val pthread_create = _import \"pthread_create\" : (pthread_t ref, unit ptr, unit ptr - unit ptr, unit ptr) - int fun create f = let val ret = ref _NULL val err = pthread_create (ret, _NULL, f, _NULL) val ref th = ret in if err = 0 then () else raise Fail \"pthread_create\"; th end ``` === # 最近のSML# ----------- Changesベース === # 3.0.0 ------- * 64bit化 + 逆に32bitサポートは怪しくなった * pthreadサポート（あれ？今までは？） + デフォルトでサポートONになったらしい * Fully Concurrent GC + [A Fully Concurrent Garbage Collector for Functional Programs on Multicore Processors. Katsuhiro Ueno, Atsushi Ohori. To appear in Proc. ICFP, 2016.](http://www.pllab.riec.tohoku.ac.jp/papers/icfp2016UenoOhori-preprint.pdf) === # Fully Concurrent GC --------------------- * SML#のBit Map GCベース * アロケーションはスレッド毎にセグメントを割り当てる * コレクタはSnap Shotっぽいやつ 1. Filledなセグメントは自動でルートセットに 2. Currentなセグメントは各スレッドとハンドシェイク + コレクタとミューテータは別スレッド + スレッドが自分が管理しているルートセットを計算する + ライトバリアをonに 3. 各ミューテータスレッドからルートセットが返ってくる 4. あとはsnap shotと同じ 5. ライトバリアをoffにできる * 関数型言語なのでライトバリアが響かない === # 3.1.0 -------- * JSONサポート + [A Calculus with Partially Dynamic Records for Typeful Manipulation of JSON Objects. Atsushi Ohori, Katsuhiro Ueno, Tomohiro Sasaki, Daisuke Kikuchi. To appear in Proc. ECOOP Conference, 2016.](http://www.pllab.riec.tohoku.ac.jp/papers/ecoopPreversion.pdf) === # JSONサポート ------------- コードは3.3.0より引用 ``` sml structure JSON = struct exception AttemptToReturnVOIDValue exception RuntimeTypeError exception TypeIsNotJsonKind exception AttemptToViewNull exception NaturalJoin datatype null = datatype JSONTypes.null datatype void = datatype JSONTypes.void datatype jsonTy = datatype JSONTypes.jsonTy datatype json = datatype JSONTypes.json datatype dyn = datatype JSONTypes.dyn val view : 'a dyn - 'a val import : string - void dyn val importJson :JSONParser.utJson - void dyn val typeOf : json - jsonTy val printJsonTy : jsonTy - unit val jsonToJsonDyn : json - void dyn val jsonToString : json - string val jsonDynToString : 'a dyn - string val jsonDynToJson : 'a dyn - json val toJson : ['a#dynamic.'a - json] val dynamicToJson : PolyDynamic.dynamic - json val toJsonDyn : ['a#dynamic.'a - void dyn] end ``` === # JSONサポート ------------- SML3.3に合わせてコードを変えてある ``` sml val json = JSON.import \"{\\\"name\\\":\\\"SML#\\\", \\\"version\\\":\\\"3.1\\\"}\" val name = _jsoncase json of {name=x:string, ...} = x; val reco = _json json as {name: string, version: string} val versions = _json JSON.import \"{\\\"name\\\":\\\"SML#\\\", \\\"version\\\":\\\"3.1\\\"}\" as {name: string, version: string} val data = JSON.jsonToString (JSON.toJson {name = \"SML#\", version = \"3.1\"}) ``` demo === # 3.1.1 ------- * inner join * 実行されるsqlクエリの改善 + 差分取りづらいので断念 === # Inner Join ------------ ``` sml _sql db = select #P.name as name, #P.age as age, #S.salary from #db.Persons as P inner join #db.Salaries as S on #P.id = #S.person_id where SQL.(#S.salary, 10000) ; ``` ``` ['a#{Persons: 'b list, Salaries: 'c list}, 'b#{age: 'f, id: 'j, name: 'h}, 'c#{person_id: 'j, salary: 'd}, 'd::{int, intInf, 'e option}, 'e::{int, intInf}, 'f::{int, intInf, word, char,...}, 'g::{int, intInf, word, char,...}, 'h::{int, intInf, word, char,...}, 'i::{int, intInf, word, char,...}, 'j::{int, intInf, word, char,...}, 'k::{int, intInf, word, char,...}. 'a SQL.conn - {3: 'd, age: 'f, name: 'h} list SQL.cursor] ``` === # 3.2 ------ * DBのnatural joinの型システム + [SML# with Natural Join - ICFP 2016](http://conf.researchr.org/event/icfp-2016/mlfamilyworkshop-2016-papers-sml-with-natural-join) + [A. Ohori and P. Buneman. Type inference in a database programming language. In Proc. ACM Conference on LISP and Functional Programming, pages 174–183, 1988.](http://www.pllab.riec.tohoku.ac.jp/~ohori/research/lfp88.pdf)の実現っぽい？ * jsonのNULLサポート === # Natural Join -------------- ``` sml _sql db = select #P.name as name, #P.age as age, #S.salary from #db.Persons as P natural join #db.Salaries as S where SQL.(#S.salary, 10000) ; ``` ``` ['a#{Persons: 'b list, Salaries: 'c list}, 'b#{age: 'f, name: 'h}#reify, 'c#{salary: 'd}#reify, 'd::{int, intInf, 'e option}, 'e::{int, intInf}, 'f::{int, intInf, word, char,...}, 'g::{int, intInf, word, char,...}, 'h::{int, intInf, word, char,...}, 'i::{int, intInf, word, char,...}, 'j#{}#reify. (* この辺がnatural join型 *) ('j = 'b join 'c) = 'a SQL.conn - {3: 'd, age: 'f, name: 'h} list SQL.cursor] ``` === # Nullable in JSON ------------------ ``` sml val json2 = JSON.import \"{\\\"name\\\":\\\"SML#\\\", \\\"version\\\":\\\"3.1\\\", \\\"date\\\": null}\" val reco2 = _json json2 as {name: string, version: string, date: string option} ``` === # 3.3.0 ------ * massive threadsサポート + [Making SML# a General-purpose High-performance Language. Atsushi Ohori, Kenjiro Taura, Katsuhiro Ueno.](http://www.pllab.riec.tohoku.ac.jp/papers/ml2017Preversion.pdf) + [massivethreads/massivethreads: Light weight thread library](https://github.com/massivethreads/massivethreads) + [細粒度マルチスレッド処理系 MassiveThreads](http://www.yl.is.s.u-tokyo.ac.jp/raw-attachment/wiki/GeneralMeeting/20110627-massive.pdf) + 100万個スレッド作れるらしい + IOスケジューリングも頑張るらしい * Concurrent, Myth, CMLモジュールが増えた + ようやく処理系提供のスレッドライブラリ + CMLはMLtonとかと互換 === # 3.3.0 ------ * SQLの向上 + 中置演算子がそのままな感じに + テーブルの型がlistに + sqlexcとsqlevalが廃止されてコネクションを渡されたら実行するように + リフレクション導入？（reifyできる型に対して`pp`が導入された） * type reification * ML式の自然結合 === # Massive Threads ------------------ * Myth: ベースバインディング - [Thread](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/myth.smi#L7) - [Mutex](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/myth.smi#L19) - [Cond](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/myth.smi#L30) - [Barrier](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/myth.smi#L41) * Concurrent: 便利ライブラリ - [MVar](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/concurrent.smi#L7) - [IVar](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/concurrent.smi#L15) - [Couple](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/concurrent.smi#L23) - [Thread](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/concurrent.smi#L31) - [Future](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/concurrent.smi#L37) * [CML](https://github.com/smlsharp/smlsharp/blob/master/src/thread/main/cml.smi): Concurrent ML互換インタフェース - なんかCSPっぽい作りらしい？ === # Massive Threads ------------------ * なんか[並列処理構文](https://github.com/smlsharp/smlsharp/blob/master/benchmark/benchmarks_massive/suffixsum.sml#L17-L38)も入ったらしい？ * 長い ``` sml _foreach id in dataExp [where setUpExp] with pat do iteratorExp while predicateExp end ``` === # 中置演算子 ----------- ``` sml _sql db = select #P.name as name, #P.age as age, #S.salary from #db.Persons as P inner join #db.Salaries as S on #P.id = #S.person_id where #S.salary  10000 ; ``` === # SQL式の分割 ------------ ``` sml # val sel = _sql select #t.name; val sel = _ : ['a#{t: 'b}, 'b#{name: 'c}, 'c::{int, intInf, word, char,...}, 'd::{int, intInf, word, char,...}, 'e. ('a list, {1: 'c} list, 'e) SQL.select] # val frm = fn db = _sql from #db.people as t  ; val frm = fn : ['a#{people: 'b list}, 'b, 'c. ('a, 'c) SQL.db - ({t: 'b} list, 'c) SQL.from] # val whr = fn () = _sql where (#t.age = 25 and #t.salary  300); val whr = fn : ['a#{t: 'b}, 'b#{age: 'd, salary: 'f}, 'c, 'd::{int, intInf, 'e option}, 'e::{int, intInf}, 'f::{int, intInf, 'g option}, 'g::{int, intInf}. unit - ('a list - 'a list, 'c) SQL.whr] # val q = _sql db = select...(sel) from...(frm db) where...(whr ()); val q = fn : ['a#{people: 'b list}, 'b#{age: 'e, name: 'c, salary: 'g}, 'c::{int, intInf, word, char,...}, 'd::{int, intInf, word, char,...}, 'e::{int, intInf, 'f option}, 'f::{int, intInf}, 'g::{int, intInf, 'h option}, 'h::{int, intInf}. 'a SQL.conn - {1: 'c} list SQL.cursor] ``` === # Type Reification ------------------ * 値をreifyしてdatatypeとして取り出せる * いわゆるリフレクション？ * [コード](https://github.com/smlsharp/smlsharp/blob/master/src/compiler-utils/reflection/main/ReifiedTerm.ppg#L59) ``` sml structure ReifyTerm = struct val toReifiedTerm : ['a#reify.'a - ReifiedTerm.reifiedTerm] val sizeOf : ReifiedTy.reifiedTy - word val setCdr : ['a#reify. 'a list * 'a list - unit] end ``` === # Type Reification ------------------ ``` sml fun ('a#reify) pp (x:'a) = (TextIO.print (ReifiedTerm.reifiedTermToString (ReifyTerm.toReifiedTerm x)); TextIO.print \"\\n\") ``` ``` # pp; val it = fn : ['a#reify. 'a - unit] # pp (1 + 1); 2 val it = () : unit # pp {name = \"keen\", age = 25}; {age = 25, name = \"keen\"} val it = () : unit ``` === # ML式の自然結合 ---------------- ``` sml # _join(1, 1); val it = 1 : int # _join(1, 2); uncaught exception NaturalJoin.NaturalJoin at (interactive):2 # _join([1, 2, 3], [2, 3, 4]); val it = [2, 3] : int list # val l1 = [{id = 1, age = 10}, {id = 2, age = 20}, {id = 3, age = 30}]; val l1 = [{age = 10, id = 1}, {age = 20, id = 2}, {age = 30, id = 3}] : {age: int, id: int} list # val l2 = [{id = 2, salary = 200}, {id = 3, salary = 300}, {id = 4, salary = 400}]; val l2 = [{id = 2, salary = 200}, {id = 3, salary = 300}, {id = 4, salary = 400}] : {id: int, salary: int} list # _join(l1, l2); val it = [{age = 20, id = 2, salary = 200}, {age = 30, id = 3, salary = 300}] : {age: int, id: int, salary: int} list ``` === # まとめ -------- * SML# 3系の変更を追ったよ * SQL、JSON、Concurrency * みんなもSML# 使おうね   ","categories":["ML","SML","SMLSharp"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp"],"date":"2017-07-17","title":"最近のSML#の話題","url":"https://KeenS.github.io/slide/saikinnosml_nowadai/"},
  {"body":"κeenです。最近Futureと一口にいってもいくつか種類があるなと気付いたのでRustのfutures-rsに実装されているFutureの挙動を紐解こうと思います。\nイベント駆動IO TCPサーバをノンブロッキングに書こうとすると、思いの他大変です。 ブロックせずにIOできるタイミングまで処理を溜めておいて、できるときに読み書きします。ブロックしないタイミングをみつけるのも一苦労なので大抵ライブラリに頼ってライブラリからイベントを通知してもらいます。Rustにはmioというライブラリがあります。\nさて、これイベントの発見は書かなくてよくなりましたが、まだつらいです。リクエストがないのにレスポンスを返せる訳もないので処理とイベントに依存関係があって、「read readyイベントでデータを読み取って、足りれば処理開始、足りなければまだ読み取る。処理が終わればwrite readyイベントを待って書き込み。その後は次のリクエストに備えてread readyイベント待ち」などの複雑な条件分岐と処理をしなければなりません。しかもクライアントは1つじゃないのでそれらを複数管理しないといけません。やりきれませんね。私が昔書いたWebsocketのechoサーバを少し見ると大変そうなことが伝わると思います。（余談ですが、つらそうなコードを書いたのは抽象化ライブラリに頼らないコードを実感するためでした）\nステートマシン 先程の複雑な条件分岐の例は、「ステート」があることに気付きます。「リクエストがまだ来てない」「リクエストの一部が届いたけど全部でない」「リクエストの処理中」「レスポンスの送信待ち」など。これを明確に「ステート」としてプログラムを書いてあげると綺麗に書くことができます。\n[リクエストがまだ来てない]\u0026lt;----------------+ | read ready | +------------------------------------+ | | | | [リクエストの一部がきたが全部でない]\u0026lt;-+ | | | read ready | | | +---------------------------------+ | | | | | [リクエストの処理中]\u0026lt;-------------------+ | | | [レスポンスの書き出し待ち] | | write ready | [レスポンスの書き出し完了]-----------------+ さて、このステートマシンを図に書く範囲では明瞭なのですが、実際のプログラムに落とすとやや見通しが悪いです。\nナイーブな実装を疑似コードで書くとこうなるでしょうか。\nenum State = リクエストがまだ来てない | リクエストの一部がきたが全部でない | リクエストの処理中 | レスポンスの書き出し待ち | レスポンスの書き出し完了 event arrived case (state, event) when (リクエストがまだ来てない, read ready) ... if request is complete state \u0026lt;- リクエストの処理中 wait for write ready else state \u0026lt;- リクエストの一部がきたが全部でない wait for read ready when リクエストの一部がきたが全部でない ... if request is complete state \u0026lt;- リクエストの処理中 wait for write ready else state \u0026lt;- リクエストの一部がきたが全部でない wait for read ready ... モデリングは上手くいっているものの実際のコードに落とすとみづらいですね。 ナイーブな実装方法の他に、デザインパターンのステートパターンを使う手もあります。まあ、そのまんまですね。 疑似コードにするとこうなるでしょうか。\nabstract class State method do returns (State, Event) class リクエストがまだ来てないState method do returns (State, Event) ... if request is complete return (new リクエストの処理中State, write ready) else return (new リクエストの一部がきたが全部でないState, read ready) class リクエストの一部がきたが全部でない method do returns (State, Event) ... if request is complete return (new リクエストの処理中State, write ready) else return (new リクエストの一部がきたが全部でないState, read ready) event arrived if event equals waiting_event (next_state, waiting_event) \u0026lt;- state.do() ステートと処理のかたまりで分離することができたのでコードの見通しもよくなりました。\nしかし、Rust的にはまだ問題があります。Stateのサブクラスでモデリングしてますが、それだとメソッドのディスパッチが動的ディスパッチになってしまって遅いです。Zero-cost abstractionできてません。\nもう1つ問題があって、これでもまだ直感的なコードとはかけ離れてます。本来ならこういうコードを書きたい筈です。\nrequest \u0026lt;- empty until request is complete request \u0026lt;\u0026lt; input response \u0026lt;- // do something with request output \u0026lt;\u0026lt; response これをどうにかできないでしょうか。\nFuture そこでfutures-rsです。ゼロコストでステートマシンを抽象化してくれます。Zero-cost futures in Rust · Aaron Turonを読んだことのある人も多いでしょう。\n基本的なアイディアは、1つのステートとその時の処理を表わすFutureの他にステート同士を繋げるコンビネータを用意することで柔軟にプログラムを書けるようにするということです。そしてステートの処理関数が静的ディスパッチされるようにコンビネータを工夫する（基本的には型パラメータに情報を残して静的ディスパッチできるようにする）ことでゼロコスト抽象化を実現しています。\n先程のコードをfuturesを使って書くとこのような雰囲気になるでしょうか。\nletf=loop_fn(Vec::new(),|mutbuff|{input.read().and_then(|data|{buff.append(data);matchRequest::parse(buff){Ok(request)=\u0026gt;Ok(Loop::Break(request))Err(_)=\u0026gt;Ok(Loop::Continue((buff)))}})}).and_then(|request|{// do something with request }).and_then(|response|{output.write(response)});run(f) ダイレクトなコードに比べるとまだノイズが多いですが、ステートマシンを陽に作るコードよりは直感的になったと思います。\n他のFutureとの違い futuers-rsのFutureは1イベント起きる度に(pollが呼ばれてReadyになる度に)次のステートの処理をし、その次のステートに移るという流れが基本です。 次のステートに移っても、即座にそののステートの処理が走る訳ではありません。次にpollが呼ばれるまで処理をしません。つまりマルチスレッドの文脈で語ると、イベントが発火したスレッド ではなく pollを呼んだスレッド、おおむね Futureを所有しているスレッドで処理が走ります 。Futureの処理がスレッドを飛び越えたりはしません。ある1つのFutureを別スレッドで計算したければCPU Poolなどが使えますが、その後（spawnの返り値の新たなFuture）に続けた処理は今のスレッドで実行されます。\n一方他のFutureはほぼマルチスレッドと密結合したプロミスのようになっていて、\n1 Future = 別スレッドで実行される計算への先物。 コンビネータ(callback) = 別スレッドで実行される計算が終わったあとに同じスレッドで実行されるべき計算\nのようなものが多い印象です。要は1つ処理が終わるとそのまま次の処理、その次の処理と自動で発火していく。もちろん、ライブラリの作りによってスレッドとの関係性などにバリエーションはあるでしょうが、Rustのようにpollを基本とした設計はあまりみません。\nこのようにFutureにも色々あるうち、Rustでメジャーに使われているfutures-rsのFutureはステートマシンの抽象化になっているよ、というお話でした。\n","categories":["Rust","Future","非同期"],"category_urls":["/categories/rust","/categories/future","/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f"],"date":"2017-07-02","title":"ステートマシン抽象化としてのFuture","url":"https://KeenS.github.io/blog/2017/07/02/sute_tomashinchuushoukatoshitenofuture/"},
  {"body":"κeenです。本日ジェネリクス勉強会で発表したのですがいくつか拾いきれないコメントがあったのでここでお返事書きます\n発表スライドはこちら\nジェネリクスの実装はポインタ方式とテンプレート方式だけじゃないよ もちろんです。 基本的な手法を大別しただけで、私の発表中にもポインタ方式でも最適化がありえるとの指摘がありましたし、ジェネリクス勉強会中でも.NETの実装の話も出てました。 勉強会全体を見ているならここで私がフォローするまでもないかと思いますが、念のため拾っておきます。\nクロージャの件が分からない  クロージャの型は関数型じゃないの？ 無名関数は関数に名前がないだけで型はあるんじゃないの？ なんで(Iteratorのmapとかの)返り値に関数型がでてくるの  Rustの挙動を知らないとちょっと分かりづらかったですね。それとあとで見返したら私も発表中一箇所嘘いってました。 詳しいことをコード例を出しながら説明していきます\nRustのクロージャの型は匿名化された型 Rustのクロージャ3種を作って理解する | κeenのHappy Hacκing BlogやRustのゼロコスト抽象化 | κeenのHappy Hacκing Blog で若干説明しましたが、Rustではクロージャリテラル毎に型が作られます。\nletmutx=0;letmutcounter=||{x+=1;x} こう書いたときにコンパイラは裏で以下のようなコードを生成します。（Rustを知らない人への説明のため、FnOnceの存在や実際は参照でキャプチャするなどを無視した疑似コードです）\nstruct AnonymousClosure{x: i32}implFnMut\u0026lt;()\u0026gt;forAnonymousClosure{extern\u0026#34;rust-call\u0026#34;fn call_mut(\u0026amp;mutself,(): ())-\u0026gt; i32 {self.x+=1;x}}letmutx=0;letmutcounter=AnnonymousClosure{x: x} 要点は\n クロージャ自体はただのキャプチャしたデータの集まり 関数本体は、メソッドとして定義される。 Rustは静的ディスパッチをする ので 関数ポインタはデータには含まれない。コンパイラが解決する。  私が1つ嘘を言っていたというのはここです。関数ポインタもデータに含まれるって言っちゃってました。 クロージャだけど関数ポインタを使わないんですね  1クロージャリテラルにつき1型を生成することでクロージャリテラル毎の関数本体を出し分けている キャプチャした変数をまとめた構造体自体はポインタ型になっていない  ということで\n クロージャ自体の型は関数型ではなくて、関数っぽい振舞いをするトレイト(ここではFnMut)を実装しているだけのただの無名型です。 無名関数だから型が無名という説明は確かにちょっとおかしかったですね。  クロージャを返したい ここから「なんで(Iteratorのmapとかの)返り値に関数型がでてくるの」へのお返事。\n説明の例として遅延評価するイテレータへのマップを書きたいと思います。 引数にはイテレータとクロージャを取ります。 実際には適用する訳ではないのでマップするイテレータとクロージャの組を返せばよさそうですね。 ここで思い出して欲しいのはクロージャはただのFnMutを実装している構造体なのでした。 なのでこう書くのですが、\nfn map\u0026lt;I,B,F\u0026gt;(i: I,f: F)-\u0026gt; (I,F)whereI: Iterator,F: FnMut(I::Item)-\u0026gt; B,{(I,F)} 実際にクロージャを渡したときには\nfn map(i: SomeIter,f: AnnonymousClosure)-\u0026gt; (SomeIter,AnnonymousClosure){(i,f)} のようになります。ここでも、クロージャデータにはポインタが挟まってないことに注意して下さい。そして型名が分かるのでクロージャを呼び出すときにはその関数が 静的ディスパッチされます\n返り値にクロージャの型を書く = クロージャの関数本体が静的ディスパッチされる = 速い\nということが伝わりますでしょうか。なのでRustではできるかぎり返り値にクロージャの型を書きたいのです。\nで、このパターンだと引数で受け取ったものを返り値で返すだけなので関数を呼んだときに得られた名前を書くだけです。たとえクロージャが匿名型であっても書くことができます。\n返り値にだけ書きたい ところが返り値にだけクロージャの型を書こうとすると、ダメです。先程のmap関数を関数の中で使ってみましょう。\nfn inc\u0026lt;I\u0026gt;(i: I)-\u0026gt; ???whereI: Iterator\u0026lt;Item=i32\u0026gt;,{map(i,|x|x+1)} こうすると型はこう解決されます。\nsturctAnnonymousClosure;implFnMut\u0026lt;(i32,)\u0026gt;forAnonymousClosure{extern\u0026#34;rust-call\u0026#34;fn call_mut(\u0026amp;mutself,(x,): (i32,))-\u0026gt; i32 {x+1}}fn inc(i: SomeItr)-\u0026gt; (SomeItr,AnnonymousClosure){map(i,AnnonymousClosure::new())} 返り値にだけ匿名型が出てきました。 先程のようにパラメータで受け取ってそのまま返すということができません。 なのでここで、返り値も匿名化する存在型が必要になるのです。\nここまでくれば以下のコードにも存在型が必要な理由が分かりますでしょうか。\nfn do_later()-\u0026gt; implFuture\u0026lt;Item=(),Err=Error\u0026gt;{do_something()// ここでクロージャが出てきた .and_then(|()|do_another_thing())// 本来の`and_then`の返り値は // `AndThen\u0026lt;Self, B, F\u0026gt;`だが // `F`の型が匿名化されていて書けない } 存在型って、forallでできるよ マジレスなのかただ知識を披露してるのかよく分からなかったのですが、いちおうお返事書いておきます。\nどの意味で「forall」でできるよと言っているのかよく分からなかったのですが、Coqの実装を見ていっているのなら見当違いです。 Coqの実装はこの辺が参考になりますかね。 Coqで「任意のxについて…」「あるxが存在して…」を扱う - きくらげ観察日記。\nこれをRustで書くとこうなるでしょうか。Rustにはトレイトをパラメータで受け取る手段がないのでひとまず量化する一階の述語をFn() -\u0026gt; ()トレイトにしておきます。\nstruct FnExists\u0026lt;F: Fn()-\u0026gt; ()\u0026gt;(f: F) これは命題論理としては正しいのですが、型パラメータを取るので目的である匿名化を実現できていません。\n2017-06-25 追記: よく考えたらCoqの実装とは異なりました。Coqに忠実にするならこうでしょうか。\nstruct FnExists(for\u0026lt;F: Fn()-\u0026gt; ()\u0026gt;f: F) これもダメです。Fの実際のサイズが分からないのでコンパイルできません。 これを実現できている言語ではポインタを使って実現しているのかと思います。 Rustでも説明の通りトレイトオブジェクトがあれば可能です。しかしながらオーバーヘッドがかかるので避けたいという話でした。 「型システムに表現能力がある」と「値レベルでのパフォーマンスを犠牲にしない表現能力がある」は別の話です。\n/追記\nもう1つは、CPS変換の可能性もあります。 この辺が参考になりますかね。データ型のCPS変換について - Just $ A sandbox。\n直観論理でも以下が成り立ちます。\n\\[ {}^\\exists x P(x) \\to \\lnot ^\\forall x \\lnot P(x) \\]\n因みに逆は直観論理では成り立ちません（直感的な説明をすると存在しないことを否定しても実際の値を構成できないからです）。\nこれは確かに正しいです。「Trトレイトを実装した型」という存在型は以下の疑似コードで書けるでしょう。\ntraitTr{}fn exists()-\u0026gt; FnOnce\u0026lt;A\u0026gt;(FnOnce\u0026lt;T: Tr\u0026gt;(t: T)-\u0026gt; A)-\u0026gt; A{lettr=SomeTr::new();forall\u0026lt;A\u0026gt;move|cont: FnOnce\u0026lt;T: Tr\u0026gt;(t: T)-\u0026gt; A|-\u0026gt; A{cont(tr)}} ですがまあ、これは実際には無理です。 1つにはRustには型の高ランク多相がありません。ジェネリクスだけです。 もしランクの概念を知らずにforallで書けると主張しているならそれは的外れです。 ランクの概念を知った上で高ランク多相を入れろという主張なら理解はできますが、無理です。 引数に渡す関数や返り値で返す関数、要はデータとして扱う関数はジェネリクスにできません。 スライドの中でRustはテンプレート方式と説明しましたが、ジェネリクスはテンプレートであって実際のデータではないので値として扱えないのです。 なのでRustのコンパイル方式を大きく変えるなどしないと実現できないでしょう。\nそれにもう1つ、ランクとは関係なしにクリティカルな理由があります。 上で説明した通り、クロージャの実際の型は匿名データ型になります。なので返り値に型として書くことができません。 冷静になって考えれば返り値のクロージャの型を書かないようにするための存在型のために返り値にクロージャの型を書くのは土台無理です。\nさて、私の知識では全称型で存在型を構成する手法はこれくらいですがもし上記以外の構成方法が存在して、私が明後日な返事をしているなら連絡下さい。\n","categories":["型","ジェネリクス","Rust","言語実装"],"category_urls":["/categories/%e5%9e%8b","/categories/%e3%82%b8%e3%82%a7%e3%83%8d%e3%83%aa%e3%82%af%e3%82%b9","/categories/rust","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2017-06-24","title":"ジェネリクス勉強会補足","url":"https://KeenS.github.io/blog/2017/06/24/jienerikusubenkyoukaihosoku/"},
  {"body":"# ジェネリクス ディスパッチ 表裏 ---------------------- [ジェネリクス勉強会 - connpass](https://connpass.com/event/56773/?utm_campaign=event_participate_to_owner\u0026utm_source=notifications\u0026utm_medium=email\u0026utm_content=title_link) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # はじめに ----------- * 例にはJavaとRustを使います + それ以外にあまり詳しくない + たまにScalaが出てくるかも * 主に裏側で何が起きてるかに焦点を当てます * 一般的な手法の比較と言語固有実装の比較がやや混じります + 実例重視 * 言語や機能を選ぶときの知識が増えればよし === # ジェネリクス -------------- * 型でパラメータ化された何か * パラメータ化する方法にいくつか方式が + 任意の型に対応する実装にする - Java + 使う型毎に実体をつくる - 型が引数になるイメージ - Rust * 便宜上前者をポインタ方式、後者をテンプレート方式と呼ぶ === # 関数ジェネリクス ----------------- * Javaコード ``` java public class Generics { public static void main(String[] args) { Generics g = new Generics(); System.out.println(g.id(\"hello\")); }  T id(T t) { return t; } } ``` === # 関数ジェネリクス ----------------- * Javaアセンブリ ``` public class Generics { // ... // Tの中身に言及していない  T id(T); Code: 0: aload_1 1: areturn ``` === # 関数ジェネリクス ----------------- * Rustコード ``` rust fn id(t: T) - T { t } fn main() { println!(\"{}\", id(\"hello\")); } ``` === # 関数ジェネリクス ----------------- * Rustアセンブリ ``` llvm define internal %str_slice @_ZN3tmp2id17hfe175cfdb5be0f46E(i8* noalias nonnull readonly, i64) unnamed_addr #0 { start: ; str_sliceに特化した関数を生成している %2 = insertvalue %str_slice undef, i8* %0, 0 %3 = insertvalue %str_slice %2, i64 %1, 1 ret %str_slice %3 } ``` === # 関数ジェネリクス ----------------- * ポインタ方式は`void *`使ってるイメージ + コンパイルされたコードがコンパクト + 必ずポインタ経由する + Javaのオブジェクトは参照になってるのであまり問題ない * テンプレート方式は型毎に`id_XXX`関数を定義してるイメージ + 構造体の値渡しも可能 + オブジェクトコードは大きくなる + 関数の使用箇所が分からないとコンパイルできない === # 返り値ジェネリクス ------------------- * Rustは返り値のジェネリクスがある - コンテキストで返り値が決まる ```rust // str parse(\u0026self) - Result::Err where F: FromStr; ``` ```rust let addr: SocketAddr = \"127.0.0.1:8080\".parse().unwrap(); ``` * コンパイル中に実際の型が解決されるので関連関数（スタティックメソッド）が呼べる * キモいけど便利 === # データ型ジェネリクス --------------------- * `ArrayList`(Java) vs `Vec`(Rust) * だいたい関数のときと似たような特徴 * テンプレート方式はサイズやアラインメントまで考慮できる - `Vec`(バイト列型)が効率的 * Rustの場合は構造体定義はオブジェクトコードに出ないのでサイズは気にならない === # 制約とディスパッチ ------------------- * パラメータ型に条件をつけたい + Javaならインターフェースで `T extends SomeInterface` とか + Rustならトレイトで `T: SomeTrait` とか * さらにパラメータ型の詳細にアクセスしたい + `t.someMethod()` とか * このメソッドってどっからやってくるの？ === ``` java void writeHello(W w) throws IOException { // このwriteメソッドはどこから？ w.write(\"Hello\"); } ``` ``` rust fn write_hello(mut w: W) - io::Result { // このwrite_allメソッドはどこから？ w.write_all(b\"Hello\") } ``` === # 動的ディスパッチ ------------------- * Javaだとオブジェクトに紐付くメソッドテーブルを *実行時* に引く + テーブルもオブジェクトから *実行時* に取得する ``` java w.vtable[write](w, \"Hello\"); ``` * ダイナミックなことができる + サブクラスのインスタンスと入り交じっても問題無 ```java Writer w = new MyWriter(); obj.writeHello(w); ``` * vtable引くオーバーヘッドがかかる - [java - Virtual table/dispatch table - Stack Overflow](https://stackoverflow.com/questions/6606481/virtual-table-dispatch-table) - [jvm - Java method table - Stack Overflow](https://stackoverflow.com/questions/10225668/java-method-table) === # 静的ディスパッチ ----------------- * Rustだとメソッドを *コンパイル時* に解決する + テーブルを静的に解決するだけじゃなくてテーブルのメソッドまで解決 ```rust SomeWriter::write(w, b\"Hello\") ``` + 辞書オブジェクトはみんなの心の中にあるんだよ - (テーブルだけ静的に解決する方式もある) * 速い + オーバーヘッドがない + メソッドのインライン化などの最適化ができる === # 動静まとめ ------------ * ポインタ方式で動的ディスパッチだとコンパクトだけど遅い * テンプレート方式で静的ディスパッチだと速いけど嵩む * 特徴は表裏な感じ === # Java固有の問題と解決 ---------------------- * ジェネリクスとプリミティブ問題 * → ヴァルハラ * → Scalaのspecialized * → DottyのLinker === # ジェネリクスとプリミティブ問題 -------------------------------- * ジェネリクスは必ずポインタ経由 + プリミティブはどうするの？ * 一旦オブジェクトに包む(ボクシングする)必要がある + 関数もデータ型も同じ問題 + 関数は暗黙の変換があるので気付きづらい * 割と深刻なパフォーマンス低下を招くこともある === ``` java public class Generics { public static void main(String[] args) { Generics g = new Generics(); // プリミティブを渡す System.out.println(g.id(0)); }  T id(T t) { return t; } } ``` === ``` public class Generics { public static void main(java.lang.String[]); // .. Code: // .. // ここで一旦`Integer`を作る 13: invokestatic #5 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 16: invokevirtual #6 // Method id:(Ljava/lang/Object;)Ljava/lang/Object; 19: invokevirtual #7 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V 22: return  T id(T); Code: 0: aload_1 1: areturn } ``` === # ヴァルハラ ------------ * [OpenJDK: Valhalla](http://openjdk.java.net/projects/valhalla/) + [JEP 169: Value Objects](http://openjdk.java.net/jeps/169) + [JEP 218: Generics over Primitive Types](http://openjdk.java.net/jeps/218) ← こっち * プリミティブタイプもボクシングせずにジェネリクスに使える * やったね * いつ入るんだろうね。 * [JDK 9](http://openjdk.java.net/projects/jdk9/) にはまだっぽい？ === # [scala.specialized](http://www.scala-lang.org/api/2.9.2/scala/specialized.html) ------------- * ジェネリクスの他にプリミティブ毎に専用のメソッドを生成 * 半分テンプレート方式みたい ``` scala class MyList[@specialized T] ... ``` * 実際には使われない型に対しても生成してしまう + → テンプレート方式よりも非効率 + 型パラメータが3つあったら1000メソッドくらい出来てしまう *  関数の使用箇所が分からないとコンパイルできない + JVMの分割コンパイル下では何が使われるか事前に分からない === # DottyのLinker --------------- *  関数の使用箇所が分からないとコンパイルできない * リンクフェーズを用意すれば使用箇所が全て分かる * [Dotty Linker: Making your Scala applications smaller and faster](https://d-d.me/talks/scaladays2015/#/) + スライドを見る限りspecializeしといてDCE? * 実際には生のバイトコードじゃ情報が足りないのでTASTYも付加 * Dottyはいつ使えるようになるんでしょうね。 === # Rust固有の問題と解決 --------------------- * トレイト境界とヘテロな型の問題 * ヘテロなVec * 分岐からのreturn * → トレイトオブジェクト === # トレイト境界とヘテロな型の問題 ------------------------------- * ジェネリックデータ型に2つ以上の異なる型を入れられない * つまり以下のようなコードが書けない ``` rust trait Processor {} let procs: Vec = vec![ TwProc::new(), FbProc::new(), ]; ``` * トレイトは実際の型ではないので同じ振舞をしても共通の型として扱えない * でも一緒に扱いたいケースがあるんだけど？？ === # トレイト境界とヘテロな型の問題2 ------------------------------- * 分岐して型を出し分けるのも出来ない ```rust fn getProc() - Processor { if xxx { TwProc::new() } else { FbProc::new() } } ``` === # トレイトオブジェクト --------------------- * オプトインで動的ディスパッチする仕組み * データとトレイトからvtableを作る * `Box`や`\u0026`などポインタ型を通すと使える === ``` rust let procs: Vec = vec![ Box::new(TwProc::new()), Box::new(FbProc::new()), ]; ``` ``` rust fn getProc() - Box { if xxx { Box::new(TwProc::new()) } else { Box::new(FbProc::new()) } } ``` === 裏 === # ジェネリクスの双対 ------------------- * ジェネリクスは$\\forall$の量化 + 関数$T \\to S$に対して${}^\\forall x(T \\to S)$ * $\\exists$の量化があってもよくない？ + 存在型と呼ばれる + 因みに${}^\\exists x(T \\to S)$は虚無 === # 存在型 --------- * 「`P`を満たす`T`が存在する」ことを表わす型 * `P`とは？ + 本来は型を引数にとる述語。 + e.g.) 「`T`は`S`のサブタイプである」「`T`は`write`メソッドを持つ」 + 実際は型の集合の方が便利 - $P(x) \\iff x \\in \\\\{x| {}^\\forall x, P(x) \\\\}$ + Scala: `forSome`に続く何か - よく分からなかった。構造的superset? + Rust: トレイト境界 * 実際に使うときには`P`を満たす`T`を1つ与える * 実際の型を変数`T`に匿名化してるとも見れる - Rustなら「トレイト`Tr`を実装しているとある型`T`」 === # 引数の存在型 --------------- * Scalaの`forSome` ```scala def len(l: List[T] forSome {type T}): Int ``` * Rustのarg position `impl Trait` ```rust fn len(i: impl IntoIterator) - usize ``` * `R`が`x`を含まないなら \\\\\\[{}^\\forall x(A(x) \\land x \\to R) \\leftrightarrow {}^\\exists x (A(x) \\land x) \\to R \\\\\\] なのでほぼジェネリクス * 違い + 関数が型パラメータを持たなくなる + 量化した場所以外（他の引数や返り値）でその型変数を使えない === # 返り値の存在型 ---------------- * Rustの`impl Trait` ```rust fn do_later() - impl Future``` * 実際の型は関数の定義で決まっている * 実質返り値を匿名化しているだけ * 必要？ === # 存在型の利点 -------------- * 何をしたいか伝わりやすい ```rust // Iterator map(self, f: F) - Mapwhere ... ``` vs ```rust map(self, f: F) - impl Iterator where ... ``` * サブタイピングがあればアップキャストで終わる * Rustでも動的ディスパッチを許せばトレイトオブジェクトがある + でも絶対動的ディスパッチをしたくない === # 存在型の必要性 ---------------- * 存在型でないと書けない型が存在する + 匿名化した型を含む型 + クロージャ、お前のことだ * 以下の型はジェネリクスでは書けない ``` rust fn counter(x: isize) - impl FnMut() - isize; ``` * 動的ディスパッチを許せばトレイトオブジェクトで書ける + でも絶対動的ディスパッチをしたくない + 極端な話、関数抽象する度にパフォーマンスが落ちる === # ユースケース -------------- * 実際そんなに必要なの？ * 極一部のケースだけじゃないの？ * 分岐したら結局トレイトオブジェクト必要なんじゃなかった？ * 動的ディスパッチで妥協できないの？ === # `Iterator` ------------ * 標準ライブラリ * 遅延評価 * 融合変換するため * `map`すると元のイテレータとmapする関数の組が返る ```rust // Iterator map(self, f: F) - Mapwhere ... ``` * `impl Trait`で書くと分かりやすい ```rust map(self, f: F) - impl Iterator where ... ``` === # [futures-rs](https://github.com/alexcrichton/futures-rs) ----------------- * 非同期処理を抽象化 * 実行時にはステートマシンになる + 動的ディスパッチを挟まない * `Future`に`map`や`and_then`すると返り値に関数型が出てくる + 存在型がないと書けない + 引数でクロージャを受け取る訳ではないのでジェネリクスで書けない * `Future`を使うほぼ全てのコードで存在型が必要になる === # futures-rs ------------ ``` rust fn do_later() - impl Future{ do_something() // ここでクロージャが出てきた .and_then(|()| do_another_thing()) // 本来の`and_then`の返り値は // `AndThen`だが // `F`の型が匿名化されていて書けない } ``` === # [transaction-rs](https://github.com/KeenS/transaction-rs) ------------------ * トランザクションを抽象化 * コンセプト的には`futures-rs`に似てる * 分岐しても`branch` APIでトレイトオブジェクト回避 + 直和型を信じろ * [マイクロベンチマーク](https://github.com/KeenS/transaction-rs/blob/master/transaction-stm/benches/boxed_vs_branch.rs)だとトレイトオブジェクトをなくすと *13%* 高速化 === # transaction-rs ---------------- ```rust fn find_and_delete() - impl Transaction... { match find_user() { // 分岐の枝毎に違う型を返そうとしてるが、直和型を使えば問題無 None = ok(none).branch().first() Some(user) = delete_user() .map(move|_| user) .branch() .second() } } ``` === # 存在型の深掘 -------------- * ユーザには匿名化された型の実体は分からない * コンパイラは実際の型で扱う * 色々エッジケースが出てきそう + 同じ関数から返る型は同じ型？ + 違う関数でも実体が同じなら？ + 関数がジェネリクスだったら？ - 返り値もジェネリクスパターン - 引数だけジェネリクスパターン + トレイトのメソッドだったら？ * 例えば`vec![foo(), bar()]`って書けるの？ === ``` rust fn foo(t: T) - impl Trait {t} fn bar() - impl Trait {123} fn equal_type(a: T, b: T) {} equal_type(bar(), bar()); // OK equal_type(foo::(0), foo::(0)); // OK equal_type(bar(), foo::(0)); // ERROR, `impl Trait {bar}` is not the same type as `impl Trait {foo}` equal_type(foo::(false), foo::(0)); // ERROR, `impl Trait {foo}` is not the same type as `impl Trait {foo}` // トレイトのメソッドには`impl Trait`は書けないらしい ``` === # 話さなかったこと ----------------- * 存在型のライフタイム * Rustのfeatureとリリーススケジュール + 存在型はまだリリース版には入っていない * 関連型と存在型の関係(なんか関係ありそう) === # まとめ -------- * 総称を表わすジェネリクスというのがあるよ * ジェネリクスの実装は2種類あるよ * 存在を表わす存在型というのがあるよ * 存在型の実装は2種類あるよ * 2種類の実装は言語機能や型システムに密着してるよ   ","categories":["型","ジェネリクス","Rust","言語実装"],"category_urls":["/categories/%e5%9e%8b","/categories/%e3%82%b8%e3%82%a7%e3%83%8d%e3%83%aa%e3%82%af%e3%82%b9","/categories/rust","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2017-06-17","title":"ジェネリクス ディスパッチ 表裏","url":"https://KeenS.github.io/slide/jienerikusu_disupatchi_omoteura/"},
  {"body":"κeenです。随分前から書こうと思いつつ先送りになっていた小ネタです。\n例えばカレントディレクトリにあるsome_file.txtに適当なデータを書き込もうとして、以下のようなコードを書いたとします。\nusestd::fs::File;usestd::io::prelude::*;usestd::io::BufWriter;fn main(){letfile=File::open(\u0026#34;some_file.txt\u0026#34;).unwrap();letmutw=BufWriter::new(file);// unwrapを呼んで書き込みエラーを検知 write!(w,\u0026#34;hello\u0026#34;).unwrap();} これを実行してみましょう。\n$rustcwrite_file.rs$./write_file 特段エラーは出ません。しかしながらsome_file.txtの中身は特に書き変わっていません。\n$catsome_file.txt$ これ、パッと原因分かりますか？\n直接の原因はFile::openです。File::openはリードオンリーでファイルを開くのでFile::openで開いたファイルに書き込もうとしても書き込めません（書き込みたいならFile::createを使います）。 じゃあなぜエラーが出ないかというとBufWriterのせいです。 書き込んだ文字列\u0026quot;hello\u0026quot;は短いのでwrite!を発効した時点ではまだデータはバッファに書き込まれるだけです。 このときにはまだエラーは出ません。 そしてmainの末尾でwのライフタイムが終わるときにBufWriteのdropが呼ばれますが、ここではエラーが無視されるのでユーザにはエラーが起きてないように見える訳です。\nこのような事故を防ぐために以下のようにflushを呼びましょう。\nusestd::fs::File;usestd::io::prelude::*;usestd::io::BufWriter;fn main(){letfile=File::open(\u0026#34;some_file.txt\u0026#34;).unwrap();letmutw=BufWriter::new(file);// unwrapを呼んで書き込みエラーを検知 write!(w,\u0026#34;hello\u0026#34;).unwrap();// flushを呼ぶことで書き込みエラーを全て拾える w.flush().unwrap();}$rustcwrite_file.rs$./write_filethread\u0026#39;main\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: Error{repr: Os{code: 9,message: \u0026#34;Bad file descriptor\u0026#34;}}\u0026#39;,/checkout/src/libcore/result.rs:859note: Runwith`RUST_BACKTRACE=1`forabacktrace. 参考: Rustといえどリソースの解放は注意 | κeenのHappy Hacκing Blog\n","categories":["Rust","小ネタ"],"category_urls":["/categories/rust","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2017-06-13","title":"Rustでエラーが出てないのにファイルに書き出せないときは","url":"https://KeenS.github.io/blog/2017/06/13/rustdeera_gadetenainonifairunikakidasenaitokiha/"},
  {"body":"κeenです。最近KeenS/transaction-rs: The transaction abstraction library and its executors for rustというライブラリをリリースしたのでそれについて。\nモチベーション Rustでドメインロジックを書いていると以下のようなコードが出てきました。 (実際はもうちょっと複雑ですが本質ではないので簡略化します)\nstruct GroupPgDao(r2d2::Pool\u0026lt;ConnectionManager\u0026lt;PgConnection\u0026gt;\u0026gt;);implGroupPgDao{fn get_conn(\u0026amp;self)-\u0026gt; \u0026amp;PgConnection{/*... */}fn delete_user(\u0026amp;self,user: \u0026amp;User,group: \u0026amp;Group)-\u0026gt; Result\u0026lt;()\u0026gt;{letcn=self.get_conn();//... }fn add_user(\u0026amp;self,user: \u0026amp;User,group: \u0026amp;Group)-\u0026gt; Result\u0026lt;()\u0026gt;{letcn=self.get_conn();//... }}traitGroupService: HaveGroupDao{fn change_group(\u0026amp;self,user: \u0026amp;User,from: \u0026amp;Group,to: \u0026amp;Group)-\u0026gt; Result\u0026lt;()\u0026gt;{letservice=self.group_dao();dao.delete_user(user,from)?;dao.add_user(user,to)}} このchange_groupはDBのトランザクション内で実行しないと困ります。delete_userが成功してadd_userが失敗するとuserがどちらにも所属しなくなるからです。じゃあchange_groupの中でトランザクションを作って実行すればいいかというとそうでもなく、いくつか問題があります。\n もっと外側でトランザクションが必要な操作が発生するかもしれない 同一トランザクション内で実行するにはコネクションを共有しないといけないが、関数個々でプールからコネクションを取得している  1に関しては誰がトランザクションを実行するのかという責任問題と、どの操作がトランザクションを必要とするのかという契約問題の2つが複合しています。 dieselのトランザクションはネストをサポートしているので必要そうな部分至るところトランザクションを作るというのも考えられますが、プログラマが目で責任と契約を追うことになりバグりかねません\n2つ目はインジェクションの問題ですね。これについてはシンプルに引数にコネクションを渡すというのも考えられますが持ち回るのは非常に大変です。\nこれらを解決するために作ったのが冒頭に挙げたtransaction-rsです。\ntransaction-rs transaction-rsは非常にfuture-rsに似ています。\npubtraitTransaction\u0026lt;Ctx\u0026gt;{type Item;type Err;fn run(\u0026amp;self,ctx: \u0026amp;mutCtx)-\u0026gt; Result\u0026lt;Self::Item,Self::Err\u0026gt;;fn map\u0026lt;F,B\u0026gt;(self,f: F)-\u0026gt; Map\u0026lt;Self,F\u0026gt;whereF: Fn(Self::Item)-\u0026gt; B,Self: Sized,{...}fn and_then\u0026lt;F,B\u0026gt;(self,f: F)-\u0026gt; AndThen\u0026lt;Self,F,B\u0026gt;whereB: Transaction\u0026lt;Ctx,Err=Self::Err\u0026gt;,F: Fn(Self::Item)-\u0026gt; B,Self: Sized,{...}fn map_err\u0026lt;F,B\u0026gt;(self,f: F)-\u0026gt; MapErr\u0026lt;Self,F\u0026gt;whereF: Fn(Self::Err)-\u0026gt; B,Self: Sized,{...}fn or_else\u0026lt;F,B\u0026gt;(self,f: F)-\u0026gt; OrElse\u0026lt;Self,F,B\u0026gt;whereB: Transaction\u0026lt;Ctx,Item=Self::Item\u0026gt;,F: Fn(Self::Err)-\u0026gt; B,Self: Sized,{...}// ... } mapやand_thenのある「よくあるパターン」です。futuresの他ResultやOptionにもありますね。 Transactionを作った時点ではまだ計算は実行されません。DBへのクエリも実行されてません。runが呼ばれた時点でようやく計算が実行され、結果を取り出すことができます。future-rsと同じくこれは ゼロコスト抽象化 をしていて、トランザクションの関数を積んでいくと実行時にはオートマトンにまで落ちます。 詳しくはこちらをどうぞZero-cost futures in Rust · Aaron Turon。\nトランザクションの合成と要求 話を冒頭のコードに戻しすと、transaction-rsを使うとDAOはこう書けるでしょう。\nstruct GroupPgDao;implGroupPgDao{fn delete_user(\u0026amp;self,user: \u0026amp;User,group: \u0026amp;Group)-\u0026gt; Box\u0026lt;Transaction\u0026lt;...()\u0026gt;{with_conn(|cn|{//... }).boxed()}fn add_user(\u0026amp;self,user: \u0026amp;User,group: \u0026amp;Group)-\u0026gt; Box\u0026lt;Transaction\u0026lt;...()\u0026gt;{with_conn(|cn|{//... }).boxed()}} 返り値の型がやや残念になるものの、中身はそれほど変わらないです。 Transactionを返しているのでこのコードはトランザクション下で実行されることを要求しているのが分かりますね。\nそして自分で持っていたコネクションプールとself.get_conn()が消え、変わりにwith_conn関数でコネクションを取得しています。この関数は付属のtransaction-dieselにて定義されています。何やら虚空からコネクションが沸いてるようにも見えますがちゃんと正規のルートで渡ってきています。これについては後で説明します。\nさらにサービスの方も書き換えてみます。\ntraitGroupService\u0026lt;Ctx\u0026gt;: HaveGroupDao\u0026lt;Ctx{fn change_group(\u0026amp;self,user: \u0026amp;User,from: \u0026amp;Group,to: \u0026amp;Group)-\u0026gt; Box\u0026lt;Transaction\u0026lt;Ctx,...()\u0026gt;\u0026gt;\u0026gt;{letservice=self.group_dao();dao.delete_user(user,from).and_then(move|()|dao.add_user(user,to)).boxed()}} 疑似コードなのでコンパイルが通るか分かりませんがまあ、こんなところになるでしょう。 このコードで分かるように、トランザクション同士の合成も可能なのです。 そして、Transactionを返しているのでこのコード自身もまたトランザクションを要求していることが分かります。\nさて、気付いたでしょうか。これで上記の契約問題、責任問題、インジェクション問題が解決しています。\n契約問題についてはTransactionを返す関数はトランザクションを要求するというシグナルですね。非常に分かりやすいです。 責任問題についてもTransactionをrunする関数にトランザクションの責任があります。runしないと結果を取り出せないので結果が欲しい人がそのまま責任を持つ形になります。\nなんとなく、unsafeに似ているのが分かりますか？unsafe fnは内部でアンセーフなことをやるし、呼び出す関数に契約を満たすことを要求します。unsafeブロックはアンセーフな処理の契約に責任を持ちます。同じくTransactionを返す関数は内部でトランザクションを要求する処理をするし、呼び出し側に契約を満たすことを要求します。runがトランザクションという契約に責任を持ちます。\nインジェクションの仕組み 先のコードでマジカルにコネクションが外からやってきていました。この仕組みについて説明します。とはいっても複雑ではないです。\nTransactionのコードを思い出してみましょう。\npubtraitTransaction\u0026lt;Ctx\u0026gt;{fn run(\u0026amp;self,ctx: \u0026amp;mutCtx)-\u0026gt; Result\u0026lt;Self::Item,Self::Err\u0026gt;;// ... } runすると結果が取り出せるのでした。そしてrunは引数Ctxをとります。 これは抽象的なトランザクションなので抽象的な「コンテキスト」ですが、STMならSTM、データベースならコネクションがコンテキストです。 コンテキストを受け取って計算を実行するということは、Transactionは見方を変えるとCtxを引数にとる関数になっています。\nなのでwith_conn関数はrunで受け取った引数を取り出しているだけです。\n小まとめ このtransaction-rsは\n トランザクションの契約と責任を型で表現している コネクションをインジェクトしている  さらに、runするまでは実際にはトランザクションは実行されていないので\n 「トランザクションを必要とする計算とその合成」と「トランザクションの実行」を分離している  というのが特徴です。大筋はこれがメインなのですが、実用の話をいくつか。\nつらい話と救いの話 Transactionで契約と責任は明確になりました。 では、便利になったかというとそうでもありません。例えばUserをCRUDしてみましょう。\nfn crud_user(dao: UserDao,ctx: Ctx)-\u0026gt; Result\u0026lt;()\u0026gt;{lettx=dao.create(\u0026#34;name\u0026#34;,24).and_then(move|id|dao.find(id).and_then(move|user|dao.update(None,user.age+1).and_then(move|()|dao.delete(user))));tx.run(ctx)} このように、and_thenがネストしてしまいます。コードが不要に複雑になっただけですね。つらい。\nしかしながら救いはあって、mdoというライブラリがあります。 mがなんなのかやdoがどこからきたのかは気にしてはいけません。 transaction-rsもこれをサポートしていて、マクロを使うことで以下のように書き換えられます。\nfn crud_user(dao: UserDao,ctx: Ctx)-\u0026gt; Result\u0026lt;()\u0026gt;{lettx=mdo!{id=\u0026lt;\u0026lt;dao.create(\u0026#34;name\u0026#34;,24);user=\u0026lt;\u0026lt;dao.find(id);()=\u0026lt;\u0026lt;dao.update(None,user.age+1);retdao.delete(user)};tx.run(ctx)} 本質的にはネストを代入っぽく書き換えただけですが、絶大な可読性の向上があります。 なので実際にtransactionを使うときはmdoを併用することになるでしょう。\nfuturesとの違い futuresに非常によく似ていると言いましたが、逆に何が違うのかという話です。大きな違いは2つあります。\n1つには結果を取り出すメソッドの違いです。Futureのpollは引数を取りませんが、Transactionのrunは取ります。また、それに合わせてトレイトがジェネリクスになっています。\npubtraitFuture{fn poll(\u0026amp;mutself)-\u0026gt; Poll\u0026lt;Self::Item,Self::Error\u0026gt;;}pubtraitTransaction\u0026lt;Ctx\u0026gt;{fn run(\u0026amp;self,ctx: \u0026amp;mutCtx)-\u0026gt; Result\u0026lt;Self::Item,Self::Err\u0026gt;;} もう1つはクロージャを取るメソッドの違いで、FutureはFnOnceを取るのに対してTransactionはFnを取ります。\npubtraitFuture{fn map\u0026lt;F,U\u0026gt;(self,f: F)-\u0026gt; Map\u0026lt;Self,F\u0026gt;whereF: FnOnce(Self::Item)-\u0026gt; U,Self: Sized,}pubtraitTransaction\u0026lt;Ctx\u0026gt;{fn map\u0026lt;F,B\u0026gt;(self,f: F)-\u0026gt; Map\u0026lt;Self,F\u0026gt;whereF: Fn(Self::Item)-\u0026gt; B,Self: Sized,} Futureは単純に計算の合成と実行を分離しているのに対してTransactionはSTMのように失敗した計算のリトライにまで責任を持つことがあるので再実行可能でないといけません。さらに、再実行するということは羃等性の確保も必要です。羃等性を保つためコンテキスト以外への副作用も禁止する必要があって、FnOnceでもFnMutでもなく FnOnceを Fn を要求します。（間違いを指摘されたので修正しました。）\n実はこのことが若干問題になるケースもあります。データベースのトランザクションなら別に再実行せずにロールバックするだけなのでFnOnceで十分なケースもあります。FnOnceの方が所有権に寛容なのでFnOnceなら書けるのにFnが要求されて、実際にはFnOnceしか必要ない、というケースに何度か直面しました。いくつかのハックで乗り越えられましたが本質的ではない問題なので今後何か変更があるかもしれません。\n他の問題点 ちょっと説明するのが面倒なのでコードを出さないのですが、計算の合成と実行を分離すると合成の時点では生きているけど実行するときに生きてるか分からないオブジェクトが出てきたりします。 概ねライフタイム境界を明示的に書いてあげると解決するのですが、一部joinなどを駆使してハックしないとコンパイルが通らないことがあり面倒です。\n返り値型が複雑なのも問題で、ひとまずimpl Traitがstableに降ってくるまではそもそも型を書けません（クロージャが匿名なせい）。 Boxに包むにしても少なくともCtxが型引数に増えますし、dieselと一緒に使うならコネクションのライフタイムも型に入れる必要があったりとResultやBoxFutureに比べてやや重くなっています。\n記法についても問題があります。mdoを使うとある程度は解決しますが、早期リターンがしづらく、頑張って分岐のネストを書かないといけません。これはfuturesも抱える問題です。 futuresについてはのジェネレータのパッチを当てることでResultのように書けるデモがあるのですが、先述の通りtransactionではFnOnceではなくFnを取っているのでジェネレータにはエンコードできないのではないかと思っています（あまり調査してないです）。\nまとめ  transaction-rsを作ったよ トランザクションの契約と責任を型で明示するよ コネクションをインジェクトするよ コードは複雑になるかもね mdoを使うと複雑さを抑えられるよ でもライフタイムとかの問題もあるよ 将来どうにかするかもね  零れ話 これを作ったあとに【ScalaMatsuriセッション当選御礼】ドワンゴ秘伝のトランザクションモナドを解説！ - Qiitaを思い出して読んでみたらほぼ同じものを作ってましたね。 Scalaのpoor-man\u0026rsquo;s type classだと読み辛いですがほぼ同じです。\n相違点は1つには返り値がResultかFutureか。実際、トランザクションモナドは成功と失敗両方に対してモナドになっている型であれば（こういうの名前ついてないのかな、重モナドとかそんなの）何にでも定義できます。要はトランスフォーマーとして定義可能です。 しかしながらRustには高階多相がなくてトランスフォーマーは書けないのでどちらかを選ぶ必要があり、transaction-rsではResultを選びました。外部ライブラリへの依存を減らしたいだとかウェブアプリケーションフレームワークにFutureを受け付けてくれるものがなくてあまり意味がないとかその辺です。 需要が発生したらトランスフォーマーマクロとか作るかもしれません。\nもう1つ相違点があって、fujitaskの方はRead/Writeを型で判別するようになっていますがtransaction-rsにはそういう機能はありません。 fujitaskを読み返すまではそれには思い至りませんでした。 で、存在を知った後に実装したかというと別にしてません。 RustでもCtxに幽霊型を付ければ実装自体は可能なのですがデータベースライブラリがトランザクションの分離レベルの変更をサポートしていないのであまり意味がないからです。 データベース側でサポートされたらやるかもしれません。\nScalaのfujitaskは便利そうで、概ねこちらもそのようなものなのですが、Rust特有の所有権/ライフタイムによる問題とScalaのfor式相当のものがないという理由でちょっとつらい感じになってます。つらい。\n追記 ノリでジェネリクスにしたけど関連型の方が良かったのでは？\n\u0026mdash; κeen (@blackenedgold) 2017年6月6日 \nひとまずmasterはそう書き直しました。\n","categories":["Rust","Transaction"],"category_urls":["/categories/rust","/categories/transaction"],"date":"2017-06-06","title":"Rustのトランザクション抽象化ライブラリ作った","url":"https://KeenS.github.io/blog/2017/06/06/rustnotoranzakushonchuushoukaraiburaritsukutta/"},
  {"body":"κeenです。最近同期/非同期、ブロッキング/ノンブロッキング、直接形式/継続渡し形式あたりが混乱してきたので個人的に整理します。 あくまで私個人の理解を纏めただけなので誤謬などに注意して下さい。\n追記: @tanaka_akrさんから指摘されたのですが、用語の説明が間違っていそうだったので書き直しました。 diffはこちら\n非同期とノンブロッキングはよく混同されます。また、非同期処理の記述形式として直接形式や継続渡し形式などがあります。 私自身違う言葉だなとは思いつつも混同したり違いを忘れたりしています。 非同期もノンブロッキングもナイーブなIOに比べると速い方式だな程度の理解でいてそんなに困らないと思ってますし混同や誤用に目くじらを立てるつもりもありません。 しかしながら3者を区別しないと意味を成さない文脈で3者を混同している技術を何度か見掛けたので（自分の中で）整理しようと思ったのがこの記事を書こうと思ったきっかけです。\n用語 色々と調べましたが、The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Editionの定義を使います。\n ブロッキング: IO操作で、操作する前に待ちが発生するという性質 ノンブロッキング: IO操作で、操作する前に待ちが発生しそうなら即座に関数から返るという性質 同期: IO操作で、操作が終わるまでブロックするという性質 非同期: IO操作で、IO操作を発効したスレッド自体がブロックせずに別のCPU処理を行えるという性質 IOの多重化: 複数のfdに対して監視を行ない、ブロックせずに操作可能なfdを通知する仕組み。 調べると「複数のfdに対してブロックできる」という記述があるのですがノンブロッキングなオプションもありますよね  これらはどのようにIOを行うかの問題で、 実行時 に関係する話題です。\n次に、直接形式と継続渡し形式について。非同期やノンブロッキングなIOをしようと思うと後続の処理、すなわち（限定）継続が必要になる。この（限定）継続をプログラマがどのように渡すかの問題。\n直接形式は（限定）継続がプログラムには陽には現れず、コンパイラが頑張るかコルーチンなどの言語機能、async/await、do、forなどの構文を用いて実現されます。 継続渡し形式(CPS)はプログラマが陽に（限定）継続を渡すスタイルで、コールバック形式などとも呼ばれます。\nこれらは主に言語の問題で、 コンパイル時 に関係する話題です。 よく直接形式と同期処理が混同されて「同期プログラミングをすることで非同期プログラミングができます」などの矛盾した一文が書かれがちですが区別しましょう。\n誰が何を IO処理の話題はスレッドとカーネルとのやりとりに関することが多い気がしますが、Goのようにユーザランドで実行単位を持つと「ブロックする」といったときにスレッドがブロックするのかgoroutineがブロックするのか分かりづらいですね。 なのでこれ以後は誰が何をブロックするのかを出来る限り明示しながら書きたいと思います。例えば「カーネルがgoroutine Aを実行しているスレッドをブロックする」など。\nScala 前職でScalaを書いていました。 ScalaのFutureそのものはflatMapが関数をとるので継続渡し形式ですが、そのシンタックスシュガーのfor式は直接形式でプログラミングができます。 IOの実体についてはFutureで抽象化されているのでexecutorによります。\nGo 前職の新卒研修で5日ほどGoを書いたことがあります。 多くの言語は比較的シンプルなIOモデルを持つので用語を意識しなくても問題ありませんが、Goは実行時に色々工夫しているので用語をちゃんと区別しないと齟齬が出るようです。 なのでGoを例に理解を深めようと思います。\nまず、Goは実行時に動作するコンポーネントが多いので整理します。 ここの質問への回答によるとgoroutine実行用のスレッド、スケジューラ、GCに大別してよさそうです。 このうち、IOに関連するのはgoroutine実行用のスレッドとスケジューラなのでGCについては触れません。 あまりよく分かってないのですがスケジューラはgoroutine実行用のスレッド上で呼ばれるための関数（群）なんですかね。\n普段は1スレッドが複数のgoroutineの実行を受け持ち、goroutineが何かしらの理由でブロックしそうなタイミングで別のgoroutineにコンテキストスイッチするようです。 ブロックしそうなタイミングというのはやや古いですがここに書かれてます。 直接形式で書きつつコンテキストスイッチをするということはどうにかして(限定)継続を取り出す必要がありますが、それこそgoroutineですね。goroutine自身でスタックを持つようですし。 C関数を呼ぶときなどはコンパイラが裏で呼び出す前と後に分割しているようです。\nさて、IOについてはファイルIOとネットワークIOで操作が異なるようです。\nファイルIOでは普通に同期/ブロッキングなシステムコールを発効し、OSがスレッドをブロックする時間が長いようなら別スレッドで元スレッドの持っていたgoroutineを実行するようです。 信頼できる情報が出てこなかったのですが自身で長くなりそうと思っているシステムコールの場合はgoroutineの実行権限（プロセス）を手放してあとは他のプロセスがstealするに任せてる？ ファイルIOは、スレッドがシステムコールでブロックし同期的で、goroutineもシステムコールでブロックし同期的です。ただスケジューラのお陰で他のgoroutineに迷惑がかからないだけです。\nネットワークIOはポーリングを行なうようです。 スケジューラがfinbrunnableする中でブロックしない方のpoll(Linuxだとepollにノンブロッキングオプションつけたやつかな？)を呼んで、操作可能なfdがあればそれを待っているgoroutineを起こしている模様。 であれば上の分類に従うとネットワークIOはスレッドはブロックせず同期的でIOを多重化し、goroutineはスケジューラからブロックされ同期的で（特別に関数を呼ばなければ）IOの多重化もしません。ただ、操作可能なfdに操作しているのでgoroutineはカーネルからはブロックされません。\nこの他にもgoroutine同士のコミュニケーションにチャネルがあります。そこまで重要じゃないかなと思って詳しく調べてないので間違いがあるかもしれないです。 チャネルへの操作は同期的ですね。チャネルへのread/writeはバッファがempty/fullだったらブロックするようなのでgoroutineはチャネルへの操作でブロックします。調べてないですが普通スレッドはブロックしないでしょう。\nチャネルへのselectはあまり情報が出てこなかったのですが恐らくスケジューラがIO可能なチャネルを調べて1つでもあればそれからランダムに選ぶ、1つもなくdefaultもなければスケジューラがgoroutineをブロックするんだと思います。 同期的でIOの多重化をしていますね。\nGoroutineやスレッドレベルでは同期的ですが、Goのプロセス全体でみるとGOMAXPROC分のスレッドは常にCPUを使っているので非同期なんですかね。\nまとめ Goの件について表にするとこうですかね。非同期処理をやろうと思ったら大抵処理単位を分ける必要がありますが、Goの最小処理単位がgoroutineなのでよく考えたらgoroutineが全て同期するのはあたりまえですね。\n    スレッド goroutine Goプロセス     ファイル ブロック/同期/ ブロック/同期/ 非同期   ネットワーク ノンブロック/同期/多重化 ノンブロック/同期/ 非同期   チャネルRW - ブロック/同期/ -   チャネルselect - ブロック/同期/多重化 -    ということでGoのIOについては「goroutineを直接形式で同期的な書き方をしても裏でスケジューラが動いているからCPUを効率的に使えてGoプロセス全体でみれば非同期」になるんですかね。\nGoに詳しい人、コメントや誤り訂正お願いします。GitHubのイシューとか使えば良い気がします。\n参考  multithreading - Golang blocking and non blocking - Stack Overflow src/os/file_unix.go - The Go Programming Language src/runtime/proc.go - The Go Programming Language Frequently Asked Questions (FAQ) - The Go Programming Language channel - go routine blocking the others one - Stack Overflow src/runtime/cgocall.go - The Go Programming Language select - How does channel blocking work in Go? - Stack Overflow The Go Programming Language Specification - The Go Programming Language How does the Go runtime work? - Quora ","categories":["非同期","Go"],"category_urls":["/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f","/categories/go"],"date":"2017-05-19","title":"非同期とノンブロッキングとあと何か","url":"https://KeenS.github.io/blog/2017/05/19/hidoukitononburokkingutoatonanika/"},
  {"body":"κeenです。 GoFのデザインパターンは有名ですが、言語機能によっては単純化できたりあるいは不要だったりするのでRust風に書き換えたらどうなるか試してみます。\n発端はこのツイート。\nデザインパターン、古いJavaの機能の足りなさのワークアラウンド的なテクニックも含まれてるからあまり宜しくないんだよね。enumやクロージャで十分なのもいくつかある。\nRustで写経、デザインパターン23種 - Qiitahttps://t.co/MhpS3Z2OlF\n\u0026mdash; κeen (@blackenedgold) 2017年5月5日 \n一応誤解のないように説明しておくと、該当のQiitaの記事に不満がある訳ではなくてGoFのデザインパターンついての言及です。\nリンク先のコードで十分な時にはここでは流すのでリンク先も同時に参照下さい。 また、比較しやすいようにサンプルコードはリンク先のものに則って書きます。\n一応デザインパターンの教科書として結城先生の本を参照しつつ書いていきます。\nCommand パターン 列挙型を使うところです。 Javaにまともなenumがないのでクラスが使われていますが、列挙型があるならそちらの方がデータとコードの分離ができて見通しがいいです。また、コマンドが1つの型に収まるのでトレイトオブジェクトを作る必要がなくなります。\n比較的マイナーな変更です。\nLispだとクロージャで解決したりしますが、Rustだと列挙型の方がしっくりくるかなと思います。\ntraitCommand\u0026lt;T\u0026gt;{fn execute(\u0026amp;self,\u0026amp;mutT);fn undo(\u0026amp;self,\u0026amp;mutT);}struct Invoker\u0026lt;\u0026#39;a,Cmd,T: \u0026#39;a\u0026gt;{commands: Vec\u0026lt;Cmd\u0026gt;,target: \u0026amp;\u0026#39;a mutT,current_index: usize,}impl\u0026lt;\u0026#39;a,Cmd,T\u0026gt;Invoker\u0026lt;\u0026#39;a,Cmd,T\u0026gt;{fn new(t: \u0026amp;\u0026#39;a mutT)-\u0026gt; Self{Invoker{commands: Vec::new(),target: t,current_index: 0,}}fn target(\u0026amp;self)-\u0026gt; \u0026amp;T{self.target}fn append_command(\u0026amp;mutself,c: Cmd){self.commands.push(c);}}impl\u0026lt;\u0026#39;a,Cmd,T\u0026gt;Invoker\u0026lt;\u0026#39;a,Cmd,T\u0026gt;whereCmd: Command\u0026lt;T\u0026gt;{fn execute_command(\u0026amp;mutself){ifself.commands.len()\u0026lt;=self.current_index{// Nothing to do. return;}letc=\u0026amp;self.commands[self.current_index];lett=\u0026amp;mut*self.target;c.execute(t);self.current_index+=1;}fn execute_all_commands(\u0026amp;mutself){for_inself.current_index..self.commands.len(){self.execute_command();}}fn undo(\u0026amp;mutself){if0==self.current_index{return;}self.current_index-=1;letc=\u0026amp;self.commands[self.current_index];lett=\u0026amp;mut*self.target;c.undo(t);}}#[derive(Debug, Eq, PartialEq)]struct Robot{x: i32,y: i32,dx: i32,dy: i32,}implRobot{fn new()-\u0026gt; Robot{Robot{x: 0,y: 0,dx: 0,dy: 1,}}fn move_forward(\u0026amp;mutself){self.x+=self.dx;self.y+=self.dy;}fn set_direction(\u0026amp;mutself,d: (i32,i32)){self.dx=d.0;self.dy=d.1;}fn get_direction(\u0026amp;self)-\u0026gt; (i32,i32){(self.dx,self.dy)}}enum RoboCommand{MoveForward,TurnRight,TurnLeft,}implCommand\u0026lt;Robot\u0026gt;forRoboCommand{fn execute(\u0026amp;self,r: \u0026amp;mutRobot){useRoboCommand::*;match*self{MoveForward=\u0026gt;r.move_forward(),TurnRight=\u0026gt;{let(dx,dy)=r.get_direction();r.set_direction((dy,-dx))}TurnLeft=\u0026gt;{let(dx,dy)=r.get_direction();r.set_direction((-dy,dx));}}}fn undo(\u0026amp;self,r: \u0026amp;mutRobot){useRoboCommand::*;match*self{MoveForward=\u0026gt;{letc1=TurnRight;c1.execute(r);c1.execute(r);self.execute(r);c1.execute(r);c1.execute(r);}TurnRight=\u0026gt;{letc=TurnLeft;c.execute(r);}TurnLeft=\u0026gt;{letc=TurnRight;c.execute(r);}}}}fn main(){letmutr=Robot::new();letmutinvoker=Invoker::new(\u0026amp;mutr);assert_eq!(*invoker.target(),Robot{x: 0,y: 0,dx: 0,dy: 1,});{useRoboCommand::*;invoker.append_command(TurnRight);invoker.append_command(TurnLeft);invoker.append_command(MoveForward);}invoker.execute_all_commands();assert_eq!(*invoker.target(),Robot{x: 0,y: 1,dx: 0,dy: 1,});invoker.undo();assert_eq!(*invoker.target(),Robot{x: 0,y: 0,dx: 0,dy: 1,});invoker.undo();assert_eq!(*invoker.target(),Robot{x: 0,y: 0,dx: 1,dy: 0,});} Stateパターン 参照先のままです。トレイトオブジェクトを使う代表的なケースだと思います。。 あるいは列挙型を使う可能性もあります。\nStrategyパターン 参照先でも説明されていますが、Rustにはクロージャがあるので不要です。\nTemplate Methodパターン そもそもトレイトを使った普通のプログラミングなのでRustでわざわざ名前をつけるほどかな？と個人的には思いますがあえて書くなら参照先のままです。 あるいはものによっては高階関数でも。\n個人的にはトレイトオブジェクトを作るより関連型を使った方が好みです。\ntraitAbstractFactory\u0026lt;\u0026#39;a\u0026gt;{type ProdX: ProductX;type ProdY: ProductY;fn create_product_x(\u0026amp;self)-\u0026gt; Box\u0026lt;ProdX+\u0026#39;a\u0026gt;;fn create_product_y(\u0026amp;self)-\u0026gt; Box\u0026lt;ProdY+\u0026#39;a\u0026gt;;}// ...  Mementoパターン 参照先のままです\nObserverパターン 参照先のままです\nVisitorパターン 参照先では簡単な例なので分かりづらいのですが、列挙型を使うところです。 まともな列挙型がない+シングルディスパッチしかなく引数はオーバーロードという二重苦によって生まれたパターンであり、まともな列挙型か多重ディスパッチがあれば複雑怪奇なプログラムは書かなくて済みます。\nここでは参照先とは違ってもう少し複雑な例を出します。\ntraitVisitor\u0026lt;T\u0026gt;{fn visit(\u0026amp;mutself,\u0026amp;T);}enum Entity{File(String),Dir(String,Vec\u0026lt;Entity\u0026gt;),}struct ConcreteFileVisitor;implVisitor\u0026lt;Entity\u0026gt;forConcreteFileVisitor{fn visit(\u0026amp;mutself,e: \u0026amp;Entity){useEntity::*;match*e{File(refname)=\u0026gt;println!(\u0026#34;file: {}\u0026#34;,name),Dir(refname,reffiles)=\u0026gt;{println!(\u0026#34;dir: {}\u0026#34;,name);forfileinfiles{self.visit(file)}}}}}fn main(){useEntity::*;lete=Dir(\u0026#34;/\u0026#34;.to_string(),vec![File(\u0026#34;etc\u0026#34;.to_string()),File(\u0026#34;usr\u0026#34;.to_string())]);letmutvisitor=ConcreteFileVisitor;visitor.visit(\u0026amp;e);} 特段パターンというほどの処理をしている感じがしませんね。\nIteratorパターン 参照先のままです。\nMediatorパターン だいたい参照先のままです。複雑なことをしようと思うとColleagueが複数種類出てきて列挙型かトレイトオブジェクトが必要になりそうな気がします。\nInterpreterパターン 略\nBuilderパターン あまりここまで抽象化してるのは見たことありませんがやるとしたら参照先のままです。 そもそもRustには継承がないので抽象化する意義があまりなく、型固有のBuilderパターンで十分です。\nPrototypeパターン 参照先のままです。\nFactoryパターン クロージャで十分です。\ntraitProduct{fn convert(\u0026amp;self,String)-\u0026gt; String;}struct Factory;implFactory{fn convert\u0026lt;P,F\u0026gt;(\u0026amp;self,s: String,create_product: F)-\u0026gt; String whereP: Product,F: FnOnce()-\u0026gt; P{create_product().convert(s)}}struct ConcreteProductX;implProductforConcreteProductX{fn convert(\u0026amp;self,s: String)-\u0026gt; String {s.to_uppercase()}}fn main(){letf=Factory;println!(\u0026#34;{}\u0026#34;,f.convert(\u0026#34;hogehoge piyopiyo\u0026#34;.to_string(),||ConcreteProductX))} AbstractFactoryパターン そもそもここまでやる？というのは置いといてやるとしたら参照先のままかなぁと思います。\nTemplateMethodパターンでも述べた通り個人的には関連型を使う方が好みです。\nChain of Responsibility/CoR パターン 参照先のままです。\nSingletonパターン そもそもアンチパターンです。分かりづらいグローバル変数なだけです。あえてRustでやるとしたらlazy_staticかなと思います。\nAdapterパターン これは捉え方が2種類あるかなーと思います。。\n1つにはクラスの定義時にしかインターフェースを実装できない窮屈な言語仕様へのワークアラウンドとして。 この捉え方では参照先のコードようにただトレイトを実装してしまえば終わりです。\nもう1つにはラッパーオブジェクトとして。std::fs::Fileの実装とかがそれっぽいと思います。。\npubstruct File{inner: fs_imp::File,} Bridgeパターン そもそも機能の追加とAPIの抽象化をどちらも継承に押し込める言語仕様が悪い。 それにRustでは継承しないので関係ないです。\nProxyパターン 参照先のままです。\nFacadeパターン 参照先のままです。Rustにはモジュールや可視性の制御があって特別意識することなく普段からやっていることなのであまり名前をつけるほどのことではないと思ってます。\nFlyweightパターン 所有権があるのでRustだとちょっと難しいパターンです。 参照だけなら参照先のようにHashMapにいれるか、オブジェクトを区別しないならVecにいれるかなと思います。\n因みにLispとかではinternという名前で呼ばれてると思います。\nCompositeパターン ただの列挙型の再実装です。\nDecoratorパターン よくあるやつです。参照先のコードの他、std::io::WriteBufのようなものが代表的です。\nおわりに デザインパターンをdisろうと思って書いたのですが案外多くのケースで便利でした。Rustで不要なものは10本指で数えられる程度でしたね。すごい。\n因みにLisperでAIの研究者（確か今GoogleのAI研究所の所長）のPeter NorvigはDesign Patterns in Dynamic Languagesで16個はLispの機能を使えばパターンという程のものではなくなると言ってます。 それぞれどの機能でどれが不要になるかを解説しているのですが、Rustは高階関数とモジュールの分に加えて列挙型の分で不要になってるかなと思います。\n","categories":["Rust","デザインパターン"],"category_urls":["/categories/rust","/categories/%e3%83%87%e3%82%b6%e3%82%a4%e3%83%b3%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3"],"date":"2017-05-06","title":"Rust風にデザインパターン23種","url":"https://KeenS.github.io/blog/2017/05/06/rustkazenidezainpata_n23tane/"},
  {"body":"κeenです。 今回の話は別にRustに限ったものではないのですが、よくRustを始めたばかりの人がスタックとヒープが分からないと言っているのをみかけるので少しメモリの話をしますね。 厳密な話というよりは雰囲気を掴んで欲しいという感じです。\nメモリは配列 プログラム（プロセス）のメモリには実行するプログラム（機械語）やグローバル変数/定数、関数の引数やローカル変数、その他プログラムで使うデータ領域などを置きます。 プロセスに割り当てられるメモリというのは、1つの巨大なのっぺらな配列みたいなものです。サイズも決まってます。64bit OSなら2^64 byteです。\n0 2^64 +--------------- ----+ | | | | | ~~ | | +--------------- ----+ これは仮想的なメモリなので実際の物理メモリに2^64 byteの配列がドンと確保される訳ではなくて、使った(使いたい)分だけ占有します。OSが賢いですね。\nただまあこれだけだと使いづらいのである程度区切って「この辺にこれ系のデータを置く」みたいな使われ方をします。 プログラムを置く text領域 、初期化されたグローバル変数を置く data領域 、初期化されていない（データ領域だけ確保された）グローバル変数を置く bss領域 、関数の引数やローカル変数を置く stack領域 、プログラムのデータを置く heap領域 です。 グローバル変数って言っちゃいましたけど実はそれに限らなくて、例えばRustの文字列リテラルなんかもdata領域に置かれます。\ntext、 data、 bssは実行する前からサイズが分かっているので問題ないのですが、heapとstackはプログラムの実行中にサイズが変わるものなのでどこにどう置いたら上手く配分できるか分かりませんね。 そこで以下のようにstackとheapを両端に配置して使いたい分だけ使用領域を伸ばせるようになってます。\n// 簡略化するために嘘ついてたりしますがまあ、だいたい合ってます +-------+ 2^64 | stack | | | | | V | | | | ^ | | | | | heap | +-------+ | bss | +-------+ | data | +-------+ | text | +-------+ 0 text、data、bssはそのままなのでstackとヒープについて話します。\nStackと関数 Stackは関数呼び出しのために使われます。 ネストした関数の呼び出しの系譜を関数の「コールスタック」と呼んだりするように、関数呼び出しはスタック構造になってますね。 なのでスタックを用いて管理すると具合が良いのです。\n+--------+ | func 1 | +--------+ | func 2 | +--------+ | func 3 | +--------+ | func 4 | さて、折角特別に用意したこのstackにはただの関数の呼び出し履歴だけではなく他のデータも入れたいですよね？ 例えば関数ローカルな変数だとか。データの次にまた別のデータが置かれるのでサイズを変えたりはできませんが。\n+--------+ | func 1 | |--------| | data 1 | |--------| | data 2 | +--------+ | func 2 | |--------| | data | | ... | +--------+ | func 3 | |--------| | data | | ... | +--------+ | func 4 | |--------| | data | | ... | データの解放は簡単です。スタックを巻き戻せば自動的に消えます。\n+--------+ | func 1 | |--------| | data 1 | |--------| | data 2 | +--------+ | func 2 | |--------| | data | | ... | +--------+ | | | | | | | | | | | | | | 逆にいうと関数から抜けたら消えてしまうということでもありますが。\nという訳で、 「条件が限られるけど高速に扱えるデータ領域」がstackです。\n因みに、メモリは使った分だけしか確保されないと言いましたが、スタックを伸ばしすぎると確保されていない領域に到達してエラーが出ます。スタックオーバーフローです。\nHeapとデータ heapにはstackに置けないデータが置かれます。 これの扱いは少し面倒です。何故ならデータの確保や解放の順番がバラバラなので、歯抜けな状態になってしまうからです。\n| | | data 4 | +--------+ | data 3 | +--------+ | | +--------+ | data 1 | +--------+ そこで「どかが使われていてどこが空いているか」を管理するシステムを導入します。 C言語ではmallocという関数をインターフェースとして管理しているので管理システム自体もmallocと呼ぶことが多いようです。 この実装方法はフリーリストを使った単純なものからサイズ毎のバケツを用意して〜といった方法まで様々にあるので気になる人は調べてみて下さい。 大抵、「メモリがこのくらい欲しい」と言われたら今管理している中からそれっぽい空きを捜してそこを渡してあげるような作りになっています。\nちなみにこの領域管理には(mallocの場合)そこそこのコストが掛かります。でもその代わり自由に確保/解放できる他、サイズの変更もできるので自由度が高いです。\nという訳で「自由度が高いが少しコストがかかるデータ領域」がheapです。\nプログラミング言語とメモリ では、具体的な言語がどのようにメモリを使っているかを簡単に紹介します。\n1つ注意しないといけないのが、ガーベジコレクション（GC）のある言語ではheapの上に構築した自前のメモリ管理システムのことをヒープと呼んでいたりするので両者をちゃんと区別しましょう。 同じく、スタックの使い方も言語独自でコールスタックと引数のスタックを分けたりもするので気をつけましょう。\nC言語 先程説明したとおり、データ領域にheapを、関数呼び出しや関数ローカルなデータにstackを使っています。\nメモリの領域管理は先述のmalloc, freeなどをプログラマが手で書きます。手で管理するのでバグります。\nRuby データ領域にはheapにmallocで確保した領域にヒープを確保し、その上にメモリ管理システム(GC)を構築して管理しています。\n関数呼び出しにはstackではなくheapに確保した自前のスタックを用意しています。 stackを使わないのはどうしてもC言語がstackを使うのでRubyも交ぜて使ってしまうと(Ruby自体C言語の上で動いていますね)問題が起こるだとかデータ構造として扱いづらいだとかGCとの兼ね合いだとかの理由だと思います。 また、そもそもRubyのメソッドとC言語の関数は別物という話もあります。\nまた、実行用にスタックはありますが、データの実体はRubyのヒープに置かれます。Rubyのプログラムから高速なスタック領域を使うことができないのです。残念ですね。\nメモリの領域管理にはGCシステムを採用し、メモリ管理をユーザがすることはありません。 GCはmallocに少しデータを足したようなMark and Sweepです。メモリ確保はほぼmallocと同じで、気が向いたときに使っているデータにマークを付けていって、マークの付いていないデータを一括でfreeしてくれます。 メモリ確保（やポインタの扱い）がmallocに似ているのでC言語と協調するときに楽です。RubyはNative Extentionが作りやすいように設計されていますね。\n1つ注意しておくと、Rubyを実行するときにもメモリにtextやbss、dataなどの領域がありますが、それは「Rubyを実行するVMのための領域」であって「実行しているRubyスクリプトのための領域」ではありません。\nPythonやPHP Rubyと同じようにヒープもスタックもheapに確保していると思います（面倒なのでソースを追っていない）。 メモリ管理システムはGCを使いますが、Rubyとは違って参照カウント方式を採用しています。\n参照カウントは、メモリ確保はmallocに似ていますが、確保した後の扱いが異なります。 値を参照する度にカウントを増やし、使わなくなったら参照を減らし、参照が0になったらfreeされます。 言語レベルでは意識するすることはありませんが、C言語のレイヤーでは一々参照の操作をしてあげないといけないので手間がかかります（たまに扱いを間違ってバグります）。 また、循環参照という問題もあって、たまに解放されないメモリがあったりします。（そのために結局たまにMark and Sweepのようなものが必要だったりします）\nJava Rubyと同じようにヒープもスタックもheapに確保しています(JVMのメモリについて調べてみると色々出てきます)。 30億のデバイスで走らせるための工夫ですね。\n同じくGCを使いますが、今度はCopy GC方式を採用しています（厳密にいうとHotSpot VMでの複数種類ある方式のうちの1つですが）。 Copy GCは面白くて、ヒープを2つに分割します。同時に使うのは1つだけです。メモリを確保するときは、使われていない領域などは無視して新たなスペースを確保します。 これはわざわざ空き領域を捜す必要がないので非常に高速です。\n+---------------------------------+ | data1 | data 2 | data 3 | -\u0026gt; | +---------------------------------+ +---------------------------------+ | | +---------------------------------+ そしてメモリが一杯になったら使っているデータだけもう1つの領域にコピーします。このとき、使っていなかった分は詰めます。\n+---------------------------------+ | | data 2 | | +---------------------------------+ +---------------------------------+ | data1 | data 3 | -\u0026gt; | +---------------------------------+ 使っていなかったdata 2の存在を忘れて、2つを入れ替えたらメモリの回収完了です。\n+---------------------------------+ | data1 | data 3 | -\u0026gt; | +---------------------------------+ +---------------------------------+ | | +---------------------------------+ ヒープが半分しか使えないだとかデータが移動してしまうので扱いが難しいだとかの問題はあるのですが、確保が非常に高速で解放もかなり速い方式です。\nこの方式はJavaの他にOCamlやHaskellなどの関数型言語でよく使われます。 データを頻繁にアロケートするのでメモリ確保が高速なこの方式が好まれるようです。\nRust RustはC言語と同じくデータ領域にheapを、関数呼び出しや関数ローカルなデータにstackを使っています。\nメモリの領域管理はmalloc, freeなどをコンパイラが自動で発効してくれます。なのでプログラマが自分で管理する必要はありません。\n高速なメモリの使い方 まず、一番速い方法は「そもそもメモリを確保しない」です。 これはコストが掛からないので高速です。 「何をふざけたことを」と思うかもしれませんが、プログラミングする上で「余計に確保しない」を意識するという意味で重要です。\n次はstackを使うと高速です。これはそもそもstackを意識して使える言語でないと選べない方法ですね。\n最後の手段としてheapを使います。\nGCのある言語ではGCの特性によってヒープの使い方も考える必要があります。 Mark and Sweepは生死に関らず確保したオブジェクトの数に比例してメモリ解放コストが掛かりますが、Copy GCでは生きているオブジェクトに比例してコストが掛かりますので、生きているオブジェクトを減らすと速くなります。 例えば使わないけど変数に束縛されているものがあるなら変数のスコープを狭めるだとか変数にnullを代入するだとか。 よほどメモリのせいで遅くなっていない限りあまりやりませんが（ゲームの人はよくやるらしい？）。\nまた、最近の多くのGC（RubyもJavaも）には世代別GCといって、新しいデータと古いデータを分けて管理する方式が採用されているので作ったデータをすぐさま使ってすぐさま不要にすると速くなったりします。 例えばデータ列に対して個々のデータに処理1、2、3を適用したいなら処理1のループ、2のループ、3のループ、とするよりもループの中で処理1、2、3と適用した方が速くなります。 最近Scalaの次期コンパイラが高速化のためにそのような構成（phase fusioning）にしたらしいですね。 使っている言語でOld領域、New領域などの単語を聞いたことがあるなら多分世代別GCが使われています。\nまとめ スタックとヒープの話、そしてなぜスタックとヒープを意識したいかを説明しました。 ついでに、比較のためにGCのある言語についても少しだけ紹介しました。 けっこうふわふわとした説明なので「分かった気分」になりたいだけならこの記事で十分かと思いますが、もう少し踏み込んだことが知りたければ個別に調べてみて下さい。 また、メモリレイアウトについてはおおまかには合っているものの、結構嘘ついているのであまり鵜呑みにしないで下さい。\n参考  仮想メモリ空間のメモリマップを調べる - th0x4c 備忘録。 malloc(3)のメモリ管理構造 | VA Linux Systems Japan株式会社。 rubyのメモリ確保にmallocを使っている部分。 rubyのスタックの定義部分。これは引数スタックかな？コールスタックどこだろう… ","categories":["メモリ管理","Stack","Heap"],"category_urls":["/categories/%e3%83%a1%e3%83%a2%e3%83%aa%e7%ae%a1%e7%90%86","/categories/stack","/categories/heap"],"date":"2017-04-30","title":"メモリとスタックとヒープとプログラミング言語","url":"https://KeenS.github.io/blog/2017/04/30/memoritosutakkutohi_puto/"},
  {"body":"κeenです。最近Cargoのreplace機能を使おうとしてハマったのでメモを残しておきます。\n最近何箇所かで喋ったのでご存知の方もいらっしゃるかと思いますが、Cargoにはワークスペース機能があります。 fat repositoryスタイルに便利な機能で、1つのディレクトリ下に複数のサブプロジェクトを配置しつつtarget/は共有するのでマイクロプロジェクトのモジュール性とモノリシックプロジェクトのコンパイルの速さを実現することが出来ます。\nさて、問題になるのはクレートを公開するときの依存関係の記述です。 サブプロジェクト同士で依存し合っているのでCargo.tomlにはmy-project-lib = {path = \u0026quot;../my-project-lib\u0026quot;} のような依存の記述がある筈です。 しかしながらローカルのクレートに依存しているとcrates.ioに公開は出来ません。 そこで今回はそれをどうにかするお話。\nreplace Cargoにはreplaceという機能があります。 特定のライブラリの特定のバージョンを、crates.ioにあるものではなくてユーザが指定した場所にあるものを使うように指示します。 Specifying Dependenciesのドキュメントによると、以下のように使えます。\n例えばuuidクレートを使っているときにそれが依存しているrandクレートにバグを見付けて修正し、修正した結果を試したいとします。 その時にreplaceは以下のように使えます。\n# ワークスペースの親プロジェクト ... [replace] \u0026#34;rand:0.3.14\u0026#34; = { path = \u0026#34;./rand\u0026#34; }# ワークスペースの子プロジェクト [package] name = \u0026#34;my-awesome-crate\u0026#34; version = \u0026#34;0.2.0\u0026#34; authors = [\u0026#34;The Rust Project Developers\u0026#34;] [dependencies] uuid = \u0026#34;0.2\u0026#34; 間接的に依存してるrand:0.3.14を、crates.ioにあるものではなく指定したパスにあるものを使うように指示しています。\nこの仕組みを使って先のローカルパス問題を解決出来ないでしょうか。すなわち、\n# 子プロジェクト [dependencies] my-project-lib = \u0026#34;0.1.0\u0026#34; のように、見た目上はcrates.ioにあるものに依存しておきつつ実際は\n# 親プロジェクト [replace] \u0026#34;my-project-lib:0.1.0\u0026#34; = { path = \u0026#34;./my-project-lib\u0026#34; } のように実際の依存先をローカルのパスに向ければ問題を解決できないでしょうか。\nこの答えは、半分no、半分yesになります。\nreplaceはあくまでcrates.ioにあるものを置き換えるのでまだ公開していないプロジェクトに対しては使えません。 一方、一度crates.ioに公開してしまえば上記のテクニックは可能になります。\nなので一番最初にcrates.ioに公開する時の手順はやや煩雑になります。\n (ローカルサブプロジェクトへの依存の記述はpath = \u0026quot;...\u0026quot;のまま) どのプロジェクトにも依存しないローカルサブプロジェクトを公開する 既に公開されたローカルサブプロジェクトへの依存は順次replaceに書き換える ローカルパスへの依存のなくなったローカルプロジェクトから順に公開していく 全てのサブプロジェクトのローカルサブプロジェクトへの依存がreplaceに置き換わったら以後はそのまま使える。  このようなテクニックは例えばdieselなどで使われています。 この辺、改善あるといいですね。\n","categories":["Rust","Cargo"],"category_urls":["/categories/rust","/categories/cargo"],"date":"2017-04-05","title":"Cargoのサブプロジェクトとreplace","url":"https://KeenS.github.io/blog/2017/04/05/cargonosabupurojiekutotoreplace/"},
  {"body":"C++からRustに入った人あたりから「関数型言語から来た人のRustの感想を知りたい」とたまに言われるのでいつかブログ書こうか。\n\u0026mdash; κeen (@blackenedgold) 2017年4月3日 \nイントロ 私はRustをやる前にはCommon LispやSMLを主に使っていましたが、仕事ではScalaを使っていましたし他にもOCamlやSchemeやClojureやATS2やHaskellなどを書くこともありました。\n私を含めた多くの関数型言語経験者人が一度は Rust for functional programmers を読んだことがあるかと思います。 このように関数型言語と比較して書かれるといかにも似た言語に見えるので私は興味を持ちました。そこで私は実際にRustに触れ始めたのです。\n構文 let があるのでおよそOCamlなどに似ているという印象を受けました。 デフォルトでイミュータブルですしパターンマッチやシャドイングなもどするのでまさにMLのletそのものです。 行末にセミコロンが要求されますが、inの代わりだと思うことにして自分をなだめました。 式指向でreturnを書かなくて済むのも関数型言語らしさを感じました。\n関数定義の構文は手続型言語風ですが手続き型言語に馴れた人に寄り添うために必要なんだと思って深くは気にしないことにしました。\n一方、ジェネリクスの構文については憤りすら感じました。 どうして \u0026lt;\u0026gt; を採用したのか、そもそも比較演算子の \u0026lt;, \u0026gt;と紛らわしい上に\u0026lt;\u0026lt;の扱いでも困ることは目に見えていました。 私はML風に前置、あるいは少なくともHaskellのように関数と引数のように書くべきだと思いましたし、少なくともScalaのように型と値でカッコを分けるくらいはできるはずです。 しかしながら、不平を言っても始まらないので我慢して次に進むことにしました。\n言語機能 トレイト、タプル、代数的データ型とマッチ式、高階関数、型推論。 これらは明らかに関数型言語から輸入されたものです。 これはとても喜ばしいことです、なぜなら今までしていた通りのプログラミングを新しい言語でもできるからです！ 関数の引数と返り値に型宣言が必要なのはMLプログラマとしては少し残念でしたがHaskellやIdrisも同じようなスタイルなのでそういうものと自分で納得しました。 そして私はさっそく、倉庫番のゲームを作り始めました。あの、十分にシンプルで、コンソールで動かせて、楽しいゲームです。\nしかしすぐにそううまい話はないと気付きます。 再帰的データ型を定義するとすぐにエラーになりますし（Boxが必要と気付くまでしばらくかかりました）、ハッシュテーブルを使うとすぐミュータブルが必要になります（ハッシュテーブルの操作が破壊的ということをすっかり忘れていました）。 そして何より所有権のせいで思うようにプログラムが書けませんでした。 関数型プログラミングではメモリは無尽蔵にあると思ってプログラミングするのでRustのパラダイムとはとてつもない隔りがありました。 最初は、所有権についてはCleanやGHCにある一意型、あるいはATS2の線形型のようなものだと思えばそう難しくないと踏んでいましたが、実際のところ何もかも思い通りにいきませんでした。 プログラム全てで所有権を意識するのが思いの外難しかったのです。 それでもコンパイル時にコードの安全性を検査出来るのは喜ばしいことだと思って、\u0026rdquo;ボローチェッカとの戦い\u0026rdquo;を数日続けました。\n\u0026ldquo;ボローチェッカとの戦い\u0026rdquo;をしばらく続けて気付いたのは、コンパイラは理不尽な理由で怒ったりしていないということでした。 関数型言語ではデータほとんどイミュータブルなのでデータをコピーしたいのか参照したいのかあまり区別する必要がありませんでしたがRustでは厳密に区別しているだけのことでした。 むしろ、所有権の概念は、一度コンパイラの気持ちを理解してしまえば所有権や参照を意識せずにプログラミングするのが気持ち悪いとさえ感じるほどに自然でした。\nそれ以外の点ではトレイトや導出はMLプログラマからすると羨望の的でしたし（余談ですがRustの導出は昔はHaskell風に#[deriving(Show)]と書いていましたが、いつからか#[derive(Debug)]と書くようになったようです。）、 オブジェクト指向についても上手くやっていると感じました（関数型プログラミング言語でもオブジェクト指向はします！）。\nLispプログラマから一言あるとすれば、マクロです。RustのマクロはSchemeのsyntax-rules相当の機能しかなく、Common Lispプログラマの私にはもの足りませんでした。 macro_rulesでも無いよりはましですし、C言語のマクロよりは素晴らしいものです。 それでもどうしても伝統的なマクロが欲しくなりますが、不安定なコンパイラプラグインの機能しか選択肢がありません（訳注: 現在のRustにはproc_macroが入ったので伝統的なマクロも書けます）。\nツール 私の好きなEmacsのサポートはしっかりしていましたし、大きな不満はありませんでした。 REPLこそありませんがむしろSMLに比べると補完や定義ジャンプなどリッチな機能さえありました。\nそれよりも、ビルドツールについてです。 Rustは関数型プログラムで永遠のテーマだった分割コンパイルをするとインライン化が妨げられるが全プログラムコンパイルをするとコンパイル時間が掛かりすぎるという問題にモジュールより上位のクレートという単位を設けることで解決を見出したのです。 それに素晴らしきCargo。依存関係の地獄はありませんし、Makefileを書く必要もありません。パッケージインストーラがランタイムにまで侵入してくることもありません。 私達がプログラムを書くことに集中させてくれます。\nまとめ 関数型プログラマがRustを使うと、所有権やミュータビリティ、メモリへの厳しさに最初は面くらうもののすぐに馴れて普段通りにプログラムを書けるようになります。 もちろん、Rustはむしろ手続き型な言語なので関数型プログラムそのまま、とはいきませんが普段使っている道具がそのまま使えるのでハードルは低いですし、むしろ手続き型プログラムに馴れた人が戸惑わないか心配にすらなります（初めてC++プログラマがRustをスラスラ書けると聞いたときには大変驚きました）。 Rustは関数型プログラマ、手続き型プログラマ問わず良い言語なのでみなさんも最初の一歩を踏み出しましょう！\nメタ 私のブログは記事によって意識的に文体を変えているのですが、今回は新たな試みとして「海外でちょっと流行った記事の野良和訳」風に書いてみました。 なので海外風に「明らかに」などの強いワードを用いたり誤訳っぽいワードを埋めたいあまつさえ（訳注:〜）なんてものが出現しますが特に原文はないです。 案外疲れました。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2017-04-04","title":"関数型プログラマからみたRust","url":"https://KeenS.github.io/blog/2017/04/04/kansuugatapuroguramakaramitarust/"},
  {"body":"# ソフトウェアエンジニアがPYNQでFPGAやってみる ---------------------- === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # よくある話 ------------ 「Lisperって自分のLispを作るらしいよ」  「Lispって昔は専用ハードウェアで動いてたらしいよ」  「じゃあハードウェア作んなきゃ」  「FPGAやるかー」  === # FPGAって？ ------------ * Field-Programmable Gate Array * プログラマブルな集積回路 + オレオレ設計のCPU作ったり + HDMI入力を直でmpg4にエンコードするデバイスとかも * クロックはASIC(ふつうのCPU)より大分遅い * でも上手く嵌れば100倍高速化とか === # PYNQって？ ------------ * [PYNQ-Z1 Python Productivity for Zynq - Digilent](http://store.digilentinc.com/pynq-z1-python-productivity-for-zynq/) * xilinxのFPGAとARMのチップが載ったSoC * ARMで動いてるPython(Jupyter)からFPGAにロジック焼ける + 手軽にロジックを試せる * FPGAとの通信はMMIO + 特定のアドレスのメモリにデータを書くとFPGAに送られる + メモリのデータを読むとFPGAからデータが送られる === 会社にPYNQがきたよ！！azure倒したら遊ぶ！！！！ pic.twitter.com/ohJg7z4lxd\n\u0026mdash; κeen (@blackenedgold) 2017年2月7日 === # ハードウェアロジック --------------------- * ハードウェア記述言語(HDL)を使う + メジャーなのはVHDLとVerilog + 今回はVerilogの話 * クロックとかレジスタとかワイヤーとか駆使する * 電気信号なのでロジックが並列で走る * vivadoというツールでコンパイル + Tclで制御も出来る * 回路設計とかも * コンパイルは結構遅い… * CPUと通信するときの規格とかも書かなきゃいけない * AXI LiteとかAXI Fullとか… * 一応自動で生成はしてくれる === ![vivadoのスクショ](/images/fpga/vivado.png) === # なんか作ってみる1 ------------------ * Lチカ * [Vivado and zybo linux勉強会資料3](https://www.slideshare.net/marsee101/vivado-and-zybo-linux3) * ↑ロジック焼くとこ以外ほぼこれのまま * ロジックで作ったワイヤーと実際のLEDのワイヤー結んだりして楽しい * AXI LiteでCPUと繋がって間隔変えたり出来る === ``` verilog reg [3:0] LED_Display_Counter; reg [31:0] LED_Interval_Counter; reg slv_reg_wren_1d; // slv_reg_wren_1d generate always @(posedge S_AXI_ACLK) begin if (~S_AXI_ARESETN) slv_reg_wren_1d === # なんか作ってみる2 ------------------ * 簡易計算機 * 渡された2値で演算 + 四則演算とか論理演算とか * AXI Liteで通信 + AXI Liteはレジスタのみ通信可能 === ```verilog reg [C_S_AXI_DATA_WIDTH-1:0] res; always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 1'b0) begin res === # なんか作ってみる3 ------------------ * 命令列を受け取って計算 * 内部で16のレジスタ、プログラムカウンタなど * CPUっぽい動き * CPUとの通信はAXI Full + メモリに触れる === ``` verilog generate if (USER_NUM_MEM = 1) begin assign mem_select = 1; assign mem_address = (axi_arv_arr_flag? axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:(axi_awv_awr_flag? axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:0)); end endgenerate function [3:0] fop; input reg[C_S_AXI_DATA_WIDTH-1:0] opcode; fop = opcode[C_S_AXI_DATA_WIDTH-1 -: 4]; endfunction function [3:0] fret; input reg[C_S_AXI_DATA_WIDTH-1:0] opcode; fret = opcode[C_S_AXI_DATA_WIDTH-5 -: 4]; endfunction function [3:0] freg1; input reg[C_S_AXI_DATA_WIDTH-1:0] opcode; freg1 = opcode[C_S_AXI_DATA_WIDTH-9 -: 4]; endfunction function [3:0] freg2; input reg[C_S_AXI_DATA_WIDTH-1:0] opcode; freg2 = opcode[C_S_AXI_DATA_WIDTH-13 -: 4]; endfunction function [15:0] fconst1; input reg [C_S_AXI_DATA_WIDTH-1:0] opcode; fconst1 = opcode[C_S_AXI_DATA_WIDTH-13 -: 16]; endfunction // implement Block RAM(s) wire mem_rden; wire mem_wren; wire [C_S_AXI_DATA_WIDTH-1:0] data_out; wire [C_S_AXI_DATA_WIDTH-1:0] start; reg [C_S_AXI_DATA_WIDTH-1:0] result; reg [C_S_AXI_DATA_WIDTH-1:0] r[0:15]; reg [C_S_AXI_ADDR_WIDTH-1:0] pc; reg [1:0] finish; reg [C_S_AXI_DATA_WIDTH-1:0] byte_ram [0 : 31]; reg [3:0] state; reg [C_S_AXI_DATA_WIDTH-1:0] opword; reg [3:0] op; reg [3:0] ret; reg reten; reg [C_S_AXI_DATA_WIDTH-1:0] retreg; reg [C_S_AXI_DATA_WIDTH-1:0] reg1; reg [C_S_AXI_DATA_WIDTH-1:0] reg2; reg [15:0] const1; assign mem_wren = axi_wready \u0026\u0026 S_AXI_WVALID ; assign mem_rden = axi_arv_arr_flag ; //\u0026 ~axi_rvalid assign data_out = byte_ram[mem_address]; assign start = byte_ram[1]; localparam integer PC_START = 2; always @(posedge S_AXI_ACLK) begin if (S_AXI_ARESETN == 0 || start == 32'b0) begin finish === # まとめ -------- * FPGA楽しいよ * CPUっぽいの作れるよ * PYNQ便利だよ   ","categories":["FPGA","PYNQ","sotomuki"],"category_urls":["/categories/fpga","/categories/pynq","/categories/sotomuki"],"date":"2017-03-28","title":"ソフトウェアエンジニアがFPGAやってみる","url":"https://KeenS.github.io/slide/sofutoueaenjiniagafpgayattemiru/"},
  {"body":"# Rust in Production ---------------------- [Rust プログラマーミートアップ / Rust programmers' meetup - connpass](https://rust.connpass.com/event/49304/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * 若者 * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # Rust採用までの流れ -------------------- Ω＜「κeen君継続的ベンチマークサーバ作って」Ω＜「GitHubにpushする度ベンチマーク走る感じで」Ω＜「GPUとRaspberry Piでベンチマークするから」Ω＜「全部任せるね」⸜( ¯⌓¯ )⸝「Rustで書くか」やったこととか知見とかトピック毎にかいつまんで話します === # Rustのメリット --------------- * κeenが馴れてる * 社員の半分くらい書ける * Linux, Mac, Raspberry Piで動く * テスト書かなくてもそんなにバグらなそう * 将来のために小さいところでノウハウ溜めていきたい * シングルバイナリで楽に動きそう * **単純に使いたかった** * ※今回は速度や安全性は必要ない === # コンポーネント --------------- * CLIクライアント + 各自の手元やCIサーバから起動 * アグリゲータ + ワーカに仕事を投げ、結果を受け取る + ジョブ管理 * ワーカ + GPUマシンやRSPiなどでベンチマーク + 結果をアグリゲータに返す * ブラウザ + ベンチマーク結果の閲覧 === # プロジェクト構成 ------------------- * [ワークスペース](http://doc.crates.io/manifest.html#the-workspace--field-optional)を使ってサブプロジェクトに分割 + モノリシックだとビルドが重かった + targetは全てのプロジェクトで共有する * CLI, aggregator, worker, browserの他にmodel, api * modelはaggregatorとbrowserで共有 * apiはaggergatorとcliとworkerで共有 * コード === # プロジェクト構成 ------------------- ``` Cargo.lock Cargo.toml README.md bench_aggregator/ bench_api/ bench_browser/ bench_cli/ bench_model/ bench_worker/ build.sh circle.yml docker-compose-deploy.yml docker-compose.yml migrations rustfmt.toml src/ static/ target/ ``` === # プロジェクト構成 ------------------- ![構成のイメージ](/images/rust-in-production/composition.png)=== # パーサ -------- * workerで使う * timeやgprofの結果を数値で欲しい * →パースするか… + フォーマット * timeはbash固定 + シェルコマンドなのでシェル毎にフォーマットが違う * gprofは`-b`オプションでの結果をパース + gmon.outではない === # パーサ -------- * パーサコンビネータ [nom](https://github.com/Geal/nom) * サクっと作れた * デバッグつらい + gprofが思ったより変なフォーマットしてた + nomがバイト指向なのと位置を保存しない + 自力でどうにかする？ + [combine](https://github.com/Marwes/combine)使うか手書きにするかで書き直したい * コード === # CLIオプション --------------- * workerとcliで必要 * 多機能な[clap](https://github.com/kbknapp/clap-rs)を採用 * 特に困らない * 採用プロジェクトも多くてliving exampleに事欠かない * CLIツールに思考停止で採用していいと思う * コード === # HTTPクライアント ------------------ * CLIとworkerで使う * [hyper](https://github.com/hyperium/hyper) vs [reqwest](https://github.com/seanmonstar/reqwest) * 非同期な必要はないのでreqwest使いたかった * reqwestにmultipart対応がない→生hyper+[multipart](https://github.com/abonander/multipart) * コネクションの管理とかjsonの扱いとかそこそこ面倒だった… * reqwestにmultipart対応入ったら乗り換えるかも === # HTTPサーバ ------------ * aggregatorとbrowserで使う * 簡単なREST API * 生hyper vs [nickel](https://github.com/nickel-org/nickel.rs) vs [iron](https://github.com/iron/iron) * 生hyperはすぐつらくなる→やめた * **nickelとironはそんなに変わらなかった** * nickel(agregator)+iron(browser) + aggregatorはなんとなくでnickel選んじゃった + browserは結局[rustc-perf](https://github.com/rust-lang-nursery/rustc-perf)からフォークしたためironだった === # HTTPサーバ(Nickel) ------------ * サーバデータの扱いがちょっと特殊？ ```rust let data = req.server_data(); ``` * 400 BadRequestと500 InternalServerErrorのマクロ作った + `validate!(res, serde_json::from_str(field));` + `server_try_with!(res, serde_json::to_string(\u0026ret));` + 「エラー出たら処理終了」が他の言語と比べて書きづらい？ * 非同期IOしない… + ポーリングでコネクション張りっぱなしなのでクライアント分スレッドが必要（ハマった） * マルチスレッド→DBコネクションにロックが必要 * コード === # APIモデル ----------- * apiクレートを分けた + バイナリ毎に別クレートに分けるために必要だった * [serde](https://github.com/serde-rs/serde)と[serde_json](https://github.com/serde-rs/json)でjson化 * proc-macroがstableになって格段に使いやすくなった * モジュール分けて`Request`と`Response`を作ってAPIが分かりやすく * コード === # DB ----- * aggergatorとbrowserで必要 * ほぼ[diesel](https://github.com/diesel-rs/diesel)一択 + コネクション、マイグレーション、ORMなど + proc-macroで大分楽に * [仕事でdiesel使ってみた | κeenのHappy Hacκing Blog](https://keens.github.io/slide/shigotodedieseltsukattemita/) * DBはPostgreSQL + 半分dieselのため、もう半分機能のため * 開発時はdocker-composeで立てる + CF [docker-composeでmysql \u0026 postgreSQL をサクッと起動 - Qiita](http://qiita.com/astrsk_hori/items/1e683a7a2f2b7189cb6e) === # diesel ----- * Pros + SQLでスキーマ書ける + マイグレーションの面倒みてくれる + proc-macroのおかげで楽 + クエリDSL案外普通に書けた + 最悪SQL生牡蠣出来る + CLI便利 === # diesel -------- * Cons + deriveいっぱいあって難しい - has_manyとbelongs_toあたりをどう書くか + enum扱えない + DSLで2重join書けない + 偶に機能足りない - ネットワークアドレス型サポートとか + SQL生牡蠣の型付けつらい + has_manyの扱いに難あり - eager loadingしない設計判断 - `(User, Vec)` みたいなのを持ち回す羽目に - モデル設計にも影響 === # マイグレーション ----------------- * 普通のマイグレーション運用かな * 最初のデプロイまでは`diesel database reset`で何度も初期化した * 最初デプロイ後は手元で`diesel migration run`と`diesel migration revert`を何度か * デプロイ時に雑に手元から本番サーバに `diesel migration run` + 本当はデプロイプロセスに組込みたい + diesel CLIの入ったdockerコンテナ… * まだほとんど使われてないので雑運用 === # マイグレーション(コード) ----------------- * スキーマ変更したらコードの変更も必要 + そもそも必要だからスキーマ変更するので割と自然に出来る * `infer_schema` があるので先に開発環境のマイグレーションをしないといけない * カラムの順番とフィールドの順番が一致する必要 + 地味に面倒 + 今後改善予定 CF [#747](https://github.com/diesel-rs/diesel/pull/747) * SQL生牡蠣の対応がつらい + コンパイル時にカラム不足が分からない === # エラー管理 ------------ * 全ての場所で必要 * [error_chain](https://github.com/brson/error-chain)を採用 * 公式ドキュメントの[エラーハンドリング](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/error-handling.html)のボイラプレートをマクロで生成 * `?`でのエラー処理が楽になる→ `unwrap`が消えた * 全てのプロジェクトに思考停止で採用していいんじゃないかな === # ログ ------ * 全ての場所で必要 * nurseryの[log](https://github.com/rust-lang-nursery/log)と[env_logger](https://github.com/rust-lang-nursery/log)を採用 * `println!`より高機能な（on/offが出来る）ので`println!`の代わりに`debug!`を入れる * あとたまにエラーハンドリングで`error!`使ったり * `main`で一行`env_logger::init().expect(\"failed to init env logger\");`を忘れずに * 運用以前に開発に便利なので問答無用で入れていいと思う === # コンフィグ ------------ * [serde_yaml](https://github.com/dtolnay/serde-yaml) + [dotenv](https://github.com/slapresta/rust-dotenv) * コンフィグファイルといえばyamlだよね + ちょこっといじって再起動がやりやすい * dotenvはdockerと相性がいい気がする * どっちがいいか判断出来なかったので両方実装 * プロダクションで動いてるのはdotenv（というか普通の環境変数）の方 === # テスト -------- * 全ての場所で必要 * 組込みの`#[test]`を使用 * 正直あまり出来てない * 型強いし多少はなくてもバグらない…？ * 一応レイヤ(DB/ビジネスロジック/インタフェース)を跨ぐときにはtraitで抽象化 + 出来てないところもいっぱい * 今後の課題とさせて頂きます === # デバッグ ---------- * 基本はlogの`debug!`でトレース * ちゃんと型つけときゃバグらない * GDB使う…？ * デモ === # ビルド -------- * cargoでサブプロジェクト全てをビルドするコマンドがなかった + 最近 `cargo build --all` が入った * Raspberri Pi向けにクロスコンパイルが必要 * シェルスクリプトでビルドスクリプト * クロスコンパイルはdockerを使う CF [dlecan/rust-crosscompiler-arm: Docker images for Rust dedicated to cross compilation for ARM v6 and more](https://github.com/dlecan/rust-crosscompiler-arm) * 正解なのか分からない === # CI ---- * 全てのクレートで必要 * Circle CIを使ってる * 普通にrustupでRustのインストール + travisならRustサポートあるけど… * 普通に `cargo test --all` === # デプロイ ---------- * シングルバイナリだけど… * シュっとdocker-swarmとかでデプロイしたい * dockerイメージ作ってdocker-composeで管理 + 開発も便利に * raspberry piはバイナリだけ配る * browserは`static/`もイメージに同梱 === # Docker -------- * ベースイメージはUbuntu + libcの扱いが面倒そうなのでalpineはやめといた + イメージサイズに困ってからどうにか考える * swarmなのでdocker-composeの設定そのままで動かせる * ログの管理もswarm任せ + env_loggerが標準出力に吐くのもそんなに困ってない === # Docker -------- * rustのビルドからのdockerのビルドが面倒 * Dockerfileの管理も面倒 * 便利なの作った * [KeenS/cargo-pack-docker: a cargo subcommand to package your application into a docker image](https://github.com/KeenS/cargo-pack-docker) * DockerfileなしでRustのビルドからイメージ作成までやってくれる * 今のところ使えてる + 作りが甘いことは認識してる… === # まとめ --------- * Rustを仕事で使ったときの知見を話した * 微妙に痒いところに手が届かないけど概ね揃ってる * 開発が速いので問題は放置しとくと勝手に直るかも * テストとかデプロイとかまだ知見が足りない   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2017-03-22","title":"Rust in Production","url":"https://KeenS.github.io/slide/rust_in_production/"},
  {"body":"ちょっとオーディナルの話をしよう。ついでにカーディナルの話もしよう。 特に何も知らなくても分かる内容。だけど文脈を知ってると伝えたいことが伝わる筈。\nまずは何もないところから始めよう。机もスマホもパソコンンもない。空気もないし数字もない、自然数もない。\n何もない。\n「何もない」、もうちょっと正確にいうと「何も要素がない集合」のことを覚えているだろうか。中学校で習った気もする。\n\\[ \\emptyset \\]\nと書く。 さて、ここから始める。何もないところから何か作れるだろうか。まずは $\\emptyset$ を要素に持つ集合、\n\\[ \\{\\emptyset\\} \\]\nがある。これは要素を1つだけ持つので $\\emptyset$ とは異なる集合だ。これをさらに進められないだろうか。例えば\n\\[ \\{\\emptyset, \\emptyset\\} \\]\nとか。これではダメだ。結局2つの要素が同じ $\\emptyset$ なので要素を取り出してみても $\\{\\emptyset\\}$ から取り出したときと区別がつかない。 何か $\\emptyset$ とは別のものが必要だ。 $\\emptyset$ とは別のもの。既に出てきた。 $\\{\\emptyset\\}$ だ。\n\\[ \\{\\emptyset, \\{\\emptyset\\}\\} \\]\nこれで $\\emptyset$ とも $\\{\\emptyset\\}$ とも異なる集合が作れた。ここまできたらあとはもうパターンだ。「次」が欲しければ今までに出てきた集合を全部$\\{\\}$に放り込めばいい。\n\\[ \\{\\emptyset, \\{\\emptyset\\}, \\{\\emptyset, \\{\\emptyset\\}\\}\\} \\]\n「次(Successor)」を求める手続を $\\mathbf{succ}$ と書くとすると、集合の合併 $\\cup$ を用いて\n\\[ \\mathbf{succ} (x) = x \\cup \\{x\\} \\]\nと書ける。この $\\mathbf{succ}$ 、必ず新たな集合を生み出している。これはつまり、任意の $x$ に対して $\\mathbf{succ}(x)$ は $\\emptyset$ にはならないし、 $x \\not= y$ のとき $\\mathbf{succ}(x) \\not=\\mathbf{succ}(y)$ でもある。 このようなものをご存知ないだろうか(細かいことを言うと帰納法の原理も必要だが飛ばす)。\n自然数だ。\n $\\emptyset$ がある 任意の自然数 $x$ に $\\mathbf{succ}(x)$ がある $\\emptyset$ はいかなる自然数 $x$ の $\\mathbf{succ}$ でもない $x \\not= y$ のとき $\\mathbf{succ}(x) \\not=\\mathbf{succ}(y)$ (帰納法の原理が成り立つ)  これは、こういうことだ。\n\\[ \\begin{eqnarray} 0 \u0026amp; = \u0026amp; \\emptyset \\\\\\\n1 \u0026amp; = \u0026amp; \\{\\emptyset\\} \\\\\\\n2 \u0026amp; = \u0026amp; \\{\\emptyset, \\{\\emptyset\\}\\} \\\\\\\n3 \u0026amp; = \u0026amp; \\{\\emptyset, \\{\\emptyset\\}, \\{\\emptyset, \\{\\emptyset\\}\\}\\} \\\\\\\n\u0026amp; \\vdots \u0026amp; \\end{eqnarray} \\]\nここでは #0は自然数 としてある。 さて、今我々は何もないところから出発してDASH村のように自然数を作り上げた。\nこの自然数、面白い性質がある。 0 は 1の要素( $0 \\in 1$) だ。 1 は 2 の要素 ( $1 \\in 2$ )だし、0も2の要素 $0 \\in 2$ だ。もうちょっというと、 $x \\in y$ かつ $y \\in z$ のとき、 $x \\in z$も成り立つ。 この関係で自然数には順序がつく。つまり、自然数は順序数(オーディナルナンバー)だ。再度、オーディナルナンバーであるところの自然数を列挙するとこうなる。\n\\[ \\emptyset, \\{\\emptyset\\}, \\{\\emptyset, \\{\\emptyset\\}\\}, \\{\\emptyset, \\{\\emptyset\\}, \\{\\emptyset, \\{\\emptyset\\}\\}\\}, \u0026hellip; \\]\nこれに見覚えがあるならオーディナルの話はこれで十分。\nさて、カーディナルの話をしよう。 $\\emptyset$ は要素が0個。 $\\{\\emptyset\\}$ は要素が1つ。 $\\{\\emptyset, \\{\\emptyset\\}\\}$ は要素が2つ。 要素数の話だ。これは別に自然数だけでなくて、 $\\{2, 4\\}$ のように自然数ではない集合でも要素数という概念はある。要素数をどう数えようか。一応要素数に濃度という名前もついている。 これにも自然数が使える。2と $\\{2, 4\\}$ を $\\{2, 4\\}$ を $2 -\\emptyset$ と $4 - \\{\\emptyset\\}$ と1対1に対応づければ、「$\\{2, 4\\}$と 2は同じ濃度を持つ」といえる。 このように濃度を数えるための数を基数（カーディナルナンバー）という。\n手で数えられる（有限な）ものは面白みがない。無限なものについて考えよう。例えば今我々が作った自然数は常に $\\mathbf{succ}$ がとれるので無限の要素がある。 まだ作ってないが、自然数だけでなく整数にも有理数にも実数にも無限の要素がある。これらの「無限」は全て同じ大きさなのだろうか、つまり同じ濃度なのだろうか。 結論からいうと自然数と整数と有理数は同じ濃度を持つ。全て自然数と1対1の対応が取れるということだ。一方実数は対応が作れない。実数の濃度の方がずっと大きい訳だ。つまり、無限の間にも大小関係がある。実は自然数は無限の中でも一番小さい。この一番小さい基数のことをヘブライ文字からとって\n\\[ \\aleph_0 \\]\nと書く。これも見覚えがあればカーディナルの話はこれにて重畳。\nそういえばこういう「紙の上でDASH村」を気に入ったならこの本がお勧め。\nコンピュータは数学者になれるのか? -数学基礎論から証明とプログラムの理論へ- | 照井一成 |本 | 通販 | Amazon\n","categories":["番外編","小ネタ"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2017-03-02","title":"オーディナルの話とカーディナルの話","url":"https://KeenS.github.io/blog/2017/03/02/o_dinarunohanashitoka_dinarunohanashi/"},
  {"body":"# 仕事でdiesel使ってみた ---------------------- [RustのLT会！ Rust入門者の集い #2 - connpass](https://rust.connpass.com/event/48826/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # [diesel.rs](diesel.rs) ![dieselのwebページ](/images/diesel/diesel-web.png) === # diesel --------- * RustのORM * スキーマからコード自動生成 * diesel_codegen * クエリビルダ * マイグレーション管理 * PostgreSQL, MySQL, SQLiteサポート === # 準備 ------- * [docker-composeでmysql \u0026 postgreSQL をサクッと起動 - Qiita](http://qiita.com/astrsk_hori/items/1e683a7a2f2b7189cb6e) ``` cargo install diesel_cli echo DATABASE_URL=postgres://username:password@localhost/hoge  .env diesel setup diesel migration generate create_posts ``` === # 準備 ------- ``` toml [dependencies] chrono = \"0.3.0\" diesel = {version = \"0.11.4\", features = [\"chrono\", \"postgres\", \"serde_json\"]} dotenv = \"0.8.0\" serde_json = \"0.9.6\" serde_derive = \"0.9.7\" serde = \"0.9.7\" [dependencies.diesel_codegen] features = [\"postgres\"] version = \"0.11.0\" ``` === # プロジェクト構成 ----------------- * モデルのコンパイルが遅いので分離したい * Cargoの[ワークスペース](http://doc.crates.io/manifest.html#the-workspace-section)機能を使う === # プロジェクト構成 ----------------- ``` $ ls Cargo.lock Cargo.toml hoge_model { pub hoge_entry_id: i32, // Stringではなく\u0026str pub hostname: \u0026'a str, } ``` === # enumの扱い ----------- * dieselはenumのcodegenをサポートしてない * 気合 === # enumの扱い ----------- ```rust // Queryableとかはderive出来ない #[derive(Debug, Clone)] pub enum HogeStatus { Waiting, Running, Finished, Failed, Canceled, } // 手で実装 implFromSqlfor HogeStatus where QB: QueryBuilder, BC: BindCollector, BE: Backend{ fn from_sql(bytes: Option::RawValue) - Result { use self::HogeStatus::*; match ::from_sql(bytes)? { 0 = Ok(Waiting), 1 = Ok(Running), 2 = Ok(Finished), 3 = Ok(Failed), 4 = Ok(Canceled), n = Err(format!(\"invalid status: {}\", n).into()), } } } implFromSqlRowfor HogeStatus where QB: QueryBuilder, BC: BindCollector, BE: Backend{ fn build_from_row(row: \u0026mut T) - Result { use self::HogeStatus::*; match ::build_from_row(row)? { 0 = Ok(Waiting), 1 = Ok(Running), 2 = Ok(Finished), 3 = Ok(Failed), 4 = Ok(Canceled), n = Err(format!(\"invalid status: {}\", n).into()), } } } ``` === # クエリ -------- * モデルプロジェクトとは別 * 各プロジェクトのdb.rsで関数を定義 * SQLよりRsutのイテレータを意識した書き方 === # クエリ -------- ```rust pub fn is_hoge_finished(conn: \u0026Cn, entry_id: i32) - Resultwhere Cn: Connection{ use self::schema::hoge_suites::dsl::*; // SELECT ... じゃなくてsourceからfileterして最後にselect let ret = hoge_suites .filter(hoge_entry_id.eq(entry_id)) .select(status) // ここまでクエリビルダ .load::(conn)? // ここからイテレータ .into_iter() .all(|i| [HogeStatus::Finished as i32, HogeStatus::Failed as i32].contains(\u0026i)); Ok(ret) } ``` === # 複雑なクエリ ------------- * トランザクション * join * order by === # 複雑なクエリ ------------- ``` rust pub fn pic_suite(conn: \u0026Cn, query: \u0026api::worker_poll::Request) - Result, Error where Cn: Connection{ use self::schema::hoge_entries::dsl::*; use self::schema::hoge_suites::dsl::*; use self::schema::hoge_suites::dsl::id; // transaction conn.transaction(|| { let suite = hoge_suites // join .inner_join(hoge_entries) .filter(status.eq(HogeStatus::Waiting as i32) .and(hostname.eq(\u0026query.hostname))) // order by .order(created_at.asc()) .select((id, hoge_entry_id, hostname, status)) .first::(conn) // NotFoundErrorをOptionにできる .optional()?; // transactionの中で普通にrustの式が書ける if let Some(s) = suite { let entry = hoge_entries.find(s.hoge_entry_id) .first::(conn)?; let suite = diesel::update(hoge_suites.find(s.id)).set(status.eq(HogeStatus::Running as i32)) .get_result::(conn)?; Ok(Some((entry, suite))) } else { Ok(None) } }) } ``` === # もっと複雑なクエリ ------------------- * 2重join * dieselは2重joinを扱えない… === # もっと複雑なクエリ ------------------- ``` rust pub fn load_all_data(conn: \u0026Cn) - Result)) where Cn: Connection{ use diesel::types::{Integer, Timestamp, VarChar, Double}; use diesel::pg::types::sql_types::{Array, Jsonb}; use diesel::expression::dsl::*; use diesel::select; let status = sql::(\"s.status\"); let ret = select(sql::,Timestamp, VarChar, Integer, Jsonb), (Integer, Integer, VarChar, Integer), (Integer, Integer, VarChar, Integer, Integer, VarChar), (Integer, Integer, VarChar, Integer, Double))( \" e.id, e.repo, e.committish, e.files, e.created_at, e.command, e.format, e.format_data, s.id, s.hoge_entry_id, s.hostname, s.status, r.id, r.hoge_suite_id, r.hoge_name, r.score, r.status, r.result, p.id, p.hoge_result_id, p.function_name, p.score, p.percent FROM hoge_profiles p INNER JOIN hoge_results r on r.id = p.hoge_result_id INNER JOIN hoge_suites s ON s.id = r.hoge_suite_id INNER JOIN hoge_entries e ON e.id = s.hoge_entry_id\")) .filter(status.eq(HogeStatus::Finished as i32)) .load::(conn)?; let mut hash = HashMap::new(); for (e, s, r, p) in ret { let mut hash_entry1 = hash .entry(e.id).or_insert((e, HashMap::new())); let mut hash_entry2 = hash_entry1.1.entry(r.id).or_insert(((s, r), Vec::new())); hash_entry2.1.push(p); } let ret = hash.into_iter().map(|(_, v)| (v.0, v.1.into_iter().map(|(_, p)| p).collect())).collect(); Ok(ret) } ``` === # テスト ------- * ￣\\＿(ツ)＿/￣ === # まとめ -------- * 案外普通に使えるよ * モデルはちょっと面倒かもね * クエリは困ったらSQL生牡蠣 * マイグレーションとかはまた今度   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2017-03-01","title":"仕事でdiesel使ってみた","url":"https://KeenS.github.io/slide/shigotodedieseltsukattemita/"},
  {"body":"# WebAssemblyとコンパイラとランタイム ---------------------- [emscripten night !! #3 - connpass](https://emsn.connpass.com/event/48100/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # 何の話 --------- * WebAssemblyをバックエンドに使う言語を作りたい * [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml) * 既に発表したものの補足記事的な + [コンパイラの人からみたWebAssembly | κeenのHappy Hacκing Blog](https://keens.github.io/slide/konpairanoninkaramitaWebAssembly/) + ある程度再度説明します === # アジェンダ ------------ * なぜWebAssembly * コンパイラ * コード生成 * ランタイム === # なぜWebAssembly === # なぜWebAssembly ---------------- * なんかバイナリでテンション上がる * ポータブルでコンパクトで速い * 機能的にJSを越えるかもしれない…？ * コンパイラがブラウザで動くと言語導入のハードル下がる + 気軽に試せる + コンパイラだけでなく吐いたコードもブラウザで動かしたい === # WASM over LLVM ---------------- * 既存のJS環境と協調する + JSとの相互呼び出しとか * **non-determinismが少ない** * 細かいアラインメント考える必要がない * **API安定しそう** === # WASM over asm.js -------------------- * ブラウザ以外への組込みもサポート + Node.jsとか + **JITエンジンに使えそう** * プラットフォーム * 実行までのレイテンシが短かい * asm.jsより速度を出しやすい設計 * テキストフォーマットで生成コードの文法エラーが怖い * 将来機能が増えるかも === # WebAssemblyの現状 ------------------- * Minimum Viable Product(MVP) * 機能を削ってとりあえず動くものを作ってる * 今はC/C++からLLVMを通して吐けるのが目標 + C/C++には不要でも自分の言語に欲しい機能は…… * 今後SIMDとかスレッドとかDOM APIとか増えていく === # コンパイラ === # WASM概要 ---------- * WASMには以下がある + 関数 - 関数内ローカル変数 + リニアメモリ + グローバル変数 + テーブル + importテーブル + exportテーブル === # WASM実行モデル -------------- * i32,i64,f32,f64のみ * **スタックマシン** + 命令のオペランドや関数の引数はスタック経由で渡す + 1 passのコード生成が楽そう * 無限のローカル変数が使える + 型がある * 関数の引数はローカル変数経由で渡される * コントロールフローはgotoじゃなくてstructured + 静的検証がしやすいらしい + 安全だけどコンパイラ的には… === # コントロールフロー ------------------- * `loop` + `br` (名前付き) * `block` + `br` (名前付き) * `br_if` or `br_table` * `if` + `else` + `end` * `return` * 等 === # コントロールフロー ------------------- * gotoがない + `br` はブランチじゃなくてブレイク * gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf) + loop, block, br, br_ifを使う * 高級言語から変換するなら `if` を使う + ifが2系統あることになる === # サンプル --------- ``` javascript function geometricMean(start, end) { start = start|0; // start has type int end = end|0; // end has type int return +exp(+logSum(start, end) / +((end - start)|0)); } ... ``` === # サンプル --------- ```wasm (module (type (;0;) (func (param i64 i64) (result f64))) (type (;1;) (func (param i64 i64) (result f64))) (type (;2;) (func (param f64) (result f64))) (func (;0;) (type 0) (param i64 i64) (result f64) (get_local 0) (get_local 1) (call 1) (get_local 1) (get_local 0) (i64.sub) (f64.convert_s/i64) (f64.div) (call 2)) ...) ``` === # サンプル --------- ```wasm (module (type (;0;) (func (param i64 i64) (result f64))) (type (;1;) (func (param i64 i64) (result f64))) (type (;2;) (func (param f64) (result f64))) (func (;0;) (type 0) (param i64 i64) (result f64) (call 2 (f64.div (call 1 (get_local 0) (get_local 1)) (f64.convert_s/i64 (i64.sub (get_local 1) (get_local 0)))))) ...) ``` === # WebMLコンパイラ ------------ * パーサ、AST、HIR、MIR、LIR * LIRがRTLなのでそれをWASMに変換したい * gotoからstructured control flow… === ``` [コード] | パーサ [AST] 型推論とか | AST2HIR [HIR] 早期最適化、K正規化、A正規化など | HIR2MIR [MIR] 諸々の最適化 | MIL2LIR [LIR] シリアライズ、レジスタ割り当てなど | コード生成 [WASM] ``` === # 変数 ------ * LIRはレジスタで計算する * LIRはCFG由来の大量の変数を使う + レジスタ割り当ては一旦置いとく * WASMはスタックで計算する * どうコード生成すると最適か？ === ``` fun main: () - i64 = { entry@0: r0: i64 @11 [r25+8]  (block ... (br 0)--+ ... | ) ===   (block ... ... ... (br 0)--+ ... | ) === # loopと前方ジャンプ ------------ * `loop` + `break`で後方ジャンプ + `loop` からの `break` はいわゆる `continue` * 開き括弧の位置にジャンプ * 閉じ括弧の位置は自由 ===   (loopbr 0)--+ ... )   ===   (loopbr 0)--+ ... ... ... )   === # ジャンプのクロス ------------------ * 単一gotoは割り当て出来る * 複数のgotoが入り組んだら？ === # 絶対出来る ------------ * チューリング完全なら必ず書ける + whileとswitchでステートマシン作ればいい * 効率的とは限らない * 効率的なコードを吐きたい === # ステートマシンはつらい ----------------------- * これをナイーブに変換すると… ```c #include  int main() { int sum = 0; for (int i = 1; i [br]-+ if label == 0 | | | then goto 3 | | | else goto 2 | | | | [2] | | | | | [3]=== # フォーマット ------------ * バイナリフォーマットとテキストフォーマットがある * バイナリ: wasm + コンパクト + intとかもパッキングする * テキスト: wast + 人間可読+機械可読=S式 + 低級にもちょっと高級にも書ける + 一旦アセンブラ噛まさないと動かない === # アセンブラ ------------ * オンメモリで生成するためにアセンブラ自作 + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs) + ブラウザで動かすのに必要 + 既存のツールは使えない * アセンブラ自体ブラウザで動かすのでRust製 * まだ動かしてない === ```rust let mut mb = ModuleBuilder::new(); let f = mb.new_function(FunctionBuilder::new(funtype!((i32, i32) - i32)) .code(|cb, args| { cb.constant(2) .get_local(args[0]) .i32_add() }) .build()); mb.export(\"addTwo\", f); let module = mb.build(); ``` === # スタック領域 ------------- * Cでいう`struct foo x;`みたいにエフェメラルな多ワード領域が欲しい * WebAssemblyのローカルストレージはLVだけ + 最大1ワードしか保存出来ない * 可能性 1. 諦めてメモリに確保（場合によっては最適化で消えるかも） 2. ワード毎に分割してLVに保存（大変だけど速そう） === # ランタイム === # 言語のランタイム ----------------- * 主にはGC * その他データのメモリ表現 + アラインメントも * スタック領域 * FFI * コンパイラなのでシンボルテーブルはなし === # メモリ -------- * mallocとかはない * ページ単位のアロケーションだけ * 自前でGCを実装することになる === # GC ----- * コールスタックを遡れない + コールスタックをGCルートに出来ない * メモリonlyな走査なら可能 + ポインタを都度メモリ領域(arena)にコピーすれば良い。 + arenaもルートになる + コールスタックと連動するのでスタックで管理出来る。 + CF [Matzにっき(2013-07-31)](http://www.rubyist.net/~matz/20130731.html) + ただしコンパイラなので関数全部をsave/restoreで囲んだりはしない。 === # アロケータ ------------ * どうにか書いてブラウザでリンクする必要がある + ブラウザにもランタイムライブラリの時代… + WASMはライブラリ間でメモリ共有出来る * とりあえずRustで書く方針 + WASMのページアロケートとかどうすればいいんだろう + まだ色々未定 === # メモリ表現 ------------ * 出来れば楽して64bit統一したかった + i32やf32を抹殺したかった * WASM32しかないのでポインタが32bit… * 仕方ないので64bitアラインメントでパディングする * 空いた32bitの使い道は未定 + 静的型付だし型タグが要らない + 代数的データ型のタグ？ === # 高階関数 ---------- * WASMに関数ポインタがない * テーブルに関数を登録してインデックス参照 + C++のvtableのための機能 + 型も動的チェック * ちょっと遅そう * 気合でインライン化を頑張ろう === # FFI ------ * JSの関数を呼びたい * 細かいところどうなってるんだろう + 例外は？JSオブジェクトは？GCは？ * 型付… * ノープラン === # 雑にまとめ ------------- * WASMはちょっと高級なので最適化コンパイラは困るよ + 雑なコンパイラにはむしろ嬉しい * コード生成は努力で解決 * GCは割とつらいよ + 将来楽になるかも * JS連携や将来のスレッドとかはみんなで考えよう   ","categories":["WebAssembly","Compiler","Runtime"],"category_urls":["/categories/webassembly","/categories/compiler","/categories/runtime"],"date":"2017-02-16","title":"WebAssemblyとコンパイラとランタイム","url":"https://KeenS.github.io/slide/webassemblytokonpairatorantaimu/"},
  {"body":"κeenです。Rustでちょっとやりすぎだけど使う側の自由度が高くて安全なBuilderパターンを思い付いたので紹介しますね。\n※2017-02-11T13:18:58Z+09:00 最下部に追記しました\n目的コード 以下のような構造体のビルダーを作りたいとします。\n#[derive(Debug)]struct Person{id: u32,name: String,age: u32,address: Option\u0026lt;String\u0026gt;,zipcode: Option\u0026lt;String\u0026gt;,} 雑にやると\nstruct PersonBuilder{id: Option\u0026lt;u32\u0026gt;,name: Option\u0026lt;String\u0026gt;,age: Option\u0026lt;u32\u0026gt;,address: Option\u0026lt;String\u0026gt;,zipcode: Option\u0026lt;String\u0026gt;,}implPersonBuilder{pubfn new()-\u0026gt; Self{...}pubfn id(self,id: u32)-\u0026gt; Self{...}pubfn name(self,name: String)-\u0026gt; Self{...}pubfn age(self,id: u32)-\u0026gt; Self{...}pubfn address(self,address: String)-\u0026gt; Self{...}pubfn zipcode(self,zipcode: String)-\u0026gt; Self{...}// 返り値がOption型になってしまう pubfn build(self)-\u0026gt; Option\u0026lt;Person\u0026gt;{// try_opt!は標準ライブラリには存在しませんが各所で使われてるので動きは分かると思います Person{id: try_opt!(self.id),name: try_opt!(self.name),age: try_opt!(self.age),address: self.address,zipcode: self.zipcode,}}} とbuildの返り値がOption型になってしまい、あまりうれしくありません。 さらには例えばidを2回呼んだらどうなるんだとかツッコミどころが数多くあります。\nということで色々な回避策を先人達は考えてきました。\n不自由なコード 普通にやるなら\nstruct PersonBuilder{id: u32,name: String,age: u32,address: Option\u0026lt;String\u0026gt;,zipcode: Option\u0026lt;String\u0026gt;,}implPersonBuilder{fn new(id: u32,name: String,age: String)-\u0026gt; Self{...}fn address(self,address: String)-\u0026gt; Self{...}fn zipcode(self,zipcode: String)-\u0026gt; Self{...}// 返り値がOptionじゃない fn build(self)-\u0026gt; Person{...}} のようにOptionでないフィールドをコンストラクタで受け取れば安全に作れますが、コンストラクタを呼ぶ時点でいくつかフィールドが揃っている必要がある、そもそも元の構造体と何が違うんだ、など色々問題があります。\n少しマシなコード オートマトンのようにビルダーが状態遷移するコードを使うと、1つ1つの引数をビルドしつつ安全なコードが出来ます。\nstruct PersonBuilderId;struct PersonBuilderName{id: u32}struct PersonBuilderAge{id: u32,name: String}struct PersonBuilder{id: u32,name: String,age: u32,address: Option\u0026lt;String\u0026gt;,zipcode: Option\u0026lt;String\u0026gt;,}implPersonBuilderId{pubfn new()-\u0026gt; Self{...}// idの次はname pubfn id(self,id: u32)-\u0026gt; PersonBuilderName{PersonBuilderName{id: id}}}implPersonBuilderName{// nameの次はage pubname(self,name: String)-\u0026gt; PersonBuilderAge{PersonBuilderAge{id: self.id,name: name,}}}implPersonBuilderAge{// ageは最後 pubname(self,age: u32)-\u0026gt; PersonBuilder{PersonBuilder{id: self.id,name: self.name,age: age,address: None,zipcode: None,}}}implPersonBuilder{// 気持ち悪いけど PersonBuilderIdを返す pubfn new-\u0026gt; PersonBuilderId{...}pubfn address(self,address: String)-\u0026gt; Self{...}pubfn zipcode(self,zipcode: String)-\u0026gt; Self{...}// これまたOptionじゃなくなってる pubfn build(self)-\u0026gt; Person{...}} これは以下のように\nfn main(){letperson=PersonBuilder::new().id(1).name(\u0026#34;κeen\u0026#34;.to_string()).age(24).address(\u0026#34;Tokyo\u0026#34;.to_string()).build();println!(\u0026#34;{:?}\u0026#34;,person)} と使えます(即興で書いたので試してないけど)。\nとりあえず使えそうな気がしますが、型レベルで状態遷移をハードコードしているのでメソッドを呼び出す順番が固定されてしまいます。 なので以下はエラーです。\nfn main(){letperson=PersonBuilder::new()// nameとidを逆順に呼び出してみる .name(\u0026#34;κeen\u0026#34;.to_string()).id(1).age(24).address(\u0026#34;Tokyo\u0026#34;.to_string()).build();println!(\u0026#34;{:?}\u0026#34;,person)} あとは単純にstruct PersonBuilderId、struct PersonBuilderName{id: u32}、struct PersonBuilderAge{id: u32, name: String}と作っていくのが面倒という話もあります。\n今回はそれを改善したいという話\n幽霊型を使ったフィールド状態 今回提案するビルダー型はこれです。提案するといってもどうせ既に誰かが考えてるでしょうが。\nusestd::marker::PhantomData;struct Empty;struct Filled;struct PersonBuilder\u0026lt;Id,Name,Age\u0026gt;{id: Option\u0026lt;u32\u0026gt;,id_state: PhantomData\u0026lt;Id\u0026gt;,name: Option\u0026lt;String\u0026gt;,name_state: PhantomData\u0026lt;Name\u0026gt;,age: Option\u0026lt;u32\u0026gt;,age_state: PhantomData\u0026lt;Age\u0026gt;,address: Option\u0026lt;String\u0026gt;,zipcode: Option\u0026lt;String\u0026gt;,} PhantomDataという特殊な型を使ってビルダーに余計な型を付けています。\nこの型、最初はEmptyから出発します。\nimplPersonBuilder\u0026lt;Empty,Empty,Empty\u0026gt;{pubfn new()-\u0026gt; Self{PersonBuilder{id: None,id_state: PhantomData,name: None,name_state: PhantomData,age: None,age_state: PhantomData,address: None,zipcode: None,}}} そしてフィールドが埋められると対応する型がEmptyからFilledになります。\nフィールドにSomeが埋められるのと同時に対応する_stateフィールドをEmptyからFilledにすると整合性が崩れません。\n// Id以外、つまりNameとAgeはいじらないのでジェネリクスに impl\u0026lt;Name,Age\u0026gt;PersonBuilder\u0026lt;Empty,Name,Age\u0026gt;{pubfn id(self,id: u32)-\u0026gt; PersonBuilder\u0026lt;Filled,Name,Age\u0026gt;{PersonBuilder{id: Some(id),id_state: PhantomData,name: self.name,name_state: self.name_state,age: self.age,age_state: self.age_state,address: self.address,zipcode: self.zipcode,}}}impl\u0026lt;Id,Age\u0026gt;PersonBuilder\u0026lt;Id,Empty,Age\u0026gt;{// 地味なテクニックとして、SringではなくてInto\u0026lt;String\u0026gt;で受けることでリテラルのStringとかも受け取れる。 pubfn name\u0026lt;S: Into\u0026lt;String\u0026gt;\u0026gt;(self,name: S)-\u0026gt; PersonBuilder\u0026lt;Id,Filled,Age\u0026gt;{PersonBuilder{id: self.id,id_state: self.id_state,name: Some(name.into()),name_state: PhantomData,age: self.age,age_state: self.age_state,address: self.address,zipcode: self.zipcode,}}}impl\u0026lt;Id,Name\u0026gt;PersonBuilder\u0026lt;Id,Name,Empty\u0026gt;{pubfn age(self,age: u32)-\u0026gt; PersonBuilder\u0026lt;Id,Name,Filled\u0026gt;{PersonBuilder{id: self.id,id_state: self.id_state,name: self.name,name_state: self.name_state,age: Some(age),age_state: PhantomData,address: self.address,zipcode: self.zipcode,}}} Optionのままで構わないフィールドについては雑で構いません。\nimpl\u0026lt;Id,Name,Age\u0026gt;PersonBuilder\u0026lt;Id,Name,Age\u0026gt;{pubfn address\u0026lt;S: Into\u0026lt;String\u0026gt;\u0026gt;(mutself,address: S)-\u0026gt; Self{self.address=Some(address.into());self}pubfn zipcode\u0026lt;S: Into\u0026lt;String\u0026gt;\u0026gt;(mutself,zipcode: S)-\u0026gt; Self{self.zipcode=Some(zipcode.into());self}} そして必須フィールド全てが満たされた時にだけbuildが呼べます。unwrapを呼んでますが安全であることに注意して下さい。\nimplPersonBuilder\u0026lt;Filled,Filled,Filled\u0026gt;{pubfn build(self)-\u0026gt; Person{Person{id: self.id.unwrap(),name: self.name.unwrap(),age: self.age.unwrap(),address: self.address,zipcode: self.zipcode,}}} こうすることで、呼び出しが非常に自由になります。\nfn main(){letperson=PersonBuilder::new().age(24).id(1).address(\u0026#34;Tokyo\u0026#34;).name(\u0026#34;κeen\u0026#34;).build();println!(\u0026#34;{:?}\u0026#34;,person);} メソッドは自由に組み換えられますが、必須フィールドがなかったらbuildが呼べません（コンパイルエラー）になります。\nこれは応用も出来て、それぞれの状態が独立しているので例えば「2つのVector合計3つ以上要素が入っていたら」、とか「R、G、BあるいはH、S、Vの3つが揃っていたら」とかオートマトンではエンコードしづらいものでも比較的楽に書けます。\nということで便利なbuilderが出来ました。めでたしめでたし。といいたいところですが、ちょっとコードが冗長ですよね。マクロで生成なんかも出来るのですがあまりやりたくありません。ということで「ちょっとやりすぎな」Builderパターンでした。\nSome like it unsafe 上のコード、実はもうちょっと短く書けます。ただしunsafeな機能を使いますが。\nこう書いていたものが\nimpl\u0026lt;Name,Age\u0026gt;PersonBuilder\u0026lt;Empty,Name,Age\u0026gt;{pubfn id(self,id: u32)-\u0026gt; PersonBuilder\u0026lt;Filled,Name,Age\u0026gt;{PersonBuilder{id: Some(id),id_state: PhantomData,name: self.name,name_state: self.name_state,age: self.age,age_state: self.age_state,address: self.address,zipcode: self.zipcode,}}} std::mem::transmuteを使うことで2行になります。\nusestd::mem::transmute;impl\u0026lt;Name,Age\u0026gt;PersonBuilder\u0026lt;Empty,Name,Age\u0026gt;{pubfn id(mutself,id: u32)-\u0026gt; PersonBuilder\u0026lt;Filled,Name,Age\u0026gt;{self.id=Some(id);unsafe{transmute(self)}}} すごいですね。 しかし、案外しょっちゅうtransmuteはミスなどで間違った変換をしてしまう（上記で言えばidフィールドを更新したのにname_stateの型を変更してしまう）上に型検査で弾けないので個人的にはあまりおすすめ出来ません。 これも「ちょっとやりすぎ」なTipsでした。\n2017-02-11T13:18:58Z+09:00 追記 qnighyさんからもっと便利な方法の提案がありました。\nこう https://t.co/undNgEM2IQ やったらunwrapしなくてすみそう？ / “RustのちょっとやりすぎなBuilderパターン | κeenのHappy Hacκing Blog” https://t.co/ogDOpYifjh\n\u0026mdash; Masaki⊣Hara (@qnighy) 2017年2月10日 \n実際のコードはこちら。\n transmuteを使ったサボった実装は出来なくなるけどそもそも余計なフィールドを使う必要がなくなるので手軽ですね。\nqnighyさんありがとうございました。\n","categories":["Rust","デザインパターン"],"category_urls":["/categories/rust","/categories/%e3%83%87%e3%82%b6%e3%82%a4%e3%83%b3%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3"],"date":"2017-02-09","title":"RustのちょっとやりすぎなBuilderパターン","url":"https://KeenS.github.io/blog/2017/02/09/rustnochottoyarisuginabuilderpata_n/"},
  {"body":"I\u0026rsquo;m κeen. I have a sad news, I\u0026rsquo;ll stop the development of CIM and no more updates for new lisp impls will be provided.\nIt has been months from when I stopped developping CIM and only providing updates for new lisp impl versions. From that point, CIM is a half-dead product. I know there are still someone using CIM though, so I kept updating. For present CIM users, I recomend to migrate to roswell, also a lisp installer and manager, which is well-maintained.\nCIM has been developed in my studenthood for my practice in shell scripts. This is my first OSS. The reason why I wrote CIM in shell script other than for practice is that shell scripts are the most portable and available script language on Unix-like systems. The original purpose of writing a new manager is to provide a consistent way of launching CLs from CLI. To realize that, managing lisp impls, including installing is needed so CIM has started to manage impls. At some point, CIM was used such products like cl-travis. But CIM lacked flexibility of development as it is written in ugly shell script, and lacked Windows support. As I got a job and got interests other than lisp such as Rust, I have no more time to spend for maintaining CIM.\nThus @snmsts, the author of roswell, started to develop roswell to support Windows. Roswell is written mainly in Lisp though booting from C, so many of Lispers may be able to hack it. Roswell is well-maintained because stmsts is, unlike me, a hobby Lisper, professional lisper and he uses roswell in daily work. Besides roswell is well-maintained, roswell is more feature-rich than CIM. It searchs for new lisp versions for itself so there is no need to update manager itself to update your local lisp impls. It is distributed from package managers such like homebrew and AUR so you don\u0026rsquo;t need to care about updating it. Using dump feature of roswell, you can create an executable binary from a lisp script in a command. And so on. There are many reasons to use roswell even if CIM would be kept maintained.\nAnyway I wish CIM users to keep using lisp via roswell. Thank you for staying with me for a long time.\n","categories":["Lisp","Common Lisp","CIM"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/cim"],"date":"2017-01-29","title":"Deprecating CIM","url":"https://KeenS.github.io/blog/2017/01/29/deprecating_cim/"},
  {"body":"# コンパイラの人からみたWebAssembly ---------------------- [コンパイラ勉強会 - connpass](https://connpass.com/event/46850/) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # アジェンダ ------------ * WebAssemblyの概要 * 具体的な話 * WebAssembly吐こうとした話 === # WebAssemblyの概要 === # JavaScript ------------- * ブラウザ上で動くスクリプト言語 * 動的型付 * 高級 * GCとかある * 今までブラウザで動く唯一の言語だった * 遅い + 各ブラウザJITなどで補強 === # [asm.js](http://asmjs.org/) ------------ * プラウザ上で動く言語 * 低級 * GCなし * JSのサブセット + asm.jsをサポートしないプラウザでも動かせる * コンパイラから生成されることを想定 + emscriptenなど === ``` javascript function geometricMean(start, end) { start = start|0; // start has type int end = end|0; // end has type int return +exp(+logSum(start, end) / +((end - start)|0)); } ... ``` === # asm.jsの問題点 --------------- * JS互換文法なため嵩張る * パースも遅い * そもそもコンパイラが吐くならバイナリでも良いのでは？ === # WebAssembly -------------- * ブラウザ上で動く言語 + 仮想機械命令？ * 低級 * バイナリフォーマット + ロード、パース時間が短かい + パース20倍くらい速いらしい * wasm32とwasm64がある * セマンティクスは（今のところ）ams.jsをほぼ踏襲 + 実行エンジンは既存のものを使える * 将来SIMD、スレッドなどの拡張が入る === # WASMのゴール -------------------- * ポータブルでコンパクトで速い * 仕様策定と実装をインクリメンタルにやっていく + 今はとりあえずC/C++をターゲットに * 既存のJS環境と協調する + JSとの相互呼び出しとか * ブラウザ以外への組込みもサポート + Node.jsとか * プラットフォームになる + ツール類のサポートとか === # なぜWebAssembly? ------------------ * 実行までのレイテンシが短かい * asm.jsより速度を出しやすい設計 * クライアントヘビーにしやすい？ * **JSを補完する存在** * non-determinismが少ない * LLVM IRと比べてデコードが速くてコンパクト * (**code generator IR** vs optimization IR) * 余計なことをしない + fast mathとかはない + 既に最適化されたコードが吐かれる前提 === # WebAssemblyの現状 ------------------- * Minimum Viable Product(MVP) * 機能を削ってとりあえず動くものを作ってる * 今はC/C++からLLVMを通して吐けるのが目標 * 今後SIMDとかスレッドとかDOM APIとか増えていく * ChromeとFirefoxでオプトインで使える + そろそろFirefoxで普通に動く === # 具体的な話 === # セマンティクス --------------- * https://github.com/WebAssembly/spec * 形式的定義されている * 実行以外にも静的バリデーションもある * 1ファイル1モジュール + JSのモジュールと同じ概念 === # 実行モデル -------------- * i32,i64,f32,f64のみ + bitエンコーディングは指定 * スタックマシン + 命令のオペランドや関数の引数はスタック経由で渡す + バイナリがコンパクト+雑にコンパイルしても速い * 無限のローカル変数が使える + 型がある * 関数の引数はローカル変数経由で渡される * コントロールフローはgotoじゃなくてstructured + 静的検証がしやすい === # wasm、wast ------------ * バイナリフォーマットだけでは人間が読めない * テキストフォーマットも欲しい * バイナリ: wasm + コンパクト + intとかもパッキングする * テキスト: wast + 人間可読+機械可読=S式 + 低級にもちょっと高級にも書ける === ``` javascript function geometricMean(start, end) { start = start|0; // start has type int end = end|0; // end has type int return +exp(+logSum(start, end) / +((end - start)|0)); } ... ``` === ```wasm (module (type (;0;) (func (param i64 i64) (result f64))) (type (;1;) (func (param i64 i64) (result f64))) (type (;2;) (func (param f64) (result f64))) (func (;0;) (type 0) (param i64 i64) (result f64) (get_local 0) (get_local 1) (call 1) (get_local 1) (get_local 0) (i64.sub) (f64.convert_s/i64) (f64.div) (call 2)) ...) ``` === ```wasm (module (type (;0;) (func (param i64 i64) (result f64))) (type (;1;) (func (param i64 i64) (result f64))) (type (;2;) (func (param f64) (result f64))) (func (;0;) (type 0) (param i64 i64) (result f64) (call 2 (f64.div (call 1 (get_local 0) (get_local 1)) (f64.convert_s/i64 (i64.sub (get_local 1) (get_local 0)))))) ...) ``` === ``` 0000000: 0061 736d ; WASM_BINARY_MAGIC 0000004: 0d00 0000 ; WASM_BINARY_VERSION ; section \"TYPE\" (1) 0000008: 01 ; section code 0000009: 00 ; section size (guess) 000000a: 03 ; num types ; type 0 000000b: 60 ; func 000000c: 02 ; num params 000000d: 7e ; i64 000000e: 7e ; i64 000000f: 01 ; num results 0000010: 7c ; f64 ; type 1 0000011: 60 ; func 0000012: 02 ; num params 0000013: 7e ; i64 0000014: 7e ; i64 0000015: 01 ; num results 0000016: 7c ; f64 ; type 2 0000017: 60 ; func 0000018: 01 ; num params 0000019: 7c ; f64 000001a: 01 ; num results 000001b: 7c ; f64 0000009: 12 ; FIXUP section size ; section \"FUNCTION\" (3) 000001c: 03 ; section code 000001d: 00 ; section size (guess) 000001e: 03 ; num functions 000001f: 00 ; function 0 signature index 0000020: 01 ; function 1 signature index 0000021: 02 ; function 2 signature index 000001d: 04 ; FIXUP section size ; section \"CODE\" (10) 000002e: 0a ; section code 000002f: 00 ; section size (guess) 0000030: 03 ; num functions ; function body 0 0000031: 00 ; func body size (guess) 0000032: 00 ; local decl count 0000033: 20 ; get_local 0000034: 00 ; local index 0000035: 20 ; get_local 0000036: 01 ; local index 0000037: 10 ; call 0000038: 01 ; func index 0000039: 20 ; get_local 000003a: 01 ; local index 000003b: 20 ; get_local 000003c: 00 ; local index 000003d: 7d ; i64.sub 000003e: b9 ; f64.convert_s/i64 000003f: a3 ; f64.div 0000040: 10 ; call 0000041: 02 ; func index 0000042: 0b ; end 0000031: 11 ; FIXUP func body size ... ``` === # JS API --------- ``` javascript var importObj = {js: { import1: () = console.log(\"hello,\"), import2: () = console.log(\"world!\") }}; fetch('demo.wasm').then(response = response.arrayBuffer() ).then(buffer = WebAssembly.instantiate(buffer, importObj) ).then(({module, instance}) = instance.exports.f() ``` === # メモリ ------------ * メモリアドレスが0から始まって飛びのない **リニアメモリ** + 命令で伸び縮み出来る + 将来複数のリニアメモリとか出てくるかも * メモリサイズは32bit(wasm32)か64bit(wasm64)が選べる + 現状はwasm32のみ + 1つのモジュールでメモリ4GiBバイトも使わないから普通は32bitで十分 * アドレッシングは `アドレス+オフセット` * アラインメントは必須ではない（した方が速い） * コード列のメモリは見えない * スタックスキャンも出来ない === # 例外とか ---------- * Trap -- WebAssemblyのインスタンスが異常終了する + 例えばメモリの範囲外アクセスとか * スタックオーバーフロー + オーバーフローするとインスタンスが異常終了する + 処理系/環境毎にスタック長は違う - non-determinism === # テーブル ---------- * 要素の配列的なもの + 整数インデックスでアクセス出来る * 今のところ関数を入れてindrect callするため * 将来的にはOSのハンドラとかGCの参照とか === # ローカル変数 -------------- * 無限にある型付きストレージ * 0 初期化 * 関数の引数もローカル変数に入る === # グローバル変数 --------------- * 型付きストレージ * 可変/不変がある * 不変Globにsetするとvalidationエラー * リニアメモリとは違うメモリ領域 === # import / export ----------------- * 他のモジュールから色々インポート出来る * 関数 * テーブル * グローバル変数 * リニアメモリ * 勿論exportも === # 一旦まとめ ------------ * WASMは1ファイル1モジュール * WASMには以下がある + 関数 - 関数内ローカル変数 + リニアメモリ + グローバル変数 + テーブル + importテーブル + exportテーブル === # 命令の話 ---------- * コントロールフロー * Call * パラメトリック * 変数アクセス * メモリ関連 * 定数 * 比較 * 数値 * 変換 * 再解釈 === # コントロールフロー ------------------- * `loop` + `br` (名前付き) * `block` + `br` (名前付き) * `br_if` or `br_table` * `if` + `else` + `end` * `return` * 等 === # コントロールフロー ------------------- * gotoがない + `br` はブランチじゃなくてブレイク * gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf) + loop, block, br, br_ifを使う * 高級言語から変換するなら `if` を使う + ifが2系統あることになる === # Call ------ * `call` * `call_indirect` + 関数テーブルを使った呼び出し + ダイナミックな関数ディスパッチに === # パラメトリック ------ * `drop` * `select` + 三項演算子相当 === # 変数アクセス -------------- * `get/set_local` * `get/set_global` * `tee_local` + スタックに値を残しつつset === # メモリ関連 ------------ * `{i,f}{32,64}.load{,8,16,32,64}{,_s,_u}` * `{i,f}{32,64}.store{,8,16,32}` * `current_memory` * `grow_memory` + メモリを増やす命令もある === # 定数 ------ * `{i,f}{32,64}.const` === # 比較 ------- * 各種 `eq`, `eqz`, `ne`,`lt`, `le`, `gt`, `ge` === # 数値 ------- * 四則(`i32.add`とか) * 論理(`i64.popcnt`とか) * 丸め,最{大,小}(`f32.ceil`とか) * ルート(`f64.sqrt`とか) === # 変換 ------ * `f32.convert_s/i32`とか * `i32.wrap/i64`とか === # 再解釈 -------- * `i32.reinterpret/f32`とか * ビットキャスト * ビットエンコーディングが定まってるのでwell-defined === # WASM吐こうとした話 === # 作ったやつ ------------- * なんかコンパイラ作ろうと思い立った * [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml) * とりあえずSMLのサブセット * Rust製 * 未完成 + 正月気抜いてたら進捗ダメでした === # やりたかったこと ------------------ * ブラウザで動くコンパイラ作ってみたい + Rustはemscripten通せる * WebAssembly面白そう * SML処理系作りたかった * 最適化書く練習 === # 中身 ------------ * パーサ、AST, HIR, MIR, LIR * LIRがレジスタマシンなのでそれをWASMに変換したい * オンメモリで生成するためにアセンブラ自作 + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs) + ブラウザで動かすのに必要 * 最適化はまだ === # コード生成 ----------- * (ほぼ)SSAの1変数 = 1ローカル変数 + どうせエンジン側でレジスタ割り当てするでしょ * スタックはほぼ使わない * gotoを構造化制御フローにする + 一応出来る + [Reloop](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf) + 何言ってるのかよく分からない + ステートマシンは勿論可能 * →自分で考えた * なんかつらいので詳解します * みんな基本ブロックとCFGは分かるかな？ === # blockと前方ジャンプ ------------ * `block` + `break` で前方ジャンプ * 閉じ括弧の位置にジャンプ * `block` の位置は自由 ===   (block ... (br 0)--+ ... | ) ===   (block ... ... ... (br 0)--+ ... | ) === # loopと前方ジャンプ ------------ * `loop` + `break`で後方ジャンプ + `loop` からの `break` はいわゆる `continue` * 開き括弧の位置にジャンプ * 閉じ括弧の位置は自由 ===   (loopbr 0)--+ ... )   ===   (loopbr 0)--+ ... ... ... )   === # ジャンプのクロス ------------------ * 単一gotoは割り当て出来る * 複数のgotoが入り組んだら？ === # 前前 ------ ``` [ ]--+ | | +--[ ] | | | | | [ ][ ] ``` === # 前前 ------ ``` (block (block ... (br 0)-+ ... | (br 1)-+-+ )[ ] | | | | | [ ]--+ | | +--[ ] ``` === # 後後 ------ ``` (loop[ ] ``` === # 後前 ------ ``` (block (loop[ ] | | | | | [ ] ","categories":["WebAssembly","Compiler"],"category_urls":["/categories/webassembly","/categories/compiler"],"date":"2017-01-22","title":"コンパイラの人からみたWebAssembly","url":"https://KeenS.github.io/slide/konpairanoninkaramitawebassembly/"},
  {"body":" Me  2011-04 - 2013-03 東京大学理科I類 2013-04 - 2015-03 東京大学理学部数学科(中退) 2015-04 - 2016-12 サイバーエージェント(エンジニア) 2017-01 - 現在 Idein Inc. (エンジニア)  Activities  2014-06 - 2017-01 Shibuya.lispの運営 2016-02 - 現在 Rustドキュメント翻訳プロジェクト 2013 ISUCON3 学生賞 2014 ISUCON4 学生賞  いくつかのOSSの開発者/コミッタ/コントリビュータ\nPublications  実践Rust入門 ［言語仕様から開発手法まで］ (技術評論社) 2019年5月8日発売 κeen，河野 達也，小松礼人 著 n月刊ラムダノート (ラムダノート) 2019年11月1日発売 κeen, 辻本和樹 著 Software Design 2021年9月号（技術評論社）2021年8月18日発売 第1特集4章、5章  SNS accounts  Twitter: @blackenedgold GitHub: KeenS GitLab: blackenedgold COOKPAD: κeen Qiita: blackenedgold SlideShare: blackenedgold zenn.dev: blackenedgold  Main Interests  Emacs Lisp Rust ML (Meta Language) 言語処理系(主にインタプリタ)  GC 最適化 CPU λ計算 継続  Linux システムプログラミング 数学基礎論  ","categories":null,"category_urls":[],"date":"2017-01-22","title":"About","url":"https://KeenS.github.io/about/"},
  {"body":"κeenです。たまにRustのモジュールが分かりづらいとの声を聞くので解説しますね。\n※ 2018版 も書きました。恐らくこちらの方が求める情報と思います。\nとりあえずサンプルプロジェクトを作ります。\n$ cargo new module エラいのは lib.rs と main.rs モジュールの話をする前にクレートの話をしないといけません。 クレートはRustのプログラムの一番大きな単位です。 大きく分けてライブラリを作るlibクレートと実行可能ファイルを作るbinクレートがあります。\nlibクレートならばlib.rsが、binクレートならばmain.rsがルートにあたるファイルです。ここから辿れるモジュールが全てです。プロジェクトにファイルが存在していてもこれらから辿れなかったらコンパイルされません。\nモジュールの作り方は3種類  ファイルの中にインラインで作る 1ファイルで作る 1ディレクトリで作る  のやり方があります。 1.はそんなに使われなくて、説明のために1ファイルにまとめたい時や、可視性でアレコレする時のテクニックなんかに使われます。\n2.と3.の境界はサブモジュールを持つかどうかです。\n2.のファイルで作る時は\n$ find src src src/lib.rs src/new_module.rs のように作っておいて、lib.rsの中を\nmod new_module; のようにmodで参照してあげれば使えます。\n3.のディレクトリの時もそんなに変わらなくて、lib.rsは変わらず、ファイルを\n$ find src src src/lib.rs src/new_module src/new_module/mod.rs のようにしてあげます。mod.rsの名前はこれでないといけません。丁度サブモジュールのnew_moduleにとってのlib.rsのような存在がmod.rsな訳です。\n兄弟モジュール同士の可視性 モジュールの身分 さて、次のように2つのモジュールを作ってみましょう。lib.rsにはmodule_aのみmod宣言しておきます。\n$ find src src src/lib.rs src/module_a.rs src/module_b.rs $ cat src/lib.rs mod module_a; これでmodule_a.rsに\nmod module_b; と書くと\n$ cargo build Compiling module v0.1.0 (file:///home/kim/Rust/module) error[E0432]: unresolved import `module_a` --\u0026gt; src/lib.rs:1:5 | 1 | use module_a; | ^^^^^^^^ no `module_a` in the root error: aborting due to previous error error: Could not compile `module`. To learn more, run the command again with --verbose. と怒られます。一番エラいのはlib.rsですから、身分の低い module_aではmod宣言出来ません。\n君の名は 同じ設定で、lib.rsにmodule_aとmodule_b両方をmod宣言しておきます。\n$ find src src src/lib.rs src/module_a.rs src/module_b.rs $ cat src/lib.rs mod module_a; mod module_b; この時、module_bがlib.rsから見た時とmodule_a.rsから見た時で名前が変わります。\nlib.rsから見た時は、以下の3つが使えます。\nuse ::module_a; // 絶対パス use module_a; // 省略絶対パス use self::module_a; // 相対パス selfというのは予約語で、ディレクトリでいうところの.に相当します。\nmodule_a.rsからは同じく3つが使えますが、相対パスが変わります。\nuse ::module_a; // 絶対パス use module_a; // 省略絶対パス use super::module_a; // 相対パス superも予約語で、..に相当します。 ファイルが同じディレクトリにいるので分かりづらいですが、libが1つ上の階層で、その下にmodule_aとmodule_bがぶら下がってる感じですね。\nおじさんと隠し子 次のように、サブモジュールを作ってみます。\n$src src/lib.rs src/module_a src/module_a/mod.rs src/module_a/submodule.rs src/module_b.rs $ cat src/lib.rs mod module_a; mod module_b; $ cat src/module_a/mod.rs mod submodule; さて、この時sumbmoduleから見たmodule_bの名前はどうなるでしょうか。もうお分かりかと思いますが、以下の3つです。\nuse::module_a;// 絶対パス usemodule_a;// 省略絶対パス usesuper::super::module_a;// 相対パス  じゃ、逆にmodule_bから見たsubmoduleはどうなるでしょうか。実は、module_bからsubmoduleは見えません（lib.rsからも見えません）。module_a1つで所帯を持っているので子であるsubmoduleを外に出すかはmodule_aの一存で決まります。今回は隠し子にしている訳ですね。いくら兄弟モジュールとはいえ家庭にまでは入り込めないのです。\n子供をちゃんと公開するには\n$ cat src/module_a/mod.rs mod submodule; となっていたモジュール宣言を\n$ cat src/module_a/mod.rs pub mod submodule; としてあげればOKです。そうするとmodule_bからも見えて、以下の3種類で参照出来ます。\nuse::module_a::submodule;usemodule_a::submodule;usesuper::module_a::submodule; 木箱の外から さて、今までは1クレート内での話でした。クレートの外から見るとどうなるでしょうか。\n新たにmain.rsを追加しましょう。先程 lib.rsとmain.rsがエラいと話しましたが、どちらも別々のクレートを作るのでmain.rsは完全にクレートの外です。\nこんな感じですね。\n$ find src src src/lib.rs src/main.rs src/module_a src/module_a/mod.rs src/module_a/submodule.rs src/module_b.rs $ cat src/lib.rs mod module_a; mod module_b; $ cat src/module_a/mod.rs pub mod submodule; まず、外部のクレートを参照するにはextern crateを書く必要があります。あとまあ、binクレートなのでmain関数も必要ですね。\n$ cat src/main.rs extern carte module; fn main() {} では、module_bはどういう名前で見えるでしょうか。見えません。一番エラいlib.rsがmodule_bをpubにしていないのでクレートの外からは見えなくなっています。見たければ、\n$ cat src/lib.rs mod module_a; pub mod module_b; のようにします。\nさて、これでmain.rsからどのように見えるかというと。\nuse ::module::module_b; use module::module_b; use self::module::module_b; のように気持的にルート直下にクレートがモジュールとして配置されたように見えます。\n家出 さて、同じようにlib.rsでmodule_aをpub modすればmodule::module_a::submoduleも参照出来るようになります。ところで、例えばmodule_aは外に出さずにsubmoduleだけを公開したい時にはどうしたらいいでしょうか。そんなケースあるのかと疑問に思うかもしれませんが、あります。同じクレートであってもpubにしないとサブモジュールにアクセス出来ないことを思い出して下さい。そうすると\npubmod submodule;pubmod internal_submodule_a;pubmod internal_submodule_b; みたいなケースが発生するのは想像出来ると思います。そういう時は、lib.rs側でどうにかいじれます。\n$ cat src/lib.rs mod module_a; pub mod module_b; となっていると思いますが、\n$catsrc/lib.rsmod module_a;pubmod module_b;pubusemodule_a::submodule; と、pub use を加えてあげることでmodule_aの下から出すことが出来ます。\nこれをmain.rsから使う時は\nusemodule::submodule; のように名字のmodule_aが取れます。\nさらに踏み込めば、useはasを使ってリネーム出来るので\n$catsrc/lib.rsmod module_a;pubmod module_b;pubusemodule_a::submoduleasmodule_c; のようにリネームuseしてあげれば\nusemodule::module_c; のように参照することも出来ます。完全に籍を外れて名前の上では別人ですね。\n実装する時の都合とAPIとして公開する時の都合が違うので公開用にいじれる作りになってるんですね。\nlib.rsとmain.rs 上ではlib.rsを使って説明しましたが、main.rsでも同じことが出来ます。\nさて、ここからはスタイルの話ですが、私がRustを書く時はmain.rsの中にmodを書くことはないです。必ずlib.rsを作って、そこでライブラリとしてまとめてからmain.rsで使います。「アプリケーションはアプリケーションを記述するための巨大なDSLとそれを使った小さな実装からなる」という思想ですね。明示的に境界を作ることで自然とAPIを設計出来るのでコードが整理しやすくなります。\nまとめ  lib.rsとmain.rsが一番エラい。 mod で「モジュールがある」宣言 pub mod で加えて上位のモジュールにも公開 selfとsuperの予約語 pub use で改名  力尽きてテストのためのモジュールの話が出来なかったのでドキュメントを読んでみて下さい。\n因みにこれのようにテクニックが詰まったlib.rsファイルなんかも存在するので参考にどうぞ。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2017-01-15","title":"Rustのモジュールの使い方","url":"https://KeenS.github.io/blog/2017/01/15/rustnomoju_runokirikata/"},
  {"body":"κeenです。みんなカスタマイズしてLinux使っているようなのであまりカスタマイズしてない私のものも紹介しますね。\n因みに私は会社でMac使ってたら使いにくすぎてVMに逃げたくらいのLinuxユーザです。家では勿論Linuxしか使ってないです。\nディストリ Ubuntu。定番。色々言う人がいるけど何も不満はない。\nウィンドウマネージャ（統合デスクトップ環境） Unity。デフォルト。\nIM uim-skk。何故uim-かというと最初にたまたまそれを使ったから。\nブラウザ FireFox。確かデフォルト。入れてる拡張はkeysnailのみ。\nTwitterクライアント 公式Web。新機能の追加が一番早くて便利。\nターミナルエミュレータ gnome-terminal。デフォルト。速いし簡単に背景半透明に出来るし何も不満はない。tmuxと一緒に使ってる。\nエディタ Emacs。デフォルトではない。毎日masterをコンパイルして使う。\nキーバインド変更 xmodmap + xremap。これ CF Linux向けの最強のキーリマッパーを作った - k0kubun\u0026rsquo;s blog。 CapsLockとctrlのスワップにxmodmapを、Emacs風バインドを作るためにxremapを使ってる。xremapは別になくてもどうにかなる。\nメーラ Thunderbird。確かデフォルト。でもUbuntuのパッケージは更新が遅いので手でインストールしてる。\nカレンダー Thunderbird + Lightening拡張。Googlカレンダーと同期出来るし便利。\nこのくらいかな？フォントもデフォルト。あとはSlackに公式クライアントだとか偶に音楽再生にrythmbox（デフォルト）だとか画像表示にeog（デフォルト）だとかPDF表示にevice（デフォルト）だとかファイラにnautilus（デフォルト）スクリーンショットにgnome-screenshot（デフォルト）だとかを使うけどこの辺は当たり前なので書かなくていいかな。\nということでそんなにカスタマイズしなくてもLinuxは便利なのでみなさん使いましょう。\n","categories":["Linux","開発環境"],"category_urls":["/categories/linux","/categories/%e9%96%8b%e7%99%ba%e7%92%b0%e5%a2%83"],"date":"2017-01-10","title":"頑張らないLinuxデスクトップ環境","url":"https://KeenS.github.io/blog/2017/01/10/linuxdesukutoppukankyou/"},
  {"body":"κeenです。本日を以ちましてIdein Inc.に入社したので報告します。\n退職エントリはこちら\n経緯  Lisp Meet Upで社長の@9_tiesさんと知り合う その他勉強会で何度か一緒になってよく喋るようになる オフィス訪問に誘われて行ったら入社を誘われる（7月末） 入社することにする（9月半ば） 入社（現在）  わさびずとideinに遊びに来たよ。噂のpi zero\nクラスタとかPEZYとかあった。熱い。 pic.twitter.com/MEc7qdosrk\n\u0026mdash; κeen (@blackenedgold) 2016年7月31日 \n結構前から水面下で話は進んでました。\n割と「PEZYに行くの？」という質問が多かったのですが中らずとも遠からずといったところでしょうか。PEZY Computingとも取引があったりする会社です。\nどんな会社？ 私が7人目（バイトを抜いたら6人目）の社員になる、少数精鋭なスタートアップです。全社員に1つのチャットで連絡が取れます。 この規模ながらフルタイムのリサーチャがいるなど、かなり技術寄りな会社です。創業者も全員技術者です。社員の中ではクソザコクラスになるので明日から人権があるか心配ですがどうにか上手くやっていきます。\n今3期目とのことです。\n社長に「なんて紹介したらいいですか」って言ったら「うーん、困るなぁ」と言われました（苦笑。 Big Pictureとしてはコンピュテーショナルセンサーを使って世の中に起きているあらゆる事象をソフトウェアで扱えるようにしたい、というもの。ざっくり言ってしまえばIoTの会社になるんですかね。 でもじゃあ電子工作ばっかやってるのかというとそういう訳でもなくて、例えばカメラから得られた画像から色々な情報を抜き出すために機械学習やらディープラーニングやらをやっていたり、さらにそれをセンサーデバイス（Rasp Piとか）上で走らせるために効率化したりとソフトウェア技術のウェイトがかなり大きいです。\n例えばニューラルネットワークの学習済みデータを最適化（軽量化）してさらにコンパイル（！！）して組込みデバイス上でも満足な速度で動かすための技術開発なんかをやっています。\nあるいはセンサーから取得したデータを使えるプラットフォームなんかも。\nどんな仕事するの？ 私の仕事もそういう文脈からきていて、例えばニューラルネットをコンパイルしてRasp PiのGPUで動かすだとか、あるいはもうちょっと特化したデバイス（ぼかしてる）のためのコンパイラを作るだとかの仕事になります。 自分で書いておきながらやっぱり「ニューラルネットをコンパイルする」っていう字面がパワーある。 今、（学習ではなくて予測に）使われているのはほとんどがモデルと実行器が分けらています。要はインタプリタなのでそれをコンパイルしてあげて高速に実行するというのが可能なんですね。 ニューラルネットの圧縮のために数学が必要そうな雰囲気で、数学出来ない私は震え上がってます。\n会社全体としてはデバイスの開発も一応やりつつ、データを処理するための技術開発、共同研究、技術開発も含めた受託案件、あるいは開発した技術を使った受託案件なんかもやっています。 かなり技術開発への投資が強いイメージですが、今期は黒字予定と案外バランスの取れた運営をしているようです（結構色々な会社が興味を持ってくれているようです。 センサーだとかの文脈になるのでお客さんはハードウェアの会社が多いようです。\n初日の感想は？ 会社が移転した（前のオフィスだと私のスペースがなかった）のでほとんど環境構築でした。\n環境構築してる pic.twitter.com/6HLHbnOmi6\n\u0026mdash; κeen (@blackenedgold) 2017年1月6日 \nオフィス引っ越し中 pic.twitter.com/MnrNUxxUP7\n\u0026mdash; y͛amaday͛ (@yamaday) 2017年1月6日 \n落ち着いたあとはQiita::Teamを全部読んでました。社長も技術者なので事業プランや資金計画（売り上げ）なんかもQiita::Teamに上がってるのが新鮮でした。\n社員に2名ほどRustをやってる人がいて「κeen君来たし仕事でRust使っていくかー」みたいな感じになりました。使えそうな案件があったら積極的に使っていきたいですね。\n結びに 前回転職祝いを沢山頂いたので今回は例のURLは控えさせて頂きます。 前回送りそびれたのでどうしてもという方は退職エントリの方から辿って頂けると幸いです。\nまた、Ideinではエンジニアを募集しています\n 募集職種  ソフトウェアエンジニア（画像処理） 画像処理に関する基本的な知識を持っている方（画像処理の実装経験がある方歓迎） ソフトウェアエンジニア（バックエンド） 分散システムの構築やDevOpsに興味があり、最新の技術の動向を追っている方。場合によっては自ら実装が出来る方 ソフトウェアエンジニア（フロントエンド） 最新の技術動向に明るく、移り変わりの激しい技術のコンテキストを理解して吸収でき、UXを考慮した実装が出来る方 ソフトウェアエンジニア（組み込み） 計算機を低いレイヤーまで理解し、ハードウェアの仕様を読み解いて必要機能の実装が出来る方 ソフトウェアエンジニア（言語処理系） 計算機アーキテクチャや数値計算アルゴリズムに精通しており、最適化コンパイラやプログラミング環境をフルスクラッチで実装出来る方  以下のスキルセットを持っている方を歓迎します。\n C++, Python, Haskell,Rust, etc\u0026hellip; Git（分散VCS） DevOps関連技術(Docker,Ansible,etc\u0026hellip;) GPU  すべての職種に一貫して、現在のスキルセットよりは以下に挙げるような事柄への知識や興味を優先します。\n アルゴリズムとデータ構造 計算機 プログラミング言語 ソフトウェア工学  待遇・給与 社保完備 月収60万円〜（正社員）\n 因みに私はポテンシャル採用されたタイプで「壁に当たっても自分で調べて乗り越えていけそう」だとか「コンパイラを書いてると心が折れそうになる瞬間があるけどそこで折れないような人が大事だ」とか言われました。頑張ります。\nということで皆様の応募お待ちしております！！\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2017-01-06","title":"Idein Incに入社しました","url":"https://KeenS.github.io/blog/2017/01/06/idein_incninyuushashimashita/"},
  {"body":"κeenです。先日同期と話しててQUICの中身ってあまり知らないよねってことでQUICの仕様（ドラフト）を読んだのでまとめますね。あまりまとめきれてませんが。\n※ドラフトは既に古くなっているのでこのブログの内容は現行では正しくない可能性があります。というか一部既に正しくないことが判明しています。ご注意下さい\n後で新しいドラフトを発見したので内容を書き換えました。とりあえずリンクを貼ってあるドラフトの内容までは反映出来ています。\n背景 仕様を読む前にQUICの背景から。 HTTP/2でHTTPにストリームという概念が入りました。 1つのコンテンツ毎に順にやりとりするのではなく、複数のコンテンツを並行して通信する仕組みです。\n# 今まで []--CCCBBBAAA--\u0026gt;[] # HTTP/2 []--ACCBCABBA--\u0026gt;[] 上の図でいえば例えばAのコンテンツがサーバの都合で遅くてもBやCのコンテンツが支える（Head of Line Blocking）ことなくクライアントに届きます。\nところで、この通信はTCP上で行われています。TCPは到達順序を保障するので例えば1パケット欠損したらそれ以後のパケットは（実際にはクライアントに到着しているにも関らず）待たされます(TCP Head of Line Blocking)。\n[]--ACCBCABB-X--\u0026gt;[] この図でいえばAのパケットが欠損してますが、HTTP/2的にはAは無視してBやCのコンテンツをユーザに届けることは可能な訳です。 この辺を改善したいというのがQUICのモチベーション。\nもうちょっと言うとTCPの3way hand shakeだとかその上のTLS hand shakeだとかのオーバーヘッドの削減の目的もあります。 TCPやTLSもRTTを減らそうと努力はしていますが、もっと抜本的な解決が必要とのことです。\nということでHTTP/2に特化してTCP+TLSを置き換えるための通信プロトコルとしてUDPベースのQUICが産まれました。\nここまではよくあるQUICの説明。でも、これだけだと情報が少なくてもやもやしますよね。\n HTTP/2に特化とはいうけどどこまで特化してるの？他のアプリケーションで使えないの？ どうしてTLSも統合してしまったの？分離出来なかったの？ UDPベースでどうやってコネクションの維持や輻輳制御してるの？ 上記以外でQUICに特徴はないの？  などなど。これらの疑問を解決すべくQUICのドラフトを読んでいきます。\nQUIC これを読んでいきます。Expires July 16, 2016とのこと。\nイントロ QUICはHTTP/2のストリーム分割やフローコントロール、TLSのセキュリティ、TCPのコネクションセマンティクスや信頼性、輻輳制御を提供します。\nQUICはUDPベースの通信プロトコルなので、完全にユーザーランドで完結します。 これは重要な話で、レガシーなネットーワーク中間機器の上でもちゃんと通信出来ることを意味します。 仕様化する前に実証実験をする上でとても重要な性質です。\n用語  クライアント: QUICコネクションを開始する端 サーバ: QUICコネクションを受け付ける端 エンドポイント: サーバ、またはクライアント ストリーム: QUICコネクションの論理チャネル内を双方向に流れるバイト列の流れ コネクション: 単一の暗号コンテキスト下のQUICエンドポイント同士のやりとり。複数のストリームを持つ。 コネクションID: QUICコネクションのID QUIC Packet: QUICでパース可能な有効なUDPペイロード。QUICのパケットサイズとはUDPのペイロードのサイズを指す。  概要 QUIC(+HTTP/2)のTCP+TLS(+HTTP/2)に対する利点は以下を改善することです。\n コネクション確立のレイテンシ 柔軟な輻輳制御 Head of Line Blockingなしに多重化 ヘッダやペイロードが認証/暗号化されている ストリーム及びコネクションフローコントーロール 前方エラー訂正 コネクション移行  思ったより特徴ありますね。コネクション移行とか面白そう。 さて、それぞれ見ていきます。忙しい人は概要まででもそれなりに役立つでしょう。\nコネクション確立のレイテンシ 通常TCP+TLSだと1-3RTT必要なのに対してQUICは多くの場合0 RTTでコネクション確立出来ます。つまり、いきなりデータを送れる。\n0 RTTで接続出来ない場合、つまりハンドシェイクが必要な場合もある訳ですが、ハンドシェイクの詳細はQUIC Cryptoの方に投げられています。 さらにQUIC CryptoはTLS 1.3に置き換えられる予定なのでほぼTLS 1.3のハンドシェイクだと思っておいて良いようです。\n柔軟な輻輳制御 QUICはプラガブルな輻輳制御を持っており、TCPより豊富なシグナルがあるのでTCPの輻輳制御アルゴリズムより賢く振る舞うことが出来ます。 とはいっても現状の（ドラフト時点の）GoogleではTCPのアルゴリズムを流用しており別のアプローチを実験中とのこと。\n詳細はここにあるとのことでしたが、リンク切れなのか真っ白なページしかありません。\nさて、シグナルが豊富とのことでしたが、1例を出すとパケットの元のものと再送されたものでシーケンス番号が異ります(私はTCPの詳細を知らないのでよく分かりませんが輻輳制御のためにシーケンス番号を振っているのでしょう)。 元と再送のものを区別出来るようになるのでTCPの曖昧性問題（というのがあるのでしょう）を解決出来るとのこと。\nまた、パケットを受け取ってからackを送るまでの時差と単調増加するシーケンス番号も一緒に送るのでRTTを計算することが出来ます。\n最後に、ACKが256 NACKまでサポートする（らしい）のでTCPのSACKよりもリオーダリングに弾力性があり、パケロスやリオーダリングがある環境下でもパケット密度を高めることが出来るとのこと。これは後程記述があります。\nこの辺はTCPの輻輳制御から勉強しないと利点が分からないですね。宿題。\nストリーム及びコネクションフローコントーロール 順番が前後しますがストリームの話。そういえばHTTP/2にバックプレッシャーありましたね。\nストリームレベル、コネクションレベルでのフロー制御が出来ます。 ほぼHTTP/2と同等のストリーム制御が可能です。\nストリームレベルの制御は、まず、受け取り側がストリーム内のデータのどのオフセットまでを受け取るかを広報します。 ストリームにデータが届いたら、WINDOW_UPDATEのフレームを投げて、受け取り可能なオフセットを更新します。\nコネクションレベルの制御は、ストリーム合計でのバッファを制限するために使います。 単純にストリームでやっている制御をコネクションレベルでやるだけです。\nまた、TCPにあるようにreceive-windowのオートチューニングもやるそうです。\nこの辺、HTTP/2に合わせた仕様なんですね。\n多重化 TCP head of line blockingしない。因みにHTTP/2のヘッダはHPACKで圧縮して送るのでここはhead of line blockingします。\nヘッダやペイロードが認証/暗号化されている そもそもの話、TCPは平文で通信するのでreceive-windowの更新やらシーケンス番号を上書きしたりやらの攻撃が可能です（尤も、通信の最適化のために中間機器で行うこともありますが）。\nQUICは一部のヘッダを除き暗号化されています。暗号化されていない部分も受理側によって認証されるのでインジェクションを阻止出来ます。\nここでTLSも統合している理由が分かりました。認証のためにTLSが必要なんですね。\n前方エラー訂正 Forward Error Correction (FEC)。シンプルなXORベースのFECをやるそうです。FECグループ内の1パケットがロスしてもFECパケットから復元出来るとのこと。すごい。\nコネクション移行 TCPは4-tuple(source address, port, destinacion address, port)でコネクションを判別しますが、それだと例えばスマホが電話通信（って呼称でいいのかな？）からWifiに切り替わった時にIPが変わりますし、NAT下でポート番号が変わることもあるので突発的にコネクションが切れてしまう訳です。\nQUICはクライアントがランダム生成した64bitのコネクションIDで識別します。 じゃあ、コネクションIDを被せにいったらハイジャック出来るじゃんと思えますが、TLSを前提にしているのでクライアント認証も自動でついていて、その辺には耐性があります。\nパケットタイプとフォーマット 2種類の特殊パケットと2種類の通常パケットがあります。バージョンネゴシエーションパケットとパブリックリセットパケット、フレームパケットとFECパケットです。\nパケットはIPの断片化を防ぐためにパスのMTU（Message Transfer Unit）に収まる必要がありますが、MTUの発見はまだWIPだそうです。 今とのころIPv6で1350byte、IPv4で1370byteを使っているとのこと。\nバブリックヘッダ 全てのQUICパケットにつくヘッダです。パブリックの名の通り暗号化されません。\n長さは2-19byteの間になります。\n 0 1 2 3 4 8 +--------+--------+--------+--------+--------+--- ---+ | Public | Connection ID (0, 8, 32, or 64) ... | -\u0026gt; |Flags(8)| (variable length) | +--------+--------+--------+--------+--------+--- ---+ 9 10 11 12 +--------+--------+--------+--------+ | QUIC Version (32) | -\u0026gt; | (optional) | +--------+--------+--------+--------+ 13 14 15 16 17 18 +--------+--------+--------+--------+--------+--------+ | Packet Number (8, 16, 32, or 48) | | (variable length) | +--------+--------+--------+--------+--------+--------+ 軽く説明しますね。それぞれの詳しい内容は仕様を読んで下さい。\n public flagsにパケットタイプなどが入っています。 コネクションIDが64bitだと過剰な場合はネゴって短かくすることも可能です。 パケット番号はフレームパケットに付与されます。1から始まり1づつ大きくなります。 パケット番号の下位64bitはTLSのnonceの一部に使われます。合理的ですね。 内部的には64bitでシーケンス番号を管理するけどパケットに載せるのは48bitまで。 48bit(n bit)でオーバーフローした時の曖昧性排除のために2^46個(2^(n-2)個)までしか同時にパケットを送れない シーケンス番号が2^64-1に逹したらシーケンス番号のリミットでコネクションクローズが走る  パケットタイプを判別するフローチャートが載っていたので引用しますね。\nCheck the public flags in public header | | V +--------------+ | Public Reset | YES | flag set? |---------------\u0026gt; Public Reset Packet +--------------+ | | NO V +------------+ +-------------+ | Version | YES | Packet sent | YES | flag set? |---------\u0026gt;| by server? |--------\u0026gt; Version Negotiation +------------+ +-------------+ Packet | | | NO | NO V V Regular Packet Regular Packet with QUIC Version present in header スペシャルパケット バージョンネゴシエーションパケット サーバからのみ送られます。\n 0 1 2 3 4 5 6 7 8 +--------+--------+--------+--------+--------+--------+--------+--------+--------+ | Public | Connection ID (64) | -\u0026gt; |Flags(8)| | +--------+--------+--------+--------+--------+--------+--------+--------+--------+ 9 10 11 12 13 14 15 16 17 +--------+--------+--------+--------+--------+--------+--------+--------+---...--+ | 1st QUIC version supported | 2nd QUIC version supported | ... | by server (32) | by server (32) | +--------+--------+--------+--------+--------+--------+--------+--------+---...--+ 特に順序に言及がないのでクライアントは良い感じに新しいやつ選ぶんですかね。\nパブリックリセットパケット コネクションをクローズしようとしているのが本当に正しいクライアントなのか証明するための情報が載せられます。詳細は仕様を読んで下さい。\n 0 1 2 3 4 8 +--------+--------+--------+--------+--------+-- --+ | Public | Connection ID (64) ... | -\u0026gt; |Flags(8)| | +--------+--------+--------+--------+--------+-- --+ 9 10 11 12 13 14 +--------+--------+--------+--------+--------+--------+--- | Quic Tag (32) | Tag value map ... -\u0026gt; | (PRST) | (variable length) +--------+--------+--------+--------+--------+--------+--- 通常パケット 通常パケットのペイロードは暗号化/認証されます。パブリックヘッダは暗号化されませんが認証されます。 通常パケットはPrivate Flagsから始まるプライベートヘッダを持ちます（そこからが暗号化されます）。\n 0 1 +--------+--------+ |Private | FEC (8)| |Flags(8)| (opt) | +--------+--------+ このあとにAEAD (authenticated encryption and associated data)、つまり認証/暗号化されたペイロードが続きます。\nフレームパケット プライベートヘッダに続いてこんな感じのデータが続きます。\n+--------+---...---+--------+---...---+ | Type | Payload | Type | Payload | +--------+---...---+--------+---...---+ FECパケット プライベートヘッダに続いてこんな感じのデータが続きます。\n+-----...----+ | Redundancy | +-----...----+ QUICコネクションのライフサイクル コネクションの確立 クライアントがバージョン付きでデータを送って、サーバが処理出来るならそのままレスポンスを返してコネクション成立です。 もし処理出来ないなら、バージョンネゴシエーションパケットを送り返して、クライアントはそこから1つバージョンを選んで再送します。サーバから通常レスポンスが返ってきたらコネクション成立です（成立するまで繰り返します）。\nダウングレード攻撃を避けるためにハンドシェイクにバージョン情報を載せたり頑張るようですが、細かいので仕様を読んで下さい。\nデータ転送 多くは概要で説明した通り。 暗号化ハンドシェイクも含めてストリーム内でデータをやりとりしますが、ACKはQUICパケット単位です。\nシーケンス番号は輻輳制御を統合するためにコネクションを通して同じ番号空間を共有します。\n詳しくは付設のドキュメントを読めと書いてますが、リンク先が真っ白です。\nストリームのライフサイクル ストリームはデータをストリームフレームに分割してデータ転送します。 ストリームフレームは互いに順序逆転可能です。 ストリームの生成/クローズはサーバ、クライアント両方から出来ます。 ほとんどHTTP/2のストリームと同じですね。\nストリーム生成は特にネゴる必要なく簡単に可能です。ただ、ストリームIDが衝突しないようにサーバが作る時は偶数、クライアントが作る時は奇数を使います。 0は無効、1は暗号化ハンドシェイクのために予約、3はHTTPヘッダの通信のために予約とされています。ヘッダだけは順序保障が必要なんですね。 他の細かい規約は仕様を見て下さい。\n一旦ストリームが開いたらデータ転送に自由に使えます。\nストリームの終了には3種類あります。\n 普通の終了: 双方向通信なのでFIN bitを立てて送信した後のhalf-closeとかの概念があります。 突然の終了: 何かしらのエラーがあった時などにRST_STREAMフレームを送ると強制終了出来ます。 コネクションが終了した時: まあ、当然ですね。  コネクションの終了 コネクションの終了にも2種類あります。\n 明示的な終了: CONNECTION_CLOSEを送ることでコネクションを終了出来ます。 暗黙的な終了: タイムアウト（デフォルト30秒）したらクローズします。通常はCONNECTION_CLOSEを送りますが、モバイルで電波をonにしたくないなどの理由があればsilent closeも可能です。  それ以外に、PUBLIC_RSTでコネクションをクローズ出来ます。TCPのRST相当（だそう）です。\nフレームタイプとフォーマット 前述の通りフレームパケットにはフレームが入っています。フレームタイプ毎にデータの解釈が変わります。 1フレームは必ず1パケットに収まる必要があります。\nフレームタイプ 特殊フレームと通常フレームがあります。\n特殊フレームは以下。\n+------------------+-----------------------------+ | Type-field value | Control Frame-type | +------------------+-----------------------------+ | 1fdooossB | STREAM | | 01ntllmmB | ACK | | 001xxxxxB | CONGESTION_FEEDBACK | +------------------+-----------------------------+ 通常フレームは以下。\n+------------------+-----------------------------+ | Type-field value | Control Frame-type | +------------------+-----------------------------+ | 00000000B (0x00) | PADDING | | 00000001B (0x01) | RST_STREAM | | 00000010B (0x02) | CONNECTION_CLOSE | | 00000011B (0x03) | GOAWAY | | 00000100B (0x04) | WINDOW_UPDATE | | 00000101B (0x05) | BLOCKED | | 00000110B (0x06) | STOP_WAITING | | 00000111B (0x07) | PING | +------------------+-----------------------------+ これらのタイプについて仕様に載っている順に軽く説明します。詳しくは仕様を読んで下さい。\n STREAM: 暗黙的にstreamを作るのにもデータを送るのにも使います。 ACK: ackです。受け取った最大シーケンス番号とそれまでで欠損している番号のリストを送ります。前述の通り受理からACKまでの時差を入れたりと複雑なので仕様を読んで下さい。 STOP_WAITING: 特定以下のシーケンス番号のパケットを待たないように指示します。 WINDOW_UPDATE: コネクション/ストリームいずれかのウィンドウ余白を通知します。Stream ID 0がコネクションレベルのアップデートです。 BLOCKED: バックプレッシャーでこれ以上データを送信出来ない時に送ります。informational frameです(ほぼデバッグ用とのこと)。 CONGESTION_FEEDBACK: experimentalで、not usedとのこと。 PADDING: 0x00で埋められたデータを保持します。パケットをMTUまで埋めるのが目的なのかな？ RST_STREAM: ストリームの異常終了用。 PING: 生きてる？って訊くやつです。これを受けたらACKを返します。デフォルトで15秒毎に送ります。 CONNECTION_CLOSE: closeを通知するやつです。 GOAWAY: コネクションを止めるよ通知です。近くcloseするのでデータ送るのやめなよという通知です。新たなstreamが作れなくなります。  QUICの通信上のパラメータ ハンドシェイクでネゴシエートすべきパラメータの列挙です。\nRequired  SFCW - Stream Flow Control Window: ストリームレベルのコントロールフローウィンドウサイズ(バイト単位)です。 SFCW - Connection Flow Control Window: コネクションレベルのコントロールフローウィンドウサイズ(バイト単位)です。  ほとんどルー語ですね。\nOptional  SRBF - Socket receive buffer size in bytes: CWNDを受け取りバッファくらいに指定したい場合があるらしいのでそれ用。 TCID - Connection ID truncation: クライアントのエフェメラルポートが単一コネクションにしか使われないと分かっている場合に便利らしいです。 COPT - Connection Options are a repeated tag field: 実験的パラメータだそうです。  プライオリティ HTTP/2のものを使うそうですが、まだ実装してないとのこと。\nQUIC上のHTTP/2 いくつかHTTP/2と同じ機能を提供していますが、HTTP/2がQUICを使う時にどう統合するかのお話です。\nストリームマネジメント QUICが代替機能を提供するのでHTTP/2レイヤで扱う必要はありません。HTTP/2のストリームIDはそのままQUICのストリームIDになります。\nヘッダー圧縮 Stream ID 3で送ることになっている（QUICの仕様でHTTP/2のヘッダを扱うことになっている）。のでそれを使います。\nHTTP/2ヘッダのパース ヘッダのパースはHTTP/2の仕様に従います。\n永続コネクション コネクションという概念がないのでHTTPにある\u0026rdquo;Connection\u0026rdquo;ヘッダが意味をなさない。ので、HTTPレベルでのコネクションハンドリングはしません。\nこれ、\u0026rdquo;Connection: upgrade\u0026rdquo;はどうするんですかねって思ったら次に書いてました。\nHTTPでのQUICネゴシエーション クライアントが普通のHTTPでアクセスした時にサーバはQUICを使いませんか、とネゴシエーションすることが出来ます。それが\n\u0026ldquo;Alternate-Protocol: 123:quic\u0026rdquo;\nです。同じホストの123ポートにQUICプロトコルでアクセスしにいきます。 中間機器がUDPをブロックすることも考えてTCPにgraceful fallbackしろ、と書かれてます。\nハンドシェイクプロトコルへの要求 ハンドシェイク自体はこのドキュメントでは扱ってませんが、ハンドシェイクが満たすべき性質を書いています。\n 0-RTTでのコネクション確立 ソースアドレスのなりすまし対策 クライアントからソースアドレストークンが不透明なこと。トークンにいくつかのクライアント情報を埋め込むため。 通信パラメータのネゴシエーション 証明書の圧縮。REJも1350bytesに収めたい。 サーバコンフィグのアップデート  以上が仕様の主だった記述です。\nまとめ  HTTP/2に特化とはいうけどどこまで特化してるの？他のアプリケーションで使えないの？\n→ ストリームやHTTP/2ヘッダなどが統合されているのでかなり扱いづらい。 どうしてTLSも統合してしまったの？分離出来なかったの？\n→ クライアント認証のために必要だった。TLS1.3からは分離出来る（？） UDPベースでどうやってコネクションの維持や輻輳制御してるの？\n→ コネクションはコネクションIDで維持。輻輳制御は別の仕様（アクセス不可）に書いてある 上記以外でQUICに特徴はないの？\n→ 柔軟な輻輳制御、FEC、コネクション移行など  新たに湧いた疑問\n ロードバランシングどうするんだろう。ミドルウェアレベルだとConnection ID見て振り分けるとして、アプリケーションレベルだとRubyとかでよくあるlistenしてforkしてacceptするようなやつは破綻しないかな。そもそもQUICを使わない？ Connection IDが衝突したらどうなるんだろう。REJするのかな。仕様に書いてない。 いくつかの仕様（HTTP/2ヘッダ）とかを無視して別のアプリケーションで使えないかな。あるいは想定してないのかな。  宿題:\n TCPについても調べる。特に輻輳制御回り。 QUICの輻輳制御について調べる。 TLS1.3との統合について調べる ","categories":["QUIC"],"category_urls":["/categories/quic"],"date":"2017-01-02","title":"QUICの中身が分からないから仕様読んでみた","url":"https://KeenS.github.io/blog/2017/01/02/quicnonakamigawakaranaikarashiyouyondemita/"},
  {"body":"κeenです。毎年これやっていく。個人的に注目していきたい技術と飛び込んでみたい技術書いく。\nあくまで個人的な内容。\nWebAssembly ブラウザ上で動く仮想アセンブラ。ブラウザ上でのJSの高速実行はブラウザでの至上命題である。 JIT技術を各ブラウザベンダが切磋琢磨していたがそれでも限界があるのでasm.jsなんかが産まれた。 これは例えば\nfunction geometricMean(start, end) { start = start|0; // start has type int  end = end|0; // end has type int  return +exp(+logSum(start, end) / +((end - start)|0)); } のようにx|0と書くとxが整数であることを表わす、などとしてJSのサブセットで型情報も付与出来るようにしたものだ。冗長なので人の手で書くことは意図していない。 これはある程度上手くいって、emscriptenのようにLLVMからjsへのコンパイラでも使われている。\nそれでもまだ問題がある。1つに、JSよりも冗長な記法を使っているためファイルが嵩張る点。ロード時間やパース時間が長くなる。そもそも人の手で掛かないならバイナリフォーマットでもいい筈だ。 そしてもう1つに低レベルな処理、例えばSIMDなんかは扱えない点。\nWebAssemblyはこれらを解決する。仮想的な機械語でバイナリフォーマットがあるので低レベルなことが（将来）出来てコンパクトになっている。 計算モデルはスタックベースのマシンになっている。メモリや関数テーブルなどもある。\n(module (type (;0;) (func (param i32 i32) (result i32))) (func (;0;) (type 0) (param i32 i32) (result i32) get_local 0 get_local 1 i32.add) (export \u0026#34;addTwo\u0026#34; (func 0))) 多くの人にとってWebAssemblyは意識して関るものではなく、emscriptenの吐くコードが効率的になる、程度のものだろう。 私はコンパイラを作る人なので意識する必要がある。 WebAssemblyにはundefined behaviourがないだとかThread API、 SIMD APIなどが入る予定だとかがあるのでLLVM経由で吐くよりも直接吐いた方が面白い。\n少し追っていきたい。\nQUIC HTTP/2のための代替TCP。HTTP/2はもうリリースされてるので次はQUICを。 HTTP/2は1コネクションを複数のstreamに分割するが、stream内での到達順序保障は必要なもののstream同士ではそれが不要なのでTCPの到達順序保障が過剰要求になってしまう。 それを緩めるためにUDPベースでプロトコルを作ったのがQUIC。まあ、他にも色々改善点はあるが。\nこれも基本的にはあまり追う必要はないが、自分の使いたい言語で実装がなかったら自分で実装することになる。 まだその辺の環境が整っていないので今後どうなるか注視する必要がある。\nIdris 依存型のある言語。今年もRustに忙しい可能性があるが、ちょっとIdrisに興味が湧いた。 常々「多相があって正格評価で高階関数を簡単に扱えてサブタイピングのない、C FFIやThreadを扱える言語」を捜していて、それがATS2だったりSML#だったりRustだったりした。 最近はRustに落ち着いたが、今度は低レベルな部分、「C FFIやThreadを扱える」がなくてもいいから依存型が入ってる言語が欲しくなった。ATS2は置いといてIdrisかなーと。\n生の依存型だとつらいかな、と思っていたらtacticもあるようだったので機会があればやってみたい。\nCF プログラミング言語 idris - wkwkesのやつ\nLean MSRで開発されている定理証明支援系。よく「Coqでいいじゃん」「Agdaは？」と訊かれるが、オンラインチュートリアルが良さげだったのと、Emacsから使えるのと、 RustからLeanへのトランスレートをやっている人がいたので興味湧いた。 そもそもCoqをある程度やってからにしろとは自分でも思う。\nCoq 定理証明支援系。去年も上がっていたが、今年は酉年なので。「Agdaは？」。知らん。\nFinagle RPCのクライアント/サーバフレームワーク。RPCをやる時にいくつか問題が出る。 1つはペイロードがRPC毎に違うのでフレームワークが定まりづらい点。 もう1つはロードバランシングがしづらい点。 ロードバランシングの方に言及しておくと、RPCをやる時は大抵コネクションを張りっぱなしなのでTCPロードバランサが使えない。 例えば順番にサーバを起動していくと最初に上がったサーバにコネクションが集中して以後バランスされない。\nこれを解決するのがFinagleで、クライアントが全てのサーバにコネクションを貼って、クライアントサイドでロードバランシングをする。 さらにクライアントが複数のサーバを知っているのでサーバがエラーを返したら別のサーバにリクエストを投げることも出来る。 ペイロードの話は多相型で解決する。パーサとかその辺も含めたフレームワークになっている。\nTokio FinagleのRust版。Rustは非同期IOに強いと思っているのでTokioがリリースされたらそこら辺のHTTPフレームワークも非同期化するのではと思っている。\nTiDB 分散スケール可能なSQL DB。Rust製。Google F1を参考に作られているらしい。 ストレージエンジン自体はRocksDBを使っていて、その上に分散合意、MVCC、トランザクションを載せてさらにそれにSQLレイヤー、MySQLプロトコルレイヤーを載せている。\nアーキテクチャについては上の画像を引用したこの記事が詳しい。\ntantivy 全文検索エンジンライブラリ。Rust製。アーキテクチャやアルゴリズムはApache Luceneを参考に作られているらしいのでだいたいそのレイヤーのライブラリと思ってもらえれば。\nRust製なのでインデックスの構築が速いのが一つの特徴。今後、自前でElastic SearchやApache Solrのようなレイヤーを作るのかLuceneの置き換えを狙ってJava APIを提供するのかは不明。\n注目したい理由はベースで使っているfstライブラリの紹介記事が気に入ったから。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2017-01-01","title":"2017年注目していきたい技術","url":"https://KeenS.github.io/blog/2017/01/01/2017nenchuumokushiteikitaigijutsu/"},
  {"body":"κeenです。年始に2016年注目していきたい技術 | κeenのHappy Hacκing Blogってのを書いたので雑に振り返ります。あと個人的な一年の総括を。\n※個人メモなので雑多な記述が多いです。\nApache Drill ちょっとづつ進化してるようだけどそこまで広まってる気配なし。因みに自分はチーム移動で使う用事がなくなったのであんまり使ってない\nRust めっちゃ使った。大分進化してる。ハンズオンのチュータやったりLT会の玄人枠で発表したりもした。あと年明けにハンズオン第2回のチュータやる。\nApache Kafka めっちゃ使った。便利。道具箱の中身が増えた。便利。\nFloki 5月で開発停止したっぽい。残念。\nRobotS 開発は続いてるようだけど流行ってはない。うーん、アクターいけると思ったんだけどなぁ。\nRedox 開発は継続中。ISOのリリースとかもあったしそれなりに進歩はしてる。多分もうちょっとウォッチ期間が必要。\nATS2 使ってない。一回コンパイラのバグ踏んじゃって萎えてその後はRustばっか使ってる。面白いんだけどなぁ…\nR チーム移動で用事がなくなったのであまり使ってない。 一応それなりには使ったけどあんまりRのこと覚えきれてない。例えるならEmacs初心者がEmacs Lispのスニペットをコピペでどうにか使ってるくらい。\n異常検知 チーム移動で(ry\nCoq それなりにやった。ソフトウェアの基礎のサブタイプまでやった。ProofGeneralのバグはGitHubにある方のProofGeneralを使ったら解決した。あと#readcoqartにも何度か参加した。\nIsabelle 一応チュートリアルを少しやった。あと社内勉強会で発表もした。Isabelle 2014までしかProofGeneralで使えないのでちょっと厳しくなってやらなくなった。つらい。\nいい加減Emacs以外のプラットフォームも使えるようにならないとなー。\nFortran やってない。1ﾐﾘも触ってない。本当はある程度入門したらFortranコンパイラでも作るかって気分だったけどつらいらしいのでやらなくてよかった\nじゃ、個人的総括。まず、個人ブログはこのエントリ含めて48。週1ペース守れなかった。\n 2016年注目していきたい技術 ATS2の観が整理出来た Rustといえどリソースの解放は注意 SML#のpthreadバインディング作った Isabelleに入門した 独学でプログラミングをやってきた中で良かった技術書50選 プログラミングを独学する時こそインプットを増やした方がいい Lisp Meetup3周年に寄せて Rustのパッケージをcrates.ioに登録する Common Lispで高速行列演算 Nexus 5にUbuntu Touchのインストール 分散VCSのモデル、あるいはPijulについて readlineの作り方 Bind Addressの意味がようやく分かった druidというリアルタイムデータ分析ツールを知った RustのHigher-Kinded type Trait Rustのゼロコスト抽象化 テストについて考えてみた リージョンとRustの返り値 Mirah関連ツールまとめ LXDがリリースされたらしい RustでベアメタルRaspberry PiのLチカ cargo-profilerを試す multirustが非推奨になったようなのでrustupに移行する Rustの所有権/ミュータビリティの分割 Container Desgin Patterns シェル芸十八般 私がコードを書くときテストは書かない mirah 0.2がリリースされました。 Rustでシェル作った Pijulのインストールが難易度高いので解説する Rustのクロージャ3種を作って理解する SMLでモナド VMwareのUbuntuを16.10にしたら起動しなくなった Rustの型レベルLispっぽいの作った Rustの関連型の使いどころ SML#をUbuntu 16.10で動かす サイバーエージェントを退職しました 4年間続いたShibuya.lispのLispMeetUp Rustでバイト列を扱う時のtips マクロやコンパイラプラグインの実装方法色々 Rustのプロセス 新しいコンパイラバックエンドcretonne Rustのstructとtraitって似てるよね Rustの所有権、ライフタイム、参照、型、しがらみ Rustのライフタイムを使ったスコープ解析 気付いたらRustの環境構築がかなり楽になってた 2016年注目していきたかった技術の振り返りと個人的振り返り  スライドは15。月1以上のペースだった。意外。ほとんど社内のScala勉強会で発表してるっぽい。\n HAMT ~ イミュータブルで高速なハッシュマップ ~ ClojureでSSPを作った話 Rustとは何か。どんな言語か。 ビッグデータしないDrill、ローカルで快適に使うために SMLで函数型的正規表現マッチ テストについて、Scalaと。 高速な継続ライブラリに向けて DOT/dottyについて調べてみた Socket on SML# 型クラスを越えて 正しいScalaのコードが欲しい Scala 2.12.0変更点 Rustの話とリソースの話 Rustで非同期Thriftしたい SchemeでClassとProtocol  その他外部に投稿したものは13。これも併わせたらブログはギリギリ週1ペースかな。仕事関連だったり仕事中に思い付いてブログにアクセス出来ないのでQiitaに投げたものが多い。\n Rustのドキュメントの翻訳プロジェクトを開始します。 - Qiita 正規表現の先読み/後読みを「絞り込み」と理解してみる - Qiita 一瞬でシェルスクリプト作れるシェル関数作った - Qiita sedの-iオプションの非互換 - Qiita Rustでサイコロで同じ目が100回連続で実際に出るか - Qiita POSIXシェルで変数がセットされているか検査するイディオム - Qiita ICFP及び関連イベント参加レポート – Haskell Day – | Tech Blog ICFP及び関連イベント参加レポート – ICFP併設ワークショップ – | Tech Blog ICFP及び関連イベント参加レポート – ICFP 1日目 – | Tech Blog ICFP及び関連イベント参加レポート – ICFP 2日目 – | Tech Blog ICFP及び関連イベント参加レポート – ICFP 3日目 – | Tech Blog ICFP及び関連イベント参加レポート – 併設ワークショップ2日目 – | Tech Blog ICFP及び関連イベント参加レポート – 併設ワークショップ3日目 – | Tech Blog  さて、OSSだと雑なスニペットとかもGitHubに上げてるのでカウントが難しいけど、主だったものだと\n airflowのSSH Execute Operatorを書いた Apache DrillのEmacs Mode作った（リリースしてない） Rustのfile_logger作った file_loggerと一緒に使うためにrotate_file作った（リリースしてない） インターン向けに作ったSSPを公開した。 SML#のpthreadバインディング作った。多分64bitで動かない。 SML#のsocketサポー作った。まだメモリ管理回りで処理系とのやりとりに上手くいってないので完成してない。 Rustでシェル作った。雑に動く。 TokioのThrift対応フレームワーク作成中。Tokio側がリリースされたらこちらもリリース出来るくらいの進捗でやっていきたい。 Rust公式ドキュメントの翻訳一応1.6は完了。今1.14まで来てるので更新せねば…。 なんか適当なML風言語のコンパイラ作り始めた。年内にコード吐くまでやりたかったけど最後の数日サボってしまったので間に合わない。 コンパイラのためにWebAssemblyをインメモリで吐くライブラリ作った。ブラウザでコンパイラ動かしたい時に使う。  かな。限定継続ライブラリみたいに途中で放置してるやつとかチュートリアル読んでOS作ってるやつとかは入れてないので「活動」って意味だともう少し広いけど社会貢献はしてない。\n仕事も含めたGitHubの草はこんなもん。\npic.twitter.com/MVQag8h6qU\n\u0026mdash; κeen (@blackenedgold) 2016年12月29日 \n引越しだとかICFPとかの週はほとんどコミット出来てないのでもうちょっと頑張りたい。あと顕著に土日にサボってるのもどうにかしたい。\n割と飽きっぽいというか他のものに浮気しがちというか適当に手を付けては壁に当たった/第一目標達成したあたりで次にいっちゃうので継続性がない。継続した方が社会貢献になるんだよなー。\n読書は正確にいつ買ったか覚えてないので正確じゃないけど、流し読みしたものも含めれば\n 線型論理入門 圏論の基礎 圏論の歩き方 Compiling with Continuations 最新コンパイラ構成技法 ガベージコレクション 自動的メモリ管理を構成する理論と実装 独自CPU開発で学ぶコンピュータのしくみ 暗号技術入門 第3版 秘密の国のアリス その数式、プログラムできますか？ 戦略的データサイエンス入門 ―ビジネスに活かすコンセプトとテクニック ノンパラメトリックベイズ 点過程と統計的機械学習の数理 (機械学習プロフェッショナルシリーズ) 劣モジュラ最適化と機械学習 (機械学習プロフェッショナルシリーズ) 深層学習 (機械学習プロフェッショナルシリーズ) 異常検知と変化検知 (機械学習プロフェッショナルシリーズ) 実践ドメイン駆動設計 (Object Oriented SELECTION) The Art of Multiprocessor Programming 並行プログラミングの原理から実践まで  多分こんなもん。機械学習プロフェッショナルシリーズは去年読んだのも含んでるかもしれない。あんまり覚えてない。論文も挙げようと思ったけど面倒になったからいいや。十数綴から二十綴くらいじゃないかな。\n社会的には1回社内でチーム移動になって1回退職した。Shibuya.lispの運営から引退を発表して、rust-lang-ja（有志の翻訳コミュニティ？）の中の人になった。\nまだ社会人になって2年も経ってなくて情報科学/工学の基礎もないので基礎を付けるために勉強してるフェーズかなぁといったところ。 来年は専門性の高い仕事になるので今年以上に勉強が必要になりそう。多分本より論文に比重が傾く。\n年明けにまた注目していきたい技術書く。毎年書いていったら面白いかもしれない。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2016-12-31","title":"2016年注目していきたかった技術の振り返りと個人的振り返り","url":"https://KeenS.github.io/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri/"},
  {"body":"κeenです。ここのところRustの開発ツール回りでリリースが続いてセットアップが楽になってるようだったので最新の情報をお届けします。\nとりあえず私は既存の環境があるので一旦全て破棄してから再度セットアップしてみます。\nRustのインストール rustup.rs - The Rust toolchain installerがリリースされたので以下で一発です。\n$ curl https://sh.rustup.rs -sSf | sh そして\nsource $HOME/.cargo/env をシェルのrcファイルに書き加えたらOKです。 今のシェルにも反映するには同じく上記のコマンドを打ちます。\n周辺ツールのインストール cargoがあるので楽ですね\n# コードフォーマッタ $ cargo install rustfmt # 補完、定義ジャンプなど $ cargo install racer まあまあ時間がかかります。\nエディタ(Emacs)の設定 私がEmacsを使ってるのでEmacsの設定を。\nまず、必要パッケージをインストールします。\nracer rustfmt flycheck-rust をインストールします。\nracer flycheck-rust をインストールします。rust-modeにrustfmtの機能が含まれているようでした。\n@blackenedgold rustfmtを emacsから使うの rust-modeが現在サポートしているので, rustfmt.elパッケージは不要ですね. rust-format-on-saveが non-nilなら保存時に rustfmtが実行されます.\n\u0026mdash; Syohei YOSHIDA (@syohex) 2016年12月29日 ;;; racerやrustfmt、コンパイラにパスを通す (add-to-list \u0026#39;exec-path (expand-file-name \u0026#34;~/.cargo/bin/\u0026#34;)) ;;; rust-modeでrust-format-on-saveをtにすると自動でrustfmtが走る (eval-after-load \u0026#34;rust-mode\u0026#34; \u0026#39;(setq-default rust-format-on-save t)) ;;; rustのファイルを編集するときにracerとflycheckを起動する (add-hook \u0026#39;rust-mode-hook (lambda () (racer-mode) (flycheck-rust-setup))) ;;; racerのeldocサポートを使う (add-hook \u0026#39;racer-mode-hook #\u0026#39;eldoc-mode) ;;; racerの補完サポートを使う (add-hook \u0026#39;racer-mode-hook (lambda () (company-mode) ;;; この辺の設定はお好みで (set (make-variable-buffer-local \u0026#39;company-idle-delay) 0.1) (set (make-variable-buffer-local \u0026#39;company-minimum-prefix-length) 0))) とりあえずこれでセットアップ完了です。racerの最新版でrustのソースコードの位置を設定しなくてよくなったので簡潔になりましたね。\nracer-modeは補完をしてくれる他、M-.で定義元ジャンプ、M-,でジャンプ元に戻れます。 あとはM-x racer-describeでポイント位置にあるシンボルのrustdocを(Emacs内で)表示してくれます。\nおお! racerでEmacs内でrustdocレンダ出来るようになってる！便利！！\nRustdoc Meets The Self-Documenting Editorhttps://t.co/gDEHl2fSfx pic.twitter.com/sdrX9OoEnr\n\u0026mdash; κeen (@blackenedgold) 2016年8月31日 \nその他は放っておくと勝手に機能してくれるので考えることが少なくていいですね。\nその他便利ツール セットアップがあっけなかったのでついでに入れておくと便利なツールをいくつか紹介します。\ncargo-edit インストールは\n$ cargo install cargo-edit 「libcクレートの最新版に依存したい」なんて時に一々libcの最新版を確認するのは面倒ですよね。そんなときにcargo-editがあれば\n$ cargo add libc で Cargo.toml に追記してくれます。\ncargo-script インストールは\n$ cargo install cargo-script ちょっとした実験スクリプトとかをコンパイル→実行のステップを踏まずにいきなり実行出来ます。 cargo script FILEでファイルを実行出来ます。\n$ cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026gt; hello.rs fn main() { println!(\u0026#34;hello, script\u0026#34;) } EOF $ cargo script hello.rs Compiling hello v0.1.0 (file:///home/kim/.cargo/.cargo/script-cache/file-hello-f6b1735a519bb659) Finished release [optimized] target(s) in 0.15 secs hello, script というふうに使います。\nシェルのrcファイルで\nalias rust=\u0026#39;cargo-script\u0026#39; としておくと吉。\ncargo-update インストールは\n$ cargo install cargo-update 今までインストールしたバイナリのアップデートを出来ます。\n$ cargo install-update -a 以上\n","categories":["Rust","rustup","開発環境","Emacs"],"category_urls":["/categories/rust","/categories/rustup","/categories/%e9%96%8b%e7%99%ba%e7%92%b0%e5%a2%83","/categories/emacs"],"date":"2016-12-29","title":"気付いたらRustの環境構築がかなり楽になってた","url":"https://KeenS.github.io/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta/"},
  {"body":"このエントリはRust その2 Advent Calendar 2016 - Qiitaの25日目の記事です。\nκeenです。大トリに小ネタで申し訳ないのですが最近書いたコードでちょっと便利だなと思ったテクニックを紹介します。\n次のような言語のインタプリタを作ることを考えます。意味論はエスパーして下さい。\nx = 1 y = 2 println(\u0026#34;x = \u0026#34;, x) println(\u0026#34;y = \u0026#34;, y) println(\u0026#34;--\u0026#34;) { x = 3 println(\u0026#34;x = \u0026#34;, x) println(\u0026#34;y = \u0026#34;, y) } println(\u0026#34;--\u0026#34;) println(\u0026#34;x = \u0026#34;, x) println(\u0026#34;y = \u0026#34;, y) この実行結果は\nx = 1 y = 2 -- x = 3 y = 2 -- x = 1 y = 2 になりますね。このインタプリタをRustで作りましょう。\n初期実装 雛形はこんなもんでしょうか。後でリファレンスが出てきてややこしくなるので値は全て所有権を貰っています。\n#[derive(Debug, Clone)]struct AST(Vec\u0026lt;Stmt\u0026gt;);#[derive(Debug, Clone)]enum Stmt{Subst(String,Expr),Print(Vec\u0026lt;Expr\u0026gt;),Block(Vec\u0026lt;Stmt\u0026gt;),}#[derive(Debug, Clone)]enum Expr{Str(String),Num(isize),Var(String),}struct Interpreter{// これを実装する }implInterpreter{pubfn new()-\u0026gt; Self{Interpreter{}}fn run(\u0026amp;mutself,ast: AST){forstmtinast.0{self.run_stmt(stmt);}}fn run_stmt(\u0026amp;mutself,stmt: Stmt){// これを実装する }}fn main(){letast={useStmt::*;useExpr::*;AST(vec![Subst(\u0026#34;x\u0026#34;.to_string(),Num(1)),Subst(\u0026#34;y\u0026#34;.to_string(),Num(2)),Print(vec![Str(\u0026#34;x = \u0026#34;.to_string()),Var(\u0026#34;x\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;y = \u0026#34;.to_string()),Var(\u0026#34;y\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;--\u0026#34;.to_string())]),Block(vec![Subst(\u0026#34;x\u0026#34;.to_string(),Num(3)),Print(vec![Str(\u0026#34;x = \u0026#34;.to_string()),Var(\u0026#34;x\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;y = \u0026#34;.to_string()),Var(\u0026#34;y\u0026#34;.to_string())]),]),Print(vec![Str(\u0026#34;--\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;x = \u0026#34;.to_string()),Var(\u0026#34;x\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;y = \u0026#34;.to_string()),Var(\u0026#34;y\u0026#34;.to_string())]),])};letmutinterpreter=Interpreter::new();interpreter.run(ast);} (コンストラクタ関数作っときゃよかったかも)\n今回の本質ではないのでパーサは用意してません。\nさて、とりあえずのところ変数の管理のためにシンボルテーブルが必要です。実装しましょう。\n//... usestd::collections::HashMap;struct Interpreter{symbol_table: HashMap\u0026lt;String,Expr\u0026gt;,}implInterpreter{pubfn new()-\u0026gt; Self{Interpreter{symbol_table: HashMap::new(),}}fn add_to_scope(\u0026amp;mutself,name: String,expr: Expr){self.symbol_table.insert(name,expr);}fn find_scope(\u0026amp;self,name: \u0026amp;str)-\u0026gt; Expr{self.symbol_table.get(name).expect(\u0026#34;reference to unknown variable\u0026#34;).clone()}//... } 簡略化のためにcloneやpanicしてますがご愛嬌。\nこれがあればrun_stmtのそれっぽい実装は出来ます。\nfn run_stmt(\u0026amp;mutself,stmt: Stmt){useStmt::*;matchstmt{Subst(name,expr)=\u0026gt;{letexpr=self.eval(expr);self.add_to_scope(name,expr);},Print(exprs)=\u0026gt;{forexprinexprs{self.print_expr(expr);}println!(\u0026#34;\u0026#34;);},Block(stmts)=\u0026gt;{forstmtinstmts{self.run_stmt(stmt);}},}}fn eval(\u0026amp;self,expr: Expr)-\u0026gt; Expr{useExpr::*;matchexpr{Var(v)=\u0026gt;self.find_scope(\u0026amp;v),e@Str(_)|e@Num(_)=\u0026gt;e}}fn print_expr(\u0026amp;self,expr: Expr){useExpr::*;matchself.eval(expr){Str(refs)=\u0026gt;print!(\u0026#34;{}\u0026#34;,s),Num(refn)=\u0026gt;print!(\u0026#34;{}\u0026#34;,n),Var(_)=\u0026gt;panic!(\u0026#34;reference to unknown variable\u0026#34;),}} さて、これを走らせてみましょう。\n$ cargo run x = 1 y = 2 -- x = 3 y = 2 -- x = 3 y = 2 スコープを実装していないので最後のxが3になっていますね。スコープを実装しましょう。\nスコープを実装するには簡単にはハッシュテーブルを複数持てば良さそうです。 3段にネストしたスコープなら3つのハッシュテーブルを持ちます。 そしてスコープを抜けた時にそのスコープに対応するハッシュテーブルを消せば（忘れれば）良さそうです。\nstruct Interpreter{// スコープに対応したテーブル達。 symbol_tables: Vec\u0026lt;HashMap\u0026lt;String,Expr\u0026gt;\u0026gt;,// 今どのスコープを指しているか。 // スコープを抜けてもベクトルは縮まないのでこれが必要。 pos: usize,}implInterpreter{pubfn new()-\u0026gt; Self{// 新しいフィールドの初期化 Interpreter{symbol_tables: Vec::new(),// ややこしくなるが、0で初期化しているのでpos-1番目のハッシュマップが現スコープのテーブルになる pos: 0,}}// スコープに入る処理。 fn in_scope(\u0026amp;mutself){letpos=self.pos;// スコープから抜けてもハッシュマップは消えないので // 入る → 出る → 入るをしたときに既にテーブルがある場合が出てくる。 // 必要なテーブルが既にある場合とない場合で条件分岐 ifself.symbol_tables.len()\u0026lt;=pos{self.symbol_tables.push(HashMap::new())}else{// 既にテーブルがある場合は古い情報を消す self.symbol_tables[pos-1].clear()}// ポジションは忘れずインクリメント self.pos+=1;}// スコープから抜ける処理 fn out_scope(\u0026amp;mutself){// スコープから抜けるのはデクリメントのみでOK self.pos-=1;}pubfn run(\u0026amp;mutself,ast: AST){// in_scope が増えた self.in_scope();forstmtinast.0{self.run_stmt(stmt);}// out_scope が増えた self.out_scope();}fn add_to_scope(\u0026amp;mutself,name: String,expr: Expr){// 現在のスコープに変数を入れる letpos=self.pos-1;self.symbol_tables[pos].insert(name,expr);}fn find_scope(\u0026amp;self,name: \u0026amp;str)-\u0026gt; Expr{letpos=self.pos;// 一番内側(現在)のスコープから外側のスコープの順に調べていく。 // `[0..pos]` や `rev()` に注意。 fortableinself.symbol_tables[0..pos].iter().rev(){ifletSome(e)=table.get(name){returne.clone()}}// どこにもなければ未定義変数 panic!(\u0026#34;reference to unknown variable\u0026#34;)}fn run_stmt(\u0026amp;mutself,stmt: Stmt){useStmt::*;matchstmt{// .. Block(stmts)=\u0026gt;{// in_scope が増えた self.in_scope();forstmtinstmts{self.run_stmt(stmt);}// out_scope が増えた self.out_scope();},}}// .. } これで走らせてみます。\n$ cargo run x = 1 y = 2 -- x = 3 y = 2 -- x = 1 y = 2 はい。動きました。\nScope の導入 さて、上のコードではin_scopeとout_scopeが対で現れました。というか現れないといけません。 でもプログラミングエラーでout_scopeを忘れるなんてことはよくある話です（現に私はこのサンプルを書いてて間違えかけました）。これをRustのライフタイムの仕組みに乗っけて自動で解決しようというのが今回のお話。\n手法は簡単で、とりあえずScopeという型を用意します。そしてnewする時にin_scopeを呼んであげて、dropする時にout_scopeを呼んであげます。\nusestd::ops::Drop;struct Scope\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;\u0026#39;amutInterpreter);impl\u0026lt;\u0026#39;a\u0026gt;Scope\u0026lt;\u0026#39;a\u0026gt;{fn new(inpr: \u0026amp;\u0026#39;a mutInterpreter)-\u0026gt; Self{inpr.in_scope();Scope(inpr)}}impl\u0026lt;\u0026#39;a\u0026gt;DropforScope\u0026lt;\u0026#39;a\u0026gt;{fn drop(\u0026amp;mutself){self.0.out_scope()}} さて、この\u0026amp;mut Interpreterで参照しているというのが丁度良くて、Scopeの分岐というのを防ぐことが出来ます。こういうやつですね。\nlet scope1 = Scope::new(\u0026amp;mut intr); let scope2 = Scope::new(\u0026amp;mut intr); // error: 既に\u0026amp;mut されている変数は\u0026amp;mut出来ない では、これを使ってみましょう。\npubfn run(\u0026amp;mutself,ast: AST){// in_scopeをScope::new()に置き換えた letscope=Scope::new(self);forstmtinast.0{// scopeに渡してしまったのでselfはsope.0で参照する必要がある scope.0.run_stmt(stmt);}// out_scopeは自動で呼ばれる }// run_stmtのBlockも同様に書き換える $ cargo run x = 1 y = 2 -- x = 3 y = 2 -- x = 1 y = 2 動きました。でも、あまりscope.0なんて使いたくないですよね。出来れば透過的に扱いたい。 そんなときのためにDeref と DerefMut です。Rustは型が合わなければ自動でderefを呼んでくれます。\nDeref と DerefMut を実装しましょう。\nusestd::ops::{Deref,DerefMut};impl\u0026lt;\u0026#39;a\u0026gt;DerefforScope\u0026lt;\u0026#39;a\u0026gt;{type Target=Interpreter;fn deref(\u0026amp;self)-\u0026gt; \u0026amp;Interpreter{self.0}}impl\u0026lt;\u0026#39;a\u0026gt;DerefMutforScope\u0026lt;\u0026#39;a\u0026gt;{fn deref_mut(\u0026amp;mutself)-\u0026gt; \u0026amp;mutInterpreter{self.0}}implInterpreter{// .. pubfn run(\u0026amp;mutself,ast: AST){// deref_mutするために mutをつける letmutscope=Scope::new(self);forstmtinast.0{// scope.0しなくてもInterpreterのメソッドが呼べる scope.run_stmt(stmt);}}// .. } まとめ  生成と消滅が対になるものはRustのオブジェクトで管理出来るよ シンプルなラッパー型はDerefやDerefMutを実装しておくと便利だよ  参考  Drop Deref による型強制  付録A 最終的なソースコード全文を掲載します。\n#[derive(Debug, Clone)]struct AST(Vec\u0026lt;Stmt\u0026gt;);#[derive(Debug, Clone)]enum Stmt{Subst(String,Expr),Print(Vec\u0026lt;Expr\u0026gt;),Block(Vec\u0026lt;Stmt\u0026gt;),}#[derive(Debug, Clone)]enum Expr{Str(String),Num(isize),Var(String),}usestd::collections::HashMap;struct Interpreter{symbol_tables: Vec\u0026lt;HashMap\u0026lt;String,Expr\u0026gt;\u0026gt;,pos: usize,}usestd::ops::{Drop,Deref,DerefMut};struct Scope\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;\u0026#39;amutInterpreter);impl\u0026lt;\u0026#39;a\u0026gt;Scope\u0026lt;\u0026#39;a\u0026gt;{fn new(inpr: \u0026amp;\u0026#39;a mutInterpreter)-\u0026gt; Self{inpr.in_scope();Scope(inpr)}}impl\u0026lt;\u0026#39;a\u0026gt;DropforScope\u0026lt;\u0026#39;a\u0026gt;{fn drop(\u0026amp;mutself){self.0.out_scope()}}impl\u0026lt;\u0026#39;a\u0026gt;DerefforScope\u0026lt;\u0026#39;a\u0026gt;{type Target=Interpreter;fn deref(\u0026amp;self)-\u0026gt; \u0026amp;Interpreter{self.0}}impl\u0026lt;\u0026#39;a\u0026gt;DerefMutforScope\u0026lt;\u0026#39;a\u0026gt;{fn deref_mut(\u0026amp;mutself)-\u0026gt; \u0026amp;mutInterpreter{self.0}}implInterpreter{pubfn new()-\u0026gt; Self{Interpreter{symbol_tables: Vec::new(),pos: 0,}}fn in_scope(\u0026amp;mutself){letpos=self.pos;ifself.symbol_tables.len()\u0026lt;=pos{self.symbol_tables.push(HashMap::new())}else{self.symbol_tables[pos-1].clear()}self.pos+=1;}fn out_scope(\u0026amp;mutself){self.pos-=1;}pubfn run(\u0026amp;mutself,ast: AST){letmutscope=Scope::new(self);forstmtinast.0{scope.run_stmt(stmt);}}fn add_to_scope(\u0026amp;mutself,name: String,expr: Expr){letpos=self.pos-1;self.symbol_tables[pos].insert(name,expr);}fn find_scope(\u0026amp;self,name: \u0026amp;str)-\u0026gt; Expr{letpos=self.pos;fortableinself.symbol_tables[0..pos].iter().rev(){ifletSome(e)=table.get(name){returne.clone()}}panic!(\u0026#34;reference to unknown variable\u0026#34;)}fn run_stmt(\u0026amp;mutself,stmt: Stmt){useStmt::*;matchstmt{Subst(name,expr)=\u0026gt;{letexpr=self.eval(expr);self.add_to_scope(name,expr);},Print(exprs)=\u0026gt;{forexprinexprs{self.print_expr(expr);}println!(\u0026#34;\u0026#34;);},Block(stmts)=\u0026gt;{letscope=Scope::new(self);forstmtinstmts{scope.0.run_stmt(stmt);}},}}fn eval(\u0026amp;self,expr: Expr)-\u0026gt; Expr{useExpr::*;matchexpr{Var(v)=\u0026gt;self.find_scope(\u0026amp;v),e@Str(_)|e@Num(_)=\u0026gt;e}}fn print_expr(\u0026amp;self,expr: Expr){useExpr::*;matchself.eval(expr){Str(refs)=\u0026gt;print!(\u0026#34;{}\u0026#34;,s),Num(refn)=\u0026gt;print!(\u0026#34;{}\u0026#34;,n),Var(_)=\u0026gt;panic!(\u0026#34;reference to unknown variable\u0026#34;),}}}fn main(){letast={useStmt::*;useExpr::*;AST(vec![Subst(\u0026#34;x\u0026#34;.to_string(),Num(1)),Subst(\u0026#34;y\u0026#34;.to_string(),Num(2)),Print(vec![Str(\u0026#34;x = \u0026#34;.to_string()),Var(\u0026#34;x\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;y = \u0026#34;.to_string()),Var(\u0026#34;y\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;--\u0026#34;.to_string())]),Block(vec![Subst(\u0026#34;x\u0026#34;.to_string(),Num(3)),Print(vec![Str(\u0026#34;x = \u0026#34;.to_string()),Var(\u0026#34;x\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;y = \u0026#34;.to_string()),Var(\u0026#34;y\u0026#34;.to_string())]),]),Print(vec![Str(\u0026#34;--\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;x = \u0026#34;.to_string()),Var(\u0026#34;x\u0026#34;.to_string())]),Print(vec![Str(\u0026#34;y = \u0026#34;.to_string()),Var(\u0026#34;y\u0026#34;.to_string())]),])};letmutinterpreter=Interpreter::new();interpreter.run(ast);}","categories":["Rust","Advent Calendar","Advent Calendar 2016","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2016","/categories/rust-advent-calendar"],"date":"2016-12-24","title":"Rustのライフタイムを使ったスコープ解析","url":"https://KeenS.github.io/blog/2016/12/24/rustnoraifutaimuwotsukattasuko_pukaiseki/"},
  {"body":"κeenです。Rustには所有権やらライフタイムやら参照やらがあって型システムが面倒ですよね。線形（アフィン）と言われてるのに「あれ？」と思う部分もあるので詳しく探っていこうと思います。\n尚、この記事は型システムに興味のある人向けです。単にRustを書きたい方に有用な情報があるかは分かりません。\n2016-212-14T15:28Z09:00 加筆訂正しました。diffはこちら\n線形型？アフィン型？ はじめにこの辺をハッキりさせておきたいです。 アフィン型は線形型に弱化規則を許す型です。 プログラミング的に言えば線形型は free しないと型エラーになるけどアフィン型はそうでない。 Rustはご存知の通り free 相当のものを手で書くことはないのでアフィンな気がしますし、昔のドキュメントにもそう書いてました。\nしかし実際に実行されるプログラムではコンパイラが差し込んだ free が実行されるので free を省略出来るというシンタックスシュガーの類な気もします。\nただまあ、 free を差し込む位置を特定するのに弱化規則を使った場所で推論している筈なのでアフィンを使ってる筈ですよね。\nってことで今回の記事はアフィン型で統一したいと思います。\n参照も値 なんとなく、構文が用意されているので参照自体特別な存在な気がしますが、そんなことはありません。\nfn take_any\u0026lt;T\u0026gt;(t: T)-\u0026gt; T{t} このように任意の値を取れる関数を用意してあげます。 すると、以下のように所有、参照、可変参照全て渡せます。\nlets=\u0026#34;foo\u0026#34;.to_string();letmuts=take_any(s);take_any(\u0026amp;s);take_any(\u0026amp;muts); \u0026amp; は Copy 、 \u0026amp;mut は違う 先と同じように Copy を実装した型を受け取る関数を書いてみましょう。\nfn take_copy\u0026lt;T: Copy\u0026gt;(t: T)-\u0026gt; T{t} これに参照を渡してあげると、 \u0026amp;mut がエラーになります。\nletmuts=\u0026#34;foo\u0026#34;.to_string();take_copy(\u0026amp;s);take_copy(\u0026amp;muts);// error[E0277]: the trait bound `\u0026amp;mut std::string::String: std::marker::Copy` is not satisfied  もちろん、 Copy なので普通に何度も使えます。線形型でいう ! に近いですね。違いますけど。\nlets=\u0026#34;foo\u0026#34;.to_string();letref_s=\u0026amp;s;letx: \u0026amp;String =ref_s;lety: \u0026amp;String =ref_s;// Copy(が要求するClone)に実装されているメソッドを陽に呼ぶ letz: \u0026amp;String =(\u0026amp;ref_s).clone(); また、 Copy への参照は参照外しが可能です。\nletx: isize =1;letref_x=\u0026amp;x;letx: isize =*x; なので、 \u0026amp;\u0026amp; や \u0026amp;mut\u0026amp; は \u0026amp; への参照（Copyへの参照）なので \u0026amp; へ参照外しが可能ですが、 \u0026amp;\u0026amp;mut は\u0026amp;mutへの参照（Copyではない値への参照）なので参照外し出来ません。\u0026amp;mut\u0026amp; や \u0026amp;\u0026amp;mut とややこしいですね。\nletmuts=\u0026#34;foo\u0026#34;.to_string();// \u0026amp;\u0026amp; {letref_ref_s=\u0026amp;\u0026amp;s;letref_s: \u0026amp;String =*ref_refs;}// \u0026amp;mut \u0026amp; {letrefmut_ref_s=\u0026amp;mut\u0026amp;s;letreft_s: \u0026amp;String =*s;}// \u0026amp;\u0026amp;mut {letref_refmut_s=\u0026amp;\u0026amp;muts;letrefmut_s: \u0026amp;mutString=*s;// error[E0389]: cannot borrow data mutably in a `\u0026amp;` reference } ということで \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;T が \u0026amp;T に参照外し出来る理由も分かったかと思います。\n\u0026amp;mut は Deref さて、 \u0026amp;mut がたまに \u0026amp; のように振る舞うことがありますが、これは Deref のせいです。\nusestd::ops::Deref;letmuts=\u0026#34;foo\u0026#34;.to_string();letrefmut_s=\u0026amp;muts;{// derefを陽に呼ぶ letref_s: \u0026amp;string=refmut_s.deref();}{// 暗黙のDerefによる型強制 letref_s: \u0026amp;string=refmut_s;} rustはderef による型強制を行うため、無言で \u0026amp;mut を \u0026amp; に変換することが出来ます。\nさて、ここまでで \u0026amp; や \u0026amp;mut もただの値であること、アフィン型に反しないことを調べました。 次はライフタイムについて探ります。\nライフタイムとサブタイピング 実は、Rustにはサブタイピングがあります。ライフタイムです。ライフタイムにはサブタイプ関係があるのです。\nこのように、2つの引数が厳密に同じライフタイムであることを要求する関数を用意します。\nfn take_two_ref\u0026lt;\u0026#39;a\u0026gt;(_: \u0026amp;\u0026#39;a String,_: \u0026amp;\u0026#39;a String){} これに、違うライフタイムを持つ型を放り込んでみます。\n{leta=\u0026#34;aaa\u0026#34;.to_string();letref_a=\u0026amp;a;{letb=\u0026#34;bbb\u0026#34;.to_string();letref_b=\u0026amp;b;take_two_ref(ref_a,ref_b);}} これはコンパイルが通ります。明示的にライフタイムを書くとこうです。これは有効な構文ではないです（余談ですがラベル付きbreak文のための構文と衝突します）。\n\u0026#39;a: {leta: \u0026#39;a String =\u0026#34;aaa\u0026#34;.to_string();letref_a=\u0026amp;\u0026#39;aa;\u0026#39;b: {letb: \u0026#39;b String =\u0026#34;bbb\u0026#34;.to_string();letref_b=\u0026amp;\u0026#39;bb;take_two_ref::\u0026lt;\u0026#39;b\u0026gt;(ref_a,ref_b);}} 大は小を兼ねるので 'a は 'b のサブタイプになっています。 ちょっと言葉がややこしいのですが、スコープが狭いライフタイムの方が大きい型です。狭い方が大きい。この言い回しに馴れてない人に説明すると、上の例でいえば 'b を要求する部分に渡せるのは 'a と 'b 2つありますが、 'a を要求する部分に渡せるのは 'a だけです。 2つと1つだったら2つの方が大きいですよね。\nさて、今回の例ではちゃんとスコープの入れ子とサブタイプ関係が一致していました。\n\u0026#39;a: {----------||\u0026#39;b: {--|||||||}------|}-------------- 参照を取るときは参照のライフタイムが元のライフタイムのサブタイプになっている必要があります。\nこの関係に反するとエラーになります。\nletref_s: \u0026amp;String;{lets=\u0026#34;foo\u0026#34;.to_string();ref_s=\u0026amp;s;// error: `s` does not live long enough } 図示するとこうでしょうか。\nletref_s: \u0026amp;String;{lets=\u0026#34;foo\u0026#34;.to_string();-----ref_s=\u0026amp;s;----------------|||}------------------------------+---|-------------------------------- ライフタイムといえどある種、型なんですね。余談ですが確かリージョンの論文には「リージョンはプログラム全体を静的に伝播する型のようなもの」と表現していた気がします。既存の型と直行するので型とは別とも言えますし、タプルのように両方並べたものを型と言うことも出来ますね。\n所有型とライフタイムと 'static 適切な語彙がなかったので勝手に所有型と名付けましたが、参照でない型のことを指しています。（先の例で見せた通り、参照型にも所有権はあるので適切ではないですがひとまず我慢して下さい。）\nさて、なんとなくライフタイムと参照型は結び付いている気がしますが、参照じゃない型にもライフタイムはあります。\nfn take_two_value\u0026lt;\u0026#39;a,T: \u0026#39;a,S: \u0026#39;a\u0026gt;(_: T,_: S){} このように、任意の2つの型を取るけども両方ともにライフタイムを要求する関数を書いてみます。\nこれに、所有型を渡すことが出来ます。\nlett=\u0026#34;t\u0026#34;.to_string();{lets=\u0026#34;s\u0026#34;.to_string();lets_ref=\u0026amp;s;take_two_value(t,s_ref);} ということで、所有型にもライフタイムはあります（多分）。\nところで、ライフタイムのボトム型相当のものに 'static というものがあります。 グローバル変数やリテラルなどに割り当てられるライフタイムで、プログラムが死ぬまで生き続けます。\nstaticfoo: \u0026amp;\u0026#39;static isize =\u0026amp;3;staticbar: isize =3;fn main(){letx: \u0026amp;\u0026#39;static str =\u0026#34;x\u0026#34;;letref_bar: \u0026amp;\u0026#39;static isize =\u0026amp;bar} 'static のみを受け取る関数を書いてみましょう。\nfn take_static\u0026lt;T: \u0026#39;static\u0026gt;(_: T){} もちろん、先の例に出たstaticな値達を渡せます。\nstaticfoo: \u0026amp;\u0026#39;static isize =\u0026amp;3;staticbar: isize =3;fn main(){letx: \u0026amp;\u0026#39;static str =\u0026#34;x\u0026#34;;letref_bar: \u0026amp;\u0026#39;static isize =\u0026amp;bar;take_static(foo);take_static(x);take_static(ref_bar);} 実は、これに所有型を渡せます。\nlets=\u0026#34;foo\u0026#34;.to_string();take_static(s); そして、任意の参照型は渡せません。\nlets=\u0026#34;foo\u0026#34;.to_string();take_static(\u0026amp;s);// error: `s` does not live long enough  ということで所有型には 'static というライフタイムが付いているようです（？）。 'static イメージとしては「自分がその値を保持している限り無効になることはない型」ですかね。\nこれに関連するTipsとして関数や構造体のジェネリクスで所有型しか受け取らないようにするには \u0026lt;T: 'static\u0026gt; が使えます。\nさてさて、これまた参照型は特別扱いされることなく他のRustの値と同じようにライフタイムで管理されていることを調べました。\n最後に今回到達出来なかった謎、「参照を取る」について考えたいと思います。\n\u0026amp;mut の規則 みなさん御存じの通り、\u0026amp;mut を取ると値への他の操作が許されなくなります。\nletmuts=\u0026#34;foo\u0026#34;.to_string();letrefmut_s=\u0026amp;muts;lett=s;// error[E0505]: cannot move out of `s` because it is borrowed letref_s=\u0026amp;s;// error[E0502]: cannot borrow `s` as immutable because it is also borrowed as mutable  \u0026amp;mut T と T が相互排他的なのでこれは線形論理のシーケント計算っぽく書くと以下のような規則を考えれば良さそうです。\nΓ, T:\u0026#39;a |- Σ -------------- \u0026amp;mut-intro Γ, (\u0026amp;\u0026#39;a mut T): \u0026#39;b |- Σ where \u0026#39;a \u0026lt;: \u0026#39;b Γ, (\u0026amp;\u0026#39;a mut T):\u0026#39;b |- (\u0026amp;\u0026#39;a mut T): \u0026#39;b, Σ ----------------------- \u0026amp;mut-elim Γ, T: \u0026#39;a |- Σ 型付け規則の書き方になれてないのでシーケント計算で書きましたがサブタイプの記述で困りましたね。\n\u0026amp; の謎 さて、問題は \u0026amp; です。 \u0026amp; は Copy なのでそこら中に生えてきます。 なので \u0026amp;-elim のような規則では対応出来ません。\nただ、ライフタイムによる制約があるので「参照のライフタイムが死ぬときに元の値が復活する」ような規則を考えたくなります。\nしかし、それでもだめです。複数回 \u0026amp; を取れてしまうので、以下のように複数のライフタイムを持つ場合で破綻します。\u0026amp; T と T の間でなにかしらのしがらみがある筈です。\nlets=\u0026#34;foo\u0026#34;.to_string();{letref_s1=\u0026amp;s;{letref_s2=\u0026amp;s;}} それに、 \u0026amp;mut と \u0026amp; が相互排他であることも説明出来る規則でないといけません。謎が多い。\nまとめ さて、Rustの型システムのリソース管理回りを探ってみました。とりあえず分かったことを纏めると\n 値には全てアフィン型が付く  参照型も例外ではない  値には全てライフタイムが付く  所有型も例外ではないっぽい もしかしたら所有型はライフタイムを無視している？  「参照を取る」のセマンティクスが謎  勿論、直感的には分かる どういう規則なんだろう アフィン型とライフタイム両方が絡むはず。   特に論文も読んでないのでちょっと遠回りだったかもしれません。 もしかしたら論文漁ったら一発で解決するのかも。 詳しい方、 \u0026amp; の謎を教えて下さい。\n","categories":["Rust","型"],"category_urls":["/categories/rust","/categories/%e5%9e%8b"],"date":"2016-12-14","title":"Rustの所有権、ライフタイム、参照、型、しがらみ","url":"https://KeenS.github.io/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami/"},
  {"body":"κeenです。関連型について考えてたらtraitがstructに見えてきたので一筆。小ネタです。\nstructは普通の構造体とtupl structと言われる形式二種類あります。\nstruct Color{r: u8,g: u8,b: u8,}struct Color(u8,u8,u8); traitはというと関連型と型パラメータ二種類あります。\ntraitInto{type Item;}traitInto\u0026lt;T\u0026gt;{} インスタンス化も似てます。\n// struct struct Color{r: 255,g: 0,b: 0,}struct Color(255,0,0)// trait struct Dummy;implIntoforDummy{type Item=i8}implInto\u0026lt;i8\u0026gt;forDummy{} また、両者の使い分けも名前で参照したいかor手軽に使いたいかで使い分けます。\n以上小ネタでした。\n","categories":["Rust","関連型","小ネタ","型"],"category_urls":["/categories/rust","/categories/%e9%96%a2%e9%80%a3%e5%9e%8b","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf","/categories/%e5%9e%8b"],"date":"2016-12-03","title":"Rustのstructとtraitって似てるよね","url":"https://KeenS.github.io/blog/2016/12/03/rustnostructtotraittteniteruyone/"},
  {"body":"このエントリはRust その2 Advent Calendar 2016 - Qiita3日目の記事です。\nκeenです。Rustのstd::processの扱い方を紹介します。\nビルダー これはビルダーになっていて、以下のように使えます。公式ドキュメントの例です。\nletoutput=Command::new(\u0026#34;sh\u0026#34;).arg(\u0026#34;-c\u0026#34;).arg(\u0026#34;echo hello\u0026#34;).output().expect(\u0026#34;failed to execute process\u0026#34;);lethello=output.stdout;println!(\u0026#34;{}\u0026#34;,std::str::from_utf8(\u0026amp;hello).unwrap());hello 環境変数も渡せます\nletoutput=Command::new(\u0026#34;sh\u0026#34;).arg(\u0026#34;-c\u0026#34;)// 環境変数を参照するコマンド .arg(\u0026#34;echo $HELLO\u0026#34;)// 環境変数を設定する .env(\u0026#34;HELLO\u0026#34;,\u0026#34;hello, world\u0026#34;).output().expect(\u0026#34;failed to execute process\u0026#34;);lethello=output.stdout;println!(\u0026#34;{}\u0026#34;,std::str::from_utf8(\u0026amp;hello).unwrap());hello,world あるいは実行するディレクトリも指定出来ます\nletoutput=Command::new(\u0026#34;ls\u0026#34;)// プロセスを実行するディレクトリを指定する .current_dir(\u0026#34;/\u0026#34;).output().expect(\u0026#34;failed to execute process\u0026#34;);lethello=output.stdout;println!(\u0026#34;{}\u0026#34;,std::str::from_utf8(\u0026amp;hello).unwrap());bin boot cdrom core ... 出力 上の例では output でstdio,stderr, exitstatus取り出していますが、子プロセスとして実行することも出来ます。\nletmutchild=Command::new(\u0026#34;ls\u0026#34;).current_dir(\u0026#34;/\u0026#34;)// outputではなくspawnを使う .spawn().expect(\u0026#34;failed to execute process\u0026#34;);letstatus=child.wait().unwrap();println!(\u0026#34;{}\u0026#34;,status);bin boot cdrom core dev etc home initrd.img initrd.img.old lib lib32 lib64 libx32 lost+found media mnt opt proc root run sbin snap srv sys tmp usr var vmlinuz vmlinuz.old この場合、子プロセスはRustへではなく直接stdoutへ出力するのでSIGPIPEが送られません。\nあるいは出力先を手で指定することも出来ます。\nletchild=Command::new(\u0026#34;ls\u0026#34;).current_dir(\u0026#34;/\u0026#34;)// stdoutをnullにする .stdout(Stdio::null()).spawn().expect(\u0026#34;failed to execute process\u0026#34;);letstatus=child.wait().unwrap();println!(\u0026#34;{}\u0026#34;,status); ここではstdoutをnull ioに指定しています。他にはinheritで親プロセスのものを引き継ぐか、pipedで次のプロセスに渡すことも出来ます\n// 1つめのプロセスを作る letmutchild1=Command::new(\u0026#34;ls\u0026#34;).current_dir(\u0026#34;/\u0026#34;)// 出力は親プロセスへパイプする .stdout(Stdio::piped()).spawn().expect(\u0026#34;failed to execute process\u0026#34;);// 2つめのプロセスを作る letmutchild2=Command::new(\u0026#34;grep\u0026#34;).arg(\u0026#34;bin\u0026#34;)// 入力は親プロセスへパイプする .stdin(Stdio::piped()).spawn().expect(\u0026#34;failed to execute process\u0026#34;);{// Someと分かっているのでunwrapする。 // この辺はrustの型システテムの限界。 letout=child1.stdout.as_mut().unwrap();letin_=child2.stdin.as_mut().unwrap();// 1つめのプロセスの出力から2つめのプロセスの入力へデータをコピーする io::copy(out,in_).unwrap();}letstatus1=child1.wait().unwrap();letstatus2=child2.wait().unwrap();println!(\u0026#34;{}, {}\u0026#34;,status1,status2);bin sbin exit code: 0, exit code: 0 ちょっと繋ぎ込みが面倒ですしio::copyを使って手でコピーしてるのが頂けませんね。\nUnix Unixに依存することを認めてしまえばもうちょっと色々なことが出来ます。\n1つには\nusestd::os::unix::process::CommandExt; するといくつか追加のメソドが生えてくる仕組みになってます。\n例えば、exec が使えます。\nleterror=Command::new(\u0026#34;ls\u0026#34;).current_dir(\u0026#34;/\u0026#34;)// execを呼ぶ .exec();println!(\u0026#34;after exec!!\u0026#34;); execした後はRustのプロセスを別のものに置き換えてしまうのでprintln!(\u0026quot;after exec!!\u0026quot;);の行が実行されません。 されるとしたら何らかの理由でexecに失敗した場合だけです。なので面白いことにexecの返り値はエラーのみです。\nあるいは、unsafeなコードを認めるなら先のプロセスの繋ぎ込みはもうちょっとスマートに書けます。\nusestd::os::unix::io::{AsRawFd,FromRawFd};letmutchild1=Command::new(\u0026#34;ls\u0026#34;).current_dir(\u0026#34;/\u0026#34;)// 標準出力をパイプする .stdout(Stdio::piped()).spawn().expect(\u0026#34;failed to spawn a process\u0026#34;);letmutchild2=Command::new(\u0026#34;grep\u0026#34;).arg(\u0026#34;bin\u0026#34;)// 標準入力は手で作ったStdioオブジェクトにする。 // ここでは1つめのプロセスの標準出力を直接繋ぐ。 .stdin(unsafe{Stdio::from_raw_fd(child1.stdout.as_ref().unwrap().as_raw_fd())}).spawn().expect(\u0026#34;failed to spawn a process\u0026#34;);// 直接繋いでしまったのでコピーの必要はない letstatus1=child1.wait().unwrap();letstatus2=child2.wait().unwrap();println!(\u0026#34;{}, {}\u0026#34;,status1,status2);bin sbin exit code: 0, exit code: 0 Stdioがfdと行き来出来るのでそれを経由することでパイプを作れます。\nもちろん、ファイルに書き出すことも出来ます。\nusestd::os::unix::io::{AsRawFd,FromRawFd};letfile=File::create(\u0026#34;test.txt\u0026#34;).unwrap();// ファイルからFDを経由してStdioを作る letout=unsafe{Stdio::from_raw_fd(file.as_raw_fd())};letmutchild1=Command::new(\u0026#34;ls\u0026#34;).current_dir(\u0026#34;/\u0026#34;).stdout(out).spawn().expect(\u0026#34;failed to spawn a process\u0026#34;);letstatus1=child1.wait().unwrap();println!(\u0026#34;{}\u0026#34;,status1);$ cat test.txt bin boot cdrom core dev ... おわりに 最初は思ったよりCのプロセス回りのAPIと違って戸惑いますが馴れてしまえば使いやすいAPIでしょう。\n","categories":["Rust","Advent Calendar","Advent Calendar 2016","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2016","/categories/rust-advent-calendar"],"date":"2016-12-02","title":"Rustのプロセス","url":"https://KeenS.github.io/blog/2016/12/02/rustnopurosesu/"},
  {"body":"このエントリは言語実装 Advent Calendar 2016 - Qiita3日目の記事です。\nκeenです。先日、Rustの開発者フォーラムに新しいバックエンドしてcretonneが提案されていました。\nちょっと気になったのでそれを紹介します。\n概略  GitHub ドキュメント  フォーラムによると、WebAssemblyをエンコードするために作られたコンパイラバックエンドで、FirefoxのJSエンジンであるSpiderMonkeyに載せる予定だそうです。JITが主な目的？\nLLVMのように最適化を頑張る方ではなくてコードを吐くまでのレイテンシを気にして作られているとのこと。なのでcretonne自身は最適化を行いません。\n特徴はドキュメントのLLVMとの比較によくまとまってますが、\n LLVMは複数種類の中間言語を持つのに対してcretonneは1種類 アセンブラもディスアセンブラもない  コードジェネレータが吐く命令だけサポート  中間言語はISA非依存で、legalization / instruction selectionをするとISA固有のアノテーションが付く 最大抽象単位が関数(LLVMはモジュール)。cretonneは関数のインライン化とかもしない。 Extended Basic Blockを使う(LLVMはBasic Block)。  ebbは分岐命令のfalse branchを指定せず、fall throughする。よくあるマシン語に近い。 分岐の合流はebbに引数を持たせることで行う(LLVMはphi nodeを使う)。  undefined behaviorが存在しない  なんとなくWebAssemblyを意識した仕様ですね。\n雰囲気 以下のCのコードは\nfloat average(const float *array, size_t count) { double sum = 0; for (size_t i = 0; i \u0026lt; count; i++) sum += array[i]; return sum / count; } 以下のcretonneのIRに落ちるそうです。\nfunction average(i32, i32) -\u0026gt; f32 { ss1 = stack_slot 8, align 4 ; Stack slot for ``sum``. ebb1(v1: i32, v2: i32): v3 = f64const 0x0.0 stack_store v3, ss1 brz v2, ebb3 ; Handle count == 0. v4 = iconst.i32 0 br ebb2(v4) ebb2(v5: i32): v6 = imul_imm v5, 4 v7 = iadd v1, v6 v8 = heap_load.f32 v7 ; array[i] v9 = fext.f64 v8 v10 = stack_load.f64 ss1 v11 = fadd v9, v10 stack_store v11, ss1 v12 = iadd_imm v5, 1 v13 = icmp ult v12, v2 brnz v13, ebb2(v12) ; Loop backedge. v14 = stack_load.f64 ss1 v15 = cvt_utof.f64 v2 v16 = fdiv v14, v15 v17 = ftrunc.f32 v16 return v17 ebb3: v100 = f32const qNaN return v100 まあ、実際はファイルヘッダとかも付きますがこんな感じです。\nebbに引数があったりebbの途中で平気でブランチしてたり中々やんちゃですね。\n使ってみる コードを吐くところまでやりたかったのですがまだ絶賛開発中ということもあってそのような操作が見当りませんでした。\nということでファイルの方を扱ってると面白みがないのでRust APIの方で関数を構築して正当性を検証してから中間言語を吐き出してみます。\n一歩 まずはcretonneをcloneしてきます。\n$ cargo new cretonne-sample --bin $ cd cretonne-sample んでCargo.tomlのdependenciesに\ncretonne = {path = \u0026#34;path/cretonne/lib/cretonne/\u0026#34;} を追加します。どうやらトップレベルのプロジェクトはただのユーティリティのようでした。本体はlib/cretonne/以下にいます。\nそしてmainファイルの中身はこうです。\nexterncratecretonne;usecretonne::ir::*;usecretonne::ir::{typesasty};usecretonne::ir::{immediatesasimm};usecretonne::isa;usecretonne::settings::{self,Configurable};usecretonne::{write_function,legalize_function,verify_function};fn main(){letmutfunc={letname=FunctionName::new(\u0026#34;average\u0026#34;);letmutsig=Signature::new();sig.argument_types.push(ArgumentType::new(ty::I32));sig.argument_types.push(ArgumentType::new(ty::I32));sig.return_types.push(ArgumentType::new(ty::F32));Function::with_name_signature(name,sig)};letisa={letmutb=settings::builder();b.set(\u0026#34;opt_level\u0026#34;,\u0026#34;fastest\u0026#34;).unwrap();letf=settings::Flags::new(\u0026amp;b);letbuilder=isa::lookup(\u0026#34;intel\u0026#34;).unwrap();builder.finish(f)};verify_function(\u0026amp;func).unwrap();legalize_function(\u0026amp;mutfunc,isa.as_ref());letmuto=String::new();write_function(\u0026amp;muto,\u0026amp;func,Some(isa.as_ref())).unwrap();println!(\u0026#34;{}\u0026#34;,o);}functionaverage(i32,i32)-\u0026gt; f32 {} おおまかにはfuncを構築してisaを決めてverify_functionで検証、さらにlegalize_functionで今回のアーキテクチャ向けに微調整、write_functionで書き出しです。\nスタックスロットの追加 まあ、スタック領域ですね。8byteの領域を確保します。\nfuncにstack_slotsフィールドがあるのでそこにpushします。\nfn main(){letmutfunc={....};{letk=func.stack_slots.push(StackSlotData::new(8));}letisa={....};....}function average(i32, i32) -\u0026gt; f32 { ss0 = stack_slot 8 } pushの返り値はスタック領域を指すキーです。\nEBBの追加 func構造体のフィールドにdfgがいて、そいつを色々いじります。\nfn main(){letmutfunc={....};{letk=func.stack_slots.push(StackSlotData::new(8));letcur=\u0026amp;mutCursor::new(\u0026amp;mutfunc.layout);letebb0=func.dfg.make_ebb();letv1=func.dfg.append_ebb_arg(ebb0,types::I32);letv2=func.dfg.append_ebb_arg(ebb0,types::I32);cur.insert_ebb(ebb0);}letisa={....};....}function average(i32, i32) -\u0026gt; f32 { ss0 = stack_slot 8 ebb0(vx0: i32, vx1: i32): } EBBの追加にはカーソルを決めてあげて、dfgにebbを作ってあげて、カーソルの位置にebbの追加という形になります。\nEBBには任意に引数を追加出来ます。append_ebb_argの返り値はSSAの変数です。\n命令を追加する 命令はpythonのスクリプトによって生成されるので補完が効かず、中々扱いづらいですが頑張ります。\nさて、今回コードの検証を入れているので以下のようなコードは検証に落ちてしまいます。\n....{letk=func.stack_slots.push(StackSlotData::new(8));letcur=\u0026amp;mutCursor::new(\u0026amp;mutfunc.layout);letdfg=\u0026amp;mutfunc.dfg;letebb0=dfg.make_ebb();letv1=dfg.append_ebb_arg(ebb0,types::I32);letv2=dfg.append_ebb_arg(ebb0,types::I32);cur.insert_ebb(ebb0);letv3=dfg.ins(cur).f64const(imm::Ieee64::new(0.0));}....thread \u0026#39;main\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: Error { location: Ebb(Ebb(0)), message: \u0026#34;block does not end in a terminator instruction!\u0026#34; }\u0026#39;, ../src/libcore/result.rs:799 最後の命令が定数であるため、正常なブロックと見做されないのです。\nひとまずv3を返すことで凌ぎます。\n....{....letmutvarg=VariableArgs::new();varg.push(v3);let_=dfg.ins(cur).return_(varg);}....function average(i32, i32) -\u0026gt; f32 { ss0 = stack_slot 8 ebb0(vx0: i32, vx1: i32): [-] v0 = f64const 0.0 [-] return v0 } 命令の頭に付いてる [-]はlegalizeすると付くようです。\nブランチ もう1つebbを追加してあげる必要があります。\n{letk=func.stack_slots.push(StackSlotData::new(8));letcur=\u0026amp;mutCursor::new(\u0026amp;mutfunc.layout);letdfg=\u0026amp;mutfunc.dfg;letebb0=dfg.make_ebb();letebb3=dfg.make_ebb();// \u0026lt;- ebb3を作成 letv1=dfg.append_ebb_arg(ebb0,types::I32);letv2=dfg.append_ebb_arg(ebb0,types::I32);cur.insert_ebb(ebb0);letv3=dfg.ins(cur).f64const(imm::Ieee64::new(0.0));dfg.ins(cur).brz(v2,ebb3,VariableArgs::new());// \u0026lt;-ebb3にジャンプ letmutvarg=VariableArgs::new();varg.push(v3);let_=dfg.ins(cur).return_(varg);cur.insert_ebb(ebb3);// \u0026lt;- ebb3を追加 }function average(i32, i32) -\u0026gt; f32 { ss0 = stack_slot 8 ebb0(vx0: i32, vx1: i32): [-] v0 = f64const 0.0 [-] brz vx1, ebb1 [-] return v0 ebb1: } 残り {letk=func.stack_slots.push(StackSlotData::new(8));letcur=\u0026amp;mutCursor::new(\u0026amp;mutfunc.layout);letdfg=\u0026amp;mutfunc.dfg;letebb0=dfg.make_ebb();letv1=dfg.append_ebb_arg(ebb0,types::I32);letv2=dfg.append_ebb_arg(ebb0,types::I32);letebb2=dfg.make_ebb();letv5=dfg.append_ebb_arg(ebb0,types::I32);letebb3=dfg.make_ebb();cur.insert_ebb(ebb0);letv3=dfg.ins(cur).f64const(imm::Ieee64::new(0.0));dfg.ins(cur).brz(v2,ebb3,VariableArgs::new());letv4=dfg.ins(cur).iconst(types::I32,0);letmutebb2_arg=VariableArgs::new();ebb2_arg.push(v4);dfg.ins(cur).jump(ebb2,ebb2_arg);cur.insert_ebb(ebb2);letv6=dfg.ins(cur).imul_imm(v5,4);letv7=dfg.ins(cur).iadd(v1,v6);dfg.ins(cur).jump(ebb3,VariableArgs::new());cur.insert_ebb(ebb3);} こんな感じで進めていこうと思いましたがどうやらまだstack/heapを触る命令がない？？ようなので詰みました。\nまとめ  コンパイラバックエンドcretonneについて紹介しました cretonneのRust APIを触ってみましたがダメでした。 ","categories":["Rust","言語実装","Advent Calendar","Advent Calendar 2016","言語実装 Advent Calendar"],"category_urls":["/categories/rust","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/advent-calendar","/categories/advent-calendar-2016","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-advent-calendar"],"date":"2016-12-02","title":"新しいコンパイラバックエンドcretonne","url":"https://KeenS.github.io/blog/2016/12/02/atarashiikonpairabakkuendocretonne/"},
  {"body":"このエントリはRust その2 Advent Calendar 2016 - Qiita2日目の記事です。\nRustはシステムプログラミング言語なのでバイト列をあれこれしたいことがあると思います。その時にイテレータでバイト列を舐める以外にも色々方法があるなと気付いたので。\nRead と Write 私には割と衝撃だったのですが\u0026amp;[u8]や\u0026amp;mut [u8]、Vec\u0026lt;u8\u0026gt;は直接ReadやWriteのインスタンスになってます。 例えばReadならこういう風に使えます。\nletmutbytes: \u0026amp;[u8]=\u0026amp;[1,2,3,4,5,6];letmutbuf=[0;3];bytes.read_exact(\u0026amp;mutbuf).unwrap();println!(\u0026#34;read: {:?}, rest: {:?}\u0026#34;,buf,bytes);read: [1, 2, 3], rest: [4, 5, 6] あるいは .bytes()でbyteのイテレータを取り出してもいいですし、如何様にも扱えます。\n少し注意が必要なのはVecは Read を実装してないので一旦スライスに変換してあげる必要がありますが、やり方を工夫する必要があります。\n以下は少しびっくりする例。\nletbytes: Vec\u0026lt;u8\u0026gt;=vec![1,2,3,4,5,6];letmutbuf=[0;3];(\u0026amp;bytes[..]).read_exact(\u0026amp;mutbuf).unwrap();println!(\u0026#34;read: {:?}, rest: {:?}\u0026#34;,buf,bytes);read: [1, 2, 3], rest: [1, 2, 3, 4, 5, 6] 一旦スライスを取り出してその場で捨てているのでbytesは消費されません。\nそうやりたいなら\nletbytes: Vec\u0026lt;u8\u0026gt;=vec![1,2,3,4,5,6];letmutbytes=\u0026amp;bytes[..];letmutbuf=[0;3];bytes.read_exact(\u0026amp;mutbuf).unwrap();println!(\u0026#34;read: {:?}, rest: {:?}\u0026#34;,buf,bytes); のように一旦スライスを束縛してから使います。\nWriteの方も似ていて、そのままwrite出来ますし、消費されます。ただ、書き込み領域が空になってもそのままスルーされるので注意です。\nlet mut bytes: \u0026amp;mut [u8] = \u0026amp;mut [0; 6]; let data = \u0026amp;[1, 2, 3]; println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;, data, bytes); bytes.write(data).unwrap(); println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;, data, bytes); bytes.write(data).unwrap(); println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;, data, bytes); bytes.write(data).unwrap(); println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;, data, bytes);data: [1, 2, 3], buf: [0, 0, 0, 0, 0, 0] data: [1, 2, 3], buf: [0, 0, 0] data: [1, 2, 3], buf: [] data: [1, 2, 3], buf: [] 最後、バッファが空になった状態で書き込んでも無言で書き込みが終了しています。そして書き込んだデータへのアクセスは出来てないですね。\nこうすると出来ます。\nletmutbytes:[u8;6]=[0;6];letdata=\u0026amp;[1,2,3];{letmutbuf: \u0026amp;mut[u8]=\u0026amp;mutbytes;println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;,data,buf);buf.write(data).unwrap();println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;,data,buf);buf.write(data).unwrap();println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;,data,buf);}println!(\u0026#34;bytes: {:?}\u0026#34;,bytes);data: [1,2,3],buf: [0,0,0,0,0,0]data: [1,2,3],buf: [0,0,0]data: [1,2,3],buf: []bytes: [1,2,3,1,2,3] まあまあ面倒ですね。というかそもそも固定長のバッファに書き込みたいという需要が少ない。\nでもこれはVecを使えば解決します。可変長ですしWrite も実装しているので便利です。\nletmutbytes: Vec\u0026lt;u8\u0026gt;=Vec::new();letdata=\u0026amp;[1,2,3];println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;,data,bytes);bytes.write(data).unwrap();println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;,data,bytes);bytes.write(data).unwrap();println!(\u0026#34;data: {:?}, buf: {:?}\u0026#34;,data,bytes);println!(\u0026#34;bytes: {:?}\u0026#34;,bytes);data: [1,2,3],buf: []data: [1,2,3],buf: [1,2,3]data: [1,2,3],buf: [1,2,3,1,2,3]bytes: [1,2,3,1,2,3] Cursor さて、上で見た通り、なんとなく生のバイト列だと扱いづらそうな場面がありそうですよね。 そこで std::io::Cursorを使うと便利です。\nCursorはコンストラクタで引数の所有権を奪うタイプの、ラッパーオブジェクト的構造体です。\nreadだとこんな感じです。\nletbytes: \u0026amp;[u8]=\u0026amp;[1,2,3,4,5,6];letdata: \u0026amp;mut[u8]=\u0026amp;mut[0;3];letmutcur=Cursor::new(bytes);println!(\u0026#34;data: {:?}, position {}\u0026#34;,data,cur.position());cur.read_exact(data).unwrap();println!(\u0026#34;data: {:?}, position {}\u0026#34;,data,cur.position());cur.read_exact(data).unwrap();println!(\u0026#34;data: {:?}, position {}\u0026#34;,data,cur.position());println!(\u0026#34;bytes: {:?}\u0026#34;,cur.into_inner());data: [0,0,0],position0data: [1,2,3],position3data: [4,5,6],position6bytes: [1,2,3,4,5,6] ポジションが取れるのと元のオブジェクトが無事なのが違いますね。\nWriteも同様です。\nletbytes: \u0026amp;mut[u8]=\u0026amp;mut[0;6];letdata: \u0026amp;[u8]=\u0026amp;[1,2,3];letmutcur=Cursor::new(bytes);println!(\u0026#34;bytes: {:?}, position {}\u0026#34;,cur.get_ref(),cur.position());cur.write(data).unwrap();println!(\u0026#34;bytes: {:?}, position {}\u0026#34;,cur.get_ref(),cur.position());cur.write(data).unwrap();println!(\u0026#34;bytes: {:?}, position {}\u0026#34;,cur.get_ref(),cur.position());println!(\u0026#34;bytes: {:?}\u0026#34;,cur.into_inner());data: [0, 0, 0, 0, 0, 0], position 0 data: [1, 2, 3, 0, 0, 0], position 3 data: [1, 2, 3, 1, 2, 3], position 6 bytes: [1, 2, 3, 1, 2, 3] さて、このCursorの面白いのは\u0026amp;[u8]でなくAsRef\u0026lt;[u8]\u0026gt;でReadを実装していますしstd::io::Seekも実装しているのでこういうことが出来ます。\nletbytes: Vec\u0026lt;u8\u0026gt;=Vec::new();letdata: \u0026amp;[u8]=\u0026amp;[1,2,3];letbuf: \u0026amp;mut[u8]=\u0026amp;mut[0;3];letmutcur=Cursor::new(bytes);println!(\u0026#34;bytes: {:?}, position {}\u0026#34;,cur.get_ref(),cur.position());cur.write(data).unwrap();println!(\u0026#34;bytes: {:?}, position {}\u0026#34;,cur.get_ref(),cur.position());cur.write(data).unwrap();println!(\u0026#34;bytes: {:?}, position {}\u0026#34;,cur.get_ref(),cur.position());cur.seek(SeekFrom::Start(0)).unwrap();println!(\u0026#34;bytes: {:?}, position {}\u0026#34;,cur.get_ref(),cur.position());cur.read(buf).unwrap();println!(\u0026#34;bytes: {:?}, position {}, buf: {:?}\u0026#34;,cur.get_ref(),cur.position(),buf);bytes: [], position 0 bytes: [1, 2, 3], position 3 bytes: [1, 2, 3, 1, 2, 3], position 6 bytes: [1, 2, 3, 1, 2, 3], position 0 // \u0026lt;- 0にシークした bytes: [1, 2, 3, 1, 2, 3], position 3, buf: [1, 2, 3] // \u0026lt;- 0からリード出来てる 生のVecでは出来なかったread and writeが実現出来ています。そして好きにカーソルをシーク出来ます。 ここまでくるとほとんどファイルと変わらなく扱えますね。\nおりに ちょっとしたTipsですが道具箱にこういうのを増やしておくと便利ですよね！！\n参考  std::io::Read - Rust std::io::Write - Rust std::io::Cursor - Rust std::io::Seek - Rust std::io::SeekFrom - Rust ","categories":["Rust","Advent Calendar","Advent Calendar 2016","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2016","/categories/rust-advent-calendar"],"date":"2016-12-01","title":"Rustでバイト列を扱う時のtips","url":"https://KeenS.github.io/blog/2016/12/01/rustdebaitoretsuwoatsukautokinotips/"},
  {"body":"このエントリは言語実装 Advent Calendar 2016 - Qiita2日目の記事です。\nκeenです。マクロなどのコンパイル時に何か処理をしてコード生成する機構の実現方法が言語によって様々にあるなぁと思ったのでちょっと探ってみます\nなんか文字だけ並んでても味気ないのでサンプルマクロも付けときますね。\nコンパイラにマクロ専用言語のインタプリタ機能を付けるやつ Rustのmacro_rulesやSchemeのsyntax-rulesが該当します。\n(define-syntax define-protocol (syntax-rules () ((define-protocol (name type ...) (method arg ...) ...) (begin (define method (make-generic)) ... (define name (lambda (type ...) (lambda methods (add-methods methods (list (list method arg ...) ...))))))))) 制限が強い上に無駄にコンパイラの機能が増えるので個人的にはあまり好きじゃないですね…。\nコンパイラでもホスト言語を動かすやつ コンパイラとランタイムが一緒になっているCommon Lispなんかで使われる方法です。\n(defmacro dotimes-unroll ((i n unroll) \u0026amp;body body) (let ((n_ (gensym \u0026#34;n\u0026#34;))) `(let ((,n_ ,n)) (do ((,i 0)) ((\u0026lt; ,n_ (the fixnum (+ ,unroll ,i))) (do ((,i ,i (the fixnum (1+ ,i)))) ((\u0026lt; ,n_ (the fixnum (1+ ,i)))) ,@body )) ,@(loop :repeat unroll :append (append body `((setq ,i (the fixnum (1+ ,i)))))))))) マクロがなくなるまで再帰的にマクロ展開をします。 ユーザが好き勝手書けてしかも手軽に使えるので割と好きです。まあ、でも言語を選びますね。\nコンパイラプラグインとしてdlopenするやつ Rustのコンパイラプラグインが相当します。\n[lib] crate-type = [\u0026#34;dylib\u0026#34;] plugin = truefn codegen\u0026lt;\u0026#39;cx\u0026gt;(cx: \u0026amp;\u0026#39;cx mutExtCtxt,text: String,file: String)-\u0026gt; Box\u0026lt;MacResult+\u0026#39;cx\u0026gt;{letmutoutput=Vec::new();letdoc=Document::parse(\u0026amp;text).expect(\u0026#34;failed to parse thrift file\u0026#34;).expect(\u0026#34;EOF while parsing thrift file\u0026#34;);{letns=find_rust_namespace(\u0026amp;doc).expect(\u0026#34;cannot find namespace\u0026#34;);output.write_all(format!(\u0026#34;mod {} {{\u0026#34;,ns.module).as_ref()).expect(\u0026#34;internal error failed to write the vec\u0026#34;);}compile(doc,\u0026amp;mutoutput).expect(\u0026#34;failed to generate code\u0026#34;);output.write_all(format!(\u0026#34;}}\u0026#34;).as_ref()).expect(\u0026#34;internal error failed to write the vec\u0026#34;);letoutput=matchstd::str::from_utf8(\u0026amp;output){Ok(s)=\u0026gt;s,Err(_)=\u0026gt;\u0026#34;\u0026#34;,};trace!(\u0026#34;{}\u0026#34;,output);letparser=new_parser_from_source_str(cx.parse_sess(),file,output.to_string());struct ExpandResult\u0026lt;\u0026#39;a\u0026gt;{p: parse::parser::Parser\u0026lt;\u0026#39;a\u0026gt;,}impl\u0026lt;\u0026#39;a\u0026gt;base::MacResultforExpandResult\u0026lt;\u0026#39;a\u0026gt;{fn make_items(mutself: Box\u0026lt;ExpandResult\u0026lt;\u0026#39;a\u0026gt;\u0026gt;)-\u0026gt; Option\u0026lt;SmallVector\u0026lt;ptr::P\u0026lt;ast::Item\u0026gt;\u0026gt;\u0026gt;{letmutret=SmallVector::zero();whileself.p.token!=token::Eof{matchpanictry!(self.p.parse_item()){Some(item)=\u0026gt;ret.push(item),None=\u0026gt;panic!(self.p.diagnostic().span_fatal(self.p.span,\u0026amp;format!(\u0026#34;expected item, found `{}`\u0026#34;,self.p.this_token_to_string())))}}Some(ret)}}Box::new(ExpandResult{p: parser})}fn macro_thrift\u0026lt;\u0026#39;cx\u0026gt;(cx: \u0026amp;\u0026#39;cx mutExtCtxt,sp: Span,tts: \u0026amp;[TokenTree])-\u0026gt; Box\u0026lt;MacResult+\u0026#39;cx\u0026gt;{lettext=matchget_single_str_from_tts(cx,sp,tts,\u0026#34;thrift!\u0026#34;){Some(f)=\u0026gt;f,None=\u0026gt;returnDummyResult::expr(sp),};codegen(cx,text,\u0026#34;trift!\u0026#34;.to_string())}#[plugin_registrar]pubfn plugin_registrar(reg: \u0026amp;mutRegistry){reg.register_macro(\u0026#34;thrift\u0026#34;,macro_thrift);reg.register_macro(\u0026#34;thrift_file\u0026#34;,macro_thrift_file);} 一旦dllを作ってそれをプラグインとしてロードするという手間もありますし、ユーザが触れるASTも複雑なのであまり好きではないです。 まあ、これは準クオートだとかのユーザインターフェースの問題だったりするんですが。 ただ表現力はホスト言語が使えるので自由に使えます。\n言語の仕組みを使ってライブラリをコンパイラにロードする 私が地味に好きな言語にmirahというのがあります。その言語での実現方法が少し好きでした。 mirahはJVMで動くRuby風言語で、コンパイラは既にセルフホストされています。つまりコンパイラもJVMで動く訳です。\nJavaにはSPIというものがあって明示的にクラスやインスタンスを指定しなくてもJVMが実装を捜してくれる機能があります。 その機能にのっかることでマクロを.classファイルにコンパイルしてクラスパスに置いておくだけでマクロが使えるようになります。\n$ExtensionsRegistration[[\u0026#39;java.util.Map\u0026#39;]] class MapExtensions macro def [](key) quote { `@call.target`.get(`key`) } end end class Builtins implements ExtensionsProvider def register(type_system:ExtensionsService):void type_system.macro_registration(MapExtensions.class) end end 中々面白いですね。\nおわりに なんか実装コード1つない雑な記事で申し訳ありませんがmirahのマクロの仕組みがちょっと気に入ったので書こうと思った次第です。\nあとはOCamlのppxやHaskellのTHも気になるのですが調べきれませんでした。はい。\n","categories":["言語実装","マクロ","Advent Calendar","Advent Calendar 2016","言語実装 Advent Calendar"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/%e3%83%9e%e3%82%af%e3%83%ad","/categories/advent-calendar","/categories/advent-calendar-2016","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-advent-calendar"],"date":"2016-12-01","title":"マクロやコンパイラプラグインの実装方法色々","url":"https://KeenS.github.io/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou/"},
  {"body":"このエントリはIT勉強会/コミュニティ運営 Advent Calendar 2016 - Qiita2日目の記事です。\nShibuya.lispの開催しているlispmeetupは約4年間毎月開催しました（現46回開催）。 そこまで長く続いているコミュニティ活動はそんなに多くないのではないでしょうか。 lispmeetupがどうして続いたのかちょっと考察してみます。\n因みにlispmeetupを開催しているのは第2期運営で、Shibuya.lisp自体はそれより前から活動しています。\n私は2期運営に途中から入った人でmeetup第6回から参加し始めて確か19回くらいから運営になったと思います。\n会場が安定的に確保出来た 安定してるかは若干怪しいですが毎月会場確保が出来ていたのは事実です。 最初の頃は天井から木の根が出てくるお粗末な会場だったそうですが、私が参加するころには毎回サイバーエージェントのセミナールームを使ってました。\n発表者がいなかったら運営が発表した 勉強会に来たのに発表がなかったら残念ですよね。 どんな回でも少なくとも運営が発表するので2件くらいは発表がありました。 時間が余ったらライブコーディングしたりもしてました。\n因みに私も毎月発表してるからという理由で運営になったような気がします。\nテーマをローテした Lisp固有の事情かもしれませんがメジャーな方言にCommon Lisp、 Clojure、Schemeがあります。 参加者の中には全部いけるって人もそれなりにいますがClojureにしか興味がないって人もいます。 なので毎回テーマを決めてある程度発表者、参加者のゾーンニングをした方が満足度が高い訳です。\nローテションというのもまあまあ重要で、まず運営が考えることが少なくて済む。 発表者は3ヶ月に1回くらいの頻度で自分の興味のある方言の回がやってくるのでそれなりに準備期間がある。 参加者も今月はClojureだから無理してでもいこおう、Common Lispだから今月はいいやみたいにメリハリが付けれる。\n平日開催した 善し悪しだと思いますが平日開催に拘りました。平日にしか来れない人を集めたいという意向です。 逆に休日にしか来れない人は切り捨てちゃってますね。\n来れる人が渋谷近辺の人に限られてしまいますがまあ、Shibuya.lispなのでご愛嬌。 参加する人は地球の裏側からでも来ます。これは半分本当で、オランダとかからの参加者も過去にいました。\n仕事帰りに参加する人とか学生とかが多いようでした。\n運営の負荷を減らした テーマをローテしたのところでも述べましたが、極力運営の負荷は減らした方がいいです。 運営が動かないと何も進まないので開催が億劫になるくらいなら負荷は減らしましょう。 lispmeetupでは開催報告やレポートをメーリスに投げていましたがやめてしまいました。 まあ、connpassが優秀だったのである程度そっちに頼れたというのもあります。\nまた、最初のうちは懇親会で余ったお金を予算として持っていましたが、管理コストもかかるので掃き出してしまいました。\nとにかく毎月開催した 最初の頃は参加者が1ケタの時もありました。それでも毎月続けました。 するとある程度lispmeetupが定着したのかここ1年ほどは会場定員オーバーくらいまで人が集まるようになりました。\n懇親会を毎回やった 地味に重要だと思います。 発表者に質問にいったりあるいはふとした会話から次の発表のネタが産まれたりします。 新規参加者も重要ですがリピーターも重要です。\n最後に LispMeetUpは4年の節目で一旦終了します。\nShibuya.lispの現運営が引退するので #lispmeetup がなくなります。引き継いでくれる方を募集しています。残りはClojure回、CL回です。Schemeは今月が最後でした。https://t.co/o4vv9DRFal\n\u0026mdash; κeen (@blackenedgold) 2016年11月29日 \n今の運営が引退した後を引き継いでくれる人も集まりそうなので何らかの形では続くと思いますが、lispmeetupという形をとるのかTech Talkだけになるのかは次の運営次第です。\nお疲れ様でした。\n","categories":["Lisp","Advent Calendar","Advent Calendar 2016"],"category_urls":["/categories/lisp","/categories/advent-calendar","/categories/advent-calendar-2016"],"date":"2016-12-01","title":"4年間続いたShibuya.lispのLispMeetUp","url":"https://KeenS.github.io/blog/2016/12/01/4nenkantsuzuitashibuya_lispnolispmeetup/"},
  {"body":"このエントリはEx CyberAgent Developers Advent Calendar 2016 - Adventar1日目の記事です。 元サイバーエージェントの人がわいわいやります。\nκeenです。二年弱勤めたサイバーエージェントを退職したのでその旨について。\nサイバーエージェントの思い出 サイバーエージェントに興味をもつきっかけになったのも入社することになったのも学生の頃からずっと参加し続けていたLispMeetUpでした。 LispMeetUpでは長らく会場としてCAのセミナールームを使わせてもらっていました。 そこでエンジニアに対して気軽に施設を提供するCAや社員の@potix2さんを知って、そのまま@potix2さんの手引でCAに入社する運びとなりました。 「面接でLispは口にしない方が良い。100%落ちる。」なんて言ってた割にはLisp繋りで入社しました。\n CyberAgentに入社しました | κeenのHappy Hacκing Blog  新卒で入社してからは3ヶ月ほど研修でした。 最初の2週間ほどあるビジネス職も含めた全体研修ではなるほど、ここがCAかと思いました。しかしエンジニア研修からは見慣れた光景に戻って静かに研修を受けてました。 エンジニア研修は割と長めにあるので同期のエンジニア同士の顔を覚える余地はありました。勉強会なんかもやりました。\n 静的なメモリ管理の話。リージョン推論とλ計算からRustまで | κeenのHappy Hacκing Blog 勉強会駆動勉強で猛勉強 | κeenのHappy Hacκing Blog 21世紀のエンジニアのためのHTTP/2入門 | κeenのHappy Hacκing Blog  などなど。Linux, C, Python, Go, Java, Web, iOS, フレームワーク, Android, チーム開発なんかをやりました。Python, Go, iOSあたりは自分じゃやらなかったので面白かったです。\n研修中は割と時間があったので他にも色々なことをやってました。\n tarballベースの軽量バックアップツール\u0026rsquo;Sheltar\u0026rsquo;を作った | κeenのHappy Hacκing Blog Onigmoを最大49%高速化した話 | κeenのHappy Hacκing Blog 第一級ラベルを持たない言語におけるDirect Threaded VMの実装 | κeenのHappy Hacκing Blog  この他にも研修期間中にブログエントリ十数本書いていたようです。下の代からは研修の内容が変わって忙しそうでした。\n研修のあとの配属は@potix2さんのいるアドテクスタジオのAMoAdでした。トレーナの清水さんを始めとしてチームの皆さんにお世話になりました。 AMoAdはその昔、外注していたシステムを巻き取ったものなのでやることが一杯あって、JavaやScalaを書いたり自動化をやったりしました。\nScalaは全然いたことがなかったので練習がてら作ったのがこれでした。\n Scala初心者の新卒が頑張ってLispを作ってみた | Scala Tech Blog  これのおかげで型クラスがただのimplpcit parameterに見えるようになったのでそれなりに収穫はあったな、と思ってます。\nAMoAdに限らずアドテクスタジオのエンジニアのボリュームゾーンは30代半ばなのでだいたい一回り近く年の離れたエンジニアに暖かく囲まれながら仕事をしていました。 どんな雰囲気なの？とたまに訊かれますがエンジニアが集う部署なのでだいたい工学部を想像して頂けたらと思います。\nさて、年が明けて2016年の1月になると、@potix2さんが新しいグループを立ち上げることになって別のグループに移動してしまいました。長らくお世話になりました。 と思いきや自分もそのグループに移動になったので相変わらずお世話になることになりました。基盤開発グループってところでした。仕事と仕事の境目は一瞬仕事がない期間が産まれたりしますが、その隙を使って始めたのがRustのドキュメントの翻訳です。\n Rustのドキュメントの翻訳プロジェクトを開始します。 - Qiita  あたらしいチームでは社内向けマイクロサービスのようなものを作ることになりました。 私ともう一人ベテランのエンジニア(@atty303)でやる筈でしたが私のような雑草と違ってベテランは中々元のチームを抜けられないので1ヶ月ほど私一人でコードを書いてました。 Scalaにも馴れてない新卒一人で。1ヶ月後に@atty303さんがジョインすると、コードは書かずにインフラをやるとのことでした。なのでコードを書くのはやっぱり私一人。\n私が苦戦しつつコードを書いている間にconsulやnomad、terraform、dockerなんかでインフラが構築されていき、たまに朝来たら自分のコードが消えていたり（「君のコード書き直しといたよ」）して確か5月頃リリースだったような。\n因みにdockerを多く使うのにdocker-machineだと不便なのでUbuntuマシンが欲しいって言ったら却下されました。セキュリティ的に無理でした。結局VMでUbuntuを使ってました（使ってます）。\nリリースしてからは要求性能も満たしそこまで大きな障害もなく平和に暮らしました。めでたしめでたし。Ubuntuは使えなかったけど。\nまあ、あとは新卒研修を担当したりインターンを担当したり社内ハッカソンをやったりゼミでドローンを飛ばしたり新卒のトレーナーをやったりライブラリの選書をやってコンパイラの本を大量に入荷したりと本業以外も色々やってました。長くなるのでこの辺は省きますね。\n退職に際して よく、「合わなかったの？」と言われますがそんなことはないです。（少くとも）アドテクスタジオはエンジニアにとっては非常に働きやすい場所でしたし\n adtech studio - Photo Tour｜FEATURES  CAの一般的イメージはそういう部分だけ切り取ってメディアに出してるんだと思います。 エンジニアから見たら先述の通り工学部のような雰囲気です。Ubuntuは使えないけど。サーバもMacやWindowsで動いてるんですかね。\nむしろCAに入って良かったなと思える部分は一杯あって、ベテランのエンジニアに色々教えて貰ったりだとかVMwareのライセンスを買ってくれたりだとかICFPに行かせてもらったりだとか。\n同期エンジニアの繋りというのもすごい良くて、得意分野も部署も（今となっては）会社も色々にある60人ほどいるエンジニアとの人脈が無条件に作れるというのは新卒で入らないと出来ないなと思います。 困ったことがあったら同期Slackに投げると数分で解決します。\n最後は雑草が枯れるように誰にも気付かれないように消えていくつもりでしたがそうもいかず、大勢の方々に送り出して頂きました。\n私の周りにいるのがお世話になった開発責任者やトレーナー、トレーニーなどですね。\n色紙とプレゼントも頂きました。ありがとうございます。\n退職の旨は業務上必要な方以外には知らせてなかったのでまさか色紙が来るとは思ってませんでした。 多分関係しそうな人にDMを送って集めたんだと思います。ありがとうございます。 プレゼントは麻の模様の風呂敷です。 私はカバン代わりにPCを入れるにも旅行に行くにも風呂敷を使う人です:)\nそして女性エンジニアの方(@iyunoriue)からFOUNDRYの詰め合わせも頂きました。\nスイーツが好きなので非常に嬉しいです。ありがとうございます。抹茶と合いそう。\nまた、退職に合わせて色々なものも引退することになりました。\nShibuya.lispの現運営が引退するので #lispmeetup がなくなります。引き継いでくれる方を募集しています。残りはClojure回、CL回です。Schemeは今月が最後でした。https://t.co/o4vv9DRFal\n\u0026mdash; κeen (@blackenedgold) 2016年11月29日 そろそろ私も野生のLisper引退した方がいい。\n\u0026mdash; κeen (@blackenedgold) 2016年11月29日 お世話になった方々本当にありがとうございました。\n次の話と退職理由 とりあえず12月中は有給消化で、1月から働きます。給料はまあまあ上がります。どうやらコンパイラ関係の仕事をしそうです。 世の中そんな仕事があるのか自分でも半信半疑ですがあるようです。\nそういえばICFPのときにкeenさんと話して「えっコンパイラが書けるシゴトあると思ってんの!?」と冗談半分で言われたな．\n\u0026mdash; gfn (@bd_gfngfn) 2016年9月25日 私のことを知ってる方なら「コンパイラの仕事があるから」で十分退職理由として納得頂けると思います。 技術的にも人生的にもチャレンジングですがまだ20代前半なので後先考えずに行動してもどうにかなるかな、とか思ってます。 地味に社内でRustも使われているようなのでそこも狙っていこうと思います。 あ、こういうのもやってます。興味のある方はお願いします。\n 言語実装 Advent Calendar 2016 - Qiita Rust その2 Advent Calendar 2016 - Qiita  次の仕事についてはまた入社してから書こうと思いますが、ひとまずの報告として渋谷からは離れます。本郷キャンパスに近いところに引っ越す予定です。付近の人はなんか誘って下さい。\nhttp://amzn.asia/0JcDzIf\n お疲れ様でした\n","categories":["番外編","Advent Calendar","Advent Calendar 2016"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8","/categories/advent-calendar","/categories/advent-calendar-2016"],"date":"2016-11-30","title":"サイバーエージェントを退職しました","url":"https://KeenS.github.io/blog/2016/11/30/saiba_e_jientowotaishokushimashita/"},
  {"body":"この記事はML Advent Calendar 2016 - Qiitaの1日目の記事です。\nκeenです。小ネタを。Ubuntu 16.10でSML#を動かそうと思ったら動かなかったので動かします。\n現象 リンカがエラーを吐く。バイナリが正しく作れてなさそう\n/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(callback.o): relocation R_X86_64_32 against `.text\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(control.o): relocation R_X86_64_32 against `.text\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(error.o): relocation R_X86_64_32 against `.bss\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(exn.o): relocation R_X86_64_32 against `.rodata.str1.8\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください 。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(finalize.o): relocation R_X86_64_32 against `.text\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(init.o): relocation R_X86_64_32 against `.rodata.str1.1\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(object.o): relocation R_X86_64_32 against `.rodata.str1.1\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(xmalloc.o): relocation R_X86_64_32 against `.rodata.str1.1\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてくだ さい。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(prim.o): relocation R_X86_64_32 against `.rodata\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(top.o): relocation R_X86_64_32 against `.text\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(dtoa.o): relocation R_X86_64_32 against `.rodata.str1.1\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(heap_concurrent.o): relocation R_X86_64_32S against `.bss\u0026#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。 /usr/bin/ld: 最終リンクに失敗しました: 出力に対応するセクションがありません collect2: error: ld returned 1 exit status uncaught exception: CoreUtils.Failed: gcc -Wl,-Bsymbolic-functions -Wl,-z,relro test/Main.o /tmp/tmp.IhaEmV/000/tmp_000.a lib/socket.o lib/inet.o lib/net_host_db.o /usr/lib/x86_64-linux-gnu/smlsharp/runtime/main.o /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a -lpthread -lyajl -ldl -lgmp -lm -o testRunner at src/compiler/toolchain/main/CoreUtils.sml:113 Makefile:50: ターゲット \u0026#39;testRunner\u0026#39; のレシピで失敗しました 原因 私もよく分かってないのですが、Ubuntu 16.10からGCC 6系になりましたが、そこでデフォルトの挙動が変わったらしいのでその辺らしいです。\n対策 たいていの言語で -no-pie を付けることで解決しています。 Position Independent Executableだっけ？\nアドホックにやる方法と恒久的に解決する方法とがあります。\nアドホックな方 簡単で、SML#で リンクする時 に -Xlinker -no-pie を付けてあげます。\n恒久的な方 SML#を自前でビルドします。そのとき configure時 に LDFLAGS=-no-pie を付けてあげます。\n余談 -no-pie はGCC 6以降で、それ以前は -nopie との噂をききましたがGCC 6系しか手元にないので真偽のほどは分かりません。\n","categories":["ML","SML","smlsharp","Advent Calendar","Advent Calendar 2016","ML Advent Calendar"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp","/categories/advent-calendar","/categories/advent-calendar-2016","/categories/ml-advent-calendar"],"date":"2016-11-30","title":"SML#をUbuntu 16.10で動かす","url":"https://KeenS.github.io/blog/2016/11/30/sml_woubuntu_16_10deugokasu/"},
  {"body":"# ClassとProtocol ---------------------- [Lisp Meet Up presented by Shibuya.lisp #46](https://lisp.connpass.com/event/45517/) Scheme回 === # About Me --------- ![κeenのアイコン](/images/icon.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * サイバーエージェントのエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === # Class ------- * ここでは単に値の集合を表わす * `new` のように新しいインスタンスを作る機能はつけない * ほとんど型と同じ機能 * 唯一の機能 `instance?` を持つ === ``` scheme (instance? 3 ) ; = #t (instance? \"foo\" ) ; = #f ``` === # Classの実装 ------------- * 事実上述語があればいい * [詳細](https://github.com/picrin-scheme/picrin/blob/master/contrib/50.class/piclib/picrin/class.scm) ``` scheme (define-class  (lambda (x) #t)) (define-class  list?) (define-class  procedure?) (define-class  number?) ``` === # Classの用途 ------------- * 述語だけで意味ある？ + プリミティブにのみあった述語をユーザが拡張出来る * その上に何かを構築出来る * protocolとか === # Protocol ----------- * Clojureのprotocol * 多重ディスパッチの機構 * ディスパッチするのにClassを使う === ```scheme (define-protocol (PLUS x y) (plus x y)) (define-instance (PLUS  ) (lambda (x y) (+ x y))) (define-instance (PLUS  ) (lambda (x y) (string-append (number-string x) y))) (define-instance (PLUS  ) (lambda (x y) (string-append x y))) ``` === ``` scheme (display (plus 1 2)) (newline) ; - 3 (display (plus 1 \"foo\")) (newline) ; - 1foo (display (plus \"bar\" \"foo\")) (newline) ; - barfoo (display (plus \"bar\" 1)) (newline) ; - \"error: method not found\" ``` === # ユーザ定義型とProtocol ------------------------ ``` scheme (define-record-type complex (make-complex real img) complex? (real complex-real) (img complex-img)) (define (complex-+ c1 c2) (make-complex (+ (complex-real c1) (complex-real c2)) (+ (complex-img c1) (complex-img c2)))) (define (complex-string c) (string-append (number-string (complex-real c)) \"+\" (number-string (complex-img c)) \"i\")) ``` === ```scheme (define-class  complex?) (define-instance (PLUS  ) complex-+) (display (complex-string (plus (make-complex 1 2) (make-complex 2 3)))) (newline) ; - 3+5i ``` === # Protocolの実装 ---------------- * メソッドの登録とか述語でディスパッチとか割と面倒 * [詳細](https://github.com/picrin-scheme/picrin/blob/master/contrib/80.protocol/piclib/picrin/protocol.scm) === # まとめ --------- * 「追加可能な型」は便利だよ * 型相当のものがあればダイナミックディスパッチ出来るよ * picrinに実装されてるよ `(picrin class)` `(picrin protocol)`   ","categories":["Lisp","Scheme","Lisp Meet Up"],"category_urls":["/categories/lisp","/categories/scheme","/categories/lisp-meet-up"],"date":"2016-11-28","title":"SchemeでClassとProtocol","url":"https://KeenS.github.io/slide/schemedeclasstoprotocol/"},
  {"body":"# Rustで非同期Thrift ---------------------- [歌舞伎座.tech#12「メッセージフォーマット/RPC勉強会」 - connpass](https://kbkz.connpass.com/event/40629/) === # About Me --------- ![κeenのアイコン](/images/icon.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * サイバーエージェントのエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます === * X RPCライブラリを使う話 * O RPCライブラリを作る話 === # RPC ----- * Remote Procedure Call * リモートで呼べる * 言語跨げる * シリアライズフォーマットが決まれば大体出来る * Thrift, protobuf/gRPC, avro... * 大抵バイナリ + JSONに比べて2倍くらい効率がいい === # Thrift -------- * Facebook発(現apache)RPCフレームワーク * IDLから複数の言語向けのコードを吐ける * 対応言語多い * 新しい言語はthriftレポジトリフォークして追加 === # Thrift vs gRPC ---------------- \\ | Thrift | gRPC ------------------------|:------:|:----: ベース | 自前 | HTTP/2 コード生成 | o | o プロトコルのアップデート | o | o 通信の多重化 | トランスポート次第 | o (HTTP/2) 認証 | x | o 例外 | ユーザ定義可能 | 事前定義のみ? 対応言語 | 多い | ほどほど その他 | union | timestamp, anyなど === # 何故Thrift? ------------- * 仕事で使ってたから * 仕事は「gRPCかthrift、まあthriftでいっしょ」で決まった === # RustとThrift -------------- いくつか実装がある === ## [sgnr/rust-thrift](https://github.com/sgnr/rust-thrift) === ![sgnr/rust-thrift is deprecated](/images/thrift/sgnr-rust-thrift.png) === ## [maximg/thrift](https://github.com/maximg/thrift) === ![maximg/thrift is deprecated](/images/thrift/maximg-thrift.png) === ## [terminalcloud/thrift](https://github.com/terminalcloud/thrift) === ![terminalcloud/thrift is deprecated](/images/thrift/terminalcloud.png) === # [thehydroimpulse/thrust](https://github.com/thehydroimpulse/thrust) --------------------------- * Thrift RPC in Rust (Async I/O) * 非同期!! * apache/thriftベースじゃない（フルスクラッチ） * コンパイラプラグインサポートとかも * 作りかけ + `Latest commit 0a37b77 on 11 Apr` → フォークすることに === # [Finagle](https://github.com/twitter/finagle) --------- * **Scalaの** RPCフレームワーク * [You Server as a Function](https://monkey.org/~marius/funsrv.pdf) * Nettyベース * サーバとクライアント両方サポート * Twitter製 * 良くも悪くもTwitterべったり === # Finagle Client -------- * クライアントが賢い * RPCではTCPベースのLBが使えない + クライアントはコネクション張りっぱなし * クライアントサイドロードバランシングが必要 * Finagleはそこまでカバー * 他にもエラーが起きたサーバ外したり色々 === # Tokio -------- * **Rustの** RPCフレームワーク * mioベース * Finagleを参考に開発 + **開発中** * tokio-core + コア部分 * tokio-proto + プロトコル実装のサポート + 絶賛API変更中 * tokio-service + サービス実装のサポート === # TokioとFinagle ----------------- \\ | Tokio | Finagle --------------|:-----------:|:-------: コア | [tokio-core](https://github.com/tokio-rs/tokio-core) | [finagle-core](https://github.com/twitter/finagle/tree/develop/finagle-core) Future | [future](https://github.com/alexcrichton/futures-rs) | [twitter util](https://github.com/twitter/util) 非同期エンジン | [mio](https://github.com/carllerche/mio) | [netty](http://netty.io/) === # [mio](https://github.com/carllerche/mio) ------ * 非同期イベントループライブラリ * イベントドリブン * ループ内ゼロアロケーション * `epoll` などの薄いラッパ * libuv, libevent, libev2などのRust版 * ソケットだけでなく *ファイルIO* 、インメモリチャネルとかも監視出来る === # [future](https://github.com/alexcrichton/futures-rs) -------------- * [Zero-cost futures in Rust · Aaron Turon](https://aturon.github.io/blog/2016/08/11/futures/) * ゼロコスト * 普通にFutureを使うとランタイムにステートマシンになる * 「将来実行される」という「状態」を第一級の値として表現する大事な手段 * お型付けは大変 + `map` したら `MapB` の型が返ったり * ストリーミング指向のAPIもある === # [tokio-core](https://github.com/tokio-rs/tokio-core) -------------- * 非同期IOのフレームワーク * Futureベース * フレームドIOとストリーミングIO * フレームワークというよりユーティリティ？ + mioとfutureを合わせて使う === # [tokio-proto](https://github.com/tokio-rs/tokio-proto) ------------- * 主にバイナリ列構造体の部分の面倒を見てくれる * API変更中… * バッファリングしてパースしやすくしてくれる * プロトコルの多重化やってくれる(後述) === # [tokio-service](https://github.com/tokio-rs/tokio-service) ----------------- * タスクサーバの面倒見てくれる * 主にロードバランシング === # [Service](https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html) ------------- ``` rust pub trait Service { type Request; type Response; type Error; type Future: Future; fn call(\u0026self, req: Self::Request) - Self::Future; } ``` === # Service ---------- * いわゆるハンドラ * インターフェースさえ満たせばいい + ミドルウェアもハンドラも同じ扱い === # [NewService](https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html) -------------- ```rust pub trait NewService { type Request; type Response; type Error; type Instance: Service; fn new_service(\u0026self) - Result; } implNewService for F where F: Fn() - Result, R: Service ``` === # NewService ------------ * いわゆるAbstractServiceFactory的な存在 * コア数に応じてサービスを作ってくれる * ただし`Service`を返す普通の関数も`NewService`になる * [example](https://github.com/tokio-rs/tokio-line/blob/master/examples/echo_client_server.rs#L21) === # tokio-thrift === # [tokio-thrift](https://github.com/KeenS/tokio-thrift) -------------- * [KeenS/tokio-thrift](https://github.com/KeenS/tokio-thrift) * この発表のために作った（作ってる） * tokioベースのrustのthriftサポート * thrustのフォーク * 基本ツール全て + コードジェネレータ + コンパイラプラグイン + ランタイムライブラリ === # プロトコルスタック ------------------- ユーザは実装に集中出来る仕組み ``` +------------------------------------------------+ | service | tokio-service + 生成コード + ユーザ | |------------------------------------------------| | protocol | tokio-proto + tokio-thrift | |------------------------------------------------| | transport | tokio-core | +------------------------------------------------+ ``` === # サンプルコード ---------------- * [これ](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/main.rs) === # ユーザビリティ --------------- * サーバ: ユーザはインターフェースに沿ったコードを書くだけ * クライアント: インターフェース通りに呼べる * 返り値はFuture * サーバ: 非同期実装と相性がいい * クライアント: 非同期通信をそのままエンコード === # 実装の話 === # Thriftのプロトコル ------------------- * 現状binary protocolのみ + fork元が実装してあった * compactとか需要ある？ * 因みにJSONはやめとけ === # 所有権とゼロコピー ------------------- * プロトコルのパースの部分の話 * Rustっぽい部分 * バッファの所有権をパース結果に渡すことでデータのコピーを避ける === # 所有権とゼロコピー ------------------- バッファをresultにパースして ``` buffer | +-+---------------+ | | ------------------- | | | | | ... | | |  ","categories":["Rust","Thrift","非同期"],"category_urls":["/categories/rust","/categories/thrift","/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f"],"date":"2016-11-26","title":"Rustで非同期Thriftしたい","url":"https://KeenS.github.io/slide/rustdehidoukithriftshitai/"},
  {"body":"κeenです。昨日はRustのLT会！ Rust入門者の集い - connpassに参加してきました。 そこで関連型に関する発表があったので感化されて私も一筆。\n馴れないと関連型はジェネリクスでいいじゃんと思えますが、両者は別の機能を提供するものです。 設計による使い分けではなくて実現したいことに応じた機能による使い分けをするので馴れてしまえば迷うことなくどちらを使うか判断出来ます。\nということで関連型のパターンをいくつか。 もちろん、根底にある関連型という機能は共通なのでほとんど同じようなことを言ってますが気持としてパターンを知っておくと便利です。\n型レベルの関数として 「関連」型なのである型に関連する型を表現します。ちょっと見方を変えると型から型への写像、つまり関数になります。 例えばこういうのです。\ntraitToUnsigned{type Counterpart;fn to_unsigned(self)-\u0026gt; Self::Counterpart;}implToUnsignedfori32{type Counterpart=u32;fn to_unsigned(self)-\u0026gt; Self::Counterpart{selfasu32}} i32 から u32 への関数になってそうなのが見えますかね？もちろん、 i64 から u64 などへの対応も作れます。 こういうのは例えば符号無し数にのみ演算が定義されている場合とかに便利ですね。\nfn write_bigendian_signed\u0026lt;I,U\u0026gt;(i: I)-\u0026gt; ()whereI: ToUnsigned\u0026lt;Counterpart=U\u0026gt;,U: ...,{} トレイト内で使う型を固定するため これが一番目にするやつじゃないでしょうか。\ntraitHandler{type Request;type Response;fn handle(req: Self::Request,res: Self::Response)-\u0026gt; io::Result\u0026lt;()\u0026gt;;}struct HTTPHandler;implHandlerforHTTPHandler{type Request=HTTPRequest;type Response=HTTPResponse;fn handle(req: Self::Request,res: Self::Response)-\u0026gt; io::Result\u0026lt;()\u0026gt;;} 固定というか特殊化というか、トレイト自体は汎用的に作られていて、それを実装する型が特定の処理に特化するパターンです。 ジェネリクスで受け取る訳にはいかなくて、実装すべき型をトレイトの中で定義してあげる必要があるのは分かると思います。\n関数の返り値を一般化するため これは現在のRust(rust-1.13.0)が impl Traitをサポートしていないために必要になるテクニックです。 関連型とトレイト境界を組み合わせて使います。\ntraitReverseIter{type Item;type Iter: Iterator\u0026lt;Item=Self::Item\u0026gt;;fn rev_iter(\u0026amp;self)-\u0026gt; Iter;} これの type Iter: Iterator\u0026lt;Item = Self::Item\u0026gt;; の方です。 返り値のIteratorを抽象化したいのですが、現在のRustではfn rev_iter(\u0026amp;self) -\u0026gt; Iterator\u0026lt;Item = Self::Item\u0026gt;;のような書き方が出来ないので仕方なく関連型を使ってあげる必要があります。\nちょっと踏み込んだ話をすると、関数の引数の多相性は∀の量化、返り値の多相は∃の量化です。そしてトレイトのジェネリクスも∀の量化で関連型が∃の量化なのでそういう対応がある訳です。\n最後に 結構理論的にも色々あるようなので調べてみると様々なブログポストが見付かると思います。\nぱぱっと思いついたパターンを3つ挙げました。もしかしたら他にもパターンがあるかもしれません。\nこれを知っておけばtokio-serviceのServiceみたいな関連型を多用するパターンでもひるまなくなります。\n参考 関連型とimpl Traitに関して  関連型 関連型が必要になる状況 | Rust by Example Abstract return types, aka impl Trait  応用  RustのHigher-Kinded type Trait | κeenのHappy Hacκing Blog  発展的な話題  Associated type constructors, part 1: basic concepts and introduction Associated type constructors, part 2: family traits Associated type constructors, part 3: What higher-kinded types might look like Associated type constructors, part 4: Unifying ATC and HKT Associated type constructors (a form of higher-kinded polymorphism). by withoutboats · Pull Request #1598 · rust-lang/rfcs ","categories":["Rust","型"],"category_urls":["/categories/rust","/categories/%e5%9e%8b"],"date":"2016-11-22","title":"Rustの関連型の使いどころ","url":"https://KeenS.github.io/blog/2016/11/22/rustnokanrenkatanotsukaidokoro/"},
  {"body":"# Rustの話とリソースの話 ---------------------- [RustのLT会！ Rust入門者の集い](https://rust.connpass.com/event/41467/) 2016-11-21 === # About Me --------- ![κeenのアイコン](/images/icon.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * 若者 * サイバーエージェントのエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます * [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)の翻訳 * [Join rust-jp on Slack!](http://rust-jp.herokuapp.com/) にもいます。 * [Rust その2 Advent Calendar 2016 - Qiita](http://qiita.com/advent-calendar/2016/rust-lang-2) === # 注意 ------ * たまにマニアックな話が出ますが気にせず無視して下さい * 「なんかRustすげー」って思ってもらえれば幸いです === # Rustとの出会い ---------------- * 元々Lisperだった * 他にはML, Ruby, JVM言語など === ![lis books](/images/rust-and-resource/lisp.jpg)=== 「Lisperは自分で処理系作って一人前」 === ![compiler books](/images/rust-and-resource/compiler.jpg) === # 苦悩 ------- * Cは低級すぎる * Javaは向いてない * C++は怖そう + 闇の軍団 + 縄文土器飛んできそう + あと **nullあるしメモリ破壊あるし** * MLは向いてるけどシステムプログラミングしづらい * ATS2, Golang, D... === # Rustと出会う ---------------- * 正直最初は色物言語と思ってた * 調べてみたら気に入った === # ゼロコスト抽象化 ---------------------------- ``` rust fn sum_pos(v: \u0026Vec) - i32 { v.iter().filter(|i| **i  0).sum() ``` === 高階関数が消えた…！？ ``` asm _ZN21higher_order_function7sum_pos17h2f9de4f69306ec0aE: .cfi_startproc movq\t(%rdi), %rcx movq\t16(%rdi), %rax leaq\t(%rcx,%rax,4), %rdx xorl\t%eax, %eax jmp\t.LBB0_1 .LBB0_3: addl\t%esi, %eax .p2align\t4, 0x90 .LBB0_1: cmpq\t%rcx, %rdx je\t.LBB0_4 movl\t(%rcx), %esi addq\t$4, %rcx testl\t%esi, %esi jle\t.LBB0_1 jmp\t.LBB0_3 .LBB0_4: retq ``` === # スタックとヒープ ------------------ * Rustは手で割り当てを変えられる * 「ヒープを使ったら負け」ゲームが出来る * ループの中でヒープアロケートしたくないよね === # マクロとコンパイラプラグイン ----------------------------- 例えば正規表現リテラルを作れるか、とか。 1. Common Lisp 2. 衛生的マクロ + 手続的マクロ Ok(expr.clone()), \u0026Expr::Sym(ref name) = { match env.find(\u0026name.to_owned()) { Ok(v) = Ok(v.clone()), Err(m) = { if name.deref() == \"t\" { Ok(ksym(\"t\")) } else { Err(m) } } } } \u0026Expr::Cons(ref car, ref cdr) = { .... ``` === # C インターフェース --------------------- * C FFI, C API共に1行 * 構造体なんかも互換 ``` rust extern { fn snappy_max_compressed_length(source_length: size_t) - size_t; } ``` ``` rust #[no_mangle] pub extern fn hello_rust() - *const u8 { \"Hello, world!\\0\".as_ptr() } ``` === # ランタイムなし --------------- * [RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/) * [Writing an OS in Rust](http://os.phil-opp.com/) * [Redox - Your Next(Gen) OS](http://www.redox-os.org/) === # 生ポインタ ------------ * Cとのやりとりで大事 * あるいはパフォーマンスチューニングに ``` rust pub struct Vec { ptr: *mut T, cap: usize, len: usize, } ``` ``` rust unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) - Vec ``` === # エラー処理 ------------ * 例外じゃない * [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html) * `?` (元 `try!`)も便利 * Erro as a data * 巻き戻し例外って扱い難しいよね + 値継続と例外継続の使い分けつらい === # リソースの話（本題） === # リソースの重要性 ------------------- * プログラムはIOの塊、すなわりリソースの塊 * 従来は手動で管理するかGCで管理するかしていた * RustはGCを使わず自動で管理する * 所有権の概念が「ただの自動」以上に便利 === # メモリ管理 ------------ * Cでいう`free`を自動で挟んでくれる * 基本 === # Vecとslice ------------- * sliceを`Vec`のviewとして使える + zero copy + 例えばJavaとかだと出来ない * zero copy parserとかも書ける === # `File` 、 `Lock` ------------------ * `Drop`があるので自動 * ところでGCがあるのに手動で管理する言語があるらしいですね + 例えばRubyの`File.open(..) do ... end` も半手動 + GCで処理すべきなのに手で`do ... end`を書いてる === # Rust ------- ``` rust let file = File::open(\"text.txs\").unwrap(); let mut br = BufReader::new(file); ... ``` === # Java ------- ※try-with-resourceを使うともっと簡単に書けます。極端な比較のためにこう書いてます ``` java BufferedReader br = null; try { br = new BufferedReader(new FileReader(\"test.txt\")); ... } catch (FileNotFoundException e) { e.printStackTrace(); } finally { if (br != null) try { br.close(); } catch (IOException e) { e.printStackTrace(); } } ``` === # Use after close ------------------ * プログラミングエラーの一種 * あらゆるリソースで起きうる * GCのある言語ではメモリでのエラー **のみ** 防げる * 他のリソースだとダメ * Rustは **全ての** リソースで防げる === # Ruby ------ ``` ruby file = nil File.open(\"file.rb\") do |f| file = f end puts file.read ``` ``` #file.rb:6:in `read': closed stream (IOError) from file.rb:6:in `' ``` === # Rust ------- * 所有権のある限り勝手に`close`されない ``` rust let mut file = None; { let f = File::open(\"file.rs\").unwrap(); file = Some(f); } let mut s = String::new(); file.unwrap().read_to_string(\u0026mut s).unwrap(); println!(\"{}\", s); ``` === # ラッパーオブジェクト -------------------- * 所有権便利って話 === # Scala ------ ``` scala val kc = new KafkaProducer(...) val sk = new SimpleKafkaClient(kc) kc.close //  ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2016-11-20","title":"Rustの話とリソースの話","url":"https://KeenS.github.io/slide/rustnohanashitoriso_sunohanashi/"},
  {"body":"κeenです。ふとした気紛れでRustの型レベルLispっぽいの作りました。\n実装自体は去年Scalaで作た時とほぼ同じ。 ただしRustでコンパイル時に文字列を処理しようとするとコンパイラプラグインが必要になるので今回はあきらめて素のRustの式のまま。\nこんな感じです。\nprintln!(\u0026#34;{}\u0026#34;,eval!(List3\u0026lt;Add,_2,_3\u0026gt;)); Lisp…？感ありますがLispと言い張ります。\n少しだけ工夫した点はシンボルをアルファベットのListにすることで任意の文字列を表現出来るようにした点、関数をFun 、 Fun2 といったトレイトで抽象化することでユーザも関数を定義出来るようにした点です。\n例えばフィボナッチ数列は\npubtype Fib=Symbol\u0026lt;Sym3\u0026lt;F,I,B\u0026gt;\u0026gt;;implFun1\u0026lt;_0\u0026gt;forFib{type Out=_1;}implFun1\u0026lt;_1\u0026gt;forFib{type Out=_1;}impl\u0026lt;T1N: Num,N1_O: Num,N2_O: Num,NO: Num\u0026gt;Fun1\u0026lt;Number\u0026lt;Succ\u0026lt;Succ\u0026lt;T1N\u0026gt;\u0026gt;\u0026gt;\u0026gt;forFibwhereFib: Fun1\u0026lt;Number\u0026lt;Succ\u0026lt;T1N\u0026gt;\u0026gt;,Out=Number\u0026lt;N1_O\u0026gt;\u0026gt;,Fib: Fun1\u0026lt;Number\u0026lt;T1N\u0026gt;,Out=Number\u0026lt;N2_O\u0026gt;\u0026gt;,Add: Fun2\u0026lt;Number\u0026lt;N1_O\u0026gt;,Number\u0026lt;N2_O\u0026gt;,Out=Number\u0026lt;NO\u0026gt;\u0026gt;{type Out=Number\u0026lt;NO\u0026gt;;} と定義出来ます。\nただし、Rustの型検査が許す再帰深度がかなり小さいため、List2\u0026lt;Fib, _6\u0026gt;で音を上げます。\n Compiling rustlisp v0.1.0 (file:///home/kim/Rust/rustlisp) error[E0275]: overflow evaluating the requirement `_: std::marker::Sized` --\u0026gt; \u0026lt;rustlisp macros\u0026gt;:1:20 | 1 | ( $ t : ty ) =\u0026gt; { \u0026lt;\u0026lt; $ t as Eval \u0026gt; :: Out as Expr \u0026gt; :: to_string ( ) } | ^^^^^^^^^^^^^^^^^^^^^^ src/main.rs:18:20: 18:41 note: in this expansion of eval! (defined in \u0026lt;rustlisp macros\u0026gt;) \u0026lt;std macros\u0026gt;:2:27: 2:58 note: in this expansion of format_args! \u0026lt;std macros\u0026gt;:3:1: 3:54 note: in this expansion of print! (defined in \u0026lt;std macros\u0026gt;) src/main.rs:18:5: 18:43 note: in this expansion of println! (defined in \u0026lt;std macros\u0026gt;) | = note: consider adding a `#![recursion_limit=\u0026#34;128\u0026#34;]` attribute to your crate = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun2\u0026lt;rustlisp::num::Number\u0026lt;_\u0026gt;, rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::A, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::D, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::fun::Fun1\u0026lt;rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;` for `rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::F, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::I, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::B, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;` = note: required because of the requirements on the impl of `rustlisp::eval::Eval` for `rustlisp::cons::ConsCell\u0026lt;rustlisp::symbol::Symbol\u0026lt;rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::F, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::I, rustlisp::symbol::SymCons\u0026lt;rustlisp::symbol::B, rustlisp::symbol::Eos\u0026gt;\u0026gt;\u0026gt;\u0026gt;, rustlisp::cons::ConsCell\u0026lt;rustlisp::num::Number\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Succ\u0026lt;rustlisp::num::Zero\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;, rustlisp::cons::Nil\u0026gt;\u0026gt;` error: aborting due to previous error error: Could not compile `rustlisp`. To learn more, run the command again with --verbose. スタックを作ってどうこう、とかも考えたのですが上手くいきませんでした。悲しい。\nということで小ネタでした。\n","categories":["Rust","Lisp"],"category_urls":["/categories/rust","/categories/lisp"],"date":"2016-11-06","title":"Rustの型レベルLispっぽいの作った","url":"https://KeenS.github.io/blog/2016/11/06/rustnokatareberulispppoinotsukutta/"},
  {"body":"# Scala 2.12.0変更点 ---------------------- サイバーエージェント ScalaMeetUp === # About Me --------- ![κeenのアイコン](/images/icon.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * AI Studio Dev Group * Lisp, ML, Rust, Shell Scriptあたりを書きます === # サマリー ---------- 全部[公式ページ](http://www.scala-lang.org/news/2.12.0)に詳細あるよ * Java8向けの互換性向上したよ + トレイトがinterfaceに + 無名関数がlambdaに + SAMとScalaの関数が統合 * コンパイラが少し賢くなったよ + いくつかでinvokedynamicを使うように + 中間状態をやめた + 最適化をするように * ライブラリ改善した + EitherがRight Biasedに + Futureが強化 * 非互換いくつか === # トレイトがinterfaceに ----------------------- ``` scala trait Foo { def foo(): String = \"foo\" def bar(): String } ``` === # トレイトがinterfaceに ----------------------- ``` $ scalac-2.11 Trait.scala $ ls Foo$class.class Foo.class Trait.scala $ javap Foo Compiled from \"Trait.scala\" public interface Foo { public abstract java.lang.String foo(); public abstract java.lang.String bar(); } $ javap 'Foo$class' Compiled from \"Trait.scala\" public abstract class Foo$class { public static java.lang.String foo(Foo); public static void $init$(Foo); } ``` === # トレイトがinterfaceに ----------------------- ``` $ scalac-2.12 Trait.scala $ ls Foo.class Trait.scala $ javap Foo Compiled from \"Trait.scala\" public interface Foo { public static java.lang.String foo$(Foo); public java.lang.String foo(); public abstract java.lang.String bar(); public static void $init$(Foo); ``` === # 無名関数がlambdaに ----------------------- ``` class Foo { val f = () = \"string\" } ``` === # 無名関数がlambdaに ----------------------- ``` $ scalac-2.11 Trait.scala $ ls Foo$$anonfun$1.class Foo.class Trait.scala $ javap Foo Compiled from \"Trait.scala\" public class Foo { public scala.Function0 f(); public Foo(); } $ javap 'Foo$$anonfun$1 Compiled from \"Trait.scala\" public final class Foo$$anonfun$1 extends scala.runtime.AbstractFunction0 implements scala.Serializable { public static final long serialVersionUID; public final java.lang.String apply(); public final java.lang.Object apply(); public Foo$$anonfun$1(Foo); } ``` === # 無名関数がlambdaに ----------------------- ``` $ scalac-2.12 Trait.scala $ ls Foo.class Trait.scala $ javap -p Foo Compiled from \"Trait.scala\" public class Foo { private final scala.Function0 f; public scala.Function0 f(); public static final java.lang.String $anonfun$f$1(); public Foo(); private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda); $ javap -c -p Foo Compiled from \"Trait.scala\" public class Foo { private final scala.Function0 f; public scala.Function0 f(); Code: 0: aload_0 1: getfield #19 // Field f:Lscala/Function0; 4: areturn public static final java.lang.String $anonfun$f$1(); Code: 0: ldc #25 // String string 2: areturn public Foo(); Code: 0: aload_0 1: invokespecial #29 // Method java/lang/Object.\"\":()V 4: aload_0 5: invokedynamic #49, 0 // InvokeDynamic #0:apply:()Lscala/Function0; 10: putfield #19 // Field f:Lscala/Function0; 13: return private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda); Code: 0: aload_0 1: invokedynamic #61, 0 // InvokeDynamic #1:lambdaDeserialize:(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object; 6: areturn } ``` === # SAMとScalaの関数が統合 ----------------------- 関数をSingle Abstract Methodに出来る ``` scala val runRunnable: Runnable = () = println(\"Run!\") runRunnable: Runnable = $$Lambda$1073/754978432@7cf283e1 scala runRunnable.run() Run! ``` JavaでLambdaが期待される箇所にScalaの無名関数を書ける === # SAMとScalaの関数が統合 ----------------------- 逆に、JavaのLambdaでScalaの関数を作れる ``` public class A { scala.Function1f = s - s.trim(); } ``` === # 最適化 -------- とりあえずDead Code Elimination ``` class Foo { def add1(i: Int) = { val unused = 1 + i 1 + i } } ``` === # 最適化 -------- ``` $ scalac Trait.java $ javap -c Foo ... public int add1(int); Code: 0: iconst_1 1: iload_1 2: iadd 3: istore_2 4: iconst_1 5: iload_1 6: iadd 7: ireturn ... } ``` === # 最適化 -------- ``` $ scalac -opt:l:method Trait.java $ javap -c Foo ... public int add1(int); Code: 0: iconst_1 1: iload_1 2: iadd 3: ireturn ... ``` === # 非互換 -------- * Object initialization locks and lambdas + 無名関数が元のクラスのメソッドになったので変にデッドロックするかも * Lambdas capturing outer instances + 無名関数が元のクラスのメソッドになったのでスコープが少し変わる + シリアライズに影響出るかも * SAM conversion precedes implicits + SAM conversionとimplicit comversionだとSAMが優先される === # 非互換 -------- * SAM conversion in overloading resolution + なんか型が面倒になった * Inferred types for fields + なんかよく分かんなかった * Changed syntax trees (affects macro and compiler plugin authors) + 変わったらしい   ","categories":["Scala","ScalaMeetUp","社内"],"category_urls":["/categories/scala","/categories/scalameetup","/categories/%e7%a4%be%e5%86%85"],"date":"2016-11-04","title":"Scala 2.12.0変更点","url":"https://KeenS.github.io/slide/scala_2_12_0henkouten/"},
  {"body":"κeenです。普段はネイティブのUbuntuを使ってますが会社では使えないのでVMwareにUbuntuを入れて使っています。 今日そのUbuntuを16.04から16.10にアップグレードしたら起動しなくなったので対策メモ。\n現象は、Ubuntuを起動しようとするとゲストOSによってCPUがオフにされた旨の通知が来てフリーズします。 このリリースノート（VMware Fusion 8.5.1 Release Notes）を見れば分かりますが、Linux Kernel 4.7以上を使うと発生するバグのようです。\n Known Issues\nVirtual machines running Linux kernel version 4.7 or above may crash or hang on hosts with Intel CPUs Virtual Machines running Linux kernel version 4.7 or above may crash during installation or during power-on with a crash in the intel_powerclamp driver. This issue has been reported with Ubuntu 16.10, but it is a generic Linux kernel issue. Workaround: VMware is working with the OS vendors to have them fix their respective kernels. Until a fix is available, you can blacklist the intel_powerclamp driver so that the buggy code doesn\u0026#39;t get loaded. To blacklist the driver: Add the kernel command-line option modprobe.blacklist=intel_powerclamp to the guest OS\u0026#39;s default grub configuration or add it directly at the grub menu during boot. どうやらIntel CPUのホストだと特定のカーネルモジュールが誤動作してCPUをoffってしまうっぽい？OSベンダと協力して直していくと言っているのでVMwareのアップデートでは直らなそう。OSのアップデートはそもそも起動しないので出来ない、というかなりキツい状況です。 幸いにもワークアラウンドがあるのでそれを使って起動、修正します。\nUbuntuの起動 誤動作するカーネルモジュールをロードしないようにしたら起動するっぽいです。\n今OSがハングしている状態ならとりあえず殺して、 ESC キー(多分。もしかしたら Shift かも)を押しながらUbuntuを起動します。そうするとgrub menuの画面に遷移する筈です。\ngrub menuで（恐らく1番上にある）使用中のカーネルに選択肢を合わせた状態でeを押すと起動シーケンスをいじれるようになります。\nEmacsっぽく操作出来る画面が出てくるので\n\tlinux\t/vmlinuz-4.4.0-45-generic root=/dev/mapper/ubuntu--vg-root ro quiet splash $vt_handoff のようにLinuxカーネルを起動してるっぽい行に\n\tlinux\t/vmlinuz-4.4.0-45-generic root=/dev/mapper/ubuntu--vg-root ro quiet splash $vt_handoff modprobe.blacklist=intel_powerclamp と modprobe.blacklist=intel_powerclamp を追加してあげれば起動します。\n起動オプションの変更 とりあえず今のでワンショットで起動出来るようになったので起動オプションの設定を変更して次回以降も起動出来るようにしておきます。\n/etc/default/grub をいじれば良いようです。\nGRUB_CMDLINE_LINUX=\u0026#34;\u0026#34; の行をこれまた\nGRUB_CMDLINE_LINUX=\u0026#34;modprobe.blacklist=intel_powerclamp\u0026#34; と modprobe.blacklist=intel_powerclamp を追加するように書き換えてあげて、\n$ sudo update-grub2 でgrubに変更を反映してあげればOKです。\nその他 Ubuntu 16.10を1日使ってみましたが特に不自由なく使えています。\n","categories":["Linux","Ubuntu","VMware"],"category_urls":["/categories/linux","/categories/ubuntu","/categories/vmware"],"date":"2016-10-31","title":"VMwareのUbuntuを16.10にしたら起動しなくなった","url":"https://KeenS.github.io/blog/2016/10/31/vmwarenoubuntuwo16_10nishitarakidoushinakunatta/"},
  {"body":"κeenです。Rustのクロージャ、3種類もあって複雑ですよね。 こういう複雑なものはRustの気持になって考えれば理解出来たりします。ということで手でクロージャを作って理解してみましょう。\n尚、これはRustの1.12.0-stableと1.14.0-nightly (6e8f92f11 2016-10-07)で実験しています。\n用語  関数 - 関数 無名関数 - 名前のついていない関数 自由変数 - そのスコープの中で束縛されていない変数 クロージャ - 関数に、自由変数の値(環境)もくっつけてそれだけで閉じるようにしたもの  クロージャについては関数が閉じ込める環境だけを指してクロージャとする人もいますが、ここでは関数本体と環境を合わせてクロージャとします。\nよく、無名関数とクロージャ(関数閉包)を一緒くたにすることがありますが明確に区別しましょう。まあ、大抵の無名関数はクロージャになりますが、動的スコープの言語みたいにそうならないケースもあります。\n余談ですが「ラムダ式」は言語がよく無名関数に付ける名前です。「関数」も言語によって「手続き」だったり「メソッド」だったりしますね。\nFnOnce FnMut Fn さて、「作って理解する」なので例を出します。なんかよく分からないけど0から9の値に1を足して印字するプログラムです。\nfn main(){letx=1;foriin0..10{// 無名関数を作る letcls=|arg|{i+arg};println!(\u0026#34;{}\u0026#34;,cls(x));}} 無名関数を作って cls という変数に束縛しています。 cls は自由変数 i を含みますので、 cls のクロージャを取ると 「cls の定義 + i の定義」になります。\nでは i という変数を保持したオブジェクトを作りましょう。\nstruct Closure{i: isize,}fn main(){letx=1;foriin0..10{// クロージャを作る letcls=Closure{i: i};// もちろん、Closureは関数でないので呼び出せない // println!(\u0026#34;{}\u0026#34;, cls(x)); }} さて、このままだと cls は呼び出せません。しかし + なんかのオーバーロードを許しているRustはなんと関数呼び出し構文 name(arg, ...) もオーバーロード出来ます。実装すべきトレイトは std::ops::{FnOnce, FnMut, Fn} です。これがクロージャ3種です。\nこれらは継承関係にあって、上から順に FnOnce FnMut Fn です。\npubtraitFnOnce\u0026lt;Args\u0026gt;{type Output;extern\u0026#34;rust-call\u0026#34;fn call_once(self,args: Args)-\u0026gt; Self::Output;}pubtraitFnMut\u0026lt;Args\u0026gt;: FnOnce\u0026lt;Args\u0026gt;{extern\u0026#34;rust-call\u0026#34;fn call_mut(\u0026amp;mutself,args: Args)-\u0026gt; Self::Output;}pubtraitFn\u0026lt;Args\u0026gt;: FnMut\u0026lt;Args\u0026gt;{extern\u0026#34;rust-call\u0026#34;fn call(\u0026amp;self,args: Args)-\u0026gt; Self::Output;} これらの違いは self をムーブして受け取るか \u0026amp;mut で受けるか \u0026amp; で受けるかです。\nFnOnce とりあえず先程の Closure にこれを実装してみましょう。ちょいとunstableな機能なようなので feature を使って、nightlyでコンパイルするようにしてみます。\n#![feature(unboxed_closures)]#![feature(fn_traits)]usestd::ops::{FnOnce,FnMut,Fn};// 再掲 struct Closure{i: isize,}implFnOnce\u0026lt;(isize,)\u0026gt;forClosure{type Output=isize;extern\u0026#34;rust-call\u0026#34;fn call_once(self,(arg,): (isize,))-\u0026gt; Self::Output{self.i+arg}} これで呼び出しが出来る筈です。\nfn main(){letx=1;foriin0..10{// 無名関数を作る letcls=Closure{i: i};// 呼出せるようになる println!(\u0026#34;{}\u0026#34;,cls(x));}} 勿論、これは以下のように明示的にメソッドを呼んでも同じです。\nfn main(){letx=1;foriin0..10{// クロージャを作る letcls=Closure{i: i};// メソッドで呼ぶ println!(\u0026#34;{}\u0026#34;,cls.call_once((x,)));}} FnMut FnMut Fn FnOnce で出来るんならなんで FnMut と FnMut Fn が存在するかというと、クロージャが閉じ込めた環境の所有権の問題ですね。\n2018-02-26: 上記2打ち消し線部分修正しました\n例えば以下のコードを手で実装してみます。\nfn main(){letx=1;// ループの外でクロージャを作る letcls=|arg|{x+arg};foriin0..10{// 複数回クロージャを呼ぶ println!(\u0026#34;{}\u0026#34;,cls(i));}} 先程と同じ Closure ではコンパイル出来ません（統一感のために Closure のメンバ名を変えました）。\n#![feature(unboxed_closures)]#![feature(fn_traits)]usestd::ops::{FnOnce,FnMut,Fn};struct Closure{x: isize,}implFnOnce\u0026lt;(isize,)\u0026gt;forClosure{// ...略 }fn main(){letx=1;// ループの外でクロージャを作る letcls=Closure{x: x};foriin0..10{// 複数回クロージャを呼ぶ println!(\u0026#34;{}\u0026#34;,cls(i));}}error[E0382]: use of moved value: `cls` --\u0026gt; closure.rs:45:28 | 45 | println!(\u0026#34;{}\u0026#34;, cls(i)); | ^^^ value moved here in previous iteration of loop | = note: move occurs because `cls` has type `Closure`, which does not implement the `Copy` trait error: aborting due to previous error 1回目のループでは問題ないのですが call_once(self, (arg, ): (isize,)) の呼び出しでムーブしてしまうので2回目以降は呼べません。ということで1つ下のトレイト、 FnMut も実装してみましょう。\n// ...略 implFnMut\u0026lt;(isize,)\u0026gt;forClosure{extern\u0026#34;rust-call\u0026#34;fn call_mut(\u0026amp;mutself,(arg,): (isize,))-\u0026gt; Self::Output{self.x+arg}}fn main(){letx=1;letcls=Closure{x: x};foriin0..10{println!(\u0026#34;{}\u0026#34;,cls(i));}} 実はこれでも怒られます。\nerror: cannot borrow immutable local variable `cls` as mutable --\u0026gt; closure.rs:45:28 | 43 | let cls = Closure {x: x}; | --- use `mut cls` here to make mutable 44 | for i in 0..10 { 45 | println!(\u0026#34;{}\u0026#34;, cls(i)); | ^^^ cannot borrow mutably error: aborting due to previous error 何故なら mut を要求しているから。正確にはこうです。\n// ...略 fn main(){letx=1;// `mut` を付ける letmutcls=Closure{x: x};foriin0..10{println!(\u0026#34;{}\u0026#34;,cls(i));}} これで通ります。しかしまあ、何か書き換えてる訳でもないのに mut が付いているのは嫌ですね。mut を要求しないように定義してあげようと思ったら Fn が必要になります。\n// ...略 implFn\u0026lt;(isize,)\u0026gt;forClosure{extern\u0026#34;rust-call\u0026#34;fn call(\u0026amp;self,(arg,): (isize,))-\u0026gt; Self::Output{self.x+arg}}fn main(){letx=1;letcls=Closure{x: x};foriin0..10{println!(\u0026#34;{}\u0026#34;,cls(i));}} これで通ります。\n整理  クロージャとは関数とその環境のセットだよ 環境にも所有権はあるよ Rustは所有権でクロージャの呼び出しを使い分けるよ  構文 じゃあ、 FnOnce FnMut Fn に対応するRustの構文を探っていきます。\nFn 先程 Fn まで実装しないとコンパイルが通らなかった\nfn main(){letx=1;letcls=|arg|{x+arg};foriin0..10{println!(\u0026#34;{}\u0026#34;,cls(i));}} は ||{} でコンパイルが通っているので ||{} は Fn を作るようです。\nFnMut じゃあ、 call_mut を要求しそうにちょっと変えてみます。\nfn main(){letmutx=1;letcls=|arg|{x+=arg};foriin0..10{cls(i);}println!(\u0026#34;{}\u0026#34;,x);} はい、予想通りエラーが出ます。\nerror: cannot borrow immutable local variable `cls` as mutable --\u0026gt; closure.rs:37:13 | 35 | let cls = |arg|{ x += arg }; | --- use `mut cls` here to make mutable 36 | for i in 0..10 { 37 | cls(i); | ^^^ cannot borrow mutably error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable --\u0026gt; closure.rs:39:24 | 35 | let cls = |arg|{ x += arg }; | ----- - previous borrow occurs due to use of `x` in closure | | | mutable borrow occurs here ... 39 | println!(\u0026#34;{}\u0026#34;, x); | ^ immutable borrow occurs here 40 | } | - mutable borrow ends here error: aborting due to 2 previous errors 先程の FnMut の例のように cls に mut を付けてみます。\nfn main(){letmutx=1;letmutcls=|arg|{x+=arg};foriin0..10{cls(i);}println!(\u0026#34;{}\u0026#34;,x);} 実は、これでもエラーです。\nerror[E0502]: cannotborrow`x`asimmutablebecauseitisalsoborrowedasmutable--\u0026gt; closure.rs:39:24|35|letmutcls=|arg|{x+=arg};|------previousborrowoccursduetouseof`x`inclosure|||mutableborrowoccurshere...39|println!(\u0026#34;{}\u0026#34;,x);|^immutableborrowoccurshere40|}|-mutableborrowendshereerror: abortingduetopreviouserror 何故なら cls が x を捕捉し続けているから。これは cls のライフタイムを println! の前で終わらせてあげると解決します。\nfn main(){letmutx=1;{// `{}` でスコープを作ることでライフタイムをコントロールする letmutcls=|arg|{x+=arg};foriin0..10{cls(i);}}println!(\u0026#34;{}\u0026#34;,x);} FnMut は変数を mut にする無名関数と同じなようです。\nFnOnce じゃあ、 FnOnce は？ std::mem::drop を使って所有権を無理矢理奪うクロージャを作ってみましょう。\nusestd::mem::drop;fn main(){letx=String::new();letcls=||{drop(x)};cls();} はい、実はこれでOKです。冷静に考えたら FnOnce を継承している Fn を ||{} で作れた時点で問題ありませんでしたね。\n落穂拾い move クロージャ じゃあ、Rustが良い感じに使い分けてくれるなら move クロージャって何のためにあるの？と思いますが、これは環境を捕捉する際に Copy なんかが起こらないようにするためのものです。\n move しない例\nletmutnum=5;{letmutadd_num=|x: i32|num+=x;add_num(5);}assert_eq!(10,num); move する例\nletmutnum=5;{letmutadd_num=move|x: i32|num+=x;add_num(5);}assert_eq!(5,num);  move は環境 へ 所有権を移すかどうか、 FnOnce などは環境 から 所有権を移すかどうかです。\n関数ポインタ クロージャを持たない関数は、 fn(i32) -\u0026gt; i32 のような型を持ちます。これは空の環境を持つクロージャと同じですね。空の環境に所有権も何もないのでプリミティブの fn は FnOnce FnMut Fn のいずれとしても振舞います。\n参考 ここまで書いて普通にドキュメントに詳しく載っているのに気付きました（汗\n 関数 クロージャ ","categories":["Rust","言語実装"],"category_urls":["/categories/rust","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2016-10-10","title":"Rustのクロージャ3種を作って理解する","url":"https://KeenS.github.io/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru/"},
  {"body":"κeenです。ML Workshop 2016でなんかSMLで型クラスする発表があったらしいので追ってみます。\nimplicit parameterをexplicitに渡すのではなく、モジュールとファンクタを使った実装です。\n前置き Haskell風の中置演算子を使うので\ninfix 4 \u0026lt;$\u0026gt; \u0026lt;$ $\u0026gt; \u0026lt;*\u0026gt; \u0026lt;* *\u0026gt; infix 1 \u0026gt;\u0026gt;= \u0026gt;\u0026gt; を予め宣言しておきます。\n最初の試み さて、(MLの機能の方ではない)functorを考えましょうか。functorには fmap が要求され、\u0026lt;$\u0026gt; なんかが実装されます。それを素直に表したらこうなるでしょうか。\nsignature FUNCTOR_MIN = sig type \u0026#39;a t val fmap: (\u0026#39;a -\u0026gt; \u0026#39;b) -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;b t end signature FUNCTOR = sig include FUNCTOR_MIN val \u0026lt;$\u0026gt; : (\u0026#39;a -\u0026gt; \u0026#39;b) * \u0026#39;a t -\u0026gt; \u0026#39;b t val \u0026lt;$ : \u0026#39;a * \u0026#39;b t -\u0026gt; \u0026#39;a t val $\u0026gt; : \u0026#39;a t * \u0026#39;b -\u0026gt; \u0026#39;b t val void: \u0026#39;a t -\u0026gt; unit t end functor MkFunctor(Fun: FUNCTOR_MIN): FUNCTOR = struct open Fun fun f \u0026lt;$\u0026gt; fa = fmap f fa fun a \u0026lt;$ fb = (fn _ =\u0026gt; a) \u0026lt;$\u0026gt; fb fun fa $\u0026gt; b = b \u0026lt;$ fa fun void fa = () \u0026lt;$ fa end さて、さらにそのサブクラスのapplicativeも作ります。 include を使うことで FUNCTOR を継承することを表します。\nsignature APPLICATIVE_MIN = sig include FUNCTOR val pure: \u0026#39;a -\u0026gt; \u0026#39;a t val ap : (\u0026#39;a -\u0026gt; \u0026#39;b) t -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;b t end signature APPLICATIVE = sig include APPLICATIVE_MIN val \u0026lt;*\u0026gt; : (\u0026#39;a -\u0026gt; \u0026#39;b) t * \u0026#39;a t -\u0026gt; \u0026#39;b t val *\u0026gt; : \u0026#39;a t * \u0026#39;b t -\u0026gt; \u0026#39;b t val \u0026lt;* : \u0026#39;a t * \u0026#39;b t -\u0026gt; \u0026#39;a t end functor MkApplicative(App: APPLICATIVE_MIN): APPLICATIVE = struct open App fun af \u0026lt;*\u0026gt; aa = ap af aa fun aa *\u0026gt; ab = pure (fn _ =\u0026gt; fn x =\u0026gt; x) \u0026lt;*\u0026gt; aa \u0026lt;*\u0026gt; ab fun aa \u0026lt;* ab = pure (fn x =\u0026gt; fn _ =\u0026gt; x) \u0026lt;*\u0026gt; aa \u0026lt;*\u0026gt; ab end さらにmonadも作りましょうか。\nsignature MONAD_MIN = sig include APPLICATIVE val bind : \u0026#39;a t -\u0026gt; (\u0026#39;a -\u0026gt; \u0026#39;b t) -\u0026gt; \u0026#39;b t end signature MONAD = sig include MONAD_MIN val return: \u0026#39;a -\u0026gt; \u0026#39;a t val \u0026gt;\u0026gt;= : \u0026#39;a t * (\u0026#39;a -\u0026gt; \u0026#39;b t) -\u0026gt; \u0026#39;b t val \u0026gt;\u0026gt; : \u0026#39;a t * \u0026#39;b t -\u0026gt; \u0026#39;b t end functor MkMonad(M: MONAD_MIN): MONAD = struct open M val return = pure fun ma \u0026gt;\u0026gt;= f = bind ma f fun ma \u0026gt;\u0026gt; mb = ma \u0026gt;\u0026gt;= (fn _ =\u0026gt; mb) end ちょっと使ってみましょう。1つ1つインスタンスを作ってあげます。\nstructure OptionFunc = MkFunctor( struct type \u0026#39;a t = \u0026#39;a option fun fmap f = Option.map f end) structure OptionApp = MkApplicative( struct open OptionFunc fun pure x = SOME(x) fun ap af aa = case (af, aa) of (SOME(f), SOME(a)) =\u0026gt; SOME(f a) | _ =\u0026gt; NONE end) structure OptionMonad = MkMonad( struct open OptionApp fun bind ma f = case ma of SOME(a) =\u0026gt; f a | NONE =\u0026gt; NONE end) local open OptionMonad in fun add x y = x + y fun println s = print (s ^ \u0026#34;\\n\u0026#34;) val ret1 = add \u0026lt;$\u0026gt; SOME(1) \u0026lt;*\u0026gt; SOME(2) val ret2 = SOME(1) \u0026gt;\u0026gt;= (fn x =\u0026gt; SOME(2) \u0026gt;\u0026gt;= (fn y =\u0026gt; return (x + y))) val () = Option.app (println o Int.toString) ret1 (* =\u0026gt; 3 *) val () = Option.app (println o Int.toString) ret2 (* =\u0026gt; 3 *) end 動きました。\nさて、一見これで良さそうですがML Workshopでの発表では問題点を2点指摘しています。\n Monadのインスタンスが欲しいだけなのにFunctorまで遡って作らないといけない ダイアモンド継承が起きた時に共通の親クラスの実装の一貫性を保障出来ない  とのことです。私はこの問題点自体割と疑問なのですがまあ、問題らしいです。\n解決案 継承のやり方をちょいと変えます。Functor までは先程と同じなのですが、Applicativeは APPLICATIVE_MINにFUNCTORをincludeしません。また、衝突の問題から型が applicativeになります（同じと言っちゃいましたがFunctorの方も functor_ になってます）。\nsignature APPLICATIVE_MIN = sig type \u0026#39;a applicative val pure: \u0026#39;a -\u0026gt; \u0026#39;a applicative val ap : (\u0026#39;a -\u0026gt; \u0026#39;b) applicative -\u0026gt; \u0026#39;a applicative -\u0026gt; \u0026#39;b applicative end そしてAPPLICATIVEの方でincludeします。ここで sharing 制約を付けます。\nsignature APPLICATIVE = sig include FUNCTOR APPLICATIVE_MIN sharing type functor_ = applicative val \u0026lt;*\u0026gt; : (\u0026#39;a -\u0026gt; \u0026#39;b) applicative * \u0026#39;a applicative -\u0026gt; \u0026#39;b applicative val *\u0026gt; : \u0026#39;a applicative * \u0026#39;b applicative -\u0026gt; \u0026#39;b applicative val \u0026lt;* : \u0026#39;a applicative * \u0026#39;b applicative -\u0026gt; \u0026#39;a applicative end で、 APPLICATIVE_MIN から FUNCTOR_MIN を生成するファンクタを作ります。\nfunctor ApplicativeMinToFunctorMin(A: APPLICATIVE_MIN): FUNCTOR_MIN = struct open A type \u0026#39;a functor_ = \u0026#39;a applicative fun fmap f = ap (pure f) end applicativeからfunctor????感ありますがとりあえず進みます。\nで、 MkApplicative は一旦内部で Functor を作ってそれを open します。\nfunctor MkApplicative(App: APPLICATIVE_MIN): APPLICATIVE = struct type \u0026#39;a applicative = \u0026#39;a App.applicative structure FunctorMin = ApplicativeMinToFunctorMin(App) structure Functor = MkFunctor(FunctorMin) open App Functor fun af \u0026lt;*\u0026gt; aa = ap af aa fun aa *\u0026gt; ab = pure (fn _ =\u0026gt; fn x =\u0026gt; x) \u0026lt;*\u0026gt; aa \u0026lt;*\u0026gt; ab fun aa \u0026lt;* ab = pure (fn x =\u0026gt; fn _ =\u0026gt; x) \u0026lt;*\u0026gt; aa \u0026lt;*\u0026gt; ab end モナドも同じですね。ただ、 MONAD_MIN から APPLICATIVE_MIN を生成する必要があるので MONAD_MIN のシグネチャに return が増えてます。\nsignature MONAD_MIN = sig type \u0026#39;a monad val return: \u0026#39;a -\u0026gt; \u0026#39;a monad val bind : \u0026#39;a monad -\u0026gt; (\u0026#39;a -\u0026gt; \u0026#39;b monad) -\u0026gt; \u0026#39;b monad end signature MONAD = sig include APPLICATIVE MONAD_MIN sharing type applicative = monad val \u0026gt;\u0026gt;= : \u0026#39;a monad * (\u0026#39;a -\u0026gt; \u0026#39;b monad) -\u0026gt; \u0026#39;b monad val \u0026gt;\u0026gt; : \u0026#39;a monad * \u0026#39;b monad -\u0026gt; \u0026#39;b monad end functor MonadMinToApplicativeMin(M: MONAD_MIN): APPLICATIVE_MIN = struct open M type \u0026#39;a applicative = \u0026#39;a monad val pure = return fun ap mf ma = bind mf (fn f =\u0026gt; bind ma (fn a =\u0026gt; return (f a))) end functor MkMonad(M: MONAD_MIN): MONAD = struct type \u0026#39;a monad = \u0026#39;a M.monad structure AppMin = MonadMinToApplicativeMin(M) structure App = MkApplicative(AppMin) open M App fun ma \u0026gt;\u0026gt;= f = bind ma f fun ma \u0026gt;\u0026gt; mb = ma \u0026gt;\u0026gt;= (fn _ =\u0026gt; mb) end ちょっと ap の実装イケてないなぁと思いつつ先に進みます。\nさて、使ってみましょう。今度はファンクタの適用は一回で済みます。\nstructure ListMonad = MkMonad(struct type \u0026#39;a monad = \u0026#39;a list fun return x = [x] fun bind ma f = List.concat (List.map f ma) end) local open ListMonad in val ret = [1, 2, 3] \u0026gt;\u0026gt;= (fn x =\u0026gt; [4, 5, 6] \u0026gt;\u0026gt;= (fn y =\u0026gt; return (x + y))) fun println s = print (s ^ \u0026#34;\\n\u0026#34;) val () = List.app (println o Int.toString) ret end 動きます。 ご覧の通り、ファンクタの適用は1回で済んでますし、親クラスのインスタンス全て自分で生成しているので実装の一貫性も保障出来ます。ダイアモンド継承が来ても安心ですね！\n感想 私は最初のアプローチの方が好きですね（率直）。\nそれぞれのクラスのインスタンスを作るのは自然だと思いますし実はWorkshopのアプローチは表層上の問題でダイアモンド継承を解決出来ていません。名前衝突が起きます。モジュールの名前衝突ならまだ気合で( val \u0026gt;\u0026gt;= = Monad.\u0026gt;\u0026gt;= のように全て手で)解決出来ますが、シグネチャの方は解決策はなさそうです(いや、シグネチャを使わずに全て手で書き直すとかは可能ですが)。どうせ完全には解決出来てない問題のために実装が曲がるのは好みではないです。\n付録A ダイアモンド継承に強そうなアプローチ 単純に親クラスのインクルードをやめます。んで親クラスは名前空間の汚染を防ぐためにモジュールに入ったまま受け取ることにします。\ninfix 4 \u0026lt;$\u0026gt; \u0026lt;$ $\u0026gt; \u0026lt;*\u0026gt; \u0026lt;* *\u0026gt; infix 1 \u0026gt;\u0026gt;= \u0026gt;\u0026gt; signature FUNCTOR_MIN = sig type \u0026#39;a t val fmap: (\u0026#39;a -\u0026gt; \u0026#39;b) -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;b t end signature FUNCTOR = sig include FUNCTOR_MIN val \u0026lt;$\u0026gt; : (\u0026#39;a -\u0026gt; \u0026#39;b) * \u0026#39;a t -\u0026gt; \u0026#39;b t val \u0026lt;$ : \u0026#39;a * \u0026#39;b t -\u0026gt; \u0026#39;a t val $\u0026gt; : \u0026#39;a t * \u0026#39;b -\u0026gt; \u0026#39;b t val void: \u0026#39;a t -\u0026gt; unit t end functor MkFunctor(Fun: FUNCTOR_MIN): FUNCTOR = struct open Fun fun f \u0026lt;$\u0026gt; fa = fmap f fa fun a \u0026lt;$ fb = (fn _ =\u0026gt; a) \u0026lt;$\u0026gt; fb fun fa $\u0026gt; b = b \u0026lt;$ fa fun void fa = () \u0026lt;$ fa end signature APPLICATIVE_MIN = sig type \u0026#39;a t val pure: \u0026#39;a -\u0026gt; \u0026#39;a t val ap : (\u0026#39;a -\u0026gt; \u0026#39;b) t -\u0026gt; \u0026#39;a t -\u0026gt; \u0026#39;b t end signature APPLICATIVE = sig include APPLICATIVE_MIN val \u0026lt;*\u0026gt; : (\u0026#39;a -\u0026gt; \u0026#39;b) t * \u0026#39;a t -\u0026gt; \u0026#39;b t val *\u0026gt; : \u0026#39;a t * \u0026#39;b t -\u0026gt; \u0026#39;b t val \u0026lt;* : \u0026#39;a t * \u0026#39;b t -\u0026gt; \u0026#39;a t end functor MkApplicative(App: sig structure Functor: FUNCTOR include APPLICATIVE_MIN sharing type Functor.t = t end): APPLICATIVE = struct open App type \u0026#39;a t = \u0026#39;a t fun af \u0026lt;*\u0026gt; aa = ap af aa fun aa *\u0026gt; ab = pure (fn _ =\u0026gt; fn x =\u0026gt; x) \u0026lt;*\u0026gt; aa \u0026lt;*\u0026gt; ab fun aa \u0026lt;* ab = pure (fn x =\u0026gt; fn _ =\u0026gt; x) \u0026lt;*\u0026gt; aa \u0026lt;*\u0026gt; ab end signature MONAD_MIN = sig type \u0026#39;a t val return: \u0026#39;a -\u0026gt; \u0026#39;a t val bind : \u0026#39;a t -\u0026gt; (\u0026#39;a -\u0026gt; \u0026#39;b t) -\u0026gt; \u0026#39;b t end signature MONAD = sig include MONAD_MIN val \u0026gt;\u0026gt;= : \u0026#39;a t * (\u0026#39;a -\u0026gt; \u0026#39;b t) -\u0026gt; \u0026#39;b t val \u0026gt;\u0026gt; : \u0026#39;a t * \u0026#39;b t -\u0026gt; \u0026#39;b t end functor MkMonad(M: sig structure Applicative: APPLICATIVE include MONAD_MIN sharing type Applicative.t = t end): MONAD = struct open M type \u0026#39;a t = \u0026#39;a t fun ma \u0026gt;\u0026gt;= f = bind ma f fun ma \u0026gt;\u0026gt; mb = ma \u0026gt;\u0026gt;= (fn _ =\u0026gt; mb) end structure ListFunctor = MkFunctor(struct type \u0026#39;a t = \u0026#39;a list val fmap = List.map end) structure ListApplicative = MkApplicative(struct structure Functor = ListFunctor type \u0026#39;a t = \u0026#39;a list fun pure x = [x] fun ap af aa = List.concat (List.map (fn a =\u0026gt; List.map (fn f =\u0026gt; f a) af) aa) end) structure ListMonad = MkMonad(struct structure Applicative = ListApplicative type \u0026#39;a t = \u0026#39;a list fun return x = [x] fun bind ma f = List.concat (List.map f ma) end) local open ListFunctor open ListApplicative open ListMonad in fun add x y = x + y val ret1 = [1, 2, 3] \u0026gt;\u0026gt;= (fn x =\u0026gt; [4, 5, 6] \u0026gt;\u0026gt;= (fn y =\u0026gt; return (x + y))) val ret2 = add \u0026lt;$\u0026gt; [1, 2, 3] \u0026lt;*\u0026gt; pure 1 fun println s = print (s ^ \u0026#34;\\n\u0026#34;) val () = List.app (println o Int.toString) ret1 val () = List.app (println o Int.toString) ret2 end 付録B do記法 ちょっと \u0026gt;\u0026gt;= が入り乱れるのはつらいですね。PreMLというSMLのプリプロセッサがあって、do記法（など）のシンタックスシュガーを提供してくれます。\nval ret = do with ListMonad; x \u0026lt;- [1, 2, 3]; y \u0026lt;- [4, 5, 6]; return (x + y) end fun println s = print (s ^ \u0026#34;\\n\u0026#34;) val () = List.app (println o Int.toString) ret 生成されるコードはこれです。\nval ret = let infix 0 \u0026gt;\u0026gt;= val op\u0026gt;\u0026gt;= = ListMonad.\u0026gt;\u0026gt;= val return = ListMonad.return in ( [1, 2, 3] ) \u0026gt;\u0026gt;= (fn x =\u0026gt; ( [4, 5, 6] ) \u0026gt;\u0026gt;= (fn y =\u0026gt; return (x + y) ) ) end  マシになりましたね。\n","categories":["ML","SML"],"category_urls":["/categories/ml","/categories/sml"],"date":"2016-10-10","title":"SMLでモナド","url":"https://KeenS.github.io/blog/2016/10/10/smldemonado/"},
  {"body":"# 正しいScalaのコードが欲しい ---------------------- === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 基盤開発グループ + Lisp, ML, Rust, Shell Scriptあたりを書きます + Scalaはあんまり === # Scalaを始めたばかりの頃の話 === ``` scala def revappend[A]( xs: List[A], ys: List[A]): List[A] = match xs { case Nil = Nil case x::xs_ = revappend(xs_, x::ys) } ``` === ``` scala def length(xs: List[_]): Int = xs match { case Nil = Nil case x::xs_ = 1 + length(xs_) } ``` === ``` scala def append[A]( xs: List[A], ys: List[A]): List[A] = xs match { case Nil = Nil case x::xs_ = x :: append(xs_, ys) } append(List(1, 2, 3), List(4, 5, 6)) // = List(1, 2, 3) ``` === # Scalaを始めたばかりの頃の話 ----------------------------- * 正しくないコードばかり書いてしまう + 他の言語の構文と混ぜてしまう + 型エラー + 実装ミス * 正しいScalaのコードが欲しい === # 正しさって？ ------------- * 構文が正しいコード? * コンパイルが通るコード? * バグのないコード？ + テストが通るコード? === # 正しさって？ ----------- * 数学だったら？ * 数学なら証明されれば正しい * プログラムの証明???? === # Isabelle ---------- * 汎用証明支援系 * [Isabelle](https://isabelle.in.tum.de/) * 結構昔からある * 関数型言語 + 高階論理 === # コード -------- ``` isabelle datatype 'a list = Nil (\"[]\") | Cons 'a \"'a list\" (infixr \"#\" 65) primrec app :: \"'a list = 'a list = 'a list\" (infixr \"@\" 65) where \"[] @ ys = ys\" | \"(x # xs) @ ys = x # (xs @ ys)\" ``` === # 証明 ------ ``` isabelle lemma app_Nil2 [simp]: \"xs @ [] = xs\" apply(induct_tac xs) apply auto done lemma app_assoc [simp]: \"(xs @ ys) @ zs = xs @ (ys @ zs)\" apply (induct_tac xs) apply auto done ``` === # Extract --------- ```isabelle export_code append in Scala module_name \"Example\" file \"Example.scala\" ``` === # Scalaのコード --------------- 証明されたScalaのコードが手に入る ``` scala object Example { abstract sealed class list[A] final case class Nila[A]() extends list[A] final case class Cons[A](a: A, b: list[A]) extends list[A] def append[A](x0: list[A], ys: list[A]): list[A] = (x0, ys) match { case (Nila(), ys) = ys case (Cons(x, xs), ys) = Cons[A](x, append[A](xs, ys)) } } /* object Example */ ``` === # 余談 ------- 他の言語にもextract出来る ```isabelle export_code append in SML module_name \"Example\" file \"Example.sml\" ``` === # まとめ --------- * プログラムは証明出来るよ * Isabelleで証明が出来るよ * Isabelleで証明したら正しいScalaのコードが手に入るよ   ","categories":["Scala","Isabelle","ScalaMeetUp","社内"],"category_urls":["/categories/scala","/categories/isabelle","/categories/scalameetup","/categories/%e7%a4%be%e5%86%85"],"date":"2016-10-05","title":"正しいScalaのコードが欲しい","url":"https://KeenS.github.io/slide/tadashiiscalanoko_dogahoshii/"},
  {"body":"κeenです。ふとTwitterでPijulの話題を見掛けたついでにインストールしようと思ったら難易度が高かったので解説します。 Pijulそのものについては過去のエントリを参照して下さい。\n因みにPijulは「ピーフール」みたいに発音するそうです。「フー」は喉の奥から出す破擦音ですね。\nまず、公式ドキュメントには cargo install pijul すると書いてますが、これはバージョン0.1、古いやつな上にビルドに失敗します。 ということでソースからビルドするのですがビルドガイドがないので非常に難しいです。コマンドだけ載せてしまうと\n$ darcs get https://pijul.org $ cd pijul.org/pijul $ cp -R ../libpijul src $ cd src/libpijul/src $ darcs get https://pijul.org/sanakirja $ cd ../../../ $ cargo install です。これだと常に最新版をビルドしてしまいますがdarcsでタグを指定する方法が分からなかったのでこれで。 あ、あとdarcs get https://pijul.org/sanakirjaでnested repositoryで怒られますがそれもよく分からなかったのでそのまま。 darcsに馴れてる方は好きにして下さい。\n因みにその後のコマンドはちゃんと動くので公式ガイドに従えば使えます。\n","categories":["Pijul"],"category_urls":["/categories/pijul"],"date":"2016-09-29","title":"Pijulのインストールが難易度高いので解説する","url":"https://KeenS.github.io/blog/2016/09/29/pijulnoinsuto_ruganan_idotakainodekaisetsusuru/"},
  {"body":"κeenです。 先日、先輩社員と話してるとシェルを作る話になりました。 だいたいのコンピュータサイエンスの学生なら学部生の頃に課題でシェルを作りますが数学科にいた私は作ったことありませんでした。 でも、その時「今ならシェルなんて作ろうと思えばすぐに作れますよ」なんて言っちゃったのでなんか作りました。 まあ、習作程度の雑なものです。\n作ったのはこれ、KeenS/igaguri: my toy shell written in Rust。 名前は、Shellは木の実を覆う殻のようにカーネルを覆う殻とのことなのでRustのロゴに似てる毬栗を選びました。\nパーサ パーサコンビネータライブラリのnomを使いました。\n雰囲気こんな感じ。\nnamed!(token\u0026lt;String\u0026gt;,map!(map_res!(is_a!(\u0026#34;abcdefghijklmnopqlrstuvwxyzABCDEFGHIJKLMNOPQLRSTUVWXYZ-!$%^\u0026amp;@/1234567890\u0026#34;),str::from_utf8),|i: \u0026amp;str|i.to_string()));named!(pipe,tag!(\u0026#34;|\u0026#34;));named!(redirect_out\u0026lt;String\u0026gt;,chain!(tag!(\u0026#34;\u0026gt;\u0026#34;)~opt!(multispace)~filename: token,||filename));named!(command\u0026lt;Ast\u0026gt;,chain!(opt!(multispace)~cmd: separated_list!(multispace,token)~outfile: opt!(chain!(multispace~out: redirect_out,||out))~opt!(multispace),||Ast::Command{cmd: cmd,out: outfile}));named!(parse\u0026lt;Ast\u0026gt;,map!(separated_list!(pipe,command),Ast::Pipe)); 入力ハンドリング readlineのRust実装、rustylineを使いました。\nそれっぽいからとりあえず、で選んだものの、複数行入力（履歴）とか考えるともうちょっとリッチなものを選んだ方が良かったかもしれません。\n実行 最初、libcバインディングの pipe や fork 、 execve なんかを考えてましたが、標準ライブラリの std::process::Commandで実現出来そうだったのでそれを使いました。\nこんな感じ。\nCommand::new(cmd).args(\u0026amp;terms).stdin(stdin).stdout(stdout).stderr(stderr).spawn() パイプ/リダイレクト 一応、パイプも標準ライブラリでサポートされてるのでそれを使いました。\nただ、普通のCとは違って子プロセスと親プロセスの間に一旦パイプを作って、子プロセスの出力の生のfdを取り出して、次の子プロセスの入力に与えて、と案外面倒でした。 unsafe も出てくれば unreachable も出てくるのでもう少し書き直したい。\nletmutsi=stdin;letmutitr=commands.into_iter().peekable();unsafe{whileletSome(command)=itr.next(){ifitr.peek().is_some(){letprocess=try!(self.run(command,si,Stdio::piped(),Stdio::inherit()));si=Stdio::from_raw_fd(process.stdout.unwrap().into_raw_fd());}else{returnself.run(command,si,stdout,stderr);}}}unreachable!() リダイレクトも似たようなもので、ファイルを作って生のfdを取り出して、とやります。\nletstdout=out.map(|f|{unsafe{letfile=File::create(f)// FIXME: do not panic .unwrap();Stdio::from_raw_fd(file.into_raw_fd())}}).unwrap_or(stdout); おわりに 昨日の夜からちょろっと作り始めてさっきそれっぽく動くようになった程度なのでまだ適当にしか動きません。 パイプと標準出力のリダイレクトだけで、 cd なんかのシェルコマンドもなければシェル変数もありません。 が、そろそろ飽きたのでこの辺で。\nそろそろ飽きてきた\n\u0026mdash; κeen (@blackenedgold) 2016年9月4日\u0026lt;/ blockquote\u0026gt; \nシェルコマンドとシェル変数くらいはいつか実装しようかな。\n","categories":["Rust","Shell"],"category_urls":["/categories/rust","/categories/shell"],"date":"2016-09-04","title":"Rustでシェル作った","url":"https://KeenS.github.io/blog/2016/09/04/rustdeshierutsukutta/"},
  {"body":"κeenです。久しぶりにmirahのリリースが出ましたので新機能の紹介をしたいと思います。\nリリース版のダウンロードは こちらから。\n== のセマンティクス変更 Rubyに合わせて、 == が等価性、 === が同値性の比較になりました。\nimport java.net.URL puts \u0026#34;1 == 1 =\u0026gt; #{1 == 1}\u0026#34; puts \u0026#34;1 === 1 =\u0026gt; #{1 === 1}\u0026#34; x = 1; puts \u0026#34;x = 1\u0026#34; puts \u0026#34;x == x =\u0026gt; #{x == x}\u0026#34; puts \u0026#34;x === x =\u0026gt; #{x === x}\u0026#34; puts \u0026#34;URL.new(\\\u0026#34;http://hoge.com\\\u0026#34;) == URL.new(\\\u0026#34;http://hoge.com\\\u0026#34;) =\u0026gt; #{URL.new(\u0026#34;http://hoge.com\u0026#34;) == URL.new(\u0026#34;http://hoge.com\u0026#34;)}\u0026#34; puts \u0026#34;URL.new(\\\u0026#34;http://hoge.com\\\u0026#34;) === URL.new(\\\u0026#34;http://hoge.com\\\u0026#34;) =\u0026gt; #{URL.new(\u0026#34;http://hoge.com\u0026#34;) === URL.new(\u0026#34;http://hoge.com\u0026#34;)}\u0026#34; x = URL.new(\u0026#34;http://hoge.com\u0026#34;); puts \u0026#34;x = URL.new(\\\u0026#34;http://hoge.com\\\u0026#34;)\u0026#34; puts \u0026#34;x == x =\u0026gt; #{x == x}\u0026#34; puts \u0026#34;x === x =\u0026gt; #{x === x}\u0026#34;1 == 1 =\u0026gt; true 1 === 1 =\u0026gt; true x = 1 x == x =\u0026gt; true x === x =\u0026gt; true URL.new(\u0026#34;http://hoge.com\u0026#34;) == URL.new(\u0026#34;http://hoge.com\u0026#34;) =\u0026gt; true URL.new(\u0026#34;http://hoge.com\u0026#34;) === URL.new(\u0026#34;http://hoge.com\u0026#34;) =\u0026gt; false x = URL.new(\u0026#34;http://hoge.com\u0026#34;) x == x =\u0026gt; true x === x =\u0026gt; true ビルトインMacroの追加 キャスト 今まで、Mirahのキャスト構文は\nint(0.5) のように関数呼び出しっぽい形式でしたが、この度 as! マクロが追加されたので以下のように書けるようになりました。\nputs \u0026#34;0.5.as!(int) =\u0026gt; #{0.5.as!(int)}\u0026#34;0.5.as!(int) =\u0026gt; 0 Synchronize javaの Lock の lock , unlock を sychronize マクロでラップしました。Javaのビルトインの synchronized ではない模様。\nimport java.util.concurrent.locks.ReentrantLock lock = ReentrantLock.new counter = 0 th1 = Thread.new do 100.times do lock.synchronize do counter += 1 end end end th2 = Thread.new do 100.times do lock.synchronize do counter -= 1 end end end th1.run th2.run th1.join th2.join puts \u0026#34;counter = #{counter}\u0026#34;counter = 0 private private def my_method puts \u0026#34;foo\u0026#34; end みたいに書けるようになりました。\nラッパークラスの演算子 int に対する Integer のようなラッパークラスにも演算子マクロが定義されるようになました。\nb = Integer.new(1); puts \u0026#34;b = Integer.new(1)\u0026#34; b += 1;puts \u0026#34;b += 1\u0026#34; puts \u0026#34;a \u0026lt; b =\u0026gt; #{a \u0026lt; b}\u0026#34;a \u0026lt; b =\u0026gt; true 他にも色々と定義されているようです。\n改善  Javaのバイトコードを吐くライブラリasmのバージョンが5になりました。 コンパイラのの内部で使っているロガーをマクロで書き直すことでDebug出力しない時のコンパイラの速度が速くなりました(確かこの変更が入った時に20%速くなるって言ってたような)。 マクロがサービスプロバイダの仕組みに乗っかるようになりました。 マクロを使うには今までマクロを定義したmirahのソースコードを一緒にコンパイルしないといけなかったのが、Mirahコンパイラがクラスパスから捜すようになったのでJarによる配布が現実的になりました。  最後に マクロ周りが便利になるなど、興味深い変更がありましたね。 みなさんもこれを機にmirahを使ってみて下さい。\n","categories":["Mirah"],"category_urls":["/categories/mirah"],"date":"2016-08-11","title":"mirah 0.2がリリースされました。","url":"https://KeenS.github.io/blog/2016/08/11/mirah_0_2gariri_susaremashita/"},
  {"body":"ちょっとポエムというか自分語りを。会社の同期と話してて少し刺激されたので。あとはソースコードって実際のところどういうふうに書いていますか？｜Rui Ueyama｜noteにも刺激されて。\n発端は同期が最近は何か書いてもイケてなくて後で丸っと書き直すことが多くてつらい、という話を始めたこと。 自分は、そんなの普通だろと返した。少なくとも自分の中では当たり前だった。 ふと考えてみたらそうじゃない人も沢山いる気がした。当たり前じゃない人に、自分の当たり前を喋ってみたら面白そうということで自分がコードを書くときにやることを語る。\nコードを書き始めた時点では仕様は完全には固まっていない。アプリケーションの構成とかは決まってるけど、ソフトウェアの中身はほとんど何も決まっていない。 まずは手を着けやすそうな所から始める。最初は必ずHello Worldから。そしてmainの中にPoCを書いてイメージを掴む。 そこから一気に飛躍して、ディレクトリ構成を決める。mainは三枚下ろしにして各ディレクトリ下に入れる。これでアプリケーションの骨格が見える。ここまでトップダウン。この状態でアプリケーションを走らせるとPoCが動く。\n次はボトムアップのフェーズで、骨格に肉付けしていく。1度に考えることが一箇所で済むように、順番を考えながら気儘にコードを加えていく。だいたいデータアクセス層のインターフェース、データアクセス層の実装のスタブ、サービス層のスタブ、メインルーチン、サービス層、くらいの順番。抽象すると必要そうなものを定義する、定義したものを使う、定義したものを実装する。多少型が違ってコンパイルが通らなくても気にしない。エラー処理やエッジケースは全部スタブのまま。コードのあちこちに FIXME が散らばる。条件分岐の枝は全ては書かない。頭のコンテキストスイッチで死んでしまう。集中したい枝以外はFIXMEで埋める。こんなもんかな、と思ったところでちゃんとコンパイルが通るように修正する。ここまでテスト無し、データアクセス層の実装無し。\nここからようやく永続データのスキーマやアプリケーションの仕様を決める。コードを見ればどういうデータにパターンでアクセスして、どういうエッジケースがあるかが分かるからサクサク決まる。\nデータのスキーマが決まったので最後データアクセス層を実装出来る。そしたら動くものが完成する。動いたものをポチポチやってみて実装が正しいことを確認する。\nこのまま細かい実装を詰めていくかというとそうならない。仕様を見て、コードを見て、イケてない所を全部書き直す。まずはインターフェースを変える、型を変える。意図的にコードを壊す。あとはコンパイルエラーで修正箇所が全て分かる。ついでにFIXMEも片付けていく。エラーが取れてアプリケーションが再度動くようになったら、リファクタの完了。納得のいくコードになっている筈。ここでようやく仕様を固定するためにテストを書く。全てのコードが出来てからテストを書くからホワイトボックスに近いテストになる。\nどうしてこのようなプロセスを経るかと考えてみた。ポールグレアムも言っているように、私にとってのアプリケーションは、アプリケーションのドメインを記述するための巨大な言語（ライブラリ）と、それを使った非常に小さな実装からなる。 そして言語と実装の境界は何度も押したり引いたりしてようやく固まる。この手順は境界が固まるまでの過程だ。DSLを作るにはまずどのようなAPIがあれば便利か理解する必要がある。理解するのに一番手っ取り早い方法は一旦実装してみることだ。 ある人は言うだろう、「何を七面倒な。最初からちゃんと設計していれば手戻りがないものを。」と。違う。こういうときに私はよく詰将棋を引き合いに出す。 新聞の片隅にある詰将棋を解いてみる。新聞とにらめっこしてアレコレ考えても中々上手くいかない。 ところが将棋盤を引っ張り出してきて、パチパチ駒を動かしてみると簡単に解けることがある。ここは実は銀を持っていた、ここで馬が効くからこの手は指せない。 人間先を読むには想像力が足りなすぎる。目の前に現物がないと気付けないことが多い。だから先に実装する。一度作ってしまえば壊してもコンパイラが助けてくれる。\n一度目でアタリを付ける。二度目で実線を書く。作って、壊して、また作る。\n","categories":["開発手法","ポエム"],"category_urls":["/categories/%e9%96%8b%e7%99%ba%e6%89%8b%e6%b3%95","/categories/%e3%83%9d%e3%82%a8%e3%83%a0"],"date":"2016-08-02","title":"私がコードを書くときテストは書かない","url":"https://KeenS.github.io/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai/"},
  {"body":"# 型クラスを越えて ---------------------- [歌舞伎座.tech#10「型クラス勉強会」](http://kbkz.connpass.com/event/32420/) === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバーエージェントのエンジニア + Lisp, ML, Rust, Shell Scriptあたりを書きます === # Rustとは ---------- * システムプログラミング言語 * GCなし！でもメモリ管理は自動 * **Zero-Cost Abstraction** * **Trait-Based Generics** * パターンマッチ、代数的データ型などなど * [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/README.html) === # Rustのトレイト的なの ---------------- * 型に固有のメソッド + オブジェクト指向的な * トレイト + 型クラス === # 型クラスじゃない方 ------------------- ``` rust struct Person { name: String, } impl Person { // Static constructor fn new(name: String) - Self { Person{name: name} } // method fn hello(\u0026self) { println!(\"Hello, {}\", self.name); } } ``` === ``` rust let person = Person::new(\"κeen\"); person.hello(); ``` === # 多相型と制約 -------------- ``` rust struct Temp(T); impl Temp { fn fromCelsius(t: isize) - Self { Temp(Celsius(t)) } } impl Temp { fn fromFahrenheit(t: isize) - Self { Temp(Fahrenheit(t)) } } ``` === # 型クラス --------- * 便利 * 他の言語にも取り入れてほしい * 型クラスを入れることで言語設計がどうなるか * ユーザランドより言語機能的な部分フォーカス === # Rustの型クラスの実装 --------------------- * 動的ディスパッチと静的ディスパッチ両方がある * 動的ディスパッチ + implicit parameterを渡すやつ * 静的ディスパッチ + コンパイル時に解決してしまうやつ * デフォフォルト静的 + 動的を選ぶことも出来る === # 静的ディスパッチの意味 ----------------------- * Zero-Cost Abstraction * ユーザはパフォーマンスのために設計を曲げる必要がなくなる * インライン化などの最適化も出来る * 逆の見方をすればZero-Cost Abstraction出来るからシステムプログラミング言語に高級な機能を入れれた === # 型クラス+α ----------- それぞれ面白い特徴が。 * `FromStr` * `Write` * `Add` * `Default`, `Zero` * `Iterator` === # 型クラス+関数 -------------- * 関連関数 * `FromStr` * static関数的なものになる ```rust pub trait FromStr { type Err; fn from_str(s: \u0026str) - Result; } ``` === ``` rust use std::str::FromStr; let s = \"5\"; let x = i32::from_str(s).unwrap(); assert_eq!(5, x); ``` === # 型クラス+構文 -------------- * = メソッド * 第一引数が `self` な関数はメソッド構文で呼び出せる * クラスがなくても継承がなくてもオブジェクト指向 * `Write` ``` rust trait Write { fn write(\u0026mut self, buf: \u0026[u8]) - Result; } ``` === ``` rust impl Write for Foo { fn write(\u0026mut self, buf: \u0026[u8]) - Result { ... } } let foo = Foo::new(); foo.write(aa); ``` === # 型クラス+UFCS --------------- * = 実質オーバーロード * 中身の違うメソッドを複数定義出来る * どのメソッドを呼ぶかを決定する構文がある + = Universal Function Call Syntax === ```rust trait Foo { fn foo() - i32; } struct Bar; impl Bar { fn foo() - i32 { 20 } } impl Foo for Bar { fn foo() - i32 { 10 } } ``` === ```rust ::foo(); Bar::foo(); ``` === # 型クラス+演算子 ----------------- * = 演算子オーバーロード * `Add` ``` rust pub trait Add{ type Output; fn add(self, rhs: RHS) - Self::Output; } ``` === ``` rust use std::ops::Add; struct Foo; impl Add for Foo { type Output = Foo; fn add(self, _rhs: Foo) - Foo { println!(\"Adding!\"); self } } fn main() { Foo + Foo; } ``` === for (my_int i = 0; i \u0026lt; 10; i++) { … }\nCならどういうアセンブリに落ちるかすぐわかるけどC++ならmy_intはクラスかもしれず=0はコンストラクタを起動し\u0026lt;はメソッド呼び出しになり++はejectを発行して光学ディスクトレイが開き相手は死ぬ\n\u0026mdash; わさびず 2015年12月29日 === # 型クラス+値 ------------- * = 関連定数 * unstable... * `Zero`, `Default` ``` rust // current pub trait Zero { fn zero() - Self; } ``` ``` rust // ideal #![feature(associated_consts)] pub trait Zero { const ZERO: Self; } ``` === ```rust trait Monoid: Add + Zero where Self::Output : Add + Zero { } ``` === # 型クラス+型 ------------- * 関連型 * 型族…？ + あまり違いを分かっていない + 関連型を持った型をまとめたのが型族？ * `Iterator` ```rust pub trait Iterator { type Item; .... } ``` === ``` rust trait Iterator { ... fn next(\u0026mut self) - Option; } ``` === # 型クラス+暗黙のルール --------------------- * オーバーライド * `Drop` + 暗黙に呼ばれるデストラクタをオーバーライド出来る ```rust pub trait Drop { fn drop(\u0026mut self); } ``` === ``` rust impl Drop for Lock { fn drop(\u0026mut self) { self.free(); } } ``` === # 型クラス+アノテーション ------------------------ * 単純に便利 * `derive`(`Debug` , `Eq`) ``` rust #[derive(Debug, Eq)] struct Foo(usize); ``` === ``` rust let foo1 = Foo(1); let foo2 = Foo(2); println!(\"{:?} == {:?} ?: {:?}\", foo1, foo2, foo1 == foo2); ``` === # まとめ -------- * 型クラスは便利だよ * 型クラスの実装は効率的に出来るよ * 型クラスを使うと言語設計も変わるよ   ","categories":["型クラス","型"],"category_urls":["/categories/%e5%9e%8b%e3%82%af%e3%83%a9%e3%82%b9","/categories/%e5%9e%8b"],"date":"2016-07-16","title":"型クラスを越えて","url":"https://KeenS.github.io/slide/katakurasuwokoete/"},
  {"body":"武芸十八般のひとつシェル芸ってワードがふと湧いてきたけどどちらかというとシェル芸十八般とかの方がよさそう。grep, cut, xargs,\u0026hellip;\n\u0026mdash; κeen (@blackenedgold) 2016年7月13日 \ncat ファイルの内容を吐くのに使う。 -n とか使えそうなオプションがあるが滅多に使わない\n例 cat file head 標準入力の先頭のほうだけを切り取る。大きなファイルに対して処理する前にちょろっと試すのに使う\n例 cat large_file | head -n 10 | ... tail 標準入力の末尾のほうだけを切り取る。-f オプションでよく使う\n例 tail -f log_file | grep -ie error -e \u0026#39;$\u0026#39; grep globally regexp print. 汎用フィルタとして様々に活躍する他飛び道具的な使い方もある。\n例 cat file | grep some_wordcat file | grep -v \u0026#34;^[ \\n\\t]+$\u0026#34;echo hello | grep -o . awk プログラミング言語awk。だいたい cut の上位互換として使われる。\n例 ls -l | awk \u0026#39;{print $3}\u0026#39;seq 1 100 | awk \u0026#39;BEGIN{sum=0}{sum+=$0}END{print sum}\u0026#39; sed プログラミング言語sed。だいたい s/RE/replace/ が使われるが使いこなすと深い。\n例 cat log_file | sed \u0026#39;s/error/ERROR/gi\u0026#39;cat some.csv | sed 1d xargs 標準入力を横に並べる、コマンドを並列に実行する、繰り返し実行をするなどストリーム内での制御機構的働きをする\n例 seq 1 10 | xargs echofind . -type f | xargs -P $(nproc) grep FIXMEinc(){ echo $(( 1 + $1 ));} export -f sum seq 1 10 | xargs -I@ bash -c \u0026#39;sum @\u0026#39; find 複雑なクエリ式を書けるコマンド。(シェルに依存してしまう)ワイルドカード展開の肩代わりなんかも出来る。xargsに繋げることが多い。\n例 find . -type f -name \u0026#39;*.md\u0026#39; -exec basename \u0026#39;{}\u0026#39; .md \\; sort ほぼ次のuniqに繋げるために使うことが多い。あるいはuniqした結果を使う。\n例 cat .histfile | grep \u0026#39;|\u0026#39; | sed \u0026#39;s/|/\\n/g\u0026#39; | awk \u0026#39;{print $1}\u0026#39; | LANG=C sort | uniq -c | LANG=C sort uniq 多くは頻度のカウントに使う。\ntar リモートホストとファイルをやりとりするのに使う。\n例 ssh stepper ssh host1 tar czf - -C \u0026#39;/var/log/somedir/\u0026#39; stdout.log stderr.log | tar xzf - -C /tmp zcat 圧縮ファイル扱うのに使う。よくtarと組み合わせる。 プロセスが分かれる分マルチコアを使えるのでtarのzオプション使うより速いかもしれない。\n例 zcat some.tar.gz | tar tf - | xargs -I@ -n 1 basename @ .java date 日付操作用コマンド。BSD系とGNU系で全然違う。つらい。\n例 find logs -type f -name \u0026#39;*.log\u0026#39; | xargs -I@ dirname @ | sed \u0026#39;s|logs/||\u0026#39; | tr / - | xargs -I@ date --date=@ +%w | sort | uniq -c tr 文字置換、削除。sedで出来るじゃんとか言わない。\n例 cat data.list | tr -c \u0026#39;[a-zA-Z0-9\\n]\u0026#39; _ | xargs touch curl なんでもプロトコル喋る人。結果を標準出力に吐くのでREST APIを叩いた後シェル芸に繋げやすい。\n例 curl http://example.io/status | jq -r \u0026#39;.status\u0026#39; jq チューリング完全言語jq。REST API叩いてjsonが返ってきた時に使うと便利。\nod バイナリデータを扱うのに使う。\n例 cat /dev/urandom | od -x | head -n 10 | ... tee T字管のようにパイプを分岐させるのに使う。あるいはシェルの機能であるリダイレクトをコマンドとして実行するのに使う。\n例 cat nginx.conf | ssh stepper ssh host1 sudo tee /etc/nginx/nginx.conf \u0026gt; /dev/null","categories":["Shell","シェル芸"],"category_urls":["/categories/shell","/categories/%e3%82%b7%e3%82%a7%e3%83%ab%e8%8a%b8"],"date":"2016-07-13","title":"シェル芸十八般","url":"https://KeenS.github.io/blog/2016/07/13/shierugeijuuhachihan/"},
  {"body":"κeenです。先日、Kubernetesの開発者が書いたKubernetes: Container Design Patternsというのを教えてもらって、面白かったのでそれを紹介します。 ただ漫然とコンテナを使っているだけでは気付かない使い方があったのでコンテナに興味のある方は是非一読下さい。\n序論 オブジェクト指向が出てすぐにオブジェクト指向デザインパターンが産まれたように、分散システムにもデザインパターンが必要となってきました。 分散システムのデザインパターンの萌芽はHadoop/MapReduceに見ることが出来ますが、Javaに限られていました。 ところがここ数年の(Linuxの)コンテナ技術の躍進により欠けていたピースが埋まりました。分散システムパターンへのデプロイの抽象化です。 依存モジュールも一緒にデプロイ出来ますし、デプロイの状態も成功/失敗の二値になります。 それだけでなく、コンテナはオブジェクト指向におけるオブジェクトによく似た役割を果たします。それを見ていきましょう。\n単一コンテナのマネジメント パターン コンテナは、自然にインターフェースの境界となります（オブジェクトと同じように）。 アプリケーション機能のインターフェースに留まらず、コンテナそのものの管理インターフェースも提供するでしょう。 典型的には run() pause() stop() の管理ですが、もっと多様な管理インターフェースが有り得ます。\n大抵の今時のプログラミング言語ならHTTP経由でJSONをやりとりする機能くらい簡単に書けるのでそれがコンテナ間で統一さたインターフェースになりえるでしょう。\n上位のアプリケーションに対してはコンテナ内の情報(アプリケーションのQPS, プロファイル情報, コンフィグ情報, ヘルスチェック, ログなどなど)を提供するでしょう。\n下位のアプリケーションにはマネジメントインターフェース、例えばgraceful shutdownなどを提供することになるでしょう。 Android OSがActivityを管理する時に様々なコールバック(onCreate, onResume\u0026hellip;)を呼ぶように、分散マネージャがコンテナを管理するための様々なAPIを提供すると綺麗に管理出来ます。 また、コンテナ特有の機能として「レプリケーションする」（スケールアップするためのインターフェース）なんかもあるかもしれません。\n単一ノード、複数コンテナのアプリケーションパターン コンテナマネージャにはKubernetesのPodやNomadのTask Groupsのように複数のコンテナを1つのノードにスケジュールする機能があります。 別にコンテナに分けずに複数のコンテナをアプリケーションと同じの1つのコンテナに入れることも可能です。しかしながら分けた方が様々なメリットが得られます。\n コンテナがリソース管理の単位である。cgroupによる管理がやりやすくなる。 コンテナがパッケージングの単位である。複数のコンテナでデプロイや管理をするチームを分けるのも簡単になるし、テストも簡単になる。 コンテナが再利用の単位である。多くのサブ機能コンテナは多種のメインコンテナと一緒に使うことが出来る。 コンテナが障害を分離する境界になる。例えば、コンテントマネジメントコンテナに障害があったとしても、Webサーバコンテナはサービスを継続出来るようになる。 コンテナがデプロイの単位となる。新しい機能の追加やロールバックが単独で行える。（ただし、アプリケーションのバージョンの組み合わせが増えるという点では短所にもなる）。  ということでそれらを前提にしたデザインパターンをいくつか。\nサイドカーパターン メインのアプリケーションコンテナにサイドカーのように付属するコンテナを付けて、機能を足すパターンです。 例えばアプリケーションがあって、それのログをローカルストレージから分散ストレージに保存するサイドカーなど。\n逆に、ローカルディスクのファイルを提供するWebサーバがあったとして、そのために定期的にgitからstatic fileをpollするサイドカーコンテナなんかもあるかもしれません。\nこれらのサイドカーは同じノードのコンテナ同士ならディスクボリュームを共有出来ることに依存した作りになっています。\nアンバサダーパターン アンバサダーパターンはメインコンテナと別システムとのコミュニケーションを代理します。 例えば、twemproxy のコンテナをアンバサダーとすれば実際は複数のmemcachedにシャードされたmemcachedクラスタと通信しているも関らず、アプリケーションはローカルホストのmemcachedと通信しているように出来ます。\nこの利点は1つにはアプリケーションをローカルホストのmemcachedと通信することだけを考えて書けばいいようになる点、もう1つにはアプリケーションのテストをローカルホストのmemcachedとだけすれば良くなる点、さらにもう1つにはtwemproxyのコンテナを（別の言語で書かれた）別のアプリケーションに使い回せる点にあります。\nこれは同じホストのコンテナ同士はローカルホストのネットワークインターフェースを使って通信出来ることに依存した作りになっています。\nアダプターパターン アダプターパターンはアンバサダーパターンの逆で、アプリケーションを外部から観測した時に統一されたインターフェースを提供するようにするために使います。\nアプリケーション毎にメトリクスの採り方は異ります（例えばJavaならJMX、など）。様々にあるメトリクスを統一したインタフェースで提供するとメトリクスアグリゲータが非常にシンプルになります。 具体的な例を出すとPrometheusのためのインターフェース (HTTP /metrics)を提供する(exporter)コンテナなどです。\nアダプターとメインコンテナはストレージやローカルホストネットワークを通じてデータをやりとりするでしょう。\n複数ノードアプリケーションパターン 次は複数のノードに跨る協調分散システムでのパターンです。 こちらも同じくPodなどの抽象化を前提とします。\nリーダー選出パターン 分散システムではリーダを選出する需要が多々あります。 例えば複数のレプリカを作った時にマスターがコケたら次のマスターを選出しないといけません。\n巷にはリーダー選出アルゴリズムを実装したライブライが出回っていますが、往々にして難解であり、また、特定の言語でしか動かないので再利用性がありません。\nそこで、ライブラリを使うのではなくてリーダー選出コンテナを実装しましょう。\n単一ノードのパターンと同じく、リーダー選出コンテナとアプリケーションコンテナを一緒にスケジューリングします。 そして、リーダー選出コンテナが他のコンテナとネゴシエーションしてリーダーになったら、ローカルホストのHTTP APIにbecomeLeader、renewLeadershipなどのクエリを投げます。 アプリケーションはただそれらのエンドポイントを実装しさえすればいいのです。\nこのコンテナはアプリケーションにも言語に依存しないので自由に使い回すことが出来ます。\nワークキューパターン もう1つのよくある分散システムでのタスクは、ワークキューによる分散実行です。 いくつかワークキューの実装はありますが、やはりそれらは特定の言語に依存しています。\nそこで仕事の分配のコンテナ、そして、仕事実行のフレームワークとなるコンテナを用意してあげましょう。\nフレームワークのコンテナは分配コンテナから仕事(ファイルなど)を受け取って、ユーザの書いた実行コンテナに処理を移譲します。そしてフレームワークコンテナが実行コンテナの出力した結果をまた分配コンテナに戻します。\n[Request] +---[フレームワークコンテナ]=[実行コンテナ(ユーザ)] | | [分配コンテナ] --+ | | | +---[フレームワークコンテナ]=[実行コンテナ(ユーザ)] | [ワークキューの保存など] 分散協調の部分をフレームワークコンテナがやってくれるのでユーザが書く実行コンテナは非常にシンプルになります。\n分配/集約パターン このパターンは、クライアントが1つの巨大なタスクをルートコンテナに投げ、ルートコンテナが子コンテナ達に分割したタスクを移譲します。そして子コンテナ達の結果を纏めてクライアントに返します。\nMapReduceと同じように、タスクを実行するリーフコンテナと、リーフコンテナの結果を纏めるマージコンテナを用意する必要があります。\nコンテナは特定のインターフェースさえ実装していればいいのでリファクタが(オブジェクト指向の時と同じように)容易です。\nまた、子コンテナにルートコンテナと同じようなscatter/gather機能を持ったコンテナを使うことで、任意の深さにまでタスクツリーを作ることが出来ます。 これは例えば処理中のリソース使用量が多いときに部分的にタスクを実行してマージを繰替えすことで必要となる最大リソースを減らす、などに使えるでしょう（他にももっとあるかもしれませんがパッとは思いつきませんでした）。\nまとめ コンテナのデザインパターを紹介しました。フレームワークコンテナなど、興味深いパターンもあって興味深いですね。\nまだまだパターンはありえると思うのでこの分野（？）、もう少し広まると良いですね。\n","categories":["Docker"],"category_urls":["/categories/docker"],"date":"2016-07-02","title":"Container Desgin Patterns","url":"https://KeenS.github.io/blog/2016/07/02/container_desgin_patterns/"},
  {"body":"# Socket on SML\u0026#x23; ---------------------- [ML勉強会](http://connpass.com/event/32752/) 2016-07-09 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバーエージェントのエンジニア + Lisp, ML, Rust, Shell Scriptあたりを書きます === # HTTP on SML\u0026#x23;? ------------- * SML#にJSONサポートが入った + REST API簡単に叩けるのでは？ * SML#にFully Concurrent GCが入った + HTTPサーバ書くとレイテンシ抑えられて嬉しいのでは？ * スレッドも使えるしスループットも高い筈 * SML#でHTTPの機運 * しかしHTTPサポートはないので自前実装するしかない === # Socket on SML\u0026#x23;? ------------------ * HTTPサポートに必要 * Basisにはある (Optional) + SML#のBasisはサポートしてない * FFIあるしユーザランドで実装するか * [KeenS/SmlSharpSocketSupport](https://github.com/KeenS/SmlSharpSocketSupport) === # TCP/IP、ソケットなど --------------------------- * ソケットアドレス - 自分、相手の居場所。これがないと通信出来ない + 複数のアドレスファミリ(AF)がある + IP v4, IP v6, UNIXドメインなど。 * ソケット - 通信の仕組み。プログラムからはfdとして見える。 + AFやtype(stream/diagram)の属性を持つ * INet - インターネットドメインソケット + TCPとUDP + IP v4/v6アドレスで通信 === # 主要なstructure ----------------- * Socket * NetHostDB * INetSock * (UnixSock) === # [NetHostDB](http://sml-family.org/Basis/net-host-db.html#SIG:NET_HOST_DB) ----------- * ドメイン名からIPアドレスを調べたり逆をやったり * Cの古い(現在では非推奨な)APIに合わせた設計 + IPがv4/v6が混じることを考慮してない + 非推奨どころか脆弱性もあったり CF [glibc の脆弱性 CVE-2015-0235（通称：GHOST）についてまとめてみた - piyolog](http://d.hatena.ne.jp/Kango/20150128/1422409960) * 新しいAPIで実装するのが面倒 === # [Socket](http://sml-family.org/Basis/socket.html#SIG:SOCKET.accept:VAL:SPEC) --------- * まあまあでかいけどsend/receive関数の変種が一杯あるだけ * ドメインに依らないソケット操作 * typeには依る + stream socketとdgramソケットで送受信関数が別 === # Socket.AF ------------ * ソケットのアドレスファミリ関連 * 仕様では具体的なファミリを定義しない === # Socket.SOCK ------------- * ソケットにも種類がある + stream/diagram * さらにstreamにはactive/passiveがある * それらの型。 === # [INetSock](http://sml-family.org/Basis/inet-sock.html#INetSock:STR:SPEC) -------------- * IP - TCP/UDPのソケットを作る/操作するやつ。 * ここの関数はインターネットドメインソケットしか受け付けない === # Socketについて整理 ---------------- * sockにはtypeとafの属性がある * afは色々ある * typeはstreamとdgramがある * streamにはさらにactiveとpassiveがある * 特定のaf, 特定のtypeしか受け付けない関数がある === # Socketについて整理 ---------------- ``` (AF_UN) v [unix sock]... | (Active) [socket]-+ [TCP(stream)]-+ | | (Passive) [inet/inet6 sock]-+ ^ | (AF_INET/INET6) [UDP(dgram)] ``` === 幽霊型 === # Socketの幽霊型 --------------- ```sml type ('af,'sock_type) sock type 'af sock_addr type dgram type 'mode stream type passive type active ``` === # サーバのSocket操作(stream) --------------------------- * INetSock(UnixSock)でソケットを作る(af, sock typeの選択, プロセス側の準備) * bindでソケットをsock_addrにバインドする(アドレスの割り当て) * listenでソケットの特定のポートを開ける(TCPの開始) + passive streamしか受け付けない * acceptでクライアントからの入力を受け付ける(接続) + passive streamしか受け付けない + passive streamがactive streamになる + 一度acceptしたsockはlisten/accept出来ない === # データの送受信 --------------- * `send` / `recv` * それぞれArraySlice/VectorSliceの制御フラグ有り/無しがある + 実装がまあまあ面倒 === # SML# でのバインディング ------------------------ * sock - fd = int * sock_addr - AFによってサイズが違う。ヤバい。 + 任意のsock_addrを格納出来るsockaddr_storageを使う + Solarisだとsockaddr_unを格納出来ないらしい（任意のaddrを格納出来るとは） - SML#はSolarisでは動かないので問題ない。 * AF_* とか - Cではただのint。SML#は関数しかインポート出来ない。 + C側で定数関数でラップしてSML#で呼び出した値を束縛 * その他 - straitforward === # 非同期IO === # 非同期IO ---------- * HTTPサーバは複数のクライアントとのコネクションを持つ * それらのコネクションを要領良く扱わないといけない * 相手の処理速度や通信速度によって即座にデータを読み書き出来ない時がある + 勿論クライアント毎に状況が異なる * 読み書き出来ない時にやったらブロック(CPU時間の無駄遣い)する * 「読み書き出来るならする」/「読み書き出来るクライアントを選ぶ」APIが必要 === # 非同期API ---------- * select - 複数のクライアントを登録して、読み書き出来るやつを選ぶ * \\*NB - 読み書き出来るならやって、出来ないならブロックせずにリターンする * poll - selectと同じような（ちょっと速い）API。SocketではなくIOにある。 + pollがあるのに何故Socketにselectがあるの…。 === === # 非同期APIのFFI ---------------- * select - Cに対応する関数が。構造体の変換でメモリアロケーションが起きて遅い * \\*NB - O_NONBLOCKを付けたsend/recv。 * poll - SML#にある === # 非同期HTTPサーバ概略 --------------------- ```sml bind(sock, addr); listen(sock, port); create_thread(n, fn i = let val clientList = makeClientList() fun loop () = let val clientList = Option.map (acceptNB(sock)) (fn client = addReadClient clientList client) handle SysErr = ... val {rds, wds, exs} = select (makeSelectList clientList) in recvAndParseHTTPThenCallHandler clientList rds; sendResponse clientList wds; loop () end end) ``` === # Cバインディングの憂鬱 === # importとメモリ割り当て ----------------------- * SML#にはポインタかワードサイズ以下の値しか渡せない + stringとかはポインタからインポートする関数がある + インポートしたものはSML#のヒープに **コピーされる** * cでポインタを返すにはmallocが必要 * **すぐコピーされてfreeされるもののためにmalloc??** * SML#からコールバックを渡してCのスタックの変数をインポート * CF https://github.com/KeenS/SmlSharpSocketSupport/blob/master/lib/net_host_db.c#L74 === # メモリ管理 ------------ * SML#にインポート出来る型は限られている + array, string * 他の型はポインタのまま扱う。 * ポインタはGCされない * `sockaddr` は仕様的にファイナライザを持っていない + 現状 **メモリリークする** * SML#側でどうにかしてもらわないとダメ？ + パンドラの壷(sml_alloc)使う？ === # 型隠蔽 ------- * sockは本来はioDescに変換出来ないといけない + SML#でioDescはsockと同じくint * しかし型隠蔽のせいでintをioDescに変換出来ない * 手詰まり === # まとめ -------- * socketとかその辺を解説したよ * SML#向けにSocket関連Basisのバインディング作ってるよ * BasisのAPI使うと非同期HTTPサーバ作れるよ * SML#のFFIはやっぱりつらいよ   ","categories":["socket","SML","SMLSharp"],"category_urls":["/categories/socket","/categories/sml","/categories/smlsharp"],"date":"2016-07-02","title":"Socket on SML#","url":"https://KeenS.github.io/slide/socket_on_sml_/"},
  {"body":"κeenです。昔所有権/ミュータビリティを分割したくなったけどぱっと方法が思いつかなくて困ったことがあるので今更ながら備忘録として残しておきます。\nミュータビリティ 例えば、HTTPパーサを作ろうとしてるとしましょう。 受け取ったバイト列のバッファをパースしてヘッダやらボディやらのサブスライスを返します。この時、返り値のサブスライスはユーザへの自由を与えるために mut にしたいですよね。\nそう思ってこういうコードを書くと\nusestd::io;fn parse(buf: \u0026amp;mut[u8])-\u0026gt; io::Result\u0026lt;(\u0026amp;mut[u8],\u0026amp;mut[u8])\u0026gt;{...Ok((\u0026amp;mutbuf[hstart..hend],\u0026amp;mutbuf[bstart..bend]))} エラーになります。\nmutability_split.rs:4:31: 4:34error: cannotborrow`*buf`asmutablemorethanonceatatime[E0499]mutability_split.rs:4Ok((\u0026amp;mutbuf[hstart..hend],\u0026amp;mutbuf[bstart..bend]))... 普通にやろうとすると 1つ1つミュータブルなサブスライスを作ることになり、2つ目以降でborrow checkに引っ掛かってしまいます。2つのバッファがオーバーラップしてなくても。難儀ですね。コピーするくらいしかないのでしょうか。いいえ。rustはちゃんと助けになるAPIを用意してくれています。\nsplit_at_mut fn split_at_mut(\u0026amp;mutself,mid: usize)-\u0026gt; (\u0026amp;mut[T],\u0026amp;mut[T]) スライスを2つに分割してくれます。重要なのが、ミュータビリティも分割してくれるところです。返り値の2つ共に mut がついています。ということで、次のように実装出来ます。（実行してないので結果が正しいかは確認してませんが）\nfn parse(buf: \u0026amp;mut[u8])-\u0026gt; io::Result\u0026lt;(\u0026amp;mut[u8],\u0026amp;mut[u8])\u0026gt;{...let(h,b)=buf.split_at_mut(bstart);leth={let(_,h)=h.split_at_mut(hstart);let(_,h)=h.split_at_mut(hend-hstart);h};let(_,b)=b.split_at_mut(bend-bstart);Ok((h,b))} 所有権 似たような話で、構造体の所有権というか、貸与権(?)を分割したい時もあります。\nstruct PersonDB{name: String,age: usize,address: String,}fn use_immutable(s: \u0026amp;str){// empty }fn use_mutable(s: \u0026amp;mutstr){// empty }fn from_db(person: PersonDB){letname=\u0026amp;person.name;letmutaddress=\u0026amp;mutperson.address;use_immutable(name);use_mutable(address);} イミュータブルとミュータブル両方の借用があるのでエラーになってしまいます。実際は別のフィールドなので問題は起きないのですが、コンパイラに怒られます。理不尽ですね。\nmutability_split.rs:36:28: 36:42 error: cannot borrow immutable field `person.address` as mutable mutability_split.rs:36 let mut address = \u0026amp;mut person.address; ^~~~~~~~~~~~~~ そういう時は、パターンマッチによる分配束縛でクリア出来ます。\nfn from_db(person: PersonDB){letPersonDB{name,mutaddress,..}=person;use_immutable(\u0026amp;name);use_mutable(\u0026amp;mutaddress);} まとめ Rustの所有権やミュータブルな参照など、1つしか存在出来ないとされるものが分割出来ることを示しました。 地味に悩む所なので誰かの助けになれば幸いです。\n蛇足を足すと、本当は所有権の分割についても書く予定でしたがエラーになる筈のコードがあっさりコンパイルを通ってしまったのでナシになりました。コンパイラも進化してますね。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2016-06-19","title":"Rustの所有権/ミュータビリティの分割","url":"https://KeenS.github.io/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu/"},
  {"body":"κeenです。どうやらもうそろそろRustのツールチェーン管理はmultirustじゃなくてrustupを使った方が良さそうなので移行しようと思います。\nきっかけはmultirustにそういうコミットがされたから。\nもうmultirustじゃなくてrustup使え、と。\nUpdate README.md · brson/multirust@84c3459https://t.co/ySeRB50x5C\n\u0026mdash; κeen (@blackenedgold) 2016年6月10日 \n因みにrustupはrust-lang/rustup.sh: The rustup.sh script for installing Rust from release channelsではなくrust-lang-nursery/rustup.rs: The Rust toolchain installerの方です。インストールガイドなどはこちらから。rustup.rs - The Rust toolchain installer\nなんかベータ版のようですが推奨していいんですかね…。\nとりあえずmultirustを入れたままコマンドを叩いてみます。\n$ curl https://sh.rustup.rs -sSf | sh info: downloading installer warning: it looks like you have an existing installation of multirust warning: rustup cannot be installed alongside multirust warning: run `/usr/local/lib/rustlib/uninstall.sh` as root and delete `/home/kim/.multirust/version` before installing rustup error: cannot install while multirust is installed rustup: command failed: /tmp/tmp.9kjQj9WT5O/rustup-init ふーむ。アンインストールしろ、と。一応指示された通りmultirust自体はアンインストールせずにversionだけを削除します。\n$ sudo /usr/local/lib/rustlib/uninstall.sh install: uninstalling component \u0026#39;multirust\u0026#39; multirust is uninstalled. $ rm -rf ~/.multirust/version もう一度。\n$ curl https://sh.rustup.rs -sSf | sh info: downloading installer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. It will add the cargo, rustc, rustup and other commands to Cargo\u0026#39;s bin directory, located at: /home/kim/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile file located at: /home/kim/.profile You can uninstall at any time with rustup self uninstall and these changes will be reverted. WARNING: This is beta software. Current installation options: default toolchain: stable modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation 選択肢が出ました。とりあえず1を選択します。\nerror: toolchain \u0026#39;stable\u0026#39; is not installed info: caused by: not a directory: \u0026#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu\u0026#39; rustup: command failed: /tmp/tmp.nugK4VN4p8/rustup-init えー。ちょっと…。仕方ないのでシンボリックリンクを貼って騙してみます。\n$ ls ~/.multirust/toolchains/ beta nightly stable $ ln -s ~/.multirust/toolchains/{stable,stable-x86_64-unknown-linux-gnu} 3度目の正直なるか\n$ curl https://sh.rustup.rs -sSf | sh info: downloading installer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. It will add the cargo, rustc, rustup and other commands to Cargo\u0026#39;s bin directory, located at: /home/kim/.cargo/bin This path will then be added to your PATH environment variable by modifying the profile file located at: /home/kim/.profile You can uninstall at any time with rustup self uninstall and these changes will be reverted. WARNING: This is beta software. Current installation options: default toolchain: stable modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation 1 info: updating existing rustup installation Rust is installed now. Great! To get started you need Cargo\u0026#39;s bin directory in your PATH environment variable. Next time you log in this will be done automatically. To configure your current shell run source $HOME/.cargo/env. インストール出来たよう。しかしセットアップは ~/.profile に書かれたようなので .zshrc は自分で更新します。\ndiff --git a/zshrc b/zshrc index 0178873..589c6a5 100644 --- a/zshrc +++ b/zshrc @@ -213,7 +213,7 @@ export PATSHOME=~/compile/ATS2-Postiats-$ATS_VERSION/  export PATH=$PATSHOME/bin:$PATH export PATSHOMERELOC=~/compile/ATS2-Postiats-contrib-$ATS_VERSION -export PATH=$PATH:~/.multirust/toolchains/stable/cargo/bin +export PATH=\u0026#34;$HOME/.cargo/bin:$PATH\u0026#34;  # OPAM configuration . /home/kim/.opam/opam-init/init.sh \u0026gt; /dev/null 2\u0026gt; /dev/null || true  使ってみます。\nrustup 0.1.12 (c6e430a 2016-05-12) The Rust toolchain installer USAGE: rustup [FLAGS] [SUBCOMMAND] FLAGS: -v, --verbose Enable verbose output -h, --help Prints help information -V, --version Prints version information SUBCOMMANDS: show Show the active and installed toolchains update Update Rust toolchains default Set the default toolchain toolchain Modify or query the installed toolchains target Modify a toolchain\u0026#39;s supported targets override Modify directory toolchain overrides run Run a command with an environment configured for a given toolchain which Display which binary will be run for a given command doc Open the documentation for the current toolchain. self Modify the rustup installation telemetry rustup telemetry commands help Prints this message or the help of the given subcommand(s) rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between stable, beta, and nightly compilers and keep them updated. It makes cross-compiling simpler with binary builds of the standard library for common platforms. If you are new to Rust consider running `rustup doc --book` to learn Rust. multirustを使っていたら馴染めそうですね。\n一応どこにインストールされたのか確認。\n$ which rustc /home/kim/.cargo/bin/rustc ふむふむ。ちょいとアップデートしてみます。\n$ rustup update info: syncing channel updates for \u0026#39;stable-x86_64-unknown-linux-gnu\u0026#39; info: downloading component \u0026#39;rustc\u0026#39; 43.2 MiB / 43.2 MiB (100 %) 2.1 MiB/s ETA: 0 s info: downloading component \u0026#39;rust-std\u0026#39; 55.3 MiB / 55.3 MiB (100 %) 3.0 MiB/s ETA: 0 s info: downloading component \u0026#39;rust-docs\u0026#39; 6.4 MiB / 6.4 MiB (100 %) 2.9 MiB/s ETA: 0 s info: downloading component \u0026#39;cargo\u0026#39; 4.1 MiB / 4.1 MiB (100 %) 2.3 MiB/s ETA: 0 s info: rolling back changes error: could not read component file: \u0026#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-\u0026#39; info: syncing channel updates for \u0026#39;stable-x86_64-unknown-linux-gnu\u0026#39; info: downloading component \u0026#39;rustc\u0026#39; 43.2 MiB / 43.2 MiB (100 %) 953.6 KiB/s ETA: 0 s info: downloading component \u0026#39;rust-std\u0026#39; 55.3 MiB / 55.3 MiB (100 %) 1.8 MiB/s ETA: 0 s info: downloading component \u0026#39;rust-docs\u0026#39; 6.4 MiB / 6.4 MiB (100 %) 2.2 MiB/s ETA: 0 s info: downloading component \u0026#39;cargo\u0026#39; 4.1 MiB / 4.1 MiB (100 %) 1.5 MiB/s ETA: 0 s info: rolling back changes error: could not read component file: \u0026#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-\u0026#39; info: syncing channel updates for \u0026#39;beta-x86_64-unknown-linux-gnu\u0026#39; info: downloading component \u0026#39;rustc\u0026#39; 44.8 MiB / 44.8 MiB (100 %) 1.4 MiB/s ETA: 0 s info: downloading component \u0026#39;rust-std\u0026#39; 57.9 MiB / 57.9 MiB (100 %) 2.9 MiB/s ETA: 0 s info: downloading component \u0026#39;rust-docs\u0026#39; 7.0 MiB / 7.0 MiB (100 %) 1.8 MiB/s ETA: 0 s info: downloading component \u0026#39;cargo\u0026#39; 4.1 MiB / 4.1 MiB (100 %) 1.3 MiB/s ETA: 0 s info: installing component \u0026#39;rustc\u0026#39; info: installing component \u0026#39;rust-std\u0026#39; info: installing component \u0026#39;rust-docs\u0026#39; info: installing component \u0026#39;cargo\u0026#39; info: syncing channel updates for \u0026#39;nightly-x86_64-unknown-linux-gnu\u0026#39; info: downloading component \u0026#39;rustc\u0026#39; 46.5 MiB / 46.5 MiB (100 %) 924.8 KiB/s ETA: 0 s info: downloading component \u0026#39;rust-std\u0026#39; 59.0 MiB / 59.0 MiB (100 %) 2.4 MiB/s ETA: 0 s info: downloading component \u0026#39;rust-docs\u0026#39; 7.3 MiB / 7.3 MiB (100 %) 1.8 MiB/s ETA: 0 s info: downloading component \u0026#39;cargo\u0026#39; 4.1 MiB / 4.1 MiB (100 %) 3.2 MiB/s ETA: 0 s info: installing component \u0026#39;rustc\u0026#39; info: installing component \u0026#39;rust-std\u0026#39; info: installing component \u0026#39;rust-docs\u0026#39; info: installing component \u0026#39;cargo\u0026#39; info: checking for self-updates info: rustup is up to date stable update failed - rustc 1.9.0 (e4e8b6668 2016-05-18) stable-x86_64-unknown-linux-gnu update failed - rustc 1.9.0 (e4e8b6668 2016-05-18) beta installed - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26) nightly installed - rustc 1.11.0-nightly (0554abac6 2016-06-10) あれ、なんかコケてる…。シンボリックリンクが悪さしたかな…。しかし試しに手元のプロダクトをコンパイルしてみたら通ったので使えているよう。\nさて、クロスコンパイルの方はどうでしょうか。以前Raspberry Pi向けにクロスコンパイルしました RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog。これは動くでしょうか。\nとりあえずインストール可能なターゲットを確認\n$ rustup target list error: toolchain \u0026#39;stable-x86_64-unknown-linux-gnu\u0026#39; does not support components …………。無理矢理addしてみます。\n$ rustup target add nightly-arm-unknown-linux-gnueabihf error: toolchain \u0026#39;stable-x86_64-unknown-linux-gnu\u0026#39; does not support components …………………………………。\nなんか変ですね。\n一旦\n$ rm ~/.multirust/toolchains/stable-x86_64-unknown-linux-gnu してもう一度 rustup update します。\n$ rustup update info: syncing channel updates for \u0026#39;stable-x86_64-unknown-linux-gnu\u0026#39; info: downloading component \u0026#39;rustc\u0026#39; 43.2 MiB / 43.2 MiB (100 %) 2.6 MiB/s ETA: 0 s info: downloading component \u0026#39;rust-std\u0026#39; 55.3 MiB / 55.3 MiB (100 %) 3.7 MiB/s ETA: 0 s info: downloading component \u0026#39;rust-docs\u0026#39; 6.4 MiB / 6.4 MiB (100 %) 5.0 MiB/s ETA: 0 s info: downloading component \u0026#39;cargo\u0026#39; info: installing component \u0026#39;rustc\u0026#39; info: installing component \u0026#39;rust-std\u0026#39; info: installing component \u0026#39;rust-docs\u0026#39; info: installing component \u0026#39;cargo\u0026#39; info: syncing channel updates for \u0026#39;beta-x86_64-unknown-linux-gnu\u0026#39; info: syncing channel updates for \u0026#39;beta-x86_64-unknown-linux-gnu\u0026#39; info: syncing channel updates for \u0026#39;nightly-x86_64-unknown-linux-gnu\u0026#39; info: syncing channel updates for \u0026#39;nightly-x86_64-unknown-linux-gnu\u0026#39; info: checking for self-updates info: rustup is up to date stable installed - rustc 1.9.0 (e4e8b6668 2016-05-18) beta unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26) beta-x86_64-unknown-linux-gnu unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26) nightly unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10) nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10) あれ、今回は上手くいった。やっぱりシンボリックリンクが悪かったよう。リトライ。\n$ rustup target list aarch64-apple-ios aarch64-unknown-linux-gnu arm-linux-androideabi arm-unknown-linux-gnueabi arm-unknown-linux-gnueabihf armv7-apple-ios armv7-unknown-linux-gnueabihf armv7s-apple-ios i386-apple-ios i586-pc-windows-msvc i586-unknown-linux-gnu i686-apple-darwin i686-pc-windows-gnu i686-pc-windows-msvc i686-unknown-freebsd i686-unknown-linux-gnu i686-unknown-linux-musl mips-unknown-linux-gnu mips-unknown-linux-musl mipsel-unknown-linux-gnu mipsel-unknown-linux-musl powerpc-unknown-linux-gnu powerpc64-unknown-linux-gnu powerpc64le-unknown-linux-gnu x86_64-apple-darwin x86_64-apple-ios x86_64-pc-windows-gnu x86_64-pc-windows-msvc x86_64-rumprun-netbsd x86_64-unknown-freebsd x86_64-unknown-linux-gnu (default) x86_64-unknown-linux-musl x86_64-unknown-netbsd $ rustup target add --toolchain nightly arm-unknown-linux-gnueabihf info: downloading component \u0026#39;rust-std\u0026#39; for \u0026#39;arm-unknown-linux-gnueabihf\u0026#39; 62.6 MiB / 62.6 MiB (100 %) 1.4 MiB/s ETA: 0 s info: installing component \u0026#39;rust-std\u0026#39; for \u0026#39;arm-unknown-linux-gnueabihf\u0026#39; んー、ちゃんとnightlyが入ったのか分からない。\n$ rustup show installed toolchains -------------------- stable stable-x86_64-unknown-linux-gnu (default) beta beta-x86_64-unknown-linux-gnu nightly nightly-x86_64-unknown-linux-gnu active toolchain ---------------- stable-x86_64-unknown-linux-gnu (default) rustc 1.9.0 (e4e8b6668 2016-05-18) しかし件のARM向けプロジェクトのクロスコンパイルは出来たよう。\nもう一度listを見る。\n$ rustup target list aarch64-apple-ios aarch64-linux-android aarch64-unknown-linux-gnu arm-linux-androideabi arm-unknown-linux-gnueabi arm-unknown-linux-gnueabihf (installed) armv7-apple-ios armv7-unknown-linux-gnueabihf armv7s-apple-ios i386-apple-ios i586-pc-windows-msvc i586-unknown-linux-gnu i686-apple-darwin i686-linux-android i686-pc-windows-gnu i686-pc-windows-msvc i686-unknown-freebsd i686-unknown-linux-gnu i686-unknown-linux-musl mips-unknown-linux-gnu mips-unknown-linux-musl mipsel-unknown-linux-gnu mipsel-unknown-linux-musl powerpc-unknown-linux-gnu powerpc64-unknown-linux-gnu powerpc64le-unknown-linux-gnu x86_64-apple-darwin x86_64-apple-ios x86_64-pc-windows-gnu x86_64-pc-windows-msvc x86_64-rumprun-netbsd x86_64-unknown-freebsd x86_64-unknown-linux-gnu (default) x86_64-unknown-linux-musl x86_64-unknown-netbsd arm-unknown-linux-gnueabihf (installed) とあるのでインストール出来ているよう。しかし本当にnightlyなのか。\nrustup target list --toolchain stable aarch64-apple-ios aarch64-unknown-linux-gnu arm-linux-androideabi arm-unknown-linux-gnueabi arm-unknown-linux-gnueabihf armv7-apple-ios armv7-unknown-linux-gnueabihf armv7s-apple-ios i386-apple-ios i586-pc-windows-msvc i586-unknown-linux-gnu i686-apple-darwin i686-pc-windows-gnu i686-pc-windows-msvc i686-unknown-freebsd i686-unknown-linux-gnu i686-unknown-linux-musl mips-unknown-linux-gnu mips-unknown-linux-musl mipsel-unknown-linux-gnu mipsel-unknown-linux-musl powerpc-unknown-linux-gnu powerpc64-unknown-linux-gnu powerpc64le-unknown-linux-gnu x86_64-apple-darwin x86_64-apple-ios x86_64-pc-windows-gnu x86_64-pc-windows-msvc x86_64-rumprun-netbsd x86_64-unknown-freebsd x86_64-unknown-linux-gnu (default) x86_64-unknown-linux-musl x86_64-unknown-netbsd $ rustup target list --toolchain nightly aarch64-apple-ios aarch64-linux-android aarch64-unknown-linux-gnu arm-linux-androideabi arm-unknown-linux-gnueabi arm-unknown-linux-gnueabihf (installed) armv7-apple-ios armv7-unknown-linux-gnueabihf armv7s-apple-ios i386-apple-ios i586-pc-windows-msvc i586-unknown-linux-gnu i686-apple-darwin i686-linux-android i686-pc-windows-gnu i686-pc-windows-msvc i686-unknown-freebsd i686-unknown-linux-gnu i686-unknown-linux-musl mips-unknown-linux-gnu mips-unknown-linux-musl mipsel-unknown-linux-gnu mipsel-unknown-linux-musl powerpc-unknown-linux-gnu powerpc64-unknown-linux-gnu powerpc64le-unknown-linux-gnu x86_64-apple-darwin x86_64-apple-ios x86_64-pc-windows-gnu x86_64-pc-windows-msvc x86_64-rumprun-netbsd x86_64-unknown-freebsd x86_64-unknown-linux-gnu (default) x86_64-unknown-linux-musl x86_64-unknown-netbsd どうやら本当にnightlyのよう。\nまとめ 色々あたふたとしましたがrustupをインストールして使ってみました。multirustを使っているとインストールあたりでやや難はありそうですがそれ以降は普通に使えそうです。\n皆様もお試しあれ。\n","categories":["RUST","rustup"],"category_urls":["/categories/rust","/categories/rustup"],"date":"2016-06-12","title":"multirustが非推奨になったようなのでrustupに移行する","url":"https://KeenS.github.io/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru/"},
  {"body":"# DOT/dottyについて調べてみた ---------------------- サイバーエージェント Scala Meet Up 2016-05-27 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 基盤開発グループ + Lisp, ML, Rust, Shell Scriptあたりを書きます + Scala初心者 + Scala歴1年未満\u0026gt;\u0026lt; === # Scalaコンパイラ ---------------- * 型推論（特にimplicit）が遅い * コンパイルフェーズが多い + 中間オブジェクトが多くて遅くなる * 多くのクラスファイルを生成する + コンパイラのくせにディスクIOが多い * 気を抜いてると `Any` に推論される e.g.) `if(x) 1 else \"a\"` * そもそものScalaの設計に起因する点が多い + 抜本的変更が必要 === # Scala基礎 ----------- * Scalaが成立するのに最低限必要な機能って？ + e.g.) `case class` はなくても `class` だけでどうにかなる * 「最低限の機能」を減らせばコンパイラがシンプルになる + 他の機能はただのシンタックスシュガーになる + コンパイラのバグを減らせる + 機能追加時の矛盾確認が楽 * コア言語 === # Featherlight Scala --------------------- * Scalaのシンタックスシュガーを減らした感じ * 小さな言語 * 元のScalaはこれをベースに議論されてきた === # 形式言語理論 ------------- * 最低限必要な機能を形式的にモデル化 + 全ての動作は予め決められた「規則」に基く + 実際に書いて動かすものではない * 形式的にすることで「証明」とかが出来る + 「型検査に通れば実行時に型エラーが起きない」 + 「型検査が必ず終了する」 * 逆に、「このモデルだとこの機能は実現出来ない」とかも分かる === # Dependent Object Type ------ * Scalaのコアをモデル化したもの（要出典） * 形式言語 * ジェネリクスもなければクラスも継承もない、パッケージもない。 * 小さい言語ながら表現力豊か * 全ての値はオブジェクト。 + オブジェクトのフィールドとメソッドと型メンバーだけ + 型はそのまま * Path Dependent Type * サブタイピング === # About DOT --------- * 型付の健全性が証明された * System FSystem DDOT * existential typeを自然に表現出来る * 交差型と合併型 + `A extends B` - `A \u0026 B` + 合併型は主に型推論の結果に出てくる === ```scala package scala.collection.immutable trait List[+A] { def isEmpty: Boolean; def head: A; def tail: List[A] } object List { def nil: List[Nothing] = new List[Nothing] { def isEmpty = true; def head = head; def tail = tail /* infinite loops */ } def cons[A](hd: A, tl: List[A]) = new List[A] { def isEmpty = false; def head = hd; def tail = tl } } ``` === ```scala object scala_collection_immutable { sci = trait List { self = type A def isEmpty: Boolean def head: self.A def tail: List{type A type A = Nothing def isEmpty = true def head: A = self.head def tail: List{type A = Nothing} = self.tail } def cons(x: {type A})(hd: x.A)(tl: sci.List{type A type A = x.A def isEmpty = false def head = hd def tail = tl } } ``` === # dotty -------- * DOTに影響を受けたコンパイラ * いくつかの新しい機能 + DOTの交差型、合併型も + Nullable = `T | Null` + `if (x) 1 else \"a\"` は `Int | String` にアノテーション可能 * `forSome` が消えた + DOTのお陰 === # dotty -------- * Java8のラムダを使う + 生成するclassファイルの減少 * Implicitの探索アルゴリズムを改善 + 反変implicitについても改善 * 型推論のアルゴリズムを改善 + DOTのお陰 + 特にサブタイピングが交差/合併型で楽に * コンパイルパスを融合して高速化 + 中間木がなくなってGCにやさしい * 他にも一杯改善が === ```scala object DaysOfTheWeek{ object Mon object Tue object Wed object Thu object Fri object Sat object Sun type Weekend = Sat.type | Sun.type type Workweek = Mon.type | Tue.type | Wed.type | Thu.type | Fri.type type All = Weekend | Workweek } ``` === # TASTY/Linker -------------- * classファイルを作るとScala固有の情報が落ちる * プログラム全体を見渡すと不要なコードとかもコンパイルしないといけない * かといって毎回プログラム全部をコンパイルし直すのは遅い * → TASTY。型推論後のASTをシリアライズする + Scalaは型推論が遅いのでそこをスキップ出来るだけでそこそこ速くなる * classファイルを跨げるようになったのでユーザが最適化とかも書ける * Scala/Scala.js/Scala Native共通プラットフォーム化への布石？ * どうやらclassファイルにバイトコードとTASTYを埋め込む?? === # まとめ -------- * Scalaの基礎にDOTがあるよ * DOTを参考にdottyが作られたよ * dottyで色々改善されるよ * ついでにTASTY/Linkerについて話したよ === # 参考1 ------ * [The Essence of Dependent Object Types](https://infoscience.epfl.ch/record/215280/files/paper_1.pdf) * [From F to DOT: Type Soundness Proofs with Definitional Interpreters](http://arxiv.org/pdf/1510.05216v2.pdf) * [Dependent Object Types](http://www.cs.uwm.edu/~boyland/fool2012/papers/fool2012_submission_3.pdf) * [Why is the Scala compiler so slow? - Quora](https://www.quora.com/Why-is-the-Scala-compiler-so-slow) * [performance - Java compile speed vs Scala compile speed - Stack Overflow](http://stackoverflow.com/questions/3490383/java-compile-speed-vs-scala-compile-speed/3612212#3612212) === # 参考2 ------- * [GHC doesn't do subtyping. I suspect that is the main reason why Scala is slow - ... | Hacker News](https://news.ycombinator.com/item?id=5008761) * [A Core Calculus for Scala Type Checking](http://lampwww.epfl.ch/~odersky/papers/mfcs06.pdf) * [namin/dot: formalization of the Dependent Object Types (DOT) calculus](https://github.com/namin/dot) * [The DOT Calculus](http://lampwww.epfl.ch/%7Eamin/dot/current_rules.pdf) * [Dotty: exploring the future of scala](https://d-d.me/talks/scalaworld2015/) * [Dotty and types: the story so far](http://guillaume.martres.me/talks/typelevel-summit-oslo/)   ","categories":["Scala","言語処理系","社内","Scala Meet Up"],"category_urls":["/categories/scala","/categories/%e8%a8%80%e8%aa%9e%e5%87%a6%e7%90%86%e7%b3%bb","/categories/%e7%a4%be%e5%86%85","/categories/scala-meet-up"],"date":"2016-05-24","title":"DOT/dottyについて調べてみた","url":"https://KeenS.github.io/slide/dot_dottynitsuiteshirabetemita/"},
  {"body":"κeenです。先日Rustのニュースに流れてきたcargo profilerを試してみます。 元の紹介記事はこちらIntroducing Cargo Profiler · suchin。\nGitHubレポジトリはこちらpegasos1/cargo-profiler: cargo subcommand to profile binaries。\nProfilerとはいっても自身でプロファイラを持っている訳ではなくて外部のプロファイラ（現状valgrind）を呼び出して整形してくれるツールのようです。 Rust向けに関数をモジュールパス付きで表示してくれたりするのでRustから使うにはvalgrind生より便利そうです。\nインストール READMEに従って\n$ sudo apt install valgrind $ cargo install cargo-profiler とします。\nプロジェクトの準備 適当なものがないので手元の[κLisp]()でフィボナッチ数列を動かしてみます。(と思ったらκLispに比較演算子がなかったのでそれを作るところから始まりましたがそれはまた別の話)。\nmain.rsはこんな感じ。\nexterncratekappa_lisp;usekappa_lisp::kappa_lisp::{run,init};usekappa_lisp::env::Env;fn main(){letmutenv=Env::new();init(\u0026amp;mutenv).unwrap();run(\u0026amp;mutenv,r\u0026#34; (defun fib (n) (if (\u0026lt; n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))) \u0026#34;).unwrap();letexpr=run(\u0026amp;mutenv,r\u0026#34; (fib 20) \u0026#34;).unwrap();println!(\u0026#34;{}\u0026#34;,expr);} 割と遅いので20くらいで限界でした。\nさて、これを\ncargo build --release としてビルドします。\nプロファイル 今のところcallgrindとcachegrindが実装されているようです。1つづづ試してみます。\ncallgrind よく分かってないのですが多分実行時間に占める関数毎の割合を出してくれるんですかね。-nで上位何件を表示するか指定出来ます。\nとりあえず上位10件出してみましょう。\n$ cargo profiler callgrind --bin ./target/release/kappa_lisp -n 10 Profiling kappa_lisp with callgrind... Total Instructions...571,437,255 142,527,726 (24.9%) ???:collections::hash::table::make_hash ----------------------------------------------------------------------- 107,551,309 (18.8%) ???:hash::sip::SipHasher.Hasher::write ----------------------------------------------------------------------- 39,749,571 (7.0%) ???:collections::hash::map::HashMap..K$C$..V$C$..S..::get ----------------------------------------------------------------------- 38,693,006 (6.8%) ???:sdallocx ----------------------------------------------------------------------- 37,670,732 (6.6%) ???:mallocx ----------------------------------------------------------------------- 34,608,049 (6.1%) ???:expr..Expr::drop.9629 ----------------------------------------------------------------------- 26,539,906 (4.6%) ???:eval::eval ----------------------------------------------------------------------- 19,887,024 (3.5%) ???:util::f_foldr ----------------------------------------------------------------------- 16,634,175 (2.9%) ???:eval::feval ----------------------------------------------------------------------- 14,353,992 (2.5%) ???:util::kcons ----------------------------------------------------------------------- はい、こんな感じです。ハッシュテーブル関連が時間喰ってますね。これは関数呼び出しの度に行われてます。 ちょっと実装が雑すぎるので直さなきゃ…。\ncachegrind キャッシュミスを表示してくれます。本気出してチューニングする時に必要ですね。\n同じく -nで件数を絞り込めます。\ncargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10 Profiling kappa_lisp with cachegrind... Total Memory Accesses...800,070,388\tTotal L1 I-Cache Misses...100,068 (0%)\tTotal LL I-Cache Misses...422 (0%)\tTotal L1 D-Cache Misses...4,346,335 (0%)\tTotal LL D-Cache Misses...7,724 (0%)\tIr I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash ----------------------------------------------------------------------- 0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write ----------------------------------------------------------------------- 0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629 ----------------------------------------------------------------------- 0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get ----------------------------------------------------------------------- 0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx ----------------------------------------------------------------------- 0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx ----------------------------------------------------------------------- 0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval ----------------------------------------------------------------------- 0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr ----------------------------------------------------------------------- 0.03 0.02 0.05 0.04 0.05 0.00 0.02 0.06 0.05 ???:eval::feval ----------------------------------------------------------------------- 0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons ----------------------------------------------------------------------- やはりハッシュテーブルが酷いですが同じコードを繰り返し実行するタイプのマイクロベンチマークなのでキャッシュミスは少ないです。\n因みにそれぞれの列はこういう意味だそうです。\n Ir -\u0026gt; Total Instructions I1mr -\u0026gt; Level 1 I-Cache misses ILmr -\u0026gt; Last Level I-Cache misses Dr -\u0026gt; Total Memory Reads D1mr -\u0026gt; Level 1 D-Cache read misses DLmr -\u0026gt; Last Level D-cache read misses Dw -\u0026gt; Total Memory Writes D1mw -\u0026gt; Level 1 D-Cache write misses DLmw -\u0026gt; Last Level D-cache write misses  --sort オプションでどの列をみるのか指定出来るようです。全メモリアクセスのミスレートを見てみましょうか。\n$ cargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10 --sort dr Profiling kappa_lisp with cachegrind... Total Memory Accesses...800,082,686\tTotal L1 I-Cache Misses...100,083 (0%)\tTotal LL I-Cache Misses...420 (0%)\tTotal L1 D-Cache Misses...4,321,895 (0%)\tTotal LL D-Cache Misses...7,721 (0%)\tIr I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write ----------------------------------------------------------------------- 0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629 ----------------------------------------------------------------------- 0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx ----------------------------------------------------------------------- 0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get ----------------------------------------------------------------------- 0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash ----------------------------------------------------------------------- 0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx ----------------------------------------------------------------------- 0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval ----------------------------------------------------------------------- 0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr ----------------------------------------------------------------------- 0.03 0.02 0.05 0.04 0.04 0.00 0.02 0.06 0.05 ???:eval::feval ----------------------------------------------------------------------- 0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons ----------------------------------------------------------------------- やっぱりハッシュテーブル関連が重い…。\nまとめ 私にとっては薮蛇にκLispの実装の筋が悪いことが分かったりしてショックでしたがまあ、簡単にプロファイルをとれるツールを紹介しました。\nRustで高速なアプリケーションを作りたい方、利用してみては如何でしょうか。\n","categories":["Rust","Cargo"],"category_urls":["/categories/rust","/categories/cargo"],"date":"2016-05-14","title":"cargo-profilerを試す","url":"https://KeenS.github.io/blog/2016/05/14/cargo_profilerwotamesu/"},
  {"body":"# 高速な継続ライブラリに向けて ---------------------- [継続勉強会](http://connpass.com/event/28150/) 2016-05-22 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバーエージェントのエンジニア + Lisp, ML, Rust, Shell Scriptあたりを書きます === # 継続欲しい ----------- * 色々な場面で便利 * Schemeで使い回してるのうらやましい * Common Lispでも使いたい * 現実には限定継続が欲しい + Common Lispには大域脱出はある === # 限定継続を使う例 ----------------- ## 非同期プログラミング * コールバック形式だと厳しい * 限定継続を使うと綺麗に書き直せる === # 限定継続を使う例 ----------------- ## ゲームのコルーチン * 複数のオブジェクトを制御するのにコルーチンが欲しい * cf [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590) === # 限定継続を使う例 ----------------- ## do記法 * モナドのdo記法は限定継続を使って実装出来る * [Operational monad in scheme](http://www.slideshare.net/yuichinishiwaki/operational-monad-in-scheme) === # Common Lispでの限定継続の実現 --------------- 1. 仕様に入れてもらう 2. 処理系に手を入れる 3. ユーザレベルで(限定)継続ライブラリを作る + 柔軟なCommon Lispでは可能 === # CPS変換 --------- * (限定)継続の実現方法の1つ + スタックを切り取る方式とかもある * 機械的にも出来る * グローバルな変換なのとプリミティブな式しか書けないでコンパイラ内部でやることが多い + 継続関係なしに中間形式として採用されることが多い * 関数定義/呼び出し以外にも諸々の構文とかに対しても定義が必要 === # CPS変換 ---------- Q. Common Lispだといくつの構文に対して定義が必要? 1. 1つ 2. 26つ 3. 42つ 4. 無数 === # CPS変換 ---------- A. 26つ (スペシャルフォーム25+funcall) === # Common Lispのプリミティブ -------------------------- * スペシャルフォームと呼ばれる * 仕様で25個定められている * [CLHS: Section 3.1.2.1.2.1](http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm) * この中に関数定義だとか例外だとかは入っていない + マクロで定義されている === # マクロ -------- * 構文木 to 構文木(S式to S式)変換器( = 普通のLispの関数) * 新しい構文を作れる * CPS変換は????? === # `macroexpand` ------------- * [CLHS: Function MACROEXPAND, MACROEXPAND-1](http://clhs.lisp.se/Body/f_mexp_.htm) * マクロを手動展開する関数 * 雑にいうと普段pre-orderなマクロ展開をin-orderやpost-orderにする時に使う * 本来はあまり使いたくない + 処理系の展開器に任せた方が間違いが少ない * これでマクロを排したプリミティブのCommon Lispの構文木にアクセス出来る === # cl-cont --------- * 上記のことを全てやったライブラリ * デファクトというか唯一のライブラリ * [Common Lispで限定継続と遊ぶ | κeenのHappy Hacκing Blog](http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/) === 「shift/resetがわからない時にあげる声」\n\u0026mdash; かず(原材料に小麦粉を含む) (@kazzna) 2015年12月8日 === # cl-contの使用例 ``` common-lisp (with-call/cc (+ 1 (call/cc (lambda (k) (funcall k 2))))) ``` === # cl-contの使用例 ``` common-lisp (FUNCALL (LAMBDA (\u0026OPTIONAL #:G542 \u0026REST #:G543) (DECLARE (IGNORABLE #:G542)) (DECLARE (IGNORE #:G543)) (FUNCALL (LAMBDA (\u0026OPTIONAL #:G544 \u0026REST #:G545) (DECLARE (IGNORABLE #:G544)) (DECLARE (IGNORE #:G545)) (FUNCALL (LAMBDA (K) (FUNCALL K 1)) (LAMBDA (\u0026OPTIONAL #:G546 \u0026REST #:G547) (DECLARE (IGNORABLE #:G546)) (DECLARE (IGNORE #:G547)) (FUNCALL (CL-CONT::FDESIGNATOR-TO-FUNCTION/CC #:G542) #'VALUES #:G544 #:G546)))) 1)) #'+) ``` === # cl-contへの不満 ----------------- * 遅い * lambda多い。 + 多分コンパイラと相性が悪い * lambda禁止おじさんと分かりあえる === # cl-fast-cont === # cl-fast-cont -------------- * [KeenS/cl-fast-cont: faster partial contiuation library of common lisp](https://github.com/KeenS/cl-fast-cont) * とりあえずレポジトリ作っただけ * 完成させたい… === # アプローチ1 === # SSA使う --------- * CPSと等価 * だけどSSAだったらlambda出てこない * Common Lispならgotoあるしいけるんじゃね？ === ```common-lisp (let (x y z) (tagbody (setq x 1) :call/cc (setq y 1) (setq z (+ x y)))) ``` === # 問題 ------- * ネイティブスタックとは別に自分でスタック作らないといけない + 例外とかでスタック巻き戻されるとつらい * gotoのタグをtagbodyの外に持ち出せない(=継続を外に持ち出せない) * 変数を準備するのが面倒orパフォーマンスに影響しそう * そもそもtagbodyそこまで柔軟じゃなかった * 関数が消し飛ぶ === # アプローチ2 === # SSA+CPS --------- * SSAとCPSを組み合わせる * 基本はSSA * スタックを使う/継続が必要な所でだけCPS === # 問題 ------- * SSAの部分意味なくね？ * そもそも継続を取り出すのが目的なので関係ない所で変換しても意味がない === # アプローチ3 === # Selective CPS ---------------- * 継続が必要な部分でのみ変換 * 2 pass transformation * [A Selective CPS Transformation](http://www.sciencedirect.com/science/article/pii/S1571066104809691) === ```common-lisp (with-call/cc (let ((x 3) y) (setq y (* x x)) (+ 1 (call/cc (lambda (k) (funcall k y)))))) ``` === ```common-lisp (with-call/cc (let ((x 3) y) (setq y (* x x)) (+ 1 @(call/cc (lambda (k) (funcall k y)))))) ``` === ```common-lisp (with-call/cc (let ((x 3) y) (setq y (* x x)) @(+ 1 @(call/cc (lambda (k) (funcall k y)))))) ``` === ```common-lisp (with-call/cc @(let ((x 3) y) (setq y (* x x)) @(+ 1 @(call/cc (lambda (k) (funcall k y)))))) ``` === # そもそもCommon Lispのつらい話 ------------------------------- * セマンティクスが動的 + catch, block, tagbody + special variable + 変換は静的なのでどう頑張っても追い付かない * multiple valueが面倒 === # ダイナミック!! ---------------- ``` common-lisp (block name (let ((f (lambda (x) (return-from name x)))) (with-call/cc (funcall f (call/cc (lambda (k) (funcall k 2))))))) ``` === # スペシャル変数 --------------- * Common Lispにはレキシカルスコープとダイナミックスコープ両方ある * CPS変換すると継続の全てがスコープ下に入る + 関数の呼び出し関係が木だったのが線型になる + ダイナミックスコープだと困る === ![CPS前のAST](/images/cps/pre-cps.png) === ![CPS後のAST](/images/cps/post-cps.png) === ``` (defvar *x* 1) (with-call/cc (progn (let ((*x* 2)) (call/cc ..) (format t \"~a~%\" *x*)) ; *x* = 2 (format t \"~a~%\" *x*))) ; *x* = 1 ``` === ``` (defvar *x* 1) (with-call/cc (progn (let ((*x* 2)) (... (lambda (ignore) ((lambda (ignore) (format t \"~a~%\" *x*)) ; *x* = 2!! (format t \"~a~%\" *x*))))))) ; *x* = 1 ``` === # 多値 ------ * Common Lispの多値はGoと違って無視出来る * 変換が空気読む必要がある * 下手するとプログラムを壊す 1. 本当は多値を返してるのに変換で無視された 2. 意図的に無視してるのに変換で加えられた === # 関数定義と引数の数 ----------------- * **Selective** CPS * 関数をCPS変換するときとしない時がある * 呼び出す時にどっちか分かんなくね？ 1. 統一的に変換してしまう 2. Selectiveに変換して関数にメタデータつける - まだ決めきれてない === # パフォーマンス ---------------- === # フィボナッチ数列 ----------------- * とりえあずのフィボナッチ数列で計測 + Full CPS変換に割と不利 + 何も考えずにライブラリを使うとこうなるよって例 * Selective CPSは何もしない=普通の定義と同じ === ```common-lisp (defun fib (n) (if ( ","categories":["継続","限定継続","Lisp","Common Lisp"],"category_urls":["/categories/%e7%b6%99%e7%b6%9a","/categories/%e9%99%90%e5%ae%9a%e7%b6%99%e7%b6%9a","/categories/lisp","/categories/common-lisp"],"date":"2016-05-08","title":"高速な継続ライブラリに向けて","url":"https://KeenS.github.io/slide/kousokunakeizokuraiburarinimukete/"},
  {"body":"κeenです。GWもくもく会で机の片隅で埃被ってたRSPiのベアメタルを触ってみたのでその成果報告を。 ベアメタルについて知らない人でも読めるように書きます。そしてアセンブラもCも出てきませんし、半田付けも必要ありません。 Rustしか使いません。\nRustは分かるけどLチカは全く知らない、けど興味のある方は是非読んでみて下さい。\nベアメタルって？ 普段我々が使っているパソコンはOSの上で動いています。 OSはざっくりいうとハードウェアへのアクセスを抽象化し、プロセスという単位でプログラムの実行を分離します。 ベアメタルはそのOSがない状態、ハードウェアの初期化やプロトコルなどは自分でやるしメモリ管理だとかも自分でやる環境です。 丁度ハードウェアが抽象化されてなくて機械が生で見えているようなのでこう呼ぶようです。\nOSがないのは中々イメージつきづらいですが、標準出力なんてものはないのでHello Worldも動きませんしメモリも仮想化されていないのでmallocも発効出来ません。 さらにはスタックとヒープみたいな区別もOSが与えてくれるものなので、自分で作らない限りスタック領域も使えません。 自分で書いたプログラムが唯一走るプログラムなのでプロセスの感覚でプログラムを終了させてはいけません。\nなんでそんな環境でプログラムしたいかというといくつかモチベーションがありそうです。1つはOSそのものを作ってみたい人が練習がてら。 もう1つにはOSが動かないような小さな環境だとそれしか選択肢がない。\nRSPiの場合はOSが動くので選択肢がないという訳ではないのですが私はそういう小さなデバイスを持っていないので実験台としてRSPiを使いました。\nさて、Hello Worldすら動かないシステムでの入門的なプログラムは信号のON/OFFを切り替えてあげるだけで出来るLEDをチカチカさせるプログラムという訳です。\nRaspberry Pi 言わずと知れた名刺サイズの小型コンピュータ、Raspberry Piです。 Raspberry Piと一口にいっても色々種類があるのですが、私が持っているのはRaspberry Pi 1 Model Bの後期モデルです(Raspberry Pi 1 Model Bは販売途中で仕様がアップグレードしてメモリが増えた)。\nARMv6アーキテクチャのチップ(ARM1176JZF-S)で動いていて、SDカードから起動します。特別なライターなどは必要なく、PCからSDカードに書き込んでRSPiに挿して電源を繋ぐだけで簡単に起動出来る訳です。 さらに配線とかが必要なGPIOに加えてボードにLEDもついているので物理の知識必要なくて今回のようにLチカだけをやりたいなら手軽に遊べます。\n準備  Raspberry Pi 1 Model B USB - micro USBケーブル(Raspberry Piへの給電用) SDカード(FAT32でフォーマットしておく) GCCのARM向けクロスコンパイラ(後述) RustのARM向けクロスコンパイラ(後述) ブートローダ(後述)  GCCのクロスコンパイラ GCCのクロスコンパイラはGCC ARM Embedded in Launchpadというプロジェクトがあるので簡単に用意出来ます。Ubuntu環境なら\nsudo apt install gcc-arm-linux-gnueabihf でインストールできます。どうやらRSPiには不動小数点数計算ユニット(FPU)がついているようなのでhf(Hardware Float)で大丈夫みたいです。 HomebrewやPacmanにもパッケージはあるようです。\nRustのクロスコンパイラ 次にRustのクロスコンパイラですが、multirustを使うと簡単にインストール出来ます。今回はunstable機能も使うのでnightlyコンパイラを使います。 因みに私が昔インストールしたmultirustだと古くて以下のコマンドが実行出来なかったので出来ない方はmultirustをアップデートして試してみて下さい。\n# インストール可能なターゲットを確認 $ multirust list-available-targets nightly aarch64-apple-ios aarch64-unknown-linux-gnu arm-linux-androideabi arm-unknown-linux-gnueabi arm-unknown-linux-gnueabihf armv7-apple-ios armv7-unknown-linux-gnueabihf armv7s-apple-ios i386-apple-ios i586-pc-windows-msvc i586-unknown-linux-gnu i686-apple-darwin i686-pc-windows-gnu i686-pc-windows-msvc i686-unknown-linux-gnu mips-unknown-linux-gnu mips-unknown-linux-musl mipsel-unknown-linux-gnu mipsel-unknown-linux-musl powerpc-unknown-linux-gnu powerpc64-unknown-linux-gnu powerpc64le-unknown-linux-gnu x86_64-apple-darwin x86_64-apple-ios x86_64-pc-windows-gnu x86_64-pc-windows-msvc x86_64-rumprun-netbsd x86_64-unknown-freebsd x86_64-unknown-linux-gnu x86_64-unknown-linux-musl x86_64-unknown-netbsd # インストール $ multirust add-target nightly arm-unknown-linux-gnueabihf ブートローダ まず、ブートローダが何をするものなのかから説明しましょう。興味がない人は飛ばして下さい。\n説明 Raspberry PiにはCPUとGPUが両方ついているのでやや面倒です。\nCPU/GPUは電源がONになってすぐは何の機能もない、ただの命令を実行する機械です。メモリにすらアクセス出来ません。RSPiにSDカードを挿したところでSDカードのプロトコルを喋らないとそこに書いてあるプログラムが読めません。 SDカードのプロトコルを喋るプログラム(BIOS)は、RSPiに組込みで入っています。これは普段我々が使うメモリ(RAM)とは別の場所(ROM)に入っています。\n最初はGPUがそいつを起動し、(この時点ではCPUは起動してない)SDカードを読みにいきます。名前決め打ちでbootcode.binという名前のプログラムを、RAMではなくGPU(のL2キャッシュ)に直接ロードして実行します(メモリはまだ使えません)。 GPUのキャッシュは非常に小さいのでbootcode.binは小さなプログラムでないといけません。\nbootcode.binはRAMを有効にしてstart.elfをRAMに読み込み、GPUがそれを実行します。start.elfはRAMを使えるのである程度大きくても構いません。\nstart.elfはconfig.txt、cmdline.txtとkernel.imgを読みにいき、kernel.imgを0x8000番地のメモリに配置します。そしてconfgやcmdlineに基いてCPUを設定してkernel.imgに引数を渡しつつ実行します。\nこのkernel.imgは普段はLinuxカーネルなどのカーネル、今回は我々が作るLチカのプログラムです。\n参考: Raspberry Piのブートプロセスメモ - φ(・・*)ゞ ｳｰﾝ　カーネルとか弄ったりのメモ 昔はloader.binもあったようですが今はなくて大丈夫なようです。\nインストール bootcode.bin, start.elfはこちらから入手出来ます。config.txtとcmdline.txtはなくていいようです。\nこいつらはSDカードに放り込んでおきます。\n環境確認 まずはコンパイラツールチェーンが正常に動くか確認しましょう。 以下にrustコードを。\n#![feature(lang_items, asm)]#![crate_type = \u0026#34;staticlib\u0026#34;]#![no_std]#[no_mangle]pubexternfn main(){loop{}}#[no_mangle]pubexternfn _sbrk(){}#[no_mangle]pubexternfn _exit(){}#[no_mangle]pubexternfn _kill(){}#[no_mangle]pubexternfn _getpid(){}#[lang = \u0026#34;eh_personality\u0026#34;]externfn eh_personality(){}#[lang = \u0026#34;panic_fmt\u0026#34;]externfn panic_fmt(){} さて、今回作るのは #![crate_type = \u0026quot;staticlib\u0026quot;] を使って静的リンクライブラリを作れと指定しています。そして #[no_mangle] pub extern fn main() { でC言語と同じような規則でmain関数を定義する(アセンブラからmain関数を実行出来るようにする)と指定しています。 ベアメタル環境なのでファイルだとか諸々のものはなく、stdを使えないので #![no_std] を指定してstdを使わずにcoreライブラリを使うようにしました。その代わり#[lang = \u0026quot;eh_personality\u0026quot;] extern fn eh_personality() {} と #[lang = \u0026quot;panic_fmt\u0026quot;] extern fn panic_fmt() {} を実装してあげないといけません(この実装はあまりよろしくないのですが今回はとりあえずコンパイルが通るようにということでこうしてます)。\nそしてよく分かってないのですがRustが _sbrk 、 _exit 、 _kill 、 _getpid のシンボルを捜しにいくのでとりあえずスタブを挿してます。\nno_mangle, no_std, lang_itemsについて詳しくはドキュメントをご覧下さい。 他言語関数インターフェイス、No stdlib、言語アイテムあたりが参考になるかと思います。\n以下のようにコンパイル出来ればRustはOKです。\nrustc --target arm-unknown-linux-gnueabihf --emit=obj test.rs 次に、elfファイルを作ります。これは以下のコマンドで出来ます。Cのクロスコンパイラを使っていますね。\n$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles test.o -o kernel.elf /usr/lib/gcc/arm-none-eabi/4.9.3/../../../arm-none-eabi/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000008000 -mで始まるオプションはRaspberry Piのチップ固有の指定、 -nostartfiles はベアメアルで動かすのに必要な指定ですね。\n最後にelfファイルからimgファイルを作ります。\narm-none-eabi-objcopy kernel.elf -O binary kernel.img 私もよく分かってないのですがobjファイルが不完全なバイナリファイル、elfが完全なバイナリファイル、imgがelfを実際のメモリに展開した時のものそのままなんですかね。 逆にいうとOSのない環境で動かすには生のimgが欲しいけどそれを作るのは難しいから一旦elfを作ってそこからimgを生成している？\nさて、とりあえずここまで来れば環境は整いました。あとはプログラムを書くだけです。\nLチカ RSPiにくっついているLEDはデバイスとしてはGPIOのように見えるみたいです。 そしてGPIOはMemory Mapped IO、特定の位置のメモリを読み書きすることでデバイスをいじれるようになってるみたいです。 このセットアップは誰がやったんだって気になりますがBIOSなんですかね。\nさて、この「特定の位置のメモリ」ですが、Raspberry Pi 1だと 0x20200000 から始まるアドレス、のようです。2だと 3F200000 のよう。\nそして0x20200000からいくつかの32bitレジスタが配列のように並んでいる訳ですがこれまたRSPi+やRSP 2とRSPi 1はLEDに対応するレジスタがやや違うようです。\n面倒なのでコピペで済ませると(私はCのコードからRustに移植しました。)\n// Raspberry Pi2 //pub const GPIO_BASE: u32 = 0x3F200000; // other pubconstGPIO_BASE: u32 =0x20200000;// Raspberrp Pi+ or Raspberry Pi2 //pub const LED_GPFSEL: isize = GPIO_GPFSEL4; //pub const LED_GPFBIT: i32 = 21; //pub const LED_GPSET: isize = GPIO_GPSET1; //pub const LED_GPCLR: isize = GPIO_GPCLR1; //pub const LED_GPIO_BIT: isize = 15; // other pubconstLED_GPFSEL: isize =GPIO_GPFSEL1;pubconstLED_GPFBIT: i32 =18;pubconstLED_GPCLR: isize =GPIO_GPCLR0;pubconstLED_GPSET: isize =GPIO_GPSET0;pubconstLED_GPIO_BIT: i32 =16;pubconstGPIO_GPFSEL0: isize =0;pubconstGPIO_GPFSEL1: isize =1;pubconstGPIO_GPFSEL2: isize =2;pubconstGPIO_GPFSEL3: isize =3;pubconstGPIO_GPFSEL4: isize =4;pubconstGPIO_GPFSEL5: isize =5;pubconstGPIO_GPSET0: isize =7;pubconstGPIO_GPSET1: isize =8;pubconstGPIO_GPCLR0: isize =10;pubconstGPIO_GPCLR1: isize =11;pubconstGPIO_GPLEV0: isize =13;pubconstGPIO_GPLEV1: isize =14;pubconstGPIO_GPEDS0: isize =16;pubconstGPIO_GPEDS1: isize =17;pubconstGPIO_GPREN0: isize =19;pubconstGPIO_GPREN1: isize =20;pubconstGPIO_GPFEN0: isize =22;pubconstGPIO_GPFEN1: isize =23;pubconstGPIO_GPHEN0: isize =25;pubconstGPIO_GPHEN1: isize =26;pubconstGPIO_GPLEN0: isize =28;pubconstGPIO_GPLEN1: isize =29;pubconstGPIO_GPAREN0: isize =31;pubconstGPIO_GPAREN1: isize =32;pubconstGPIO_GPAFEN0: isize =34;pubconstGPIO_GPAFEN1: isize =35;pubconstGPIO_GPPUD: isize =37;pubconstGPIO_GPPUDCLK0: isize =38;pubconstGPIO_GPPUDCLK1: isize =39; こうなります(cfgを使ってないです。ごめんなさい。)。\n次にLチカですが、 LEDに対応するGPIOをwriteに初期化する→ループ{LEDに対応するGPIOをセットする → スリープ → LEDに対応するGPIOをクリアする → スリープ}\nのプログラムを書きます。\n色々試したのですが簡単なプログラムだと最適化で消えてしまうので消えないように工夫する必要があります。\nスリープはとりあえずタイマーを使わずに空ループを回すのですが、ループの中身は空インラインアセンブラを使うと消えないようです。\nまた、メモリへの書き込みはintrinsicのvolatile_storeを使います。\nということでコードは以下です。\n#![feature(lang_items, asm, core_intrinsics)]#![crate_type = \u0026#34;staticlib\u0026#34;]#![no_std]usecore::intrinsics::volatile_store;// Raspberry Pi2 //pub const GPIO_BASE: u32 = 0x3F200000; // other pubconstGPIO_BASE: u32 =0x20200000;// Raspberrp Pi+ or Raspberry Pi2 //pub const LED_GPFSEL: isize = GPIO_GPFSEL4; //pub const LED_GPFBIT: i32 = 21; //pub const LED_GPSET: isize = GPIO_GPSET1; //pub const LED_GPCLR: isize = GPIO_GPCLR1; //pub const LED_GPIO_BIT: isize = 15; // other pubconstLED_GPFSEL: isize =GPIO_GPFSEL1;pubconstLED_GPFBIT: i32 =18;pubconstLED_GPCLR: isize =GPIO_GPCLR0;pubconstLED_GPSET: isize =GPIO_GPSET0;pubconstLED_GPIO_BIT: i32 =16;pubconstGPIO_GPFSEL0: isize =0;pubconstGPIO_GPFSEL1: isize =1;pubconstGPIO_GPFSEL2: isize =2;pubconstGPIO_GPFSEL3: isize =3;pubconstGPIO_GPFSEL4: isize =4;pubconstGPIO_GPFSEL5: isize =5;pubconstGPIO_GPSET0: isize =7;pubconstGPIO_GPSET1: isize =8;pubconstGPIO_GPCLR0: isize =10;pubconstGPIO_GPCLR1: isize =11;pubconstGPIO_GPLEV0: isize =13;pubconstGPIO_GPLEV1: isize =14;pubconstGPIO_GPEDS0: isize =16;pubconstGPIO_GPEDS1: isize =17;pubconstGPIO_GPREN0: isize =19;pubconstGPIO_GPREN1: isize =20;pubconstGPIO_GPFEN0: isize =22;pubconstGPIO_GPFEN1: isize =23;pubconstGPIO_GPHEN0: isize =25;pubconstGPIO_GPHEN1: isize =26;pubconstGPIO_GPLEN0: isize =28;pubconstGPIO_GPLEN1: isize =29;pubconstGPIO_GPAREN0: isize =31;pubconstGPIO_GPAREN1: isize =32;pubconstGPIO_GPAFEN0: isize =34;pubconstGPIO_GPAFEN1: isize =35;pubconstGPIO_GPPUD: isize =37;pubconstGPIO_GPPUDCLK0: isize =38;pubconstGPIO_GPPUDCLK1: isize =39;#[no_mangle]pubexternfn main(){// GPIO_BASEを符号無し32bit整数を指すポインタにキャストする letgpio=GPIO_BASEas*constu32;// offsetを使うことでCの配列のようにポインタの何番地か先のメモリを指せる letinit=unsafe{gpio.offset(LED_GPFSEL)as*mutu32};letled_on=unsafe{gpio.offset(LED_GPSET)as*mutu32};letled_off=unsafe{gpio.offset(LED_GPCLR)as*mutu32};// LEDのGPIOを書き込みに設定 unsafe{volatile_store(init,*(init)|1\u0026lt;\u0026lt;LED_GPFBIT);}loop{// LEDをOFFにする unsafe{volatile_store(led_off,1\u0026lt;\u0026lt;LED_GPIO_BIT);}// 適当な長さbusy loopで時間を空ける for_in1..500000{unsafe{asm!(\u0026#34;\u0026#34;);}}// LEDをONにする unsafe{volatile_store(led_on,1\u0026lt;\u0026lt;LED_GPIO_BIT);}// また適当な長さ空ける for_in1..500000{unsafe{asm!(\u0026#34;\u0026#34;);}}}}#[no_mangle]pubexternfn _sbrk(){}#[no_mangle]pubexternfn _exit(){}#[no_mangle]pubexternfn _kill(){}#[no_mangle]pubexternfn _getpid(){}#[lang = \u0026#34;eh_personality\u0026#34;]externfn eh_personality(){}#[lang = \u0026#34;panic_fmt\u0026#34;]externfn panic_fmt(){} これをkernel.rsとして保存し、\nrustc -O --target arm-unknown-linux-gnueabihf --emit=obj kernel.rs でコンパイルします。どうやら使っていないのにrustが余計なシンボルを付けるようで、-Oをつけてそいつらをoptimize outさせないとコンパイルが通りませんでした。 この辺、コンパイラのバージョンに依存しそうで怖いですね。\nさて、あとは先程と同じく\n$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles kernel.o -o kernel.elf $ arm-none-eabi-objcopy kernel.elf -O binary kernel.img でイメージを作ってあげます。\nそしたらこのkernel.imgをSDカードに放り込みます。\nSDカードの中身はこうなっている筈です。\n$ ls /media/kim/6F6F-DCD9 bootcode.bin kernel.img start.elf このSDカードをRSPiに挿して、電源を繋いであげるとLEDがすごい勢いでチカチカする筈です。そうなったら成功です。おめでとうございます。\nおわりに 今回のコードはここに置いておきます。とはいってもそのままではなくてCargo化したりMakefileを書いたり色々しています。\n今回の作業をするにあたって参考にした資料のURLを挙げておきます。\n Step01 – Bare Metal Programming in C Pt1 – Valvers Step02 – Bare Metal Programming in C Pt2 – Valvers Raspberry Pi Bare Metal Programming with Rust piでベアメタルプログラミング - bobuhiro11\u0026rsquo;s diary ","categories":["Rust","Raspberry Pi","ベアメタル"],"category_urls":["/categories/rust","/categories/raspberry-pi","/categories/%e3%83%99%e3%82%a2%e3%83%a1%e3%82%bf%e3%83%ab"],"date":"2016-05-04","title":"RustでベアメタルRaspberry PiのLチカ","url":"https://KeenS.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/"},
  {"body":"κeenです。頭痛い。LXDがリリースされたようなので1つ記事をば。 LXDはLinuxで動く軽量仮想化コンテナ、LXCのラッパでREST APIとCLIが提供されています。\nLXC、LXD共にUbuntuの開発元、Canonicalが開発しています。 LXCについては初期のDockerがバックエンドに使っていたので知名度もそこそこあるかと思いますが、 そのラッパであるLXDはこの度ようやく正式リリースされました。\n既にDockerがあるのになぜわざわざ新たにLXDを使うんだって気もしますが、対象とするレイヤーが違います。 Dockerはアプリケーションコンテナ、つまりアプリケーションを動かすためのプロセスより強い分離環境を提供するために使われますが LXDはシステムコンテナ、つまり仮想マシンより軽い仮想化環境を提供します。 なのでファイルシステムはCopy on Writeしませんし一度終了したコンテナは破棄されず、再起動出来ます。 詳しくはここら辺に書いてあります。\nLXD 2.0: Blog post series [0/12] | Stéphane Graber\u0026rsquo;s website\n1つDockerとLXDの違いの分かりやすい例を出すと、それぞれのOpenStackでの立ち位置を見ると面白そうです。 DockerはOpenStack MagnumでOpenStack上で扱えますが、OpenStackのコンピュートノード 上 で動作します。 一方LXDはnova-compute-lxdでOpenStack上で扱えますが、 OpenStackのコンピュートノード として 動作します。 なんだかんだ重いVMがコンテナのお陰で軽くなる訳です。そして勿論のこと、Docker in LXDなんかも出来るのでちゃんと共存出来ます。\n今のところUbuntu 14.04あるいは未来の16.04でリリースされているようです。Ubuntu 15.10をお使いの方は\nadd-apt-repository ppa:ubuntu-lxc/lxd-stable apt-get update apt-get dist-upgrade apt-get install lxd でインストール出来るようです(マニュアルより)。 LXDはLXCのラッパでありながらもliblxcにしか依存しないのでlxc自体はインストールする必要はありません。\nさてこれでLXDがインストールされた訳ですが、LXDはコンテナなどのリソースを管理するデーモンとそのCLIから成ります。 CLIのコマンド名はなんとlxcです。LXCのコマンド群がlxc-*なので非常に勘違いしやすいですね。\n詳しいコマンド群はマニュアルを読めばいいのですがそれだけだとお粗末なので多少紹介します。\nインストール直後は新規に作ったグループを今のログインセッションに反映させる必要があるので\nnewgrp lxd とする必要があります。その次は初期化が必要になります。lxd initです。いくつか質問されますがデフォルトの回答を選んでいけば問題なさそうです。\n$ sudo lxd init Name of the storage backend to use (dir or zfs): zfs error: The requested backend \u0026#39;zfs\u0026#39; isn\u0026#39;t available on your system (missing tools). Name of the storage backend to use (dir or zfs): dir Would you like LXD to be available over the network (yes/no)? yes Address to bind LXD to (not including port): 0.0.0.0 Port to bind LXD to (8443 recommended): Invalid input, try again. Port to bind LXD to (8443 recommended): 8443 Trust password for new clients: Again: Do you want to configure the LXD bridge (yes/no)? yes Warning: Stopping lxd.service, but it can still be activated by: lxd.socket LXD has been successfully configured. Ubuntuでzfsが使えるのは16.04からなので15.10では使えませんでした。また、ブリッジのコンフィギュアにはウィザードが出てきます。\nこれで初期化が終わり、コンテナを立ち上げる準備が出来ました。\nコンテナはイメージを元に立ち上げるのですが、今回はイメージはネット上のものから立ち上げます。 インストール時点でいくつかサーバが登録されているので名前で指定してあげるだけでよいようです。 他にイメージを使う方法はリモートのLXDをサーバとして使う、手動でファイルからインポートするなどがあるようです。\nということでコンテナの立ち上げはこうです。折角なので未来のUbuntu 16.04を使ってみましょう。\nsudo lxc launch ubuntu:16.04 future-ubuntu このコマンドでビルトインの\u0026rdquo;Ubuntu\u0026rdquo;サーバにある16.04バージョンのイメージをfuture-ubuntuという名前のコンテナで立ち上げます。\nこれでコンテナが立ち上がりました。確認してみましょう。\nsudo lxc list +---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+ | NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS | +---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+ | future-ubuntu | RUNNING | 10.197.202.251 (eth0) | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0 | | | | 10.0.3.1 (lxcbr0) | | | | +---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+ ついでにローカルにあるイメージも確認しましょう。インポートまで終わっているようです。\nsudo lxc image list +-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+ | ALIAS | FINGERPRINT | PUBLIC | DESCRIPTION | ARCH | SIZE | UPLOAD DATE | +-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+ | | 6cb0ba80a5fe | no | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) | +-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+ 立ち上げたコンテナにログインしてみましょう。これはDockerをお使いの方は馴染があるんじゃないでしょうか。\nsudo lxc exec future-ubuntu -- /bin/bash root@future-ubuntu:~# lsb_release -a No LSB modules are available. Distributor ID:\tUbuntu Description:\tUbuntu Xenial Xerus (development branch) Release:\t16.04 Codename:\txenial root@future-ubuntu:~# exit ちゃんと16.04になっているようです。\nコンテナの停止は\nsudo lxc stop future-ubuntu です。ちゃんと止まったか確認してみましょう。\nsudo lxc list +---------------+---------+------+------+------------+-----------+ | NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS | +---------------+---------+------+------+------------+-----------+ | future-ubuntu | STOPPED | | | PERSISTENT | 0 | +---------------+---------+------+------+------------+-----------+ ちゃんとSTATEがSTOPPEDになってますね\nもう一度起動してみます\nsudo lxc start future-ubuntu sudo lxc list +---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+ | NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS | +---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+ | future-ubuntu | RUNNING | 10.197.202.251 (eth0) | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0 | | | | 10.0.3.1 (lxcbr0) | | | | +---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+ 次はコンテナを削除します\nsudo lxc stop future-ubuntu sudo lxc delete future-ubuntu sudo lxc list +------+-------+------+------+------+-----------+ | NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS | +------+-------+------+------+------+-----------+ sudo lxc image list +-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+ | ALIAS | FINGERPRINT | PUBLIC | DESCRIPTION | ARCH | SIZE | UPLOAD DATE | +-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+ | | 6cb0ba80a5fe | no | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) | +-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+ コンテナが消えただけでイメージは残るんですね。\nさて、いかがでしょうか。軽量なVMと考えれば非常に手軽で中々面白いんじゃないでしょうか。 因みにコンテナとホスト間でのファイルのやりとりも簡単(lxc file pull/push)なようなのでコンテナ内でコンパイラを動かしてホストにもってくるとかをすれば開発環境の隔離環境としても使えそうです。\n時間があればもう少し詳細に検証してみます。SNAPSHOTとかも試してみたかった。それでは今日はこの辺で。\n","categories":["Linux","Ubuntu","仮想化","コンテナ","lxd","lxc"],"category_urls":["/categories/linux","/categories/ubuntu","/categories/%e4%bb%ae%e6%83%b3%e5%8c%96","/categories/%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a","/categories/lxd","/categories/lxc"],"date":"2016-04-14","title":"LXDがリリースされたらしい","url":"https://KeenS.github.io/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii/"},
  {"body":"# テストについて、Scalaと。 ---------------------- サイバーエージェント アドテクスタジオ ScalaMeetUp テスト回 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバーエージェントのエンジニア + 基盤開発グループでScalaで基盤開発してます + Lisp, ML, Rust, Shell Scriptあたりを書きます === # Scalaのテスト --------------- * ScalaTest + 機能豊富 + 複数のテストスタイルを選べる + 他のフレームワークとの統合がある * Specs2 + 普通に使いやすい * 他にもScalaCheck、JUnit、Gatlingなどなど === # ScalaTestのスタイルたち ----------- * FunSuite + xUnitっぽいらしい * FlatSpec + xUnitからBDDに移行した人向けらしい * FunSpec + RSpecっぽいBDD用の === # ScalaTestのスタイルたち ----------- * WordSpec + Specs2に似てる。 * FreeSpec + 何段にでもネスト出来る。自由。 * Spec + テスト=メソッド。速いらしい。 === # ScalaTestのスタイルたち ----------- * PropSpec + プロパティベースのテスト。ScalaCheckとの統合。 * FeatureSpec + シナリオテスト。 === # その他の機能 ------------- * mockitoのシュガー * Matcher DSL * 複数のランナー（複数のツールとの統合） === # Axionのテスト コード紹介を多めに === # 単体テスト --------------- * 普通の単体テストはWordSpec * ホーアの3つ組に基いて事前条件、コマンド、事後条件(不変条件)に分ける + 「{事前条件}が成り立つ時{コマンド}を実行し、停止するなら{事後条件(不変条件)}が成り立つ」の列挙 * [テストについて考えてみた | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/tesutonitsuitekangaetemita/) * コマンドの実行と事後条件への表明を明確に分離 * テストの分け方に試行錯誤 === # 事前条件 ---------- * 基本的にはmockitoをフルに使う * テストは並行に走るのでテストケース毎にモックを準備 * コンテキストの共有は基本的にはしない + 情報の局所性を上げて何をテストするかを理解しやすくする + 逆にノイズが乗ってわかりにくい？ * メソッドの実行に必要な引数と環境全てを構築する === # コマンドの実行 --------------- * 例外が起きないことだけ表明する * 結果はvarに保存して外に持ち出す。 === # 事後条件 ---------- * コマンドを実行した結果に対する表明 * 環境に対する表明 + 環境が変化した/しなかった + 依存オブジェクトのメソッドが呼ばれた/なかった === メソッド毎にテストケースをグルーピング ``` scala \"Class#method\" when { \"precondition\" should { ... var ret: Type = null \"method invocation\" in { ret = ... } \"post conditions\" in { ... } } } ``` === # Tips ------ * エディタでテンプレートを用意しておくと楽 + ensimeのテストテンプレートとか * やや冗長でも頭を使わずに書ける/理解出来るテストを書く === # ユーティリ --------------- * ユーティリティのテストはPropSpec * ユーティリティ = 汎用的(文脈に依存しない)、副作用がない、小さい + まさにプロパティベースのテストに向く * ほとんどGenerator Driven Test + 半分くらいScalaCheckの機能を使う * 一部Tebale Driven Test + Generatorがコーナーケースを生成してくれない時がある === # 他のテスト ------------ * インテグレーションテスト/パフォーマンステストはGatling(の予定) * Gatlingでエラーレート、パーセンタイル、レスポンスなどをテスト出来る * パフォーマンステストは実行インスタンスを固定しないといけない問題が… * シナリオテストはない(APIがReadのみなため) === # 他のテスト --------------- * AxionはThriftプロトコルだがGatlingのAPIをいくつか実装すればGatlingを独自プロトコルに対応出来る + 実装量はほとんどない + 2~3個DSLを作るだけ + 簡単とはいってない(ドキュメントがないつらさ) * Gatlingのおかげでパフォーマンスに対する表明やリクエスト毎のチェックなどが簡単 * そのうちノウハウを公開するかも？ + 2.1.Xと2.2.XでAPIが違う問題も… === # まとめ -------- * ScalaTestを紹介したよ * ScalaTestの実用例を紹介したよ * Gatlingについて紹介したよ   ","categories":["Scala","Scala Meet Up","テスト","社内"],"category_urls":["/categories/scala","/categories/scala-meet-up","/categories/%e3%83%86%e3%82%b9%e3%83%88","/categories/%e7%a4%be%e5%86%85"],"date":"2016-04-12","title":"テストについて、Scalaと。","url":"https://KeenS.github.io/slide/tesutonitsuite_scalato_/"},
  {"body":"κeenです。寝付けないのでMirah関連ツールについてまとめようかと。 とはいってもそんなにないのですが。Mirahについて知らない人は適当にググって下さい。\nコンパイラ Releases · mirah/mirah\n本家のものを使うべし\n開発支援 NetBeansプラグイン shannah/mirah-nbm: Netbeans Module for Mirah\nこのプラグインのためにパーサのAPIに変更を加える議論がされたりしていて恐らく現状一番まともに動くやつと思う。\nEmacs KeenS/mirah-mode.el:\nruby-modeにやっつけで雑に機能を追加したやつ。コメントのハイライトにコーナーケース(/*/*/**/*/*/ みたいなの)があったり雑。 まあ、とりあえずそれっぽくは動く\nビルドツール統合 Gradle ysb33r/gradle-mirah-plugin: Gradleplugin to compile Mirah source code\n最近作られたやつ。軽く使てみたら簡単に動いたし良さげ。\nMaven mirah/maven-mirah-plugin: Plugin to compile Mirah source with Maven\n公式サポートだし良さげ。\nその他 コードトランスレート captn3m0/java2mirah: A java to mirah transpiler\njavaからMirahに変換してくれるツール。試したことはないけどそんなに期待はしてない。\n私が把握してるのはこれくらい。ビルドツール統合と開発支援があればどうにかなるっしょ。\n","categories":["Mirha","開発環境"],"category_urls":["/categories/mirha","/categories/%e9%96%8b%e7%99%ba%e7%92%b0%e5%a2%83"],"date":"2016-04-04","title":"Mirah関連ツールまとめ","url":"https://KeenS.github.io/blog/2016/04/04/mirahkanrentsu_rumatome/"},
  {"body":"# SMLで函数型的正規表現マッチ ---------------------- === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバーエージェントのエンジニア + Lisp, ML, Rust, Shell Scriptあたりを書きます === # 元ネタ -------- [関数型的正規表現マッチ | Preferred Research](https://research.preferred.jp/2010/11/regexp-play/) === # 正規表現 ---------- 必要最小限の要素は5つだけ 1. 空文字 2. アルファベット1つ 3. 正規表現のOR結合 4. 正規表現のAND結合 5. 正規表現の繰り返し === # SMLで表してみる ----------------- ``` sml datatype reg = Empty | Sym of t | Or of reg * reg | And of reg * reg | Rep of reg ``` === # 本当に大丈夫？ === # `/(a|b)*c/` ----------- ``` sml And(Rep(Or(Sym \"a\", Sym \"b\")), Sym \"c\") ``` === # `/https?:\\/\\/[a-z]*/` ----------- ``` sml val a_z = Or(Sym\"a\", Or(Sym \"b\", Or(Sym \"d\", ...))) And(Sym \"http\", And(Or(Sym \"s\", Empty), And(Sym \"://\", Rep a_z))) ``` === # 実装してみる === # `Empty`, `Sym`, `Or` ---------------- trivial ``` sml fun match Empty u = isEmpty u | match (Sym a) u = a = u | match (Or(p, q)) u = match p u orelse match q u ``` === # `And` -------- `And(p, q)` に入力が`u`の時`p`がどこまでマッチするか分からないので * `u` から一部取ってきて`p`にマッチするか確認 * 残りの文字列が`q`にマッチするか確認 === # `And` -------- `match (And (Sym \"a\", Sym \"b\")) \"abd\"` の時 * (Sym \"a\"と\"\")、(Sym \"b\"と\"abd\") * (Sym \"a\"と\"a\")、(Sym \"b\"と\"bd\") * (Sym \"a\"と\"ab\")、(Sym \"b\"と\"d\") * (Sym \"a\"と\"abd\")、(Sym \"b\"と\"\") === # `And` -------- ``` sml | match (And(p, q)) u = withSprits u (fn (u1, u2) = match p u1 andalso match q u2) ``` `withSprits u f` は`u`を2分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。 === # `Rep` ------- `Rep(r)` に入力が`u`の時、`r`がどこまでマッチするかも`Rep`が何回繰り返すかも分からないので * `u` を任意の個数に分割し * その全てが`r`にマッチするか確認 === === # `Rep` -------- `match (Rep (Sym \"a\")) \"abd\"` の時 * (Sym \"a\"と\"abd\") * (Sym \"a\"と\"a\")、(Sym \"a\"と\"bd\") * (Sym \"a\"と\"ab\")、(Sym \"a\"と\"d\") * (Sym \"a\"と\"a\")、(Sym \"a\"と\"b\")、(Sym \"a\"と\"d\") === # `Rep` -------- ``` sml | match (Rep(r)) u = withParts u (fn input = List.all (match r) input) ``` `withParts u f` は`u`を分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。 === # チェック ---------- ``` # match (And(Rep(Or(Sym \"a\", Sym \"b\")), Sym \"c\")) \"ababbca\"; val it = false : bool # match (And(Rep(Or(Sym \"a\", Sym \"b\")), Sym \"c\")) \"ababbc\"; val it = true : bool # match (And(Rep(Or(Sym \"a\", Sym \"b\")), Sym \"c\")) \"c\"; val it = true : bool ``` === # まとめ -------- * 適当に実装したら正規表現も簡単に実装出来るよ * SMLで正規表現実装したよ === # 参考 ------ * [KeenS/regexp](https://github.com/KeenS/regexp)   ","categories":["SML","ML","正規表現"],"category_urls":["/categories/sml","/categories/ml","/categories/%e6%ad%a3%e8%a6%8f%e8%a1%a8%e7%8f%be"],"date":"2016-03-29","title":"SMLで函数型的正規表現マッチ","url":"https://KeenS.github.io/slide/smldekansuukatatekiseikihyougenmatchi/"},
  {"body":"# ビッグデータしないDrill、ローカルで快適に使うために ---------------------- [Tokyo Apache Drill Meetup](http://drill.connpass.com/event/27414/) 2016-03-22 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + Lisp, ML, Rust, Shell Scriptあたりを書きます + サイバーエージェントのエンジニア + アドテクスタジオ所属 + データエンジニアじゃなくてもデータを触ることはある === # なぜローカルか --------------- * ビッグデータ重い * 使いたいデータが絞れる時には大袈裟 + 「売り上げ上位1000のユーザの行動」とか * 同じようなクエリの重複 + 新しいテーブル作れないDBとかview作れないDBとか * 結果をRに渡したりとかが面倒 + CSVダウンロードがGUI === # キャッシュ的な ---------------- ``` +---------------------------------+ | BIG DATA (BigQuery, Spark, etc) | +---------------------------------+ ^ | ^ | | | | | | v | v +-------------------+ | ローカルキャッシュ | ＿人人人人人人人＿ ＞　突然のDrill　＜ ￣Y^Y^Y^Y^Y^Y￣  === # なぜ Drill ------------ * (デーモン立ち上げておけば)サクっと始められる * CSVをそのまま読める + Schema定義がいらない! * ついでにJSONも読める * 馴れたSQLで操作出来る * CSV吐ける === # Drillを便利にするために ------------------------- * いくつかのシェル関数 * Drillのデーモン/クライアントの起動を便利に ```sh drill-start() { ~/compile/zookeeper-3.4.8/bin/zkServer.sh start drillbit.sh start } drill-cli() { sqlline -u jdbc:drill:zk=localhost:2181 } drill-web() { firefox http://localhost:8047 } ``` === # もっと便利に -------------- * REPLでの操作が面倒 + ヒストリ遡るのとか + ミスった時の訂正が地味に不便 * シンタックスハイライト欲しい * 馴れたツールで編集したい === # sql-drill.el -------------- * [KeenS/sql-drill.el](https://github.com/KeenS/sql-drill.el) * Emacsのsql-modeのDrillサポート + emacsのsql-modeは拡張可能 * シンタックスハイライト * REPL === # DEMO ------ === # まとめ -------- * ローカルでデータ分析したい時があるよ * その時にDrillは便利だよ * Emacs向けのDrillプラグイン作ったよ   ","categories":["SQL","DB","Apache Drill","Drill Meet up"],"category_urls":["/categories/sql","/categories/db","/categories/apache-drill","/categories/drill-meet-up"],"date":"2016-03-06","title":"ビッグデータしないDrill、ローカルで快適に使うために","url":"https://KeenS.github.io/slide/biggude_tashinaidrill_ro_karudekaitekinitsukautameni/"},
  {"body":"# Rustとは何か。どんな言語か。 ---------------------- [異種プログラミング言語格闘勉強会](http://kbkz.connpass.com/event/26677/) 2016-03-20 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバーエージェントのエンジニア + Lisp, ML, Rust, Shell Scriptあたりを書きます === # Rustって? ---------- * システムプログラミング言語 * だけど函数型言語から影響を受けた * 安全かつ高速 * ゼロコスト抽象化 === ## システムプログラミング言語 --------------------------- * スレッドはネイティブ、Cとの相互呼び出し、小さなバイナリサイズ * ゲームエンジンとか作れる([piston](https://github.com/PistonDevelopers/piston)) * レンダリングエンジンとか作れる([Servo](https://github.com/servo/servo)) * Lチカとか出来る * OSとか作れる([Redox](https://github.com/redox-os/redox)) === ## 函数型言語的からの影響 ----------------------- 最近ではめずらしくなくなった * デフォルトイミュータブル * 代数的データ型 * コンビネータ * トレイト (型クラス) === ## 安全かつ高速 -------------- * データ競合が起きない + 所有権システム + だいたいコンパイル時Read Writeロック + Read only参照複数 or Write可能参照1つ * LLVMベースの強力な最適化 * スレッド周辺のAPIが揃ってる === ## ゼロコスト抽象化 ------------------ 省略 * [Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/) === # Rustの誤解 ----------- * 安定してないって聞いたよ * 函数型言語ってホント? * GCがなくて大丈夫? * 継承がなくて大丈夫? === ## 安定してないって聞いたよ * 1.0以前の話 * 1.0(2015-05以降)はAPIの変更がルール化された * 新規APIのstablizeはあれどdeprecateはまれ === ## 函数型言語ってホント? * 函数型言語の機能をつまみぐいしてるだけ * 標準ライブラリとかはバリバリ手続的 * Lispよりも函数型言語っぽくない。 * とはいえ抽象力は高いのでそこまで煩雑にはならない === ## GCがなくて大丈夫? * GCはなくてもメモリ管理は自動でする * コンパイル時にメモリ管理 + コンパイラが必要なところにmalloc/freeを挟むイメージ * むしろメモリ以外(fd、ロックなど)も自動管理 + GCがある言語よりリソース管理の自動化が徹底してる * [リージョンについて | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/) === ## 継承がなくて大丈夫? * むしろ継承必要？インターフェースだけでよくない？ * Rustはデータ型とメソッドを分離するので継承のメリットそんなにない + トレイトが強力ともいう * 逆にサブタイプ関係による複雑さの上昇のデメリットが多い + 3回以上継承してるの全部把握出来るの？ * ジェネリクスとかはあるよ === # Rustをとりまく環境 ------------------- * racer/rustfmt * Cargo * crates.io * [Rust Playground](https://play.rust-lang.org/) * The Rust Programming Language === # racer/rustfmt --------------- * racerがコーディング支援ツール + 補完 + 定義元ジャンプ + 型情報 + 各種エディタプラグインあり * rustfmtがコードフォーマッタ + エディタプラグインあり + ビルドツール連携あり === # Cargo ------- * Rustのビルドツール兼パッケージマネージャ * これだけ覚えとけば困らない === # crates.io ----------- * Rustパッケージのセントラルレポジトリ * 必ずビルドが通るような工夫 + cargo yank + 同じライブラリの違うバージョンがいても大丈夫 * Cargoとの連携 * Cargoからpublishも可能 === # [Rust Playground](https://play.rust-lang.org/) --------------------------------------- * webからRustを試せる * とりあえず試すと色々分かる + 所有権難しいとか === # [The Rust Programming Language](https://doc.rust-lang.org/book/) ------------------------------ * Rustの入門用ドキュメント * とりあえずこれ読めば始められる * [和訳版](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)もある + [GitHub](https://github.com/rust-lang-ja/the-rust-programming-language-ja)で作業中 + これの宣伝しに来ただけ * 1.6ほぼ終わり、1.7はまだ === # ライブラリ紹介 ---------------- ## MIO * [mio](https://github.com/carllerche/mio) * 低レベルな非同期IOライブラリ + libuvやlibev2相当 + イベントスレッドではなくイベントループ * これを純Rustで実装 * つまり(比較的)高水準なAPIで使える * 色んなライブラリの下地になっている === # ライブラリ紹介 ---------------- ## diesel * [diesel](https://github.com/sgrif/diesel) * ORM \u0026 クエリビルダ + mioとはうってかわって高水準なライブラリ * `infer_schema!(dotenv!(\"DATABASE_URL\"));` でコンパイル時に + DBにアクセスしてスキーマ情報抜いて + コード生成 * モデルもCRUDでちゃんと使い分けている === # 所有権難しい -------------- 下記のコードは動かない。 ``` rust fn main(){ let hello = \"Hello, \".to_owned(); let world = \"World!\"; let hello_world = hello + world; println!(\"{}\", hello); println!(\"{}\", world); println!(\"{}\", hello_world); } ``` === # まとめ -------- * Rustはシステムプログラミング言語だよ * 面白い機能いっぱいあるよ * もう「安定待ち」じゃないよ * Try it now!   ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2016-03-06","title":"Rustとは何か。どんな言語か。","url":"https://KeenS.github.io/slide/rusttohananika_donnagengoka_/"},
  {"body":"Rustにおいては返り値ポインタで返すよりもそのまま返して、受け取る側でポインタで受け取るかそのまま受け取るかを指定するのが良い選択肢だ、といっています。 しかし初めて見る時にはどうしてそんなことが出来るのかわからず、びっくりしますよね。 それをRustがリージョンを使ってメモリ管理をしていると分かればどうなっているのか分かったのですこしばかり。\nRustにおいては以下のように関数が値を返す時にポインタを返すコードは好ましくなく、（というかコンパイル出来ない）\nfn new_value()-\u0026gt; \u0026amp;BigStruct{\u0026amp;BigStruct{....}}letbs=new_value(); 関数が返す値はスタックに載らないような大きな値でもそのまま返して、受け取り側でヒープに保存してあげるのが良いスタイルとされています。\nfn new_value()-\u0026gt; BigStruct{BigStruct{....}}letbs=Box::new(new_value()); 今までの言語の感覚だとRustにおいて良いとされるスタイルは大きな値を一旦スタックに載せた後でBoxによって作られたヒープ領域に確保されているように見えます。\nこれはリージョンについて理解すると動作が理解できます。\nリージョンについては以前のブログを参照して下さい。\nリージョンについて | κeenのHappy Hacκing Blog\nさて、リージョンによるメモリ管理は「メモリを確保すべき場所」が先にあって、値はそこに置かれます。 特に、関数呼び出しにおいて、関数の「返り値を確保すべき場所」は関数の外から与えます。\nここまで説明したらお分りかと思いますが、Box::new(new_value());というコードはnew_value()の返り値を保存する場所としてヒープ領域を渡していて、 関数内部でそのヒープ領域にBigStructの値を書き込んでいるのです。\nもやもやしていたものがスッキリしたし返り値のサイズが決まってないと関数から返せないのも分かるようになった。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2016-03-02","title":"リージョンとRustの返り値","url":"https://KeenS.github.io/blog/2016/03/02/ri_jontorustnokaerichi/"},
  {"body":"κeenです。今日Twitter上でのやりとりから少し面白いことが分かったのでそれについて。\n最近1.0が出たKotlinについて、水島さんがツイートしてました。\nnullableに対してはmapとかの高階関数を一切使えないのが痛い。 ?. でカバーできるケースは一部だけだ。zero-overhead null-safetyと唄っとるが、代わりにnullチェックお化けになるわけで、どこがzero-overheadだ #kotlin_dis\n\u0026mdash; 水島 宏太(Klassic作成中) (@kmizu) 2016年2月29日 それについて私が無関係なツイートを。\n全く無関係だけどRustはOptionみたいな0-1の型をnull or valueに最適化するそうな。これこそがゼロコスト抽象かな https://t.co/5Y7cBEyrMe\n\u0026mdash; κeen (@blackenedgold) 2016年2月29日 これはRustのnomiconに書かれています。\nrepr(Rust)\nそうすると水島さんからお返事が。\n@blackenedgold Rust詳しくないですけど、Optionにmapとかした場合インライン展開されるんですかね？だとしたらとても理想的。\n\u0026mdash; 水島 宏太(Klassic作成中) (@kmizu) 2016年2月29日 \n確かにそうなると面白そう。ということで少し調べてみました。\nまず、上記の話をまとめると、RustのOptionに対するmap\npubfn map\u0026lt;U,F: FnOnce(T)-\u0026gt; U\u0026gt;(self,f: F)-\u0026gt; Option\u0026lt;U\u0026gt;{matchself{Some(x)=\u0026gt;Some(f(x)),None=\u0026gt;None,}} はxがポインタ型だった時に以下と同値です。\npubfn map\u0026lt;U,F: FnOnce(T)-\u0026gt; U\u0026gt;(self,f: F)-\u0026gt; Option\u0026lt;U\u0026gt;{if(self!=nullPointer){f(x)}} さらに、mapはインライン宣言されているので以下のコード\nletopt=Some(\u0026amp;v);opt.map(|x|x+1); は以下と同値です。\nletopt=\u0026amp;v;if(opt!=nullPointer){(|x|x+1)(opt)}; さて、ここで無名関数がどうコンパイルされるかという問題が出てきますが、クロージャのドキュメントによるとこういう雰囲気のコードになるらしいです。\nletopt=\u0026amp;v;struct AnonymousType;implFnOnce\u0026lt;(\u0026amp;i32)\u0026gt;forAnonymousType{type Output=i32;fn call_once(self,args: (\u0026amp;i32))-\u0026gt; Self::Output{args+1}}if(opt!=nullPointer){letfn_once: FnOnce =AnonymousType;fn_once.call_once(opt)}; 思ったよりも複雑…。さて、問題はlet fn_once: FnOnce = AnonymousType;としているので一旦元の無名関数の情報が抜けてしまいそうな気がします。 となるとコンパイル時に具体的なメソッドを決定出来ないのでfn_once.call_once(opt);は以下のような雰囲気のコードになってしまいます。\nletcall_once_fn=fn_once.get_call_once_fn();call_once_fn(opt); 毎回呼び出すべき関数の取得が入るのは面倒ですね。\nしかしなががらクロージャのドキュメントをよく読むと無名関数は静的ディスパッチされると書いてあります。つまり、\nletcall_once_fn=fn_once.get_call_once_fn();call_once_fn(opt); と2段ではなく\nthe_call_once_fn_of_AnonymousType(opt); とコンパイルされ、\nよって\nletopt=Some(\u0026amp;v);opt.map(|x|x+1); は\nfn the_call_once_fn_of_AnonymousType(x: \u0026amp;i32)-\u0026gt; i32 {x+1}letopt=\u0026amp;v;if(opt!=nullPointer){the_call_once_fn_of_AnonymousType(opt)}; と同値ということです。\nここからは私の推測ですが、the_call_once_fn_of_AnonymousTypeは本体が小さい上に1回しか呼ばれないのでインライン化されるのではないかと思います。 よってこの推測が正しければ\nletopt=Some(\u0026amp;v);opt.map(|x|x+1); は\nletopt=\u0026amp;v;if(opt!=nullPointer){opt+1}; となる筈です。\nゼロコスト抽象化すごい!\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2016-03-01","title":"Rustのゼロコスト抽象化","url":"https://KeenS.github.io/blog/2016/03/01/rustnozerokosutochuushouka/"},
  {"body":"κeenです。 普段はテストをあまり書かない人なのですが業務では流石に書く必要があって、馴れないことをしていると色々と考えることがあったのでまとめます。 まだ私はテストのセオリーとかには詳しくないので勝手気儘に考えたことです。\n2016-03-05 追記: 酷い誤りがあったので修正しました。s/ホーア理論/ホーア論理/。\n今まではテストは「とりあえずエッジケースとかをカバー出来てればいいんでしょ」くらいにしか考えてませんでした。 しかしオブジェクト指向をしていて他のオブジェクトの振舞いに依存するだとか関数の引数が複雑だとかの時には適切なケースを書くのが困難でした。\nチームの人とかとどう書くのが適切かと話しているとなんとなくまとまってきました。\nホーア論理 ホーア論理的にはソフトウェアの振舞/性質を表すのには3つの要素が必要です。事前条件、操作、事後条件です。\n「事前条件Pが満たされるときに操作Oを行い、それが停止するならば事後条件Qが満たされる」\nエンジニアリング的には以下のように読み替えられます。\n事前条件とは、メソッドを実行するまでのお善立て。引数を用意する、依存するオブジェクトのモックを用意する、などなど。 操作が実際のメソッドの実行。 事後条件こそがassertなどを使ったテストケース群です。\nテストフレームワークとホーア論理 テストを書く時にもこの考え方は役に立つな、と思いました。事前条件 x 操作 x 事後条件を網羅していけばいい訳です。\nところで、テストフレームワークにはテストをグルーピングしたりといくつかのスコープをネスト出来る機能を持っているものもあります。 ホーア論理では要素が3つある訳ですから3段にネストするのが適切な気がするのは納得いくと思います。しかしどの順番でネストするかは議論の余地がありそうです。\n勿論、ホーア論理に従うなら操作の時系列的に事前条件\u0026gt;操作\u0026gt;事後条件のネストの仕方が一番自然かと思います。 しかしテストしたい主役は振舞、メソッドなのでそれを階層の最上位に持ってくる方が可読性、ひいてはテストの意味が高まりそうです。\nあるいは、4段にネストして最上位にだたのグルーピング目的にメソッドを、そしてその下に事前条件\u0026gt;操作\u0026gt;事後条件を持っていく手法もありそうです。 しかしこれだとネストが深すぎますね。また、後述するように操作の子階層を作ると例外がどこ由来なのか分かりづらいという問題もあります。\nこれの改良版は最上位にだたのグルーピング目的にメソッドを、そして事前条件\u0026gt;(操作+事後条件)という形のネストの仕方をする方法です。 これは例外の出所を明確に出来る他、多くのテストフレームワークで操作に対する表明と事後条件に対する表明を区別しない問題もクリア出来るという利点があります。 1つある欠点は、操作と事後条件のスコープが分かれているので操作の返り値に対して事後条件で表明したい時にどうにかしてスコープの外に出してやる必要がある点です。 副作用を容易に許す言語なら外のスコープの変数に代入すればいいだけですが、純粋な言語だと簡単ではありません。 そういう意味でも操作に対する表明と事後条件に対する表明は分けたいなと思う次第。\n操作に対する表明 本来のホーア論理的には事後条件で表明すれば十分ですが、実際には不十分な点があります。もう一度ホーア論理の表明について思い出しましょう。\n「事前条件pが満たされるときに操作oを行い、 それが停止するならば 事後条件qが満たされる」\n現実的に、関数が正しく停止することも保証したいです。「無限ループを書く方が悪い」という訳ではありません。関数が停止しないのは何も無限ループだけでなく、例外などで脱出した場合も含みます。\nなので例外を出す/出さないの表明も欲しくなる訳です。 もう少し踏み込んで考えると、多くのテストフレームワークでassertと例外の送出の有無を同列扱いますが、前者は事後条件に対する表明、後者は操作に対する表明なので本来は分かれるべきです。\nまた、操作に対する表明はスコープを作るとしても操作の返り値を返す手段を用意してくれると事後条件の表明がやりやすくなるな、と思いました。まる。\nまとめ テストをする時には3つの要素に分けて考えると考えやすくなります。その3つとは事前条件、操作、事後条件で、それぞれの組み合わせがあるのでテストケースのネストは合理的です。 しかしながら人間の認識のためにネストの順番は入れ替えた方がよいのですが、そうするとコード上いくつか問題が発生します。\nグルーピング目的にメソッドを、そして事前条件\u0026gt;(操作+事後条件)というネストの仕方が最終案に思えますが、それを的確に表現出来、かつコード上の問題をクリア出来るテストフレームワークが中々ないのが現状です。\n付録A 考えがまとまるまでの過程\nテスト書いててなぜテストライブラリがテストスートを階層構造にしてるのか考えたけど1つの事前条件に対して複数の操作が考えれてそれぞれの操作に対して保証したい不変条件と事後条件があるから少なくとも3段にネストしないと上手くグルーピング出来ないのかな。\n\u0026mdash; κeen (@blackenedgold) 2016年3月1日 しかしネストする順番はどうだろう。メソッドに対するテストでグルーピングしたいからメソッド\u0026gt;事前条件\u0026gt;事後/不変条件になるのかな。\n\u0026mdash; κeen (@blackenedgold) 2016年3月1日 事前条件を最上位に持ってきた方が理解しやすいし事前条件の使い回しもしやすいけど並行にテストを走らせようと思ったらやっぱり操作毎に事前条件用意してあげた方がいいし事前条件と事後条件が近い方が性質を理解しやすい?\n\u0026mdash; κeen (@blackenedgold) 2016年3月1日 あれ?もしかして操作ってメソッドじゃなくてメソッド+引数になる?\n\u0026mdash; κeen (@blackenedgold) 2016年3月1日 うーん。操作を行うパートと条件の準備/確認のパートを分けたいんだけど難しい。例えば操作によって例外が出ることを確認したいとかが非常にやりづらい。\n\u0026mdash; κeen (@blackenedgold) 2016年3月1日 いや?やっぱり操作と事後/不変条件のパートは分けれるな?\n\u0026mdash; κeen (@blackenedgold) 2016年3月1日 そしてやはり操作をネストのトップレベルにもってくると操作の引数とかが事前条件/前提条件に依存するのでやりづらい。\n\u0026mdash; κeen (@blackenedgold) 2016年3月1日 \n","categories":["テスト"],"category_urls":["/categories/%e3%83%86%e3%82%b9%e3%83%88"],"date":"2016-03-01","title":"テストについて考えてみた","url":"https://KeenS.github.io/blog/2016/03/01/tesutonitsuitekangaetemita/"},
  {"body":"κeenです。少し前の話になりますがRustの関連型を駆使してHigher Kinded type Trait（高階型トレイト）を実現してしまったものが出回ってたのでそれについて。 本来RustはHKTをサポートしていませんが不思議なことに実装出来てしまっているのです。\nHKTについて微塵も知らない方にも分かるように解説していきます。\nmap 可能なトレイト Option、Result、etc 色々なトレイトが map メソッドを実装しています。\nそれぞれ型シグネチャを抜き出してみましょう。\n Option: map\u0026lt;U, F: FnOnce(T) -\u0026gt; U\u0026gt;(self, f: F) -\u0026gt; Option\u0026lt;U\u0026gt; Result: map\u0026lt;U, F: FnOnce(T) -\u0026gt; U\u0026gt;(self, op: F) -\u0026gt; Result\u0026lt;U, E\u0026gt;  驚く程似てますね。これを抽象化して「mapメソッドを持つ」トレイトを定義したくなるかもしれません。 しかしそれは簡単には書けません。何故ならmapはコンテナ型、つまり「型引数を取る型」に定義される型だからです。 現在のRustは「型引数を取る型」に対するジェネリクスはサポートしていません。もし書こうとするとこのようになるでしょう。\ntraitMappable\u0026lt;M\u0026lt;_\u0026gt;,T\u0026gt;whereSelf: M\u0026lt;T\u0026gt;{fn map\u0026lt;U,F: FnOnce(T)-\u0026gt; U\u0026gt;(self,f: F)-\u0026gt; M\u0026lt;U\u0026gt;;} M\u0026lt;_\u0026gt; なんて型パラメータを書くことは出来ませんしM\u0026lt;T\u0026gt;やM\u0026lt;U\u0026gt;も無理があります。残念ですね。\nIterator との違い さて、Iteratorにもmapはあります。 これこそが求めている「.map 可能なトレイト」ではないのでしょうか。 これはおおよそは合っているのですがやや期待とは違う動作をします。\nOptionのmapは不自由なく使えます。\nleto=Some(1);leto=o.map(|i|i+1);println!(\u0026#34;{:?}\u0026#34;,o); 一方、Vecは全く同じような書き方は出来ません。\nletv=vec![1];letv=v.map(|i|i+1);println!(\u0026#34;{:?}\u0026#34;,v);\u0026lt;anon\u0026gt;:3:11: 3:25 error: no method named `map` found for type `collections::vec::Vec\u0026lt;_\u0026gt;` in the current scope \u0026lt;anon\u0026gt;:3 let v = v.map(|i| i + 1); ^~~~~~~~~~~~~~ \u0026lt;anon\u0026gt;:3:11: 3:25 note: the method `map` exists but the following trait bounds were not satisfied: `collections::vec::Vec\u0026lt;_\u0026gt; : core::iter::Iterator`, `[_] : core::iter::Iterator` error: aborting due to previous error playpen: application terminated with error code 101 正しくは、こうです。\nletv=vec![1];letv: Vec\u0026lt;i32\u0026gt;=v.iter().map(|i|i+1).collect();println!(\u0026#34;{:?}\u0026#34;,v); 色々実装上のノイズが乗っているのでやや例として不適切だったかもしれませんが、注目して欲しい部分はここです。\nletv: Vec\u0026lt;i32\u0026gt;=... Vecから取り出したイテレータなのにVecに戻すためにわざわざ型アノテーションを書く必要があります。\nどうしてこうなるかというとイテレータを取り出した時点で元のコンテナ型がVec\u0026lt;\u0026gt;であるという情報が失われているからです。 これはRustの型システム上どうしても仕方のないことで、なので恐らくRustは「map可能なトレイト」などを定義せず、コレクションの操作をIteratorに集約しているんだと思います。 この方式はある程度は上手くいきますがOptionやResultはIteratorになれはしてもIteratorからは作れない(2要素のイテレータからOptionは作れない)ので独自でmapメソッドを持つことになってしまいます。\nmap 可能なトレイト again 先程そういうのは作れないと言ったばかりですが実はどうにかする方法がなくもないです。先程の(仮想の)定義を思い出して下さい。\ntraitMappable\u0026lt;M\u0026lt;_\u0026gt;,T\u0026gt;whereSelf: M\u0026lt;T\u0026gt;{fn map\u0026lt;U,F: FnOnce(T)-\u0026gt; U\u0026gt;(self,f: F)-\u0026gt; M\u0026lt;U\u0026gt;;} ジェネリクスになっている登場人物はM\u0026lt;_\u0026gt;、U、T ですね。しかしM\u0026lt;_\u0026gt;は実際にはそのまま使われいる訳ではなくM\u0026lt;T\u0026gt;またはM\u0026lt;U\u0026gt;の形でのみ使われています。 では、M\u0026lt;T\u0026gt;、M\u0026lt;U\u0026gt;をパラメータに取るようにしてはどうでしょうか。\ntraitMappable\u0026lt;T,MT\u0026gt;whereSelf: MT{fn map\u0026lt;U,MU,F: FnOnce(T)-\u0026gt; U\u0026gt;(self,f: F)-\u0026gt; MU;} これで出来…てません。これは欲しい、正しいもの も 作れてはいるのですが正しくないものも含んでいます。\nimpl\u0026lt;T,MT: Option\u0026lt;T\u0026gt;Mappable\u0026lt;MT,T\u0026gt;forOption\u0026lt;T\u0026gt;{fn map\u0026lt;U,MU,F: FnOnce(T)-\u0026gt; U\u0026gt;(self,f: F)-\u0026gt; MU{...}}letr: Result\u0026lt;String,()\u0026gt;=Some(1).map(|i|i.to_string()); Option に対するmapをResultで受けようとしています。 これはもちろんおかしなことですが上記の型定義に従うとこういうことが出来てしまいます。 もうちょっというと上のトレイトの定義はこういう「おかしなこと」が起こるような実装をしろ、と言っている訳で、実際には実装出来ません。\n本来なら自由パラメータが3つなのに4つの自由パラメータを取ってしまったので不整合が起きる訳です。 では、自由パラメータを3つにして1つを従属パラメータにしてはどうでしょうか。それは関連型を使えばRustでも出来ます。\ntraitMappable\u0026lt;T,U,MT\u0026gt;whereSelf: MT{type MU;fn map\u0026lt;F: FnOnce(T)-\u0026gt; U\u0026gt;(self,f: F)-\u0026gt; Self::MU;} 実は、これである程度上手くいきます。 もちろん、実際にM\u0026lt;_\u0026gt;を取れるのに比べると不自由で下手をするとバグる(MUを無関係な型に定義できてしまう)可能性があるのですが、先程の4パラメータの時と比べて トレイトが定義された時点で返す型は決まっているのでちゃんと実装出来ますし、使う時に不整合が起きることもありません。\nHKT さて、先のMappableの仮想定義、map関数を除いて汎用的にするとこうなりますね。\ntraitHKT\u0026lt;T,U,MT\u0026gt;whereSelf: MT{type MU;} Self: MT というアノテーションをつけてますが実際には使えません。implを書くときに気をつけて実装するしかないです。なのでこうなります。\ntraitHKT\u0026lt;T,U\u0026gt;{type MU;}impl\u0026lt;T,U\u0026gt;HKT\u0026lt;T,U\u0026gt;forOption\u0026lt;T\u0026gt;{type MU=Option\u0026lt;U\u0026gt;;} さて、こう書くとするとこういうことも出来てしまいます。\ntraitHKT\u0026lt;T,U\u0026gt;{type MU;}impl\u0026lt;S,T,U\u0026gt;HKT\u0026lt;T,U\u0026gt;forOption\u0026lt;S\u0026gt;{type MU=Option\u0026lt;U\u0026gt;;} Tとは独立なSに対するコンテナに対して実装できてしまうのです。「実装するときに気をつける」とはいいましたが制約を書けるなら書いた方がいいです。こうしましょう。\ntraitHKT\u0026lt;U\u0026gt;{type T;type MU;}impl\u0026lt;T,U\u0026gt;HKT\u0026lt;U\u0026gt;forOption\u0026lt;T\u0026gt;{type T=T;type MU=Option\u0026lt;U\u0026gt;;} これで冒頭に紹介したHKTの実装になりました。\n逆にこのHKTの実装からMappableを定義するには、こうです。\ntraitMappable\u0026lt;U\u0026gt;: HKT\u0026lt;U\u0026gt;{fn map\u0026lt;F: FnOnce(Self::T)-\u0026gt; U\u0026gt;(self,f: F)-\u0026gt; Self::MU;} HKTについてもっと ようやく話題のHKTの元実装です。こちら。\nHigher-kinded type trait\nずいぶんとモナモナしいですがやはり高階型を使った一番実績のある構造はこのあたりでしょう。\nこういうのを扱えるとプログラミングの幅が広がりますね。\nノート  モナドの話題が出ましたがRustでモナドを実現するには高階型だけでなく複数ある関数トレイトのどれを選ぶかだとかその他諸々の問題を扱う必要があるようです。 Rust and the Monad trait - Not just higher kinded types · m4rw3r ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2016-02-28","title":"RustのHigher-Kinded type Trait","url":"https://KeenS.github.io/blog/2016/02/28/rustnohigherkinded_type_trait/"},
  {"body":"κeenです。社内ハッカソンに出てきた。そこでdruidというツール（？）を触ったのでそれについて。\n読み方は「ドゥルイド」でいいのかな？公式ページはこちら。Metamarketsが主導で開発しているようで、オープンソースになっている。\n公式サイトを少し回遊してもらうと分かると思うが、時系列データを分散環境でストリーミング処理出来るツール。分散環境で動くだけあってコンポーネントはいくつかある。\n主にはストリーミングデータを取り込む「REALTIME」、クライアントからのクエリを処理する「BROKER」、過去のデータを処理する「HISTORICAL」があるようだ。 BROKERがDEEP STORAGE(s3などの永続データストア)にデータを保存し、HISTORICALがオンデマンドにそのデータを読み出してBROKERに返す。\nイメージとしてはこんな感じだが、実際に動かすのには他のコンポーネントも必要で、分散環境に必須なZookeeperが必要なのはもちろんのこと、全体を司る「COORDINATOR」、取り込んだデータのメタデータを保存する「METADATA STORAGE」も必要になる。\n画像の出展はこちら。\n中々に大仰なアーキテクチャだがどのみちリアルタイムデータ分析基盤を作ろうと思うとこれくらい必要になる。それを1まとめにしてディストリビュートしてくれるdruidを使った方がなんぼか近道な気はする。\nさて、これを1インスタンスで動かそうと思うと、DEEP STORAGEはローカルファイルシステム、METADATA STORAGEは組込みのDerby DBでまかなえ、REALTIMEはデータを取り込む時にのみ必要なのでZookeeper、Coordinator、Broker、Historical、都合4つのJava製ミドルウェアを起動すればどうにか使える。 これら合わせても2GBくらいのメモリしか必要なかったので十分手元で動く。\nさて、このDruid、どういうことが出来るかというとクエリに注目すれば「Group By付きのAggrigation Functionを高速に動かす」が主な目的だろうか。他にも色々あるが。 BIツールや他のダッシュボードツールなんかと連携してストリーミングデータをリアルタイムに可視化するのに一役買う。YahooやAlibabaなんかでも使われているようだ。 例えばDruidをサポートするダッシュボードツール、panoramixなんかもある。\n今回のハッカソンはGCPがテーマで、Cloud Pub/Subからデータを取り込むことになったがDruidにはPub/Subからデータを取り込むREALTIMEがない。ということでハッカソンでPub/Sub extensionを作った。 メーリスに投稿して様子を覘った上でコードを整理してプルリクを出す予定だ。 拡張は思ったよりも作りやすく、ドキュメントを読まなくても既存のKafka拡張を参考にするだけで書けた。まあ、その後苦労したが。\nはじめて使うDBのプラグイン書いたらデータのロードは出来たもののクエリの投げ方が分からずに入ったデータを確認出来ない…っ…\n\u0026mdash; κeen (@blackenedgold) 2016年2月26日 \n今回作ったのはFirehose Pluginと呼ばれるものだが、他にもプラグインの種類は色々あるみたいだ。 しかしFirehose Pluginの基底クラスはあまりストリーミングデータのインポートには良くない気がする。FirehoseV2というのがあって、それが良いインターフェースになっていたが使い方が分からなかった。\n今が0.9.0-SNAPSHOT。1.0.0が出る頃が楽しみだ。\n","categories":["druid","DB"],"category_urls":["/categories/druid","/categories/db"],"date":"2016-02-27","title":"druidというリアルタイムデータ分析ツールを知った","url":"https://KeenS.github.io/blog/2016/02/27/druidtoiuriarutaimude_tabunsekitsu_ruwoshitta/"},
  {"body":"κeenです。小ネタを。サーバを立ち上げる時に指定するBind Addressについてよく分かっていなかったのがようやく分かるようになったのでそれについて。\nBind Addressはサーバ(特にHTTPサーバ)を立ち上げる時によく指定することになりますが、Usageを見ても「バインドするアドレスを指定する」などとトートジーめいたことしか書いてありませんでした。 実際に使ってみても127.0.0.1を指定すればローカルホストから、0.0.0.0を指定すれば外部からでも参照出来るな、くらいの認識しかありませんでした。 意味も分からず使っていると気持ち悪いもので、2つの疑問が湧いてきます。\n 0.0.0.0と127.0.0.1は正確に何を意味するのか 127.0.0.1と0.0.0.0以外のアドレスを指定するのはどのようなケースか  もちろん、127.0.0.1がlocalhostを指すことは知っていますが0.0.0.0というアドレスはBind Addressでしか見たことありませんし、127.0.0.1が私の知っているlocalhostの意味でない可能性も十分あるな、と思っていました。\nさて、この疑問に答えるには前提知識が必要なのでそこから始めましょう。\nマシンは複数のIPアドレスを持ちうる 1つのマシンに、複数のIPアドレスが割り当てられることがあります。 典型的なのはルータのようにインターネットとローカルエリアネットワーク両方に参加しているもので、LANには「192.168.1.1」、インターネットには「www.xxx.yyy.zz」という2つのIPアドレスを持つでしょう。 また、どのマシンにも先程述べたlocalhost、127.0.0.1という内部から自身を指すIPアドレスもあります。 図にするとこんな感じでしょうか。\n [インターネット] | | | www.xxx.yyy.zz [x 127.0.0.1] ルータ | 192.168.1.1 | ...-+--+ | 192.168.1.2 [ 127.0.0.1]マシンA さて、この時に例えばルータの管理WebUIを提供したいとしましょう。このUIは勿論LAN内にいるマシンAからは参照したいですがインターネット全てに公開する訳にはいきません。 こういう時のアクセス制御に使うのがBind Addressです。\n呼ばれ方で反応を変える bind addressは、他のマシンから何という名前で呼ばれたかでメッセージを受け取る/受け取らない（というか見える見えない）を変えるものです。 街中で「田中さん」と呼ばれたら返事したいけど「†漆黒の天翅†さん」と呼ばれたら返事したくないですよね。 少し実験してみましょう。\nさて、私の手元のマシンはifconfigによると127.0.0.1というアドレスと192.168.1.6というアドレスを持っているようです。\n$ ifconfig lo Link encap:ローカルループバック inetアドレス:127.0.0.1 マスク:255.0.0.0 inet6アドレス: ::1/128 範囲:ホスト UP LOOPBACK RUNNING MTU:65536 メトリック:1 RXパケット:5132 エラー:0 損失:0 オーバラン:0 フレーム:0 TXパケット:5132 エラー:0 損失:0 オーバラン:0 キャリア:0 衝突(Collisions):0 TXキュー長:0 RXバイト:665331 (665.3 KB) TXバイト:665331 (665.3 KB) wlp3s0 Link encap:イーサネット ハードウェアアドレス cc:3d:82:38:21:e2 inetアドレス:192.168.1.6 ブロードキャスト:192.168.1.255 マスク:255.255.255.0 inet6アドレス: fe80::ce3d:82ff:fe38:21e2/64 範囲:リンク UP BROADCAST RUNNING MULTICAST MTU:1500 メトリック:1 RXパケット:85578 エラー:0 損失:0 オーバラン:0 フレーム:0 TXパケット:64002 エラー:0 損失:0 オーバラン:0 キャリア:0 衝突(Collisions):0 TXキュー長:1000 RXバイト:85393847 (85.3 MB) TXバイト:10710856 (10.7 MB) HTTPサーバをそれぞれにbindしてみます。今回使うのはRubyのコマンドラインから使えるHTTPサーバです。\nまずは127.0.0.1。\n$ ruby -run -e httpd -- ./ --port 8080 --bind 127.0.0.1 こんな感じですかね。\n+-------+ | | | +-+ 127.0.0.1 |ruby-+ | | + 192.168.1.6 +-------+ さて、これにcurlでアクセスしてみます。\n$ curl 127.0.0.1:8080 結果が返ってくる$ curl 192.168.1.6:8080 curl: (7) Failed to connect to 192.168.1.6 port 8080: 接続を拒否されました 次に192.168.1.6を試します。\n$ ruby -run -e httpd -- ./ --port 8080 --bind 192.168.1.6 これもこんな感じですかね。\n+-------+ | | | + 127.0.0.1 |ruby-+ | | +-+ 192.168.1.6 +-------+ 同じくcurlでアクセスしてみます。\n$ curl 127.0.0.1:8080 curl: (7) Failed to connect to 127.0.0.1 port 8080: 接続を拒否されました$ curl 192.168.1.6:8080 結果が返ってくる 見事にbindしたアドレスに投げた時にしか結果が返ってきません。 また、無関係なアドレス、例えば192.168.1.2などにbindしようとするとこうなります。\n$ ruby -run -e httpd -- ./ --port 8080 --bind 192.168.1.2 [2016-02-25 00:36:17] INFO WEBrick 1.3.1 [2016-02-25 00:36:17] INFO ruby 2.1.5 (2014-11-13) [x86_64-linux-gnu] /usr/lib/ruby/2.1.0/socket.rb:206:in `bind\u0026#39;: Cannot assign requested address - bind(2) for 192.168.1.2:3000 (Errno::EADDRNOTAVAIL) どうやら正確に自分のアドレスでないとbind出来ないようです。\n0.0.0.0はワイルドカード さて、これで正確に何という名前で呼ばれたかでアクセスを制御出来るようになりました。しかし公開サーバのように「どこからでも」アクセスさせたい場合にこと細かく指定させるのは不便です（というか複数のネットワークから参照することが出来なくなる？）。 その「どこからでも」を表すのが0.0.0.0です。\n試してみます。\n$ ruby -run -e httpd -- ./ --port 8080 --bind 0.0.0.0 こうなっているのでしょうか。\n+-------+ | | | +-+ 127.0.0.1 |ruby-+ | | +-+ 192.168.1.6 +-------+$ curl 127.0.0.1:8080 結果が返ってくる$ curl 192.168.1.6:8080 結果が返ってくる$ curl 0.0.0.0:8080 結果が返ってくる このようにどのような指定方法でも返ってきます。 curl 0.0.0.0:3000で結果が返ってきた(0.0.0.0が自身を指す)ことに驚きましたがワイルドカードアドレスにbindされた時にだけ結果が返ってきて欲しい時に便利なんですかね。\nまとめ Bind Addressは本当にBindするAddressでした。足りないのはBind Addressに対する知識ではなくネットワークに対する知識でした。 世の中知らないといけないことが多い。\n","categories":["network"],"category_urls":["/categories/network"],"date":"2016-02-24","title":"Bind Addressの意味がようやく分かった","url":"https://KeenS.github.io/blog/2016/02/24/bind_addressnoimigayouyakuwakatta/"},
  {"body":"# ClojureでSSPを作った話 ---------------------- === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバーエージェントのエンジニア + Lisp, ML, Rust, Shell Scriptあたりを書きます === # SSPとは ------- ※今回作ったものの話なので実際は少し違う * Supplier Side Platform * メディアからの広告リクエストを受けて表示権をオークションに掛け、落札された広告を表示する 0. 広告リクエストを受け取って 1. 各DSPに競りの通知を投げて 2. 入札を受け取って 3. 落札者と落札価格を決めて 4. 落札通知を出す === # アドテクコンペ --------------- * [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380) * サイバーエージェントの学生向けインターン * 3日間、3、4人のチームで **DSP** を作る * 学生は7チーム、1チームあたり2000q/sを捌くことになってる * 学生のDSPを繋ぐための **SSP** が必要になったので作ることに。 ===   日本におけるアドテク市場とサイバーエージェントのアドテク事業について  from CyberAgent, Inc.  === # 作るもの ---------- * 各DSPに競りの通知(HTTPリクエスト)を投げる大規模HTTPクライアント + 各DSPが2000q/s x 7チーム + 落札通知 = 16000q/s + 丁度2000q/sになるような制御も必要 * 入札を受けてのオークション、結果のロギングなど * 管理画面 === # s7pについて ------------- * 今回作ったSSP * [KeenS/s7p](https://github.com/KeenS/s7p) * Clojure製 * 3日くらいで作った * やや粗い部分も === # 今日話すこと -------------- * なぜClojureか * 16000q/s出すための工夫 * 16000q/sに抑えるための制御 * 運用して困った話とか === # なぜClojureか === # なぜClojureか --------------- * リクエストの数が多いので非同期IOは必須 * 100msでタイムアウトする仕様なのでタイムアウト処理も * もともとはScala(akka)で作ったs6pがあった * Actorの設計が良くなかったので遅かった * あと非同期HTTPクライアントにタイムアウトがなかった * プロダクションコードを流用したのでインターンが終わった後公開出来なかった * 別言語で書き直すにあたってGo, Clojure, Common Lisp, Rust, Erlangが検討された === # なぜClojureか --------------- * Common Lisp: 一番慣れてるが、非同期HTTPクライアント(とfutureライブラリ)が使いづらそうなのでやめた * Rust: とりあえずパフォーマンスは出そうだし使いたかったが非同期HTTPクライアントが見付からなかった * Clojure: そこそこ慣れてるし速そうな非同期HTTPクライアントがあった。core.asyncで非同期プログラミングもし易い * Erlang: 恐らく一番向いてるが、ほとんど経験がない * Go: 結構向いてそうだがあまり経験がないのでClojureを選んだ === # 16kq/s出すための工夫 === # 16kq/s出すための工夫 ------------------------ 非同期IO（一部同期しちゃったけど） ``` clojure (defn work [test req result] (- @dsps (sequence (comp ;; 全DSPにPOSTしてから(timeout 100ms) (map (fn [dsp] {:dsp dsp :response (http/post (:url dsp) (json-request-option req))})) ;; 結果を待ち合わせる (map destruct) ...)) ...)) .... ``` === # 16kq/s出すための工夫2 ------------------------ 一部同期したのでとにかくスレッド。スレッドへのディスパッチはチャネルで一発解決。 ``` clojure (defn worker [c] (thread ...)) ``` ```clojure (defn make-workers [ch n] (doall (map (fn [_] (core/worker ch)) (range n)))) ``` ``` clojure workers (manage/make-workers ch 1024) ``` === # 16kq/s出すための工夫3 ------------------------ ZeroMQを使ったmaster-slave構成 (最終的にSlave18台) ![master-slave構成図](/images/s7p/s7p.svg) === # 16kq/sに抑えるための制御 === # 16kq/sに抑えるための制御 --------------------------- * DSPの買い付け能力というビジネス的な問題ではなくサーバの負荷という技術的な問題による制御 * 1秒で160kクエリ投げて9秒休むとかは出来ない。もう少し細かく制御する必要がある。 * しかし制御をあまり細かくしすぎると今度はそこで遅くなりそう。 * リクエストを実際に投げるSlaveは分散してるけど統一した制御が必要 === # 16kq/sに抑えるための制御 --------------------------- Master側で100ms毎にに200個だけZeroMQのキューに積む ![QPS制御の図](/images/s7p/qps_control.svg) === # 16kq/sに抑えるための制御 --------------------------- 実装にはcore.asyncの `chan` と `timeout` を使用。(非同期プログラミング便利!) ```Clojure (defn start-query [sender reqs] (let [timer (timer 100)] (go-loop [] (let [t (=== # 運用して困った話とか --------------------- ## レスポンスが遅いDSPにSSPのパフォーマンスが引き摺られる * DSPが速ければ余裕を見ても10台あれば十分だった * DSPのパフォーマンスに仮定をおけないので上限ギリギリの18台 * 同期: 「DSP作ってる時はちょっとくらい待ってくれよ、って思ってたけどSSP運用したら遅いDSPガンガン切りたくなる気持分かった」 === # 運用して困った話とか --------------------- ## パフォーマンス検証が大変 * リクエストを捌くサーバのパフォーマンスをどうするか悩む * サーバをチューニングすればSSPも速くなるが、検証にならない * かといって投げたクエリを捌けないサーバに対して検証する訳にもいかない * 結局安全側に倒したパフォーマンス見積りに。 === # 運用して困った話とか --------------------- ## Masterがログ吐きすぎてDisk Full * 最初の予定ではMasterはディスクをそんなに使わなかったのでディスクの小さいインスタンスだった * ディスクスペース空けてMaster再起動で復旧。焦った。 === # 運用して困った話とか --------------------- ## timeoutし続けるDSPがいてSlave完全沈黙 * コネクションのクローズ待ちで固まってた * 該当DSPを切った上でSlaveの再起動で復旧 * カーネルのチューニングかtimeout頻度の検知が必要そう * timeoutを考慮に入れた構成にしてた筈なので想定外だった === # まとめ --------- * ClojureでSSP作ったよ * Clojure使えば非同期プログラミングが簡単に出来るよ * 運用って大変だよ === # 参考 ------- * [KeenS/s7p: sexp version of s6p; a toy SSP.](https://github.com/KeenS/s7p) * [ClojureでDSPを作った話 | κeenのHappy Hacκing Blog](http://keens.github.io/slide/ClojuredeDSPwotsukuttahanashi/) * [KeenS/b11d: A toy DSP](https://github.com/KeenS/b11d) * [アドテクコンペ | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/recruit/fresh/program_detail/id=11303\u0026season=2016) * [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380)   ","categories":["Clojure","Lisp","AdTech"],"category_urls":["/categories/clojure","/categories/lisp","/categories/adtech"],"date":"2016-02-22","title":"ClojureでSSPを作った話","url":"https://KeenS.github.io/slide/clojuredesspwotsukuttahanashi/"},
  {"body":"κeenです。なんか伏線っぽいもの回収しといた方が良いかなと思ってLinuxっぽい話でも。\nreadlineって便利ですよね。 でもCで書かれているから他の言語から使おうと思うと面倒だったり使えなかったりGPLv3の所為で使えなかったりしますよね。 そこである程度POSIXのインターフェースを扱わせてくれる言語でのreadlineの作り方でも。\nカノニカルモードとエコーモード readlineの仕組み自体は簡単で、全ての文字入力を受け取って、\n readlineの制御キーシーケンスなら指定の制御を行なう 普通の文字ならそのまま画面に表示する コントロールシーケンスなら ^W などとエスケープ表示する  これだけです。しかしそう簡単ではありません。 あなたのお気に入りの言語で readchar っぽい関数を実行してみると分かるかと思いますが、\n 一文字入力しただけではプログラムに入力文字が渡されない。エンターキーを押して初めてプログラムの readchar 関数が返る。 入力した文字がそのままエコーバックされる。すなわち、 ← を押しても ^[[D が入力されてしまい、制御上不都合。  私は昔はこれらの挙動が適切な関数がないからだと思ってました。しかし、そうではありません。 このような挙動をするのはプログラムの責任でもでもシェルの責任でもなくターミナルの責任です。\nターミナルには多彩なモードがあり、それによって挙動が変わるのです。 つまり、1.の挙動をするのはカノニカルモードの挙動、2.の挙動をするのはエコーモードの挙動なのです。\ntcgetattr と tcsetattr さて、ターミナルのモードはプログラム側から変更出来ます。それを行なうのが tcgetattr(3) と tcsetattr(3) です。 ざっくり言うと tcgetattr で現在のターミナルのコンフィグレーションを取得して、それを所望のモードに書き換え、 tcsetattr を使って反映出来ます。\n今回はカノニカルモードとエコーモードをoffにしたいのですごい雑なコードだとこう書けるでしょう。\n(require \u0026#39;sb-posix) (let* ((stdin 0) (termios (sb-posix:tcgetattr stdin)) (lflag (sb-posix:termios-lflag termios))) (setf lflag (logand lflag (lognot sb-posix:icanon))) (setf lflag (logand lflag (lognot sb-posix:echo))) (setf (sb-posix:termios-lflag termios) lflag) (sb-posix:tcsetattr stdin sb-posix:tcsadrain termios)) しかし、これは雑すぎます。なぜならreadlineを実行し終わった後にターミナルを元の状態に復元する必要があるからです。 そうしないとreadlineするつもりのない入力関数が予期せぬ挙動をするでしょう。 あるいはLispプロセスを終了した後のターミナルにまで影響が及びます。 なので 必ず 処理が終わったらターミナルの状態を復元する必要があります。\nさて、Common Lispではこの「必ず」は unwind-protect を使った with- マクロで実現するのが常套手段です。 コードはこのようになるでしょうか。\n(defmacro with-readline-mode (\u0026amp;body body) (let ((stdin (gensym \u0026#34;stdin\u0026#34;)) (old-termios (gensym \u0026#34;old-termios\u0026#34;)) (new-termios (gensym \u0026#34;new-termios\u0026#34;)) (lflag (gensym \u0026#34;lflag\u0026#34;))) `(let* ((,stdin 0) (,old-termios (sb-posix:tcgetattr ,stdin)) (,new-termios (sb-posix:tcgetattr ,stdin)) (,lflag (sb-posix:termios-lflag ,new-termios))) (unwind-protect (progn (setf ,lflag (logand ,lflag (lognot sb-posix:icanon))) (setf ,lflag (logand ,lflag (lognot sb-posix:echo))) (setf (sb-posix:termios-lflag ,new-termios) ,lflag) (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,new-termios) ,@body) (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,old-termios))))) これで\n(with-readline-mode (format t \u0026#34;~a~%\u0026#34; (read-char))) などとするとターミナルのモードが変わったことが実感出来るでしょう。\n尚、繰り返すとこれはターミナルの設定の話なのでEmacs内から試そうとしても正常に動作しない筈です。\nコントロールシーケンス さて、Common Lispの標準にない拡張機能が必要なのはターミナルのモード変更だけで、あとは好き勝手出来るのですが私も少し嵌った部分があるのでそこだけ。\nreadlineに欲しい機能はなんでしょうか。色々あるかと思いますが、まずは ← 、 → でカーソル移動をしたいのではないでしょうか。 実はこれが大落し穴。\n← キーを押すとターミナルにはなんと3文字入力されます。すなわち、 Esc文字の ^[ 、普通のASCII文字の [ 、そして大文字の D です。\nそしてカーソルの移動文字を受けてカーソルを移動するにはターミナルにそのままEsc文字の ^[ 、普通のASCII文字の [ 、そして大文字の D を入力してあげれば出来ます。\nなのでこのようなコードになるでしょう。\n(defconstant left \u0026#34;\u001b[d\u0026#34;) (defconstant right \u0026#34;\u001b[c\u0026#34;) (defun left () (format t \u0026#34;~a\u0026#34; left) (force-output)) (defun right () (format t \u0026#34;~a\u0026#34; right) (force-output)) (defun readline () (let ((line \u0026#39;())) (flet ((self-insert (char) (format t \u0026#34;~c\u0026#34; char) (setf line (cons char line)) (force-output))) (with-readline-mode (loop (let* ((char (read-char)) (code (char-code char))) (case code ; escape ((#b11011) (let* ((char (read-char)) (code (char-code char))) ;; (write-line \u0026#34;called\u0026#34;) ;; (format t \u0026#34;~a~%\u0026#34; char) ;; (format t \u0026#34;~a~%\u0026#34; code) (case char ((#\\[) (let* ((char (read-char)) (code (char-code char))) (case char ((#\\c) (right)) ((#\\d) (left))))) ((t) (self-insert #\\escape) (self-insert char))))) ((#b1010) (return-from readline (coerce (reverse line) \u0026#39;string))) (t (self-insert char))))))))) case をネストしていくのはダルいし拡張性がないので現実的にはtrie木を使うことになるかと思いますが単純にはこのようなコードでreadlineを作れます。\nLet\u0026rsquo;s Happy Hacκking!\n付録A: 伏線 適当に魚と野菜炒めたらオサレっぽくなった pic.twitter.com/9IIzhIGjzd\n\u0026mdash; κeen (@blackenedgold) 2016, 2月 14 @blackenedgold 魚は何？タラ？だったら季節物だし、旬の鱈と野菜のソテー、詳解Linuxカーネルを添えて。と命名しよう\n\u0026mdash; Shinnosuke Takeda (@cnosuke) 2016, 2月 14 \n付録B: Pure Rubyなreadlineのソースコード 努力が必要ということが読み解ければ幸いです。\nrb-readline/rbreadline.rb at master · ConnorAtherton/rb-readline\n","categories":["Linux","Lisp","Common Lisp"],"category_urls":["/categories/linux","/categories/lisp","/categories/common-lisp"],"date":"2016-02-14","title":"readlineの作り方","url":"https://KeenS.github.io/blog/2016/02/14/readlinenotsukurikata/"},
  {"body":"先日、Pijulという分散VCSについて知って、それについて調べてみたら少し面白かったのでメモ。\nDVCSで一番有名なのは間違いなくGitだろう。あれは分散グラフ理論木モデルに基いているらしい。ベースになったモデルがあることに驚いたが、調べても出てこなかった。 Gitは高速で信頼性が高い一方、コミット同士をチェーンのように繋げてしまうので柔軟性を欠き、例えばCherry Pickなんかがやりづらい。 あるいはリモートのmasterを取り込まずにローカルのmasterにコミットすると互いに独立した変更であっても一旦remote masterをマージしないとプッシュ出来ず、コミットグラフが汚れてしまう。 また、CUIが直感的でなく、理解しづらいという声もある。それはこういう皮肉にも現れている\nまあ、言われてみれば私もこのスライドを見てようやく理解した。\n  コンセプトから理解するGitコマンド  from ktateish \n他のVCSにも色々特色はあって、歴史は神聖なるmercurial、履歴にアクセスしてこそのVCSなFossil、レポジトリとはパッチの集合であるDarcsなどなど。\nこの中でもDarcsは大きく毛色が違うように思える。レポジトリは依存関係のあるパッチの集合で、互いに独立なパッチは相互作用しない。なので上に挙げたcherry pickだとかremote vs localの問題とかが起きない。 それにパッチベースの管理なのでメールでパッチを送り合うような古いシステムでも困らない。少なくともforkしてpull requestよりはパッチを送った方がなんぼか筋は良い気がする。他のVCSがsnapshot-basedなのに対してdarcsはpatch-basedになる。\nさて、このDarcs、そこまで知らない人も多いかと思うが古くはGHCの開発に使われていたり(gitに移行した)、common-lisp.netで使われていたり(リニューアルの時に内部がgitlabになってdarcsサポートはドロップされた)した。 Haskellで書かれていたのとモデルが(理論的には)綺麗なので函数型な人達には人気があったようだ。\nDarcsを使っていたプロジェクトがGitに移行したことから分かるように、Darcsにも問題があった(らしい)。1つはパフォーマンスの問題で、Haskellで書かれていたので流石にCで書かれたGitには勝てなかった。 さらには、勘の良い人は気付いたかもしれないが、パッチ同士の依存関係だけで管理してるとマージの時に最悪計算量が $O(2^n)$ になる(多くの場合は $O(n)$ で済むらしい)。\nその他のDarcsの問題についてはこちらを参考されれば。\nGHC の開発の darcs から git への移行 - Togetterまとめ\nPijul 今回話題に出したPijulはDarcsに影響を受けている。レポジトリとは依存関係を持ったパッチの集合で、パッチ同士の関係はGitに比べれば薄いが、snapshot-basedとpatch-basedの両方の良い所を取り入れている。 Pijulの特色はA Categorical Theory of Patchesの成果を取り入れていて、Darcsにあった計算量の問題が改善している。 この理論はファイルを対象、パッチを射とした圏を考えると、互いにコンフリクトしないパッチは同時に適用出来てかつ適用の順序に依らないことは圏論に於ける「押し出し」に一致することに着目している。 さらにこのパッチ圏を拡張(余完備化)することでコンフリクトが起きないように出来る。\nさて、Pijulにすると何が嬉しいのかというと、色々ある。 Darcsのようにパッチベースな点は言わずもがな、パッチベースなのでパッチを作った後でブランチを切ることが出来る。 実際に作業をしてみてブランチの名前が不適切だったな、とかブランチを切る前に名前を考えるのに一瞬手が止まったりすることがない。 尚、Pijulの現バージョン(0.2)では内部構造的にはブランチを扱えるものの、インターフェースのコマンドがないため事実上ブランチは作れないらしい。 また、データの持ち方的にgit blame相当の機能が速いなどそれなりの特色を出している。\n開発言語もOCaml、Scala、Haskell、Cなどを試して今はRustがベストフィットだと落ち着いたらしい。 cargo install pijul でインストール出来る。 Rustで開発したお陰もあってDarcsより大分速いらしい。\nDarcsユーザには受けがいいようで、darcs to pijulブリッジも作られようとしているらしい。\n個人で使うには困らない程度にまで安定したら楽しみだ。\n","categories":["Git","Pijul"],"category_urls":["/categories/git","/categories/pijul"],"date":"2016-02-14","title":"分散VCSのモデル、あるいはPijulについて","url":"https://KeenS.github.io/blog/2016/02/14/dvcsnomoderu_aruihapijulnitsuite/"},
  {"body":"κeenです。先日中古のNexus 5を入手したのでUbuntu Touchをインストールしました。その時のメモ。 尚、Multi ORMなどを使ったマルチブートではなく完全にAndroidを殺したシングルブートです。\n色々調べてみましたが公式ドキュメントのままやるのが一番無難なようです。 まあ、スクショがないので他のサイトのスクショは参考にした方がいいかもしれませんが。\n途中adbを使ったりする部分も丁寧に解説してるのでAndroid初心者でも問題ないはず。\nツールの準備 Ubuntu公式で案外色々なツールを用意してくれている模様。\nsudo add-apt-repository ppa:ubuntu-sdk-team/ppa sudo apt-get update でppaを登録した後は\nUbuntu Touchインストールに必要なツール\nsudo apt-get install ubuntu-device-flash USBで繋いだデバイスをデスクトップから操作するのに便利なツール\nsudo apt-get install phablet-tools をインストールします。（恐らく）このコマンドでadbとfastbootも入ります。\nAndroidのUSBデバッグを有効にする 普段から自機でAndroidアプリを開発してない人はこのステップが必要でしょう。\n開発者モードの解放 [設定のアプリ] → [一般] → [端末情報] → [ソフトウェア情報]\nと進んで[ビルド番号]を7回タップすると開発者モードが解放されます。\n私がAndroid Appを作ってた頃(Android 2.3)にはこんな手順なかったんですけどいつのまにやら変わったんですね。\nUSBデバッグの有効化 さて、これで[一般]タブに戻ると[開発者向けのオプション]という項目が出てくるのでそこからUSBデバッグを有効にしましょう。\nNexus 5を繋ぐ USBケーブルでNexus 5をPCに繋ぎます。\nadb devices で1つデバイスが表示されていたらちゃんとデバッグモードで繋げています。\nAndroidデータのバックアップ Androidに未練はなくてももしUbuntu Touchのインストールに失敗した時に引き返せるようにバックアップは必要です。\nadb backup -apk -shared -all のコマンドでカレントディレクトリに./backup.abという名前でデータが吸い出されます。\nさらにAndroidの再インストールに必要なデバイスデータも取得します。\nadb shell grep ro.product.name /system/build.prop \u0026gt; mydevicedata \\ \u0026amp;\u0026amp; adb shell grep build.id /system/build.prop \u0026gt;\u0026gt; mydevicedata \\ \u0026amp;\u0026amp; adb shell grep ro.product.device /system/build.prop \u0026gt;\u0026gt; mydevicedata 中身はこんな感じ。\n$ cat mydevicedata ro.product.name=hammerhead ro.product.device=hammerhead ro.build.id=MMB29S ブートローダのアンロック そろそろ危いところですね。\nAndroidの再起動 \u0026amp; ブートローダへ突入。倒れたドロイド君が現れます。\nadb reboot bootloader そしてアンロックします。\nsudo fastboot oem unlock デバイス側で色々訊かれるので音量ボタンと電源ボタンを駆使して答えていきましょう。\n質問が終わってドロイド君の画面に戻ったら\nfastboot reboot します。これでAndroidは初期化されてるので最初のセットアップを済ませましょう。どうせ直ぐに殺すので最小限で大丈夫です。\nUbuntu Touchのインストール さて、ここは公式ドキュメントと異なる部分です。 公式サポートのチャネルではNexus 5がサポートされていません。 Ubuntu wikiにいくとコミュニティベースでホストされているイメージがあるのでそれを使います。\nubuntu-device-flash --server=https://system-image.ubports.com touch --channel=ubuntu-touch/stable --bootstrap まあまあな量ダウンロードしますが放置しておけばそのままubuntu touchのインストールが完了します。\nおめでとうございます。\n触ってみた所感 上下左右の端からスワイプインするとメニューとか諸々が出てくるのは面白い。特に左のメニューはUbuntu使いなら体に馴染む。 使い勝手は悪くなさそう。Android使いならすぐに馴染める。\nアプリはまだまだといった所。ストアのアプリも少なければCanonicalの公式アプリもWeb Appという仕上がり(Twitterがモバイル版Webそのままだった)\nUbuntu Touch nihongo utenai?\n\u0026mdash; κeen (@blackenedgold) 2016, 2月 9 \n一応パッチは出ている。\nMerge into trunk : japanese-keyboard-rebooted : Code : ubuntu-keyboard\n","categories":["Ubuntu Touch"],"category_urls":["/categories/ubuntu-touch"],"date":"2016-02-10","title":"Nexus 5にUbuntu Touchのインストール","url":"https://KeenS.github.io/blog/2016/02/10/nexus_5niubuntu_touchnoinsuto_ru/"},
  {"body":"κeenです。Common Lispから線形代数ライブラリを使うポストで比較にCommon Lispのコードが出されていたのですがもう少し改良出来そうだったので少しばかり高速化してみました。\nそのポストはこちら。\nCommon Lispで行列演算: LLA(Lisp Linear Algebra)を使う - 翡翠はコンピュータに卵を生むか\n圧倒的にCommon Lispが遅いですね。そのコードはこちらから。\nPython (NumPy) と Common Lisp (LLA) で行列積の実行速度を比較する - 不確定特異点\n行列計算(GEMM)部分を抜き出すとこうなっています。\n(defun simple-gemm (ma mb) \u0026#34;Common Lispのみを使った行列積の計算\u0026#34; (declare (optimize (speed 3) (debug 0) (safety 0))) (declare (type (simple-array single-float (* *)) ma mb)) (let ((rows (array-dimension ma 0)) (cols (array-dimension mb 1))) (declare (type fixnum rows cols)) (let ((result (make-matrix rows cols))) (declare (type (simple-array single-float (* *)) result)) (dotimes (row rows) (dotimes (col cols) (dotimes (k cols) (incf (aref result row col) (* (aref ma row k) (aref mb k col)))))) result))) これを*N* = 256, で100回繰り返したら\n;; Evaluation took: ;; 4.688 seconds of real time ;; 4.692000 seconds of total run time (4.688000 user, 0.004000 system) ;; 100.09% CPU ;; 13,564,728,093 processor cycles ;; 26,216,000 bytes consed とのこと。まあ、まだ高速化の余地はありそうです。\nキャッシュする 内側のループをみるとこうなっています。\n(dotimes (k cols) (incf (aref result row col) (* (aref ma row k) (aref mb k col)))) incfをばらすとこうなります。\n(dotimes (k cols) (setf (aref result row col) (+ (aref result row col) (* (aref ma row k) (aref mb k col))))) 値として参照している方の(aref result row col)はkに依存しないのでループの外に出せます。 書き込んでいる方は場所だから仕方ない。\nこれをキャッシュするようにすると\n(defun caching-gemm (ma mb) \u0026#34;Common Lispのみを使った行列積の計算\u0026#34; (declare (optimize (speed 3) (debug 0) (safety 0))) (declare (type (simple-array single-float (* *)) ma mb)) (let ((rows (array-dimension ma 0)) (cols (array-dimension mb 1))) (declare (type fixnum rows cols)) (let ((result (make-matrix rows cols))) (declare (type (simple-array single-float (* *)) result)) (dotimes (row rows) (dotimes (col cols) (let ((cell (aref result row col))) (dotimes (k cols) (setf (aref result row col) (+ cell (* (aref ma row k) (aref mb k col))))) ))) result))) 同じパラメータでベンチマークをとると\n;; 3.971 seconds of real time ;; 3.972000 seconds of total run time (3.972000 user, 0.000000 system) ;; 100.03% CPU ;; 11,491,319,119 processor cycles ;; 26,216,000 bytes consed 2016-02-28 追記:\n@blackenedgold キャッシュのところ、resultのインデックスにkは使ってないけど、kが進むごとに対象の要素は変化してるはずなので、このキャッシュのしかたはまずいのでは?\n\u0026mdash; goskevich (@gos_k) 2016年2月19日 \nということでこれは間違ってました。\nループアンローリング さて、先程の内側のループ、仕事が少ないですね。小さな仕事をチマチマループしてるとイテレーションコストが嵩みます。 1回のイテレーションでの仕事を増やすべく、ループアンローリングをしましょう。\nコピペはダルいのでまずはマクロを。\n(defmacro dotimes-unroll ((i n unroll) \u0026amp;body body) (let ((n_ (gensym \u0026#34;n\u0026#34;))) `(let ((,n_ ,n)) (do ((,i 0)) ((\u0026lt; ,n_ (the fixnum (+ ,unroll ,i))) (do ((,i ,i (the fixnum (1+ ,i)))) ((\u0026lt; ,n_ (the fixnum (1+ ,i)))) ,@body )) ,@(loop :repeat unroll :append (append body `((setq ,i (the fixnum (1+ ,i)))))))))) 少し試してみましょう。\n(dotimes-unroll (i 10 3) (format t \u0026#34;~%~a\u0026#34;) i) 0 1 2 3 4 5 6 7 8 9 よしよし。\nそれではこれを使ってアンロールします。\n(defun loop-unroll-gemm (ma mb) \u0026#34;Common Lispのみを使った行列積の計算\u0026#34; (declare (optimize (speed 3) (debug 0) (safety 0))) (declare (type (simple-array single-float (* *)) ma mb)) (let ((rows (array-dimension ma 0)) (cols (array-dimension mb 1))) (declare (type fixnum rows cols)) (let ((result (make-matrix rows cols))) (declare (type (simple-array single-float (* *)) result)) (dotimes (row rows) (dotimes (col cols) (let ((cell (aref result row col))) (dotimes-unroll (k cols 16) (setf (aref result row col) (+ cell (* (aref ma row k) (aref mb k col)))))))) result))) アンロール数は16が一番パフォーマンス出たようでした。\nさて、ベンチマークをしてみます。\n;; Evaluation took: ;; 3.847 seconds of real time ;; 3.848000 seconds of total run time (3.848000 user, 0.000000 system) ;; [ Run times consist of 0.012 seconds GC time, and 3.836 seconds non-GC time. ] ;; 100.03% CPU ;; 11,128,993,432 processor cycles ;; 26,216,000 bytes consed 辛うじて速くなってる…。因みにこれのパフォーマンスはCPUの命令キャッシュの状況に依存するので何度か試すとこれより速いスコアが出ることもあります。\nEvaluation took: 3.338 seconds of real time 3.340000 seconds of total run time (3.332000 user, 0.008000 system) [ Run times consist of 0.020 seconds GC time, and 3.320 seconds non-GC time. ] 100.06% CPU 9,657,259,219 processor cycles 26,248,768 bytes consed メモリアクセスしない さて、最初にキャッシュした時に書き込まれている方の (aref result row col) は場所だからキャッシュ出来ないといいました。まあ、それは正しいのですがループの中で毎回書き込む必要はありません。\nレジスタ上で計算を済ませて最後に書き込んであげれば十分です。\n(defun on-register-gemm (ma mb) \u0026#34;Common Lispのみを使った行列積の計算\u0026#34; (declare (optimize (speed 3) (debug 0) (safety 0))) (declare (type (simple-array single-float (* *)) ma mb)) (let ((rows (array-dimension ma 0)) (cols (array-dimension mb 1))) (declare (type fixnum rows cols)) (let ((result (make-matrix rows cols))) (declare (type (simple-array single-float (* *)) result)) (dotimes (row rows) (dotimes (col cols) (let ((res (aref result row col))) (dotimes-unroll (k cols 16) (setf res (the single-float (+ res (* (aref ma row k) (aref mb k col)))))) (setf (aref result row col) res)))) result))) これを試してみます。\n;; Evaluation took: ;; 2.302 seconds of real time ;; 2.304000 seconds of total run time (2.300000 user, 0.004000 system) ;; [ Run times consist of 0.008 seconds GC time, and 2.296 seconds non-GC time. ] ;; 100.09% CPU ;; 6,662,273,812 processor cycles ;; 26,216,000 bytes consed わお！急に速くなりました。 (* 100 (- (/ 4.688 2.302) 1)) ≒ 103、 100%近い高速化です。\nおわりに 特に深い意味はなかったのですがパタヘネに載っていたやつを試してみたくて遊んでみました。\n普通に行列計算したいなら線形代数ライブラリ使った方が良いと思います。\nノート  ループアンローリングの部分をイテレーションコストで説明しましたが他にも1ループ内の命令数が増えると組み合わせパズルのピースが増えるので最適化されやすくなります。まあ、SBCLは覗き穴最適化をほとんどしないのであまり意味ありませんが。気になる方はディスアセンブルしてみて下さい。 このあと、 (aref mb k col) がCPUキャッシュを無駄にしているという話からキャッシュサイズ毎に行、列を分けて計算するやり方を紹介しようとしたのですが逆に遅くなってしまいました。付録Aにコードを置いておきます。うーむ。 本当はさらにこのセグメント毎にスレッドに計算を投げて並列化したかったのですがセグメントで高速化しなかったので萎えて諦めました。 パタヘネ的にはSIMDも使うのですが深夜に近付いてきて面倒になったのでこの辺でやめました。Common Lisp(SBCL)からSIMD命令を使うには私の過去のエントリを参照して下さい。 本気で行列計算をしたいなら今回の $O(n^3)$ のアルゴリズムだけでなくStrassenのアルゴリズムやCoppersmith-Winogradのアルゴリズムも検討すべきです。  付録A (defun segmented-gemm (ma mb) \u0026#34;Common Lispのみを使った行列積の計算\u0026#34; (declare (optimize (speed 3) (debug 0) (safety 0))) (declare (type (simple-array single-float (* *)) ma mb)) (let* ((segment 16) (rows (array-dimension ma 0)) (cols (array-dimension mb 1)) (colseg (floor cols segment)) ktmp coltmp k col ) (declare (type fixnum rows cols)) (let ((result (make-matrix rows cols))) (declare (type (simple-array single-float (* *)) result)) (dotimes (row rows) (dotimes (ci colseg) (setf coltmp (the fixnum (* ci segment))) (dotimes (ki colseg) (setf ktmp (the fixnum (* ki segment))) (dotimes (cs segment) (setf col (the fixnum (+ coltmp cs))) (let ((res (aref result row col))) (dotimes (ks segment) (setf k (the fixnum (+ ktmp ks))) (setf res (the single-float (+ res (* (aref ma row k) (aref mb k col)))))) (setf (aref result row col) res)))))) result)))","categories":["Lisp","Common Lisp"],"category_urls":["/categories/lisp","/categories/common-lisp"],"date":"2016-02-04","title":"Common Lispで高速行列演算","url":"https://KeenS.github.io/blog/2016/02/04/common_lispdekousokugyouretsuenzan/"},
  {"body":"# Hash-Array Mapped Trie ---------------------- ~ イミュータブルで高速なハッシュマップ ~ サイバーエージェント AdTech Scala Meetup LT大会 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 基盤開発グループの新卒 + Lisp, ML, Rust, Shell Scriptあたりを書きます === # scala.collections.immutable.HashMap ------------------------------------- * 今日の話題。これの実装をみていく。 * イミュータブル * キー-バリューペア * 値を追加する度に新たなハッシュマップを作る === # HashMap ---------------- * `O(1)`のアクセス効率 * 空間効率は悪い * ハッシュ関数が定義出来れば何でもキーに使える * 普通はミュータブルに使う + 大量のメモリをアロケートするのでコピーはつらい === # メモリ効率悪そう？ ------------------------- ```scala val hash = HashMap.empty + (3 - 1) // +---+---+---+---+---+---- // | / | 3 | / | / | / | ... // +---+---+---+---+---+---- // | // +-+ // |1| // +-+ ``` === # メモリ効率悪そう？ ------------------------- ```scala val hash2 = hash + (2 - 2) // +---+---+---+---+---+---- // | / | 3 | / | / | / | ... // +---+---+---+---+---+---- // | // +-+ // |1| // +-+ //  Copy \"value3\" \\ \"very long ... key2\" - \"value2\" \\ \"very long ...key1\" - \"value1\" ``` === # HashMap vs TreeMap -----------------  HashMapTreeMap アクセス効率`O(1)``O(log(n))` イミュータブルな時の空間効率悪い(毎回コピー)良い(部分構造を共有) キーの比較定数回`O(log(n))`回 キーの要件Hash関数が定義されている全順序関数が定義されている  === # Hash-Array Mapped Trie ------------------------ * `O(1)`のアクセス効率 * 部分構造を共有してメモリ効率も良い * キーの比較は定数回 * Hash関数が定義されていればキーに出来る === # 動作 ------ * ざっくり言うと、「Hashして分割してトライ」 === # 動作 ------ ## Hashする * 40bitくらいの値が生成される ``` scala hash(\"key\") // = 0b10101101010101001010110101010100 ``` === # 動作 ------ ## 分割する * 下位から5bit毎に分割する + 5bit = 0 ~ 31 + 32分木になる ``` 11111 00010 10110 10101 01001 01011 01010 10100 ``` === # 動作 ------ ## トライ * 32分のトライ木になる * トライ木の実装は32bitのbitmapを使ったArray Mapped Trieを使う === (図が分かりづらいというか不適切) ``` 8 7 6 5 4 3 2 1 11111 00010 10110 10101 01001 01011 01010 10100 1 2 3 4 ... / 10100 ... \\ / \\ 01011 \\ / \\ \\ / 01001.... 01010 \\ ... ``` === # 特徴 ------ * ハッシュ値が固定長なので`O(1)`で動作 * Treeなので部分構造の共有が簡単 * 木を辿る時の比較はhash値（の一部）なので高速 * キーに全順序がなくてもハッシュ関数さえ定義されていれば木を構築出来る === # まとめ -------- * Scalaのimmutable.HashMapはコピーしても高速だよ * 裏で動くアルゴリズムを紹介したよ + ざっくりなので本物はもう少し工夫してる + prefix treeになってる === # 参考 ------ * PDF [Ideal Hash Trees](http://lampwww.epfl.ch/papers/idealhashtrees.pdf) + HAMTの元論文 * [HAMT(Hash Array Mapped Trie) - sileのブログ](http://sile.hatenablog.jp/entry/20100926/1285467529) + HAMTの解説ブログ * PDF [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections](http://michael.steindorfer.name/publications/oopsla15.pdf) + HAMTを改善したCHAMPというデータ構造の論文。Clojureにこれが入りそう。 * [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections | the morning paper](http://blog.acolyer.org/2015/11/27/hamt/) + CHAMPを解説したブログ   ","categories":["Scala","社内","Scala Meet Up"],"category_urls":["/categories/scala","/categories/%e7%a4%be%e5%86%85","/categories/scala-meet-up"],"date":"2016-01-31","title":"HAMT ~ イミュータブルで高速なハッシュマップ ~","url":"https://KeenS.github.io/slide/hamt/"},
  {"body":"κeenです。技術の話題を書くのは久し振りですね。今日初めてRustのパッケージのセントラルレポジトリ、crates.ioにパッケージを登録したのでその流れを共有します。\n登録したいパッケージを用意する file_loggeを作りました。 しばらく前に(Advent Calendar向けに)それっぽく動くところまで作って放置してたやつですね。これを整形していきます。\n(任意)ドキュメントを生成する Rustには素晴しき cargo doc があります。\n$ cargo doc --no-deps でドキュメントを生成しましょう。ドキュメントを書いてないならこちらを見ながら書きましょう（すいません、私の奴は全然書いてないです…）。 target/doc 以下に生成されたドキュメントがあるので適当に gh-pages ブランチに放り込みましょう。 尚、--no-deps オプションがないと依存パッケージのドキュメントも全部生成してしまいます。\n求: gh-pages管理のベストプラクティス。\nパッケージ情報を充実させる 普段使っているままの Cargo.toml だとcrates.ioで見た時に情報が全然ありません。 [package] セクションに色々書きましょう。私の場合は\n[package] name = \u0026#34;file_logger\u0026#34; version = \u0026#34;0.1.0\u0026#34; authors = [\u0026#34;Sunrin SHIMURA (keen) \u0026lt;3han5chou7@gmail.com\u0026gt;\u0026#34;] から\n[package] name = \u0026#34;file_logger\u0026#34; version = \u0026#34;0.1.0\u0026#34; authors = [\u0026#34;Sunrin SHIMURA (keen) \u0026lt;3han5chou7@gmail.com\u0026gt;\u0026#34;] repository = \u0026#34;https://github.com/KeenS/file_logger\u0026#34; keywords = [\u0026#34;log\u0026#34;, \u0026#34;file\u0026#34;] license-file = \u0026#34;LICENSE\u0026#34; readme = \u0026#34;README.md\u0026#34; description = \u0026#34;A simple logger backend that outputs to a file. \\nThis is alpha state.\u0026#34; documentation = http://KeenS.github.io/file_logger/file_logger/ になりました。 あ、ちゃんとライセンスも明示しましょうね。\nどういう情報が書けるのかはここに載ってます。\ncrates.ioにログインする [crates.io]()に行き、右上にあるGitHubログインボタンをクリックします。\nそうするとログイン状態になります\nメニューから\nAccount Settingsに飛ぶと下記のようにログイン用cargoコマンドが提示されるのでそのままペタっとコマンドラインに貼って終了です。\nパッケージング $ cargo package crates.ioに登録する $ cargo publish その他 パッケージに含めるファイルを細かく調整したい、既にpublishしたパッケージをdeprecated的な扱いにしたいなどはこちらにドキュメントが載っています。\nまとめ  crates.ioにログインしたよ Cargoを使えば簡単にパッケージを登録出来るよ Cargoってすごいね ","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2016-01-31","title":"Rustのパッケージをcrates.ioに登録する","url":"https://KeenS.github.io/blog/2016/01/31/rustnopakke_jiwocrates_ionitourokusuru/"},
  {"body":"κeenです。昨日、Lisp Meetup #36が行なわれました。1回テックトークを挟んでるのでこれでちょうど丸3年、毎月Lisp Meetupが行われたことになります。\nLisp MeetupはShibuya.lispが基本、毎月開催している草の根活動で、Lisper同士の交流を目的として主に希望者によるトークをメインとした会です。\n毎月Common Lisp、Clojure、Scheme回でローテーションしていて、近頃はScheme回にSchemerが来ないことからScheme回を減らして運用されています。 最初に述べた通りLisp Meetupだけで36回、丸3年活動してきました。ここ最近は定員にギリギリまで人が集まるくらいの盛況で何よりです。 ここまで継続したことを祝って記念ステッカーを作りました。私はほとんど何もしてませんが。@potix2さんに感謝。\n今日のLisp Meet Upは3周年記念ですね。先程ステッカー届きました。 pic.twitter.com/IRKkKVnkeU\n\u0026mdash; κeen (@blackenedgold) 2016, 1月 26 私が初めて参加したのは第7回から、運営になったのが1年後の第19回から(の筈)。 2年半サイバーエージェントの会場に通って気付いたらサイバーエージェントの社員になって、一勉強会がここまで大きく人生に影響するのかと感慨に耽る次第です。 何を大袈裟に、と思うかもしれませんがプログラミング経験が調子に乗ってきた時とLisp Meetupに参加し始めた時期が重なるので個人的には感慨に耽るだけのものがあるのです。\nさて、他のメジャーな言語の勉強会でも中々聞かない3周年ともなるとまた別種の問題も出てくる訳です。 その1つが「固定化」問題です。1度もLisp Meetupに来たことのない方はこう思う訳です: 何度も回を重ねる内にメンバーが固定化されて一見さんお断りな雰囲気になってるんじゃないかと。 実際のところLisp Meetupにはそんな雰囲気はなく、何度も来てる人もいれば久しぶりに来た人、最近よく来る人、初めて来る人色々いる訳です。 実情がどうあれ、お尻の数字が大きいだけで一番来て欲しい初心者が来なくなるならと、一度は名前を変えて連番をリセットしようかとも話されましたが結局今のLisp Meetupのままでいます。 Lisp Meetupといえば私のようによく分からない発表をしてても暖かく受け入れてくれる優しい人達の集りなのですが、とはいえ外から見て「初めての勉強会でLisp Meetupは怖い」などと言われると中々考えることがあります。 まあ、それでも初心者や初参加の人は毎回数人は来てるのでこれ以上増やそうとするとこれより大きな会場を確保する必要があって中々ハードルは高いのですが。初心者は大歓迎ということは伝えておこうかと思います。\nさて、次回はClojure回です。そろそろScheme回を…と思ったのですが発表者が集りそうにないので見送られました。\n少し気の早い話ですが来月2月の #lispmeetup でSchemeをテーマにするとしたらみなさんどうですか\n\u0026mdash; κeen (@blackenedgold) 2016, 1月 17 \n3月には開催しようかと話し合われている最中なのでSchemer各位、SICP読書中の各位は準備をして開催して欲しいオーラを出して頂けると開催決定の後押しになります。\nということで来月以降もLisp Meetupをよろしくお願いします。\n","categories":["番外編","Lisp"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8","/categories/lisp"],"date":"2016-01-27","title":"Lisp Meetup3周年に寄せて","url":"https://KeenS.github.io/blog/2016/01/27/lisp_meetup3shuunenniyosete/"},
  {"body":"今まで読んできた技術書の中で良かったものを挙げていく。 そろそろ本棚が溢れるので捨てる前に書き留めておく。\n私は独学でプログラミングを始めたので情報系専攻の人には何をそんなという本も混っているだろうが価値は人それぞれ違う。\n一応私自身について語っておくと学生時代はプログラミングに興味を持ちつつも数学科に進んだ。 しかしそこでもプログラミングへの興味は薄れず、色々本を読んだり同学年の情報科学科の真似をしたりしていた。 今思えば日本の精鋭たる東大情報科学科の人達に勝てる筈もなかったのだが学生時代に我武者羅になれたのは悪い経験ではなかった。 私が興味があったのは主にプログラミング言語そのもの、特にLispとその周辺。\n何故本か 挙げていく前に1つだけ。Webに大量に情報がある今、何故本かについて説明したい。簡潔に言うと\n 文章が推敲されていて読み易い 1つの情報ソースに多彩な内容が載っている 巨大な情報の中で一貫性が取れている 出版されている以上ある程度内容に責任を持って書かれている  どれもWebの情報は断片的で無責任に書かれているような書き方だが凡そ間違ってはいないと思う。 私のブログだってよく間違いが書いてある（そして申し訳ないことに面倒くさがって修正しないままのことも多々ある）。 本屋に足を運んでパラパラ捲って気に入った本を買うのが一番確実な情報収集の仕方だと思う。勿論本だけでは足りないことも多いが。\nでは、本を挙げていく。順不同で、本棚を見ながらあれこれ挙げることにする。\n1. 作りながら学ぶRuby入門  この本は私がプログラミングを学び始めた時にお世話になった。初心者には0からアプリケーションを作るまでのノウハウがない。それを丁寧に教えてくれる。 よく「プログラミングを始めたいんですがどうやって覚えました？」と聞かれるが、毎度この本と下記の逆引きを勧めている。\nもしかしたらRubyのバージョンが古くてサンプルコードが動かないかもしれない。\n2. Ruby逆引きハンドブック  私の人生を変えたともいうべき1冊。プログラミングを英作文に例えるならこの本は和英辞典にあたる。 そして初心者にとっては「○○したいから□□する」は「へー。○○したいという需要があるんだ、そして□□で出来るんだ」と同時に2つを教えてくれる。 この1冊前部読むことでRubyを書くときの手札を確認出来た。\n惜しいことにこの本も少し古くなってきた。\n3. メタプログラミングRuby  Rubyをやるならこの本を一度は読んだ方がいい。method_missingなどRubyコミュニティでは非常に重要なテクニックが載っている。私は初版を読んだが第2版が出ているようだ。\n4. Emacsテクニックバイブル  るびきちさんの本を紹介したのでついでにこの本も。Emacsの便利な使い方から人気プラグインまで様々に解説されている。Emacsを使い熟したい方にお勧めする(そして私のように帰ってこれなくなるといい。)。 今ではいくつか動かない/入手出来ないプラグインはあるものの基本的な使い熟すための指南というか思想は色褪せない。\n5. Emacs Lispテクニックバイブル  同じくるびきちさんの本。コピペだけでinit.elを書くのが嫌な人、片手間程度でもEmacs Lispを書く人にお勧めする。私もこの本を境にして片手間程度にEmacs Lispを書くようになった。 さらにComon Lisperである私にはCommon Lispマクロの解説が非常に分かりやすくて参考になった。\n6. 入門vi  例え熟練のEmacsユーザでもviは使えた方がいい。サーバに入った時にviしか使えないこともある。 Emacsをインストールしようにもインストールするための設定をviで書く必要がある。 nanoもあるが、リッチテキストエディタに馴れた手にはviの方が馴染む。\nそういう人に、この本は良い。Vim入門のようにごてごてしてなくて欲しい情報だけが書いてある。\n7. 実践Common Lisp  私はほぼRubyでプログラミングに入門したがRubyはLispを参考に作られたと言われたらその原典たるLispにも興味が出るのは自然の流れ。当然私もCommon Lispを始めた。 Common Lispに入門するにあたって一番お世話になった一冊。早見表もあれば関数の解説もあり、実践の名の通りアプリケーションを作るところまでいける。 Common Lispといえばまずこの本をお勧めする。\n8. Land of Lisp  オライリーの中でも異色の表紙で有名なこの本。このエイリアンはオライリーの本が出る前からLisp界隈で活躍していたりする。 モチーフは「他言語プログラマから見たLisper」なのでLisperのペットというようりはLisper自身。\n閑話休題。この本は実践Common Lispよりも易しいというか丁寧で、分かりやすく書いてある。 そしてちょこちょこゲームを作りながら進んでいくので飽きない。手を動かしたい人には本書を、後のリファレンスとしても役立てたい人には先の実践Common Lispをお勧めする。\n9. On Lisp  大半がマクロについて書かれているPaul Grahamのマクロの本。Common Lisp中級者向けの必読書。 Common Lispを使っていてマクロを書く必要が出てきたあたりでこの本を読むといいと思う。 変数捕捉の問題から逆に変数を捕捉させるアナフォリックマクロの話、マクロを使って作る継続と非決定性計算などなどが載っている。\n他言語プログラマでも非衛生的なマクロを持つ言語を使うならこの本を読むと良いと思う。私の知る限り世界で一番マクロに詳しい本だ。\nマクロの本とはいったがLisp流のボトムアッププログラミングを指南していたりオブジェクトシステムやパッケージについての解説があったりと中々役に立つ指南書でもある。 また、名言も多いのでLisp界隈でよく言われる元ネタを知りたい時にもいい。\n訳者が高校生の時に訳し始めたので日本語はやや読みづらい。Webで無料で公開されていたりする。\nOn Lisp\n10. LET OVER LAMBDA  過激な本。LOLの名で呼ばれる。Land of LispはLoL。一歩間違うと命を落しかねないので注意。「Common Lispこそが史上最高の言語だ」のスタンスで進んでいく。 LET OVER LAMBDA(lambdaの上のlet)とは、ラムダでletで作った変数を捕捉する話、クロージャの話をメインに据えている。 サーカスのようなプログラミングテクニックもあるかと思えば割と便利なツール、あるいはパフォーマンスチューニングについてなども載っていて、飽きない本。\n余談だが某所で「Land of Lispは聖典」と言われていたが本当にバイブル的な意味では先のOn Lisp、宗教的な意味ではこのLET OVER LAMBDAが聖典になると思う。\n11. Real World OCaml  Lispが函数型言語と言われいると他の函数型言語にも興味が出る。OCamlに半ば足を突っ込んでる時にこの本が公開されて読んだ。Webで草稿が公開されている。 普通に初心者に易しい内容だしコマンドラインのパースとか非同期プログラミングとかもあり充実満足な内容。 さらにランタイムシステムやコンパイラプラグインなどの深い話もあってOCaml上級者にも役に立つらしい（私はまだ初級者）。 数少ないOCaml書籍。オライリーでは唯一？\nこのノリでReal World Standard MLとか出ないかな、出ないよな。Standard MLの書籍少ない…。これくらい？\n 12. プログラミングErlang  どうせなら他の函数型言語も試してみるといい。例えばErlangとか。これは飛行機本として有名なErlangの入門書。Erlang作者のJoe Armstrongが著している。 Erlangのアクターモデルについて何も知らなくても恐れる必要はない。この本がついている。全くの初心者からErlangの考え方、ETS、DETS、OTP、Mnesiaなどを学べる。\n13. すごいErlangゆかいに学ぼう!  Erlang界隈では先の飛行機本が定本らしいが私はこのすごいE\u0026reg;本の方が肌に合った。ノリ良く進むしEUnitやDialyzerなどについても解説してある。 Erlang最高！なノリだが「うまい話ばかりじゃないですよ」とちゃんと現実も見ている。\n14. ７つの言語 ７つの世界  さらにプログラミング言語に興味を持ったならこの本を読むといい。様々な言語を広く浅くやっている。 普通のプログラマなら言語の10くらい書けるものだがCライクな言語10個書けたところで大したことはない。 比してこの本はそれぞれにパラダイムの違う言語を7つ紹介している。Ruby、Io、Prolog、Scala、Erlang、Clojure、Haskell。 Ioなんかは中々知っている人は少ないのではないだろうか。そういう言語に3日だけ触れてみるのも悪くない。\n15. Java言語で学ぶデザインパターン入門  人は、あまりに分かり易い解説を読むと初めてでも既知のように感じる。この本はそういう体験をさせてくれる。 プログラマとして生きる以上知っておかないといけないデザインパターンについて非常に分かりやすく丁寧に解説してある。 著者が物書きもしている結城先生なので日本語も非常に読み易い。\n大きな本だが解説を丁寧にするために膨らんでいるだけなので臆せず読んで欲しい。\n16. Java言語で学ぶデザインパターン入門 マルチスレッド編  マルチスレッドプログラミングは複雑で、書いてる本人すら状況を把握しづらい。 先にこの本を読んで基本的な考え方を身に付けているかいないかは大きく響く。 分かりやすい解説に加えて図解もあるので頭の中で動きをイメージしやすい。\n17. プログラミングコンテストチャレンジブック  いわゆる蟻本。プログラミングコンテストに興味がなくてもこの本は良い本だ。 様々なアルゴリズムの解説とその実践が出来る。そしてグラフ関連のアルゴリズムに詳しい。 私がアルゴリズムに興味を持つきっかけになった一冊。\n18. アルゴリズムイントロダクション  アルゴリズムやデータ構造に詳しくなりたいのならこの本をお勧めする。 相当数のアルゴリズムやデータ構造が載っているばかりか、ちゃんと計算量の解析なんかもしている。しっかりと「考え方」が身につく本である。 練習問題も豊富にある。中々分厚いが辞書と思えば妥当でもある。\nただ、内容は堅いのでかなりとっつきにくい。さらに、載っているのは疑似コードなので実際に試したいならそれなりに頭を使って自分の言語に翻訳する必要がある。\nアルゴリズムやデータ構造に関して、触りだけでいいならこの本がある。\n 随分前に借りて読んだ本で、本棚にも並んでないので記憶が朧げだがプログラミング初学者~初心者に丁度いいくらいの内容だったと思う。\n19. Purely Functional Data Structures  この本はアルゴリズムイントロダクションの延長にあると言える。 最初に「ならし計算量」(償却計算量)を導入したあと、いくつかのデータ構造を下限オーダの操作のまま簡潔に関数的に実装していく。古い本なので恐らくは多くの人に馴染のないStandard MLで書かれているが簡潔な実装は一目瞭然、SMLを知らなくても読めるだろう。 その後遅延評価を導入して、上手く高速化する話、償却しなくても下限の計算量を維持出来る話、データ構造に「ひずみ」を溜めない話なんかが出てくる。Qiitaに一部の解説があるのでこれを読んで興味が湧いた人は買うといいと思う。\n20. 関数プログラミング 珠玉のアルゴリズムデザイン  この本を読んだ時、衝撃を受けた。まず、内容が難しくて理解が及ばなかった。先述のアルゴリズムイントロダクションを読んだ上でだ。 そしてそれ以上に衝撃だったのが複雑なアルゴリズムをHaskellを使って驚くほど簡潔に実装していた点だ。 アルゴリズムを下限のオーダーで実装するのを前提として、「運算」を使って定数倍の高速化を試みる。魔法のようだった。\n比較的小さな本だが内容は見た目の3倍はあると思って読んだ方がいい。\n函数型言語を触る人なら必ず読んだ方がいい。難しいので完全に理解は出来なくてもこういう世界があることは知っておきたい。\n21. 人間に勝つコンピュータ将棋の作り方  LispはかつてAIの言語として表舞台に立った。ならばLisperとしてAIは知っておきたい。当時まだ探索初心者だった私にとってこの本は色々ためになった。 min maxやnega max、αβ木探索なんかは初めて知ったし評価関数のパラメータを機械学習で決めるのも初耳だった。 読み物程度で詳しい技術の話は載ってないがAIに興味を持っていた私には面白い本だった。\n22. コンピュータ囲碁  将棋AIが人間に勝つようになって、そろそろ別のゲームか、と思い始めてこの本を手に取った。 先の本とはうってかわってつぶさな実装が載っている。将棋とは違ったモンテカルロ法のアプローチが新鮮で面白い。 モンテカルロ法の探索を知らないのなら一度は読むと良いかもしれない。\n最近では画像認識によく使われるCNNを使った手法なんかもあるようだが今の囲碁AIはどうなっているのだろうか。\n23. やさしいインタープリタの作り方入門  Lisperは一生に一度は自分のLispを作ると言われている。ならば、とこの本を手に取った。 プログラミング言語がどう動いているのかも知らない初心者には丁度良い内容だった。\n一応言うと私はこの本を参考にインタプリタを作った訳ではなくサラサラと眺めて概略だけを知った。 図書館で借りた本だったのでゆっくり読む時間がなかった。\n24. やさしいコンパイラの作り方入門  私が作りたいのはインタプリタだったが姉妹本ということで一緒に借りて読んだ。 感想はインタプリタと同じ。今Amazonのレビューを見ると酷評されていたのでゆっくり読むには向いてない本なのかもしれない。\n25. コンパイラ―原理・技法・ツール  いわゆるドラゴンブック。コンパイラの定本。もう少しコンパイラに詳しくなろうと手にとった。著者達が構文解析の専門家のようで、本の半分くらいが構文解析に割かれている。 さらっと正規言語(正規表現)についても載っていたりする。私みたいにLispを作りたい人には複雑な構文解析の話は退屈だったが後半の翻訳や最適化の話は非常に面白かった。 中々堅いというか難しい本ではあるが、馴染めるならこれ以上のものはない一冊。\n余談だが著者のエイホはAhoと綴る。I am AHOというとめちゃくちゃコンパイラ出来る人と思われるだろう。\n因みにドラゴンブックと並び語られる本にタイガーブックがあるが私はまだ読んだことがない。その内読まねばと思っている。\n 26. コンパイラの構成と最適化  ドラゴンブックよりも最適化についてページを割いている本。人によりけりだがドラゴンブックよりもこの本を勧める人が多い。私もそれが妥当だと思う。 文体はさしてドラゴンブックと変わらないが変にカタカナ文字を日本語にしておらず(インタプリタ、コンパイラを解釈系、翻訳系と訳すなど)読み易い。\n27. きつねさんでもわかるLLVM  理論の話が出来ても現実のコンパイラを作るのは難しい。その1つにコードを吐く部分が泥臭い点がある。 LLVMを使えればそういう泥臭さを軽減出来る。さらにLLVMは低レベルな最適化もやってくれるのでコンパイラを作る時の手間をかなり省かせてくれる。\nLLVMは巨大だがこの本を読めばどこで何をやってるのか、LLVM IRがどんなものかは分かるようになる。 さらにパスやバックエンドなどそれぞれのプラグインの書き方も載っているので色々な切り口からLLVMを使いたい人にも役に立つ。 少なくともこの本を読まずしてLLVMが分からないと言ってはいけない。分かってなくて分かりたいなら読むべき。\nところでLLVMといえばもう一冊あるがこちらはClangのためのLLVMといった感じでClangをハックしたい人向けな内容になっている。\n 28. 言語実装パターン  パーサジェネレータのANTLRの開発者が著した本。実際にいくつかDSLなどを作りながら進むのでエンジニア向けなのかもしれない。 一度借りて読んだ後本棚に置きたいなと思いつつまだ買っていない。\n29. 正規表現技術入門  一度書評を書いた。 Webではまず得られない正規表現のまとまった情報が得られる。 ドラゴンブックでも扱われている正規言語だがこちらの方がコードを交えながら解説するので詳しくて分かりやすい。\nOnigmoのコードが載っているのでそれを見て最適化し、最終的にはパッチがRubyに取り込まれるまでの流れが出来た私にとっての思い出の1冊でもある。\n語彙が足りなくて申し訳ないが素晴しいの一言に付きる。\n30. 型システム入門 −プログラミング言語と型の理論−  コンパイラを作っていて外せないのが型システムの話題。それについて深く扱っているのがこの本。いわゆるTaPL。 初めて読んだ時、λだけで様々な関数を実装していくのが不思議でならなかったし、不動点コンビネータにも感動した。 2回目に読んだ時にはもう少し余裕があって操作的意味論も追えた。 次に読む時はもう少し深くまで読みたい。少くとも手を動かす必要はあるだろう。\n有名な定本ではあるが理論の本なのでどういうことを論じているか分からないまま読める本ではない。 しかし本棚に置いておくと「あれ？System F_ωってどんなシステムだっけ？」などとなった時にサッと引けて便利ではある。\n31. プログラミング言語の基礎概念  TaPLよりも軽くやりたいならこの本がある。TaPLに比べてずいぶん（物理的にも）軽く、要点を押えた内容で入り易い。\n読書会も開かれている\nこの本とTaPLの中間というかもう少しプログラミング言語の意味論に焦点を当てたものとしてWeb上だがソフトウェアの基礎がある。Coqの練習がてら手を動かすと良い。\nソフトウェアの基礎\nこちらも読書会が開かれている\n32. 計算機プログラムの構造と解釈  もう少しエンジニア寄りのコンピュータサイエンスの本ならこれがある。 言わずと知れた名著、いわゆるSICP(しっくぴー)。表紙から魔導師本などとも言われる。計算機科学への深い洞察を与える。 訳が堅いとも言われるが大学生の教科書なんてみんな同じようなものだ。解析概論に比べたら読み易い。 初心者にプログラミングを教える時に適当な例を挙げるのに困ることがよくあるが、この本の題材の選び方は完璧だと思う。 理解の妨げになる余分な脂肪は落として完璧なまでに簡潔にしつつも関心を失わせない興味深いものを取り上げている。 題材のプログラミング言語としてSchemeが選ばれているが、そこも正解だと思う。Scheme自身にも余計な脂肪がない。\n最初のレベルはプログラミング初心者に合わせてあるが中身は計算機科学なのでストイックな初心者がゆっくり読むかある程度レベルをつけてから読むのが良いと思う。\n33. Linuxプログラミングインターフェース  普段OSのインタフェースがどうなってるかなんてプログラミング言語が隠蔽してくれるが、自分でプログラミング言語、Lispを作ろうと思ったら知る必要がある。 そういう時にこの本は役に立つ。\nC言語の良い所の1つにmanが充実している点が挙げられるが、この本はmanの編集者が著した本だ。 しかもmanよりも詳しくて、Linuxに出てくる概念のつぶさな説明、それぞれのインターフェースの細かな違い、早見表、違いを実感出来るコード例、Linuxに限らないコードの可搬性の話などなど枚挙に暇がない。\n今回挙げる中でも随一の重量を誇るが一番お勧めしたい一冊。無人島に1冊だけ持っていくとしたらこの本を選ぶ。\n34. Operating Systems  やはりOS上でLispを動かす以上OSについては避けて通れない。\nこれはいわゆるMINIX本で、UNIXライクな小さなOS、MINIXを題材にOSについて論じる。 私は英語版を読んだが日本のAmazonに出回ってないようなので日本語版のリンクを挙げておく。 MINIXを題材とはいいつつも副題にDesign and Implementationとあるが、Implementationの部分でMINIXのコードリーディングが挟まる程度。Designの部分はMINIXに限らない一般的なことを論じる。\nIOについて、プロセスについて、メモリ管理についてなどなど、普段のプログラミングで使っているのに詳しくないのなら一度は読むべきだ。\n特に、IPC(プロセス間コミュニケーション)の部分はOS関係なく役に立つ。\nOSについてなら最近だと定本ではあるがMINIX本よりこちらの方が良いと勧められたことがあるがまだ読んでいない。\n   4部構成らしいが、なぜかvolum4が見当らない。\n35. Computer Organization and Design  やはりCPU上でLispを動かす以上CPUについては避けて通れない。\nこれも名著。いわゆるパタヘネ。副題にThe Hardware/Software Interfaceとある通り、ハードウェアとソフトウェアの境界を行ったり来たりして進んでいく。 コンピュータの中身なんて丸で知らない初心者でも読めて、CPUの構造や(MIPS)アセンブラを知ることが出来る。 本を通してCPUの構造を解説しつつその知識を使って行列計算を高速化していく。それで最後は200倍まで速くなる。高速なコードを書きたい人は是非読むと良い。\nまた、この本は最新のCPU事情を追い掛けることも目的としていて、頻繁に改訂されている。 古くからある本だがこの第5版には大規模データセンターやモバイルデバイスでのCPUについても論じられている。\n尚、日本語版もあるが私は読んでないのでコメントは控える。\n  余談だが、最初にパタヘネと間違えてヘネパタ、CPUを作る人向けの本を買ってしまったので勿体なくて読んだが私には早すぎたようだった。\n こちらも日本語版があるらしい。\n 36. データマイニング入門  LispをやるならAI、AIでは機械学習が使われいるということから簡単な入門書を選んだ。 最初、これを選んだ時にはそこまで深く考えた訳ではないのだが後にこれ以上の入門書に出会ったことがない。 取り上げるトピックや理論と実践の配分、理論の踏み込み具合、図、などなど絶妙である。\n他にも統計や機械学習の入門書は色々に読んだが全てこの本の前には霞んでしまったのでこれしか挙げられない。\n37. エンジニアのための データ可視化[実践]入門  この本の通称何なのだろう。3D円グラフ本？あんちべ本？あんちべ本はこれか。\n 小中学校の社会や算数で習ったグラフの発展といったところ。しかし世の中思った以上に可視化の手法があって驚きが多かった。 データを可視化することがあるなら一度手を止めてこの本を読むだけの価値がある。\n詳しくは著者のブログを見るといい。\nエンジニアのためのデータ可視化実践入門という本を書いた - あんちべ！\n38. 詳解 シェルスクリプト  Lispの処理系マネージャをシェルスクリプトで書き始めたのが大学3年生のこと。そのあたりでこの本を買った。 シェルスクリプトを書くときには是非この本をお勧めする。便利コマンドやTipsの他にシェルの引数の評価順序、互換性の話などこの本くらいでしか扱ってないような情報が多数載っている。 シェルのテキストベース、行指向の考え方を身につけることが出来る。私も知人からはシェルスクリプトの人と認識されているがその知識の根底にあるのはこの本。\n39. BSD Hacks  古き良きBSDハッカーに思いを馳せたいならこの本を読むといい。FreeBSDを主としているがNetBSDやOpenBSDについての注釈もある。「telnetでメールを読む」など個人的にはすごい好きな本なのだが恐らく今の時代に需要はない。\n40. マスタリングNginx  NginXのパラメータやビルドオプションについて詳しい説明がある。 説明だけでなく、「CPUネックの時はワーカ数をコアと同じだけ、IOネックの時はコア数の1.5~2倍にするといい」など、パラメータ設定の目安もある。 NginXを扱うことがあるなら是非読んだ方がいい。そんなに分量はないので隙間時間に目を通せる。\n最近はnginx実践入門が話題だがまだ読んでいないので何も紹介出来ない。\n 41. 初めてのSQL  今更この本を挙げると笑われそうだが初学者の私には役に立った。SQLは割とノリで書けるところはあるが、GROUP BYなんかは知らないと書けない。\n42. SQLアンチパターン  こういう本は中々ない。いわゆる勘所みたいなのを書いてある。 ちゃんと、アンチパターンを挙げるだけでなくじゃあ代わりにどうしたら上手く解決出来るのか、とかアンチパターンとは言ったがこういう場合は使っていいだとか建設的な議論がされている。 ここで挙げられているアンチパターンには実際に問題が明みになるまでアンチパターンと気付けないようなものも少なくなく、この本で予習するかしないかで生死が分かれる。 テーブル設計のミスは中々に致命的である。\n43. 理論から学ぶデータベース実践入門  アンチパターンは超絶実践的な話だったがこちらは理論の話。リレーション代数や正規形の話、インデックスのアルゴリズムなど。第4正規形だとか関数従属性だとかが分からないならこの本を読むといい。\n型がある人がやるから型破りとはいう実用上正規形を崩すにせよがまずはこの本で理論的に綺麗なテーブル設計を知ると良いと思う。\n44. Redis入門  Redisの機能を使いつつアプリケーションをいくつか作っていく。最初読んだ時に割と「そこまでRedisでやるのか」と思った。 入門とはいいつつもシャーディングやLuaによるスクリプティングなども取り扱っており、中々読み応えがある。\n45. 7つのデータベース 7つの世界  先に7つの言語 7つの世界を挙げたがこの本も良書だ。むしろ私はこちらの方が好きだ。\nPostgreSQL、 Riak、 Redis、 HBase、 MongoDB、 CouchDB、 Neo4j。思うに、プログラミング言語に比べてデータベースは重くて気軽には試せない。 それを考えると7つというのは非常に大きな数字だ。色々なデータベースを知って適材適所使おうと思うならこの本こそ最適だ。\n46. 適応的分散アルゴリズム  この本は昔図書館で借りて読んだ。なんとなく名前だけに惹かれて借りた。そして退屈だなと思いつつ読み終わって返した。 しかしそれから幾許か。分散データベースやアクターモデルなんかが頻繁に出てくるようになってよくこの本を思い出す。\nノードとノードの間にどれだけ遅延があるかも分からないメッセージが届かないかもしれないノードが故障しているかもしれない、あるいは間違った情報を送ってくるかもしれない。 そんな中で合意形成したりリーダを選出したりマルチリードマルチライトなメモリを作ったりと面白いことを議論してある。\n次本屋で見付けたら絶対書いたい。そんな本。\n47. Parallel and Concurrent Programming in Haskell  Hey Hey Haskell本(?)。和訳も出ている。\n オンラインで読めるのでそれで読んだ。 内容がHaskellと密結合しているのでなんとなくでもHaskellを読めないとこの本も読めない。\n個々のプログラミング言語の機能の1つとして並列/並行のAPIについて述べられていることはあるがここまで様々に扱っているのは見たことがない。 よく「これ以上詳しく書こうとすると本が一冊書けてしまう」と流される部分を実際に本一冊書いてしまったような内容。\n並列/並行プログラミングに興味があるならHaskellを読めるようになってこの本を読むと良いと思う。\n48. Reactive Messaging Patterns with the Actor Model  デザインパターンのアクター版。Akkaを題材に扱っている。 これこそ「人類が既に解決している問題」であり、Akkaを使うにあたって読むといいと思う。 Akkaに固有の話もあるが大部分はBeamVMを始めとした他のアクターシステムにも共通する内容になる。\nAkkaを使う各社で読書会が開かれてその内和訳が出るところまで見えた。\n49. Unicode標準入門  自分の作ったLispでマルチバイト文字を扱おうと思うとUnicodeについては避けて通れない。 バイト列とエンコーディングとコードポイントと文字集合と文字とグリフとフォントと、これらの違いと関係について分かってないのならUnicodeについて勉強した方がいい。 ただでさえ複雑なUnicodeなのに基本の概念が分かってないのなら話にならない。\n扱っているのがUnicode3.0とやや古いものの基本的な部分は変わらない。というか、最近のUnicodeのバージョンアップは文字集合が拡大されているだけと思ってるんだけど合ってるかな？\n50. セキュリティコンテストチャレンジブック  セキュリティコンテストに興味がなくてもこの本は役に立つ。 プログラマなら「こういうコードを書くと脆弱性になる」とは知っていても実際にどういう攻撃が可能なのか知っている人はそんなにいないのではないか。 この本を読めば少しは分かるようになる。話題もバイナリ解析からネットワーク、Web、SQLと色々ある。\nところで今目次をみたら酷い誤植があった。やたらバイナリ解析したいらしい。\nおわりに お気に入りの本を挙げていったら50冊近くあったのでキリ良く50冊にした。 思ったよりも50冊は多くて、日曜日の半分が潰れたが色々吐き出せてよかった。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2016-01-17","title":"独学でプログラミングをやってきた中で良かった技術書50選","url":"https://KeenS.github.io/blog/2016/01/17/dokugakudepuroguraminguwoyattekitanakadeyokattagijutsushowoageteiku/"},
  {"body":"巷でよく「アウトプットを増やせ」というのを聞くが個人的な意見としてインプットを増やした方が良いと思っているのでそれについて書く。\n以前少し書いたことがあるが、私はプログラミングを独学で学んだ。 その時インプットがメインでほとんどアウトプットをしてこなかった。今でもそれは正解だったと思っている。何故か？ 答えは簡単で、「学ぶ」ということは情報を仕入れる、要はインプットのことを指しているからだ。それに独学でない人、つまり情報学科なんかにいる人は死ぬほど勉強している訳でちょろっと勉強したくらいでは到底太刀打ち出来ない。\n全くアウトプットが必要ないかというとそうとも思っていない。アウトプットの瞬間に今まで仕入れた知識が自分に定着するからだ。 インプットとアウトプットどれくらいの比率でやればいいのかというと「インプットが溢れ出した時」にアウトプットすればいいと思っている。\nただ目だけで追った情報は自分の中ではぼんやりしていて形を成していない。 コードなり文書なりの形にアウトプットする時に同時に自分の中で形を成す。あるいは半知半解の部分が明みになって理解の手向けとなる。 そのぼんやりとしたものが形を成す瞬間が一番成長しているように感じるのでよく「アウトプットを増やせ」と言われるのではと思っている。 しかしそれはぼんやりとした情報が定着しているだけであって知識が増えている訳ではない。アウトプットの時に定着するものは今までのインプットに比例する。インプットがなければアウトプットの時の成長もない。 かといって定着させることなく情報を仕入れ続けると不安になる。あるいは、仕入れた知識を試してみたくなる。そういう時にアウトプットすればいいと思っている。 私はそれを「インプットが溢れた」と呼んでいる。\nもう1つインプットを増やした方が良いと思っているのは大抵の問題は人類は既に解決しているからだ。無理にアウトプットしようと1時間掛けて悩むよりも10分掛けて解決法を学んだ方が手っ取り早い。 プログラミングを独学しようと思うと莫大な時間が必要になる。独学に取れる時間が有限ならば短時間で解決出来る方法を選ぶべきだ。 問題解決能力なんて手札が揃ってから考えればいい。碌な手札も持ってないのにそれで解決しようとするのは無理がある。まずは手札を揃えるべきだ。世の中のプログラマと同じ手札を揃えないとそもそも同じ土俵で戦えない。\nここで1つ言及しておきたいのが毎日ブログ問題だ。「毎日技術ブログを書き続けろ。つらくてもいいから続けろ。続けた先に見えるものがある。」なんて言われることがある。あれはあまり良くないと思っている。 本当に初学者の時は毎日くらいの頻度でインプットが溢れるかもしれない。しかしその期間は長くは続かない。ちゃんと学んで成長していればインプットのバッファも大きくなる。 すぐに1日の勉強量ではインプットが溢れなくなる。そうなった時にも毎日ブログを書く意味はない。ブログを書くのにも時間が取られるのを忘れてはいけない。ブログを書く達人になりたいのでもなければ時間を使う意味はさしてない。 それよりは平日に進めて土日で仕上げて日曜の夜にそれについてブログを書く、とかの計画的なサイクルを回した方が良い。あるいはもっと長いスパンで。\n1つ、インプットばかりしていると懸念が生じる。それは実用上の問題ではなく自己満足とか成果とかの問題、精神上の問題だ。 何かを学ぶ以上成果が欲しくなる。特に実学なら実用的な成果が欲しくなる。学んではいるものの目に見える成果がないと不安になる。 例えば職のためにプログラミングを始めた人なら切実に成果が欲しいだろう。これについては私は今のところ有効な解決策を見付けていない。 目標のある人はどれだけ目標に近付いているかで測れるかもしれないが私には目標がなかった。 同じくらいの習熟度の人と比べるのが良さそうだが、独学同士相手を見付けるのは中々難しい。同学年の情報科学科の人と比べると正規軍に徒手空拳で挑むようなもので話にならない(そういう経験がある)。 時折たまに溢れ出たアウトプットを眺めてちゃんと前に進んでいるんだと自分に言い聞かせてきた。 不思議と、就職に関してもそれでどうにかなった。目に見える形にはなっていなくても面接などで話すと分かるのだろう。結局、不安は不安のまま抱え続けるしかなかった。独学とはそういうものなのかもしれない。\n私も大学生でプログラミングに目覚めて今丁度丸4年。去年の4月からプログラマとして働いているが未だインプットの足りなさをひしひしと感じる。働きながら勉強を続けるが中々時間がとれない。 時間のある学生の時にもうちょっと効率的にインプットを増やしていたらと思う。そういう後悔をする人を一人でも減らそうと思ってこういう記事を書いてみた。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2016-01-17","title":"プログラミングを独学する時こそインプットを増やした方がいい","url":"https://KeenS.github.io/blog/2016/01/17/puroguraminguwodokugakusurutokikosoinputtowofuyashitahougaii/"},
  {"body":"κeenです。連休中にIsabelleを少しばかり触ったのでその時のまとめを。\nIsabelleって？ 公式。定理証明支援系の一つ。SML処理系の1つ、Poly/MLで書かれている。 どうやらHOL(Higher Order Logic)に焦点を当てているようだが詳しいことは分かっていない。\nあと、Linuxが正式にはGNU/LinuxというようにIsabelleもIsabelle/Isar/HOLと言うべきらしいが、まだよく分かっていない。\nインストール 公式サイトからダウンロード出来るが、後述のProofGeneralの関係上Isabelle2014をインストールする。\nエディタ設定 ProofGeneralを使う。恐らくGitHub版を使った方がいい。設定は1行\n(load (expand-file-name \u0026#34;/path/to/ProofGeneral/generic/proof-site\u0026#34;) nil t) と書くだけ。多分prettify-symbol-modeも自動でonになる。(なってなかったらなんか適当に設定しておこう。global-prettify-symbols-modeとかで。) Isabelleの古いドキュメントを見てるとX-Symbolsモードなるものが出てくるが、恐らく現在のprettify-symbol-modeだと思う。\nはじめる このチュートリアルを進めている。まだ途中。タクティックもtactic_indとautoしか知らない。\nとりあえず拡張子は.thyにしとくとEmacsが認識してくれる。\n所感 Coqを触ったことあるとそれなりにスムーズに入れた。ただしダブルクォートはキモい。 Coqも3つくらいの言語が混ってるらしいのでその内のGallinaの部分をクォートで囲っている感じなのだろうか。 クォートの部分はHOLがどうのこうの言ってた気がする。\nまだどんなことが出来るのか分からないのでCoqの方がマシじゃんという感想しかない。\n困ったところ チュートリアル中に数学記号が出てくる。∀とか∃とか¬とか。断りもなしにソースコード中にも。 最初、組版の都合上置き換えたのだろうとCoqのようにforall, exists, notと打っていたがエラーになった。じゃあ、とユニコードで打ってみてもエラーになった。 結局、TeXのようにコマンドを入力するとWYSIWYGのようにシンボルになるらしい。 さらにややこしいことにEmacsに特定のシーケンスでキーを入力するとそのコマンドを挿入してくれる機能がついている。\nとりあえず今のところ分かっているものをまとめる\n   見た目 Emacsでの入力 実際のタグ     ∀ \\forall \u0026lt;forall\u0026gt;   ∃ \\exists \u0026lt;exists\u0026gt;   ¬ \\not \u0026lt;not\u0026gt;   ∧ \\and, / \u0026lt;and\u0026gt;   ∨ \\or, \\/ \u0026lt;or\u0026gt;   ⇒ \\Rightarrow, =\u0026gt; \u0026lt;Rightarrow\u0026gt;   → \\rightarrow, -\u0026gt; \u0026lt;rightarrow\u0026gt;   ≡ \\equiv, == \u0026lt;equiv\u0026gt;   ≠ \\noteq, ~= \u0026lt;noteq\u0026gt;    なんかそれっぽい記号を連ねてみたら色々出てきた。けどユニコード入力出来ないから載せれないw。\n逆引きしたい。見た目からコマンドを知りたい。\nなんかまとまりないけどそんな所で。頭痛い。\n","categories":["Isabelle","定理証明"],"category_urls":["/categories/isabelle","/categories/%e5%ae%9a%e7%90%86%e8%a8%bc%e6%98%8e"],"date":"2016-01-12","title":"Isabelleに入門した","url":"https://KeenS.github.io/blog/2016/01/12/isabelleninyuumonshita/"},
  {"body":"κeenです。またしても深夜になってしまいましたがSML#のpthreadバインディングを作ったのでその報告を。\nSML#はC FFIを簡単に書け、さらにランタイムがnon Moving GCなのでSML#自体はサポートしていないもののランタイムそのものはマルチスレッドに対応しているという大変興味深い特徴を持っています。 処理系側としてもマルチスレッドが欲しいならpthreadのFFIを使って好きにやってくれというスタンスのようです。\nということでさまざまなマルチスレッドアプリケーションの下地になるべくpthreadのバインディングを作りました。とはいってもまだ不完全ですが。\nどういうものが用意出来ているかはこちらが一覧として機能しています。\nSML的には改善の余地がある(例えば、排他的なフラグをdatatypeで定義するとか)のですが、あくまで低レベルなバインディングに徹するためにintのままで残してあります。\n他にはCのマクロで実現されていたものはインポート出来ないのでどうにかしてあったりどうにかしてなかったりしてます。 例えばPTHREAD_XXX_INITIALIZERはマクロで定義された初期値ですが、SMLからは参照出来ないのであきらめました。 代わりにpthread_xxx_new関数を用意したのでpthread_xxx_initと併せて使うことでそれらの値を初期化出来ます。 メモリ確保と初期化同時にやれよとの声が聞こえてきそうですが繰り返すとあくまで低レベルなバインディングなのでそういうのは他に譲ることにします。\npthread_cleanup_{pop/push}はバインディングが書けませんでした。 それらはマクロとして実現されていて、しかもpthread_cleanup_pushで開き括弧を挿入してpthread_cleanup_popで閉じるというエグい実装なので移植は無理でしょう。 POSIX的にもマクロとして実現して良いことになっているので文句は言えません。\nサンプルコード レポジトリにも入ってますが、スレッドを作る小さな例だとこうなります。\nopen PThread fun exit reason = ( print (reason ^ \u0026#34;\\n\u0026#34;); OS.Process.exit OS.Process.failure ) val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr (* durty hack *) val sml_str_new = _import \u0026#34;sml_str_new\u0026#34;: (string) -\u0026gt; char ptr fun threadFunc (arg:unit ptr): unit ptr = let val cp: char ptr = fromUnitPtr arg val s = Pointer.importString cp val () = print s (* val ret =ref _NULL *) (* val () = ret := (String.size s) *) in (* ret *) _NULL end val () = let val tattr = ref (pthread_attr_new()) val s = pthread_attr_init(tattr) val () = if s \u0026lt;\u0026gt; 0 then exit \u0026#34;pthread_attr_init\u0026#34; else () val thread_ref = ref (pthread_new()) val arg = sml_str_new \u0026#34;Hello world\\n\u0026#34; val s = pthread_create(thread_ref, tattr, threadFunc, toUnitPtr arg) val t1 = !thread_ref val () = if s \u0026lt;\u0026gt; 0 then exit \u0026#34;thread creation failed\u0026#34; else () val s = pthread_attr_destroy(tattr) val () = if s \u0026lt;\u0026gt; 0 then exit \u0026#34;pthread_attr_destroy\u0026#34; else () val () = print \u0026#34;Message from main()\\n\u0026#34;; val resRef = ref (Pointer.NULL ()) val s = pthread_join(t1, resRef) val () = if s \u0026lt;\u0026gt; 0 then exit \u0026#34;thread creation failed\u0026#34; else () (* val () = print (\u0026#34;Thread returned\u0026#34; ^ Int.toString (!resRef) ^ \u0026#34;\\n\u0026#34;) *) in () end 言わずとも雰囲気で読み取れそうですがこの例はCのサンプルをそのまま移植しました。Cだと(void *)と文字列で相互変換が出来るのですがSML#だと一筋縄では出来ないので内部APIを叩くとかのかなりアレなハックしてます。 SML#にイシューに上げましたが(void *)が強敵ですね。\n可搬性の話 ところで、pthreadはp(POSIX)の名が付いている通り様々なプラットフォームで利用出来、そしてそれぞれのプラットフォーム毎に実装が異なります。 勿論、POSIXで定められているのでAPIレベルでは互換性がある(≒関数のバインディングは問題ない)のですが、ABI、データの表現に互換性がありません(≒データ型のバインディングに問題がある)\n実はその辺で苦労がありました。今のところ手元の環境(Linux)でしか移植が済んでません。しかし他のプラットフォームの移植は書ける形になっています。 これは以前書いたSMLのファイルにCのプリプロセッサを適用するというなんともいえないハックを使うことで実現しています。 他のプラットフォームに移植するには\n どういうマクロが定義されている時にどのプラットフォームのpthreadを使っているかの対応を調べる そのプラットフォームのpthread.hを入手してデータ型を移植する  手順が必要です。私は手元の環境で動かすのが精一杯なのでMacとかで動かしたい方がいればプルリクを頂けると。 前述の通り、関数のバインディングは可搬性があるので必要なのはデータ型と定数の移植です。ある程度はプリプロセッサも使えるのでほぼヘッダファイルを移植する感じですね。\nまあ、実をいうと関数の移植も細々したものが面倒なので放置していたりします。ここら辺は作業ゲーなので気が向いたらやります。\nあとは若干迷っているのが必ずしも実装されているとは限らないオプショナルな機能の移植ですね。 バリアやリードライトロック、スピンロックがそれにあたります。 可搬性とはいってもSML#自身が動く環境が限られているのでMacでもそれらが使えるなら移植してしまおうかと思っていますがまだ調べきれてません。\nまとめ  pthreadのバインディング作ったよ まだバインドが書かれてない関数もあるよ Macの移植パッチ待ってるよ ","categories":["SML","SMLSharp","ML"],"category_urls":["/categories/sml","/categories/smlsharp","/categories/ml"],"date":"2016-01-11","title":"SML#のpthreadバインディング作った","url":"https://KeenS.github.io/blog/2016/01/11/sml_nopthreadbaindingutsukutta/"},
  {"body":"κeenです。深夜にですが小ネタを。\nRustを使っているとついついリソースの解放のことは忘れてしまうのですが、注意しないといけない類のリソースがあります。\nその1つがBufWriterです。 バッファリングライター全般に言えることですが、奴らはメモリ上にまだ書き込まれてない値を保持しているので解放する前にそれらを掃き出す必要があります。 その時に書き込み例外が起き得るので、解放も安全な処理ではないのです。Javaのtry-with-resource文を使わないファイルの扱いについては悪名高いですが、あれは仕方ない話なのです。\nところでRustのリソースの解放はDropトレイトのdropが担っていますが、返り値はvoidです。基本的には裏で動くので当然ですね。 そして、dropはpanicを起こさないことが望ましいです。Rustは今のところ(1.5時点)panicから回復出来ないのでそれはそうでしょう。では、エラーを返り値でも返せない、panicも起こせない中BufWriteはどうエラーを扱っているのでしょう。それは実装を見ると分かります。\nimpl\u0026lt;W: Write\u0026gt;DropforBufWriter\u0026lt;W\u0026gt;{fn drop(\u0026amp;mutself){ifself.inner.is_some(){// dtors should not panic, so we ignore a failed flush // 訳: dropはパニックすべきではない、だからflushの失敗は無視する let_r=self.flush_buf();}}} …はい。中々アレなことをやってくれますね。\nということでBufWriteを使う時は\n{letfile=File::create(\u0026#34;some_file.txt\u0026#34;).unwrap();letbr=BufWrite::new(\u0026amp;file);// do something matchbr.flush_buf(){Ok(())=\u0026gt;(),Err(e)=\u0026gt;// handle errors }} のようにライフタイムの終わりでflush_bufを呼ぶのが作法的な方法です。 unwrapと同じく掃き出せない時に無視されてもいいならそこまでする必要はありませんが、それでもスコープの終わりに意図的にflush_bufを呼んでない旨を書くと丁寧でしょう。\n因みにスコープが大きすぎる時は\n{letfile=File::create(\u0026#34;some_file.txt\u0026#34;).unwrap();{letbr=BufWrite::new(\u0026amp;file);// do something with br matchbr.flush_buf(){Ok(())=\u0026gt;(),Err(e)=\u0026gt;// handle errors }}// do other things } のようにスコープを作って不要なライフタイムを切り詰めるイディオムもあるので併せてどうぞ。\n余談ですがstd::fs::Fileの実体はCのFILE構造体ではなくファイルディスクリプタなのでバッファリングはしてません。のでこちらは気にする必要はありません。\nという訳で小ネタでした。\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2016-01-08","title":"Rustといえどリソースの解放は注意","url":"https://KeenS.github.io/blog/2016/01/08/rusttoiedoriso_sunokaihouhachuui/"},
  {"body":"2016年個人的に注目したいというか力を入れたいというか成行を見守りたいというか、そんな技術達を書き連ねていく。ものによっては「何を今更」と思うかもしれないがあくまで私にとって、だ。\n順不同。\nApache Drill 公式。様々なデータソースに対してANSI SQLでクエリを投げれるやつ。 ビッグデータの時代にETL無しで迅速にデータを分析出来るようにするために開発されてるらしい。\n様々なデータソースというのは本当に凄くて、CSVとJSONをJOIN出来たりする。 あるいはTSVの生ログとRDBにあるマスタデータをJOIN出来たりする。 個人的にはデータベースから抽出したCSVにクエリを投げたい時に便利かな、と思って注目してる。viewや一時テーブルを作る権限がないデータベースだってある。\nあるいは、Zookeeperを使って分散モードで実行も出来るのでBigQueryみたいなのをオンプレ環境で動かすのにも使えるようだ。 その時はデータフォーマットはParquetで保存すると速いらしい。\nRust 公式。言わずもがな。去年の5月に1.0が出て、今年で一周年を迎える。そろそろ安全なシステムプログラミング言語としての地位を築いて欲しい。 今までは安全なシステムプログラミング言語が不在で、不適切にも関らずJavaで代用されることが多かったように思える。\nやっぱりGCがあると安定性に心配が残るし、フルマネージングなランタイムシステムを持ってると他のランタイム、例えばlibuvなんかと相性が悪い。\nかといってC++やCだと安全でない。システムが巨大になった時にデバッグがつらくなる。\nRustには是非Javaより速くて実行が安定しててC++よりも安全でCよりも抽象力があってマルチスレッドを使い始めても開発効率が落ちない言語として活躍して欲しい。\nKafka 公式。「ただのキュー」と言ってしまえばそれまでだが高トラフィックを捌ける信頼性の高いキューだ。 OSのキャッシュを上手く使ってるだとかJavaだからといって富豪的プログラミングをしてないだとか分かってる人が作った感じがしてすごくいい。\nfluentdとかでデータを流すにしてもバックプレッシャーをやりたい、流す先が落ちてた時の事を考えたい、バッチじゃなくてストリーム（ミニバッチでもいいけど）でやりたい、とかの要望に応えてくれる。\nfloki Github。Rustで作られているキュー。 kafkaに言及しているがRedisプロトコルをベースとしていて、色々コマンドがあるようなのでkafkaとは少し毛色が違いそう。\n別にこれが次世代キューだ！なんて思ってる訳ではなくてRustで作られたミドルウェアがどうなっていくのか興味があるので観察対象に入っている。\nRobotS Github。RustのActor System。ほぼakkaの移植みたいだ。\nRustにアクターシステムが必要かは置いておいて、アクターシステムをRustの上に作るのは正解だと思ってる。 何故ならJVMや.NETのようにStop The Worldはないし、Erlangとは比べものにならないくらい速い。 さらに、もしかしたらだが、Rustなら所有権があるのでうまくすればメッセージを送るのにメモリコピーが起きないかもしれない。 まあ、Go使えばいいじゃんと言えばそれまでである。\nRedox 公式。Rustで開発されているOS。まだまだ開発途上だがゆくゆくはMINIXくらいの地位は築いて欲しい。 コマンドは全然ないのにGUIは動いていたりZFSをサポートしていたりする。開発者は「本気でやってる」と言っていたのでそれなりのものは出来るんだろうと期待している。\nコマンド群は、Rustでcoreutilsを書き直そうというcoreutilsというプロジェクトがある。それを使えると面白いんじゃないかと思っている。 こういう時ってまずはRustのコンパイラの移植をしないといけないのかな？よく分かってない。\nATS2 公式。線形型が肌で感じられる体になりたい。そのために修行したい。\nSML likeなシンタックスなので学習コストが低い。依存型の部分もCoqに似てる気がするのでそこも学習コストが低い。つまり線形型の学習に集中出来る。 ほとんど実用ではなく修行のために学習したい。もしかしたらアプリケーションくらい作れるのでは、とも思っている。 あとCとの相互連携が出来るのも良い。\nR 公式。最近データを扱うことが多くなった。そういう時に簡単に可視化が出来るこの言語は素晴しい。 まだほとんどコピペでしか動かしてないが、ちょこっとした分析くらいなら自分の手で書けるようになりたい。\n異常検知 機械学習というとぼんやりしてるので絞ってみる。時系列データにスパイクがあったり、集団から外れた値があるのを検出する。 これが出来れば職人が手作業で検査していたものを自動化出来る。こういうのをやってみたいなぁとぼんやり願ってはいるがまだ遠い。\nCoq 公式。ソフトウェアの基礎をずっとやっていたが、ProofGeneralのバグなのか、とある証明を食わせるとProofGeneralがフリーズするようになって以来途絶えている。 バグを直すか回避策を見付けるかして先に進みたい。こちらが終わったら次はCoqArtがある。 #readcoqartにも行く行く詐欺をしてるので行かねば。\nIsabelle 公式。SMLユーザとしてはCoqをやるならIsabelleもやらないとな、と思っている。 ここによるとCoqとはまた違った証明のやりかたらしいのでそういう意味でもやる意味あるのかな、とか。 Coqが終わってさらに手が空いてたら、くらい。\nProlog 修行の1つとしてPrologをやりたい。というか、作りたい。その前にまずはPrologを書けるようになりたい。 少しやってみているが、GNU PrologもSWI PrologもただのPrologとしか呼ばれていなくて情報を見付けるのに苦難している。 Lispみたくそれっぽい見た目と挙動をしていたらPrologを主張出来るのだろう。\n今気になっているのは制約ソルバとPrologの関係。 もし制約ソルバでPrologを実装出来るなら実装をサボれるし制約ソルバを触ってみれる。ただ、制約ソルバがチューリング完全な気がしないので使えるとしても部分的な気がする。\nFortran 神託の言語。\nκeen が 2016 年に新たに学ぶべき言語は『Fortran』です。\u0026#10;#1year1lang\u0026#10;https://t.co/sDP4Kk2Vfx\u0026#10;\u0026#10;うっ。。ぐ。。。\n\u0026mdash; κeen (@blackenedgold) 2015, 12月 31 \nまあ、ベクトル計算楽そうだし機械学習の手習いついでにアルゴリズムを実装してみるのも悪くないのかな、と思えてきた。\n思ったより言語の話題が多かった。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2016-01-01","title":"2016年注目していきたい技術","url":"https://KeenS.github.io/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu/"},
  {"body":"κeenです。ATS2には3つの世界があります。動的な世界、静的な世界、証明の世界。 前回の記事では静的な世界を色々扱ってみました。 今回は証明の世界である観について少し。\n2016-1-2: いくつか誤植を直しました(用語で言えば、 注観→駐観 が正解でした)。\n観 観(view)は、線形型によるリソース管理をするための仕組みです。 静的な世界と同様コンパイル時に検査されたらバイナリには現われませんが関数の引数として渡したり観を扱う関数(証明関数)を定義出来たり 動的な世界と似た部分があります。\n駐観 at-viewの和訳だそうです。これは観の中でも特に特定のアドレスにデータが存在することの証明を表わす観です。 線形型の主な管理対象がメモリなので特別扱いされているのでしょう。\n抽象観 任意のリソース管理に使っていい観。これ自体は実体を持たないので後述のデータ観などで実体を与える必要があります。 ドキュメントではロックの管理だとかに使う例が載っていました。\n観型 ただ単に観と型をくっつけたものです。「あると便利なのは分かるけど…」と思ってましたが、だんだん理解が追いついてきました。\n1つには観と型を1つの記法で表わせるので記述が楽になる。もう1つにはある型に対して必ず線形型によるリスース管理がされることを保証出来る。\nもう1つの用途が思い浮かんだらなるほど、となりました。\nこちらは駐観に限らず任意の観と任意の型を組み合わせれるようです。\nデータ観 動的な世界でのデータ型のように、静的な世界でのデータ種のように、証明の世界にもデータ観というものがあります。\n例えば、あるかもしれないしないかもしれないリソースを表わすのにオプショナル観が使えそうだ、など。\nこれ自体は新しい観を作るためのものです。\nデータ観型 これは動的な世界と証明の世界両方に跨るものです。おおざっぱにはデータ型とデータ観を組み合わせたものです。 つまり、データ型であり、データ観であり、両方合わさってるので観型でもあります。\n「データ型を観で管理しようとしたら同じようなデータ観を作ることになるしまとめて作れたら嬉しいよね」が一番分かりやすい説明でしょうか。\nデータ観型専用のシンタックスなどもあるようなので単なるシンタックスシュガーではなさそうです。\nこちらは駐観というかメモリ管理の観が割り当てられるみたいです。\nRustと比べると随分リッチなリソース管理が出来ますね。\nまだ良く分かってない部分 ATS2にはprop（命題）というものもあります。「観はpropの線形バージョン」と書いてあるのですがどう分けられているのでしょうか。 例えば観型にpropは渡せなそうな気がしますが、証明関数には命題も観も渡せそうな気がします。\n微妙に命題と観が共存していたり排他的であったりします。動的な世界のdatatyp, 静的な世界のdatasort, 証明の世界のdataviewという理解でいるとdatapropの居場所がなくなります。\n今のところ、証明の世界も普通の命題であるpropと線形の命題であるviewに分かれていて、 それらはsortが違うので一部では排他的であり、どちらのsortに対しても対応しているものもあるので共存してるようにも見えるという仮説を立てています。\nドキュメントにも種viewや種propという記述があるので種がsortが違うのは正しそうです。\nしかしそうするとdatasortとかで新しく作った種はどこの世界に住むことになるんでしょうか。静的な世界?証明の世界に住む新しい種を定義出来ない?\nビルトインの種viewと種propの静的な項(の静的な項)だけが証明の世界の住人になれる?\ndatasortとかで作った新しい種は依存型や依存命題(?)、依存観(?)で使うためにある?\n分からないことが多いですね。もう少しATS2の世界の整理をつけたい。\n","categories":["ML","ATS2"],"category_urls":["/categories/ml","/categories/ats2"],"date":"2016-01-01","title":"ATS2の観が整理出来た","url":"https://KeenS.github.io/blog/2016/01/01/ats2nokangaseiridekita/"},
  {"body":"κeenです。少しばかりATS2を触ってみたので成果報告でも。\nAVL木は左右のノードの高さが高々1しか違わない平衡二分木です。OCamlやSMLでナイーブに実装すると本当に1しか違わないことを保証するのは難しく、精々テストなどで部分的に検査するだけです。\nところがSMLに似た文法を持つATS2には依存型があり、左右のノードの高さが高々1しか違わないことを型で保証出来ます。 つまり、左右のノードの高さが2以上違う木を作ろうとしてもコンパイルエラーになるのでコンパイルが通れば高さについてはバグがないこと保証されます。\nそういうAVL木を使ってTreeSetを作ってみたので紹介します。\n私のブログ(のこの記事)の読者ならATS2も依存型もAVL木も知ってそうですが一応説明します。\nATS2って何? 詳しい説明は日本ATSユーザグループに譲るとして、この記事にて重要な点を挙げます。\n SMLに似た文法を持つML方言 型の部分に型以外の項（例えば整数とか）が使える依存型を持つ  他にももっと素晴しい型システムや機能、特徴があるのですがとりあえずのところは上記の特徴を押えておいて下さい。\n依存型って何? 先程も述べた通り、ざっくり言うと型の部分に型以外の項が使える型システムです。\n例えば、次のSMLのコードを考えてみましょう。\nArray.get(arr: int array, index: int): int 型から読み取れるのは「intの配列arrと整数indexを受け取ってintの値を返す」関数です。 しかしこの関数はindexがarrの長さよりも大きい時に実行時例外を上げます。内部でメモリを護るために境界チェックをして、チェックに落ちた時に例外を挙げている筈です。。 配列アクセスの度に実行時例外をハンドルするのはコード上もパフォーマンス上も避けたいですよね。 こういうものをコンパイル時に防ぎたくありませんか？無駄な境界チェックを省きたくありまんか？依存型を使えばそれが出来ます。\n例えば\narray_get{n, i: nat| i \u0026lt; n}(arr: arrayref(int, n), index: int(i)): int これは「長さnのint配列arrとn以下の自然数indexを受け取ってintの値を返す」関数です。 正しい入力しか受け取らないので実行時例外が起きませんし内部で境界チェックも必要ありません。面白くないですか？\n私も大して型システムに詳しくないのでこのくらいの例しか挙げることが出来ませんがきっとさらに面白い世界が広がっているのでしょう。\nAVL木って何？ Wikipediaを参照すると詳しいことが載っています。前の説明を繰り返すと、左右のノードの高さが高々1しか違わない平衡二分木です。自身の高さは左右の高さの高い方+1です。 データ構造は左右の木、ノードの保持する値の他にそのノードの高さを保持します。\nなので平衡度は赤黒木より高く、検索が高速な一方、要素数を変更する操作の度に平衡を取らないといけないので挿入や削除は赤黒木に負けるそうです。 OCamlのstdlibのMap/Setの実装に使われています。(OCamlは左右の高さが高々2違う木なので厳密にはAVL木ではないのですがアルゴリズムは同じです。)\n因みにAVLは人の名前の頭文字みたいです。\n作ってみよう 今回、ATS2の依存型に関係ない機能、関数テンプレートなどは理解（読解）の妨げになると判断してそれらを使わないコード例を出します。 (関数テンプーレートを使わなくても多相型を使えば良さそうですが、ATS wayではなさそうです。)\nということで、整数を格納するSetを作ってみましょう。\n実装に先立って、OCamlのSetやGADTを使ったAVLの実装を読んでおくと比較が出来るかと思います。\n今回OCamlのSetを参考にして作ったので比較のためにコードを載せたいのですがOCamlは確かコードの再配布に厳しいライセンスだった気がするのでやめておきます。(スニペットくらいなら著作権は発生せず、ライセンス関係なしに使えるのですが念のため。)\nおまじない 標準的な操作を取り込むため、以下をファイルの先頭に書きます。\n#include \u0026#34;share/atspre_staload.hats\u0026#34; データ型 高さnのAVL木を表わすデータ型を考えます。このデータ型は、\u0026rdquo;型パラメータとして\u0026rdquo;木の高さnを取ります。\n書き出しはこうです。\ndatatype avlt(n: int) = ... 続けて、Emptyを書きます。Emptyは高さ0です。\ndatatype avlt(n: int) = Empty(0) ... 続いて、Nodeですが、左の木の高さと右の木の高さを表わす変数を導入します。\n| {l, m: nat} Node of ... このクルクル括弧{}で囲まれた部分は「任意のnatなるl,mに対して」と読めば読み易いです。\nデータ構造は、左右の木、値、高さを持つのでした。ここで、高さはnであると型で制約されてます。ということでこうです。\n| {l, m: nat} Node of (avlt(l), int, avlt(m), int(n)) 最後の高さの部分でint(n)となっているのは、nは種intであって型ではないので「整数nのint\u0026ldquo;型\u0026rdquo;」にする為にint()を適用する必要があるのです。依存型だと「ただの整数値」だけでなく「整数3」などの型も作れるのです。\nさて、このままだと左右の木の高さが高々1しか違わないということを表わせていません。さらにいうと、自身の高さについての制約も書けていません。これらの制約はこう書きます。\n| {l, m: nat | \u0026lt;制約\u0026gt; } 今回の制約はこうなりますね。\n| {l, m: nat | (l + 2 == n \u0026amp;\u0026amp; m + 1 == n) || // 右が左より1高い 又は (l + 1 == n \u0026amp;\u0026amp; m + 1 == n) || // 左右同じ高さ 又は (l + 1 == n \u0026amp;\u0026amp; m + 2 == n) // 左が右より1高い } 結果、データ型はこうです。\ndatatype avlt(n: int) = Empty(0) | {l, m: nat | (l + 2 == n \u0026amp;\u0026amp; m + 1 == n) || (l + 1 == n \u0026amp;\u0026amp; m + 1 == n) || (l + 1 == n \u0026amp;\u0026amp; m + 2 == n) } Node of (avlt(l), int, avlt(m), int(n)) 中々複雑ですね。\nheight 軽い関数から作っていきましょう。まずは木の高さを返す関数heightです。高さnの木を受け取って整数nを返します。\n書き出しはこうです。\nfun height... そしてnを導入します。\nfun height{n: nat}... 引数は「高さnの木」ですね。\nfun height{n: nat}(tree: avlt(n))... 返り値は「整数n」です。\nfun height{n: nat}(tree: avlt(n)): int(n) = ... 関数本体は普通です。\nfun height{n: nat}(tree: avlt(n)): int(n) = case+ tree of | Empty () =\u0026gt; 0 | Node (_, _, _, n) =\u0026gt; n ここで使っているcase+ですが、普通のcaseより強くて網羅性検査に落ちるとコンパイルエラーになります。\ncreate これからinsertを実装していく訳ですが、ユーティリティから少しづつ実装していきます。まずは高さが高々1しか違わない木2つと値を1つ受け取って新たな木を作るcreateです。Nodeを生で使うのに比べて高さの計算が必要なくなります。\nこれは先に実装を与えて、後で型を考えましょう。先程のheightを使います。\nfun create??(l: ??, v: int, r: ??): ?? = let val hl = height l val hr = height r in if hl \u0026gt;= hr then Node(l, v, r, hl + 1) else Node(l, v, r, hr + 1) end さて、型を考えていきます。まずはlとrはある高さを持つ木です。\nfun create{l, m: nat} (l: avlt(l), v: int, r: avlt(m)): ?? = ... 次に、左右で高さが高々1しか違わないことを制約したいです。これはNodeの定義を参考にすると書けるでしょうか。\nfun create{ l, m: nat | l + 1 == m || l == m + 1 || l == m } (l: avlt(l), v: int, r: avlt(m)): ?? = ... 最後に返り値の型を考えます。返り値は「lかmどちらか大きい方+1の高さを持つ木」です。私は最初、それをこう表現していました。\nfun create...(...): [n: nat | n == m + 1 || n == l + 1] avlt(n) = ... [n: nat | n == m + 1 || n == l + 1] avlt(n)の部分を読み下すと、「n = m + 1又はn = l + 1を満たすnに対してavlt(n)」という型になります。これは、間違ってはいないのですが正確ではありませんでした。なぜならこの型に忠実に従うとl = m + 1の時にn = m + 1、すなわちn = lもありえてしまいます。勿論そんなことはなく、l = m + 1ならばn = l + 1です。\nよって正しい型は[n: nat | (m \u0026gt; l \u0026amp;\u0026amp; n == m + 1) || (l \u0026gt;= m \u0026amp;\u0026amp; n == l + 1)] avlt(x, n)です。やたら長いですね。\n全体を載せると、\nfun create{ l, m: nat | l + 1 == m || l == m + 1 || l == m } (l: avlt(l), v: int, r: avlt(m)): [n: nat | (m \u0026gt; l \u0026amp;\u0026amp; n == m + 1) || (l \u0026gt;= m \u0026amp;\u0026amp; n == l + 1)] avlt(n) = let val hl = height l val hr = height r in if hl \u0026gt;= hr then Node(l, v, r, hl + 1) else Node(l, v, r, hr + 1) end になります。\nrotate OCamlのSetでは1まとめにbalとしていますが、条件分岐が多すぎて読みづらいのでrightとleftに分離することにします。\nrotate_xxxは、左右で高さがちょうど2違う木と値を受け取って、バランスのとれた木を作って返す関数です。 rotate_rightなら左の木が右の木より2高い木を受け取って上手い具合に木の付け替えをして新たな木を返します。\n返り値の木は左の木と同じ高さかあるいはそれより1高い木です。\nそろそろ慣れてきたと思うので型までを一気に書きます。\nfun rotate_right{hl, hr: nat | hl == hr + 2 }(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = ... さて、さらに左側の木の左右の高さでも場合分けが必要になるのでまずは色々バラします。\nfun rotate_right{hl, hr: nat | hl == hr + 2 }(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let val+ Node(ll, lv, lr, _) = l val hll = height ll val hlr = height lr in ... end さて、ここが一番面白い所です。val+ Node(ll, lv, lr, _) = lに注目して下さい。 OCamlではmatch l with Empty -\u0026gt; invalid_arg \u0026quot;Set.bal\u0026quot; | Node (ll, lv, lr, _) -\u0026gt; ...となっていた部分です。 型制約から、lは高さ2以上の木であることが分かっているのでEmptyでないことが保証されます。なので Nodeだけで網羅出来ているとコンパイラが理解してくれ ます。マッチが1節しかないのでvalのパターンマッチで代用出来ますね。 val+はcase+と同じく網羅性検査に落ちるとコンパイルエラーになるバージョンのvalです。\n残りの実装をまとめると、こうです。\nfun rotate_right{hl, hr: nat | hl == hr + 2 }(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let val+ Node(ll, lv, lr, _) = l val hll = height ll val hlr = height lr in if hll \u0026gt;= hlr then create(ll, lv, create(lr, v, r)) else let val+ Node(lrl, lrv, lrr, _) = lr in create(create(ll, lv, lrl), lrv, create(lrr, v, r)) end end rotate_leftはこうです。\nfun rotate_left{hl, hr: nat | hl + 2 == hr }(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hr || n == hr + 1] avlt(n) = let val+ Node(rl, rv, rr, _) = r val hrl = height rl val hrr = height rr in if hrr \u0026gt;= hrl then create(create(l, v, rl), rv, rr) else let val+ Node(rll, rlv, rlr, _) = rl in create(create(l, v, rll), rlv, create(rlr, rv, rr)) end end bal rotate_right, rotate_left, createを1まとめにして左右の高さの差が高々2の2つの木と値を受け取ってバランスのとれた木を作って返すbalを作りましょう。\n型がエグいことになります。\nfun bal{hl, hr: nat | ~2 \u0026lt;= hl - hr \u0026amp;\u0026amp; hl - hr \u0026lt;= 2 }(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| (hl == hr - 2 \u0026amp;\u0026amp; n == hr ) || (hl == hr - 2 \u0026amp;\u0026amp; n == hr + 1) || (hl == hr - 1 \u0026amp;\u0026amp; n == hr + 1) || (hl == hr \u0026amp;\u0026amp; n == hl + 1) || (hl == hr + 1 \u0026amp;\u0026amp; n == hl + 1) || (hl == hr + 2 \u0026amp;\u0026amp; n == hl + 1) || (hl == hr + 2 \u0026amp;\u0026amp; n == hl ) ] avlt(n) = let val hl = height l val hr = height r in if hl = hr + 2 then rotate_right(l, v, r) else if hl = hr - 2 then rotate_left(l, v, r) else create(l, v, r) end cmp さて、本来のOCamlのSetはファンクタで出来てますがATS2には原始的なファンクタしかないのでファンクタを使わずにこれまで実装してきました。 あまりよろしくありませんがcmpもベタっと実装してしまいましょう。\nfun cmp(x: int, y: int): int = x - y empty, singleton fun empty(): avlt(0) = Empty() fun singleton(x: int): avlt(1) = Node(Empty, x, Empty, 1) insert ここまで辿りついたらもう難しいところはありません。insertした結果、木の高さが変わらないか1増えるだけです。\nfun insert{m: nat}(x: int, tree: avlt(m)): [n: nat | n == m || n == m + 1]avlt(n) = case+ tree of | Empty () =\u0026gt; singleton(x) | t as Node(l, v, r, _) =\u0026gt; let val c = cmp(x, v) in if c = 0 then t else if c \u0026lt; 0 then bal(insert(x, l), v, r) else bal(l, v, insert(x, r)) end mem fun mem{m: nat}(x: int, tree: avlt(m)): bool = case+ tree of | Empty () =\u0026gt; false | Node(l, v, r, _) =\u0026gt; let val c = cmp(x, v) in if c = 0 then true else if c \u0026lt; 0 then mem(x, r) else mem(x, l) end 遊ぶ さて、少しばかり遊んでみましょう\nimplement main0 () = { val tree = Empty val tree = insert(1, tree) val tree = insert(2, tree) val tree = insert(4, tree) val b = mem(2, tree) val c = mem(3, tree) val () = fprintln!(stdout_ref, b) val () = fprintln!(stdout_ref, c) } これまでのファイルをavlset_int.datに保存して、以下のようにコンパイル/実行します。\n$ patscc avlset.dats -DATS_MEMALLOC_LIBC $ ./a.out true false ちゃんと動いているようです。(GCをリンクしてないのでメモリリークしてる気がしますが、GCのリンクの仕方が分からなかったのでこのままにします。)\n追記: GCのリンクの仕方を教えてもらいました。\n@blackenedgold GC付きコンパイルには -DATS_MEMALLOC_GCBDW -lgc を使うようです。僕も今知りました。。。 / master · githwxi/ATS-Postiats-contrib https://t.co/4DPotHeUJ1\n\u0026mdash; Myu-Myu- ATS-tan! (@masterq_mogumog) 2015, 12月 30 \nまとめ 依存型を持つATS2を使うことでAVL木の高さに関する要件を必ず満たす木を作ることが出来ました。 これは変な入力がないことを保証するばかりでなく、自らの実装がバグっていないことの確認にも使えます。 また、val+の例で見た通り、パターンマッチについてもより厳格な検査が出来るので無意味なコードを書かなくて済みました。\n今回のコードはこちらに置いておきます。また、関数テンプレートを使ったよりジェネリックな実装もあります。\nノート  今回型レベルで保証したのは高さに対する要件だけでした。 「ノードの左側の木にはそのノードの保持する値より小さい値しか入っていない」「一度insertした値はmemするとtrueが返ってくる」などの要件については無保証のままです。 実はATS2には定理証明器も付いており、そのような振舞に関しても保証出来ます。 ATS2には依存型の他にも線形型を持っていて、GCに頼らないメモリ管理が可能です。 今回のコードも線形型を使ってメモリリークしないように出来るでしょう。 関数テンプレートを使ったAVL木の実装には若干危い点があります。関数テンプレートは実装をアドホックに変更出来るので 比較関数を差し替えれてしまいます。cmp(x, y) = x - yで木を作った後にcmp(x, y) = y - xにしてさらに要素を挿入したら大惨事になるでしょう。 そこまで気にするようならファンクタを使うべきです。  その他  CoqやAgdaのように依存型も定理証明器もある言語がありますが、それらと違ってATS2は「汎用プログラミング言語に表現力の高い依存型を付けて、ついでに定理証明器もついてる」くらいです。 本格的な証明には向かない一方汎用プログラミングにはATS2の方が向いているでしょう。 しかしCoqと似ている面もあり、ATS2の世界で依存型や線形型、証明などで強い保証を付けた後は一旦Cのコードをエクストラクトして、それをコンパイルしています。 Cにエクストラクトされるということで、ATS2はCとの相互連携が出来ます。  さて、ATS2には心躍る特徴がたくさんあります。依存型で実行時検査をコンパイル時検査に持ち上げ、定理証明器でバグも潰せて、 線形型でボックス/アンボックデータの扱いやGCに頼らないリソース管理やデータ競合の回避が出来、 並列プログラミングもサポート、低レベルなCのコードを呼べてバイナリサイズも小さいなどなど。\nしかし、これらの機能を得るのにATS2は1つだけ代償を払いました。学習コストです。 私はCも書きますしSMLも書きます。依存型のあるCoqや線形型より少し弱いアフィン型のあるRustも書いたことがあります。そんな私にもATS2は難解です。 最近難解な言語として名高くなってきたRustですら足元に及ばないでしょう。\nそれでも、急峻な学習曲線の崖をよじ登った先には素晴しい世界が広がっているのです。1つ、修行だと思ってトライしてみてはいかがでしょうか。\n参考: プログラマの区分\n","categories":["ML","ATS2","依存型","型"],"category_urls":["/categories/ml","/categories/ats2","/categories/%e4%be%9d%e5%ad%98%e5%9e%8b","/categories/%e5%9e%8b"],"date":"2015-12-29","title":"ATS2の依存型を使ってAVL木","url":"https://KeenS.github.io/blog/2015/12/29/ats2noizongatawotsukatteavlki/"},
  {"body":"κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。 Advent Calendarが終わってしまったので投げやり気味ですね。 第3段はSML#とCプリプロセッサで連携する話。\nSML#のC FFIを使ってるとマクロで定義された値などを触りたくなるのですが、触れないのでどうにかしようかと。\n発想自体は単純で、SMLファイルの中でCのヘッダをインクルードしてCプリプロセッサを呼んであげればどうにかなります。\n簡単な例 JITを作る話の時のように、定数に触りたいとします。 その時、以下のように.smlファイルを記述して、\n(* #include\u0026lt;sys/mman.h\u0026gt; *) (* ====END_OF_HEADER==== *) datatype dummy = $ of int val $PROT_READ = $ PROT_READ val $PROT_WRITE = $ PROT_WRITE val $PROT_EXEC = $ PROT_EXEC val $PROT_NONE = $ PROT_NONE 以下のコマンドを実行します。\ncpp -pipe -E cpp_pre.sml | sed \u0026#39;1,/====END_OF_HEADER====/d;/^#/d\u0026#39; \u0026gt; cpp.sml  ポイントを挙げると、\n smlファイルに#includeを書く。lintでエラーが出ないように#includeはコメントで囲む includeをコメントで囲ったところで安全でない( インクルードしたファイルに\u0026rsquo;*)\u0026lsquo;、例えば int f(char *);とかが入ってるとコメントが終端される)ので、includeの部分は後で削除する。 そのための識別子として、====END_OF_HEADER====を置いておく(これも完全には安全ではないが比較的マシ)。 Cのマクロと同じ識別子を使おうとすると識別子も置換されてしまうので左辺にダミーで$をつけておく。スペースは空けない。 逆に右辺は置換されてほしいので$の後にスペースを空ける。 最後にCプリプロセッサを呼び、sedでヘッダ部分や無駄に追加されたCのコメントを除く。  ちょっと$の部分がこの方式だとintにしか使えないのでイケてませんがないよりマシでしょう。因みに処理結果はこうなります。\ndatatype dummy = $ of int val $PROT_READ = $ 0x1 val $PROT_WRITE = $ 0x2 val $PROT_EXEC = $ 0x4 val $PROT_NONE = $ 0x0 ifdef 一旦発想さえ得てしまえば話は簡単です。次はifdefを使う例です。\n(* ====END_OF_HEADER==== *) (* #ifdef Debug *) val debug = true (* #else *) val debug = false (* #endif *) これは\ncpp -pipe -E -DDebug ifdef_pre.sml | sed \u0026#39;1,/====END_OF_HEADER====/d;/^#/d\u0026#39; \u0026gt; ifdef.sml とDebugを定義して処理すればifdef.smlの中身は\n(* *) val debug = true (* *) となりますし、定義せずに\n sh cpp -pipe -E ifdef_pre.sml | sed \u0026lsquo;1,/====END_OF_HEADER====/d;/^#/d\u0026rsquo; \u0026gt; ifdef.sml\nと処理すれば sml\n(*\n*) val debug = false\n(*\n*)\n```\nとなってどちらでもSMLとして有効な文法になります。ifndefだったり、elifがあったとしても有効な文法のままです。\nまとめ  CプリプロセッサでSMLファイルを処理する方法を提示したよ ifdefも使えるよ 関数マクロは使えないよ ","categories":["ML","SML","SMLSharp","Advent Calendar Memorial 2015","Advent Calendar Memorial"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp","/categories/advent-calendar-memorial-2015","/categories/advent-calendar-memorial"],"date":"2015-12-26","title":"SML#とCプリプロセッサの連携","url":"https://KeenS.github.io/blog/2015/12/26/sml_tocpuripurosessanorenkei/"},
  {"body":"κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。 Advent Calendarが終わってしまったので投げやり気味ですね。 第2段はSML#のオレオレREPLを作る話の初級。\nSML#にはFFIがあり、任意のオブジェクトファイル/ライブラリをリンクしてC関数を呼び出すことが出来ますが、REPLで試そうとしてもREPLにリンクされていないので呼び出せません。 そこで呼び出したいオブジェクトファイルをリンクしたREPLを作れば捗るよね、という発想です。\n事前に必要なもの  SML#のビルド時に使ったLLVMのパス SML#をビルドした時のオブジェクトファイルの残骸（一部） SML#のソーコード（一部）  コマンド まず、普通のREPLを作るだけならこれだけです。（コンパイラも一緒にくっついてきますが面倒なのでそのままにしてます。）\nSMLSHARP_SRC=/path/to/smlsharp LLVM_HOME=/path/to/LLVM cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./ cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026gt; smlsharp.smi _require \u0026#34;prelude.smi\u0026#34; _require \u0026#34;compiler/main/main/SimpleMain.smi\u0026#34; EOF smlsharp -c++ -o oreore_repl \u0026#34;${SMLSHARP_SRC}/src/compiler/smlsharp.smi\u0026#34; \u0026#34;${SMLSHARP_SRC}\u0026#34;/src/llvm/main/llvm_support.o \u0026#34;${SMLSHARP_SRC}\u0026#34;/src/llvm/main/SMLSharpGC.o $(\u0026#34;${LLVM_HOME}/bin/llvm-config\u0026#34; --ldflags --libs) あとは最後のリンクコマンドにフラグを足せばいいでしょう。注意点として、64bit OSを使ってるならちゃんと32bitでビルドしたライブラリをリンクしましょう。例えばlibuvをリンクするならこうです。\nSMLSHARP_SRC=/path/to/smlsharp LLVM_HOME=/path/to/LLVM cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./ cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026gt; smlsharp.smi _require \u0026#34;prelude.smi\u0026#34; _require \u0026#34;compiler/main/main/SimpleMain.smi\u0026#34; EOF smlsharp -c++ -o smlsharp_uv \u0026#34;${SMLSHARP_SRC}/src/compiler/smlsharp.smi\u0026#34; -L /opt/libuv32/lib -luv \u0026#34;${SMLSHARP_SRC}\u0026#34;/src/llvm/main/llvm_support.o \u0026#34;${SMLSHARP_SRC}\u0026#34;/src/llvm/main/SMLSharpGC.o $(\u0026#34;${LLVM_HOME}/bin/llvm-config\u0026#34; --ldflags --libs) 終わりに やり方さえ分かってしまえば簡単ですが見付けるのが難しい小ネタでした。因みに今回初級ですが、REPLにlibeditを統合するなどの上級ネタはいつか気が向いたら書くかもしれません。\n","categories":["ML","SML","SMLSharp","Advent Calendar Memorial 2015","Advent Calendar Memorial"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp","/categories/advent-calendar-memorial-2015","/categories/advent-calendar-memorial"],"date":"2015-12-26","title":"SML#のオレオレREPLを作る話 初級","url":"https://KeenS.github.io/blog/2015/12/26/sml_nooreorereplwotsukuruhanashi_shokyuu/"},
  {"body":"κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。 Advent Calendarが終わってしまったので投げやり気味ですね。 第1段はRustのロガーを作る話。\nRust Advent Calendarの初日でロガーはfacadと実装に分かれてると書きましたが、実装を作る話ですね。\nドキュメントを見てもらえば分かる通り、logは\npubtraitLog: Sync +Send{fn enabled(\u0026amp;self,metadata: \u0026amp;LogMetadata)-\u0026gt; bool;fn log(\u0026amp;self,record: \u0026amp;LogRecord);} とだけインターフェースが定まっているのでそこを実装してあげれば終わりです。 なぜまたloggerを作ろうとしたのかというと、Rust公式のenv_loggerは標準出力にしか出せず、crates.ioを捜しても（作ろうと思った時点ではパっと見）ファイルに書き出せるものがなさそうだったからです。\n私が作ったのはfile_loggerといいます。まだcrates.ioには出してません。TOMLでコンフィグを書けるようになったら出そうかと思うのですがもう既にファイルに書きだせるものが他にありますかね。\n今回作るにあたって目指したのは1つのことにだけ集中する他と組み合わせられるライブラリです。 logはロガーをグローバル変数に代入して使い回してるので同時に1つしかロガーを登録出来ません。そこでロガーアグリケーターのようなものを作ってそれに複数のロガーを登録することが考えられます。 調べきれてませんが恐らく既にいくつか存在するでしょう。アグリゲータの存在を仮定してしまえばアグリゲータに任せれる部分は任せてしまうのが良いでしょう。\nということで次のことを最初に決めました\n ログフォーマットは柔軟性を持たせる ログメッセージの内容に応じて出力を制御出来るフィルターを入れる。(アグリゲータが無差別にログを流し込んで来た時のため) 複数ファイルへのログはサポートしない。アグリゲータに任せる プラグインはサポートしない。アグリゲータに任せる ログローテーションはしない。Writeの実装に任せる。  一応file loggerですがWriteをすべからく受け取れるので実際はストリームにも使えたりします。今書き出してみたらフォーマッタとかフィルタとかもアグリゲータに任せた方がいいのかなって気がしてきた。 しかし単体での利便性を考えると仕方ない。\n実装は大したことをやっていなくて、精々ログフォーマットを文字列で書けるように（TOMLで設定を書きたいため）フォーマットのパーサを書いた程度でしょうか。\nもう少し考えてからリリースします。あとFile Lotating Writerも一緒に出さなきゃ片手落ちですかね…\n","categories":["Rust","Advent Calendar Memorial 2015","Advent Calendar Memorial"],"category_urls":["/categories/rust","/categories/advent-calendar-memorial-2015","/categories/advent-calendar-memorial"],"date":"2015-12-26","title":"Rustのロガーを作る","url":"https://KeenS.github.io/blog/2015/12/26/rustnoroga_wotsukuru/"},
  {"body":"この記事はApache Drill Advent Calendar 201521日目のエントリです\n最初は備忘録がてら普段使うMySQL、BigQuery、SQLite、Apache DrillのSQLシンタックスの違いでも書こうかと思ったのですが調査が思ったより大変だったのでやめました。ANSI SQLも色々変わってるということは理解出来ました。\nということでApache Drillを使ってて「ん？」と思った挙動をいくつか出してみようかと。1.4時点での情報です。\nSELECT 1 シェルで手持ち無沙汰にlsやpwdを打つようにSQLプロンプトでSELECT 1;を打つ訳ですが、Apache Drillはこれを受け付けてくれません。\nまあ、これは不自然というかそういう仕様なのですが正しくは\nSELECT1FROM(VALUES(1)); です。手持ち無沙汰に打つには少し面倒ですね。そうでなくても日付関数の挙動を確かめたい時にも\nSELECTNOW(); などとやりたい訳ですがそれにもFROM (VALUES(1));とダミーのFROM句を付けてあげる必要があります。面倒ですね。\nUNIONとUNION ALL UNIONはテーブル同士のレコード間で重複を取り除いた集合を、UNION ALLは重複を取り除かない集合を返します。Apache Drillでも試してみましょう。\nSELECT*FROM(VALUES(1,2,3)UNIONVALUES(4,5,6)UNIONVALUES(7,8,9)UNIONVALUES(1,2,3));SELECT*FROM(VALUES(1,2,3)UNIONALLVALUES(4,5,6)UNIONALLVALUES(7,8,9)UNIONALLVALUES(1,2,3)); これらのクエリはどういう結果になるでしょうか。答えはこうです。\n0: jdbc:drill:zk=local\u0026gt; SELECT * FROM (VALUES (1, 2, 3) UNION VALUES(4, 5, 6) UNION VALUES(7, 8, 9) UNION VALUES(1, 2, 3)); +---------+---------+---------+ | EXPR$0 | EXPR$1 | EXPR$2 | +---------+---------+---------+ | 1 | 2 | 3 | +---------+---------+---------+ 1 row selected (0.416 seconds) 0: jdbc:drill:zk=local\u0026gt; SELECT * FROM (VALUES (1, 2, 3) UNION ALL VALUES(4, 5, 6) UNION ALL VALUES(7, 8, 9) UNION ALL VALUES(1, 2, 3)); +---------+---------+---------+ | EXPR$0 | EXPR$1 | EXPR$2 | +---------+---------+---------+ | 7 | 8 | 9 | | 7 | 8 | 9 | | 7 | 8 | 9 | | 7 | 8 | 9 | +---------+---------+---------+ 4 rows selected (0.115 seconds) うーん。これはバグだと思うんですよね。定数テーブルをキャッシュするようにしてたら全てのレコードで同じ値を参照しちゃって値を書き換えてしまったとか。 UNIONがUNION ALLの結果からDISTINCT相当の処理をするなら2番目の結果を見れば最初の結果が従うのもうなずけますし。\nヘッダ付きCSV Drill 1.4からヘッダ付きCSVの扱いが楽になりましたね。拡張子がcsvのままヘッダ付きCSVにクエリを投げられます。ちょっと試しましょう。\n次のようなCSVファイルを用意します。\n$ cat ~/Csv/test.csv foo,bar,baz 1,1.0,\u0026#34;a\u0026#34; 2,2.0,\u0026#34;b\u0026#34; 3,3.0,\u0026#34;c\u0026#34; 4,4.0,\u0026#34;d\u0026#34; 5,5.0,\u0026#34;e\u0026#34; クエリを投げてみましょう。\n0: jdbc:drill:zk=local\u0026gt; SELECT * FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =\u0026gt; \u0026#39;text\u0026#39;, fieldDelimiter =\u0026gt; \u0026#39;,\u0026#39;, extractHeader =\u0026gt; true)); +------+------+------+ | foo | bar | baz | +------+------+------+ | 1 | 1.0 | a | | 2 | 2.0 | b | | 3 | 3.0 | c | | 4 | 4.0 | d | | 5 | 5.0 | e | +------+------+------+ 5 rows selected (0.12 seconds) よしよし。じゃあ今度はbazカラムだけ取り出してみましょう。ここで、会社のMacだと\n0: jdbc:drill:zk=local\u0026gt; SELECT baz FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =\u0026gt; \u0026#39;text\u0026#39;, fieldDelimiter =\u0026gt; \u0026#39;,\u0026#39;, extractHeader =\u0026gt; true)); +------+------+------+ | foo | bar | baz | +------+------+------+ | 1 | 1.0 | a | | 2 | 2.0 | b | | 3 | 3.0 | c | | 4 | 4.0 | d | | 5 | 5.0 | e | +------+------+------+ 5 rows selected (0.12 seconds) のようにカラムを指定しているのにも関らず全てのデータが返ってきていました。その旨を書こうと思ったのですが手元のLinuxマシンだと正しい結果が返ってくるようです。\n0: jdbc:drill:zk=local\u0026gt; SELECT `bar` FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =\u0026gt; \u0026#39;text\u0026#39;, fieldDelimiter =\u0026gt; \u0026#39;,\u0026#39;, extractHeader =\u0026gt; true)); +------+ | bar | +------+ | 1.0 | | 2.0 | | 3.0 | | 4.0 | | 5.0 | +------+ 5 rows selected (0.088 seconds) ちょっと会社で見たのが幻覚だったかもしれないので要調査ですね。\nMySQLへの接続 以下のようなSQLを投げた所、ひどく時間が掛かりました。投げた対象はプロダクションのデータが入ってる分析用のDBで、結構な量のデータが入ってます。\nSELECT*FROMmysql.mydb.`test`LIMIT20; Apache Drill自体レスポンスが悪いのでクエリによってはそんなものかな、と思って最初はそのままにしたのですがふと気になってEXPLAINしてみました。\n0: jdbc:drill:zk=localhost:2181\u0026gt; EXPLAIN PLAN FOR SELECT * FROM mysql.mydb.`test` LIMIT 20; +------+------+ | text | json | +------+------+ | 00-00 Screen 00-01 Project(columns....) 00-02 SelectionVectorRemover 00-03 Limit(fetch=[20]) 00-04 Limit(fetch=[20]) 00-05 Jdbc(sql=[SELECT * FROM `mydb`.`test`]) | { .... Jdbc(sql=[SELECT * FROM mydb.test]) とあるのでなんとMySQLにLIMITをつけずにクエリを投げてます。そしてさらに何故かLimit(fetch=[20])を2回やっています。\nまあ、内部でLimitを2回やってるのは良いとしてもMySQLにLimit無しで投げるのはいただけないですね。 分散モデルのDrillからしたら「分散してる俺らの方が処理が速いから全部俺らでやってやるよ」という気概なのかもしれませんがこちらとしてはDBへの負荷も考えて欲しいものです。 まあ、かといってWHERE句にインデックスが付く/付かないだとかその他の句によってMySQLのへの負荷も変わるのでなんとも言えないといえばそうなんですが簡単な場合にpush downしてくれるか あるいは手動でpush down出来る仕組みが欲しいですね。FORCE INDEXみたいに。\nさて、色々気になる点はありましたがApache Drillは面白いプロダクトです。 主にビッグデータ分析に使われるようですが私は大きなテーブルからアドホックに抽出したCSVとMySQLにあるマスターデータをJOINするなどの目的で使っていきたいなと思っています。\n皆様良いデータ分析ライフを！\n","categories":["SQL","DB","Apache Drill","Advent Calendar","Advent Calendar 2015"],"category_urls":["/categories/sql","/categories/db","/categories/apache-drill","/categories/advent-calendar","/categories/advent-calendar-2015"],"date":"2015-12-20","title":"Apache Drillの不自然な挙動","url":"https://KeenS.github.io/blog/2015/12/20/apache_drillnofushizennakyodou/"},
  {"body":"このエントリはLisp Advent Calendar 201521日目の記事です。\nκeenです。最近あまりLispを書いてなくてネタがないので最近作ってるLispの話でもしようかと。\nκLispといいます。まだまだ完成には程遠いです。現在、ここら辺くらいの式なら評価出来ます。\nこのLispはSKK辞書に使われているS式を評価するために作られました。 SKKは様々な場所に移植されているのでマルチプラットフォームで動いて他の言語と協調が出来る言語で作るのが望ましいのですが、今回はRustを選びました。 最初はCにしようかと思ったのですがちょいとRustを試してみようかと(当時Rustほとんど書いたことがない初心者)。\nSKKに書かれているS式を処理出来るLisp処理系はあるのですがGPLでライセンスされており、それを使ったiOSアプリをAppStoreに登録出来ないという問題があるそうです。 なのでMITライセンスで作り始めました。\nさて、Lisp処理系くらい簡単に作れそうなものですが、いくつかの点で詰まっています。\n そもそもRustが難しい 関数ポインタが思うように扱えない やろうとした事がborrow checkに引っ掛かって出来なかった  この詰まった点はRustが悪い訳ではなくて単に私がRustに合わせた設計が出来なかっただけですね。そろそろRustにも少しづつですが慣れて来たのでどこかのタイミングでリファクタリングして進めていきたいですね。\n一応現状でも進めようと思えば進めれるのですがここのように明らかにイケてないコードが続くので進めるモチベーション起きませんよね。\n設計とかの話をすると、最終的にはC APIでS式の文字列を受け取ったらそれを評価した結果の文字列を返す関数を晒せばいいかな、と思ってます。 ちゃんとiOSへのクロスコンパイルも出来ますしObj-C, Swift双方C FFIがあるのでそれで十分でしょう。(CF http://qiita.com/moriturus/items/1190614dcbbe31ecfc2f , http://safx-dev.blogspot.jp/2014/06/rustios.html)\nパーサは手書きで、実行はインタプリタ、Emacs Lispに則ってLisp2のダイナミックスコープです。設計がクソなのでメモリ管理らしいメモリ管理はやってませんがRustのメモリ管理のお陰でメモリリークはしてません。 ちゃんと設計してReference Countなメモリ管理でもしようかと。フットプリントの軽さ大事。\n全然まとまりませんがいつか使えるようになってAquaSKKやFlickSKKに取り込まれるかもしれないのでその時には裏でこのLispが動いてるかもと思い出してあげて下さい。\n","categories":["Lisp","SKK","Rust","Advent Calendar","Advent Calendar 2015","Lisp Advent Calendar"],"category_urls":["/categories/lisp","/categories/skk","/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2015","/categories/lisp-advent-calendar"],"date":"2015-12-20","title":"最近作ってるLispの話","url":"https://KeenS.github.io/blog/2015/12/20/saikintsukutterulispnohanashi/"},
  {"body":"このエントリはRust Advent Calendar 201520日目の記事です。 日付を覚え間違っていて、締切ギリギリに書いてます。\nκeenです。ものすごい小ネタですがRustでCIする話でも。\nRustはクロスプラットフォームな言語なのでLinux, Macそしてあまり聞き慣れませんがWindowsというOSでも動きます。 とは言っても普段の開発環境がLinux、運悪くMacを使わざるを得ない人はMacで開発をしているとそれらでの動作検証は出来るでしょうが他のOSでの動作検証が難しいでしょう。\nそこでCIしましょう。Travis CIはLinuxと、あまり使われていませんがMacでのCI環境を、AppveyorでWindowsというOSでのCI環境を作ります。\nしかしクロスプラットフォームでしかもテスト方法がCargoで統一されているRustではそこまで難しいこともなく、以下の設定をコピペするだけです。\ntravis\nlanguage:rustrust:- nightly- beta- stableos:- linux- osx appveyor\nbranches:except:- gh-pagesplatform:- x64environment:RUST_INSTALL_DIR:C:\\Rustmatrix:- RUST_INSTALL_TRIPLE:i686-pc-windows-msvcRUST_VERSION:1.4.0- RUST_INSTALL_TRIPLE:i686-pc-windows-msvcRUST_VERSION:beta- RUST_INSTALL_TRIPLE:i686-pc-windows-msvcRUST_VERSION:nightly- RUST_INSTALL_TRIPLE:x86_64-pc-windows-msvcRUST_VERSION:1.4.0- RUST_INSTALL_TRIPLE:x86_64-pc-windows-msvcRUST_VERSION:beta- RUST_INSTALL_TRIPLE:x86_64-pc-windows-msvcRUST_VERSION:nightlyinstall:- ps:Start-FileDownload \u0026#34;https://static.rust-lang.org/dist/rust-${env:RUST_VERSION}-${env:RUST_INSTALL_TRIPLE}.exe\u0026#34;- cmd:rust-%RUST_VERSION%-%RUST_INSTALL_TRIPLE%.exe /VERYSILENT /NORESTART /DIR=\u0026#34;%RUST_INSTALL_DIR%\u0026#34;- cmd:SET PATH=%PATH%;%RUST_INSTALL_DIR%\\bin- rustc --version- cargo --versionbuild:falsetest_script:- cargo build --verbose- cargo test --verbose バッジとかは適当に持ってきましょう。\nサンプルが欲しければStebalien/tempfileあたりを参考にしましょう。\nそれではHave Happy Hacκings!\n※OS関連の煽りはただのネタです。また「あまり使われていませんがMacでのCI環境を」は「(travisの中では)あまり使われていません(のでもしかしたら使えることを知らない人がいるかもしれません)が」という意味です。\n","categories":["Rust","Advent Calendar","Advent Calendar 2015","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2015","/categories/rust-advent-calendar"],"date":"2015-12-20","title":"travisとappveyorでクロスプラットフォームなCIする話","url":"https://KeenS.github.io/blog/2015/12/20/travistoappveyerdekurosupurattofo_munacisuruhanashi/"},
  {"body":"このエントリはClojure Advent Calendar 2015の16日目の記事です（大遅刻）\nκeenです。ここのところ体調優れず、また、特に面白いネタもなくClojure Advent Calendarに遅刻したことをお詫び申し上げます。\nさて、今日はReactive Messaging PatternをClojureのcore.asyncでやってみたいと思います。Reactive Messaging Pattersは、Java/Scala向けActorシステムのAkkaの作者が著した本、Amazon.co.jp: Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akkaで書かれているデザインパターンです。\n非常に興味深い本なのですがScala及びAkka初心者の私には中々辛いので一旦Clojureで試してみようかと。\nところで、AkkaとClojureのcore.asynkには若干のモデルの違いがあります。詳しくはこことかにあるのですが、一番大きくは非同期/同期モデルの違いがあります。 Akkaの場合はActorにメッセージを送っても届いたという保障はなく(「その瞬間に」届いてないだけでなく、届く前にActorが再起動したらメッセージがロストしてしまう!)、また、メッセージの受信もreceiveというコールバック用のメソッドを用意してそこでハンドルすることになります。\nそういう違いがある中でどれだけClojureに翻訳出来るか多少不安ですがチャレンジしてみます。尚、原書には様々なパターンがあるのですが流石に本一冊分全部は紹介し切れないので面白そうでかつClojureでも役立ちそうなものだけ紹介することにします。このコードは原書のものをClojureに翻訳したものではなく、私が勝手に書いたものです。コードを参考にするのは雰囲気程度に留めて、実際を知りたかったら原書を読みましょう。\n今回、\n(defproject reactive-message-patterns \u0026#34;0.1.0-SNAPSHOT\u0026#34; :description \u0026#34;FIXME: write description\u0026#34; :url \u0026#34;http://example.com/FIXME\u0026#34; :license {:name \u0026#34;Eclipse Public License\u0026#34; :url \u0026#34;http://www.eclipse.org/legal/epl-v10.html\u0026#34;} :dependencies [[org.clojure/clojure \u0026#34;1.7.0\u0026#34;] [org.clojure/core.async \u0026#34;0.2.374\u0026#34;]]) というプロジェクト設定で試しました。また、ソースコードはこちらで公開しています。\nMessaging With Actors Pipes And Filters メッセージが来る際に、そのまま受け取るのではなく一旦Filter用のActorで変換やvalidationをかけて本処理に入ります。\nClojureならfilter\u0026lt;/filter\u0026gt;/ transducerで瞬殺 Filter処理をActorに分離することで並列性やモジュール性が上がります。原書の例ではまずDecrypt Filterを噛ませてAuthenticate Filterで認証出来たら De-dup Filterで重複を取り除いてメッセージをクリーンにしてから処理を始める、とういうように非常に実用的な例が出ています。\nまた、(transformでなく、篩い分けの)Filterを分離することでFilterした後の処理、例えばinvalidなメッセージが来たらログに出すなどの柔軟性を得ることが出来ます。\nこれを実装してみましょう。すごい適当ですがメッセージが来たらそれを2倍するfilterを作ってみます。\n(use \u0026#39;clojure.core.async) (defn filter-actor ([f] (let [in (chan) out (chan)] (do (filter-actor f in out) [in out]))) ([f in out] (go-loop [] (if-let [v (\u0026lt;! in)] (if-let [ret (f v)] (if (\u0026gt;! out ret) (recur))) (close! out))))) (let [[in out] (filter-actor (fn [x] (* x 2)))] (go ;; producer (doseq [v (range 1 10)] (\u0026gt;! in v)) (close! in)) (go-loop [] ;; consumer (if-let [v (\u0026lt;! out)] (do (println v) (recur)) (close! out)))) 簡単ですね。チャネルが終わったかどうか調べるのに一々if-letを使うのが面倒ですがリストに対する再帰関数もそんな感じなのでまあ、こういうもんなんでしょう。\nその他 他にもMessaging With ActorsにはMessage Router, Message Translator, Message Endpointsなどのパターンが載っているのですが割愛します。特にMessage Translatorは外部システム(HTTPリクエスト、MQ, SQLなど)とのやりとりの話なので簡単に試すには少し重すぎるようです。\nMessaging Channels この章にはActor同士のメッセージのやりとりの方法が色々書かれています。 Point-to-Point Channel, Publish-Subscribe Channel, Datatype Channel, Invalid Message Channel, Dead Letter Channel, Guaranteed Delivery, Channel Adapter, Message Bridge, Message Bus。 中々多くのパターンが載っているのですが一部はAkka固有であったりClojureには必要なかったりしますので、私が興味を持ったものを紹介します。\nPublish-Subscribe 定番ですね。概念自体の説明は不要と思います。core.asyncだとどうなるのかを見てみます。pubとsubを使います。\n(let [publisher (chan) publication (pub publisher :topic) subscriber1 (chan) subscriber2 (chan)] (sub publication :delete subscriber1) (sub publication :create subscriber1) (sub publication :update subscriber2) (sub publication :read subscriber2) ;; start subscribers before publish start (go-loop [] (when-let [v (\u0026lt;! subscriber1)] (printf \u0026#34;I\u0026#39;m One, got %s\\n\u0026#34; (:type v)) (recur))) (go-loop [] (when-let [v (\u0026lt;! subscriber2)] (printf \u0026#34;I\u0026#39;m Two, got %s\\n\u0026#34; (:type v)) (recur))) (go (onto-chan publisher [{:topic :update, :type \u0026#34;dog\u0026#34;} {:topic :create, :type \u0026#34;cat\u0026#34;} {:topic :read , :type \u0026#34;fox\u0026#34;}])) ) おもちゃのような例ですがこれで動くようです。因みに原書ではここに結構なページ数が割かれていて、分散システムを念頭に、異なるシステムにメッセージを送る話なども扱っています。core.asyncだとそこまでは出来そうにないですね。\nInvalid Message Channel とあるActorに予期しないメッセージが届いたらどうしましょうか。そのまま捨てますか？もしかしたらバグを潰せる好機かもしれないのにそのまま捨てるには勿体なすぎます。 かといって全てのActorにデバッグ用のコードを入れていては埒が明かないどころかコードが複雑化してしまいます。そこでInvalid Massage Channelを使いましょう。\nあるActorに予期しないメッセージが届いた時に、全てを放り投げるチャネルを用意しておいて、その先のActorでログを出すなりするのです。\n今回は:priceタグのついていないメッセージが届いた時にinvalid actorに放り投げ、ログを出すものを作りました。\n(defn invalid [data] {:data data :from (Thread/currentThread)}) (let [invalid-chan (chan) in (chan) tax 0.08] ;; invalid message processor (go-loop [] (when-let [{data :data from :from} (\u0026lt;! invalid-chan)] (printf \u0026#34;invalid data %s from %s from\\n\u0026#34; data from) (recur))) ;; main processing actor (go-loop [] (when-let [v (\u0026lt;! in)] (if-let [price (:price v)] (printf \u0026#34;price: %f\\n\u0026#34; (* price (+ 1 tax))) (\u0026gt;! invalid-chan (invalid v))) (recur))) (go (onto-chan in [{:goods \u0026#34;はじめてのClojure\u0026#34; :price 1900} {:goods \u0026#34;プログラミングClojure\u0026#34; :price 3400} {:goods \u0026#34;へび\u0026#34; :description \u0026#34;にょろにょろ\u0026#34;}]))) fromについてはActorならアクターオブジェクトに対してリフレクションかけて何かしらの情報をとれるのですがgoに対するリフレクションが分からなかったので代わりにスレッド情報を使いました。 私はこの章を読んだ時にいたく完動しました。ログの扱いを集約出来るし地味にIOして非同期モデルのアクターの邪魔になるログをそれぞれのアクターに持たなくて済む。 しかしこれのActorが落ちたら、とかこのActor自身にinvalidなメッセージが来たら、とか色々考えたくなります。詳しくは原書を読みましょう。\nその他 この章には他にも外部システムと連携するMessage Adapter、外部のメッセージングシステムと連携するMessage Bridge、複数のシステム間でメッセージをやりとりするMessage Busなどが載っていますが割愛します。\nMessage Construction この章にはCommand Message, Document Message, Event Message, Request-Reply, Return Address, Correlation Identifire, Message Sequence, Message Expiration, Format Indicatorなどのメッセージ自体にまつわる話題が載っています。\n疲れてきたため AkkaやScala特有の話題が多いので1つだけに絞ります。。まあ、だいたいErlangとかやってたら自然と覚えるやつらです。\nDocument Message Command MessageやEvent Messageは良く見ますが、Document Messageとはどのようなものでしょうか。原書にはこう書いてあります\n Use a Document Message to convey information to a receiver, but without indicating how the data should be used.\n 「受取側に情報を伝えはするが、その情報がどのように扱われるべきかを指示しない時にDocument Messageを使います」Command Messageに付随する情報でもなくEvent Messageに付随する情報でもなくただ単なる情報です。\nこれは例えばデータベースアダプタのような所で使うことになります。\n(let [db [{:id 1 :name \u0026#34;Aho\u0026#34;} {:id 2 :name \u0026#34;Ulman\u0026#34;} {:id 3 :name \u0026#34;Sethi\u0026#34;}] in (chan)] (go-loop [] (when-let [[id return] (\u0026lt;! in)] (\u0026gt;! return (some #(when (= id (:id %) ) %) db)) (recur))) (let [chan-cache (chan)] (go-loop [id 1] (\u0026gt;! in [id chan-cache]) (when-let [res (\u0026lt;! chan-cache)] (println res) (recur (+ id 1)))))) 複数のアクセスがあることを考えると双方向チャネルがあるからといってそれ1つを使うのは良くないでしょう。混線してしまいます。今回は返信用のチャネル自身も一緒に送ってしまってそこにDocumentを貰うことにしました。 ActorならActor ID(Ref)を送ることになるでしょう。\nMessage Routing この章は主にAkkaのクラスタ、分散実行に関る内容です。それ自体非常に興味深いのですがClojureだと試せないので飛ばします。 まあ、実際にはクラスタを組まなくてもいくつかのactorを使ってactor群同士でやりとりをすればいいのですが準備が中々面倒ですね。\n一応扱われているトピックを拾うとContent Based Router, Message Filter, Dynamic Router, Recipient List, Splitter, Aggregator, Resequencer, Composed Message Processor, Scatter-Gather, Routing-Slip, Process Manager, Message Brokerです。 見ての通り非常に数が多く、ページ数もかなり割かれています。そして、よく使いそうなパターンが多く載っています。Scatter-Gatherとか重い処理する時に使いそうなんですけどね。\nなどなど ここまでで、4~7章を紹介しました。原書は10章まで続きます(1-3章は何故Actorが必要なのかなどを延々語ってます)が私はこの辺で筆を置くことにします。続きが気になる方は原書をお読み下さい。\nAdvent Calendar遅刻して大変申し分けありませんでした。\n","categories":["Lisp","Clojure","Advent Calendar","Advent Calendar 2015","Lisp Advent Calendar"],"category_urls":["/categories/lisp","/categories/clojure","/categories/advent-calendar","/categories/advent-calendar-2015","/categories/lisp-advent-calendar"],"date":"2015-12-19","title":"ClojureでReactive Messaging Pattern","url":"https://KeenS.github.io/blog/2015/12/19/clojuredereactive_messaging_pattern/"},
  {"body":"# DSLとTagless Final ---------------------- サイバーエージェント アドテクスタジオ Scala Meet Up 2015-12-18 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + AMoAdの新卒エンジニア + Lisp, ML, Rust, Shell Scriptあたりを書きます - Scalaは初心者 ※ [Scala初心者の新卒が頑張ってLispを作ってみた](http://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/) === # 注意 ------ * Scala初心者なのでScalaではなくScalaっぽい疑似コードで説明します + ~~コード例動かす時間が無かっただけ~~ * Scala初心者なのでScalaのコードは少なめに説明します === # DSLを作る ----------- 以下のようなHTTPなユーザをエミュレートするDSLを考える ``` scala val scenario = and( get(\"/\"), get(\"/users\").andThen(res = post(\"/follow\", first(users.getJsonData)))) val Right(_) = runScenario(scenario, \"user\") ``` === # DSLを作る ----------- 普通は以下のようなAST作ってをラップする ``` scala trait ScenarioDSL sealed case class Get(url: String) extends ScenarioDSL sealed case class Post(url: String, data: JSON) extends ScenarioDSL sealed case class And(first, ScenarioDSL, second ScenarioDSL) extends ScenarioDSL sealed case class AndThen(first: ScenarioDSL, callBack: (Response) = ScenarioDSL) extends ScenarioDSL def get(url: String): ScenarioDSL= Get(url) .... ``` === # DSLを作る ----------- そして`runScenario`を作る ``` scala def runScenario(scenario: ScenarioDSL, user: String) = { scenario match { Get(url) = Client.getInstance(user).get(url) Post(url) = Client.getInstance(user).post(url) And(first, second) = {runSenario(first, user); runSenario(second, user)} .... } } ``` === # DSLを便利に ------------- 例えば、このDSLを`curl`コマンド関数を追加する ``` scala def toCurl(scenario: ScenarioDSL, user: String) = val auth = makeAuth(user) scenario match { Get(url) = \"curl ${auth} ${SERVICE_HOST}/url\" Post(url) = \"curl ${auth} -XPOST ${SERVICE_HOST}/url\" And(first, second) = toCurl(first) + \"\\n\" + toCurl(second) .... } } ``` === # DSLの拡張 ----------- このDSLに新たに`select`を追加する ``` scala val scenario = and( get(\"/\"), select(get(\"/users\"), post(\"/update\"))) val _ = runScenario(scenario, \"user\") ``` === # Expression Problem ------------------- この時に問題が出る * DSLを使う全てのコードに変更が必要 + `runScenario`と`toCurl`で`select`に対応する * DSLそのものに手を加える必要がある + DSLがsealed traitされてる + そもそも、DSLがライブラリだったら変更出来るの？ * 実際には使ってなくても全ての関数で新しい機能に対応しないといけない + `toCurl`では`select`に対応しないとか + 逆に、`toCurl`がプラグインでコードいじれなかったらどうしよう === # Tagless Finalで解決出来るよ ---------------------------- * 元のコードをいじらず * 必要な所だけを記述して * しかも元々の実装よりも速い DSLの作り方があります。それは型クラスを使ったやり方です。 === # 型クラスの復習 --------------- 型クラスは * 型の振る舞うインターフェースを定めて * インスタンスの型ごとに「後付けで」実装を与えると * 多相的に扱えるアドホックポリモーフィズム でした === # 型クラスの復習 --------------- ``` rust trait Hello { //型クラス fn hello(\u0026self) - String; } impl Hello for isize { //isize型のインスタンス fn hello(\u0026self) - String {format!(\"I'm {} years old\", self)} } impl Hello for \u0026'a str {//\u0026str型のインスタンス fn hello(\u0026self) - String {format!(\"My name is {}\", self)} } fn main() { println!(\"{}\", 23.hello()); // = \"I'm 23 years old\" println!(\"{}\", \"κeen\".hello()); // = \"My name is κeen\" } ``` === # DSLをRustに翻訳 ------------- Scalaで型クラスを説明するとややこしいので一旦先のDSL例をRustに翻訳します ``` rust let scenario = and( get(\"/\".to_string()), get(\"/users\".to_string()).andThen(|req| post(\"/follow\".to_string(), req.getJsonData().first))); runScenario(scenario, \"user\").unwrap(); ``` === # Rustに翻訳 ------------- DSLのASTはこうなります。 ``` rust enum ScenarioDSL { Get{url: String}, Post{url: String, data: RequestData}, And{first: Box, second: Box}, AndThen{first: Box, callBack: FnOnceScenarioDSL}, } ``` === # Rustに翻訳 ------------- runScenarioはこうなります。 ``` rust fn runScenario(scenario: \u0026ScenarioDSL, user: \u0026str)- Result { match scenario { \u0026ScenarioDSL::Get{ref url} = Client::instance(user).get(url), \u0026ScenarioDSL::Post{ref url} = Client::instance(user).post(url), \u0026ScenarioDSL::And{ref first, ref second} = { try!(runSenario(first)); runSenario(second) }, ... }; } ``` === # Rustに翻訳 ------------- `toCurl`はこうなります ``` rust fn toCurl(scenario: \u0026ScenarioDSL, user: \u0026str)- String { let auth = makeAuth(user) match scenario { \u0026ScenarioDSL::Get{ref url} = format!(\"curl {} {}{}\", auth, SERVICE_HOST, url) \u0026ScenarioDSL::Post{ref url} = format!(\"curl {} -X POST {}{}\", auth, SERVICE_HOST, url) \u0026ScenarioDSL::And{ref first, ref second} = { let first_str = toCurl(first, user); let second_str = toCurl(second, user); format!(\"{}\\n{}\", first_str, second_str) }, ... } } ``` === # Tagless Final --------------- Rustの準備が終わったのでTagless Finalの説明に入ります。 === # Tagless Final ---------------- * ASTをデータではなく関数で表わす * 同じ関数でも欲しい結果によって計算を変えるために型クラスを使う * どの型クラスのインスタンスとして扱うかで結果を変える + そもそもASTは計算を抽象化してデータにしたもの。 + 抽象的な計算があるならデータにする必要はない * 型クラスでジェネリックに作って * 欲しい型を伝えるだけで挙動が変わる === # 型クラス ---------- DSLの文法の型クラスを定義する。 DSLっぽく見せるため、ラッパを書く(Rust特有)。 ``` rust trait ScenarioSYM { fn get(url: String) - Self; fn post(url: String) - Self; fn and(first: Self, second: Self) - Self; ... } fn get(url: String) - C {C::get(url)} fn post(url: String) - C {C::post(url)} fn and(first: C, second: C) - C {C::and(first, second)} ... ``` === # `runScenario` ------ 結果に`Result`型が結果として欲しいなら`Result`型に`ScenarioSYM`を実装する ```rust impl ScenarioSYM for Result { fn get(self,url: String) - Self {...} fn post(self, url: String) - Self {...} fn and(self, url: String) - Self {...} } fn runScenario(res: Result) - Result { res } ``` === # `toCurl` ---------- `String`が欲しいなら`String`に実装すれば良い。 ``` rust impl ScenarioSYM for String { fn get(self, url: String) - Self {...} fn post(self, url: String) - Self {...} fn and(self, url: String) - Self {...} } fn toCurl(str: String) - String { str } ``` === # 完成形 -------- ``` rust let scenario = and( get(\"/\".to_string()), get(\"/users\".to_string()).andThen(|req| post(\"/follow\".to_string(), req.getData().iter().next()))); // ↑ここまではジェネリックなScenarioSYM型 // ↓ここで呼ばれることでResult型にインスタンス化される runScenario(scenario, \"user\").unwrap(); ``` === # DSLの拡張 ----------- 拡張したい文法のDSLを定義して、欲しいものに実装するだけ。 `runScenario`に変更は要らないしサポートしない`toCurl`は気にしなくて良い。 ``` rust trait SelectSYM { fn select(self, first: Self, second: Self) - Self; } impl SelectSYM for Result { fn select(self, first: Self, second: Self) - Self {...} } ``` === # Tagless Finalまとめ --------------------- * この方式だと実行時にタグでパターンマッチしないので速い * DSLの拡張も機能の拡張も容易 * 型クラス便利 === # ScalaでのTagless Final ------------------------ Rustで分かりやすく解説したのでScalaでどうなるか見ていきます。 まずは型クラスを定義 ``` scala trait ScenarioSYM[C] { def get(self: C, url: String): C def post(self: C, url: String): C ... } def get(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.get(self, url) def post(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.post(self, url) ... ``` === # `runScenario` ------ ``` scala implicit val resultScenario = new ScenarioSYM[Either[Err, ()]] { def get(self: Either[Err, ()], url: STring): Either[Err, ()] = ... def post(self: Either[Err, ()], url: STring): Either[Err, ()] = ... ... } def runScenario(ast: Either[Err, ()], user: String) (implicit i: ScenarioSYM[Either[Err, ()]]) = ast ``` === # 完成形 -------- Scalaの型クラスの制約上最初の例と少し異なる (`val`じゃなくて`implicit`を取る`def`になる) ``` scala def scenario(implict i: ScenarioSYM[C]) = Scenario get(\"/\") get(\"/users\") andThen((scenario, res) = scenario post(\"/follow\", first(users.getJsonData))) val Right(_) = runScenario(scenario, \"user\") ``` === # まとめ -------- * Expression Problemについて説明した * Tagless Finalを紹介した * 型クラス便利 * Rust便利 * [参考](http://okmij.org/ftp/tagless-final/course/)   ","categories":["Scala","Scala Meet Up"],"category_urls":["/categories/scala","/categories/scala-meet-up"],"date":"2015-12-13","title":"DSLとTagless Final","url":"https://KeenS.github.io/slide/dsltotagless_final/"},
  {"body":"このエントリはRust Advent Calendar 14日目の記事です\n前:gifnksmさんの kcovを使ってRustプログラムのカバレッジを測定する - gifnksmの雑多なメモ\n後:nacika_insさんのtimeこわい\nκeenです。当初の予定より小ネタになってしまいましたがRustでの日本語の扱いについて書こうかと。\nご存じの通りRustはマルチバイト文字をサポートしていますが、その殆どがUTF-8だけです。しかし日本人にはUTF-8だけでは少し辛いものがありますのでどうにかして対応しようかと。\nソースコード中でもマルチバイト文字を扱えますが、UTF-8である必要があります。\n例えば\nfn main(){println!(\u0026#34;あああ\u0026#34;);} これをISO-2022-JPで保存してrustcに食わせても、\nerror: couldn\u0026#39;tread\u0026#34;src/main.rs\u0026#34;: streamdidnotcontainvalidUTF-8Couldnotcompile`japanese`. と無下もないエラーが出てしまいます。\n内部エンコーディングにもUTF-8が使われているのでRustの文字列をUTF-8以外で出力するにはなんとなく変換が必要そうなのは理解出来ますが、変に出入力をラップしてる関数を使うとまた意図せぬエラーが出ます。\nusestd::fs::File;usestd::io::BufRead;usestd::io::BufReader;fn main(){letfile=File::open(\u0026#34;japanese.txt\u0026#34;);letbr=BufReader::new(\u0026amp;file);forlineinbr.lines(){matichline{Ok(l)=\u0026gt;println!(\u0026#34;Ok: {}\u0026#34;,l),Err(e)=\u0026gt;println!(\u0026#34;{:?}\u0026#34;,e)};}} これもまた、stream did not contain valid UTF-8エラーを出します。\nReadもBufReadもbyte orientedって言ってるのに何故か文字列を扱えるのが若干気になりますがまあ、そういうもんなんでしょう。\nencoding そこで救世主となるライブラリがlifthrasiir/rust-encodingです。文字列のエンコーディングをサポートします。 READMEに詳しい使い方が載っているのですが、このライブラリは与えられたスライスに対して指定されたエンコーディングでエンコード/デコードします。\nなので先の例のようにISO-2022-JPで\u0026quot;あああ\u0026quot;と出力したいなら\nexterncrateencoding;useencoding::{Encoding,EncoderTrap};useencoding::all::ISO_2022_JP;usestd::io::Stdout;fn main(){letbytes=ISO_2022_JP.encode(\u0026#34;あああ\u0026#34;,EncoderTrap::Ignore);Stdout.write_all(\u0026amp;bytes[..]);} と出来るでしょう。(即興で書いてコンパイルすらしてないので本当に出来るかは分かりませんが)\n読み取りに関しては…………。そう、このライブラリはバッファに対してしか動作せず、ストリームに使えないのです。提供してくれたら良さそうなのですが、作者の方が忙しいようです。\n@blackenedgold stream encoding/decodingは計画してはいるのですが、私が忙しくてなかなか作業をすることができません\u0026hellip; orz\n\u0026mdash; Kang Seonghoon (@senokay) 2015, 11月 17 \n余談ですがこの方は韓国の方のようですが、日本語もある程度分かるそうです。すごいですね。\nさて、ストリームに対して使えないと分かったなら自分で対応するまで。幸いにも我々が使っているのはRustです。新しいものを既存の仕組みに載せるのは造作もありません。 ストリームを良い感じにデコードするにはstd::io::Readを実装した何かを作れば十分です。作っていきましょう。Readトレイトを実装するには最低readだけ実装してしまえば十分です。\nこのreadですが、ドキュメントを読むと中々制限が緩いようです。\n Pull some bytes from this source into the specified buffer, returning how many bytes were read.\nThis function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an Err return value.\nIf the return value of this method is Ok(n), then it must be guaranteed that 0 \u0026lt;= n \u0026lt;= buf.len(). A nonzero n value indicates that the buffer buf has been filled in with n bytes of data from this source. If n is 0, then it can indicate one of two scenarios:\nThis reader has reached its \u0026ldquo;end of file\u0026rdquo; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will always no longer be able to produce bytes. The buffer specified was 0 bytes in length.\nNo guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true. It is recommended that implementations only write data to buf instead of reading its contents.\n です。\n No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true.\n 「関数が呼ばれる際にbufに対しては何如なる保証もなく、呼出側はバッファの内容に対して何如なる不変条件も期待してはいけません」とあります。つまり、4096 byteのバッファが与えられても1呼び出しにつき1バイトしか返さないような実装でも許容されます。 また、非同期ベースのIOのようにキャッシュにデータがなければIOブロッキングせずにエラーだとかの挙動もありえます。非常にシステムプログラミング言語らしい仕様ですね。\n今から作ろうとしているデコーディングストリームも読み出したバイト列がデコード後に何バイトになるのか予測がつかないのでこの仕様は有難いですね。\nさて、作っていきましょうか。まずは必要そうなライブラリを読み込みます。\nexterncrateencoding;useself::encoding::{EncodingRef,DecoderTrap};usestd::io::Read;usestd::io; そしてメインとなる構造体です。とあるReadを実装した型をラップする形にしましょう。\npubstruct DecodingReader\u0026lt;R\u0026gt;{inner: R,encoding: EncodingRef,} Readはトレイトなのでinnerのところを\u0026amp;Rとしなくて大丈夫です。Readの実装側が調整します。\nそしてコンストラクタですね。\nimpl\u0026lt;R: Read\u0026gt;DecodingReader\u0026lt;R\u0026gt;{pubfn new(coding: EncodingRef,read: R)-\u0026gt; Self{EncodingReader{inner: read,encoding: coding}}} そのままですね。\nReadの実装です。まずはinnerのreadを呼んで、その結果を一旦デコードしてからまたバイト列に変換します。\nimpl\u0026lt;R: Read\u0026gt;ReadforDecodingReader\u0026lt;R\u0026gt;{fn read(\u0026amp;mutself,buf: \u0026amp;mut[u8])-\u0026gt; io::Result\u0026lt;usize\u0026gt;{// TODO set appropriate buffer size letlen=buf.len()/2;letn=try!(self.inner.read(\u0026amp;mutbuf[..len]));// TODO don\u0026#39;t ignore input code letstr=self.encoding.decode(\u0026amp;mutbuf[..n],DecoderTrap::Ignore).unwrap();letmuti=0;for(d,s)inbuf.iter_mut().zip(str.bytes()){*d=s;i+=1;ifi==0{break};}assert!(i\u0026lt;=buf.len());Ok(i)}} 先程も言った通りデコード読み込んだバイト列をUTF-8にした時にどれくらいバイト数が変わるか分からないので山勘で2倍くらいに膨らむだろうとして与えられたバッファ長の半分を使います。 ここはもう少し調整が必要ですね。エンコーディング毎に適切なバッファ長を設定したい…\nバッファを確保出来たらlet n = try!(self.inner.read(\u0026amp;mut buf[..len]));してそれっぽいサイズ読み込んで、読み込んだサイズをデコードにかけます。\n現在DecoderTrapをIgnoreにしてunwrapしてますが、これは少し雑すぎますね。例えば入力が全てvalidな文字を含んでいたとしてもreadが多バイト文字の真ん中までしか読まなかった時にそれが無効なエンコーディングと判定されて無視されるのでユーザからしたら「合ってる筈なのに何故か1文字欠損するバグ」として現れます。今回即席で作ったので勘弁して下さい。\n変換は文字列にしか出来ないようなので一旦文字列に落してからまたバイト列として取り出し、バッファに書き出します。デコード後のバイト列がreadしたバイト列より小さかったら一部readしたデータが残ってしまいそうですが、「何如なる不変条件も…」とあるので問題ないでしょう。返り値にデコード後のバイト列の長さを返していれば良い筈です。\nさて、エンコードのエラーハンドリングしてないだとか本当に読み込みのバッファ長が適切なのかとかの疑問はあるものの、一応ストリームのデコーダが出来ました。使ってみましょう。\nexterncrateencoding;externcratejapanese;useencoding::{Encoding,DecoderTrap};useencoding::all::ISO_2022_JP;usestd::fs::File;usestd::io::BufReader;usestd::io::BufRead;usestd::str::from_utf8;usejapanese::buf::DecodingReader;fn main(){letfile=File::open(\u0026#34;src/japanese.txt\u0026#34;).unwrap();lete=DecodingReader::new(ISO_2022_JP,\u0026amp;file);letmutbr=BufReader::new(e);forlineinbr.lines(){println!(\u0026#34;{}\u0026#34;,line.unwrap());}} これでちゃんとISO-2022-JPのファイルを読めます。\nJavaに慣れてる人ならこういうIOに対するデコレータパターンは見覚えがあるでしょう。\n今更ですがiso-2022-jpはいわゆるjisエンコーディングです。rust-encodingはshift_jisの拡張にあたるwindows31jだとかeuc-jpも扱えます(参考)。\n今後 ライブラリとして公開するか、あるいは作者の方がやる気はあるようなのでプルリクを送るかが終着点かな、と思っていますが如何せん雑にしか実装してないので微妙ですね。 例の境界とマルチバイトの問題はReadじゃなくBufReadを要求して1文字分読み切るまで来るまで1バイトずつ読むとかになると思います。ダルい。\nまとめ  Rust標準だけでUTF-8以外の文字列を使うのはつらいよ Rustのエンコーディングライブラリを紹介したよ エンコーディングライブラリを使ってストリームデコーダを実装してみたよ。  今回のコードはこちらにあります\n","categories":["Rust","Advent Calendar","Advent Calendar 2015","小ネタ","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2015","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf","/categories/rust-advent-calendar"],"date":"2015-12-13","title":"Rustでの日本語の扱い","url":"https://KeenS.github.io/blog/2015/12/13/rustdenonihongonoatsukai/"},
  {"body":"このエントリは言語実装 Advent Calendar 201516日目の記事です。\nκeenです。かねてより気になっていたREPLの実装方法について、SML#のソースコードを読んだのでその話でもします。\nさて、ソースコードを読みながらやっていきましょう。SML# 2.0.0のソースコードです。\nREPLのエントリポイントはsrc/compiler/main/main/SimpleMain.smlL949です。\n | Interactive (options, context) =\u0026gt; let val newContext = Top.loadInteractiveEnv {stopAt = Top.NoStop, stdPath = [#systemBaseDir options], loadPath = nil} context (Filename.concatPath (#systemBaseDir options, Filename.fromString \u0026#34;prelude.smi\u0026#34;)) val context = let val context = Top.extendContext (context, newContext) val context = Top.incVersion context in context end val _ = ReifiedTermData.init (#topEnv context) handle e =\u0026gt; raise e in RunLoop.interactive options context; SUCCESS end いろいろごちゃごちゃやってますがオプションと共にRunLoop.interactiveを呼んでるだけです。\nさて、RunLoop.smlはSimpleMain.smlと同じディレクトリにあります。interactive関数は次のように定義されています。\nfun interactive options context = let ... val state = initInteractive () fun loop context input = if !(#eof state) then () else (Counter.reset(); NameEvalEnv.intExnConList(); case run options context input of SUCCESS newContext =\u0026gt; .... | FAILED =\u0026gt; loop (Top.incVersion context) (interactiveInput state) ) in loop context (interactiveInput state) end 何やら状態を初期化した後はinteractiveInputで得られた結果をrunに渡しているようです。runを見ましょう。\nfun run ({stdPath, loadPath, LDFLAGS, LIBS, errorOutput, llvmOptions, ...}:options) context input = let fun puts s = TextIO.output (errorOutput, s ^ \u0026#34;\\n\u0026#34;) val options = {stopAt = Top.NoStop, baseFilename = NONE, stdPath = stdPath, loadPath = loadPath} val ({interfaceNameOpt, ...}, result) = Top.compile options context input handle e =\u0026gt; ( case e of UserError.UserErrors errs =\u0026gt; app (fn e =\u0026gt; puts (userErrorToString e)) errs | UserError.UserErrorsWithoutLoc errs =\u0026gt; app (fn (k,e) =\u0026gt; puts (userErrorToString (Loc.noloc,k,e))) errs | Bug.Bug s =\u0026gt; puts (\u0026#34;Compiler bug:\u0026#34; ^ s) | exn =\u0026gt; raise exn; raise CompileError ) val (newContext, module) = case result of Top.RETURN (newContext, module) =\u0026gt; (newContext, module) | Top.STOPPED =\u0026gt; raise Bug.Bug \u0026#34;run\u0026#34; in let val objfile = TempFile.create (\u0026#34;.\u0026#34; ^ SMLSharp_Config.OBJEXT ()) val asmfile = TempFile.create (\u0026#34;.\u0026#34; ^ SMLSharp_Config.ASMEXT ()) val _ = #start Counter.llvmOutputTimeCounter() val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile, Filename.toString asmfile) val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile, Filename.toString objfile) val _ = #stop Counter.llvmOutputTimeCounter() val _ = LLVM.LLVMDisposeModule module val sofile = TempFile.create (SMLSharp_Config.DLLEXT ()) val ldflags = case SMLSharp_Config.HOST_OS_TYPE () of SMLSharp_Config.Unix =\u0026gt; nil | SMLSharp_Config.Cygwin =\u0026gt; [\u0026#34;-Wl,-out-implib,\u0026#34; ^ Filename.toString (Filename.replaceSuffix \u0026#34;lib\u0026#34; sofile)] | SMLSharp_Config.Mingw =\u0026gt; [\u0026#34;-Wl,--out-implib=\u0026#34; ^ Filename.toString (Filename.replaceSuffix \u0026#34;lib\u0026#34; sofile)] val libfiles = case SMLSharp_Config.HOST_OS_TYPE () of SMLSharp_Config.Unix =\u0026gt; nil | SMLSharp_Config.Cygwin =\u0026gt; map (fn x =\u0026gt; Filename.toString (Filename.replaceSuffix \u0026#34;lib\u0026#34; x)) (!loadedFiles) | SMLSharp_Config.Mingw =\u0026gt; map (fn x =\u0026gt; Filename.toString (Filename.replaceSuffix \u0026#34;lib\u0026#34; x)) (!loadedFiles) val _ = BinUtils.link {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS @ ldflags, libs = libfiles @ LIBS, objects = [objfile], dst = sofile, useCXX = false, quiet = not (!Control.printCommand)} val so = DynamicLink.dlopen\u0026#39; (Filename.toString sofile, DynamicLink.GLOBAL, DynamicLink.NOW) handle OS.SysErr (msg, _) =\u0026gt; raise DLError msg val {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} = GenerateMain.moduleName (interfaceNameOpt, #version context) val smap = DynamicLink.dlsym\u0026#39; (so, stackMapSymbol) handle OS.SysErr (msg, _) =\u0026gt; raise DLError msg val base = DynamicLink.dlsym\u0026#39; (so, codeBeginSymbol) handle OS.SysErr (msg, _) =\u0026gt; raise DLError msg val _ = sml_register_stackmap (smap, base) val ptr = DynamicLink.dlsym (so, mainSymbol) handle OS.SysErr (msg, _) =\u0026gt; raise DLError msg (* * Note that \u0026#34;ptr\u0026#34; points to an ML toplevel code. This toplevel code * should be called by the calling convention for ML toplevels of * ML object files. __attribute__((fastcc,no_callback)) is an ad * hoc way of yielding this convention code; no_callback avoids * calling sml_control_suspend. If we change how to compile * attributes in the future, we should revisit here and update the * __attribute__ annotation. *) val mainFn = ptr : _import __attribute__((fastcc,no_callback)) () -\u0026gt; () in loadedFiles := sofile :: !loadedFiles; mainFn () handle e =\u0026gt; raise UncaughtException e; SUCCESS newContext end handle e =\u0026gt; ( case e of UserError.UserErrors errs =\u0026gt; app (fn e =\u0026gt; puts (userErrorToString e)) errs | UserError.UserErrorsWithoutLoc errs =\u0026gt; app (fn (k,e) =\u0026gt; puts (userErrorToString (Loc.noloc,k,e))) errs | DLError s =\u0026gt; puts (\u0026#34;failed dynamic linking. Perhaps incorrect name in _import declaration: \u0026#34; ^ s) | UncaughtException exn =\u0026gt; puts (\u0026#34;uncaught exception \u0026#34; ^ exnMessage exn) | CoreUtils.Failed {command, message} =\u0026gt; (puts (\u0026#34;command failed: \u0026#34; ^ command); puts message) | _ =\u0026gt; raise e; FAILED ) end handle CompileError =\u0026gt; FAILED デカいですね。どうやらrunがREPLの本体のようです。少しずつ見ていきます。\nまずはコンパイルしているようです。\nval ({interfaceNameOpt, ...}, result) = Top.compile options context input そして結果からcontextとmoduleを取り出します。\nval (newContext, module) = case result of Top.RETURN (newContext, module) =\u0026gt; (newContext, module) | Top.STOPPED =\u0026gt; raise Bug.Bug \u0026#34;run\u0026#34; 恐らくcontextが変数名とかを持っているのでしょう。 moduleに関してはTop.compileが最後にLLVMEmitをしてるのでLLVMのmodule(コンパイルされる最大単位)のことだと思います。だとするとここまではまだコードはメモリ上にあるはずです。\nmoduleを取り出した後どうしてるかというとオブジェクトファイルを作っているようです。ここでファイルに書き出されました。\n val objfile = TempFile.create (\u0026#34;.\u0026#34; ^ SMLSharp_Config.OBJEXT ()) val asmfile = TempFile.create (\u0026#34;.\u0026#34; ^ SMLSharp_Config.ASMEXT ()) val _ = #start Counter.llvmOutputTimeCounter() val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile, Filename.toString asmfile) val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile, Filename.toString objfile) val _ = #stop Counter.llvmOutputTimeCounter() val _ = LLVM.LLVMDisposeModule module 最後に呼んでるDisposeModuleはデストラクタですかね。ちゃんとお片付けしてます。\nさらに、ダイナミックリンクファイルを作るようです。\nval sofile = TempFile.create (SMLSharp_Config.DLLEXT ()) val ldflags = case SMLSharp_Config.HOST_OS_TYPE () of SMLSharp_Config.Unix =\u0026gt; nil | SMLSharp_Config.Cygwin =\u0026gt; [\u0026#34;-Wl,-out-implib,\u0026#34; ^ Filename.toString (Filename.replaceSuffix \u0026#34;lib\u0026#34; sofile)] | SMLSharp_Config.Mingw =\u0026gt; [\u0026#34;-Wl,--out-implib=\u0026#34; ^ Filename.toString (Filename.replaceSuffix \u0026#34;lib\u0026#34; sofile)] val libfiles = case SMLSharp_Config.HOST_OS_TYPE () of SMLSharp_Config.Unix =\u0026gt; nil | SMLSharp_Config.Cygwin =\u0026gt; map (fn x =\u0026gt; Filename.toString (Filename.replaceSuffix \u0026#34;lib\u0026#34; x)) (!loadedFiles) | SMLSharp_Config.Mingw =\u0026gt; map (fn x =\u0026gt; Filename.toString (Filename.replaceSuffix \u0026#34;lib\u0026#34; x)) (!loadedFiles) val _ = BinUtils.link {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS @ ldflags, libs = libfiles @ LIBS, objects = [objfile], dst = sofile, useCXX = false, quiet = not (!Control.printCommand)} この時、Windowsでは何かしらの制約があるのか過去にリンクしたダイナミックリンクファイル(libfiles)も今回作るダイナミックリンクファイルにリンクしているようです。\nさて、ダイナミックリンクファイルを作った後はdlopenを使ってダイナミックリンクします。\nval so = DynamicLink.dlopen\u0026#39; (Filename.toString sofile, DynamicLink.GLOBAL, DynamicLink.NOW) handle OS.SysErr (msg, _) =\u0026gt; raise DLError msg その後はエントリポイントを捜してインポート、\nval {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} = GenerateMain.moduleName (interfaceNameOpt, #version context) val smap = DynamicLink.dlsym\u0026#39; (so, stackMapSymbol) handle OS.SysErr (msg, _) =\u0026gt; raise DLError msg val base = DynamicLink.dlsym\u0026#39; (so, codeBeginSymbol) handle OS.SysErr (msg, _) =\u0026gt; raise DLError msg val _ = sml_register_stackmap (smap, base) val ptr = DynamicLink.dlsym (so, mainSymbol) handle OS.SysErr (msg, _) =\u0026gt; raise DLError msg そして実行します。\nval mainFn = ptr : _import __attribute__((fastcc,no_callback)) () -\u0026gt; () in loadedFiles := sofile :: !loadedFiles; mainFn () handle e =\u0026gt; raise UncaughtException e; SUCCESS newContext 結果を印字しているところが見当らないのですが吐かれたコードに印字部分も入っているんですかね。\nあとはinteractiveに返ってコンテキストを拡張したりバージョンをインクリメントしたりします。\nval context = Top.extendContext (context, newContext) val context = Top.incVersion context バージョンによってシンボル名を変えることで何度もsoファイルをロードしても大丈夫なようにしてるんですかね。\nということでREPLの実装は入力を一旦ダイナミックリンクとしてコンパイルしてからロードしているようでした。\nおまけ REPLの入力部分は次のようになっています。\nfun initInteractive () = let val lineCount = ref 1 val eof = ref false fun read (isFirst, _:int) = let val prompt = if isFirst then \u0026#34;# \u0026#34; else \u0026#34;\u0026gt; \u0026#34; val _ = TextIO.output (TextIO.stdOut, prompt) val _ = TextIO.flushOut TextIO.stdOut val line = TextIO.inputLine TextIO.stdIn val _ = lineCount := !lineCount + 1 in case line of NONE =\u0026gt; (eof := true; \u0026#34;\u0026#34;) | SOME s =\u0026gt; s end in {lineCount = lineCount, eof = eof, read = read} end 結構小さいので色々Hack出来ます。例えばhskさんのようにREPLを付けることも出来ます。\nこのパッチで外部コマンドを呼ぶのが少し嫌な人はさらにioctl(2)を使ってrawモードにするパッチを当てるかlibeditなんかを使ってリッチな入力を実現するかをすればいいでしょう。 個人利用なら(他人に配布しないなら)GPLv3のreadlineも使えるんですかね（ライセンスに詳しくない）。\nまとめ  REPLの実装にはダイナミックリンクを使う方法があるよ SML#のREPLはHack出来そうだよ ","categories":["ML","SML","SMLSharp","Advent Calendar","Advent Calendar 2015","言語実装","言語実装 Advent Calendar"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp","/categories/advent-calendar","/categories/advent-calendar-2015","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-advent-calendar"],"date":"2015-12-12","title":"SML#に学ぶコンパイラ言語におけるREPLの実装方法","url":"https://KeenS.github.io/blog/2015/12/12/sml_nimanabukonpairagengoniokerureplnojissouhouhou/"},
  {"body":"このエントリはML Advent Calendar 2015及び言語実装 Advent Calendar 201515日目の記事です。\nκeenです。先日流れてきたRustでJITコンパイラを作る話が面白かったのでSML#でもやってみます。\nJITコンパイラってなに？ JITはJust In Timeで、日本語にすると「間に合って」になります。誤読されかねませんが「臨時コンパイラ」と訳すのが適当なのでしょうか。\n普通のインタプリタがソースコードを直接評価するのに対してJITコンパイラはソースコードを内部で一旦ネイティブコードにコンパイルして実行します。\nよく、JITコンパイラ/JITコンパイルのことをJITと略して呼びます。\nどこで使うの？ 主に、インタプリタの高速化の目的で使われるようです。他にはコンパイラをインタプリタ化させる(REPLの実装とか)でも使えそうな気がしますが、詳しくは知りません。\nJITってどうやって作るの？ JIT でない コンパイラが吐いたコードは一旦ディスクからメモリに読まれ、メモリ上で実行されます。\nJITコンパイラが吐くコードは直接メモリに吐かれ、メモリ上で実行されます。なので細かい条件を無視すれば\n 吐かれる命令のための(特殊な)メモリ領域を用意する そこに実行したい命令列を書き込む 書き込んだ命令列を実行する  だけです。 3.の「書き込んだ命令を実行する」が若干ふわっとしてますが、多くの場合は命令の書かれたメモリを関数ポインタとして扱って、その関数を呼び出す形で実行されます。 一応直接プログラムカウンタをいじって書き込んだ命令列を実行させることも出来ます。\n一緒に作ってみよう 思ったより簡単そうですね。作ってみましょう。\n1. メモリ領域を準備する 先に「特殊な」と付言しましたのでそれについて説明しましょう。プロセス上のメモリは、OSによって保護されています。 特に、そのままではそのメモリ上の命令列を実行出来ません。その保護を外すためにmprotect(2)システムコールを使います。\nint mprotect(void *addr, size_t len, int prot); SML#を使えば簡単に使えるようになります。\nval mprotect = _import \u0026#34;mprotect\u0026#34;: (unit ptr, word, word) -\u0026gt; int SML#は2.0.0時点では32bitでしか動かないのでsize_tをwordとしてしまって大丈夫です。また、bit演算をやりたいのでprotは本来はintですがwordにしました。\nmprotect(2)はPOSIX(SUSv4)的には引数のaddrがシステムのページの境界上にあることを要求しても良いことになっています。 実際、OS Xが要求するらしいです。また、メモリ保護はページ単位で行われるため、lenもページサイズの倍数である必要があります。 protは保護フラグですね。\nメモリの確保、特にページの境界にアラインメントされたメモリ領域を確保するにはSML#では厳しそうなのでこれもCの関数に頼ります。 Linuxならいくつか方法はありますが、ポータブルにはposix_memalign(3)を使うのが良いようです。\nint posix_memalign(void **memptr, size_t alignment, size_t size); これもSML#から簡単に使えます。\nval posix_memalign = _import \u0026#34;posix_memalign\u0026#34;: (unit ptr ref, word, word) -\u0026gt; int ついでにメモリの解放も必要ですね。free(3)もインポートしましょう。\nval free = _import \u0026#34;free\u0026#34;: unit ptr -\u0026gt; () さて、メモリを確保するのにいくつかCのマクロで定義された定数を定義しましょう。今のところSML#にCのマクロを使う術はなさそうです。どうにかしてCプリプロセッサを使えれば良いのですが…。\nval PROT_READ = 0wx1 val PROT_WRITE = 0wx2 val PROT_EXEC = 0wx4 val PROT_NONE = 0wx0 val PAGE_SIZE = 0w4096 ページサイズは本当はsysconf(3)を使ってsysconf(PAGESIZE)として取るのが作法ですが面倒なので4KiB決め打ちにしてしまいました。\nさて、これらを用いてJIT用のメモリは次のように確保します。Pointerモジュールが必要なのでsmiファイルでrequire \u0026quot;ffi.smi\u0026quot;しましょう。\nval op orb = Word.orb infix 5 orb val size = 0wx1 val msize = size * PAGE_SIZE val pageRef: unit ptr ref = ref (Pointer.NULL ()) val ret = posix_memalign (pageRef, PAGE_SIZE, msize) val page = if ret = 0 then !pageRef else raise Fail \u0026#34;memory allocation failed\u0026#34; val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC val ret = mprotect (page, msize, PROT_RWEX) val () = if ret = 0 then () else raise Fail \u0026#34;memory protection error\u0026#34; これでpageに実行可能フラグが立ったメモリが確保出来ました。sizeは書き込みたい命令列に応じて変えます。\n2. 命令列を書き込む さて、ここらへんからアセンブラの世界になってきます。\nまず、安全のために件のメモリ領域をret命令で埋めます。 ret命令は関数から戻る時に使われる命令で、変なことをしてもretで元の場所に戻ればどうにかなる可能性があるのです。\nメモリを一気に埋めるにはmemset(3)が便利です。\nvoid *memset(void *s, int c, size_t n); これをSMLにインポートして使いましょう。ret命令に対応するマシン語は0xc3です。\nval memset = _import \u0026#34;memset\u0026#34;: (unit ptr, word, word) -\u0026gt; unit ptr val _ = memset (page, 0wxc3, msize) じゃあ、命令を書き込んでいきましょう。最初はただ1を返すだけの関数に相当する命令です。 64bitマシンを使っていても32bitでコンパイルしたSML#を使っている限りはx86(IA32)のアセンブラを使います。 x86は値をeaxレジスタに入れることで返り値とします。\nmov 1 eax ret このコードをオンラインアセンブラでアセンブルしてみると\n0: b8 01 00 00 00 mov eax,0x1 5: c3 ret との結果が返ってきました。これを真心込めて1つづつメモリに書き込んでいきます。 SML#からメモリに直接書き込むには内部APIっぽいものを触る必要があります。 タイプ数を減らすためにいくつかエイリアスを定義しておきましょう。\nval fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr val store = Pointer.store val advance = Pointer.advance メモリにword8の値を書き込むのにキャストが必要になるのでfromUnitPtrを使います。 さて、書き込んでいきます。\nval mem: word8 ptr = fromUnitPtr page val () = store page 0wxb8 val mem = advance mem val () = store page 0wx01 val mem = advance mem val () = store page 0wx00 val mem = advance mem val () = store mem 0wx00 val mem = advance mem val () = store mem 0wx00 val mem = advance mem val () = store mem 0wxc3 val _ = advance mem これでpageに1を返すだけの命令列が書き込まれした。\n3. 書き込んだ命令列を実行する 書き込んだ命令列は関数にキャストして使うことが多いと言いました。今回もそのようにします。\nそのために、また内部APIっぽいものを使います。\nval toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr codeptr型は関数ポインタを表すもののようです。DynamicLinkモジュールなどで使われています。\nさて、今回の1を返すだけの命令列は() -\u0026gt; int型になりますね。 それをインポート、実行しましょう。\nval freturn1 = toCodePtr page: _import () -\u0026gt; int val () = print ((Int.toString (freturn1 ())) ^ \u0026#34;\\n\u0026#34;) val _ = free page これで見事1が印字されたら成功です。\nさらに 先程のコードは繰り返しが多く、整理されていませんでした。もう少し整理しましょう。\nstructure Emit = struct val posix_memalign = _import \u0026#34;posix_memalign\u0026#34;: (unit ptr ref, word, word) -\u0026gt; int val mprotect = _import \u0026#34;mprotect\u0026#34;: (unit ptr, word, word) -\u0026gt; int val memset = _import \u0026#34;memset\u0026#34;: (unit ptr, word, word) -\u0026gt; unit ptr val free = _import \u0026#34;free\u0026#34;: unit ptr -\u0026gt; () val printf = _import \u0026#34;printf\u0026#34;: (string, unit ptr) -\u0026gt; () (* #define PROT_READ\t0x1\t/* Page can be read. */ #define PROT_WRITE\t0x2\t/* Page can be written. */ #define PROT_EXEC\t0x4\t/* Page can be executed. */ #define PROT_NONE\t0x0\t/* Page can not be accessed. */ *) val PROT_READ = 0wx1 val PROT_WRITE = 0wx2 val PROT_EXEC = 0wx4 val PROT_NONE = 0wx0 val PAGE_SIZE = 0w4096 type jitptr = word8 ptr val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr val toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr val store = Pointer.store val advance = Pointer.advance fun jitMemory size: jitptr = let val op orb = Word.orb infix 5 orb val msize = size * PAGE_SIZE val pageRef: unit ptr ref = ref (Pointer.NULL ()) val ret = posix_memalign (pageRef, PAGE_SIZE, msize) val page = if ret = 0 then !pageRef else raise Fail \u0026#34;memory allocation failed\u0026#34; val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC val ret = mprotect (page, msize, PROT_RWEX) val () = if ret = 0 then () else raise Fail \u0026#34;memory protection error\u0026#34; (* init with ret for safety *) val _ = memset (page, 0wxc3, msize) in fromUnitPtr page end fun freeJit (jitMem: jitptr) = free (SMLSharp_Builtin.Pointer.toUnitPtr jitMem) fun pushWord page (word: word8) = (store (page, word); advance (page, 1)) fun pushWords (page: jitptr) l = List.foldl (fn(w,page) =\u0026gt; pushWord page w) page l val import: jitptr -\u0026gt; codeptr = toCodeptr o toUnitPtr fun fromMachineCode l = let val len = Word.fromInt(List.length l) val size = (len + PAGE_SIZE) div PAGE_SIZE val page = jitMemory size val _ = pushWords page l in import page end end 次のように使います。一回importした関数はfreeしないことにしましょう。\nfun println x = print (x ^ \u0026#34;\\n\u0026#34;) val return1 = (* 0: b8 01 00 00 00 mov eax,0x1 *) [ 0wxb8, 0wx01, 0wx00, 0wx00, 0wx00 ] val freturn1 = Emit.fromMachineCode return1 :_import () -\u0026gt; int val () = println (Int.toString (freturn1 ())) 引数を取る もうアセンブラの話になります。\nx86では引数は右から順にスタックに積まれます。intを1つ取ってそれに1足して返す関数はこうなります。\nval add1 = (* 0: 8b 44 24 04 mov eax,DWORD PTR [esp+0x4] *) (* 4: 83 c0 01 add eax,0x1 *) [ 0wx8b, 0wx44, 0wx24, 0wx04, 0wx83, 0wxc0, 0wx01 ] val fadd1 = Emit.fromMachineCode add1 :_import (int) -\u0026gt; int val () = println (Int.toString (fadd1 3)) 正常に動けば4が印字されます。\nつらい話 バグ 最初、Pointer.storeでなく、SMLSharp_Builtin.Pointer.storeを使っていたら変なバグ踏みました。バグというか使い方が悪かった。\nデバッグ デバッガがないので非常につらいです。書き出された命令列を見るのに困りました。gdbで見たかったので、\nval printf = _import \u0026#34;printf\u0026#34;: (string, unit ptr) -\u0026gt; int val _ = pritnf (\u0026#34;page pointr: %p\u0026#34;, page) してprintfにブレークポイントを張り、そこで止めつつページのアドレスを取得、\n(gdb) x/20xh 0x81ca000 などとして見ていました。\nもっと JITコンパイラが楽しかったのでアセンブラのDSLを作ってみました。1、2個の命令吐けるだけですがちゃんと動きました。今のところこのように書けます。Intel記法だとしんどそうだったのでAT\u0026amp;T記法っぽく書けるようにしました。\nval freturn1\u0026#39; = Emit.fromInsts [ xorl eax eax, addl ($1) eax, ret ]:_import () -\u0026gt; int val () = println (Int.toString (freturn1\u0026#39; ())) x86は命令フォーマットが1バイトから15バイトまでの可変長で、内部表現をどのようにするか決めるだけでも一苦労でした。x86つらい。\nアドレッシングが複雑なのも悩みどころで、複数のアドレッシングを統一的に扱えるようにオーバーロードされた関数を用意したのですがあえなくSML#のバグを踏んで死亡しました。本当はこういう記法が出来る筈だった…\naddl (%eax) eax addl eax (%eax) addl eax (%(eax, ebx)) addl eax (%(eax, ebx, 4)) addl eax (%(4, eax))$ /usr/local/bin/smlsharp -c -o main.o main.sml uncaught exception: Bug.Bug: InferType: FIXME: user error: invalid instTy at src/compiler/typeinference2/main/InferTypes2.sml:47 Makefile:11: recipe for target \u0026#39;main.o\u0026#39; failed make: *** [main.o] Error 1 movlを実装しようとしたらアドレッシングが動かなかったので萎えてまだ実装してません。\nよく考えたら%ってミスリーディングだし名前変えよう。\nまとめ  JITを作るにはメモリ保護をいじれて関数ポインタのインポートが出来ればいいよ SML#でもJIT作れるよ アセンブラっぽいの作ったよ  今回のコードはこちらにあります。\n","categories":["ML","SML","SMLSharp","Advent Calendar","Advent Calendar 2015","言語実装","言語実装 Advent Calendar"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp","/categories/advent-calendar","/categories/advent-calendar-2015","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-advent-calendar"],"date":"2015-12-12","title":"SML#でJITコンパイラを作る軽い話","url":"https://KeenS.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi/"},
  {"body":"このエントリは言語実装Advent Calendar 2015 10日目の記事です\nκeenです。今日はある程度gcに頼らずメモリを管理する手法、リージョンについて話そうと思います。 リージョン推論とそのアルゴリズムまで話せればよかったのですがサーベイが間に合わず…\nスタックベースのメモリ管理 gcのない言語、例えばcでも自動で解放される類のメモリがあります。ローカル変数です。\nローカル変数のメモリ確保/解放戦略は単純です。ブロックの開始に確保され、ブロックの終わりに解放されます。\n{ int x; // \u0026lt;- xが確保される  { int y = 2; // \u0026lt;- yが確保される  { int z = 3; // \u0026lt;- zが確保される  x = y + z; } // \u0026lt;- zが解放される  } // \u0026lt;- yが解放される } // \u0026lt;- xが解放される  ブロックはネスト構造をとるのでメモリ管理はスタックがあれば十分で、概念としても実装としても非常にシンプルです。\nしかしシンプルな一方で柔軟性に欠ける部分もあります。 初心者の時に次のようなコードを書いてコンパイラに怒られた、あるいはバグらせたことは誰しもあるのではないでしょうか。\n{ int i; int *x; { int y[5] = {1, 2, 3, 4, 5}; x = y + 1; } // \u0026lt;- yに割り当てられたメモリはここで解放されるため、外のブロックにあるxで参照出来ない  for(i = 0; i \u0026lt; 4; ++i) { printf(\u0026#34;%i\\n\u0026#34;, x[i]); } } ちょっとわざとらしい例ですがこのようにブロック内で確保されたメモリが必ずブロックが終わった時に解放されるのは嬉しくないケースがあります。\nリージョン リージョンはブロックと基本的には同じ考え方です。リージョンの開始でメモリが準備され、リージョンの終わりでメモリが解放される。そしてリージョンは入れ子構造を作る。 リージョンとブロックの違いはリージョンには名前があることと、メモリを割り当てる時にどのリージョンに置くかを指定できることです。\nリージョンについて説明するためにml風の小さな言語で説明しましょう。この言語にgcはありません。\nlet x = [1, 2, 3] in let l = let y = append ([4, 5], x) in y end in len l end end スコープによるメモリ管理を考えてみましょう。yについて考えます。先程の考え方でいくと一番内側のスコープで作られたyはスコープの外まで生きていないのでlに渡すのは不正です。 これはつらいですね。代入を許さない言語だと値を返せなくなります。\n次に、リージョンを導入してみます。リージョンを作る構文として、letregionを導入します。\nリージョンr1, r2を導入するには\nletregion r1, r2 in ... end と書きます。そしてリージョンr1に[1, 2, 3]をアロケートするには\n[1, 2, 3] at r1 と書きます。また、関数fの返り値をリージョンr1にアロケートするには\nf[r1] args ... と書きます。今回端折り気味の説明なのでこの記法の詳細は後回しにします。\nリージョンとこの記法を導入した時に、先程の何がしたいのか分からないプログラムは次のように書けます。\nletregion r1, r2 in let x = [1, 2, 3] at r1 in letregion r3, r4 in let l = let letregion r5 in y = append[r3] (([4, 5] at r4, x) at r5) end in y end in len[r2] l end end end さて、このプログラムはちゃんと齟齬なく値を渡せていて、アロケートしたメモリも全て解放されています。 リージョンを導入することでこのような小さなプログラムならgc無しでもメモリ管理が出来るようになりました。 特に、このプログラムのメモリ管理は静的です。つまりメモリをアロケートする箇所と解放する箇所がコンパイル時に決定します。\nリージョンと関数 先程までは値の計算だけでした。今度は関数を定義してみましょう。 関数は返り値をどこかに返さないといけないので返り値の置き場となるリージョンを外から与える必要があります。 ということで関数はリージョンパラメータを取ります。先程の関数を返り値のリージョンを指定する構文は厳密には関数にリージョンを渡していた訳です。\n試しにappendを定義してみましょう。\nletlec append[r1] p = let (xs, ys) = p in case xs of nil =\u0026gt; ys | x::xs\u0026#39; =\u0026gt; (x::letregion r2 in (append[r1] ((xs\u0026#39;, ys) at r2)) end at r1) end end この関数appendはリージョンr1とタプルpを受け取って、r1にアロケートされた値を返します。\n(xs', ys)のようにappendの呼び出しのためだけに作られたタプルは短命なr2にアロケートしつつ、再帰呼び出しのappの返り値は 関数全体の返り値の一部になるのでr1にアロケートしています。\nこのように、リージョンさえなければ普通のmlと変わらないのにgcに頼らずメモリ管理が出来ています。\nリージョン推論 さてさて、先程リージョンなしのml言語にリージョンを導入することでメモリを静的に管理出来ました。しかしリージョンを手で指定していくのは中々つらいものがあります。ということでリージョンをコンパイラで勝手に推論してしまおうというのがリージョン推論です。\nリージョン推論を導入することで今までgcでメモリを管理していたのをある程度静的に管理することが出来ます。 リージョン推論のアルゴリズムは冒頭で述べたようにサーベイが間に合いませんでした。\nsml処理系のml kitはリージョン推論を導入することでgcをほとんど無くし、リアルタイム性に優れる処理系になりました。 先程から「ほとんど」といっているのは既存のプログラミング言語だとリージョンを綺麗に割り当てることが出来なくてほとんどのオブジェクトがトップレベルリージョンに推論されてしまい、あまり意味がなくなってしまうからだとか。丁度動的型付き言語に型推論を入れてもほとんどobject型になってしまうのと同じような話なんですかね。\n発展的話題 リージョンサイズ解析 今まで、リージョンによるメモリの確保/解放については話してきましたが確保するサイズについては触れてきませんでした。 簡単にはmalloc realloc free相当の機能を考えれば済むのですが、例えばコンパイル時点で最大確保サイズが分かっているのなら コールスタックに載せて確保/解放を高速化することが出来ます。\nそのコンパイル時に出来るだけリージョンの最大サイズを判明させようというのがリージョンサイズ解析です。\n線形/アフィン型 線形型は全てのリソースに対が必ず丁度1回消費されることを要求する型システムです。必ず消費されるのでメモリの解放が必ず行われることを型レベルで保障します。そして最大1回しか消費されないので他者が同じリソースを触って大惨事になるデータ競合を防ぐことが出来ます。 しかし推論は完全には出来ず、ユーザがちょくちょく整合性が取れていることの証明を書く必要があります。ATS2は線形型を持っており、厳密なリソース管理が出来ます。\nアフィン型は線形型よりは少し緩い型システムで、リソースが最大でも1回しか消費されないことを要求します。メモリなどの管理は出来ませんがデータ競合を防ぐことは出来ます。\nRustはアフィン型を導入してるらしいです。多分所有権回りの話なんでしょう。リージョンも導入してるらしいです。生存期間回りの話なんでしょう。\n余談ですがリージョンとアフィン型の関係を調べようとしたら画像の特定領域に台形変換を掛ける話しかヒットしませんでした。ググラビリティ低い…\nまとめ  リージョンについて話した リージョン推論のアルゴリズムについては話さなかった リージョン以外にもリソースを管理する方法はあるよ みんなRust使おう。  全然理解が追い付かないまま期限が来て半知半解で書いてるので詳しい方κeenまでツッコみお願いします。\n参考文献  A Brief Introduction to Regions 今回の記事はこの論文の内容をかい摘んで書いてある。 Implementation of the Typed Call-by-value lambda-calculus using a Stack of Regions (多分)リージョンの初出論文 A Region Inference Algorithm リージョン推論のアルゴリズム。70ページある… ML Kitの論文たち ここに色々論文ある。 ","categories":["Advent Calendar","Advent Calendar 2015","言語実装 Advent Calendar"],"category_urls":["/categories/advent-calendar","/categories/advent-calendar-2015","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85-advent-calendar"],"date":"2015-12-09","title":"リージョンについて","url":"https://KeenS.github.io/blog/2015/12/09/ri_jonnitsuite/"},
  {"body":"このエントリはML Advent Calendar6日目の記事です。\n次はdico_leque先生で、「ML中心にしつつ何か」です。\nκeenです。SMl#はDB接続及びSQLを言語レベルでサポートしていることが大きな特徴ですが詳細な方法についてはあまり情報がなく、 実際に利用するのは難しい状況にあります。そこで私がなんとかソースコードを読んで得られた知識を少し共有したいと思います。\n接続サーバ設定 DBへの接続サーバ設定には\n_sqlserver serverLocation : τ 式を使います。このserverLocationはDB毎に指定方法が異なります。公式のドキュメントにはデフォルトDBであるPostgreSQLへの接続方法しか書かれていませんが、いくつかのDBをサポートします。\nSML#はDB接続時にテーブルの型を要求します(上でいう型注釈のτがそれです。文法的に型注釈がないといけません。)。今回の例では公式ドキュメントにある通り\nCREATEDATABASEmydb;CREATETABLEPersons(nametextnotnull,ageintnotnull,salaryintnotnull);USEmydb;INSERTINTOPersonsVALUES(\u0026#39;Joe\u0026#39;,21,10000);INSERTINTOPersonsVALUES(\u0026#39;Sue\u0026#39;,31,20000);INSERTINTOPersonsVALUES(\u0026#39;Bob\u0026#39;,41,30000); で作ったDBへ接続することにします。\nテーブルの型 深追いしてないので分かりません。とりあえず今回使うmydbは{Persons:{name:string, age:int, salary :int}で接続出来るみたいです。これも追わねば…\n一応ソースを読む限りだとint, decimal, real32, float, real, string, bool, timestampがあるようです。NULLableなカラムにはoptionを使うようです。\nSMLで見慣れないdecimal, float, timestampはSML#が実装を持っているようです。\nfloat, decimalは内部表現は文字列で、文字列との相互及びrealとIEEERealへの変換が出来るようです。\ntimestampは文字列との相互変換及びnow()関数, defaultTimestampが存在します(スキーマにDEFAULT指定があった時用)。内部表現はunix timeなのか、intです。\nそれぞれSQL.Float, SQL.Decimal, SQL.TimeStampモジュールに入っています。\nPostgreSQL デフォルト設定のpgのmydbというDBへ接続したいならこれで接続出来ると公式ドキュメントに書いてあるのですが\nval myServer = _sqlserver (dbname=\u0026#34;mydb\u0026#34;) : {Persons:{name:string, age:int, salary :int} これだと最後の }が1つ抜けている上、それを補っても\n(interactive):2.27-2.32 Error: (name evaluation \u0026#34;190\u0026#34;) unbound variable: dbname と返してきます。正しくは(?)\nval myServer = _sqlserver (\u0026#34;dbname=mydb\u0026#34;) : {Persons:{name:string, age:int, salary :int}} です。他のパラメータ、例えばホストやポート、パスワードを渡したい場合はスペース区切で渡します。\nval myServer = _sqlserver (\u0026#34;dbname=mydb host=localhost password=hogehoge\u0026#34;) : {Persons:{name:string, age:int, salary :int}} この文字列はそのままPostgreSQLのPGconnectdbという関数に渡っているのでそのドキュメントに完全な受付可能なキーが書いてあります。\n host: DBサーバ名 hostaddr: DBサーバのIPアドレス user: DB接続時のユーザ名 password: userに対するパスワード dbname: DB名  とのことです。\nMySQL ドキュメントはありませんがソースコードを読んである程度勘を効かせた上で色々書いて試行錯誤すれば接続方法は分かります。\nMySQLに接続するには以下のようにSQL.mysqlを使います。\nval myServer = _sqlserver (SQL.mysql \u0026#34;dbname=mydb\u0026#34;) : {Persons:{name: string, age: int, salary: int}} 余談ですが_sqlserverはオーバーロードされていて、backend型とstring型両方を受け付けます。 文字列が来た時にはSQL.defaultに渡されます。そして val default = postgresqlです。つまり、PostgreSQLの例は_sqlserver (SQL.postgresql \u0026quot;dbname=mydb\u0026quot;) としているのと同じです。\n閑話休題。MySQLの時に渡せるパラメータの話をしましょう。こちらはバックエンドの接続関数にそのまま渡してる訳ではないのですが、 SML#側でパーサを持っているのでPostgreSQLの時のように書けます。\nSQL.mysql \u0026#34;dbname=mydb host=localhost\u0026#34; ここで使えるキーは\nval availableKeys = [\u0026#34;host\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;, \u0026#34;dbname\u0026#34;, \u0026#34;unix_socket\u0026#34;, \u0026#34;flags\u0026#34;] と定義されています1。因みにこれはパースエラーにならない文字列の集合であって、unix_socketを使おうとするとコネクションエラーになるようです(raise Connect \u0026quot;unix_socket is not supported\u0026quot;)。\n文法に関して深掘りすると、一応パーサ(src/sql/main/KeyValuePair.sml)を読む限りだと\n keyは [a-zA-Z0-9_](isAlphanum + #'_') valueはスペース以外の文字列(e.g. hogehoge)又は'で囲まれた文字列(e.g. 'hoge hoge') valueでは\\によるエスケープが可能(e.g. hoge\\ hoge, 'a \\'quote\\'')  \\については文字列の中なので\\自身のエスケープが必要なことに注意して下さい。\nunixODBC ご存知ない方に説明するとODBCはOpen Database Connectivityの略です。Microsoftが主導となって定めたDB接続のインターフェースです。また、そのインターフェースに従うドライバマネージャのことも指します。 一旦抽象化レイヤを挟むのでパフォーマンス面では生の接続に負けますが、豊富な接続先が魅力です。 MicroSoftのSQL ServerやMicroSoft Accessを始めとし、Oracle, MySQL, PostgreSQL, SQLite3, 果てはMongoDBなどにまで接続出来ます。 まあ、接続出来るからといって投げたクエリを正しく解釈、実行してくれるとは限りませんが…\nunixODBCはODBCのunix実装のようです。つまりODBCドライバを持つDBにunixから接続出来ます。\nさてさて、odbcに繋ぐには以下のようにします。2\nval myServer = (SQL.odbc \u0026#34;mydb username mypassword\u0026#34;) : {Persons:{name: string, age: int, salary: int}} なぜ記法変えたし…。しかも必ずスペースで区切るのでクォートも出来なければ空のユーザパスワードを渡すことも出来ません。もしかしたら\u0026quot;''\u0026quot;としたら後側で空の文字列と扱ってくれるかもしれませんが。 私がString.fieldsの挙動を勘違いしてました。スペースで区切って空にしておけば空パスワードを渡せます(e.g. \u0026quot;mydb username \u0026quot;)。あるいは空ユーザ名も(\u0026quot;mydb \u0026quot;)。\n私自身ODBCに詳しくないのですが、ODBCに接続するときはData Source Nameと呼ばれるものがシステムの特定の場所に存在するので他の接続情報は必要ないみたいです。\n接続 さっきまでは接続サーバの設定の話でした。今度は実際に接続する話です。DBMS固有の話はサーバ設定までなのでこれからは総のDBに共通です。\n接続するには公式のドキュメント通り\nval conn = SQL.connet myServer で繋げます。ここで各クライアントのダイナミックリンクライブラリがないとエラーになります。64dbit環境でSML#を32bitでビルドしている人はライブラリも32bitでビルドされていることを確認しましょう。\nクエリ これもドキュメント通りです。\nval myQuery = _sql db =\u0026gt; select #P.name as name, #P.age as age from #db.Persons as P where SQL.\u0026gt;(#P.salary, 10000) val rel = _sqleval myQuery conn val result = SQL.fetchAll rel; (* =\u0026gt; [{age=32, name=\u0026#34;Sue\u0026#34;}, {age=41, name=\u0026#34;Bob\u0026#34;}] *) val () = SQL.closeRel です。\n可能な文法については主に公式ドキュメントを参考にしましょう。\ninsert, update, deleteをサポートしている他、トランザクション(begin, commit, rollback)をサポートしているようです。詳しくはBNFを読んで下さい。\nSQLを投げて返ってきたリレーションに対しては結果を総取得するSQL.fetchAll、結果をoption型で1つ取得するSQL.fetch、結果を1つ取得するか例外になるSQL.fetchOneを使います。fetchOneの上げる例外はSQL.NotOneです。\nクエリ結果を使い終わったら必ずSQL.closeRelで開放しましょう。そしてコネクションも、終わったらSQL.closeConで開放しましょう。\nおわりに 本当は実際に試してから記事を書きたかったのですが、32bitの壁に阻まれて出来ませんでした。しかしソースを読んで裏を取って書いてあるのでまあまあ信憑性のある内容だと思います。 SML# からデータベースに接続したい方の一助になれば幸いです。\n https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184 [return] https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270 [return]  ","categories":["ML","SML","SMLSharp","Advent Calendar","Advent Calendar 2015","ML Advent Calendar"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp","/categories/advent-calendar","/categories/advent-calendar-2015","/categories/ml-advent-calendar"],"date":"2015-12-05","title":"SML#でDBに接続","url":"https://KeenS.github.io/blog/2015/12/05/sml_dedbnisetsuzoku/"},
  {"body":"この記事はRust Advent Calendar 2015 3日目の記事です。\n前 Rustで小さなツールを作ってみる(後編)\n次 szkttyさん インデックス構文によるアクセスを実装する\nκeenです。Rustを使うにはCargoを使う必要がありますが、cargo helpを見てもあまり情報が載っていないので少しばかり書きましょう。\nnew Create a new cargo package at \u0026lt;path\u0026gt; Usage: cargo new [options] \u0026lt;path\u0026gt; cargo new -h | --help Options: -h, --help Print this message --vcs VCS Initialize a new repository for the given version control system (git or hg) or do not initialize any version control at all (none) overriding a global configuration. --bin Use a binary instead of a library template --name NAME Set the resulting package name -v, --verbose Use verbose output -q, --quiet No output printed to stdout --color WHEN Coloring: auto, always, never これはみなさんよく使うのでほとんど説明不要でしょう。cargo newまたはcargo new --binの形でよく使います。 オプションを見て分かる通り、cargo new foo-rs --name fooのようにパスとcrateの名前を変えたりデフォルトのvcsにmercurialを使うことも出来ます。\nbuild Compile a local package and all of its dependencies Usage: cargo build [options] Options: -h, --help Print this message -p SPEC, --package SPEC Package to build -j N, --jobs N The number of jobs to run in parallel --lib Build only this package\u0026#39;s library --bin NAME Build only the specified binary --example NAME Build only the specified example --test NAME Build only the specified test target --bench NAME Build only the specified benchmark target --release Build artifacts in release mode, with optimizations --features FEATURES Space-separated list of features to also build --no-default-features Do not build the `default` feature --target TRIPLE Build for the target triple --manifest-path PATH Path to the manifest to compile -v, --verbose Use verbose output -q, --quiet No output printed to stdout --color WHEN Coloring: auto, always, never If the --package argument is given, then SPEC is a package id specification which indicates which package should be built. If it is not given, then the current package is built. For more information on SPEC and its format, see the `cargo help pkgid` command. Compilation can be configured via the use of profiles which are configured in the manifest. The default profile for this command is `dev`, but passing the --release flag will use the `release` profile instead. 恐らく一番よく使うタスクですね。ビルド対象を色々指定できるのはいいとして、実は-jオプションがあります。並行ビルド出来るやつですね。体感速度は変わりませんが。\nrun Run the main binary of the local package (src/main.rs) Usage: cargo run [options] [--] [\u0026lt;args\u0026gt;...] Options: -h, --help Print this message --bin NAME Name of the bin target to run --example NAME Name of the example target to run -j N, --jobs N The number of jobs to run in parallel --release Build artifacts in release mode, with optimizations --features FEATURES Space-separated list of features to also build --no-default-features Do not build the `default` feature --target TRIPLE Build for the target triple --manifest-path PATH Path to the manifest to execute -v, --verbose Use verbose output -q, --quiet No output printed to stdout --color WHEN Coloring: auto, always, never If neither `--bin` nor `--example` are given, then if the project only has one bin target it will be run. Otherwise `--bin` specifies the bin target to run, and `--example` specifies the example target to run. At most one of `--bin` or `--example` can be provided. All of the trailing arguments are passed to the binary to run. If you\u0026#39;re passing arguments to both Cargo and the binary, the ones after `--` go to the binary, the ones before go to Cargo. 実行可能ファイルのプロジェクトだった時に成果物を走らせます。あるいはexampleも走らせられます。とはいってもまだビルドしてなかったらビルドもするのでビルド向けのオプションがいっぱいありますね。\n実行可能ファイルが複数あるならcargo run --bin xxxで指定して走らせます。\n--releaseビルドした成果物を走らせたかったらcargo run --releaseしないといけません。\ncargo run -- argsで成果物に引数を渡せます。\ntest Execute all unit and integration tests of a local package Usage: cargo test [options] [--] [\u0026lt;args\u0026gt;...] Options: -h, --help Print this message --lib Test only this package\u0026#39;s library --bin NAME Test only the specified binary --example NAME Test only the specified example --test NAME Test only the specified integration test target --bench NAME Test only the specified benchmark target --no-run Compile, but don\u0026#39;t run tests -p SPEC, --package SPEC Package to run tests for -j N, --jobs N The number of jobs to run in parallel --release Build artifacts in release mode, with optimizations --features FEATURES Space-separated list of features to also build --no-default-features Do not build the `default` feature --target TRIPLE Build for the target triple --manifest-path PATH Path to the manifest to build tests for -v, --verbose Use verbose output -q, --quiet No output printed to stdout --color WHEN Coloring: auto, always, never --no-fail-fast Run all tests regardless of failure All of the trailing arguments are passed to the test binaries generated for filtering tests and generally providing options configuring how they run. For example, this will run all tests with the name `foo` in their name: cargo test foo If the --package argument is given, then SPEC is a package id specification which indicates which package should be tested. If it is not given, then the current package is tested. For more information on SPEC and its format, see the `cargo help pkgid` command. The --jobs argument affects the building of the test executable but does not affect how many jobs are used when running the tests. Compilation can be configured via the `test` profile in the manifest. テスト走らせるやつです。\ncargo testとだけすると全てのテストが走ります。地味にrustdocの中に書いたexampleも走ります。\nsearch Search packages in crates.io Usage: cargo search [options] \u0026lt;query\u0026gt; cargo search [-h | --help] Options: -h, --help Print this message --host HOST Host of a registry to search in -v, --verbose Use verbose output -q, --quiet No output printed to stdout --color WHEN Coloring: auto, always, never crates.ioからパッケージを捜してきてくれます。よく使いますね。インデックスのアップデートが地味に重い。\nfetch だんだんニッチなタスクを紹介していきます。\nFetch dependencies of a package from the network. Usage: cargo fetch [options] Options: -h, --help Print this message --manifest-path PATH Path to the manifest to fetch dependencies for -v, --verbose Use verbose output -q, --quiet No output printed to stdout --color WHEN Coloring: auto, always, never If a lockfile is available, this command will ensure that all of the git dependencies and/or registries dependencies are downloaded and locally available. The network is never touched after a `cargo fetch` unless the lockfile changes. If the lockfile is not available, then this is the equivalent of `cargo generate-lockfile`. A lockfile is generated and dependencies are also all updated. dependenciesを全てローカルに持ってくるタスクです。\ngenerate_lockfile Generate the lockfile for a project Usage: cargo generate-lockfile [options] Options: -h, --help Print this message --manifest-path PATH Path to the manifest to generate a lockfile for -v, --verbose Use verbose output -q, --quiet No output printed to stdout --color WHEN Coloring: auto, always, never Cargo.lockの生成をします。cargo updateがロックファイルがないと怒ってくるのでそういう時に使うのでしょう。\npackage Assemble the local package into a distributable tarball Usage: cargo package [options] Options: -h, --help Print this message -l, --list Print files included in a package without making one --no-verify Don\u0026#39;t verify the contents by building them --no-metadata Ignore warnings about a lack of human-usable metadata --manifest-path PATH Path to the manifest to compile -v, --verbose Use verbose output -q, --quiet No output printed to stdout --color WHEN Coloring: auto, always, never Cargoにはcrates.ioにデプロイする機能もあります。他にもpublish, login, yankも見ておきましょう。\ninstall Install a Rust binary Usage: cargo install [options] [\u0026lt;crate\u0026gt;] cargo install [options] --list Specifying what crate to install: --vers VERS Specify a version to install from crates.io --git URL Git URL to install the specified crate from --branch BRANCH Branch to use when installing from git --tag TAG Tag to use when installing from git --rev SHA Specific commit to use when installing from git --path PATH Filesystem path to local crate to install Build and install options: -h, --help Print this message -j N, --jobs N The number of jobs to run in parallel --features FEATURES Space-separated list of features to activate --no-default-features Do not build the `default` feature --debug Build in debug mode instead of release mode --bin NAME Only install the binary NAME --example EXAMPLE Install the example EXAMPLE instead of binaries --root DIR Directory to install packages into -v, --verbose Use verbose output -q, --quiet Less output printed to stdout --color WHEN Coloring: auto, always, never This command manages Cargo\u0026#39;s local set of install binary crates. Only packages which have [[bin]] targets can be installed, and all binaries are installed into the installation root\u0026#39;s `bin` folder. The installation root is determined, in order of precedence, by `--root`, `$CARGO_INSTALL_ROOT`, the `install.root` configuration key, and finally the home directory (which is either `$CARGO_HOME` if set or `$HOME/.cargo` by default). There are multiple sources from which a crate can be installed. The default location is crates.io but the `--git` and `--path` flags can change this source. If the source contains more than one package (such as crates.io or a git repository with multiple crates) the `\u0026lt;crate\u0026gt;` argument is required to indicate which crate should be installed. Crates from crates.io can optionally specify the version they wish to install via the `--vers` flags, and similarly packages from git repositories can optionally specify the branch, tag, or revision that should be installed. If a crate has multiple binaries, the `--bin` argument can selectively install only one of them, and if you\u0026#39;d rather install examples the `--example` argument can be used as well. The `--list` option will list all installed packages (and their versions). まだリリースチャネルには来てませんが、installも入る予定です。binプロジェクトをソースを持ってきてそのままビルド、インストールまでするやつです。勿論、ローカルのものもインストール出来ますよ。 rustfmtのようにREADMEのインストール方法にcargo installを書いているものもあります。これが使えるようになると配布がぐっと楽になりますね。\nプラグイン Cargoのサブコマンドを自分で作るのは簡単です。cargo fooというタスクを作りたいのならcargo-fooという名前の実行可能ファイルをパスに置いておくだけです。\n試してみましょう\n$ cat \u0026lt;\u0026lt;EOF \u0026gt; ~/bin/cargo-foo #!/bin/sh echo args are: \u0026#34;\\$@\u0026#34; echo \\\\\\$0 is: \\$0 EOF $ chmod +x ~/bin/cargo-foo $ cargo foo aa bb cc args are: foo aa bb cc $0 is: /home/kim/bin/cargo-foo $ cargo help foo aa bb cc args are: foo -h $0 is: /home/kim/bin/cargo-foo ちょっと独特な引数の渡り方をしてますね。しかし予め了解しておけば特に問題はなさそうです。1つサブコマンドを作ってみましょう。\n指定した名前のパッケージをCargo.tomlのdependenciesに書き足してくれるサブコマンドです。\n#!/bin/sh usage(){ cat \u0026lt;\u0026lt;EOF Add the dependency of crate to Cargo.toml Usage: cargo use \u0026lt;crate\u0026gt; [version] cargo use -h | --help Description: Add the dependency of crate to Cargo.toml. If vension is omitted, adopt the latest version. EOF } version(){ cargo search \u0026#34;$1\u0026#34; | grep -Eo \u0026#34;^$1\\(.*?\\)\u0026#34; | sed \u0026#34;s/^$1(\\(.*\\))/\\1/\u0026#34; } find_cargo(){ # TODO: look up parent directories ls | grep \u0026#39;^Cargo.toml$\u0026#39; } ensure_dep_exists(){ cargo=\u0026#34;$1\u0026#34; if ! grep -F \u0026#39;[dependencies]\u0026#39; \u0026#34;$cargo\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#39;[dependencies]\u0026#39; \u0026gt;\u0026gt; \u0026#34;$cargo\u0026#34; fi } insert_dep(){ cargo=\u0026#34;$1\u0026#34; crate=\u0026#34;$2\u0026#34; version=\u0026#34;$3\u0026#34; # FIXME: Because Linux and Mac behaves defferently on null string argument, don\u0026#39;t use it and adopt workaround. sed -i\u0026#39;\u0026#39; \u0026#34;/\\[dependencies\\]/{a\\ $crate= \\\u0026#34;$version\\\u0026#34; }\u0026#34; \u0026#34;$cargo\u0026#34; } run(){ CARGO_TOML=\u0026#34;$(find_cargo)\u0026#34; if [ $? != 0 ] then echo \u0026#34;Cargo.toml not found\u0026#34; 1\u0026gt;\u0026amp;2 exit 1 fi if [ -z \u0026#34;$1\u0026#34; ]; then usage exit 1 else CRATE=\u0026#34;$1\u0026#34; fi if [ -z \u0026#34;$2\u0026#34; ]; then VERSION=\u0026#34;$(version $1)\u0026#34; else VERSION=\u0026#34;$2\u0026#34; fi ensure_dep_exists \u0026#34;$CARGO_TOML\u0026#34; insert_dep \u0026#34;$CARGO_TOML\u0026#34; \u0026#34;$CRATE\u0026#34; \u0026#34;$VERSION\u0026#34; } main(){ # $1 is \u0026#34;use\u0026#34; when called as a cargo plugin if [ \u0026#34;$1\u0026#34; != use ]; then echo \u0026#34;Use this as a cargo plugin\u0026#34; usage exit 1 fi shift if [ \u0026#34;$1\u0026#34; = -h ] || [ \u0026#34;$1\u0026#34; = --help ]; then usage exit else run \u0026#34;$@\u0026#34; fi } main \u0026#34;$@\u0026#34; まだ洗練されていませんがお気に入りのタスクです。誰かCLIからCargo.tomlをいじれるツール作ってくれないかな。\n","categories":["Rust","CLI","小ネタ"],"category_urls":["/categories/rust","/categories/cli","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2015-11-29","title":"Cargoの使い方","url":"https://KeenS.github.io/blog/2015/11/29/cargonotsukaikata/"},
  {"body":"この記事はRust Advent Calendar 2015 2日目の記事です。\n前 Rustで小さなツールを作ってみる(前編)\n次 Cargoの使い方\nκeenです。昨日の記事で作りかけだったIRCの生ログのDBへのインポートの続きです。今日はDBへのインポートをやります。\nとはいってもRustでDBを扱った経験がないので探り探りです。\n要件 今回は簡単なのでORMは要らない気がしますが、サンプルということでORMも使いましょう。さらに、サンプルということでクエリビルダも使いましょう。\n…と思ったのですが中々良いライブラリがありませんでした。ドキュメントもろくにないまま放置されてるdeuteriumと開発途中でまだpostgresしかサポートされていないrustorm/codegentaくらいしかないようです。うぅ。 最近話題になったdieselもまだ若すぎるようです。\nということでシンプルなDBIを使います。そろそろ牡蠣の美味しい季節ですしSQL生書きしましょう。当たると怖いですが。で、テスト用にsqlite3を、（今回は使いませんが）本番用（？）にMySQLを使える奴を捜しましょう。\nライブラリ捜し まずはcrates.ioを捜します。\u0026rdquo;sqlite\u0026rdquo;で捜せばいいでしょうか。\nMySQLとSQLite3をサポートしているライブラリ…r2d2がそれのようです。 コネクションプールのライブラリなので何か違う気がしますが、mysqlもsqlite3も扱えて、結果コネクションを抽象化してくれるので大体大丈夫です。\n蛇足ですが、名前はJavaにc3p0というコネクションプールがあるのでそこから来ているのでしょう。\nスキーマ定義 SQLiteを使い慣れないのですが大したことやってないので大丈夫でしょう。DATETIME 型がないのが苦しいですね。\n自然キーが文字列や複合キーなのでサロゲートキーを使って自然キーにUNIQUE制約をかけてますがちょっと気持悪いですね。\n-- _*_ mode: sql; sql-product: \u0026#39;sqlite _*_ CREATETABLEservers(idINTEGERPRIMARYKEY,nameTEXTNOTNULLUNIQUE,addressTEXT);mCREATETABLEchannels(idINTEGERPRIMARYKEY,server_idINTEGERREFERENCESservers(id)ONUPDATECASCADE,nameTEXTNOTNULL,UNIQUE(server_id,name));CREATETABLEentries(idINTEGERPRIMARYKEY,channel_idINTEGERREFERENCESchannels(id)ONUPDATECASCADE,user_idINTEGERREFERENCESusers(i)ONUPDATECASCADE,typeTEXTNOTNULL,bodyTEXTNOTNULL,created_atTEXTNOTNULL);CREATETABLEusers(idINTEGERPRIMARYKEY,server_idINTEGERREFERENCESservers(id)ONUPDATECASCADE,nameTEXTNOTNULL,UNIQUE(server_id,name)); これをetc/schema.sqlに保存します。\nモデル定義 折角シンプルなツールを作っているのでモデルは使わない。\nコネクションまで あらかじめ\n$ sqlite test.db \u0026lt; etc/schema.sql としてDBを作っておきましょう。\nCargo.tomlのdependenciesには\nr2d2_sqlite = \u0026#34;0.0.3\u0026#34; r2d2 = \u0026#34;0.6.1\u0026#34; rusqlite = \u0026#34;0.4.0\u0026#34; を追記。\nsrc/main.rsの先頭部分に\nexterncrater2d2;externcrater2d2_sqlite;externcraterusqlite;usestd::sync::Arc;user2d2_sqlite::SqliteConnectionManager;userusqlite::SqliteError; を追記しましょう。\nそしてmainの中に次を追加。\nletmanager=SqliteConnectionManager::new(\u0026#34;test.db\u0026#34;).unwrap();letconfig=r2d2::Config::builder().pool_size(16).build();letpool=Arc::new(r2d2::Pool::new(config,manager).unwrap()); これで一旦コンパイル。\n$ cargo build これが通れば良いです。\nはじめての挿入 INSERTを発行してみましょう。on_channel_dirの引数を変える必要があります。\nfn on_channel_dir(path: \u0026amp;Path,pool: Arc\u0026lt;r2d2::Pool\u0026lt;SqliteConnectionManager\u0026gt;\u0026gt;) 併せて、呼び出しも\non_channel_dir(\u0026amp;path,pool.clone()); となります。\nそうしたらon_channel_dirの中で\nletchannel=\u0026amp;dirname[..at];letserver=\u0026amp;dirname[at+1..];println!(\u0026#34;{} at {}\u0026#34;,channel,server); としていた辺でまずはserversへのインサートを発行しましょう。\nletconn=pool.get().unwrap();letserver_id=matchconn.execute(\u0026#34;INSERT INTO servers (name) VALUES ($1)\u0026#34;,\u0026amp;[\u0026amp;server]){// unique constraint failed Err(SqliteError{code: 19,message:_})=\u0026gt;conn.query_row(\u0026#34;SELECT id FROM servers WHERE name = $1\u0026#34;,\u0026amp;[\u0026amp;server],|r|r.get(0)).unwrap(),Ok(_)=\u0026gt;conn.last_insert_rowid(),e=\u0026gt;{e.unwrap();return}}; プールからコネクションを持ってきてINSERTを発行します。成功するか既にUNIQUEな名前が存在していて失敗したらサーバのidを持ってきます。それ以外の失敗だったらそのままパニックしていいでしょう。\nしかしラッパがちょっと雑すぎやしませんかね。エラーステータスくらいenumでラップして欲しかった。\n同じくチャネルもインサートしましょう。\nletchannel_id=matchconn.execute(\u0026#34;INSERT INTO channels (name, server_id) VALUES ($1, $2)\u0026#34;,\u0026amp;[\u0026amp;channel,\u0026amp;server_id]){// unique constraint failed Err(SqliteError{code: 19,message:_})=\u0026gt;conn.query_row(\u0026#34;SELECT id FROM channels WHERE name = $1\u0026#34;,\u0026amp;[\u0026amp;channel],|r|r.get(0)).unwrap(),Ok(_)=\u0026gt;conn.last_insert_rowid(),e=\u0026gt;{e.unwrap();return}}; こういうupsertというかinsert or get_idってどうやるのが正解なんでしょう。DB力が低い…\nエントリのインサート 同じくon_logの引数を増やします。\nfn on_log(log: \u0026amp;Path,channel_id: i64,pool: Arc\u0026lt;r2d2::Pool\u0026lt;SqliteConnectionManager\u0026gt;\u0026gt;){ 呼び出し側も。\nletpool_=pool.clone();Builder::new().name(pathname).spawn(move||on_log(\u0026amp;log,channel_id,pool_)) moveする前にcloneしないとダメですね。所有権難しい。\nさて、今度は色々することがあります。 まず、dateとtimeをくっつけてdatetimeにしましょう。timeがイミュータブルだったので\nletmuttime=... とし、その下で\ntime.tm_mday=date.tm_mday;time.tm_mon=date.tm_mon;time.tm_year=date.tm_year;letcreated_at=time.to_timespec(); とします。わざわざto_timespecで変換してるのはTimespecだとDBライブラリが良い感じに変換してくれるからですね。\n次にメッセージの抜き出し部分も値を返すように変更。\nlet(user,type_,body)=match\u0026amp;msg[0..1]{\u0026#34;!\u0026#34;=\u0026gt;(\u0026#34;server\u0026#34;,\u0026#34;sysmsg\u0026#34;,\u0026amp;msg[1..]),\u0026#34;+\u0026#34;=\u0026gt;(\u0026#34;server\u0026#34;,\u0026#34;join\u0026#34;,\u0026amp;msg[1..]),\u0026#34;-\u0026#34;=\u0026gt;(\u0026#34;server\u0026#34;,\u0026#34;part\u0026#34;,\u0026amp;msg[1..]),\u0026#34;\u0026lt;\u0026#34;=\u0026gt;matchmsg.find(\u0026#39;\u0026gt;\u0026#39;).map(|e|(\u0026amp;msg[1..e],\u0026amp;msg[e+1..])){Some((user,body))=\u0026gt;(user,\u0026#34;msg\u0026#34;,body),None=\u0026gt;{warn!(\u0026#34;cannot parse the entry; skipping\u0026#34;);continue;}},_=\u0026gt;(\u0026#34;server\u0026#34;,\u0026#34;notice\u0026#34;,\u0026amp;msg[1..]),}; ここまで来たらあとはユーザとエントリをインサートするだけですね。\nletconn=pool.get().unwrap();letuser_id=matchconn.execute(\u0026#34;INSERT INTO users (name) VALUES ($1)\u0026#34;,\u0026amp;[\u0026amp;user]){// unique constraint failed Err(SqliteError{code: 19,message:_})=\u0026gt;conn.query_row(\u0026#34;SELECT id FROM users WHERE name = $1\u0026#34;,\u0026amp;[\u0026amp;user],|r|r.get(0)).unwrap(),Ok(_)=\u0026gt;conn.last_insert_rowid(),e=\u0026gt;{e.unwrap();return}};conn.execute(\u0026#34;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)\u0026#34;,\u0026amp;[\u0026amp;channel_id,\u0026amp;user_id,\u0026amp;type_,\u0026amp;body,\u0026amp;created_at]); 一旦これで走らせてみましょう。\n$ cargo run --release ... thread \u0026#39;/home/kim/log/#hongo@utmc/2015-02-15.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2015-08-18.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2014-12-13.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2015-10-13.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2014-02-26.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2014-05-23.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2015-04-30.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2013-10-18.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2015-10-14.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2014-01-19.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: \u0026#34;database is locked\u0026#34; }\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2014-08-12.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2014-06-03.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())\u0026#39;, ../src/libcore/result.rs:736 thread \u0026#39;/home/kim/log/#hongo@utmc/2015-02-05.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())\u0026#39;, ../src/libcore/result.rs:736 ... あちゃー。マルチスレッドでINSERTしてるのでロックが掛かってますね。SQLiteはファイルロックしか持たないので並列インサートはつらそう。\nトランザクション はい、そういう時のトランザクションですよ。\n最後のユーザやエントリーをインサートしてる部分で使ってみます。\nletconn=pool.get().unwrap();lettrx=conn.transaction().unwrap();letuser_id=matchconn.execute(\u0026#34;INSERT INTO users (name) VALUES ($1)\u0026#34;,\u0026amp;[\u0026amp;user]){// unique constraint failed Err(SqliteError{code: 19,message:_})=\u0026gt;conn.query_row(\u0026#34;SELECT id FROM users WHERE name = $1\u0026#34;,\u0026amp;[\u0026amp;user],|r|r.get(0)).unwrap(),Ok(_)=\u0026gt;conn.last_insert_rowid(),e=\u0026gt;{e.unwrap();return}};trx.commit();lettrx=conn.transaction().unwrap();conn.execute(\u0026#34;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)\u0026#34;,\u0026amp;[\u0026amp;channel_id,\u0026amp;user_id,\u0026amp;type_,\u0026amp;body,\u0026amp;created_at]);trx.commit(); 排他制御が目的なのでトランザクションを2回取ってます。\nこれだとどうなるかというと\n$cargorun--release...thread\u0026#39;/home/kim/log/#hongo@utmc/2015-02-15.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2015-08-18.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2014-12-13.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2015-10-13.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2014-02-26.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2014-05-23.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2015-04-30.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2013-10-18.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2015-10-14.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2014-01-19.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: SqliteError{code: 5,message: \u0026#34;database is locked\u0026#34;}\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2014-08-12.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: GetTimeout(())\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2014-06-03.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: GetTimeout(())\u0026#39;,../src/libcore/result.rs:736thread\u0026#39;/home/kim/log/#hongo@utmc/2015-02-05.txt\u0026#39;panickedat\u0026#39;called`Result::unwrap()`onan`Err`value: GetTimeout(())\u0026#39;,../src/libcore/result.rs:736... エラーは減ったもののまだ出ます。\nその他 他にスレッドプールを使って並列度を下げる、ワーカースレッドを使ってSQLiteへの書き込みを1スレッドにするなども試したのですが上手く行きませんでした。\nスレッドプールについては、今回エラーハンドリングのためにスレッドを立てている訳ですが、パニックを出してスレッドが死ぬとあまり思わしくない挙動をするのでダメでした。\nワーカースレッドは書き込んだ後にまたchannel_idなどを受け取らないといけないのでやめました。promiseなどを使えば上手くいきそうな気もしますが色々面倒そうなので止めておきます。\nコネクション 並列度を下げる方法はもう1つあります。\nmainの中で\nletconfig=r2d2::Config::builder().pool_size(16).build(); としていたのを覚えていますでしょうか。これはコネクションプールに16個のコネクションを持っています。この数を落とせばなんとかならないでしょうか。\n結論からいうとダメでした。今度は複数スレッドがコネクションを取り合ってタイムアウトが発生してしまいます。\n並列度を下げる 最後の最後、本当に並列度を下げる方法があります。スレッドを立てていた部分で\nletthreads=logs.map(|log|{letlog=log.unwrap().path();letpathname=log.to_string_lossy().to_string();Builder::new().name(pathname).spawn(move||on_log(\u0026amp;log))}).collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;();forthreadinthreads{let_=thread.unwrap().join();} としていました。これはファイル数分並列に実行してしまいます。ここを抑えましょう。\nforloginlogs{letlog=log.unwrap().path();letpathname=log.to_string_lossy().to_string();letpool_=pool.clone();let_=Builder::new().name(pathname).spawn(move||on_log(\u0026amp;log,channel_id,pool_)).unwrap().join();} spawnしてそのままjoinします。こうすれば並列度を抑えつつパニックをスレッドに分離出来ます。\nこれで実行するとどうなるかというと\n$ cargo run --release ... thread \u0026#39;/home/kim/log/#lisp-ja@freenode/2015-04-08.txt\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())\u0026#39;, ../src/libcore/result.rs:736 ... いくつかタイムアウトを出します。えー。並列度1でこれならもうどうしようもないでしょう。\nまとめ さて、小さなツールを作るというタイトルにしては後半(執筆が)重い内容になってしまいました。というか、sqlite3の問題もしますが。\nこのブログの内容としては\n rustでディレクトリを扱った ファイルを扱った 文字列を扱った 日付を扱った スレッドを扱った ロガーライブラリを扱った エラーハンドリングをした パニックのハンドリングをした DBを扱った sqlite3に並列書き込みはつらい  ボツ案も含めれば私個人はORMやスレッドプール、チャネルも扱いましたが関係ないですね。\nこういう簡単なツールでも思ったより色々な機能を触れるのでみなさん試してみてはいかがでしょうか。\nソースコード全体はここにおいておきます。\n因みに本筋とは外れますが、今回のSQLiteの問題を扱うには一旦CSVファイルに書き出してからCSVインポートでバルクインサートが考えられます。 CSVに書き出すのはちまちまやってもいいし今回のデータ量ならオンメモリ構築して一気に書き出しも出来るでしょう。あるいはSQLiteをやめてMySQLを使う。\n","categories":["Rust","Advent Calendar","Advent Calendar 2015","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2015","/categories/rust-advent-calendar"],"date":"2015-11-29","title":"Rustで小さなツールを作ってみる(後編)","url":"https://KeenS.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_/"},
  {"body":"この記事はRust Advent Calendar 2015 1日目の記事です。\n次 Rustで小さなツールを作ってみる(後編)\nκeenです。Rust Advent Calendar初日ということで軽い話から。 小さなツールって何だよって感じですが手元にIRCの生ログが大量にあるのでそれをDBにインポートしてみましょう。 あまりRustに向いた仕事じゃなさそうですが手始めとして。\n前編でログのパースを、後編でDBへのインポートをやります。\nIRCの生ログはtiarraが吐いたものです。\n#emacs@freenodeのようにチャネル名@サーバ名のディレクトリに入っていて、ファイル名はYYYY-mm-dd.txtで、\n13:43:24 \u0026lt;#emacs@freenode:codingquark\u0026gt; Such key generation, much wow. 13:43:59 ! Vejeta` (Ping timeout: 264 seconds) 13:44:30 + jcazevedo (jcazevedo!~jcazevedo@a94-132-141-99.cpe.netcabo.pt) to #emacs@freenode 13:45:30 + quazimodo (quazimodo!~quazimodo@155.143.14.28) to #emacs@freenode 13:45:32 ! Hugehead_ (Read error: Connection reset by peer) 13:48:48 + favadi (favadi!~textual@113.190.4.106) to #emacs@freenode 13:51:06 wizzo -\u0026gt; bitchimightbe 13:52:23 bitchimightbe -\u0026gt; wizzo 13:53:05 - frost3772 from #emacs@freenode (\u0026#34;\u0002ERC\u0002 (IRC client for Emacs 24.5.1)\u0026#34;) 13:56:37 ! chandan (Quit: WeeChat 1.2) 13:56:38 ! plunderous (Read error: Connection res のような形式で入ってます。先頭に\u0026lt;が付いてるのが発言、!がついてるのがなんかメッセージ(多分quitとかkillとか)、+がjoin、-がpart、無しがnickとかnoticeですかね。他にもログ取ってるircコマンドはあるのですが!に内包されてそうですね(tiarraのマニュアルに載ってそうですが見るの面倒)\n因みにログ全体は~/logに置いてあります。\n一応treeするとこんな感じ。\n. ├── #emacs@freenode │ ├── 2014-04-11.txt │ ├── 2014-04-12.txt │ ├── 2014-04-13.txt .. .. 2014-04-11から2015-11-01までの間ロギングしてます。\nディレクトリリスティングまで まずは\n$ cargo new irc_log --bin $ cd irc_log そしてsrc/main.rsを開いて\nusestd::fs;fn main(){letpaths=fs::read_dir(\u0026#34;/home/kim/log\u0026#34;).unwrap();forpathinpaths{letpath=path.unwrap().path();println!(\u0026#34;{}\u0026#34;,path.to_string_lossy().to_string());}} と書きましょう。path path煩いですね。OSの返す文字列(Cの文字列)とRustの文字列の違いだとか一旦Pathで抽象化してるだとかで文字列を抜き出すのは一苦労です。\nさて、\n$ cargo run でディレクトリ名が出てくればOK。\nファイル名リスティング mainを\nusestd::fs;fn main(){letpaths=fs::read_dir(\u0026#34;/home/kim/log\u0026#34;).unwrap();forpathinpaths{letpath=path.unwrap().path();on_channel_dir(\u0026amp;path);}} と置き換えてチャネルのディレクトリでの作業はon_channel_dirでやりましょう。\nチャネル名とサーバ名の抜き出し ディレクトリ名がチャネル名@サーバ名 の 形をしているので @の前後を抜き出せば良さそうです。\nsrc/main.rsの先頭に\nusestd::path::Path;usestd::str::from_utf8;usestd::os::unix::prelude::OsStrExt; を追記して、\nfn on_channel_dir(path: \u0026amp;Path){letdirname=from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();} でとりあえず/の付かないディレクトリ名を取れそうです。難しい。やはりOSの返す文字列の扱いは面倒ですね。 しかし一旦Rustの文字列になってしまえばこちらのもの。\nletat=matchdirname.find(\u0026#39;@\u0026#39;){Some(i)=\u0026gt;i,None=\u0026gt;return}; で@の位置を取得出来ます。@がなかったらreturnして無視しておきましょう（実際そういう名前のディレクトリがあるのですが今回の集計の対象外なので）。\nあとは部分文字列を取るだけ。\nletchannel=\u0026amp;dirname[..at];letserver=\u0026amp;dirname[at+1..];println!(\u0026#34;{} at {}\u0026#34;,channel,server); ファイルリスティング これは先程と同じですね。\nletlogs=fs::read_dir(path).unwrap();forloginlogs{letlog=log.unwrap().path();println!(\u0026#34;{}\u0026#34;,log.to_string_lossy().to_string());}; で、on_channel_dir全体はこうです。\nfn on_channel_dir(path: \u0026amp;Path){letdirname=from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();letat=matchdirname.find(\u0026#39;@\u0026#39;){Some(i)=\u0026gt;i,None=\u0026gt;return};letchannel=\u0026amp;dirname[..at];letserver=\u0026amp;dirname[at+1..];println!(\u0026#34;{} at {}\u0026#34;,channel,server);letlogs=fs::read_dir(path).unwrap();forloginlogs{letlog=log.unwrap().path();println!(\u0026#34;{}\u0026#34;,log.to_string_lossy().to_string());};} ファイルのパース 次にまたprintln!の部分をon_logとしてファイルをパースしていきましょう。\n日付の抜き出し 先程と似てますので飛ばし気味にいきます。\n簡単にやっても良いのですがお作法として日付ライブラリを使ってパースしましょう。 Cargo.tomlに以下を追記。\n[dependencies] time = \u0026#34;*\u0026#34; log = \u0026#34;0.3.3\u0026#34; env_logger = \u0026#34;0.3.2\u0026#34; 本当はバージョンも指定した方が良いのですが書き捨てのコードなのでまあ、良いでしょう。因みにtimeライブラリ自体扱いづらいとか色々問題があるのですがそれは後のAdvent Calendarに譲りましょう。しれっとloggerも導入します。printfデバッグにlogger便利!\ncargo update してdependenciesをインストールします。因みにlogがlogger facadでenv_loggerがloggerの実装です。使い方は後程。\nまたsrc/main.rsの先頭に\n#[macro_use]externcratelog;externcrateenv_logger;externcratetime; を追記。\nそしてon_logです。\nfn on_log(log: \u0026amp;Path){letdatestr=from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();letdate=time::strptime(\u0026amp;datestr,\u0026#34;%Y-%m-%d\u0026#34;).urwrap();} 今回は失敗しないことが分かってるので全部unwrapしてます。本当はtry!を使って上流に委ねた方がいいのですが今回は面倒なのでこうしちゃってます。正しいエラーハンドリングはtrplのError Handlingを読みましょう。\nファイルの読み出し 開く コードをいきなり載せると\nletfile=matchfs::File::open(log){Ok(f)=\u0026gt;f,Err(e)=\u0026gt;{error!(\u0026#34;could not open {}; skipping.\u0026#34;,log.display());return;}}; です。これはエラーハンドリングします。1つのファイルに失敗しても次があるので。ここで使ってるerror!がloggerのマクロです。\n行毎の読み出し 行毎の読み出しはバッファーリーダーが必要です。\nusestd::io::BufReader;usestd::io::BufRead; をsrc/main.rsの先頭部分に追記しましょう。因みにBufReadがトレイトで、BufReaderが実装です。実装が必要なのは良いとして、トレイトまで必要なのはトレイトで定義された関数を呼び出すのにトレイトのインポートが必要だからですね。\nさてさて、行の読み出しを進めます。先程オープンしたファイルをBufReaderで包んでやればOKです。\nletbr=BufReader::new(\u0026amp;file);forlineinbr.lines(){letline=matchline{Ok(l)=\u0026gt;l,Err(e)=\u0026gt;{warn!(\u0026#34;ignoring error {}\u0026#34;,e);continue;}};....} 行の読み出し結果もResultで返ってくるんですね。これも失敗したら読み飛ばせばいいのでurwrapせずに扱います。\n行のパース ガード 先頭部分の時間をパースする時に部分文字列を抜き出しますが、変な行だと10文字もなかったりするので一旦ガードを付けておきましょう。\nifline.len()\u0026lt;10{warn!(\u0026#34;ignoring line {}\u0026#34;,line);continue;} 時間のパース これはファイル名の時とほぼ同じ。\nlettime=matchtime::strptime(\u0026amp;line[0..8],\u0026#34;%H:%M:%S\u0026#34;){Ok(t)=\u0026gt;t,Err(e)=\u0026gt;{warn!(\u0026#34;Parse error {}; ignoring\u0026#34;,e);continue;}}; 今度は変な行が紛れてそうな（実際、ログファイルにはよくある）のでエラーは無視します。\nメッセージのパース 0-8文字目に時間があって、1スペース挟むので9文字目からがメッセージですね。そして先頭の文字で判断出来るのでした。\nletmsg=\u0026amp;line[9..];match\u0026amp;msg[0..1]{\u0026#34;!\u0026#34;=\u0026gt;println!(\u0026#34;sysmsg {}\u0026#34;,\u0026amp;msg[1..]),\u0026#34;+\u0026#34;=\u0026gt;println!(\u0026#34;join {}\u0026#34;,\u0026amp;msg[1..]),\u0026#34;-\u0026#34;=\u0026gt;println!(\u0026#34;part {}\u0026#34;,\u0026amp;msg[1..]),\u0026#34;\u0026lt;\u0026#34;=\u0026gt;matchmsg.find(\u0026#39;\u0026gt;\u0026#39;).map(|e|(\u0026amp;msg[1..e],\u0026amp;msg[e+1..])){Some((user,body))=\u0026gt;println!(\u0026#34;user: {} body: {}\u0026#34;,user,body),None=\u0026gt;()},_=\u0026gt;println!(\u0026#34;info {}\u0026#34;,\u0026amp;msg[1..]),} で判断出来そうです。パースした後の話は後回し。\nソース全体 ソースの断片が続いたので一旦ここまでの全体像を出します。\n#[macro_use]externcratelog;externcrateenv_logger;externcratetime;usestd::str::from_utf8;usestd::io::BufReader;usestd::io::BufRead;usestd::fs;usestd::path::Path;usestd::os::unix::prelude::OsStrExt;fn on_log(log: \u0026amp;Path){letdatestr=from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();letdate=time::strptime(\u0026amp;datestr,\u0026#34;%Y-%m-%d\u0026#34;);letfile=matchfs::File::open(log){Ok(f)=\u0026gt;f,Err(e)=\u0026gt;{error!(\u0026#34;could not open {}; skipping.\u0026#34;,log.display());return;}};letbr=BufReader::new(\u0026amp;file);forlineinbr.lines(){letline=matchline{Ok(l)=\u0026gt;l,Err(e)=\u0026gt;{warn!(\u0026#34;ignoring error {}\u0026#34;,e);continue;}};ifline.len()\u0026lt;10{warn!(\u0026#34;ignoring line {}\u0026#34;,line);continue;}lettime=matchtime::strptime(\u0026amp;line[0..8],\u0026#34;%H:%M:%S\u0026#34;){Ok(t)=\u0026gt;t,Err(e)=\u0026gt;{warn!(\u0026#34;Parse error {}; ignoring\u0026#34;,e);continue;}};letmsg=\u0026amp;line[9..];match\u0026amp;msg[0..1]{\u0026#34;!\u0026#34;=\u0026gt;println!(\u0026#34;sysmsg {}\u0026#34;,\u0026amp;msg[1..]),\u0026#34;+\u0026#34;=\u0026gt;println!(\u0026#34;join {}\u0026#34;,\u0026amp;msg[1..]),\u0026#34;-\u0026#34;=\u0026gt;println!(\u0026#34;part {}\u0026#34;,\u0026amp;msg[1..]),\u0026#34;\u0026lt;\u0026#34;=\u0026gt;matchmsg.find(\u0026#39;\u0026gt;\u0026#39;).map(|e|(\u0026amp;msg[1..e],\u0026amp;msg[e+1..])){Some((user,body))=\u0026gt;println!(\u0026#34;user: {} body: {}\u0026#34;,user,body),None=\u0026gt;()},_=\u0026gt;println!(\u0026#34;info {}\u0026#34;,\u0026amp;msg[1..]),}}}fn on_channel_dir(path: \u0026amp;Path){letdirname=from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();letat=matchdirname.find(\u0026#39;@\u0026#39;){Some(i)=\u0026gt;i,None=\u0026gt;return};letchannel=\u0026amp;dirname[..at];letserver=\u0026amp;dirname[at+1..];println!(\u0026#34;{} at {}\u0026#34;,channel,server);letlogs=fs::read_dir(path).unwrap();forloginlogs{on_log(\u0026amp;log.unwrap().path());};}fn main(){env_logger::init().unwrap();letpaths=fs::read_dir(\u0026#34;/home/kim/log\u0026#34;).unwrap();forpathinpaths{letpath=path.unwrap().path();on_channel_dir(\u0026amp;path);}} 実はmainの先頭でenv_logger::init().unwrap();でロガーの初期化してました。忘れてましたね。ごめんなさい。\nさて、これで一旦走らせてみましょう。動く筈です。\n$ cargo run 動いてるようですが、遅い。出力が多くてターミナル側がボトルネックのようです。\nパニックハンドルとチューニング 一旦メッセージを出力をやめて様子見してみましょう。\n\u0026#34;!\u0026#34;=\u0026gt;(),\u0026#34;+\u0026#34;=\u0026gt;(),\u0026#34;-\u0026#34;=\u0026gt;(),\u0026#34;\u0026lt;\u0026#34;=\u0026gt;(),_=\u0026gt;(), それでもまだ遅い上に謎のパニックが出てます。\nthread \u0026#39;/home/kim/log/#lisp@freenode\u0026#39; panicked at \u0026#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary\u0026#39;, ../src/libcore/str/mod.rs:1311 ログを見てみましょう。env_loggerは環境変数からログレベルを渡してあげるとログを出します。\n$ RUST_LOG=Trace cargo run ... WARN:irc_log: ignoring error stream did not contain valid UTF-8 WARN:irc_log: ignoring error stream did not contain valid UTF-8 WARN:irc_log: ignoring error stream did not contain valid UTF-8 WARN:irc_log: ignoring error stream did not contain valid UTF-8 WARN:irc_log: ignoring error stream did not contain valid UTF-8 WARN:irc_log: ignoring error stream did not contain valid UTF-8 WARN:irc_log: ignoring error stream did not contain valid UTF-8 ... 意外と変な行が一杯あるのですね。しかしこれらはちゃんとエラーハンドリングしてるので問題ありません。\n各所でunwrapしてるせいな気もしますが、urwrapのせいならそういうメッセージが出るので違います。\n実はこれ、非UTF-8のバイト列でrustの標準ライブラリが内部でパニックを出してます。 これの扱いも後のAdvent Calendarに譲るとして、ワークアラウンドを捜しましょう。rust1.4時点ではパニックをハンドルする手段はありません。\nパニックメッセージの先頭にthreadとついてるのでthreadで包めば良さそうです。\nThread まずはthreadをインポートします。\nusestd::thread::Builder; そしてon_channel_logを少し弄りましょう。無効なバイト列を含むファイルをざっくり切る感じで。\nforloginlogs{on_log(\u0026amp;log.unwrap().path());}; としていた部分を\nletthreads=logs.map(|log|{letlog=log.unwrap().path();letpathname=log.to_string_lossy().to_string();Builder::new().name(pathname).spawn(move||on_log(\u0026amp;log))}).collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;();forthreadinthreads{let_=thread.unwrap().join();} とします。一見複雑ですが、ファイル毎にスレッドを作って全部をvectorにして集めてそれぞれjoinを待ってるだけです。 そしてスレッド名を処理するファイル名にしたいのでスレッドビルダを使っています。\nさて、これで走らせてみましょう。\n$ time cargo run ... #lisp at freenode thread \u0026#39;/home/kim/log/#lisp@freenode/2014-08-18.txt\u0026#39; panicked at \u0026#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary\u0026#39;, ../src/libcore/str/mod.rs:1311 #emacs at freenode ... cargo run 327.21s user 8.71s system 630% cpu 53.289 total lispチャネルの1ファイルだけに変なバイト列があることが分かりました。\nそしてパフォーマンスですが、とりあえずtopで見る限りCPUは最大770%使ってくれてます（8コアマシン）。ファイル毎にスレッド作ってるので若干リソースの食い合いが発生してますがこれだけ並列度があればスレッドプールを使うまでもないでしょう。\nさらなるチューニング…？ しかしそれでもまだ遅いですね。ちょこっと書いては走らせるのサイクルを回すには耐えられません。\nそういえばログ全体のファイルサイズを確認してなかった。\n$ du -h ... 774M . 意外と小さい。まだチューニングの余地はありそうです。メモリアロケーションを減らしましょうか、それとも時間のパースを手書きでやりましょうか。\nいいえ。もっと簡単に速くする方法があります。--releaseをつけて実行すればOKです。\n$ cargo run --release ... ... cargo run --release 3.63s user 5.44s system 203% cpu 4.453 total (/ 53.289 4.453);=\u0026gt; 11.966988547046935 。12倍速くなりました。1ディレクトリ700以上のファイルがあってそれぞれにスレッドを作っているのでそろそろそのオーバーヘッドが効いてきてますね。\nスレッドプールを試してみたい気もしますがひとまずこれで置いておきましょう。\n次は後編、DBへのインポートです。\n蛇足ですが行のパースのところは正規表現でも出来ましたね。そっちの方が好きな方は試してみて下さい。\n","categories":["Rust","Advent Calendar","Advent Calendar 2015","Rust Advent Calendar"],"category_urls":["/categories/rust","/categories/advent-calendar","/categories/advent-calendar-2015","/categories/rust-advent-calendar"],"date":"2015-11-14","title":"Rustで小さなツールを作ってみる(前編)","url":"https://KeenS.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru/"},
  {"body":"Rustにtempfileというライブラリがある。その名の通りテンポラリファイルを作るライブラリだ。 必要に迫られてそのライブラリにPRを送ろうとして実装を読んだのだが普段あまり意識しなかったテンポラリファイルの作り方を知ったのでちょっと解説してみる。\nRustはほぼそのままの使い心地でCのライブラリを呼べるのでCが分かる人になら伝わると思う。\nライブラリの構成として、src/*.rsにOS非依存なコードやユーザ向けのAPIがあり、src/imp/{windows,unix}.rsにOS依存なコードがある。 私はWindowsの実装には興味ないし詳しくもないのでunix向けの実装だけを見る。\nimp以下を見る前にこのライブライが提供するAPIを解説しておくと、大きく分けてTempFileとNamedTempFileがある。無名、Namedどちらにもデフォルトの一時ファイルディレクトリ下に一時ファイルを作るAPIと指定したディレクトリ以下に作るAPIとがある。 TempFileが作るファイルは完全に匿名で、ファイルシステムに残らない。I/Oが出来るストリームだけを返す。定期的に/tmp以下を削除するジョブが走っていたとしても安全だし、他のプロセスに中身を読まれる危険性もない。 一方NamedTempFileの方は予測不可能なファイル名でファイルを作るものの、ファイルシステムに残るので安全ではない。しかしファイル名を要求する関数や外部プロセスと協調する時に使える。\nそれぞれで実装を見ていく。\nTempFile これはLinuxとその他で実装が分かれる。ユーザーAPI側でテンポラリファイルを作るディレクトリの指定は吸収しているのでこちらではただ指定されたディレクトリ下にテンポラリファイルを作ればいい。\nLinux #[cfg(target_os = \u0026#34;linux\u0026#34;)]pubfn create(dir: \u0026amp;Path)-\u0026gt; io::Result\u0026lt;File\u0026gt;{constO_TMPFILE: libc::c_int=0o20200000;matchunsafe{libc::open(try!(cstr(dir)).as_ptr(),O_CLOEXEC|O_EXCL|O_TMPFILE|O_RDWR,0o600)}{-1=\u0026gt;create_unix(dir),fd=\u0026gt;Ok(unsafe{FromRawFd::from_raw_fd(fd)}),}} Linux 3.11からO_TMPFILEが入ったので実装は直接的だ。O_TMPFILEはテンポラリファイル向けにファイルシステムに名前が登録されない匿名のファイルを作る。Lispのgensymに似ている。 O_EXCLでリンクによる別名での参照を回避し、Linux 2.6.23以後で入ったO_CLOEXECでexec(2)した時にfdを閉じるようにする。そうすれば関係のないプログラムからファイルが参照されるのを防げる。\nこのライブラリコールが成功すればそのままFileを返す。\nLinux 3.11未満やO_TMPFILEをサポートしないファイルシステムだったら失敗し、-1が返るのでLinuxに依存しない汎用のcreate_unixにフォールバックする。\nUnix Unix向けの実装は恐らくPOSIX互換なシステムなら全てで動く。\n#[cfg(not(target_os = \u0026#34;linux\u0026#34;))]pubfn create(dir: \u0026amp;Path)-\u0026gt; io::Result\u0026lt;File\u0026gt;{create_unix(dir)}fn create_unix(dir: \u0026amp;Path)-\u0026gt; io::Result\u0026lt;File\u0026gt;{for_in0..::NUM_RETRIES{lettmp_path=dir.join(\u0026amp;tmpname());returnmatchcreate_named(\u0026amp;tmp_path){Ok(file)=\u0026gt;{// I should probably tell the user this failed but the temporary file creation // didn\u0026#39;t really fail... let_=fs::remove_file(tmp_path);Ok(file)},Err(refe)ife.kind()==io::ErrorKind::AlreadyExists=\u0026gt;continue,Err(e)=\u0026gt;Err(e),}}Err(io::Error::new(io::ErrorKind::AlreadyExists,\u0026#34;too many temporary directories already exist\u0026#34;))} 汎用のcreate_unixでは完全に無名のテンポラリファイルを作るのを諦めて、一旦ランダム生成な名前のファイルを作って開き、成功したらそのファイルを削除する。 1つでも開いてるプロセスがある時に削除されるとUnixのファイルはそのプロセスからは見れるが他のプロセスからは見れない状態になるので色々便利に使われている。\ncreate_namedは後程見るとして、ランダム生成なファイル名だと稀に既に存在するファイル名と被る可能性があるので何度かリトライしている。 リトライ回数はsrc/lib.rsで定義されていて、\nconstNUM_RETRIES: u32 =1\u0026lt;\u0026lt;31; となっている。思ったよりえけつない回数リトライしている。もちろん、ファイル名が被った以外の理由でファイル生成が失敗したのならリトライに意味はないので大人しくreturnしている。\nで、create_namedだが\npubfn create_named(path: \u0026amp;Path)-\u0026gt; io::Result\u0026lt;File\u0026gt;{matchunsafe{libc::open(try!(cstr(\u0026amp;path)).as_ptr(),O_CLOEXEC|O_EXCL|O_RDWR|O_CREAT,0o600)}{-1=\u0026gt;Err(io::Error::last_os_error()),fd=\u0026gt;Ok(unsafe{FromRawFd::from_raw_fd(fd)}),}} となっている。単にcreateのフラグのO_TMPFILEがO_CREATになっただけ。\nNamedTempFile こちらはユーザーAPIの中から直接OS互換用コードを呼んでいる。src/named.rsに実装がある。\n/// Create a new temporary file in the specified directory. pubfn new_in\u0026lt;P: AsRef\u0026lt;Path\u0026gt;\u0026gt;(dir: P)-\u0026gt; io::Result\u0026lt;NamedTempFile\u0026gt;{for_in0..::NUM_RETRIES{letpath=dir.as_ref().join(\u0026amp;util::tmpname());returnmatchimp::create_named(\u0026amp;path){Ok(file)=\u0026gt;Ok(NamedTempFile(Some(NamedTempFileInner{path: path,file: file,}))),Err(refe)ife.kind()==io::ErrorKind::AlreadyExists=\u0026gt;continue,Err(e)=\u0026gt;Err(e),}}Err(io::Error::new(io::ErrorKind::AlreadyExists,\u0026#34;too many temporary directories already exist\u0026#34;))} 返り値をユーザAPI向けにラップしている以外は無名の一時ファイルと変わらない。余談だがここで使われているファイル名にユーザが干渉することが出来ず、完全にランダムなファイル名になっている。 ファイルの末尾(例えば拡張子)や先頭(例えばapp_nameなどの識別子)を挟めない。私が今作業してるパッチはその辺をもう少し自由にするものだ。\n閑話休題。似たような実装が2つもあるのは気になるので一応windows向けの実装も読んでみる。\nconstACCESS: DWORD=winapi::FILE_GENERIC_READ|winapi::FILE_GENERIC_WRITE;constSHARE_MODE: DWORD=winapi::FILE_SHARE_DELETE|winapi::FILE_SHARE_READ|winapi::FILE_SHARE_WRITE;constFLAGS: DWORD=winapi::FILE_ATTRIBUTE_HIDDEN|winapi::FILE_ATTRIBUTE_TEMPORARY;fn to_utf16(s: \u0026amp;Path)-\u0026gt; Vec\u0026lt;u16\u0026gt;{s.as_os_str().encode_wide().chain(Some(0).into_iter()).collect()}fn win_create(path: \u0026amp;Path,access: DWORD,share_mode: DWORD,disp: DWORD,flags: DWORD)-\u0026gt; io::Result\u0026lt;File\u0026gt;{letpath=to_utf16(path);lethandle=unsafe{CreateFileW(path.as_ptr(),access,share_mode,0as*mut_,disp,flags,ptr::null_mut())};ifhandle==winapi::INVALID_HANDLE_VALUE{Err(io::Error::last_os_error())}else{Ok(unsafe{File::from_raw_handle(handleasRawHandle)})}}pubfn create_named(path: \u0026amp;Path)-\u0026gt; io::Result\u0026lt;File\u0026gt;{win_create(path,ACCESS,SHARE_MODE,winapi::CREATE_NEW,FLAGS)}pubfn create(dir: \u0026amp;Path)-\u0026gt; io::Result\u0026lt;File\u0026gt;{for_in0..::NUM_RETRIES{returnmatchwin_create(\u0026amp;dir.join(\u0026amp;tmpname()),ACCESS,SHARE_MODE,winapi::CREATE_NEW,FLAGS|winapi::FILE_FLAG_DELETE_ON_CLOSE){Ok(f)=\u0026gt;Ok(f),Err(refe)ife.kind()==io::ErrorKind::AlreadyExists=\u0026gt;continue,Err(e)=\u0026gt;Err(e),};}Err(io::Error::new(io::ErrorKind::AlreadyExists,\u0026#34;too many temporary directories already exist\u0026#34;))} Windows向けの実装は必ずファイル名を指定する必要があり、リトライが必要そう？NamedTempFileを作るには(理論的に)どの実装でもリトライが必要だからユーザAPI側で纏めたのかな？\nまとめ  テンポラリファイルを作るならまずはO_TMPFILEを試す ダメならランダム生成なファイル名で成功するまでリトライ、成功したら即座にファイルを削除  作業中のコードをpushし忘れて土日に進捗出来なかったのでまたお茶を濁すはめになった。\n","categories":["Rust","Linux"],"category_urls":["/categories/rust","/categories/linux"],"date":"2015-11-08","title":"一時ファイルの作り方","url":"https://KeenS.github.io/blog/2015/11/08/ichijifairunotsukurikata/"},
  {"body":"# ClojureでDSPを作った話 ---------------------- Lisp Meet Up #3 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバーエージェントのエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # DSPとは -------- * Demand Side Platform * 広告主から広告を集めて広告の表示権を競り落し、適切な広告を出す 0. 広告主を集めて 1. 競りの通知を受け取って 2. 一番コスパが良さそうな広告を選んで 3. 入札して 4. 落札通知を受け取る 5. 落札したら広告を出す === # ひとりDSP ---------- * AdTech Studioの新卒研修 * 2ヶ月間、業務時間の20%を使ってDSPを作る + 実質8営業日 * 業務ロジックを理解することが目的 * 最後に新卒の作ったDSP同士で競争、利益が得点になる * 他には最終発表での得点も * **研修なので好きにやっていい** + Clojureで書くことに * サーバーの他は広告主データと学習用データが与えられる ===   日本におけるアドテク市場とサイバーエージェントのアドテク事業について  from CyberAgent, Inc.  === # 作るもの --------- * 競りの通知を受け取って入札するJSON REST API * 落札の通知を受け取るJSON REST API + 割とシンプル * 「一番コスパが良さそうな広告を選ぶ」部分は色々と工夫する * 今回は広告を出すところまではやらない * クリック情報は落札通知に入ってる === # b11dについて ------------- * 今回作ったDSP * [KeenS/b11d](https://github.com/KeenS/b11d) * Clojure製 * 5日くらいで作った * あまりゴテゴテしない方針 + 今回パフォーマンスは無視していい + Clojureに慣れてないので学習コストも抑えたい * NginXとAppとMySQL構成+α * DBは綺麗に設計したい * 1リクエスト毎にDBを引きにいく素敵仕様 === # WAP ----- * Compojure * Sinatra likeなやつ * ringの上に乗っかてる * かなりシンプルな部類だがJSON REST API程度ならこれで十分 * ringミドルウェアのでJSON部分も抽象化 * 学習コストが低いので気軽に始められる === # JSONライブラリ -------------- * ring.middleware.json/wrap-json-{body, response} + JSON-マップとマップ-JSON + bodyの方はキーがStringになるのが微妙 - セキュリティ的に仕方ない + Content-Typeを指定しないと動かない罠 * cheshire + 事前データをインポートするのに使った + ringのJSONミドルウェアの依存なのでそのまま使った + 自然で使い易いAPI === # データベース接続 ---------------- * java.jdbc * JDBCのClojure向けラッパ? * DataSourceを自分で渡すのでコネクションプールも簡単 * SQL手書きしたら良い感じにマップを返してくれる * Storeはカラムと値の対応を手書き * 便利マクロもいくつか === # データベース接続 ---------------- * eager loading面倒問題 + 入れ子オブジェクトを保存する方も面倒だった + ORMの便利さを実感。 * bulk insert難しい問題 + 実行時可変長引数難しい * ORMはXXXを使うかJavaのやつをそのまま使う? * JavaはXMLさえ我慢すれば割と良い奴揃ってる * しかしレスポンスはマップで欲しいかも === # 運用 ----- * warに固めてTomcat vs スタンドアロンなfat jar * 今回はfat jarを選択 * スタンドアロンだとsupervisordとかでの管理が楽 * Tomcatの運用経験がない * Jetty中々優秀らしい * jstatを使ってMackerelでメトリクス取った === # 非同期化 --------- * core.async/goで手軽に非同期 * DBへの書き込みを非同期にした * DB書き込みでエラーが出ても500にならない恐怖 * 最初の方で支払いを記録出来てなくて予算管理が死亡 + 予算管理失敗ペナルティで、大分点数引かれたらしい * goroutineでの例外処理どうやるんだろう。 === # 開発環境 --------- * nREPL + Emacs + CIDER * 補完の設定上手くいかなかった * 諸々地味に不便 * 起動遅い * Emacs側からnREPL立ち上げたい * サーバーのライブリロード欲しい * 正解が欲しい === # その他Clojureについて --------------------- * コンスのCarを取るのに`hd`か`head`か`car`か分かんなかった + 結局どれでもなくて`first`だった * 引数のパターンマッチが便利 + JSON REST APIだとリクエストに何を期待してるのか分かりづらい + パターンマッチがドキュメントになる * やっぱJavaのライブラリ使えるの便利 === # 落穂拾い --------- * デプロイにはシェルスクリプト + お家芸 * 「一番コスパが良さそうな広告を選んで入札」で統計か機械学習が必要 + 1回表示した時の収益の期待値を計算する * 今回は事前データの統計を使った + 理想的には機械学習。時間変化についていける * In Appでオンライン学習出来るライブラリが思ったよりない + 分散処理向けの大袈裟なのが多い + Weka? liblinear-java? * 後で考えたらIncanter使えばよかった === # まとめ ------- * 給料貰いながらLisp書いた * ClojureでDSP作った * Clojureで機械学習したかったけど間に合わなかった === # 参考 ------ * [Internal of b11d | κeenのHappy Hacκing Blog](//KeenS.github.io/slide/Internal_of_b11d/)   ","categories":["Clojure","Lisp","AdTech"],"category_urls":["/categories/clojure","/categories/lisp","/categories/adtech"],"date":"2015-10-27","title":"ClojureでDSPを作った話","url":"https://KeenS.github.io/slide/clojurededspwotsukuttahanashi/"},
  {"body":"寝れずに悶々としていたので書いてみる。REST APIを叩くときはデフォルトで結果を標準出力に吐くcURLがよく使われるがテストにはwgetが向いてるかもしれない。\n理由は簡単。exit statusだ。シェルのテストをする時はshunit2を使うことになるかと思うが、exit statusでテストをしたくなる。 cURLはHTTPサーバーがエラーステータスを返してもexit status 0で終了するのに対してwgetは所定の値を返す。\nEXIT STATUS Wget may return one of several error codes if it encounters problems. 0 No problems occurred. 1 Generic error code. 2 Parse error---for instance, when parsing command-line options, the .wgetrc or .netrc... 3 File I/O error. 4 Network failure. 5 SSL verification failure. 6 Username/password authentication failure. 7 Protocol errors. 8 Server issued an error response. 少し試してみよう。\n$ curl -sL google.com/teapot \u0026gt; /dev/null $ echo $? 0 $ wget -qO /dev/null google.com/teapot $ echo $? 8 ちゃんと違いが出ている。余談だが wget -O /dev/nullは便利なので覚えておくと幸せになれる。\nおまけ HTTPのエラーを全部1つのステータスに纏めるのはちょっと乱暴な気がする。wgetはHTTP以外のプロトコルにも対応してるのでまあ仕方がないのだろうが。 ということで任意のHTTPレスポンスを抜き出してみる。\n$ curl -sIL google.com/teapot | grep -E \u0026#39;^HTTP/[0-9](\\.[0-9])? [0-9]{3}\u0026#39; HTTP/1.1 301 Moved Permanently HTTP/1.1 418 I\u0026#39;m a Teapot 本当にstatusだけ抜き出したかったらこうだ。\n$ curl -sIL google.com/teapot | grep -E \u0026#39;^HTTP/[0-9](\\.[0-9])? [0-9]{3}\u0026#39; | grep -o -E \u0026#39;[0-9]{3}\u0026#39; 301 418 複数回HTTPリクエストを飛ばしているので複数statusが返ってくるのは諦めよう。最後のやつだけ欲しければ tail -n 1すればいい。\nHTTPの仕様を読まずに書いたのでバージョンのマッチの部分が冗長かもしれないがとりあえず動く。というかcURLを使った。\nまとめ cURL使おう。\n","categories":["CLI"],"category_urls":["/categories/cli"],"date":"2015-10-20","title":"REST APIのテストにはwgetが便利かもしれない","url":"https://KeenS.github.io/blog/2015/10/20/apinotesutonihawgetgabenrikamoshirenai/"},
  {"body":"# Internal of b11d ---------------------- サイバーエージェント新卒研修 ひとりDSP最終発表会 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + AMoAdのサーバーサイド（？）エンジニア + 趣味でLisp, ML, Shell Scriptあたりを書きます + 仕事でScalaとShell Scriptあたりを書きます === # 今回作ったもの ---------------- * b11d (ぶらっくんどごーるど) * Clojure (compojure + middleware)製 + + NginX + MySQL + Supervisord * 出来る限りシンプルになるように作った + 310行 * デプロイその他はシェルスクリプト * 監視はmackerel === # シンプルということ ------------------- * アプリケーションは状態を持たない * IO以外副作用を持たない * つまり、キャッシュを持たない + キャッシュはパフォーマンス上の意味しかない + 早過ぎる最適化は諸悪の根源 * スケールアウトが容易 * compojureのミドルウェアを上手く使った === # シンプルということ2 -------------------- * データベースはだいたい第4正規形（ﾀﾌﾞﾝ） + 全てのカラムは`NOT NULL` + 広告主の所だけ拡張性を持たせるために第1正規形に落とした + 1広告主に対して複数の広告が持てるようになる * 外部キー制約も全部付ける * データが綺麗なのでアプリケーション側でのやることが少ない * 分析する時にも活きる筈 === # デプロイ --------- * 全てシェルスクリプトでオペレーション出来る * 手作業を無くしてミスを無くす + 「あれ？設定書き換えたのに反映されてない」 → 「再起動忘れてた」とかを防ぐ * ☆秘伝☆のシェルテクニック満載！ * アプリケーションが1jarに収まるのでデプロイが楽。 === # 監視 ------ * mackerelで色々モニタリング * Linux, NginX, MySQL, JVM, レスポンスステータス * ほとんどMackerelに乗っかることで本質的でないことに労力を割かない + 本質 = 業務ロジックを理解すること * アプリケーションの死活監視にはsupervisord + 本当はsystemdでやりたかったけどUbuntuのバージョンが古かった === # 落穂拾い ---------- * DBへの書き込みは非同期。Clojureなら簡単に書ける + `(go ...)` で囲むだけ * だいたい1700qps。データが増えると多分もうちょい下がる。 + キャッシュすればデータに依存しない速度。もう少しパフォーマンスも出る。 * アプリケーションサーバには組込みjettyを使った。 + War + Tomcatでも出来るがデプロイ/運用が楽なのでこちらを採用 * コア数に対してスケールするのでスケールアップも出来る * CTR予測は訓練データを 広告主xサイトxUA で統計を取って使う + 途中からシグモイド関数で変化をつける === # 改善点とか今後とか --------- * win rate, 入札/落札価格, CTRとかをmackerelでモニタリングしたかった * 管理画面的なの必要？ * フォールトトラレンス性はないのでその辺 + MySQLが死ぬとヤバい。 * ホットデプロイしたかった * 折角JVMだし機械学習したかった * Unix Domain Socket使うの忘れてた * データベースにタイムスタンプ入れるの忘れてた………orz   ","categories":["社内","AdTech","Lisp","Clojure"],"category_urls":["/categories/%e7%a4%be%e5%86%85","/categories/adtech","/categories/lisp","/categories/clojure"],"date":"2015-10-19","title":"Internal of b11d","url":"https://KeenS.github.io/slide/internal_of_b11d/"},
  {"body":"κeenです。この間長年使ってたDynabookからThink Padに乗り換えました。引っ越しの時に困ったのでメモ。\n元々あるのが\n Dynabook 外付けハードディスクカバー  新たに購入したのが\n Think Pad (HDDモデル) SSD  SSDだけ先に手元に来たのでまずSSDへ引っ越しを済ませ、Think Padが届いたらHDDとSSDを交換することに。\nDynabookのHDDからSSDへの引っ越し Ubuntuをインストールしてバックアップから復元しても良かったのですがHDDもSSDも512GBだったのでddを使って引っ越ししました。\n事前に出来る限りプロセスは殺す。本来は別ディスクから立ち上げたOSでやるのが良いんだろうけど面倒だったので引越し対象のOSから実行しました。。コマンドはすごいシンプル。\n$ dd if=/dev/sda of=/dev/sdb bs=512k 外付けハードディスクカバーとDynabookがUSB2.0までにしか対応してないからか20MB/sしか出ず、一晩掛かりました。しかし終わったあとDynabookのHDDとSSDを交換して起動してみると何の問題もなく起動しました。素晴しい。\nSSDをThink Padに移植 一瞬ハードディスクの外し方が分からず苦戦するもネットで調べると分解マニュアルが出てきたので楽に換装。しかしThink Padの電源を入れても起動しなかった。\nBIOSとUEFI BIOS BIOSといえばコンビュータの電源をポチっと入れた瞬間に起動するソフトウェアで、Basic I/O Systemの略かと思っていましたがBasic I/O Systemの実装の1つの名前でもあるらしいです。\nBIOSはディスクの先頭にあるMaster Boot Recordを読みにいきます。そこからパーティションテーブルの情報を得てgrubなどを起動します。（Master Boot RecordのことをMBRと略すこともあるしMaster Boot Recordを使うパーティションテーブルのことをMBRと呼ぶこともある…？）。昔、GPTを使うと起動しなかった経験があるので私のDynabookのBasic I/O SystemにはBIOSが使われていた模様。\nUEFI UEFIはBIOSに代わるBasic I/O Systemらしいです。MBRの他、GPTもサポートします。GPTは MBR を使わず 、EFI System Partitionなるものを使うらしいです。Think PadのBasic I/O Systemはこれだったようです。\n原因、対策、今後 ということでUEFIがGPTを期待していたのにこちらはBIOS向けのMBRを用意していたのでダメだった模様。(いわゆる従来)BIOS画面(と呼ばれていたもの)に入って起動タイプをUEFIからLegacyにすることで起動出来ました。\n@blackenedgold 可能ですよ。WindowsでもLinuxでもBSDでも、です。\n\u0026mdash; orumin (@kotatsu_mi) 2015, 9月 26 @blackenedgold gptgenなどを用いてパーティションをMBRからGPTに変換すること、FAT32のパーティションを作り(先頭パーティションであることが好ましい)パーティションタイプを0xEF00にすること、そしてブートローダーをそのパーティションにインストールする\n\u0026mdash; orumin (@kotatsu_mi) 2015, 9月 26 @blackenedgold 以上があらましになります。FAT32のこのパーティションはEFI System Partition, ESPと呼ばれ、従来ファイルシステムから不可視な先頭セクタにインストールされていたブートローダーはただの実行ファイルとしてESPに置かれます\n\u0026mdash; orumin (@kotatsu_mi) 2015, 9月 26 @blackenedgold ブートローダーをESPに入れる手段としては、ArchWikiのUEFIの項をご覧ください。また、この時efibootmgrコマンドを用いてブートローダーのパスをUEFIに記録させておくと、UEFIのブートデバイス選択画面にブートローダーが出現します。\n\u0026mdash; orumin (@kotatsu_mi) 2015, 9月 26 @blackenedgold GRUBの場合efibootmgrコマンドを使うべき操作は自動でしてくれます。\n\u0026mdash; orumin (@kotatsu_mi) 2015, 9月 26 \nとのことですがまあ、SSDの先頭のスペース空いてないしちょっとミスったら即死だしどうしましょうね。 一旦SSDの中身を元のHDDに退避してSSDにUEFIで起動するパーティション作ってそのパーティションに元のパーティションをddでコピーとかで出来ますかね…\nサルでも分かる操作マニュアルが欲しい。\n","categories":["CLI","BIOS","UEFI"],"category_urls":["/categories/cli","/categories/bios","/categories/uefi"],"date":"2015-10-05","title":"ddでPCの引っ越しをしたら起動しなかった","url":"https://KeenS.github.io/blog/2015/10/05/dd_depcnohikkoshiwoshitarakidoushinakatta/"},
  {"body":"κeenです。 isucon に@nitro_idiot(深町さん)と@Rudolph_MillerのCommon Lispチームで出てきました。チーム名clfreaks。勿論Common Lispで再実装しました。\n因みに深町さんは今回使ったWebサーバーのwooを含めCommon Lispのライブラリを多数公開している世界一のCommon Lisper、ルドルフさんは元Common Lispの会社のCTO。\n前日 κeen 「あとはwooがunixソケット使えたら嬉しいんですがまあ、いいでしょう。」\nfukamachi 「今からやれば明日には間に合うな」\nfukamachi 「ローカルでは一応動いた。間に合いそうである」\nfukamachi 「5倍ちょっとくらい速いかな」\nこの間1時間半足らず。\nκeen 「練習してて気付いたんですけどデプロイツールってどうしましょう。」\nfukamachi 「κeenさんが使い慣れてるツールで良いです」\nκeen 「シェルスクリプトかー。」\nfukamachi 「やめろ」\n結局capistranoを使うことに。\n当日の作業 私がマシン立ち上げてソースをgitに上げるまでやる。残りの二人はソースを読む、私はNginXやMySQLやCapistranの基本設定をする。\n午前中 Common Lispでの再実装 ルドルフさんが見付けた遅い部分を書き出し、深町さんがCommon Lispの実装を進める。\n私がmysqlの設定をするもなぜか反映されずに詰まる。ルドルフさんと一緒にやるも数時間やっても解決せず。結局新しいインスタンスを立ち上げたら動いた。my.cnfにsym linkを貼ったのが問題だったよう。/etc/my.cnfの問題ではない。\n午後 実装を進めつつチューニング 私の方がどうにかなったのでルドルフさんも実装をすすめる。私はインデックスを張ろうとしてalterが帰ってこなくて諦めたりどうせ使わないけどunicornのワーカー数を増やして気分だけでもスコアを上げたりN+1クエリをJOINで書き直したり。\nComon Lispの実装がとりあえず終了 バグは残ってる、と言われつつCL実装をmasterにマージしたのがgitのログを見るに15:28。そこからデバッグ。色々ハマったりライブラリにバグがあったり（深町さんのライブラリだったのでその場でbug fix）してログイン処理が通ったのが17時くらい？そこからベンチマークを走らせるとまたtypoとかのバグがあってちまちま直していくも結局間に合わず0点のままFINISH。\n反省とか 思ったよりアプリケーションが重厚で再実装に時間取られすぎたなー、が一番。あとMysqlの設定でハマったのは本当にやりたくなかった。\nベンチマーク走らせるとデータが溜まることに気付かずに大分走らせた後でインデックスを張ろうとしたら20分くらい待っても帰ってこなかったのでインデックスを諦めた。なのでruby実装のスコアも800点くらい。 やろうとしたことはN+1クエリを消すとかuserをメモリに載せるとか。\nかなり苦い思いはしたけどCommon Lispに足りないものとか今後の課題とかも見えたし出た価値はあったと思う。例えばデプロイの度にコンパイルが走るが、コンパイルの重いライブラリを使ってるとデプロイが遅くなるので並列ビルド欲しいよね、とか。ただ、大きな目的だったWeサーバーのチューニングまではいけなかった。\n今年は知り合いと出ちゃったので来年は知らない人とチームを組もうかと。\n運営、出題の方々、お疲れ様でした。来年こそは本戦出ます。\n","categories":["ISUCON","ISUCON5"],"category_urls":["/categories/isucon","/categories/isucon5"],"date":"2015-09-27","title":"isucon にCommon Lispチームで出た","url":"https://KeenS.github.io/blog/2015/09/27/isucon_nicommon_lispchi_mudedeta/"},
  {"body":"シルバーウィークの進捗が芳しくなかったので雑な記事書いてお茶を濁しとく。rustをそれなりに（といっても1000行くらい）書いて溜まった知見をとりあえず出す。rust1.3時点。\n最初の方で熱く語ってるが多くの人にとって欲しい情報は下の方にあると思う。\nどんな言語 公式から持ってくるとこんな感じ。\n zero-cost abstractions  C++くらいの性能と思えばいい。  move semantics  他にはない難しい概念。しかしこれのおかげで様々な機能を教授出来る。  guaranteed memory safety  move semanticsにより安全でない操作はコンパイル時に弾ける。  threads without data races  move semanticsその他により安全でない操作は(ry  trait-based generics  継承ベースとは違って開いている。型を定義した後に機能を追加出来る。  pattern matching  便利だよねー。  type inference  (超)重量級言語ながらタイプ数は少なめ。  minimal runtime  move semanticsのお陰でGCがないので本当に小さい。hello, worldが277KBだった。  efficient C bindings  ABI的に良い感じなのでブリッジングコストがほぼない。   さて、ここでは足りないことを書いておくと、現在Mozillaで開発されている言語で、LLVMバックエンドのネイティブコンパイル言語。LLVMにトラウマがある人もバイナリ配布されているので気軽に使える。 rustを使った大きなプロジェクトはレンダリングエンジンのServoがある。\nレンダリングエンジンに使われているだけあって対応OS/アーキテクチャは広く、iOSやAndroidでも動く。C FFIもC APIもある。\nコミュニティは非常に活発で、インフラやライブラリは一通り揃った感じはする。マイナー言語を見てきた身としては1000ライラリくらい集まると一通りのことは出来るようになるかな、と思っているがrustは若い言語ながら3000ある。増えるペースも速いので欲しいものはまずあると思っていい。\n長らくAPIの破壊的変更をガンガンやる時期があって、1ヶ月前のhello worldが動かないとかもザラだったが2015年5月に1.0が出て以来見違えたように大人しくなって人が増え始めている。APIについてはunstable, stableだとかのラベルを付けるようになったので安心して使える。\n開発フローについてはFirefoxと同じく6週間毎に上流から新しいバージョンが降ってくる。ので今はもう1.3が出ている。1.0から1.3はコンパイル/実行時のパフォーマンス改善が主。新しい機能はPythonのPEPみたいにRFCで管理している。\n所有権や生存期間など新しい概念を導入していてとっつきにくいがこれらの概念のお陰で並列化しても安全だし、何よりメモリ管理を静的に解決出来るのでGCがなくてパフォーマンスが出るわ安定するわStop the Worldがないわで非常に良い言語。個人的にはデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。\n何指向言語かと言われると難しい。安全指向？継承はないがオブジェクト指向といえばそうだし函数型っぽくなくもない。並行を意識して作ってあるから並行指向と言えなくもない。継承を止めたC++のような所有権と副作用を入れたHaskellのような言語。副作用はバリバリ使うのであまり函数型言語として見ない方が幸せになれると思っている。\ntraitがどんなものかというとHaskellの型クラスに（多分）同じ。しかもHaskellのderiving Showみたいに#[derive(Debug)]とかも書ける。便利。\n生存期間と所有権がどういうものかというと、\nletfoo=Foo::new(1);println!(\u0026#34;{:?}\u0026#34;,foo);letfoo=Foo::new(2);println!(\u0026#34;{:?}\u0026#34;,foo); でfooをFoo::new(2)にバインドした時、Foo::new(1)は所有者が居なくなるのでその時点で開放される。GCと違う点は、GCはその時点ではゴミになるだけで、次にGCが走った時にようやく開放されるが、rustはその場で開放される、freeを自動で挟む。そうなると、コンパイラは最適化で同じサイズをfreeしてまたアロケートするのを同じ領域を使うようにする筈だ。これで領域の節約とかアロケーションコストの節約の他に、「今使った」メモリを再利用出来るのでキャッシュに載ったままメモリを使える。ここまでの効率化を「自動で」やってくれるのはrustだけではないかと思っている。\nこのように素晴しい言語機能があってコミュニティも活発で安定した言語なので流行ればいいなと思っている。とはいっても気軽に書ける言語ではないのであらゆる所で使われる言語とは思っていない。先に言ったようにデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。goがnext Cならrustはnext C++かな、と。\nrustは難しい。学習曲線が急峻だ。しかし手を動かしてその急峻な崖を乗り越えるだけの価値はある言語だと思うので是非試してみて欲しい。\nさて、情報セクションだ。\nドキュメント 入門 trplと略されるThe Rust Programming Languageを読むととりあえず基本的な概念を一通り学習出来る。\n書き始めた 文法とかをサクっと確認したいならThe Rust Referenceがある。\n標準ライブラリを調べたいならAPIドキュメントがある。一見分かりづらいが一番上に検索窓があるので全体検索が出来る。\nコード例が欲しいならRust by Exampleがある。\n軽く試す Rust Playgroundを使えばWeb上で試せる。質問とか投げる時にサンプルコードをここに載せて渡すと捗る。\n開発環境 コンパイラ 公式から簡単にバイナリ落としてこれる。Macだとbrewでも入った気がする。FreeBSDだとpkgで入る。Debianのパッケージも出来たらしい(9\u0026frasl;23)がUbuntuにはまだ(9\u0026frasl;23)きてない。すぐ来るだろう。\nしかし後述のracerのためにソースが必要なので別途ソースはダウンロードする必要がある。\nエディタ Emacs, Vim, Atomだったらracerを使う。 racerのソースを持ってきてコンパイルしてエディタプラグインをエディタに入れてrustコンパイラのソース持ってきて2行設定書けば使える。ソース補完と定義元ジャンプがある。ちゃんと型を見て補完候補出してくれるし標準ライブラリのソースにもジャンプ出来るので中々便利。\ngofmtのrust版、rustfmtは開発版のコンパイラを持ってこないとコンパイル出来ないので私は諦めているが使いたい人は試すといいと思う。少なくともEmacs向けのプラグインはある。\nビルドツール コンパイラと一緒に配布される(FreeBSDのpkgでは別になってる)Cagroがある。雛形作成、依存解決、ビルド、テスト、ベンチマークなどのタスクが出来る。クロスコンパイルとかも。\nパッケージ管理 クライアント側はCargo。セントラルレポジトリ的なのはcrates.io。crates.ioに登録されてなくてもCargoはgitから取ってくるとかも出来るので野良パッケージも使える。\nテスト 関数に#[test]アノテーションを付ければ良い。つまり、ソースとテストを同じファイルに書ける。結構便利。テスト用ビルドでのみコンパイルされて他のビルドだと無視される（と思う。）。\nfn fib(n:isize)-\u0026gt; isize{ifn\u0026lt;2{1}else{fib(n-1)+fib(n-2)}}#[test]fn test_fib(){assert(fib(1)==1);} これ便利とかここ躓いたとか。\n所有権 分かってたけどやっぱり躓いた。局所的には「あ、ここ所有権必要だわ」とか分かるのだが大域的には難しい。\n例えばボトムアップで作っていくと、小さな関数で所有権が必要だがそれを呼び出そうとしたら呼出元が所有権を持っていなくて困るとか。小さな値とか状態を持たない値だったらcloneして渡すのだがそうでなければ手戻りが発生する。この辺は実際に書いて経験を積むしかなさそう。\n因みに代数的データ型と所有権でも困っている。\nenum Value{Str(String),Int(isize)} とかするとStrデータコンストラクタがStringの所有権を持っているのでパターンマッチで取り出す時に所有権が貰えず、match{Value::Str(ref str) =\u0026gt; ...,}と、refを使って借りるしかない。\nまだ経験が足りないので困ったまま。\nサイズ rustはコンパイル時にメモリ管理を決定するのでコンパイル時にデータのメモリサイズが決まってないといけない。例えば以下のコードはコンパイルが通らない。Bazにおいて、fooのサイズが決定出来ないと言われる。\ntraitFoo{}struct Bar{}implFooforBar{}struct Baz{foo: Foo} これはFooはただのインターフェースの定義であって、データを定義してないので実際にFooを実装したデータ型のサイズが分からないからだ(今後変更がある模様。)。次のようにパラメータにすれば解決出来る。\nstruct Baz\u0026lt;T\u0026gt;{foo: T}impl\u0026lt;T:Foo\u0026gt;Baz\u0026lt;T\u0026gt;{} 因みに元の定義とは変わってデータの時点ではTで、implを書く時にFooに絞っているのは不要な所では不要な条件を付けないようにしているからだろうか。 変な値を入れられて困りそうだが、構造体のフィールドを公開しなければ勝手に値が作られることはなく、impl内に書いたコンストラクタを通してのみ値が作られるので心配無用である。\n\u0026amp;[T]とVec\u0026lt;T\u0026gt;, \u0026amp;strとString 使い分けはRustの文字列のガイド - Qiitaを見て欲しいが、相互変換で困ることがあったので。\nStringから\u0026amp;strに変換する時に「as_sliceはunstable」と言われる。こうしてやれば良いようだ。\nletstring=\u0026#34;String\u0026#34;.to_string();letlent_str=\u0026amp;string[..] Vectorも同じ。\nletvector=vec![1,2,3];letlent_slice=\u0026amp;vector[..] HashMap 所有権周りで困る。例えば次のコードはコンパイルが通らない。\nmatchhash.get(key){Some(v)=\u0026gt;v,None=\u0026gt;{hash.insert(key,default);default}} matchの中でhashがborrowされてると判断されるのでNone節でhashにinsert出来ない。ワークアラウンド もあるが、どう考えてもイケてないので改善される模様\nデータ型と参照 データ型の中で参照を使いづらい。\nstruct Value{Str(\u0026amp;str),Int(isize)} とすると、怒られる。\u0026amp;strは自分の物ではないので生存期間が分からないからパラメータで受け取らないといけない。\nstruct \u0026lt;\u0026#39;a\u0026gt;Value\u0026lt;\u0026#39;a\u0026gt;{Str(\u0026amp;\u0026#39;astr),Int(isize)} そして、やはり所有権を持っていないので次のようなメソッドを定義出来ない。\nimpl\u0026lt;\u0026#39;a\u0026gt;Value\u0026lt;\u0026#39;a\u0026gt;{fn empty_str()-\u0026gt; \u0026lt;\u0026#39;a\u0026gt;{Value::Str(\u0026#34;\u0026#34;)}} …と思ったらなんか出来ちゃった。今まで使い方が悪かったのかも。これはナシ。\nモナド mdoというdo記法っぽく書けるマクロがあるがクロージャを作るとそのクロージャが変数の所有権を持っていって面倒だったのでそんなに良くなかった。optionモナドに関しては素直にmapとandThenを使った方が良い。\ntry! rustのコードでは至る所でResult(Either)型が返ってくる。それに対して毎回パターンマッチするのはやってられない。かといって安全でないunwrap()を各所で使うのも精神衛生に良くない。Errに対してunwrapを使うとpanicになるが、rustにはpanicをハンドルする方法はない。\nそこでtry!。返り値がErrだったらそのままErrで関数から抜け、Okだったらその値を返すマクロ。多分展開結果はこんな形になってる:\nletv=try!(foo()); が\nletv=matchfoo(){Ok(v)=\u0026gt;v,e@Err(_)=\u0026gt;returne}; 。\nこれの逆、成功したらその値で抜け、ErrだったらErrを返して処理を継続するやつとかオプション版とかも欲しい。\n最後に Lisp処理系作ろうとしたけど完成しなかったのでそっとここに置いときますね\nκLisp\n","categories":["Rust"],"category_urls":["/categories/rust"],"date":"2015-09-23","title":"rust初心者へのガイド","url":"https://KeenS.github.io/blog/2015/09/23/rustwokakutokinochiken/"},
  {"body":"久しぶりですね。κeenです。最近はMacでもまともな仮想環境が整ってきたのでFreeBSDでも動かすかーといって試したやつを共有します。\n大部分はここを参考にしてますが、ちゃんと動きます。\nxhyveとは xhyve – Lightweight Virtualization on OS X Based on bhyve | pagetable.com\nFreeBSDのBHyVeをMac OS Xに移植したものです。Intel CPUの仮想化フレームワークを使うことで仮想化の実装が（比較的）が楽になるからやろうぜってプロジェクトです。 カーネルレベルでのサポートが必要になりますがyosemiteからHyervisor.frameworkが入っているのでそれが使えます。\n因みに開発はそんなに活発ではないです。\n動かす xhyveの準備 FreeBSDのサポートは既にマージされているのでcloneしてきてそのまま使えます。\ngit clone git@github.com:mist64/xhyve.git cd xhyve make FreeBSDのイメージの入手 イメージは現在10.2が出ているので\nfetch http://ftp.freebsd.org/pub/FreeBSD/releases/VM-IMAGES/10.2-RELEASE/amd64/Latest/FreeBSD-10.2-RELEASE-amd64.raw.xz unxz FreeBSD-10.2-RELEASE-amd64.raw.xz で入手出来ます。\n起動スクリプトの準備 参照ブログのままだとハードディスクが読めないのでIMG_HDDにもイメージを指定します。\n名前は何でも良いのですがfreebsd.shとして保存し、chmod +x freebsd.shします。\n#!/bin/sh  USERBOOT=\u0026#34;test/userboot.so\u0026#34; BOOTVOLUME=\u0026#34;FreeBSD-10.2-RELEASE-amd64.raw\u0026#34; KERNELENV=\u0026#34;\u0026#34; MEM=\u0026#34;-m 1G\u0026#34; #SMP=\u0026#34;-c 2\u0026#34; #NET=\u0026#34;-s 2:0,virtio-net\u0026#34; #IMG_CD=\u0026#34;-s 3,ahci-cd,/somepath/somefile.iso\u0026#34; IMG_HDD=\u0026#34;-s 4,virtio-blk,$BOOTVOLUME\u0026#34; PCI_DEV=\u0026#34;-s 0:0,hostbridge -s 31,lpc\u0026#34; LPC_DEV=\u0026#34;-l com1,stdio\u0026#34; #UUID=\u0026#34;-U deadbeef-dead-dead-dead-deaddeafbeef\u0026#34; build/xhyve -A $MEM $SMP $PCI_DEV $LPC_DEV $NET $IMG_CD $IMG_HDD $UUID -f fbsd,$USERBOOT,$BOOTVOLUME,\u0026#34;$KERNELENV\u0026#34; 起動 ./freebsd.sh で起動します。\nその他 FreeBSDのイメージを一杯作りたい人はダウンロードしてきたやつをcpして使うと良いと思います。\n","categories":["xhyve","FreeBSD","Mac"],"category_urls":["/categories/xhyve","/categories/freebsd","/categories/mac"],"date":"2015-09-16","title":"xhyveでFreeBSD guestを動かす","url":"https://KeenS.github.io/blog/2015/09/16/xhyvedefreebsd_guestwougokasu/"},
  {"body":"# ISUCONこれまでの流れ ---------------------- 雑に書き殴った === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + ISUCON3、 4の予選、本戦に出場（学生枠） === # ISUCON1 ブログ --------------- * node perl ruby * kazeburoの罠 * ブログのサイドバーが重いやつ * 割と親切なルール === # ISUCON2 チケット予約サイト --------------------------- * perl ruby node php java python * 席ランダムにしてなくてもベンチマーカー通っちゃう * 変更が1秒以内に反映されていること → 0.9秒毎に裏でバッチを回す * JOINが3連になってる所があってみんなそこに引っ掛かったがボトルネックはそこじゃない * ちょっとルールが雑になった === # ISUCON3予選 スニペット投稿サイト -------------------------------- * go node perl python ruby php * AWS1台 * Markdown変換がperl製の重いやつ * AWSだとプロセスのフォークも重い * titleの抜き出しも重い * チェッカーが甘くてVarnishを導入しただけで点数爆上がり * SQLの典型問題とかも * workloadに気付かなかった人多数 * 学生枠が出来た * ベンチマーカが通れば何でもアリな風潮 === # ISUCON3本戦 画像SNS -------------------- * go node perl python ruby * オンプレ5台 * 画像の変換が重い * 実は帯域もつらい * 画像のチェッカがあってチェッカが通れば画質を落としても良かった * 組長の罠 * ベンチマーカーに通れば何でもアリ * 複数サーバーでのファイルの共有にWebDAVが盲点 * 点数計算の罠に嵌まる人多数 + 基本点より追加点に目が眩む人がそれなりに * 推測するな計測せよ * nodeで初期パスワードが間違っているトラブル === # ISUCON4予選 銀行 -------------------------------------- * go node perl php python ruby * AWS1台 * ワークロードを桁外れに指定するとベンチマーカーが走り続けるバグ * ベンチマーカーにアクセスして行動パターンを解析した人が出る（その情報は使ってない。スポーツマンシップ。） * テンプレートエンジンをやめて静的ファイル * Go勢のon memory戦略が跋扈 * 「メモリに載せれば勝てるぜ」風潮 * 静的ファイルを返さない反則ギリギリのチューニング * ベンチマーカーのチューニング * Varnish潰し * アプリをC++で書き換えて予選突破したチームも出る === # ISUCON4本戦 動画広告 ---------------- * go perl php python ruby * オンプレ3台 * 最初からRedisに動画が載ってる * それ外したらスコア頭打ち(帯域がつまる) * ベンチマーク同士が干渉しあう * 実はCache-Controlをしたらスコアが爆上がり(上位2チームだけ気付いた) * 3位のチームは外向きと内向きの2枚のNICを使って団子状のスコアから頭1つだけ出た === #ISUCON5予選 ??? ---------------- * perl ruby node php python go java (scala) * GCP * 今までの予選だとベンチマーカが競技者の手元に渡る問題があった。 * かといって外部からのベンチマークは安定しない。 * GCPならGoogleの謎の技術によって安定するらしい。 * @tagomoris 「もはやISUCONは予選で落ちる人の方が多くなった。その人達にとっては予選こそがISUCONなのだ」   ","categories":["ISUCON"],"category_urls":["/categories/isucon"],"date":"2015-09-04","title":"ISUCONこれまでの流れ","url":"https://KeenS.github.io/slide/isuconkoremadenonagare/"},
  {"body":"# SMLでPNGデコーダを作ろうとして分かったこと ------------------------------------------ サイバーエージェント アドテクスタジオ エンジニア月初会 === # About Me ---------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + AMoAdの新卒 + Lisp, ML, Shell Scriptあたりを書きます === うーむ。画像フォーマットの扱い一回くらい書いてみないとなーと思ってたけどやっぱり既存なんだよなー。Common LispかSMLあたりならフロンティアになれそう。\n\u0026mdash; κeen (@blackenedgold) 2015, 9月 3 === @blackenedgold 仕様を理解するためにデコーダから実装するのがオススメです\n\u0026mdash; ELD-R-ESH-2 (@eldesh) 2015, 9月 3 === @blackenedgold そんな詳しいわけではないんですが、jpegかpngがおすすめです。webpは動画コーデック由来で難しいと思います。tiffは画像コンテナみたいな立ち位置なので画像フォーマット感がないかなと。\n\u0026mdash; ELD-R-ESH-2 (@eldesh) 2015, 9月 3 === 明日の朝までに SMLでpngデコーダを実装しよう === # Standard ML ------------- * ML系の函数型言語 * 文法はOCamlよりF#に似てる（というかF#が似せてきた） * 結構書き易い * 仕様は SML'90とSML'97がある * 仕様で言語のformal semanticsが定められてたりする * 要は研究向き + **ライブラリほぼなし** + **コミュニティほぼなし** === ＞　無理ゲー　＜ === # 一応フォーマットを調べる ------------------------ ``` +-----------------+ | Chunk | 画像はChunkの集合。 ++---------------++ Chunk自体は簡単なフォーマット || length | name || |+---------------+| || data || || ... || |+---------------+| || CRC || ++---------------++ | Chunk | | ... | ``` === 意外と単純？  === # とりあえず書いてみる --------------------- ```sml structure PNG = struct fun readChunk data i = ... end ``` === # 案外苦戦 ------------ * 型が厳密なので型の行き来が面倒 + 8bit  32bit + 符号付き  符号無し + byte  char ```sml val op  = Word. fun nameToWord name = CharVector.foldl (fn(c, acc) = 3時間後  === さて、メインのデータ抜き出すところまでは行ったけど次復号だ。\n\u0026mdash; κeen (@blackenedgold) 2015, 9月 3 === # 今更PNGについて ---------------- * GIFの特許問題を回避するために作られたフォーマット + LZ77がマズいらしい * **可逆圧縮アルゴリズムを使う** + **アルゴリズムは1つとは限らない** + 但し仕様で指定されているのはzlibのみ * フィルタを噛ませることでプログレッシブな表示も可能 === # SMLのZLibライブラリ -------------------- * ない === zlib……実装するか  === # ZLib ------ * RFC-1950 * zipやpngで使われるフォーマット * ZLib自体は圧縮データのコンテナで **圧縮アルゴリズム自体は1つとは限らない** + 但し仕様で指定されているのはdeflateのみ === # SMLのDeflateライブラリ -------------------- * ない === deflate…実装するか  === # Deflate --------- * RFC-1951 * ハフマン符号の変種の可逆圧縮アルゴリズム + **3種類の符号化方式を自由に使ってよい** === (心)ボキッ === # 学んだこと ----------- * PNGは一晩でデコーダを書ける程柔じゃない + 事前調査も大事 * 書き易い言語でもコミュニティが大事 * 1晩でLTの準備はつらい === # 付録 ------ * [今回のコード](https://github.com/KeenS/sml-png) * [SMLのパッケージマネージャ](https://github.com/standardml/smackage) * [PNG](http://www.w3.org/TR/2003/REC-PNG-20031110/) * [RFC-1950 ZLIB](https://www.ietf.org/rfc/rfc1950.txt) * [RFC-1951 DEFLATE](https://www.ietf.org/rfc/rfc1950.txt)   ","categories":["SML","月初会"],"category_urls":["/categories/sml","/categories/%e6%9c%88%e5%88%9d%e4%bc%9a"],"date":"2015-09-04","title":"SMLでPNGデコーダを作ろうとして分かったこと","url":"https://KeenS.github.io/slide/smldepngdeko_dawotsukuroutoshitewakattakoto/"},
  {"body":"# Method Drawでお手軽LGTM生成 ---------------------- === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバーエージェントのエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # Method Draw ------------- * シンプルなSVG エディタ * オープンソース * [editor.method.ac](http://editor.method.ac/) === # デモ === # 以上 ------ Have a happy hacking life   ","categories":["小ネタ"],"category_urls":["/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2015-08-14","title":"Method Drawでお手軽LGTM生成","url":"https://KeenS.github.io/slide/method_drawdeotegarulgtmseisei/"},
  {"body":"# 構文解析にまつわる小話たち ---------------------- [#peg_study](https://twitter.com/search?q=%23peg_study\u0026src=typd\u0026vertical=default\u0026f=tweets) === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + サイバエージェントの新卒エンジニア + Lisp, ML, Shell Scriptあたりを書きます === # ウォームアップ === # 構文解析はバッドノウハウ ------------------------- * プログラム言語を使っているなら既にパーサはある + 文法も定義されてる * 目の前のパーサを使え + パーサAPIがある言語もある(Lispとか) * そうでなくても内部DSLを考えろ + 内部DSLで解決出来ないときだけ構文解析 === # 本質はAST ----------- * 結局はASTになればどんな文法でも同じ * 文法はただの外皮、欲しいのはAST * シンタックスシュガーは飾り + DRY出来るなら別 * S式を使え + ASTをそのまま書き下せる === # AST First ----------- * 最初にASTを考える。そして文法を考える * 何が欲しいのかイメージし易くなる * 構文解析はAST生成の自動化。普段してないことを自動化するのは愚か。 * 早めに間違いに気付ける + `+`は二項演算子。じゃあ `\u0026\u0026` は？ `=` は？ Note: Lispだと+は関数、andはマクロ、setqはスペシャルフォーム === # 構文解析の流れ === # 構文解析の流れ --------------- 1. Lexer generaterからlexerを作る + Lexとか 2. Parser generaterからparserを作る + yaccとか + BNFという記法 3. ソースファイルをlexerで処理してトークン化する 4. トークン列をparserで処理してASTを作る === ``` [Lexer] [parser] [Source]-------[Tokens]------[AST] ``` === # LexerとParserを分ける意味 -------------------------- * (上向き構文解析だと分けないとつらい) * 役割の分担 + 困難は分割せよ * 文字列をシンボル化して比較が高速に * 思考のフレームワークとして === 字句解析器手づくりの簡単さに対して構文解析器手づくりはわりと人を殺しにかかる\n\u0026mdash; gfn (@bd_gfngfn) 2015, 3月 20 === # 正規表現の使いどころ --------------------- * 高速な実装がある * 部品化しにくい * 括弧の対応とか入れ子構造(`if .. then .. else`とか)は扱えない + perlの正規表現は厳密には正規表現ではない * 構文解析には向かない + 「マッチ」は出来ても「抜き出し」は面倒 * Lexerには向いてる + トークン自体末端の部品なので部品化する必要がない === 依存型のある言語でlexとか作ったら出てくるトークンの型変数に正規表現出てくるのかな\n\u0026mdash; eld-r-esh-2 (@eldesh) 2015, 5月 11 === 「bnf = (大雑把に言って)正規表現+括弧の対応」というのはchomsky–schützenbergerの定理という結構マニアックな定理(ドラゴンブックには載ってないと思う)をさらに僕なりに超訳したものなのであまり知られてないと思います．\n\u0026mdash; ryoma sin\u0026#39;ya (@sinya8282) 2015, 5月 10 === # 構文クラス === # 構文クラス ------------ * 学術的だが知っておくと幸せになれる * 文脈自由文法を解析するためのものを話す + 多くのプログラム言語は文脈自由文法 + 正規言語 ⊂ 文脈自由文法 * 大きく分けると上向き構文解析と下向き構文解析 * 詳しくは[ドラゴンブック](http://www.amazon.co.jp/%e3%82%b3%e3%83%b3%e3%83%91%e3%82%a4%e3%83%a9%e2%80%95%e5%8e%9f%e7%90%86%e3%83%bb%e6%8a%80%e6%b3%95%e3%83%bb%e3%83%84%e3%83%bc%e3%83%ab-information-computing-a-v-%e3%82%a8%e3%82%a4%e3%83%9b/dp/478191229x)参照 === # LL(1) ---- * 下向き + 再帰降下パーサ * 定義した言語しか厳密に受け取らない * 線形線形時間でパース可能 * 手書きに向く * パーサーコンビネータとかも === # LR(1) ---- * 上向き + トークンをくっつけて構文要素に、構文要素をくっつけてさらに上の構文要素に… * LL(n)⊂LR(n) * LRそのものの解析は難しくて、いくつかサブクラスがある + 単純LR (SLR): 貧弱 + 先読みLR (LALR): パーサジェネレータでよく使われる + 正準LR: 計算コストが高い。メモリ喰う * 事前計算のコスト（面倒くささ）が高い + パーサジェネレータ === # LRパーサジェネレータ ----- * 基本はBNF(Backus-Naur-Form) * いくつか方式がある + 演算子順位解析も合わせる - EmacsのSMIEとか + BNFだけでやる - 別の言語も受理する可能性がある ドラゴンブック 上 p. 247 - 普通は問題にならない === # LRの限界とか ------------- * `-`の単項演算子と二項演算子の衝突 1. SMLみたいに諦める(単項の`-`を`~`で表す) 2. Lexerで区別する * 左再帰で無限ループ + 手動でどうにか出来る + 自動でどうにかしてくれるジェネレータもある * BNFの書き方によっては文法があいまいになる + `if .. then .. if .. then .. else ..` とか + 自動ではどうにもできないので気をつけるしかない === # BNFとパーサージェネレータの良さ ------------ * BNFは言語を定義する。 + 言語仕様にも使われる * 要は「仕様からプログラムを生成する」 * 宣言的 === # 複数文法のサポートとグローバル変数の衝突 --------------------------------------- * 複数の文法をサポートしたい時がある + 独自記法と互換記法とか * 雑なパーサジェネレータ/コンビネータを使っているとグローバル変数が衝突する + パーサライブラリの作者は配慮して下さい。 === # 言語仕様の配慮 --------------- * LispはLL * Java 1.0はLALR + 今はLALRではないらしい * PrologはLALRだった気がする === # 非文脈自由文法 ---------------- * 文脈を持つ（雑） * ひねりなくパーサージェネレータ使っただけじゃ解析出来ない言語のこと。 === ## sedのs/// ----------- * 実は `s|||`のように区切文字は何でもいい + パスネームの置換に便利 * 対応関係が文脈で変わるので非文脈自由 === ## Markdown ----------- * 元々のperlの実装は正規表現 + 再帰を使っているので正規言語ではなく文脈自由文法 * GFMなどのTable記法はカラム数という文脈があるので非文脈自由 * Table記法をサポートする時は覚悟を持って。 === # その他 -------- * 関数の仮引数の数と実引数の数の一致 * 変数の使用の前に変数宣言 * 要は構文解析で出来ることには限界がある。 === # パーサの実際 === # 速度と手軽さ -------------- * 外部DSLやコンフィグファイルだとパーサの速度は必要ない + メインループで使われないので起動時間にしか影響しない。 + むしろ手軽に作れた方がいい * HTTPだとかメインループで使うものはどうやってでも速くしたい + 労力は惜しまない === # 手書きとジェネレータとコンビネータ ---------------------------------- * 速度が必要ならジェネレータ * LLでないならジェネレータ * 手軽さが欲しいならコンビネータ * 色々手を加えたいなら手書き…かも === パーサ手書きするのダサイよなぁ。クラスが分からなくなる。\n\u0026mdash; ELD-R-ESH-2 (@eldesh) 2015, 5月 11 === # ジェネレータの扱いにくさ -------------------------- * あんまり人気ない気がする * 2回も前処理必要なのダサいよね * 新たな文法覚える必要がある * そもそも作るのにもコストが高い + 言語の文法に合わせたプリンタ + 拡張性持たせると厄介 * かといって正規表現はやめましょうね === # DSLパーサジェネレータ ---------------------- PEGが正規表現と違って辛いところは言語組み込みじゃないのとワンライナーに向かないことなんだよな… #peg_study\n\u0026mdash; わかめ@TypeScriptカッコガチ (@vvakame) 2015, 8月 8 === # DSLパーサジェネレータ ---------------------- * あったらそれなりに人気出そう * メタプログラミングが出来る必要がある * Common Lisp + 作者自身作ってる途中でジェネレータとコンビネータを勘違いする + ドキュメントでジェネレータといってるのに実際はコンビネータだったりする * D + なんか作ってる人いるらしい === # 複雑性と分かりやすさ --------------------- オーバーエンジニアリングを「あいつは力に溺れた」と言い変えていくといいと思う\n\u0026mdash; イカid:mizchi0x (@mizchi) 2015, 2月 12 === # 複雑性と分かりやすさ --------------------- * パーサが複雑な文法に対応出来ても人間が追い付かない * 周辺のサポートも必要になるのでやっぱりシンプルな方が良い。 + LRよりLL + S式とかシンプルの極み + [Clojureシンタックスハイライター開発から考えるこれからのlispに必要なもの](http://www.slideshare.net/sohta/clojurelisp?ref=http://athos.hatenablog.com/entry/2015/07/29/222535) * 「出来る」と「した方がいい」は別の話 === S式はどう考えても読み易い……\n\u0026mdash; Ocamlアイドル (@no_maddo) 2015, 4月 21 === }]))みたいなのを書いてると、括弧が一種類の言語、いいなぁ、と思ったりします。\n\u0026mdash; mzp (@mzp) 2015, 4月 14 === # ソースロケーション保持法 === # ソースロケーション保持法 ------------------------- * エラーメッセージを出すためにはソースロケーションを保持する必要がある * flymakeの情報: ファイル名、開始行/列 終了行/列 エラーメッセージ + 最悪これがあればどうにかなる + 「分かりやすい」メッセージはツールに任せる * 字句解析だけでなく意味解析、さらにはつまるところコンパイルが終わるまで保存する必要がある + トークンやASTにメンバが増える + オブジェクト指向のカプセル化って素晴らしい === # 1. インクルード ---------------------- * トークンのデータに入れてしまうパターン * `datatype token = Plus of int * int | Symbol of int * int * string` ... * OOPなら自然だが函数型だとパターンマッチがつらくなる === # 2. ラップ -------- * ロケーションのレコードでトークンをラップする * `{start:int, end: int, token: token}` * パターンマッチは少し楽になる + 多相レコードがないとそもそもレコードつらいけどな！！ * MLtonがやってるらしい === # 3. テーブル ------------- * ロケーションテーブルを持って、トークンにはテーブルへのキーだけ持たせる * トークンが軽くなるので速そう * でも面倒そう === # エラー処理 === # エラーメッセージ ------------------------ * 一応ロケーションがとれればエラー箇所は出せる。 * メッセージの親切さはツールとヒューリスティックと根気 * clangとか頑張ってる ``` ERROR: expected tEnd before '' each do {} ^ ``` === # エラー回復 ------------- * シンタックスハイライターは壊れた文法も解析しないといけない * 1回のコンパイルでできるだけ多くのエラーメッセージを出したい * シンタックスエラーから回復したい === # Cの易しさ ----------- * エラーがあってもセミコロンまで読み飛ばせば回復出来る + CやJavaは結構コンパイラが教えてくれる * そういう言語設計も大事 === # 拡張方法 === # リードマクロ -------------- * トークンレベルの拡張 * 特定の「文字」がきた時にユーザ定義関数を使ってパースする * リテラルをユーザが定義することが出来る + 正規表現リテラルとか + [Common Lispの正規表現](http://weitz.de/cl-interpol/) === # マクロ -------- * ASTレベルの拡張 * LispとかScalaとかRustとか + Lispは自由度が高い + 関数マクロはないよりマシ程度 * ~衛生性~ * [マクロについて整理してみる | κeenのHappy Hacκing Blog](//KeenS.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru/) === ## Cのマクロ ------------ * プリプロセッサなのでコンパイラの拡張ではない * プリプロセッサ自体レキサを持つ + パーサとレキサを分ける意味 * ASTに関知しないのでやりたい放題 === # 中置演算子 ----------- * 新しい中置演算子と優先順位を定義できる言語は多い + Haskell, SML, Prolog… * パーサをその場で書き換えるのは難しいので後で処理する + [\\[コンパイラ\\]\\[Haskell\\]\\[OCaml\\] Haskellのinfixの仕組み - mad日記](http://d.hatena.ne.jp/MaD/touch/20090108) * シンタックスのプラグインをセマンティクスに入れてるのでちょっと無茶 === # 中置演算子 ----------- * 人間が同時に覚えられるのは3つまで + 優先順位がいくつもあっても覚えられない + 優先度40とか900とか無理。 * 本質はAST + 文法に問題を抱えるくらいならS式を使え === # Coq ----- Coqは謎のテクノロジーにより `Notation`を使えば新しい文法を定義出来る ```coq Notation \"'SKIP'\" := CSkip. Notation \"X '::=' a\" := (CAss X a) (at level 60). Notation \"c1 ; c2\" := (CSeq c1 c2) (at level 80, right associativity). Notation \"'WHILE' b 'DO' c 'END'\" := (CWhile b c) (at level 80, right associativity). Notation \"'IFB' e1 'THEN' e2 'ELSE' e3 'FI'\" := (CIf e1 e2 e3) (at level 80, right associativity). Definition fact_in_coq : com := Z ::= AId X; Y ::= ANum 1; WHILE BNot (BEq (AId Z) (ANum 0)) DO Y ::= AMult (AId Y) (AId Z); Z ::= AMinus (AId Z) (ANum 1) END. ``` === # 雑な話題 === # テスト ------- * ASTのテストは案外難しい + 微妙な仕様変更で結果が変わる + でも言語の動作には関係なかったり 1. あきらめる 2. 不屈の精神でテストを直し続ける 3. 木に対するクエリ言語を使う === # 先読みと副作用 -------------- * 先読みしてバックトラックすると副作用があった時に困る 1. 副作用を許さない 2. 副作用は自己責任 3. 一旦先読みで正しいパスを記憶してから正しいパスでもう一度パース   ","categories":["構文解析","言語実装"],"category_urls":["/categories/%e6%a7%8b%e6%96%87%e8%a7%a3%e6%9e%90","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2015-08-08","title":"構文解析にまつわる小話たち","url":"https://KeenS.github.io/slide/koubunkaisekiarekore/"},
  {"body":"ファイル生成/削除コマンドについて覚え書き。\n空ファイル生成 $ touch file サイズ指定でファイル生成 0埋め/高速なら\n$ dd if=/dev/zero of=file bs=size count=1 ランダム/低速なら\n$ dd if=/dev/random of=file bs=size count=1 こっちは圧縮されてもサイズが極端に変わらない。\nファイルの切り詰め $ truncate -s size file 上記で作ったファイルのサイズを変えたりログファイルを一旦クリアしたりに便利。\n普通の削除 $ rm file ただしハードディスク上にはデータは残るのでセキュリティ的には完全ではない。\nディスク上からも完全削除 $ shred -u file -uがなかったらファイルを壊すが削除はしない。\nshredが出てこなかったので調べたついでにまとめた。\n","categories":["CLI","備忘録"],"category_urls":["/categories/cli","/categories/%e5%82%99%e5%bf%98%e9%8c%b2"],"date":"2015-07-05","title":"ファイル削除コマンド色々","url":"https://KeenS.github.io/blog/2015/07/05/fairusakujokomandoiroiro/"},
  {"body":"何故Lisperがマクロについて語るのか。Lisperと議論してみても満足のいく答を得た人はそんなにいないと思う。 それはLisper自身便利とは思っていても何が便利なのかを意識してなくて他人に上手く説明出来ないからじゃないかと思った。 ちょっと思いついた範囲でまとめてみる。\n最近ではマクロシステムを持つ言語は珍しくない。Rust, Scala, Template Haskell, Mirahなどなど。最初にCommon Lispのマクロと他の言語のマクロとの違いを少し考えてみたい。\nUnless まず、unlessをマクロで書くことを考えてみたい。単純にifにnotをつければいい。\nCommon Lispではこうなる。\n(if (not foo-p) bar) (defmacro unless (cond then) `(if (not ,cond) ,then)) (unless foo-p bar) Rustだとこうなるだろうか。\nif!isFoo{bar;}macro_rules!unless{($cond:expr,$then:stmt)=\u0026gt;{{if!$cond{$then}}};}unless!(isFoo,{bar;}) あるいはmirahだとこうなる。unlessが予約語なので_unlessにした。\nif ! isFoo bar end macro def _unless(cond, block:Block) quote{ if ! `cond` `block.body` end } end _unless isFoo do bar end ちなみにCだとこう出来る。\nif(! is_foo) bar; #define unless(cond) if(!(cond))  unless(is_foo) bar; さて、上のマクロたちを見比べて欲しい。Common LispのマクロとCのマクロは違和感なく新たな制御構造を作れたのに対してRustとMirahはマクロ呼び出しが剥き出しになっている。\nここで注意して欲しいのはCはともかくCommon Lisp、Rust、Mirahのマクロは全て引数に必要な構文木をとってそのまま用意したテンプレートにあてはめているだけだ。やっていることに違いはない。 何が違うかというとマクロ呼び出しの構文が制御構造の構文と同じか違うかという点だけだ。私の知る範囲ではそのような構文をした言語はLispしかない。だから「Lispの」マクロなのだ。\nもう一つ。どのマクロ定義も十分直感的に読めたと思う。この範囲なら S式だからマクロが簡単になるということはない と思う。別にS式でなくてもquasiquoteがあれば十分読み易いマクロが書ける。\nCase caseを生成することを考えよう。\n(defun fun1 (x) (let ((y (case x ((:foo) (hoge \u0026#34;foo\u0026#34;)) ((:bar) (hoge \u0026#34;bar!\u0026#34;))))) ...)) (defun fun2 (x) (let ((y (case x ((:foo) (hoge \u0026#34;foo\u0026#34;)) ((:baz) (hoge \u0026#34;baz!\u0026#34;))))) ...)) のように似たような、しかし微妙に違うcaseが必要になったような時に必要だろう。この時、'(:foo (hoge \u0026quot;foo\u0026quot;) :bar (hoge \u0026quot;bar!\u0026quot;))のようにリテラルでそのまま書いてしまっては抽象化する意味がなくなる。例えばハッシュテーブルにKey-Valueペアを入れて必要な時に入れたり削除したりすればよい。そのようなマクロはこう書ける。\n(defmacro case-table (key hash) `(case ,key ,@(loop :for k :being :the :hash-key :of hash :using (hash-value v) :collect `((,k) ,v)))) (defparameter *table*) (setf (gethash :foo *table*) \u0026#39;(hoge \u0026#34;foo\u0026#34;)) (setf (gethash :bar *table*) \u0026#39;(hoge \u0026#34;bar!\u0026#34;)) (defun fun1 (x) (let ((y (case-table x #.*table*))) ...)) (remhash :bar *table*) (setf (gethash :baz \u0026#39;(hoge \u0026#34;baz!\u0026#34;))) (defun fun2 (x) (let ((y (case-table x #.*table*))) ...)) ハッシュテーブルを受け取ってリストを返す普通のloopマクロの力をマクロ展開時にも使える。また、ハッシュテーブルには'(hoge \u0026quot;foo\u0026quot;)などのただのリストを突っ込んだがそれをそのままASTとしても使っている。 Common Lispのマクロのもう1つの良いところはマクロの展開時にもCommon Lispの機能がフルで使えるところであり、マクロの引数に受け取るのが構文木でありデータ構造でもあるS式なところだ。ここでは S式の同図像性が重要なファクターになっている 。\n(case-table x #.*table*) で使っている #. は リードマクロ といってマクロ展開(コンパイル時)より前(リード時、構文解析時)に動作するマクロだ。このリードマクロはeval-when-readといってリード時に 値を評価する。その結果、case-tableに渡るのが '*table*というシンボルでなく*table*に束縛されているハッシュテーブルになる。因みに コンパイラマクロ というマクロ展開が終わった後に動作するマクロもある。\nマクロ1つではなくマクロの前後に動作するマクロもあってこそ初めて柔軟性を手にしている。あまりその点は議論されてないのではないだろうか。\nCommon Lispの設計 さて、各々言語には予約語や~構文というものがあると思う。メソッド定義構文など。Common Lispにもスペシャルフォームという名前で25個存在する。 驚くべきことに、ここまでに出てきたCommon Lispのコードにはスペシャルフォームは3つしか出てこない。ifとletとquoteだ。setfやloop、defun、defmacro、case、defparameterなんかはマクロで出来ている。\ndefunまでマクロで出来ているということはユーザがその気になれば関数定義の構文に手を入れたりも出来るということだ。 普通、そんなことをしたら阿鼻叫喚だがCommon Lispなら安全に出来る。マクロもシンボルに束縛されているので新たにマクロで上書きしたシンボルを名前空間にインポートしなければ今まで通りのdefunやloopが使える。\nもう1つ、普段使うものがマクロで出来ているということはマクロを被せてない機能は相当低レベルだということだ。マクロさえ書けば全く新しい言語機能を追加出来るということであり、あるいは全く新しい言語も作れてしまう。\nこのような設計はマクロで制御構造までも作れるから出来るのだ。関数定義構文をマクロで定義している言語はLisp以外に私は知らない。\nメタプログラミングとCommon Lisp ところで、マクロに限らないメタプログラミングについて考えてみたい。メタプログラミングとは、プログラムを書くプログラムを書くことだ。プログラムはテキスト形式のソースコードから実行形式に至るまでの間に様々な中間形式から中間形式に変換される。メタプログラミングはそのどこかの形式を生成することと同義になる。通常、処理系内部で使う形式は変なことをされると困るのであまり外部に公開したくない。メタプログラミングを許すとしても構文解析などのフロントエンドに近い部分になるだろう。\n例えばyaccやlexのようなソースコードジェネレータ、rubyやDのような文字列ベースのメタプログラミングは公開APIであるところのパーサだけを使っているので安全性は高い。しかし文字列だけだと構造がないので書く側はつらい。一応、Common Lispにもread関数とeval関数があるのでCommon Lispのソースコード文字列を吐いてreadしてevalすれば文字列メタプログラミングは出来る。特に嬉しくないのでやらないが。\n次はトークンベースのメタプログラミングがある。Cのプリプロセッサなど。Common Lispでもリードマクロで可能だ。例えば正規表現リテラルを作ったりとかの例がある。\n次はASTベースのメタプログラミングがある。マクロだ。これは今まで見てきた。\nこれより先はメタプログラミングとはあまり言わない気がする。JITと呼ぶのではないか。Common Lispにもeval関数やcompile関数があるからそういうことも出来る。正規表現ライブラリなんかが使っている。\n私が言いたいのはCommon Lispにはメタプログラミングの機構が一杯あるということではない。read, eval, compile…。気付いたかもしれないが、LispはLisp自身で出来ている。 Lispを書くとき、Lispを書いてるかもしれないしLispを構成するLispを書いているかもしれない。いくらでもメタプログラミングが出来るということだ。\nまとめ 何やらCommon Lisp賛美歌になってしまったが一応まとめておく。\n 簡単なマクロ定義ならS式である必要はない 複雑なマクロ定義ならS式であると書き易い。恐らく他の構文でも書けないことはない。 マクロ呼び出し構文はS式でないと重大な違いがある。 マクロ以外にもリードマクロやパッケージなど他の言語機能があってこそマクロが活きる。 言語機能だけでなくマクロを前提とした設計も重要である。 LispはS式で出来ている以前にLispで出来ている。 ","categories":["Lisp","Common Lisp","ポエム"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/%e3%83%9d%e3%82%a8%e3%83%a0"],"date":"2015-07-04","title":"マクロについて整理してみる","url":"https://KeenS.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru/"},
  {"body":"κeenです。最近は何故かBlack君って呼ばれます。Shebangの書き方にはいくつかあって、それを利用したふと面白い方法を思い付いたので共有を。\nさて、ご存知Shebangといえば\n#!/bin/sh ... のようにファイルの1行目が#!から始まっているとシェルがそれ以降の文字列を実行可能ファイルのパス名として捜して実行してくれるものですが、実は#!は唯一のフォーマットではありません。\n#!がデファクトになる前なのかそもそもシェルにコメントがなかった時代のものなのかは知りませんが昔は\n: /bin/sh ... と:で始めていたらしいです。因みに:は「何もしないコマンド」です。実質的にコメントとして扱ったり副作用のある変数展開だけを行なったりプログラマティックコメントアウトだったりの用途で使われてます。\nさて、シェルは全て文字列なのでクォートしてもしなくても構いません。\n\u0026#34;:\u0026#34; \u0026#34;/bin/sh\u0026#34; としてもちゃんと動いてくれます。なぜわざわざクォートするかというと割と処理系ポータブルなCommon Lisp実行可能ファイルを作る | κeenのHappy Hacκing Blogのように別の言語のスクリプトとして実行される時に文字列リテラルになってくれると単純に無視されるので互換性が高まるのです。\nということで完全版ポータブルなCommon Lisp実行可能ファイルはこうなります。\n\u0026#34;:\u0026#34; \u0026#34;/bin/sh\u0026#34; #| run_if_exists(){ command -v $1 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; exec \u0026#34;$@\u0026#34; } run_if_exists cl \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; run_if_exists sbcl --noinform --no-sysinit --no-userinit --script \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists clisp -norc --quiet --silent -on-error exit \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists ecl -norc -q -shell \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists mkcl -norc -q -shell \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists alisp -qq -#! \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists ccl --no-init --quiet --batch --load \u0026#34;$0\u0026#34; --eval \u0026#39;(quit)\u0026#39; -- \u0026#34;$@\u0026#34; run_if_exists abcl --noinform --noinit --nosystem --batch --load \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists lisp -quiet -noinit -batch -load \u0026#34;$0\u0026#34; -eval \u0026#39;(quit)\u0026#39; -- \u0026#34;$@\u0026#34; echo \u0026#34;No lisp implementation found\u0026#34; exit 1 |# (write-line (lisp-implementation-type)) (force-output) abclとcclが利用可能になりました。あとCIMも捜すようにしました。roswellは作者に訊いて下さい。\nちなみに、shebangの解釈はシェルに依存するのですが、B Shell, csh, tcsh, dash, Bash, zshで動作確認しました。古い機能なので新しいシェルほど切り捨てている可能性があったのですがBashやzshが大丈夫だったので良かったです。 一応非推奨な気がしますがこれしか方法がないので仕方ないですね。\nということでみなさんスクリプト書きましょう。\n追記 @blackenedgold shebangの解釈はシェルじゃなくてOSのexec()がやります。で、#!や認識できるバイナリ以外は、exec()がエラーを返した後でシェルがファイルを見て、テキストファイルならシェルスクリプトとして実行ってやってます。なので先頭が:の場合は(続\n\u0026mdash; Kilo Kawai (@anohana) 2015, 6月 26 @blackenedgold shebangとしてではなく、シェルがシェルスクリプトとして読んでるだけなので、その後に/bin/shとか書いてあっても関係ないはず (シェルによってはそこも見るかもしれませんが)\n\u0026mdash; Kilo Kawai (@anohana) 2015, 6月 26 \nということで実験してみたところ、先頭の\u0026quot;:\u0026quot; \u0026quot;/bin/sh\u0026quot;はどのシェルも読み飛ばす模様(つまり、\u0026quot;:\u0026quot; \u0026quot;/usr/bin/ruby\u0026quot;と書いてもrubyが実行される訳ではない)。\nで、先程の 完全版から\u0026quot;:\u0026quot; \u0026quot;/bin/sh\u0026quot;を取り除いて\n#| run_if_exists(){ command -v $1 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; exec \u0026#34;$@\u0026#34; } run_if_exists cl \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; run_if_exists sbcl --noinform --no-sysinit --no-userinit --script \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists clisp -norc --quiet --silent -on-error exit \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists ecl -norc -q -shell \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists mkcl -norc -q -shell \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists alisp -qq -#! \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists ccl --no-init --quiet --batch --load \u0026#34;$0\u0026#34; --eval \u0026#39;(quit)\u0026#39; -- \u0026#34;$@\u0026#34; run_if_exists abcl --noinform --noinit --nosystem --batch --load \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists lisp -quiet -noinit -batch -load \u0026#34;$0\u0026#34; -eval \u0026#39;(quit)\u0026#39; -- \u0026#34;$@\u0026#34; echo \u0026#34;No lisp implementation found\u0026#34; exit 1 |# (write-line (lisp-implementation-type)) (force-output) としても動いたのでこれが最終版ということになります。\n大学の講究でMINIX本やったどころかexecのところ自分の担当だったのに恥かしい。\n","categories":["CLI","Shell Script","Lisp","Common Lisp"],"category_urls":["/categories/cli","/categories/shell-script","/categories/lisp","/categories/common-lisp"],"date":"2015-06-26","title":"あなたの知らないShebang","url":"https://KeenS.github.io/blog/2015/06/26/anatanoshiranaishebang/"},
  {"body":"# Clojureおじさん ---------------------- サイバーエージント新卒 第5回 Fresh勉強会 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 渋谷のエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # Clojure --------- * 2007年から * JVMで動くLisp系言語 * 函数型 * 動的型付き * 値は基本immutable * 遅延シーケンス * STMがあり、並列処理に強い === # Hello World ------------- ```clojure (println \"Hello, World\") ``` === # JVM ------ ## Javaのコードをシームレスに呼べる * `obj.method()` ではなく `(.method obj)` * `Class.staticField` ではなく `Class/staticField` * `obj.method1().method2()` ではなく `(.. obj method1 method2)` === # JVM ----- ```clojure (.println System/out \"Hello JVM\") ``` ```clojure (Math/random) ``` === # Immutable ----------- * 状態を持たないのでコードの見通しが良い + 並列で考える時には重要 + 複雑さだけでなく不整合などバグの原因になりやすい * 変更可能な値もある + それらはトランザクション内でのみ変更可能 + 不整合が起きない === # 函数型 -------- ```clojure (filter odd? (map #(+ 1 %) '(1 2 3))) ``` === # 遅延シーケンス --------------- ```clojure (def natural_number (iterate inc 1)) (take 5 natural_number) ;= (1 2 3 4 5) ``` === # リスト内包表記 ---------------- ```clojure (for [x (range 5)] (* x x)) ;= (1 4 9 16 25) ``` === #並列処理に強い --------------- * 簡単にはJavaのスレッドを呼べばいい + Clojureの関数は全てCallableでRunnablea ```clojure (.start (Thread. (fn [] (Thread/sleep 1000) (println 'foo)))) ``` === #並列処理に強い --------------- ## core.async * goroutineとgochannelが使える === ## core.async ------------- ```clojure (require '[clojure.core.async :as async :refer :all]) (let [c (chan)] (go (! c \"hello\")) (assert (= \"hello\" (!! c \"hello\")) (assert (= \"hello\" (=== # 今回紹介し切れなかったの ------------------------- * マクロ * メタデータ * protocolとかの多態性 * ClojureScript/Om * Typed Clojure === # まとめ -------- * Clojureを使えばJavaが使える * Clojureを使えばPythonのリスト内包表記が使える * Clojureを使えばGoのgoroutine/gochannelが使える === Why not start Clojure?   ","categories":["Clojure","FRESH勉強会"],"category_urls":["/categories/clojure","/categories/fresh%e5%8b%89%e5%bc%b7%e4%bc%9a"],"date":"2015-06-22","title":"Clojureおじさん","url":"https://KeenS.github.io/slide/clojureojisan/"},
  {"body":"### Common Lisp 処理系拡張の探求 SBCLのマルチスレッドサポート ---------------------- Lisp Meet Up #29 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 渋谷のエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # CLのマルチスレッド ---------------------------- ## [bordeaux-threads](https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation) * 色々な処理系のマルチスレッドサポートの抽象レイヤー * デファクトスタンダード + スレッド + ロック + コンディションヴァリアル === # SBLCのマルチスレッド === # SBLCのマルチスレッド ---------------------------- * スレッド + スレッド内エラー * アトミック操作+ CAS* 排他制御（ロック） * セマフォ * コンディションヴァリアル * バリア * キュー* メールボックス* ゲート* frlock=== # アトミック操作 === # アトミック操作 ---------------- 複雑な動作は同じデータに並行に動かすと壊れうる ``` [var = 1] [incf] | [decf] [1][1] [2]---[var = 2] | | | [var = 0]+---+ go | | V V ``` === # frlock -------- * Fast Read Lock * またの名をRead-Write Lock * Read Lockは多重に取れる。Write Lockは1つしか取れない。 * 基本操作は`frlock-read`と`frlock-write` * 普通のlockと違って複数のReadが速くなる === # まとめ -------- * SBCLのマルチスレッドサポートはbordeaux-threadsよりもリッチ * 処理系の独自サポート面白い * 処理系に依存してしまってもいいんじゃないだろうか   ","categories":["Lisp","Common Lisp","SBCL","Common Lisp処理系拡張"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/sbcl","/categories/common-lisp%e5%87%a6%e7%90%86%e7%b3%bb%e6%8b%a1%e5%bc%b5"],"date":"2015-06-20","title":"Common Lisp処理系拡張の探求 SBCLのマルチスレッドサポート","url":"https://KeenS.github.io/slide/common_lispshorikeikakuchounotankyuu_sbclnomaruchisureddosapo_to/"},
  {"body":"κeenです。LLで書かれた動作のもっさりしてるコマンドラインツールよりシェルスクリプトが好きです。\nしかしシェルスクリプトを書く時にはハマり所も多いです。ということでハマりそうなところと対処法を共有しますね。\n1. 変数は基本クォート 変数には空白が入り得ます（特にパス名とか）。あるいは空である可能性もあります。\nmv file1 file2 $target_dir で$target_dirが空だった時は\nmv file1 file2 となってしまいます。file2が上書きされますね。恐ろしい。\nクォートで括っておけば\nmv file1 file2 \u0026#34;$target_dir\u0026#34;mv file1 file2 \u0026#34;\u0026#34; となり辺なディレクトリに書き込もうとしてエラーになります。まだマシですね。\n基本、と書いたのはクォートしたくない場合もあるからです。例えばこんな時ですね。\nitems=\u0026#34;foo bar baz\u0026#34; for item in $items do echo \u0026#34;$item\u0026#34; done 変数展開の後にトークン分割が行なわれるので空白で区切れば複数のトークンを1つの変数に入れられます。\n2. -eオプションをつけよう シェルには例外がありません。何かが失敗しても走り続けます。これは時に迷惑な挙動です。しかし -eオプションをつけると0以外の終了ステータスが出た瞬間スクリプトが止まるようになります。\n-eオプションを有効にするには\n#!/bin/sh set -e とすれば良いです。0以外のステータスで終了し得るコマンドの例外ハンドル的なことをしたければ\ntrying_command || true とすれば確実に0で終了します。\nまた、スクリプトの途中で-eを切り替えたければ\n#!/bin/sh set -e # -eが有効 set +e # -eが無効 set -e # -eが有効 のようにset -eとset +eで制御出来ます。\n3. カレントディレクトリはスクリプトを起動した場所 例えば ~/Shell/hoge.shにこう書いたとします。\n#!/bin/sh cat ./hoge.sh pwd それを実行するとこうなります\n$ cd ~/Shell $ sh hoge.sh #!/bin/sh cat ./hoge.sh pwd /home/kim/Shell $ cd ../ $ sh Shell/hoge.sh hoge.sh: no such file or directory /home/kim なのでシェルスクリプト内での相対パスは基本的に信用出来ません。\nスクリプトの相対でパスを指定したいならこうしましょう。\n#!/bin/sh ROOT=\u0026#34;$(cd $(dirname $0); pwd)\u0026#34; cat \u0026#34;$ROOT/hoge.sh\u0026#34; pwd $(cd $(dirname $0); pwd) がキモです。 $0には起動スクリプトが入ってます。 $ ./hoge.shと起動したなら ./hoge.shが、 $ ../hoge.sh なら ../hoge.shが。そのスクリプトがあるディレクトリに移動(cd $(dirname $0)) してpwdするとスクリプトのあるディレクトリの絶対パスがとれます。\n因みにこのイディオムはスクリプトにリンクを張られると困ります。 readlink(1) を使う流儀もあるのですがreadlinkがMacとLinuxで全然違い、互換性を保てないのでおすすめしません。\n4. sudo command \u0026gt;\u0026gt; fileでパーミッションエラー \u0026gt;\u0026gt; (\u0026gt;) を使った時にファイルに書き込んでるのは commandではなくてシェルなのでシェルのアクセス権限でパーミッションエラーが出ます。sudoして書き込みたいなら\nsudo command \u0026gt; file ではなく\n$ command | sudo tee file を、\nsudo command \u0026gt;\u0026gt; file ではなく\n$ command | sudo tee -a file を使いましょう。\n関連して、echoは外部コマンドではなくシェルの組込みコマンドなのでsudoに渡すことが出来ません。これもファイルに書き込む目的ならechoとsudo teeをパイプで繋ぎましょう。\n5. sudoのパスワードを渡せない スクリプト内でsudoを扱うのは少しテクニックが必要になります。sudoに-Sを付けると標準入力からパスワードを読むようになります。かといってソースにベタ書きする訳にはいきません。 ということで、こうなります。\nprintf \u0026#34;password: \u0026#34; read password echo \u0026#34;$password\u0026#34; | sudo -S command ユーザにパスワードを要求し、メモリに保存。必要な時にsudoに渡すという流れです。\nシェルに依ってはreadに-sをつけることでエコーバックしなくなるのでディスプレイにパスワードが流れてくることはありません。未確認ですがdash(Debian系の/bin/sh)では出来なくてB shell(BSD系の/bin/sh)やBash、Zshなどの拡張POSIXシェルだと出来そうです。\n余談ですが改行なしの印字にecho -nは使えません。-n シェルによってはオプションを認識しないので。printf(1)はPOSIXにあるのでポータブルに使えます。\n因みにパスワードが初期化されてないならユーザに訊く、というのはこういう関数を実装すれば良さそうです。\npassword(){ if ! ${password+:} false then printf \u0026#34;password: \u0026#34; read -s password fi } 6. sudoのパスワードを渡しつつ標準出力も渡したい { echo \u0026#34;$password\u0026#34; ; cat } | sudo -S command しましょう。\n7. リモートでスクリプトを実行したい 一旦scpでスクリプトを送ってから実行？そんな面倒なことしたくありません。\nssh user@remote \u0026lt;\u0026lt;SHELL # some script SHELL で実行出来ます。これはログインシェルで実行します。ログインシェル如何に関わらずshで実行したいなら(ログインシェルがcshとかnologinとかは割とありえる)\nssh user@remote sh \u0026lt;\u0026lt;SHELL # some script SHELL としましょう。\n8. リモートでsudoのパスワードを渡したい 先のテクニックがそのまま使えます。\nprintf \u0026#34;password: \u0026#34; read password ssh user@remote sh \u0026lt;\u0026lt;SHELL echo \u0026#34;$password\u0026#34; | sudo -S command SHELL クォート無しのヒアドキュメントのシェル変数の展開はローカルで行なわれるのでローカルにある変数がそのまま参照出来ます。\n9. リモートにローカルに置いてあるファイルを送りたい scpでも良いですがroot loginを許可してないと設定ファイルを/etcに置けないなどと不都合が生じます。\nssh user@remote sh \u0026lt;\u0026lt;SHELL cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026gt;\u0026gt; some_remote_file $(cat local_file) EOF SHELL これは少し解説が必要でしょうか。\nまず、先程も出てきた\nssh user@remote sh \u0026lt;\u0026lt;SHELL SHELL ですが普通のヒアドキュメントなので中の変数やコマンド置換を展開します。ということでリモートで実行されるのは\ncat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026gt;\u0026gt; some_remote_file # the content of # local_file EOF となります。そしてcatのヒアドキュメントはクォート付きなのでlocal_fileの中身がさらに変数展開されることはありません。\n勿論、root権限で書き込みたかったら先程までのテクニックを組み合わせて\nssh user@remote sh \u0026lt;\u0026lt;SHELL { echo \u0026#34;$password\u0026#34; ; cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; } | sudo -S tee some_remote_file $(cat local_file) EOF SHELL として下さい.\n10. リモートにあるファイルを編集したい sed(1)を使いましょう。あるいは、sedだと辛いならローカルでファイルを編集、diffをとってpatch(1)を使いましょう。diffの送り方はもう分かりますね。\nssh user@remote sh \u0026lt;\u0026lt;SHELL cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; | patch $(cat file.diff) EOF SHELL です。\nいかがでしょうか。テクニックさえ抑えればシェルスクリプトは料理人だか板前だか知りませんが流行に流されるツールにも負けない力があると思います。動作も速い。 みなさんシェルスクリプト書きましょうね。\n","categories":["Shell Script"],"category_urls":["/categories/shell-script"],"date":"2015-06-17","title":"Shell Scriptを書くときのテクニック10選","url":"https://KeenS.github.io/blog/2015/06/17/shell_scriptwokakutokinikiwotsuketaikoto/"},
  {"body":"κeenです。人々にRustを薦めておきながら本人は昨日ようやく入門しました。その時に困ったことをメモ。タイトルがルー語になってますが気にしない。\n因みにこれはRust 1.0の情報です。\n導入 Rustを知らない人のために説明すると、Rustの値はデフォルトでイミュータブルです。デフォルトで、というのはもちろんミュータブルにすることも出来ます。 標準ライブラリにも値がイミュータブルであることを要求するものもあります。 そしてミュータビリティはmutとして型にも現れます。厳密に同じかは知りませんがconstの逆、と思えばいいでしょう。\nstruct Point{x: isize,y: isize }fn double(p: \u0026amp;mutPoint){p.x=p.x*2;p.y=p.y*2;}fn main(){letmutp1=Point{x: 1,y: 2};letp2=Point{x: 1,y: 2};double(\u0026amp;mutp1);double(\u0026amp;mutp2);// error! p2 is immutable } イミュータビリティは継承します。親のstructがイミュータブルなら子もイミュータルになります。因みにフィールドにmutを指定することは出来ないようです。\nusestd::collections::HashMap;struct IntHashMap{hash: HashMap\u0026lt;isize,isize\u0026gt;}fn main(){leth=IntHashMap{hash: HashMap::new()};h.hash.insert(1,2);// error! h.hash is immutable } 最後に、少し本筋とずれますがtraitについて。他の言語でいうインターフェースのようなものです。今回これで困ったので。\n例えばHTTPライブラリのhyperでは次のようなトレイトを実装しているstructをrequest handlerとして登録できます。\npubtraitHandler: Sync +Send{fn handle\u0026lt;\u0026#39;a,\u0026#39;k\u0026gt;(\u0026amp;\u0026#39;aself,Request\u0026lt;\u0026#39;a,\u0026#39;k\u0026gt;,Response\u0026lt;\u0026#39;a,Fresh\u0026gt;);fn check_continue(\u0026amp;self,_: (\u0026amp;Method,\u0026amp;RequestUri,\u0026amp;Headers))-\u0026gt; StatusCode{...}} これを見て下さい。\nfn handle\u0026lt;\u0026#39;a,\u0026#39;k\u0026gt;(\u0026amp;\u0026#39;aself,Request\u0026lt;\u0026#39;a,\u0026#39;k\u0026gt;,Response\u0026lt;\u0026#39;a,Fresh\u0026gt;); selfにmutがついてませんね。つまりhandlerはイミュータブルな値として渡されます。例えば先の例のようにフィールドにハッシュマップを持っていても更新出来ません。ちょっと困りますね。\nCell/RefCell ということでフィールドにミュータビリティを入れるのが std::cell::{Cell, RefCell} です。この辺のブログを参考に。\n#rustlang における構造体のmutabilityとCell/RefCell - snyk_s log\nで、喜び勇んで使ったのですが次なるエラーが。\nstruct MyHandler{cache: RefCell\u0026lt;HashMap\u0026lt;String,Vec\u0026lt;u8\u0026gt;\u0026gt;\u0026gt;}implHandlerforMyHandler{fn handle\u0026lt;\u0026#39;a,\u0026#39;k\u0026gt;(\u0026amp;\u0026#39;aself,Request\u0026lt;\u0026#39;a,\u0026#39;k\u0026gt;,Response\u0026lt;\u0026#39;a,Fresh\u0026gt;){....}}the trait `core::marker::Sync` is not implemented for the type `core::cell::UnsafeCell\u0026lt;... どうも、hyperは複数スレッドでも動かせるのでハンドラにスレッドセーフであることが要求されるようです。そしてRustコンパイラはRefCellがスレッドセーフでない事を知っているのでコンパイルを弾きます。怖いですね。\nMutex 無理っぽいので最早別の手段を捜し始めます。\nキャッシュ用のアクター走らせるのが良い気がしてきた\n\u0026mdash; κeen (@blackenedgold) 2015, 6月 12 \nこれはちょっと無理がありそうですね。\nしかし、別の方法があるようでした。std::sync::Mutexです。\nstruct MyHandler{cache: Mutex\u0026lt;HashMap\u0026lt;String,Vec\u0026lt;u8\u0026gt;\u0026gt;\u0026gt;} こんな感じでlock().unwrap()するだけで使えます。\nletmutcache=self.cache.lock().unwrap(); 因みにロックの解除は不要です。Rustコンパイラは値の生存期間を知っているので値がこれ以上使われなくなった箇所にコンパイラがunlockを挟みます。(正確に言うとdrop(デストラクタ)が挿入され、dropがリソースの開放を行なう)\nまとめ  rustのイミュータビリティは継承する structのfieldに直接mutは指定出来ない シングルスレッドでミュータブルなフィールドが欲しいならCell/RefCell マルチスレッドならMutex ","categories":["Rust","Rust1.0"],"category_urls":["/categories/rust","/categories/rust1.0"],"date":"2015-06-14","title":"Rustでstructのmutableなfieldあれこれ","url":"https://KeenS.github.io/blog/2015/06/14/rustdestructnomutablenafieldarekore/"},
  {"body":"κeenです。先日OpenCV 3.0がリリースされましたね。 ちょっと触ってみようと思ったのですが公式バインディングがC++、C、Java、Pythonと中々つらい言語ばっかりなので扱いやすいClojureから触った時のメモです。\n2系とはAPIが変わってる部分もあるらしく、苦労しました。 UbuntuでやってるのでMacの人は適当に読み替えて下さい。\n準備 OpenCV 公式からOpenCV 3.0をダウンロードしてきましょう。展開してからは\n$ cd opencv-3.0.0 $ cmake . $ make -j4 $ sudo make -j4 install でインストールまでしてくれます。\nImShow どうも3.0からHighguiというQtベースのGUIツール群のJavaバインディングが作られなくなったそうです。Swing使えと。\nということでOpenCVとSwingのブリッジしてくれる軽いライブラリがImShow-Java-OpenCV です。.javaファイル1枚なので本当に軽いです。\n.jarもレポジトリに入ってるのですがソースコードより古いらしく、自分でビルドする必要があります。\n$ git clone git@github.com:master-atul/ImShow-Java-OpenCV.git $ cd ImShow-Java-OpenCV/ImShow_JCV/src $ javac com/atul/JavaOpenCV/Imshow.java $ jar -cf Imshow.jar com/atul/JavaOpenCV/Imshow.class lein プロジェクト Clojureのプロジェクト管理ツールのLeiningenを使います。知らない人は適当にググって下さい。\nまずプロジェクトを作ります。\n$ lein new opencv-play んで、mavenでいうところのpom.xmlにあたるproject.cljをいじります。\n$ cd opencv-play $ cat project.clj (defproject opencv-play \u0026#34;0.1.0-SNAPSHOT\u0026#34; :description \u0026#34;FIXME: write description\u0026#34; :url \u0026#34;http://example.com/FIXME\u0026#34; :license {:name \u0026#34;Eclipse Public License\u0026#34; :url \u0026#34;http://www.eclipse.org/legal/epl-v10.html\u0026#34;} :dependencies [[org.clojure/clojure \u0026#34;1.6.0\u0026#34;]]) $ edit project.clj $ cat project.clj (defproject opencv-play \u0026#34;0.1.0-SNAPSHOT\u0026#34; :description \u0026#34;FIXME: write description\u0026#34; :url \u0026#34;http://example.com/FIXME\u0026#34; :license {:name \u0026#34;Eclipse Public License\u0026#34; :url \u0026#34;http://www.eclipse.org/legal/epl-v10.html\u0026#34;} :dependencies [[org.clojure/clojure \u0026#34;1.6.0\u0026#34;] [cider/cider-nrepl \u0026#34;0.9.0-SNAPSHOT\u0026#34;]] :jvm-opts [\u0026#34;-Djava.library.path=./lib\u0026#34;] :resource-paths [\u0026#34;./lib/opencv-300.jar\u0026#34; \u0026#34;./lib/Imshow.jar\u0026#34;] :injections [(clojure.lang.RT/loadLibrary org.opencv.core.Core/NATIVE_LIBRARY_NAME)]) そしたら先程のライブラリ達を配置します。\n$ mkdir lib $ cp /usr/local/share/OpenCV/java/* lib $ cp /path/to/ImShow-Java-OpenCV/ImShow_JCV/src/Imshow.jar lib ついでにlenaも呼びましょう。\n$ mkdir img $ cp /path/to/src/of/opencv-3.0.0/samples/data/lena.jpg img 遊ぶ 準備完了ってことでREPLを起動しましょう。ちょっと遅いですが我慢。\n$ lein repl Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar nREPL server started on port 52301 on host 127.0.0.1 - nrepl://127.0.0.1:52301 REPL-y 0.3.5, nREPL 0.2.6 Clojure 1.6.0 Java HotSpot(TM) 64-Bit Server VM 1.8.0_25-b17 Docs: (doc function-name-here) (find-doc \u0026#34;part-of-name-here\u0026#34;) Source: (source function-name-here) Javadoc: (javadoc java-object-or-class-here) Exit: Control+D or (exit) or (quit) Results: Stored in vars *1, *2, *3, an exception in *e user=\u0026gt;  このままREPLを使ってもいいですが私はEmacsからCIDERでnREPLにつなぎます。 REPLでも補完は効くのでEmacsやらのエディタの設定が面倒ならこのままでも十分ですよ。\nまずは画像のロードから。2系とは違ってImagecodecを使うようです。\nuser\u0026gt; (import [org.opencv.imgcodecs Imgcodecs]) org.opencv.imgcodecs.Imgcodecs user\u0026gt; (def lena (Imgcodecs/imread \u0026#34;img/lena.jpg\u0026#34;)) #\u0026#39;user/lena いじる前に表示してみましょう。\nuser\u0026gt; (import [com.atul.JavaOpenCV Imshow]) com.atul.JavaOpenCV.Imshow user\u0026gt; (def is (Imshow. \u0026#34;Lena\u0026#34;)) #\u0026#39;user/is user\u0026gt; (.showImage is lena) nil よしよし。表示されましたね。ではこの辺を参考に顔認識してみましょう。\nClojure - 二次元絵の顔を検出する - Qiita\nまずは必要なパッケージの読み込み\nuser\u0026gt; (import [org.opencv.core Mat CvType]) org.opencv.core.CvType user\u0026gt; (import [org.opencv.imgproc Imgproc]) org.opencv.imgproc.Imgproc 前処理のグレースケール変換からヒストグラムの均一化まで一気にやってしまいましょう。\nuser\u0026gt; (def buffer (Mat. 512 512 CvType/CV_8UC3)) #\u0026#39;user/buffer user\u0026gt; (Imgproc/cvtColor lena buffer Imgproc/COLOR_RGB2GRAY) nil user\u0026gt; (Imgproc/equalizeHist buffer buffer) nil ここで一旦画像の確認。\nuser\u0026gt; (.showImage is buffer) nil ふむふむ。ではでは顔を認識しますか。\nまずは色々準備します。\nuser\u0026gt; (import [org.opencv.core MatOfRect]) org.opencv.core.MatOfRect user\u0026gt; (import [org.opencv.objdetect CascadeClassifier]) org.opencv.objdetect.CascadeClassifier user\u0026gt; (def faces (MatOfRect.)) #\u0026#39;user/faces user\u0026gt; (def classifier (CascadeClassifier.)) #\u0026#39;user/classifier user\u0026gt; (.load classifier \u0026#34;/usr/local/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml\u0026#34;) true 因みに分類器のデータのロードは成功がtrueで失敗がfalseだそうです。例外投げないんですね。ハマった。パス名に~を使うと(ホームを省略表記すると)ロードに失敗するようなのでお気をつけて。\nそれでは実行。\nuser\u0026gt; (.detectMultiScale classifier buffer faces) nil さて、顔の位置がとれたので画像に重ねるのですがここではSwing(AWT)の描画を使ってみましょう。 OpenCVの描画は画像に描画するのでファイルに書き出しても残っているのに対してSwingのだと表示しているフレームに描画するので書き出した画像には残りません。また、リフレッシュすれば消えるのでインタラクティブに実験するのに向いてます。\n一旦準備。フレームをレナの元画像に戻しておきましょう。\nuser\u0026gt; (import [java.awt Rectangle Color]) java.awt.Color user\u0026gt; (.showImage is lena) nil ImshowのWndowというパブリックなメンバにJFrameが入ってるのでそれを操作します。\nuser\u0026gt; (def g2 (.getGraphics (.Window is))) #\u0026#39;user/g2 user\u0026gt; (.setColor g2 Color/GREEN) nil user\u0026gt; (doseq [face (.toList faces)] (let [rect (Rectangle.)] (do (.setRect rect (.width face) (.height face) (.x face) (.y face)) (.draw g2 rect)))) nil はい。\nパチパチパチ\n因みに四角形を消すには\nuser\u0026gt; (.showImage is lena) nil で十分です。ミスっても何回でもやり直せますね。\nまとめ 因みに3.0のドキュメントが探しづらいのですが、masterにあるようです。\nOpenCV: OpenCV\nOpenCVをインタラクティブに扱えると楽しいのでみなさんClojure使いましょう。\n","categories":["Lisp","Clojure","OpenCV"],"category_urls":["/categories/lisp","/categories/clojure","/categories/opencv"],"date":"2015-06-07","title":"ClojureでOpenCV 3.0と戯れる","url":"https://KeenS.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru/"},
  {"body":"# ボトルネックのイイ話 ---------------------- サイバーエージェント15新卒 FRESH勉強会 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 渋谷のエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # ボトルネック -------------  ボトルネック (bottleneck) とは、システム設計上の制約の概念。英語の「瓶の首」の意。一部（主に化学分野）においては律速（りっそく、「速さ」を「律する（制御する）」要素を示すために使われる）、また『隘路（あいろ）』と言う同意語も存在する。 === # Webアプリの主な登場人物 ------------------------ * リバースプロキシ * アプリケーションサーバ * データベース === ![relation of reverse proxy, app and DB](/images/webapp.png) === # レスポンスタイムとスループット ------------------------------ * レスポンスタイム + リクエストを投げてレスポンスが返ってくるまでの時間 + ユーザから見たメトリクス * スループット+ 一定時間内にシステムがどれだけのリクエストを捌けるか + 中の人から見たメトリクス === # スループット ------------- * スループットの最大 ≒ リソースの限界 + ネットワーク帯域 + ディスクIO + メモリ使用量 + CPU負荷 * リソースのどれか1つでも限界になったらそれ以上パフォーマンスは上がらない === # パフォマンスの目安 ------------------- * ネットワーク帯域: bpsで表わす。NICによるが 1Gbpsとか * CPU: パーセンテージで表わす。100xコア数が最大マシンに依る。 * メモリ: Bで表わす。ピンキリだが1GB ~ 128GBくらい？ * ディスクIO: Bpsで表わす。HDDなら 100Bpsとか。SSDなら10倍くらい。 テキトーに調べたので間違ってるかも === # 誰が何を --------- * リバースプロキシ: ネットワーク、メモリ、CPUなど * アプリケーションサーバl: CPU、メモリなど * データベース: CPU、ディスクIOなど === 「CPUは100%に行ってないのにアプリケーションが遅いんだよ」 === # 誤り ------ * ボトルネックはCPUとは限らない * 他のメトリクスも一緒に見るべき === # 推測するな。計測せよ --------------------- * 実際に測ってみないとどこがボトルネックか分からない * 何をしてどれくらいパフォーマンスが上がったのかも分からない + コストパフォーマンスも重要 === 「パフォーマンスが悪いからCPUをグレードアップしよう」 === # 誤り ------ * ボトルネックはCPUとは限らない * 例えばネットワーク帯域が詰まっているのにCPUを改善しても意味がない * 帯域が詰まってるならデータを減らす、NIC（マシン）を増やすなどをする === 「多分アプリケーションを高速化したよ」 === # 誤り ------ * 計測せずに高速化しても意味がない + テストの無いリファクタリングがただの破壊なのと同じ * 高速化した気になって実際はコードが汚なくなっただけの可能性もある === # ボトルネックは変わりうる ------------------------ * 一箇所をずっと改善してても意味がない * ある程度改善したら次のリソースの限界がきてるかもしれない === 「アプリケーションを10倍高速化したのにあんまり速くなってない」 === # 誤り ------ * 10倍くらい極端に高速化すると次のリソースがボトルネックになる * ディスクやネットワークの改善を考えるべき === # リソースの食い合い ------------------- * 1マシンで完結している場合、リソースの食い合いが発生しうる + リバースプロキシとアプリケーションがCPUを食い合うとか * この時、どのようにして解決するのが適切か？ === # 例題 ------ * アプリが80%くらいの負荷 * Rプロキシが20%くらいの負荷 === # 例題 ------ 1. アプリが多くCPUを喰ってるからアプリを高速化すべき 2. アプリが多くCPUを必要としてるからRプロキシはアプリにCPUを譲るべき === # 例題 ------ 1. アプリが多くCPUを喰ってるからアプリを高速化すべき 2. アプリが多くCPUを必要としてるからRプロキシはアプリにCPUを譲るべき === # アムダールの法則 ----------------- * [アムダールの法則 - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%A0%E3%83%80%E3%83%BC%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87) * ざっくり言うと比率の小さな部分を高速化しても全体の高速化は高が知れてる === 「ORマッパ使うと遅そうだから生のSQL使おう」 === # 誤り ------ * ORマッピングにかかるコストは微小 * 他にもっと効率的に改善出来る部分に手をつけるべき === # リソースの配分 --------------- * 逆に、与えられたリソースからどれをどこに割り当てるかの問題もある * 理論的には負荷の高い部分に多くリソースを割り当てれば良い。 * しかしアプリケーションの構成を先に決めないといけないので事前に計測は出来ない + 知識と経験と勘 === # 例題 ------ * 画像配信アプリケーション * VPS5台 + ネット1Mbps/メモリ1G/CPU4コア/HDD * Rプロキシ、アプリ、DBにそれぞれ何台割り当てる？ + 1つのマシンに複数機能を持たせても良い。 === # チューニングは難しい --------------------- * 様々な部分の知識が必要 * システム全体を見渡した設計力も大事 * 細かなチューニングテクニックも一杯 + 今回話してないが、キャッシュ戦略とかも + Cache-Control * 知識がないと計測しても数値の意味が分からない === 「やった。5%高速化した」 === # 誤り ------ * パフォーマンスは計測の度にゆらぎがある * 5%くらいなら普通に測定誤差の範囲内 * 逆に、5%くらいの改善をしても意味がない === # チューニングは楽しい --------------------- * パズルゲームみたいな部分もある * チューニング次第でスループット何十倍とかいく * 難しい分一気にパフォーマンスが上がると喜びも一入 === # ISUCON === # ISUCON -------- * [ISUCON公式Blog](http://isucon.net/) * Webアプリケーションチューニングコンテスト * 優勝賞金100万円 * 何でもアリ。どこをいじってもいい。 * 要はさっきの知識をフルで活用出来る === # ISUCON -------- * 何でもアリは実は珍しい。 + 他はデータベースのみ、とかアプリは触っちゃだめ、とか雁字搦め * 前回は185組（1チーム2~3人）の大きな大会 + 予選で27チームに絞られる * 界隈の有名人が揃う天下一武闘会の様相 * 楽しい === # 良質な問題 ----------- * 過去問は教育的な問題が多数。 * 過去問は全て公開。 * 腕試しに丁度良い。 === # 今年のISUCON -------------- * 予選 9/26,27 * 本戦 10/31 * 2~3人のチーム * Google Cloud Platform * 出題は[@tagomoris](https://twitter.com/tagomoris)さんと[@kamipo](https://twitter.com/kamipo)さん === Let's ISUCON === # 参考 ------ * [ISUCONで学ぶ Webアプケーションのパフォーマンス向上のコツ 実践編 完全版](http://www.slideshare.net/kazeburo/isucon-summerclass2014action2final) * [ISUCONの話(夏期講習2014)](http://www.slideshare.net/tagomoris/isucon2014) * [kamipoさんはすごい人](https://twitter.com/search?q=kamipo%E3%81%95%E3%82%93%E3%81%AF%E3%81%99%E3%81%94%E3%81%84%E4%BA%BA\u0026src=typd\u0026vertical=default\u0026f=tweets)   ","categories":["ISUCON","FRESH勉強会"],"category_urls":["/categories/isucon","/categories/fresh%e5%8b%89%e5%bc%b7%e4%bc%9a"],"date":"2015-06-04","title":"ボトルネックのイイ話","url":"https://KeenS.github.io/slide/botorunekkunoiihanashi/"},
  {"body":"# Transducerについて ---------------------- サイバーエージェント 朝の3分スピーチ === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 渋谷のエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # Transducerって？ ------------------ * Clojure 1.7で入るフレームワーク * 関数のパイプライン化を簡単にする * 入力、出力には依存しない === # Reduce関数について ------------------- * `reduce: ('a - 'b - 'a) 'a - 'b list` * `('a - 'b - 'a)` でシーケンスを集約する * `(reduce + 0 '(1 2 3)) ;= 6` * 要はreduceは関数を使って集約する。 === # Transducerについて ------------------- * `transduce:(('a - 'b - 'a) - ('a - 'b - 'a)) ('a - 'b - 'a) 'a - 'b list` * 集約関数を変換する関数もとる * `(transduce xf + 0 '(1 2 3))` * transducerで集約する前に処理を挟める === # すごいところ ------------------------- ## コンポーサビリティ * `(('a - 'b - 'a) - ('a - 'b - 'a))` * 変換関数は入力と出力が同じ。 * つまり変換関数を合成出来る * ex) `(comp (filter odd?) (map inc))` === # すごいところ2 -------------------------- ## 汎用性 * 各関数は入力や出力について知る必要はない + シーケンスではなく要素に対して定義される * シーケンスだけでなく遅延シーケンス、ストリーム、チャネルなどなどにも使える * 中間シーケンスを作らない + 遅延シーケンスやストリームには大きなメリット * 集約先をシーケンスなどにすることも出来る + 関数の汎用性が上がる === # すごいところ3 -------------- ## 並列/非同期 * core.asyncもtransducerをサポート * 各変換関数を並列/非同期に実行が可能 * さらに各関数に割り当てるプロセッサの数も細かく制御出来る === 変換して === 集約する === 何かに似てない？ === MapReduce === @oza_x86 ozaさんの近しい環境というとHadoop...多段Mapreduceをtransdecerみたいにしようってはなしとかですか？\n\u0026mdash; κeen (@blackenedgold) 2015, 6月 1 === @blackenedgold まさにその通りです．MapReduce には Combiner という中間集約をする API があるのですが，それをもっと汎用的にしようという話です． http://t.co/injEiPjePG\n\u0026mdash; oza (@oza_x86) 2015, 6月 1 === @oza_x86 すごい楽しそうですね。Clojure向けのAPIがtransducerのバッグエンドになって普段書いてるコードがそのままHadoopで動いたりしたら、とか夢が無限に広がります\n\u0026mdash; κeen (@blackenedgold) 2015, 6月 1 === @blackenedgold おお，その案は良いですね！！\n\u0026mdash; oza (@oza_x86) 2015, 6月 1 === Clojure 1.7 + Transducer === Comming Soon === # 参考 ------ * [Clojure 1.7のtransducersを動かしてみよう - Qiita](http://qiita.com/tokomakoma123/items/1ca3fb0dddc5b901b032) * [core.async+transducers Shibuya.lisp #21](http://www.slideshare.net/ktsujister/coreasynctransducers-shibuyalisp-21) * [Hadoop Combinerメモ(Hishidama's Hadoop Combiner Memo)](http://www.ne.jp/asahi/hishidama/home/tech/apache/hadoop/Combiner.html)   ","categories":["Clojure","Lisp","transducer"],"category_urls":["/categories/clojure","/categories/lisp","/categories/transducer"],"date":"2015-06-03","title":"Transducerについて","url":"https://KeenS.github.io/slide/transducernitsuite/"},
  {"body":"κeenです。先日のエントリーの最後でループ内で例外ハンドルをすると極端に遅くなるということを書きましたが、それについて。\nループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。\n\u0026mdash; κeen (@blackenedgold) 2015, 5月 29 @blackenedgold うーん、ちょっと例外のことは詳しくないんですが、予想だと例外ハンドラをループ内にいれると毎回スタックに積むんで外す操作がはさまることになるのでレジスタで完結してるようなループ処理だと露骨に遅くなるかもしれません\n\u0026mdash; Ocamlアイドル (@no_maddo) 2015, 5月 30 @blackenedgold あーありえますね。ジャンプで済むところを戻ってきてスタックに積んだのを除去しないといけませんからね。ちょっと手元にマシンが無いのですがネイティブコードで実験してみますー\n\u0026mdash; Ocamlアイドル (@no_maddo) 2015, 5月 30 @blackenedgold ocamlでも例外ハンドラのはさみ方で末尾再帰になったり、ならなかったりするというのは聞いたことがあるので多分あたりな気がします\n\u0026mdash; Ocamlアイドル (@no_maddo) 2015, 5月 30 \nということで実験してみましょう。\n次のような何がしたいのか分からないループのベンチマークを取ってみます。\nval () = let val arr = Array.array(1000000, 0) val i = ref 0 fun loop () = ( Array.update(arr, !i, 1); i := (!i) + 1; loop () ) in Benchmark.benchmark \u0026#34;loop\u0026#34; 1 (fn () =\u0026gt; loop() ) end 結果は無限ループではなく\nuncaught exception: Subscript と、境界外アクセスの例外が出ます。因みにSubscripは添字って意味だそうです。\nこれではベンチマークがとれないので、例外が起きたらループを抜けるようにしてみましょう。\nval () = let val arr = Array.array(1000000, 0) val i = ref 0 fun loop () = ( Array.update(arr, !i, 1); i := (!i) + 1; loop () ) in Benchmark.benchmark \u0026#34;loop\u0026#34; 1 (fn () =\u0026gt; loop() handle Subscript =\u0026gt; () ) endloop Time: [Total] 5 ms/1calls [Average] 5.0 ms/call 一瞬ですね。では、末尾呼び出し位置でhandleしてみます。\nval () = let val arr = Array.array(100, 0) val i = ref 0 fun loop () = ( Array.update(arr, !i, 1); i := (!i) + 1; loop () handle Subscript =\u0026gt; () ) in Benchmark.benchmark \u0026#34;loop\u0026#34; 1 (fn () =\u0026gt; loop() ) endloop Time: [Total] 1729 ms/1calls [Average] 1729.0 ms/call ふーむ。やはり大分遅くなってますね。しかしループ内で例外をハンドルした所為かもしれないのでループ内で非末尾位置で例外をハンドルしてみます。大域脱出に例外使いますがまあ、パフォーマンスに問題ないでしょう。\nexception Exit val () = let val arr = Array.array(1000000, 0) val i = ref 0 fun loop () = ( Array.update(arr, !i, 1) handle Subscript =\u0026gt; raise Exit; i := (!i) + 1; loop () ) in Benchmark.benchmark \u0026#34;loop\u0026#34; 1 (fn () =\u0026gt; loop() handle Exit =\u0026gt; () ) endloop Time: [Total] 11 ms/1calls [Average] 11.0 ms/call やはり多少は遅くなってますが末尾位置の時のように極端には遅くなってないようです。\n最後に非末尾再帰ループの速度を測っておきましょう。\nval () = let val arr = Array.array(1000000, 0) val i = ref 0 fun loop () = ( Array.update(arr, !i, 1); i := (!i) + 1; 1 + (loop ()) ) in Benchmark.benchmark \u0026#34;loop\u0026#34; 1 (fn () =\u0026gt; loop() handle Subscript =\u0026gt; 0 ) endloop Time: [Total] 403 ms/1calls [Average] 403.0 ms/call 思ったより遅いですね。ループか末尾例外ハンドルかというと末尾例外ハンドルに近いスコア。\n考察 末尾位置で例外をハンドルすると遅くなる原因はTCOが効かないから、で合ってそうです。\nしかしそれにしても遅いですね。例外ハンドラをスタックに積むのが1関数呼び出しくらいならせいぜい倍くらいの遅さで済む筈です。 もしかしたらループ展開とかの外の最適化も掛からなくなるのかもしれません。\n結論 例外をハンドルする時は位置に気をつけましょうね。\n付録A ベンチマーカはこんなコードです。\nstructure Benchmark = struct fun repeat 0 f = () | repeat n f = (f ();repeat (n - 1) f) fun bench n f = let val startTime = Time.now () val _ = repeat n f val endTime = Time.now () in Time.toMilliseconds (Time.-(endTime, startTime)) end fun benchmark name n f = let val time = bench n f in print (name ^ \u0026#34;\\n\u0026#34;); print (\u0026#34; Time:\\n\u0026#34;); print (\u0026#34; [Total] \u0026#34; ^ (LargeInt.toString time) ^ \u0026#34; ms/\u0026#34; ^ (Int.toString n) ^ \u0026#34;calls\\n\u0026#34;); print (\u0026#34; [Average] \u0026#34; ^ (Real.toString((Real.fromLargeInt time) / (Real.fromInt n))) ^ \u0026#34; ms/call\\n\u0026#34;) end fun nChars n char = CharArray.vector(CharArray.array(n, char)) fun toWidth width str = let val len = String.size str in if len \u0026lt; width then str ^ (nChars (width - len) #\u0026#34; \u0026#34;) else str end fun histLine width base value = (nChars (Int.fromLarge(width * value div base)) #\u0026#34;*\u0026#34;) ^ \u0026#34;\\n\u0026#34; fun benchset name n fs = let val res = List.map (fn (label, f) =\u0026gt; (label, bench n f)) fs val max = List.foldl (fn ((_, time), m) =\u0026gt; LargeInt.max(time, m)) 0 res val maxLen = List.foldl (fn ((label, _), m) =\u0026gt; Int.max(String.size label, m)) 0 fs in print \u0026#34;name:\\n\u0026#34;; print ((nChars ((String.size \u0026#34; \u0026#34;) + maxLen) #\u0026#34;-\u0026#34;) ^ \u0026#34;+\u0026#34; ^ (nChars ((String.size \u0026#34;|\u0026#34;) + 50) #\u0026#34;-\u0026#34;) ^ \u0026#34;\\n\u0026#34;); app (fn (label, time) =\u0026gt; print(\u0026#34; \u0026#34; ^ (toWidth maxLen label) ^ \u0026#34;|\u0026#34; ^(histLine (50:LargeInt.int) max time))) res; print ((nChars ((String.size \u0026#34; \u0026#34;) + maxLen) #\u0026#34;-\u0026#34;) ^ \u0026#34;+\u0026#34; ^ (nChars ((String.size \u0026#34;|\u0026#34;) + 50) #\u0026#34;-\u0026#34;) ^ \u0026#34;\\n\u0026#34;) end end 付録B 元々、なんでこの問題が生じたかというと一々境界チェックして配列にアクセスするより例外出させといた方が速いんじゃね？ってことでそういうコードを書いたからです。 例外が出るってことは内部でも境界チェックしてる筈ですから。\nということでどちらが速いか確認してみましょう。\nまず例外ハンドル方式。先程のままだと数ミリ秒で終わってたので配列の大きさを10倍しました。あと。実際に書きそうな書き方に変えました。\nval () = let val len = 10000000 val arr = Array.array(len, 0) fun loop i = ( Array.update(arr, i, 1); loop (i + 1) ) in Benchmark.benchmark \u0026#34;loop\u0026#34; 1 (fn () =\u0026gt; loop 0 handle Subscript =\u0026gt; () ) endloop Time: [Total] 48 ms/1calls [Average] 48.0 ms/call まあ、こんなもんですね。\n次にifで分岐するやりかた。\nval () = let val len = 10000000 val arr = Array.array(len, 0) fun loop i = if i \u0026lt; len then ( Array.update(arr, i, 1); loop (i + 1)) else () in Benchmark.benchmark \u0026#34;loop\u0026#34; 1 (fn () =\u0026gt; loop 0 handle Subscript =\u0026gt; () ) endloop Time: [Total] 96 ms/1calls [Average] 96.0 ms/call 倍くらい遅くなってますね。\nということでみだりに境界チェックするより例外を出させといた方が速いようです。\n","categories":["言語実装","SML"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85","/categories/sml"],"date":"2015-05-31","title":"TCOと例外ハンドル","url":"https://KeenS.github.io/blog/2015/05/31/tcotoreigaihandoru/"},
  {"body":"こんにちは。κeenです。このブログでちょくちょく出てくるDirect Threaded VMについて。 SMLのようにgotoがない言語だとDT VMの実装出来ないよなー、と思ってた所、ふとアイディアが浮かんだのでそれについて。\n序論 DSL、例えば正規表現などの処理系を実装することを考えてみて下さい。\n言語処理系において最も素朴な実装はインタプリタですが、速度面で不利なので一旦仮想命令にコンパイルして仮想命令実行器(VM)で実行することが一般的です。 コンパイラのように複雑な記号処理をするプログラムはCommon LispやMLのような記号処理に強い高級言語が得意とする分野です。 一方、ランタイムには低レベルなことが出来て処理速度の速いCommon LispやCを使いたくなるでしょう。\nCommon Lisp以外の言語ではコンパイラとランタイムを分離するのが妥当な選択肢のようですが、高級言語とcの間のブッジングが必要になり、少なからぬコストを支払う必要があります。 また、ffiを持たない言語ではブリッジ出来ないのでランタイムもその言語で実装する必要があります。つまり、高級言語でVMを実装する必要があるケースが存在します。\nVMの実行を高速化する技術の一つとしてDirect Threadingというものがあります。 命令ディスパッチのループを短絡することで余計なオーバーヘッドが減り、また、命令毎にジャンプ命令を持つことで分岐予測も効きやすくなるのでVMが高速化します。 しかしDTの実装にはgotoのラベルを第一級オブジェクトとして保存する必要があり、gccやclangのように拡張されたcコンパイラなど、限られた言語でしか実現出来ません。まあ、Common Lispならevalとcompileを使えばJITが出来るので不要ですが。\nそこで、gotoのない言語でDirect Threadingを実現してみたいと思います。\nDirect Threading Direct Threaded でない VMは大抵次のような構造をしています。\nloop { op = fetchNextOp switch(op) { case op1: .... break case op2: .... break .... } } つまり、\n 次の命令を取得する 命令でディスパッチする 命令に対応するコードを実行する ディスパッチを抜ける 1.に戻る  という動きをします。自然に思えるかもしれませんが、\n 命令のディスパッチはlogオーダの時間が掛かる（可能性がある）。 4. 5. のステップが不要 2. で毎回違う命令にディスパッチするので分岐予測がほぼ意味を成さない  という無駄があります。それを改良したのがDirect Threaded VMで、オペコードではなくgotoのラベルを使うことで\nlabel = fetchNextLabel goto label label1: ... label = fetchNextLabel goto label label2: ... label = fetchNextLabel goto label ...  次のラベルを取得する ラベルにgotoする 命令に対応するコードを実行する 次のラベルを取得する ラベルにgotoする(次の処理は3. 相当)  と、ループ内の2ステップを飛ばした他、ディスパッチもなくなるので高速になります。 また、ラベル毎にgotoがついていて、それぞれのgotoに分岐予測があるので普通のVMに比べて分岐予測がある程度効きます。\n第一級ラベルを持たない言語におけるDirect Threaded VM 結論から言うと関数の配列を使います。ラベルの代わりに配列のインデックス、gotoの代わりに配列へのアクセスとcallを使います。 ランダムアクセスでアドレスの取得をするために配列を、任意コードへのジャンプのために関数を使えばエミュレート出来るよねって発想です。\n実装 ソースコード全体はGithuに上げてます。SML/NJで動きます。SML#向けのインターフェースファイルを書いていますが何故かコンパイルが通りません。\n次のようなASTを実行するインタプリタ、VM、Direct Threaded VMを実装しました。但し、VMとDTVMはクロージャをサポートしていません。\ndatatype monoop = Not datatype binop = Equal | GreaterThan | Add datatype t = Int of int | Bool of bool | MonoOp of monoop * t | BinOp of binop * t * t | Bind of t * t | If of t * t * t | Var of string | Lambda of t list * t | Call of t * t list | Progn of t list インタプリタはこのASTを解釈実行、VMはいくつかの中間表現を経てオペコードにコンパイルし、それを実行します。尚、最適化は行いません。\nVMのディスパッチ部分は次のような実装になっています。\nfun aux () = ( case (Array.sub(ops, !pc)) of O.Not =\u0026gt; (case pop vm of V.Bool x =\u0026gt; push vm (V.Bool (not x)) | _ =\u0026gt; raise Type) | O.Add =\u0026gt; (case (pop vm, pop vm) of (V.Int x, V.Int y) =\u0026gt; push vm (V.Int (x + y)) | _ =\u0026gt; raise Type) | O.Eq =\u0026gt; (case (pop vm, pop vm) of (V.Int x, V.Int y) =\u0026gt; push vm (V.Bool (x = y)) | (V.Bool x, V.Bool y) =\u0026gt; push vm (V.Bool (x = y)) | _ =\u0026gt; raise Type) | O.Gt =\u0026gt; (case (pop vm, pop vm) of (V.Int x, V.Int y) =\u0026gt; push vm (V.Bool (x \u0026lt; y)) | _ =\u0026gt; raise Type) | O.Jump label =\u0026gt; pc := (label - 1) | O.Jtrue label =\u0026gt; (case pop vm of V.Bool true =\u0026gt; pc := (label - 1) | V.Bool false =\u0026gt; () | _ =\u0026gt; raise Type) | O.Call i =\u0026gt; (case (pop vm) of V.Lambda label =\u0026gt; ( pushCi vm; fp := (!fp) - i; pc := (label - 1)) | _ =\u0026gt; raise Type) | O.Ret =\u0026gt; (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1)); popCi vm; pc := (!pc)) | O.Push v =\u0026gt; push vm v | O.Pop =\u0026gt; (pop vm;()) | O.Lref i =\u0026gt; push vm (Array.sub(stack, (!fp) + i)) | O.Lset i =\u0026gt; ((Array.update(stack, (!fp) + i, pop vm)); push vm (V.Bool true)) | O.Gref i =\u0026gt; push vm (Array.sub(pool, i)) | O.Gset i =\u0026gt; (Array.update(pool, i, pop vm); push vm (V.Bool true)) | O.Nop =\u0026gt; () | O.End =\u0026gt; raise Exit ; pc := (!pc) + 1; aux ()) DT VMではこれを次のように書き換えました。\nfun next () = let val () = pc := (!pc) + 1; val (index, arg) = Array.sub(cops, !pc) in Array.sub(opArray, index) arg end Array.fromList [ (* Not *) fn _ =\u0026gt; (case pop vm of V.Bool x =\u0026gt; push vm (V.Bool (not x)) | _ =\u0026gt; raise Type; next ()), (* Add *) fn _ =\u0026gt; (case (pop vm, pop vm) of (V.Int x, V.Int y) =\u0026gt; push vm (V.Int (x + y)) | _ =\u0026gt; raise Type; next ()), (* Eq *) fn _ =\u0026gt; (case (pop vm, pop vm) of (V.Int x, V.Int y) =\u0026gt; push vm (V.Bool (x = y)) | (V.Bool x, V.Bool y) =\u0026gt; push vm (V.Bool (x = y)) | _ =\u0026gt; raise Type; next ()), (* Gt *) fn _ =\u0026gt; (case (pop vm, pop vm) of (V.Int x, V.Int y) =\u0026gt; push vm (V.Bool (x \u0026lt; y)) | _ =\u0026gt; raise Type; next ()), (* Jump *) fn ({int = label, ...}: oparg) =\u0026gt; (pc := (label - 1); next ()), (* Jtrue *) fn ({int = label, ...}: oparg) =\u0026gt; (case pop vm of V.Bool true =\u0026gt; pc := (label - 1) | V.Bool false =\u0026gt; () | _ =\u0026gt; raise Type; next ()), (* Call *) fn ({int = i, ...}: oparg) =\u0026gt; (case (pop vm) of V.Lambda label =\u0026gt; ( pushCi vm; fp := (!fp) - i; pc := (label - 1)) | _ =\u0026gt; raise Type; next ()), (* Ret *) fn _ =\u0026gt; (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1)); popCi vm; pc := (!pc); next ()), (* Push *) fn ({vmvalue = v, ...}: oparg) =\u0026gt; (push vm v; next ()), (* Pop *) fn _ =\u0026gt; (pop vm; next ()), (* Lref *) fn ({int = i, ...}: oparg) =\u0026gt; (push vm (Array.sub(stack, (!fp) + i)); next ()), (* Lset *) fn ({int = i, ...}: oparg) =\u0026gt; ((Array.update(stack, (!fp) + i, pop vm)); push vm (V.Bool true); next ()), (* Gref *) fn ({int = i, ...}: oparg) =\u0026gt; (push vm (Array.sub(pool, i)); next ()), (* Gset *) fn ({int = i, ...}: oparg) =\u0026gt; (Array.update(pool, i, pop vm); push vm (V.Bool true); next ()), (* Nop *) (fn _ =\u0026gt; next ()), (fn _ =\u0026gt; raise Exit) ] fun aux () = let val (index, arg) = Array.sub(cops, !pc) in Array.sub(opArray, index) arg end 1引数を受け取ってunitを返す関数の配列としてVMを表しています。 1つ注意点として、前処理としてタグ付き共用体として表されている命令をタグ(配列のインデックス)と共用体に分解するのですが、SMLに共用体はないので構造体で代用しています。 oparg 型がそれにあたります。\nディスパッチを関数nextに括り出していて、一見すると分岐予測に関する利点が失われるように思われますが、 nextは小さいのでインライン化されるだろうと踏んでそのままにしています。実際、手動でインライン化しても速度に変化はありませんでした。\n今回のメインの話はVMなのでインタプリタについては省略します。\n実行速度 予測 普通のVMはディスパッチをlogオーダーの時間で行ないますがDT VMは定数オーダーの時間で行ないます。しかし配列の参照と関数呼び出しを挟むので定数倍の部分は大きくなります。 どちらが速いでしょうか。\n計測 今回、次のようなフィボナッチ数列を計算するコードの実行速度を計測しました。\nfun fib n = (Progn [ Bind (Var \u0026#34;fib\u0026#34;, Lambda([Var \u0026#34;n\u0026#34;], (If (BinOp(GreaterThan, (Int 2), (Var \u0026#34;n\u0026#34;)), Int(1), BinOp(Add, Call(Var \u0026#34;fib\u0026#34;, [BinOp(Add, Var \u0026#34;n\u0026#34;, Int ~1)]), Call(Var \u0026#34;fib\u0026#34;, [BinOp(Add, Var \u0026#34;n\u0026#34;, Int ~2)])))))), Call(Var \u0026#34;fib\u0026#34;, [Int n])]) コンパイラは以下のような命令列を吐きます。命令の内部表現が違うだけで命令列自体はVMとDTVMで共通です。 繰り返しますが、最適化はしてないのでL25で次の命令にジャンプしてるだとか目に見えて無駄なコードもあります。\n0\tPush Lambda 7 1\tGset 0 2\tPop 3\tPush 35 4\tGref 0 5\tCall 1 6\tEnd 7\tPush 2 8\tLref 0 9\tGt 10\tJtrue 12 11\tJump 14 12\tPush 1 13\tJump 26 14\tLref 0 15\tPush ~1 16\tAdd 17\tGref 0 18\tCall 1 19\tLref 0 20\tPush ~2 21\tAdd 22\tGref 0 23\tCall 1 24\tAdd 25\tJump 26 26\tRet 計測には次のようなコードを使いました。コンパイラは実行効率を無視して書いたのでベンチマークには含めていません。\nval target = (AST.fib 35) val compiled = VM.compile target val dtcompiled = DTVM.compile target val vm = VM.new () val dtvm = DTVM.new () val _ = Benchmark.benchset \u0026#34;fib 35\u0026#34; 1 [ (\u0026#34;Interpreter\u0026#34;, fn () =\u0026gt; (Interp.run target; ())), (\u0026#34;Normal VM\u0026#34;, fn () =\u0026gt; (VM.run vm compiled; ())), (\u0026#34;Direct Threaded VM\u0026#34;, fn () =\u0026gt; (DTVM.run dtvm dtcompiled; ())) ] 結果 Intel Core i5 M450 2.4GHz 2コア4スレッド、Ubunt 15.04、SML/NJ v110.77で実行しました。\n-------------------+--------------------------------------------------- Interpreter |********************************************* 47170ms Normal VM |****************** 19170ms Direct Threaded VM|************************************************** 51460ms -------------------+--------------------------------------------------- ダントツで速いのがVMで、インタプリタに比べてかなりの性能向上が見られます。一方DT VMはインタプリタより遅いという結果になりました。\n考察 冷静に考えたらインタプリタは毎回関数呼び出して遅いよねってことからループで処理を済ませるのがVMなのにVMで毎回関数を呼び出してたら遅いに決まってるじゃん。 というかこれ、Direct Threaded VMじゃないじゃん。死にたい。\n余談 ループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。\n\u0026mdash; κeen (@blackenedgold) 2015, 5月 29 \n尚、このつぶやきはfibの引数を小さくして繰り返しを増やした時のものです。多分コンパイルを外に出してるので繰り返しが多いとその分のオーバーヘッドの差が効いてくるのでしょう。\nval target = (AST.fib 24) val compiled = VM.compile target val dtcompiled = DTVM.compile target val vm = VM.new () val dtvm = DTVM.new () val _ = Benchmark.benchset \u0026#34;fib 24\u0026#34; 10 [ (\u0026#34;Interpreter\u0026#34;, fn () =\u0026gt; (Interp.run target; ())), (\u0026#34;Normal VM\u0026#34;, fn () =\u0026gt; (VM.run vm compiled; ())), (\u0026#34;Direct Threaded VM\u0026#34;, fn () =\u0026gt; (DTVM.run dtvm dtcompiled; ())) ]-------------------+--------------------------------------------------- Interpreter |************************************************** 2052ms Normal VM |** 104ms Direct Threaded VM|***** 238ms -------------------+---------------------------------------------------","categories":["ML","SML","言語実装"],"category_urls":["/categories/ml","/categories/sml","/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2015-05-29","title":"第一級ラベルを持たない言語におけるDirect Threaded VMの実装","url":"https://KeenS.github.io/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou/"},
  {"body":"κeenです。Rubyでも使われてる高速な正規表現エンジン、Onigmo(鬼雲)を高速化したのでその話を。\n先日、正規表現技術入門を読んだというエントリの中で\n ところで本に載ってた鬼雲のコードはDT(編注: Direct Threaded)にしてなかったけど簡単のためなのかな？あるいは厳格にC89に準拠するため？picrinみたくプリプロセッサで分岐すれば使えるのに。\n と書いたところ、鬼雲の作者、K.Takataさんから\n@k_takata 「picrinみたくプリプロセッサで分岐すれば使えるのに。」これも知らなかった。\n\u0026mdash; K.Takata (@k_takata) 2015, 5月 11 \nという反応を頂きました。そしてイシューにも乗ったので言い出しっぺとして実装してみました。こちらのプルリクです。\nDirect Threaded VM自体の解説はRubyist Magazineに載っている笹田さんのものが詳しいようです Rubyist Magazine - YARV Maniacs 【第 3 回】 命令ディスパッチの高速化\n実装は少し技巧的ですがwhile, switch, case, break, continueなどをマクロでラップしつつDT VMが有効ならそれらと互換性のあるDT用のコード（gotoやラベル）に展開します。元はpicrinで使われていたテクニックです。 このコードは @wasabizが書いたものなのでpicrinがどこを参考にして書かれたかは@wasabizに聞いて下さい。もしかしたらわさびずの発明かもしれませんね。\nで、パフォーマンスの方ですが、最初、素直に制御命令を1つづつマクロで書き換えたのですが、こうなりました。\nmaster\n パターン時間 Twain47 ms ^Twain47 ms Twain$47 ms Huck[a-zA-Z]+|Finn[a-zA-Z]+127 ms a[^x]{20}b1172 ms Tom|Sawyer|Huckleberry|Finn151 ms .{0,3}(Tom|Sawyer|Huckleberry|Finn)497 ms [a-zA-Z]+ing4032 ms ^[a-zA-Z]{0,4}ing[^a-zA-Z]96 ms [a-zA-Z]+ing$4175 ms ^[a-zA-Z ]{5,}$1770 ms ^.{16,20}$1757 ms ([a-f](.[d-m].){0,2}[h-n]){2}1849 ms ([A-Za-z]awyer|[A-Za-z]inn)[^a-zA-Z]656 ms \"[^\"]{0,30}[?!\\.]\"115 ms Tom.{10,25}river|river.{10,25}Tom260 ms  DT版\n パターン時間 Twain100 ms ^Twain99 ms Twain$100 ms Huck[a-zA-Z]+|Finn[a-zA-Z]+246 ms a[^x]{20}b2182 ms Tom|Sawyer|Huckleberry|Finn288 ms .{0,3}(Tom|Sawyer|Huckleberry|Finn)847 ms [a-zA-Z]+ing6278 ms ^[a-zA-Z]{0,4}ing[^a-zA-Z]203 ms [a-zA-Z]+ing$6430 ms ^[a-zA-Z ]{5,}$3603 ms ^.{16,20}$3596 ms ([a-f](.[d-m].){0,2}[h-n]){2}3239 ms ([A-Za-z]awyer|[A-Za-z]inn)[^a-zA-Z]1039 ms \"[^\"]{0,30}[?!\\.]\"327 ms Tom.{10,25}river|river.{10,25}Tom487 ms  はい。DT版の方が2倍ちょっと遅いです。そりゃないわー。最適化オプションとかも確認したのですがダメでした。\n諦めて布団に入った後、ふと思い当たる節がありました。\n元のコードで\ncase OP_XXX: ... continue; break; というパターンが割と現れます。continueの後のbreakは本来なら不要ですがcaseを書く際の作法というか癖というか とにかくbreakを付けるスタイルもあります。これもそうなのでしょう。こいつらをマクロで書き換える時に愚直に\nCASE(OP_XXX) ... JUMP; NEXT; としてました。ここで、\n#if USE_DIRECT_THREADED_VM #define NEXT sprev = sbegin; JUMP #define JUMP goto *oplabels[*p++] #else #define NEXT break #define JUMP continue #endif です。これはUSE_DIRECT_THREADED_VMが定義されてる時は\nL_OP_XXX: ... goto *oplabels[*p++]; sprev = sbegin;goto *oplabels[*p++]; と展開され、gotoが2つ現れることになります。どうせ無用コードだし最適化で消えるだろと思ってたらそうでもないらしく、\nCASE(OP_XXX) ... JUMP; NEXT; を\nCASE(OP_XXX) ... JUMP; にし、マクロの方も\n#if USE_DIRECT_THREADED_VM #define NEXT sprev = sbegin; JUMP #define JUMP goto *oplabels[*p++] #else #define NEXT break #define JUMP continue; break #endif としたらようやく本領発揮してくれました。その結果がこれです。\n MasterThis PRImprove Rate Twain47 ms47 ms0% ^Twain47 ms47 ms0% Twain$47 ms47 ms0% Huck[a-zA-Z]+|Finn[a-zA-Z]+127 ms127 ms0% a[^x]{20}b1172 ms889 ms31% Tom|Sawyer|Huckleberry|Finn151 ms153 ms-1% .{0,3}(Tom|Sawyer|Huckleberry|Finn)497 ms449 ms10% [a-zA-Z]+ing4032 ms2705 ms49% ^[a-zA-Z]{0,4}ing[^a-zA-Z]96 ms98 ms-2% [a-zA-Z]+ing$4175 ms2797 ms49% ^[a-zA-Z ]{5,}$1770 ms1623 ms9% ^.{16,20}$1757 ms1637 ms7% ([a-f](.[d-m].){0,2}[h-n]){2}1849 ms1670 ms11% ([A-Za-z]awyer|[A-Za-z]inn)[^a-zA-Z]656 ms607 ms8% \"[^\"]{0,30}[?!\\.]\"115 ms93 ms24% Tom.{10,25}river|river.{10,25}Tom260 ms262 ms-1%  a[^x]{20}bや[a-zA-Z]+ingのようにバックトラックが何度も起きてVMループをヘビーに回すパターンでは効果覿面のようで、最大49%の高速化です。素晴しいですね。\n因みに2つめのgotoは実際には実行されないのに何故遅くなったかというとgotoはコンパイラにとってはコントロールフログラフを乱す厄介な奴なので 無用コード除去に引っ掛からなかったどころか最適化ルーチンを引っ掻き回したんじゃないかと思います。\nこのコード、私の手元の環境でしかテストしてないのでC89なら須くサポートするOnigmoにマージされるかは分かりませんがマージされると嬉しいですね。\n","categories":["正規表現"],"category_urls":["/categories/%e6%ad%a3%e8%a6%8f%e8%a1%a8%e7%8f%be"],"date":"2015-05-26","title":"Onigmoを最大49%高速化した話","url":"https://KeenS.github.io/blog/2015/05/26/onigmowosaidai49_kousokukashitahanashi/"},
  {"body":"κeenです。かねてより気になっていた幽霊型(Phantom Type)について知ったのでアウトプット。 このPDFがベースになって ます。\n余談ですが英語がファントム・タイプと中々中二な名前なので和訳も幻影型とかそういう方向に走って欲かったな。\n「幽霊型」で調べると真っ先にこのサイトが出てくるのですが、ミスリーディングと言われていました。 別に間違ったことを書いている訳ではないのですが、幽霊型の応用例なのでこれこそが幽霊型だと思ってしまうと少し視野が狭くなってしまうようです。\nモチベーション ブーリアンと整数と条件分岐と足し算と比較が出来るミニ言語を考えてみます。自動で型変換は行わない(つまりintとboolの比較などは出来ない)言語とします。こんな感じでしょうか。\ndatatype exp = Int of int | Bool of bool | If of exp * exp * exp | Plus of exp * exp | Equal of exp * exp fun mkInt x = Int x fun mkBool x = Bool x fun mkIf cnd thn els = If(cnd, thn, els) fun mkPlus x y = Plus(x, y) fun mkEqual x y = Equal(x, y) exception Type fun evalIf cnd thn els = case eval cnd of Bool x =\u0026gt; if x then eval thn else eval els | _ =\u0026gt; raise Type fun evalPlus x y = case (eval x, eval y) of (Int x\u0026#39;, Int y\u0026#39;) =\u0026gt; Int(x\u0026#39; + y\u0026#39;) | _ =\u0026gt; raise Type fun evalEqual x y = case (eval x, eval y) of (Int x\u0026#39;, Int y\u0026#39;) =\u0026gt; Bool(x\u0026#39; = y\u0026#39;) | (Bool x\u0026#39;, Bool y\u0026#39;) =\u0026gt; Bool(x\u0026#39; = y\u0026#39;) | _ =\u0026gt; raise Type fun eval exp = case exp of If(cnd, thn, els) =\u0026gt; evalIf cnd thn els | Plus(x, y) =\u0026gt; evalPlus x y | Equal(x, y) =\u0026gt; evalEqual x y | e =\u0026gt; e さて、この定義に従うと次のような自明に間違ったプログラムもコンパイルを通ってしまいます1。\nmkEqual (mkInt 1) (mkBool false) 勿論、評価するとエラーになります。\neval (mkEqual (mkInt 1) (mkBool false)); uncaught exception Type こういうものを極力コンパイル時に発見出来ないかとうのがモチベーションです。因みにこのモチベーションは変な型変換を行わない言語なら動的型付き言語でも同じで、SBCLで(+ 1 t)を評価するとちゃんとコンパイルエラーになります。\n問題の分析 今回、IntだとかBoolだとかの型情報をタグ、つまり値として持たせました。しかしコンパイル時に値にはアクセス出来ません。コンパイル時にアクセスできるのは型です。ということでメタデータとして型を付与しましょう。\n幽霊型 メタデータとして型を付けたのが幽霊型です。名前的に'a texpではなく'aの部分が幽霊型なんですかね。\n使い方は割と分かりやすくて、datatypeに余計な型をつけます。この'aは使われていませんがメタデータなのでそういうもんです。\ndatatype \u0026#39;a texp = E of exp 次に、mkXxx にも型を付けます。\nまず、mkIntなら返り値はIntなので'aの部分にその情報を詰め込みます。今回はintが宜しいようです。 毎回Eがつくのが面倒ですが我慢して下さい。\nfun mkInt x: int texp = E (Int x) mkBoolも同じです。\nfun mkBool x: bool texp = E (Bool x) 次はmkIfですが、condにはBool型、thenとelseには同じ型が来て欲しいです。そして返り値というかこのIfを evalした型はthenやelseと同じ型なのでこのような型になります。Ifに渡す為に一旦Eを剥がしてます。\nfun mkIf (E cnd: \u0026#39;b texp) (E thn: \u0026#39;a texp) (E els: \u0026#39;a texp): \u0026#39;a texp = E (If(cnd, thn, els)) 同じように考えたらmkPlusやmkEqualも型付け出来ます。\nfun mkPlus (E x: int texp) (E y: int texp): int texp = E (Plus(x, y)) fun mkEqual (E x: \u0026#39;a texp) (E y: \u0026#39;a texp): bool texp = E (Equal(x, y)) これ以後は変更ありません。一応修正後のプログラムを載せると、\ndatatype exp = Int of int | Bool of bool | If of exp * exp * exp | Plus of exp * exp | Equal of exp * exp datatype \u0026#39;a texp = E of exp fun mkInt x: int texp = E (Int x) fun mkBool x: bool texp = E (Bool x) fun mkIf (E cnd: \u0026#39;b texp) (E thn: \u0026#39;a texp) (E els: \u0026#39;a texp): \u0026#39;a texp = E (If(cnd, thn, els)) fun mkPlus (E x: int texp) (E y: int texp): int texp = E (Plus(x, y)) fun mkEqual (E x: \u0026#39;a texp) (E y: \u0026#39;a texp): bool texp = E (Equal(x, y)) exception Type fun evalIf cnd thn els = case eval\u0026#39; cnd of Bool x =\u0026gt; if x then eval\u0026#39; thn else eval\u0026#39; els | _ =\u0026gt; raise Type and evalPlus x y = case (eval\u0026#39; x, eval\u0026#39; y) of (Int x\u0026#39;, Int y\u0026#39;) =\u0026gt; Int(x\u0026#39; + y\u0026#39;) | _ =\u0026gt; raise Type and evalEqual x y = case (eval\u0026#39; x, eval\u0026#39; y) of (Int x\u0026#39;, Int y\u0026#39;) =\u0026gt; Bool(x\u0026#39; = y\u0026#39;) | (Bool x\u0026#39;, Bool y\u0026#39;) =\u0026gt; Bool(x\u0026#39; = y\u0026#39;) | _ =\u0026gt; raise Type and eval\u0026#39; exp = case exp of If(cnd, thn, els) =\u0026gt; evalIf cnd thn els | Plus(x, y) =\u0026gt; evalPlus x y | Equal(x, y) =\u0026gt; evalEqual x y | e =\u0026gt; e fun eval (E x) = eval\u0026#39; x となります。ユーザインターフェースレベルでの変更はありません。 さて、ということで先の式をもう一度評価してみましょう。\nmkEqual (mkInt 1) (mkBool false); stdIn:1.2-1.34 Error: operator and operand don\u0026#39;t agree [tycon mismatch] operator domain: int texp operand: bool texp in expression: (mkEqual (mkInt 1)) (mkBool false) ちゃんとエラーが出ました。楽しいですね。\n発展1 - 任意の型 任意の型を作る手段としてタグ1つ、引数無しのタグ付き共用体を使う方法があります。それを使った技が先のPDFに載ってます。\ndatatype tcp = TCP datatype udp = UDP datatype \u0026#39;a safe_socket = W of Word32.word fun mkTCP .... fun mkUDP .... fun sendTCP ... fun sendUPD ... fun close ... のように型安全に、そしてcloseのように可能なものはジェネリックにプログラムを書くことが出来ます。\n発展2 - サブタイプ 次のようにヒエラルキーがある場合の話です。面倒なので言語を縮小しますね。\ndatatype num = Int of int | Real of real datatype exp = Num of num | Bool of bool | Plus of exp * exp この場合、こうなります。\ndatatype num = Int of int | Real of real datatype exp = Num of num | Bool of bool | Plus of exp * exp datatype \u0026#39;a tnum = N datatype \u0026#39;a texp = E of exp exception Type fun mkInt x: (int tnum texp) = E (Num (Int x)) fun mkReal x: (real tnum texp) = E (Num (Real x)) fun mkBool x: (bool texp) = E (Bool x) fun mkPlus (E x: \u0026#39;a tnum texp) (E y: \u0026#39;a tnum texp): \u0026#39;a tnum texp = case (x, y) of (Num (Int x\u0026#39;), Num (Int y\u0026#39;)) =\u0026gt; E (Num (Int (x\u0026#39; + y\u0026#39;))) | (Num (Real x\u0026#39;), Num (Real y\u0026#39;)) =\u0026gt; E (Num (Real (x\u0026#39; + y\u0026#39;))) | _ =\u0026gt; raise Type  疲れてきたので説明省略しますが型パラメータを入れ子にしたら上手い具合にサブタイプの親子関係を表せるよねって話です。\nまとめ 幽霊型を使うと値レベルの話を一部型レベルに持ち上げれる（ってことで良いのかな？）\n最後に どうしても\ndatatype \u0026#39;a texp = E of exp としている所のEが気になりますね。型システム上必要っぽい(type 'a texp = expとしてもダメだった)ので必要なコストだとは思うのですが 少くとも内部的にはゼロオーバーヘッドであって欲しいです。最適化で消せそうですが実際に消してる処理系はどれほどあるのでしょう。\ntype 'a texp = expでダメだった(型がミスマッチしてるのにコンパイルが通ってしまった)のも気になります。smlのtypeってただのエイリアスなんでしたっけ？\n若干のモヤモヤは残るものの一応幽霊型について知りました。\n 因みにこのコードをSML#のREPLで評価すると返ってこなくなります。イシューに上がってます。 [return]  ","categories":["型","幽霊型"],"category_urls":["/categories/%e5%9e%8b","/categories/%e5%b9%bd%e9%9c%8a%e5%9e%8b"],"date":"2015-05-24","title":"幽霊型を知った","url":"https://KeenS.github.io/blog/2015/05/24/yuureikatawoshitta/"},
  {"body":"# 21世紀のエンジニアのためのHTTP/2入門 ---------------------- サイバーエージェントFresh勉強会 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 渋谷のエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # HTTPについて ------------- * 1990年誕生の骨董仕様 * Human Readableなテキストベース * パフォーマンスはあまり考慮してない === # HTTP/1.1の限界 --------------- * フォーマットがゆるふわでパースしづらい * 何度も似たようなヘッダをる + 割とネットワーク負荷が高い * 基本1コネクションにつき1ファイルの送受信 + 短命なコネクションをいくつも張ることになる + コネクションが\"ウォームアップ\"する前に切れる * Head of Line Blocking + 遅いコンテンツをダウンロードしてると他のコンテンツがダウンロード出来なくなる === ``` GET / HTTP/1.1 Host: localhost:8080 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: ja Accept-Encoding: gzip, deflate Cookie: _ga=GA1.1.1989570020.1429589222; __utma=111872281.1989570020.1429589222.1430193585.1431477266.5; __utmz=111872281.1429589222.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmc=111872281 Connection: keep-alive Cache-Control: max-age=0 ``` === ``` GET /js/todo.js HTTP/1.1 Host: localhost:8080 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0 Accept: */* Accept-Language: ja Accept-Encoding: gzip, deflate Referer: http://localhost:8080/ Cookie: _ga=GA1.1.1989570020.1429589222; __utma=111872281.1989570020.1429589222.1430193585.1431477266.5; __utmz=111872281.1429589222.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmc=111872281 Connection: keep-alive Cache-Control: max-age=0 ``` === ``` GET /style/main.css HTTP/1.1 Host: localhost:8080 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0 Accept: text/css,*/*;q=0.1 Accept-Language: ja Accept-Encoding: gzip, deflate Referer: http://localhost:8080/ Cookie: _ga=GA1.1.1989570020.1429589222; __utma=111872281.1989570020.1429589222.1430193585.1431477266.5; __utmz=111872281.1429589222.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmc=111872281 Connection: keep-alive Cache-Control: max-age=0 ``` === # 涙ぐましい努力 -------------- 何度もリクエストをしないためにファイル数を減らす様々な努力がされてきた * css/js concatenation + cssやjsを1つのファイルにまとめてアクセスを減らす * image inlining + 画像をBase64エンコードしてCSS内に埋め込む * image sprite + 複数の画像を1まとめにして表示する時に切り出して使う * 並列アクセス + ブラウザは最大6並列でサーバにアクセスする === # HTTP/2 === # HTTP/2 -------- * 2015-05-15(先週の金曜)に[RFC化](http://jxck.hatenablog.com/entry/http2-rfc7540) * HTTP/1.1に限界を感じたGoogleによって作られたSPDYがベース + 現実の問題を解決している + 新しいがある程度の信頼性もある * これから広まっていく === # HTTP/2の特徴 ------------- * 接続開始はHTTP/1.1のUpgradeを使う。 + HTTP/1.1と共存可能 * バイナリベースになってパースが楽に * セマンティクスはHTTP/1.xのものを保持 * ヘッタの圧縮も行なう([HPACK](http://http2.github.io/http2-spec/compression.html#indexing.tables)) * プロキシやリバースプロキシの存在も織り込んだ仕様(Hop by Hop) * その他拡張も多数 CF [HTTP/2の現状とこれから](http://www.slideshare.net/shigeki_ohtsu/http2-ohtsu-html5conf2015) === ## セマンティクスの保持 -------------------- * HTTP/2 - HTTP/1.xへの変換が可能 * つまり、(リバース)プロキシの内側は1.x、外側は2が可能 + アプリケーションはいじらずにフロント側が対応すればすぐに使える CF [nghttpx](http://qiita.com/tatsuhiro-t/items/99a2fd61d0fb16d7241b) === ## セマンティクスの保持 -------------------- こういうことが可能 ``` +------+ +-------+ +---+ |Client|-[HTTP/2]-|R.Proxy|-[HTTP/1.1]-|App| +------+ +-------+ +---+ ``` === ## HPACK -------- * よく使うヘッダは数値で表わす + Static Table * 以前送ったヘッダも数値で表わせる + Dynamic Table * それ以外もハフマン符号で圧縮可能 === # HTTP/2の新機能 --------------- * ストリーム * フロー制御 * サーバープッシュ === # ストリーム ------------ * ストリームは論理的なもの * 1つのコネクション内で複数のストリームを作れる + 1コネクション内で複数のファイルをやりとり出来る + さらに、1コネクション内で並列に複数のファイルをやりとり出来る * 短命なコネクションをいくつも張るよりずっと効率的 + コネクションの性能をほぼフルで使い切れるようになった === # フロー制御 ------------ スライド略。 [HTTP2 のフロー制御 - Qiita](http://qiita.com/Jxck_/items/622162ad8bcb69fa043d) 具体的な状況はいくつか考えられます。   * 大きなファイルの通信が帯域を食いつぶし、他の通信を妨害する。  * あるリクエストの処理にサーバがかかりっきりになり、他のリクエストをサーバが処理してくれなくなる。  * 高速なアップロードを行うクライアントと、低速な書き込みをしているサーバとの間に挟まったプロキシが、調整のためにデータを貯めているバッファが溢れる。 === # プライオーリティ制御 --------------------- * ストリームの存在が念頭にある * 複数のストリームの内どれを優先させるかを決める + CSSは描画に必要だから優先度高、画像は後で良いから優先度低など * ブラウザが要求する時に指定出来るし、サーバが指定することも出来る CF [HTTP2 のプライオリティ制御 - Qiita](http://qiita.com/Jxck_/items/16a5a9e9983e9ea1129f) === # サーバープッシュ ---------------- * サーバが自発的にコンテンツを送れる + 今までは必ずクライアントがリクエストを送らないとレスポンスが返せなかった * サーバがコンテンツの内容を分かってるなら先にコンテンツを送ることが可能 + 例えばHTMLを生成する前に静的コンテンツを送ればレンダリング完了までの時間が速くなる * いわゆるPush通知が可能 + 今まではCommetやWebsocketなどで対応していた CF [Service WorkerとHTTP/2が切り開く新しいWeb Pushの世界](http://d.hatena.ne.jp/jovi0608/20141204/1417697480) === # Availability -------------- ## ブラウザ * Firefox 34以降（現38） * Google Chrome 31以降 (現42) * Opera * IE 11 on Windows10 === # Availability -------------- ## Servers [Implementations · http2/http2-spec Wiki](https://github.com/http2/http2-spec/wiki/Implementations) より抜粋。 ![available servers according to http2 wiki](/images/http2_availability.png) === # Availability -------------- ## Servers * Nginxを始めとして多くのサーバがHTTP/2を実装している + H2OのようにHTTP/2を念頭に置いて書かれたものもある * アプリケーションサーバはそんなに多くない + 多分Rackなどの統一サーバインターフェースの問題 === # Availability -------------- 少くともこういうことをすれば利用出来る ``` +--------+ +---------+ +-----+ | |-[HTTP/2]---| | | | | Client | | R.Proxy |-[HTTP/1.1]-| App | | |-[HTTP/1.1]-| | | | +--------+ +---------+ +-----+ ``` === # まとめ -------- * HTTP/2について紹介した * HTTP/2は現状の問題を解決する + サーバ/クライアント共に幸せになれる * HTTP/2には段階的に移行出来る + 普及はかなり速いかもしれない * みなさんが配属された時はHTTP/2の存在を前提としてアプリを設計しましょう   ","categories":["HTTP","Web","FRESH勉強会"],"category_urls":["/categories/http","/categories/web","/categories/fresh%e5%8b%89%e5%bc%b7%e4%bc%9a"],"date":"2015-05-18","title":"21世紀のエンジニアのためのHTTP/2入門","url":"https://KeenS.github.io/slide/21seikinoenjinianotamenohttp_2nyuumon/"},
  {"body":"# 実装から理解するクロージャ ---------------------- === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 渋谷のエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # クロージャとは？ ----------------- * 日本語にすると（関数）閉包 * 関数が外側のローカル変数を補足する * 補足されたローカル変数は無限の生存期間を持つ + ローカル変数は本来スコープを抜けると生存期間が終わる + 言い換えるとグローバル変数みたいになる + でもあくまでスコープはローカル === # コード例 --------- ```js function genpower(n){ var x = 1; return function(){ x *= n; return x; }; } var p = genpower(2); ``` === # コード例 ---------- ```js p() // = 2 p() // = 4 p() // = 8 x * 2 // x is not defined ``` === # コード例 ---------- * `p`が`n`と`x`を補足しているので関数を抜けた後も`x`と`n`は使える。 + 関数の仮引数もローカル変数。 * でもローカル変数なので外からは見えない。 === ``` +-----------------------+ | function genpower(n){ | | var x = 1; | | ... ^ | | } | | +-----------------------+ | +------+ | +-------------+ ||function(){ | |+-- x *= n; | | return x; | | }; | +-------------+ ``` === # コード例2 ---------- ```js function incdec(){ var x = 0; return [function(){ return ++x;}, function(){ return --x;}]; } var fs = incdec(); var inc = fs[0]; var dec = fs[1]; ``` === # コード例2 ---------- ```js inc() // = 1 inc() // = 2 dec() // = 1 inc() // = 2 ``` === # コード例2 ---------- * 同じタイミングで作られたクロージャ群は捕捉変数を共有する === ``` +--------------------+ | function incdec(){ | | var x = 0; | | ... ^ | | } | | +--------------------+ +--------------+----+ | | +----------------------|---+| | function(){ return ++x;} || +--------------------------+| +----+ +----------------------|---+ | function(){ return --x;} | +--------------------------+ ``` === # コード例3 ---------- ```js function genpower(n){ var x = 1; return function(){ x *= n; return x; }; } var p1 = genpower(2); var p2 = genpower(2); ``` === # コード例3 ---------- ```js p1() // = 2 p1() // = 4 p2() // = 2 p2() // = 4 ``` === # コード例3 ---------- * 逆に、同じ関数から生まれても違うタイミングなら共有しない。 === ``` +-----------------------+ +-----------------------+ | function genpower(n){ | | function genpower(n){ | | var x = 1; | | var x = 1; | | ... ^ | | ... ^ | | } | | | } | | +-----------------------+ +-----------------------+ | | +------+ +------+ | | +-------------+ +-------------+ ||function(){ | ||function(){ | |+-- x *= n; | |+-- x *= n; | | return x; | | return x; | | }; | | }; | +-------------+ +-------------+ ``` === # 実装方法 ---------- * ここでは複数ある実装方法のうちの1つを紹介する。 * 言語はVM型のインタプリタ（大抵のインタプリタの実装に同じ）を仮定する === # 用語整理 ---------- * `outer`から見たら`x`は捕捉(Captured)変数 + `inner`から捕捉されてるから * `inner`から見たら`x`は自由(Free)変数 + `inner`からしたら`x`は知らない子だから ```js function outer(x) { function inner(y){ return x * y; } } ``` === # 実装概要 ---------- * **クロージャとは捕捉変数の集まり** + つまり、捕捉した側ではなくされた側が作る + 捕捉した側は作られたものを参照するだけ === # 変数の話 --------- * グローバル変数はヒープ領域に置かれる + グローバル DB（大抵巨大なハッシュテーブル）に登録される * ローカル変数はコールスタックに置かれる + 配列が作られ、インデックスでアクセスされる感じ。 + ローカル変数の数は関数定義時に決定するので配列で管理出来る + 関数の実引数も同じように置かれる === # 捕捉変数の話 ------------- * 捕捉変数はヒープ領域に置かれる + 簡単には小さなハッシュテーブルに登録される - つまり、グローバル変数と同じ - 捕捉変数も関数定義時に決定するので配列でも管理出来る + ハッシュテーブル/配列はクロージャ毎に作られる ※ [本気出した実装](http://practical-scheme.net/docs/stack-j.html)だとコールスタックでどうにかすることもある === ```js var g = 1; function sample(a) { var l = 2; var c = 3; return function(){ return c;}; } ``` === ``` | .... | |---------------| | args[0] = _ | a |---------------| | locals[0] = 1 | var l |---------------|--コールスタック↑-- | .... | | .... | |---------------|--ヒープ領域↓-- | caps[c] = 3 | var c = 3 |---------------| | global[g] = 1 | var g = 1 | global[_] = _ | | .... | | .... | ``` === ```js function incdec(){ var x = 0; return [function(){ return ++x;}, function(){ return --x;}]; } var fs = incdec(); var inc = fs[0]; var dec = fs[1]; ``` === ``` | .... | |---------------|--ヒープ領域↓-- | caps[x] = 0  ","categories":["言語実装"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85"],"date":"2015-05-17","title":"実装から理解するクロージャ","url":"https://KeenS.github.io/slide/jissoukararikaisurukuro_ja/"},
  {"body":"κeenです。正規表現技術入門という本の書評が望まれているようなので今日買ってきて読みました。\n私のバックグラウンドと目的 バックグラウンドは\n RubyとUnixの正規表現はそこそこ使ってる ドラゴンブックは読んだことある RE2の概略も知ってる VMベースの言語処理系のコミッタなのでVMへの理解もある Standard MLの正規表現エンジンを開発中。機能はほぼ揃ってる  な感じです。で、実装中の正規表現エンジンがこの本で紹介されてるVM型でもDFA型でもなくVM型の素朴な形、ASTのインタプリタで 実装されてるので\n インタプリタのまま追加出来る機能はないか 高速化を目指すならVM化とDFA化どちらがいいか (既存のSMLの正規表現エンジンではVMバックエンドやDFAバックエンドでグルーピングが使えないので)高速な手法でのグルーピングの実装方法が知りたい 後方参照の実装方法が知りたい  などの目的で読みました。割とガチめですね。そういうことを念頭に置いてこの書評を読んで下さい。\n書評 1章 正規表現 正規表現とはなんぞや？から入り使われる記号などを解説してます。「日本酒うめえwww」など出てきてしかも「草を生やす」の意味の解説がありました。フランクですね。 はいはい、と読み進めていったら先読み、後読みなどのあまり理解してない機能の解説やさらに上手い使い方も紹介されておお！となりました。例えばhoge、fuga、piyoの3つが含まれる文字列は\n(?=.*hoge.*)(?=.*fuga.*)(?=.*piyo.*).* と書けるそうです。飽くまで先読みは文字列ではなく位置にマッチするため、正規表現の重ね合わせが出来るんですね。本来ならhoge、fuga、piyoが3!通りの並び方をするので6つの分岐をしないといけない。\nあと、貪欲、非貪欲の他に強欲マッチなるものを知りました。確かに実装側としては貪欲マッチでバックトラックしてるところが無駄に複雑になるので強欲マッチがあるとありがたいですね。\n正規表現の再帰の話もありました。(?0)で全体、(?n)(n \u0026gt;= 1)でグループを再帰します。予想の通りこれは正規言語ではなくなるのですが、\n(\\d+|\\((?0)\\))([-+*/](?1))* で括弧と四則演算の式をパース出来てしまうそうです。もはやパーサジェネレータ並だなと。と思ったら後で出てくる通り対応する括弧にマッチ出来てしまうので文脈自由文法を受理するそうです。すごい。\n導入なので読み飛ばそうと思ったのですがちゃんと飽きさせない内容で良かったですね。\nあとこの章でさらっと(否定)?[先後]読みが正規言語の範疇で出来るという（私にとって）大変重要な事実が書かれてました。実装しますかな。\n2章 正規表現の歴史 一口に正規表現といっても色々あるんだよーな感じな内容。恐らく後の章で比較する時のために役者を揃える目的。\n「Unixの正規表現といえばEREのこととする」と書いてあったのでこの章は許さない。あとegrepを使ってる。 奴は互換性のためだけに残された非推奨コマンドで、実体は grep -Eだ。古のシェルスクリプトでもない限りgrep -Eを使え。絶対許さない。\n3章 プログラマのための一歩進んだ正規表現 正規表現の形式的な話のあとはエンジン毎のサポートする機能の違いだとかベンチマークだとかの話。VM型とDFA型の性能特徴が出てて面白かった。\nそして正規表現の限界(メールアドレスの精密なバリデーションには正規表現は使えないから妥協しろ、など)にも言及。 恐らく使う側からしたらこの辺の話を聞きたかったんだろうが私はそんなに興味ない。\n4章 DFA型エンジン オートマトンの話から入る。んでNFAからDFAを構築する話。ドラゴンブックに載ってたトンプソンのアルゴリズムや部分集合構成法が紹介されてた。 しかもPythonによる実装も載っててすごいありがたい。理論系の資料だと自然言語によるアルゴリズムだけで分かりづらいんですよねー。解説も平易。\n次にDFAのOn the Fly構成の話。ちゃんと載ってるのはありがたい。しかしほぼ必須の機能といいつつ参考資料が載ってないのが気になった。資料が必要ないくらい簡単なのかな。\n最後にDFAの良いところが載ってる。VMと比較したい人には嬉しい点ですね。\n5章 VM型エンジン トイレに行きたくてうずうずしながら読んだので少し軽めにしか読んでない（ごめんなさい）。最初はVMとはなんぞや？という話から正規表現VMの挙動について、CレベルでのAPIについて、実装についてなど。 著者が開発している鬼雲で採用されてる方式なだけあってかなり詳しくて丁寧。VMの仮想アセンブラ例とスタックの遷移なども細かく書いてある。\n最初に必要最小限な機能をナイーブに実装したVMのコードを紹介して読者に雰囲気を掴ませたあと徐々に最適化していき、最後は鬼雲のコードを見せます。\n鬼雲の拡張機能のための命令や高速化のための工夫なども載ってて実装の際にはかなり役立つ筈。ここで目的の1つであったVM方式での後方参照の実装の仕方を知ります。\nUnicodeつらいよねーって話とか。Unicode対応しようかと思いましたがこれ読んで諦めました。\nAST/バイトコードレベルでの最適化の話もありました。私がプリントしたASTが簡単になるように変換していたものや、インタプリタの機能を出来る限り小さくするためにASTレベルで実現していた機能が実は最適化だったことを知りました。\n正規表現エンジンの三大技術動向 JIT、固定文字列探索、ビットパラレルについて。やはりドラゴンブックのように古い本だとこの辺はカバーし切れない。\nJITの話 まあ、知ってるよって思ったのですがVM命令を実際にアセンブラに変換した例が載っていて後の参考になりそうだった。あとなぜバイトコードよりJITした方が速いのかの図解がめちゃくちゃ分かりやすかった。あの図、Direct Threaded VMの説明にも使えるのでいつか説明する機会があったら参考にさせてもらいます。 ところで本に載ってた鬼雲のコードはDTにしてなかったけど簡単のためなのかな？あるいは厳格にC89に準拠するため？picrinみたくプリプロセッサで分岐すれば使えるのに。\n流石にOn the Flyコンパイルの話はなかった。まあ、あんまりメリットないしやんないか。\n固定文字列探索の話 grepよりgrep -Fの方が速いよねーって話かと思ったらそれだけではなかった。http://([^/?#]*)?([?#]*)(\\?([^#]*))?(#(.*))?みたいな正規表現にマッチさせる時に、まず http:// を固定文字列探索で高速に見付けてからそこを起点にマッチを始める高速化手法があるそうです。固定文字列探索が高速なのはQuick Search（多分尺取り法と同じ）などのアルゴリズムがあるからですねー。あとSIMDやAVXも使える。さらに今回のhttp://みたいな\u0026rdquo;キーワード\u0026rdquo;を抽出する技術の話も。\nビットパラレルの話 先の固定文字列探索の話に関連して。固定文字列ではなく文字クラスまで含めても高速に扱える方法。なるほど〜といったところ。SIMDやAVXが使えない/使いづらい言語でも実践出来そうでいいですね。\n正規表現の落とし穴 RE2のモチベーションでもある、バックトラックによってマッチングが指数時間になってしまう問題から。「RE2使え」ってくるかと思ったらユーザーレベルでどうにかする話や正規表現の最適化の部分でどうにかする話もあった。\n落とし穴とその対策の話があるのですが、一番気になったのがエンジンによる挙動の違い。私の正規表現エンジンはEREを実装することを目標として、grep -Eで挙動を確かめながら実装してたのですがちょっと怪しくなってきた。\nマッチ戦略が最左最長か自身がないのもあるけどグルーピングの話。pythonではグループは上書きされて、\n\u0026gt;\u0026gt;\u0026gt; r = re.compile(\u0026#39;(\\w+,?)*\u0026#39;) \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#39;apple,banana,kiwi\u0026#39;).groups() (\u0026#39;kiwi\u0026#39;,) となるそうです。最初、私の正規表現エンジンもこの挙動をしていたのですが、grep -Eは例えばecho 'apple,banana,kiwi' | grep -o -E '([a-z],?)*'がapple,banana,kiwiを返すのでわざわざ\n| Star =\u0026gt; (case acc of [] =\u0026gt; raise Parse | Group(i, x) :: xs =\u0026gt; parse(ts, Group(i, Kleene x) :: xs, e, gi) | x :: xs =\u0026gt; parse(ts, Kleene x :: xs, e, gi)) のように括弧の後にスターが来たら括弧の中のクリーネ閉包をとってました。まあ、実装はそれぞれらしいのでこれが間違ってる訳ではないのですがパーサを不必要に複雑にしてしまったことを反省。\n残りはアトミックグループの話だとか。\n正規表現を越えて 正規表現周りのツールの紹介の後はBNF、PEGの話。恥ずかしながら、BNFの表現範囲である文脈自由言語が正規表現言語+括弧の対応だということを初め知りました。いや、もしかしたらドラゴンブックに書いてたのかもしれませんが見落してました。\nPEGについては、BNFあるしいいやって思ってたのですがマッチが線形時間だったりBNFで表現出来ない範囲まで表現出来たりと中々楽しそうでした。\nあとまさかの「草生やす」の説明をした伏線を回収。\n付録A.1 正規と非正規の壁 正規言語の話とその辺の証明。否定は正規だけど後方参照は非正規だとか。この本で一番理論寄りな話でありながら同値関係とは〜とかから解説していてすごい丁寧（簡単に理解出来るとは言っていない）。いや、でも本当に正規言語関連の証明が欲しかったらまずはここ参照するかってくらい丁寧ですよ。\n付録A.2 正規性の魅力 だんだん感想が雑になってるのからも分かる通り、この辺で力尽きたのでこの章は流しました。後日読みます。\n全体を通して 論文やWeb上の資料への参照をばら撒いていますが本書自体は理論寄りになりがちな正規表現の解説を平易に書いていて、かなり敷居を下げてくれたなという印象。正規表現やエンジンの歴史、それによる実装の違いなども説明しているのでこの本を持っていれば正規表現でハマるということもなくなりそう。まえがきにもある通り、Web上では断片的にしか入らない知識が1冊にまとまっている。個人的にはDFAの話をもうちょっと詳しく知りたかった。DFAを実装する時の最適化の話とか。\n私のように正規表現を実装したい人だけでなく「正規表現の最適化ってどこまで賢いの？」だとか「このパターンは正規表現で表現出来るの？」だとか「書いた正規表現が魔境で理解出来ないから綺麗に書きたい」だとか思ってる人にも良い本だと思います。\n因みにこの本、33,00円ですが私は4,800円でも買った。\n","categories":["書評"],"category_urls":["/categories/%e6%9b%b8%e8%a9%95"],"date":"2015-05-10","title":"正規表現技術入門を読んだ","url":"https://KeenS.github.io/blog/2015/05/10/seikihyougengijutsunyuumonwoyonda/"},
  {"body":"# 勉強会駆動勉強で勉強 ---------------------- サイバーエージェント15卒FRESH勉強会 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 渋谷のエンジニア + 大学では非情報系の学部にいた + Lisp, ML, Shell Scriptあたりを書きます === # 勉強会駆動勉強 --------------- === # 勉強会駆動勉強 --------------- ## 方法 1. 勉強会を見付ける 2. (詳しくない内容について)トークを登録する 3. 期日までに勉強する 4. 期日までに資料を作る 5. 発表する === # 勉強会駆動勉強 --------------- ## ポイント * 自分でテーマを決めてる * 自分で期限を決めてる * 決めた期限は強制力がある * アプトプットする * 質問などでフィードバックがくる === # 勉強会駆動勉強 --------------- ## 身に付く力 * 素早く調べる力 * 要点を素早く見付ける力 * プレゼン資料の作成力 * プレゼン力 === # 例 === # 前回のRustの話 実は発表決めた時点ではRustを書いたことなかった ![Rust slide](/images/rust_slide.png) === # ISUCON 勉強会じゃないけど出場を決めてから周辺の勉強を始めた ![iscon4 blog](/images/isucon4_blog.png) === # おまけ ------- その他の勉強法 * マイナー言語式勉強法 * やっちゃれ勉強法 === # マイナー言語式勉強法 === # マイナー言語式勉強法 --------------------- ## 方法 * マイナー言語を始める === # マイナー言語式勉強法 --------------------- ## ポイント ![lisplogo](/images/lisplogo_256.png) * 情報が少ない * ライブラリも少ない * でも謎技術が使われていたりする === # マイナー言語式勉強法 --------------------- ## 身につく力など * どうにかして情報を見付ける力 * 英語力 * ソースコード読解力 * ライブラリ実装する力 * 他人のソースのバグを見付ける力 * プルリク力 * RFCなどを読む力 * パラダイムが広がる * 謎技術を使えるようになる === # やっちゃれ勉強法 === # やっちゃれ勉強法 ----------------- ## 方法 * (言語/仕様に)詳しくないけどライブラリの実装始めちゃう * やっちゃれ（やってやれ）の気持で。 === # やっちゃれ勉強法 ----------------- ## ポイント * 手を動かしてる === # やっちゃれ勉強法 --------------------- ## 身につく力など * 実装力 * 仕様の理解力 * 言語への理解 * (大抵)低レベルな操作 === 以上 何か質問あればどうぞ   ","categories":[],"category_urls":[],"date":"2015-05-06","title":"勉強会駆動勉強で猛勉強","url":"https://KeenS.github.io/slide/benkyoukaikudoubenkyoudetakeshibenkyou/"},
  {"body":"κeenです。みなさんバックアップは何使ってますか？大抵のOSには標準でバックアップツールが付いてますがそれ使ってます？私も使ってます。 しかしやつらはそのOSでしか動かない/動かす方法があまり知られていないのでマシンがクラッシュしたりマシンを失くした時に困ります。\nそこで候補に上がるのが安心と信頼のtarballですが今度は増分バックアップが取りづらいという問題があります。なのでtarballベースの差分バックアップツールを作りました。\nまあ、捜せば同じようなものが色々あるでしょうが捜し回るのが面倒だし色々インストールするのも嫌なのでえいやと作ってしまいました。\nタイトルにある通りSheltarといいます。ポータブルなB Shellスクリプト製です。どこでも動くと思います。バックアップ（避難）だしshellだしtarだしって適当に付けたら意外にもコンフリクトがありませんでした。しかもウルトラ怪獣にも居るという奇跡的な名前です。\n目的  増分バックアップをとる UbuntuとMac間でのデータ同期にも使いたい(家のルータがしょぼいのでrsyncを使いたくなく、USBメモリ経由とかが良い) なのでファイル形式はポータブルなtarballで メタデータとかは極力置かず、最悪他のツールからでもバックアップデータをサルベージ出来るようにしたい  です。 GNU tarには増分バックアップ用のオプションがありますがファイル抽出は手作業でやる必要があります。 また、(多分)BSD tarには増分バックアップ用のオプションがないのでそこもカバーする必要があるかなと思って作りました。\nあとオプションがあるとはいっても一々覚えてられないのでスクリプト化してしまいたかったってのもあります。\n使い方 STEP0 ここからSheltarを入手しましょう。sheltarスクリプト1つで完結しているのでcloneしなくてもrawをwgetしてきても大丈夫です。\nSTEP1 増分バックアップなので複数のtarballが作られます。バックアップ用のディレクトリを用意しましょう。\n$ mkdir /mnt/dev1/backup STEP2 バックアップしたいファイルをリストアップしましょう。バックアップは継続的に行なうものなので1回限りのコマンドライン引数で渡す訳にはいきませんね。\npngファイルをバックアップしたいとしましょうか。\n$ find Pictures -name \u0026#39;*.png\u0026#39; \u0026gt;\u0026gt; list.txt これで良さそうです。ディレクトリの中身全部をバックアップしたいなら\n$ echo Pictures/ \u0026gt;\u0026gt; list.txt でも構いません。最後の\u0026rsquo;/\u0026lsquo;重要です。最初のバックアップの時には問題ありませんが\u0026rsquo;/\u0026lsquo;がないと増分バックアップの時にディレクトリ自体のlast modified timeを見て変更を判断します。\nSTEP3 あとは実行するだけですね。\n$ sheltar backup /mnt/dev1/backup list.txt その後、増分バックアップを取るのも同じく\n$ sheltar backup /mnt/dev1/backup list.txt で可能です。前回のアーカイブファイルのlast modified time より新しいファイルだけをバックアップしてくれます。\n因みに今のところバックアップディレクトリに余計なものがあると正しく動作してくれないので注意です。\n復元 全部のファイルをカレントディレクトリにぶちまけたいなら\n$ sheltar extract /mnt/dev1/backup です。抽出するファイルを指定したいなら\n$ sheltar extract /mnt/dev1/backup file1 file2 ... とします。\nカレントディレクトリに同名ファイルが既にある場合は新しい方を残します。\nその他 まだまだ未完成です。欲しい機能があったらissueに投げてくれると実装するかもしれません。Pull Requestもお待ちしております あと、ドックフードはまだ食べてません。一応テストはしてますが…。Macをまともに使う気になったら使い始めると思います。\nあ、そうそう。今回比較的コメントを多く書いたのでシェルスクリプトを勉強したい方はソース読んでみて下さい。 こんな感じです。Doxygenがシェルスクリプトに対応してないので疑似ドキュメント形式のコメントですが。\n# Extract the all files from backups in $ST_BACKUP_DIR. # A file with the same name as extracting file will be preserved if it is newer than its counterpart. ## @filesystem extract all the backup files to CWD st_extract_all() { # This is preferable to `for TARBALL in $(ls)` because the names of listed files # can contain whilespaces ls --sort=time -r \u0026#34;${ST_BACKUP_DIR}\u0026#34; | while read TARBALL do tar xf \u0026#34;${ST_BACKUP_DIR}/${TARBALL}\u0026#34; \\  --keep-newer-files \\  --preserve-permissions \\  --preserve-order done }","categories":["Shell","CLI"],"category_urls":["/categories/shell","/categories/cli"],"date":"2015-05-06","title":"tarballベースの軽量バックアップツール'Sheltar'を作った","url":"https://KeenS.github.io/blog/2015/05/06/tarballbe_sunokeiryoubakkuapputsu_rutsukutta/"},
  {"body":"SMLばっかり書いてたら「お前Lisperじゃないだろ」って怒られたとかそういう話ではなく。\nML系の言語は関数は1つの引数しかとれません。じゃあ複数の値を受け取りたい時はどうするかというと 1. 値を組(タプル)にして受け取る 2. 関数を返す関数((を返す関数)*)にして1つづつ受け取る の2種類の方法があります。 それに纏わる話。\nそれぞれの記法を例示すると\n 値を組(タプル)にして受け取る\nfun add (x, y) = x + y add (1, 2) あるいは、手続型言語に似せて\nadd(1, 2) とするスタイルもあります\n 関数を返す関数((を返す関数)*)に(カリー化)して1つづつ受け取る\nfun add x y = x + y add x y (*= ((add x) y) *)  となります。勿論、2.のように何度も関数を呼び出すよりは1.のように一度で全ての値を渡してしまった方が速い筈です。なのでプリミティブっぽい関数はタプル式にした方が良さそうです。 また、無名関数を定義する時にSMLではfunのように自動でカリー化してくれる構文がないので複数の引数を受け付ける関数を引数にとる高階関数を定義するときはタプル式の方が都合が良いでしょう。\n例えば二項演算子はタプル式で定義しなければなりませんし、List.foldlのシグネチャも\n(\u0026#39;a * \u0026#39;b -\u0026gt; \u0026#39;b) -\u0026gt; \u0026#39;b -\u0026gt; \u0026#39;a list -\u0026gt; \u0026#39;b です。\n勿論、積極的に最適化を行なうコンパイラではuncurry optimizationや、closure eliminationでカリー化によるオーバーヘッドはなくなります。 むしろ、カリー化した方が部分適用が出来るので利便性は上がります。となると後は無名関数の問題ですが、OCamlやHaskellなど無名関数にもカリー化した定義が出来る構文のある言語だとそれも問題なく、タプル式の引数の渡し方はしないようです。\nSMLは流石に\u0026rsquo;Standard\u0026rsquo;なので最適化を仮定したり余計な構文を突っ込んだりはしづらいのでしょう。なのでこの問題はSML特有のようです。\nここまで、なぜタイトルがML系言語ではなくSML限定なのかの前置き。\nこういう関数呼び出しがあるとします。sub: string * int -\u0026gt; charは文字列の0番目の文字を取り出します。\nsub(str, 0) これにChar.isAlpha : char -\u0026gt; boolを適用します。\nChar.isAlpha sub(str, 0) これ、コンパイルエラーになります。みなさん何でか分かりますか？\nsub(str, 0)はあくまでsubに(str, 0)というタプルを渡している文なのでコンパイラはこう解釈するのです。\n(Char.isAlpha sub) (str, 0) 毎回このようなエラーを出すのが面倒なので関数の呼び出しには全て手続き型言語のように括弧をつけることを考え始めます。\nChar.isAlpha(sub(str, 0)) しかしそうは問屋が卸さないのがカリー化された関数。String.isPrefix: string -\u0026gt; string -\u0026gt; boolに次のような呼び出しをすると勿論怒られます。\nString.isPrefix(\u0026#34;/usr/local\u0026#34; path) 必ず\nString.isPrefix \u0026#34;/usr/local\u0026#34; path としないといけません。これまた関数呼び出しがネストすると面倒で、\napp (fn s =\u0026gt; print (s ^ \u0026#34;\\n\u0026#34;)) (List.filter (String.isPrefix \u0026#34;/usr/local\u0026#34;) paths) のように毎回括弧が付き纏います。ここまでくるとS式みたく\n(app (fn s =\u0026gt; print (s ^ \u0026#34;\\n\u0026#34;)) (List.filter (String.isPrefix \u0026#34;/usr/local\u0026#34;) paths)) と書きたくなってくるのがLisperの心情。これなら慣れないデータコンストラクタや関数呼び出しや中置演算子の優先順位問題も解決!やったね!!と思ったのですがやっぱりタプル式の関数呼出が行く手を阻むのでした。 (sub(str, i)) とか訳分からなすぎる。括弧多すぎる。\nということでどっちに揃えたら良いのかさえ分かってないのにどっちにも揃えられてないSMLに対して悩みを抱えるLisperの悩みでした。\n因みにSML-LintはChar.isAlpha()のような書き方は無駄な括弧がついてると怒ってきます。\n","categories":["ML","SML"],"category_urls":["/categories/ml","/categories/sml"],"date":"2015-05-03","title":"SMLを書くLisperの悩み","url":"https://KeenS.github.io/blog/2015/05/03/smlwokakulispernonayami/"},
  {"body":"κeenです。SML#2.0.0を文鎮と化していたMBAにインストールしたのでメモをば。\n基本はよんたさんの記事をMacに翻訳した感じです。\nモチベーションは、公式の配布物がMac版だとMacPorts版しかなく、 portsとhomebrewの混在は避けた方が良いと聞いたのでどうにかして自前ビルドしようとしたことです。\n注意書き 冒頭にも書いてあるようにMBAは普段使ってなくて、このエントリーもMBAじゃないマシンから書いているのでコマンド類はコピペでなく写経してます。 typoがあるかもしれないのでコピペして動かなかったら一応この記事のtypoを疑って下さい。\nGMP32bitの準備 $ brew install gmp --32-bit で終わり。バージョン6.0.0aが入りました。 既にインストールされていたら多分64bit版が入っているので一旦 brew remove gmp してから再度インストールすると良いです。尚、バイナリ版はないようで、ビルドが始まります。checkに時間が掛かる。\nLLVM34 32bitの準備 骨が折れるところですね。\n$ wget http://llvm.org/releases/3.4.2/llvm-3.4.2.src.tar.gz $ gzcat llvm-3.4.2.src.tar.gz | tar xf - $ cd llvm-3.4.2.src $ ./configure --build=i686-mac-darwin CC=\u0026#39;gcc -m32\u0026#39; CXX=\u0026#39;g++ -m32\u0026#39; --prefix=/usr/local/Cellar/llvm34/3.4.2a $ make -j4 $ make -j4 install $ cd ../ としたら上手くいきました。何故上手くいったんでしょうねー。あとprefixは割と気持悪いのでみなさん適切な場所にインストールしましょうね。\nSML# のビルド これが一番骨が折れるところですね。\n$ wget http://www.pllab.riec.tohoku.ac.jp/smlsharp/download/smlsharp-2.0.0.tar.gz $ gzcat smlsharp-2.0.0.tar.gz | tar xf - $ cd smlsharp-2.0.0 $ ./configure --with-llvm=/usr/local/Cellar/llvm34/3.4.2a/ \\ LDFLAGS=\u0026#39;-L/usr/local/Cellar/gmp/6.0.0a/lib\u0026#39; \\ CPPFLAGS=\u0026#39;-I/usr/local/Cellar/gmp/6.0.0a/include\u0026#39; \\ CC=\u0026#39;gcc -m32\u0026#39; \\ CXX=\u0026#39;g++ -m32\u0026#39; $ make -j4 $ make -j4 install としたら出来ました。\nまとめ 誰かhomebrewにして。\n","categories":["ML","SML","SMLSharp"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp"],"date":"2015-04-29","title":"SML#をMacでビルドする","url":"https://KeenS.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru/"},
  {"body":"# Common Lispで限定継続と遊ぶ ---------------------- [Lisp Meet Up #27](https://atnd.org/events/64988) === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 渋谷のエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # Agenda -------- 0. cl-contの紹介 1. 限定継続の話 2. 限定継続の使い方の話 3. 限定継続の実装の話 === # CL-CONTの紹介 === # CL-CONT --------- * Common Lispの限定継続ライブラリ * 結構古くからあるっぽい * 割と色々なライブラリが使ってる === # CL-CONT --------- ![cl-cont dependers](/images/cl-cont-dependers.png) === # API ----- * 継続を区切るマクロ + `with-call/cc` + `defun/cc` + `lambda/cc` * 継続を取得するマクロ + `call/cc` + `let/cc` ※後で説明するので意味が分からなくても問題ないです。 === # 限定継続の話 === # 継続とは --------- * \"その後\"の計算を表わす概念。 * 値が決定した後トップレベルに戻るまでの計算。 * Schemeが一級市民として扱えることで有名 * 値として取り出した時は0-1引数関数として振る舞う === # 継続とは ---------- `foo`の継続は、`foo`を虫食いにしたものと思えば良い。 ```lisp (mapc #'writ-line (loop :for x :in list :collect (if (evenp x) (foo x)))) ``` === # 継続とは ---------- `foo`の継続は、`foo`を虫食いにしたものと思えば良い。 ```lisp (mapc #'writ-line (loop :for x :in list :collect (if (evenp x) □))) ``` === # 継続とは ---------- あとはそれを関数にするだけ ```lisp (lambda (k) (mapc #'writ-line (loop :for x :in list :collect (if (evenp x) k)))) ``` === # 限定継続とは --------- * \"その後\"の計算を表わす概念。 * 値が決定した後 *指定した位置* に戻るまでの計算。 * 継続がトップレベルまで戻るのに対して限定継続途中で止まる。それだけ。 * 部分継続などの言い方もある + 英語もpart contとdelimited contで分かれる === # 限定継続とは ------------- 先の例を`loop`までの限定継続にすると ```lisp (mapc #'writ-line (loop :for x :in list :collect (if (evenp x) (foo x)))) ``` === # 限定継続とは ------------- 先の例を`loop`までの限定継続にすると ```lisp (loop :for x :in list :collect (if (evenp x) □)) ``` === # 限定継続とは ------------- ```lisp (lambda (k) (loop :for x :in list :collect (if (evenp x) k))) ``` === # 限定継続の挙動 --------------- 普通のやつ ```lisp (with-call/cc (+ 1 (call/cc (lambda (k) (funcall k 2))))) ``` これは ```lisp (+ 1 2) ``` と等価 === # 限定継続の挙動 --------------- 今度は継続を呼ばないでみる ```lisp (with-call/cc (+ 1 (call/cc (lambda (k) 2)))) ``` これは ```lisp 2 ``` と等価 === # 限定継続の挙動 --------------- もうちょっと呼ばない例 (`(let/cc k ...)` = `(call/cc (lambda (k) ...))`) ```lisp (with-call/cc (write-line \"hello\") (let/cc k 1) (write-line \"world\")) ``` は ```lisp (progn (write-line \"hello\") 1) ``` と等価 === # 限定継続の使い方の話 === # 限定継続の使い方の話 --------------------- * グリーンスレッド * コールバックを綺麗に書き換える * 非決定性計算 * etc... === ## グリーンスレッド === ## グリーンスレッド ----------------- * またの名をコルーチン * またの名を強調スレッド === ## グリーンスレッド ----------------- ```lisp (let (c) (setf c (with-call/cc (write-line \"in thread A 1\") (let/cc k k) (write-line \"in thread A 2\") (let/cc k k) (write-line \"in thread A 3\"))) (write-line \"in main thread 1\") (setq c (funcall c)) (write-line \"in main thread 2\") (setq c (funcall c)) (write-line \"in main thread 3\")) ``` === ## グリーンスレッド ----------------- 実行結果 ``` in thread A 1 in main thread 1 in thread A 2 in main thread 2 in thread A 2 in main thread 3 ``` === ## コールバックの書き換え === ## コールバックの書き換え ---------------------- 本当はこう書きたい ```lisp (with-event-loop (format t \"Hello, ~a!~%\" (async-read stream))) ``` === ## コールバックの書き換え ---------------------- しかしライブラリがコールバック関数を要求してくる ```lisp (with-event-loop (async-read stream (lambda (line) (format t \"Hello, ~a!~%\" line)))) ``` === ## コールバックの書き換え ----------------------- コールバック = 限定継続（後述）なのでこうしてやれば良い。 ```lisp (with-event-loop (with-call/cc (format t \"Hello, ~a!~%\" (call/cc (lambda (k)) (async-read stream k))))) ``` === ## 非決定性計算 === ## 非決定性計算 ------------- ### ベースアイディア * 継続を関数として取り出した後同じ処理を何回も実行出来るんじゃね？ === ## 非決定性計算 ------------- ### ベースアイディア 複数回呼び出してみる ```lisp (let (c) (setf c (with-call/cc (+ 1 (* 2 (- 3 (let/cc k k)))))) (list (funcall c 1) (funcall c 2) (funcall c 3))) ``` === ## 非決定性計算 ------------- ### ベースアイディア 普通の1引数関数として使ってみる ```lisp (let (c) (setf c (with-call/cc (+ 1 (* 2 (- 3 (let/cc k k)))))) (mapcar c (list 1 2 3))) ``` === ## 非決定性計算 ------------- ### ベースアイディア マクロでラップしてみる ```lisp (defmacro for (\u0026body expr) `(with-call/cc ,@expr)) (defmacro in (m) `(let/cc k (apply #'append (mapcar k ,m)))) (defun yield (x) (list x)) (defun unit () nil) ``` === ## 非決定性計算 ------------- 使ってみる ```lisp (for (let ((x (in '(1 2 3))) (y (in '(a b c)))) (yield (cons x y)))) ``` ``` ((1 . A) (1 . B) (1 . C) (2 . A) (2 . B) (2 . C) (3 . A) (3 . B) (3 . C)) ``` === # 限定継続の実装の話 === # 限定継続の実装の話 ------------------- * 継続は0~1引数関数として取り出せるのであった。 + 実は機械的に取り出せる * 継続は全ての式に暗黙に存在するのであった + 全ての式を継続を明示的に使うようにも出来る === # CPS変換 === # CPS変換 --------- * 全ての関数の引数を1つ増やして、そこで継続を受け取る * 値を返す時は暗黙のreturnを使うのではなく明示的に継続を呼ぶ * 関数を呼ぶ時は必ず継続を渡す。呼び出し元には返ってこない（自然と末尾再帰になる） === # CPS変換 --------- 例えば ```lisp (with-call/cc (foo (call/cc (lambda (k) (funcall k 2))))) ``` は、取り出された継続が ```lisp (lambda (k) (foo k)) ``` 。 === # CPS変換 --------- よって ```lisp ((lambda (k) (foo k)) 2) ``` と変換される === # CPS変換 --------- 再帰関数だと少し面倒 ```lisp (defun fact (n) (if ( ","categories":["Lisp","Common Lisp","Lisp Meet Up","限定継続","CPS"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/lisp-meet-up","/categories/%e9%99%90%e5%ae%9a%e7%b6%99%e7%b6%9a","/categories/cps"],"date":"2015-04-26","title":"Common Lispで限定継続と遊ぶ","url":"https://KeenS.github.io/slide/common_lispdegenteikeizokutoasobu_/"},
  {"body":"# 非同期処理の「その後」の話 ---------------------- ## goto、継続、限定継続、CPS、そしてコールバック地獄 === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 渋谷のエンジニア + Lisp, ML, Shell Scriptあたりを書きます === # 同期処理とは ------------- 通常、外部とやりとり(I/O)する時に待ち時間(ブロック)が発生する。 ![sync task image](/images/sync.png) === # 非同期処理とは --------------- 待ち時間に(ブロックせずに)別の処理をしようという発想。 ![async task image](/images/async.png) === # 非同期処理の裏側 ----------------- 処理Aと処理Bの他にいつどっちを動かすかを決めるスケジューラが存在することが多い ![async scheduler image](/images/async_scheduler.png) === # どうやって戻る問題 ------------------- * 一時停止した後「その後」の処理にどうやって戻るか ![cont image](/images/cont.png) === # 「その後」とは ----------- ```C ... fputc(c); // ここの処理でI/Oが入る // 再開する時にここに戻ってきたい printf(\"Work done\"); ... ``` === # GOTO ------ `goto` を使えば戻れる ```C ... fputc(c); // ここの処理でI/Oが入る // 再開する時にここに戻ってきたい RESTART: printf(\"Work done\"); ... ``` === # GOTOの問題 ------------ こういうコードだとGOTOでは困る ```C if ((c = fgetc(f)) != -1) ... ``` === # GOTOの問題 ------------ こんな区切り方をしたい ![cont in code image](/images/codecont.png) === # GOTOの問題 ------------ * 式の途中に入れない * 値を返せない * I/Oが終わった「その後」が思ったより複雑 === # \"継続\"という概念 ----------------- * continuation * ここで言ってる「その後」に名前をつけたもの * その後に行なわれる全ての処理のこと * 全ての言語に存在する === # (限定)継続を値として扱える言語 ------------------------------ 値としての継続はちょっとリッチになったGOTO程度。 * Scheme * OchaCaml * SML/NJ * (Ruby) * etc. === ## 正確には限定継続 ------------------ * 細かい話だが継続と言うと処理Aとスケジューラ全てを含んでしまうので 今回欲しいのは処理Aの中に限定した限定継続 * 継続を値として扱えれば限定継続を[実装出来る]()ので今回はそこまで深く違いを気にする必要はない === ## 正確には限定継続 ------------------ ![continuation image](/images/continuation.png) === ## 正確には限定継続 ------------------ ![partcont image](/images/partcont.png) === # 限定継続を使った非同期処理の例 ------------------------------ Cの例をSchemeに翻訳してみる ```scheme (if (/= (read-char f) -1) ...) ``` === # 限定継続を使った非同期処理の例 ------------------------------ `lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている) `reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。 ```scheme (reset (if (/= (shift (lambda (k) (async-read-char f k))) -1) ...)) ``` === # 限定継続を使った非同期処理の例 ------------------------------ `lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている) `reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。 ```scheme (if (/= (async-read-char f ) -1) ...) ``` === # 限定継続を使った非同期処理の例 ------------------------------ `lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている) `reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。 ```scheme (if (/= (read-char f) -1) ...) ``` === # ここまでのまとめ ----------------- * 非同期処理を行なう時に継続という概念が出てくる * 継続を値として扱える言語もある * 値としての継続は1引数関数として振る舞う * そのような言語ではユーザレベルで非同期処理をサポート出来る === # 継続を値として扱えない言語での非同期処理 ---------------------------------------- * 先に言ったように全ての言語に継続が存在する * マシン語レベルでjump命令とほぼ同じ * 言語処理系レベルで継続を取り出せば使える * 要は組込み機能 === # 継続を値として扱えない言語での非同期処理 ---------------------------------------- * 処理系にそこまで求めるのは酷 * バグり易い * デバッグし辛い * 処理系はもっと別のことに専念すべき * 機能が追加修正される度に処理系をアップグレードしないといけない 実は継続を値として扱えない言語でもユーザレベルで継続を値として取り出す方法がある === ## Continuation Passing Style === # CPS ----- * 日本語にすると「継続渡し形式」 * 継続を関数として切り出して引数に渡す * 継続のために全ての関数の引数が1つ増える * 継続渡し形式に変換することを「CPS変換という」 * CPS変換は機械的に出来る === # CPS変換 ------------ 先は ```scheme (if (/= (read-char f) -1) ...) ``` が ```scheme (reset (if (/= (shift (lambda (k) (async-read-char f k))) -1) ...)) ``` になった。 === # CPS変換 ------------ 今回は ```scheme (if (/= (read-char f) -1) ...) ``` が ```scheme (async-read-char f (lambda (c) (if (/= c -1) ...))) ``` になる === # CPS変換 --------- * パっと見限定継続のコードの`lambda`の外側と内側が入れ替わる * そんなり分かりやすくない === # もっとCPS変換 --------------- 階乗関数の例 ```scheme (define fact (n) (if (=== # コールバック地獄の正体 ----------------------- 先のCPS変換のコードをJSで書くと分かるかも ```javascript async_read_char(f, function(c){ if(c === -1) { ... } }) ``` === # コールバック地獄の正体 ----------------------- 先のCPS変換のコードをJSで書くと分かるかも ```javascript function fact(n, callback) { if(n  ","categories":["非同期","CPS","継続","限定継続"],"category_urls":["/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f","/categories/cps","/categories/%e7%b6%99%e7%b6%9a","/categories/%e9%99%90%e5%ae%9a%e7%b6%99%e7%b6%9a"],"date":"2015-04-25","title":"非同期処理の「その後」の話。goto、継続、限定継続、CPS、そしてコールバック地獄。","url":"https://KeenS.github.io/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_cps_soshiteko_rubakkujigoku_/"},
  {"body":"κeenです。最近SMLを結構書いてるのですが中置演算子が乱立する言語はLisperにはつらくて、しょっちゅうコンパイルエラーを出します。 そこでSML#をflymakeで動かしてOn The Flyにエラーチェックをします。\nなぜSML#かというと -ftypecheck-only オプションがあって、シンタックスと型エラーのチェックだけを行なえるからです。\n色々試したのですが設定はこれだけで済みました。\n(eval-after-load \u0026#39;flymake \u0026#39;(progn (add-to-list \u0026#39;flymake-allowed-file-name-masks \u0026#39;(\u0026#34;.+\\\\.sml$\u0026#34; (lambda () (list \u0026#34;/usr/local/bin/smlsharp\u0026#34; (list \u0026#34;-ftypecheck-only\u0026#34; (buffer-file-name)))) (lambda () nil))) (add-to-list \u0026#39;flymake-err-line-patterns \u0026#39;(\u0026#34;^\\\\([^: ]*\\\\):\\\\([0-9]+\\\\)\\\\.\\\\([0-9]+\\\\)-[0-9]+\\\\.[0-9]+ \\\\(Error\\\\|Warning\\\\):\u0026#34; 1 2 3 4)))) (add-hook \u0026#39;sml-mode-hook #\u0026#39;flymake-mode) \u0026quot;/usr/local/bin/smlsharp\u0026quot; のところは各自書き換えて下さい。尚、SML#はエラーメッセージを複数行に跨って出すのですがそれがflymakeと相性が悪いのでエラーメッセージの取得は諦めました。\n多くの場合、 flymake-simple という枠組みの中で設定を書くのですがテンポラリファイルを作る構造がどうしてもインターフェースファイルと相性が悪かったので生のflymakeを使ってます。 というかflymakeは元々 -ftypecheck-only みたいなのを前提に作られてたのに実際にコンパイル走らせないとエラーメッセージ取得出来ない言語が多過ぎてフレームワークが出来たのでこれが本来の使い方です。\nおまけ SML-Lintというものがあって、スタイルワーニングを出してくれます。ただ、これはパッチを当てないと使えなかったりスタイルワーニングのみしか出さなかったりするので気が向いた時に紹介します\n","categories":["ML","SML","SMLSharp","Emacs","flymake"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp","/categories/emacs","/categories/flymake"],"date":"2015-04-23","title":"SMLSharpを使ってSMLのon-the-flyエラーチェック","url":"https://KeenS.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu/"},
  {"body":"# 静的なメモリ管理の話。リージョン推論とλ計算からRustまで ---------------------- サイバーエージェント新卒エンジニア勉強会 === # About Me --------- ![κeenのアイコン](/images/icon.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * 大学では非情報系学科。趣味のプログラマ。 + 非ガチ勢なので優しくして下さい=== # 強い静的メモリ管理の話をしよう ------------------------------ * まずは可能性の議論が必要 * 実現可能性 * 実用性 === # 可能性の議論 ------------- * プログラミング言語の理論 ≒ λ計算 * そもそもλ計算はメモリのことを考慮してない + GCがあるかのように記述される === # 可能性の議論 ------------- * λ計算にメモリ管理まで含めて理論を立てたものは存在する（静的なメモリ管理） + リージョンというものをベースにしている [参考](http://www.elsman.com/mlkit/pdf/popl94.pdf) * さらにリージョンを自動で推論する理論もある（強いメモリ管理） + リージョン推論という === # 軽くリージョンの話 ------------------- * 型と同じようにプログラム全体を伝わるメタデータ。 * データが保存される場所を指す。リージョンはいくつもある。 * リージョン推論でデータがどのリージョンに入るかが分かる * さらにリージョンのサイズもある程度予想がつくので静的に管理出来る * 関数などは引数のリージョンに対して多相になる「リージョン多相」などもある * この辺は[Martin Elsmanの論文たち](http://www.elsman.com/mlkit/papers.html)を参考にして下さい + [A Brief Introduction to Regions](http://www.elsman.com/mlkit/pdf/ismm98.pdf)とか。 === # 強い静的メモリ管理の話をしよう ------------------------------ * ✓ まずは可能性の議論が必要 * 実現可能性 * 実用性 === # 実現可能性 === # 実現可能性 ----------- * Martin ElsmanによるSML処理系、[ML Kitに一部導入された](http://www.elsman.com/mlkit/pdf/pldi2002.pdf)（多分世界初） + 但し完全ではなく、GCと組み合わせてある + 動的型付き言語に無理矢理静的型を付けても完全には上手くいかないようなもの？ + 多分リージョン推論を前提とした言語を設計する必要がある * Cyclone というC likeな文法の言語が完全に[リージョン推論のみでメモリ管理を実現した](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf) === # 強い静的メモリ管理の話をしよう ------------------------------ * ✓ まずは可能性の議論が必要 * ✓ 実現可能性 * 実用性 === # 実用性 === # Rust言語 ---------- * Mozillaが開発した言語 * 2008~ * Cycloneを参考にしたらしい。 * 活発に開発される * 大きなプロジェクトに現行のレンダリングエンジン、Geckoを置き換えるべく開発された[Servo](https://github.com/servo/servo)がある + 既にC++製のGockoの3倍速い + 並列レンダリングすればさらに速い。 === # Rust言語 ---------- * リージョン推論(ライフタイム)でメモリを管理する - かなり賢くて、ヒープにアロケートする必要なけばスタックを使う。 * mallocとfreeは全てコンパイル時に自動で挿入される * (多分)リージョン推論のみでメモリ管理するために所有権という概念がある。 + 所有権自体は並列性の導入などにも有用だと思われる。 - 競合状態の回避とか * その他 + 代数的データ型とパターンマッチ + トレイトベース(non-nominal)のジェネリクス 詳細は[公式ページ](http://www.rust-lang.org/)から === # 強い静的メモリ管理の話をしよう ------------------------------ * ✓ まずは可能性の議論が必要 * ✓ 実現可能性 * ✓ 実用性 === # Rustのライフタイムと所有権 ------------------------- === # Cの例 ------- ```c { int *x = malloc(sizeof(int)); // we can now do stuff with our handle x *x = 5; free(x); } ``` === # Rustに翻訳 ------------ ```rust { let x = Box::new(5); } ``` === # 少しいじってみる --------------- trivialに見える ```rust fn main() { let x = Box::new(5); add_one(x); } fn add_one(mut num: Box) { *num += 1; } ``` === # 少しいじってみる --------------- printlnを追加してみる ```rust fn main() { let x = Box::new(5); add_one(x); println!(\"{}\", x); } fn add_one(mut num: Box) { *num += 1; } ``` === # 少しいじってみる ---------------- エラーになる。 ``` error: use of moved value: `x` println!(\"{}\", x); ^ ``` === # 所有権 ------- `add_one` を呼んだ時点で所有権が `add_one` に移るので `println!` では使えない。 ```rust fn main() { let x = Box::new(5); add_one(x); println!(\"{}\", x); } fn add_one(mut num: Box) { *num += 1; } ``` === # 所有権 ------- 新たに値を返してもらえば使える。 ```rust fn main() { let x = Box::new(5); let y = add_one(x); println!(\"{}\", y); } fn add_one(mut num: Box) - Box { *num += 1; num } ``` === # 所有権の貸し借り --------------- * さっきの例は面倒。 * `add_one` が `x` を奪ったのが問題。 * `x` を「借り」ることが出来る。 === # 所有権の貸し借り ---------------- ```rust fn main() { let mut x = 5; add_one(\u0026mut x); println!(\"{}\", x); } fn add_one(num: \u0026mut i32) { *num += 1; } ``` === # ライフタイム ------------ 先の `add_one` はライフタイム(リージョン)アノテーションを省略していた。 省略せずに書くとこうなる。(リージョン多相) ```rust fn add_one(num: \u0026'a mut i32) { *num += 1; } ``` === # ライフタイム ------------ スコープの終わりでライフタイムが終わる。 ```rust fn main() { let y = \u00265; // -+ y goes into scope // | // stuff // | // | } // -+ y goes out of scope ``` === # LTの明示的宣言 -------------- こんな構造体を宣言したとする。 `x` はコンストラクタに渡された値のライフタイムを引き継ぐ。 ```rust struct Foo { x: \u0026'a i32, } ``` === # LTの明示的宣言 -------------- `f.x`のライフタイムが `y` のライフタイムに制限されるので `y` より広いスコープにある `x` には代入出来ない。 ```rust fn main() { let x; // -+ x goes into scope // | { // | let y = \u00265; // ---+ y goes into scope let f = Foo { x: y }; // ---+ f goes into scope x = \u0026f.x; // | | error here } // ---+ f and y go out of scope // | println!(\"{}\", x); // | } // -+ x goes out of scope ``` === # まとめ ------- * メモリ管理の性質についてまとめた * 静的メモリ管理が出来れば + メモリ管理からの開放 + 実行時は安定している + リアルタイム + パフォーマンスが出る * 強い静的メモリ管理の手法としてリージョン推論がある * Rust言語がリージョン推論を利用している。 * Rustをみんな使おう! === # 参考 * [ML Kit](http://www.elsman.com/mlkit/) * [Rust](http://www.rust-lang.org/) * [Allocators in Rust - Baby Steps](http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/)   ","categories":["λ計算","リージョン推論","Rust"],"category_urls":["/categories/%ce%bb%e8%a8%88%e7%ae%97","/categories/%e3%83%aa%e3%83%bc%e3%82%b8%e3%83%a7%e3%83%b3%e6%8e%a8%e8%ab%96","/categories/rust"],"date":"2015-04-21","title":"静的なメモリ管理の話。リージョン推論とλ計算からRustまで","url":"https://KeenS.github.io/slide/seitekinamemorikanrinohanashi.rijonsuirontolambdakeisankararustmade/"},
  {"body":"κeenです。最近頻繁にSML#を使ってます。SML#のメイン機能の1つであるC連携ですが、ちょっと複雑なことをやろうとするとテクニックが必要になるので共有します。\nTwitterとかにコメントや突っ込みお願いします。\n簡単な型 型が簡単な関数なら普通に_importで済みます。\nval puts = _import \u0026#34;puts\u0026#34;: string -\u0026gt; () val () = puts \u0026#34;Hello, C\u0026#34; 尚、簡単な型とは公式ドキュメントにある通り、いわゆる即値、即値の組（タプル）、即値の配列、即値の参照、それらを引数、返り値に持つ関数などです。\n又、以下のような制約もあります。\n C関数全体の型は，引数リストを組型とするMLの関数型に対応付けられます． ただし，C関数の引数や返り値に書ける相互運用型には，以下の制約があり ます． 配列型や組型など，Cのポインタ型に対応する相互運用型を，C関数の返り値の 型として指定することはできません．\n 恐らくGCとの兼ね合いでしょうがつらいですね。stringすら返り値で受け取れません。\nそれにこの制約がどこまで効いてるのかが不明で、同じ型でも型付けに成功したり失敗したりすることがあります。例えば上の例でstring型を引数にとる関数をインポートしましたが関数に依ってはstringが相互運用型でないとか怒られることがあります。タプルの配列やタプルの参照などは確実にダメみたいです。\n尚、string型はCでいう const char * 、タプルは変更不能な構造体へのポインタになるそうです。構造体の即値は扱えないんですね…。また、参照とは別に ptr 型も存在します。SML#側からは作れず、Cとの相互運用のためだけに存在するようです。\n魔法の unit ptr じゃあ複雑な型はインポート出来ないのかというとそうでもなく、 unit ptr 型にしておけばとりあえずインポート出来ます。Cで言うところの void * です。 邪悪な雰囲気を感じますね。しかしそこは型安全言語、ちゃんと型安全に unit ptr を扱えます。\ntype file = unit ptr val fopen = _import \u0026#34;fopen\u0026#34;: (string, string) -\u0026gt; file val fgetc = _import \u0026#34;fgetc\u0026#34;: (file) -\u0026gt; int val fclose = _import \u0026#34;fclose\u0026#34;: (file) -\u0026gt; int val () = let val f = fopen(\u0026#34;test\u0026#34;, \u0026#34;r\u0026#34;) val c = fgetc(f) in print(str(chr c)); fclose(f) end はい。単に type で名前をつけてあげれば大丈夫です。SML#側ではポイント先が何であるかには関知せず、インポートしたC関数の間で完結してれば問題ありません。多くのライブラリはそのようなAPIになっているのではないでしょうか。\nポインタを扱う とはいえ時にポインタを扱う必要もあります。構造体の配列を扱えないのでその辺で。\nそういった時に便利なのが SMLSharp_Builtin.Pointer と Pointer です。 Pointer の方は .smi ファイルの中で _require \u0026quot;ffi.smi\u0026quot; してから使います。\nstructure SMLSharp_Builtin structure Pointer = struct val identityEqual = _builtin val IdentityEqual : boxed * boxed -\u0026gt; bool val advance = _builtin val Ptr_advance : \u0026#39;a ptr * int -\u0026gt; \u0026#39;a ptr val deref = _builtin val Ptr_deref : \u0026#39;a ptr -\u0026gt; \u0026#39;a val store = _builtin val Ptr_store : \u0026#39;a ptr * \u0026#39;a -\u0026gt; unit val toUnitPtr = _builtin val Cast : \u0026#39;a ptr -\u0026gt; unit ptr val fromUnitPtr = _builtin val Cast : unit ptr -\u0026gt; \u0026#39;a ptr val toCodeptr = _builtin val BitCast : unit ptr -\u0026gt; codeptr end end structure Pointer = struct val advance = SMLSharp_Builtin.Pointer.advance val load = case \u0026#39;a in \u0026#39;a ptr -\u0026gt; \u0026#39;a of int =\u0026gt; SMLSharp_Builtin.Pointer.deref | word =\u0026gt; SMLSharp_Builtin.Pointer.deref | SMLSharp_Builtin.Word8.word =\u0026gt; SMLSharp_Builtin.Pointer.deref | char =\u0026gt; SMLSharp_Builtin.Pointer.deref | real =\u0026gt; SMLSharp_Builtin.Pointer.deref | SMLSharp_Builtin.Real32.real =\u0026gt; SMLSharp_Builtin.Pointer.deref | \u0026#39;b ptr =\u0026gt; SMLSharp_Builtin.Pointer.deref val store = case \u0026#39;a in \u0026#39;a ptr * \u0026#39;a -\u0026gt; unit of int =\u0026gt; SMLSharp_Builtin.Pointer.store | word =\u0026gt; SMLSharp_Builtin.Pointer.store | SMLSharp_Builtin.Word8.word =\u0026gt; SMLSharp_Builtin.Pointer.store | char =\u0026gt; SMLSharp_Builtin.Pointer.store | real =\u0026gt; SMLSharp_Builtin.Pointer.store | SMLSharp_Builtin.Real32.real =\u0026gt; SMLSharp_Builtin.Pointer.store | \u0026#39;b ptr =\u0026gt; SMLSharp_Builtin.Pointer.store val isNull : \u0026#39;a ptr -\u0026gt; bool val NULL : unit -\u0026gt; \u0026#39;a ptr val importBytes : SMLSharp_Builtin.Word8.word ptr * int -\u0026gt; SMLSharp_Builtin.Word8.word vector val importString : char ptr -\u0026gt; string end load 、 store 、 deref 、 advance あたりを良く使いそうですね。\n実際にあった話。 struct header { const char *name; int name_len; const char *value; int value_len} の配列(struct header *)を扱う必要がありました。 その配列をCの関数に渡して書き換えてもらって、後で値を取り出したいという状況がです。その時値を取り出すコードがこれです。\nfun getHeader headers i = let val header_ptr : char ptr ptr = fromUnitPtr(headers) val header_ptr = advance(header_ptr, i * 2) val header_ptr : int ptr = fromUnitPtr(toUnitPtr(header_ptr)) val header_ptr = advance(header_ptr , i * 2) val header_ptr : char ptr ptr = fromUnitPtr(toUnitPtr(header_ptr)) val name = deref(header_ptr) val header_ptr = advance(header_ptr, 1) val header_ptr : int ptr = fromUnitPtr(toUnitPtr(header_ptr)) val nameLen = deref(header_ptr) val header_ptr = advance(header_ptr, 1) val header_ptr : char ptr ptr = fromUnitPtr(toUnitPtr(header_ptr)) val value = deref(header_ptr) val header_ptr = advance(header_ptr, 1) val header_ptr : int ptr = fromUnitPtr(toUnitPtr(header_ptr)) val valueLen = deref(header_ptr) in if isNull name then (NONE, String.substring(importString(value), 0, valueLen)) else (SOME(String.substring(importString(name), 0, nameLen)), String.substring(importString(value), 0, valueLen)) end まず、タプルは構造体へのポインタなので今回の struct header * は (string * int * string * int) ptr ではありません。それは struct header ** になってしまいます。 また、ポインタを扱う関数が ptr 型しか受け付けないので string ではなく char ptr にしておいて後から importString で文字列にする戦略をとります。\nそして配列のi番目にアクセスしたかったら先述の通り (string * int * string * int) ptr ではないので地道に char ptr ptr 2*i個分、 int ptr 2*i個分ポインタを進めます。 ポインタの型を変える時はダイレクトには変換出来ないようなので一旦 unit ptr を経由してから変換。そして次のメンバにアクセスするために advance という形をとります。\nそこまでしたら後は deref してあげれば欲しい値がとれます。\nREPLからのimportと DynamicLink SML#のREPLからも勿論インポート出来ますが、SML#のランタイムにリンクされてないライブラリのものはインポート出来ないのでダイナミックリンクを使います。 DynamicLink にCの dl* と同じ関数群が用意されているのでそれらを使います。\nstructure DynamicLink = struct type lib (= ptr) datatype scope = LOCAL | GLOBAL datatype mode = LAZY | NOW val dlopen : string -\u0026gt; lib val dlopen\u0026#39; : string * scope * mode -\u0026gt; lib val dlsym : lib * string -\u0026gt; codeptr val dlsym\u0026#39; : lib * string -\u0026gt; unit ptr val dlclose : lib -\u0026gt; unit end val lib = dlopen(\u0026quot;libawsome.so\u0026quot;) でライブラリのオープン、 dlsym(lib, \u0026quot;awm_function\u0026quot;): _import () -\u0026gt;unit で読み込みです。\nこれでインポートする関数は必要になった時に読み込んで欲しいのですがトップレベルで val でバインドすると即読み込まれてしまいます。その辺を上手くやるテクニックがSML#のソースにありました。MySQLのバインディングの部分です。\nfun lazy f = let val r = ref NONE in fn () =\u0026gt; case !r of SOME x =\u0026gt; x | NONE =\u0026gt; let val x = f () in r := SOME x; x end end val lib = lazy (fn _ =\u0026gt; DynamicLink.dlopen (case OS.Process.getEnv \u0026#34;SMLSHARP_LIBMYSQLCLIENT\u0026#34; of NONE =\u0026gt; \u0026#34;libmysqlclient.16.\u0026#34; ^ SMLSharp_Config.DLLEXT () | SOME x =\u0026gt; x)) fun find s = DynamicLink.dlsym(lib (), s) val mysql_init = lazy (fn _ =\u0026gt; find \u0026#34;mysql_init\u0026#34; : _import (MYSQL) -\u0026gt; MYSQL) ... 遅延評価してますね。これ。呼び出す時は mysql_init () (mysql) みたいに一旦lazyを剥がさないといけないので注意です。\n問題とか Cの仕様 確かCの仕様上構造体のメモリ上の表現にはメンバ以外のものも置いていいことになっていた筈です。 上の方法では変なコンパイラでコンパイルしたコードだと動きそうにないですね。GCCやClangは大丈夫な筈。\nそもそもSML#自体GCCとABI互換なコンパイラでコンパイルしたものじゃないとリンク出来なそうな気がするので杞憂ですかね。\nメモリ確保 Cの関数から構造体のポインタが返ってくるケースだと良いんですが自分で構造体を用意してCの関数に渡すケースだとメモリの確保が問題になります。現状、\nstruct header *prepare_headers(int n) { return malloc(n * sizeof(struct header)); } みたいなヘルパ関数を用意して凌いでますが欲しい構造体毎に書かないといけないのであまり嬉しくないです。 sizeof をSML#側でとれれば単に malloc をバインドするだけで済むのに。 もう少し欲を言うと malloc したらGCから外れそうな気がするので明示的に free する必要がありそうです。GCに載るメモリ確保関数も欲しいですね。 さらに欲を言うとスタックアロケートする版のメモリ確保関数も欲しい。もしかしたら alloca で大丈夫なんでしょうか。\n#define ヘッダファイル内で定数を #define してあることが多々あります。それらは地道に手書きでSML#側に持ってくることになりますが気になるのが互換性の問題。 特にOSのヘッダファイルには名前は同じだけどOS毎に値が異なるものが存在します。シグナルとか。OSで条件分岐するか理想的にはプリプロセッサのサポートがあればどうにかなりそうなんですけどねぇ。 現状だとCで定数を返すgetter関数を書いてSML#側でインポートして…ってやればどうにか出来そうですけどやりたくないですね。\n変数 私はまだ遭遇してないのですがライブラリによってはグローバル変数にアクセスしないといけないものが存在します。これもgetterとsetterを書いて…ってやるとどうにか出来そうですがどうせなら変数のインポートも出来ると良いですよね。\nまとめ  SML#でCのバインドを書く時は少しテクニックが必要 SML#にはポインタを直接扱える関数もある それでも機能が足りない時はCでヘルパ関数を書こう。 ダイナミックリンクライブラリも扱えるよ ","categories":["ML","SML","SMLSharp"],"category_urls":["/categories/ml","/categories/sml","/categories/smlsharp"],"date":"2015-04-19","title":"SMLSharpでFFIバインディングを書く時の知見","url":"https://KeenS.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken/"},
  {"body":"κeenです。SmlSharpContribにコントリビュートしてます。そこでファンクタを使う用事があったのですが少し踏み込んだ使い方をしようとしたらハマったのでメモ。\nファンクタおさらい SMLのfunctorはstructureに引数がついたもので、モジュールを引数にとり、モジュールを返します。\nfunctor List (Args : sig type elem end) = struct type elem = Args.elem datatype list = Nil | Cons of elem * list fun length Nil = 0 | length (Cons (x, xs)) = 1 + length xs end structure IntList = List(struct type elem = int end) 複雑なファンクタ 以前mlyaccを使った時にJoinなる3つのモジュールを引数にとるファンクタが登場したのでした。\nstructure PrologParser = Join(structure LrParser = LrParser structure ParserData = PrologParserLrVals.ParserData structure Lex = PrologLex) これの定義を覗いてみます。\nfunctor Join(structure Lex : LEXER structure ParserData: PARSER_DATA structure LrParser : LR_PARSER sharing ParserData.LrTable = LrParser.LrTable sharing ParserData.Token = LrParser.Token sharing type Lex.UserDeclarations.svalue = ParserData.svalue sharing type Lex.UserDeclarations.pos = ParserData.pos sharing type Lex.UserDeclarations.token = ParserData.Token.token) : PARSER = ... 複数のモジュールの他にsharingなるキーワードも出てきています。それにstructureキーワードもプリフィクスされています。\n先程の例とは大分離れてますね。何があったのでしょう。structureを付けとけば複数書ける…？\n省略記法 実はファンクタの引数の中では省略記法が使えます。引数のモジュール名とsig ... endが省略可能なのです。さらに適用の時もstruct ... endも省略可能なのです。\nつまり、最初の例はこうも書けるのです。\nfunctor List (type elem) = struct type elem = Args.elem datatype list = Nil | Cons of elem * list fun length Nil = 0 | length (Cons (x, xs)) = 1 + length xs end structure IntList = List(type elem = int) モジュール内モジュールと省略記法 そうです。複雑怪奇なJoinファンクタは省略記法で書かれていたのでした。省略せずに書くと\nstructure PrologParser = Join(struct structure LrParser = LrParser structure ParserData = PrologParserLrVals.ParserData structure Lex = PrologLex end)functor Join(X: sig structure Lex : LEXER structure ParserData: PARSER_DATA structure LrParser : LR_PARSER sharing ParserData.LrTable = LrParser.LrTable sharing ParserData.Token = LrParser.Token sharing type Lex.UserDeclarations.svalue = ParserData.svalue sharing type Lex.UserDeclarations.pos = ParserData.pos sharing type Lex.UserDeclarations.token = ParserData.Token.token end) : PARSER = ... となります。形式的には引数のモジュールは1つでありながら事実上複数のモジュールを渡していたのです。structureが付いていたのはモジュール内モジュールだったから、sharingはモジュール内モジュールに対する制約宣言です。\nなぜこれでハマったかというとSML#のインターフェースファイルでは省略記法が使えなかったからです。地雷の数だけ強くなれるよ♪\n参考  モジュール - ウォークスルー Standard ML ファンクタのサポート in Ch.11. SML#分割コンパイルシステム in プログラミング言語SML#解説 ","categories":["ML","SML"],"category_urls":["/categories/ml","/categories/sml"],"date":"2015-04-12","title":"SMLのファンクタに少し踏み込んだ","url":"https://KeenS.github.io/blog/2015/04/12/smlnofankutanisukoshifumikonda/"},
  {"body":"κeenです。少し遅くなりましたが4/1付で所属が変わったので報告です。\nタイトルにあるように、株式会社サイバーエージェントに入社しました。こう言うとよく「あれ？サムライトじゃないの？」「もっとストイックな所に行くと思ってた」と言われます。サムライトについては特に関係はないです。エンジニア2人と知り合いなだけです。Common Lispだけが幸せの基準じゃありません。 それにキラキラ女子のイメージが強いかもしれませんがサイバーエージェント、結構ストイックですよ？\n 因みに昨日までで全体研修が終わり、月曜から技術研修が始まります。技術研修を受けずに早期配属される同期や果ては社長になる同期も居る中のんびり6月末まで研修を受けます。フロント周りはからっきしなのでこれを機にその辺も勉強しようかと。\n研修はグループワークが多かったのですが一緒のチームにいて優秀だなと思える人に何人も会ってきたしバックグラウンドを訊いてみて尖ってるエンジニアも一杯いたので正式配属されるのが楽しみです。私もそれなりに尖ってるつもりだったのですが精進が足りませんね。\nまあ、マイペースに歩んでいきます\nよし、来年Clojureおじさんになろう\n\u0026mdash; κeen (@blackenedgold) 2014, 7月 16 \n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2015-04-10","title":"CyberAgentに入社しました","url":"https://KeenS.github.io/blog/2015/04/10/cyberagentninyuushashimashita/"},
  {"body":"最近ではUTF-8でソースコードを書いてUTF-8で出入力をする。それ以外のエンコーディングは使われていない。…だと？誰がそんなこと言ったんだ\nASCIIと古いUnicodeと新しいUnicode 少し長くなるが文字コードの話から始まる。ASCIIはお馴染み最低7bitあればASCIIの定義する文字集合を表せる。\n古いUnicodeは16bitで全ての文字を表わすことを目標に作られた。\n新しいUnicodeは文字(主に漢字)が多過ぎて16bitでは表せなかったので21bitに拡張された。\n文字コードとエンコーディング 文字コードをどういう形式で表すかがエンコーディングだ。文字コードが7bit、16bit、21bitだからといってそのままのサイズで表わす訳ではない。ASCIIは普通8bitの型で表わすし21bitの型を用意するよりは32bitの型に格納した方が扱い易そうだ。あるいは8bit型の配列に16bitや21bitを収めるとプログラムコードの変更が少なそうだ。\nUTF-8とUTF-16とUTF-32 さて、ここまで来ればお分かりだろう。UTF-8はASCIIとの互換性を保つ8bitベースのエンコーディング、UTF-16は古いUnicodeの時に作られて新しいUnicodeにも対応した16bitベースのエンコーディング、UTF-32は新しいUnicodeのために作られた32bitベースのエンコーディングだ。 ここで注意して欲しいのはUTF-8とUTF-16は8bitや16bitの単位を複数使うことで新しいUnicodeの範囲も扱える点、逆に言えば1単位が1文字に対応しない点だ。日本語を含んだ文字列に対してlengthを使うと正しい結果が帰って来ないなどの経験は誰しもあるだろう\nUTF-8とUTF-16とUTF-32それぞれの特徴 UTF-8 8bit(オクテット)の配列に文字列を収めることになる。16bitや21bitの範囲の文字を表す時は8bitに対してASCIIは7bitしか使わないのでその1bitを使って次に続くことを表わす。最大4オクテットまで使うことがある。 UTF-8の特徴はなんと言ってもASCIIとの互換性があること。UTF-8でASCIIの範囲のみの文字をエンコードするとASCIIと同一になるし、ASCIIでエンコードされたものはUTF-8で読んでも同じ内容になる。なのでどんなエンコードか分からないものはとりあえずUTF-8で読んでおくと間違いが少ない。よって冒頭で書いたように出入力、保存ファイル、GUIに表示する文字列などに使われる。\nUTF-8にも欠点はあり、ASCII外の文字を大量に扱うと空間効率が悪い。さらに先頭から順番に辿らないとどのオクテットが何文字目かも分からないので(配列長が既知であっても)文字列へのlengthやランダムアクセスなどの多くの操作がO(n)になってしまう点だ。文字の置換に至ってはin placeでは出来ないことすらある。\nUTF-16 16bitの配列に文字列を収める。21bitまで扱うために特定の範囲の値が来たら次の16bitも読んで2つ併わせて1つの文字とみなす。このペアをサロゲートペアという。C言語にはwcharなるマルチバイト文字用の型があるが、仕様では最低で16bitという要求になっているのでwcharを使う時はUTF-16でエンコードする（と思う）。UTF-16もUTF-8と同じく文字列操作がO(n)になる。Unicode公式のエンコーディングであるという点を除いて特に良い点が見当たらないので後方互換性の必要な場面でないと使われてなさそうな気がする。例えばWindowsのファイルシステムはファイル名をUTF-16で保持しているらしい。\n尚、16bitのエンディアンは指定されてないのでファイルの先頭にバイトオーダーマーク(BOM)と呼ばれる空白文字を置いてそれでエンディアンを指定/判別する慣習になっている。\nUTF-32 32bitの配列に文字列を収める。必ず32bitで1文字を表すので文字列操作が効率的に行なえる。欠点はASCIIの範囲の文字が多いとメモリを無駄にし易い点。どんな文字列を扱うか分からない(ASCIIの範囲が多いとは言い切れない)汎用ライブラリや言語処理系そのものでよく使われる。\n言語処理系の内部表現と外部エンコーディング ここで罠になるのがソースコードをUTF-8で書いて出入力をUTF-8で行なう処理系でも内部では先述の理由でUTF-8以外を使うことがあることだ。メジャーな言語について少し調べてみた。\n SBCL(Common Lispのメジャーな処理系)はUTF-32を使う SpiderMonkey(FirefoxのJavaScript処理系)はUTF-8を使う。HTMLはマルチバイト文字を使う言語で書かれていても大半がASCIIになるからとのこと。また、文字列をropeで表現しており、UTF-8のデメリットを軽減出来る。 Rubyは多言語対応の時に内部表現はなんでもアリ(渡された文字列そのまま)になった PerlはUTF-8を使う PythonはconfigureのオプションでUCS2(ほぼUTF-16に同じ)やUCS4(UTF-32形式のUnicodeと概ね互換)が選べる。FedoraやUbuntuはUCS4でビルドしている PHPは言語で動的に変更出来る  ソースコードをUTF-8で書いて出入力をUTF-8で行なうから変換コストなんてないと思ったら大間違いだ。裏ではUTF-32が使われていて、出入力の度に変換が走る。誰がUTF-32が使われてないなんて言ったんだ。\n","categories":["言語処理系","エンコーディング"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%87%a6%e7%90%86%e7%b3%bb","/categories/%e3%82%a8%e3%83%b3%e3%82%b3%e3%83%bc%e3%83%87%e3%82%a3%e3%83%b3%e3%82%b0"],"date":"2015-03-31","title":"誰がUTF-32が使われてないなんて言ったんだ","url":"https://KeenS.github.io/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda/"},
  {"body":"# caveman2、ningle、datafly…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト ---------------------- Clack Meet Up #1 2015-03-05 @サムライト === ずっと俺のターン === # 問題 ------ Common Lispは case * Sensitive * Insensitive どっち? === # 問題 ------- あれ？ ```lisp (eql? 'CaseInsensitive 'caseinsensitive) ;= t ``` === # 問題 ------- リーダがデフォルトで大文字にするだけ ```lisp (eql? '|CaseSensitive| '|casesensitive|) ;= nil ``` === # Caveman2 --------- ```lisp @route GET \"/hello\" (defun say-hello (\u0026key (|name| \"Guest\")) (format nil \"Hello, ~A\" |name|)) ``` === # Ningle -------- ```lisp (setf (ningle:route *app* \"/login\" :method :POST) #'(lambda (params) (if (authorize (getf params :|username|) (getf params :|password|)) \"Authorized!\" \"Failed...Try again.\"))) ``` === # 面倒… ---- デフォルトでそのままだたっらいいのに === # 魔法の`readtable-case` === # 魔法の`readtable-case` ----------------------- ```lisp (setf (readtable-case *readtable*) :invert) ``` を使えばOK 参考: [SBCLでclispとかallegroのmodern mode的なことをする - wasabizの日記](http://wasabiz.hatenablog.com/entry/20120929/1348889601) === # 例 ---- ```lisp CL-USER :username :USERNAME CL-USER (setf (readtable-case *readtable*) :invert) :invert CL-USER :username :username ``` === # まとめ -------- * `(setf (readtable-case *readtable*) :invert)`を使うと快適だよ   ","categories":["Lisp","Common Lisp","小ネタ"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2015-03-05","title":"caveman2、ningle…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト","url":"https://KeenS.github.io/slide/caveman2-ningle...common-lispnowebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/"},
  {"body":"κeenです。勉強会などで役立ちそうなLispエイリアンの矢印を作りました。\nLispエイリアンの元データはこちらでPNGやSVGで公開されているのでInkscapeの練習がてらそれをいじりました。\nどうぞ\nlisplogo_alien_arrow.svg\nライセンスは元データに倣ってパブリックドメインとします。\nPNG形式のもの必要…ですか？\n","categories":["Lisp","小ネタ"],"category_urls":["/categories/lisp","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2015-03-03","title":"Lispエイリアンの矢印作った","url":"https://KeenS.github.io/blog/2015/03/03/lispeiriannoyajirushitsukutta/"},
  {"body":".red { color: red; }  # 既存のテンプレートエンジンの問題点と再設計、あるいはArrowsについて ----------------------------------------------------------------- Clack Meet Up #1 2015-03-05 @サムライト === # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + [@blackenedgold](https://twitter.com/blackenedgold) + Github: [KeenS](https://github.com/KeenS) + 野生のLisper + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます === # Template Engines === # Existing Architeture ---------------------- 0. (リクエスト) 1. アプリ 0. 引数を計算 1. テンプレートに引数を渡す 2. レスポンスをレンダリング 4. レスポンスをサーバに渡す 5. (レスポンス) === # Rendering? ---------------------- * 結合した文字列はクライアントに返ったらその後はゴミ + GCへ負荷がかかる (後述) * クライアントにとって1つの文字列である必要はない * むしろ返せる部分だけ先に返した方が得（後述） === # GC Pressure (SBCL) ----------------- * 世代別Copy GC * 結合した文字列は比較的大きい * `alloc_space`に入らない大きさならアロケートが遅い * GCを頻繁に起動してしまう * 16KBを越えると特別扱いされて遅い/メモリを喰う * LispのWebアプリはレスポンスタイムの分散が大きい（要出展） 参考: [SBCL GENCGC @ x86 Linux](http://cl-www.msi.co.jp/reports/sbcl-gc-memo.html) === # Split Response --------------- 例えば、こんなの \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html xmlns=\u0026quot;http://www.w3.org/1999/xhtml\u0026quot; xml:lang=\u0026quot;en\u0026quot; lang=\u0026quot;en-us\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;http://localhost:1313//reveal.js/lib/css/xcode.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; .... \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026quot;li-body\u0026quot;\u0026gt; \u0026lt;header\u0026gt;{{ header }}\u0026lt;/header\u0026gt; {{ body }} ...  === # Split Response --------------- 1. `{{ header }}`の前に先頭から``までを返す 2. `{{ header }}`を返す 3. ``を返す 4. `{{ body }}`を返す ... === # Pros of Split Response ------------------------ * `header`を計算してる間にクライアントにhead部分が渡る + 先に``や``を要求出来る + サーバ側のスループットやレスポンスタイムは変わらないが クライアントのレンダリング完了までの時間は大幅に短縮出来る * 文字列を結合する必要がない * 定数部分については長さが判ってるので最適化し易い === # How TEs Work --------------------------- ## Compilation 1. テンプレート文字列 + パーサ 2. 抽象構文木 + コードエミット 3. レンダリング関数 === # How TEs Work --------------------------- ## Rendering 1. レンダリング関数 + 引数 2. 文字列 === # Misc Problems --------------- * サーバに渡すのは文字列なのにソケットに書き込む時はオクテット？ + 文字列で返す？オクテットで返す？（デバッグがー） + オクテットの変換はいつ？ * ストリームが遅い？ + POSIX APIが使える\"なら\"fdの方が速い？ * ユーザが用意したバッファに書き出したい？ * テンプレートに渡す引数が定数文字列なら畳み込める筈？ * リクエストの度にテンプレートパースするのは筋悪だけど開発中は毎回コンパイルするのは面倒？ === # Arrows Template flies like an arrow === # Arrows -------- * [KeenS/arrows](https://github.com/KeenS/arrows) * 現在開発中のテンプレートエンジン * 複数のテンプレートが選べる（予定） * 複数のバックエンドが選べる * バックエンドに依ってはnon-consing === # How Arrows Works ------------------ ## Compilation 1. テンプレート文字列+ 定数引数 + パーサ(default, cl-emd互換...) 2. 抽象構文木 + 最適化(const folding, concat, convert...) + コードエミット 3. レンダリング関数(string, octets, stream, fast-io ...) === # How Arrows Works ------------------ ## Rendering 1. レンダリング関数 + 引数 2. 文字列、オクテット列、ストリーム書き出し、fast-io… === # How compiled -------------- ```html Hi {{var name}}! ``` を ```lisp (compile-template-string :xxx \"Hi {{var name}}!\" ()) ``` とコンパイル === # Stream backend ---------------- ```lisp (lambda (stream \u0026key name) (write-string \"Hi \" stream) (write-string (encode-for-tt (princ-to-string name)) stream) (write-string \"!\" stream)) ``` * ほとんどアロケートしない === # Octet backend ---------------- ```lisp (lambda (\u0026key name) (with-fast-output (buffer) (fast-write-sequence #.(string-to-octets \"Hi \") buffer) (fast-write-sequence (string-to-octets (encode-for-tt (princ-to-string name))) buffer) (fast-write-sequence #.(string-to-octets \"!\") buffer))) ``` === # How optimized --------------- ```html Hi {{var name}}! ``` を ```lisp (compile-template-string :stream \"Hi {{var name}}!\" '(:known-args (:name \"\"))) ``` とコンパイル === # How optimized --------------- ## variable folding ```lisp (lambda (stream) (write-string \"Hi \" stream) (write-string (encode-for-tt \"\") stream) (write-string \"!\" stream)) ``` * 既知の引数は畳み込む * 文字列なら`princ-to-string`しない === # How optimized --------------- ## const folding ```lisp (lambda (stream) (write-string \"Hi \" stream) (write-string \"\u0026lt;κeen\u0026gt;\" stream) (write-string \"!\" stream)) ``` * 定数のエスケープはコンパイル時に済ませる === # How optimized --------------- ## append sequence ```lisp (lambda (stream) (write-string \"Hi \u0026lt;κeen\u0026gt;!\" stream)) ``` * 複数シーケンスの書き出しは1つにまとめる === # Further Ideas --------------- * 引数計算の遅延 * 引数計算の並列化 * 非同期化 * HTML compction === # Further Ideas --------------- ## 引数計算の遅延 * `name`の計算が重いときに先に`\"Hi \"`を返す。 * `name`は必要になったら値を計算する(Promise パターン) ```lisp (lambda (stream \u0026key name) (write-string \"Hi \" stream) (write-string (encode-for-tt (princ-to-string name)) stream) (write-string \"!\" stream)) ``` === # Further Ideas --------------- ## 引数計算の並列化 * `name`の計算が重いときに先に`\"Hi \"`を返す。 * `name`は並列に計算して必要になったら値を要求する(Futureパターン) ```lisp (lambda (stream \u0026key name) (write-string \"Hi \" stream) (write-string (encode-for-tt (princ-to-string name)) stream) (write-string \"!\" stream)) ``` === # Further Ideas --------------- ## 非同期化 * 単純にwriteを非同期にする * 他にFutureもブロックするので非同期Futureを使う === # Further Ideas --------------- ## HTML compction ```html   item 1   item 2   item 3   ``` を ```html item 1item 2item 3 ``` * DOM構造が変わってしまう === # TODOs ------- * 設計上複数シンタックスをサポート可能だがまだしてない * 既存のテンプレートエンジンとの比較ベンチマーク * 高速化 * 多機能化 + テンプレート + 最適化 + バックエンド * clackとの連携 + clackのAPIはメモリアロケーションが多めに必要になる === # Summary --------- * 既存のテンプレートエンジンは非効率 + メモリを無駄遣いしていた + ユーザーのことを考えてなかった * 新しいテンプレートエンジンを設計した + メモリアロケーションをあまりしない + ユーザー側の速度まで考慮した + 柔軟   ","categories":["Lisp","Common Lisp","Arrows"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/arrows"],"date":"2015-03-02","title":"既存のテンプレートエンジンの問題点と再設計","url":"https://KeenS.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaarrowsnitsuite/"},
  {"body":"κeenです。先日の記事がやたら拡散しました。その中で\n「面接でLispは口にしない方が良い。100%落ちる。」\nの一文がえらく気に入られたようです。Lispの風評被害を防ぐために1つアンケートにご協力下さい。\nこのスプレッドシートです。\n面接でLispを口にして落ちない企業調査表 - Google スプレッドシート\n「うちの会社は面接でLispを口にしても落ちないぜ」って方はお手隙ならば書いて下さると嬉しいです。単純な興味目的のゆるふわなアンケートです。調査項目は\n 会社名 会社のURL 書いた人(本名、スクリーンネーム、なんかのIDかは任意。IDにすると連絡がとれて便利かも) コメント、会社のアピールなど(長文可、任意)  で。\n利用規約(？)は\n 社員が書く。会社に全く書かない人は勝手に書かない。 改竄を防ぐために一度書いたら同じ人しか編集してはいけない。同じ会社の人でもダメ。 どっかのメディアに掲載されても怒らない。 メディア側は改竄なしでリスト全部を引用し、引用した日時も付記する。あるいはURLにリンクを張る。二次引用は禁止する。 問題が生じたら管理者(@blackenedgold)がこのスプレッドシートを非公開にする。  こんなもんですかね。ゆるふわアンケートなので書く側もゆるふわな気持でお願いします。\n補足 「面接でLispは口にしない方が良い。100%落ちる。」について補足 振り返ってみるとそんなことはありませんでした。就活のある時点までは確かに真で、次の面接でLispを口にしなかったら落ちなかったのでそんなイメージになってました。 しかしよく考えたら私が内定頂いたところはむしろ全部Lispのおかげで内定頂きました。こっちの情報の方が大事だった。拝承。\n","categories":["番外編","Lisp"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8","/categories/lisp"],"date":"2015-02-10","title":"面接でLispを口にして落ちない企業、私気になります！","url":"https://KeenS.github.io/blog/2015/02/10/mensetsudelispwokuchinishiteochinaikigyouwatashikininarimasu/"},
  {"body":"私は今4年生なので去年の今頃は就活なんてものをしていた。下の代から若干日程が変わっているがそろそろ就活ムードが出てきているのでなんか吐いておく。思い出かもしれないし愚痴かもしれないし毒かもしれない。経験かもしれないし他人の代弁かもしれない。後輩の役に立つかもしれないし人事の方に向けたメッセージかもしれない。\n念のために書いておくが私はIT系の会社のプログラマ、エンジニア職ばかり応募していた。他の業界、職種に当て嵌まるとは限らない。\n注意\n 良かった企業は名前を出す、悪かった企業はここには名前を書かない方針にする。悪かった企業の具体名が知りたかったら@blackenedgoldに訊いて下さい。  リクナビ、メール 周りの流れに乗せられてリクナビに登録することになる。個人情報を大量に打ち込む。すると大量のメールが届く。正直、情報量はゼロに近い。メールは受信しないにチェックした方が良い。\nリクナビの価値は3割くらいがポータルサイトとしての価値、残り7割くらいがリクナビ経由でしか募集してない企業にエントリーするためだけのもの。そういう企業にエントリーしないならリクナビにはあまり近寄らない方が良い。リクナビのサイトは非常に良く出来ていて、不安を煽る情報を的確に伝えてくる。本当にその辺の企業のサイトに爪の垢を煎じて飲ませてやりたいくらいに良く出来ている。\n一応何社かはリクナビ経由で知ってエントリーした。一々個人情報を手打することなくワンクリックでエントリー出来るのは負担を軽減してくれる。統一されたUIで情報を見れるのにはそれなりの価値はある。でもあまり齧りつきすぎると毒に冒される。2週間程放置しておくと「企業からの特別オファー」なる量産メッセージが1000通くらい溜まる。\nTwitterや勉強会で社員と知り合って採用情報などを得られるならそっちを頼った方が良い。Twitterに流れてくる情報の方が有用。\n説明会 エントリーに必須でない限り行かなかった。少なくともIT系企業ならWebページの採用情報が一番情報が充実して然るべきだ。\nマイページ、エントリーシート、性格診断 リクナビ経由でエントリーしても結局は企業毎のマイページなるものに登録し、そこで情報を得ないといけない。エントリーシートの提出や面接の登録など。\nマイページ IT系の企業ならまずはそのマイページが評価基準になる。外注としても最低限のラインというのがある筈だ。マイページ登録にもまた個人情報を大量に打ち込む。まずエントリー時点でそこまで情報が必要なのか、とか大量の情報を入力させるに当たってどこまでUXを考えてるかとか。\n事例1 とあるグローバル人材を求める企業  入力項目の説明に日本語と英語を併記していた。半分はゴミ情報なので酷く見づらかった 最初に出身大学が国内か海外かのラジオボタンがあった。その次に出身大学を選ぶウィザードがあった。ウィザードの最初の質問は「出身大学は国内ですか？海外ですか？」のラジオボタン。 住所と郵便番号も同じようなウィザードだった。住所をウィザードで選んでいくと郵便番号が自動で入力される。その次の項目は住所を手入力だった。  事例2 Yahoo! JAPAN 具体的には覚えてないけど入力補完があった。郵便番号を入力すると住所も自動で入力された。一番使い易かった。\n事例3 ワークスアプリケーションズ テクノロジスペシャリスト採用 そもそもマイページは必要なかった。エントリーには2〜3個のフォーム入力と返信用のメールアドレスのみで良かった。最高。\n次にマイページの内容。クッキーを焼いて「こんにちはn回目の訪問ですね」なんてやってたら即切る。大抵対応ブラウザも書いてあるからそこも見る。モダンブラウザはサポート外とか言ってたら渋い顔になる。私の就活後半は丁度Windows XPのサポートが切れた時期なのでその辺でまだIE 6のサポートをしてたらやっぱり渋い顔になる。対応OSがWindowsとOS Xとか書いてたらキレる。IT系でLinuxユーザは相手にしないだと？\nエントリーシート 割と企業の個性が出る。熱意とか意気込みとかはコピペなりでどうにでもなってしまうので適当に書く。そればっか訊いてくるところはエントリーをやめる。書くのに手間が書かるのにまともな基準で評価されてるか分からないから。簡単に詐称可能でしょ…\nこれまでの実績とかを訊いてきたらGithubアカウントとかTwitterアカウントとかブログとか大会実績とか過去のLT資料とかを張る。興味のある分野を書く。大抵Markdown形式で書いたがどこもプレビューで改行エスケープをしてなかったので箇条書きが酷く見辛かった。字数は気にしない。\n性格診断 最悪の体験。まず、Windows+IEかOS X+Safariにしか対応してない。単に対応してないだけじゃなくてご丁寧にUAを見てそれ以外を弾く。IT系ならLinuxユーザも居るだろうに。そして内容だが、似たような質問を何度も繰り返す。ただでさえWindowsを使わされてイライラさせられているのに更に追い討ちを掛けてくる。さっきも答えただろ、と悪態をつきながら地獄の20分に耐えることになる。SAN値がほぼ0になる。あれをやらせてる人事の方々は一回体験してみた方が良いと思いますよ。その上であの性格診断が必要か判断して下さい。どっかの企業で性格診断無視してたら普通にそのまま選考進んだ。マジで存在価値が分かならい。\n筆記試験 SPだっけ？IS？なんかそんなやつ。一回だけ受けた。さんすうとこくごの問題をひたすら解く。英語もあったっけ？覚えてないや。指定の会場じゃないと受けられないし順番待ちがあるしクソみたいな問題しか出ないし2回目は受けたくない。何の判断に使われるかもイマイチ分からない。必要ないなら止めて欲しい。\nそれではなくて情報技術/科学に関する問題を出してきたところがあった。LINE。カバー範囲が広く、全ての問題に正当することは要求しない。回答を見て適正を決めて次の面接官を決めてたらしい。非常に良い。出来れば問題用紙を持ち帰らせてくれれば後学に使えたのにと思った。問題使い回してるのかな？\nプログラミング課題 課してくるところは少なかった。楽しいプログラミングかと思いきやそうでもなかった。\n事例1 言語指定があった。Java。しかもJavaで解くには凡そ不向きな問題。つながりのある複数の問題だったのに1問につき1ファイル指定で共通する機能をクラスに切り出すことも許されなかった。因みにお題は「共通化を考えながら解け」。\n事例2 仕様があいまいだった。「与えられた入力に対して」。入力はどう与えられるの？標準入力？コマンドライン引数？関数の引数？どれでも良いならそう書いて欲しい。さらに悪いことに時間指定があった。4時間。それは良いんだけど40分くらいで解いて提出したらログインセッションが切れてた。もう一回ログインしたらもう一回課題を受けれた。既に手元に回答は準備してあるので即座に提出したら普通に受理された。よくわからない。ちなみにその企業は唯一エントリーシートで落ちた。\n面接 自分の話じゃないけどエントリーしまくってた友人は交通費で破産しかけてた。交通費は出してくれると嬉しいけど手続面倒だよねー。Skype面接とか？自分は近場の企業を、それも少数だけにしかエントリーしない方針で凌いだ。1つ落ちたら1つ新たにエントリーした。\nスーツはあまり着たくない。特にIT系なら勤務も私服だし面接も私服OKなところが多い。服装に言及がないとかスーツ必須とかだと悪目立ちする。服装に言及がないときは募集ページのプログラマが私服かどうかで判断していた。一回、募集ページは私服なのに面接官はスーツを着ていることがあった。面接だから、とのこと。学生相手にそこまで気を遣う必要はないと思うのだがお作法なのだろうか。あとエレベータホールまで見送りにきてさらにエレベータの扉が閉まるまで深々と御辞儀されるのも恐縮だ。\n内容はまあいいや。変な質問をされたことはない。こちら一人に対して面接官3人とか4人とかは圧迫感があって嫌だった。あ、一回「スクリプト言語でもディスクIOバウンドやネットワークIOバウンドなら高速なアプリケーションを書ける」と言ったら面接官に「は？」って言われたのが気になった。CPUバウンドじゃないならアーキテクチャの問題だからむしろアプリを簡単に書き換えられるLLで記述すべきでしょ。因みにその面接で落ちた。\n面接でLispは口にしない方が良い。100%落ちる。\n最後に質問はあるかと聞かれる。そんなものはない。エントリーした時点で公開情報で十分納得してある。内定が出たら即座に決めるつもりだ。もう情報は必要ない。面接が早く終われば授業に間に合うかもしれない。早く帰してくれ。聞ける場を用意してくれるのは非常に良いことなんだが質問の内容で評価するのは止めてほしい。\nその他の事も色々言いたい。\n時間 なんか大学生なんだから暇でしょみたいな雰囲気になってる。そんな訳はない。普通に授業がある。遊んでる大学生はごく一部だ。少なくともうちの大学だと遊べるのは1、2年までで3、4年からが勉強の本番になる。空き時間はレポートなりゼミの準備なりバイトなりサークルなりのために空けてある。面接と往復の時間を考えたら授業を1つ2つ犠牲にする必要がある。一応空いてる時間を訊いてくるがこちらが指定しても「それだとこちらが都合が悪いので他を指定して下さい」となって結局授業を潰すことになる。面接にしろ試験にしろ無駄なステップは省いて欲しい。学生の本分は勉強だ。\n時刻 機械送信のメッセージの他に手動で送られてくるメールや電話がある。あれの時間は結構気にする。まず、電話はやめて欲しい。電話で連絡取るにしても掛け直すときは前回とは時間帯をずらすとかしてほしい。学生なのだから毎日時間割ベースで活動している。電話をとれない時間帯は固定されている。前日と同じ、電話をとれない時間に電話が掛かってきたら正直バカなの？と思ってしまう。\nあと遅い時間や休日に連絡が来るとあまり良い顔にはならない。困る訳じゃなくて社員がその時間に活動しているということは残業や休出があるということだ。出来ればそういう会社は避けたい。\nOB訪問 ある企業でマイページ作ったらOB(というか同じ大学出身なだけの全く関係のない社員)と会う場をセッティングされそうになった。しかし相手は人事。話をしたいとしたらエンジニアだ。人事の方には興味はない。無駄な時間は使いたくない。\nエントリーする企業の決め方 Twitterや勉強会で知った人とかあるいは興味の湧くスライドを書いた人とかの会社を採用ページを見るところから始める。募集要項を見て気に入れば他のPRページも見る。気に入ればエントリーする。あとはGithub採用やってるところはとりあえず出す。他は名前知ってる有名企業とか。\n見るところは勤務形態の自由さ、年収、技術力。技術職なのだから自分の技術力を発揮出来てそれが評価されてまた仕事でスキルアップ出来る所が良い。\n自分の技術力を発揮出来るというのはつまらない規約で制限されないか。スーツ着用とかありえない。合理的理由が全くない。袖のボタンがキーボードに引っかかって作業し辛い。環境を自分の好きに選べるか。椅子、ディスプレイ、キーボード、OS、エディタ等々。バランスボールがオフィスにあると評価が上がる。\n評価されるというのは具体的には年収。札束で頬を引っ張たけばエンジニアは集まる。\n技術力は恐らく会社のWebページでは評価出来ない。中のエンジニアを勉強会で知った、スライドを見た、有名OSSのコミッタが居る、会社のGithubレポジトリの内容。鮎の友釣みたいにエンジニアを自由にさせておけば他のエンジニアも集まる。技術力を求めるのは自分のスキルアップという積極的な理由もあるし、クソコードをレビューしたくないという消極的な理由もある。\n割と年収が決め手だったりする。初任給は高く見えるように書いておいた方が良い。見た目は低くても手当てを入れると手取りがそれなりになるなら参考年収とかを書くと分かり易い。\n因みに会社の将来性は気にしてない。転職が盛んな職種なのだから傾いたら出ていく。\n正直経団連の企業は上の条件を満たしていそうにないので目も呉れてない。向こうも私のような人は求めてないだろうし多分棲み分けが出来てる。主にベンチャーを見ていた。\nコーディング面接 事例1 面接で予告なくコーディングがあった。まあ、それは良い。与えられた環境はWindows XP + Eclipseだった。その時点で既にXPのサポートは切れてた。椅子蹴っ飛ばして帰ろうかと思った。一応受けたけどEmacs入ってないしqwertyだしjp配列だしCaps Lockのままだしなんか数分に1回警告が出て邪魔されるし最悪だった。環境固定はありえないなと思った。\n事例2 pixiv 抜き打ちでホワイトボードコーディングをやった。リファレンスや補完が無くても書ける程度の問題だったし「多分この問題はここを訊いてると思うんですが…」「おぉ？！」とか盛り上がってたし楽しかった。シェル芸も披露した。上がり性の人にはつらいのかもしれないけど個人的には積極的にやって欲しい。\n事例3 採用フローにオンサイトのプログラミング試験があるところがあった。用意される環境はMac ProとJava 7とEclipseとJava 7のリファレンスだったかな？リファレンスが用意されてる時点でお察しと思うがインターネット接続禁止。なんでや。ググり力が一番大事でしょ。あと環境固定は最悪だって。それ見て受けるのやめた。\nGithub採用 積極的にやってほしい。こちらの負担は軽いから。が、エンジニアへの負担がどれほどなのか分からない。あと(学部生なら)Githubを覚え始める頃と就活を始める頃が重なると思うので「これから伸びる」も考慮してくれると嬉しいなー。自分のGithubアカウントが充実し出したのは就活が終わってからだった。\n一定期間アカウントを観察して行動を見て決めるのなら期間を考えて欲しい。観察期間と試験期間が重なって観察期間中1コミットも出来ないことがあった。\n採用側のコストが低いなら一番推奨されるべき。\nプロコン採用 あまり感心しない。前にもポエム書いたようにあれはサイエンスであってエンジニアの採用に有用とは思わない。むしろプロコン採用をやってるところはその辺分かってなさそうで評価が下がる。勿論、動画コーデックの開発をしているドワンゴのようにそういう人材が実際に必要なところはその限りではない。そういうところは積極的にアピールしてくれると誤認が少なくて助かる。\n一応言うとプログラマの中から適性のあるプログラマを見出す方法としては感心しない、と言っている。プログラマ志望の中からプログラム書けるプログラマを見出す方法としてはアリなんじゃないですかね。世の中プログラムの書けないプログラマがどの程度居るのか分かりませんが。\nISUCON採用 めっちゃやって欲しい。インフラ系の即戦力って結構稀だと思います。はい。\n因みに私は1件だけオファーがありました。その頃は自分にそのオファーに見合うだけの技術があるとは思ってなくて、深く考えずに断っちゃいましたけど。今考えるとそこで内定貰って「ISUCONで内定貰ったぜ！ヒャッハ〜」って言ってれば流れ変わったのかな。\nアカリク採用 自分は行ってないけどめっちゃ良さそう。推奨されるべき。\nインターン 一番毒吐きたいところ。\n優秀な学生をインターンで獲得すると言っている企業をちらほら見掛ける。ふざけている。優秀な学生がインターンをしてる暇があると思ってるのか？やはりここにも学生なんだから暇でしょという雰囲気を感じる。\n参考に普通の学生たる私の3年生の時の夏休みの日程を挙げる。8月1日から強化錬、間を空けずに合宿、2日休んで合宿、すぐさま試験準備、試験、直後に帰省。東京に戻ってきたのは9月30日。夏休み中の休みは合宿の合間の2日のみ。\n色々突っ込みたいだろうが予想されるものには反論しておく。\n 夏休みの真ん中に試験がある大学にいるのが悪い これは私からはどうしようもない。高校生の時にそこまで考える人はいないだろう。悪いというならうちの大学を切り捨てればいい。1学年3000人居る。因みに私は夏休みの前半はサークルに勤しんでいたが本来ならそれら全てを試験勉強に充てる。お察しの通り私の試験の出来は良くなかった。その期間にインターンに行きたがる人はそう多くないだろう。\n サークル3つやってるのが悪い\n 私の場合サークルばかりだが他の人でもサークルの他にバイト2つ3つ掛け持ちとかはザラにある。しかもその内の少なくとも1つは大抵教育系なので夏期講習で忙しい。夏期講習で働けなかった分の皺寄せで他のバイトも日程がつまる。夏休みに知人に会うと10連勤明けで死んだ目をしている。サークルやバイトの他にも高校の部活絡みだとか学外活動だとか要因は色々ある。\n 就活のためならサークルを犠牲にすればいい\n 副将をやってるとそうもいかない。参加者ではなく主催者になる。それとも主催者の責務を放り出すような人を採りたいのか？副将になったのが悪いという批判も当を得てない。なぜならサークルの同期は9人いて3人が主副将になる。1/3だ。流石に1/3が外れ値と言う人はいないだろう。それに優秀な人こそ責任者になりやすい筈だ。\n インターンでお金貰えるんだからバイトは辞めるなり休むなりすれば良いのでは\n そうも言ってられない。最近のバイトは中々辞めさせてくれないし、休むと言っても勝手にシフトを入れてくる。辞めるには1ヶ月、2ヶ月前に辞意を伝えておかないといけない。インターンにも選考はある訳で、確実に行けると決まるのは夏休み直前だったりする。あるか無いか分からないもののためにリスクは冒したくない。それに一時収入のために定常収入を失う訳にはいかない。辞めるかも、なんて言葉が勝手にシフトを入れてくるような所に通用する訳がない。\n 帰省は個人の都合では\n そうでもない。多くの大学生は親の扶養下にある。定期的に家族に挨拶をしないと東京で生かしてもらえない。\n 空きの2日を使ってインターンに行けば良いのでは\n インターンが2日で済むのは文系の話だ。理系ならば最低でも2週間、普通1ヶ月。2ヶ月のものもよく見掛ける。学んで動いて成果を出すには2日は短かすぎる。空きの2日どころか合宿をすっぽかしたところでインターンには行けない。\n 普通の学生じゃなくて優秀な学生の話をしているんだ\n 確かに。ここに書いたのは普通の学部生の日程だ。しかし優秀な人は他人より多くのことをこなすから優秀なのではないか？ならば優秀な人はさらに忙しいのではないか？私の周りの(私が思う)優秀な人は忙しそうにしている。忙しいとは言ってないが暇と言ってるのは見たことない。 院生のスケジュールは研究室次第だろう。何とも言えない。やる事やってるなら他は関知しない、というところもあれば夏休みにもコアタイムのある研究室もあると聞く。\n  勿論、ここに書いたことが全ての学生に当て嵌る訳ではない。中には夏休みに時間のある人もいる。だがその人がインターンに行くか、という問題もある。優秀な人は優れた指導教官の下に居る筈だ。その指導教官の下を離れてまでインターンに行く価値があるか。あるいは優秀ならば指導教官がいなくても自ら学べる人は多い。本人の自主学習速度を上回る体験を提供出来るか。優秀な人は職が欲しいなら先のアカリクなどで座して待つだけでやってくる。内定直結は別に魅力ではない。\n私がここまで毒を吐いたのはインターンそのものではない。時間のある学生を集めてインターンを開きたいならそれはそれで良し。両者得をすることがあるだろう。毒を吐いているのはインターンで優秀な学生を獲得すると言っている企業、採用プロセスにインターンを組み込む企業だ。少数、時間のある優秀な学生もいるだろうが多くの優秀な人を自らフィルタしていることに気付かないのか。\n最後に 常体で書いた上に普段使わない汚ない言葉遣い、自分の価値観に合わないものを全力で否定する内容だったので酷く毒毒しいエントリになってしまった。飽くまで個人の日記で毒を吐いただけなので皆さんマジレスしないで下さいね。\n企業は利益のために採用活動をするのに対して大学生はその露命をつなぐために就職活動をする。立場上も身分上も大学生が下手に出るべきだが上から目線な記述が散見される。ここは一つ個人の日記ということで赦して下さい。\n","categories":["番外編","デトックス"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8","/categories/%e3%83%87%e3%83%88%e3%83%83%e3%82%af%e3%82%b9"],"date":"2015-02-07","title":"就活について思ったことをここに書き記す","url":"https://KeenS.github.io/blog/2015/02/07/shuukatsunitsuiteomottakotowokokonikakishirusu/"},
  {"body":"κeenです。前回のmllexの記事の続きです。今回はmlyaccを使ってみました。\n 前回はprologをパースするためにこのようなmllexのコードを書いたのでした。\ndatatype lexresult = Comment of string | LeftParen | RightParen | LeftBracket | RightBracket | Comma | Dot | Bar | Medaka | UnderScore | String of string | Number of int | Variable of string | EOF val linenum = ref 1 val error = fn x =\u0026gt; print (x ^ \u0026#34;\\n\u0026#34;) val eof = fn () =\u0026gt; EOF %% %structure PrologLex alphanum = [A-Za-z0-9]; alpha = [A-Za-z]; digit = [0-9]; ws = [\\ \\t\\n]; %% {ws}+ =\u0026gt; (lex()); %(.*)\\n =\u0026gt; (Comment yytext); \u0026#34;(\u0026#34; =\u0026gt; (LeftParen); \u0026#34;)\u0026#34; =\u0026gt; (RightParen); \u0026#34;[\u0026#34; =\u0026gt; (LeftBracket); \u0026#34;]\u0026#34; =\u0026gt; (RightBracket); \u0026#34;,\u0026#34; =\u0026gt; (Comma); \u0026#34;.\u0026#34; =\u0026gt; (Dot); \u0026#34;|\u0026#34; =\u0026gt; (Bar); \u0026#34;:-\u0026#34; =\u0026gt; (Medaka); \u0026#34;_\u0026#34; =\u0026gt; (UnderScore); [a-z]{alphanum}* =\u0026gt; (String yytext); {digit}+ =\u0026gt; (Number (foldl (fn(a, r)=\u0026gt; (ord(a)-ord(#\u0026#34;0\u0026#34;)) + 10*r) 0 (explode yytext))); [A-Z]{alphanum}* =\u0026gt; (Variable yytext); これでトークナイズしたトークンをパースすることを考えます。結果はAST作るのが面倒なので文字列にします。\nとりあえずコードを晒してから解説します。prologの仕様を読まずに書いたので用語や文法は誤りを含みます。今度直すので今回はこれで勘弁して下さい。\n%% %name PrologParser %pos int %term Comment of string | LeftParen | RightParen | LeftBracket | RightBracket | Comma | Dot | Bar | Medaka | UnderScore | Number of int | String of string | Variable of string | EOF %nonterm EXP of string | LIST of string | LISTEXPS of string | TOPDEFINITION of string | SUBDEFINITIONS of string | DEFINITION of string | ARG of string | NAME of string | STMT of string | ATOM of string | START of string %left Comma %right Bar %eop EOF %noshift EOF %nodefault %% START : STMT (STMT) STMT : Comment STMT (Comment ^ \u0026#34;\\n\u0026#34; ^ STMT) | TOPDEFINITION STMT (TOPDEFINITION ^ \u0026#34;\\n\u0026#34; ^ STMT) | (\u0026#34;\u0026#34;) TOPDEFINITION : DEFINITION Dot (DEFINITION ^ \u0026#34;.\u0026#34;) | DEFINITION Medaka SUBDEFINITIONS Dot (DEFINITION ^ \u0026#34;:-\\n\u0026#34; ^ SUBDEFINITIONS ^ \u0026#34;.\u0026#34;) SUBDEFINITIONS : DEFINITION Comma SUBDEFINITIONS (DEFINITION ^ \u0026#34;,\\n\u0026#34; ^SUBDEFINITIONS) | DEFINITION (\u0026#34; \u0026#34; ^ DEFINITION) DEFINITION : NAME ARG (NAME ^ ARG) NAME : String (String) ARG : LeftParen EXP RightParen (\u0026#34;(\u0026#34; ^ EXP ^ \u0026#34;)\u0026#34;) EXP : EXP Comma EXP (EXP1 ^ \u0026#34;, \u0026#34; ^ EXP2) | LIST (LIST) | ATOM (ATOM) LIST : LeftBracket LISTEXPS RightBracket ( \u0026#34;[\u0026#34; ^ LISTEXPS ^ \u0026#34;]\u0026#34;) LISTEXPS : ATOM Bar LISTEXPS (ATOM ^ \u0026#34; | \u0026#34; ^ LISTEXPS) | ATOM (ATOM) ATOM : UnderScore (\u0026#34;_\u0026#34;) | Number (Int.toString Number) | String (String) | Variable (Variable) | LeftBracket RightBracket (\u0026#34;[]\u0026#34;) 全体はやはり\n補助コード %% 補助ルール %% パースルール となります。\nトークンに切り出す部分がないので補助コードはあまり書く必要はないようです。ASTを組み立てる時に必要なことがあるのかな？\n補助ルールは、主なものは終端記号(term)と非終端記号(nonterm)の記述です。パーサに馴染のない人には聞き慣れない言葉かもしれませんが、ASTの葉が終端記号で、節が非終端記号です。あとはパースの終わりの記号にeop、パースの区切にnonshiftを指定しましょう。パースの区切はEOFの他にREPLならNewlineなども候補かもしれません。posの型も必須です。leftやrightは中置演算子があればそれの結合の左右を指定します。複数書くと後の方が優先順位が高くなるようです。\n%left Add Sub %left Mul Div のように。\nパースルールは見て察して下さい。\nこれをprolog.yaccなどと名前をつけて(.grmがよく使われるそうですが。)、\n$ mlyacc prolog.yacc とするとprolog.yacc.smlとprolog.yacc.sigが出来ます。\n追記: @blackenedgold あと拡張子ですが、compilation managerは.grmをmlyaccのファイルと認識してくれるはずなので手間が少なそうです。\n\u0026mdash; ELD-R-ESH-2 (@eldesh) 2015, 1月 31 大人しく.grmを使いましょう。\nシグネチャは.sigが\nsignature PrologParser_TOKENS = sig type (\u0026#39;a,\u0026#39;b) token type svalue val EOF : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Variable : string * \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val String : string * \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Number : int * \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val UnderScore : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Medaka : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Bar : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Dot : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Comma : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val RightBracket : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val LeftBracket : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val RightParen : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val LeftParen : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Comment : string * \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token end signature PrologParser_LRVALS = sig structure Tokens : sig type (\u0026#39;a,\u0026#39;b) token type svalue val EOF : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Variable : string * \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val String : string * \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Number : int * \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val UnderScore : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Medaka : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Bar : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Dot : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Comma : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val RightBracket : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val LeftBracket : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val RightParen : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val LeftParen : \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token val Comment : string * \u0026#39;a * \u0026#39;a -\u0026gt; (svalue,\u0026#39;a) token end structure ParserData : sig type pos type svalue type arg type result structure LrTable : \u0026lt;sig\u0026gt; structure Token : \u0026lt;sig\u0026gt; structure Actions : \u0026lt;sig\u0026gt; structure EC : \u0026lt;sig\u0026gt; val table : LrTable.table sharing LrTable = Token.LrTable end sharing type Tokens.svalue = ParserData.svalue sharing type Tokens.token = ParserData.Token.token end で、.smlが\nfunctor PrologParserLrValsFun(\u0026lt;param\u0026gt;: sig structure Token : \u0026lt;sig\u0026gt; end) : sig structure ParserData : \u0026lt;sig\u0026gt; structure Tokens : \u0026lt;sig\u0026gt; end な感じです。\n問題点 これ、以前のlexのコードと組み合わせても動きません。パーサはレキサが吐いたトークン列をパースするのでレキサとパーサで同じdatatypeを共有している必要があります。パーサはtermの指定からTokensを自動で生成してしまうのでレキサの方を修正する必要があります。\nこうなります。\nstructure Tokens = Tokens type pos = int type svalue = Tokens.svalue type (\u0026#39;a, \u0026#39;b) token = (\u0026#39;a, \u0026#39;b) Tokens.token type lexresult = (svalue,pos) token (* datatype lexresult = *) (* Comment of string *) (* | LeftParen *) (* | RightParen *) (* | LeftBracket *) (* | RightBracket *) (* | Comma *) (* | Dot *) (* | Bar *) (* | Medaka *) (* | UnderScore *) (* | Number of int *) (* | String of string *) (* | Variable of string *) (* | EOF *) val pos = ref 0 val linenum = ref 1 val error = fn x =\u0026gt; print (x ^ \u0026#34;\\n\u0026#34;) val eof = fn () =\u0026gt; Tokens.EOF(!pos, !pos) %% %header (functor PrologLexFun(structure Tokens: PrologParser_TOKENS)); alphanum = [A-Za-z0-9]; alpha = [A-Za-z]; digit = [0-9]; ws = [\\ \\t\\n]; %% {ws}+ =\u0026gt; (lex()); %(.*)\\n =\u0026gt; (Tokens.Comment(yytext, !pos, !pos)); \u0026#34;(\u0026#34; =\u0026gt; (Tokens.LeftParen(!pos, !pos)); \u0026#34;)\u0026#34; =\u0026gt; (Tokens.RightParen(!pos, !pos)); \u0026#34;[\u0026#34; =\u0026gt; (Tokens.LeftBracket(!pos, !pos)); \u0026#34;]\u0026#34; =\u0026gt; (Tokens.RightBracket(!pos, !pos)); \u0026#34;,\u0026#34; =\u0026gt; (Tokens.Comma(!pos, !pos)); \u0026#34;.\u0026#34; =\u0026gt; (Tokens.Dot(!pos, !pos)); \u0026#34;|\u0026#34; =\u0026gt; (Tokens.Bar(!pos, !pos)); \u0026#34;:-\u0026#34; =\u0026gt; (Tokens.Medaka(!pos, !pos)); \u0026#34;_\u0026#34; =\u0026gt; (Tokens.UnderScore(!pos, !pos)); [a-z]{alphanum}* =\u0026gt; (Tokens.String(yytext, !pos, !pos)); {digit}+ =\u0026gt; (Tokens.Number ((foldl (fn(a, r)=\u0026gt; (ord(a)-ord(#\u0026#34;0\u0026#34;)) + 10*r) 0 (explode yytext)), !pos, !pos)); [A-Z]{alphanum}* =\u0026gt; (Tokens.Variable(yytext, !pos, !pos)); モジュールではなくてファンクタを生成するようになります。シグネチャはこうです。\nfunctor PrologLexFun(\u0026lt;param\u0026gt;: sig structure Tokens : \u0026lt;sig\u0026gt; end) : sig structure UserDeclarations : \u0026lt;sig\u0026gt; exception LexError structure Internal : \u0026lt;sig\u0026gt; structure YYPosInt : \u0026lt;sig\u0026gt; val makeLexer : (int -\u0026gt; string) -\u0026gt; unit -\u0026gt; Internal.result end 組み合わせる まず、必要なモジュールやシグネチャをmlyaccから読み込みます。前回同様mltonのmlyaccを使って、SML/NJで動作確認を行ないました。\n私は分かってないのですが、useってもしかしてSML/NJの固有の機能なんですかね。\n追記: useはThe Standard ML Basis Libraryに記載があるのでSML/NJ固有の機能ではないですが、implementation dependentと書いてあるのでまぁそういう事なんでしょう\n\u0026mdash; ろんだ (@fetburner) 2015, 1月 31\n@blackenedgold useは標準ですが意味は実装依存ですね\u0026gt; http://t.co/fPC38xtD1X (例外の直後辺り)\n\u0026mdash; ELD-R-ESH-2 (@eldesh) 2015, 1月 31 とのことなので処理系依存の機能ではなかった模様。\nuse \u0026#34;/home/kim/compile/mlton/lib/mlyacc-lib/base.sig\u0026#34;; use \u0026#34;/home/kim/compile/mlton/lib/mlyacc-lib/join.sml\u0026#34;; use \u0026#34;/home/kim/compile/mlton/lib/mlyacc-lib/lrtable.sml\u0026#34;; use \u0026#34;/home/kim/compile/mlton/lib/mlyacc-lib/stream.sml\u0026#34;; use \u0026#34;/home/kim/compile/mlton/lib/mlyacc-lib/parser2.sml\u0026#34;; use \u0026#34;prolog.yacc.sig\u0026#34;; use \u0026#34;prolog.yacc.sml\u0026#34;; use \u0026#34;prolog.lex.sml\u0026#34;; mlyacc-libの場所は各自異なるので適宜書き換えて下さい。SML/NJはインストール場所を表わすシンボルを持っているようですが、私はmltonのものを参照しているのでいずれにせよ関係ないですね。\nさて、この.yacc.smlに入ってるファンクタです。\nfunctor PrologParserLrValsFun(\u0026lt;param\u0026gt;: sig structure Token : \u0026lt;sig\u0026gt; end) : sig structure ParserData : \u0026lt;sig\u0026gt; structure Tokens : \u0026lt;sig\u0026gt; end 何故こうなってるのかは分からないのですがTokenを欲しがってますね。あげましょう。\nstructure PrologParserLrVals = PrologParserLrValsFun(structure Token = LrParser.Token) LrValsって言ってるのでLRパーサーで使うデータ型が用意出来たのかな？\nこれでレキサで使うTokensとパーサで使うParserDataを持つモジュールが出来たのでレキサのファンクタの餌が用意出来ました。食べさせてあげましょう。\nstructure PrologLex = PrologLexFun(structure Tokens = PrologParserLrVals.Tokens) これは普通にレキサを生成します。\nんで最後にLRパーサとLRパーサで使うデータ型(?)とLRパーサに渡すトークンを生成するレキサを組み合わせます。なんかsharingなる機能を使って組み合わせるらしいのでそれ専用のファンクタが用意されています。sharingなんぞ。いつかThe Definition of Standard ML Revised読まねば。\nstructure PrologParser = Join(structure LrParser = LrParser structure ParserData = PrologParserLrVals.ParserData structure Lex = PrologLex) やっぱりLrParserを使ってるのが腑に落ちませんね。どうして生成した時点で含んでないのかな。複数のパーサを作ったときに無駄を無くすため？自前のパーサが使えるようにするため？LrParser.Tokenはまだパーサとsharingしてる必要がありそうなので納得出来ますが。\n使ってみる makeLexerとparseを使うようです。makeLexerは呼ぶ度にトークンを返すものではなく、トークンのストリームを返すものになってるらしいです。\nprologファイル名を受け取ってその中身をパースして、中身を整形した文字列にするコードです。\nfun invoke lexstream = let fun print_error (s, _, _) = TextIO.output(TextIO.stdOut, \u0026#34;Error: \u0026#34; ^ s ^ \u0026#34;\\n\u0026#34;) in PrologParser.parse(0, lexstream, print_error, ()) end fun parse filename = let val f = TextIO.openIn filename val lexer = PrologParser.makeLexer (fn i =\u0026gt; TextIO.inputN(f, i)) fun run lexer = let val (result,lexer) = invoke lexer in TextIO.output(TextIO.stdOut, \u0026#34;result = \u0026#34; ^ result ^ \u0026#34;\\n\u0026#34;) end in run lexer end 今回はposのアップデートをサボったのでprint_error内では無視してますが本来はprint_errorは\nprint_error (s, start:int, end:int) として受けるべきです。この時startとendはトークンの開始位置と終了位置です。\n他にも説明が足りてない部分がありますが、マニュアルや東北大のPDFを参照して下さい。\nまとめ  mlyaccの使い方を書いた mllexとmlyaccの組み合わせ方を書いた 疑問が残った  次回はASTでも作ってみますが、smlsharpにSMLFormatなるdatatypeの定義とそのプリティプリンタの定義を同時に出来るツールがあるようなのでそれを使ってみます。いくつも中間表現を作ろうと思ったら途中経過も欲しいのでプリティプリンタ重要ですよね。\n","categories":["ML","SML","mlyacc","Prolog"],"category_urls":["/categories/ml","/categories/sml","/categories/mlyacc","/categories/prolog"],"date":"2015-01-31","title":"mlyaccを使ってみてハマったところ","url":"https://KeenS.github.io/blog/2015/01/31/mlyaccwotsukattemitehamattatokoro/"},
  {"body":"コマンドラインツールを作ってるみなさん、man書いてますか？コマンドラインツールを使う人は時代の変化に取り残された遺物なのでWebにドキュメント置いても読んでくれませんよ。\nいや、私のようにmanだけを頼りにツールを使う人もいるのでちゃんと書いて下さいね。面倒だって?AsciiDocを使えば簡単に書けますよ!\nManとは man hoge で見れるやつですね。\ntroff manはtroffというフォーマットで書く必要があります。どんな感じかというと\n.ie n \\{\\ \\h\u0026#39;-04\u0026#39;\\(bu\\h\u0026#39;+03\u0026#39;\\c .\\} .el \\{\\ .sp -1 .IP \\(bu 2.3 .\\} use the latest sbcl .RE .sp .if n \\{\\ .RS 4 .\\} はい。人間が書くものではないですね。なので別の形式(AsciiDoc)から変換することを考えます。\nセクションナンバー コマンド（など）はセクションに分かれています。manを書くときに必要になる知識なので覚えておきましょう。コマンドラインから使うものの他、Cの関数やコンフィグファイルについての項目もあります。\n    Description     1 一般コマンド   2 システムコール   3 ライブラリ関数   4 デバイス   5 ファイルフォーマット（コンフィグファイル）   6 ゲーム   7 その他   8 システムメンテナンス(sudoとか)   9 カーネル    一般デベロッパが使うのは1、5、6、8あたりでしょうか。6のゲームには普通のゲームの他、phase of moon、盈虚(えいきょ、月齢のこと)を表示するpomコマンドなどがあります。\nmanを書くときにはmanを必ずどこかのセクションに割り当てます。\nmanを使う時はman hogeだと全てのセクションのhogeのmanを捜しますがman 1 hogeだとセクション1のみから捜します。割とセクション1と2で同名のmanがあることがあるので重宝します。また、そのような混同を防ぐためにコマンドやシステムコールの後には括弧書きでセクションナンバーを書くのが慣習です。manならman(1)のように。\n因みにman n introとするとセクションナンバーnの説明が見れます。\nAsciiDoc AsciiDoc Home Page MarkdownとかrSTとかの類いです。リーダブルなAsciiなDocを書いて色々な形式に変換出来ます。HTMLやDocBookなどの形式に変換出来ます。普通にそのままのテキストでも十分リーダブルだと思います。拡張子は.txtを使います。そのままでも読めるんだぜオーラが出てますね。\n有名どころだとgitが使ってるとか。バッククォートをあまり使わないので個人的にはリーダブルさが他より高い気がします。\nここにチートシートがあるのでだいたいはそこを見てもらえば良いのですが、例を出すと\nTITLE ===== keen mail@address 0.0.1, 2015-01-24 Header ------ [source, lisp] (write-line \u0026#34;Hello, World\u0026#34;) な感じです。 タイトル、=で下線のあとにファイルの属性がきます。Author、Mail、Revision、Dateはよく使うのでこのようにリーダブルに書けます。他の属性は\n:attr: value のように書く必要があります。Authorなどもこのように書いても構いません。\n独特なのがパラグラフ毎にマークアップしていくところですね。パラグラフの区切は空行です。上の\n[source, lisp] (write-line \u0026#34;Hello, World\u0026#34;) のようにパラグラフの前にマークアップコマンドを置けます。1パラグラフに収まらないものは例えばソースコードなら\n---- (defun hello (name) (format t \u0026#34;Hello, ~a~%\u0026#34; name)) (hello \u0026#34;κeen\u0026#34;) ---- のように-4つで囲む、などの記法もあります。\nmanのフォーマット さて、話戻ってmanのフォーマットです。みなさん見慣れてるかと思いますが、manは最初はNAME、SYNOPSIS、DESCRIPTIONのセクションが並ぶことを要求します。\nAsciiDocからman生成 manが一定のフォーマットを要求するのでAsciiDoc側も一定のフォーマットで書いてやる必要があります。\nNAME、SYNOPSIS、DESCRIPTIONは勿論のこと、タイトルが「コマンド名(n)」となっている必要があります。コマンド名にはスペースが入ってはいけません。gitのようにサブコマンドに分かれているものはハイフンで繋ぐようです。nはセクションナンバーですね。\nNAMEについて捕捉しておくと、NAMEの書式も決まっていて、\ncommand-name - one line description のフォーマットである必要があります。apropos(1)で表示するためでしょうね、きっと。\n例 実際に私が書いたものを載せますね。\ncim-use(1) ========== keen(@blackenedgold) 3han5chou7@gmail.com :man manual: CIM Manual NAME ---- cim-use - Use specified impl as \u0026#39;cl\u0026#39; command\u0026#39;s backend. SYNOPSIS -------- [verse] cim use \u0026lt;impl[-version]\u0026gt; [--default] DESCRIPTION ----------- Use \u0026lt;impl\u0026gt; as background for cl command. It also affects bare lisp command. If version is not given, use latest version. If --default is given, use the specified implementation at initial state. EXAMPLES -------- * use the latest sbcl ---- $ cim use sbcl $ sbcl --version SBCL 1.1.14 ---- * use old sbcl ---- $ cim use sbcl-1.1.10 $ sbcl --version SBCL 1.1.10 ---- * use ccl-1.9 and set it default ---- $ cim use ccl-1.9 --default ---- :man manual:の属性はヘッダに表示されるものです。\nんで変換は\na2x --doctype manpage --format manpage filename.txt 。\nこれ、ファイル名に関らずcim-use.1というファイルを生成します。\nんでファイルの内容は\nman ./cim-use.1 で見れます。\nCIM-USE(1)\tCIM Manual\tCIM-USE(1) NAME cim-use - Use specified impl as \u0026#39;cl\u0026#39; command\u0026#39;s backend. SYNOPSIS cim use \u0026lt;impl[-version]\u0026gt;\t[--default] DESCRIPTION Use \u0026lt;impl\u0026gt; as background\tfor cl command.\tIt also\taffects\tbare lisp command.\tIf version is not given, use latest version. If\t--default is given, use the specified\timplementation at initial state. EXAMPLES o use the latest sbcl $ cim use sbcl $ sbcl --version SBCL\t1.1.14 o use old sbcl $ cim use sbcl-1.1.10 $ sbcl --version SBCL\t1.1.10 o use ccl-1.9 and set it default $ cim use ccl-1.9 --default AUTHOR keen(@blackenedgold) 3han5chou7@gmail.com Author. 01/21/2015\tCIM-USE(1) 他の例だと、gitのドキュメントを見るとよさそうです。あそこはWEB用にもビルドしてるのでAsciiDocのコンフィグ書いてWEBとmanで条件分岐するマクロとかも書いてます。変態ですね。\nビルド 私は以下のようなスクリプトを書いてビルドしてます。並列ビルド、タイムスタンプセンシティブビルド対応。DOC_ROOTはデファルトでそのスクリプトが置いてあるディレクトリです。環境変数で制御出来ます。make.shって名前で保存したなら\n$ DOC_ROOT=your/root ./make.sh のように。その他AUTO_POLLなども設定出来ます。必要ならお使い下さい。CIMの配布物に含まれるのでBSDライセンスです。\n#!/bin/sh  : ${DOC_ROOT:=$(cd $(dirname $0); pwd)} : ${MAN_DIR:=${DOC_ROOT}/man/man1} : ${AUTO_POLL:=false} : ${POLL_INTERVAL:=5} txt2man(){ if [ ! -e \u0026#34;${MAN_DIR}/$(basename $1 .txt).1\u0026#34; ] || [ \u0026#34;$1\u0026#34; -nt \u0026#34;${MAN_DIR}/$(basename $1 .txt).1\u0026#34; ]; then echo \u0026#34;Building $1\u0026#34; if a2x -v --doctype manpage --format manpage -D \u0026#34;${MAN_DIR}\u0026#34; \u0026#34;$1\u0026#34; \u0026gt; \u0026#34;log/$(basename $1 .txt).log\u0026#34; 2\u0026gt;\u0026amp;1 then echo \u0026#34;O Built $1\u0026#34; else echo \u0026#34;X Bulid failed: $1. See log/$(basename $1 .txt).log\u0026#34; return 1 fi fi } cd \u0026#34;${DOC_ROOT}\u0026#34; while \u0026#34;${AUTO_POLL}\u0026#34;; do for f in *.txt; do txt2man \u0026#34;$f\u0026#34; \u0026amp; done wait if \u0026#34;${AUTO_POLL}\u0026#34;; then sleep \u0026#34;${POLL_INTERVAL}\u0026#34; fi done 運用 manはMANPATH環境変数を元にmanを捜します。捜すのはMANPATH直下ではなく、セクションナンバー1なら/man/path/man1/name.1を捜します。それっぽいところに置きましょう。\n因みにFreeBSDではちょっと面倒です。詳しくはmanpath(1)を見て下さい。\nまとめ  manpageは重要 だけど手で書くものではない AsciiDoc使うと便利! 便利なスクリプト用意しといたよ ","categories":["AsciiDoc","CLI","Document"],"category_urls":["/categories/asciidoc","/categories/cli","/categories/document"],"date":"2015-01-24","title":"AsciiDocを使ってお手軽manページ生成","url":"https://KeenS.github.io/blog/2015/01/24/generate-manpage/"},
  {"body":"小ネタ。古いドキュメントやらポータブルな仕様を落としてくると中身が印刷フォーマット済み(ページネーションやヘッダ、フッタをアスキーアートで表現してる)であることがあります。 それらを普通のテキスト形式だと読みづらいのでPDF化する話。\n結論から言うとa2pdf - search.cpan.orgを使いました。選んだ理由は\n 余計な装飾を付与しない ^L(pagebreak)でちゃんと改ページする  です。使い方は\n$ a2pdf --noheader --noperl-syntax --noline-numbers foo.txt -o foo.pdf でok。本当は--nofooterも付けたいんですがそれつけるとエラー出たのでやむなくフッタは甘受。元々perlのソースコードをPDF化するためのものらしく、デフォルトでそのような設定になってるので無効化する必要があります。\n生成速度なんですけどPDF化すると105ページあるテキストの変換に73秒かかりました。少し遅いですね。このくらいだったらサクっとCommon Lispで書いてしまった方が速かったのかなぁ。\n","categories":["CLI","PDF","小ネタ"],"category_urls":["/categories/cli","/categories/pdf","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2015-01-24","title":"印刷フォマット済みのテキストファイルをPDF化する","url":"https://KeenS.github.io/blog/2015/01/24/a2pdf/"},
  {"body":"clfreaksの収録時に他のLisperと話してて価値観というか目標を共有出来てないなと思ったのでここで心情を語る次第。今のCommon Lispの使われ方には問題がある。\nCommon Lispにはポータビリティというかユニバーサリティというか、そういうものがない。いや、処理系の作者達はしっかり作ってるのだけどLisperがそういう使い方をしていない。\n例えば、Rubyで出来たアプリケーションを使いたいとしよう。Jekyllがいいかな。大抵のシステムには入ってるだろうが一応処理系のインストールから始めてみる。\n aptなりpkgなりyumなりで処理系をインストールする。それが気に入らなければソースからインストールしてもいい。 処理系をインストールするとgemがついてくるのでgem install jekyllを叩く。 あとはJekyllを使うだけ。  あるいは、Octopressなら処理系のインストールのあとは\n git cloneしてくる。 gem install bundlerでbundlerをインストールする。 bundle installで依存gemをインストールする。 bundle exec rake previewでサーバーが起動する。 止めたければCtrl-Cで止まる。  Common Lispで出来たアプリケーションを使いたいとしよう。cliki。がいいかな。\n 処理系のインストールはRubyと同じくパッケージマネージャで入る。あるいはソースからインストールしてもいい。この際処理系選びは既に終わっているとする。 clikiをgit cloneしてくる。 ASDFに読んでもらうために~/common-lisp以下にclikiを移動する。 依存パッケージのインストールのためにquicklispをインストールする。  quicklisp.lispをダウンロードしてくる。 REPLを起動する。どうやって？処理系依存だから自分で調べろ。 Lispの式をいくつか評価してquicklispをインストールする。~/quicklispが出現するがこの際目を瞑る。  REPLで(ql:quickload :cliki)を評価して依存パッケージをインストールする (start-cliki-server port homedir wikis)でサーバーが起動する。REPLも起動しっぱなし。 止めたければ  Ctrl-Cでinteractive-interruptコンディションを発生させる。デバッガが起動する。 デバッガからREPLのtoplevelに戻る。デバッガの操作?処理系依存だから自分で調べろ。 REPLを終了する。どうやって？処理系依存だから自分で調べろ。   「アプリケーションは~/common-lispじゃなくて/var/wwwに置きたいんだけど」 - 「コンフィグ書いたら変えられるよ。ASDFのコンフィグ書いてね。コンフィグの書き方はLisperの常識だよね」\n「~/quicklisp邪魔なんだけど」 - 「ああ、それも変えられるよ。好きな場所に移動して処理系の初期化ファイル書き直してね。初期化ファイル？処理系依存だから自分で調べろ。どう直すか？簡単なLispの式だから自分で直せるよね？」\n多分言いたいことは伝わったかと思う。コマンドラインから扱えないとかパッケージマネージャが我が儘とか色々あるんだけど全ては「Lisperのためだけのものになっている」の一言で表せられる。\nquicklispが我が儘なのはまだ許せる。インストール先のディレクトリが固定されてないと管理しづらいから。しかしASDFがライブラリじゃなくてアプリケーションにまで特定のパスにあることを要求してくるのは納得がいかない。コンパイルやらロードやらテストやらの機能があるんだから.asdファイルのあるディレクトリをルートとしてそこだけで完結してほしい。以前、こんな記事を書いた所為でASDFの信者と思われているみたいだが、どっちかというとASDFの方が嫌いだ。ASDFが憖っか依存関係の解決までするがためにアプリケーションの置き場まで制約を受ける。手を広げたがために本来の機能が使い辛くなっている。Lisperが制約を受けるのはまだいい。アプリケーションのユーザにまで制約が及ぶのは耐えられない。\nコマンドラインから扱えない問題は多分ノウハウがなかったからだと思う。以前の記事で紹介した方法は多分知られていなかった。あとは複雑で使い辛いと評判(だった)のcl-launchか。アプリケーションはおろかquicklispすらREPLに入らないと使えない。ユーザがLispを微塵も知らない可能性すらあるのに。さらに、コマンドラインから使えないということは他のUnixツール群と組み合わせることも困難になる。また、ここにあるようにREPLでアプリケーションを起動していると問題もある。\n私はこの問題を解決するためにCIMを作った。clfreaksの時にも喋ったがCIMのメインの機能はclコマンドとqlコマンドだ。cimコマンドはただの付加価値のためにつけたおまけである。\nもしclコマンドが広く使われるようになればshebangにclを使うだけで実行可能ファイルが作れて、コマンドラインから使えるようになる。qlを使えばREPLに入らずにパッケージをインストール出来る。スクリプトがエラーを出してもデバッガに入るようなことはない。Ctrl-Cでちゃんと止まる。\nこれで一部ユニバーサリティの問題は解決出来たんだけだまだまだ未解決問題がある。\n CIMのインストールが必要になる。 コマンドラインツールは解決したにしてもディレクトリ丸ごと持ってくるようなアプリケーションはASDFの制約をうける コンパイルの問題  1はやっぱりLispを知らない人に使ってもらいたいならCIMのインストールは省きたい。処理系とquicklispだけ入れたら使えてほしい。やっぱりquicklispに変わってもらうしかないのかな。配布物に実行可能形式を含めてたらPATHも通して欲しいし。\n2のASDFの制約の問題はASDFを環境変数で制御出来るようなのでうまいことする方法を考えている。良い方法があったらまたアウトプットする。\n3は現状CIMで扱いかねてる問題。マクロ展開の問題からコンパイルするのが望ましいんだけどコンパイル後のファイルに互換性がない。しかも互換性がないのに同じ拡張子を使う。そこを上手く扱ってくれるのはASDFなんだけどやっぱり奴は我が儘だし何よりコンパイルしてしまうとAllegroを除いてshebangが効かなくなる。\n解決案はいくつか上がってるんだけどまだ決定的なものはない。\n コンパイルをあきらめる 本体だけASDFでコンパイルしてエントリポイントになるスクリプトはコンパイルしない スタンドアロンバイナリ配布する ECLを使ってCのファイルを配布する ユーザー側にスタンドアロンバイナリを作らせる 特定の処理系を要求する  1は下の策。\n2は個人的に推したいところだけどやっぱりASDFが憎い。\n3はクロスコンパイルが壊滅的なCommon Lispでは現実的ではない。\n4はCommon Lispの利点の一つにSBCLやCCLやCMU CLの速度が速いというのがあるから出来れば自由に処理系を選ばせたい。あとECLのランタイムのインストールが必要になる。\n5はやっぱりASDFが憎い。それに依存ライブラリもロードするにはquicklispもロードする必要があって、以前の記事の通りバイナリに邪魔なものが入るしそうでなくてもバイナリが素で60MBとかになる。stripするとアプリケーションとして動かなくなるからstripも出来ない。\n6はコンパイル後のファイルがポータブルな処理系はABCL、CLISP、XCLあたりだが、起動の遅いABCL、微妙に仕様に従ってなくて開発も停滞気味なCLISP、既に開発されていない上にマイナーでライブラリのサポートも薄いXCLとあまり選びたくないものばかり。\n因みに非Lispユーザにも使われているCommon LispアプリケーションにStumpWMがあるが、5の方法を採用している。しかしASDFを使わずにMakefileでコンパイルしている。依存ライブラリも手でインストールする必要がある。出来ればCommon Lispのツールチェーンに載せたまま配布したいところ…\n研究が必要。\n","categories":["Lisp","Common Lisp","CLI"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/cli"],"date":"2015-01-22","title":"Common Lispのポータビリティとユニバーサリティ","url":"https://KeenS.github.io/blog/2015/01/22/common-lisp-portability-and-univesality/"},
  {"body":"今、picrinのcodegenプロセスに手を入れる機運が高まってます。picrinはバイトコードインタプリタなのでS式を渡されたらそれをバイトコードに変換する作業が必要です。それがcodegen。本当はcompileなんだけどpicrinのCのソースコードのコンパイルと紛らわしいからcodegen。私も完全にはプロセスを理解してないので説明して理解度を試しつつ問題点を洗い出します。\n関連ファイル  extlib/benz/codegen.c extlib/benz/macro.c (extlib/benz/read.c) (extlib/benz/vm.c)  おおまかな流れ  (readする) マクロ展開する コードの解析をする バイトコードを生成する (実行する)  今回説明するのは2~4です。\nマクロ展開 入力:Schemeの式\n出力:マクロ展開済みのS式\n副作用:マクロテーブルの更新、ライブラリテーブルの更新、その他マクロ毎の副作用\nextlib/benz/macro.cに処理があります。\nメインの部分はこれです。\nstatic pic_value macroexpand_node(pic_state *pic, pic_value expr, struct pic_senv *senv) { switch (pic_type(expr)) { case PIC_TT_SYMBOL: { return macroexpand_symbol(pic, pic_sym(expr), senv); } case PIC_TT_PAIR: { pic_value car; struct pic_macro *mac; if (! pic_list_p(expr)) { pic_errorf(pic, \u0026#34;cannot macroexpand improper list: ~s\u0026#34;, expr); } car = macroexpand(pic, pic_car(pic, expr), senv); if (pic_sym_p(car)) { pic_sym tag = pic_sym(car); if (tag == pic-\u0026gt;rDEFINE_SYNTAX) { return macroexpand_defsyntax(pic, expr, senv); } else if (tag == pic-\u0026gt;rLAMBDA) { return macroexpand_defer(pic, expr, senv); } else if (tag == pic-\u0026gt;rDEFINE) { return macroexpand_define(pic, expr, senv); } else if (tag == pic-\u0026gt;rQUOTE) { return macroexpand_quote(pic, expr); } if ((mac = find_macro(pic, tag)) != NULL) { return macroexpand_node(pic, macroexpand_macro(pic, mac, expr, senv), senv); } } return pic_cons(pic, car, macroexpand_list(pic, pic_cdr(pic, expr), senv)); } default: return expr; } } S式を行きがけ順でマクロ展開していきます。\nリストの先頭にあるものをマクロと疑って展開しようとしますが、見ての通りdefine-syntax、lambda、define、quoteだけは特別扱いされています。このスペシャルフォーム達は引数に括弧つきのものを取ったり引数を全く触ってほしくなかったりするのでマクロ展開時に特別な処理がされるんですね。他はシンボルは変数名(identifier)として処理し、リストとシンボル以外のものはそのまま返します。\nここに1つ問題があります。find_macroです。イシューにも挙げられていますが、マクロを定義したあと同じ名前の手続を定義したら手続で上書きされる筈なのにマクロとして展開されてしまいます。これはマクロと手続きで別のテーブルを持っていることに起因します。ちゃんと上書きされるようにするにはマクロも変数束縛テーブルに登録すれば解決出来るのかなと思ってます。\nシンボル 変なことはしてません。スコープを遡っていき、最初に見付かったインターンされたシンボルを返します。見付からなかった(=未定義のシンボルだった)ときは新たなgensymを返します。\ndefine-syntax static pic_value macroexpand_defsyntax(pic_state *pic, pic_value expr, struct pic_senv *senv) { pic_value var, val; pic_sym sym, rename; if (pic_length(pic, expr) != 3) { pic_errorf(pic, \u0026#34;syntax error\u0026#34;); } var = pic_cadr(pic, expr); if (! pic_sym_p(var)) { pic_errorf(pic, \u0026#34;binding to non-symbol object\u0026#34;); } sym = pic_sym(var); if (! pic_find_rename(pic, senv, sym, \u0026amp;rename)) { rename = pic_add_rename(pic, senv, sym); } else { pic_warnf(pic, \u0026#34;redefining syntax variable: ~s\u0026#34;, pic_sym_value(sym)); } val = pic_cadr(pic, pic_cdr(pic, expr)); pic_try { val = pic_eval(pic, val, pic-\u0026gt;lib); } pic_catch { pic_errorf(pic, \u0026#34;macroexpand error while definition: %s\u0026#34;, pic_errmsg(pic)); } if (! pic_proc_p(val)) { pic_errorf(pic, \u0026#34;macro definition \\\u0026#34;~s\\\u0026#34;evaluates to non-procedure object\u0026#34;, var); } define_macro(pic, rename, pic_proc_ptr(val), senv); return pic_none_value(); } 手を入れる候補。やってることは単純で、(define-syntax \u0026lt;name\u0026gt; \u0026lt;definition\u0026gt;)の形で引数を渡される筈だからnameをdefinitionに関連づけてマクロとして登録します。返り値はnone。返り値はnone。大事なことなので2回言いました。\n一応実行時にはマクロ展開は全て終了してる筈なのでdefine-syntaxをマクロ展開時に消し去っても良い筈なんですが、気持ち悪いですよね。コアを小さくするという意味では正解なんですが…。あとファイルのコンパイルを考えた時にdefine-syntaxをファイルの外に持ち出せなくなるという実用上の問題もあります。\nあと、definitionがマクロ展開だけで止まってしまうと困るのでdefinitionだけはevalしているのもキモいポイントですね。\n改善案はdefineと同じようにすること。そのためにはマクロ展開後の処理(analyze、codegen、VM命令)にもdefine-syntax用の処理を入れる必要があって、面倒。\nlambda lambdaの扱いは面倒です。一番分かり易い例は再帰マクロですかね。マクロの定義中に定義中のマクロが見えてる必要があります。この解決策としてlambdaだけはマクロ展開を遅延(defer)します。じゃあいつ遅延されたマクロが展開されるかというと\npic_value pic_macroexpand(pic_state *pic, pic_value expr, struct pic_lib *lib) { struct pic_lib *prev; pic_value v; #if DEBUG  puts(\u0026#34;before expand:\u0026#34;); pic_debug(pic, expr); puts(\u0026#34;\u0026#34;); #endif  /* change library for macro-expansion time processing */ prev = pic-\u0026gt;lib; pic-\u0026gt;lib = lib; lib-\u0026gt;env-\u0026gt;defer = pic_nil_value(); /* the last expansion could fail and leave defer field old */ v = macroexpand(pic, expr, lib-\u0026gt;env); macroexpand_deferred(pic, lib-\u0026gt;env); pic-\u0026gt;lib = prev; #if DEBUG  puts(\u0026#34;after expand:\u0026#34;); pic_debug(pic, v); puts(\u0026#34;\u0026#34;); #endif  return v; } macroexpandの後です。macroexpandはmacroexpand_nodeの薄いラッパと思って下さい。\n遅延されたマクロ展開はsenv-\u0026gt;deferにpushされ、macroexpand_deferredで1つずつmacroexpand_lambdaされます。macroexpand_lambdaはまあ、想像通りです。formalをα変換したあとformalとbodyをマクロ展開します。α変換はsenvにシンボル -\u0026gt; gensymのキーペアを突っ込むだけです。返り値は(lambda formal body)。\ndefine 比較的単純です。(define name value)の他に(define (name formal) body)のMIT記法にも対応する必要があるのでマクロ展開時に特別扱いされてます。(define name value)を返り値として返します。MIT記法もこの形に正規化されます。\nquote 特に語る事はないです。\n他のマクロ Schemeのマクロ展開は簡単で、マクロ手続をbody、展開場所の環境、定義場所の環境の3つを引数として呼び出せば終りです。勿論macroexpand_nodeを見て分かるように最後まで展開します。picrinはCommon Lisp風の伝統的マクロもサポートしてるので伝統的マクロだった時はbodyだけを引数として呼び出します。\n蛇足 define-syntaxだけを指摘しましたが、マクロ展開後にnoneになるマクロは他にもあります。library関係全部です。個人的にはやつらもVM命令まで残すべきだと思ってます。\n因みにもう1つlibrary関係の問題があります。define-library直下のbeginについてです。\n(define-library (hoge) (begin (define foo ...) (define bar ...) ) ) のようなコードを考えます。define-library直下のbeginは他とセマンティクスが違って、begin内のコードをトップレベルで定義されたかのように扱う必要があります。しかしpicrinは普通のbeginと同じように扱っています。これがどのような違いを産むかというと、コンパイル順を見れば分かり易いです。\n仕様: fooのマクロ展開-\u0026gt;fooの解析-\u0026gt;fooのコード生成-\u0026gt;barのマクロ展開-\u0026gt;barの解析-\u0026gt;barのコード生成\npicrin: fooのマクロ展開-\u0026gt;barのマクロ展開-\u0026gt;fooの解析-\u0026gt;barの解析-\u0026gt;fooのコード生成-\u0026gt;barのコード生成\npicrinのコンパイル順序だとマクロ展開を先にやってしまうのでマクロ展開中に同じbegin内でdefineされたシンボルが見えなくなってしまいます。尚、後述しますが今のpicrinはこのコンパイル順序のおかげで手続の相互参照が可能になってます。ここもどうにかしないといけない。\nコード解析 入力:マクロ展開済みのS式\n出力:中間表現\n副作用:無し\nextlib/benz/codegen.cに処理があります。\nここの処理ではS式をVM命令に近いS式に書き換えます。(+ 1 x)が(+ (quote 1) (gref x))になるなど。この解析後のS式は特に呼び名はなさそうなので中間表現と呼んでおきます。\n中間表現にはcons、carなどの16の基本的な手続に対応する命令やif、defineなどの6つのスペシャルフォームの他、call、tailcall、call-with-values、tailcall-with-valuesの4つの手続呼び出し命令、gref、lref、crefの3つの変数参照、returnがあります。合計30の命令です。JIT化も視野に入れてるので基本命令は少なくする方針なんでしょう。また、組み込みも意識しているのでその気になればコアを小さく出来るようにする意味もあるのかもしれません。\ngrefはグローバル変数、lrefはローカル変数、crefはクcaptured変数を参照します。ここでピンときた方も居るかと思いますが、コード解析がスコープ周りを担当しています。\nanalyze_*系はanalyze_stateを持ち回ししますが、こいつはpicrin VMとスコープを表現する構造体の他に中間命令のシンボル(の一部)のキャッシュや中間命令にそのまま翻訳されるべき手続(consやcar)のキャッシュを持ちます。手続はライブラリに属するのでキャッシュを捜すときに少し特別な処理が入ってますね。中間命令のシンボルのキャッシュが一部だけなのは他はpic_state構造体が既に持ってるからですね。\nさて、本体はやはりanalyze_nodeですが30命令分のifを持つので少し大きいですね。載せるのをやめて面白いやつだけ取り上げましょうか。どうでもいいけどこれ、caseじゃなくてif elseなので並び換えたら高速化しそうですね。\n変数 analyze_varがスコープの深さでgref、lref、crefに振り分けます。analyze_*_varはgref、lref、crefを返すだけの関数。\nスコープを遡って変数を捜していき、変数が見付かったスコープの深さ=今いるスコープの深さならグローバル変数、、今いるスコープならローカル変数、それ以外なら捕捉変数です。\nstatic pic_value analyze_var(analyze_state *state, pic_sym sym) { pic_state *pic = state-\u0026gt;pic; int depth; if ((depth = find_var(state, sym)) == -1) { pic_errorf(pic, \u0026#34;unbound variable %s\u0026#34;, pic_symbol_name(pic, sym)); } if (depth == state-\u0026gt;scope-\u0026gt;depth) { return analyze_global_var(state, sym); } else if (depth == 0) { return analyze_local_var(state, sym); } else { return analyze_free_var(state, sym, depth); } } 因みにこれ、変数が見付からなかったらエラー出してますけどSchemeは仕様上は\n(define (foo) (bar)) (define (bar) ...) のように後から定義することも可能なので仕様に準拠してないことになります。ここが手を入れるポイント2つ目。\n改善案は見付からなかった変数は一旦NOWHEREとかに束縛しておいてanalyze時にはエラーを出さない。実行時にNOWHEREに束縛された変数が出てくればエラー。\ndefine static pic_value analyze_define(analyze_state *state, pic_value obj) { pic_state *pic = state-\u0026gt;pic; pic_value var, val; pic_sym sym; if (pic_length(pic, obj) != 3) { pic_errorf(pic, \u0026#34;syntax error\u0026#34;); } var = pic_list_ref(pic, obj, 1); if (! pic_sym_p(var)) { pic_errorf(pic, \u0026#34;syntax error\u0026#34;); } else { sym = pic_sym(var); } var = analyze_declare(state, sym); if (pic_pair_p(pic_list_ref(pic, obj, 2)) \u0026amp;\u0026amp; pic_sym_p(pic_list_ref(pic, pic_list_ref(pic, obj, 2), 0)) \u0026amp;\u0026amp; pic_sym(pic_list_ref(pic, pic_list_ref(pic, obj, 2), 0)) == pic-\u0026gt;rLAMBDA) { pic_value formals, body_exprs; formals = pic_list_ref(pic, pic_list_ref(pic, obj, 2), 1); body_exprs = pic_list_tail(pic, pic_list_ref(pic, obj, 2), 2); val = analyze_defer(state, pic_sym_value(sym), formals, body_exprs); } else { if (pic_length(pic, obj) != 3) { pic_errorf(pic, \u0026#34;syntax error\u0026#34;); } val = analyze(state, pic_list_ref(pic, obj, 2), false); } return pic_list3(pic, pic_symbol_value(pic-\u0026gt;sSETBANG), var, val); } 手続をdefineするときに上の後から定義(interreferencial definitionという)を一部の状況で実現するために束縛する値がlambdaかどうかで場合分けしています。lambdaの場合はanalyze_deferを使います。そうすることで\n(begin (define (foo) (bar)) (define (bar) ...)) と書けばbegin -\u0026gt; define foo -\u0026gt; define bar -\u0026gt; (analyze deferred) -\u0026gt; foo本体 -\u0026gt; bar本体 の順番に解析されることになるのでコンパイルが通ります。\nまた、defineされた手続に名前をつける(シンボルと手続を関連付けるのではない)役割もあります。\nlambda また例の再帰定義とかで面倒なやつです。analyze_lambdaが引数のチェックだけしたらanalyze_deferに丸投げして、analyze_deferはモックのエントリーポイントだけ返してdeferリストに処理をpushします。\nんで後から呼ばれるanalyze_deferredが1つずつanalyze_procedureします。マクロ展開と微妙に名前が違うのが気になりますね。\nanalyze_procedureが本体になるのですが、スコープを作るので少しややこしいことになってます。\nスコープと変数 スコープの解説をしてませんでしたね。変数を参照するときはスコープの関係で4種類出てきます。\n グローバル変数 : トップレベルでdefineされたもの ローカル変数 : lambda内でdefineされたもの 自由変数 : lambdaの外かつトップレベルでない変数 引数 : lambdaの引数  captureについて: 変数を導入した側から見たら「捕捉された変数」で、変数を参照する側から見たら「自由変数」です。\nさて、変数の種類を見たところでanalyze_procedureの定義を見てみましょう。\nstatic pic_value analyze_procedure(analyze_state *state, pic_value name, pic_value formals, pic_value body_exprs) { pic_state *pic = state-\u0026gt;pic; pic_value args, locals, varg, captures, body; assert(pic_sym_p(name) || pic_false_p(name)); if (push_scope(state, formals)) { analyze_scope *scope = state-\u0026gt;scope; pic_sym *var; size_t i; args = pic_nil_value(); for (i = xv_size(\u0026amp;scope-\u0026gt;args); i \u0026gt; 0; --i) { var = xv_get(\u0026amp;scope-\u0026gt;args, i - 1); pic_push(pic, pic_sym_value(*var), args); } varg = scope-\u0026gt;varg ? pic_true_value() : pic_false_value(); /* To know what kind of local variables are defined, analyze body at first. */ body = analyze(state, pic_cons(pic, pic_sym_value(pic-\u0026gt;rBEGIN), body_exprs), true); analyze_deferred(state); locals = pic_nil_value(); for (i = xv_size(\u0026amp;scope-\u0026gt;locals); i \u0026gt; 0; --i) { var = xv_get(\u0026amp;scope-\u0026gt;locals, i - 1); pic_push(pic, pic_sym_value(*var), locals); } captures = pic_nil_value(); for (i = xv_size(\u0026amp;scope-\u0026gt;captures); i \u0026gt; 0; --i) { var = xv_get(\u0026amp;scope-\u0026gt;captures, i - 1); pic_push(pic, pic_sym_value(*var), captures); } pop_scope(state); } else { pic_errorf(pic, \u0026#34;invalid formal syntax: ~s\u0026#34;, args); } return pic_list7(pic, pic_sym_value(pic-\u0026gt;sLAMBDA), name, args, locals, varg, captures, body); } スコープを作ったあとは最初に引数をスコープに登録して本体内ででcapture出来るようにしてます。んで本体をanalyzeしてローカル変数と捕捉された変数を洗い出してます。\n因みにvargというのはCommon Lispでいう\u0026amp;restや\u0026amp;optionalを引っ括めたものです。\nbegin static pic_value analyze_begin(analyze_state *state, pic_value obj, bool tailpos) { pic_state *pic = state-\u0026gt;pic; pic_value seq; bool tail; switch (pic_length(pic, obj)) { case 1: return analyze(state, pic_none_value(), tailpos); case 2: return analyze(state, pic_list_ref(pic, obj, 1), tailpos); default: seq = pic_list1(pic, pic_symbol_value(pic-\u0026gt;sBEGIN)); for (obj = pic_cdr(pic, obj); ! pic_nil_p(obj); obj = pic_cdr(pic, obj)) { if (pic_nil_p(pic_cdr(pic, obj))) { tail = tailpos; } else { tail = false; } seq = pic_cons(pic, analyze(state, pic_car(pic, obj), tail), seq); } return pic_reverse(pic, seq); } } そんなに大したコードじゃないんですけど末尾呼出最適化のためのコードが垣間見えたので載せました。\nbegin自身が末尾位置にいればbeginの最後の式は末尾位置になりますがそれ以外は必ず非末尾位置になるよねーってコードです。\nバイトコード生成 入力:中間表現\n出力:バイトコード\n副作用:無し\nextlib/benz/codegen.cに処理があります。\nここの処理では中間表現をスタックベースのpicrin VM命令に変換します。\nVM命令やlambdaの内部表現 VM命令フォーマット フォーマットは3種類あります。\nstruct pic_code { enum pic_opcode insn; union { int i; char c; struct { int depth; int idx; } r; } u; }; 見ての通り命令番号(opcode)+\n int char int2つ  になっています。因みに普通使われるのは1. intで、2. charはOP_PUSHCHARのみ、3. int2つはOP_CREFとOP_CSETのみに使われます。また、引数(?)を全く持たない命令もあります(スタックマシンなため)。\n愉快なVM命令たち enum pic_opcode { OP_NOP, OP_POP, OP_PUSHNIL, OP_PUSHTRUE, OP_PUSHFALSE, OP_PUSHINT, OP_PUSHCHAR, OP_PUSHCONST, OP_GREF, OP_GSET, OP_LREF, OP_LSET, OP_CREF, OP_CSET, OP_JMP, OP_JMPIF, OP_NOT, OP_CALL, OP_TAILCALL, OP_RET, OP_LAMBDA, OP_CONS, OP_CAR, OP_CDR, OP_NILP, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MINUS, OP_EQ, OP_LT, OP_LE, OP_STOP } 大体名前から分かるかと思います。quoteはOP_PUSH*系になります。OP_STOPはあるのにOP_STARTがないのは分かりますね。開始はユーザーの操作から始まるのに対して停止はプログラム側が行うからです。\nlambdaとか lambdaとかのエントリポイント付きのコード1まとまりはirepと呼ばれています。\nstruct pic_irep { PIC_OBJECT_HEADER pic_sym name; pic_code *code; int argc, localc, capturec; bool varg; struct pic_irep **irep; pic_valuel *pool; size_t clen, ilen, plen; };  PIC_OBJECT_HEADER: オブジェクトタイプのタグ name: 名前（あれば） *code: VM命令たち argc、 localc、 capturec: 引数数、ローカル変数数、捕捉された変数数 varg: \u0026amp;rest引数を持つか **irep: irepプール *pool: 定数プール clen、ilen、plen: *code、**irep、*poolの長さ  スコープを作るので変数を格納するpoolを持ちます。そしてlambdaだけは定数プールとは別にirepに格納します。\nコード生成 本体はcodegenなんですがこれまた長いので掻い摘んで。帰りがけ順でコード生成します。\ncons まずは肩馴らし。\nelse if (sym == pic-\u0026gt;sCONS) { codegen(state, pic_list_ref(pic, obj, 1)); codegen(state, pic_list_ref(pic, obj, 2)); cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_CONS; cxt-\u0026gt;clen++; return; } 引数1と引数2を生成する命令を吐いてからOP_CONS命令を吐きます。引数1と引数2は自ら値をスタックにPUSHします。\nquote 少し長いですが。\nelse if (sym == pic-\u0026gt;sQUOTE) { int pidx; obj = pic_list_ref(pic, obj, 1); switch (pic_type(obj)) { case PIC_TT_BOOL: if (pic_true_p(obj)) { cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_PUSHTRUE; } else { cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_PUSHFALSE; } cxt-\u0026gt;clen++; return; case PIC_TT_INT: cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_PUSHINT; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.i = pic_int(obj); cxt-\u0026gt;clen++; return; case PIC_TT_NIL: cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_PUSHNIL; cxt-\u0026gt;clen++; return; case PIC_TT_CHAR: cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_PUSHCHAR; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.c = pic_char(obj); cxt-\u0026gt;clen++; return; default: if (cxt-\u0026gt;plen \u0026gt;= cxt-\u0026gt;pcapa) { cxt-\u0026gt;pcapa *= 2; cxt-\u0026gt;pool = pic_realloc(pic, cxt-\u0026gt;pool, sizeof(pic_value) * cxt-\u0026gt;pcapa); } pidx = (int)cxt-\u0026gt;plen++; cxt-\u0026gt;pool[pidx] = obj; cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_PUSHCONST; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.i = pidx; cxt-\u0026gt;clen++; return; } } リテラルや定数をPUSHする命令を吐いてますね。\nREF系 local、captureはirep構造体についてるのpoolを参照します。globalはVMのシンボルテーブルから直接引きます。因みにpicrinのシンボルはただのintです。\ncaptureは上位のスコープで既に出てきた変数を参照するだけなので「n個上位のm番目のcaptured変数」と指定するだけなので簡単ですが、localはarg、普通のlocal、下位スコープにcaptureされたlocal、の3つに分けて置いているので少し面倒です。\nif (sym == state-\u0026gt;sGREF) { cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_GREF; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.i = pic_sym(pic_list_ref(pic, obj, 1)); cxt-\u0026gt;clen++; return; } else if (sym == state-\u0026gt;sCREF) { pic_sym name; int depth; depth = pic_int(pic_list_ref(pic, obj, 1)); name = pic_sym(pic_list_ref(pic, obj, 2)); cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_CREF; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.r.depth = depth; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.r.idx = index_capture(state, name, depth); cxt-\u0026gt;clen++; return; } else if (sym == state-\u0026gt;sLREF) { pic_sym name; int i; name = pic_sym(pic_list_ref(pic, obj, 1)); if ((i = index_capture(state, name, 0)) != -1) { cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_LREF; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.i = i + (int)xv_size(\u0026amp;cxt-\u0026gt;args) + (int)xv_size(\u0026amp;cxt-\u0026gt;locals) + 1; cxt-\u0026gt;clen++; return; } cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_LREF; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.i = index_local(state, name); cxt-\u0026gt;clen++; return; } 因みにset系もほぼ同じようなコードです。\nlambda else if (sym == pic-\u0026gt;sLAMBDA) { int k; if (cxt-\u0026gt;ilen \u0026gt;= cxt-\u0026gt;icapa) { cxt-\u0026gt;icapa *= 2; cxt-\u0026gt;irep = pic_realloc(pic, cxt-\u0026gt;irep, sizeof(struct pic_irep *) * cxt-\u0026gt;icapa); } k = (int)cxt-\u0026gt;ilen++; cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_LAMBDA; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.i = k; cxt-\u0026gt;clen++; cxt-\u0026gt;irep[k] = codegen_lambda(state, obj); return; } codegen_lambdaに投げているのでこの部分は簡単です。irepプールにコードを置いてそれを参照する命令を吐くだけ。\ncodegen_lambdaはというとそこまで長くなくて\nstatic struct pic_irep * codegen_lambda(codegen_state *state, pic_value obj) { pic_state *pic = state-\u0026gt;pic; pic_value name, args, locals, closes, body; bool varg; name = pic_list_ref(pic, obj, 1); args = pic_list_ref(pic, obj, 2); locals = pic_list_ref(pic, obj, 3); varg = pic_true_p(pic_list_ref(pic, obj, 4)); closes = pic_list_ref(pic, obj, 5); body = pic_list_ref(pic, obj, 6); /* inner environment */ push_codegen_context(state, name, args, locals, varg, closes); { /* body */ codegen(state, body); } return pop_codegen_context(state); } 単純に本体に対してcodegenを呼んで出来た命令を取り出してるだけです。\nif schemeはほとんどの制御を継続に任せているのでなんとjmp命令を吐くのはifだけです。\nelse if (sym == pic-\u0026gt;sIF) { int s, t; codegen(state, pic_list_ref(pic, obj, 1)); cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_JMPIF; s = (int)cxt-\u0026gt;clen++; /* if false branch */ codegen(state, pic_list_ref(pic, obj, 3)); cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = OP_JMP; t = (int)cxt-\u0026gt;clen++; cxt-\u0026gt;code[s].u.i = (int)cxt-\u0026gt;clen - s; /* if true branch */ codegen(state, pic_list_ref(pic, obj, 2)); cxt-\u0026gt;code[t].u.i = (int)cxt-\u0026gt;clen - t; return; } call 思ったより短いです。単純に引数を評価する命令を吐いたあと引数の数を指定して呼ぶだけです。\nelse if (sym == state-\u0026gt;sCALL || sym == state-\u0026gt;sTAILCALL) { int len = (int)pic_length(pic, obj); pic_value elt; pic_for_each (elt, pic_cdr(pic, obj)) { codegen(state, elt); } cxt-\u0026gt;code[cxt-\u0026gt;clen].insn = (sym == state-\u0026gt;sCALL) ? OP_CALL : OP_TAILCALL; cxt-\u0026gt;code[cxt-\u0026gt;clen].u.i = len - 1; cxt-\u0026gt;clen++; return; } 最後に これを書くのに半日掛かりましたがちゃんとコンパイルプロセスを理解して問題を洗い出すことが出来ました。良かった。\n今のところ中間表現までS式なのでS式操作に長けたSchemeでコンパイラ書けないかなとか考えてますが現状マクロ展開で副作用があるので厳しいですね。\n因みに気付いた方もいらっしゃるかと思いますが今のpicrinは最適化をtco以外は行っていません。行うとしたら\n マクロ展開後にコンパイラマクロ展開を挟む 中間表現から一旦ssa形式の第二中間表現に落して定数伝播や畳み込みなどの一般的な最適化を行なう 生成されたvm命令に対して覗き穴最適化を行なう  あたりかなと思います。1. は楽しそうですけど普通のマクロ展開のバグとか問題に悩んでる今入れるべきではないですし、2. は効果高いですしjit化の布石にもなりますが実装コストが高いのでwasabiz次第かなといったところ、3. は今どの程度非効率な命令が吐かれてるのか分からないので効果が見えにくいですね。\nいずれにせよ最適化は仕様準拠してからにしますか。\n何か質問や突っ込みがあれば@blackenedgoldまで。\n","categories":["Picrin","Lisp","Scheme"],"category_urls":["/categories/picrin","/categories/lisp","/categories/scheme"],"date":"2015-01-10","title":"picrinのcodegenプロセスを説明してみる","url":"https://KeenS.github.io/blog/2015/01/10/picrin-codegen-explanation/"},
  {"body":"以前の記事の続編。FreeBSDで普通の(Ubuntuで使っていたのと同程度の)環境を整えようとしたときの話。普通ならPC BSDを使えば苦労しないんだろうけど私のラップトップは少し古いのか癖があるのかGPTパーティションに対応してなくてPC BSDのインストーラが使えなかったのでFreeBSDを入れてデスクトップ環境を一から構築した。\nキーボード デフォルトでdvorakにしてるのに起動時にはqwertyになってる問題。なんかいつのまにか解決してた。多分だけど /etc/rc.confにkeymap=\u0026quot;jp.106\u0026quot;書いてから直った気がする。LANGの設定かも。\nFirefox 漢字が汚ない問題 フォントの問題と思ってたらアンチエイリアスの方だった。KDEの設定で[システム設定]-\u0026gt;[アプリケーションの外観]-\u0026gt;[フォント]-\u0026gt;アンチエイリアスの設定-\u0026gt;[スタイルのヒント]をなしにすると漢字にもアンチエイリアスが掛かる。しかしHelveticaが汚ない問題は直らなかった。というか今度はアンチエイリアスが掛かりすぎてぼやけてしまうようになった。Firefox (日本語) - ArchWikiに解決策があった。ビットマップフォントを拒否すれば良いらしい。\nメニューが日本語にならない問題 クイックロケールチェンジャーみたいなのがいつの間にか入ってたのでそれを使った。それを見るとロケールに日本語が入ってるのにデフォルトで英語を使うようになってたので英語のロケールを削除して日本語だけにしたらメニューも日本語になった。\nFlash 一応公式ハンドブックに設定方法が載ってるが、これでは動かなかった。linuxの互換レイヤーがカーネルパニック起こしてた。 sudo sysctl compat.linux.osrelease=2.6.18したらwww/linux-c6-flashplugin11のコンパイルとnspluginwrapper -a -v -iが通った。勿論後でcompat.linux.osrelease=2.6.18は/etc/sysctl.confに書き足した。あと/ect/rc.confにlinux_enable=YESも書いてある。多分必要。\n蛇足だけどlinux-c6がCentOS6互換レイヤ、linux-f10がFedora10互換レイヤらしい。排他的っぽい。\nDropbox DropboxのデスクトップアプリはFreeBSDをサポートしないものの、pkgにdropboxのAPIを叩くコマンドラインスクリプトがある。dropbox-api-commandって名前。手動でsyncすることになるけど実際スマホと写真のやりとに使ってる程度なので必要なときに手動でsyncしてる。unisonみたいな使い方。\nWifi KDEにデフォルトでセットアップアプリケーションがついてこないっぽいのでwifimgrを入れた。\nSSH Key ksshaskpassを導入、~/.xprofileに\nexport LANG=ja_JP.UTF-8 export LC_CTYPE=ja_JP.UTF-8 export LANG=ja_JP.UTF-8 export SSH_ASKPASS=/usr/local/bin/ksshaskpass eval $(ssh-agent) \u0026gt;\u0026gt; /dev/null を追加、~/.kde/Autostart/に\n#!/bin/sh export SSH_ASKPASS=/usr/local/bin/ksshaskpass /usr/bin/ssh-add を実行権限付きでssh-addという名前で保存してあとはKDE Walletをポチポチやったらログイン時にマスターパスワードを聞かれて、ログイン後はパスワード不要になった。\nまた蛇足。Xの起動時に読まれる設定ファイルは.xinitrc、.xprofile、.xsessionなどがある。.xsessionは過去の遺物、.xinitrcはstartxされた後ウィンドウマネージャの起動まで管理するスクリプトで由緒あるが最近は使われないことが多い、.xprofileは設定だけでウィンドウマネージャの起動まではしない設定ファイルで、gdm、kdmなどのウィンドウマネージャから読まれるとのこと。.xinitrcに.xprofileを読みにいく行を書いておけばXに関連する主な設定は.xprofileに書いておけば良い。\nEmacsでximが使えない問題 uim-ximが起動してなかった。\n.xprofileに\nexport XIM=\u0026#34;uim\u0026#34; export GTK_IM_MODULE=uim export QT_IM_MODULE=uim export XMODIFIERS=\u0026#39;@im=uim\u0026#39; を書いて、.kde4/Autostart/に\n#!/bin/sh exec /usr/local/bin/uim-xim を置いておけば使えるようになった。\n残った問題  スリープからの復帰時にディスプレイが点かない ラップトップ内のwifiが使えない 音が鳴らない KVM相当のものが使えない  やっぱうちのラップトップ(TOSHIBAのDynabook)特殊なのかなあ。\n※ 2015-1-10 追記 アプリケーションで音が鳴らない問題は、ドライバを確認したところ適切にロード出来てる。echo aaa \u0026gt; /dev/dsp0.0も動く（音がなる）ので訝してると、デフォルトの\u0026rdquo;出力\u0026rdquo;デバイスがマイク（！）になってました。 よくみると電源問題で色々いじってたときに/etc/sysctl.confにhw.snd.default_unit=1を書いてました。これを0にしてやるとちゃんとスピーカから音が出ました。めでたしめでたし。\n","categories":["FreeBSD"],"category_urls":["/categories/freebsd"],"date":"2015-01-08","title":"FreeBSDの環境構築","url":"https://KeenS.github.io/blog/2015/01/08/freebsd-environment-setups/"},
  {"body":"自分用。\nコピー  cp -Rじゃだめ。タイムスタンプが変わる。アーカイブ専用にcp -aがある。あるいはrsync 移動するのは  非隠しフォルダ/ファイル  但しDownloads/は除く。あれはプラットフォーム依存なバイナリなんかも含む Dropbox/はどっちでも良い。コピーせずにDropboxの同期に任せた方が確実 Desktop/はどうせ空だからコピーしてしまっても害はない  .ssh/ .emacs.d/ .twittering-mode.gpg .gitconfig .thunderbird/ .config/ 残りの隠しファイルはdot.filesにある もしかしたら.mozilla/もコピーしておくといいかも  compile/以下はmake cleanしておく。オブジェクトファイルがプラットフォーム依存だからコピーする意味ない compile/以下はファイル数が多くて時間かかるので要らないものはこの際削除 同じ理由で.cim/, .rvm/, .nvm/, .opam/なんかもコピーしない  コピーが終わったら  Emacsをビルドして起動、動作確認 Thunderbirdをインストール、動作確認 gitをインストール、githubとの接続確認 CIMをインストール、cim install sbclの動作確認 rustをビルドするときは./configureから始める  いつかやる  tarballにコピーするファイルを詰め込んどく  理想的にはメインのHDDとは別の記憶媒体にtarballを保存 定期実行が面倒になるくらいなら~/.backupにでも。気が向いた時に別の媒体にコピー  どうもappendオプションを使えばヒストリ付きのアーカイバとして使えるらしい ","categories":["備忘録"],"category_urls":["/categories/%e5%82%99%e5%bf%98%e9%8c%b2"],"date":"2015-01-04","title":"OSお引っ越しの時のデータ移行の自分用注意点","url":"https://KeenS.github.io/blog/2015/01/04/migration-memo/"},
  {"body":"新年明けましておめでとう御座います。κeenです。私から一つお知らせが御座います。\n私、本名を金舜琳といいますが今年から日本に帰化して志村舜琳と名乗ります。アルファベット表記もSunrim KIMからSunrin SHIMURAに変更致します。Sunrinも微妙に変化します。 尚、外部インターフェースのκeenは変らず、内部のみの変更になるので多くの方には影響は無いかと思います。 さらに正式に日本国籍を取得するまでは本名の金舜琳と通称名の志村舜琳両方で呼び出せるのでこの期間に移行下さい。\nさて、帰化の理由についてですが、主に外国人参政権に関連します。昔は私も外国人に参政権を渡せと叫んでおりましたが最近考え方が変わりました。権利が欲いなら国籍とればくれてやる、国籍を取る事は認める。それで良いと思います。韓国の権利よりも日本の権利が欲い、なら日本国籍を取る。筋は通っていると思います。書類上の変更で血筋が変わる訳でもありませんし。父親の世代は在日韓国人というだけで日本の社会から拒絶され、帰化＝屈服だったそうで今でも帰化には否定的なようですが特に反対はありませんでした。私と同世代の姉は、もっと歴史を勉強して納得してから決めると言っています。価値感はそれぞれでしょう。\nそれでは皆様、今年も一年κeenこと志村舜琳を宜くお願い致します。\nP.S.\n志村舜琳ってDQNネームっぽくて嫌だなぁ。下の名前も変えようかなぁ。\n","categories":[],"category_urls":[],"date":"2015-01-01","title":"新年の挨拶及び内部実装変更のお知らせ","url":"https://KeenS.github.io/blog/2015/01/01/new-year-greeting/"},
  {"body":"κeenです。年末ですね。こちらのブログにもあるようにOctopressの生成の遅さに閉口してたのでHugoに移行しました。 出来るだけブログのURLは変えないようにしました。でもどっかでリンク切れちゃってるかも。\nOctopressは遲い以外にもテンプレートのファイルが多い、Rubyのインストールとbundle installが必要、柔軟性がない、など不満があったのですがバイナリ配布のHugoは~/binに置くだけで良いですしテーマが気に入らなければユーザーがオーバーライドする仕組みもあるので好きにいじれます。まあ、結局テーマをフォークしちゃったんですけどね。\n作業 Markdownとメタデータは概ね互換性があるのでcontent/post/に突っ込んで先のブログのワンライナーを回せばとりあえず動きます。URL互換性を保つために\ncd content/post for f in *.markdown; do mv ${f} $(basename ${f#*-*-*-} .markdown).md;done みたいなのを回します。ヒストリ搜すの面倒なので今即興で書きました。\nんで記事にカテゴリのタグが欲いのと日付をISOっぽくしたかったのでテンプレートをオーバーライド。あ、テンプレートはliquoriceを使いました。\nシンタックスハイライト Hugoはデフォルトでは提供しません。サーバーサイドでやろうとするとpygmentsが遲いから。クライアントサイドだと複数あるらしいのでhighlight.jsにしてみました。Clojure REPLとか絶妙なものがあって良いですね。個人的にはコマンドラインのハイライトが欲かった…\nスライド Octopressの時はテーマに手を入れるわreveal.jsのテーマは自作するわちょっと表には出せないアドホックでダーティーなプラグインを作るわしてreveal.jsに無理やりブログのテーマを載せてました。\n今回はHugoテーマをフォークしてslide用のテンプレート書いて、Octopressの時に使っていたreveal.jsの自作テーマを少しいじるだけで済みました。しかもブロクにreveal.jsを埋め込む形になってます。この際remark.jsにしようかとも思ったのですがまたスライドのテーマ作るの面倒だったのでreveal.jsのままで。remark.jsだったら苦労せずとも導入出来たのかなぁ。\n一番の問題はreveal.jsにはmarkdownを食わせるのですが、Hugoがmarkdownをレンダリングしちゃうところですね。Octopressではプラグインで先にスライドだけ処理しちゃってOctopressには触らせないことで実現してました。\nHugoはgoのテンプレートを使っているのですがこれまた癖があって文脈に応じてそのまま出したりレンダリングしたりHTMLエスケープしたりJSエスケープしたりします。試行錯誤する内に markdown 全体を\u0026lt;section\u0026gt;で囲むとレンダリングされない というバグっぽい挙動を見付けました。というこで汚ないんですがスライドは各記事を手動で\n\u0026lt;section data-markdown data-separator=\u0026#34;\\n\u000c\\n\u0026#34; data-vertical=\u0026#34;\\n\u0006\\n\u0026#34; data-notes=\u0026#34;^Note:\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/template\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/section\u0026gt; で囲むことにしました。\n雑感 速いし導入楽だしもうOctopressに戻りたいとは思わないです。あとauto refleshが便利すぎる。変更したらビルドしてブラウザのリロードまでやってくれます。デュアルディスプレイだと捗りそうですね。\n不満はウィジェットが少ない、コマンド１発でデプロイ出来無い、octomacsが使えない。ソーシャルアイコン気に入ってたのに。\nあと折角なのでブログエントリ全体見返して細かな修正行いました。カテゴリの統一とか。\nこれで今年の大掃除終わり！\n","categories":["Octopress","Hugo"],"category_urls":["/categories/octopress","/categories/hugo"],"date":"2014-12-30","title":"OctopressからHugoに移行した","url":"https://KeenS.github.io/blog/2014/12/30/migration-from-octopress-to-hugo/"},
  {"body":"κeenです。Ubuntuのaptが古いのが我慢ならなくなってきたのでFreeBSDに移行しました。pkgのsbclが1.2.6ですよ！\n最初は踏ん切りがつかなかったのでメインの500GBのHDDではなく、ジャンクで買った128Gのものにインストール。様々な問題に当ったものの、どうにか使えてます。今はHDD換装してメインになってます。\n 問題の半分はKDEを導入したら直った（最初はCinnamon入れようとした。UbuntuではUnity使ってた） ２日くらいはつぶす覚悟 Xorgの設定を手で畫くことになるとは  良いところ  速い気がする。ufsのお陰？（HDDの問題？） Firefoxが全然CPU食わなくなった（プラグインの問題？） pkg使い易い！ Ubuntuで使ってたソフトウェア大体動く portsもある！！ Dtraceとかjailとか便利そうじゃね？  問題 たいてい解決or妥協してるのですが、どうにもならない点がいくつか\n skkservがセグフォる。multiskkserv使えない。今は辞書直読みで対応してる。 Wifiのデバドラがない。今はUSBのアダプタ使ってる（そっちのドライバはある） sleepすると復帰したときにディスプレイが点かない メインのHDDにデュアルブートでバックポート出来無かった 日本語キーボードのモディファイアキーを認識しない: のたうち回ってpolykitの設定とかsysctlとか書いてる内に直った。でもen配列だと無理  特に3番が痛い。\n解決/妥協した問題  インプットメソッド、ログインマネージャ、タイムゾーン: KDEを導入したら直った データの移行: fusefs_ext4でUbuntuのHDDマウントしてコピー、権限変更、chmod u+w フォント: sudo pkg install $(pkg search ja-font)の力技。あとはXorgの設定書いてKDEとFirefoxで好みのフォントを選んだ キーボードdvorakにしてるのにqwertyになる: qwertyで妥協。やりたければsekxkbdとかあるし ロケールが日本語になんなくてFirefoxとかが全部英語: ま、いっか タッチパッドでスクロールが出来無い: Xorgの設定書いた。ドライバもなんか設定書いた気がする kvmが使えない: むしろBHyVeを試してみるチャンス！開発中のVMMを提供してくれたFreeBSDに圧倒的感謝！！  デバドラとかハードウェア周りがつらい。ソフトウェアは統合デスクトップ環境が吸収してくれますね。\nEmacsとFirefoxとThunderbirdが動くので今のところ問題ないですね。今後また問題が出て来るかも。\n","categories":["FreeBSD","Ubuntu"],"category_urls":["/categories/freebsd","/categories/ubuntu"],"date":"2014-12-27","title":"FreeBSDに移行した","url":"https://KeenS.github.io/blog/2014/12/27/freebsd/"},
  {"body":"誰向けなのか分からない。多分5年後くらの初心を忘れた自分が読めば良いと思う。あるいは、独学でプログラミングを始めようとしてる人が参考にするのかもしれない。\n私はプログラミングを独学で学んだ。\n初めて触ったのは中学生のとき、ネットゲームのギルドのホームページを作ろうとなってHTML、CSS、JavaScriptという存在を知った。イヌでもわかるJavaScript講座を見てメモ帳で書いた20行くらいのスクリプトが当時の最高傑作だった。\nそれから名前の訊いたことのあったC言語を学ぼうとしたが、Vijuaru Stajioのインストールが出来なくて挫折した。CとC++とC#の違いも分ってなかった。\nその後、ネットゲームもしなくなり高校の間は全くプログラミングに触れずに大学に入った。\n1年夏学期の情報の授業でシェルを知った。最初は慣れなかったが次第に使えるようになって、家でもコマンドプロンプトを使うようになった。冬学期の情報科学でrubyを知った。あくまで情報科学であってプログラミングの授業ではなかったが、rubyに興味を持った。Ruby入門を見ながら覚えた。メソッド、クラス、オブジェクト指向…。カタカナ語が多くて中々頭に入らなかった。\n一つ、ターニングポイントになったと思うのはRuby逆引きハンドブックを買った時だと思う。どんな本かも分からずに買った。そして最初から最後まで読んだ。これで一通りプログラミング言語で何が出来るのか分かった気がする。手札の確認というか。逆引きを買ったのが1年生の冬学期の終わりだったかな？そしてバッチファイルで書いていた処理をrubyで置き換えたりしていた。\nその頃にはラップトップにCygwinが入っていた気がする。そしてEmacsをCygwin内で使っていた。いや、怪しいな。Cygwinのbinにパスを通してコマンドプロンプトからEmacsを使っていたかもしれない。\n春休みにプログラミングのバイトに応募してみた。それまでは個別指導をしていたが、兄弟会社でバイトを募集していると告知されたからだ。プログラミング試験はrubyで書いて恐る恐る提出すると合格だった。面談の結果Androidチームに入った。Javaは一行も書けない。最初のミーティングまでにJavaを覚えようとしたが間に合わなかった。戦々恐々と出社したが、仕事がみんなに降ってきて、自分の出来そうな仕事をして相応の報酬を貰う制度だったのでとりあえずのところ書けなくても困らなかった。\n2年生の夏学期。JavaとAndroidとEmacsを勉強していた。PC系サークルにも入った。確かこの頃Ubuntuを使い始めた。バイトはまだ一度もアサインされたことはなかったがどんな仕事はどんな人が持っていくのかはなんとなく分かってきた。Emacsの設定を触るうちにLispに興味を持ったのもこの辺じゃなかったかな。\n2年生の夏休み。合宿と強化練に忙殺されていたがバイトのタスクアサインに初めて手を挙げた気がする。君にはこの仕事はまだ早いと言われ、貰えなかった。もう一つ、ここで進路の決断を迫られた。大学に入ったときは数学科に行くつもりだったが情報系も検討した。最後まで悩んだ挙句数学科を選んだ。今思えば大失敗だったが後悔先に立たず。\n2年生の冬学期。学科の周りの人を見て絶望した。レベルが違い過ぎる。高校の数学が少し得意程度の人が来るべきところではなかった。数学者になる夢はここで潰えた。この時期は授業が少ないので我武者羅にプログラミング関係の情報を集めた。この頃にはRuby、Common Lisp、Javaが使えた筈。でもJavaが嫌いでAndroidアプリをJava以外で書く方法を捜してた。JRubyとRubotを試したけど遅すぎてダメだった。Clojure、Scala、Haskell、OCamlなどの名前もこの辺で知った。Clojureは少し触ってみた気がする。バイトで初めてのタスクアサインを受けたのもこの頃。プログラムを書く仕事ではなくテスターだったが。\nこれ以降、順調に学んでいった。QtRubyで胃に穴が空きそうになったり、どうしてもCommon Lispが気になって6月にShibuya.lispに初めて参加したり。\n2つ目のターニングポイントはISUCONだった。ISUCONの案内はPC系サークルのOBから来た。学生枠を設けるから講習会を開くとの案内。その頃は腕に覚えがあったのでバリバリスコア伸ばすつもりで夏期講習に参加した。コテンパンにやられた。手も足も出なかった。Webアプリケーションがどんなものかは分かっているつもりだったがSQLも知らないしNginXの設定も3時間くらい格闘して結局出来なかった。悔しいので予選でリベンジしようと思った。懇親会に出ると同じような人が何人かいて、チームを組むことになった。予選でも手も足も出なかった。私がNginXの担当になったがチューニング方法も全く分からなかった。神風が吹いて上位の学生チームがFailして本戦に出場することになった。流石に本戦で恥かしい思いはしまいと公式ブログの解答例を二人で復習した。NginX、SQL、Capistranoなどの知識を得た。そして本戦。善戦した。他の学生チームが全てFailするというまさかのオチで学生賞をとった。\nISUCONで学生賞を取ったのとISUCON関係でフォローした人の影響でOpsの方にも興味を持った。\nそういえばこの頃、睡眠時間を気にせずIT系の情報を漁っていたら体調を酷く崩してバイトを辞めた。\n思い出せばこの頃に色々と変わった。変わったというか壁を破ったというか。それまでコンスタントに参加していたShibuya.lispのLisp Meet Upで初めてLTをした。初めてのまともなOSSであるCIMを作った。プロコンに参加してみた。\nそしてそれから1年、勉強会で喋ってGithubで活動してISUCONに出て若干コンピュータサイエンスに興味を持った今の私になった。4年生では数学科らしからずパタヘネとMINIX本を講究でやっている。\nこれで大体合ってる筈なんだが書きたかったのはこういう事じゃなかった気がする。何がきっかけで殻を破ったか、どうやって独学で身につけたか。時系列は無視して書き連ねていく。\n上でも書いたように逆引きRubyが1つのターニングポイントだった。でも、どうしても書きたいものがあまりなくてソースコードを読んだ。WEBRicks。その頃はまだHTTPサーバーの仕組みを分かってなかったから理解出来なかったけど雰囲気は分かった。それとrush。今では死んだプロジェクトだけどrubyで書かれたシェルに夢を抱いてソースを読んだ。\n最初の頃は何でもググってた気がする。英語はスルーしてた。Common Lispを始めた時にはマイナー言語の宿命で英語は避けて通れなかったので肚を括った。しかしドキュメントも無いプロジェクトも多数あって、結局ソースをかなり読んだ。\nWEB上の情報も頼りにしてたが、やっぱり書籍が便利だった。ディスプレイが1つしか無いからブラウザとEmacsを行き来するのが面倒だったというのもあるかもしれない。今数えると50数冊持っていた。図書館で借りて読んだ本もあるから読んだ本だともうちょっと。\n上には出てこなかったがFreeBSDをKVM上で動かしている。FreeBSDを触り始めた時にはマニュアルを頼りにしろ、と書いてあった。成程、便利だ。それ以来ググるより先に公式ドキュメントやmanページを先に引くようになった。特にmanを引けるようになったのは大きかった気がする。\n「Lisperは一度はLisp処理系を書く」と言われて言語処理系に興味を持った。Rubyやmrubyのコードを読んで図書館でそれっぽい本（後にドラゴンブックと分かる）を手にとった。就活でプログラミング課題が出たときにJavaを書きたくなくてLispを実装してLispで解いた。初めてのLisp処理系だった。それからpicrinを見かけてpicrinにコミットし始めた。言語処理系が中で何をやっているか、そして一番GCなどのメモリ管理について理解が深まったのは大きかったと思う。\n低レベルの世界はパタヘネが導いてくれた。picrinにコミットし始めてCをゴリゴリ書いたのもある。高速なコードを書こうと思った時にアセンブラやCを知っていると全然違った。どうすれば速くてどこが遅くなる原因なのか。勿論、ドラゴンブックで最適化も学んだのでどの程度は処理系がやってくれるのかも少しは分っていた。\nデバッガはpicrinを開発してるときに覚えた。WEBにいくらでも資料がある。実はそれまではずっとprintfデバッグしかしたことがなかった。それからCommon Lispでも少し使うようになった。他の言語はまだ使っていない。\n理論の世界はOCamlとプロコンが入口だった。プロコンは賞金が出るらしいときいてリクルートプロコンに出た。4/10問解けてそれなりに満足して、少し興味を持った。chokudaiさんの講座を受けたり蟻本を買ったりして学んだ。Common Lispで実装しようとしてたらアルゴリズムイントロダクションを勧められた。図書館で借りた本だったので逃げてしまったが道具箱のカタログには入った。 OCamlは、「数学科の主な就職先は金融」「金融では主にOCamlが使われている」と訊いて始めた。OCaml界隈を追ってると、型だとかTaPLだとかCoqだとかが聴こえてきた（主に名古屋の方面から）。少し齧った。そこから関数型言語の世界に入った。HaskellもRWHをざっと読んでモナドを知り、SML#からSMLに入って、SMLも追ってみた。主に研究に使われているらしく、面白い機能を持った処理系がいっぱいあった。型安全pickling、リージョン推論、モジュールのコンパイル時畳み込み…。だいたい論文にリンクが貼ってあって、そこから論文を読むことを覚えた。\nバージョン管理システムは.emacsの管理をsvnで始めたのが最初だった。バイト先が最初svnだったから。DropBoxにsvnサーバを置いてちまちま使っていた。init.elだけはRCSで管理してた時期もあった気がする。バイト先がgitになってから手元もgitに以降した。gitbreakに.emacsを置いた。この時点ではまだGithuはソース読もうと思ったら良く出てくるダウンロードUIが最悪なサイトだった。しかししょっちゅう出てくるので義務感に刈られてアカウントを作った。Shibuya.lispでLTするにあたり、サンプルコードを置くのに初めてpushした。いや、Octopressのブログが先だったか？いずれにせよ3年生の9月あたりからコミットを始めた。gitは経験とWEBで覚えた。今はgit helpを参照している。\nOSについてはLinuxディストリを試して回ったときに学んだ。最初はUSBに焼くことしか知らず、同じUSBに何度も色々なディストリを焼いた。Ubuntuの次はArch、Gentoo、FreeBSD、 OpenSUSE。Gentooはブートローダやパーティションについて知る良い機会だった。PCを何度も再起動するのが耐えられなくて回避策を捜したらKVMが出てきた。三つ子の魂なんとやら、今でもコマンドラインからkvmコマンドで仮想マシンを起動している。そして今はMINIX本でもうちょっと詳しくOSについて学んでいる。\nAIはLispをやってると自然と行きつく。WEBを参考にしながらオセロのAIを作った。そのとき初めてSchemeを触った。なんでSchemeを選んだのかは覚えてない。SICPの影響だったかPC系サークルで部誌を書くにあたりSchemeのチュートリアルがあってそれに乗っかって選んだのか。ほぼGaucheのマニュアルだけでやりきった。魔法のように見えたAIが人工無能であることを理解した。探索、MiniMax、αβ法なんかも理解した。将棋のAI、碁のAIの本も買った。そこで機械学習を知った。\nデータ解析はビッグデータの流れから本を捜して学んだ。R。正直そんなに身に入ってないが心には留めている。\n機械学習はAIの流れとデータ解析の流れの合流地点だった。WEB、データ解析の本、AIの本などで断片的に知識を仕入れた。これもあまり身に入ってないがディープラーニングや画像処理の話題についていける程度にはなった。\n画像処理はAIの流れだった。五目並べに似たConnect 6というドマイナーなゲームのAIを作ろうとした。棋譜を打ち込むのが面倒だから画像処理でやろうとした。結局処理は出来なかったけど画像処理が裏で何をやっているのか、OpenCVで何が出来るのか、機械学習がどう使われるのかなどが分かった。公式マニュアルとWEBとオライリーのOpenCVも図書館で借りた気がする。道具箱に入った。\nネットワークは自宅サーバを立てようとしてルータをいじった時に少し覚えた。WEBで情報を得た。OSをインストールするときにも最初に設定が必要になる。正直まだまだ知識が足りてない。TCP/IPの本を流し読みしたけど覚え切れなかった。\nUnicodeやエンコードはpicrinをUnicode対応させようとしたときに調べた。WEBだとどうしても表面しか書いてない記事が多くて欲しい情報を探しきれなかったので本を買った。\n上に書いたことだと、勉強会はShibuya.lispが暖かく受け入れてくれたことから始まった。怖がらないことが大事。そしてLTを録画してくれるので見直して喋り方やスライドも改善した。\nOpsはISUCONがきっかけだった。Twitterで流れてくる情報を追った。運用に興味を持った。でも、自分で運用しているサービスなんてない。サーバもない。多分だから早くエンジニアになりたいと思ってるんだと思う。\nデータベースもISUCONがきっかけだった。SQLも然り。そこからNoSQLに行って7つのDB7つの世界を読んだ。道具箱のカタログの中身が増えた。データベースの実装が気になって少しRDBを作ってみた。トランザクションとかバックアップとかクラスタリングとかはまだどう実装するのか理解していない。\nLinuxプログラミングは自然に覚えた。シェルが内側で何をやっているか、高速なWEBサーバの背後にあるのは何か。データベースを効率的に実装するには何が必要か。picrinに機能を追加する時に最終的に何を使うのか。\nここで上に書いたものを改めて見てみる。何が必要で何が必要でないか分からない。全然足りない気がする。CPU作ったこともコンパイラ書いたこともデバイスドライバ書いたこともない。同年代の情報系の人は何を学んでいるのか。情報科学科と情報工学科でどれくらいの違いがあるのか。エンジニアに必要なスキルは何なのか。やっぱり見えない敵と戦っている。\n文系からエンジニアになったという人を見掛けた。見てると、大学に入り直して情報科学を体系的に学びたいと言っていた。彼女も多分見えない敵と戦ってるんだと思う。\n何だろう。大学を出るまであと3~4ヶ月。あと何を勉強しておけば良いのかな。\n","categories":["ポエム"],"category_urls":["/categories/%e3%83%9d%e3%82%a8%e3%83%a0"],"date":"2014-12-18","title":"独学のプログラミング","url":"https://KeenS.github.io/blog/2014/12/18/du-xue-falsepuroguramingu/"},
  {"body":"最近、エンジニアリングかサイエンスかという分類を教えてもらった。それが出てきたのはGoがエンジニアリングから出た言語だと言われた時だった。\nその時私はRustを推していたのでRustはサイエンスから出た言語だと言った。\nGoが出た時は「コンパイルの速いシステム記述言語」という触れ込みだった気がする。C++のコンパイルが遅いからGoを作った、ならエンジニアリングから出た言語と言える。 Rustは触れ込みがあった気はしないが代数的データ型やトレイト、リージョン推論（ライフタイム）などサイエンスの成果を反映している。サイエンスから出た言語と言って良いと思う。\nサイエンスとエンジニアリング。この言葉を知ってから随分ともやもやを説明出来るようになった。\n先のGoとRustの話に関連して。Goがここ15年のプログラミング言語の歴史を無視しているだとか、平ぺったい言語だとか言われるのを良く聞く。Goがサイエンスの成果をあまり取り入れなかったからだろう。 折しも関数型言語が流行っている今、サイエンス寄りになったエンジニアには物足りないのだと思う。\n私が競技プログラミングをあまり好きになれない（※個人の感想です）のはあれがサイエンスの一部分を競技化したものだからだ、と説明出来る。何故かというと私が興味があるのはエンジニアリングだから。エンジニアの募集に競プロを使うのは違う気がしていたのもそこなんだな、と気付いた。プログラムの書けないプログラマがどの程度いるのか知らないけど少しずれてる気がする。\nまあ、競プロが好きになれないのは他にも\u0026rdquo;コード\u0026rdquo;という広い意味の単語を競技プログラミングの意味で使ってるだとか私の好きな言語が使えないだとか勝てないだとかの理由もあるのだが。一応、補足しておくと私も競プロは競技としては楽しむ。\n逆に、以前後輩にISUCONのことを説明したらサイエンスの大会と理解されたようだった。違う。あれはエンジニアリングの大会だ。多くのエンジニアが腕を競う。実際にやってみないとエンジニアリングで何十倍も高速化するというのが理解出来ないかったのだろう。\n偶に院進を勧められることがある。理学部に居るし、普通なら院進する。特に父親は心配していた。その時は「なんとなく違う」と返していたが今ではちゃんと説明出来る。私がやりたいのはエンジニアリングだ。実際に手を動かさないと出来ない経験をしたい。エンジニアリングのためのサイエンスをやることはあるがサイエンスのためのサイエンスはしない。\n","categories":["ポエム"],"category_urls":["/categories/%e3%83%9d%e3%82%a8%e3%83%a0"],"date":"2014-12-18","title":"サイエンスかエンジニアリングか","url":"https://KeenS.github.io/blog/2014/12/18/saiensugaenziniaringu/"},
  {"body":"以前Common Lispの勉強の手引の記事を書いたときに実用Common Lispの名を挙げたが読んだことはなかった。\n一応名前を挙げた責任として読んでみた。\n読んだとは言ってもソースはざっくりしか見てないし、演習には目もくれてないので「一通り目を通した」程度。 買った本は逃げないのだし一回で理解する必要はない。最初に一通り内容を掴んで主張を理解してから、あとで気になった時につぶさに読むのが私の読み方。\n最初の感想を言うと、古い。Common Lispもcltl2とANSI両方に配慮されて書かれているし、紹介されているAIの事例も1970~1980年代のもの。 古典といった感じ。ただし、その時代はCommon LispとAIの最盛期なのでこの本を読めばCommon LispがAIで名を馳せた理由が良く分かる。\nCommon Lispの内容は初級程度。まえがきにもあるようにプログラマとしては中級だがLispは初心者レベルの人向に書かれている。基本的なところを押えたらあとはどんどん進んでいく。 プログラミングの経験があればそれでも問題ない筈。心配ならWeb上にいくらでもあるチュートリアルをこなせば良い。\nライブラリなどに関しては本の中で完結しているので良く言えば1から10まで教えてくれる。悪く言えば最近のCommon Lispの動向は全く分からない。その意味では実践入門ではなく学習図書。陳腐化はしない。\nAIについては、やはり古い。今では手法が確立されてAIの分野とは扱われないものも含まれている。ただし、これは意図したものなのかもしれない。 古いものというのは単純だ。最初に2部で単純なものを通して「肩馴らし」をしてから3部で手駒を増やして4部で踏み込んだ内容に入る。\nまた、AIの分野としては扱われていなものも含む、ということはこの本が情報科学の広い範囲をカバーする、ということでもある。900ベージは伊達じゃない。量もあればバラエティもある。\n現実にある様々な難解な問題をCommon Lispという強力な道具で快刀乱麻解決していく。ソフトウェア開発手法を学びながらCommon Lispの強力さを思い知るための一冊。\n","categories":["Lisp","Common Lisp","書評"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/%e6%9b%b8%e8%a9%95"],"date":"2014-12-14","title":"実用Common Lispを読んだ","url":"https://KeenS.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda/"},
  {"body":"このエントリーはML Advent Calendar 10日目の記事です。\n前 OCamlで作ったgoma言語 - h_sakurai\u0026rsquo;s diary\nふと思い立ってPrologのコンパイラかインタプリタかを作ってみようとして、その第一段でlexerに着手しました。\nちょ、SML分かる人はmllexくらい常識的に知ってるなんて言わないで下さい。私は初めて触りました。\nちょっと変則的なんですが、smlsharpの配布物にあるドキュメントを読みながらmlton付属のmllexを使い、sml/nj上で動作を確認しました。SMLの処理系管理ガバガバですね。\nまあ、初めて使ってみたとは言ってもほぼC版のlexのCを書く部分をそのままSMLで書けば良いだけなので簡単ですね。\n因みにPrologの文法は以下のようなもの。\n%reverse a list into X reverse([], []). reverse([Hd|Tl], X):- reverse(Tl, Y), append(Y, [Hd], X). reverse(List, X):- reverse(List, []). だいたいの部分は見れば分かるかと思うのですが、小文字で始まるのがリテラル（文字列？識別子？）で大文字から始まるのが変数です。\nで、これをイメージしながらlexファイルを書いていきます。\nLexファイル 全体はこのようになっています。lexと同じですね。\nSMLの補助コード部分 %% 補助ルールの記述 %% 解析ルールの記述 SMLの補助コードの部分は典型的にはdatatypeを書きます。あとはどうもerror : string -\u0026gt; unitと eof : unit -\u0026gt; 'aが必要みたいですね（マニュアルちゃんと読んでない）。'aというのは他の解析ルールと同じ型です。\n補助ルールはlexとだいたい同じです。生成した関数やらデータ型を収めるstructureの指定とかもします。\n解析ルールもだいたいlexと同じです。\npattern =\u0026gt; (SMLのコード); のような形をしてます。\n実際のコード 結構適当です。あ、カットのこと忘れてた。ほら、適当だった。\nこのコードをprolog.lexとして保存します。\ndatatype lexresult = Comment of string | LeftParen | RightParen | LeftBracket | RightBracket | Comma | Dot | Bar | Medaka | UnderScore | String of string | Number of int | Variable of string | EOF val linenum = ref 1 val error = fn x =\u0026gt; print (x ^ \u0026#34;\\n\u0026#34;) val eof = fn () =\u0026gt; EOF %% %structure PrologLex alphanum = [A-Za-z0-9]; alpha = [A-Za-z]; digit = [0-9]; ws = [\\ \\t\\n]; %% {ws}+ =\u0026gt; (lex()); %(.*)\\n =\u0026gt; (Comment yytext); \u0026#34;(\u0026#34; =\u0026gt; (LeftParen); \u0026#34;)\u0026#34; =\u0026gt; (RightParen); \u0026#34;[\u0026#34; =\u0026gt; (LeftBracket); \u0026#34;]\u0026#34; =\u0026gt; (RightBracket); \u0026#34;,\u0026#34; =\u0026gt; (Comma); \u0026#34;.\u0026#34; =\u0026gt; (Dot); \u0026#34;|\u0026#34; =\u0026gt; (Bar); \u0026#34;:-\u0026#34; =\u0026gt; (Medaka); \u0026#34;_\u0026#34; =\u0026gt; (UnderScore); [a-z]{alphanum}* =\u0026gt; (String yytext); {digit}+ =\u0026gt; (Number (foldl (fn(a, r)=\u0026gt; (ord(a)-ord(#\u0026#34;0\u0026#34;)) + 10*r) 0 (explode yytext))); [A-Z]{alphanum}* =\u0026gt; (Variable yytext);  実際に使ってみる。 $ mllex prolog.lex Number of states = 19 Number of distinct rows = 8 Approx. memory size of trans. table = 1032 bytes $ rlwrap sml Standard ML of New Jersey v110.77 [built: Thu Sep 4 12:32:33 2014] - use \u0026#34;prolog.lex.sml\u0026#34;; [opening prolog.lex.sml] [autoloading] [library $SMLNJ-BASIS/basis.cm is stable] [autoloading done] structure PrologLex : sig structure UserDeclarations : \u0026lt;sig\u0026gt; exception LexError structure Internal : \u0026lt;sig\u0026gt; structure YYPosInt : \u0026lt;sig\u0026gt; val makeLexer : (int -\u0026gt; string) -\u0026gt; unit -\u0026gt; Internal.result end val it = () : unit - val lexer = PrologLex.makeLexer (fn i =\u0026gt; TextIO.inputN(TextIO.openIn \u0026#34;reverse.pl\u0026#34;, i)); val lexer = fn : unit -\u0026gt; PrologLex.Internal.result - lexer(); val it = Comment \u0026#34;%reverse a list into X\\n\u0026#34; : PrologLex.Internal.result - lexer(); val it = String \u0026#34;reverse\u0026#34; : PrologLex.Internal.result - lexer(); val it = LeftParen : PrologLex.Internal.result - lexer(); val it = LeftBracket : PrologLex.Internal.result - lexer(); val it = RightBracket : PrologLex.Internal.result -  コメントの扱い失敗してますね。この辺はどうしようもないのかなあ\n困ったところ ドキュメントが古いSML/NJのものらしく、SMLのコードをそのまま書いても動かなかった。revfoldとかinputcとか。\n次回はmlyaccでも触ってみますか。\n","categories":["ML","SML","Prolog","mllex","Advent Calendar","ML Advent Calendar","Advent Calendar 2014"],"category_urls":["/categories/ml","/categories/sml","/categories/prolog","/categories/mllex","/categories/advent-calendar","/categories/ml-advent-calendar","/categories/advent-calendar-2014"],"date":"2014-12-10","title":"mllexを使ってみる。あるいはlexユーザーに対するmllexの解説","url":"https://KeenS.github.io/blog/2014/12/10/mllexwoshi-tutemiru/"},
  {"body":"κeenです。Lisp Advent Calendarはもう枠埋まっちゃったので普通にブログで。\nコマンドラインから実行可能なLispファイルをそれなりに多くの処理系で動くように作る話。\nこの話はCIMの生い立ちとも関連するんだけどシェルからLispを使いたいときは\n#!/usr/bin/env sbcl --script ... なんて書いてた人も多いんじゃないかと思うんだけどこれは色々問題がある。\n envは環境に依っては/usr/local/bin/envだったりする envは環境に依っては複数引数を取れない。\u0026rdquo;sbcl \u0026ndash;script\u0026rdquo;という名前のファイルを捜しにいく sbclでしか動かない  この問題の扱いは一応解決策がある\n#!/bin/sh #| exec sbcl --script \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; |# ... 3行目の#|がシェルのコメントでありLispのブロックコメントであるのがポイント。\n シェルは#!/bin/shを見てシェルスクリプトとして実行する 1,3行目はコメントなのでシェルは無視 4行目でsbclにそのファイルを引数として与えてexecする。execしたあとはシェルには戻らないのでその後何が書いてあっても構わない sbclを--script付きで読んでるので1行目の#!で始まる行は無視する 3~5行目はブロックコメントなのでsbclは無視 それ以降がLispとして実行される  というカラクリになっている。こういうのをピジン言語っていうんだけ？\nまあいいや。\nところでこのブロックコメントの中にはシェルスクリプト書き放題だよね？そのシェルスクリプト内でどのLisp使うか決めたらポータブルになりそうじゃない？\nこういうのはどう？\n#!/bin/sh #| run_if_exists(){ command -v $1 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; exec \u0026#34;$@\u0026#34; } run_if_exists sbcl --noinform --no-sysinit --no-userinit --script \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists clisp -norc --quiet --silent -on-error exit \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists ecl -norc -q -shell \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists mkcl -norc -q -shell \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; run_if_exists alisp -qq -#! \u0026#34;$0\u0026#34; -- \u0026#34;$@\u0026#34; |# (write-line (lisp-implementation-type)) (force-output) cclとabclは1行目のシェバンを読み飛ばせなかった\u0026amp;評価結果をエコーバックしない方法が見当らなかったからパス。CMUCLは自分の環境で動かないから検証出来てない。\nこれでポータブルに実行は可能。コマンドライン引数の扱いとかはライブラリを頼ってくれ。因みにCIMでは\n#+allegro (cdr (system:command-line-arguments)) #+sbcl (do* ((var sb-ext:*posix-argv* (cdr list)) (list var var)) ((string= (car list) \u0026#34;--\u0026#34;) (return (cdr list)))) #+clisp ext:*args* #+ecl (do* ((var (si:command-args) (cdr list)) (list var var)) ((string= (car list) \u0026#34;--\u0026#34;) (return (cdr list)))) #+abcl extensions:*command-line-argument-list* #+gcl (do* ((var si::*command-args* (cdr list)) (list var var)) ((string= (car list) \u0026#34;--\u0026#34;) (return (cdr list)))) #+cmu ext:*command-line-words* #+ccl ccl:*unprocessed-command-line-arguments* #+mkcl (do* ((var (si:command-args) (cdr list)) (list var var)) ((string= (car list) \u0026#34;--\u0026#34;) (return (cdr list)))) #+lispworks system:*line-arguments-list* としている。参考までに。\n","categories":["Lisp","Common Lisp","Shell","CLI"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/shell","/categories/cli"],"date":"2014-12-08","title":"割と処理系ポータブルなCommon Lisp実行可能ファイルを作る","url":"https://KeenS.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/"},
  {"body":"このエントリーは\nLisp Advent Calendar 7日目\n兼\nH2O Advent Calendar 7日目\nの記事です。\nκeenです。タイトルの通りです。\nH2Oとは 水。\npicrinとは Wikipediaにあるように、フェノールのトリニトロ化合物で、水溶性があります。\nではなくて H2OはHTTP1, HTTP2, WebsocketをサポートするNginXより速いHTTPサーバです。Githubで開発されています。開発者は@kazuhoさん。\npicrinは「速い、軽い、高機能」を目指して作られているScheme処理系です。Githubで開発されています。開発者は@wasabizさん。\n混ぜる picrinのように組込み向けで開発されている処理系は\n picrinからH2Oを使えるようにする H2Oにpicrinを埋め込む  と、2種類考えられますが、今回は後者です。H2Oにpicrinを溶かしてる感じしますね。\nまあ、Apatch HTTPDやNginX宜しくmod_picrinを作れば済むでしょう。\n絶望 @blackenedgold モジュラーにできるようにはしてるけど、まだsoをロードする仕組みはないです。というか、APIがまだunstableだし\n\u0026mdash; Kazuho Oku (@kazuho) 2014, 12月 5 \nつらい\nsolシステムの導入 mod_xxxにしようと思ったんですけど水だし溶液ってことでsol_xxxにします。\nH2Oにこんな感じのパッチ当てて\ndiff --git a/src/main.c b/src/main.c index 7fc4680..57804a6 100644 --- a/src/main.c +++ b/src/main.c @@ -30,6 +30,7 @@  #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; +#include \u0026lt;dlfcn.h\u0026gt;  #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; @@ -76,6 +77,8 @@ struct config_t {  } state; }; +typedef int(*sol_init_fn)(h2o_configurator_command_t *, h2o_configurator_context_t *, const char *, yoml_t *); +  static unsigned long openssl_thread_id_callback(void) { return (unsigned long)pthread_self(); @@ -381,6 +384,43 @@ static int on_config_num_threads(h2o_configurator_command_t *cmd, h2o_configurat  return h2o_config_scanf(cmd, config_file, config_node, \u0026#34;%u\u0026#34;, \u0026amp;conf-\u0026gt;num_threads); } +static int on_config_use(h2o_configurator_command_t *cmd, h2o_configurator_context_t *ctx, const char *config_file, yoml_t *config_node) +{ + /* struct config_t *conf = H2O_STRUCT_FROM_MEMBER(struct config_t, global_config, ctx-\u0026gt;globalconf); */ + char *sol_name; + sol_init_fn init_fn; + void *handle; + + /* fetch solution name */ + switch (config_node-\u0026gt;type) { + case YOML_TYPE_SCALAR: + sol_name = config_node-\u0026gt;data.scalar; + break; + default: + h2o_config_print_error(cmd, config_file, config_node, \u0026#34;value must be a string or a mapping (with keys: `port` and optionally `host`)\u0026#34;); + return -1; + } + + char dl_name[strlen(\u0026#34;sol_.so\u0026#34;) + strlen(sol_name) + 1]; + char init_fn_name[strlen(\u0026#34;init_sol_\u0026#34;) + strlen(sol_name) + 1]; + + sprintf(dl_name, \u0026#34;./sol_%s.so\u0026#34;, sol_name); + sprintf(init_fn_name, \u0026#34;init_sol_%s\u0026#34;, sol_name); + handle = dlopen(dl_name, RTLD_LAZY); + if (! handle){ + h2o_config_print_error(cmd, config_file, config_node, \u0026#34;cannot load the solution\u0026#34;); + return -1; + } + + init_fn = dlsym(handle, init_fn_name); + if(dlerror()){ + h2o_config_print_error(cmd, config_file, config_node, \u0026#34;cannot find the initialize function\u0026#34;); + return -1; + } + return (*init_fn)(cmd, ctx, config_file, config_node); + +} +  static void usage_print_directives(h2o_globalconf_t *conf) { h2o_linklist_t *node; @@ -606,6 +646,10 @@ int main(int argc, char **argv)  c, \u0026#34;num-threads\u0026#34;, H2O_CONFIGURATOR_FLAG_GLOBAL, on_config_num_threads, \u0026#34;number of worker threads (default: 1)\u0026#34;); + h2o_config_define_command( + c, \u0026#34;use\u0026#34;, H2O_CONFIGURATOR_FLAG_GLOBAL, + on_config_use, + \u0026#34;use the solution\u0026#34;);  } h2o_access_log_register_configurator(\u0026amp;config.global_config);  こんな感じのソリューション用意して\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;pthread.h\u0026gt;#include \u0026#34;picrin.h\u0026#34;#include \u0026#34;picrin/pair.h\u0026#34;#include \u0026#34;picrin/string.h\u0026#34;#include \u0026#34;picrin/error.h\u0026#34;#include \u0026#34;h2o.h\u0026#34; pic_state *pic; struct pic_lib *PICRIN_BASE; void pic_init_contrib(pic_state *); void pic_load_piclib(pic_state *); static pic_value pic_features(pic_state *pic) { pic_get_args(pic, \u0026#34;\u0026#34;); return pic-\u0026gt;features; } static pic_value pic_libraries(pic_state *pic) { pic_value libs = pic_nil_value(), lib; pic_get_args(pic, \u0026#34;\u0026#34;); pic_for_each (lib, pic-\u0026gt;libs) { libs = pic_cons(pic, pic_car(pic, lib), libs); } return libs; } void pic_init_picrin(pic_state *pic) { const char *scheme = \u0026#34;(import (scheme base)\u0026#34; \u0026#34; (scheme write))\u0026#34; \u0026#34;(define-syntax call-with-output-to-string\u0026#34; \u0026#34; (syntax-rules ()\u0026#34; \u0026#34; ((_ proc)\u0026#34; \u0026#34; (let ((s (open-output-string)))\u0026#34; \u0026#34; (proc s)\u0026#34; \u0026#34; (get-output-string s)))))\u0026#34; \u0026#34;(define (-\u0026gt;string e)\u0026#34; \u0026#34; (call-with-output-to-string\u0026#34; \u0026#34; (lambda (s)\u0026#34; \u0026#34; (display e s))))\u0026#34;; pic_add_feature(pic, \u0026#34;r7rs\u0026#34;); pic_deflibrary (pic, \u0026#34;(picrin library)\u0026#34;) { pic_defun(pic, \u0026#34;libraries\u0026#34;, pic_libraries); } pic_deflibrary (pic, \u0026#34;(scheme base)\u0026#34;) { pic_defun(pic, \u0026#34;features\u0026#34;, pic_features); pic_init_contrib(pic); pic_load_piclib(pic); } pic_deflibrary (pic, \u0026#34;(picrin base)\u0026#34;) { pic_load_cstr(pic, scheme); } } const char * pic_eval_cstr_into_cstr(pic_state *pic, const char *input) { pic_value v; v = pic_read_cstr(pic, input); v = pic_eval(pic, v, PICRIN_BASE); v = pic_funcall(pic, PICRIN_BASE, \u0026#34;-\u0026gt;string\u0026#34;, pic_list1(pic, v)); return pic_str_cstr(pic_str_ptr(v)); } int on_picrin(h2o_configurator_command_t *cmd, h2o_configurator_context_t *ctx, const char *config_file, yoml_t *config_node) { const char *sexp; switch (config_node-\u0026gt;type) { case YOML_TYPE_SCALAR: sexp = config_node-\u0026gt;data.scalar; break; default: h2o_config_print_error(cmd, config_file, config_node, \u0026#34;value must be a string\u0026#34;); return -1; } pic_try{ puts(pic_eval_cstr_into_cstr(pic, sexp)); } pic_catch{ pic_print_backtrace(pic); return -1; } return 0; } int init_sol_picrin(h2o_configurator_command_t *cmd, h2o_configurator_context_t *ctx, const char *config_file, yoml_t *config_node) { h2o_configurator_t *c = cmd-\u0026gt;configurator; pic = pic_open(0, NULL, NULL); pic_init_picrin(pic); PICRIN_BASE = pic_find_library(pic, pic_read_cstr(pic, \u0026#34;(picrin base)\u0026#34;)); h2o_config_define_command( c, \u0026#34;picrin\u0026#34;, H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR, on_picrin, \u0026#34;run picrin\u0026#34;); return 0; } んでコンフィグは\n# to find out the configuration commands, run: h2o --helpuse:picrinlisten:port:listen:port:8081ssl:certificate-file:examples/h2o/server.crtkey-file:examples/h2o/server.keypicrin:\u0026#34;(string-append \\\u0026#34;Hello, \\\u0026#34; \\\u0026#34;World\\\u0026#34;)\u0026#34;hosts:default:paths:/:file.dir:examples/doc_rootaccess-log:/dev/stdout そして魔法のコマンドを叩いて\n$ cp ~/compile/picrin/src/{init_contrib.c,load_piclib.c} ./ $ gcc -c sol_picrin.c -std=c99 -o sol_picrin.o -I ~/compile/picrin/extlib/benz/include -I ~/compile/h2o/include -I ~/compile/h2o/deps/picohttpparser -I ~/compile/h2o/deps/yoml -DH2O_USE_LIBUV=0 -fPIC $ gcc sol_picrin.o load_piclib.o init_contrib.o -L ~/compile/picrin/build/lib/ -l picrin -fPIC -shared -o sol_picrin.so $ cp sol_picrin.so ~/compile/h2o 実行すると\n$ cd ~/compile/h2o $ ./h2o --conf example/h2o/h2o.conf Hello, Wold ヤッタ！\n標準出力かよ ううっ。ごめんなさい。\nで、HTTPレスポンス版は？ ごめんなさい、まだです。\nfile.cをベースにして\npaths:/:picrin.exp:\u0026#34;(string-append \\\u0026#34;Hello, \\\u0026#34; \\\u0026#34;World\\\u0026#34;)\u0026#34; とかしたかったんですけど間に合いませんでした。\nソリューションなりモジュールなりのシステムが出来たらまたトライします\n","categories":["Lisp","Scheme","Picrin","H2O","Advent Calendar","Advent Calendar 2014"],"category_urls":["/categories/lisp","/categories/scheme","/categories/picrin","/categories/h2o","/categories/advent-calendar","/categories/advent-calendar-2014"],"date":"2014-12-07","title":"H2Oにpicrinを溶かす","url":"https://KeenS.github.io/blog/2014/12/07/h2onipicrinworong-kasu/"},
  {"body":"このエントリーはLisp Advent Calendar 20146日目の記事です。\n前: nobkzさんで lfe - (lisp (flavored (erlang)))について基本その1 - Qiita\n後: 私で H2Oにpicrinを溶かす | κeenのHappy Hacκing Blog\nκeenです。アドベントカレンダーめっちゃ書いてますね。\nClasp! claspのmasterに色々マージされました。リリースノートには、\n Clasp version 0.11 * Added ASDF support. This is still alpha. Compile the ASDF module using (core:compile-asdf). After that you can load the module using (load \u0026ldquo;sys:kernel;asdf;build;asdf.bundle\u0026rdquo;). It takes between 15-30 seconds to load (this is why I\u0026rsquo;m integrating Cleavir). * Added the :CLASP feature and removed the :ECL feature. Clasp will continue to mimic the underlying ECL functionality so that Common Lisp code that supports ECL can be made to support Clasp by converting #+ecl to #+(or ecl clasp) and #-ecl to #-(or ecl clasp) * Added code to generate object files directly from Clasp. The LLVM bitcode compiler \u0026ldquo;llc\u0026rdquo; no longer needs to be in the PATH for Clasp to generate object files from Common Lisp source. The \u0026ldquo;ld\u0026rdquo; linker does need to be accessible. \nとあります。ASDFが使える！リリースノートには書いてませんがslimeサポートもmasterにコミットされてます。あとコミット読んだら最適化もされてるような…。\n以前二十数秒掛かっていた(fib 29)ですが、今回はなんと\n$ /usr/local/clasp/bin/clasp_boehm_o Starting Clasp 0.11 ... loading image... it takes a few seconds Top level. \u0026gt; (load \u0026#34;fib.lisp\u0026#34;) 1346269 real time : 34.294 secs run time : 38.844 secs T \u0026gt; (compile-file \u0026#34;fib.lisp\u0026#34;) #P\u0026#34;/home/kim/Lisp/fib.bc\u0026#34; NIL NIL \u0026gt; (load \u0026#34;fib.bc\u0026#34;) 1346269 real time : 21.355 secs run time : 25.785 secs T うわぁ。遅くなってる。\n因みに.bcファイルはLLVMの中間ファイルなのでClaspとは独立にopt -f -O3 fib.bc \u0026gt; fib.opt.bcで最適化出来ます。それをやると\n$ opt -f -O3 fib.bc \u0026gt; fib.opt.bc $ /usr/local/clasp/bin/clasp_boehm_o Starting Clasp 0.11 ... loading image... it takes a few seconds Top level. \u0026gt; (load \u0026#34;fib.opt.bc\u0026#34;) 1346269 real time : 34.981 secs run time : 37.986 secs T あれ？遅くなった。\nmpsはまだコンパイル中だから待ってね\nASDFを使ってみる $ /usr/local/clasp/bin/clasp_boehm_o Starting Clasp 0.11 ... loading image... it takes a few seconds Top level. \u0026gt; (time (core:compile-asdf)) zsh: segmentation fault (core dumped) /usr/local/clasp/bin/clasp_boehm_o はい。解散。因みに50分くらいは動いてた。\n","categories":["Lisp","Common Lisp","Advent Calendar","Lisp Advent Calendar"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/advent-calendar","/categories/lisp-advent-calendar"],"date":"2014-12-06","title":"claspがアップデートされたよ","url":"https://KeenS.github.io/blog/2014/12/06/claspgaatupudetosaretayo/"},
  {"body":"このエントリーはマイナー言語 Advent Calendar 2014 - Qiita4日目の記事です。\n前: ksmakotoさんでマクロ、拙作のテキストマクロ言語m55について主に - ksmakotoのhatenadiary\nκeenです。進捗ダメです。マイナー言語Advent Calendarが空いてるようだったのでMirahの話を捩じ込みますね。\nMirahとは？ 以前の記事を参照していただければだいたい分かるかと思いますが、「Ruby風の文法で書けるJava」です。JRubyのようにRubyをJavaで実装したのでもなくGroovyのようにJVM上で動く別の言語でもなく、あくまでJavaそのものです。\nJRubyとの違いは理解頂けるかと思いますが、Groovyとの違いを説明するとしたら一番はランタイムですかね。Groovyはコンパイル後のソースもGroovyを必要としますがMirahはコンパイルされたら普通のJavaで書いたのと同じ.classファイルになります。\nかといってくるくる括弧({})をendで書けるだけかというとそうでもなく、多くのシンタックスシュガーがマクロとして実装されています。\n例えば\n10.times do |i| puts i end はJavaの\nfor(int i = 0; i \u0026lt; 10; i++) System.out.println(i); と同じバイトコードを生成します。\nv0.1.4リリースおめでとうございます。 2014-11-14にv0.1.4がリリースされました。ラムダ式について少し進展があったようです。\n(lambda Runnable do 1000.times { puts \u0026#34;Hello\u0026#34;} end).run とか書けます。が、\n(lambda Runnable do 1000.times { puts \u0026#34;Hello\u0026#34;} end).start とは書けませんでした。やりたいのはこっちなのにね。ちょっと突っついてみます。\nここからそれっぽい情報入手出来ます。\nここからNetBeansのプラグインを入手出来ます。\n","categories":["Advent Calendar","Mirah","Advent Calendar 2014"],"category_urls":["/categories/advent-calendar","/categories/mirah","/categories/advent-calendar-2014"],"date":"2014-12-04","title":"mirahについて","url":"https://KeenS.github.io/blog/2014/12/04/mirahnituite/"},
  {"body":"(:meta\n((:this \u0026ldquo;Lisp Advent Calendar 2014の3日目の記事\u0026rdquo;)\n(:prev (:author \u0026ldquo;tk_riple\u0026rdquo; :title \u0026ldquo;時の羅針盤＠blog: R7RSポータブルライブラリを書く際の落とし穴\u0026rdquo;))\n(:next (:author \u0026ldquo;nobkz\u0026rdquo; :tite \u0026ldquo;Shenの基礎その1 基本的な型 - Qiita\u0026rdquo;))))\nκeenです。さっきまでVOPで遊んでたので当初の予定を変更してVOPの話をします。\nVOPとは何か SBCLやCMU CLで使われているネイティブコードを吐くための機構、要はインラインアセンブラです。\nVOPとはどんなものか とりあえずコードをば。x86-64用です。\n(in-package :cl-user) (defpackage vop-sample (:use :cl :sb-ext :sb-c)) (in-package :vop-sample) (defknown add (fixnum fixnum) ; addのftypeを宣言 fixnum (movable ; 副作用がない flushable ; デッドコードとして除去してよい foldable ; 定数畳み込みをしてよい always-translatable) ; 必ずアセンブラコードになる :overwrite-fndb-silently t) ; 関数上書きのエラーを出さない (in-package \u0026#34;SB-VM\u0026#34;) (define-vop (vop-sample::add) ; VOP名 (:translate vop-sample::add) ; 関数名 (:policy :fast-safe) ; declare optimize的な (:args (x :scs (signed-reg)) ; 引数宣言。後述 (y :scs (signed-reg))) (:arg-types fixnum fixnum) ; 引数の型宣言 (:results (r :scs (signed-reg))) ; 返り値宣言。後述 (:result-types fixnum) ; 返り値の型宣言 (:generator 4 ; 翻訳するときのコスト (move r x) ; 返り値レジスタにxを移動 (inst add r y))) ; 返り値レジスタにyを足し込む (in-package :vop-sample) (defun add (x y) ; 安全なバージョンでラップする (add x y)) ちょっとおまじないが多いですね。\nすこし解説すると引数は基本レジスタ渡しで、レジスタが足りなければスタックも使います。で、レジスタやスタックの値には型があります。それがストレージクラス(sc)です。この場合、x、y、rはsigned-regと宣言されてますね。符号付きレジスタです。:scsの最後のsは複数形のsです。今回は1つしか指定してませんが複数指定することも可能なのです。\nmoveというのはアセンブラ命令ではなく、マクロかなんかです（適当）。VOPなのかな？どのストレージクラスからどのストレージクラスに移動するかを認知して適切な命令を吐きます。\ninstが付いてるのがアセンブラですね。\nこのコード、xとrが等しいときに最適化出来るのですがそれはまあおいといて、こいつをディスアセンブルしてみましょう。\nVOP-SAMPLE\u0026gt; (disassemble #\u0026#39;add) ; disassembly for ADD ; Size: 43 bytes. Origin: #x1005C26416 ; 16: 488BD3 MOV RDX, RBX ; no-arg-parsing entry point ; 19: 48D1FA SAR RDX, 1 ; 1C: 488BF9 MOV RDI, RCX ; 1F: 48D1FF SAR RDI, 1 ; 22: 4801FA ADD RDX, RDI ; 25: 48D1E2 SHL RDX, 1 ; 28: 488BE5 MOV RSP, RBP ; 2B: F8 CLC ; 2C: 5D POP RBP ; 2D: C3 RET ; 2E: CC0A BREAK 10 ; error trap ; 30: 02 BYTE #X02 ; 31: 19 BYTE #X19 ; INVALID-ARG-COUNT-ERROR ; 32: 9A BYTE #X9A ; RCX ; 33: CC0A BREAK 10 ; error trap ; 35: 04 BYTE #X04 ; 36: 08 BYTE #X08 ; OBJECT-NOT-FIXNUM-ERROR ; 37: FE1B01 BYTE #XFE, #X1B, #X01 ; RDX ; 3A: CC0A BREAK 10 ; error trap ; 3C: 04 BYTE #X04 ; 3D: 08 BYTE #X08 ; OBJECT-NOT-FIXNUM-ERROR ; 3E: FE9B03 BYTE #XFE, #X9B, #X03 ; RDI NIL 主要な部分はここです。\n; 19: 48D1FA SAR RDX, 1 ; 1C: 488BF9 MOV RDI, RCX ; 1F: 48D1FF SAR RDI, 1 ; 22: 4801FA ADD RDX, RDI ; 25: 48D1E2 SHL RDX, 1 ; 28: 488BE5 MOV RSP, RBP ; 2B: F8 CLC ; 2C: 5D POP RBP ; 2D: C3 RET ADDの他に無駄な命令がいくつかありますね。\nSBCLはintの下位1bitをGCのときのタグとして使ってるのでアセンブラに渡す前に算術右シフト(SAR)して渡してます。 そして返るときはまた左シフト(SHL)してます。\nその後の\n; 28: 488BE5 MOV RSP, RBP ; 2B: F8 CLC ; 2C: 5D POP RBP ; 2D: C3 RET は関数から返るときのイディオム(スタックポインタを復元してフラグをクリアして呼び出し元に戻る)です。\n余談ですがLispマシンなどのタグマシンは下位ビットにあるタグを無視して計算出来るのでシフトが不要になります。なので速いんですね。\nシフトをなくす さっきはsigned-regを指定しました。つまり「（アセンブラの）intをくれ」と要求した訳です。 intの下位1bitは0なので足し算する分には別にシフトされなくても問題ありませんよね。シフトを殺しましょう。\nさっきのコードの下にこれを足します。addは再定義しないと反映されないようでした。\n(in-package \u0026#34;SB-VM\u0026#34;) (define-vop (vop-sample::add/v2) ; vop名は異なる (:translate vop-sample::add) ; 関数名は同じ (:policy :fast-safe) (:args (x :scs (any-reg)) ; any-regになってる (y :scs (any-reg))) ; any-regになってる (:arg-types fixnum fixnum) (:results (r :scs (any-reg))) ; any-regになってる (:result-types fixnum) (:generator 3 ; コストをさっきより低くすると優先して使ってくれる (move r x) (inst add r y))) (in-package :vop-sample) (defun add (x y) (add x y)) んで、ディスアセンブルしてみると\nVOP-SAMPLE\u0026gt; (disassemble #\u0026lsquo;add)\n; disassembly for ADD ; Size: 31 bytes. Origin: #x1004C2AB83 ; 83: 488BD1 MOV RDX, RCX ; no-arg-parsing entry point ; 86: 4801FA ADD RDX, RDI ; 89: 488BE5 MOV RSP, RBP ; 8C: F8 CLC ; 8D: 5D POP RBP ; 8E: C3 RET ; 8F: CC0A BREAK 10 ; error trap ; 91: 02 BYTE #X02 ; 92: 19 BYTE #X19 ; INVALID-ARG-COUNT-ERROR ; 93: 9A BYTE #X9A ; RCX ; 94: CC0A BREAK 10 ; error trap ; 96: 04 BYTE #X04 ; 97: 08 BYTE #X08 ; OBJECT-NOT-FIXNUM-ERROR ; 98: FE1B01 BYTE #XFE, #X1B, #X01 ; RDX ; 9B: CC0A BREAK 10 ; error trap ; 9D: 04 BYTE #X04 ; 9E: 08 BYTE #X08 ; OBJECT-NOT-FIXNUM-ERROR ; 9F: FE9B03 BYTE #XFE, #X9B, #X03 ; RDI NIL はい。見事にSARとSHLが消えましたね。\nもう少し複雑な型を扱う アセンブラですし(simple-array (unsigned-byte 8) (*))(以下octets)を扱いたいですよね。とりあえず難しいことは考えずにoctetsの0番目の要素にアクセスしてみましょう。とはいってもsimple-arrayは長さや要素の型の情報も持っていることが予想されるので少しデータを読み飛ばさないといけませんね。\nその辺の計算が分からなかったのでsbclのソースからそれっぽいものを参考にしました。\n(defknown access-simple-array-0 ((simple-array (unsigned-byte 8) (*))) (unsigned-byte 8) (movable flushable always-translatable) :overwrite-fndb-silently t) (in-package \u0026#34;SB-VM\u0026#34;) (define-vop (vop-sample::access-simple-array-0) (:translate vop-sample::access-simple-array-0) (:policy :fast-safe) (:args (x :scs (descriptor-reg))) (:arg-types *) (:results (r :scs (unsigned-reg))) (:result-types unsigned-num) (:generator 4 (inst movzx r (make-ea :byte :base x :disp (- (* vector-data-offset n-word-bytes) other-pointer-lowtag))))) (in-package :vop-sample) (defvar *octets* (make-array 4 :element-type \u0026#39;(unsigned-byte 8) :initial-contents \u0026#39;(10 11 12 13))) (defun access-simple-array-0 (x) (access-simple-array-0 x)) こんな感じになります。境界チェックとかはやってませんが許して下さい。\ndescriptor-regというのがポインタが入ってるレジスタっぽいです。movzxは8bitの値を64bitのレジスタに符号拡張しながらロードする命令です。\nmake-eaというのがアドレッシングですね。xレジスタを起点として(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)バイト(？ワード？)先のメモリ1byteを指します。\nディスアセンブルしてみましょう。みなさんもう慣れてきたと思うので主要部だけ抜き出します。\n; 65: 0FB65101 MOVZX EDX, BYTE PTR [RCX+1] ; no-arg-parsing entry point ; 69: 48D1E2 SHL RDX, 1 短いですね。このBYTE PTR [RCX+1]がmake-eaした値に対応します。RCXはxで(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)の結果が1に現れてるんでしょう。補足しておくと、EDXとRDXは同じ場所を指します。32bitとして扱うときはE、64bitとして扱うときはRで指します。\nさて、私はx86のアドレッシングモードなんて全然知らないのですがコードを見る限りもうちょっと複雑なアドレッシングが出来るようです。\n配列のn番目にアクセスするコードが良い例のようです。\n(defknown access-simple-array-n ((simple-array (unsigned-byte 8) (*)) (unsigned-byte 64)) (unsigned-byte 8) (movable flushable always-translatable) :overwrite-fndb-silently t) (in-package \u0026#34;SB-VM\u0026#34;) (define-vop (vop-sample::access-simple-array-n) (:translate vop-sample::access-simple-array-n) (:policy :fast-safe) (:args (x :scs (descriptor-reg)) (i :scs (unsigned-reg))) (:arg-types * unsigned-num) (:results (r :scs (unsigned-reg))) (:result-types unsigned-num) (:generator 4 (inst movzx r (make-ea :byte :base x :scale 1 :index i :disp (- (* vector-data-offset n-word-bytes) other-pointer-lowtag))))) (in-package :vop-sample) (defun access-simple-array-n (x i) (access-simple-array-n x i)) 新たに引数iをとるようになったのとmake-eaの引数に:scale 1 :index iが加わってます。\nディスアセンブルしてみましょう。\n; 98: 0FB6543901 MOVZX EDX, BYTE PTR [RCX+RDI+1] ; no-arg-parsing entry point ; 9D: 48D1E2 SHL RDX, 1 アドレッシングに+RDIが加わりましたね。どうしてi(RDI)をRASしなくていいのか気になりますがまあ、とりあえず正常に動いてるようです。\nおわかりかと思いますがアドレッシングがxをベースにして今までの定数オフセット+新たにレジスタで指定したオフセットになってます。\nmake-eaに渡した:indexは何か分かるとしても:scaleが気になりますよね。scaleを2にしてディスアセンブルしてみます。\n; 58: 0FB6547901 MOVZX EDX, BYTE PTR [RCX+RDI*2+1] ; no-arg-parsing entry point ; 5D: 48D1E2 SHL RDX, 1 はい。インデックスを定数倍するようですね。\nSSEにチャレンジ インテルアーキテクチャにあるSSEとはStreaming SIMD Extensionsの略です。じゃあSIMDは何かというとSimple Instruction Mulitple Dataの略で、1命令で複数のデータを処理出来ます。\nこの「複数のデータ」というのは64bit2つや32bit4つなどを128bitにまとめて渡します。128bitの値なんてどうやって作るんだよって感じですがsbcl-1.1.8から入ったsb-ext:%make-simd-pack-*が存在します。\nVOP-SAMPLE\u0026gt; (%make-simd-pack-ub32 1 2 3 4) #\u0026lt;SIMD-PACK 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00\u0026gt; こんな感じです。x86_64がリトルエンディアンだったのを思い出させる表記ですね。ub32の他にub64、single、doubleが存在します。\nストレージクラスも*-sse-regというものがあるのでこれを使いましょう。\n(defknown simd-add ((simd-pack (unsigned-byte 64)) (simd-pack (unsigned-byte 64))) (simd-pack (unsigned-byte 32)) (movable flushable always-translatable) :overwrite-fndb-silently t) (in-package \u0026#34;SB-VM\u0026#34;) (define-vop (vop-sample::simd-add) (:translate vop-sample::simd-add) (:policy :fast-safe) (:args (x :scs (int-sse-reg)) (y :scs (int-sse-reg))) (:arg-types simd-pack-int simd-pack-int) (:results (r :scs (int-sse-reg))) (:result-types simd-pack-int) (:generator 4 (move r x) (inst padddw r y))) (in-package :vop-sample) (defun simd-add (x y) (simd-add x y)) はい。こんな感じですね。paddwはparallel add wordですかね。これをディスアセンブルすると思ったより大きな命令になったので全部貼っときますね。\nVOP-SAMPLE\u0026gt; (disassemble #\u0026#39;simd-add); disassembly for SIMD-ADD ; Size: 108 bytes. Origin: #x1006D64A21 ; 21: 660F6FC2 MOVDQA XMM0, XMM2 ; no-arg-parsing entry point ; 25: 660FFDC1 PADDW XMM0, XMM1 ; 29: 49896C2440 MOV [R12+64], RBP ; thread.pseudo-atomic-bits ; 2E: 4D8B5C2418 MOV R11, [R12+24] ; thread.alloc-region ; 33: 498D5320 LEA RDX, [R11+32] ; 37: 493B542420 CMP RDX, [R12+32] ; 3C: 7740 JNBE L2 ; 3E: 4989542418 MOV [R12+24], RDX ; thread.alloc-region ; 43: 498D530F LEA RDX, [R11+15] ; 47: L0: 48C742F165030000 MOV QWORD PTR [RDX-15], 869 ; 4F: 48C742F900000000 MOV QWORD PTR [RDX-7], 0 ; 57: 660F7F4201 MOVDQA [RDX+1], XMM0 ; 5C: 49316C2440 XOR [R12+64], RBP ; thread.pseudo-atomic-bits ; 61: 7402 JEQ L1 ; 63: cc09 break 9 ; pending interrupt trap ; 65: l1: 488be5 mov rsp, rbp ; 68: f8 clc ; 69: 5d pop rbp ; 6a: c3 ret ; 6b: cc0a break 10 ; error trap ; 6d: 02 byte #x02 ; 6e: 19 byte #x19 ; invalid-arg-count-error ; 6f: 9a byte #x9a ; rcx ; 70: cc0a break 10 ; error trap ; 72: 04 byte #x04 ; 73: 32 byte #x32 ; object-not-simd-pack-error ; 74: fe1b01 byte #xfe, #x1b, #x01 ; rdx ; 77: cc0a break 10 ; error trap ; 79: 04 byte #x04 ; 7a: 32 byte #x32 ; object-not-simd-pack-error ; 7b: fe9b03 byte #xfe, #x9b, #x03 ; rdi ; 7e: l2: 6a20 push 32 ; 80: bac0854200 mov edx, 4359616 ; alloc_tramp ; 85: ffd2 call rdx ; 87: 5a pop rdx ; 88: 80ca0f or dl, 15 ; 8b: ebba jmp l0 nil なにやってるのやら。\n出来なかったこと PCMPESTRIを使ってみたかったのですが扱いがトリッキーなので断念しました。具体的に言うと操作する値を格納するレジスタがEAXとECX固定なようなのです。 :temporary節で内部で使うレジスタも要求出来るようなのですが名指しでもらえるんですかね。\nSSEの使い方とsimple-arrayから要素の配列を取り出す方法までは示したので誰かやって下さい。\n参考資料いっぱい置いときますね。\n How to Define New Intrinsics in SBCL - Paul Khuong mostly on Lisp VOPの使い方。最初の方に出てきたaddの最適化のやつとかも出てくる。(en) Hacking SSE Intrinsics in SBCL (part 1) - Paul Khuong mostly on Lisp SBCLのsimd-packの具体的解説(en) Fresh in SBCL 1.1.8: SSE Intrinsics! - Paul Khuong mostly on Lisp SBCLでVOPとSSEを使ってマンデルブロ集合を計算する(en) Packed Compare Intrinsics IntelのPCMPESTRIとかのマニュアル(en) _mm_cmpestri MicrosoftのPCMPESTRIのマニュアル。こっちの方が分かりやすい(en) Intel optimization PCMPISTRIを使ったstrlenの実装例(ja) Kazuho\u0026rsquo;s Weblog: Improving Parser Performance using SSE Instructions (in case of PicoHTTPParser) PCMPESTRIを使ってHTTPパーサーを高速化した話。これをやりたかった。(en)  おわりに おつかれ様でした。たまには低レベルなことをやっても良いんじゃないでしょうか。\n明日はnobkzさんで、Shenについてです。\n","categories":["Lisp","Common Lisp","SBCL","VOP","Advent Calendar","Advent Calendar 2014","Lisp Advent Calendar"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/sbcl","/categories/vop","/categories/advent-calendar","/categories/advent-calendar-2014","/categories/lisp-advent-calendar"],"date":"2014-12-02","title":"VOPで遊ぶ","url":"https://KeenS.github.io/blog/2014/12/02/vopdeyou-bu/"},
  {"body":"κeenです。最近のCommon Lispのパッケージ管理はql:quickloadしか知らないという方も多いのではないでしょうか。しかしそれだけでは機能が足りないこともあります。Common Lispには様々な管理システムがあるので整理しましょう。\nprovide, require 同じファイルを読み込まないための原始的なシステムです。Common Lispの標準の機能です。(require 'foo)がファイルをロードし、ロードされたファイル内で(provide 'foo)しておくと2回目以降の(require 'foo')はファイルを読まずにすぐさま返ります。\nここで問題なのがrequireがどこのファイルを捜しにいくかは処理系依存なところですね。なので生のrequireは使えないと思っておいた方が良いでしょう。\nASDF 3 Another System Definition Facility。過去にはAnotherじゃないSystem Definition Facilityもあった模様。最新版は3系です。結構APIが変っているので必ず3の情報を捜しましょう。\nこの「System」というのが聞き慣れませんが、ASDFのdefsystemで\n systemに含まれるファイルの定義 依存systemの記述 その他作者、ライセンス、バージョンなどの記述 systemのコンパイルやロード、テストなどの操作  が可能です。ASDFはCにとってのmake + ldを標榜しています。Makefile的なものは(systemname).asdになります。\nrequireとの統合もされており、ASDFを適切に設定することでdefsystemされたsystemをrequireでロードすることが出来ます。このときASDFは処理系に依存せずにASDFのパスに従って.asdファイルを捜しにいきます。\nまた、ほとんどの処理系はASDFを標準添付していて、大抵(require 'asdf)すれば使えるようになっています。\n尚、コンパイル後のファイルは処理系、バージョン毎に互換性がないので本来なら適切に管理する必要がありますが、ASDFが適切に~/.cache/common-lisp以下に管理してくれます。優秀ですね。\nquicklisp lispプロジェクトのインストーラと微妙にパッケージマネージャ的な役割をします。\nhttp://beta.quicklisp.org/quicklisp.lisp をダウンロードしてきてそのファイルを読み込んで(quicklisp-quickstart:install)すれば~/quicklisp/以下にquicklispがインストールされ、ロードされます。処理系を再起動したあとまたquicklispをロードするには~/quicklisp/setup.lispをloadします。が、毎回それをやるのが面倒な人は(ql:add-to-init-file)しておけば処理系の初期化ファイルに~/quicklisp/setup.lispを読み込む処理が書き加えられます。\nさて、このquicklispを扱う上で3つの概念を覚えておくと良いです。\n dist releaseの配布元。普通は\u0026rsquo;quicklisp\u0026rsquo;のみだがほかのdistを使うことも可能。自前のやつとか。新たなdistを追加したり削除したり出来る。gitのremoteをイメージすればよい。 release quicklispがダウンロードしてくる単位。ライブラリの作者が登録するときの単位。複数のsystemをもつこともある。 system ASDFのsystem。ユーザーが使うときの単位。  さて、quicklispを使うときは通常使いたいシステムをql:quickloadすればそのシステムと依存システムの含まれているリリースをダウンロード、展開、ロードまでしてくれます。\n開発中はREPLを立ち上げているので「あ、このライブライリ使おう」と思ったらql:quickloadするだけで即座に使えるようになりますね。\nquicklispのリリースは毎月下旬にアップデートされていて、毎月ちゃんと全てのライブラリが対応処理系で動くことがテストされています。なのでメンテナが居なくなったライブラリはドロップします。代わりにquicklispの作者がテスト出来ないライブラリは登録させてもらえなかったりします（cl-cudaとか）\nquicklispの問題 既にCommon Lispのライブラリマネージャとしてデファクトスタンダード的位置を築きつつあるquicklispですが、私は結構不満があります。\n ~/quicklisp/setup.lispを読み込むとquicklispの全てを読み込んでしまう: これには過去全てのバージョンのdistとreleaseとsystemのデータベース、HTTPクライアント、圧縮ファイルの解凍ライブラリなども含まれており、処理系の起動が非常に遅くなる 特にデータベースはファイルに書かれていても高速に読める形式なのに初期化時に毎回全ての内容をLispのハッシュに変換するという愚行をする。 (ql:add-to-init-file)が推奨されているが、前述の通り処理系の起動が遅くなってしまう。特に、（インストーラではなく、インストール済みの）ライブラリマネージャとして使いたくてもインストーラの機能までロードしてしまう。結構メモリを食うしアプリケーションには要らない。 処理系に依っては初期化ファイルはlispファイルをスクリプトとして使うときは読み込まれないこともあるのでスクリプトには使えない。まあ、前述の通り使いたくもない。  のでライブラリマネージャにはASDFが向いてるのですが、\n quicklispでインストールしたシステムはquicklispを一旦ロードするかASDFの設定をいじるかしなければASDFからは使えない quicklispはシステムのダウンロード/インストールだけすれば良いものをロードまでする 要はASDFを隠す じゃASDFのラッパーかというとロードしかせず、コンパイルやテストなどはしない  など様々な問題があります。\n一応quicklispの弁護をしておくと、Common Lispは他のスクリプト言語とはちょっと使い方が違って、\n 初期化ファイルは大抵オレオレライブラリで埋め尽くされていてそもそも起動には時間がかかる Emacsのように一度REPLを立ち上げたら滅多に落とさない アプリケーションも基本的にはREPLの中で使う 起動時間を気にするなら初期化ファイルを全てロードした、コアファイルをダンプしておいて使う  といった使い方をされることが多いのです。そのような人からしてみたら細々処理されるよりも起動時間とメモリは気にしないから速いやつをくれ、となるのです。\nじゃあそれなりにCommon Lispを使う私が何故そうしないかというと\n 立ち上げっぱなしというのが性に合わない。立ち上がっているものを見るとすぐに落としたくなる。EmacsのヘビーユーザーだがEmacsもすぐ落とす。 コマンドラインアプリケーションを作りたいため、起動時間が命になる。 私はSBCLの開発版を使っていて、コアファイルはすぐに無効になるためコアダンプはしない（意味がない）  といった理由があります。これは初心者にも共通する部分があるんじゃないでしょうか。REPLを立ち上げっぱなしにはしないし「コアダンプ？なにそれ？エラー出してんじゃん」状態でしょう。\nASDFを正しく使う ということでquicklispをあまり使わない方法を紹介します。\n前述の通り、quicklispでインストールしたシステムはquicklispを一旦ロードするかasdfの設定をいじるかしなければasdfからは使えません。具体的に言うと、\n ASDFのデフォルトパスは~/common-lisp以下 quicklispのシステムのインストールパスは~/quicklisp/dists/(dist name)/software/以下  なので~/quicklisp/dists/以下にパスを通します。少し無駄なディレクトリもパスに含まれてしまうので気にする人はそれぞれのdistについて~/quicklisp/dists/(dist name)/software/にパスを通しましょう。\n因みに拙作のCIMは~/.cim/quicklisp以下にquicklispをインストールするのでCIM使いの方は~/.cim/quicklisp/dists/ですね。~/quicklispの方が混乱少ないかなあ。\nさて、ASDFの設定は公式マニュアルを参照すれば良いのですが一応実際のものを書いておくと\n~/.config/common-lisp/source-registry.conf に\n(:source-registry (:tree \u0026#34;~/quicklisp/dists/\u0026#34;) (:tree (:home \u0026#34;Lisp/\u0026#34;)) :INHERIT-CONFIGURATION) を書けばOKです。2つめのLisp/は私がCommon Lispファイルを置いているディレクトリですね。この書き方だとquicklispより自分のLispライブラリを優先して読みにいきます。開発版を使いたいときとかむしろ開発をするときとかに必須です。この設定をミスるといくら開発してもロードされてるのはリリース版で、機能が動かないとかの地獄を見ます。\nここまでくれば\n(require \u0026#39;asdf) (require \u0026#39;hoge) とすればquicklispでインストールしたライブラリをロード出来ます。\nrequire以外のASDFの使い方 バージョンに依って使い方が異なるのですが、3系だと(asdf:xxx-system 'hoge)などとします。具体的には\n (asdf:load-system 'hoge) ( = (require 'hoge)) (asdf:test-system 'hoge) (テストがあるときのみ) (asdf:compile-system 'hoge)  を覚えておけば良いでしょう。他にもいくつか操作があるようですが私は使ったことがないです。asdf:locate-systemは名前的に便利そうではあるんですけどね。\n開発するときはまず.asdファイルを書いておいて(あるいはcl-projectから生成して)、(require 'hoge)で始めて書いていき、ある程度進んだらテストを書いてテストの項目を.asdファイルに書き足して(asdf:test-system 'hoge)、それなりに動くようになったら(asdf:compile-system 'hoge)してコンパイルの様子を見たりコンパイル後のベンチマークを取ったりします。\nquickloadを成仏させる これでロードの処理はASDFで全てカバー出来るようになりました。じゃあquickloadのロード機能は邪魔ですね。quicklispをインストーラとしてのみ使いましょう。\nまず処理系の初期化ファイル(sbclなら~/.sbclrc)から\n;;; The following lines added by ql:add-to-init-file: #-quicklisp (let ((quicklisp-init (merge-pathnames \u0026#34;~quicklisp/setup.lisp\u0026#34; (user-homedir-pathname)))) (when (probe-file quicklisp-init) (load quicklisp-init :verbose nil))) を削除します。quicklispを使いたいときだけ(load \u0026quot;~/quicklisp/setup.lisp\u0026quot;)します。そして欲しいシステムをインストールするには\n(ql::recursively-install \u0026#34;foo\u0026#34;) します。quickloadに比べて爆速です。ここにきて名前が文字列な上にexportされてないシンポル参照してますね。気持ち悪いという方は大人しくquickloadしましょう。\n拙作のCIMにはこれをコマンドラインから行なうql installなるコマンドが存在します。\n最後に quicklispが嫌いなのは私の好みですがASDFを正しく使えて損はないと思うので知らなかった方々は是非試してみて下さい。\n","categories":["Lisp","Common Lisp","Quicklisp","ASDF"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/quicklisp","/categories/asdf"],"date":"2014-11-30","title":"require, ASDF, quicklispを正しく使う","url":"https://KeenS.github.io/blog/2014/11/30/quicklisp/"},
  {"body":"κeenです。先日 Lisp Meet Up #22 でLTしてきたので報告です。\nLTは事前に登録されたのが2件、私が当日17時くらいに登録したの1件で、参加は20人募集の内20人応募、20人参加と最近中々の人気を見せてます。\nCommon Lispで高速なHTTPパーサーを書く(仮) LT1件目は深町さんより、「Common Lispで高速なHTTPパーサーを書く(仮)」。fast-httpを作ったときの話。\n  Writing a fast HTTP parser  from fukamachi \n動画\n深町さんのブログに書かれていることの他、fast-httpが高速になるまでの経緯や実装方針などの話もありました。\n最初ベースにしたnode.jsのHTTPパーサ、http-parseは状態を持っていて、1文字読む毎に状態を保存していた。次にベースにしたpicohttpparseは状態を持たず、HTTPリクエストが全部届く前にパースを始めてしまった場合はあきらめて最初からパースするようにしていた。fast-httpは1行パースする毎に状態を保存するようにした。など。\nもう一つ、http-parseはwhileループの中に巨大なcase文があって、現在の状態でcaseでディスパッチし、その節の中で読んだ文字に依って現在の状態を変え、またループで先頭に戻って状態に依ってディスパッチするという手法だったそうです。Common Lispの場合はcaseが全て(cond ((eql ..) ....) ...)に展開されて遅い1のでwhileとcaseじゃなくてtagbodyとgotoで実装したそうです。\nこの手法は一般にDirect(Navive) ThreadingだとかThreaded Codeだとか呼ばれています。主にバイトコードインタプリタを実装する時にバイトコードに依るディスパッチの部分で使われるようです。Rubyの解説が丁寧だったようなので参考資料として置いておきます。\nRubyist Magazine - YARV Maniacs 【第 3 回】 命令ディスパッチの高速化\n会場からはアーキテクチャ依存の最適化はしないのかとの質問がありました。SBCLにはインラインアセンブラであるVOPなるものが存在するのでSIMD命令使えば、とかいう怖い話ですね。\nsymbol tree diff LT2件目はchikuさんより「symbol tree diff」。chikuさんが以前から取り組んでいるプログラムのdiffを構文レベルでとる話の進捗。\n  Symbol tree-diff  from samugari \n動画\ndiff自体はとれるようになったようですが見せ方に問題があり、見易い形式を模索中のようです。会場に見易い形式は何か投げ掛けましたが良い案を見付けるのは難しいようです。\nSemantic S式 私から「Semantic S式」。括弧が多い方が嬉しいこともあるよねーというゆるい話。 Semantic S式 | κeenのHappy Hacκing Blog\n動画\n会場からは半分同意、半分ツッコみたいとの反応が。plistをリテラルからgetfするやついないだろ、とか。\n懇親会 私の発表で21時あたりだったのでそのまま解散して懇親会。隣にLand of Lispを読んでLispに興味持ってLispの授業をとってる方がいたのでどの本が入門に良いかなど。\nVOPの話の続きもしました。どうしても資料がないのがネックだよねー、と。私の知っているのは\nHow to Define New Intrinsics in SBCL - Paul Khuong mostly on Lisp\nや\nHacking SSE Intrinsics in SBCL (part 1) - Paul Khuong mostly on Lisp\nかな。日本語のやってみた系だとg1さんの\n#:g1: SBCLでVOPを使ってみよう\nあたり。\nその他 テンプレートエンジンを作ってるって以前深町さんに話してたら「まだ出来ないんですか？」とさんざん煽られました。はい。頑張ります。\n condは先頭から順番に比較する仕様です。caseはcondに展開されることが仕様で定められていた筈。 [return]  ","categories":["Lisp","Common Lisp","Lisp Meet Up"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/lisp-meet-up"],"date":"2014-11-28","title":"lisp meet up #22でLTしてきた","url":"https://KeenS.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita/"},
  {"body":"# Semantic S式 --- 2014-11-27 κeen(@blackenedgold) # About Me ---------- ![κeenのアイコン](/images/icon.png) + κeen + 東大数学科の4年生 + ソーシャルアカウントは上のアイコン達から。 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます # Semantic Web とは # [Semantic Web](http://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A6%E3%82%A7%E3%83%96) ---------------- * W3C のティム・バーナーズ＝リーが提唱 * 文章の見た目を記述するんじゃなくて構造を記述しよう * そうすると機械がクローリングするの楽になるよね # Semantic S式とは # Semantic S式 -------------- * Shibuya.lispのκeenが提唱 (昨日思い付いた) * S式の見た目じゃなくて構造で括弧をつけよう * そうするとコーディングが楽になるよね # 良いところ ------------ 1. 意味が分かり易い 2. パースし易い 3. 編集が楽になる 4. 壊れにくい # 1. 意味が分かり易い # 1. 意味が分かり易い -------------------- ## 例1 * Clojure ```clojure (let [a 1 b 2] ...) ``` * Common Lisp ```lisp (let ((a 1) (b 2)) ....) ``` どっちが分かり易い？ # 1. 意味が分かり易い -------------------- ## 例1 （日本語にしてみる（イメージ）） * Clojure aを1bを2とする * Common Lisp `a`1`b`2 とする # 1. 意味が分かり易い -------------------- ## 例2 何をしてる？ ```lisp (destructuring-bind (a b) (some-function) ...) ``` # 1. 意味が分かり易い -------------------- ## 例2 何をしてる？ ```lisp (destructuring-bind ((a b) (some-function)) ...) ``` # 1. 意味が分かり易い -------------------- ## 例3 これの返り値は？ ```lisp (getf '(:hoge :foo :huga :baz :piyo :pon :chun) :pon) ``` # 1. 意味が分かり易い -------------------- ## 例3 これの返り値は？ ```lisp (assoc :pon '((:hoge :foo) (:huga :baz) (:piyo :pon) (:chun))) ``` # 2. パースし易い # 2. パースし易い ---------------- ## 例 * Clojure ```clojure (let [a 1 b 2] ...) ``` * Common Lisp ```lisp (let ((a 1) (b 2)) ....) ``` どっちが実装し易い？ # 2. パースし易い ---------------- * Common Lispの方は意味で分割してある * 括弧は無くてもパースは出来る * 機械にパースし易い≒人間にパースし易い # 3. 編集が楽になる # 3. 編集が楽になる ------------------ ## 前提 * エディタに文/式/トークン(Lispの場合は全てS式)単位の編集機能がある + S式単位でカーソル移動 + S式単位の削除/カット + S式単位のスワップ + etc.... # 3. 編集が楽になる ------------------ ## 例（偶によくある） この`c`の束縛を上のletに持っていきたいときどうする？ ```lisp (let ((a 1) (b 2)) .... (let ((c 3) (d 4)) ...)) ``` # 3. 編集が楽になる ------------------ ## 例（偶によくある） * 意味で括弧をつけていれば1カット移動1ペースト * Clojure方式だと2カット移動1ペースト * `c`だけじゃなくて`d`も、と考えると… # 4. 壊れにくい # 4. 壊れにくい --------------- ## 例 ageの計算が壊れているとする ```lisp (:name \"κeen\" :age (year-of-time-interval (date- (today) (date 1992 5 17))) :place \"Shibuya\") ``` # 4. 壊れにくい --------------- ## 例 コメントアウトしてみる（壊れた） ```lisp (:name \"κeen\" :age ;(year-of-time-interval (date- (today) (date 1992 5 17))) :place \"Shibuya\") ``` # 4. 壊れにくい --------------- ## 例 ageの計算が壊れているとする ```lisp ((:name \"κeen\") (:age (year-of-time-interval (date- (today) (date 1992 5 17)))) (:place \"Shibuya\")) ``` # 4. 壊れにくい --------------- ## 例 (エディタサポートあり) コメントアウトしてみる（壊れない） ```lisp ((:name \"κeen\") (:age ;(year-of-time-interval (date- (today) (date 1992 5 17))) ) (:place \"Shibuya\")) ``` # ここまでのまとめ ----------------- * 構造が文脈に依存していると + 人間に分りづらい + プログラムに分りづらい + エディタに分りづらい + 壊れやすい # Q. When Semantic? ------------------------------ ## A. 言語を設計するとき * つまりマクロを書くとき # Q. When Semantic? ------------------------------ ## A. 言語を設計するとき * マクロを書くときそれなりのDSLを設計する * プログラム上は必須ではない括弧もあった方が良いときもある # まとめ -------- * 括弧が少ない方が書き易いとは限らない + 「書く」だけなら速くてもwrite onlyになってしまうかも* プログラムの意味を考えながら括弧つけよう + Lisperはどうせ括弧は見えない以上 何か質問あればどうぞ   ","categories":["Lisp","Lisp Meet Up","デザインスタイル","Lisp Meet Up"],"category_urls":["/categories/lisp","/categories/lisp-meet-up","/categories/%e3%83%87%e3%82%b6%e3%82%a4%e3%83%b3%e3%82%b9%e3%82%bf%e3%82%a4%e3%83%ab","/categories/lisp-meet-up"],"date":"2014-11-27","title":"Semantic S式","url":"https://KeenS.github.io/slide/semantic-sshi/"},
  {"body":"κeenです。@nemunemu3desuさん（ねむさん）、@cocodripsさん（くーむさん）とチーム「(ρ_-)/超銀杏バスターズ\u0026#92;(･ω･ o)」でISUCON4で学生賞とってきた。二連覇わーい。\n※2014-11-09 16:50 ちょっと加筆修正しました\nやったこと\n本番前 なにもしなかった。しかも前日に体調崩して簡単な打ち合わせも欠席という状態。結局前回と同じく私インフラ、ねむさんアプリ、くーむさんDB。\n当日 朝 起床成功。\n競技開始〜昼御飯 くーむさんにssh、ねむさんにgitレポジトリの設定してもらって私はcapistranoの設定。capistrano触るのは去年のisucon以来でうんうん言いながらやってた。\nrack-line-profをしかけてもらってNginXでjsとcss返してベンチ走らせるもなんか動かないしでつまる。運営からベンチに障害があるとのアナウンスがきてローカルで動かすもエラーが出るわプロファイル結果出ないわ。\nforemanが死んでなかったっぽいことが判明したりとちょっと前進するもエラーは残る。\nしばらくにらめっこしてもエラーとれないのでとりあえず昼御飯食べながらプロファイル結果見て作戦会議。ここ遅いよって言われて見てみたらrubyからmp4返してたので第一段はそこをWebDAVサーバーに置くことに。因みにエラーの原因は後にline-profのバグだったことが判明。\n1号サーバーだけCPUが少ないので3号サーバでリクエスト受けて動画のPOSTは1号サーバーで動いてるWebDAVサーバーにスルーパス、GETはリダイレクトな感じにしよう。私がWedDAVサーバー、ねむさんがアプリ、くーむさんは引き続きアプリ読んで次のボトルネック解析。\n因みになんで1号サーバーをWebDAVにしたかというと次の手で2号サーバーもフロントにしたかったから。\n昼御飯後〜15、16時くらい？ 静的ファイルならlighttpdかなと思ってWebDAV設定するもyumで入れたやつはWebDAV用にビルドされてなかった。結局NginXにした。\nlighttpd、一瞬で消え去ったと思ってる方も居るかと思いますがRaspberry Piでも元気に動いてくれる良い子なんですよ！！\nねむさんはWebDAV叩くの初めてみたいで苦戦してたり私の設定ミスもあったりでようやく動く。これでスコアめっちゃ上がる。\n4位浮上うぇーーーーーい #isucon\n\u0026mdash; κeen (@blackenedgold) 2014, 11月 8 \n社会人相手に一時的に4位を取ったのは嬉しかった。\nどうやらネットワーク帯域を全部埋めたよう。\n16時以降 くーむさんの分析でログをファイルに書き出してる部分がめっちゃ無駄\u0026amp;フロントの2台化を邪魔するのでどうにかしようとの話になる。最初jsonをシリアライズしてるからMongoDB、いや、やっぱ安心と信頼のMySQL、いや、やっぱ既に動いてるRedisと言って結局MySQLに落ち着く。2台からアクセスが来るので1号サーバに置く。\nくーむさんがねむさんにデータベーススキーマの設計とか説明しつつねむさんが実装、私がMySQLのリモートログインとかその他DB全般の設定をする。よく考えたらねむさんPythonアイドルの女子大生とペアプロしてるぞ。\nしかし結果間に合わず。うーむ。\n最後 ベンチマーク毎にWebDAVにファイルが溜っていくのでどうにかしよう。今までは手動削除してたけど本番計測下手したらこけるんじゃねって不安。アプリの初期化API内でWebDAVサーパーのファイルを全部削除しようとするもなんか拒否られる。設定ミスってたかなあ。\n結局CGI(シェル)スクリプトで叩くという荒技。レスポンスが500なのは御愛嬌。しかもNginXがfastCGIしかサポートしてないのでNginXからApacheにフォワードしてからApacheがCGI起動という曲芸のような仕様。MySQLが間に合えばこのシェルスクリプトにDBの初期化も入れるつもりだった。lighttpdならこんなことにはならなかったのに…\nUnicornのワーカー数とかベンチマークのワークロード数とかいじってみるも測定誤差がめっちゃ大きくて参考にならず、4位に浮上したときのパラメータで挑む。\n結果 タイトルにあるように学生賞。全体は12位で一応真ん中よりは上。賞金GET!無料 VPS GET!!しかもVPSはTECHORUS社長の一声で半年から1年になりました。TECHORUS++++\n懇親会で@tagomorisさんに学生チームで帯域を埋めるのは大したもんと褒められた。ヤッター。\n反省 個人的には自由奔放すぎた。もうちょっと協調的だったら、とかREADMEくらい書いたら、とかあった。あと私はインフラ担当だったからどのミドルウェアがどのログ管理してて、っていうのを把握してたけど他の二人は把握出来てないことを把握してなかった。毎回rubyのログはどこにあるんですかとか聞かれてた。Capistranoとか結局私しか使えてなかった。\nチーム全体では最初ごたごたし過ぎた所為で最後MySQL入れるのが間に合わなかったのと静的ファイルをキャッシュしてなかったねっていうの。静的ファイルをキャッシュしようとしたらまぐれでCache-Control設定したかもしれない（実際2位のチームがそうらしい）。sinatraをproductionモードするのを忘れないって競技中にHangoutに書いたのに忘れてた。Unixドメインソケットも使ってなかった。最後焦りすぎたね。\n最後に 私は今年で学生枠で出るのは最後でした。来年からは猛者犇めく一般枠での参加になります。予選突破が大きな目標ですね。出来れば次回はCommon Lispで出たい。\n私のインフラ周りの知識や経験はほぼISUCONの経験を通して得られたもので、一年ちょっと前のSQLも見たことない自分に比べるとずいぶん成長したなと思います。LINE、COOKPAD、TECHORUSの方々、運営お疲れ様でした。本当にありがとう御座います。来年も宜しくお願いします。\n","categories":["ISUCON"],"category_urls":["/categories/isucon"],"date":"2014-11-09","title":"#isucon で学生賞二連覇してきた","url":"https://KeenS.github.io/blog/2014/11/09/isucondexue-sheng-shang-er-lian-ba-sitekita/"},
  {"body":"# claspを少し触ってみた ---------------------- Lisp Meet Up presented by Shibuya.lisp #21 2014-10-29 κeen(@blackenedgold) # About Me --------- ![κeenのアイコン](/images/icon.png) + κeen + 東大数学科の4年生 + ソーシャルアカウントは上のアイコン達から。 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます # clasp ------- * Github: [drmeister/clasp](https://github.com/drmeister/clasp) * 2014-09-18に0.1リリース(現在0.11プレビューが出ている) * 今は0.11プレビューが出ている * ANSI Common Lisp準拠を目指す(現在80 ~90%) * ECLからのフォーク * LLVMベースのJIT([MCJIT](http://llvm.org/docs/MCJITDesignAndImplementation.html))搭載 * C++とLispで書かれている * C++との連携を意識 Note: C++との連携の部分を強調。今回は0.11プレビューでの話 # メモリ管理 ------------------ * Memory Pool Systemと Boehm GCから選べる * ビルドするときにどっちかを選ぶ # メモリ管理 ------------------ ## [Boehm GC](http://www.hboehm.info/gc/) * Mark \u0026amp; Sweepのライブラリ * 枯れた有名なライブラリ * Lisp有名どころではGaucheが使う * RedHat系だとこれを使ってないとrpmリジェクトされやすいらしい(?) Note: 他にはMozilla, W3M, GNU GCJ, GNU Obj-Cなどなど # メモリ管理 ------------------ ## [Memory Pool System](http://www.ravenbrook.com/project/mps/) * 複数のGCアルゴリズムを組み合わせて使えるらしい * since 1994 * あまり分からないです\u0026gt;\u0026lt; # 依存ライブラリ ---------------------- * LLVM **3.6** * LLVM/clang **3.5** compiler * Boost build v2 * boost libraries ver 1.55 * Boehm 7.2 * gmp-6.0.0 * expat-2.0.1 * zlib-1.2.8 * readline-6.2 無理 # externals-clasp -------------------------- * Github: [drmeister/externals-clasp](https://github.com/drmeister/externals-clasp) * 依存ライブラリを揃えるのが難しいとの声から作られた * 依存ライブラリを全てビルド＼LLVMをビルド／ ＼Boostをビルド／ ビルド時間はお察しです # 本体のビルド ------------------ Twitter実況をどうぞ↓↓ # 本体のビルド ------------------ clangがメモリ6GB以上食い続けてて怖い。何やってんの。\n\u0026mdash; κeen (@blackenedgold) 2014, 10月 26 # 本体のビルド ------------------ clangの起動時間1時間超えてますよ…\n\u0026mdash; κeen (@blackenedgold) 2014, 10月 26 # 本体のビルド ------------------ HDDプチプチ言ってるし今にも壊れそう\n\u0026mdash; κeen (@blackenedgold) 2014, 10月 26 # 本体のビルド ------------------ @nobkz claspのコンパイル中です。\u0026#10;clangなのにIOネックという謎の状態です。\n\u0026mdash; κeen (@blackenedgold) 2014, 10月 26 # 本体のビルド ------------------ clangの消費メモリ7GB超えた\n\u0026mdash; κeen (@blackenedgold) 2014, 10月 26 ビルドは自己責任で # 使ってみる ------------ ## 起動オプション ``` /usr/local/clasp/bin/clasp_mps_o --help clasp options -I/--ignore-image - Don't load the boot image/start with init.lsp -i/--image file - Use the file as the boot image -N/--non-interactive - Suppress all repls -v/--version - Print version -s/--verbose - Print more info while booting -f/--feature feature - Add the feature to *features* -e/--eval {form} - Evaluate a form -l/--load {file} - LOAD the file -r/--norc - Don't load the ~/.clasprc file -n/--noinit - Don't load the init.lsp (very minimal environment) -s/--seed # - Seed the random number generator -- {ARGS}* - Trailing are added to core:*command-line-arguments* ``` # 使ってみる ------------ ## ASDF * 動かない + ASDFの処理系依存の部分(`#+`)の問題 + ECLと見做されるけどECLのコードは動かない # 使ってみる ------------ ## cl-ppcre * [手動ロードスクリプト](https://gist.github.com/KeenS/4e25cb6e424ebe4e7a4a) * 動かない + `schar`がない + ANSI Common Lispにあるのに… # 使ってみる ------------ ## C++との連携 * ドキュメントがない * サンプルコードもない * 遂行不能 # 使ってみる ------------ ## LLVMの呼び出し * [clasp/src/llvmo/demo.lisp](https://github.com/drmeister/clasp/blob/master/src/llvmo/demo.lsp) * 動かない # 使ってみる ------------ .graph{ background:#aaa; border-radius:5px; white-space: nowrap; text-align: left; } td { white-space: nowrap; }  処理系 | `(time (fib 29))` --------------------|----------------------------------------------------------------- clasp-0.1(boehm) | 26.43s clasp-0.1(mps) | 17.28s clasp-0.11(boehm) | 21.32s clasp-0.11(mps) | 18.79s ECL-13.5.1 | 1.603s ECL-13.5.1(compile) | 0.192s ABCL-1.3.1 | 3.292s ABCL-1.3.1(compile) | 0.241s # 使ってみる ------------ 処理系 | `(time (fib 29))` --------------------|----------------------------------------------------------------- CLISP-2.49 | 3.847s CLISP-2.49(compile) | 0.7146s ccl-1.10 | 0.04033s sbcl-1.2.5 | 0.06469s alisp-9.0 | 23.09s alisp-9.0(compile) | 0.06194s LLVM/JITなのになぜ遅い？ # LLVM/JITで遅い？ ------------------------- * LLVMって速いんじゃ？ * JIT搭載した○○が速いって聞いたよ + JVM + lua-jit + Rubinius + pypy # 言葉の罠: LLVM -------------------- * 遅いコードはどんなに頑張っても遅い * ECLのバックエンドにClang(=LLVM)を使ってもSBCLに勝てないのと同じ # 言葉の罠: JIT搭載 -------------------- * JIT(実行時コンパイル)の意味は広い * 実行時にネイティブコードを吐けばJITと言える * claspは実行直前にコンパイルするだけ * 多くの速いJIT処理系はTracing JITを使う + またの名を適応的コンパイル + 実行時の情報に基いて実行中に最適化する + `(declare ...)` を自動生成してる的な # Tracing JITへの道 -------------------- * LLVMのJITは実行直前にコンパイルするだけ + Tracing JITのバックエンドには使える * 実行時最適化には最適化用のコードが必要 + Common Lispでは`(declare ...)`用のコードを使い回せる * 案外近い # 結論 ------ * 遅い * 時期尚早 * 今後機能や速度改善があれば使えるようになるかも 以上 何か質問あればどうぞ   ","categories":["Lisp","Common Lisp","clasp","Lisp Meet Up"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/clasp","/categories/lisp-meet-up"],"date":"2014-10-28","title":"claspを少し触ってみた","url":"https://KeenS.github.io/slide/clasp/"},
  {"body":"#関数型なんたら でGCの話を聴いて、SML#のGCの論文を読んで色々感じたのでエントリー。\nSnapshot GC まず、湯浅先生のSnapshot GC (解説)。並列、並行、インクリメンタルにGCが出来る。恐らく一番性能が出るとのこと。解説ではmark \u0026amp; sweepだけど私が聴いたのはCopyingだった。\n勿論並行にするにはライトバリアが必要なんだけどその辺にまつわる話。並行じゃなくても世代別GCでもライトバリアが必要になるからその辺も頭に入れて聴いてほしい。Copyingはアロケーションが鬼のように速いのが特徴。mallocの感覚でメモリ確保が重いとか思ってると感覚が狂う。なので新たなオブジェクトを作るコストは非常に低い。そこにオブジェクトの変更にはライトバリアが付くとなると、大きくないオブジェクトの場合 オブジェクトを変更するより新たに作った方がコストが低くなる 。一応言っておくと、Copying GCの負荷は 生きている オブジェクトの数に比例するのでゴミオブジェクトを大量に作ったところでそんなにGCの負荷は高くならない。勿論、GCの頻度は上がってしまうが。それも世代別GCなら軽いGCが走るだけなので回数が増えてもそんなに負荷にはならない。\nつまるところ 関数型スタイルでプログラムを書いた方がパフォーマンスが上がる ことがある。素晴しい。逆にこのような理由から関数型言語ではCopying GCを使うことが多い。\nただ、全ての場合で速くなる訳ではない。Copying GCはオブジェクトを移動するため、オブジェクトのアドレスが変わる。普通の参照ならGCのアルゴリズムが書き換えてくれるのだがそうはいかないのがハッシュ。ハッシュは多くの場合オブジェクトのアドレスをハッシュ値に使うため、GCが走ったらハッシュ値の再計算が必要になる。しかもハッシュの操作には破壊的なものが多いため、ライトバリアの影響も受ける。その場合、 ハッシュマップよりもツリーマップの方がパフォーマンスが出る ことがある。勿論、アルゴリズムのオーダが違うので要素数がケタ違いに大きくなるとハッシュに軍配が上がるが、通常そこまで要素を入れない。ようやく関数型言語でツリーマップが使われる理由が分かった。\nBitmap GC 関数型言語と相性の良いCopying GCだけど問題もある。Stop the Worldの話は世代別化やらそれこそSnopsht GCでどうにでもなるからそれはいい。Copying GCに本質的な問題。オブジェクトのアドレスの問題。GCが走ると現在のポインタが無効になる。処理系内部だけならまだ開発者が頑張れば良いんだけどC拡張を許すとそうもいかない。普通のポインタの問題だけじゃなくて構造体にポインタがあったら、とかそもそも外部ライブラリの内部のポインタをとか考えてるとどこかで割り切る必要がある。\nそのためユーザにC拡張を気持ち良く使わせようと思うとCopying GCではつらい。Mark \u0026amp; Sweepが現実的な選択肢になる。が、そうすると今度はパフォーマンスに問題が出る。特にフラグメント化の問題は関数型スタイルが天敵である。じゃあ、Mark \u0026amp; Sweepの性能を改善しようというのがBitmap GC。\n概要はMark \u0026amp; Sweepがオブジェクトにマークを付けるのに対してオブジェクトとマークを別にしてマークだけbit列で管理すると局所性が上がって良いよねというもの。詳しくは最初に上げた論文を参照して欲しいが一応解説。\n局所性が上がるとはいっても単にキャッシュが効くとかではない。ビット列になることでCPU命令で操作出来るようになって$O(n)$が$O(n/32)$になったりする。そして何より、Mark \u0026amp; SweepじゃなくてSweep \u0026amp; Markになる。Sweepはビット列を0で埋める論理削除。ほぼ一瞬。なので実質Markのコストしかかからない。\n構成 勿論、ただのbit列でオブジェクトの生死を管理するにはヒープをサイズ毎に用意する必要がある。8bitのオブジェクト用のサブヒープ、16bitのオブジェクト用のサブヒープ…という風に。そしてそれぞれのヒープ毎にビットマップをつける。ただそれだと無限に大きいサイズのヒープが必要になるのでどこかで切ってそれ以降は普通のMark \u0026amp; Sweepで管理するらしい。因みにSML#では4096bitが上限。32bit専用アーキテクチャなので64bitだと少し違うのかもしれない。以下、32bitアーキテクチャを仮定する。64bitでも適切に読み替えれば問題ない。\nサブヒープはセグメント列とアロケーションポインタからなる。アロケーションポインタは次にアロケートすべき場所を差す(セグメント、ブロック、bitmap tree(後述)の情報)。\nセグメントはオブジェクト数、ブロック列、ビットマップ、作業領域を持つ。ブロックというのが実際のオブジェクトが入る場所。8bitのサブヒープなら8bitのオブジェクトが入る。1セグメントに含まれるブロックの数は事前に決められている。要はコンパイル時なり起動時なりのパラメータになる。勿論、サブヒープ毎にブロック数をいじることになる。\nビットマップはただのビット列ではない。ただのintの列にするといくらCPU命令を使っても次の空いている場所を捜すのに$O(n/32)$かかってしまう。そこでbitmap treeで管理する。bitmap treeは親ビット列のi番目のビットが1のとき、i番目の子ビット列がfullである。ここでfullとは末端なら対応するブロックが使われている、それ以外なら子ビット列が全て1であるということである。これで次の空いているブロックを$Ω(log_{32} n)$で見付けることが出来る。同じワード内にあって適切なCPU命令があれば$O(1)$で済む。\nアロケーションは先に出てきたアロケーションポインタの先が使われているか判断して、空いてれば先にデータを書き込んでアロケーションポインタをインクリメントするこのとき、特にbitmap treeは変更しない。空いてなければ空きブロックを捜す。空いてなければ次のセグメントに移って繰り返す同じ操作を行なう。最後のセグメントならセグメントプールに新しいセグメントを要求する。それももらえなければGCが走る。この辺はホットスポットらしいので色々テクニックが詰まっている。詳しくは論文を参照して欲しい。\nGCは先に述べたように全てのサブヒープの全てのセグメントのbitmap treeを0で埋めることから始まる。そしてこれでSweep完了。\nMarkはまずrootノードについて、対応するbitmap treeを1にして、セグメントのオブジェクト数をインクリメントし、作業領域のトレーススタックに積む。あとはトレーススタックの中身の参照先をを順に同様に処理していけば良い。既にMarkされているオブジェクトは単に無視する。空になったセグメントはセグメントプールに返して、fullなセグメント(オブジェクト数=1セグメント毎のブロック数 なセグメント)はセグメント列の先頭に持ってくればアロケート時に無駄に探索されることはない。そしてアロケーションポインタを最初の空きブロックを差すようにすれば良い。\nオブジェクトをサイズ毎に管理することでSweepを論理削除で済ませているところが良い。\n世代別化 論文には世代別化の話もある。ライトバリアが必要なのは一緒だけど世代の管理が面白かった。安直には世代毎にサブヒープを分ける方法が思い付くが、それだとオブジェクトの移動が発生する。論文では世代毎にbitmap treeを持っている。ある世代のbitmap treeはその世代とそれより古い世代全ての生きているオブジェクトのbitmapになっている。\nある世代をsweepしたければ一つ古い世代のbitmap treeで上書きすれば良い。\nある世代のMarkは生存回数をインクリメントし、その世代のbitmap treeにMarkする。生存回数が閾値を越えたら上の世代にもMarkする。\n全て完了したら若い世代達にも反映する(どう反映するかは論文には載ってない。差分をとって…とかかな？)。面白いのはある世代狙い撃ちでGC走らせられる点。あるいはいくつかの世代でも可能だろう。多くのアルゴリズムはある世代\u0026rdquo;以下\u0026rdquo;な気がする。これによって、マイナーGCでダメならミドルGCして、それでもダメならメジャーGCしてってなってたのが若年、中年、高年で別々に可能になる。まあ、ライトバリアの数がものすごいことになるからやらないだろうけど。なんでかっていうと若い世代から古い世代への参照もトレースする必要が出てくるから。論文に詳しく載ってないのはそんなに多くの世代を作っても現実的でないからだろう。勿論、ある世代以下を全てsweepも出来るので普通はそうする筈。\nリメンバーセットとライトバリア さて、さっきからライトバリアの話は出てたのに具体的になんなのかが出てこなかった。\n世代別GCでは、マイナーGCが動くときに旧世代から新世代への参照があればその新世代のオブジェクトは生きているのでマークしなければならない。その「参照されている」ことを覚えておくのがリメンバーセット。GCされた後どうなるかは資料が見付からなかったけど旧世代に移ったものやGCされたものを取り除くんじゃないかな。\nライトバリアは調べたところ、多義的である。オブジェクトの参照を変更するときにごにょごにょするもの全般をライトバリアと呼んでいるようだ。Snapshot GC(並行GC)の場合はマーク中に変更された参照の先のオブジェクトもマークしていくことのようだし、RGenGC(インクリメンタル GC)はマーク中に変更された参照の元オブジェクトをグレーにすることのようだし、世代別GCではさらに色々意味がある。\n世代別GCでのライトバリアは、全ての参照を変更する操作にフックして動く。そしてリメンバーセットを更新する。そこまでは皆共通している。そこからは、\n 旧世代オブジェクトから新たに参照された新世代オブジェクトをリメンバーセットに加える 変更されたオブジェクトをリメンバーセットに加える 変更されたオブジェクトを、旧世代オブジェクトならリメンバーセットに加える  などのバリエーションがある。それ以外にもありそう。尚、どれも正確ではない。つまり本来なら死んでいるオブジェクトも生き残る可能性がある。\n正確にやろうと思えばリメンバー\u0026rdquo;マップ\u0026rdquo;を用意し、[新世代オブジェクト]-\u0026gt;[旧世代からの参照数]を保持し、参照カウントを行なえばいけると思う。\nそこまでやらないのは性能に問題があるからかな。あとそもそも世代別GC自体正確にはオブジェクトを回収しないから正確にやってもあまり意味がないのもある。\nSticky Mark世代別化 Sticky Mark世代別GCというのは世代別GCを世代2つ、生存回数の閾値1とするときの簡単な実装方法。本当に簡単で、前回のMarkを残しておけば良い。それが旧世代の目印になる。あとはライトバリアとリメンバーセットを用意するだけ。元々Markのときに既にMarkされているオブジェクトはスルーされるのでアルゴリズムはほぼ変更が要らない。普通のMark \u0026amp; Sweepでも出来るし、Bitmap GCでもアロケーションのときにbitmap treeをいじってないのでbitmap treeを0にする処理をしなければ良い。\nさらに、リメンバーセットに関しても簡単になる。全てのオブジェクトが旧世代になるのだからリメンバーセットはクリアするだけで良い。あるいはGC毎に消えてしまうデータに格納してしまっても良い。SML#ではトレーススタックに積むことでリメンバーセットとしているようだった。何も考えなくてもGCのときにルートノードとして扱われる。重複判定に関しては読み解けなかった。\n以下、書いてあるところの引用。最初の this factというのはリメンバーセットについて簡単になるということ。Tworkというのが作業領域。\n Taking advantage of this fact, we allocate a re- membered set in the collector’s trace stack. As mentioned before, our trace stack is implemented as a linked list using Twork work areas. This is done by assigning a unique pointer slot in Twork to each object. This implementation allows us to determine whether a given object is already in the list or not by checking whether the pointer is non-null. This automatically eliminates duplication in the remembered set. A write barrier can then be incorporated in the generational collector as follows. A write barrier code takes a young object that is to be referred from the old generation due to mutation, and marks it and pushes it to the trace stack. Minor collector simply traces objects using the trace stack whose initial contents is the remembered set\n 誰か分かる人教えて下さい。\n複数mutater対応 要はアプリケーションでスレッドを使ったときの話。1スレッドにつき1セグメント割り当てて新たなセグメントを確保するときだけロックとればアロケーション速いよねって言ってる。GCはStop the Worldしないようにするとか言ってるけど出来るのかな。\nパフォーマンス Bitmap GC、sticky bit世代別Bitmap GC、シンプルなCopying GC、2世代、5世代の世代別Copying GCでの比較が載ってる。Copying GCは2世代が最もパフォーマンスが良く、世代別Bitmap GCもそんなに負けてない。少くともシンプルなCopying GCには勝ってる。アロケーションは及びもつかないものの、世代別Bitmap GCはGCのStop the Worldは圧倒的に短いみたい。\npicrinの話 picrinのGCは超シンプルなMark \u0026amp; Sweep。んで、picrinのボトルネック。どうにかしたい。先述の理由からMark \u0026amp; Sweepなのは維持なんだけどどう拡張しようねという話。\nライトバリアさえ実装してしまえばSticky Markで簡単に世代別化出来る。もうちょっと言うとライトバリアだけのデバッグが出来る。そしてまともな世代別化につながる。でもライトバリア-\u0026gt;Bitmap化だとライトバリアも書き換える必要が出てきてあまり宜しくない。\nBitmap化すれば速くなるっぽい。が、メモリ管理を大幅に書き換える必要がある。特にサイズ別に管理するところ。でもそこからさらにSticky Markとかでさらに拡張可能。\nうーん。個人的にはBitmap化してみたいんだけど完全に独自メモリ管理になっちゃうからなー。\n","categories":["GC"],"category_urls":["/categories/gc"],"date":"2014-10-26","title":"GCの話","url":"https://KeenS.github.io/blog/2014/10/26/gcfalsehua/"},
  {"body":"κeenです。昨日函数型なんたらの集いに参加してきたので報告/感想です。\n会場提供はドワンゴということでトークはニコ生に流された模様。ちらっと覗いてみたらLinuxでも見れましたね。いつのまにかFlashのバグ直ってたんですね。 とはいえ私自身のトーク中のコメントが見れなかったのであまり意味はないのですが…\nプレミアム会員は放送後7日は生放送の内容を見れるそうですね。見れる方々はコチラからどうぞ。次回からはタイムシフト予約しておこう。\n話した内容 C6H6+HNO3というタイトルで、picrinのbenzとnitrosについて。本当はnitrosの依存関係解決器sulfuricを完成させてそれについて話し、nitroを書こう!って言う予定だったんですが着手が遅れて完成しないまま発表になりました。\n普段関数型言語のヒトは型やらモナドで殴ってる印象があったのでマクロで殴ろうと思ったのですがマクロの話のところで焦ってしまって話が飛んでしまい、殴れずに終わりました。\nガチの組み込み屋さんから組み込み機器で動作検証したのかとの質問がありましたがそもそも持ってないです。そろそろ1.0が出ると思うのでそのあたりでやります。\nGCがconservativeかとの質問に対して「はい」と答えてしまいましたが間違いでした。 conservativeなのはcall/ccでした。GCはexactですね。ドキュメントに載ってます。\nwasabizの名前に反応した人が多かったようですね。やっぱ有名人なのかぁ。\n興味深かった話 エンジニアとモナド またモナドで殴る話かと思ったら全然違いました。トップダウンで設計するときにそれぞれを小さなDSLに分割してそれらをモナドで実装し、モナド変換子で組み合わせると良いよねとのこと。タスクアサインもモナド単位になるし分かり易い。スピードのために実際には単相化すると良いとか現実的な話をしてて非常に良かったです。\nLispで考えるとこうはいかないなと思います。トップダウンで設計するのが他の言語以上に向いてない気がします。というか、ボトムアップに向きすぎてる。小っさく始めて抽象が欲しければマクロを書いて…って。オブジェクト指向で作るにしてもオブジェクトとメソッドが分離してるのでボトムアップと相性が良い。この辺はポールグレアムの「ハッカーと画家」に詳しいです。\nshapelessの紹介 興味を持ったのはshaplessそのものではなくてヘテロなリストやヘテロなハッシュに型をつける話。{ 1 =\u0026gt; \u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot; =\u0026gt; 2}に型がつくのは面白すぎます。「高度に多相化された静的型は動的型と区別がつかなくなる」っぽかったです。\nパターンマッチいろいろ 議論を呼んだ発表。パターンマッチを拡張する話。例えば年月日に対してYMD(y, 12 25)でクリスマスならそのときの年を取り出せるだとかさらにアンドを使えばHMSも一緒にマッチ出来るだとか。 そこからEgisonに話が飛んでEgisonの例のようにポーカーの役をScalaでパターンマッチする例の紹介。\n議論を呼んだというのはパターンマッチにガードが吸収されてる件ですね。データ型のコンストラクタとエクストラクタが一対一対応してこそパターンマッチは真価を発揮する派vsパターンマッチの表現力が高ければ高い方が良い派の対立ですね。さらに前者は型の表現力が足りてないのなら型をもっと複雑にすべき派とガードを付けて網羅性の証明をすれば良い派に分かれます。私はパターンマッチには表現力があればあるほど良いよね派。\nこれはそもそもパターンに対する立場の違いがある気がするんですよね。私はパターンマッチは同じデータに対する条件判定のシンタックスシュガーとして捉えています。マッチと束縛を一緒に行なうのは便利なのとパフォーマンスのため。ガードが必要なのはパターンの表現力が足りないため。だからパターンがリッチならリッチな方が良い。そもそもLispでは網羅性のチェックは期待出来ませんので。そもそもの話動的言語はコンパイル時の検査をあきらめてその代わり表現力を得ようという思想ですからね。\nパターンが複雑になるとメモリが爆発するとの指摘がありましたがそれに直面した人がいるらしく、パターンによる分岐の枝を実行時に伸ばしていくようなパターンマッチライブラリも存在します。（Lispは実行時にもマクロが動いていて、実行時にコードを生成することも可能なのです。）\n懇親会その他 名古屋の型々方々と色々喋れました。偶々でこれきさん、みずぴーさんと同じテーブルに座り、昼御飯も一緒に。普段休日出勤してる印象が強く、名古屋に行かないと会えないと思っていたブレイスさんといよさんも一緒でした。でこれき先生はやっぱり大先生だった。\nよんたさんにSML#のコードリーディング会開いて下さいって言ったら良いよって言ってもらいました。そろそろ64bit版も出るそうなのでリリース記念コードリーディング会\u0026amp;芋煮会やろうって話になりました。\nOCamlのユニコードライブラリを作ってる方とも話しました。内部でropeで持ってるらしく、その話を聞きました。ropeのユニコード化はどうやら普通に文字列をUTF-8で保持し、ropeに文字列長のフィールドを保たせるだけで良いよう。ただ、picrinはCとの連携のためちょくちょくCの文字列に変換してまた新たにropeを作って、とするので若干勝手というかボトルネックが違いそう。\nSchemeのネイティブコンパイラを作ってる方とも話しました。Schemeの実装について喋ったり、GCについて喋ったり。GCについては興味深いことを聴いたのでもう1本エントリー書きます。あとはプロセス代数とかモデル検査とか。\nまとめ 楽しかった。どうしてもLispは関数型とはあまり言われない（し、私も関数型言語とは思ってない）のでLisperが少なかったのですが私自身はMLも好きなので楽しめました。GCとTaPLとHaskellとScalaとEgisonに対するモチベーションが上がりました。\n最後に開催して下さった主催の方々、会場を提供して下さったドワンゴ様、ありがとう御座いました。\n","categories":["Lisp","Scheme","Picrin","Scala"],"category_urls":["/categories/lisp","/categories/scheme","/categories/picrin","/categories/scala"],"date":"2014-10-26","title":"#関数型なんたら で喋ってきた","url":"https://KeenS.github.io/blog/2014/10/26/number-guan-shu-xing-nantara-nican-jia-sitekita/"},
  {"body":"# $\\mathbf{C_6H_6+HNO_3}$ ------------------------ 関数型なんたらの集い  κeen(@blackenedgold) # picrinについて --------------- ![ピクリン酸の構造式](/images/picrin/picrin-structure.png) 化学式 $\\mathbf{C_6H_3N_3O_7}$、示性式 $\\mathbf{C_6H_2(OH)(NO_2)_3}$ で表される芳香族のニトロ化合物。 一般にはフェノールのニトロ化によって得られる。 Note: ニトロ化に硫酸を使うことを触れる。 ![picrinのロゴ](/images/picrin/picrin-logo-fin01-02.png) # About Me ---------- + κeen + 東大数学科の4年生 + ソーシャルアカウントは上のアイコン達から。 + Lisp, Ruby, ML, Shell Scriptあたりを書きます + [picrin](https://github.com/picrin-scheme/picrin)のコミッタです # picrinについて ---------------- * github: picrin-scheme/picrin * R7RS-small scheme 処理系 * 速い、軽い、高機能を目指す * 組み込み向けを意識 * 1年くらい開発 * κeenがコミットし始めてから半年弱 # picrinの プロジェクト構成 --------------------------- コア(benz)はC、ビルドツールはCMake。 ``` ├── contrib (nitros) ....... ├── docs ├── etc ├── extlib │ └── benz ├── piclib .... └── src ``` Note: contribとextlib/benzを強調。 srcはほぼ空であることにも触れる。 # nitrosの紹介 --------------- * schemeやCで書かれている * picrinのコンパイル時に一緒にlibpicrinに入る * picrinと共にCMakeで管理されている Note: schemeファイルもlibpicrinにCの文字列として入ってることに触れる。 バイトコンパイルプロジェクトにも触れる。 nitrosも一緒にコンパイルされることを強調する。 # nitroの紹介 --------------- ## [R7RS](https://github.com/picrin-scheme/picrin/tree/master/contrib/05.r7rs/scheme) * picrinではr7rsもただのライブラリ * 組み込みのときに必要なければ外せばよい Note: リンクを辿る必要はない。 スライドは下に続く。 # nitroの紹介 --------------- ## [partcont](https://github.com/picrin-scheme/picrin/blob/master/contrib/10.partcont/piclib/partcont.scm) * ただの限定継続ライブラリ * ねこはるさんが詳しく話すと思うのでそちらに譲ります Note: リンクを辿ってソースを見せる。 # nitroの紹介 --------------- ## [for](https://github.com/picrin-scheme/picrin/blob/master/contrib/20.for/piclib/for.scm) * 非決定性計算ライブラリ * またの名をListモナド Note: リンクを辿ってソースを見せる。 # nitroの紹介 --------------- ## [regexp](https://github.com/picrin-scheme/picrin/blob/master/contrib/10.regexp/src/regexp.c) * Unixのregexライブラリのバインディング * Cで書かれている Note: リンクを辿ってソースを見せる。 詳細に説明する。 + `regexp_t`型 + dtor + GCに乗ることは強調 # nitroの依存関係の話 --------------------- * nitro同士に依存関係がある * forはpartcontに依存する * REPLはeditlineに依存する * etc... # picrinの依存関係解決法 ----------------------- [picrin/contrib](https://github.com/picrin-scheme/picrin/tree/master/contrib) Note: * リンクを辿る * ディレクトリ名が数字で始まることを説明 * 03まできてそろそろ限界であることを説明 どう見ても手動(ディレクトリ名)ソートですね。 本当にありがとうございました。 * さすがにどうにかしたい * 依存関係解決ツールが欲しい * なんかmrubyのmrbgemとかみたいにしたら楽しいんじゃね？ * 個々のnitroを別プロジェクトにも出来る! # sulfuricプロジェクト # sulfuricプロジェクト --------------------- * sulfuric acid = 硫酸 * nitro定義、依存解決、ビルドコンフィグ etc... * 最終的にはCMakeと連携 * 定義ファイルはschemeで書きたい Note: 個人案なことに触れる。 chikenのeggsやRacketのPlanetにも触れる。 # sulfuricプロジェクト --------------------- * あれ？R7RSってnitroじゃね？ * そもそもschemeをビルドするためにschemeを書く…？ * てかCMakeとの連携どうするよ Note: 進捗はまだinitial commitすら出来てない。 書いてる内に大きくなっていったことも説明。 最初は他のschemeでビルドする案やフェノールでビルドする案も話す。 solutionディレクトリに入れたいよねーも話す。 フェノールの合成にベンゼンスルホン酸が使われる # picrinにコミットしよう ----------------------- * picrinはまだ若い + ちょろっと覗くだけでコミット出来るところが見付かる * 開発者全員日本人 # コミットはとっても簡単 ------------ 1. [issue](https://github.com/picrin-scheme/picrin/issues)を覗く 2. 簡単そうなのをサクっと実装 3. PR Note: イシューの中から + \\#224 feature request: data structures + \\#210 Add MQTT support を見せる # Q. なぜpicrin? ------------ # A. picrinの独自拡張 ----------------- * [ドキュメント](http://picrin.readthedocs.org/en/latest/)に色々書いてある * C拡張の書き方も書いてある Note: arrayとdictionaryに触れる。 マクロに触れる C APIの項目があることにも触れる。 # picrinのマクロ ---------------- * `syntax-rules` (R7RS) * `sc-macro-transformer` * `rsc-macro-transformer` * `ir-macro-transformer` * `er-macro-transformer` * `define-macro` (Common Lisp) 参考: [様々な Hygienic Macro - 月の塵](http://d.hatena.ne.jp/leque/20080528/p1) # picrinにコミットしよう ----------------------- * issueに上がってなくても大歓迎 * Schemeの練習に * 「便利なライブラリ書いたけどどこ置いたら良いの」 # picrinにコミットしよう 以上 何か質問あればどうぞ   ","categories":["Lisp","picrin"],"category_urls":["/categories/lisp","/categories/picrin"],"date":"2014-10-24","title":"C6H6+HNO3","url":"https://KeenS.github.io/slide/c6h6-plus-hno3/"},
  {"body":"深町さんのブログで日本語でCommon Lispの質問をする方法が載ってましたが質問じゃなくて単に情報を得たい、勉強をしたいという場合が書かれてなかったので勝手に補遺。\n処理系選び 処理系:選び方の目安 - Common LISP users jpや Common Lisp 処理系 - 紫藤のWikiが参考になるかと思います。\n開発環境構築 Modern Common Lispあたりですかね。著者がちょっと古くなってきたので更新するって言ってました。\n処理系のインストールなら*nix環境で使える拙作のCIMもあります。解説はこちら。\n入門 Web 私の一番のおすすめはM.HiroiさんのWebページです。一応Common Lispではなくxyzzyですがここで紹介されている内容であればCommon Lispにも共通します。\nM.Hiroi\u0026rsquo;s Home Page / xyzzy Lisp Programming\n書籍  実践Common Lispは入門から実践までいけて素晴らしいです。内容の密度が濃いです。心無しか手にとってみると少し重いです。 loopやformatなど複雑な部分はしっかりベージを割いてるので入門が終わってもリファレンスとして役立ちます。私も今でも参照してます。 Land of Lispは挿絵が多く、少し学んでは実際に使ってみるのルーチンなので勉強のモチベーションを保ちやすいです。 内容は実践Common Lispに比べると細かな注釈が少ないかな？といったところ。さらっと読めて良いですね。 実用Common Lisp(通称PAIP本)はぶ厚くて高い本。AI系の内容らしい。私は読んだことが無いのですが、数理システムが入門書として使ってるそうです。 2014-12-14 追記 読みました  何か作る Web  Common LispでSTGを作りますが何かは有名なPDF。STG(シューティングゲーム)を作る内容。多少古い(SDLが1.2系だとか)ものの、練習には十分です。 Common LispでWebAppの開発に必要なN個のこと - 八発白中はWeb Appを作るにあたって必要なライブラリを紹介している。紹介しているだけで作り方は書いてないのでどうにか頑張って下さい。  あんまり情報無いですね…Lisperのみなさんもっとアウトプットしましょう。\nリファレンス Web  Common Lisp Hyper SpecはCommon Lispの機能をサンプルと共に網羅的に、詳細に紹介しています。英語です。 主にコンテンツからドリルダウンで調べていくと良いです。時間があればじっくり眺めても良いかも。 Common Lispをやる上では必ず必要になるので、英語ですが必ず友達になっておきましょう。 逆引きCommon Lispは名前の通りやりたいことからCommon Lispの機能を調べられます。サンプルもあります。残念ながら網羅的ではないのですが凡その需要は満たせると思います。 Quickdocsはライブラリのドキュメントサイト(英語)。ライブラリを捜す時にも良いと思います。  書籍  COMMON LISP 第2版は通称cltl2と呼ばれるCommon Lispの原典の和訳です。一応紹介しました。今のCommon LispはANSI Common Lispになってるので少し違います。  ポータルサイト  Common LISP users jpは日本語で様々な情報が得られます。 redditの/r/lisp_jaにはLispに関連するWebページの情報が日々投稿されています。 CLikiはCommon Lispの総合Wiki(英語)。非常に有用な情報が溜まってます。 Common-Lisp.netはCommon Lispのコミュニティ支援サイト(英語)。多くのプロジェクトをホストしていて、そのWebページなんかもあります。  ソースコードを読む κeenの適当チョイスです。他にお勧めがあれば教えて下さい。\n alexandriaは有名なユーティリティパッケージ。小さな関数やマクロで構成されてるのでイディオム集みたいな感じで読めると思います。 log4clはログライブラリ。ドキュメント(英語)をしっかり書いてるので読み易いです。 HunchentootはWebサーバ。ドキュメント(英語)を過剰に書いてるので読める筈。  ステップアップ Web  On Lispは主にマクロについて書かれたCommon Lispプログラミングの指南書。書籍もありますが、Web版もあります。  書籍  Let Over Lambda(通称LOL)は過激とか狂気とか宗教とか言われるエッセイ。高速化の話とかクロージャの危ない使い方とかが書かれてます。  Lisperとコミュニケーションをとる  Shibuya.lispは渋谷を中心に半径2万kmを対象としたLispコミュニティ。毎月下旬の平日夜にLisp Meet Upをやってるのでひょこっとやってくると良いと思います。内容はCommon Lisp, Scheme, Clojureで回してるのでCommon Lisp回は3ヶ月に1回ですが毎回Common Lisperは来てるので別のLispの回でも構わず参加すると良いと思います。 #lispmeetup の情報はここから入手するのが良いかな？あとはTwitterアカウントもあります。Ustream配信もしてます。 IRCの#lisp-ja@irc.freenode.orgと#common-lisp-ja@irc.freenode.orgにコミュニティがあります。常に誰かがいる訳ではないのですがちょくちょく見てる人はいるので発言してみると反応があるかもしれません。今もこの投稿に対して反応があってCIMとredditの項目を追加しました。 ","categories":["Lisp","Common Lisp"],"category_urls":["/categories/lisp","/categories/common-lisp"],"date":"2014-10-20","title":"Common Lispの勉強をするには、あるいは情報を得るには","url":"https://KeenS.github.io/blog/2014/10/20/lisp-ja/"},
  {"body":"κeenです。lisp meet up # 20に参加したのでレポートです。\n20人の募集に19人参加予定。会場は今回初めてのところでした。\nLT LTはTOYOZUMIさんが仕事で来れなくなったので私の1件のみ。内容はpicrinのチューニングの話と思わせてほとんどがその前振りのGCの話。\nスライドはこちら。\nPicrinのチューニングの話、もといGCの話 | κeenのHappy Hacκing Blog\nTOYOZUMIさんのdocstringの話聞きたかった\n飛び入り  ブラウザ上でbiwa schemeの環境(REPLだけでなくオートインデントとか)を作ってる 関連して、websocketでswankと対話できるやつ作ってる 関連して、ブラウザ上で動くLispに似てそうなBlockyというヴィジュアル言語がある なんかの話がありました。  余った時間 chikuさんが前でGCの話してました。んで話が尽きたあたりで私がpicrinの宣伝しました。(picrin control list)の話です。非同期プロミス然りpicrinにはトリッキーな機能が多いですね。\n結局ライブコーディングはしませんでしたね。\n懇親会 Raspberry Piの話とかちょいとGCの話とかVarnishの話とかaltJSとか。ブログの話題が出たのでOctopress推しといたり。なんでみんなGithub Pages + Octopress使わないん？便利ですやん。\n結構色々話してた気がするんですが覚えてないですね。\n","categories":["Lisp","Scheme","Picrin","Lisp Meet Up"],"category_urls":["/categories/lisp","/categories/scheme","/categories/picrin","/categories/lisp-meet-up"],"date":"2014-09-30","title":"Lisp Meet Up #20でLTしてきました","url":"https://KeenS.github.io/blog/2014/09/30/lisp-meet-up-number-20/"},
  {"body":"κeenです。ISUCON 4 予選に学生枠で参加してきたのでレポートです。日曜、2日目の方に参加です。\nメンバー集めと準備 一番苦労しました。去年と同じく、全く知らない人と組んでます。全然集らなくて、@941さんがメンバー集めの音頭をとってくれたりして、ようやく集りました。941++。\n結局ISUCON夏期講習にいたPythonアイドルのくーむ(@cocodrips)さんとその友達の友達のねむねむ(@nemunemu3desu)さんと出ることになりました。くーむさんは競技プログラミング系Pythonista、ねむねむさんはプログラマのためのWebサービス開発のバイトをやってるWeb系Rubyist。因みに私は去年もISUCONに出て学生賞なんか貰ってるのでISUCONで要求される技術は一通り、広く浅くといった感じのRubyist。普段はLisp書いてます。「Lispを書く」はダブルミーニングですよ。すごいどうでも良いけどくーむさんは情報系のM2、ねむねむさんは情報系のB4、私は数学科のB4です。\n流石に初対面のメンバーでいきなり競技を始めても何も出来ないので一度3人で顔を合わせて打ち合わせをしました。簡単に書いてますけど待ち合わせとか苦労したんですよ。\n データ量とかアルゴリズムに対する感のあるくーむさんにはMySQLのチューニングを任せる くーむさんは各社のインターンで実務経験があるのでデプロイとかのコードの流れ、ベンチマークの管理もやって貰う その周辺のツールも作って貰う Rubyでwebサービスの開発をやってるねむねむさんにはRubyのコードをがんがん弄ってもらう Redisを使うことも視野に入れてもらう。Redisの経験はあるようなのでそんなに問題なさそう。 あとは余ったNginX、Varnishをκeenが担当する 恐らくNginX、Varnishは然程手間取らないのでアプリとMySQLで苦戦してる方にκeenが入る 最初のセットアップはAWSアカウントを作ったくーむさんにやって貰う 最初に計測することが大事なのでデフォルトのままログの設定だけ変えてベンチを走らせて作戦会議をする チーム名は3人のアイデンティティを合わせて「(ρ_-)/超銀杏バスターズ(･ω･ o)」とする  あたりを決めました。\nくーむさんは完全に普段とドメインが違うのでちょっとつらそうでしたがSQLとかRedisとかの本を貸したらめっちゃ勉強してきたみたいでした。 流石、情報科ですね。地力が違いますね。あとはGithubの学生が使えるプライベートリポジトリを用意してくれたり。ベンチマークを走らせたら時刻とgitのコミットIDをセットにしてログ用のレポジトリに突っこむスクリプトの準備もしてくれました。\nねむねむさんはAWSアカウントを作って去年の予選の問題を予習してきたようでした。あとRedis使うかもって言っといたらRedis in ActionのPDFを見付けてたようなので読んできたんじゃないかなと思います。Rack用のプロファイラを試したようでした。去年も使おうとして結局使えなかったminiprofiler。ねむねむさんにも使えなかったようです。\n私はApacheとかNginXのログフォーマットを整備してパス/メソッド毎の(合計)レスポンスタイムを出す集計スクリプトを用意。その他マスタリングNginXを一通り読み直したりOpenRestyでmemcachedやlua、Redisのプラグインがあることを確認してインストールスクリプトを書いたりしてました。Varnishは間に合いませんでした。\n当日 開始 LINEカフェを使わせてもらうので9:20に集合。ちゃんと集まる。家の近いくーむさんがデカいディスプレイを持ってきてました。\nLINEカフェではLINEインターンの経験のあるくーむさんが勝手が分かってるので机を勝手に動かして三人横並びに座る。真ん中にくーむさんの大きいディスプレイがきて良い感じでした。\n10:00に号砲と共に競技開始。早速3人ともAWSの初心者でAMIの起動の仕方が分からず詰まります。ここクリックしてみて？とかいいながらログイン出来たのが10:20くらいですね。isuconユーザーにRSAのpubキーを突っ込むもパスワードを要求されてハマる。くーむさんはLinuxには不慣れなようだったので私がやるも夏期講習のときと同じく解決出来ず。うーん。結局パスワードのまま通しました。\ngitの設定をするときにアプリとログはレポジトリを分けることは決まってましたがログを吐く場所を決めてなかったのでゴタゴタ。/var/logに吐こうとするもMySQLが吐いてくれない。権限の問題じゃね？とか言って777にするという邪悪なことをするとねむねむさんがsshを締め出される。MySQLが吐いてくれなかったのは再起動忘れ。sshを締め出されたのはsshdのログファイルの権限の問題。この辺解決したのが11時過ぎかな？\nごたごたしてる間はねむねむさんはアプリ読んでくーむさんはインテグレーション周りの準備してくれたり。私もちょっとアプリ読んだりエラーでググったり。\n作戦会議 12時前なので昼御飯食べながら。\n ベンチマークを走らせると明かにMySQLが重いのでインデックスを張る(くーむ) アプリはキャッシュ効きそうなのでガンガンRedis使う(ねむねむ) とりあえずNginXの最適化とVarnishは入れる(κeen)  な感じです。\n作業 Typoがあった以外はNginXとVarnishはスムーズに。\n実際にはくーむさんがログの自動プッシュ周りで苦戦してたのでけんちん汁を食べてる隙に私がインデックスを張ることにしました。ちまちまexplainしながらやるもどうもうまくいかない、と思ったらinit.shのヒアドキュメントが二重になってる…。そこを解消したら一気にスコア上がりました。でもWHERE狙いとORDER BY狙いってどうなんだっけとなって多少過剰なインデックスだったかもしれません。\nそれでもうMySQLはCPU使わなくなったのでワークロード上げてみたらスコア12,000くらいになりました。\nなんか静的ファイルでベンチマークエラー出てるとくーむさんから報告がありました。Varnishの設定ミスったかなと思ったらエラーメッセージが無機質だったのでシステム関連っぽい。そこは全て独学でやってきた数学科生のググり力を発揮。調べるとローカルポートを使い果たしていた模様。システムの設定をコピペ。エラー出なくなる。\nRubyがCPU使ってるのでNginXからのリダイレクトをunixドメインソケットに。あんまり効果無し。\nねむねむさんのRedisキャッシュ化が入って15,000とか。ねむねむさんを信じて「キャッシュして」とだけ言っといたので詳細は不明ですがユーザーはRedisに全部突っ込んだ模様。その後は脱MySQLを目指して黙々と作業してました。\n私は/reportがN+1クエリなので直そうと2時間くらい奮闘。後にスコアには反映されてないことを知らされて絶望。よく見とけば良かった。しかもEmacsのバッファに残ってるものをコミットしてしまってねむねむさんのコミット上書きしてしまったりしました。\nまだRubyがCPUを使ってるのてテンプレートエンジンを置き換えることを考えました。slimが速いと風の噂で訊いたのでくーむさんにお願いしてみるもスコアがた落ち。あれRuby製だったんですね。C製のテンプレートエンジン捜しとかなきゃ。\nさらにくーむさんがCSSやpngのminifyを試みるもチェックサムをとられていたようで失敗。良く見たらMD5とるってレギュレーションに書いてありました。後にminifyでなくインライン化すれば良かったらしいと聞く。\n最終確認とか 17時あたりで一旦chkconfigしてリブートしてもベンチが動くことを確認。よかった。一応AMIを作ります。その後でN+1クエリの解決が動くも当然スコアには変動なし。あとはミドルウェアのログを切って脱MySQLは間に合わなくてアプリの微改善が入りパラメータの微調整をし、17,700あたりで競技終了。\n終わってみて 一応2日目の中では学生1位なものの、1日目10チーム、2日目4チームなので何とも言えないですね。一般枠は40,000でも本戦出場無理ポとか言ってるのに20,000にも全然届かないスコアで本戦出れるかもとか言ってるゆとりの学生です。\n反省は\n レギュレーション良く読む ベンチマークのスコアリングも確認する  静的ファイルは0.1点と思ってたら0.01点だった。この差大きい。  権限管理は適切に hangoutに思ったことを垂れ流す筈だったのに口頭で済ませてしまった  それだけならまだしもhangoutに貼ったものが無視されてしまった  プロファイラ使えるようにならないとね。  RubyがCPU喰ってるのは分かってるのにどこがまずいか分かんなかったのは悔しい  深みに嵌ったらあきらめる ブランチ切るとミドルウェアの違いで問題が出る(varnishとnginxの80の取り合い) 互いのスキルを把握しておく 開発スタイルを決めておく workload、workerprocessは最適値を捜す(コア数が4だったので4~8で決め打ちだったけど後に30くらいまで上げれると聞く)  かな？私が普段Linuxを使ってるのでLinuxの設定くらいみんな出来ると思ってたら私以外Macerだったってのは予想外でした。本来なら私がAWSアカウント持ってれば問題なかったんですけどクレジットカード持ってないんですよね。つらい。\n開発スタイルはねむねむさんがpull-reqスタイル、私が細かいコミットをマスターに入れるスタイルでした。設定ファイルとアプリの違いもありますがpull-reqスタイルの方がロールバックし易いしそっちに統一した方が良さげですね。\n個人的に、いつも通りケアレスミスが多かったのは反省しなきゃなと思います。「あれ？動かない。あ！そうか！」みたいな。メンバーは「すげー。デバッグ速えー」って言ってましたけど違いますよ？世の中の不当評価はこうして産まれるんだと少し社会を知りました。\nVarnishももうちょっと使い熟さないとなーってのとlua勉強しなきゃなーってのが個人的な本戦に向けた準備ですね。N+1のとこはSQLの練習が出来たので個人的には満足…って言ったらメンバーに怒られますかね。\n全体として、チームは上手く動いてたんじゃないかなと思います。N+1のところで無駄に嵌らずにねむねむさんと2人でアプリの改修やってたら脱MySQLが間に合ったんじゃないかなってのが心残りです。インテグレーションはくーむさんのスクリプトで良い感じだったのでもうちょっと改良して本番にも使いたいですね。あとCapistranoかFabricも準備しないといけませんね。\n本当、やらかしてばっかの私に怒ることなく一緒にやってくれたくーむさん、ねむねむさんには感謝してます。もし予選通ってたら本戦も宜しくお願いします。\nそして忙しい中ISUCONを開催して下さったCOOKPADの方々、941さん、ありがとう御座います。ベンチマーカーの問題にも迅速に対応して下さってこちらは本当に楽しく競技出来ました。\nP.S.\n今回の作業レポジトリはここ、ログレポジトリはここにありますがまだ非公開です。そのうち公開されると思います。\n","categories":["ISUCON","Ruby"],"category_urls":["/categories/isucon","/categories/ruby"],"date":"2014-09-30","title":"#ISUCON 4 予選に学生枠で参加してきました","url":"https://KeenS.github.io/blog/2014/09/30/isucon4-q/"},
  {"body":"# Picrinのチューニングの話、もといGCの話 --- Lisp Meet Up presented by Shibuya.lisp #20 2014-09-29 κeen(@blackenedgold) # 自己紹介 --- + κeen + 東大数学科の4年生 + ソーシャルアカウントは上のアイコン達から。 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます + [picrin](https://github.com/picrin-scheme/picrin)のコミッタです # picrin --- ![picrin](/images/picrin/picrin-logo-fin01-02.png) # picrin --- * R7RS compatibility * bytecode interpreter (based on stack VM) * internal representation by nan-boxing * conservative call/cc implementation (users can freely interleave native stack with VM stack) * exact GC (simple mark and sweep, partially reference count is used as well) * string representation by rope data structure # picrin --- * R7RS compatibility * bytecode interpreter (based on stack VM) * internal representation by nan-boxing * conservative call/cc implementation (users can freely interleave native stack with VM stack) * exact GC (simple mark and sweep, partially reference count is used as well) * string representation by rope data structure # picrin開発者の不満 --- * picrinの起動が遅い+ 2秒くらいかかる * picrinのテストが遅い+ 16秒くらいかかる # 少しGCの話 --- GC(ごみ集め)とは * 使われていないオブジェクトを自動的に解法する + メモリ管理に煩わせられないで済む + メモリーリークを防ぐ。 * 「使われていないオブジェクト」を判定するのはいくつかアルゴリズムがある # GCのアルゴリズム --- ## 主なGCのアルゴリズム * マーク\u0026amp;スイープ * 参照カウント * Copying GC # GCのアルゴリズム --- ## マーク\u0026amp;スイープ 1. あらかじめ全てのオブジェクトはどこかで一元管理する2. 一元管理元(ヒープ(ページ))でメモリが足りなくなったらGCを開始3. スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする4. そこから辿れるオブジェクトも再帰的にマークする5. ヒープからマークされていないオブジェクトを開放する6. それでもメモリが足りなければ一ヒープのページを増やす7. 増やせなければメモリを使い果したのでabort# GCのアルゴリズム --- ## マーク\u0026amp;スイープの特徴 * そこそこ速い * 正確に集められる * GC以外ではメモリ管理を考えなくて良い(≒プラグインは書き易い) * 長生きのオブジェクトは何度もマークされる(=世代別GC) * 負荷は1点に集中する * メモリの断片化が起きる(=オブジェクトのアロケートが遅くなる) # GCのアルゴリズム --- ## 参照カウント 1. オブジェクトに他から参照されている数(参照カウント)を記憶させる2. オブジェクトの参照を変えるときはその都度参照カウントを変える3. 参照カウントが0になったら開放する# GCのアルゴリズム --- ## 参照カウントの特徴 * 負荷は分散する * GCの実装は楽 * 少し遅い(必ずfreeする必要がある) * 正確でない(循環参照に弱い)(cf. 大相撲の星の回しあい) * プラグインは面倒 # GCのアルゴリズム --- ## Copying GC 1. オブジェクトプールを2つ用意する(1, 2)とする2. オブジェクトを確保するときは必ず1に確保する3. 1のメモリが足りなくなったらgcを開始4. 1の生きているオブジェクトを再帰的に2に移動する5. 1に残っているものは全てゴミとして良い6. 1、2のラベルを付け換える# GCのアルゴリズム --- ## Copying GCの特徴 * 正確 * メモリの断片化が起きない(Windowsのデフラグ)(=アロケートが速くなる) * 負荷は1点に集中する * 遅い(オブジェクトの移動が必要) * メモリ食う(オブジェクトプール2つ分) * ポインタも変わるため、ハッシュの再計算などが必要 # GCのアルゴリズム --- ## GCの主な属性 * 世代別 + 新しいオブジェクトだけGCの対象にする* 正確 + ゴミは必ず回収する* インクリメンタル + 一度にやらずに少しづつGCを進める# picrinのGC --- ![picrin](/images/picrin/picrin-logo-fin01-02.png) # picrinのGC --- * 基本は普通の正確なマーク\u0026amp;スイープ + Copying GCはlightweightでない * ropeには参照カウント + ropeには循環参照が起きない # picrinのGC --- * 基本はマーク\u0026amp;スイープ  3. スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする * schemeの変数はそのまま * Cの変数は読めないのでアリーナという場所を用意してC内ではそこに一時保管してもらう + スコープはFILOなのでスタックを用いればヒープより速くアロケート出来る # picrinのチューニング ## プロファイルをとってみる --- ``` % cumulative self self total time seconds seconds calls s/call s/call name 37.14 0.78 0.78 13136494 0.00 0.00 XROPE_DECREF 23.81 1.28 0.50 1544 0.00 0.00 gc_sweep_phase 15.72 1.61 0.33 59344814 0.00 0.00 gc_mark_object 10.00 1.82 0.21 1544 0.00 0.00 gc_mark_phase 6.67 1.96 0.14 1544 0.00 0.00 gc_mark_trie 2.38 2.01 0.05 6523 0.00 0.00 pic_apply ``` ほとんどGCですね。 本当にありがとう御座いました。 # 解決案 --- * GCのアルゴリズムを変える * オブジェクトをアロケートしないようにする * パラメーターをいじる # 解決案 --- * GCのアルゴリズムを変える * オブジェクトをアロケートしないようにする * パラメーターをいじる # GCに関連するパラメータ --- 元々tinyに設計されている ```C /* アリーナのサイズ */ # define PIC_ARENA_SIZE 1000 /* ヒープページのサイズ */ # define PIC_HEAP_PAGE_SIZE 10000 /* シンボルプール(ハッシュ)のサイズ */ # define PIC_SYM_POOL_SIZE 128 ``` # GCに関連するパラメータ --- チューニング後 ```C /* アリーナのサイズ */ # define PIC_ARENA_SIZE 8 * 1024 /* ヒープページのサイズ */ # define PIC_HEAP_PAGE_SIZE 2 * 1024 * 1024 /* シンボルプール(ハッシュ)のサイズ */ # define PIC_SYM_POOL_SIZE 2048 ``` # 結果 --- * 昔  テストに16秒 * 変更後  time make test-r7rs  make test-r7rs 1.68s user 0.23s system 98% cpu 1.931 total # 今後 --- * GCのアルゴリズムを変える + 世代別GCにしたいよねー + そもそもマーク\u0026amp;スイープの実装が適当すぎるだとか。協議中。 + 組み込み目指すならインクリメンタル性必要では？ * オブジェクトをアロケートしないようにする + バイトコンパイルするときにもめちゃくちゃアロケートしてる。その辺どうにかする。 + [Fast Reader](https://github.com/picrin-scheme/picrin/pull/207) # まとめ --- * 基本的なGCの解説をした * picrinのGCの戦略を話した * GCチューニング大事 以上 何か質問あればどうぞ   ","categories":["Lisp","picrin","GC","Lisp Meet Up"],"category_urls":["/categories/lisp","/categories/picrin","/categories/gc","/categories/lisp-meet-up"],"date":"2014-09-29","title":"Picrinのチューニングの話、もといGCの話","url":"https://KeenS.github.io/slide/picrin-gc/"},
  {"body":"低レベルなことがしたい。もうちょっと具体的に言うと、DBMを書きたい。コンパイラを書きたい。ただ動くだけじゃなくて効率的な実装がしたい。CPUの歓声が聞きたい。そのためにもバイナリを簡単に扱える言語が良い。マシン語が透けて見える言語が良い。いっそインラインアセンブラが欲しい。システムコールがスムーズに出来る(≒ C をスムーズに呼べる)言語が良い。どんな言語が適任か。\n因みにコンパイラはLLVMをバックエンドに使う予定。何の言語のコンパイラかは決めてない。SMLのサブセットかmini Camlかその辺？\nまず考えられるのはダイレクトにマシン語が見えるアセンブラ。でも移植性が無いからボツ。じゃあ他には？\n LLVMアセンブラ C C++ Java SML Haskell OCaml ATS Go D Rust  あたりかな？と思う。Common Lispはバイナリの扱いは案外いけるが流石に効率的な実装は難しい。ガチガチに型宣言つけていくくらいならそもそも静的型付けで型推論のある言語を使った方が良い。その意味ではHylasに期待したけど今はまだメンテナンス中。多分完成したら使う。\nNimrodなる言語もあるらしいがあまり聞かないのでスルー。\n因みにこの中で自分が普通に書けるのはCとJava。OCamlもまあまあ。HaskellはRWH読んだっきりでアウトプットはしてない。C++とSMLはHello World + α程度。他はサンプルコード眺めてHello Worldしたかしてないかくらい。\nLLVMアセンブラ 移植性のあるアセンブラ。アセンブラとは言ってもモジュールシステムもある、関数もある。一度学んでおくと便利な気はする。ただ、多少Cの呼び出しが面倒。メンテナンス性が悪そう。総合して悪くはない、程度かな。\nC Cの呼び出し易さにおいて他の追随を許さない言語。高級アセンブラの別名の通りマシン語も透けて見える。というか、書こうとしているDBMのプロトタイプはCで書かれている。だが、既にpicrinでCを書いているし、今回やりたいのとは違う気がするのでおやすみ。\nC++ LLVM自体C++で書かれているしbetter Cな側面もあるし今回の目的に一番合致しそうな言語。ではあるんだけどあまり好きになれない。一度はやっておかなきゃいけないんだろうけど…。一旦保留で。\nJava 安心と信頼のJava。30億のデバイスで走るJava。バイナリの扱いは上々だけど今回は使いたくない。理由は、必要上の理由ではなく論理的な理由でオブジェクトを作らなきゃいけない点。メモリ管理が出来ない点。ポインタを扱えない点。抽象性のための犠牲なんだろうけど今回は抽象性ではなく効率をとりたい。\nただ、後で習作としてDBMをJavaで書き直すのはありかもしれない。JavaというかMirahだろうけど。\nSML Standard ML。人工知能御三家のうち唯一静的型付けの言語。Haskellerがモナドモナドうるさい所為で隠れがちだがML系の言語は意外とバイナリの扱いも出来る気がする。記号処理に向いてるからとコンパイラを書こうとしたときにバイナリ扱えないと片手落ちだからかな。実際SML、OCaml、Haskellは全てセルフホストコンパイラがある。\nSMLの中でも今回検討してるのはSML#とMLton。どちらもCとの相互呼出がある。しかも1行書くだけ。だが複雑な構造体とかはどうしようね。\nSML#は分割コンパイルがあるしSML#自身LLVMバックエンドなのでLLVMバインディングもある。が、MLtonに比べて数倍遅く、まだ64bit対応もしてない。MLtonは速くて機能も豊富。だが分割コンパイルは無いっぽい？\n一応コンパイラはこれらのどちらかで書くかな、と考えている。\nHaskell ML系の言語の中では一番人気でライブラリ豊富。言語自体はすごい好きなんだけどコミュニティが初心者をモナドで殴りにいく印象が強いのであまり好きになれない。あと参考コードとしてGHCのコードは読む気にはなれない。SMLで書いててつらくなったらトライしてみるかな。その時は(a)jhcを使うのかな？\nOCaml LLVMやるならOCamlらしい(?)。が、C書いててライブラリの豊富さに気付いてSML#やってCとの相互呼出に惹かれた身には少しもの足りなくなってきた。うーん。迷う。\nATS 元Depenent ML。低レベルなことが出来るMLらしい。しかし一々証明しながらプログラム書く気はしない。もうちょっと情報が欲しい。\nGo 最近中々の人気を見せるGo。一応コンパイルの速いシステム記述言語との触れ込みだがWeb系で多い気がする。なんとなーく自分のやりたいことと違う方向向いてる言語な気がする。Goで書かれたDBMもあるけど。Cとの連携はトリッキーだがヘッダからラッパ自動生成してくれるのは気に入った。DBM書く候補には入れとく\nD やりたいこと的には多分一番合ってる言語。でもネタ言語感が拭えないのがなんとも。あと思ったよりCの呼び出しが面倒だった。一応心には留めておく。\nRust まだまだ未熟な印象な言語。だがMozillaが本気で作ってるっぽいので期待も出来そう。メモリ管理も自分でやらせてくれるみたいだしDBMはこれでいこうかなと思ってる。でもCとの連携はつらそう。うーん。メモリモデルの関係上ヘッダから自動生成は出来ないのは分かるんだけどどうにかならんのですかね。\nまあ、これだけつらつら書いておいてもCIMもpicrinもcl21も面倒看なきゃいけないしcl21-datacollectionsも復活させないといけないしちゃんと出来るんですかね。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2014-09-18","title":"低レベルなことがしたい","url":"https://KeenS.github.io/blog/2014/09/18/low-level-languages/"},
  {"body":"κeenです。レポートに追われ試験があり合宿に行きで2週間以上空きましたが8/30にShibuya.lisp TT #8の運営をしつつLT枠での参加もしてきたので報告です。何かそこそこ大きなイベントの運営をされる方の参考になれば。\nキックオフミーティング キックオフミーティングが6月にありました。集まったのは5人。potix2(@potix2)さん、chikuさん、深町(@nitro_idiot)さんかにたん(@kazh98)、私。Shibuya.lispの運営はもうちょい居る筈なんですけど引く手数多のLisper達はきっと忙しいんでしょうね。\nShibuya.lisp TTを開催するかを含めて話し合いました。開催されるとなれば3年振りです。\n一番の懸案事項はTTをする人がいるかでした。招待講演のアテを話し合ったりTT枠とLT枠のバランスを話し合ったりして開催可能だろうと判断しました。その場で予想参加人数、タイムテーブルや役割分担、TT枠やLT枠が応募多寡になったときの対応、懇親会をどうするかなどを話し合いました。\nやっぱりその時点では会場が決まってないので不確定要素が多く、「会場次第」が多かったかと思います。そのときの予想や要求を元に会場の条件を絞った訳ですが。\n必要と判断された役職は、\n 懇親会 司会 誘導 照明 マイク 受付 会計 広報 動画 タイムキーパ コーヒーのケータリングとかお茶とかお菓子の準備  でした。5人だとどうしても人数が足りないので運営手伝いも募集することになりました。\n会場決定 mixi様より(鈴木さん経由で)会場を提供頂きました。スクリーン2枚、飲食OK、懇親会もその場でOK、ハンディカムの貸し出しありの至れり尽せりです。鈴木さんありがとう御座います。\n広報 広報担当のかにたんがTwitterやMeet Upで宣伝したりchikuさんがTokyo.cljに参加して宣伝したりで広報活動を行なってきました。結果、60人の枠がほぼ埋まる(キャンセル含めれば超過)程度の人数が集りました。かにたんありがとう。\n懸案事項だったTTの発表者は早々に埋まり、むしろ応募多寡だろうと予想されたLT枠が半分しか埋まらなくて焦りました。\nビデオ 映像に詳しいTOYOZUMIさんに相談したところ、発表者の映像出力をキャプチャする手段があるとのことなので\n 特殊機器による映像出力のキャプチャ ハンディカムによる発表者の録画 WebカメラによるUstream配信  の3つを行ない、3.はリアルタイムに、1.、2.を合成したものを録画映像として配信することになりました。一応私がビデオ担当でしたが一人では無理なのでchikuさんやかにたんと一緒に予行演習を行ないました。\n扱いの分からぬ機器に悪戦苦闘し、一応動かすことは出来たものの不安が残るので、上手く動いたシナリオと動かなかったシナリオを用意しました。\nその他 懇親会の手配やら会計やらがどうだったかは分かりません。何も気にすることが無い程スムーズに進んでたんでしょう。potix2さんと深町さんありがとうございます。\n当日 準備 chikuさんと一緒に渋谷駅に集合し、ケータリングのコーヒーを持って会場入り。そのまま鈴木さんにお世話になりつつ会場設営。当初は私は会場設営はほどほどに、ビデオ関係の準備をしてる筈でしたが人が少ないのでそのまま設営をやってました。\nさらにThunderboltケーブルが不足ということでビックカメラまでダッシュ。雪駄+合宿で痛めた足で走るんじゃなかった。結局Thunderboltを買ってきても機器を上手く扱うことが出来ず、失敗した方のシナリオでオペレーションしてました。\n映像配信に関しては私のLinuxではUstream配信出来ないだとかWebカメラがスライドから遠くて見えないだとかがありましたが、全体は滞りなく進行。\nTalk TalkはLT枠は飛び入りが4人あり、結局良い感じに埋まりました。\n 特別講演  笹川様 : 好きい夢の話 (ビデオ)  TT  athosさん : genuine-hilighterの話 (ビデオ) 深町さん : cl21の話 (ビデオ) 豊住さん : 自作画像処理ライブラリの話 (ビデオ) 横田さん : 型宣言と最適化の話 (ビデオ)  LT (ビデオ 1~4、ビデオ 4~9)  のぶかずさん : Shenの話 κeen : moclの話 かにたん : 床下LispとLisp Meet Upの話 すてぃべあさん : EROSの話 ねこはるさん : Clojureの型推論器の話 Takagiさん: cl-cudaの話 あんちべさん : Incanterの話 TAKUFUKUSHIMAさん : Omの話 zick_minohさん : 42の言語でLisp処理系を書いた話   と様々な内容に分かれて行われました。私の発表スライドはここにあります。\n懇親会 箸が足りない、ケータリングのボットを返却し忘れるなどとトラブルはあったものの概ね問題なく進みました。出されたのはアルコール、ソフトドリンク、寿司、ピザです。\nだいたい言語毎に島が出来てたようです。私は撮影したビデオを取り込みつつ色々な島に入っていきました。Common Lisperでcl21コミッタでScheme実装者でClojureワナビーなのでどこにも入れて良いですね。ただ、前日スライドの微調整などであまり寝てなかったのでちょいちょい居眠りしてました。\n片付けが終って外に出るとみなさんが待ってて下さったのでぞろぞろ帰りました。TOYOZUMIさんが2次会にカラオケに行こうと皆さん誘ってました。私は行こうかと思ったのですがカラオケはジェネレーションギャップがあるとつらいので大人しく帰りました。\n後日 返し忘れたケータリングのポットは後日chikuさんが返してくれました。\n録画した動画はちょいと梃摺りました。まず、長い動画なので動画サイズが4GBのところで切れてます。なのでその2つを結合し、さらにあまりにサイズが大きいので画質を落とす作業が必要でした。\n変換はavconv(ffmpegのフォーク。Ubuntuだとこれしか入らない)で行なったのですが、MPEG4をダイレクトには結合出来ないらしことに気付くまで何度も失敗しました(1つの動画の変換に4時間とか掛かるんですよ？しかもその間CPUは100%に張り付いてるのでPC使えない)。レポートやら試験やらの合間に行なったのでそれだけで数日使いました。最終的にはmpegtsなるフォーマットに変換してcatで結合すれば良いことが分かり、 (MP4 + MP4) -\u0026gt; (mpegts + mpegts) -\u0026gt; mpegts -\u0026gt; MP4 -\u0026gt; MP4(low quality) の手順を踏んで最終動画を得ました。それでも1トークあたり1GBくらいのサイズがあります。もうちょい画質落としても良かったのかな。\nで、今アップロード中ですが私のポンコツWiMAXルータは高負荷に耐えられず1動画数時間掛かってます。その間全くネットが使えません。はぁ。\n実は今回の運営は私も含めTech Talk初参加の人がそれなりに居たのですがなんとか乗り切れましたね。講演をして下さった笹川様、会場を提供して下さったmixi様と鈴木さん、運営の手伝いをして下さった方々、ありがとう御座いました。そして運営のみなさん、発表者のみなさんお疲れ様でした。\n次回もTT開催出来ると良いですね。\n","categories":["Shibuya.lisp","Lisp","Common Lisp","MOCL","Android"],"category_urls":["/categories/shibuya.lisp","/categories/lisp","/categories/common-lisp","/categories/mocl","/categories/android"],"date":"2014-09-16","title":"Shibuya.lisp Tech Talk #8を運営\u0026LTしてきました","url":"https://KeenS.github.io/blog/2014/09/16/lisp-tech-talk-8/"},
  {"body":"# Introduction to CIM κeen(@blackenedgold) ## 突然ですが Common Lispのスクリプトファイルの実行方法知ってますか？ sbcl sbcl --script $file ecl ecl -shell $file ccl ccl -e $file -e '(quit)' ... シバン可搬性のあるスクリプトが書けない ## そこで、こんなの書きました ```sh case \"$LISP_IMPL\" in sbcl*) sbcl --script $1 ;; clisp*) clisp -on-error exit -i $1 ;; ecl*) ecl -shell $1 ;; ccl*) ... ``` ## でも問題がある * どの処理系をバックエンドに使うか * 処理系のパスをどう捜すか * そもそもどうやって使ってもらうか ## κeenの答え  処理系の管理までやってしまおう。  そうしたら一緒に使ってもらえる。 ＿人人人人人人＿ ＞　CIMの誕生　＜ ￣Y^Y^Y^Y^Y￣ ## CIMとは * Common Lisp Implementation Manager * ちむ * Rubyのrvmを強く意識 * Common Lisp処理系のインストール、切り替え、コマンドラインインターフェースなど。 * `cim`、 `cl`、 `ql`コマンドから成る * B Shell スクリプト製(マルチプラットフォーム対応のため) * 2013/10くらいからぼちぼち開発 ## `cim`コマンドについて インストール cim install sbcl バックエンドの切り替え cim use sbcl 現在情報 cim info CIMのアップデート cim get など。 ## `cl`コマンドについて * 最初に紹介したシェルスクリプトベース * コマンドラインからCommon Lispを使うことを重視 * シバン対応も。 * REPLは独自実装(デバッガを黙らせるのが主な目的) * オプションはrubyを意識 ## 少しシバンの話 ### だめな例 ```lisp #!cl (write-line \"ok\") ``` ```lisp #!/home/kim/.cim/bin/cl (write-line \"ok\") ``` ```lisp #!/usr/bin/env cl -q (write-line \"ok\") ``` ### 推奨される例 ```lisp #!/bin/sh #| exec cl -- \"$0\" \"$@\" |# (write-line \"ok\") ``` ## `ql`コマンドについて * quicklispのコマンドラインインターフェース * まだ未熟 * rubyのgem的な。 * 最近`ql install`を高速化 ## その他の話 ### 対応処理系 * 処理系はabcl, alisp, ccl, clisp, ecl, sbcl対応 * 基本ビルドする * gclはANSIじゃないのでドロップ * lispworks他商用ははインストール出来ないのでドロップ * mkcl対応する？ * CMU CLはつらい… ### 実装 * B Shell スクリプトで書いたの失敗だった? * つらい * 開発速度に影響 * テスト（=品質）にも影響 * sbclがじゃじゃ馬でつらい ### 方針 * コマンドラインユーティリティである * 基本POSIX以外に依存しない * 極力環境に影響しない(rvmがひどいのを嫌って) * clコマンドはあくまで薄いラッパ * asdfも使わない ## [半年前](http://www.slideshare.net/blackenedgold/cim-common-lisp-implementation-manager?ref=http://keens.github.io/blog/2014/01/24/lisp-meet-up-number-13/)から何が変わったか * バグ潰し * その他細かな改善 + ダンプされたコアを読み込む機能 + SIGINTをハンドル + ビルド時のログ制御 * ぼちぼちテスト書き始めた ## 将来の話 * テストと品質の安定化 * バイナリ配布の処理系は大人しくバイナリ使う？ * 最適なビルドオプション * コアダンプ機能 * Lispスクリプト(実行可能ファイル)インストーラ * cl21との連携（バイナリ生成） * もうちょっとquicklispとの連携 * ユーザー拡張 ## 関連リソース * [The problem with Lisp ](http://pupeno.com/2007/08/26/the-problem-with-lisp/) : Lispはコマンドが作れないから流行らないという分析 * [CIMの解説をしてみる コマンド編 | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2014/01/27/cim-explanation/) : CIMの解説記事 * [shelly](https://github.com/fukamachi/shelly) : CIMを使うCLのコマンドラインインターフェース * [lsp](https://github.com/snmsts/lsp) : CIMのC実装 * [qlot](https://github.com/fukamachi/qlot) : `ql`よりリッチなquicklispラッパ 以上 何か質問あればどうぞ   ","categories":["Common Lisp","Lisp","CIM"],"category_urls":["/categories/common-lisp","/categories/lisp","/categories/cim"],"date":"2014-08-30","title":"Introduction to CIM","url":"https://KeenS.github.io/slide/introduction-to-cim/"},
  {"body":"# 授業で半年間moclを使ってみた Shibuya.lisp TT #8 κeen(@blackenedgold) ## 自己紹介 + κeen + 東大数学科の4年生 + ソーシャルアカウントは上のアイコン達から。 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます 一年前 ## [計算数学II](http://ks.ms.u-tokyo.ac.jp/) ![計算数学IIのホームページ](/images/shibuya_lisp_TT8/calculation_math.png) 自分でテーマを決めて半年間取り組む チーム[人造エイリアン](https://sites.google.com/site/2013ks2/home) ![チーム人造エイリアン](/images/shibuya_lisp_TT8/android_alien.png) ## Common Lisp でAndroid? ## [mocl](https://wukix.com/mocl) ![mocl home](/images/shibuya_lisp_TT8/mocl.png) ## What is mocl * iOS, Androidで動くCommon Lisp処理系 * LLVMをバックエンドに使う * Networking, Unicode, CLOS, and More. Run Countless CL Libraries. ## 買ってもらった(・ω・)v ![mocl home](/images/shibuya_lisp_TT8/mocl_ut.png) ## 注意 私が触ったのは1つ前のバージョンです。 一部5月のアップデートで改善されています。 ## How it Works ## コードサンプル 授業で私が作ったオセロのAIのコード ```java public BoardCanvas(Context context,int width, int height,int color ){ ... CL.cl_init(); CL.init_game(3 - color); ... } void nextHand(){ String[] coord = CL.next().split(\" \"); CL.jput(Integer.parseInt(coord[0]), Integer.parseInt(coord[1]) , color); ... } ``` ## コードサンプル ```lisp (declaim (call-in next)) (defun next () (let ((dummy (make-board)) (max most-negative-fixnum) (x) (y) (score)) ... )) (declaim (call-in init-game)) (defun init-game (color) (setf *board* (make-board)) (setf *ai* color)) (declaim (call-in jput)) (defun jput (x y color) (put *board* x y color)) ``` ## ライブラリについて * ASDFが使える * `MOCL_HOME/systems/`以下に配置 * quicklispでインストールしたやつは`MOCL_HOME/systems/`にひたすら`ln -s` * 大抵のライブラリは動かない 例えば`cl-annot`を使って ```lisp (declaim (call-in jput)) (defun jput (x y color) (put *board* x y color)) ``` を ```lisp @call-in (defun jput (x y color) (put *board* x y color)) ``` としたい 私のときはCFFIを始め、ironclad、cl-annotなど、 使おうとしたライブラリは全て動かなかった 現在の状態は不明 ## 作業フロー(Android)  CLのコードを書いてSBCLで動かす ある程度動いたらmoclでAndroid用のコードを生成 原因不明のエラーが出るので1に戻る コンパイルが通れば生成されたCをコンパイル  JavaからCLを呼び出すコードを書く アプリをコンパイル 実機/エミュレータに転送  動かす 動かない ひたすらlogcat眺める 1に戻る  ### ここがつらい * 作業が煩雑 * 例外のスタックトレースがJNIのせいで追いづらい * logを出すには`rt:format`という関数のみ使える(ログレベルを設定出来ない) ※ 今はREPLが端末で動くので環境は良くなっています。 ## 制限など * Java/Obj-CからCLを呼ぶことしか出来ない + プラットフォームのライブラリも呼べない * やりとり出来るのは文字列、数値、真偽値のみ + 裏でタスクを回すworker的な役割or純粋関数的な役割のみ ※ 今はCLからObj-Cを呼ぶことが出来ます。 ## 成果物 * [コード(抜粋)](https://gist.github.com/KeenS/15e7bb35519818c88c13) * [最終発表スライド](http://www.slideshare.net/blackenedgold/ss-30373688) * [デモ動画](http://www.slideshare.net/blackenedgold/ss-30373688) ## おまけ ## 5月のアップデート内容 * OS Xアプリケーション対応 * 端末内でREPLが動く * FFI強化 * Lisp内Obj-C構文 * iOSとOS XでのネイティブSSL対応 * ARM64サポート * ドキュメントの改善 * 多くのバグフィクス 以上 何か質問あればどうぞ   ","categories":["Common Lisp","Lisp","mocl","Android"],"category_urls":["/categories/common-lisp","/categories/lisp","/categories/mocl","/categories/android"],"date":"2014-08-28","title":"授業で半年間moclを使ってみた","url":"https://KeenS.github.io/slide/shibuya-dot-lisp-tt-number-8/"},
  {"body":"κeenです。もうすぐShibuya.lisp TT #8 ですね。今回はCIMのREPLの改善をしてたらSIGINTを補足しようとして詰まったので共有します。\n結論を書いちゃうと\n(defvar *interrupt-condition* ;; It seems abcl does not raise any conditions #+allegro \u0026#39;excl:interrupt-signal #+ccl \u0026#39;ccl:interrupt-signal-condition #+clisp \u0026#39;system::simple-interrupt-condition #+ecl \u0026#39;ext:interactive-interrupt #+sbcl \u0026#39;sb-sys:interactive-interrupt #-(or allegro ccl clisp ecl sbcl) \u0026#39;no-conditon-known) (defmacro with-handle-interrupt (\u0026amp;body body) `(handler-case #-ccl(progn ,@body) #+ccl (let ((ccl:*break-hook* (lambda (condition hook) (declare (ignore hook)) (error condition)))) ,@body) (#.*interrupt-condition* (c) (handle-interrupt c)))) こんな感じです。ABCLがコンディションを投げずに即終了してる(?)っぽいのでABCLに対しては無力です。もしかしたらJava側で捉えないといけないのかもしれません。 因みにどうやってそれぞれのコンディション名を調べたかというと、(handler-case (loop) (condition (c) (print c)))を各処理系のREPLで実行して^Cしました。 Allegro CLはinterrupt-signalがconditionのサブクラスでなかった(serious-conditionだった)のでちょいと困りましたね。結局マニュアル読みました。\nCIMのコードなので上記以外の処理系には対応してないです。\n今回詰まったのはCCLですね。ccl:interrupt-signal-conditionは定義してあるもののユーザーより先に処理系が処理するので無意味でした。なのでccl:*break-hook*を使って処理系が捉えるより早くコンディションを発生させました。\n","categories":["Common Lisp","Lisp"],"category_urls":["/categories/common-lisp","/categories/lisp"],"date":"2014-08-27","title":"Common LispでSIGINTを捉える","url":"https://KeenS.github.io/blog/2014/08/27/sigint-in-common-lisp/"},
  {"body":"レポート締切間近のκeenです。ISUCON夏期講習2014に参加してきたのでレポートです。とはいっても去年の夏期講習もISUCONも参加してるので目新しいことはないんですが。主な目的はメンバー集めです。\n流れ  LINEの採用情報: ISUCONがきっかけでLINEに内定貰った人がいるよう。因みに自分はLINE落ちた。 ISUCONの概要の説明: うん。知ってる。    ISUCONの話(夏期講習2014)  from SATOSHI TAGOMORI  + 過去問を解く: 去年の予選の問題だった。うん。知ってる。 + パフォーマンス向上に関しての解説: これもISUCON反省会とかそんなんでkazeburoさんが話してた気がする\n  Webアプリケーションの パフォーマンス向上のコツ 概要編  from Masahiro Nagano    Webアプリケーションの パフォーマンス向上のコツ 実践編  from Masahiro Nagano \n morisさんによるライブチューニング: 失敗してた 懇親会  自分の作業 前年度参加者がハイパフォーマンス叩き出して俺TUEEEEEEしても意味がないので次回のISUCONで試したいことを試して地雷踏むことにした。\nsshのRSAAuthenticationの設定 何故かハマる。\nid_rsa.pubをauthorized_keysに突っ込んでUserPAMの設定まで確認してsudo service sshd restartしたのにパスワードを求められる。確か色々確認してもう一回sshdリスタートしたら通った気がする。原因不明。\nそういや curl https://github.com/KeenS.keys \u0026gt;\u0026gt; .ssh/authorized_keys のワンライナー使えば良かった。\nアプリケーションをgitで管理する やらかす。\n最初isucon/webapp/ruby/だけをgitで管理した。それだと足りないので次にisucon/全体をgitで管理しようとしたらisucon/webapp/ruby/がサブモジュール扱いされて困った。サブモジュール分かんね。色々試すもついぞisucon/のgitでisucon/webapp/ruby/を管理出来なかった。結局.git吹っ飛ばして再度git init .した。これは次回までの宿題ですね。\nあと地味にisucon/init.shが.gitignoreされてて困った。\nサーバーマシンをgitサーバーにする 前回はbitbucketで管理してたがしばらく使わない内にパスワードを忘れてしまったのと(もしかしたら以前のバイト先のメールアドレスで登録してた?)pingが400msのbitbucketサーバー使うのに気が引けたのでサーバーマシンをgitサーバーにしようと決意。ハマる。\ngitのマニュアルを適当に読んでたのが悪かった。ローカルでgit clone iscon@machine:isuconしてもなんか怒られてしばらく悩む。正解は、先ずリモートでgit clone --bare isucon isucon.gitしてからgit clone iscon@machine:isucon.gitだった。\n次にリモートで mv isucon isucon.back git clone isucon.git isucon したら.gitignoreとかその辺の関係でベンチマークやら何やらが動かなくなる。自分でベンチマークをビルドする羽目に。\n新たにcloneせずに cd isucon git remote add origin ../isucon.git すれば良かったのだろうか。要調査。\n細かなチューニング markdownのバックエンドをrdiscountにしたり。これもGemfileで困る。結局あれはローカルでbundle install --no-deployしてからgit pushしたら良かったのだろうか。これも宿題。\nインデックスを張る isucon/config/init.sqlに\nCREATEINDEXusers_idx_usernameONusers(username);CREATEINDEXmemos_idx_id_is_private_created_at_idONmemos(is_private,created_at,id);CREATEINDEXmemos_idx_id_user_created_atONmemos(`user`,created_at); を書いてisucon/init.shに\n#!/bin/sh set -e mysql -u isu-user isucon \u0026lt; ./config/init.sql \u0026gt; log 2\u0026gt;\u0026amp;1 #データ投入後になにかしらの作業をしたい場合はこのシェルスクリプトに書いてください を書くもエラーが出る。結局絶対パスで書いて2〜3回実行したら通ったのでパスの問題だったかと。しかし1回で通らなかったのは謎。\nあとデバッグ大変だった。ベンチマークツールさん、初期化スクリプトでエラー出したらエラーログ吐いて下さいよ。\nそういやリダイレクト先のlogファイルは結局行方不明のままだった。\nN+1クエリの解決 SQL書けなすぎてJOINとかFORCE INDEX書くのに戸惑った。一々書いてはmysqlのコンソールに貼ってエラーメッセージ読んでってやってた。すんなりやりたい。\nリバースプロキシをNginXにする まずは\nsudo yum install nginx mv /etc/nginx/nginx.conf ./config/ git add ./config/nginx.conf git commit -m \u0026#39;add nignx.conf\u0026#39; sudo ln -s /home/isu-user/isucon/config/nginx.conf /etc/nginx/ sudo service httpd stop sudo service nginx start だったかな?最初lnに絶対パスを使ってなくてエラー出たりしたけど。\nんで\nlocation / { proxy_pass http://localhost:5000; } だけ書くも404 http://localhost:5000/なんちゃら Not Foundが出る。そういや、とプロキシヘッダを追加。それでも画像などはとれない。多分rootをいじらなかったのが原因。次の手で静的ファイルをNginXでキャッシュするように設定したら直った。\nあまり記録残してないけどこの辺で2900点くらいで首位だった気がする。因みに初期値は1700くらい。\nVarnishを噛ませる 前回、ベンチマークツールのチェックが甘くてVarnishを使うだけでスコアが跳ね上がるというのを知っていたのでちょっとチート臭いけどどうせ本番でも必要だしということで練習もかねて使う。\nsudo yum install varnish mv /etc/sysconfig/varnish ./config git add ./config/varnish git commit -m \u0026#39;varnish\u0026#39; sudo ln -s /home/isu-user/isucon/config/varnish /etc/sysconfig/varnish mv /etc/varnish/default.vcl ./config git add ./config/default.vcl git commit -m \u0026#39;default.vcl\u0026#39; sudo ln -s /home/isu-user/isucon/config/default.vcl /etc/varnish/default.vcl 的なことをやった。あとはvarnishを80番にしてバックエンドを4000番にして、NginXを4000番にした。それだけでスコアが14000くらいになった。varinish簡単だし優秀。\nmy.cnfのチューニング もはやvarnishが仕事してる所為でボトルネックはベンチマークツールなのだけど一応。\nとはいってもinnodb_buffer_pool_sizeを2GBから6GBにしただけ。因みに与えられたマシンのメモリは8GB。スコアは一応微増。でもまあ誤差の範囲内。\nこの辺でタイムオーバー。\n懇親会 目の前の人がClojure推しの人でだいたいそんな話してた。\nチームメンバー捜しは席の周りの人が当日出れない人ばかりだったのと席替えがなかったので失敗に終わる。誰か学生枠で一緒に出ましょうよ。学生賞目指しましょうよ。\nやり残したこととか反省とか  ローカルで変更→commit→push→リモートでpull→再起動→ベンチマークのワークフローが結構面倒だったしpull忘れ、再起動忘れがあったのでpushより後を自動化したい。出来ればgitのコミットログとベンチマークのスコアをペアで保存しながら。hook使ったら割と出来そうな気はするんだけどなあ。 折角サーバー与えられたんだしMySQLのslow logを吐かせるの一回練習しとけば良かった。 結局capistrano使わなかった。複数台構成なら必須だし復習しておきたかったのに。 メンバー捜したかった。  マジでメンバー捜してます。学生枠で出たい人@blackenedgoldまでお願いします。\n","categories":["ISUCON"],"category_urls":["/categories/isucon"],"date":"2014-08-21","title":"isucon夏期講習2014に参加してきた","url":"https://KeenS.github.io/blog/2014/08/21/isucon-summer-2014/"},
  {"body":"κeenです。このブログのアクセスログを見てるとEmacsの記事が好評なようなのでここは一つ私の知ってる便利機能を全列挙してみますね。\nどの辺から常識でどの辺からTipsかは私の主観です。だいたいるびきちさんの本に載ってるのは常識扱いです。\n※-!-でカーソル位置、-¡-でマーク位置を表すものとします。\n※私はEmacsのtrunkをビルドして使ってるので最新のリリース版のEmacsにも含まれない機能もあるかもしれません。\n改行/インデント系 C-m RET C-j C-o 最初の頃は混乱してました。\n   key lisp function     C-m = RET newline   C-j newline-and-indent   C-o open-line    です。C-mとC-oの違いはカーソルが現在行に残るか残らないかです。\naaa-!-aaa ↓ C-m\naaa -!-aaa ですが、\naaa-!-aaa ↓ C-o\naaa-!- aaa です。\nC-oの改行後にインデントする版を捜したのですがC-M-o (split-line)という近いコマンドはあるもののまさにというのはありませんでした。\n※trunkではデフォルトでelectric-indent-modeがonになってるのでC-m/RETとC-jが入れ替わります。\n※現在行と改行した先の行両方をインデントするindent-then-newline-and-indentという関数もあります。\nM-^(delete-indentation) 直感的にはnewline-and-indentの逆関数です。今の行を上の行にくっつけます。そのとき邪魔になるインデントは取り除いてくれます。M-- M-^とすると下の行を今の行にくっつけてくれます。\nC-M-j(indent-new-comment-line) コメント内で使うC-jです。\n;;; This is a comment-!- ↓ C-M-j\n;;; This is a comment ;;; -!- です。\nM-m(back-to-indentation) 現在行の空白文字でない最初の文字に移動します。viでいう^です。\n aaa-!-bbb ↓\n -!-aaabbb です。\nelectric-indent-mode さっきちらっと触れました。C-mがnewline-and-indentになってC-jがnewlineになるモードです。\n削除/kill-ring系 \u0026lt;C-S-backspace\u0026gt;(kill-whole-line) おなじみ C-k(kill-line)は現在位置から行末までを削除しますが、それだとぬるいといってC-kで現在行をまるごと削除する設定((setq kill-whole-line t))してる人もいますが、実は\u0026lt;C-S-backspace\u0026gt;で可能なのでした。鍛えられた左手の小指の先と腹でCaps LockとShiftを同時押しすれば難易度もそんなに高くない！\nC-M-w(append-next-kill) nextのkillコマンドでkillした内容をkill-ringにappendします。チュートリアルにも載ってた気がするんですがすっかり忘れてました。\n編集系 electric-pair-mode 開き括弧を挿入すると自動で閉じ括弧を挿入してくれます。リージョンを選択して括弧を挿入するとリージョンを囲むように括弧を挿入してくれます。これ大事。挿入後のカーソルは開き/閉じのどちらを入力したかに依ります。まあ、想像付きますね。地味に鉤括弧にも対応。\nruby-modeはこの挙動を上書きしてるので殴り殺したくなります。\nsubword-mode 私はキャメルケースが嫌いという超個人的理由で使ってないのですが、キャメルケースがコーディング規約な言語を使う人には便利でしょう。キャメルケースの1こぶを1単語と見做します。例えば\u0026rdquo;SubWord\u0026rdquo;は\u0026rdquo;Sub\u0026rdquo; \u0026ldquo;Word\u0026rdquo;と認識されます。\n-!-SubWord  でM-f(forward-word)すると通常は SubWord-!- となりますがsubword-mode内だと Sub-!-Word となります。その他word系の操作が全部こぶ単位になります。\n因みにモードラインの表示が\u0026rdquo;, \u0026ldquo;と、微妙な感じです。\nsuperword-mode subword-modeの逆です。Lispの\u0026rdquo;this-is-a-symbol\u0026rdquo;といったシンボルが\u0026rdquo;this\u0026rdquo; \u0026ldquo;-is\u0026rdquo; \u0026ldquo;-a\u0026rdquo; \u0026ldquo;-symbol\u0026rdquo;と認識されていたのが\u0026rdquo;this-is-a-symbol\u0026rdquo;と認識されます。\n因みにモードラインの表示は \u0026ldquo;$^2$\u0026rdquo; です。\nC-x C-u(upcase-region) リージョンを選択した状態で使うとリージョンを大文字にしてくれます。 これを使ったTipsです。\nシチュエーションは全部大文字の単語(定数とかで良く出てくる)を入力したいが、Caps Lockは既にCtrlにしてあるので使えないって状態です。\n先ず、C-@します。そして目的の単語を小文字のまま入力します。そしてC-x C-uします。すると全て大文字になります。便利。C-x C-l(lowercase-region)でも同じこと出来ますが、使いたいシチュエーションは少ないでしょう。\n尚、このコマンドはデフォルトで無効になっているので普段使いするには一回使ってダイアログを出さないようにするかinit.elに\n(put \u0026#39;upcase-region \u0026#39;disabled nil) を追加しておく必要があります。\nM-- M-u(upcase-word) upcase-wordはカーソルの次の単語を大文字にしますが、負の前置引数を与えると直前の単語を大文字にしてくれます。ちょっと押し辛いですが一応覚えておきましょう。M-- M-l(capitalize-word)もそれなりに使えるかもしれません。\ncomplete系 icomplete-modeするとミニバッファでの入力時に補完候補が随時表示されますが、実はあの候補に色々操作出来るのです。\nM-p / M-n ヒストリを辿れます\nC-j 先頭の候補に決定します。\nC-, / C-. 候補を後/先に送ります。キーボードを見て\u0026lt; / \u0026gt;を押せば良いので簡単ですね。\nC-M-i 先頭の候補を補完します。続けてC-M-iすると順次次候補になります。\nC-r ヒストリを検索します。\nC-s ミニバッファ内を前方検索します。あまり需要なさそうですね。\nisearch isearchはカーソルをバッファに残したままミニバッファを編集するのでキーバインドが特殊です。\nC-s(isearch-repeat-forward) 検索文字列が空の状態でC-sすると前回の検索文字列で検索します。\nC-j(isearch-printing-char) RETが決定に使われてるので改行はC-jになります。\nC-w(isearch-yank-word-or-char) カーソル下の単語又は文字を検索文字列にします。連続して押すと範囲を広げます。\nC-M-w(isearch-del-char) 1文字削除します。DEL(isearch-delete-char)とは違って削除してもバッファのポイントは戻りません。\nC-M-y(isearch-yank-char) カーソル下の文字を検索文字列に足します。\nM-s C-e(isearch-yank-line) カーソルから行末までを検索文字列にします。\nM-s(isearch-toggle-)系 isearchには実は文字列検索だけでなく、さまざまな検索方法があります。 M-s _(isearch-toggle-symbol)、M-s c(isearch-toggle-case-fold)、M-s r(isearch-toggle-regexp)、M-s w(isearch-toggle-word)、あたりを覚えておくと良いでしょう。\nバッファ/ウィンドウ系 split-threshold Emacsはデフォルトの状態では何かしらのウィンドウを分割するアクション(e.g. list-buffers)でウィンドウを上下に分割します。しかしワイドディスプレイを使っていると左右に分割して欲しいものです。そこで、この設定です。\n(setq split-height-threshold nil) (setq split-width-threshold 100) この設定で、幅が100桁以上なら左右、100桁未満なら上下に分割するようになります。100という数字は私が試行錯誤して出した最適解です。split-height-thresholdとsplit-width-thresholdを同時に設定したら先にsplit-height-thresholdが判定されるようです。\nC-x 4(-other-window)系 ウィンドウを分割して隣のウィンドウに別のファイルを開きたい、あるいは既に分割してある隣のウィンドウに別のバッファを持ってきたいといったときに使うのがC-x 4(-other-window)系のコマンドです。C-x 4 C-f(find-file-other-window)、C-x 4 b(switch-to-buffer-other-window)、C-x 4 0(kill-buffer-and-window)あたりを覚えておけば良いでしょう。詳しくはC-x 4 C-hすると見れます。\n似たようなのに、C-x 5(-other-frame)系のコマンドがありますが、私はEmacsのフレームを2つ以上出したいという状況に遭遇したことがないので省略します。\nfind-alternate-file ほぼfind-fileと同じ挙動ですが、現在のバッファをkillしてから新たなファイルを開きます。あるファイルを開こうとして間違ったファイルを開いてしまったときに使います(バッファの内容が空なので間違ったことが直ぐ分かる)。地味に便利なのですがデフォルトでキーが割り当てられていません。C-x C-aあたりが妥当でしょうか。\nrectangle(矩形選択)系 最近機能が強化されてるrectangle系です。プリフィクスがC-x rと押し辛いのが難点ですが、使用頻度が高い訳ではないのでまあ妥当でしょう。\nregion-rectangleはカーソルとマークで成す長方形を範囲とします。\nab-!-cdefg hijklmn opqrs-¡-tu のとき、\ncde jkl qrs がregion-rectangleに入ります。\nしかしこれだと分り辛いものです。そこで、最近C-x SPCでregion-rectangleを視覚表示出来るようになりました。るびきちさんの本に載ってるsense-regionに近いです。\nC-x r k(kill-rectangle) / C-x r d(delete-rectangle) / C-x r M-w(copy-rectangle-as-kill) 名前のままですね。kill-rectangleやcopy-rectangle-as-killが保存するkill-ringは通常のkill-ringとは異なります。\nregion-rectangleを視覚表示した状態でC-wするとkill-rectangleになるようです(他のコマンドは未確認)\nC-x r y(yank-rectangle) kill-rectangleやcopy-rectangle-as-killが保存したものを吐きます。どのように挿入されるかというと、\nrectangleのkill-ringが\ncde jkl qrs で、バッファが\n-!-foo bar baz のとき、C-x r yすると\ncdefoo jklbar qrs-!-baz となります。\nC-x r t(string-rectangle) rectangle-regionを文字列で置換します。ちょっと実用的な例を出しましょうかね。\nバッファが\npic_-¡-list_first(pic_state *); pic_list_second(pic_state *); pic_list-!-_third(pic_state *); でC-x r t RET vectorすると\npic_vector_first(pic_state *); pic_vector_second(pic_state *); pic_vector_third(pic_state *); となります。最近プレビュー機能が入ったので入力しながらリアルタイムでバッファが書き換わります。最小設定主義のemacsにしては珍しい変更ですね。\n尚、幅0のregion-rectangleに使うとプリフィクスを付けられることも覚えておきましょう。\n-¡-This sentence is -!-a quotation にC-x r t RET \u0026gt;すると\n\u0026gt; This sentence is \u0026gt; a quotation. と出来ます。\nregister系 register系もC-x rのブリフィクスを持ちます。非常に高機能なのに押し辛く、rectangleと紛らわしいキーバインドなのは残念です。\nregisterの概念は分り辛いのですが、「何でも保存出来る箱」で、しかも「キー1つにつき箱一つ」です。viの名前付きバッファと似ていますが何でも保存出来る点で異なります。\nそれぞれの機能を見てちょっと自分で試してみて理解して下さい。\nC-x r SPC(point-to-register) レジスタにポイントを登録します。C-x r C-SPCでもC-x r C-@でも同じです。\nC-x r SPCすると\u0026rdquo;Point to Register: \u0026ldquo;とプロンプトが出るので、現在のポイントを登録させたいレジスタを選びます。レジスタを選ぶというのは好きなキーを押せばよいです。私は考えるのが面倒なのでaから順番に使っていってます。\nこれだけだと分かりにくいので次のコマンドも参考にして下さい。\nC-x r j(jump-to-register) point-to-registerでレジスタに登録したポイントに飛びます。例えばaレジスタにポイントを登録したならC-x r j RET aでそこに飛べます。最近、現在登録されてるレジスタ一覧が出るようになったので然程迷わないかと思います。\nC-x r x(copy-to-register) レジスタに選択範囲の文字列を登録します。C-x r sでも同じです。\nrectangleと同じプリフィクスを使っているがために非常に覚え辛いキーバインドになってしまっています。しかもkill-ringとの差別化がイマイチ分からないので需要なさそうですね。\nC-x r r(copy-rectangle-to-register) region-rectangleをレジスタに登録します。\nC-x r i(insert-register) レジスタに登録した文字列/rectangle/数字をバッファに挿入します。C-x r gでも同じです。\nポイントを挿入しようとすると数字が入るようです(ポイントは内部的には数字)。\nC-x r n(number-to-register) レジスタに数字を登録します。登録した数字はC-x r +(increment-regiser)で増やしたり(負の前置引数を与えれば減らすことも可能)insert-registerでバッファに挿入することも可能。キーボードマクロなんかで役に立つのかな？\nC-x r w(window-configuration-to-register) 現在のフレームのwindow-configuration(ウィンドウの分割や表示されるバッファ)をレジスタに登録します。復元はC-x r j(jump-to-register)です。\n同様の機能を提供するために数々のプラグインが作られてきましたが標準で提供されることになりました。\nこれと次のframeset-to-registerは最近入った機能だった気がします。\nC-x r f(frameset-to-register) frameset(フレームの数や位置、サイズ、そしてそれぞれのフレームのwindow-configuration)をレジスタに登録します。復元はC-x r j(jump-to-register)です。\n蛇足 キーは割り当てられてませんがキーボードマクロの保存/実行やレジスタにappend/prependするコマンドもあるようです。\n同じC-x rのプリフィクスの機能にブックマークがありますが、るびきちさんの本に載ってるので割愛します。\nvc(バージョン管理)系 詳しい使い方は多数の記事があると思うのでそちらに任せるとして、よく使うものを紹介します。尚、るびきちさんの本の頃からは大分進化してるのでvcに関しては参考にしない方が良いかと思います。例えばgit init相当をするコマンド(vc-create-repo)は追加されてます。その他mergeやpull/pushなども。\n各vcsの対応状況は\n ;; Supported version-control systems presently include CVS, RCS, GNU\n;; Arch, Subversion, Bzr, Git, Mercurial, Monotone and SCCS\n;; (or its free replacement, CSSC).\n とあります。かなり多いですね。というかこんなにvcsあったんですね。\n私が最近gitしか使ってないので他のvcsでどうなるかは分かりません。一応vc.el自体vcsの差異を吸収するものなのですが、vcs固有の挙動もあるのです。\nC-x v =(vc-diff) git diff \u0026lt;バッファのファイル\u0026gt;相当です。大体、しばらく作業してそろそろコミットするかーって時に使います。表示されるバッファはdiff-modeになっているのでdiffの部分でRETすると変更箇所にジャンプ出来ます。\nC-x v l(vc-print-log) / C-x v L(vc-root-log) C-x v l(vc-print-log) で現在ファイルの、 C-x v L(vc-root-log) でバージョン管理下全体のログ(コミットグラフ)を見れます。TABでログ間を移動出来たりRETでログを展開したりDでそのログのdiffを見たり色々なことが出来ます。diffを表示させたら勿論RETで変更箇所に飛べます。変更履歴を追うときは圧倒的に便利。\n私もそこまで深追いしてないのでlogバッファでの操作の調査は読者の課題とする。\nC-x v v(vc-next-action) vcの中で一番有名なコマンドでしょうから詳細は省きます。私が強調したいのはコミットログ書くときのlog-editモードです。地味に機能強化されてます。C-c C-d(log-edit-show-diff)でdiffを表示したりC-c C-e(vc-git-log-edit-toggle-amend)でamendにしたり出来ます。詳しくはC-c ?(log-edit-mode-help)して下さい。\nC-x v d(vc-dir) ディレクトリ単位での機能を使えます。というかファイル単位でない機能(つまりvcsの多くの機能)を使えます。最近はvcを使うときはこれがメインになってます。色々機能があるので\u0026lt;f1\u0026gt; b(describe-bindings)して確認して下さい。\nC-x v u(vc-revert) これは逆に使ってはいけないコマンドです。バッファのファイルのみをリバートする(git checkout -- \u0026lt;バッファのファイル\u0026gt;相当)と思いきや、git reset --hardするようです。no more被害者。\nview-mode かなりキーバインドが特殊ですが割と便利な機能です。ここで紹介したもの以外にもキーはバインドされてますが非自明なのは大体こんなもんでしょう。\nRET(View-scroll-line-forward) / y(View-scroll-line-backward) 上下に1行スクロールします。ありそうで他にない機能です。\n/(View-search-regexp-forward) / \\(View-search-regexp-backward) まさかのviバインド。ちゃんとn(View-search-last-regexp-forward)とp(View-search-last-regexp-backward)も用意されてます。\ns(isearch-forward) / r (isearch-backward) C-がなくなっただけですね。他にもC-がなくなっただけのコマンドはいっぱいありますが//\\との比較で出しました。\nm(point-to-register) / '(register-to-point) mでマークして'でジャンプです。\nやめる系 なぜか一杯あります。前提として、view-modeは別のファイルから「view-modeで(時に別ウィンドウで)ファイルを開く」系のコマンドで呼ばれることが多いというのがあります。\n   コマンド 説明     e(View-exit) view-modeを抜ける。   E(View-exit-and-edit) view-modeを抜けてバッファを編集出来るようにする。つまり、read-only-modeも抜ける。   c(View-leave) view-modeを抜けてバッファを切り替えるがバッファはkillしない。   C(View-kill-and-leave) view-modeを抜けてバッファをkillして以前のバッファに切り替る。   q(View-quit) view-modeを抜けてウィンドウ内の状態を元に戻し、フォーカスも戻す。大抵バッファをkillする。   Q(View-quit-all) view-modeを抜けてウィンドウ構成を元に戻す。大抵バッファをkillする。    うん。覚えられね。\ndired系 便利なのに情報が少ないdired系。私はUbuntuのUnityを捨ててStumpwmを使っているのでファイルエクスプローラは専らEmacsですからよく使います。以前のエントリ以外の便利機能を紹介します。\n因みに呆れるほどキーがバインドされてるのでここで紹介するのはほんの一部です。画像のサムネイル関連の機能なんかもあります。\n+(dired-create-directory) ディレクトリを作ります。\n((dired-hide-ditail-mode) 初期状態ではls -lっぽい内容が表示されてますがlsに変更出来ます。\nv(dired-view-file) ポイント下のファイルをview-modeで開きます。view-modeではqでバッファを閉じれるので、あるディレクトリ下のファイルを連続して読みたいときに便利です。\no(dired-find-file-other-window) 別ウィンドウでファイルを開きます。\nC-o(dired-display-file) 別ウィンドウでファイルを開きますが、フォーカスは移りません。\ndiredに限らず、ファイルへのリンクをリスト表示するバッファでは大抵vとoとC-oが使えます。\ni(dired-maybe-insert-subdir) バッファの下にポイント下のディレクトリの内容を追加します。ツリー表示にする機能はないようです。\n%(dired--regexp)系 % C(dired-do-copy-regexp)など色々あるのですがとりあえず使いそうなのは% g(dired-mark-files-containing-regexp)と% m(dired-mark-files-regexp)ですかね。\n拡張子でマークするコマンドがあった気がしたのですが見当りませんでした。\n検索/置換系 これも色々ある上にキーバインドが覚えづらいです。ポイント下又はマークしたファイル全てに操作を行います。キーを覚えるよりM-xで実行した方が速そうですね。\n   キー コマンド     Q dired-do-query-replace-regexp   M-s a C-s dired-do-isearch   M-s a C-M-s dired-do-isearch-regexp    eww (Emacs Web WOWer) elispで書かれたブラウザ(正確にはWOWerらしい)です。レンダリングエンジンにはかつてgnusで使われて今は別プロジェクトになったshr.el(Simple HTML Renderer)が使われています。HTMLの他に簡単なCSSも理解します。\nlibxsltなどのSGML解析系のライブラリを有効にしてビルドしないと使えないのでEmacsを野良ビルドする人は要注意です。\nM-x eww URL又はキーワードで検索します。検索エンンジンはeww-search-prefixで制御出来ます。\ngoogleで検索したかったら\n(setq-default eww-search-prefix \u0026#34;https://www.google.co.jp/search?q=\u0026#34;) です。\nキーバインド infoライクに設定されてます。そんなに多くないのですが、一部抜粋するとn(eww-next-url)、p(eww-previous-url)、l(eww-back-url)、r(eww-forward-url)、H(eww-list-histories)、\u0026amp;(eww-browse-with-external-browser)、b(eww-add-bookmark)、B(eww-list-bookmarks)、q(quit-window)です。\nn / pとl / rの違いは、l / rはヒストリを辿る機能、n / pはヘッダに\u0026lt;link rel=\u0026quot;Next/Prev\u0026quot; ...\u0026gt;が設定されているときにそれを辿ります。あまり馴染がないかもしれませんが広告料稼ぐためにページ分割しているサイトが多いので結構便利ですよ。\nnewsticker 最後に最近見付けたRSS/Atomリーダーの紹介です。\n先ず、こんな感じの設定をします。ニュースサイトは自分の好きなものを選んで下さい。\n(setq-default newsticker-url-list \u0026#39;((\u0026#34;産経\u0026#34; \u0026#34;http://sankei.jp.msn.com/rss/news/points.xml\u0026#34;) (\u0026#34;朝日-IT/Sci\u0026#34; \u0026#34;http://rss.asahi.com/rss/asahi/science.rdf\u0026#34;) (\u0026#34;技術評論社\u0026#34; \u0026#34;http://rss.rssad.jp/rss/gihyo/feed/rss2?rss\u0026#34;) (\u0026#34;Planet Lisp\u0026#34; \u0026#34;http://planet.lisp.org/rss20.xml\u0026#34;) (\u0026#34;Hacker News\u0026#34; \u0026#34;https://news.ycombinator.com/rss\u0026#34;))) (setq-default newsticker-url-list-defaults \u0026#39;((\u0026#34;LWN (Linux Weekly News)\u0026#34; \u0026#34;http://lwn.net/headlines/rss\u0026#34;))) (setq-default newsticker-retrieval-interval 0) (setq newsticker-html-renderer #\u0026#39;shr-render-region) で、M-x newsticker-show-newsでニュースを取ってきてくれます。\n3ペインの画面(treeview)になるかと思いますが、基本操作を覚えればC-x oで移動する必要はありません。\nf(newsticker-treeview-next-feed) / F(newsticker-treeview-prev-feed) ニュースサイト間を移動します。\nn(newsticker-treeview-next-item) / p(newsticker-treeview-prev-item) ニュース間を移動します。\nSPC(newsticker-treeview-next-page) ニュースのページを送ります。戻すキーは無いようです。\nv(newsticker-treeview-browse-url) 今開いているニュースをブラウザで開きます。RSSは概要しか送られてこないのでこの機能は必須ですね。\nq(newsticker-treeview-quit) 画面を閉じます。\n最後に いかがだったでしょうか。ちょっと長いので途中読み飛ばし気味だったかもしれませんが1つでも覚えていただけたら幸いです。\n因みに、このエントリを書き始めたのは8/13だったのですが、あまりに長く、途中合宿を挟んだりしたので公開は8/20になってしまいました。\n","categories":["Emacs","開発環境","IDE"],"category_urls":["/categories/emacs","/categories/%e9%96%8b%e7%99%ba%e7%92%b0%e5%a2%83","/categories/ide"],"date":"2014-08-13","title":"Emacs便利機能/Tips紹介","url":"https://KeenS.github.io/blog/2014/08/13/emacs-utility-functions/"},
  {"body":"本日2回目のκeenです。次はRuby-likeな文法でJavaが書けるMirah言語の0.1.3がリリースたのでこれを期にMirahの紹介をします。\nMirahとは？ 公式ページ。JRubyの開発者がJRubyのためにJavaを書くのが嫌になったという理由で作り始めた言語です。2008年にスタートだったかな？JRubyの開発の片手間に開発してるのでコミットペースはゆっくりです。\ngithubのREADMEから引用すると、\n Ruby-like シンタックス .classにコンパイルされる Javaと同じスピード ランタイムライブラリ必要なし  な言語です。私的には\n 型推論がある マクロがある 面倒な部分はコンパイラが補ってくれる  、Javaです。多くのJVM上の言語は独自言語+Java FFIって感じですが、Mirahは文法をRuby風にしただけで、吐かれるバイトコードはJavaコンパイラが吐くのものと等価です。\nサンプルコード 一番Javaっぽいコードを見せましょう。ファイル名はHelloWorld.mirahの他にhello_world.mirahでも構いません。\nclass HelloWorld def self.main(args:String[]):void System.out.println(\u0026#34;Hello World\u0026#34;) end end まあ、Javaですね。JavaのstaticメソッドとRubyのクラスメソッドが対応しています。これをMirahの機能を使って書き換えていきます。\n暗黙のクラス ファイル名からクラス名が推測出来るので省略することが出来ます。すなわち、トップレベルのメソッド定義は推測されたクラス内でのメソッド定義として扱われます。\ndef self.main(args:String[]):void System.out.println(\u0026#34;Hello World\u0026#34;) end これでも動きます。\n暗黙のmain トップレベルの式はmain内のものとして扱われます。\nSystem.out.println(\u0026#34;Hello World\u0026#34;) こうも書けることになります。ただし、argsにアクセス出来ないので複雑なことをやりたかったら大人しくself.mainを書きましょう。\nputsマクロ mirahには組込みでputsというマクロが定義されています。これはコンパイル時にSystem.out.printlnに展開されます。\nputs \u0026#34;Hello World\u0026#34; こう書けます。ここまでくるとRubyと同じコードになりますね。あ、()が省略可能なのは良いですよね。Ruby系の言語ではよくあることです。\nもうちょっとサンプル mirah/exmpleから面白いのを拾ってきます。だいたいRubyです。\nリテラル ほぼRubyです。つまり、[]が配列ではなくArrayListになってます。尚、自動でintがIntegerに変換されてます。 また、hashはHashMapです。\nstr = \u0026#39;non-interpolated string\u0026#39; str2 = \u0026#34;interpolated is better than #{str}\u0026#34; heredoc = \u0026lt;\u0026lt;EOS this is a here doc EOS int = 42 char = ?a float = 3.14159265358979323846264 regex = /\\d(cow)+\\w\\\\/ # in Java, this would be \u0026#34;\\\\\\\\d(cow)+\\\\\\\\w\\\\\\\\\\\\\\\\\u0026#34; regex2 = /interpolated #{regex}/ list = [1, 2, 3] list[2] = 4 array = byte[5] array[0] = byte(0) hash = { \u0026#34;one\u0026#34; =\u0026gt; 1, \u0026#34;two\u0026#34; =\u0026gt; 2 } hash[\u0026#34;three\u0026#34;] = 3 修飾import import java.util.HashMap as H って書けます\n型推論 Swingの例です。変数の型を書いてないことに注目して下さい。\nimport javax.swing.JFrame import javax.swing.JButton # FIXME blocks need to be inside a MethodDefinition, but main doesn\u0026#39;t # have one. def self.run frame = JFrame.new \u0026#34;Welcome to Mirah\u0026#34; frame.setSize 300, 300 frame.setVisible true button = JButton.new \u0026#34;Press me\u0026#34; frame.add button frame.show button.addActionListener do |event| JButton(event.getSource).setText \u0026#34;Mirah Rocks!\u0026#34; end end run 暗黙のInterface及び暗黙のabstractメソッド 先のSwingの例を良く見て下さい。この部分です。\nbutton.addActionListener do |event| JButton(event.getSource).setText \u0026#34;Mirah Rocks!\u0026#34; end Javaだと\nbutton.addactionlistener(new ActionListener(){ public void actionPerformed(ActionEvent event){ JButton(event.getSource).setText(\u0026#34;Mirah Rocks!\u0026#34;); } }); となっていたところが、\n 引数の型がインターフェースだったときはブロックでnew Class(){}と同じ働きになる abstractメソッドが一つのときはそれも省略出来る  というルールにより簡潔に書けます。これで引数の中に文が現れるという最悪の事態を回避出来ます。Java8のlambda式に近いのかな？Java8に詳しくなくてゴメンなさい。\n似たようなので、Threadも\nThread.new do # do something end.start と書けます。\nマクロによる既存クラスの拡張 マクロは展開後のASTがJavaとして有効であれば良いのでJavaでは出来ない芸当が可能です。\nシンプルだけど強力な例\n10.times{ puts \u0026#34;Hi\u0026#34;} intをtimesマクロで拡張してます。その他、eachなどの便利マクロやattr_accessor(getterとsetterを自動生成する)など色々あります。ユーザー定義のマクロで拡張も可能ですが、今シンプルに書けるシンタックスが議論中です。\nJavaとの互換性とか完成度とか まだ未実装機能はいっぱいあります。finalとかsynchronizedとか。あとスコープもRuby風にprivate以下で定義されたものはprivateですがメソッド/フィールド単位では制限出来ません1。ジェネリクスの構文もまだサポートされてません2のでジェネリクスの定義は不可能、使用も型推論で型を明示的に書かなくても良いときのみ可能です。インターフェースやアノテーションはあります。\nここにTODOがありますが、inner classやlambda(多分Java8のlambda式とは別もの)が弱いようです。\nでもまあ、Mirah自体Mirahでセルフホスティングされてますし一つ言語を作れる程度には機能は揃ってます。遊んでみる分には十分使えると思います。\nマクロの話 Mirahはオブジェクト指向で静的型付けの言語でマクロを実装してます。Lisper的には割と面白かったのでちょいと触れますね。\nまずは簡単な例から。\nmacro def puts(node) quote {System.out.println(` [node] `)} end Lisperなら\n macro defでdefmacro quote blockでquasiquote バックスラッシュで囲んでunquote  などが読み取れると思います。\n今のはASTは陽には出てこない簡単な例でしたが、次はちょっと飛躍しますよ？\nmacro def self.abstract(klass:ClassDefinition) anno = Annotation.new(@call.name.position, Constant.new(SimpleString.new(\u0026#39;org.mirah.jvm.types.Modifiers\u0026#39;)), [HashEntry.new(SimpleString.new(\u0026#39;flags\u0026#39;), Array.new([SimpleString.new(\u0026#39;ABSTRACT\u0026#39;)]))]) klass.annotations.add(anno) klass.setParent(nil) klass end  macroにも型がある。その型はASTの型。 というかClassDefinitionとかいう型がある ASTをいじるときにASTのNodeオブジェクトのメンバをゴニョゴニョするという手段がある  などが読み取れると思います。また、ClassDefinitionを受け取ってClassDefinitionを返しているのでmacro chainが可能ですね。\n次はASTを自分で組み立てる例です。\nmacro def self.attr_reader(hash:Hash) methods = NodeList.new i = 0 size = hash.size while i \u0026lt; size e = hash.get(i) i += 1 method = quote do def `e.key`:`e.value` #` @`e.key` end end methods.add(method) end methods end NodeListがprognみたいなものでその中にMethodDefinitionを突っ込んでいってますね。中々楽しい。\n余談:ところでgetterメソッド名がgetKeyじゃなくてkeyになってますよね。コンパイル後は変換してくれるのかなと思い、\n@foo = \u0026#34;a\u0026#34; attr_accessor :foo =\u0026gt; :String をコンパイル、ディスアセンブルしてみました。すると、fooとset_fooというメソッドが定義されてましたorz。Ruby的にはまあ良いんですがコンパイル後はJavaなのでそこはgetKey/setKeyにしてほしかったですね。もしかしたら今はシンボルをキャメルケースに変換出来ないのかもしれません\n閑話休題。また、呼び出し元の情報もとれます。これはStringの+マクロです。\nmacro def +(arg) quote { \u0026#34;#{`@call.target`}#{`arg`}\u0026#34; } end @callに呼び出し元の情報が入ってるのでそれを使って情報をとれます。\ngensymなんかもあります。これはintのtimesマクロです。\nmacro def times(block:Block) i = if block.arguments \u0026amp;\u0026amp; block.arguments.required_size() \u0026gt; 0 block.arguments.required(0).name.identifier else gensym end last = gensym quote { while `i` \u0026lt; `last` init { `i` = 0; `last` = `@call.target`} post { `i` = `i` + 1 } `block.body` end } end whileの中にあるinitとpostはRubyでいうBEGINとEND、JVM的にはforの実装のために使われているのでしょうか。\nまとめとか雑感とか 0.1.3で一番大きな変更はセルフホストされたことですね。今まではJRubyで書かれてたのでHello Worldのコンパイルに16秒とか掛かってました。今のmirahc.jarはかなり小さく、1MBちょっとしかありません。\n入手法はgithubから良いかんじにダウンロード出来るんじゃないですかね？（適当）\n古いバージョンにはMirahのコードと等価なJavaのソースを吐くオプションがありましたがコンパイラが変わってなくなりました。かつてheadiusはこの機能を使って吐いたコードをJRubyにコミットしたことがあるそうです。今新しいコンパイラが安定してきたのでそろそろ再実装されそうです。\nexampleですが一応私のコミットも入ってます。grep keen NOTICEってやってみて下さい。\nmirah-mode.elをちまちま書いてますが道程は通そうです。ブロックコメント(/* .. */)がネスト可能なのですが、正規表現だと/*/*を/*2つと*/1つと認識しちゃってつらいです。\n今回細かいところは省きましたがexampleとかあと公式ページとかgithubのwikiとか見て下さいね。\nある程度の完成度になってきてるのでみなさんも遊んでみて下さい。\n pull-reqは入ってるのですが、まだマージされてません [return] まだリテラルの議論が終わってないだけで、内部はジェネリクスに対応してるので近い内に入りそうな気はします。 [return]  ","categories":["Mirah","Java","Ruby"],"category_urls":["/categories/mirah","/categories/java","/categories/ruby"],"date":"2014-08-07","title":"Mirah 0.1.3がリリースされました","url":"https://KeenS.github.io/blog/2014/08/07/mirah-0-dot-1-3/"},
  {"body":"強化練中のκeenです。明日も朝早いのでこんな時間にエントリー書いてて寝坊しないか心配です。\nShibuya.XSS TT #5 がLINEのオフィスで行なわれてたので覗きに行ってきました。名前はXSSですが内容はセキュリティ全般でしたね。\nMozillaの脆弱性バグ報奨金制度にチャレンジした話だとか色々あったのですがやっぱセキュリティの話なのでオフレコな話題が多く、あまり書けることは無いです。 malaさんが飛び入りでさっきサイボウズの脆弱性を見付けたから話します、ってやろうとしてサイボウズの竹迫さんに止められてたり（結局Googleの未修正の脆弱性の話してました。データガンガン抜いててやばかった。）。\n話せる話題はblob URI SchemeとサニタイズとmXSSの話ですね。(俄知識なので誤謬があるかと思います。あまり信用しないで下さい)\nblob URI Scheme example.com/XXXXXX-XXXXXX-XXXXXX みたいなURLのことです。blobの名前の通りバイナリをデコードしたURLで、アップロードした画像の一時URLなんかに使われるそうです。似たようなのにdata URI Schemeとかjavascript URI Schemeとかがあるそうです。\nこれの扱われ方が他とはちょっと違うらしく、iframe内でこのURIでXSSをするとoriginが親コンテンツのものになるそうです。つまりiframe内からSame Origin Policy突破可能。その他にも面白い特徴があって要研究って言ってました。\nサニタイズとmXSS mutate base XSSだったかな？\nユーザーの入力をJS側でサニタイズしようとする時の話です。 一つ思い付くのはJSでHTMLパーザを書いて許可しないタグを検出する方法ですが、どうしてもブラウザのパーザと互換性を確保出来ない（ブラウザ毎の非互換性がある）ためそこが脆弱性になるそうです。\nそこでブラウザのパーザを呼び出すAPIがあるのでそれを使ってDOMを作り、タグを洗い出す方法が考えられます。ここまでは良いのですが、最後HTMLに追加するときに文字列化してinnerHTMLで書き込もうとするとmXSSの危険性があるそうです。具体的には特定の状況で\u0026amp;lt;や\u0026amp;gt;が\u0026lt;や\u0026gt;に変化してしまい、入力と出力でDOM構造が変わってしまうことがあるそうです。怖い。\nセキュリティ大変ですね。\n","categories":["Security","JavaScript"],"category_urls":["/categories/security","/categories/javascript"],"date":"2014-08-07","title":"Shibuya.XSS TT #5 に参加してきました","url":"https://KeenS.github.io/blog/2014/08/07/shibuya-dot-xss-tt-number-5-nican-jia-sitekimasita/"},
  {"body":"κeenです。先日のLisp Meet Upで紹介したCloud9の詳解でも書きます。まあ、そんなに詳しくないんですけどね。\nCloud9について 先日のスライドを見てない方はまず見て下さい。\nCloud 9の紹介 | κeenのHappy Hacκing Blog\n公式の詳解ムービー(en)もあります。まあ、一般的なIDEの機能は一通り揃ってるようです。git連携とかも。 CloudNine Ide - YouTube\nスライドでバックエンドは一人一つDockerが与えられるって書きましたが自分のVMをバックエンドにも出来るようです。\n省略しましたが他のユーザーとの連携機能も多数あって、チャットだとかワークスペースの共有だとかソーシャルコーディング関連も多数機能があります。全社導入の折には役立つ機能なんじゃないでしょうか。\nローカルファイルをアップロードしたり逆にローカルにダウンロードとかも出来るようです。\n尚、IDE本体はACEという名前でオープンソースで開発されてるのでプラグインとかのドキュメントはそっちもあたると良いようです。\nCloud9事始め スクショとかは適当にスライドを参照して下さい(手抜き)\nアカウントを作る c9.ioにアクセスしてGithubかBitbucketのアカウントでログイン出来ます(以後、Githubでログインしたものとします。Bitbucketの方は適宜読み替えて下さい)。Cloud9で書いたコードをHerokuやらなんやらに直接上げるつもりなら普通にCloud9アカウント作っても良いと思いますが、多くの場合どちらかとの連携を使うと思うので素直にGithubでログインしましょう。\nログインしたらダッシュボードに飛ばされます。demo-projectと自分のGithubのプロジェクトがサイドバーにある筈です。\n細かな設定 demo-projectでも開きましょうか。demo-projectを選択してstart editingです。\nIDEというかEditorの設定が出てくる筈です(多分)。キーバインディングとかタブ幅とか設定しましょう。そして、C-hでbackward-delete-char出来ないと死んでしまう方のための設定はこちらです。Preferencesのkeybindingsのedit your keymap fileからkeymap fileに飛んで、\n[ {\u0026#34;command\u0026#34;: \u0026#34;backspace\u0026#34;, \u0026#34;keys\u0026#34;:[\u0026#34;Ctrl-H\u0026#34;, \u0026#34;Backspace\u0026#34;]}, {\u0026#34;command\u0026#34;: \u0026#34;replace\u0026#34;, \u0026#34;keys\u0026#34;:[\u0026#34;Alt-Shift-5\u0026#34;]} ] と編集、保存しましょう。どうも、キーにコマンドを割り当てるのではなく、コマンドにキーを割り当ててる(?)っぽいのでCtrl-Hを持ってるreplaceを別のキーにしないと動かないようでした。尚、これはファイルをいじらなくてもsearch keybindingsのところから目的のコマンドを捜して、keystrokeのところをクリックして、割り当てたいキーストロークをすれば割り当て出来るようです。その際、自分のkeymap fileも対応して書き変わります。\nCommon Lispのセットアップ 処理系のインストールはいくつか方法があります。\n apt-getで入れる バイナリを落してくる CIMを使う  のいずれかの方法で処理系を入れて下さい。apt-getで入れる場合はかなり古いバージョンが入ります。CIMで入れる場合はsudo apt-get install timeしておかないとSBCLのビルドが出来ませんでした。他の処理系は確認してないです。どの処理系でも良いんですがとりあえずSBCLを入れたってことで話進めますね。私がそれしか確認してないので。\nまた、便利のためrlwrapを入れましょう。sudo apt-get install rlwrapです。\nそこまでいったらrun scriptを作りましょう。上のメニューバーから[Run]\u0026gt;[Run With]\u0026gt;[New Runner]と進みます。で、run scriptの内容はどの方法で処理系を入れたかに依るのですが、\n1の場合\n{ \u0026#34;cmd\u0026#34; : [\u0026#34;sudo\u0026#34;, \u0026#34;rlwrap\u0026#34;, \u0026#34;sbcl\u0026#34;, \u0026#34;--load\u0026#34;, \u0026#34;$file\u0026#34;, \u0026#34;$args\u0026#34;], \u0026#34;info\u0026#34; : \u0026#34;Started SBCL :: $project_path$file_name\u0026#34;, \u0026#34;env\u0026#34; : {}, \u0026#34;selector\u0026#34; : \u0026#34;source.ext\u0026#34; } だそうです(引用元)。sudoがついてるのはWEBアプリの場合0.0.0.0で待つためにroot権限が必要だからかな？\nこれは実行した後でREPLに入ってデバッガとか扱う感じの設定ですね。\n単に実行したいだけののきは--loadの部分を--scriptに変えれば良さそうです(未確認)\n2の場合も同じ設定でいけそうな気がします。PATHぐらい必要かな?(未確認)\n3の場合\n{ \u0026#34;cmd\u0026#34; : [\u0026#34;sudo\u0026#34;, \u0026#34;cl\u0026#34;, \u0026#34;$file\u0026#34;, \u0026#34;$args\u0026#34;], \u0026#34;info\u0026#34; : \u0026#34;Started cl :: $project_path$file_name\u0026#34;, \u0026#34;env\u0026#34; : {\u0026#34;CIM_HOME\u0026#34;:\u0026#34;$HOME/.cim\u0026#34;,\u0026#34;PATH\u0026#34;: \u0026#34;$CIM_HOME/bin:$PATH\u0026#34;, \u0026#34;LISP_IMPL\u0026#34;: \u0026#34;sbcl\u0026#34;}, \u0026#34;selector\u0026#34; : \u0026#34;source.ext\u0026#34; } です。本来CIMは$CIM_HOME/init.*を呼ばないと動かないのですが、ショートカットする環境変数を設定することで無理矢理動かしてます。Cloud9のinitスクリプト(jsファイル)があるようなのでそこでCIMをinitしておけば無理せずとも出来そうですがあまり深く踏み込んでないです。\n尚、この設定は実行即終了のものです。実行してREPLに入りたい場合は\u0026quot;cmd\u0026quot;を[\u0026quot;cl\u0026quot;,\u0026quot;-rf\u0026quot;, \u0026quot;$file\u0026quot;, \u0026quot;$args\u0026quot;]にすると出来ます。\n動かしてみる 上記のrun scriptを設定、保存したらメニューバーから[File]\u0026gt;[New File]と進み、新しいファイルを作ります。\n一番簡単に\n(write-line \u0026#34;Hello Cloud9\u0026#34;) とでも書きましょうか。そして[\u0026gt;Run]してちょいと待つと実行出来る筈です。動かなかったら手動で[Run]\u0026gt;[Run With]\u0026gt;[My Runner]とかしてみましょう。ここまで来ればセットアップ完了です。\n今後の課題というか要調査というか シンタックスハイライト Lisp Meet Upでも喋りましたがハイライトが最悪です。ユーザー定義ハイライターも(少くともACEレベルでは)出来そうなのでどうにかする必要があります。\nインデント Lispのインデントはタブn個とかで済むようなものじゃなくてどのオペレータの中にいるかに依って変わります。その辺どうにかなって欲しいですね。 もしかしたらClojureは上手くいってるかもしれないのでそこからインポートしてくれると嬉しいですね。\nswankインターフェース initスクリプトがあるって事はもしかしたらIDEもプログラマブルなのかもしれないのでswankインターフェースを作れるかもしれません。\nCIMインターフェース initスクリプトがあるって事は(ry。最終目標はメニューバーからどの処理系を使うか選択可能とかで。\nまとめ  Cloud9を紹介した Common Lispのセットアップ方法を示した 誰か諸問題解決して下さい ","categories":["Lisp","Common Lisp","IDE","開発環境","Cloud9","CIM"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/ide","/categories/%e9%96%8b%e7%99%ba%e7%92%b0%e5%a2%83","/categories/cloud9","/categories/cim"],"date":"2014-08-02","title":"Cloud9の紹介とLispのセットアップ","url":"https://KeenS.github.io/blog/2014/08/02/introduction-to-cloud9/"},
  {"body":"κeenです毎月恒例のLisp Meet Up presented by Shibuya.lispでLTしてきたのでレポートです。\n今回は募集20に対して参加登録20、参加18、LT4本と集りの良い会でした。\n自己紹介ではほぼCLの人ばっかりでした。珍しいところ（？）では数理システムの方が居たり会場を提供して下さってるサイバーエージェントの方が覗きにきてたり。\nLT1本目はTOYOZUMIさんから連作の一つのCommon Lisp最適化発展。画像のエッジ検出をするときの関数の最適化の話でした。カーネルを渡すだけで最適なコードを生成するそうです。コーナーケースのif式をループの外に追い出してたりと半分成程、あとはよく分かんない話してるなーって。\n最終的にはevalを使ってるらしく、本当に速度出るの？って気になりましたが本人もやってみたところ速くなってビックリだったそうです。\nスライドはこちら。\n  Common lisp最適化発展  from Toyozumi Kouichi \n動画は今回から私が担当なので処理が終ったらリンク張ります。\n次はTakagiさんよりcl-cudaについて。話聞く前は「どうせC APIをCFFIで叩いただけだろ(ホジ」って思ってましたがさすがにGPGPUはそんなに簡単じゃなかったようです。 cl-cudaはLispのAPIを叩いたらCUDA向けのCコードを吐いてCUDA専用のコンパイラ通してモジュールとして動的に読み込んで、ってやってくれるそうです。すごい。 完成度も、CUDAを研究に使ってたchikuさんによると普通使う分にはほぼ困らなくて、あとは構造体のサポートがあれば良いかも程度だそうです。すごい。\nスライドはまだ見付けてないです。\n3番目は私から、WebブラウザベースのIDE、Cloud9の紹介とLispの対応状況について。 スライドはこのブログに載せてますが、こちら\nCloud 9の紹介 | κeenのHappy Hacκing Blog\nもうちょっと説明が欲しそうな雰囲気だったので別記事立てますね。@potix2さんが社内チャットに流したところなり反応が良かったようなので普通にIDEとして優れてるんじゃないでしょうか。\n最後はかにたん(@kazh98)から床下からLispが出てきた話。うん。本当に床下からLispが出てきた話でした。かにたんの研究室すごいですね。みなさんの家の床下にもLispがあるかもしれませんよm9っ。\n最後の最後にかにたんの研究室から出てきたLispについてTOYOZUMIさんがモニタをスクリーンに映しつつみんなで色々議論。なんかWEBのマニュアルがポルトガル語で書かれてたのでポルトガル語喋れる人捜したけど居なかったり。次回、床下Lispを動かしてみようってなりました。\nそこでもう閉場の時間だったので懇親会へ。11名が参加。\n私とかにたんとpotix2さんがschemeの実装の話してたり@mhkojiさんがhunchentootがありえないくらい遅いって話してたり色々でしたね。 CIMの話も出てました。実用上Windowsサポートは外せないってことで@snmstsさんがCでCIMを書き直してるだとか@nitro_idiotさんがshellyでCIMを使うにあたってCIM側でコアのマネジメントして欲しいって言ってただとか。\nC CIMは面白そうですね。ビルドしなきゃいけないから手軽さの問題が…とかlibcurlに依存するとLinuxが…とか言ってたら「ディストリのパッケージシステムに乗せてしまえば問題無い」と一刀両断。その発想はなかった。むしろパッケージシステムに入った方が手軽。\n今からCloud9の記事とCIMのコアマネジメント頑張りますね。\n","categories":["Lisp","Common Lisp","Lisp Meet Up"],"category_urls":["/categories/lisp","/categories/common-lisp","/categories/lisp-meet-up"],"date":"2014-07-30","title":"Lisp Meet Up #19でLTしてきました","url":"https://KeenS.github.io/blog/2014/07/30/lisp-meet-up-number-19/"},
  {"body":"# Cloud 9の紹介 Lisp Meet Up #19 presented by Shibuya.lisp κeen(@blackenedgold) ## 自己紹介 + κeen + 東大数学科の4年生 + ソーシャルアカウントは上のアイコン達から。 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます ## Lispがあまり使われない原因  認知度が低い 開発環境構築の難易度高い  ## Cloud 9について + WEBベースのIDEサービス + 40以上の言語に対応（らしい） + この間正式リリース + 1アカウント毎に1Docker環境与えられる + IDEはオープンソース + よく分かってない ## こんなん ## デモ ## 良いところ + 難易度低い + Lisp環境動く + Githubとの連携 + どこからでも同じ環境にアクセス + キーバインドはうれしい各宗教対応の {Mac, Windows}x{Default, Emacs, Vim, Sublime} ## 微妙なところ + シンタックスハイライト微妙 （せめてキーワード引数はどうにか） + 補完微妙 + インデント微妙 + swank使いたい 以上 何か質問あればどうぞ   ","categories":["Lisp Meet Up","Lisp","IDE","Editor","開発環境"],"category_urls":["/categories/lisp-meet-up","/categories/lisp","/categories/ide","/categories/editor","/categories/%e9%96%8b%e7%99%ba%e7%92%b0%e5%a2%83"],"date":"2014-07-29","title":"Cloud 9の紹介","url":"https://KeenS.github.io/slide/cloud-9/"},
  {"body":"# (S式で書く(altJS)達) κeen(@blackenedgold) 天下一altJS武闘会(#tenka1altJS) @渋谷プライムプラザ四階 ## 自己紹介 + κeen + 東大数学科の4年生 + Twit : @blackenedgold + Github : KeenS + Blog : [κeenのHappy Hacκing Blog](http://KeenS.github.io/) + Shibuya.lispにいます。(2014-06〜運営になりました) + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます ## お品書き - (ボツ) Shen.js - (ボツ) Embedable Common Lisp with Emscripten - (ボツ) Picrin with Emscripten - (ボツ) オレオレaltJSの作り方の話 - ParenScript ## Shen.js Shenの公式ページより + パターンマッチ + λ計算ベース + マクロ + 遅延評価も可能 + 静的型検査 + 関数的なPrologの統合 + ビルトインコンパイラコンパイラ これのJS実装もある。 ## 例 ```lisp (define factorial 0 - 1 X - (* X (factorial (- X 1)))) ``` そもそもaltJSじゃない… ボツ ## ECL with Emscripten + ANSI Common Lisp準拠のCommon Lisp処理系 + LispをコンパイルしてCを吐く + Emscriptenでコンパイルすれば… `#include ` が悪さをしてコンパイル出来ない ボツ ## picrin + R7RS small準拠を目指すScheme処理系 + R7RS準拠の中では唯一Emscriptenで コンパイル出来るらしい + SDLもEmscriptenで動くらしいから 組み合わせればウハウハじゃね？ コンパイル出来ない… ( `va_args` は64bit x Clang3.3では コンパイル出来ないとか言われる。回避策も効かない) ボツ ## オレオレaltJSの作り方の話 escodegenを使う ```javascript { type: 'BinaryExpression', operator: '+', left: { type: 'Literal', value: 40 }, right: { type: 'Literal', value: 2 } } →40 + 2 ``` オレオレaltJS(S式) ↓ read リスト ↓ 変換 (find-file \"~/Lisp/translate.lisp\") リスト ↓ cl-json JSON ↓ escodegen JS escodegenのドキュメントがあんまりない… ボツ ## ParenScript + Common Lisp製 + Weblocks(WAF)に採用されるなどの実績/伝統 + Common LispのサブセットをJSにコンパイル + 実際はCommon Lispのマクロなので Common Lispに組み込んで使える + ランタイムライブラリは必要ない + Lispを無理矢理変換するというより LispっぽくJSを書ける感じ ### 例 ~/Lisp/parenscript.lisp + `(@ obj property)` でプロパティ参照 + `(chain obj function/property)` でメソッドチェーン など 以上   ","categories":["Lisp","altJS"],"category_urls":["/categories/lisp","/categories/altjs"],"date":"2014-07-13","title":"(S式で書く(altJS)達)","url":"https://KeenS.github.io/slide/sshi-deshu-kualtjs/"},
  {"body":"κeenです。書く書くいってた近況です。思ったよりあります。\n5月 関数型言語LT大会でLTしてきた みんなすごいH本を読み終わったくらいの実力の人達かなって思ってゆるめに準備していったらプロばっかで爆死しました。\n 発表スライド    (define)なしで再帰関数を定義する  from blackenedgold \n togetter  因みにここで初めて@wasabiz氏と面会しました。\npicrinにコミットを始める wasabiz氏に会ってからC言語の勉強がてらpicrinのソースでも読んでみるかってなって紆余曲折あってコミットしはじめました。\n主にはchibi scheme のテストケースのインポートとそれによって判明したバグフィクスあたりですね。あとは最近ようやくGMPとMPFR のポートが動いたのでプルリク投げました。今は山葵寿司からレビューを受けて直す作業ですね。\nLisp Meet Up #17に参加した Scheme回なのに人も発表も多かったので私はLTは控えました。実際時間ギリギリまでLTやってましたし。レポートは公式ページに上ってます。\n処理系の話が複数聞けたのは有益でしたね。\n6月 Shibuya.lispの運営になった 毎回参加してたら声かかりました。動画周りの担当です。頑張ります。\n天下一altJS武闘大会でLTしてきた 今回は#functionalLTで爆死した反省からLispを前面に押し出しました。発表もEmacs上で行なったり。その結果「最高に怖い」なんて言われてたのでまあ、成功だったんじゃないですかね。\n 発表資料スライド スライドをreveal.jsに変換したもの togetter  因みにLisp Meet Up #18はサークルの用事で逃しました\n7月 進捗ダメです。このブログにスライドページつけたりしました。reveal.jsです。\nいちおうOctopressのプラグイン的な感じなってはいるんですが、レイアウトやインクルードファイルも追加してて面倒なので公開してません。このブログのテーマ(cleanpress)以外で動くかも分かりませんし。\n","categories":["番外編"],"category_urls":["/categories/%e7%95%aa%e5%a4%96%e7%b7%a8"],"date":"2014-07-13","title":"近況","url":"https://KeenS.github.io/blog/2014/07/13/jin-kuang/"},
  {"body":"# 言葉遣いの時代変遷を追う 理学部数学科4年 金 舜琳 （きん すんりん） ## 概要 古いものから新しいものまであるリソースから単語を抽出し、使用頻度から単語の時代変遷を追う ## 手法 ## step1 青空か新聞から単語抽出抽出を行なう * 名詞、形容詞、語尾などが候補 * 青空は多様性がある/話し言葉もとれるが古いのしかない？ * 新聞は均質だからサンプル調査に向いてる？ ## step2  年代別に使用頻度上位数十〜百ぐらいを使用頻度順まとめてみる ## step3  似たような意味の単語で順位の入れ替わりが見受けられたら詳細に追ってみる とりあえず手動を考えている。発展課題的にプログラムでやっても良いかもしれない ##step4  変遷の背景を考えてみる 戦前/戦後とか分りやすいものとかなんとか   ","categories":["言語処理"],"category_urls":["/categories/%e8%a8%80%e8%aa%9e%e5%87%a6%e7%90%86"],"date":"2014-07-09","title":"言葉遣いの時代変遷を追う","url":"https://KeenS.github.io/slide/nlp/"},
  {"body":"ご不沙汰しております、κeenです。先日（と言ってもしばらく前）、安いHDDを買ってきてFreeBSDでも入れて遊ぼうかとしていました。\nそうするとインストールは正常に終わるのにリブートするとブートローダが見付からないとか怒られます。おかしいな〜と思って元のHDDに付け替えてインストールメディアをごちゃごちゃしてまたHDDを付け替えてインストールしてを10回くらい繰り返したでしょうか。\nはい、挿さってるHDD勘違いして元のHDDにFreeBSD焼いちゃいました。パーティションテーブルとかHDDの先頭にあったWindowsのパーティションとか全滅です。しかもまだFreeBSD起動しない。どうするよこれ。\nUSBに焼いてたArchがあったのでどうにかUbuntuを落してきてOS自体は復旧出来ました。因みにFreeBSDが起動しなかった理由はハードウェアがBSDだとかGPTだとかのパーティションテーブルに対応してなかったのが原因っぽいです。尚、LinuxもBSDのパーティションテーブルを理解しないので一旦ddとかで強制的にパーティションテーブルを上書きしないと正常にインストール出来ませんでした。\nで、ですよ。問題は飛んだデータです。Windowsの方はどうでも良くてUbuntuの方もほとんどの重要なソースコードはgithubやgitbreakで管理してたので問題無くて、重要でないソースコードは仕方無いとして、LTの資料はまあ、SlideShareにあるし良いとして、KVMイメージはそんなに育ててなかったのでまた作り直すことにして、その他のデータはDropBoxに逃がしてて、残り、cl21-datacollectionsとこのブログのソースはgitで管理してなかったので消えてしまいました。\ncl21-datacollectionsは書き直すより他ないので図書館でアルゴリズムイントロダクションを借りてきました。まあ、そのうち出現すると思います。Lisp Meet UpでTOYOZUMIさんにそそのかされたCSB+木も実装してみるつもりです。\nブログの方はソースが無いと流石につらいので掘り起こしたデータの受け皿に新たに500GのHDDと外付け用のカバーを買ってきて\ntest-diskやphotorecといったパーティション、データ復旧ツールで復旧を試みました。\nパーティション再認識ツールのtest-diskは全然駄目で、わずかに/を認識するだけでその下のファイル情報は全く読み出せませんでした。\nしゃあないのでデータ復旧ツールのphotorecを一晩回してみると…800万くらいのファイルが掘り起こされました。因みにファイル名は機械的につけられたものです。\nザーっと眺めてみるとほとんどブラウザキャッシュの残骸ですね。因みに拡張子はすっげー適当につけられてるのでせいぜいバイナリかテキストかを見分けられる程度でした。\n流石に人力で捜すのは無理なのでOctopress用のマークダウンを拾ってくるスクリプト書いてまた一晩回してみたものの、集まったのは何故かRubiniusのブログばかりでこのブログのデータはゼロ。どうしようもなく、githubに上がってるHTMLから復旧することにしました。\nNokogiri使ってHTMLのタグをちまちまMarkdownに直すスクリプト書いてる途中で「これ、他にもやってる人いるんじゃね？」という思いが。\n調べてみると、ありました。Reverse Markdownというそうです。ここまでくればあとはNokogiri使ってメタデータとメインの部分抜き出してくるだけなので楽勝ですね。まあ、 {% や#をスケープするなどの作業もあるのですが。#をエスケープしなきゃいけないのはreverse_markdownのバグっぽそうですね。\n画像はディレクトリごとコピーし、Sassはcleanpressを再度インストール、その他自分で手を加えた部分はこのブログに残してあったのでそこを参照しました。\nブログ更新出来なかった間になにしてたかは別記事にしますね\n","categories":["備忘録"],"category_urls":["/categories/%e5%82%99%e5%bf%98%e9%8c%b2"],"date":"2014-06-12","title":"パーティションテーブルとか色々吹っ飛ばした話","url":"https://KeenS.github.io/blog/2014/06/12/partision-table/"},
  {"body":"κeenです。年度末/年度始めで色々あり、しばらく更新できてませんでしたが Lisp Meet Up Presented by Shibuya.lisp #16に参加してきたのでレポートです。\n最近はLisp Meet Upも盛況で毎回ほぼ満席ですね。今回も満席でした。というか立ち見出てました。\n自己紹介では初参加の方が多くてCLerが多い印象でした。昔研究とかでCL使ってて久し振りに、とか。私個人的にはTwitterでフォローしてる方々とお会い出来て楽しかったです。\nLTは私とTOYOZUMIさんが告知してました。しかしTOYOZUMIさんは当日体調が悪くて欠席したので私と飛び入りのchikuさんで計2件のLTがありました。TOYOZUMIさんは何回かに分けて発表するうちの1回だったので次回LTしていただけるかと思います。\n私のやつは↓です。時間ギリギリで作ったのであんまりいじめないで下さい。因みにまだソースはgithubに上げてないです（後述）\n CL21で色々なデータ構造を実装してみようとした from blackenedgold\n会場からはCL21作者のにとりさんから「abstract-sequenceは最低限実装しなきゃいけないメソッドは少ない」との指摘がありましたがqueueとして機能するために色々頑張ったのです。\nabstract-setとかは欲しいですねとの声もありました。issueに上げておきますかな\nまた、chikuさんからheapの実装について色々と指摘があり、 Introduction to Algorithmsという本を紹介されました。とりあえず大学の図書館から借りてきたのでそれを読んだらcl21-data-collectionsに手を加えてgithubに上げます。\n次はchikuさんから chiku-utilsというオレオレライブラリの紹介がありました。スライドは見付け次第貼りますね。結構便利そうな関数やマクロがあったので一度見てみると良いかもしれません。\nその後は休憩からのぐだぐだ時間でした。chikuさんの発表の中で出てきたkeyminという関数について会場から一般的にはargminと言うとの指摘があり、その場でかにたんがargminの定義の数式を書いたことから私とかにたんとラジカルこうじさんでマスハラをしあってました。というか主にかにたんがマスハラしてました。Lispの話はあまりしませんでしたね… あとは私がゼミで パタヘネを読んでることからパタヘネってC言語の入門書だよねとかの会話とか。StumpWMについてもちょっと話したかな？\nそうだ。次回のScheme回は Sagittariusの作者のKeiさんが次回LTする気満々とのことで話題に上がってました。それに picrinの作者のわざびず君も来るかもとかですしTOYOZUMIさんの連作もありますし次回は長くなるか2回に分けるかになるかもしれません。\nその後の懇親会は9人が参加でしたがアルコールを飲む方はあまりいませんでしたね。飲んでたのは3~4人かな?多くの方が普通にお酒に弱いだとかバイクで来てるだとか次の日仕事があるとかですね。もう普通に食事でも良いのでは。私のいたテーブルでの会話は佐野さんがLispの本をめっちゃ持ってるだとかでしたね。実践Common Lispを訳者ということを割り引いても多いくらい持ってるそうです。CLtL2とかもめっちゃ持ってるそうです。謎ですね。\n今回のまとめ\n かにたんをホワイトボードに近付けてはいけない  最後になりますがイベント管理や会場手配など運営の方々ありがとう御座いまいした。\n","categories":["Common Lisp","Lisp","Lisp Meet Up"],"category_urls":["/categories/common-lisp","/categories/lisp","/categories/lisp-meet-up"],"date":"2014-04-25","title":"Lisp Meet Up #16 でLTしてきました。","url":"https://KeenS.github.io/blog/2014/04/25/lisp-meet-up-number-16/"},
  {"body":"どうも、κeenです。Rubyをアップグレードしようとしたらrvmが動かなくて、あれ？ってなったら私がecho -\u0026gt; echoとかいう謎のsymlinkを作ってたせいでした。このブログはOctopressで作ってるのでその間更新遅れました。\nさて、毎月恒例 Lisp Meet Up Presented by Shibuya.lisp #14でLTしてきたので報告です。今回は「Real World OCamlを読んだ感想」というタイトルです。\nまあ、感想とは言っても内容を軽く紹介したあとにLispにインポートしてみたという内容です。\n今回はいつも以上にスライドが説明不足なのでどうにか頑張ってUstreamを探して下さい\n Real World OCamlを読んでLispと協調してみた from blackenedgold\n会場からはquicksortの例がメモリ使用量的にquicksortとは言えないとか怒られました。あとはappendが演算子@で書けちゃうとコスト高いのにみんな頻繁に使っちゃうんじゃないかとかのツッコミもありました。\nMeet Up自体は自己紹介から始まりました初めての参加の方が14人中3人だったかな？もっと増えると嬉しいですね。京都から来た博士過程の方とか「ハッカーと画家」を読んでLispに興味を持った方とかが居ました。\nで、私のLTは上の通り。前述の通りUstreamでも流されてます。\n次はかにたん(@kazh98)さんから。かにたんここ2ヶ月くらいMeet Upで見掛けないなと思ってたら数学の論文に”Gauche”って文字列を入れる仕事をしてたようです。LTはRacketの新バージョンの機能FFIを使って線形代数ライブラリのバインディングを作る話でした。ジョーク飛しながら軽快に喋ってて楽しかったです。スライドはこちら。\n すべてをRacketに取り込もう！ ~Racket FFI と Package システムの使い方~ from Kazuhiro Hishinuma\nそのあとは休憩からのぐだぐだタイムで私はCommon Lisperで CL21のlambdaの略称を考えてたりしました。私は^良いと思うんですけど英字キーボードだとS-6なので押しにくいそうです。fnはfunctionの略称っぽくてダメという話。functionはCommon Lispでは既に別の意味がありますからね。\n懇親会では私含めて就活生が二人居るので就活の話になりましたがLisperってまともな就活してないんですね…\n大学中退してバイト先に就職した、友達の始めたベンチャーに参加してから今の職場に転職した、就活せずにふらふらしてたらShibuya.lispでLispの求人があったからそこに行った…。\nそういえばまた隣がにとりさんだったので最近何やってますかと訊いたらUtopianに向けて着々と準備進めてますとの返事をいただきました。まだ計画あったんですねと返すと\n 昨日「Utopianってまだ計画あったんですね」って言われたけど、3年前からClack、Caveman、ningle、CL-DBI、SxQL、Caveman2、Integralってずっとリリースし続けてるのは全部Utopianの為ですよ\n— 深町英太郎 (fukamachi) (@nitro_idiot) 2014, 2月 27\n とのこと。私もUtopianの下地を作るためにRubyにあってLispにないものを色々考えてたので色々話してたらCL21のコミット権もらっちゃいました。私はライブラリ(DateTimeとかQueueなどのデータ構造とか)を整備したいのですがそれらは0.2で追加される予定だそうなので今はissue潰しですかね。\nまあ、そんなところです。そういえばClojureの会社に潜入したといういちせさん(＠ichisemasashi)にどんな感じか訊くの忘れてましたね…まあ、次回もいらっしゃるでしょうから次回訊けば良いですかね。\n","categories":["Common Lisp","Lisp","Lisp Meet Up","OCaml"],"category_urls":["/categories/common-lisp","/categories/lisp","/categories/lisp-meet-up","/categories/ocaml"],"date":"2014-02-27","title":"Lisp Meet Up #14でLTしてきました","url":"https://KeenS.github.io/blog/2014/02/27/lisp-meet-up-number-14/"},
  {"body":"小ネタです。ブログに数式を埋め込むときの話。\nMathJaxはHTMLに$\\LaTeX$の式を埋め込んでJavaScriptでMathMLに変換するプロジェクトみたいです。\nOctopressで使うには(ocotpressroot)/source/_includes/custom/head.htmlに\n 1 2 3 4 5 6 7  \u0026lt;script type=\"text/x-mathjax-config\"\u0026gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], [\"\\\\(\",\"\\\\)\"]] } }); \u0026lt;/script\u0026gt; \u0026lt;script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML\"\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;meta http-equiv=\"X-UA-Compatible\" CONTENT=\"IE=EmulateIE7\" /\u0026gt;  を追加するだけです。\n数式を埋め込むには、上の設定だと$数式$又は\\\\\\(数式\\\\\\)でインライン、\n 1 2 3  \\\\\\[ 数式 \\\\\\]  で別行立ての数式が書けます。markdownとコンフリクトするのでバックスラッシュのエスケープ大変ですね…。\\begin{eqnarray*}\\end{eqnarray*}は無理なのかなあ\nインライン\\(e^{i\\pi} = -1\\)\n別行\\\\[\\lim_{n \\to \\infty} P(Z=l) = e^{–\\lambda} \\frac{ \\lambda ^l}{l!}\\]\n","categories":["MathJax","Octopress","小ネタ"],"category_urls":["/categories/mathjax","/categories/octopress","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2014-02-21","title":"MathJaxを使って数式を埋め込む","url":"https://KeenS.github.io/blog/2014/02/21/mathjax/"},
  {"body":"κeenです。CIMの解説 実装編の執筆はもうちょい掛かりそうです。だいたいコードが落ち着いたら書きます。\n今回は長いオプションと短いオプションをシェルスクリプトでパースするときの話です。\nシェルスクリプトではcaseを使う方法とgetoptsを使う方法があります。caseだと長いオプションと短いオプションを扱えるものの短いオプションをまとめるのに苦労し、getoptsだと短いオプションをまとめられるものの長いオプションを扱えません。\nそこで解決策。--foo ARG -f ARG -hをパースし、他のオプションも許可（無視）、--でパースを止めるとします。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  while [ \"$#\" -gt 0 ];do ARG=\"$1\";shift case \"$ARG\" in --foo) do_something_with \"$ARG\";; --) break;; --*) ;; -*) OPTIND=1 while getopts :f:h OPT \"$ARG\"; do case \"$OPT\" in f) do_something_with \"$OPTARG\";; h) do_something;; esac done ;; esac done   単純にcaseとgetoptsを組み合わせます。ポイントは-*)の節のOPTIND=1とgetoptsの第3引数でしょうか。\n因みにこの例だと引数を消費します。引数を消費したくなければ\n 1 2  while [ \"$#\" -gt 0 ];do ARG=\"$1\";shift   を\n 1  for ARG;do   に書き換えれば良く、--でパースを止めたくなければ--) break;;の節を無くせば良く、\n他のオプションを許したくなければ--*);;の節を--*)exit 1;;などにし、getoptsの引数文字列:f:hの:をとってgetopts fh ...とすれば良いです。\n","categories":["CLI","Shell Script"],"category_urls":["/categories/cli","/categories/shell-script"],"date":"2014-02-19","title":"Shell Scriptでオプションをパースするときの必勝法","url":"https://KeenS.github.io/blog/2014/02/19/option-parse-for-shell/"},
  {"body":"FreeBSD10をインストールするときにdocをインストールしなかったら後で困ったのでメモ。環境はUbuntu13.10上のkvmに入れたFreeBSD10です。\n本来ならsudo bsdconfig(9.xまではsudo sysinstall)でメニューを選んでいけばインストールできるのですが、pingか何かがおかしくてサーバーの名前解決ができない。ping FreeBSD.orgやping 4.4.4.4が返ってこない。しかしcurlなどは普通に動きます。\nとりあえず\n$ ftp anonymous@ftp.jp.freebsd.org でログインし、\nftp\u0026gt; cd pub/FreeBSD/releases/i386/10.0-RELEASE と進んで\nftp\u0026gt; get doc.txz します。んで\nftp\u0026gt; bye $ unxz -cd doc.txz | sudo tar xf - -C / でインストール完了。\n普通に配置するだけで良いんですね。mandbとかあるのかと思ってた。\n","categories":["CLI","FreeBSD","小ネタ"],"category_urls":["/categories/cli","/categories/freebsd","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2014-02-01","title":"FreeBSDのmanページを手動インストールする","url":"https://KeenS.github.io/blog/2014/02/01/freebsd-manpage/"},
  {"body":"先日LTで紹介したCIMが思いの外反響を呼んでる(Githubのstarが15)ので解説でもしてみます。\nコマンド編の次は実装編です。これでバグにエンカウントしたときの調査とか完璧ですね。\nインストーラ READMEにあるように\ncurl https://raw.github.com/KeenS/CIM/master/scripts/cim_installer | /bin/sh で~/.cim/にインストールできます。パスを変えたければ\nCIM_HOME=/path/to/cim curl https://raw.github.com/KeenS/CIM/master/scripts/cim_installer | /bin/sh でOK。Cシェル系なら\nenv CIM_HOME /path/to/cim curl https://raw.github.com/KeenS/CIM/master/scripts/cim_installer | /bin/sh でしょうか。\n2014-10-20更新\nCIM_HOMEの設定方法が間違ってました。正しくは\ncurl https://raw.github.com/KeenS/CIM/master/scripts/cim_installer | CIM_HOME=/path/to/cim /bin/sh で、Cシェル系なら\ncurl https://raw.github.com/KeenS/CIM/master/scripts/cim_installer | env CIM_HOME /path/to/cim /bin/sh です\n更新ここまで\nここではcurlを使ってますがwget -O -とかfetch -o -など標準出力に吐ければなんでも良いです。\nあ、でもCIM_HOMEを指定してインストールしたときにバグがある気がしてきました。今から直します。\nCIMを使うにはシェルの起動時に初期化が必要ですが、インストーラが初期化ファイルを読みにいく処理を.*rcに書き出してくれます。Bourne Shellは.profileですね。\n書き出すファイルは$SHELLを見てます。csh、tcsh、sh、bash、zshに対応してます。\nあと~/.emacs.d/eshell/が存在したら~/.emacs.d/eshell/profileにも初期化処理を書き出します。一時期パスが間違ってて~/.emacs.d/profileに書き出してました。ごめんなさい。\nvimshell(だっけ？)でも初期化さえしてしまえば使えると思うので誰か初期化処理書いて下さい。\ncim とりあえずhelp見ておきましょう。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  $ cim help CIM -- Common Lisp Implementation Manager Commands currently available install \u0026lt;impl[-version]\u0026gt; ;; Install the impl. use \u0026lt;impl[-version]\u0026gt; ;; Use specified impl as `cl' command's backend. resume [rm] [resume..] ;; Resume suspended installation(s) or give it up. list \u0026lt;command\u0026gt; ;; List available target of \u0026lt;command\u0026gt; reinstall \u0026lt;impl[-version]\u0026gt; ;; Reinstall the impl. clean \u0026lt;impl\u0026gt;|all ;; Clean downloaded archive and src of the impl. distclean \u0026lt;impl\u0026gt;|all ;; Clean built dists. uninstall \u0026lt;impl[-version]\u0026gt; ;; Uninstall the impl. purge \u0026lt;impl\u0026gt;|all ;; Just clean and uninstall the impl. info ;; Display current state. get ;; Upgrade cim itself. version ;; Show the version help \u0026lt;command\u0026gt; ;; Show help for \u0026lt;command\u0026gt;. If no commands are specified, show this help. If you want detailed help, type `cim help \u0026lt;command\u0026gt;'.  ## `cim install`  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  $ cim help install Usage: cim install \u0026lt;impl[-version]\u0026gt; Description: Install the given lisp implementation to cim directory. If version is not specified, install the latest version. If you want to pass specific options to 'configure' script, prefix 'flags='. Examples: # install sbcl-1.1.14 cim install sbcl-1.1.14 # install latest clisp with option. flags='--with-libsigsegv-prefix=/usr/local' cim install clisp To show available lisp implementations, type 'cim list install'.   インストールします。はい。\u0026lt;impl[-version]\u0026gt;ってのはsbclとかclisp-2.48とかですね。バージョンを指定しなかったら最新版になります。cim list installでインストール可能なものを表示しますが載ってない古いバージョンとかもインストールできる筈です。多分。\nconfigureスクリプトに渡すフラグを指定したいときはflags='flag....' cim installとします。ヘルプにあるようにlibsigsegvのパスを指定しないとFreeBSDでclispをインストールできなかったので用意しました。\nAllegroはライセンス表示した方が良いのかなーとか考えてます。\ncim use  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  Usage: cim use \u0026lt;impl[-version]\u0026gt; [--default] Description: Use \u0026lt;impl\u0026gt; as background for 'cl' command. It also affects bare lisp command. If version is not given, use latest version. If --default is given, use the specified implementation at initial state. Examples: # use the latest sbcl cim use sbcl sbcl --version -\u0026gt; SBCL 1.1.14 # use old sbcl cim use sbcl-1.1.10 sbcl --version -\u0026gt; SBCL 1.1.10 # use ccl-1.9 and set it default cim use ccl-1.9 --default   clコマンドのバックエンドの切り替えと処理系のバージョンの両方を切り替えます。処理系の指定の仕方はinstallに同じ。じゃなかった。installに加えて/bin:/usr/bin:/usr/local/binにあるものをxxx-systemとして指定できます。sbcl-systemとか。\n例えば\ncim use clisp-2.48 ってやるとclコマンドがバックエンドとしてclispのバージョン2.48を使うようになりますし、clispコマンドのバージョンも2.48になります。このclispの部分はリンクを貼り替えてて、一つのシェルで変更すると他のシェルにも影響が及ぶ問題があるのでそのうち直します。これ結構面倒なのでそのうちです。\nclisp = clisp-2.48な状態でcim use sbclするとclisp = clisp-2.48なままclのバックエンドがsbclになります。上手く使って下さい。\n--defaultを付けると次回からのデフォルト値を指定したものにしつつcim useします。\ncim resume  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  $ cim help resume Usage: cim resume [rm] \u0026lt;impl[-version]\u0026gt; | all Description: Resume interrupted installation of \u0026lt;impl\u0026gt;. If \u0026lt;version\u0026gt; is not given, the latest version is used. If 'rm' is given, remove \u0026lt;impl\u0026gt; from 'resume' list. If target is 'all', do on all the available target. Examples: # resume the installation of clisp with configure flags flags='--with-libsigsegv-path=/usr/local' cim resume clisp # remove all the available target. cim resume rm all   cim installがエラー終了したりCtrl-Cで中断したりしたやつを再開してくれるコマンドです。cim install sbclを中断したならcim resume sbclで再開できます。cim resume allで中断された全てのインストールを再開します。終了ステータスは再開してもまたエラーで終了したやつの数になります。\ncim resume rm sbclだとcim list resumeの結果からsbclを削除できます。resumeはしませんよ。cim resume rm allとかも可能です。\ncim list  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  $ cim help list Usage: cim list \u0026lt;subcommand\u0026gt; Description: List available target for subcommand. Examples: # list available lisp implementation to install cim list install # show available target for list cim list list # targets for subsubcommands are also available cim list resume rm   さっきから出てきてるので分かるかと思いますが、可能なターゲットを表示します。将来的にはzshの補完候補にも使うつもりです。そのときは-b, --batchオプションでhuman readableかmachine readableかを分けようかなと。\ncim reinstall  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $ cim help reinstall Usage: cim reinstall \u0026lt;impl[-version]\u0026gt; | all Description: Force install already installed implementaion(s). Downloaded archives are resued if available If version is not specified, install the latest version. If target is 'all', do on all the available targets. Examples: # reinstall sbcl-1.1.14 cim reinstall sbcl-1.1.14 # reinstall all installed lisp impls cim reinstall all To show available lisp implementations, type 'cim list reinstall'.   cim installは既にインストールされているものはインストールできないのですが、reinstallを使えば可能です。ダウンロードしたアーカイブがあればそれを使います。なければダウンロードから始めます。allは察しのようにインストール済のものを全てreinstallします。\ncim clean  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $ cim help clean Usage: cim clean \u0026lt;impl[-version]\u0026gt; | all Description: Remove donwloaded archives and extracted sources of the given lisp implementations. If version is not specified, install the latest version. If target is 'all', do on all the available targets. Examples: # clean sbcl-1.1.14 cim clean sbcl-1.1.14 # clean all installed lisp impls cim clean all To show available lisp implementations, type 'cim list clean'.   cim installは基本的に不要なものも削除しないので、それが嫌ならcleanを使いましょうというスタンスです。アーカイブとソースを削除します。\ncim distclean  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $cim help distclean Usage: cim distclean \u0026lt;impl[-version]\u0026gt; | all Description: Clean built files of the given lisp implementation. It doesn't mean uninstall. If version is not specified, install the latest version. If target is 'all', do on all the available targets. Examples: # distclean sbcl-1.1.14 cim distclean sbcl-1.1.14 # distclean all installed lisp impls cim distclean all To show available lisp implementations, type 'cim list distclean'.   cim cleanより控えめなコマンドです。コンパイルするときにmakeで生成されたファイルを削除します。make clean的な。\ncim uninstall  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $ cim help uninstall Usage: cim uninstall \u0026lt;impl[-version]\u0026gt; | all Description: Uninstall the given lisp implementaion(s). It does't remove donwloaded archives and extracted sources. If version is not specified, install the latest version. If target is 'all', do on all the available targets. Examples: # uninstall sbcl-1.1.14 cim uninstall sbcl-1.1.14 # uninstall all installed lisp impls cim uninstall all To show available lisp implementations, type 'cim list uninstall'.   アンインストールします。はい。ただしダウンロードしたアーカイブとソースは削除しません。\ncim purge  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $ cim help purge Usage: cim purge \u0026lt;impl[-version]\u0026gt; | all Description: Uninstall and clean up downloaded files of the given lisp implementation. This command is equivalent to 'clean' and 'uninstall'. Examples: # purge the latest sbcl cim purge sbcl To show available target for 'purge', type 'cim list purge'   uninstallのアーカイブとソースを削除する版です。\ncim info  1 2 3 4 5 6 7 8 9 10 11 12 13  $ cim help info Usage: cim info Description: Display information for current cim. It includes environment variables that cim uses, what current and default lisp implementation is, what version of each implementation is used, and where system lisp is. Example: # display info cim info   現在の状態を表示します。こんな感じ。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  $ cim info CIM_ID = 22176 CIM_HOME = /home/kim/.cim current lisp = sbcl-system default lisp = sbcl-system abcl = abcl-1.2.1 alisp = alisp-9.0 ccl = ccl-1.9 clisp = clisp-2.49 ecl = ecl-13.5.1 gcl = gcl-2.6.9 sbcl = sbcl-system sbcl-system = /usr/local/bin/sbcl gcl-system = /usr/bin/gcl   CIM_IDってのはcimがそれぞれのシェルの状態を管理するためのIDです。まあ、そのシェルのプロセスIDですね。逆にプロセスIDの取得と環境変数の設定さえできればcimは動かせるのでEmacsでも簡単に動きます。\ncim get  1 2 3 4 5 6 7 8 9 10 11  $ cim help get Usage: cim get Description: Upgrade to the latest cim. Examples: cim get   cim自身のアップデートです。なんでこんな名前かというとrvmがそうだからです。現状はgithubのKeenS/CIMのmasterからとってきます。stable版ができたらstableに変更しますね。実はブランチを指定してとってくる方法もあったりはします。cim get --branch stableか CIM_INSTALL_BRANCH=stable cim getです。まだブランチが無いので意味ないんですけどね。\nこの辺で気付いたかもしれませんが結構環境変数で制御できるようにデザインされてます。rubyがそんな感じだからです。\ncim version  1 2 3 4 5 6 7 8 9 10 11 12  $ cim help version Usage: cim version Description: Show current cim's version Example: cim version   めちゃくちゃバグがあるのにversionが1.0.0に見えるの気のせいです。きっと100点中の1点なんですよ。\ncim help  1 2  $ cim help help Help for 'help' is not prepared, sorry.  あー。helpのhelp用意してなかったー。まあ、上で使ったのが全てです。\ncl  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  $ cl -h Usage: cl [switchs] [--] [programfile] [argumensts] -C DIR set *default-pathname-defaults* DIR. -d, --debug set debugging flags (push :debug into *features*) -e, --eval SEXP one line of script. Several -e's are allowed. Omit [programfile] -f, --load FILE load the FILE -i EXT edit *argv* files in place and make backup with the extension .EXT -l LIBRARY quickload the LIBRARY -L LIBRARY quickload and use-package the LIBRARY -r, --repl run repl -q, --no-init do not load $CIM_HOME/init.lisp --no-rl do not use rlwrap. This is effective only when --repl is specified --no-right do not display right prompt. This is effective only when --repl is specified --no-color do not use color. This is effective only when --repl is specified -h, --help print this help -v, --version print the version If neither programfile, -e (--eval) nor -r (--repl) are specified, cl reads scripts from the standard input and then eval them.   まあ、見たら分かりますね。ruby由来のオプションとShelly由来のオプションと私の好みのオプションがあります。clを起動する方法は\n cl script.lisp cl \u0026lt; script.lisp cl -e sexp cl -r  です。cl script.lispはシェバン(最初の行が#!なもの)を無視します。\nまた、これも環境変数LISP_IMPLでバックエンドを制御できます。これはShelly由来ですね。\nもう一つ、デバッガは起動しません。スクリプトやワンライナーはエラーを吐いて終了して欲しいですし次に述べますがREPLも目的からしてデバッガは相応しくないと思うからです。因みにですが-dオプションをつけてもデバッガは起動しません。理由はオプション解析のほとんどをLispに任せているので起動時のオブションである--disable-debuggerを制御できないからです。需要が高そうならシェルスクリプト内で解析して頑張ってみます。\nあ、-c, --compile FILEオプションつけ忘れてた。いつか入れます。(compile-file FILE)で可能でしょうからすぐに入るはずです。\ncl -r 一応開発向けではなくて、ちょっと試したいときや初心者が本を片手に動かすときを想定して作ってます。エラーはメッセージのみ表示。ちょっと試したいときはあんまりデバッガを必要としませんしスタックトレースもどうせ深さ1~2なのであまり必要でないからです。なにより初心者にとってデバッガは何をして良いか分かりませんし覚えても処理系毎に操作が違います。その辺を分り易い統一インターフェースを作ることも考えたのですが「それってswank」って結論に至ったのでこのままです。\nql  1 2 3 4 5 6 7 8 9 10  ql -- Command line interface for quicklisp Commands currently available deps \u0026lt;system\u0026gt; ;; Install dependencies of \u0026lt;system\u0026gt;. help [command] ;; Show help. install[quickload] \u0026lt;system\u0026gt;... ;; Install given system. list {remote | local} ;; List available/installed systems. search[system-propos] \u0026lt;keyword\u0026gt; ;; Search quicklisp. uninstall \u0026lt;system\u0026gt; ;; Uninstall system. update [system] ;; Update dist info and installed systems.  一番未完成なコマンドです。主な理由は私がquicklispの使い方を分かってないからです。\nql deps  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $ ql help deps Usage: ql deps [--path \u0026lt;path\u0026gt;] \u0026lt;system\u0026gt; Description: Install dependencies of given system. If path is specified, install dependencies there. Once you run 'ql --path \u0026lt;path\u0026gt; deps', you don't need to specify '--path' because the path is written out to '.quicklisp-path' in current directory. You can run 'ql deps' for a local system if '.asd' file is in current directory. This command is useful when you want to separate quicklisps for local project. Example: ql deps --path ./quicklisp my-project   rubyのbundlerを参考に作りました。Gemfileに対応するQLfileでも読もうかと思いましたが良く考えたら.asdで十分じゃんとの思いに至ったのでカレントパスのasdファイルを読みます。\nが、奴は依存システムのバージョンまでは指定できなかった気がするのでやっぱり必要な気がします。\nql deps --path ./ql myappとすると依存システム(+新たなquicklisp本体)を./qlにインストールしてくれます。quicklisp本体のインストールは不要ですがどうやったら回避できるかは今模索中です。\n--pathの位置がcim use --defaultと違うのでご注意下さい。これは主に内部で使ってるparse-optionの欠陥に由来します。\n一度指定すると.quicklisp-pathにパスを書き出してくれるので次回からは必要なくなります。カレントディレクトリに複数のasdファイルがあってそれぞれでパスを使い分けたいとかはできません。\nあと、最大の欠陥として./qlにシステムをインストールしてもそれを読み込みにいくコマンドがないので実用性ゼロです← まあ、clあたりを弄ってカレントパスに.quicklisp-pathがあったら読みにいくようにします。その辺は.lisp-implとかも含めて考えます。\nql help  1 2  $ ql help help Help for 'help' is not prepared, sorry.   こいつもhelp用意してなかった。まあ、良いや。\nql install  1 2 3 4 5 6 7 8 9 10 11 12 13  $ ql help install Usage: ql install \u0026lt;system\u0026gt;... Description: Install given system(s) to $CIM_HOME/quicklisp. Example: # install clack ql install clack   なんでこいつがhelpの先頭に居ないんでしょうね。cimに比べて適当ですね。\nql quickloadっていう別名も持ってます。ql helpにはquickloadが本名でinstallがエイリアスって書いてありましたが実装ミスりました。\n名前の通りql:quickloadします。systemは複数指定できます。\nql list  1 2 3 4 5 6 7 8 9 10 11 12  $ ql list Usage: ql list {remote | [local]} Description: List installed systems. if 'remote' is given, list all the available systems. 'ql list local' is equivalent to 'ql list'. Example: ql list remote   cim listと使い方が違ってアレですね。現状quicklispに登録されているもの全てを表示するql list remoteとインストールしたものだけを表示するql list [local]があります。ql depsでパスを指定したやつらにも使いたかったのですが方法が分かんないのでとりあえず先送りです。\nql search  1 2 3 4 5 6 7 8 9 10 11 12  $ ql help search Usage: ql search \u0026lt;keyword\u0026gt; Description: Search quicklisp for \u0026lt;keyword\u0026gt;. Example: ql search http   別名system-apropos。別名と本名がql helpと違うのも単にql:system-aproposを呼ぶのもql installと同じです。出力結果をもうちょっと制御したいなと思ってます。\nql uninstall  1 2 3 4 5 6 7 8 9 10 11 12  $ ql help uninstall Usage: ql uninstall \u0026lt;system\u0026gt;... Description: Uninstall given system(s). Example: ql uninstall caveman clack   ql:uninstallに同じ。以上。\nql update  1 2 3 4 5 6 7 8 9 10 11 12  $ ql help update Usage: ql update [client] Description: Update installed systems. If target 'client' is given, update quicklisp itself. Example: ql update client   ql:update-all-distsかql:update-clientかを選べます。最初はsystem毎にアップデートしたかったのですが無理っぽいので止めました。\nおわりに とりあえずCIMの機能はこれで全部です。あ、開発用にcim resetとかありますけど使わないで下さい。とういうか使うなよ。絶対使うなよ。\nこれら使ってみてバグがあったらgithubのissueに投げるなりtwitterで報告するなりして下さい。\nところでCIMは私はちむと読んでます。しー・あい・えむと読む人も居るようです。何でも良いです。プロジェクトとしてのちむとコマンドとしてのちむを区別するためにコマンドは小文字でcim、そしてcim、cl、qlを含んだプロジェクトは大文字でCIMと書くことにします。今考えました。\n","categories":["CIM","CLI","Common Lisp","Lisp"],"category_urls":["/categories/cim","/categories/cli","/categories/common-lisp","/categories/lisp"],"date":"2014-01-27","title":"CIMの解説をしてみる コマンド編","url":"https://KeenS.github.io/blog/2014/01/27/cim-explanation/"},
  {"body":"もう12時回ったので昨日になってしまいましたが Lisp Meet Up presented by Shibya.lisp #13に参加してLTしてきたので報告(?)エントリです。\n先月東京に戻ってきた深町さんがめちゃくちゃ宣伝してたせいか20人参加希望があり、19人参加しました。\n自己紹介ではClojureが多いなーってのとRubyistが混ってたりしたのが印象的でした。Emacs Lispの人も居たり。\nLTは一人目がにとり(深町英太郎 (fukamachi))(@nitro_idiot)さん。今更ながら呼び方に困りましたね。内容はO/Rマッパーの integralの機能と実装について。\n非Common Lisperが多い中Meta Object Protocolについて色々説明したりと大変そうでした。私はCommon LisperなのでMOPにそんな使い方がるのかとか結構面白かったです。\nスライドはまだ上げてないみたいです。そのうち上がるでしょう。上がりました。\n Integral – New O/R Mapper for Common Lisp from fukamachi\n二人目が私。最近作ってる CIMについてです。スライド見るのが速いですね。\n CIM – Common Lisp Implementation Managerを作りました from blackenedgold\n実際にそれぞれのコマンドを動かしてみた結果、予想してなかったエラーなとがあったものの割と聴衆の反応は良かったです。あとはPure Bourne Shell Scriptで挑んで爆死した話とかしたりですね。「詳解シェルスクリプト」を読んだりmanページ読んだりして頑張ったんですよ。\nそれが終わったら一旦休憩。そしたらわざわざ深町さんが私のところに来て下さって「Shellyより良いプロダクトになると思います。頑張って下さい。」との御言葉を頂きました。非常に嬉しかったです。私が作ったものが認められた。しかも着想の元になったShellyの作者の深町さんから。\nでもその後実際に何人か使ってみてくれたのですが、バグが立て続けに3つくらい発覚して「…これ、テスト必要ですね」と絶句。分かってます。分かってますけど難しいんです泣。\n他はgithubでCIMを探そうとしてる方が居たんですが同じ名前のレポジトリがめちゃくちゃあって検索性悪いなとか。何故か私のハンドルネームの最初の文字がk(ケー)ではなくκ(カッパ)なのを知ってたり。\nその後の懇親会では向かいが深町さん、隣が佐野さん(実践Common Lispの訳者)で、Common Lispの今後とか色々な話をしてました。 ここのグラフでCommon Lispがありえない位置にいるしどうやったら普及するんだろうねーとか。\n運営のchikuさん potixさん、発表を聞いてCIMを試してくれたりGithubにstarくれたりしたみなさんありがとう御座いました。\n","categories":["CIM","Common Lisp","Lisp","Lisp Meet Up"],"category_urls":["/categories/cim","/categories/common-lisp","/categories/lisp","/categories/lisp-meet-up"],"date":"2014-01-24","title":"Lisp Meet Up #13でLTしてきました","url":"https://KeenS.github.io/blog/2014/01/24/lisp-meet-up-number-13/"},
  {"body":"mpdのちょっとした便利な使い方。\natがRSPiにインストールされてる前提で、RSPi上で\n$ at 7:00 at\u0026gt; mpc toggle ^D とすればRSPiを目覚ましや時報として使えます。停止にはsshログインしてmpc toggleする必要があるのでそこまでする頃には起きてる筈。\n","categories":["Raspberry Pi","mpd","CLI"],"category_urls":["/categories/raspberry-pi","/categories/mpd","/categories/cli"],"date":"2014-01-21","title":"Mpd 小ネタ","url":"https://KeenS.github.io/blog/2014/01/21/mpd-something/"},
  {"body":"κeenです。ここのところ寒い日が続いてますね。寒いと家に扃(ひきこも)ってTweet数が急上昇します。 すると一日に何postしてるか気になるのでカウンタを作りました。\nそのときの苦労話です。\nただ、どうせ記録取るなら色々やりたいのでRspberry Piで一日のpost数、fav数、そしてメンヘラなことにフォロー/フォロワー全員のidを毎日記録することにしました。これで誰にリムられたかブロられたか一目瞭然ですね。\nここで一つ問題が。post, fav数は良いのですがフォロー/フォロワーのid一覧は毎日変わるのでmysqlで管理するのはちょっと面倒かなと。なのでMongoDBで管理することにしたいんですが、raspbianのaptにないんですよね。仕方ないので手動ビルドで対応しました。\nMongoDBのビルド ここを参考に\ncd ~/compile sudo apt-get install build-essential libboost-filesystem-dev libboost-program-options-dev libboost-system-dev libboost-thread-dev scons libboost-all-dev python-pymongo git git clone https://github.com/skrabban/mongo-nonx86 cd mongo-nonx86 sudo scons としました。が、sconsに一晩かかるとのことなので放置してたら何故かraspberry piが落ちてる…\n気をとりなおして再起動。もう一度sudo sconsすると今度はエラー終了。sig 9 killed…いや、私なにもしてないですよ?ダメ元で今度は\nsudo scons install したら完走。良ク分カラン。狂想曲感が出てますね。\nMongoDBのインストール さっきのでインストール終わったと思うでしょ？違うんですよ。init.dだとかmongodb.confだとかは配置されてないんですよ。debian/以下に色々入ってるので\ncd debian sudo cp mongodb.conf /etc/mongodb.conf までは良いのですが、init.dとmongodb.upstartのmongodのパスが/usr/bin/mongodでハードコードされてるんですよ。上のsudo scons installだと/usr/local/bin/mongodです。さらに起動オプションに--dbpadh /var/lib/mongodbと--logpath /var/log/mongodb/mongodb.logが指定されていて、mongodb.confで上書きしているにも係らずそこまでのパスが存在しないとエラー吐いて起動してくれないので修正。\nmongodb.upstartは直ぐ分かるので良いとして、init.dは\n 1 2 3 4 5 6 7 8 9 10  48d47 \u0026lt; 50c49 \u0026lt; DAEMON=/usr/bin/mongod --- \u0026gt; DAEMON=/usr/local/bin/mongod 100c99 \u0026lt; DAEMON_OPTS=\"$DAEMON_OPTS --config $CONF\" --- \u0026gt; DAEMON_OPTS=\"run --config $CONF\"   な感じの修正です。なんか空行が一つ減ってますが気にしない。\nここまでしたらようやく\nchmod +x init.d mongodb.upstart sudo cp init.d /etc/init.d/mongodb sudo cp mongodb.upstart /etc/init/mongodb で完了です。manとかもあるのですが配置の仕方が分からないので放置←\nsudo service mongodb start mongo で接続確認できます。\nTwitterのpostを集約する ビックリするくらい簡単。twitterのAPI keyを持ってる前提ですが。\nsudo gem install twitter mongo で必要なgemをインストールし、~/.twitter.rbに\n 1 2 3 4 5 6  $client = Twitter::REST::Client.new do |conf| conf.consumer_key = \"yours\" conf.consumer_secret = \"yours\" conf.access_token = \"yours\" conf.access_token_secret = \"yours\" end   と保存しておきます。昔と形式が変わりましたね。この形式になってからスレッドセーフになり、Twitter Stream APIにも対応してるようです。いつか扱ってみたい\n集計ですが\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #! /usr/local/bin/ruby # coding: utf-8 require 'twitter' require 'mongo' require 'time' load \"~/.twitter.rb\" doc = { \"tweets\" =\u0026gt; $client.user.tweets_count, \"favs\" =\u0026gt; $client.user.favorites_count, \"followers\" =\u0026gt; $client.friend_ids.to_a, \"friends\" =\u0026gt; $client.follower_ids.to_a, \"timestamp\" =\u0026gt; Time.now.strftime(\"%Y%m%d%H%M%S\")} col = Mongo::Connection.new.db(\"twitter\").collection(\"tweets\") last = col.find.sort([\"timestamp\",:desc]).first tweets_sub = doc[\"tweets\"] - last[\"tweets\"] favs_sub = doc[\"favs\"] - last[\"favs\"] followers_sub = doc[\"followers\"].length - last[\"followers\"].length friends_sub = doc[\"friends\"].length - last[\"friends\"].length col.insert doc message = \"前回計測(#{Time.parse(last[\"timestamp\"]).strftime \"%Y-%m-%d %H:%M:%S\"})以降\\n\" message += \"#{tweets_sub}回ツイートし\\n\" message += \"#{favs_sub}回favり\\n\" message += \"友達は#{friends_sub.abs}人#{friends_sub \u0026gt;= 0 ? \"増え\" : \"減り\"}\\n\" message += \"フォロワーは#{followers_sub.abs}人#{followers_sub \u0026gt;= 0 ? \"増え\" : \"減り\"}ました\" $client.update message   で全部です。Rubyのハッシュ+配列がそのままinsert/selectできるのでぜんぜんMongoDBを意識しなくて良いですね。\nところでdatetime型が無さげだったのでtimestampをソートキー兼idにするためにYYYYMMDDHHMMSS形式の文字列で格納してます(整数は8bitまでっぽかったです)。他に良い方法があると思うのですが思いつきませんでした。\n","categories":["MongoDB","Raspberry Pi","Ruby","Twitter"],"category_urls":["/categories/mongodb","/categories/raspberry-pi","/categories/ruby","/categories/twitter"],"date":"2014-01-19","title":"RSPiでMongoDBを動かし、Twitter Post Alertを作った話","url":"https://KeenS.github.io/blog/2014/01/19/rspi-plus-mongodb-plus-twitter/"},
  {"body":"やや長いタイトルですが・・・年末になって大掃除がやってきましたね。みなさんもそろそろ.emacsの大掃除をしましょう。\n私の.emacsは元々1300行ちょいあってEmacsの起動に7~8秒(体感)かかってましたが大掃除\u0026amp;高速化をした結果800行弱、起動に1秒(体感)ほどになったので整理の仕方を共有しますね。\n前提ですが、私はinitローダーとかは使ってません。全部init.elに書いてます。で、機能毎にページを作って(C-q C-l)ます。ただ、それだけだと視認性が悪いので見出しとしてC-u C-u C-u ;で;を64個挿入して次の行にコメントで#付きのタイトルを付けてます。\n具体的には\n 1 2 3  ^L ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; #Lisp   こんな感じのものが機能毎に書かれてます。これでC-sやM-x occurでハッシュタグのように検索することもC-vでスクロールしていって目grepすることもC-x ]で機能毎にジャンプすることもできます。\n1. Emacsの最新版を使う 結構重要です。「標準のやつだと欲いこの機能がないから拡張パッケージ入れた」なんてのも最新版では改善されていたりします。例えば私はemacs-w3mを使っていましたが、EmacsのmasterブランチにはewwなるEmacs Lisp製のブラウザが入っているのでそれを使うようにしました。\nただ、これが絶対的正義かというとそうでもなく、パッケージで入れてない分 Ubuntuのインプットメソッドとの連携部分がなかったのでuim.elを入れる 必要が出てきたりと、面倒な部分もありました。Emacs標準のインプットメソッドはどうにも使いものにならず、 ddskkもuim-skkとコンフリクトする(というかC-j上書きとかありえない)ので使いません。インプットメソッドの切り替え部分は\n 1 2  (global-set-key (kbd \"\u0026lt;hiragana-katakana\u0026gt;\") #'uim-mode) (global-set-key (kbd \"\u0026lt;zenkaku-hankaku\u0026gt;\") #'uim-mode) (autoload #'uim-mode \"uim\" nil t)   になりました。\n2013-12-16追記\nこれは私が~/.XresourcesにEmacs*useXIM: falseを書いていたのが原因でした。Emacs*useXIM: trueに書き換え、xrdb ~/.Xresourcesすると直りました。\n2. 普段使わない設定は全部消す 基本ですね。私はsummary-edit.elだとかmultiverse.elだとかるびきちさんの本を読んで便利そうだから入れたものの、結局使わなかったものの設定\u0026amp;elispをごっそり削除。あとかなりの言語に対してデフォルトでauto-mode-alistが設定されていたのでauto-mode-alistの設定も全部消して、必要になったら書き足すようにしました。\n3. 普段使っていても代替の効くものは削除 これは高速化の意味と自分の環境に依存しない意味があります。最近、自分のラップトップ以外でもEmacsを触ることが多くあって、デフォルトのキーを上書きして使ってる部分で何度も誤操作したのでそれを減らす目的です。bm.elはC-x r SPCのregister系やC-x C-SPCで対応(registerは覚えれば使い出がありそうなのでいつか解説書くかもです)、open-junk-file.elは~/tmpを作って対応、recentf-ext.elはhelm-file-buffersだとか。\nあと全てhelm.elに置き換えてhelm.elとanything.elが混在してる状態をどうにかしたかったのですが、php-completion.elかなにかが依存しててトドメを刺せませんでした。\nあと、viewerの代替を探していたらタイトルにあるように悪魔合体が起きたので後で書きますね。\n4. できる限り標準のものを使う 標準で提供されているパッケージはautoloadがemacsバイナリに組込まれてる(と思う)ので起動時のオーバーヘッドはありません。flymake.elやruby-mode.elが標準で提供されてるのに気付いたのでそれを使ったりなど。一度(emacsroot)/lisp以下を眺めてみることをお勧めします。結構発見があるものです。\n5.autoloadを使う autoloadとはファイルの読み込みを必要になるまで遅らせる仕組みです。「必要になる」ってのはそのファイルで定義されている関数が呼ばれたときです。賢いrequireと思えば良いでしょう。\n(autoload #\u0026#39;関数名 \u0026#34;関数が呼ばれたときに読むファイル名\u0026#34; nil interactivep) みたいに使います。interactivepの部分はM-xで呼ぶものならt、そうでなければnilです。requireをautoloadで書き換えていけば理論上起動時の読み込み0にできるのでかなり高速化できます。\nが、実際は一々autoload書くのはしんどいので次です。\n6.できる限りpackage.elを使う package.elは必要な関数のautoloadを自動生成して読み込んでおいてくれるのでかなりの手間が省けます。そしてautoloadがあるのにrequireしてると折角のpackage.elの配慮が無駄になります。\n自動生成されたautoloadはelpa/パッケージのディレクトリ/パッケージ-autoloads.elにあるので確認しながらinit.elの邪魔なものを消していきます。これでかなりinit.elの行数が減ります。今まで無駄な設定していたんだなと気付きます。\n7. eval-after-loadを使う 8割程の設定はautoloadで対応できるのですが、踏み込んだ設定をしているとパッケージの内部の関数を使ってしまってどうしてもその式が評価される前にパッケージが読み込まれている必要があることがあります。\nそんなときはeval-after-loadを使います。名前のまんま、ロードした後でevalしてくれます。\n(eval-after-load \u0026#39;ファイル名 \u0026#39;式) の形で使います。複数の式を使いたい場合はprognを使って\n(eval-after-load \u0026#39;ファイル名 \u0026#39;(progn 式1 式2...)) のように使います。あるパッケージの拡張パッケージなんかもここで読むと良いかもしれません。\n8.その他 メールクライアントを標準のものにしようとしましたが、gnus.elはちょっと受け付けなくてその他はimapを喋らないので断念。でも色々調べてたらmewよりwanderlustの方が良いようなので使い初めました。表示が綺麗で良いですね。HTMLのレンダリングもemacs-w3mに頼らず標準のshr.elを使っているのも◎。\n同じような経緯でJDEEをやめてmalabar.elを使うようにしました。ただ、私はmaven使いではないので微妙ではあります。まあ、そもそもプロジェクト単位でJavaを書くことがないってのもあるんですが。Androidのスケルトンがantなのでantでできたら嬉しいなーって。\nEmacsとViとShellとLispを悪魔合体させた話 私はEmacsの狂信者ですが読み専のときはちょいちょいviを使うこともあります。片手で操作できるのは便利です。Emacsで読み専といえばview-modeです。そこでもhjklを使うべくview-mode-mapに手を加えてましたが、大掃除ということで全部削除。\nその後でemacsroot/lisp/emulate/以下を読んでいるとなんかviのエミュレーターが3つも見付かりました。vi.el、vip.el、viper.elです。後者になるほどviとの互換性が高くなります。とりあえずはhjklが使えれば良いのでvi.elを使ってみたところ、ん〜…といったところ。vip.elと試して結局viper.elに落ち着きました。\n(global-set-key (kbd \u0026#34;C-x C-q\u0026#34;) #\u0026#39;(lambda () (interactive) (toggle-viper-mode) (force-mode-line-update))) 設定はこんな感じです。toggle-viper-modeしてもモードラインの表示が変わらないことがあったのでforce-mode-line-updateを加えました。\nviper.elは単なるviのエミュレートだけではなく、Levelに応じて良い感じにemacsと悪魔合体してくれます。私は最高レベルの5にしました。”C-x C-s”など基本的なコマンドはそのまま使えるようになってます。:で始まるvi(ex)のコマンドも使えます。C-zでemacs\u0026lt;–\u0026gt;viを切り替えたり。非常に便利です。\n尚、私はvi使いであってvim使いではないのでevilは使いません。\nもう一つ、shellの話。今まではmultiterm × zshな感じでしたが、「できる限り標準のものを使う」方針でeshellに切り替えました。eshellはEmacs Lispで書かれたshellです。これが思った以上に便利です。るびきちさんの本では標準出力とエラー出力の切り分けができてないと書かれてましたがそれは修正されてるようです。\nあとは/dev/killだとか\u0026gt;\u0026gt;\u0026gt;だとかバッファへのリダイレクトだとかgrepの上書きだとか色々楽しい拡張もあるのですが、一番はeshellがLispであること。eshell上で任意のEmacs Lisp式を実行できます。最近Emacs LispやLispに精通してきたので非常に有り難いです。\nそれにファイルを開くときもその後で同じディレクトリのファイルを開くことが多いので一旦 cdしてからfind-fileをするとアクセスし易くて捗ります。もう起動時にeshellが立ち上がるようにして、基本そこから操作するようにしてます。guakeもそんなに使わなくなりました。他の環境でも使えるので安心して依存できます。\nで、ファイルを開くときはどうしてるかというと実はemacsのfind-fileではなくviの:e file-nameです。Emacs上でLispで出来たShellを使いつつviを動かしてます。かなり人を選びますが「EmacsのヘビーユーザーでLispに精通しててviを便利だと思ってる人」は試してみてはいかがでしょうか。\n","categories":["Emacs","Emacs Lisp","Lisp","Shell","vi"],"category_urls":["/categories/emacs","/categories/emacs-lisp","/categories/lisp","/categories/shell","/categories/vi"],"date":"2013-12-13","title":".emacsの整理をした話 + EmacsとViとShellとLispを悪魔合体させたら超絶便利だった","url":"https://KeenS.github.io/blog/2013/12/13/dot-emacs-clean-up/"},
  {"body":"(この記事は Lisp Advent Calendar 7日目のためのエントリです。\n( 6日目 meymaoさんより「Lisperがクリスマスに贈るべきプレゼント三選」)\n( 8日目 athos0220さんよりマクロとクロージャで作る並行プログラミング言語))\nClackのHandlerの書き方についてちゃちゃっと解説します。\nさっくりゆるふわな感じで行くので clack公式だとか チュートリアルだとかも参考にして下さい。とは言ってもCommon Lispな方なら知ってるでしょう。\nClackって？ PerlのPlackやRubyのRackと同じくCommon Lispの統一HTTPサーバーインターフェースです。開発時はHunchentootで、本番はFastCGIでみたいなことが簡単にできます。\nHandlerって？ HunchentootやFastCGIといったバックエンドとClackとの間でリクエストやレスポンスの受け渡しを担当します。さっくり言うとHandlerを書けばClackで使えるサーバーが増える訳です。今(2013-12現在)のところ、Hunchentoot、FastCGI、Apache + mod_lisp2があるようです。\nじゃあ、実際に軽量サーバーの tootのハンドラを書きながら解説しますね\n準備 git clone git@github.com:fukamachi/clack.gitしてclackのソースコードを持ってきます。他のHanderがそうしてるようなので\n clack/clack-handler-toot.asd clack/src/core/handler/toot.lisp  を作ります。coreじゃなくてcontribだろとかそもそも自分のリポジトリに作れよとかは自由にやって下さい。clack/clack-handler-toot.asdは適当に似た名前のやつをコピーすれば良いんじゃないですかね？（適当\n書き方 いたって簡単で、run (app \u0026amp;key debug (port 5000)) -\u0026gt; acceptorとstop (acceptor) -\u0026gt; 多分決まってないを実装すれば良いです。\nとはいってもstopは1行で終わりますがrunは大きく分けて\n . サーバーを立ち上げる . サーバーから渡されたリクエスト(多くの場合requestオブジェクト)をplistにしてappに渡す . appのlist形式の返値を適切な形(多くの場合responseオブジェクト)にしてサーバーに返す . エラーハンドリング  の4つの作業があります。一つ一つ説明していきますね。\n1 サーバーを立ち上げる tootの場合はtoot:start-server (\u0026amp;key handler port)を使いました。スレッド立てるのはclackがやってくれます。はい。\n2 サーバー渡されたリクエスト(多くの場合requestオブジェクト)をplistにしてappに渡す tootの場合、keyのhandlerがrequesutオブジェクトを受け取ってresponseオブジェクトを返せば良いので\n(lambda (req) ..... (call app (handle-request req)) ..... ) って感じでhandle-requestに実装を書きます。\nhandle-requestの内部はreqを clack公式のチュートリアルに載っているプロパティに一つ一つ変換していきます。このプロパティとバックエンドのオブジェクトのスロット名と実際のHTTPヘッダの名前が必ずしも一致しないのが泣き所です。さらに、大抵のサーバーの場合リクエストオブジェクトのスロットの詳細まではドキュメントに載ってないのでソースを参照しながら書くことになります。また、そもそも対応する値が無くて、他の情報を切り貼りして作らないといけなかったり、どうしようもなくて空にしないといけないこともあります。\ntootハンドラは\n(defun handle-request (req) \u0026#34;Convert Request from server into a plist before pass to Clack application.\u0026#34; (let ((content-length (and (request-header :content-length req) (parse-integer (request-header :content-length req) :junk-allowed t))) (port-and-host (get-port-and-host req))) (append (list :request-method (request-method req) :script-name \u0026#34;\u0026#34; :path-info (url-decode (request-path req)) :server-name (car port-and-host) :server-port (cdr port-and-host) :server-protocol (server-protocol req) :request-uri (request-uri req) :url-scheme :HTTP;(request-scheme req) :remote-addr (remote-addr req) :remote-port (remote-port req) :query-string (request-query req) :content-length content-length :content-type (request-header :content-type req) :raw-body (let ((stream (toot::request-body-stream req))) ;(when content-length ;(setf (flex:flexi-stream-bound stream) content-length)) stream) :clack.uploads nil :clack.handler :toot) (loop for (k . v) in (toot::request-headers req) unless (find k \u0026#39;(:request-method :script-name :path-info :server-name :server-port :server-protocol :request-uri :remote-addr :remote-port :query-string :content-length :content-type :accept :connection)) append (list (intern (format nil \u0026#34;HTTP-~:@(~A~)\u0026#34; k) :keyword) v))))) こんな感じに実装されてます。tootからインポートしたものの他、一部ヘルパー関数も使ってますが挙動はまあ、名前から察して下さい。\n3 appの返値のplistを適切な形(多くの場合responseオブジェクト)にしてサーバーに返す appをcallしてやると(status headers body)という形式のlistが返ってきます。statusは数値、headersはplist、bodyはパスネーム又は文字列のリストです。\nさっきはこんな感じで呼んだのでした。\n(lambda (req) ..... (call app (handle-request req)) ..... ) もうお分かりかと思いますが\n(lambda (req) (handle-response (call app (handle-request req))) ) として、実装はhandle-responseに書きます。…が、tootはresponseオブジェクトではなくrequestオブジェクトに変更を加えたものを返すようなので\n(lambda (req) (handle-response req (call app (handle-request req))) ) として、appの返値を元にreqを書き換えます。こちらもあまりドキュメントが無いので頑張ってソース読むしかないです。因みにbodyはパスネームならそのファイルの内容を、文字列のリストならそれぞれを改行(\u0026lt;br\u0026gt;ではなく\\n)で連結したものを返す必要があります。\ntootハンドラの実装載せときますね。\n(defun handle-response (req res) (destructuring-bind (status headers body) res (etypecase body (pathname (multiple-value-call #\u0026#39;serve-file (values req body (parse-charset (getf headers :content-type))))) (list ;; XXX: almost same as Clack.Handler.Hunchentoot\u0026#39;s one. (setf (status-code req) status) (loop for (k v) on headers by #\u0026#39;cddr with hash = (make-hash-table :test #\u0026#39;eq) if (gethash k hash) do (setf (gethash k hash) (format nil \u0026#34;~:[~;~:*~A, ~]~A\u0026#34; (gethash k hash) v)) else if (eq k :content-type) do (multiple-value-bind (v charset) (parse-charset v) (setf (gethash k hash) v) (setf (toot::response-charset req) charset)) else do (setf (gethash k hash) v) finally (loop for k being the hash-keys in hash using (hash-value v) do (setf (response-header k req) v))) (toot::send-response req (with-output-to-string (s) (format s \u0026#34;~{~A~^~%~}\u0026#34; body))))))) です。\n(destructuring-bind (status headers body) res (etypecase body (pathname ...) (list ...))) がテンプレートですね。pathnameのときはtootに丸投げしてlistのときはheadersとかを真面目に処理してます。\n4 エラーハンドリング 早い話が500 internal server errorです。普通、Lispはエラーが起きるとデバッガに落ちますがサーバーは走り続ける必要がるのであらゆるエラーを無視する必要があります。が、しかしデバッグするとき(runのキーワード引数にdebugがありましたね)はデバッガに落ちると嬉しいです。なので例のラムダを少し変更します。\n(lambda (req) (handle-response req (if debug (call app (handle-request req)) (aif (handler-case (call app (handle-request req)) (condition () nil)) it \u0026#39;(500 nil nil))))) これで完成です。\nテスト Clackにはテストが付いてます。テストケース自体はclack/src/core/test/suite.lispに書かれてます。\nclack/t/core/handler/hunchentoot.lispを参考にclack/t/core/handler/toot.lispを作り、clack/clack-test.asdのhunchentootをtootに書き換えたら準備完了です。(ql:quickload :clack-test)しましょう。テストが走ります。そして恐らくエラーが出て止まるでしょう。変な値を返すとサーバーじゃなくてテストの方がエラーで死ぬんですね。\nそしたらclack/src/core/test/suite.lispを開いて期待された値がなんだったかを調べてサーバーを修正します。で、また(ql:quickload :clack-test)の繰り返し。でも一回quickloadしちゃうと読み直してくれないので私は一々M-x slime-restart-inferior-lispしてました。なんか違う気がする。これだけじゃなくてテスト全般。溢れるバッドノウハウ感。\nとりあえずバックエンドにバグがあるとかのどうしようもない場合を除いてテストに全部合格すれば完成です\n完成したら どうしたらいいんでしょうね。分かんないです。clackにpull-req送るんでしょうか。あるいはquicklispに登録?私はとりあえず ブランチに置いてますが恐らく誰も使ってないですし知らないと思います。\nで、何作ればいい？ clackのissueにまだ作られてないものがリストされてます。「自分では需要はないけどなんか作ってみたい」といった奇特な方はそこから試すと良いんじゃないでしょうか。GAEとかmongrel2とか需要ありそうな気がします。\nまとめ 誰得\n","categories":["Advent Calendar","Clack","Common Lisp","Lisp","Lisp Advent Calendar"],"category_urls":["/categories/advent-calendar","/categories/clack","/categories/common-lisp","/categories/lisp","/categories/lisp-advent-calendar"],"date":"2013-12-06","title":"ClackのHandlerの書き方","url":"https://KeenS.github.io/blog/2013/12/06/lisp-advent-calendar-7/"},
  {"body":"暗号化といえばGPGですがEmacsからGPGで暗号化されたファイルを編集しようとすると毎回パスワードを訊かれて鬱陶しいです。これはキーリングを登録することで解決できました。\nStep1 Keyringに登録する Dashboardから[key]で検索すると[パスワードと鍵]が見付かります。左上の[+]で新たにキーリングを追加します。\nGPGを選択します\n必要な情報を入力します。このメールアドレスは実在しなくても作れますが、ブルートフォースかけられたときの警告とかに使われそうなので実在した方が良い気がします。とりあえず後で使うので覚えておいて下さい。\nあとはパスワードのプロンプトが出るので入力して、エントロピーを発生させたら終わりです。\nStep2 ファイルを準備する ここが肝です。ファイルの先頭に\n-*- epa-file-encrypt-to: (my@mailaddress) -*- を挿入します。既存の暗号化されたファイルでも同じです。\nStep3 暗号化する M-x epa-encrypt-fileで暗号化できます。暗号化するファイル名を指定したらキーリングを選べます\nStep4 編集する あとはもう透過的に使えます。でもなんか実験してたらファイル保存できなかった。先にGPGで暗号化してたやつはできたのに。要調査です。\n","categories":["Emacs","GPG","Ubuntu"],"category_urls":["/categories/emacs","/categories/gpg","/categories/ubuntu"],"date":"2013-12-04","title":"UbuntuでEmacsからGPGを透過的に扱う","url":"https://KeenS.github.io/blog/2013/12/04/emacs-gpg/"},
  {"body":"mpdを導入したときにrsyncでパーミッションの問題が発生したと言ってましたが解決策がありました。\nまず基本。\nrsyncでバックアップをとるときは\nrsync -avz dir/ me@remote:backup です。dirのあとの/は重要です。dir自体かdirの中身かを左右します。zshはそこんとこイマイチ理解してないようで悲しいです。因みに-aは-rltogpDの略です。でも今回みたいにパーミッションを含めたくないときは\nrsync -rltogD -vz dir/ me@remote:backup と-pを抜くかと思いきや、\nrsync -avz --no-p dir/ me@remote:backup なる記法があるそうです。便利ですね。\n","categories":["rsync","CLI","小ネタ"],"category_urls":["/categories/rsync","/categories/cli","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2013-11-30","title":"Rsync小ネタ","url":"https://KeenS.github.io/blog/2013/11/30/something-about-rsync/"},
  {"body":"「Makefile書けない人がMake 4.0触ってみた」での発表です。\nまあ、これが殆どなんですけどね。\n Lispmeetup11 from blackenedgold\ngithubのソースも参照下さい。\nあとUStreamにも上がってました。\nhttp://www.ustream.tv/recorded/41155561\nいや、改めて自分の発表聞いてみると酷いwもうちょっと喋るの上手くなりたいです\n会場ではこのあと、「使えるのは良いけど誰が使うんだろーねー」とかの話題になりました。\n次の発表はかにたん( @kazh98)さんからR7 RSの新機能についての発表でした。\n「すごい！」っていうより「今まで無かったんかい！」って機能が満載でしたね。\nその後、chikuさんによるライブコーディングで、お題は(loop repeat 1000 collect (float (/ (random 1000) 1000)))で生成された浮動小数点数1000このヒストグラムを作るものです。データの格納をhashでやるかalistかplistかとかだったり最終的にヒストグラムにするときに数字-\u0026gt;‘*’の変換とかで外野から色々飛んで楽しかったです。\n自然数nが与えられてn個の’*‘を返すってどうするんだろ。formatでできるのかな？(coerce (make-array n :initial-element #\\*) 'string)が個人的には気に入りました。\n12/05追記:(make-string n :initial-elemet #\\*)というもっと直接的な方法がありました。\n懇親会は’80~‘90年代のPCの話で盛り上がって私にはちんぷんかんぷんでした。それ以上に小2でファミコンの改造/ハックをやってたってのは凄いですね。\nその他 cimの開発ぼちぼち進んでます。sysetあたりがまだ手をつけてないです。あとインストーラが動いてくれない。コアダンンプ機能必要なのでは？など。Quicklispのロードって案外重いんですね。\n","categories":[],"category_urls":[],"date":"2013-11-29","title":"Lisp Meet Up #11でLTしてきました","url":"https://KeenS.github.io/blog/2013/11/29/lispmeetup-11/"},
  {"body":"#isucon 参戦記がフォロワーの多い@tagomorisさんとか@nitro_idiotさんとかにツイートされて普段の数十倍のアクセスが来てテンション上がったので近況書きますね。\nisuconの勉強 件の記事でも書いてますけどMySQLとNginXとCapistranoの勉強しました。SQLって書けると案外楽しいですね。あとN+1問題を学んだり、IF EXISTS TRRIGER的な文がなくて殺そうかと思ったり。\nNginXはキャッシュとかですね。キャッシュキーに$cookie_isucon_sessionとか入れてログインしてるユーザーが来ても対応できたので良かったです（小並感\nCapistranoはどうせだからと3.0を使ったのですが調べても2.x時代の情報ばっかり引っ掛かって苦労しました。その代わり、isucon本戦では複数サーバーへのデプロイ機能を存分に使わせて頂きました。ほぼログインしなくても問題ないですね。\n例えば\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  set :application, 'my app' set :repo_url, 'git@bitbucket.org:me/myrepo.git' set :deploy_to, '/home/me/app' set :scm, :git set :deploy_via, :remote_cache namespace :nginx do task :reload do on roles(:web) do execute :sudo, 'service nginx reload' end end task :restart do on roles(:web) do execute :sudo, 'service nginx restart' end end task :start do on roles(:web) do execute :sudo, 'service nginx start' end end end   こんな感じです。で、もう一つ\n 1 2 3 4 5 6 7 8 9  set :stage, :production server '123.4.5.67', user: 'me', roles: 'web' server '123.4.5.68', user: 'me', roles: 'web' server '123.4.5.69', user: 'me', roles: 'web' set :ssh_options, { keys: %w(~/.ssh/id_rsa), forward_agent: true, auth_methods: %w(publickey) }   を書いておけばこの3台のサーバーに一斉にデプロイしてくれます。(上の例だとnginxですが、まあいいでしょう。)\nShibuya.lisp Lisp Meet Up #10で発表してきました。内容はfluentdをCommon Lispから使う話。\nスライド\n Common Lisp でビッグデータを作ろう from blackenedgold\nUstreamは見つかりませんでした。てへペロ\n恐らく、Log4CLはやりたいことと目的が違いますね。全く別のロギングフレームワークを作るのが良さげな気がします。isuconの懇親会で開発者の@tagomorisさんにアドバイスも頂きましたし作るかもしれません。\nmpd 以前、mplayer2が正常に動作しないとかぼやいてましたが、結局あきらめました。で、代わりに Music Player Daemon(MPD)なるものを見付けて、しかもRaspberry Piで動き、iPod/Androidから操作できるとのことで、導入しました。\nMPDはまさしくRaspberry Piのような機器向で、音楽を鳴らすサーバーと操作するクライアントが完全に分かれてます。\n$ sudo apg-get install mpd mpc とかでRSPiに入れた気がします。クライアントはAndroidはMPDroid、iPodはMPoDっていうアプリです。\nscpで手元の曲をRSPiコピーし、iPodから繋ぐも曲が見えない。色々試した結果、scpでコピーしたときにパーミッションの問題が出てたようなのでそこを解決したらちゃんと動きました。\n動画(iPod)\n 黒ばっかで見づらくて申し訳ありません。iPodからではなくスピーカから音が出てるのが分かりますかね？思ったより音が入ってないので分りづらいですね（汗\nCIM Shellyを使って Common Lispスクリプトをexecutableにしようってのをやってましたが少しshellyが求めているのと違うようだったので「シェルスクリプトでshelly的な物を実装しよう！ついでにrvmみたいにバージョン管理できたら嬉しいな！！」って思い付きで Common Lisp Implementation Manager(CIM)を作り始めました。まだCLISP, ECL, GCLのインストールぐらいしかできてません。\n初めてシェルスクリプトを書き、初めてBourne Shellを触り(普段はzsh)、早くも挫折しそうです。今めっちゃシェルスクリプトの勉強してます。目的はImplementationの管理じゃなくて統一インターフェースのclコマンドなのにそこが全然進んでないですね。qlに至っては1行も書いてない。まあ、clを使って書くつもりなのでclが出来ないことにはどうしようもないんですが。\nsysetとかネーミングセンスが無かったり(発音しずらい。シセット…サイセットって読もうかな)ダウンロードしたアーカイブのチェックサムとか全く見てなかったり色々ツッコみたくなりますが温かい目で見て下さい。気に入ったらpull-reqとかして下さい。\nOctomacs Octomacsに一回pull-req送ってからコミッタ気取りのκeenですが、octomacs-previewとoctomacs-deployを実装しました。C-uをつけるとgenerateが付いてきます。テストをしてない（できない？）+サーバーを殺す(octomacs-preview-quitとかの名前かなあ。現状は*octomacs preview*バッファをkill-bufferすればいい)コマンドを実装してないのでpull-reqは投げてませんが使ってみたい方は こちらをどうぞ。まあ、今からpushするんですがね。ちゃんとこの記事もoctomacs-new-postから始まり、octomacs-previewで確認しつつoctomacs-deployでデプロイしました。あとは過去の記事を編集するoctomacs-editを実装すれば完璧ですね。\nこんなかんじです。CIMがんばります。\n","categories":["CIM","Common Lisp","Emacs","Octomacs","fluentd","mpd","CLI"],"category_urls":["/categories/cim","/categories/common-lisp","/categories/emacs","/categories/octomacs","/categories/fluentd","/categories/mpd","/categories/cli"],"date":"2013-11-13","title":"ここ１ヶ月くらいの近況","url":"https://KeenS.github.io/blog/2013/11/13/what-recent/"},
  {"body":"しばらく間が空きました。まあ、その間のことはいつかまとめて書きます。今回は isucon#3について。\n先日、isucon#3の予選を突破したと書きましたが、日曜にその決勝戦があったので報告です。\n準備 とりあえずyokoteさんが予定が入って参加できないので@c0umeさんと二人で毎週会って予選の問題を解き直しつつSQLの勉強とかやってました。MariaDBを試したりもしましたが大して変んないねーとか。最終的に4万点くらいになったのかな？あとisucon#2で複数台構成の練習とか地味にデプロイツールCapistranoのお勉強とかもしてました。非常に便利です。\n当日 サークルを休む許可も貰えたので何事も心配なく10時にヒカリエに集合。名札とかもらって本格的な感じ。 お題のアプリは画像版ツイッターで、処理的には投稿された画像を生/中/小にサイズ変更して返すのがほとんど。htmlはインデックスだけであとはjson APIですしDBまわりも画像のアクセスレベルとユーザーのフォロー関係程度で、必要最低限といった感じ。単純にファイスサイズで攻めてきましたね。\n因みにこれ、ストーリーとしてはエンジニア二人で作って騒いでたら社長が聞き付けて「18時に大規模プロモーションかけるからそれまでに対策しといてね。あ、サーバーは4台増やしといたよ」ってなっててそれを見た瞬間のみんなの反応が\n 社長を殺そう #isucon\n— tagomoris (@tagomoris) November 9, 2013\n とかでしたw\nそうそう、そんなストーリーなもんでサーバー5台中1台にしかアプリがデプロイされてない状態でスタートです。\nやったこと @c0umeさんがサーバーセットアップしてる間に私がアプリを読んできになったところをスカイプに張っていきました。\n何も考えずにとりあえずnginxを野良ビルドしてgzip配信を有効にしようとするも、なぜかnginx.confが上手く機能せずにハマる。結局conf.d以下を読んでた部分が悪さをしてたと判明。ようやくアプリ側にとりかかる。\nとりあえずリクエストの度に画像を変換してるのでそれをどうにかしようということに。POSTされた時点で変換する方針だったのですが、私は変換した画像の「パスネーム」をDBに突っ込もうって思ってたのですが@c0umeさんは画像の「バイナリデータ」を突っ込もうとしてたらしく、意思疎通ができずに若干揉めました。\n結局、1台リバースプロキシ、3台app、 1台DBの構成で、appで画像のPOSTを受けたら3サイズにコンバートしてDBに突っ込むことに。ですがとりあえず段階を踏もうということで第一段は画像をblobとしてMySQLにツッコみます。第二段でコンバートして突っ込む、第三段でさらにgzip圧縮して突っ込むことにしました。\n私がapp側、@c0umeさんがDB側でやりました。\n外部プロセスを呼んでると遅いと聞いたのでRMagickを使って変換するようにして、さらにファイルに書き出さずにMagick::ImageList#from_blobと#to_blobを使って書き換えました。\n今回、RMagickを初めて使ったのですが、ハマることハマること。Magick::ImageList#crop非破壊的であったり、関連ブログに書いてあるメソッドがないとか言われたり。最終的にDBが終わった@c0umeさんにも手伝ってもらってバグ取りが完了し、ベンチマークが走るようになった時点でもう終わり近く。大きな変更はやめてキャッシュとかレスポンスだけ返して裏で処理を走らせるとかをやりましたがどれもベンチマークが巧妙に作られてて失敗に終りました。あとUnicornに謎のエラーが出続けてましたが特にベンチに影響はなかったので放置しました\nそれで初期スコアが1100だったのが5400程度になりました。最後20分くらいはchkconfigとかでfailしないよう確認作業をしてタイムアップ。暫定学生1位、全体で7位だったかと思います。\nfailしないことだけを祈って1時間後の結果発表を待ちます。本計測は3分ですし謎のエラーもありましたし不安要素はいっぱいありました。\n結果 failしませんでした。よかった。上のチームがfailしたらしく、最終順位は学生1位、全体6位でした。まあ、failしなかったチームは7チームしかいなかったのでなんとも言い難いですが。\nスコア的には3位と2倍差だったので案外良い線いってたのかもしれません。\nそれで、タイトルにあるように学生賞もらいました。\nこの5万は2万ずつ二人で分けて、あとの1万でyokoteさんと3人で肉を食べに行きます。\n因みに私はこういう風に使いました。\nその後懇親会ではGoとかnodeの人達がライブラリが若くてバグがあって苦しんだりしてた話を聞きました。fujiwara組長のところには行けませんでした。\n感想 たのしかったです（小並感\nベンチマークツール自体がラウンドロビンでリクエスト飛ばしてくるのでリバースプロキシ不要でしたね。あとはあせりすぎて手汗でタッチパッドの誤反応が頻発したり挙句なぜかカーネルがCPU100%使い始めて作業できなくなったりして冷や冷やしました。@c0umeさんには多大な迷惑お掛けしました。そのPC寿命じゃね？とか言われたり。\n来年は胸を張れるようなスコアを出したいですね。LINE、カヤック、データホテルのみなさんありがとうございました\nその他 κeenは就活生です。RubyかLispでできる仕事探してます。\nあとamazonほしいものリストも上げときますね。http://www.amazon.co.jp/registry/wishlist/TA077537OIUP\n","categories":["ISUCON"],"category_urls":["/categories/isucon"],"date":"2013-11-11","title":"チーム「銀杏絶滅しろ」でisucon学生賞もらってきました","url":"https://KeenS.github.io/blog/2013/11/11/isucon-final-stage/"},
  {"body":"ISUCON#3の予選に参加してきた話です。\nISUCON(Iikanjini SpeedUp CONtest)とは椅子を投げないなどの一部のルールを除き、基本なんでもアリのWebアプリケーションチューニングコンテストです。\nなんで私がこんなのに参加するかというと、サークルのOBさんから告知があり、8月に学生向けのISUCON夏期講習会に参加したからです。第３回となる今回は学生枠を作るとのことで事前に学生のレベルを上げておこうという方針だそうです。\nその講習会でコテンパンにやられてめげつつも、もう一回チャレンジしようということで夏期講習会で知りあったasamiさんとその友達のyokoteさんでチームを組んで参戦しました。\nちなみにこのチーム、予選3日前にSkype会議で結成したもので、予選当日も各自自宅にいてSkypeで連絡を取ってたので私はyokoteさんとはまだ会ったことありません←\n準備 事前の話しあいではasamiさんがAWSの準備からgit(bitbucket)、ssh鍵の設定までやってくれることになりました。私も本来ならISUCON#2で練習をしておくべきだったのですが、サークルとかを言い訳に、ISUCONの記事に目を通すだけに終りました。\n当日 10時に開始しました。10時40分に起きました←\n私が起きた頃にはasamiさんが色々設定を済ませていたので問題のアプリケーションをgit cloneして公開鍵をSkypeにペタっと貼って参戦。アプリを読むにMarkdownでメモを投稿できるもの。\nフムフムってなってたらsslのバージョン問題でログインできてなかったyokoteさんも参戦し、asamiさんがmy.cnfをいじってスコアが\n900→2500\nとなりました。スゲー。あ、言語はasamiさんとyokoteさんが書けるperlを選択。私は1ミリも読めませんがサーバーをいじる気だったので気にしませんでした。\nで、私がフロントサーバーをapacheからnginxに移行し、staticファイルをnginxから出すようにして、さらにキャッシュするようにし、ログを消したら\n2500→2800\nとなりました。後で考えるとこのログを消したのまずかったですね。asamiさんがなんかpythonのツールを使ってトラフィック監視してたのでいっかなーって思ってたんですが。\nその間asamiさんがslow queryのログを吐かせてボトルネックを見付けようとしますが、どれも平均的に重い。ソートに使われてるcreated_atにyokoteさんがインデックスを貼ってくれたりしましたが大した改善はみられず。後にこのインデックスはベンチマークが初期化するときに消されてるのではということが発覚しました。\nあとは私がworker_connectionをいじったりasamiさんがmemcachedを使ってクエリの数を減らしたりyokoteさんがストレージエンジンをarchiveに変えたり色々しましたが努力虚しくスコアは改善しませんでした。\n外部でmarkdownコマンドを呼んでるところを(それがperl製のスクリプトだったので)アプリに埋め込んでしまえばちょっとは速くなるかなと思いましたが私はperlをいじれませんし大差ないだろうからいっかと思って放置してたのですが、後で聞くと案外それでスコア伸びたそうです。nginxのログを見てれば気づいたことだったのに…\nということで大したこともできず予選敗退です。因みに1位とは10倍くらいの差がありました。\n振り返って 後で他の方のブログとかを見るとそんな手があったのかとかそこに罠があったのかとか全然気づかなかったことがたくさんありました。とりあえず勉強しなきゃって思ったのは + redis + プロファイラ + デプロイツールですね。asamiさんがデプロイツールを用意してくれてたのですが私には使いこなせず、折角git管理してたのにその利点を生かせませんでした。(私は手動デプロイしてました)\nあとはボトルネックから攻める、redisで書き換えるといったこをとほとんどの上位チームがやってたのでそこは勉強したいです。\n来年も開催されるなら是非参加したいですね。\n追記 まさか…まさかこんなことになるとは…\n学生枠上位3チーム中2チームが動作検証で失格となり、繰り上げで私達のチームakyが予選通過となりました。ビックリすね。終ったあとasamiさんがしっかり動作確認してからAMIを提出してくれたからでしょう。\n6割くらい嬉しいのですが、失格となったチーム魔王は夏期講習会で一緒だったメンバーのチームで、内心お祝いしてたのにこんなことになって残念です。スコアも正常に動作していたら16000点だったそうです。\nあと1ヶ月、精進して本戦で晒しものにならないよう頑張ります。\n","categories":["ISUCON"],"category_urls":["/categories/isucon"],"date":"2013-10-09","title":"ISUCON#3予選に参加しました","url":"https://KeenS.github.io/blog/2013/10/09/isucon-qualifying-event/"},
  {"body":"tiarraに ercで接続したときの/loadの問題。\ntiarraは有名なircプロキシ。ercはEmacs上で動くircクライアント。これらを使っているとtiarraが自動でログインしてくれないのでおかしいなと思っていたらtiarraの自動ログインモジュールを有効にしていなかった模様。\n書き換えていざ設定を反映しようとすると若干困りました。どこに/loadと打てばいいんだろ。\n最初に誘導されるバッファ(ircバッファ名がプロキシサーバー名になってるやつ)に/loadと打つと\nERC\u0026gt; /load Incorrect arguments. Usage: /LOAD line Load the script provided in the LINE. If LINE continues beyond the file name, the rest of it is put in a (local) variable `erc-script-args\u0026#39;, which can be used in Emacs Lisp scripts. The optional FORCE argument is ignored here - you can\u0026#39;t force loading a script after exceeding the flood threshold. ですって。ああ…。/loadコマンドがercに食われてる…\n流石に解決策あるだろって思って調べたら\n/quote load だそうです。\nERC\u0026gt; /quote load -192.168.1.4- *** Reloaded configuration file. -192.168.1.4- *** Module Channel::Join::Connect will be loaded newly. はい。ちゃんとloadしてくれました。\n以上小ネタでした。\n","categories":["Emacs","IRC","備忘録","小ネタ"],"category_urls":["/categories/emacs","/categories/irc","/categories/%e5%82%99%e5%bf%98%e9%8c%b2","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2013-10-06","title":"Tiarraにercで接続したときの/loadの問題","url":"https://KeenS.github.io/blog/2013/10/06/tiarra-erc/"},
  {"body":"Emacsの標準ライブラリdired.elを読んでたら色々発見があったのでメモ兼dired-modeとはなんじゃらほいって方にも一から解説してみます。\nとは言ってもいきなり解説しなくて申し訳ないのですが、最初に\n(ffap-bindings) を設定しておきましょう。C-x C-fが非常に便利になります。だいたいの方が設定してるかと思いますが、まだという方はinit.elに書いて保存し、最後の)の後にカーソルを持っていってC-x C-eしましょう。設定が反映されます。この設定でC-x C-fの入力がファイル以外も受け付けてくれますし、カーソルにポイントされてるファイルやURLをデフォルトで開こうとしてくれます。\n…よし。じゃあ解説始めますよ。C-x C-f ~/してみて下さい。上の設定をしていたらディレクトリでも開ける筈です。するとホームディレクトリがls -alされた感じのバッファが出てくると思います。\nこれがdired-modeです。これは普通にn(C-nでも可)やp(C-pでも可)で移動して、Enterでそのファイルやディレクトリを開けます。これだけでも十分便利なのですが、ここからさらにファイル操作までできます。\n適当なファイルにカーソルを合わせてCするとコピー先を聞かれるので、入力してあげるとコピーしてくれます。複数ファイルをコピーしたいなら、コピーしたいファイル上でmしてマークを付けて、Cすれば一括でコピーできます。\n勿論、他にもコマンドはあります。同じような使い方のできる代表的なものを挙げると、\n   コマンド 操作(実行されるLinuxコマンド)     C コピー(cp)   R リネーム/移動 (mv)   D 削除(rm)   M 権限操作(chmod)   G グループ変更(chgrp)   O 所有権変更(chown)   Z 圧縮/展開(compress/uncompress/gunzip/bunzip/unzip)   B (*.elファイルの)バイトコンパイル   ! 任意のコマンドの実行。デフォルトで空気読んだコマンドになってる。    他にも無数に操作はありますがファイル操作はこんなものでしょう。あとはバッファを閉じるqや親ディレクトリに移動する^、バッファの更新を行なうg、マークを外すu(Uで全解除)を覚えていれば操作には困らない筈です。\nが、頻繁に使っているとより良く使いたくなります。そこで今回見付けた設定を紹介します。\nまず\n(add-hook \u0026#39;dired-load-hook (lambda () (define-key dired-mode-map \u0026#34;r\u0026#34; \u0026#39;wdired-change-to-wdired-mode))) から。これはdired-modeでrするとバッファがエディタブルになり、ファイル名を普通に変更できます。そのままC-x C-sすればリネームの終了です。\n普通にEmacsの編集コマンドが使えるので M-%とかで一括拡張子変更とかC-x r tでファイル名にプリフィクスつけたり自由自在です。\n次に\n(setq dired-listing-switches (purecopy \u0026#34;-Ahl\u0026#34;)) Emacsがdired-modeを表示するとき、実際に裏で ls -alを走らせているのですが、そのときのオプションを変更できます。但し内部で-lの結果を利用してるのでこれは必須です。しかしそれ以外は自由に設定できます。因みにWindowsでもEmacsがエミュレートしてくれるので設定可能ですが、一部未実装のものもあるそうです。\n頻繁に使うなら\n(setq dired-dwim-target t) もお勧めです。\nこれを設定しておくと、ウィンドウを分割して左右にdiredバッファを開いているとき、RやCのデフォルトの宛先がもう片方のディレクトリになります。伝わりますかね？\nのようにdiredでディレクトリA, Bを開いてるときにディレクトリAでファイルのコピーやら移動やらをするときにデフォルトでBに移動やコピーを行なうようになります。いくつかのファイルをディレクトリ間で移動させるときに非常に便利ですね。\nあ、C-x C-f /ftp:user@ftp-server:/path/to/dirでFTPサーバーのディレクトリ/ファイルにもアクセスできるのは御存じですよね？これと組合せるとEmacsが割と使い易いFTPクライアントに大変身!\nあとは私がどうしても欲しかったtarballですね。\n(defun dired-tar (tarname files \u0026amp;optional arg) \u0026ldquo;A dired-mode extension to archive files marked. With prefix argument, the tarball is gziped.\u0026rdquo; (interactive (let ((files (dired-get-marked-files)))\n (list (read-string \u0026amp;quot;Tarball name: \u0026amp;quot; (concat (file-relative-name (car files)) \u0026amp;quot;.tar.gz\u0026amp;quot;)) files \u0026amp;quot;P\u0026amp;quot;)))   (let ((tar (if arg\n (if dired-guess-shell-gnutar (concat dired-guess-shell-gnutar \u0026amp;quot; zcf %s %s\u0026amp;quot;) \u0026amp;quot;tar cf - %2s | gzip \u0026amp;gt; %1s\u0026amp;quot;) \u0026amp;quot;tar cf %s %s\u0026amp;quot;))) (shell-command (format tar tarname (mapconcat 'file-relative-name files \u0026amp;quot; \u0026amp;quot;)))))  (add-hook ‘dired-load-hook (lambda () (define-key dired-mode-map \u0026ldquo;T\u0026rdquo; ‘dired-tar))) \nこれでtarballにまとめたいファイルをマークしてTすればまとめてくれます。C-u Tするとgzip圧縮までしてくれます。因みに解凍/展開はファイル上で!するとデフォルトコマンドが展開(tar xzvfなど)になってるので専用コマンドは必要ありません。補足ですが個人用なのでテストとかしてません。一旦御自身で動作テストなどをされてから実行されることをお勧めします。\n他にも色々なコマンドがたくさんあったので興味のある方は探求してみて下さい。\n","categories":["Emacs","Emacs Lisp","Lisp"],"category_urls":["/categories/emacs","/categories/emacs-lisp","/categories/lisp"],"date":"2013-10-04","title":"Emacsのdired-modeを使い易くする","url":"https://KeenS.github.io/blog/2013/10/04/emacs-dired/"},
  {"body":"MPlayerを使ってBGMを流すコマンドを作ろうとしたときに困ったことがいくつかあったので誰か解決して下さい。\nスクリプトは3年前で更新がとまってるmplayer-rubyを使ってRubyでmplayerを叩く方針。\n案の定バグに当りました。スペースの入ってるファイルをうまく処理できない。これは内部的にシェルを呼んでるのですが、そのときにシェルエスケープをしてないためです。require 'shellwords'しとけばString#shellescapeメソッドが追加されるのでmplayer-rubyの何箇所かにあるfileをfile.shellescapeすれば解決しました。\nさらにDirty Hack。複数ファイルをload_fileで渡してると詰まるようなので思いきってMPlayer::Slave#initializeを改造して引数に再生ファイルの配列(元々はファイル名の文字列)を渡すようにしました。\nこれで\n#!/usr/bin/env ruby -Ku\n* coding:UTF-8 * require \u0026lsquo;mplayer-ruby\u0026rsquo; require \u0026lsquo;libnotify\u0026rsquo;\nclass MPlayer::Slave def now_playing summary = \u0026ldquo;\u0026rdquo; summary += get(:meta_title).chomp summary += \u0026ldquo; \u0026ndash; \u0026rdquo; + get(:meta_artist).chomp body = \u0026ldquo;NowPlaying\u0026rdquo; Libnotify.show(body: body, summary: summary) end end\nmusic = \u0026ldquo;/your/path/to/music/directory/\u0026rdquo; playlist = File.read( music + \u0026ldquo;BGM.list\u0026rdquo;).split(\u0026rdquo;\\n\u0026rdquo;).map{|f| music + f }.shuffle player = MPlayer::Slave.new playlist player.loop Signal.trap(:INT) {player.quit;exit} Signal.trap(:KILL) {player.quit;exit} player.now_playing while line = player.stdout.gets player.now_playing if line =~ /playback/ end \nが動くようになりました。\nしかし一つ問題がありまして、再生が1曲目で止まっちゃいます。loopを指定してるのにです。mplayerを直接叩いてみるに、mplayerのバグっぽい…複数ファイル指定したときは本来なら全曲1回は再生してくれるはずなのに再生しませんし-loop 0オプションガン無視。今回入れたのはUbuntuのapt-getで入るやつで、バージョン(?)は「MPlayer2 UNKNOWN © 2000-2012 MPlayer Team」だそうです。\nUbuntuはパッケージが古いことが往々にしてあるので冷静に自分でビルドしようとしてもfridibiがないとかで怒られる。\nどなたか解決方法御存じないですか???\n追記 -loop -1を渡すとループしてくれました。それドキュメントと逆…\n","categories":["MPlayer","MPlayer2","Ruby"],"category_urls":["/categories/mplayer","/categories/mplayer2","/categories/ruby"],"date":"2013-09-29","title":"MPlayerがうまく動かない","url":"https://KeenS.github.io/blog/2013/09/29/mplayer/"},
  {"body":"どうもGithubのgistのURLが変わってる(?)っぽくてOctopressのgistプラグインが動いてくれなかったので修正しました。\nOctopressの最新版でも修正されてなかったっぽいです。自分の使い方が悪かったのかなぁ…\n原因は生のソースコードを取ってくるときに\u0026quot;https://raw.github.com/gist/#{gist}/#{file}\u0026quot;にアクセスするんですがそいつが404返すんですね。ブラウザからgistにいって”view raw”をクリックすると\u0026quot;https://gist.github.com/#{gist_id}/#{gist}/raw/#{file}\u0026quot;でした。gist_idってかGithubアカウントです。この辺、挙動が怪しくて、gist_idがなくてもリダイレクトしてくれたりしてくれなかったりします。APIによって違うようです。問題のrawAPIはリダイレクトしてくれないので割と大きめにプラグインを書き換える必要がありました。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129  diff --cc plugins/gist_tag.rb index 1620345,0000000..58acd2a mode 100644,000000..100644 --- a/plugins/gist_tag.rb +++ b/plugins/gist_tag.rb @@@ -1,105 -1,0 +1,105 @@@ +# A Liquid tag for Jekyll sites that allows embedding Gists and showing code for non-JavaScript enabled browsers and readers. +# by: Brandon Tilly +# Source URL: https://gist.github.com/1027674 +# Post http://brandontilley.com/2011/01/31/gist-tag-for-jekyll.html +# +# Example usage: //embeds a gist for this plugin + +require 'cgi' +require 'digest/md5' +require 'net/https' +require 'uri' + +module Jekyll + class GistTag \u0026lt; Liquid::Tag + def initialize(tag_name, text, token) + super + @text = text + @cache_disabled = false + @cache_folder = File.expand_path \"../.gist-cache\", File.dirname( __FILE__ ) + FileUtils.mkdir_p @cache_folder + end + + def render(context) - if parts = @text.match(/([a-zA-Z\\d]*) (.*)/) - gist, file = parts[1].strip, parts[2].strip - script_url = script_url_for gist, file - code = get_cached_gist(gist, file) || get_gist_from_web(gist, file) ++ if parts = @text.match(/([a-zA-Z]*) ([a-zA-Z\\d]*) (.*)/) ++ gist_id, gist, file = parts[1].strip, parts[2].strip, parts[3].strip ++ script_url = script_url_for gist_id, gist, file ++ code = get_cached_gist(gist_id, gist, file) || get_gist_from_web(gist_id, gist, file) + html_output_for script_url, code + else + \"\" + end + end + + def html_output_for(script_url, code) + code = CGI.escapeHTML code + \u0026lt;\u0026lt;-HTML +\u0026lt;div\u0026gt;\u0026lt;script src='#{script_url}'\u0026gt;\u0026lt;/script\u0026gt; +\u0026lt;noscript\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#{code}\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/noscript\u0026gt;\u0026lt;/div\u0026gt; + HTML + end + - def script_url_for(gist_id, filename) - url = \"https://gist.github.com/#{gist_id}.js\" ++ def script_url_for(gist_id, gist, filename) ++ url = \"https://gist.github.com/#{gist_id}/#{gist}.js\" + url = \"#{url}?file=#{filename}\" unless filename.nil? or filename.empty? + url + end + - def get_gist_url_for(gist, file) - \"https://raw.github.com/gist/#{gist}/#{file}\" ++ def get_gist_url_for(gist_id, gist, file) ++ \"https://gist.github.com/#{gist_id}/#{gist}/raw/#{file}\" + end + - def cache(gist, file, data) - cache_file = get_cache_file_for gist, file ++ def cache(gist_id, gist, file, data) ++ cache_file = get_cache_file_for gist_id, gist, file + File.open(cache_file, \"w\") do |io| + io.write data + end + end + - def get_cached_gist(gist, file) ++ def get_cached_gist(gist_id, gist, file) + return nil if @cache_disabled - cache_file = get_cache_file_for gist, file ++ cache_file = get_cache_file_for gist_id, gist, file + File.read cache_file if File.exist? cache_file + end + - def get_cache_file_for(gist, file) ++ def get_cache_file_for(gist_id, gist, file) + bad_chars = /[^a-zA-Z0-9\\-_.]/ + gist = gist.gsub bad_chars, '' + file = file.gsub bad_chars, '' - md5 = Digest::MD5.hexdigest \"#{gist}-#{file}\" - File.join @cache_folder, \"#{gist}-#{file}-#{md5}.cache\" ++ md5 = Digest::MD5.hexdigest \"#{gist_id}-#{gist}-#{file}\" ++ File.join @cache_folder, \"#{gist_id}-#{gist}-#{file}-#{md5}.cache\" + end + - def get_gist_from_web(gist, file) - gist_url = get_gist_url_for gist, file ++ def get_gist_from_web(gist_id, gist, file) ++ gist_url = get_gist_url_for gist_id, gist, file + raw_uri = URI.parse gist_url + proxy = ENV['http_proxy'] + if proxy + proxy_uri = URI.parse(proxy) + https = Net::HTTP::Proxy(proxy_uri.host, proxy_uri.port).new raw_uri.host, raw_uri.port + else + https = Net::HTTP.new raw_uri.host, raw_uri.port + end + https.use_ssl = true + https.verify_mode = OpenSSL::SSL::VERIFY_NONE + request = Net::HTTP::Get.new raw_uri.request_uri + data = https.request request + if data.code.to_i != 200 + raise RuntimeError, \"Gist replied with #{data.code} for #{gist_url}\" + end + data = data.body - cache gist, file, data unless @cache_disabled ++ cache gist_id, gist, file, data unless @cache_disabled + data + end + end + + class GistTagNoCache \u0026lt; GistTag + def initialize(tag_name, text, token) + super + @cache_disabled = true + end + end +end + +Liquid::Template.register_tag('gist', Jekyll::GistTag) +Liquid::Template.register_tag('gistnocache', Jekyll::GistTagNoCache)  なんかOctopressのブランチが面倒だったりmagit.elの使い方がよく分らなかったのでアレですが伝えたいことは伝わるdiffだと思います。\n見ての通りgist_idというパラメーターを追加してリクエストURLをちょこっと書き換えただけです。この修正を加えたあとは\n{% gist KeenS 6688683 script.lisp %} で使えます。\n本当にこれでいいのかなあ…なんか違う気がするなぁ。表示もイマイチだし。けどこれしかないのだから仕方がないですね。正確な情報を持ってる方いらっしゃいましたらコメントお願いします。\n追記 http://rcmdnk.github.io/blog/2013/05/06/blog-octopress/ にあるエントリを見て変更加えました。やり方は貼られてあるdiffを*scratch*バッファにコピー、M-x ediff-patch-fileでパッチ適用しました。\nしかしどうもパッチの元のバージョンが古いらしく、何度もエラー出しながら手でパッチファイルを修正しました。もうちょっとパッチに慣れないとな…\nしかも苦労してパッチ適用したのに表示変わらないなーって思ってたらどうもCleanpressはsass/partialを読み込まないようなので無駄骨でした。sass/parts/_syntax.sassをひたすら様子見ながら修正しました。\ndiffは…いいや。希望があったら晒します。\n","categories":["GitHub","Octopress","Ruby"],"category_urls":["/categories/github","/categories/octopress","/categories/ruby"],"date":"2013-09-26","title":"Octopressのgistプラグインが動かなかったので修正した","url":"https://KeenS.github.io/blog/2013/09/26/patch-to-gist-plugin/"},
  {"body":"コマンドラインからCommon Lispの関数を実行できる Shellyを使ってCommon Lispファイルを実行形式にしてみました。Shellyは\n$ shly + 1 2 3 みたいに関数を実行できます。\nモチベーションとしては、 Shellyの作者深町さんがTwitterで「Shellyでloadを使うとスクリプトみたいに実行できる」と発言していたのがきっかけで、Shebangを無視できればUNIX系ではExecutableにできるのでは？と思いついてやってみました。\nreadしてevalして…とか考えてましたが、loadにstreamを渡せるようなので案外簡単にできました。\n(in-package :shelly) (export (defvar argv nil)) (in-package :cl-user)\n(defun script (file argv) \u0026ldquo;Execute a file as script ignoring shebang\u0026rdquo; (setf shelly:argv argv) (let* ((in (open file :if-does-not-exist :error)) (first-char (read-char in)) (second-char (read-char in))) (cond ((and (char= first-char ##) (char= second-char #!)) (read-line in)) (t (unread-char second-char in) (unread-char first-char in))) (load in) (values))) \nコマンドライン引数を受け取るために*argv*という変数を用意してます。\nこんなことを~/.shelly/Shellyfileに書いておき、Lispの初期化ファイルに\n#+shelly (load \u0026#34;~/.shelly/Shellyfile\u0026#34;) と書いてます。この~/.shelly/ShellyfileにはShelly向けの関数を溜め込んでいく予定です。\nあとは\n 1 2 3 4 5  #!shly script (defun hello () (format t \"Hello ~a~%\" (first shelly:*argv*))) (hello)   をfoo.lispに書き込めば\n$ chmod u+x foo.lisp $./foo.lisp κeen Hello κeen と実行できます。勿論、\n$shly script foo.lisp κeen としても同じです。一部の処理系ではこのようなことが出来ますが、コマンドライン引数の渡し方とかも処理系依存なのでポータブルに書くなら一つ試してみてはいかがでしょうか。\n","categories":["Common Lisp","Lisp","Shelly","CLI"],"category_urls":["/categories/common-lisp","/categories/lisp","/categories/shelly","/categories/cli"],"date":"2013-09-26","title":"Shellyを使ってCommon LispファイルをExecutableにする","url":"https://KeenS.github.io/blog/2013/09/26/shelly-script/"},
  {"body":"この度、 Google Common Lispスタイルガイドが 日本語になりました。\n私が見付けた時点でほとんど日本語になってたのですが、ちょいちょい訳し残しがあったのでお手伝いをして、とりあえず英文は消えました。\nただまあこれで完成かというとそうでもなく、第一段階で「とりあえず」日本語になっただけ。第二段階がまだ残ってます。直訳も多々ありますし記法が統一できてなかったりします。\nですがこれで英語が苦手な方でも読めるかと思いますので読んでみて、変なところがあったらじゃんじゃんPull-Req送って下さい。マスターリポジトリは@massoさんの https://github.com/g000001/google-common-lisp-style-guide-jaです。コメントに元の英文とか訳者のコメントとか残ってるので日本語が訳わかめな状態だったらそっちの方が分り易いかもしれません。\nみなさん第二段階のご協力お願いします。\n","categories":["Common Lisp","Lisp","ドキュメント"],"category_urls":["/categories/common-lisp","/categories/lisp","/categories/%e3%83%89%e3%82%ad%e3%83%a5%e3%83%a1%e3%83%b3%e3%83%88"],"date":"2013-09-21","title":"Google Common Lispスタイルガイド","url":"https://KeenS.github.io/blog/2013/09/21/google-commonlisp-style-guide/"},
  {"body":"githubで共同作業してたらいろいろ困ったことがあったのでそのときのメモ。はじめてやって困ったことなので経験ある人には常識なのかもしれません。\nマスターリポジトリに追従する マスターをフォークして自分のレポジトリで作業、終ったらマスターにpull-reqという流れで作業してました。するとマスターが変更されたときに自分のリポジトリに反映させる必要があります。そのときは http://qiita.com/xtetsuji/items/555a1ef19ed21ee42873を参考に、\n$ git remote add upstream git@github.com:g000001/google-common-lisp-style-guide-ja.git $ git fetch upstream $ git merge upstream/master でできました。\nPull-Reqを正しく送る まず、masterでpull-req送るととりこまれるまで自分のマスターへのコミットが反映され続けるんですね。それで一回失敗。\nじゃあ、ということでブランチを切ることに。するとまた問題が。まあ、自分がアホっていったらアホなんですけど\n_A_ _B_ _C_ *_/ ___\\A\u0026#39;/___ \\B\u0026#39;/___\\C\u0026#39;_HEAD みたいなブランチの作り方してしまいました。A,B,Cそれぞれでpull-req送ったんですけど当然\nA : A B : B-A\u0026#39; C : C-B\u0026#39;-A\u0026#39; みたいなヒストリのまま送られるわけです。A,B,Cは同じファイルの違う箇所への変更なのでヒストリを\n_C_ /_B_ /_A_ *_/ ______ HEAD のようにしたいわけです。magit.elさんにお助け願おうかと思いましたが、そもそも出来るか分らないのでTwitterで投げてみたところ、@mod_poppo氏に助けていただきました。git resetとgit cherry-pickでできます。\nAのブランチは問題ないのでBでやると、まず私はmagit.elで必要なBのコミットを調べておいて\n$ git reset --hard * で*にHEADを戻してA, Bで加えた変更を全て破棄。\n$ git cherry-pick B-commits でBでの変更のみ適用\n$ git push -f origin branch で自分のリポジトリに反映(=pull-reqにも反映)\nとしました。*とB-commitsはそれぞれリビジョンIDを調べて下さいね。\n私の説明じゃ分りづらいと思うので http://d.hatena.ne.jp/murank/20110327/1301224770 にあるすばらしい図を参考にして下さい。\n","categories":["Git","Github","備忘録"],"category_urls":["/categories/git","/categories/github","/categories/%e5%82%99%e5%bf%98%e9%8c%b2"],"date":"2013-09-18","title":"Gitあれこれ","url":"https://KeenS.github.io/blog/2013/09/18/some-git-matters/"},
  {"body":"EmacsからOctopressに投稿できるOctomacs.elが最新版のrvm.elに対応してないようだったので修正してみました。\n原因はOctomacs.elがrvm.elの内部で使われている関数を使っていたのですが、その関数が最新版で削除されていたからだったみたいです。\n結論として、\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  *** /home/kim/.emacs.d/lisp/octomacs/octomacs.el 2013-09-16 22:29:14.498296762 +0900 --- /home/kim/.emacs.d/elpa/octomacs-20121026.1649/octomacs.el 2013-08-31 23:54:13.044373498 +0900 *************** ***4,10**** ;; ;; Author: Jacob Helwig \u0026lt;jacob@technosorcery.net\u0026gt; ;; Homepage: http://technosorcery.net ! ;; Version: 0.0.1 ;; URL: https://github.com/jhelwig/octomacs ;; ;;; License: --- 4,11 ---- ;; ;; Author: Jacob Helwig \u0026lt;jacob@technosorcery.net\u0026gt; ;; Homepage: http://technosorcery.net ! ;; Version: 20121026.1649 ! ;; X-Original-Version: 0.0.1 ;; URL: https://github.com/jhelwig/octomacs ;; ;;; License: *************** ***133,146**** (defun octomacs-format-rake-task-with-args (task \u0026amp;optional arguments) \"Build a shell suitable string of the rake TASK name with the specified ARGUMENTS.\" (let ((arguments-string (if arguments ! (format \"[%s]\" (if (listp arguments) (mapconcat 'octomacs-shell-escape-string arguments \", \") arguments)) \"\"))) (format \"'%s%s'\" task arguments-string))) (defun octomacs-rake-with-rvm (directory task \u0026amp;optional arguments) \"Run rake task TASK with specified ARGUMENTS in DIRECTORY using rvm\" (let* ((default-directory (file-name-as-directory (expand-file-name directory))) ! (rvmrc-info (or (rvm--load-info-rvmrc) (rvm--load-info-ruby-version) (rvm--load-info-gemfile))) (rvm-command (if rvmrc-info (concat \"rvm \" (mapconcat 'identity rvmrc-info \"@\") \" do \") \"\"))) --- 134,148 ---- (defun octomacs-format-rake-task-with-args (task \u0026amp;optional arguments) \"Build a shell suitable string of the rake TASK name with the specified ARGUMENTS.\" (let ((arguments-string (if arguments ! (format \"[%s]\" (mapconcat 'octomacs-shell-escape-string arguments \", \")) \"\"))) (format \"'%s%s'\" task arguments-string))) (defun octomacs-rake-with-rvm (directory task \u0026amp;optional arguments) \"Run rake task TASK with specified ARGUMENTS in DIRECTORY using rvm\" (let* ((default-directory (file-name-as-directory (expand-file-name directory))) ! (rvmrc-path (rvm--rvmrc-locate directory)) ! (rvmrc-info (if rvmrc-path (rvm--rvmrc-read-version rvmrc-path) nil)) (rvm-command (if rvmrc-info (concat \"rvm \" (mapconcat 'identity rvmrc-info \"@\") \" do \") \"\")))   こんな感じです。これでちゃんと.rvmrcやら.ruby-versionやら.ruby-gemsetやらを反映してくれます。 pull-req投げてみました。初pull-reqです。英語心配です。\n俺、pull-reqとりこまれたらrake gen_deployにも挑戦するんだ…\nあ、因みにこの投稿はinit.elに\n(setq octomacs-workdir-alist \u0026#39;((\u0026#34;default\u0026#34; . \u0026#34;~/Ruby/octopress\u0026#34;))) してoctomacs-new-postから投稿してます。\n","categories":["Emacs","Emacs Lisp","Octopress"],"category_urls":["/categories/emacs","/categories/emacs-lisp","/categories/octopress"],"date":"2013-09-16","title":"octomacs.elを修正しました","url":"https://KeenS.github.io/blog/2013/09/16/octomacs-el/"},
  {"body":"今日の夕方、Qiitaのユーザーヒアリングを受けたのでその報告です。\nユーザーヒアリングはQiitaがサービス向上のために「Qiitaアカウントを持っていてストックをするなど活動はしているが投稿をしてない人」を対象に「ねえ？なんで投稿しないの？ねえ、どうしてなの？Qiitaより良いサービスがあるの？そっか。私じゃだめなの？」って聞いてまわる活動です(違\n場所は駒場キャンパスのイタリアントマトで、小西さんと高橋さん と色々お話させていただきました。二方とも気さくで話しやすく、ちょいちょい脱線しながらも「ブログあるしー」とか「これどうしたらいいんでしょうねとか書きこめないしー」とか答えてました。\n一番大きかったのはバグ報告ができたのとqiita.elをメンテナンスしてほしいっていう要望を伝えれたところですかね。バグ伝えたときは割とマジになって詳細聞いてくれましたw\n話を聞くに全社員5人だそうです。それで5つのプロダクトを回してるんだとか。大変そうですね。\nあとは、記念品。 名刺の色はEmacerが薄紫でVimmerが黒だそうです。面白い。\n最後に他にQiitaのユーザーヒアリングの対象になりそうな人(プログラマだけど情報をアウトプットしてない人)が知り合いにいないかとかバイト募集してるんで興味ありそうな人いたら声掛けて下さいとか言われました。バイトは顧客開拓か、できそうならデータマイニングらへんになるそうです。\n興味のある方いましたら是非どうぞ。\nあとで左上のソーシャルのところにQiita加えます(今は画像作る時間がない\n2013/09/17追記 Qiitaをソーシャルに加えました。やりかたは COOKPADの記事参照。\n画像はまーる書いてちょんなので簡単に作れると思いますが こちらです。御自由にお使い下さい。\n","categories":[],"category_urls":[],"date":"2013-09-13","title":"Qiitaのユーザーヒアリングを受けてきました。","url":"https://KeenS.github.io/blog/2013/09/13/met-qiita-engineer/"},
  {"body":"FreeBSD10をインストールしてたときにちょっとつまったところがあったのでメモ。\n(前回までのあらすじ) FreeBSD10をインストールしたkvmのイメージでFreeBSDのソースをコンパイルできなくなっていたのでκeenはイメージに最新のFreeBSDを上書きインストールすることを決意したのであった\n今回 https://pub.allbsd.org/FreeBSD-snapshots/から最新版isoをダウンロードして\n$ kvm -cdrom ~/Download/FreeBSD-10.0-HEAD-r255472-JPSNAP-i386-i386-disc1.iso -boot d -m 2048 -smp 3 FreeBSD10.img でブート\u0026amp;インストール。普通にインストーラに従って問題無し。\nもう一度\n$ kvm -m 2048 -smp 3 FreeBSD10.img でブート。/usr/srcが空なのを確認して、最近標準添付になったsvnliteでソースをチェックアウト。\n# cd /usr # rmdir src # svnlite co https://svn0.us-west.FreeBSD.org/base/head src で、エラー。\n内容は\n server sent a truncated http response body.\n 不明。svn(lite)のエラーらしいことは分った。https:が悪い気がするのでhttp:にしようかと思ったけど、ふとダメ元で以前はできなかったsvn:のスキーマにしてみた。\n# svnlite co svn://svn0.us-west.FreeBSD.org/base/head src できた。なんだよ。\n蛇足 このあと\n# svnlite co svn://svn0.us-west.FreeBSD.org/ports/head ports でportsもチェックアウトしましたよ\n","categories":["FreeBSD","FreeBSD10","svn","svnlite","備忘録","小ネタ"],"category_urls":["/categories/freebsd","/categories/freebsd10","/categories/svn","/categories/svnlite","/categories/%e5%82%99%e5%bf%98%e9%8c%b2","/categories/%e5%b0%8f%e3%83%8d%e3%82%bf"],"date":"2013-09-12","title":"FreeBSD10でちょっとこけた","url":"https://KeenS.github.io/blog/2013/09/12/error-on-svn/"},
  {"body":"クックパッドにレシピ初投稿の記念として左上のソーシャルアイコンにクックパッドを追加しました。\nもともとソーシャルアイコン自体今使ってるOctopressのテーマ、CleanPressにはないのですが、別のテーマからもらってきました。\n加えた変更は\nsource/_includes/header.htmlに\n\u0026lt;nav id=\u0026#34;sub-nav\u0026#34;\u0026gt;{% include custom/social.html %}\u0026lt;/nav\u0026gt;\u0026lt;br\u0026gt; を、\nsource/_includes/custom/social.htmlのdivの中に\n{% if site.cookpad_user %} \u0026lt;a class=\u0026#34;cookpad\u0026#34; href=\u0026#34;http://cookpad.com/kitchen/3303629\u0026#34; title=\u0026#34;COOKPAD\u0026#34;\u0026gt;COOKPAD\u0026lt;/a\u0026gt; {% endif %} を、\nsass/parts/_header.scssの\u0026amp;.githubとかが並んでるところに\n\u0026amp;.cookpad{ background: image-url(\u0026#39;social/cookpad.png\u0026#39;) center no-repeat #FF9933; border: 1px solid #FF9933; \u0026amp;:hover{ border: 1px solid darken(#FF9933, 10%); } } を、\n_config.ymlに\n#COOKPADcookpad_user:your_ID を加え、\nsource/images/social/に この画像をつっこみました。16x16なのでめっちゃちっちゃいです。\n画像はクックパッドの公式のバナーのピクセル数を数えながら作ったのですが、アンチエイリアスのかけかたとか分らなかったので質はかなり低いです。かといって公式のやつ勝手に改造はマズいでしょうし。\n16x16で白い部分のみ、背景透過でだれか作って下さい←\n因みに私の作った画像は自由にご使用下さい。\n","categories":["COOKPAD","Octopress"],"category_urls":["/categories/cookpad","/categories/octopress"],"date":"2013-09-07","title":"COOKPADのアイコン","url":"https://KeenS.github.io/blog/2013/09/07/cookpad/"},
  {"body":"私はバイトではプロジェクト管理に Backlogのサービスを利用してますが、同様のOSSに Redmineなるものがあると聞いて動かしてみたときのメモ。\n以下、公式の引用。\n Redmineはオープンソースのプロジェクト管理ソフトウェアです。\nプロジェクトのタスク管理、進捗管理、情報共有が行えます。SubversionやGitなどのバージョン管理システムとの連携機能も備えており、ソフトウェア開発やwebサイト制作などのITプロジェクトで特に威力を発揮します。\n Redmineの管理団体(？)が MyRedmineというホスティングサービスを提供してたりしますが、今回はこれをローカルで動かします。\n公式ドキュメントを参考に作業していきます。\nまずはダウンロード。現在の最新版は2.3.2だそうです。\n$cd ~/Ruby $svn checkout http://svn.redmine.org/redmine/branches/2.3-stable redmine んで、グローバルの空間を汚したくないので新たにGemsetを作ります。本来ならbundler仕事なのですが、railsのバージョンとか仕組みの問題が面倒臭そうだったのでGemsetで管理。\n$rvm use --create 1.9.3@redmine $cd redmine $echo ruby-1.9.3-p448 \u0026gt; .ruby-version $echo redmine \u0026gt; .ruby-gemset これで~/Ruby/redmineにcdすると自動的にrvmが1.9.3@redmineに切り替えてくれます。\n※注意\n.rvmrcにrvm use 1.9.3@redmineと書いてたら怒られます。.ruby-versionと.ruby-gemsetがバージョン管理システムに依存しない新しい書き方だそうです。\nデータベースはデフォルトだとMySQLを使う設定になってますがこんなお試しにのためにMySQLを動かしたくないのでSQLiteに変更。\n$cp config/{database.yml.example, database.yml} のあと、database.ymlのproductionの部分を以下のように変更。\n 1 2 3  production: adapter: sqlite3 database: db/redmine.sqlite3   あとはbundle install。(bundlerはインストールされてる前提です)\n$bundle install --without development test すると…あれ？RMagickでコケる…。公式ドキュメントには bundleの--withoutにrmagickを加えろと書いてますが画像扱えないのは悔しいので色々調べた結果、\n$sudo apt-get install libmagic-dev libmagickwand-dev で依存関係を満せるようです。これでようやくbundle installが通ります。\nここまできたらあとはドキュメント通り。\n$rake generate_secret_token $RAILS_ENV=production rake db:migrate $RAILS_ENV=production rake redmine:load_default_data $rails s …あれ？rails sでコケる。\nこれは自分がrailsに慣れてなかったのが問題のようで、正しくは\n$rails s -e production だそうです。\n$RAILS_ENV=production rails s としても同じ。これで localhost:3000にアクセスするとRedmineが開きます。\n因みにAdminのID、パスワードはadminだそうです。\nデータベースの設定のexample部分にjenkinsとかいう文字列があったけど連携できるのかなぁ。要調査。\n補足 デフォルトのWEBrickだと遅いのでGemfileに\n 1  gem \"thin\"   を加えて、bundle installし直すと自動的にThinを使ってくれるそうです。\n","categories":["Install","Redmine","Ruby","Ubuntu","rvm","備忘録"],"category_urls":["/categories/install","/categories/redmine","/categories/ruby","/categories/ubuntu","/categories/rvm","/categories/%e5%82%99%e5%bf%98%e9%8c%b2"],"date":"2013-09-05","title":"Redmineのインストール","url":"https://KeenS.github.io/blog/2013/09/05/install-redmine/"},
  {"body":"小ネタ。コマンドラインからPDFを編集した話の備忘録。\nこちらに紹介されてるように、pdftkというツールである程度のことはできる。\n$sudo apt-get install pdftk でインストール可能。\n今回は\n$for pdf in *.pdf \u0026gt;\u0026gt;do \u0026gt;\u0026gt; pdftk $pdf cat 1-endR output `basename $pdf .pdf`_rot.pdf \u0026gt;\u0026gt;done で全てのPDFの全てのページを右周りに回転し、名前に_rotを付けて保存した。\npdftk *.pdf cat output all.pdf とかで結合なんかもできて便利。\n","categories":["PDF","Utility","CLI","備忘録"],"category_urls":["/categories/pdf","/categories/utility","/categories/cli","/categories/%e5%82%99%e5%bf%98%e9%8c%b2"],"date":"2013-09-03","title":"PDFユーティリティ","url":"https://KeenS.github.io/blog/2013/09/03/pdftk/"},
  {"body":"夜中にコーヒー飲むと眠れなくなりますね。昨晩もコーヒー飲んだら朝まで眠れず、寝たのが朝8時半、起きたのが16時でした。明日提出のレポート終ってないのに…\nさて、かなり良いRuby on Railsのチュートリアルを見付けたので紹介します。\nRuby on Rails チュートリアル：実例を使ってRailsを学ぼう\nこれはただのrailsの紹介ではなくてgitだとかherokuだとかを使ってかなり実践的にアプリケーションを作ていくものです。1, 2章で軽くrailsを動かしてみたあと、3章以降でテスト駆動開発でアプリケーションを構築していきます。\nこのテスト駆動開発の環境がすばらしいのなんのって、最初動かしたとき思わずニヤリとしました。しかも何故か(何も設定してないのに)Emacsのモードバーの色がテストの結果に応じて変わるという。\nマウス操作もキーストロークも無くコードの正しさを教えてくれるのは非常に快適でした。\n文体も訳本にありがちな片言の日本語ではなく読み易いですし、Ruby自体の解説もあり、「Scaffoldを使えば簡単にできるんだぜ~」じゃなくてちゃんとMVCの関係とかを解説して身に付いた上で「今後はScaffoldでより手軽に作れるよ」なのでRailsに限らずWeb開発のチュートリアルとして秀逸でした。\n私もまだ5章までしか進めてないのですが是非一度試してみて下さい\n","categories":["Git","Heroku","Ruby","Ruby on Rails","Web Development"],"category_urls":["/categories/git","/categories/heroku","/categories/ruby","/categories/ruby-on-rails","/categories/web-development"],"date":"2013-09-03","title":"Rails Tutorial","url":"https://KeenS.github.io/blog/2013/09/03/rails-tutorial/"},
  {"body":"こんばんは。κeenです。普段、Github上で最新のソースを追ってるプロジェクトはこまめにgit pullすることで更新を確認してたのですが、別の方法があることに気づきました。\n単純にWatchという便利な機能もあるのですが、RSSでソースを追うこともできるようです。RSSのアイコンが見当らなかったのでないものと思ってましたがちゃんとあるんですね。\nRSSのAPIはgithub.com/ORG/PROJECT/commits/BRANCH.atomになります。\nたとえばMirahのmasterブランチの最新のコミットを受け取りたかったら、\nhttps://github.com/mirah/mirah/commits/master.atomになります。試してませんがcommitsのところをissuとかにすればissuを追えるのかもしれません。\nwatchとの違いは、watchはwikiの変更やissuなど全てを追うところと、通知がメール and/or github上での通知なところですね。\nメールじゃなくてgithubの通知でもなくてRSSで受け取りたい方は試してみてはいかがでしょうか。\n","categories":["Git"],"category_urls":["/categories/git"],"date":"2013-09-02","title":"Githubの変更を追う","url":"https://KeenS.github.io/blog/2013/09/02/rss-of-github/"},
  {"body":"はじめまして。κeenです。今までLispでblogエンジンを作ってblogを開設したいと思いつつも時間がなかったりWifiアダプタ失くしたりして結局あきらめ、github+octopressでblog作ることにしました。\noctopress、テーマも充実してて非常に便利なのですが、私Markdown書いたことないんですね…\nとりあえずMarkdownの勉強がてらblogを書くことになりそうです。\n記事の内容としてはブログタイトルにあるように私がRuby, Emacs, Lispその他を扱ってるときにはまったことなどをメモしていく感じになると思います。主にTwitterで活動してるので @blackenedgoldを監視してるといいかもしれません。\nでは次回以降Markdownを勉強して出直してきます\n","categories":[],"category_urls":[],"date":"2013-09-01","title":"ブログ開設しました","url":"https://KeenS.github.io/blog/2013/09/01/first-post/"}
];

