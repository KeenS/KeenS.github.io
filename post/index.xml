<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on κeenのHappy Hacκing Blog</title>
    <link>/post/index.xml</link>
    <description>Recent content in Posts on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Fri, 19 May 2017 20:51:46 +0900</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>非同期とノンブロッキングとあと何か</title>
      <link>/blog/2017/05/19/hidoukitononburokkingutoatonanika</link>
      <pubDate>Fri, 19 May 2017 20:51:46 +0900</pubDate>
      
      <guid>/blog/2017/05/19/hidoukitononburokkingutoatonanika</guid>
      <description>&lt;p&gt;κeenです。最近同期/非同期、ブロッキング/ノンブロッキング、直接形式/継続渡し形式あたりが混乱してきたので個人的に整理します。
あくまで私個人の理解を纏めただけなので誤謬などに注意して下さい。&lt;/p&gt;

&lt;p&gt;追記: &lt;a href=&#34;https://twitter.com/tanaka_akr&#34;&gt;@tanaka_akr&lt;/a&gt;さんから&lt;a href=&#34;https://twitter.com/tanaka_akr/status/865722507281580032&#34;&gt;指摘&lt;/a&gt;されたのですが、用語の説明が間違っていそうだったので書き直しました。
diffは&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/commit/d46dad5282436eeaa615f31c160f892e6c724403&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;非同期とノンブロッキングはよく混同されます。また、非同期処理の記述形式として直接形式や継続渡し形式などがあります。
私自身違う言葉だなとは思いつつも混同したり違いを忘れたりしています。
非同期もノンブロッキングもナイーブなIOに比べると速い方式だな程度の理解でいてそんなに困らないと思ってますし混同や誤用に目くじらを立てるつもりもありません。
しかしながら3者を区別しないと意味を成さない文脈で3者を混同している技術を何度か見掛けたので（自分の中で）整理しようと思ったのがこの記事を書こうと思ったきっかけです。&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;p&gt;色々と調べましたが、&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html&#34;&gt;The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition&lt;/a&gt;の定義を使います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_77&#34;&gt;ブロッキング&lt;/a&gt;:
IO操作で、操作する前に待ちが発生するという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_240&#34;&gt;ノンブロッキング&lt;/a&gt;:
IO操作で、操作する前に待ちが発生しそうなら即座に関数から返るという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_378&#34;&gt;同期&lt;/a&gt;:
IO操作で、操作が終わるまでブロックするという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_29&#34;&gt;非同期&lt;/a&gt;:
IO操作で、IO操作を発効したスレッド自体がブロックせずに別のCPU処理を行えるという性質&lt;/li&gt;
&lt;li&gt;IOの多重化: 複数のfdに対して監視を行ない、ブロックせずに操作可能なfdを通知する仕組み。
調べると「複数のfdに対してブロックできる」という記述があるのですがノンブロッキングなオプションもありますよね&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらはどのようにIOを行うかの問題で、 &lt;strong&gt;実行時&lt;/strong&gt; に関係する話題です。&lt;/p&gt;

&lt;p&gt;次に、直接形式と継続渡し形式について。非同期やノンブロッキングなIOをしようと思うと後続の処理、すなわち（限定）継続が必要になる。この（限定）継続をプログラマがどのように渡すかの問題。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Direct_style&#34;&gt;直接形式&lt;/a&gt;は（限定）継続がプログラムには陽には現れず、コンパイラが頑張るかコルーチンなどの言語機能、&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;などの構文を用いて実現されます。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Continuation-passing_style&#34;&gt;継続渡し形式&lt;/a&gt;(CPS)はプログラマが陽に（限定）継続を渡すスタイルで、コールバック形式などとも呼ばれます。&lt;/p&gt;

&lt;p&gt;これらは主に言語の問題で、 &lt;strong&gt;コンパイル時&lt;/strong&gt; に関係する話題です。
よく直接形式と同期処理が混同されて「同期プログラミングをすることで非同期プログラミングができます」などの矛盾した一文が書かれがちですが区別しましょう。&lt;/p&gt;

&lt;h2 id=&#34;誰が何を&#34;&gt;誰が何を&lt;/h2&gt;

&lt;p&gt;IO処理の話題はスレッドとカーネルとのやりとりに関することが多い気がしますが、Goのようにユーザランドで実行単位を持つと「ブロックする」といったときにスレッドがブロックするのかgoroutineがブロックするのか分かりづらいですね。
なのでこれ以後は誰が何をブロックするのかを出来る限り明示しながら書きたいと思います。例えば「カーネルがgoroutine Aを実行しているスレッドをブロックする」など。&lt;/p&gt;

&lt;h1 id=&#34;scala&#34;&gt;Scala&lt;/h1&gt;

&lt;p&gt;前職でScalaを書いていました。
Scalaの&lt;code&gt;Future&lt;/code&gt;そのものは&lt;code&gt;flatMap&lt;/code&gt;が関数をとるので継続渡し形式ですが、そのシンタックスシュガーの&lt;code&gt;for&lt;/code&gt;式は直接形式でプログラミングができます。
IOの実体についてはFutureで抽象化されているのでexecutorによります。&lt;/p&gt;

&lt;h1 id=&#34;go&#34;&gt;Go&lt;/h1&gt;

&lt;p&gt;前職の新卒研修で5日ほどGoを書いたことがあります。
多くの言語は比較的シンプルなIOモデルを持つので用語を意識しなくても問題ありませんが、Goは実行時に色々工夫しているので用語をちゃんと区別しないと齟齬が出るようです。
なのでGoを例に理解を深めようと思います。&lt;/p&gt;

&lt;p&gt;まず、Goは実行時に動作するコンポーネントが多いので整理します。
&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;ここの質問&lt;/a&gt;への回答によるとgoroutine実行用のスレッド、スケジューラ、GCに大別してよさそうです。
このうち、IOに関連するのはgoroutine実行用のスレッドとスケジューラなのでGCについては触れません。
あまりよく分かってないのですがスケジューラはgoroutine実行用のスレッド上で呼ばれるための関数（群）なんですかね。&lt;/p&gt;

&lt;p&gt;普段は1スレッドが複数のgoroutineの実行を受け持ち、goroutineが何かしらの理由でブロックしそうなタイミングで別のgoroutineにコンテキストスイッチするようです。
ブロックしそうなタイミングというのはやや古いですが&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;ここ&lt;/a&gt;に書かれてます。
直接形式で書きつつコンテキストスイッチをするということはどうにかして(限定)継続を取り出す必要がありますが、それこそgoroutineですね。goroutine自身でスタックを持つようですし。
C関数を呼ぶときなどはコンパイラが裏で呼び出す前と後に分割しているようです。&lt;/p&gt;

&lt;p&gt;さて、IOについてはファイルIOとネットワークIOで操作が異なるようです。&lt;/p&gt;

&lt;p&gt;ファイルIOでは普通に同期/ブロッキングなシステムコールを発効し、OSがスレッドをブロックする時間が長いようなら別スレッドで元スレッドの持っていたgoroutineを実行するようです。
信頼できる情報が出てこなかったのですが自身で長くなりそうと思っているシステムコールの場合はgoroutineの実行権限（プロセス）を手放してあとは他のプロセスがstealするに任せてる？
ファイルIOは、スレッドがシステムコールでブロックし同期的で、goroutineもシステムコールでブロックし同期的です。ただスケジューラのお陰で他のgoroutineに迷惑がかからないだけです。&lt;/p&gt;

&lt;p&gt;ネットワークIOはポーリングを行なうようです。
スケジューラがfinbrunnableする中でブロックしない方のpoll(Linuxだとepollにノンブロッキングオプションつけたやつかな？)を呼んで、操作可能なfdがあればそれを待っているgoroutineを起こしている模様。
であれば上の分類に従うとネットワークIOはスレッドはブロックせず同期的でIOを多重化し、goroutineはスケジューラからブロックされ同期的で（特別に関数を呼ばなければ）IOの多重化もしません。ただ、操作可能なfdに操作しているのでgoroutineはカーネルからはブロックされません。&lt;/p&gt;

&lt;p&gt;この他にもgoroutine同士のコミュニケーションにチャネルがあります。そこまで重要じゃないかなと思って詳しく調べてないので間違いがあるかもしれないです。
チャネルへの操作は同期的ですね。チャネルへのread/writeはバッファがempty/fullだったらブロックするようなのでgoroutineはチャネルへの操作でブロックします。調べてないですが普通スレッドはブロックしないでしょう。&lt;/p&gt;

&lt;p&gt;チャネルへのselectはあまり情報が出てこなかったのですが恐らくスケジューラがIO可能なチャネルを調べて1つでもあればそれからランダムに選ぶ、1つもなくdefaultもなければスケジューラがgoroutineをブロックするんだと思います。
同期的でIOの多重化をしていますね。&lt;/p&gt;

&lt;p&gt;Goroutineやスレッドレベルでは同期的ですが、Goのプロセス全体でみるとGOMAXPROC分のスレッドは常にCPUを使っているので非同期なんですかね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Goの件について表にするとこうですかね。非同期処理をやろうと思ったら大抵処理単位を分ける必要がありますが、Goの最小処理単位がgoroutineなのでよく考えたらgoroutineが全て同期するのはあたりまえですね。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;スレッド&lt;/th&gt;
&lt;th&gt;goroutine&lt;/th&gt;
&lt;th&gt;Goプロセス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ファイル&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;非同期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ネットワーク&lt;/td&gt;
&lt;td&gt;ノンブロック/同期/多重化&lt;/td&gt;
&lt;td&gt;ノンブロック/同期/&lt;/td&gt;
&lt;td&gt;非同期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルRW&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルselect&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/同期/多重化&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ということでGoのIOについては「goroutineを直接形式で同期的な書き方をしても裏でスケジューラが動いているからCPUを効率的に使えてGoプロセス全体でみれば非同期」になるんですかね。&lt;/p&gt;

&lt;p&gt;Goに詳しい人、コメントや誤り訂正お願いします。&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/issues&#34;&gt;GitHubのイシュー&lt;/a&gt;とか使えば良い気がします。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/36112445/golang-blocking-and-non-blocking&#34;&gt;multithreading - Golang blocking and non blocking - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/os/file_unix.go?s=#L224&#34;&gt;src/os/file_unix.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/proc.go?s=#L1795&#34;&gt;src/runtime/proc.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/faq#goroutines&#34;&gt;Frequently Asked Questions (FAQ) - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;channel - go routine blocking the others one - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/cgocall.go&#34;&gt;src/runtime/cgocall.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/32538438/how-does-channel-blocking-work-in-go&#34;&gt;select - How does channel blocking work in Go? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/ref/spec#Select_statements&#34;&gt;The Go Programming Language Specification - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;How does the Go runtime work? - Quora&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rust風にデザインパターン23種</title>
      <link>/blog/2017/05/06/rustkazenidezainpata_n23tane</link>
      <pubDate>Sat, 06 May 2017 21:59:30 +0900</pubDate>
      
      <guid>/blog/2017/05/06/rustkazenidezainpata_n23tane</guid>
      <description>&lt;p&gt;κeenです。
GoFのデザインパターンは有名ですが、言語機能によっては単純化できたりあるいは不要だったりするのでRust風に書き換えたらどうなるか試してみます。

発端はこのツイート。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;デザインパターン、古いJavaの機能の足りなさのワークアラウンド的なテクニックも含まれてるからあまり宜しくないんだよね。enumやクロージャで十分なのもいくつかある。&lt;br&gt;&lt;br&gt;Rustで写経、デザインパターン23種 - Qiita&lt;a href=&#34;https://t.co/MhpS3Z2OlF&#34;&gt;https://t.co/MhpS3Z2OlF&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/860635079600513024&#34;&gt;2017年5月5日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;一応誤解のないように説明しておくと、該当のQiitaの記事に不満がある訳ではなくてGoFのデザインパターンついての言及です。&lt;/p&gt;

&lt;p&gt;リンク先のコードで十分な時にはここでは流すのでリンク先も同時に参照下さい。
また、比較しやすいようにサンプルコードはリンク先のものに則って書きます。&lt;/p&gt;

&lt;p&gt;一応デザインパターンの教科書として結城先生の本を参照しつつ書いていきます。&lt;/p&gt;

&lt;h1 id=&#34;command-パターン&#34;&gt;Command パターン&lt;/h1&gt;

&lt;p&gt;列挙型を使うところです。
Javaにまともなenumがないのでクラスが使われていますが、列挙型があるならそちらの方がデータとコードの分離ができて見通しがいいです。また、コマンドが1つの型に収まるのでトレイトオブジェクトを作る必要がなくなります。&lt;/p&gt;

&lt;p&gt;比較的マイナーな変更です。&lt;/p&gt;

&lt;p&gt;Lispだとクロージャで解決したりしますが、Rustだと列挙型の方がしっくりくるかなと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Command&amp;lt;T&amp;gt; {
    fn execute(&amp;amp;self, &amp;amp;mut T);
    fn undo(&amp;amp;self, &amp;amp;mut T);
}



struct Invoker&amp;lt;&#39;a, Cmd, T: &#39;a&amp;gt; {
    commands: Vec&amp;lt;Cmd&amp;gt;,
    target: &amp;amp;&#39;a mut T,
    current_index: usize,
}


impl&amp;lt;&#39;a, Cmd, T&amp;gt; Invoker&amp;lt;&#39;a, Cmd, T&amp;gt; {
    fn new(t: &amp;amp;&#39;a mut T) -&amp;gt; Self {
        Invoker {
            commands: Vec::new(),
            target: t,
            current_index: 0,
        }
    }


    fn target(&amp;amp;self) -&amp;gt; &amp;amp;T {
        self.target
    }

    fn append_command(&amp;amp;mut self, c: Cmd) {
        self.commands.push(c);
    }
}

impl&amp;lt;&#39;a, Cmd, T&amp;gt; Invoker&amp;lt;&#39;a, Cmd, T&amp;gt;
    where Cmd: Command&amp;lt;T&amp;gt;
{
    fn execute_command(&amp;amp;mut self) {
        if self.commands.len() &amp;lt;= self.current_index {
            // Nothing to do.
            return;
        }

        let c = &amp;amp;self.commands[self.current_index];
        let t = &amp;amp;mut *self.target;
        c.execute(t);

        self.current_index += 1;
    }

    fn execute_all_commands(&amp;amp;mut self) {
        for _ in self.current_index..self.commands.len() {
            self.execute_command();
        }
    }

    fn undo(&amp;amp;mut self) {
        if 0 == self.current_index {
            return;
        }

        self.current_index -= 1;

        let c = &amp;amp;self.commands[self.current_index];
        let t = &amp;amp;mut *self.target;
        c.undo(t);
    }
}


#[derive(Debug, Eq, PartialEq)]
struct Robot {
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
}


impl Robot {
    fn new() -&amp;gt; Robot {
        Robot {
            x: 0,
            y: 0,
            dx: 0,
            dy: 1,
        }
    }

    fn move_forward(&amp;amp;mut self) {
        self.x += self.dx;
        self.y += self.dy;
    }

    fn set_direction(&amp;amp;mut self, d: (i32, i32)) {
        self.dx = d.0;
        self.dy = d.1;
    }

    fn get_direction(&amp;amp;self) -&amp;gt; (i32, i32) {
        (self.dx, self.dy)
    }
}

enum RoboCommand {
    MoveForward,
    TurnRight,
    TurnLeft,
}

impl Command&amp;lt;Robot&amp;gt; for RoboCommand {
    fn execute(&amp;amp;self, r: &amp;amp;mut Robot) {
        use RoboCommand::*;
        match *self {
            MoveForward =&amp;gt; r.move_forward(),
            TurnRight =&amp;gt; {
                let (dx, dy) = r.get_direction();
                r.set_direction((dy, -dx))
            }
            TurnLeft =&amp;gt; {
                let (dx, dy) = r.get_direction();
                r.set_direction((-dy, dx));
            }

        }
    }
    fn undo(&amp;amp;self, r: &amp;amp;mut Robot) {
        use RoboCommand::*;
        match *self {
            MoveForward =&amp;gt; {
                let c1 = TurnRight;
                c1.execute(r);
                c1.execute(r);
                self.execute(r);
                c1.execute(r);
                c1.execute(r);
            }
            TurnRight =&amp;gt; {
                let c = TurnLeft;
                c.execute(r);
            }
            TurnLeft =&amp;gt; {
                let c = TurnRight;
                c.execute(r);

            }

        }
    }
}



fn main() {
    let mut r = Robot::new();

    let mut invoker = Invoker::new(&amp;amp;mut r);
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 0,
                   dy: 1,
               });

    {
        use RoboCommand::*;
        invoker.append_command(TurnRight);
        invoker.append_command(TurnLeft);
        invoker.append_command(MoveForward);
    }

    invoker.execute_all_commands();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 1,
                   dx: 0,
                   dy: 1,
               });

    invoker.undo();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 0,
                   dy: 1,
               });

    invoker.undo();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 1,
                   dy: 0,
               });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;stateパターン&#34;&gt;Stateパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。トレイトオブジェクトを使う代表的なケースだと思います。。
あるいは列挙型を使う可能性もあります。&lt;/p&gt;

&lt;h1 id=&#34;strategyパターン&#34;&gt;Strategyパターン&lt;/h1&gt;

&lt;p&gt;参照先でも説明されていますが、Rustにはクロージャがあるので不要です。&lt;/p&gt;

&lt;h1 id=&#34;template-methodパターン&#34;&gt;Template Methodパターン&lt;/h1&gt;

&lt;p&gt;そもそもトレイトを使った普通のプログラミングなのでRustでわざわざ名前をつけるほどかな？と個人的には思いますがあえて書くなら参照先のままです。
あるいはものによっては高階関数でも。&lt;/p&gt;

&lt;p&gt;個人的にはトレイトオブジェクトを作るより関連型を使った方が好みです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait AbstractFactory&amp;lt;&#39;a&amp;gt; {
    type ProdX: ProductX;
    type ProdY: ProductY;
    fn create_product_x(&amp;amp;self) -&amp;gt; Box&amp;lt;ProdX + &#39;a&amp;gt;;
    fn create_product_y(&amp;amp;self) -&amp;gt; Box&amp;lt;ProdY + &#39;a&amp;gt;;
}

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;mementoパターン&#34;&gt;Mementoパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです&lt;/p&gt;

&lt;h1 id=&#34;observerパターン&#34;&gt;Observerパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです&lt;/p&gt;

&lt;h1 id=&#34;visitorパターン&#34;&gt;Visitorパターン&lt;/h1&gt;

&lt;p&gt;参照先では簡単な例なので分かりづらいのですが、列挙型を使うところです。
まともな列挙型がない+シングルディスパッチしかなく引数はオーバーロードという二重苦によって生まれたパターンであり、まともな列挙型か多重ディスパッチがあれば複雑怪奇なプログラムは書かなくて済みます。&lt;/p&gt;

&lt;p&gt;ここでは参照先とは違ってもう少し複雑な例を出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Visitor&amp;lt;T&amp;gt; {
    fn visit(&amp;amp;mut self, &amp;amp;T);
}

enum Entity {
    File(String),
    Dir(String, Vec&amp;lt;Entity&amp;gt;),
}

struct ConcreteFileVisitor;

impl Visitor&amp;lt;Entity&amp;gt; for ConcreteFileVisitor {
    fn visit(&amp;amp;mut self, e: &amp;amp;Entity) {
        use Entity::*;
        match *e {
            File(ref name) =&amp;gt; println!(&amp;quot;file: {}&amp;quot;, name),
            Dir(ref name, ref files) =&amp;gt; {
                println!(&amp;quot;dir: {}&amp;quot;, name);
                for file in files {
                    self.visit(file)
                }
            }
        }
    }
}

fn main() {
    use Entity::*;
    let e = Dir(&amp;quot;/&amp;quot;.to_string(),
                vec![File(&amp;quot;etc&amp;quot;.to_string()), File(&amp;quot;usr&amp;quot;.to_string())]);
    let mut visitor = ConcreteFileVisitor;
    visitor.visit(&amp;amp;e);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特段パターンというほどの処理をしている感じがしませんね。&lt;/p&gt;

&lt;h1 id=&#34;iteratorパターン&#34;&gt;Iteratorパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;mediatorパターン&#34;&gt;Mediatorパターン&lt;/h1&gt;

&lt;p&gt;だいたい参照先のままです。複雑なことをしようと思うと&lt;code&gt;Colleague&lt;/code&gt;が複数種類出てきて列挙型かトレイトオブジェクトが必要になりそうな気がします。&lt;/p&gt;

&lt;h1 id=&#34;interpreterパターン&#34;&gt;Interpreterパターン&lt;/h1&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h1 id=&#34;builderパターン&#34;&gt;Builderパターン&lt;/h1&gt;

&lt;p&gt;あまりここまで抽象化してるのは見たことありませんがやるとしたら参照先のままです。
そもそもRustには継承がないので抽象化する意義があまりなく、型固有のBuilderパターンで十分です。&lt;/p&gt;

&lt;h1 id=&#34;prototypeパターン&#34;&gt;Prototypeパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;factoryパターン&#34;&gt;Factoryパターン&lt;/h1&gt;

&lt;p&gt;クロージャで十分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Product {
    fn convert(&amp;amp;self, String) -&amp;gt; String;
}


struct Factory;

impl Factory {
    fn convert&amp;lt;P, F&amp;gt;(&amp;amp;self, s: String, create_product: F) -&amp;gt; String
        where P: Product,
              F: FnOnce() -&amp;gt; P
    {
        create_product().convert(s)
    }
}


struct ConcreteProductX;
impl Product for ConcreteProductX {
    fn convert(&amp;amp;self, s: String) -&amp;gt; String {
        s.to_uppercase()
    }
}


fn main() {
    let f = Factory;
    println!(&amp;quot;{}&amp;quot;,
             f.convert(&amp;quot;hogehoge piyopiyo&amp;quot;.to_string(), || ConcreteProductX))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;abstractfactoryパターン&#34;&gt;AbstractFactoryパターン&lt;/h1&gt;

&lt;p&gt;そもそもここまでやる？というのは置いといてやるとしたら参照先のままかなぁと思います。&lt;/p&gt;

&lt;p&gt;TemplateMethodパターンでも述べた通り個人的には関連型を使う方が好みです。&lt;/p&gt;

&lt;h1 id=&#34;chain-of-responsibility-cor-パターン&#34;&gt;Chain of Responsibility/CoR パターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;singletonパターン&#34;&gt;Singletonパターン&lt;/h1&gt;

&lt;p&gt;そもそもアンチパターンです。分かりづらいグローバル変数なだけです。あえてRustでやるとしたら&lt;a href=&#34;https://github.com/rust-lang-nursery/lazy-static.rs&#34;&gt;lazy_static&lt;/a&gt;かなと思います。&lt;/p&gt;

&lt;h1 id=&#34;adapterパターン&#34;&gt;Adapterパターン&lt;/h1&gt;

&lt;p&gt;これは捉え方が2種類あるかなーと思います。。&lt;/p&gt;

&lt;p&gt;1つにはクラスの定義時にしかインターフェースを実装できない窮屈な言語仕様へのワークアラウンドとして。
この捉え方では参照先のコードようにただトレイトを実装してしまえば終わりです。&lt;/p&gt;

&lt;p&gt;もう1つにはラッパーオブジェクトとして。&lt;code&gt;std::fs::File&lt;/code&gt;の実装とかがそれっぽいと思います。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct File {
    inner: fs_imp::File,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bridgeパターン&#34;&gt;Bridgeパターン&lt;/h1&gt;

&lt;p&gt;そもそも機能の追加とAPIの抽象化をどちらも継承に押し込める言語仕様が悪い。
それにRustでは継承しないので関係ないです。&lt;/p&gt;

&lt;h1 id=&#34;proxyパターン&#34;&gt;Proxyパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;facadeパターン&#34;&gt;Facadeパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。Rustにはモジュールや可視性の制御があって特別意識することなく普段からやっていることなのであまり名前をつけるほどのことではないと思ってます。&lt;/p&gt;

&lt;h1 id=&#34;flyweightパターン&#34;&gt;Flyweightパターン&lt;/h1&gt;

&lt;p&gt;所有権があるのでRustだとちょっと難しいパターンです。
参照だけなら参照先のように&lt;code&gt;HashMap&lt;/code&gt;にいれるか、オブジェクトを区別しないなら&lt;code&gt;Vec&lt;/code&gt;にいれるかなと思います。&lt;/p&gt;

&lt;p&gt;因みにLispとかでは&lt;code&gt;intern&lt;/code&gt;という名前で呼ばれてると思います。&lt;/p&gt;

&lt;h1 id=&#34;compositeパターン&#34;&gt;Compositeパターン&lt;/h1&gt;

&lt;p&gt;ただの列挙型の再実装です。&lt;/p&gt;

&lt;h1 id=&#34;decoratorパターン&#34;&gt;Decoratorパターン&lt;/h1&gt;

&lt;p&gt;よくあるやつです。参照先のコードの他、&lt;code&gt;std::io::WriteBuf&lt;/code&gt;のようなものが代表的です。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;デザインパターンをdisろうと思って書いたのですが案外多くのケースで便利でした。Rustで不要なものは10本指で数えられる程度でしたね。すごい。&lt;/p&gt;

&lt;p&gt;因みにLisperでAIの研究者（確か今GoogleのAI研究所の所長）のPeter Norvigは&lt;a href=&#34;http://www.norvig.com/design-patterns/design-patterns.pdf&#34;&gt;Design Patterns in Dynamic Languages&lt;/a&gt;で16個はLispの機能を使えばパターンという程のものではなくなると言ってます。
それぞれどの機能でどれが不要になるかを解説しているのですが、Rustは高階関数とモジュールの分に加えて列挙型の分で不要になってるかなと思います。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>メモリとスタックとヒープとプログラミング言語</title>
      <link>/blog/2017/04/30/memoritosutakkutohi_puto</link>
      <pubDate>Sun, 30 Apr 2017 09:09:50 +0900</pubDate>
      
      <guid>/blog/2017/04/30/memoritosutakkutohi_puto</guid>
      <description>&lt;p&gt;κeenです。
今回の話は別にRustに限ったものではないのですが、よくRustを始めたばかりの人がスタックとヒープが分からないと言っているのをみかけるので少しメモリの話をしますね。
厳密な話というよりは雰囲気を掴んで欲しいという感じです。
&lt;/p&gt;

&lt;h1 id=&#34;メモリは配列&#34;&gt;メモリは配列&lt;/h1&gt;

&lt;p&gt;プログラム（プロセス）のメモリには実行するプログラム（機械語）やグローバル変数/定数、関数の引数やローカル変数、その他プログラムで使うデータ領域などを置きます。
プロセスに割り当てられるメモリというのは、1つの巨大なのっぺらな配列みたいなものです。サイズも決まってます。64bit OSなら2^64 byteです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0                        2^64
+---------------     ----+
|  |  |  |  |    ~~   |  |
+---------------     ----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは仮想的なメモリなので実際の物理メモリに2^64 byteの配列がドンと確保される訳ではなくて、使った(使いたい)分だけ占有します。OSが賢いですね。&lt;/p&gt;

&lt;p&gt;ただまあこれだけだと使いづらいのである程度区切って「この辺にこれ系のデータを置く」みたいな使われ方をします。
プログラムを置く &lt;em&gt;text領域&lt;/em&gt; 、初期化されたグローバル変数を置く &lt;em&gt;data領域&lt;/em&gt; 、初期化されていない（データ領域だけ確保された）グローバル変数を置く &lt;em&gt;bss領域&lt;/em&gt; 、関数の引数やローカル変数を置く &lt;em&gt;stack領域&lt;/em&gt; 、プログラムのデータを置く &lt;em&gt;heap領域&lt;/em&gt; です。
グローバル変数って言っちゃいましたけど実はそれに限らなくて、例えばRustの文字列リテラルなんかもdata領域に置かれます。&lt;/p&gt;

&lt;p&gt;text、 data、 bssは実行する前からサイズが分かっているので問題ないのですが、heapとstackはプログラムの実行中にサイズが変わるものなのでどこにどう置いたら上手く配分できるか分かりませんね。
そこで以下のようにstackとheapを両端に配置して使いたい分だけ使用領域を伸ばせるようになってます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 簡略化するために嘘ついてたりしますがまあ、だいたい合ってます
+-------+ 2^64
| stack |
|   |   |
|   V   |
|       |
|   ^   |
|   |   |
| heap  |
+-------+
| bss   |
+-------+
| data  |
+-------+
| text  |
+-------+ 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;text、data、bssはそのままなのでstackとヒープについて話します。&lt;/p&gt;

&lt;h1 id=&#34;stackと関数&#34;&gt;Stackと関数&lt;/h1&gt;

&lt;p&gt;Stackは関数呼び出しのために使われます。
ネストした関数の呼び出しの系譜を関数の「コールスタック」と呼んだりするように、関数呼び出しはスタック構造になってますね。
なのでスタックを用いて管理すると具合が良いのです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+
| func 1 |
+--------+
| func 2 |
+--------+
| func 3 |
+--------+
| func 4 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、折角特別に用意したこのstackにはただの関数の呼び出し履歴だけではなく他のデータも入れたいですよね？
例えば関数ローカルな変数だとか。データの次にまた別のデータが置かれるのでサイズを変えたりはできませんが。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+
| func 1 |
|--------|
| data 1 |
|--------|
| data 2 |
+--------+
| func 2 |
|--------|
| data   |
| ...    |
+--------+
| func 3 |
|--------|
| data   |
| ...    |
+--------+
| func 4 |
|--------|
| data   |
| ...    |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;データの解放は簡単です。スタックを巻き戻せば自動的に消えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+
| func 1 |
|--------|
| data 1 |
|--------|
| data 2 |
+--------+
| func 2 |
|--------|
| data   |
| ...    |
+--------+
|        |
|        |
|        |
|        |
|        |
|        |
|        |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逆にいうと関数から抜けたら消えてしまうということでもありますが。&lt;/p&gt;

&lt;p&gt;という訳で、 「条件が限られるけど高速に扱えるデータ領域」がstackです。&lt;/p&gt;

&lt;p&gt;因みに、メモリは使った分だけしか確保されないと言いましたが、スタックを伸ばしすぎると確保されていない領域に到達してエラーが出ます。スタックオーバーフローです。&lt;/p&gt;

&lt;h1 id=&#34;heapとデータ&#34;&gt;Heapとデータ&lt;/h1&gt;

&lt;p&gt;heapにはstackに置けないデータが置かれます。
これの扱いは少し面倒です。何故ならデータの確保や解放の順番がバラバラなので、歯抜けな状態になってしまうからです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|        |
| data 4 |
+--------+
| data 3 |
+--------+
|        |
+--------+
| data 1 |
+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで「どかが使われていてどこが空いているか」を管理するシステムを導入します。
C言語では&lt;code&gt;malloc&lt;/code&gt;という関数をインターフェースとして管理しているので管理システム自体もmallocと呼ぶことが多いようです。
この実装方法はフリーリストを使った単純なものからサイズ毎のバケツを用意して〜といった方法まで様々にあるので気になる人は調べてみて下さい。
大抵、「メモリがこのくらい欲しい」と言われたら今管理している中からそれっぽい空きを捜してそこを渡してあげるような作りになっています。&lt;/p&gt;

&lt;p&gt;ちなみにこの領域管理には(mallocの場合)そこそこのコストが掛かります。でもその代わり自由に確保/解放できる他、サイズの変更もできるので自由度が高いです。&lt;/p&gt;

&lt;p&gt;という訳で「自由度が高いが少しコストがかかるデータ領域」がheapです。&lt;/p&gt;

&lt;h1 id=&#34;プログラミング言語とメモリ&#34;&gt;プログラミング言語とメモリ&lt;/h1&gt;

&lt;p&gt;では、具体的な言語がどのようにメモリを使っているかを簡単に紹介します。&lt;/p&gt;

&lt;p&gt;1つ注意しないといけないのが、ガーベジコレクション（GC）のある言語ではheapの上に構築した自前のメモリ管理システムのことをヒープと呼んでいたりするので両者をちゃんと区別しましょう。
同じく、スタックの使い方も言語独自でコールスタックと引数のスタックを分けたりもするので気をつけましょう。&lt;/p&gt;

&lt;h2 id=&#34;c言語&#34;&gt;C言語&lt;/h2&gt;

&lt;p&gt;先程説明したとおり、データ領域にheapを、関数呼び出しや関数ローカルなデータにstackを使っています。&lt;/p&gt;

&lt;p&gt;メモリの領域管理は先述の&lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;などをプログラマが手で書きます。手で管理するのでバグります。&lt;/p&gt;

&lt;h2 id=&#34;ruby&#34;&gt;Ruby&lt;/h2&gt;

&lt;p&gt;データ領域にはheapにmallocで確保した領域にヒープを確保し、その上にメモリ管理システム(GC)を構築して管理しています。&lt;/p&gt;

&lt;p&gt;関数呼び出しにはstackではなくheapに確保した自前のスタックを用意しています。
stackを使わないのはどうしてもC言語がstackを使うのでRubyも交ぜて使ってしまうと(Ruby自体C言語の上で動いていますね)問題が起こるだとかデータ構造として扱いづらいだとかGCとの兼ね合いだとかの理由だと思います。
また、そもそもRubyのメソッドとC言語の関数は別物という話もあります。&lt;/p&gt;

&lt;p&gt;また、実行用にスタックはありますが、データの実体はRubyのヒープに置かれます。Rubyのプログラムから高速なスタック領域を使うことができないのです。残念ですね。&lt;/p&gt;

&lt;p&gt;メモリの領域管理にはGCシステムを採用し、メモリ管理をユーザがすることはありません。
GCはmallocに少しデータを足したようなMark and Sweepです。メモリ確保はほぼmallocと同じで、気が向いたときに使っているデータにマークを付けていって、マークの付いていないデータを一括でfreeしてくれます。
メモリ確保（やポインタの扱い）がmallocに似ているのでC言語と協調するときに楽です。RubyはNative Extentionが作りやすいように設計されていますね。&lt;/p&gt;

&lt;p&gt;1つ注意しておくと、Rubyを実行するときにもメモリにtextやbss、dataなどの領域がありますが、それは「Rubyを実行するVMのための領域」であって「実行しているRubyスクリプトのための領域」ではありません。&lt;/p&gt;

&lt;h2 id=&#34;pythonやphp&#34;&gt;PythonやPHP&lt;/h2&gt;

&lt;p&gt;Rubyと同じようにヒープもスタックもheapに確保していると思います（面倒なのでソースを追っていない）。
メモリ管理システムはGCを使いますが、Rubyとは違って参照カウント方式を採用しています。&lt;/p&gt;

&lt;p&gt;参照カウントは、メモリ確保はmallocに似ていますが、確保した後の扱いが異なります。
値を参照する度にカウントを増やし、使わなくなったら参照を減らし、参照が0になったらfreeされます。
言語レベルでは意識するすることはありませんが、C言語のレイヤーでは一々参照の操作をしてあげないといけないので手間がかかります（たまに扱いを間違ってバグります）。
また、循環参照という問題もあって、たまに解放されないメモリがあったりします。（そのために結局たまにMark and Sweepのようなものが必要だったりします）&lt;/p&gt;

&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;

&lt;p&gt;Rubyと同じようにヒープもスタックもheapに確保しています(JVMのメモリについて調べてみると色々出てきます)。
30億のデバイスで走らせるための工夫ですね。&lt;/p&gt;

&lt;p&gt;同じくGCを使いますが、今度はCopy GC方式を採用しています（厳密にいうとHotSpot VMでの複数種類ある方式のうちの1つですが）。
Copy GCは面白くて、ヒープを2つに分割します。同時に使うのは1つだけです。メモリを確保するときは、使われていない領域などは無視して新たなスペースを確保します。
これはわざわざ空き領域を捜す必要がないので非常に高速です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------+
| data1 | data 2 | data 3 | -&amp;gt;    |
+---------------------------------+
+---------------------------------+
|                                 |
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてメモリが一杯になったら使っているデータだけもう1つの領域にコピーします。このとき、使っていなかった分は詰めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------+
|       | data 2 |                |
+---------------------------------+
+---------------------------------+
| data1 | data 3 | -&amp;gt;             |
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使っていなかったdata 2の存在を忘れて、2つを入れ替えたらメモリの回収完了です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------+
| data1 | data 3 | -&amp;gt;             |
+---------------------------------+
+---------------------------------+
|                                 |
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ヒープが半分しか使えないだとかデータが移動してしまうので扱いが難しいだとかの問題はあるのですが、確保が非常に高速で解放もかなり速い方式です。&lt;/p&gt;

&lt;p&gt;この方式はJavaの他にOCamlやHaskellなどの関数型言語でよく使われます。
データを頻繁にアロケートするのでメモリ確保が高速なこの方式が好まれるようです。&lt;/p&gt;

&lt;h2 id=&#34;rust&#34;&gt;Rust&lt;/h2&gt;

&lt;p&gt;RustはC言語と同じくデータ領域にheapを、関数呼び出しや関数ローカルなデータにstackを使っています。&lt;/p&gt;

&lt;p&gt;メモリの領域管理は&lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;などをコンパイラが自動で発効してくれます。なのでプログラマが自分で管理する必要はありません。&lt;/p&gt;

&lt;h1 id=&#34;高速なメモリの使い方&#34;&gt;高速なメモリの使い方&lt;/h1&gt;

&lt;p&gt;まず、一番速い方法は「そもそもメモリを確保しない」です。
これはコストが掛からないので高速です。
「何をふざけたことを」と思うかもしれませんが、プログラミングする上で「余計に確保しない」を意識するという意味で重要です。&lt;/p&gt;

&lt;p&gt;次はstackを使うと高速です。これはそもそもstackを意識して使える言語でないと選べない方法ですね。&lt;/p&gt;

&lt;p&gt;最後の手段としてheapを使います。&lt;/p&gt;

&lt;p&gt;GCのある言語ではGCの特性によってヒープの使い方も考える必要があります。
Mark and Sweepは生死に関らず確保したオブジェクトの数に比例してメモリ解放コストが掛かりますが、Copy GCでは生きているオブジェクトに比例してコストが掛かりますので、生きているオブジェクトを減らすと速くなります。
例えば使わないけど変数に束縛されているものがあるなら変数のスコープを狭めるだとか変数にnullを代入するだとか。
よほどメモリのせいで遅くなっていない限りあまりやりませんが（ゲームの人はよくやるらしい？）。&lt;/p&gt;

&lt;p&gt;また、最近の多くのGC（RubyもJavaも）には世代別GCといって、新しいデータと古いデータを分けて管理する方式が採用されているので作ったデータをすぐさま使ってすぐさま不要にすると速くなったりします。
例えばデータ列に対して個々のデータに処理1、2、3を適用したいなら処理1のループ、2のループ、3のループ、とするよりもループの中で処理1、2、3と適用した方が速くなります。
最近Scalaの次期コンパイラが高速化のためにそのような構成（phase fusioning）にしたらしいですね。
使っている言語でOld領域、New領域などの単語を聞いたことがあるなら多分世代別GCが使われています。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;スタックとヒープの話、そしてなぜスタックとヒープを意識したいかを説明しました。
ついでに、比較のためにGCのある言語についても少しだけ紹介しました。
けっこうふわふわとした説明なので「分かった気分」になりたいだけならこの記事で十分かと思いますが、もう少し踏み込んだことが知りたければ個別に調べてみて下さい。
また、メモリレイアウトについてはおおまかには合っているものの、結構嘘ついているのであまり鵜呑みにしないで下さい。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://th0x4c.github.io/blog/2012/10/10/os-virtual-memory-map/&#34;&gt;仮想メモリ空間のメモリマップを調べる - th0x4c 備忘録&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valinux.co.jp/technologylibrary/document/linux/malloc0001/&#34;&gt;malloc(3)のメモリ管理構造 | VA Linux Systems Japan株式会社&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ruby/ruby/blob/trunk/gc.c#L7649&#34;&gt;rubyのメモリ確保にmallocを使っている部分&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ruby/ruby/blob/trunk/vm_core.h#L705&#34;&gt;rubyのスタックの定義部分&lt;/a&gt;。これは引数スタックかな？コールスタックどこだろう…&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Cargoのサブプロジェクトとreplace</title>
      <link>/blog/2017/04/05/cargonosabupurojiekutotoreplace</link>
      <pubDate>Wed, 05 Apr 2017 20:46:26 +0900</pubDate>
      
      <guid>/blog/2017/04/05/cargonosabupurojiekutotoreplace</guid>
      <description>&lt;p&gt;κeenです。最近Cargoのreplace機能を使おうとしてハマったのでメモを残しておきます。&lt;/p&gt;

&lt;p&gt;
最近何箇所かで喋ったのでご存知の方もいらっしゃるかと思いますが、Cargoにはワークスペース機能があります。
fat repositoryスタイルに便利な機能で、1つのディレクトリ下に複数のサブプロジェクトを配置しつつ&lt;code&gt;target/&lt;/code&gt;は共有するのでマイクロプロジェクトのモジュール性とモノリシックプロジェクトのコンパイルの速さを実現することが出来ます。&lt;/p&gt;

&lt;p&gt;さて、問題になるのはクレートを公開するときの依存関係の記述です。
サブプロジェクト同士で依存し合っているので&lt;code&gt;Cargo.toml&lt;/code&gt;には&lt;code&gt;my-project-lib = {path = &amp;quot;../my-project-lib&amp;quot;}&lt;/code&gt; のような依存の記述がある筈です。
しかしながらローカルのクレートに依存していると&lt;code&gt;crates.io&lt;/code&gt;に公開は出来ません。
そこで今回はそれをどうにかするお話。&lt;/p&gt;

&lt;h1 id=&#34;replace&#34;&gt;replace&lt;/h1&gt;

&lt;p&gt;Cargoには&lt;a href=&#34;http://doc.crates.io/manifest.html#the-replace-section&#34;&gt;replace&lt;/a&gt;という機能があります。
特定のライブラリの特定のバージョンを、crates.ioにあるものではなくてユーザが指定した場所にあるものを使うように指示します。
&lt;a href=&#34;http://doc.crates.io/specifying-dependencies.html#overriding-dependencies&#34;&gt;Specifying Dependencies&lt;/a&gt;のドキュメントによると、以下のように使えます。&lt;/p&gt;

&lt;p&gt;例えば&lt;code&gt;uuid&lt;/code&gt;クレートを使っているときにそれが依存している&lt;code&gt;rand&lt;/code&gt;クレートにバグを見付けて修正し、修正した結果を試したいとします。
その時にreplaceは以下のように使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# ワークスペースの親プロジェクト
...

[replace]
&amp;quot;rand:0.3.14&amp;quot; = { path = &amp;quot;./rand&amp;quot; }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# ワークスペースの子プロジェクト

[package]
name = &amp;quot;my-awesome-crate&amp;quot;
version = &amp;quot;0.2.0&amp;quot;
authors = [&amp;quot;The Rust Project Developers&amp;quot;]

[dependencies]
uuid = &amp;quot;0.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;間接的に依存してる&lt;code&gt;rand:0.3.14&lt;/code&gt;を、crates.ioにあるものではなく指定したパスにあるものを使うように指示しています。&lt;/p&gt;

&lt;p&gt;この仕組みを使って先のローカルパス問題を解決出来ないでしょうか。すなわち、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# 子プロジェクト
[dependencies]
my-project-lib = &amp;quot;0.1.0&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、見た目上はcrates.ioにあるものに依存しておきつつ実際は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# 親プロジェクト
[replace]
&amp;quot;my-project-lib:0.1.0&amp;quot; = { path = &amp;quot;./my-project-lib&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように実際の依存先をローカルのパスに向ければ問題を解決できないでしょうか。&lt;/p&gt;

&lt;p&gt;この答えは、半分no、半分yesになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;replace&lt;/code&gt;はあくまでcrates.ioにあるものを置き換えるのでまだ公開していないプロジェクトに対しては使えません。
一方、一度crates.ioに公開してしまえば上記のテクニックは可能になります。&lt;/p&gt;

&lt;p&gt;なので一番最初にcrates.ioに公開する時の手順はやや煩雑になります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;(ローカルサブプロジェクトへの依存の記述は&lt;code&gt;path = &amp;quot;...&amp;quot;&lt;/code&gt;のまま)&lt;/li&gt;
&lt;li&gt;どのプロジェクトにも依存しないローカルサブプロジェクトを公開する&lt;/li&gt;
&lt;li&gt;既に公開されたローカルサブプロジェクトへの依存は順次&lt;code&gt;replace&lt;/code&gt;に書き換える&lt;/li&gt;
&lt;li&gt;ローカルパスへの依存のなくなったローカルプロジェクトから順に公開していく&lt;/li&gt;
&lt;li&gt;全てのサブプロジェクトのローカルサブプロジェクトへの依存が&lt;code&gt;replace&lt;/code&gt;に置き換わったら以後はそのまま使える。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;このようなテクニックは例えばdieselなどで&lt;a href=&#34;https://github.com/diesel-rs/diesel/blob/master/Cargo.toml#L21&#34;&gt;使われています&lt;/a&gt;。
この辺、改善あるといいですね。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>関数型プログラマからみたRust</title>
      <link>/blog/2017/04/04/kansuugatapuroguramakaramitarust</link>
      <pubDate>Tue, 04 Apr 2017 21:38:57 +0900</pubDate>
      
      <guid>/blog/2017/04/04/kansuugatapuroguramakaramitarust</guid>
      <description>&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;C++からRustに入った人あたりから「関数型言語から来た人のRustの感想を知りたい」とたまに言われるのでいつかブログ書こうか。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/848900720573075458&#34;&gt;2017年4月3日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;イントロ&#34;&gt;イントロ&lt;/h1&gt;

&lt;p&gt;私はRustをやる前にはCommon LispやSMLを主に使っていましたが、仕事ではScalaを使っていましたし他にもOCamlやSchemeやClojureやATS2やHaskellなどを書くこともありました。&lt;/p&gt;

&lt;p&gt;私を含めた多くの関数型言語経験者人が一度は &lt;a href=&#34;http://science.raphael.poss.name/rust-for-functional-programmers.html&#34;&gt;Rust for functional programmers&lt;/a&gt; を読んだことがあるかと思います。
このように関数型言語と比較して書かれるといかにも似た言語に見えるので私は興味を持ちました。そこで私は実際にRustに触れ始めたのです。&lt;/p&gt;

&lt;h1 id=&#34;構文&#34;&gt;構文&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;let&lt;/code&gt; があるのでおよそOCamlなどに似ているという印象を受けました。
デフォルトでイミュータブルですしパターンマッチやシャドイングなもどするのでまさにMLの&lt;code&gt;let&lt;/code&gt;そのものです。
行末にセミコロンが要求されますが、&lt;code&gt;in&lt;/code&gt;の代わりだと思うことにして自分をなだめました。
式指向で&lt;code&gt;return&lt;/code&gt;を書かなくて済むのも関数型言語らしさを感じました。&lt;/p&gt;

&lt;p&gt;関数定義の構文は手続型言語風ですが手続き型言語に馴れた人に寄り添うために必要なんだと思って深くは気にしないことにしました。&lt;/p&gt;

&lt;p&gt;一方、ジェネリクスの構文については憤りすら感じました。
どうして &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; を採用したのか、そもそも比較演算子の &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;と紛らわしい上に&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;の扱いでも困ることは目に見えていました。
私はML風に前置、あるいは少なくともHaskellのように関数と引数のように書くべきだと思いましたし、少なくともScalaのように型と値でカッコを分けるくらいはできるはずです。
しかしながら、不平を言っても始まらないので我慢して次に進むことにしました。&lt;/p&gt;

&lt;h1 id=&#34;言語機能&#34;&gt;言語機能&lt;/h1&gt;

&lt;p&gt;トレイト、タプル、代数的データ型とマッチ式、高階関数、型推論。
これらは明らかに関数型言語から輸入されたものです。
これはとても喜ばしいことです、なぜなら今までしていた通りのプログラミングを新しい言語でもできるからです！
関数の引数と返り値に型宣言が必要なのはMLプログラマとしては少し残念でしたがHaskellやIdrisも同じようなスタイルなのでそういうものと自分で納得しました。
そして私はさっそく、倉庫番のゲームを作り始めました。あの、十分にシンプルで、コンソールで動かせて、楽しいゲームです。&lt;/p&gt;

&lt;p&gt;しかしすぐにそううまい話はないと気付きます。
再帰的データ型を定義するとすぐにエラーになりますし（&lt;code&gt;Box&lt;/code&gt;が必要と気付くまでしばらくかかりました）、ハッシュテーブルを使うとすぐミュータブルが必要になります（ハッシュテーブルの操作が破壊的ということをすっかり忘れていました）。
そして何より所有権のせいで思うようにプログラムが書けませんでした。
関数型プログラミングではメモリは無尽蔵にあると思ってプログラミングするのでRustのパラダイムとはとてつもない隔りがありました。
最初は、所有権についてはCleanやGHCにある一意型、あるいはATS2の線形型のようなものだと思えばそう難しくないと踏んでいましたが、実際のところ何もかも思い通りにいきませんでした。
プログラム全てで所有権を意識するのが思いの外難しかったのです。
それでもコンパイル時にコードの安全性を検査出来るのは喜ばしいことだと思って、&amp;rdquo;ボローチェッカとの戦い&amp;rdquo;を数日続けました。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;ボローチェッカとの戦い&amp;rdquo;をしばらく続けて気付いたのは、コンパイラは理不尽な理由で怒ったりしていないということでした。
関数型言語ではデータほとんどイミュータブルなのでデータをコピーしたいのか参照したいのかあまり区別する必要がありませんでしたがRustでは厳密に区別しているだけのことでした。
むしろ、所有権の概念は、一度コンパイラの気持ちを理解してしまえば所有権や参照を意識せずにプログラミングするのが気持ち悪いとさえ感じるほどに自然でした。&lt;/p&gt;

&lt;p&gt;それ以外の点ではトレイトや導出はMLプログラマからすると羨望の的でしたし（余談ですがRustの導出は昔はHaskell風に&lt;code&gt;#[deriving(Show)]&lt;/code&gt;と書いていましたが、いつからか&lt;code&gt;#[derive(Debug)]&lt;/code&gt;と書くようになったようです。）、
オブジェクト指向についても上手くやっていると感じました（関数型プログラミング言語でもオブジェクト指向はします！）。&lt;/p&gt;

&lt;p&gt;Lispプログラマから一言あるとすれば、マクロです。RustのマクロはSchemeの&lt;code&gt;syntax-rules&lt;/code&gt;相当の機能しかなく、Common Lispプログラマの私にはもの足りませんでした。
&lt;code&gt;macro_rules&lt;/code&gt;でも無いよりはましですし、C言語のマクロよりは素晴らしいものです。
それでもどうしても伝統的なマクロが欲しくなりますが、不安定なコンパイラプラグインの機能しか選択肢がありません（訳注: 現在のRustにはproc_macroが入ったので伝統的なマクロも書けます）。&lt;/p&gt;

&lt;h1 id=&#34;ツール&#34;&gt;ツール&lt;/h1&gt;

&lt;p&gt;私の好きなEmacsのサポートはしっかりしていましたし、大きな不満はありませんでした。
REPLこそありませんがむしろSMLに比べると補完や定義ジャンプなどリッチな機能さえありました。&lt;/p&gt;

&lt;p&gt;それよりも、ビルドツールについてです。
Rustは関数型プログラムで永遠のテーマだった分割コンパイルをするとインライン化が妨げられるが全プログラムコンパイルをするとコンパイル時間が掛かりすぎるという問題にモジュールより上位のクレートという単位を設けることで解決を見出したのです。
それに素晴らしきCargo。依存関係の地獄はありませんし、Makefileを書く必要もありません。パッケージインストーラがランタイムにまで侵入してくることもありません。
私達がプログラムを書くことに集中させてくれます。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;関数型プログラマがRustを使うと、所有権やミュータビリティ、メモリへの厳しさに最初は面くらうもののすぐに馴れて普段通りにプログラムを書けるようになります。
もちろん、Rustはむしろ手続き型な言語なので関数型プログラムそのまま、とはいきませんが普段使っている道具がそのまま使えるのでハードルは低いですし、むしろ手続き型プログラムに馴れた人が戸惑わないか心配にすらなります（初めてC++プログラマがRustをスラスラ書けると聞いたときには大変驚きました）。
Rustは関数型プログラマ、手続き型プログラマ問わず良い言語なのでみなさんも最初の一歩を踏み出しましょう！&lt;/p&gt;

&lt;h1 id=&#34;メタ&#34;&gt;メタ&lt;/h1&gt;

&lt;p&gt;私のブログは記事によって意識的に文体を変えているのですが、今回は新たな試みとして「海外でちょっと流行った記事の野良和訳」風に書いてみました。
なので海外風に「明らかに」などの強いワードを用いたり誤訳っぽいワードを埋めたいあまつさえ（訳注:〜）なんてものが出現しますが特に原文はないです。
案外疲れました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>オーディナルの話とカーディナルの話</title>
      <link>/blog/2017/03/02/o_dinarunohanashitoka_dinarunohanashi</link>
      <pubDate>Thu, 02 Mar 2017 21:15:44 +0900</pubDate>
      
      <guid>/blog/2017/03/02/o_dinarunohanashitoka_dinarunohanashi</guid>
      <description>&lt;p&gt;ちょっとオーディナルの話をしよう。ついでにカーディナルの話もしよう。
特に何も知らなくても分かる内容。だけど文脈を知ってると伝えたいことが伝わる筈。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;まずは何もないところから始めよう。机もスマホもパソコンンもない。空気もないし数字もない、自然数もない。&lt;/p&gt;

&lt;p&gt;何もない。&lt;/p&gt;

&lt;p&gt;「何もない」、もうちょっと正確にいうと「何も要素がない集合」のことを覚えているだろうか。中学校で習った気もする。&lt;/p&gt;

&lt;p&gt;\[
\emptyset
\]&lt;/p&gt;

&lt;p&gt;と書く。
さて、ここから始める。何もないところから何か作れるだろうか。まずは $\emptyset$ を要素に持つ集合、&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset\}
\]&lt;/p&gt;

&lt;p&gt;がある。これは要素を1つだけ持つので $\emptyset$ とは異なる集合だ。これをさらに進められないだろうか。例えば&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \emptyset\}
\]&lt;/p&gt;

&lt;p&gt;とか。これではダメだ。結局2つの要素が同じ $\emptyset$ なので要素を取り出してみても $\{\emptyset\}$ から取り出したときと区別がつかない。
何か $\emptyset$ とは別のものが必要だ。 $\emptyset$ とは別のもの。既に出てきた。 $\{\emptyset\}$ だ。&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \{\emptyset\}\}
\]&lt;/p&gt;

&lt;p&gt;これで $\emptyset$ とも $\{\emptyset\}$ とも異なる集合が作れた。ここまできたらあとはもうパターンだ。「次」が欲しければ今までに出てきた集合を全部$\{\}$に放り込めばいい。&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\}
\]&lt;/p&gt;

&lt;p&gt;「次(Successor)」を求める手続を $\mathbf{succ}$ と書くとすると、集合の合併 $\cup$ を用いて&lt;/p&gt;

&lt;p&gt;\[
\mathbf{succ} (x) = x \cup \{x\}
\]&lt;/p&gt;

&lt;p&gt;と書ける。この $\mathbf{succ}$ 、必ず新たな集合を生み出している。これはつまり、任意の $x$ に対して $\mathbf{succ}(x)$ は $\emptyset$ にはならないし、 $x \not= y$ のとき $\mathbf{succ}(x) \not=\mathbf{succ}(y)$ でもある。
このようなものをご存知ないだろうか(細かいことを言うと帰納法の原理も必要だが飛ばす)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%9A%E3%82%A2%E3%83%8E%E3%81%AE%E5%85%AC%E7%90%86&#34;&gt;自然数&lt;/a&gt;だ。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$\emptyset$ がある&lt;/li&gt;
&lt;li&gt;任意の自然数 $x$ に $\mathbf{succ}(x)$ がある&lt;/li&gt;
&lt;li&gt;$\emptyset$ はいかなる自然数 $x$ の $\mathbf{succ}$ でもない&lt;/li&gt;
&lt;li&gt;$x \not= y$ のとき $\mathbf{succ}(x) \not=\mathbf{succ}(y)$&lt;/li&gt;
&lt;li&gt;(帰納法の原理が成り立つ)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これは、こういうことだ。&lt;/p&gt;

&lt;p&gt;\[
\begin{eqnarray}
0 &amp;amp; = &amp;amp; \emptyset \\\&lt;br /&gt;
1 &amp;amp; = &amp;amp; \{\emptyset\} \\\&lt;br /&gt;
2 &amp;amp; = &amp;amp; \{\emptyset, \{\emptyset\}\} \\\&lt;br /&gt;
3 &amp;amp; = &amp;amp; \{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\} \\\&lt;br /&gt;
  &amp;amp; \vdots &amp;amp;
\end{eqnarray}
\]&lt;/p&gt;

&lt;p&gt;ここでは &lt;a href=&#34;https://twitter.com/search?q=%230%E3%81%AF%E8%87%AA%E7%84%B6%E6%95%B0&amp;amp;src=typd&#34;&gt;#0は自然数&lt;/a&gt; としてある。
さて、今我々は何もないところから出発してDASH村のように自然数を作り上げた。&lt;/p&gt;

&lt;p&gt;この自然数、面白い性質がある。 0 は 1の要素( $0 \in 1$) だ。 1 は 2 の要素 ( $1 \in 2$ )だし、0も2の要素 $0 \in 2$ だ。もうちょっというと、 $x \in y$ かつ $y \in z$ のとき、 $x \in z$も成り立つ。
この関係で自然数には順序がつく。つまり、自然数は&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E9%A0%86%E5%BA%8F%E6%95%B0&#34;&gt;順序数&lt;/a&gt;(オーディナルナンバー)だ。再度、オーディナルナンバーであるところの自然数を列挙するとこうなる。&lt;/p&gt;

&lt;p&gt;\[
\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}, \{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\}, &amp;hellip;
\]&lt;/p&gt;

&lt;p&gt;これに見覚えがあるならオーディナルの話はこれで十分。&lt;/p&gt;

&lt;p&gt;さて、カーディナルの話をしよう。 $\emptyset$ は要素が0個。 $\{\emptyset\}$ は要素が1つ。 $\{\emptyset, \{\emptyset\}\}$ は要素が2つ。
要素数の話だ。これは別に自然数だけでなくて、 $\{2, 4\}$ のように自然数ではない集合でも要素数という概念はある。要素数をどう数えようか。一応要素数に&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%BF%83%E5%BA%A6_(%E6%95%B0%E5%AD%A6)&#34;&gt;濃度&lt;/a&gt;という名前もついている。
これにも自然数が使える。2と $\{2, 4\}$ を $\{2, 4\}$ を $2 -\emptyset$ と $4 - \{\emptyset\}$ と1対1に対応づければ、「$\{2, 4\}$と 2は同じ濃度を持つ」といえる。
このように濃度を数えるための数を&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0&#34;&gt;基数&lt;/a&gt;（カーディナルナンバー）という。&lt;/p&gt;

&lt;p&gt;手で数えられる（有限な）ものは面白みがない。無限なものについて考えよう。例えば今我々が作った自然数は常に $\mathbf{succ}$ がとれるので無限の要素がある。
まだ作ってないが、自然数だけでなく整数にも有理数にも実数にも無限の要素がある。これらの「無限」は全て同じ大きさなのだろうか、つまり同じ濃度なのだろうか。
結論からいうと自然数と整数と有理数は同じ濃度を持つ。全て自然数と1対1の対応が取れるということだ。一方&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB%E3%81%AE%E5%AF%BE%E8%A7%92%E7%B7%9A%E8%AB%96%E6%B3%95&#34;&gt;実数は対応が作れない&lt;/a&gt;。実数の濃度の方がずっと大きい訳だ。つまり、無限の間にも大小関係がある。実は自然数は無限の中でも一番小さい。この一番小さい基数のことをヘブライ文字からとって&lt;/p&gt;

&lt;p&gt;\[
\aleph_0
\]&lt;/p&gt;

&lt;p&gt;と書く。これも見覚えがあればカーディナルの話はこれにて重畳。&lt;/p&gt;

&lt;p&gt;そういえばこういう「紙の上でDASH村」を気に入ったならこの本がお勧め。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4791768515&#34;&gt;コンピュータは数学者になれるのか? -数学基礎論から証明とプログラムの理論へ- | 照井一成 |本 | 通販 | Amazon&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RustのちょっとやりすぎなBuilderパターン</title>
      <link>/blog/2017/02/09/rustnochottoyarisuginabuilderpata_n</link>
      <pubDate>Thu, 09 Feb 2017 23:03:45 +0900</pubDate>
      
      <guid>/blog/2017/02/09/rustnochottoyarisuginabuilderpata_n</guid>
      <description>&lt;p&gt;κeenです。Rustでちょっとやりすぎだけど使う側の自由度が高くて安全なBuilderパターンを思い付いたので紹介しますね。&lt;/p&gt;

&lt;p&gt;※2017-02-11T13:18:58Z+09:00 最下部に追記しました
&lt;/p&gt;

&lt;h1 id=&#34;目的コード&#34;&gt;目的コード&lt;/h1&gt;

&lt;p&gt;以下のような構造体のビルダーを作りたいとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-struct&#34;&gt;#[derive(Debug)]
struct Person {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;雑にやると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilder {
    id: Option&amp;lt;u32&amp;gt;,
    name: Option&amp;lt;String&amp;gt;,
    age: Option&amp;lt;u32&amp;gt;,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilder {
  pub fn new() -&amp;gt; Self { ... }
  pub fn id(self, id: u32) -&amp;gt; Self { ... }
  pub fn name(self, name: String) -&amp;gt; Self { ... }
  pub fn age(self, id: u32) -&amp;gt; Self { ... }
  pub fn address(self, address: String) -&amp;gt; Self { ... }
  pub fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // 返り値がOption型になってしまう
  pub fn build(self) -&amp;gt; Option&amp;lt;Person&amp;gt; {
    // try_opt!は標準ライブラリには存在しませんが各所で使われてるので動きは分かると思います
    Person {
       id: try_opt!(self.id),
       name: try_opt!(self.name),
       age: try_opt!(self.age),
       address: self.address,
       zipcode: self.zipcode,
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とbuildの返り値が&lt;code&gt;Option&lt;/code&gt;型になってしまい、あまりうれしくありません。
さらには例えば&lt;code&gt;id&lt;/code&gt;を2回呼んだらどうなるんだとかツッコミどころが数多くあります。&lt;/p&gt;

&lt;p&gt;ということで色々な回避策を先人達は考えてきました。&lt;/p&gt;

&lt;h1 id=&#34;不自由なコード&#34;&gt;不自由なコード&lt;/h1&gt;

&lt;p&gt;普通にやるなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilder {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilder {
  fn new(id: u32, name: String, age: String) -&amp;gt; Self { ... }
  fn address(self, address: String) -&amp;gt; Self { ... }
  fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // 返り値がOptionじゃない
  fn build(self) -&amp;gt; Person { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;Option&lt;/code&gt;でないフィールドをコンストラクタで受け取れば安全に作れますが、コンストラクタを呼ぶ時点でいくつかフィールドが揃っている必要がある、そもそも元の構造体と何が違うんだ、など色々問題があります。&lt;/p&gt;

&lt;h1 id=&#34;少しマシなコード&#34;&gt;少しマシなコード&lt;/h1&gt;

&lt;p&gt;オートマトンのようにビルダーが状態遷移するコードを使うと、1つ1つの引数をビルドしつつ安全なコードが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilderId;
struct PersonBuilderName{id: u32}
struct PersonBuilderAge{id: u32, name: String}
struct PersonBuilder {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilderId {
  pub fn new() -&amp;gt; Self { ... }
  // idの次はname
  pub fn id(self, id: u32) -&amp;gt; PersonBuilderName {
    PersonBuilderName { id: id }
  }
}

impl PersonBuilderName {
  // nameの次はage
  pub name(self, name: String) -&amp;gt; PersonBuilderAge {
    PersonBuilderAge {
      id: self.id,
      name: name,
    }
  }
}
impl PersonBuilderAge {
  // ageは最後
  pub name(self, age: u32) -&amp;gt; PersonBuilder {
    PersonBuilder {
      id: self.id,
      name: self.name,
      age: age,
      address: None,
      zipcode: None,
    }
  }
}

impl PersonBuilder {
  // 気持ち悪いけど PersonBuilderIdを返す
  pub fn new -&amp;gt; PersonBuilderId { ... }
  pub fn address(self, address: String) -&amp;gt; Self { ... }
  pub fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // これまたOptionじゃなくなってる
  pub fn build(self) -&amp;gt; Person { ... }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは以下のように&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
  let person = PersonBuilder::new()
         .id(1)
         .name(&amp;quot;κeen&amp;quot;.to_string())
         .age(24)
         .address(&amp;quot;Tokyo&amp;quot;.to_string())
         .build();
  println!(&amp;quot;{:?}&amp;quot;, person)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と使えます(即興で書いたので試してないけど)。&lt;/p&gt;

&lt;p&gt;とりあえず使えそうな気がしますが、型レベルで状態遷移をハードコードしているのでメソッドを呼び出す順番が固定されてしまいます。
なので以下はエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
  let person = PersonBuilder::new()
         // nameとidを逆順に呼び出してみる
         .name(&amp;quot;κeen&amp;quot;.to_string())
         .id(1)
         .age(24)
         .address(&amp;quot;Tokyo&amp;quot;.to_string())
         .build();
  println!(&amp;quot;{:?}&amp;quot;, person)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは単純に&lt;code&gt;struct PersonBuilderId&lt;/code&gt;、&lt;code&gt;struct PersonBuilderName{id: u32}&lt;/code&gt;、&lt;code&gt;struct PersonBuilderAge{id: u32, name: String}&lt;/code&gt;と作っていくのが面倒という話もあります。&lt;/p&gt;

&lt;p&gt;今回はそれを改善したいという話&lt;/p&gt;

&lt;h1 id=&#34;幽霊型を使ったフィールド状態&#34;&gt;幽霊型を使ったフィールド状態&lt;/h1&gt;

&lt;p&gt;今回提案するビルダー型はこれです。提案するといってもどうせ既に誰かが考えてるでしょうが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::marker::PhantomData;
struct Empty;
struct Filled;

struct PersonBuilder&amp;lt;Id, Name, Age&amp;gt; {
    id: Option&amp;lt;u32&amp;gt;,
    id_state: PhantomData&amp;lt;Id&amp;gt;,
    name: Option&amp;lt;String&amp;gt;,
    name_state: PhantomData&amp;lt;Name&amp;gt;,
    age: Option&amp;lt;u32&amp;gt;,
    age_state: PhantomData&amp;lt;Age&amp;gt;,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/marker/struct.PhantomData.html&#34;&gt;PhantomData&lt;/a&gt;という特殊な型を使ってビルダーに余計な型を付けています。&lt;/p&gt;

&lt;p&gt;この型、最初は&lt;code&gt;Empty&lt;/code&gt;から出発します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl PersonBuilder&amp;lt;Empty, Empty, Empty&amp;gt; {
    pub fn new() -&amp;gt; Self {
        PersonBuilder {
            id: None,
            id_state: PhantomData,
            name: None,
            name_state: PhantomData,
            age: None,
            age_state: PhantomData,
            address: None,
            zipcode: None,
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてフィールドが埋められると対応する型がEmptyからFilledになります。&lt;/p&gt;

&lt;p&gt;フィールドに&lt;code&gt;Some&lt;/code&gt;が埋められるのと同時に対応する&lt;code&gt;_state&lt;/code&gt;フィールドを&lt;code&gt;Empty&lt;/code&gt;から&lt;code&gt;Filled&lt;/code&gt;にすると整合性が崩れません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Id以外、つまりNameとAgeはいじらないのでジェネリクスに
impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        PersonBuilder {
            id: Some(id),
            id_state: PhantomData,
            name: self.name,
            name_state: self.name_state,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
impl&amp;lt;Id, Age&amp;gt; PersonBuilder&amp;lt;Id, Empty, Age&amp;gt; {
    // 地味なテクニックとして、SringではなくてInto&amp;lt;String&amp;gt;で受けることでリテラルのStringとかも受け取れる。
    pub fn name&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(self, name: S) -&amp;gt; PersonBuilder&amp;lt;Id, Filled, Age&amp;gt; {
        PersonBuilder {
            id: self.id,
            id_state: self.id_state,
            name: Some(name.into()),
            name_state: PhantomData,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}

impl&amp;lt;Id, Name&amp;gt; PersonBuilder&amp;lt;Id, Name, Empty&amp;gt; {
    pub fn age(self, age: u32) -&amp;gt; PersonBuilder&amp;lt;Id, Name, Filled&amp;gt; {
        PersonBuilder {
            id: self.id,
            id_state: self.id_state,
            name: self.name,
            name_state: self.name_state,
            age: Some(age),
            age_state: PhantomData,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt;のままで構わないフィールドについては雑で構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;Id, Name, Age&amp;gt; PersonBuilder&amp;lt;Id, Name, Age&amp;gt; {
    pub fn address&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(mut self, address: S) -&amp;gt; Self {
        self.address = Some(address.into());
        self
    }

    pub fn zipcode&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(mut self, zipcode: S) -&amp;gt; Self {
        self.zipcode = Some(zipcode.into());
        self
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして必須フィールド全てが満たされた時にだけ&lt;code&gt;build&lt;/code&gt;が呼べます。&lt;code&gt;unwrap&lt;/code&gt;を呼んでますが安全であることに注意して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl PersonBuilder&amp;lt;Filled, Filled, Filled&amp;gt; {
    pub fn build(self) -&amp;gt; Person {
        Person {
            id: self.id.unwrap(),
            name: self.name.unwrap(),
            age: self.age.unwrap(),
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、呼び出しが非常に自由になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let person = PersonBuilder::new()
        .age(24)
        .id(1)
        .address(&amp;quot;Tokyo&amp;quot;)
        .name(&amp;quot;κeen&amp;quot;)
        .build();
    println!(&amp;quot;{:?}&amp;quot;, person);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メソッドは自由に組み換えられますが、必須フィールドがなかったら&lt;code&gt;build&lt;/code&gt;が呼べません（コンパイルエラー）になります。&lt;/p&gt;

&lt;p&gt;これは応用も出来て、それぞれの状態が独立しているので例えば「2つのVector合計3つ以上要素が入っていたら」、とか「R、G、BあるいはH、S、Vの3つが揃っていたら」とかオートマトンではエンコードしづらいものでも比較的楽に書けます。&lt;/p&gt;

&lt;p&gt;ということで便利なbuilderが出来ました。めでたしめでたし。といいたいところですが、ちょっとコードが冗長ですよね。マクロで生成なんかも出来るのですがあまりやりたくありません。ということで「ちょっとやりすぎな」Builderパターンでした。&lt;/p&gt;

&lt;h1 id=&#34;some-like-it-unsafe&#34;&gt;Some like it unsafe&lt;/h1&gt;

&lt;p&gt;上のコード、実はもうちょっと短く書けます。ただし&lt;code&gt;unsafe&lt;/code&gt;な機能を使いますが。&lt;/p&gt;

&lt;p&gt;こう書いていたものが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        PersonBuilder {
            id: Some(id),
            id_state: PhantomData,
            name: self.name,
            name_state: self.name_state,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/mem/fn.transmute.html&#34;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;を使うことで2行になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::transmute;

impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(mut self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        self.id = Some(id);
        unsafe { transmute(self) }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すごいですね。
しかし、案外しょっちゅうtransmuteはミスなどで間違った変換をしてしまう（上記で言えばidフィールドを更新したのにname_stateの型を変更してしまう）上に型検査で弾けないので個人的にはあまりおすすめ出来ません。
これも「ちょっとやりすぎ」なTipsでした。&lt;/p&gt;

&lt;h1 id=&#34;2017-02-11t13-18-58z-09-00-追記&#34;&gt;2017-02-11T13:18:58Z+09:00 追記&lt;/h1&gt;

&lt;p&gt;qnighyさんからもっと便利な方法の提案がありました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;こう &lt;a href=&#34;https://t.co/undNgEM2IQ&#34;&gt;https://t.co/undNgEM2IQ&lt;/a&gt; やったらunwrapしなくてすみそう？ / “RustのちょっとやりすぎなBuilderパターン | κeenのHappy Hacκing Blog” &lt;a href=&#34;https://t.co/ogDOpYifjh&#34;&gt;https://t.co/ogDOpYifjh&lt;/a&gt;&lt;/p&gt;&amp;mdash; Masaki⊣Hara (@qnighy) &lt;a href=&#34;https://twitter.com/qnighy/status/830053476096843776&#34;&gt;2017年2月10日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;実際のコードはこちら。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/qnighy/e7a833eebd57ef778eaff3a8ab3649d7.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;transmuteを使ったサボった実装は出来なくなるけどそもそも余計なフィールドを使う必要がなくなるので手軽ですね。&lt;/p&gt;

&lt;p&gt;qnighyさんありがとうございました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Deprecating CIM</title>
      <link>/blog/2017/01/29/deprecating_cim</link>
      <pubDate>Sun, 29 Jan 2017 22:18:24 +0900</pubDate>
      
      <guid>/blog/2017/01/29/deprecating_cim</guid>
      <description>&lt;p&gt;I&amp;rsquo;m κeen. I have a sad news, I&amp;rsquo;ll stop the development of &lt;a href=&#34;https://github.com/KeenS/CIM&#34;&gt;CIM&lt;/a&gt; and no more updates for new lisp impls will be provided.

It has been months from when I stopped developping CIM and only providing updates for new lisp impl versions.
From that point, CIM is a half-dead product. I know there are still someone using CIM though, so I kept updating.
For present CIM users, I recomend to migrate to &lt;a href=&#34;https://github.com/roswell/roswell&#34;&gt;roswell&lt;/a&gt;, also a lisp installer and manager, which is well-maintained.&lt;/p&gt;

&lt;p&gt;CIM has been developed in my studenthood for my practice in shell scripts. This is my first OSS.
The reason why I wrote CIM in shell script other than for practice is that shell scripts are the most portable and available script language on Unix-like systems.
The original purpose of writing a new manager is to provide a consistent way of launching CLs from CLI.
To realize that, managing lisp impls, including installing is needed so CIM has started to manage impls.
At some point, CIM was used such products like &lt;a href=&#34;https://github.com/luismbo/cl-travis&#34;&gt;cl-travis&lt;/a&gt;.
But CIM lacked flexibility of development as it is written in ugly shell script, and lacked Windows support.
As I got a job and got interests other than lisp such as Rust, I have no more time to spend for maintaining CIM.&lt;/p&gt;

&lt;p&gt;Thus &lt;a href=&#34;https://github.com/snmsts&#34;&gt;@snmsts&lt;/a&gt;, the author of roswell, started to develop roswell to support Windows.
Roswell is written mainly in Lisp though booting from C, so many of Lispers may be able to hack it.
Roswell is well-maintained because stmsts is, unlike me, a hobby Lisper, professional lisper and he uses roswell in daily work.
Besides roswell is well-maintained, roswell is more feature-rich than CIM.
It searchs for new lisp versions for itself so there is no need to update manager itself to update your local lisp impls.
It is distributed from package managers such like homebrew and AUR so you don&amp;rsquo;t need to care about updating it.
Using &lt;code&gt;dump&lt;/code&gt; feature of roswell, you can create an executable binary from a lisp script in a command.
And so on. There are many reasons to use roswell even if CIM would be kept maintained.&lt;/p&gt;

&lt;p&gt;Anyway I wish CIM users to keep using lisp via roswell. Thank you for staying with me for a long time.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのモジュールの使い方</title>
      <link>/blog/2017/01/15/rustnomoju_runokirikata</link>
      <pubDate>Sun, 15 Jan 2017 20:52:14 +0900</pubDate>
      
      <guid>/blog/2017/01/15/rustnomoju_runokirikata</guid>
      <description>&lt;p&gt;κeenです。たまにRustのモジュールが分かりづらいとの声を聞くので解説しますね。&lt;/p&gt;

&lt;p&gt;
とりあえずサンプルプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new module
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;エラいのは-lib-rs-と-main-rs&#34;&gt;エラいのは &lt;code&gt;lib.rs&lt;/code&gt; と &lt;code&gt;main.rs&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;モジュールの話をする前にクレートの話をしないといけません。
クレートはRustのプログラムの一番大きな単位です。
大きく分けてライブラリを作るlibクレートと実行可能ファイルを作るbinクレートがあります。&lt;/p&gt;

&lt;p&gt;libクレートならば&lt;code&gt;lib.rs&lt;/code&gt;が、binクレートならば&lt;code&gt;main.rs&lt;/code&gt;がルートにあたるファイルです。ここから辿れるモジュールが全てです。プロジェクトにファイルが存在していてもこれらから辿れなかったらコンパイルされません。&lt;/p&gt;

&lt;h1 id=&#34;モジュールの作り方は3種類&#34;&gt;モジュールの作り方は3種類&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;ファイルの中にインラインで作る&lt;/li&gt;
&lt;li&gt;1ファイルで作る&lt;/li&gt;
&lt;li&gt;1ディレクトリで作る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;のやり方があります。 1.はそんなに使われなくて、説明のために1ファイルにまとめたい時や、可視性でアレコレする時のテクニックなんかに使われます。&lt;/p&gt;

&lt;p&gt;2.と3.の境界はサブモジュールを持つかどうかです。&lt;/p&gt;

&lt;p&gt;2.のファイルで作る時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように作っておいて、lib.rsの中を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod new_module;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;mod&lt;/code&gt;で参照してあげれば使えます。&lt;/p&gt;

&lt;p&gt;3.のディレクトリの時もそんなに変わらなくて、&lt;code&gt;lib.rs&lt;/code&gt;は変わらず、ファイルを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module
src/new_module/mod.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにしてあげます。&lt;code&gt;mod.rs&lt;/code&gt;の名前はこれでないといけません。丁度サブモジュールの&lt;code&gt;new_module&lt;/code&gt;にとっての&lt;code&gt;lib.rs&lt;/code&gt;のような存在が&lt;code&gt;mod.rs&lt;/code&gt;な訳です。&lt;/p&gt;

&lt;h1 id=&#34;兄弟モジュール同士の可視性&#34;&gt;兄弟モジュール同士の可視性&lt;/h1&gt;

&lt;h2 id=&#34;モジュールの身分&#34;&gt;モジュールの身分&lt;/h2&gt;

&lt;p&gt;さて、次のように2つのモジュールを作ってみましょう。lib.rsには&lt;code&gt;module_a&lt;/code&gt;のみ&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;module_a.rs&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build
   Compiling module v0.1.0 (file:///home/kim/Rust/module)
error[E0432]: unresolved import `module_a`
 --&amp;gt; src/lib.rs:1:5
  |
1 | use module_a;
  |     ^^^^^^^^ no `module_a` in the root

error: aborting due to previous error

error: Could not compile `module`.

To learn more, run the command again with --verbose.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と怒られます。一番エラいのは&lt;code&gt;lib.rs&lt;/code&gt;ですから、身分の低い &lt;code&gt;module_a&lt;/code&gt;では&lt;code&gt;mod&lt;/code&gt;宣言出来ません。&lt;/p&gt;

&lt;h2 id=&#34;君の名は&#34;&gt;君の名は&lt;/h2&gt;

&lt;p&gt;同じ設定で、&lt;code&gt;lib.rs&lt;/code&gt;に&lt;code&gt;module_a&lt;/code&gt;と&lt;code&gt;module_b&lt;/code&gt;両方を&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時、&lt;code&gt;module_b&lt;/code&gt;が&lt;code&gt;lib.rs&lt;/code&gt;から見た時と&lt;code&gt;module_a.rs&lt;/code&gt;から見た時で名前が変わります。&lt;/p&gt;

&lt;p&gt;lib.rsから見た時は、以下の3つが使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use self::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self&lt;/code&gt;というのは予約語で、ディレクトリでいうところの&lt;code&gt;.&lt;/code&gt;に相当します。&lt;/p&gt;

&lt;p&gt;module_a.rsからは同じく3つが使えますが、相対パスが変わります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;super&lt;/code&gt;も予約語で、&lt;code&gt;..&lt;/code&gt;に相当します。
ファイルが同じディレクトリにいるので分かりづらいですが、libが1つ上の階層で、その下にmodule_aとmodule_bがぶら下がってる感じですね。&lt;/p&gt;

&lt;h1 id=&#34;おじさんと隠し子&#34;&gt;おじさんと隠し子&lt;/h1&gt;

&lt;p&gt;次のように、サブモジュールを作ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$src
src/lib.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この時&lt;code&gt;sumbmodule&lt;/code&gt;から見た&lt;code&gt;module_b&lt;/code&gt;の名前はどうなるでしょうか。もうお分かりかと思いますが、以下の3つです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃ、逆に&lt;code&gt;module_b&lt;/code&gt;から見た&lt;code&gt;submodule&lt;/code&gt;はどうなるでしょうか。実は、&lt;code&gt;module_b&lt;/code&gt;から&lt;code&gt;submodule&lt;/code&gt;は見えません（lib.rsからも見えません）。&lt;code&gt;module_a&lt;/code&gt;1つで所帯を持っているので子である&lt;code&gt;submodule&lt;/code&gt;を外に出すかは&lt;code&gt;module_a&lt;/code&gt;の一存で決まります。今回は隠し子にしている訳ですね。いくら兄弟モジュールとはいえ家庭にまでは入り込めないのです。&lt;/p&gt;

&lt;p&gt;子供をちゃんと公開するには&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていたモジュール宣言を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてあげればOKです。そうすると&lt;code&gt;module_b&lt;/code&gt;からも見えて、以下の3種類で参照出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a::submodule;
use module_a::submodule;
use super::module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;木箱の外から&#34;&gt;木箱の外から&lt;/h1&gt;

&lt;p&gt;さて、今までは1クレート内での話でした。クレートの外から見るとどうなるでしょうか。&lt;/p&gt;

&lt;p&gt;新たに&lt;code&gt;main.rs&lt;/code&gt;を追加しましょう。先程 &lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;がエラいと話しましたが、どちらも別々のクレートを作るので&lt;code&gt;main.rs&lt;/code&gt;は完全にクレートの外です。&lt;/p&gt;

&lt;p&gt;こんな感じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/main.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、外部のクレートを参照するには&lt;code&gt;extern crate&lt;/code&gt;を書く必要があります。あとまあ、binクレートなので&lt;code&gt;main&lt;/code&gt;関数も必要ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.rs
extern carte module;
fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、&lt;code&gt;module_b&lt;/code&gt;はどういう名前で見えるでしょうか。見えません。一番エラい&lt;code&gt;lib.rs&lt;/code&gt;が&lt;code&gt;module_b&lt;/code&gt;を&lt;code&gt;pub&lt;/code&gt;にしていないのでクレートの外からは見えなくなっています。見たければ、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにします。&lt;/p&gt;

&lt;p&gt;さて、これでmain.rsからどのように見えるかというと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module::module_b;
use module::module_b;
use self::module::module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように気持的にルート直下にクレートがモジュールとして配置されたように見えます。&lt;/p&gt;

&lt;h1 id=&#34;家出&#34;&gt;家出&lt;/h1&gt;

&lt;p&gt;さて、同じように&lt;code&gt;lib.rs&lt;/code&gt;で&lt;code&gt;module_a&lt;/code&gt;を&lt;code&gt;pub mod&lt;/code&gt;すれば&lt;code&gt;module::module_a::submodule&lt;/code&gt;も参照出来るようになります。ところで、例えば&lt;code&gt;module_a&lt;/code&gt;は外に出さずに&lt;code&gt;submodule&lt;/code&gt;だけを公開したい時にはどうしたらいいでしょうか。そんなケースあるのかと疑問に思うかもしれませんが、あります。同じクレートであっても&lt;code&gt;pub&lt;/code&gt;にしないとサブモジュールにアクセス出来ないことを思い出して下さい。そうすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub mod submodule;
pub mod internal_submodule_a;
pub mod internal_submodule_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなケースが発生するのは想像出来ると思います。そういう時は、&lt;code&gt;lib.rs&lt;/code&gt;側でどうにかいじれます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていると思いますが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、&lt;code&gt;pub use&lt;/code&gt; を加えてあげることで&lt;code&gt;module_a&lt;/code&gt;の下から出すことが出来ます。&lt;/p&gt;

&lt;p&gt;これを&lt;code&gt;main.rs&lt;/code&gt;から使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように名字の&lt;code&gt;module_a&lt;/code&gt;が取れます。&lt;/p&gt;

&lt;p&gt;さらに踏み込めば、&lt;code&gt;use&lt;/code&gt;は&lt;code&gt;as&lt;/code&gt;を使ってリネーム出来るので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule as module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにリネーム&lt;code&gt;use&lt;/code&gt;してあげれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように参照することも出来ます。完全に籍を外れて名前の上では別人ですね。&lt;/p&gt;

&lt;p&gt;実装する時の都合とAPIとして公開する時の都合が違うので公開用にいじれる作りになってるんですね。&lt;/p&gt;

&lt;h1 id=&#34;lib-rsとmain-rs&#34;&gt;lib.rsとmain.rs&lt;/h1&gt;

&lt;p&gt;上では&lt;code&gt;lib.rs&lt;/code&gt;を使って説明しましたが、&lt;code&gt;main.rs&lt;/code&gt;でも同じことが出来ます。&lt;/p&gt;

&lt;p&gt;さて、ここからはスタイルの話ですが、私がRustを書く時は&lt;code&gt;main.rs&lt;/code&gt;の中に&lt;code&gt;mod&lt;/code&gt;を書くことはないです。必ず&lt;code&gt;lib.rs&lt;/code&gt;を作って、そこでライブラリとしてまとめてから&lt;code&gt;main.rs&lt;/code&gt;で使います。「アプリケーションはアプリケーションを記述するための巨大なDSLとそれを使った小さな実装からなる」という思想ですね。明示的に境界を作ることで自然とAPIを設計出来るのでコードが整理しやすくなります。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;が一番エラい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mod&lt;/code&gt; で「モジュールがある」宣言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub mod&lt;/code&gt; で加えて上位のモジュールにも公開&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt;と&lt;code&gt;super&lt;/code&gt;の予約語&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub use&lt;/code&gt; で改名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;力尽きてテストのためのモジュールの話が出来なかったので&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/testing.html#tests-%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB&#34;&gt;ドキュメント&lt;/a&gt;を読んでみて下さい。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;https://github.com/BurntSushi/fst/blob/master/src/lib.rs&#34;&gt;これ&lt;/a&gt;のようにテクニックが詰まった&lt;code&gt;lib.rs&lt;/code&gt;ファイルなんかも存在するので参考にどうぞ。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>頑張らないLinuxデスクトップ環境</title>
      <link>/blog/2017/01/10/linuxdesukutoppukankyou</link>
      <pubDate>Tue, 10 Jan 2017 22:07:31 +0900</pubDate>
      
      <guid>/blog/2017/01/10/linuxdesukutoppukankyou</guid>
      <description>&lt;p&gt;κeenです。みんなカスタマイズしてLinux使っているようなのであまりカスタマイズしてない私のものも紹介しますね。&lt;/p&gt;

&lt;p&gt;因みに私は会社でMac使ってたら使いにくすぎてVMに逃げたくらいのLinuxユーザです。家では勿論Linuxしか使ってないです。
&lt;/p&gt;

&lt;h1 id=&#34;ディストリ&#34;&gt;ディストリ&lt;/h1&gt;

&lt;p&gt;Ubuntu。定番。色々言う人がいるけど何も不満はない。&lt;/p&gt;

&lt;h1 id=&#34;ウィンドウマネージャ-統合デスクトップ環境&#34;&gt;ウィンドウマネージャ（統合デスクトップ環境）&lt;/h1&gt;

&lt;p&gt;Unity。デフォルト。&lt;/p&gt;

&lt;h1 id=&#34;im&#34;&gt;IM&lt;/h1&gt;

&lt;p&gt;uim-skk。何故uim-かというと最初にたまたまそれを使ったから。&lt;/p&gt;

&lt;h1 id=&#34;ブラウザ&#34;&gt;ブラウザ&lt;/h1&gt;

&lt;p&gt;FireFox。確かデフォルト。入れてる拡張はkeysnailのみ。&lt;/p&gt;

&lt;h1 id=&#34;twitterクライアント&#34;&gt;Twitterクライアント&lt;/h1&gt;

&lt;p&gt;公式Web。新機能の追加が一番早くて便利。&lt;/p&gt;

&lt;h1 id=&#34;ターミナルエミュレータ&#34;&gt;ターミナルエミュレータ&lt;/h1&gt;

&lt;p&gt;gnome-terminal。デフォルト。速いし簡単に背景半透明に出来るし何も不満はない。tmuxと一緒に使ってる。&lt;/p&gt;

&lt;h1 id=&#34;エディタ&#34;&gt;エディタ&lt;/h1&gt;

&lt;p&gt;Emacs。デフォルトではない。毎日masterをコンパイルして使う。&lt;/p&gt;

&lt;h1 id=&#34;キーバインド変更&#34;&gt;キーバインド変更&lt;/h1&gt;

&lt;p&gt;xmodmap + &lt;a href=&#34;https://github.com/k0kubun/xremap&#34;&gt;xremap&lt;/a&gt;。これ CF &lt;a href=&#34;http://k0kubun.hatenablog.com/entry/xkremap&#34;&gt;Linux向けの最強のキーリマッパーを作った - k0kubun&amp;rsquo;s blog&lt;/a&gt;。
CapsLockとctrlのスワップにxmodmapを、Emacs風バインドを作るためにxremapを使ってる。xremapは別になくてもどうにかなる。&lt;/p&gt;

&lt;h1 id=&#34;メーラ&#34;&gt;メーラ&lt;/h1&gt;

&lt;p&gt;Thunderbird。確かデフォルト。でもUbuntuのパッケージは更新が遅いので手でインストールしてる。&lt;/p&gt;

&lt;h1 id=&#34;カレンダー&#34;&gt;カレンダー&lt;/h1&gt;

&lt;p&gt;Thunderbird + Lightening拡張。Googlカレンダーと同期出来るし便利。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;このくらいかな？フォントもデフォルト。あとはSlackに公式クライアントだとか偶に音楽再生にrythmbox（デフォルト）だとか画像表示にeog（デフォルト）だとかPDF表示にevice（デフォルト）だとかファイラにnautilus（デフォルト）スクリーンショットにgnome-screenshot（デフォルト）だとかを使うけどこの辺は当たり前なので書かなくていいかな。&lt;/p&gt;

&lt;p&gt;ということでそんなにカスタマイズしなくてもLinuxは便利なのでみなさん使いましょう。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Idein Incに入社しました</title>
      <link>/blog/2017/01/06/idein_incninyuushashimashita</link>
      <pubDate>Fri, 06 Jan 2017 20:53:12 +0900</pubDate>
      
      <guid>/blog/2017/01/06/idein_incninyuushashimashita</guid>
      <description>&lt;p&gt;κeenです。本日を以ちまして&lt;a href=&#34;http://idein.jp/&#34;&gt;Idein Inc.&lt;/a&gt;に入社したので報告します。&lt;/p&gt;

&lt;p&gt;退職エントリは&lt;a href=&#34;http://keens.github.io/blog/2016/11/30/saiba_e_jientowotaishokushimashita/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;経緯&#34;&gt;経緯&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Lisp Meet Upで社長の&lt;a href=&#34;https://twitter.com/9_ties&#34;&gt;@9_ties&lt;/a&gt;さんと知り合う&lt;/li&gt;
&lt;li&gt;その他勉強会で何度か一緒になってよく喋るようになる&lt;/li&gt;
&lt;li&gt;オフィス訪問に誘われて行ったら入社を誘われる（7月末）&lt;/li&gt;
&lt;li&gt;入社することにする（9月半ば）&lt;/li&gt;
&lt;li&gt;入社（現在）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;わさびずとideinに遊びに来たよ。噂のpi zero&lt;br&gt;クラスタとかPEZYとかあった。熱い。 &lt;a href=&#34;https://t.co/MEc7qdosrk&#34;&gt;pic.twitter.com/MEc7qdosrk&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/759655196628615168&#34;&gt;2016年7月31日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;結構前から水面下で話は進んでました。&lt;/p&gt;

&lt;p&gt;割と「PEZYに行くの？」という質問が多かったのですが中らずとも遠からずといったところでしょうか。PEZY Computingとも取引があったりする会社です。&lt;/p&gt;

&lt;h1 id=&#34;どんな会社&#34;&gt;どんな会社？&lt;/h1&gt;

&lt;p&gt;私が7人目（バイトを抜いたら6人目）の社員になる、少数精鋭なスタートアップです。全社員に1つのチャットで連絡が取れます。
この規模ながらフルタイムのリサーチャがいるなど、かなり技術寄りな会社です。創業者も全員技術者です。社員の中ではクソザコクラスになるので明日から人権があるか心配ですがどうにか上手くやっていきます。&lt;/p&gt;

&lt;p&gt;今3期目とのことです。&lt;/p&gt;

&lt;p&gt;社長に「なんて紹介したらいいですか」って言ったら「うーん、困るなぁ」と言われました（苦笑。
Big Pictureとしてはコンピュテーショナルセンサーを使って世の中に起きているあらゆる事象をソフトウェアで扱えるようにしたい、というもの。ざっくり言ってしまえばIoTの会社になるんですかね。
でもじゃあ電子工作ばっかやってるのかというとそういう訳でもなくて、例えばカメラから得られた画像から色々な情報を抜き出すために機械学習やらディープラーニングやらをやっていたり、さらにそれをセンサーデバイス（Rasp Piとか）上で走らせるために効率化したりとソフトウェア技術のウェイトがかなり大きいです。&lt;/p&gt;

&lt;p&gt;例えばニューラルネットワークの学習済みデータを最適化（軽量化）してさらにコンパイル（！！）して組込みデバイス上でも満足な速度で動かすための技術開発なんかをやっています。&lt;/p&gt;

&lt;p&gt;あるいはセンサーから取得したデータを使えるプラットフォームなんかも。&lt;/p&gt;

&lt;h1 id=&#34;どんな仕事するの&#34;&gt;どんな仕事するの？&lt;/h1&gt;

&lt;p&gt;私の仕事もそういう文脈からきていて、例えばニューラルネットをコンパイルしてRasp PiのGPUで動かすだとか、あるいはもうちょっと特化したデバイス（ぼかしてる）のためのコンパイラを作るだとかの仕事になります。
自分で書いておきながらやっぱり「ニューラルネットをコンパイルする」っていう字面がパワーある。
今、（学習ではなくて予測に）使われているのはほとんどがモデルと実行器が分けらています。要はインタプリタなのでそれをコンパイルしてあげて高速に実行するというのが可能なんですね。
ニューラルネットの圧縮のために数学が必要そうな雰囲気で、数学出来ない私は震え上がってます。&lt;/p&gt;

&lt;p&gt;会社全体としてはデバイスの開発も一応やりつつ、データを処理するための技術開発、共同研究、技術開発も含めた受託案件、あるいは開発した技術を使った受託案件なんかもやっています。
かなり技術開発への投資が強いイメージですが、今期は黒字予定と案外バランスの取れた運営をしているようです（結構色々な会社が興味を持ってくれているようです。
センサーだとかの文脈になるのでお客さんはハードウェアの会社が多いようです。&lt;/p&gt;

&lt;h1 id=&#34;初日の感想は&#34;&gt;初日の感想は？&lt;/h1&gt;

&lt;p&gt;会社が移転した（前のオフィスだと私のスペースがなかった）のでほとんど環境構築でした。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;環境構築してる &lt;a href=&#34;https://t.co/6HLHbnOmi6&#34;&gt;pic.twitter.com/6HLHbnOmi6&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/817252587703414789&#34;&gt;2017年1月6日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;オフィス引っ越し中 &lt;a href=&#34;https://t.co/MnrNUxxUP7&#34;&gt;pic.twitter.com/MnrNUxxUP7&lt;/a&gt;&lt;/p&gt;&amp;mdash; y͛amaday͛ (@yamaday) &lt;a href=&#34;https://twitter.com/yamaday/status/817203674036305921&#34;&gt;2017年1月6日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;落ち着いたあとはQiita::Teamを全部読んでました。社長も技術者なので事業プランや資金計画（売り上げ）なんかもQiita::Teamに上がってるのが新鮮でした。&lt;/p&gt;

&lt;p&gt;社員に2名ほどRustをやってる人がいて「κeen君来たし仕事でRust使っていくかー」みたいな感じになりました。使えそうな案件があったら積極的に使っていきたいですね。&lt;/p&gt;

&lt;h1 id=&#34;結びに&#34;&gt;結びに&lt;/h1&gt;

&lt;p&gt;前回転職祝いを沢山頂いたので今回は例のURLは控えさせて頂きます。
前回送りそびれたのでどうしてもという方は&lt;a href=&#34;http://keens.github.io/blog/2016/11/30/saiba_e_jientowotaishokushimashita/&#34;&gt;退職エントリ&lt;/a&gt;の方から辿って頂けると幸いです。&lt;/p&gt;

&lt;p&gt;また、Ideinではエンジニアを募集しています&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;募集職種&#34;&gt;募集職種&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ソフトウェアエンジニア（画像処理）
画像処理に関する基本的な知識を持っている方（画像処理の実装経験がある方歓迎）&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（バックエンド）
分散システムの構築やDevOpsに興味があり、最新の技術の動向を追っている方。場合によっては自ら実装が出来る方&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（フロントエンド）
最新の技術動向に明るく、移り変わりの激しい技術のコンテキストを理解して吸収でき、UXを考慮した実装が出来る方&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（組み込み）
計算機を低いレイヤーまで理解し、ハードウェアの仕様を読み解いて必要機能の実装が出来る方&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（言語処理系）
計算機アーキテクチャや数値計算アルゴリズムに精通しており、最適化コンパイラやプログラミング環境をフルスクラッチで実装出来る方&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下のスキルセットを持っている方を歓迎します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++, Python, Haskell,Rust, etc&amp;hellip;&lt;/li&gt;
&lt;li&gt;Git（分散VCS）&lt;/li&gt;
&lt;li&gt;DevOps関連技術(Docker,Ansible,etc&amp;hellip;)&lt;/li&gt;
&lt;li&gt;GPU&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;すべての職種に一貫して、現在のスキルセットよりは以下に挙げるような事柄への知識や興味を優先します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;アルゴリズムとデータ構造&lt;/li&gt;
&lt;li&gt;計算機&lt;/li&gt;
&lt;li&gt;プログラミング言語&lt;/li&gt;
&lt;li&gt;ソフトウェア工学&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;待遇-給与&#34;&gt;待遇・給与&lt;/h1&gt;

&lt;p&gt;社保完備 月収60万円〜（正社員）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因みに私はポテンシャル採用されたタイプで「壁に当たっても自分で調べて乗り越えていけそう」だとか「コンパイラを書いてると心が折れそうになる瞬間があるけどそこで折れないような人が大事だ」とか言われました。頑張ります。&lt;/p&gt;

&lt;p&gt;ということで皆様の応募お待ちしております！！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>QUICの中身が分からないから仕様読んでみた</title>
      <link>/blog/2017/01/02/quicnonakamigawakaranaikarashiyouyondemita</link>
      <pubDate>Mon, 02 Jan 2017 10:46:39 +0900</pubDate>
      
      <guid>/blog/2017/01/02/quicnonakamigawakaranaikarashiyouyondemita</guid>
      <description>&lt;p&gt;κeenです。先日同期と話しててQUICの中身ってあまり知らないよねってことでQUICの仕様（ドラフト）を読んだのでまとめますね。あまりまとめきれてませんが。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;strong&gt;※ドラフトは既に古くなっているのでこのブログの内容は現行では正しくない可能性があります。というか一部既に正しくないことが判明しています。ご注意下さい&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;後で新しいドラフトを発見したので内容を書き換えました。とりあえずリンクを貼ってあるドラフトの内容までは反映出来ています。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;仕様を読む前にQUICの背景から。
HTTP/2でHTTPにストリームという概念が入りました。
1つのコンテンツ毎に順にやりとりするのではなく、複数のコンテンツを並行して通信する仕組みです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 今まで
[]--CCCBBBAAA--&amp;gt;[]

# HTTP/2
[]--ACCBCABBA--&amp;gt;[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の図でいえば例えばAのコンテンツがサーバの都合で遅くてもBやCのコンテンツが支える（Head of Line Blocking）ことなくクライアントに届きます。&lt;/p&gt;

&lt;p&gt;ところで、この通信はTCP上で行われています。TCPは到達順序を保障するので例えば1パケット欠損したらそれ以後のパケットは（実際にはクライアントに到着しているにも関らず）待たされます(TCP Head of Line Blocking)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[]--ACCBCABB-X--&amp;gt;[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この図でいえばAのパケットが欠損してますが、HTTP/2的にはAは無視してBやCのコンテンツをユーザに届けることは可能な訳です。
この辺を改善したいというのがQUICのモチベーション。&lt;/p&gt;

&lt;p&gt;もうちょっと言うとTCPの3way hand shakeだとかその上のTLS hand shakeだとかのオーバーヘッドの削減の目的もあります。
TCPやTLSもRTTを減らそうと努力はしていますが、もっと抜本的な解決が必要とのことです。&lt;/p&gt;

&lt;p&gt;ということでHTTP/2に特化してTCP+TLSを置き換えるための通信プロトコルとしてUDPベースのQUICが産まれました。&lt;/p&gt;

&lt;p&gt;ここまではよくあるQUICの説明。でも、これだけだと情報が少なくてもやもやしますよね。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP/2に特化とはいうけどどこまで特化してるの？他のアプリケーションで使えないの？&lt;/li&gt;
&lt;li&gt;どうしてTLSも統合してしまったの？分離出来なかったの？&lt;/li&gt;
&lt;li&gt;UDPベースでどうやってコネクションの維持や輻輳制御してるの？&lt;/li&gt;
&lt;li&gt;上記以外でQUICに特徴はないの？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などなど。これらの疑問を解決すべくQUICのドラフトを読んでいきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;quic&#34;&gt;QUIC&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/draft-tsvwg-quic-protocol-02&#34;&gt;これ&lt;/a&gt;を読んでいきます。Expires July 16, 2016とのこと。&lt;/p&gt;

&lt;h2 id=&#34;イントロ&#34;&gt;イントロ&lt;/h2&gt;

&lt;p&gt;QUICはHTTP/2のストリーム分割やフローコントロール、TLSのセキュリティ、TCPのコネクションセマンティクスや信頼性、輻輳制御を提供します。&lt;/p&gt;

&lt;p&gt;QUICはUDPベースの通信プロトコルなので、完全にユーザーランドで完結します。
これは重要な話で、レガシーなネットーワーク中間機器の上でもちゃんと通信出来ることを意味します。
仕様化する前に実証実験をする上でとても重要な性質です。&lt;/p&gt;

&lt;h2 id=&#34;用語&#34;&gt;用語&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;クライアント: QUICコネクションを開始する端&lt;/li&gt;
&lt;li&gt;サーバ: QUICコネクションを受け付ける端&lt;/li&gt;
&lt;li&gt;エンドポイント: サーバ、またはクライアント&lt;/li&gt;
&lt;li&gt;ストリーム: QUICコネクションの論理チャネル内を双方向に流れるバイト列の流れ&lt;/li&gt;
&lt;li&gt;コネクション: 単一の暗号コンテキスト下のQUICエンドポイント同士のやりとり。複数のストリームを持つ。&lt;/li&gt;
&lt;li&gt;コネクションID: QUICコネクションのID&lt;/li&gt;
&lt;li&gt;QUIC Packet: QUICでパース可能な有効なUDPペイロード。QUICのパケットサイズとはUDPのペイロードのサイズを指す。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;QUIC(+HTTP/2)のTCP+TLS(+HTTP/2)に対する利点は以下を改善することです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コネクション確立のレイテンシ&lt;/li&gt;
&lt;li&gt;柔軟な輻輳制御&lt;/li&gt;
&lt;li&gt;Head of Line Blockingなしに多重化&lt;/li&gt;
&lt;li&gt;ヘッダやペイロードが認証/暗号化されている&lt;/li&gt;
&lt;li&gt;ストリーム及びコネクションフローコントーロール&lt;/li&gt;
&lt;li&gt;前方エラー訂正&lt;/li&gt;
&lt;li&gt;コネクション移行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思ったより特徴ありますね。コネクション移行とか面白そう。
さて、それぞれ見ていきます。忙しい人は概要まででもそれなりに役立つでしょう。&lt;/p&gt;

&lt;h3 id=&#34;コネクション確立のレイテンシ&#34;&gt;コネクション確立のレイテンシ&lt;/h3&gt;

&lt;p&gt;通常TCP+TLSだと1-3RTT必要なのに対してQUICは多くの場合0 RTTでコネクション確立出来ます。つまり、いきなりデータを送れる。&lt;/p&gt;

&lt;p&gt;0 RTTで接続出来ない場合、つまりハンドシェイクが必要な場合もある訳ですが、ハンドシェイクの詳細はQUIC Cryptoの方に投げられています。
さらにQUIC CryptoはTLS 1.3に置き換えられる予定なのでほぼTLS 1.3のハンドシェイクだと思っておいて良いようです。&lt;/p&gt;

&lt;h3 id=&#34;柔軟な輻輳制御&#34;&gt;柔軟な輻輳制御&lt;/h3&gt;

&lt;p&gt;QUICはプラガブルな輻輳制御を持っており、TCPより豊富なシグナルがあるのでTCPの輻輳制御アルゴリズムより賢く振る舞うことが出来ます。
とはいっても現状の（ドラフト時点の）GoogleではTCPのアルゴリズムを流用しており別のアプローチを実験中とのこと。&lt;/p&gt;

&lt;p&gt;詳細は&lt;a href=&#34;https://tools.ietf.org/html/draft-quic-loss-recovery&#34;&gt;ここ&lt;/a&gt;にあるとのことでしたが、リンク切れなのか真っ白なページしかありません。&lt;/p&gt;

&lt;p&gt;さて、シグナルが豊富とのことでしたが、1例を出すとパケットの元のものと再送されたものでシーケンス番号が異ります(私はTCPの詳細を知らないのでよく分かりませんが輻輳制御のためにシーケンス番号を振っているのでしょう)。
元と再送のものを区別出来るようになるのでTCPの曖昧性問題（というのがあるのでしょう）を解決出来るとのこと。&lt;/p&gt;

&lt;p&gt;また、パケットを受け取ってからackを送るまでの時差と単調増加するシーケンス番号も一緒に送るのでRTTを計算することが出来ます。&lt;/p&gt;

&lt;p&gt;最後に、ACKが256 NACKまでサポートする（らしい）のでTCPのSACKよりもリオーダリングに弾力性があり、パケロスやリオーダリングがある環境下でもパケット密度を高めることが出来るとのこと。これは後程記述があります。&lt;/p&gt;

&lt;p&gt;この辺はTCPの輻輳制御から勉強しないと利点が分からないですね。宿題。&lt;/p&gt;

&lt;h3 id=&#34;ストリーム及びコネクションフローコントーロール&#34;&gt;ストリーム及びコネクションフローコントーロール&lt;/h3&gt;

&lt;p&gt;順番が前後しますがストリームの話。そういえばHTTP/2にバックプレッシャーありましたね。&lt;/p&gt;

&lt;p&gt;ストリームレベル、コネクションレベルでのフロー制御が出来ます。
ほぼHTTP/2と同等のストリーム制御が可能です。&lt;/p&gt;

&lt;p&gt;ストリームレベルの制御は、まず、受け取り側がストリーム内のデータのどのオフセットまでを受け取るかを広報します。
ストリームにデータが届いたら、WINDOW_UPDATEのフレームを投げて、受け取り可能なオフセットを更新します。&lt;/p&gt;

&lt;p&gt;コネクションレベルの制御は、ストリーム合計でのバッファを制限するために使います。
単純にストリームでやっている制御をコネクションレベルでやるだけです。&lt;/p&gt;

&lt;p&gt;また、TCPにあるようにreceive-windowのオートチューニングもやるそうです。&lt;/p&gt;

&lt;p&gt;この辺、HTTP/2に合わせた仕様なんですね。&lt;/p&gt;

&lt;h3 id=&#34;多重化&#34;&gt;多重化&lt;/h3&gt;

&lt;p&gt;TCP head of line blockingしない。因みにHTTP/2のヘッダはHPACKで圧縮して送るのでここはhead of line blockingします。&lt;/p&gt;

&lt;h3 id=&#34;ヘッダやペイロードが認証-暗号化されている&#34;&gt;ヘッダやペイロードが認証/暗号化されている&lt;/h3&gt;

&lt;p&gt;そもそもの話、TCPは平文で通信するのでreceive-windowの更新やらシーケンス番号を上書きしたりやらの攻撃が可能です（尤も、通信の最適化のために中間機器で行うこともありますが）。&lt;/p&gt;

&lt;p&gt;QUICは一部のヘッダを除き暗号化されています。暗号化されていない部分も受理側によって認証されるのでインジェクションを阻止出来ます。&lt;/p&gt;

&lt;p&gt;ここでTLSも統合している理由が分かりました。認証のためにTLSが必要なんですね。&lt;/p&gt;

&lt;h3 id=&#34;前方エラー訂正&#34;&gt;前方エラー訂正&lt;/h3&gt;

&lt;p&gt;Forward Error Correction (FEC)。シンプルなXORベースのFECをやるそうです。FECグループ内の1パケットがロスしてもFECパケットから復元出来るとのこと。すごい。&lt;/p&gt;

&lt;h3 id=&#34;コネクション移行&#34;&gt;コネクション移行&lt;/h3&gt;

&lt;p&gt;TCPは4-tuple(source address, port, destinacion address, port)でコネクションを判別しますが、それだと例えばスマホが電話通信（って呼称でいいのかな？）からWifiに切り替わった時にIPが変わりますし、NAT下でポート番号が変わることもあるので突発的にコネクションが切れてしまう訳です。&lt;/p&gt;

&lt;p&gt;QUICはクライアントがランダム生成した64bitのコネクションIDで識別します。
じゃあ、コネクションIDを被せにいったらハイジャック出来るじゃんと思えますが、TLSを前提にしているのでクライアント認証も自動でついていて、その辺には耐性があります。&lt;/p&gt;

&lt;h2 id=&#34;パケットタイプとフォーマット&#34;&gt;パケットタイプとフォーマット&lt;/h2&gt;

&lt;p&gt;2種類の特殊パケットと2種類の通常パケットがあります。バージョンネゴシエーションパケットとパブリックリセットパケット、フレームパケットとFECパケットです。&lt;/p&gt;

&lt;p&gt;パケットはIPの断片化を防ぐためにパスのMTU（Message Transfer Unit）に収まる必要がありますが、MTUの発見はまだWIPだそうです。
今とのころIPv6で1350byte、IPv4で1370byteを使っているとのこと。&lt;/p&gt;

&lt;h3 id=&#34;バブリックヘッダ&#34;&gt;バブリックヘッダ&lt;/h3&gt;

&lt;p&gt;全てのQUICパケットにつくヘッダです。パブリックの名の通り暗号化されません。&lt;/p&gt;

&lt;p&gt;長さは2-19byteの間になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      0        1        2        3        4            8
+--------+--------+--------+--------+--------+---    ---+
| Public |    Connection ID (0, 8, 32, or 64)    ...    | -&amp;gt;
|Flags(8)|      (variable length)                       |
+--------+--------+--------+--------+--------+---    ---+

     9       10       11        12
+--------+--------+--------+--------+
|      QUIC Version (32)            | -&amp;gt;
|         (optional)                |
+--------+--------+--------+--------+

    13      14       15        16        17       18
+--------+--------+--------+--------+--------+--------+
|         Packet Number (8, 16, 32, or 48)            |
|                         (variable length)           |
+--------+--------+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;軽く説明しますね。それぞれの詳しい内容は仕様を読んで下さい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;public flagsにパケットタイプなどが入っています。&lt;/li&gt;
&lt;li&gt;コネクションIDが64bitだと過剰な場合はネゴって短かくすることも可能です。&lt;/li&gt;
&lt;li&gt;パケット番号はフレームパケットに付与されます。1から始まり1づつ大きくなります。&lt;/li&gt;
&lt;li&gt;パケット番号の下位64bitはTLSのnonceの一部に使われます。合理的ですね。&lt;/li&gt;
&lt;li&gt;内部的には64bitでシーケンス番号を管理するけどパケットに載せるのは48bitまで。&lt;/li&gt;
&lt;li&gt;48bit(n bit)でオーバーフローした時の曖昧性排除のために2^46個(2^(n-2)個)までしか同時にパケットを送れない&lt;/li&gt;
&lt;li&gt;シーケンス番号が2^64-1に逹したらシーケンス番号のリミットでコネクションクローズが走る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;パケットタイプを判別するフローチャートが載っていたので引用しますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Check the public flags in public header
                 |
                 |
                 V
           +--------------+
           | Public Reset |    YES
           | flag set?    |---------------&amp;gt; Public Reset Packet
           +--------------+
                 |
                 | NO
                 V
           +------------+          +-------------+
           | Version    |   YES    | Packet sent |  YES
           | flag set?  |---------&amp;gt;| by server?  |--------&amp;gt; Version Negotiation
           +------------+          +-------------+               Packet
                 |                        |
                 | NO                     | NO
                 V                        V
           Regular Packet         Regular Packet with
                              QUIC Version present in header
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;スペシャルパケット&#34;&gt;スペシャルパケット&lt;/h3&gt;

&lt;h4 id=&#34;バージョンネゴシエーションパケット&#34;&gt;バージョンネゴシエーションパケット&lt;/h4&gt;

&lt;p&gt;サーバからのみ送られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     0        1        2        3        4        5        6        7       8
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
| Public |    Connection ID (64)                                                 | -&amp;gt;
|Flags(8)|                                                                       |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+

     9       10       11        12       13      14       15       16       17
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
|      1st QUIC version supported   |     2nd QUIC version supported    |   ...
|      by server (32)               |     by server (32)                |
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特に順序に言及がないのでクライアントは良い感じに新しいやつ選ぶんですかね。&lt;/p&gt;

&lt;h4 id=&#34;パブリックリセットパケット&#34;&gt;パブリックリセットパケット&lt;/h4&gt;

&lt;p&gt;コネクションをクローズしようとしているのが本当に正しいクライアントなのか証明するための情報が載せられます。詳細は仕様を読んで下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     0        1        2        3        4         8
+--------+--------+--------+--------+--------+--   --+
| Public |    Connection ID (64)                ...  | -&amp;gt;
|Flags(8)|                                           |
+--------+--------+--------+--------+--------+--   --+

     9       10       11        12       13      14
+--------+--------+--------+--------+--------+--------+---
|      Quic Tag (32)                |  Tag value map      ... -&amp;gt;
|         (PRST)                    |  (variable length)
+--------+--------+--------+--------+--------+--------+---
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通常パケット&#34;&gt;通常パケット&lt;/h3&gt;

&lt;p&gt;通常パケットのペイロードは暗号化/認証されます。パブリックヘッダは暗号化されませんが認証されます。
通常パケットはPrivate Flagsから始まるプライベートヘッダを持ちます（そこからが暗号化されます）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     0        1
+--------+--------+
|Private | FEC (8)|
|Flags(8)|  (opt) |
+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このあとにAEAD (authenticated encryption and associated data)、つまり認証/暗号化されたペイロードが続きます。&lt;/p&gt;

&lt;h4 id=&#34;フレームパケット&#34;&gt;フレームパケット&lt;/h4&gt;

&lt;p&gt;プライベートヘッダに続いてこんな感じのデータが続きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+---...---+--------+---...---+
| Type   | Payload | Type   | Payload |
+--------+---...---+--------+---...---+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fecパケット&#34;&gt;FECパケット&lt;/h3&gt;

&lt;p&gt;プライベートヘッダに続いてこんな感じのデータが続きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-----...----+
| Redundancy |
+-----...----+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quicコネクションのライフサイクル&#34;&gt;QUICコネクションのライフサイクル&lt;/h2&gt;

&lt;h3 id=&#34;コネクションの確立&#34;&gt;コネクションの確立&lt;/h3&gt;

&lt;p&gt;クライアントがバージョン付きでデータを送って、サーバが処理出来るならそのままレスポンスを返してコネクション成立です。
もし処理出来ないなら、バージョンネゴシエーションパケットを送り返して、クライアントはそこから1つバージョンを選んで再送します。サーバから通常レスポンスが返ってきたらコネクション成立です（成立するまで繰り返します）。&lt;/p&gt;

&lt;p&gt;ダウングレード攻撃を避けるためにハンドシェイクにバージョン情報を載せたり頑張るようですが、細かいので仕様を読んで下さい。&lt;/p&gt;

&lt;h3 id=&#34;データ転送&#34;&gt;データ転送&lt;/h3&gt;

&lt;p&gt;多くは概要で説明した通り。
暗号化ハンドシェイクも含めてストリーム内でデータをやりとりしますが、ACKはQUICパケット単位です。&lt;/p&gt;

&lt;p&gt;シーケンス番号は輻輳制御を統合するためにコネクションを通して同じ番号空間を共有します。&lt;/p&gt;

&lt;p&gt;詳しくは付設のドキュメントを読めと書いてますが、リンク先が真っ白です。&lt;/p&gt;

&lt;h4 id=&#34;ストリームのライフサイクル&#34;&gt;ストリームのライフサイクル&lt;/h4&gt;

&lt;p&gt;ストリームはデータをストリームフレームに分割してデータ転送します。
ストリームフレームは互いに順序逆転可能です。
ストリームの生成/クローズはサーバ、クライアント両方から出来ます。
ほとんどHTTP/2のストリームと同じですね。&lt;/p&gt;

&lt;p&gt;ストリーム生成は特にネゴる必要なく簡単に可能です。ただ、ストリームIDが衝突しないようにサーバが作る時は偶数、クライアントが作る時は奇数を使います。
0は無効、1は暗号化ハンドシェイクのために予約、3はHTTPヘッダの通信のために予約とされています。ヘッダだけは順序保障が必要なんですね。
他の細かい規約は仕様を見て下さい。&lt;/p&gt;

&lt;p&gt;一旦ストリームが開いたらデータ転送に自由に使えます。&lt;/p&gt;

&lt;p&gt;ストリームの終了には3種類あります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;普通の終了: 双方向通信なのでFIN bitを立てて送信した後のhalf-closeとかの概念があります。&lt;/li&gt;
&lt;li&gt;突然の終了: 何かしらのエラーがあった時などにRST_STREAMフレームを送ると強制終了出来ます。&lt;/li&gt;
&lt;li&gt;コネクションが終了した時: まあ、当然ですね。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;コネクションの終了&#34;&gt;コネクションの終了&lt;/h3&gt;

&lt;p&gt;コネクションの終了にも2種類あります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;明示的な終了: CONNECTION_CLOSEを送ることでコネクションを終了出来ます。&lt;/li&gt;
&lt;li&gt;暗黙的な終了: タイムアウト（デフォルト30秒）したらクローズします。通常はCONNECTION_CLOSEを送りますが、モバイルで電波をonにしたくないなどの理由があればsilent closeも可能です。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;それ以外に、PUBLIC_RSTでコネクションをクローズ出来ます。TCPのRST相当（だそう）です。&lt;/p&gt;

&lt;h2 id=&#34;フレームタイプとフォーマット&#34;&gt;フレームタイプとフォーマット&lt;/h2&gt;

&lt;p&gt;前述の通りフレームパケットにはフレームが入っています。フレームタイプ毎にデータの解釈が変わります。
1フレームは必ず1パケットに収まる必要があります。&lt;/p&gt;

&lt;h3 id=&#34;フレームタイプ&#34;&gt;フレームタイプ&lt;/h3&gt;

&lt;p&gt;特殊フレームと通常フレームがあります。&lt;/p&gt;

&lt;p&gt;特殊フレームは以下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------------------+-----------------------------+
| Type-field value |     Control Frame-type      |
+------------------+-----------------------------+
|     1fdooossB    |  STREAM                     |
|     01ntllmmB    |  ACK                        |
|     001xxxxxB    |  CONGESTION_FEEDBACK        |
+------------------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常フレームは以下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------------------+-----------------------------+
| Type-field value |     Control Frame-type      |
+------------------+-----------------------------+
| 00000000B (0x00) |  PADDING                    |
| 00000001B (0x01) |  RST_STREAM                 |
| 00000010B (0x02) |  CONNECTION_CLOSE           |
| 00000011B (0x03) |  GOAWAY                     |
| 00000100B (0x04) |  WINDOW_UPDATE              |
| 00000101B (0x05) |  BLOCKED                    |
| 00000110B (0x06) |  STOP_WAITING               |
| 00000111B (0x07) |  PING                       |
+------------------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのタイプについて仕様に載っている順に軽く説明します。詳しくは仕様を読んで下さい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;STREAM: 暗黙的にstreamを作るのにもデータを送るのにも使います。&lt;/li&gt;
&lt;li&gt;ACK: ackです。受け取った最大シーケンス番号とそれまでで欠損している番号のリストを送ります。前述の通り受理からACKまでの時差を入れたりと複雑なので仕様を読んで下さい。&lt;/li&gt;
&lt;li&gt;STOP_WAITING: 特定以下のシーケンス番号のパケットを待たないように指示します。&lt;/li&gt;
&lt;li&gt;WINDOW_UPDATE: コネクション/ストリームいずれかのウィンドウ余白を通知します。Stream ID 0がコネクションレベルのアップデートです。&lt;/li&gt;
&lt;li&gt;BLOCKED: バックプレッシャーでこれ以上データを送信出来ない時に送ります。informational frameです(ほぼデバッグ用とのこと)。&lt;/li&gt;
&lt;li&gt;CONGESTION_FEEDBACK: experimentalで、not usedとのこと。&lt;/li&gt;
&lt;li&gt;PADDING: 0x00で埋められたデータを保持します。パケットをMTUまで埋めるのが目的なのかな？&lt;/li&gt;
&lt;li&gt;RST_STREAM: ストリームの異常終了用。&lt;/li&gt;
&lt;li&gt;PING: 生きてる？って訊くやつです。これを受けたらACKを返します。デフォルトで15秒毎に送ります。&lt;/li&gt;
&lt;li&gt;CONNECTION_CLOSE: closeを通知するやつです。&lt;/li&gt;
&lt;li&gt;GOAWAY: コネクションを止めるよ通知です。近くcloseするのでデータ送るのやめなよという通知です。新たなstreamが作れなくなります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;quicの通信上のパラメータ&#34;&gt;QUICの通信上のパラメータ&lt;/h2&gt;

&lt;p&gt;ハンドシェイクでネゴシエートすべきパラメータの列挙です。&lt;/p&gt;

&lt;h3 id=&#34;required&#34;&gt;Required&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SFCW - Stream Flow Control Window: ストリームレベルのコントロールフローウィンドウサイズ(バイト単位)です。&lt;/li&gt;
&lt;li&gt;SFCW - Connection Flow Control Window: コネクションレベルのコントロールフローウィンドウサイズ(バイト単位)です。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ほとんどルー語ですね。&lt;/p&gt;

&lt;h3 id=&#34;optional&#34;&gt;Optional&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SRBF - Socket receive buffer size in bytes: CWNDを受け取りバッファくらいに指定したい場合があるらしいのでそれ用。&lt;/li&gt;
&lt;li&gt;TCID - Connection ID truncation: クライアントのエフェメラルポートが単一コネクションにしか使われないと分かっている場合に便利らしいです。&lt;/li&gt;
&lt;li&gt;COPT - Connection Options are a repeated tag field: 実験的パラメータだそうです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;プライオリティ&#34;&gt;プライオリティ&lt;/h2&gt;

&lt;p&gt;HTTP/2のものを使うそうですが、まだ実装してないとのこと。&lt;/p&gt;

&lt;h2 id=&#34;quic上のhttp-2&#34;&gt;QUIC上のHTTP/2&lt;/h2&gt;

&lt;p&gt;いくつかHTTP/2と同じ機能を提供していますが、HTTP/2がQUICを使う時にどう統合するかのお話です。&lt;/p&gt;

&lt;h3 id=&#34;ストリームマネジメント&#34;&gt;ストリームマネジメント&lt;/h3&gt;

&lt;p&gt;QUICが代替機能を提供するのでHTTP/2レイヤで扱う必要はありません。HTTP/2のストリームIDはそのままQUICのストリームIDになります。&lt;/p&gt;

&lt;h3 id=&#34;ヘッダー圧縮&#34;&gt;ヘッダー圧縮&lt;/h3&gt;

&lt;p&gt;Stream ID 3で送ることになっている（QUICの仕様でHTTP/2のヘッダを扱うことになっている）。のでそれを使います。&lt;/p&gt;

&lt;h3 id=&#34;http-2ヘッダのパース&#34;&gt;HTTP/2ヘッダのパース&lt;/h3&gt;

&lt;p&gt;ヘッダのパースはHTTP/2の仕様に従います。&lt;/p&gt;

&lt;h3 id=&#34;永続コネクション&#34;&gt;永続コネクション&lt;/h3&gt;

&lt;p&gt;コネクションという概念がないのでHTTPにある&amp;rdquo;Connection&amp;rdquo;ヘッダが意味をなさない。ので、HTTPレベルでのコネクションハンドリングはしません。&lt;/p&gt;

&lt;p&gt;これ、&amp;rdquo;Connection: upgrade&amp;rdquo;はどうするんですかねって思ったら次に書いてました。&lt;/p&gt;

&lt;h3 id=&#34;httpでのquicネゴシエーション&#34;&gt;HTTPでのQUICネゴシエーション&lt;/h3&gt;

&lt;p&gt;クライアントが普通のHTTPでアクセスした時にサーバはQUICを使いませんか、とネゴシエーションすることが出来ます。それが&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Alternate-Protocol: 123:quic&amp;rdquo;&lt;/p&gt;

&lt;p&gt;です。同じホストの123ポートにQUICプロトコルでアクセスしにいきます。
中間機器がUDPをブロックすることも考えてTCPにgraceful fallbackしろ、と書かれてます。&lt;/p&gt;

&lt;h2 id=&#34;ハンドシェイクプロトコルへの要求&#34;&gt;ハンドシェイクプロトコルへの要求&lt;/h2&gt;

&lt;p&gt;ハンドシェイク自体はこのドキュメントでは扱ってませんが、ハンドシェイクが満たすべき性質を書いています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0-RTTでのコネクション確立&lt;/li&gt;
&lt;li&gt;ソースアドレスのなりすまし対策&lt;/li&gt;
&lt;li&gt;クライアントからソースアドレストークンが不透明なこと。トークンにいくつかのクライアント情報を埋め込むため。&lt;/li&gt;
&lt;li&gt;通信パラメータのネゴシエーション&lt;/li&gt;
&lt;li&gt;証明書の圧縮。REJも1350bytesに収めたい。&lt;/li&gt;
&lt;li&gt;サーバコンフィグのアップデート&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上が仕様の主だった記述です。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;HTTP/2に特化とはいうけどどこまで特化してるの？他のアプリケーションで使えないの？&lt;br /&gt;
→ ストリームやHTTP/2ヘッダなどが統合されているのでかなり扱いづらい。&lt;/li&gt;
&lt;li&gt;どうしてTLSも統合してしまったの？分離出来なかったの？&lt;br /&gt;
→ クライアント認証のために必要だった。TLS1.3からは分離出来る（？）&lt;/li&gt;
&lt;li&gt;UDPベースでどうやってコネクションの維持や輻輳制御してるの？&lt;br /&gt;
→ コネクションはコネクションIDで維持。輻輳制御は別の仕様（アクセス不可）に書いてある&lt;/li&gt;
&lt;li&gt;上記以外でQUICに特徴はないの？&lt;br /&gt;
→ 柔軟な輻輳制御、FEC、コネクション移行など&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新たに湧いた疑問&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ロードバランシングどうするんだろう。ミドルウェアレベルだとConnection ID見て振り分けるとして、アプリケーションレベルだとRubyとかでよくあるlistenしてforkしてacceptするようなやつは破綻しないかな。そもそもQUICを使わない？&lt;/li&gt;
&lt;li&gt;Connection IDが衝突したらどうなるんだろう。REJするのかな。仕様に書いてない。&lt;/li&gt;
&lt;li&gt;いくつかの仕様（HTTP/2ヘッダ）とかを無視して別のアプリケーションで使えないかな。あるいは想定してないのかな。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;宿題:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCPについても調べる。特に輻輳制御回り。&lt;/li&gt;
&lt;li&gt;QUICの輻輳制御について調べる。&lt;/li&gt;
&lt;li&gt;TLS1.3との統合について調べる&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>2017年注目していきたい技術</title>
      <link>/blog/2017/01/01/2017nenchuumokushiteikitaigijutsu</link>
      <pubDate>Sun, 01 Jan 2017 22:12:01 +0900</pubDate>
      
      <guid>/blog/2017/01/01/2017nenchuumokushiteikitaigijutsu</guid>
      <description>&lt;p&gt;κeenです。毎年これやっていく。個人的に注目していきたい技術と飛び込んでみたい技術書いく。&lt;/p&gt;

&lt;p&gt;あくまで個人的な内容。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;webassembly-http-webassembly-org&#34;&gt;&lt;a href=&#34;http://webassembly.org/&#34;&gt;WebAssembly&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;ブラウザ上で動く仮想アセンブラ。ブラウザ上でのJSの高速実行はブラウザでの至上命題である。
JIT技術を各ブラウザベンダが切磋琢磨していたがそれでも限界があるので&lt;a href=&#34;http://asmjs.org/&#34;&gt;asm.js&lt;/a&gt;なんかが産まれた。
これは例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;x|0&lt;/code&gt;と書くと&lt;code&gt;x&lt;/code&gt;が整数であることを表わす、などとしてJSのサブセットで型情報も付与出来るようにしたものだ。冗長なので人の手で書くことは意図していない。
これはある程度上手くいって、&lt;a href=&#34;https://github.com/kripken/emscripten&#34;&gt;emscripten&lt;/a&gt;のようにLLVMからjsへのコンパイラでも使われている。&lt;/p&gt;

&lt;p&gt;それでもまだ問題がある。1つに、JSよりも冗長な記法を使っているためファイルが嵩張る点。ロード時間やパース時間が長くなる。そもそも人の手で掛かないならバイナリフォーマットでもいい筈だ。
そしてもう1つに低レベルな処理、例えばSIMDなんかは扱えない点。&lt;/p&gt;

&lt;p&gt;WebAssemblyはこれらを解決する。仮想的な機械語でバイナリフォーマットがあるので低レベルなことが（将来）出来てコンパクトになっている。
計算モデルはスタックベースのマシンになっている。メモリや関数テーブルなどもある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (func (;0;) (type 0) (param i32 i32) (result i32)
    get_local 0
    get_local 1
    i32.add)
  (export &amp;quot;addTwo&amp;quot; (func 0)))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多くの人にとってWebAssemblyは意識して関るものではなく、emscriptenの吐くコードが効率的になる、程度のものだろう。
私はコンパイラを作る人なので意識する必要がある。
WebAssemblyにはundefined behaviourがないだとかThread API、 SIMD APIなどが入る予定だとかがあるのでLLVM経由で吐くよりも直接吐いた方が面白い。&lt;/p&gt;

&lt;p&gt;少し追っていきたい。&lt;/p&gt;

&lt;h1 id=&#34;quic-https-www-chromium-org-quic&#34;&gt;&lt;a href=&#34;https://www.chromium.org/quic&#34;&gt;QUIC&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;HTTP/2のための代替TCP。HTTP/2はもうリリースされてるので次はQUICを。
HTTP/2は1コネクションを複数のstreamに分割するが、stream内での到達順序保障は必要なもののstream同士ではそれが不要なのでTCPの到達順序保障が過剰要求になってしまう。
それを緩めるためにUDPベースでプロトコルを作ったのがQUIC。まあ、他にも色々改善点はあるが。&lt;/p&gt;

&lt;p&gt;これも基本的にはあまり追う必要はないが、自分の使いたい言語で実装がなかったら自分で実装することになる。
まだその辺の環境が整っていないので今後どうなるか注視する必要がある。&lt;/p&gt;

&lt;h1 id=&#34;idris-http-www-idris-lang-org&#34;&gt;&lt;a href=&#34;http://www.idris-lang.org/&#34;&gt;Idris&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;依存型のある言語。今年もRustに忙しい可能性があるが、ちょっとIdrisに興味が湧いた。
常々「多相があって正格評価で高階関数を簡単に扱えてサブタイピングのない、C FFIやThreadを扱える言語」を捜していて、それがATS2だったりSML#だったりRustだったりした。
最近はRustに落ち着いたが、今度は低レベルな部分、「C FFIやThreadを扱える」がなくてもいいから依存型が入ってる言語が欲しくなった。ATS2は置いといてIdrisかなーと。&lt;/p&gt;

&lt;p&gt;生の依存型だとつらいかな、と思っていたらtacticもあるようだったので機会があればやってみたい。&lt;/p&gt;

&lt;p&gt;CF &lt;a href=&#34;http://wkwkes.hatenablog.com/entry/2016/12/17/000000&#34;&gt;プログラミング言語 idris - wkwkesのやつ&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lean-http-leanprover-github-io&#34;&gt;&lt;a href=&#34;http://leanprover.github.io/&#34;&gt;Lean&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;MSRで開発されている定理証明支援系。よく「Coqでいいじゃん」「Agdaは？」と訊かれるが、&lt;a href=&#34;https://leanprover.github.io/theorem_proving_in_lean/index.html&#34;&gt;オンラインチュートリアル&lt;/a&gt;が良さげだったのと、Emacsから使えるのと、
&lt;a href=&#34;https://kha.github.io/2016/07/22/formally-verifying-rusts-binary-search.html&#34;&gt;RustからLeanへのトランスレートをやっている&lt;/a&gt;人がいたので興味湧いた。
そもそもCoqをある程度やってからにしろとは自分でも思う。&lt;/p&gt;

&lt;h1 id=&#34;coq-https-coq-inria-fr&#34;&gt;&lt;a href=&#34;https://coq.inria.fr/&#34;&gt;Coq&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;定理証明支援系。去年も上がっていたが、今年は酉年なので。「Agdaは？」。知らん。&lt;/p&gt;

&lt;h1 id=&#34;finagle-https-twitter-github-io-finagle&#34;&gt;&lt;a href=&#34;https://twitter.github.io/finagle/&#34;&gt;Finagle&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;RPCのクライアント/サーバフレームワーク。RPCをやる時にいくつか問題が出る。
1つはペイロードがRPC毎に違うのでフレームワークが定まりづらい点。
もう1つはロードバランシングがしづらい点。
ロードバランシングの方に言及しておくと、RPCをやる時は大抵コネクションを張りっぱなしなのでTCPロードバランサが使えない。
例えば順番にサーバを起動していくと最初に上がったサーバにコネクションが集中して以後バランスされない。&lt;/p&gt;

&lt;p&gt;これを解決するのがFinagleで、クライアントが全てのサーバにコネクションを貼って、クライアントサイドでロードバランシングをする。
さらにクライアントが複数のサーバを知っているのでサーバがエラーを返したら別のサーバにリクエストを投げることも出来る。
ペイロードの話は多相型で解決する。パーサとかその辺も含めたフレームワークになっている。&lt;/p&gt;

&lt;h1 id=&#34;tokio-https-github-com-tokio-rs-tokio&#34;&gt;&lt;a href=&#34;https://github.com/tokio-rs/tokio&#34;&gt;Tokio&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;FinagleのRust版。Rustは非同期IOに強いと思っているのでTokioがリリースされたらそこら辺のHTTPフレームワークも非同期化するのではと思っている。&lt;/p&gt;

&lt;h1 id=&#34;tidb-https-github-com-pingcap-tidb&#34;&gt;&lt;a href=&#34;https://github.com/pingcap/tidb&#34;&gt;TiDB&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;分散スケール可能なSQL DB。Rust製。&lt;a href=&#34;https://research.google.com/pubs/pub41344.html&#34;&gt;Google F1&lt;/a&gt;を参考に作られているらしい。
ストレージエンジン自体は&lt;a href=&#34;http://rocksdb.org/&#34;&gt;RocksDB&lt;/a&gt;を使っていて、その上に分散合意、MVCC、トランザクションを載せてさらにそれにSQLレイヤー、MySQLプロトコルレイヤーを載せている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pingcap.github.io/blog/assets/img/how-we-build-tidb-2.png&#34; alt=&#34;TiDBのアーキテクチャ画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アーキテクチャについては上の画像を引用した&lt;a href=&#34;https://pingcap.github.io/blog/2016/10/17/how-we-build-tidb/&#34;&gt;この記事&lt;/a&gt;が詳しい。&lt;/p&gt;

&lt;h1 id=&#34;tantivy-https-github-com-tantivy-search-tantivy&#34;&gt;&lt;a href=&#34;https://github.com/tantivy-search/tantivy&#34;&gt;tantivy&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;全文検索エンジンライブラリ。Rust製。アーキテクチャやアルゴリズムは&lt;a href=&#34;http://lucene.apache.org/core/&#34;&gt;Apache Lucene&lt;/a&gt;を参考に作られているらしいのでだいたいそのレイヤーのライブラリと思ってもらえれば。&lt;/p&gt;

&lt;p&gt;Rust製なのでインデックスの構築が速いのが一つの特徴。今後、自前でElastic SearchやApache Solrのようなレイヤーを作るのかLuceneの置き換えを狙ってJava APIを提供するのかは不明。&lt;/p&gt;

&lt;p&gt;注目したい理由はベースで使っている&lt;a href=&#34;https://github.com/BurntSushi/fst&#34;&gt;fstライブラリ&lt;/a&gt;の&lt;a href=&#34;http://blog.burntsushi.net/transducers/&#34;&gt;紹介記事&lt;/a&gt;が気に入ったから。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2016年注目していきたかった技術の振り返りと個人的振り返り</title>
      <link>/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri</link>
      <pubDate>Sat, 31 Dec 2016 16:57:48 +0900</pubDate>
      
      <guid>/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri</guid>
      <description>&lt;p&gt;κeenです。年始に&lt;a href=&#34;http://keens.github.io/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu/&#34;&gt;2016年注目していきたい技術 | κeenのHappy Hacκing Blog&lt;/a&gt;ってのを書いたので雑に振り返ります。あと個人的な一年の総括を。&lt;/p&gt;

&lt;p&gt;※個人メモなので雑多な記述が多いです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;apache-drill-https-drill-apache-org&#34;&gt;&lt;a href=&#34;https://drill.apache.org/&#34;&gt;Apache Drill&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;ちょっとづつ進化してるようだけどそこまで広まってる気配なし。因みに自分はチーム移動で使う用事がなくなったのであんまり使ってない&lt;/p&gt;

&lt;h1 id=&#34;rust-https-www-rust-lang-org-en-us&#34;&gt;&lt;a href=&#34;https://www.rust-lang.org/en-US/&#34;&gt;Rust&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;めっちゃ使った。大分進化してる。&lt;a href=&#34;https://rust.connpass.com/event/35122/&#34;&gt;ハンズオン&lt;/a&gt;のチュータやったり&lt;a href=&#34;https://rust.connpass.com/event/41467/&#34;&gt;LT会&lt;/a&gt;の玄人枠で発表したりもした。あと年明けに&lt;a href=&#34;https://rust.connpass.com/event/43893/&#34;&gt;ハンズオン第2回&lt;/a&gt;のチュータやる。&lt;/p&gt;

&lt;h1 id=&#34;apache-kafka-http-kafka-apache-org&#34;&gt;&lt;a href=&#34;http://kafka.apache.org/&#34;&gt;Apache Kafka&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;めっちゃ使った。便利。道具箱の中身が増えた。便利。&lt;/p&gt;

&lt;h1 id=&#34;floki-https-github-com-arthurprs-floki&#34;&gt;&lt;a href=&#34;https://github.com/arthurprs/floki&#34;&gt;Floki&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;5月で開発停止したっぽい。残念。&lt;/p&gt;

&lt;h1 id=&#34;robots-https-github-com-gamazeps-robots&#34;&gt;&lt;a href=&#34;https://github.com/gamazeps/RobotS&#34;&gt;RobotS&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;開発は続いてるようだけど流行ってはない。うーん、アクターいけると思ったんだけどなぁ。&lt;/p&gt;

&lt;h1 id=&#34;redox-http-www-redox-os-org&#34;&gt;&lt;a href=&#34;http://www.redox-os.org/&#34;&gt;Redox&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;開発は継続中。&lt;a href=&#34;https://github.com/redox-os/redox/releases&#34;&gt;ISOのリリース&lt;/a&gt;とかもあったしそれなりに進歩はしてる。多分もうちょっとウォッチ期間が必要。&lt;/p&gt;

&lt;h1 id=&#34;ats2-http-www-ats-lang-org&#34;&gt;&lt;a href=&#34;http://www.ats-lang.org/&#34;&gt;ATS2&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;使ってない。一回コンパイラのバグ踏んじゃって萎えてその後はRustばっか使ってる。面白いんだけどなぁ…&lt;/p&gt;

&lt;h1 id=&#34;r-https-www-r-project-org&#34;&gt;&lt;a href=&#34;https://www.r-project.org/&#34;&gt;R&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;チーム移動で用事がなくなったのであまり使ってない。
一応それなりには使ったけどあんまりRのこと覚えきれてない。例えるならEmacs初心者がEmacs Lispのスニペットをコピペでどうにか使ってるくらい。&lt;/p&gt;

&lt;h1 id=&#34;異常検知&#34;&gt;異常検知&lt;/h1&gt;

&lt;p&gt;チーム移動で(ry&lt;/p&gt;

&lt;h1 id=&#34;coq-https-coq-inria-fr&#34;&gt;&lt;a href=&#34;https://coq.inria.fr/&#34;&gt;Coq&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;それなりにやった。&lt;a href=&#34;http://proofcafe.org/sf/&#34;&gt;ソフトウェアの基礎&lt;/a&gt;のサブタイプまでやった。ProofGeneralのバグは&lt;a href=&#34;https://github.com/ProofGeneral/PG&#34;&gt;GitHubにある方のProofGeneral&lt;/a&gt;を使ったら解決した。あと&lt;a href=&#34;https://twitter.com/search?q=%23readcoqart&amp;amp;src=typd&amp;amp;lang=ja&#34;&gt;#readcoqart&lt;/a&gt;にも何度か参加した。&lt;/p&gt;

&lt;h1 id=&#34;isabelle-https-isabelle-in-tum-de&#34;&gt;&lt;a href=&#34;https://isabelle.in.tum.de/&#34;&gt;Isabelle&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;一応チュートリアルを少しやった。あと&lt;a href=&#34;https://keens.github.io/slide/tadashiiScalanoko_dogahoshii/&#34;&gt;社内勉強会で発表&lt;/a&gt;もした。Isabelle 2014までしかProofGeneralで使えないのでちょっと厳しくなってやらなくなった。つらい。&lt;/p&gt;

&lt;p&gt;いい加減Emacs以外のプラットフォームも使えるようにならないとなー。&lt;/p&gt;

&lt;h1 id=&#34;fortran&#34;&gt;Fortran&lt;/h1&gt;

&lt;p&gt;やってない。1ﾐﾘも触ってない。本当はある程度入門したらFortranコンパイラでも作るかって気分だったけど&lt;a href=&#34;http://no-maddojp.hatenablog.com/entry/2016/12/01/023624&#34;&gt;つらいらしい&lt;/a&gt;のでやらなくてよかった&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;じゃ、個人的総括。まず、個人ブログはこのエントリ含めて48。週1ペース守れなかった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu&#34;&gt;2016年注目していきたい技術&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/01/ATS2nokangaseiridekita&#34;&gt;ATS2の観が整理出来た&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/08/Rusttoiedoriso_sunokaihouhachuui&#34;&gt;Rustといえどリソースの解放は注意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/11/SML_nopthreadbaindingutsukutta&#34;&gt;SML#のpthreadバインディング作った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/12/Isabelleninyuumonshita&#34;&gt;Isabelleに入門した&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/17/dokugakudepuroguraminguwoyattekitanakadeyokattagijutsushowoageteiku&#34;&gt;独学でプログラミングをやってきた中で良かった技術書50選&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/17/puroguraminguwodokugakusurutokikosoinputtowofuyashitahougaii&#34;&gt;プログラミングを独学する時こそインプットを増やした方がいい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/27/Lisp_Meetup3shuunenniyosete&#34;&gt;Lisp Meetup3周年に寄せて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/31/Rustnopakke_jiwocrates_ionitourokusuru&#34;&gt;Rustのパッケージをcrates.ioに登録する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/04/Common_Lispdekousokugyouretsuenzan&#34;&gt;Common Lispで高速行列演算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/10/Nexus_5niUbuntu_Touchnoinsuto_ru&#34;&gt;Nexus 5にUbuntu Touchのインストール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/14/DVCSnomoderu_aruihaPijulnitsuite&#34;&gt;分散VCSのモデル、あるいはPijulについて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/14/readlinenotsukurikata&#34;&gt;readlineの作り方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/24/Bind_Addressnoimigayouyakuwakatta&#34;&gt;Bind Addressの意味がようやく分かった&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/27/druidtoiuriarutaimude_tabunsekitsu_ruwoshitta&#34;&gt;druidというリアルタイムデータ分析ツールを知った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/28/RustnoHigherKinded_type_Trait&#34;&gt;RustのHigher-Kinded type Trait&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/03/01/Rustnozerokosutochuushouka&#34;&gt;Rustのゼロコスト抽象化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/03/01/tesutonitsuitekangaetemita&#34;&gt;テストについて考えてみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/03/02/ri_jontoRustnokaerichi&#34;&gt;リージョンとRustの返り値&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/04/04/Mirahkanrentsu_rumatome&#34;&gt;Mirah関連ツールまとめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii&#34;&gt;LXDがリリースされたらしい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/05/04/RustdebeametaruRaspberry_PinoLchika&#34;&gt;RustでベアメタルRaspberry PiのLチカ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/05/14/cargo_profilerwotamesu&#34;&gt;cargo-profilerを試す&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru&#34;&gt;multirustが非推奨になったようなのでrustupに移行する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/06/19/Rustnoshoyuuken_myu_tabiriteinobunkatsu&#34;&gt;Rustの所有権/ミュータビリティの分割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/07/02/Container_Desgin_Patterns&#34;&gt;Container Desgin Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/07/13/shierugeijuuhachihan&#34;&gt;シェル芸十八般&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai&#34;&gt;私がコードを書くときテストは書かない&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/08/11/mirah_0_2gariri_susaremashita&#34;&gt;mirah 0.2がリリースされました。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/09/04/Rustdeshierutsukutta&#34;&gt;Rustでシェル作った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/09/29/Pijulnoinsuto_ruganan_idotakainodekaisetsusuru&#34;&gt;Pijulのインストールが難易度高いので解説する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/10/10/Rustnokuro_ja3tanewotsukutterikaisuru&#34;&gt;Rustのクロージャ3種を作って理解する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/10/10/SMLdemonado&#34;&gt;SMLでモナド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/10/31/VMwarenoUbuntuwo16_10nishitarakidoushinakunatta&#34;&gt;VMwareのUbuntuを16.10にしたら起動しなくなった&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/06/RustnokatareberuLispppoinotsukutta&#34;&gt;Rustの型レベルLispっぽいの作った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/22/Rustnokanrenkatanotsukaidokoro&#34;&gt;Rustの関連型の使いどころ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/30/SML_woUbuntu_16_10deugokasu&#34;&gt;SML#をUbuntu 16.10で動かす&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/30/saiba_e_jientowotaishokushimashita&#34;&gt;サイバーエージェントを退職しました&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/01/4nenkantsuzuitaShibuya_lispnoLispMeetUp&#34;&gt;4年間続いたShibuya.lispのLispMeetUp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/01/Rustdebaitoretsuwoatsukautokinotips&#34;&gt;Rustでバイト列を扱う時のtips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou&#34;&gt;マクロやコンパイラプラグインの実装方法色々&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/02/Rustnopurosesu&#34;&gt;Rustのプロセス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/02/atarashiikonpairabakkuendocretonne&#34;&gt;新しいコンパイラバックエンドcretonne&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/03/Rustnostructtotraittteniteruyone&#34;&gt;Rustのstructとtraitって似てるよね&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/14/Rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami&#34;&gt;Rustの所有権、ライフタイム、参照、型、しがらみ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/24/Rustnoraifutaimuwotsukattasuko_pukaiseki&#34;&gt;Rustのライフタイムを使ったスコープ解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/29/kizuitaraRustnokankyoukouchikugakanarirakuninatteta&#34;&gt;気付いたらRustの環境構築がかなり楽になってた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri&#34;&gt;2016年注目していきたかった技術の振り返りと個人的振り返り&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スライドは15。月1以上のペースだった。意外。ほとんど社内のScala勉強会で発表してるっぽい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/slide/HAMT&#34;&gt;HAMT ~ イミュータブルで高速なハッシュマップ ~&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/ClojuredeSSPwotsukuttahanashi&#34;&gt;ClojureでSSPを作った話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Rusttohananika_donnagengoka_&#34;&gt;Rustとは何か。どんな言語か。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni&#34;&gt;ビッグデータしないDrill、ローカルで快適に使うために&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/SMLdekansuukatatekiseikihyougenmatchi&#34;&gt;SMLで函数型的正規表現マッチ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/tesutonitsuite_Scalato_&#34;&gt;テストについて、Scalaと。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/kousokunakeizokuraiburarinimukete&#34;&gt;高速な継続ライブラリに向けて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/DOT_dottynitsuiteshirabetemita&#34;&gt;DOT/dottyについて調べてみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Socket_on_SML_&#34;&gt;Socket on SML#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/katakurasuwokoete&#34;&gt;型クラスを越えて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/tadashiiScalanoko_dogahoshii&#34;&gt;正しいScalaのコードが欲しい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Scala_2_12_0henkouten&#34;&gt;Scala 2.12.0変更点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Rustnohanashitoriso_sunohanashi&#34;&gt;Rustの話とリソースの話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/RustdehidoukiThriftshitai&#34;&gt;Rustで非同期Thriftしたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Schemedeclasstoprotocol&#34;&gt;SchemeでClassとProtocol&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その他外部に投稿したものは13。これも併わせたらブログはギリギリ週1ペースかな。仕事関連だったり仕事中に思い付いてブログにアクセス出来ないのでQiitaに投げたものが多い。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/3b068769736e671805f0&#34;&gt;Rustのドキュメントの翻訳プロジェクトを開始します。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/382704cc54c8e42819d0&#34;&gt;正規表現の先読み/後読みを「絞り込み」と理解してみる - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/c9e60e089974392878c8&#34;&gt;一瞬でシェルスクリプト作れるシェル関数作った - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/3231c8adec40b350cf33&#34;&gt;sedの-iオプションの非互換 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/4945a6eb5cceeb154b24&#34;&gt;Rustでサイコロで同じ目が100回連続で実際に出るか - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/4f91a174e0f63ee42699&#34;&gt;POSIXシェルで変数がセットされているか検査するイディオム - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1095&#34;&gt;ICFP及び関連イベント参加レポート – Haskell Day – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1099&#34;&gt;ICFP及び関連イベント参加レポート – ICFP併設ワークショップ – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1118&#34;&gt;ICFP及び関連イベント参加レポート – ICFP 1日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1125&#34;&gt;ICFP及び関連イベント参加レポート – ICFP 2日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1158&#34;&gt;ICFP及び関連イベント参加レポート – ICFP 3日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1200&#34;&gt;ICFP及び関連イベント参加レポート – 併設ワークショップ2日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1380&#34;&gt;ICFP及び関連イベント参加レポート – 併設ワークショップ3日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、OSSだと雑なスニペットとかもGitHubに上げてるのでカウントが難しいけど、主だったものだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/incubator-airflow&#34;&gt;airflow&lt;/a&gt;の&lt;a href=&#34;https://github.com/apache/incubator-airflow/blob/master/airflow/contrib/operators/ssh_execute_operator.py&#34;&gt;SSH Execute Operator&lt;/a&gt;を書いた&lt;/li&gt;
&lt;li&gt;Apache Drillの&lt;a href=&#34;https://github.com/KeenS/sql-drill.el&#34;&gt;Emacs Mode&lt;/a&gt;作った（リリースしてない）&lt;/li&gt;
&lt;li&gt;Rustの&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logger&lt;/a&gt;作った&lt;/li&gt;
&lt;li&gt;file_loggerと一緒に使うために&lt;a href=&#34;https://github.com/KeenS/rotate_file&#34;&gt;rotate_file&lt;/a&gt;作った（リリースしてない）&lt;/li&gt;
&lt;li&gt;インターン向けに作った&lt;a href=&#34;https://github.com/KeenS/s7p&#34;&gt;SSP&lt;/a&gt;を公開した。&lt;/li&gt;
&lt;li&gt;SML#の&lt;a href=&#34;https://github.com/KeenS/smlsharp_pthread&#34;&gt;pthreadバインディング&lt;/a&gt;作った。多分64bitで動かない。&lt;/li&gt;
&lt;li&gt;SML#の&lt;a href=&#34;https://github.com/KeenS/SmlSharpSocketSupport&#34;&gt;socketサポー&lt;/a&gt;作った。まだメモリ管理回りで処理系とのやりとりに上手くいってないので完成してない。&lt;/li&gt;
&lt;li&gt;Rustで&lt;a href=&#34;https://github.com/KeenS/igaguri&#34;&gt;シェル&lt;/a&gt;作った。雑に動く。&lt;/li&gt;
&lt;li&gt;Tokioの&lt;a href=&#34;https://github.com/KeenS/tokio-thrift&#34;&gt;Thrift対応&lt;/a&gt;フレームワーク作成中。Tokio側がリリースされたらこちらもリリース出来るくらいの進捗でやっていきたい。&lt;/li&gt;
&lt;li&gt;Rust公式ドキュメントの&lt;a href=&#34;https://github.com/rust-lang-ja/the-rust-programming-language-ja&#34;&gt;翻訳&lt;/a&gt;一応1.6は完了。今1.14まで来てるので更新せねば…。&lt;/li&gt;
&lt;li&gt;なんか適当な&lt;a href=&#34;https://github.com/KeenS/webml&#34;&gt;ML風言語のコンパイラ&lt;/a&gt;作り始めた。年内にコード吐くまでやりたかったけど最後の数日サボってしまったので間に合わない。&lt;/li&gt;
&lt;li&gt;コンパイラのために&lt;a href=&#34;[KeenS/WebAssembler-rs](https://github.com/KeenS/WebAssembler-rs)&#34;&gt;WebAssemblyをインメモリで吐くライブラリ&lt;/a&gt;作った。ブラウザでコンパイラ動かしたい時に使う。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;かな。&lt;a href=&#34;https://github.com/KeenS/cl-fast-cont&#34;&gt;限定継続ライブラリ&lt;/a&gt;みたいに途中で放置してるやつとか&lt;a href=&#34;https://github.com/KeenS/rust_os&#34;&gt;チュートリアル読んでOS作ってるやつ&lt;/a&gt;とかは入れてないので「活動」って意味だともう少し広いけど社会貢献はしてない。&lt;/p&gt;

&lt;p&gt;仕事も含めたGitHubの草はこんなもん。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;und&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://t.co/MVQag8h6qU&#34;&gt;pic.twitter.com/MVQag8h6qU&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/814449614967357440&#34;&gt;2016年12月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;引越しだとかICFPとかの週はほとんどコミット出来てないのでもうちょっと頑張りたい。あと顕著に土日にサボってるのもどうにかしたい。&lt;/p&gt;

&lt;p&gt;割と飽きっぽいというか他のものに浮気しがちというか適当に手を付けては壁に当たった/第一目標達成したあたりで次にいっちゃうので継続性がない。継続した方が社会貢献になるんだよなー。&lt;/p&gt;

&lt;p&gt;読書は正確にいつ買ったか覚えてないので正確じゃないけど、流し読みしたものも含めれば&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/gp/product/4535782148/&#34;&gt;線型論理入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4621063243/&#34;&gt;圏論の基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4535787204/&#34;&gt;圏論の歩き方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/gp/product/052103311X/&#34;&gt;Compiling with Continuations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798114685/&#34;&gt;最新コンパイラ構成技法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798134201/&#34;&gt;ガベージコレクション 自動的メモリ管理を構成する理論と実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798045365/&#34;&gt;独自CPU開発で学ぶコンピュータのしくみ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4797382228/&#34;&gt;暗号技術入門 第3版 秘密の国のアリス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798141100/&#34;&gt;その数式、プログラムできますか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4873116856/&#34;&gt;戦略的データサイエンス入門 ―ビジネスに活かすコンセプトとテクニック&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529153/&#34;&gt;ノンパラメトリックベイズ 点過程と統計的機械学習の数理 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529099/&#34;&gt;劣モジュラ最適化と機械学習 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529021/&#34;&gt;深層学習 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529080&#34;&gt;異常検知と変化検知 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/479813161X/&#34;&gt;実践ドメイン駆動設計 (Object Oriented SELECTION)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4048679880&#34;&gt;The Art of Multiprocessor Programming 並行プログラミングの原理から実践まで&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多分こんなもん。機械学習プロフェッショナルシリーズは去年読んだのも含んでるかもしれない。あんまり覚えてない。論文も挙げようと思ったけど面倒になったからいいや。十数綴から二十綴くらいじゃないかな。&lt;/p&gt;

&lt;p&gt;社会的には1回社内でチーム移動になって1回退職した。Shibuya.lispの運営から引退を発表して、rust-lang-ja（有志の翻訳コミュニティ？）の中の人になった。&lt;/p&gt;

&lt;p&gt;まだ社会人になって2年も経ってなくて情報科学/工学の基礎もないので基礎を付けるために勉強してるフェーズかなぁといったところ。
来年は専門性の高い仕事になるので今年以上に勉強が必要になりそう。多分本より論文に比重が傾く。&lt;/p&gt;

&lt;p&gt;年明けにまた注目していきたい技術書く。毎年書いていったら面白いかもしれない。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>気付いたらRustの環境構築がかなり楽になってた</title>
      <link>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</link>
      <pubDate>Thu, 29 Dec 2016 11:52:55 +0900</pubDate>
      
      <guid>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</guid>
      <description>&lt;p&gt;κeenです。ここのところRustの開発ツール回りでリリースが続いてセットアップが楽になってるようだったので最新の情報をお届けします。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;とりあえず私は既存の環境があるので一旦全て破棄してから再度セットアップしてみます。&lt;/p&gt;

&lt;h1 id=&#34;rustのインストール&#34;&gt;Rustのインストール&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;がリリースされたので以下で一発です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;source $HOME/.cargo/env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をシェルのrcファイルに書き加えたらOKです。
今のシェルにも反映するには同じく上記のコマンドを打ちます。&lt;/p&gt;

&lt;h1 id=&#34;周辺ツールのインストール&#34;&gt;周辺ツールのインストール&lt;/h1&gt;

&lt;p&gt;cargoがあるので楽ですね&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# コードフォーマッタ
$ cargo install rustfmt
# 補完、定義ジャンプなど
$ cargo install racer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあ時間がかかります。&lt;/p&gt;

&lt;h1 id=&#34;エディタ-emacs-の設定&#34;&gt;エディタ(Emacs)の設定&lt;/h1&gt;

&lt;p&gt;私がEmacsを使ってるのでEmacsの設定を。&lt;/p&gt;

&lt;p&gt;まず、必要パッケージをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;rustfmt&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。rust-modeにrustfmtの機能が含まれているようでした。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; rustfmtを emacsから使うの rust-modeが現在サポートしているので, rustfmt.elパッケージは不要ですね. rust-format-on-saveが non-nilなら保存時に rustfmtが実行されます.&lt;/p&gt;&amp;mdash; Syohei YOSHIDA (@syohex) &lt;a href=&#34;https://twitter.com/syohex/status/814354653672415232&#34;&gt;2016年12月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;;;; racerやrustfmt、コンパイラにパスを通す
(add-to-list &#39;exec-path (expand-file-name &amp;quot;~/.cargo/bin/&amp;quot;))
;;; rust-modeでrust-format-on-saveをtにすると自動でrustfmtが走る
(eval-after-load &amp;quot;rust-mode&amp;quot;
  &#39;(setq-default rust-format-on-save t))
;;; rustのファイルを編集するときにracerとflycheckを起動する
(add-hook &#39;rust-mode-hook (lambda ()
                            (racer-mode)
                            (flycheck-rust-setup)))
;;; racerのeldocサポートを使う
(add-hook &#39;racer-mode-hook #&#39;eldoc-mode)
;;; racerの補完サポートを使う
(add-hook &#39;racer-mode-hook (lambda ()
                             (company-mode)
                             ;;; この辺の設定はお好みで
                             (set (make-variable-buffer-local &#39;company-idle-delay) 0.1)
                             (set (make-variable-buffer-local &#39;company-minimum-prefix-length) 0)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とりあえずこれでセットアップ完了です。racerの最新版でrustのソースコードの位置を設定しなくてよくなったので簡潔になりましたね。&lt;/p&gt;

&lt;p&gt;racer-modeは補完をしてくれる他、&lt;code&gt;M-.&lt;/code&gt;で定義元ジャンプ、&lt;code&gt;M-,&lt;/code&gt;でジャンプ元に戻れます。
あとは&lt;code&gt;M-x racer-describe&lt;/code&gt;でポイント位置にあるシンボルのrustdocを(Emacs内で)表示してくれます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;おお! racerでEmacs内でrustdocレンダ出来るようになってる！便利！！&lt;br&gt;&lt;br&gt;Rustdoc Meets The Self-Documenting Editor&lt;a href=&#34;https://t.co/gDEHl2fSfx&#34;&gt;https://t.co/gDEHl2fSfx&lt;/a&gt; &lt;a href=&#34;https://t.co/sdrX9OoEnr&#34;&gt;pic.twitter.com/sdrX9OoEnr&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/770796719185408000&#34;&gt;2016年8月31日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;その他は放っておくと勝手に機能してくれるので考えることが少なくていいですね。&lt;/p&gt;

&lt;h1 id=&#34;その他便利ツール&#34;&gt;その他便利ツール&lt;/h1&gt;

&lt;p&gt;セットアップがあっけなかったのでついでに入れておくと便利なツールをいくつか紹介します。&lt;/p&gt;

&lt;h2 id=&#34;cargo-edit&#34;&gt;cargo-edit&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-edit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「libcクレートの最新版に依存したい」なんて時に一々libcの最新版を確認するのは面倒ですよね。そんなときにcargo-editがあれば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo add libc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で &lt;code&gt;Cargo.toml&lt;/code&gt; に追記してくれます。&lt;/p&gt;

&lt;h2 id=&#34;cargo-script&#34;&gt;cargo-script&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとした実験スクリプトとかをコンパイル→実行のステップを踏まずにいきなり実行出来ます。
&lt;code&gt;cargo script FILE&lt;/code&gt;でファイルを実行出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; hello.rs
fn main() {
    println!(&amp;quot;hello, script&amp;quot;)
}
EOF
$ cargo script hello.rs
   Compiling hello v0.1.0 (file:///home/kim/.cargo/.cargo/script-cache/file-hello-f6b1735a519bb659)
    Finished release [optimized] target(s) in 0.15 secs
hello, script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というふうに使います。&lt;/p&gt;

&lt;p&gt;シェルのrcファイルで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;alias rust=&#39;cargo-script&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としておくと吉。&lt;/p&gt;

&lt;h2 id=&#34;cargo-update&#34;&gt;cargo-update&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までインストールしたバイナリのアップデートを出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install-update -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>