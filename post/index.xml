<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/post/</link>
    <description>Recent content in Posts on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 29 Nov 2015 13:54:39 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rustで小さなツールを作ってみる(後編)</title>
      <link>http://keens.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_</link>
      <pubDate>Sun, 29 Nov 2015 13:54:39 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 2日目の記事です。&lt;br /&gt;
前 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru/&#34;&gt;Rustで小さなツールを作ってみる(前編)&lt;/a&gt;&lt;br /&gt;
次 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/cargonotsukaikata/&#34;&gt;Cargoの使い方&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。昨日の記事で作りかけだったIRCの生ログのDBへのインポートの続きです。今日はDBへのインポートをやります。&lt;/p&gt;

&lt;p&gt;とはいってもRustでDBを扱った経験がないので探り探りです。&lt;/p&gt;

&lt;h1 id=&#34;要件:b5100d6caeb6e32800002ace57fa8102&#34;&gt;要件&lt;/h1&gt;

&lt;p&gt;今回は簡単なのでORMは要らない気がしますが、サンプルということでORMも使いましょう。さらに、サンプルということでクエリビルダも使いましょう。&lt;/p&gt;

&lt;p&gt;…と思ったのですが中々良いライブラリがありませんでした。ドキュメントもろくにないまま放置されてる&lt;a href=&#34;https://github.com/deuterium-orm/deuterium&#34;&gt;deuterium&lt;/a&gt;と開発途中でまだpostgresしかサポートされていない&lt;a href=&#34;https://github.com/ivanceras/rustorm&#34;&gt;rustorm&lt;/a&gt;/&lt;a href=&#34;https://github.com/ivanceras/codegenta&#34;&gt;codegenta&lt;/a&gt;くらいしかないようです。うぅ。
最近話題になった&lt;a href=&#34;https://github.com/sgrif/diesel&#34;&gt;diesel&lt;/a&gt;もまだ若すぎるようです。&lt;/p&gt;

&lt;p&gt;ということでシンプルなDBIを使います。そろそろ牡蠣の美味しい季節ですしSQL生書きしましょう。当たると怖いですが。で、テスト用にsqlite3を、（今回は使いませんが）本番用（？）にMySQLを使える奴を捜しましょう。&lt;/p&gt;

&lt;h1 id=&#34;ライブラリ捜し:b5100d6caeb6e32800002ace57fa8102&#34;&gt;ライブラリ捜し&lt;/h1&gt;

&lt;p&gt;まずは&lt;a href=&#34;https://crates.io&#34;&gt;crates.io&lt;/a&gt;を捜します。&amp;rdquo;sqlite&amp;rdquo;で捜せばいいでしょうか。&lt;/p&gt;

&lt;p&gt;MySQLとSQLite3をサポートしているライブラリ…&lt;a href=&#34;https://github.com/sfackler/r2d2&#34;&gt;r2d2&lt;/a&gt;がそれのようです。
コネクションプールのライブラリなので何か違う気がしますが、mysqlもsqlite3も扱えて、結果コネクションを抽象化してくれるので大体大丈夫です。&lt;/p&gt;

&lt;p&gt;蛇足ですが、名前はJavaにc3p0というコネクションプールがあるのでそこから来ているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;スキーマ定義:b5100d6caeb6e32800002ace57fa8102&#34;&gt;スキーマ定義&lt;/h1&gt;

&lt;p&gt;SQLiteを使い慣れないのですが大したことやってないので大丈夫でしょう。&lt;code&gt;DATETIME&lt;/code&gt; 型がないのが苦しいですね。&lt;/p&gt;

&lt;p&gt;自然キーが文字列や複合キーなのでサロゲートキーを使って自然キーにUNIQUE制約をかけてますがちょっと気持悪いですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- _*_ mode: sql; sql-product: &#39;sqlite _*_

CREATE TABLE servers(
        id   INTEGER PRIMARY KEY,
        name  TEXT NOT NULL UNIQUE,
        address TEXT
        );
m
CREATE TABLE channels(
        id INTEGER PRIMARY KEY,
        server_id INTEGER REFERENCES servers(id) ON UPDATE CASCADE,
        name TEXT NOT NULL,
        UNIQUE(server_id, name)
        );

CREATE TABLE entries(
        id INTEGER PRIMARY KEY,
        channel_id INTEGER REFERENCES channels(id) ON UPDATE CASCADE,
        user_id INTEGER REFERENCES users(i) ON UPDATE CASCADE,
        type TEXT NOT NULL,
        body TEXT NOT NULL,
        created_at TEXT NOT NULL
        );

CREATE TABLE users(
        id INTEGER PRIMARY KEY,
        server_id INTEGER REFERENCES servers(id) ON UPDATE CASCADE,
        name TEXT NOT NULL,
        UNIQUE(server_id, name)
        );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをetc/schema.sqlに保存します。&lt;/p&gt;

&lt;h1 id=&#34;モデル定義:b5100d6caeb6e32800002ace57fa8102&#34;&gt;モデル定義&lt;/h1&gt;

&lt;p&gt;折角シンプルなツールを作っているのでモデルは使わない。&lt;/p&gt;

&lt;h1 id=&#34;コネクションまで:b5100d6caeb6e32800002ace57fa8102&#34;&gt;コネクションまで&lt;/h1&gt;

&lt;p&gt;あらかじめ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sqlite test.db &amp;lt; etc/schema.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてDBを作っておきましょう。&lt;/p&gt;

&lt;p&gt;Cargo.tomlのdependenciesには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;r2d2_sqlite = &amp;quot;0.0.3&amp;quot;
r2d2 = &amp;quot;0.6.1&amp;quot;
rusqlite = &amp;quot;0.4.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記。&lt;/p&gt;

&lt;p&gt;src/main.rsの先頭部分に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate r2d2;
extern crate r2d2_sqlite;
extern crate rusqlite;
use std::sync::Arc;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::SqliteError;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記しましょう。&lt;/p&gt;

&lt;p&gt;そしてmainの中に次を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let manager = SqliteConnectionManager::new(&amp;quot;test.db&amp;quot;).unwrap();
    let config = r2d2::Config::builder().pool_size(16).build();
    let pool = Arc::new(r2d2::Pool::new(config, manager).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで一旦コンパイル。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これが通れば良いです。&lt;/p&gt;

&lt;h1 id=&#34;はじめての挿入:b5100d6caeb6e32800002ace57fa8102&#34;&gt;はじめての挿入&lt;/h1&gt;

&lt;p&gt;INSERTを発行してみましょう。&lt;code&gt;on_channel_dir&lt;/code&gt;の引数を変える必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path, pool: Arc&amp;lt;r2d2::Pool&amp;lt;SqliteConnectionManager&amp;gt;&amp;gt;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;併せて、呼び出しも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        on_channel_dir(&amp;amp;path, pool.clone());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;/p&gt;

&lt;p&gt;そうしたら&lt;code&gt;on_channel_dir&lt;/code&gt;の中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていた辺でまずはserversへのインサートを発行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let conn = pool.get().unwrap();
    let server_id = match conn.execute(&amp;quot;INSERT INTO servers (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;server]) {
        // unique constraint failed
        Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM servers WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;server], |r| r.get(0)).unwrap(),
        Ok(_) =&amp;gt; conn.last_insert_rowid(),
        e =&amp;gt; {e.unwrap(); return}
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プールからコネクションを持ってきて&lt;code&gt;INSERT&lt;/code&gt;を発行します。成功するか既にUNIQUEな名前が存在していて失敗したらサーバのidを持ってきます。それ以外の失敗だったらそのままパニックしていいでしょう。&lt;/p&gt;

&lt;p&gt;しかしラッパがちょっと雑すぎやしませんかね。エラーステータスくらいenumでラップして欲しかった。&lt;/p&gt;

&lt;p&gt;同じくチャネルもインサートしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel_id = match conn.execute(&amp;quot;INSERT INTO channels (name, server_id) VALUES ($1, $2)&amp;quot;, &amp;amp;[&amp;amp;channel, &amp;amp;server_id]) {
        // unique constraint failed
        Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM channels WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;channel], |r| r.get(0)).unwrap(),
        Ok(_) =&amp;gt; conn.last_insert_rowid(),
        e =&amp;gt; {e.unwrap(); return}

    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こういうupsertというかinsert or get_idってどうやるのが正解なんでしょう。DB力が低い…&lt;/p&gt;

&lt;h1 id=&#34;エントリのインサート:b5100d6caeb6e32800002ace57fa8102&#34;&gt;エントリのインサート&lt;/h1&gt;

&lt;p&gt;同じく&lt;code&gt;on_log&lt;/code&gt;の引数を増やします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_log(log: &amp;amp;Path, channel_id: i64,  pool: Arc&amp;lt;r2d2::Pool&amp;lt;SqliteConnectionManager&amp;gt;&amp;gt;) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し側も。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let pool_ = pool.clone();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log, channel_id, pool_))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt;する前に&lt;code&gt;clone&lt;/code&gt;しないとダメですね。所有権難しい。&lt;/p&gt;

&lt;p&gt;さて、今度は色々することがあります。
まず、dateとtimeをくっつけてdatetimeにしましょう。timeがイミュータブルだったので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let mut time = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とし、その下で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        time.tm_mday = date.tm_mday;
        time.tm_mon = date.tm_mon;
        time.tm_year = date.tm_year;
        let created_at = time.to_timespec();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。わざわざ&lt;code&gt;to_timespec&lt;/code&gt;で変換してるのは&lt;code&gt;Timespec&lt;/code&gt;だとDBライブラリが良い感じに変換してくれるからですね。&lt;/p&gt;

&lt;p&gt;次にメッセージの抜き出し部分も値を返すように変更。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let (user, type_, body) = match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;sysmsg&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;join&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;part&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; (user, &amp;quot;msg&amp;quot;, body),
                None =&amp;gt; {
                    warn!(&amp;quot;cannot parse the entry; skipping&amp;quot;);
                    continue;
                }
            },
            _ =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;notice&amp;quot;, &amp;amp;msg[1..]),
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまで来たらあとはユーザとエントリをインサートするだけですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let conn = pool.get().unwrap();
        let user_id = match conn.execute(&amp;quot;INSERT INTO users (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;user]) {
            // unique constraint failed
            Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM users WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;user], |r| r.get(0)).unwrap(),
            Ok(_) =&amp;gt; conn.last_insert_rowid(),
            e =&amp;gt; {e.unwrap(); return}
        };
        conn.execute(&amp;quot;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)&amp;quot;, &amp;amp;[&amp;amp;channel_id, &amp;amp;user_id, &amp;amp;type_, &amp;amp;body, &amp;amp;created_at]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦これで走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#hongo@utmc/2015-02-15.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-08-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-12-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-02-26.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-05-23.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-04-30.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2013-10-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-14.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-01-19.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-08-12.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-06-03.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-02-05.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あちゃー。マルチスレッドでINSERTしてるのでロックが掛かってますね。SQLiteはファイルロックしか持たないので並列インサートはつらそう。&lt;/p&gt;

&lt;h1 id=&#34;トランザクション:b5100d6caeb6e32800002ace57fa8102&#34;&gt;トランザクション&lt;/h1&gt;

&lt;p&gt;はい、そういう時のトランザクションですよ。&lt;/p&gt;

&lt;p&gt;最後のユーザやエントリーをインサートしてる部分で使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let conn = pool.get().unwrap();
        let trx = conn.transaction().unwrap();
        let user_id = match conn.execute(&amp;quot;INSERT INTO users (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;user]) {
            // unique constraint failed
            Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM users WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;user], |r| r.get(0)).unwrap(),
            Ok(_) =&amp;gt; conn.last_insert_rowid(),
            e =&amp;gt; {e.unwrap(); return}
        };
        trx.commit();
        let trx = conn.transaction().unwrap();
        conn.execute(&amp;quot;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)&amp;quot;, &amp;amp;[&amp;amp;channel_id, &amp;amp;user_id, &amp;amp;type_, &amp;amp;body, &amp;amp;created_at]);
        trx.commit();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排他制御が目的なのでトランザクションを2回取ってます。&lt;/p&gt;

&lt;p&gt;これだとどうなるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#hongo@utmc/2015-02-15.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-08-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-12-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-02-26.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-05-23.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-04-30.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2013-10-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-14.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-01-19.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-08-12.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-06-03.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-02-05.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーは減ったもののまだ出ます。&lt;/p&gt;

&lt;h1 id=&#34;その他:b5100d6caeb6e32800002ace57fa8102&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;他にスレッドプールを使って並列度を下げる、ワーカースレッドを使ってSQLiteへの書き込みを1スレッドにするなども試したのですが上手く行きませんでした。&lt;/p&gt;

&lt;p&gt;スレッドプールについては、今回エラーハンドリングのためにスレッドを立てている訳ですが、パニックを出してスレッドが死ぬとあまり思わしくない挙動をするのでダメでした。&lt;/p&gt;

&lt;p&gt;ワーカースレッドは書き込んだ後にまたchannel_idなどを受け取らないといけないのでやめました。promiseなどを使えば上手くいきそうな気もしますが色々面倒そうなので止めておきます。&lt;/p&gt;

&lt;h1 id=&#34;コネクション:b5100d6caeb6e32800002ace57fa8102&#34;&gt;コネクション&lt;/h1&gt;

&lt;p&gt;並列度を下げる方法はもう1つあります。&lt;/p&gt;

&lt;p&gt;mainの中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let config = r2d2::Config::builder().pool_size(16).build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていたのを覚えていますでしょうか。これはコネクションプールに16個のコネクションを持っています。この数を落とせばなんとかならないでしょうか。&lt;/p&gt;

&lt;p&gt;結論からいうとダメでした。今度は複数スレッドがコネクションを取り合ってタイムアウトが発生してしまいます。&lt;/p&gt;

&lt;h1 id=&#34;並列度を下げる:b5100d6caeb6e32800002ace57fa8102&#34;&gt;並列度を下げる&lt;/h1&gt;

&lt;p&gt;最後の最後、本当に並列度を下げる方法があります。スレッドを立てていた部分で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let threads = logs.map(|log| {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log))
    }).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
    for thread in threads {
        let _ = thread.unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていました。これはファイル数分並列に実行してしまいます。ここを抑えましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    for log in logs {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        let pool_ = pool.clone();
        let _ = Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log, channel_id, pool_)).unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;spawn&lt;/code&gt;してそのまま&lt;code&gt;join&lt;/code&gt;します。こうすれば並列度を抑えつつパニックをスレッドに分離出来ます。&lt;/p&gt;

&lt;p&gt;これで実行するとどうなるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#lisp-ja@freenode/2015-04-08.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いくつかタイムアウトを出します。えー。並列度1でこれならもうどうしようもないでしょう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:b5100d6caeb6e32800002ace57fa8102&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;さて、小さなツールを作るというタイトルにしては後半(執筆が)重い内容になってしまいました。というか、sqlite3の問題もしますが。&lt;/p&gt;

&lt;p&gt;このブログの内容としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rustでディレクトリを扱った&lt;/li&gt;
&lt;li&gt;ファイルを扱った&lt;/li&gt;
&lt;li&gt;文字列を扱った&lt;/li&gt;
&lt;li&gt;日付を扱った&lt;/li&gt;
&lt;li&gt;スレッドを扱った&lt;/li&gt;
&lt;li&gt;ロガーライブラリを扱った&lt;/li&gt;
&lt;li&gt;エラーハンドリングをした&lt;/li&gt;
&lt;li&gt;パニックのハンドリングをした&lt;/li&gt;
&lt;li&gt;DBを扱った&lt;/li&gt;
&lt;li&gt;sqlite3に並列書き込みはつらい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ボツ案も含めれば私個人はORMやスレッドプール、チャネルも扱いましたが関係ないですね。&lt;/p&gt;

&lt;p&gt;こういう簡単なツールでも思ったより色々な機能を触れるのでみなさん試してみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;ソースコード全体は&lt;a href=&#34;https://github.com/KeenS/irc_log&#34;&gt;ここ&lt;/a&gt;においておきます。&lt;/p&gt;

&lt;p&gt;因みに本筋とは外れますが、今回のSQLiteの問題を扱うには一旦CSVファイルに書き出してからCSVインポートでバルクインサートが考えられます。
CSVに書き出すのはちまちまやってもいいし今回のデータ量ならオンメモリ構築して一気に書き出しも出来るでしょう。あるいはSQLiteをやめてMySQLを使う。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustで小さなツールを作ってみる(前編)</title>
      <link>http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru</link>
      <pubDate>Sat, 14 Nov 2015 23:57:43 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 1日目の記事です。&lt;br /&gt;
次 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_/&#34;&gt;Rustで小さなツールを作ってみる(後編)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。Rust Advent Calendar初日ということで軽い話から。
小さなツールって何だよって感じですが手元にIRCの生ログが大量にあるのでそれをDBにインポートしてみましょう。
あまりRustに向いた仕事じゃなさそうですが手始めとして。&lt;/p&gt;

&lt;p&gt;前編でログのパースを、後編でDBへのインポートをやります。&lt;/p&gt;

&lt;p&gt;IRCの生ログは&lt;a href=&#34;http://www.clovery.jp/tiarra/&#34;&gt;tiarra&lt;/a&gt;が吐いたものです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#emacs@freenode&lt;/code&gt;のように&lt;code&gt;チャネル名@サーバ名&lt;/code&gt;のディレクトリに入っていて、ファイル名は&lt;code&gt;YYYY-mm-dd.txt&lt;/code&gt;で、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;13:43:24 &amp;lt;#emacs@freenode:codingquark&amp;gt; Such key generation, much wow.
13:43:59 ! Vejeta` (Ping timeout: 264 seconds)
13:44:30 + jcazevedo (jcazevedo!~jcazevedo@a94-132-141-99.cpe.netcabo.pt) to #emacs@freenode
13:45:30 + quazimodo (quazimodo!~quazimodo@155.143.14.28) to #emacs@freenode
13:45:32 ! Hugehead_ (Read error: Connection reset by peer)
13:48:48 + favadi (favadi!~textual@113.190.4.106) to #emacs@freenode
13:51:06 wizzo -&amp;gt; bitchimightbe
13:52:23 bitchimightbe -&amp;gt; wizzo
13:53:05 - frost3772 from #emacs@freenode (&amp;quot;ERC (IRC client for Emacs 24.5.1)&amp;quot;)
13:56:37 ! chandan (Quit: WeeChat 1.2)
13:56:38 ! plunderous (Read error: Connection res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような形式で入ってます。先頭に&lt;code&gt;&amp;lt;&lt;/code&gt;が付いてるのが発言、&lt;code&gt;!&lt;/code&gt;がついてるのがなんかメッセージ(多分quitとかkillとか)、&lt;code&gt;+&lt;/code&gt;がjoin、&lt;code&gt;-&lt;/code&gt;がpart、無しがnickとかnoticeですかね。他にもログ取ってるircコマンドはあるのですが&lt;code&gt;!&lt;/code&gt;に内包されてそうですね(tiarraのマニュアルに載ってそうですが見るの面倒)&lt;/p&gt;

&lt;p&gt;因みにログ全体は&lt;code&gt;~/log&lt;/code&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;一応treeするとこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── #emacs@freenode
│   ├── 2014-04-11.txt
│   ├── 2014-04-12.txt
│   ├── 2014-04-13.txt
..  ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2014-04-11から2015-11-01までの間ロギングしてます。&lt;/p&gt;

&lt;h1 id=&#34;ディレクトリリスティングまで:a7315be0136fc976c0c4320441efd799&#34;&gt;ディレクトリリスティングまで&lt;/h1&gt;

&lt;p&gt;まずは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new irc_log --bin
$ cd irc_log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;code&gt;src/main.rs&lt;/code&gt;を開いて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs;

fn main() {
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, path.to_string_lossy().to_string());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きましょう。path path煩いですね。OSの返す文字列(Cの文字列)とRustの文字列の違いだとか一旦&lt;code&gt;Path&lt;/code&gt;で抽象化してるだとかで文字列を抜き出すのは一苦労です。&lt;/p&gt;

&lt;p&gt;さて、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でディレクトリ名が出てくればOK。&lt;/p&gt;

&lt;h1 id=&#34;ファイル名リスティング:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイル名リスティング&lt;/h1&gt;

&lt;p&gt;mainを&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs;

fn main() {
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        on_channel_dir(&amp;amp;path);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と置き換えてチャネルのディレクトリでの作業は&lt;code&gt;on_channel_dir&lt;/code&gt;でやりましょう。&lt;/p&gt;

&lt;h2 id=&#34;チャネル名とサーバ名の抜き出し:a7315be0136fc976c0c4320441efd799&#34;&gt;チャネル名とサーバ名の抜き出し&lt;/h2&gt;

&lt;p&gt;ディレクトリ名が&lt;code&gt;チャネル名@サーバ名&lt;/code&gt; の 形をしているので @の前後を抜き出せば良さそうです。&lt;/p&gt;

&lt;p&gt;src/main.rsの先頭に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::path::Path;
use std::str::from_utf8;
use std::os::unix::prelude::OsStrExt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でとりあえず&lt;code&gt;/&lt;/code&gt;の付かないディレクトリ名を取れそうです。難しい。やはりOSの返す文字列の扱いは面倒ですね。
しかし一旦Rustの文字列になってしまえばこちらのもの。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;@&lt;/code&gt;の位置を取得出来ます。&lt;code&gt;@&lt;/code&gt;がなかったらreturnして無視しておきましょう（実際そういう名前のディレクトリがあるのですが今回の集計の対象外なので）。&lt;/p&gt;

&lt;p&gt;あとは部分文字列を取るだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ファイルリスティング:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルリスティング&lt;/h2&gt;

&lt;p&gt;これは先程と同じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        let log = log.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, log.to_string_lossy().to_string());
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、&lt;code&gt;on_channel_dir&lt;/code&gt;全体はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        let log = log.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, log.to_string_lossy().to_string());
    };
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ファイルのパース:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルのパース&lt;/h1&gt;

&lt;p&gt;次にまた&lt;code&gt;println!&lt;/code&gt;の部分を&lt;code&gt;on_log&lt;/code&gt;としてファイルをパースしていきましょう。&lt;/p&gt;

&lt;h2 id=&#34;日付の抜き出し:a7315be0136fc976c0c4320441efd799&#34;&gt;日付の抜き出し&lt;/h2&gt;

&lt;p&gt;先程と似てますので飛ばし気味にいきます。&lt;/p&gt;

&lt;p&gt;簡単にやっても良いのですがお作法として日付ライブラリを使ってパースしましょう。
&lt;code&gt;Cargo.toml&lt;/code&gt;に以下を追記。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]
time = &amp;quot;*&amp;quot;
log = &amp;quot;0.3.3&amp;quot;
env_logger = &amp;quot;0.3.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本当はバージョンも指定した方が良いのですが書き捨てのコードなのでまあ、良いでしょう。因みにtimeライブラリ自体扱いづらいとか色々問題があるのですがそれは後のAdvent Calendarに譲りましょう。しれっとloggerも導入します。printfデバッグにlogger便利!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;してdependenciesをインストールします。因みに&lt;code&gt;log&lt;/code&gt;がlogger facadで&lt;code&gt;env_logger&lt;/code&gt;がloggerの実装です。使い方は後程。&lt;/p&gt;

&lt;p&gt;またsrc/main.rsの先頭に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[macro_use]
extern crate log;
extern crate env_logger;
extern crate time;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記。&lt;/p&gt;

&lt;p&gt;そして&lt;code&gt;on_log&lt;/code&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_log(log: &amp;amp;Path) {
    let datestr = from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();
    let date = time::strptime(&amp;amp;datestr, &amp;quot;%Y-%m-%d&amp;quot;).urwrap();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は失敗しないことが分かってるので全部&lt;code&gt;unwrap&lt;/code&gt;してます。本当は&lt;code&gt;try!&lt;/code&gt;を使って上流に委ねた方がいいのですが今回は面倒なのでこうしちゃってます。正しいエラーハンドリングはtrplの&lt;a href=&#34;https://doc.rust-lang.org/book/error-handling.html&#34;&gt;Error Handling&lt;/a&gt;を読みましょう。&lt;/p&gt;

&lt;h2 id=&#34;ファイルの読み出し:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルの読み出し&lt;/h2&gt;

&lt;h3 id=&#34;開く:a7315be0136fc976c0c4320441efd799&#34;&gt;開く&lt;/h3&gt;

&lt;p&gt;コードをいきなり載せると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let file = match fs::File::open(log) {
        Ok(f) =&amp;gt; f,
        Err(e) =&amp;gt; {
            error!(&amp;quot;could not open {}; skipping.&amp;quot;, log.display());
            return;
        }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。これはエラーハンドリングします。1つのファイルに失敗しても次があるので。ここで使ってる&lt;code&gt;error!&lt;/code&gt;がloggerのマクロです。&lt;/p&gt;

&lt;h2 id=&#34;行毎の読み出し:a7315be0136fc976c0c4320441efd799&#34;&gt;行毎の読み出し&lt;/h2&gt;

&lt;p&gt;行毎の読み出しはバッファーリーダーが必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io::BufReader;
use std::io::BufRead;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をsrc/main.rsの先頭部分に追記しましょう。因みに&lt;code&gt;BufRead&lt;/code&gt;がトレイトで、&lt;code&gt;BufReader&lt;/code&gt;が実装です。実装が必要なのは良いとして、トレイトまで必要なのはトレイトで定義された関数を呼び出すのにトレイトのインポートが必要だからですね。&lt;/p&gt;

&lt;p&gt;さてさて、行の読み出しを進めます。先程オープンしたファイルを&lt;code&gt;BufReader&lt;/code&gt;で包んでやればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let br = BufReader::new(&amp;amp;file);
    for line in br.lines() {
        let line = match line {
            Ok(l) =&amp;gt; l,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;ignoring error {}&amp;quot;, e);
                continue;
            }
        };
        ....
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行の読み出し結果もResultで返ってくるんですね。これも失敗したら読み飛ばせばいいので&lt;code&gt;urwrap&lt;/code&gt;せずに扱います。&lt;/p&gt;

&lt;h2 id=&#34;行のパース:a7315be0136fc976c0c4320441efd799&#34;&gt;行のパース&lt;/h2&gt;

&lt;h3 id=&#34;ガード:a7315be0136fc976c0c4320441efd799&#34;&gt;ガード&lt;/h3&gt;

&lt;p&gt;先頭部分の時間をパースする時に部分文字列を抜き出しますが、変な行だと10文字もなかったりするので一旦ガードを付けておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        if line.len() &amp;lt; 10 {
            warn!(&amp;quot;ignoring line {}&amp;quot;, line);
            continue;
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;時間のパース:a7315be0136fc976c0c4320441efd799&#34;&gt;時間のパース&lt;/h3&gt;

&lt;p&gt;これはファイル名の時とほぼ同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let time = match time::strptime(&amp;amp;line[0..8], &amp;quot;%H:%M:%S&amp;quot;) {
            Ok(t) =&amp;gt; t,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;Parse error {}; ignoring&amp;quot;, e);
                continue;

            }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度は変な行が紛れてそうな（実際、ログファイルにはよくある）のでエラーは無視します。&lt;/p&gt;

&lt;h3 id=&#34;メッセージのパース:a7315be0136fc976c0c4320441efd799&#34;&gt;メッセージのパース&lt;/h3&gt;

&lt;p&gt;0-8文字目に時間があって、1スペース挟むので9文字目からがメッセージですね。そして先頭の文字で判断出来るのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let msg = &amp;amp;line[9..];
        match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; println!(&amp;quot;sysmsg {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; println!(&amp;quot;join {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; println!(&amp;quot;part {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; println!(&amp;quot;user: {} body: {}&amp;quot;, user, body),
                None =&amp;gt; ()
            },
            _ =&amp;gt; println!(&amp;quot;info {}&amp;quot;, &amp;amp;msg[1..]),
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で判断出来そうです。パースした後の話は後回し。&lt;/p&gt;

&lt;h1 id=&#34;ソース全体:a7315be0136fc976c0c4320441efd799&#34;&gt;ソース全体&lt;/h1&gt;

&lt;p&gt;ソースの断片が続いたので一旦ここまでの全体像を出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[macro_use]
extern crate log;
extern crate env_logger;
extern crate time;
use std::str::from_utf8;
use std::io::BufReader;
use std::io::BufRead;
use std::fs;
use std::path::Path;
use std::os::unix::prelude::OsStrExt;


fn on_log(log: &amp;amp;Path) {
    let datestr = from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();
    let date = time::strptime(&amp;amp;datestr, &amp;quot;%Y-%m-%d&amp;quot;);
    let file = match fs::File::open(log) {
        Ok(f) =&amp;gt; f,
        Err(e) =&amp;gt; {
            error!(&amp;quot;could not open {}; skipping.&amp;quot;, log.display());
            return;
        }
    };
    let br = BufReader::new(&amp;amp;file);
    for line in br.lines() {
        let line = match line {
            Ok(l) =&amp;gt; l,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;ignoring error {}&amp;quot;, e);
                continue;
            }
        };
        if line.len() &amp;lt; 10 {
            warn!(&amp;quot;ignoring line {}&amp;quot;, line);
            continue;
        }
        let time = match time::strptime(&amp;amp;line[0..8], &amp;quot;%H:%M:%S&amp;quot;) {
            Ok(t) =&amp;gt; t,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;Parse error {}; ignoring&amp;quot;, e);
                continue;

            }
        };
        let msg = &amp;amp;line[9..];
        match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; println!(&amp;quot;sysmsg {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; println!(&amp;quot;join {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; println!(&amp;quot;part {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; println!(&amp;quot;user: {} body: {}&amp;quot;, user, body),
                None =&amp;gt; ()
            },
            _ =&amp;gt; println!(&amp;quot;info {}&amp;quot;, &amp;amp;msg[1..]),
        }
    }
}

fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        on_log(&amp;amp;log.unwrap().path());
    };
}


fn main(){
    env_logger::init().unwrap();
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        on_channel_dir(&amp;amp;path);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はmainの先頭で&lt;code&gt;env_logger::init().unwrap();&lt;/code&gt;でロガーの初期化してました。忘れてましたね。ごめんなさい。&lt;/p&gt;

&lt;p&gt;さて、これで一旦走らせてみましょう。動く筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動いてるようですが、遅い。出力が多くてターミナル側がボトルネックのようです。&lt;/p&gt;

&lt;h1 id=&#34;パニックハンドルとチューニング:a7315be0136fc976c0c4320441efd799&#34;&gt;パニックハンドルとチューニング&lt;/h1&gt;

&lt;p&gt;一旦メッセージを出力をやめて様子見してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;            &amp;quot;!&amp;quot; =&amp;gt; (),
            &amp;quot;+&amp;quot; =&amp;gt; (),
            &amp;quot;-&amp;quot; =&amp;gt; (),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; (),
            _ =&amp;gt; (),

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それでもまだ遅い上に謎のパニックが出てます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;/home/kim/log/#lisp@freenode&#39; panicked at &#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary&#39;, ../src/libcore/str/mod.rs:1311
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログを見てみましょう。env_loggerは環境変数からログレベルを渡してあげるとログを出します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ RUST_LOG=Trace cargo run
...
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意外と変な行が一杯あるのですね。しかしこれらはちゃんとエラーハンドリングしてるので問題ありません。&lt;/p&gt;

&lt;p&gt;各所で&lt;code&gt;unwrap&lt;/code&gt;してるせいな気もしますが、&lt;code&gt;urwrap&lt;/code&gt;のせいならそういうメッセージが出るので違います。&lt;/p&gt;

&lt;p&gt;実はこれ、非UTF-8のバイト列でrustの標準ライブラリが内部でパニックを出してます。
これの扱いも後のAdvent Calendarに譲るとして、ワークアラウンドを捜しましょう。rust1.4時点ではパニックをハンドルする手段はありません。&lt;/p&gt;

&lt;p&gt;パニックメッセージの先頭に&lt;code&gt;thread&lt;/code&gt;とついてるのでthreadで包めば良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;thread:a7315be0136fc976c0c4320441efd799&#34;&gt;Thread&lt;/h2&gt;

&lt;p&gt;まずはthreadをインポートします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::thread::Builder;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてon_channel_logを少し弄りましょう。無効なバイト列を含むファイルをざっくり切る感じで。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    for log in logs {
        on_log(&amp;amp;log.unwrap().path());
    };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていた部分を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let threads = logs.map(|log| {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log))
    }).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
    for thread in threads {
        let _ = thread.unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。一見複雑ですが、ファイル毎にスレッドを作って全部をvectorにして集めてそれぞれjoinを待ってるだけです。
そしてスレッド名を処理するファイル名にしたいのでスレッドビルダを使っています。&lt;/p&gt;

&lt;p&gt;さて、これで走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time cargo run
...
#lisp at freenode
thread &#39;/home/kim/log/#lisp@freenode/2014-08-18.txt&#39; panicked at &#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary&#39;, ../src/libcore/str/mod.rs:1311
#emacs at freenode
...
cargo run  327.21s user 8.71s system 630% cpu 53.289 total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lispチャネルの1ファイルだけに変なバイト列があることが分かりました。&lt;/p&gt;

&lt;p&gt;そしてパフォーマンスですが、とりあえず&lt;code&gt;top&lt;/code&gt;で見る限りCPUは最大770%使ってくれてます（8コアマシン）。ファイル毎にスレッド作ってるので若干リソースの食い合いが発生してますがこれだけ並列度があればスレッドプールを使うまでもないでしょう。&lt;/p&gt;

&lt;h2 id=&#34;さらなるチューニング:a7315be0136fc976c0c4320441efd799&#34;&gt;さらなるチューニング…？&lt;/h2&gt;

&lt;p&gt;しかしそれでもまだ遅いですね。ちょこっと書いては走らせるのサイクルを回すには耐えられません。&lt;/p&gt;

&lt;p&gt;そういえばログ全体のファイルサイズを確認してなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -h
...
774M   .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意外と小さい。まだチューニングの余地はありそうです。メモリアロケーションを減らしましょうか、それとも時間のパースを手書きでやりましょうか。&lt;/p&gt;

&lt;p&gt;いいえ。もっと簡単に速くする方法があります。&lt;code&gt;--release&lt;/code&gt;をつけて実行すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
...
cargo run --release  3.63s user 5.44s system 203% cpu 4.453 total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(/ 53.289 4.453);=&amp;gt; 11.966988547046935&lt;/code&gt; 。12倍速くなりました。1ディレクトリ700以上のファイルがあってそれぞれにスレッドを作っているのでそろそろそのオーバーヘッドが効いてきてますね。&lt;/p&gt;

&lt;p&gt;スレッドプールを試してみたい気もしますがひとまずこれで置いておきましょう。&lt;/p&gt;

&lt;p&gt;次は後編、DBへのインポートです。&lt;/p&gt;

&lt;p&gt;蛇足ですが行のパースのところは正規表現でも出来ましたね。そっちの方が好きな方は試してみて下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一時ファイルの作り方</title>
      <link>http://keens.github.io/blog/2015/11/08/ichijifairunotsukurikata</link>
      <pubDate>Sun, 08 Nov 2015 21:40:14 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/08/ichijifairunotsukurikata</guid>
      <description>

&lt;p&gt;Rustに&lt;a href=&#34;https://github.com/Stebalien/tempfile&#34;&gt;tempfile&lt;/a&gt;というライブラリがある。その名の通りテンポラリファイルを作るライブラリだ。
必要に迫られてそのライブラリにPRを送ろうとして実装を読んだのだが普段あまり意識しなかったテンポラリファイルの作り方を知ったのでちょっと解説してみる。&lt;/p&gt;

&lt;p&gt;Rustはほぼそのままの使い心地でCのライブラリを呼べるのでCが分かる人になら伝わると思う。&lt;/p&gt;

&lt;p&gt;ライブラリの構成として、src/*.rsにOS非依存なコードやユーザ向けのAPIがあり、src/imp/{windows,unix}.rsにOS依存なコードがある。
私はWindowsの実装には興味ないし詳しくもないのでunix向けの実装だけを見る。&lt;/p&gt;

&lt;p&gt;imp以下を見る前にこのライブライが提供するAPIを解説しておくと、大きく分けて&lt;code&gt;TempFile&lt;/code&gt;と&lt;code&gt;NamedTempFile&lt;/code&gt;がある。無名、Namedどちらにもデフォルトの一時ファイルディレクトリ下に一時ファイルを作るAPIと指定したディレクトリ以下に作るAPIとがある。
&lt;code&gt;TempFile&lt;/code&gt;が作るファイルは完全に匿名で、ファイルシステムに残らない。I/Oが出来るストリームだけを返す。定期的に/tmp以下を削除するジョブが走っていたとしても安全だし、他のプロセスに中身を読まれる危険性もない。
一方&lt;code&gt;NamedTempFile&lt;/code&gt;の方は予測不可能なファイル名でファイルを作るものの、ファイルシステムに残るので安全ではない。しかしファイル名を要求する関数や外部プロセスと協調する時に使える。&lt;/p&gt;

&lt;p&gt;それぞれで実装を見ていく。&lt;/p&gt;

&lt;h1 id=&#34;tempfile:047d25333d01b489b97d09f703fb9afe&#34;&gt;TempFile&lt;/h1&gt;

&lt;p&gt;これはLinuxとその他で実装が分かれる。ユーザーAPI側でテンポラリファイルを作るディレクトリの指定は吸収しているのでこちらではただ指定されたディレクトリ下にテンポラリファイルを作ればいい。&lt;/p&gt;

&lt;h2 id=&#34;linux:047d25333d01b489b97d09f703fb9afe&#34;&gt;Linux&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(target_os = &amp;quot;linux&amp;quot;)]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    const O_TMPFILE: libc::c_int = 0o20200000;
    match unsafe {
        libc::open(try!(cstr(dir)).as_ptr(), O_CLOEXEC | O_EXCL | O_TMPFILE | O_RDWR, 0o600)
    } {
        -1 =&amp;gt; create_unix(dir),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux 3.11から&lt;code&gt;O_TMPFILE&lt;/code&gt;が入ったので実装は直接的だ。&lt;code&gt;O_TMPFILE&lt;/code&gt;はテンポラリファイル向けにファイルシステムに名前が登録されない匿名のファイルを作る。Lispのgensymに似ている。
O_EXCLでリンクによる別名での参照を回避し、Linux 2.6.23以後で入ったO_CLOEXECで&lt;code&gt;exec(2)&lt;/code&gt;した時にfdを閉じるようにする。そうすれば関係のないプログラムからファイルが参照されるのを防げる。&lt;/p&gt;

&lt;p&gt;このライブラリコールが成功すればそのままFileを返す。&lt;/p&gt;

&lt;p&gt;Linux 3.11未満やO_TMPFILEをサポートしないファイルシステムだったら失敗し、-1が返るのでLinuxに依存しない汎用の&lt;code&gt;create_unix&lt;/code&gt;にフォールバックする。&lt;/p&gt;

&lt;h2 id=&#34;unix:047d25333d01b489b97d09f703fb9afe&#34;&gt;Unix&lt;/h2&gt;

&lt;p&gt;Unix向けの実装は恐らくPOSIX互換なシステムなら全てで動く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(not(target_os = &amp;quot;linux&amp;quot;))]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    create_unix(dir)
}

fn create_unix(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        let tmp_path = dir.join(&amp;amp;tmpname());
        return match create_named(&amp;amp;tmp_path) {
            Ok(file) =&amp;gt; {
                // I should probably tell the user this failed but the temporary file creation
                // didn&#39;t really fail...
                let _ = fs::remove_file(tmp_path);
                Ok(file)
            },
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        }
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;汎用の&lt;code&gt;create_unix&lt;/code&gt;では完全に無名のテンポラリファイルを作るのを諦めて、一旦ランダム生成な名前のファイルを作って開き、成功したらそのファイルを削除する。
1つでも開いてるプロセスがある時に削除されるとUnixのファイルはそのプロセスからは見れるが他のプロセスからは見れない状態になるので色々便利に使われている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;create_named&lt;/code&gt;は後程見るとして、ランダム生成なファイル名だと稀に既に存在するファイル名と被る可能性があるので何度かリトライしている。
リトライ回数はsrc/lib.rsで定義されていて、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const NUM_RETRIES: u32 = 1 &amp;lt;&amp;lt; 31;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。思ったよりえけつない回数リトライしている。もちろん、ファイル名が被った以外の理由でファイル生成が失敗したのならリトライに意味はないので大人しくreturnしている。&lt;/p&gt;

&lt;p&gt;で、&lt;code&gt;create_named&lt;/code&gt;だが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    match unsafe {
        libc::open(try!(cstr(&amp;amp;path)).as_ptr(), O_CLOEXEC | O_EXCL | O_RDWR | O_CREAT, 0o600)
    } {
        -1 =&amp;gt; Err(io::Error::last_os_error()),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。単に&lt;code&gt;create&lt;/code&gt;のフラグの&lt;code&gt;O_TMPFILE&lt;/code&gt;が&lt;code&gt;O_CREAT&lt;/code&gt;になっただけ。&lt;/p&gt;

&lt;h1 id=&#34;namedtempfile:047d25333d01b489b97d09f703fb9afe&#34;&gt;NamedTempFile&lt;/h1&gt;

&lt;p&gt;こちらはユーザーAPIの中から直接OS互換用コードを呼んでいる。src/named.rsに実装がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    /// Create a new temporary file in the specified directory.
    pub fn new_in&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(dir: P) -&amp;gt; io::Result&amp;lt;NamedTempFile&amp;gt; {
        for _ in 0..::NUM_RETRIES {
            let path = dir.as_ref().join(&amp;amp;util::tmpname());
            return match imp::create_named(&amp;amp;path) {
                Ok(file) =&amp;gt; Ok(NamedTempFile(Some(NamedTempFileInner { path: path, file: file, }))),
                Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
                Err(e) =&amp;gt; Err(e),
            }
        }
        Err(io::Error::new(io::ErrorKind::AlreadyExists,
                           &amp;quot;too many temporary directories already exist&amp;quot;))
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値をユーザAPI向けにラップしている以外は無名の一時ファイルと変わらない。余談だがここで使われているファイル名にユーザが干渉することが出来ず、完全にランダムなファイル名になっている。
ファイルの末尾(例えば拡張子)や先頭(例えばapp_nameなどの識別子)を挟めない。私が今作業してるパッチはその辺をもう少し自由にするものだ。&lt;/p&gt;

&lt;p&gt;閑話休題。似たような実装が2つもあるのは気になるので一応windows向けの実装も読んでみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const ACCESS: DWORD     = winapi::FILE_GENERIC_READ
                        | winapi::FILE_GENERIC_WRITE;
const SHARE_MODE: DWORD = winapi::FILE_SHARE_DELETE
                        | winapi::FILE_SHARE_READ
                        | winapi::FILE_SHARE_WRITE;
const FLAGS: DWORD      = winapi::FILE_ATTRIBUTE_HIDDEN
                        | winapi::FILE_ATTRIBUTE_TEMPORARY;


fn to_utf16(s: &amp;amp;Path) -&amp;gt; Vec&amp;lt;u16&amp;gt; {
    s.as_os_str().encode_wide().chain(Some(0).into_iter()).collect()
}

fn win_create(path: &amp;amp;Path,
                     access: DWORD,
                     share_mode: DWORD,
                     disp: DWORD,
                     flags: DWORD) -&amp;gt; io::Result&amp;lt;File&amp;gt; {

    let path = to_utf16(path);
    let handle = unsafe {
        CreateFileW(
            path.as_ptr(),
            access,
            share_mode,
            0 as *mut _,
            disp,
            flags,
            ptr::null_mut())
    };
    if handle == winapi::INVALID_HANDLE_VALUE {
        Err(io::Error::last_os_error())
    } else {
        Ok(unsafe { File::from_raw_handle(handle as RawHandle) })
    }
}

pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    win_create(path, ACCESS, SHARE_MODE, winapi::CREATE_NEW, FLAGS)
}

pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        return match win_create(
            &amp;amp;dir.join(&amp;amp;tmpname()),
            ACCESS,
            SHARE_MODE,
            winapi::CREATE_NEW,
            FLAGS | winapi::FILE_FLAG_DELETE_ON_CLOSE)
        {
            Ok(f) =&amp;gt; Ok(f),
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        };
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows向けの実装は必ずファイル名を指定する必要があり、リトライが必要そう？&lt;code&gt;NamedTempFile&lt;/code&gt;を作るには(理論的に)どの実装でもリトライが必要だからユーザAPI側で纏めたのかな？&lt;/p&gt;

&lt;h1 id=&#34;まとめ:047d25333d01b489b97d09f703fb9afe&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;テンポラリファイルを作るならまずは&lt;code&gt;O_TMPFILE&lt;/code&gt;を試す&lt;/li&gt;
&lt;li&gt;ダメならランダム生成なファイル名で成功するまでリトライ、成功したら即座にファイルを削除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作業中のコードをpushし忘れて土日に進捗出来なかったのでまたお茶を濁すはめになった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>REST APIのテストにはwgetが便利かもしれない</title>
      <link>http://keens.github.io/blog/2015/10/20/apinotesutonihawgetgabenrikamoshirenai</link>
      <pubDate>Tue, 20 Oct 2015 00:30:42 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/10/20/apinotesutonihawgetgabenrikamoshirenai</guid>
      <description>

&lt;p&gt;寝れずに悶々としていたので書いてみる。REST APIを叩くときはデフォルトで結果を標準出力に吐くcURLがよく使われるがテストにはwgetが向いてるかもしれない。&lt;/p&gt;

&lt;p&gt;理由は簡単。exit statusだ。シェルのテストをする時は&lt;a href=&#34;https://github.com/kward/shunit2&#34;&gt;shunit2&lt;/a&gt;を使うことになるかと思うが、exit statusでテストをしたくなる。
cURLはHTTPサーバーがエラーステータスを返してもexit status 0で終了するのに対してwgetは所定の値を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXIT STATUS
       Wget may return one of several error codes if it encounters problems.

       0   No problems occurred.

       1   Generic error code.

       2   Parse error---for instance, when parsing command-line options, the .wgetrc or .netrc...

       3   File I/O error.

       4   Network failure.

       5   SSL verification failure.

       6   Username/password authentication failure.

       7   Protocol errors.

       8   Server issued an error response.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;少し試してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sL google.com/teapot &amp;gt; /dev/null
$ echo $?
0
$ wget -qO /dev/null google.com/teapot
$ echo $?
8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと違いが出ている。余談だが &lt;code&gt;wget -O /dev/null&lt;/code&gt;は便利なので覚えておくと幸せになれる。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:67650a6fc4fa81318fe87d2796b2dbeb&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;HTTPのエラーを全部1つのステータスに纏めるのはちょっと乱暴な気がする。wgetはHTTP以外のプロトコルにも対応してるのでまあ仕方がないのだろうが。
ということで任意のHTTPレスポンスを抜き出してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sIL google.com/teapot | grep -E &#39;^HTTP/[0-9](\.[0-9])? [0-9]{3}&#39;
HTTP/1.1 301 Moved Permanently
HTTP/1.1 418 I&#39;m a Teapot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本当にstatusだけ抜き出したかったらこうだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sIL google.com/teapot | grep -E &#39;^HTTP/[0-9](\.[0-9])? [0-9]{3}&#39; | grep -o -E &#39;[0-9]{3}&#39;
301
418
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数回HTTPリクエストを飛ばしているので複数statusが返ってくるのは諦めよう。最後のやつだけ欲しければ &lt;code&gt;tail -n 1&lt;/code&gt;すればいい。&lt;/p&gt;

&lt;p&gt;HTTPの仕様を読まずに書いたのでバージョンのマッチの部分が冗長かもしれないがとりあえず動く。というかcURLを使った。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:67650a6fc4fa81318fe87d2796b2dbeb&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;cURL使おう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ddでPCの引っ越しをしたら起動しなかった</title>
      <link>http://keens.github.io/blog/2015/10/05/dd_depcnohikkoshiwoshitarakidoushinakatta</link>
      <pubDate>Mon, 05 Oct 2015 21:30:06 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/10/05/dd_depcnohikkoshiwoshitarakidoushinakatta</guid>
      <description>

&lt;p&gt;κeenです。この間長年使ってたDynabookからThink Padに乗り換えました。引っ越しの時に困ったのでメモ。&lt;/p&gt;

&lt;p&gt;元々あるのが&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dynabook&lt;/li&gt;
&lt;li&gt;外付けハードディスクカバー&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新たに購入したのが&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Think Pad (HDDモデル)&lt;/li&gt;
&lt;li&gt;SSD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SSDだけ先に手元に来たのでまずSSDへ引っ越しを済ませ、Think Padが届いたらHDDとSSDを交換することに。&lt;/p&gt;

&lt;h1 id=&#34;dynabookのhddからssdへの引っ越し:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;DynabookのHDDからSSDへの引っ越し&lt;/h1&gt;

&lt;p&gt;Ubuntuをインストールしてバックアップから復元しても良かったのですがHDDもSSDも512GBだったので&lt;code&gt;dd&lt;/code&gt;を使って引っ越ししました。&lt;/p&gt;

&lt;p&gt;事前に出来る限りプロセスは殺す。本来は別ディスクから立ち上げたOSでやるのが良いんだろうけど面倒だったので引越し対象のOSから実行しました。。コマンドはすごいシンプル。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ dd if=/dev/sda of=/dev/sdb bs=512k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外付けハードディスクカバーとDynabookがUSB2.0までにしか対応してないからか20MB/sしか出ず、一晩掛かりました。しかし終わったあとDynabookのHDDとSSDを交換して起動してみると何の問題もなく起動しました。素晴しい。&lt;/p&gt;

&lt;h1 id=&#34;ssdをthink-padに移植:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;SSDをThink Padに移植&lt;/h1&gt;

&lt;p&gt;一瞬ハードディスクの外し方が分からず苦戦するもネットで調べると分解マニュアルが出てきたので楽に換装。しかしThink Padの電源を入れても起動しなかった。&lt;/p&gt;

&lt;h1 id=&#34;biosとuefi:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;BIOSとUEFI&lt;/h1&gt;

&lt;h2 id=&#34;bios:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;BIOS&lt;/h2&gt;

&lt;p&gt;BIOSといえばコンビュータの電源をポチっと入れた瞬間に起動するソフトウェアで、Basic I/O Systemの略かと思っていましたがBasic I/O Systemの実装の1つの名前でもあるらしいです。&lt;/p&gt;

&lt;p&gt;BIOSはディスクの先頭にあるMaster Boot Recordを読みにいきます。そこからパーティションテーブルの情報を得てgrubなどを起動します。（Master Boot RecordのことをMBRと略すこともあるしMaster Boot Recordを使うパーティションテーブルのことをMBRと呼ぶこともある…？）。昔、&lt;a href=&#34;http://KeenS.github.io/blog/2015/01/08/freebsd-environment-setups/&#34;&gt;GPTを使うと起動しなかった経験がある&lt;/a&gt;ので私のDynabookのBasic I/O SystemにはBIOSが使われていた模様。&lt;/p&gt;

&lt;h2 id=&#34;uefi:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;UEFI&lt;/h2&gt;

&lt;p&gt;UEFIはBIOSに代わるBasic I/O Systemらしいです。MBRの他、GPTもサポートします。GPTは &lt;strong&gt;MBR を使わず&lt;/strong&gt; 、EFI System Partitionなるものを使うらしいです。Think PadのBasic I/O Systemはこれだったようです。&lt;/p&gt;

&lt;h1 id=&#34;原因-対策-今後:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;原因、対策、今後&lt;/h1&gt;

&lt;p&gt;ということでUEFIがGPTを期待していたのにこちらはBIOS向けのMBRを用意していたのでダメだった模様。(いわゆる従来)BIOS画面(と呼ばれていたもの)に入って起動タイプをUEFIからLegacyにすることで起動出来ました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 可能ですよ。WindowsでもLinuxでもBSDでも、です。&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647688708661972992&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; gptgenなどを用いてパーティションをMBRからGPTに変換すること、FAT32のパーティションを作り(先頭パーティションであることが好ましい)パーティションタイプを0xEF00にすること、そしてブートローダーをそのパーティションにインストールする&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647692419090112512&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 以上があらましになります。FAT32のこのパーティションはEFI System Partition, ESPと呼ばれ、従来ファイルシステムから不可視な先頭セクタにインストールされていたブートローダーはただの実行ファイルとしてESPに置かれます&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647692825853755392&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; ブートローダーをESPに入れる手段としては、ArchWikiのUEFIの項をご覧ください。また、この時efibootmgrコマンドを用いてブートローダーのパスをUEFIに記録させておくと、UEFIのブートデバイス選択画面にブートローダーが出現します。&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647693202737098757&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; GRUBの場合efibootmgrコマンドを使うべき操作は自動でしてくれます。&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647693310149025792&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;とのことですがまあ、SSDの先頭のスペース空いてないしちょっとミスったら即死だしどうしましょうね。
一旦SSDの中身を元のHDDに退避してSSDにUEFIで起動するパーティション作ってそのパーティションに元のパーティションをddでコピーとかで出来ますかね…&lt;/p&gt;

&lt;p&gt;サルでも分かる操作マニュアルが欲しい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>isucon にCommon Lispチームで出た</title>
      <link>http://keens.github.io/blog/2015/09/27/isucon_nicommon_lispchi_mudedeta</link>
      <pubDate>Sun, 27 Sep 2015 23:58:24 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/09/27/isucon_nicommon_lispchi_mudedeta</guid>
      <description>

&lt;p&gt;κeenです。 &lt;a href=&#34;isucon.net&#34;&gt;isucon&lt;/a&gt; に&lt;a href=&#34;https://twitter.com/i/notifications?lang=ja&#34;&gt;@nitro_idiot&lt;/a&gt;(深町さん)と&lt;a href=&#34;https://twitter.com/Rudolph_Miller?lang=ja&#34;&gt;@Rudolph_Miller&lt;/a&gt;のCommon Lispチームで出てきました。チーム名clfreaks。勿論Common Lispで再実装しました。&lt;/p&gt;

&lt;p&gt;因みに深町さんは今回使ったWebサーバーのwooを含めCommon Lispのライブラリを多数公開している&lt;a href=&#34;http://github-awards.com/users/search?login=fukamachi&#34;&gt;世界一のCommon Lisper&lt;/a&gt;、ルドルフさんは元Common Lispの会社のCTO。&lt;/p&gt;

&lt;h1 id=&#34;前日:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;前日&lt;/h1&gt;

&lt;p&gt;κeen 「あとはwooがunixソケット使えたら嬉しいんですがまあ、いいでしょう。」&lt;br /&gt;
fukamachi 「今からやれば明日には間に合うな」&lt;br /&gt;
fukamachi 「ローカルでは一応動いた。間に合いそうである」&lt;br /&gt;
fukamachi 「5倍ちょっとくらい速いかな」&lt;/p&gt;

&lt;p&gt;この間1時間半足らず。&lt;/p&gt;

&lt;p&gt;κeen 「練習してて気付いたんですけどデプロイツールってどうしましょう。」&lt;br /&gt;
fukamachi 「κeenさんが使い慣れてるツールで良いです」&lt;br /&gt;
κeen 「シェルスクリプトかー。」&lt;br /&gt;
fukamachi 「やめろ」&lt;/p&gt;

&lt;p&gt;結局capistranoを使うことに。&lt;/p&gt;

&lt;h1 id=&#34;当日の作業:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;当日の作業&lt;/h1&gt;

&lt;p&gt;私がマシン立ち上げてソースをgitに上げるまでやる。残りの二人はソースを読む、私はNginXやMySQLやCapistranの基本設定をする。&lt;/p&gt;

&lt;h2 id=&#34;午前中-common-lispでの再実装:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;午前中 Common Lispでの再実装&lt;/h2&gt;

&lt;p&gt;ルドルフさんが見付けた遅い部分を書き出し、深町さんがCommon Lispの実装を進める。&lt;/p&gt;

&lt;p&gt;私がmysqlの設定をするもなぜか反映されずに詰まる。ルドルフさんと一緒にやるも数時間やっても解決せず。結局新しいインスタンスを立ち上げたら動いた。my.cnfにsym linkを貼ったのが問題だったよう。/etc/my.cnfの問題ではない。&lt;/p&gt;

&lt;h2 id=&#34;午後-実装を進めつつチューニング:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;午後 実装を進めつつチューニング&lt;/h2&gt;

&lt;p&gt;私の方がどうにかなったのでルドルフさんも実装をすすめる。私はインデックスを張ろうとしてalterが帰ってこなくて諦めたりどうせ使わないけどunicornのワーカー数を増やして気分だけでもスコアを上げたりN+1クエリをJOINで書き直したり。&lt;/p&gt;

&lt;h2 id=&#34;comon-lispの実装がとりあえず終了:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;Comon Lispの実装がとりあえず終了&lt;/h2&gt;

&lt;p&gt;バグは残ってる、と言われつつCL実装をmasterにマージしたのがgitのログを見るに15:28。そこからデバッグ。色々ハマったりライブラリにバグがあったり（深町さんのライブラリだったのでその場でbug fix）してログイン処理が通ったのが17時くらい？そこからベンチマークを走らせるとまたtypoとかのバグがあってちまちま直していくも結局間に合わず0点のままFINISH。&lt;/p&gt;

&lt;h1 id=&#34;反省とか:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;反省とか&lt;/h1&gt;

&lt;p&gt;思ったよりアプリケーションが重厚で再実装に時間取られすぎたなー、が一番。あとMysqlの設定でハマったのは本当にやりたくなかった。&lt;/p&gt;

&lt;p&gt;ベンチマーク走らせるとデータが溜まることに気付かずに大分走らせた後でインデックスを張ろうとしたら20分くらい待っても帰ってこなかったのでインデックスを諦めた。なのでruby実装のスコアも800点くらい。
やろうとしたことはN+1クエリを消すとかuserをメモリに載せるとか。&lt;/p&gt;

&lt;p&gt;かなり苦い思いはしたけどCommon Lispに足りないものとか今後の課題とかも見えたし出た価値はあったと思う。例えばデプロイの度にコンパイルが走るが、コンパイルの重いライブラリを使ってるとデプロイが遅くなるので並列ビルド欲しいよね、とか。ただ、大きな目的だったWeサーバーのチューニングまではいけなかった。&lt;/p&gt;

&lt;p&gt;今年は知り合いと出ちゃったので来年は知らない人とチームを組もうかと。&lt;/p&gt;

&lt;p&gt;運営、出題の方々、お疲れ様でした。来年こそは本戦出ます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rust初心者へのガイド</title>
      <link>http://keens.github.io/blog/2015/09/23/rustwokakutokinochiken</link>
      <pubDate>Wed, 23 Sep 2015 22:43:14 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/09/23/rustwokakutokinochiken</guid>
      <description>

&lt;p&gt;シルバーウィークの進捗が芳しくなかったので雑な記事書いてお茶を濁しとく。rustをそれなりに（といっても1000行くらい）書いて溜まった知見をとりあえず出す。rust1.3時点。&lt;/p&gt;

&lt;p&gt;最初の方で熱く語ってるが多くの人にとって欲しい情報は下の方にあると思う。&lt;/p&gt;

&lt;h1 id=&#34;どんな言語:64b642c20ac103c85395c6858549d1b9&#34;&gt;どんな言語&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;から持ってくるとこんな感じ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;zero-cost abstractions

&lt;ul&gt;
&lt;li&gt;C++くらいの性能と思えばいい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;move semantics

&lt;ul&gt;
&lt;li&gt;他にはない難しい概念。しかしこれのおかげで様々な機能を教授出来る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;guaranteed memory safety

&lt;ul&gt;
&lt;li&gt;move semanticsにより安全でない操作はコンパイル時に弾ける。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;threads without data races

&lt;ul&gt;
&lt;li&gt;move semanticsその他により安全でない操作は(ry&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;trait-based generics

&lt;ul&gt;
&lt;li&gt;継承ベースとは違って開いている。型を定義した後に機能を追加出来る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;pattern matching

&lt;ul&gt;
&lt;li&gt;便利だよねー。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;type inference

&lt;ul&gt;
&lt;li&gt;(超)重量級言語ながらタイプ数は少なめ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;minimal runtime

&lt;ul&gt;
&lt;li&gt;move semanticsのお陰でGCがないので本当に小さい。hello, worldが277KBだった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;efficient C bindings

&lt;ul&gt;
&lt;li&gt;ABI的に良い感じなのでブリッジングコストがほぼない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、ここでは足りないことを書いておくと、現在Mozillaで開発されている言語で、LLVMバックエンドのネイティブコンパイル言語。LLVMにトラウマがある人もバイナリ配布されているので気軽に使える。
rustを使った大きなプロジェクトはレンダリングエンジンの&lt;a href=&#34;https://github.com/servo/servo&#34;&gt;Servo&lt;/a&gt;がある。&lt;/p&gt;

&lt;p&gt;レンダリングエンジンに使われているだけあって対応OS/アーキテクチャは広く、iOSやAndroidでも動く。C FFIもC APIもある。&lt;/p&gt;

&lt;p&gt;コミュニティは非常に活発で、インフラやライブラリは一通り揃った感じはする。マイナー言語を見てきた身としては1000ライラリくらい集まると一通りのことは出来るようになるかな、と思っているがrustは若い言語ながら3000ある。増えるペースも速いので欲しいものはまずあると思っていい。&lt;/p&gt;

&lt;p&gt;長らくAPIの破壊的変更をガンガンやる時期があって、1ヶ月前のhello worldが動かないとかもザラだったが2015年5月に1.0が出て以来見違えたように大人しくなって人が増え始めている。APIについてはunstable, stableだとかのラベルを付けるようになったので安心して使える。&lt;/p&gt;

&lt;p&gt;開発フローについてはFirefoxと同じく6週間毎に上流から新しいバージョンが降ってくる。ので今はもう1.3が出ている。1.0から1.3はコンパイル/実行時のパフォーマンス改善が主。新しい機能はPythonのPEPみたいにRFCで管理している。&lt;/p&gt;

&lt;p&gt;所有権や生存期間など新しい概念を導入していてとっつきにくいがこれらの概念のお陰で並列化しても安全だし、何よりメモリ管理を静的に解決出来るのでGCがなくてパフォーマンスが出るわ安定するわStop the Worldがないわで非常に良い言語。個人的にはデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。&lt;/p&gt;

&lt;p&gt;何指向言語かと言われると難しい。安全指向？継承はないがオブジェクト指向といえばそうだし函数型っぽくなくもない。並行を意識して作ってあるから並行指向と言えなくもない。継承を止めたC++のような所有権と副作用を入れたHaskellのような言語。副作用はバリバリ使うのであまり函数型言語として見ない方が幸せになれると思っている。&lt;/p&gt;

&lt;p&gt;traitがどんなものかというとHaskellの型クラスに（多分）同じ。しかもHaskellの&lt;code&gt;deriving Show&lt;/code&gt;みたいに&lt;code&gt;#[derive(Debug)]&lt;/code&gt;とかも書ける。便利。&lt;/p&gt;

&lt;p&gt;生存期間と所有権がどういうものかというと、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let foo = Foo::new(1);
println!(&amp;quot;{:?}&amp;quot;, foo);
let foo = Foo::new(2);
println!(&amp;quot;{:?}&amp;quot;, foo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;foo&lt;/code&gt;を&lt;code&gt;Foo::new(2)&lt;/code&gt;にバインドした時、&lt;code&gt;Foo::new(1)&lt;/code&gt;は所有者が居なくなるのでその時点で開放される。GCと違う点は、GCはその時点ではゴミになるだけで、次にGCが走った時にようやく開放されるが、rustはその場で開放される、&lt;code&gt;free&lt;/code&gt;を自動で挟む。そうなると、コンパイラは最適化で同じサイズを&lt;code&gt;free&lt;/code&gt;してまたアロケートするのを同じ領域を使うようにする筈だ。これで領域の節約とかアロケーションコストの節約の他に、「今使った」メモリを再利用出来るのでキャッシュに載ったままメモリを使える。ここまでの効率化を「自動で」やってくれるのはrustだけではないかと思っている。&lt;/p&gt;

&lt;p&gt;このように素晴しい言語機能があってコミュニティも活発で安定した言語なので流行ればいいなと思っている。とはいっても気軽に書ける言語ではないのであらゆる所で使われる言語とは思っていない。先に言ったようにデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。goがnext Cならrustはnext C++かな、と。&lt;/p&gt;

&lt;p&gt;rustは難しい。学習曲線が急峻だ。しかし手を動かしてその急峻な崖を乗り越えるだけの価値はある言語だと思うので是非試してみて欲しい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、情報セクションだ。&lt;/p&gt;

&lt;h1 id=&#34;ドキュメント:64b642c20ac103c85395c6858549d1b9&#34;&gt;ドキュメント&lt;/h1&gt;

&lt;h2 id=&#34;入門:64b642c20ac103c85395c6858549d1b9&#34;&gt;入門&lt;/h2&gt;

&lt;p&gt;trplと略される&lt;a href=&#34;https://doc.rust-lang.org/stable/book/&#34;&gt;The Rust Programming Language&lt;/a&gt;を読むととりあえず基本的な概念を一通り学習出来る。&lt;/p&gt;

&lt;h2 id=&#34;書き始めた:64b642c20ac103c85395c6858549d1b9&#34;&gt;書き始めた&lt;/h2&gt;

&lt;p&gt;文法とかをサクっと確認したいなら&lt;a href=&#34;https://doc.rust-lang.org/stable/reference.html&#34;&gt;The Rust Reference&lt;/a&gt;がある。&lt;/p&gt;

&lt;p&gt;標準ライブラリを調べたいなら&lt;a href=&#34;https://doc.rust-blang.org/stable/std/&#34;&gt;APIドキュメント&lt;/a&gt;がある。一見分かりづらいが一番上に検索窓があるので全体検索が出来る。&lt;/p&gt;

&lt;p&gt;コード例が欲しいなら&lt;a href=&#34;http://rustbyexample.com/&#34;&gt;Rust by Example&lt;/a&gt;がある。&lt;/p&gt;

&lt;h1 id=&#34;軽く試す:64b642c20ac103c85395c6858549d1b9&#34;&gt;軽く試す&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://play.rust-lang.org/&#34;&gt;Rust Playground&lt;/a&gt;を使えばWeb上で試せる。質問とか投げる時にサンプルコードをここに載せて渡すと捗る。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:64b642c20ac103c85395c6858549d1b9&#34;&gt;開発環境&lt;/h1&gt;

&lt;h2 id=&#34;コンパイラ:64b642c20ac103c85395c6858549d1b9&#34;&gt;コンパイラ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;から簡単にバイナリ落としてこれる。Macだとbrewでも入った気がする。FreeBSDだとpkgで入る。Debianのパッケージも出来たらしい(&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;)がUbuntuにはまだ(&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;)きてない。すぐ来るだろう。&lt;/p&gt;

&lt;p&gt;しかし後述のracerのためにソースが必要なので別途ソースはダウンロードする必要がある。&lt;/p&gt;

&lt;h2 id=&#34;エディタ:64b642c20ac103c85395c6858549d1b9&#34;&gt;エディタ&lt;/h2&gt;

&lt;p&gt;Emacs, Vim, Atomだったら&lt;a href=&#34;https://github.com/phildawes/racer&#34;&gt;racer&lt;/a&gt;を使う。
racerのソースを持ってきてコンパイルしてエディタプラグインをエディタに入れてrustコンパイラのソース持ってきて2行設定書けば使える。ソース補完と定義元ジャンプがある。ちゃんと型を見て補完候補出してくれるし標準ライブラリのソースにもジャンプ出来るので中々便利。&lt;/p&gt;

&lt;p&gt;gofmtのrust版、&lt;a href=&#34;https://github.com/nrc/rustfmt&#34;&gt;rustfmt&lt;/a&gt;は開発版のコンパイラを持ってこないとコンパイル出来ないので私は諦めているが使いたい人は試すといいと思う。少なくともEmacs向けのプラグインはある。&lt;/p&gt;

&lt;h1 id=&#34;ビルドツール:64b642c20ac103c85395c6858549d1b9&#34;&gt;ビルドツール&lt;/h1&gt;

&lt;p&gt;コンパイラと一緒に配布される(FreeBSDのpkgでは別になってる)Cagroがある。雛形作成、依存解決、ビルド、テスト、ベンチマークなどのタスクが出来る。クロスコンパイルとかも。&lt;/p&gt;

&lt;h1 id=&#34;パッケージ管理:64b642c20ac103c85395c6858549d1b9&#34;&gt;パッケージ管理&lt;/h1&gt;

&lt;p&gt;クライアント側はCargo。セントラルレポジトリ的なのは&lt;a href=&#34;https://crates.io/&#34;&gt;crates.io&lt;/a&gt;。crates.ioに登録されてなくてもCargoはgitから取ってくるとかも出来るので野良パッケージも使える。&lt;/p&gt;

&lt;h1 id=&#34;テスト:64b642c20ac103c85395c6858549d1b9&#34;&gt;テスト&lt;/h1&gt;

&lt;p&gt;関数に&lt;code&gt;#[test]&lt;/code&gt;アノテーションを付ければ良い。つまり、ソースとテストを同じファイルに書ける。結構便利。テスト用ビルドでのみコンパイルされて他のビルドだと無視される（と思う。）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn fib(n:isize) -&amp;gt; isize{
    if n &amp;lt; 2 {
       1 
    }
    else {
        fib(n - 1) + fib(n - 2)
    }
}

#[test]
fn test_fib(){
    assert(fib(1) == 1);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;これ便利とかここ躓いたとか。&lt;/p&gt;

&lt;h1 id=&#34;所有権:64b642c20ac103c85395c6858549d1b9&#34;&gt;所有権&lt;/h1&gt;

&lt;p&gt;分かってたけどやっぱり躓いた。局所的には「あ、ここ所有権必要だわ」とか分かるのだが大域的には難しい。&lt;/p&gt;

&lt;p&gt;例えばボトムアップで作っていくと、小さな関数で所有権が必要だがそれを呼び出そうとしたら呼出元が所有権を持っていなくて困るとか。小さな値とか状態を持たない値だったら&lt;code&gt;clone&lt;/code&gt;して渡すのだがそうでなければ手戻りが発生する。この辺は実際に書いて経験を積むしかなさそう。&lt;/p&gt;

&lt;p&gt;因みに代数的データ型と所有権でも困っている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
enum Value {
   Str(String),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とかすると&lt;code&gt;Str&lt;/code&gt;データコンストラクタがStringの所有権を持っているのでパターンマッチで取り出す時に所有権が貰えず、&lt;code&gt;match{Value::Str(ref str) =&amp;gt; ...,}&lt;/code&gt;と、&lt;code&gt;ref&lt;/code&gt;を使って借りるしかない。&lt;/p&gt;

&lt;p&gt;まだ経験が足りないので困ったまま。&lt;/p&gt;

&lt;h1 id=&#34;サイズ:64b642c20ac103c85395c6858549d1b9&#34;&gt;サイズ&lt;/h1&gt;

&lt;p&gt;rustはコンパイル時にメモリ管理を決定するのでコンパイル時にデータのメモリサイズが決まってないといけない。例えば以下のコードはコンパイルが通らない。Bazにおいて、fooのサイズが決定出来ないと言われる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Foo {

}


struct Bar {
}

impl Foo for Bar {

}


struct Baz {
  foo: Foo
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;Foo&lt;/code&gt;はただのインターフェースの定義であって、データを定義してないので実際にFooを実装したデータ型のサイズが分からないからだ(今後変更がある模様。)。次のようにパラメータにすれば解決出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Baz&amp;lt;T&amp;gt; {
  foo: T
}

impl &amp;lt;T:Foo&amp;gt; Baz&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに元の定義とは変わってデータの時点ではTで、implを書く時にFooに絞っているのは不要な所では不要な条件を付けないようにしているからだろうか。
変な値を入れられて困りそうだが、構造体のフィールドを公開しなければ勝手に値が作られることはなく、impl内に書いたコンストラクタを通してのみ値が作られるので心配無用である。&lt;/p&gt;

&lt;h1 id=&#34;t-と-vec-t-str-と-string:64b642c20ac103c85395c6858549d1b9&#34;&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt;と&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;str&lt;/code&gt;と&lt;code&gt;String&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;使い分けは&lt;a href=&#34;http://qiita.com/kondei/items/4a3496786fce0c1a1b43&#34;&gt;Rustの文字列のガイド - Qiita&lt;/a&gt;を見て欲しいが、相互変換で困ることがあったので。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;String&lt;/code&gt;から&lt;code&gt;&amp;amp;str&lt;/code&gt;に変換する時に「&lt;code&gt;as_slice&lt;/code&gt;はunstable」と言われる。こうしてやれば良いようだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let string = &amp;quot;String&amp;quot;.to_string();
let lent_str = &amp;amp;string[..]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vectorも同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let vector = vec![1, 2, 3];
let lent_slice = &amp;amp;vector[..]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hashmap:64b642c20ac103c85395c6858549d1b9&#34;&gt;HashMap&lt;/h1&gt;

&lt;p&gt;所有権周りで困る。例えば次のコードはコンパイルが通らない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;match hash.get(key) {
    Some(v) =&amp;gt; v,
    None =&amp;gt; {hash.insert(key, default); default}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matchの中でhashがborrowされてると判断されるのでNone節でhashにinsert出来ない。&lt;a href=&#34;http://stackoverflow.com/questions/28512394/how-to-lookup-from-and-insert-into-a-hashmap-efficiently&#34;&gt;ワークアラウンド&lt;/a&gt;
もあるが、どう考えてもイケてないので&lt;a href=&#34;http://blog.rust-lang.org/2015/08/14/Next-year.html&#34;&gt;改善される模様&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;データ型と参照:64b642c20ac103c85395c6858549d1b9&#34;&gt;データ型と参照&lt;/h1&gt;

&lt;p&gt;データ型の中で参照を使いづらい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Value {
   Str(&amp;amp;str),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、怒られる。&lt;code&gt;&amp;amp;str&lt;/code&gt;は自分の物ではないので生存期間が分からないからパラメータで受け取らないといけない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct &amp;lt;&#39;a&amp;gt;Value&amp;lt;&#39;a&amp;gt; {
   Str(&amp;amp;&#39;a str),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、やはり所有権を持っていないので次のようなメソッドを定義出来ない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;&#39;a&amp;gt;Value&amp;lt;&#39;a&amp;gt; {
    fn empty_str() -&amp;gt; &amp;lt;&#39;a&amp;gt; {
        Value::Str(&amp;quot;&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…と思ったらなんか出来ちゃった。今まで使い方が悪かったのかも。これはナシ。&lt;/p&gt;

&lt;h1 id=&#34;モナド:64b642c20ac103c85395c6858549d1b9&#34;&gt;モナド&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/TeXitoi/rust-mdo&#34;&gt;mdo&lt;/a&gt;というdo記法っぽく書けるマクロがあるがクロージャを作るとそのクロージャが変数の所有権を持っていって面倒だったのでそんなに良くなかった。optionモナドに関しては素直にmapとandThenを使った方が良い。&lt;/p&gt;

&lt;h1 id=&#34;try:64b642c20ac103c85395c6858549d1b9&#34;&gt;try!&lt;/h1&gt;

&lt;p&gt;rustのコードでは至る所でResult(Either)型が返ってくる。それに対して毎回パターンマッチするのはやってられない。かといって安全でない&lt;code&gt;unwrap()&lt;/code&gt;を各所で使うのも精神衛生に良くない。Errに対してunwrapを使うとpanicになるが、rustにはpanicをハンドルする方法はない。&lt;/p&gt;

&lt;p&gt;そこで&lt;code&gt;try!&lt;/code&gt;。返り値がErrだったらそのままErrで関数から抜け、Okだったらその値を返すマクロ。多分展開結果はこんな形になってる:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = try!(foo());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = match foo() {
   Ok(v) =&amp;gt; v,
   e @ Err(_) =&amp;gt; return e
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;。&lt;/p&gt;

&lt;p&gt;これの逆、成功したらその値で抜け、ErrだったらErrを返して処理を継続するやつとかオプション版とかも欲しい。&lt;/p&gt;

&lt;h1 id=&#34;最後に:64b642c20ac103c85395c6858549d1b9&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;Lisp処理系作ろうとしたけど完成しなかったのでそっとここに置いときますね&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/kappaLisp&#34;&gt;κLisp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>xhyveでFreeBSD guestを動かす</title>
      <link>http://keens.github.io/blog/2015/09/16/xhyvedefreebsd_guestwougokasu</link>
      <pubDate>Wed, 16 Sep 2015 21:55:25 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/09/16/xhyvedefreebsd_guestwougokasu</guid>
      <description>

&lt;p&gt;久しぶりですね。κeenです。最近はMacでもまともな仮想環境が整ってきたのでFreeBSDでも動かすかーといって試したやつを共有します。&lt;/p&gt;

&lt;p&gt;大部分は&lt;a href=&#34;http://blog.holidayworking.org/entry/2015/06/27/xhyve_%E3%81%A7_FreeBSD_%E3%82%92%E5%8B%95%E3%81%8B%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F&#34;&gt;ここ&lt;/a&gt;を参考にしてますが、ちゃんと動きます。&lt;/p&gt;

&lt;h1 id=&#34;xhyveとは:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;xhyveとは&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pagetable.com/?p=831&#34;&gt;xhyve – Lightweight Virtualization on OS X Based on bhyve | pagetable.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;FreeBSDのBHyVeをMac OS Xに移植したものです。Intel CPUの仮想化フレームワークを使うことで仮想化の実装が（比較的）が楽になるからやろうぜってプロジェクトです。
カーネルレベルでのサポートが必要になりますがyosemiteからHyervisor.frameworkが入っているのでそれが使えます。&lt;/p&gt;

&lt;p&gt;因みに開発はそんなに活発ではないです。&lt;/p&gt;

&lt;h1 id=&#34;動かす:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;動かす&lt;/h1&gt;

&lt;h2 id=&#34;xhyveの準備:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;xhyveの準備&lt;/h2&gt;

&lt;p&gt;FreeBSDのサポートは既にマージされているのでcloneしてきてそのまま使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone git@github.com:mist64/xhyve.git
cd xhyve
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FreeBSDのイメージの入手
イメージは現在10.2が出ているので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;fetch http://ftp.freebsd.org/pub/FreeBSD/releases/VM-IMAGES/10.2-RELEASE/amd64/Latest/FreeBSD-10.2-RELEASE-amd64.raw.xz
unxz FreeBSD-10.2-RELEASE-amd64.raw.xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で入手出来ます。&lt;/p&gt;

&lt;h2 id=&#34;起動スクリプトの準備:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;起動スクリプトの準備&lt;/h2&gt;

&lt;p&gt;参照ブログのままだとハードディスクが読めないのでIMG_HDDにもイメージを指定します。&lt;/p&gt;

&lt;p&gt;名前は何でも良いのですが&lt;code&gt;freebsd.sh&lt;/code&gt;として保存し、&lt;code&gt;chmod +x freebsd.sh&lt;/code&gt;します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh

USERBOOT=&amp;quot;test/userboot.so&amp;quot;
BOOTVOLUME=&amp;quot;FreeBSD-10.2-RELEASE-amd64.raw&amp;quot;
KERNELENV=&amp;quot;&amp;quot;

MEM=&amp;quot;-m 1G&amp;quot;
#SMP=&amp;quot;-c 2&amp;quot;
#NET=&amp;quot;-s 2:0,virtio-net&amp;quot;
#IMG_CD=&amp;quot;-s 3,ahci-cd,/somepath/somefile.iso&amp;quot;
IMG_HDD=&amp;quot;-s 4,virtio-blk,$BOOTVOLUME&amp;quot;
PCI_DEV=&amp;quot;-s 0:0,hostbridge -s 31,lpc&amp;quot;
LPC_DEV=&amp;quot;-l com1,stdio&amp;quot;
#UUID=&amp;quot;-U deadbeef-dead-dead-dead-deaddeafbeef&amp;quot;

build/xhyve -A $MEM $SMP $PCI_DEV $LPC_DEV $NET $IMG_CD $IMG_HDD $UUID -f fbsd,$USERBOOT,$BOOTVOLUME,&amp;quot;$KERNELENV&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;起動:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;起動&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./freebsd.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で起動します。&lt;/p&gt;

&lt;h1 id=&#34;その他:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;FreeBSDのイメージを一杯作りたい人はダウンロードしてきたやつを&lt;code&gt;cp&lt;/code&gt;して使うと良いと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ファイル削除コマンド色々</title>
      <link>http://keens.github.io/blog/2015/07/05/fairusakujokomandoiroiro</link>
      <pubDate>Sun, 05 Jul 2015 14:18:37 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/07/05/fairusakujokomandoiroiro</guid>
      <description>

&lt;p&gt;ファイル生成/削除コマンドについて覚え書き。&lt;/p&gt;

&lt;h1 id=&#34;空ファイル生成:40d37f886c175b93db8e875ce685ddc6&#34;&gt;空ファイル生成&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ touch file
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;サイズ指定でファイル生成:40d37f886c175b93db8e875ce685ddc6&#34;&gt;サイズ指定でファイル生成&lt;/h1&gt;

&lt;p&gt;0埋め/高速なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/zero of=file bs=size count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ランダム/低速なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/random of=file bs=size count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こっちは圧縮されてもサイズが極端に変わらない。&lt;/p&gt;

&lt;h1 id=&#34;ファイルの切り詰め:40d37f886c175b93db8e875ce685ddc6&#34;&gt;ファイルの切り詰め&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ truncate -s size file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記で作ったファイルのサイズを変えたりログファイルを一旦クリアしたりに便利。&lt;/p&gt;

&lt;h1 id=&#34;普通の削除:40d37f886c175b93db8e875ce685ddc6&#34;&gt;普通の削除&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ rm file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただしハードディスク上にはデータは残るのでセキュリティ的には完全ではない。&lt;/p&gt;

&lt;h1 id=&#34;ディスク上からも完全削除:40d37f886c175b93db8e875ce685ddc6&#34;&gt;ディスク上からも完全削除&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ shred -u file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-u&lt;/code&gt;がなかったらファイルを壊すが削除はしない。&lt;/p&gt;

&lt;p&gt;shredが出てこなかったので調べたついでにまとめた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>マクロについて整理してみる</title>
      <link>http://keens.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru</link>
      <pubDate>Sat, 04 Jul 2015 15:34:46 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru</guid>
      <description>

&lt;p&gt;何故Lisperがマクロについて語るのか。Lisperと議論してみても満足のいく答を得た人はそんなにいないと思う。
それはLisper自身便利とは思っていても何が便利なのかを意識してなくて他人に上手く説明出来ないからじゃないかと思った。
ちょっと思いついた範囲でまとめてみる。&lt;/p&gt;

&lt;p&gt;最近ではマクロシステムを持つ言語は珍しくない。Rust, Scala, Template Haskell, Mirahなどなど。最初にCommon Lispのマクロと他の言語のマクロとの違いを少し考えてみたい。&lt;/p&gt;

&lt;h1 id=&#34;unless:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Unless&lt;/h1&gt;

&lt;p&gt;まず、unlessをマクロで書くことを考えてみたい。単純にifにnotをつければいい。&lt;/p&gt;

&lt;p&gt;Common Lispではこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(if (not foo-p)
    bar)

(defmacro unless (cond then)
  `(if (not ,cond)
       ,then))

(unless foo-p
  bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rustだとこうなるだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
if ! isFoo {
    bar;
}

macro_rules! unless {
    ($cond:expr, $then:stmt) =&amp;gt; {{
        if ! $cond {
            $then
        }
    }};
}

unless!(isFoo, {
    bar;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいはmirahだとこうなる。unlessが予約語なので_unlessにした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if ! isFoo
  bar
end

macro def _unless(cond, block:Block)
  quote{
    if ! `cond`
      `block.body`
    end
  }
end

_unless isFoo do
  bar
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみにCだとこう出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;if(! is_foo)
  bar;

#define unless(cond) if(!(cond))

unless(is_foo)
  bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、上のマクロたちを見比べて欲しい。Common LispのマクロとCのマクロは違和感なく新たな制御構造を作れたのに対してRustとMirahはマクロ呼び出しが剥き出しになっている。&lt;/p&gt;

&lt;p&gt;ここで注意して欲しいのはCはともかくCommon Lisp、Rust、Mirahのマクロは全て引数に必要な構文木をとってそのまま用意したテンプレートにあてはめているだけだ。やっていることに違いはない。
何が違うかというとマクロ呼び出しの構文が制御構造の構文と同じか違うかという点だけだ。私の知る範囲ではそのような構文をした言語はLispしかない。だから「Lispの」マクロなのだ。&lt;/p&gt;

&lt;p&gt;もう一つ。どのマクロ定義も十分直感的に読めたと思う。この範囲なら &lt;strong&gt;S式だからマクロが簡単になるということはない&lt;/strong&gt; と思う。別にS式でなくてもquasiquoteがあれば十分読み易いマクロが書ける。&lt;/p&gt;

&lt;h1 id=&#34;case:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Case&lt;/h1&gt;

&lt;p&gt;caseを生成することを考えよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun fun1 (x)
  (let ((y (case x
             ((:foo) (hoge &amp;quot;foo&amp;quot;))
             ((:bar) (hoge &amp;quot;bar!&amp;quot;)))))
    ...))


(defun fun2 (x)
 (let ((y (case x
            ((:foo) (hoge &amp;quot;foo&amp;quot;))
            ((:baz) (hoge &amp;quot;baz!&amp;quot;)))))
   ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように似たような、しかし微妙に違うcaseが必要になったような時に必要だろう。この時、&lt;code&gt;&#39;(:foo (hoge &amp;quot;foo&amp;quot;) :bar (hoge &amp;quot;bar!&amp;quot;))&lt;/code&gt;のようにリテラルでそのまま書いてしまっては抽象化する意味がなくなる。例えばハッシュテーブルにKey-Valueペアを入れて必要な時に入れたり削除したりすればよい。そのようなマクロはこう書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro case-table (key hash)
  `(case ,key
     ,@(loop
          :for k :being :the :hash-key :of hash :using (hash-value v)
          :collect `((,k) ,v))))

(defparameter *table*)
(setf (gethash :foo *table*) &#39;(hoge &amp;quot;foo&amp;quot;))
(setf (gethash :bar *table*) &#39;(hoge &amp;quot;bar!&amp;quot;))

(defun fun1 (x)
  (let ((y (case-table x #.*table*)))
    ...))

(remhash :bar *table*)
(setf (gethash :baz &#39;(hoge &amp;quot;baz!&amp;quot;)))


(defun fun2 (x)
  (let ((y (case-table x #.*table*)))
    ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ハッシュテーブルを受け取ってリストを返す普通のloopマクロの力をマクロ展開時にも使える。また、ハッシュテーブルには&lt;code&gt;&#39;(hoge &amp;quot;foo&amp;quot;)&lt;/code&gt;などのただのリストを突っ込んだがそれをそのままASTとしても使っている。
Common Lispのマクロのもう1つの良いところはマクロの展開時にもCommon Lispの機能がフルで使えるところであり、マクロの引数に受け取るのが構文木でありデータ構造でもあるS式なところだ。ここでは &lt;strong&gt;S式の同図像性が重要なファクターになっている&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(case-table x #.*table*)&lt;/code&gt; で使っている &lt;code&gt;#.&lt;/code&gt; は &lt;em&gt;リードマクロ&lt;/em&gt; といってマクロ展開(コンパイル時)より前(リード時、構文解析時)に動作するマクロだ。このリードマクロはeval-when-readといってリード時に
値を評価する。その結果、&lt;code&gt;case-table&lt;/code&gt;に渡るのが &lt;code&gt;&#39;*table*&lt;/code&gt;というシンボルでなく&lt;code&gt;*table*&lt;/code&gt;に束縛されているハッシュテーブルになる。因みに &lt;em&gt;コンパイラマクロ&lt;/em&gt; というマクロ展開が終わった後に動作するマクロもある。&lt;/p&gt;

&lt;p&gt;マクロ1つではなくマクロの前後に動作するマクロもあってこそ初めて柔軟性を手にしている。あまりその点は議論されてないのではないだろうか。&lt;/p&gt;

&lt;h1 id=&#34;common-lispの設計:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Common Lispの設計&lt;/h1&gt;

&lt;p&gt;さて、各々言語には予約語や~構文というものがあると思う。メソッド定義構文など。Common Lispにもスペシャルフォームという名前で&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm&#34;&gt;25&lt;/a&gt;個存在する。
驚くべきことに、ここまでに出てきたCommon Lispのコードにはスペシャルフォームは3つしか出てこない。ifとletとquoteだ。setfやloop、defun、defmacro、case、defparameterなんかはマクロで出来ている。&lt;/p&gt;

&lt;p&gt;defunまでマクロで出来ているということはユーザがその気になれば関数定義の構文に手を入れたりも出来るということだ。
普通、そんなことをしたら阿鼻叫喚だがCommon Lispなら安全に出来る。マクロもシンボルに束縛されているので新たにマクロで上書きしたシンボルを名前空間にインポートしなければ今まで通りのdefunやloopが使える。&lt;/p&gt;

&lt;p&gt;もう1つ、普段使うものがマクロで出来ているということはマクロを被せてない機能は相当低レベルだということだ。マクロさえ書けば全く新しい言語機能を追加出来るということであり、あるいは&lt;a href=&#34;http://cl21.org/&#34;&gt;全く新しい言語も作れてしまう&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;このような設計はマクロで制御構造までも作れるから出来るのだ。関数定義構文をマクロで定義している言語はLisp以外に私は知らない。&lt;/p&gt;

&lt;h1 id=&#34;メタプログラミングとcommon-lisp:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;メタプログラミングとCommon Lisp&lt;/h1&gt;

&lt;p&gt;ところで、マクロに限らないメタプログラミングについて考えてみたい。メタプログラミングとは、プログラムを書くプログラムを書くことだ。プログラムはテキスト形式のソースコードから実行形式に至るまでの間に様々な中間形式から中間形式に変換される。メタプログラミングはそのどこかの形式を生成することと同義になる。通常、処理系内部で使う形式は変なことをされると困るのであまり外部に公開したくない。メタプログラミングを許すとしても構文解析などのフロントエンドに近い部分になるだろう。&lt;/p&gt;

&lt;p&gt;例えばyaccやlexのようなソースコードジェネレータ、rubyやDのような文字列ベースのメタプログラミングは公開APIであるところのパーサだけを使っているので安全性は高い。しかし文字列だけだと構造がないので書く側はつらい。一応、Common Lispにもread関数とeval関数があるのでCommon Lispのソースコード文字列を吐いてreadしてevalすれば文字列メタプログラミングは出来る。特に嬉しくないのでやらないが。&lt;/p&gt;

&lt;p&gt;次はトークンベースのメタプログラミングがある。Cのプリプロセッサなど。Common Lispでもリードマクロで可能だ。例えば正規表現リテラルを作ったりとかの例がある。&lt;/p&gt;

&lt;p&gt;次はASTベースのメタプログラミングがある。マクロだ。これは今まで見てきた。&lt;/p&gt;

&lt;p&gt;これより先はメタプログラミングとはあまり言わない気がする。JITと呼ぶのではないか。Common Lispにもeval関数やcompile関数があるからそういうことも出来る。正規表現ライブラリなんかが使っている。&lt;/p&gt;

&lt;p&gt;私が言いたいのはCommon Lispにはメタプログラミングの機構が一杯あるということではない。read, eval, compile…。気付いたかもしれないが、LispはLisp自身で出来ている。
Lispを書くとき、Lispを書いてるかもしれないしLispを構成するLispを書いているかもしれない。いくらでもメタプログラミングが出来るということだ。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;何やらCommon Lisp賛美歌になってしまったが一応まとめておく。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;簡単なマクロ定義ならS式である必要はない&lt;/li&gt;
&lt;li&gt;複雑なマクロ定義ならS式であると書き易い。恐らく他の構文でも書けないことはない。&lt;/li&gt;
&lt;li&gt;マクロ呼び出し構文はS式でないと重大な違いがある。&lt;/li&gt;
&lt;li&gt;マクロ以外にもリードマクロやパッケージなど他の言語機能があってこそマクロが活きる。&lt;/li&gt;
&lt;li&gt;言語機能だけでなくマクロを前提とした設計も重要である。&lt;/li&gt;
&lt;li&gt;LispはS式で出来ている以前にLispで出来ている。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>あなたの知らないShebang</title>
      <link>http://keens.github.io/blog/2015/06/26/anatanoshiranaishebang</link>
      <pubDate>Fri, 26 Jun 2015 23:24:44 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/26/anatanoshiranaishebang</guid>
      <description>

&lt;p&gt;κeenです。最近は何故かBlack君って呼ばれます。Shebangの書き方にはいくつかあって、それを利用したふと面白い方法を思い付いたので共有を。&lt;/p&gt;

&lt;p&gt;さて、ご存知Shebangといえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにファイルの1行目が&lt;code&gt;#!&lt;/code&gt;から始まっているとシェルがそれ以降の文字列を実行可能ファイルのパス名として捜して実行してくれるものですが、実は&lt;code&gt;#!&lt;/code&gt;は唯一のフォーマットではありません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#!&lt;/code&gt;がデファクトになる前なのかそもそもシェルにコメントがなかった時代のものなのかは知りませんが昔は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;: /bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;:&lt;/code&gt;で始めていたらしいです。因みに&lt;code&gt;:&lt;/code&gt;は「何もしないコマンド」です。実質的にコメントとして扱ったり副作用のある変数展開だけを行なったりプログラマティックコメントアウトだったりの用途で使われてます。&lt;/p&gt;

&lt;p&gt;さて、シェルは全て文字列なのでクォートしてもしなくても構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてもちゃんと動いてくれます。なぜわざわざクォートするかというと&lt;a href=&#34;http://keens.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/&#34;&gt;割と処理系ポータブルなCommon Lisp実行可能ファイルを作る | κeenのHappy Hacκing Blog&lt;/a&gt;のように別の言語のスクリプトとして実行される時に文字列リテラルになってくれると単純に無視されるので互換性が高まるのです。&lt;/p&gt;

&lt;p&gt;ということで完全版ポータブルなCommon Lisp実行可能ファイルはこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;

#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abclとcclが利用可能になりました。あとCIMも捜すようにしました。roswellは作者に訊いて下さい。&lt;/p&gt;

&lt;p&gt;ちなみに、shebangの解釈はシェルに依存するのですが、B Shell, csh, tcsh, dash, Bash, zshで動作確認しました。古い機能なので新しいシェルほど切り捨てている可能性があったのですがBashやzshが大丈夫だったので良かったです。
一応非推奨な気がしますがこれしか方法がないので仕方ないですね。&lt;/p&gt;

&lt;p&gt;ということでみなさんスクリプト書きましょう。&lt;/p&gt;

&lt;h1 id=&#34;追記:97aff0076544159c37193ad080a89d0a&#34;&gt;追記&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangの解釈はシェルじゃなくてOSのexec()がやります。で、#!や認識できるバイナリ以外は、exec()がエラーを返した後でシェルがファイルを見て、テキストファイルならシェルスクリプトとして実行ってやってます。なので先頭が:の場合は(続&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614551978526445570&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangとしてではなく、シェルがシェルスクリプトとして読んでるだけなので、その後に/bin/shとか書いてあっても関係ないはず (シェルによってはそこも見るかもしれませんが)&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614552151759589376&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということで実験してみたところ、先頭の&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;はどのシェルも読み飛ばす模様(つまり、&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/usr/bin/ruby&amp;quot;&lt;/code&gt;と書いてもrubyが実行される訳ではない)。&lt;/p&gt;

&lt;p&gt;で、先程の 完全版から&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;を取り除いて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても動いたのでこれが最終版ということになります。&lt;/p&gt;

&lt;p&gt;大学の講究でMINIX本やったどころかexecのところ自分の担当だったのに恥かしい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Shell Scriptを書くときのテクニック10選</title>
      <link>http://keens.github.io/blog/2015/06/17/shell_scriptwokakutokinikiwotsuketaikoto</link>
      <pubDate>Wed, 17 Jun 2015 22:12:25 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/17/shell_scriptwokakutokinikiwotsuketaikoto</guid>
      <description>

&lt;p&gt;κeenです。LLで書かれた動作のもっさりしてるコマンドラインツールよりシェルスクリプトが好きです。&lt;/p&gt;

&lt;p&gt;しかしシェルスクリプトを書く時にはハマり所も多いです。ということでハマりそうなところと対処法を共有しますね。&lt;/p&gt;

&lt;h1 id=&#34;1-変数は基本クォート:5e57d8f93a32720e126e1053ccd91901&#34;&gt;1. 変数は基本クォート&lt;/h1&gt;

&lt;p&gt;変数には空白が入り得ます（特にパス名とか）。あるいは空である可能性もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mv file1 file2 $target_dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;$target_dir&lt;/code&gt;が空だった時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mv file1 file2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまいます。file2が上書きされますね。恐ろしい。&lt;/p&gt;

&lt;p&gt;クォートで括っておけば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mv file1 file2 &amp;quot;$target_dir&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mv file1 file2 &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり辺なディレクトリに書き込もうとしてエラーになります。まだマシですね。&lt;/p&gt;

&lt;p&gt;基本、と書いたのはクォートしたくない場合もあるからです。例えばこんな時ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;items=&amp;quot;foo bar baz&amp;quot;
for item in $items
do
    echo &amp;quot;$item&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変数展開の後にトークン分割が行なわれるので空白で区切れば複数のトークンを1つの変数に入れられます。&lt;/p&gt;

&lt;h1 id=&#34;2-eオプションをつけよう:5e57d8f93a32720e126e1053ccd91901&#34;&gt;2. -eオプションをつけよう&lt;/h1&gt;

&lt;p&gt;シェルには例外がありません。何かが失敗しても走り続けます。これは時に迷惑な挙動です。しかし &lt;code&gt;-e&lt;/code&gt;オプションをつけると0以外の終了ステータスが出た瞬間スクリプトが止まるようになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-e&lt;/code&gt;オプションを有効にするには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
set -e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば良いです。0以外のステータスで終了し得るコマンドの例外ハンドル的なことをしたければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;trying_command || true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば確実に0で終了します。&lt;/p&gt;

&lt;p&gt;また、スクリプトの途中で&lt;code&gt;-e&lt;/code&gt;を切り替えたければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
set -e
# -eが有効
set +e
# -eが無効
set -e
# -eが有効
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;set -e&lt;/code&gt;と&lt;code&gt;set +e&lt;/code&gt;で制御出来ます。&lt;/p&gt;

&lt;h1 id=&#34;3-カレントディレクトリはスクリプトを起動した場所:5e57d8f93a32720e126e1053ccd91901&#34;&gt;3. カレントディレクトリはスクリプトを起動した場所&lt;/h1&gt;

&lt;p&gt;例えば ~/Shell/hoge.shにこう書いたとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
cat ./hoge.sh
pwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それを実行するとこうなります&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/Shell
$ sh hoge.sh
#!/bin/sh
cat ./hoge.sh
pwd
/home/kim/Shell
$ cd ../
$ sh Shell/hoge.sh
hoge.sh: no such file or directory
/home/kim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なのでシェルスクリプト内での相対パスは基本的に信用出来ません。&lt;/p&gt;

&lt;p&gt;スクリプトの相対でパスを指定したいならこうしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
ROOT=&amp;quot;$(cd $(dirname $0); pwd)&amp;quot;
cat &amp;quot;$ROOT/hoge.sh&amp;quot;
pwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$(cd $(dirname $0); pwd)&lt;/code&gt; がキモです。 $0には起動スクリプトが入ってます。 &lt;code&gt;$ ./hoge.sh&lt;/code&gt;と起動したなら &lt;code&gt;./hoge.sh&lt;/code&gt;が、 &lt;code&gt;$ ../hoge.sh&lt;/code&gt; なら &lt;code&gt;../hoge.sh&lt;/code&gt;が。そのスクリプトがあるディレクトリに移動(&lt;code&gt;cd $(dirname $0)&lt;/code&gt;) して&lt;code&gt;pwd&lt;/code&gt;するとスクリプトのあるディレクトリの絶対パスがとれます。&lt;/p&gt;

&lt;p&gt;因みにこのイディオムはスクリプトにリンクを張られると困ります。 &lt;code&gt;readlink(1)&lt;/code&gt; を使う流儀もあるのですがreadlinkがMacとLinuxで全然違い、互換性を保てないのでおすすめしません。&lt;/p&gt;

&lt;h1 id=&#34;4-sudo-command-fileでパーミッションエラー:5e57d8f93a32720e126e1053ccd91901&#34;&gt;4. sudo command &amp;gt;&amp;gt; fileでパーミッションエラー&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;) を使った時にファイルに書き込んでるのは &lt;code&gt;command&lt;/code&gt;ではなくてシェルなのでシェルのアクセス権限でパーミッションエラーが出ます。sudoして書き込みたいなら&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo command &amp;gt; file&lt;/code&gt; ではなく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ command | sudo tee file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を、&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo command &amp;gt;&amp;gt; file&lt;/code&gt; ではなく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ command | sudo tee -a file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を使いましょう。&lt;/p&gt;

&lt;p&gt;関連して、&lt;code&gt;echo&lt;/code&gt;は外部コマンドではなくシェルの組込みコマンドなのでsudoに渡すことが出来ません。これもファイルに書き込む目的ならechoとsudo teeをパイプで繋ぎましょう。&lt;/p&gt;

&lt;h1 id=&#34;5-sudoのパスワードを渡せない:5e57d8f93a32720e126e1053ccd91901&#34;&gt;5. sudoのパスワードを渡せない&lt;/h1&gt;

&lt;p&gt;スクリプト内でsudoを扱うのは少しテクニックが必要になります。sudoに-Sを付けると標準入力からパスワードを読むようになります。かといってソースにベタ書きする訳にはいきません。
ということで、こうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;printf &amp;quot;password: &amp;quot;
read password
echo &amp;quot;$password&amp;quot; | sudo -S command
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ユーザにパスワードを要求し、メモリに保存。必要な時にsudoに渡すという流れです。&lt;/p&gt;

&lt;p&gt;シェルに依ってはreadに-sをつけることでエコーバックしなくなるのでディスプレイにパスワードが流れてくることはありません。未確認ですがdash(Debian系の/bin/sh)では出来なくてB shell(BSD系の/bin/sh)やBash、Zshなどの拡張POSIXシェルだと出来そうです。&lt;/p&gt;

&lt;p&gt;余談ですが改行なしの印字に&lt;code&gt;echo -n&lt;/code&gt;は使えません。&lt;code&gt;-n&lt;/code&gt; シェルによってはオプションを認識しないので。printf(1)はPOSIXにあるのでポータブルに使えます。&lt;/p&gt;

&lt;p&gt;因みにパスワードが初期化されてないならユーザに訊く、というのはこういう関数を実装すれば良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;password(){
    if ! ${password+:} false
    then
        printf &amp;quot;password: &amp;quot;
        read -s password
    fi
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;6-sudoのパスワードを渡しつつ標準出力も渡したい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;6. sudoのパスワードを渡しつつ標準出力も渡したい&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;{ echo &amp;quot;$password&amp;quot; ; cat } | sudo -S command
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しましょう。&lt;/p&gt;

&lt;h1 id=&#34;7-リモートでスクリプトを実行したい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;7. リモートでスクリプトを実行したい&lt;/h1&gt;

&lt;p&gt;一旦scpでスクリプトを送ってから実行？そんな面倒なことしたくありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote &amp;lt;&amp;lt;SHELL
#  some script
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で実行出来ます。これはログインシェルで実行します。ログインシェル如何に関わらずshで実行したいなら(ログインシェルがcshとかnologinとかは割とありえる)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
#  some script
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としましょう。&lt;/p&gt;

&lt;h1 id=&#34;8-リモートでsudoのパスワードを渡したい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;8. リモートでsudoのパスワードを渡したい&lt;/h1&gt;

&lt;p&gt;先のテクニックがそのまま使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;printf &amp;quot;password: &amp;quot;
read password
ssh user@remote sh &amp;lt;&amp;lt;SHELL
echo &amp;quot;$password&amp;quot; | sudo -S command
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クォート無しのヒアドキュメントのシェル変数の展開はローカルで行なわれるのでローカルにある変数がそのまま参照出来ます。&lt;/p&gt;

&lt;h1 id=&#34;9-リモートにローカルに置いてあるファイルを送りたい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;9. リモートにローカルに置いてあるファイルを送りたい&lt;/h1&gt;

&lt;p&gt;scpでも良いですがroot loginを許可してないと設定ファイルを/etcに置けないなどと不都合が生じます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt;&amp;gt; some_remote_file
$(cat local_file)
EOF
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは少し解説が必要でしょうか。&lt;/p&gt;

&lt;p&gt;まず、先程も出てきた&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですが普通のヒアドキュメントなので中の変数やコマンド置換を展開します。ということでリモートで実行されるのは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt;&amp;gt; some_remote_file
# the content of
# local_file
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。そしてcatのヒアドキュメントはクォート付きなのでlocal_fileの中身がさらに変数展開されることはありません。&lt;/p&gt;

&lt;p&gt;勿論、root権限で書き込みたかったら先程までのテクニックを組み合わせて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
{ echo &amp;quot;$password&amp;quot; ; cat &amp;lt;&amp;lt;&#39;EOF&#39; } | sudo -S tee  some_remote_file
$(cat local_file)
EOF
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として下さい.&lt;/p&gt;

&lt;h1 id=&#34;10-リモートにあるファイルを編集したい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;10. リモートにあるファイルを編集したい&lt;/h1&gt;

&lt;p&gt;sed(1)を使いましょう。あるいは、sedだと辛いならローカルでファイルを編集、diffをとってpatch(1)を使いましょう。diffの送り方はもう分かりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
cat &amp;lt;&amp;lt;&#39;EOF&#39; |  patch
$(cat file.diff)
EOF
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;いかがでしょうか。テクニックさえ抑えればシェルスクリプトは料理人だか板前だか知りませんが流行に流されるツールにも負けない力があると思います。動作も速い。
みなさんシェルスクリプト書きましょうね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustでstructのmutableなfieldあれこれ</title>
      <link>http://keens.github.io/blog/2015/06/14/rustdestructnomutablenafieldarekore</link>
      <pubDate>Sun, 14 Jun 2015 17:53:11 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/14/rustdestructnomutablenafieldarekore</guid>
      <description>

&lt;p&gt;κeenです。人々にRustを薦めておきながら本人は昨日ようやく入門しました。その時に困ったことをメモ。タイトルがルー語になってますが気にしない。&lt;/p&gt;

&lt;p&gt;因みにこれはRust 1.0の情報です。&lt;/p&gt;

&lt;h1 id=&#34;導入:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;導入&lt;/h1&gt;

&lt;p&gt;Rustを知らない人のために説明すると、Rustの値はデフォルトでイミュータブルです。デフォルトで、というのはもちろんミュータブルにすることも出来ます。
標準ライブラリにも値がイミュータブルであることを要求するものもあります。
そしてミュータビリティは&lt;code&gt;mut&lt;/code&gt;として型にも現れます。厳密に同じかは知りませんが&lt;code&gt;const&lt;/code&gt;の逆、と思えばいいでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Point {
    x: isize,
    y: isize
}

fn double(p: &amp;amp;mut Point) {
    p.x = p.x * 2;
    p.y = p.y * 2;
}

fn main(){
    let mut p1 = Point{x: 1, y: 2};
    let p2 = Point{x: 1, y: 2};
    double(&amp;amp;mut p1);
    double(&amp;amp;mut p2); // error! p2 is immutable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イミュータビリティは継承します。親のstructがイミュータブルなら子もイミュータルになります。因みにフィールドに&lt;code&gt;mut&lt;/code&gt;を指定することは出来ないようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::collections::HashMap;

struct IntHashMap {
    hash: HashMap&amp;lt;isize, isize&amp;gt;
}
fn main(){
    let h = IntHashMap{hash: HashMap::new()};
    h.hash.insert(1, 2);        // error! h.hash is immutable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、少し本筋とずれますがtraitについて。他の言語でいうインターフェースのようなものです。今回これで困ったので。&lt;/p&gt;

&lt;p&gt;例えばHTTPライブラリの&lt;a href=&#34;http://hyper.rs/hyper/hyper/server/trait.Handler.html&#34;&gt;hyper&lt;/a&gt;では次のようなトレイトを実装しているstructをrequest handlerとして登録できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Handler: Sync + Send {
    fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;);

    fn check_continue(&amp;amp;self, _: (&amp;amp;Method, &amp;amp;RequestUri, &amp;amp;Headers)) -&amp;gt; StatusCode { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを見て下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self&lt;/code&gt;に&lt;code&gt;mut&lt;/code&gt;がついてませんね。つまりhandlerはイミュータブルな値として渡されます。例えば先の例のようにフィールドにハッシュマップを持っていても更新出来ません。ちょっと困りますね。&lt;/p&gt;

&lt;h1 id=&#34;cell-refcell:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;Cell/RefCell&lt;/h1&gt;

&lt;p&gt;ということでフィールドにミュータビリティを入れるのが &lt;code&gt;std::cell::{Cell, RefCell}&lt;/code&gt; です。この辺のブログを参考に。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://saneyukis.hatenablog.com/entry/2014/05/30/230351&#34;&gt;#rustlang における構造体のmutabilityと&lt;code&gt;Cell/RefCell&lt;/code&gt; - snyk_s log&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;で、喜び勇んで使ったのですが次なるエラーが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyHandler {
    cache: RefCell&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;
}

impl Handler for MyHandler {
    fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;){
        ....
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;the trait `core::marker::Sync` is not implemented for the type `core::cell::UnsafeCell&amp;lt;...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうも、hyperは複数スレッドでも動かせるのでハンドラにスレッドセーフであることが要求されるようです。そしてRustコンパイラはRefCellがスレッドセーフでない事を知っているのでコンパイルを弾きます。怖いですね。&lt;/p&gt;

&lt;h1 id=&#34;mutex:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;Mutex&lt;/h1&gt;

&lt;p&gt;無理っぽいので最早別の手段を捜し始めます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;キャッシュ用のアクター走らせるのが良い気がしてきた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/609471732970209280&#34;&gt;2015, 6月 12&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これはちょっと無理がありそうですね。&lt;/p&gt;

&lt;p&gt;しかし、別の方法があるようでした。&lt;a href=&#34;https://doc.rust-lang.org/std/sync/struct.Mutex.html&#34;&gt;std::sync::Mutex&lt;/a&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyHandler {
    cache: Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで&lt;code&gt;lock().unwrap()&lt;/code&gt;するだけで使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut cache = self.cache.lock().unwrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにロックの解除は不要です。Rustコンパイラは値の生存期間を知っているので値がこれ以上使われなくなった箇所にコンパイラがunlockを挟みます。(正確に言うとdrop(デストラクタ)が挿入され、dropがリソースの開放を行なう)&lt;/p&gt;

&lt;h1 id=&#34;まとめ:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;rustのイミュータビリティは継承する&lt;/li&gt;
&lt;li&gt;structのfieldに直接&lt;code&gt;mut&lt;/code&gt;は指定出来ない&lt;/li&gt;
&lt;li&gt;シングルスレッドでミュータブルなフィールドが欲しいなら&lt;code&gt;Cell&lt;/code&gt;/&lt;code&gt;RefCell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;マルチスレッドなら&lt;code&gt;Mutex&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでOpenCV 3.0と戯れる</title>
      <link>http://keens.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru</link>
      <pubDate>Sun, 07 Jun 2015 16:56:51 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru</guid>
      <description>

&lt;p&gt;κeenです。先日OpenCV 3.0がリリースされましたね。
ちょっと触ってみようと思ったのですが公式バインディングがC++、C、Java、Pythonと中々つらい言語ばっかりなので扱いやすいClojureから触った時のメモです。&lt;/p&gt;

&lt;p&gt;2系とはAPIが変わってる部分もあるらしく、苦労しました。
UbuntuでやってるのでMacの人は適当に読み替えて下さい。&lt;/p&gt;

&lt;h1 id=&#34;準備:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;準備&lt;/h1&gt;

&lt;h2 id=&#34;opencv:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;OpenCV&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://opencv.org/&#34;&gt;公式&lt;/a&gt;からOpenCV 3.0をダウンロードしてきましょう。展開してからは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-3.0.0
$ cmake .
$ make -j4
$ sudo make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストールまでしてくれます。&lt;/p&gt;

&lt;h2 id=&#34;imshow:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;ImShow&lt;/h2&gt;

&lt;p&gt;どうも3.0からHighguiというQtベースのGUIツール群のJavaバインディングが作られなくなったそうです。Swing使えと。&lt;/p&gt;

&lt;p&gt;ということでOpenCVとSwingのブリッジしてくれる軽いライブラリが&lt;a href=&#34;https://github.com/master-atul/ImShow-Java-OpenCV&#34;&gt;ImShow-Java-OpenCV&lt;/a&gt;
です。.javaファイル1枚なので本当に軽いです。&lt;/p&gt;

&lt;p&gt;.jarもレポジトリに入ってるのですがソースコードより古いらしく、自分でビルドする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:master-atul/ImShow-Java-OpenCV.git
$ cd ImShow-Java-OpenCV/ImShow_JCV/src
$ javac com/atul/JavaOpenCV/Imshow.java
$ jar -cf Imshow.jar com/atul/JavaOpenCV/Imshow.class
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lein-プロジェクト:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;lein プロジェクト&lt;/h2&gt;

&lt;p&gt;Clojureのプロジェクト管理ツールの&lt;a href=&#34;http://leiningen.org/&#34;&gt;Leiningen&lt;/a&gt;を使います。知らない人は適当にググって下さい。&lt;/p&gt;

&lt;p&gt;まずプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein new opencv-play
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んで、mavenでいうところのpom.xmlにあたるproject.cljをいじります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-play
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]])
$ edit project.clj
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]
                 [cider/cider-nrepl &amp;quot;0.9.0-SNAPSHOT&amp;quot;]]
  :jvm-opts [&amp;quot;-Djava.library.path=./lib&amp;quot;]
  :resource-paths [&amp;quot;./lib/opencv-300.jar&amp;quot;
                   &amp;quot;./lib/Imshow.jar&amp;quot;]
  :injections [(clojure.lang.RT/loadLibrary org.opencv.core.Core/NATIVE_LIBRARY_NAME)])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしたら先程のライブラリ達を配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir lib
$ cp /usr/local/share/OpenCV/java/* lib
$ cp /path/to/ImShow-Java-OpenCV/ImShow_JCV/src/Imshow.jar lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにlenaも呼びましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir img
$ cp /path/to/src/of/opencv-3.0.0/samples/data/lena.jpg img
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;遊ぶ:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;遊ぶ&lt;/h1&gt;

&lt;p&gt;準備完了ってことでREPLを起動しましょう。ちょっと遅いですが我慢。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein repl
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
nREPL server started on port 52301 on host 127.0.0.1 - nrepl://127.0.0.1:52301
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_25-b17
    Docs: (doc function-name-here)
          (find-doc &amp;quot;part-of-name-here&amp;quot;)
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このままREPLを使ってもいいですが私はEmacsから&lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt;でnREPLにつなぎます。
REPLでも補完は効くのでEmacsやらのエディタの設定が面倒ならこのままでも十分ですよ。&lt;/p&gt;

&lt;p&gt;まずは画像のロードから。2系とは違ってImagecodecを使うようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.imgcodecs Imgcodecs])
org.opencv.imgcodecs.Imgcodecs
user&amp;gt; (def lena (Imgcodecs/imread &amp;quot;img/lena.jpg&amp;quot;))
#&#39;user/lena
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いじる前に表示してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [com.atul.JavaOpenCV Imshow])
com.atul.JavaOpenCV.Imshow
user&amp;gt; (def is (Imshow. &amp;quot;Lena&amp;quot;))
#&#39;user/is
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/show-lena.png&#34; alt=&#34;lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;よしよし。表示されましたね。ではこの辺を参考に顔認識してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/woxtu/items/bf39e3d53cbf60396d2c&#34;&gt;Clojure - 二次元絵の顔を検出する - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずは必要なパッケージの読み込み&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core Mat CvType])
org.opencv.core.CvType
user&amp;gt; (import [org.opencv.imgproc Imgproc])
org.opencv.imgproc.Imgproc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前処理のグレースケール変換からヒストグラムの均一化まで一気にやってしまいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def buffer (Mat. 512 512 CvType/CV_8UC3))
#&#39;user/buffer
user&amp;gt; (Imgproc/cvtColor lena buffer Imgproc/COLOR_RGB2GRAY)
nil
user&amp;gt; (Imgproc/equalizeHist buffer buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで一旦画像の確認。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/gray-hist-lena.png&#34; alt=&#34;gray-hist-lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ふむふむ。ではでは顔を認識しますか。&lt;/p&gt;

&lt;p&gt;まずは色々準備します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core MatOfRect])
org.opencv.core.MatOfRect
user&amp;gt; (import [org.opencv.objdetect CascadeClassifier])
org.opencv.objdetect.CascadeClassifier
user&amp;gt; (def faces (MatOfRect.))
#&#39;user/faces
user&amp;gt; (def classifier (CascadeClassifier.))
#&#39;user/classifier
user&amp;gt; (.load classifier &amp;quot;/usr/local/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml&amp;quot;)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに分類器のデータのロードは成功がtrueで失敗がfalseだそうです。例外投げないんですね。ハマった。パス名に&lt;code&gt;~&lt;/code&gt;を使うと(ホームを省略表記すると)ロードに失敗するようなのでお気をつけて。&lt;/p&gt;

&lt;p&gt;それでは実行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.detectMultiScale classifier buffer faces)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、顔の位置がとれたので画像に重ねるのですがここではSwing(AWT)の描画を使ってみましょう。
OpenCVの描画は画像に描画するのでファイルに書き出しても残っているのに対してSwingのだと表示しているフレームに描画するので書き出した画像には残りません。また、リフレッシュすれば消えるのでインタラクティブに実験するのに向いてます。&lt;/p&gt;

&lt;p&gt;一旦準備。フレームをレナの元画像に戻しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [java.awt Rectangle Color])
java.awt.Color
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImshowのWndowというパブリックなメンバにJFrameが入ってるのでそれを操作します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def g2 (.getGraphics (.Window is)))
#&#39;user/g2
user&amp;gt; (.setColor g2 Color/GREEN)
nil
user&amp;gt; (doseq [face (.toList faces)]
  (let [rect (Rectangle.)]
    (do
      (.setRect rect (.width face) (.height face) (.x face) (.y face))
      (.draw g2 rect))))
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/face-recognized-lena.png&#34; alt=&#34;face recognized lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;パチパチパチ&lt;/p&gt;

&lt;p&gt;因みに四角形を消すには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で十分です。ミスっても何回でもやり直せますね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;因みに3.0のドキュメントが探しづらいのですが、masterにあるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.opencv.org/master/&#34;&gt;OpenCV: OpenCV&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OpenCVをインタラクティブに扱えると楽しいのでみなさんClojure使いましょう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCOと例外ハンドル</title>
      <link>http://keens.github.io/blog/2015/05/31/tcotoreigaihandoru</link>
      <pubDate>Sun, 31 May 2015 21:02:08 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/31/tcotoreigaihandoru</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;http://KeenS.github.io/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou&#34;&gt;先日のエントリー&lt;/a&gt;の最後でループ内で例外ハンドルをすると極端に遅くなるということを書きましたが、それについて。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/604235677337714689&#34;&gt;2015, 5月 29&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; うーん、ちょっと例外のことは詳しくないんですが、予想だと例外ハンドラをループ内にいれると毎回スタックに積むんで外す操作がはさまることになるのでレジスタで完結してるようなループ処理だと露骨に遅くなるかもしれません&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604537509771501569&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; あーありえますね。ジャンプで済むところを戻ってきてスタックに積んだのを除去しないといけませんからね。ちょっと手元にマシンが無いのですがネイティブコードで実験してみますー&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604540519188815872&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; ocamlでも例外ハンドラのはさみ方で末尾再帰になったり、ならなかったりするというのは聞いたことがあるので多分あたりな気がします&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604545844000325632&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということで実験してみましょう。&lt;/p&gt;

&lt;p&gt;次のような何がしたいのか分からないループのベンチマークを取ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は無限ループではなく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uncaught exception: Subscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、境界外アクセスの例外が出ます。因みにSubscripは添字って意味だそうです。&lt;/p&gt;

&lt;p&gt;これではベンチマークがとれないので、例外が起きたらループを抜けるようにしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Subscript =&amp;gt; ()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 5 ms/1calls
  [Average] 5.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一瞬ですね。では、末尾呼び出し位置でhandleしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(100, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
        handle Subscript =&amp;gt; ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 1729 ms/1calls
  [Average] 1729.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふーむ。やはり大分遅くなってますね。しかしループ内で例外をハンドルした所為かもしれないのでループ内で非末尾位置で例外をハンドルしてみます。大域脱出に例外使いますがまあ、パフォーマンスに問題ないでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;exception Exit
val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1)
        handle Subscript =&amp;gt; raise Exit;
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Exit =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 11 ms/1calls
  [Average] 11.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やはり多少は遅くなってますが末尾位置の時のように極端には遅くなってないようです。&lt;/p&gt;

&lt;p&gt;最後に非末尾再帰ループの速度を測っておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        1 + (loop ())
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Subscript =&amp;gt; 0
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 403 ms/1calls
  [Average] 403.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思ったより遅いですね。ループか末尾例外ハンドルかというと末尾例外ハンドルに近いスコア。&lt;/p&gt;

&lt;h1 id=&#34;考察:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;考察&lt;/h1&gt;

&lt;p&gt;末尾位置で例外をハンドルすると遅くなる原因はTCOが効かないから、で合ってそうです。&lt;/p&gt;

&lt;p&gt;しかしそれにしても遅いですね。例外ハンドラをスタックに積むのが1関数呼び出しくらいならせいぜい倍くらいの遅さで済む筈です。
もしかしたらループ展開とかの外の最適化も掛からなくなるのかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;結論:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;結論&lt;/h1&gt;

&lt;p&gt;例外をハンドルする時は位置に気をつけましょうね。&lt;/p&gt;

&lt;h1 id=&#34;付録a:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;ベンチマーカはこんなコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure Benchmark =
struct
fun repeat 0 f = ()
  | repeat n f =  (f ();repeat (n - 1) f)
 
fun bench n f = let
    val startTime = Time.now ()
    val _ = repeat n f
    val endTime = Time.now ()
in
    Time.toMilliseconds (Time.-(endTime, startTime))
end
 
fun benchmark name n f = let
    val time = bench n f
in
    print (name ^ &amp;quot;\n&amp;quot;);
    print (&amp;quot; Time:\n&amp;quot;);
    print (&amp;quot;    [Total] &amp;quot; ^ (LargeInt.toString time) ^ &amp;quot; ms/&amp;quot; ^ (Int.toString n) ^ &amp;quot;calls\n&amp;quot;);
    print (&amp;quot;  [Average] &amp;quot; ^ (Real.toString((Real.fromLargeInt time) / (Real.fromInt n))) ^ &amp;quot; ms/call\n&amp;quot;)
end

fun nChars n char = CharArray.vector(CharArray.array(n, char))

fun toWidth width str = let
    val len = String.size str
in
    if len &amp;lt; width
    then str ^ (nChars (width - len) #&amp;quot; &amp;quot;)
    else str
end

fun histLine width base value =
  (nChars (Int.fromLarge(width * value div base)) #&amp;quot;*&amp;quot;) ^ &amp;quot;\n&amp;quot;

fun benchset name n fs = let
    val res = List.map (fn (label, f) =&amp;gt; (label, bench n f)) fs
    val max = List.foldl (fn ((_, time), m) =&amp;gt; LargeInt.max(time, m)) 0 res
    val maxLen = List.foldl (fn ((label, _), m) =&amp;gt; Int.max(String.size label,  m)) 0 fs
in
    print &amp;quot;name:\n&amp;quot;;
    print ((nChars ((String.size &amp;quot; &amp;quot;) + maxLen) #&amp;quot;-&amp;quot;) ^ &amp;quot;+&amp;quot; ^ (nChars ((String.size &amp;quot;|&amp;quot;) +  50) #&amp;quot;-&amp;quot;) ^ &amp;quot;\n&amp;quot;);
    app (fn (label, time) =&amp;gt; print(&amp;quot; &amp;quot; ^ (toWidth maxLen label) ^ &amp;quot;|&amp;quot; ^(histLine (50:LargeInt.int) max time))) res;
    print ((nChars ((String.size &amp;quot; &amp;quot;) + maxLen) #&amp;quot;-&amp;quot;) ^ &amp;quot;+&amp;quot; ^ (nChars ((String.size &amp;quot;|&amp;quot;) +  50) #&amp;quot;-&amp;quot;) ^ &amp;quot;\n&amp;quot;)
end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;付録b:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;付録B&lt;/h1&gt;

&lt;p&gt;元々、なんでこの問題が生じたかというと一々境界チェックして配列にアクセスするより例外出させといた方が速いんじゃね？ってことでそういうコードを書いたからです。
例外が出るってことは内部でも境界チェックしてる筈ですから。&lt;/p&gt;

&lt;p&gt;ということでどちらが速いか確認してみましょう。&lt;/p&gt;

&lt;p&gt;まず例外ハンドル方式。先程のままだと数ミリ秒で終わってたので配列の大きさを10倍しました。あと。実際に書きそうな書き方に変えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val len = 10000000
    val arr = Array.array(len, 0)
    fun loop i = (
        Array.update(arr, i, 1);
        loop (i + 1)
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop 0
                                     handle Subscript =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 48 ms/1calls
  [Average] 48.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ、こんなもんですね。&lt;/p&gt;

&lt;p&gt;次にifで分岐するやりかた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val len = 10000000
    val arr = Array.array(len, 0)
    fun
    loop i = if i &amp;lt; len
             then (
                 Array.update(arr, i, 1);
                 loop (i + 1))
             else ()
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop 0
                                     handle Subscript =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 96 ms/1calls
  [Average] 96.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;倍くらい遅くなってますね。&lt;/p&gt;

&lt;p&gt;ということでみだりに境界チェックするより例外を出させといた方が速いようです。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>