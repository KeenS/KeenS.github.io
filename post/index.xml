<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on κeenのHappy Hacκing Blog</title>
    <link>/post/</link>
    <description>Recent content in Posts on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Feb 2016 23:47:34 +0900</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Common Lispで高速行列演算</title>
      <link>/blog/2016/02/04/common_lispdekousokugyouretsuenzan</link>
      <pubDate>Thu, 04 Feb 2016 23:47:34 +0900</pubDate>
      
      <guid>/blog/2016/02/04/common_lispdekousokugyouretsuenzan</guid>
      <description>

&lt;p&gt;κeenです。Common Lispから線形代数ライブラリを使うポストで比較にCommon Lispのコードが出されていたのですがもう少し改良出来そうだったので少しばかり高速化してみました。&lt;/p&gt;

&lt;p&gt;そのポストはこちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://d.hatena.ne.jp/masatoi/20160204/1454519281&#34;&gt;Common Lispで行列演算: LLA(Lisp Linear Algebra)を使う - 翡翠はコンピュータに卵を生むか&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;圧倒的にCommon Lispが遅いですね。そのコードはこちらから。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tanakahx.hatenablog.com/entry/2015/09/25/070000&#34;&gt;Python (NumPy) と Common Lisp (LLA) で行列積の実行速度を比較する - 不確定特異点&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;行列計算(GEMM)部分を抜き出すとこうなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun simple-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))
      (dotimes (row rows)
        (dotimes (col cols)
          (dotimes (k cols)
            (incf (aref result row col)
                  (* (aref ma row k) (aref mb k col))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを&lt;code&gt;*N*&lt;/code&gt; = 256, で100回繰り返したら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   4.688 seconds of real time
;;   4.692000 seconds of total run time (4.688000 user, 0.004000 system)
;;   100.09% CPU
;;   13,564,728,093 processor cycles
;;   26,216,000 bytes consed

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とのこと。まあ、まだ高速化の余地はありそうです。&lt;/p&gt;

&lt;h1 id=&#34;キャッシュする:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;キャッシュする&lt;/h1&gt;

&lt;p&gt;内側のループをみるとこうなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;          (dotimes (k cols)
            (incf (aref result row col)
                  (* (aref ma row k) (aref mb k col))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;incf&lt;/code&gt;をばらすとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;          (dotimes (k cols)
            (setf (aref result row col)
                  (+ (aref result row col) (* (aref ma row k) (aref mb k col)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値として参照している方の&lt;code&gt;(aref result row col)&lt;/code&gt;は&lt;code&gt;k&lt;/code&gt;に依存しないのでループの外に出せます。
書き込んでいる方は場所だから仕方ない。&lt;/p&gt;

&lt;p&gt;これをキャッシュするようにすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun caching-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((cell (aref result row col)))
           (dotimes (k cols)
             (setf (aref result row col)
              (+ cell (* (aref ma row k) (aref mb k col)))))
           )))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じパラメータでベンチマークをとると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; 3.971 seconds of real time
;; 3.972000 seconds of total run time (3.972000 user, 0.000000 system)
;; 100.03% CPU
;; 11,491,319,119 processor cycles
;; 26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ループアンローリング:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;ループアンローリング&lt;/h1&gt;

&lt;p&gt;さて、先程の内側のループ、仕事が少ないですね。小さな仕事をチマチマループしてるとイテレーションコストが嵩みます。
1回のイテレーションでの仕事を増やすべく、ループアンローリングをしましょう。&lt;/p&gt;

&lt;p&gt;コピペはダルいのでまずはマクロを。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro dotimes-unroll ((i n unroll) &amp;amp;body body)
  (let ((n_      (gensym &amp;quot;n&amp;quot;)))
    `(let ((,n_ ,n))
       (do ((,i 0))
           ((&amp;lt; ,n_ (the fixnum (+ ,unroll ,i)))
            (do ((,i ,i (the fixnum (1+ ,i))))
                ((&amp;lt; ,n_ (the fixnum (1+ ,i))))
              ,@body
              ))
         ,@(loop :repeat unroll :append (append body `((setq ,i (the fixnum (1+ ,i))))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;少し試してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(dotimes-unroll (i 10 3)
  (format t &amp;quot;~%~a&amp;quot;) i)
0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。&lt;/p&gt;

&lt;p&gt;それではこれを使ってアンロールします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun loop-unroll-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((cell (aref result row col)))
           (dotimes-unroll (k cols 16)
             (setf (aref result row col)
              (+ cell (* (aref ma row k) (aref mb k col))))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アンロール数は16が一番パフォーマンス出たようでした。&lt;/p&gt;

&lt;p&gt;さて、ベンチマークをしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   3.847 seconds of real time
;;   3.848000 seconds of total run time (3.848000 user, 0.000000 system)
;;   [ Run times consist of 0.012 seconds GC time, and 3.836 seconds non-GC time. ]
;;   100.03% CPU
;;   11,128,993,432 processor cycles
;;   26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;辛うじて速くなってる…。因みにこれのパフォーマンスはCPUの命令キャッシュの状況に依存するので何度か試すとこれより速いスコアが出ることもあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Evaluation took:
  3.338 seconds of real time
  3.340000 seconds of total run time (3.332000 user, 0.008000 system)
  [ Run times consist of 0.020 seconds GC time, and 3.320 seconds non-GC time. ]
  100.06% CPU
  9,657,259,219 processor cycles
  26,248,768 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;メモリアクセスしない:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;メモリアクセスしない&lt;/h1&gt;

&lt;p&gt;さて、最初にキャッシュした時に書き込まれている方の &lt;code&gt;(aref result row col)&lt;/code&gt; は場所だからキャッシュ出来ないといいました。まあ、それは正しいのですがループの中で毎回書き込む必要はありません。&lt;/p&gt;

&lt;p&gt;レジスタ上で計算を済ませて最後に書き込んであげれば十分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun on-register-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((res (aref result row col)))
           (dotimes-unroll (k cols 16)
             (setf res
                   (the single-float (+ res (* (aref ma row k) (aref mb k col))))))
           (setf (aref result row col) res))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを試してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   2.302 seconds of real time
;;   2.304000 seconds of total run time (2.300000 user, 0.004000 system)
;;   [ Run times consist of 0.008 seconds GC time, and 2.296 seconds non-GC time. ]
;;   100.09% CPU
;;   6,662,273,812 processor cycles
;;   26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;わお！急に速くなりました。 &lt;code&gt;(* 100 (- (/ 4.688 2.302) 1))&lt;/code&gt; ≒ 103、 100%近い高速化です。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;特に深い意味はなかったのですがパタヘネに載っていたやつを試してみたくて遊んでみました。&lt;/p&gt;

&lt;p&gt;普通に行列計算したいなら線形代数ライブラリ使った方が良いと思います。&lt;/p&gt;

&lt;h1 id=&#34;ノート:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ループアンローリングの部分をイテレーションコストで説明しましたが他にも1ループ内の命令数が増えると組み合わせパズルのピースが増えるので最適化されやすくなります。まあ、SBCLは覗き穴最適化をほとんどしないのであまり意味ありませんが。気になる方はディスアセンブルしてみて下さい。&lt;/li&gt;
&lt;li&gt;このあと、 &lt;code&gt;(aref mb k col)&lt;/code&gt; がCPUキャッシュを無駄にしているという話からキャッシュサイズ毎に行、列を分けて計算するやり方を紹介しようとしたのですが逆に遅くなってしまいました。付録Aにコードを置いておきます。うーむ。&lt;/li&gt;
&lt;li&gt;本当はさらにこのセグメント毎にスレッドに計算を投げて並列化したかったのですがセグメントで高速化しなかったので萎えて諦めました。&lt;/li&gt;
&lt;li&gt;パタヘネ的にはSIMDも使うのですが深夜に近付いてきて面倒になったのでこの辺でやめました。Common Lisp(SBCL)からSIMD命令を使うには&lt;a href=&#34;http://keens.github.io/blog/2014/12/02/vopdeyou-bu/&#34;&gt;私の過去のエントリ&lt;/a&gt;を参照して下さい。&lt;/li&gt;
&lt;li&gt;本気で行列計算をしたいなら今回の $O(n^3)$ のアルゴリズムだけでなくStrassenのアルゴリズムやCoppersmith-Winogradのアルゴリズムも検討すべきです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;付録a:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;付録A&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun segmented-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let* ((segment 16)
         (rows (array-dimension ma 0))
         (cols (array-dimension mb 1))
         (rowseg (floor rows segment))
         (colseg (floor cols segment))
         rowtmp coltmp
         row col
         )
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (ri rowseg)
        (setf rowtmp (the fixnum (* ri segment)))
        (dotimes (ci colseg)
          (setf coltmp (the fixnum (* ci segment)))
          (dotimes (rs segment)
            (setf row (the fixnum (+ rowtmp rs)))
            (dotimes-unroll (cs segment 8)
              (setf col (the fixnum (+ coltmp cs)))
              (let ((res (aref result row col)))
                (dotimes-unroll (k cols 2)
                  (setf res
                        (the single-float (+ res (* (aref ma row k) (aref mb k col))))))
                (setf (aref result row col) res))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rustのパッケージをcrates.ioに登録する</title>
      <link>/blog/2016/01/31/rustnopakke_jiwocrates_ionitourokusuru</link>
      <pubDate>Sun, 31 Jan 2016 14:43:14 +0900</pubDate>
      
      <guid>/blog/2016/01/31/rustnopakke_jiwocrates_ionitourokusuru</guid>
      <description>

&lt;p&gt;κeenです。技術の話題を書くのは久し振りですね。今日初めてRustのパッケージのセントラルレポジトリ、&lt;a href=&#34;crates.io&#34;&gt;crates.io&lt;/a&gt;にパッケージを登録したのでその流れを共有します。&lt;/p&gt;

&lt;h1 id=&#34;登録したいパッケージを用意する:68d62f44abaeccb48e3489e820073d3b&#34;&gt;登録したいパッケージを用意する&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logge&lt;/a&gt;を作りました。
しばらく前に(Advent Calendar向けに)それっぽく動くところまで作って放置してたやつですね。これを整形していきます。&lt;/p&gt;

&lt;h1 id=&#34;任意-ドキュメントを生成する:68d62f44abaeccb48e3489e820073d3b&#34;&gt;(任意)ドキュメントを生成する&lt;/h1&gt;

&lt;p&gt;Rustには素晴しき &lt;code&gt;cargo doc&lt;/code&gt; があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo doc --no-deps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でドキュメントを生成しましょう。ドキュメントを書いてないなら&lt;a href=&#34;http://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/documentation.html&#34;&gt;こちら&lt;/a&gt;を見ながら書きましょう（すいません、私の奴は全然書いてないです…）。
&lt;code&gt;target/doc&lt;/code&gt; 以下に生成されたドキュメントがあるので適当に &lt;code&gt;gh-pages&lt;/code&gt; ブランチに放り込みましょう。
尚、&lt;code&gt;--no-deps&lt;/code&gt; オプションがないと依存パッケージのドキュメントも全部生成してしまいます。&lt;/p&gt;

&lt;p&gt;求: gh-pages管理のベストプラクティス。&lt;/p&gt;

&lt;h1 id=&#34;パッケージ情報を充実させる:68d62f44abaeccb48e3489e820073d3b&#34;&gt;パッケージ情報を充実させる&lt;/h1&gt;

&lt;p&gt;普段使っているままの &lt;code&gt;Cargo.toml&lt;/code&gt; だとcrates.ioで見た時に情報が全然ありません。
&lt;code&gt;[package]&lt;/code&gt; セクションに色々書きましょう。私の場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[package]
name = &amp;quot;file_logger&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Sunrin SHIMURA (keen) &amp;lt;3han5chou7@gmail.com&amp;gt;&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;から&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[package]
name = &amp;quot;file_logger&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Sunrin SHIMURA (keen) &amp;lt;3han5chou7@gmail.com&amp;gt;&amp;quot;]
repository = &amp;quot;https://github.com/KeenS/file_logger&amp;quot;
keywords = [&amp;quot;log&amp;quot;, &amp;quot;file&amp;quot;]
license-file = &amp;quot;LICENSE&amp;quot;
readme = &amp;quot;README.md&amp;quot;
description = &amp;quot;A simple logger backend that outputs to a file. \nThis is alpha state.&amp;quot;
documentation = http://KeenS.github.io/file_logger/file_logger/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になりました。
あ、ちゃんとライセンスも明示しましょうね。&lt;/p&gt;

&lt;p&gt;どういう情報が書けるのかは&lt;a href=&#34;http://doc.crates.io/manifest.html&#34;&gt;ここ&lt;/a&gt;に載ってます。&lt;/p&gt;

&lt;h1 id=&#34;crates-ioにログインする:68d62f44abaeccb48e3489e820073d3b&#34;&gt;crates.ioにログインする&lt;/h1&gt;

&lt;p&gt;[crates.io]()に行き、右上にあるGitHubログインボタンをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/login.png&#34; alt=&#34;github login&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そうするとログイン状態になります&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/loggedin.png&#34; alt=&#34;github logged in&#34; /&gt;&lt;/p&gt;

&lt;p&gt;メニューから&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/menu.png&#34; alt=&#34;menu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Account Settingsに飛ぶと下記のようにログイン用cargoコマンドが提示されるのでそのままペタっとコマンドラインに貼って終了です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/account_settings.png&#34; alt=&#34;account settings&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;パッケージング:68d62f44abaeccb48e3489e820073d3b&#34;&gt;パッケージング&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ cargo package
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;crates-ioに登録する:68d62f44abaeccb48e3489e820073d3b&#34;&gt;crates.ioに登録する&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ cargo publish
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;その他:68d62f44abaeccb48e3489e820073d3b&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;パッケージに含めるファイルを細かく調整したい、既にpublishしたパッケージをdeprecated的な扱いにしたいなどは&lt;a href=&#34;http://doc.crates.io/crates-io.html&#34;&gt;こちら&lt;/a&gt;にドキュメントが載っています。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:68d62f44abaeccb48e3489e820073d3b&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;crates.ioにログインしたよ&lt;/li&gt;
&lt;li&gt;Cargoを使えば簡単にパッケージを登録出来るよ&lt;/li&gt;
&lt;li&gt;Cargoってすごいね&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Lisp Meetup3周年に寄せて</title>
      <link>/blog/2016/01/27/lisp_meetup3shuunenniyosete</link>
      <pubDate>Wed, 27 Jan 2016 23:40:11 +0900</pubDate>
      
      <guid>/blog/2016/01/27/lisp_meetup3shuunenniyosete</guid>
      <description>&lt;p&gt;κeenです。昨日、&lt;a href=&#34;http://lisp.connpass.com/event/25546/&#34;&gt;Lisp Meetup #36&lt;/a&gt;が行なわれました。1回テックトークを挟んでるのでこれでちょうど丸3年、毎月Lisp Meetupが行われたことになります。&lt;/p&gt;

&lt;p&gt;Lisp Meetupは&lt;a href=&#34;http://shibuya.lisp-users.org/&#34;&gt;Shibuya.lisp&lt;/a&gt;が基本、毎月開催している草の根活動で、Lisper同士の交流を目的として主に希望者によるトークをメインとした会です。&lt;/p&gt;

&lt;p&gt;毎月Common Lisp、Clojure、Scheme回でローテーションしていて、近頃はScheme回にSchemerが来ないことからScheme回を減らして運用されています。
最初に述べた通りLisp Meetupだけで36回、丸3年活動してきました。ここ最近は定員にギリギリまで人が集まるくらいの盛況で何よりです。
ここまで継続したことを祝って記念ステッカーを作りました。私はほとんど何もしてませんが。@potix2さんに感謝。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;今日のLisp Meet Upは3周年記念ですね。先程ステッカー届きました。 &lt;a href=&#34;https://t.co/IRKkKVnkeU&#34;&gt;pic.twitter.com/IRKkKVnkeU&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/691875297940148224&#34;&gt;2016, 1月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;私が初めて参加したのは第7回から、運営になったのが1年後の第19回から(の筈)。
2年半サイバーエージェントの会場に通って気付いたらサイバーエージェントの社員になって、一勉強会がここまで大きく人生に影響するのかと感慨に耽る次第です。
何を大袈裟に、と思うかもしれませんがプログラミング経験が調子に乗ってきた時とLisp Meetupに参加し始めた時期が重なるので個人的には感慨に耽るだけのものがあるのです。&lt;/p&gt;

&lt;p&gt;さて、他のメジャーな言語の勉強会でも中々聞かない3周年ともなるとまた別種の問題も出てくる訳です。
その1つが「固定化」問題です。1度もLisp Meetupに来たことのない方はこう思う訳です: 何度も回を重ねる内にメンバーが固定化されて一見さんお断りな雰囲気になってるんじゃないかと。
実際のところLisp Meetupにはそんな雰囲気はなく、何度も来てる人もいれば久しぶりに来た人、最近よく来る人、初めて来る人色々いる訳です。
実情がどうあれ、お尻の数字が大きいだけで一番来て欲しい初心者が来なくなるならと、一度は名前を変えて連番をリセットしようかとも話されましたが結局今のLisp Meetupのままでいます。
Lisp Meetupといえば私のようによく分からない発表をしてても暖かく受け入れてくれる優しい人達の集りなのですが、とはいえ外から見て「初めての勉強会でLisp Meetupは怖い」などと言われると中々考えることがあります。
まあ、それでも初心者や初参加の人は毎回数人は来てるのでこれ以上増やそうとするとこれより大きな会場を確保する必要があって中々ハードルは高いのですが。初心者は大歓迎ということは伝えておこうかと思います。&lt;/p&gt;

&lt;p&gt;さて、次回はClojure回です。そろそろScheme回を…と思ったのですが発表者が集りそうにないので見送られました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;少し気の早い話ですが来月2月の &lt;a href=&#34;https://twitter.com/hashtag/lispmeetup?src=hash&#34;&gt;#lispmeetup&lt;/a&gt; でSchemeをテーマにするとしたらみなさんどうですか&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/688627343112278017&#34;&gt;2016, 1月 17&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;3月には開催しようかと話し合われている最中なのでSchemer各位、SICP読書中の各位は準備をして開催して欲しいオーラを出して頂けると開催決定の後押しになります。&lt;/p&gt;

&lt;p&gt;ということで来月以降もLisp Meetupをよろしくお願いします。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>独学でプログラミングをやってきた中で良かった技術書50選</title>
      <link>/blog/2016/01/17/dokugakudepuroguraminguwoyattekitanakadeyokattagijutsushowoageteiku</link>
      <pubDate>Sun, 17 Jan 2016 16:48:28 +0900</pubDate>
      
      <guid>/blog/2016/01/17/dokugakudepuroguraminguwoyattekitanakadeyokattagijutsushowoageteiku</guid>
      <description>

&lt;p&gt;今まで読んできた技術書の中で良かったものを挙げていく。
そろそろ本棚が溢れるので捨てる前に書き留めておく。
あとはGitHub PagesがアフィOKとのことなので試してみようかと。50冊分（以上）アフィがあるのでページが重いがご容赦を。&lt;/p&gt;

&lt;p&gt;私は独学でプログラミングを始めたので情報系専攻の人には何をそんなという本も混っているだろうが価値は人それぞれ違う。&lt;/p&gt;

&lt;p&gt;一応私自身について語っておくと学生時代はプログラミングに興味を持ちつつも数学科に進んだ。
しかしそこでもプログラミングへの興味は薄れず、色々本を読んだり同学年の情報科学科の真似をしたりしていた。
今思えば日本の精鋭たる東大情報科学科の人達に勝てる筈もなかったのだが学生時代に我武者羅になれたのは悪い経験ではなかった。
私が興味があったのは主にプログラミング言語そのもの、特にLispとその周辺。&lt;/p&gt;

&lt;h1 id=&#34;何故本か:390eeec2ebe741f3494b487839fdedf9&#34;&gt;何故本か&lt;/h1&gt;

&lt;p&gt;挙げていく前に1つだけ。Webに大量に情報がある今、何故本かについて説明したい。簡潔に言うと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文章が推敲されていて読み易い&lt;/li&gt;
&lt;li&gt;1つの情報ソースに多彩な内容が載っている&lt;/li&gt;
&lt;li&gt;巨大な情報の中で一貫性が取れている&lt;/li&gt;
&lt;li&gt;出版されている以上ある程度内容に責任を持って書かれている&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;どれもWebの情報は断片的で無責任に書かれているような書き方だが凡そ間違ってはいないと思う。
私のブログだってよく間違いが書いてある（そして申し訳ないことに面倒くさがって修正しないままのことも多々ある）。
本屋に足を運んでパラパラ捲って気に入った本を買うのが一番確実な情報収集の仕方だと思う。勿論本だけでは足りないことも多いが。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では、本を挙げていく。順不同で、本棚を見ながらあれこれ挙げることにする。&lt;/p&gt;

&lt;h1 id=&#34;1-作りながら学ぶruby入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;1. 作りながら学ぶRuby入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B00GJGOPU0&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本は私がプログラミングを学び始めた時にお世話になった。初心者には0からアプリケーションを作るまでのノウハウがない。それを丁寧に教えてくれる。
よく「プログラミングを始めたいんですがどうやって覚えました？」と聞かれるが、毎度この本と下記の逆引きを勧めている。&lt;/p&gt;

&lt;p&gt;もしかしたらRubyのバージョンが古くてサンプルコードが動かないかもしれない。&lt;/p&gt;

&lt;h1 id=&#34;2-ruby逆引きハンドブック:390eeec2ebe741f3494b487839fdedf9&#34;&gt;2. Ruby逆引きハンドブック&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4863540221&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;私の人生を変えたともいうべき1冊。プログラミングを英作文に例えるならこの本は和英辞典にあたる。
そして初心者にとっては「○○したいから□□する」は「へー。○○したいという需要があるんだ、そして□□で出来るんだ」と同時に2つを教えてくれる。
この1冊前部読むことでRubyを書くときの手札を確認出来た。&lt;/p&gt;

&lt;p&gt;惜しいことにこの本も少し古くなってきた。&lt;/p&gt;

&lt;h1 id=&#34;3-メタプログラミングruby:390eeec2ebe741f3494b487839fdedf9&#34;&gt;3. メタプログラミングRuby&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873117437&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Rubyをやるならこの本を一度は読んだ方がいい。&lt;code&gt;method_missing&lt;/code&gt;などRubyコミュニティでは非常に重要なテクニックが載っている。私は初版を読んだが第2版が出ているようだ。&lt;/p&gt;

&lt;h1 id=&#34;4-emacsテクニックバイブル:390eeec2ebe741f3494b487839fdedf9&#34;&gt;4. Emacsテクニックバイブル&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774143278&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;るびきちさんの本を紹介したのでついでにこの本も。Emacsの便利な使い方から人気プラグインまで様々に解説されている。Emacsを使い熟したい方にお勧めする(そして私のように帰ってこれなくなるといい。)。
今ではいくつか動かない/入手出来ないプラグインはあるものの基本的な使い熟すための指南というか思想は色褪せない。&lt;/p&gt;

&lt;h1 id=&#34;5-emacs-lispテクニックバイブル:390eeec2ebe741f3494b487839fdedf9&#34;&gt;5. Emacs Lispテクニックバイブル&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774148970&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;同じくるびきちさんの本。コピペだけでinit.elを書くのが嫌な人、片手間程度でもEmacs Lispを書く人にお勧めする。私もこの本を境にして片手間程度にEmacs Lispを書くようになった。
さらにComon Lisperである私にはCommon Lispマクロの解説が非常に分かりやすくて参考になった。&lt;/p&gt;

&lt;h1 id=&#34;6-入門vi:390eeec2ebe741f3494b487839fdedf9&#34;&gt;6. 入門vi&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873110831&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;例え熟練のEmacsユーザでもviは使えた方がいい。サーバに入った時にviしか使えないこともある。
Emacsをインストールしようにもインストールするための設定をviで書く必要がある。
nanoもあるが、リッチテキストエディタに馴れた手にはviの方が馴染む。&lt;/p&gt;

&lt;p&gt;そういう人に、この本は良い。Vim入門のようにごてごてしてなくて欲しい情報だけが書いてある。&lt;/p&gt;

&lt;h1 id=&#34;7-実践common-lisp:390eeec2ebe741f3494b487839fdedf9&#34;&gt;7. 実践Common Lisp&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274067211&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;私はほぼRubyでプログラミングに入門したが&lt;a href=&#34;http://docs.ruby-lang.org/ja/2.0.0/doc/spec=2fintro.html&#34;&gt;RubyはLispを参考に作られたと言われたら&lt;/a&gt;その原典たるLispにも興味が出るのは自然の流れ。当然私もCommon Lispを始めた。
Common Lispに入門するにあたって一番お世話になった一冊。早見表もあれば関数の解説もあり、実践の名の通りアプリケーションを作るところまでいける。
Common Lispといえばまずこの本をお勧めする。&lt;/p&gt;

&lt;h1 id=&#34;8-land-of-lisp:390eeec2ebe741f3494b487839fdedf9&#34;&gt;8. Land of Lisp&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873115876&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;オライリーの中でも異色の表紙で有名なこの本。このエイリアンはオライリーの本が出る前からLisp界隈で活躍していたりする。
モチーフは「他言語プログラマから見たLisper」なのでLisperのペットというようりはLisper自身。&lt;/p&gt;

&lt;p&gt;閑話休題。この本は実践Common Lispよりも易しいというか丁寧で、分かりやすく書いてある。
そしてちょこちょこゲームを作りながら進んでいくので飽きない。手を動かしたい人には本書を、後のリファレンスとしても役立てたい人には先の実践Common Lispをお勧めする。&lt;/p&gt;

&lt;h1 id=&#34;9-on-lisp:390eeec2ebe741f3494b487839fdedf9&#34;&gt;9. On Lisp&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274066371&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;大半がマクロについて書かれているPaul Grahamのマクロの本。Common Lisp中級者向けの必読書。
Common Lispを使っていてマクロを書く必要が出てきたあたりでこの本を読むといいと思う。
変数捕捉の問題から逆に変数を捕捉させるアナフォリックマクロの話、マクロを使って作る継続と非決定性計算などなどが載っている。&lt;/p&gt;

&lt;p&gt;他言語プログラマでも非衛生的なマクロを持つ言語を使うならこの本を読むと良いと思う。私の知る限り世界で一番マクロに詳しい本だ。&lt;/p&gt;

&lt;p&gt;マクロの本とはいったがLisp流のボトムアッププログラミングを指南していたりオブジェクトシステムやパッケージについての解説があったりと中々役に立つ指南書でもある。
また、名言も多いのでLisp界隈でよく言われる元ネタを知りたい時にもいい。&lt;/p&gt;

&lt;p&gt;訳者が高校生の時に訳し始めたので日本語はやや読みづらい。Webで無料で公開されていたりする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/&#34;&gt;On Lisp&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;10-let-over-lambda:390eeec2ebe741f3494b487839fdedf9&#34;&gt;10. LET OVER LAMBDA&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4434201581&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;過激な本。LOLの名で呼ばれる。Land of LispはLoL。一歩間違うと命を落しかねないので注意。「Common Lispこそが史上最高の言語だ」のスタンスで進んでいく。
LET OVER LAMBDA(lambdaの上のlet)とは、ラムダでletで作った変数を捕捉する話、クロージャの話をメインに据えている。
サーカスのようなプログラミングテクニックもあるかと思えば割と便利なツール、あるいはパフォーマンスチューニングについてなども載っていて、飽きない本。&lt;/p&gt;

&lt;p&gt;余談だが某所で「Land of Lispは聖典」と言われていたが本当にバイブル的な意味では先のOn Lisp、宗教的な意味ではこのLET OVER LAMBDAが聖典になると思う。&lt;/p&gt;

&lt;h1 id=&#34;11-real-world-ocaml:390eeec2ebe741f3494b487839fdedf9&#34;&gt;11. Real World OCaml&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=144932391X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Lispが函数型言語と言われいると他の函数型言語にも興味が出る。OCamlに半ば足を突っ込んでる時にこの本が公開されて読んだ。&lt;a href=&#34;https://realworldocaml.org/&#34;&gt;Webで草稿が公開されている&lt;/a&gt;。
普通に初心者に易しい内容だしコマンドラインのパースとか非同期プログラミングとかもあり充実満足な内容。
さらにランタイムシステムやコンパイラプラグインなどの深い話もあってOCaml上級者にも役に立つらしい（私はまだ初級者）。
数少ないOCaml書籍。オライリーでは唯一？&lt;/p&gt;

&lt;p&gt;このノリでReal World Standard MLとか出ないかな、出ないよな。Standard MLの書籍少ない…。これくらい？&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4320120248&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;12-プログラミングerlang:390eeec2ebe741f3494b487839fdedf9&#34;&gt;12. プログラミングErlang&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274067149&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;どうせなら他の函数型言語も試してみるといい。例えばErlangとか。これは飛行機本として有名なErlangの入門書。Erlang作者のJoe Armstrongが著している。
Erlangのアクターモデルについて何も知らなくても恐れる必要はない。この本がついている。全くの初心者からErlangの考え方、ETS、DETS、OTP、Mnesiaなどを学べる。&lt;/p&gt;

&lt;h1 id=&#34;13-すごいerlangゆかいに学ぼう:390eeec2ebe741f3494b487839fdedf9&#34;&gt;13. すごいErlangゆかいに学ぼう!&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274069125&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Erlang界隈では先の飛行機本が定本らしいが私はこのすごいE&amp;reg;本の方が肌に合った。ノリ良く進むしEUnitやDialyzerなどについても解説してある。
Erlang最高！なノリだが「うまい話ばかりじゃないですよ」とちゃんと現実も見ている。&lt;/p&gt;

&lt;h1 id=&#34;14-７つの言語-７つの世界:390eeec2ebe741f3494b487839fdedf9&#34;&gt;14. ７つの言語 ７つの世界&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274068579&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;さらにプログラミング言語に興味を持ったならこの本を読むといい。様々な言語を広く浅くやっている。
普通のプログラマなら言語の10くらい書けるものだがCライクな言語10個書けたところで大したことはない。
比してこの本はそれぞれにパラダイムの違う言語を7つ紹介している。Ruby、Io、Prolog、Scala、Erlang、Clojure、Haskell。
Ioなんかは中々知っている人は少ないのではないだろうか。そういう言語に3日だけ触れてみるのも悪くない。&lt;/p&gt;

&lt;h1 id=&#34;15-java言語で学ぶデザインパターン入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;15. Java言語で学ぶデザインパターン入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4797327030&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;人は、あまりに分かり易い解説を読むと初めてでも既知のように感じる。この本はそういう体験をさせてくれる。
プログラマとして生きる以上知っておかないといけないデザインパターンについて非常に分かりやすく丁寧に解説してある。
著者が物書きもしている結城先生なので日本語も非常に読み易い。&lt;/p&gt;

&lt;p&gt;大きな本だが解説を丁寧にするために膨らんでいるだけなので臆せず読んで欲しい。&lt;/p&gt;

&lt;h1 id=&#34;16-java言語で学ぶデザインパターン入門-マルチスレッド編:390eeec2ebe741f3494b487839fdedf9&#34;&gt;16. Java言語で学ぶデザインパターン入門 マルチスレッド編&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4797331623&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;マルチスレッドプログラミングは複雑で、書いてる本人すら状況を把握しづらい。
先にこの本を読んで基本的な考え方を身に付けているかいないかは大きく響く。
分かりやすい解説に加えて図解もあるので頭の中で動きをイメージしやすい。&lt;/p&gt;

&lt;h1 id=&#34;17-プログラミングコンテストチャレンジブック:390eeec2ebe741f3494b487839fdedf9&#34;&gt;17. プログラミングコンテストチャレンジブック&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4839941068&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;いわゆる蟻本。プログラミングコンテストに興味がなくてもこの本は良い本だ。
様々なアルゴリズムの解説とその実践が出来る。そしてグラフ関連のアルゴリズムに詳しい。
私がアルゴリズムに興味を持つきっかけになった一冊。&lt;/p&gt;

&lt;h1 id=&#34;18-アルゴリズムイントロダクション:390eeec2ebe741f3494b487839fdedf9&#34;&gt;18. アルゴリズムイントロダクション&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=476490408X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;アルゴリズムやデータ構造に詳しくなりたいのならこの本をお勧めする。
相当数のアルゴリズムやデータ構造が載っているばかりか、ちゃんと計算量の解析なんかもしている。しっかりと「考え方」が身につく本である。
練習問題も豊富にある。中々分厚いが辞書と思えば妥当でもある。&lt;/p&gt;

&lt;p&gt;ただ、内容は堅いのでかなりとっつきにくい。さらに、載っているのは疑似コードなので実際に試したいならそれなりに頭を使って自分の言語に翻訳する必要がある。&lt;/p&gt;

&lt;p&gt;アルゴリズムやデータ構造に関して、触りだけでいいならこの本がある。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4797306947&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;随分前に借りて読んだ本で、本棚にも並んでないので記憶が朧げだがプログラミング初学者~初心者に丁度いいくらいの内容だったと思う。&lt;/p&gt;

&lt;h1 id=&#34;19-purely-functional-data-structures:390eeec2ebe741f3494b487839fdedf9&#34;&gt;19. Purely Functional Data Structures&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=0521663504&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本はアルゴリズムイントロダクションの延長にあると言える。
最初に「ならし計算量」(償却計算量)を導入したあと、いくつかのデータ構造を下限オーダの操作のまま簡潔に関数的に実装していく。古い本なので恐らくは多くの人に馴染のないStandard MLで書かれているが簡潔な実装は一目瞭然、SMLを知らなくても読めるだろう。
その後遅延評価を導入して、上手く高速化する話、償却しなくても下限の計算量を維持出来る話、データ構造に「ひずみ」を溜めない話なんかが出てくる。&lt;a href=&#34;http://qiita.com/search?q=%E7%B4%94%E7%B2%8B%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0&amp;amp;sort=rel&#34;&gt;Qiitaに一部の解説がある&lt;/a&gt;のでこれを読んで興味が湧いた人は買うといいと思う。&lt;/p&gt;

&lt;h1 id=&#34;20-関数プログラミング-珠玉のアルゴリズムデザイン:390eeec2ebe741f3494b487839fdedf9&#34;&gt;20. 関数プログラミング 珠玉のアルゴリズムデザイン&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274050645&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本を読んだ時、衝撃を受けた。まず、内容が難しくて理解が及ばなかった。先述のアルゴリズムイントロダクションを読んだ上でだ。
そしてそれ以上に衝撃だったのが複雑なアルゴリズムをHaskellを使って驚くほど簡潔に実装していた点だ。
アルゴリズムを下限のオーダーで実装するのを前提として、「運算」を使って定数倍の高速化を試みる。魔法のようだった。&lt;/p&gt;

&lt;p&gt;比較的小さな本だが内容は見た目の3倍はあると思って読んだ方がいい。&lt;/p&gt;

&lt;p&gt;函数型言語を触る人なら必ず読んだ方がいい。難しいので完全に理解は出来なくてもこういう世界があることは知っておきたい。&lt;/p&gt;

&lt;h1 id=&#34;21-人間に勝つコンピュータ将棋の作り方:390eeec2ebe741f3494b487839fdedf9&#34;&gt;21. 人間に勝つコンピュータ将棋の作り方&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774153265&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;LispはかつてAIの言語として表舞台に立った。ならばLisperとしてAIは知っておきたい。当時まだ探索初心者だった私にとってこの本は色々ためになった。
min maxやnega max、αβ木探索なんかは初めて知ったし評価関数のパラメータを機械学習で決めるのも初耳だった。
読み物程度で詳しい技術の話は載ってないがAIに興味を持っていた私には面白い本だった。&lt;/p&gt;

&lt;h1 id=&#34;22-コンピュータ囲碁:390eeec2ebe741f3494b487839fdedf9&#34;&gt;22. コンピュータ囲碁&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4320123271&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;将棋AIが人間に勝つようになって、そろそろ別のゲームか、と思い始めてこの本を手に取った。
先の本とはうってかわってつぶさな実装が載っている。将棋とは違ったモンテカルロ法のアプローチが新鮮で面白い。
モンテカルロ法の探索を知らないのなら一度は読むと良いかもしれない。&lt;/p&gt;

&lt;p&gt;最近では画像認識によく使われるCNNを使った手法なんかもあるようだが今の囲碁AIはどうなっているのだろうか。&lt;/p&gt;

&lt;h1 id=&#34;23-やさしいインタープリタの作り方入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;23. やさしいインタープリタの作り方入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=487783219X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Lisperは一生に一度は自分のLispを作ると言われている。ならば、とこの本を手に取った。
プログラミング言語がどう動いているのかも知らない初心者には丁度良い内容だった。&lt;/p&gt;

&lt;p&gt;一応言うと私はこの本を参考にインタプリタを作った訳ではなくサラサラと眺めて概略だけを知った。
図書館で借りた本だったのでゆっくり読む時間がなかった。&lt;/p&gt;

&lt;h1 id=&#34;24-やさしいコンパイラの作り方入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;24. やさしいコンパイラの作り方入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4877832203&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;私が作りたいのはインタプリタだったが姉妹本ということで一緒に借りて読んだ。
感想はインタプリタと同じ。今Amazonのレビューを見ると酷評されていたのでゆっくり読むには向いてない本なのかもしれない。&lt;/p&gt;

&lt;h1 id=&#34;25-コンパイラ-原理-技法-ツール:390eeec2ebe741f3494b487839fdedf9&#34;&gt;25. コンパイラ―原理・技法・ツール&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=478191229X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;いわゆるドラゴンブック。コンパイラの定本。もう少しコンパイラに詳しくなろうと手にとった。著者達が構文解析の専門家のようで、本の半分くらいが構文解析に割かれている。
さらっと正規言語(正規表現)についても載っていたりする。私みたいにLispを作りたい人には複雑な構文解析の話は退屈だったが後半の翻訳や最適化の話は非常に面白かった。
中々堅いというか難しい本ではあるが、馴染めるならこれ以上のものはない一冊。&lt;/p&gt;

&lt;p&gt;余談だが著者のエイホはAhoと綴る。I am AHOというとめちゃくちゃコンパイラ出来る人と思われるだろう。&lt;/p&gt;

&lt;p&gt;因みにドラゴンブックと並び語られる本にタイガーブックがあるが私はまだ読んだことがない。その内読まねばと思っている。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4798114685&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;26-コンパイラの構成と最適化:390eeec2ebe741f3494b487839fdedf9&#34;&gt;26. コンパイラの構成と最適化&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4254121776&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;ドラゴンブックよりも最適化についてページを割いている本。人によりけりだがドラゴンブックよりもこの本を勧める人が多い。私もそれが妥当だと思う。
文体はさしてドラゴンブックと変わらないが変にカタカナ文字を日本語にしておらず(インタプリタ、コンパイラを解釈系、翻訳系と訳すなど)読み易い。&lt;/p&gt;

&lt;h1 id=&#34;27-きつねさんでもわかるllvm:390eeec2ebe741f3494b487839fdedf9&#34;&gt;27. きつねさんでもわかるLLVM&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4844334158&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;理論の話が出来ても現実のコンパイラを作るのは難しい。その1つにコードを吐く部分が泥臭い点がある。
LLVMを使えればそういう泥臭さを軽減出来る。さらにLLVMは低レベルな最適化もやってくれるのでコンパイラを作る時の手間をかなり省かせてくれる。&lt;/p&gt;

&lt;p&gt;LLVMは巨大だがこの本を読めばどこで何をやってるのか、LLVM IRがどんなものかは分かるようになる。
さらにパスやバックエンドなどそれぞれのプラグインの書き方も載っているので色々な切り口からLLVMを使いたい人にも役に立つ。
少なくともこの本を読まずしてLLVMが分からないと言ってはいけない。分かってなくて分かりたいなら読むべき。&lt;/p&gt;

&lt;p&gt;ところでLLVMといえばもう一冊あるがこちらはClangのためのLLVMといった感じでClangをハックしたい人向けな内容になっている。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4883379310&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;28-言語実装パターン:390eeec2ebe741f3494b487839fdedf9&#34;&gt;28. 言語実装パターン&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873115329&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;パーサジェネレータのANTLRの開発者が著した本。実際にいくつかDSLなどを作りながら進むのでエンジニア向けなのかもしれない。
一度借りて読んだ後本棚に置きたいなと思いつつまだ買っていない。&lt;/p&gt;

&lt;h1 id=&#34;29-正規表現技術入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;29. 正規表現技術入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774172707&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;一度&lt;a href=&#34;//KeenS.github.io/blog/2015/05/10/seikihyougengijutsunyuumonwoyonda/&#34;&gt;書評を書いた&lt;/a&gt;。
Webではまず得られない正規表現のまとまった情報が得られる。
ドラゴンブックでも扱われている正規言語だがこちらの方がコードを交えながら解説するので詳しくて分かりやすい。&lt;/p&gt;

&lt;p&gt;Onigmoのコードが載っているのでそれを見て&lt;a href=&#34;//KeenS.github.io/blog/2015/05/26/onigmowosaidai49_kousokukashitahanashi/&#34;&gt;最適化し&lt;/a&gt;、最終的には&lt;a href=&#34;http://qiita.com/blackenedgold/items/2ec4d8bfaf220409609d&#34;&gt;パッチがRubyに取り込まれる&lt;/a&gt;までの流れが出来た私にとっての思い出の1冊でもある。&lt;/p&gt;

&lt;p&gt;語彙が足りなくて申し訳ないが素晴しいの一言に付きる。&lt;/p&gt;

&lt;h1 id=&#34;30-型システム入門-プログラミング言語と型の理論:390eeec2ebe741f3494b487839fdedf9&#34;&gt;30. 型システム入門 −プログラミング言語と型の理論−&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274069117&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;コンパイラを作っていて外せないのが型システムの話題。それについて深く扱っているのがこの本。いわゆるTaPL。
初めて読んだ時、λだけで様々な関数を実装していくのが不思議でならなかったし、不動点コンビネータにも感動した。
2回目に読んだ時にはもう少し余裕があって操作的意味論も追えた。
次に読む時はもう少し深くまで読みたい。少くとも手を動かす必要はあるだろう。&lt;/p&gt;

&lt;p&gt;有名な定本ではあるが理論の本なのでどういうことを論じているか分からないまま読める本ではない。
しかし本棚に置いておくと「あれ？System F_ωってどんなシステムだっけ？」などとなった時にサッと引けて便利ではある。&lt;/p&gt;

&lt;h1 id=&#34;31-プログラミング言語の基礎概念:390eeec2ebe741f3494b487839fdedf9&#34;&gt;31. プログラミング言語の基礎概念&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4781912850&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;TaPLよりも軽くやりたいならこの本がある。TaPLに比べてずいぶん（物理的にも）軽く、要点を押えた内容で入り易い。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sampou.connpass.com/&#34;&gt;読書会も開かれている&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この本とTaPLの中間というかもう少しプログラミング言語の意味論に焦点を当てたものとしてWeb上だがソフトウェアの基礎がある。Coqの練習がてら手を動かすと良い。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://proofcafe.org/sf/&#34;&gt;ソフトウェアの基礎&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こちらも&lt;a href=&#34;http://readcoqart.connpass.com/&#34;&gt;読書会が開かれている&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;32-計算機プログラムの構造と解釈:390eeec2ebe741f3494b487839fdedf9&#34;&gt;32. 計算機プログラムの構造と解釈&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=489471163X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;もう少しエンジニア寄りのコンピュータサイエンスの本ならこれがある。
言わずと知れた名著、いわゆるSICP(しっくぴー)。表紙から魔導師本などとも言われる。計算機科学への深い洞察を与える。
訳が堅いとも言われるが大学生の教科書なんてみんな同じようなものだ。解析概論に比べたら読み易い。
初心者にプログラミングを教える時に適当な例を挙げるのに困ることがよくあるが、この本の題材の選び方は完璧だと思う。
理解の妨げになる余分な脂肪は落として完璧なまでに簡潔にしつつも関心を失わせない興味深いものを取り上げている。
題材のプログラミング言語としてSchemeが選ばれているが、そこも正解だと思う。Scheme自身にも余計な脂肪がない。&lt;/p&gt;

&lt;p&gt;最初のレベルはプログラミング初心者に合わせてあるが中身は計算機科学なのでストイックな初心者がゆっくり読むかある程度レベルをつけてから読むのが良いと思う。&lt;/p&gt;

&lt;h1 id=&#34;33-linuxプログラミングインターフェース:390eeec2ebe741f3494b487839fdedf9&#34;&gt;33. Linuxプログラミングインターフェース&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=487311585X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;普段OSのインタフェースがどうなってるかなんてプログラミング言語が隠蔽してくれるが、自分でプログラミング言語、Lispを作ろうと思ったら知る必要がある。
そういう時にこの本は役に立つ。&lt;/p&gt;

&lt;p&gt;C言語の良い所の1つにmanが充実している点が挙げられるが、この本はmanの編集者が著した本だ。
しかもmanよりも詳しくて、Linuxに出てくる概念のつぶさな説明、それぞれのインターフェースの細かな違い、早見表、違いを実感出来るコード例、Linuxに限らないコードの可搬性の話などなど枚挙に暇がない。&lt;/p&gt;

&lt;p&gt;今回挙げる中でも随一の重量を誇るが一番お勧めしたい一冊。無人島に1冊だけ持っていくとしたらこの本を選ぶ。&lt;/p&gt;

&lt;h1 id=&#34;34-operating-systems:390eeec2ebe741f3494b487839fdedf9&#34;&gt;34. Operating Systems&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4894717697&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;やはりOS上でLispを動かす以上OSについては避けて通れない。&lt;/p&gt;

&lt;p&gt;これはいわゆるMINIX本で、UNIXライクな小さなOS、MINIXを題材にOSについて論じる。
私は英語版を読んだが日本のAmazonに出回ってないようなので日本語版のリンクを挙げておく。
MINIXを題材とはいいつつも副題にDesign and Implementationとあるが、Implementationの部分でMINIXのコードリーディングが挟まる程度。Designの部分はMINIXに限らない一般的なことを論じる。&lt;/p&gt;

&lt;p&gt;IOについて、プロセスについて、メモリ管理についてなどなど、普段のプログラミングで使っているのに詳しくないのなら一度は読むべきだ。&lt;/p&gt;

&lt;p&gt;特に、IPC(プロセス間コミュニケーション)の部分はOS関係なく役に立つ。&lt;/p&gt;

&lt;p&gt;OSについてなら最近だと定本ではあるがMINIX本よりこちらの方が良いと勧められたことがあるがまだ読んでいない。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B014I57BEA&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B014RTDMFY&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B014RTDPJM&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;4部構成らしいが、なぜかvolum4が見当らない。&lt;/p&gt;

&lt;h1 id=&#34;35-computer-organization-and-design:390eeec2ebe741f3494b487839fdedf9&#34;&gt;35. Computer Organization and Design&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=0124077269&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;やはりCPU上でLispを動かす以上CPUについては避けて通れない。&lt;/p&gt;

&lt;p&gt;これも名著。いわゆるパタヘネ。副題にThe Hardware/Software Interfaceとある通り、ハードウェアとソフトウェアの境界を行ったり来たりして進んでいく。
コンピュータの中身なんて丸で知らない初心者でも読めて、CPUの構造や(MIPS)アセンブラを知ることが出来る。
本を通してCPUの構造を解説しつつその知識を使って行列計算を高速化していく。それで最後は200倍まで速くなる。高速なコードを書きたい人は是非読むと良い。&lt;/p&gt;

&lt;p&gt;また、この本は最新のCPU事情を追い掛けることも目的としていて、頻繁に改訂されている。
古くからある本だがこの第5版には大規模データセンターやモバイルデバイスでのCPUについても論じられている。&lt;/p&gt;

&lt;p&gt;尚、日本語版もあるが私は読んでないのでコメントは控える。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4822298426&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4822298434&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;余談だが、最初にパタヘネと間違えてヘネパタ、CPUを作る人向けの本を買ってしまったので勿体なくて読んだが私には早すぎたようだった。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=012383872X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;こちらも日本語版があるらしい。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4798126233&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;36-データマイニング入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;36. データマイニング入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4489020457&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;LispをやるならAI、AIでは機械学習が使われいるということから簡単な入門書を選んだ。
最初、これを選んだ時にはそこまで深く考えた訳ではないのだが後にこれ以上の入門書に出会ったことがない。
取り上げるトピックや理論と実践の配分、理論の踏み込み具合、図、などなど絶妙である。&lt;/p&gt;

&lt;p&gt;他にも統計や機械学習の入門書は色々に読んだが全てこの本の前には霞んでしまったのでこれしか挙げられない。&lt;/p&gt;

&lt;h1 id=&#34;37-エンジニアのための-データ可視化-実践-入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;37. エンジニアのための データ可視化[実践]入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774163260&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本の通称何なのだろう。3D円グラフ本？あんちべ本？あんちべ本はこれか。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4627817711&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;小中学校の社会や算数で習ったグラフの発展といったところ。しかし世の中思った以上に可視化の手法があって驚きが多かった。
データを可視化することがあるなら一度手を止めてこの本を読むだけの価値がある。&lt;/p&gt;

&lt;p&gt;詳しくは著者のブログを見るといい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://antibayesian.hateblo.jp/entry/2014/02/16/235830&#34;&gt;エンジニアのためのデータ可視化実践入門という本を書いた - あんちべ！&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;38-詳解-シェルスクリプト:390eeec2ebe741f3494b487839fdedf9&#34;&gt;38. 詳解 シェルスクリプト&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873112672&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Lispの処理系マネージャをシェルスクリプトで書き始めたのが大学3年生のこと。そのあたりでこの本を買った。
シェルスクリプトを書くときには是非この本をお勧めする。便利コマンドやTipsの他にシェルの引数の評価順序、互換性の話などこの本くらいでしか扱ってないような情報が多数載っている。
シェルのテキストベース、行指向の考え方を身につけることが出来る。私も知人からはシェルスクリプトの人と認識されているがその知識の根底にあるのはこの本。&lt;/p&gt;

&lt;h1 id=&#34;39-bsd-hacks:390eeec2ebe741f3494b487839fdedf9&#34;&gt;39. BSD Hacks&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873112184&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;古き良きBSDハッカーに思いを馳せたいならこの本を読むといい。FreeBSDを主としているがNetBSDやOpenBSDについての注釈もある。「telnetでメールを読む」など個人的にはすごい好きな本なのだが恐らく今の時代に需要はない。&lt;/p&gt;

&lt;h1 id=&#34;40-マスタリングnginx:390eeec2ebe741f3494b487839fdedf9&#34;&gt;40. マスタリングNginx&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873116457&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;NginXのパラメータやビルドオプションについて詳しい説明がある。
説明だけでなく、「CPUネックの時はワーカ数をコアと同じだけ、IOネックの時はコア数の1.5~2倍にするといい」など、パラメータ設定の目安もある。
NginXを扱うことがあるなら是非読んだ方がいい。そんなに分量はないので隙間時間に目を通せる。&lt;/p&gt;

&lt;p&gt;最近はnginx実践入門が話題だがまだ読んでいないので何も紹介出来ない。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774178667&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;41-初めてのsql:390eeec2ebe741f3494b487839fdedf9&#34;&gt;41. 初めてのSQL&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873112818&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;今更この本を挙げると笑われそうだが初学者の私には役に立った。SQLは割とノリで書けるところはあるが、GROUP BYなんかは知らないと書けない。&lt;/p&gt;

&lt;h1 id=&#34;42-sqlアンチパターン:390eeec2ebe741f3494b487839fdedf9&#34;&gt;42. SQLアンチパターン&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873115892&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;こういう本は中々ない。いわゆる勘所みたいなのを書いてある。
ちゃんと、アンチパターンを挙げるだけでなくじゃあ代わりにどうしたら上手く解決出来るのか、とかアンチパターンとは言ったがこういう場合は使っていいだとか建設的な議論がされている。
ここで挙げられているアンチパターンには実際に問題が明みになるまでアンチパターンと気付けないようなものも少なくなく、この本で予習するかしないかで生死が分かれる。
テーブル設計のミスは中々に致命的である。&lt;/p&gt;

&lt;h1 id=&#34;43-理論から学ぶデータベース実践入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;43. 理論から学ぶデータベース実践入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774171972&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;アンチパターンは超絶実践的な話だったがこちらは理論の話。リレーション代数や正規形の話、インデックスのアルゴリズムなど。第4正規形だとか関数従属性だとかが分からないならこの本を読むといい。&lt;/p&gt;

&lt;p&gt;型がある人がやるから型破りとはいう実用上正規形を崩すにせよがまずはこの本で理論的に綺麗なテーブル設計を知ると良いと思う。&lt;/p&gt;

&lt;h1 id=&#34;44-redis入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;44. Redis入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4048917358&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Redisの機能を使いつつアプリケーションをいくつか作っていく。最初読んだ時に割と「そこまでRedisでやるのか」と思った。
入門とはいいつつもシャーディングやLuaによるスクリプティングなども取り扱っており、中々読み応えがある。&lt;/p&gt;

&lt;h1 id=&#34;45-7つのデータベース-7つの世界:390eeec2ebe741f3494b487839fdedf9&#34;&gt;45. 7つのデータベース 7つの世界&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274069087&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;先に7つの言語 7つの世界を挙げたがこの本も良書だ。むしろ私はこちらの方が好きだ。&lt;/p&gt;

&lt;p&gt;PostgreSQL、 Riak、 Redis、 HBase、 MongoDB、 CouchDB、 Neo4j。思うに、プログラミング言語に比べてデータベースは重くて気軽には試せない。
それを考えると7つというのは非常に大きな数字だ。色々なデータベースを知って適材適所使おうと思うならこの本こそ最適だ。&lt;/p&gt;

&lt;h1 id=&#34;46-適応的分散アルゴリズム:390eeec2ebe741f3494b487839fdedf9&#34;&gt;46. 適応的分散アルゴリズム&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4320122518&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本は昔図書館で借りて読んだ。なんとなく名前だけに惹かれて借りた。そして退屈だなと思いつつ読み終わって返した。
しかしそれから幾許か。分散データベースやアクターモデルなんかが頻繁に出てくるようになってよくこの本を思い出す。&lt;/p&gt;

&lt;p&gt;ノードとノードの間にどれだけ遅延があるかも分からないメッセージが届かないかもしれないノードが故障しているかもしれない、あるいは間違った情報を送ってくるかもしれない。
そんな中で合意形成したりリーダを選出したりマルチリードマルチライトなメモリを作ったりと面白いことを議論してある。&lt;/p&gt;

&lt;p&gt;次本屋で見付けたら絶対書いたい。そんな本。&lt;/p&gt;

&lt;h1 id=&#34;47-parallel-and-concurrent-programming-in-haskell:390eeec2ebe741f3494b487839fdedf9&#34;&gt;47. Parallel and Concurrent Programming in Haskell&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B00DWJ1BIG&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Hey Hey Haskell本(?)。和訳も出ている。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873116899&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&#34;http://community.haskell.org/~simonmar/pcph/&#34;&gt;オンラインで読める&lt;/a&gt;のでそれで読んだ。
内容がHaskellと密結合しているのでなんとなくでもHaskellを読めないとこの本も読めない。&lt;/p&gt;

&lt;p&gt;個々のプログラミング言語の機能の1つとして並列/並行のAPIについて述べられていることはあるがここまで様々に扱っているのは見たことがない。
よく「これ以上詳しく書こうとすると本が一冊書けてしまう」と流される部分を実際に本一冊書いてしまったような内容。&lt;/p&gt;

&lt;p&gt;並列/並行プログラミングに興味があるならHaskellを読めるようになってこの本を読むと良いと思う。&lt;/p&gt;

&lt;h1 id=&#34;48-reactive-messaging-patterns-with-the-actor-model:390eeec2ebe741f3494b487839fdedf9&#34;&gt;48. Reactive Messaging Patterns with the Actor Model&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B011S8YC5G&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;デザインパターンのアクター版。Akkaを題材に扱っている。
これこそ「人類が既に解決している問題」であり、Akkaを使うにあたって読むといいと思う。
Akkaに固有の話もあるが大部分はBeamVMを始めとした他のアクターシステムにも共通する内容になる。&lt;/p&gt;

&lt;p&gt;Akkaを使う各社で読書会が開かれてその内和訳が出るところまで見えた。&lt;/p&gt;

&lt;h1 id=&#34;49-unicode標準入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;49. Unicode標準入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4798100307&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;自分の作ったLispでマルチバイト文字を扱おうと思うとUnicodeについては避けて通れない。
バイト列とエンコーディングとコードポイントと文字集合と文字とグリフとフォントと、これらの違いと関係について分かってないのならUnicodeについて勉強した方がいい。
ただでさえ複雑なUnicodeなのに基本の概念が分かってないのなら話にならない。&lt;/p&gt;

&lt;p&gt;扱っているのがUnicode3.0とやや古いものの基本的な部分は変わらない。というか、最近のUnicodeのバージョンアップは文字集合が拡大されているだけと思ってるんだけど合ってるかな？&lt;/p&gt;

&lt;h1 id=&#34;50-セキュリティコンテストチャレンジブック:390eeec2ebe741f3494b487839fdedf9&#34;&gt;50. セキュリティコンテストチャレンジブック&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4839956480&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;セキュリティコンテストに興味がなくてもこの本は役に立つ。
プログラマなら「こういうコードを書くと脆弱性になる」とは知っていても実際にどういう攻撃が可能なのか知っている人はそんなにいないのではないか。
この本を読めば少しは分かるようになる。話題もバイナリ解析からネットワーク、Web、SQLと色々ある。&lt;/p&gt;

&lt;p&gt;ところで今目次をみたら酷い誤植があった。やたらバイナリ解析したいらしい。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;おわりに:390eeec2ebe741f3494b487839fdedf9&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;お気に入りの本を挙げていったら50冊近くあったのでキリ良く50冊にした。
思ったよりも50冊は多くて、日曜日の半分が潰れたが色々吐き出せてよかった。&lt;/p&gt;

&lt;p&gt;みんなアフィ踏んでね！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>プログラミングを独学する時こそインプットを増やした方がいい</title>
      <link>/blog/2016/01/17/puroguraminguwodokugakusurutokikosoinputtowofuyashitahougaii</link>
      <pubDate>Sun, 17 Jan 2016 13:38:03 +0900</pubDate>
      
      <guid>/blog/2016/01/17/puroguraminguwodokugakusurutokikosoinputtowofuyashitahougaii</guid>
      <description>&lt;p&gt;巷でよく「アウトプットを増やせ」というのを聞くが個人的な意見としてインプットを増やした方が良いと思っているのでそれについて書く。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//KeenS.github.io/blog/2014/12/18/du-xue-falsepuroguramingu/&#34;&gt;以前&lt;/a&gt;少し書いたことがあるが、私はプログラミングを独学で学んだ。
その時インプットがメインでほとんどアウトプットをしてこなかった。今でもそれは正解だったと思っている。何故か？
答えは簡単で、「学ぶ」ということは情報を仕入れる、要はインプットのことを指しているからだ。それに独学でない人、つまり情報学科なんかにいる人は死ぬほど勉強している訳でちょろっと勉強したくらいでは到底太刀打ち出来ない。&lt;/p&gt;

&lt;p&gt;全くアウトプットが必要ないかというとそうとも思っていない。アウトプットの瞬間に今まで仕入れた知識が自分に定着するからだ。
インプットとアウトプットどれくらいの比率でやればいいのかというと「インプットが溢れ出した時」にアウトプットすればいいと思っている。&lt;/p&gt;

&lt;p&gt;ただ目だけで追った情報は自分の中ではぼんやりしていて形を成していない。
コードなり文書なりの形にアウトプットする時に同時に自分の中で形を成す。あるいは半知半解の部分が明みになって理解の手向けとなる。
そのぼんやりとしたものが形を成す瞬間が一番成長しているように感じるのでよく「アウトプットを増やせ」と言われるのではと思っている。
しかしそれはぼんやりとした情報が定着しているだけであって知識が増えている訳ではない。アウトプットの時に定着するものは今までのインプットに比例する。インプットがなければアウトプットの時の成長もない。
かといって定着させることなく情報を仕入れ続けると不安になる。あるいは、仕入れた知識を試してみたくなる。そういう時にアウトプットすればいいと思っている。
私はそれを「インプットが溢れた」と呼んでいる。&lt;/p&gt;

&lt;p&gt;もう1つインプットを増やした方が良いと思っているのは大抵の問題は人類は既に解決しているからだ。無理にアウトプットしようと1時間掛けて悩むよりも10分掛けて解決法を学んだ方が手っ取り早い。
プログラミングを独学しようと思うと莫大な時間が必要になる。独学に取れる時間が有限ならば短時間で解決出来る方法を選ぶべきだ。
問題解決能力なんて手札が揃ってから考えればいい。碌な手札も持ってないのにそれで解決しようとするのは無理がある。まずは手札を揃えるべきだ。世の中のプログラマと同じ手札を揃えないとそもそも同じ土俵で戦えない。&lt;/p&gt;

&lt;p&gt;ここで1つ言及しておきたいのが毎日ブログ問題だ。「毎日技術ブログを書き続けろ。つらくてもいいから続けろ。続けた先に見えるものがある。」なんて言われることがある。あれはあまり良くないと思っている。
本当に初学者の時は毎日くらいの頻度でインプットが溢れるかもしれない。しかしその期間は長くは続かない。ちゃんと学んで成長していればインプットのバッファも大きくなる。
すぐに1日の勉強量ではインプットが溢れなくなる。そうなった時にも毎日ブログを書く意味はない。ブログを書くのにも時間が取られるのを忘れてはいけない。ブログを書く達人になりたいのでもなければ時間を使う意味はさしてない。
それよりは平日に進めて土日で仕上げて日曜の夜にそれについてブログを書く、とかの計画的なサイクルを回した方が良い。あるいはもっと長いスパンで。&lt;/p&gt;

&lt;p&gt;1つ、インプットばかりしていると懸念が生じる。それは実用上の問題ではなく自己満足とか成果とかの問題、精神上の問題だ。
何かを学ぶ以上成果が欲しくなる。特に実学なら実用的な成果が欲しくなる。学んではいるものの目に見える成果がないと不安になる。
例えば職のためにプログラミングを始めた人なら切実に成果が欲しいだろう。これについては私は今のところ有効な解決策を見付けていない。
目標のある人はどれだけ目標に近付いているかで測れるかもしれないが私には目標がなかった。
同じくらいの習熟度の人と比べるのが良さそうだが、独学同士相手を見付けるのは中々難しい。同学年の情報科学科の人と比べると正規軍に徒手空拳で挑むようなもので話にならない(そういう経験がある)。
時折たまに溢れ出たアウトプットを眺めてちゃんと前に進んでいるんだと自分に言い聞かせてきた。
不思議と、就職に関してもそれでどうにかなった。目に見える形にはなっていなくても面接などで話すと分かるのだろう。結局、不安は不安のまま抱え続けるしかなかった。独学とはそういうものなのかもしれない。&lt;/p&gt;

&lt;p&gt;私も大学生でプログラミングに目覚めて今丁度丸4年。去年の4月からプログラマとして働いているが未だインプットの足りなさをひしひしと感じる。働きながら勉強を続けるが中々時間がとれない。
時間のある学生の時にもうちょっと効率的にインプットを増やしていたらと思う。そういう後悔をする人を一人でも減らそうと思ってこういう記事を書いてみた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Isabelleに入門した</title>
      <link>/blog/2016/01/12/isabelleninyuumonshita</link>
      <pubDate>Tue, 12 Jan 2016 22:23:45 +0900</pubDate>
      
      <guid>/blog/2016/01/12/isabelleninyuumonshita</guid>
      <description>

&lt;p&gt;κeenです。連休中にIsabelleを少しばかり触ったのでその時のまとめを。&lt;/p&gt;

&lt;h1 id=&#34;isabelleって:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;Isabelleって？&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://isabelle.in.tum.de/&#34;&gt;公式&lt;/a&gt;。定理証明支援系の一つ。SML処理系の1つ、Poly/MLで書かれている。
どうやらHOL(Higher Order Logic)に焦点を当てているようだが詳しいことは分かっていない。&lt;/p&gt;

&lt;p&gt;あと、Linuxが正式にはGNU/LinuxというようにIsabelleもIsabelle/Isar/HOLと言うべきらしいが、まだよく分かっていない。&lt;/p&gt;

&lt;h1 id=&#34;インストール:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;インストール&lt;/h1&gt;

&lt;p&gt;公式サイトからダウンロード出来るが、後述のProofGeneralの関係上Isabelle2014をインストールする。&lt;/p&gt;

&lt;h1 id=&#34;エディタ設定:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;エディタ設定&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ProofGeneral/PG&#34;&gt;ProofGeneral&lt;/a&gt;を使う。恐らくGitHub版を使った方がいい。設定は1行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(load (expand-file-name &amp;quot;/path/to/ProofGeneral/generic/proof-site&amp;quot;) nil t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くだけ。多分&lt;code&gt;prettify-symbol-mode&lt;/code&gt;も自動でonになる。(なってなかったらなんか適当に設定しておこう。global-prettify-symbols-modeとかで。)
Isabelleの古いドキュメントを見てるとX-Symbolsモードなるものが出てくるが、恐らく現在の&lt;code&gt;prettify-symbol-mode&lt;/code&gt;だと思う。&lt;/p&gt;

&lt;h1 id=&#34;はじめる:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;はじめる&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;isabelle.in.tum.de/doc/tutorial.pdf&#34;&gt;この&lt;/a&gt;チュートリアルを進めている。まだ途中。タクティックも&lt;code&gt;tactic_ind&lt;/code&gt;と&lt;code&gt;auto&lt;/code&gt;しか知らない。&lt;/p&gt;

&lt;p&gt;とりあえず拡張子は.thyにしとくとEmacsが認識してくれる。&lt;/p&gt;

&lt;h1 id=&#34;所感:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;所感&lt;/h1&gt;

&lt;p&gt;Coqを触ったことあるとそれなりにスムーズに入れた。ただしダブルクォートはキモい。
Coqも3つくらいの言語が混ってるらしいのでその内のGallinaの部分をクォートで囲っている感じなのだろうか。
クォートの部分はHOLがどうのこうの言ってた気がする。&lt;/p&gt;

&lt;p&gt;まだどんなことが出来るのか分からないのでCoqの方がマシじゃんという感想しかない。&lt;/p&gt;

&lt;h1 id=&#34;困ったところ:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;困ったところ&lt;/h1&gt;

&lt;p&gt;チュートリアル中に数学記号が出てくる。∀とか∃とか¬とか。断りもなしにソースコード中にも。
最初、組版の都合上置き換えたのだろうとCoqのようにforall, exists, notと打っていたがエラーになった。じゃあ、とユニコードで打ってみてもエラーになった。
結局、TeXのようにコマンドを入力するとWYSIWYGのようにシンボルになるらしい。
さらにややこしいことにEmacsに特定のシーケンスでキーを入力するとそのコマンドを挿入してくれる機能がついている。&lt;/p&gt;

&lt;p&gt;とりあえず今のところ分かっているものをまとめる&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;見た目&lt;/th&gt;
&lt;th&gt;Emacsでの入力&lt;/th&gt;
&lt;th&gt;実際のタグ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;∀&lt;/td&gt;
&lt;td&gt;\forall&lt;/td&gt;
&lt;td&gt;&amp;lt;forall&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;∃&lt;/td&gt;
&lt;td&gt;\exists&lt;/td&gt;
&lt;td&gt;&amp;lt;exists&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;¬&lt;/td&gt;
&lt;td&gt;\not&lt;/td&gt;
&lt;td&gt;&amp;lt;not&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;∧&lt;/td&gt;
&lt;td&gt;\and, /&lt;/td&gt;
&lt;td&gt;&amp;lt;and&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;∨&lt;/td&gt;
&lt;td&gt;\or, \/&lt;/td&gt;
&lt;td&gt;&amp;lt;or&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;⇒&lt;/td&gt;
&lt;td&gt;\Rightarrow, =&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;Rightarrow&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;→&lt;/td&gt;
&lt;td&gt;\rightarrow, -&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;rightarrow&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;≡&lt;/td&gt;
&lt;td&gt;\equiv, ==&lt;/td&gt;
&lt;td&gt;&amp;lt;equiv&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;≠&lt;/td&gt;
&lt;td&gt;\noteq, ~=&lt;/td&gt;
&lt;td&gt;&amp;lt;noteq&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;なんかそれっぽい記号を連ねてみたら色々出てきた。けどユニコード入力出来ないから載せれないw。&lt;/p&gt;

&lt;p&gt;逆引きしたい。見た目からコマンドを知りたい。&lt;/p&gt;

&lt;p&gt;なんかまとまりないけどそんな所で。頭痛い。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#のpthreadバインディング作った</title>
      <link>/blog/2016/01/11/sml_nopthreadbaindingutsukutta</link>
      <pubDate>Mon, 11 Jan 2016 00:57:20 +0900</pubDate>
      
      <guid>/blog/2016/01/11/sml_nopthreadbaindingutsukutta</guid>
      <description>

&lt;p&gt;κeenです。またしても深夜になってしまいましたがSML#のpthreadバインディングを作ったのでその報告を。&lt;/p&gt;

&lt;p&gt;SML#はC FFIを簡単に書け、さらにランタイムがnon Moving GCなのでSML#自体はサポートしていないもののランタイムそのものはマルチスレッドに対応しているという大変興味深い特徴を持っています。
処理系側としてもマルチスレッドが欲しいならpthreadのFFIを使って好きにやってくれというスタンスのようです。&lt;/p&gt;

&lt;p&gt;ということでさまざまなマルチスレッドアプリケーションの下地になるべくpthreadのバインディングを作りました。とはいってもまだ不完全ですが。&lt;/p&gt;

&lt;p&gt;どういうものが用意出来ているかは&lt;a href=&#34;https://github.com/KeenS/smlsharp_pthread/blob/master/src/pthread.smi&#34;&gt;こちら&lt;/a&gt;が一覧として機能しています。&lt;/p&gt;

&lt;p&gt;SML的には改善の余地がある(例えば、排他的なフラグをdatatypeで定義するとか)のですが、あくまで低レベルなバインディングに徹するためにintのままで残してあります。&lt;/p&gt;

&lt;p&gt;他にはCのマクロで実現されていたものはインポート出来ないのでどうにかしてあったりどうにかしてなかったりしてます。
例えば&lt;code&gt;PTHREAD_XXX_INITIALIZER&lt;/code&gt;はマクロで定義された初期値ですが、SMLからは参照出来ないのであきらめました。
代わりに&lt;code&gt;pthread_xxx_new&lt;/code&gt;関数を用意したので&lt;code&gt;pthread_xxx_init&lt;/code&gt;と併せて使うことでそれらの値を初期化出来ます。
メモリ確保と初期化同時にやれよとの声が聞こえてきそうですが繰り返すとあくまで低レベルなバインディングなのでそういうのは他に譲ることにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pthread_cleanup_{pop/push}&lt;/code&gt;はバインディングが書けませんでした。
それらはマクロとして実現されていて、しかも&lt;code&gt;pthread_cleanup_push&lt;/code&gt;で開き括弧を挿入して&lt;code&gt;pthread_cleanup_pop&lt;/code&gt;で閉じるというエグい実装なので移植は無理でしょう。
POSIX的にもマクロとして実現して良いことになっているので文句は言えません。&lt;/p&gt;

&lt;h1 id=&#34;サンプルコード:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;サンプルコード&lt;/h1&gt;

&lt;p&gt;レポジトリにも入ってますが、スレッドを作る小さな例だとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;open PThread
fun exit reason = (
    print (reason ^ &amp;quot;\n&amp;quot;);
    OS.Process.exit OS.Process.failure
)


val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr
(* durty hack *)
val sml_str_new = _import &amp;quot;sml_str_new&amp;quot;: (string) -&amp;gt; char ptr

fun threadFunc (arg:unit ptr): unit ptr = let
    val cp: char ptr = fromUnitPtr arg
    val s = Pointer.importString cp
    val () = print s
    (* val ret =ref _NULL *)
    (* val () = ret := (String.size s) *)
in
    (* ret *)
    _NULL
end
                   
val () = let
    val tattr = ref (pthread_attr_new())
    val s = pthread_attr_init(tattr)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;pthread_attr_init&amp;quot;
             else ()
    val thread_ref = ref (pthread_new())
    val arg = sml_str_new &amp;quot;Hello world\n&amp;quot;
    val s = pthread_create(thread_ref, tattr, threadFunc, toUnitPtr arg)
    val t1 = !thread_ref
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;thread creation failed&amp;quot;
             else ()
    val s = pthread_attr_destroy(tattr)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;pthread_attr_destroy&amp;quot;
             else ()
    val () = print &amp;quot;Message from main()\n&amp;quot;;
    val resRef = ref (Pointer.NULL ())
    val s = pthread_join(t1, resRef)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;thread creation failed&amp;quot;
             else ()
    (* val () = print (&amp;quot;Thread returned&amp;quot; ^ Int.toString  (!resRef) ^ &amp;quot;\n&amp;quot;) *)
in
    ()
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;言わずとも雰囲気で読み取れそうですがこの例はCのサンプルをそのまま移植しました。Cだと&lt;code&gt;(void *)&lt;/code&gt;と文字列で相互変換が出来るのですがSML#だと一筋縄では出来ないので内部APIを叩くとかのかなりアレなハックしてます。
&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/45&#34;&gt;SML#にイシューに上げ&lt;/a&gt;ましたが&lt;code&gt;(void *)&lt;/code&gt;が強敵ですね。&lt;/p&gt;

&lt;h1 id=&#34;可搬性の話:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;可搬性の話&lt;/h1&gt;

&lt;p&gt;ところで、pthreadはp(POSIX)の名が付いている通り様々なプラットフォームで利用出来、そしてそれぞれのプラットフォーム毎に実装が異なります。
勿論、POSIXで定められているのでAPIレベルでは互換性がある(≒関数のバインディングは問題ない)のですが、ABI、データの表現に互換性がありません(≒データ型のバインディングに問題がある)&lt;/p&gt;

&lt;p&gt;実はその辺で苦労がありました。今のところ手元の環境(Linux)でしか移植が済んでません。しかし他のプラットフォームの移植は書ける形になっています。
これは&lt;a href=&#34;//KeenS.github.io/blog/2015/12/26/sml_tocpuripurosessanorenkei/&#34;&gt;以前&lt;/a&gt;書いたSMLのファイルにCのプリプロセッサを適用するというなんともいえないハックを使うことで実現しています。
他のプラットフォームに移植するには&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;どういうマクロが定義されている時にどのプラットフォームのpthreadを使っているかの対応を調べる&lt;/li&gt;
&lt;li&gt;そのプラットフォームの&lt;code&gt;pthread.h&lt;/code&gt;を入手してデータ型を移植する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;手順が必要です。私は手元の環境で動かすのが精一杯なのでMacとかで動かしたい方がいればプルリクを頂けると。
前述の通り、関数のバインディングは可搬性があるので必要なのはデータ型と定数の移植です。ある程度はプリプロセッサも使えるのでほぼヘッダファイルを移植する感じですね。&lt;/p&gt;

&lt;p&gt;まあ、実をいうと関数の移植も細々したものが面倒なので放置していたりします。ここら辺は作業ゲーなので気が向いたらやります。&lt;/p&gt;

&lt;p&gt;あとは若干迷っているのが必ずしも実装されているとは限らないオプショナルな機能の移植ですね。
バリアやリードライトロック、スピンロックがそれにあたります。
可搬性とはいってもSML#自身が動く環境が限られているのでMacでもそれらが使えるなら移植してしまおうかと思っていますがまだ調べきれてません。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;pthreadのバインディング作ったよ&lt;/li&gt;
&lt;li&gt;まだバインドが書かれてない関数もあるよ&lt;/li&gt;
&lt;li&gt;Macの移植パッチ待ってるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rustといえどリソースの解放は注意</title>
      <link>/blog/2016/01/08/rusttoiedoriso_sunokaihouhachuui</link>
      <pubDate>Fri, 08 Jan 2016 00:50:31 +0900</pubDate>
      
      <guid>/blog/2016/01/08/rusttoiedoriso_sunokaihouhachuui</guid>
      <description>&lt;p&gt;κeenです。深夜にですが小ネタを。&lt;/p&gt;

&lt;p&gt;Rustを使っているとついついリソースの解放のことは忘れてしまうのですが、注意しないといけない類のリソースがあります。&lt;/p&gt;

&lt;p&gt;その1つが&lt;code&gt;BufWriter&lt;/code&gt;です。
バッファリングライター全般に言えることですが、奴らはメモリ上にまだ書き込まれてない値を保持しているので解放する前にそれらを掃き出す必要があります。
その時に書き込み例外が起き得るので、解放も安全な処理ではないのです。Javaのtry-with-resource文を使わないファイルの扱いについては悪名高いですが、あれは仕方ない話なのです。&lt;/p&gt;

&lt;p&gt;ところでRustのリソースの解放は&lt;code&gt;Drop&lt;/code&gt;トレイトの&lt;code&gt;drop&lt;/code&gt;が担っていますが、返り値は&lt;code&gt;void&lt;/code&gt;です。基本的には裏で動くので当然ですね。
そして、&lt;code&gt;drop&lt;/code&gt;はpanicを起こさないことが望ましいです。Rustは今のところ(1.5時点)panicから回復出来ないのでそれはそうでしょう。では、エラーを返り値でも返せない、panicも起こせない中&lt;code&gt;BufWrite&lt;/code&gt;はどうエラーを扱っているのでしょう。それは実装を見ると分かります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;W: Write&amp;gt; Drop for BufWriter&amp;lt;W&amp;gt; {
    fn drop(&amp;amp;mut self) {
        if self.inner.is_some() {
            // dtors should not panic, so we ignore a failed flush
            // 訳: dropはパニックすべきではない、だからflushの失敗は無視する
            let _r = self.flush_buf();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…はい。中々アレなことをやってくれますね。&lt;/p&gt;

&lt;p&gt;ということで&lt;code&gt;BufWrite&lt;/code&gt;を使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
  let file = File::create(&amp;quot;some_file.txt&amp;quot;).unwrap();
  let br = BufWrite::new(&amp;amp;file);

  // do something

  match br.flush_buf() {
    Ok(()) =&amp;gt; (),
    Err(e) =&amp;gt; // handle errors
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにライフタイムの終わりで&lt;code&gt;flush_buf&lt;/code&gt;を呼ぶのが作法的な方法です。
&lt;code&gt;unwrap&lt;/code&gt;と同じく掃き出せない時に無視されてもいいならそこまでする必要はありませんが、それでもスコープの終わりに意図的に&lt;code&gt;flush_buf&lt;/code&gt;を呼んでない旨を書くと丁寧でしょう。&lt;/p&gt;

&lt;p&gt;因みにスコープが大きすぎる時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
  let file = File::create(&amp;quot;some_file.txt&amp;quot;).unwrap();
  {
    let br = BufWrite::new(&amp;amp;file);
  
    // do something with br
  
    match br.flush_buf() {
      Ok(()) =&amp;gt; (),
      Err(e) =&amp;gt; // handle errors
    }
  }
  
  // do other things

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにスコープを作って不要なライフタイムを切り詰めるイディオムもあるので併せてどうぞ。&lt;/p&gt;

&lt;p&gt;余談ですが&lt;code&gt;std::fs::File&lt;/code&gt;の実体はCの&lt;code&gt;FILE&lt;/code&gt;構造体ではなくファイルディスクリプタなのでバッファリングはしてません。のでこちらは気にする必要はありません。&lt;/p&gt;

&lt;p&gt;という訳で小ネタでした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016年注目していきたい技術</title>
      <link>/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu</link>
      <pubDate>Fri, 01 Jan 2016 20:09:36 +0900</pubDate>
      
      <guid>/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu</guid>
      <description>

&lt;p&gt;2016年個人的に注目したいというか力を入れたいというか成行を見守りたいというか、そんな技術達を書き連ねていく。ものによっては「何を今更」と思うかもしれないがあくまで私にとって、だ。&lt;/p&gt;

&lt;p&gt;順不同。&lt;/p&gt;

&lt;h1 id=&#34;apache-drill:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Apache Drill&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://drill.apache.org/&#34;&gt;公式&lt;/a&gt;。様々なデータソースに対してANSI SQLでクエリを投げれるやつ。
ビッグデータの時代にETL無しで迅速にデータを分析出来るようにするために開発されてるらしい。&lt;/p&gt;

&lt;p&gt;様々なデータソースというのは本当に凄くて、CSVとJSONをJOIN出来たりする。
あるいはTSVの生ログとRDBにあるマスタデータをJOIN出来たりする。
個人的にはデータベースから抽出したCSVにクエリを投げたい時に便利かな、と思って注目してる。viewや一時テーブルを作る権限がないデータベースだってある。&lt;/p&gt;

&lt;p&gt;あるいは、Zookeeperを使って分散モードで実行も出来るのでBigQueryみたいなのをオンプレ環境で動かすのにも使えるようだ。
その時はデータフォーマットは&lt;a href=&#34;https://drill.apache.org/docs/parquet-format/&#34;&gt;Parquet&lt;/a&gt;で保存すると速いらしい。&lt;/p&gt;

&lt;h1 id=&#34;rust:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Rust&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;。言わずもがな。去年の5月に1.0が出て、今年で一周年を迎える。そろそろ安全なシステムプログラミング言語としての地位を築いて欲しい。
今までは安全なシステムプログラミング言語が不在で、不適切にも関らずJavaで代用されることが多かったように思える。&lt;/p&gt;

&lt;p&gt;やっぱりGCがあると安定性に心配が残るし、フルマネージングなランタイムシステムを持ってると他のランタイム、例えばlibuvなんかと相性が悪い。&lt;/p&gt;

&lt;p&gt;かといってC++やCだと安全でない。システムが巨大になった時にデバッグがつらくなる。&lt;/p&gt;

&lt;p&gt;Rustには是非Javaより速くて実行が安定しててC++よりも安全でCよりも抽象力があってマルチスレッドを使い始めても開発効率が落ちない言語として活躍して欲しい。&lt;/p&gt;

&lt;h1 id=&#34;kafka:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Kafka&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/&#34;&gt;公式&lt;/a&gt;。「ただのキュー」と言ってしまえばそれまでだが高トラフィックを捌ける信頼性の高いキューだ。
OSのキャッシュを上手く使ってるだとかJavaだからといって富豪的プログラミングをしてないだとか分かってる人が作った感じがしてすごくいい。&lt;/p&gt;

&lt;p&gt;fluentdとかでデータを流すにしてもバックプレッシャーをやりたい、流す先が落ちてた時の事を考えたい、バッチじゃなくてストリーム（ミニバッチでもいいけど）でやりたい、とかの要望に応えてくれる。&lt;/p&gt;

&lt;h1 id=&#34;floki:1c55afff208b866183fc0b210a2a3f36&#34;&gt;floki&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/arthurprs/floki&#34;&gt;Github&lt;/a&gt;。Rustで作られているキュー。
kafkaに言及しているがRedisプロトコルをベースとしていて、色々コマンドがあるようなのでkafkaとは少し毛色が違いそう。&lt;/p&gt;

&lt;p&gt;別にこれが次世代キューだ！なんて思ってる訳ではなくてRustで作られたミドルウェアがどうなっていくのか興味があるので観察対象に入っている。&lt;/p&gt;

&lt;h1 id=&#34;robots:1c55afff208b866183fc0b210a2a3f36&#34;&gt;RobotS&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gamazeps/RobotS&#34;&gt;Github&lt;/a&gt;。RustのActor System。ほぼakkaの移植みたいだ。&lt;/p&gt;

&lt;p&gt;Rustにアクターシステムが必要かは置いておいて、アクターシステムをRustの上に作るのは正解だと思ってる。
何故ならJVMや.NETのようにStop The Worldはないし、Erlangとは比べものにならないくらい速い。
さらに、もしかしたらだが、Rustなら所有権があるのでうまくすればメッセージを送るのにメモリコピーが起きないかもしれない。
まあ、Go使えばいいじゃんと言えばそれまでである。&lt;/p&gt;

&lt;h1 id=&#34;redox:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Redox&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.redox-os.org/&#34;&gt;公式&lt;/a&gt;。Rustで開発されているOS。まだまだ開発途上だがゆくゆくはMINIXくらいの地位は築いて欲しい。
コマンドは全然ないのにGUIは動いていたりZFSをサポートしていたりする。開発者は「本気でやってる」と言っていたのでそれなりのものは出来るんだろうと期待している。&lt;/p&gt;

&lt;p&gt;コマンド群は、Rustでcoreutilsを書き直そうという&lt;a href=&#34;https://github.com/uutils/coreutils&#34;&gt;coreutils&lt;/a&gt;というプロジェクトがある。それを使えると面白いんじゃないかと思っている。
こういう時ってまずはRustのコンパイラの移植をしないといけないのかな？よく分かってない。&lt;/p&gt;

&lt;h1 id=&#34;ats2:1c55afff208b866183fc0b210a2a3f36&#34;&gt;ATS2&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ats-lang.org/&#34;&gt;公式&lt;/a&gt;。線形型が肌で感じられる体になりたい。そのために修行したい。&lt;/p&gt;

&lt;p&gt;SML likeなシンタックスなので学習コストが低い。依存型の部分もCoqに似てる気がするのでそこも学習コストが低い。つまり線形型の学習に集中出来る。
ほとんど実用ではなく修行のために学習したい。もしかしたらアプリケーションくらい作れるのでは、とも思っている。
あとCとの相互連携が出来るのも良い。&lt;/p&gt;

&lt;h1 id=&#34;r:1c55afff208b866183fc0b210a2a3f36&#34;&gt;R&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.r-project.org/&#34;&gt;公式&lt;/a&gt;。最近データを扱うことが多くなった。そういう時に簡単に可視化が出来るこの言語は素晴しい。
まだほとんどコピペでしか動かしてないが、ちょこっとした分析くらいなら自分の手で書けるようになりたい。&lt;/p&gt;

&lt;h1 id=&#34;異常検知:1c55afff208b866183fc0b210a2a3f36&#34;&gt;異常検知&lt;/h1&gt;

&lt;p&gt;機械学習というとぼんやりしてるので絞ってみる。時系列データにスパイクがあったり、集団から外れた値があるのを検出する。
これが出来れば職人が手作業で検査していたものを自動化出来る。こういうのをやってみたいなぁとぼんやり願ってはいるがまだ遠い。&lt;/p&gt;

&lt;h1 id=&#34;coq:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Coq&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://coq.inria.fr/&#34;&gt;公式&lt;/a&gt;。&lt;a href=&#34;http://proofcafe.org/sf/&#34;&gt;ソフトウェアの基礎&lt;/a&gt;をずっとやっていたが、ProofGeneralのバグなのか、とある証明を食わせるとProofGeneralがフリーズするようになって以来途絶えている。
バグを直すか回避策を見付けるかして先に進みたい。こちらが終わったら次は&lt;a href=&#34;http://www.amazon.co.jp/Interactive-Theorem-Proving-Program-Development/dp/3540208542&#34;&gt;CoqArt&lt;/a&gt;がある。
&lt;a href=&#34;https://twitter.com/search?q=%23readcoqart&amp;amp;src=typd&amp;amp;lang=ja&#34;&gt;#readcoqart&lt;/a&gt;にも行く行く詐欺をしてるので行かねば。&lt;/p&gt;

&lt;h1 id=&#34;isabelle:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Isabelle&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://isabelle.in.tum.de/&#34;&gt;公式&lt;/a&gt;。SMLユーザとしてはCoqをやるならIsabelleもやらないとな、と思っている。
&lt;a href=&#34;http://qiita.com/myuon_myon/items/11bb5bfc2e274fdaea7c&#34;&gt;ここ&lt;/a&gt;によるとCoqとはまた違った証明のやりかたらしいのでそういう意味でもやる意味あるのかな、とか。
Coqが終わってさらに手が空いてたら、くらい。&lt;/p&gt;

&lt;h1 id=&#34;prolog:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Prolog&lt;/h1&gt;

&lt;p&gt;修行の1つとしてPrologをやりたい。というか、作りたい。その前にまずはPrologを書けるようになりたい。
少しやってみているが、GNU PrologもSWI PrologもただのPrologとしか呼ばれていなくて情報を見付けるのに苦難している。
Lispみたくそれっぽい見た目と挙動をしていたらPrologを主張出来るのだろう。&lt;/p&gt;

&lt;p&gt;今気になっているのは制約ソルバとPrologの関係。
もし制約ソルバでPrologを実装出来るなら実装をサボれるし制約ソルバを触ってみれる。ただ、制約ソルバがチューリング完全な気がしないので使えるとしても部分的な気がする。&lt;/p&gt;

&lt;h1 id=&#34;fortran:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Fortran&lt;/h1&gt;

&lt;p&gt;神託の言語。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;κeen が 2016 年に新たに学ぶべき言語は『Fortran』です。&amp;#10;&lt;a href=&#34;https://twitter.com/hashtag/1year1lang?src=hash&#34;&gt;#1year1lang&lt;/a&gt;&amp;#10;&lt;a href=&#34;https://t.co/sDP4Kk2Vfx&#34;&gt;https://t.co/sDP4Kk2Vfx&lt;/a&gt;&amp;#10;&amp;#10;うっ。。ぐ。。。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/682535448124637184&#34;&gt;2015, 12月 31&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;まあ、ベクトル計算楽そうだし機械学習の手習いついでにアルゴリズムを実装してみるのも悪くないのかな、と思えてきた。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;思ったより言語の話題が多かった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ATS2の観が整理出来た</title>
      <link>/blog/2016/01/01/ats2nokangaseiridekita</link>
      <pubDate>Fri, 01 Jan 2016 18:52:56 +0900</pubDate>
      
      <guid>/blog/2016/01/01/ats2nokangaseiridekita</guid>
      <description>

&lt;p&gt;κeenです。ATS2には3つの世界があります。動的な世界、静的な世界、証明の世界。
&lt;a href=&#34;//KeenS.github.io/blog/2015/12/29/ats2noizongatawotsukatteavlki/&#34;&gt;前回&lt;/a&gt;の記事では静的な世界を色々扱ってみました。
今回は証明の世界である観について少し。&lt;/p&gt;

&lt;p&gt;2016-1-2: いくつか誤植を直しました(用語で言えば、 注観→駐観 が正解でした)。&lt;/p&gt;

&lt;h1 id=&#34;観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;観&lt;/h1&gt;

&lt;p&gt;観(view)は、線形型によるリソース管理をするための仕組みです。
静的な世界と同様コンパイル時に検査されたらバイナリには現われませんが関数の引数として渡したり観を扱う関数(証明関数)を定義出来たり
動的な世界と似た部分があります。&lt;/p&gt;

&lt;h1 id=&#34;駐観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;駐観&lt;/h1&gt;

&lt;p&gt;at-viewの和訳だそうです。これは観の中でも特に特定のアドレスにデータが存在することの証明を表わす観です。
線形型の主な管理対象がメモリなので特別扱いされているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;抽象観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;抽象観&lt;/h1&gt;

&lt;p&gt;任意のリソース管理に使っていい観。これ自体は実体を持たないので後述のデータ観などで実体を与える必要があります。
ドキュメントではロックの管理だとかに使う例が載っていました。&lt;/p&gt;

&lt;h1 id=&#34;観型:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;観型&lt;/h1&gt;

&lt;p&gt;ただ単に観と型をくっつけたものです。「あると便利なのは分かるけど…」と思ってましたが、だんだん理解が追いついてきました。&lt;/p&gt;

&lt;p&gt;1つには観と型を1つの記法で表わせるので記述が楽になる。もう1つにはある型に対して必ず線形型によるリスース管理がされることを保証出来る。&lt;/p&gt;

&lt;p&gt;もう1つの用途が思い浮かんだらなるほど、となりました。&lt;/p&gt;

&lt;p&gt;こちらは駐観に限らず任意の観と任意の型を組み合わせれるようです。&lt;/p&gt;

&lt;h1 id=&#34;データ観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;データ観&lt;/h1&gt;

&lt;p&gt;動的な世界でのデータ型のように、静的な世界でのデータ種のように、証明の世界にもデータ観というものがあります。&lt;/p&gt;

&lt;p&gt;例えば、あるかもしれないしないかもしれないリソースを表わすのにオプショナル観が使えそうだ、など。&lt;/p&gt;

&lt;p&gt;これ自体は新しい観を作るためのものです。&lt;/p&gt;

&lt;h1 id=&#34;データ観型:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;データ観型&lt;/h1&gt;

&lt;p&gt;これは動的な世界と証明の世界両方に跨るものです。おおざっぱにはデータ型とデータ観を組み合わせたものです。
つまり、データ型であり、データ観であり、両方合わさってるので観型でもあります。&lt;/p&gt;

&lt;p&gt;「データ型を観で管理しようとしたら同じようなデータ観を作ることになるしまとめて作れたら嬉しいよね」が一番分かりやすい説明でしょうか。&lt;/p&gt;

&lt;p&gt;データ観型専用のシンタックスなどもあるようなので単なるシンタックスシュガーではなさそうです。&lt;/p&gt;

&lt;p&gt;こちらは駐観というかメモリ管理の観が割り当てられるみたいです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Rustと比べると随分リッチなリソース管理が出来ますね。&lt;/p&gt;

&lt;h1 id=&#34;まだ良く分かってない部分:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;まだ良く分かってない部分&lt;/h1&gt;

&lt;p&gt;ATS2にはprop（命題）というものもあります。「観はpropの線形バージョン」と書いてあるのですがどう分けられているのでしょうか。
例えば観型にpropは渡せなそうな気がしますが、証明関数には命題も観も渡せそうな気がします。&lt;/p&gt;

&lt;p&gt;微妙に命題と観が共存していたり排他的であったりします。動的な世界のdatatyp, 静的な世界のdatasort, 証明の世界のdataviewという理解でいるとdatapropの居場所がなくなります。&lt;/p&gt;

&lt;p&gt;今のところ、証明の世界も普通の命題であるpropと線形の命題であるviewに分かれていて、
それらはsortが違うので一部では排他的であり、どちらのsortに対しても対応しているものもあるので共存してるようにも見えるという仮説を立てています。&lt;/p&gt;

&lt;p&gt;ドキュメントにも種viewや種propという記述があるので種がsortが違うのは正しそうです。&lt;/p&gt;

&lt;p&gt;しかしそうするとdatasortとかで新しく作った種はどこの世界に住むことになるんでしょうか。静的な世界?証明の世界に住む新しい種を定義出来ない?&lt;/p&gt;

&lt;p&gt;ビルトインの種viewと種propの静的な項(の静的な項)だけが証明の世界の住人になれる?&lt;/p&gt;

&lt;p&gt;datasortとかで作った新しい種は依存型や依存命題(?)、依存観(?)で使うためにある?&lt;/p&gt;

&lt;p&gt;分からないことが多いですね。もう少しATS2の世界の整理をつけたい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ATS2の依存型を使ってAVL木</title>
      <link>/blog/2015/12/29/ats2noizongatawotsukatteavlki</link>
      <pubDate>Tue, 29 Dec 2015 23:40:45 +0900</pubDate>
      
      <guid>/blog/2015/12/29/ats2noizongatawotsukatteavlki</guid>
      <description>

&lt;p&gt;κeenです。少しばかりATS2を触ってみたので成果報告でも。&lt;/p&gt;

&lt;p&gt;AVL木は左右のノードの高さが高々1しか違わない平衡二分木です。OCamlやSMLでナイーブに実装すると本当に1しか違わないことを保証するのは難しく、精々テストなどで部分的に検査するだけです。&lt;/p&gt;

&lt;p&gt;ところがSMLに似た文法を持つATS2には依存型があり、左右のノードの高さが高々1しか違わないことを型で保証出来ます。
つまり、左右のノードの高さが2以上違う木を作ろうとしてもコンパイルエラーになるのでコンパイルが通れば高さについてはバグがないこと保証されます。&lt;/p&gt;

&lt;p&gt;そういうAVL木を使ってTreeSetを作ってみたので紹介します。&lt;/p&gt;

&lt;p&gt;私のブログ(のこの記事)の読者ならATS2も依存型もAVL木も知ってそうですが一応説明します。&lt;/p&gt;

&lt;h1 id=&#34;ats2って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;ATS2って何?&lt;/h1&gt;

&lt;p&gt;詳しい説明は&lt;a href=&#34;http://jats-ug.metasepi.org/#document&#34;&gt;日本ATSユーザグループ&lt;/a&gt;に譲るとして、この記事にて重要な点を挙げます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SMLに似た文法を持つML方言&lt;/li&gt;
&lt;li&gt;型の部分に型以外の項（例えば整数とか）が使える&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E5%9E%8B&#34;&gt;依存型&lt;/a&gt;を持つ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他にももっと素晴しい型システムや機能、特徴があるのですがとりあえずのところは上記の特徴を押えておいて下さい。&lt;/p&gt;

&lt;h1 id=&#34;依存型って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;依存型って何?&lt;/h1&gt;

&lt;p&gt;先程も述べた通り、ざっくり言うと型の部分に型以外の項が使える型システムです。&lt;/p&gt;

&lt;p&gt;例えば、次のSMLのコードを考えてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Array.get(arr: int array, index: int): int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型から読み取れるのは「&lt;code&gt;int&lt;/code&gt;の配列&lt;code&gt;arr&lt;/code&gt;と整数&lt;code&gt;index&lt;/code&gt;を受け取って&lt;code&gt;int&lt;/code&gt;の値を返す」関数です。
しかしこの関数は&lt;code&gt;index&lt;/code&gt;が&lt;code&gt;arr&lt;/code&gt;の長さよりも大きい時に実行時例外を上げます。内部でメモリを護るために境界チェックをして、チェックに落ちた時に例外を挙げている筈です。。
配列アクセスの度に実行時例外をハンドルするのはコード上もパフォーマンス上も避けたいですよね。
こういうものをコンパイル時に防ぎたくありませんか？無駄な境界チェックを省きたくありまんか？依存型を使えばそれが出来ます。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;array_get{n, i: nat| i &amp;lt; n}(arr: arrayref(int, n), index: int(i)): int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは「長さ&lt;code&gt;n&lt;/code&gt;の&lt;code&gt;int&lt;/code&gt;配列&lt;code&gt;arr&lt;/code&gt;と&lt;code&gt;n&lt;/code&gt;以下の自然数&lt;code&gt;index&lt;/code&gt;を受け取って&lt;code&gt;int&lt;/code&gt;の値を返す」関数です。
正しい入力しか受け取らないので実行時例外が起きませんし内部で境界チェックも必要ありません。面白くないですか？&lt;/p&gt;

&lt;p&gt;私も大して型システムに詳しくないのでこのくらいの例しか挙げることが出来ませんがきっとさらに面白い世界が広がっているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;avl木って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;AVL木って何？&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/AVL%E6%9C%A8&#34;&gt;Wikipedia&lt;/a&gt;を参照すると詳しいことが載っています。前の説明を繰り返すと、左右のノードの高さが高々1しか違わない平衡二分木です。自身の高さは左右の高さの高い方+1です。
データ構造は左右の木、ノードの保持する値の他にそのノードの高さを保持します。&lt;/p&gt;

&lt;p&gt;なので平衡度は赤黒木より高く、検索が高速な一方、要素数を変更する操作の度に平衡を取らないといけないので挿入や削除は赤黒木に負けるそうです。
OCamlのstdlibのMap/Setの実装に使われています。(OCamlは左右の高さが高々2違う木なので厳密にはAVL木ではないのですがアルゴリズムは同じです。)&lt;/p&gt;

&lt;p&gt;因みにAVLは人の名前の頭文字みたいです。&lt;/p&gt;

&lt;h1 id=&#34;作ってみよう:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;作ってみよう&lt;/h1&gt;

&lt;p&gt;今回、ATS2の依存型に関係ない機能、関数テンプレートなどは理解（読解）の妨げになると判断してそれらを使わないコード例を出します。
(関数テンプーレートを使わなくても多相型を使えば良さそうですが、ATS wayではなさそうです。)&lt;/p&gt;

&lt;p&gt;ということで、整数を格納するSetを作ってみましょう。&lt;/p&gt;

&lt;p&gt;実装に先立って、&lt;a href=&#34;https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml&#34;&gt;OCamlのSet&lt;/a&gt;や&lt;a href=&#34;https://tech.bezoomnyville.com/2015/12/07/A-GADT-implementation-of-AVL-tree.html&#34;&gt;GADTを使ったAVLの実装&lt;/a&gt;を読んでおくと比較が出来るかと思います。&lt;/p&gt;

&lt;p&gt;今回OCamlのSetを参考にして作ったので比較のためにコードを載せたいのですがOCamlは確かコードの再配布に厳しいライセンスだった気がするのでやめておきます。(スニペットくらいなら著作権は発生せず、ライセンス関係なしに使えるのですが念のため。)&lt;/p&gt;

&lt;h2 id=&#34;おまじない:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;おまじない&lt;/h2&gt;

&lt;p&gt;標準的な操作を取り込むため、以下をファイルの先頭に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;#include &amp;quot;share/atspre_staload.hats&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;データ型:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;データ型&lt;/h2&gt;

&lt;p&gt;高さnのAVL木を表わすデータ型を考えます。このデータ型は、&amp;rdquo;型パラメータとして&amp;rdquo;木の高さnを取ります。&lt;/p&gt;

&lt;p&gt;書き出しはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続けて、Emptyを書きます。Emptyは高さ0です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
    Empty(0)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いて、Nodeですが、左の木の高さと右の木の高さを表わす変数を導入します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat} Node of ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このクルクル括弧&lt;code&gt;{}&lt;/code&gt;で囲まれた部分は「任意の&lt;code&gt;nat&lt;/code&gt;なる&lt;code&gt;l&lt;/code&gt;,&lt;code&gt;m&lt;/code&gt;に対して」と読めば読み易いです。&lt;/p&gt;

&lt;p&gt;データ構造は、左右の木、値、高さを持つのでした。ここで、高さは&lt;code&gt;n&lt;/code&gt;であると型で制約されてます。ということでこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat} Node of (avlt(l), int, avlt(m), int(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の高さの部分で&lt;code&gt;int(n)&lt;/code&gt;となっているのは、&lt;code&gt;n&lt;/code&gt;は種&lt;code&gt;int&lt;/code&gt;であって型ではないので「整数&lt;code&gt;n&lt;/code&gt;の&lt;code&gt;int&lt;/code&gt;&amp;ldquo;型&amp;rdquo;」にする為に&lt;code&gt;int()&lt;/code&gt;を適用する必要があるのです。依存型だと「ただの整数値」だけでなく「整数3」などの型も作れるのです。&lt;/p&gt;

&lt;p&gt;さて、このままだと左右の木の高さが高々1しか違わないということを表わせていません。さらにいうと、自身の高さについての制約も書けていません。これらの制約はこう書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat | &amp;lt;制約&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回の制約はこうなりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat |
    (l + 2 == n &amp;amp;&amp;amp; m + 1 == n) || // 右が左より1高い 又は
    (l + 1 == n &amp;amp;&amp;amp; m + 1 == n) || // 左右同じ高さ 又は
    (l + 1 == n &amp;amp;&amp;amp; m + 2 == n)    // 左が右より1高い
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果、データ型はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
    Empty(0)
  | {l, m: nat |
    (l + 2 == n &amp;amp;&amp;amp; m + 1 == n) ||
    (l + 1 == n &amp;amp;&amp;amp; m + 1 == n) ||
    (l + 1 == n &amp;amp;&amp;amp; m + 2 == n)
} Node of (avlt(l), int, avlt(m), int(n))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中々複雑ですね。&lt;/p&gt;

&lt;h2 id=&#34;height:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;軽い関数から作っていきましょう。まずは木の高さを返す関数&lt;code&gt;height&lt;/code&gt;です。高さ&lt;code&gt;n&lt;/code&gt;の木を受け取って整数&lt;code&gt;n&lt;/code&gt;を返します。&lt;/p&gt;

&lt;p&gt;書き出しはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;code&gt;n&lt;/code&gt;を導入します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数は「高さ&lt;code&gt;n&lt;/code&gt;の木」ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n))...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値は「整数&lt;code&gt;n&lt;/code&gt;」です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n)): int(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数本体は普通です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n)): int(n) = 
  case+ tree of
  | Empty () =&amp;gt; 0
  | Node (_, _, _, n) =&amp;gt; n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで使っている&lt;code&gt;case+&lt;/code&gt;ですが、普通の&lt;code&gt;case&lt;/code&gt;より強くて網羅性検査に落ちるとコンパイルエラーになります。&lt;/p&gt;

&lt;h2 id=&#34;create:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;これから&lt;code&gt;insert&lt;/code&gt;を実装していく訳ですが、ユーティリティから少しづつ実装していきます。まずは高さが高々1しか違わない木2つと値を1つ受け取って新たな木を作る&lt;code&gt;create&lt;/code&gt;です。&lt;code&gt;Node&lt;/code&gt;を生で使うのに比べて高さの計算が必要なくなります。&lt;/p&gt;

&lt;p&gt;これは先に実装を与えて、後で型を考えましょう。先程の&lt;code&gt;height&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create??(l: ??, v: int, r: ??): ?? = let
  val hl = height l
  val hr = height r
in
  if hl &amp;gt;= hr
  then Node(l, v, r, hl + 1)
  else Node(l, v, r, hr + 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、型を考えていきます。まずは&lt;code&gt;l&lt;/code&gt;と&lt;code&gt;r&lt;/code&gt;はある高さを持つ木です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{l, m: nat} (l: avlt(l), v: int, r: avlt(m)): ?? = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、左右で高さが高々1しか違わないことを制約したいです。これは&lt;code&gt;Node&lt;/code&gt;の定義を参考にすると書けるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{
  l, m: nat |
  l + 1 == m ||
  l == m + 1 ||
  l == m
  } (l: avlt(l), v: int, r: avlt(m)): ?? = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に返り値の型を考えます。返り値は「&lt;code&gt;l&lt;/code&gt;か&lt;code&gt;m&lt;/code&gt;どちらか大きい方+1の高さを持つ木」です。私は最初、それをこう表現していました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create...(...): [n: nat | n == m + 1 || n == l + 1] avlt(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[n: nat | n == m + 1 || n == l + 1] avlt(n)&lt;/code&gt;の部分を読み下すと、「&lt;code&gt;n = m + 1&lt;/code&gt;又は&lt;code&gt;n = l + 1&lt;/code&gt;を満たす&lt;code&gt;n&lt;/code&gt;に対して&lt;code&gt;avlt(n)&lt;/code&gt;」という型になります。これは、間違ってはいないのですが正確ではありませんでした。なぜならこの型に忠実に従うと&lt;code&gt;l = m + 1&lt;/code&gt;の時に&lt;code&gt;n = m + 1&lt;/code&gt;、すなわち&lt;code&gt;n = l&lt;/code&gt;もありえてしまいます。勿論そんなことはなく、&lt;code&gt;l = m + 1&lt;/code&gt;ならば&lt;code&gt;n = l + 1&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;よって正しい型は&lt;code&gt;[n: nat | (m &amp;gt; l &amp;amp;&amp;amp; n == m + 1) || (l &amp;gt;= m &amp;amp;&amp;amp; n == l + 1)] avlt(x, n)&lt;/code&gt;です。やたら長いですね。&lt;/p&gt;

&lt;p&gt;全体を載せると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{
  l, m: nat |
  l + 1 == m ||
  l == m + 1 ||
  l == m
  } (l: avlt(l), v: int, r: avlt(m)): [n: nat | (m &amp;gt; l &amp;amp;&amp;amp; n == m + 1) || (l &amp;gt;= m &amp;amp;&amp;amp; n == l + 1)] avlt(n) = let
  val hl = height l
  val hr = height r
in
  if hl &amp;gt;= hr
  then Node(l, v, r, hl + 1)
  else Node(l, v, r, hr + 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;rotate:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;rotate&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;OCamlのSetでは1まとめに&lt;code&gt;bal&lt;/code&gt;としていますが、条件分岐が多すぎて読みづらいので&lt;code&gt;right&lt;/code&gt;と&lt;code&gt;left&lt;/code&gt;に分離することにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rotate_xxx&lt;/code&gt;は、左右で高さがちょうど2違う木と値を受け取って、バランスのとれた木を作って返す関数です。
&lt;code&gt;rotate_right&lt;/code&gt;なら左の木が右の木より2高い木を受け取って上手い具合に木の付け替えをして新たな木を返します。&lt;/p&gt;

&lt;p&gt;返り値の木は左の木と同じ高さかあるいはそれより1高い木です。&lt;/p&gt;

&lt;p&gt;そろそろ慣れてきたと思うので型までを一気に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、さらに左側の木の左右の高さでも場合分けが必要になるのでまずは色々バラします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let
  val+ Node(ll, lv, lr, _) = l
  val hll = height ll
  val hlr = height lr
in
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、ここが一番面白い所です。&lt;code&gt;val+ Node(ll, lv, lr, _) = l&lt;/code&gt;に注目して下さい。 OCamlでは&lt;code&gt;match l with Empty -&amp;gt; invalid_arg &amp;quot;Set.bal&amp;quot; | Node (ll, lv, lr, _) -&amp;gt; ...&lt;/code&gt;となっていた部分です。
型制約から、&lt;code&gt;l&lt;/code&gt;は高さ2以上の木であることが分かっているので&lt;code&gt;Empty&lt;/code&gt;でないことが保証されます。なので &lt;strong&gt;&lt;code&gt;Node&lt;/code&gt;だけで網羅出来ているとコンパイラが理解してくれ&lt;/strong&gt; ます。マッチが1節しかないので&lt;code&gt;val&lt;/code&gt;のパターンマッチで代用出来ますね。
&lt;code&gt;val+&lt;/code&gt;は&lt;code&gt;case+&lt;/code&gt;と同じく網羅性検査に落ちるとコンパイルエラーになるバージョンの&lt;code&gt;val&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;残りの実装をまとめると、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let
  val+ Node(ll, lv, lr, _) = l
  val hll = height ll
  val hlr = height lr
in
  if  hll &amp;gt;= hlr
  then create(ll, lv, create(lr, v, r))
  else let
       val+ Node(lrl, lrv, lrr, _) =  lr
  in
    create(create(ll, lv, lrl), lrv, create(lrr, v, r))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rotate_left&lt;/code&gt;はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_left{hl, hr: nat |
  hl + 2 == hr
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hr || n == hr + 1] avlt(n) = let
  val+ Node(rl, rv, rr, _) = r
  val hrl = height rl
  val hrr = height rr
in
  if  hrr &amp;gt;= hrl
  then create(create(l, v, rl), rv, rr)
  else let
    val+ Node(rll, rlv, rlr, _) =  rl
  in
    create(create(l, v, rll), rlv, create(rlr, rv, rr))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bal:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;bal&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;rotate_right&lt;/code&gt;, &lt;code&gt;rotate_left&lt;/code&gt;, &lt;code&gt;create&lt;/code&gt;を1まとめにして左右の高さの差が高々2の2つの木と値を受け取ってバランスのとれた木を作って返す&lt;code&gt;bal&lt;/code&gt;を作りましょう。&lt;/p&gt;

&lt;p&gt;型がエグいことになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun bal{hl, hr: nat |
  ~2 &amp;lt;= hl - hr  &amp;amp;&amp;amp; hl - hr &amp;lt;= 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat|
 (hl == hr - 2 &amp;amp;&amp;amp; n == hr    ) ||
 (hl == hr - 2 &amp;amp;&amp;amp; n == hr + 1) ||
 (hl == hr - 1 &amp;amp;&amp;amp; n == hr + 1) ||
 (hl == hr     &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 1 &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 2 &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 2 &amp;amp;&amp;amp; n == hl    )
] avlt(n) = let
  val hl = height l
  val hr = height r
in
  if hl = hr + 2
  then rotate_right(l, v, r)
  else if hl = hr - 2
  then rotate_left(l, v, r)
  else create(l, v, r)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cmp:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;さて、本来のOCamlのSetはファンクタで出来てますがATS2には原始的なファンクタしかないのでファンクタを使わずにこれまで実装してきました。
あまりよろしくありませんが&lt;code&gt;cmp&lt;/code&gt;もベタっと実装してしまいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun cmp(x: int, y: int): int = x - y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;empty-singleton:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;singleton&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun empty(): avlt(0) = Empty()
fun singleton(x: int): avlt(1) = Node(Empty, x, Empty, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insert:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ここまで辿りついたらもう難しいところはありません。&lt;code&gt;insert&lt;/code&gt;した結果、木の高さが変わらないか1増えるだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun insert{m: nat}(x: int, tree: avlt(m)): [n: nat | n == m || n == m + 1]avlt(n) =
  case+ tree of
  | Empty () =&amp;gt; singleton(x)
  | t as Node(l, v, r, _) =&amp;gt; let
    val c = cmp(x, v)
  in
    if c = 0 then t
    else if c &amp;lt; 0
    then bal(insert(x, l), v, r)
    else bal(l, v, insert(x, r))
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mem:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;mem&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun mem{m: nat}(x: int, tree: avlt(m)): bool =
  case+ tree of
  | Empty () =&amp;gt; false
  | Node(l, v, r, _) =&amp;gt; let
    val c = cmp(x, v)
  in
    if c = 0
    then true
    else if c &amp;lt; 0
    then mem(x, r)
    else mem(x, l)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;遊ぶ:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;遊ぶ&lt;/h1&gt;

&lt;p&gt;さて、少しばかり遊んでみましょう&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;
implement
main0 () =  {
  val tree = Empty
  val tree = insert(1, tree)
  val tree = insert(2, tree)
  val tree = insert(4, tree)
  val b = mem(2, tree)
  val c = mem(3, tree)
  val () = fprintln!(stdout_ref, b)
  val () = fprintln!(stdout_ref, c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これまでのファイルを&lt;code&gt;avlset_int.dat&lt;/code&gt;に保存して、以下のようにコンパイル/実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ patscc avlset.dats -DATS_MEMALLOC_LIBC
$ ./a.out
true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと動いているようです。(GCをリンクしてないのでメモリリークしてる気がしますが、GCのリンクの仕方が分からなかったのでこのままにします。)&lt;/p&gt;

&lt;p&gt;追記: GCのリンクの仕方を教えてもらいました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; GC付きコンパイルには -DATS_MEMALLOC_GCBDW -lgc を使うようです。僕も今知りました。。。 / master · githwxi/ATS-Postiats-contrib &lt;a href=&#34;https://t.co/4DPotHeUJ1&#34;&gt;https://t.co/4DPotHeUJ1&lt;/a&gt;&lt;/p&gt;&amp;mdash; Myu-Myu- ATS-tan! (@masterq_mogumog) &lt;a href=&#34;https://twitter.com/masterq_mogumog/status/682142334704717824&#34;&gt;2015, 12月 30&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;まとめ:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;依存型を持つATS2を使うことでAVL木の高さに関する要件を必ず満たす木を作ることが出来ました。
これは変な入力がないことを保証するばかりでなく、自らの実装がバグっていないことの確認にも使えます。
また、&lt;code&gt;val+&lt;/code&gt;の例で見た通り、パターンマッチについてもより厳格な検査が出来るので無意味なコードを書かなくて済みました。&lt;/p&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/avlset&#34;&gt;こちら&lt;/a&gt;に置いておきます。また、関数テンプレートを使ったよりジェネリックな実装もあります。&lt;/p&gt;

&lt;h1 id=&#34;ノート:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;今回型レベルで保証したのは高さに対する要件だけでした。
「ノードの左側の木にはそのノードの保持する値より小さい値しか入っていない」「一度&lt;code&gt;insert&lt;/code&gt;した値は&lt;code&gt;mem&lt;/code&gt;すると&lt;code&gt;true&lt;/code&gt;が返ってくる」などの要件については無保証のままです。
実はATS2には&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/c2849.html&#34;&gt;定理証明器&lt;/a&gt;も付いており、そのような振舞に関しても保証出来ます。&lt;/li&gt;
&lt;li&gt;ATS2には依存型の他にも&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/p3301.html&#34;&gt;線形型&lt;/a&gt;を持っていて、GCに頼らないメモリ管理が可能です。
今回のコードも線形型を使ってメモリリークしないように出来るでしょう。&lt;/li&gt;
&lt;li&gt;関数テンプレートを使ったAVL木の実装には若干危い点があります。関数テンプレートは実装をアドホックに変更出来るので
比較関数を差し替えれてしまいます。&lt;code&gt;cmp(x, y) = x - y&lt;/code&gt;で木を作った後に&lt;code&gt;cmp(x, y) = y - x&lt;/code&gt;にしてさらに要素を挿入したら大惨事になるでしょう。
そこまで気にするようなら&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/x1974.html&#34;&gt;ファンクタ&lt;/a&gt;を使うべきです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;その他:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;その他&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CoqやAgdaのように依存型も定理証明器もある言語がありますが、それらと違ってATS2は「汎用プログラミング言語に表現力の高い依存型を付けて、ついでに定理証明器もついてる」くらいです。
本格的な証明には向かない一方汎用プログラミングにはATS2の方が向いているでしょう。&lt;/li&gt;
&lt;li&gt;しかしCoqと似ている面もあり、ATS2の世界で依存型や線形型、証明などで強い保証を付けた後は一旦Cのコードをエクストラクトして、それをコンパイルしています。&lt;/li&gt;
&lt;li&gt;Cにエクストラクトされるということで、ATS2はCとの相互連携が出来ます。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、ATS2には心躍る特徴がたくさんあります。依存型で実行時検査をコンパイル時検査に持ち上げ、定理証明器でバグも潰せて、
線形型でボックス/アンボックデータの扱いやGCに頼らないリソース管理やデータ競合の回避が出来、
並列プログラミングもサポート、低レベルなCのコードを呼べてバイナリサイズも小さいなどなど。&lt;/p&gt;

&lt;p&gt;しかし、これらの機能を得るのにATS2は1つだけ代償を払いました。学習コストです。
私はCも書きますしSMLも書きます。依存型のあるCoqや線形型より少し弱いアフィン型のあるRustも書いたことがあります。そんな私にもATS2は難解です。
最近難解な言語として名高くなってきたRustですら足元に及ばないでしょう。&lt;/p&gt;

&lt;p&gt;それでも、急峻な学習曲線の崖をよじ登った先には素晴しい世界が広がっているのです。1つ、修行だと思ってトライしてみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://fumieval.tumblr.com/post/28324791101/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%81%AE%E5%8C%BA%E5%88%86&#34;&gt;プログラマの区分&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#とCプリプロセッサの連携</title>
      <link>/blog/2015/12/26/sml_tocpuripurosessanorenkei</link>
      <pubDate>Sat, 26 Dec 2015 20:09:24 +0900</pubDate>
      
      <guid>/blog/2015/12/26/sml_tocpuripurosessanorenkei</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第3段はSML#とCプリプロセッサで連携する話。&lt;/p&gt;

&lt;p&gt;SML#のC FFIを使ってるとマクロで定義された値などを触りたくなるのですが、触れないのでどうにかしようかと。&lt;/p&gt;

&lt;p&gt;発想自体は単純で、SMLファイルの中でCのヘッダをインクルードしてCプリプロセッサを呼んであげればどうにかなります。&lt;/p&gt;

&lt;h1 id=&#34;簡単な例:17ab4ed508953994d38c55ce3a68a752&#34;&gt;簡単な例&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;//KeenS.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi/&#34;&gt;JITを作る話&lt;/a&gt;の時のように、定数に触りたいとします。
その時、以下のように.smlファイルを記述して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* 
#include&amp;lt;sys/mman.h&amp;gt;
*)

(* ====END_OF_HEADER==== *)
datatype dummy = $ of int
              
val $PROT_READ  = $ PROT_READ
val $PROT_WRITE = $ PROT_WRITE
val $PROT_EXEC  = $ PROT_EXEC
val $PROT_NONE  = $ PROT_NONE

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E cpp_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; cpp.sml 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントを挙げると、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;smlファイルに&lt;code&gt;#include&lt;/code&gt;を書く。lintでエラーが出ないように&lt;code&gt;#include&lt;/code&gt;はコメントで囲む&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt;をコメントで囲ったところで安全でない( インクルードしたファイルに&amp;rsquo;&lt;code&gt;*)&lt;/code&gt;&amp;lsquo;、例えば &lt;code&gt;int f(char *);&lt;/code&gt;とかが入ってるとコメントが終端される)ので、&lt;code&gt;include&lt;/code&gt;の部分は後で削除する。
そのための識別子として、&lt;code&gt;====END_OF_HEADER====&lt;/code&gt;を置いておく(これも完全には安全ではないが比較的マシ)。&lt;/li&gt;
&lt;li&gt;Cのマクロと同じ識別子を使おうとすると識別子も置換されてしまうので左辺にダミーで&lt;code&gt;$&lt;/code&gt;をつけておく。スペースは空けない。
逆に右辺は置換されてほしいので&lt;code&gt;$&lt;/code&gt;の後にスペースを空ける。&lt;/li&gt;
&lt;li&gt;最後にCプリプロセッサを呼び、sedでヘッダ部分や無駄に追加されたCのコメントを除く。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ちょっと&lt;code&gt;$&lt;/code&gt;の部分がこの方式だとintにしか使えないのでイケてませんがないよりマシでしょう。因みに処理結果はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype dummy = $ of int

val $PROT_READ = $ 
                   0x1

val $PROT_WRITE = $ 
                   0x2

val $PROT_EXEC = $ 
                   0x4

val $PROT_NONE = $ 
                   0x0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ifdef:17ab4ed508953994d38c55ce3a68a752&#34;&gt;&lt;code&gt;ifdef&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;一旦発想さえ得てしまえば話は簡単です。次は&lt;code&gt;ifdef&lt;/code&gt;を使う例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* ====END_OF_HEADER==== *)


(* 
#ifdef Debug
*)
val debug = true
(* 
#else
*)
val debug = false

(* 
#endif
*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E -DDebug ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;Debug&lt;/code&gt;を定義して処理すればifdef.smlの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*

*)
val debug = true
(*






*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となりますし、定義せずに&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
``` sh
cpp -pipe -E ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と処理すれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*





*)
val debug = false

(*

*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってどちらでもSMLとして有効な文法になります。&lt;code&gt;ifndef&lt;/code&gt;だったり、&lt;code&gt;elif&lt;/code&gt;があったとしても有効な文法のままです。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:17ab4ed508953994d38c55ce3a68a752&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CプリプロセッサでSMLファイルを処理する方法を提示したよ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifdef&lt;/code&gt;も使えるよ&lt;/li&gt;
&lt;li&gt;関数マクロは使えないよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#のオレオレREPLを作る話 初級</title>
      <link>/blog/2015/12/26/sml_nooreorereplwotsukuruhanashi_shokyuu</link>
      <pubDate>Sat, 26 Dec 2015 19:48:30 +0900</pubDate>
      
      <guid>/blog/2015/12/26/sml_nooreorereplwotsukuruhanashi_shokyuu</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第2段はSML#のオレオレREPLを作る話の初級。&lt;/p&gt;

&lt;p&gt;SML#にはFFIがあり、任意のオブジェクトファイル/ライブラリをリンクしてC関数を呼び出すことが出来ますが、REPLで試そうとしてもREPLにリンクされていないので呼び出せません。
そこで呼び出したいオブジェクトファイルをリンクしたREPLを作れば捗るよね、という発想です。&lt;/p&gt;

&lt;h1 id=&#34;事前に必要なもの:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;事前に必要なもの&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;SML#のビルド時に使ったLLVMのパス&lt;/li&gt;
&lt;li&gt;SML#をビルドした時のオブジェクトファイルの残骸（一部）&lt;/li&gt;
&lt;li&gt;SML#のソーコード（一部）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;コマンド:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;コマンド&lt;/h1&gt;

&lt;p&gt;まず、普通のREPLを作るだけならこれだけです。（コンパイラも一緒にくっついてきますが面倒なのでそのままにしてます。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o oreore_repl &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot;  &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは最後のリンクコマンドにフラグを足せばいいでしょう。注意点として、64bit OSを使ってるならちゃんと32bitでビルドしたライブラリをリンクしましょう。例えばlibuvをリンクするならこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o smlsharp_uv &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot; -L /opt/libuv32/lib -luv &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;終わりに:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;終わりに&lt;/h1&gt;

&lt;p&gt;やり方さえ分かってしまえば簡単ですが見付けるのが難しい小ネタでした。因みに今回初級ですが、REPLにlibeditを統合するなどの上級ネタはいつか気が向いたら書くかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustのロガーを作る</title>
      <link>/blog/2015/12/26/rustnoroga_wotsukuru</link>
      <pubDate>Sat, 26 Dec 2015 19:18:31 +0900</pubDate>
      
      <guid>/blog/2015/12/26/rustnoroga_wotsukuru</guid>
      <description>&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第1段はRustのロガーを作る話。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar&lt;/a&gt;の&lt;a href=&#34;//KeenS.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru/&#34;&gt;初日&lt;/a&gt;でロガーはfacadと実装に分かれてると書きましたが、実装を作る話ですね。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/log/log/index.html&#34;&gt;ドキュメント&lt;/a&gt;を見てもらえば分かる通り、logは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Log: Sync + Send {
    fn enabled(&amp;amp;self, metadata: &amp;amp;LogMetadata) -&amp;gt; bool;
    fn log(&amp;amp;self, record: &amp;amp;LogRecord);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とだけインターフェースが定まっているのでそこを実装してあげれば終わりです。
なぜまたloggerを作ろうとしたのかというと、Rust公式の&lt;a href=&#34;https://crates.io/crates/env_logger/&#34;&gt;env_logger&lt;/a&gt;は標準出力にしか出せず、crates.ioを捜しても（作ろうと思った時点ではパっと見）ファイルに書き出せるものがなさそうだったからです。&lt;/p&gt;

&lt;p&gt;私が作ったのは&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logger&lt;/a&gt;といいます。まだcrates.ioには出してません。TOMLでコンフィグを書けるようになったら出そうかと思うのですがもう既にファイルに書きだせるものが他にありますかね。&lt;/p&gt;

&lt;p&gt;今回作るにあたって目指したのは1つのことにだけ集中する他と組み合わせられるライブラリです。
logはロガーをグローバル変数に代入して使い回してるので同時に1つしかロガーを登録出来ません。そこでロガーアグリケーターのようなものを作ってそれに複数のロガーを登録することが考えられます。
調べきれてませんが恐らく既にいくつか存在するでしょう。アグリゲータの存在を仮定してしまえばアグリゲータに任せれる部分は任せてしまうのが良いでしょう。&lt;/p&gt;

&lt;p&gt;ということで次のことを最初に決めました&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ログフォーマットは柔軟性を持たせる&lt;/li&gt;
&lt;li&gt;ログメッセージの内容に応じて出力を制御出来るフィルターを入れる。(アグリゲータが無差別にログを流し込んで来た時のため)&lt;/li&gt;
&lt;li&gt;複数ファイルへのログはサポートしない。アグリゲータに任せる&lt;/li&gt;
&lt;li&gt;プラグインはサポートしない。アグリゲータに任せる&lt;/li&gt;
&lt;li&gt;ログローテーションはしない。&lt;code&gt;Write&lt;/code&gt;の実装に任せる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一応file loggerですがWriteをすべからく受け取れるので実際はストリームにも使えたりします。今書き出してみたらフォーマッタとかフィルタとかもアグリゲータに任せた方がいいのかなって気がしてきた。
しかし単体での利便性を考えると仕方ない。&lt;/p&gt;

&lt;p&gt;実装は大したことをやっていなくて、精々ログフォーマットを文字列で書けるように（TOMLで設定を書きたいため）フォーマットのパーサを書いた程度でしょうか。&lt;/p&gt;

&lt;p&gt;もう少し考えてからリリースします。あとFile Lotating Writerも一緒に出さなきゃ片手落ちですかね…&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Drillの不自然な挙動</title>
      <link>/blog/2015/12/20/apache_drillnofushizennakyodou</link>
      <pubDate>Sun, 20 Dec 2015 23:04:37 +0900</pubDate>
      
      <guid>/blog/2015/12/20/apache_drillnofushizennakyodou</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/drill&#34;&gt;Apache Drill Advent Calendar 2015&lt;/a&gt;21日目のエントリです&lt;/p&gt;

&lt;p&gt;最初は備忘録がてら普段使うMySQL、BigQuery、SQLite、Apache DrillのSQLシンタックスの違いでも書こうかと思ったのですが調査が思ったより大変だったのでやめました。ANSI SQLも色々変わってるということは理解出来ました。&lt;/p&gt;

&lt;p&gt;ということでApache Drillを使ってて「ん？」と思った挙動をいくつか出してみようかと。1.4時点での情報です。&lt;/p&gt;

&lt;h1 id=&#34;select-1:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;&lt;code&gt;SELECT 1&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;シェルで手持ち無沙汰に&lt;code&gt;ls&lt;/code&gt;や&lt;code&gt;pwd&lt;/code&gt;を打つようにSQLプロンプトで&lt;code&gt;SELECT 1;&lt;/code&gt;を打つ訳ですが、Apache Drillはこれを受け付けてくれません。&lt;/p&gt;

&lt;p&gt;まあ、これは不自然というかそういう仕様なのですが正しくは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT 1 FROM (VALUES(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。手持ち無沙汰に打つには少し面倒ですね。そうでなくても日付関数の挙動を確かめたい時にも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT NOW();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとやりたい訳ですがそれにも&lt;code&gt;FROM (VALUES(1));&lt;/code&gt;とダミーの&lt;code&gt;FROM&lt;/code&gt;句を付けてあげる必要があります。面倒ですね。&lt;/p&gt;

&lt;h1 id=&#34;union-と-union-all:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;&lt;code&gt;UNION&lt;/code&gt;と&lt;code&gt;UNION ALL&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;UNION&lt;/code&gt;はテーブル同士のレコード間で重複を取り除いた集合を、&lt;code&gt;UNION ALL&lt;/code&gt;は重複を取り除かない集合を返します。Apache Drillでも試してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM (VALUES (1, 2, 3) UNION VALUES(4, 5, 6) UNION VALUES(7, 8, 9) UNION VALUES(1, 2, 3));
SELECT * FROM (VALUES (1, 2, 3) UNION ALL VALUES(4, 5, 6) UNION ALL VALUES(7, 8, 9) UNION ALL VALUES(1, 2, 3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのクエリはどういう結果になるでしょうか。答えはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT * FROM (VALUES (1, 2, 3) UNION VALUES(4, 5, 6) UNION VALUES(7, 8, 9) UNION VALUES(1, 2, 3));
+---------+---------+---------+
| EXPR$0  | EXPR$1  | EXPR$2  |
+---------+---------+---------+
| 1       | 2       | 3       |
+---------+---------+---------+
1 row selected (0.416 seconds)
0: jdbc:drill:zk=local&amp;gt; SELECT * FROM (VALUES (1, 2, 3) UNION ALL VALUES(4, 5, 6) UNION ALL VALUES(7, 8, 9) UNION ALL VALUES(1, 2, 3));
+---------+---------+---------+
| EXPR$0  | EXPR$1  | EXPR$2  |
+---------+---------+---------+
| 7       | 8       | 9       |
| 7       | 8       | 9       |
| 7       | 8       | 9       |
| 7       | 8       | 9       |
+---------+---------+---------+
4 rows selected (0.115 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うーん。これはバグだと思うんですよね。定数テーブルをキャッシュするようにしてたら全てのレコードで同じ値を参照しちゃって値を書き換えてしまったとか。
&lt;code&gt;UNION&lt;/code&gt;が&lt;code&gt;UNION ALL&lt;/code&gt;の結果から&lt;code&gt;DISTINCT&lt;/code&gt;相当の処理をするなら2番目の結果を見れば最初の結果が従うのもうなずけますし。&lt;/p&gt;

&lt;h1 id=&#34;ヘッダ付きcsv:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;ヘッダ付きCSV&lt;/h1&gt;

&lt;p&gt;Drill 1.4からヘッダ付きCSVの扱いが楽になりましたね。拡張子が&lt;code&gt;csv&lt;/code&gt;のままヘッダ付きCSVにクエリを投げられます。ちょっと試しましょう。&lt;/p&gt;

&lt;p&gt;次のようなCSVファイルを用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/Csv/test.csv
foo,bar,baz
1,1.0,&amp;quot;a&amp;quot;
2,2.0,&amp;quot;b&amp;quot;
3,3.0,&amp;quot;c&amp;quot;
4,4.0,&amp;quot;d&amp;quot;
5,5.0,&amp;quot;e&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリを投げてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT * FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+------+------+
| foo  | bar  | baz  |
+------+------+------+
| 1    | 1.0  | a    |
| 2    | 2.0  | b    |
| 3    | 3.0  | c    |
| 4    | 4.0  | d    |
| 5    | 5.0  | e    |
+------+------+------+
5 rows selected (0.12 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。じゃあ今度は&lt;code&gt;baz&lt;/code&gt;カラムだけ取り出してみましょう。ここで、会社のMacだと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT baz FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+------+------+
| foo  | bar  | baz  |
+------+------+------+
| 1    | 1.0  | a    |
| 2    | 2.0  | b    |
| 3    | 3.0  | c    |
| 4    | 4.0  | d    |
| 5    | 5.0  | e    |
+------+------+------+
5 rows selected (0.12 seconds)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにカラムを指定しているのにも関らず全てのデータが返ってきていました。その旨を書こうと思ったのですが手元のLinuxマシンだと正しい結果が返ってくるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT `bar` FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+
| bar  |
+------+
| 1.0  |
| 2.0  |
| 3.0  |
| 4.0  |
| 5.0  |
+------+
5 rows selected (0.088 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと会社で見たのが幻覚だったかもしれないので要調査ですね。&lt;/p&gt;

&lt;h1 id=&#34;mysqlへの接続:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;MySQLへの接続&lt;/h1&gt;

&lt;p&gt;以下のようなSQLを投げた所、ひどく時間が掛かりました。投げた対象はプロダクションのデータが入ってる分析用のDBで、結構な量のデータが入ってます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM mysql.mydb.`test` LIMIT 20;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache Drill自体レスポンスが悪いのでクエリによってはそんなものかな、と思って最初はそのままにしたのですがふと気になって&lt;code&gt;EXPLAIN&lt;/code&gt;してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=localhost:2181&amp;gt; EXPLAIN PLAN FOR SELECT * FROM mysql.mydb.`test` LIMIT 20;
+------+------+
| text | json |
+------+------+
| 00-00    Screen
00-01      Project(columns....)
00-02        SelectionVectorRemover
00-03          Limit(fetch=[20])
00-04            Limit(fetch=[20])
00-05              Jdbc(sql=[SELECT * FROM `mydb`.`test`])
| {
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Jdbc(sql=[SELECT * FROM mydb.test])&lt;/code&gt; とあるのでなんとMySQLに&lt;code&gt;LIMIT&lt;/code&gt;をつけずにクエリを投げてます。そしてさらに何故か&lt;code&gt;Limit(fetch=[20])&lt;/code&gt;を2回やっています。&lt;/p&gt;

&lt;p&gt;まあ、内部でLimitを2回やってるのは良いとしてもMySQLにLimit無しで投げるのはいただけないですね。
分散モデルのDrillからしたら「分散してる俺らの方が処理が速いから全部俺らでやってやるよ」という気概なのかもしれませんがこちらとしてはDBへの負荷も考えて欲しいものです。
まあ、かといって&lt;code&gt;WHERE&lt;/code&gt;句にインデックスが付く/付かないだとかその他の句によってMySQLのへの負荷も変わるのでなんとも言えないといえばそうなんですが簡単な場合にpush downしてくれるか
あるいは手動でpush down出来る仕組みが欲しいですね。&lt;code&gt;FORCE INDEX&lt;/code&gt;みたいに。&lt;/p&gt;

&lt;p&gt;さて、色々気になる点はありましたがApache Drillは面白いプロダクトです。
主にビッグデータ分析に使われるようですが私は大きなテーブルからアドホックに抽出したCSVとMySQLにあるマスターデータをJOINするなどの目的で使っていきたいなと思っています。&lt;/p&gt;

&lt;p&gt;皆様良いデータ分析ライフを！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>