<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on κeenのHappy Hacκing Blog</title>
    <link>/post/</link>
    <description>Recent content in Posts on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 29 Sep 2016 22:15:51 +0900</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Pijulのインストールが難易度高いので解説する</title>
      <link>/blog/2016/09/29/pijulnoinsuto_ruganan_idotakainodekaisetsusuru</link>
      <pubDate>Thu, 29 Sep 2016 22:15:51 +0900</pubDate>
      
      <guid>/blog/2016/09/29/pijulnoinsuto_ruganan_idotakainodekaisetsusuru</guid>
      <description>&lt;p&gt;κeenです。ふとTwitterで&lt;a href=&#34;http://pijul.org&#34;&gt;Pijul&lt;/a&gt;の話題を見掛けたついでにインストールしようと思ったら難易度が高かったので解説します。
Pijulそのものについては&lt;a href=&#34;/blog/2016/02/14/dvcsnomoderu_aruihapijulnitsuite/&#34;&gt;過去のエントリ&lt;/a&gt;を参照して下さい。&lt;/p&gt;

&lt;p&gt;因みにPijulは「ピーフール」みたいに発音するそうです。「フー」は喉の奥から出す破擦音ですね。&lt;/p&gt;

&lt;p&gt;まず、公式ドキュメントには &lt;code&gt;cargo install pijul&lt;/code&gt; すると書いてますが、これはバージョン0.1、古いやつな上にビルドに失敗します。
ということでソースからビルドするのですがビルドガイドがないので非常に難しいです。コマンドだけ載せてしまうと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ darcs get https://pijul.org
$ cd pijul.org/pijul
$ cp -R ../libpijul src
$ cd src/libpijul/src
$ darcs get https://pijul.org/sanakirja
$ cd ../../../
$ cargo install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。これだと常に最新版をビルドしてしまいますがdarcsでタグを指定する方法が分からなかったのでこれで。
あ、あと&lt;code&gt;darcs get https://pijul.org/sanakirja&lt;/code&gt;でnested repositoryで怒られますがそれもよく分からなかったのでそのまま。
darcsに馴れてる方は好きにして下さい。&lt;/p&gt;

&lt;p&gt;因みにその後のコマンドはちゃんと動くので&lt;a href=&#34;http://pijul.org/documentation/getting-started/&#34;&gt;公式ガイド&lt;/a&gt;に従えば使えます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustでシェル作った</title>
      <link>/blog/2016/09/04/rustdeshierutsukutta</link>
      <pubDate>Sun, 04 Sep 2016 16:26:20 +0900</pubDate>
      
      <guid>/blog/2016/09/04/rustdeshierutsukutta</guid>
      <description>

&lt;p&gt;κeenです。
先日、先輩社員と話してるとシェルを作る話になりました。
だいたいのコンピュータサイエンスの学生なら学部生の頃に課題でシェルを作りますが数学科にいた私は作ったことありませんでした。
でも、その時「今ならシェルなんて作ろうと思えばすぐに作れますよ」なんて言っちゃったのでなんか作りました。
まあ、習作程度の雑なものです。&lt;/p&gt;

&lt;p&gt;作ったのはこれ、&lt;a href=&#34;https://github.com/KeenS/igaguri&#34;&gt;KeenS/igaguri: my toy shell written in Rust&lt;/a&gt;。
名前は、Shellは木の実を覆う殻のようにカーネルを覆う殻とのことなのでRustのロゴに似てる毬栗を選びました。&lt;/p&gt;

&lt;h1 id=&#34;パーサ&#34;&gt;パーサ&lt;/h1&gt;

&lt;p&gt;パーサコンビネータライブラリの&lt;a href=&#34;https://github.com/Geal/nom&#34;&gt;nom&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;雰囲気こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;named!(token&amp;lt;String&amp;gt;, map!(map_res!(is_a!(&amp;quot;abcdefghijklmnopqlrstuvwxyzABCDEFGHIJKLMNOPQLRSTUVWXYZ-!$%^&amp;amp;@/1234567890&amp;quot;), str::from_utf8), |i: &amp;amp;str| i.to_string()));
named!(pipe, tag!(&amp;quot;|&amp;quot;));
named!(redirect_out&amp;lt;String&amp;gt;, chain!(tag!(&amp;quot;&amp;gt;&amp;quot;) ~ opt!(multispace) ~ filename: token, || filename));

named!(command&amp;lt;Ast&amp;gt;, chain!(
    opt!(multispace)
        ~ cmd: separated_list!(multispace, token)
        ~ outfile: opt!(chain!(multispace ~ out: redirect_out, || out))
        ~ opt!(multispace), || Ast::Command{cmd: cmd, out: outfile}));
named!(parse&amp;lt;Ast&amp;gt;, map!(separated_list!(pipe, command), Ast::Pipe));

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;入力ハンドリング&#34;&gt;入力ハンドリング&lt;/h1&gt;

&lt;p&gt;readlineのRust実装、&lt;a href=&#34;https://github.com/kkawakam/rustyline&#34;&gt;rustyline&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;それっぽいからとりあえず、で選んだものの、複数行入力（履歴）とか考えるともうちょっとリッチなものを選んだ方が良かったかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;実行&#34;&gt;実行&lt;/h1&gt;

&lt;p&gt;最初、&lt;a href=&#34;https://github.com/rust-lang/libc&#34;&gt;libcバインディング&lt;/a&gt;の &lt;code&gt;pipe&lt;/code&gt; や &lt;code&gt;fork&lt;/code&gt; 、 &lt;code&gt;execve&lt;/code&gt; なんかを考えてましたが、標準ライブラリの &lt;a href=&#34;https://doc.rust-lang.org/std/process/struct.Command.html&#34;&gt;&lt;code&gt;std::process::Command&lt;/code&gt;&lt;/a&gt;で実現出来そうだったのでそれを使いました。&lt;/p&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Command::new(cmd)
    .args(&amp;amp;terms)
    .stdin(stdin)
    .stdout(stdout)
    .stderr(stderr)
    .spawn()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パイプ-リダイレクト&#34;&gt;パイプ/リダイレクト&lt;/h2&gt;

&lt;p&gt;一応、パイプも標準ライブラリでサポートされてるのでそれを使いました。&lt;/p&gt;

&lt;p&gt;ただ、普通のCとは違って子プロセスと親プロセスの間に一旦パイプを作って、子プロセスの出力の生のfdを取り出して、次の子プロセスの入力に与えて、と案外面倒でした。 &lt;code&gt;unsafe&lt;/code&gt; も出てくれば &lt;code&gt;unreachable&lt;/code&gt; も出てくるのでもう少し書き直したい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut si = stdin;
let mut itr = commands.into_iter().peekable();
unsafe {
    while let Some(command) = itr.next() {
        if itr.peek().is_some() {
            let process =
                try!(self.run(command, si, Stdio::piped(), Stdio::inherit()));
            si = Stdio::from_raw_fd(process.stdout.unwrap().into_raw_fd());
        } else {
            return self.run(command, si, stdout, stderr);
        }
    }
}
unreachable!()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リダイレクトも似たようなもので、ファイルを作って生のfdを取り出して、とやります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let stdout = out.map(|f| {
    unsafe {
        let file = File::create(f)
        // FIXME: do not panic
            .unwrap();
        Stdio::from_raw_fd(file.into_raw_fd())
    }

}).unwrap_or(stdout);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;昨日の夜からちょろっと作り始めてさっきそれっぽく動くようになった程度なのでまだ適当にしか動きません。
パイプと標準出力のリダイレクトだけで、 &lt;code&gt;cd&lt;/code&gt; なんかのシェルコマンドもなければシェル変数もありません。
が、そろそろ飽きたのでこの辺で。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そろそろ飽きてきた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/772334565264232454&#34;&gt;2016年9月4日&lt;/a&gt;&amp;lt;/
blockquote&amp;gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;シェルコマンドとシェル変数くらいはいつか実装しようかな。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mirah 0.2がリリースされました。</title>
      <link>/blog/2016/08/11/mirah_0_2gariri_susaremashita</link>
      <pubDate>Thu, 11 Aug 2016 15:32:39 +0900</pubDate>
      
      <guid>/blog/2016/08/11/mirah_0_2gariri_susaremashita</guid>
      <description>

&lt;p&gt;κeenです。久しぶりに&lt;a href=&#34;mirah.org&#34;&gt;mirah&lt;/a&gt;のリリースが出ましたので新機能の紹介をしたいと思います。&lt;/p&gt;

&lt;p&gt;リリース版のダウンロードは &lt;a href=&#34;https://github.com/mirah/mirah/releases/tag/0.2.0&#34;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;

&lt;h1 id=&#34;のセマンティクス変更&#34;&gt;&lt;code&gt;==&lt;/code&gt; のセマンティクス変更&lt;/h1&gt;

&lt;p&gt;Rubyに合わせて、 &lt;code&gt;==&lt;/code&gt; が等価性、 &lt;code&gt;===&lt;/code&gt; が同値性の比較になりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;import java.net.URL

puts &amp;quot;1 == 1 =&amp;gt; #{1 == 1}&amp;quot;
puts &amp;quot;1 === 1 =&amp;gt; #{1 === 1}&amp;quot;
x = 1; puts &amp;quot;x = 1&amp;quot;
puts &amp;quot;x == x =&amp;gt; #{x == x}&amp;quot;
puts &amp;quot;x === x =&amp;gt; #{x === x}&amp;quot;
puts &amp;quot;URL.new(\&amp;quot;http://hoge.com\&amp;quot;) == URL.new(\&amp;quot;http://hoge.com\&amp;quot;) =&amp;gt; #{URL.new(&amp;quot;http://hoge.com&amp;quot;) == URL.new(&amp;quot;http://hoge.com&amp;quot;)}&amp;quot;
puts &amp;quot;URL.new(\&amp;quot;http://hoge.com\&amp;quot;) === URL.new(\&amp;quot;http://hoge.com\&amp;quot;) =&amp;gt; #{URL.new(&amp;quot;http://hoge.com&amp;quot;) === URL.new(&amp;quot;http://hoge.com&amp;quot;)}&amp;quot;
x = URL.new(&amp;quot;http://hoge.com&amp;quot;); puts &amp;quot;x = URL.new(\&amp;quot;http://hoge.com\&amp;quot;)&amp;quot;
puts &amp;quot;x == x =&amp;gt; #{x == x}&amp;quot;
puts &amp;quot;x === x =&amp;gt; #{x === x}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1 == 1 =&amp;gt; true
1 === 1 =&amp;gt; true
x = 1
x == x =&amp;gt; true
x === x =&amp;gt; true
URL.new(&amp;quot;http://hoge.com&amp;quot;) == URL.new(&amp;quot;http://hoge.com&amp;quot;) =&amp;gt; true
URL.new(&amp;quot;http://hoge.com&amp;quot;) === URL.new(&amp;quot;http://hoge.com&amp;quot;) =&amp;gt; false
x = URL.new(&amp;quot;http://hoge.com&amp;quot;)
x == x =&amp;gt; true
x === x =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ビルトインmacroの追加&#34;&gt;ビルトインMacroの追加&lt;/h1&gt;

&lt;h2 id=&#34;キャスト&#34;&gt;キャスト&lt;/h2&gt;

&lt;p&gt;今まで、Mirahのキャスト構文は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;int(0.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように関数呼び出しっぽい形式でしたが、この度 &lt;code&gt;as!&lt;/code&gt; マクロが追加されたので以下のように書けるようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;puts &amp;quot;0.5.as!(int) =&amp;gt; #{0.5.as!(int)}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0.5.as!(int) =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;synchronize&#34;&gt;Synchronize&lt;/h2&gt;

&lt;p&gt;javaの &lt;code&gt;Lock&lt;/code&gt; の &lt;code&gt;lock&lt;/code&gt; , &lt;code&gt;unlock&lt;/code&gt; を &lt;code&gt;sychronize&lt;/code&gt; マクロでラップしました。Javaのビルトインの &lt;code&gt;synchronized&lt;/code&gt; ではない模様。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;import java.util.concurrent.locks.ReentrantLock
lock = ReentrantLock.new
counter = 0
th1 = Thread.new do
  100.times do
    lock.synchronize do
      counter += 1
    end
  end
end

th2 = Thread.new do
  100.times do
    lock.synchronize do
      counter -= 1
    end
  end
end

th1.run
th2.run
th1.join
th2.join
puts &amp;quot;counter = #{counter}&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;counter = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;private&#34;&gt;&lt;code&gt;private&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;private def my_method
  puts &amp;quot;foo&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいに書けるようになりました。&lt;/p&gt;

&lt;h2 id=&#34;ラッパークラスの演算子&#34;&gt;ラッパークラスの演算子&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;int&lt;/code&gt; に対する &lt;code&gt;Integer&lt;/code&gt; のようなラッパークラスにも演算子マクロが定義されるようになました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;b = Integer.new(1); puts &amp;quot;b = Integer.new(1)&amp;quot;
b += 1;puts &amp;quot;b += 1&amp;quot;
puts &amp;quot;a &amp;lt; b =&amp;gt; #{a &amp;lt; b}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;a &amp;lt; b =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にも色々と定義されているようです。&lt;/p&gt;

&lt;h1 id=&#34;改善&#34;&gt;改善&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Javaのバイトコードを吐くライブラリasmのバージョンが5になりました。&lt;/li&gt;
&lt;li&gt;コンパイラのの内部で使っているロガーをマクロで書き直すことでDebug出力しない時のコンパイラの速度が速くなりました(確かこの変更が入った時に20%速くなるって言ってたような)。&lt;/li&gt;
&lt;li&gt;マクロが&lt;a href=&#34;http://www.ne.jp/asahi/hishidama/home/tech/java/jar.html#h_Service_Provider&#34;&gt;サービスプロバイダ&lt;/a&gt;の仕組みに乗っかるようになりました。
マクロを使うには今までマクロを定義したmirahのソースコードを一緒にコンパイルしないといけなかったのが、Mirahコンパイラがクラスパスから捜すようになったのでJarによる配布が現実的になりました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;マクロ周りが便利になるなど、興味深い変更がありましたね。
みなさんもこれを機にmirahを使ってみて下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>私がコードを書くときテストは書かない</title>
      <link>/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai</link>
      <pubDate>Tue, 02 Aug 2016 00:12:22 +0900</pubDate>
      
      <guid>/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai</guid>
      <description>&lt;p&gt;ちょっとポエムというか自分語りを。会社の同期と話してて少し刺激されたので。あとは&lt;a href=&#34;https://note.mu/ruiu/n/n1083b2a5d547&#34;&gt;ソースコードって実際のところどういうふうに書いていますか？｜Rui Ueyama｜note&lt;/a&gt;にも刺激されて。&lt;/p&gt;

&lt;p&gt;発端は同期が最近は何か書いてもイケてなくて後で丸っと書き直すことが多くてつらい、という話を始めたこと。
自分は、そんなの普通だろと返した。少なくとも自分の中では当たり前だった。
ふと考えてみたらそうじゃない人も沢山いる気がした。当たり前じゃない人に、自分の当たり前を喋ってみたら面白そうということで自分がコードを書くときにやることを語る。&lt;/p&gt;

&lt;p&gt;コードを書き始めた時点では仕様は完全には固まっていない。アプリケーションの構成とかは決まってるけど、ソフトウェアの中身はほとんど何も決まっていない。
まずは手を着けやすそうな所から始める。最初は必ずHello Worldから。そしてmainの中にPoCを書いてイメージを掴む。
そこから一気に飛躍して、ディレクトリ構成を決める。mainは三枚下ろしにして各ディレクトリ下に入れる。これでアプリケーションの骨格が見える。ここまでトップダウン。この状態でアプリケーションを走らせるとPoCが動く。&lt;/p&gt;

&lt;p&gt;次はボトムアップのフェーズで、骨格に肉付けしていく。1度に考えることが一箇所で済むように、順番を考えながら気儘にコードを加えていく。だいたいデータアクセス層のインターフェース、データアクセス層の実装のスタブ、サービス層のスタブ、メインルーチン、サービス層、くらいの順番。抽象すると必要そうなものを定義する、定義したものを使う、定義したものを実装する。多少型が違ってコンパイルが通らなくても気にしない。エラー処理やエッジケースは全部スタブのまま。コードのあちこちに &lt;code&gt;FIXME&lt;/code&gt; が散らばる。条件分岐の枝は全ては書かない。頭のコンテキストスイッチで死んでしまう。集中したい枝以外はFIXMEで埋める。こんなもんかな、と思ったところでちゃんとコンパイルが通るように修正する。ここまでテスト無し、データアクセス層の実装無し。&lt;/p&gt;

&lt;p&gt;ここからようやく永続データのスキーマやアプリケーションの仕様を決める。コードを見ればどういうデータにパターンでアクセスして、どういうエッジケースがあるかが分かるからサクサク決まる。&lt;/p&gt;

&lt;p&gt;データのスキーマが決まったので最後データアクセス層を実装出来る。そしたら動くものが完成する。動いたものをポチポチやってみて実装が正しいことを確認する。&lt;/p&gt;

&lt;p&gt;このまま細かい実装を詰めていくかというとそうならない。仕様を見て、コードを見て、イケてない所を全部書き直す。まずはインターフェースを変える、型を変える。意図的にコードを壊す。あとはコンパイルエラーで修正箇所が全て分かる。ついでにFIXMEも片付けていく。エラーが取れてアプリケーションが再度動くようになったら、リファクタの完了。納得のいくコードになっている筈。ここでようやく仕様を固定するためにテストを書く。全てのコードが出来てからテストを書くからホワイトボックスに近いテストになる。&lt;/p&gt;

&lt;p&gt;どうしてこのようなプロセスを経るかと考えてみた。ポールグレアムも言っているように、私にとってのアプリケーションは、アプリケーションのドメインを記述するための巨大な言語（ライブラリ）と、それを使った非常に小さな実装からなる。
そして言語と実装の境界は何度も押したり引いたりしてようやく固まる。この手順は境界が固まるまでの過程だ。DSLを作るにはまずどのようなAPIがあれば便利か理解する必要がある。理解するのに一番手っ取り早い方法は一旦実装してみることだ。
ある人は言うだろう、「何を七面倒な。最初からちゃんと設計していれば手戻りがないものを。」と。違う。こういうときに私はよく詰将棋を引き合いに出す。
新聞の片隅にある詰将棋を解いてみる。新聞とにらめっこしてアレコレ考えても中々上手くいかない。
ところが将棋盤を引っ張り出してきて、パチパチ駒を動かしてみると簡単に解けることがある。ここは実は銀を持っていた、ここで馬が効くからこの手は指せない。
人間先を読むには想像力が足りなすぎる。目の前に現物がないと気付けないことが多い。だから先に実装する。一度作ってしまえば壊してもコンパイラが助けてくれる。&lt;/p&gt;

&lt;p&gt;一度目でアタリを付ける。二度目で実線を書く。作って、壊して、また作る。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>シェル芸十八般</title>
      <link>/blog/2016/07/13/shierugeijuuhachihan</link>
      <pubDate>Wed, 13 Jul 2016 23:34:03 +0900</pubDate>
      
      <guid>/blog/2016/07/13/shierugeijuuhachihan</guid>
      <description>

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;武芸十八般のひとつシェル芸ってワードがふと湧いてきたけどどちらかというとシェル芸十八般とかの方がよさそう。grep, cut, xargs,&amp;hellip;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/753211663927513088&#34;&gt;2016年7月13日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;cat&#34;&gt;&lt;code&gt;cat&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;ファイルの内容を吐くのに使う。 -n とか使えそうなオプションがあるが滅多に使わない&lt;/p&gt;

&lt;h2 id=&#34;例&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat file
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;head&#34;&gt;&lt;code&gt;head&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;標準入力の先頭のほうだけを切り取る。大きなファイルに対して処理する前にちょろっと試すのに使う&lt;/p&gt;

&lt;h2 id=&#34;例-1&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat large_file | head -n 10 | ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tail&#34;&gt;&lt;code&gt;tail&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;標準入力の末尾のほうだけを切り取る。&lt;code&gt;-f&lt;/code&gt; オプションでよく使う&lt;/p&gt;

&lt;h2 id=&#34;例-2&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tail -f log_file | grep -ie error -e &#39;$&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;grep&#34;&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;globally regexp print. 汎用フィルタとして様々に活躍する他飛び道具的な使い方もある。&lt;/p&gt;

&lt;h2 id=&#34;例-3&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat file | grep some_word
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat file | grep -v &amp;quot;^[ \n\t]+$&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo hello | grep -o .
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;awk&#34;&gt;&lt;code&gt;awk&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;プログラミング言語awk。だいたい &lt;code&gt;cut&lt;/code&gt; の上位互換として使われる。&lt;/p&gt;

&lt;h2 id=&#34;例-4&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls -l | awk &#39;{print $3}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;seq 1 100 | awk &#39;BEGIN{sum=0}{sum+=$0}END{print sum}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sed&#34;&gt;&lt;code&gt;sed&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;プログラミング言語sed。だいたい &lt;code&gt;s/RE/replace/&lt;/code&gt; が使われるが使いこなすと深い。&lt;/p&gt;

&lt;h2 id=&#34;例-5&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat log_file | sed &#39;s/error/ERROR/gi&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat some.csv | sed 1d
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;xargs&#34;&gt;&lt;code&gt;xargs&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;標準入力を横に並べる、コマンドを並列に実行する、繰り返し実行をするなどストリーム内での制御機構的働きをする&lt;/p&gt;

&lt;h2 id=&#34;例-6&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;seq 1 10 | xargs echo
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -type f | xargs -P $(nproc) grep FIXME
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;inc(){ echo $(( 1 + $1 ));}
export -f sum
seq 1 10 | xargs -I@ bash -c &#39;sum @&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;find&#34;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;複雑なクエリ式を書けるコマンド。(シェルに依存してしまう)ワイルドカード展開の肩代わりなんかも出来る。xargsに繋げることが多い。&lt;/p&gt;

&lt;h2 id=&#34;例-7&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -type f -name &#39;*.md&#39; -exec basename &#39;{}&#39; .md \;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sort&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;ほぼ次のuniqに繋げるために使うことが多い。あるいはuniqした結果を使う。&lt;/p&gt;

&lt;h2 id=&#34;例-8&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat .histfile | grep &#39;|&#39; | sed &#39;s/|/\n/g&#39; | awk &#39;{print $1}&#39; | LANG=C sort | uniq -c | LANG=C sort
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;uniq&#34;&gt;&lt;code&gt;uniq&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;多くは頻度のカウントに使う。&lt;/p&gt;

&lt;h1 id=&#34;tar&#34;&gt;&lt;code&gt;tar&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;リモートホストとファイルをやりとりするのに使う。&lt;/p&gt;

&lt;h2 id=&#34;例-9&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh stepper ssh host1 tar czf - -C &#39;/var/log/somedir/&#39; stdout.log stderr.log | tar xzf - -C /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;zcat&#34;&gt;&lt;code&gt;zcat&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;圧縮ファイル扱うのに使う。よくtarと組み合わせる。
プロセスが分かれる分マルチコアを使えるのでtarのzオプション使うより速いかもしれない。&lt;/p&gt;

&lt;h2 id=&#34;例-10&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zcat some.tar.gz | tar tf - | xargs -I@ -n 1 basename @ .java
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;date&#34;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;日付操作用コマンド。BSD系とGNU系で全然違う。つらい。&lt;/p&gt;

&lt;h2 id=&#34;例-11&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find logs -type f -name &#39;*.log&#39; | xargs -I@ dirname @ | sed &#39;s|logs/||&#39; | tr / - | xargs -I@ date --date=@ +%w | sort | uniq -c
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tr&#34;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;文字置換、削除。&lt;code&gt;sed&lt;/code&gt;で出来るじゃんとか言わない。&lt;/p&gt;

&lt;h2 id=&#34;例-12&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat data.list | tr -c &#39;[a-zA-Z0-9\n]&#39; _ | xargs touch
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;curl&#34;&gt;&lt;code&gt;curl&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;なんでもプロトコル喋る人。結果を標準出力に吐くのでREST APIを叩いた後シェル芸に繋げやすい。&lt;/p&gt;

&lt;h2 id=&#34;例-13&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl http://example.io/status | jq -r &#39;.status&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;jq&#34;&gt;&lt;code&gt;jq&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;チューリング完全言語jq。REST API叩いてjsonが返ってきた時に使うと便利。&lt;/p&gt;

&lt;h1 id=&#34;od&#34;&gt;&lt;code&gt;od&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;バイナリデータを扱うのに使う。&lt;/p&gt;

&lt;h2 id=&#34;例-14&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat /dev/urandom | od -x | head -n 10 | ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tee&#34;&gt;&lt;code&gt;tee&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;T字管のようにパイプを分岐させるのに使う。あるいはシェルの機能であるリダイレクトをコマンドとして実行するのに使う。&lt;/p&gt;

&lt;h2 id=&#34;例-15&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat nginx.conf | ssh stepper ssh host1 sudo tee /etc/nginx/nginx.conf &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Container Desgin Patterns</title>
      <link>/blog/2016/07/02/container_desgin_patterns</link>
      <pubDate>Sat, 02 Jul 2016 22:26:10 +0900</pubDate>
      
      <guid>/blog/2016/07/02/container_desgin_patterns</guid>
      <description>

&lt;p&gt;κeenです。先日、Kubernetesの開発者が書いた&lt;a href=&#34;http://blog.kubernetes.io/2016/06/container-design-patterns.html&#34;&gt;Kubernetes: Container Design Patterns&lt;/a&gt;というのを教えてもらって、面白かったのでそれを紹介します。
ただ漫然とコンテナを使っているだけでは気付かない使い方があったのでコンテナに興味のある方は是非一読下さい。&lt;/p&gt;

&lt;h1 id=&#34;序論&#34;&gt;序論&lt;/h1&gt;

&lt;p&gt;オブジェクト指向が出てすぐにオブジェクト指向デザインパターンが産まれたように、分散システムにもデザインパターンが必要となってきました。
分散システムのデザインパターンの萌芽はHadoop/MapReduceに見ることが出来ますが、Javaに限られていました。
ところがここ数年の(Linuxの)コンテナ技術の躍進により欠けていたピースが埋まりました。分散システムパターンへのデプロイの抽象化です。
依存モジュールも一緒にデプロイ出来ますし、デプロイの状態も成功/失敗の二値になります。
それだけでなく、コンテナはオブジェクト指向におけるオブジェクトによく似た役割を果たします。それを見ていきましょう。&lt;/p&gt;

&lt;h1 id=&#34;単一コンテナのマネジメント-パターン&#34;&gt;単一コンテナのマネジメント パターン&lt;/h1&gt;

&lt;p&gt;コンテナは、自然にインターフェースの境界となります（オブジェクトと同じように）。
アプリケーション機能のインターフェースに留まらず、コンテナそのものの管理インターフェースも提供するでしょう。
典型的には &lt;code&gt;run()&lt;/code&gt; &lt;code&gt;pause()&lt;/code&gt; &lt;code&gt;stop()&lt;/code&gt; の管理ですが、もっと多様な管理インターフェースが有り得ます。&lt;/p&gt;

&lt;p&gt;大抵の今時のプログラミング言語ならHTTP経由でJSONをやりとりする機能くらい簡単に書けるのでそれがコンテナ間で統一さたインターフェースになりえるでしょう。&lt;/p&gt;

&lt;p&gt;上位のアプリケーションに対してはコンテナ内の情報(アプリケーションのQPS, プロファイル情報, コンフィグ情報, ヘルスチェック, ログなどなど)を提供するでしょう。&lt;/p&gt;

&lt;p&gt;下位のアプリケーションにはマネジメントインターフェース、例えばgraceful shutdownなどを提供することになるでしょう。
Android OSがActivityを管理する時に様々なコールバック(&lt;code&gt;onCreate&lt;/code&gt;, &lt;code&gt;onResume&lt;/code&gt;&amp;hellip;)を呼ぶように、分散マネージャがコンテナを管理するための様々なAPIを提供すると綺麗に管理出来ます。
また、コンテナ特有の機能として「レプリケーションする」（スケールアップするためのインターフェース）なんかもあるかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;単一ノード-複数コンテナのアプリケーションパターン&#34;&gt;単一ノード、複数コンテナのアプリケーションパターン&lt;/h1&gt;

&lt;p&gt;コンテナマネージャにはKubernetesのPodやNomadのTask Groupsのように複数のコンテナを1つのノードにスケジュールする機能があります。
別にコンテナに分けずに複数のコンテナをアプリケーションと同じの1つのコンテナに入れることも可能です。しかしながら分けた方が様々なメリットが得られます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;コンテナがリソース管理の単位である。cgroupによる管理がやりやすくなる。&lt;/li&gt;
&lt;li&gt;コンテナがパッケージングの単位である。複数のコンテナでデプロイや管理をするチームを分けるのも簡単になるし、テストも簡単になる。&lt;/li&gt;
&lt;li&gt;コンテナが再利用の単位である。多くのサブ機能コンテナは多種のメインコンテナと一緒に使うことが出来る。&lt;/li&gt;
&lt;li&gt;コンテナが障害を分離する境界になる。例えば、コンテントマネジメントコンテナに障害があったとしても、Webサーバコンテナはサービスを継続出来るようになる。&lt;/li&gt;
&lt;li&gt;コンテナがデプロイの単位となる。新しい機能の追加やロールバックが単独で行える。（ただし、アプリケーションのバージョンの組み合わせが増えるという点では短所にもなる）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ということでそれらを前提にしたデザインパターンをいくつか。&lt;/p&gt;

&lt;h2 id=&#34;サイドカーパターン&#34;&gt;サイドカーパターン&lt;/h2&gt;

&lt;p&gt;メインのアプリケーションコンテナにサイドカーのように付属するコンテナを付けて、機能を足すパターンです。
例えばアプリケーションがあって、それのログをローカルストレージから分散ストレージに保存するサイドカーなど。&lt;/p&gt;

&lt;p&gt;逆に、ローカルディスクのファイルを提供するWebサーバがあったとして、そのために定期的にgitからstatic fileをpollするサイドカーコンテナなんかもあるかもしれません。&lt;/p&gt;

&lt;p&gt;これらのサイドカーは同じノードのコンテナ同士ならディスクボリュームを共有出来ることに依存した作りになっています。&lt;/p&gt;

&lt;h2 id=&#34;アンバサダーパターン&#34;&gt;アンバサダーパターン&lt;/h2&gt;

&lt;p&gt;アンバサダーパターンはメインコンテナと別システムとのコミュニケーションを代理します。
例えば、&lt;a href=&#34;https://github.com/twitter/twemproxy&#34;&gt;twemproxy&lt;/a&gt; のコンテナをアンバサダーとすれば実際は複数のmemcachedにシャードされたmemcachedクラスタと通信しているも関らず、アプリケーションはローカルホストのmemcachedと通信しているように出来ます。&lt;/p&gt;

&lt;p&gt;この利点は1つにはアプリケーションをローカルホストのmemcachedと通信することだけを考えて書けばいいようになる点、もう1つにはアプリケーションのテストをローカルホストのmemcachedとだけすれば良くなる点、さらにもう1つにはtwemproxyのコンテナを（別の言語で書かれた）別のアプリケーションに使い回せる点にあります。&lt;/p&gt;

&lt;p&gt;これは同じホストのコンテナ同士はローカルホストのネットワークインターフェースを使って通信出来ることに依存した作りになっています。&lt;/p&gt;

&lt;h2 id=&#34;アダプターパターン&#34;&gt;アダプターパターン&lt;/h2&gt;

&lt;p&gt;アダプターパターンはアンバサダーパターンの逆で、アプリケーションを外部から観測した時に統一されたインターフェースを提供するようにするために使います。&lt;/p&gt;

&lt;p&gt;アプリケーション毎にメトリクスの採り方は異ります（例えばJavaならJMX、など）。様々にあるメトリクスを統一したインタフェースで提供するとメトリクスアグリゲータが非常にシンプルになります。
具体的な例を出すと&lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;のためのインターフェース (HTTP &lt;code&gt;/metrics&lt;/code&gt;)を提供する(&lt;a href=&#34;https://prometheus.io/docs/instrumenting/exporters/&#34;&gt;exporter&lt;/a&gt;)コンテナなどです。&lt;/p&gt;

&lt;p&gt;アダプターとメインコンテナはストレージやローカルホストネットワークを通じてデータをやりとりするでしょう。&lt;/p&gt;

&lt;h1 id=&#34;複数ノードアプリケーションパターン&#34;&gt;複数ノードアプリケーションパターン&lt;/h1&gt;

&lt;p&gt;次は複数のノードに跨る協調分散システムでのパターンです。
こちらも同じくPodなどの抽象化を前提とします。&lt;/p&gt;

&lt;h2 id=&#34;リーダー選出パターン&#34;&gt;リーダー選出パターン&lt;/h2&gt;

&lt;p&gt;分散システムではリーダを選出する需要が多々あります。
例えば複数のレプリカを作った時にマスターがコケたら次のマスターを選出しないといけません。&lt;/p&gt;

&lt;p&gt;巷にはリーダー選出アルゴリズムを実装したライブライが出回っていますが、往々にして難解であり、また、特定の言語でしか動かないので再利用性がありません。&lt;/p&gt;

&lt;p&gt;そこで、ライブラリを使うのではなくてリーダー選出コンテナを実装しましょう。&lt;/p&gt;

&lt;p&gt;単一ノードのパターンと同じく、リーダー選出コンテナとアプリケーションコンテナを一緒にスケジューリングします。
そして、リーダー選出コンテナが他のコンテナとネゴシエーションしてリーダーになったら、ローカルホストのHTTP APIにbecomeLeader、renewLeadershipなどのクエリを投げます。
アプリケーションはただそれらのエンドポイントを実装しさえすればいいのです。&lt;/p&gt;

&lt;p&gt;このコンテナはアプリケーションにも言語に依存しないので自由に使い回すことが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;ワークキューパターン&#34;&gt;ワークキューパターン&lt;/h2&gt;

&lt;p&gt;もう1つのよくある分散システムでのタスクは、ワークキューによる分散実行です。
いくつかワークキューの実装はありますが、やはりそれらは特定の言語に依存しています。&lt;/p&gt;

&lt;p&gt;そこで仕事の分配のコンテナ、そして、仕事実行のフレームワークとなるコンテナを用意してあげましょう。&lt;/p&gt;

&lt;p&gt;フレームワークのコンテナは分配コンテナから仕事(ファイルなど)を受け取って、ユーザの書いた実行コンテナに処理を移譲します。そしてフレームワークコンテナが実行コンテナの出力した結果をまた分配コンテナに戻します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
[Request]       +---[フレームワークコンテナ]=[実行コンテナ(ユーザ)]
   |            |
[分配コンテナ] --+
   |            |
   |            +---[フレームワークコンテナ]=[実行コンテナ(ユーザ)]
   |
[ワークキューの保存など]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分散協調の部分をフレームワークコンテナがやってくれるのでユーザが書く実行コンテナは非常にシンプルになります。&lt;/p&gt;

&lt;h2 id=&#34;分配-集約パターン&#34;&gt;分配/集約パターン&lt;/h2&gt;

&lt;p&gt;このパターンは、クライアントが1つの巨大なタスクをルートコンテナに投げ、ルートコンテナが子コンテナ達に分割したタスクを移譲します。そして子コンテナ達の結果を纏めてクライアントに返します。&lt;/p&gt;

&lt;p&gt;MapReduceと同じように、タスクを実行するリーフコンテナと、リーフコンテナの結果を纏めるマージコンテナを用意する必要があります。&lt;/p&gt;

&lt;p&gt;コンテナは特定のインターフェースさえ実装していればいいのでリファクタが(オブジェクト指向の時と同じように)容易です。&lt;/p&gt;

&lt;p&gt;また、子コンテナにルートコンテナと同じようなscatter/gather機能を持ったコンテナを使うことで、任意の深さにまでタスクツリーを作ることが出来ます。
これは例えば処理中のリソース使用量が多いときに部分的にタスクを実行してマージを繰替えすことで必要となる最大リソースを減らす、などに使えるでしょう（他にももっとあるかもしれませんがパッとは思いつきませんでした）。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;コンテナのデザインパターを紹介しました。フレームワークコンテナなど、興味深いパターンもあって興味深いですね。&lt;/p&gt;

&lt;p&gt;まだまだパターンはありえると思うのでこの分野（？）、もう少し広まると良いですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustの所有権/ミュータビリティの分割</title>
      <link>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</link>
      <pubDate>Sun, 19 Jun 2016 20:42:14 +0900</pubDate>
      
      <guid>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</guid>
      <description>

&lt;p&gt;κeenです。昔所有権/ミュータビリティを分割したくなったけどぱっと方法が思いつかなくて困ったことがあるので今更ながら備忘録として残しておきます。&lt;/p&gt;

&lt;h1 id=&#34;ミュータビリティ&#34;&gt;ミュータビリティ&lt;/h1&gt;

&lt;p&gt;例えば、HTTPパーサを作ろうとしてるとしましょう。
受け取ったバイト列のバッファをパースしてヘッダやらボディやらのサブスライスを返します。この時、返り値のサブスライスはユーザへの自由を与えるために &lt;code&gt;mut&lt;/code&gt; にしたいですよね。&lt;/p&gt;

&lt;p&gt;そう思ってこういうコードを書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io;

fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...
    Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mutability_split.rs:4:31: 4:34 error: cannot borrow `*buf` as mutable more than once at a time [E0499]
mutability_split.rs:4     Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通にやろうとすると
1つ1つミュータブルなサブスライスを作ることになり、2つ目以降でborrow checkに引っ掛かってしまいます。2つのバッファがオーバーラップしてなくても。難儀ですね。コピーするくらいしかないのでしょうか。いいえ。rustはちゃんと助けになるAPIを用意してくれています。&lt;/p&gt;

&lt;h2 id=&#34;split-at-mut-https-doc-rust-lang-org-std-primitive-slice-html-method-split-at-mut&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut&#34;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn split_at_mut(&amp;amp;mut self, mid: usize) -&amp;gt; (&amp;amp;mut [T], &amp;amp;mut [T])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スライスを2つに分割してくれます。重要なのが、ミュータビリティも分割してくれるところです。返り値の2つ共に &lt;code&gt;mut&lt;/code&gt; がついています。ということで、次のように実装出来ます。（実行してないので結果が正しいかは確認してませんが）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...

    let (h, b) = buf.split_at_mut(bstart);
    let h = {
        let (_, h) = h.split_at_mut(hstart);
        let (_, h) = h.split_at_mut(hend - hstart);
        h
    };

    let (_, b) = b.split_at_mut(bend - bstart);

    Ok((h, b))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;所有権&#34;&gt;所有権&lt;/h1&gt;

&lt;p&gt;似たような話で、構造体の所有権というか、貸与権(?)を分割したい時もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonDB {
    name: String,
    age: usize,
    address: String,
}


fn use_immutable(s: &amp;amp;str) {
    // empty
}

fn use_mutable(s: &amp;amp;mut str) {
    // empty
}



fn from_db(person: PersonDB) {
    let name = &amp;amp;person.name;
    let mut address = &amp;amp;mut person.address;
    use_immutable(name);
    use_mutable(address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イミュータブルとミュータブル両方の借用があるのでエラーになってしまいます。実際は別のフィールドなので問題は起きないのですが、コンパイラに怒られます。理不尽ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mutability_split.rs:36:28: 36:42 error: cannot borrow immutable field `person.address` as mutable
mutability_split.rs:36     let mut address = &amp;amp;mut person.address;
                                                  ^~~~~~~~~~~~~~

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そういう時は、パターンマッチによる分配束縛でクリア出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn from_db(person: PersonDB) {
    let PersonDB {name, mut address, ..} = person;
    use_immutable(&amp;amp;name);
    use_mutable(&amp;amp;mut address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Rustの所有権やミュータブルな参照など、1つしか存在出来ないとされるものが分割出来ることを示しました。
地味に悩む所なので誰かの助けになれば幸いです。&lt;/p&gt;

&lt;p&gt;蛇足を足すと、本当は所有権の分割についても書く予定でしたがエラーになる筈のコードがあっさりコンパイルを通ってしまったのでナシになりました。コンパイラも進化してますね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>multirustが非推奨になったようなのでrustupに移行する</title>
      <link>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</link>
      <pubDate>Sun, 12 Jun 2016 15:23:06 +0900</pubDate>
      
      <guid>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</guid>
      <description>

&lt;p&gt;κeenです。どうやらもうそろそろRustのツールチェーン管理はmultirustじゃなくてrustupを使った方が良さそうなので移行しようと思います。&lt;/p&gt;

&lt;p&gt;きっかけはmultirustにそういうコミットがされたから。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;もうmultirustじゃなくてrustup使え、と。&lt;br&gt;&lt;br&gt;Update README.md · brson/multirust@84c3459&lt;a href=&#34;https://t.co/ySeRB50x5C&#34;&gt;https://t.co/ySeRB50x5C&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/741077158651514882&#34;&gt;2016年6月10日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;因みにrustupは&lt;a href=&#34;https://github.com/rust-lang/rustup.sh&#34;&gt;rust-lang/rustup.sh: The rustup.sh script for installing Rust from release channels&lt;/a&gt;ではなく&lt;a href=&#34;https://github.com/rust-lang-nursery/rustup.rs&#34;&gt;rust-lang-nursery/rustup.rs: The Rust toolchain installer&lt;/a&gt;の方です。インストールガイドなどはこちらから。&lt;a href=&#34;https://www.rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なんかベータ版のようですが推奨していいんですかね…。&lt;/p&gt;

&lt;p&gt;とりあえずmultirustを入れたままコマンドを叩いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer
warning: it looks like you have an existing installation of multirust
warning: rustup cannot be installed alongside multirust
warning: run `/usr/local/lib/rustlib/uninstall.sh` as root and delete `/home/kim/.multirust/version` before installing rustup
error: cannot install while multirust is installed
rustup: command failed: /tmp/tmp.9kjQj9WT5O/rustup-init

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふーむ。アンインストールしろ、と。一応指示された通りmultirust自体はアンインストールせずにversionだけを削除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/local/lib/rustlib/uninstall.sh
install: uninstalling component &#39;multirust&#39;

    multirust is uninstalled.
$ rm -rf ~/.multirust/version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう一度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;選択肢が出ました。とりあえず1を選択します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: toolchain &#39;stable&#39; is not installed
info: caused by: not a directory: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu&#39;
rustup: command failed: /tmp/tmp.nugK4VN4p8/rustup-init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;えー。ちょっと…。仕方ないのでシンボリックリンクを貼って騙してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls ~/.multirust/toolchains/
beta  nightly  stable
$ ln -s ~/.multirust/toolchains/{stable,stable-x86_64-unknown-linux-gnu}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3度目の正直なるか&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
1

info: updating existing rustup installation


Rust is installed now. Great!

To get started you need Cargo&#39;s bin directory in your PATH environment variable.
Next time you log in this will be done automatically.

To configure your current shell run source $HOME/.cargo/env.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストール出来たよう。しかしセットアップは &lt;code&gt;~/.profile&lt;/code&gt; に書かれたようなので &lt;code&gt;.zshrc&lt;/code&gt; は自分で更新します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/zshrc b/zshrc
index 0178873..589c6a5 100644
--- a/zshrc
+++ b/zshrc
@@ -213,7 +213,7 @@ export PATSHOME=~/compile/ATS2-Postiats-$ATS_VERSION/
 export PATH=$PATSHOME/bin:$PATH
 export PATSHOMERELOC=~/compile/ATS2-Postiats-contrib-$ATS_VERSION
 
-export PATH=$PATH:~/.multirust/toolchains/stable/cargo/bin
+export PATH=&amp;quot;$HOME/.cargo/bin:$PATH&amp;quot;
 
 # OPAM configuration
 . /home/kim/.opam/opam-init/init.sh &amp;gt; /dev/null 2&amp;gt; /dev/null || true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup 0.1.12 (c6e430a 2016-05-12)
The Rust toolchain installer

USAGE:
    rustup [FLAGS] [SUBCOMMAND]

FLAGS:
    -v, --verbose    Enable verbose output
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    show         Show the active and installed toolchains
    update       Update Rust toolchains
    default      Set the default toolchain
    toolchain    Modify or query the installed toolchains
    target       Modify a toolchain&#39;s supported targets
    override     Modify directory toolchain overrides
    run          Run a command with an environment configured for a given toolchain
    which        Display which binary will be run for a given command
    doc          Open the documentation for the current toolchain.
    self         Modify the rustup installation
    telemetry    rustup telemetry commands
    help         Prints this message or the help of the given subcommand(s)

rustup installs The Rust Programming Language from the official
release channels, enabling you to easily switch between stable, beta,
and nightly compilers and keep them updated. It makes cross-compiling
simpler with binary builds of the standard library for common platforms.

If you are new to Rust consider running `rustup doc --book`
to learn Rust.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;multirustを使っていたら馴染めそうですね。&lt;/p&gt;

&lt;p&gt;一応どこにインストールされたのか確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which rustc
/home/kim/.cargo/bin/rustc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふむふむ。ちょいとアップデートしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.1 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.0 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   2.3 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %) 953.6 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.2 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.5 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 44.8 MiB /  44.8 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 57.9 MiB /  57.9 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.0 MiB /   7.0 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.3 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 46.5 MiB /  46.5 MiB (100 %) 924.8 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 59.0 MiB /  59.0 MiB (100 %)   2.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.3 MiB /   7.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   3.2 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: checking for self-updates
info: rustup is up to date

                           stable update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
  stable-x86_64-unknown-linux-gnu update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                                 beta installed - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                              nightly installed - rustc 1.11.0-nightly (0554abac6 2016-06-10)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、なんかコケてる…。シンボリックリンクが悪さしたかな…。しかし試しに手元のプロダクトをコンパイルしてみたら通ったので使えているよう。&lt;/p&gt;

&lt;p&gt;さて、クロスコンパイルの方はどうでしょうか。以前Raspberry Pi向けにクロスコンパイルしました &lt;a href=&#34;http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/&#34;&gt;RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog&lt;/a&gt;。これは動くでしょうか。&lt;/p&gt;

&lt;p&gt;とりあえずインストール可能なターゲットを確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………。無理矢理addしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target add nightly-arm-unknown-linux-gnueabihf
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………………………………。&lt;/p&gt;

&lt;p&gt;なんか変ですね。&lt;/p&gt;

&lt;p&gt;一旦&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm ~/.multirust/toolchains/stable-x86_64-unknown-linux-gnu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;してもう一度 &lt;code&gt;rustup update&lt;/code&gt; します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.6 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.7 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   5.0 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: checking for self-updates
info: rustup is up to date

                            stable installed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                              beta unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
     beta-x86_64-unknown-linux-gnu unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                           nightly unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
  nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、今回は上手くいった。やっぱりシンボリックリンクが悪かったよう。リトライ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target add --toolchain nightly arm-unknown-linux-gnueabihf
info: downloading component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
 62.6 MiB /  62.6 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: installing component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んー、ちゃんとnightlyが入ったのか分からない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup show
installed toolchains
--------------------

stable
stable-x86_64-unknown-linux-gnu (default)
beta
beta-x86_64-unknown-linux-gnu
nightly
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.9.0 (e4e8b6668 2016-05-18)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし件のARM向けプロジェクトのクロスコンパイルは出来たよう。&lt;/p&gt;

&lt;p&gt;もう一度listを見る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;arm-unknown-linux-gnueabihf (installed)&lt;/code&gt; とあるのでインストール出来ているよう。しかし本当にnightlyなのか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup target list --toolchain stable
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target list --toolchain nightly
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら本当にnightlyのよう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;色々あたふたとしましたがrustupをインストールして使ってみました。multirustを使っているとインストールあたりでやや難はありそうですがそれ以降は普通に使えそうです。&lt;/p&gt;

&lt;p&gt;皆様もお試しあれ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cargo-profilerを試す</title>
      <link>/blog/2016/05/14/cargo_profilerwotamesu</link>
      <pubDate>Sat, 14 May 2016 20:59:13 +0900</pubDate>
      
      <guid>/blog/2016/05/14/cargo_profilerwotamesu</guid>
      <description>

&lt;p&gt;κeenです。先日Rustのニュースに流れてきたcargo profilerを試してみます。
元の紹介記事はこちら&lt;a href=&#34;http://www.suchin.co/2016/05/11/Introducing-Cargo-Profiler/&#34;&gt;Introducing Cargo Profiler · suchin&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;GitHubレポジトリはこちら&lt;a href=&#34;https://github.com/pegasos1/cargo-profiler&#34;&gt;pegasos1/cargo-profiler: cargo subcommand to profile binaries&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Profilerとはいっても自身でプロファイラを持っている訳ではなくて外部のプロファイラ（現状valgrind）を呼び出して整形してくれるツールのようです。
Rust向けに関数をモジュールパス付きで表示してくれたりするのでRustから使うにはvalgrind生より便利そうです。&lt;/p&gt;

&lt;h1 id=&#34;インストール&#34;&gt;インストール&lt;/h1&gt;

&lt;p&gt;READMEに従って&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt install valgrind
$ cargo install cargo-profiler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;h1 id=&#34;プロジェクトの準備&#34;&gt;プロジェクトの準備&lt;/h1&gt;

&lt;p&gt;適当なものがないので手元の[κLisp]()でフィボナッチ数列を動かしてみます。(と思ったらκLispに比較演算子がなかったのでそれを作るところから始まりましたがそれはまた別の話)。&lt;/p&gt;

&lt;p&gt;main.rsはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate kappa_lisp;
use kappa_lisp::kappa_lisp::{run, init};
use kappa_lisp::env::Env;

fn main() {
    let mut env = Env::new();
    init(&amp;amp;mut env).unwrap();
    run(&amp;amp;mut env, r&amp;quot;
(defun fib (n)
  (if (&amp;lt; n 2)
      1
      (+ (fib (- n 1)) (fib (- n 2)))))
&amp;quot;).unwrap();
    let expr = run(&amp;amp;mut env, r&amp;quot; (fib 20) &amp;quot;).unwrap();
    println!(&amp;quot;{}&amp;quot;, expr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;割と遅いので20くらいで限界でした。&lt;/p&gt;

&lt;p&gt;さて、これを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo build --release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてビルドします。&lt;/p&gt;

&lt;h1 id=&#34;プロファイル&#34;&gt;プロファイル&lt;/h1&gt;

&lt;p&gt;今のところcallgrindとcachegrindが実装されているようです。1つづづ試してみます。&lt;/p&gt;

&lt;h2 id=&#34;callgrind&#34;&gt;callgrind&lt;/h2&gt;

&lt;p&gt;よく分かってないのですが多分実行時間に占める関数毎の割合を出してくれるんですかね。-nで上位何件を表示するか指定出来ます。&lt;/p&gt;

&lt;p&gt;とりあえず上位10件出してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo profiler callgrind --bin ./target/release/kappa_lisp -n 10
Profiling kappa_lisp with callgrind...

Total Instructions...571,437,255

142,527,726 (24.9%) ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
107,551,309 (18.8%) ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
39,749,571 (7.0%) ???:collections::hash::map::HashMap..K$C$..V$C$..S..::get
-----------------------------------------------------------------------
38,693,006 (6.8%) ???:sdallocx
-----------------------------------------------------------------------
37,670,732 (6.6%) ???:mallocx
-----------------------------------------------------------------------
34,608,049 (6.1%) ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
26,539,906 (4.6%) ???:eval::eval
-----------------------------------------------------------------------
19,887,024 (3.5%) ???:util::f_foldr
-----------------------------------------------------------------------
16,634,175 (2.9%) ???:eval::feval
-----------------------------------------------------------------------
14,353,992 (2.5%) ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、こんな感じです。ハッシュテーブル関連が時間喰ってますね。これは関数呼び出しの度に行われてます。
ちょっと実装が雑すぎるので直さなきゃ…。&lt;/p&gt;

&lt;h1 id=&#34;cachegrind&#34;&gt;cachegrind&lt;/h1&gt;

&lt;p&gt;キャッシュミスを表示してくれます。本気出してチューニングする時に必要ですね。&lt;/p&gt;

&lt;p&gt;同じく -nで件数を絞り込めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10  


Profiling kappa_lisp with cachegrind...

Total Memory Accesses...800,070,388	

Total L1 I-Cache Misses...100,068 (0%)	
Total LL I-Cache Misses...422 (0%)	
Total L1 D-Cache Misses...4,346,335 (0%)	
Total LL D-Cache Misses...7,724 (0%)	

 Ir  I1mr ILmr  Dr  D1mr DLmr  Dw  D1mw DLmw
0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get
-----------------------------------------------------------------------
0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx
-----------------------------------------------------------------------
0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx
-----------------------------------------------------------------------
0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval
-----------------------------------------------------------------------
0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr
-----------------------------------------------------------------------
0.03 0.02 0.05 0.04 0.05 0.00 0.02 0.06 0.05 ???:eval::feval
-----------------------------------------------------------------------
0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やはりハッシュテーブルが酷いですが同じコードを繰り返し実行するタイプのマイクロベンチマークなのでキャッシュミスは少ないです。&lt;/p&gt;

&lt;p&gt;因みにそれぞれの列はこういう意味だそうです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ir -&amp;gt; Total Instructions&lt;/li&gt;
&lt;li&gt;I1mr -&amp;gt; Level 1 I-Cache misses&lt;/li&gt;
&lt;li&gt;ILmr -&amp;gt; Last Level I-Cache misses&lt;/li&gt;
&lt;li&gt;Dr -&amp;gt; Total Memory Reads&lt;/li&gt;
&lt;li&gt;D1mr -&amp;gt; Level 1 D-Cache read misses&lt;/li&gt;
&lt;li&gt;DLmr -&amp;gt; Last Level D-cache read misses&lt;/li&gt;
&lt;li&gt;Dw -&amp;gt; Total Memory Writes&lt;/li&gt;
&lt;li&gt;D1mw -&amp;gt; Level 1 D-Cache write misses&lt;/li&gt;
&lt;li&gt;DLmw -&amp;gt; Last Level D-cache write misses&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;--sort&lt;/code&gt; オプションでどの列をみるのか指定出来るようです。全メモリアクセスのミスレートを見てみましょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10 --sort dr


Profiling kappa_lisp with cachegrind...

Total Memory Accesses...800,082,686	

Total L1 I-Cache Misses...100,083 (0%)	
Total LL I-Cache Misses...420 (0%)	
Total L1 D-Cache Misses...4,321,895 (0%)	
Total LL D-Cache Misses...7,721 (0%)	

 Ir  I1mr ILmr  Dr  D1mr DLmr  Dw  D1mw DLmw
0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx
-----------------------------------------------------------------------
0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get
-----------------------------------------------------------------------
0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx
-----------------------------------------------------------------------
0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval
-----------------------------------------------------------------------
0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr
-----------------------------------------------------------------------
0.03 0.02 0.05 0.04 0.04 0.00 0.02 0.06 0.05 ???:eval::feval
-----------------------------------------------------------------------
0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やっぱりハッシュテーブル関連が重い…。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;私にとっては薮蛇にκLispの実装の筋が悪いことが分かったりしてショックでしたがまあ、簡単にプロファイルをとれるツールを紹介しました。&lt;/p&gt;

&lt;p&gt;Rustで高速なアプリケーションを作りたい方、利用してみては如何でしょうか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RustでベアメタルRaspberry PiのLチカ</title>
      <link>/blog/2016/05/04/rustdebeametaruraspberry_pinolchika</link>
      <pubDate>Wed, 04 May 2016 11:43:26 +0900</pubDate>
      
      <guid>/blog/2016/05/04/rustdebeametaruraspberry_pinolchika</guid>
      <description>

&lt;p&gt;κeenです。GWもくもく会で机の片隅で埃被ってたRSPiのベアメタルを触ってみたのでその成果報告を。
ベアメタルについて知らない人でも読めるように書きます。そしてアセンブラもCも出てきませんし、半田付けも必要ありません。
Rustしか使いません。&lt;/p&gt;

&lt;p&gt;Rustは分かるけどLチカは全く知らない、けど興味のある方は是非読んでみて下さい。&lt;/p&gt;

&lt;h1 id=&#34;ベアメタルって&#34;&gt;ベアメタルって？&lt;/h1&gt;

&lt;p&gt;普段我々が使っているパソコンはOSの上で動いています。
OSはざっくりいうとハードウェアへのアクセスを抽象化し、プロセスという単位でプログラムの実行を分離します。
ベアメタルはそのOSがない状態、ハードウェアの初期化やプロトコルなどは自分でやるしメモリ管理だとかも自分でやる環境です。
丁度ハードウェアが抽象化されてなくて機械が生で見えているようなのでこう呼ぶようです。&lt;/p&gt;

&lt;p&gt;OSがないのは中々イメージつきづらいですが、標準出力なんてものはないのでHello Worldも動きませんしメモリも仮想化されていないのでmallocも発効出来ません。
さらにはスタックとヒープみたいな区別もOSが与えてくれるものなので、自分で作らない限りスタック領域も使えません。
自分で書いたプログラムが唯一走るプログラムなのでプロセスの感覚でプログラムを終了させてはいけません。&lt;/p&gt;

&lt;p&gt;なんでそんな環境でプログラムしたいかというといくつかモチベーションがありそうです。1つはOSそのものを作ってみたい人が練習がてら。
もう1つにはOSが動かないような小さな環境だとそれしか選択肢がない。&lt;/p&gt;

&lt;p&gt;RSPiの場合はOSが動くので選択肢がないという訳ではないのですが私はそういう小さなデバイスを持っていないので実験台としてRSPiを使いました。&lt;/p&gt;

&lt;p&gt;さて、Hello Worldすら動かないシステムでの入門的なプログラムは信号のON/OFFを切り替えてあげるだけで出来るLEDをチカチカさせるプログラムという訳です。&lt;/p&gt;

&lt;h1 id=&#34;raspberry-pi&#34;&gt;Raspberry Pi&lt;/h1&gt;

&lt;p&gt;言わずと知れた名刺サイズの小型コンピュータ、Raspberry Piです。
Raspberry Piと一口にいっても&lt;a href=&#34;https://ja.wikipedia.org/wiki/Raspberry_Pi&#34;&gt;色々種類がある&lt;/a&gt;のですが、私が持っているのはRaspberry Pi 1 Model Bの後期モデルです(Raspberry Pi 1 Model Bは販売途中で仕様がアップグレードしてメモリが増えた)。&lt;/p&gt;

&lt;p&gt;ARMv6アーキテクチャのチップ(ARM1176JZF-S)で動いていて、SDカードから起動します。特別なライターなどは必要なく、PCからSDカードに書き込んでRSPiに挿して電源を繋ぐだけで簡単に起動出来る訳です。
さらに配線とかが必要なGPIOに加えてボードにLEDもついているので物理の知識必要なくて今回のようにLチカだけをやりたいなら手軽に遊べます。&lt;/p&gt;

&lt;h1 id=&#34;準備&#34;&gt;準備&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 1 Model B&lt;/li&gt;
&lt;li&gt;USB - micro USBケーブル(Raspberry Piへの給電用)&lt;/li&gt;
&lt;li&gt;SDカード(FAT32でフォーマットしておく)&lt;/li&gt;
&lt;li&gt;GCCのARM向けクロスコンパイラ(後述)&lt;/li&gt;
&lt;li&gt;RustのARM向けクロスコンパイラ(後述)&lt;/li&gt;
&lt;li&gt;ブートローダ(後述)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gccのクロスコンパイラ&#34;&gt;GCCのクロスコンパイラ&lt;/h2&gt;

&lt;p&gt;GCCのクロスコンパイラは&lt;a href=&#34;https://launchpad.net/gcc-arm-embedded&#34;&gt;GCC ARM Embedded in Launchpad&lt;/a&gt;というプロジェクトがあるので簡単に用意出来ます。Ubuntu環境なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install gcc-arm-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストールできます。どうやらRSPiには不動小数点数計算ユニット(FPU)がついているようなのでhf(Hardware Float)で大丈夫みたいです。
HomebrewやPacmanにもパッケージはあるようです。&lt;/p&gt;

&lt;h2 id=&#34;rustのクロスコンパイラ&#34;&gt;Rustのクロスコンパイラ&lt;/h2&gt;

&lt;p&gt;次にRustのクロスコンパイラですが、&lt;a href=&#34;https://github.com/brson/multirust&#34;&gt;multirust&lt;/a&gt;を使うと簡単にインストール出来ます。今回はunstable機能も使うのでnightlyコンパイラを使います。
因みに私が昔インストールしたmultirustだと古くて以下のコマンドが実行出来なかったので出来ない方はmultirustをアップデートして試してみて下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# インストール可能なターゲットを確認
$ multirust list-available-targets nightly
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-linux-gnu
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
# インストール
$ multirust add-target nightly arm-unknown-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ブートローダ&#34;&gt;ブートローダ&lt;/h2&gt;

&lt;p&gt;まず、ブートローダが何をするものなのかから説明しましょう。興味がない人は飛ばして下さい。&lt;/p&gt;

&lt;h3 id=&#34;説明&#34;&gt;説明&lt;/h3&gt;

&lt;p&gt;Raspberry PiにはCPUとGPUが両方ついているのでやや面倒です。&lt;/p&gt;

&lt;p&gt;CPU/GPUは電源がONになってすぐは何の機能もない、ただの命令を実行する機械です。メモリにすらアクセス出来ません。RSPiにSDカードを挿したところでSDカードのプロトコルを喋らないとそこに書いてあるプログラムが読めません。
SDカードのプロトコルを喋るプログラム(BIOS)は、RSPiに組込みで入っています。これは普段我々が使うメモリ(RAM)とは別の場所(ROM)に入っています。&lt;/p&gt;

&lt;p&gt;最初はGPUがそいつを起動し、(この時点ではCPUは起動してない)SDカードを読みにいきます。名前決め打ちでbootcode.binという名前のプログラムを、RAMではなくGPU(のL2キャッシュ)に直接ロードして実行します(メモリはまだ使えません)。
GPUのキャッシュは非常に小さいのでbootcode.binは小さなプログラムでないといけません。&lt;/p&gt;

&lt;p&gt;bootcode.binはRAMを有効にしてstart.elfをRAMに読み込み、GPUがそれを実行します。start.elfはRAMを使えるのである程度大きくても構いません。&lt;/p&gt;

&lt;p&gt;start.elfはconfig.txt、cmdline.txtとkernel.imgを読みにいき、kernel.imgを0x8000番地のメモリに配置します。そしてconfgやcmdlineに基いてCPUを設定してkernel.imgに引数を渡しつつ実行します。&lt;/p&gt;

&lt;p&gt;このkernel.imgは普段はLinuxカーネルなどのカーネル、今回は我々が作るLチカのプログラムです。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://kernhack.hatenablog.com/entry/2014/01/11/102237&#34;&gt;Raspberry Piのブートプロセスメモ - φ(・・*)ゞ ｳｰﾝ　カーネルとか弄ったりのメモ&lt;/a&gt;
昔はloader.binもあったようですが今はなくて大丈夫なようです。&lt;/p&gt;

&lt;h3 id=&#34;インストール&#34;&gt;インストール&lt;/h3&gt;

&lt;p&gt;bootcode.bin, start.elfは&lt;a href=&#34;https://github.com/raspberrypi/firmware/tree/master/boot&#34;&gt;こちら&lt;/a&gt;から入手出来ます。config.txtとcmdline.txtはなくていいようです。&lt;/p&gt;

&lt;p&gt;こいつらはSDカードに放り込んでおきます。&lt;/p&gt;

&lt;h1 id=&#34;環境確認&#34;&gt;環境確認&lt;/h1&gt;

&lt;p&gt;まずはコンパイラツールチェーンが正常に動くか確認しましょう。
以下にrustコードを。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(lang_items, asm)]
#![crate_type = &amp;quot;staticlib&amp;quot;]
#![no_std]

#[no_mangle]
pub extern fn main() {
    loop{}
}


#[no_mangle]
pub extern fn _sbrk() {}
#[no_mangle]
pub extern fn _exit() {}
#[no_mangle]
pub extern fn _kill() {}
#[no_mangle]
pub extern fn _getpid() {}


#[lang = &amp;quot;eh_personality&amp;quot;]
extern fn eh_personality() {}

#[lang = &amp;quot;panic_fmt&amp;quot;]
extern fn panic_fmt() {}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、今回作るのは &lt;code&gt;#![crate_type = &amp;quot;staticlib&amp;quot;]&lt;/code&gt; を使って静的リンクライブラリを作れと指定しています。そして &lt;code&gt;#[no_mangle] pub extern fn main() {&lt;/code&gt; でC言語と同じような規則でmain関数を定義する(アセンブラからmain関数を実行出来るようにする)と指定しています。
ベアメタル環境なのでファイルだとか諸々のものはなく、stdを使えないので &lt;code&gt;#![no_std]&lt;/code&gt; を指定してstdを使わずにcoreライブラリを使うようにしました。その代わり&lt;code&gt;#[lang = &amp;quot;eh_personality&amp;quot;] extern fn eh_personality() {}&lt;/code&gt; と &lt;code&gt;#[lang = &amp;quot;panic_fmt&amp;quot;] extern fn panic_fmt() {}&lt;/code&gt; を実装してあげないといけません(この実装はあまりよろしくないのですが今回はとりあえずコンパイルが通るようにということでこうしてます)。&lt;/p&gt;

&lt;p&gt;そしてよく分かってないのですがRustが &lt;code&gt;_sbrk&lt;/code&gt; 、 &lt;code&gt;_exit&lt;/code&gt; 、 &lt;code&gt;_kill&lt;/code&gt; 、 &lt;code&gt;_getpid&lt;/code&gt; のシンボルを捜しにいくのでとりあえずスタブを挿してます。&lt;/p&gt;

&lt;p&gt;no_mangle, no_std, lang_itemsについて詳しくは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/&#34;&gt;ドキュメント&lt;/a&gt;をご覧下さい。
&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/ffi.html&#34;&gt;他言語関数インターフェイス&lt;/a&gt;、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/no-stdlib.html&#34;&gt;No stdlib&lt;/a&gt;、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/lang-items.html&#34;&gt;言語アイテム&lt;/a&gt;あたりが参考になるかと思います。&lt;/p&gt;

&lt;p&gt;以下のようにコンパイル出来ればRustはOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustc --target arm-unknown-linux-gnueabihf --emit=obj test.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、elfファイルを作ります。これは以下のコマンドで出来ます。Cのクロスコンパイラを使っていますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles test.o -o kernel.elf
/usr/lib/gcc/arm-none-eabi/4.9.3/../../../arm-none-eabi/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000008000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-mで始まるオプションはRaspberry Piのチップ固有の指定、 -nostartfiles はベアメアルで動かすのに必要な指定ですね。&lt;/p&gt;

&lt;p&gt;最後にelfファイルからimgファイルを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arm-none-eabi-objcopy kernel.elf -O binary kernel.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私もよく分かってないのですがobjファイルが不完全なバイナリファイル、elfが完全なバイナリファイル、imgがelfを実際のメモリに展開した時のものそのままなんですかね。
逆にいうとOSのない環境で動かすには生のimgが欲しいけどそれを作るのは難しいから一旦elfを作ってそこからimgを生成している？&lt;/p&gt;

&lt;p&gt;さて、とりあえずここまで来れば環境は整いました。あとはプログラムを書くだけです。&lt;/p&gt;

&lt;h1 id=&#34;lチカ&#34;&gt;Lチカ&lt;/h1&gt;

&lt;p&gt;RSPiにくっついているLEDはデバイスとしてはGPIOのように見えるみたいです。
そしてGPIOはMemory Mapped IO、特定の位置のメモリを読み書きすることでデバイスをいじれるようになってるみたいです。
このセットアップは誰がやったんだって気になりますがBIOSなんですかね。&lt;/p&gt;

&lt;p&gt;さて、この「特定の位置のメモリ」ですが、Raspberry Pi 1だと &lt;code&gt;0x20200000&lt;/code&gt; から始まるアドレス、のようです。2だと &lt;code&gt;3F200000&lt;/code&gt; のよう。&lt;/p&gt;

&lt;p&gt;そして0x20200000からいくつかの32bitレジスタが配列のように並んでいる訳ですがこれまたRSPi+やRSP 2とRSPi 1はLEDに対応するレジスタがやや違うようです。&lt;/p&gt;

&lt;p&gt;面倒なのでコピペで済ませると(私はCのコードからRustに移植しました。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Raspberry Pi2
//pub const GPIO_BASE: u32 = 0x3F200000;
// other
pub const GPIO_BASE: u32 = 0x20200000;



// Raspberrp Pi+ or Raspberry Pi2
//pub const LED_GPFSEL: isize   = GPIO_GPFSEL4;
//pub const LED_GPFBIT: i32     = 21;
//pub const LED_GPSET: isize    = GPIO_GPSET1;
//pub const LED_GPCLR: isize    = GPIO_GPCLR1;
//pub const LED_GPIO_BIT: isize = 15;
//  other
pub const LED_GPFSEL: isize = GPIO_GPFSEL1;
pub const LED_GPFBIT: i32 = 18;
pub const LED_GPCLR: isize = GPIO_GPCLR0;
pub const LED_GPSET: isize = GPIO_GPSET0;
pub const LED_GPIO_BIT: i32 = 16;

pub const GPIO_GPFSEL0: isize   = 0;
pub const GPIO_GPFSEL1: isize   = 1;
pub const GPIO_GPFSEL2: isize   = 2;
pub const GPIO_GPFSEL3: isize   = 3;
pub const GPIO_GPFSEL4: isize   = 4;
pub const GPIO_GPFSEL5: isize   = 5;
pub const GPIO_GPSET0: isize    = 7;
pub const GPIO_GPSET1: isize    = 8;
pub const GPIO_GPCLR0: isize    = 10;
pub const GPIO_GPCLR1: isize    = 11;
pub const GPIO_GPLEV0: isize    = 13;
pub const GPIO_GPLEV1: isize    = 14;
pub const GPIO_GPEDS0: isize    = 16;
pub const GPIO_GPEDS1: isize    = 17;
pub const GPIO_GPREN0: isize    = 19;
pub const GPIO_GPREN1: isize    = 20;
pub const GPIO_GPFEN0: isize    = 22;
pub const GPIO_GPFEN1: isize    = 23;
pub const GPIO_GPHEN0: isize    = 25;
pub const GPIO_GPHEN1: isize    = 26;
pub const GPIO_GPLEN0: isize    = 28;
pub const GPIO_GPLEN1: isize    = 29;
pub const GPIO_GPAREN0: isize   = 31;
pub const GPIO_GPAREN1: isize   = 32;
pub const GPIO_GPAFEN0: isize   = 34;
pub const GPIO_GPAFEN1: isize   = 35;
pub const GPIO_GPPUD: isize     = 37;
pub const GPIO_GPPUDCLK0: isize = 38;
pub const GPIO_GPPUDCLK1: isize = 39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうなります(cfgを使ってないです。ごめんなさい。)。&lt;/p&gt;

&lt;p&gt;次にLチカですが、
LEDに対応するGPIOをwriteに初期化する→ループ{LEDに対応するGPIOをセットする → スリープ → LEDに対応するGPIOをクリアする → スリープ}&lt;/p&gt;

&lt;p&gt;のプログラムを書きます。&lt;/p&gt;

&lt;p&gt;色々試したのですが簡単なプログラムだと最適化で消えてしまうので消えないように工夫する必要があります。&lt;/p&gt;

&lt;p&gt;スリープはとりあえずタイマーを使わずに空ループを回すのですが、ループの中身は空インラインアセンブラを使うと消えないようです。&lt;/p&gt;

&lt;p&gt;また、メモリへの書き込みは&lt;a href=&#34;https://doc.rust-lang.org/core/intrinsics/&#34;&gt;intrinsic&lt;/a&gt;の&lt;a href=&#34;https://doc.rust-lang.org/core/intrinsics/fn.volatile_store.html&#34;&gt;volatile_store&lt;/a&gt;を使います。&lt;/p&gt;

&lt;p&gt;ということでコードは以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(lang_items, asm, core_intrinsics)]
#![crate_type = &amp;quot;staticlib&amp;quot;]
#![no_std]

use core::intrinsics::volatile_store;

// Raspberry Pi2
//pub const GPIO_BASE: u32 = 0x3F200000;
// other
pub const GPIO_BASE: u32 = 0x20200000;



// Raspberrp Pi+ or Raspberry Pi2
//pub const LED_GPFSEL: isize   = GPIO_GPFSEL4;
//pub const LED_GPFBIT: i32     = 21;
//pub const LED_GPSET: isize    = GPIO_GPSET1;
//pub const LED_GPCLR: isize    = GPIO_GPCLR1;
//pub const LED_GPIO_BIT: isize = 15;
//  other
pub const LED_GPFSEL: isize = GPIO_GPFSEL1;
pub const LED_GPFBIT: i32 = 18;
pub const LED_GPCLR: isize = GPIO_GPCLR0;
pub const LED_GPSET: isize = GPIO_GPSET0;
pub const LED_GPIO_BIT: i32 = 16;

pub const GPIO_GPFSEL0: isize   = 0;
pub const GPIO_GPFSEL1: isize   = 1;
pub const GPIO_GPFSEL2: isize   = 2;
pub const GPIO_GPFSEL3: isize   = 3;
pub const GPIO_GPFSEL4: isize   = 4;
pub const GPIO_GPFSEL5: isize   = 5;
pub const GPIO_GPSET0: isize    = 7;
pub const GPIO_GPSET1: isize    = 8;
pub const GPIO_GPCLR0: isize    = 10;
pub const GPIO_GPCLR1: isize    = 11;
pub const GPIO_GPLEV0: isize    = 13;
pub const GPIO_GPLEV1: isize    = 14;
pub const GPIO_GPEDS0: isize    = 16;
pub const GPIO_GPEDS1: isize    = 17;
pub const GPIO_GPREN0: isize    = 19;
pub const GPIO_GPREN1: isize    = 20;
pub const GPIO_GPFEN0: isize    = 22;
pub const GPIO_GPFEN1: isize    = 23;
pub const GPIO_GPHEN0: isize    = 25;
pub const GPIO_GPHEN1: isize    = 26;
pub const GPIO_GPLEN0: isize    = 28;
pub const GPIO_GPLEN1: isize    = 29;
pub const GPIO_GPAREN0: isize   = 31;
pub const GPIO_GPAREN1: isize   = 32;
pub const GPIO_GPAFEN0: isize   = 34;
pub const GPIO_GPAFEN1: isize   = 35;
pub const GPIO_GPPUD: isize     = 37;
pub const GPIO_GPPUDCLK0: isize = 38;
pub const GPIO_GPPUDCLK1: isize = 39;

#[no_mangle]
pub extern fn main() {
    // GPIO_BASEを符号無し32bit整数を指すポインタにキャストする
    let gpio = GPIO_BASE as *const u32;
    // offsetを使うことでCの配列のようにポインタの何番地か先のメモリを指せる
    let init   = unsafe {gpio.offset(LED_GPFSEL) as *mut u32};
    let led_on = unsafe { gpio.offset(LED_GPSET) as *mut u32 };
    let led_off = unsafe { gpio.offset(LED_GPCLR) as *mut u32 };

    // LEDのGPIOを書き込みに設定
    unsafe{
        volatile_store(init, *(init) | 1 &amp;lt;&amp;lt; LED_GPFBIT);
    }

    loop {
        // LEDをOFFにする
        unsafe {
            volatile_store(led_off, 1 &amp;lt;&amp;lt; LED_GPIO_BIT);
        }
        // 適当な長さbusy loopで時間を空ける
        for _ in 1..500000 {
            unsafe { asm!(&amp;quot;&amp;quot;); }
        }

        // LEDをONにする
        unsafe {
            volatile_store(led_on, 1 &amp;lt;&amp;lt; LED_GPIO_BIT);
        }
        // また適当な長さ空ける
        for _ in 1..500000 {
            unsafe { asm!(&amp;quot;&amp;quot;); }
        }
    }
}


#[no_mangle]
pub extern fn _sbrk() {}
#[no_mangle]
pub extern fn _exit() {}
#[no_mangle]
pub extern fn _kill() {}
#[no_mangle]
pub extern fn _getpid() {}


#[lang = &amp;quot;eh_personality&amp;quot;]
extern fn eh_personality() {}

#[lang = &amp;quot;panic_fmt&amp;quot;]
extern fn panic_fmt() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをkernel.rsとして保存し、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustc  -O --target arm-unknown-linux-gnueabihf --emit=obj kernel.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でコンパイルします。どうやら使っていないのにrustが余計なシンボルを付けるようで、-Oをつけてそいつらをoptimize outさせないとコンパイルが通りませんでした。
この辺、コンパイラのバージョンに依存しそうで怖いですね。&lt;/p&gt;

&lt;p&gt;さて、あとは先程と同じく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles kernel.o -o kernel.elf
$ arm-none-eabi-objcopy kernel.elf -O binary kernel.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でイメージを作ってあげます。&lt;/p&gt;

&lt;p&gt;そしたらこのkernel.imgをSDカードに放り込みます。&lt;/p&gt;

&lt;p&gt;SDカードの中身はこうなっている筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls  /media/kim/6F6F-DCD9
bootcode.bin  kernel.img  start.elf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このSDカードをRSPiに挿して、電源を繋いであげるとLEDがすごい勢いでチカチカする筈です。そうなったら成功です。おめでとうございます。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/RaspPi&#34;&gt;ここ&lt;/a&gt;に置いておきます。とはいってもそのままではなくてCargo化したりMakefileを書いたり色々しています。&lt;/p&gt;

&lt;p&gt;今回の作業をするにあたって参考にした資料のURLを挙げておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valvers.com/open-software/raspberry-pi/step01-bare-metal-programming-in-cpt1/&#34;&gt;Step01 – Bare Metal Programming in C Pt1 – Valvers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valvers.com/open-software/raspberry-pi/step02-bare-metal-programming-in-c-pt2/&#34;&gt;Step02 – Bare Metal Programming in C Pt2 – Valvers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.thiago.me/raspberry-pi-bare-metal-programming-with-rust/&#34;&gt;Raspberry Pi Bare Metal Programming with Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.bobuhiro11.net/2014/01-13-baremetal.html&#34;&gt;piでベアメタルプログラミング - bobuhiro11&amp;rsquo;s diary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>LXDがリリースされたらしい</title>
      <link>/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii</link>
      <pubDate>Thu, 14 Apr 2016 22:51:20 +0900</pubDate>
      
      <guid>/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii</guid>
      <description>&lt;p&gt;κeenです。頭痛い。LXDがリリースされたようなので1つ記事をば。
LXDはLinuxで動く軽量仮想化コンテナ、LXCのラッパでREST APIとCLIが提供されています。&lt;/p&gt;

&lt;p&gt;LXC、LXD共にUbuntuの開発元、Canonicalが開発しています。
LXCについては初期のDockerがバックエンドに使っていたので知名度もそこそこあるかと思いますが、
そのラッパであるLXDはこの度ようやく正式リリースされました。&lt;/p&gt;

&lt;p&gt;既にDockerがあるのになぜわざわざ新たにLXDを使うんだって気もしますが、対象とするレイヤーが違います。
Dockerはアプリケーションコンテナ、つまりアプリケーションを動かすためのプロセスより強い分離環境を提供するために使われますが
LXDはシステムコンテナ、つまり仮想マシンより軽い仮想化環境を提供します。
なのでファイルシステムはCopy on Writeしませんし一度終了したコンテナは破棄されず、再起動出来ます。
詳しくはここら辺に書いてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.stgraber.org/2016/03/11/lxd-2-0-blog-post-series-012/&#34;&gt;LXD 2.0: Blog post series [0/12] | Stéphane Graber&amp;rsquo;s website&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1つDockerとLXDの違いの分かりやすい例を出すと、それぞれのOpenStackでの立ち位置を見ると面白そうです。
Dockerは&lt;a href=&#34;https://wiki.openstack.org/wiki/Magnum&#34;&gt;OpenStack Magnum&lt;/a&gt;でOpenStack上で扱えますが、OpenStackのコンピュートノード &lt;strong&gt;上&lt;/strong&gt; で動作します。
一方LXDは&lt;a href=&#34;https://insights.ubuntu.com/2015/05/06/introduction-to-nova-compute-lxd/&#34;&gt;nova-compute-lxd&lt;/a&gt;でOpenStack上で扱えますが、 OpenStackのコンピュートノード &lt;strong&gt;として&lt;/strong&gt; 動作します。
なんだかんだ重いVMがコンテナのお陰で軽くなる訳です。そして勿論のこと、Docker in LXDなんかも出来るのでちゃんと共存出来ます。&lt;/p&gt;

&lt;p&gt;今のところUbuntu 14.04あるいは未来の16.04でリリースされているようです。Ubuntu 15.10をお使いの方は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add-apt-repository ppa:ubuntu-lxc/lxd-stable
apt-get update
apt-get dist-upgrade
apt-get install lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストール出来るようです(&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;マニュアル&lt;/a&gt;より)。
LXDはLXCのラッパでありながらもliblxcにしか依存しないのでlxc自体はインストールする必要はありません。&lt;/p&gt;

&lt;p&gt;さてこれでLXDがインストールされた訳ですが、LXDはコンテナなどのリソースを管理するデーモンとそのCLIから成ります。
CLIのコマンド名はなんと&lt;code&gt;lxc&lt;/code&gt;です。LXCのコマンド群が&lt;code&gt;lxc-*&lt;/code&gt;なので非常に勘違いしやすいですね。&lt;/p&gt;

&lt;p&gt;詳しいコマンド群は&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;マニュアル&lt;/a&gt;を読めばいいのですがそれだけだとお粗末なので多少紹介します。&lt;/p&gt;

&lt;p&gt;インストール直後は新規に作ったグループを今のログインセッションに反映させる必要があるので&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;newgrp lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする必要があります。その次は初期化が必要になります。&lt;code&gt;lxd init&lt;/code&gt;です。いくつか質問されますがデフォルトの回答を選んでいけば問題なさそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
Name of the storage backend to use (dir or zfs): zfs
error: The requested backend &#39;zfs&#39; isn&#39;t available on your system (missing tools).
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? yes
Address to bind LXD to (not including port): 0.0.0.0
Port to bind LXD to (8443 recommended): 
Invalid input, try again.

Port to bind LXD to (8443 recommended): 8443
Trust password for new clients: 
Again: 
Do you want to configure the LXD bridge (yes/no)? yes
Warning: Stopping lxd.service, but it can still be activated by:
  lxd.socket
LXD has been successfully configured.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntuでzfsが使えるのは16.04からなので15.10では使えませんでした。また、ブリッジのコンフィギュアにはウィザードが出てきます。&lt;/p&gt;

&lt;p&gt;これで初期化が終わり、コンテナを立ち上げる準備が出来ました。&lt;/p&gt;

&lt;p&gt;コンテナはイメージを元に立ち上げるのですが、今回はイメージはネット上のものから立ち上げます。
インストール時点でいくつかサーバが登録されているので名前で指定してあげるだけでよいようです。
他にイメージを使う方法はリモートのLXDをサーバとして使う、手動でファイルからインポートするなどがあるようです。&lt;/p&gt;

&lt;p&gt;ということでコンテナの立ち上げはこうです。折角なので未来のUbuntu 16.04を使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc launch ubuntu:16.04 future-ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドでビルトインの&amp;rdquo;Ubuntu&amp;rdquo;サーバにある16.04バージョンのイメージをfuture-ubuntuという名前のコンテナで立ち上げます。&lt;/p&gt;

&lt;p&gt;これでコンテナが立ち上がりました。確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc list
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
|     NAME      |  STATE  |              IPV4              |                     IPV6                     |    TYPE    | SNAPSHOTS |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
| future-ubuntu | RUNNING | 10.197.202.251 (eth0)          | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0         |
|               |         | 10.0.3.1 (lxcbr0)              |                                              |            |           |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにローカルにあるイメージも確認しましょう。インポートまで終わっているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc image list
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |                DESCRIPTION                |  ARCH  |   SIZE   |         UPLOAD DATE          |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
|       | 6cb0ba80a5fe | no     | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立ち上げたコンテナにログインしてみましょう。これはDockerをお使いの方は馴染があるんじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc exec future-ubuntu -- /bin/bash
root@future-ubuntu:~# lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu Xenial Xerus (development branch)
Release:	16.04
Codename:	xenial
root@future-ubuntu:~# exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと16.04になっているようです。&lt;/p&gt;

&lt;p&gt;コンテナの停止は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc stop future-ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。ちゃんと止まったか確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc list
+---------------+---------+------+------+------------+-----------+
|     NAME      |  STATE  | IPV4 | IPV6 |    TYPE    | SNAPSHOTS |
+---------------+---------+------+------+------------+-----------+
| future-ubuntu | STOPPED |      |      | PERSISTENT | 0         |
+---------------+---------+------+------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんとSTATEがSTOPPEDになってますね&lt;/p&gt;

&lt;p&gt;もう一度起動してみます&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc start future-ubuntu
sudo lxc list
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
|     NAME      |  STATE  |              IPV4              |                     IPV6                     |    TYPE    | SNAPSHOTS |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
| future-ubuntu | RUNNING | 10.197.202.251 (eth0)          | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0         |
|               |         | 10.0.3.1 (lxcbr0)              |                                              |            |           |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次はコンテナを削除します&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc stop future-ubuntu
sudo lxc delete future-ubuntu
sudo lxc list
+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
sudo lxc image list
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |                DESCRIPTION                |  ARCH  |   SIZE   |         UPLOAD DATE          |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
|       | 6cb0ba80a5fe | no     | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナが消えただけでイメージは残るんですね。&lt;/p&gt;

&lt;p&gt;さて、いかがでしょうか。軽量なVMと考えれば非常に手軽で中々面白いんじゃないでしょうか。
因みにコンテナとホスト間でのファイルのやりとりも簡単(&lt;code&gt;lxc file pull/push&lt;/code&gt;)なようなのでコンテナ内でコンパイラを動かしてホストにもってくるとかをすれば開発環境の隔離環境としても使えそうです。&lt;/p&gt;

&lt;p&gt;時間があればもう少し詳細に検証してみます。SNAPSHOTとかも試してみたかった。それでは今日はこの辺で。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mirah関連ツールまとめ</title>
      <link>/blog/2016/04/04/mirahkanrentsu_rumatome</link>
      <pubDate>Mon, 04 Apr 2016 01:16:31 +0900</pubDate>
      
      <guid>/blog/2016/04/04/mirahkanrentsu_rumatome</guid>
      <description>

&lt;p&gt;κeenです。寝付けないのでMirah関連ツールについてまとめようかと。
とはいってもそんなにないのですが。Mirahについて知らない人は適当にググって下さい。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラ&#34;&gt;コンパイラ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mirah/mirah/releases&#34;&gt;Releases · mirah/mirah&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本家のものを使うべし&lt;/p&gt;

&lt;h1 id=&#34;開発支援&#34;&gt;開発支援&lt;/h1&gt;

&lt;h2 id=&#34;netbeansプラグイン&#34;&gt;NetBeansプラグイン&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/shannah/mirah-nbm&#34;&gt;shannah/mirah-nbm: Netbeans Module for Mirah&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このプラグインのためにパーサのAPIに変更を加える議論がされたりしていて恐らく現状一番まともに動くやつと思う。&lt;/p&gt;

&lt;h2 id=&#34;emacs&#34;&gt;Emacs&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/mirah-mode.el&#34;&gt;KeenS/mirah-mode.el:&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ruby-modeにやっつけで雑に機能を追加したやつ。コメントのハイライトにコーナーケース(&lt;code&gt;/*/*/**/*/*/&lt;/code&gt; みたいなの)があったり雑。
まあ、とりあえずそれっぽくは動く&lt;/p&gt;

&lt;h1 id=&#34;ビルドツール統合&#34;&gt;ビルドツール統合&lt;/h1&gt;

&lt;h2 id=&#34;gradle&#34;&gt;Gradle&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ysb33r/gradle-mirah-plugin&#34;&gt;ysb33r/gradle-mirah-plugin: Gradleplugin to compile Mirah source code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近作られたやつ。&lt;a href=&#34;https://github.com/KeenS/mirah_sample_gradle&#34;&gt;軽く使てみた&lt;/a&gt;ら簡単に動いたし良さげ。&lt;/p&gt;

&lt;h2 id=&#34;maven&#34;&gt;Maven&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mirah/maven-mirah-plugin&#34;&gt;mirah/maven-mirah-plugin: Plugin to compile Mirah source with Maven&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;公式サポートだし良さげ。&lt;/p&gt;

&lt;h1 id=&#34;その他&#34;&gt;その他&lt;/h1&gt;

&lt;h2 id=&#34;コードトランスレート&#34;&gt;コードトランスレート&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/captn3m0/java2mirah&#34;&gt;captn3m0/java2mirah: A java to mirah transpiler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;javaからMirahに変換してくれるツール。試したことはないけどそんなに期待はしてない。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;私が把握してるのはこれくらい。ビルドツール統合と開発支援があればどうにかなるっしょ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>リージョンとRustの返り値</title>
      <link>/blog/2016/03/02/ri_jontorustnokaerichi</link>
      <pubDate>Wed, 02 Mar 2016 00:05:03 +0900</pubDate>
      
      <guid>/blog/2016/03/02/ri_jontorustnokaerichi</guid>
      <description>&lt;p&gt;Rustにおいては返り値ポインタで返すよりもそのまま返して、受け取る側でポインタで受け取るかそのまま受け取るかを指定するのが良い選択肢だ、といっています。
しかし初めて見る時にはどうしてそんなことが出来るのかわからず、びっくりしますよね。
それをRustがリージョンを使ってメモリ管理をしていると分かればどうなっているのか分かったのですこしばかり。&lt;/p&gt;

&lt;p&gt;Rustにおいては以下のように関数が値を返す時にポインタを返すコードは好ましくなく、（というかコンパイル出来ない）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; &amp;amp;BigStruct {
    &amp;amp;BigStruct{ .... }
}

let bs = new_value();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数が返す値はスタックに載らないような大きな値でもそのまま返して、受け取り側でヒープに保存してあげるのが良いスタイルとされています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; BigStruct {
    BigStruct{ .... }
}

let bs = Box::new(new_value());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までの言語の感覚だとRustにおいて良いとされるスタイルは大きな値を一旦スタックに載せた後で&lt;code&gt;Box&lt;/code&gt;によって作られたヒープ領域に確保されているように見えます。&lt;/p&gt;

&lt;p&gt;これはリージョンについて理解すると動作が理解できます。&lt;/p&gt;

&lt;p&gt;リージョンについては以前のブログを参照して下さい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/&#34;&gt;リージョンについて | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、リージョンによるメモリ管理は「メモリを確保すべき場所」が先にあって、値はそこに置かれます。
特に、関数呼び出しにおいて、関数の「返り値を確保すべき場所」は関数の外から与えます。&lt;/p&gt;

&lt;p&gt;ここまで説明したらお分りかと思いますが、&lt;code&gt;Box::new(new_value());&lt;/code&gt;というコードは&lt;code&gt;new_value()&lt;/code&gt;の返り値を保存する場所としてヒープ領域を渡していて、
関数内部でそのヒープ領域にBigStructの値を書き込んでいるのです。&lt;/p&gt;

&lt;p&gt;もやもやしていたものがスッキリしたし返り値のサイズが決まってないと関数から返せないのも分かるようになった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustのゼロコスト抽象化</title>
      <link>/blog/2016/03/01/rustnozerokosutochuushouka</link>
      <pubDate>Tue, 01 Mar 2016 23:32:12 +0900</pubDate>
      
      <guid>/blog/2016/03/01/rustnozerokosutochuushouka</guid>
      <description>&lt;p&gt;κeenです。今日Twitter上でのやりとりから少し面白いことが分かったのでそれについて。&lt;/p&gt;

&lt;p&gt;最近1.0が出たKotlinについて、水島さんがツイートしてました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;nullableに対してはmapとかの高階関数を一切使えないのが痛い。 ?. でカバーできるケースは一部だけだ。zero-overhead null-safetyと唄っとるが、代わりにnullチェックお化けになるわけで、どこがzero-overheadだ &lt;a href=&#34;https://twitter.com/hashtag/kotlin_dis?src=hash&#34;&gt;#kotlin_dis&lt;/a&gt;&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704453235277324288&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;それについて私が無関係なツイートを。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;全く無関係だけどRustはOptionみたいな0-1の型をnull or valueに最適化するそうな。これこそがゼロコスト抽象かな &lt;a href=&#34;https://t.co/5Y7cBEyrMe&#34;&gt;https://t.co/5Y7cBEyrMe&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704453898996547584&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;これはRustのnomiconに書かれています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/repr-rust.html&#34;&gt;repr(Rust)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;そうすると水島さんからお返事が。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; Rust詳しくないですけど、Optionにmapとかした場合インライン展開されるんですかね？だとしたらとても理想的。&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704455185125408768&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;確かにそうなると面白そう。ということで少し調べてみました。&lt;/p&gt;

&lt;p&gt;まず、上記の話をまとめると、Rustの&lt;code&gt;Option&lt;/code&gt;に対する&lt;code&gt;map&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    match self {
        Some(x) =&amp;gt; Some(f(x)),
        None =&amp;gt; None,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;code&gt;x&lt;/code&gt;がポインタ型だった時に以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    if (self != nullPointer ) {
        f(x)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、&lt;a href=&#34;https://github.com/rust-lang/rust/blob/master/src/libcore/option.rs#L386&#34;&gt;&lt;code&gt;map&lt;/code&gt;はインライン宣言されている&lt;/a&gt;ので以下のコード&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  (|x| x + 1)(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、ここで無名関数がどうコンパイルされるかという問題が出てきますが、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャのドキュメント&lt;/a&gt;によるとこういう雰囲気のコードになるらしいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
struct AnonymousType;

impl FnOnce&amp;lt;(&amp;amp;i32)&amp;gt; for AnonymousType {
    type Output = i32;
    fn call_once(self, args: (&amp;amp;i32)) -&amp;gt; Self::Output {
        args + 1
    }
}

if (opt != nullPointer) {
    let fn_once: FnOnce = AnonymousType;
    fn_once.call_once(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思ったよりも複雑…。さて、問題は&lt;code&gt;let fn_once: FnOnce = AnonymousType;&lt;/code&gt;としているので一旦元の無名関数の情報が抜けてしまいそうな気がします。
となるとコンパイル時に具体的なメソッドを決定出来ないので&lt;code&gt;fn_once.call_once(opt);&lt;/code&gt;は以下のような雰囲気のコードになってしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回呼び出すべき関数の取得が入るのは面倒ですね。&lt;/p&gt;

&lt;p&gt;しかしなががらクロージャのドキュメントをよく読むと無名関数は静的ディスパッチされると書いてあります。つまり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と2段ではなく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;the_call_once_fn_of_AnonymousType(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイルされ、&lt;/p&gt;

&lt;p&gt;よって&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn the_call_once_fn_of_AnonymousType(x: &amp;amp;i32) -&amp;gt; i32 {
    x + 1
}


let opt = &amp;amp;v;
if (opt != nullPointer) {
  the_call_once_fn_of_AnonymousType(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と同値ということです。&lt;/p&gt;

&lt;p&gt;ここからは私の推測ですが、&lt;code&gt;the_call_once_fn_of_AnonymousType&lt;/code&gt;は本体が小さい上に1回しか呼ばれないのでインライン化されるのではないかと思います。
よってこの推測が正しければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  opt + 1
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる筈です。&lt;/p&gt;

&lt;p&gt;ゼロコスト抽象化すごい!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>テストについて考えてみた</title>
      <link>/blog/2016/03/01/tesutonitsuitekangaetemita</link>
      <pubDate>Tue, 01 Mar 2016 22:49:23 +0900</pubDate>
      
      <guid>/blog/2016/03/01/tesutonitsuitekangaetemita</guid>
      <description>

&lt;p&gt;κeenです。
普段はテストをあまり書かない人なのですが業務では流石に書く必要があって、馴れないことをしていると色々と考えることがあったのでまとめます。
まだ私はテストのセオリーとかには詳しくないので勝手気儘に考えたことです。&lt;/p&gt;

&lt;p&gt;2016-03-05 追記:
酷い誤りがあったので修正しました。s/ホーア理論/ホーア論理/。&lt;/p&gt;

&lt;p&gt;今まではテストは「とりあえずエッジケースとかをカバー出来てればいいんでしょ」くらいにしか考えてませんでした。
しかしオブジェクト指向をしていて他のオブジェクトの振舞いに依存するだとか関数の引数が複雑だとかの時には適切なケースを書くのが困難でした。&lt;/p&gt;

&lt;p&gt;チームの人とかとどう書くのが適切かと話しているとなんとなくまとまってきました。&lt;/p&gt;

&lt;h1 id=&#34;ホーア論理&#34;&gt;ホーア論理&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://proofcafe.org/sf/Hoare_J.html&#34;&gt;ホーア論理&lt;/a&gt;的にはソフトウェアの振舞/性質を表すのには3つの要素が必要です。事前条件、操作、事後条件です。&lt;/p&gt;

&lt;p&gt;「事前条件Pが満たされるときに操作Oを行い、それが停止するならば事後条件Qが満たされる」&lt;/p&gt;

&lt;p&gt;エンジニアリング的には以下のように読み替えられます。&lt;/p&gt;

&lt;p&gt;事前条件とは、メソッドを実行するまでのお善立て。引数を用意する、依存するオブジェクトのモックを用意する、などなど。
操作が実際のメソッドの実行。
事後条件こそがassertなどを使ったテストケース群です。&lt;/p&gt;

&lt;h1 id=&#34;テストフレームワークとホーア論理&#34;&gt;テストフレームワークとホーア論理&lt;/h1&gt;

&lt;p&gt;テストを書く時にもこの考え方は役に立つな、と思いました。事前条件 x 操作 x 事後条件を網羅していけばいい訳です。&lt;/p&gt;

&lt;p&gt;ところで、テストフレームワークにはテストをグルーピングしたりといくつかのスコープをネスト出来る機能を持っているものもあります。
ホーア論理では要素が3つある訳ですから3段にネストするのが適切な気がするのは納得いくと思います。しかしどの順番でネストするかは議論の余地がありそうです。&lt;/p&gt;

&lt;p&gt;勿論、ホーア論理に従うなら操作の時系列的に事前条件&amp;gt;操作&amp;gt;事後条件のネストの仕方が一番自然かと思います。
しかしテストしたい主役は振舞、メソッドなのでそれを階層の最上位に持ってくる方が可読性、ひいてはテストの意味が高まりそうです。&lt;/p&gt;

&lt;p&gt;あるいは、4段にネストして最上位にだたのグルーピング目的にメソッドを、そしてその下に事前条件&amp;gt;操作&amp;gt;事後条件を持っていく手法もありそうです。
しかしこれだとネストが深すぎますね。また、後述するように操作の子階層を作ると例外がどこ由来なのか分かりづらいという問題もあります。&lt;/p&gt;

&lt;p&gt;これの改良版は最上位にだたのグルーピング目的にメソッドを、そして事前条件&amp;gt;(操作+事後条件)という形のネストの仕方をする方法です。
これは例外の出所を明確に出来る他、多くのテストフレームワークで操作に対する表明と事後条件に対する表明を区別しない問題もクリア出来るという利点があります。
1つある欠点は、操作と事後条件のスコープが分かれているので操作の返り値に対して事後条件で表明したい時にどうにかしてスコープの外に出してやる必要がある点です。
副作用を容易に許す言語なら外のスコープの変数に代入すればいいだけですが、純粋な言語だと簡単ではありません。
そういう意味でも操作に対する表明と事後条件に対する表明は分けたいなと思う次第。&lt;/p&gt;

&lt;h1 id=&#34;操作に対する表明&#34;&gt;操作に対する表明&lt;/h1&gt;

&lt;p&gt;本来のホーア論理的には事後条件で表明すれば十分ですが、実際には不十分な点があります。もう一度ホーア論理の表明について思い出しましょう。&lt;/p&gt;

&lt;p&gt;「事前条件pが満たされるときに操作oを行い、 &lt;strong&gt;それが停止するならば&lt;/strong&gt; 事後条件qが満たされる」&lt;/p&gt;

&lt;p&gt;現実的に、関数が正しく停止することも保証したいです。「無限ループを書く方が悪い」という訳ではありません。関数が停止しないのは何も無限ループだけでなく、例外などで脱出した場合も含みます。&lt;/p&gt;

&lt;p&gt;なので例外を出す/出さないの表明も欲しくなる訳です。
もう少し踏み込んで考えると、多くのテストフレームワークでassertと例外の送出の有無を同列扱いますが、前者は事後条件に対する表明、後者は操作に対する表明なので本来は分かれるべきです。&lt;/p&gt;

&lt;p&gt;また、操作に対する表明はスコープを作るとしても操作の返り値を返す手段を用意してくれると事後条件の表明がやりやすくなるな、と思いました。まる。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;テストをする時には3つの要素に分けて考えると考えやすくなります。その3つとは事前条件、操作、事後条件で、それぞれの組み合わせがあるのでテストケースのネストは合理的です。
しかしながら人間の認識のためにネストの順番は入れ替えた方がよいのですが、そうするとコード上いくつか問題が発生します。&lt;/p&gt;

&lt;p&gt;グルーピング目的にメソッドを、そして事前条件&amp;gt;(操作+事後条件)というネストの仕方が最終案に思えますが、それを的確に表現出来、かつコード上の問題をクリア出来るテストフレームワークが中々ないのが現状です。&lt;/p&gt;

&lt;h1 id=&#34;付録a&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;考えがまとまるまでの過程&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;テスト書いててなぜテストライブラリがテストスートを階層構造にしてるのか考えたけど1つの事前条件に対して複数の操作が考えれてそれぞれの操作に対して保証したい不変条件と事後条件があるから少なくとも3段にネストしないと上手くグルーピング出来ないのかな。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704586009464311808&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;しかしネストする順番はどうだろう。メソッドに対するテストでグルーピングしたいからメソッド&amp;gt;事前条件&amp;gt;事後/不変条件になるのかな。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704586479427670016&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;事前条件を最上位に持ってきた方が理解しやすいし事前条件の使い回しもしやすいけど並行にテストを走らせようと思ったらやっぱり操作毎に事前条件用意してあげた方がいいし事前条件と事後条件が近い方が性質を理解しやすい?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704587239402008576&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;あれ?もしかして操作ってメソッドじゃなくてメソッド+引数になる?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704588326175551488&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うーん。操作を行うパートと条件の準備/確認のパートを分けたいんだけど難しい。例えば操作によって例外が出ることを確認したいとかが非常にやりづらい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704601381605232640&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;いや?やっぱり操作と事後/不変条件のパートは分けれるな?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704602157148872704&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そしてやはり操作をネストのトップレベルにもってくると操作の引数とかが事前条件/前提条件に依存するのでやりづらい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704602629737811968&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>