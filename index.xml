<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Fri, 04 Nov 2016 13:19:01 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Scala 2.12.0変更点</title>
      <link>/slide/Scala_2_12_0henkouten/</link>
      <pubDate>Fri, 04 Nov 2016 13:19:01 +0900</pubDate>
      
      <guid>/slide/Scala_2_12_0henkouten/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Scala 2.12.0変更点
----------------------
サイバーエージェント ScalaMeetUp

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * AI Studio Dev Group
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# サマリー
----------
全部[公式ページ](http://www.scala-lang.org/news/2.12.0)に詳細あるよ

* Java8向けの互換性向上したよ
  + トレイトがinterfaceに
  + 無名関数がlambdaに
  + SAMとScalaの関数が統合
* コンパイラが少し賢くなったよ
  + いくつかでinvokedynamicを使うように
  + 中間状態をやめた
  + 最適化をするように
* ライブラリ改善した
  + EitherがRight Biasedに
  + Futureが強化
* 非互換いくつか


===

# トレイトがinterfaceに
-----------------------

``` scala
trait Foo {
  def foo(): String = &#34;foo&#34;
  def bar(): String
}
```

===

# トレイトがinterfaceに
-----------------------


```
$ scalac-2.11 Trait.scala
$ ls
Foo$class.class  Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public interface Foo {
  public abstract java.lang.String foo();
  public abstract java.lang.String bar();
}
$ javap &#39;Foo$class&#39;
Compiled from &#34;Trait.scala&#34;
public abstract class Foo$class {
  public static java.lang.String foo(Foo);
  public static void $init$(Foo);
}

```

===

# トレイトがinterfaceに
-----------------------

```
$ scalac-2.12 Trait.scala
$ ls
Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public interface Foo {
  public static java.lang.String foo$(Foo);
  public java.lang.String foo();
  public abstract java.lang.String bar();
  public static void $init$(Foo);

```

===

# 無名関数がlambdaに
-----------------------

```
class Foo {
  val f = () =&gt; &#34;string&#34;
}
```

===

# 無名関数がlambdaに
-----------------------


```
$ scalac-2.11 Trait.scala
$ ls
Foo$$anonfun$1.class  Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  public scala.Function0&lt;java.lang.String&gt; f();
  public Foo();
}
$ javap  &#39;Foo$$anonfun$1
Compiled from &#34;Trait.scala&#34;
public final class Foo$$anonfun$1 extends scala.runtime.AbstractFunction0&lt;java.lang.String&gt; implements scala.Serializable {
  public static final long serialVersionUID;
  public final java.lang.String apply();
  public final java.lang.Object apply();
  public Foo$$anonfun$1(Foo);
}

```

===

# 無名関数がlambdaに
-----------------------

```
$ scalac-2.12 Trait.scala
$ ls
Foo.class  Trait.scala
$ javap -p Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  private final scala.Function0&lt;java.lang.String&gt; f;
  public scala.Function0&lt;java.lang.String&gt; f();
  public static final java.lang.String $anonfun$f$1();
  public Foo();
  private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda);
$ javap -c -p Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  private final scala.Function0&lt;java.lang.String&gt; f;

  public scala.Function0&lt;java.lang.String&gt; f();
    Code:
       0: aload_0
       1: getfield      #19                 // Field f:Lscala/Function0;
       4: areturn

  public static final java.lang.String $anonfun$f$1();
    Code:
       0: ldc           #25                 // String string
       2: areturn

  public Foo();
    Code:
       0: aload_0
       1: invokespecial #29                 // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
       4: aload_0
       5: invokedynamic #49,  0             // InvokeDynamic #0:apply:()Lscala/Function0;
      10: putfield      #19                 // Field f:Lscala/Function0;
      13: return

  private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda);
    Code:
       0: aload_0
       1: invokedynamic #61,  0             // InvokeDynamic #1:lambdaDeserialize:(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;
       6: areturn
}
```

===

# SAMとScalaの関数が統合
-----------------------

関数をSingle Abstract Methodに出来る

```
scala&gt; val runRunnable: Runnable = () =&gt; println(&#34;Run!&#34;)
runRunnable: Runnable = $$Lambda$1073/754978432@7cf283e1
scala&gt; runRunnable.run()
Run!
```

JavaでLambdaが期待される箇所にScalaの無名関数を書ける

===

# SAMとScalaの関数が統合
-----------------------

逆に、JavaのLambdaでScalaの関数を作れる

```
public class A {
  scala.Function1&lt;String, String&gt; f = s -&gt; s.trim();
}
```

===

# 最適化
--------
とりあえずDead Code Elimination

```
class Foo {
  def add1(i: Int) = {
    val unused = 1 + i
    1 + i
  }

}

```

===

# 最適化
--------

```
$ scalac Trait.java
$ javap -c Foo
...
  public int add1(int);
    Code:
       0: iconst_1
       1: iload_1
       2: iadd
       3: istore_2
       4: iconst_1
       5: iload_1
       6: iadd
       7: ireturn
...
}

```

===

# 最適化
--------

```
$ scalac -opt:l:method Trait.java
$ javap -c Foo
...
  public int add1(int);
    Code:
       0: iconst_1
       1: iload_1
       2: iadd
       3: ireturn
...
```

===

# 非互換
--------

* Object initialization locks and lambdas
  + 無名関数が元のクラスのメソッドになったので変にデッドロックするかも
* Lambdas capturing outer instances
  + 無名関数が元のクラスのメソッドになったのでスコープが少し変わる
  + シリアライズに影響出るかも
* SAM conversion precedes implicits
  + SAM conversionとimplicit comversionだとSAMが優先される

===

# 非互換
--------

* SAM conversion in overloading resolution
  + なんか型が面倒になった
* Inferred types for fields
  + なんかよく分かんなかった
* Changed syntax trees (affects macro and compiler plugin authors)
  + 変わったらしい

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>VMwareのUbuntuを16.10にしたら起動しなくなった</title>
      <link>/blog/2016/10/31/vmwarenoubuntuwo16_10nishitarakidoushinakunatta</link>
      <pubDate>Mon, 31 Oct 2016 22:06:17 +0900</pubDate>
      
      <guid>/blog/2016/10/31/vmwarenoubuntuwo16_10nishitarakidoushinakunatta</guid>
      <description>

&lt;p&gt;κeenです。普段はネイティブのUbuntuを使ってますが会社では使えないのでVMwareにUbuntuを入れて使っています。
今日そのUbuntuを16.04から16.10にアップグレードしたら起動しなくなったので対策メモ。&lt;/p&gt;

&lt;p&gt;現象は、Ubuntuを起動しようとするとゲストOSによってCPUがオフにされた旨の通知が来てフリーズします。
このリリースノート（&lt;a href=&#34;http://pubs.vmware.com/Release_Notes/en/fusion/8/fusion-851-release-notes.html&#34;&gt;VMware Fusion 8.5.1 Release Notes&lt;/a&gt;）を見れば分かりますが、Linux Kernel 4.7以上を使うと発生するバグのようです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Known Issues&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Virtual machines running Linux kernel version 4.7 or above may crash or hang on hosts with Intel CPUs

Virtual Machines running Linux kernel version 4.7 or above may crash during installation or during power-on with a crash in the intel_powerclamp driver. This issue has been reported with Ubuntu 16.10, but it is a generic Linux kernel issue.

Workaround: VMware is working with the OS vendors to have them fix their respective kernels. Until a fix is available, you can blacklist the intel_powerclamp driver so that the buggy code doesn&#39;t get loaded.

To blacklist the driver:

Add the kernel command-line option modprobe.blacklist=intel_powerclamp to the guest OS&#39;s default grub configuration or add it directly at the grub menu during boot.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;どうやらIntel CPUのホストだと特定のカーネルモジュールが誤動作してCPUをoffってしまうっぽい？OSベンダと協力して直していくと言っているのでVMwareのアップデートでは直らなそう。OSのアップデートはそもそも起動しないので出来ない、というかなりキツい状況です。
幸いにもワークアラウンドがあるのでそれを使って起動、修正します。&lt;/p&gt;

&lt;h1 id=&#34;ubuntuの起動&#34;&gt;Ubuntuの起動&lt;/h1&gt;

&lt;p&gt;誤動作するカーネルモジュールをロードしないようにしたら起動するっぽいです。&lt;/p&gt;

&lt;p&gt;今OSがハングしている状態ならとりあえず殺して、 &lt;code&gt;ESC&lt;/code&gt; キー(多分。もしかしたら &lt;code&gt;Shift&lt;/code&gt; かも)を押しながらUbuntuを起動します。そうするとgrub menuの画面に遷移する筈です。&lt;/p&gt;

&lt;p&gt;grub menuで（恐らく1番上にある）使用中のカーネルに選択肢を合わせた状態で&lt;code&gt;e&lt;/code&gt;を押すと起動シーケンスをいじれるようになります。&lt;/p&gt;

&lt;p&gt;Emacsっぽく操作出来る画面が出てくるので&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	linux	/vmlinuz-4.4.0-45-generic root=/dev/mapper/ubuntu--vg-root ro  quiet splash $vt_handoff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにLinuxカーネルを起動してるっぽい行に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	linux	/vmlinuz-4.4.0-45-generic root=/dev/mapper/ubuntu--vg-root ro  quiet splash $vt_handoff modprobe.blacklist=intel_powerclamp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と &lt;code&gt;modprobe.blacklist=intel_powerclamp&lt;/code&gt; を追加してあげれば起動します。&lt;/p&gt;

&lt;h1 id=&#34;起動オプションの変更&#34;&gt;起動オプションの変更&lt;/h1&gt;

&lt;p&gt;とりあえず今のでワンショットで起動出来るようになったので起動オプションの設定を変更して次回以降も起動出来るようにしておきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/default/grub&lt;/code&gt; をいじれば良いようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GRUB_CMDLINE_LINUX=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の行をこれまた&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GRUB_CMDLINE_LINUX=&amp;quot;modprobe.blacklist=intel_powerclamp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と &lt;code&gt;modprobe.blacklist=intel_powerclamp&lt;/code&gt; を追加するように書き換えてあげて、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo update-grub2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でgrubに変更を反映してあげればOKです。&lt;/p&gt;

&lt;h1 id=&#34;その他&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;Ubuntu 16.10を1日使ってみましたが特に不自由なく使えています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustのクロージャ3種を作って理解する</title>
      <link>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</link>
      <pubDate>Mon, 10 Oct 2016 16:48:43 +0900</pubDate>
      
      <guid>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</guid>
      <description>

&lt;p&gt;κeenです。Rustのクロージャ、3種類もあって複雑ですよね。
こういう複雑なものはRustの気持になって考えれば理解出来たりします。ということで手でクロージャを作って理解してみましょう。&lt;/p&gt;

&lt;p&gt;尚、これはRustの1.12.0-stableと1.14.0-nightly (6e8f92f11 2016-10-07)で実験しています。&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;関数 - 関数&lt;/li&gt;
&lt;li&gt;無名関数 - 名前のついていない関数&lt;/li&gt;
&lt;li&gt;自由変数 - そのスコープの中で束縛されていない変数&lt;/li&gt;
&lt;li&gt;クロージャ - 関数に、自由変数の値(環境)もくっつけてそれだけで閉じるようにしたもの&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;クロージャについては関数が閉じ込める環境だけを指してクロージャとする人もいますが、ここでは関数本体と環境を合わせてクロージャとします。&lt;/p&gt;

&lt;p&gt;よく、無名関数とクロージャ(関数閉包)を一緒くたにすることがありますが明確に区別しましょう。まあ、大抵の無名関数はクロージャになりますが、動的スコープの言語みたいにそうならないケースもあります。&lt;/p&gt;

&lt;p&gt;余談ですが「ラムダ式」は言語がよく無名関数に付ける名前です。「関数」も言語によって「手続き」だったり「メソッド」だったりしますね。&lt;/p&gt;

&lt;h1 id=&#34;fnonce-fnmut-fn&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、「作って理解する」なので例を出します。なんかよく分からないけど0から9の値に1を足して印字するプログラムです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = |arg|{ i + arg };
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無名関数を作って &lt;code&gt;cls&lt;/code&gt; という変数に束縛しています。 &lt;code&gt;cls&lt;/code&gt; は自由変数 &lt;code&gt;i&lt;/code&gt; を含みますので、 &lt;code&gt;cls&lt;/code&gt; のクロージャを取ると 「&lt;code&gt;cls&lt;/code&gt; の定義 + &lt;code&gt;i&lt;/code&gt; の定義」になります。&lt;/p&gt;

&lt;p&gt;では &lt;code&gt;i&lt;/code&gt; という変数を保持したオブジェクトを作りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Closure {
    i: isize,
}


fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // もちろん、Closureは関数でないので呼び出せない
        // println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このままだと &lt;code&gt;cls&lt;/code&gt; は呼び出せません。しかし &lt;code&gt;+&lt;/code&gt; なんかのオーバーロードを許しているRustはなんと関数呼び出し構文 &lt;code&gt;name(arg, ...)&lt;/code&gt; もオーバーロード出来ます。実装すべきトレイトは &lt;code&gt;std::ops::{FnOnce, FnMut, Fn}&lt;/code&gt; です。これがクロージャ3種です。&lt;/p&gt;

&lt;p&gt;これらは継承関係にあって、上から順に &lt;code&gt;FnOnce&lt;/code&gt;  &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait FnOnce&amp;lt;Args&amp;gt; {
    type Output;
    extern &amp;quot;rust-call&amp;quot; fn call_once(self, args: Args) -&amp;gt; Self::Output;
}

pub trait FnMut&amp;lt;Args&amp;gt;: FnOnce&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, args: Args) -&amp;gt; Self::Output;
}

pub trait Fn&amp;lt;Args&amp;gt;: FnMut&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, args: Args) -&amp;gt; Self::Output;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらの違いは &lt;code&gt;self&lt;/code&gt; をムーブして受け取るか &lt;code&gt;&amp;amp;mut&lt;/code&gt; で受けるか &lt;code&gt;&amp;amp;&lt;/code&gt; で受けるかです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;とりあえず先程の &lt;code&gt;Closure&lt;/code&gt; にこれを実装してみましょう。ちょいとunstableな機能なようなので &lt;code&gt;feature&lt;/code&gt; を使って、nightlyでコンパイルするようにしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

// 再掲
struct Closure {
    i: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
    type Output = isize;

    extern &amp;quot;rust-call&amp;quot; fn call_once(self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.i + arg
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで呼び出しが出来る筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = Closure {i: i};
        // 呼出せるようになる
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;勿論、これは以下のように明示的にメソッドを呼んでも同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // メソッドで呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls.call_once((x, )));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fnmut-fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;FnOnce&lt;/code&gt; で出来るんならなんで &lt;code&gt;FnMut&lt;/code&gt; と &lt;code&gt;FnMut&lt;/code&gt; が存在するかというと、クロージャが閉じ込めた環境の所有権の問題ですね。&lt;/p&gt;

&lt;p&gt;例えば以下のコードを手で実装してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = |arg| { x + arg};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程と同じ &lt;code&gt;Closure&lt;/code&gt; ではコンパイル出来ません（統一感のために &lt;code&gt;Closure&lt;/code&gt; のメンバ名を変えました）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

struct Closure {
    x: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
  // ...略
}


fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = Closure {x: x};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error[E0382]: use of moved value: `cls`
  --&amp;gt; closure.rs:45:28
   |
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ value moved here in previous iteration of loop
   |
   = note: move occurs because `cls` has type `Closure`, which does not implement the `Copy` trait

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1回目のループでは問題ないのですが &lt;code&gt;call_once(self, (arg, ): (isize,))&lt;/code&gt; の呼び出しでムーブしてしまうので2回目以降は呼べません。ということで1つ下のトレイト、 &lt;code&gt;FnMut&lt;/code&gt; も実装してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl FnMut&amp;lt;(isize,)&amp;gt; for Closure {

    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はこれでも怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:45:28
   |
43 |         let cls = Closure {x: x};
   |             --- use `mut cls` here to make mutable
44 |         for i in 0..10 {
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ cannot borrow mutably

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;mut&lt;/code&gt; を要求しているから。正確にはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略


fn main() {
    let x = 1;
    // `mut` を付ける
    let mut cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。しかしまあ、何か書き換えてる訳でもないのに &lt;code&gt;mut&lt;/code&gt; が付いているのは嫌ですね。&lt;code&gt;mut&lt;/code&gt; を要求しないように定義してあげようと思ったら &lt;code&gt;Fn&lt;/code&gt; が必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl Fn&amp;lt;(isize,)&amp;gt; for Closure {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, (arg,): (isize, )) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。&lt;/p&gt;

&lt;h2 id=&#34;整理&#34;&gt;整理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;クロージャとは関数とその環境のセットだよ&lt;/li&gt;
&lt;li&gt;環境にも所有権はあるよ&lt;/li&gt;
&lt;li&gt;Rustは所有権でクロージャの呼び出しを使い分けるよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;構文&#34;&gt;構文&lt;/h1&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; に対応するRustの構文を探っていきます。&lt;/p&gt;

&lt;h2 id=&#34;fn&#34;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;先程 &lt;code&gt;Fn&lt;/code&gt; まで実装しないとコンパイルが通らなかった&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    let cls = |arg| { x + arg};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は &lt;code&gt;||{}&lt;/code&gt; でコンパイルが通っているので &lt;code&gt;||{}&lt;/code&gt; は &lt;code&gt;Fn&lt;/code&gt; を作るようです。&lt;/p&gt;

&lt;h2 id=&#34;fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;call_mut&lt;/code&gt; を要求しそうにちょっと変えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、予想通りエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:37:13
   |
35 |         let cls = |arg|{ x += arg };
   |             --- use `mut cls` here to make mutable
36 |         for i in 0..10 {
37 |             cls(i);
   |             ^^^ cannot borrow mutably

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let cls = |arg|{ x += arg };
   |                   -----  - previous borrow occurs due to use of `x` in closure
   |                   |
   |                   mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to 2 previous errors

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程の &lt;code&gt;FnMut&lt;/code&gt; の例のように &lt;code&gt;cls&lt;/code&gt; に &lt;code&gt;mut&lt;/code&gt; を付けてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let mut cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これでもエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let mut cls = |arg|{ x += arg };
   |                       -----  - previous borrow occurs due to use of `x` in closure
   |                       |
   |                       mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;cls&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; を捕捉し続けているから。これは &lt;code&gt;cls&lt;/code&gt; のライフタイムを &lt;code&gt;println!&lt;/code&gt; の前で終わらせてあげると解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    {
        // `{}` でスコープを作ることでライフタイムをコントロールする
        let mut cls = |arg|{ x += arg };
        for i in 0..10 {
            cls(i);
        }
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FnMut&lt;/code&gt; は変数を &lt;code&gt;mut&lt;/code&gt; にする無名関数と同じなようです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce-1&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; は？ &lt;code&gt;std::mem::drop&lt;/code&gt; を使って所有権を無理矢理奪うクロージャを作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::drop;

fn main() {
    let x = String::new();
    let cls = || {drop(x)};
    cls();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、実はこれでOKです。冷静に考えたら &lt;code&gt;FnOnce&lt;/code&gt; を継承している &lt;code&gt;Fn&lt;/code&gt; を &lt;code&gt;||{}&lt;/code&gt; で作れた時点で問題ありませんでしたね。&lt;/p&gt;

&lt;h1 id=&#34;落穂拾い&#34;&gt;落穂拾い&lt;/h1&gt;

&lt;h2 id=&#34;move-クロージャ&#34;&gt;&lt;code&gt;move&lt;/code&gt; クロージャ&lt;/h2&gt;

&lt;p&gt;じゃあ、Rustが良い感じに使い分けてくれるなら &lt;code&gt;move&lt;/code&gt; クロージャって何のためにあるの？と思いますが、これは環境を捕捉する際に &lt;code&gt;Copy&lt;/code&gt; なんかが起こらないようにするためのものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; しない例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; する例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt; は環境 &lt;strong&gt;へ&lt;/strong&gt; 所有権を移すかどうか、 &lt;code&gt;FnOnce&lt;/code&gt; などは環境 &lt;strong&gt;から&lt;/strong&gt; 所有権を移すかどうかです。&lt;/p&gt;

&lt;h2 id=&#34;関数ポインタ&#34;&gt;関数ポインタ&lt;/h2&gt;

&lt;p&gt;クロージャを持たない関数は、 &lt;code&gt;fn(i32) -&amp;gt; i32&lt;/code&gt; のような型を持ちます。これは空の環境を持つクロージャと同じですね。空の環境に所有権も何もないのでプリミティブの &lt;code&gt;fn&lt;/code&gt; は &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; のいずれとしても振舞います。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;p&gt;ここまで書いて普通にドキュメントに詳しく載っているのに気付きました（汗&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/functions.html&#34;&gt;関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SMLでモナド</title>
      <link>/blog/2016/10/10/smldemonado</link>
      <pubDate>Mon, 10 Oct 2016 11:05:38 +0900</pubDate>
      
      <guid>/blog/2016/10/10/smldemonado</guid>
      <description>

&lt;p&gt;κeenです。ML Workshop 2016でなんかSMLで型クラスする発表があったらしいので追ってみます。&lt;/p&gt;

&lt;p&gt;implicit parameterをexplicitに渡すのではなく、モジュールとファンクタを使った実装です。&lt;/p&gt;

&lt;h1 id=&#34;前置き&#34;&gt;前置き&lt;/h1&gt;

&lt;p&gt;Haskell風の中置演算子を使うので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;infix 4 &amp;lt;$&amp;gt; &amp;lt;$ $&amp;gt;  &amp;lt;*&amp;gt; &amp;lt;* *&amp;gt;
infix 1 &amp;gt;&amp;gt;= &amp;gt;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を予め宣言しておきます。&lt;/p&gt;

&lt;h1 id=&#34;最初の試み&#34;&gt;最初の試み&lt;/h1&gt;

&lt;p&gt;さて、(MLの機能の方ではない)functorを考えましょうか。functorには &lt;code&gt;fmap&lt;/code&gt; が要求され、&lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; なんかが実装されます。それを素直に表したらこうなるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature FUNCTOR_MIN = sig
    type &#39;a t
    val fmap: (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature FUNCTOR = sig
    include FUNCTOR_MIN
    val &amp;lt;$&amp;gt; : (&#39;a -&amp;gt; &#39;b) * &#39;a t -&amp;gt; &#39;b t
    val &amp;lt;$ : &#39;a *  &#39;b t -&amp;gt;  &#39;a t
    val $&amp;gt; : &#39;a t *  &#39;b  -&amp;gt;  &#39;b t
    val void: &#39;a t -&amp;gt; unit t
end

functor MkFunctor(Fun: FUNCTOR_MIN): FUNCTOR = struct
    open Fun

    fun f &amp;lt;$&amp;gt; fa = fmap f fa
    fun a &amp;lt;$ fb =  (fn _ =&amp;gt; a) &amp;lt;$&amp;gt; fb
    fun fa $&amp;gt; b = b &amp;lt;$ fa
    fun void fa = () &amp;lt;$ fa
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、さらにそのサブクラスのapplicativeも作ります。 &lt;code&gt;include&lt;/code&gt; を使うことで &lt;code&gt;FUNCTOR&lt;/code&gt; を継承することを表します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature APPLICATIVE_MIN = sig
    include FUNCTOR

    val pure: &#39;a -&amp;gt; &#39;a t
    val ap : (&#39;a -&amp;gt; &#39;b) t -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature APPLICATIVE = sig
    include APPLICATIVE_MIN

    val &amp;lt;*&amp;gt; : (&#39;a -&amp;gt; &#39;b) t * &#39;a t -&amp;gt; &#39;b t
    val *&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
    val &amp;lt;* : &#39;a t * &#39;b t -&amp;gt; &#39;a t
end

functor MkApplicative(App: APPLICATIVE_MIN): APPLICATIVE = struct
    open App

    fun af &amp;lt;*&amp;gt; aa = ap af aa
    fun aa *&amp;gt; ab = pure (fn _ =&amp;gt; fn x =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
    fun aa &amp;lt;* ab = pure (fn x =&amp;gt; fn _ =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにmonadも作りましょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature MONAD_MIN = sig
    include APPLICATIVE

    val bind : &#39;a t -&amp;gt; (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
end

signature MONAD = sig
    include MONAD_MIN

    val return: &#39;a -&amp;gt; &#39;a t
    val &amp;gt;&amp;gt;= : &#39;a t * (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
    val &amp;gt;&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
end


functor MkMonad(M: MONAD_MIN): MONAD = struct
    open M

    val return = pure
    fun ma &amp;gt;&amp;gt;= f = bind ma f
    fun ma &amp;gt;&amp;gt; mb = ma &amp;gt;&amp;gt;= (fn _ =&amp;gt; mb)

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと使ってみましょう。1つ1つインスタンスを作ってあげます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;structure OptionFunc = MkFunctor(
  struct
      type &#39;a t = &#39;a option
      fun fmap f = Option.map f
  end)

structure OptionApp = MkApplicative(
  struct
      open OptionFunc
      fun pure x = SOME(x)
      fun ap af aa = case (af, aa) of
                         (SOME(f), SOME(a)) =&amp;gt; SOME(f a)
                       | _ =&amp;gt; NONE
  end)

structure OptionMonad = MkMonad(
  struct
      open OptionApp
      fun bind ma f = case ma of
                          SOME(a) =&amp;gt; f a
                        | NONE =&amp;gt; NONE
  end)


local
    open OptionMonad
in
    fun add x y = x + y
    fun println s = print (s ^ &amp;quot;\n&amp;quot;)

    val ret1 = add &amp;lt;$&amp;gt; SOME(1) &amp;lt;*&amp;gt; SOME(2)
    val ret2 = SOME(1) &amp;gt;&amp;gt;= (fn x =&amp;gt;
               SOME(2) &amp;gt;&amp;gt;= (fn y =&amp;gt;
               return (x + y)))
    val () = Option.app (println o Int.toString) ret1 (* =&amp;gt; 3 *)
    val () = Option.app (println o Int.toString) ret2 (* =&amp;gt; 3 *)
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きました。&lt;/p&gt;

&lt;p&gt;さて、一見これで良さそうですがML Workshopでの発表では問題点を2点指摘しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Monadのインスタンスが欲しいだけなのにFunctorまで遡って作らないといけない&lt;/li&gt;
&lt;li&gt;ダイアモンド継承が起きた時に共通の親クラスの実装の一貫性を保障出来ない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とのことです。私はこの問題点自体割と疑問なのですがまあ、問題らしいです。&lt;/p&gt;

&lt;h1 id=&#34;解決案&#34;&gt;解決案&lt;/h1&gt;

&lt;p&gt;継承のやり方をちょいと変えます。&lt;code&gt;Functor&lt;/code&gt; までは先程と同じなのですが、Applicativeは
APPLICATIVE_MINにFUNCTORをincludeしません。また、衝突の問題から型が &lt;code&gt;applicative&lt;/code&gt;になります（同じと言っちゃいましたがFunctorの方も &lt;code&gt;functor_&lt;/code&gt; になってます）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature APPLICATIVE_MIN = sig
    type &#39;a applicative
    val pure: &#39;a -&amp;gt; &#39;a applicative
    val ap : (&#39;a -&amp;gt; &#39;b) applicative -&amp;gt; &#39;a applicative -&amp;gt; &#39;b applicative
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてAPPLICATIVEの方でincludeします。ここで &lt;code&gt;sharing&lt;/code&gt; 制約を付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature APPLICATIVE = sig
    include FUNCTOR APPLICATIVE_MIN
    sharing type functor_ = applicative

    val &amp;lt;*&amp;gt; : (&#39;a -&amp;gt; &#39;b) applicative * &#39;a applicative -&amp;gt; &#39;b applicative
    val *&amp;gt; : &#39;a applicative * &#39;b applicative -&amp;gt; &#39;b applicative
    val &amp;lt;* : &#39;a applicative * &#39;b applicative -&amp;gt; &#39;a applicative
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、 &lt;code&gt;APPLICATIVE_MIN&lt;/code&gt; から &lt;code&gt;FUNCTOR_MIN&lt;/code&gt; を生成するファンクタを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;functor ApplicativeMinToFunctorMin(A: APPLICATIVE_MIN): FUNCTOR_MIN = struct
    open A
    type &#39;a functor_ = &#39;a applicative
    fun fmap f = ap (pure f)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;applicativeからfunctor????感ありますがとりあえず進みます。&lt;/p&gt;

&lt;p&gt;で、 &lt;code&gt;MkApplicative&lt;/code&gt; は一旦内部で &lt;code&gt;Functor&lt;/code&gt; を作ってそれを &lt;code&gt;open&lt;/code&gt; します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;functor MkApplicative(App: APPLICATIVE_MIN): APPLICATIVE = struct
    type &#39;a applicative = &#39;a App.applicative

    structure FunctorMin = ApplicativeMinToFunctorMin(App)
    structure Functor = MkFunctor(FunctorMin)
    open App Functor

    fun af &amp;lt;*&amp;gt; aa = ap af aa
    fun aa *&amp;gt; ab = pure (fn _ =&amp;gt; fn x =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
    fun aa &amp;lt;* ab = pure (fn x =&amp;gt; fn _ =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モナドも同じですね。ただ、 &lt;code&gt;MONAD_MIN&lt;/code&gt; から &lt;code&gt;APPLICATIVE_MIN&lt;/code&gt; を生成する必要があるので &lt;code&gt;MONAD_MIN&lt;/code&gt; のシグネチャに &lt;code&gt;return&lt;/code&gt; が増えてます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature MONAD_MIN = sig
    type &#39;a monad
    val return: &#39;a -&amp;gt; &#39;a monad
    val bind : &#39;a monad -&amp;gt; (&#39;a -&amp;gt; &#39;b monad) -&amp;gt; &#39;b monad
end

signature MONAD = sig
    include APPLICATIVE MONAD_MIN
    sharing type applicative = monad
    val &amp;gt;&amp;gt;= : &#39;a monad * (&#39;a -&amp;gt; &#39;b monad) -&amp;gt; &#39;b monad
    val &amp;gt;&amp;gt; : &#39;a monad * &#39;b monad -&amp;gt; &#39;b monad
end

functor MonadMinToApplicativeMin(M: MONAD_MIN): APPLICATIVE_MIN = struct
    open M
    type &#39;a applicative = &#39;a monad
    val pure = return
    fun ap mf ma =  bind mf (fn f =&amp;gt;
                    bind ma (fn a =&amp;gt;
                    return (f a)))
end

functor MkMonad(M: MONAD_MIN): MONAD = struct
    type &#39;a monad = &#39;a M.monad
    structure AppMin = MonadMinToApplicativeMin(M)
    structure App = MkApplicative(AppMin)
    open M App

    fun ma &amp;gt;&amp;gt;= f = bind ma f
    fun ma &amp;gt;&amp;gt; mb = ma &amp;gt;&amp;gt;= (fn _ =&amp;gt; mb)

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと &lt;code&gt;ap&lt;/code&gt; の実装イケてないなぁと思いつつ先に進みます。&lt;/p&gt;

&lt;p&gt;さて、使ってみましょう。今度はファンクタの適用は一回で済みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;structure ListMonad = MkMonad(struct
                                   type &#39;a monad = &#39;a list
                                   fun return x = [x]
                                   fun bind ma f = List.concat (List.map f ma)
                              end)
local
    open ListMonad
in
    val ret = [1, 2, 3] &amp;gt;&amp;gt;= (fn x =&amp;gt;
              [4, 5, 6] &amp;gt;&amp;gt;= (fn y =&amp;gt;
              return (x + y)))
    fun println s = print (s ^ &amp;quot;\n&amp;quot;)

    val () = List.app (println o Int.toString) ret
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きます。
ご覧の通り、ファンクタの適用は1回で済んでますし、親クラスのインスタンス全て自分で生成しているので実装の一貫性も保障出来ます。ダイアモンド継承が来ても安心ですね！&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;私は最初のアプローチの方が好きですね（率直）。&lt;/p&gt;

&lt;p&gt;それぞれのクラスのインスタンスを作るのは自然だと思いますし実はWorkshopのアプローチは表層上の問題でダイアモンド継承を解決出来ていません。名前衝突が起きます。モジュールの名前衝突ならまだ気合で( &lt;code&gt;val &amp;gt;&amp;gt;= = Monad.&amp;gt;&amp;gt;=&lt;/code&gt; のように全て手で)解決出来ますが、シグネチャの方は解決策はなさそうです(いや、シグネチャを使わずに全て手で書き直すとかは可能ですが)。どうせ完全には解決出来てない問題のために実装が曲がるのは好みではないです。&lt;/p&gt;

&lt;h1 id=&#34;付録a-ダイアモンド継承に強そうなアプローチ&#34;&gt;付録A ダイアモンド継承に強そうなアプローチ&lt;/h1&gt;

&lt;p&gt;単純に親クラスのインクルードをやめます。んで親クラスは名前空間の汚染を防ぐためにモジュールに入ったまま受け取ることにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;infix 4 &amp;lt;$&amp;gt; &amp;lt;$ $&amp;gt;  &amp;lt;*&amp;gt; &amp;lt;* *&amp;gt;
infix 1 &amp;gt;&amp;gt;= &amp;gt;&amp;gt;

signature FUNCTOR_MIN = sig
    type &#39;a t
    val fmap: (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature FUNCTOR = sig
    include FUNCTOR_MIN
    val &amp;lt;$&amp;gt; : (&#39;a -&amp;gt; &#39;b) * &#39;a t -&amp;gt; &#39;b t
    val &amp;lt;$ : &#39;a *  &#39;b t -&amp;gt;  &#39;a t
    val $&amp;gt; : &#39;a t *  &#39;b  -&amp;gt;  &#39;b t
    val void: &#39;a t -&amp;gt; unit t
end

functor MkFunctor(Fun: FUNCTOR_MIN): FUNCTOR = struct
    open Fun

    fun f &amp;lt;$&amp;gt; fa = fmap f fa
    fun a &amp;lt;$ fb =  (fn _ =&amp;gt; a) &amp;lt;$&amp;gt; fb
    fun fa $&amp;gt; b = b &amp;lt;$ fa
    fun void fa = () &amp;lt;$ fa
end

signature APPLICATIVE_MIN = sig
    type &#39;a t
    val pure: &#39;a -&amp;gt; &#39;a t
    val ap : (&#39;a -&amp;gt; &#39;b) t -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature APPLICATIVE = sig
    include APPLICATIVE_MIN

    val &amp;lt;*&amp;gt; : (&#39;a -&amp;gt; &#39;b) t * &#39;a t -&amp;gt; &#39;b t
    val *&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
    val &amp;lt;* : &#39;a t * &#39;b t -&amp;gt; &#39;a t
end

functor MkApplicative(App: sig
                          structure Functor: FUNCTOR
                          include APPLICATIVE_MIN
                          sharing type Functor.t = t
                         end): APPLICATIVE = struct
    open App
    type &#39;a t = &#39;a t

    fun af &amp;lt;*&amp;gt; aa = ap af aa
    fun aa *&amp;gt; ab = pure (fn _ =&amp;gt; fn x =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
    fun aa &amp;lt;* ab = pure (fn x =&amp;gt; fn _ =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
end


signature MONAD_MIN = sig
    type &#39;a t
    val return: &#39;a -&amp;gt; &#39;a t
    val bind : &#39;a t -&amp;gt; (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
end

signature MONAD = sig
    include MONAD_MIN
    val &amp;gt;&amp;gt;= : &#39;a t * (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
    val &amp;gt;&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
end


functor MkMonad(M: sig
                    structure Applicative: APPLICATIVE
                    include MONAD_MIN
                    sharing type Applicative.t = t
                end): MONAD = struct
    open M
    type &#39;a t = &#39;a t

    fun ma &amp;gt;&amp;gt;= f = bind ma f
    fun ma &amp;gt;&amp;gt; mb = ma &amp;gt;&amp;gt;= (fn _ =&amp;gt; mb)

end


structure ListFunctor = MkFunctor(struct
                                       type &#39;a t = &#39;a list
                                       val fmap = List.map end)
structure ListApplicative = MkApplicative(struct
                                               structure Functor = ListFunctor
                                               type &#39;a t = &#39;a list
                                               fun pure x = [x]
                                               fun ap af aa = List.concat (List.map (fn a =&amp;gt; List.map (fn f =&amp;gt; f a) af) aa)
                                           end)
structure ListMonad = MkMonad(struct
                                   structure Applicative = ListApplicative
                                   type &#39;a t = &#39;a list
                                   fun return x = [x]
                                   fun bind ma f = List.concat (List.map f ma)
                               end)
local
    open ListFunctor
    open ListApplicative
    open ListMonad
in
    fun add x y = x + y
    val ret1 = [1, 2, 3] &amp;gt;&amp;gt;= (fn x =&amp;gt;
               [4, 5, 6] &amp;gt;&amp;gt;= (fn y =&amp;gt;
               return (x + y)))
    val ret2 = add &amp;lt;$&amp;gt; [1, 2, 3] &amp;lt;*&amp;gt; pure 1
    fun println s = print (s ^ &amp;quot;\n&amp;quot;)

    val () = List.app (println o Int.toString) ret1
    val () = List.app (println o Int.toString) ret2
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;付録b-do記法&#34;&gt;付録B do記法&lt;/h1&gt;

&lt;p&gt;ちょっと &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; が入り乱れるのはつらいですね。&lt;a href=&#34;https://github.com/br0ns/PreML&#34;&gt;PreML&lt;/a&gt;というSMLのプリプロセッサがあって、do記法（など）のシンタックスシュガーを提供してくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;val ret = do with ListMonad;
    x &amp;lt;- [1, 2, 3];
    y &amp;lt;- [4, 5, 6];
    return (x + y)
end
fun println s = print (s ^ &amp;quot;\n&amp;quot;)

val () = List.app (println o Int.toString) ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成されるコードはこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;val ret = let infix 0 &amp;gt;&amp;gt;= val op&amp;gt;&amp;gt;= = ListMonad.&amp;gt;&amp;gt;= val return = ListMonad.return in ( 
         [1, 2, 3] ) &amp;gt;&amp;gt;= (fn  x =&amp;gt; ( 
         [4, 5, 6] ) &amp;gt;&amp;gt;= (fn  y =&amp;gt; 
    return (x + y) ) ) end 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;マシになりましたね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>正しいScalaのコードが欲しい</title>
      <link>/slide/tadashiiScalanoko_dogahoshii/</link>
      <pubDate>Wed, 05 Oct 2016 00:10:25 +0900</pubDate>
      
      <guid>/slide/tadashiiScalanoko_dogahoshii/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 正しいScalaのコードが欲しい
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
   + Scalaはあんまり
===
# Scalaを始めたばかりの頃の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===


``` scala
def revappend[A](
    xs: List[A],
    ys: List[A]): List[A] = match xs {
  case Nil =&gt; Nil
  case x::xs_ =&gt; revappend(xs_, x::ys)
}
```

===

``` scala
def length(xs: List[_]): Int = xs match {
  case Nil =&gt; Nil
  case x::xs_ =&gt; 1 + length(xs_)
}
```

===

``` scala
def append[A](
    xs: List[A],
    ys: List[A]): List[A] = xs match {
  case Nil =&gt; Nil
  case x::xs_ =&gt; x :: append(xs_, ys)
}

append(List(1, 2, 3), List(4, 5, 6))
// =&gt; List(1, 2, 3)

```

===
# Scalaを始めたばかりの頃の話
-----------------------------

* 正しくないコードばかり書いてしまう
  + 他の言語の構文と混ぜてしまう
  + 型エラー
  + 実装ミス
* 正しいScalaのコードが欲しい

===
# 正しさって？
-------------

* 構文が正しいコード?
* コンパイルが通るコード?
* バグのないコード？
  + テストが通るコード?

===
# 正しさって？
-----------

* 数学だったら？
* 数学なら証明されれば正しい
* プログラムの証明????

===
# Isabelle
----------

* 汎用証明支援系
* [Isabelle](https://isabelle.in.tum.de/)
* 結構昔からある
* 関数型言語 + 高階論理

===
# コード
--------

``` isabelle
datatype &#39;a list = Nil                 (&#34;[]&#34;)
  | Cons &#39;a &#34;&#39;a list&#34;    (infixr &#34;#&#34; 65)

primrec app :: &#34;&#39;a list =&gt; &#39;a list =&gt; &#39;a list&#34; (infixr &#34;@&#34; 65)
  where
  &#34;[] @ ys      = ys&#34; |
  &#34;(x # xs) @ ys = x # (xs @ ys)&#34;
```

===

# 証明
------

``` isabelle
lemma app_Nil2 [simp]: &#34;xs @ [] = xs&#34;
  apply(induct_tac xs)
  apply auto
  done

lemma app_assoc [simp]: &#34;(xs @ ys) @ zs = xs @ (ys @ zs)&#34;
  apply (induct_tac xs)
  apply auto
  done
```

===
# Extract
---------

```isabelle
export_code append
   in Scala
   module_name &#34;Example&#34;
   file &#34;Example.scala&#34;
```

===
# Scalaのコード
---------------

証明されたScalaのコードが手に入る

``` scala
object Example {

abstract sealed class list[A]
final case class Nila[A]() extends list[A]
final case class Cons[A](a: A, b: list[A]) extends list[A]

def append[A](x0: list[A], ys: list[A]): list[A] = (x0, ys) match {
  case (Nila(), ys) =&gt; ys
  case (Cons(x, xs), ys) =&gt; Cons[A](x, append[A](xs, ys))
}

} /* object Example */

```

===
# 余談
-------

他の言語にもextract出来る

```isabelle
export_code append
   in SML
   module_name &#34;Example&#34;
   file &#34;Example.sml&#34;
```


===
# まとめ
---------

* プログラムは証明出来るよ
* Isabelleで証明が出来るよ
* Isabelleで証明したら正しいScalaのコードが手に入るよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Pijulのインストールが難易度高いので解説する</title>
      <link>/blog/2016/09/29/pijulnoinsuto_ruganan_idotakainodekaisetsusuru</link>
      <pubDate>Thu, 29 Sep 2016 22:15:51 +0900</pubDate>
      
      <guid>/blog/2016/09/29/pijulnoinsuto_ruganan_idotakainodekaisetsusuru</guid>
      <description>&lt;p&gt;κeenです。ふとTwitterで&lt;a href=&#34;http://pijul.org&#34;&gt;Pijul&lt;/a&gt;の話題を見掛けたついでにインストールしようと思ったら難易度が高かったので解説します。
Pijulそのものについては&lt;a href=&#34;/blog/2016/02/14/dvcsnomoderu_aruihapijulnitsuite/&#34;&gt;過去のエントリ&lt;/a&gt;を参照して下さい。&lt;/p&gt;

&lt;p&gt;因みにPijulは「ピーフール」みたいに発音するそうです。「フー」は喉の奥から出す破擦音ですね。&lt;/p&gt;

&lt;p&gt;まず、公式ドキュメントには &lt;code&gt;cargo install pijul&lt;/code&gt; すると書いてますが、これはバージョン0.1、古いやつな上にビルドに失敗します。
ということでソースからビルドするのですがビルドガイドがないので非常に難しいです。コマンドだけ載せてしまうと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ darcs get https://pijul.org
$ cd pijul.org/pijul
$ cp -R ../libpijul src
$ cd src/libpijul/src
$ darcs get https://pijul.org/sanakirja
$ cd ../../../
$ cargo install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。これだと常に最新版をビルドしてしまいますがdarcsでタグを指定する方法が分からなかったのでこれで。
あ、あと&lt;code&gt;darcs get https://pijul.org/sanakirja&lt;/code&gt;でnested repositoryで怒られますがそれもよく分からなかったのでそのまま。
darcsに馴れてる方は好きにして下さい。&lt;/p&gt;

&lt;p&gt;因みにその後のコマンドはちゃんと動くので&lt;a href=&#34;http://pijul.org/documentation/getting-started/&#34;&gt;公式ガイド&lt;/a&gt;に従えば使えます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustでシェル作った</title>
      <link>/blog/2016/09/04/rustdeshierutsukutta</link>
      <pubDate>Sun, 04 Sep 2016 16:26:20 +0900</pubDate>
      
      <guid>/blog/2016/09/04/rustdeshierutsukutta</guid>
      <description>

&lt;p&gt;κeenです。
先日、先輩社員と話してるとシェルを作る話になりました。
だいたいのコンピュータサイエンスの学生なら学部生の頃に課題でシェルを作りますが数学科にいた私は作ったことありませんでした。
でも、その時「今ならシェルなんて作ろうと思えばすぐに作れますよ」なんて言っちゃったのでなんか作りました。
まあ、習作程度の雑なものです。&lt;/p&gt;

&lt;p&gt;作ったのはこれ、&lt;a href=&#34;https://github.com/KeenS/igaguri&#34;&gt;KeenS/igaguri: my toy shell written in Rust&lt;/a&gt;。
名前は、Shellは木の実を覆う殻のようにカーネルを覆う殻とのことなのでRustのロゴに似てる毬栗を選びました。&lt;/p&gt;

&lt;h1 id=&#34;パーサ&#34;&gt;パーサ&lt;/h1&gt;

&lt;p&gt;パーサコンビネータライブラリの&lt;a href=&#34;https://github.com/Geal/nom&#34;&gt;nom&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;雰囲気こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;named!(token&amp;lt;String&amp;gt;, map!(map_res!(is_a!(&amp;quot;abcdefghijklmnopqlrstuvwxyzABCDEFGHIJKLMNOPQLRSTUVWXYZ-!$%^&amp;amp;@/1234567890&amp;quot;), str::from_utf8), |i: &amp;amp;str| i.to_string()));
named!(pipe, tag!(&amp;quot;|&amp;quot;));
named!(redirect_out&amp;lt;String&amp;gt;, chain!(tag!(&amp;quot;&amp;gt;&amp;quot;) ~ opt!(multispace) ~ filename: token, || filename));

named!(command&amp;lt;Ast&amp;gt;, chain!(
    opt!(multispace)
        ~ cmd: separated_list!(multispace, token)
        ~ outfile: opt!(chain!(multispace ~ out: redirect_out, || out))
        ~ opt!(multispace), || Ast::Command{cmd: cmd, out: outfile}));
named!(parse&amp;lt;Ast&amp;gt;, map!(separated_list!(pipe, command), Ast::Pipe));

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;入力ハンドリング&#34;&gt;入力ハンドリング&lt;/h1&gt;

&lt;p&gt;readlineのRust実装、&lt;a href=&#34;https://github.com/kkawakam/rustyline&#34;&gt;rustyline&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;それっぽいからとりあえず、で選んだものの、複数行入力（履歴）とか考えるともうちょっとリッチなものを選んだ方が良かったかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;実行&#34;&gt;実行&lt;/h1&gt;

&lt;p&gt;最初、&lt;a href=&#34;https://github.com/rust-lang/libc&#34;&gt;libcバインディング&lt;/a&gt;の &lt;code&gt;pipe&lt;/code&gt; や &lt;code&gt;fork&lt;/code&gt; 、 &lt;code&gt;execve&lt;/code&gt; なんかを考えてましたが、標準ライブラリの &lt;a href=&#34;https://doc.rust-lang.org/std/process/struct.Command.html&#34;&gt;&lt;code&gt;std::process::Command&lt;/code&gt;&lt;/a&gt;で実現出来そうだったのでそれを使いました。&lt;/p&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Command::new(cmd)
    .args(&amp;amp;terms)
    .stdin(stdin)
    .stdout(stdout)
    .stderr(stderr)
    .spawn()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パイプ-リダイレクト&#34;&gt;パイプ/リダイレクト&lt;/h2&gt;

&lt;p&gt;一応、パイプも標準ライブラリでサポートされてるのでそれを使いました。&lt;/p&gt;

&lt;p&gt;ただ、普通のCとは違って子プロセスと親プロセスの間に一旦パイプを作って、子プロセスの出力の生のfdを取り出して、次の子プロセスの入力に与えて、と案外面倒でした。 &lt;code&gt;unsafe&lt;/code&gt; も出てくれば &lt;code&gt;unreachable&lt;/code&gt; も出てくるのでもう少し書き直したい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut si = stdin;
let mut itr = commands.into_iter().peekable();
unsafe {
    while let Some(command) = itr.next() {
        if itr.peek().is_some() {
            let process =
                try!(self.run(command, si, Stdio::piped(), Stdio::inherit()));
            si = Stdio::from_raw_fd(process.stdout.unwrap().into_raw_fd());
        } else {
            return self.run(command, si, stdout, stderr);
        }
    }
}
unreachable!()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リダイレクトも似たようなもので、ファイルを作って生のfdを取り出して、とやります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let stdout = out.map(|f| {
    unsafe {
        let file = File::create(f)
        // FIXME: do not panic
            .unwrap();
        Stdio::from_raw_fd(file.into_raw_fd())
    }

}).unwrap_or(stdout);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;昨日の夜からちょろっと作り始めてさっきそれっぽく動くようになった程度なのでまだ適当にしか動きません。
パイプと標準出力のリダイレクトだけで、 &lt;code&gt;cd&lt;/code&gt; なんかのシェルコマンドもなければシェル変数もありません。
が、そろそろ飽きたのでこの辺で。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そろそろ飽きてきた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/772334565264232454&#34;&gt;2016年9月4日&lt;/a&gt;&amp;lt;/
blockquote&amp;gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;シェルコマンドとシェル変数くらいはいつか実装しようかな。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mirah 0.2がリリースされました。</title>
      <link>/blog/2016/08/11/mirah_0_2gariri_susaremashita</link>
      <pubDate>Thu, 11 Aug 2016 15:32:39 +0900</pubDate>
      
      <guid>/blog/2016/08/11/mirah_0_2gariri_susaremashita</guid>
      <description>

&lt;p&gt;κeenです。久しぶりに&lt;a href=&#34;mirah.org&#34;&gt;mirah&lt;/a&gt;のリリースが出ましたので新機能の紹介をしたいと思います。&lt;/p&gt;

&lt;p&gt;リリース版のダウンロードは &lt;a href=&#34;https://github.com/mirah/mirah/releases/tag/0.2.0&#34;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;

&lt;h1 id=&#34;のセマンティクス変更&#34;&gt;&lt;code&gt;==&lt;/code&gt; のセマンティクス変更&lt;/h1&gt;

&lt;p&gt;Rubyに合わせて、 &lt;code&gt;==&lt;/code&gt; が等価性、 &lt;code&gt;===&lt;/code&gt; が同値性の比較になりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;import java.net.URL

puts &amp;quot;1 == 1 =&amp;gt; #{1 == 1}&amp;quot;
puts &amp;quot;1 === 1 =&amp;gt; #{1 === 1}&amp;quot;
x = 1; puts &amp;quot;x = 1&amp;quot;
puts &amp;quot;x == x =&amp;gt; #{x == x}&amp;quot;
puts &amp;quot;x === x =&amp;gt; #{x === x}&amp;quot;
puts &amp;quot;URL.new(\&amp;quot;http://hoge.com\&amp;quot;) == URL.new(\&amp;quot;http://hoge.com\&amp;quot;) =&amp;gt; #{URL.new(&amp;quot;http://hoge.com&amp;quot;) == URL.new(&amp;quot;http://hoge.com&amp;quot;)}&amp;quot;
puts &amp;quot;URL.new(\&amp;quot;http://hoge.com\&amp;quot;) === URL.new(\&amp;quot;http://hoge.com\&amp;quot;) =&amp;gt; #{URL.new(&amp;quot;http://hoge.com&amp;quot;) === URL.new(&amp;quot;http://hoge.com&amp;quot;)}&amp;quot;
x = URL.new(&amp;quot;http://hoge.com&amp;quot;); puts &amp;quot;x = URL.new(\&amp;quot;http://hoge.com\&amp;quot;)&amp;quot;
puts &amp;quot;x == x =&amp;gt; #{x == x}&amp;quot;
puts &amp;quot;x === x =&amp;gt; #{x === x}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1 == 1 =&amp;gt; true
1 === 1 =&amp;gt; true
x = 1
x == x =&amp;gt; true
x === x =&amp;gt; true
URL.new(&amp;quot;http://hoge.com&amp;quot;) == URL.new(&amp;quot;http://hoge.com&amp;quot;) =&amp;gt; true
URL.new(&amp;quot;http://hoge.com&amp;quot;) === URL.new(&amp;quot;http://hoge.com&amp;quot;) =&amp;gt; false
x = URL.new(&amp;quot;http://hoge.com&amp;quot;)
x == x =&amp;gt; true
x === x =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ビルトインmacroの追加&#34;&gt;ビルトインMacroの追加&lt;/h1&gt;

&lt;h2 id=&#34;キャスト&#34;&gt;キャスト&lt;/h2&gt;

&lt;p&gt;今まで、Mirahのキャスト構文は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;int(0.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように関数呼び出しっぽい形式でしたが、この度 &lt;code&gt;as!&lt;/code&gt; マクロが追加されたので以下のように書けるようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;puts &amp;quot;0.5.as!(int) =&amp;gt; #{0.5.as!(int)}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0.5.as!(int) =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;synchronize&#34;&gt;Synchronize&lt;/h2&gt;

&lt;p&gt;javaの &lt;code&gt;Lock&lt;/code&gt; の &lt;code&gt;lock&lt;/code&gt; , &lt;code&gt;unlock&lt;/code&gt; を &lt;code&gt;sychronize&lt;/code&gt; マクロでラップしました。Javaのビルトインの &lt;code&gt;synchronized&lt;/code&gt; ではない模様。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;import java.util.concurrent.locks.ReentrantLock
lock = ReentrantLock.new
counter = 0
th1 = Thread.new do
  100.times do
    lock.synchronize do
      counter += 1
    end
  end
end

th2 = Thread.new do
  100.times do
    lock.synchronize do
      counter -= 1
    end
  end
end

th1.run
th2.run
th1.join
th2.join
puts &amp;quot;counter = #{counter}&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;counter = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;private&#34;&gt;&lt;code&gt;private&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;private def my_method
  puts &amp;quot;foo&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいに書けるようになりました。&lt;/p&gt;

&lt;h2 id=&#34;ラッパークラスの演算子&#34;&gt;ラッパークラスの演算子&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;int&lt;/code&gt; に対する &lt;code&gt;Integer&lt;/code&gt; のようなラッパークラスにも演算子マクロが定義されるようになました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;b = Integer.new(1); puts &amp;quot;b = Integer.new(1)&amp;quot;
b += 1;puts &amp;quot;b += 1&amp;quot;
puts &amp;quot;a &amp;lt; b =&amp;gt; #{a &amp;lt; b}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;a &amp;lt; b =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にも色々と定義されているようです。&lt;/p&gt;

&lt;h1 id=&#34;改善&#34;&gt;改善&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Javaのバイトコードを吐くライブラリasmのバージョンが5になりました。&lt;/li&gt;
&lt;li&gt;コンパイラのの内部で使っているロガーをマクロで書き直すことでDebug出力しない時のコンパイラの速度が速くなりました(確かこの変更が入った時に20%速くなるって言ってたような)。&lt;/li&gt;
&lt;li&gt;マクロが&lt;a href=&#34;http://www.ne.jp/asahi/hishidama/home/tech/java/jar.html#h_Service_Provider&#34;&gt;サービスプロバイダ&lt;/a&gt;の仕組みに乗っかるようになりました。
マクロを使うには今までマクロを定義したmirahのソースコードを一緒にコンパイルしないといけなかったのが、Mirahコンパイラがクラスパスから捜すようになったのでJarによる配布が現実的になりました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;マクロ周りが便利になるなど、興味深い変更がありましたね。
みなさんもこれを機にmirahを使ってみて下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>私がコードを書くときテストは書かない</title>
      <link>/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai</link>
      <pubDate>Tue, 02 Aug 2016 00:12:22 +0900</pubDate>
      
      <guid>/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai</guid>
      <description>&lt;p&gt;ちょっとポエムというか自分語りを。会社の同期と話してて少し刺激されたので。あとは&lt;a href=&#34;https://note.mu/ruiu/n/n1083b2a5d547&#34;&gt;ソースコードって実際のところどういうふうに書いていますか？｜Rui Ueyama｜note&lt;/a&gt;にも刺激されて。&lt;/p&gt;

&lt;p&gt;発端は同期が最近は何か書いてもイケてなくて後で丸っと書き直すことが多くてつらい、という話を始めたこと。
自分は、そんなの普通だろと返した。少なくとも自分の中では当たり前だった。
ふと考えてみたらそうじゃない人も沢山いる気がした。当たり前じゃない人に、自分の当たり前を喋ってみたら面白そうということで自分がコードを書くときにやることを語る。&lt;/p&gt;

&lt;p&gt;コードを書き始めた時点では仕様は完全には固まっていない。アプリケーションの構成とかは決まってるけど、ソフトウェアの中身はほとんど何も決まっていない。
まずは手を着けやすそうな所から始める。最初は必ずHello Worldから。そしてmainの中にPoCを書いてイメージを掴む。
そこから一気に飛躍して、ディレクトリ構成を決める。mainは三枚下ろしにして各ディレクトリ下に入れる。これでアプリケーションの骨格が見える。ここまでトップダウン。この状態でアプリケーションを走らせるとPoCが動く。&lt;/p&gt;

&lt;p&gt;次はボトムアップのフェーズで、骨格に肉付けしていく。1度に考えることが一箇所で済むように、順番を考えながら気儘にコードを加えていく。だいたいデータアクセス層のインターフェース、データアクセス層の実装のスタブ、サービス層のスタブ、メインルーチン、サービス層、くらいの順番。抽象すると必要そうなものを定義する、定義したものを使う、定義したものを実装する。多少型が違ってコンパイルが通らなくても気にしない。エラー処理やエッジケースは全部スタブのまま。コードのあちこちに &lt;code&gt;FIXME&lt;/code&gt; が散らばる。条件分岐の枝は全ては書かない。頭のコンテキストスイッチで死んでしまう。集中したい枝以外はFIXMEで埋める。こんなもんかな、と思ったところでちゃんとコンパイルが通るように修正する。ここまでテスト無し、データアクセス層の実装無し。&lt;/p&gt;

&lt;p&gt;ここからようやく永続データのスキーマやアプリケーションの仕様を決める。コードを見ればどういうデータにパターンでアクセスして、どういうエッジケースがあるかが分かるからサクサク決まる。&lt;/p&gt;

&lt;p&gt;データのスキーマが決まったので最後データアクセス層を実装出来る。そしたら動くものが完成する。動いたものをポチポチやってみて実装が正しいことを確認する。&lt;/p&gt;

&lt;p&gt;このまま細かい実装を詰めていくかというとそうならない。仕様を見て、コードを見て、イケてない所を全部書き直す。まずはインターフェースを変える、型を変える。意図的にコードを壊す。あとはコンパイルエラーで修正箇所が全て分かる。ついでにFIXMEも片付けていく。エラーが取れてアプリケーションが再度動くようになったら、リファクタの完了。納得のいくコードになっている筈。ここでようやく仕様を固定するためにテストを書く。全てのコードが出来てからテストを書くからホワイトボックスに近いテストになる。&lt;/p&gt;

&lt;p&gt;どうしてこのようなプロセスを経るかと考えてみた。ポールグレアムも言っているように、私にとってのアプリケーションは、アプリケーションのドメインを記述するための巨大な言語（ライブラリ）と、それを使った非常に小さな実装からなる。
そして言語と実装の境界は何度も押したり引いたりしてようやく固まる。この手順は境界が固まるまでの過程だ。DSLを作るにはまずどのようなAPIがあれば便利か理解する必要がある。理解するのに一番手っ取り早い方法は一旦実装してみることだ。
ある人は言うだろう、「何を七面倒な。最初からちゃんと設計していれば手戻りがないものを。」と。違う。こういうときに私はよく詰将棋を引き合いに出す。
新聞の片隅にある詰将棋を解いてみる。新聞とにらめっこしてアレコレ考えても中々上手くいかない。
ところが将棋盤を引っ張り出してきて、パチパチ駒を動かしてみると簡単に解けることがある。ここは実は銀を持っていた、ここで馬が効くからこの手は指せない。
人間先を読むには想像力が足りなすぎる。目の前に現物がないと気付けないことが多い。だから先に実装する。一度作ってしまえば壊してもコンパイラが助けてくれる。&lt;/p&gt;

&lt;p&gt;一度目でアタリを付ける。二度目で実線を書く。作って、壊して、また作る。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>型クラスを越えて</title>
      <link>/slide/katakurasuwokoete/</link>
      <pubDate>Sat, 16 Jul 2016 02:53:49 +0900</pubDate>
      
      <guid>/slide/katakurasuwokoete/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 型クラスを越えて
----------------------
[歌舞伎座.tech#10「型クラス勉強会」](http://kbkz.connpass.com/event/32420/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# Rustとは
----------

* システムプログラミング言語
* GCなし！でもメモリ管理は自動
* **Zero-Cost Abstraction**
* **Trait-Based Generics**
* パターンマッチ、代数的データ型などなど
* [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/README.html)

===
# Rustのトレイト的なの
----------------

* 型に固有のメソッド
  + オブジェクト指向的な
* トレイト
  + 型クラス

===
# 型クラスじゃない方
-------------------

``` rust
struct Person {
  name: String,
}
impl Person {
  // Static constructor
  fn new(name: String) -&gt; Self {
    Person{name: name}
  }

  // method
  fn hello(&amp;self) {
    println!(&#34;Hello, {}&#34;, self.name);
  }
}
```

===
``` rust
let person = Person::new(&#34;κeen&#34;);
person.hello();
```

===
# 多相型と制約
--------------

``` rust
struct Temp&lt;T&gt;(T);

impl &lt;T: Celsius&gt; Temp&lt;T&gt; {
  fn fromCelsius(t: isize) -&gt; Self {
    Temp(Celsius(t))
  }
}

impl &lt;T: Fahrenheit&gt; Temp&lt;T&gt; {
  fn fromFahrenheit(t: isize) -&gt; Self {
    Temp(Fahrenheit(t))
  }
}

```

===
# 型クラス
---------

* 便利
* 他の言語にも取り入れてほしい
* 型クラスを入れることで言語設計がどうなるか
* ユーザランドより言語機能的な部分フォーカス

===
# Rustの型クラスの実装
---------------------

* 動的ディスパッチと静的ディスパッチ両方がある
* 動的ディスパッチ
  + implicit parameterを渡すやつ
* 静的ディスパッチ
  + コンパイル時に解決してしまうやつ
* デフォフォルト静的
  + 動的を選ぶことも出来る

===
# 静的ディスパッチの意味
-----------------------

* Zero-Cost Abstraction
* ユーザはパフォーマンスのために設計を曲げる必要がなくなる
* インライン化などの最適化も出来る
* 逆の見方をすればZero-Cost Abstraction出来るからシステムプログラミング言語に高級な機能を入れれた

===
# 型クラス+α
-----------
それぞれ面白い特徴が。

* `FromStr`
* `Write`
* `Add`
* `Default`, `Zero`
* `Iterator`

===
# 型クラス+関数
--------------

* 関連関数
* `FromStr`
* static関数的なものになる

```rust
pub trait FromStr {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
```

===
``` rust
use std::str::FromStr;

let s = &#34;5&#34;;
let x = i32::from_str(s).unwrap();

assert_eq!(5, x);
```

===
# 型クラス+構文
--------------

* = メソッド
* 第一引数が `self` な関数はメソッド構文で呼び出せる
* クラスがなくても継承がなくてもオブジェクト指向
* `Write`

``` rust
trait Write {
  fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
}
```

===
``` rust
impl Write for Foo {
  fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt; {
    ...
  }
}

let foo = Foo::new();
foo.write(aa);
```

===
# 型クラス+UFCS
---------------

* = 実質オーバーロード
* 中身の違うメソッドを複数定義出来る
* どのメソッドを呼ぶかを決定する構文がある
  + = Universal Function Call Syntax

===
```rust
trait Foo {
    fn foo() -&gt; i32;
}

struct Bar;

impl Bar {
    fn foo() -&gt; i32 {
        20
    }
}

impl Foo for Bar {
    fn foo() -&gt; i32 {
        10
    }
}

```
===

```rust
&lt;Bar as Foo&gt;::foo();
Bar::foo();
```


===
# 型クラス+演算子
-----------------

* = 演算子オーバーロード
* `Add`

``` rust
pub trait Add&lt;RHS = Self&gt; {
    type Output;
    fn add(self, rhs: RHS) -&gt; Self::Output;
}
```

===

``` rust
use std::ops::Add;

struct Foo;

impl Add for Foo {
    type Output = Foo;

    fn add(self, _rhs: Foo) -&gt; Foo {
        println!(&#34;Adding!&#34;);
        self
    }
}

fn main() {
    Foo + Foo;
}
```
===
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;for (my_int i = 0; i &amp;lt; 10; i++) { … }&lt;br&gt;&lt;br&gt;Cならどういうアセンブリに落ちるかすぐわかるけどC++ならmy_intはクラスかもしれず=0はコンストラクタを起動し&amp;lt;はメソッド呼び出しになり++はejectを発行して光学ディスクトレイが開き相手は死ぬ&lt;/p&gt;&amp;mdash; わさびず &lt;a href=&#34;https://twitter.com/___yuni/status/681891856335032320&#34;&gt;2015年12月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 型クラス+値
-------------

* = 関連定数
* unstable...
* `Zero`, `Default`

``` rust
// current
pub trait Zero {
    fn zero() -&gt; Self;
}
```

``` rust
// ideal
#![feature(associated_consts)]
pub trait Zero {
    const ZERO: Self;
}
```

===
```rust
trait Monoid: Add&lt;Self&gt; + Zero
  where Self::Output : Add&lt;Self&gt; + Zero {
}

```

===
# 型クラス+型
-------------

* 関連型
* 型族…？
  + あまり違いを分かっていない
  + 関連型を持った型をまとめたのが型族？
* `Iterator`

```rust
pub trait Iterator {
  type Item;
  ....
}
```

===
``` rust
trait Iterator {
  ...
  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
```

===
# 型クラス+暗黙のルール
---------------------

* オーバーライド
* `Drop`
  + 暗黙に呼ばれるデストラクタをオーバーライド出来る

```rust
pub trait Drop {
    fn drop(&amp;mut self);
}
```

===
``` rust
impl Drop for Lock {
    fn drop(&amp;mut self) {
        self.free();
    }
}
```

===
# 型クラス+アノテーション
------------------------

* 単純に便利
* `derive`(`Debug` , `Eq`)

``` rust
#[derive(Debug, Eq)]
struct Foo(usize);
```

===

``` rust
let foo1 = Foo(1);
let foo2 = Foo(2);
println!(&#34;{:?} == {:?} ?: {:?}&#34;,
         foo1,
         foo2,
         foo1 == foo2);
```

===
# まとめ
--------

* 型クラスは便利だよ
* 型クラスの実装は効率的に出来るよ
* 型クラスを使うと言語設計も変わるよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>シェル芸十八般</title>
      <link>/blog/2016/07/13/shierugeijuuhachihan</link>
      <pubDate>Wed, 13 Jul 2016 23:34:03 +0900</pubDate>
      
      <guid>/blog/2016/07/13/shierugeijuuhachihan</guid>
      <description>

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;武芸十八般のひとつシェル芸ってワードがふと湧いてきたけどどちらかというとシェル芸十八般とかの方がよさそう。grep, cut, xargs,&amp;hellip;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/753211663927513088&#34;&gt;2016年7月13日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;cat&#34;&gt;&lt;code&gt;cat&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;ファイルの内容を吐くのに使う。 -n とか使えそうなオプションがあるが滅多に使わない&lt;/p&gt;

&lt;h2 id=&#34;例&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat file
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;head&#34;&gt;&lt;code&gt;head&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;標準入力の先頭のほうだけを切り取る。大きなファイルに対して処理する前にちょろっと試すのに使う&lt;/p&gt;

&lt;h2 id=&#34;例-1&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat large_file | head -n 10 | ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tail&#34;&gt;&lt;code&gt;tail&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;標準入力の末尾のほうだけを切り取る。&lt;code&gt;-f&lt;/code&gt; オプションでよく使う&lt;/p&gt;

&lt;h2 id=&#34;例-2&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tail -f log_file | grep -ie error -e &#39;$&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;grep&#34;&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;globally regexp print. 汎用フィルタとして様々に活躍する他飛び道具的な使い方もある。&lt;/p&gt;

&lt;h2 id=&#34;例-3&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat file | grep some_word
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat file | grep -v &amp;quot;^[ \n\t]+$&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo hello | grep -o .
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;awk&#34;&gt;&lt;code&gt;awk&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;プログラミング言語awk。だいたい &lt;code&gt;cut&lt;/code&gt; の上位互換として使われる。&lt;/p&gt;

&lt;h2 id=&#34;例-4&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls -l | awk &#39;{print $3}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;seq 1 100 | awk &#39;BEGIN{sum=0}{sum+=$0}END{print sum}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sed&#34;&gt;&lt;code&gt;sed&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;プログラミング言語sed。だいたい &lt;code&gt;s/RE/replace/&lt;/code&gt; が使われるが使いこなすと深い。&lt;/p&gt;

&lt;h2 id=&#34;例-5&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat log_file | sed &#39;s/error/ERROR/gi&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat some.csv | sed 1d
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;xargs&#34;&gt;&lt;code&gt;xargs&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;標準入力を横に並べる、コマンドを並列に実行する、繰り返し実行をするなどストリーム内での制御機構的働きをする&lt;/p&gt;

&lt;h2 id=&#34;例-6&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;seq 1 10 | xargs echo
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -type f | xargs -P $(nproc) grep FIXME
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;inc(){ echo $(( 1 + $1 ));}
export -f sum
seq 1 10 | xargs -I@ bash -c &#39;sum @&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;find&#34;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;複雑なクエリ式を書けるコマンド。(シェルに依存してしまう)ワイルドカード展開の肩代わりなんかも出来る。xargsに繋げることが多い。&lt;/p&gt;

&lt;h2 id=&#34;例-7&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -type f -name &#39;*.md&#39; -exec basename &#39;{}&#39; .md \;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sort&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;ほぼ次のuniqに繋げるために使うことが多い。あるいはuniqした結果を使う。&lt;/p&gt;

&lt;h2 id=&#34;例-8&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat .histfile | grep &#39;|&#39; | sed &#39;s/|/\n/g&#39; | awk &#39;{print $1}&#39; | LANG=C sort | uniq -c | LANG=C sort
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;uniq&#34;&gt;&lt;code&gt;uniq&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;多くは頻度のカウントに使う。&lt;/p&gt;

&lt;h1 id=&#34;tar&#34;&gt;&lt;code&gt;tar&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;リモートホストとファイルをやりとりするのに使う。&lt;/p&gt;

&lt;h2 id=&#34;例-9&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh stepper ssh host1 tar czf - -C &#39;/var/log/somedir/&#39; stdout.log stderr.log | tar xzf - -C /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;zcat&#34;&gt;&lt;code&gt;zcat&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;圧縮ファイル扱うのに使う。よくtarと組み合わせる。
プロセスが分かれる分マルチコアを使えるのでtarのzオプション使うより速いかもしれない。&lt;/p&gt;

&lt;h2 id=&#34;例-10&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zcat some.tar.gz | tar tf - | xargs -I@ -n 1 basename @ .java
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;date&#34;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;日付操作用コマンド。BSD系とGNU系で全然違う。つらい。&lt;/p&gt;

&lt;h2 id=&#34;例-11&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find logs -type f -name &#39;*.log&#39; | xargs -I@ dirname @ | sed &#39;s|logs/||&#39; | tr / - | xargs -I@ date --date=@ +%w | sort | uniq -c
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tr&#34;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;文字置換、削除。&lt;code&gt;sed&lt;/code&gt;で出来るじゃんとか言わない。&lt;/p&gt;

&lt;h2 id=&#34;例-12&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat data.list | tr -c &#39;[a-zA-Z0-9\n]&#39; _ | xargs touch
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;curl&#34;&gt;&lt;code&gt;curl&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;なんでもプロトコル喋る人。結果を標準出力に吐くのでREST APIを叩いた後シェル芸に繋げやすい。&lt;/p&gt;

&lt;h2 id=&#34;例-13&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl http://example.io/status | jq -r &#39;.status&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;jq&#34;&gt;&lt;code&gt;jq&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;チューリング完全言語jq。REST API叩いてjsonが返ってきた時に使うと便利。&lt;/p&gt;

&lt;h1 id=&#34;od&#34;&gt;&lt;code&gt;od&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;バイナリデータを扱うのに使う。&lt;/p&gt;

&lt;h2 id=&#34;例-14&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat /dev/urandom | od -x | head -n 10 | ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tee&#34;&gt;&lt;code&gt;tee&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;T字管のようにパイプを分岐させるのに使う。あるいはシェルの機能であるリダイレクトをコマンドとして実行するのに使う。&lt;/p&gt;

&lt;h2 id=&#34;例-15&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat nginx.conf | ssh stepper ssh host1 sudo tee /etc/nginx/nginx.conf &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Container Desgin Patterns</title>
      <link>/blog/2016/07/02/container_desgin_patterns</link>
      <pubDate>Sat, 02 Jul 2016 22:26:10 +0900</pubDate>
      
      <guid>/blog/2016/07/02/container_desgin_patterns</guid>
      <description>

&lt;p&gt;κeenです。先日、Kubernetesの開発者が書いた&lt;a href=&#34;http://blog.kubernetes.io/2016/06/container-design-patterns.html&#34;&gt;Kubernetes: Container Design Patterns&lt;/a&gt;というのを教えてもらって、面白かったのでそれを紹介します。
ただ漫然とコンテナを使っているだけでは気付かない使い方があったのでコンテナに興味のある方は是非一読下さい。&lt;/p&gt;

&lt;h1 id=&#34;序論&#34;&gt;序論&lt;/h1&gt;

&lt;p&gt;オブジェクト指向が出てすぐにオブジェクト指向デザインパターンが産まれたように、分散システムにもデザインパターンが必要となってきました。
分散システムのデザインパターンの萌芽はHadoop/MapReduceに見ることが出来ますが、Javaに限られていました。
ところがここ数年の(Linuxの)コンテナ技術の躍進により欠けていたピースが埋まりました。分散システムパターンへのデプロイの抽象化です。
依存モジュールも一緒にデプロイ出来ますし、デプロイの状態も成功/失敗の二値になります。
それだけでなく、コンテナはオブジェクト指向におけるオブジェクトによく似た役割を果たします。それを見ていきましょう。&lt;/p&gt;

&lt;h1 id=&#34;単一コンテナのマネジメント-パターン&#34;&gt;単一コンテナのマネジメント パターン&lt;/h1&gt;

&lt;p&gt;コンテナは、自然にインターフェースの境界となります（オブジェクトと同じように）。
アプリケーション機能のインターフェースに留まらず、コンテナそのものの管理インターフェースも提供するでしょう。
典型的には &lt;code&gt;run()&lt;/code&gt; &lt;code&gt;pause()&lt;/code&gt; &lt;code&gt;stop()&lt;/code&gt; の管理ですが、もっと多様な管理インターフェースが有り得ます。&lt;/p&gt;

&lt;p&gt;大抵の今時のプログラミング言語ならHTTP経由でJSONをやりとりする機能くらい簡単に書けるのでそれがコンテナ間で統一さたインターフェースになりえるでしょう。&lt;/p&gt;

&lt;p&gt;上位のアプリケーションに対してはコンテナ内の情報(アプリケーションのQPS, プロファイル情報, コンフィグ情報, ヘルスチェック, ログなどなど)を提供するでしょう。&lt;/p&gt;

&lt;p&gt;下位のアプリケーションにはマネジメントインターフェース、例えばgraceful shutdownなどを提供することになるでしょう。
Android OSがActivityを管理する時に様々なコールバック(&lt;code&gt;onCreate&lt;/code&gt;, &lt;code&gt;onResume&lt;/code&gt;&amp;hellip;)を呼ぶように、分散マネージャがコンテナを管理するための様々なAPIを提供すると綺麗に管理出来ます。
また、コンテナ特有の機能として「レプリケーションする」（スケールアップするためのインターフェース）なんかもあるかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;単一ノード-複数コンテナのアプリケーションパターン&#34;&gt;単一ノード、複数コンテナのアプリケーションパターン&lt;/h1&gt;

&lt;p&gt;コンテナマネージャにはKubernetesのPodやNomadのTask Groupsのように複数のコンテナを1つのノードにスケジュールする機能があります。
別にコンテナに分けずに複数のコンテナをアプリケーションと同じの1つのコンテナに入れることも可能です。しかしながら分けた方が様々なメリットが得られます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;コンテナがリソース管理の単位である。cgroupによる管理がやりやすくなる。&lt;/li&gt;
&lt;li&gt;コンテナがパッケージングの単位である。複数のコンテナでデプロイや管理をするチームを分けるのも簡単になるし、テストも簡単になる。&lt;/li&gt;
&lt;li&gt;コンテナが再利用の単位である。多くのサブ機能コンテナは多種のメインコンテナと一緒に使うことが出来る。&lt;/li&gt;
&lt;li&gt;コンテナが障害を分離する境界になる。例えば、コンテントマネジメントコンテナに障害があったとしても、Webサーバコンテナはサービスを継続出来るようになる。&lt;/li&gt;
&lt;li&gt;コンテナがデプロイの単位となる。新しい機能の追加やロールバックが単独で行える。（ただし、アプリケーションのバージョンの組み合わせが増えるという点では短所にもなる）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ということでそれらを前提にしたデザインパターンをいくつか。&lt;/p&gt;

&lt;h2 id=&#34;サイドカーパターン&#34;&gt;サイドカーパターン&lt;/h2&gt;

&lt;p&gt;メインのアプリケーションコンテナにサイドカーのように付属するコンテナを付けて、機能を足すパターンです。
例えばアプリケーションがあって、それのログをローカルストレージから分散ストレージに保存するサイドカーなど。&lt;/p&gt;

&lt;p&gt;逆に、ローカルディスクのファイルを提供するWebサーバがあったとして、そのために定期的にgitからstatic fileをpollするサイドカーコンテナなんかもあるかもしれません。&lt;/p&gt;

&lt;p&gt;これらのサイドカーは同じノードのコンテナ同士ならディスクボリュームを共有出来ることに依存した作りになっています。&lt;/p&gt;

&lt;h2 id=&#34;アンバサダーパターン&#34;&gt;アンバサダーパターン&lt;/h2&gt;

&lt;p&gt;アンバサダーパターンはメインコンテナと別システムとのコミュニケーションを代理します。
例えば、&lt;a href=&#34;https://github.com/twitter/twemproxy&#34;&gt;twemproxy&lt;/a&gt; のコンテナをアンバサダーとすれば実際は複数のmemcachedにシャードされたmemcachedクラスタと通信しているも関らず、アプリケーションはローカルホストのmemcachedと通信しているように出来ます。&lt;/p&gt;

&lt;p&gt;この利点は1つにはアプリケーションをローカルホストのmemcachedと通信することだけを考えて書けばいいようになる点、もう1つにはアプリケーションのテストをローカルホストのmemcachedとだけすれば良くなる点、さらにもう1つにはtwemproxyのコンテナを（別の言語で書かれた）別のアプリケーションに使い回せる点にあります。&lt;/p&gt;

&lt;p&gt;これは同じホストのコンテナ同士はローカルホストのネットワークインターフェースを使って通信出来ることに依存した作りになっています。&lt;/p&gt;

&lt;h2 id=&#34;アダプターパターン&#34;&gt;アダプターパターン&lt;/h2&gt;

&lt;p&gt;アダプターパターンはアンバサダーパターンの逆で、アプリケーションを外部から観測した時に統一されたインターフェースを提供するようにするために使います。&lt;/p&gt;

&lt;p&gt;アプリケーション毎にメトリクスの採り方は異ります（例えばJavaならJMX、など）。様々にあるメトリクスを統一したインタフェースで提供するとメトリクスアグリゲータが非常にシンプルになります。
具体的な例を出すと&lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;のためのインターフェース (HTTP &lt;code&gt;/metrics&lt;/code&gt;)を提供する(&lt;a href=&#34;https://prometheus.io/docs/instrumenting/exporters/&#34;&gt;exporter&lt;/a&gt;)コンテナなどです。&lt;/p&gt;

&lt;p&gt;アダプターとメインコンテナはストレージやローカルホストネットワークを通じてデータをやりとりするでしょう。&lt;/p&gt;

&lt;h1 id=&#34;複数ノードアプリケーションパターン&#34;&gt;複数ノードアプリケーションパターン&lt;/h1&gt;

&lt;p&gt;次は複数のノードに跨る協調分散システムでのパターンです。
こちらも同じくPodなどの抽象化を前提とします。&lt;/p&gt;

&lt;h2 id=&#34;リーダー選出パターン&#34;&gt;リーダー選出パターン&lt;/h2&gt;

&lt;p&gt;分散システムではリーダを選出する需要が多々あります。
例えば複数のレプリカを作った時にマスターがコケたら次のマスターを選出しないといけません。&lt;/p&gt;

&lt;p&gt;巷にはリーダー選出アルゴリズムを実装したライブライが出回っていますが、往々にして難解であり、また、特定の言語でしか動かないので再利用性がありません。&lt;/p&gt;

&lt;p&gt;そこで、ライブラリを使うのではなくてリーダー選出コンテナを実装しましょう。&lt;/p&gt;

&lt;p&gt;単一ノードのパターンと同じく、リーダー選出コンテナとアプリケーションコンテナを一緒にスケジューリングします。
そして、リーダー選出コンテナが他のコンテナとネゴシエーションしてリーダーになったら、ローカルホストのHTTP APIにbecomeLeader、renewLeadershipなどのクエリを投げます。
アプリケーションはただそれらのエンドポイントを実装しさえすればいいのです。&lt;/p&gt;

&lt;p&gt;このコンテナはアプリケーションにも言語に依存しないので自由に使い回すことが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;ワークキューパターン&#34;&gt;ワークキューパターン&lt;/h2&gt;

&lt;p&gt;もう1つのよくある分散システムでのタスクは、ワークキューによる分散実行です。
いくつかワークキューの実装はありますが、やはりそれらは特定の言語に依存しています。&lt;/p&gt;

&lt;p&gt;そこで仕事の分配のコンテナ、そして、仕事実行のフレームワークとなるコンテナを用意してあげましょう。&lt;/p&gt;

&lt;p&gt;フレームワークのコンテナは分配コンテナから仕事(ファイルなど)を受け取って、ユーザの書いた実行コンテナに処理を移譲します。そしてフレームワークコンテナが実行コンテナの出力した結果をまた分配コンテナに戻します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
[Request]       +---[フレームワークコンテナ]=[実行コンテナ(ユーザ)]
   |            |
[分配コンテナ] --+
   |            |
   |            +---[フレームワークコンテナ]=[実行コンテナ(ユーザ)]
   |
[ワークキューの保存など]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分散協調の部分をフレームワークコンテナがやってくれるのでユーザが書く実行コンテナは非常にシンプルになります。&lt;/p&gt;

&lt;h2 id=&#34;分配-集約パターン&#34;&gt;分配/集約パターン&lt;/h2&gt;

&lt;p&gt;このパターンは、クライアントが1つの巨大なタスクをルートコンテナに投げ、ルートコンテナが子コンテナ達に分割したタスクを移譲します。そして子コンテナ達の結果を纏めてクライアントに返します。&lt;/p&gt;

&lt;p&gt;MapReduceと同じように、タスクを実行するリーフコンテナと、リーフコンテナの結果を纏めるマージコンテナを用意する必要があります。&lt;/p&gt;

&lt;p&gt;コンテナは特定のインターフェースさえ実装していればいいのでリファクタが(オブジェクト指向の時と同じように)容易です。&lt;/p&gt;

&lt;p&gt;また、子コンテナにルートコンテナと同じようなscatter/gather機能を持ったコンテナを使うことで、任意の深さにまでタスクツリーを作ることが出来ます。
これは例えば処理中のリソース使用量が多いときに部分的にタスクを実行してマージを繰替えすことで必要となる最大リソースを減らす、などに使えるでしょう（他にももっとあるかもしれませんがパッとは思いつきませんでした）。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;コンテナのデザインパターを紹介しました。フレームワークコンテナなど、興味深いパターンもあって興味深いですね。&lt;/p&gt;

&lt;p&gt;まだまだパターンはありえると思うのでこの分野（？）、もう少し広まると良いですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Socket on SML#</title>
      <link>/slide/Socket_on_SML_/</link>
      <pubDate>Sat, 02 Jul 2016 15:25:24 +0900</pubDate>
      
      <guid>/slide/Socket_on_SML_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Socket on SML&amp;#x23;
----------------------
[ML勉強会](http://connpass.com/event/32752/) 2016-07-09

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# HTTP on SML&amp;#x23;?
-------------

* SML#にJSONサポートが入った
  + REST API簡単に叩けるのでは？
* SML#にFully Concurrent GCが入った
  + HTTPサーバ書くとレイテンシ抑えられて嬉しいのでは？
  * スレッドも使えるしスループットも高い筈
* SML#でHTTPの機運
* しかしHTTPサポートはないので自前実装するしかない

===
# Socket on SML&amp;#x23;?
------------------

* HTTPサポートに必要
* Basisにはある (Optional)
  + SML#のBasisはサポートしてない
* FFIあるしユーザランドで実装するか
* [KeenS/SmlSharpSocketSupport](https://github.com/KeenS/SmlSharpSocketSupport)

===
# TCP/IP、ソケットなど
---------------------------

* ソケットアドレス - 自分、相手の居場所。これがないと通信出来ない
  + 複数のアドレスファミリ(AF)がある
  + IP v4, IP v6, UNIXドメインなど。
* ソケット - 通信の仕組み。プログラムからはfdとして見える。
  + AFやtype(stream/diagram)の属性を持つ
* INet - インターネットドメインソケット
  + TCPとUDP
  + IP v4/v6アドレスで通信

===
# 主要なstructure
-----------------

* Socket
* NetHostDB
* INetSock
* (UnixSock)

===
# [NetHostDB](http://sml-family.org/Basis/net-host-db.html#SIG:NET_HOST_DB)
-----------

* ドメイン名からIPアドレスを調べたり逆をやったり
* Cの古い(現在では非推奨な)APIに合わせた設計
  + IPがv4/v6が混じることを考慮してない
  + 非推奨どころか脆弱性もあったり CF [glibc の脆弱性 CVE-2015-0235（通称：GHOST）についてまとめてみた - piyolog](http://d.hatena.ne.jp/Kango/20150128/1422409960)
* 新しいAPIで実装するのが面倒

===
# [Socket](http://sml-family.org/Basis/socket.html#SIG:SOCKET.accept:VAL:SPEC)
---------

* まあまあでかいけどsend/receive関数の変種が一杯あるだけ
* ドメインに依らないソケット操作
* typeには依る
  + stream socketとdgramソケットで送受信関数が別

===
# Socket.AF
------------

* ソケットのアドレスファミリ関連
* 仕様では具体的なファミリを定義しない

===
# Socket.SOCK
-------------

* ソケットにも種類がある
  + stream/diagram
* さらにstreamにはactive/passiveがある
* それらの型。

===
# [INetSock](http://sml-family.org/Basis/inet-sock.html#INetSock:STR:SPEC)
--------------

* IP - TCP/UDPのソケットを作る/操作するやつ。
* ここの関数はインターネットドメインソケットしか受け付けない

===
# Socketについて整理
----------------

* sockにはtypeとafの属性がある
* afは色々ある
* typeはstreamとdgramがある
* streamにはさらにactiveとpassiveがある
* 特定のaf, 特定のtypeしか受け付けない関数がある

===
# Socketについて整理
----------------

```
   (AF_UN)
        v
     [unix sock]...
         |                       (Active)
[socket]-+           [TCP(stream)]-+
         |             |         (Passive)
     [inet/inet6 sock]-+
        ^              |
   (AF_INET/INET6)   [UDP(dgram)]
```

===
&lt;span style=&#34;font-size:500%;&#34;&gt;幽霊型&lt;/sapn&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# Socketの幽霊型
---------------

```sml
type (&#39;af,&#39;sock_type) sock
type &#39;af sock_addr
type dgram
type &#39;mode stream
type passive
type active
```
===
# サーバのSocket操作(stream)
---------------------------

* INetSock(UnixSock)でソケットを作る(af, sock typeの選択, プロセス側の準備)
* bindでソケットをsock_addrにバインドする(アドレスの割り当て)
* listenでソケットの特定のポートを開ける(TCPの開始)
  + passive streamしか受け付けない
* acceptでクライアントからの入力を受け付ける(接続)
  + passive streamしか受け付けない
  + passive streamがactive streamになる
  + 一度acceptしたsockはlisten/accept出来ない
===
# データの送受信
---------------

* `send` / `recv`
* それぞれArraySlice/VectorSliceの制御フラグ有り/無しがある
  + 実装がまあまあ面倒

===
# SML# でのバインディング
------------------------

* sock - fd = int
* sock_addr - AFによってサイズが違う。ヤバい。
 + 任意のsock_addrを格納出来るsockaddr_storageを使う
 + Solarisだとsockaddr_unを格納出来ないらしい（任意のaddrを格納出来るとは）
   - SML#はSolarisでは動かないので問題ない。
* AF_* とか - Cではただのint。SML#は関数しかインポート出来ない。
 + C側で定数関数でラップしてSML#で呼び出した値を束縛
* その他 - straitforward

===
# 非同期IO

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 非同期IO
----------

* HTTPサーバは複数のクライアントとのコネクションを持つ
* それらのコネクションを要領良く扱わないといけない
* 相手の処理速度や通信速度によって即座にデータを読み書き出来ない時がある
  + 勿論クライアント毎に状況が異なる
* 読み書き出来ない時にやったらブロック(CPU時間の無駄遣い)する
* 「読み書き出来るならする」/「読み書き出来るクライアントを選ぶ」APIが必要

===
# 非同期API
----------

* select - 複数のクライアントを登録して、読み書き出来るやつを選ぶ
* \*NB - 読み書き出来るならやって、出来ないならブロックせずにリターンする
* poll - selectと同じような（ちょっと速い）API。SocketではなくIOにある。
  + pollがあるのに何故Socketにselectがあるの…。

===
===
# 非同期APIのFFI
----------------

* select - Cに対応する関数が。構造体の変換でメモリアロケーションが起きて遅い
* \*NB - O_NONBLOCKを付けたsend/recv。
* poll - SML#にある

===
# 非同期HTTPサーバ概略
---------------------

```sml
bind(sock, addr);
listen(sock, port);
create_thread(n, fn i =&gt; let
  val clientList = makeClientList()
  fun loop () = let
    val clientList =
      Option.map (acceptNB(sock))
      (fn client =&gt; addReadClient clientList client)
      handle SysErr =&gt; ...
    val {rds, wds, exs} = select (makeSelectList clientList)
  in
    recvAndParseHTTPThenCallHandler clientList rds;
    sendResponse clientList wds;
    loop ()
  end
end)
```

===
# Cバインディングの憂鬱

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# importとメモリ割り当て
-----------------------

* SML#にはポインタかワードサイズ以下の値しか渡せない
  + stringとかはポインタからインポートする関数がある
  + インポートしたものはSML#のヒープに **コピーされる**
* cでポインタを返すにはmallocが必要
* **すぐコピーされてfreeされるもののためにmalloc??**
* SML#からコールバックを渡してCのスタックの変数をインポート
* CF https://github.com/KeenS/SmlSharpSocketSupport/blob/master/lib/net_host_db.c#L74

===
# メモリ管理
------------

* SML#にインポート出来る型は限られている
  + array, string
* 他の型はポインタのまま扱う。
* ポインタはGCされない
* `sockaddr` は仕様的にファイナライザを持っていない
  + 現状 **メモリリークする**
* SML#側でどうにかしてもらわないとダメ？
  + パンドラの壷(sml_alloc)使う？

===
# 型隠蔽
-------

* sockは本来はioDescに変換出来ないといけない
 + SML#でioDescはsockと同じくint
* しかし型隠蔽のせいでintをioDescに変換出来ない
* 手詰まり

===
# まとめ
--------

* socketとかその辺を解説したよ
* SML#向けにSocket関連Basisのバインディング作ってるよ
* BasisのAPI使うと非同期HTTPサーバ作れるよ
* SML#のFFIはやっぱりつらいよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustの所有権/ミュータビリティの分割</title>
      <link>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</link>
      <pubDate>Sun, 19 Jun 2016 20:42:14 +0900</pubDate>
      
      <guid>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</guid>
      <description>

&lt;p&gt;κeenです。昔所有権/ミュータビリティを分割したくなったけどぱっと方法が思いつかなくて困ったことがあるので今更ながら備忘録として残しておきます。&lt;/p&gt;

&lt;h1 id=&#34;ミュータビリティ&#34;&gt;ミュータビリティ&lt;/h1&gt;

&lt;p&gt;例えば、HTTPパーサを作ろうとしてるとしましょう。
受け取ったバイト列のバッファをパースしてヘッダやらボディやらのサブスライスを返します。この時、返り値のサブスライスはユーザへの自由を与えるために &lt;code&gt;mut&lt;/code&gt; にしたいですよね。&lt;/p&gt;

&lt;p&gt;そう思ってこういうコードを書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io;

fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...
    Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mutability_split.rs:4:31: 4:34 error: cannot borrow `*buf` as mutable more than once at a time [E0499]
mutability_split.rs:4     Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通にやろうとすると
1つ1つミュータブルなサブスライスを作ることになり、2つ目以降でborrow checkに引っ掛かってしまいます。2つのバッファがオーバーラップしてなくても。難儀ですね。コピーするくらいしかないのでしょうか。いいえ。rustはちゃんと助けになるAPIを用意してくれています。&lt;/p&gt;

&lt;h2 id=&#34;split-at-mut-https-doc-rust-lang-org-std-primitive-slice-html-method-split-at-mut&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut&#34;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn split_at_mut(&amp;amp;mut self, mid: usize) -&amp;gt; (&amp;amp;mut [T], &amp;amp;mut [T])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スライスを2つに分割してくれます。重要なのが、ミュータビリティも分割してくれるところです。返り値の2つ共に &lt;code&gt;mut&lt;/code&gt; がついています。ということで、次のように実装出来ます。（実行してないので結果が正しいかは確認してませんが）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...

    let (h, b) = buf.split_at_mut(bstart);
    let h = {
        let (_, h) = h.split_at_mut(hstart);
        let (_, h) = h.split_at_mut(hend - hstart);
        h
    };

    let (_, b) = b.split_at_mut(bend - bstart);

    Ok((h, b))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;所有権&#34;&gt;所有権&lt;/h1&gt;

&lt;p&gt;似たような話で、構造体の所有権というか、貸与権(?)を分割したい時もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonDB {
    name: String,
    age: usize,
    address: String,
}


fn use_immutable(s: &amp;amp;str) {
    // empty
}

fn use_mutable(s: &amp;amp;mut str) {
    // empty
}



fn from_db(person: PersonDB) {
    let name = &amp;amp;person.name;
    let mut address = &amp;amp;mut person.address;
    use_immutable(name);
    use_mutable(address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イミュータブルとミュータブル両方の借用があるのでエラーになってしまいます。実際は別のフィールドなので問題は起きないのですが、コンパイラに怒られます。理不尽ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mutability_split.rs:36:28: 36:42 error: cannot borrow immutable field `person.address` as mutable
mutability_split.rs:36     let mut address = &amp;amp;mut person.address;
                                                  ^~~~~~~~~~~~~~

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そういう時は、パターンマッチによる分配束縛でクリア出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn from_db(person: PersonDB) {
    let PersonDB {name, mut address, ..} = person;
    use_immutable(&amp;amp;name);
    use_mutable(&amp;amp;mut address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Rustの所有権やミュータブルな参照など、1つしか存在出来ないとされるものが分割出来ることを示しました。
地味に悩む所なので誰かの助けになれば幸いです。&lt;/p&gt;

&lt;p&gt;蛇足を足すと、本当は所有権の分割についても書く予定でしたがエラーになる筈のコードがあっさりコンパイルを通ってしまったのでナシになりました。コンパイラも進化してますね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>multirustが非推奨になったようなのでrustupに移行する</title>
      <link>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</link>
      <pubDate>Sun, 12 Jun 2016 15:23:06 +0900</pubDate>
      
      <guid>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</guid>
      <description>

&lt;p&gt;κeenです。どうやらもうそろそろRustのツールチェーン管理はmultirustじゃなくてrustupを使った方が良さそうなので移行しようと思います。&lt;/p&gt;

&lt;p&gt;きっかけはmultirustにそういうコミットがされたから。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;もうmultirustじゃなくてrustup使え、と。&lt;br&gt;&lt;br&gt;Update README.md · brson/multirust@84c3459&lt;a href=&#34;https://t.co/ySeRB50x5C&#34;&gt;https://t.co/ySeRB50x5C&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/741077158651514882&#34;&gt;2016年6月10日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;因みにrustupは&lt;a href=&#34;https://github.com/rust-lang/rustup.sh&#34;&gt;rust-lang/rustup.sh: The rustup.sh script for installing Rust from release channels&lt;/a&gt;ではなく&lt;a href=&#34;https://github.com/rust-lang-nursery/rustup.rs&#34;&gt;rust-lang-nursery/rustup.rs: The Rust toolchain installer&lt;/a&gt;の方です。インストールガイドなどはこちらから。&lt;a href=&#34;https://www.rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なんかベータ版のようですが推奨していいんですかね…。&lt;/p&gt;

&lt;p&gt;とりあえずmultirustを入れたままコマンドを叩いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer
warning: it looks like you have an existing installation of multirust
warning: rustup cannot be installed alongside multirust
warning: run `/usr/local/lib/rustlib/uninstall.sh` as root and delete `/home/kim/.multirust/version` before installing rustup
error: cannot install while multirust is installed
rustup: command failed: /tmp/tmp.9kjQj9WT5O/rustup-init

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふーむ。アンインストールしろ、と。一応指示された通りmultirust自体はアンインストールせずにversionだけを削除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/local/lib/rustlib/uninstall.sh
install: uninstalling component &#39;multirust&#39;

    multirust is uninstalled.
$ rm -rf ~/.multirust/version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう一度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;選択肢が出ました。とりあえず1を選択します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: toolchain &#39;stable&#39; is not installed
info: caused by: not a directory: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu&#39;
rustup: command failed: /tmp/tmp.nugK4VN4p8/rustup-init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;えー。ちょっと…。仕方ないのでシンボリックリンクを貼って騙してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls ~/.multirust/toolchains/
beta  nightly  stable
$ ln -s ~/.multirust/toolchains/{stable,stable-x86_64-unknown-linux-gnu}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3度目の正直なるか&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
1

info: updating existing rustup installation


Rust is installed now. Great!

To get started you need Cargo&#39;s bin directory in your PATH environment variable.
Next time you log in this will be done automatically.

To configure your current shell run source $HOME/.cargo/env.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストール出来たよう。しかしセットアップは &lt;code&gt;~/.profile&lt;/code&gt; に書かれたようなので &lt;code&gt;.zshrc&lt;/code&gt; は自分で更新します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/zshrc b/zshrc
index 0178873..589c6a5 100644
--- a/zshrc
+++ b/zshrc
@@ -213,7 +213,7 @@ export PATSHOME=~/compile/ATS2-Postiats-$ATS_VERSION/
 export PATH=$PATSHOME/bin:$PATH
 export PATSHOMERELOC=~/compile/ATS2-Postiats-contrib-$ATS_VERSION
 
-export PATH=$PATH:~/.multirust/toolchains/stable/cargo/bin
+export PATH=&amp;quot;$HOME/.cargo/bin:$PATH&amp;quot;
 
 # OPAM configuration
 . /home/kim/.opam/opam-init/init.sh &amp;gt; /dev/null 2&amp;gt; /dev/null || true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup 0.1.12 (c6e430a 2016-05-12)
The Rust toolchain installer

USAGE:
    rustup [FLAGS] [SUBCOMMAND]

FLAGS:
    -v, --verbose    Enable verbose output
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    show         Show the active and installed toolchains
    update       Update Rust toolchains
    default      Set the default toolchain
    toolchain    Modify or query the installed toolchains
    target       Modify a toolchain&#39;s supported targets
    override     Modify directory toolchain overrides
    run          Run a command with an environment configured for a given toolchain
    which        Display which binary will be run for a given command
    doc          Open the documentation for the current toolchain.
    self         Modify the rustup installation
    telemetry    rustup telemetry commands
    help         Prints this message or the help of the given subcommand(s)

rustup installs The Rust Programming Language from the official
release channels, enabling you to easily switch between stable, beta,
and nightly compilers and keep them updated. It makes cross-compiling
simpler with binary builds of the standard library for common platforms.

If you are new to Rust consider running `rustup doc --book`
to learn Rust.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;multirustを使っていたら馴染めそうですね。&lt;/p&gt;

&lt;p&gt;一応どこにインストールされたのか確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which rustc
/home/kim/.cargo/bin/rustc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふむふむ。ちょいとアップデートしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.1 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.0 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   2.3 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %) 953.6 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.2 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.5 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 44.8 MiB /  44.8 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 57.9 MiB /  57.9 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.0 MiB /   7.0 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.3 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 46.5 MiB /  46.5 MiB (100 %) 924.8 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 59.0 MiB /  59.0 MiB (100 %)   2.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.3 MiB /   7.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   3.2 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: checking for self-updates
info: rustup is up to date

                           stable update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
  stable-x86_64-unknown-linux-gnu update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                                 beta installed - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                              nightly installed - rustc 1.11.0-nightly (0554abac6 2016-06-10)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、なんかコケてる…。シンボリックリンクが悪さしたかな…。しかし試しに手元のプロダクトをコンパイルしてみたら通ったので使えているよう。&lt;/p&gt;

&lt;p&gt;さて、クロスコンパイルの方はどうでしょうか。以前Raspberry Pi向けにクロスコンパイルしました &lt;a href=&#34;http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/&#34;&gt;RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog&lt;/a&gt;。これは動くでしょうか。&lt;/p&gt;

&lt;p&gt;とりあえずインストール可能なターゲットを確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………。無理矢理addしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target add nightly-arm-unknown-linux-gnueabihf
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………………………………。&lt;/p&gt;

&lt;p&gt;なんか変ですね。&lt;/p&gt;

&lt;p&gt;一旦&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm ~/.multirust/toolchains/stable-x86_64-unknown-linux-gnu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;してもう一度 &lt;code&gt;rustup update&lt;/code&gt; します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.6 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.7 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   5.0 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: checking for self-updates
info: rustup is up to date

                            stable installed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                              beta unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
     beta-x86_64-unknown-linux-gnu unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                           nightly unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
  nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、今回は上手くいった。やっぱりシンボリックリンクが悪かったよう。リトライ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target add --toolchain nightly arm-unknown-linux-gnueabihf
info: downloading component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
 62.6 MiB /  62.6 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: installing component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んー、ちゃんとnightlyが入ったのか分からない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup show
installed toolchains
--------------------

stable
stable-x86_64-unknown-linux-gnu (default)
beta
beta-x86_64-unknown-linux-gnu
nightly
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.9.0 (e4e8b6668 2016-05-18)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし件のARM向けプロジェクトのクロスコンパイルは出来たよう。&lt;/p&gt;

&lt;p&gt;もう一度listを見る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;arm-unknown-linux-gnueabihf (installed)&lt;/code&gt; とあるのでインストール出来ているよう。しかし本当にnightlyなのか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup target list --toolchain stable
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target list --toolchain nightly
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら本当にnightlyのよう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;色々あたふたとしましたがrustupをインストールして使ってみました。multirustを使っているとインストールあたりでやや難はありそうですがそれ以降は普通に使えそうです。&lt;/p&gt;

&lt;p&gt;皆様もお試しあれ。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>