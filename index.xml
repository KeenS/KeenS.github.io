<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 29 Dec 2016 11:52:55 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>気付いたらRustの環境構築がかなり楽になってた</title>
      <link>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</link>
      <pubDate>Thu, 29 Dec 2016 11:52:55 +0900</pubDate>
      
      <guid>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</guid>
      <description>&lt;p&gt;κeenです。ここのところRustの開発ツール回りでリリースが続いてセットアップが楽になってるようだったので最新の情報をお届けします。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;とりあえず私は既存の環境があるので一旦全て破棄してから再度セットアップしてみます。&lt;/p&gt;

&lt;h1 id=&#34;rustのインストール&#34;&gt;Rustのインストール&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;がリリースされたので以下で一発です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;source $HOME/.cargo/env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をシェルのrcファイルに書き加えたらOKです。
今のシェルにも反映するには同じく上記のコマンドを打ちます。&lt;/p&gt;

&lt;h1 id=&#34;周辺ツールのインストール&#34;&gt;周辺ツールのインストール&lt;/h1&gt;

&lt;p&gt;cargoがあるので楽ですね&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# コードフォーマッタ
$ cargo install rustfmt
# 補完、定義ジャンプなど
$ cargo install racer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあ時間がかかります。&lt;/p&gt;

&lt;h1 id=&#34;エディタ-emacs-の設定&#34;&gt;エディタ(Emacs)の設定&lt;/h1&gt;

&lt;p&gt;私がEmacsを使ってるのでEmacsの設定を。&lt;/p&gt;

&lt;p&gt;まず、必要パッケージをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;rustfmt&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。rust-modeにrustfmtの機能が含まれているようでした。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; rustfmtを emacsから使うの rust-modeが現在サポートしているので, rustfmt.elパッケージは不要ですね. rust-format-on-saveが non-nilなら保存時に rustfmtが実行されます.&lt;/p&gt;&amp;mdash; Syohei YOSHIDA (@syohex) &lt;a href=&#34;https://twitter.com/syohex/status/814354653672415232&#34;&gt;2016年12月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;;;; racerやrustfmt、コンパイラにパスを通す
(add-to-list &#39;exec-path (expand-file-name &amp;quot;~/.cargo/bin/&amp;quot;))
;;; rust-modeでrust-format-on-saveをtにすると自動でrustfmtが走る
(eval-after-load &amp;quot;rust-mode&amp;quot;
  &#39;(setq-default rust-format-on-save t))
;;; rustのファイルを編集するときにracerとflycheckを起動する
(add-hook &#39;rust-mode-hook (lambda ()
                            (racer-mode)
                            (flycheck-rust-setup)))
;;; racerのeldocサポートを使う
(add-hook &#39;racer-mode-hook #&#39;eldoc-mode)
;;; racerの補完サポートを使う
(add-hook &#39;racer-mode-hook (lambda ()
                             (company-mode)
                             ;;; この辺の設定はお好みで
                             (set (make-variable-buffer-local &#39;company-idle-delay) 0.1)
                             (set (make-variable-buffer-local &#39;company-minimum-prefix-length) 0)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とりあえずこれでセットアップ完了です。racerの最新版でrustのソースコードの位置を設定しなくてよくなったので簡潔になりましたね。&lt;/p&gt;

&lt;p&gt;racer-modeは補完をしてくれる他、&lt;code&gt;M-.&lt;/code&gt;で定義元ジャンプ、&lt;code&gt;M-,&lt;/code&gt;でジャンプ元に戻れます。
あとは&lt;code&gt;M-x racer-describe&lt;/code&gt;でポイント位置にあるシンボルのrustdocを(Emacs内で)表示してくれます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;おお! racerでEmacs内でrustdocレンダ出来るようになってる！便利！！&lt;br&gt;&lt;br&gt;Rustdoc Meets The Self-Documenting Editor&lt;a href=&#34;https://t.co/gDEHl2fSfx&#34;&gt;https://t.co/gDEHl2fSfx&lt;/a&gt; &lt;a href=&#34;https://t.co/sdrX9OoEnr&#34;&gt;pic.twitter.com/sdrX9OoEnr&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/770796719185408000&#34;&gt;2016年8月31日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;その他は放っておくと勝手に機能してくれるので考えることが少なくていいですね。&lt;/p&gt;

&lt;h1 id=&#34;その他便利ツール&#34;&gt;その他便利ツール&lt;/h1&gt;

&lt;p&gt;セットアップがあっけなかったのでついでに入れておくと便利なツールをいくつか紹介します。&lt;/p&gt;

&lt;h2 id=&#34;cargo-edit&#34;&gt;cargo-edit&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-edit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「libcクレートの最新版に依存したい」なんて時に一々libcの最新版を確認するのは面倒ですよね。そんなときにcargo-editがあれば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo add libc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で &lt;code&gt;Cargo.toml&lt;/code&gt; に追記してくれます。&lt;/p&gt;

&lt;h2 id=&#34;cargo-script&#34;&gt;cargo-script&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとした実験スクリプトとかをコンパイル→実行のステップを踏まずにいきなり実行出来ます。
&lt;code&gt;cargo script FILE&lt;/code&gt;でファイルを実行出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; hello.rs
fn main() {
    println!(&amp;quot;hello, script&amp;quot;)
}
EOF
$ cargo script hello.rs
   Compiling hello v0.1.0 (file:///home/kim/.cargo/.cargo/script-cache/file-hello-f6b1735a519bb659)
    Finished release [optimized] target(s) in 0.15 secs
hello, script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というふうに使います。&lt;/p&gt;

&lt;p&gt;シェルのrcファイルで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;alias rust=&#39;cargo-script&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としておくと吉。&lt;/p&gt;

&lt;h2 id=&#34;cargo-update&#34;&gt;cargo-update&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までインストールしたバイナリのアップデートを出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install-update -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのライフタイムを使ったスコープ解析</title>
      <link>/blog/2016/12/24/rustnoraifutaimuwotsukattasuko_pukaiseki</link>
      <pubDate>Sat, 24 Dec 2016 22:51:46 +0900</pubDate>
      
      <guid>/blog/2016/12/24/rustnoraifutaimuwotsukattasuko_pukaiseki</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;の25日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。大トリに小ネタで申し訳ないのですが最近書いたコードでちょっと便利だなと思ったテクニックを紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;次のような言語のインタプリタを作ることを考えます。意味論はエスパーして下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 1
y = 2
println(&amp;quot;x = &amp;quot;, x)
println(&amp;quot;y = &amp;quot;, y)

println(&amp;quot;--&amp;quot;)

{
    x = 3
    println(&amp;quot;x = &amp;quot;, x)
    println(&amp;quot;y = &amp;quot;, y)
}

println(&amp;quot;--&amp;quot;)

println(&amp;quot;x = &amp;quot;, x)
println(&amp;quot;y = &amp;quot;, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この実行結果は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になりますね。このインタプリタをRustで作りましょう。&lt;/p&gt;

&lt;h1 id=&#34;初期実装&#34;&gt;初期実装&lt;/h1&gt;

&lt;p&gt;雛形はこんなもんでしょうか。後でリファレンスが出てきてややこしくなるので値は全て所有権を貰っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Debug, Clone)]
struct AST(Vec&amp;lt;Stmt&amp;gt;);

#[derive(Debug, Clone)]
enum Stmt {
    Subst(String, Expr),
    Print(Vec&amp;lt;Expr&amp;gt;),
    Block(Vec&amp;lt;Stmt&amp;gt;),
}


#[derive(Debug, Clone)]
enum Expr {
    Str(String),
    Num(isize),
    Var(String),
}


struct Interpreter {
    // これを実装する
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{}
    }

    fn run(&amp;amp;mut self, ast: AST) {
        for stmt in ast.0 {
            self.run_stmt(stmt);
        }
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        // これを実装する
    }
}

fn main() {
    let ast = {
        use Stmt::*;
        use Expr::*;
        AST(
            vec![
                Subst(&amp;quot;x&amp;quot;.to_string(), Num(1)),
                Subst(&amp;quot;y&amp;quot;.to_string(), Num(2)),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Block(vec![
                    Subst(&amp;quot;x&amp;quot;.to_string(), Num(3)),
                    Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                    Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                ]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
            ]
        )
    };
    let mut interpreter = Interpreter::new();

    interpreter.run(ast);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(コンストラクタ関数作っときゃよかったかも)&lt;/p&gt;

&lt;p&gt;今回の本質ではないのでパーサは用意してません。&lt;/p&gt;

&lt;p&gt;さて、とりあえずのところ変数の管理のためにシンボルテーブルが必要です。実装しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;//...

use std::collections::HashMap;
struct Interpreter {
    symbol_table: HashMap&amp;lt;String, Expr&amp;gt;,
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{
            symbol_table: HashMap::new(),
        }
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        self.symbol_table.insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        self.symbol_table
            .get(name)
            .expect(&amp;quot;reference to unknown variable&amp;quot;)
            .clone()
    }

  //...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡略化のためにcloneやpanicしてますがご愛嬌。&lt;/p&gt;

&lt;p&gt;これがあれば&lt;code&gt;run_stmt&lt;/code&gt;のそれっぽい実装は出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            Subst(name, expr) =&amp;gt; {
                let expr = self.eval(expr);
                self.add_to_scope(name, expr);
            },
            Print(exprs) =&amp;gt; {
                for expr in exprs {
                    self.print_expr(expr);
                }
                println!(&amp;quot;&amp;quot;);
            },
            Block(stmts) =&amp;gt; {
                for stmt in stmts {
                    self.run_stmt(stmt);
                }
            },
        }

    }

    fn eval(&amp;amp;self, expr: Expr) -&amp;gt; Expr {
        use Expr::*;
        match expr {
            Var(v) =&amp;gt; self.find_scope(&amp;amp;v),
            e @ Str(_) |
            e @ Num(_) =&amp;gt; e
        }
    }

    fn print_expr(&amp;amp;self, expr: Expr) {
        use Expr::*;
        match self.eval(expr) {
            Str(ref s) =&amp;gt; print!(&amp;quot;{}&amp;quot;, s),
            Num(ref n) =&amp;gt; print!(&amp;quot;{}&amp;quot;, n),
            Var(_) =&amp;gt; panic!(&amp;quot;reference to unknown variable&amp;quot;) ,
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、これを走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 3
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコープを実装していないので最後の&lt;code&gt;x&lt;/code&gt;が3になっていますね。スコープを実装しましょう。&lt;/p&gt;

&lt;p&gt;スコープを実装するには簡単にはハッシュテーブルを複数持てば良さそうです。
3段にネストしたスコープなら3つのハッシュテーブルを持ちます。
そしてスコープを抜けた時にそのスコープに対応するハッシュテーブルを消せば（忘れれば）良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Interpreter {
   // スコープに対応したテーブル達。
   symbol_tables: Vec&amp;lt;HashMap&amp;lt;String, Expr&amp;gt;&amp;gt;,
   // 今どのスコープを指しているか。
   // スコープを抜けてもベクトルは縮まないのでこれが必要。
   pos: usize,
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        // 新しいフィールドの初期化
        Interpreter{
            symbol_tables: Vec::new(),
            // ややこしくなるが、0で初期化しているのでpos-1番目のハッシュマップが現スコープのテーブルになる
            pos: 0,
        }
    }

    // スコープに入る処理。
    fn in_scope(&amp;amp;mut self) {
        let pos = self.pos;
        // スコープから抜けてもハッシュマップは消えないので
        // 入る → 出る → 入るをしたときに既にテーブルがある場合が出てくる。
        // 必要なテーブルが既にある場合とない場合で条件分岐
        if self.symbol_tables.len() &amp;lt;= pos {
            self.symbol_tables.push(HashMap::new())
        } else {
            // 既にテーブルがある場合は古い情報を消す
            self.symbol_tables[pos - 1].clear()
        }
        // ポジションは忘れずインクリメント
        self.pos += 1;
    }

    // スコープから抜ける処理
    fn out_scope(&amp;amp;mut self) {
        // スコープから抜けるのはデクリメントのみでOK
        self.pos -= 1;
    }

    pub fn run(&amp;amp;mut self, ast: AST) {
        // in_scope が増えた
        self.in_scope();
        for stmt in ast.0 {
            self.run_stmt(stmt);
        }
        // out_scope が増えた
        self.out_scope();
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        // 現在のスコープに変数を入れる
        let pos = self.pos - 1;
        self.symbol_tables[pos].insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        let pos = self.pos;
        // 一番内側(現在)のスコープから外側のスコープの順に調べていく。
        // `[0..pos]` や `rev()` に注意。
        for table in self.symbol_tables[0..pos].iter().rev() {
            if let Some(e) = table.get(name) {
                return e.clone()
            }
        }
        // どこにもなければ未定義変数
        panic!(&amp;quot;reference to unknown variable&amp;quot;)
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            // ..
            Block(stmts) =&amp;gt; {
                // in_scope が増えた
                self.in_scope();
                for stmt in stmts {
                    self.run_stmt(stmt);
                }
                // out_scope が増えた
                self.out_scope();
            },
        }

    }

    // ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで走らせてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。動きました。&lt;/p&gt;

&lt;h1 id=&#34;scope-の導入&#34;&gt;&lt;code&gt;Scope&lt;/code&gt; の導入&lt;/h1&gt;

&lt;p&gt;さて、上のコードでは&lt;code&gt;in_scope&lt;/code&gt;と&lt;code&gt;out_scope&lt;/code&gt;が対で現れました。というか現れないといけません。
でもプログラミングエラーで&lt;code&gt;out_scope&lt;/code&gt;を忘れるなんてことはよくある話です（現に私はこのサンプルを書いてて間違えかけました）。これをRustのライフタイムの仕組みに乗っけて自動で解決しようというのが今回のお話。&lt;/p&gt;

&lt;p&gt;手法は簡単で、とりあえず&lt;code&gt;Scope&lt;/code&gt;という型を用意します。そして&lt;code&gt;new&lt;/code&gt;する時に&lt;code&gt;in_scope&lt;/code&gt;を呼んであげて、&lt;code&gt;drop&lt;/code&gt;する時に&lt;code&gt;out_scope&lt;/code&gt;を呼んであげます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::Drop;
struct Scope&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a mut Interpreter);

impl &amp;lt;&#39;a&amp;gt;Scope&amp;lt;&#39;a&amp;gt; {
    fn new(inpr: &amp;amp;&#39;a mut Interpreter) -&amp;gt; Self {
        inpr.in_scope();
        Scope(inpr)
    }
}

impl &amp;lt;&#39;a&amp;gt;Drop for Scope&amp;lt;&#39;a&amp;gt; {
    fn drop(&amp;amp;mut self) {
        self.0.out_scope()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この&lt;code&gt;&amp;amp;mut Interpreter&lt;/code&gt;で参照しているというのが丁度良くて、Scopeの分岐というのを防ぐことが出来ます。こういうやつですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let scope1 = Scope::new(&amp;amp;mut intr);
let scope2 = Scope::new(&amp;amp;mut intr); // error: 既に&amp;amp;mut されている変数は&amp;amp;mut出来ない
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、これを使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    pub fn run(&amp;amp;mut self, ast: AST) {
        // in_scopeをScope::new()に置き換えた
        let scope = Scope::new(self);
        for stmt in ast.0 {
            // scopeに渡してしまったのでselfはsope.0で参照する必要がある
            scope.0.run_stmt(stmt);
        }
        // out_scopeは自動で呼ばれる
    }

    // run_stmtのBlockも同様に書き換える
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きました。でも、あまり&lt;code&gt;scope.0&lt;/code&gt;なんて使いたくないですよね。出来れば透過的に扱いたい。
そんなときのために&lt;code&gt;Deref&lt;/code&gt; と &lt;code&gt;DerefMut&lt;/code&gt; です。Rustは型が合わなければ自動で&lt;code&gt;deref&lt;/code&gt;を呼んでくれます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Deref&lt;/code&gt; と &lt;code&gt;DerefMut&lt;/code&gt; を実装しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::{Deref, DerefMut};
impl &amp;lt;&#39;a&amp;gt; Deref for Scope&amp;lt;&#39;a&amp;gt; {
    type Target = Interpreter;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Interpreter {
        self.0
    }
}

impl &amp;lt;&#39;a&amp;gt; DerefMut for Scope&amp;lt;&#39;a&amp;gt; {
    fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Interpreter {
        self.0
    }
}

impl Interpreter {
    // ..

    pub fn run(&amp;amp;mut self, ast: AST) {
        // deref_mutするために mutをつける
        let mut scope = Scope::new(self);
        for stmt in ast.0 {
            // scope.0しなくてもInterpreterのメソッドが呼べる
            scope.run_stmt(stmt);
        }
    }

   // ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;生成と消滅が対になるものはRustのオブジェクトで管理出来るよ&lt;/li&gt;
&lt;li&gt;シンプルなラッパー型は&lt;code&gt;Deref&lt;/code&gt;や&lt;code&gt;DerefMut&lt;/code&gt;を実装しておくと便利だよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/drop.html&#34;&gt;Drop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/deref-coercions.html&#34;&gt;&lt;code&gt;Deref&lt;/code&gt; による型強制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;付録a&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;最終的なソースコード全文を掲載します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Debug, Clone)]
struct AST(Vec&amp;lt;Stmt&amp;gt;);

#[derive(Debug, Clone)]
enum Stmt {
    Subst(String, Expr),
    Print(Vec&amp;lt;Expr&amp;gt;),
    Block(Vec&amp;lt;Stmt&amp;gt;),
}


#[derive(Debug, Clone)]
enum Expr {
    Str(String),
    Num(isize),
    Var(String),
}


use std::collections::HashMap;
struct Interpreter {
   symbol_tables: Vec&amp;lt;HashMap&amp;lt;String, Expr&amp;gt;&amp;gt;,
   pos: usize,
}

use std::ops::{Drop, Deref, DerefMut};
struct Scope&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a mut Interpreter);

impl &amp;lt;&#39;a&amp;gt;Scope&amp;lt;&#39;a&amp;gt; {
    fn new(inpr: &amp;amp;&#39;a mut Interpreter) -&amp;gt; Self {
        inpr.in_scope();
        Scope(inpr)
    }
}

impl &amp;lt;&#39;a&amp;gt;Drop for Scope&amp;lt;&#39;a&amp;gt; {
    fn drop(&amp;amp;mut self) {
        self.0.out_scope()
    }
}

impl &amp;lt;&#39;a&amp;gt; Deref for Scope&amp;lt;&#39;a&amp;gt; {
    type Target = Interpreter;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Interpreter {
        self.0
    }
}

impl &amp;lt;&#39;a&amp;gt; DerefMut for Scope&amp;lt;&#39;a&amp;gt; {
    fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Interpreter {
        self.0
    }
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{
            symbol_tables: Vec::new(),
            pos: 0,
        }
    }

    fn in_scope(&amp;amp;mut self) {
        let pos = self.pos;
        if self.symbol_tables.len() &amp;lt;= pos {
            self.symbol_tables.push(HashMap::new())
        } else {
            self.symbol_tables[pos - 1].clear()
        }
        self.pos += 1;
    }

    fn out_scope(&amp;amp;mut self) {
        self.pos -= 1;
    }

    pub fn run(&amp;amp;mut self, ast: AST) {
        let mut scope = Scope::new(self);
        for stmt in ast.0 {
            scope.run_stmt(stmt);
        }
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        let pos = self.pos - 1;
        self.symbol_tables[pos].insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        let pos = self.pos;
        for table in self.symbol_tables[0..pos].iter().rev() {
            if let Some(e) = table.get(name) {
                return e.clone()
            }
        }
        panic!(&amp;quot;reference to unknown variable&amp;quot;)
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            Subst(name, expr) =&amp;gt; {
                let expr = self.eval(expr);
                self.add_to_scope(name, expr);
            },
            Print(exprs) =&amp;gt; {
                for expr in exprs {
                    self.print_expr(expr);
                }
                println!(&amp;quot;&amp;quot;);
            },
            Block(stmts) =&amp;gt; {
                let scope = Scope::new(self);

                for stmt in stmts {
                    scope.0.run_stmt(stmt);
                }
            },
        }

    }

    fn eval(&amp;amp;self, expr: Expr) -&amp;gt; Expr {
        use Expr::*;
        match expr {
            Var(v) =&amp;gt; self.find_scope(&amp;amp;v),
            e @ Str(_) |
            e @ Num(_) =&amp;gt; e
        }
    }

    fn print_expr(&amp;amp;self, expr: Expr) {
        use Expr::*;
        match self.eval(expr) {
            Str(ref s) =&amp;gt; print!(&amp;quot;{}&amp;quot;, s),
            Num(ref n) =&amp;gt; print!(&amp;quot;{}&amp;quot;, n),
            Var(_) =&amp;gt; panic!(&amp;quot;reference to unknown variable&amp;quot;) ,
        }
    }
}

fn main() {
    let ast = {
        use Stmt::*;
        use Expr::*;
        AST(
            vec![
                Subst(&amp;quot;x&amp;quot;.to_string(), Num(1)),
                Subst(&amp;quot;y&amp;quot;.to_string(), Num(2)),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Block(vec![
                    Subst(&amp;quot;x&amp;quot;.to_string(), Num(3)),
                    Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                    Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                ]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
            ]
        )
    };
    let mut interpreter = Interpreter::new();

    interpreter.run(ast);
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Rustの所有権、ライフタイム、参照、型、しがらみ</title>
      <link>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</link>
      <pubDate>Wed, 14 Dec 2016 11:19:12 +0900</pubDate>
      
      <guid>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</guid>
      <description>&lt;p&gt;κeenです。Rustには所有権やらライフタイムやら参照やらがあって型システムが面倒ですよね。線形（アフィン）と言われてるのに「あれ？」と思う部分もあるので詳しく探っていこうと思います。&lt;/p&gt;

&lt;p&gt;尚、この記事は型システムに興味のある人向けです。単にRustを書きたい方に有用な情報があるかは分かりません。&lt;/p&gt;

&lt;p&gt;2016-212-14T15:28Z09:00 加筆訂正しました。diffは&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/commit/f86c03a3793fde1787a9c0eb47f8efda305c2be4&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;線形型-アフィン型&#34;&gt;線形型？アフィン型？&lt;/h1&gt;

&lt;p&gt;はじめにこの辺をハッキりさせておきたいです。
アフィン型は線形型に弱化規則を許す型です。
プログラミング的に言えば線形型は &lt;code&gt;free&lt;/code&gt; しないと型エラーになるけどアフィン型はそうでない。
Rustはご存知の通り &lt;code&gt;free&lt;/code&gt; 相当のものを手で書くことはないのでアフィンな気がしますし、昔のドキュメントにもそう書いてました。&lt;/p&gt;

&lt;p&gt;しかし実際に実行されるプログラムではコンパイラが差し込んだ &lt;code&gt;free&lt;/code&gt; が実行されるので &lt;code&gt;free&lt;/code&gt; を省略出来るというシンタックスシュガーの類な気もします。&lt;/p&gt;

&lt;p&gt;ただまあ、 &lt;code&gt;free&lt;/code&gt; を差し込む位置を特定するのに弱化規則を使った場所で推論している筈なのでアフィンを使ってる筈ですよね。&lt;/p&gt;

&lt;p&gt;ってことで今回の記事はアフィン型で統一したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;参照も値&#34;&gt;参照も値&lt;/h1&gt;

&lt;p&gt;なんとなく、構文が用意されているので参照自体特別な存在な気がしますが、そんなことはありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_any&amp;lt;T&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように任意の値を取れる関数を用意してあげます。
すると、以下のように所有、参照、可変参照全て渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let mut s = take_any(s);
take_any(&amp;amp;s);
take_any(&amp;amp;mut s);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;は-copy-mut-は違う&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; は違う&lt;/h1&gt;

&lt;p&gt;先と同じように &lt;code&gt;Copy&lt;/code&gt; を実装した型を受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_copy&amp;lt;T: Copy&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに参照を渡してあげると、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
take_copy(&amp;amp;s);
take_copy(&amp;amp;mut s); // error[E0277]: the trait bound `&amp;amp;mut std::string::String: std::marker::Copy` is not satisfied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、 &lt;code&gt;Copy&lt;/code&gt; なので普通に何度も使えます。線形型でいう &lt;code&gt;!&lt;/code&gt; に近いですね。違いますけど。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let ref_s = &amp;amp;s;
let x: &amp;amp;String = ref_s;
let y: &amp;amp;String = ref_s;
// Copy(が要求するClone)に実装されているメソッドを陽に呼ぶ
let z: &amp;amp;String = (&amp;amp;ref_s).clone();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、 &lt;code&gt;Copy&lt;/code&gt; への参照は参照外しが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x: isize = 1;
let ref_x = &amp;amp;x;
let x: isize = *x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; は &lt;code&gt;&amp;amp;&lt;/code&gt; への参照（&lt;code&gt;Copy&lt;/code&gt;への参照）なので &lt;code&gt;&amp;amp;&lt;/code&gt; へ参照外しが可能ですが、 &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; は&lt;code&gt;&amp;amp;mut&lt;/code&gt;への参照（&lt;code&gt;Copy&lt;/code&gt;ではない値への参照）なので参照外し出来ません。&lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; とややこしいですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
// &amp;amp;&amp;amp;
{
    let ref_ref_s = &amp;amp;&amp;amp;s;
    let ref_s: &amp;amp;String = *ref_refs;
}
// &amp;amp;mut &amp;amp;
{
    let refmut_ref_s = &amp;amp;mut &amp;amp; s;
    let reft_s: &amp;amp;String = *s;
}

// &amp;amp;&amp;amp;mut
{
    let ref_refmut_s = &amp;amp;&amp;amp;mut s;
    let refmut_s: &amp;amp;mut String = *s; // error[E0389]: cannot borrow data mutably in a `&amp;amp;` reference
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;T&lt;/code&gt; が &lt;code&gt;&amp;amp;T&lt;/code&gt; に参照外し出来る理由も分かったかと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-は-deref&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; は &lt;code&gt;Deref&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がたまに &lt;code&gt;&amp;amp;&lt;/code&gt; のように振る舞うことがありますが、これは &lt;code&gt;Deref&lt;/code&gt; のせいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::Deref;

let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
{
    // derefを陽に呼ぶ
    let ref_s: &amp;amp;string = refmut_s.deref();
}

{
    // 暗黙のDerefによる型強制
    let ref_s: &amp;amp;string = refmut_s;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rustは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/deref-coercions.html&#34;&gt;&lt;code&gt;deref&lt;/code&gt; による型強制&lt;/a&gt;を行うため、無言で &lt;code&gt;&amp;amp;mut&lt;/code&gt; を &lt;code&gt;&amp;amp;&lt;/code&gt; に変換することが出来ます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、ここまでで &lt;code&gt;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&lt;/code&gt; もただの値であること、アフィン型に反しないことを調べました。
次はライフタイムについて探ります。&lt;/p&gt;

&lt;h1 id=&#34;ライフタイムとサブタイピング&#34;&gt;ライフタイムとサブタイピング&lt;/h1&gt;

&lt;p&gt;実は、Rustにはサブタイピングがあります。ライフタイムです。ライフタイムにはサブタイプ関係があるのです。&lt;/p&gt;

&lt;p&gt;このように、2つの引数が厳密に同じライフタイムであることを要求する関数を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_ref&amp;lt;&#39;a&amp;gt;(_: &amp;amp;&#39;a String, _: &amp;amp;&#39;a String) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに、違うライフタイムを持つ型を放り込んでみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
    let a = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;a;
    {
        let b = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;b;
        take_two_ref(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはコンパイルが通ります。明示的にライフタイムを書くとこうです。これは有効な構文ではないです（余談ですがラベル付きbreak文のための構文と衝突します）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {
    let a: &#39;a String = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;&#39;a a;
    &#39;b: {
        let b: &#39;b String = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;&#39;b b;
        take_two_ref::&amp;lt;&#39;b&amp;gt;(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大は小を兼ねるので &lt;code&gt;&#39;a&lt;/code&gt; は &lt;code&gt;&#39;b&lt;/code&gt; のサブタイプになっています。
ちょっと言葉がややこしいのですが、スコープが狭いライフタイムの方が大きい型です。狭い方が大きい。この言い回しに馴れてない人に説明すると、上の例でいえば &lt;code&gt;&#39;b&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; と &lt;code&gt;&#39;b&lt;/code&gt; 2つありますが、 &lt;code&gt;&#39;a&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; だけです。 2つと1つだったら2つの方が大きいですよね。&lt;/p&gt;

&lt;p&gt;さて、今回の例ではちゃんとスコープの入れ子とサブタイプ関係が一致していました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {----------
              |
              |
    &#39;b: {--   |
          |   |
          |   |
          |   |
    }------   |
}--------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参照を取るときは参照のライフタイムが元のライフタイムのサブタイプになっている必要があります。&lt;/p&gt;

&lt;p&gt;この関係に反するとエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();
    ref_s = &amp;amp;s; // error: `s` does not live long enough
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;図示するとこうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();-----
    ref_s = &amp;amp;s; ----------------  |
                               |  |
}------------------------------+---
                               |
--------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ライフタイムといえどある種、型なんですね。余談ですが確かリージョンの論文には「リージョンはプログラム全体を静的に伝播する型のようなもの」と表現していた気がします。既存の型と直行するので型とは別とも言えますし、タプルのように両方並べたものを型と言うことも出来ますね。&lt;/p&gt;

&lt;h1 id=&#34;所有型とライフタイムと-static&#34;&gt;所有型とライフタイムと &lt;code&gt;&#39;static&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;適切な語彙がなかったので勝手に所有型と名付けましたが、参照でない型のことを指しています。（先の例で見せた通り、参照型にも所有権はあるので適切ではないですがひとまず我慢して下さい。）&lt;/p&gt;

&lt;p&gt;さて、なんとなくライフタイムと参照型は結び付いている気がしますが、参照じゃない型にもライフタイムはあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_value&amp;lt;&#39;a, T: &#39;a, S: &#39;a&amp;gt;(_: T, _: S){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、任意の2つの型を取るけども両方ともにライフタイムを要求する関数を書いてみます。&lt;/p&gt;

&lt;p&gt;これに、所有型を渡すことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let t = &amp;quot;t&amp;quot;.to_string();
{
    let s = &amp;quot;s&amp;quot;.to_string();
    let s_ref = &amp;amp;s;
    take_two_value(t, s_ref);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、所有型にもライフタイムはあります（多分）。&lt;/p&gt;

&lt;p&gt;ところで、ライフタイムのボトム型相当のものに &lt;code&gt;&#39;static&lt;/code&gt; というものがあります。
グローバル変数やリテラルなどに割り当てられるライフタイムで、プログラムが死ぬまで生き続けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&#39;static&lt;/code&gt; のみを受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_static&amp;lt;T: &#39;static&amp;gt;(_: T){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、先の例に出たstaticな値達を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar;
    take_static(foo);
    take_static(x);
    take_static(ref_bar);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これに所有型を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、任意の参照型は渡せません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(&amp;amp;s); // error: `s` does not live long enough
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで所有型には &lt;code&gt;&#39;static&lt;/code&gt; というライフタイムが付いているようです（？）。
&lt;code&gt;&#39;static&lt;/code&gt; イメージとしては「自分がその値を保持している限り無効になることはない型」ですかね。&lt;/p&gt;

&lt;p&gt;これに関連するTipsとして関数や構造体のジェネリクスで所有型しか受け取らないようにするには &lt;code&gt;&amp;lt;T: &#39;static&amp;gt;&lt;/code&gt; が使えます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さてさて、これまた参照型は特別扱いされることなく他のRustの値と同じようにライフタイムで管理されていることを調べました。&lt;/p&gt;

&lt;p&gt;最後に今回到達出来なかった謎、「参照を取る」について考えたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-の規則&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; の規則&lt;/h1&gt;

&lt;p&gt;みなさん御存じの通り、&lt;code&gt;&amp;amp;mut&lt;/code&gt; を取ると値への他の操作が許されなくなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
let t = s;  // error[E0505]: cannot move out of `s` because it is borrowed
let ref_s = &amp;amp;s; // error[E0502]: cannot borrow `s` as immutable because it is also borrowed as mutable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;mut T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; が相互排他的なのでこれは線形論理のシーケント計算っぽく書くと以下のような規則を考えれば良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Γ, T:&#39;a |- Σ
-------------- &amp;amp;mut-intro
Γ, (&amp;amp;&#39;a mut T): &#39;b |- Σ
where &#39;a &amp;lt;: &#39;b

Γ, (&amp;amp;&#39;a mut T):&#39;b |- (&amp;amp;&#39;a mut T): &#39;b, Σ
----------------------- &amp;amp;mut-elim
Γ, T: &#39;a |- Σ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型付け規則の書き方になれてないのでシーケント計算で書きましたがサブタイプの記述で困りましたね。&lt;/p&gt;

&lt;h1 id=&#34;の謎&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; の謎&lt;/h1&gt;

&lt;p&gt;さて、問題は &lt;code&gt;&amp;amp;&lt;/code&gt; です。 &lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; なのでそこら中に生えてきます。
なので &lt;code&gt;&amp;amp;-elim&lt;/code&gt; のような規則では対応出来ません。&lt;/p&gt;

&lt;p&gt;ただ、ライフタイムによる制約があるので「参照のライフタイムが死ぬときに元の値が復活する」ような規則を考えたくなります。&lt;/p&gt;

&lt;p&gt;しかし、それでもだめです。複数回 &lt;code&gt;&amp;amp;&lt;/code&gt; を取れてしまうので、以下のように複数のライフタイムを持つ場合で破綻します。&lt;code&gt;&amp;amp; T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; の間でなにかしらのしがらみがある筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
{
    let ref_s1 = &amp;amp;s;
    {
        let ref_s2 = &amp;amp;s;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それに、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; と &lt;code&gt;&amp;amp;&lt;/code&gt; が相互排他であることも説明出来る規則でないといけません。謎が多い。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;さて、Rustの型システムのリソース管理回りを探ってみました。とりあえず分かったことを纏めると&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;値には全てアフィン型が付く

&lt;ul&gt;
&lt;li&gt;参照型も例外ではない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;値には全てライフタイムが付く

&lt;ul&gt;
&lt;li&gt;所有型も例外ではないっぽい&lt;/li&gt;
&lt;li&gt;もしかしたら所有型はライフタイムを無視している？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「参照を取る」のセマンティクスが謎

&lt;ul&gt;
&lt;li&gt;勿論、直感的には分かる&lt;/li&gt;
&lt;li&gt;どういう規則なんだろう&lt;/li&gt;
&lt;li&gt;アフィン型とライフタイム両方が絡むはず。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特に論文も読んでないのでちょっと遠回りだったかもしれません。
もしかしたら論文漁ったら一発で解決するのかも。
詳しい方、 &lt;code&gt;&amp;amp;&lt;/code&gt; の謎を教えて下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのstructとtraitって似てるよね</title>
      <link>/blog/2016/12/03/rustnostructtotraittteniteruyone</link>
      <pubDate>Sat, 03 Dec 2016 22:06:18 +0900</pubDate>
      
      <guid>/blog/2016/12/03/rustnostructtotraittteniteruyone</guid>
      <description>&lt;p&gt;κeenです。関連型について考えてたらtraitがstructに見えてきたので一筆。小ネタです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;structは普通の構造体とtupl structと言われる形式二種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Color {
  r: u8,
  g: u8,
  b: u8,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Color(u8, u8, u8);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;traitはというと関連型と型パラメータ二種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Into {
  type Item;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Into&amp;lt;T&amp;gt;{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インスタンス化も似てます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// struct
struct Color {
  r: 255,
  g: 0,
  b: 0,
}

struct Color(255, 0, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// trait
struct Dummy;

impl Into for Dummy {
  type Item = i8
}

impl Into&amp;lt;i8&amp;gt; for Dummy {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、両者の使い分けも名前で参照したいかor手軽に使いたいかで使い分けます。&lt;/p&gt;

&lt;p&gt;以上小ネタでした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのプロセス</title>
      <link>/blog/2016/12/02/rustnopurosesu</link>
      <pubDate>Fri, 02 Dec 2016 17:52:30 +0900</pubDate>
      
      <guid>/blog/2016/12/02/rustnopurosesu</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;3日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。Rustの&lt;a href=&#34;https://doc.rust-lang.org/std/process/index.html&#34;&gt;&lt;code&gt;std::process&lt;/code&gt;&lt;/a&gt;の扱い方を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;ビルダー&#34;&gt;ビルダー&lt;/h1&gt;

&lt;p&gt;これはビルダーになっていて、以下のように使えます。公式ドキュメントの例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;sh&amp;quot;)
    .arg(&amp;quot;-c&amp;quot;)
    .arg(&amp;quot;echo hello&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境変数も渡せます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;sh&amp;quot;)
    .arg(&amp;quot;-c&amp;quot;)
    // 環境変数を参照するコマンド
    .arg(&amp;quot;echo $HELLO&amp;quot;)
    // 環境変数を設定する
    .env(&amp;quot;HELLO&amp;quot;, &amp;quot;hello, world&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;hello, world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは実行するディレクトリも指定出来ます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;ls&amp;quot;)
    // プロセスを実行するディレクトリを指定する
    .current_dir(&amp;quot;/&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
boot
cdrom
core
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;出力&#34;&gt;出力&lt;/h1&gt;

&lt;p&gt;上の例では &lt;code&gt;output&lt;/code&gt; でstdio,stderr, exitstatus取り出していますが、子プロセスとして実行することも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut child = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // outputではなくspawnを使う
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);
let status = child.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin  boot  cdrom  core  dev  etc  home  initrd.img  initrd.img.old  lib  lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  sys  tmp  usr  var  vmlinuz  vmlinuz.old
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、子プロセスはRustへではなく直接stdoutへ出力するのでSIGPIPEが送られません。&lt;/p&gt;

&lt;p&gt;あるいは出力先を手で指定することも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let child = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // stdoutをnullにする
    .stdout(Stdio::null())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);
let status = child.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではstdoutをnull ioに指定しています。他には&lt;code&gt;inherit&lt;/code&gt;で親プロセスのものを引き継ぐか、&lt;code&gt;piped&lt;/code&gt;で次のプロセスに渡すことも出来ます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// 1つめのプロセスを作る
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // 出力は親プロセスへパイプする
    .stdout(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);

// 2つめのプロセスを作る
let mut child2 = Command::new(&amp;quot;grep&amp;quot;)
    .arg(&amp;quot;bin&amp;quot;)
    // 入力は親プロセスへパイプする
    .stdin(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);

{
    // Someと分かっているのでunwrapする。
    // この辺はrustの型システテムの限界。
    let out = child1.stdout.as_mut().unwrap();
    let in_ = child2.stdin.as_mut().unwrap();
    // 1つめのプロセスの出力から2つめのプロセスの入力へデータをコピーする
    io::copy(out, in_).unwrap();
}


let status1 = child1.wait().unwrap();
let status2 = child2.wait().unwrap();
println!(&amp;quot;{}, {}&amp;quot;, status1, status2);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
sbin
exit code: 0, exit code: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと繋ぎ込みが面倒ですし&lt;code&gt;io::copy&lt;/code&gt;を使って手でコピーしてるのが頂けませんね。&lt;/p&gt;

&lt;h1 id=&#34;unix&#34;&gt;Unix&lt;/h1&gt;

&lt;p&gt;Unixに依存することを認めてしまえばもうちょっと色々なことが出来ます。&lt;/p&gt;

&lt;p&gt;1つには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::process::CommandExt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するといくつか追加のメソドが生えてくる仕組みになってます。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;exec&lt;/code&gt; が使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let error = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // execを呼ぶ
    .exec();

println!(&amp;quot;after exec!!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;した後はRustのプロセスを別のものに置き換えてしまうので&lt;code&gt;println!(&amp;quot;after exec!!&amp;quot;);&lt;/code&gt;の行が実行されません。
されるとしたら何らかの理由で&lt;code&gt;exec&lt;/code&gt;に失敗した場合だけです。なので面白いことに&lt;code&gt;exec&lt;/code&gt;の返り値はエラーのみです。&lt;/p&gt;

&lt;p&gt;あるいは、&lt;code&gt;unsafe&lt;/code&gt;なコードを認めるなら先のプロセスの繋ぎ込みはもうちょっとスマートに書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::io::{AsRawFd, FromRawFd};
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // 標準出力をパイプする
    .stdout(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

let mut child2 = Command::new(&amp;quot;grep&amp;quot;)
    .arg(&amp;quot;bin&amp;quot;)
    // 標準入力は手で作ったStdioオブジェクトにする。
    // ここでは1つめのプロセスの標準出力を直接繋ぐ。
    .stdin(unsafe{Stdio::from_raw_fd(child1.stdout.as_ref().unwrap().as_raw_fd())})
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

// 直接繋いでしまったのでコピーの必要はない

let status1 = child1.wait().unwrap();
let status2 = child2.wait().unwrap();
println!(&amp;quot;{}, {}&amp;quot;, status1, status2);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
sbin
exit code: 0, exit code: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Stdio&lt;/code&gt;がfdと行き来出来るのでそれを経由することでパイプを作れます。&lt;/p&gt;

&lt;p&gt;もちろん、ファイルに書き出すことも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::io::{AsRawFd, FromRawFd};

let file = File::create(&amp;quot;test.txt&amp;quot;).unwrap();
// ファイルからFDを経由してStdioを作る
let out = unsafe{Stdio::from_raw_fd(file.as_raw_fd())};
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    .stdout(out)
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

let status1 = child1.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status1);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat test.txt
bin
boot
cdrom
core
dev
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;最初は思ったよりCのプロセス回りのAPIと違って戸惑いますが馴れてしまえば使いやすいAPIでしょう。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>新しいコンパイラバックエンドcretonne</title>
      <link>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</link>
      <pubDate>Fri, 02 Dec 2016 14:00:11 +0900</pubDate>
      
      <guid>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;3日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。先日、Rustの開発者フォーラムに新しいバックエンドして&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;cretonne&lt;/a&gt;が&lt;a href=&#34;https://internals.rust-lang.org/t/possible-alternative-compiler-backend-cretonne/4275&#34;&gt;提案されていました&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ちょっと気になったのでそれを紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;概略&#34;&gt;概略&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/index.html&#34;&gt;ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;フォーラムによると、WebAssemblyをエンコードするために作られたコンパイラバックエンドで、FirefoxのJSエンジンであるSpiderMonkeyに載せる予定だそうです。JITが主な目的？&lt;/p&gt;

&lt;p&gt;LLVMのように最適化を頑張る方ではなくてコードを吐くまでのレイテンシを気にして作られているとのこと。なのでcretonne自身は最適化を行いません。&lt;/p&gt;

&lt;p&gt;特徴はドキュメントの&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/compare-llvm.html&#34;&gt;LLVMとの比較&lt;/a&gt;によくまとまってますが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LLVMは複数種類の中間言語を持つのに対してcretonneは1種類&lt;/li&gt;
&lt;li&gt;アセンブラもディスアセンブラもない

&lt;ul&gt;
&lt;li&gt;コードジェネレータが吐く命令だけサポート&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中間言語はISA非依存で、legalization / instruction selectionをするとISA固有のアノテーションが付く&lt;/li&gt;
&lt;li&gt;最大抽象単位が関数(LLVMはモジュール)。cretonneは関数のインライン化とかもしない。&lt;/li&gt;
&lt;li&gt;Extended Basic Blockを使う(LLVMはBasic Block)。

&lt;ul&gt;
&lt;li&gt;ebbは分岐命令のfalse branchを指定せず、fall throughする。よくあるマシン語に近い。&lt;/li&gt;
&lt;li&gt;分岐の合流はebbに引数を持たせることで行う(LLVMはphi nodeを使う)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;undefined behaviorが存在しない&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なんとなくWebAssemblyを意識した仕様ですね。&lt;/p&gt;

&lt;h1 id=&#34;雰囲気&#34;&gt;雰囲気&lt;/h1&gt;

&lt;p&gt;以下のCのコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;float
average(const float *array, size_t count)
{
    double sum = 0;
    for (size_t i = 0; i &amp;lt; count; i++)
        sum += array[i];
    return sum / count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のcretonneのIRに落ちるそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss1 = stack_slot 8, align 4   ; Stack slot for ``sum``.

ebb1(v1: i32, v2: i32):
    v3 = f64const 0x0.0
    stack_store v3, ss1
    brz v2, ebb3                  ; Handle count == 0.
    v4 = iconst.i32 0
    br ebb2(v4)

ebb2(v5: i32):
    v6 = imul_imm v5, 4
    v7 = iadd v1, v6
    v8 = heap_load.f32 v7         ; array[i]
    v9 = fext.f64 v8
    v10 = stack_load.f64 ss1
    v11 = fadd v9, v10
    stack_store v11, ss1
    v12 = iadd_imm v5, 1
    v13 = icmp ult v12, v2
    brnz v13, ebb2(v12)           ; Loop backedge.
    v14 = stack_load.f64 ss1
    v15 = cvt_utof.f64 v2
    v16 = fdiv v14, v15
    v17 = ftrunc.f32 v16
    return v17

ebb3:
    v100 = f32const qNaN
    return v100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ、実際はファイルヘッダとかも付きますがこんな感じです。&lt;/p&gt;

&lt;p&gt;ebbに引数があったりebbの途中で平気でブランチしてたり中々やんちゃですね。&lt;/p&gt;

&lt;h1 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h1&gt;

&lt;p&gt;コードを吐くところまでやりたかったのですがまだ絶賛開発中ということもあってそのような操作が見当りませんでした。&lt;/p&gt;

&lt;p&gt;ということでファイルの方を扱ってると面白みがないのでRust APIの方で関数を構築して正当性を検証してから中間言語を吐き出してみます。&lt;/p&gt;

&lt;h2 id=&#34;一歩&#34;&gt;一歩&lt;/h2&gt;

&lt;p&gt;まずはcretonneをcloneしてきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new cretonne-sample --bin
$ cd cretonne-sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んでCargo.tomlのdependenciesに&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cretonne = {path = &amp;quot;path/cretonne/lib/cretonne/&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加します。どうやらトップレベルのプロジェクトはただのユーティリティのようでした。本体は&lt;code&gt;lib/cretonne/&lt;/code&gt;以下にいます。&lt;/p&gt;

&lt;p&gt;そしてmainファイルの中身はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate cretonne;
use cretonne::ir::*;
use cretonne::ir::{types as ty};
use cretonne::ir::{immediates as imm};
use cretonne::isa;
use cretonne::settings::{self, Configurable};
use cretonne::{write_function, legalize_function, verify_function};

fn main() {
    let mut func = {
        let name = FunctionName::new(&amp;quot;average&amp;quot;);
        let mut sig = Signature::new();
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.return_types.push(ArgumentType::new(ty::F32));
        Function::with_name_signature(name, sig)
    };

    let isa = {
        let mut b = settings::builder();
        b.set(&amp;quot;opt_level&amp;quot;, &amp;quot;fastest&amp;quot;).unwrap();
        let f = settings::Flags::new(&amp;amp;b);
        let builder = isa::lookup(&amp;quot;intel&amp;quot;).unwrap();
        builder.finish(f)
    };
    verify_function(&amp;amp;func).unwrap();
    legalize_function(&amp;amp;mut func, isa.as_ref());
    let mut o = String::new();
    write_function(&amp;amp;mut o, &amp;amp;func, Some(isa.as_ref())).unwrap();
    println!(&amp;quot;{}&amp;quot;, o);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;function average(i32, i32) -&amp;gt; f32 {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おおまかには&lt;code&gt;func&lt;/code&gt;を構築して&lt;code&gt;isa&lt;/code&gt;を決めて&lt;code&gt;verify_function&lt;/code&gt;で検証、さらに&lt;code&gt;legalize_function&lt;/code&gt;で今回のアーキテクチャ向けに微調整、&lt;code&gt;write_function&lt;/code&gt;で書き出しです。&lt;/p&gt;

&lt;h2 id=&#34;スタックスロットの追加&#34;&gt;スタックスロットの追加&lt;/h2&gt;

&lt;p&gt;まあ、スタック領域ですね。8byteの領域を確保します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;にstack_slotsフィールドがあるのでそこにpushします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;push&lt;/code&gt;の返り値はスタック領域を指すキーです。&lt;/p&gt;

&lt;h2 id=&#34;ebbの追加&#34;&gt;EBBの追加&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;構造体のフィールドに&lt;code&gt;dfg&lt;/code&gt;がいて、そいつを色々いじります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let ebb0 = func.dfg.make_ebb();
        let v1 = func.dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = func.dfg.append_ebb_arg(ebb0, types::I32);

        cur.insert_ebb(ebb0);
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

ebb0(vx0: i32, vx1: i32):
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EBBの追加にはカーソルを決めてあげて、dfgにebbを作ってあげて、カーソルの位置にebbの追加という形になります。&lt;/p&gt;

&lt;p&gt;EBBには任意に引数を追加出来ます。&lt;code&gt;append_ebb_arg&lt;/code&gt;の返り値はSSAの変数です。&lt;/p&gt;

&lt;h2 id=&#34;命令を追加する&#34;&gt;命令を追加する&lt;/h2&gt;

&lt;p&gt;命令はpythonのスクリプトによって生成されるので補完が効かず、中々扱いづらいですが頑張ります。&lt;/p&gt;

&lt;p&gt;さて、今回コードの検証を入れているので以下のようなコードは検証に落ちてしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);

        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Error { location: Ebb(Ebb(0)), message: &amp;quot;block does not end in a terminator instruction!&amp;quot; }&#39;, ../src/libcore/result.rs:799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の命令が定数であるため、正常なブロックと見做されないのです。&lt;/p&gt;

&lt;p&gt;ひとまずv3を返すことで凌ぎます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        ....
        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     return v0
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令の頭に付いてる &lt;code&gt;[-]&lt;/code&gt;はlegalizeすると付くようです。&lt;/p&gt;

&lt;h2 id=&#34;ブランチ&#34;&gt;ブランチ&lt;/h2&gt;

&lt;p&gt;もう1つebbを追加してあげる必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let ebb3 = dfg.make_ebb();  // &amp;lt;- ebb3を作成
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new()); // &amp;lt;-ebb3にジャンプ

        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);

        cur.insert_ebb(ebb3); // &amp;lt;- ebb3を追加
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     brz vx1, ebb1
[-]                     return v0

                    ebb1:
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;残り&#34;&gt;残り&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;

        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb2 =  dfg.make_ebb();
        let v5 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb3 = dfg.make_ebb();

        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new());
        let v4 = dfg.ins(cur).iconst(types::I32, 0);
        let mut ebb2_arg = VariableArgs::new();
        ebb2_arg.push(v4);
        dfg.ins(cur).jump(ebb2, ebb2_arg);

        cur.insert_ebb(ebb2);
        let v6 = dfg.ins(cur).imul_imm(v5, 4);
        let v7 = dfg.ins(cur).iadd(v1, v6);
        dfg.ins(cur).jump(ebb3, VariableArgs::new());

        cur.insert_ebb(ebb3);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで進めていこうと思いましたがどうやらまだstack/heapを触る命令がない？？ようなので詰みました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;コンパイラバックエンドcretonneについて紹介しました&lt;/li&gt;
&lt;li&gt;cretonneのRust APIを触ってみましたがダメでした。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustでバイト列を扱う時のtips</title>
      <link>/blog/2016/12/01/rustdebaitoretsuwoatsukautokinotips</link>
      <pubDate>Thu, 01 Dec 2016 14:29:33 +0900</pubDate>
      
      <guid>/blog/2016/12/01/rustdebaitoretsuwoatsukautokinotips</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;2日目の記事です。&lt;/p&gt;

&lt;p&gt;Rustはシステムプログラミング言語なのでバイト列をあれこれしたいことがあると思います。その時にイテレータでバイト列を舐める以外にも色々方法があるなと気付いたので。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;read-と-write&#34;&gt;&lt;code&gt;Read&lt;/code&gt; と &lt;code&gt;Write&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;私には割と衝撃だったのですが&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;や&lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt;、&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;は直接&lt;code&gt;Read&lt;/code&gt;や&lt;code&gt;Write&lt;/code&gt;のインスタンスになってます。
例えば&lt;code&gt;Read&lt;/code&gt;ならこういう風に使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes: &amp;amp;[u8] = &amp;amp;[1, 2, 3, 4, 5, 6];
let mut buf = [0;3];
bytes.read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;read: [1, 2, 3], rest: [4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは &lt;code&gt;.bytes()&lt;/code&gt;でbyteのイテレータを取り出してもいいですし、如何様にも扱えます。&lt;/p&gt;

&lt;p&gt;少し注意が必要なのは&lt;code&gt;Vec&lt;/code&gt;は &lt;code&gt;Read&lt;/code&gt; を実装してないので一旦スライスに変換してあげる必要がありますが、やり方を工夫する必要があります。&lt;/p&gt;

&lt;p&gt;以下は少しびっくりする例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = vec![1, 2, 3, 4, 5, 6];
let mut buf = [0;3];
(&amp;amp;bytes[..]).read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;read: [1, 2, 3], rest: [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦スライスを取り出してその場で捨てているので&lt;code&gt;bytes&lt;/code&gt;は消費されません。&lt;/p&gt;

&lt;p&gt;そうやりたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = vec![1, 2, 3, 4, 5, 6];
let mut bytes = &amp;amp;bytes[..];
let mut buf = [0;3];
bytes.read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように一旦スライスを束縛してから使います。&lt;/p&gt;

&lt;p&gt;Writeの方も似ていて、そのまま&lt;code&gt;write&lt;/code&gt;出来ますし、消費されます。ただ、書き込み領域が空になってもそのままスルーされるので注意です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mut bytes: &amp;amp;mut [u8] = &amp;amp;mut [0; 6];
let data = &amp;amp;[1, 2, 3];
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;data: [1, 2, 3], buf: [0, 0, 0, 0, 0, 0]
data: [1, 2, 3], buf: [0, 0, 0]
data: [1, 2, 3], buf: []
data: [1, 2, 3], buf: []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後、バッファが空になった状態で書き込んでも無言で書き込みが終了しています。そして書き込んだデータへのアクセスは出来てないですね。&lt;/p&gt;

&lt;p&gt;こうすると出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes:[u8; 6] =  [0; 6];
let data = &amp;amp;[1, 2, 3];
{
    let mut buf: &amp;amp;mut [u8] = &amp;amp;mut bytes;
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
    buf.write(data).unwrap();
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
    buf.write(data).unwrap();
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
}
println!(&amp;quot;bytes: {:?}&amp;quot;, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [1, 2, 3], buf: [0, 0, 0, 0, 0, 0]
data: [1, 2, 3], buf: [0, 0, 0]
data: [1, 2, 3], buf: []
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあ面倒ですね。というかそもそも固定長のバッファに書き込みたいという需要が少ない。&lt;/p&gt;

&lt;p&gt;でもこれは&lt;code&gt;Vec&lt;/code&gt;を使えば解決します。可変長ですし&lt;code&gt;Write&lt;/code&gt; も実装しているので便利です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes: Vec&amp;lt;u8&amp;gt; = Vec::new();
let data = &amp;amp;[1, 2, 3];
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
println!(&amp;quot;bytes: {:?}&amp;quot;, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [1, 2, 3], buf: []
data: [1, 2, 3], buf: [1, 2, 3]
data: [1, 2, 3], buf: [1, 2, 3, 1, 2, 3]
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cursor&#34;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、上で見た通り、なんとなく生のバイト列だと扱いづらそうな場面がありそうですよね。
そこで &lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/struct.Cursor.html&#34;&gt;&lt;code&gt;std::io::Cursor&lt;/code&gt;&lt;/a&gt;を使うと便利です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Cursor&lt;/code&gt;はコンストラクタで引数の所有権を奪うタイプの、ラッパーオブジェクト的構造体です。&lt;/p&gt;

&lt;p&gt;readだとこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: &amp;amp;[u8] = &amp;amp;[1,2,3,4,5,6];
let data: &amp;amp;mut [u8] = &amp;amp;mut [0;3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
cur.read_exact(data).unwrap();
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
cur.read_exact(data).unwrap();
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
println!(&amp;quot;bytes: {:?}&amp;quot;, cur.into_inner());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [0, 0, 0], position 0
data: [1, 2, 3], position 3
data: [4, 5, 6], position 6
bytes: [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポジションが取れるのと元のオブジェクトが無事なのが違いますね。&lt;/p&gt;

&lt;p&gt;Writeも同様です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: &amp;amp;mut [u8] = &amp;amp;mut [0;6];
let data: &amp;amp;[u8] = &amp;amp;[1, 2, 3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
println!(&amp;quot;bytes: {:?}&amp;quot;, cur.into_inner());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;data: [0, 0, 0, 0, 0, 0], position 0
data: [1, 2, 3, 0, 0, 0], position 3
data: [1, 2, 3, 1, 2, 3], position 6
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この&lt;code&gt;Cursor&lt;/code&gt;の面白いのは&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;でなく&lt;code&gt;AsRef&amp;lt;[u8]&amp;gt;&lt;/code&gt;で&lt;code&gt;Read&lt;/code&gt;を実装していますし&lt;code&gt;std::io::Seek&lt;/code&gt;も実装しているのでこういうことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = Vec::new();
let data: &amp;amp;[u8] = &amp;amp;[1, 2, 3];
let buf: &amp;amp;mut [u8] = &amp;amp;mut [0; 3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.seek(SeekFrom::Start(0)).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.read(buf).unwrap();
println!(&amp;quot;bytes: {:?}, position {}, buf: {:?}&amp;quot;, cur.get_ref(), cur.position(), buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bytes: [], position 0
bytes: [1, 2, 3], position 3
bytes: [1, 2, 3, 1, 2, 3], position 6
bytes: [1, 2, 3, 1, 2, 3], position 0  // &amp;lt;- 0にシークした
bytes: [1, 2, 3, 1, 2, 3], position 3, buf: [1, 2, 3] // &amp;lt;- 0からリード出来てる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生の&lt;code&gt;Vec&lt;/code&gt;では出来なかったread and writeが実現出来ています。そして好きにカーソルをシーク出来ます。
ここまでくるとほとんどファイルと変わらなく扱えますね。&lt;/p&gt;

&lt;h1 id=&#34;おりに&#34;&gt;おりに&lt;/h1&gt;

&lt;p&gt;ちょっとしたTipsですが道具箱にこういうのを増やしておくと便利ですよね！！&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Read.html&#34;&gt;std::io::Read - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Write.html&#34;&gt;std::io::Write - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/struct.Cursor.html&#34;&gt;std::io::Cursor - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Seek.html&#34;&gt;std::io::Seek - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/enum.SeekFrom.html&#34;&gt;std::io::SeekFrom - Rust&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>マクロやコンパイラプラグインの実装方法色々</title>
      <link>/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou</link>
      <pubDate>Thu, 01 Dec 2016 13:29:52 +0900</pubDate>
      
      <guid>/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;2日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。マクロなどのコンパイル時に何か処理をしてコード生成する機構の実現方法が言語によって様々にあるなぁと思ったのでちょっと探ってみます&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;なんか文字だけ並んでても味気ないのでサンプルマクロも付けときますね。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラにマクロ専用言語のインタプリタ機能を付けるやつ&#34;&gt;コンパイラにマクロ専用言語のインタプリタ機能を付けるやつ&lt;/h1&gt;

&lt;p&gt;Rustの&lt;code&gt;macro_rules&lt;/code&gt;やSchemeの&lt;code&gt;syntax-rules&lt;/code&gt;が該当します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-syntax define-protocol
  (syntax-rules ()
    ((define-protocol (name type ...) (method arg ...) ...)
     (begin
       (define method
         (make-generic))
       ...
       (define name
         (lambda (type ...)
           (lambda methods
             (add-methods methods (list (list method arg ...) ...)))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;制限が強い上に無駄にコンパイラの機能が増えるので個人的にはあまり好きじゃないですね…。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラでもホスト言語を動かすやつ&#34;&gt;コンパイラでもホスト言語を動かすやつ&lt;/h1&gt;

&lt;p&gt;コンパイラとランタイムが一緒になっているCommon Lispなんかで使われる方法です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(defmacro dotimes-unroll ((i n unroll) &amp;amp;body body)
  (let ((n_      (gensym &amp;quot;n&amp;quot;)))
    `(let ((,n_ ,n))
       (do ((,i 0))
           ((&amp;lt; ,n_ (the fixnum (+ ,unroll ,i)))
            (do ((,i ,i (the fixnum (1+ ,i))))
                ((&amp;lt; ,n_ (the fixnum (1+ ,i))))
              ,@body
              ))
         ,@(loop :repeat unroll :append (append body `((setq ,i (the fixnum (1+ ,i))))))))))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;マクロがなくなるまで再帰的にマクロ展開をします。
ユーザが好き勝手書けてしかも手軽に使えるので割と好きです。まあ、でも言語を選びますね。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラプラグインとしてdlopenするやつ&#34;&gt;コンパイラプラグインとしてdlopenするやつ&lt;/h1&gt;

&lt;p&gt;Rustのコンパイラプラグインが相当します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[lib]
crate-type = [&amp;quot;dylib&amp;quot;]
plugin = true
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn codegen&amp;lt;&#39;cx&amp;gt;(cx: &amp;amp;&#39;cx mut ExtCtxt, text: String, file: String)
        -&amp;gt; Box&amp;lt;MacResult + &#39;cx&amp;gt; {
    let mut output = Vec::new();
    let doc = Document::parse(&amp;amp;text)
        .expect(&amp;quot;failed to parse thrift file&amp;quot;)
        .expect(&amp;quot;EOF while parsing thrift file&amp;quot;);
    {
        let ns = find_rust_namespace(&amp;amp;doc).expect(&amp;quot;cannot find namespace&amp;quot;);
    output.write_all(format!(&amp;quot;mod {} {{&amp;quot;, ns.module).as_ref()).expect(&amp;quot;internal error failed to write the vec&amp;quot;);
    }
    compile(doc, &amp;amp;mut output).expect(&amp;quot;failed to generate code&amp;quot;);
    output.write_all(format!(&amp;quot;}}&amp;quot;).as_ref()).expect(&amp;quot;internal error failed to write the vec&amp;quot;);
    let output = match std::str::from_utf8(&amp;amp;output) {
        Ok(s) =&amp;gt; s,
        Err(_) =&amp;gt; &amp;quot;&amp;quot;,
    };

    trace!(&amp;quot;{}&amp;quot;, output);


    let parser = new_parser_from_source_str(cx.parse_sess(), file, output.to_string());

    struct ExpandResult&amp;lt;&#39;a&amp;gt; {
        p: parse::parser::Parser&amp;lt;&#39;a&amp;gt;,
    }
    impl&amp;lt;&#39;a&amp;gt; base::MacResult for ExpandResult&amp;lt;&#39;a&amp;gt; {
        fn make_items(mut self: Box&amp;lt;ExpandResult&amp;lt;&#39;a&amp;gt;&amp;gt;)
                      -&amp;gt; Option&amp;lt;SmallVector&amp;lt;ptr::P&amp;lt;ast::Item&amp;gt;&amp;gt;&amp;gt; {
            let mut ret = SmallVector::zero();
            while self.p.token != token::Eof {
                match panictry!(self.p.parse_item()) {
                    Some(item) =&amp;gt; ret.push(item),
                    None =&amp;gt; panic!(self.p.diagnostic().span_fatal(self.p.span,
                                                                  &amp;amp;format!(&amp;quot;expected item, found `{}`&amp;quot;,
                                                                           self.p.this_token_to_string())))
                }
            }
            Some(ret)
        }
    }

    Box::new(ExpandResult { p: parser })

}


fn macro_thrift&amp;lt;&#39;cx&amp;gt;(cx: &amp;amp;&#39;cx mut ExtCtxt, sp: Span, tts: &amp;amp;[TokenTree])
                     -&amp;gt; Box&amp;lt;MacResult + &#39;cx&amp;gt; {

    let text = match get_single_str_from_tts(cx, sp, tts, &amp;quot;thrift!&amp;quot;) {
        Some(f) =&amp;gt; f,
        None =&amp;gt; return DummyResult::expr(sp),
    };

    codegen(cx, text, &amp;quot;trift!&amp;quot;.to_string())
}


#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;amp;mut Registry) {
    reg.register_macro(&amp;quot;thrift&amp;quot;, macro_thrift);
    reg.register_macro(&amp;quot;thrift_file&amp;quot;, macro_thrift_file);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦dllを作ってそれをプラグインとしてロードするという手間もありますし、ユーザが触れるASTも複雑なのであまり好きではないです。
まあ、これは準クオートだとかのユーザインターフェースの問題だったりするんですが。
ただ表現力はホスト言語が使えるので自由に使えます。&lt;/p&gt;

&lt;h1 id=&#34;言語の仕組みを使ってライブラリをコンパイラにロードする&#34;&gt;言語の仕組みを使ってライブラリをコンパイラにロードする&lt;/h1&gt;

&lt;p&gt;私が地味に好きな言語に&lt;a href=&#34;http://www.mirah.org/&#34;&gt;mirah&lt;/a&gt;というのがあります。その言語での実現方法が少し好きでした。
mirahはJVMで動くRuby風言語で、コンパイラは既にセルフホストされています。つまりコンパイラもJVMで動く訳です。&lt;/p&gt;

&lt;p&gt;Javaには&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html&#34;&gt;SPI&lt;/a&gt;というものがあって明示的にクラスやインスタンスを指定しなくてもJVMが実装を捜してくれる機能があります。
その機能にのっかることでマクロを.classファイルにコンパイルしてクラスパスに置いておくだけでマクロが使えるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;$ExtensionsRegistration[[&#39;java.util.Map&#39;]]
class MapExtensions
  macro def [](key)
    quote { `@call.target`.get(`key`) }
  end
end

class Builtins implements ExtensionsProvider

  def register(type_system:ExtensionsService):void
    type_system.macro_registration(MapExtensions.class)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中々面白いですね。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;なんか実装コード1つない雑な記事で申し訳ありませんがmirahのマクロの仕組みがちょっと気に入ったので書こうと思った次第です。&lt;/p&gt;

&lt;p&gt;あとはOCamlのppxやHaskellのTHも気になるのですが調べきれませんでした。はい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>4年間続いたShibuya.lispのLispMeetUp</title>
      <link>/blog/2016/12/01/4nenkantsuzuitashibuya_lispnolispmeetup</link>
      <pubDate>Thu, 01 Dec 2016 12:40:08 +0900</pubDate>
      
      <guid>/blog/2016/12/01/4nenkantsuzuitashibuya_lispnolispmeetup</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/event-management&#34;&gt;IT勉強会/コミュニティ運営 Advent Calendar 2016 - Qiita&lt;/a&gt;2日目の記事です。&lt;/p&gt;

&lt;p&gt;Shibuya.lispの開催しているlispmeetupは約4年間毎月開催しました（現46回開催）。
そこまで長く続いているコミュニティ活動はそんなに多くないのではないでしょうか。
lispmeetupがどうして続いたのかちょっと考察してみます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;因みにlispmeetupを開催しているのは第2期運営で、Shibuya.lisp自体はそれより前から活動しています。&lt;/p&gt;

&lt;p&gt;私は2期運営に途中から入った人でmeetup第6回から参加し始めて確か19回くらいから運営になったと思います。&lt;/p&gt;

&lt;h1 id=&#34;会場が安定的に確保出来た&#34;&gt;会場が安定的に確保出来た&lt;/h1&gt;

&lt;p&gt;安定してるかは若干怪しいですが毎月会場確保が出来ていたのは事実です。
最初の頃は天井から木の根が出てくるお粗末な会場だったそうですが、私が参加するころには毎回サイバーエージェントのセミナールームを使ってました。&lt;/p&gt;

&lt;h1 id=&#34;発表者がいなかったら運営が発表した&#34;&gt;発表者がいなかったら運営が発表した&lt;/h1&gt;

&lt;p&gt;勉強会に来たのに発表がなかったら残念ですよね。
どんな回でも少なくとも運営が発表するので2件くらいは発表がありました。
時間が余ったらライブコーディングしたりもしてました。&lt;/p&gt;

&lt;p&gt;因みに私も毎月発表してるからという理由で運営になったような気がします。&lt;/p&gt;

&lt;h1 id=&#34;テーマをローテした&#34;&gt;テーマをローテした&lt;/h1&gt;

&lt;p&gt;Lisp固有の事情かもしれませんがメジャーな方言にCommon Lisp、 Clojure、Schemeがあります。
参加者の中には全部いけるって人もそれなりにいますがClojureにしか興味がないって人もいます。
なので毎回テーマを決めてある程度発表者、参加者のゾーンニングをした方が満足度が高い訳です。&lt;/p&gt;

&lt;p&gt;ローテションというのもまあまあ重要で、まず運営が考えることが少なくて済む。
発表者は3ヶ月に1回くらいの頻度で自分の興味のある方言の回がやってくるのでそれなりに準備期間がある。
参加者も今月はClojureだから無理してでもいこおう、Common Lispだから今月はいいやみたいにメリハリが付けれる。&lt;/p&gt;

&lt;h1 id=&#34;平日開催した&#34;&gt;平日開催した&lt;/h1&gt;

&lt;p&gt;善し悪しだと思いますが平日開催に拘りました。平日にしか来れない人を集めたいという意向です。
逆に休日にしか来れない人は切り捨てちゃってますね。&lt;/p&gt;

&lt;p&gt;来れる人が渋谷近辺の人に限られてしまいますがまあ、Shibuya.lispなのでご愛嬌。
参加する人は地球の裏側からでも来ます。これは半分本当で、オランダとかからの参加者も過去にいました。&lt;/p&gt;

&lt;p&gt;仕事帰りに参加する人とか学生とかが多いようでした。&lt;/p&gt;

&lt;h1 id=&#34;運営の負荷を減らした&#34;&gt;運営の負荷を減らした&lt;/h1&gt;

&lt;p&gt;テーマをローテしたのところでも述べましたが、極力運営の負荷は減らした方がいいです。
運営が動かないと何も進まないので開催が億劫になるくらいなら負荷は減らしましょう。
lispmeetupでは開催報告やレポートをメーリスに投げていましたがやめてしまいました。
まあ、connpassが優秀だったのである程度そっちに頼れたというのもあります。&lt;/p&gt;

&lt;p&gt;また、最初のうちは懇親会で余ったお金を予算として持っていましたが、管理コストもかかるので掃き出してしまいました。&lt;/p&gt;

&lt;h1 id=&#34;とにかく毎月開催した&#34;&gt;とにかく毎月開催した&lt;/h1&gt;

&lt;p&gt;最初の頃は参加者が1ケタの時もありました。それでも毎月続けました。
するとある程度lispmeetupが定着したのかここ1年ほどは会場定員オーバーくらいまで人が集まるようになりました。&lt;/p&gt;

&lt;h1 id=&#34;懇親会を毎回やった&#34;&gt;懇親会を毎回やった&lt;/h1&gt;

&lt;p&gt;地味に重要だと思います。
発表者に質問にいったりあるいはふとした会話から次の発表のネタが産まれたりします。
新規参加者も重要ですがリピーターも重要です。&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;LispMeetUpは4年の節目で一旦終了します。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Shibuya.lispの現運営が引退するので &lt;a href=&#34;https://twitter.com/hashtag/lispmeetup?src=hash&#34;&gt;#lispmeetup&lt;/a&gt; がなくなります。引き継いでくれる方を募集しています。残りはClojure回、CL回です。Schemeは今月が最後でした。&lt;a href=&#34;https://t.co/o4vv9DRFal&#34;&gt;https://t.co/o4vv9DRFal&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/803599706475507716&#34;&gt;2016年11月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;今の運営が引退した後を引き継いでくれる人も集まりそうなので何らかの形では続くと思いますが、lispmeetupという形をとるのかTech Talkだけになるのかは次の運営次第です。&lt;/p&gt;

&lt;p&gt;お疲れ様でした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>サイバーエージェントを退職しました</title>
      <link>/blog/2016/11/30/saiba_e_jientowotaishokushimashita</link>
      <pubDate>Wed, 30 Nov 2016 15:51:38 +0900</pubDate>
      
      <guid>/blog/2016/11/30/saiba_e_jientowotaishokushimashita</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/1638&#34;&gt;Ex CyberAgent Developers Advent Calendar 2016 - Adventar&lt;/a&gt;1日目の記事です。
元サイバーエージェントの人がわいわいやります。&lt;/p&gt;

&lt;p&gt;κeenです。二年弱勤めたサイバーエージェントを退職したのでその旨について。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;サイバーエージェントの思い出&#34;&gt;サイバーエージェントの思い出&lt;/h1&gt;

&lt;p&gt;サイバーエージェントに興味をもつきっかけになったのも入社することになったのも学生の頃からずっと参加し続けていた&lt;a href=&#34;https://lisp.connpass.com&#34;&gt;LispMeetUp&lt;/a&gt;でした。
LispMeetUpでは長らく会場としてCAのセミナールームを使わせてもらっていました。
そこでエンジニアに対して気軽に施設を提供するCAや社員の&lt;a href=&#34;https://twitter.com/potix2&#34;&gt;@potix2&lt;/a&gt;さんを知って、そのまま@potix2さんの手引でCAに入社する運びとなりました。
「面接でLispは口にしない方が良い。100%落ちる。」なんて言ってた割にはLisp繋りで入社しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/04/10/cyberagentninyuushashimashita/&#34;&gt;CyberAgentに入社しました | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新卒で入社してからは3ヶ月ほど研修でした。
最初の2週間ほどあるビジネス職も含めた全体研修ではなるほど、ここがCAかと思いました。しかしエンジニア研修からは見慣れた光景に戻って静かに研修を受けてました。
エンジニア研修は割と長めにあるので同期のエンジニア同士の顔を覚える余地はありました。勉強会なんかもやりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://keens.github.io/slide/seitekinamemorikanrinohanashi/&#34;&gt;静的なメモリ管理の話。リージョン推論とλ計算からRustまで | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keens.github.io/slide/benkyoukaikudoubenkyoudetakeshibenkyou/&#34;&gt;勉強会駆動勉強で猛勉強 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keens.github.io/slide/21seikinoenjinianotamenoHTTP_2nyuumon/&#34;&gt;21世紀のエンジニアのためのHTTP/2入門 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などなど。Linux, C, Python, Go, Java, Web, iOS, フレームワーク, Android, チーム開発なんかをやりました。Python, Go, iOSあたりは自分じゃやらなかったので面白かったです。&lt;/p&gt;

&lt;p&gt;研修中は割と時間があったので他にも色々なことをやってました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/05/06/tarballbe_sunokeiryoubakkuapputsu_rutsukutta/&#34;&gt;tarballベースの軽量バックアップツール&amp;rsquo;Sheltar&amp;rsquo;を作った | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/05/26/onigmowosaidai49_kousokukashitahanashi/&#34;&gt;Onigmoを最大49%高速化した話 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou/&#34;&gt;第一級ラベルを持たない言語におけるDirect Threaded VMの実装 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この他にも研修期間中にブログエントリ十数本書いていたようです。下の代からは研修の内容が変わって忙しそうでした。&lt;/p&gt;

&lt;p&gt;研修のあとの配属は@potix2さんのいる&lt;a href=&#34;https://adtech.cyberagent.io/&#34;&gt;アドテクスタジオ&lt;/a&gt;のAMoAdでした。トレーナの清水さんを始めとしてチームの皆さんにお世話になりました。
AMoAdはその昔、外注していたシステムを巻き取ったものなのでやることが一杯あって、JavaやScalaを書いたり自動化をやったりしました。&lt;/p&gt;

&lt;p&gt;Scalaは全然いたことがなかったので練習がてら作ったのがこれでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/&#34;&gt;Scala初心者の新卒が頑張ってLispを作ってみた | Scala Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これのおかげで型クラスがただのimplpcit parameterに見えるようになったのでそれなりに収穫はあったな、と思ってます。&lt;/p&gt;

&lt;p&gt;AMoAdに限らずアドテクスタジオのエンジニアのボリュームゾーンは30代半ばなのでだいたい一回り近く年の離れたエンジニアに暖かく囲まれながら仕事をしていました。
どんな雰囲気なの？とたまに訊かれますがエンジニアが集う部署なのでだいたい工学部を想像して頂けたらと思います。&lt;/p&gt;

&lt;p&gt;さて、年が明けて2016年の1月になると、@potix2さんが新しいグループを立ち上げることになって別のグループに移動してしまいました。長らくお世話になりました。
と思いきや自分もそのグループに移動になったので相変わらずお世話になることになりました。基盤開発グループってところでした。仕事と仕事の境目は一瞬仕事がない期間が産まれたりしますが、その隙を使って始めたのがRustのドキュメントの翻訳です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/3b068769736e671805f0&#34;&gt;Rustのドキュメントの翻訳プロジェクトを開始します。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あたらしいチームでは社内向けマイクロサービスのようなものを作ることになりました。
私ともう一人ベテランのエンジニア(&lt;a href=&#34;https://twitter.com/atty303&#34;&gt;@atty303&lt;/a&gt;)でやる筈でしたが私のような雑草と違ってベテランは中々元のチームを抜けられないので1ヶ月ほど私一人でコードを書いてました。
Scalaにも馴れてない新卒一人で。1ヶ月後に&lt;a href=&#34;https://twitter.com/atty303&#34;&gt;@atty303&lt;/a&gt;さんがジョインすると、コードは書かずにインフラをやるとのことでした。なのでコードを書くのはやっぱり私一人。&lt;/p&gt;

&lt;p&gt;私が苦戦しつつコードを書いている間にconsulやnomad、terraform、dockerなんかでインフラが構築されていき、たまに朝来たら自分のコードが消えていたり（「君のコード書き直しといたよ」）して確か5月頃リリースだったような。&lt;/p&gt;

&lt;p&gt;因みにdockerを多く使うのにdocker-machineだと不便なのでUbuntuマシンが欲しいって言ったら却下されました。セキュリティ的に無理でした。結局VMでUbuntuを使ってました（使ってます）。&lt;/p&gt;

&lt;p&gt;リリースしてからは要求性能も満たしそこまで大きな障害もなく平和に暮らしました。めでたしめでたし。Ubuntuは使えなかったけど。&lt;/p&gt;

&lt;p&gt;まあ、あとは新卒研修を担当したり&lt;a href=&#34;https://www.cyberagent.co.jp/recruit/fresh/program_detail/id=11303&amp;amp;season=2016&#34;&gt;インターン&lt;/a&gt;を担当したり社内ハッカソンをやったりゼミでドローンを飛ばしたり新卒のトレーナーをやったりライブラリの選書をやってコンパイラの本を大量に入荷したりと本業以外も色々やってました。長くなるのでこの辺は省きますね。&lt;/p&gt;

&lt;h1 id=&#34;退職に際して&#34;&gt;退職に際して&lt;/h1&gt;

&lt;p&gt;よく、「合わなかったの？」と言われますがそんなことはないです。（少くとも）アドテクスタジオはエンジニアにとっては非常に働きやすい場所でしたし&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cyberagent.co.jp/features/detail/id=12837&#34;&gt;adtech studio - Photo Tour｜FEATURES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CAの一般的イメージはそういう部分だけ切り取ってメディアに出してるんだと思います。
エンジニアから見たら先述の通り工学部のような雰囲気です。Ubuntuは使えないけど。サーバもMacやWindowsで動いてるんですかね。&lt;/p&gt;

&lt;p&gt;むしろCAに入って良かったなと思える部分は一杯あって、ベテランのエンジニアに色々教えて貰ったりだとかVMwareのライセンスを買ってくれたりだとか&lt;a href=&#34;https://adtech.cyberagent.io/techblog?s=icfp&#34;&gt;ICFPに行かせてもらったり&lt;/a&gt;だとか。&lt;/p&gt;

&lt;p&gt;同期エンジニアの繋りというのもすごい良くて、得意分野も部署も（今となっては）会社も色々にある60人ほどいるエンジニアとの人脈が無条件に作れるというのは新卒で入らないと出来ないなと思います。
困ったことがあったら同期Slackに投げると数分で解決します。&lt;/p&gt;

&lt;p&gt;最後は雑草が枯れるように誰にも気付かれないように消えていくつもりでしたがそうもいかず、大勢の方々に送り出して頂きました。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;集合写真&#34; src=&#34;/images/ca/mall.jpg&#34; style=&#34;width: 100%&#34;&gt;&lt;/p&gt;

&lt;p&gt;私の周りにいるのがお世話になった開発責任者やトレーナー、トレーニーなどですね。&lt;/p&gt;

&lt;p&gt;色紙とプレゼントも頂きました。ありがとうございます。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;プレゼントの写真&#34; src=&#34;/images/ca/presents.jpg&#34; style=&#34;width: 100%&#34;&gt;&lt;/p&gt;

&lt;p&gt;退職の旨は業務上必要な方以外には知らせてなかったのでまさか色紙が来るとは思ってませんでした。
多分関係しそうな人にDMを送って集めたんだと思います。ありがとうございます。
プレゼントは麻の模様の風呂敷です。
私はカバン代わりにPCを入れるにも旅行に行くにも風呂敷を使う人です:)&lt;/p&gt;

&lt;p&gt;そして女性エンジニアの方(&lt;a href=&#34;https://twitter.com/iyunoriue&#34;&gt;@iyunoriue&lt;/a&gt;)からFOUNDRYの詰め合わせも頂きました。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;FOUNDRYの写真&#34; src=&#34;/images/ca/foundry.jpg&#34; style=&#34;width: 100%&#34;&gt;&lt;/p&gt;

&lt;p&gt;スイーツが好きなので非常に嬉しいです。ありがとうございます。抹茶と合いそう。&lt;/p&gt;

&lt;p&gt;また、退職に合わせて色々なものも引退することになりました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Shibuya.lispの現運営が引退するので &lt;a href=&#34;https://twitter.com/hashtag/lispmeetup?src=hash&#34;&gt;#lispmeetup&lt;/a&gt; がなくなります。引き継いでくれる方を募集しています。残りはClojure回、CL回です。Schemeは今月が最後でした。&lt;a href=&#34;https://t.co/o4vv9DRFal&#34;&gt;https://t.co/o4vv9DRFal&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/803599706475507716&#34;&gt;2016年11月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そろそろ私も野生のLisper引退した方がいい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/803601106693521408&#34;&gt;2016年11月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;お世話になった方々本当にありがとうございました。&lt;/p&gt;

&lt;h1 id=&#34;次の話と退職理由&#34;&gt;次の話と退職理由&lt;/h1&gt;

&lt;p&gt;とりあえず12月中は有給消化で、1月から働きます。給料はまあまあ上がります。どうやらコンパイラ関係の仕事をしそうです。
世の中そんな仕事があるのか自分でも半信半疑ですがあるようです。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そういえばICFPのときにкeenさんと話して「えっコンパイラが書けるシゴトあると思ってんの!?」と冗談半分で言われたな．&lt;/p&gt;&amp;mdash; gfn (@bd_gfngfn) &lt;a href=&#34;https://twitter.com/bd_gfngfn/status/780057500485681153&#34;&gt;2016年9月25日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;私のことを知ってる方なら「コンパイラの仕事があるから」で十分退職理由として納得頂けると思います。
技術的にも人生的にもチャレンジングですがまだ20代前半なので後先考えずに行動してもどうにかなるかな、とか思ってます。
地味に社内でRustも使われているようなのでそこも狙っていこうと思います。
あ、こういうのもやってます。興味のある方はお願いします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次の仕事についてはまた入社してから書こうと思いますが、ひとまずの報告として渋谷からは離れます。本郷キャンパスに近いところに引っ越す予定です。付近の人はなんか誘って下さい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://amzn.asia/0JcDzIf&#34;&gt;http://amzn.asia/0JcDzIf&lt;/a&gt;&lt;/p&gt;

&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;お疲れ様でした&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SML#をUbuntu 16.10で動かす</title>
      <link>/blog/2016/11/30/sml_woubuntu_16_10deugokasu</link>
      <pubDate>Wed, 30 Nov 2016 15:18:58 +0900</pubDate>
      
      <guid>/blog/2016/11/30/sml_woubuntu_16_10deugokasu</guid>
      <description>&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2016/ml&#34;&gt;ML Advent Calendar 2016 - Qiita&lt;/a&gt;の1日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。小ネタを。Ubuntu 16.10でSML#を動かそうと思ったら動かなかったので動かします。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;現象&#34;&gt;現象&lt;/h1&gt;

&lt;p&gt;リンカがエラーを吐く。バイナリが正しく作れてなさそう&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(callback.o): relocation R_X86_64_32 against `.text&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(control.o): relocation R_X86_64_32 against `.text&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(error.o): relocation R_X86_64_32 against `.bss&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(exn.o): relocation R_X86_64_32 against `.rodata.str1.8&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください 。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(finalize.o): relocation R_X86_64_32 against `.text&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(init.o): relocation R_X86_64_32 against `.rodata.str1.1&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(object.o): relocation R_X86_64_32 against `.rodata.str1.1&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(xmalloc.o): relocation R_X86_64_32 against `.rodata.str1.1&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてくだ さい。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(prim.o): relocation R_X86_64_32 against `.rodata&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(top.o): relocation R_X86_64_32 against `.text&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(dtoa.o): relocation R_X86_64_32 against `.rodata.str1.1&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(heap_concurrent.o): relocation R_X86_64_32S against `.bss&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: 最終リンクに失敗しました: 出力に対応するセクションがありません
collect2: error: ld returned 1 exit status
uncaught exception: CoreUtils.Failed: gcc -Wl,-Bsymbolic-functions -Wl,-z,relro test/Main.o /tmp/tmp.IhaEmV/000/tmp_000.a lib/socket.o lib/inet.o lib/net_host_db.o /usr/lib/x86_64-linux-gnu/smlsharp/runtime/main.o /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a -lpthread -lyajl -ldl -lgmp -lm  -o testRunner at src/compiler/toolchain/main/CoreUtils.sml:113
Makefile:50: ターゲット &#39;testRunner&#39; のレシピで失敗しました
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;原因&#34;&gt;原因&lt;/h1&gt;

&lt;p&gt;私もよく分かってないのですが、Ubuntu 16.10からGCC 6系になりましたが、そこでデフォルトの挙動が変わったらしいのでその辺らしいです。&lt;/p&gt;

&lt;h1 id=&#34;対策&#34;&gt;対策&lt;/h1&gt;

&lt;p&gt;たいていの言語で &lt;code&gt;-no-pie&lt;/code&gt; を付けることで解決しています。 Position Independent Executableだっけ？&lt;/p&gt;

&lt;p&gt;アドホックにやる方法と恒久的に解決する方法とがあります。&lt;/p&gt;

&lt;h2 id=&#34;アドホックな方&#34;&gt;アドホックな方&lt;/h2&gt;

&lt;p&gt;簡単で、SML#で &lt;strong&gt;リンクする時&lt;/strong&gt; に &lt;code&gt;-Xlinker -no-pie&lt;/code&gt; を付けてあげます。&lt;/p&gt;

&lt;h2 id=&#34;恒久的な方&#34;&gt;恒久的な方&lt;/h2&gt;

&lt;p&gt;SML#を自前でビルドします。そのとき &lt;strong&gt;configure時&lt;/strong&gt; に &lt;code&gt;LDFLAGS=-no-pie&lt;/code&gt; を付けてあげます。&lt;/p&gt;

&lt;h1 id=&#34;余談&#34;&gt;余談&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;-no-pie&lt;/code&gt; はGCC 6以降で、それ以前は &lt;code&gt;-nopie&lt;/code&gt; との噂をききましたがGCC 6系しか手元にないので真偽のほどは分かりません。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SchemeでClassとProtocol</title>
      <link>/slide/Schemedeclasstoprotocol/</link>
      <pubDate>Mon, 28 Nov 2016 15:41:36 +0900</pubDate>
      
      <guid>/slide/Schemedeclasstoprotocol/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClassとProtocol
----------------------
[Lisp Meet Up presented by Shibuya.lisp #46](https://lisp.connpass.com/event/45517/) Scheme回
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# Class
-------

* ここでは単に値の集合を表わす
* `new` のように新しいインスタンスを作る機能はつけない
* ほとんど型と同じ機能
* 唯一の機能 `instance?` を持つ

===

``` scheme
(instance? 3 &lt;number&gt;)     ; =&gt; #t
(instance? &#34;foo&#34; &lt;number&gt;) ; =&gt; #f
```

===

# Classの実装
-------------

* 事実上述語があればいい
* [詳細](https://github.com/picrin-scheme/picrin/blob/master/contrib/50.class/piclib/picrin/class.scm)

``` scheme
(define-class &lt;any&gt; (lambda (x) #t))
(define-class &lt;list&gt; list?)
(define-class &lt;procedure&gt; procedure?)
(define-class &lt;number&gt; number?)
```

===

# Classの用途
-------------

* 述語だけで意味ある？
  + プリミティブにのみあった述語をユーザが拡張出来る
* その上に何かを構築出来る
* protocolとか

===

# Protocol
-----------

* Clojureのprotocol
* 多重ディスパッチの機構
* ディスパッチするのにClassを使う

===

```scheme
(define-protocol (PLUS x y)
  (plus x y))

(define-instance (PLUS &lt;number&gt; &lt;number&gt;)
  (lambda (x y) (+ x y)))


(define-instance (PLUS &lt;number&gt; &lt;string&gt;)
  (lambda (x y) (string-append (number-&gt;string x) y)))

(define-instance (PLUS &lt;string&gt; &lt;string&gt;)
  (lambda (x y) (string-append x y)))

```

===

``` scheme
(display (plus 1 2)) (newline)
; -&gt; 3
(display (plus 1 &#34;foo&#34;)) (newline)
; -&gt; 1foo
(display (plus &#34;bar&#34; &#34;foo&#34;)) (newline)
; -&gt; barfoo
(display (plus &#34;bar&#34; 1)) (newline)
; -&gt; &#34;error: method not found&#34;
```

===
# ユーザ定義型とProtocol
------------------------

``` scheme
(define-record-type complex
  (make-complex real img)
  complex?
  (real complex-real)
  (img  complex-img))

(define (complex-+ c1 c2)
  (make-complex (+ (complex-real c1) (complex-real c2))
                (+ (complex-img  c1) (complex-img  c2))))

(define (complex-&gt;string c)
  (string-append
   (number-&gt;string (complex-real c)) &#34;+&#34;
   (number-&gt;string (complex-img  c)) &#34;i&#34;))
```

===

```scheme
(define-class &lt;complex&gt; complex?)

(define-instance (PLUS &lt;complex&gt; &lt;complex&gt;)
  complex-+)


(display (complex-&gt;string
          (plus (make-complex 1 2)
                (make-complex 2 3)))) (newline)
; -&gt; 3+5i
```

===

# Protocolの実装
----------------

* メソッドの登録とか述語でディスパッチとか割と面倒
* [詳細](https://github.com/picrin-scheme/picrin/blob/master/contrib/80.protocol/piclib/picrin/protocol.scm)

===
# まとめ
---------

* 「追加可能な型」は便利だよ
* 型相当のものがあればダイナミックディスパッチ出来るよ
* picrinに実装されてるよ `(picrin class)` `(picrin protocol)`

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustで非同期Thriftしたい</title>
      <link>/slide/RustdehidoukiThriftshitai/</link>
      <pubDate>Sat, 26 Nov 2016 13:07:29 +0900</pubDate>
      
      <guid>/slide/RustdehidoukiThriftshitai/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Rustで非同期Thrift
----------------------
[歌舞伎座.tech#12「メッセージフォーマット/RPC勉強会」 - connpass](https://kbkz.connpass.com/event/40629/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

* &lt;span style=&#34;font-size:150%&#34;&gt;X&lt;/span&gt; RPCライブラリを使う話
* &lt;span style=&#34;font-size:150%&#34;&gt;O&lt;/span&gt; RPCライブラリを作る話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# RPC
-----

* Remote Procedure Call
* リモートで呼べる
* 言語跨げる
* シリアライズフォーマットが決まれば大体出来る
* Thrift, protobuf/gRPC, avro...
* 大抵バイナリ
  + JSONに比べて2倍くらい効率がいい

===

# Thrift
--------

* Facebook発(現apache)RPCフレームワーク
* IDLから複数の言語向けのコードを吐ける
* 対応言語多い
* 新しい言語はthriftレポジトリフォークして追加

===

# Thrift vs gRPC
----------------

\                       | Thrift | gRPC
------------------------|:------:|:----:
ベース                  | 自前   | HTTP/2
コード生成              | o      | o
プロトコルのアップデート | o      | o
通信の多重化            | トランスポート次第  | o (HTTP/2)
認証                    | x  | o
例外                    | ユーザ定義可能 | 事前定義のみ?
対応言語                | 多い   | ほどほど
その他                  | union  | timestamp, anyなど
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;

===

# 何故Thrift?
-------------

* 仕事で使ってたから
* 仕事は「gRPCかthrift、まあthriftでいっしょ」で決まった

===

# RustとThrift
--------------
いくつか実装がある

===

## [sgnr/rust-thrift](https://github.com/sgnr/rust-thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![sgnr/rust-thrift is deprecated](/images/thrift/sgnr-rust-thrift.png)

===

## [maximg/thrift](https://github.com/maximg/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![maximg/thrift is deprecated](/images/thrift/maximg-thrift.png)

===

## [terminalcloud/thrift](https://github.com/terminalcloud/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![terminalcloud/thrift is deprecated](/images/thrift/terminalcloud.png)

===

# [thehydroimpulse/thrust](https://github.com/thehydroimpulse/thrust)
---------------------------

* Thrift RPC in Rust (Async I/O)
* 非同期!!
* apache/thriftベースじゃない（フルスクラッチ）
* コンパイラプラグインサポートとかも
* 作りかけ
  + `Latest commit 0a37b77 on 11 Apr`

→ フォークすることに

===

# [Finagle](https://github.com/twitter/finagle)
---------

* **Scalaの** RPCフレームワーク
* [You Server as a Function](https://monkey.org/~marius/funsrv.pdf)
* Nettyベース
* サーバとクライアント両方サポート
* Twitter製
* 良くも悪くもTwitterべったり

===

# Finagle Client
--------

* クライアントが賢い
* RPCではTCPベースのLBが使えない
  + クライアントはコネクション張りっぱなし
* クライアントサイドロードバランシングが必要
* Finagleはそこまでカバー
* 他にもエラーが起きたサーバ外したり色々

===

# Tokio
--------

* **Rustの** RPCフレームワーク
* mioベース
* Finagleを参考に開発
  + **開発中**
* tokio-core
  + コア部分
* tokio-proto
  + プロトコル実装のサポート
  + 絶賛API変更中
* tokio-service
  + サービス実装のサポート


===

# TokioとFinagle
-----------------

  \           | Tokio       | Finagle
--------------|:-----------:|:-------:
コア          | [tokio-core](https://github.com/tokio-rs/tokio-core) | [finagle-core](https://github.com/twitter/finagle/tree/develop/finagle-core)
Future        | [future](https://github.com/alexcrichton/futures-rs) | [twitter util](https://github.com/twitter/util)
非同期エンジン | [mio](https://github.com/carllerche/mio) | [netty](http://netty.io/)
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;


===

# [mio](https://github.com/carllerche/mio)
------

* 非同期イベントループライブラリ
* イベントドリブン
* ループ内ゼロアロケーション
* `epoll` などの薄いラッパ
* libuv, libevent, libev2などのRust版
* ソケットだけでなく *ファイルIO* 、インメモリチャネルとかも監視出来る

===

# [future](https://github.com/alexcrichton/futures-rs)
--------------

* [Zero-cost futures in Rust · Aaron Turon](https://aturon.github.io/blog/2016/08/11/futures/)
* ゼロコスト
* 普通にFutureを使うとランタイムにステートマシンになる
* 「将来実行される」という「状態」を第一級の値として表現する大事な手段
* お型付けは大変
    + `map` したら `Map&lt;A, fn (A)-&gt;B&gt;` の型が返ったり
* ストリーミング指向のAPIもある

===

# [tokio-core](https://github.com/tokio-rs/tokio-core)
--------------

* 非同期IOのフレームワーク
* Futureベース
* フレームドIOとストリーミングIO
* フレームワークというよりユーティリティ？
  + mioとfutureを合わせて使う

===

# [tokio-proto](https://github.com/tokio-rs/tokio-proto)
-------------

* 主にバイナリ列&lt;-&gt;構造体の部分の面倒を見てくれる
* API変更中…
* バッファリングしてパースしやすくしてくれる
* プロトコルの多重化やってくれる(後述)

===

# [tokio-service](https://github.com/tokio-rs/tokio-service)
-----------------

* タスクサーバの面倒見てくれる
* 主にロードバランシング


===

# [Service](https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html)
-------------

``` rust
pub trait Service {
    type Request;
    type Response;
    type Error;
    type Future: Future&lt;Item=Self::Response, Error=Self::Error&gt;;
    fn call(&amp;self, req: Self::Request) -&gt; Self::Future;
}
```

===

# Service
----------

* いわゆるハンドラ
* インターフェースさえ満たせばいい
  + ミドルウェアもハンドラも同じ扱い

===

# [NewService](https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html)
--------------

```rust
pub trait NewService {
    type Request;
    type Response;
    type Error;
    type Instance: Service&lt;Request=Self::Request, Response=Self::Response, Error=Self::Error&gt;;
    fn new_service(&amp;self) -&gt; Result&lt;Self::Instance&gt;;
}

impl&lt;F, R&gt; NewService for F where F: Fn() -&gt; Result&lt;R&gt;, R: Service
```

===

# NewService
------------

* いわゆるAbstractServiceFactory的な存在
* コア数に応じてサービスを作ってくれる
* ただし`Service`を返す普通の関数も`NewService`になる
* [example](https://github.com/tokio-rs/tokio-line/blob/master/examples/echo_client_server.rs#L21)


===

# tokio-thrift
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# [tokio-thrift](https://github.com/KeenS/tokio-thrift)
--------------

* [KeenS/tokio-thrift](https://github.com/KeenS/tokio-thrift)
* この発表のために作った（作ってる）
* tokioベースのrustのthriftサポート
* thrustのフォーク
* 基本ツール全て
  + コードジェネレータ
  + コンパイラプラグイン
  + ランタイムライブラリ

===

# プロトコルスタック
-------------------

ユーザは実装に集中出来る仕組み

```
+------------------------------------------------+
| service   | tokio-service + 生成コード + ユーザ |
|------------------------------------------------|
| protocol  | tokio-proto   + tokio-thrift       |
|------------------------------------------------|
| transport | tokio-core                         |
+------------------------------------------------+
```

===

# サンプルコード
----------------

* [これ](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/main.rs)

===

# ユーザビリティ
---------------

* サーバ: ユーザはインターフェースに沿ったコードを書くだけ
* クライアント: インターフェース通りに呼べる
* 返り値はFuture
* サーバ: 非同期実装と相性がいい
* クライアント: 非同期通信をそのままエンコード

===

# 実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# Thriftのプロトコル
-------------------

* 現状binary protocolのみ
  + fork元が実装してあった
* compactとか需要ある？
* 因みにJSONはやめとけ

===

# 所有権とゼロコピー
-------------------

* プロトコルのパースの部分の話
* Rustっぽい部分
* バッファの所有権をパース結果に渡すことでデータのコピーを避ける

===

# 所有権とゼロコピー
-------------------
バッファをresultにパースして

```
buffer
  |
+-+---------------+
|                 |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 所有権とゼロコピー
-------------------
resultにデータの所有権を渡してしまう

```
 result   buffer
   |        |
+--+----++--+-----+
|       ||        |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 複数メソッド
-------------

* 複数メソッドだと複数の引数/返値の型を扱う
* コネクションのハンドラは1つ
* 複数型をどうやって扱う？
  + [enumを定義](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/thrift.rs#L67)
  + ゼロオーバーヘッド…

===

# 複数メソッド
-------------

```
 (methodA) (methodB)
     |         |
     +----+----+
          | &lt;----- enum化
      [client]
          |
      [server]
          | &lt;----- enumでディスパッチ
     +----+-----+
     |          |
(handlerA) (handlerB)
```

===

# つらい話
-----------------

* Thrift IDLのセマンティクスが書いてない
  + throws節のフィールドは直積？直和？
  + Javaで生成してみて推測するしかない
* フォークライブラリの実装が不完全
  + パーサはフルスクラッチで書き直した
  + [パーサコンビネータ便利](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-codegen/src/parser.rs#L517)
  + フォークした意味…
* Rustにエンコード出来ないthriftの機能もある
  + mapの定数は普通には無理
  + エラーどうしよう(`Error`トレイトの実装とEnum)
* 所有権の問題

===

# 言語との統合
-------------

* Rustには公式のシリアライズフレームワークがある
* [rustc-serialize](https://github.com/rust-lang-nursery/rustc-serialize)
* あるいはユーザ側のも
* [serde](https://github.com/serde-rs/serde)
* のっかりたいけどThriftに必要なデータがない
  + フィールドのシーケンス番号とか
* 今のところ自動生成に頼る
  + フレームワークにフィードバックした方がいい？

===

# コード生成の話
---------------

* [コンパイラプラグイン](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-macros/tests/service.rs#L10)微妙
  + 定義元ジャンプ、フィールド名補完などに難
* CLI生成は悪手
  + IDL変更する度CLI実行？
  + 生成コードはコミット？
    - CLIのバージョンがあるので基本はコミット。でも…
* ビルドツール統合が最良
  + FinagleにはScoogeがある
  + tokio-thriftでもやりたい
    - build.rsのサポート

===

# 多重化の話
------------

* 生のthrift on TCPだと通信を多重化出来ない
* tokio-proto側でpipelineやmultiplexなどをサポート
* pipeline: レスポンスを待たずに次のリクエスト
* multiplex: リクエストとレスポンスが入り乱れてもよい。プロトコルオーバーヘッドがある
* tokio-thriftは未対応

===

# Tokioの利点
-------------

* service: サーバとクライアント両方面倒見てくれる
  + サーバもCPUの数だけハンドラをクローンしてくれたりする
* protocol: 面倒毎が少ない(バッファ使ってくれる)
* Futureベースの非同期
* pipeline, multiplexによる多重化

===

# Tokioの欠点
-------------

* APIが不安定
  + tokio-thriftは今動かないorz
* thriftはストリーミング指向なのにバッファ使う
* Rustの痒い所に当たる
  + 返り値多相がない(`Future`を直接返せない)
  + アロケーションが必要になる
  + ダイナミックディスパッチが必要になる
  + 他言語と同水準のコスト

===

# まとめ
--------

* Thriftは広さで勝負
* コードジェネレータはビルドツールへの統合を
* IDLは既存のコードに乗っかった方が楽（上と競合）
* フレームワークを使うとみんな幸せ
* RPCはインターフェースベースであるべき
* 多重化はRPCより下のレイヤーで出来る

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustの関連型の使いどころ</title>
      <link>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</link>
      <pubDate>Tue, 22 Nov 2016 18:26:47 +0900</pubDate>
      
      <guid>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</guid>
      <description>&lt;p&gt;κeenです。昨日は&lt;a href=&#34;https://rust.connpass.com/event/41467/&#34;&gt;RustのLT会！ Rust入門者の集い - connpass&lt;/a&gt;に参加してきました。
そこで&lt;a href=&#34;http://qiita.com/tacke_jp/items/9c7617971dc341146c0f&#34;&gt;関連型に関する発表&lt;/a&gt;があったので感化されて私も一筆。&lt;/p&gt;

&lt;p&gt;
馴れないと関連型はジェネリクスでいいじゃんと思えますが、両者は別の機能を提供するものです。
設計による使い分けではなくて実現したいことに応じた機能による使い分けをするので馴れてしまえば迷うことなくどちらを使うか判断出来ます。&lt;/p&gt;

&lt;p&gt;ということで関連型のパターンをいくつか。
もちろん、根底にある関連型という機能は共通なのでほとんど同じようなことを言ってますが気持としてパターンを知っておくと便利です。&lt;/p&gt;

&lt;h1 id=&#34;型レベルの関数として&#34;&gt;型レベルの関数として&lt;/h1&gt;

&lt;p&gt;「関連」型なのである型に関連する型を表現します。ちょっと見方を変えると型から型への写像、つまり関数になります。
例えばこういうのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ToUnsigned {
    type Counterpart;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart;
}

impl ToUnsigned for i32 {
    type Counterpart = u32;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart {
        self as u32
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;i32&lt;/code&gt; から &lt;code&gt;u32&lt;/code&gt; への関数になってそうなのが見えますかね？もちろん、 &lt;code&gt;i64&lt;/code&gt; から &lt;code&gt;u64&lt;/code&gt; などへの対応も作れます。
こういうのは例えば符号無し数にのみ演算が定義されている場合とかに便利ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn write_bigendian_signed&amp;lt;I, U&amp;gt;(i: I) -&amp;gt; ()
    where I: ToUnsigned&amp;lt;Counterpart = U&amp;gt;,
          U: ...,  {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;トレイト内で使う型を固定するため&#34;&gt;トレイト内で使う型を固定するため&lt;/h1&gt;

&lt;p&gt;これが一番目にするやつじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Handler {
    type Request;
    type Response;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}

struct HTTPHandler;

impl Handler for HTTPHandler {
    type Request = HTTPRequest;
    type Response = HTTPResponse;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定というか特殊化というか、トレイト自体は汎用的に作られていて、それを実装する型が特定の処理に特化するパターンです。
ジェネリクスで受け取る訳にはいかなくて、実装すべき型をトレイトの中で定義してあげる必要があるのは分かると思います。&lt;/p&gt;

&lt;h1 id=&#34;関数の返り値を一般化するため&#34;&gt;関数の返り値を一般化するため&lt;/h1&gt;

&lt;p&gt;これは現在のRust(rust-1.13.0)が &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1522&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;をサポートしていないために必要になるテクニックです。
関連型とトレイト境界を組み合わせて使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ReverseIter {
    type Item;
    type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;
    fn rev_iter(&amp;amp;self) -&amp;gt; Iter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの &lt;code&gt;type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt; の方です。
返り値のIteratorを抽象化したいのですが、現在のRustでは&lt;code&gt;fn rev_iter(&amp;amp;self) -&amp;gt; Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt;のような書き方が出来ないので仕方なく関連型を使ってあげる必要があります。&lt;/p&gt;

&lt;p&gt;ちょっと踏み込んだ話をすると、関数の引数の多相性は∀の量化、返り値の多相は∃の量化です。そしてトレイトのジェネリクスも∀の量化で関連型が∃の量化なのでそういう対応がある訳です。&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;結構理論的にも色々あるようなので調べてみると様々なブログポストが見付かると思います。&lt;/p&gt;

&lt;p&gt;ぱぱっと思いついたパターンを3つ挙げました。もしかしたら他にもパターンがあるかもしれません。&lt;/p&gt;

&lt;p&gt;これを知っておけば&lt;a href=&#34;https://github.com/tokio-rs/tokio-service&#34;&gt;tokio-service&lt;/a&gt;の&lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;Service&lt;/a&gt;みたいな関連型を多用するパターンでもひるまなくなります。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;h2 id=&#34;関連型とimpl-traitに関して&#34;&gt;関連型とimpl Traitに関して&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rust-lang-ja.org/rust-by-example/generics/assoc_items/the_problem.html&#34;&gt;関連型が必要になる状況 | Rust by Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ncameron.org/blog/abstract-return-types-aka-%60impl-trait%60/&#34;&gt;Abstract return types, aka &lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;応用&#34;&gt;応用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2016/02/28/rustnohigherkinded_type_trait/&#34;&gt;RustのHigher-Kinded type Trait | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;発展的な話題&#34;&gt;発展的な話題&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/02/associated-type-constructors-part-1-basic-concepts-and-introduction/&#34;&gt;Associated type constructors, part 1: basic concepts and introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/03/associated-type-constructors-part-2-family-traits/&#34;&gt;Associated type constructors, part 2: family traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/04/associated-type-constructors-part-3-what-higher-kinded-types-might-look-like/&#34;&gt;Associated type constructors, part 3: What higher-kinded types might look like&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/09/associated-type-constructors-part-4-unifying-atc-and-hkt/&#34;&gt;Associated type constructors, part 4: Unifying ATC and HKT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1598&#34;&gt;Associated type constructors (a form of higher-kinded polymorphism). by withoutboats · Pull Request #1598 · rust-lang/rfcs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustの話とリソースの話</title>
      <link>/slide/Rustnohanashitoriso_sunohanashi/</link>
      <pubDate>Sun, 20 Nov 2016 14:08:07 +0900</pubDate>
      
      <guid>/slide/Rustnohanashitoriso_sunohanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustの話とリソースの話
----------------------
[RustのLT会！ Rust入門者の集い](https://rust.connpass.com/event/41467/)  
2016-11-21

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 若者
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます
 * [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)の翻訳
 * [Join rust-jp on Slack!](http://rust-jp.herokuapp.com/) にもいます。
 * [Rust その2 Advent Calendar 2016 - Qiita](http://qiita.com/advent-calendar/2016/rust-lang-2)

===

# 注意
------

* たまにマニアックな話が出ますが気にせず無視して下さい
* 「なんかRustすげー」って思ってもらえれば幸いです


===

# Rustとの出会い
----------------

* 元々Lisperだった
* 他にはML, Ruby, JVM言語など

===

![lis books](/images/rust-and-resource/lisp.jpg)&lt;!-- .element: height=&#34;640px&#34; --&gt;

===

&lt;span style=&#34;font-size: 150%&#34;&gt;「Lisperは自分で処理系作って一人前」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![compiler books](/images/rust-and-resource/compiler.jpg) &lt;!-- .element: height=&#34;640px&#34;&#34; --&gt;

===

# 苦悩
-------

* Cは低級すぎる
* Javaは向いてない
* C++は怖そう
  + 闇の軍団
  + 縄文土器飛んできそう
  + あと **nullあるしメモリ破壊あるし**
* MLは向いてるけどシステムプログラミングしづらい
* ATS2, Golang, D...

===

# Rustと出会う
----------------

* 正直最初は色物言語と思ってた
* 調べてみたら気に入った

===

# ゼロコスト抽象化
----------------------------

``` rust
fn sum_pos(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    v.iter().filter(|i| **i &gt; 0).sum()
```

===

高階関数が消えた…！？

``` asm
_ZN21higher_order_function7sum_pos17h2f9de4f69306ec0aE:
	.cfi_startproc
	movq	(%rdi), %rcx
	movq	16(%rdi), %rax
	leaq	(%rcx,%rax,4), %rdx
	xorl	%eax, %eax
	jmp	.LBB0_1
.LBB0_3:
	addl	%esi, %eax
	.p2align	4, 0x90
.LBB0_1:
	cmpq	%rcx, %rdx
	je	.LBB0_4
	movl	(%rcx), %esi
	addq	$4, %rcx
	testl	%esi, %esi
	jle	.LBB0_1
	jmp	.LBB0_3
.LBB0_4:
	retq
```

===


# スタックとヒープ
------------------


* Rustは手で割り当てを変えられる
* 「ヒープを使ったら負け」ゲームが出来る
* ループの中でヒープアロケートしたくないよね

===

# マクロとコンパイラプラグイン
-----------------------------

例えば正規表現リテラルを作れるか、とか。

1. Common Lisp
2. 衛生的マクロ + 手続的マクロ &lt;- Rust
2. 衛生的マクロ + コンパイラプラグイン &lt;- Rust
3. 手続的マクロ
4. コンパイラプラグイン
4. 衛生的マクロ

===

# トレイト
----------

* 型クラス
  + 継承を駆逐する
  + MLにも欲しい超便利機能
* 関連型
  + 表現力が高いことが知られている
  + CF [Rustの型レベルLispっぽいの作った | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/11/06/rustnokatareberulispppoinotsukutta/)

===

# パターンマッチ、代数的データ型
-------------------------------

* 便利ってかないと困る

``` rust
    match expr {
        &amp;Expr::Nil |
        &amp;Expr::EOF |
        &amp;Expr::Str(_) |
        &amp;Expr::Int(_) |
        &amp;Expr::Float(_) |
        &amp;Expr::Proc(_) =&gt; Ok(expr.clone()),
        &amp;Expr::Sym(ref name) =&gt; {
            match env.find(&amp;name.to_owned()) {
                Ok(v) =&gt; Ok(v.clone()),
                Err(m) =&gt; {
                    if name.deref() == &#34;t&#34; {
                        Ok(ksym(&#34;t&#34;))
                    } else {
                        Err(m)
                    }
                }
            }
        }
        &amp;Expr::Cons(ref car, ref cdr) =&gt; {
        ....
```


===

# C インターフェース
---------------------

* C FFI, C API共に1行
* 構造体なんかも互換

``` rust
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}
```

``` rust
#[no_mangle]
pub extern fn hello_rust() -&gt; *const u8 {
    &#34;Hello, world!\0&#34;.as_ptr()
}
```


===

# ランタイムなし
---------------

* [RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/)
* [Writing an OS in Rust](http://os.phil-opp.com/)
* [Redox - Your Next(Gen) OS](http://www.redox-os.org/)

===

# 生ポインタ
------------

* Cとのやりとりで大事
* あるいはパフォーマンスチューニングに

``` rust
pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}
```

``` rust
unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Vec&lt;T&gt;
```


===

# エラー処理
------------

* 例外じゃない
* [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html)
* `?` (元 `try!`)も便利
* Erro as a data
* 巻き戻し例外って扱い難しいよね
  + 値継続と例外継続の使い分けつらい

===

# リソースの話（本題）
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# リソースの重要性
-------------------

* プログラムはIOの塊、すなわりリソースの塊
* 従来は手動で管理するかGCで管理するかしていた
* RustはGCを使わず自動で管理する
* 所有権の概念が「ただの自動」以上に便利

===

# メモリ管理
------------

* Cでいう`free`を自動で挟んでくれる
* 基本

===

# Vecとslice
-------------

* sliceを`Vec`のviewとして使える
  + zero copy
  + 例えばJavaとかだと出来ない
* zero copy parserとかも書ける

===

# `File` 、 `Lock`
------------------

* `Drop`があるので自動
* ところでGCがあるのに手動で管理する言語があるらしいですね
  + 例えばRubyの`File.open(..) do ... end` も半手動
  + GCで処理すべきなのに手で`do ... end`を書いてる

===

# Rust
-------

``` rust
let file = File::open(&#34;text.txs&#34;).unwrap();
let mut br = BufReader::new(file);
...
```


===

# Java
-------
※try-with-resourceを使うともっと簡単に書けます。極端な比較のためにこう書いてます

``` java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader(&#34;test.txt&#34;));
    ...
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (br != null)
        try {
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
}
```

===

# Use after close
------------------

* プログラミングエラーの一種
* あらゆるリソースで起きうる
* GCのある言語ではメモリでのエラー **のみ** 防げる
* 他のリソースだとダメ
* Rustは **全ての** リソースで防げる

===

# Ruby
------

``` ruby
file = nil
File.open(&#34;file.rb&#34;) do |f|
  file = f
end
puts file.read

```

```
#&lt;File:file.rb (closed)&gt;
file.rb:6:in `read&#39;: closed stream (IOError)
        from file.rb:6:in `&lt;main&gt;&#39;
```


===

# Rust
-------

* 所有権のある限り勝手に`close`されない

``` rust
let mut file = None;
{
  let f = File::open(&#34;file.rs&#34;).unwrap();
  file = Some(f);
}
let mut s = String::new();
file.unwrap().read_to_string(&amp;mut s).unwrap();
println!(&#34;{}&#34;, s);
```

===

# ラッパーオブジェクト
--------------------

* 所有権便利って話

===

# Scala
------

``` scala
val kc = new KafkaProducer(...)
val sk = new SimpleKafkaClient(kc)
kc.close // &lt;- !?!?!?
...
```

===

# Rust
-------

``` rust
let kc = KafkaClient(...);
val mut sk = SimpleKafkaClient(kc);
kc.close(); // &lt;- Compile error because kc has been moved
```

===

# 責任者問題
-----------

* ラッパーオブジェクトの続き
* ラップされたオブジェクトは誰が閉じるの？


===

# Scala
------

``` scala
val kc = new KafkaProducer(...)
val sk = new SimpleKafkaClient(kc)
...
sk.close
kc.close // 本当に必要？
```

===

# Rust
-------

``` rust
let kc = KafkaClient(...);
val mut sk = SimpleKafkaClient(kc); // ここでmove
...
sk.close(); // moveされたskがcolseすることが型で分かる
```

===

# まとめ
--------

* Rust = 便利機能詰め合わせ + 所有権
* さらにランタイムもないしCとの相互連携も出来る
* リソース管理って大事
* 所有権は制限だけじゃないよ



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>