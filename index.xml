<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 May 2015 00:24:08 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>21世紀のエンジニアのためのHTTP/2入門</title>
      <link>http://keens.github.io/slide/21seikinoenjinianotamenoHTTP_2nyuumon/</link>
      <pubDate>Mon, 18 May 2015 00:24:08 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/21seikinoenjinianotamenoHTTP_2nyuumon/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 21世紀のエンジニアのためのHTTP/2入門
----------------------
サイバーエージェントFresh勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# HTTPについて
-------------

* 1990年誕生の骨董仕様
* Human Readableなテキストベース
* パフォーマンスはあまり考慮してない


# HTTP/1.1の限界
---------------

* フォーマットがゆるふわでパースしづらい
* 何度も似たようなヘッダをる
  + 割とネットワーク負荷が高い
* 基本1コネクションにつき1ファイルの送受信
  + 短命なコネクションをいくつも張ることになる
  + コネクションが&#34;ウォームアップ&#34;する前に切れる
* Head of Line Blocking
  + 遅いコンテンツをダウンロードしてると他のコンテンツがダウンロード出来なくなる


```
GET / HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ja
Accept-Encoding: gzip, deflate
Cookie: _ga=GA1.1.1989570020.1429589222; __utma=111872281.1989570020.1429589222.1430193585.1431477266.5; __utmz=111872281.1429589222.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmc=111872281
Connection: keep-alive
Cache-Control: max-age=0
```



```
GET /js/todo.js HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0
Accept: */*
Accept-Language: ja
Accept-Encoding: gzip, deflate
Referer: http://localhost:8080/
Cookie: _ga=GA1.1.1989570020.1429589222; __utma=111872281.1989570020.1429589222.1430193585.1431477266.5; __utmz=111872281.1429589222.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmc=111872281
Connection: keep-alive
Cache-Control: max-age=0
```



```
GET /style/main.css HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0
Accept: text/css,*/*;q=0.1
Accept-Language: ja
Accept-Encoding: gzip, deflate
Referer: http://localhost:8080/
Cookie: _ga=GA1.1.1989570020.1429589222; __utma=111872281.1989570020.1429589222.1430193585.1431477266.5; __utmz=111872281.1429589222.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmc=111872281
Connection: keep-alive
Cache-Control: max-age=0
```

# 涙ぐましい努力
--------------
何度もリクエストをしないためにファイル数を減らす様々な努力がされてきた

* css/js concatenation
  + cssやjsを1つのファイルにまとめてアクセスを減らす
* image inlining
  + 画像をBase64エンコードしてCSS内に埋め込む
* image sprite
  + 複数の画像を1まとめにして表示する時に切り出して使う
* 並列アクセス
  + ブラウザは最大6並列でサーバにアクセスする

# HTTP/2

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# HTTP/2
--------

* 2015-05-15(先週の金曜)に[RFC化](http://jxck.hatenablog.com/entry/http2-rfc7540)
* HTTP/1.1に限界を感じたGoogleによって作られたSPDYがベース
  + 現実の問題を解決している
  + 新しいがある程度の信頼性もある
* これから広まっていく


# HTTP/2の特徴
-------------

* 接続開始はHTTP/1.1のUpgradeを使う。
  + HTTP/1.1と共存可能
* バイナリベースになってパースが楽に
* セマンティクスはHTTP/1.xのものを保持
* ヘッタの圧縮も行なう([HPACK](http://http2.github.io/http2-spec/compression.html#indexing.tables))
* プロキシやリバースプロキシの存在も織り込んだ仕様(Hop by Hop)
* その他拡張も多数

CF [HTTP/2の現状とこれから](http://www.slideshare.net/shigeki_ohtsu/http2-ohtsu-html5conf2015)

## セマンティクスの保持
--------------------

* HTTP/2 -&gt; HTTP/1.xへの変換が可能
* つまり、(リバース)プロキシの内側は1.x、外側は2が可能
  + アプリケーションはいじらずにフロント側が対応すればすぐに使える

CF [nghttpx](http://qiita.com/tatsuhiro-t/items/99a2fd61d0fb16d7241b)

## セマンティクスの保持
--------------------

こういうことが可能

```
+------+           +-------+             +---+
|Client|-[HTTP/2]-&gt;|R.Proxy|-[HTTP/1.1]-&gt;|App|
+------+           +-------+             +---+
```


## HPACK
--------

* よく使うヘッダは数値で表わす
  + Static Table
* 以前送ったヘッダも数値で表わせる
  + Dynamic Table
* それ以外もハフマン符号で圧縮可能


# HTTP/2の新機能
---------------

* ストリーム
* フロー制御
* サーバープッシュ


# ストリーム
------------

* ストリームは論理的なもの
* 1つのコネクション内で複数のストリームを作れる
  + 1コネクション内で複数のファイルをやりとり出来る
  + さらに、1コネクション内で並列に複数のファイルをやりとり出来る
* 短命なコネクションをいくつも張るよりずっと効率的
  + コネクションの性能をほぼフルで使い切れるようになった

# フロー制御
------------

スライド略。

[HTTP2 のフロー制御 - Qiita](http://qiita.com/Jxck_/items/622162ad8bcb69fa043d)

&gt;具体的な状況はいくつか考えられます。
&gt;
&gt; * 大きなファイルの通信が帯域を食いつぶし、他の通信を妨害する。
&gt; * あるリクエストの処理にサーバがかかりっきりになり、他のリクエストをサーバが処理してくれなくなる。
&gt; * 高速なアップロードを行うクライアントと、低速な書き込みをしているサーバとの間に挟まったプロキシが、調整のためにデータを貯めているバッファが溢れる。


# プライオーリティ制御
---------------------

* ストリームの存在が念頭にある
* 複数のストリームの内どれを優先させるかを決める
  + CSSは描画に必要だから優先度高、画像は後で良いから優先度低など
* ブラウザが要求する時に指定出来るし、サーバが指定することも出来る

CF [HTTP2 のプライオリティ制御 - Qiita](http://qiita.com/Jxck_/items/16a5a9e9983e9ea1129f)

# サーバープッシュ
----------------

* サーバが自発的にコンテンツを送れる
  + 今までは必ずクライアントがリクエストを送らないとレスポンスが返せなかった
* サーバがコンテンツの内容を分かってるなら先にコンテンツを送ることが可能
  + 例えばHTMLを生成する前に静的コンテンツを送ればレンダリング完了までの時間が速くなる
* いわゆるPush通知が可能
  + 今まではCommetやWebsocketなどで対応していた

CF [Service WorkerとHTTP/2が切り開く新しいWeb Pushの世界](http://d.hatena.ne.jp/jovi0608/20141204/1417697480)


# Availability
--------------
## ブラウザ

* Firefox 34以降（現38）
* Google Chrome 31以降 (現42)
* Opera
* IE 11 on Windows10


# Availability
--------------
## Servers
[Implementations · http2/http2-spec Wiki](https://github.com/http2/http2-spec/wiki/Implementations)
より抜粋。

![available servers according to http2 wiki](/images/http2_availability.png)


# Availability
--------------
## Servers

* Nginxを始めとして多くのサーバがHTTP/2を実装している
  + H2OのようにHTTP/2を念頭に置いて書かれたものもある
* アプリケーションサーバはそんなに多くない
  + 多分Rackなどの統一サーバインターフェースの問題

# Availability
--------------
少くともこういうことをすれば利用出来る

```
+--------+             +---------+             +-----+
|        |-[HTTP/2]---&gt;|         |             |     |
| Client |             | R.Proxy |-[HTTP/1.1]-&gt;| App |
|        |-[HTTP/1.1]-&gt;|         |             |     |
+--------+             +---------+             +-----+
```


# まとめ
--------

* HTTP/2について紹介した
* HTTP/2は現状の問題を解決する
  + サーバ/クライアント共に幸せになれる
* HTTP/2には段階的に移行出来る
  + 普及はかなり速いかもしれない
* みなさんが配属された時はHTTP/2の存在を前提としてアプリを設計しましょう

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>実装から理解するクロージャ</title>
      <link>http://keens.github.io/slide/jissoukararikaisurukuro_ja/</link>
      <pubDate>Sun, 17 May 2015 01:33:39 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/jissoukararikaisurukuro_ja/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 実装から理解するクロージャ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# クロージャとは？
-----------------

* 日本語にすると（関数）閉包
* 関数が外側のローカル変数を補足する
* 補足されたローカル変数は無限の生存期間を持つ
  + ローカル変数は本来スコープを抜けると生存期間が終わる
  + 言い換えるとグローバル変数みたいになる
  + でもあくまでスコープはローカル

# コード例
---------

```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p = genpower(2);
```

# コード例
----------

```js
p()  // =&gt; 2
p()  // =&gt; 4
p()  // =&gt; 8
x * 2 // x is not defined
```


# コード例
----------

* `p`が`n`と`x`を補足しているので関数を抜けた後も`x`と`n`は使える。
  + 関数の仮引数もローカル変数。
* でもローカル変数なので外からは見えない。



```
+-----------------------+
| function genpower(n){ |
|   var x = 1;          |
| ...   ^               |
| }     |               |
+-----------------------+
        |
 +------+
 |
+-------------+
||function(){ |
|+-- x *= n;  |
|   return x; |
| };          |
+-------------+
```



# コード例2
----------

```js
function incdec(){
    var x = 0;
    return [function(){ return ++x;},
            function(){ return --x;}];
}
var fs = incdec();
var inc = fs[0];
var dec = fs[1];
```

# コード例2
----------

```js
inc() // =&gt; 1
inc() // =&gt; 2
dec() // =&gt; 1
inc() // =&gt; 2
```

# コード例2
----------

* 同じタイミングで作られたクロージャ群は捕捉変数を共有する



```
+--------------------+
| function incdec(){ |
|   var x = 0;       |
|   ... ^            |
| }     |            |
+--------------------+
        +--------------+----+
                       |    |
+----------------------|---+|
| function(){ return ++x;} ||
+--------------------------+|
                       +----+
+----------------------|---+
| function(){ return --x;} |
+--------------------------+
```

# コード例3
----------

```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p1 = genpower(2);
var p2 = genpower(2);
```

# コード例3
----------

```js
p1()  // =&gt; 2
p1()  // =&gt; 4
p2()  // =&gt; 2
p2()  // =&gt; 4
```

# コード例3
----------

* 逆に、同じ関数から生まれても違うタイミングなら共有しない。



```
+-----------------------+ +-----------------------+
| function genpower(n){ | | function genpower(n){ |
|   var x = 1;          | |   var x = 1;          |
| ...   ^               | | ...   ^               |
| }     |               | | }     |               |
+-----------------------+ +-----------------------+
        |                         |
 +------+                  +------+
 |                         |
+-------------+           +-------------+
||function(){ |           ||function(){ |
|+-- x *= n;  |           |+-- x *= n;  |
|   return x; |           |   return x; |
| };          |           | };          |
+-------------+           +-------------+

```

# 実装方法
----------

* ここでは複数ある実装方法のうちの1つを紹介する。
* 言語はVM型のインタプリタ（大抵のインタプリタの実装に同じ）を仮定する


# 用語整理
----------
* `outer`から見たら`x`は捕捉(Captured)変数
  + `inner`から捕捉されてるから
* `inner`から見たら`x`は自由(Free)変数
  + `inner`からしたら`x`は知らない子だから

```js
function outer(x) {
    function inner(y){
        return x * y;
    }
}
```


# 実装概要
----------

* **クロージャとは捕捉変数の集まり**
  + つまり、捕捉した側ではなくされた側が作る
  + 捕捉した側は作られたものを参照するだけ

# 変数の話
---------

* グローバル変数はヒープ領域に置かれる
  + グローバル DB（大抵巨大なハッシュテーブル）に登録される
* ローカル変数はコールスタックに置かれる
  + 配列が作られ、インデックスでアクセスされる感じ。
  + ローカル変数の数は関数定義時に決定するので配列で管理出来る
  + 関数の実引数も同じように置かれる

# 捕捉変数の話
-------------

* 捕捉変数はヒープ領域に置かれる
  + 簡単には小さなハッシュテーブルに登録される
    - つまり、グローバル変数と同じ
    - 捕捉変数も関数定義時に決定するので配列でも管理出来る
  + ハッシュテーブル/配列はクロージャ毎に作られる

※ [本気出した実装](http://practical-scheme.net/docs/stack-j.html)だとコールスタックでどうにかすることもある


```js
var g = 1;
function sample(a) {
    var l = 2;
    var c = 3;
    return function(){ return c;};
}
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;



```
| ....          |
|---------------|
| args[0] = _   | a
|---------------| 
| locals[0] = 1 | var l
|---------------|--コールスタック↑--
| ....          |
| ....          |
|---------------|--ヒープ領域↓--
| caps[c] = 3   | var c = 3
|---------------|
| global[g] = 1 | var g = 1
| global[_] = _ |
| ....          |
| ....          |

```


```js
function incdec(){
    var x = 0;
    return [function(){ return ++x;},
            function(){ return --x;}];
}
var fs = incdec();
var inc = fs[0];
var dec = fs[1];
```


```
| ....          |
|---------------|--ヒープ領域↓--
| caps[x] = 0 &lt;-++------------------------+
|---------------|| +----------------------|---+
| global[_] = _ || | function(){ return ++x;} |
| ....          || +--------------------------+
| ....          |+------------------------+
| ....          |  +----------------------|---+
| ....          |  | function(){ return --x;} |
| ....          |  +--------------------------+
| ....          |
| ....          |
| ....          |

```


```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p1 = genpower(2);
var p2 = genpower(2);
```

AA略

```
| ....          |
|---------------|--ヒープ領域↓--
| caps[x] = 0 &lt;-+-|p1|
|---------------|
| caps[x] = 0 &lt;-+-|p2|
|---------------|
| global[_] = _ |
| ....          |
| ....          |

```


# 捕捉変数の実装
-----------------

* クロージャ毎にcapturedが作られる
* capturedとlocalはソース上の見た目は似ているが実装は大きく異なる
  + 多分この所為で分かりづらい
* グローバルアクセス出来ないだけでグローバル変数に似ている

# まとまってないけどまとめ
-------------------------

* クロージャについて説明した
* クロージャの正体は捕捉変数の集まり
* 捕捉変数はヒープ領域に置かれるローカルスコープな変数

※あくまで実装の1例です

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>正規表現技術入門を読んだ</title>
      <link>http://keens.github.io/blog/2015/05/10/seikihyougengijutsunyuumonwoyonda</link>
      <pubDate>Sun, 10 May 2015 20:32:45 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/10/seikihyougengijutsunyuumonwoyonda</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;http://gihyo.jp/book/2015/978-4-7741-7270-5&#34;&gt;正規表現技術入門&lt;/a&gt;という本の書評が望まれているようなので今日買ってきて読みました。&lt;/p&gt;

&lt;h1 id=&#34;私のバックグラウンドと目的:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;私のバックグラウンドと目的&lt;/h1&gt;

&lt;p&gt;バックグラウンドは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RubyとUnixの正規表現はそこそこ使ってる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/478191229X/ref=pd_lpo_sbs_dp_ss_1?pf_rd_p=187205609&amp;amp;pf_rd_s=lpo-top-stripe&amp;amp;pf_rd_t=201&amp;amp;pf_rd_i=4781905862&amp;amp;pf_rd_m=AN1VRQENFRJN5&amp;amp;pf_rd_r=0R2GCT6BYGWFR0061YND&#34;&gt;ドラゴンブック&lt;/a&gt;は読んだことある&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://swtch.com/~rsc/regexp/regexp1.html&#34;&gt;RE2&lt;/a&gt;の概略も知ってる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/picrin-scheme/picrin&#34;&gt;VMベースの言語処理系&lt;/a&gt;のコミッタなのでVMへの理解もある&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bleis-tift/SmlSharpContrib/pull/20/files&#34;&gt;Standard MLの正規表現エンジン&lt;/a&gt;を開発中。機能はほぼ揃ってる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;な感じです。で、実装中の正規表現エンジンがこの本で紹介されてるVM型でもDFA型でもなくVM型の素朴な形、ASTのインタプリタで
実装されてるので&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;インタプリタのまま追加出来る機能はないか&lt;/li&gt;
&lt;li&gt;高速化を目指すならVM化とDFA化どちらがいいか&lt;/li&gt;
&lt;li&gt;(既存のSMLの正規表現エンジンではVMバックエンドやDFAバックエンドでグルーピングが使えないので)高速な手法でのグルーピングの実装方法が知りたい&lt;/li&gt;
&lt;li&gt;後方参照の実装方法が知りたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などの目的で読みました。割とガチめですね。そういうことを念頭に置いてこの書評を読んで下さい。&lt;/p&gt;

&lt;h1 id=&#34;書評:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;書評&lt;/h1&gt;

&lt;h2 id=&#34;1章-正規表現:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;1章 正規表現&lt;/h2&gt;

&lt;p&gt;正規表現とはなんぞや？から入り使われる記号などを解説してます。「日本酒うめえwww」など出てきてしかも「草を生やす」の意味の解説がありました。フランクですね。
はいはい、と読み進めていったら先読み、後読みなどのあまり理解してない機能の解説やさらに上手い使い方も紹介されておお！となりました。例えばhoge、fuga、piyoの3つが含まれる文字列は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(?=.*hoge.*)(?=.*fuga.*)(?=.*piyo.*).*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けるそうです。飽くまで先読みは文字列ではなく位置にマッチするため、正規表現の重ね合わせが出来るんですね。本来ならhoge、fuga、piyoが3!通りの並び方をするので6つの分岐をしないといけない。&lt;/p&gt;

&lt;p&gt;あと、貪欲、非貪欲の他に強欲マッチなるものを知りました。確かに実装側としては貪欲マッチでバックトラックしてるところが無駄に複雑になるので強欲マッチがあるとありがたいですね。&lt;/p&gt;

&lt;p&gt;正規表現の再帰の話もありました。&lt;code&gt;(?0)&lt;/code&gt;で全体、&lt;code&gt;(?n)&lt;/code&gt;(n &amp;gt;= 1)でグループを再帰します。予想の通りこれは正規言語ではなくなるのですが、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(\d+|\((?0)\))([-+*/](?1))*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で括弧と四則演算の式をパース出来てしまうそうです。もはやパーサジェネレータ並だなと。と思ったら後で出てくる通り対応する括弧にマッチ出来てしまうので文脈自由文法を受理するそうです。すごい。&lt;/p&gt;

&lt;p&gt;導入なので読み飛ばそうと思ったのですがちゃんと飽きさせない内容で良かったですね。&lt;/p&gt;

&lt;p&gt;あとこの章でさらっと(否定)?[先後]読みが正規言語の範疇で出来るという（私にとって）大変重要な事実が書かれてました。実装しますかな。&lt;/p&gt;

&lt;h2 id=&#34;2章-正規表現の歴史:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;2章 正規表現の歴史&lt;/h2&gt;

&lt;p&gt;一口に正規表現といっても色々あるんだよーな感じな内容。恐らく後の章で比較する時のために役者を揃える目的。&lt;/p&gt;

&lt;p&gt;「Unixの正規表現といえばEREのこととする」と書いてあったのでこの章は許さない。あとegrepを使ってる。
奴は互換性のためだけに残された非推奨コマンドで、実体は grep -Eだ。古のシェルスクリプトでもない限りgrep -Eを使え。絶対許さない。&lt;/p&gt;

&lt;h2 id=&#34;3章-プログラマのための一歩進んだ正規表現:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;3章 プログラマのための一歩進んだ正規表現&lt;/h2&gt;

&lt;p&gt;正規表現の形式的な話のあとはエンジン毎のサポートする機能の違いだとかベンチマークだとかの話。VM型とDFA型の性能特徴が出てて面白かった。&lt;/p&gt;

&lt;p&gt;そして正規表現の限界(メールアドレスの精密なバリデーションには正規表現は使えないから妥協しろ、など)にも言及。
恐らく使う側からしたらこの辺の話を聞きたかったんだろうが私はそんなに興味ない。&lt;/p&gt;

&lt;h2 id=&#34;4章-dfa型エンジン:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;4章 DFA型エンジン&lt;/h2&gt;

&lt;p&gt;オートマトンの話から入る。んでNFAからDFAを構築する話。ドラゴンブックに載ってたトンプソンのアルゴリズムや部分集合構成法が紹介されてた。
しかもPythonによる実装も載っててすごいありがたい。理論系の資料だと自然言語によるアルゴリズムだけで分かりづらいんですよねー。解説も平易。&lt;/p&gt;

&lt;p&gt;次にDFAのOn the Fly構成の話。ちゃんと載ってるのはありがたい。しかしほぼ必須の機能といいつつ参考資料が載ってないのが気になった。資料が必要ないくらい簡単なのかな。&lt;/p&gt;

&lt;p&gt;最後にDFAの良いところが載ってる。VMと比較したい人には嬉しい点ですね。&lt;/p&gt;

&lt;h2 id=&#34;5章-vm型エンジン:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;5章 VM型エンジン&lt;/h2&gt;

&lt;p&gt;トイレに行きたくてうずうずしながら読んだので少し軽めにしか読んでない（ごめんなさい）。最初はVMとはなんぞや？という話から正規表現VMの挙動について、CレベルでのAPIについて、実装についてなど。
著者が開発している鬼雲で採用されてる方式なだけあってかなり詳しくて丁寧。VMの仮想アセンブラ例とスタックの遷移なども細かく書いてある。&lt;/p&gt;

&lt;p&gt;最初に必要最小限な機能をナイーブに実装したVMのコードを紹介して読者に雰囲気を掴ませたあと徐々に最適化していき、最後は鬼雲のコードを見せます。&lt;/p&gt;

&lt;p&gt;鬼雲の拡張機能のための命令や高速化のための工夫なども載ってて実装の際にはかなり役立つ筈。ここで目的の1つであったVM方式での後方参照の実装の仕方を知ります。&lt;/p&gt;

&lt;p&gt;Unicodeつらいよねーって話とか。Unicode対応しようかと思いましたがこれ読んで諦めました。&lt;/p&gt;

&lt;p&gt;AST/バイトコードレベルでの最適化の話もありました。私がプリントしたASTが簡単になるように変換していたものや、インタプリタの機能を出来る限り小さくするためにASTレベルで実現していた機能が実は最適化だったことを知りました。&lt;/p&gt;

&lt;h2 id=&#34;正規表現エンジンの三大技術動向:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;正規表現エンジンの三大技術動向&lt;/h2&gt;

&lt;p&gt;JIT、固定文字列探索、ビットパラレルについて。やはりドラゴンブックのように古い本だとこの辺はカバーし切れない。&lt;/p&gt;

&lt;h3 id=&#34;jitの話:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;JITの話&lt;/h3&gt;

&lt;p&gt;まあ、知ってるよって思ったのですがVM命令を実際にアセンブラに変換した例が載っていて後の参考になりそうだった。あとなぜバイトコードよりJITした方が速いのかの図解がめちゃくちゃ分かりやすかった。あの図、Direct Threaded VMの説明にも使えるのでいつか説明する機会があったら参考にさせてもらいます。
ところで本に載ってた鬼雲のコードはDTにしてなかったけど簡単のためなのかな？あるいは厳格にC89に準拠するため？&lt;a href=&#34;https://github.com/picrin-scheme/picrin/blob/master/extlib/benz/vm.c#L583&#34;&gt;picrinみたく&lt;/a&gt;プリプロセッサで分岐すれば使えるのに。&lt;/p&gt;

&lt;p&gt;流石にOn the Flyコンパイルの話はなかった。まあ、あんまりメリットないしやんないか。&lt;/p&gt;

&lt;h3 id=&#34;固定文字列探索の話:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;固定文字列探索の話&lt;/h3&gt;

&lt;p&gt;grepよりgrep -Fの方が速いよねーって話かと思ったらそれだけではなかった。&lt;code&gt;http://([^/?#]*)?([?#]*)(\?([^#]*))?(#(.*))?&lt;/code&gt;みたいな正規表現にマッチさせる時に、まず &lt;code&gt;http://&lt;/code&gt; を固定文字列探索で高速に見付けてからそこを起点にマッチを始める高速化手法があるそうです。固定文字列探索が高速なのはQuick Search（多分尺取り法と同じ）などのアルゴリズムがあるからですねー。あとSIMDやAVXも使える。さらに今回の&lt;code&gt;http://&lt;/code&gt;みたいな&amp;rdquo;キーワード&amp;rdquo;を抽出する技術の話も。&lt;/p&gt;

&lt;h3 id=&#34;ビットパラレルの話:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;ビットパラレルの話&lt;/h3&gt;

&lt;p&gt;先の固定文字列探索の話に関連して。固定文字列ではなく文字クラスまで含めても高速に扱える方法。なるほど〜といったところ。SIMDやAVXが使えない/使いづらい言語でも実践出来そうでいいですね。&lt;/p&gt;

&lt;h2 id=&#34;正規表現の落とし穴:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;正規表現の落とし穴&lt;/h2&gt;

&lt;p&gt;RE2のモチベーションでもある、バックトラックによってマッチングが指数時間になってしまう問題から。「RE2使え」ってくるかと思ったらユーザーレベルでどうにかする話や正規表現の最適化の部分でどうにかする話もあった。&lt;/p&gt;

&lt;p&gt;落とし穴とその対策の話があるのですが、一番気になったのがエンジンによる挙動の違い。私の正規表現エンジンはEREを実装することを目標として、grep -Eで挙動を確かめながら実装してたのですがちょっと怪しくなってきた。&lt;/p&gt;

&lt;p&gt;マッチ戦略が最左最長か自身がないのもあるけどグルーピングの話。pythonではグループは上書きされて、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; r = re.compile(&#39;(\w+,?)*&#39;)
&amp;gt;&amp;gt;&amp;gt; re.match(&#39;apple,banana,kiwi&#39;).groups()
(&#39;kiwi&#39;,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となるそうです。最初、私の正規表現エンジンもこの挙動をしていたのですが、grep -Eは例えば&lt;code&gt;echo &#39;apple,banana,kiwi&#39; | grep -o -E &#39;([a-z],?)*&#39;&lt;/code&gt;が&lt;code&gt;apple,banana,kiwi&lt;/code&gt;を返すのでわざわざ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;| Star =&amp;gt; (case acc of
                           [] =&amp;gt; raise Parse
                         | Group(i, x) :: xs  =&amp;gt; parse(ts, Group(i, Kleene x) :: xs, e, gi)
                         | x :: xs =&amp;gt; parse(ts, Kleene x :: xs, e, gi))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように括弧の後にスターが来たら括弧の中のクリーネ閉包をとってました。まあ、実装はそれぞれらしいのでこれが間違ってる訳ではないのですがパーサを不必要に複雑にしてしまったことを反省。&lt;/p&gt;

&lt;p&gt;残りはアトミックグループの話だとか。&lt;/p&gt;

&lt;h2 id=&#34;正規表現を越えて:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;正規表現を越えて&lt;/h2&gt;

&lt;p&gt;正規表現周りのツールの紹介の後はBNF、PEGの話。恥ずかしながら、BNFの表現範囲である文脈自由言語が正規表現言語+括弧の対応だということを初め知りました。いや、もしかしたらドラゴンブックに書いてたのかもしれませんが見落してました。&lt;/p&gt;

&lt;p&gt;PEGについては、BNFあるしいいやって思ってたのですがマッチが線形時間だったりBNFで表現出来ない範囲まで表現出来たりと中々楽しそうでした。&lt;/p&gt;

&lt;p&gt;あとまさかの「草生やす」の説明をした伏線を回収。&lt;/p&gt;

&lt;h2 id=&#34;付録a-1-正規と非正規の壁:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;付録A.1 正規と非正規の壁&lt;/h2&gt;

&lt;p&gt;正規言語の話とその辺の証明。否定は正規だけど後方参照は非正規だとか。この本で一番理論寄りな話でありながら同値関係とは〜とかから解説していてすごい丁寧（簡単に理解出来るとは言っていない）。いや、でも本当に正規言語関連の証明が欲しかったらまずはここ参照するかってくらい丁寧ですよ。&lt;/p&gt;

&lt;h2 id=&#34;付録a-2-正規性の魅力:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;付録A.2 正規性の魅力&lt;/h2&gt;

&lt;p&gt;だんだん感想が雑になってるのからも分かる通り、この辺で力尽きたのでこの章は流しました。後日読みます。&lt;/p&gt;

&lt;h1 id=&#34;全体を通して:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;全体を通して&lt;/h1&gt;

&lt;p&gt;論文やWeb上の資料への参照をばら撒いていますが本書自体は理論寄りになりがちな正規表現の解説を平易に書いていて、かなり敷居を下げてくれたなという印象。正規表現やエンジンの歴史、それによる実装の違いなども説明しているのでこの本を持っていれば正規表現でハマるということもなくなりそう。まえがきにもある通り、Web上では断片的にしか入らない知識が1冊にまとまっている。個人的にはDFAの話をもうちょっと詳しく知りたかった。DFAを実装する時の最適化の話とか。&lt;/p&gt;

&lt;p&gt;私のように正規表現を実装したい人だけでなく「正規表現の最適化ってどこまで賢いの？」だとか「このパターンは正規表現で表現出来るの？」だとか「書いた正規表現が魔境で理解出来ないから綺麗に書きたい」だとか思ってる人にも良い本だと思います。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;http://gihyo.jp/book/2015/978-4-7741-7270-5&#34;&gt;この本&lt;/a&gt;、33,00円ですが私は4,800円でも買った。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>勉強会駆動勉強で猛勉強</title>
      <link>http://keens.github.io/slide/benkyoukaikudoubenkyoudetakeshibenkyou/</link>
      <pubDate>Wed, 06 May 2015 22:02:12 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/benkyoukaikudoubenkyoudetakeshibenkyou/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 勉強会駆動勉強で勉強
----------------------
サイバーエージェント15卒FRESH勉強会
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + 大学では非情報系の学部にいた
 + Lisp, ML, Shell Scriptあたりを書きます

# 勉強会駆動勉強
---------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 勉強会駆動勉強
---------------
## 方法

1. 勉強会を見付ける &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
2. (詳しくない内容について)トークを登録する &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
3. 期日までに勉強する &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;
4. 期日までに資料を作る &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;4&#34; --&gt;
5. 発表する &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;5&#34; --&gt;


# 勉強会駆動勉強
---------------
## ポイント

* 自分でテーマを決めてる
* 自分で期限を決めてる
* 決めた期限は強制力がある
* アプトプットする
* 質問などでフィードバックがくる


# 勉強会駆動勉強
---------------
## 身に付く力

* 素早く調べる力
* 要点を素早く見付ける力
* プレゼン資料の作成力
* プレゼン力


# 例

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 前回のRustの話
実は発表決めた時点ではRustを書いたことなかった
![Rust slide](/images/rust_slide.png)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ISUCON
勉強会じゃないけど出場を決めてから周辺の勉強を始めた
![iscon4 blog](/images/isucon4_blog.png)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# おまけ
-------
その他の勉強法

* マイナー言語式勉強法
* やっちゃれ勉強法


# マイナー言語式勉強法

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# マイナー言語式勉強法
---------------------
## 方法

* マイナー言語を始める


# マイナー言語式勉強法
---------------------
## ポイント
![lisplogo](/images/lisplogo_256.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

* 情報が少ない
* ライブラリも少ない
* でも謎技術が使われていたりする


# マイナー言語式勉強法
---------------------
## 身につく力など

* どうにかして情報を見付ける力
* 英語力
* ソースコード読解力
* ライブラリ実装する力
* 他人のソースのバグを見付ける力
* プルリク力
* RFCなどを読む力
* パラダイムが広がる
* 謎技術を使えるようになる


# やっちゃれ勉強法

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# やっちゃれ勉強法
-----------------
## 方法

* (言語/仕様に)詳しくないけどライブラリの実装始めちゃう
* やっちゃれ（やってやれ）の気持で。


# やっちゃれ勉強法
-----------------
## ポイント

* 手を動かしてる


# やっちゃれ勉強法
---------------------
## 身につく力など

* 実装力
* 仕様の理解力
* 言語への理解
* (大抵)低レベルな操作



&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ

&lt;!-- .slide: class=&#34;center&#34; --&gt;


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>tarballベースの軽量バックアップツール&#39;Sheltar&#39;を作った</title>
      <link>http://keens.github.io/blog/2015/05/06/tarballbe_sunokeiryoubakkuapputsu_rutsukutta</link>
      <pubDate>Wed, 06 May 2015 20:45:53 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/06/tarballbe_sunokeiryoubakkuapputsu_rutsukutta</guid>
      <description>

&lt;p&gt;κeenです。みなさんバックアップは何使ってますか？大抵のOSには標準でバックアップツールが付いてますがそれ使ってます？私も使ってます。
しかしやつらはそのOSでしか動かない/動かす方法があまり知られていないのでマシンがクラッシュしたりマシンを失くした時に困ります。&lt;/p&gt;

&lt;p&gt;そこで候補に上がるのが安心と信頼のtarballですが今度は増分バックアップが取りづらいという問題があります。なのでtarballベースの差分バックアップツールを作りました。&lt;/p&gt;

&lt;p&gt;まあ、捜せば同じようなものが色々あるでしょうが捜し回るのが面倒だし色々インストールするのも嫌なのでえいやと作ってしまいました。&lt;/p&gt;

&lt;p&gt;タイトルにある通り&lt;a href=&#34;https://github.com/KeenS/sheltar&#34;&gt;Sheltar&lt;/a&gt;といいます。ポータブルなB Shellスクリプト製です。どこでも動くと思います。バックアップ（避難）だしshellだしtarだしって適当に付けたら意外にもコンフリクトがありませんでした。しかも&lt;a href=&#34;http://ultra.wikia.com/wiki/Sheltar&#34;&gt;ウルトラ怪獣&lt;/a&gt;にも居るという奇跡的な名前です。&lt;/p&gt;

&lt;h1 id=&#34;目的:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;目的&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E5%A2%97%E5%88%86%E3%83%90%E3%83%83%E3%82%AF%E3%82%A2%E3%83%83%E3%83%97&#34;&gt;増分バックアップ&lt;/a&gt;をとる&lt;/li&gt;
&lt;li&gt;UbuntuとMac間でのデータ同期にも使いたい(家のルータがしょぼいのでrsyncを使いたくなく、USBメモリ経由とかが良い)&lt;/li&gt;
&lt;li&gt;なのでファイル形式はポータブルなtarballで&lt;/li&gt;
&lt;li&gt;メタデータとかは極力置かず、最悪他のツールからでもバックアップデータをサルベージ出来るようにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;です。 GNU tarには増分バックアップ用のオプションがありますがファイル抽出は手作業でやる必要があります。
また、(多分)BSD tarには増分バックアップ用のオプションがないのでそこもカバーする必要があるかなと思って作りました。&lt;/p&gt;

&lt;p&gt;あとオプションがあるとはいっても一々覚えてられないのでスクリプト化してしまいたかったってのもあります。&lt;/p&gt;

&lt;h1 id=&#34;使い方:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;使い方&lt;/h1&gt;

&lt;h2 id=&#34;step0:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;STEP0&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/sheltar&#34;&gt;ここ&lt;/a&gt;からSheltarを入手しましょう。&lt;code&gt;sheltar&lt;/code&gt;スクリプト1つで完結しているのでcloneしなくてもrawをwgetしてきても大丈夫です。&lt;/p&gt;

&lt;h2 id=&#34;step1:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;STEP1&lt;/h2&gt;

&lt;p&gt;増分バックアップなので複数のtarballが作られます。バックアップ用のディレクトリを用意しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir /mnt/dev1/backup
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step2:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;STEP2&lt;/h2&gt;

&lt;p&gt;バックアップしたいファイルをリストアップしましょう。バックアップは継続的に行なうものなので1回限りのコマンドライン引数で渡す訳にはいきませんね。&lt;/p&gt;

&lt;p&gt;pngファイルをバックアップしたいとしましょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ find Pictures -name &#39;*.png&#39; &amp;gt;&amp;gt; list.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで良さそうです。ディレクトリの中身全部をバックアップしたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ echo Pictures/ &amp;gt;&amp;gt; list.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でも構いません。最後の&amp;rsquo;/&amp;lsquo;重要です。最初のバックアップの時には問題ありませんが&amp;rsquo;/&amp;lsquo;がないと増分バックアップの時にディレクトリ自体のlast modified timeを見て変更を判断します。&lt;/p&gt;

&lt;h2 id=&#34;step3:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;STEP3&lt;/h2&gt;

&lt;p&gt;あとは実行するだけですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sheltar backup /mnt/dev1/backup list.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後、増分バックアップを取るのも同じく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sheltar backup /mnt/dev1/backup list.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で可能です。前回のアーカイブファイルのlast modified time より新しいファイルだけをバックアップしてくれます。&lt;/p&gt;

&lt;p&gt;因みに今のところバックアップディレクトリに余計なものがあると正しく動作してくれないので注意です。&lt;/p&gt;

&lt;h2 id=&#34;復元:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;復元&lt;/h2&gt;

&lt;p&gt;全部のファイルをカレントディレクトリにぶちまけたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sheltar extract /mnt/dev1/backup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。抽出するファイルを指定したいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sheltar extract /mnt/dev1/backup file1 file2 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;p&gt;カレントディレクトリに同名ファイルが既にある場合は新しい方を残します。&lt;/p&gt;

&lt;h1 id=&#34;その他:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;まだまだ未完成です。欲しい機能があったら&lt;a href=&#34;https://github.com/KeenS/sheltar/issues&#34;&gt;issue&lt;/a&gt;に投げてくれると実装するかもしれません。&lt;a href=&#34;https://github.com/KeenS/sheltar/pulls&#34;&gt;Pull Request&lt;/a&gt;もお待ちしております
あと、ドックフードはまだ食べてません。一応テストはしてますが…。Macをまともに使う気になったら使い始めると思います。&lt;/p&gt;

&lt;p&gt;あ、そうそう。今回比較的コメントを多く書いたのでシェルスクリプトを勉強したい方はソース読んでみて下さい。
こんな感じです。Doxygenがシェルスクリプトに対応してないので疑似ドキュメント形式のコメントですが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Extract the all files from backups in $ST_BACKUP_DIR.
# A file with the same name as extracting file will be preserved if it is newer than its counterpart.
## @filesystem extract all the backup files to CWD
st_extract_all()
{
    # This is preferable to `for TARBALL in $(ls)` because the names of listed files
    # can contain whilespaces
    ls --sort=time -r &amp;quot;${ST_BACKUP_DIR}&amp;quot; | while read TARBALL
    do
        tar xf &amp;quot;${ST_BACKUP_DIR}/${TARBALL}&amp;quot; \
            --keep-newer-files               \
            --preserve-permissions           \
            --preserve-order
    done
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SMLを書くLisperの悩み</title>
      <link>http://keens.github.io/blog/2015/05/03/smlwokakulispernonayami</link>
      <pubDate>Sun, 03 May 2015 13:23:17 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/03/smlwokakulispernonayami</guid>
      <description>&lt;p&gt;SMLばっかり書いてたら「お前Lisperじゃないだろ」って怒られたとかそういう話ではなく。&lt;/p&gt;

&lt;p&gt;ML系の言語は関数は1つの引数しかとれません。じゃあ複数の値を受け取りたい時はどうするかというと 1. 値を組(タプル)にして受け取る 2. 関数を返す関数((を返す関数)*)にして1つづつ受け取る の2種類の方法があります。
それに纏わる話。&lt;/p&gt;

&lt;p&gt;それぞれの記法を例示すると&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;値を組(タプル)にして受け取る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun add (x, y) = x + y
add (1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは、手続型言語に似せて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;add(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするスタイルもあります&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;関数を返す関数((を返す関数)*)に(カリー化)して1つづつ受け取る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun add x y = x + y
add x y  (*= ((add x) y)  *)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。勿論、2.のように何度も関数を呼び出すよりは1.のように一度で全ての値を渡してしまった方が速い筈です。なのでプリミティブっぽい関数はタプル式にした方が良さそうです。
また、無名関数を定義する時にSMLでは&lt;code&gt;fun&lt;/code&gt;のように自動でカリー化してくれる構文がないので複数の引数を受け付ける関数を引数にとる高階関数を定義するときはタプル式の方が都合が良いでしょう。&lt;/p&gt;

&lt;p&gt;例えば二項演算子はタプル式で定義しなければなりませんし、&lt;code&gt;List.foldl&lt;/code&gt;のシグネチャも&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(&#39;a * &#39;b -&amp;gt; &#39;b) -&amp;gt; &#39;b -&amp;gt; &#39;a list -&amp;gt; &#39;b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;p&gt;勿論、積極的に最適化を行なうコンパイラではuncurry optimizationや、closure eliminationでカリー化によるオーバーヘッドはなくなります。
むしろ、カリー化した方が部分適用が出来るので利便性は上がります。となると後は無名関数の問題ですが、OCamlやHaskellなど無名関数にもカリー化した定義が出来る構文のある言語だとそれも問題なく、タプル式の引数の渡し方はしないようです。&lt;/p&gt;

&lt;p&gt;SMLは流石に&amp;rsquo;Standard&amp;rsquo;なので最適化を仮定したり余計な構文を突っ込んだりはしづらいのでしょう。なのでこの問題はSML特有のようです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ここまで、なぜタイトルがML系言語ではなくSML限定なのかの前置き。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;こういう関数呼び出しがあるとします。&lt;code&gt;sub: string * int -&amp;gt; char&lt;/code&gt;は文字列の0番目の文字を取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;sub(str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに&lt;code&gt;Char.isAlpha : char -&amp;gt; bool&lt;/code&gt;を適用します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Char.isAlpha sub(str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ、コンパイルエラーになります。みなさん何でか分かりますか？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sub(str, 0)&lt;/code&gt;はあくまで&lt;code&gt;sub&lt;/code&gt;に&lt;code&gt;(str, 0)&lt;/code&gt;というタプルを渡している文なのでコンパイラはこう解釈するのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(Char.isAlpha sub) (str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回このようなエラーを出すのが面倒なので関数の呼び出しには全て手続き型言語のように括弧をつけることを考え始めます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Char.isAlpha(sub(str, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしそうは問屋が卸さないのがカリー化された関数。&lt;code&gt;String.isPrefix: string -&amp;gt; string -&amp;gt; bool&lt;/code&gt;に次のような呼び出しをすると勿論怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;String.isPrefix(&amp;quot;/usr/local&amp;quot; path)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必ず&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;String.isPrefix &amp;quot;/usr/local&amp;quot; path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としないといけません。これまた関数呼び出しがネストすると面倒で、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;app (fn s =&amp;gt; print (s ^ &amp;quot;\n&amp;quot;)) (List.filter (String.isPrefix &amp;quot;/usr/local&amp;quot;) paths)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように毎回括弧が付き纏います。ここまでくるとS式みたく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(app (fn s =&amp;gt; print (s ^ &amp;quot;\n&amp;quot;)) (List.filter (String.isPrefix &amp;quot;/usr/local&amp;quot;) paths))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きたくなってくるのがLisperの心情。これなら慣れないデータコンストラクタや関数呼び出しや中置演算子の優先順位問題も解決!やったね!!と思ったのですがやっぱりタプル式の関数呼出が行く手を阻むのでした。
&lt;code&gt;(sub(str, i))&lt;/code&gt; とか訳分からなすぎる。括弧多すぎる。&lt;/p&gt;

&lt;p&gt;ということでどっちに揃えたら良いのかさえ分かってないのにどっちにも揃えられてないSMLに対して悩みを抱えるLisperの悩みでした。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;は&lt;code&gt;Char.isAlpha()&lt;/code&gt;のような書き方は無駄な括弧がついてると怒ってきます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#をMacでビルドする</title>
      <link>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</link>
      <pubDate>Wed, 29 Apr 2015 16:09:08 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</guid>
      <description>

&lt;p&gt;κeenです。SML#2.0.0を文鎮と化していたMBAにインストールしたのでメモをば。&lt;/p&gt;

&lt;p&gt;基本は&lt;a href=&#34;http://d.hatena.ne.jp/keita44_f4/20140412/1397279451&#34;&gt;よんたさんの記事&lt;/a&gt;をMacに翻訳した感じです。&lt;/p&gt;

&lt;p&gt;モチベーションは、&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/ja/?Download&#34;&gt;公式の配布物&lt;/a&gt;がMac版だとMacPorts版しかなく、
portsとhomebrewの混在は避けた方が良いと聞いたのでどうにかして自前ビルドしようとしたことです。&lt;/p&gt;

&lt;h1 id=&#34;注意書き:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;注意書き&lt;/h1&gt;

&lt;p&gt;冒頭にも書いてあるようにMBAは普段使ってなくて、このエントリーもMBAじゃないマシンから書いているのでコマンド類はコピペでなく写経してます。
typoがあるかもしれないのでコピペして動かなかったら一応この記事のtypoを疑って下さい。&lt;/p&gt;

&lt;h1 id=&#34;gmp32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;GMP32bitの準備&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ brew install gmp --32-bit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で終わり。バージョン6.0.0aが入りました。
既にインストールされていたら多分64bit版が入っているので一旦 &lt;code&gt;brew remove gmp&lt;/code&gt; してから再度インストールすると良いです。尚、バイナリ版はないようで、ビルドが始まります。checkに時間が掛かる。&lt;/p&gt;

&lt;h1 id=&#34;llvm34-32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;LLVM34 32bitの準備&lt;/h1&gt;

&lt;p&gt;骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://llvm.org/releases/3.4.2/llvm-3.4.2.src.tar.gz
$ gzcat llvm-3.4.2.src.tar.gz | tar xf -
$ cd llvm-3.4.2.src
$ ./configure --build=i686-mac-darwin CC=&#39;gcc -m32&#39; CXX=&#39;g++ -m32&#39; --prefix=/usr/local/Cellar/llvm34/3.4.2a
$ make -j4
$ make -j4 install
$ cd ../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら上手くいきました。何故上手くいったんでしょうねー。あとprefixは割と気持悪いのでみなさん適切な場所にインストールしましょうね。&lt;/p&gt;

&lt;h1 id=&#34;sml-のビルド:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;SML# のビルド&lt;/h1&gt;

&lt;p&gt;これが一番骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.pllab.riec.tohoku.ac.jp/smlsharp/download/smlsharp-2.0.0.tar.gz
$ gzcat smlsharp-2.0.0.tar.gz | tar xf -
$ cd smlsharp-2.0.0
$ ./configure --with-llvm=/usr/local/Cellar/llvm34/3.4.2a/      \
               LDFLAGS=&#39;-L/usr/local/Cellar/gmp/6.0.0a/lib&#39;     \
              CPPFLAGS=&#39;-I/usr/local/Cellar/gmp/6.0.0a/include&#39; \
                    CC=&#39;gcc -m32&#39;                               \
                   CXX=&#39;g++ -m32&#39;
$ make -j4
$ make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら出来ました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;誰かhomebrewにして。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispで限定継続と遊ぶ</title>
      <link>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</link>
      <pubDate>Sun, 26 Apr 2015 21:09:07 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Common Lispで限定継続と遊ぶ
----------------------
[Lisp Meet Up #27](https://atnd.org/events/64988)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# Agenda
--------

0. cl-contの紹介
1. 限定継続の話
2. 限定継続の使い方の話
3. 限定継続の実装の話


# CL-CONTの紹介

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CL-CONT
---------

* Common Lispの限定継続ライブラリ
* 結構古くからあるっぽい
* 割と色々なライブラリが使ってる

# CL-CONT
---------

![cl-cont dependers](/images/cl-cont-dependers.png)

# API
-----

* 継続を区切るマクロ
  + `with-call/cc`
  + `defun/cc`
  + `lambda/cc`
* 継続を取得するマクロ
  + `call/cc`
  + `let/cc`

※後で説明するので意味が分からなくても問題ないです。


# 限定継続の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後トップレベルに戻るまでの計算。
* Schemeが一級市民として扱えることで有名
* 値として取り出した時は0-1引数関数として振る舞う

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      □)))
```

# 継続とは
----------
あとはそれを関数にするだけ

```lisp
(lambda (k)
  (mapc #&#39;writ-line
        (loop :for x :in list
           :collect (if (evenp x)
                        k))))
```


# 限定継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後 *指定した位置* に戻るまでの計算。
* 継続がトップレベルまで戻るのに対して限定継続途中で止まる。それだけ。
* 部分継続などの言い方もある
  + 英語もpart contとdelimited contで分かれる


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(loop :for x :in list
           :collect (if (evenp x)
                        □))
```


# 限定継続とは
-------------

```lisp
(lambda (k)
  (loop :for x :in list
     :collect (if (evenp x)
                  k)))
```

# 限定継続の挙動
---------------
普通のやつ

```lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```

これは

```lisp
(+ 1 2)
```

と等価

# 限定継続の挙動
---------------
今度は継続を呼ばないでみる

```lisp
(with-call/cc
  (+ 1 (call/cc (lambda (k) 2))))
```

これは

```lisp
2
```

と等価

# 限定継続の挙動
---------------
もうちょっと呼ばない例  
(`(let/cc k ...)` = `(call/cc (lambda (k) ...))`)

```lisp
(with-call/cc
  (write-line &#34;hello&#34;)
  (let/cc k 1)
  (write-line &#34;world&#34;))
```

は

```lisp
(progn
  (write-line &#34;hello&#34;)
  1)
```

と等価


# 限定継続の使い方の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の使い方の話
---------------------

* グリーンスレッド
* コールバックを綺麗に書き換える
* 非決定性計算
* etc...


## グリーンスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


## グリーンスレッド
-----------------

* またの名をコルーチン
* またの名を強調スレッド



## グリーンスレッド
-----------------

```lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```

## グリーンスレッド
-----------------
実行結果

```
in thread A 1
in main thread 1
in thread A 2
in main thread 2
in thread A 2
in main thread 3

```


## コールバックの書き換え

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## コールバックの書き換え
----------------------
本当はこう書きたい

```lisp
(with-event-loop
    (format t &#34;Hello, ~a!~%&#34; (async-read stream)))
```

## コールバックの書き換え
----------------------
しかしライブラリがコールバック関数を要求してくる

```lisp
(with-event-loop
    (async-read stream (lambda (line)
                         (format t &#34;Hello, ~a!~%&#34; line))))
```

## コールバックの書き換え
-----------------------
コールバック = 限定継続（後述）なのでこうしてやれば良い。

```lisp
(with-event-loop
    (with-call/cc
      (format t &#34;Hello, ~a!~%&#34;
              (call/cc (lambda (k))
                       (async-read stream k)))))
```

## 非決定性計算

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## 非決定性計算
-------------
### ベースアイディア

* 継続を関数として取り出した後同じ処理を何回も実行出来るんじゃね？


## 非決定性計算
-------------
### ベースアイディア
複数回呼び出してみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (list (funcall c 1)
        (funcall c 2)
        (funcall c 3)))
```


## 非決定性計算
-------------
### ベースアイディア
普通の1引数関数として使ってみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (mapcar c (list 1 2 3)))
```

## 非決定性計算
-------------
### ベースアイディア
マクロでラップしてみる

```lisp
(defmacro for (&amp;body expr)
  `(with-call/cc ,@expr))
(defmacro in (m)
  `(let/cc k (apply #&#39;append (mapcar k ,m))))
(defun yield (x) (list x))
(defun unit () nil)
```


## 非決定性計算
-------------
使ってみる

```lisp
(for
  (let ((x (in &#39;(1 2 3)))
        (y (in &#39;(a b c))))
    (yield (cons x y))))
```

```
((1 . A) (1 . B) (1 . C) (2 . A) (2 . B) (2 . C) (3 . A) (3 . B) (3 . C))
```


# 限定継続の実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の実装の話
-------------------

* 継続は0~1引数関数として取り出せるのであった。
  + 実は機械的に取り出せる
* 継続は全ての式に暗黙に存在するのであった
  + 全ての式を継続を明示的に使うようにも出来る


# CPS変換

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CPS変換
---------

* 全ての関数の引数を1つ増やして、そこで継続を受け取る
* 値を返す時は暗黙のreturnを使うのではなく明示的に継続を呼ぶ
* 関数を呼ぶ時は必ず継続を渡す。呼び出し元には返ってこない（自然と末尾再帰になる）


# CPS変換
---------
例えば

```lisp
(with-call/cc
  (foo (call/cc
        (lambda (k)
          (funcall k 2)))))
```

は、取り出された継続が

```lisp
(lambda (k) (foo k))
```

。


# CPS変換
---------
よって

```lisp
((lambda (k) (foo k)) 2)
```

と変換される


# CPS変換
---------
再帰関数だと少し面倒

```lisp
(defun fact (n)
  (if (&lt;= n)
      1
      (* n (fact (- n 1))))))

```

が

```lisp
(defun fact (n c)
  (if (&lt;= n)
      (c 1)
      (fact (- n 1) (lambda (v) (* n v)))))
```

となる


# CPS変換
---------

* CPS変換を行なうことでいつでも継続を値として使える


# 限定継続の実装の話
-------------------

* CPS変換を裏で行なっている
* 自動で出来るのでマクロで変換をしている
  + 組み込み関数は変更出来ないので特別扱い
  + スペシャルフォームも気をつける必要がある
* `lambda`が乱立するのでパフォーマンスは酷い。


# まとめ
-------

* cl-contというライブラリがあって、限定継続が扱える
* 限定継続は処理を中断したり再開したり繰り返したりに使える
* 裏ではえげつないことをやっている
* パフォーマンスが必要なところでは使っちゃダメ


# 参考
------
* [picrin/partcont.scm at master · picrin-scheme/picrin](https://github.com/picrin-scheme/picrin)
* [cl-cont | Quickdocs](http://quickdocs.org/cl-cont/)
* [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)
* [継続渡しスタイル - Wikipedia](http://ja.wikipedia.org/wiki/%E7%B6%99%E7%B6%9A%E6%B8%A1%E3%81%97%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB)
* [M.Hiroi&#39;s Home Page / お気楽 Scheme プログラミング入門](http://www.geocities.jp/m_hiroi/func/abcscm20.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>非同期処理の「その後」の話。goto、継続、限定継続、CPS、そしてコールバック地獄。</title>
      <link>http://keens.github.io/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</link>
      <pubDate>Sat, 25 Apr 2015 23:44:46 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 非同期処理の「その後」の話
----------------------
## goto、継続、限定継続、CPS、そしてコールバック地獄

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# 同期処理とは
-------------
通常、外部とやりとり(I/O)する時に待ち時間(ブロック)が発生する。

![sync task image](/images/sync.png)


# 非同期処理とは
---------------
待ち時間に(ブロックせずに)別の処理をしようという発想。

![async task image](/images/async.png)

# 非同期処理の裏側
-----------------
処理Aと処理Bの他にいつどっちを動かすかを決めるスケジューラが存在することが多い

![async scheduler image](/images/async_scheduler.png)


# どうやって戻る問題
-------------------
* 一時停止した後「その後」の処理にどうやって戻るか

![cont image](/images/cont.png)

# 「その後」とは
-----------

```C
...
fputc(c); // ここの処理でI/Oが入る
// 再開する時にここに戻ってきたい
printf(&#34;Work done&#34;);
...
```

# GOTO
------
`goto` を使えば戻れる

```C
...
  fputc(c); // ここの処理でI/Oが入る
  // 再開する時にここに戻ってきたい
RESTART:
  printf(&#34;Work done&#34;);
...
```

# GOTOの問題
------------
こういうコードだとGOTOでは困る

```C
if ((c = fgetc(f)) != -1)
...
```


# GOTOの問題
------------
こんな区切り方をしたい

![cont in code image](/images/codecont.png)


# GOTOの問題
------------

* 式の途中に入れない
* 値を返せない
* I/Oが終わった「その後」が思ったより複雑

# &#34;継続&#34;という概念
-----------------

* continuation
* ここで言ってる「その後」に名前をつけたもの
* その後に行なわれる全ての処理のこと
* 全ての言語に存在する


# (限定)継続を値として扱える言語
------------------------------
値としての継続はちょっとリッチになったGOTO程度。

* Scheme
* OchaCaml
* SML/NJ
* (Ruby)
* etc.


## 正確には限定継続
------------------

* 細かい話だが継続と言うと処理Aとスケジューラ全てを含んでしまうので
今回欲しいのは処理Aの中に限定した限定継続
* 継続を値として扱えれば限定継続を[実装出来る]()ので今回はそこまで深く違いを気にする必要はない


## 正確には限定継続
------------------

![continuation image](/images/continuation.png)


## 正確には限定継続
------------------

![partcont image](/images/partcont.png)


# 限定継続を使った非同期処理の例
------------------------------
Cの例をSchemeに翻訳してみる

```scheme
(if (/= (read-char f) -1)
    ...)
```


# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```


# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme

  (if (/= 
                  (async-read-char f  )
          -1)
      ...)

```


# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(if (/= (read-char f) -1)
    ...)
```


# ここまでのまとめ
-----------------

* 非同期処理を行なう時に継続という概念が出てくる
* 継続を値として扱える言語もある
* 値としての継続は1引数関数として振る舞う
* そのような言語ではユーザレベルで非同期処理をサポート出来る


# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 先に言ったように全ての言語に継続が存在する
  * マシン語レベルでjump命令とほぼ同じ
* 言語処理系レベルで継続を取り出せば使える
* 要は組込み機能


# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 処理系にそこまで求めるのは酷
  * バグり易い
  * デバッグし辛い
* 処理系はもっと別のことに専念すべき
* 機能が追加修正される度に処理系をアップグレードしないといけない

実は継続を値として扱えない言語でもユーザレベルで継続を値として取り出す方法がある


## Continuation Passing Style

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CPS
-----

* 日本語にすると「継続渡し形式」
* 継続を関数として切り出して引数に渡す
  * 継続のために全ての関数の引数が1つ増える
* 継続渡し形式に変換することを「CPS変換という」
* CPS変換は機械的に出来る


# CPS変換
------------
先は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```

になった。

# CPS変換
------------
今回は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(async-read-char f
           (lambda (c) (if (/= c -1) ...)))
```

になる


# CPS変換
---------

* パっと見限定継続のコードの`lambda`の外側と内側が入れ替わる
* そんなり分かりやすくない


# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n)
  (if (&lt;= n 1)
      1
      (* n (fact (- n 1)))))
```


# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n c)
  (if (&lt;= n 1)
      (c 1)
      (fact (- n 1) (lambda (c) (* n c)))))
```

# CPS変換まとめ
--------------

* とりあえず機械的に変換できる
  + 実際、CPS変換をサポートする言語はいくつかある
    - Haskellのdo記法とか
* むしろ機械がやるべきで人間がやることではない


# コールバック地獄の正体

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも

```javascript
async_read_char(f, function(c){
    if(c === -1) {
        ...
    }
})

```


# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも

```javascript
function fact(n, callback) {
    if(n &lt;= 1)
        return callback(n);
    else
        return fact(n - 1, function(c){return n * c;})
}
```


# コールバック地獄の正体
-----------------------

* 人間が手でやることではない&#34;CPS変換&#34;を手でやらせた結果
* altJSは内部でCPS変換を行なうことで非同期プロミスなどを実現している
  + DeNAのJSXとか

# 非同期処理の実装まとめ
------------------------
下に行く程抽象度/汎用性が高い

* コールバックスタイル
  + JavaScript(&lt; ES6)とか
* 言語レベル組み込みサポート
  + C#とか
* 言語レベルCPS変換サポート
  + altJSとか
* 言語レベル(限定)継続サポート
  + Schemeとか
* ユーザーレベルでも限定継続(CPS変換)を実現出来るエレガントなマクロサポート
  * Lisp

※ネタです。マサカリ投げないで下さい。


# まとめ: なぜコールバック&#34;地獄&#34;なのか
------------------------------------

* そもそも難しいことをやろうとしている
* 難しいことをカバーするだけの言語の機能が足りてない

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpを使ってSMLのon-the-flyエラーチェック</title>
      <link>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</link>
      <pubDate>Thu, 23 Apr 2015 23:01:17 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</guid>
      <description>

&lt;p&gt;κeenです。最近SMLを結構書いてるのですが中置演算子が乱立する言語はLisperにはつらくて、しょっちゅうコンパイルエラーを出します。
そこでSML#をflymakeで動かしてOn The Flyにエラーチェックをします。&lt;/p&gt;

&lt;p&gt;なぜSML#かというと &lt;code&gt;-ftypecheck-only&lt;/code&gt; オプションがあって、シンタックスと型エラーのチェックだけを行なえるからです。&lt;/p&gt;

&lt;p&gt;色々試したのですが設定はこれだけで済みました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(eval-after-load &#39;flymake
  &#39;(progn 
    (add-to-list &#39;flymake-allowed-file-name-masks &#39;(&amp;quot;.+\\.sml$&amp;quot;
                                                    (lambda ()
                                                      (list &amp;quot;/usr/local/bin/smlsharp&amp;quot; (list &amp;quot;-ftypecheck-only&amp;quot; (buffer-file-name))))
                                                    (lambda () nil)))
    (add-to-list &#39;flymake-err-line-patterns &#39;(&amp;quot;^\\([^: ]*\\):\\([0-9]+\\)\\.\\([0-9]+\\)-[0-9]+\\.[0-9]+ \\(Error\\|Warning\\):&amp;quot;
                                              1 2 3 4))))
(add-hook &#39;sml-mode-hook #&#39;flymake-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;/usr/local/bin/smlsharp&amp;quot;&lt;/code&gt; のところは各自書き換えて下さい。尚、SML#はエラーメッセージを複数行に跨って出すのですがそれがflymakeと相性が悪いのでエラーメッセージの取得は諦めました。&lt;/p&gt;

&lt;p&gt;多くの場合、 &lt;code&gt;flymake-simple&lt;/code&gt; という枠組みの中で設定を書くのですがテンポラリファイルを作る構造がどうしてもインターフェースファイルと相性が悪かったので生のflymakeを使ってます。
というかflymakeは元々 &lt;code&gt;-ftypecheck-only&lt;/code&gt; みたいなのを前提に作られてたのに実際にコンパイル走らせないとエラーメッセージ取得出来ない言語が多過ぎてフレームワークが出来たのでこれが本来の使い方です。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:311ce9d5e51e732b1928a84bcceb27a3&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;というものがあって、スタイルワーニングを出してくれます。ただ、これはパッチを当てないと使えなかったりスタイルワーニングのみしか出さなかったりするので気が向いた時に紹介します&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>静的なメモリ管理の話。リージョン推論とλ計算からRustまで</title>
      <link>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</link>
      <pubDate>Tue, 21 Apr 2015 00:25:56 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 静的なメモリ管理の話。リージョン推論とλ計算からRustまで
----------------------
サイバーエージェント新卒エンジニア勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 大学では非情報系学科。趣味のプログラマ。
   + 非ガチ勢なので優しくして下さい&gt;&lt;
 * Lisp, Ruby, OCaml, Shell Scriptあたりを書きます


# メモリ管理の話
---------------
(一般的ではない用語)

* 弱い静的メモリ管理
* 強い動的メモリ管理
* (弱い動的メモリ管理)
* 強い静的メモリ管理


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 静的 = コンパイル時にメモリ管理が決定する

### 例

* C言語


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 利点

* 実行時は安定している

### 欠点
* バグる
* 面倒
* 危険


# メモリ管理の話
---------------
## 強い動的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* GCのある言語全般

# メモリ管理の話
---------------
## 強い動的メモリ管理
### 利点

* メモリ管理からの開放

### 欠点

* 動作が不安定 (cf [これがCassandra](http://www.slideshare.net/TakehiroTorigaki/cassandra-21191674))
* パフォーマンスの問題
* リアルタイム性の問題


# メモリ管理の話
---------------
## (弱い動的メモリ管理)
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* バグったGC
  + 普通はない
  + (参照カウント？)


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 静的 = コンパイル時にメモリ管理が決定する


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 利点

* メモリ管理からの開放
* 実行時は安定している
* リアルタイム
* パフォーマンスが出る

### 欠点

* 実現可能性は？


# 強い静的メモリ管理の話をしよう


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 強い静的メモリ管理の話をしよう
------------------------------

* まずは可能性の議論が必要
* 実現可能性
* 実用性


# 可能性の議論
-------------

* プログラミング言語の理論 ≒ λ計算
* そもそもλ計算はメモリのことを考慮してない
  + GCがあるかのように記述される


# 可能性の議論
-------------

* λ計算にメモリ管理まで含めて理論を立てたものは存在する（静的なメモリ管理）
  + リージョンというものをベースにしている [参考](http://www.elsman.com/mlkit/pdf/popl94.pdf)
* さらにリージョンを自動で推論する理論もある（強いメモリ管理）
  + リージョン推論という


# 軽くリージョンの話
-------------------

* 型と同じようにプログラム全体を伝わるメタデータ。
* データが保存される場所を指す。リージョンはいくつもある。
* リージョン推論でデータがどのリージョンに入るかが分かる
* さらにリージョンのサイズもある程度予想がつくので静的に管理出来る
* 関数などは引数のリージョンに対して多相になる「リージョン多相」などもある
* この辺は[Martin Elsmanの論文たち](http://www.elsman.com/mlkit/papers.html)を参考にして下さい
  + [A Brief Introduction to Regions](http://www.elsman.com/mlkit/pdf/ismm98.pdf)とか。



# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* 実現可能性
* 実用性

# 実現可能性

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 実現可能性
-----------

* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;Martin ElsmanによるSML処理系、[ML Kitに一部導入された](http://www.elsman.com/mlkit/pdf/pldi2002.pdf)（多分世界初）
  + 但し完全ではなく、GCと組み合わせてある
  + 動的型付き言語に無理矢理静的型を付けても完全には上手くいかないようなもの？
  + 多分リージョン推論を前提とした言語を設計する必要がある
* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;Cyclone というC likeな文法の言語が完全に[リージョン推論のみでメモリ管理を実現した](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf)


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* 実用性


# 実用性


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Rust言語
----------

* Mozillaが開発した言語
* 2008~
* Cycloneを参考にしたらしい。
* 活発に開発される
* 大きなプロジェクトに現行のレンダリングエンジン、Geckoを置き換えるべく開発された[Servo](https://github.com/servo/servo)がある
  + 既にC++製のGockoの3倍速い
  + 並列レンダリングすればさらに速い。


# Rust言語
----------

* リージョン推論(ライフタイム)でメモリを管理する
  - かなり賢くて、ヒープにアロケートする必要なけばスタックを使う。
* mallocとfreeは全てコンパイル時に自動で挿入される
* (多分)リージョン推論のみでメモリ管理するために所有権という概念がある。
  + 所有権自体は並列性の導入などにも有用だと思われる。
    -  競合状態の回避とか
* その他
  + 代数的データ型とパターンマッチ
  + トレイトベース(non-nominal)のジェネリクス

詳細は[公式ページ](http://www.rust-lang.org/)から


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* ✓ 実用性


# Rustのライフタイムと所有権
-------------------------


&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Cの例
-------

```c
{
    int *x = malloc(sizeof(int));

    // we can now do stuff with our handle x
    *x = 5;

    free(x);
}
```


# Rustに翻訳
------------

```rust
{
    let x = Box::new(5);
}
```


# 少しいじってみる
---------------

trivialに見える

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
---------------

printlnを追加してみる

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);

    println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
----------------

エラーになる。

```
error: use of moved value: `x`
   println!(&#34;{}&#34;, x);
                  ^
```


# 所有権
-------

`add_one` を呼んだ時点で所有権が `add_one` に移るので `println!` では使えない。

```rust
fn main() {
  let x = Box::new(5);

  add_one(x);

  println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 所有権
-------
新たに値を返してもらえば使える。

```rust
fn main() {
  let x = Box::new(5);

  let y = add_one(x);

  println!(&#34;{}&#34;, y);
}

fn add_one(mut num: Box&lt;i32&gt;) -&gt; Box&lt;i32&gt; {
  *num += 1;

  num
}
```


# 所有権の貸し借り
---------------

* さっきの例は面倒。
* `add_one` が `x` を奪ったのが問題。
* `x` を「借り」ることが出来る。


# 所有権の貸し借り
----------------

```rust
fn main() {
  let mut x = 5;

  add_one(&amp;mut x);

  println!(&#34;{}&#34;, x);
}

fn add_one(num: &amp;mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

先の `add_one` はライフタイム(リージョン)アノテーションを省略していた。  
省略せずに書くとこうなる。(リージョン多相)

```rust
fn add_one&lt;&#39;a&gt;(num: &amp;&#39;a mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

スコープの終わりでライフタイムが終わる。

```rust
fn main() {
  let y = &amp;5;     // -+ y goes into scope
                  //  |
  // stuff        //  |
                  //  |
}                 // -+ y goes out of scope
```


# LTの明示的宣言
--------------
こんな構造体を宣言したとする。 `x` はコンストラクタに渡された値のライフタイムを引き継ぐ。

```rust
struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}
```


# LTの明示的宣言
--------------
`f.x`のライフタイムが `y` のライフタイムに制限されるので
`y` より広いスコープにある `x` には代入出来ない。

```rust
fn main() {
  let x;                  // -+ x goes into scope
                          //  |
  {                       //  |
    let y = &amp;5;           // ---+ y goes into scope
    let f = Foo { x: y }; // ---+ f goes into scope
    x = &amp;f.x;             //  | | error here
  }                       // ---+ f and y go out of scope
                          //  |
  println!(&#34;{}&#34;, x);      //  |
}                         // -+ x goes out of scope
```


# まとめ
-------

* メモリ管理の性質についてまとめた
* 静的メモリ管理が出来れば
  + メモリ管理からの開放
  + 実行時は安定している
  + リアルタイム
  + パフォーマンスが出る
* 強い静的メモリ管理の手法としてリージョン推論がある
* Rust言語がリージョン推論を利用している。
* Rustをみんな使おう!


# 参考
* [ML Kit](http://www.elsman.com/mlkit/)
* [Rust](http://www.rust-lang.org/)
* [Allocators in Rust - Baby Steps](http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpでFFIバインディングを書く時の知見</title>
      <link>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</link>
      <pubDate>Sun, 19 Apr 2015 13:51:33 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</guid>
      <description>

&lt;p&gt;κeenです。最近頻繁にSML#を使ってます。SML#のメイン機能の1つであるC連携ですが、ちょっと複雑なことをやろうとするとテクニックが必要になるので共有します。&lt;/p&gt;

&lt;p&gt;Twitterとかにコメントや突っ込みお願いします。&lt;/p&gt;

&lt;h1 id=&#34;簡単な型:017736760057fcde64c6904c3e916b13&#34;&gt;簡単な型&lt;/h1&gt;

&lt;p&gt;型が簡単な関数なら普通に&lt;code&gt;_import&lt;/code&gt;で済みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val puts = _import &amp;quot;puts&amp;quot;: string -&amp;gt; ()
val () = puts &amp;quot;Hello, C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尚、簡単な型とは&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch9.S2.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;にある通り、いわゆる即値、即値の組（タプル）、即値の配列、即値の参照、それらを引数、返り値に持つ関数などです。&lt;/p&gt;

&lt;p&gt;又、以下のような制約もあります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C関数全体の型は，引数リストを組型とするMLの関数型に対応付けられます． ただし，C関数の引数や返り値に書ける相互運用型には，以下の制約があり ます．
   配列型や組型など，Cのポインタ型に対応する相互運用型を，C関数の返り値の 型として指定することはできません．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恐らくGCとの兼ね合いでしょうがつらいですね。stringすら返り値で受け取れません。&lt;/p&gt;

&lt;p&gt;それにこの制約がどこまで効いてるのかが不明で、同じ型でも型付けに成功したり失敗したりすることがあります。例えば上の例でstring型を引数にとる関数をインポートしましたが関数に依ってはstringが相互運用型でないとか怒られることがあります。タプルの配列やタプルの参照などは確実にダメみたいです。&lt;/p&gt;

&lt;p&gt;尚、string型はCでいう &lt;code&gt;const char *&lt;/code&gt; 、タプルは変更不能な構造体へのポインタになるそうです。構造体の即値は扱えないんですね…。また、参照とは別に &lt;code&gt;ptr&lt;/code&gt; 型も存在します。SML#側からは作れず、Cとの相互運用のためだけに存在するようです。&lt;/p&gt;

&lt;h1 id=&#34;魔法の-unit-ptr:017736760057fcde64c6904c3e916b13&#34;&gt;魔法の &lt;code&gt;unit ptr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;じゃあ複雑な型はインポート出来ないのかというとそうでもなく、 &lt;code&gt;unit ptr&lt;/code&gt; 型にしておけばとりあえずインポート出来ます。Cで言うところの &lt;code&gt;void *&lt;/code&gt; です。
邪悪な雰囲気を感じますね。しかしそこは型安全言語、ちゃんと型安全に &lt;code&gt;unit ptr&lt;/code&gt; を扱えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;type file = unit ptr
val fopen = _import &amp;quot;fopen&amp;quot;: (string, string) -&amp;gt; file
val fgetc = _import &amp;quot;fgetc&amp;quot;: (file) -&amp;gt; int
val fclose = _import &amp;quot;fclose&amp;quot;: (file) -&amp;gt; int
val () = let
      val f = fopen(&amp;quot;test&amp;quot;, &amp;quot;r&amp;quot;)
      val c = fgetc(f)
    in
      print(str(chr c));
      fclose(f)
    end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。単に &lt;code&gt;type&lt;/code&gt; で名前をつけてあげれば大丈夫です。SML#側ではポイント先が何であるかには関知せず、インポートしたC関数の間で完結してれば問題ありません。多くのライブラリはそのようなAPIになっているのではないでしょうか。&lt;/p&gt;

&lt;h1 id=&#34;ポインタを扱う:017736760057fcde64c6904c3e916b13&#34;&gt;ポインタを扱う&lt;/h1&gt;

&lt;p&gt;とはいえ時にポインタを扱う必要もあります。構造体の配列を扱えないのでその辺で。&lt;/p&gt;

&lt;p&gt;そういった時に便利なのが &lt;code&gt;SMLSharp_Builtin.Pointer&lt;/code&gt; と &lt;code&gt;Pointer&lt;/code&gt; です。 &lt;code&gt;Pointer&lt;/code&gt; の方は .smi ファイルの中で &lt;code&gt;_require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt; してから使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure SMLSharp_Builtin
  structure Pointer =
  struct
    val identityEqual = _builtin val IdentityEqual : boxed * boxed -&amp;gt; bool
    val advance = _builtin val Ptr_advance : &#39;a ptr * int -&amp;gt; &#39;a ptr
    val deref = _builtin val Ptr_deref : &#39;a ptr -&amp;gt; &#39;a
    val store = _builtin val Ptr_store : &#39;a ptr * &#39;a -&amp;gt; unit

    val toUnitPtr = _builtin val Cast : &#39;a ptr -&amp;gt; unit ptr
    val fromUnitPtr = _builtin val Cast : unit ptr -&amp;gt; &#39;a ptr
    val toCodeptr = _builtin val BitCast : unit ptr -&amp;gt; codeptr
  end
  end

structure Pointer =
struct
  val advance = SMLSharp_Builtin.Pointer.advance

  val load =
      case &#39;a in &#39;a ptr -&amp;gt; &#39;a of
        int =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | char =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.deref

  val store =
      case &#39;a in &#39;a ptr * &#39;a -&amp;gt; unit of
        int =&amp;gt; SMLSharp_Builtin.Pointer.store
      | word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | char =&amp;gt; SMLSharp_Builtin.Pointer.store
      | real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.store

  val isNull : &#39;a ptr -&amp;gt; bool
  val NULL : unit -&amp;gt; &#39;a ptr

  val importBytes : SMLSharp_Builtin.Word8.word ptr * int
                    -&amp;gt; SMLSharp_Builtin.Word8.word vector
  val importString : char ptr -&amp;gt; string
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 、 &lt;code&gt;store&lt;/code&gt; 、 &lt;code&gt;deref&lt;/code&gt; 、 &lt;code&gt;advance&lt;/code&gt; あたりを良く使いそうですね。&lt;/p&gt;

&lt;p&gt;実際にあった話。 &lt;code&gt;struct header { const char *name; int name_len; const char *value; int value_len}&lt;/code&gt; の配列(&lt;code&gt;struct header *&lt;/code&gt;)を扱う必要がありました。
その配列をCの関数に渡して書き換えてもらって、後で値を取り出したいという状況がです。その時値を取り出すコードがこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun getHeader headers i =
      let
          val header_ptr : char ptr ptr = fromUnitPtr(headers)
          val header_ptr = advance(header_ptr, i * 2)
          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val header_ptr = advance(header_ptr , i * 2)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val name = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val nameLen = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val value = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val valueLen = deref(header_ptr)
      in
          if isNull name
          then (NONE, String.substring(importString(value), 0, valueLen))
          else (SOME(String.substring(importString(name), 0, nameLen)),
                String.substring(importString(value), 0, valueLen))
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、タプルは構造体へのポインタなので今回の &lt;code&gt;struct header *&lt;/code&gt; は &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではありません。それは &lt;code&gt;struct header **&lt;/code&gt; になってしまいます。
また、ポインタを扱う関数が &lt;code&gt;ptr&lt;/code&gt; 型しか受け付けないので &lt;code&gt;string&lt;/code&gt; ではなく &lt;code&gt;char ptr&lt;/code&gt; にしておいて後から &lt;code&gt;importString&lt;/code&gt; で文字列にする戦略をとります。&lt;/p&gt;

&lt;p&gt;そして配列のi番目にアクセスしたかったら先述の通り &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではないので地道に &lt;code&gt;char ptr ptr&lt;/code&gt; 2*i個分、 &lt;code&gt;int ptr&lt;/code&gt; 2*i個分ポインタを進めます。
ポインタの型を変える時はダイレクトには変換出来ないようなので一旦 &lt;code&gt;unit ptr&lt;/code&gt; を経由してから変換。そして次のメンバにアクセスするために &lt;code&gt;advance&lt;/code&gt; という形をとります。&lt;/p&gt;

&lt;p&gt;そこまでしたら後は &lt;code&gt;deref&lt;/code&gt; してあげれば欲しい値がとれます。&lt;/p&gt;

&lt;h1 id=&#34;replからのimportと-dynamiclink:017736760057fcde64c6904c3e916b13&#34;&gt;REPLからのimportと &lt;code&gt;DynamicLink&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;SML#のREPLからも勿論インポート出来ますが、SML#のランタイムにリンクされてないライブラリのものはインポート出来ないのでダイナミックリンクを使います。 &lt;code&gt;DynamicLink&lt;/code&gt; にCの &lt;code&gt;dl*&lt;/code&gt; と同じ関数群が用意されているのでそれらを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure DynamicLink =
struct
  type lib (= ptr)
  datatype scope = LOCAL | GLOBAL
  datatype mode = LAZY | NOW
  val dlopen : string -&amp;gt; lib
  val dlopen&#39; : string * scope * mode -&amp;gt; lib
  val dlsym : lib * string -&amp;gt; codeptr
  val dlsym&#39; : lib * string -&amp;gt; unit ptr
  val dlclose : lib -&amp;gt; unit
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;val lib = dlopen(&amp;quot;libawsome.so&amp;quot;)&lt;/code&gt; でライブラリのオープン、 &lt;code&gt;dlsym(lib, &amp;quot;awm_function&amp;quot;): _import () -&amp;gt;unit&lt;/code&gt; で読み込みです。&lt;/p&gt;

&lt;p&gt;これでインポートする関数は必要になった時に読み込んで欲しいのですがトップレベルで &lt;code&gt;val&lt;/code&gt; でバインドすると即読み込まれてしまいます。その辺を上手くやるテクニックがSML#のソースにありました。MySQLのバインディングの部分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun lazy f =
      let
        val r = ref NONE
      in
        fn () =&amp;gt;
           case !r of
             SOME x =&amp;gt; x
           | NONE =&amp;gt;
             let val x = f ()
             in r := SOME x; x
             end
      end

  val lib =
      lazy (fn _ =&amp;gt;
               DynamicLink.dlopen
                 (case OS.Process.getEnv &amp;quot;SMLSHARP_LIBMYSQLCLIENT&amp;quot; of
                    NONE =&amp;gt; &amp;quot;libmysqlclient.16.&amp;quot; ^ SMLSharp_Config.DLLEXT ()
                  | SOME x =&amp;gt; x))

  fun find s = DynamicLink.dlsym(lib (), s)
  val mysql_init =
      lazy (fn _ =&amp;gt; find &amp;quot;mysql_init&amp;quot;
                    : _import (MYSQL) -&amp;gt; MYSQL)


...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遅延評価してますね。これ。呼び出す時は &lt;code&gt;mysql_init () (mysql)&lt;/code&gt; みたいに一旦lazyを剥がさないといけないので注意です。&lt;/p&gt;

&lt;h1 id=&#34;問題とか:017736760057fcde64c6904c3e916b13&#34;&gt;問題とか&lt;/h1&gt;

&lt;h2 id=&#34;cの仕様:017736760057fcde64c6904c3e916b13&#34;&gt;Cの仕様&lt;/h2&gt;

&lt;p&gt;確かCの仕様上構造体のメモリ上の表現にはメンバ以外のものも置いていいことになっていた筈です。
上の方法では変なコンパイラでコンパイルしたコードだと動きそうにないですね。GCCやClangは大丈夫な筈。&lt;/p&gt;

&lt;p&gt;そもそもSML#自体GCCとABI互換なコンパイラでコンパイルしたものじゃないとリンク出来なそうな気がするので杞憂ですかね。&lt;/p&gt;

&lt;h2 id=&#34;メモリ確保:017736760057fcde64c6904c3e916b13&#34;&gt;メモリ確保&lt;/h2&gt;

&lt;p&gt;Cの関数から構造体のポインタが返ってくるケースだと良いんですが自分で構造体を用意してCの関数に渡すケースだとメモリの確保が問題になります。現状、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct header
*prepare_headers(int n)
{
  return malloc(n * sizeof(struct header));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなヘルパ関数を用意して凌いでますが欲しい構造体毎に書かないといけないのであまり嬉しくないです。 &lt;code&gt;sizeof&lt;/code&gt; をSML#側でとれれば単に &lt;code&gt;malloc&lt;/code&gt; をバインドするだけで済むのに。
もう少し欲を言うと &lt;code&gt;malloc&lt;/code&gt; したらGCから外れそうな気がするので明示的に &lt;code&gt;free&lt;/code&gt; する必要がありそうです。GCに載るメモリ確保関数も欲しいですね。
さらに欲を言うとスタックアロケートする版のメモリ確保関数も欲しい。もしかしたら &lt;code&gt;alloca&lt;/code&gt; で大丈夫なんでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;define:017736760057fcde64c6904c3e916b13&#34;&gt;&lt;code&gt;#define&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ヘッダファイル内で定数を &lt;code&gt;#define&lt;/code&gt; してあることが多々あります。それらは地道に手書きでSML#側に持ってくることになりますが気になるのが互換性の問題。
特にOSのヘッダファイルには名前は同じだけどOS毎に値が異なるものが存在します。シグナルとか。OSで条件分岐するか理想的にはプリプロセッサのサポートがあればどうにかなりそうなんですけどねぇ。
現状だとCで定数を返すgetter関数を書いてSML#側でインポートして…ってやればどうにか出来そうですけどやりたくないですね。&lt;/p&gt;

&lt;h2 id=&#34;変数:017736760057fcde64c6904c3e916b13&#34;&gt;変数&lt;/h2&gt;

&lt;p&gt;私はまだ遭遇してないのですがライブラリによってはグローバル変数にアクセスしないといけないものが存在します。これもgetterとsetterを書いて…ってやるとどうにか出来そうですがどうせなら変数のインポートも出来ると良いですよね。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:017736760057fcde64c6904c3e916b13&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SML#でCのバインドを書く時は少しテクニックが必要&lt;/li&gt;
&lt;li&gt;SML#にはポインタを直接扱える関数もある&lt;/li&gt;
&lt;li&gt;それでも機能が足りない時はCでヘルパ関数を書こう。&lt;/li&gt;
&lt;li&gt;ダイナミックリンクライブラリも扱えるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SMLのファンクタに少し踏み込んだ</title>
      <link>http://keens.github.io/blog/2015/04/12/smlnofankutanisukoshifumikonda</link>
      <pubDate>Sun, 12 Apr 2015 19:49:41 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/12/smlnofankutanisukoshifumikonda</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;https://github.com/bleis-tift/SmlSharpContrib&#34;&gt;SmlSharpContrib&lt;/a&gt;にコントリビュートしてます。そこでファンクタを使う用事があったのですが少し踏み込んだ使い方をしようとしたらハマったのでメモ。&lt;/p&gt;

&lt;h1 id=&#34;ファンクタおさらい:921b7b3c7820999b28763bd2de5241d3&#34;&gt;ファンクタおさらい&lt;/h1&gt;

&lt;p&gt;SMLの&lt;code&gt;functor&lt;/code&gt;は&lt;code&gt;structure&lt;/code&gt;に引数がついたもので、モジュールを引数にとり、モジュールを返します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (Args : sig type elem end) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(struct type elem = int end)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;複雑なファンクタ:921b7b3c7820999b28763bd2de5241d3&#34;&gt;複雑なファンクタ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;blog/2015/01/31/mlyaccwotsukattemitehamattatokoro/&#34;&gt;以前mlyaccを使った時&lt;/a&gt;に&lt;code&gt;Join&lt;/code&gt;なる3つのモジュールを引数にとるファンクタが登場したのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの定義を覗いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数のモジュールの他に&lt;code&gt;sharing&lt;/code&gt;なるキーワードも出てきています。それに&lt;code&gt;structure&lt;/code&gt;キーワードもプリフィクスされています。&lt;/p&gt;

&lt;p&gt;先程の例とは大分離れてますね。何があったのでしょう。&lt;code&gt;structure&lt;/code&gt;を付けとけば複数書ける…？&lt;/p&gt;

&lt;h1 id=&#34;省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;省略記法&lt;/h1&gt;

&lt;p&gt;実はファンクタの引数の中では省略記法が使えます。引数のモジュール名と&lt;code&gt;sig ... end&lt;/code&gt;が省略可能なのです。さらに適用の時も&lt;code&gt;struct ... end&lt;/code&gt;も省略可能なのです。&lt;/p&gt;

&lt;p&gt;つまり、最初の例はこうも書けるのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (type elem) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(type elem = int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;モジュール内モジュールと省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;モジュール内モジュールと省略記法&lt;/h1&gt;

&lt;p&gt;そうです。複雑怪奇な&lt;code&gt;Join&lt;/code&gt;ファンクタは省略記法で書かれていたのでした。省略せずに書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(struct
     structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex
     end)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(X: sig
             structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token
             end)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。形式的には引数のモジュールは1つでありながら事実上複数のモジュールを渡していたのです。&lt;code&gt;structure&lt;/code&gt;が付いていたのはモジュール内モジュールだったから、&lt;code&gt;sharing&lt;/code&gt;はモジュール内モジュールに対する制約宣言です。&lt;/p&gt;

&lt;p&gt;なぜこれでハマったかというとSML#のインターフェースファイルでは省略記法が使えなかったからです。地雷の数だけ強くなれるよ♪&lt;/p&gt;

&lt;h1 id=&#34;参考:921b7b3c7820999b28763bd2de5241d3&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://walk.wgag.net/sml/module.html&#34;&gt;モジュール - ウォークスルー Standard ML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch11.S6.xhtml&#34;&gt;ファンクタのサポート in Ch.11. SML#分割コンパイルシステム in プログラミング言語SML#解説&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CyberAgentに入社しました</title>
      <link>http://keens.github.io/blog/2015/04/10/cyberagentninyuushashimashita</link>
      <pubDate>Fri, 10 Apr 2015 19:55:59 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/10/cyberagentninyuushashimashita</guid>
      <description>&lt;p&gt;κeenです。少し遅くなりましたが4/1付で所属が変わったので報告です。&lt;/p&gt;

&lt;p&gt;タイトルにあるように、株式会社サイバーエージェントに入社しました。こう言うとよく「あれ？サムライトじゃないの？」「もっとストイックな所に行くと思ってた」と言われます。サムライトについては特に関係はないです。エンジニア2人と知り合いなだけです。Common Lispだけが幸せの基準じゃありません。
それにキラキラ女子のイメージが強いかもしれませんがサイバーエージェント、結構ストイックですよ？&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/lXs96toe-B8&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;因みに昨日までで全体研修が終わり、月曜から技術研修が始まります。技術研修を受けずに早期配属される同期や果ては&lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1504/03/news134.html&#34;&gt;社長になる同期&lt;/a&gt;も居る中のんびり6月末まで研修を受けます。フロント周りはからっきしなのでこれを機にその辺も勉強しようかと。&lt;/p&gt;

&lt;p&gt;研修はグループワークが多かったのですが一緒のチームにいて優秀だなと思える人に何人も会ってきたしバックグラウンドを訊いてみて尖ってるエンジニアも一杯いたので正式配属されるのが楽しみです。私もそれなりに尖ってるつもりだったのですが精進が足りませんね。&lt;/p&gt;

&lt;p&gt;まあ、マイペースに歩んでいきます&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;よし、来年Clojureおじさんになろう&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/489246490724810752&#34;&gt;2014, 7月 16&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>誰がUTF-32が使われてないなんて言ったんだ</title>
      <link>http://keens.github.io/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</link>
      <pubDate>Tue, 31 Mar 2015 19:41:05 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</guid>
      <description>

&lt;p&gt;最近ではUTF-8でソースコードを書いてUTF-8で出入力をする。それ以外のエンコーディングは使われていない。…だと？誰がそんなこと言ったんだ&lt;/p&gt;

&lt;h1 id=&#34;asciiと古いunicodeと新しいunicode:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;ASCIIと古いUnicodeと新しいUnicode&lt;/h1&gt;

&lt;p&gt;少し長くなるが文字コードの話から始まる。ASCIIはお馴染み最低7bitあればASCIIの定義する文字集合を表せる。&lt;/p&gt;

&lt;p&gt;古いUnicodeは16bitで全ての文字を表わすことを目標に作られた。&lt;/p&gt;

&lt;p&gt;新しいUnicodeは文字(主に漢字)が多過ぎて16bitでは表せなかったので21bitに拡張された。&lt;/p&gt;

&lt;h1 id=&#34;文字コードとエンコーディング:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;文字コードとエンコーディング&lt;/h1&gt;

&lt;p&gt;文字コードをどういう形式で表すかがエンコーディングだ。文字コードが7bit、16bit、21bitだからといってそのままのサイズで表わす訳ではない。ASCIIは普通8bitの型で表わすし21bitの型を用意するよりは32bitの型に格納した方が扱い易そうだ。あるいは8bit型の配列に16bitや21bitを収めるとプログラムコードの変更が少なそうだ。&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8とUTF-16とUTF-32&lt;/h1&gt;

&lt;p&gt;さて、ここまで来ればお分かりだろう。UTF-8はASCIIとの互換性を保つ8bitベースのエンコーディング、UTF-16は古いUnicodeの時に作られて新しいUnicodeにも対応した16bitベースのエンコーディング、UTF-32は新しいUnicodeのために作られた32bitベースのエンコーディングだ。
ここで注意して欲しいのはUTF-8とUTF-16は8bitや16bitの単位を複数使うことで新しいUnicodeの範囲も扱える点、逆に言えば1単位が1文字に対応しない点だ。日本語を含んだ文字列に対して&lt;code&gt;length&lt;/code&gt;を使うと正しい結果が帰って来ないなどの経験は誰しもあるだろう&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32それぞれの特徴:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8とUTF-16とUTF-32それぞれの特徴&lt;/h1&gt;

&lt;h2 id=&#34;utf-8:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8&lt;/h2&gt;

&lt;p&gt;8bit(オクテット)の配列に文字列を収めることになる。16bitや21bitの範囲の文字を表す時は8bitに対してASCIIは7bitしか使わないのでその1bitを使って次に続くことを表わす。最大4オクテットまで使うことがある。 UTF-8の特徴はなんと言ってもASCIIとの互換性があること。UTF-8でASCIIの範囲のみの文字をエンコードするとASCIIと同一になるし、ASCIIでエンコードされたものはUTF-8で読んでも同じ内容になる。なのでどんなエンコードか分からないものはとりあえずUTF-8で読んでおくと間違いが少ない。よって冒頭で書いたように出入力、保存ファイル、GUIに表示する文字列などに使われる。&lt;/p&gt;

&lt;p&gt;UTF-8にも欠点はあり、ASCII外の文字を大量に扱うと空間効率が悪い。さらに先頭から順番に辿らないとどのオクテットが何文字目かも分からないので(配列長が既知であっても)文字列へのlengthやランダムアクセスなどの多くの操作がO(n)になってしまう点だ。文字の置換に至ってはin placeでは出来ないことすらある。&lt;/p&gt;

&lt;h2 id=&#34;utf-16:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-16&lt;/h2&gt;

&lt;p&gt;16bitの配列に文字列を収める。21bitまで扱うために特定の範囲の値が来たら次の16bitも読んで2つ併わせて1つの文字とみなす。このペアをサロゲートペアという。C言語には&lt;code&gt;wchar&lt;/code&gt;なるマルチバイト文字用の型があるが、仕様では最低で16bitという要求になっているのでwcharを使う時はUTF-16でエンコードする（と思う）。UTF-16もUTF-8と同じく文字列操作がO(n)になる。Unicode公式のエンコーディングであるという点を除いて特に良い点が見当たらないので後方互換性の必要な場面でないと使われてなさそうな気がする。例えばWindowsのファイルシステムはファイル名をUTF-16で保持しているらしい。&lt;/p&gt;

&lt;p&gt;尚、16bitのエンディアンは指定されてないのでファイルの先頭にバイトオーダーマーク(BOM)と呼ばれる空白文字を置いてそれでエンディアンを指定/判別する慣習になっている。&lt;/p&gt;

&lt;h2 id=&#34;utf-32:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-32&lt;/h2&gt;

&lt;p&gt;32bitの配列に文字列を収める。必ず32bitで1文字を表すので文字列操作が効率的に行なえる。欠点はASCIIの範囲の文字が多いとメモリを無駄にし易い点。どんな文字列を扱うか分からない(ASCIIの範囲が多いとは言い切れない)汎用ライブラリや言語処理系そのものでよく使われる。&lt;/p&gt;

&lt;h1 id=&#34;言語処理系の内部表現と外部エンコーディング:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;言語処理系の内部表現と外部エンコーディング&lt;/h1&gt;

&lt;p&gt;ここで罠になるのがソースコードをUTF-8で書いて出入力をUTF-8で行なう処理系でも内部では先述の理由でUTF-8以外を使うことがあることだ。メジャーな言語について少し調べてみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SBCL(Common Lispのメジャーな処理系)はUTF-32を使う&lt;/li&gt;
&lt;li&gt;SpiderMonkey(FirefoxのJavaScript処理系)はUTF-8を使う。HTMLはマルチバイト文字を使う言語で書かれていても大半がASCIIになるからとのこと。また、文字列をropeで表現しており、UTF-8のデメリットを軽減出来る。&lt;/li&gt;
&lt;li&gt;Rubyは多言語対応の時に内部表現はなんでもアリ(渡された文字列そのまま)になった&lt;/li&gt;
&lt;li&gt;PerlはUTF-8を使う&lt;/li&gt;
&lt;li&gt;PythonはconfigureのオプションでUCS2(ほぼUTF-16に同じ)やUCS4(UTF-32形式のUnicodeと概ね互換)が選べる。FedoraやUbuntuはUCS4でビルドしている&lt;/li&gt;
&lt;li&gt;PHPは言語で動的に変更出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ソースコードをUTF-8で書いて出入力をUTF-8で行なうから変換コストなんてないと思ったら大間違いだ。裏ではUTF-32が使われていて、出入力の度に変換が走る。誰がUTF-32が使われてないなんて言ったんだ。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>