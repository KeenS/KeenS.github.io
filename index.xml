<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Apr 2015 16:09:08 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SML#をMacでビルドする</title>
      <link>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</link>
      <pubDate>Wed, 29 Apr 2015 16:09:08 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</guid>
      <description>

&lt;p&gt;κeenです。SML#2.0.0を文鎮と化していたMBAにインストールしたのでメモをば。&lt;/p&gt;

&lt;p&gt;基本は&lt;a href=&#34;http://d.hatena.ne.jp/keita44_f4/20140412/1397279451&#34;&gt;よんたさんの記事&lt;/a&gt;をMacに翻訳した感じです。&lt;/p&gt;

&lt;p&gt;モチベーションは、&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/ja/?Download&#34;&gt;公式の配布物&lt;/a&gt;がMac版だとMacPorts版しかなく、
portsとhomebrewの混在は避けた方が良いと聞いたのでどうにかして自前ビルドしようとしたことです。&lt;/p&gt;

&lt;h1 id=&#34;注意書き:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;注意書き&lt;/h1&gt;

&lt;p&gt;冒頭にも書いてあるようにMBAは普段使ってなくて、このエントリーもMBAじゃないマシンから書いているのでコマンド類はコピペでなく写経してます。
typoがあるかもしれないのでコピペして動かなかったら一応この記事のtypoを疑って下さい。&lt;/p&gt;

&lt;h1 id=&#34;gmp32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;GMP32bitの準備&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ brew install gmp --32-bit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で終わり。バージョン6.0.0aが入りました。
既にインストールされていたら多分64bit版が入っているので一旦 &lt;code&gt;brew remove gmp&lt;/code&gt; してから再度インストールすると良いです。尚、バイナリ版はないようで、ビルドが始まります。checkに時間が掛かる。&lt;/p&gt;

&lt;h1 id=&#34;llvm34-32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;LLVM34 32bitの準備&lt;/h1&gt;

&lt;p&gt;骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://llvm.org/releases/3.4.2/llvm-3.4.2.src.tar.gz
$ gzcat llvm-3.4.2.src.tar.gz | tar xf -
$ cd llvm-3.4.2.src
$ ./configure --build=i686-mac-darwin CC=&#39;gcc -m32&#39; CXX=&#39;g++ -m32&#39; --prefix=/usr/local/Cellar/llvm34/3.4.2a
$ make -j4
$ make -j4 install
$ cd ../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら上手くいきました。何故上手くいったんでしょうねー。あとprefixは割と気持悪いのでみなさん適切な場所にインストールしましょうね。&lt;/p&gt;

&lt;h1 id=&#34;sml-のビルド:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;SML# のビルド&lt;/h1&gt;

&lt;p&gt;これが一番骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.pllab.riec.tohoku.ac.jp/smlsharp/download/smlsharp-2.0.0.tar.gz
$ gzcat smlsharp-2.0.0.tar.gz | tar xf -
$ cd smlsharp-2.0.0
$ ./configure --with-llvm=/usr/local/Cellar/llvm34/3.4.2a/      \
               LDFLAGS=&#39;-L/usr/local/Cellar/gmp/6.0.0a/lib&#39;     \
              CPPFLAGS=&#39;-I/usr/local/Cellar/gmp/6.0.0a/include&#39; \
                    CC=&#39;gcc -m32&#39;                               \
                   CXX=&#39;g++ -m32&#39;
$ make -j4
$ make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら出来ました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;誰かhomebrewにして。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispで限定継続と遊ぶ</title>
      <link>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</link>
      <pubDate>Sun, 26 Apr 2015 21:09:07 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Common Lispで限定継続と遊ぶ
----------------------
[Lisp Meet Up #27](https://atnd.org/events/64988)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# Agenda
--------

0. cl-contの紹介
1. 限定継続の話
2. 限定継続の使い方の話
3. 限定継続の実装の話


# CL-CONTの紹介

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CL-CONT
---------

* Common Lispの限定継続ライブラリ
* 結構古くからあるっぽい
* 割と色々なライブラリが使ってる

# CL-CONT
---------

![cl-cont dependers](/images/cl-cont-dependers.png)

# API
-----

* 継続を区切るマクロ
  + `with-call/cc`
  + `defun/cc`
  + `lambda/cc`
* 継続を取得するマクロ
  + `call/cc`
  + `let/cc`

※後で説明するので意味が分からなくても問題ないです。


# 限定継続の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後トップレベルに戻るまでの計算。
* Schemeが一級市民として扱えることで有名
* 値として取り出した時は0-1引数関数として振る舞う

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      □)))
```

# 継続とは
----------
あとはそれを関数にするだけ

```lisp
(lambda (k)
  (mapc #&#39;writ-line
        (loop :for x :in list
           :collect (if (evenp x)
                        k))))
```


# 限定継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後 *指定した位置* に戻るまでの計算。
* 継続がトップレベルまで戻るのに対して限定継続途中で止まる。それだけ。
* 部分継続などの言い方もある
  + 英語もpart contとdelimited contで分かれる


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(loop :for x :in list
           :collect (if (evenp x)
                        □))
```


# 限定継続とは
-------------

```lisp
(lambda (k)
  (loop :for x :in list
     :collect (if (evenp x)
                  k)))
```

# 限定継続の挙動
---------------
普通のやつ

```lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```

これは

```lisp
(+ 1 2)
```

と等価

# 限定継続の挙動
---------------
今度は継続を呼ばないでみる

```lisp
(with-call/cc
  (+ 1 (call/cc (lambda (k) 2))))
```

これは

```lisp
2
```

と等価

# 限定継続の挙動
---------------
もうちょっと呼ばない例  
(`(let/cc k ...)` = `(call/cc (lambda (k) ...))`)

```lisp
(with-call/cc
  (write-line &#34;hello&#34;)
  (let/cc k 1)
  (write-line &#34;world&#34;))
```

は

```lisp
(progn
  (write-line &#34;hello&#34;)
  1)
```

と等価


# 限定継続の使い方の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の使い方の話
---------------------

* グリーンスレッド
* コールバックを綺麗に書き換える
* 非決定性計算
* etc...


## グリーンスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


## グリーンスレッド
-----------------

* またの名をコルーチン
* またの名を強調スレッド



## グリーンスレッド
-----------------

```lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```

## グリーンスレッド
-----------------
実行結果

```
in thread A 1
in main thread 1
in thread A 2
in main thread 2
in thread A 2
in main thread 3

```


## コールバックの書き換え

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## コールバックの書き換え
----------------------
本当はこう書きたい

```lisp
(with-event-loop
    (format t &#34;Hello, ~a!~%&#34; (async-read stream)))
```

## コールバックの書き換え
----------------------
しかしライブラリがコールバック関数を要求してくる

```lisp
(with-event-loop
    (async-read stream (lambda (line)
                         (format t &#34;Hello, ~a!~%&#34; line))))
```

## コールバックの書き換え
-----------------------
コールバック = 限定継続（後述）なのでこうしてやれば良い。

```lisp
(with-event-loop
    (with-call/cc
      (format t &#34;Hello, ~a!~%&#34;
              (call/cc (lambda (k))
                       (async-read stream k)))))
```

## 非決定性計算

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## 非決定性計算
-------------
### ベースアイディア

* 継続を関数として取り出した後同じ処理を何回も実行出来るんじゃね？


## 非決定性計算
-------------
### ベースアイディア
複数回呼び出してみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (list (funcall c 1)
        (funcall c 2)
        (funcall c 3)))
```


## 非決定性計算
-------------
### ベースアイディア
普通の1引数関数として使ってみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (mapcar c (list 1 2 3)))
```

## 非決定性計算
-------------
### ベースアイディア
マクロでラップしてみる

```lisp
(defmacro for (&amp;body expr)
  `(with-call/cc ,@expr))
(defmacro in (m)
  `(let/cc k (apply #&#39;append (mapcar k ,m))))
(defun yield (x) (list x))
(defun unit () nil)
```


## 非決定性計算
-------------
使ってみる

```lisp
(for
  (let ((x (in &#39;(1 2 3)))
        (y (in &#39;(a b c))))
    (yield (cons x y))))
```

```
((1 . A) (1 . B) (1 . C) (2 . A) (2 . B) (2 . C) (3 . A) (3 . B) (3 . C))
```


# 限定継続の実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の実装の話
-------------------

* 継続は0~1引数関数として取り出せるのであった。
  + 実は機械的に取り出せる
* 継続は全ての式に暗黙に存在するのであった
  + 全ての式を継続を明示的に使うようにも出来る


# CPS変換

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CPS変換
---------

* 全ての関数の引数を1つ増やして、そこで継続を受け取る
* 値を返す時は暗黙のreturnを使うのではなく明示的に継続を呼ぶ
* 関数を呼ぶ時は必ず継続を渡す。呼び出し元には返ってこない（自然と末尾再帰になる）


# CPS変換
---------
例えば

```lisp
(with-call/cc
  (foo (call/cc
        (lambda (k)
          (funcall k 2)))))
```

は、取り出された継続が

```lisp
(lambda (k) (foo k))
```

。


# CPS変換
---------
よって

```lisp
((lambda (k) (foo k)) 2)
```

と変換される


# CPS変換
---------
再帰関数だと少し面倒

```lisp
(defun fact (n)
  (if (&lt;= n)
      1
      (* n (fact (- n 1))))))

```

が

```lisp
(defun fact (n c)
  (if (&lt;= n)
      (c 1)
      (fact (- n 1) (lambda (v) (* n v)))))
```

となる


# CPS変換
---------

* CPS変換を行なうことでいつでも継続を値として使える


# 限定継続の実装の話
-------------------

* CPS変換を裏で行なっている
* 自動で出来るのでマクロで変換をしている
  + 組み込み関数は変更出来ないので特別扱い
  + スペシャルフォームも気をつける必要がある
* `lambda`が乱立するのでパフォーマンスは酷い。


# まとめ
-------

* cl-contというライブラリがあって、限定継続が扱える
* 限定継続は処理を中断したり再開したり繰り返したりに使える
* 裏ではえげつないことをやっている
* パフォーマンスが必要なところでは使っちゃダメ


# 参考
------
* [picrin/partcont.scm at master · picrin-scheme/picrin](https://github.com/picrin-scheme/picrin)
* [cl-cont | Quickdocs](http://quickdocs.org/cl-cont/)
* [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)
* [継続渡しスタイル - Wikipedia](http://ja.wikipedia.org/wiki/%E7%B6%99%E7%B6%9A%E6%B8%A1%E3%81%97%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB)
* [M.Hiroi&#39;s Home Page / お気楽 Scheme プログラミング入門](http://www.geocities.jp/m_hiroi/func/abcscm20.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>非同期処理の「その後」の話。goto、継続、限定継続、CPS、そしてコールバック地獄。</title>
      <link>http://keens.github.io/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</link>
      <pubDate>Sat, 25 Apr 2015 23:44:46 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 非同期処理の「その後」の話
----------------------
## goto、継続、限定継続、CPS、そしてコールバック地獄

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# 同期処理とは
-------------
通常、外部とやりとり(I/O)する時に待ち時間(ブロック)が発生する。

![sync task image](/images/sync.png)


# 非同期処理とは
---------------
待ち時間に(ブロックせずに)別の処理をしようという発想。

![async task image](/images/async.png)

# 非同期処理の裏側
-----------------
処理Aと処理Bの他にいつどっちを動かすかを決めるスケジューラが存在することが多い

![async scheduler image](/images/async_scheduler.png)


# どうやって戻る問題
-------------------
* 一時停止した後「その後」の処理にどうやって戻るか

![cont image](/images/cont.png)

# 「その後」とは
-----------

```C
...
fputc(c); // ここの処理でI/Oが入る
// 再開する時にここに戻ってきたい
printf(&#34;Work done&#34;);
...
```

# GOTO
------
`goto` を使えば戻れる

```C
...
  fputc(c); // ここの処理でI/Oが入る
  // 再開する時にここに戻ってきたい
RESTART:
  printf(&#34;Work done&#34;);
...
```

# GOTOの問題
------------
こういうコードだとGOTOでは困る

```C
if ((c = fgetc(f)) != -1)
...
```


# GOTOの問題
------------
こんな区切り方をしたい

![cont in code image](/images/codecont.png)


# GOTOの問題
------------

* 式の途中に入れない
* 値を返せない
* I/Oが終わった「その後」が思ったより複雑

# &#34;継続&#34;という概念
-----------------

* continuation
* ここで言ってる「その後」に名前をつけたもの
* その後に行なわれる全ての処理のこと
* 全ての言語に存在する


# (限定)継続を値として扱える言語
------------------------------
値としての継続はちょっとリッチになったGOTO程度。

* Scheme
* OchaCaml
* SML/NJ
* (Ruby)
* etc.


## 正確には限定継続
------------------

* 細かい話だが継続と言うと処理Aとスケジューラ全てを含んでしまうので
今回欲しいのは処理Aの中に限定した限定継続
* 継続を値として扱えれば限定継続を[実装出来る]()ので今回はそこまで深く違いを気にする必要はない


## 正確には限定継続
------------------

![continuation image](/images/continuation.png)


## 正確には限定継続
------------------

![partcont image](/images/partcont.png)


# 限定継続を使った非同期処理の例
------------------------------
Cの例をSchemeに翻訳してみる

```scheme
(if (/= (read-char f) -1)
    ...)
```


# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```


# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme

  (if (/= 
                  (async-read-char f  )
          -1)
      ...)

```


# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(if (/= (read-char f) -1)
    ...)
```


# ここまでのまとめ
-----------------

* 非同期処理を行なう時に継続という概念が出てくる
* 継続を値として扱える言語もある
* 値としての継続は1引数関数として振る舞う
* そのような言語ではユーザレベルで非同期処理をサポート出来る


# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 先に言ったように全ての言語に継続が存在する
  * マシン語レベルでjump命令とほぼ同じ
* 言語処理系レベルで継続を取り出せば使える
* 要は組込み機能


# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 処理系にそこまで求めるのは酷
  * バグり易い
  * デバッグし辛い
* 処理系はもっと別のことに専念すべき
* 機能が追加修正される度に処理系をアップグレードしないといけない

実は継続を値として扱えない言語でもユーザレベルで継続を値として取り出す方法がある


## Continuation Passing Style

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CPS
-----

* 日本語にすると「継続渡し形式」
* 継続を関数として切り出して引数に渡す
  * 継続のために全ての関数の引数が1つ増える
* 継続渡し形式に変換することを「CPS変換という」
* CPS変換は機械的に出来る


# CPS変換
------------
先は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```

になった。

# CPS変換
------------
今回は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(async-read-char f
           (lambda (c) (if (/= c -1) ...)))
```

になる


# CPS変換
---------

* パっと見限定継続のコードの`lambda`の外側と内側が入れ替わる
* そんなり分かりやすくない


# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n)
  (if (&lt;= n 1)
      1
      (* n (fact (- n 1)))))
```


# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n c)
  (if (&lt;= n 1)
      (c 1)
      (fact (- n 1) (lambda (c) (* n c)))))
```

# CPS変換まとめ
--------------

* とりあえず機械的に変換できる
  + 実際、CPS変換をサポートする言語はいくつかある
    - Haskellのdo記法とか
* むしろ機械がやるべきで人間がやることではない


# コールバック地獄の正体

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも

```javascript
async_read_char(f, function(c){
    if(c === -1) {
        ...
    }
})

```


# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも

```javascript
function fact(n, callback) {
    if(n &lt;= 1)
        return callback(n);
    else
        return fact(n - 1, function(c){return n * c;})
}
```


# コールバック地獄の正体
-----------------------

* 人間が手でやることではない&#34;CPS変換&#34;を手でやらせた結果
* altJSは内部でCPS変換を行なうことで非同期プロミスなどを実現している
  + DeNAのJSXとか

# 非同期処理の実装まとめ
------------------------
下に行く程抽象度/汎用性が高い

* コールバックスタイル
  + JavaScript(&lt; ES6)とか
* 言語レベル組み込みサポート
  + C#とか
* 言語レベルCPS変換サポート
  + altJSとか
* 言語レベル(限定)継続サポート
  + Schemeとか
* ユーザーレベルでも限定継続(CPS変換)を実現出来るエレガントなマクロサポート
  * Lisp

※ネタです。マサカリ投げないで下さい。


# まとめ: なぜコールバック&#34;地獄&#34;なのか
------------------------------------

* そもそも難しいことをやろうとしている
* 難しいことをカバーするだけの言語の機能が足りてない

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpを使ってSMLのon-the-flyエラーチェック</title>
      <link>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</link>
      <pubDate>Thu, 23 Apr 2015 23:01:17 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</guid>
      <description>

&lt;p&gt;κeenです。最近SMLを結構書いてるのですが中置演算子が乱立する言語はLisperにはつらくて、しょっちゅうコンパイルエラーを出します。
そこでSML#をflymakeで動かしてOn The Flyにエラーチェックをします。&lt;/p&gt;

&lt;p&gt;なぜSML#かというと &lt;code&gt;-ftypecheck-only&lt;/code&gt; オプションがあって、シンタックスと型エラーのチェックだけを行なえるからです。&lt;/p&gt;

&lt;p&gt;色々試したのですが設定はこれだけで済みました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(eval-after-load &#39;flymake
  &#39;(progn 
    (add-to-list &#39;flymake-allowed-file-name-masks &#39;(&amp;quot;.+\\.sml$&amp;quot;
                                                    (lambda ()
                                                      (list &amp;quot;/usr/local/bin/smlsharp&amp;quot; (list &amp;quot;-ftypecheck-only&amp;quot; (buffer-file-name))))
                                                    (lambda () nil)))
    (add-to-list &#39;flymake-err-line-patterns &#39;(&amp;quot;^\\([^: ]*\\):\\([0-9]+\\)\\.\\([0-9]+\\)-[0-9]+\\.[0-9]+ \\(Error\\|Warning\\):&amp;quot;
                                              1 2 3 4))))
(add-hook &#39;sml-mode-hook #&#39;flymake-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;/usr/local/bin/smlsharp&amp;quot;&lt;/code&gt; のところは各自書き換えて下さい。尚、SML#はエラーメッセージを複数行に跨って出すのですがそれがflymakeと相性が悪いのでエラーメッセージの取得は諦めました。&lt;/p&gt;

&lt;p&gt;多くの場合、 &lt;code&gt;flymake-simple&lt;/code&gt; という枠組みの中で設定を書くのですがテンポラリファイルを作る構造がどうしてもインターフェースファイルと相性が悪かったので生のflymakeを使ってます。
というかflymakeは元々 &lt;code&gt;-ftypecheck-only&lt;/code&gt; みたいなのを前提に作られてたのに実際にコンパイル走らせないとエラーメッセージ取得出来ない言語が多過ぎてフレームワークが出来たのでこれが本来の使い方です。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:311ce9d5e51e732b1928a84bcceb27a3&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;というものがあって、スタイルワーニングを出してくれます。ただ、これはパッチを当てないと使えなかったりスタイルワーニングのみしか出さなかったりするので気が向いた時に紹介します&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>静的なメモリ管理の話。リージョン推論とλ計算からRustまで</title>
      <link>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</link>
      <pubDate>Tue, 21 Apr 2015 00:25:56 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 静的なメモリ管理の話。リージョン推論とλ計算からRustまで
----------------------
サイバーエージェント新卒エンジニア勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 大学では非情報系学科。趣味のプログラマ。
   + 非ガチ勢なので優しくして下さい&gt;&lt;
 * Lisp, Ruby, OCaml, Shell Scriptあたりを書きます


# メモリ管理の話
---------------
(一般的ではない用語)

* 弱い静的メモリ管理
* 強い動的メモリ管理
* (弱い動的メモリ管理)
* 強い静的メモリ管理


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 静的 = コンパイル時にメモリ管理が決定する

### 例

* C言語


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 利点

* 実行時は安定している

### 欠点
* バグる
* 面倒
* 危険


# メモリ管理の話
---------------
## 強い動的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* GCのある言語全般

# メモリ管理の話
---------------
## 強い動的メモリ管理
### 利点

* メモリ管理からの開放

### 欠点

* 動作が不安定 (cf [これがCassandra](http://www.slideshare.net/TakehiroTorigaki/cassandra-21191674))
* パフォーマンスの問題
* リアルタイム性の問題


# メモリ管理の話
---------------
## (弱い動的メモリ管理)
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* バグったGC
  + 普通はない
  + (参照カウント？)


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 静的 = コンパイル時にメモリ管理が決定する


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 利点

* メモリ管理からの開放
* 実行時は安定している
* リアルタイム
* パフォーマンスが出る

### 欠点

* 実現可能性は？


# 強い静的メモリ管理の話をしよう


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 強い静的メモリ管理の話をしよう
------------------------------

* まずは可能性の議論が必要
* 実現可能性
* 実用性


# 可能性の議論
-------------

* プログラミング言語の理論 ≒ λ計算
* そもそもλ計算はメモリのことを考慮してない
  + GCがあるかのように記述される


# 可能性の議論
-------------

* λ計算にメモリ管理まで含めて理論を立てたものは存在する（静的なメモリ管理）
  + リージョンというものをベースにしている [参考](http://www.elsman.com/mlkit/pdf/popl94.pdf)
* さらにリージョンを自動で推論する理論もある（強いメモリ管理）
  + リージョン推論という


# 軽くリージョンの話
-------------------

* 型と同じようにプログラム全体を伝わるメタデータ。
* データが保存される場所を指す。リージョンはいくつもある。
* リージョン推論でデータがどのリージョンに入るかが分かる
* さらにリージョンのサイズもある程度予想がつくので静的に管理出来る
* 関数などは引数のリージョンに対して多相になる「リージョン多相」などもある
* この辺は[Martin Elsmanの論文たち](http://www.elsman.com/mlkit/papers.html)を参考にして下さい
  + [A Brief Introduction to Regions](http://www.elsman.com/mlkit/pdf/ismm98.pdf)とか。



# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* 実現可能性
* 実用性

# 実現可能性

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 実現可能性
-----------

* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;Martin ElsmanによるSML処理系、[ML Kitに一部導入された](http://www.elsman.com/mlkit/pdf/pldi2002.pdf)（多分世界初）
  + 但し完全ではなく、GCと組み合わせてある
  + 動的型付き言語に無理矢理静的型を付けても完全には上手くいかないようなもの？
  + 多分リージョン推論を前提とした言語を設計する必要がある
* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;Cyclone というC likeな文法の言語が完全に[リージョン推論のみでメモリ管理を実現した](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf)


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* 実用性


# 実用性


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Rust言語
----------

* Mozillaが開発した言語
* 2008~
* Cycloneを参考にしたらしい。
* 活発に開発される
* 大きなプロジェクトに現行のレンダリングエンジン、Geckoを置き換えるべく開発された[Servo](https://github.com/servo/servo)がある
  + 既にC++製のGockoの3倍速い
  + 並列レンダリングすればさらに速い。


# Rust言語
----------

* リージョン推論(ライフタイム)でメモリを管理する
  - かなり賢くて、ヒープにアロケートする必要なけばスタックを使う。
* mallocとfreeは全てコンパイル時に自動で挿入される
* (多分)リージョン推論のみでメモリ管理するために所有権という概念がある。
  + 所有権自体は並列性の導入などにも有用だと思われる。
    -  競合状態の回避とか
* その他
  + 代数的データ型とパターンマッチ
  + トレイトベース(non-nominal)のジェネリクス

詳細は[公式ページ](http://www.rust-lang.org/)から


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* ✓ 実用性


# Rustのライフタイムと所有権
-------------------------


&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Cの例
-------

```c
{
    int *x = malloc(sizeof(int));

    // we can now do stuff with our handle x
    *x = 5;

    free(x);
}
```


# Rustに翻訳
------------

```rust
{
    let x = Box::new(5);
}
```


# 少しいじってみる
---------------

trivialに見える

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
---------------

printlnを追加してみる

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);

    println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
----------------

エラーになる。

```
error: use of moved value: `x`
   println!(&#34;{}&#34;, x);
                  ^
```


# 所有権
-------

`add_one` を呼んだ時点で所有権が `add_one` に移るので `println!` では使えない。

```rust
fn main() {
  let x = Box::new(5);

  add_one(x);

  println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 所有権
-------
新たに値を返してもらえば使える。

```rust
fn main() {
  let x = Box::new(5);

  let y = add_one(x);

  println!(&#34;{}&#34;, y);
}

fn add_one(mut num: Box&lt;i32&gt;) -&gt; Box&lt;i32&gt; {
  *num += 1;

  num
}
```


# 所有権の貸し借り
---------------

* さっきの例は面倒。
* `add_one` が `x` を奪ったのが問題。
* `x` を「借り」ることが出来る。


# 所有権の貸し借り
----------------

```rust
fn main() {
  let mut x = 5;

  add_one(&amp;mut x);

  println!(&#34;{}&#34;, x);
}

fn add_one(num: &amp;mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

先の `add_one` はライフタイム(リージョン)アノテーションを省略していた。  
省略せずに書くとこうなる。(リージョン多相)

```rust
fn add_one&lt;&#39;a&gt;(num: &amp;&#39;a mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

スコープの終わりでライフタイムが終わる。

```rust
fn main() {
  let y = &amp;5;     // -+ y goes into scope
                  //  |
  // stuff        //  |
                  //  |
}                 // -+ y goes out of scope
```


# LTの明示的宣言
--------------
こんな構造体を宣言したとする。 `x` はコンストラクタに渡された値のライフタイムを引き継ぐ。

```rust
struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}
```


# LTの明示的宣言
--------------
`f.x`のライフタイムが `y` のライフタイムに制限されるので
`y` より広いスコープにある `x` には代入出来ない。

```rust
fn main() {
  let x;                  // -+ x goes into scope
                          //  |
  {                       //  |
    let y = &amp;5;           // ---+ y goes into scope
    let f = Foo { x: y }; // ---+ f goes into scope
    x = &amp;f.x;             //  | | error here
  }                       // ---+ f and y go out of scope
                          //  |
  println!(&#34;{}&#34;, x);      //  |
}                         // -+ x goes out of scope
```


# まとめ
-------

* メモリ管理の性質についてまとめた
* 静的メモリ管理が出来れば
  + メモリ管理からの開放
  + 実行時は安定している
  + リアルタイム
  + パフォーマンスが出る
* 強い静的メモリ管理の手法としてリージョン推論がある
* Rust言語がリージョン推論を利用している。
* Rustをみんな使おう!


# 参考
* [ML Kit](http://www.elsman.com/mlkit/)
* [Rust](http://www.rust-lang.org/)
* [Allocators in Rust - Baby Steps](http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpでFFIバインディングを書く時の知見</title>
      <link>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</link>
      <pubDate>Sun, 19 Apr 2015 13:51:33 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</guid>
      <description>

&lt;p&gt;κeenです。最近頻繁にSML#を使ってます。SML#のメイン機能の1つであるC連携ですが、ちょっと複雑なことをやろうとするとテクニックが必要になるので共有します。&lt;/p&gt;

&lt;p&gt;Twitterとかにコメントや突っ込みお願いします。&lt;/p&gt;

&lt;h1 id=&#34;簡単な型:017736760057fcde64c6904c3e916b13&#34;&gt;簡単な型&lt;/h1&gt;

&lt;p&gt;型が簡単な関数なら普通に&lt;code&gt;_import&lt;/code&gt;で済みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val puts = _import &amp;quot;puts&amp;quot;: string -&amp;gt; ()
val () = puts &amp;quot;Hello, C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尚、簡単な型とは&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch9.S2.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;にある通り、いわゆる即値、即値の組（タプル）、即値の配列、即値の参照、それらを引数、返り値に持つ関数などです。&lt;/p&gt;

&lt;p&gt;又、以下のような制約もあります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C関数全体の型は，引数リストを組型とするMLの関数型に対応付けられます． ただし，C関数の引数や返り値に書ける相互運用型には，以下の制約があり ます．
   配列型や組型など，Cのポインタ型に対応する相互運用型を，C関数の返り値の 型として指定することはできません．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恐らくGCとの兼ね合いでしょうがつらいですね。stringすら返り値で受け取れません。&lt;/p&gt;

&lt;p&gt;それにこの制約がどこまで効いてるのかが不明で、同じ型でも型付けに成功したり失敗したりすることがあります。例えば上の例でstring型を引数にとる関数をインポートしましたが関数に依ってはstringが相互運用型でないとか怒られることがあります。タプルの配列やタプルの参照などは確実にダメみたいです。&lt;/p&gt;

&lt;p&gt;尚、string型はCでいう &lt;code&gt;const char *&lt;/code&gt; 、タプルは変更不能な構造体へのポインタになるそうです。構造体の即値は扱えないんですね…。また、参照とは別に &lt;code&gt;ptr&lt;/code&gt; 型も存在します。SML#側からは作れず、Cとの相互運用のためだけに存在するようです。&lt;/p&gt;

&lt;h1 id=&#34;魔法の-unit-ptr:017736760057fcde64c6904c3e916b13&#34;&gt;魔法の &lt;code&gt;unit ptr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;じゃあ複雑な型はインポート出来ないのかというとそうでもなく、 &lt;code&gt;unit ptr&lt;/code&gt; 型にしておけばとりあえずインポート出来ます。Cで言うところの &lt;code&gt;void *&lt;/code&gt; です。
邪悪な雰囲気を感じますね。しかしそこは型安全言語、ちゃんと型安全に &lt;code&gt;unit ptr&lt;/code&gt; を扱えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;type file = unit ptr
val fopen = _import &amp;quot;fopen&amp;quot;: (string, string) -&amp;gt; file
val fgetc = _import &amp;quot;fgetc&amp;quot;: (file) -&amp;gt; int
val fclose = _import &amp;quot;fclose&amp;quot;: (file) -&amp;gt; int
val () = let
      val f = fopen(&amp;quot;test&amp;quot;, &amp;quot;r&amp;quot;)
      val c = fgetc(f)
    in
      print(str(chr c));
      fclose(f)
    end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。単に &lt;code&gt;type&lt;/code&gt; で名前をつけてあげれば大丈夫です。SML#側ではポイント先が何であるかには関知せず、インポートしたC関数の間で完結してれば問題ありません。多くのライブラリはそのようなAPIになっているのではないでしょうか。&lt;/p&gt;

&lt;h1 id=&#34;ポインタを扱う:017736760057fcde64c6904c3e916b13&#34;&gt;ポインタを扱う&lt;/h1&gt;

&lt;p&gt;とはいえ時にポインタを扱う必要もあります。構造体の配列を扱えないのでその辺で。&lt;/p&gt;

&lt;p&gt;そういった時に便利なのが &lt;code&gt;SMLSharp_Builtin.Pointer&lt;/code&gt; と &lt;code&gt;Pointer&lt;/code&gt; です。 &lt;code&gt;Pointer&lt;/code&gt; の方は .smi ファイルの中で &lt;code&gt;_require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt; してから使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure SMLSharp_Builtin
  structure Pointer =
  struct
    val identityEqual = _builtin val IdentityEqual : boxed * boxed -&amp;gt; bool
    val advance = _builtin val Ptr_advance : &#39;a ptr * int -&amp;gt; &#39;a ptr
    val deref = _builtin val Ptr_deref : &#39;a ptr -&amp;gt; &#39;a
    val store = _builtin val Ptr_store : &#39;a ptr * &#39;a -&amp;gt; unit

    val toUnitPtr = _builtin val Cast : &#39;a ptr -&amp;gt; unit ptr
    val fromUnitPtr = _builtin val Cast : unit ptr -&amp;gt; &#39;a ptr
    val toCodeptr = _builtin val BitCast : unit ptr -&amp;gt; codeptr
  end
  end

structure Pointer =
struct
  val advance = SMLSharp_Builtin.Pointer.advance

  val load =
      case &#39;a in &#39;a ptr -&amp;gt; &#39;a of
        int =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | char =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.deref

  val store =
      case &#39;a in &#39;a ptr * &#39;a -&amp;gt; unit of
        int =&amp;gt; SMLSharp_Builtin.Pointer.store
      | word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | char =&amp;gt; SMLSharp_Builtin.Pointer.store
      | real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.store

  val isNull : &#39;a ptr -&amp;gt; bool
  val NULL : unit -&amp;gt; &#39;a ptr

  val importBytes : SMLSharp_Builtin.Word8.word ptr * int
                    -&amp;gt; SMLSharp_Builtin.Word8.word vector
  val importString : char ptr -&amp;gt; string
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 、 &lt;code&gt;store&lt;/code&gt; 、 &lt;code&gt;deref&lt;/code&gt; 、 &lt;code&gt;advance&lt;/code&gt; あたりを良く使いそうですね。&lt;/p&gt;

&lt;p&gt;実際にあった話。 &lt;code&gt;struct header { const char *name; int name_len; const char *value; int value_len}&lt;/code&gt; の配列(&lt;code&gt;struct header *&lt;/code&gt;)を扱う必要がありました。
その配列をCの関数に渡して書き換えてもらって、後で値を取り出したいという状況がです。その時値を取り出すコードがこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun getHeader headers i =
      let
          val header_ptr : char ptr ptr = fromUnitPtr(headers)
          val header_ptr = advance(header_ptr, i * 2)
          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val header_ptr = advance(header_ptr , i * 2)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val name = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val nameLen = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val value = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val valueLen = deref(header_ptr)
      in
          if isNull name
          then (NONE, String.substring(importString(value), 0, valueLen))
          else (SOME(String.substring(importString(name), 0, nameLen)),
                String.substring(importString(value), 0, valueLen))
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、タプルは構造体へのポインタなので今回の &lt;code&gt;struct header *&lt;/code&gt; は &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではありません。それは &lt;code&gt;struct header **&lt;/code&gt; になってしまいます。
また、ポインタを扱う関数が &lt;code&gt;ptr&lt;/code&gt; 型しか受け付けないので &lt;code&gt;string&lt;/code&gt; ではなく &lt;code&gt;char ptr&lt;/code&gt; にしておいて後から &lt;code&gt;importString&lt;/code&gt; で文字列にする戦略をとります。&lt;/p&gt;

&lt;p&gt;そして配列のi番目にアクセスしたかったら先述の通り &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではないので地道に &lt;code&gt;char ptr ptr&lt;/code&gt; 2*i個分、 &lt;code&gt;int ptr&lt;/code&gt; 2*i個分ポインタを進めます。
ポインタの型を変える時はダイレクトには変換出来ないようなので一旦 &lt;code&gt;unit ptr&lt;/code&gt; を経由してから変換。そして次のメンバにアクセスするために &lt;code&gt;advance&lt;/code&gt; という形をとります。&lt;/p&gt;

&lt;p&gt;そこまでしたら後は &lt;code&gt;deref&lt;/code&gt; してあげれば欲しい値がとれます。&lt;/p&gt;

&lt;h1 id=&#34;replからのimportと-dynamiclink:017736760057fcde64c6904c3e916b13&#34;&gt;REPLからのimportと &lt;code&gt;DynamicLink&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;SML#のREPLからも勿論インポート出来ますが、SML#のランタイムにリンクされてないライブラリのものはインポート出来ないのでダイナミックリンクを使います。 &lt;code&gt;DynamicLink&lt;/code&gt; にCの &lt;code&gt;dl*&lt;/code&gt; と同じ関数群が用意されているのでそれらを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure DynamicLink =
struct
  type lib (= ptr)
  datatype scope = LOCAL | GLOBAL
  datatype mode = LAZY | NOW
  val dlopen : string -&amp;gt; lib
  val dlopen&#39; : string * scope * mode -&amp;gt; lib
  val dlsym : lib * string -&amp;gt; codeptr
  val dlsym&#39; : lib * string -&amp;gt; unit ptr
  val dlclose : lib -&amp;gt; unit
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;val lib = dlopen(&amp;quot;libawsome.so&amp;quot;)&lt;/code&gt; でライブラリのオープン、 &lt;code&gt;dlsym(lib, &amp;quot;awm_function&amp;quot;): _import () -&amp;gt;unit&lt;/code&gt; で読み込みです。&lt;/p&gt;

&lt;p&gt;これでインポートする関数は必要になった時に読み込んで欲しいのですがトップレベルで &lt;code&gt;val&lt;/code&gt; でバインドすると即読み込まれてしまいます。その辺を上手くやるテクニックがSML#のソースにありました。MySQLのバインディングの部分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun lazy f =
      let
        val r = ref NONE
      in
        fn () =&amp;gt;
           case !r of
             SOME x =&amp;gt; x
           | NONE =&amp;gt;
             let val x = f ()
             in r := SOME x; x
             end
      end

  val lib =
      lazy (fn _ =&amp;gt;
               DynamicLink.dlopen
                 (case OS.Process.getEnv &amp;quot;SMLSHARP_LIBMYSQLCLIENT&amp;quot; of
                    NONE =&amp;gt; &amp;quot;libmysqlclient.16.&amp;quot; ^ SMLSharp_Config.DLLEXT ()
                  | SOME x =&amp;gt; x))

  fun find s = DynamicLink.dlsym(lib (), s)
  val mysql_init =
      lazy (fn _ =&amp;gt; find &amp;quot;mysql_init&amp;quot;
                    : _import (MYSQL) -&amp;gt; MYSQL)


...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遅延評価してますね。これ。呼び出す時は &lt;code&gt;mysql_init () (mysql)&lt;/code&gt; みたいに一旦lazyを剥がさないといけないので注意です。&lt;/p&gt;

&lt;h1 id=&#34;問題とか:017736760057fcde64c6904c3e916b13&#34;&gt;問題とか&lt;/h1&gt;

&lt;h2 id=&#34;cの仕様:017736760057fcde64c6904c3e916b13&#34;&gt;Cの仕様&lt;/h2&gt;

&lt;p&gt;確かCの仕様上構造体のメモリ上の表現にはメンバ以外のものも置いていいことになっていた筈です。
上の方法では変なコンパイラでコンパイルしたコードだと動きそうにないですね。GCCやClangは大丈夫な筈。&lt;/p&gt;

&lt;p&gt;そもそもSML#自体GCCとABI互換なコンパイラでコンパイルしたものじゃないとリンク出来なそうな気がするので杞憂ですかね。&lt;/p&gt;

&lt;h2 id=&#34;メモリ確保:017736760057fcde64c6904c3e916b13&#34;&gt;メモリ確保&lt;/h2&gt;

&lt;p&gt;Cの関数から構造体のポインタが返ってくるケースだと良いんですが自分で構造体を用意してCの関数に渡すケースだとメモリの確保が問題になります。現状、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct header
*prepare_headers(int n)
{
  return malloc(n * sizeof(struct header));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなヘルパ関数を用意して凌いでますが欲しい構造体毎に書かないといけないのであまり嬉しくないです。 &lt;code&gt;sizeof&lt;/code&gt; をSML#側でとれれば単に &lt;code&gt;malloc&lt;/code&gt; をバインドするだけで済むのに。
もう少し欲を言うと &lt;code&gt;malloc&lt;/code&gt; したらGCから外れそうな気がするので明示的に &lt;code&gt;free&lt;/code&gt; する必要がありそうです。GCに載るメモリ確保関数も欲しいですね。
さらに欲を言うとスタックアロケートする版のメモリ確保関数も欲しい。もしかしたら &lt;code&gt;alloca&lt;/code&gt; で大丈夫なんでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;define:017736760057fcde64c6904c3e916b13&#34;&gt;&lt;code&gt;#define&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ヘッダファイル内で定数を &lt;code&gt;#define&lt;/code&gt; してあることが多々あります。それらは地道に手書きでSML#側に持ってくることになりますが気になるのが互換性の問題。
特にOSのヘッダファイルには名前は同じだけどOS毎に値が異なるものが存在します。シグナルとか。OSで条件分岐するか理想的にはプリプロセッサのサポートがあればどうにかなりそうなんですけどねぇ。
現状だとCで定数を返すgetter関数を書いてSML#側でインポートして…ってやればどうにか出来そうですけどやりたくないですね。&lt;/p&gt;

&lt;h2 id=&#34;変数:017736760057fcde64c6904c3e916b13&#34;&gt;変数&lt;/h2&gt;

&lt;p&gt;私はまだ遭遇してないのですがライブラリによってはグローバル変数にアクセスしないといけないものが存在します。これもgetterとsetterを書いて…ってやるとどうにか出来そうですがどうせなら変数のインポートも出来ると良いですよね。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:017736760057fcde64c6904c3e916b13&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SML#でCのバインドを書く時は少しテクニックが必要&lt;/li&gt;
&lt;li&gt;SML#にはポインタを直接扱える関数もある&lt;/li&gt;
&lt;li&gt;それでも機能が足りない時はCでヘルパ関数を書こう。&lt;/li&gt;
&lt;li&gt;ダイナミックリンクライブラリも扱えるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SMLのファンクタに少し踏み込んだ</title>
      <link>http://keens.github.io/blog/2015/04/12/smlnofankutanisukoshifumikonda</link>
      <pubDate>Sun, 12 Apr 2015 19:49:41 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/12/smlnofankutanisukoshifumikonda</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;https://github.com/bleis-tift/SmlSharpContrib&#34;&gt;SmlSharpContrib&lt;/a&gt;にコントリビュートしてます。そこでファンクタを使う用事があったのですが少し踏み込んだ使い方をしようとしたらハマったのでメモ。&lt;/p&gt;

&lt;h1 id=&#34;ファンクタおさらい:921b7b3c7820999b28763bd2de5241d3&#34;&gt;ファンクタおさらい&lt;/h1&gt;

&lt;p&gt;SMLの&lt;code&gt;functor&lt;/code&gt;は&lt;code&gt;structure&lt;/code&gt;に引数がついたもので、モジュールを引数にとり、モジュールを返します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (Args : sig type elem end) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(struct type elem = int end)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;複雑なファンクタ:921b7b3c7820999b28763bd2de5241d3&#34;&gt;複雑なファンクタ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;blog/2015/01/31/mlyaccwotsukattemitehamattatokoro/&#34;&gt;以前mlyaccを使った時&lt;/a&gt;に&lt;code&gt;Join&lt;/code&gt;なる3つのモジュールを引数にとるファンクタが登場したのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの定義を覗いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数のモジュールの他に&lt;code&gt;sharing&lt;/code&gt;なるキーワードも出てきています。それに&lt;code&gt;structure&lt;/code&gt;キーワードもプリフィクスされています。&lt;/p&gt;

&lt;p&gt;先程の例とは大分離れてますね。何があったのでしょう。&lt;code&gt;structure&lt;/code&gt;を付けとけば複数書ける…？&lt;/p&gt;

&lt;h1 id=&#34;省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;省略記法&lt;/h1&gt;

&lt;p&gt;実はファンクタの引数の中では省略記法が使えます。引数のモジュール名と&lt;code&gt;sig ... end&lt;/code&gt;が省略可能なのです。さらに適用の時も&lt;code&gt;struct ... end&lt;/code&gt;も省略可能なのです。&lt;/p&gt;

&lt;p&gt;つまり、最初の例はこうも書けるのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (type elem) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(type elem = int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;モジュール内モジュールと省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;モジュール内モジュールと省略記法&lt;/h1&gt;

&lt;p&gt;そうです。複雑怪奇な&lt;code&gt;Join&lt;/code&gt;ファンクタは省略記法で書かれていたのでした。省略せずに書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(struct
     structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex
     end)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(X: sig
             structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token
             end)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。形式的には引数のモジュールは1つでありながら事実上複数のモジュールを渡していたのです。&lt;code&gt;structure&lt;/code&gt;が付いていたのはモジュール内モジュールだったから、&lt;code&gt;sharing&lt;/code&gt;はモジュール内モジュールに対する制約宣言です。&lt;/p&gt;

&lt;p&gt;なぜこれでハマったかというとSML#のインターフェースファイルでは省略記法が使えなかったからです。地雷の数だけ強くなれるよ♪&lt;/p&gt;

&lt;h1 id=&#34;参考:921b7b3c7820999b28763bd2de5241d3&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://walk.wgag.net/sml/module.html&#34;&gt;モジュール - ウォークスルー Standard ML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch11.S6.xhtml&#34;&gt;ファンクタのサポート in Ch.11. SML#分割コンパイルシステム in プログラミング言語SML#解説&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CyberAgentに入社しました</title>
      <link>http://keens.github.io/blog/2015/04/10/cyberagentninyuushashimashita</link>
      <pubDate>Fri, 10 Apr 2015 19:55:59 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/10/cyberagentninyuushashimashita</guid>
      <description>&lt;p&gt;κeenです。少し遅くなりましたが4/1付で所属が変わったので報告です。&lt;/p&gt;

&lt;p&gt;タイトルにあるように、株式会社サイバーエージェントに入社しました。こう言うとよく「あれ？サムライトじゃないの？」「もっとストイックな所に行くと思ってた」と言われます。サムライトについては特に関係はないです。エンジニア2人と知り合いなだけです。Common Lispだけが幸せの基準じゃありません。
それにキラキラ女子のイメージが強いかもしれませんがサイバーエージェント、結構ストイックですよ？&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/lXs96toe-B8&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;因みに昨日までで全体研修が終わり、月曜から技術研修が始まります。技術研修を受けずに早期配属される同期や果ては&lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1504/03/news134.html&#34;&gt;社長になる同期&lt;/a&gt;も居る中のんびり6月末まで研修を受けます。フロント周りはからっきしなのでこれを機にその辺も勉強しようかと。&lt;/p&gt;

&lt;p&gt;研修はグループワークが多かったのですが一緒のチームにいて優秀だなと思える人に何人も会ってきたしバックグラウンドを訊いてみて尖ってるエンジニアも一杯いたので正式配属されるのが楽しみです。私もそれなりに尖ってるつもりだったのですが精進が足りませんね。&lt;/p&gt;

&lt;p&gt;まあ、マイペースに歩んでいきます&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;よし、来年Clojureおじさんになろう&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/489246490724810752&#34;&gt;2014, 7月 16&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>誰がUTF-32が使われてないなんて言ったんだ</title>
      <link>http://keens.github.io/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</link>
      <pubDate>Tue, 31 Mar 2015 19:41:05 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</guid>
      <description>

&lt;p&gt;最近ではUTF-8でソースコードを書いてUTF-8で出入力をする。それ以外のエンコーディングは使われていない。…だと？誰がそんなこと言ったんだ&lt;/p&gt;

&lt;h1 id=&#34;asciiと古いunicodeと新しいunicode:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;ASCIIと古いUnicodeと新しいUnicode&lt;/h1&gt;

&lt;p&gt;少し長くなるが文字コードの話から始まる。ASCIIはお馴染み最低7bitあればASCIIの定義する文字集合を表せる。&lt;/p&gt;

&lt;p&gt;古いUnicodeは16bitで全ての文字を表わすことを目標に作られた。&lt;/p&gt;

&lt;p&gt;新しいUnicodeは文字(主に漢字)が多過ぎて16bitでは表せなかったので21bitに拡張された。&lt;/p&gt;

&lt;h1 id=&#34;文字コードとエンコーディング:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;文字コードとエンコーディング&lt;/h1&gt;

&lt;p&gt;文字コードをどういう形式で表すかがエンコーディングだ。文字コードが7bit、16bit、21bitだからといってそのままのサイズで表わす訳ではない。ASCIIは普通8bitの型で表わすし21bitの型を用意するよりは32bitの型に格納した方が扱い易そうだ。あるいは8bit型の配列に16bitや21bitを収めるとプログラムコードの変更が少なそうだ。&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8とUTF-16とUTF-32&lt;/h1&gt;

&lt;p&gt;さて、ここまで来ればお分かりだろう。UTF-8はASCIIとの互換性を保つ8bitベースのエンコーディング、UTF-16は古いUnicodeの時に作られて新しいUnicodeにも対応した16bitベースのエンコーディング、UTF-32は新しいUnicodeのために作られた32bitベースのエンコーディングだ。
ここで注意して欲しいのはUTF-8とUTF-16は8bitや16bitの単位を複数使うことで新しいUnicodeの範囲も扱える点、逆に言えば1単位が1文字に対応しない点だ。日本語を含んだ文字列に対して&lt;code&gt;length&lt;/code&gt;を使うと正しい結果が帰って来ないなどの経験は誰しもあるだろう&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32それぞれの特徴:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8とUTF-16とUTF-32それぞれの特徴&lt;/h1&gt;

&lt;h2 id=&#34;utf-8:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8&lt;/h2&gt;

&lt;p&gt;8bit(オクテット)の配列に文字列を収めることになる。16bitや21bitの範囲の文字を表す時は8bitに対してASCIIは7bitしか使わないのでその1bitを使って次に続くことを表わす。最大4オクテットまで使うことがある。 UTF-8の特徴はなんと言ってもASCIIとの互換性があること。UTF-8でASCIIの範囲のみの文字をエンコードするとASCIIと同一になるし、ASCIIでエンコードされたものはUTF-8で読んでも同じ内容になる。なのでどんなエンコードか分からないものはとりあえずUTF-8で読んでおくと間違いが少ない。よって冒頭で書いたように出入力、保存ファイル、GUIに表示する文字列などに使われる。&lt;/p&gt;

&lt;p&gt;UTF-8にも欠点はあり、ASCII外の文字を大量に扱うと空間効率が悪い。さらに先頭から順番に辿らないとどのオクテットが何文字目かも分からないので(配列長が既知であっても)文字列へのlengthやランダムアクセスなどの多くの操作がO(n)になってしまう点だ。文字の置換に至ってはin placeでは出来ないことすらある。&lt;/p&gt;

&lt;h2 id=&#34;utf-16:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-16&lt;/h2&gt;

&lt;p&gt;16bitの配列に文字列を収める。21bitまで扱うために特定の範囲の値が来たら次の16bitも読んで2つ併わせて1つの文字とみなす。このペアをサロゲートペアという。C言語には&lt;code&gt;wchar&lt;/code&gt;なるマルチバイト文字用の型があるが、仕様では最低で16bitという要求になっているのでwcharを使う時はUTF-16でエンコードする（と思う）。UTF-16もUTF-8と同じく文字列操作がO(n)になる。Unicode公式のエンコーディングであるという点を除いて特に良い点が見当たらないので後方互換性の必要な場面でないと使われてなさそうな気がする。例えばWindowsのファイルシステムはファイル名をUTF-16で保持しているらしい。&lt;/p&gt;

&lt;p&gt;尚、16bitのエンディアンは指定されてないのでファイルの先頭にバイトオーダーマーク(BOM)と呼ばれる空白文字を置いてそれでエンディアンを指定/判別する慣習になっている。&lt;/p&gt;

&lt;h2 id=&#34;utf-32:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-32&lt;/h2&gt;

&lt;p&gt;32bitの配列に文字列を収める。必ず32bitで1文字を表すので文字列操作が効率的に行なえる。欠点はASCIIの範囲の文字が多いとメモリを無駄にし易い点。どんな文字列を扱うか分からない(ASCIIの範囲が多いとは言い切れない)汎用ライブラリや言語処理系そのものでよく使われる。&lt;/p&gt;

&lt;h1 id=&#34;言語処理系の内部表現と外部エンコーディング:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;言語処理系の内部表現と外部エンコーディング&lt;/h1&gt;

&lt;p&gt;ここで罠になるのがソースコードをUTF-8で書いて出入力をUTF-8で行なう処理系でも内部では先述の理由でUTF-8以外を使うことがあることだ。メジャーな言語について少し調べてみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SBCL(Common Lispのメジャーな処理系)はUTF-32を使う&lt;/li&gt;
&lt;li&gt;SpiderMonkey(FirefoxのJavaScript処理系)はUTF-8を使う。HTMLはマルチバイト文字を使う言語で書かれていても大半がASCIIになるからとのこと。また、文字列をropeで表現しており、UTF-8のデメリットを軽減出来る。&lt;/li&gt;
&lt;li&gt;Rubyは多言語対応の時に内部表現はなんでもアリ(渡された文字列そのまま)になった&lt;/li&gt;
&lt;li&gt;PerlはUTF-8を使う&lt;/li&gt;
&lt;li&gt;PythonはconfigureのオプションでUCS2(ほぼUTF-16に同じ)やUCS4(UTF-32形式のUnicodeと概ね互換)が選べる。FedoraやUbuntuはUCS4でビルドしている&lt;/li&gt;
&lt;li&gt;PHPは言語で動的に変更出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ソースコードをUTF-8で書いて出入力をUTF-8で行なうから変換コストなんてないと思ったら大間違いだ。裏ではUTF-32が使われていて、出入力の度に変換が走る。誰がUTF-32が使われてないなんて言ったんだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>caveman2、ningle…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト</title>
      <link>http://keens.github.io/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</link>
      <pubDate>Thu, 05 Mar 2015 13:18:44 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# caveman2、ningle、datafly…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト
----------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;ずっと俺のターン&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 問題
------
Common Lispは case

* Sensitive &lt;!--.element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;  
* Insensitive &lt;!--.element: class=&#34;fragment shrink&#34; data-fragment-index=&#34;1&#34; --&gt;

どっち?

# 問題
-------

あれ？

```lisp
(eql? &#39;CaseInsensitive &#39;caseinsensitive) ;=&gt; t
```


# 問題
-------

リーダがデフォルトで大文字にするだけ

```lisp
(eql? &#39;|CaseSensitive| &#39;|casesensitive|) ;=&gt; nil
```


# Caveman2
---------

```lisp
@route GET &#34;/hello&#34;
(defun say-hello (&amp;key (|name| &#34;Guest&#34;))
  (format nil &#34;Hello, ~A&#34; |name|))
```

# Ningle
--------

```lisp
(setf (ningle:route *app* &#34;/login&#34; :method :POST)
      #&#39;(lambda (params)
          (if (authorize (getf params :|username|)
                         (getf params :|password|))
            &#34;Authorized!&#34;
            &#34;Failed...Try again.&#34;)))
```

# 面倒…
----
デフォルトでそのままだたっらいいのに

# 魔法の`readtable-case`

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 魔法の`readtable-case`
-----------------------

```lisp
(setf (readtable-case *readtable*) :invert)
```
を使えばOK  
参考: [SBCLでclispとかallegroのmodern mode的なことをする - wasabizの日記](http://wasabiz.hatenablog.com/entry/20120929/1348889601)

# 例
----

```lisp
CL-USER&gt; :username
:USERNAME
CL-USER&gt; (setf (readtable-case *readtable*) :invert)
:invert
CL-USER&gt; :username
:username
```

# まとめ
--------
* `(setf (readtable-case *readtable*) :invert)`を使うと快適だよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Lispエイリアンの矢印作った</title>
      <link>http://keens.github.io/blog/2015/03/03/lispeiriannoyajirushitsukutta</link>
      <pubDate>Tue, 03 Mar 2015 21:30:13 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/03/03/lispeiriannoyajirushitsukutta</guid>
      <description>&lt;p&gt;κeenです。勉強会などで役立ちそうなLispエイリアンの矢印を作りました。&lt;/p&gt;

&lt;p&gt;Lispエイリアンの元データは&lt;a href=&#34;http://www.lisperati.com/logo.html&#34;&gt;こちら&lt;/a&gt;でPNGやSVGで公開されているのでInkscapeの練習がてらそれをいじりました。&lt;/p&gt;

&lt;p&gt;どうぞ&lt;br /&gt;
&lt;img src=&#34;http://KeenS.github.io/images/lisplogo_alien_arrow.svg&#34; alt=&#34;lisplogo_alien_arrow.svg&#34; /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://KeenS.github.io/images/lisplogo_alien_arrow.svg&#34;&gt;lisplogo_alien_arrow.svg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ライセンスは元データに倣ってパブリックドメインとします。&lt;/p&gt;

&lt;p&gt;PNG形式のもの必要…ですか？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>既存のテンプレートエンジンの問題点と再設計</title>
      <link>http://keens.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</link>
      <pubDate>Mon, 02 Mar 2015 23:36:03 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt;
.red {
color: red;
}
&lt;/style&gt;
# 既存のテンプレートエンジンの問題点と再設計、あるいはArrowsについて
-----------------------------------------------------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 野生のLisper
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

# Template Engines

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Existing Architeture
----------------------
0. (リクエスト)
1. アプリ
  0. 引数を計算
  1. テンプレートに引数を渡す
  2. レスポンスをレンダリング &lt;!--.element: class=&#34;fragment grow&#34;  --&gt;
4. レスポンスをサーバに渡す
5. (レスポンス)

# Rendering?
----------------------
* 結合した文字列はクライアントに返ったらその後はゴミ
 + GCへ負荷がかかる (後述)
* クライアントにとって1つの文字列である必要はない
* むしろ返せる部分だけ先に返した方が得（後述）

# GC Pressure (SBCL)
-----------------
* 世代別Copy GC
* 結合した文字列は比較的大きい
* `alloc_space`に入らない大きさならアロケートが遅い
* GCを頻繁に起動してしまう
* 16KBを越えると特別扱いされて遅い/メモリを喰う
* LispのWebアプリはレスポンスタイムの分散が大きい（要出展）

参考: [SBCL GENCGC @ x86 Linux](http://cl-www.msi.co.jp/reports/sbcl-gc-memo.html)

# Split Response
---------------
例えば、こんなの

&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot; xml:lang=&amp;quot;en&amp;quot; lang=&amp;quot;en-us&amp;quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://localhost:1313//reveal.js/lib/css/xcode.css&amp;quot;&amp;gt;
        &amp;lt;script src=&amp;quot;//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
        ....
        &amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body class=&amp;quot;li-body&amp;quot;&amp;gt;
    &amp;lt;header&amp;gt;{{ header }}&amp;lt;/header&amp;gt;
    {{ body }}
    ...
&lt;/code&gt;&lt;/pre&gt;

# Split Response
---------------
1. `{{ header }}`の前に先頭から`&lt;header&gt;`までを返す
2. `{{ header }}`を返す
3. `&lt;/header&gt;`を返す
4. `{{ body }}`を返す

...


# Pros of Split Response
------------------------
* `header`を計算してる間にクライアントにhead部分が渡る
  + 先に`&lt;link&gt;`や`&lt;script&gt;`を要求出来る
  + サーバ側のスループットやレスポンスタイムは変わらないが
    クライアントのレンダリング完了までの時間は大幅に短縮出来る
* 文字列を結合する必要がない
* 定数部分については長さが判ってるので最適化し易い

# How TEs Work 
---------------------------
## Compilation
1. テンプレート文字列
 + パーサ &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
 + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数

# How TEs Work 
---------------------------
## Rendering
1. レンダリング関数
 + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列

# Misc Problems
---------------
* サーバに渡すのは文字列なのにソケットに書き込む時はオクテット？
  + 文字列で返す？オクテットで返す？（デバッグがー）
  + オクテットの変換はいつ？
* ストリームが遅い？
  + POSIX APIが使える&#34;なら&#34;fdの方が速い？
* ユーザが用意したバッファに書き出したい？
* テンプレートに渡す引数が定数文字列なら畳み込める筈？
* リクエストの度にテンプレートパースするのは筋悪だけど開発中は毎回コンパイルするのは面倒？

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;

# Arrows

Template flies like an arrow

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Arrows
--------
* [KeenS/arrows](https://github.com/KeenS/arrows)
* 現在開発中のテンプレートエンジン
* 複数のテンプレートが選べる（予定）
* 複数のバックエンドが選べる
* バックエンドに依ってはnon-consing

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Compilation
1. テンプレート文字列&lt;span class=&#34;red&#34;&gt; + 定数引数&lt;/span&gt;
  + パーサ&lt;span class=&#34;red&#34;&gt;(default, cl-emd互換...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
  + &lt;span class=&#34;red&#34;&gt;最適化(const folding, concat, convert...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
  + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数&lt;span class=&#34;red&#34;&gt;(string, octets, stream, fast-io ...)&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Rendering
1. レンダリング関数
  + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列&lt;span class=&#34;red&#34;&gt;、オクテット列、ストリーム書き出し、fast-io…&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How compiled
--------------

```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を

```lisp
(compile-template-string :xxx
  &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34; ())
```
とコンパイル

# Stream backend
----------------
&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* ほとんどアロケートしない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Octet backend
----------------

```lisp
(lambda (&amp;key name)
  (with-fast-output (buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;&lt;h1&gt;Hi &#34;)
       buffer)
    (fast-write-sequence
      (string-to-octets
        (encode-for-tt (princ-to-string name)))
                       buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;!&lt;/h1&gt;&#34;)
      buffer)))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------

```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を

```lisp
(compile-template-string :stream
   &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34;
   &#39;(:known-args (:name &#34;&lt;κeen&gt;&#34;)))
```
とコンパイル

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## variable folding

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string (encode-for-tt &#34;&lt;κeen&gt;&#34;) stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 既知の引数は畳み込む
* 文字列なら`princ-to-string`しない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## const folding

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string &#34;&amp;lt;κeen&amp;gt;&#34; stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 定数のエスケープはコンパイル時に済ませる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## append sequence

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &amp;lt;κeen&amp;gt;!&lt;/h1&gt;&#34;
                stream))
```
* 複数シーケンスの書き出しは1つにまとめる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
* 引数計算の遅延
* 引数計算の並列化
* 非同期化
* HTML compction

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の遅延
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は必要になったら値を計算する(Promise パターン)

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の並列化
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は並列に計算して必要になったら値を要求する(Futureパターン)

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 非同期化
* 単純にwriteを非同期にする
* 他にFutureもブロックするので非同期Futureを使う

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## HTML compction

```html
&lt;ol&gt;
  &lt;li&gt; item 1 &lt;/li&gt;
  &lt;li&gt; item 2 &lt;/li&gt;
  &lt;li&gt; item 3 &lt;/li&gt;
&lt;/ol&gt;

```
を

```html
&lt;ol&gt;&lt;li&gt;item 1&lt;/li&gt;&lt;li&gt;item 2&lt;/li&gt;&lt;li&gt;item 3&lt;/li&gt;&lt;/ol&gt;

```
* DOM構造が変わってしまう


&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# TODOs
-------
* 設計上複数シンタックスをサポート可能だがまだしてない
* 既存のテンプレートエンジンとの比較ベンチマーク
* 高速化
* 多機能化
  + テンプレート
  + 最適化
  + バックエンド
* clackとの連携
  + clackのAPIはメモリアロケーションが多めに必要になる

# Summary
---------
* 既存のテンプレートエンジンは非効率
  + メモリを無駄遣いしていた
  + ユーザーのことを考えてなかった
* 新しいテンプレートエンジンを設計した
  + メモリアロケーションをあまりしない
  + ユーザー側の速度まで考慮した
  + 柔軟
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>面接でLispを口にして落ちない企業、私気になります！</title>
      <link>http://keens.github.io/blog/2015/02/10/mensetsudelispwokuchinishiteochinaikigyouwatashikininarimasu</link>
      <pubDate>Tue, 10 Feb 2015 08:01:35 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/02/10/mensetsudelispwokuchinishiteochinaikigyouwatashikininarimasu</guid>
      <description>

&lt;p&gt;κeenです。先日の記事がやたら拡散しました。その中で&lt;/p&gt;

&lt;p&gt;「面接でLispは口にしない方が良い。100%落ちる。」&lt;/p&gt;

&lt;p&gt;の一文がえらく気に入られたようです。Lispの風評被害を防ぐために1つアンケートにご協力下さい。&lt;/p&gt;

&lt;p&gt;このスプレッドシートです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1dUUOSpKqPK_tMqboxzAfPaL1eAEVwAdYy4AP_5HWeVw/edit?usp=sharing&#34;&gt;面接でLispを口にして落ちない企業調査表 - Google スプレッドシート&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;「うちの会社は面接でLispを口にしても落ちないぜ」って方はお手隙ならば書いて下さると嬉しいです。単純な興味目的のゆるふわなアンケートです。調査項目は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;会社名&lt;/li&gt;
&lt;li&gt;会社のURL&lt;/li&gt;
&lt;li&gt;書いた人(本名、スクリーンネーム、なんかのIDかは任意。IDにすると連絡がとれて便利かも)&lt;/li&gt;
&lt;li&gt;コメント、会社のアピールなど(長文可、任意)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;で。&lt;/p&gt;

&lt;p&gt;利用規約(？)は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;社員が書く。会社に全く書かない人は勝手に書かない。&lt;/li&gt;
&lt;li&gt;改竄を防ぐために一度書いたら同じ人しか編集してはいけない。同じ会社の人でもダメ。&lt;/li&gt;
&lt;li&gt;どっかのメディアに掲載されても怒らない。&lt;/li&gt;
&lt;li&gt;メディア側は改竄なしでリスト全部を引用し、引用した日時も付記する。あるいはURLにリンクを張る。二次引用は禁止する。&lt;/li&gt;
&lt;li&gt;問題が生じたら管理者(@blackenedgold)がこのスプレッドシートを非公開にする。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こんなもんですかね。ゆるふわアンケートなので書く側もゆるふわな気持でお願いします。&lt;/p&gt;

&lt;h1 id=&#34;補足:9e6d9857d06fd9b1ba5f4a8582464265&#34;&gt;補足&lt;/h1&gt;

&lt;h1 id=&#34;面接でlispは口にしない方が良い-100-落ちる-について補足:9e6d9857d06fd9b1ba5f4a8582464265&#34;&gt;「面接でLispは口にしない方が良い。100%落ちる。」について補足&lt;/h1&gt;

&lt;p&gt;振り返ってみるとそんなことはありませんでした。就活のある時点までは確かに真で、次の面接でLispを口にしなかったら落ちなかったのでそんなイメージになってました。
しかしよく考えたら私が内定頂いたところはむしろ全部Lispのおかげで内定頂きました。こっちの情報の方が大事だった。拝承。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>就活について思ったことをここに書き記す</title>
      <link>http://keens.github.io/blog/2015/02/07/shuukatsunitsuiteomottakotowokokonikakishirusu</link>
      <pubDate>Sat, 07 Feb 2015 14:27:58 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/02/07/shuukatsunitsuiteomottakotowokokonikakishirusu</guid>
      <description>

&lt;p&gt;私は今4年生なので去年の今頃は就活なんてものをしていた。下の代から若干日程が変わっているがそろそろ就活ムードが出てきているのでなんか吐いておく。思い出かもしれないし愚痴かもしれないし毒かもしれない。経験かもしれないし他人の代弁かもしれない。後輩の役に立つかもしれないし人事の方に向けたメッセージかもしれない。&lt;/p&gt;

&lt;p&gt;念のために書いておくが私はIT系の会社のプログラマ、エンジニア職ばかり応募していた。他の業界、職種に当て嵌まるとは限らない。&lt;/p&gt;

&lt;p&gt;注意&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;良かった企業は名前を出す、悪かった企業はここには名前を書かない方針にする。悪かった企業の具体名が知りたかったら&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt;に訊いて下さい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;リクナビ-メール:019fa2f68fcb27779e09f21baadfe988&#34;&gt;リクナビ、メール&lt;/h1&gt;

&lt;p&gt;周りの流れに乗せられてリクナビに登録することになる。個人情報を大量に打ち込む。すると大量のメールが届く。正直、情報量はゼロに近い。メールは受信しないにチェックした方が良い。&lt;/p&gt;

&lt;p&gt;リクナビの価値は3割くらいがポータルサイトとしての価値、残り7割くらいがリクナビ経由でしか募集してない企業にエントリーするためだけのもの。そういう企業にエントリーしないならリクナビにはあまり近寄らない方が良い。リクナビのサイトは非常に良く出来ていて、不安を煽る情報を的確に伝えてくる。本当にその辺の企業のサイトに爪の垢を煎じて飲ませてやりたいくらいに良く出来ている。&lt;/p&gt;

&lt;p&gt;一応何社かはリクナビ経由で知ってエントリーした。一々個人情報を手打することなくワンクリックでエントリー出来るのは負担を軽減してくれる。統一されたUIで情報を見れるのにはそれなりの価値はある。でもあまり齧りつきすぎると毒に冒される。2週間程放置しておくと「企業からの特別オファー」なる量産メッセージが1000通くらい溜まる。&lt;/p&gt;

&lt;p&gt;Twitterや勉強会で社員と知り合って採用情報などを得られるならそっちを頼った方が良い。Twitterに流れてくる情報の方が有用。&lt;/p&gt;

&lt;h1 id=&#34;説明会:019fa2f68fcb27779e09f21baadfe988&#34;&gt;説明会&lt;/h1&gt;

&lt;p&gt;エントリーに必須でない限り行かなかった。少なくともIT系企業ならWebページの採用情報が一番情報が充実して然るべきだ。&lt;/p&gt;

&lt;h1 id=&#34;マイページ-エントリーシート-性格診断:019fa2f68fcb27779e09f21baadfe988&#34;&gt;マイページ、エントリーシート、性格診断&lt;/h1&gt;

&lt;p&gt;リクナビ経由でエントリーしても結局は企業毎のマイページなるものに登録し、そこで情報を得ないといけない。エントリーシートの提出や面接の登録など。&lt;/p&gt;

&lt;h2 id=&#34;マイページ:019fa2f68fcb27779e09f21baadfe988&#34;&gt;マイページ&lt;/h2&gt;

&lt;p&gt;IT系の企業ならまずはそのマイページが評価基準になる。外注としても最低限のラインというのがある筈だ。マイページ登録にもまた個人情報を大量に打ち込む。まずエントリー時点でそこまで情報が必要なのか、とか大量の情報を入力させるに当たってどこまでUXを考えてるかとか。&lt;/p&gt;

&lt;h3 id=&#34;事例1-とあるグローバル人材を求める企業:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例1 とあるグローバル人材を求める企業&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;入力項目の説明に日本語と英語を併記していた。半分はゴミ情報なので酷く見づらかった&lt;/li&gt;
&lt;li&gt;最初に出身大学が国内か海外かのラジオボタンがあった。その次に出身大学を選ぶウィザードがあった。ウィザードの最初の質問は「出身大学は国内ですか？海外ですか？」のラジオボタン。&lt;/li&gt;
&lt;li&gt;住所と郵便番号も同じようなウィザードだった。住所をウィザードで選んでいくと郵便番号が自動で入力される。その次の項目は住所を手入力だった。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;事例2-yahoo-japan:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例2 Yahoo! JAPAN&lt;/h3&gt;

&lt;p&gt;具体的には覚えてないけど入力補完があった。郵便番号を入力すると住所も自動で入力された。一番使い易かった。&lt;/p&gt;

&lt;h3 id=&#34;事例3-ワークスアプリケーションズ-テクノロジスペシャリスト採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例3 ワークスアプリケーションズ テクノロジスペシャリスト採用&lt;/h3&gt;

&lt;p&gt;そもそもマイページは必要なかった。エントリーには2〜3個のフォーム入力と返信用のメールアドレスのみで良かった。最高。&lt;/p&gt;

&lt;p&gt;次にマイページの内容。クッキーを焼いて「こんにちはn回目の訪問ですね」なんてやってたら即切る。大抵対応ブラウザも書いてあるからそこも見る。モダンブラウザはサポート外とか言ってたら渋い顔になる。私の就活後半は丁度Windows XPのサポートが切れた時期なのでその辺でまだIE 6のサポートをしてたらやっぱり渋い顔になる。対応OSがWindowsとOS Xとか書いてたらキレる。IT系でLinuxユーザは相手にしないだと？&lt;/p&gt;

&lt;h2 id=&#34;エントリーシート:019fa2f68fcb27779e09f21baadfe988&#34;&gt;エントリーシート&lt;/h2&gt;

&lt;p&gt;割と企業の個性が出る。熱意とか意気込みとかはコピペなりでどうにでもなってしまうので適当に書く。そればっか訊いてくるところはエントリーをやめる。書くのに手間が書かるのにまともな基準で評価されてるか分からないから。簡単に詐称可能でしょ…&lt;/p&gt;

&lt;p&gt;これまでの実績とかを訊いてきたらGithubアカウントとかTwitterアカウントとかブログとか大会実績とか過去のLT資料とかを張る。興味のある分野を書く。大抵Markdown形式で書いたがどこもプレビューで改行エスケープをしてなかったので箇条書きが酷く見辛かった。字数は気にしない。&lt;/p&gt;

&lt;h2 id=&#34;性格診断:019fa2f68fcb27779e09f21baadfe988&#34;&gt;性格診断&lt;/h2&gt;

&lt;p&gt;最悪の体験。まず、Windows+IEかOS X+Safariにしか対応してない。単に対応してないだけじゃなくてご丁寧にUAを見てそれ以外を弾く。IT系ならLinuxユーザも居るだろうに。そして内容だが、似たような質問を何度も繰り返す。ただでさえWindowsを使わされてイライラさせられているのに更に追い討ちを掛けてくる。さっきも答えただろ、と悪態をつきながら地獄の20分に耐えることになる。SAN値がほぼ0になる。あれをやらせてる人事の方々は一回体験してみた方が良いと思いますよ。その上であの性格診断が必要か判断して下さい。どっかの企業で性格診断無視してたら普通にそのまま選考進んだ。マジで存在価値が分かならい。&lt;/p&gt;

&lt;h2 id=&#34;筆記試験:019fa2f68fcb27779e09f21baadfe988&#34;&gt;筆記試験&lt;/h2&gt;

&lt;p&gt;SPだっけ？IS？なんかそんなやつ。一回だけ受けた。さんすうとこくごの問題をひたすら解く。英語もあったっけ？覚えてないや。指定の会場じゃないと受けられないし順番待ちがあるしクソみたいな問題しか出ないし2回目は受けたくない。何の判断に使われるかもイマイチ分からない。必要ないなら止めて欲しい。&lt;/p&gt;

&lt;p&gt;それではなくて情報技術/科学に関する問題を出してきたところがあった。LINE。カバー範囲が広く、全ての問題に正当することは要求しない。回答を見て適正を決めて次の面接官を決めてたらしい。非常に良い。出来れば問題用紙を持ち帰らせてくれれば後学に使えたのにと思った。問題使い回してるのかな？&lt;/p&gt;

&lt;h2 id=&#34;プログラミング課題:019fa2f68fcb27779e09f21baadfe988&#34;&gt;プログラミング課題&lt;/h2&gt;

&lt;p&gt;課してくるところは少なかった。楽しいプログラミングかと思いきやそうでもなかった。&lt;/p&gt;

&lt;h3 id=&#34;事例1:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例1&lt;/h3&gt;

&lt;p&gt;言語指定があった。Java。しかもJavaで解くには凡そ不向きな問題。つながりのある複数の問題だったのに1問につき1ファイル指定で共通する機能をクラスに切り出すことも許されなかった。因みにお題は「共通化を考えながら解け」。&lt;/p&gt;

&lt;h3 id=&#34;事例2:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例2&lt;/h3&gt;

&lt;p&gt;仕様があいまいだった。「与えられた入力に対して」。入力はどう与えられるの？標準入力？コマンドライン引数？関数の引数？どれでも良いならそう書いて欲しい。さらに悪いことに時間指定があった。4時間。それは良いんだけど40分くらいで解いて提出したらログインセッションが切れてた。もう一回ログインしたらもう一回課題を受けれた。既に手元に回答は準備してあるので即座に提出したら普通に受理された。よくわからない。ちなみにその企業は唯一エントリーシートで落ちた。&lt;/p&gt;

&lt;h1 id=&#34;面接:019fa2f68fcb27779e09f21baadfe988&#34;&gt;面接&lt;/h1&gt;

&lt;p&gt;自分の話じゃないけどエントリーしまくってた友人は交通費で破産しかけてた。交通費は出してくれると嬉しいけど手続面倒だよねー。Skype面接とか？自分は近場の企業を、それも少数だけにしかエントリーしない方針で凌いだ。1つ落ちたら1つ新たにエントリーした。&lt;/p&gt;

&lt;p&gt;スーツはあまり着たくない。特にIT系なら勤務も私服だし面接も私服OKなところが多い。服装に言及がないとかスーツ必須とかだと悪目立ちする。服装に言及がないときは募集ページのプログラマが私服かどうかで判断していた。一回、募集ページは私服なのに面接官はスーツを着ていることがあった。面接だから、とのこと。学生相手にそこまで気を遣う必要はないと思うのだがお作法なのだろうか。あとエレベータホールまで見送りにきてさらにエレベータの扉が閉まるまで深々と御辞儀されるのも恐縮だ。&lt;/p&gt;

&lt;p&gt;内容はまあいいや。変な質問をされたことはない。こちら一人に対して面接官3人とか4人とかは圧迫感があって嫌だった。あ、一回「スクリプト言語でもディスクIOバウンドやネットワークIOバウンドなら高速なアプリケーションを書ける」と言ったら面接官に「は？」って言われたのが気になった。CPUバウンドじゃないならアーキテクチャの問題だからむしろアプリを簡単に書き換えられるLLで記述すべきでしょ。因みにその面接で落ちた。&lt;/p&gt;

&lt;p&gt;面接でLispは口にしない方が良い。100%落ちる。&lt;/p&gt;

&lt;p&gt;最後に質問はあるかと聞かれる。そんなものはない。エントリーした時点で公開情報で十分納得してある。内定が出たら即座に決めるつもりだ。もう情報は必要ない。面接が早く終われば授業に間に合うかもしれない。早く帰してくれ。聞ける場を用意してくれるのは非常に良いことなんだが質問の内容で評価するのは止めてほしい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;その他の事も色々言いたい。&lt;/p&gt;

&lt;h1 id=&#34;時間:019fa2f68fcb27779e09f21baadfe988&#34;&gt;時間&lt;/h1&gt;

&lt;p&gt;なんか大学生なんだから暇でしょみたいな雰囲気になってる。そんな訳はない。普通に授業がある。遊んでる大学生はごく一部だ。少なくともうちの大学だと遊べるのは1、2年までで3、4年からが勉強の本番になる。空き時間はレポートなりゼミの準備なりバイトなりサークルなりのために空けてある。面接と往復の時間を考えたら授業を1つ2つ犠牲にする必要がある。一応空いてる時間を訊いてくるがこちらが指定しても「それだとこちらが都合が悪いので他を指定して下さい」となって結局授業を潰すことになる。面接にしろ試験にしろ無駄なステップは省いて欲しい。学生の本分は勉強だ。&lt;/p&gt;

&lt;h1 id=&#34;時刻:019fa2f68fcb27779e09f21baadfe988&#34;&gt;時刻&lt;/h1&gt;

&lt;p&gt;機械送信のメッセージの他に手動で送られてくるメールや電話がある。あれの時間は結構気にする。まず、電話はやめて欲しい。電話で連絡取るにしても掛け直すときは前回とは時間帯をずらすとかしてほしい。学生なのだから毎日時間割ベースで活動している。電話をとれない時間帯は固定されている。前日と同じ、電話をとれない時間に電話が掛かってきたら正直バカなの？と思ってしまう。&lt;/p&gt;

&lt;p&gt;あと遅い時間や休日に連絡が来るとあまり良い顔にはならない。困る訳じゃなくて社員がその時間に活動しているということは残業や休出があるということだ。出来ればそういう会社は避けたい。&lt;/p&gt;

&lt;h1 id=&#34;ob訪問:019fa2f68fcb27779e09f21baadfe988&#34;&gt;OB訪問&lt;/h1&gt;

&lt;p&gt;ある企業でマイページ作ったらOB(というか同じ大学出身なだけの全く関係のない社員)と会う場をセッティングされそうになった。しかし相手は人事。話をしたいとしたらエンジニアだ。人事の方には興味はない。無駄な時間は使いたくない。&lt;/p&gt;

&lt;h1 id=&#34;エントリーする企業の決め方:019fa2f68fcb27779e09f21baadfe988&#34;&gt;エントリーする企業の決め方&lt;/h1&gt;

&lt;p&gt;Twitterや勉強会で知った人とかあるいは興味の湧くスライドを書いた人とかの会社を採用ページを見るところから始める。募集要項を見て気に入れば他のPRページも見る。気に入ればエントリーする。あとはGithub採用やってるところはとりあえず出す。他は名前知ってる有名企業とか。&lt;/p&gt;

&lt;p&gt;見るところは勤務形態の自由さ、年収、技術力。技術職なのだから自分の技術力を発揮出来てそれが評価されてまた仕事でスキルアップ出来る所が良い。&lt;/p&gt;

&lt;p&gt;自分の技術力を発揮出来るというのはつまらない規約で制限されないか。スーツ着用とかありえない。合理的理由が全くない。袖のボタンがキーボードに引っかかって作業し辛い。環境を自分の好きに選べるか。椅子、ディスプレイ、キーボード、OS、エディタ等々。バランスボールがオフィスにあると評価が上がる。&lt;/p&gt;

&lt;p&gt;評価されるというのは具体的には年収。札束で頬を引っ張たけばエンジニアは集まる。&lt;/p&gt;

&lt;p&gt;技術力は恐らく会社のWebページでは評価出来ない。中のエンジニアを勉強会で知った、スライドを見た、有名OSSのコミッタが居る、会社のGithubレポジトリの内容。鮎の友釣みたいにエンジニアを自由にさせておけば他のエンジニアも集まる。技術力を求めるのは自分のスキルアップという積極的な理由もあるし、クソコードをレビューしたくないという消極的な理由もある。&lt;/p&gt;

&lt;p&gt;割と年収が決め手だったりする。初任給は高く見えるように書いておいた方が良い。見た目は低くても手当てを入れると手取りがそれなりになるなら参考年収とかを書くと分かり易い。&lt;/p&gt;

&lt;p&gt;因みに会社の将来性は気にしてない。転職が盛んな職種なのだから傾いたら出ていく。&lt;/p&gt;

&lt;p&gt;正直経団連の企業は上の条件を満たしていそうにないので目も呉れてない。向こうも私のような人は求めてないだろうし多分棲み分けが出来てる。主にベンチャーを見ていた。&lt;/p&gt;

&lt;h1 id=&#34;コーディング面接:019fa2f68fcb27779e09f21baadfe988&#34;&gt;コーディング面接&lt;/h1&gt;

&lt;h2 id=&#34;事例1-1:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例1&lt;/h2&gt;

&lt;p&gt;面接で予告なくコーディングがあった。まあ、それは良い。与えられた環境はWindows XP + Eclipseだった。その時点で既にXPのサポートは切れてた。椅子蹴っ飛ばして帰ろうかと思った。一応受けたけどEmacs入ってないしqwertyだしjp配列だしCaps Lockのままだしなんか数分に1回警告が出て邪魔されるし最悪だった。環境固定はありえないなと思った。&lt;/p&gt;

&lt;h2 id=&#34;事例2-pixiv:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例2 pixiv&lt;/h2&gt;

&lt;p&gt;抜き打ちでホワイトボードコーディングをやった。リファレンスや補完が無くても書ける程度の問題だったし「多分この問題はここを訊いてると思うんですが…」「おぉ？！」とか盛り上がってたし楽しかった。シェル芸も披露した。上がり性の人にはつらいのかもしれないけど個人的には積極的にやって欲しい。&lt;/p&gt;

&lt;h2 id=&#34;事例3:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例3&lt;/h2&gt;

&lt;p&gt;採用フローにオンサイトのプログラミング試験があるところがあった。用意される環境はMac ProとJava 7とEclipseとJava 7のリファレンスだったかな？リファレンスが用意されてる時点でお察しと思うがインターネット接続禁止。なんでや。ググり力が一番大事でしょ。あと環境固定は最悪だって。それ見て受けるのやめた。&lt;/p&gt;

&lt;h1 id=&#34;github採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;Github採用&lt;/h1&gt;

&lt;p&gt;積極的にやってほしい。こちらの負担は軽いから。が、エンジニアへの負担がどれほどなのか分からない。あと(学部生なら)Githubを覚え始める頃と就活を始める頃が重なると思うので「これから伸びる」も考慮してくれると嬉しいなー。自分のGithubアカウントが充実し出したのは就活が終わってからだった。&lt;/p&gt;

&lt;p&gt;一定期間アカウントを観察して行動を見て決めるのなら期間を考えて欲しい。観察期間と試験期間が重なって観察期間中1コミットも出来ないことがあった。&lt;/p&gt;

&lt;p&gt;採用側のコストが低いなら一番推奨されるべき。&lt;/p&gt;

&lt;h1 id=&#34;プロコン採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;プロコン採用&lt;/h1&gt;

&lt;p&gt;あまり感心しない。&lt;a href=&#34;http://keens.github.io/blog/2014/12/18/saiensugaenziniaringu/&#34;&gt;前にもポエム書いた&lt;/a&gt;ようにあれはサイエンスであってエンジニアの採用に有用とは思わない。むしろプロコン採用をやってるところはその辺分かってなさそうで評価が下がる。勿論、動画コーデックの開発をしているドワンゴのようにそういう人材が実際に必要なところはその限りではない。そういうところは積極的にアピールしてくれると誤認が少なくて助かる。&lt;/p&gt;

&lt;p&gt;一応言うとプログラマの中から適性のあるプログラマを見出す方法としては感心しない、と言っている。プログラマ志望の中からプログラム書けるプログラマを見出す方法としてはアリなんじゃないですかね。世の中プログラムの書けないプログラマがどの程度居るのか分かりませんが。&lt;/p&gt;

&lt;h1 id=&#34;isucon-http-isucon-net-採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;&lt;a href=&#34;http://isucon.net&#34;&gt;ISUCON&lt;/a&gt;採用&lt;/h1&gt;

&lt;p&gt;めっちゃやって欲しい。インフラ系の即戦力って結構稀だと思います。はい。&lt;/p&gt;

&lt;p&gt;因みに私は1件だけオファーがありました。その頃は自分にそのオファーに見合うだけの技術があるとは思ってなくて、深く考えずに断っちゃいましたけど。今考えるとそこで内定貰って「ISUCONで内定貰ったぜ！ヒャッハ〜」って言ってれば流れ変わったのかな。&lt;/p&gt;

&lt;h1 id=&#34;アカリク-https-acaric-jp-採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;&lt;a href=&#34;https://acaric.jp/&#34;&gt;アカリク&lt;/a&gt;採用&lt;/h1&gt;

&lt;p&gt;自分は行ってないけどめっちゃ良さそう。推奨されるべき。&lt;/p&gt;

&lt;h1 id=&#34;インターン:019fa2f68fcb27779e09f21baadfe988&#34;&gt;インターン&lt;/h1&gt;

&lt;p&gt;一番毒吐きたいところ。&lt;/p&gt;

&lt;p&gt;優秀な学生をインターンで獲得すると言っている企業をちらほら見掛ける。ふざけている。優秀な学生がインターンをしてる暇があると思ってるのか？やはりここにも学生なんだから暇でしょという雰囲気を感じる。&lt;/p&gt;

&lt;p&gt;参考に普通の学生たる私の3年生の時の夏休みの日程を挙げる。8月1日から強化錬、間を空けずに合宿、2日休んで合宿、すぐさま試験準備、試験、直後に帰省。東京に戻ってきたのは9月30日。夏休み中の休みは合宿の合間の2日のみ。&lt;/p&gt;

&lt;p&gt;色々突っ込みたいだろうが予想されるものには反論しておく。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;夏休みの真ん中に試験がある大学にいるのが悪い
: これは私からはどうしようもない。高校生の時にそこまで考える人はいないだろう。悪いというならうちの大学を切り捨てればいい。1学年3000人居る。因みに私は夏休みの前半はサークルに勤しんでいたが本来ならそれら全てを試験勉強に充てる。お察しの通り私の試験の出来は良くなかった。その期間にインターンに行きたがる人はそう多くないだろう。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;サークル3つやってるのが悪い
: 私の場合サークルばかりだが他の人でもサークルの他にバイト2つ3つ掛け持ちとかはザラにある。しかもその内の少なくとも1つは大抵教育系なので夏期講習で忙しい。夏期講習で働けなかった分の皺寄せで他のバイトも日程がつまる。夏休みに知人に会うと10連勤明けで死んだ目をしている。サークルやバイトの他にも高校の部活絡みだとか学外活動だとか要因は色々ある。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;就活のためならサークルを犠牲にすればいい
: 副将をやってるとそうもいかない。参加者ではなく主催者になる。それとも主催者の責務を放り出すような人を採りたいのか？副将になったのが悪いという批判も当を得てない。なぜならサークルの同期は9人いて3人が主副将になる。1/3だ。流石に1/3が外れ値と言う人はいないだろう。それに優秀な人こそ責任者になりやすい筈だ。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;インターンでお金貰えるんだからバイトは辞めるなり休むなりすれば良いのでは
: そうも言ってられない。最近のバイトは中々辞めさせてくれないし、休むと言っても勝手にシフトを入れてくる。辞めるには1ヶ月、2ヶ月前に辞意を伝えておかないといけない。インターンにも選考はある訳で、確実に行けると決まるのは夏休み直前だったりする。あるか無いか分からないもののためにリスクは冒したくない。それに一時収入のために定常収入を失う訳にはいかない。辞めるかも、なんて言葉が勝手にシフトを入れてくるような所に通用する訳がない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;帰省は個人の都合では
: そうでもない。多くの大学生は親の扶養下にある。定期的に家族に挨拶をしないと東京で生かしてもらえない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空きの2日を使ってインターンに行けば良いのでは
: インターンが2日で済むのは文系の話だ。理系ならば最低でも2週間、普通1ヶ月。2ヶ月のものもよく見掛ける。学んで動いて成果を出すには2日は短かすぎる。空きの2日どころか合宿をすっぽかしたところでインターンには行けない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;普通の学生じゃなくて優秀な学生の話をしているんだ
: 確かに。ここに書いたのは普通の学部生の日程だ。しかし優秀な人は他人より多くのことをこなすから優秀なのではないか？ならば優秀な人はさらに忙しいのではないか？私の周りの(私が思う)優秀な人は忙しそうにしている。忙しいとは言ってないが暇と言ってるのは見たことない。
院生のスケジュールは研究室次第だろう。何とも言えない。やる事やってるなら他は関知しない、というところもあれば夏休みにもコアタイムのある研究室もあると聞く。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;勿論、ここに書いたことが全ての学生に当て嵌る訳ではない。中には夏休みに時間のある人もいる。だがその人がインターンに行くか、という問題もある。優秀な人は優れた指導教官の下に居る筈だ。その指導教官の下を離れてまでインターンに行く価値があるか。あるいは優秀ならば指導教官がいなくても自ら学べる人は多い。本人の自主学習速度を上回る体験を提供出来るか。優秀な人は職が欲しいなら先のアカリクなどで座して待つだけでやってくる。内定直結は別に魅力ではない。&lt;/p&gt;

&lt;p&gt;私がここまで毒を吐いたのはインターンそのものではない。時間のある学生を集めてインターンを開きたいならそれはそれで良し。両者得をすることがあるだろう。毒を吐いているのはインターンで優秀な学生を獲得すると言っている企業、採用プロセスにインターンを組み込む企業だ。少数、時間のある優秀な学生もいるだろうが多くの優秀な人を自らフィルタしていることに気付かないのか。&lt;/p&gt;

&lt;h1 id=&#34;最後に:019fa2f68fcb27779e09f21baadfe988&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;常体で書いた上に普段使わない汚ない言葉遣い、自分の価値観に合わないものを全力で否定する内容だったので酷く毒毒しいエントリになってしまった。飽くまで個人の日記で毒を吐いただけなので皆さんマジレスしないで下さいね。&lt;/p&gt;

&lt;p&gt;企業は利益のために採用活動をするのに対して大学生はその露命をつなぐために就職活動をする。立場上も身分上も大学生が下手に出るべきだが上から目線な記述が散見される。ここは一つ個人の日記ということで赦して下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mlyaccを使ってみてハマったところ</title>
      <link>http://keens.github.io/blog/2015/01/31/mlyaccwotsukattemitehamattatokoro</link>
      <pubDate>Sat, 31 Jan 2015 11:55:51 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/01/31/mlyaccwotsukattemitehamattatokoro</guid>
      <description>

&lt;p&gt;κeenです。前回の&lt;a href=&#34;http://keens.github.io/blog/2014/12/10/mllexwoshi-tutemiru/&#34;&gt;mllexの記事&lt;/a&gt;の続きです。今回はmlyaccを使ってみました。&lt;/p&gt;

&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;前回はprologをパースするためにこのようなmllexのコードを書いたのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;datatype lexresult =
         Comment of string
       | LeftParen
       | RightParen
       | LeftBracket
       | RightBracket
       | Comma
       | Dot
       | Bar
       | Medaka
       | UnderScore
       | String of string
       | Number of int
       | Variable of string
       | EOF

val linenum = ref 1
val error = fn x =&amp;gt; print (x ^ &amp;quot;\n&amp;quot;)
val eof = fn () =&amp;gt; EOF
%%
%structure PrologLex                      

alphanum = [A-Za-z0-9];
alpha    = [A-Za-z];
digit    = [0-9];
ws       = [\ \t\n];

%%

{ws}+            =&amp;gt; (lex());
%(.*)\n          =&amp;gt; (Comment yytext);
&amp;quot;(&amp;quot;              =&amp;gt; (LeftParen);
&amp;quot;)&amp;quot;              =&amp;gt; (RightParen);
&amp;quot;[&amp;quot;              =&amp;gt; (LeftBracket);
&amp;quot;]&amp;quot;              =&amp;gt; (RightBracket);
&amp;quot;,&amp;quot;              =&amp;gt; (Comma);
&amp;quot;.&amp;quot;              =&amp;gt; (Dot);
&amp;quot;|&amp;quot;              =&amp;gt; (Bar);
&amp;quot;:-&amp;quot;             =&amp;gt; (Medaka);
&amp;quot;_&amp;quot;              =&amp;gt; (UnderScore);
[a-z]{alphanum}* =&amp;gt; (String yytext);
{digit}+         =&amp;gt; (Number (foldl (fn(a, r)=&amp;gt; (ord(a)-ord(#&amp;quot;0&amp;quot;)) + 10*r) 0 (explode yytext)));
[A-Z]{alphanum}* =&amp;gt; (Variable yytext);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでトークナイズしたトークンをパースすることを考えます。結果はAST作るのが面倒なので文字列にします。&lt;/p&gt;

&lt;p&gt;とりあえずコードを晒してから解説します。prologの仕様を読まずに書いたので用語や文法は誤りを含みます。今度直すので今回はこれで勘弁して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
%%
%name PrologParser
%pos int

%term  Comment of string | LeftParen | RightParen | LeftBracket | RightBracket | Comma | Dot | Bar | Medaka | UnderScore | Number of int | String of string | Variable of string | EOF

%nonterm EXP of string | LIST of string | LISTEXPS of string | TOPDEFINITION of string | SUBDEFINITIONS of string | DEFINITION of string | ARG of string | NAME of string | STMT of string | ATOM of string | START of string

%left Comma
%right Bar
%eop EOF
%noshift EOF
%nodefault

%%

START : STMT (STMT)

STMT           : Comment STMT       (Comment ^ &amp;quot;\n&amp;quot; ^ STMT)
               | TOPDEFINITION STMT (TOPDEFINITION ^ &amp;quot;\n&amp;quot; ^ STMT)
               | (&amp;quot;&amp;quot;)

TOPDEFINITION  : DEFINITION Dot                       (DEFINITION ^ &amp;quot;.&amp;quot;)
               | DEFINITION Medaka SUBDEFINITIONS Dot (DEFINITION ^ &amp;quot;:-\n&amp;quot; ^ SUBDEFINITIONS ^ &amp;quot;.&amp;quot;)

SUBDEFINITIONS : DEFINITION Comma SUBDEFINITIONS      (DEFINITION ^ &amp;quot;,\n&amp;quot; ^SUBDEFINITIONS)
               | DEFINITION                           (&amp;quot;  &amp;quot; ^ DEFINITION)

DEFINITION     : NAME ARG (NAME ^ ARG)

NAME           : String     (String)

               
ARG            : LeftParen EXP RightParen (&amp;quot;(&amp;quot; ^ EXP ^ &amp;quot;)&amp;quot;)
               
               
EXP            : EXP Comma EXP  (EXP1 ^ &amp;quot;, &amp;quot; ^ EXP2)
               | LIST           (LIST)
               | ATOM           (ATOM)

LIST           : LeftBracket LISTEXPS RightBracket ( &amp;quot;[&amp;quot; ^ LISTEXPS ^ &amp;quot;]&amp;quot;)

LISTEXPS       : ATOM Bar LISTEXPS (ATOM ^ &amp;quot; | &amp;quot; ^ LISTEXPS)
               | ATOM (ATOM)

ATOM           : UnderScore               (&amp;quot;_&amp;quot;)
               | Number                   (Int.toString Number)
               | String                   (String)
               | Variable                 (Variable)
               | LeftBracket RightBracket (&amp;quot;[]&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全体はやはり&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;補助コード
%%
補助ルール
%%
パースルール
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;/p&gt;

&lt;p&gt;トークンに切り出す部分がないので補助コードはあまり書く必要はないようです。ASTを組み立てる時に必要なことがあるのかな？&lt;/p&gt;

&lt;p&gt;補助ルールは、主なものは終端記号(term)と非終端記号(nonterm)の記述です。パーサに馴染のない人には聞き慣れない言葉かもしれませんが、ASTの葉が終端記号で、節が非終端記号です。あとはパースの終わりの記号にeop、パースの区切にnonshiftを指定しましょう。パースの区切はEOFの他にREPLならNewlineなども候補かもしれません。posの型も必須です。leftやrightは中置演算子があればそれの結合の左右を指定します。複数書くと後の方が優先順位が高くなるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%left Add Sub
%left Mul Div
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように。&lt;/p&gt;

&lt;p&gt;パースルールは見て察して下さい。&lt;/p&gt;

&lt;p&gt;これをprolog.yaccなどと名前をつけて(.grmがよく使われるそうですが。)、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mlyacc prolog.yacc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするとprolog.yacc.smlとprolog.yacc.sigが出来ます。&lt;/p&gt;

&lt;p&gt;追記:
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; あと拡張子ですが、compilation managerは.grmをmlyaccのファイルと認識してくれるはずなので手間が少なそうです。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/561515838461583361&#34;&gt;2015, 1月 31&lt;/a&gt;&lt;/blockquote&gt;
大人しく.grmを使いましょう。&lt;/p&gt;

&lt;p&gt;シグネチャは.sigが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;signature PrologParser_TOKENS =
  sig
    type (&#39;a,&#39;b) token
    type svalue
    val EOF : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Variable : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val String : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Number : int * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val UnderScore : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Medaka : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Bar : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Dot : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Comma : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val RightBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val LeftBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val RightParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val LeftParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Comment : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
  end
signature PrologParser_LRVALS =
  sig
    structure Tokens :
      sig
        type (&#39;a,&#39;b) token
        type svalue
        val EOF : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Variable : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val String : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Number : int * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val UnderScore : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Medaka : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Bar : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Dot : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Comma : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val RightBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val LeftBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val RightParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val LeftParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Comment : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
      end
    structure ParserData :
      sig
        type pos
        type svalue
        type arg
        type result
        structure LrTable : &amp;lt;sig&amp;gt;
        structure Token : &amp;lt;sig&amp;gt;
        structure Actions : &amp;lt;sig&amp;gt;
        structure EC : &amp;lt;sig&amp;gt;
        val table : LrTable.table
        sharing LrTable = Token.LrTable
      end
    sharing type Tokens.svalue = ParserData.svalue
    sharing type Tokens.token = ParserData.Token.token
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、.smlが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor PrologParserLrValsFun(&amp;lt;param&amp;gt;: sig
                                         structure Token : &amp;lt;sig&amp;gt;
                                       end) :
                             sig
                               structure ParserData : &amp;lt;sig&amp;gt;
                               structure Tokens : &amp;lt;sig&amp;gt;
                             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;な感じです。&lt;/p&gt;

&lt;h1 id=&#34;問題点:3f0801502eddac3f0da04697fabc5835&#34;&gt;問題点&lt;/h1&gt;

&lt;p&gt;これ、以前のlexのコードと組み合わせても動きません。パーサはレキサが吐いたトークン列をパースするのでレキサとパーサで同じdatatypeを共有している必要があります。パーサはtermの指定からTokensを自動で生成してしまうのでレキサの方を修正する必要があります。&lt;/p&gt;

&lt;p&gt;こうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;structure Tokens = Tokens

type pos = int
type svalue = Tokens.svalue
type (&#39;a, &#39;b) token = (&#39;a, &#39;b) Tokens.token
type lexresult = (svalue,pos) token
(* datatype lexresult = *)
(*          Comment of string *)
(*        | LeftParen *)
(*        | RightParen *)
(*        | LeftBracket *)
(*        | RightBracket *)
(*        | Comma *)
(*        | Dot *)
(*        | Bar *)
(*        | Medaka *)
(*        | UnderScore *)
(*        | Number of int *)
(*        | String of string *)
(*        | Variable of string *)
(*        | EOF *)
val pos = ref 0
val linenum = ref 1
val error = fn x =&amp;gt; print (x ^ &amp;quot;\n&amp;quot;)
val eof = fn () =&amp;gt; Tokens.EOF(!pos, !pos)

%%
%header (functor PrologLexFun(structure Tokens: PrologParser_TOKENS));

alphanum = [A-Za-z0-9];
alpha    = [A-Za-z];
digit    = [0-9];
ws       = [\ \t\n];

%%

{ws}+            =&amp;gt; (lex());
%(.*)\n          =&amp;gt; (Tokens.Comment(yytext, !pos, !pos));
&amp;quot;(&amp;quot;              =&amp;gt; (Tokens.LeftParen(!pos, !pos));
&amp;quot;)&amp;quot;              =&amp;gt; (Tokens.RightParen(!pos, !pos));
&amp;quot;[&amp;quot;              =&amp;gt; (Tokens.LeftBracket(!pos, !pos));
&amp;quot;]&amp;quot;              =&amp;gt; (Tokens.RightBracket(!pos, !pos));
&amp;quot;,&amp;quot;              =&amp;gt; (Tokens.Comma(!pos, !pos));
&amp;quot;.&amp;quot;              =&amp;gt; (Tokens.Dot(!pos, !pos));
&amp;quot;|&amp;quot;              =&amp;gt; (Tokens.Bar(!pos, !pos));
&amp;quot;:-&amp;quot;             =&amp;gt; (Tokens.Medaka(!pos, !pos));
&amp;quot;_&amp;quot;              =&amp;gt; (Tokens.UnderScore(!pos, !pos));
[a-z]{alphanum}* =&amp;gt; (Tokens.String(yytext, !pos, !pos));
{digit}+         =&amp;gt; (Tokens.Number ((foldl (fn(a, r)=&amp;gt; (ord(a)-ord(#&amp;quot;0&amp;quot;)) + 10*r) 0 (explode yytext)), !pos, !pos));
[A-Z]{alphanum}* =&amp;gt; (Tokens.Variable(yytext, !pos, !pos));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モジュールではなくてファンクタを生成するようになります。シグネチャはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor PrologLexFun(&amp;lt;param&amp;gt;: sig
                                structure Tokens : &amp;lt;sig&amp;gt;
                              end) :
                    sig
                      structure UserDeclarations : &amp;lt;sig&amp;gt;
                      exception LexError
                      structure Internal : &amp;lt;sig&amp;gt;
                      structure YYPosInt : &amp;lt;sig&amp;gt;
                      val makeLexer : (int -&amp;gt; string)
                                      -&amp;gt; unit -&amp;gt; Internal.result
                    end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;組み合わせる:3f0801502eddac3f0da04697fabc5835&#34;&gt;組み合わせる&lt;/h1&gt;

&lt;p&gt;まず、必要なモジュールやシグネチャをmlyaccから読み込みます。前回同様mltonのmlyaccを使って、SML/NJで動作確認を行ないました。&lt;/p&gt;

&lt;p&gt;私は分かってないのですが、useってもしかしてSML/NJの固有の機能なんですかね。&lt;/p&gt;

&lt;p&gt;追記:
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;useはThe Standard ML Basis Libraryに記載があるのでSML/NJ固有の機能ではないですが、implementation dependentと書いてあるのでまぁそういう事なんでしょう&lt;/p&gt;&amp;mdash; ろんだ (@fetburner) &lt;a href=&#34;https://twitter.com/fetburner/status/561514796734877698&#34;&gt;2015, 1月 31&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; useは標準ですが意味は実装依存ですね&amp;gt; &lt;a href=&#34;http://t.co/fPC38xtD1X&#34;&gt;http://t.co/fPC38xtD1X&lt;/a&gt; (例外の直後辺り)&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/561515332469137408&#34;&gt;2015, 1月 31&lt;/a&gt;&lt;/blockquote&gt;
とのことなので処理系依存の機能ではなかった模様。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/base.sig&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/join.sml&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/lrtable.sml&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/stream.sml&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/parser2.sml&amp;quot;;
use &amp;quot;prolog.yacc.sig&amp;quot;;
use &amp;quot;prolog.yacc.sml&amp;quot;;
use &amp;quot;prolog.lex.sml&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mlyacc-libの場所は各自異なるので適宜書き換えて下さい。SML/NJはインストール場所を表わすシンボルを持っているようですが、私はmltonのものを参照しているのでいずれにせよ関係ないですね。&lt;/p&gt;

&lt;p&gt;さて、この.yacc.smlに入ってるファンクタです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor PrologParserLrValsFun(&amp;lt;param&amp;gt;: sig
                                         structure Token : &amp;lt;sig&amp;gt;
                                       end) :
                             sig
                               structure ParserData : &amp;lt;sig&amp;gt;
                               structure Tokens : &amp;lt;sig&amp;gt;
                             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故こうなってるのかは分からないのですがTokenを欲しがってますね。あげましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParserLrVals =
PrologParserLrValsFun(structure Token = LrParser.Token)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LrValsって言ってるのでLRパーサーで使うデータ型が用意出来たのかな？&lt;/p&gt;

&lt;p&gt;これでレキサで使うTokensとパーサで使うParserDataを持つモジュールが出来たのでレキサのファンクタの餌が用意出来ました。食べさせてあげましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologLex =
PrologLexFun(structure Tokens = PrologParserLrVals.Tokens)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは普通にレキサを生成します。&lt;/p&gt;

&lt;p&gt;んで最後にLRパーサとLRパーサで使うデータ型(?)とLRパーサに渡すトークンを生成するレキサを組み合わせます。なんかsharingなる機能を使って組み合わせるらしいのでそれ専用のファンクタが用意されています。sharingなんぞ。いつか&lt;a href=&#34;https://github.com/SMLFamily/The-Definition-of-Standard-ML-Revised&#34;&gt;The Definition of Standard ML Revised&lt;/a&gt;読まねば。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やっぱり&lt;code&gt;LrParser&lt;/code&gt;を使ってるのが腑に落ちませんね。どうして生成した時点で含んでないのかな。複数のパーサを作ったときに無駄を無くすため？自前のパーサが使えるようにするため？&lt;code&gt;LrParser.Token&lt;/code&gt;はまだパーサとsharingしてる必要がありそうなので納得出来ますが。&lt;/p&gt;

&lt;h1 id=&#34;使ってみる:3f0801502eddac3f0da04697fabc5835&#34;&gt;使ってみる&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;makeLexer&lt;/code&gt;と&lt;code&gt;parse&lt;/code&gt;を使うようです。&lt;code&gt;makeLexer&lt;/code&gt;は呼ぶ度にトークンを返すものではなく、トークンのストリームを返すものになってるらしいです。&lt;/p&gt;

&lt;p&gt;prologファイル名を受け取ってその中身をパースして、中身を整形した文字列にするコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun invoke lexstream =
    let
        fun print_error (s, _, _) =
            TextIO.output(TextIO.stdOut,
                          &amp;quot;Error: &amp;quot; ^ s ^ &amp;quot;\n&amp;quot;)
    in
        PrologParser.parse(0, lexstream, print_error, ())
    end

fun parse filename =
    let
        val f = TextIO.openIn filename
        val lexer = PrologParser.makeLexer
                        (fn i =&amp;gt; TextIO.inputN(f, i))
        fun run lexer =
            let
                val (result,lexer) = invoke lexer
            in
                TextIO.output(TextIO.stdOut,
                              &amp;quot;result = &amp;quot; ^ result ^ &amp;quot;\n&amp;quot;)
            end
    in
        run lexer
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回はposのアップデートをサボったので&lt;code&gt;print_error&lt;/code&gt;内では無視してますが本来は&lt;code&gt;print_error&lt;/code&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;print_error (s, start:int, end:int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として受けるべきです。この時startとendはトークンの開始位置と終了位置です。&lt;/p&gt;

&lt;p&gt;他にも説明が足りてない部分がありますが、マニュアルや&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/education/lectures/compiler/code/mlyaccKaisetsu.pdf&#34;&gt;東北大のPDF&lt;/a&gt;を参照して下さい。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:3f0801502eddac3f0da04697fabc5835&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;mlyaccの使い方を書いた&lt;/li&gt;
&lt;li&gt;mllexとmlyaccの組み合わせ方を書いた&lt;/li&gt;
&lt;li&gt;疑問が残った&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次回はASTでも作ってみますが、smlsharpにSMLFormatなるdatatypeの定義とそのプリティプリンタの定義を同時に出来るツールがあるようなのでそれを使ってみます。いくつも中間表現を作ろうと思ったら途中経過も欲しいのでプリティプリンタ重要ですよね。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>