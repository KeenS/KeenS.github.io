<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 16 Sep 2015 21:55:25 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>xhyveでFreeBSD guestを動かす</title>
      <link>http://keens.github.io/blog/2015/09/16/xhyvedefreebsd_guestwougokasu</link>
      <pubDate>Wed, 16 Sep 2015 21:55:25 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/09/16/xhyvedefreebsd_guestwougokasu</guid>
      <description>

&lt;p&gt;久しぶりですね。κeenです。最近はMacでもまともな仮想環境が整ってきたのでFreeBSDでも動かすかーといって試したやつを共有します。&lt;/p&gt;

&lt;p&gt;大部分は&lt;a href=&#34;http://blog.holidayworking.org/entry/2015/06/27/xhyve_%E3%81%A7_FreeBSD_%E3%82%92%E5%8B%95%E3%81%8B%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F&#34;&gt;ここ&lt;/a&gt;を参考にしてますが、ちゃんと動きます。&lt;/p&gt;

&lt;h1 id=&#34;xhyveとは:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;xhyveとは&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pagetable.com/?p=831&#34;&gt;xhyve – Lightweight Virtualization on OS X Based on bhyve | pagetable.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;FreeBSDのBHyVeをMac OS Xに移植したものです。Intel CPUの仮想化フレームワークを使うことで仮想化の実装が（比較的）が楽になるからやろうぜってプロジェクトです。
カーネルレベルでのサポートが必要になりますがyosemiteからHyervisor.frameworkが入っているのでそれが使えます。&lt;/p&gt;

&lt;p&gt;因みに開発はそんなに活発ではないです。&lt;/p&gt;

&lt;h1 id=&#34;動かす:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;動かす&lt;/h1&gt;

&lt;h2 id=&#34;xhyveの準備:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;xhyveの準備&lt;/h2&gt;

&lt;p&gt;FreeBSDのサポートは既にマージされているのでcloneしてきてそのまま使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone git@github.com:mist64/xhyve.git
cd xhyve
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FreeBSDのイメージの入手
イメージは現在10.2が出ているので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;fetch http://ftp.freebsd.org/pub/FreeBSD/releases/VM-IMAGES/10.2-RELEASE/amd64/Latest/FreeBSD-10.2-RELEASE-amd64.raw.xz
unxz FreeBSD-10.2-RELEASE-amd64.raw.xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で入手出来ます。&lt;/p&gt;

&lt;h2 id=&#34;起動スクリプトの準備:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;起動スクリプトの準備&lt;/h2&gt;

&lt;p&gt;参照ブログのままだとハードディスクが読めないのでIMG_HDDにもイメージを指定します。&lt;/p&gt;

&lt;p&gt;名前は何でも良いのですが&lt;code&gt;freebsd.sh&lt;/code&gt;として保存し、&lt;code&gt;chmod +x freebsd.sh&lt;/code&gt;します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh

USERBOOT=&amp;quot;test/userboot.so&amp;quot;
BOOTVOLUME=&amp;quot;FreeBSD-10.2-RELEASE-amd64.raw&amp;quot;
KERNELENV=&amp;quot;&amp;quot;

MEM=&amp;quot;-m 1G&amp;quot;
#SMP=&amp;quot;-c 2&amp;quot;
#NET=&amp;quot;-s 2:0,virtio-net&amp;quot;
#IMG_CD=&amp;quot;-s 3,ahci-cd,/somepath/somefile.iso&amp;quot;
IMG_HDD=&amp;quot;-s 4,virtio-blk,$BOOTVOLUME&amp;quot;
PCI_DEV=&amp;quot;-s 0:0,hostbridge -s 31,lpc&amp;quot;
LPC_DEV=&amp;quot;-l com1,stdio&amp;quot;
#UUID=&amp;quot;-U deadbeef-dead-dead-dead-deaddeafbeef&amp;quot;

build/xhyve -A $MEM $SMP $PCI_DEV $LPC_DEV $NET $IMG_CD $IMG_HDD $UUID -f fbsd,$USERBOOT,$BOOTVOLUME,&amp;quot;$KERNELENV&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;起動:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;起動&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./freebsd.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で起動します。&lt;/p&gt;

&lt;h1 id=&#34;その他:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;FreeBSDのイメージを一杯作りたい人はダウンロードしてきたやつを&lt;code&gt;cp&lt;/code&gt;して使うと良いと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ISUCONこれまでの流れ</title>
      <link>http://keens.github.io/slide/ISUCONkoremadenonagare/</link>
      <pubDate>Fri, 04 Sep 2015 08:47:05 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/ISUCONkoremadenonagare/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ISUCONこれまでの流れ
----------------------
雑に書き殴った
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + ISUCON3、 4の予選、本戦に出場（学生枠）

# ISUCON1 ブログ
---------------

* node perl ruby
* kazeburoの罠
* ブログのサイドバーが重いやつ
* 割と親切なルール


# ISUCON2 チケット予約サイト
---------------------------

* perl ruby node php java python
* 席ランダムにしてなくてもベンチマーカー通っちゃう
* 変更が1秒以内に反映されていること → 0.9秒毎に裏でバッチを回す
* JOINが3連になってる所があってみんなそこに引っ掛かったがボトルネックはそこじゃない
* ちょっとルールが雑になった


# ISUCON3予選 スニペット投稿サイト
--------------------------------
* go node perl python ruby php
* AWS1台
* Markdown変換がperl製の重いやつ
* AWSだとプロセスのフォークも重い
* titleの抜き出しも重い
* チェッカーが甘くてVarnishを導入しただけで点数爆上がり
* SQLの典型問題とかも
* workloadに気付かなかった人多数
* 学生枠が出来た
* ベンチマーカが通れば何でもアリな風潮


# ISUCON3本戦 画像SNS
--------------------
* go node perl python ruby
* オンプレ5台
* 画像の変換が重い
* 実は帯域もつらい
* 画像のチェッカがあってチェッカが通れば画質を落としても良かった
* 組長の罠
* ベンチマーカーに通れば何でもアリ
* 複数サーバーでのファイルの共有にWebDAVが盲点
* 点数計算の罠に嵌まる人多数
  + 基本点より追加点に目が眩む人がそれなりに
* 推測するな計測せよ
* nodeで初期パスワードが間違っているトラブル


# ISUCON4予選 銀行
--------------------------------------

* go node perl php python ruby
* AWS1台
* ワークロードを桁外れに指定するとベンチマーカーが走り続けるバグ
* ベンチマーカーにアクセスして行動パターンを解析した人が出る（その情報は使ってない。スポーツマンシップ。）
* テンプレートエンジンをやめて静的ファイル
* Go勢のon memory戦略が跋扈
* 「メモリに載せれば勝てるぜ」風潮
* 静的ファイルを返さない反則ギリギリのチューニング
* ベンチマーカーのチューニング
* Varnish潰し
* アプリをC++で書き換えて予選突破したチームも出る


# ISUCON4本戦 動画広告
----------------

* go perl php python ruby
* オンプレ3台
* 最初からRedisに動画が載ってる
* それ外したらスコア頭打ち(帯域がつまる)
* ベンチマーク同士が干渉しあう
* 実はCache-Controlをしたらスコアが爆上がり(上位2チームだけ気付いた)
* 3位のチームは外向きと内向きの2枚のNICを使って団子状のスコアから頭1つだけ出た


#ISUCON5予選 ???
----------------
* perl ruby node php python go java (scala)
* GCP 
* 今までの予選だとベンチマーカが競技者の手元に渡る問題があった。
* かといって外部からのベンチマークは安定しない。
* GCPならGoogleの謎の技術によって安定するらしい。
* @tagomoris 「もはやISUCONは予選で落ちる人の方が多くなった。その人達にとっては予選こそがISUCONなのだ」
  
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SMLでPNGデコーダを作ろうとして分かったこと</title>
      <link>http://keens.github.io/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</link>
      <pubDate>Fri, 04 Sep 2015 06:45:19 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLでPNGデコーダを作ろうとして分かったこと
------------------------------------------
サイバーエージェント アドテクスタジオ  
エンジニア月初会
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
----------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒
 + Lisp, ML, Shell Scriptあたりを書きます


&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うーむ。画像フォーマットの扱い一回くらい書いてみないとなーと思ってたけどやっぱり既存なんだよなー。Common LispかSMLあたりならフロンティアになれそう。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639303085240643584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 仕様を理解するためにデコーダから実装するのがオススメです&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639304790766305281&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; そんな詳しいわけではないんですが、jpegかpngがおすすめです。webpは動画コーデック由来で難しいと思います。tiffは画像コンテナみたいな立ち位置なので画像フォーマット感がないかなと。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639307400244137984&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

明日の朝までに  
&lt;span style=&#39;font-size:150%;&#39;&gt;SMLでpngデコーダを実装しよう&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Standard ML
-------------

* ML系の函数型言語
* 文法はOCamlよりF#に似てる（というかF#が似せてきた）
* 結構書き易い
* 仕様は SML&#39;90とSML&#39;97がある
* 仕様で言語のformal semanticsが定められてたりする
* 要は研究向き
  + **ライブラリほぼなし**
  + **コミュニティほぼなし**


&lt;span style=&#39;font-size:250%;&#39;&gt;＞　無理ゲー　＜&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 一応フォーマットを調べる
------------------------


```
+-----------------+
|     Chunk       | 画像はChunkの集合。
++---------------++ Chunk自体は簡単なフォーマット
|| length | name ||
|+---------------+|
||    data       ||
||    ...        ||
|+---------------+|
||    CRC        ||
++---------------++
|    Chunk        |
|    ...          |
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
意外と単純？
&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# とりあえず書いてみる
---------------------

```sml
structure PNG = struct
    fun readChunk data i = ...
end
```


# 案外苦戦
------------
* 型が厳密なので型の行き来が面倒
  + 8bit &lt;-&gt; 32bit
  + 符号付き &lt;-&gt; 符号無し
  + byte &lt;-&gt; char

```sml
val op &lt;&lt; = Word.&lt;&lt;
val op &gt;&gt; = Word.&gt;&gt;

fun nameToWord name = CharVector.foldl (fn(c, acc) =&gt; &lt;&lt;(acc, 0w8) + (Word.fromInt (ord c))) 0w0 name
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
3時間後
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;さて、メインのデータ抜き出すところまでは行ったけど次復号だ。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639501771430211584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 今更PNGについて
----------------

* GIFの特許問題を回避するために作られたフォーマット
  + LZ77がマズいらしい
* **可逆圧縮アルゴリズムを使う** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + **アルゴリズムは1つとは限らない** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
  + 但し仕様で指定されているのはzlibのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
* フィルタを噛ませることでプログレッシブな表示も可能


# SMLのZLibライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
zlib……実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ZLib
------

* RFC-1950
* zipやpngで使われるフォーマット
* ZLib自体は圧縮データのコンテナで **圧縮アルゴリズム自体は1つとは限らない**  &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + 但し仕様で指定されているのはdeflateのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;


# SMLのDeflateライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
deflate…実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Deflate
---------

* RFC-1951
* ハフマン符号の変種の可逆圧縮アルゴリズム
  + **3種類の符号化方式を自由に使ってよい** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;



&lt;span style=&#39;font-size:250%;&#39;&gt;(心)ボキッ&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 学んだこと
-----------

* PNGは一晩でデコーダを書ける程柔じゃない
  + 事前調査も大事
* 書き易い言語でもコミュニティが大事
* 1晩でLTの準備はつらい


# 付録
------

* [今回のコード](https://github.com/KeenS/sml-png)
* [SMLのパッケージマネージャ](https://github.com/standardml/smackage)
* [PNG](http://www.w3.org/TR/2003/REC-PNG-20031110/)
* [RFC-1950 ZLIB](https://www.ietf.org/rfc/rfc1950.txt)
* [RFC-1951 DEFLATE](https://www.ietf.org/rfc/rfc1950.txt)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Method Drawでお手軽LGTM生成</title>
      <link>http://keens.github.io/slide/Method_DrawdeotegaruLGTMseisei/</link>
      <pubDate>Fri, 14 Aug 2015 00:55:37 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Method_DrawdeotegaruLGTMseisei/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Method Drawでお手軽LGTM生成
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# Method Draw
-------------

* シンプルなSVG エディタ
* オープンソース
* [editor.method.ac](http://editor.method.ac/)


# デモ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 以上
------
Have a happy hacking life
&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>構文解析にまつわる小話たち</title>
      <link>http://keens.github.io/slide/koubunkaisekiarekore/</link>
      <pubDate>Sat, 08 Aug 2015 04:16:50 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/koubunkaisekiarekore/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# 構文解析にまつわる小話たち
----------------------
[#peg_study](https://twitter.com/search?q=%23peg_study&amp;src=typd&amp;vertical=default&amp;f=tweets)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバエージェントの新卒エンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# ウォームアップ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文解析はバッドノウハウ
-------------------------

* プログラム言語を使っているなら既にパーサはある
  + 文法も定義されてる
* 目の前のパーサを使え
  + パーサAPIがある言語もある(Lispとか)
* そうでなくても内部DSLを考えろ
  + 内部DSLで解決出来ないときだけ構文解析

# 本質はAST
-----------

* 結局はASTになればどんな文法でも同じ
* 文法はただの外皮、欲しいのはAST
* シンタックスシュガーは飾り
  + DRY出来るなら別
* S式を使え
  + ASTをそのまま書き下せる


# AST First
-----------

* 最初にASTを考える。そして文法を考える
* 何が欲しいのかイメージし易くなる
* 構文解析はAST生成の自動化。普段してないことを自動化するのは愚か。
* 早めに間違いに気付ける
  + `+`は二項演算子。じゃあ `&amp;&amp;` は？ `=` は？

Note: Lispだと+は関数、andはマクロ、setqはスペシャルフォーム


# 構文解析の流れ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文解析の流れ
---------------

1. Lexer generaterからlexerを作る
  + Lexとか
2. Parser generaterからparserを作る
  + yaccとか
  + BNFという記法
3. ソースファイルをlexerで処理してトークン化する
4. トークン列をparserで処理してASTを作る



```
         [Lexer]        [parser]
[Source]-------&gt;[Tokens]------&gt;[AST]
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# LexerとParserを分ける意味
--------------------------

* (上向き構文解析だと分けないとつらい)
* 役割の分担
  + 困難は分割せよ
* 文字列をシンボル化して比較が高速に
* 思考のフレームワークとして



&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;字句解析器手づくりの簡単さに対して構文解析器手づくりはわりと人を殺しにかかる&lt;/p&gt;&amp;mdash; gfn (@bd_gfngfn) &lt;a href=&#34;https://twitter.com/bd_gfngfn/status/578908166785671168&#34;&gt;2015, 3月 20&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 正規表現の使いどころ
---------------------

* 高速な実装がある
* 部品化しにくい
* 括弧の対応とか入れ子構造(`if .. then .. else`とか)は扱えない
  + perlの正規表現は厳密には正規表現ではない
* 構文解析には向かない
  + 「マッチ」は出来ても「抜き出し」は面倒
* Lexerには向いてる
  + トークン自体末端の部品なので部品化する必要がない

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;依存型のある言語でlexとか作ったら出てくるトークンの型変数に正規表現出てくるのかな&lt;/p&gt;&amp;mdash; eld-r-esh-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/597772476244885505&#34;&gt;2015, 5月 11&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;「bnf = (大雑把に言って)正規表現+括弧の対応」というのはchomsky–schützenbergerの定理という結構マニアックな定理(ドラゴンブックには載ってないと思う)をさらに僕なりに超訳したものなのであまり知られてないと思います．&lt;/p&gt;&amp;mdash; ryoma sin&amp;#39;ya (@sinya8282) &lt;a href=&#34;https://twitter.com/sinya8282/status/597465565654024192&#34;&gt;2015, 5月 10&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 構文クラス

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文クラス
------------

* 学術的だが知っておくと幸せになれる
* 文脈自由文法を解析するためのものを話す
  + 多くのプログラム言語は文脈自由文法
  + 正規言語 ⊂ 文脈自由文法
* 大きく分けると上向き構文解析と下向き構文解析
* 詳しくは[ドラゴンブック](http://www.amazon.co.jp/%e3%82%b3%e3%83%b3%e3%83%91%e3%82%a4%e3%83%a9%e2%80%95%e5%8e%9f%e7%90%86%e3%83%bb%e6%8a%80%e6%b3%95%e3%83%bb%e3%83%84%e3%83%bc%e3%83%ab-information-computing-a-v-%e3%82%a8%e3%82%a4%e3%83%9b/dp/478191229x)参照


# LL(1)
----

* 下向き
  + 再帰降下パーサ
* 定義した言語しか厳密に受け取らない
* 線形線形時間でパース可能
* 手書きに向く
* パーサーコンビネータとかも


# LR(1)
----

* 上向き
  + トークンをくっつけて構文要素に、構文要素をくっつけてさらに上の構文要素に…
* LL(n)⊂LR(n)
* LRそのものの解析は難しくて、いくつかサブクラスがある
  + 単純LR (SLR):  貧弱
  + 先読みLR (LALR): パーサジェネレータでよく使われる
  + 正準LR: 計算コストが高い。メモリ喰う
* 事前計算のコスト（面倒くささ）が高い
  + パーサジェネレータ


# LRパーサジェネレータ
-----

* 基本はBNF(Backus-Naur-Form)
* いくつか方式がある
  + 演算子順位解析も合わせる
    - EmacsのSMIEとか
  + BNFだけでやる
    - 別の言語も受理する可能性がある ドラゴンブック 上 p. 247
    - 普通は問題にならない


# LRの限界とか
-------------

* `-`の単項演算子と二項演算子の衝突
  1. SMLみたいに諦める(単項の`-`を`~`で表す)
  2. Lexerで区別する
* 左再帰で無限ループ
  + 手動でどうにか出来る
  + 自動でどうにかしてくれるジェネレータもある
* BNFの書き方によっては文法があいまいになる
  + `if .. then .. if .. then .. else ..` とか
  + 自動ではどうにもできないので気をつけるしかない


# BNFとパーサージェネレータの良さ
------------

* BNFは言語を定義する。
  + 言語仕様にも使われる
* 要は「仕様からプログラムを生成する」
* 宣言的


# 複数文法のサポートとグローバル変数の衝突
---------------------------------------

* 複数の文法をサポートしたい時がある
  + 独自記法と互換記法とか
* 雑なパーサジェネレータ/コンビネータを使っているとグローバル変数が衝突する
  + パーサライブラリの作者は配慮して下さい。


# 言語仕様の配慮
---------------

* LispはLL
* Java 1.0はLALR
  + 今はLALRではないらしい
* PrologはLALRだった気がする


# 非文脈自由文法
----------------

* 文脈を持つ（雑）
* ひねりなくパーサージェネレータ使っただけじゃ解析出来ない言語のこと。


## sedのs///
-----------

* 実は `s|||`のように区切文字は何でもいい
  + パスネームの置換に便利
* 対応関係が文脈で変わるので非文脈自由


## Markdown
-----------

* 元々のperlの実装は正規表現
  + 再帰を使っているので正規言語ではなく文脈自由文法
* GFMなどのTable記法はカラム数という文脈があるので非文脈自由
* Table記法をサポートする時は覚悟を持って。


# その他
--------

* 関数の仮引数の数と実引数の数の一致
* 変数の使用の前に変数宣言
* 要は構文解析で出来ることには限界がある。


# パーサの実際

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 速度と手軽さ
--------------

* 外部DSLやコンフィグファイルだとパーサの速度は必要ない
  + メインループで使われないので起動時間にしか影響しない。
  + むしろ手軽に作れた方がいい
* HTTPだとかメインループで使うものはどうやってでも速くしたい
  + 労力は惜しまない

# 手書きとジェネレータとコンビネータ
----------------------------------

* 速度が必要ならジェネレータ
* LLでないならジェネレータ
* 手軽さが欲しいならコンビネータ
* 色々手を加えたいなら手書き…かも


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;パーサ手書きするのダサイよなぁ。クラスが分からなくなる。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/597751470834855938&#34;&gt;2015, 5月 11&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ジェネレータの扱いにくさ
--------------------------

* あんまり人気ない気がする
* 2回も前処理必要なのダサいよね
* 新たな文法覚える必要がある
* そもそも作るのにもコストが高い
  + 言語の文法に合わせたプリンタ
  + 拡張性持たせると厄介
* かといって正規表現はやめましょうね

# DSLパーサジェネレータ
----------------------

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;PEGが正規表現と違って辛いところは言語組み込みじゃないのとワンライナーに向かないことなんだよな… &lt;a href=&#34;https://twitter.com/hashtag/peg_study?src=hash&#34;&gt;#peg_study&lt;/a&gt;&lt;/p&gt;&amp;mdash; わかめ@TypeScriptカッコガチ (@vvakame) &lt;a href=&#34;https://twitter.com/vvakame/status/629881217320550401&#34;&gt;2015, 8月 8&lt;/a&gt;&lt;/blockquote&gt; 

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# DSLパーサジェネレータ
----------------------

* あったらそれなりに人気出そう
* メタプログラミングが出来る必要がある
* Common Lisp
  + 作者自身作ってる途中でジェネレータとコンビネータを勘違いする
  + ドキュメントでジェネレータといってるのに実際はコンビネータだったりする
* D
  + なんか作ってる人いるらしい


# 複雑性と分かりやすさ
---------------------

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;オーバーエンジニアリングを「あいつは力に溺れた」と言い変えていくといいと思う&lt;/p&gt;&amp;mdash; イカid:mizchi0x (@mizchi) &lt;a href=&#34;https://twitter.com/mizchi/status/565662999063838720&#34;&gt;2015, 2月 12&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 複雑性と分かりやすさ
---------------------
* パーサが複雑な文法に対応出来ても人間が追い付かない
* 周辺のサポートも必要になるのでやっぱりシンプルな方が良い。
  + LRよりLL
  + S式とかシンプルの極み
  + [Clojureシンタックスハイライター開発から考えるこれからのlispに必要なもの](http://www.slideshare.net/sohta/clojurelisp?ref=http://athos.hatenablog.com/entry/2015/07/29/222535)
* 「出来る」と「した方がいい」は別の話


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;S式はどう考えても読み易い……&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/590528791677546496&#34;&gt;2015, 4月 21&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;}]))みたいなのを書いてると、括弧が一種類の言語、いいなぁ、と思ったりします。&lt;/p&gt;&amp;mdash; mzp (@mzp) &lt;a href=&#34;https://twitter.com/mzp/status/587941717451481088&#34;&gt;2015, 4月 14&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ソースロケーション保持法

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# ソースロケーション保持法
-------------------------

* エラーメッセージを出すためにはソースロケーションを保持する必要がある
* flymakeの情報: ファイル名、開始行/列 終了行/列 エラーメッセージ
  + 最悪これがあればどうにかなる
  + 「分かりやすい」メッセージはツールに任せる
* 字句解析だけでなく意味解析、さらにはつまるところコンパイルが終わるまで保存する必要がある
  + トークンやASTにメンバが増える
  + オブジェクト指向のカプセル化って素晴らしい


# 1. インクルード
----------------------

* トークンのデータに入れてしまうパターン
* `datatype token = Plus of int * int | Symbol of int * int * string` ...
* OOPなら自然だが函数型だとパターンマッチがつらくなる


# 2. ラップ
--------

* ロケーションのレコードでトークンをラップする
* `{start:int, end: int, token: token}`
* パターンマッチは少し楽になる
  + 多相レコードがないとそもそもレコードつらいけどな！！
* MLtonがやってるらしい


# 3. テーブル
-------------

* ロケーションテーブルを持って、トークンにはテーブルへのキーだけ持たせる
* トークンが軽くなるので速そう
* でも面倒そう


# エラー処理
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# エラーメッセージ
------------------------

* 一応ロケーションがとれればエラー箇所は出せる。
* メッセージの親切さはツールとヒューリスティックと根気
* clangとか頑張ってる

```
ERROR: expected tEnd before &#39;&lt;EOF&gt;&#39;
each do {}
          ^
```


# エラー回復
-------------

* シンタックスハイライターは壊れた文法も解析しないといけない
* 1回のコンパイルでできるだけ多くのエラーメッセージを出したい
* シンタックスエラーから回復したい


# Cの易しさ
-----------

* エラーがあってもセミコロンまで読み飛ばせば回復出来る
  + CやJavaは結構コンパイラが教えてくれる
* そういう言語設計も大事


# 拡張方法

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# リードマクロ
--------------

* トークンレベルの拡張
* 特定の「文字」がきた時にユーザ定義関数を使ってパースする
* リテラルをユーザが定義することが出来る
  + 正規表現リテラルとか
  + [Common Lispの正規表現](http://weitz.de/cl-interpol/)


# マクロ
--------

* ASTレベルの拡張
* LispとかScalaとかRustとか
  + Lispは自由度が高い
  + 関数マクロはないよりマシ程度
* ~衛生性~
* [マクロについて整理してみる | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru/)


## Cのマクロ
------------

* プリプロセッサなのでコンパイラの拡張ではない
* プリプロセッサ自体レキサを持つ
  + パーサとレキサを分ける意味
* ASTに関知しないのでやりたい放題


# 中置演算子
-----------

* 新しい中置演算子と優先順位を定義できる言語は多い
  + Haskell, SML, Prolog…
* パーサをその場で書き換えるのは難しいので後で処理する
  + [\[コンパイラ\]\[Haskell\]\[OCaml\] Haskellのinfixの仕組み - mad日記](http://d.hatena.ne.jp/MaD/touch/20090108)
* シンタックスのプラグインをセマンティクスに入れてるのでちょっと無茶


# 中置演算子
-----------

* 人間が同時に覚えられるのは3つまで
  + 優先順位がいくつもあっても覚えられない
  + 優先度40とか900とか無理。
* 本質はAST
  + 文法に問題を抱えるくらいならS式を使え


# Coq
-----

Coqは謎のテクノロジーにより `Notation`を使えば新しい文法を定義出来る

```coq
Notation &#34;&#39;SKIP&#39;&#34; :=
  CSkip.
Notation &#34;X &#39;::=&#39; a&#34; :=
  (CAss X a) (at level 60).
Notation &#34;c1 ; c2&#34; :=
  (CSeq c1 c2) (at level 80, right associativity).
Notation &#34;&#39;WHILE&#39; b &#39;DO&#39; c &#39;END&#39;&#34; :=
  (CWhile b c) (at level 80, right associativity).
Notation &#34;&#39;IFB&#39; e1 &#39;THEN&#39; e2 &#39;ELSE&#39; e3 &#39;FI&#39;&#34; :=
  (CIf e1 e2 e3) (at level 80, right associativity).

Definition fact_in_coq : com :=
  Z ::= AId X;
  Y ::= ANum 1;
  WHILE BNot (BEq (AId Z) (ANum 0)) DO
    Y ::= AMult (AId Y) (AId Z);
    Z ::= AMinus (AId Z) (ANum 1)
  END.
```
  

# 雑な話題

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# テスト
-------

* ASTのテストは案外難しい
  + 微妙な仕様変更で結果が変わる
  + でも言語の動作には関係なかったり

1. あきらめる
2. 不屈の精神でテストを直し続ける
3. 木に対するクエリ言語を使う


# 先読みと副作用
--------------

* 先読みしてバックトラックすると副作用があった時に困る
  1. 副作用を許さない
  2. 副作用は自己責任
  3. 一旦先読みで正しいパスを記憶してから正しいパスでもう一度パース
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ファイル削除コマンド色々</title>
      <link>http://keens.github.io/blog/2015/07/05/fairusakujokomandoiroiro</link>
      <pubDate>Sun, 05 Jul 2015 14:18:37 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/07/05/fairusakujokomandoiroiro</guid>
      <description>

&lt;p&gt;ファイル生成/削除コマンドについて覚え書き。&lt;/p&gt;

&lt;h1 id=&#34;空ファイル生成:40d37f886c175b93db8e875ce685ddc6&#34;&gt;空ファイル生成&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ touch file
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;サイズ指定でファイル生成:40d37f886c175b93db8e875ce685ddc6&#34;&gt;サイズ指定でファイル生成&lt;/h1&gt;

&lt;p&gt;0埋め/高速なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/zero of=file bs=size count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ランダム/低速なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/random of=file bs=size count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こっちは圧縮されてもサイズが極端に変わらない。&lt;/p&gt;

&lt;h1 id=&#34;ファイルの切り詰め:40d37f886c175b93db8e875ce685ddc6&#34;&gt;ファイルの切り詰め&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ truncate -s size file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記で作ったファイルのサイズを変えたりログファイルを一旦クリアしたりに便利。&lt;/p&gt;

&lt;h1 id=&#34;普通の削除:40d37f886c175b93db8e875ce685ddc6&#34;&gt;普通の削除&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ rm file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただしハードディスク上にはデータは残るのでセキュリティ的には完全ではない。&lt;/p&gt;

&lt;h1 id=&#34;ディスク上からも完全削除:40d37f886c175b93db8e875ce685ddc6&#34;&gt;ディスク上からも完全削除&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ shred -u file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-u&lt;/code&gt;がなかったらファイルを壊すが削除はしない。&lt;/p&gt;

&lt;p&gt;shredが出てこなかったので調べたついでにまとめた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>マクロについて整理してみる</title>
      <link>http://keens.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru</link>
      <pubDate>Sat, 04 Jul 2015 15:34:46 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru</guid>
      <description>

&lt;p&gt;何故Lisperがマクロについて語るのか。Lisperと議論してみても満足のいく答を得た人はそんなにいないと思う。
それはLisper自身便利とは思っていても何が便利なのかを意識してなくて他人に上手く説明出来ないからじゃないかと思った。
ちょっと思いついた範囲でまとめてみる。&lt;/p&gt;

&lt;p&gt;最近ではマクロシステムを持つ言語は珍しくない。Rust, Scala, Template Haskell, Mirahなどなど。最初にCommon Lispのマクロと他の言語のマクロとの違いを少し考えてみたい。&lt;/p&gt;

&lt;h1 id=&#34;unless:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Unless&lt;/h1&gt;

&lt;p&gt;まず、unlessをマクロで書くことを考えてみたい。単純にifにnotをつければいい。&lt;/p&gt;

&lt;p&gt;Common Lispではこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(if (not foo-p)
    bar)

(defmacro unless (cond then)
  `(if (not ,cond)
       ,then))

(unless foo-p
  bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rustだとこうなるだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
if ! isFoo {
    bar;
}

macro_rules! unless {
    ($cond:expr, $then:stmt) =&amp;gt; {{
        if ! $cond {
            $then
        }
    }};
}

unless!(isFoo, {
    bar;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいはmirahだとこうなる。unlessが予約語なので_unlessにした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if ! isFoo
  bar
end

macro def _unless(cond, block:Block)
  quote{
    if ! `cond`
      `block.body`
    end
  }
end

_unless isFoo do
  bar
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみにCだとこう出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;if(! is_foo)
  bar;

#define unless(cond) if(!(cond))

unless(is_foo)
  bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、上のマクロたちを見比べて欲しい。Common LispのマクロとCのマクロは違和感なく新たな制御構造を作れたのに対してRustとMirahはマクロ呼び出しが剥き出しになっている。&lt;/p&gt;

&lt;p&gt;ここで注意して欲しいのはCはともかくCommon Lisp、Rust、Mirahのマクロは全て引数に必要な構文木をとってそのまま用意したテンプレートにあてはめているだけだ。やっていることに違いはない。
何が違うかというとマクロ呼び出しの構文が制御構造の構文と同じか違うかという点だけだ。私の知る範囲ではそのような構文をした言語はLispしかない。だから「Lispの」マクロなのだ。&lt;/p&gt;

&lt;p&gt;もう一つ。どのマクロ定義も十分直感的に読めたと思う。この範囲なら &lt;strong&gt;S式だからマクロが簡単になるということはない&lt;/strong&gt; と思う。別にS式でなくてもquasiquoteがあれば十分読み易いマクロが書ける。&lt;/p&gt;

&lt;h1 id=&#34;case:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Case&lt;/h1&gt;

&lt;p&gt;caseを生成することを考えよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun fun1 (x)
  (let ((y (case x
             ((:foo) (hoge &amp;quot;foo&amp;quot;))
             ((:bar) (hoge &amp;quot;bar!&amp;quot;)))))
    ...))


(defun fun2 (x)
 (let ((y (case x
            ((:foo) (hoge &amp;quot;foo&amp;quot;))
            ((:baz) (hoge &amp;quot;baz!&amp;quot;)))))
   ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように似たような、しかし微妙に違うcaseが必要になったような時に必要だろう。この時、&lt;code&gt;&#39;(:foo (hoge &amp;quot;foo&amp;quot;) :bar (hoge &amp;quot;bar!&amp;quot;))&lt;/code&gt;のようにリテラルでそのまま書いてしまっては抽象化する意味がなくなる。例えばハッシュテーブルにKey-Valueペアを入れて必要な時に入れたり削除したりすればよい。そのようなマクロはこう書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro case-table (key hash)
  `(case ,key
     ,@(loop
          :for k :being :the :hash-key :of hash :using (hash-value v)
          :collect `((,k) ,v))))

(defparameter *table*)
(setf (gethash :foo *table*) &#39;(hoge &amp;quot;foo&amp;quot;))
(setf (gethash :bar *table*) &#39;(hoge &amp;quot;bar!&amp;quot;))

(defun fun1 (x)
  (let ((y (case-table x #.*table*)))
    ...))

(remhash :bar *table*)
(setf (gethash :baz &#39;(hoge &amp;quot;baz!&amp;quot;)))


(defun fun2 (x)
  (let ((y (case-table x #.*table*)))
    ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ハッシュテーブルを受け取ってリストを返す普通のloopマクロの力をマクロ展開時にも使える。また、ハッシュテーブルには&lt;code&gt;&#39;(hoge &amp;quot;foo&amp;quot;)&lt;/code&gt;などのただのリストを突っ込んだがそれをそのままASTとしても使っている。
Common Lispのマクロのもう1つの良いところはマクロの展開時にもCommon Lispの機能がフルで使えるところであり、マクロの引数に受け取るのが構文木でありデータ構造でもあるS式なところだ。ここでは &lt;strong&gt;S式の同図像性が重要なファクターになっている&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(case-table x #.*table*)&lt;/code&gt; で使っている &lt;code&gt;#.&lt;/code&gt; は &lt;em&gt;リードマクロ&lt;/em&gt; といってマクロ展開(コンパイル時)より前(リード時、構文解析時)に動作するマクロだ。このリードマクロはeval-when-readといってリード時に
値を評価する。その結果、&lt;code&gt;case-table&lt;/code&gt;に渡るのが &lt;code&gt;&#39;*table*&lt;/code&gt;というシンボルでなく&lt;code&gt;*table*&lt;/code&gt;に束縛されているハッシュテーブルになる。因みに &lt;em&gt;コンパイラマクロ&lt;/em&gt; というマクロ展開が終わった後に動作するマクロもある。&lt;/p&gt;

&lt;p&gt;マクロ1つではなくマクロの前後に動作するマクロもあってこそ初めて柔軟性を手にしている。あまりその点は議論されてないのではないだろうか。&lt;/p&gt;

&lt;h1 id=&#34;common-lispの設計:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Common Lispの設計&lt;/h1&gt;

&lt;p&gt;さて、各々言語には予約語や~構文というものがあると思う。メソッド定義構文など。Common Lispにもスペシャルフォームという名前で&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm&#34;&gt;25&lt;/a&gt;個存在する。
驚くべきことに、ここまでに出てきたCommon Lispのコードにはスペシャルフォームは3つしか出てこない。ifとletとquoteだ。setfやloop、defun、defmacro、case、defparameterなんかはマクロで出来ている。&lt;/p&gt;

&lt;p&gt;defunまでマクロで出来ているということはユーザがその気になれば関数定義の構文に手を入れたりも出来るということだ。
普通、そんなことをしたら阿鼻叫喚だがCommon Lispなら安全に出来る。マクロもシンボルに束縛されているので新たにマクロで上書きしたシンボルを名前空間にインポートしなければ今まで通りのdefunやloopが使える。&lt;/p&gt;

&lt;p&gt;もう1つ、普段使うものがマクロで出来ているということはマクロを被せてない機能は相当低レベルだということだ。マクロさえ書けば全く新しい言語機能を追加出来るということであり、あるいは&lt;a href=&#34;http://cl21.org/&#34;&gt;全く新しい言語も作れてしまう&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;このような設計はマクロで制御構造までも作れるから出来るのだ。関数定義構文をマクロで定義している言語はLisp以外に私は知らない。&lt;/p&gt;

&lt;h1 id=&#34;メタプログラミングとcommon-lisp:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;メタプログラミングとCommon Lisp&lt;/h1&gt;

&lt;p&gt;ところで、マクロに限らないメタプログラミングについて考えてみたい。メタプログラミングとは、プログラムを書くプログラムを書くことだ。プログラムはテキスト形式のソースコードから実行形式に至るまでの間に様々な中間形式から中間形式に変換される。メタプログラミングはそのどこかの形式を生成することと同義になる。通常、処理系内部で使う形式は変なことをされると困るのであまり外部に公開したくない。メタプログラミングを許すとしても構文解析などのフロントエンドに近い部分になるだろう。&lt;/p&gt;

&lt;p&gt;例えばyaccやlexのようなソースコードジェネレータ、rubyやDのような文字列ベースのメタプログラミングは公開APIであるところのパーサだけを使っているので安全性は高い。しかし文字列だけだと構造がないので書く側はつらい。一応、Common Lispにもread関数とeval関数があるのでCommon Lispのソースコード文字列を吐いてreadしてevalすれば文字列メタプログラミングは出来る。特に嬉しくないのでやらないが。&lt;/p&gt;

&lt;p&gt;次はトークンベースのメタプログラミングがある。Cのプリプロセッサなど。Common Lispでもリードマクロで可能だ。例えば正規表現リテラルを作ったりとかの例がある。&lt;/p&gt;

&lt;p&gt;次はASTベースのメタプログラミングがある。マクロだ。これは今まで見てきた。&lt;/p&gt;

&lt;p&gt;これより先はメタプログラミングとはあまり言わない気がする。JITと呼ぶのではないか。Common Lispにもeval関数やcompile関数があるからそういうことも出来る。正規表現ライブラリなんかが使っている。&lt;/p&gt;

&lt;p&gt;私が言いたいのはCommon Lispにはメタプログラミングの機構が一杯あるということではない。read, eval, compile…。気付いたかもしれないが、LispはLisp自身で出来ている。
Lispを書くとき、Lispを書いてるかもしれないしLispを構成するLispを書いているかもしれない。いくらでもメタプログラミングが出来るということだ。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;何やらCommon Lisp賛美歌になってしまったが一応まとめておく。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;簡単なマクロ定義ならS式である必要はない&lt;/li&gt;
&lt;li&gt;複雑なマクロ定義ならS式であると書き易い。恐らく他の構文でも書けないことはない。&lt;/li&gt;
&lt;li&gt;マクロ呼び出し構文はS式でないと重大な違いがある。&lt;/li&gt;
&lt;li&gt;マクロ以外にもリードマクロやパッケージなど他の言語機能があってこそマクロが活きる。&lt;/li&gt;
&lt;li&gt;言語機能だけでなくマクロを前提とした設計も重要である。&lt;/li&gt;
&lt;li&gt;LispはS式で出来ている以前にLispで出来ている。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>あなたの知らないShebang</title>
      <link>http://keens.github.io/blog/2015/06/26/anatanoshiranaishebang</link>
      <pubDate>Fri, 26 Jun 2015 23:24:44 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/26/anatanoshiranaishebang</guid>
      <description>

&lt;p&gt;κeenです。最近は何故かBlack君って呼ばれます。Shebangの書き方にはいくつかあって、それを利用したふと面白い方法を思い付いたので共有を。&lt;/p&gt;

&lt;p&gt;さて、ご存知Shebangといえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにファイルの1行目が&lt;code&gt;#!&lt;/code&gt;から始まっているとシェルがそれ以降の文字列を実行可能ファイルのパス名として捜して実行してくれるものですが、実は&lt;code&gt;#!&lt;/code&gt;は唯一のフォーマットではありません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#!&lt;/code&gt;がデファクトになる前なのかそもそもシェルにコメントがなかった時代のものなのかは知りませんが昔は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;: /bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;:&lt;/code&gt;で始めていたらしいです。因みに&lt;code&gt;:&lt;/code&gt;は「何もしないコマンド」です。実質的にコメントとして扱ったり副作用のある変数展開だけを行なったりプログラマティックコメントアウトだったりの用途で使われてます。&lt;/p&gt;

&lt;p&gt;さて、シェルは全て文字列なのでクォートしてもしなくても構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてもちゃんと動いてくれます。なぜわざわざクォートするかというと&lt;a href=&#34;http://keens.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/&#34;&gt;割と処理系ポータブルなCommon Lisp実行可能ファイルを作る | κeenのHappy Hacκing Blog&lt;/a&gt;のように別の言語のスクリプトとして実行される時に文字列リテラルになってくれると単純に無視されるので互換性が高まるのです。&lt;/p&gt;

&lt;p&gt;ということで完全版ポータブルなCommon Lisp実行可能ファイルはこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;

#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abclとcclが利用可能になりました。あとCIMも捜すようにしました。roswellは作者に訊いて下さい。&lt;/p&gt;

&lt;p&gt;ちなみに、shebangの解釈はシェルに依存するのですが、B Shell, csh, tcsh, dash, Bash, zshで動作確認しました。古い機能なので新しいシェルほど切り捨てている可能性があったのですがBashやzshが大丈夫だったので良かったです。
一応非推奨な気がしますがこれしか方法がないので仕方ないですね。&lt;/p&gt;

&lt;p&gt;ということでみなさんスクリプト書きましょう。&lt;/p&gt;

&lt;h1 id=&#34;追記:97aff0076544159c37193ad080a89d0a&#34;&gt;追記&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangの解釈はシェルじゃなくてOSのexec()がやります。で、#!や認識できるバイナリ以外は、exec()がエラーを返した後でシェルがファイルを見て、テキストファイルならシェルスクリプトとして実行ってやってます。なので先頭が:の場合は(続&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614551978526445570&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangとしてではなく、シェルがシェルスクリプトとして読んでるだけなので、その後に/bin/shとか書いてあっても関係ないはず (シェルによってはそこも見るかもしれませんが)&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614552151759589376&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということで実験してみたところ、先頭の&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;はどのシェルも読み飛ばす模様(つまり、&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/usr/bin/ruby&amp;quot;&lt;/code&gt;と書いてもrubyが実行される訳ではない)。&lt;/p&gt;

&lt;p&gt;で、先程の 完全版から&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;を取り除いて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても動いたのでこれが最終版ということになります。&lt;/p&gt;

&lt;p&gt;大学の講究でMINIX本やったどころかexecのところ自分の担当だったのに恥かしい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Clojureおじさん</title>
      <link>http://keens.github.io/slide/Clojureojisan/</link>
      <pubDate>Mon, 22 Jun 2015 22:53:39 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Clojureojisan/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Clojureおじさん
----------------------
サイバーエージント新卒  
第5回 Fresh勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# Clojure 
---------

* 2007年から
* JVMで動くLisp系言語
* 函数型
* 動的型付き
* 値は基本immutable
* 遅延シーケンス
* STMがあり、並列処理に強い


# Hello World
-------------

```clojure
(println &#34;Hello, World&#34;)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# JVM
------
## Javaのコードをシームレスに呼べる

* `obj.method()` ではなく `(.method obj)`
* `Class.staticField` ではなく `Class/staticField`
* `obj.method1().method2()` ではなく `(.. obj method1 method2)`


# JVM
-----

```clojure
(.println System/out &#34;Hello JVM&#34;)
```

```clojure
(Math/random)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Immutable
-----------

* 状態を持たないのでコードの見通しが良い
  + 並列で考える時には重要
  + 複雑さだけでなく不整合などバグの原因になりやすい
* 変更可能な値もある
  + それらはトランザクション内でのみ変更可能
  + 不整合が起きない


# 函数型
--------

```clojure
(filter odd? (map #(+ 1 %) &#39;(1 2 3)))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 遅延シーケンス
---------------

```clojure
(def natural_number (iterate inc 1))
(take 5 natural_number) ;=&gt; (1 2 3 4 5)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# リスト内包表記
----------------

```clojure
(for [x (range 5)] (* x x))
;=&gt; (1 4 9 16 25)
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;


#並列処理に強い
---------------

* 簡単にはJavaのスレッドを呼べばいい
  + Clojureの関数は全てCallableでRunnablea

```clojure
(.start (Thread. (fn [] 
                   (Thread/sleep 1000)
                   (println &#39;foo))))
```


#並列処理に強い
---------------
## core.async

* goroutineとgochannelが使える


## core.async
-------------

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (go (&gt;! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! (go (&lt;! c)))))
  (close! c))
```

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (thread (&gt;!! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! c)))
  (close! c))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 今回紹介し切れなかったの
-------------------------

* マクロ
* メタデータ
* protocolとかの多態性
* ClojureScript/Om
* Typed Clojure


# まとめ
--------

* Clojureを使えばJavaが使える
* Clojureを使えばPythonのリスト内包表記が使える
* Clojureを使えばGoのgoroutine/gochannelが使える



&lt;span style=&#34;font-size:200%;&#34;&gt;Why not start Clojure?&lt;/span&gt;
&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lisp処理系拡張の探求 SBCLのマルチスレッドサポート</title>
      <link>http://keens.github.io/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</link>
      <pubDate>Sat, 20 Jun 2015 18:30:52 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
### Common Lisp 処理系拡張の探求
SBCLのマルチスレッドサポート

----------------------
Lisp Meet Up #29

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# CLのマルチスレッド
----------------------------
## [bordeaux-threads](https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation)
* 色々な処理系のマルチスレッドサポートの抽象レイヤー
* デファクトスタンダード
  + スレッド
  + ロック
  + コンディションヴァリアル


# SBLCのマルチスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# SBLCのマルチスレッド
----------------------------

* スレッド
  + スレッド内エラー
* アトミック操作&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
  + CAS&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* 排他制御（ロック）
* セマフォ
* コンディションヴァリアル
* バリア
* キュー&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* メールボックス&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* ゲート&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* frlock&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;


# アトミック操作

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# アトミック操作
----------------
複雑な動作は同じデータに並行に動かすと壊れうる

```
        [var = 1]
[incf]      |      [decf]
 [1]&lt;-------|
  |         |------&gt;[1]
 [2]---&gt;[var = 2]    |
            |        | 
        [var = 0]&lt;--[0]
```

# アトミック操作
----------------

* `atomic-{incf, decf}`
  + 動作出来る場所が限られている
* `atomic-{pop, push, update}`
  + CASプロトコルを実装していればどこでも


# CASプロトコル
---------------
* compare and swap
* アトミック操作の基本中の基本
  + ハードウェアレベルのサポート
* ざっくり言うと並行版setf
* `(cas place old new env)`
  + もし`place`が`old`に等しければ`new`を代入
* `(defun (cas foo) (old new))`
  + `cas`版の`setf`定義
* 他にも`setf`相当の機能は揃ってる

# CASプロトコル
---------------

```lisp
(defvar *foo* nil)

(defun (cas foo) (old new)
  (cas (symbol-value &#39;*foo*) old new))
```


# キュー
--------

* 普通のキュー
* スレッドセーフ
* `enqueue`, `dequeue`が基本操作
* `dequeue`が多値で、ブロックしない
  + 空なら第二値がnilになる


# メールボックス
---------------

* キューとほぼ同じ
* スレッドセーフ
* `send-message`, `recieve-message`が基本操作
* `recieve-message`はブロックする
  + タイムアウトも設定出来る
* `recieve-message-no-hangはdequeue`と同じ挙動
* `recieve-pending-messages`もある


# ゲート
--------

* 複数のスレッドが1つのイベントを待つ時に使う
* `wait-on-gate`, `open-gate`, `close-gate`が基本操作



```
[gate (closed)]  [T1] [T2] [T3]
     |            |    |    |
     |     wait   |    |    |
     |&lt;----------------+----+
     |            |    .    .
     |     open   |    .    .
[gate (opened)]&lt;--+    .    .
     +----------------&gt;+---&gt;+
         go            |    |
                       V    V
```


# frlock
--------

* Fast Read Lock
* またの名をRead-Write Lock
* Read Lockは多重に取れる。Write Lockは1つしか取れない。
* 基本操作は`frlock-read`と`frlock-write`
* 普通のlockと違って複数のReadが速くなる


# まとめ
--------

* SBCLのマルチスレッドサポートはbordeaux-threadsよりもリッチ
* 処理系の独自サポート面白い
* 処理系に依存してしまってもいいんじゃないだろうか
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Shell Scriptを書くときのテクニック10選</title>
      <link>http://keens.github.io/blog/2015/06/17/shell_scriptwokakutokinikiwotsuketaikoto</link>
      <pubDate>Wed, 17 Jun 2015 22:12:25 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/17/shell_scriptwokakutokinikiwotsuketaikoto</guid>
      <description>

&lt;p&gt;κeenです。LLで書かれた動作のもっさりしてるコマンドラインツールよりシェルスクリプトが好きです。&lt;/p&gt;

&lt;p&gt;しかしシェルスクリプトを書く時にはハマり所も多いです。ということでハマりそうなところと対処法を共有しますね。&lt;/p&gt;

&lt;h1 id=&#34;1-変数は基本クォート:5e57d8f93a32720e126e1053ccd91901&#34;&gt;1. 変数は基本クォート&lt;/h1&gt;

&lt;p&gt;変数には空白が入り得ます（特にパス名とか）。あるいは空である可能性もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mv file1 file2 $target_dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;$target_dir&lt;/code&gt;が空だった時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mv file1 file2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまいます。file2が上書きされますね。恐ろしい。&lt;/p&gt;

&lt;p&gt;クォートで括っておけば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mv file1 file2 &amp;quot;$target_dir&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mv file1 file2 &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり辺なディレクトリに書き込もうとしてエラーになります。まだマシですね。&lt;/p&gt;

&lt;p&gt;基本、と書いたのはクォートしたくない場合もあるからです。例えばこんな時ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;items=&amp;quot;foo bar baz&amp;quot;
for item in $items
do
    echo &amp;quot;$item&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変数展開の後にトークン分割が行なわれるので空白で区切れば複数のトークンを1つの変数に入れられます。&lt;/p&gt;

&lt;h1 id=&#34;2-eオプションをつけよう:5e57d8f93a32720e126e1053ccd91901&#34;&gt;2. -eオプションをつけよう&lt;/h1&gt;

&lt;p&gt;シェルには例外がありません。何かが失敗しても走り続けます。これは時に迷惑な挙動です。しかし &lt;code&gt;-e&lt;/code&gt;オプションをつけると0以外の終了ステータスが出た瞬間スクリプトが止まるようになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-e&lt;/code&gt;オプションを有効にするには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
set -e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば良いです。0以外のステータスで終了し得るコマンドの例外ハンドル的なことをしたければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;trying_command || true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば確実に0で終了します。&lt;/p&gt;

&lt;p&gt;また、スクリプトの途中で&lt;code&gt;-e&lt;/code&gt;を切り替えたければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
set -e
# -eが有効
set +e
# -eが無効
set -e
# -eが有効
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;set -e&lt;/code&gt;と&lt;code&gt;set +e&lt;/code&gt;で制御出来ます。&lt;/p&gt;

&lt;h1 id=&#34;3-カレントディレクトリはスクリプトを起動した場所:5e57d8f93a32720e126e1053ccd91901&#34;&gt;3. カレントディレクトリはスクリプトを起動した場所&lt;/h1&gt;

&lt;p&gt;例えば ~/Shell/hoge.shにこう書いたとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
cat ./hoge.sh
pwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それを実行するとこうなります&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/Shell
$ sh hoge.sh
#!/bin/sh
cat ./hoge.sh
pwd
/home/kim/Shell
$ cd ../
$ sh Shell/hoge.sh
hoge.sh: no such file or directory
/home/kim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なのでシェルスクリプト内での相対パスは基本的に信用出来ません。&lt;/p&gt;

&lt;p&gt;スクリプトの相対でパスを指定したいならこうしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
ROOT=&amp;quot;$(cd $(dirname $0); pwd)&amp;quot;
cat &amp;quot;$ROOT/hoge.sh&amp;quot;
pwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$(cd $(dirname $0); pwd)&lt;/code&gt; がキモです。 $0には起動スクリプトが入ってます。 &lt;code&gt;$ ./hoge.sh&lt;/code&gt;と起動したなら &lt;code&gt;./hoge.sh&lt;/code&gt;が、 &lt;code&gt;$ ../hoge.sh&lt;/code&gt; なら &lt;code&gt;../hoge.sh&lt;/code&gt;が。そのスクリプトがあるディレクトリに移動(&lt;code&gt;cd $(dirname $0)&lt;/code&gt;) して&lt;code&gt;pwd&lt;/code&gt;するとスクリプトのあるディレクトリの絶対パスがとれます。&lt;/p&gt;

&lt;p&gt;因みにこのイディオムはスクリプトにリンクを張られると困ります。 &lt;code&gt;readlink(1)&lt;/code&gt; を使う流儀もあるのですがreadlinkがMacとLinuxで全然違い、互換性を保てないのでおすすめしません。&lt;/p&gt;

&lt;h1 id=&#34;4-sudo-command-fileでパーミッションエラー:5e57d8f93a32720e126e1053ccd91901&#34;&gt;4. sudo command &amp;gt;&amp;gt; fileでパーミッションエラー&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;) を使った時にファイルに書き込んでるのは &lt;code&gt;command&lt;/code&gt;ではなくてシェルなのでシェルのアクセス権限でパーミッションエラーが出ます。sudoして書き込みたいなら&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo command &amp;gt; file&lt;/code&gt; ではなく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ command | sudo tee file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を、&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo command &amp;gt;&amp;gt; file&lt;/code&gt; ではなく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ command | sudo tee -a file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を使いましょう。&lt;/p&gt;

&lt;p&gt;関連して、&lt;code&gt;echo&lt;/code&gt;は外部コマンドではなくシェルの組込みコマンドなのでsudoに渡すことが出来ません。これもファイルに書き込む目的ならechoとsudo teeをパイプで繋ぎましょう。&lt;/p&gt;

&lt;h1 id=&#34;5-sudoのパスワードを渡せない:5e57d8f93a32720e126e1053ccd91901&#34;&gt;5. sudoのパスワードを渡せない&lt;/h1&gt;

&lt;p&gt;スクリプト内でsudoを扱うのは少しテクニックが必要になります。sudoに-Sを付けると標準入力からパスワードを読むようになります。かといってソースにベタ書きする訳にはいきません。
ということで、こうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;printf &amp;quot;password: &amp;quot;
read password
echo &amp;quot;$password&amp;quot; | sudo -S command
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ユーザにパスワードを要求し、メモリに保存。必要な時にsudoに渡すという流れです。&lt;/p&gt;

&lt;p&gt;シェルに依ってはreadに-sをつけることでエコーバックしなくなるのでディスプレイにパスワードが流れてくることはありません。未確認ですがdash(Debian系の/bin/sh)では出来なくてB shell(BSD系の/bin/sh)やBash、Zshなどの拡張POSIXシェルだと出来そうです。&lt;/p&gt;

&lt;p&gt;余談ですが改行なしの印字に&lt;code&gt;echo -n&lt;/code&gt;は使えません。&lt;code&gt;-n&lt;/code&gt; シェルによってはオプションを認識しないので。printf(1)はPOSIXにあるのでポータブルに使えます。&lt;/p&gt;

&lt;p&gt;因みにパスワードが初期化されてないならユーザに訊く、というのはこういう関数を実装すれば良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;password(){
    if ! ${password+:} false
    then
        printf &amp;quot;password: &amp;quot;
        read -s password
    fi
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;6-sudoのパスワードを渡しつつ標準出力も渡したい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;6. sudoのパスワードを渡しつつ標準出力も渡したい&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;{ echo &amp;quot;$password&amp;quot; ; cat } | sudo -S command
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しましょう。&lt;/p&gt;

&lt;h1 id=&#34;7-リモートでスクリプトを実行したい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;7. リモートでスクリプトを実行したい&lt;/h1&gt;

&lt;p&gt;一旦scpでスクリプトを送ってから実行？そんな面倒なことしたくありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote &amp;lt;&amp;lt;SHELL
#  some script
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で実行出来ます。これはログインシェルで実行します。ログインシェル如何に関わらずshで実行したいなら(ログインシェルがcshとかnologinとかは割とありえる)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
#  some script
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としましょう。&lt;/p&gt;

&lt;h1 id=&#34;8-リモートでsudoのパスワードを渡したい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;8. リモートでsudoのパスワードを渡したい&lt;/h1&gt;

&lt;p&gt;先のテクニックがそのまま使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;printf &amp;quot;password: &amp;quot;
read password
ssh user@remote sh &amp;lt;&amp;lt;SHELL
echo &amp;quot;$password&amp;quot; | sudo -S command
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クォート無しのヒアドキュメントのシェル変数の展開はローカルで行なわれるのでローカルにある変数がそのまま参照出来ます。&lt;/p&gt;

&lt;h1 id=&#34;9-リモートにローカルに置いてあるファイルを送りたい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;9. リモートにローカルに置いてあるファイルを送りたい&lt;/h1&gt;

&lt;p&gt;scpでも良いですがroot loginを許可してないと設定ファイルを/etcに置けないなどと不都合が生じます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt;&amp;gt; some_remote_file
$(cat local_file)
EOF
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは少し解説が必要でしょうか。&lt;/p&gt;

&lt;p&gt;まず、先程も出てきた&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですが普通のヒアドキュメントなので中の変数やコマンド置換を展開します。ということでリモートで実行されるのは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt;&amp;gt; some_remote_file
# the content of
# local_file
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。そしてcatのヒアドキュメントはクォート付きなのでlocal_fileの中身がさらに変数展開されることはありません。&lt;/p&gt;

&lt;p&gt;勿論、root権限で書き込みたかったら先程までのテクニックを組み合わせて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
{ echo &amp;quot;$password&amp;quot; ; cat &amp;lt;&amp;lt;&#39;EOF&#39; } | sudo -S tee  some_remote_file
$(cat local_file)
EOF
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として下さい.&lt;/p&gt;

&lt;h1 id=&#34;10-リモートにあるファイルを編集したい:5e57d8f93a32720e126e1053ccd91901&#34;&gt;10. リモートにあるファイルを編集したい&lt;/h1&gt;

&lt;p&gt;sed(1)を使いましょう。あるいは、sedだと辛いならローカルでファイルを編集、diffをとってpatch(1)を使いましょう。diffの送り方はもう分かりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh user@remote sh &amp;lt;&amp;lt;SHELL
cat &amp;lt;&amp;lt;&#39;EOF&#39; |  patch
$(cat file.diff)
EOF
SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;いかがでしょうか。テクニックさえ抑えればシェルスクリプトは料理人だか板前だか知りませんが流行に流されるツールにも負けない力があると思います。動作も速い。
みなさんシェルスクリプト書きましょうね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustでstructのmutableなfieldあれこれ</title>
      <link>http://keens.github.io/blog/2015/06/14/rustdestructnomutablenafieldarekore</link>
      <pubDate>Sun, 14 Jun 2015 17:53:11 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/14/rustdestructnomutablenafieldarekore</guid>
      <description>

&lt;p&gt;κeenです。人々にRustを薦めておきながら本人は昨日ようやく入門しました。その時に困ったことをメモ。タイトルがルー語になってますが気にしない。&lt;/p&gt;

&lt;p&gt;因みにこれはRust 1.0の情報です。&lt;/p&gt;

&lt;h1 id=&#34;導入:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;導入&lt;/h1&gt;

&lt;p&gt;Rustを知らない人のために説明すると、Rustの値はデフォルトでイミュータブルです。デフォルトで、というのはもちろんミュータブルにすることも出来ます。
標準ライブラリにも値がイミュータブルであることを要求するものもあります。
そしてミュータビリティは&lt;code&gt;mut&lt;/code&gt;として型にも現れます。厳密に同じかは知りませんが&lt;code&gt;const&lt;/code&gt;の逆、と思えばいいでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Point {
    x: isize,
    y: isize
}

fn double(p: &amp;amp;mut Point) {
    p.x = p.x * 2;
    p.y = p.y * 2;
}

fn main(){
    let mut p1 = Point{x: 1, y: 2};
    let p2 = Point{x: 1, y: 2};
    double(&amp;amp;mut p1);
    double(&amp;amp;mut p2); // error! p2 is immutable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イミュータビリティは継承します。親のstructがイミュータブルなら子もイミュータルになります。因みにフィールドに&lt;code&gt;mut&lt;/code&gt;を指定することは出来ないようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::collections::HashMap;

struct IntHashMap {
    hash: HashMap&amp;lt;isize, isize&amp;gt;
}
fn main(){
    let h = IntHashMap{hash: HashMap::new()};
    h.hash.insert(1, 2);        // error! h.hash is immutable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、少し本筋とずれますがtraitについて。他の言語でいうインターフェースのようなものです。今回これで困ったので。&lt;/p&gt;

&lt;p&gt;例えばHTTPライブラリの&lt;a href=&#34;http://hyper.rs/hyper/hyper/server/trait.Handler.html&#34;&gt;hyper&lt;/a&gt;では次のようなトレイトを実装しているstructをrequest handlerとして登録できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Handler: Sync + Send {
    fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;);

    fn check_continue(&amp;amp;self, _: (&amp;amp;Method, &amp;amp;RequestUri, &amp;amp;Headers)) -&amp;gt; StatusCode { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを見て下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self&lt;/code&gt;に&lt;code&gt;mut&lt;/code&gt;がついてませんね。つまりhandlerはイミュータブルな値として渡されます。例えば先の例のようにフィールドにハッシュマップを持っていても更新出来ません。ちょっと困りますね。&lt;/p&gt;

&lt;h1 id=&#34;cell-refcell:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;Cell/RefCell&lt;/h1&gt;

&lt;p&gt;ということでフィールドにミュータビリティを入れるのが &lt;code&gt;std::cell::{Cell, RefCell}&lt;/code&gt; です。この辺のブログを参考に。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://saneyukis.hatenablog.com/entry/2014/05/30/230351&#34;&gt;#rustlang における構造体のmutabilityと&lt;code&gt;Cell/RefCell&lt;/code&gt; - snyk_s log&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;で、喜び勇んで使ったのですが次なるエラーが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyHandler {
    cache: RefCell&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;
}

impl Handler for MyHandler {
    fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;){
        ....
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;the trait `core::marker::Sync` is not implemented for the type `core::cell::UnsafeCell&amp;lt;...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうも、hyperは複数スレッドでも動かせるのでハンドラにスレッドセーフであることが要求されるようです。そしてRustコンパイラはRefCellがスレッドセーフでない事を知っているのでコンパイルを弾きます。怖いですね。&lt;/p&gt;

&lt;h1 id=&#34;mutex:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;Mutex&lt;/h1&gt;

&lt;p&gt;無理っぽいので最早別の手段を捜し始めます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;キャッシュ用のアクター走らせるのが良い気がしてきた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/609471732970209280&#34;&gt;2015, 6月 12&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これはちょっと無理がありそうですね。&lt;/p&gt;

&lt;p&gt;しかし、別の方法があるようでした。&lt;a href=&#34;https://doc.rust-lang.org/std/sync/struct.Mutex.html&#34;&gt;std::sync::Mutex&lt;/a&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyHandler {
    cache: Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで&lt;code&gt;lock().unwrap()&lt;/code&gt;するだけで使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut cache = self.cache.lock().unwrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにロックの解除は不要です。Rustコンパイラは値の生存期間を知っているので値がこれ以上使われなくなった箇所にコンパイラがunlockを挟みます。(正確に言うとdrop(デストラクタ)が挿入され、dropがリソースの開放を行なう)&lt;/p&gt;

&lt;h1 id=&#34;まとめ:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;rustのイミュータビリティは継承する&lt;/li&gt;
&lt;li&gt;structのfieldに直接&lt;code&gt;mut&lt;/code&gt;は指定出来ない&lt;/li&gt;
&lt;li&gt;シングルスレッドでミュータブルなフィールドが欲しいなら&lt;code&gt;Cell&lt;/code&gt;/&lt;code&gt;RefCell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;マルチスレッドなら&lt;code&gt;Mutex&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでOpenCV 3.0と戯れる</title>
      <link>http://keens.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru</link>
      <pubDate>Sun, 07 Jun 2015 16:56:51 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru</guid>
      <description>

&lt;p&gt;κeenです。先日OpenCV 3.0がリリースされましたね。
ちょっと触ってみようと思ったのですが公式バインディングがC++、C、Java、Pythonと中々つらい言語ばっかりなので扱いやすいClojureから触った時のメモです。&lt;/p&gt;

&lt;p&gt;2系とはAPIが変わってる部分もあるらしく、苦労しました。
UbuntuでやってるのでMacの人は適当に読み替えて下さい。&lt;/p&gt;

&lt;h1 id=&#34;準備:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;準備&lt;/h1&gt;

&lt;h2 id=&#34;opencv:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;OpenCV&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://opencv.org/&#34;&gt;公式&lt;/a&gt;からOpenCV 3.0をダウンロードしてきましょう。展開してからは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-3.0.0
$ cmake .
$ make -j4
$ sudo make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストールまでしてくれます。&lt;/p&gt;

&lt;h2 id=&#34;imshow:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;ImShow&lt;/h2&gt;

&lt;p&gt;どうも3.0からHighguiというQtベースのGUIツール群のJavaバインディングが作られなくなったそうです。Swing使えと。&lt;/p&gt;

&lt;p&gt;ということでOpenCVとSwingのブリッジしてくれる軽いライブラリが&lt;a href=&#34;https://github.com/master-atul/ImShow-Java-OpenCV&#34;&gt;ImShow-Java-OpenCV&lt;/a&gt;
です。.javaファイル1枚なので本当に軽いです。&lt;/p&gt;

&lt;p&gt;.jarもレポジトリに入ってるのですがソースコードより古いらしく、自分でビルドする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:master-atul/ImShow-Java-OpenCV.git
$ cd ImShow-Java-OpenCV/ImShow_JCV/src
$ javac com/atul/JavaOpenCV/Imshow.java
$ jar -cf Imshow.jar com/atul/JavaOpenCV/Imshow.class
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lein-プロジェクト:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;lein プロジェクト&lt;/h2&gt;

&lt;p&gt;Clojureのプロジェクト管理ツールの&lt;a href=&#34;http://leiningen.org/&#34;&gt;Leiningen&lt;/a&gt;を使います。知らない人は適当にググって下さい。&lt;/p&gt;

&lt;p&gt;まずプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein new opencv-play
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んで、mavenでいうところのpom.xmlにあたるproject.cljをいじります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-play
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]])
$ edit project.clj
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]
                 [cider/cider-nrepl &amp;quot;0.9.0-SNAPSHOT&amp;quot;]]
  :jvm-opts [&amp;quot;-Djava.library.path=./lib&amp;quot;]
  :resource-paths [&amp;quot;./lib/opencv-300.jar&amp;quot;
                   &amp;quot;./lib/Imshow.jar&amp;quot;]
  :injections [(clojure.lang.RT/loadLibrary org.opencv.core.Core/NATIVE_LIBRARY_NAME)])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしたら先程のライブラリ達を配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir lib
$ cp /usr/local/share/OpenCV/java/* lib
$ cp /path/to/ImShow-Java-OpenCV/ImShow_JCV/src/Imshow.jar lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにlenaも呼びましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir img
$ cp /path/to/src/of/opencv-3.0.0/samples/data/lena.jpg img
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;遊ぶ:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;遊ぶ&lt;/h1&gt;

&lt;p&gt;準備完了ってことでREPLを起動しましょう。ちょっと遅いですが我慢。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein repl
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
nREPL server started on port 52301 on host 127.0.0.1 - nrepl://127.0.0.1:52301
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_25-b17
    Docs: (doc function-name-here)
          (find-doc &amp;quot;part-of-name-here&amp;quot;)
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このままREPLを使ってもいいですが私はEmacsから&lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt;でnREPLにつなぎます。
REPLでも補完は効くのでEmacsやらのエディタの設定が面倒ならこのままでも十分ですよ。&lt;/p&gt;

&lt;p&gt;まずは画像のロードから。2系とは違ってImagecodecを使うようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.imgcodecs Imgcodecs])
org.opencv.imgcodecs.Imgcodecs
user&amp;gt; (def lena (Imgcodecs/imread &amp;quot;img/lena.jpg&amp;quot;))
#&#39;user/lena
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いじる前に表示してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [com.atul.JavaOpenCV Imshow])
com.atul.JavaOpenCV.Imshow
user&amp;gt; (def is (Imshow. &amp;quot;Lena&amp;quot;))
#&#39;user/is
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/show-lena.png&#34; alt=&#34;lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;よしよし。表示されましたね。ではこの辺を参考に顔認識してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/woxtu/items/bf39e3d53cbf60396d2c&#34;&gt;Clojure - 二次元絵の顔を検出する - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずは必要なパッケージの読み込み&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core Mat CvType])
org.opencv.core.CvType
user&amp;gt; (import [org.opencv.imgproc Imgproc])
org.opencv.imgproc.Imgproc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前処理のグレースケール変換からヒストグラムの均一化まで一気にやってしまいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def buffer (Mat. 512 512 CvType/CV_8UC3))
#&#39;user/buffer
user&amp;gt; (Imgproc/cvtColor lena buffer Imgproc/COLOR_RGB2GRAY)
nil
user&amp;gt; (Imgproc/equalizeHist buffer buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで一旦画像の確認。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/gray-hist-lena.png&#34; alt=&#34;gray-hist-lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ふむふむ。ではでは顔を認識しますか。&lt;/p&gt;

&lt;p&gt;まずは色々準備します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core MatOfRect])
org.opencv.core.MatOfRect
user&amp;gt; (import [org.opencv.objdetect CascadeClassifier])
org.opencv.objdetect.CascadeClassifier
user&amp;gt; (def faces (MatOfRect.))
#&#39;user/faces
user&amp;gt; (def classifier (CascadeClassifier.))
#&#39;user/classifier
user&amp;gt; (.load classifier &amp;quot;/usr/local/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml&amp;quot;)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに分類器のデータのロードは成功がtrueで失敗がfalseだそうです。例外投げないんですね。ハマった。パス名に&lt;code&gt;~&lt;/code&gt;を使うと(ホームを省略表記すると)ロードに失敗するようなのでお気をつけて。&lt;/p&gt;

&lt;p&gt;それでは実行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.detectMultiScale classifier buffer faces)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、顔の位置がとれたので画像に重ねるのですがここではSwing(AWT)の描画を使ってみましょう。
OpenCVの描画は画像に描画するのでファイルに書き出しても残っているのに対してSwingのだと表示しているフレームに描画するので書き出した画像には残りません。また、リフレッシュすれば消えるのでインタラクティブに実験するのに向いてます。&lt;/p&gt;

&lt;p&gt;一旦準備。フレームをレナの元画像に戻しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [java.awt Rectangle Color])
java.awt.Color
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImshowのWndowというパブリックなメンバにJFrameが入ってるのでそれを操作します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def g2 (.getGraphics (.Window is)))
#&#39;user/g2
user&amp;gt; (.setColor g2 Color/GREEN)
nil
user&amp;gt; (doseq [face (.toList faces)]
  (let [rect (Rectangle.)]
    (do
      (.setRect rect (.width face) (.height face) (.x face) (.y face))
      (.draw g2 rect))))
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/face-recognized-lena.png&#34; alt=&#34;face recognized lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;パチパチパチ&lt;/p&gt;

&lt;p&gt;因みに四角形を消すには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で十分です。ミスっても何回でもやり直せますね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;因みに3.0のドキュメントが探しづらいのですが、masterにあるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.opencv.org/master/&#34;&gt;OpenCV: OpenCV&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OpenCVをインタラクティブに扱えると楽しいのでみなさんClojure使いましょう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ボトルネックのイイ話</title>
      <link>http://keens.github.io/slide/botorunekkunoiihanashi/</link>
      <pubDate>Thu, 04 Jun 2015 00:03:14 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/botorunekkunoiihanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ボトルネックのイイ話
----------------------
サイバーエージェント15新卒  
FRESH勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# ボトルネック
-------------

&gt; ボトルネック (bottleneck) とは、システム設計上の制約の概念。英語の「瓶の首」の意。一部（主に化学分野）においては律速（りっそく、「速さ」を「律する（制御する）」要素を示すために使われる）、また『隘路（あいろ）』と言う同意語も存在する。 


# Webアプリの主な登場人物
------------------------

* リバースプロキシ
* アプリケーションサーバ
* データベース


![relation of reverse proxy, app and DB](/images/webapp.png)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# レスポンスタイムとスループット
------------------------------

* レスポンスタイム 
  + リクエストを投げてレスポンスが返ってくるまでの時間
  + ユーザから見たメトリクス
* スループット&lt;!-- .element: class=&#34;fragment highlight-red&#34;--&gt;
  + 一定時間内にシステムがどれだけのリクエストを捌けるか
  + 中の人から見たメトリクス


# スループット
-------------

* スループットの最大 ≒ リソースの限界
  + ネットワーク帯域
  + ディスクIO
  + メモリ使用量
  + CPU負荷
* リソースのどれか1つでも限界になったらそれ以上パフォーマンスは上がらない

# パフォマンスの目安
-------------------

* ネットワーク帯域: bpsで表わす。NICによるが 1Gbpsとか
* CPU: パーセンテージで表わす。100xコア数が最大マシンに依る。
* メモリ: Bで表わす。ピンキリだが1GB ~ 128GBくらい？
* ディスクIO: Bpsで表わす。HDDなら 100Bpsとか。SSDなら10倍くらい。

テキトーに調べたので間違ってるかも

# 誰が何を
---------

* リバースプロキシ: ネットワーク、メモリ、CPUなど
* アプリケーションサーバl: CPU、メモリなど
* データベース: CPU、ディスクIOなど


&lt;span style=&#34;font-size: 200%&#34;&gt;「CPUは100%に行ってないのにアプリケーションが遅いんだよ」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* ボトルネックはCPUとは限らない
* 他のメトリクスも一緒に見るべき


# 推測するな。計測せよ
---------------------

* 実際に測ってみないとどこがボトルネックか分からない
* 何をしてどれくらいパフォーマンスが上がったのかも分からない
  + コストパフォーマンスも重要


&lt;span style=&#34;font-size: 200%&#34;&gt;「パフォーマンスが悪いからCPUをグレードアップしよう」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* ボトルネックはCPUとは限らない
* 例えばネットワーク帯域が詰まっているのにCPUを改善しても意味がない
* 帯域が詰まってるならデータを減らす、NIC（マシン）を増やすなどをする


&lt;span style=&#34;font-size: 200%&#34;&gt;「多分アプリケーションを高速化したよ」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* 計測せずに高速化しても意味がない
  + テストの無いリファクタリングがただの破壊なのと同じ
* 高速化した気になって実際はコードが汚なくなっただけの可能性もある

# ボトルネックは変わりうる
------------------------

* 一箇所をずっと改善してても意味がない
* ある程度改善したら次のリソースの限界がきてるかもしれない

&lt;span style=&#34;font-size: 200%&#34;&gt;「アプリケーションを10倍高速化したのにあんまり速くなってない」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* 10倍くらい極端に高速化すると次のリソースがボトルネックになる
* ディスクやネットワークの改善を考えるべき

# リソースの食い合い
-------------------

* 1マシンで完結している場合、リソースの食い合いが発生しうる
  + リバースプロキシとアプリケーションがCPUを食い合うとか
* この時、どのようにして解決するのが適切か？

# 例題
------

* アプリが80%くらいの負荷
* Rプロキシが20%くらいの負荷


# 例題
------

1. アプリが多くCPUを喰ってるからアプリを高速化すべき
2. アプリが多くCPUを必要としてるからRプロキシはアプリにCPUを譲るべき

# 例題
------

1. アプリが多くCPUを喰ってるからアプリを高速化すべき
2. &lt;span style=&#34;color: #aaa;&#34;&gt;アプリが多くCPUを必要としてるからRプロキシはアプリにCPUを譲るべき&lt;/span&gt;

# アムダールの法則
-----------------

* [アムダールの法則 - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%A0%E3%83%80%E3%83%BC%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87)
* ざっくり言うと比率の小さな部分を高速化しても全体の高速化は高が知れてる

&lt;span style=&#34;font-size: 200%&#34;&gt;「ORマッパ使うと遅そうだから生のSQL使おう」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* ORマッピングにかかるコストは微小
* 他にもっと効率的に改善出来る部分に手をつけるべき

# リソースの配分
---------------

* 逆に、与えられたリソースからどれをどこに割り当てるかの問題もある
* 理論的には負荷の高い部分に多くリソースを割り当てれば良い。
* しかしアプリケーションの構成を先に決めないといけないので事前に計測は出来ない
  + 知識と経験と勘

# 例題
------

* 画像配信アプリケーション
* VPS5台 
  + ネット1Mbps/メモリ1G/CPU4コア/HDD
* Rプロキシ、アプリ、DBにそれぞれ何台割り当てる？
  + 1つのマシンに複数機能を持たせても良い。

# チューニングは難しい
---------------------

* 様々な部分の知識が必要
* システム全体を見渡した設計力も大事
* 細かなチューニングテクニックも一杯
  + 今回話してないが、キャッシュ戦略とかも
  + Cache-Control
* 知識がないと計測しても数値の意味が分からない

&lt;span style=&#34;font-size: 200%&#34;&gt;「やった。5%高速化した」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* パフォーマンスは計測の度にゆらぎがある
* 5%くらいなら普通に測定誤差の範囲内
* 逆に、5%くらいの改善をしても意味がない

# チューニングは楽しい
---------------------

* パズルゲームみたいな部分もある
* チューニング次第でスループット何十倍とかいく
* 難しい分一気にパフォーマンスが上がると喜びも一入

# ISUCON

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ISUCON
--------

* [ISUCON公式Blog](http://isucon.net/)
* Webアプリケーションチューニングコンテスト
* 優勝賞金100万円
* 何でもアリ。どこをいじってもいい。
* 要はさっきの知識をフルで活用出来る


# ISUCON
--------

* 何でもアリは実は珍しい。
  + 他はデータベースのみ、とかアプリは触っちゃだめ、とか雁字搦め
* 前回は185組（1チーム2~3人）の大きな大会
  + 予選で27チームに絞られる
* 界隈の有名人が揃う天下一武闘会の様相
* 楽しい


# 良質な問題
-----------

* 過去問は教育的な問題が多数。
* 過去問は全て公開。
* 腕試しに丁度良い。

# 今年のISUCON
--------------

* 予選 9/26,27
* 本戦 10/31
* 2~3人のチーム
* Google Cloud Platform
* 出題は[@tagomoris](https://twitter.com/tagomoris)さんと[@kamipo](https://twitter.com/kamipo)さん


&lt;span style=&#34;font-size: 300%&#34;&gt;Let&#39;s ISUCON&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 参考
------
* [ISUCONで学ぶ Webアプケーションのパフォーマンス向上のコツ 実践編 完全版](http://www.slideshare.net/kazeburo/isucon-summerclass2014action2final)
* [ISUCONの話(夏期講習2014)](http://www.slideshare.net/tagomoris/isucon2014)
* [kamipoさんはすごい人](https://twitter.com/search?q=kamipo%E3%81%95%E3%82%93%E3%81%AF%E3%81%99%E3%81%94%E3%81%84%E4%BA%BA&amp;src=typd&amp;vertical=default&amp;f=tweets)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Transducerについて</title>
      <link>http://keens.github.io/slide/transducernitsuite/</link>
      <pubDate>Wed, 03 Jun 2015 22:29:50 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/transducernitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Transducerについて
----------------------
サイバーエージェント  
朝の3分スピーチ
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# Transducerって？
------------------

* Clojure 1.7で入るフレームワーク
* 関数のパイプライン化を簡単にする
* 入力、出力には依存しない


# Reduce関数について
-------------------

* `reduce: (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* `(&#39;a -&gt; &#39;b -&gt; &#39;a)` でシーケンスを集約する
* `(reduce + 0 &#39;(1 2 3)) ;=&gt; 6`
* 要はreduceは関数を使って集約する。

# Transducerについて
-------------------

* `transduce:((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a)) (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* 集約関数を変換する関数もとる
* `(transduce xf + 0 &#39;(1 2 3))`
* transducerで集約する前に処理を挟める

# すごいところ
-------------------------
## コンポーサビリティ

* `((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a))`
* 変換関数は入力と出力が同じ。
* つまり変換関数を合成出来る
* ex) `(comp (filter odd?) (map inc))`


# すごいところ2
--------------------------
## 汎用性

* 各関数は入力や出力について知る必要はない
  + シーケンスではなく要素に対して定義される
* シーケンスだけでなく遅延シーケンス、ストリーム、チャネルなどなどにも使える
* 中間シーケンスを作らない
  + 遅延シーケンスやストリームには大きなメリット
* 集約先をシーケンスなどにすることも出来る
  + 関数の汎用性が上がる

# すごいところ3
--------------
## 並列/非同期

* core.asyncもtransducerをサポート
* 各変換関数を並列/非同期に実行が可能
* さらに各関数に割り当てるプロセッサの数も細かく制御出来る


&lt;span style=&#34;font-size: 500%;&#34;&gt;変換して&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 500%;&#34;&gt;集約する&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 300%;&#34;&gt;何かに似てない？&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 600%;&#34;&gt;MapReduce&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; ozaさんの近しい環境というとHadoop...多段Mapreduceをtransdecerみたいにしようってはなしとかですか？&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605368356393218048&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; まさにその通りです．MapReduce には Combiner という中間集約をする API があるのですが，それをもっと汎用的にしようという話です． &lt;a href=&#34;http://t.co/injEiPjePG&#34;&gt;http://t.co/injEiPjePG&lt;/a&gt;&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605369771505221633&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; すごい楽しそうですね。Clojure向けのAPIがtransducerのバッグエンドになって普段書いてるコードがそのままHadoopで動いたりしたら、とか夢が無限に広がります&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605370461476646912&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; おお，その案は良いですね！！&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605370619509637121&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 200%;&#34;&gt;Clojure 1.7 + Transducer&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 400%;&#34;&gt;Comming Soon&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 参考
------
* [Clojure 1.7のtransducersを動かしてみよう - Qiita](http://qiita.com/tokomakoma123/items/1ca3fb0dddc5b901b032)
* [core.async+transducers Shibuya.lisp #21](http://www.slideshare.net/ktsujister/coreasynctransducers-shibuyalisp-21)
* [Hadoop Combinerメモ(Hishidama&#39;s Hadoop Combiner Memo)](http://www.ne.jp/asahi/hishidama/home/tech/apache/hadoop/Combiner.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>