<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 29 Mar 2016 01:44:39 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SMLで函数型的正規表現マッチ</title>
      <link>/slide/SMLdekansuukatatekiseikihyougenmatchi/</link>
      <pubDate>Tue, 29 Mar 2016 01:44:39 +0900</pubDate>
      
      <guid>/slide/SMLdekansuukatatekiseikihyougenmatchi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLで函数型的正規表現マッチ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# 元ネタ
--------
[関数型的正規表現マッチ | Preferred Research](https://research.preferred.jp/2010/11/regexp-play/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 正規表現
----------

必要最小限の要素は5つだけ

1. 空文字
2. アルファベット1つ
3. 正規表現のOR結合
4. 正規表現のAND結合
5. 正規表現の繰り返し


# SMLで表してみる
-----------------

``` sml
datatype  reg
  = Empty
  | Sym of t
  | Or of reg * reg
  | And of reg * reg
  | Rep of reg
```

# 本当に大丈夫？

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# `/(a|b)*c/`
-----------

``` sml
And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)
```


# `/https?:\/\/[a-z]*/`
-----------

``` sml
val a_z = Or(Sym&#34;a&#34;, Or(Sym &#34;b&#34;, Or(Sym &#34;d&#34;, ...)))
And(Sym &#34;http&#34;, And(Or(Sym &#34;s&#34;, Empty), And(Sym &#34;://&#34;, Rep a_z)))
```


# 実装してみる

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# `Empty`, `Sym`, `Or`
----------------
trivial

``` sml
fun match Empty u = isEmpty u
  | match (Sym a) u = a = u
  | match (Or(p, q)) u = match p u orelse match q u
```


# `And`
--------

`And(p, q)` に入力が`u`の時`p`がどこまでマッチするか分からないので

* `u` から一部取ってきて`p`にマッチするか確認
* 残りの文字列が`q`にマッチするか確認


# `And`
--------
`match (And (Sym &#34;a&#34;, Sym &#34;b&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;&#34;)、(Sym &#34;b&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;b&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;b&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;abd&#34;)、(Sym &#34;b&#34;と&#34;&#34;)



# `And`
--------

``` sml
  | match (And(p, q)) u = 
    withSprits u (fn (u1, u2) =&gt; 
      match p u1 andalso match q u2)

```

`withSprits u f` は`u`を2分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。


# `Rep`
-------

`Rep(r)` に入力が`u`の時、`r`がどこまでマッチするかも`Rep`が何回繰り返すかも分からないので

* `u` を任意の個数に分割し
* その全てが`r`にマッチするか確認



# `Rep`
--------
`match (Rep (Sym &#34;a&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;b&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)




# `Rep`
--------

``` sml
  | match (Rep(r)) u =
    withParts u (fn input =&gt;
      List.all (match r) input)
```

`withParts u f` は`u`を分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。



# チェック
----------

```
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbca&#34;;
val it = false : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbc&#34;;
val it = true : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;c&#34;;
val it = true : bool
```


# まとめ
--------

* 適当に実装したら正規表現も簡単に実装出来るよ
* SMLで正規表現実装したよ


# 参考
------

* [KeenS/regexp](https://github.com/KeenS/regexp)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ビッグデータしないDrill、ローカルで快適に使うために</title>
      <link>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</link>
      <pubDate>Sun, 06 Mar 2016 14:54:30 +0900</pubDate>
      
      <guid>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ビッグデータしないDrill、ローカルで快適に使うために
----------------------
[Tokyo Apache Drill Meetup](http://drill.connpass.com/event/27414/)  
2016-03-22

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + サイバーエージェントのエンジニア
   + アドテクスタジオ所属
   + データエンジニアじゃなくてもデータを触ることはある


# なぜローカルか
---------------

* ビッグデータ重い
* 使いたいデータが絞れる時には大袈裟
  + 「売り上げ上位1000のユーザの行動」とか
* 同じようなクエリの重複
  + 新しいテーブル作れないDBとかview作れないDBとか
* 結果をRに渡したりとかが面倒
  + CSVダウンロードがGUI

# キャッシュ的な
----------------

```
+---------------------------------+
| BIG DATA (BigQuery, Spark, etc) |
+---------------------------------+
        ^ |  ^  |
        | |  |  |
        | v  |  v
   +-------------------+
   | ローカルキャッシュ | &lt;- ???
   +-------------------+
     ^ | ^ | ^ | ^ |
     | v | v | v | |
     +----------+  |
     |   自分   |  |
     +----------+  v
     +---+    +-----+
     | R | &lt;--| CSV |
     +---+    +-----+
```


# やりたいこと
--------------

* パパッっと処理を始められる
  + だいたい「CSVを簡単に読める」に同じ
  + たまにJSONとか
* 簡単に処理出来る
  + 自分が馴れているかどうか
* CSVを吐ける
  + 最後はRに渡したい


# 候補
-------

* ローカルMySQL
  + 事前のScheme定義が必要
* R
  + 扱い馴れない
* SQLite
  + 事前のScheme定義が必要
* (Python)
  + あまり向いてない？



&lt;pre style=&#39;font-size: 200%&#39;&gt;
＿人人人人人人人＿
＞　突然のDrill　＜
￣Y^Y^Y^Y^Y^Y￣
&lt;/pre&gt;


# なぜ Drill
------------

* (デーモン立ち上げておけば)サクっと始められる
* CSVをそのまま読める
  + Schema定義がいらない!
* ついでにJSONも読める
* 馴れたSQLで操作出来る
* CSV吐ける


# Drillを便利にするために
-------------------------

* いくつかのシェル関数
* Drillのデーモン/クライアントの起動を便利に

```sh
drill-start() {
    ~/compile/zookeeper-3.4.8/bin/zkServer.sh start
    drillbit.sh start
}

drill-cli() {
    sqlline -u jdbc:drill:zk=localhost:2181
}

drill-web() {
   firefox http://localhost:8047
}
```


# もっと便利に
--------------

* REPLでの操作が面倒
  + ヒストリ遡るのとか
  + ミスった時の訂正が地味に不便
* シンタックスハイライト欲しい
* 馴れたツールで編集したい


# sql-drill.el
--------------

* [KeenS/sql-drill.el](https://github.com/KeenS/sql-drill.el)
* Emacsのsql-modeのDrillサポート
  + emacsのsql-modeは拡張可能
* シンタックスハイライト
* REPL


# DEMO
------
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# まとめ
--------

* ローカルでデータ分析したい時があるよ
* その時にDrillは便利だよ
* Emacs向けのDrillプラグイン作ったよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustとは何か。どんな言語か。</title>
      <link>/slide/Rusttohananika_donnagengoka_/</link>
      <pubDate>Sun, 06 Mar 2016 05:27:39 +0900</pubDate>
      
      <guid>/slide/Rusttohananika_donnagengoka_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustとは何か。どんな言語か。
----------------------
[異種プログラミング言語格闘勉強会](http://kbkz.connpass.com/event/26677/)  
2016-03-20


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# Rustって?
----------

* システムプログラミング言語
* だけど函数型言語から影響を受けた
* 安全かつ高速
* ゼロコスト抽象化


## システムプログラミング言語
---------------------------

* スレッドはネイティブ、Cとの相互呼び出し、小さなバイナリサイズ
* ゲームエンジンとか作れる([piston](https://github.com/PistonDevelopers/piston))
* レンダリングエンジンとか作れる([Servo](https://github.com/servo/servo))
* Lチカとか出来る
* OSとか作れる([Redox](https://github.com/redox-os/redox))


## 函数型言語的からの影響
-----------------------

最近ではめずらしくなくなった


* デフォルトイミュータブル
* 代数的データ型
* コンビネータ
* トレイト (型クラス)


## 安全かつ高速
--------------

* データ競合が起きない
  + 所有権システム
  + だいたいコンパイル時Read Writeロック
  + Read only参照複数 or Write可能参照1つ
* LLVMベースの強力な最適化
* スレッド周辺のAPIが揃ってる


## ゼロコスト抽象化
------------------
省略

* [Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/)


# Rustの誤解
-----------

* 安定してないって聞いたよ
* 函数型言語ってホント?
* GCがなくて大丈夫?
* 継承がなくて大丈夫?


## 安定してないって聞いたよ

* 1.0以前の話
* 1.0(2015-05以降)はAPIの変更がルール化された
* 新規APIのstablizeはあれどdeprecateはまれ


## 函数型言語ってホント?

* 函数型言語の機能をつまみぐいしてるだけ
* 標準ライブラリとかはバリバリ手続的
* Lispよりも函数型言語っぽくない。
* とはいえ抽象力は高いのでそこまで煩雑にはならない


## GCがなくて大丈夫?

* GCはなくてもメモリ管理は自動でする
* コンパイル時にメモリ管理
  + コンパイラが必要なところにmalloc/freeを挟むイメージ
* むしろメモリ以外(fd、ロックなど)も自動管理
  + GCがある言語よりリソース管理の自動化が徹底してる
* [リージョンについて | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/)


## 継承がなくて大丈夫?

* むしろ継承必要？インターフェースだけでよくない？
* Rustはデータ型とメソッドを分離するので継承のメリットそんなにない
  + トレイトが強力ともいう
* 逆にサブタイプ関係による複雑さの上昇のデメリットが多い
  + 3回以上継承してるの全部把握出来るの？
* ジェネリクスとかはあるよ


# Rustをとりまく環境
-------------------

* racer/rustfmt
* Cargo
* crates.io
* [Rust Playground](https://play.rust-lang.org/)
* The Rust Programming Language



# racer/rustfmt
---------------

* racerがコーディング支援ツール
  + 補完
  + 定義元ジャンプ
  + 型情報
  + 各種エディタプラグインあり
* rustfmtがコードフォーマッタ
  + エディタプラグインあり
  + ビルドツール連携あり


# Cargo
-------

* Rustのビルドツール兼パッケージマネージャ
* これだけ覚えとけば困らない


# crates.io
-----------

* Rustパッケージのセントラルレポジトリ
* 必ずビルドが通るような工夫
  + cargo yank
  + 同じライブラリの違うバージョンがいても大丈夫
* Cargoとの連携
* Cargoからpublishも可能


# [Rust Playground](https://play.rust-lang.org/)
---------------------------------------

* webからRustを試せる
* とりあえず試すと色々分かる
  + 所有権難しいとか


# [The Rust Programming Language](https://doc.rust-lang.org/book/)
------------------------------

* Rustの入門用ドキュメント
* とりあえずこれ読めば始められる
* [和訳版](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)もある
  + [GitHub](https://github.com/rust-lang-ja/the-rust-programming-language-ja)で作業中
  + これの宣伝しに来ただけ
* 1.6ほぼ終わり、1.7はまだ


# ライブラリ紹介
----------------
## MIO

* [mio](https://github.com/carllerche/mio)
* 低レベルな非同期IOライブラリ
  + libuvやlibev2相当
  + イベントスレッドではなくイベントループ
* これを純Rustで実装
* つまり(比較的)高水準なAPIで使える
* 色んなライブラリの下地になっている


# ライブラリ紹介
----------------
## diesel

* [diesel](https://github.com/sgrif/diesel)
* ORM &amp; クエリビルダ
  + mioとはうってかわって高水準なライブラリ
* `infer_schema!(dotenv!(&#34;DATABASE_URL&#34;));` でコンパイル時に
  + DBにアクセスしてスキーマ情報抜いて
  + コード生成
* モデルもCRUDでちゃんと使い分けている


# 所有権難しい
--------------
下記のコードは動かない。

``` rust
fn main(){
    let hello = &#34;Hello, &#34;.to_owned();
    let world = &#34;World!&#34;;
    let hello_world =  hello + world;
    println!(&#34;{}&#34;, hello);
    println!(&#34;{}&#34;, world);
    println!(&#34;{}&#34;, hello_world);
}

```



# まとめ
--------

* Rustはシステムプログラミング言語だよ
* 面白い機能いっぱいあるよ
* もう「安定待ち」じゃないよ
* Try it now!



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>リージョンとRustの返り値</title>
      <link>/blog/2016/03/02/ri_jontorustnokaerichi</link>
      <pubDate>Wed, 02 Mar 2016 00:05:03 +0900</pubDate>
      
      <guid>/blog/2016/03/02/ri_jontorustnokaerichi</guid>
      <description>&lt;p&gt;Rustにおいては返り値ポインタで返すよりもそのまま返して、受け取る側でポインタで受け取るかそのまま受け取るかを指定するのが良い選択肢だ、といっています。
しかし初めて見る時にはどうしてそんなことが出来るのかわからず、びっくりしますよね。
それをRustがリージョンを使ってメモリ管理をしていると分かればどうなっているのか分かったのですこしばかり。&lt;/p&gt;

&lt;p&gt;Rustにおいては以下のように関数が値を返す時にポインタを返すコードは好ましくなく、（というかコンパイル出来ない）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; &amp;amp;BigStruct {
    &amp;amp;BigStruct{ .... }
}

let bs = new_value();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数が返す値はスタックに載らないような大きな値でもそのまま返して、受け取り側でヒープに保存してあげるのが良いスタイルとされています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; BigStruct {
    BigStruct{ .... }
}

let bs = Box::new(new_value());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までの言語の感覚だとRustにおいて良いとされるスタイルは大きな値を一旦スタックに載せた後で&lt;code&gt;Box&lt;/code&gt;によって作られたヒープ領域に確保されているように見えます。&lt;/p&gt;

&lt;p&gt;これはリージョンについて理解すると動作が理解できます。&lt;/p&gt;

&lt;p&gt;リージョンについては以前のブログを参照して下さい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/&#34;&gt;リージョンについて | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、リージョンによるメモリ管理は「メモリを確保すべき場所」が先にあって、値はそこに置かれます。
特に、関数呼び出しにおいて、関数の「返り値を確保すべき場所」は関数の外から与えます。&lt;/p&gt;

&lt;p&gt;ここまで説明したらお分りかと思いますが、&lt;code&gt;Box::new(new_value());&lt;/code&gt;というコードは&lt;code&gt;new_value()&lt;/code&gt;の返り値を保存する場所としてヒープ領域を渡していて、
関数内部でそのヒープ領域にBigStructの値を書き込んでいるのです。&lt;/p&gt;

&lt;p&gt;もやもやしていたものがスッキリしたし返り値のサイズが決まってないと関数から返せないのも分かるようになった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustのゼロコスト抽象化</title>
      <link>/blog/2016/03/01/rustnozerokosutochuushouka</link>
      <pubDate>Tue, 01 Mar 2016 23:32:12 +0900</pubDate>
      
      <guid>/blog/2016/03/01/rustnozerokosutochuushouka</guid>
      <description>&lt;p&gt;κeenです。今日Twitter上でのやりとりから少し面白いことが分かったのでそれについて。&lt;/p&gt;

&lt;p&gt;最近1.0が出たKotlinについて、水島さんがツイートしてました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;nullableに対してはmapとかの高階関数を一切使えないのが痛い。 ?. でカバーできるケースは一部だけだ。zero-overhead null-safetyと唄っとるが、代わりにnullチェックお化けになるわけで、どこがzero-overheadだ &lt;a href=&#34;https://twitter.com/hashtag/kotlin_dis?src=hash&#34;&gt;#kotlin_dis&lt;/a&gt;&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704453235277324288&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;それについて私が無関係なツイートを。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;全く無関係だけどRustはOptionみたいな0-1の型をnull or valueに最適化するそうな。これこそがゼロコスト抽象かな &lt;a href=&#34;https://t.co/5Y7cBEyrMe&#34;&gt;https://t.co/5Y7cBEyrMe&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704453898996547584&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;これはRustのnomiconに書かれています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/repr-rust.html&#34;&gt;repr(Rust)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;そうすると水島さんからお返事が。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; Rust詳しくないですけど、Optionにmapとかした場合インライン展開されるんですかね？だとしたらとても理想的。&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704455185125408768&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;確かにそうなると面白そう。ということで少し調べてみました。&lt;/p&gt;

&lt;p&gt;まず、上記の話をまとめると、Rustの&lt;code&gt;Option&lt;/code&gt;に対する&lt;code&gt;map&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    match self {
        Some(x) =&amp;gt; Some(f(x)),
        None =&amp;gt; None,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;code&gt;x&lt;/code&gt;がポインタ型だった時に以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    if (self != nullPointer ) {
        f(x)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、&lt;a href=&#34;https://github.com/rust-lang/rust/blob/master/src/libcore/option.rs#L386&#34;&gt;&lt;code&gt;map&lt;/code&gt;はインライン宣言されている&lt;/a&gt;ので以下のコード&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  (|x| x + 1)(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、ここで無名関数がどうコンパイルされるかという問題が出てきますが、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャのドキュメント&lt;/a&gt;によるとこういう雰囲気のコードになるらしいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
struct AnonymousType;

impl FnOnce&amp;lt;(&amp;amp;i32)&amp;gt; for AnonymousType {
    type Output = i32;
    fn call_once(self, args: (&amp;amp;i32)) -&amp;gt; Self::Output {
        args + 1
    }
}

if (opt != nullPointer) {
    let fn_once: FnOnce = AnonymousType;
    fn_once.call_once(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思ったよりも複雑…。さて、問題は&lt;code&gt;let fn_once: FnOnce = AnonymousType;&lt;/code&gt;としているので一旦元の無名関数の情報が抜けてしまいそうな気がします。
となるとコンパイル時に具体的なメソッドを決定出来ないので&lt;code&gt;fn_once.call_once(opt);&lt;/code&gt;は以下のような雰囲気のコードになってしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回呼び出すべき関数の取得が入るのは面倒ですね。&lt;/p&gt;

&lt;p&gt;しかしなががらクロージャのドキュメントをよく読むと無名関数は静的ディスパッチされると書いてあります。つまり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と2段ではなく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;the_call_once_fn_of_AnonymousType(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイルされ、&lt;/p&gt;

&lt;p&gt;よって&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn the_call_once_fn_of_AnonymousType(x: &amp;amp;i32) -&amp;gt; i32 {
    x + 1
}


let opt = &amp;amp;v;
if (opt != nullPointer) {
  the_call_once_fn_of_AnonymousType(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と同値ということです。&lt;/p&gt;

&lt;p&gt;ここからは私の推測ですが、&lt;code&gt;the_call_once_fn_of_AnonymousType&lt;/code&gt;は本体が小さい上に1回しか呼ばれないのでインライン化されるのではないかと思います。
よってこの推測が正しければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  opt + 1
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる筈です。&lt;/p&gt;

&lt;p&gt;ゼロコスト抽象化すごい!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>テストについて考えてみた</title>
      <link>/blog/2016/03/01/tesutonitsuitekangaetemita</link>
      <pubDate>Tue, 01 Mar 2016 22:49:23 +0900</pubDate>
      
      <guid>/blog/2016/03/01/tesutonitsuitekangaetemita</guid>
      <description>

&lt;p&gt;κeenです。
普段はテストをあまり書かない人なのですが業務では流石に書く必要があって、馴れないことをしていると色々と考えることがあったのでまとめます。
まだ私はテストのセオリーとかには詳しくないので勝手気儘に考えたことです。&lt;/p&gt;

&lt;p&gt;2016-03-05 追記:
酷い誤りがあったので修正しました。s/ホーア理論/ホーア論理/。&lt;/p&gt;

&lt;p&gt;今まではテストは「とりあえずエッジケースとかをカバー出来てればいいんでしょ」くらいにしか考えてませんでした。
しかしオブジェクト指向をしていて他のオブジェクトの振舞いに依存するだとか関数の引数が複雑だとかの時には適切なケースを書くのが困難でした。&lt;/p&gt;

&lt;p&gt;チームの人とかとどう書くのが適切かと話しているとなんとなくまとまってきました。&lt;/p&gt;

&lt;h1 id=&#34;ホーア論理:a6610a259e229e09be210cb3df2778c4&#34;&gt;ホーア論理&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://proofcafe.org/sf/Hoare_J.html&#34;&gt;ホーア論理&lt;/a&gt;的にはソフトウェアの振舞/性質を表すのには3つの要素が必要です。事前条件、操作、事後条件です。&lt;/p&gt;

&lt;p&gt;「事前条件Pが満たされるときに操作Oを行い、それが停止するならば事後条件Qが満たされる」&lt;/p&gt;

&lt;p&gt;エンジニアリング的には以下のように読み替えられます。&lt;/p&gt;

&lt;p&gt;事前条件とは、メソッドを実行するまでのお善立て。引数を用意する、依存するオブジェクトのモックを用意する、などなど。
操作が実際のメソッドの実行。
事後条件こそがassertなどを使ったテストケース群です。&lt;/p&gt;

&lt;h1 id=&#34;テストフレームワークとホーア論理:a6610a259e229e09be210cb3df2778c4&#34;&gt;テストフレームワークとホーア論理&lt;/h1&gt;

&lt;p&gt;テストを書く時にもこの考え方は役に立つな、と思いました。事前条件 x 操作 x 事後条件を網羅していけばいい訳です。&lt;/p&gt;

&lt;p&gt;ところで、テストフレームワークにはテストをグルーピングしたりといくつかのスコープをネスト出来る機能を持っているものもあります。
ホーア論理では要素が3つある訳ですから3段にネストするのが適切な気がするのは納得いくと思います。しかしどの順番でネストするかは議論の余地がありそうです。&lt;/p&gt;

&lt;p&gt;勿論、ホーア論理に従うなら操作の時系列的に事前条件&amp;gt;操作&amp;gt;事後条件のネストの仕方が一番自然かと思います。
しかしテストしたい主役は振舞、メソッドなのでそれを階層の最上位に持ってくる方が可読性、ひいてはテストの意味が高まりそうです。&lt;/p&gt;

&lt;p&gt;あるいは、4段にネストして最上位にだたのグルーピング目的にメソッドを、そしてその下に事前条件&amp;gt;操作&amp;gt;事後条件を持っていく手法もありそうです。
しかしこれだとネストが深すぎますね。また、後述するように操作の子階層を作ると例外がどこ由来なのか分かりづらいという問題もあります。&lt;/p&gt;

&lt;p&gt;これの改良版は最上位にだたのグルーピング目的にメソッドを、そして事前条件&amp;gt;(操作+事後条件)という形のネストの仕方をする方法です。
これは例外の出所を明確に出来る他、多くのテストフレームワークで操作に対する表明と事後条件に対する表明を区別しない問題もクリア出来るという利点があります。
1つある欠点は、操作と事後条件のスコープが分かれているので操作の返り値に対して事後条件で表明したい時にどうにかしてスコープの外に出してやる必要がある点です。
副作用を容易に許す言語なら外のスコープの変数に代入すればいいだけですが、純粋な言語だと簡単ではありません。
そういう意味でも操作に対する表明と事後条件に対する表明は分けたいなと思う次第。&lt;/p&gt;

&lt;h1 id=&#34;操作に対する表明:a6610a259e229e09be210cb3df2778c4&#34;&gt;操作に対する表明&lt;/h1&gt;

&lt;p&gt;本来のホーア論理的には事後条件で表明すれば十分ですが、実際には不十分な点があります。もう一度ホーア論理の表明について思い出しましょう。&lt;/p&gt;

&lt;p&gt;「事前条件pが満たされるときに操作oを行い、 &lt;strong&gt;それが停止するならば&lt;/strong&gt; 事後条件qが満たされる」&lt;/p&gt;

&lt;p&gt;現実的に、関数が正しく停止することも保証したいです。「無限ループを書く方が悪い」という訳ではありません。関数が停止しないのは何も無限ループだけでなく、例外などで脱出した場合も含みます。&lt;/p&gt;

&lt;p&gt;なので例外を出す/出さないの表明も欲しくなる訳です。
もう少し踏み込んで考えると、多くのテストフレームワークでassertと例外の送出の有無を同列扱いますが、前者は事後条件に対する表明、後者は操作に対する表明なので本来は分かれるべきです。&lt;/p&gt;

&lt;p&gt;また、操作に対する表明はスコープを作るとしても操作の返り値を返す手段を用意してくれると事後条件の表明がやりやすくなるな、と思いました。まる。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:a6610a259e229e09be210cb3df2778c4&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;テストをする時には3つの要素に分けて考えると考えやすくなります。その3つとは事前条件、操作、事後条件で、それぞれの組み合わせがあるのでテストケースのネストは合理的です。
しかしながら人間の認識のためにネストの順番は入れ替えた方がよいのですが、そうするとコード上いくつか問題が発生します。&lt;/p&gt;

&lt;p&gt;グルーピング目的にメソッドを、そして事前条件&amp;gt;(操作+事後条件)というネストの仕方が最終案に思えますが、それを的確に表現出来、かつコード上の問題をクリア出来るテストフレームワークが中々ないのが現状です。&lt;/p&gt;

&lt;h1 id=&#34;付録a:a6610a259e229e09be210cb3df2778c4&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;考えがまとまるまでの過程&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;テスト書いててなぜテストライブラリがテストスートを階層構造にしてるのか考えたけど1つの事前条件に対して複数の操作が考えれてそれぞれの操作に対して保証したい不変条件と事後条件があるから少なくとも3段にネストしないと上手くグルーピング出来ないのかな。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704586009464311808&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;しかしネストする順番はどうだろう。メソッドに対するテストでグルーピングしたいからメソッド&amp;gt;事前条件&amp;gt;事後/不変条件になるのかな。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704586479427670016&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;事前条件を最上位に持ってきた方が理解しやすいし事前条件の使い回しもしやすいけど並行にテストを走らせようと思ったらやっぱり操作毎に事前条件用意してあげた方がいいし事前条件と事後条件が近い方が性質を理解しやすい?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704587239402008576&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;あれ?もしかして操作ってメソッドじゃなくてメソッド+引数になる?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704588326175551488&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うーん。操作を行うパートと条件の準備/確認のパートを分けたいんだけど難しい。例えば操作によって例外が出ることを確認したいとかが非常にやりづらい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704601381605232640&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;いや?やっぱり操作と事後/不変条件のパートは分けれるな?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704602157148872704&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そしてやはり操作をネストのトップレベルにもってくると操作の引数とかが事前条件/前提条件に依存するのでやりづらい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704602629737811968&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RustのHigher-Kinded type Trait</title>
      <link>/blog/2016/02/28/rustnohigherkinded_type_trait</link>
      <pubDate>Sun, 28 Feb 2016 14:40:59 +0900</pubDate>
      
      <guid>/blog/2016/02/28/rustnohigherkinded_type_trait</guid>
      <description>

&lt;p&gt;κeenです。少し前の話になりますがRustの関連型を駆使してHigher Kinded type Trait（高階型トレイト）を実現してしまったものが出回ってたのでそれについて。
本来RustはHKTをサポートしていませんが不思議なことに実装出来てしまっているのです。&lt;/p&gt;

&lt;p&gt;HKTについて微塵も知らない方にも分かるように解説していきます。&lt;/p&gt;

&lt;h1 id=&#34;map-可能なトレイト:b27135531fb7377c493eecfb210d7b92&#34;&gt;&lt;code&gt;map&lt;/code&gt; 可能なトレイト&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/core/option/enum.Option.html#method.map&#34;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;https://doc.rust-lang.org/core/result/enum.Result.html#method.map&#34;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;、etc 色々なトレイトが &lt;code&gt;map&lt;/code&gt; メソッドを実装しています。&lt;/p&gt;

&lt;p&gt;それぞれ型シグネチャを抜き出してみましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Option: &lt;code&gt;map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Result: &lt;code&gt;map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, op: F) -&amp;gt; Result&amp;lt;U, E&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;驚く程似てますね。これを抽象化して「&lt;code&gt;map&lt;/code&gt;メソッドを持つ」トレイトを定義したくなるかもしれません。
しかしそれは簡単には書けません。何故なら&lt;code&gt;map&lt;/code&gt;はコンテナ型、つまり「型引数を取る型」に定義される型だからです。
現在のRustは「型引数を取る型」に対するジェネリクスはサポートしていません。もし書こうとするとこのようになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;M&amp;lt;_&amp;gt;, T&amp;gt; where Self: M&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; M&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt; なんて型パラメータを書くことは出来ませんし&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;も無理があります。残念ですね。&lt;/p&gt;

&lt;h1 id=&#34;iterator-との違い:b27135531fb7377c493eecfb210d7b92&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt; との違い&lt;/h1&gt;

&lt;p&gt;さて、&lt;code&gt;Iterator&lt;/code&gt;にも&lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;はあります。
これこそが求めている「&lt;code&gt;.map&lt;/code&gt; 可能なトレイト」ではないのでしょうか。
これはおおよそは合っているのですがやや期待とは違う動作をします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt;の&lt;code&gt;map&lt;/code&gt;は不自由なく使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let o = Some(1);
let o = o.map(|i| i + 1);
println!(&amp;quot;{:?}&amp;quot;, o);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一方、&lt;code&gt;Vec&lt;/code&gt;は全く同じような書き方は出来ません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = vec![1];
let v = v.map(|i| i + 1);
println!(&amp;quot;{:?}&amp;quot;, v);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;anon&amp;gt;:3:11: 3:25 error: no method named `map` found for type `collections::vec::Vec&amp;lt;_&amp;gt;` in the current scope
&amp;lt;anon&amp;gt;:3 let v = v.map(|i| i + 1);
                   ^~~~~~~~~~~~~~
&amp;lt;anon&amp;gt;:3:11: 3:25 note: the method `map` exists but the following trait bounds were not satisfied: `collections::vec::Vec&amp;lt;_&amp;gt; : core::iter::Iterator`, `[_] : core::iter::Iterator`
error: aborting due to previous error
playpen: application terminated with error code 101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正しくは、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = vec![1];
let v: Vec&amp;lt;i32&amp;gt; = v.iter().map(|i| i + 1).collect();
println!(&amp;quot;{:?}&amp;quot;, v);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;色々実装上のノイズが乗っているのでやや例として不適切だったかもしれませんが、注目して欲しい部分はここです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v: Vec&amp;lt;i32&amp;gt; = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt;から取り出したイテレータなのに&lt;code&gt;Vec&lt;/code&gt;に戻すためにわざわざ型アノテーションを書く必要があります。&lt;/p&gt;

&lt;p&gt;どうしてこうなるかというとイテレータを取り出した時点で元のコンテナ型が&lt;code&gt;Vec&amp;lt;&amp;gt;&lt;/code&gt;であるという情報が失われているからです。
これはRustの型システム上どうしても仕方のないことで、なので恐らくRustは「&lt;code&gt;map&lt;/code&gt;可能なトレイト」などを定義せず、コレクションの操作を&lt;code&gt;Iterator&lt;/code&gt;に集約しているんだと思います。
この方式はある程度は上手くいきますが&lt;code&gt;Option&lt;/code&gt;や&lt;code&gt;Result&lt;/code&gt;はIteratorになれはしてもIteratorからは作れない(2要素のイテレータからOptionは作れない)ので独自でmapメソッドを持つことになってしまいます。&lt;/p&gt;

&lt;h1 id=&#34;map-可能なトレイト-again:b27135531fb7377c493eecfb210d7b92&#34;&gt;&lt;code&gt;map&lt;/code&gt; 可能なトレイト again&lt;/h1&gt;

&lt;p&gt;先程そういうのは作れないと言ったばかりですが実はどうにかする方法がなくもないです。先程の(仮想の)定義を思い出して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;M&amp;lt;_&amp;gt;, T&amp;gt; where Self: M&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; M&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジェネリクスになっている登場人物は&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;、&lt;code&gt;U&lt;/code&gt;、&lt;code&gt;T&lt;/code&gt; ですね。しかし&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;は実際にはそのまま使われいる訳ではなく&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;または&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;の形でのみ使われています。
では、&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;をパラメータに取るようにしてはどうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;T, MT&amp;gt; where Self: MT {
  fn map&amp;lt;U, MU, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで出来…てません。これは欲しい、正しいもの &lt;em&gt;も&lt;/em&gt; 作れてはいるのですが正しくないものも含んでいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;T, MT: Option&amp;lt;T&amp;gt; Mappable&amp;lt;MT, T&amp;gt;  for Option&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, MU, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU {...}
}

let r: Result&amp;lt;String, ()&amp;gt; = Some(1).map(|i| i.to_string());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt; に対する&lt;code&gt;map&lt;/code&gt;を&lt;code&gt;Result&lt;/code&gt;で受けようとしています。
これはもちろんおかしなことですが上記の型定義に従うとこういうことが出来てしまいます。
もうちょっというと上のトレイトの定義はこういう「おかしなこと」が起こるような実装をしろ、と言っている訳で、実際には実装出来ません。&lt;/p&gt;

&lt;p&gt;本来なら自由パラメータが3つなのに4つの自由パラメータを取ってしまったので不整合が起きる訳です。
では、自由パラメータを3つにして1つを従属パラメータにしてはどうでしょうか。それは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;を使えばRustでも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;T, U, MT&amp;gt; where Self: MT {
  type MU;
  fn map&amp;lt;F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これである程度上手くいきます。
もちろん、実際に&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;を取れるのに比べると不自由で下手をするとバグる(MUを無関係な型に定義できてしまう)可能性があるのですが、先程の4パラメータの時と比べて
トレイトが定義された時点で返す型は決まっているのでちゃんと実装出来ますし、使う時に不整合が起きることもありません。&lt;/p&gt;

&lt;h1 id=&#34;hkt:b27135531fb7377c493eecfb210d7b92&#34;&gt;HKT&lt;/h1&gt;

&lt;p&gt;さて、先の&lt;code&gt;Mappable&lt;/code&gt;の仮想定義、&lt;code&gt;map&lt;/code&gt;関数を除いて汎用的にするとこうなりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U, MT&amp;gt; where Self: MT {
  type MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Self: MT&lt;/code&gt; というアノテーションをつけてますが実際には使えません。&lt;code&gt;impl&lt;/code&gt;を書くときに気をつけて実装するしかないです。なのでこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U&amp;gt; {
  type MU;
}

impl &amp;lt;T, U&amp;gt; HKT&amp;lt;T, U&amp;gt; for Option&amp;lt;T&amp;gt; {
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、こう書くとするとこういうことも出来てしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U&amp;gt; {
  type MU;
}

impl &amp;lt;S, T, U&amp;gt; HKT&amp;lt;T, U&amp;gt; for Option&amp;lt;S&amp;gt; {
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;T&lt;/code&gt;とは独立な&lt;code&gt;S&lt;/code&gt;に対するコンテナに対して実装できてしまうのです。「実装するときに気をつける」とはいいましたが制約を書けるなら書いた方がいいです。こうしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;U&amp;gt; {
  type T;
  type MU;
}

impl &amp;lt;T, U&amp;gt; HKT&amp;lt;U&amp;gt; for Option&amp;lt;T&amp;gt; {
  type T = T;
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで冒頭に紹介したHKTの実装になりました。&lt;/p&gt;

&lt;p&gt;逆にこのHKTの実装からMappableを定義するには、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;U&amp;gt;: HKT&amp;lt;U&amp;gt; {
  fn map&amp;lt;F: FunOnce(Self::T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Self::MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hktについてもっと:b27135531fb7377c493eecfb210d7b92&#34;&gt;HKTについてもっと&lt;/h1&gt;

&lt;p&gt;ようやく話題のHKTの元実装です。こちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/14427/af90a21b917d2892eace&#34;&gt;Higher-kinded type trait&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ずいぶんとモナモナしいですがやはり高階型を使った一番実績のある構造はこのあたりでしょう。&lt;/p&gt;

&lt;p&gt;こういうのを扱えるとプログラミングの幅が広がりますね。&lt;/p&gt;

&lt;h1 id=&#34;ノート:b27135531fb7377c493eecfb210d7b92&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;モナドの話題が出ましたがRustでモナドを実現するには高階型だけでなく複数ある関数トレイトのどれを選ぶかだとかその他諸々の問題を扱う必要があるようです。
&lt;a href=&#34;https://m4rw3r.github.io/rust-and-monad-trait/&#34;&gt;Rust and the Monad trait - Not just higher kinded types · m4rw3r&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>druidというリアルタイムデータ分析ツールを知った</title>
      <link>/blog/2016/02/27/druidtoiuriarutaimude_tabunsekitsu_ruwoshitta</link>
      <pubDate>Sat, 27 Feb 2016 21:28:16 +0900</pubDate>
      
      <guid>/blog/2016/02/27/druidtoiuriarutaimude_tabunsekitsu_ruwoshitta</guid>
      <description>&lt;p&gt;κeenです。社内ハッカソンに出てきた。そこでdruidというツール（？）を触ったのでそれについて。&lt;/p&gt;

&lt;p&gt;読み方は「ドゥルイド」でいいのかな？公式ページは&lt;a href=&#34;http://druid.io/&#34;&gt;こちら&lt;/a&gt;。&lt;a href=&#34;https://metamarkets.com/&#34;&gt;Metamarkets&lt;/a&gt;が主導で開発しているようで、&lt;a href=&#34;https://github.com/druid-io/druid&#34;&gt;オープンソースになっている&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;公式サイトを少し回遊してもらうと分かると思うが、時系列データを分散環境でストリーミング処理出来るツール。分散環境で動くだけあってコンポーネントはいくつかある。&lt;/p&gt;

&lt;p&gt;主にはストリーミングデータを取り込む「REALTIME」、クライアントからのクエリを処理する「BROKER」、過去のデータを処理する「HISTORICAL」があるようだ。
BROKERがDEEP STORAGE(s3などの永続データストア)にデータを保存し、HISTORICALがオンデマンドにそのデータを読み出してBROKERに返す。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://druid.io/docs/img/druid-dataflow-3.png&#34; alt=&#34;design of druid&#34; /&gt;&lt;/p&gt;

&lt;p&gt;イメージとしてはこんな感じだが、実際に動かすのには他のコンポーネントも必要で、分散環境に必須なZookeeperが必要なのはもちろんのこと、全体を司る「COORDINATOR」、取り込んだデータのメタデータを保存する「METADATA STORAGE」も必要になる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://druid.io/docs/img/druid-manage-1.png&#34; alt=&#34;detailed design of druid&#34; /&gt;&lt;/p&gt;

&lt;p&gt;画像の出展は&lt;a href=&#34;http://druid.io/docs/0.8.3/design/design.html&#34;&gt;こちら&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;中々に大仰なアーキテクチャだがどのみちリアルタイムデータ分析基盤を作ろうと思うとこれくらい必要になる。それを1まとめにしてディストリビュートしてくれるdruidを使った方がなんぼか近道な気はする。&lt;/p&gt;

&lt;p&gt;さて、これを1インスタンスで動かそうと思うと、DEEP STORAGEはローカルファイルシステム、METADATA STORAGEは組込みのDerby DBでまかなえ、REALTIMEはデータを取り込む時にのみ必要なのでZookeeper、Coordinator、Broker、Historical、都合4つのJava製ミドルウェアを起動すればどうにか使える。
これら合わせても2GBくらいのメモリしか必要なかったので十分手元で動く。&lt;/p&gt;

&lt;p&gt;さて、このDruid、どういうことが出来るかというとクエリに注目すれば「Group By付きのAggrigation Functionを高速に動かす」が主な目的だろうか。&lt;a href=&#34;http://druid.io/docs/0.8.3/querying/querying.html&#34;&gt;他にも色々ある&lt;/a&gt;が。
BIツールや他のダッシュボードツールなんかと連携してストリーミングデータをリアルタイムに可視化するのに一役買う。YahooやAlibabaなんかでも&lt;a href=&#34;http://druid.io/community/&#34;&gt;使われているようだ&lt;/a&gt;。
例えばDruidをサポートするダッシュボードツール、&lt;a href=&#34;https://github.com/mistercrunch/panoramix&#34;&gt;panoramix&lt;/a&gt;なんかもある。&lt;/p&gt;

&lt;p&gt;今回のハッカソンはGCPがテーマで、Cloud Pub/Subからデータを取り込むことになったがDruidにはPub/Subからデータを取り込むREALTIMEがない。ということでハッカソンで&lt;a href=&#34;https://github.com/KeenS/druid/tree/pubsub-extension/extensions/cloud-pubsub&#34;&gt;Pub/Sub extensionを作った&lt;/a&gt;。
メーリスに投稿して様子を覘った上でコードを整理してプルリクを出す予定だ。
拡張は思ったよりも作りやすく、ドキュメントを読まなくても既存のKafka拡張を参考にするだけで書けた。まあ、その後苦労したが。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;はじめて使うDBのプラグイン書いたらデータのロードは出来たもののクエリの投げ方が分からずに入ったデータを確認出来ない…っ…&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/703202304913051648&#34;&gt;2016年2月26日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;今回作ったのはFirehose Pluginと呼ばれるものだが、他にもプラグインの種類は&lt;a href=&#34;http://druid.io/docs/0.8.3/development/modules.html&#34;&gt;色々ある&lt;/a&gt;みたいだ。
しかしFirehose Pluginの基底クラスはあまりストリーミングデータのインポートには良くない気がする。FirehoseV2というのがあって、それが良いインターフェースになっていたが使い方が分からなかった。&lt;/p&gt;

&lt;p&gt;今が0.9.0-SNAPSHOT。1.0.0が出る頃が楽しみだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bind Addressの意味がようやく分かった</title>
      <link>/blog/2016/02/24/bind_addressnoimigayouyakuwakatta</link>
      <pubDate>Wed, 24 Feb 2016 23:57:31 +0900</pubDate>
      
      <guid>/blog/2016/02/24/bind_addressnoimigayouyakuwakatta</guid>
      <description>

&lt;p&gt;κeenです。小ネタを。サーバを立ち上げる時に指定するBind Addressについてよく分かっていなかったのがようやく分かるようになったのでそれについて。&lt;/p&gt;

&lt;p&gt;Bind Addressはサーバ(特にHTTPサーバ)を立ち上げる時によく指定することになりますが、Usageを見ても「バインドするアドレスを指定する」などとトートジーめいたことしか書いてありませんでした。
実際に使ってみても127.0.0.1を指定すればローカルホストから、0.0.0.0を指定すれば外部からでも参照出来るな、くらいの認識しかありませんでした。
意味も分からず使っていると気持ち悪いもので、2つの疑問が湧いてきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0.0.0.0と127.0.0.1は正確に何を意味するのか&lt;/li&gt;
&lt;li&gt;127.0.0.1と0.0.0.0以外のアドレスを指定するのはどのようなケースか&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もちろん、127.0.0.1がlocalhostを指すことは知っていますが0.0.0.0というアドレスはBind Addressでしか見たことありませんし、127.0.0.1が私の知っているlocalhostの意味でない可能性も十分あるな、と思っていました。&lt;/p&gt;

&lt;p&gt;さて、この疑問に答えるには前提知識が必要なのでそこから始めましょう。&lt;/p&gt;

&lt;h1 id=&#34;マシンは複数のipアドレスを持ちうる:a96f766a18fe92e465482ea79d6a2ec6&#34;&gt;マシンは複数のIPアドレスを持ちうる&lt;/h1&gt;

&lt;p&gt;1つのマシンに、複数のIPアドレスが割り当てられることがあります。
典型的なのはルータのようにインターネットとローカルエリアネットワーク両方に参加しているもので、LANには「192.168.1.1」、インターネットには「www.xxx.yyy.zz」という2つのIPアドレスを持つでしょう。
また、どのマシンにも先程述べたlocalhost、127.0.0.1という内部から自身を指すIPアドレスもあります。
図にするとこんな感じでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [インターネット]
       |
       |
       | www.xxx.yyy.zz
[x 127.0.0.1] ルータ
       | 192.168.1.1
       |
   ...-+--+
          | 192.168.1.2
         [ 127.0.0.1]マシンA

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この時に例えばルータの管理WebUIを提供したいとしましょう。このUIは勿論LAN内にいるマシンAからは参照したいですがインターネット全てに公開する訳にはいきません。
こういう時のアクセス制御に使うのがBind Addressです。&lt;/p&gt;

&lt;h1 id=&#34;呼ばれ方で反応を変える:a96f766a18fe92e465482ea79d6a2ec6&#34;&gt;呼ばれ方で反応を変える&lt;/h1&gt;

&lt;p&gt;bind addressは、他のマシンから何という名前で呼ばれたかでメッセージを受け取る/受け取らない（というか見える見えない）を変えるものです。
街中で「田中さん」と呼ばれたら返事したいけど「†漆黒の天翅†さん」と呼ばれたら返事したくないですよね。
少し実験してみましょう。&lt;/p&gt;

&lt;p&gt;さて、私の手元のマシンはifconfigによると127.0.0.1というアドレスと192.168.1.6というアドレスを持っているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ifconfig
lo        Link encap:ローカルループバック  
          inetアドレス:127.0.0.1  マスク:255.0.0.0
          inet6アドレス: ::1/128 範囲:ホスト
          UP LOOPBACK RUNNING  MTU:65536  メトリック:1
          RXパケット:5132 エラー:0 損失:0 オーバラン:0 フレーム:0
          TXパケット:5132 エラー:0 損失:0 オーバラン:0 キャリア:0
          衝突(Collisions):0 TXキュー長:0 
          RXバイト:665331 (665.3 KB)  TXバイト:665331 (665.3 KB)
wlp3s0    Link encap:イーサネット  ハードウェアアドレス cc:3d:82:38:21:e2  
          inetアドレス:192.168.1.6  ブロードキャスト:192.168.1.255  マスク:255.255.255.0
          inet6アドレス: fe80::ce3d:82ff:fe38:21e2/64 範囲:リンク
          UP BROADCAST RUNNING MULTICAST  MTU:1500  メトリック:1
          RXパケット:85578 エラー:0 損失:0 オーバラン:0 フレーム:0
          TXパケット:64002 エラー:0 損失:0 オーバラン:0 キャリア:0
          衝突(Collisions):0 TXキュー長:1000 
          RXバイト:85393847 (85.3 MB)  TXバイト:10710856 (10.7 MB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTPサーバをそれぞれにbindしてみます。今回使うのはRubyのコマンドラインから使えるHTTPサーバです。&lt;/p&gt;

&lt;p&gt;まずは127.0.0.1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -run -e httpd -- ./ --port 8080 --bind 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じですかね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------+
|       |
|     +-+ 127.0.0.1
|ruby-+ |
|       + 192.168.1.6
+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、これにcurlでアクセスしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl 127.0.0.1:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 192.168.1.6:8080
curl: (7) Failed to connect to 192.168.1.6 port 8080: 接続を拒否されました
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に192.168.1.6を試します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -run -e httpd -- ./ --port 8080 --bind 192.168.1.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもこんな感じですかね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------+
|       |
|       + 127.0.0.1
|ruby-+ |
|     +-+ 192.168.1.6
+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じくcurlでアクセスしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl 127.0.0.1:8080
curl: (7) Failed to connect to 127.0.0.1 port 8080: 接続を拒否されました
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 192.168.1.6:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見事にbindしたアドレスに投げた時にしか結果が返ってきません。
また、無関係なアドレス、例えば192.168.1.2などにbindしようとするとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -run -e httpd -- ./ --port 8080 --bind 192.168.1.2
[2016-02-25 00:36:17] INFO  WEBrick 1.3.1
[2016-02-25 00:36:17] INFO  ruby 2.1.5 (2014-11-13) [x86_64-linux-gnu]
/usr/lib/ruby/2.1.0/socket.rb:206:in `bind&#39;: Cannot assign requested address - bind(2) for 192.168.1.2:3000 (Errno::EADDRNOTAVAIL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら正確に自分のアドレスでないとbind出来ないようです。&lt;/p&gt;

&lt;h1 id=&#34;0-0-0-0はワイルドカード:a96f766a18fe92e465482ea79d6a2ec6&#34;&gt;0.0.0.0はワイルドカード&lt;/h1&gt;

&lt;p&gt;さて、これで正確に何という名前で呼ばれたかでアクセスを制御出来るようになりました。しかし公開サーバのように「どこからでも」アクセスさせたい場合にこと細かく指定させるのは不便です（というか複数のネットワークから参照することが出来なくなる？）。
その「どこからでも」を表すのが0.0.0.0です。&lt;/p&gt;

&lt;p&gt;試してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -run -e httpd -- ./ --port 8080 --bind 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうなっているのでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------+
|       |
|     +-+ 127.0.0.1
|ruby-+ |
|     +-+ 192.168.1.6
+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 127.0.0.1:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 192.168.1.6:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 0.0.0.0:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにどのような指定方法でも返ってきます。
curl 0.0.0.0:3000で結果が返ってきた(0.0.0.0が自身を指す)ことに驚きましたがワイルドカードアドレスにbindされた時にだけ結果が返ってきて欲しい時に便利なんですかね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:a96f766a18fe92e465482ea79d6a2ec6&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Bind Addressは本当にBindするAddressでした。足りないのはBind Addressに対する知識ではなくネットワークに対する知識でした。
世の中知らないといけないことが多い。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでSSPを作った話</title>
      <link>/slide/ClojuredeSSPwotsukuttahanashi/</link>
      <pubDate>Mon, 22 Feb 2016 20:19:11 +0900</pubDate>
      
      <guid>/slide/ClojuredeSSPwotsukuttahanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClojureでSSPを作った話
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# SSPとは
-------
※今回作ったものの話なので実際は少し違う

* Supplier Side Platform
* メディアからの広告リクエストを受けて表示権をオークションに掛け、落札された広告を表示する
  0. 広告リクエストを受け取って
  1. 各DSPに競りの通知を投げて
  2. 入札を受け取って
  3. 落札者と落札価格を決めて
  4. 落札通知を出す


# アドテクコンペ
---------------

* [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380)
* サイバーエージェントの学生向けインターン
* 3日間、3、4人のチームで **DSP** を作る
* 学生は7チーム、1チームあたり2000q/sを捌くことになってる
* 学生のDSPを繋ぐための **SSP** が必要になったので作ることに。


&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/92I5tQt6q6IjII&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/prir/ss-35918532&#34; title=&#34;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&#34; target=&#34;_blank&#34;&gt;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/prir&#34; target=&#34;_blank&#34;&gt;CyberAgent, Inc.&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;


# 作るもの
----------

* 各DSPに競りの通知(HTTPリクエスト)を投げる大規模HTTPクライアント
  + 各DSPが2000q/s x 7チーム + 落札通知 = 16000q/s
  + 丁度2000q/sになるような制御も必要
* 入札を受けてのオークション、結果のロギングなど
* 管理画面


# s7pについて
-------------

* 今回作ったSSP
* [KeenS/s7p](https://github.com/KeenS/s7p)
* Clojure製
* 3日くらいで作った
* やや粗い部分も


# 今日話すこと
--------------

* なぜClojureか
* 16000q/s出すための工夫
* 16000q/sに抑えるための制御
* 運用して困った話とか



# なぜClojureか

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# なぜClojureか
---------------

* リクエストの数が多いので非同期IOは必須
* 100msでタイムアウトする仕様なのでタイムアウト処理も
* もともとはScala(akka)で作ったs6pがあった
* Actorの設計が良くなかったので遅かった
* あと非同期HTTPクライアントにタイムアウトがなかった
* プロダクションコードを流用したのでインターンが終わった後公開出来なかった
* 別言語で書き直すにあたってGo, Clojure, Common Lisp, Rust, Erlangが検討された

# なぜClojureか
---------------

* Common Lisp: 一番慣れてるが、非同期HTTPクライアント(とfutureライブラリ)が使いづらそうなのでやめた
* Rust: とりあえずパフォーマンスは出そうだし使いたかったが非同期HTTPクライアントが見付からなかった
* Clojure: そこそこ慣れてるし速そうな非同期HTTPクライアントがあった。core.asyncで非同期プログラミングもし易い
* Erlang: 恐らく一番向いてるが、ほとんど経験がない
* Go: 結構向いてそうだがあまり経験がないのでClojureを選んだ


# 16kq/s出すための工夫
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 16kq/s出すための工夫
------------------------
非同期IO（一部同期しちゃったけど）

``` clojure
(defn work [test req result]
  (-&gt;&gt; @dsps
       (sequence (comp
       ;; 全DSPにPOSTしてから(timeout 100ms)
                  (map (fn [dsp] {:dsp dsp :response (http/post (:url dsp) (json-request-option req))}))
       ;; 結果を待ち合わせる
                  (map destruct)
                  ...))
       ...))
    ....
```


# 16kq/s出すための工夫2
------------------------
一部同期したのでとにかくスレッド。スレッドへのディスパッチはチャネルで一発解決。

``` clojure
(defn worker [c]
  (thread
   ...))
```

```clojure
(defn make-workers [ch n]
  (doall (map (fn [_] (core/worker ch)) (range n))))
```

``` clojure
 workers (manage/make-workers ch 1024)
```


# 16kq/s出すための工夫3
------------------------
ZeroMQを使ったmaster-slave構成
(最終的にSlave18台)

![master-slave構成図](/images/s7p/s7p.svg)



# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------

* DSPの買い付け能力というビジネス的な問題ではなくサーバの負荷という技術的な問題による制御
* 1秒で160kクエリ投げて9秒休むとかは出来ない。もう少し細かく制御する必要がある。
* しかし制御をあまり細かくしすぎると今度はそこで遅くなりそう。
* リクエストを実際に投げるSlaveは分散してるけど統一した制御が必要


# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------
Master側で100ms毎にに200個だけZeroMQのキューに積む

![QPS制御の図](/images/s7p/qps_control.svg)


# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------
実装にはcore.asyncの `chan` と `timeout` を使用。(非同期プログラミング便利!)

```Clojure
(defn start-query [sender reqs]
  (let [timer (timer 100)]
    (go-loop []
      (let [t (&lt;! timer)
            took (take @qp100ms @reqs)]
        (doall
         (doseq [req took]
           (zmq/send-str sender (json/generate-string req))))
        (swap! reqs #(drop @qp100ms %))
        (if (and t (not (empty? took)))
          (recur)
          (println &#34;request done&#34;))))
    timer))
```


# 運用して困った話とか
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 50%&#34;&gt;レスポンスが遅いDSPにSSPのパフォーマンスが引き摺られる&lt;/span&gt;
* DSPが速ければ余裕を見ても10台あれば十分だった
* DSPのパフォーマンスに仮定をおけないので上限ギリギリの18台
* 同期: 「DSP作ってる時はちょっとくらい待ってくれよ、って思ってたけどSSP運用したら遅いDSPガンガン切りたくなる気持分かった」

# 運用して困った話とか
---------------------
## パフォーマンス検証が大変
* リクエストを捌くサーバのパフォーマンスをどうするか悩む
* サーバをチューニングすればSSPも速くなるが、検証にならない
* かといって投げたクエリを捌けないサーバに対して検証する訳にもいかない
* 結局安全側に倒したパフォーマンス見積りに。


# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 80%&#34;&gt;Masterがログ吐きすぎてDisk Full&lt;/span&gt;
* 最初の予定ではMasterはディスクをそんなに使わなかったのでディスクの小さいインスタンスだった
* ディスクスペース空けてMaster再起動で復旧。焦った。

# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 60%&#34;&gt;timeoutし続けるDSPがいてSlave完全沈黙&lt;/span&gt;
* コネクションのクローズ待ちで固まってた
* 該当DSPを切った上でSlaveの再起動で復旧
  * カーネルのチューニングかtimeout頻度の検知が必要そう
* timeoutを考慮に入れた構成にしてた筈なので想定外だった

# まとめ
---------

* ClojureでSSP作ったよ
* Clojure使えば非同期プログラミングが簡単に出来るよ
* 運用って大変だよ


# 参考
-------

* [KeenS/s7p: sexp version of s6p; a toy SSP.](https://github.com/KeenS/s7p)
* [ClojureでDSPを作った話 | κeenのHappy Hacκing Blog](http://keens.github.io/slide/ClojuredeDSPwotsukuttahanashi/)
* [KeenS/b11d: A toy DSP](https://github.com/KeenS/b11d)
* [アドテクコンペ | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/recruit/fresh/program_detail/id=11303&amp;season=2016)
* [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>readlineの作り方</title>
      <link>/blog/2016/02/14/readlinenotsukurikata</link>
      <pubDate>Sun, 14 Feb 2016 22:37:35 +0900</pubDate>
      
      <guid>/blog/2016/02/14/readlinenotsukurikata</guid>
      <description>

&lt;p&gt;κeenです。なんか伏線っぽいもの回収しといた方が良いかなと思ってLinuxっぽい話でも。&lt;/p&gt;

&lt;p&gt;readlineって便利ですよね。
でもCで書かれているから他の言語から使おうと思うと面倒だったり使えなかったりGPLv3の所為で使えなかったりしますよね。
そこである程度POSIXのインターフェースを扱わせてくれる言語でのreadlineの作り方でも。&lt;/p&gt;

&lt;h1 id=&#34;カノニカルモードとエコーモード:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;カノニカルモードとエコーモード&lt;/h1&gt;

&lt;p&gt;readlineの仕組み自体は簡単で、全ての文字入力を受け取って、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readlineの制御キーシーケンスなら指定の制御を行なう&lt;/li&gt;
&lt;li&gt;普通の文字ならそのまま画面に表示する&lt;/li&gt;
&lt;li&gt;コントロールシーケンスなら &lt;code&gt;^W&lt;/code&gt; などとエスケープ表示する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これだけです。しかしそう簡単ではありません。
あなたのお気に入りの言語で &lt;code&gt;readchar&lt;/code&gt; っぽい関数を実行してみると分かるかと思いますが、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一文字入力しただけではプログラムに入力文字が渡されない。エンターキーを押して初めてプログラムの &lt;code&gt;readchar&lt;/code&gt; 関数が返る。&lt;/li&gt;
&lt;li&gt;入力した文字がそのままエコーバックされる。すなわち、 &lt;code&gt;←&lt;/code&gt; を押しても &lt;code&gt;^[[D&lt;/code&gt; が入力されてしまい、制御上不都合。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;私は昔はこれらの挙動が適切な関数がないからだと思ってました。しかし、そうではありません。
このような挙動をするのはプログラムの責任でもでもシェルの責任でもなくターミナルの責任です。&lt;/p&gt;

&lt;p&gt;ターミナルには多彩なモードがあり、それによって挙動が変わるのです。
つまり、1.の挙動をするのはカノニカルモードの挙動、2.の挙動をするのはエコーモードの挙動なのです。&lt;/p&gt;

&lt;h1 id=&#34;tcgetattr-と-tcsetattr:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;&lt;code&gt;tcgetattr&lt;/code&gt; と &lt;code&gt;tcsetattr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、ターミナルのモードはプログラム側から変更出来ます。それを行なうのが &lt;code&gt;tcgetattr(3)&lt;/code&gt; と &lt;code&gt;tcsetattr(3)&lt;/code&gt; です。
ざっくり言うと &lt;code&gt;tcgetattr&lt;/code&gt; で現在のターミナルのコンフィグレーションを取得して、それを所望のモードに書き換え、 &lt;code&gt;tcsetattr&lt;/code&gt; を使って反映出来ます。&lt;/p&gt;

&lt;p&gt;今回はカノニカルモードとエコーモードをoffにしたいのですごい雑なコードだとこう書けるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;sb-posix)
(let* ((stdin 0)
       (termios (sb-posix:tcgetattr stdin))
       (lflag (sb-posix:termios-lflag termios)))
  (setf lflag (logand lflag (lognot sb-posix:icanon)))
  (setf lflag (logand lflag (lognot sb-posix:echo)))
  (setf (sb-posix:termios-lflag termios) lflag)
  (sb-posix:tcsetattr stdin sb-posix:tcsadrain termios))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、これは雑すぎます。なぜならreadlineを実行し終わった後にターミナルを元の状態に復元する必要があるからです。
そうしないとreadlineするつもりのない入力関数が予期せぬ挙動をするでしょう。
あるいはLispプロセスを終了した後のターミナルにまで影響が及びます。
なので &lt;strong&gt;必ず&lt;/strong&gt; 処理が終わったらターミナルの状態を復元する必要があります。&lt;/p&gt;

&lt;p&gt;さて、Common Lispではこの「必ず」は &lt;code&gt;unwind-protect&lt;/code&gt; を使った &lt;code&gt;with-&lt;/code&gt; マクロで実現するのが常套手段です。
コードはこのようになるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro with-readline-mode (&amp;amp;body body)
  (let ((stdin       (gensym &amp;quot;stdin&amp;quot;))
        (old-termios (gensym &amp;quot;old-termios&amp;quot;))
        (new-termios (gensym &amp;quot;new-termios&amp;quot;))
        (lflag       (gensym &amp;quot;lflag&amp;quot;)))
    `(let* ((,stdin 0)
            (,old-termios (sb-posix:tcgetattr ,stdin))
            (,new-termios (sb-posix:tcgetattr ,stdin))
            (,lflag (sb-posix:termios-lflag ,new-termios)))
       (unwind-protect
            (progn
              (setf ,lflag (logand ,lflag (lognot sb-posix:icanon)))
              (setf ,lflag (logand ,lflag (lognot sb-posix:echo)))
              (setf (sb-posix:termios-lflag ,new-termios) ,lflag)
              (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,new-termios)
              ,@body)
        (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,old-termios)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(with-readline-mode
  (format t &amp;quot;~a~%&amp;quot; (read-char)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとするとターミナルのモードが変わったことが実感出来るでしょう。&lt;/p&gt;

&lt;p&gt;尚、繰り返すとこれはターミナルの設定の話なのでEmacs内から試そうとしても正常に動作しない筈です。&lt;/p&gt;

&lt;h1 id=&#34;コントロールシーケンス:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;コントロールシーケンス&lt;/h1&gt;

&lt;p&gt;さて、Common Lispの標準にない拡張機能が必要なのはターミナルのモード変更だけで、あとは好き勝手出来るのですが私も少し嵌った部分があるのでそこだけ。&lt;/p&gt;

&lt;p&gt;readlineに欲しい機能はなんでしょうか。色々あるかと思いますが、まずは &lt;code&gt;←&lt;/code&gt; 、 &lt;code&gt;→&lt;/code&gt; でカーソル移動をしたいのではないでしょうか。
実はこれが大落し穴。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;←&lt;/code&gt; キーを押すとターミナルにはなんと3文字入力されます。すなわち、 Esc文字の &lt;code&gt;^[&lt;/code&gt; 、普通のASCII文字の &lt;code&gt;[&lt;/code&gt; 、そして大文字の &lt;code&gt;D&lt;/code&gt; です。&lt;/p&gt;

&lt;p&gt;そしてカーソルの移動文字を受けてカーソルを移動するにはターミナルにそのままEsc文字の &lt;code&gt;^[&lt;/code&gt; 、普通のASCII文字の &lt;code&gt;[&lt;/code&gt; 、そして大文字の &lt;code&gt;D&lt;/code&gt; を入力してあげれば出来ます。&lt;/p&gt;

&lt;p&gt;なのでこのようなコードになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defconstant left &amp;quot;[d&amp;quot;)
(defconstant right &amp;quot;[c&amp;quot;)

(defun left ()
  (format t &amp;quot;~a&amp;quot; left)
  (force-output))

(defun right ()
  (format t &amp;quot;~a&amp;quot; right)
  (force-output))


(defun readline ()
  (let ((line &#39;()))
    (flet ((self-insert (char)
             (format t &amp;quot;~c&amp;quot; char)
             (setf line (cons char line))
             (force-output)))
      (with-readline-mode
       (loop
          (let* ((char (read-char))
                 (code (char-code char)))
            (case code
              ; escape
              ((#b11011)
               (let* ((char (read-char))
                      (code (char-code char)))
                 ;; (write-line &amp;quot;called&amp;quot;)
                 ;; (format t &amp;quot;~a~%&amp;quot; char)
                 ;; (format t &amp;quot;~a~%&amp;quot; code)
                 (case char
                   ((#\[)
                    (let* ((char (read-char))
                           (code (char-code char)))
                      (case char
                        ((#\c) (right))
                        ((#\d) (left)))))
                   ((t)
                    (self-insert #\escape)
                    (self-insert char)))))
              ((#b1010)
               (return-from readline (coerce (reverse line) &#39;string)))
              (t (self-insert char)))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;case&lt;/code&gt; をネストしていくのはダルいし拡張性がないので現実的にはtrie木を使うことになるかと思いますが単純にはこのようなコードでreadlineを作れます。&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s Happy Hacκking!&lt;/p&gt;

&lt;h1 id=&#34;付録a-伏線:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;付録A: 伏線&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;適当に魚と野菜炒めたらオサレっぽくなった &lt;a href=&#34;https://t.co/9IIzhIGjzd&#34;&gt;pic.twitter.com/9IIzhIGjzd&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/698821538686984192&#34;&gt;2016, 2月 14&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 魚は何？タラ？だったら季節物だし、旬の鱈と野菜のソテー、詳解Linuxカーネルを添えて。と命名しよう&lt;/p&gt;&amp;mdash; Shinnosuke Takeda (@cnosuke) &lt;a href=&#34;https://twitter.com/cnosuke/status/698824048319410176&#34;&gt;2016, 2月 14&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;付録b-pure-rubyなreadlineのソースコード:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;付録B: Pure Rubyなreadlineのソースコード&lt;/h1&gt;

&lt;p&gt;努力が必要ということが読み解ければ幸いです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ConnorAtherton/rb-readline/blob/master/lib/rbreadline.rb&#34;&gt;rb-readline/rbreadline.rb at master · ConnorAtherton/rb-readline&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>分散VCSのモデル、あるいはPijulについて</title>
      <link>/blog/2016/02/14/dvcsnomoderu_aruihapijulnitsuite</link>
      <pubDate>Sun, 14 Feb 2016 17:12:01 +0900</pubDate>
      
      <guid>/blog/2016/02/14/dvcsnomoderu_aruihapijulnitsuite</guid>
      <description>

&lt;p&gt;先日、&lt;a href=&#34;pijul.org&#34;&gt;Pijul&lt;/a&gt;という分散VCSについて知って、それについて調べてみたら少し面白かったのでメモ。&lt;/p&gt;

&lt;p&gt;DVCSで一番有名なのは間違いなくGitだろう。あれは分散グラフ理論木モデルに基いているらしい。ベースになったモデルがあることに驚いたが、調べても出てこなかった。
Gitは高速で信頼性が高い一方、コミット同士をチェーンのように繋げてしまうので柔軟性を欠き、例えばCherry Pickなんかがやりづらい。
あるいはリモートのmasterを取り込まずにローカルのmasterにコミットすると互いに独立した変更であっても一旦remote masterをマージしないとプッシュ出来ず、コミットグラフが汚れてしまう。
また、CUIが直感的でなく、理解しづらいという声もある。それはこういう皮肉にも現れている&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://imgs.xkcd.com/comics/git.png&#34; alt=&#34;gitの皮肉&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まあ、言われてみれば私もこのスライドを見てようやく理解した。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/l0beYVXFDsBY3P&#34; width=&#34;595&#34; height=&#34;485&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/ktateish/git-concept1&#34; title=&#34;コンセプトから理解するGitコマンド&#34; target=&#34;_blank&#34;&gt;コンセプトから理解するGitコマンド&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/ktateish&#34; target=&#34;_blank&#34;&gt;ktateish&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;他のVCSにも色々特色はあって、歴史は神聖なるmercurial、履歴にアクセスしてこそのVCSなFossil、レポジトリとはパッチの集合であるDarcsなどなど。&lt;/p&gt;

&lt;p&gt;この中でもDarcsは大きく毛色が違うように思える。レポジトリは依存関係のあるパッチの集合で、互いに独立なパッチは相互作用しない。なので上に挙げたcherry pickだとかremote vs localの問題とかが起きない。
それにパッチベースの管理なのでメールでパッチを送り合うような古いシステムでも困らない。少なくともforkしてpull requestよりはパッチを送った方がなんぼか筋は良い気がする。他のVCSがsnapshot-basedなのに対してdarcsはpatch-basedになる。&lt;/p&gt;

&lt;p&gt;さて、このDarcs、そこまで知らない人も多いかと思うが古くはGHCの開発に使われていたり(gitに移行した)、common-lisp.netで使われていたり(リニューアルの時に内部がgitlabになってdarcsサポートはドロップされた)した。
Haskellで書かれていたのとモデルが(理論的には)綺麗なので函数型な人達には人気があったようだ。&lt;/p&gt;

&lt;p&gt;Darcsを使っていたプロジェクトがGitに移行したことから分かるように、Darcsにも問題があった(らしい)。1つはパフォーマンスの問題で、Haskellで書かれていたので流石にCで書かれたGitには勝てなかった。
さらには、勘の良い人は気付いたかもしれないが、パッチ同士の依存関係だけで管理してるとマージの時に最悪計算量が $O(2^n)$ になる(多くの場合は $O(n)$ で済むらしい)。&lt;/p&gt;

&lt;p&gt;その他のDarcsの問題についてはこちらを参考されれば。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://togetter.com/li/120640&#34;&gt;GHC の開発の darcs から git への移行 - Togetterまとめ&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;pijul:ea7808ae797e23f21c915a040fcfbb48&#34;&gt;Pijul&lt;/h1&gt;

&lt;p&gt;今回話題に出したPijulはDarcsに影響を受けている。レポジトリとは依存関係を持ったパッチの集合で、パッチ同士の関係はGitに比べれば薄いが、snapshot-basedとpatch-basedの両方の良い所を取り入れている。
Pijulの特色は&lt;a href=&#34;http://arxiv.org/abs/1311.3903&#34;&gt;A Categorical Theory of Patches&lt;/a&gt;の成果を取り入れていて、Darcsにあった計算量の問題が改善している。
この理論はファイルを対象、パッチを射とした圏を考えると、互いにコンフリクトしないパッチは同時に適用出来てかつ適用の順序に依らないことは圏論に於ける「押し出し」に一致することに着目している。
さらにこのパッチ圏を拡張(余完備化)することでコンフリクトが起きないように出来る。&lt;/p&gt;

&lt;p&gt;さて、Pijulにすると何が嬉しいのかというと、色々ある。
Darcsのようにパッチベースな点は言わずもがな、パッチベースなのでパッチを作った後でブランチを切ることが出来る。
実際に作業をしてみてブランチの名前が不適切だったな、とかブランチを切る前に名前を考えるのに一瞬手が止まったりすることがない。
尚、Pijulの現バージョン(0.2)では内部構造的にはブランチを扱えるものの、インターフェースのコマンドがないため事実上ブランチは作れないらしい。
また、データの持ち方的にgit blame相当の機能が速いなどそれなりの特色を出している。&lt;/p&gt;

&lt;p&gt;開発言語もOCaml、Scala、Haskell、Cなどを試して今はRustがベストフィットだと落ち着いたらしい。 &lt;code&gt;cargo install pijul&lt;/code&gt; でインストール出来る。
Rustで開発したお陰もあってDarcsより大分速いらしい。&lt;/p&gt;

&lt;p&gt;Darcsユーザには受けがいいようで、darcs to pijulブリッジも作られようとしているらしい。&lt;/p&gt;

&lt;p&gt;個人で使うには困らない程度にまで安定したら楽しみだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nexus 5にUbuntu Touchのインストール</title>
      <link>/blog/2016/02/10/nexus_5niubuntu_touchnoinsuto_ru</link>
      <pubDate>Wed, 10 Feb 2016 23:09:09 +0900</pubDate>
      
      <guid>/blog/2016/02/10/nexus_5niubuntu_touchnoinsuto_ru</guid>
      <description>

&lt;p&gt;κeenです。先日中古のNexus 5を入手したのでUbuntu Touchをインストールしました。その時のメモ。
尚、Multi ORMなどを使ったマルチブートではなく完全にAndroidを殺したシングルブートです。&lt;/p&gt;

&lt;p&gt;色々調べてみましたが&lt;a href=&#34;https://developer.ubuntu.com/en/start/ubuntu-for-devices/installing-ubuntu-for-devices/&#34;&gt;公式ドキュメント&lt;/a&gt;のままやるのが一番無難なようです。
まあ、スクショがないので他のサイトのスクショは参考にした方がいいかもしれませんが。&lt;/p&gt;

&lt;p&gt;途中adbを使ったりする部分も丁寧に解説してるのでAndroid初心者でも問題ないはず。&lt;/p&gt;

&lt;h1 id=&#34;ツールの準備:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;ツールの準備&lt;/h1&gt;

&lt;p&gt;Ubuntu公式で案外色々なツールを用意してくれている模様。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:ubuntu-sdk-team/ppa
sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でppaを登録した後は&lt;/p&gt;

&lt;p&gt;Ubuntu Touchインストールに必要なツール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install ubuntu-device-flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;USBで繋いだデバイスをデスクトップから操作するのに便利なツール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install phablet-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をインストールします。（恐らく）このコマンドでadbとfastbootも入ります。&lt;/p&gt;

&lt;h1 id=&#34;androidのusbデバッグを有効にする:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;AndroidのUSBデバッグを有効にする&lt;/h1&gt;

&lt;p&gt;普段から自機でAndroidアプリを開発してない人はこのステップが必要でしょう。&lt;/p&gt;

&lt;h2 id=&#34;開発者モードの解放:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;開発者モードの解放&lt;/h2&gt;

&lt;p&gt;[設定のアプリ] → [一般] → [端末情報] → [ソフトウェア情報]&lt;/p&gt;

&lt;p&gt;と進んで[ビルド番号]を7回タップすると開発者モードが解放されます。&lt;/p&gt;

&lt;p&gt;私がAndroid Appを作ってた頃(Android 2.3)にはこんな手順なかったんですけどいつのまにやら変わったんですね。&lt;/p&gt;

&lt;h2 id=&#34;usbデバッグの有効化:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;USBデバッグの有効化&lt;/h2&gt;

&lt;p&gt;さて、これで[一般]タブに戻ると[開発者向けのオプション]という項目が出てくるのでそこからUSBデバッグを有効にしましょう。&lt;/p&gt;

&lt;h1 id=&#34;nexus-5を繋ぐ:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;Nexus 5を繋ぐ&lt;/h1&gt;

&lt;p&gt;USBケーブルでNexus 5をPCに繋ぎます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb devices
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で1つデバイスが表示されていたらちゃんとデバッグモードで繋げています。&lt;/p&gt;

&lt;h1 id=&#34;androidデータのバックアップ:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;Androidデータのバックアップ&lt;/h1&gt;

&lt;p&gt;Androidに未練はなくてももしUbuntu Touchのインストールに失敗した時に引き返せるようにバックアップは必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb backup -apk -shared -all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のコマンドでカレントディレクトリに&lt;code&gt;./backup.ab&lt;/code&gt;という名前でデータが吸い出されます。&lt;/p&gt;

&lt;p&gt;さらにAndroidの再インストールに必要なデバイスデータも取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb shell grep ro.product.name /system/build.prop &amp;gt; mydevicedata \
&amp;amp;&amp;amp; adb shell grep build.id /system/build.prop &amp;gt;&amp;gt; mydevicedata \
&amp;amp;&amp;amp; adb shell grep ro.product.device /system/build.prop &amp;gt;&amp;gt; mydevicedata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中身はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat mydevicedata
ro.product.name=hammerhead
ro.product.device=hammerhead
ro.build.id=MMB29S
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ブートローダのアンロック:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;ブートローダのアンロック&lt;/h1&gt;

&lt;p&gt;そろそろ危いところですね。&lt;/p&gt;

&lt;p&gt;Androidの再起動 &amp;amp; ブートローダへ突入。倒れたドロイド君が現れます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb reboot bootloader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてアンロックします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo fastboot oem unlock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デバイス側で色々訊かれるので音量ボタンと電源ボタンを駆使して答えていきましょう。&lt;/p&gt;

&lt;p&gt;質問が終わってドロイド君の画面に戻ったら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fastboot reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;します。これでAndroidは初期化されてるので最初のセットアップを済ませましょう。どうせ直ぐに殺すので最小限で大丈夫です。&lt;/p&gt;

&lt;h1 id=&#34;ubuntu-touchのインストール:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;Ubuntu Touchのインストール&lt;/h1&gt;

&lt;p&gt;さて、ここは公式ドキュメントと異なる部分です。
&lt;a href=&#34;https://developer.ubuntu.com/en/start/ubuntu-for-devices/image-channels/&#34;&gt;公式サポートのチャネル&lt;/a&gt;ではNexus 5がサポートされていません。
&lt;a href=&#34;https://wiki.ubuntu.com/touch/devices&#34;&gt;Ubuntu wiki&lt;/a&gt;にいくとコミュニティベースでホストされているイメージがあるのでそれを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ubuntu-device-flash --server=https://system-image.ubports.com touch --channel=ubuntu-touch/stable --bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあな量ダウンロードしますが放置しておけばそのままubuntu touchのインストールが完了します。&lt;/p&gt;

&lt;p&gt;おめでとうございます。&lt;/p&gt;

&lt;h1 id=&#34;触ってみた所感:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;触ってみた所感&lt;/h1&gt;

&lt;p&gt;上下左右の端からスワイプインするとメニューとか諸々が出てくるのは面白い。特に左のメニューはUbuntu使いなら体に馴染む。
使い勝手は悪くなさそう。Android使いならすぐに馴染める。&lt;/p&gt;

&lt;p&gt;アプリはまだまだといった所。ストアのアプリも少なければCanonicalの公式アプリもWeb Appという仕上がり(Twitterがモバイル版Webそのままだった)&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;in&#34; dir=&#34;ltr&#34;&gt;Ubuntu Touch nihongo utenai?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/696885260655570944&#34;&gt;2016, 2月 9&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;一応パッチは出ている。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://code.launchpad.net/%7Ecosmos-door/ubuntu-keyboard/japanese-keyboard-rebooted/+merge/268158&#34;&gt;Merge into trunk : japanese-keyboard-rebooted : Code : ubuntu-keyboard&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispで高速行列演算</title>
      <link>/blog/2016/02/04/common_lispdekousokugyouretsuenzan</link>
      <pubDate>Thu, 04 Feb 2016 23:47:34 +0900</pubDate>
      
      <guid>/blog/2016/02/04/common_lispdekousokugyouretsuenzan</guid>
      <description>

&lt;p&gt;κeenです。Common Lispから線形代数ライブラリを使うポストで比較にCommon Lispのコードが出されていたのですがもう少し改良出来そうだったので少しばかり高速化してみました。&lt;/p&gt;

&lt;p&gt;そのポストはこちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://d.hatena.ne.jp/masatoi/20160204/1454519281&#34;&gt;Common Lispで行列演算: LLA(Lisp Linear Algebra)を使う - 翡翠はコンピュータに卵を生むか&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;圧倒的にCommon Lispが遅いですね。そのコードはこちらから。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tanakahx.hatenablog.com/entry/2015/09/25/070000&#34;&gt;Python (NumPy) と Common Lisp (LLA) で行列積の実行速度を比較する - 不確定特異点&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;行列計算(GEMM)部分を抜き出すとこうなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun simple-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))
      (dotimes (row rows)
        (dotimes (col cols)
          (dotimes (k cols)
            (incf (aref result row col)
                  (* (aref ma row k) (aref mb k col))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを&lt;code&gt;*N*&lt;/code&gt; = 256, で100回繰り返したら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   4.688 seconds of real time
;;   4.692000 seconds of total run time (4.688000 user, 0.004000 system)
;;   100.09% CPU
;;   13,564,728,093 processor cycles
;;   26,216,000 bytes consed

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とのこと。まあ、まだ高速化の余地はありそうです。&lt;/p&gt;

&lt;h1 id=&#34;キャッシュする:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;キャッシュする&lt;/h1&gt;

&lt;p&gt;内側のループをみるとこうなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;          (dotimes (k cols)
            (incf (aref result row col)
                  (* (aref ma row k) (aref mb k col))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;incf&lt;/code&gt;をばらすとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;          (dotimes (k cols)
            (setf (aref result row col)
                  (+ (aref result row col) (* (aref ma row k) (aref mb k col)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値として参照している方の&lt;code&gt;(aref result row col)&lt;/code&gt;は&lt;code&gt;k&lt;/code&gt;に依存しないのでループの外に出せます。
書き込んでいる方は場所だから仕方ない。&lt;/p&gt;

&lt;p&gt;これをキャッシュするようにすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun caching-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((cell (aref result row col)))
           (dotimes (k cols)
             (setf (aref result row col)
              (+ cell (* (aref ma row k) (aref mb k col)))))
           )))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じパラメータでベンチマークをとると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; 3.971 seconds of real time
;; 3.972000 seconds of total run time (3.972000 user, 0.000000 system)
;; 100.03% CPU
;; 11,491,319,119 processor cycles
;; 26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2016-02-28 追記:&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; キャッシュのところ、resultのインデックスにkは使ってないけど、kが進むごとに対象の要素は変化してるはずなので、このキャッシュのしかたはまずいのでは?&lt;/p&gt;&amp;mdash; goskevich (@gos_k) &lt;a href=&#34;https://twitter.com/gos_k/status/700622885933613056&#34;&gt;2016年2月19日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということでこれは間違ってました。&lt;/p&gt;

&lt;h1 id=&#34;ループアンローリング:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;ループアンローリング&lt;/h1&gt;

&lt;p&gt;さて、先程の内側のループ、仕事が少ないですね。小さな仕事をチマチマループしてるとイテレーションコストが嵩みます。
1回のイテレーションでの仕事を増やすべく、ループアンローリングをしましょう。&lt;/p&gt;

&lt;p&gt;コピペはダルいのでまずはマクロを。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro dotimes-unroll ((i n unroll) &amp;amp;body body)
  (let ((n_      (gensym &amp;quot;n&amp;quot;)))
    `(let ((,n_ ,n))
       (do ((,i 0))
           ((&amp;lt; ,n_ (the fixnum (+ ,unroll ,i)))
            (do ((,i ,i (the fixnum (1+ ,i))))
                ((&amp;lt; ,n_ (the fixnum (1+ ,i))))
              ,@body
              ))
         ,@(loop :repeat unroll :append (append body `((setq ,i (the fixnum (1+ ,i))))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;少し試してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(dotimes-unroll (i 10 3)
  (format t &amp;quot;~%~a&amp;quot;) i)
0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。&lt;/p&gt;

&lt;p&gt;それではこれを使ってアンロールします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun loop-unroll-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((cell (aref result row col)))
           (dotimes-unroll (k cols 16)
             (setf (aref result row col)
              (+ cell (* (aref ma row k) (aref mb k col))))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アンロール数は16が一番パフォーマンス出たようでした。&lt;/p&gt;

&lt;p&gt;さて、ベンチマークをしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   3.847 seconds of real time
;;   3.848000 seconds of total run time (3.848000 user, 0.000000 system)
;;   [ Run times consist of 0.012 seconds GC time, and 3.836 seconds non-GC time. ]
;;   100.03% CPU
;;   11,128,993,432 processor cycles
;;   26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;辛うじて速くなってる…。因みにこれのパフォーマンスはCPUの命令キャッシュの状況に依存するので何度か試すとこれより速いスコアが出ることもあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Evaluation took:
  3.338 seconds of real time
  3.340000 seconds of total run time (3.332000 user, 0.008000 system)
  [ Run times consist of 0.020 seconds GC time, and 3.320 seconds non-GC time. ]
  100.06% CPU
  9,657,259,219 processor cycles
  26,248,768 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;メモリアクセスしない:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;メモリアクセスしない&lt;/h1&gt;

&lt;p&gt;さて、最初にキャッシュした時に書き込まれている方の &lt;code&gt;(aref result row col)&lt;/code&gt; は場所だからキャッシュ出来ないといいました。まあ、それは正しいのですがループの中で毎回書き込む必要はありません。&lt;/p&gt;

&lt;p&gt;レジスタ上で計算を済ませて最後に書き込んであげれば十分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun on-register-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((res (aref result row col)))
           (dotimes-unroll (k cols 16)
             (setf res
                   (the single-float (+ res (* (aref ma row k) (aref mb k col))))))
           (setf (aref result row col) res))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを試してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   2.302 seconds of real time
;;   2.304000 seconds of total run time (2.300000 user, 0.004000 system)
;;   [ Run times consist of 0.008 seconds GC time, and 2.296 seconds non-GC time. ]
;;   100.09% CPU
;;   6,662,273,812 processor cycles
;;   26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;わお！急に速くなりました。 &lt;code&gt;(* 100 (- (/ 4.688 2.302) 1))&lt;/code&gt; ≒ 103、 100%近い高速化です。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;特に深い意味はなかったのですがパタヘネに載っていたやつを試してみたくて遊んでみました。&lt;/p&gt;

&lt;p&gt;普通に行列計算したいなら線形代数ライブラリ使った方が良いと思います。&lt;/p&gt;

&lt;h1 id=&#34;ノート:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ループアンローリングの部分をイテレーションコストで説明しましたが他にも1ループ内の命令数が増えると組み合わせパズルのピースが増えるので最適化されやすくなります。まあ、SBCLは覗き穴最適化をほとんどしないのであまり意味ありませんが。気になる方はディスアセンブルしてみて下さい。&lt;/li&gt;
&lt;li&gt;このあと、 &lt;code&gt;(aref mb k col)&lt;/code&gt; がCPUキャッシュを無駄にしているという話からキャッシュサイズ毎に行、列を分けて計算するやり方を紹介しようとしたのですが逆に遅くなってしまいました。付録Aにコードを置いておきます。うーむ。&lt;/li&gt;
&lt;li&gt;本当はさらにこのセグメント毎にスレッドに計算を投げて並列化したかったのですがセグメントで高速化しなかったので萎えて諦めました。&lt;/li&gt;
&lt;li&gt;パタヘネ的にはSIMDも使うのですが深夜に近付いてきて面倒になったのでこの辺でやめました。Common Lisp(SBCL)からSIMD命令を使うには&lt;a href=&#34;http://keens.github.io/blog/2014/12/02/vopdeyou-bu/&#34;&gt;私の過去のエントリ&lt;/a&gt;を参照して下さい。&lt;/li&gt;
&lt;li&gt;本気で行列計算をしたいなら今回の $O(n^3)$ のアルゴリズムだけでなくStrassenのアルゴリズムやCoppersmith-Winogradのアルゴリズムも検討すべきです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;付録a:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;付録A&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun segmented-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let* ((segment 16)
         (rows (array-dimension ma 0))
         (cols (array-dimension mb 1))
         (colseg (floor cols segment))
         ktmp coltmp
         k col
         )
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (ci colseg)
          (setf coltmp (the fixnum (* ci segment)))
          (dotimes (ki colseg)
            (setf ktmp (the fixnum (* ki segment)))
           (dotimes (cs segment)
             (setf col (the fixnum (+ coltmp cs)))
             (let ((res (aref result row col)))
               (dotimes (ks segment)
                 (setf k (the fixnum (+ ktmp ks)))
                 (setf res
                       (the single-float (+ res (* (aref ma row k) (aref mb k col))))))
               (setf (aref result row col) res))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HAMT ~ イミュータブルで高速なハッシュマップ ~</title>
      <link>/slide/HAMT/</link>
      <pubDate>Sun, 31 Jan 2016 16:17:35 +0900</pubDate>
      
      <guid>/slide/HAMT/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# &lt;span style=&#34;font-size: 90%&#34;&gt;Hash-Array Mapped Trie&lt;/span&gt;
----------------------
 ~ イミュータブルで高速なハッシュマップ ~  
サイバーエージェント AdTech Scala Meetup LT大会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループの新卒
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# &lt;span style=&#34;font-size: 60%&#34;&gt;scala.collections.immutable.HashMap&lt;/span&gt;
-------------------------------------

* 今日の話題。これの実装をみていく。
* イミュータブル
* キー-バリューペア
* 値を追加する度に新たなハッシュマップを作る &lt;!-- .element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;


# HashMap
----------------

* `O(1)`のアクセス効率
* 空間効率は悪い
* ハッシュ関数が定義出来れば何でもキーに使える
* 普通はミュータブルに使う
  + 大量のメモリをアロケートするのでコピーはつらい


# メモリ効率悪そう？
-------------------------

```scala
val hash = HashMap.empty + (3 -&gt; 1)
// +---+---+---+---+---+----
// | / | 3 | / | / | / | ...
// +---+---+---+---+---+----
//       |
//      +-+
//      |1|
//      +-+
```


# メモリ効率悪そう？
-------------------------

```scala
val hash2 = hash + (2 -&gt; 2)
// +---+---+---+---+---+----
// | / | 3 | / | / | / | ...
// +---+---+---+---+---+----
//       |
//      +-+
//      |1|
//      +-+
//  &gt; Copy &lt;
// +---+---+---+---+---+----
// | / | 3 | / | 2 | / | ...
// +---+---+---+---+---+----
//       |       |
//      +-+     +-+
//      |1|     |2|
//      +-+     +-+
```


# メモリ効率的データ構造?
----------------------------
## TreeMap

* O(log(n))のアクセス効率
* 空間効率はほどほど
  + イミュータブルに使えばかなり良い
  + 部分構造を再利用出来る
* 全順序関数が定義出来れば何でもキーに出来る
* キーが複数回比較される問題がある


# キー同士の比較
---------------
長いキー同士の比較がO(log(n))回走る可能性がある

```scala
treeMap.get(&#34;very long ... key1&#34;)

        ....
       /
&#34;very long ... key3&#34; -&gt; &#34;value3&#34;
       \
   &#34;very long ... key2&#34; -&gt; &#34;value2&#34;
         \
      &#34;very long ...key1&#34; -&gt; &#34;value1&#34;
```


# HashMap vs TreeMap
-----------------

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th&gt;HashMap&lt;/th&gt;&lt;th&gt;TreeMap&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;アクセス効率&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34;&gt;`O(1)`&lt;/td&gt;&lt;td&gt;`O(log(n))`&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;イミュータブルな時の空間効率&lt;/th&gt;&lt;td&gt;悪い(毎回コピー)&lt;/td&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;良い(部分構造を共有)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;キーの比較&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;定数回&lt;/td&gt;&lt;td&gt;`O(log(n))`回&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;キーの要件&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;Hash関数が定義されている&lt;/td&gt;&lt;td&gt;全順序関数が定義されている&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

# &lt;span style=&#34;font-size: 90%&#34;&gt;Hash-Array Mapped Trie&lt;/span&gt;
------------------------

* `O(1)`のアクセス効率
* 部分構造を共有してメモリ効率も良い
* キーの比較は定数回
* Hash関数が定義されていればキーに出来る


# 動作
------

* ざっくり言うと、「Hashして分割してトライ」


# 動作
------
## Hashする

* 40bitくらいの値が生成される

``` scala
hash(&#34;key&#34;)
// =&gt; 0b10101101010101001010110101010100
```


# 動作
------
## 分割する

* 下位から5bit毎に分割する
  + 5bit = 0 ~ 31
  + 32分木になる

```
11111 00010 10110 10101 01001 01011 01010 10100
```


# 動作
------
## トライ

* 32分のトライ木になる
* トライ木の実装は32bitのbitmapを使ったArray Mapped Trieを使う


(図が分かりづらいというか不適切)

```
8     7     6     5     4     3     2     1
11111 00010 10110 10101 01001 01011 01010 10100

1    2    3  4
   ...
  /
10100     ...
  \        /
   \    01011
    \   /  \
     \ /   01001....
     01010
       \
        ...
```


# 特徴
------

* ハッシュ値が固定長なので`O(1)`で動作
* Treeなので部分構造の共有が簡単
* 木を辿る時の比較はhash値（の一部）なので高速
* キーに全順序がなくてもハッシュ関数さえ定義されていれば木を構築出来る


# まとめ
--------

* Scalaのimmutable.HashMapはコピーしても高速だよ
* 裏で動くアルゴリズムを紹介したよ
  + ざっくりなので本物はもう少し工夫してる
  + prefix treeになってる


# 参考
------

* PDF [Ideal Hash Trees](http://lampwww.epfl.ch/papers/idealhashtrees.pdf)
  + HAMTの元論文
* [HAMT(Hash Array Mapped Trie) - sileのブログ](http://sile.hatenablog.jp/entry/20100926/1285467529)
  + HAMTの解説ブログ
* PDF [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections](http://michael.steindorfer.name/publications/oopsla15.pdf)
  + HAMTを改善したCHAMPというデータ構造の論文。Clojureにこれが入りそう。
* [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections | the morning paper](http://blog.acolyer.org/2015/11/27/hamt/)
  + CHAMPを解説したブログ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>