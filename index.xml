<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Mon, 28 Nov 2016 18:01:15 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SchemeでClassとProtocol</title>
      <link>/slide/Schemedeclasstoprotocol/</link>
      <pubDate>Mon, 28 Nov 2016 18:01:15 +0900</pubDate>
      
      <guid>/slide/Schemedeclasstoprotocol/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClassとProtocol
----------------------
[Lisp Meet Up presented by Shibuya.lisp #46](https://lisp.connpass.com/event/45517/) Scheme回
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# Class
-------

* ここでは単に値の集合を表わす
* `new` のように新しいインスタンスを作る機能はつけない
* ほとんど型と同じ機能
* 唯一の機能 `instance?` を持つ

===

``` scheme
(instance? 3 &lt;number&gt;)     ; =&gt; #t
(instance? &#34;foo&#34; &lt;number&gt;) ; =&gt; #f
```

===

# Classの実装
-------------

* 事実上述語があればいい
* [詳細](https://github.com/picrin-scheme/picrin/blob/master/contrib/50.class/piclib/picrin/class.scm)

``` scheme
(define-class &lt;any&gt; (lambda (x) #t))
(define-class &lt;list&gt; list?)
(define-class &lt;procedure&gt; procedure?)
(define-class &lt;number&gt; number?)
```

===

# Classの用途
-------------

* 述語だけで意味ある？
  + プリミティブにのみあった述語をユーザが拡張出来る
* その上に何かを構築出来る
* protocolとか

===

# Protocol
-----------

* Clojureのprotocol
* 多重ディスパッチの機構
* ディスパッチするのにClassを使う

===

```scheme
(define-protocol (PLUS x y)
  (plus x y))

(define-instance (PLUS &lt;number&gt; &lt;number&gt;)
  (lambda (x y) (+ x y)))


(define-instance (PLUS &lt;number&gt; &lt;string&gt;)
  (lambda (x y) (string-append (number-&gt;string x) y)))

(define-instance (PLUS &lt;string&gt; &lt;string&gt;)
  (lambda (x y) (string-append x y)))

```

===

``` scheme
(display (plus 1 2)) (newline)
; -&gt; 3
(display (plus 1 &#34;foo&#34;)) (newline)
; -&gt; 1foo
(display (plus &#34;bar&#34; &#34;foo&#34;)) (newline)
; -&gt; barfoo
(display (plus &#34;bar&#34; 1)) (newline)
; -&gt; &#34;error: method not found&#34;
```

===
# ユーザ定義型とProtocol
------------------------

``` scheme
(define-record-type complex
  (make-complex real img)
  complex?
  (real complex-real)
  (img  complex-img))

(define (complex-+ c1 c2)
  (make-complex (+ (complex-real c1) (complex-real c2))
                (+ (complex-img  c1) (complex-img  c2))))

(define (complex-&gt;string c)
  (string-append
   (number-&gt;string (complex-real c)) &#34;+&#34;
   (number-&gt;string (complex-img  c)) &#34;i&#34;))
```

===

```scheme
(define-class &lt;complex&gt; complex?)

(define-instance (PLUS &lt;complex&gt; &lt;complex&gt;)
  complex-+)


(display (complex-&gt;string
          (plus (make-complex 1 2)
                (make-complex 2 3)))) (newline)
; -&gt; 3+5i
```

===

# Protocolの実装
----------------

* メソッドの登録とか述語でディスパッチとか割と面倒
* [詳細](https://github.com/picrin-scheme/picrin/blob/master/contrib/80.protocol/piclib/picrin/protocol.scm)

===
# まとめ
---------

* 「追加可能な型」は便利だよ
* 型相当のものがあればダイナミックディスパッチ出来るよ
* picrinに実装されてるよ `(picrin class)` `(picrin protocol)`


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustで非同期Thriftしたい</title>
      <link>/slide/RustdehidoukiThriftshitai/</link>
      <pubDate>Sat, 26 Nov 2016 13:07:29 +0900</pubDate>
      
      <guid>/slide/RustdehidoukiThriftshitai/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Rustで非同期Thrift
----------------------
[歌舞伎座.tech#12「メッセージフォーマット/RPC勉強会」 - connpass](https://kbkz.connpass.com/event/40629/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

* &lt;span style=&#34;font-size:150%&#34;&gt;X&lt;/span&gt; RPCライブラリを使う話
* &lt;span style=&#34;font-size:150%&#34;&gt;O&lt;/span&gt; RPCライブラリを作る話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# RPC
-----

* Remote Procedure Call
* リモートで呼べる
* 言語跨げる
* シリアライズフォーマットが決まれば大体出来る
* Thrift, protobuf/gRPC, avro...
* 大抵バイナリ
  + JSONに比べて2倍くらい効率がいい

===

# Thrift
--------

* Facebook発(現apache)RPCフレームワーク
* IDLから複数の言語向けのコードを吐ける
* 対応言語多い
* 新しい言語はthriftレポジトリフォークして追加

===

# Thrift vs gRPC
----------------

\                       | Thrift | gRPC
------------------------|:------:|:----:
ベース                  | 自前   | HTTP/2
コード生成              | o      | o
プロトコルのアップデート | o      | o
通信の多重化            | トランスポート次第  | o (HTTP/2)
認証                    | x  | o
例外                    | ユーザ定義可能 | 事前定義のみ?
対応言語                | 多い   | ほどほど
その他                  | union  | timestamp, anyなど
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;

===

# 何故Thrift?
-------------

* 仕事で使ってたから
* 仕事は「gRPCかthrift、まあthriftでいっしょ」で決まった

===

# RustとThrift
--------------
いくつか実装がある

===

## [sgnr/rust-thrift](https://github.com/sgnr/rust-thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![sgnr/rust-thrift is deprecated](/images/thrift/sgnr-rust-thrift.png)

===

## [maximg/thrift](https://github.com/maximg/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![maximg/thrift is deprecated](/images/thrift/maximg-thrift.png)

===

## [terminalcloud/thrift](https://github.com/terminalcloud/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![terminalcloud/thrift is deprecated](/images/thrift/terminalcloud.png)

===

# [thehydroimpulse/thrust](https://github.com/thehydroimpulse/thrust)
---------------------------

* Thrift RPC in Rust (Async I/O)
* 非同期!!
* apache/thriftベースじゃない（フルスクラッチ）
* コンパイラプラグインサポートとかも
* 作りかけ
  + `Latest commit 0a37b77 on 11 Apr`

→ フォークすることに

===

# [Finagle](https://github.com/twitter/finagle)
---------

* **Scalaの** RPCフレームワーク
* [You Server as a Function](https://monkey.org/~marius/funsrv.pdf)
* Nettyベース
* サーバとクライアント両方サポート
* Twitter製
* 良くも悪くもTwitterべったり

===

# Finagle Client
--------

* クライアントが賢い
* RPCではTCPベースのLBが使えない
  + クライアントはコネクション張りっぱなし
* クライアントサイドロードバランシングが必要
* Finagleはそこまでカバー
* 他にもエラーが起きたサーバ外したり色々

===

# Tokio
--------

* **Rustの** RPCフレームワーク
* mioベース
* Finagleを参考に開発
  + **開発中**
* tokio-core
  + コア部分
* tokio-proto
  + プロトコル実装のサポート
  + 絶賛API変更中
* tokio-service
  + サービス実装のサポート


===

# TokioとFinagle
-----------------

  \           | Tokio       | Finagle
--------------|:-----------:|:-------:
コア          | [tokio-core](https://github.com/tokio-rs/tokio-core) | [finagle-core](https://github.com/twitter/finagle/tree/develop/finagle-core)
Future        | [future](https://github.com/alexcrichton/futures-rs) | [twitter util](https://github.com/twitter/util)
非同期エンジン | [mio](https://github.com/carllerche/mio) | [netty](http://netty.io/)
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;


===

# [mio](https://github.com/carllerche/mio)
------

* 非同期イベントループライブラリ
* イベントドリブン
* ループ内ゼロアロケーション
* `epoll` などの薄いラッパ
* libuv, libevent, libev2などのRust版
* ソケットだけでなく *ファイルIO* 、インメモリチャネルとかも監視出来る

===

# [future](https://github.com/alexcrichton/futures-rs)
--------------

* [Zero-cost futures in Rust · Aaron Turon](https://aturon.github.io/blog/2016/08/11/futures/)
* ゼロコスト
* 普通にFutureを使うとランタイムにステートマシンになる
* 「将来実行される」という「状態」を第一級の値として表現する大事な手段
* お型付けは大変
    + `map` したら `Map&lt;A, fn (A)-&gt;B&gt;` の型が返ったり
* ストリーミング指向のAPIもある

===

# [tokio-core](https://github.com/tokio-rs/tokio-core)
--------------

* 非同期IOのフレームワーク
* Futureベース
* フレームドIOとストリーミングIO
* フレームワークというよりユーティリティ？
  + mioとfutureを合わせて使う

===

# [tokio-proto](https://github.com/tokio-rs/tokio-proto)
-------------

* 主にバイナリ列&lt;-&gt;構造体の部分の面倒を見てくれる
* API変更中…
* バッファリングしてパースしやすくしてくれる
* プロトコルの多重化やってくれる(後述)

===

# [tokio-service](https://github.com/tokio-rs/tokio-service)
-----------------

* タスクサーバの面倒見てくれる
* 主にロードバランシング


===

# [Service](https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html)
-------------

``` rust
pub trait Service {
    type Request;
    type Response;
    type Error;
    type Future: Future&lt;Item=Self::Response, Error=Self::Error&gt;;
    fn call(&amp;self, req: Self::Request) -&gt; Self::Future;
}
```

===

# Service
----------

* いわゆるハンドラ
* インターフェースさえ満たせばいい
  + ミドルウェアもハンドラも同じ扱い

===

# [NewService](https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html)
--------------

```rust
pub trait NewService {
    type Request;
    type Response;
    type Error;
    type Instance: Service&lt;Request=Self::Request, Response=Self::Response, Error=Self::Error&gt;;
    fn new_service(&amp;self) -&gt; Result&lt;Self::Instance&gt;;
}

impl&lt;F, R&gt; NewService for F where F: Fn() -&gt; Result&lt;R&gt;, R: Service
```

===

# NewService
------------

* いわゆるAbstractServiceFactory的な存在
* コア数に応じてサービスを作ってくれる
* ただし`Service`を返す普通の関数も`NewService`になる
* [example](https://github.com/tokio-rs/tokio-line/blob/master/examples/echo_client_server.rs#L21)


===

# tokio-thrift
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# [tokio-thrift](https://github.com/KeenS/tokio-thrift)
--------------

* [KeenS/tokio-thrift](https://github.com/KeenS/tokio-thrift)
* この発表のために作った（作ってる）
* tokioベースのrustのthriftサポート
* thrustのフォーク
* 基本ツール全て
  + コードジェネレータ
  + コンパイラプラグイン
  + ランタイムライブラリ

===

# プロトコルスタック
-------------------

ユーザは実装に集中出来る仕組み

```
+------------------------------------------------+
| service   | tokio-service + 生成コード + ユーザ |
|------------------------------------------------|
| protocol  | tokio-proto   + tokio-thrift       |
|------------------------------------------------|
| transport | tokio-core                         |
+------------------------------------------------+
```

===

# サンプルコード
----------------

* [これ](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/main.rs)

===

# ユーザビリティ
---------------

* サーバ: ユーザはインターフェースに沿ったコードを書くだけ
* クライアント: インターフェース通りに呼べる
* 返り値はFuture
* サーバ: 非同期実装と相性がいい
* クライアント: 非同期通信をそのままエンコード

===

# 実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# Thriftのプロトコル
-------------------

* 現状binary protocolのみ
  + fork元が実装してあった
* compactとか需要ある？
* 因みにJSONはやめとけ

===

# 所有権とゼロコピー
-------------------

* プロトコルのパースの部分の話
* Rustっぽい部分
* バッファの所有権をパース結果に渡すことでデータのコピーを避ける

===

# 所有権とゼロコピー
-------------------
バッファをresultにパースして

```
buffer
  |
+-+---------------+
|                 |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 所有権とゼロコピー
-------------------
resultにデータの所有権を渡してしまう

```
 result   buffer
   |        |
+--+----++--+-----+
|       ||        |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 複数メソッド
-------------

* 複数メソッドだと複数の引数/返値の型を扱う
* コネクションのハンドラは1つ
* 複数型をどうやって扱う？
  + [enumを定義](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/thrift.rs#L67)
  + ゼロオーバーヘッド…

===

# 複数メソッド
-------------

```
 (methodA) (methodB)
     |         |
     +----+----+
          | &lt;----- enum化
      [client]
          |
      [server]
          | &lt;----- enumでディスパッチ
     +----+-----+
     |          |
(handlerA) (handlerB)
```

===

# つらい話
-----------------

* Thrift IDLのセマンティクスが書いてない
  + throws節のフィールドは直積？直和？
  + Javaで生成してみて推測するしかない
* フォークライブラリの実装が不完全
  + パーサはフルスクラッチで書き直した
  + [パーサコンビネータ便利](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-codegen/src/parser.rs#L517)
  + フォークした意味…
* Rustにエンコード出来ないthriftの機能もある
  + mapの定数は普通には無理
  + エラーどうしよう(`Error`トレイトの実装とEnum)
* 所有権の問題

===

# 言語との統合
-------------

* Rustには公式のシリアライズフレームワークがある
* [rustc-serialize](https://github.com/rust-lang-nursery/rustc-serialize)
* あるいはユーザ側のも
* [serde](https://github.com/serde-rs/serde)
* のっかりたいけどThriftに必要なデータがない
  + フィールドのシーケンス番号とか
* 今のところ自動生成に頼る
  + フレームワークにフィードバックした方がいい？

===

# コード生成の話
---------------

* [コンパイラプラグイン](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-macros/tests/service.rs#L10)微妙
  + 定義元ジャンプ、フィールド名補完などに難
* CLI生成は悪手
  + IDL変更する度CLI実行？
  + 生成コードはコミット？
    - CLIのバージョンがあるので基本はコミット。でも…
* ビルドツール統合が最良
  + FinagleにはScoogeがある
  + tokio-thriftでもやりたい
    - build.rsのサポート

===

# 多重化の話
------------

* 生のthrift on TCPだと通信を多重化出来ない
* tokio-proto側でpipelineやmultiplexなどをサポート
* pipeline: レスポンスを待たずに次のリクエスト
* multiplex: リクエストとレスポンスが入り乱れてもよい。プロトコルオーバーヘッドがある
* tokio-thriftは未対応

===

# Tokioの利点
-------------

* service: サーバとクライアント両方面倒見てくれる
  + サーバもCPUの数だけハンドラをクローンしてくれたりする
* protocol: 面倒毎が少ない(バッファ使ってくれる)
* Futureベースの非同期
* pipeline, multiplexによる多重化

===

# Tokioの欠点
-------------

* APIが不安定
  + tokio-thriftは今動かないorz
* thriftはストリーミング指向なのにバッファ使う
* Rustの痒い所に当たる
  + 返り値多相がない(`Future`を直接返せない)
  + アロケーションが必要になる
  + ダイナミックディスパッチが必要になる
  + 他言語と同水準のコスト

===

# まとめ
--------

* Thriftは広さで勝負
* コードジェネレータはビルドツールへの統合を
* IDLは既存のコードに乗っかった方が楽（上と競合）
* フレームワークを使うとみんな幸せ
* RPCはインターフェースベースであるべき
* 多重化はRPCより下のレイヤーで出来る

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustの関連型の使いどころ</title>
      <link>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</link>
      <pubDate>Tue, 22 Nov 2016 18:26:47 +0900</pubDate>
      
      <guid>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</guid>
      <description>&lt;p&gt;κeenです。昨日は&lt;a href=&#34;https://rust.connpass.com/event/41467/&#34;&gt;RustのLT会！ Rust入門者の集い - connpass&lt;/a&gt;に参加してきました。
そこで&lt;a href=&#34;http://qiita.com/tacke_jp/items/9c7617971dc341146c0f&#34;&gt;関連型に関する発表&lt;/a&gt;があったので感化されて私も一筆。&lt;/p&gt;

&lt;p&gt;
馴れないと関連型はジェネリクスでいいじゃんと思えますが、両者は別の機能を提供するものです。
設計による使い分けではなくて実現したいことに応じた機能による使い分けをするので馴れてしまえば迷うことなくどちらを使うか判断出来ます。&lt;/p&gt;

&lt;p&gt;ということで関連型のパターンをいくつか。
もちろん、根底にある関連型という機能は共通なのでほとんど同じようなことを言ってますが気持としてパターンを知っておくと便利です。&lt;/p&gt;

&lt;h1 id=&#34;型レベルの関数として&#34;&gt;型レベルの関数として&lt;/h1&gt;

&lt;p&gt;「関連」型なのである型に関連する型を表現します。ちょっと見方を変えると型から型への写像、つまり関数になります。
例えばこういうのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ToUnsigned {
    type Counterpart;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart;
}

impl ToUnsigned for i32 {
    type Counterpart = u32;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart {
        self as u32
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;i32&lt;/code&gt; から &lt;code&gt;u32&lt;/code&gt; への関数になってそうなのが見えますかね？もちろん、 &lt;code&gt;i64&lt;/code&gt; から &lt;code&gt;u64&lt;/code&gt; などへの対応も作れます。
こういうのは例えば符号無し数にのみ演算が定義されている場合とかに便利ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn write_bigendian_signed&amp;lt;I, U&amp;gt;(i: I) -&amp;gt; ()
    where I: ToUnsigned&amp;lt;Counterpart = U&amp;gt;,
          U: ...,  {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;トレイト内で使う型を固定するため&#34;&gt;トレイト内で使う型を固定するため&lt;/h1&gt;

&lt;p&gt;これが一番目にするやつじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Handler {
    type Request;
    type Response;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}

struct HTTPHandler;

impl Handler for HTTPHandler {
    type Request = HTTPRequest;
    type Response = HTTPResponse;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定というか特殊化というか、トレイト自体は汎用的に作られていて、それを実装する型が特定の処理に特化するパターンです。
ジェネリクスで受け取る訳にはいかなくて、実装すべき型をトレイトの中で定義してあげる必要があるのは分かると思います。&lt;/p&gt;

&lt;h1 id=&#34;関数の返り値を一般化するため&#34;&gt;関数の返り値を一般化するため&lt;/h1&gt;

&lt;p&gt;これは現在のRust(rust-1.13.0)が &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1522&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;をサポートしていないために必要になるテクニックです。
関連型とトレイト境界を組み合わせて使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ReverseIter {
    type Item;
    type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;
    fn rev_iter(&amp;amp;self) -&amp;gt; Iter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの &lt;code&gt;type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt; の方です。
返り値のIteratorを抽象化したいのですが、現在のRustでは&lt;code&gt;fn rev_iter(&amp;amp;self) -&amp;gt; Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt;のような書き方が出来ないので仕方なく関連型を使ってあげる必要があります。&lt;/p&gt;

&lt;p&gt;ちょっと踏み込んだ話をすると、関数の引数の多相性は∀の量化、返り値の多相は∃の量化です。そしてトレイトのジェネリクスも∀の量化で関連型が∃の量化なのでそういう対応がある訳です。&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;結構理論的にも色々あるようなので調べてみると様々なブログポストが見付かると思います。&lt;/p&gt;

&lt;p&gt;ぱぱっと思いついたパターンを3つ挙げました。もしかしたら他にもパターンがあるかもしれません。&lt;/p&gt;

&lt;p&gt;これを知っておけば&lt;a href=&#34;https://github.com/tokio-rs/tokio-service&#34;&gt;tokio-service&lt;/a&gt;の&lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;Service&lt;/a&gt;みたいな関連型を多用するパターンでもひるまなくなります。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;h2 id=&#34;関連型とimpl-traitに関して&#34;&gt;関連型とimpl Traitに関して&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rust-lang-ja.org/rust-by-example/generics/assoc_items/the_problem.html&#34;&gt;関連型が必要になる状況 | Rust by Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ncameron.org/blog/abstract-return-types-aka-%60impl-trait%60/&#34;&gt;Abstract return types, aka &lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;応用&#34;&gt;応用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2016/02/28/rustnohigherkinded_type_trait/&#34;&gt;RustのHigher-Kinded type Trait | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;発展的な話題&#34;&gt;発展的な話題&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/02/associated-type-constructors-part-1-basic-concepts-and-introduction/&#34;&gt;Associated type constructors, part 1: basic concepts and introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/03/associated-type-constructors-part-2-family-traits/&#34;&gt;Associated type constructors, part 2: family traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/04/associated-type-constructors-part-3-what-higher-kinded-types-might-look-like/&#34;&gt;Associated type constructors, part 3: What higher-kinded types might look like&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/09/associated-type-constructors-part-4-unifying-atc-and-hkt/&#34;&gt;Associated type constructors, part 4: Unifying ATC and HKT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1598&#34;&gt;Associated type constructors (a form of higher-kinded polymorphism). by withoutboats · Pull Request #1598 · rust-lang/rfcs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustの話とリソースの話</title>
      <link>/slide/Rustnohanashitoriso_sunohanashi/</link>
      <pubDate>Sun, 20 Nov 2016 14:08:07 +0900</pubDate>
      
      <guid>/slide/Rustnohanashitoriso_sunohanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustの話とリソースの話
----------------------
[RustのLT会！ Rust入門者の集い](https://rust.connpass.com/event/41467/)  
2016-11-21

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 若者
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます
 * [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)の翻訳
 * [Join rust-jp on Slack!](http://rust-jp.herokuapp.com/) にもいます。
 * [Rust その2 Advent Calendar 2016 - Qiita](http://qiita.com/advent-calendar/2016/rust-lang-2)

===

# 注意
------

* たまにマニアックな話が出ますが気にせず無視して下さい
* 「なんかRustすげー」って思ってもらえれば幸いです


===

# Rustとの出会い
----------------

* 元々Lisperだった
* 他にはML, Ruby, JVM言語など

===

![lis books](/images/rust-and-resource/lisp.jpg)&lt;!-- .element: height=&#34;640px&#34; --&gt;

===

&lt;span style=&#34;font-size: 150%&#34;&gt;「Lisperは自分で処理系作って一人前」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![compiler books](/images/rust-and-resource/compiler.jpg) &lt;!-- .element: height=&#34;640px&#34;&#34; --&gt;

===

# 苦悩
-------

* Cは低級すぎる
* Javaは向いてない
* C++は怖そう
  + 闇の軍団
  + 縄文土器飛んできそう
  + あと **nullあるしメモリ破壊あるし**
* MLは向いてるけどシステムプログラミングしづらい
* ATS2, Golang, D...

===

# Rustと出会う
----------------

* 正直最初は色物言語と思ってた
* 調べてみたら気に入った

===

# ゼロコスト抽象化
----------------------------

``` rust
fn sum_pos(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    v.iter().filter(|i| **i &gt; 0).sum()
```

===

高階関数が消えた…！？

``` asm
_ZN21higher_order_function7sum_pos17h2f9de4f69306ec0aE:
	.cfi_startproc
	movq	(%rdi), %rcx
	movq	16(%rdi), %rax
	leaq	(%rcx,%rax,4), %rdx
	xorl	%eax, %eax
	jmp	.LBB0_1
.LBB0_3:
	addl	%esi, %eax
	.p2align	4, 0x90
.LBB0_1:
	cmpq	%rcx, %rdx
	je	.LBB0_4
	movl	(%rcx), %esi
	addq	$4, %rcx
	testl	%esi, %esi
	jle	.LBB0_1
	jmp	.LBB0_3
.LBB0_4:
	retq
```

===


# スタックとヒープ
------------------


* Rustは手で割り当てを変えられる
* 「ヒープを使ったら負け」ゲームが出来る
* ループの中でヒープアロケートしたくないよね

===

# マクロとコンパイラプラグイン
-----------------------------

例えば正規表現リテラルを作れるか、とか。

1. Common Lisp
2. 衛生的マクロ + 手続的マクロ &lt;- Rust
2. 衛生的マクロ + コンパイラプラグイン &lt;- Rust
3. 手続的マクロ
4. コンパイラプラグイン
4. 衛生的マクロ

===

# トレイト
----------

* 型クラス
  + 継承を駆逐する
  + MLにも欲しい超便利機能
* 関連型
  + 表現力が高いことが知られている
  + CF [Rustの型レベルLispっぽいの作った | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/11/06/rustnokatareberulispppoinotsukutta/)

===

# パターンマッチ、代数的データ型
-------------------------------

* 便利ってかないと困る

``` rust
    match expr {
        &amp;Expr::Nil |
        &amp;Expr::EOF |
        &amp;Expr::Str(_) |
        &amp;Expr::Int(_) |
        &amp;Expr::Float(_) |
        &amp;Expr::Proc(_) =&gt; Ok(expr.clone()),
        &amp;Expr::Sym(ref name) =&gt; {
            match env.find(&amp;name.to_owned()) {
                Ok(v) =&gt; Ok(v.clone()),
                Err(m) =&gt; {
                    if name.deref() == &#34;t&#34; {
                        Ok(ksym(&#34;t&#34;))
                    } else {
                        Err(m)
                    }
                }
            }
        }
        &amp;Expr::Cons(ref car, ref cdr) =&gt; {
        ....
```


===

# C インターフェース
---------------------

* C FFI, C API共に1行
* 構造体なんかも互換

``` rust
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}
```

``` rust
#[no_mangle]
pub extern fn hello_rust() -&gt; *const u8 {
    &#34;Hello, world!\0&#34;.as_ptr()
}
```


===

# ランタイムなし
---------------

* [RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/)
* [Writing an OS in Rust](http://os.phil-opp.com/)
* [Redox - Your Next(Gen) OS](http://www.redox-os.org/)

===

# 生ポインタ
------------

* Cとのやりとりで大事
* あるいはパフォーマンスチューニングに

``` rust
pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}
```

``` rust
unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Vec&lt;T&gt;
```


===

# エラー処理
------------

* 例外じゃない
* [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html)
* `?` (元 `try!`)も便利
* Erro as a data
* 巻き戻し例外って扱い難しいよね
  + 値継続と例外継続の使い分けつらい

===

# リソースの話（本題）
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# リソースの重要性
-------------------

* プログラムはIOの塊、すなわりリソースの塊
* 従来は手動で管理するかGCで管理するかしていた
* RustはGCを使わず自動で管理する
* 所有権の概念が「ただの自動」以上に便利

===

# メモリ管理
------------

* Cでいう`free`を自動で挟んでくれる
* 基本

===

# Vecとslice
-------------

* sliceを`Vec`のviewとして使える
  + zero copy
  + 例えばJavaとかだと出来ない
* zero copy parserとかも書ける

===

# `File` 、 `Lock`
------------------

* `Drop`があるので自動
* ところでGCがあるのに手動で管理する言語があるらしいですね
  + 例えばRubyの`File.open(..) do ... end` も半手動
  + GCで処理すべきなのに手で`do ... end`を書いてる

===

# Rust
-------

``` rust
let file = File::open(&#34;text.txs&#34;).unwrap();
let mut br = BufReader::new(file);
...
```


===

# Java
-------
※try-with-resourceを使うともっと簡単に書けます。極端な比較のためにこう書いてます

``` java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader(&#34;test.txt&#34;));
    ...
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (br != null)
        try {
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
}
```

===

# Use after close
------------------

* プログラミングエラーの一種
* あらゆるリソースで起きうる
* GCのある言語ではメモリでのエラー **のみ** 防げる
* 他のリソースだとダメ
* Rustは **全ての** リソースで防げる

===

# Ruby
------

``` ruby
file = nil
File.open(&#34;file.rb&#34;) do |f|
  file = f
end
puts file.read

```

```
#&lt;File:file.rb (closed)&gt;
file.rb:6:in `read&#39;: closed stream (IOError)
        from file.rb:6:in `&lt;main&gt;&#39;
```


===

# Rust
-------

* 所有権のある限り勝手に`close`されない

``` rust
let mut file = None;
{
  let f = File::open(&#34;file.rs&#34;).unwrap();
  file = Some(f);
}
let mut s = String::new();
file.unwrap().read_to_string(&amp;mut s).unwrap();
println!(&#34;{}&#34;, s);
```

===

# ラッパーオブジェクト
--------------------

* 所有権便利って話

===

# Scala
------

``` scala
val kc = new KafkaProducer(...)
val sk = new SimpleKafkaClient(kc)
kc.close // &lt;- !?!?!?
...
```

===

# Rust
-------

``` rust
let kc = KafkaClient(...);
val mut sk = SimpleKafkaClient(kc);
kc.close(); // &lt;- Compile error because kc has been moved
```

===

# 責任者問題
-----------

* ラッパーオブジェクトの続き
* ラップされたオブジェクトは誰が閉じるの？


===

# Scala
------

``` scala
val kc = new KafkaProducer(...)
val sk = new SimpleKafkaClient(kc)
...
sk.close
kc.close // 本当に必要？
```

===

# Rust
-------

``` rust
let kc = KafkaClient(...);
val mut sk = SimpleKafkaClient(kc); // ここでmove
...
sk.close(); // moveされたskがcolseすることが型で分かる
```

===

# まとめ
--------

* Rust = 便利機能詰め合わせ + 所有権
* さらにランタイムもないしCとの相互連携も出来る
* リソース管理って大事
* 所有権は制限だけじゃないよ



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustの型レベルLispっぽいの作った</title>
      <link>/blog/2016/11/06/rustnokatareberulispppoinotsukutta</link>
      <pubDate>Sun, 06 Nov 2016 11:49:43 +0900</pubDate>
      
      <guid>/blog/2016/11/06/rustnokatareberulispppoinotsukutta</guid>
      <description>&lt;p&gt;κeenです。ふとした気紛れでRustの型レベルLispっぽいの作りました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;実装自体は&lt;a href=&#34;https://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/&#34;&gt;去年Scalaで作た時&lt;/a&gt;とほぼ同じ。
ただしRustでコンパイル時に文字列を処理しようとするとコンパイラプラグインが必要になるので今回はあきらめて素のRustの式のまま。&lt;/p&gt;

&lt;p&gt;こんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;println!(&amp;quot;{}&amp;quot;, eval!(List3&amp;lt;Add, _2, _3&amp;gt;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lisp…？感ありますがLispと言い張ります。&lt;/p&gt;

&lt;p&gt;少しだけ工夫した点はシンボルをアルファベットのListにすることで任意の文字列を表現出来るようにした点、関数を&lt;code&gt;Fun&lt;/code&gt; 、 &lt;code&gt;Fun2&lt;/code&gt; といったトレイトで抽象化することでユーザも関数を定義出来るようにした点です。&lt;/p&gt;

&lt;p&gt;例えばフィボナッチ数列は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub type Fib = Symbol&amp;lt;Sym3&amp;lt;F, I, B&amp;gt;&amp;gt;;

impl Fun1&amp;lt;_0&amp;gt; for Fib {
    type Out = _1;
}

impl Fun1&amp;lt;_1&amp;gt; for Fib {
    type Out = _1;
}

impl &amp;lt;T1N: Num, N1_O: Num, N2_O: Num, NO: Num&amp;gt;Fun1&amp;lt;Number&amp;lt;Succ&amp;lt;Succ&amp;lt;T1N&amp;gt;&amp;gt;&amp;gt;&amp;gt; for Fib
    where Fib: Fun1&amp;lt;Number&amp;lt;Succ&amp;lt;T1N&amp;gt;&amp;gt;, Out = Number&amp;lt;N1_O&amp;gt;&amp;gt;,
          Fib: Fun1&amp;lt;Number&amp;lt;     T1N &amp;gt;, Out = Number&amp;lt;N2_O&amp;gt;&amp;gt;,
          Add: Fun2&amp;lt;Number&amp;lt;N1_O&amp;gt;, Number&amp;lt;N2_O&amp;gt;, Out = Number&amp;lt;NO&amp;gt;&amp;gt;
{
    type Out = Number&amp;lt;NO&amp;gt;;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義出来ます。&lt;/p&gt;

&lt;p&gt;ただし、Rustの型検査が許す再帰深度がかなり小さいため、&lt;code&gt;List2&amp;lt;Fib, _6&amp;gt;&lt;/code&gt;で音を上げます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Compiling rustlisp v0.1.0 (file:///home/kim/Rust/rustlisp)
error[E0275]: overflow evaluating the requirement `_: std::marker::Sized`
 --&amp;gt; &amp;lt;rustlisp macros&amp;gt;:1:20
  |
1 | ( $ t : ty ) =&amp;gt; { &amp;lt;&amp;lt; $ t as Eval &amp;gt; :: Out as Expr &amp;gt; :: to_string (  ) }
  |                    ^^^^^^^^^^^^^^^^^^^^^^
src/main.rs:18:20: 18:41 note: in this expansion of eval! (defined in &amp;lt;rustlisp macros&amp;gt;)
&amp;lt;std macros&amp;gt;:2:27: 2:58 note: in this expansion of format_args!
&amp;lt;std macros&amp;gt;:3:1: 3:54 note: in this expansion of print! (defined in &amp;lt;std macros&amp;gt;)
src/main.rs:18:5: 18:43 note: in this expansion of println! (defined in &amp;lt;std macros&amp;gt;)
  |
  = note: consider adding a `#![recursion_limit=&amp;quot;128&amp;quot;]` attribute to your crate
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun1&amp;lt;rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::F, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::I, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::B, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::eval::Eval` for `rustlisp::cons::ConsCell&amp;lt;rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::F, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::I, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::B, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;, rustlisp::cons::ConsCell&amp;lt;rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;, rustlisp::cons::Nil&amp;gt;&amp;gt;`

error: aborting due to previous error

error: Could not compile `rustlisp`.

To learn more, run the command again with --verbose.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スタックを作ってどうこう、とかも考えたのですが上手くいきませんでした。悲しい。&lt;/p&gt;

&lt;p&gt;ということで小ネタでした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Scala 2.12.0変更点</title>
      <link>/slide/Scala_2_12_0henkouten/</link>
      <pubDate>Fri, 04 Nov 2016 13:19:01 +0900</pubDate>
      
      <guid>/slide/Scala_2_12_0henkouten/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Scala 2.12.0変更点
----------------------
サイバーエージェント ScalaMeetUp

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * AI Studio Dev Group
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# サマリー
----------
全部[公式ページ](http://www.scala-lang.org/news/2.12.0)に詳細あるよ

* Java8向けの互換性向上したよ
  + トレイトがinterfaceに
  + 無名関数がlambdaに
  + SAMとScalaの関数が統合
* コンパイラが少し賢くなったよ
  + いくつかでinvokedynamicを使うように
  + 中間状態をやめた
  + 最適化をするように
* ライブラリ改善した
  + EitherがRight Biasedに
  + Futureが強化
* 非互換いくつか


===

# トレイトがinterfaceに
-----------------------

``` scala
trait Foo {
  def foo(): String = &#34;foo&#34;
  def bar(): String
}
```

===

# トレイトがinterfaceに
-----------------------


```
$ scalac-2.11 Trait.scala
$ ls
Foo$class.class  Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public interface Foo {
  public abstract java.lang.String foo();
  public abstract java.lang.String bar();
}
$ javap &#39;Foo$class&#39;
Compiled from &#34;Trait.scala&#34;
public abstract class Foo$class {
  public static java.lang.String foo(Foo);
  public static void $init$(Foo);
}

```

===

# トレイトがinterfaceに
-----------------------

```
$ scalac-2.12 Trait.scala
$ ls
Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public interface Foo {
  public static java.lang.String foo$(Foo);
  public java.lang.String foo();
  public abstract java.lang.String bar();
  public static void $init$(Foo);

```

===

# 無名関数がlambdaに
-----------------------

```
class Foo {
  val f = () =&gt; &#34;string&#34;
}
```

===

# 無名関数がlambdaに
-----------------------


```
$ scalac-2.11 Trait.scala
$ ls
Foo$$anonfun$1.class  Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  public scala.Function0&lt;java.lang.String&gt; f();
  public Foo();
}
$ javap  &#39;Foo$$anonfun$1
Compiled from &#34;Trait.scala&#34;
public final class Foo$$anonfun$1 extends scala.runtime.AbstractFunction0&lt;java.lang.String&gt; implements scala.Serializable {
  public static final long serialVersionUID;
  public final java.lang.String apply();
  public final java.lang.Object apply();
  public Foo$$anonfun$1(Foo);
}

```

===

# 無名関数がlambdaに
-----------------------

```
$ scalac-2.12 Trait.scala
$ ls
Foo.class  Trait.scala
$ javap -p Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  private final scala.Function0&lt;java.lang.String&gt; f;
  public scala.Function0&lt;java.lang.String&gt; f();
  public static final java.lang.String $anonfun$f$1();
  public Foo();
  private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda);
$ javap -c -p Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  private final scala.Function0&lt;java.lang.String&gt; f;

  public scala.Function0&lt;java.lang.String&gt; f();
    Code:
       0: aload_0
       1: getfield      #19                 // Field f:Lscala/Function0;
       4: areturn

  public static final java.lang.String $anonfun$f$1();
    Code:
       0: ldc           #25                 // String string
       2: areturn

  public Foo();
    Code:
       0: aload_0
       1: invokespecial #29                 // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
       4: aload_0
       5: invokedynamic #49,  0             // InvokeDynamic #0:apply:()Lscala/Function0;
      10: putfield      #19                 // Field f:Lscala/Function0;
      13: return

  private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda);
    Code:
       0: aload_0
       1: invokedynamic #61,  0             // InvokeDynamic #1:lambdaDeserialize:(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;
       6: areturn
}
```

===

# SAMとScalaの関数が統合
-----------------------

関数をSingle Abstract Methodに出来る

```
scala&gt; val runRunnable: Runnable = () =&gt; println(&#34;Run!&#34;)
runRunnable: Runnable = $$Lambda$1073/754978432@7cf283e1
scala&gt; runRunnable.run()
Run!
```

JavaでLambdaが期待される箇所にScalaの無名関数を書ける

===

# SAMとScalaの関数が統合
-----------------------

逆に、JavaのLambdaでScalaの関数を作れる

```
public class A {
  scala.Function1&lt;String, String&gt; f = s -&gt; s.trim();
}
```

===

# 最適化
--------
とりあえずDead Code Elimination

```
class Foo {
  def add1(i: Int) = {
    val unused = 1 + i
    1 + i
  }

}

```

===

# 最適化
--------

```
$ scalac Trait.java
$ javap -c Foo
...
  public int add1(int);
    Code:
       0: iconst_1
       1: iload_1
       2: iadd
       3: istore_2
       4: iconst_1
       5: iload_1
       6: iadd
       7: ireturn
...
}

```

===

# 最適化
--------

```
$ scalac -opt:l:method Trait.java
$ javap -c Foo
...
  public int add1(int);
    Code:
       0: iconst_1
       1: iload_1
       2: iadd
       3: ireturn
...
```

===

# 非互換
--------

* Object initialization locks and lambdas
  + 無名関数が元のクラスのメソッドになったので変にデッドロックするかも
* Lambdas capturing outer instances
  + 無名関数が元のクラスのメソッドになったのでスコープが少し変わる
  + シリアライズに影響出るかも
* SAM conversion precedes implicits
  + SAM conversionとimplicit comversionだとSAMが優先される

===

# 非互換
--------

* SAM conversion in overloading resolution
  + なんか型が面倒になった
* Inferred types for fields
  + なんかよく分かんなかった
* Changed syntax trees (affects macro and compiler plugin authors)
  + 変わったらしい

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>VMwareのUbuntuを16.10にしたら起動しなくなった</title>
      <link>/blog/2016/10/31/vmwarenoubuntuwo16_10nishitarakidoushinakunatta</link>
      <pubDate>Mon, 31 Oct 2016 22:06:17 +0900</pubDate>
      
      <guid>/blog/2016/10/31/vmwarenoubuntuwo16_10nishitarakidoushinakunatta</guid>
      <description>&lt;p&gt;κeenです。普段はネイティブのUbuntuを使ってますが会社では使えないのでVMwareにUbuntuを入れて使っています。
今日そのUbuntuを16.04から16.10にアップグレードしたら起動しなくなったので対策メモ。&lt;/p&gt;

&lt;p&gt;
現象は、Ubuntuを起動しようとするとゲストOSによってCPUがオフにされた旨の通知が来てフリーズします。
このリリースノート（&lt;a href=&#34;http://pubs.vmware.com/Release_Notes/en/fusion/8/fusion-851-release-notes.html&#34;&gt;VMware Fusion 8.5.1 Release Notes&lt;/a&gt;）を見れば分かりますが、Linux Kernel 4.7以上を使うと発生するバグのようです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Known Issues&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Virtual machines running Linux kernel version 4.7 or above may crash or hang on hosts with Intel CPUs

Virtual Machines running Linux kernel version 4.7 or above may crash during installation or during power-on with a crash in the intel_powerclamp driver. This issue has been reported with Ubuntu 16.10, but it is a generic Linux kernel issue.

Workaround: VMware is working with the OS vendors to have them fix their respective kernels. Until a fix is available, you can blacklist the intel_powerclamp driver so that the buggy code doesn&#39;t get loaded.

To blacklist the driver:

Add the kernel command-line option modprobe.blacklist=intel_powerclamp to the guest OS&#39;s default grub configuration or add it directly at the grub menu during boot.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;どうやらIntel CPUのホストだと特定のカーネルモジュールが誤動作してCPUをoffってしまうっぽい？OSベンダと協力して直していくと言っているのでVMwareのアップデートでは直らなそう。OSのアップデートはそもそも起動しないので出来ない、というかなりキツい状況です。
幸いにもワークアラウンドがあるのでそれを使って起動、修正します。&lt;/p&gt;

&lt;h1 id=&#34;ubuntuの起動&#34;&gt;Ubuntuの起動&lt;/h1&gt;

&lt;p&gt;誤動作するカーネルモジュールをロードしないようにしたら起動するっぽいです。&lt;/p&gt;

&lt;p&gt;今OSがハングしている状態ならとりあえず殺して、 &lt;code&gt;ESC&lt;/code&gt; キー(多分。もしかしたら &lt;code&gt;Shift&lt;/code&gt; かも)を押しながらUbuntuを起動します。そうするとgrub menuの画面に遷移する筈です。&lt;/p&gt;

&lt;p&gt;grub menuで（恐らく1番上にある）使用中のカーネルに選択肢を合わせた状態で&lt;code&gt;e&lt;/code&gt;を押すと起動シーケンスをいじれるようになります。&lt;/p&gt;

&lt;p&gt;Emacsっぽく操作出来る画面が出てくるので&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	linux	/vmlinuz-4.4.0-45-generic root=/dev/mapper/ubuntu--vg-root ro  quiet splash $vt_handoff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにLinuxカーネルを起動してるっぽい行に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	linux	/vmlinuz-4.4.0-45-generic root=/dev/mapper/ubuntu--vg-root ro  quiet splash $vt_handoff modprobe.blacklist=intel_powerclamp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と &lt;code&gt;modprobe.blacklist=intel_powerclamp&lt;/code&gt; を追加してあげれば起動します。&lt;/p&gt;

&lt;h1 id=&#34;起動オプションの変更&#34;&gt;起動オプションの変更&lt;/h1&gt;

&lt;p&gt;とりあえず今のでワンショットで起動出来るようになったので起動オプションの設定を変更して次回以降も起動出来るようにしておきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/default/grub&lt;/code&gt; をいじれば良いようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GRUB_CMDLINE_LINUX=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の行をこれまた&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GRUB_CMDLINE_LINUX=&amp;quot;modprobe.blacklist=intel_powerclamp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と &lt;code&gt;modprobe.blacklist=intel_powerclamp&lt;/code&gt; を追加するように書き換えてあげて、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo update-grub2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でgrubに変更を反映してあげればOKです。&lt;/p&gt;

&lt;h1 id=&#34;その他&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;Ubuntu 16.10を1日使ってみましたが特に不自由なく使えています。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのクロージャ3種を作って理解する</title>
      <link>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</link>
      <pubDate>Mon, 10 Oct 2016 16:48:43 +0900</pubDate>
      
      <guid>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</guid>
      <description>&lt;p&gt;κeenです。Rustのクロージャ、3種類もあって複雑ですよね。
こういう複雑なものはRustの気持になって考えれば理解出来たりします。ということで手でクロージャを作って理解してみましょう。&lt;/p&gt;

&lt;p&gt;尚、これはRustの1.12.0-stableと1.14.0-nightly (6e8f92f11 2016-10-07)で実験しています。
&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;関数 - 関数&lt;/li&gt;
&lt;li&gt;無名関数 - 名前のついていない関数&lt;/li&gt;
&lt;li&gt;自由変数 - そのスコープの中で束縛されていない変数&lt;/li&gt;
&lt;li&gt;クロージャ - 関数に、自由変数の値(環境)もくっつけてそれだけで閉じるようにしたもの&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;クロージャについては関数が閉じ込める環境だけを指してクロージャとする人もいますが、ここでは関数本体と環境を合わせてクロージャとします。&lt;/p&gt;

&lt;p&gt;よく、無名関数とクロージャ(関数閉包)を一緒くたにすることがありますが明確に区別しましょう。まあ、大抵の無名関数はクロージャになりますが、動的スコープの言語みたいにそうならないケースもあります。&lt;/p&gt;

&lt;p&gt;余談ですが「ラムダ式」は言語がよく無名関数に付ける名前です。「関数」も言語によって「手続き」だったり「メソッド」だったりしますね。&lt;/p&gt;

&lt;h1 id=&#34;fnonce-fnmut-fn&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、「作って理解する」なので例を出します。なんかよく分からないけど0から9の値に1を足して印字するプログラムです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = |arg|{ i + arg };
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無名関数を作って &lt;code&gt;cls&lt;/code&gt; という変数に束縛しています。 &lt;code&gt;cls&lt;/code&gt; は自由変数 &lt;code&gt;i&lt;/code&gt; を含みますので、 &lt;code&gt;cls&lt;/code&gt; のクロージャを取ると 「&lt;code&gt;cls&lt;/code&gt; の定義 + &lt;code&gt;i&lt;/code&gt; の定義」になります。&lt;/p&gt;

&lt;p&gt;では &lt;code&gt;i&lt;/code&gt; という変数を保持したオブジェクトを作りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Closure {
    i: isize,
}


fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // もちろん、Closureは関数でないので呼び出せない
        // println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このままだと &lt;code&gt;cls&lt;/code&gt; は呼び出せません。しかし &lt;code&gt;+&lt;/code&gt; なんかのオーバーロードを許しているRustはなんと関数呼び出し構文 &lt;code&gt;name(arg, ...)&lt;/code&gt; もオーバーロード出来ます。実装すべきトレイトは &lt;code&gt;std::ops::{FnOnce, FnMut, Fn}&lt;/code&gt; です。これがクロージャ3種です。&lt;/p&gt;

&lt;p&gt;これらは継承関係にあって、上から順に &lt;code&gt;FnOnce&lt;/code&gt;  &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait FnOnce&amp;lt;Args&amp;gt; {
    type Output;
    extern &amp;quot;rust-call&amp;quot; fn call_once(self, args: Args) -&amp;gt; Self::Output;
}

pub trait FnMut&amp;lt;Args&amp;gt;: FnOnce&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, args: Args) -&amp;gt; Self::Output;
}

pub trait Fn&amp;lt;Args&amp;gt;: FnMut&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, args: Args) -&amp;gt; Self::Output;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらの違いは &lt;code&gt;self&lt;/code&gt; をムーブして受け取るか &lt;code&gt;&amp;amp;mut&lt;/code&gt; で受けるか &lt;code&gt;&amp;amp;&lt;/code&gt; で受けるかです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;とりあえず先程の &lt;code&gt;Closure&lt;/code&gt; にこれを実装してみましょう。ちょいとunstableな機能なようなので &lt;code&gt;feature&lt;/code&gt; を使って、nightlyでコンパイルするようにしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

// 再掲
struct Closure {
    i: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
    type Output = isize;

    extern &amp;quot;rust-call&amp;quot; fn call_once(self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.i + arg
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで呼び出しが出来る筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = Closure {i: i};
        // 呼出せるようになる
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;勿論、これは以下のように明示的にメソッドを呼んでも同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // メソッドで呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls.call_once((x, )));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fnmut-fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;FnOnce&lt;/code&gt; で出来るんならなんで &lt;code&gt;FnMut&lt;/code&gt; と &lt;code&gt;FnMut&lt;/code&gt; が存在するかというと、クロージャが閉じ込めた環境の所有権の問題ですね。&lt;/p&gt;

&lt;p&gt;例えば以下のコードを手で実装してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = |arg| { x + arg};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程と同じ &lt;code&gt;Closure&lt;/code&gt; ではコンパイル出来ません（統一感のために &lt;code&gt;Closure&lt;/code&gt; のメンバ名を変えました）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

struct Closure {
    x: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
  // ...略
}


fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = Closure {x: x};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error[E0382]: use of moved value: `cls`
  --&amp;gt; closure.rs:45:28
   |
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ value moved here in previous iteration of loop
   |
   = note: move occurs because `cls` has type `Closure`, which does not implement the `Copy` trait

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1回目のループでは問題ないのですが &lt;code&gt;call_once(self, (arg, ): (isize,))&lt;/code&gt; の呼び出しでムーブしてしまうので2回目以降は呼べません。ということで1つ下のトレイト、 &lt;code&gt;FnMut&lt;/code&gt; も実装してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl FnMut&amp;lt;(isize,)&amp;gt; for Closure {

    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はこれでも怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:45:28
   |
43 |         let cls = Closure {x: x};
   |             --- use `mut cls` here to make mutable
44 |         for i in 0..10 {
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ cannot borrow mutably

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;mut&lt;/code&gt; を要求しているから。正確にはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略


fn main() {
    let x = 1;
    // `mut` を付ける
    let mut cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。しかしまあ、何か書き換えてる訳でもないのに &lt;code&gt;mut&lt;/code&gt; が付いているのは嫌ですね。&lt;code&gt;mut&lt;/code&gt; を要求しないように定義してあげようと思ったら &lt;code&gt;Fn&lt;/code&gt; が必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl Fn&amp;lt;(isize,)&amp;gt; for Closure {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, (arg,): (isize, )) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。&lt;/p&gt;

&lt;h2 id=&#34;整理&#34;&gt;整理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;クロージャとは関数とその環境のセットだよ&lt;/li&gt;
&lt;li&gt;環境にも所有権はあるよ&lt;/li&gt;
&lt;li&gt;Rustは所有権でクロージャの呼び出しを使い分けるよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;構文&#34;&gt;構文&lt;/h1&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; に対応するRustの構文を探っていきます。&lt;/p&gt;

&lt;h2 id=&#34;fn&#34;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;先程 &lt;code&gt;Fn&lt;/code&gt; まで実装しないとコンパイルが通らなかった&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    let cls = |arg| { x + arg};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は &lt;code&gt;||{}&lt;/code&gt; でコンパイルが通っているので &lt;code&gt;||{}&lt;/code&gt; は &lt;code&gt;Fn&lt;/code&gt; を作るようです。&lt;/p&gt;

&lt;h2 id=&#34;fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;call_mut&lt;/code&gt; を要求しそうにちょっと変えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、予想通りエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:37:13
   |
35 |         let cls = |arg|{ x += arg };
   |             --- use `mut cls` here to make mutable
36 |         for i in 0..10 {
37 |             cls(i);
   |             ^^^ cannot borrow mutably

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let cls = |arg|{ x += arg };
   |                   -----  - previous borrow occurs due to use of `x` in closure
   |                   |
   |                   mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to 2 previous errors

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程の &lt;code&gt;FnMut&lt;/code&gt; の例のように &lt;code&gt;cls&lt;/code&gt; に &lt;code&gt;mut&lt;/code&gt; を付けてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let mut cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これでもエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let mut cls = |arg|{ x += arg };
   |                       -----  - previous borrow occurs due to use of `x` in closure
   |                       |
   |                       mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;cls&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; を捕捉し続けているから。これは &lt;code&gt;cls&lt;/code&gt; のライフタイムを &lt;code&gt;println!&lt;/code&gt; の前で終わらせてあげると解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    {
        // `{}` でスコープを作ることでライフタイムをコントロールする
        let mut cls = |arg|{ x += arg };
        for i in 0..10 {
            cls(i);
        }
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FnMut&lt;/code&gt; は変数を &lt;code&gt;mut&lt;/code&gt; にする無名関数と同じなようです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce-1&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; は？ &lt;code&gt;std::mem::drop&lt;/code&gt; を使って所有権を無理矢理奪うクロージャを作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::drop;

fn main() {
    let x = String::new();
    let cls = || {drop(x)};
    cls();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、実はこれでOKです。冷静に考えたら &lt;code&gt;FnOnce&lt;/code&gt; を継承している &lt;code&gt;Fn&lt;/code&gt; を &lt;code&gt;||{}&lt;/code&gt; で作れた時点で問題ありませんでしたね。&lt;/p&gt;

&lt;h1 id=&#34;落穂拾い&#34;&gt;落穂拾い&lt;/h1&gt;

&lt;h2 id=&#34;move-クロージャ&#34;&gt;&lt;code&gt;move&lt;/code&gt; クロージャ&lt;/h2&gt;

&lt;p&gt;じゃあ、Rustが良い感じに使い分けてくれるなら &lt;code&gt;move&lt;/code&gt; クロージャって何のためにあるの？と思いますが、これは環境を捕捉する際に &lt;code&gt;Copy&lt;/code&gt; なんかが起こらないようにするためのものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; しない例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; する例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt; は環境 &lt;strong&gt;へ&lt;/strong&gt; 所有権を移すかどうか、 &lt;code&gt;FnOnce&lt;/code&gt; などは環境 &lt;strong&gt;から&lt;/strong&gt; 所有権を移すかどうかです。&lt;/p&gt;

&lt;h2 id=&#34;関数ポインタ&#34;&gt;関数ポインタ&lt;/h2&gt;

&lt;p&gt;クロージャを持たない関数は、 &lt;code&gt;fn(i32) -&amp;gt; i32&lt;/code&gt; のような型を持ちます。これは空の環境を持つクロージャと同じですね。空の環境に所有権も何もないのでプリミティブの &lt;code&gt;fn&lt;/code&gt; は &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; のいずれとしても振舞います。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;p&gt;ここまで書いて普通にドキュメントに詳しく載っているのに気付きました（汗&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/functions.html&#34;&gt;関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>SMLでモナド</title>
      <link>/blog/2016/10/10/smldemonado</link>
      <pubDate>Mon, 10 Oct 2016 11:05:38 +0900</pubDate>
      
      <guid>/blog/2016/10/10/smldemonado</guid>
      <description>&lt;p&gt;κeenです。ML Workshop 2016でなんかSMLで型クラスする発表があったらしいので追ってみます。&lt;/p&gt;

&lt;p&gt;implicit parameterをexplicitに渡すのではなく、モジュールとファンクタを使った実装です。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;前置き&#34;&gt;前置き&lt;/h1&gt;

&lt;p&gt;Haskell風の中置演算子を使うので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;infix 4 &amp;lt;$&amp;gt; &amp;lt;$ $&amp;gt;  &amp;lt;*&amp;gt; &amp;lt;* *&amp;gt;
infix 1 &amp;gt;&amp;gt;= &amp;gt;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を予め宣言しておきます。&lt;/p&gt;

&lt;h1 id=&#34;最初の試み&#34;&gt;最初の試み&lt;/h1&gt;

&lt;p&gt;さて、(MLの機能の方ではない)functorを考えましょうか。functorには &lt;code&gt;fmap&lt;/code&gt; が要求され、&lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; なんかが実装されます。それを素直に表したらこうなるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature FUNCTOR_MIN = sig
    type &#39;a t
    val fmap: (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature FUNCTOR = sig
    include FUNCTOR_MIN
    val &amp;lt;$&amp;gt; : (&#39;a -&amp;gt; &#39;b) * &#39;a t -&amp;gt; &#39;b t
    val &amp;lt;$ : &#39;a *  &#39;b t -&amp;gt;  &#39;a t
    val $&amp;gt; : &#39;a t *  &#39;b  -&amp;gt;  &#39;b t
    val void: &#39;a t -&amp;gt; unit t
end

functor MkFunctor(Fun: FUNCTOR_MIN): FUNCTOR = struct
    open Fun

    fun f &amp;lt;$&amp;gt; fa = fmap f fa
    fun a &amp;lt;$ fb =  (fn _ =&amp;gt; a) &amp;lt;$&amp;gt; fb
    fun fa $&amp;gt; b = b &amp;lt;$ fa
    fun void fa = () &amp;lt;$ fa
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、さらにそのサブクラスのapplicativeも作ります。 &lt;code&gt;include&lt;/code&gt; を使うことで &lt;code&gt;FUNCTOR&lt;/code&gt; を継承することを表します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature APPLICATIVE_MIN = sig
    include FUNCTOR

    val pure: &#39;a -&amp;gt; &#39;a t
    val ap : (&#39;a -&amp;gt; &#39;b) t -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature APPLICATIVE = sig
    include APPLICATIVE_MIN

    val &amp;lt;*&amp;gt; : (&#39;a -&amp;gt; &#39;b) t * &#39;a t -&amp;gt; &#39;b t
    val *&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
    val &amp;lt;* : &#39;a t * &#39;b t -&amp;gt; &#39;a t
end

functor MkApplicative(App: APPLICATIVE_MIN): APPLICATIVE = struct
    open App

    fun af &amp;lt;*&amp;gt; aa = ap af aa
    fun aa *&amp;gt; ab = pure (fn _ =&amp;gt; fn x =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
    fun aa &amp;lt;* ab = pure (fn x =&amp;gt; fn _ =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにmonadも作りましょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature MONAD_MIN = sig
    include APPLICATIVE

    val bind : &#39;a t -&amp;gt; (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
end

signature MONAD = sig
    include MONAD_MIN

    val return: &#39;a -&amp;gt; &#39;a t
    val &amp;gt;&amp;gt;= : &#39;a t * (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
    val &amp;gt;&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
end


functor MkMonad(M: MONAD_MIN): MONAD = struct
    open M

    val return = pure
    fun ma &amp;gt;&amp;gt;= f = bind ma f
    fun ma &amp;gt;&amp;gt; mb = ma &amp;gt;&amp;gt;= (fn _ =&amp;gt; mb)

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと使ってみましょう。1つ1つインスタンスを作ってあげます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;structure OptionFunc = MkFunctor(
  struct
      type &#39;a t = &#39;a option
      fun fmap f = Option.map f
  end)

structure OptionApp = MkApplicative(
  struct
      open OptionFunc
      fun pure x = SOME(x)
      fun ap af aa = case (af, aa) of
                         (SOME(f), SOME(a)) =&amp;gt; SOME(f a)
                       | _ =&amp;gt; NONE
  end)

structure OptionMonad = MkMonad(
  struct
      open OptionApp
      fun bind ma f = case ma of
                          SOME(a) =&amp;gt; f a
                        | NONE =&amp;gt; NONE
  end)


local
    open OptionMonad
in
    fun add x y = x + y
    fun println s = print (s ^ &amp;quot;\n&amp;quot;)

    val ret1 = add &amp;lt;$&amp;gt; SOME(1) &amp;lt;*&amp;gt; SOME(2)
    val ret2 = SOME(1) &amp;gt;&amp;gt;= (fn x =&amp;gt;
               SOME(2) &amp;gt;&amp;gt;= (fn y =&amp;gt;
               return (x + y)))
    val () = Option.app (println o Int.toString) ret1 (* =&amp;gt; 3 *)
    val () = Option.app (println o Int.toString) ret2 (* =&amp;gt; 3 *)
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きました。&lt;/p&gt;

&lt;p&gt;さて、一見これで良さそうですがML Workshopでの発表では問題点を2点指摘しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Monadのインスタンスが欲しいだけなのにFunctorまで遡って作らないといけない&lt;/li&gt;
&lt;li&gt;ダイアモンド継承が起きた時に共通の親クラスの実装の一貫性を保障出来ない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とのことです。私はこの問題点自体割と疑問なのですがまあ、問題らしいです。&lt;/p&gt;

&lt;h1 id=&#34;解決案&#34;&gt;解決案&lt;/h1&gt;

&lt;p&gt;継承のやり方をちょいと変えます。&lt;code&gt;Functor&lt;/code&gt; までは先程と同じなのですが、Applicativeは
APPLICATIVE_MINにFUNCTORをincludeしません。また、衝突の問題から型が &lt;code&gt;applicative&lt;/code&gt;になります（同じと言っちゃいましたがFunctorの方も &lt;code&gt;functor_&lt;/code&gt; になってます）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature APPLICATIVE_MIN = sig
    type &#39;a applicative
    val pure: &#39;a -&amp;gt; &#39;a applicative
    val ap : (&#39;a -&amp;gt; &#39;b) applicative -&amp;gt; &#39;a applicative -&amp;gt; &#39;b applicative
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてAPPLICATIVEの方でincludeします。ここで &lt;code&gt;sharing&lt;/code&gt; 制約を付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature APPLICATIVE = sig
    include FUNCTOR APPLICATIVE_MIN
    sharing type functor_ = applicative

    val &amp;lt;*&amp;gt; : (&#39;a -&amp;gt; &#39;b) applicative * &#39;a applicative -&amp;gt; &#39;b applicative
    val *&amp;gt; : &#39;a applicative * &#39;b applicative -&amp;gt; &#39;b applicative
    val &amp;lt;* : &#39;a applicative * &#39;b applicative -&amp;gt; &#39;a applicative
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、 &lt;code&gt;APPLICATIVE_MIN&lt;/code&gt; から &lt;code&gt;FUNCTOR_MIN&lt;/code&gt; を生成するファンクタを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;functor ApplicativeMinToFunctorMin(A: APPLICATIVE_MIN): FUNCTOR_MIN = struct
    open A
    type &#39;a functor_ = &#39;a applicative
    fun fmap f = ap (pure f)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;applicativeからfunctor????感ありますがとりあえず進みます。&lt;/p&gt;

&lt;p&gt;で、 &lt;code&gt;MkApplicative&lt;/code&gt; は一旦内部で &lt;code&gt;Functor&lt;/code&gt; を作ってそれを &lt;code&gt;open&lt;/code&gt; します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;functor MkApplicative(App: APPLICATIVE_MIN): APPLICATIVE = struct
    type &#39;a applicative = &#39;a App.applicative

    structure FunctorMin = ApplicativeMinToFunctorMin(App)
    structure Functor = MkFunctor(FunctorMin)
    open App Functor

    fun af &amp;lt;*&amp;gt; aa = ap af aa
    fun aa *&amp;gt; ab = pure (fn _ =&amp;gt; fn x =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
    fun aa &amp;lt;* ab = pure (fn x =&amp;gt; fn _ =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モナドも同じですね。ただ、 &lt;code&gt;MONAD_MIN&lt;/code&gt; から &lt;code&gt;APPLICATIVE_MIN&lt;/code&gt; を生成する必要があるので &lt;code&gt;MONAD_MIN&lt;/code&gt; のシグネチャに &lt;code&gt;return&lt;/code&gt; が増えてます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature MONAD_MIN = sig
    type &#39;a monad
    val return: &#39;a -&amp;gt; &#39;a monad
    val bind : &#39;a monad -&amp;gt; (&#39;a -&amp;gt; &#39;b monad) -&amp;gt; &#39;b monad
end

signature MONAD = sig
    include APPLICATIVE MONAD_MIN
    sharing type applicative = monad
    val &amp;gt;&amp;gt;= : &#39;a monad * (&#39;a -&amp;gt; &#39;b monad) -&amp;gt; &#39;b monad
    val &amp;gt;&amp;gt; : &#39;a monad * &#39;b monad -&amp;gt; &#39;b monad
end

functor MonadMinToApplicativeMin(M: MONAD_MIN): APPLICATIVE_MIN = struct
    open M
    type &#39;a applicative = &#39;a monad
    val pure = return
    fun ap mf ma =  bind mf (fn f =&amp;gt;
                    bind ma (fn a =&amp;gt;
                    return (f a)))
end

functor MkMonad(M: MONAD_MIN): MONAD = struct
    type &#39;a monad = &#39;a M.monad
    structure AppMin = MonadMinToApplicativeMin(M)
    structure App = MkApplicative(AppMin)
    open M App

    fun ma &amp;gt;&amp;gt;= f = bind ma f
    fun ma &amp;gt;&amp;gt; mb = ma &amp;gt;&amp;gt;= (fn _ =&amp;gt; mb)

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと &lt;code&gt;ap&lt;/code&gt; の実装イケてないなぁと思いつつ先に進みます。&lt;/p&gt;

&lt;p&gt;さて、使ってみましょう。今度はファンクタの適用は一回で済みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;structure ListMonad = MkMonad(struct
                                   type &#39;a monad = &#39;a list
                                   fun return x = [x]
                                   fun bind ma f = List.concat (List.map f ma)
                              end)
local
    open ListMonad
in
    val ret = [1, 2, 3] &amp;gt;&amp;gt;= (fn x =&amp;gt;
              [4, 5, 6] &amp;gt;&amp;gt;= (fn y =&amp;gt;
              return (x + y)))
    fun println s = print (s ^ &amp;quot;\n&amp;quot;)

    val () = List.app (println o Int.toString) ret
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きます。
ご覧の通り、ファンクタの適用は1回で済んでますし、親クラスのインスタンス全て自分で生成しているので実装の一貫性も保障出来ます。ダイアモンド継承が来ても安心ですね！&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;私は最初のアプローチの方が好きですね（率直）。&lt;/p&gt;

&lt;p&gt;それぞれのクラスのインスタンスを作るのは自然だと思いますし実はWorkshopのアプローチは表層上の問題でダイアモンド継承を解決出来ていません。名前衝突が起きます。モジュールの名前衝突ならまだ気合で( &lt;code&gt;val &amp;gt;&amp;gt;= = Monad.&amp;gt;&amp;gt;=&lt;/code&gt; のように全て手で)解決出来ますが、シグネチャの方は解決策はなさそうです(いや、シグネチャを使わずに全て手で書き直すとかは可能ですが)。どうせ完全には解決出来てない問題のために実装が曲がるのは好みではないです。&lt;/p&gt;

&lt;h1 id=&#34;付録a-ダイアモンド継承に強そうなアプローチ&#34;&gt;付録A ダイアモンド継承に強そうなアプローチ&lt;/h1&gt;

&lt;p&gt;単純に親クラスのインクルードをやめます。んで親クラスは名前空間の汚染を防ぐためにモジュールに入ったまま受け取ることにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;infix 4 &amp;lt;$&amp;gt; &amp;lt;$ $&amp;gt;  &amp;lt;*&amp;gt; &amp;lt;* *&amp;gt;
infix 1 &amp;gt;&amp;gt;= &amp;gt;&amp;gt;

signature FUNCTOR_MIN = sig
    type &#39;a t
    val fmap: (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature FUNCTOR = sig
    include FUNCTOR_MIN
    val &amp;lt;$&amp;gt; : (&#39;a -&amp;gt; &#39;b) * &#39;a t -&amp;gt; &#39;b t
    val &amp;lt;$ : &#39;a *  &#39;b t -&amp;gt;  &#39;a t
    val $&amp;gt; : &#39;a t *  &#39;b  -&amp;gt;  &#39;b t
    val void: &#39;a t -&amp;gt; unit t
end

functor MkFunctor(Fun: FUNCTOR_MIN): FUNCTOR = struct
    open Fun

    fun f &amp;lt;$&amp;gt; fa = fmap f fa
    fun a &amp;lt;$ fb =  (fn _ =&amp;gt; a) &amp;lt;$&amp;gt; fb
    fun fa $&amp;gt; b = b &amp;lt;$ fa
    fun void fa = () &amp;lt;$ fa
end

signature APPLICATIVE_MIN = sig
    type &#39;a t
    val pure: &#39;a -&amp;gt; &#39;a t
    val ap : (&#39;a -&amp;gt; &#39;b) t -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature APPLICATIVE = sig
    include APPLICATIVE_MIN

    val &amp;lt;*&amp;gt; : (&#39;a -&amp;gt; &#39;b) t * &#39;a t -&amp;gt; &#39;b t
    val *&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
    val &amp;lt;* : &#39;a t * &#39;b t -&amp;gt; &#39;a t
end

functor MkApplicative(App: sig
                          structure Functor: FUNCTOR
                          include APPLICATIVE_MIN
                          sharing type Functor.t = t
                         end): APPLICATIVE = struct
    open App
    type &#39;a t = &#39;a t

    fun af &amp;lt;*&amp;gt; aa = ap af aa
    fun aa *&amp;gt; ab = pure (fn _ =&amp;gt; fn x =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
    fun aa &amp;lt;* ab = pure (fn x =&amp;gt; fn _ =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
end


signature MONAD_MIN = sig
    type &#39;a t
    val return: &#39;a -&amp;gt; &#39;a t
    val bind : &#39;a t -&amp;gt; (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
end

signature MONAD = sig
    include MONAD_MIN
    val &amp;gt;&amp;gt;= : &#39;a t * (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
    val &amp;gt;&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
end


functor MkMonad(M: sig
                    structure Applicative: APPLICATIVE
                    include MONAD_MIN
                    sharing type Applicative.t = t
                end): MONAD = struct
    open M
    type &#39;a t = &#39;a t

    fun ma &amp;gt;&amp;gt;= f = bind ma f
    fun ma &amp;gt;&amp;gt; mb = ma &amp;gt;&amp;gt;= (fn _ =&amp;gt; mb)

end


structure ListFunctor = MkFunctor(struct
                                       type &#39;a t = &#39;a list
                                       val fmap = List.map end)
structure ListApplicative = MkApplicative(struct
                                               structure Functor = ListFunctor
                                               type &#39;a t = &#39;a list
                                               fun pure x = [x]
                                               fun ap af aa = List.concat (List.map (fn a =&amp;gt; List.map (fn f =&amp;gt; f a) af) aa)
                                           end)
structure ListMonad = MkMonad(struct
                                   structure Applicative = ListApplicative
                                   type &#39;a t = &#39;a list
                                   fun return x = [x]
                                   fun bind ma f = List.concat (List.map f ma)
                               end)
local
    open ListFunctor
    open ListApplicative
    open ListMonad
in
    fun add x y = x + y
    val ret1 = [1, 2, 3] &amp;gt;&amp;gt;= (fn x =&amp;gt;
               [4, 5, 6] &amp;gt;&amp;gt;= (fn y =&amp;gt;
               return (x + y)))
    val ret2 = add &amp;lt;$&amp;gt; [1, 2, 3] &amp;lt;*&amp;gt; pure 1
    fun println s = print (s ^ &amp;quot;\n&amp;quot;)

    val () = List.app (println o Int.toString) ret1
    val () = List.app (println o Int.toString) ret2
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;付録b-do記法&#34;&gt;付録B do記法&lt;/h1&gt;

&lt;p&gt;ちょっと &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; が入り乱れるのはつらいですね。&lt;a href=&#34;https://github.com/br0ns/PreML&#34;&gt;PreML&lt;/a&gt;というSMLのプリプロセッサがあって、do記法（など）のシンタックスシュガーを提供してくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;val ret = do with ListMonad;
    x &amp;lt;- [1, 2, 3];
    y &amp;lt;- [4, 5, 6];
    return (x + y)
end
fun println s = print (s ^ &amp;quot;\n&amp;quot;)

val () = List.app (println o Int.toString) ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成されるコードはこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;val ret = let infix 0 &amp;gt;&amp;gt;= val op&amp;gt;&amp;gt;= = ListMonad.&amp;gt;&amp;gt;= val return = ListMonad.return in ( 
         [1, 2, 3] ) &amp;gt;&amp;gt;= (fn  x =&amp;gt; ( 
         [4, 5, 6] ) &amp;gt;&amp;gt;= (fn  y =&amp;gt; 
    return (x + y) ) ) end 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;マシになりましたね。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>正しいScalaのコードが欲しい</title>
      <link>/slide/tadashiiScalanoko_dogahoshii/</link>
      <pubDate>Wed, 05 Oct 2016 00:10:25 +0900</pubDate>
      
      <guid>/slide/tadashiiScalanoko_dogahoshii/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 正しいScalaのコードが欲しい
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
   + Scalaはあんまり
===
# Scalaを始めたばかりの頃の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===


``` scala
def revappend[A](
    xs: List[A],
    ys: List[A]): List[A] = match xs {
  case Nil =&gt; Nil
  case x::xs_ =&gt; revappend(xs_, x::ys)
}
```

===

``` scala
def length(xs: List[_]): Int = xs match {
  case Nil =&gt; Nil
  case x::xs_ =&gt; 1 + length(xs_)
}
```

===

``` scala
def append[A](
    xs: List[A],
    ys: List[A]): List[A] = xs match {
  case Nil =&gt; Nil
  case x::xs_ =&gt; x :: append(xs_, ys)
}

append(List(1, 2, 3), List(4, 5, 6))
// =&gt; List(1, 2, 3)

```

===
# Scalaを始めたばかりの頃の話
-----------------------------

* 正しくないコードばかり書いてしまう
  + 他の言語の構文と混ぜてしまう
  + 型エラー
  + 実装ミス
* 正しいScalaのコードが欲しい

===
# 正しさって？
-------------

* 構文が正しいコード?
* コンパイルが通るコード?
* バグのないコード？
  + テストが通るコード?

===
# 正しさって？
-----------

* 数学だったら？
* 数学なら証明されれば正しい
* プログラムの証明????

===
# Isabelle
----------

* 汎用証明支援系
* [Isabelle](https://isabelle.in.tum.de/)
* 結構昔からある
* 関数型言語 + 高階論理

===
# コード
--------

``` isabelle
datatype &#39;a list = Nil                 (&#34;[]&#34;)
  | Cons &#39;a &#34;&#39;a list&#34;    (infixr &#34;#&#34; 65)

primrec app :: &#34;&#39;a list =&gt; &#39;a list =&gt; &#39;a list&#34; (infixr &#34;@&#34; 65)
  where
  &#34;[] @ ys      = ys&#34; |
  &#34;(x # xs) @ ys = x # (xs @ ys)&#34;
```

===

# 証明
------

``` isabelle
lemma app_Nil2 [simp]: &#34;xs @ [] = xs&#34;
  apply(induct_tac xs)
  apply auto
  done

lemma app_assoc [simp]: &#34;(xs @ ys) @ zs = xs @ (ys @ zs)&#34;
  apply (induct_tac xs)
  apply auto
  done
```

===
# Extract
---------

```isabelle
export_code append
   in Scala
   module_name &#34;Example&#34;
   file &#34;Example.scala&#34;
```

===
# Scalaのコード
---------------

証明されたScalaのコードが手に入る

``` scala
object Example {

abstract sealed class list[A]
final case class Nila[A]() extends list[A]
final case class Cons[A](a: A, b: list[A]) extends list[A]

def append[A](x0: list[A], ys: list[A]): list[A] = (x0, ys) match {
  case (Nila(), ys) =&gt; ys
  case (Cons(x, xs), ys) =&gt; Cons[A](x, append[A](xs, ys))
}

} /* object Example */

```

===
# 余談
-------

他の言語にもextract出来る

```isabelle
export_code append
   in SML
   module_name &#34;Example&#34;
   file &#34;Example.sml&#34;
```


===
# まとめ
---------

* プログラムは証明出来るよ
* Isabelleで証明が出来るよ
* Isabelleで証明したら正しいScalaのコードが手に入るよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Pijulのインストールが難易度高いので解説する</title>
      <link>/blog/2016/09/29/pijulnoinsuto_ruganan_idotakainodekaisetsusuru</link>
      <pubDate>Thu, 29 Sep 2016 22:15:51 +0900</pubDate>
      
      <guid>/blog/2016/09/29/pijulnoinsuto_ruganan_idotakainodekaisetsusuru</guid>
      <description>&lt;p&gt;κeenです。ふとTwitterで&lt;a href=&#34;http://pijul.org&#34;&gt;Pijul&lt;/a&gt;の話題を見掛けたついでにインストールしようと思ったら難易度が高かったので解説します。
Pijulそのものについては&lt;a href=&#34;/blog/2016/02/14/dvcsnomoderu_aruihapijulnitsuite/&#34;&gt;過去のエントリ&lt;/a&gt;を参照して下さい。&lt;/p&gt;

&lt;p&gt;因みにPijulは「ピーフール」みたいに発音するそうです。「フー」は喉の奥から出す破擦音ですね。&lt;/p&gt;

&lt;p&gt;
まず、公式ドキュメントには &lt;code&gt;cargo install pijul&lt;/code&gt; すると書いてますが、これはバージョン0.1、古いやつな上にビルドに失敗します。
ということでソースからビルドするのですがビルドガイドがないので非常に難しいです。コマンドだけ載せてしまうと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ darcs get https://pijul.org
$ cd pijul.org/pijul
$ cp -R ../libpijul src
$ cd src/libpijul/src
$ darcs get https://pijul.org/sanakirja
$ cd ../../../
$ cargo install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。これだと常に最新版をビルドしてしまいますがdarcsでタグを指定する方法が分からなかったのでこれで。
あ、あと&lt;code&gt;darcs get https://pijul.org/sanakirja&lt;/code&gt;でnested repositoryで怒られますがそれもよく分からなかったのでそのまま。
darcsに馴れてる方は好きにして下さい。&lt;/p&gt;

&lt;p&gt;因みにその後のコマンドはちゃんと動くので&lt;a href=&#34;http://pijul.org/documentation/getting-started/&#34;&gt;公式ガイド&lt;/a&gt;に従えば使えます。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustでシェル作った</title>
      <link>/blog/2016/09/04/rustdeshierutsukutta</link>
      <pubDate>Sun, 04 Sep 2016 16:26:20 +0900</pubDate>
      
      <guid>/blog/2016/09/04/rustdeshierutsukutta</guid>
      <description>&lt;p&gt;κeenです。
先日、先輩社員と話してるとシェルを作る話になりました。
だいたいのコンピュータサイエンスの学生なら学部生の頃に課題でシェルを作りますが数学科にいた私は作ったことありませんでした。
でも、その時「今ならシェルなんて作ろうと思えばすぐに作れますよ」なんて言っちゃったのでなんか作りました。
まあ、習作程度の雑なものです。&lt;/p&gt;

&lt;p&gt;
作ったのはこれ、&lt;a href=&#34;https://github.com/KeenS/igaguri&#34;&gt;KeenS/igaguri: my toy shell written in Rust&lt;/a&gt;。
名前は、Shellは木の実を覆う殻のようにカーネルを覆う殻とのことなのでRustのロゴに似てる毬栗を選びました。&lt;/p&gt;

&lt;h1 id=&#34;パーサ&#34;&gt;パーサ&lt;/h1&gt;

&lt;p&gt;パーサコンビネータライブラリの&lt;a href=&#34;https://github.com/Geal/nom&#34;&gt;nom&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;雰囲気こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;named!(token&amp;lt;String&amp;gt;, map!(map_res!(is_a!(&amp;quot;abcdefghijklmnopqlrstuvwxyzABCDEFGHIJKLMNOPQLRSTUVWXYZ-!$%^&amp;amp;@/1234567890&amp;quot;), str::from_utf8), |i: &amp;amp;str| i.to_string()));
named!(pipe, tag!(&amp;quot;|&amp;quot;));
named!(redirect_out&amp;lt;String&amp;gt;, chain!(tag!(&amp;quot;&amp;gt;&amp;quot;) ~ opt!(multispace) ~ filename: token, || filename));

named!(command&amp;lt;Ast&amp;gt;, chain!(
    opt!(multispace)
        ~ cmd: separated_list!(multispace, token)
        ~ outfile: opt!(chain!(multispace ~ out: redirect_out, || out))
        ~ opt!(multispace), || Ast::Command{cmd: cmd, out: outfile}));
named!(parse&amp;lt;Ast&amp;gt;, map!(separated_list!(pipe, command), Ast::Pipe));

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;入力ハンドリング&#34;&gt;入力ハンドリング&lt;/h1&gt;

&lt;p&gt;readlineのRust実装、&lt;a href=&#34;https://github.com/kkawakam/rustyline&#34;&gt;rustyline&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;それっぽいからとりあえず、で選んだものの、複数行入力（履歴）とか考えるともうちょっとリッチなものを選んだ方が良かったかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;実行&#34;&gt;実行&lt;/h1&gt;

&lt;p&gt;最初、&lt;a href=&#34;https://github.com/rust-lang/libc&#34;&gt;libcバインディング&lt;/a&gt;の &lt;code&gt;pipe&lt;/code&gt; や &lt;code&gt;fork&lt;/code&gt; 、 &lt;code&gt;execve&lt;/code&gt; なんかを考えてましたが、標準ライブラリの &lt;a href=&#34;https://doc.rust-lang.org/std/process/struct.Command.html&#34;&gt;&lt;code&gt;std::process::Command&lt;/code&gt;&lt;/a&gt;で実現出来そうだったのでそれを使いました。&lt;/p&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Command::new(cmd)
    .args(&amp;amp;terms)
    .stdin(stdin)
    .stdout(stdout)
    .stderr(stderr)
    .spawn()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パイプ-リダイレクト&#34;&gt;パイプ/リダイレクト&lt;/h2&gt;

&lt;p&gt;一応、パイプも標準ライブラリでサポートされてるのでそれを使いました。&lt;/p&gt;

&lt;p&gt;ただ、普通のCとは違って子プロセスと親プロセスの間に一旦パイプを作って、子プロセスの出力の生のfdを取り出して、次の子プロセスの入力に与えて、と案外面倒でした。 &lt;code&gt;unsafe&lt;/code&gt; も出てくれば &lt;code&gt;unreachable&lt;/code&gt; も出てくるのでもう少し書き直したい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut si = stdin;
let mut itr = commands.into_iter().peekable();
unsafe {
    while let Some(command) = itr.next() {
        if itr.peek().is_some() {
            let process =
                try!(self.run(command, si, Stdio::piped(), Stdio::inherit()));
            si = Stdio::from_raw_fd(process.stdout.unwrap().into_raw_fd());
        } else {
            return self.run(command, si, stdout, stderr);
        }
    }
}
unreachable!()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リダイレクトも似たようなもので、ファイルを作って生のfdを取り出して、とやります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let stdout = out.map(|f| {
    unsafe {
        let file = File::create(f)
        // FIXME: do not panic
            .unwrap();
        Stdio::from_raw_fd(file.into_raw_fd())
    }

}).unwrap_or(stdout);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;昨日の夜からちょろっと作り始めてさっきそれっぽく動くようになった程度なのでまだ適当にしか動きません。
パイプと標準出力のリダイレクトだけで、 &lt;code&gt;cd&lt;/code&gt; なんかのシェルコマンドもなければシェル変数もありません。
が、そろそろ飽きたのでこの辺で。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そろそろ飽きてきた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/772334565264232454&#34;&gt;2016年9月4日&lt;/a&gt;&amp;lt;/
blockquote&amp;gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;シェルコマンドとシェル変数くらいはいつか実装しようかな。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>mirah 0.2がリリースされました。</title>
      <link>/blog/2016/08/11/mirah_0_2gariri_susaremashita</link>
      <pubDate>Thu, 11 Aug 2016 15:32:39 +0900</pubDate>
      
      <guid>/blog/2016/08/11/mirah_0_2gariri_susaremashita</guid>
      <description>&lt;p&gt;κeenです。久しぶりに&lt;a href=&#34;mirah.org&#34;&gt;mirah&lt;/a&gt;のリリースが出ましたので新機能の紹介をしたいと思います。&lt;/p&gt;

&lt;p&gt;リリース版のダウンロードは &lt;a href=&#34;https://github.com/mirah/mirah/releases/tag/0.2.0&#34;&gt;こちら&lt;/a&gt;から。
&lt;/p&gt;

&lt;h1 id=&#34;のセマンティクス変更&#34;&gt;&lt;code&gt;==&lt;/code&gt; のセマンティクス変更&lt;/h1&gt;

&lt;p&gt;Rubyに合わせて、 &lt;code&gt;==&lt;/code&gt; が等価性、 &lt;code&gt;===&lt;/code&gt; が同値性の比較になりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;import java.net.URL

puts &amp;quot;1 == 1 =&amp;gt; #{1 == 1}&amp;quot;
puts &amp;quot;1 === 1 =&amp;gt; #{1 === 1}&amp;quot;
x = 1; puts &amp;quot;x = 1&amp;quot;
puts &amp;quot;x == x =&amp;gt; #{x == x}&amp;quot;
puts &amp;quot;x === x =&amp;gt; #{x === x}&amp;quot;
puts &amp;quot;URL.new(\&amp;quot;http://hoge.com\&amp;quot;) == URL.new(\&amp;quot;http://hoge.com\&amp;quot;) =&amp;gt; #{URL.new(&amp;quot;http://hoge.com&amp;quot;) == URL.new(&amp;quot;http://hoge.com&amp;quot;)}&amp;quot;
puts &amp;quot;URL.new(\&amp;quot;http://hoge.com\&amp;quot;) === URL.new(\&amp;quot;http://hoge.com\&amp;quot;) =&amp;gt; #{URL.new(&amp;quot;http://hoge.com&amp;quot;) === URL.new(&amp;quot;http://hoge.com&amp;quot;)}&amp;quot;
x = URL.new(&amp;quot;http://hoge.com&amp;quot;); puts &amp;quot;x = URL.new(\&amp;quot;http://hoge.com\&amp;quot;)&amp;quot;
puts &amp;quot;x == x =&amp;gt; #{x == x}&amp;quot;
puts &amp;quot;x === x =&amp;gt; #{x === x}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1 == 1 =&amp;gt; true
1 === 1 =&amp;gt; true
x = 1
x == x =&amp;gt; true
x === x =&amp;gt; true
URL.new(&amp;quot;http://hoge.com&amp;quot;) == URL.new(&amp;quot;http://hoge.com&amp;quot;) =&amp;gt; true
URL.new(&amp;quot;http://hoge.com&amp;quot;) === URL.new(&amp;quot;http://hoge.com&amp;quot;) =&amp;gt; false
x = URL.new(&amp;quot;http://hoge.com&amp;quot;)
x == x =&amp;gt; true
x === x =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ビルトインmacroの追加&#34;&gt;ビルトインMacroの追加&lt;/h1&gt;

&lt;h2 id=&#34;キャスト&#34;&gt;キャスト&lt;/h2&gt;

&lt;p&gt;今まで、Mirahのキャスト構文は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;int(0.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように関数呼び出しっぽい形式でしたが、この度 &lt;code&gt;as!&lt;/code&gt; マクロが追加されたので以下のように書けるようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;puts &amp;quot;0.5.as!(int) =&amp;gt; #{0.5.as!(int)}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0.5.as!(int) =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;synchronize&#34;&gt;Synchronize&lt;/h2&gt;

&lt;p&gt;javaの &lt;code&gt;Lock&lt;/code&gt; の &lt;code&gt;lock&lt;/code&gt; , &lt;code&gt;unlock&lt;/code&gt; を &lt;code&gt;sychronize&lt;/code&gt; マクロでラップしました。Javaのビルトインの &lt;code&gt;synchronized&lt;/code&gt; ではない模様。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;import java.util.concurrent.locks.ReentrantLock
lock = ReentrantLock.new
counter = 0
th1 = Thread.new do
  100.times do
    lock.synchronize do
      counter += 1
    end
  end
end

th2 = Thread.new do
  100.times do
    lock.synchronize do
      counter -= 1
    end
  end
end

th1.run
th2.run
th1.join
th2.join
puts &amp;quot;counter = #{counter}&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;counter = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;private&#34;&gt;&lt;code&gt;private&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;private def my_method
  puts &amp;quot;foo&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいに書けるようになりました。&lt;/p&gt;

&lt;h2 id=&#34;ラッパークラスの演算子&#34;&gt;ラッパークラスの演算子&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;int&lt;/code&gt; に対する &lt;code&gt;Integer&lt;/code&gt; のようなラッパークラスにも演算子マクロが定義されるようになました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;b = Integer.new(1); puts &amp;quot;b = Integer.new(1)&amp;quot;
b += 1;puts &amp;quot;b += 1&amp;quot;
puts &amp;quot;a &amp;lt; b =&amp;gt; #{a &amp;lt; b}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;a &amp;lt; b =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にも色々と定義されているようです。&lt;/p&gt;

&lt;h1 id=&#34;改善&#34;&gt;改善&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Javaのバイトコードを吐くライブラリasmのバージョンが5になりました。&lt;/li&gt;
&lt;li&gt;コンパイラのの内部で使っているロガーをマクロで書き直すことでDebug出力しない時のコンパイラの速度が速くなりました(確かこの変更が入った時に20%速くなるって言ってたような)。&lt;/li&gt;
&lt;li&gt;マクロが&lt;a href=&#34;http://www.ne.jp/asahi/hishidama/home/tech/java/jar.html#h_Service_Provider&#34;&gt;サービスプロバイダ&lt;/a&gt;の仕組みに乗っかるようになりました。
マクロを使うには今までマクロを定義したmirahのソースコードを一緒にコンパイルしないといけなかったのが、Mirahコンパイラがクラスパスから捜すようになったのでJarによる配布が現実的になりました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;マクロ周りが便利になるなど、興味深い変更がありましたね。
みなさんもこれを機にmirahを使ってみて下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>私がコードを書くときテストは書かない</title>
      <link>/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai</link>
      <pubDate>Tue, 02 Aug 2016 00:12:22 +0900</pubDate>
      
      <guid>/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai</guid>
      <description>&lt;p&gt;ちょっとポエムというか自分語りを。会社の同期と話してて少し刺激されたので。あとは&lt;a href=&#34;https://note.mu/ruiu/n/n1083b2a5d547&#34;&gt;ソースコードって実際のところどういうふうに書いていますか？｜Rui Ueyama｜note&lt;/a&gt;にも刺激されて。

発端は同期が最近は何か書いてもイケてなくて後で丸っと書き直すことが多くてつらい、という話を始めたこと。
自分は、そんなの普通だろと返した。少なくとも自分の中では当たり前だった。
ふと考えてみたらそうじゃない人も沢山いる気がした。当たり前じゃない人に、自分の当たり前を喋ってみたら面白そうということで自分がコードを書くときにやることを語る。&lt;/p&gt;

&lt;p&gt;コードを書き始めた時点では仕様は完全には固まっていない。アプリケーションの構成とかは決まってるけど、ソフトウェアの中身はほとんど何も決まっていない。
まずは手を着けやすそうな所から始める。最初は必ずHello Worldから。そしてmainの中にPoCを書いてイメージを掴む。
そこから一気に飛躍して、ディレクトリ構成を決める。mainは三枚下ろしにして各ディレクトリ下に入れる。これでアプリケーションの骨格が見える。ここまでトップダウン。この状態でアプリケーションを走らせるとPoCが動く。&lt;/p&gt;

&lt;p&gt;次はボトムアップのフェーズで、骨格に肉付けしていく。1度に考えることが一箇所で済むように、順番を考えながら気儘にコードを加えていく。だいたいデータアクセス層のインターフェース、データアクセス層の実装のスタブ、サービス層のスタブ、メインルーチン、サービス層、くらいの順番。抽象すると必要そうなものを定義する、定義したものを使う、定義したものを実装する。多少型が違ってコンパイルが通らなくても気にしない。エラー処理やエッジケースは全部スタブのまま。コードのあちこちに &lt;code&gt;FIXME&lt;/code&gt; が散らばる。条件分岐の枝は全ては書かない。頭のコンテキストスイッチで死んでしまう。集中したい枝以外はFIXMEで埋める。こんなもんかな、と思ったところでちゃんとコンパイルが通るように修正する。ここまでテスト無し、データアクセス層の実装無し。&lt;/p&gt;

&lt;p&gt;ここからようやく永続データのスキーマやアプリケーションの仕様を決める。コードを見ればどういうデータにパターンでアクセスして、どういうエッジケースがあるかが分かるからサクサク決まる。&lt;/p&gt;

&lt;p&gt;データのスキーマが決まったので最後データアクセス層を実装出来る。そしたら動くものが完成する。動いたものをポチポチやってみて実装が正しいことを確認する。&lt;/p&gt;

&lt;p&gt;このまま細かい実装を詰めていくかというとそうならない。仕様を見て、コードを見て、イケてない所を全部書き直す。まずはインターフェースを変える、型を変える。意図的にコードを壊す。あとはコンパイルエラーで修正箇所が全て分かる。ついでにFIXMEも片付けていく。エラーが取れてアプリケーションが再度動くようになったら、リファクタの完了。納得のいくコードになっている筈。ここでようやく仕様を固定するためにテストを書く。全てのコードが出来てからテストを書くからホワイトボックスに近いテストになる。&lt;/p&gt;

&lt;p&gt;どうしてこのようなプロセスを経るかと考えてみた。ポールグレアムも言っているように、私にとってのアプリケーションは、アプリケーションのドメインを記述するための巨大な言語（ライブラリ）と、それを使った非常に小さな実装からなる。
そして言語と実装の境界は何度も押したり引いたりしてようやく固まる。この手順は境界が固まるまでの過程だ。DSLを作るにはまずどのようなAPIがあれば便利か理解する必要がある。理解するのに一番手っ取り早い方法は一旦実装してみることだ。
ある人は言うだろう、「何を七面倒な。最初からちゃんと設計していれば手戻りがないものを。」と。違う。こういうときに私はよく詰将棋を引き合いに出す。
新聞の片隅にある詰将棋を解いてみる。新聞とにらめっこしてアレコレ考えても中々上手くいかない。
ところが将棋盤を引っ張り出してきて、パチパチ駒を動かしてみると簡単に解けることがある。ここは実は銀を持っていた、ここで馬が効くからこの手は指せない。
人間先を読むには想像力が足りなすぎる。目の前に現物がないと気付けないことが多い。だから先に実装する。一度作ってしまえば壊してもコンパイラが助けてくれる。&lt;/p&gt;

&lt;p&gt;一度目でアタリを付ける。二度目で実線を書く。作って、壊して、また作る。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>型クラスを越えて</title>
      <link>/slide/katakurasuwokoete/</link>
      <pubDate>Sat, 16 Jul 2016 02:53:49 +0900</pubDate>
      
      <guid>/slide/katakurasuwokoete/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 型クラスを越えて
----------------------
[歌舞伎座.tech#10「型クラス勉強会」](http://kbkz.connpass.com/event/32420/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# Rustとは
----------

* システムプログラミング言語
* GCなし！でもメモリ管理は自動
* **Zero-Cost Abstraction**
* **Trait-Based Generics**
* パターンマッチ、代数的データ型などなど
* [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/README.html)

===
# Rustのトレイト的なの
----------------

* 型に固有のメソッド
  + オブジェクト指向的な
* トレイト
  + 型クラス

===
# 型クラスじゃない方
-------------------

``` rust
struct Person {
  name: String,
}
impl Person {
  // Static constructor
  fn new(name: String) -&gt; Self {
    Person{name: name}
  }

  // method
  fn hello(&amp;self) {
    println!(&#34;Hello, {}&#34;, self.name);
  }
}
```

===
``` rust
let person = Person::new(&#34;κeen&#34;);
person.hello();
```

===
# 多相型と制約
--------------

``` rust
struct Temp&lt;T&gt;(T);

impl &lt;T: Celsius&gt; Temp&lt;T&gt; {
  fn fromCelsius(t: isize) -&gt; Self {
    Temp(Celsius(t))
  }
}

impl &lt;T: Fahrenheit&gt; Temp&lt;T&gt; {
  fn fromFahrenheit(t: isize) -&gt; Self {
    Temp(Fahrenheit(t))
  }
}

```

===
# 型クラス
---------

* 便利
* 他の言語にも取り入れてほしい
* 型クラスを入れることで言語設計がどうなるか
* ユーザランドより言語機能的な部分フォーカス

===
# Rustの型クラスの実装
---------------------

* 動的ディスパッチと静的ディスパッチ両方がある
* 動的ディスパッチ
  + implicit parameterを渡すやつ
* 静的ディスパッチ
  + コンパイル時に解決してしまうやつ
* デフォフォルト静的
  + 動的を選ぶことも出来る

===
# 静的ディスパッチの意味
-----------------------

* Zero-Cost Abstraction
* ユーザはパフォーマンスのために設計を曲げる必要がなくなる
* インライン化などの最適化も出来る
* 逆の見方をすればZero-Cost Abstraction出来るからシステムプログラミング言語に高級な機能を入れれた

===
# 型クラス+α
-----------
それぞれ面白い特徴が。

* `FromStr`
* `Write`
* `Add`
* `Default`, `Zero`
* `Iterator`

===
# 型クラス+関数
--------------

* 関連関数
* `FromStr`
* static関数的なものになる

```rust
pub trait FromStr {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
```

===
``` rust
use std::str::FromStr;

let s = &#34;5&#34;;
let x = i32::from_str(s).unwrap();

assert_eq!(5, x);
```

===
# 型クラス+構文
--------------

* = メソッド
* 第一引数が `self` な関数はメソッド構文で呼び出せる
* クラスがなくても継承がなくてもオブジェクト指向
* `Write`

``` rust
trait Write {
  fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
}
```

===
``` rust
impl Write for Foo {
  fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt; {
    ...
  }
}

let foo = Foo::new();
foo.write(aa);
```

===
# 型クラス+UFCS
---------------

* = 実質オーバーロード
* 中身の違うメソッドを複数定義出来る
* どのメソッドを呼ぶかを決定する構文がある
  + = Universal Function Call Syntax

===
```rust
trait Foo {
    fn foo() -&gt; i32;
}

struct Bar;

impl Bar {
    fn foo() -&gt; i32 {
        20
    }
}

impl Foo for Bar {
    fn foo() -&gt; i32 {
        10
    }
}

```
===

```rust
&lt;Bar as Foo&gt;::foo();
Bar::foo();
```


===
# 型クラス+演算子
-----------------

* = 演算子オーバーロード
* `Add`

``` rust
pub trait Add&lt;RHS = Self&gt; {
    type Output;
    fn add(self, rhs: RHS) -&gt; Self::Output;
}
```

===

``` rust
use std::ops::Add;

struct Foo;

impl Add for Foo {
    type Output = Foo;

    fn add(self, _rhs: Foo) -&gt; Foo {
        println!(&#34;Adding!&#34;);
        self
    }
}

fn main() {
    Foo + Foo;
}
```
===
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;for (my_int i = 0; i &amp;lt; 10; i++) { … }&lt;br&gt;&lt;br&gt;Cならどういうアセンブリに落ちるかすぐわかるけどC++ならmy_intはクラスかもしれず=0はコンストラクタを起動し&amp;lt;はメソッド呼び出しになり++はejectを発行して光学ディスクトレイが開き相手は死ぬ&lt;/p&gt;&amp;mdash; わさびず &lt;a href=&#34;https://twitter.com/___yuni/status/681891856335032320&#34;&gt;2015年12月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 型クラス+値
-------------

* = 関連定数
* unstable...
* `Zero`, `Default`

``` rust
// current
pub trait Zero {
    fn zero() -&gt; Self;
}
```

``` rust
// ideal
#![feature(associated_consts)]
pub trait Zero {
    const ZERO: Self;
}
```

===
```rust
trait Monoid: Add&lt;Self&gt; + Zero
  where Self::Output : Add&lt;Self&gt; + Zero {
}

```

===
# 型クラス+型
-------------

* 関連型
* 型族…？
  + あまり違いを分かっていない
  + 関連型を持った型をまとめたのが型族？
* `Iterator`

```rust
pub trait Iterator {
  type Item;
  ....
}
```

===
``` rust
trait Iterator {
  ...
  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
```

===
# 型クラス+暗黙のルール
---------------------

* オーバーライド
* `Drop`
  + 暗黙に呼ばれるデストラクタをオーバーライド出来る

```rust
pub trait Drop {
    fn drop(&amp;mut self);
}
```

===
``` rust
impl Drop for Lock {
    fn drop(&amp;mut self) {
        self.free();
    }
}
```

===
# 型クラス+アノテーション
------------------------

* 単純に便利
* `derive`(`Debug` , `Eq`)

``` rust
#[derive(Debug, Eq)]
struct Foo(usize);
```

===

``` rust
let foo1 = Foo(1);
let foo2 = Foo(2);
println!(&#34;{:?} == {:?} ?: {:?}&#34;,
         foo1,
         foo2,
         foo1 == foo2);
```

===
# まとめ
--------

* 型クラスは便利だよ
* 型クラスの実装は効率的に出来るよ
* 型クラスを使うと言語設計も変わるよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>