<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Fri, 19 May 2017 20:51:46 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>非同期とノンブロッキングとあと何か</title>
      <link>/blog/2017/05/19/hidoukitononburokkingutoatonanika</link>
      <pubDate>Fri, 19 May 2017 20:51:46 +0900</pubDate>
      
      <guid>/blog/2017/05/19/hidoukitononburokkingutoatonanika</guid>
      <description>&lt;p&gt;κeenです。最近同期/非同期、ブロッキング/ノンブロッキング、直接形式/継続渡し形式あたりが混乱してきたので個人的に整理します。
あくまで私個人の理解を纏めただけなので誤謬などに注意して下さい。&lt;/p&gt;

&lt;p&gt;追記: &lt;a href=&#34;https://twitter.com/tanaka_akr&#34;&gt;@tanaka_akr&lt;/a&gt;さんから&lt;a href=&#34;https://twitter.com/tanaka_akr/status/865722507281580032&#34;&gt;指摘&lt;/a&gt;されたのですが、用語の説明が間違っていそうだったので書き直しました。
diffは&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/commit/d46dad5282436eeaa615f31c160f892e6c724403&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;非同期とノンブロッキングはよく混同されます。また、非同期処理の記述形式として直接形式や継続渡し形式などがあります。
私自身違う言葉だなとは思いつつも混同したり違いを忘れたりしています。
非同期もノンブロッキングもナイーブなIOに比べると速い方式だな程度の理解でいてそんなに困らないと思ってますし混同や誤用に目くじらを立てるつもりもありません。
しかしながら3者を区別しないと意味を成さない文脈で3者を混同している技術を何度か見掛けたので（自分の中で）整理しようと思ったのがこの記事を書こうと思ったきっかけです。&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;p&gt;色々と調べましたが、&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html&#34;&gt;The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition&lt;/a&gt;の定義を使います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_77&#34;&gt;ブロッキング&lt;/a&gt;:
IO操作で、操作する前に待ちが発生するという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_240&#34;&gt;ノンブロッキング&lt;/a&gt;:
IO操作で、操作する前に待ちが発生しそうなら即座に関数から返るという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_378&#34;&gt;同期&lt;/a&gt;:
IO操作で、操作が終わるまでブロックするという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_29&#34;&gt;非同期&lt;/a&gt;:
IO操作で、IO操作を発効したスレッド自体がブロックせずに別のCPU処理を行えるという性質&lt;/li&gt;
&lt;li&gt;IOの多重化: 複数のfdに対して監視を行ない、ブロックせずに操作可能なfdを通知する仕組み。
調べると「複数のfdに対してブロックできる」という記述があるのですがノンブロッキングなオプションもありますよね&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらはどのようにIOを行うかの問題で、 &lt;strong&gt;実行時&lt;/strong&gt; に関係する話題です。&lt;/p&gt;

&lt;p&gt;次に、直接形式と継続渡し形式について。非同期やノンブロッキングなIOをしようと思うと後続の処理、すなわち（限定）継続が必要になる。この（限定）継続をプログラマがどのように渡すかの問題。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Direct_style&#34;&gt;直接形式&lt;/a&gt;は（限定）継続がプログラムには陽には現れず、コンパイラが頑張るかコルーチンなどの言語機能、&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;などの構文を用いて実現されます。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Continuation-passing_style&#34;&gt;継続渡し形式&lt;/a&gt;(CPS)はプログラマが陽に（限定）継続を渡すスタイルで、コールバック形式などとも呼ばれます。&lt;/p&gt;

&lt;p&gt;これらは主に言語の問題で、 &lt;strong&gt;コンパイル時&lt;/strong&gt; に関係する話題です。
よく直接形式と同期処理が混同されて「同期プログラミングをすることで非同期プログラミングができます」などの矛盾した一文が書かれがちですが区別しましょう。&lt;/p&gt;

&lt;h2 id=&#34;誰が何を&#34;&gt;誰が何を&lt;/h2&gt;

&lt;p&gt;IO処理の話題はスレッドとカーネルとのやりとりに関することが多い気がしますが、Goのようにユーザランドで実行単位を持つと「ブロックする」といったときにスレッドがブロックするのかgoroutineがブロックするのか分かりづらいですね。
なのでこれ以後は誰が何をブロックするのかを出来る限り明示しながら書きたいと思います。例えば「カーネルがgoroutine Aを実行しているスレッドをブロックする」など。&lt;/p&gt;

&lt;h1 id=&#34;scala&#34;&gt;Scala&lt;/h1&gt;

&lt;p&gt;前職でScalaを書いていました。
Scalaの&lt;code&gt;Future&lt;/code&gt;そのものは&lt;code&gt;flatMap&lt;/code&gt;が関数をとるので継続渡し形式ですが、そのシンタックスシュガーの&lt;code&gt;for&lt;/code&gt;式は直接形式でプログラミングができます。
IOの実体についてはFutureで抽象化されているのでexecutorによります。&lt;/p&gt;

&lt;h1 id=&#34;go&#34;&gt;Go&lt;/h1&gt;

&lt;p&gt;前職の新卒研修で5日ほどGoを書いたことがあります。
多くの言語は比較的シンプルなIOモデルを持つので用語を意識しなくても問題ありませんが、Goは実行時に色々工夫しているので用語をちゃんと区別しないと齟齬が出るようです。
なのでGoを例に理解を深めようと思います。&lt;/p&gt;

&lt;p&gt;まず、Goは実行時に動作するコンポーネントが多いので整理します。
&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;ここの質問&lt;/a&gt;への回答によるとgoroutine実行用のスレッド、スケジューラ、GCに大別してよさそうです。
このうち、IOに関連するのはgoroutine実行用のスレッドとスケジューラなのでGCについては触れません。
あまりよく分かってないのですがスケジューラはgoroutine実行用のスレッド上で呼ばれるための関数（群）なんですかね。&lt;/p&gt;

&lt;p&gt;普段は1スレッドが複数のgoroutineの実行を受け持ち、goroutineが何かしらの理由でブロックしそうなタイミングで別のgoroutineにコンテキストスイッチするようです。
ブロックしそうなタイミングというのはやや古いですが&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;ここ&lt;/a&gt;に書かれてます。
直接形式で書きつつコンテキストスイッチをするということはどうにかして(限定)継続を取り出す必要がありますが、それこそgoroutineですね。goroutine自身でスタックを持つようですし。
C関数を呼ぶときなどはコンパイラが裏で呼び出す前と後に分割しているようです。&lt;/p&gt;

&lt;p&gt;さて、IOについてはファイルIOとネットワークIOで操作が異なるようです。&lt;/p&gt;

&lt;p&gt;ファイルIOでは普通に同期/ブロッキングなシステムコールを発効し、OSがスレッドをブロックする時間が長いようなら別スレッドで元スレッドの持っていたgoroutineを実行するようです。
信頼できる情報が出てこなかったのですが自身で長くなりそうと思っているシステムコールの場合はgoroutineの実行権限（プロセス）を手放してあとは他のプロセスがstealするに任せてる？
ファイルIOは、スレッドがシステムコールでブロックし同期的で、goroutineもシステムコールでブロックし同期的です。ただスケジューラのお陰で他のgoroutineに迷惑がかからないだけです。&lt;/p&gt;

&lt;p&gt;ネットワークIOはポーリングを行なうようです。
スケジューラがfinbrunnableする中でブロックしない方のpoll(Linuxだとepollにノンブロッキングオプションつけたやつかな？)を呼んで、操作可能なfdがあればそれを待っているgoroutineを起こしている模様。
であれば上の分類に従うとネットワークIOはスレッドはブロックせず同期的でIOを多重化し、goroutineはスケジューラからブロックされ同期的で（特別に関数を呼ばなければ）IOの多重化もしません。ただ、操作可能なfdに操作しているのでgoroutineはカーネルからはブロックされません。&lt;/p&gt;

&lt;p&gt;この他にもgoroutine同士のコミュニケーションにチャネルがあります。そこまで重要じゃないかなと思って詳しく調べてないので間違いがあるかもしれないです。
チャネルへの操作は同期的ですね。チャネルへのread/writeはバッファがempty/fullだったらブロックするようなのでgoroutineはチャネルへの操作でブロックします。調べてないですが普通スレッドはブロックしないでしょう。&lt;/p&gt;

&lt;p&gt;チャネルへのselectはあまり情報が出てこなかったのですが恐らくスケジューラがIO可能なチャネルを調べて1つでもあればそれからランダムに選ぶ、1つもなくdefaultもなければスケジューラがgoroutineをブロックするんだと思います。
同期的でIOの多重化をしていますね。&lt;/p&gt;

&lt;p&gt;Goroutineやスレッドレベルでは同期的ですが、Goのプロセス全体でみるとGOMAXPROC分のスレッドは常にCPUを使っているので非同期なんですかね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Goの件について表にするとこうですかね。非同期処理をやろうと思ったら大抵処理単位を分ける必要がありますが、Goの最小処理単位がgoroutineなのでよく考えたらgoroutineが全て同期するのはあたりまえですね。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;スレッド&lt;/th&gt;
&lt;th&gt;goroutine&lt;/th&gt;
&lt;th&gt;Goプロセス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ファイル&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;非同期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ネットワーク&lt;/td&gt;
&lt;td&gt;ノンブロック/同期/多重化&lt;/td&gt;
&lt;td&gt;ノンブロック/同期/&lt;/td&gt;
&lt;td&gt;非同期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルRW&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルselect&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/同期/多重化&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ということでGoのIOについては「goroutineを直接形式で同期的な書き方をしても裏でスケジューラが動いているからCPUを効率的に使えてGoプロセス全体でみれば非同期」になるんですかね。&lt;/p&gt;

&lt;p&gt;Goに詳しい人、コメントや誤り訂正お願いします。&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/issues&#34;&gt;GitHubのイシュー&lt;/a&gt;とか使えば良い気がします。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/36112445/golang-blocking-and-non-blocking&#34;&gt;multithreading - Golang blocking and non blocking - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/os/file_unix.go?s=#L224&#34;&gt;src/os/file_unix.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/proc.go?s=#L1795&#34;&gt;src/runtime/proc.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/faq#goroutines&#34;&gt;Frequently Asked Questions (FAQ) - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;channel - go routine blocking the others one - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/cgocall.go&#34;&gt;src/runtime/cgocall.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/32538438/how-does-channel-blocking-work-in-go&#34;&gt;select - How does channel blocking work in Go? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/ref/spec#Select_statements&#34;&gt;The Go Programming Language Specification - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;How does the Go runtime work? - Quora&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rust風にデザインパターン23種</title>
      <link>/blog/2017/05/06/rustkazenidezainpata_n23tane</link>
      <pubDate>Sat, 06 May 2017 21:59:30 +0900</pubDate>
      
      <guid>/blog/2017/05/06/rustkazenidezainpata_n23tane</guid>
      <description>&lt;p&gt;κeenです。
GoFのデザインパターンは有名ですが、言語機能によっては単純化できたりあるいは不要だったりするのでRust風に書き換えたらどうなるか試してみます。

発端はこのツイート。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;デザインパターン、古いJavaの機能の足りなさのワークアラウンド的なテクニックも含まれてるからあまり宜しくないんだよね。enumやクロージャで十分なのもいくつかある。&lt;br&gt;&lt;br&gt;Rustで写経、デザインパターン23種 - Qiita&lt;a href=&#34;https://t.co/MhpS3Z2OlF&#34;&gt;https://t.co/MhpS3Z2OlF&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/860635079600513024&#34;&gt;2017年5月5日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;一応誤解のないように説明しておくと、該当のQiitaの記事に不満がある訳ではなくてGoFのデザインパターンついての言及です。&lt;/p&gt;

&lt;p&gt;リンク先のコードで十分な時にはここでは流すのでリンク先も同時に参照下さい。
また、比較しやすいようにサンプルコードはリンク先のものに則って書きます。&lt;/p&gt;

&lt;p&gt;一応デザインパターンの教科書として結城先生の本を参照しつつ書いていきます。&lt;/p&gt;

&lt;h1 id=&#34;command-パターン&#34;&gt;Command パターン&lt;/h1&gt;

&lt;p&gt;列挙型を使うところです。
Javaにまともなenumがないのでクラスが使われていますが、列挙型があるならそちらの方がデータとコードの分離ができて見通しがいいです。また、コマンドが1つの型に収まるのでトレイトオブジェクトを作る必要がなくなります。&lt;/p&gt;

&lt;p&gt;比較的マイナーな変更です。&lt;/p&gt;

&lt;p&gt;Lispだとクロージャで解決したりしますが、Rustだと列挙型の方がしっくりくるかなと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Command&amp;lt;T&amp;gt; {
    fn execute(&amp;amp;self, &amp;amp;mut T);
    fn undo(&amp;amp;self, &amp;amp;mut T);
}



struct Invoker&amp;lt;&#39;a, Cmd, T: &#39;a&amp;gt; {
    commands: Vec&amp;lt;Cmd&amp;gt;,
    target: &amp;amp;&#39;a mut T,
    current_index: usize,
}


impl&amp;lt;&#39;a, Cmd, T&amp;gt; Invoker&amp;lt;&#39;a, Cmd, T&amp;gt; {
    fn new(t: &amp;amp;&#39;a mut T) -&amp;gt; Self {
        Invoker {
            commands: Vec::new(),
            target: t,
            current_index: 0,
        }
    }


    fn target(&amp;amp;self) -&amp;gt; &amp;amp;T {
        self.target
    }

    fn append_command(&amp;amp;mut self, c: Cmd) {
        self.commands.push(c);
    }
}

impl&amp;lt;&#39;a, Cmd, T&amp;gt; Invoker&amp;lt;&#39;a, Cmd, T&amp;gt;
    where Cmd: Command&amp;lt;T&amp;gt;
{
    fn execute_command(&amp;amp;mut self) {
        if self.commands.len() &amp;lt;= self.current_index {
            // Nothing to do.
            return;
        }

        let c = &amp;amp;self.commands[self.current_index];
        let t = &amp;amp;mut *self.target;
        c.execute(t);

        self.current_index += 1;
    }

    fn execute_all_commands(&amp;amp;mut self) {
        for _ in self.current_index..self.commands.len() {
            self.execute_command();
        }
    }

    fn undo(&amp;amp;mut self) {
        if 0 == self.current_index {
            return;
        }

        self.current_index -= 1;

        let c = &amp;amp;self.commands[self.current_index];
        let t = &amp;amp;mut *self.target;
        c.undo(t);
    }
}


#[derive(Debug, Eq, PartialEq)]
struct Robot {
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
}


impl Robot {
    fn new() -&amp;gt; Robot {
        Robot {
            x: 0,
            y: 0,
            dx: 0,
            dy: 1,
        }
    }

    fn move_forward(&amp;amp;mut self) {
        self.x += self.dx;
        self.y += self.dy;
    }

    fn set_direction(&amp;amp;mut self, d: (i32, i32)) {
        self.dx = d.0;
        self.dy = d.1;
    }

    fn get_direction(&amp;amp;self) -&amp;gt; (i32, i32) {
        (self.dx, self.dy)
    }
}

enum RoboCommand {
    MoveForward,
    TurnRight,
    TurnLeft,
}

impl Command&amp;lt;Robot&amp;gt; for RoboCommand {
    fn execute(&amp;amp;self, r: &amp;amp;mut Robot) {
        use RoboCommand::*;
        match *self {
            MoveForward =&amp;gt; r.move_forward(),
            TurnRight =&amp;gt; {
                let (dx, dy) = r.get_direction();
                r.set_direction((dy, -dx))
            }
            TurnLeft =&amp;gt; {
                let (dx, dy) = r.get_direction();
                r.set_direction((-dy, dx));
            }

        }
    }
    fn undo(&amp;amp;self, r: &amp;amp;mut Robot) {
        use RoboCommand::*;
        match *self {
            MoveForward =&amp;gt; {
                let c1 = TurnRight;
                c1.execute(r);
                c1.execute(r);
                self.execute(r);
                c1.execute(r);
                c1.execute(r);
            }
            TurnRight =&amp;gt; {
                let c = TurnLeft;
                c.execute(r);
            }
            TurnLeft =&amp;gt; {
                let c = TurnRight;
                c.execute(r);

            }

        }
    }
}



fn main() {
    let mut r = Robot::new();

    let mut invoker = Invoker::new(&amp;amp;mut r);
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 0,
                   dy: 1,
               });

    {
        use RoboCommand::*;
        invoker.append_command(TurnRight);
        invoker.append_command(TurnLeft);
        invoker.append_command(MoveForward);
    }

    invoker.execute_all_commands();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 1,
                   dx: 0,
                   dy: 1,
               });

    invoker.undo();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 0,
                   dy: 1,
               });

    invoker.undo();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 1,
                   dy: 0,
               });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;stateパターン&#34;&gt;Stateパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。トレイトオブジェクトを使う代表的なケースだと思います。。
あるいは列挙型を使う可能性もあります。&lt;/p&gt;

&lt;h1 id=&#34;strategyパターン&#34;&gt;Strategyパターン&lt;/h1&gt;

&lt;p&gt;参照先でも説明されていますが、Rustにはクロージャがあるので不要です。&lt;/p&gt;

&lt;h1 id=&#34;template-methodパターン&#34;&gt;Template Methodパターン&lt;/h1&gt;

&lt;p&gt;そもそもトレイトを使った普通のプログラミングなのでRustでわざわざ名前をつけるほどかな？と個人的には思いますがあえて書くなら参照先のままです。
あるいはものによっては高階関数でも。&lt;/p&gt;

&lt;p&gt;個人的にはトレイトオブジェクトを作るより関連型を使った方が好みです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait AbstractFactory&amp;lt;&#39;a&amp;gt; {
    type ProdX: ProductX;
    type ProdY: ProductY;
    fn create_product_x(&amp;amp;self) -&amp;gt; Box&amp;lt;ProdX + &#39;a&amp;gt;;
    fn create_product_y(&amp;amp;self) -&amp;gt; Box&amp;lt;ProdY + &#39;a&amp;gt;;
}

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;mementoパターン&#34;&gt;Mementoパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです&lt;/p&gt;

&lt;h1 id=&#34;observerパターン&#34;&gt;Observerパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです&lt;/p&gt;

&lt;h1 id=&#34;visitorパターン&#34;&gt;Visitorパターン&lt;/h1&gt;

&lt;p&gt;参照先では簡単な例なので分かりづらいのですが、列挙型を使うところです。
まともな列挙型がない+シングルディスパッチしかなく引数はオーバーロードという二重苦によって生まれたパターンであり、まともな列挙型か多重ディスパッチがあれば複雑怪奇なプログラムは書かなくて済みます。&lt;/p&gt;

&lt;p&gt;ここでは参照先とは違ってもう少し複雑な例を出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Visitor&amp;lt;T&amp;gt; {
    fn visit(&amp;amp;mut self, &amp;amp;T);
}

enum Entity {
    File(String),
    Dir(String, Vec&amp;lt;Entity&amp;gt;),
}

struct ConcreteFileVisitor;

impl Visitor&amp;lt;Entity&amp;gt; for ConcreteFileVisitor {
    fn visit(&amp;amp;mut self, e: &amp;amp;Entity) {
        use Entity::*;
        match *e {
            File(ref name) =&amp;gt; println!(&amp;quot;file: {}&amp;quot;, name),
            Dir(ref name, ref files) =&amp;gt; {
                println!(&amp;quot;dir: {}&amp;quot;, name);
                for file in files {
                    self.visit(file)
                }
            }
        }
    }
}

fn main() {
    use Entity::*;
    let e = Dir(&amp;quot;/&amp;quot;.to_string(),
                vec![File(&amp;quot;etc&amp;quot;.to_string()), File(&amp;quot;usr&amp;quot;.to_string())]);
    let mut visitor = ConcreteFileVisitor;
    visitor.visit(&amp;amp;e);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特段パターンというほどの処理をしている感じがしませんね。&lt;/p&gt;

&lt;h1 id=&#34;iteratorパターン&#34;&gt;Iteratorパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;mediatorパターン&#34;&gt;Mediatorパターン&lt;/h1&gt;

&lt;p&gt;だいたい参照先のままです。複雑なことをしようと思うと&lt;code&gt;Colleague&lt;/code&gt;が複数種類出てきて列挙型かトレイトオブジェクトが必要になりそうな気がします。&lt;/p&gt;

&lt;h1 id=&#34;interpreterパターン&#34;&gt;Interpreterパターン&lt;/h1&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h1 id=&#34;builderパターン&#34;&gt;Builderパターン&lt;/h1&gt;

&lt;p&gt;あまりここまで抽象化してるのは見たことありませんがやるとしたら参照先のままです。
そもそもRustには継承がないので抽象化する意義があまりなく、型固有のBuilderパターンで十分です。&lt;/p&gt;

&lt;h1 id=&#34;prototypeパターン&#34;&gt;Prototypeパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;factoryパターン&#34;&gt;Factoryパターン&lt;/h1&gt;

&lt;p&gt;クロージャで十分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Product {
    fn convert(&amp;amp;self, String) -&amp;gt; String;
}


struct Factory;

impl Factory {
    fn convert&amp;lt;P, F&amp;gt;(&amp;amp;self, s: String, create_product: F) -&amp;gt; String
        where P: Product,
              F: FnOnce() -&amp;gt; P
    {
        create_product().convert(s)
    }
}


struct ConcreteProductX;
impl Product for ConcreteProductX {
    fn convert(&amp;amp;self, s: String) -&amp;gt; String {
        s.to_uppercase()
    }
}


fn main() {
    let f = Factory;
    println!(&amp;quot;{}&amp;quot;,
             f.convert(&amp;quot;hogehoge piyopiyo&amp;quot;.to_string(), || ConcreteProductX))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;abstractfactoryパターン&#34;&gt;AbstractFactoryパターン&lt;/h1&gt;

&lt;p&gt;そもそもここまでやる？というのは置いといてやるとしたら参照先のままかなぁと思います。&lt;/p&gt;

&lt;p&gt;TemplateMethodパターンでも述べた通り個人的には関連型を使う方が好みです。&lt;/p&gt;

&lt;h1 id=&#34;chain-of-responsibility-cor-パターン&#34;&gt;Chain of Responsibility/CoR パターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;singletonパターン&#34;&gt;Singletonパターン&lt;/h1&gt;

&lt;p&gt;そもそもアンチパターンです。分かりづらいグローバル変数なだけです。あえてRustでやるとしたら&lt;a href=&#34;https://github.com/rust-lang-nursery/lazy-static.rs&#34;&gt;lazy_static&lt;/a&gt;かなと思います。&lt;/p&gt;

&lt;h1 id=&#34;adapterパターン&#34;&gt;Adapterパターン&lt;/h1&gt;

&lt;p&gt;これは捉え方が2種類あるかなーと思います。。&lt;/p&gt;

&lt;p&gt;1つにはクラスの定義時にしかインターフェースを実装できない窮屈な言語仕様へのワークアラウンドとして。
この捉え方では参照先のコードようにただトレイトを実装してしまえば終わりです。&lt;/p&gt;

&lt;p&gt;もう1つにはラッパーオブジェクトとして。&lt;code&gt;std::fs::File&lt;/code&gt;の実装とかがそれっぽいと思います。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct File {
    inner: fs_imp::File,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bridgeパターン&#34;&gt;Bridgeパターン&lt;/h1&gt;

&lt;p&gt;そもそも機能の追加とAPIの抽象化をどちらも継承に押し込める言語仕様が悪い。
それにRustでは継承しないので関係ないです。&lt;/p&gt;

&lt;h1 id=&#34;proxyパターン&#34;&gt;Proxyパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;facadeパターン&#34;&gt;Facadeパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。Rustにはモジュールや可視性の制御があって特別意識することなく普段からやっていることなのであまり名前をつけるほどのことではないと思ってます。&lt;/p&gt;

&lt;h1 id=&#34;flyweightパターン&#34;&gt;Flyweightパターン&lt;/h1&gt;

&lt;p&gt;所有権があるのでRustだとちょっと難しいパターンです。
参照だけなら参照先のように&lt;code&gt;HashMap&lt;/code&gt;にいれるか、オブジェクトを区別しないなら&lt;code&gt;Vec&lt;/code&gt;にいれるかなと思います。&lt;/p&gt;

&lt;p&gt;因みにLispとかでは&lt;code&gt;intern&lt;/code&gt;という名前で呼ばれてると思います。&lt;/p&gt;

&lt;h1 id=&#34;compositeパターン&#34;&gt;Compositeパターン&lt;/h1&gt;

&lt;p&gt;ただの列挙型の再実装です。&lt;/p&gt;

&lt;h1 id=&#34;decoratorパターン&#34;&gt;Decoratorパターン&lt;/h1&gt;

&lt;p&gt;よくあるやつです。参照先のコードの他、&lt;code&gt;std::io::WriteBuf&lt;/code&gt;のようなものが代表的です。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;デザインパターンをdisろうと思って書いたのですが案外多くのケースで便利でした。Rustで不要なものは10本指で数えられる程度でしたね。すごい。&lt;/p&gt;

&lt;p&gt;因みにLisperでAIの研究者（確か今GoogleのAI研究所の所長）のPeter Norvigは&lt;a href=&#34;http://www.norvig.com/design-patterns/design-patterns.pdf&#34;&gt;Design Patterns in Dynamic Languages&lt;/a&gt;で16個はLispの機能を使えばパターンという程のものではなくなると言ってます。
それぞれどの機能でどれが不要になるかを解説しているのですが、Rustは高階関数とモジュールの分に加えて列挙型の分で不要になってるかなと思います。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>メモリとスタックとヒープとプログラミング言語</title>
      <link>/blog/2017/04/30/memoritosutakkutohi_puto</link>
      <pubDate>Sun, 30 Apr 2017 09:09:50 +0900</pubDate>
      
      <guid>/blog/2017/04/30/memoritosutakkutohi_puto</guid>
      <description>&lt;p&gt;κeenです。
今回の話は別にRustに限ったものではないのですが、よくRustを始めたばかりの人がスタックとヒープが分からないと言っているのをみかけるので少しメモリの話をしますね。
厳密な話というよりは雰囲気を掴んで欲しいという感じです。
&lt;/p&gt;

&lt;h1 id=&#34;メモリは配列&#34;&gt;メモリは配列&lt;/h1&gt;

&lt;p&gt;プログラム（プロセス）のメモリには実行するプログラム（機械語）やグローバル変数/定数、関数の引数やローカル変数、その他プログラムで使うデータ領域などを置きます。
プロセスに割り当てられるメモリというのは、1つの巨大なのっぺらな配列みたいなものです。サイズも決まってます。64bit OSなら2^64 byteです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0                        2^64
+---------------     ----+
|  |  |  |  |    ~~   |  |
+---------------     ----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは仮想的なメモリなので実際の物理メモリに2^64 byteの配列がドンと確保される訳ではなくて、使った(使いたい)分だけ占有します。OSが賢いですね。&lt;/p&gt;

&lt;p&gt;ただまあこれだけだと使いづらいのである程度区切って「この辺にこれ系のデータを置く」みたいな使われ方をします。
プログラムを置く &lt;em&gt;text領域&lt;/em&gt; 、初期化されたグローバル変数を置く &lt;em&gt;data領域&lt;/em&gt; 、初期化されていない（データ領域だけ確保された）グローバル変数を置く &lt;em&gt;bss領域&lt;/em&gt; 、関数の引数やローカル変数を置く &lt;em&gt;stack領域&lt;/em&gt; 、プログラムのデータを置く &lt;em&gt;heap領域&lt;/em&gt; です。
グローバル変数って言っちゃいましたけど実はそれに限らなくて、例えばRustの文字列リテラルなんかもdata領域に置かれます。&lt;/p&gt;

&lt;p&gt;text、 data、 bssは実行する前からサイズが分かっているので問題ないのですが、heapとstackはプログラムの実行中にサイズが変わるものなのでどこにどう置いたら上手く配分できるか分かりませんね。
そこで以下のようにstackとheapを両端に配置して使いたい分だけ使用領域を伸ばせるようになってます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 簡略化するために嘘ついてたりしますがまあ、だいたい合ってます
+-------+ 2^64
| stack |
|   |   |
|   V   |
|       |
|   ^   |
|   |   |
| heap  |
+-------+
| bss   |
+-------+
| data  |
+-------+
| text  |
+-------+ 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;text、data、bssはそのままなのでstackとヒープについて話します。&lt;/p&gt;

&lt;h1 id=&#34;stackと関数&#34;&gt;Stackと関数&lt;/h1&gt;

&lt;p&gt;Stackは関数呼び出しのために使われます。
ネストした関数の呼び出しの系譜を関数の「コールスタック」と呼んだりするように、関数呼び出しはスタック構造になってますね。
なのでスタックを用いて管理すると具合が良いのです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+
| func 1 |
+--------+
| func 2 |
+--------+
| func 3 |
+--------+
| func 4 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、折角特別に用意したこのstackにはただの関数の呼び出し履歴だけではなく他のデータも入れたいですよね？
例えば関数ローカルな変数だとか。データの次にまた別のデータが置かれるのでサイズを変えたりはできませんが。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+
| func 1 |
|--------|
| data 1 |
|--------|
| data 2 |
+--------+
| func 2 |
|--------|
| data   |
| ...    |
+--------+
| func 3 |
|--------|
| data   |
| ...    |
+--------+
| func 4 |
|--------|
| data   |
| ...    |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;データの解放は簡単です。スタックを巻き戻せば自動的に消えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+
| func 1 |
|--------|
| data 1 |
|--------|
| data 2 |
+--------+
| func 2 |
|--------|
| data   |
| ...    |
+--------+
|        |
|        |
|        |
|        |
|        |
|        |
|        |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逆にいうと関数から抜けたら消えてしまうということでもありますが。&lt;/p&gt;

&lt;p&gt;という訳で、 「条件が限られるけど高速に扱えるデータ領域」がstackです。&lt;/p&gt;

&lt;p&gt;因みに、メモリは使った分だけしか確保されないと言いましたが、スタックを伸ばしすぎると確保されていない領域に到達してエラーが出ます。スタックオーバーフローです。&lt;/p&gt;

&lt;h1 id=&#34;heapとデータ&#34;&gt;Heapとデータ&lt;/h1&gt;

&lt;p&gt;heapにはstackに置けないデータが置かれます。
これの扱いは少し面倒です。何故ならデータの確保や解放の順番がバラバラなので、歯抜けな状態になってしまうからです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|        |
| data 4 |
+--------+
| data 3 |
+--------+
|        |
+--------+
| data 1 |
+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで「どかが使われていてどこが空いているか」を管理するシステムを導入します。
C言語では&lt;code&gt;malloc&lt;/code&gt;という関数をインターフェースとして管理しているので管理システム自体もmallocと呼ぶことが多いようです。
この実装方法はフリーリストを使った単純なものからサイズ毎のバケツを用意して〜といった方法まで様々にあるので気になる人は調べてみて下さい。
大抵、「メモリがこのくらい欲しい」と言われたら今管理している中からそれっぽい空きを捜してそこを渡してあげるような作りになっています。&lt;/p&gt;

&lt;p&gt;ちなみにこの領域管理には(mallocの場合)そこそこのコストが掛かります。でもその代わり自由に確保/解放できる他、サイズの変更もできるので自由度が高いです。&lt;/p&gt;

&lt;p&gt;という訳で「自由度が高いが少しコストがかかるデータ領域」がheapです。&lt;/p&gt;

&lt;h1 id=&#34;プログラミング言語とメモリ&#34;&gt;プログラミング言語とメモリ&lt;/h1&gt;

&lt;p&gt;では、具体的な言語がどのようにメモリを使っているかを簡単に紹介します。&lt;/p&gt;

&lt;p&gt;1つ注意しないといけないのが、ガーベジコレクション（GC）のある言語ではheapの上に構築した自前のメモリ管理システムのことをヒープと呼んでいたりするので両者をちゃんと区別しましょう。
同じく、スタックの使い方も言語独自でコールスタックと引数のスタックを分けたりもするので気をつけましょう。&lt;/p&gt;

&lt;h2 id=&#34;c言語&#34;&gt;C言語&lt;/h2&gt;

&lt;p&gt;先程説明したとおり、データ領域にheapを、関数呼び出しや関数ローカルなデータにstackを使っています。&lt;/p&gt;

&lt;p&gt;メモリの領域管理は先述の&lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;などをプログラマが手で書きます。手で管理するのでバグります。&lt;/p&gt;

&lt;h2 id=&#34;ruby&#34;&gt;Ruby&lt;/h2&gt;

&lt;p&gt;データ領域にはheapにmallocで確保した領域にヒープを確保し、その上にメモリ管理システム(GC)を構築して管理しています。&lt;/p&gt;

&lt;p&gt;関数呼び出しにはstackではなくheapに確保した自前のスタックを用意しています。
stackを使わないのはどうしてもC言語がstackを使うのでRubyも交ぜて使ってしまうと(Ruby自体C言語の上で動いていますね)問題が起こるだとかデータ構造として扱いづらいだとかGCとの兼ね合いだとかの理由だと思います。
また、そもそもRubyのメソッドとC言語の関数は別物という話もあります。&lt;/p&gt;

&lt;p&gt;また、実行用にスタックはありますが、データの実体はRubyのヒープに置かれます。Rubyのプログラムから高速なスタック領域を使うことができないのです。残念ですね。&lt;/p&gt;

&lt;p&gt;メモリの領域管理にはGCシステムを採用し、メモリ管理をユーザがすることはありません。
GCはmallocに少しデータを足したようなMark and Sweepです。メモリ確保はほぼmallocと同じで、気が向いたときに使っているデータにマークを付けていって、マークの付いていないデータを一括でfreeしてくれます。
メモリ確保（やポインタの扱い）がmallocに似ているのでC言語と協調するときに楽です。RubyはNative Extentionが作りやすいように設計されていますね。&lt;/p&gt;

&lt;p&gt;1つ注意しておくと、Rubyを実行するときにもメモリにtextやbss、dataなどの領域がありますが、それは「Rubyを実行するVMのための領域」であって「実行しているRubyスクリプトのための領域」ではありません。&lt;/p&gt;

&lt;h2 id=&#34;pythonやphp&#34;&gt;PythonやPHP&lt;/h2&gt;

&lt;p&gt;Rubyと同じようにヒープもスタックもheapに確保していると思います（面倒なのでソースを追っていない）。
メモリ管理システムはGCを使いますが、Rubyとは違って参照カウント方式を採用しています。&lt;/p&gt;

&lt;p&gt;参照カウントは、メモリ確保はmallocに似ていますが、確保した後の扱いが異なります。
値を参照する度にカウントを増やし、使わなくなったら参照を減らし、参照が0になったらfreeされます。
言語レベルでは意識するすることはありませんが、C言語のレイヤーでは一々参照の操作をしてあげないといけないので手間がかかります（たまに扱いを間違ってバグります）。
また、循環参照という問題もあって、たまに解放されないメモリがあったりします。（そのために結局たまにMark and Sweepのようなものが必要だったりします）&lt;/p&gt;

&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;

&lt;p&gt;Rubyと同じようにヒープもスタックもheapに確保しています(JVMのメモリについて調べてみると色々出てきます)。
30億のデバイスで走らせるための工夫ですね。&lt;/p&gt;

&lt;p&gt;同じくGCを使いますが、今度はCopy GC方式を採用しています（厳密にいうとHotSpot VMでの複数種類ある方式のうちの1つですが）。
Copy GCは面白くて、ヒープを2つに分割します。同時に使うのは1つだけです。メモリを確保するときは、使われていない領域などは無視して新たなスペースを確保します。
これはわざわざ空き領域を捜す必要がないので非常に高速です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------+
| data1 | data 2 | data 3 | -&amp;gt;    |
+---------------------------------+
+---------------------------------+
|                                 |
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてメモリが一杯になったら使っているデータだけもう1つの領域にコピーします。このとき、使っていなかった分は詰めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------+
|       | data 2 |                |
+---------------------------------+
+---------------------------------+
| data1 | data 3 | -&amp;gt;             |
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使っていなかったdata 2の存在を忘れて、2つを入れ替えたらメモリの回収完了です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------+
| data1 | data 3 | -&amp;gt;             |
+---------------------------------+
+---------------------------------+
|                                 |
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ヒープが半分しか使えないだとかデータが移動してしまうので扱いが難しいだとかの問題はあるのですが、確保が非常に高速で解放もかなり速い方式です。&lt;/p&gt;

&lt;p&gt;この方式はJavaの他にOCamlやHaskellなどの関数型言語でよく使われます。
データを頻繁にアロケートするのでメモリ確保が高速なこの方式が好まれるようです。&lt;/p&gt;

&lt;h2 id=&#34;rust&#34;&gt;Rust&lt;/h2&gt;

&lt;p&gt;RustはC言語と同じくデータ領域にheapを、関数呼び出しや関数ローカルなデータにstackを使っています。&lt;/p&gt;

&lt;p&gt;メモリの領域管理は&lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;などをコンパイラが自動で発効してくれます。なのでプログラマが自分で管理する必要はありません。&lt;/p&gt;

&lt;h1 id=&#34;高速なメモリの使い方&#34;&gt;高速なメモリの使い方&lt;/h1&gt;

&lt;p&gt;まず、一番速い方法は「そもそもメモリを確保しない」です。
これはコストが掛からないので高速です。
「何をふざけたことを」と思うかもしれませんが、プログラミングする上で「余計に確保しない」を意識するという意味で重要です。&lt;/p&gt;

&lt;p&gt;次はstackを使うと高速です。これはそもそもstackを意識して使える言語でないと選べない方法ですね。&lt;/p&gt;

&lt;p&gt;最後の手段としてheapを使います。&lt;/p&gt;

&lt;p&gt;GCのある言語ではGCの特性によってヒープの使い方も考える必要があります。
Mark and Sweepは生死に関らず確保したオブジェクトの数に比例してメモリ解放コストが掛かりますが、Copy GCでは生きているオブジェクトに比例してコストが掛かりますので、生きているオブジェクトを減らすと速くなります。
例えば使わないけど変数に束縛されているものがあるなら変数のスコープを狭めるだとか変数にnullを代入するだとか。
よほどメモリのせいで遅くなっていない限りあまりやりませんが（ゲームの人はよくやるらしい？）。&lt;/p&gt;

&lt;p&gt;また、最近の多くのGC（RubyもJavaも）には世代別GCといって、新しいデータと古いデータを分けて管理する方式が採用されているので作ったデータをすぐさま使ってすぐさま不要にすると速くなったりします。
例えばデータ列に対して個々のデータに処理1、2、3を適用したいなら処理1のループ、2のループ、3のループ、とするよりもループの中で処理1、2、3と適用した方が速くなります。
最近Scalaの次期コンパイラが高速化のためにそのような構成（phase fusioning）にしたらしいですね。
使っている言語でOld領域、New領域などの単語を聞いたことがあるなら多分世代別GCが使われています。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;スタックとヒープの話、そしてなぜスタックとヒープを意識したいかを説明しました。
ついでに、比較のためにGCのある言語についても少しだけ紹介しました。
けっこうふわふわとした説明なので「分かった気分」になりたいだけならこの記事で十分かと思いますが、もう少し踏み込んだことが知りたければ個別に調べてみて下さい。
また、メモリレイアウトについてはおおまかには合っているものの、結構嘘ついているのであまり鵜呑みにしないで下さい。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://th0x4c.github.io/blog/2012/10/10/os-virtual-memory-map/&#34;&gt;仮想メモリ空間のメモリマップを調べる - th0x4c 備忘録&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valinux.co.jp/technologylibrary/document/linux/malloc0001/&#34;&gt;malloc(3)のメモリ管理構造 | VA Linux Systems Japan株式会社&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ruby/ruby/blob/trunk/gc.c#L7649&#34;&gt;rubyのメモリ確保にmallocを使っている部分&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ruby/ruby/blob/trunk/vm_core.h#L705&#34;&gt;rubyのスタックの定義部分&lt;/a&gt;。これは引数スタックかな？コールスタックどこだろう…&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Cargoのサブプロジェクトとreplace</title>
      <link>/blog/2017/04/05/cargonosabupurojiekutotoreplace</link>
      <pubDate>Wed, 05 Apr 2017 20:46:26 +0900</pubDate>
      
      <guid>/blog/2017/04/05/cargonosabupurojiekutotoreplace</guid>
      <description>&lt;p&gt;κeenです。最近Cargoのreplace機能を使おうとしてハマったのでメモを残しておきます。&lt;/p&gt;

&lt;p&gt;
最近何箇所かで喋ったのでご存知の方もいらっしゃるかと思いますが、Cargoにはワークスペース機能があります。
fat repositoryスタイルに便利な機能で、1つのディレクトリ下に複数のサブプロジェクトを配置しつつ&lt;code&gt;target/&lt;/code&gt;は共有するのでマイクロプロジェクトのモジュール性とモノリシックプロジェクトのコンパイルの速さを実現することが出来ます。&lt;/p&gt;

&lt;p&gt;さて、問題になるのはクレートを公開するときの依存関係の記述です。
サブプロジェクト同士で依存し合っているので&lt;code&gt;Cargo.toml&lt;/code&gt;には&lt;code&gt;my-project-lib = {path = &amp;quot;../my-project-lib&amp;quot;}&lt;/code&gt; のような依存の記述がある筈です。
しかしながらローカルのクレートに依存していると&lt;code&gt;crates.io&lt;/code&gt;に公開は出来ません。
そこで今回はそれをどうにかするお話。&lt;/p&gt;

&lt;h1 id=&#34;replace&#34;&gt;replace&lt;/h1&gt;

&lt;p&gt;Cargoには&lt;a href=&#34;http://doc.crates.io/manifest.html#the-replace-section&#34;&gt;replace&lt;/a&gt;という機能があります。
特定のライブラリの特定のバージョンを、crates.ioにあるものではなくてユーザが指定した場所にあるものを使うように指示します。
&lt;a href=&#34;http://doc.crates.io/specifying-dependencies.html#overriding-dependencies&#34;&gt;Specifying Dependencies&lt;/a&gt;のドキュメントによると、以下のように使えます。&lt;/p&gt;

&lt;p&gt;例えば&lt;code&gt;uuid&lt;/code&gt;クレートを使っているときにそれが依存している&lt;code&gt;rand&lt;/code&gt;クレートにバグを見付けて修正し、修正した結果を試したいとします。
その時にreplaceは以下のように使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# ワークスペースの親プロジェクト
...

[replace]
&amp;quot;rand:0.3.14&amp;quot; = { path = &amp;quot;./rand&amp;quot; }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# ワークスペースの子プロジェクト

[package]
name = &amp;quot;my-awesome-crate&amp;quot;
version = &amp;quot;0.2.0&amp;quot;
authors = [&amp;quot;The Rust Project Developers&amp;quot;]

[dependencies]
uuid = &amp;quot;0.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;間接的に依存してる&lt;code&gt;rand:0.3.14&lt;/code&gt;を、crates.ioにあるものではなく指定したパスにあるものを使うように指示しています。&lt;/p&gt;

&lt;p&gt;この仕組みを使って先のローカルパス問題を解決出来ないでしょうか。すなわち、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# 子プロジェクト
[dependencies]
my-project-lib = &amp;quot;0.1.0&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、見た目上はcrates.ioにあるものに依存しておきつつ実際は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# 親プロジェクト
[replace]
&amp;quot;my-project-lib:0.1.0&amp;quot; = { path = &amp;quot;./my-project-lib&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように実際の依存先をローカルのパスに向ければ問題を解決できないでしょうか。&lt;/p&gt;

&lt;p&gt;この答えは、半分no、半分yesになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;replace&lt;/code&gt;はあくまでcrates.ioにあるものを置き換えるのでまだ公開していないプロジェクトに対しては使えません。
一方、一度crates.ioに公開してしまえば上記のテクニックは可能になります。&lt;/p&gt;

&lt;p&gt;なので一番最初にcrates.ioに公開する時の手順はやや煩雑になります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;(ローカルサブプロジェクトへの依存の記述は&lt;code&gt;path = &amp;quot;...&amp;quot;&lt;/code&gt;のまま)&lt;/li&gt;
&lt;li&gt;どのプロジェクトにも依存しないローカルサブプロジェクトを公開する&lt;/li&gt;
&lt;li&gt;既に公開されたローカルサブプロジェクトへの依存は順次&lt;code&gt;replace&lt;/code&gt;に書き換える&lt;/li&gt;
&lt;li&gt;ローカルパスへの依存のなくなったローカルプロジェクトから順に公開していく&lt;/li&gt;
&lt;li&gt;全てのサブプロジェクトのローカルサブプロジェクトへの依存が&lt;code&gt;replace&lt;/code&gt;に置き換わったら以後はそのまま使える。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;このようなテクニックは例えばdieselなどで&lt;a href=&#34;https://github.com/diesel-rs/diesel/blob/master/Cargo.toml#L21&#34;&gt;使われています&lt;/a&gt;。
この辺、改善あるといいですね。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>関数型プログラマからみたRust</title>
      <link>/blog/2017/04/04/kansuugatapuroguramakaramitarust</link>
      <pubDate>Tue, 04 Apr 2017 21:38:57 +0900</pubDate>
      
      <guid>/blog/2017/04/04/kansuugatapuroguramakaramitarust</guid>
      <description>&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;C++からRustに入った人あたりから「関数型言語から来た人のRustの感想を知りたい」とたまに言われるのでいつかブログ書こうか。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/848900720573075458&#34;&gt;2017年4月3日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;イントロ&#34;&gt;イントロ&lt;/h1&gt;

&lt;p&gt;私はRustをやる前にはCommon LispやSMLを主に使っていましたが、仕事ではScalaを使っていましたし他にもOCamlやSchemeやClojureやATS2やHaskellなどを書くこともありました。&lt;/p&gt;

&lt;p&gt;私を含めた多くの関数型言語経験者人が一度は &lt;a href=&#34;http://science.raphael.poss.name/rust-for-functional-programmers.html&#34;&gt;Rust for functional programmers&lt;/a&gt; を読んだことがあるかと思います。
このように関数型言語と比較して書かれるといかにも似た言語に見えるので私は興味を持ちました。そこで私は実際にRustに触れ始めたのです。&lt;/p&gt;

&lt;h1 id=&#34;構文&#34;&gt;構文&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;let&lt;/code&gt; があるのでおよそOCamlなどに似ているという印象を受けました。
デフォルトでイミュータブルですしパターンマッチやシャドイングなもどするのでまさにMLの&lt;code&gt;let&lt;/code&gt;そのものです。
行末にセミコロンが要求されますが、&lt;code&gt;in&lt;/code&gt;の代わりだと思うことにして自分をなだめました。
式指向で&lt;code&gt;return&lt;/code&gt;を書かなくて済むのも関数型言語らしさを感じました。&lt;/p&gt;

&lt;p&gt;関数定義の構文は手続型言語風ですが手続き型言語に馴れた人に寄り添うために必要なんだと思って深くは気にしないことにしました。&lt;/p&gt;

&lt;p&gt;一方、ジェネリクスの構文については憤りすら感じました。
どうして &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; を採用したのか、そもそも比較演算子の &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;と紛らわしい上に&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;の扱いでも困ることは目に見えていました。
私はML風に前置、あるいは少なくともHaskellのように関数と引数のように書くべきだと思いましたし、少なくともScalaのように型と値でカッコを分けるくらいはできるはずです。
しかしながら、不平を言っても始まらないので我慢して次に進むことにしました。&lt;/p&gt;

&lt;h1 id=&#34;言語機能&#34;&gt;言語機能&lt;/h1&gt;

&lt;p&gt;トレイト、タプル、代数的データ型とマッチ式、高階関数、型推論。
これらは明らかに関数型言語から輸入されたものです。
これはとても喜ばしいことです、なぜなら今までしていた通りのプログラミングを新しい言語でもできるからです！
関数の引数と返り値に型宣言が必要なのはMLプログラマとしては少し残念でしたがHaskellやIdrisも同じようなスタイルなのでそういうものと自分で納得しました。
そして私はさっそく、倉庫番のゲームを作り始めました。あの、十分にシンプルで、コンソールで動かせて、楽しいゲームです。&lt;/p&gt;

&lt;p&gt;しかしすぐにそううまい話はないと気付きます。
再帰的データ型を定義するとすぐにエラーになりますし（&lt;code&gt;Box&lt;/code&gt;が必要と気付くまでしばらくかかりました）、ハッシュテーブルを使うとすぐミュータブルが必要になります（ハッシュテーブルの操作が破壊的ということをすっかり忘れていました）。
そして何より所有権のせいで思うようにプログラムが書けませんでした。
関数型プログラミングではメモリは無尽蔵にあると思ってプログラミングするのでRustのパラダイムとはとてつもない隔りがありました。
最初は、所有権についてはCleanやGHCにある一意型、あるいはATS2の線形型のようなものだと思えばそう難しくないと踏んでいましたが、実際のところ何もかも思い通りにいきませんでした。
プログラム全てで所有権を意識するのが思いの外難しかったのです。
それでもコンパイル時にコードの安全性を検査出来るのは喜ばしいことだと思って、&amp;rdquo;ボローチェッカとの戦い&amp;rdquo;を数日続けました。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;ボローチェッカとの戦い&amp;rdquo;をしばらく続けて気付いたのは、コンパイラは理不尽な理由で怒ったりしていないということでした。
関数型言語ではデータほとんどイミュータブルなのでデータをコピーしたいのか参照したいのかあまり区別する必要がありませんでしたがRustでは厳密に区別しているだけのことでした。
むしろ、所有権の概念は、一度コンパイラの気持ちを理解してしまえば所有権や参照を意識せずにプログラミングするのが気持ち悪いとさえ感じるほどに自然でした。&lt;/p&gt;

&lt;p&gt;それ以外の点ではトレイトや導出はMLプログラマからすると羨望の的でしたし（余談ですがRustの導出は昔はHaskell風に&lt;code&gt;#[deriving(Show)]&lt;/code&gt;と書いていましたが、いつからか&lt;code&gt;#[derive(Debug)]&lt;/code&gt;と書くようになったようです。）、
オブジェクト指向についても上手くやっていると感じました（関数型プログラミング言語でもオブジェクト指向はします！）。&lt;/p&gt;

&lt;p&gt;Lispプログラマから一言あるとすれば、マクロです。RustのマクロはSchemeの&lt;code&gt;syntax-rules&lt;/code&gt;相当の機能しかなく、Common Lispプログラマの私にはもの足りませんでした。
&lt;code&gt;macro_rules&lt;/code&gt;でも無いよりはましですし、C言語のマクロよりは素晴らしいものです。
それでもどうしても伝統的なマクロが欲しくなりますが、不安定なコンパイラプラグインの機能しか選択肢がありません（訳注: 現在のRustにはproc_macroが入ったので伝統的なマクロも書けます）。&lt;/p&gt;

&lt;h1 id=&#34;ツール&#34;&gt;ツール&lt;/h1&gt;

&lt;p&gt;私の好きなEmacsのサポートはしっかりしていましたし、大きな不満はありませんでした。
REPLこそありませんがむしろSMLに比べると補完や定義ジャンプなどリッチな機能さえありました。&lt;/p&gt;

&lt;p&gt;それよりも、ビルドツールについてです。
Rustは関数型プログラムで永遠のテーマだった分割コンパイルをするとインライン化が妨げられるが全プログラムコンパイルをするとコンパイル時間が掛かりすぎるという問題にモジュールより上位のクレートという単位を設けることで解決を見出したのです。
それに素晴らしきCargo。依存関係の地獄はありませんし、Makefileを書く必要もありません。パッケージインストーラがランタイムにまで侵入してくることもありません。
私達がプログラムを書くことに集中させてくれます。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;関数型プログラマがRustを使うと、所有権やミュータビリティ、メモリへの厳しさに最初は面くらうもののすぐに馴れて普段通りにプログラムを書けるようになります。
もちろん、Rustはむしろ手続き型な言語なので関数型プログラムそのまま、とはいきませんが普段使っている道具がそのまま使えるのでハードルは低いですし、むしろ手続き型プログラムに馴れた人が戸惑わないか心配にすらなります（初めてC++プログラマがRustをスラスラ書けると聞いたときには大変驚きました）。
Rustは関数型プログラマ、手続き型プログラマ問わず良い言語なのでみなさんも最初の一歩を踏み出しましょう！&lt;/p&gt;

&lt;h1 id=&#34;メタ&#34;&gt;メタ&lt;/h1&gt;

&lt;p&gt;私のブログは記事によって意識的に文体を変えているのですが、今回は新たな試みとして「海外でちょっと流行った記事の野良和訳」風に書いてみました。
なので海外風に「明らかに」などの強いワードを用いたり誤訳っぽいワードを埋めたいあまつさえ（訳注:〜）なんてものが出現しますが特に原文はないです。
案外疲れました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ソフトウェアエンジニアがFPGAやってみる</title>
      <link>/slide/sofutoueaenjiniagaFPGAyattemiru/</link>
      <pubDate>Tue, 28 Mar 2017 09:21:33 +0900</pubDate>
      
      <guid>/slide/sofutoueaenjiniagaFPGAyattemiru/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ソフトウェアエンジニアがPYNQでFPGAやってみる
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# よくある話
------------

&lt;div class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;&gt;「Lisperって自分のLispを作るらしいよ」 &lt;/div&gt;
&lt;div class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;&gt;「Lispって昔は専用ハードウェアで動いてたらしいよ」 &lt;/div&gt;
&lt;div class=&#34;fragment&#34; data-fragment-index=&#34;3&#34;&gt;「じゃあハードウェア作んなきゃ」 &lt;/div&gt;
&lt;div class=&#34;fragment&#34; data-fragment-index=&#34;4&#34;&gt;「FPGAやるかー」 &lt;/div&gt;

===

# FPGAって？
------------

* Field-Programmable Gate Array
* プログラマブルな集積回路
  + オレオレ設計のCPU作ったり
  + HDMI入力を直でmpg4にエンコードするデバイスとかも
* クロックはASIC(ふつうのCPU)より大分遅い
* でも上手く嵌れば100倍高速化とか

===

# PYNQって？
------------

* [PYNQ-Z1 Python Productivity for Zynq - Digilent](http://store.digilentinc.com/pynq-z1-python-productivity-for-zynq/)
* xilinxのFPGAとARMのチップが載ったSoC
* ARMで動いてるPython(Jupyter)からFPGAにロジック焼ける
  + 手軽にロジックを試せる
* FPGAとの通信はMMIO
  + 特定のアドレスのメモリにデータを書くとFPGAに送られる
  + メモリのデータを読むとFPGAからデータが送られる

===

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;会社にPYNQがきたよ！！azure倒したら遊ぶ！！！！ &lt;a href=&#34;https://t.co/ohJg7z4lxd&#34;&gt;pic.twitter.com/ohJg7z4lxd&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/828834126572589056&#34;&gt;2017年2月7日&lt;/a&gt;&lt;/blockquote&gt;

===

# ハードウェアロジック
---------------------

* ハードウェア記述言語(HDL)を使う
  + メジャーなのはVHDLとVerilog
  + 今回はVerilogの話
* クロックとかレジスタとかワイヤーとか駆使する
* 電気信号なのでロジックが並列で走る
* vivadoというツールでコンパイル
  + Tclで制御も出来る
* 回路設計とかも
* コンパイルは結構遅い…
* CPUと通信するときの規格とかも書かなきゃいけない
  * AXI LiteとかAXI Fullとか…
  * 一応自動で生成はしてくれる

===

![vivadoのスクショ](/images/fpga/vivado.png) &lt;!-- .element: width=&#34;100%&#34; --&gt;

===

# なんか作ってみる1
------------------

* Lチカ
* [Vivado and zybo linux勉強会資料3](https://www.slideshare.net/marsee101/vivado-and-zybo-linux3)
* ↑ロジック焼くとこ以外ほぼこれのまま
* ロジックで作ったワイヤーと実際のLEDのワイヤー結んだりして楽しい
* AXI LiteでCPUと繋がって間隔変えたり出来る

===

``` verilog
reg [3:0] LED_Display_Counter;
reg [31:0] LED_Interval_Counter;
reg slv_reg_wren_1d;

// slv_reg_wren_1d generate
always @(posedge S_AXI_ACLK) begin
   if (~S_AXI_ARESETN)
       slv_reg_wren_1d &lt;= 1&#39;b0;
   else
       slv_reg_wren_1d &lt;= slv_reg_wren;
end

// LED_Interval_Counter
always @(posedge S_AXI_ACLK) begin: proc_LED_Interval_Counter
   if (~S_AXI_ARESETN) begin
       LED_Interval_Counter &lt;= 32&#39;d0;
   end else begin
       if (slv_reg0[0]) begin // Enable
           if (LED_Interval_Counter == 32&#39;d0)
               LED_Interval_Counter &lt;= slv_reg3;
           else
               LED_Interval_Counter &lt;= LED_Interval_Counter - 32&#39;d1;
       end else
           LED_Interval_Counter &lt;= slv_reg3;
   end
end

/// Counters
// LED_Display_Counter
always @(posedge S_AXI_ACLK) begin: proc_LED_Display_Counter
   if (~S_AXI_ARESETN) begin
       LED_Display_Counter &lt;= 4&#39;d0;
   end else begin
       if (slv_reg_wren_1d &amp;&amp; axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2&#39;h1) // Counter Load
           LED_Display_Counter &lt;= slv_reg1[3:0];
       else if (slv_reg0[0]) begin  // Enable
           if (LED_Interval_Counter == 32&#39;d0)
               LED_Display_Counter &lt;= LED_Display_Counter + 4&#39;d1;
       end
   end
end

assign LED4bit = LED_Display_Counter;
```

===

![jupyterのスクショ](/images/fpga/led4bit.png)&lt;!-- .element: width=&#34;100%&#34; --&gt;

===

# なんか作ってみる2
------------------

* 簡易計算機
* 渡された2値で演算
  + 四則演算とか論理演算とか
* AXI Liteで通信
  + AXI Liteはレジスタのみ通信可能

===

```verilog
reg [C_S_AXI_DATA_WIDTH-1:0] res;

always @(posedge S_AXI_ACLK) begin
   if (S_AXI_ARESETN == 1&#39;b0) begin
      res &lt;= 32&#39;h0;
   end else if (~ slv_reg_wren)
     begin
        if (slv_reg0[0]) begin
           case (slv_reg1)
             32&#39;h0: res &lt;= slv_reg2 + slv_reg3;
             32&#39;h1: res &lt;= slv_reg2 - slv_reg3;
             32&#39;h2: res &lt;= slv_reg2 * slv_reg3;
             default: res &lt;= res;
           endcase // case (slv_reg1)
        end
     end
end // always @ (posedge S_AXI_ACLK)

always @(posedge S_AXI_ACLK) begin
   slv_reg4 &lt;= res;
   slv_reg0 &lt;= 32&#39;b0;
end

```

===

![jupyterのスクショ](/images/fpga/alu.png) &lt;!-- .element: width=&#34;100%&#34; --&gt;


===

# なんか作ってみる3
------------------

* 命令列を受け取って計算
* 内部で16のレジスタ、プログラムカウンタなど
* CPUっぽい動き
* CPUとの通信はAXI Full
  + メモリに触れる

===

``` verilog
generate
   if (USER_NUM_MEM &gt;= 1)
 begin
    assign mem_select  = 1;
    assign mem_address = (axi_arv_arr_flag? axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:(axi_awv_awr_flag? axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:0));
 end
endgenerate

function [3:0] fop;
   input reg[C_S_AXI_DATA_WIDTH-1:0] opcode;
   fop = opcode[C_S_AXI_DATA_WIDTH-1 -: 4];
endfunction

function [3:0] fret;
   input reg[C_S_AXI_DATA_WIDTH-1:0] opcode;
   fret = opcode[C_S_AXI_DATA_WIDTH-5 -: 4];
endfunction

function [3:0] freg1;
   input reg[C_S_AXI_DATA_WIDTH-1:0] opcode;
   freg1 = opcode[C_S_AXI_DATA_WIDTH-9 -: 4];
endfunction

function [3:0] freg2;
   input reg[C_S_AXI_DATA_WIDTH-1:0] opcode;
   freg2 = opcode[C_S_AXI_DATA_WIDTH-13 -: 4];
endfunction

function [15:0] fconst1;
   input reg [C_S_AXI_DATA_WIDTH-1:0] opcode;
   fconst1 = opcode[C_S_AXI_DATA_WIDTH-13 -: 16];
endfunction

// implement Block RAM(s)
wire                                 mem_rden;
wire                                 mem_wren;
wire [C_S_AXI_DATA_WIDTH-1:0]        data_out;
wire [C_S_AXI_DATA_WIDTH-1:0]        start;
reg [C_S_AXI_DATA_WIDTH-1:0]         result;
reg [C_S_AXI_DATA_WIDTH-1:0]         r[0:15];
reg [C_S_AXI_ADDR_WIDTH-1:0]         pc;
reg [1:0]                            finish;
reg [C_S_AXI_DATA_WIDTH-1:0]         byte_ram [0 : 31];
reg [3:0]                            state;
reg [C_S_AXI_DATA_WIDTH-1:0]         opword;
reg [3:0]                            op;
reg [3:0]                            ret;
reg                                  reten;
reg [C_S_AXI_DATA_WIDTH-1:0]         retreg;
reg [C_S_AXI_DATA_WIDTH-1:0]         reg1;
reg [C_S_AXI_DATA_WIDTH-1:0]         reg2;
reg [15:0]                           const1;

assign mem_wren = axi_wready &amp;&amp; S_AXI_WVALID ;

assign mem_rden = axi_arv_arr_flag ; //&amp; ~axi_rvalid

assign data_out = byte_ram[mem_address];

assign start = byte_ram[1];

localparam integer PC_START = 2;

always @(posedge S_AXI_ACLK)
  begin
     if (S_AXI_ARESETN == 0 || start == 32&#39;b0)
       begin
          finish &lt;= 0;
          pc &lt;= PC_START;
          result &lt;= 0;
          state &lt;= 0;
          reten &lt;= 0;
          retreg &lt;= 0;
          ret &lt;= 0;
          reg1 &lt;= 0;
          reg2 &lt;= 0;
          const1 &lt;= 0;
          r[0] &lt;= 0; r[1] &lt;= 0;
          r[2] &lt;= 0; r[3] &lt;= 0;
          r[4] &lt;= 0; r[5] &lt;= 0;
          r[6] &lt;= 0; r[7] &lt;= 0;
          r[8] &lt;= 0; r[9] &lt;= 0;
          r[10] &lt;= 0; r[11] &lt;= 0;
          r[12] &lt;= 0; r[13] &lt;= 0;
          r[14] &lt;= 0; r[15] &lt;= 0;
       end
     else if (finish != 2&#39;d2)
       begin
          case (state)
            // fetch
            4&#39;d0: begin
               opword &lt;= byte_ram[pc];
               state &lt;= 4&#39;d1;
            end
            // decode
            4&#39;d1: begin
               op &lt;= fop(opword);
               ret &lt;= fret(opword);
               reg1 &lt;= r[freg1(opword)];
               reg2 &lt;= r[freg2(opword)];
               const1 &lt;= fconst1(opword);
               state &lt;= 4&#39;d2;
            end
            //execute
            4&#39;d2: begin
               case (op)
                 // add
                 4&#39;b0000: begin
                    retreg &lt;= reg1 + reg2;
                    reten &lt;= 1;
                 end
                 // sub
                 4&#39;b0001: begin
                    retreg &lt;= reg1 - reg2;
                    reten &lt;= 1;
                 end
                 // mul
                 4&#39;b0010: begin
                    retreg &lt;= reg1 * reg2;
                    reten &lt;= 1;
                 end
                 // or
                 4&#39;b0011: begin
                    retreg &lt;= reg1 | reg2;
                    reten &lt;= 1;
                 end
                 // and
                 4&#39;b0100: begin
                    retreg &lt;= reg1 &amp; reg2;
                    reten &lt;= 1;
                 end
                 // xor
                 4&#39;b0101: begin
                    retreg &lt;= reg1 ^ reg2;
                    reten &lt;= 1;
                 end
                 // add imm
                 4&#39;b1000: begin
                    retreg &lt;= reg1 + const1;
                    reten &lt;= 1;
                 end
                 // sub imm
                 4&#39;b1001: begin
                    retreg &lt;= reg1 - const1;
                    reten &lt;= 1;
                 end
                 // mul imm
                 4&#39;b1010: begin
                    retreg &lt;= reg1 * const1;
                    reten &lt;= 1;
                 end
                 // or imm
                 4&#39;b1011: begin
                    retreg &lt;= reg1 | const1;
                    reten &lt;= 1;
                 end
                 // and imm
                 4&#39;b1100: begin
                    retreg &lt;= reg1 &amp; const1;
                    reten &lt;= 1;
                 end
                 // jz
                 4&#39;b1101: begin
                    if (reg1 == 32&#39;b0)
                      pc &lt;= const1 - 1 + PC_START;
                    reten &lt;= 0;
                 end
                 // j
                 4&#39;b1110: begin
                    pc &lt;= const1 - 1 + PC_START;
                    reten &lt;=0;
                 end
                 // exit
                 4&#39;b1111: begin
                    pc &lt;= PC_START - 1;
                    result &lt;= reg1;
                    finish &lt;= 1;
                    reten &lt;= 0;
                 end
                 // error
                 default: begin
                    pc &lt;= PC_START - 1;
                    result &lt;= op;
                    finish &lt;= 1;
                    reten &lt;= 0;
                 end
               endcase
               state &lt;= 3;
            end
            // write back
            4&#39;d3: begin
               pc &lt;= pc + 1;
               if (reten)
                 r[ret] &lt;= retreg;
               if (finish == 1)
                 finish &lt;= 2;
               state &lt;= 0;
            end

          endcase
       end
  end

always @( posedge S_AXI_ACLK )
  begin
 if (mem_rden)
   begin
          if (mem_address == 0)
        mem_data_out[0] &lt;= result;
          else
            mem_data_out[0] &lt;= data_out;
   end
  end


generate
   for(mem_byte_index=0; mem_byte_index&lt;= (C_S_AXI_DATA_WIDTH/8-1); mem_byte_index=mem_byte_index+1)
 begin:BYTE_BRAM_GEN
    wire [8-1:0] data_in ;
    integer      j;

    //assigning 8 bit data
    assign data_in  = S_AXI_WDATA[(mem_byte_index*8+7) -: 8];

    always @( posedge S_AXI_ACLK )
      begin
         if (mem_wren &amp;&amp; S_AXI_WSTRB[mem_byte_index])
           begin
              byte_ram[mem_address][(mem_byte_index*8+7) -: 8] &lt;= data_in;
           end
      end
 end
endgenerate
//Output register or memory read data

always @( mem_data_out, axi_rvalid)
  begin
 if (axi_rvalid)
   begin
      // Read address mux
      axi_rdata &lt;= mem_data_out[0];
   end
 else
   begin
      axi_rdata &lt;= 32&#39;h00000000;
   end
  end
```

===


![jupyterのスクショ](/images/fpga/alu2.png) &lt;!-- .element: width=&#34;100%&#34; --&gt;


===

# まとめ
--------

* FPGA楽しいよ
* CPUっぽいの作れるよ
* PYNQ便利だよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rust in Production</title>
      <link>/slide/Rust_in_Production/</link>
      <pubDate>Wed, 22 Mar 2017 19:57:28 +0900</pubDate>
      
      <guid>/slide/Rust_in_Production/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rust in Production
----------------------
[Rust プログラマーミートアップ / Rust programmers&#39; meetup - connpass](https://rust.connpass.com/event/49304/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * 若者
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# Rust採用までの流れ
--------------------

Ω＜「κeen君継続的ベンチマークサーバ作って」&lt;!-- .element: style=&#34;color:#a00;text-align:left;&#34; --&gt;  
Ω＜「GitHubにpushする度ベンチマーク走る感じで」&lt;!-- .element: style=&#34;color&#34;:#a00;text-align:left;&#34; --&gt;  
Ω＜「GPUとRaspberry Piでベンチマークするから」&lt;!-- .element: style=&#34;color:#a00;text-align:left;&#34; --&gt;  
Ω＜「全部任せるね」&lt;!-- .element: style=&#34;color:#a00;text-align:left;&#34; --&gt;  

⸜( ¯⌓¯ )⸝「Rustで書くか」&lt;!-- .element: style=&#34;color:#00a;text-align:left;&#34; --&gt;  


やったこととか知見とかトピック毎にかいつまんで話します

&lt;!-- .slide: class=&#34;left&#34; --&gt;

===
# Rustのメリット
---------------

* κeenが馴れてる
* 社員の半分くらい書ける
* Linux, Mac, Raspberry Piで動く
* テスト書かなくてもそんなにバグらなそう
* 将来のために小さいところでノウハウ溜めていきたい
* シングルバイナリで楽に動きそう
* **単純に使いたかった**
* ※今回は速度や安全性は必要ない

===
# コンポーネント
---------------

* CLIクライアント
  + 各自の手元やCIサーバから起動
* アグリゲータ
  + ワーカに仕事を投げ、結果を受け取る
  + ジョブ管理
* ワーカ
  + GPUマシンやRSPiなどでベンチマーク
  + 結果をアグリゲータに返す
* ブラウザ
  + ベンチマーク結果の閲覧

===
# プロジェクト構成
-------------------

* [ワークスペース](http://doc.crates.io/manifest.html#the-workspace--field-optional)を使ってサブプロジェクトに分割
  + モノリシックだとビルドが重かった
  + targetは全てのプロジェクトで共有する
* CLI, aggregator, worker, browserの他にmodel, api
* modelはaggregatorとbrowserで共有
* apiはaggergatorとcliとworkerで共有
* コード

===

# プロジェクト構成
-------------------


```
Cargo.lock
Cargo.toml
README.md
bench_aggregator/
bench_api/
bench_browser/
bench_cli/
bench_model/
bench_worker/
build.sh
circle.yml
docker-compose-deploy.yml
docker-compose.yml
migrations
rustfmt.toml
src/
static/
target/
```

===
# プロジェクト構成
-------------------

![構成のイメージ](/images/rust-in-production/composition.png)&lt;!--  width=&#34;100%&#34; --&gt;


===
# パーサ
--------

* workerで使う
* timeやgprofの結果を数値で欲しい
* →パースするか…
  + フォーマット
* timeはbash固定
  + シェルコマンドなのでシェル毎にフォーマットが違う
* gprofは`-b`オプションでの結果をパース
  + gmon.outではない

===
# パーサ
--------

* パーサコンビネータ [nom](https://github.com/Geal/nom)
* サクっと作れた
* デバッグつらい
  + gprofが思ったより変なフォーマットしてた
  + nomがバイト指向なのと位置を保存しない
  + 自力でどうにかする？
  + [combine](https://github.com/Marwes/combine)使うか手書きにするかで書き直したい
* コード

===

# CLIオプション
---------------

* workerとcliで必要
* 多機能な[clap](https://github.com/kbknapp/clap-rs)を採用
* 特に困らない
* 採用プロジェクトも多くてliving exampleに事欠かない
* CLIツールに思考停止で採用していいと思う
* コード

===
# HTTPクライアント
------------------

* CLIとworkerで使う
* [hyper](https://github.com/hyperium/hyper) vs [reqwest](https://github.com/seanmonstar/reqwest)
* 非同期な必要はないのでreqwest使いたかった
* reqwestにmultipart対応がない→生hyper+[multipart](https://github.com/abonander/multipart)
* コネクションの管理とかjsonの扱いとかそこそこ面倒だった…
* reqwestにmultipart対応入ったら乗り換えるかも

===
# HTTPサーバ
------------

* aggregatorとbrowserで使う
* 簡単なREST API
* 生hyper vs [nickel](https://github.com/nickel-org/nickel.rs) vs [iron](https://github.com/iron/iron)
* 生hyperはすぐつらくなる→やめた
* **nickelとironはそんなに変わらなかった**
* nickel(agregator)+iron(browser)
  + aggregatorはなんとなくでnickel選んじゃった
  + browserは結局[rustc-perf](https://github.com/rust-lang-nursery/rustc-perf)からフォークしたためironだった

===

# HTTPサーバ(Nickel)
------------

* サーバデータの扱いがちょっと特殊？
  ```rust
    let data = req.server_data();
  ```
* 400 BadRequestと500 InternalServerErrorのマクロ作った
  + `validate!(res, serde_json::from_str(field));`
  + `server_try_with!(res, serde_json::to_string(&amp;ret));`
  + 「エラー出たら処理終了」が他の言語と比べて書きづらい？
* 非同期IOしない…
  + ポーリングでコネクション張りっぱなしなのでクライアント分スレッドが必要（ハマった）
* マルチスレッド→DBコネクションにロックが必要
* コード

===
# APIモデル
-----------

* apiクレートを分けた
  + バイナリ毎に別クレートに分けるために必要だった
* [serde](https://github.com/serde-rs/serde)と[serde_json](https://github.com/serde-rs/json)でjson化
* proc-macroがstableになって格段に使いやすくなった
* モジュール分けて`Request`と`Response`を作ってAPIが分かりやすく
* コード

===
# DB
-----

* aggergatorとbrowserで必要
* ほぼ[diesel](https://github.com/diesel-rs/diesel)一択
  + コネクション、マイグレーション、ORMなど
  + proc-macroで大分楽に
* [仕事でdiesel使ってみた | κeenのHappy Hacκing Blog](https://keens.github.io/slide/shigotodedieseltsukattemita/)
* DBはPostgreSQL
  + 半分dieselのため、もう半分機能のため
* 開発時はdocker-composeで立てる
  + CF [docker-composeでmysql &amp; postgreSQL をサクッと起動 - Qiita](http://qiita.com/astrsk_hori/items/1e683a7a2f2b7189cb6e)

===
# diesel
-----

* Pros
  + SQLでスキーマ書ける
  + マイグレーションの面倒みてくれる
  + proc-macroのおかげで楽
  + クエリDSL案外普通に書けた
  + 最悪SQL生牡蠣出来る
  + CLI便利

===
# diesel
--------

* Cons
  + deriveいっぱいあって難しい
    - has_manyとbelongs_toあたりをどう書くか
  + enum扱えない
  + DSLで2重join書けない
  + 偶に機能足りない
    - ネットワークアドレス型サポートとか
  + SQL生牡蠣の型付けつらい
  + has_manyの扱いに難あり
    - eager loadingしない設計判断
    - `(User, Vec&lt;Tweets&gt;)` みたいなのを持ち回す羽目に
    - モデル設計にも影響

===
# マイグレーション
-----------------

* 普通のマイグレーション運用かな
* 最初のデプロイまでは`diesel database reset`で何度も初期化した
* 最初デプロイ後は手元で`diesel migration run`と`diesel migration revert`を何度か
* デプロイ時に雑に手元から本番サーバに `diesel migration run`
  + 本当はデプロイプロセスに組込みたい
  + diesel CLIの入ったdockerコンテナ…
* まだほとんど使われてないので雑運用


===
# マイグレーション(コード)
-----------------

* スキーマ変更したらコードの変更も必要
  + そもそも必要だからスキーマ変更するので割と自然に出来る
* `infer_schema` があるので先に開発環境のマイグレーションをしないといけない
* カラムの順番とフィールドの順番が一致する必要
  + 地味に面倒
  + 今後改善予定 CF [#747](https://github.com/diesel-rs/diesel/pull/747)
* SQL生牡蠣の対応がつらい
  + コンパイル時にカラム不足が分からない

===
# エラー管理
------------

* 全ての場所で必要
* [error_chain](https://github.com/brson/error-chain)を採用
* 公式ドキュメントの[エラーハンドリング](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/error-handling.html)のボイラプレートをマクロで生成
* `?`でのエラー処理が楽になる→ `unwrap`が消えた
* 全てのプロジェクトに思考停止で採用していいんじゃないかな

===

# ログ
------

* 全ての場所で必要
* nurseryの[log](https://github.com/rust-lang-nursery/log)と[env_logger](https://github.com/rust-lang-nursery/log)を採用
* `println!`より高機能な（on/offが出来る）ので`println!`の代わりに`debug!`を入れる
* あとたまにエラーハンドリングで`error!`使ったり
* `main`で一行`env_logger::init().expect(&#34;failed to init env logger&#34;);`を忘れずに
* 運用以前に開発に便利なので問答無用で入れていいと思う

===
# コンフィグ
------------

* [serde_yaml](https://github.com/dtolnay/serde-yaml) + [dotenv](https://github.com/slapresta/rust-dotenv)
* コンフィグファイルといえばyamlだよね
  + ちょこっといじって再起動がやりやすい
* dotenvはdockerと相性がいい気がする
* どっちがいいか判断出来なかったので両方実装
* プロダクションで動いてるのはdotenv（というか普通の環境変数）の方

===

# テスト
--------

* 全ての場所で必要
* 組込みの`#[test]`を使用
* 正直あまり出来てない
* 型強いし多少はなくてもバグらない…？
* 一応レイヤ(DB/ビジネスロジック/インタフェース)を跨ぐときにはtraitで抽象化
  + 出来てないところもいっぱい
* 今後の課題とさせて頂きます

===
# デバッグ
----------

* 基本はlogの`debug!`でトレース
* ちゃんと型つけときゃバグらない
* GDB使う…？
* デモ

===

# ビルド
--------

* cargoでサブプロジェクト全てをビルドするコマンドがなかった
  + 最近 `cargo build --all` が入った
* Raspberri Pi向けにクロスコンパイルが必要
* シェルスクリプトでビルドスクリプト
* クロスコンパイルはdockerを使う CF [dlecan/rust-crosscompiler-arm: Docker images for Rust dedicated to cross compilation for ARM v6 and more](https://github.com/dlecan/rust-crosscompiler-arm)
* 正解なのか分からない

===
# CI
----

* 全てのクレートで必要
* Circle CIを使ってる
* 普通にrustupでRustのインストール
  + travisならRustサポートあるけど…
* 普通に `cargo test --all`

===

# デプロイ
----------

* シングルバイナリだけど…
* シュっとdocker-swarmとかでデプロイしたい
* dockerイメージ作ってdocker-composeで管理
  + 開発も便利に
* raspberry piはバイナリだけ配る
* browserは`static/`もイメージに同梱

===
# Docker
--------

* ベースイメージはUbuntu
  + libcの扱いが面倒そうなのでalpineはやめといた
  + イメージサイズに困ってからどうにか考える
* swarmなのでdocker-composeの設定そのままで動かせる
* ログの管理もswarm任せ
  + env_loggerが標準出力に吐くのもそんなに困ってない

===
# Docker
--------

* rustのビルドからのdockerのビルドが面倒
* Dockerfileの管理も面倒
* 便利なの作った
* [KeenS/cargo-pack-docker: a cargo subcommand to package your application into a docker image](https://github.com/KeenS/cargo-pack-docker)
* DockerfileなしでRustのビルドからイメージ作成までやってくれる
* 今のところ使えてる
  + 作りが甘いことは認識してる…

===
# まとめ
---------

* Rustを仕事で使ったときの知見を話した
* 微妙に痒いところに手が届かないけど概ね揃ってる
* 開発が速いので問題は放置しとくと勝手に直るかも
* テストとかデプロイとかまだ知見が足りない


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>オーディナルの話とカーディナルの話</title>
      <link>/blog/2017/03/02/o_dinarunohanashitoka_dinarunohanashi</link>
      <pubDate>Thu, 02 Mar 2017 21:15:44 +0900</pubDate>
      
      <guid>/blog/2017/03/02/o_dinarunohanashitoka_dinarunohanashi</guid>
      <description>&lt;p&gt;ちょっとオーディナルの話をしよう。ついでにカーディナルの話もしよう。
特に何も知らなくても分かる内容。だけど文脈を知ってると伝えたいことが伝わる筈。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;まずは何もないところから始めよう。机もスマホもパソコンンもない。空気もないし数字もない、自然数もない。&lt;/p&gt;

&lt;p&gt;何もない。&lt;/p&gt;

&lt;p&gt;「何もない」、もうちょっと正確にいうと「何も要素がない集合」のことを覚えているだろうか。中学校で習った気もする。&lt;/p&gt;

&lt;p&gt;\[
\emptyset
\]&lt;/p&gt;

&lt;p&gt;と書く。
さて、ここから始める。何もないところから何か作れるだろうか。まずは $\emptyset$ を要素に持つ集合、&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset\}
\]&lt;/p&gt;

&lt;p&gt;がある。これは要素を1つだけ持つので $\emptyset$ とは異なる集合だ。これをさらに進められないだろうか。例えば&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \emptyset\}
\]&lt;/p&gt;

&lt;p&gt;とか。これではダメだ。結局2つの要素が同じ $\emptyset$ なので要素を取り出してみても $\{\emptyset\}$ から取り出したときと区別がつかない。
何か $\emptyset$ とは別のものが必要だ。 $\emptyset$ とは別のもの。既に出てきた。 $\{\emptyset\}$ だ。&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \{\emptyset\}\}
\]&lt;/p&gt;

&lt;p&gt;これで $\emptyset$ とも $\{\emptyset\}$ とも異なる集合が作れた。ここまできたらあとはもうパターンだ。「次」が欲しければ今までに出てきた集合を全部$\{\}$に放り込めばいい。&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\}
\]&lt;/p&gt;

&lt;p&gt;「次(Successor)」を求める手続を $\mathbf{succ}$ と書くとすると、集合の合併 $\cup$ を用いて&lt;/p&gt;

&lt;p&gt;\[
\mathbf{succ} (x) = x \cup \{x\}
\]&lt;/p&gt;

&lt;p&gt;と書ける。この $\mathbf{succ}$ 、必ず新たな集合を生み出している。これはつまり、任意の $x$ に対して $\mathbf{succ}(x)$ は $\emptyset$ にはならないし、 $x \not= y$ のとき $\mathbf{succ}(x) \not=\mathbf{succ}(y)$ でもある。
このようなものをご存知ないだろうか(細かいことを言うと帰納法の原理も必要だが飛ばす)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%9A%E3%82%A2%E3%83%8E%E3%81%AE%E5%85%AC%E7%90%86&#34;&gt;自然数&lt;/a&gt;だ。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$\emptyset$ がある&lt;/li&gt;
&lt;li&gt;任意の自然数 $x$ に $\mathbf{succ}(x)$ がある&lt;/li&gt;
&lt;li&gt;$\emptyset$ はいかなる自然数 $x$ の $\mathbf{succ}$ でもない&lt;/li&gt;
&lt;li&gt;$x \not= y$ のとき $\mathbf{succ}(x) \not=\mathbf{succ}(y)$&lt;/li&gt;
&lt;li&gt;(帰納法の原理が成り立つ)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これは、こういうことだ。&lt;/p&gt;

&lt;p&gt;\[
\begin{eqnarray}
0 &amp;amp; = &amp;amp; \emptyset \\\&lt;br /&gt;
1 &amp;amp; = &amp;amp; \{\emptyset\} \\\&lt;br /&gt;
2 &amp;amp; = &amp;amp; \{\emptyset, \{\emptyset\}\} \\\&lt;br /&gt;
3 &amp;amp; = &amp;amp; \{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\} \\\&lt;br /&gt;
  &amp;amp; \vdots &amp;amp;
\end{eqnarray}
\]&lt;/p&gt;

&lt;p&gt;ここでは &lt;a href=&#34;https://twitter.com/search?q=%230%E3%81%AF%E8%87%AA%E7%84%B6%E6%95%B0&amp;amp;src=typd&#34;&gt;#0は自然数&lt;/a&gt; としてある。
さて、今我々は何もないところから出発してDASH村のように自然数を作り上げた。&lt;/p&gt;

&lt;p&gt;この自然数、面白い性質がある。 0 は 1の要素( $0 \in 1$) だ。 1 は 2 の要素 ( $1 \in 2$ )だし、0も2の要素 $0 \in 2$ だ。もうちょっというと、 $x \in y$ かつ $y \in z$ のとき、 $x \in z$も成り立つ。
この関係で自然数には順序がつく。つまり、自然数は&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E9%A0%86%E5%BA%8F%E6%95%B0&#34;&gt;順序数&lt;/a&gt;(オーディナルナンバー)だ。再度、オーディナルナンバーであるところの自然数を列挙するとこうなる。&lt;/p&gt;

&lt;p&gt;\[
\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}, \{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\}, &amp;hellip;
\]&lt;/p&gt;

&lt;p&gt;これに見覚えがあるならオーディナルの話はこれで十分。&lt;/p&gt;

&lt;p&gt;さて、カーディナルの話をしよう。 $\emptyset$ は要素が0個。 $\{\emptyset\}$ は要素が1つ。 $\{\emptyset, \{\emptyset\}\}$ は要素が2つ。
要素数の話だ。これは別に自然数だけでなくて、 $\{2, 4\}$ のように自然数ではない集合でも要素数という概念はある。要素数をどう数えようか。一応要素数に&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%BF%83%E5%BA%A6_(%E6%95%B0%E5%AD%A6)&#34;&gt;濃度&lt;/a&gt;という名前もついている。
これにも自然数が使える。2と $\{2, 4\}$ を $\{2, 4\}$ を $2 -\emptyset$ と $4 - \{\emptyset\}$ と1対1に対応づければ、「$\{2, 4\}$と 2は同じ濃度を持つ」といえる。
このように濃度を数えるための数を&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0&#34;&gt;基数&lt;/a&gt;（カーディナルナンバー）という。&lt;/p&gt;

&lt;p&gt;手で数えられる（有限な）ものは面白みがない。無限なものについて考えよう。例えば今我々が作った自然数は常に $\mathbf{succ}$ がとれるので無限の要素がある。
まだ作ってないが、自然数だけでなく整数にも有理数にも実数にも無限の要素がある。これらの「無限」は全て同じ大きさなのだろうか、つまり同じ濃度なのだろうか。
結論からいうと自然数と整数と有理数は同じ濃度を持つ。全て自然数と1対1の対応が取れるということだ。一方&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB%E3%81%AE%E5%AF%BE%E8%A7%92%E7%B7%9A%E8%AB%96%E6%B3%95&#34;&gt;実数は対応が作れない&lt;/a&gt;。実数の濃度の方がずっと大きい訳だ。つまり、無限の間にも大小関係がある。実は自然数は無限の中でも一番小さい。この一番小さい基数のことをヘブライ文字からとって&lt;/p&gt;

&lt;p&gt;\[
\aleph_0
\]&lt;/p&gt;

&lt;p&gt;と書く。これも見覚えがあればカーディナルの話はこれにて重畳。&lt;/p&gt;

&lt;p&gt;そういえばこういう「紙の上でDASH村」を気に入ったならこの本がお勧め。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4791768515&#34;&gt;コンピュータは数学者になれるのか? -数学基礎論から証明とプログラムの理論へ- | 照井一成 |本 | 通販 | Amazon&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>仕事でdiesel使ってみた</title>
      <link>/slide/shigotodedieseltsukattemita/</link>
      <pubDate>Wed, 01 Mar 2017 10:57:38 +0900</pubDate>
      
      <guid>/slide/shigotodedieseltsukattemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 仕事でdiesel使ってみた
----------------------
[RustのLT会！ Rust入門者の集い #2 - connpass](https://rust.connpass.com/event/48826/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# [diesel.rs](diesel.rs)

![dieselのwebページ](/images/diesel/diesel-web.png)

===

# diesel
---------


* RustのORM
  * スキーマからコード自動生成
  * diesel_codegen
* クエリビルダ
* マイグレーション管理
* PostgreSQL, MySQL, SQLiteサポート

===

# 準備
-------

* [docker-composeでmysql &amp; postgreSQL をサクッと起動 - Qiita](http://qiita.com/astrsk_hori/items/1e683a7a2f2b7189cb6e)

```
cargo install diesel_cli
echo DATABASE_URL=postgres://username:password@localhost/hoge &gt; .env
diesel setup
diesel migration generate create_posts
```

===

# 準備
-------

``` toml
[dependencies]
chrono = &#34;0.3.0&#34;
diesel = {version = &#34;0.11.4&#34;, features = [&#34;chrono&#34;, &#34;postgres&#34;, &#34;serde_json&#34;]}
dotenv = &#34;0.8.0&#34;
serde_json = &#34;0.9.6&#34;
serde_derive = &#34;0.9.7&#34;
serde = &#34;0.9.7&#34;

[dependencies.diesel_codegen]
features = [&#34;postgres&#34;]
version = &#34;0.11.0&#34;
```

===
# プロジェクト構成
-----------------

* モデルのコンパイルが遅いので分離したい
* Cargoの[ワークスペース](http://doc.crates.io/manifest.html#the-workspace-section)機能を使う

===
# プロジェクト構成
-----------------

```
$ ls
Cargo.lock
Cargo.toml
hoge_model &lt;- diesel_derive使う
hoge_XXX   &lt;- diesel使う
hoge_YYY   &lt;- diesel使う
docker-compose.yml
migrations
...
```
===

# テーブル
---------

* up.sqlとdown.sqlを書く

``` sql
CREATE TABLE hoge_suites (
  id SERIAL PRIMARY KEY,
  hoge_entry_id INT NOT NULL,
  hostname VARCHAR NOT NULL,
  status INT NOT NULL DEFAULT 0,
  CONSTRAINT unique_hoge_entry_id_hostname
             UNIQUE (
                      hoge_entry_id,
                      hostname
                      -- and other matrix
                     ),
  CONSTRAINT fkey_hoge_entry_id
             FOREIGN KEY(hoge_entry_id)
             REFERENCES hoge_entries(id) MATCH SIMPLE
             ON UPDATE NO ACTION
             ON DELETE CASCADE
);

```

===
# モデル
--------

``` rust
// なんかいっぱいderive
// QueryableとInsertableは分ける
#[derive(Default, Queryable, Associations, Identifiable, Debug, Clone)]
// belongs_to関係のstruct
#[belongs_to(HogeEntry)]
// has_many関係のテーブル
#[has_many(hoge_results)]
#[table_name=&#34;hoge_suites&#34;]
pub struct HogeSuite {
    pub id: i32,
    pub bench_entry_id: i32,
    // String
    pub hostname: String,
    pub status: HogeStatus,
}

```

===

# モデル
--------

```
// Insertableの方
#[derive(Default, Insertable, Debug, Clone)]
#[table_name=&#34;hoge_suites&#34;]
pub struct NewHogeSuite&lt;&#39;a&gt; {
    pub hoge_entry_id: i32,
    // Stringではなく&amp;str
    pub hostname: &amp;&#39;a str,
}
```

===

# enumの扱い
-----------

* dieselはenumのcodegenをサポートしてない
* 気合

===

# enumの扱い
-----------

```rust
// Queryableとかはderive出来ない
#[derive(Debug, Clone)]
pub enum HogeStatus {
    Waiting,
    Running,
    Finished,
    Failed,
    Canceled,
}

// 手で実装
impl&lt;BE, QB, BC&gt; FromSql&lt;Integer, BE&gt; for HogeStatus
    where QB: QueryBuilder&lt;BE&gt;,
          BC: BindCollector&lt;BE&gt;,
          BE: Backend&lt;RawValue = [u8], QueryBuilder = QB, BindCollector = BC&gt;
{
    fn from_sql(bytes: Option&lt;&amp;&lt;Pg as Backend&gt;::RawValue&gt;)
                -&gt; Result&lt;Self, Box&lt;Error + Send + Sync&gt;&gt; {
        use self::HogeStatus::*;
        match &lt;i32 as FromSql&lt;Integer, Pg&gt;&gt;::from_sql(bytes)? {
            0 =&gt; Ok(Waiting),
            1 =&gt; Ok(Running),
            2 =&gt; Ok(Finished),
            3 =&gt; Ok(Failed),
            4 =&gt; Ok(Canceled),
            n =&gt; Err(format!(&#34;invalid status: {}&#34;, n).into()),
        }
    }
}

impl&lt;BE, QB, BC&gt; FromSqlRow&lt;Integer, BE&gt; for HogeStatus
    where QB: QueryBuilder&lt;BE&gt;,
          BC: BindCollector&lt;BE&gt;,
          BE: Backend&lt;RawValue = [u8], QueryBuilder = QB, BindCollector = BC&gt;
{
    fn build_from_row&lt;T: Row&lt;BE&gt;&gt;(row: &amp;mut T) -&gt; Result&lt;Self, Box&lt;Error + Send + Sync&gt;&gt; {
        use self::HogeStatus::*;
        match &lt;i32 as FromSqlRow&lt;Integer, BE&gt;&gt;::build_from_row(row)? {
            0 =&gt; Ok(Waiting),
            1 =&gt; Ok(Running),
            2 =&gt; Ok(Finished),
            3 =&gt; Ok(Failed),
            4 =&gt; Ok(Canceled),
            n =&gt; Err(format!(&#34;invalid status: {}&#34;, n).into()),
        }
    }
}
```

===
# クエリ
--------

* モデルプロジェクトとは別
* 各プロジェクトのdb.rsで関数を定義
* SQLよりRsutのイテレータを意識した書き方

===
# クエリ
--------

```rust
pub fn is_hoge_finished&lt;&#39;a, Cn&gt;(conn: &amp;Cn, entry_id: i32) -&gt; Result&lt;bool, Error&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use self::schema::hoge_suites::dsl::*;
    // SELECT ... じゃなくてsourceからfileterして最後にselect
    let ret = hoge_suites
        .filter(hoge_entry_id.eq(entry_id))
        .select(status)
        // ここまでクエリビルダ
        .load::&lt;i32&gt;(conn)?
        // ここからイテレータ
        .into_iter()
        .all(|i| [HogeStatus::Finished as i32, HogeStatus::Failed as i32].contains(&amp;i));
    Ok(ret)
}

```

===
# 複雑なクエリ
-------------

* トランザクション
* join
* order by

===

# 複雑なクエリ
-------------

``` rust
pub fn pic_suite&lt;Cn&gt;(conn: &amp;Cn,
                     query: &amp;api::worker_poll::Request)
                     -&gt; Result&lt;Option&lt;(HogeEntry, HogeSuite)&gt;, Error&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use self::schema::hoge_entries::dsl::*;
    use self::schema::hoge_suites::dsl::*;
    use self::schema::hoge_suites::dsl::id;
    // transaction
    conn.transaction(|| {
        let suite = hoge_suites
             // join
            .inner_join(hoge_entries)
            .filter(status.eq(HogeStatus::Waiting as i32)
                .and(hostname.eq(&amp;query.hostname)))
            // order by
            .order(created_at.asc())
            .select((id, hoge_entry_id, hostname, status))
            .first::&lt;HogeSuite&gt;(conn)
            // NotFoundErrorをOptionにできる
            .optional()?;
        // transactionの中で普通にrustの式が書ける
        if let Some(s) = suite {
            let entry = hoge_entries.find(s.hoge_entry_id)
                .first::&lt;HogeEntry&gt;(conn)?;
            let suite =
                diesel::update(hoge_suites.find(s.id)).set(status.eq(HogeStatus::Running as i32))
                    .get_result::&lt;HogeSuite&gt;(conn)?;
            Ok(Some((entry, suite)))

        } else {
            Ok(None)
        }
    })
}
```

===

# もっと複雑なクエリ
-------------------

* 2重join
* dieselは2重joinを扱えない…

===

# もっと複雑なクエリ
-------------------


``` rust
pub fn load_all_data&lt;&#39;a, Cn&gt;(conn: &amp;Cn)
                             -&gt; Result&lt;Vec&lt;(HogeEntry, Vec&lt;((HogeSuite, HogeResult), Vec&lt;HogeProfile&gt;)&gt;)&gt;&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use diesel::types::{Integer, Timestamp, VarChar, Double};
    use diesel::pg::types::sql_types::{Array, Jsonb};
    use diesel::expression::dsl::*;
    use diesel::select;

    let status = sql::&lt;Integer&gt;(&#34;s.status&#34;);
    let ret = select(sql::&lt;(
        (Integer, VarChar, VarChar, Array&lt;VarChar&gt;,Timestamp, VarChar, Integer, Jsonb),
        (Integer, Integer, VarChar, Integer),
        (Integer, Integer, VarChar, Integer, Integer, VarChar),
        (Integer, Integer, VarChar, Integer, Double))&gt;(
        &#34;
e.id, e.repo, e.committish, e.files, e.created_at, e.command, e.format, e.format_data,
s.id, s.hoge_entry_id, s.hostname, s.status,
r.id, r.hoge_suite_id, r.hoge_name, r.score, r.status, r.result,
p.id, p.hoge_result_id, p.function_name, p.score, p.percent
FROM hoge_profiles p
INNER JOIN hoge_results r on r.id = p.hoge_result_id
INNER JOIN hoge_suites s ON s.id = r.hoge_suite_id
INNER JOIN hoge_entries e ON e.id = s.hoge_entry_id&#34;))
    .filter(status.eq(HogeStatus::Finished as i32))
    .load::&lt;(HogeEntry, HogeSuite, HogeResult, HogeProfile)&gt;(conn)?;
    let mut hash = HashMap::new();
    for (e, s, r, p) in ret {
        let mut hash_entry1 = hash         .entry(e.id).or_insert((e, HashMap::new()));
        let mut hash_entry2 = hash_entry1.1.entry(r.id).or_insert(((s, r), Vec::new()));
        hash_entry2.1.push(p);
    }
    let ret = hash.into_iter().map(|(_, v)| (v.0,  v.1.into_iter().map(|(_, p)| p).collect())).collect();
    Ok(ret)
}

```

===

# テスト
-------

* ￣\＿(ツ)＿/￣

===

# まとめ
--------

* 案外普通に使えるよ
* モデルはちょっと面倒かもね
* クエリは困ったらSQL生牡蠣
* マイグレーションとかはまた今度

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>WebAssemblyとコンパイラとランタイム</title>
      <link>/slide/WebAssemblytokonpairatorantaimu/</link>
      <pubDate>Thu, 16 Feb 2017 15:46:21 +0900</pubDate>
      
      <guid>/slide/WebAssemblytokonpairatorantaimu/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# WebAssemblyとコンパイラとランタイム
----------------------
[emscripten night !! #3 - connpass](https://emsn.connpass.com/event/48100/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# 何の話
---------

* WebAssemblyをバックエンドに使う言語を作りたい
* [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml)
* 既に発表したものの補足記事的な
  + [コンパイラの人からみたWebAssembly | κeenのHappy Hacκing Blog](https://keens.github.io/slide/konpairanoninkaramitaWebAssembly/)
  + ある程度再度説明します

===
# アジェンダ
------------

* なぜWebAssembly
* コンパイラ
* コード生成
* ランタイム

===

# なぜWebAssembly

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# なぜWebAssembly
----------------

* なんかバイナリでテンション上がる
* ポータブルでコンパクトで速い
* 機能的にJSを越えるかもしれない…？
* コンパイラがブラウザで動くと言語導入のハードル下がる
  + 気軽に試せる
  + コンパイラだけでなく吐いたコードもブラウザで動かしたい

===
# WASM over LLVM
----------------

* 既存のJS環境と協調する
  + JSとの相互呼び出しとか
* **non-determinismが少ない**
* 細かいアラインメント考える必要がない
* **API安定しそう**

===

# WASM over asm.js
--------------------

* ブラウザ以外への組込みもサポート
  + Node.jsとか
  + **JITエンジンに使えそう**
* プラットフォーム
* 実行までのレイテンシが短かい
* asm.jsより速度を出しやすい設計
* テキストフォーマットで生成コードの文法エラーが怖い
* 将来機能が増えるかも

===
# WebAssemblyの現状
-------------------

* Minimum Viable Product(MVP)
* 機能を削ってとりあえず動くものを作ってる
* 今はC/C++からLLVMを通して吐けるのが目標
  + C/C++には不要でも自分の言語に欲しい機能は……
* 今後SIMDとかスレッドとかDOM APIとか増えていく

===

# コンパイラ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# WASM概要
----------

* WASMには以下がある
  + 関数
    - 関数内ローカル変数
  + リニアメモリ
  + グローバル変数
  + テーブル
  + importテーブル
  + exportテーブル

===
# WASM実行モデル
--------------

* i32,i64,f32,f64のみ
* **スタックマシン**
  + 命令のオペランドや関数の引数はスタック経由で渡す
  + 1 passのコード生成が楽そう
* 無限のローカル変数が使える
  + 型がある
* 関数の引数はローカル変数経由で渡される
* コントロールフローはgotoじゃなくてstructured
  + 静的検証がしやすいらしい
  + 安全だけどコンパイラ的には…

===

# コントロールフロー
-------------------

* `loop` + `br` (名前付き)
* `block` + `br` (名前付き)
* `br_if` or `br_table`
* `if` + `else` + `end`
* `return`
* 等

===

# コントロールフロー
-------------------

* gotoがない
  + `br` はブランチじゃなくてブレイク
* gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
    + loop, block, br, br_ifを使う
* 高級言語から変換するなら `if` を使う
  + ifが2系統あることになる

===
# サンプル
---------

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===
# サンプル
---------

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (get_local 0)
    (get_local 1)
    (call 1)
    (get_local 1)
    (get_local 0)
    (i64.sub)
    (f64.convert_s/i64)
    (f64.div)
    (call 2))
  ...)
```

===
# サンプル
---------

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (call 2
      (f64.div
       (call 1 (get_local 0) (get_local 1))
       (f64.convert_s/i64
        (i64.sub
         (get_local 1)
         (get_local 0))))))
  ...)
```

===

# WebMLコンパイラ
------------

* パーサ、AST、HIR、MIR、LIR
* LIRがRTLなのでそれをWASMに変換したい
* gotoからstructured control flow…

===

```
[コード]
   | パーサ
 [AST] 型推論とか
   | AST2HIR
 [HIR] 早期最適化、K正規化、A正規化など
   | HIR2MIR
 [MIR] 諸々の最適化
   | MIL2LIR
 [LIR] シリアライズ、レジスタ割り当てなど
   | コード生成
 [WASM]
```

===

# 変数
------

* LIRはレジスタで計算する
* LIRはCFG由来の大量の変数を使う
  + レジスタ割り当ては一旦置いとく
* WASMはスタックで計算する
* どうコード生成すると最適か？

===

```
fun main: () -&gt; i64 = {
    entry@0:
        r0: i64 &lt;- 1
        r1: i32 &lt;- 0
        r2: i64 &lt;- 1
        r3: i64 &lt;- 2
        r4: i64 &lt;- 3
        r5: i64 &lt;- r3 * r4
        r6: i64 &lt;- 4
        r7: i64 &lt;- r5 + r6
        r8: i64 &lt;- r2 + r7
        r9: i64 &lt;- 1
        r10: i64 &lt;- 2
        r11: i64 &lt;- r9 + r10
        r12: i64 &lt;- 3
        r13: i64 &lt;- r11 * r12
        r14: i64 &lt;- 4
        r15: i64 &lt;- r13 + r14
        r16: i32 &lt;- 1
        jump_if_zero r16 then@1
        jump else@2
    then@1:
        r17: i64 &lt;- r8
        jump join@3
    else@2:
        r17: i64 &lt;- r15
        jump join@3
    join@3:
        r18: i64 &lt;- 1
        r19: i64 &lt;- r18 + r15
        r20: i64 &lt;- 1
        r21: i64 &lt;- call d@9(r20, )
        r22: i64 &lt;- 2
        r23: i64 &lt;- call #g37(r22, )
        r24: i64 &lt;- 1
        r25: i64 &lt;- heapalloc(16)
        [r25+0] &lt;- &lt;anonfun&gt;@11
        [r25+8] &lt;- r24
        r26: i64 &lt;- 0
        ret r26
}
```

===

# 変数割り当て
--------------

* SSAの1変数 = WASMの1ローカル変数
* スタックの効率利用を完全に無視
* 計算はLV→スタック→LVに書き戻し
* どうせスタックもLVもレジスタ扱いにしてレジスタ割り当てされるでしょ
* （測ってないけど）多分速度は変わらない

===

# CFG
-----

* コンパイラが一旦gotoを使うコントロールフローグラフを作る
* WASMにはgotoがない
* どうやったら生成出来るか？
* そもそも生成出来るの？

===

# blockと前方ジャンプ
------------

* `block` + `break` で前方ジャンプ
* 閉じ括弧の位置にジャンプ
* `block` の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  ...
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

# loopと前方ジャンプ
------------


* `loop` + `break`で後方ジャンプ
  + `loop` からの `break` はいわゆる `continue`
* 開き括弧の位置にジャンプ
* 閉じ括弧の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  ...
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===
# ジャンプのクロス
------------------

* 単一gotoは割り当て出来る
* 複数のgotoが入り組んだら？

===

# 絶対出来る
------------

* チューリング完全なら必ず書ける
  + whileとswitchでステートマシン作ればいい
* 効率的とは限らない
* 効率的なコードを吐きたい

===
# ステートマシンはつらい
-----------------------

* これをナイーブに変換すると…

```c
#include &lt;stdio.h&gt;
int main() {
  int sum = 0;
  for (int i = 1; i &lt;= 100; i++)
    sum += i;
  printf(&#34;1+...+100=%d\n&#34;, sum);
  return 0;
}
```

===

```javascript
function _main() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    var __label__ = -1;
    while(1)
        switch(__label__) {
        case -1:
            ...
            __label__ = 0;
            break;
        case 0:
            ...
            if ($4) {
              __label__ = 1;
              break;
            } else {
              __label__ = 2;
              break;
            }
        case 1:
            ...
            __label__ = 3;
            break;
        case 3:
            ...
            __label__ = 0;
            break;
        case 2:
            ...
            return 0;
        }
}
```

===
# ステートマシンはつらい
----------------------

* どうにかする必要がある
  + emscriptenは[ReLoop](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)で最適化
* なんか気に食わなかった
* そもそもステートマシンを使わずに生成したい
* 複数のgotoが入り組んだパターンを自分で考えたの紹介します。
* CFGと基本ブロックは知ってるかな？

===
# 前前
------

```
[ ]--+
 |   |
[ ]--+-+
 |   | |
[ ]&lt;-+ |
 |     |
[ ]&lt;---+
```

===
# 前前
------

```
(block
  (block
    ...
    (br 0)-+
    ...    |
    (br 1)-+-+
  )&lt;-------+ |
)&lt;-----------+
```

===
# 後後
------


```
[ ]&lt;-+
 |   |
[ ]&lt;-+-+
 |   | |
[ ]--+ |
 |     |
[ ]----+
```

===
# 後後
------

```
(loop&lt;-----+
  (loop&lt;---+-+
    ...    | |
    (br 1)-+ |
    ...      |
    (br 0)---+
  )
)
```

===
# 後前
------


```
[ ]&lt;-+
 |   |
[ ]--+-+
 |   | |
[ ]--+ |
 |     |
[ ]&lt;---+
```

===
# 後前
------

```
(block
  (loop&lt;---+
    ...    |
    (br 1)-+-+
    ...    | |
    (br 0)-+ |
  )          |
)&lt;-----------+
```

===
# 前後
------

```
[ ]--+
 |   |
[ ]&lt;-+-+
 |   | |
[ ]&lt;-+ |
 |     |
[ ]----+
```

===
# 前後
------

* 素直には出来ない…？
* 部分的にステートマーシン作る？

===
# 部分的ステートマーシン
-------------------------

```
[1]--+
 |   |
[2]&lt;-+-+
 |   | |
[3]&lt;-+ |
 |     |
[4]----+
```

===
# 部分的ステートマーシン
-------------------------

```
   [1] label = 0
    |
+-&gt;[br]-+ if label == 0
|   |   | then goto 3
|   |   | else goto 2
|   |   |
|  [2]  |
|   |   |
|  [3]&lt;-+ label = 1
|   |
+--[4]
```

===
# コード生成

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===

# フォーマット
------------

* バイナリフォーマットとテキストフォーマットがある
* バイナリ: wasm
  + コンパクト
  + intとかもパッキングする
* テキスト: wast
  + 人間可読+機械可読=S式
  + 低級にもちょっと高級にも書ける
  + 一旦アセンブラ噛まさないと動かない

===

# アセンブラ
------------

* オンメモリで生成するためにアセンブラ自作
  + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs)
  + ブラウザで動かすのに必要
  + 既存のツールは使えない
* アセンブラ自体ブラウザで動かすのでRust製
* まだ動かしてない

===

```rust
let mut mb = ModuleBuilder::new();
let f = mb.new_function(FunctionBuilder::new(funtype!((i32, i32) -&gt; i32))
    .code(|cb, args| {
        cb.constant(2)
            .get_local(args[0])
            .i32_add()
    })
    .build());
mb.export(&#34;addTwo&#34;, f);
let module = mb.build();
```

===
# スタック領域
-------------

* Cでいう`struct foo x;`みたいにエフェメラルな多ワード領域が欲しい
* WebAssemblyのローカルストレージはLVだけ
  + 最大1ワードしか保存出来ない
* 可能性
  1. 諦めてメモリに確保（場合によっては最適化で消えるかも）
  2. ワード毎に分割してLVに保存（大変だけど速そう）

===
# ランタイム

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 言語のランタイム
-----------------

* 主にはGC
* その他データのメモリ表現
  + アラインメントも
* スタック領域
* FFI
* コンパイラなのでシンボルテーブルはなし

===
# メモリ
--------

* mallocとかはない
* ページ単位のアロケーションだけ
* 自前でGCを実装することになる

===
# GC
-----

* コールスタックを遡れない
  + コールスタックをGCルートに出来ない
* メモリonlyな走査なら可能
  + ポインタを都度メモリ領域(arena)にコピーすれば良い。
  + arenaもルートになる
  + コールスタックと連動するのでスタックで管理出来る。
  + CF [Matzにっき(2013-07-31)](http://www.rubyist.net/~matz/20130731.html)
  + ただしコンパイラなので関数全部をsave/restoreで囲んだりはしない。

===
# アロケータ
------------

* どうにか書いてブラウザでリンクする必要がある
  + ブラウザにもランタイムライブラリの時代…
  + WASMはライブラリ間でメモリ共有出来る
* とりあえずRustで書く方針
  + WASMのページアロケートとかどうすればいいんだろう
  + まだ色々未定

===

# メモリ表現
------------

* 出来れば楽して64bit統一したかった
  + i32やf32を抹殺したかった
* WASM32しかないのでポインタが32bit…
* 仕方ないので64bitアラインメントでパディングする
* 空いた32bitの使い道は未定
  + 静的型付だし型タグが要らない
  + 代数的データ型のタグ？

===

# 高階関数
----------

* WASMに関数ポインタがない
* テーブルに関数を登録してインデックス参照
  + C++のvtableのための機能
  + 型も動的チェック
* ちょっと遅そう
* 気合でインライン化を頑張ろう

===

# FFI
------

* JSの関数を呼びたい
* 細かいところどうなってるんだろう
  + 例外は？JSオブジェクトは？GCは？
* 型付…
* ノープラン

===
# 雑にまとめ
-------------

* WASMはちょっと高級なので最適化コンパイラは困るよ
  + 雑なコンパイラにはむしろ嬉しい
* コード生成は努力で解決
* GCは割とつらいよ
  + 将来楽になるかも
* JS連携や将来のスレッドとかはみんなで考えよう

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>RustのちょっとやりすぎなBuilderパターン</title>
      <link>/blog/2017/02/09/rustnochottoyarisuginabuilderpata_n</link>
      <pubDate>Thu, 09 Feb 2017 23:03:45 +0900</pubDate>
      
      <guid>/blog/2017/02/09/rustnochottoyarisuginabuilderpata_n</guid>
      <description>&lt;p&gt;κeenです。Rustでちょっとやりすぎだけど使う側の自由度が高くて安全なBuilderパターンを思い付いたので紹介しますね。&lt;/p&gt;

&lt;p&gt;※2017-02-11T13:18:58Z+09:00 最下部に追記しました
&lt;/p&gt;

&lt;h1 id=&#34;目的コード&#34;&gt;目的コード&lt;/h1&gt;

&lt;p&gt;以下のような構造体のビルダーを作りたいとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-struct&#34;&gt;#[derive(Debug)]
struct Person {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;雑にやると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilder {
    id: Option&amp;lt;u32&amp;gt;,
    name: Option&amp;lt;String&amp;gt;,
    age: Option&amp;lt;u32&amp;gt;,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilder {
  pub fn new() -&amp;gt; Self { ... }
  pub fn id(self, id: u32) -&amp;gt; Self { ... }
  pub fn name(self, name: String) -&amp;gt; Self { ... }
  pub fn age(self, id: u32) -&amp;gt; Self { ... }
  pub fn address(self, address: String) -&amp;gt; Self { ... }
  pub fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // 返り値がOption型になってしまう
  pub fn build(self) -&amp;gt; Option&amp;lt;Person&amp;gt; {
    // try_opt!は標準ライブラリには存在しませんが各所で使われてるので動きは分かると思います
    Person {
       id: try_opt!(self.id),
       name: try_opt!(self.name),
       age: try_opt!(self.age),
       address: self.address,
       zipcode: self.zipcode,
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とbuildの返り値が&lt;code&gt;Option&lt;/code&gt;型になってしまい、あまりうれしくありません。
さらには例えば&lt;code&gt;id&lt;/code&gt;を2回呼んだらどうなるんだとかツッコミどころが数多くあります。&lt;/p&gt;

&lt;p&gt;ということで色々な回避策を先人達は考えてきました。&lt;/p&gt;

&lt;h1 id=&#34;不自由なコード&#34;&gt;不自由なコード&lt;/h1&gt;

&lt;p&gt;普通にやるなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilder {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilder {
  fn new(id: u32, name: String, age: String) -&amp;gt; Self { ... }
  fn address(self, address: String) -&amp;gt; Self { ... }
  fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // 返り値がOptionじゃない
  fn build(self) -&amp;gt; Person { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;Option&lt;/code&gt;でないフィールドをコンストラクタで受け取れば安全に作れますが、コンストラクタを呼ぶ時点でいくつかフィールドが揃っている必要がある、そもそも元の構造体と何が違うんだ、など色々問題があります。&lt;/p&gt;

&lt;h1 id=&#34;少しマシなコード&#34;&gt;少しマシなコード&lt;/h1&gt;

&lt;p&gt;オートマトンのようにビルダーが状態遷移するコードを使うと、1つ1つの引数をビルドしつつ安全なコードが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilderId;
struct PersonBuilderName{id: u32}
struct PersonBuilderAge{id: u32, name: String}
struct PersonBuilder {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilderId {
  pub fn new() -&amp;gt; Self { ... }
  // idの次はname
  pub fn id(self, id: u32) -&amp;gt; PersonBuilderName {
    PersonBuilderName { id: id }
  }
}

impl PersonBuilderName {
  // nameの次はage
  pub name(self, name: String) -&amp;gt; PersonBuilderAge {
    PersonBuilderAge {
      id: self.id,
      name: name,
    }
  }
}
impl PersonBuilderAge {
  // ageは最後
  pub name(self, age: u32) -&amp;gt; PersonBuilder {
    PersonBuilder {
      id: self.id,
      name: self.name,
      age: age,
      address: None,
      zipcode: None,
    }
  }
}

impl PersonBuilder {
  // 気持ち悪いけど PersonBuilderIdを返す
  pub fn new -&amp;gt; PersonBuilderId { ... }
  pub fn address(self, address: String) -&amp;gt; Self { ... }
  pub fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // これまたOptionじゃなくなってる
  pub fn build(self) -&amp;gt; Person { ... }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは以下のように&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
  let person = PersonBuilder::new()
         .id(1)
         .name(&amp;quot;κeen&amp;quot;.to_string())
         .age(24)
         .address(&amp;quot;Tokyo&amp;quot;.to_string())
         .build();
  println!(&amp;quot;{:?}&amp;quot;, person)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と使えます(即興で書いたので試してないけど)。&lt;/p&gt;

&lt;p&gt;とりあえず使えそうな気がしますが、型レベルで状態遷移をハードコードしているのでメソッドを呼び出す順番が固定されてしまいます。
なので以下はエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
  let person = PersonBuilder::new()
         // nameとidを逆順に呼び出してみる
         .name(&amp;quot;κeen&amp;quot;.to_string())
         .id(1)
         .age(24)
         .address(&amp;quot;Tokyo&amp;quot;.to_string())
         .build();
  println!(&amp;quot;{:?}&amp;quot;, person)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは単純に&lt;code&gt;struct PersonBuilderId&lt;/code&gt;、&lt;code&gt;struct PersonBuilderName{id: u32}&lt;/code&gt;、&lt;code&gt;struct PersonBuilderAge{id: u32, name: String}&lt;/code&gt;と作っていくのが面倒という話もあります。&lt;/p&gt;

&lt;p&gt;今回はそれを改善したいという話&lt;/p&gt;

&lt;h1 id=&#34;幽霊型を使ったフィールド状態&#34;&gt;幽霊型を使ったフィールド状態&lt;/h1&gt;

&lt;p&gt;今回提案するビルダー型はこれです。提案するといってもどうせ既に誰かが考えてるでしょうが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::marker::PhantomData;
struct Empty;
struct Filled;

struct PersonBuilder&amp;lt;Id, Name, Age&amp;gt; {
    id: Option&amp;lt;u32&amp;gt;,
    id_state: PhantomData&amp;lt;Id&amp;gt;,
    name: Option&amp;lt;String&amp;gt;,
    name_state: PhantomData&amp;lt;Name&amp;gt;,
    age: Option&amp;lt;u32&amp;gt;,
    age_state: PhantomData&amp;lt;Age&amp;gt;,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/marker/struct.PhantomData.html&#34;&gt;PhantomData&lt;/a&gt;という特殊な型を使ってビルダーに余計な型を付けています。&lt;/p&gt;

&lt;p&gt;この型、最初は&lt;code&gt;Empty&lt;/code&gt;から出発します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl PersonBuilder&amp;lt;Empty, Empty, Empty&amp;gt; {
    pub fn new() -&amp;gt; Self {
        PersonBuilder {
            id: None,
            id_state: PhantomData,
            name: None,
            name_state: PhantomData,
            age: None,
            age_state: PhantomData,
            address: None,
            zipcode: None,
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてフィールドが埋められると対応する型がEmptyからFilledになります。&lt;/p&gt;

&lt;p&gt;フィールドに&lt;code&gt;Some&lt;/code&gt;が埋められるのと同時に対応する&lt;code&gt;_state&lt;/code&gt;フィールドを&lt;code&gt;Empty&lt;/code&gt;から&lt;code&gt;Filled&lt;/code&gt;にすると整合性が崩れません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Id以外、つまりNameとAgeはいじらないのでジェネリクスに
impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        PersonBuilder {
            id: Some(id),
            id_state: PhantomData,
            name: self.name,
            name_state: self.name_state,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
impl&amp;lt;Id, Age&amp;gt; PersonBuilder&amp;lt;Id, Empty, Age&amp;gt; {
    // 地味なテクニックとして、SringではなくてInto&amp;lt;String&amp;gt;で受けることでリテラルのStringとかも受け取れる。
    pub fn name&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(self, name: S) -&amp;gt; PersonBuilder&amp;lt;Id, Filled, Age&amp;gt; {
        PersonBuilder {
            id: self.id,
            id_state: self.id_state,
            name: Some(name.into()),
            name_state: PhantomData,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}

impl&amp;lt;Id, Name&amp;gt; PersonBuilder&amp;lt;Id, Name, Empty&amp;gt; {
    pub fn age(self, age: u32) -&amp;gt; PersonBuilder&amp;lt;Id, Name, Filled&amp;gt; {
        PersonBuilder {
            id: self.id,
            id_state: self.id_state,
            name: self.name,
            name_state: self.name_state,
            age: Some(age),
            age_state: PhantomData,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt;のままで構わないフィールドについては雑で構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;Id, Name, Age&amp;gt; PersonBuilder&amp;lt;Id, Name, Age&amp;gt; {
    pub fn address&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(mut self, address: S) -&amp;gt; Self {
        self.address = Some(address.into());
        self
    }

    pub fn zipcode&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(mut self, zipcode: S) -&amp;gt; Self {
        self.zipcode = Some(zipcode.into());
        self
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして必須フィールド全てが満たされた時にだけ&lt;code&gt;build&lt;/code&gt;が呼べます。&lt;code&gt;unwrap&lt;/code&gt;を呼んでますが安全であることに注意して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl PersonBuilder&amp;lt;Filled, Filled, Filled&amp;gt; {
    pub fn build(self) -&amp;gt; Person {
        Person {
            id: self.id.unwrap(),
            name: self.name.unwrap(),
            age: self.age.unwrap(),
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、呼び出しが非常に自由になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let person = PersonBuilder::new()
        .age(24)
        .id(1)
        .address(&amp;quot;Tokyo&amp;quot;)
        .name(&amp;quot;κeen&amp;quot;)
        .build();
    println!(&amp;quot;{:?}&amp;quot;, person);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メソッドは自由に組み換えられますが、必須フィールドがなかったら&lt;code&gt;build&lt;/code&gt;が呼べません（コンパイルエラー）になります。&lt;/p&gt;

&lt;p&gt;これは応用も出来て、それぞれの状態が独立しているので例えば「2つのVector合計3つ以上要素が入っていたら」、とか「R、G、BあるいはH、S、Vの3つが揃っていたら」とかオートマトンではエンコードしづらいものでも比較的楽に書けます。&lt;/p&gt;

&lt;p&gt;ということで便利なbuilderが出来ました。めでたしめでたし。といいたいところですが、ちょっとコードが冗長ですよね。マクロで生成なんかも出来るのですがあまりやりたくありません。ということで「ちょっとやりすぎな」Builderパターンでした。&lt;/p&gt;

&lt;h1 id=&#34;some-like-it-unsafe&#34;&gt;Some like it unsafe&lt;/h1&gt;

&lt;p&gt;上のコード、実はもうちょっと短く書けます。ただし&lt;code&gt;unsafe&lt;/code&gt;な機能を使いますが。&lt;/p&gt;

&lt;p&gt;こう書いていたものが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        PersonBuilder {
            id: Some(id),
            id_state: PhantomData,
            name: self.name,
            name_state: self.name_state,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/mem/fn.transmute.html&#34;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;を使うことで2行になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::transmute;

impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(mut self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        self.id = Some(id);
        unsafe { transmute(self) }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すごいですね。
しかし、案外しょっちゅうtransmuteはミスなどで間違った変換をしてしまう（上記で言えばidフィールドを更新したのにname_stateの型を変更してしまう）上に型検査で弾けないので個人的にはあまりおすすめ出来ません。
これも「ちょっとやりすぎ」なTipsでした。&lt;/p&gt;

&lt;h1 id=&#34;2017-02-11t13-18-58z-09-00-追記&#34;&gt;2017-02-11T13:18:58Z+09:00 追記&lt;/h1&gt;

&lt;p&gt;qnighyさんからもっと便利な方法の提案がありました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;こう &lt;a href=&#34;https://t.co/undNgEM2IQ&#34;&gt;https://t.co/undNgEM2IQ&lt;/a&gt; やったらunwrapしなくてすみそう？ / “RustのちょっとやりすぎなBuilderパターン | κeenのHappy Hacκing Blog” &lt;a href=&#34;https://t.co/ogDOpYifjh&#34;&gt;https://t.co/ogDOpYifjh&lt;/a&gt;&lt;/p&gt;&amp;mdash; Masaki⊣Hara (@qnighy) &lt;a href=&#34;https://twitter.com/qnighy/status/830053476096843776&#34;&gt;2017年2月10日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;実際のコードはこちら。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/qnighy/e7a833eebd57ef778eaff3a8ab3649d7.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;transmuteを使ったサボった実装は出来なくなるけどそもそも余計なフィールドを使う必要がなくなるので手軽ですね。&lt;/p&gt;

&lt;p&gt;qnighyさんありがとうございました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Deprecating CIM</title>
      <link>/blog/2017/01/29/deprecating_cim</link>
      <pubDate>Sun, 29 Jan 2017 22:18:24 +0900</pubDate>
      
      <guid>/blog/2017/01/29/deprecating_cim</guid>
      <description>&lt;p&gt;I&amp;rsquo;m κeen. I have a sad news, I&amp;rsquo;ll stop the development of &lt;a href=&#34;https://github.com/KeenS/CIM&#34;&gt;CIM&lt;/a&gt; and no more updates for new lisp impls will be provided.

It has been months from when I stopped developping CIM and only providing updates for new lisp impl versions.
From that point, CIM is a half-dead product. I know there are still someone using CIM though, so I kept updating.
For present CIM users, I recomend to migrate to &lt;a href=&#34;https://github.com/roswell/roswell&#34;&gt;roswell&lt;/a&gt;, also a lisp installer and manager, which is well-maintained.&lt;/p&gt;

&lt;p&gt;CIM has been developed in my studenthood for my practice in shell scripts. This is my first OSS.
The reason why I wrote CIM in shell script other than for practice is that shell scripts are the most portable and available script language on Unix-like systems.
The original purpose of writing a new manager is to provide a consistent way of launching CLs from CLI.
To realize that, managing lisp impls, including installing is needed so CIM has started to manage impls.
At some point, CIM was used such products like &lt;a href=&#34;https://github.com/luismbo/cl-travis&#34;&gt;cl-travis&lt;/a&gt;.
But CIM lacked flexibility of development as it is written in ugly shell script, and lacked Windows support.
As I got a job and got interests other than lisp such as Rust, I have no more time to spend for maintaining CIM.&lt;/p&gt;

&lt;p&gt;Thus &lt;a href=&#34;https://github.com/snmsts&#34;&gt;@snmsts&lt;/a&gt;, the author of roswell, started to develop roswell to support Windows.
Roswell is written mainly in Lisp though booting from C, so many of Lispers may be able to hack it.
Roswell is well-maintained because stmsts is, unlike me, a hobby Lisper, professional lisper and he uses roswell in daily work.
Besides roswell is well-maintained, roswell is more feature-rich than CIM.
It searchs for new lisp versions for itself so there is no need to update manager itself to update your local lisp impls.
It is distributed from package managers such like homebrew and AUR so you don&amp;rsquo;t need to care about updating it.
Using &lt;code&gt;dump&lt;/code&gt; feature of roswell, you can create an executable binary from a lisp script in a command.
And so on. There are many reasons to use roswell even if CIM would be kept maintained.&lt;/p&gt;

&lt;p&gt;Anyway I wish CIM users to keep using lisp via roswell. Thank you for staying with me for a long time.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>コンパイラの人からみたWebAssembly</title>
      <link>/slide/konpairanoninkaramitaWebAssembly/</link>
      <pubDate>Sun, 22 Jan 2017 13:35:46 +0900</pubDate>
      
      <guid>/slide/konpairanoninkaramitaWebAssembly/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# コンパイラの人からみたWebAssembly
----------------------
[コンパイラ勉強会 - connpass](https://connpass.com/event/46850/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# アジェンダ
------------

* WebAssemblyの概要
* 具体的な話
* WebAssembly吐こうとした話

===

# WebAssemblyの概要

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===

# JavaScript
-------------

* ブラウザ上で動くスクリプト言語
* 動的型付
* 高級
* GCとかある
* 今までブラウザで動く唯一の言語だった
* 遅い
  + 各ブラウザJITなどで補強

===

# [asm.js](http://asmjs.org/)
------------

* プラウザ上で動く言語
* 低級
* GCなし
* JSのサブセット
  + asm.jsをサポートしないプラウザでも動かせる
* コンパイラから生成されることを想定
  + emscriptenなど

===

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===
# asm.jsの問題点
---------------

* JS互換文法なため嵩張る
* パースも遅い
* そもそもコンパイラが吐くならバイナリでも良いのでは？

===

# WebAssembly
--------------

* ブラウザ上で動く言語
  + 仮想機械命令？
* 低級
* バイナリフォーマット
  + ロード、パース時間が短かい
  + パース20倍くらい速いらしい
* wasm32とwasm64がある
* セマンティクスは（今のところ）ams.jsをほぼ踏襲
  + 実行エンジンは既存のものを使える
* 将来SIMD、スレッドなどの拡張が入る

===

# WASMのゴール
--------------------

* ポータブルでコンパクトで速い
* 仕様策定と実装をインクリメンタルにやっていく
  + 今はとりあえずC/C++をターゲットに
* 既存のJS環境と協調する
  + JSとの相互呼び出しとか
* ブラウザ以外への組込みもサポート
  + Node.jsとか
* プラットフォームになる
  + ツール類のサポートとか

===

# なぜWebAssembly?
------------------

* 実行までのレイテンシが短かい
* asm.jsより速度を出しやすい設計
* クライアントヘビーにしやすい？
* **JSを補完する存在**
* non-determinismが少ない
* LLVM IRと比べてデコードが速くてコンパクト
* (**code generator IR** vs optimization IR)
* 余計なことをしない
  + fast mathとかはない
  + 既に最適化されたコードが吐かれる前提

===
# WebAssemblyの現状
-------------------

* Minimum Viable Product(MVP)
* 機能を削ってとりあえず動くものを作ってる
* 今はC/C++からLLVMを通して吐けるのが目標
* 今後SIMDとかスレッドとかDOM APIとか増えていく
* ChromeとFirefoxでオプトインで使える
  + そろそろFirefoxで普通に動く

===

# 具体的な話
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# セマンティクス
---------------

* https://github.com/WebAssembly/spec
* 形式的定義されている
* 実行以外にも静的バリデーションもある
* 1ファイル1モジュール
  + JSのモジュールと同じ概念

===
# 実行モデル
--------------

* i32,i64,f32,f64のみ
  + bitエンコーディングは指定
* スタックマシン
  + 命令のオペランドや関数の引数はスタック経由で渡す
  + バイナリがコンパクト+雑にコンパイルしても速い
* 無限のローカル変数が使える
  + 型がある
* 関数の引数はローカル変数経由で渡される
* コントロールフローはgotoじゃなくてstructured
  + 静的検証がしやすい

===

# wasm、wast
------------

* バイナリフォーマットだけでは人間が読めない
* テキストフォーマットも欲しい
* バイナリ: wasm
  + コンパクト
  + intとかもパッキングする
* テキスト: wast
  + 人間可読+機械可読=S式
  + 低級にもちょっと高級にも書ける

===

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (get_local 0)
    (get_local 1)
    (call 1)
    (get_local 1)
    (get_local 0)
    (i64.sub)
    (f64.convert_s/i64)
    (f64.div)
    (call 2))
  ...)
```

===

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (call 2
      (f64.div
       (call 1 (get_local 0) (get_local 1))
       (f64.convert_s/i64
        (i64.sub
         (get_local 1)
         (get_local 0))))))
  ...)
```

===

```
0000000: 0061 736d                                 ; WASM_BINARY_MAGIC
0000004: 0d00 0000                                 ; WASM_BINARY_VERSION
; section &#34;TYPE&#34; (1)
0000008: 01                                        ; section code
0000009: 00                                        ; section size (guess)
000000a: 03                                        ; num types
; type 0
000000b: 60                                        ; func
000000c: 02                                        ; num params
000000d: 7e                                        ; i64
000000e: 7e                                        ; i64
000000f: 01                                        ; num results
0000010: 7c                                        ; f64
; type 1
0000011: 60                                        ; func
0000012: 02                                        ; num params
0000013: 7e                                        ; i64
0000014: 7e                                        ; i64
0000015: 01                                        ; num results
0000016: 7c                                        ; f64
; type 2
0000017: 60                                        ; func
0000018: 01                                        ; num params
0000019: 7c                                        ; f64
000001a: 01                                        ; num results
000001b: 7c                                        ; f64
0000009: 12                                        ; FIXUP section size
; section &#34;FUNCTION&#34; (3)
000001c: 03                                        ; section code
000001d: 00                                        ; section size (guess)
000001e: 03                                        ; num functions
000001f: 00                                        ; function 0 signature index
0000020: 01                                        ; function 1 signature index
0000021: 02                                        ; function 2 signature index
000001d: 04                                        ; FIXUP section size
; section &#34;CODE&#34; (10)
000002e: 0a                                        ; section code
000002f: 00                                        ; section size (guess)
0000030: 03                                        ; num functions
; function body 0
0000031: 00                                        ; func body size (guess)
0000032: 00                                        ; local decl count
0000033: 20                                        ; get_local
0000034: 00                                        ; local index
0000035: 20                                        ; get_local
0000036: 01                                        ; local index
0000037: 10                                        ; call
0000038: 01                                        ; func index
0000039: 20                                        ; get_local
000003a: 01                                        ; local index
000003b: 20                                        ; get_local
000003c: 00                                        ; local index
000003d: 7d                                        ; i64.sub
000003e: b9                                        ; f64.convert_s/i64
000003f: a3                                        ; f64.div
0000040: 10                                        ; call
0000041: 02                                        ; func index
0000042: 0b                                        ; end
0000031: 11                                        ; FIXUP func body size
...
```

===

# JS API
---------

``` javascript
var importObj = {js: {
    import1: () =&gt; console.log(&#34;hello,&#34;),
    import2: () =&gt; console.log(&#34;world!&#34;)
}};
fetch(&#39;demo.wasm&#39;).then(response =&gt;
    response.arrayBuffer()
).then(buffer =&gt;
    WebAssembly.instantiate(buffer, importObj)
).then(({module, instance}) =&gt;
    instance.exports.f()
```

===

# メモリ
------------

* メモリアドレスが0から始まって飛びのない **リニアメモリ**
  + 命令で伸び縮み出来る
  + 将来複数のリニアメモリとか出てくるかも
* メモリサイズは32bit(wasm32)か64bit(wasm64)が選べる
  + 現状はwasm32のみ
  + 1つのモジュールでメモリ4GiBバイトも使わないから普通は32bitで十分
* アドレッシングは `アドレス+オフセット`
* アラインメントは必須ではない（した方が速い）
* コード列のメモリは見えない
* スタックスキャンも出来ない

===

# 例外とか
----------

* Trap -- WebAssemblyのインスタンスが異常終了する
  + 例えばメモリの範囲外アクセスとか
* スタックオーバーフロー
  + オーバーフローするとインスタンスが異常終了する
  + 処理系/環境毎にスタック長は違う
    - non-determinism

===

# テーブル
----------

* 要素の配列的なもの
  + 整数インデックスでアクセス出来る
* 今のところ関数を入れてindrect callするため
* 将来的にはOSのハンドラとかGCの参照とか

===

# ローカル変数
--------------

* 無限にある型付きストレージ
* 0 初期化
* 関数の引数もローカル変数に入る

===

# グローバル変数
---------------

* 型付きストレージ
* 可変/不変がある
* 不変Globにsetするとvalidationエラー
* リニアメモリとは違うメモリ領域

===
# import / export
-----------------

* 他のモジュールから色々インポート出来る
* 関数
* テーブル
* グローバル変数
* リニアメモリ
* 勿論exportも

===
# 一旦まとめ
------------

* WASMは1ファイル1モジュール
* WASMには以下がある
  + 関数
    - 関数内ローカル変数
  + リニアメモリ
  + グローバル変数
  + テーブル
  + importテーブル
  + exportテーブル

===

# 命令の話
----------

* コントロールフロー
* Call
* パラメトリック
* 変数アクセス
* メモリ関連
* 定数
* 比較
* 数値
* 変換
* 再解釈

===

# コントロールフロー
-------------------

* `loop` + `br` (名前付き)
* `block` + `br` (名前付き)
* `br_if` or `br_table`
* `if` + `else` + `end`
* `return`
* 等

===

# コントロールフロー
-------------------

* gotoがない
  + `br` はブランチじゃなくてブレイク
* gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
    + loop, block, br, br_ifを使う
* 高級言語から変換するなら `if` を使う
  + ifが2系統あることになる

===

# Call
------

* `call`
* `call_indirect`
  + 関数テーブルを使った呼び出し
  + ダイナミックな関数ディスパッチに

===

# パラメトリック
------

* `drop`
* `select`
  + 三項演算子相当


===

# 変数アクセス
--------------

* `get/set_local`
* `get/set_global`
* `tee_local`
  + スタックに値を残しつつset

===

# メモリ関連
------------

* `{i,f}{32,64}.load{,8,16,32,64}{,_s,_u}`
* `{i,f}{32,64}.store{,8,16,32}`
* `current_memory`
* `grow_memory`
  + メモリを増やす命令もある

===
# 定数
------

* `{i,f}{32,64}.const`

===
# 比較
-------

* 各種 `eq`, `eqz`, `ne`,`lt`, `le`, `gt`, `ge`

===

# 数値
-------

* 四則(`i32.add`とか)
* 論理(`i64.popcnt`とか)
* 丸め,最{大,小}(`f32.ceil`とか)
* ルート(`f64.sqrt`とか)

===

# 変換
------

* `f32.convert_s/i32`とか
* `i32.wrap/i64`とか

===

# 再解釈
--------

* `i32.reinterpret/f32`とか
* ビットキャスト
* ビットエンコーディングが定まってるのでwell-defined

===
# WASM吐こうとした話

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 作ったやつ
-------------

* なんかコンパイラ作ろうと思い立った
* [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml)
* とりあえずSMLのサブセット
* Rust製
* 未完成
  + 正月気抜いてたら進捗ダメでした

===
# やりたかったこと
------------------

* ブラウザで動くコンパイラ作ってみたい
  + Rustはemscripten通せる
* WebAssembly面白そう
* SML処理系作りたかった
* 最適化書く練習

===
# 中身
------------

* パーサ、AST, HIR, MIR, LIR
* LIRがレジスタマシンなのでそれをWASMに変換したい
* オンメモリで生成するためにアセンブラ自作
  + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs)
  + ブラウザで動かすのに必要
* 最適化はまだ

===
# コード生成
-----------

* (ほぼ)SSAの1変数 = 1ローカル変数
  + どうせエンジン側でレジスタ割り当てするでしょ
* スタックはほぼ使わない
* gotoを構造化制御フローにする
  +  一応出来る
  + [Reloop](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
  + 何言ってるのかよく分からない
  + ステートマシンは勿論可能
* →自分で考えた
* なんかつらいので詳解します
* みんな基本ブロックとCFGは分かるかな？

===
# blockと前方ジャンプ
------------

* `block` + `break` で前方ジャンプ
* 閉じ括弧の位置にジャンプ
* `block` の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  ...
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

# loopと前方ジャンプ
------------


* `loop` + `break`で後方ジャンプ
  + `loop` からの `break` はいわゆる `continue`
* 開き括弧の位置にジャンプ
* 閉じ括弧の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  ...
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===
# ジャンプのクロス
------------------

* 単一gotoは割り当て出来る
* 複数のgotoが入り組んだら？

===
# 前前
------

```
   [ ]--+
    |   |
+--[ ]  |
|   |   |
|  [ ]&lt;-+
|   |
+-&gt;[ ]
```

===
# 前前
------

```
(block
  (block
    ...
    (br 0)-+
    ...    |
    (br 1)-+-+
  )&lt;-------+ |
)&lt;-----------+
```

===
# 後後
------


```
   [ ]&lt;-+
    |   |
+-&gt;[ ]  |
|   |   |
|  [ ]--+
|   |
+--[ ]
```

===
# 後後
------

```
(loop&lt;-----+
  (loop&lt;---+-+
    ...    | |
    (br 1)-+ |
    ...      |
    (br 0)---+
  )
)
```

===
# 後前
------


```
   [ ]&lt;-+
    |   |
+--[ ]  |
|   |   |
|  [ ]--+
|   |
+-&gt;[ ]
```

===
# 後前
------

```
(block
  (loop&lt;---+
    ...    |
    (br 1)-+-+
    ...    | |
    (br 0)-+ |
  )          |
)&lt;-----------+
```

===
# 前後
------

```
   [ ]--+
    |   |
+-&gt;[ ]  |
|   |   |
|  [ ]&lt;-+
|   |
+--[ ]
```

===
# 前後
------

* 出来ない…？
* 部分的にステートマーシン作る？
* ブロック組み換えたら出来る…？
* emscriptenはステートマシンっぽい？
* どうすればいいか不明
* もはやCPS変換して全部Callにする？
  + Compiling With Continuations!!!

===
# アルゴリズム
--------------

1. loopを良い感じに割り当てる
  + 最初はジャンプ位置と一番最後のgotoで作って、境界がクロスしないようにendを伸ばす
2. blockを外側のloopめいっぱい使って割り当てる
  + loopと同じく最小に割り当てて、blockをloopまで伸ばす

===
# ランタイム
------------

* スタック走査出来ない
* GC書けないのでは？？？
* 今のところターゲットはC/C++なので問題ない
* 将来はGC Integration入るかも

===
# 現状の解
----------

1. メモリの自動管理を諦める
2. リージョン推論や線形型で静的管理する
3. スタックを使わないコードにする
  + Compiling With Continuations!!!

===
# まとめ
--------

* ブラウザでアセンブリっぽいコードが動くよ
* バイナリはコンパクトだよ
* コントロールフロー難しいよ
* ランタイム難しいよ
* Compiling With Continuations

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Sun, 22 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>

&lt;h2 id=&#34;me&#34;&gt;Me&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2011-04 - 2013-03 東京大学理科I類&lt;/li&gt;
&lt;li&gt;2013-04 - 2015-03 東京大学理学部数学科(中退)&lt;/li&gt;
&lt;li&gt;2015-04 - 2016-12 サイバーエージェント(エンジニア)&lt;/li&gt;
&lt;li&gt;2017-01 - 現在    Idein Inc. (エンジニア)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;activities&#34;&gt;Activities&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014-06 - 2017-01 &lt;a href=&#34;http://shibuya.lisp-users.org/&#34;&gt;Shibuya.lisp&lt;/a&gt;の運営&lt;/li&gt;
&lt;li&gt;2016-02 - 現在    &lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/&#34;&gt;Rustドキュメント翻訳プロジェクト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2013 &lt;a href=&#34;http://isucon.net&#34;&gt;ISUCON3&lt;/a&gt; 学生賞&lt;/li&gt;
&lt;li&gt;2014 &lt;a href=&#34;http://isucon.net&#34;&gt;ISUCON4&lt;/a&gt; 学生賞&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その他いくつかのOSSの開発者/コミッタ/コントリビュータ&lt;/p&gt;

&lt;h2 id=&#34;sns-accounts&#34;&gt;SNS accounts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Twitter: &lt;a href=&#34;http://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub: &lt;a href=&#34;https://github.com/KeenS&#34;&gt;KeenS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;COOKPAD: &lt;a href=&#34;http://cookpad.com/kitchen/3303629&#34;&gt;κeen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Qiita: &lt;a href=&#34;https://qiita.com/blackenedgold&#34;&gt;blackenedgold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SlideShare: &lt;a href=&#34;http://www.slideshare.net/blackenedgold&#34;&gt;blackenedgold&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;main-interests&#34;&gt;Main Interests&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Emacs&lt;/li&gt;
&lt;li&gt;Lisp&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;ML (Meta Language)&lt;/li&gt;
&lt;li&gt;言語処理系(主にインタプリタ)

&lt;ul&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;最適化&lt;/li&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;λ計算&lt;/li&gt;
&lt;li&gt;継続&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;li&gt;システムプログラミング&lt;/li&gt;
&lt;li&gt;数学基礎論&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rustのモジュールの使い方</title>
      <link>/blog/2017/01/15/rustnomoju_runokirikata</link>
      <pubDate>Sun, 15 Jan 2017 20:52:14 +0900</pubDate>
      
      <guid>/blog/2017/01/15/rustnomoju_runokirikata</guid>
      <description>&lt;p&gt;κeenです。たまにRustのモジュールが分かりづらいとの声を聞くので解説しますね。&lt;/p&gt;

&lt;p&gt;
とりあえずサンプルプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new module
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;エラいのは-lib-rs-と-main-rs&#34;&gt;エラいのは &lt;code&gt;lib.rs&lt;/code&gt; と &lt;code&gt;main.rs&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;モジュールの話をする前にクレートの話をしないといけません。
クレートはRustのプログラムの一番大きな単位です。
大きく分けてライブラリを作るlibクレートと実行可能ファイルを作るbinクレートがあります。&lt;/p&gt;

&lt;p&gt;libクレートならば&lt;code&gt;lib.rs&lt;/code&gt;が、binクレートならば&lt;code&gt;main.rs&lt;/code&gt;がルートにあたるファイルです。ここから辿れるモジュールが全てです。プロジェクトにファイルが存在していてもこれらから辿れなかったらコンパイルされません。&lt;/p&gt;

&lt;h1 id=&#34;モジュールの作り方は3種類&#34;&gt;モジュールの作り方は3種類&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;ファイルの中にインラインで作る&lt;/li&gt;
&lt;li&gt;1ファイルで作る&lt;/li&gt;
&lt;li&gt;1ディレクトリで作る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;のやり方があります。 1.はそんなに使われなくて、説明のために1ファイルにまとめたい時や、可視性でアレコレする時のテクニックなんかに使われます。&lt;/p&gt;

&lt;p&gt;2.と3.の境界はサブモジュールを持つかどうかです。&lt;/p&gt;

&lt;p&gt;2.のファイルで作る時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように作っておいて、lib.rsの中を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod new_module;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;mod&lt;/code&gt;で参照してあげれば使えます。&lt;/p&gt;

&lt;p&gt;3.のディレクトリの時もそんなに変わらなくて、&lt;code&gt;lib.rs&lt;/code&gt;は変わらず、ファイルを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module
src/new_module/mod.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにしてあげます。&lt;code&gt;mod.rs&lt;/code&gt;の名前はこれでないといけません。丁度サブモジュールの&lt;code&gt;new_module&lt;/code&gt;にとっての&lt;code&gt;lib.rs&lt;/code&gt;のような存在が&lt;code&gt;mod.rs&lt;/code&gt;な訳です。&lt;/p&gt;

&lt;h1 id=&#34;兄弟モジュール同士の可視性&#34;&gt;兄弟モジュール同士の可視性&lt;/h1&gt;

&lt;h2 id=&#34;モジュールの身分&#34;&gt;モジュールの身分&lt;/h2&gt;

&lt;p&gt;さて、次のように2つのモジュールを作ってみましょう。lib.rsには&lt;code&gt;module_a&lt;/code&gt;のみ&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;module_a.rs&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build
   Compiling module v0.1.0 (file:///home/kim/Rust/module)
error[E0432]: unresolved import `module_a`
 --&amp;gt; src/lib.rs:1:5
  |
1 | use module_a;
  |     ^^^^^^^^ no `module_a` in the root

error: aborting due to previous error

error: Could not compile `module`.

To learn more, run the command again with --verbose.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と怒られます。一番エラいのは&lt;code&gt;lib.rs&lt;/code&gt;ですから、身分の低い &lt;code&gt;module_a&lt;/code&gt;では&lt;code&gt;mod&lt;/code&gt;宣言出来ません。&lt;/p&gt;

&lt;h2 id=&#34;君の名は&#34;&gt;君の名は&lt;/h2&gt;

&lt;p&gt;同じ設定で、&lt;code&gt;lib.rs&lt;/code&gt;に&lt;code&gt;module_a&lt;/code&gt;と&lt;code&gt;module_b&lt;/code&gt;両方を&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時、&lt;code&gt;module_b&lt;/code&gt;が&lt;code&gt;lib.rs&lt;/code&gt;から見た時と&lt;code&gt;module_a.rs&lt;/code&gt;から見た時で名前が変わります。&lt;/p&gt;

&lt;p&gt;lib.rsから見た時は、以下の3つが使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use self::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self&lt;/code&gt;というのは予約語で、ディレクトリでいうところの&lt;code&gt;.&lt;/code&gt;に相当します。&lt;/p&gt;

&lt;p&gt;module_a.rsからは同じく3つが使えますが、相対パスが変わります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;super&lt;/code&gt;も予約語で、&lt;code&gt;..&lt;/code&gt;に相当します。
ファイルが同じディレクトリにいるので分かりづらいですが、libが1つ上の階層で、その下にmodule_aとmodule_bがぶら下がってる感じですね。&lt;/p&gt;

&lt;h1 id=&#34;おじさんと隠し子&#34;&gt;おじさんと隠し子&lt;/h1&gt;

&lt;p&gt;次のように、サブモジュールを作ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$src
src/lib.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この時&lt;code&gt;sumbmodule&lt;/code&gt;から見た&lt;code&gt;module_b&lt;/code&gt;の名前はどうなるでしょうか。もうお分かりかと思いますが、以下の3つです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃ、逆に&lt;code&gt;module_b&lt;/code&gt;から見た&lt;code&gt;submodule&lt;/code&gt;はどうなるでしょうか。実は、&lt;code&gt;module_b&lt;/code&gt;から&lt;code&gt;submodule&lt;/code&gt;は見えません（lib.rsからも見えません）。&lt;code&gt;module_a&lt;/code&gt;1つで所帯を持っているので子である&lt;code&gt;submodule&lt;/code&gt;を外に出すかは&lt;code&gt;module_a&lt;/code&gt;の一存で決まります。今回は隠し子にしている訳ですね。いくら兄弟モジュールとはいえ家庭にまでは入り込めないのです。&lt;/p&gt;

&lt;p&gt;子供をちゃんと公開するには&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていたモジュール宣言を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてあげればOKです。そうすると&lt;code&gt;module_b&lt;/code&gt;からも見えて、以下の3種類で参照出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a::submodule;
use module_a::submodule;
use super::module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;木箱の外から&#34;&gt;木箱の外から&lt;/h1&gt;

&lt;p&gt;さて、今までは1クレート内での話でした。クレートの外から見るとどうなるでしょうか。&lt;/p&gt;

&lt;p&gt;新たに&lt;code&gt;main.rs&lt;/code&gt;を追加しましょう。先程 &lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;がエラいと話しましたが、どちらも別々のクレートを作るので&lt;code&gt;main.rs&lt;/code&gt;は完全にクレートの外です。&lt;/p&gt;

&lt;p&gt;こんな感じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/main.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、外部のクレートを参照するには&lt;code&gt;extern crate&lt;/code&gt;を書く必要があります。あとまあ、binクレートなので&lt;code&gt;main&lt;/code&gt;関数も必要ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.rs
extern carte module;
fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、&lt;code&gt;module_b&lt;/code&gt;はどういう名前で見えるでしょうか。見えません。一番エラい&lt;code&gt;lib.rs&lt;/code&gt;が&lt;code&gt;module_b&lt;/code&gt;を&lt;code&gt;pub&lt;/code&gt;にしていないのでクレートの外からは見えなくなっています。見たければ、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにします。&lt;/p&gt;

&lt;p&gt;さて、これでmain.rsからどのように見えるかというと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module::module_b;
use module::module_b;
use self::module::module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように気持的にルート直下にクレートがモジュールとして配置されたように見えます。&lt;/p&gt;

&lt;h1 id=&#34;家出&#34;&gt;家出&lt;/h1&gt;

&lt;p&gt;さて、同じように&lt;code&gt;lib.rs&lt;/code&gt;で&lt;code&gt;module_a&lt;/code&gt;を&lt;code&gt;pub mod&lt;/code&gt;すれば&lt;code&gt;module::module_a::submodule&lt;/code&gt;も参照出来るようになります。ところで、例えば&lt;code&gt;module_a&lt;/code&gt;は外に出さずに&lt;code&gt;submodule&lt;/code&gt;だけを公開したい時にはどうしたらいいでしょうか。そんなケースあるのかと疑問に思うかもしれませんが、あります。同じクレートであっても&lt;code&gt;pub&lt;/code&gt;にしないとサブモジュールにアクセス出来ないことを思い出して下さい。そうすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub mod submodule;
pub mod internal_submodule_a;
pub mod internal_submodule_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなケースが発生するのは想像出来ると思います。そういう時は、&lt;code&gt;lib.rs&lt;/code&gt;側でどうにかいじれます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていると思いますが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、&lt;code&gt;pub use&lt;/code&gt; を加えてあげることで&lt;code&gt;module_a&lt;/code&gt;の下から出すことが出来ます。&lt;/p&gt;

&lt;p&gt;これを&lt;code&gt;main.rs&lt;/code&gt;から使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように名字の&lt;code&gt;module_a&lt;/code&gt;が取れます。&lt;/p&gt;

&lt;p&gt;さらに踏み込めば、&lt;code&gt;use&lt;/code&gt;は&lt;code&gt;as&lt;/code&gt;を使ってリネーム出来るので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule as module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにリネーム&lt;code&gt;use&lt;/code&gt;してあげれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように参照することも出来ます。完全に籍を外れて名前の上では別人ですね。&lt;/p&gt;

&lt;p&gt;実装する時の都合とAPIとして公開する時の都合が違うので公開用にいじれる作りになってるんですね。&lt;/p&gt;

&lt;h1 id=&#34;lib-rsとmain-rs&#34;&gt;lib.rsとmain.rs&lt;/h1&gt;

&lt;p&gt;上では&lt;code&gt;lib.rs&lt;/code&gt;を使って説明しましたが、&lt;code&gt;main.rs&lt;/code&gt;でも同じことが出来ます。&lt;/p&gt;

&lt;p&gt;さて、ここからはスタイルの話ですが、私がRustを書く時は&lt;code&gt;main.rs&lt;/code&gt;の中に&lt;code&gt;mod&lt;/code&gt;を書くことはないです。必ず&lt;code&gt;lib.rs&lt;/code&gt;を作って、そこでライブラリとしてまとめてから&lt;code&gt;main.rs&lt;/code&gt;で使います。「アプリケーションはアプリケーションを記述するための巨大なDSLとそれを使った小さな実装からなる」という思想ですね。明示的に境界を作ることで自然とAPIを設計出来るのでコードが整理しやすくなります。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;が一番エラい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mod&lt;/code&gt; で「モジュールがある」宣言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub mod&lt;/code&gt; で加えて上位のモジュールにも公開&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt;と&lt;code&gt;super&lt;/code&gt;の予約語&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub use&lt;/code&gt; で改名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;力尽きてテストのためのモジュールの話が出来なかったので&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/testing.html#tests-%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB&#34;&gt;ドキュメント&lt;/a&gt;を読んでみて下さい。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;https://github.com/BurntSushi/fst/blob/master/src/lib.rs&#34;&gt;これ&lt;/a&gt;のようにテクニックが詰まった&lt;code&gt;lib.rs&lt;/code&gt;ファイルなんかも存在するので参考にどうぞ。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>