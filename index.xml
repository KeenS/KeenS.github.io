<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Wed, 13 Jul 2016 23:34:03 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>シェル芸十八般</title>
      <link>/blog/2016/07/13/shierugeijuuhachihan</link>
      <pubDate>Wed, 13 Jul 2016 23:34:03 +0900</pubDate>
      
      <guid>/blog/2016/07/13/shierugeijuuhachihan</guid>
      <description>

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;武芸十八般のひとつシェル芸ってワードがふと湧いてきたけどどちらかというとシェル芸十八般とかの方がよさそう。grep, cut, xargs,&amp;hellip;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/753211663927513088&#34;&gt;2016年7月13日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;cat&#34;&gt;&lt;code&gt;cat&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;ファイルの内容を吐くのに使う。 -n とか使えそうなオプションがあるが滅多に使わない&lt;/p&gt;

&lt;h2 id=&#34;例&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat file
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;head&#34;&gt;&lt;code&gt;head&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;標準入力の先頭のほうだけを切り取る。大きなファイルに対して処理する前にちょろっと試すのに使う&lt;/p&gt;

&lt;h2 id=&#34;例-1&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat large_file | head -n 10 | ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tail&#34;&gt;&lt;code&gt;tail&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;標準入力の末尾のほうだけを切り取る。&lt;code&gt;-f&lt;/code&gt; オプションでよく使う&lt;/p&gt;

&lt;h2 id=&#34;例-2&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tail -f log_file | grep -ie error -e &#39;$&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;grep&#34;&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;globally regexp print. 汎用フィルタとして様々に活躍する他飛び道具的な使い方もある。&lt;/p&gt;

&lt;h2 id=&#34;例-3&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat file | grep some_word
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat file | grep -v &amp;quot;^[ \n\t]+$&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo hello | grep -o .
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;awk&#34;&gt;&lt;code&gt;awk&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;プログラミング言語awk。だいたい &lt;code&gt;cut&lt;/code&gt; の上位互換として使われる。&lt;/p&gt;

&lt;h2 id=&#34;例-4&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls -l | awk &#39;{print $3}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;seq 1 100 | awk &#39;BEGIN{sum=0}{sum+=$0}END{print sum}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sed&#34;&gt;&lt;code&gt;sed&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;プログラミング言語sed。だいたい &lt;code&gt;s/RE/replace/&lt;/code&gt; が使われるが使いこなすと深い。&lt;/p&gt;

&lt;h2 id=&#34;例-5&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat log_file | sed &#39;s/error/ERROR/gi&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat some.csv | sed 1d
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;xargs&#34;&gt;&lt;code&gt;xargs&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;標準入力を横に並べる、コマンドを並列に実行する、繰り返し実行をするなどストリーム内での制御機構的働きをする&lt;/p&gt;

&lt;h2 id=&#34;例-6&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;seq 1 10 | xargs echo
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -type f | xargs -P $(nproc) grep FIXME
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;inc(){ echo $(( 1 + $1 ));}
export -f sum
seq 1 10 | xargs -I@ bash -c &#39;sum @&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;find&#34;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;複雑なクエリ式を書けるコマンド。(シェルに依存してしまう)ワイルドカード展開の肩代わりなんかも出来る。xargsに繋げることが多い。&lt;/p&gt;

&lt;h2 id=&#34;例-7&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -type f -name &#39;*.md&#39; -exec basename &#39;{}&#39; .md \;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sort&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;ほぼ次のuniqに繋げるために使うことが多い。あるいはuniqした結果を使う。&lt;/p&gt;

&lt;h2 id=&#34;例-8&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat .histfile | grep &#39;|&#39; | sed &#39;s/|/\n/g&#39; | awk &#39;{print $1}&#39; | LANG=C sort | uniq -c | LANG=C sort
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;uniq&#34;&gt;&lt;code&gt;uniq&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;多くは頻度のカウントに使う。&lt;/p&gt;

&lt;h1 id=&#34;tar&#34;&gt;&lt;code&gt;tar&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;リモートホストとファイルをやりとりするのに使う。&lt;/p&gt;

&lt;h2 id=&#34;例-9&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh stepper ssh host1 tar czf - -C &#39;/var/log/somedir/&#39; stdout.log stderr.log | tar xzf - -C /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;zcat&#34;&gt;&lt;code&gt;zcat&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;圧縮ファイル扱うのに使う。よくtarと組み合わせる。
プロセスが分かれる分マルチコアを使えるのでtarのzオプション使うより速いかもしれない。&lt;/p&gt;

&lt;h2 id=&#34;例-10&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zcat some.tar.gz | tar tf - | xargs -I@ -n 1 basename @ .java
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;date&#34;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;日付操作用コマンド。BSD系とGNU系で全然違う。つらい。&lt;/p&gt;

&lt;h2 id=&#34;例-11&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find logs -type f -name &#39;*.log&#39; | xargs -I@ dirname @ | sed &#39;s|logs/||&#39; | tr / - | xargs -I@ date --date=@ +%w | sort | uniq -c
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tr&#34;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;文字置換、削除。&lt;code&gt;sed&lt;/code&gt;で出来るじゃんとか言わない。&lt;/p&gt;

&lt;h2 id=&#34;例-12&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat data.list | tr -c &#39;[a-zA-Z0-9\n]&#39; _ | xargs touch
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;curl&#34;&gt;&lt;code&gt;curl&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;なんでもプロトコル喋る人。結果を標準出力に吐くのでREST APIを叩いた後シェル芸に繋げやすい。&lt;/p&gt;

&lt;h2 id=&#34;例-13&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl http://example.io/status | jq -r &#39;.status&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;jq&#34;&gt;&lt;code&gt;jq&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;チューリング完全言語jq。REST API叩いてjsonが返ってきた時に使うと便利。&lt;/p&gt;

&lt;h1 id=&#34;od&#34;&gt;&lt;code&gt;od&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;バイナリデータを扱うのに使う。&lt;/p&gt;

&lt;h2 id=&#34;例-14&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat /dev/urandom | od -x | head -n 10 | ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tee&#34;&gt;&lt;code&gt;tee&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;T字管のようにパイプを分岐させるのに使う。あるいはシェルの機能であるリダイレクトをコマンドとして実行するのに使う。&lt;/p&gt;

&lt;h2 id=&#34;例-15&#34;&gt;例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat nginx.conf | ssh stepper ssh host1 sudo tee /etc/nginx/nginx.conf &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Container Desgin Patterns</title>
      <link>/blog/2016/07/02/container_desgin_patterns</link>
      <pubDate>Sat, 02 Jul 2016 22:26:10 +0900</pubDate>
      
      <guid>/blog/2016/07/02/container_desgin_patterns</guid>
      <description>

&lt;p&gt;κeenです。先日、Kubernetesの開発者が書いた&lt;a href=&#34;http://blog.kubernetes.io/2016/06/container-design-patterns.html&#34;&gt;Kubernetes: Container Design Patterns&lt;/a&gt;というのを教えてもらって、面白かったのでそれを紹介します。
ただ漫然とコンテナを使っているだけでは気付かない使い方があったのでコンテナに興味のある方は是非一読下さい。&lt;/p&gt;

&lt;h1 id=&#34;序論&#34;&gt;序論&lt;/h1&gt;

&lt;p&gt;オブジェクト指向が出てすぐにオブジェクト指向デザインパターンが産まれたように、分散システムにもデザインパターンが必要となってきました。
分散システムのデザインパターンの萌芽はHadoop/MapReduceに見ることが出来ますが、Javaに限られていました。
ところがここ数年の(Linuxの)コンテナ技術の躍進により欠けていたピースが埋まりました。分散システムパターンへのデプロイの抽象化です。
依存モジュールも一緒にデプロイ出来ますし、デプロイの状態も成功/失敗の二値になります。
それだけでなく、コンテナはオブジェクト指向におけるオブジェクトによく似た役割を果たします。それを見ていきましょう。&lt;/p&gt;

&lt;h1 id=&#34;単一コンテナのマネジメント-パターン&#34;&gt;単一コンテナのマネジメント パターン&lt;/h1&gt;

&lt;p&gt;コンテナは、自然にインターフェースの境界となります（オブジェクトと同じように）。
アプリケーション機能のインターフェースに留まらず、コンテナそのものの管理インターフェースも提供するでしょう。
典型的には &lt;code&gt;run()&lt;/code&gt; &lt;code&gt;pause()&lt;/code&gt; &lt;code&gt;stop()&lt;/code&gt; の管理ですが、もっと多様な管理インターフェースが有り得ます。&lt;/p&gt;

&lt;p&gt;大抵の今時のプログラミング言語ならHTTP経由でJSONをやりとりする機能くらい簡単に書けるのでそれがコンテナ間で統一さたインターフェースになりえるでしょう。&lt;/p&gt;

&lt;p&gt;上位のアプリケーションに対してはコンテナ内の情報(アプリケーションのQPS, プロファイル情報, コンフィグ情報, ヘルスチェック, ログなどなど)を提供するでしょう。&lt;/p&gt;

&lt;p&gt;下位のアプリケーションにはマネジメントインターフェース、例えばgraceful shutdownなどを提供することになるでしょう。
Android OSがActivityを管理する時に様々なコールバック(&lt;code&gt;onCreate&lt;/code&gt;, &lt;code&gt;onResume&lt;/code&gt;&amp;hellip;)を呼ぶように、分散マネージャがコンテナを管理するための様々なAPIを提供すると綺麗に管理出来ます。
また、コンテナ特有の機能として「レプリケーションする」（スケールアップするためのインターフェース）なんかもあるかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;単一ノード-複数コンテナのアプリケーションパターン&#34;&gt;単一ノード、複数コンテナのアプリケーションパターン&lt;/h1&gt;

&lt;p&gt;コンテナマネージャにはKubernetesのPodやNomadのTask Groupsのように複数のコンテナを1つのノードにスケジュールする機能があります。
別にコンテナに分けずに複数のコンテナをアプリケーションと同じの1つのコンテナに入れることも可能です。しかしながら分けた方が様々なメリットが得られます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;コンテナがリソース管理の単位である。cgroupによる管理がやりやすくなる。&lt;/li&gt;
&lt;li&gt;コンテナがパッケージングの単位である。複数のコンテナでデプロイや管理をするチームを分けるのも簡単になるし、テストも簡単になる。&lt;/li&gt;
&lt;li&gt;コンテナが再利用の単位である。多くのサブ機能コンテナは多種のメインコンテナと一緒に使うことが出来る。&lt;/li&gt;
&lt;li&gt;コンテナが障害を分離する境界になる。例えば、コンテントマネジメントコンテナに障害があったとしても、Webサーバコンテナはサービスを継続出来るようになる。&lt;/li&gt;
&lt;li&gt;コンテナがデプロイの単位となる。新しい機能の追加やロールバックが単独で行える。（ただし、アプリケーションのバージョンの組み合わせが増えるという点では短所にもなる）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ということでそれらを前提にしたデザインパターンをいくつか。&lt;/p&gt;

&lt;h2 id=&#34;サイドカーパターン&#34;&gt;サイドカーパターン&lt;/h2&gt;

&lt;p&gt;メインのアプリケーションコンテナにサイドカーのように付属するコンテナを付けて、機能を足すパターンです。
例えばアプリケーションがあって、それのログをローカルストレージから分散ストレージに保存するサイドカーなど。&lt;/p&gt;

&lt;p&gt;逆に、ローカルディスクのファイルを提供するWebサーバがあったとして、そのために定期的にgitからstatic fileをpollするサイドカーコンテナなんかもあるかもしれません。&lt;/p&gt;

&lt;p&gt;これらのサイドカーは同じノードのコンテナ同士ならディスクボリュームを共有出来ることに依存した作りになっています。&lt;/p&gt;

&lt;h2 id=&#34;アンバサダーパターン&#34;&gt;アンバサダーパターン&lt;/h2&gt;

&lt;p&gt;アンバサダーパターンはメインコンテナと別システムとのコミュニケーションを代理します。
例えば、&lt;a href=&#34;https://github.com/twitter/twemproxy&#34;&gt;twemproxy&lt;/a&gt; のコンテナをアンバサダーとすれば実際は複数のmemcachedにシャードされたmemcachedクラスタと通信しているも関らず、アプリケーションはローカルホストのmemcachedと通信しているように出来ます。&lt;/p&gt;

&lt;p&gt;この利点は1つにはアプリケーションをローカルホストのmemcachedと通信することだけを考えて書けばいいようになる点、もう1つにはアプリケーションのテストをローカルホストのmemcachedとだけすれば良くなる点、さらにもう1つにはtwemproxyのコンテナを（別の言語で書かれた）別のアプリケーションに使い回せる点にあります。&lt;/p&gt;

&lt;p&gt;これは同じホストのコンテナ同士はローカルホストのネットワークインターフェースを使って通信出来ることに依存した作りになっています。&lt;/p&gt;

&lt;h2 id=&#34;アダプターパターン&#34;&gt;アダプターパターン&lt;/h2&gt;

&lt;p&gt;アダプターパターンはアンバサダーパターンの逆で、アプリケーションを外部から観測した時に統一されたインターフェースを提供するようにするために使います。&lt;/p&gt;

&lt;p&gt;アプリケーション毎にメトリクスの採り方は異ります（例えばJavaならJMX、など）。様々にあるメトリクスを統一したインタフェースで提供するとメトリクスアグリゲータが非常にシンプルになります。
具体的な例を出すと&lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;のためのインターフェース (HTTP &lt;code&gt;/metrics&lt;/code&gt;)を提供する(&lt;a href=&#34;https://prometheus.io/docs/instrumenting/exporters/&#34;&gt;exporter&lt;/a&gt;)コンテナなどです。&lt;/p&gt;

&lt;p&gt;アダプターとメインコンテナはストレージやローカルホストネットワークを通じてデータをやりとりするでしょう。&lt;/p&gt;

&lt;h1 id=&#34;複数ノードアプリケーションパターン&#34;&gt;複数ノードアプリケーションパターン&lt;/h1&gt;

&lt;p&gt;次は複数のノードに跨る協調分散システムでのパターンです。
こちらも同じくPodなどの抽象化を前提とします。&lt;/p&gt;

&lt;h2 id=&#34;リーダー選出パターン&#34;&gt;リーダー選出パターン&lt;/h2&gt;

&lt;p&gt;分散システムではリーダを選出する需要が多々あります。
例えば複数のレプリカを作った時にマスターがコケたら次のマスターを選出しないといけません。&lt;/p&gt;

&lt;p&gt;巷にはリーダー選出アルゴリズムを実装したライブライが出回っていますが、往々にして難解であり、また、特定の言語でしか動かないので再利用性がありません。&lt;/p&gt;

&lt;p&gt;そこで、ライブラリを使うのではなくてリーダー選出コンテナを実装しましょう。&lt;/p&gt;

&lt;p&gt;単一ノードのパターンと同じく、リーダー選出コンテナとアプリケーションコンテナを一緒にスケジューリングします。
そして、リーダー選出コンテナが他のコンテナとネゴシエーションしてリーダーになったら、ローカルホストのHTTP APIにbecomeLeader、renewLeadershipなどのクエリを投げます。
アプリケーションはただそれらのエンドポイントを実装しさえすればいいのです。&lt;/p&gt;

&lt;p&gt;このコンテナはアプリケーションにも言語に依存しないので自由に使い回すことが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;ワークキューパターン&#34;&gt;ワークキューパターン&lt;/h2&gt;

&lt;p&gt;もう1つのよくある分散システムでのタスクは、ワークキューによる分散実行です。
いくつかワークキューの実装はありますが、やはりそれらは特定の言語に依存しています。&lt;/p&gt;

&lt;p&gt;そこで仕事の分配のコンテナ、そして、仕事実行のフレームワークとなるコンテナを用意してあげましょう。&lt;/p&gt;

&lt;p&gt;フレームワークのコンテナは分配コンテナから仕事(ファイルなど)を受け取って、ユーザの書いた実行コンテナに処理を移譲します。そしてフレームワークコンテナが実行コンテナの出力した結果をまた分配コンテナに戻します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
[Request]       +---[フレームワークコンテナ]=[実行コンテナ(ユーザ)]
   |            |
[分配コンテナ] --+
   |            |
   |            +---[フレームワークコンテナ]=[実行コンテナ(ユーザ)]
   |
[ワークキューの保存など]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分散協調の部分をフレームワークコンテナがやってくれるのでユーザが書く実行コンテナは非常にシンプルになります。&lt;/p&gt;

&lt;h2 id=&#34;分配-集約パターン&#34;&gt;分配/集約パターン&lt;/h2&gt;

&lt;p&gt;このパターンは、クライアントが1つの巨大なタスクをルートコンテナに投げ、ルートコンテナが子コンテナ達に分割したタスクを移譲します。そして子コンテナ達の結果を纏めてクライアントに返します。&lt;/p&gt;

&lt;p&gt;MapReduceと同じように、タスクを実行するリーフコンテナと、リーフコンテナの結果を纏めるマージコンテナを用意する必要があります。&lt;/p&gt;

&lt;p&gt;コンテナは特定のインターフェースさえ実装していればいいのでリファクタが(オブジェクト指向の時と同じように)容易です。&lt;/p&gt;

&lt;p&gt;また、子コンテナにルートコンテナと同じようなscatter/gather機能を持ったコンテナを使うことで、任意の深さにまでタスクツリーを作ることが出来ます。
これは例えば処理中のリソース使用量が多いときに部分的にタスクを実行してマージを繰替えすことで必要となる最大リソースを減らす、などに使えるでしょう（他にももっとあるかもしれませんがパッとは思いつきませんでした）。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;コンテナのデザインパターを紹介しました。フレームワークコンテナなど、興味深いパターンもあって興味深いですね。&lt;/p&gt;

&lt;p&gt;まだまだパターンはありえると思うのでこの分野（？）、もう少し広まると良いですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Socket on SML#</title>
      <link>/slide/Socket_on_SML_/</link>
      <pubDate>Sat, 02 Jul 2016 15:25:24 +0900</pubDate>
      
      <guid>/slide/Socket_on_SML_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Socket on SML&amp;#x23;
----------------------
[ML勉強会](http://connpass.com/event/32752/) 2016-07-09

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# HTTP on SML&amp;#x23;?
-------------

* SML#にJSONサポートが入った
  + REST API簡単に叩けるのでは？
* SML#にFully Concurrent GCが入った
  + HTTPサーバ書くとレイテンシ抑えられて嬉しいのでは？
  * スレッドも使えるしスループットも高い筈
* SML#でHTTPの機運
* しかしHTTPサポートはないので自前実装するしかない


# Socket on SML&amp;#x23;?
------------------

* HTTPサポートに必要
* Basisにはある (Optional)
  + SML#のBasisはサポートしてない
* FFIあるしユーザランドで実装するか
* [KeenS/SmlSharpSocketSupport](https://github.com/KeenS/SmlSharpSocketSupport)


# TCP/IP、ソケットなど
---------------------------

* ソケットアドレス - 自分、相手の居場所。これがないと通信出来ない
  + 複数のアドレスファミリ(AF)がある
  + IP v4, IP v6, UNIXドメインなど。
* ソケット - 通信の仕組み。プログラムからはfdとして見える。
  + AFやtype(stream/diagram)の属性を持つ
* INet - インターネットドメインソケット
  + TCPとUDP
  + IP v4/v6アドレスで通信


# 主要なstructure
-----------------

* Socket
* NetHostDB
* INetSock
* (UnixSock)


# [NetHostDB](http://sml-family.org/Basis/net-host-db.html#SIG:NET_HOST_DB)
-----------

* ドメイン名からIPアドレスを調べたり逆をやったり
* Cの古い(現在では非推奨な)APIに合わせた設計
  + IPがv4/v6が混じることを考慮してない
  + 非推奨どころか脆弱性もあったり CF [glibc の脆弱性 CVE-2015-0235（通称：GHOST）についてまとめてみた - piyolog](http://d.hatena.ne.jp/Kango/20150128/1422409960)
* 新しいAPIで実装するのが面倒


# [Socket](http://sml-family.org/Basis/socket.html#SIG:SOCKET.accept:VAL:SPEC)
---------

* まあまあでかいけどsend/receive関数の変種が一杯あるだけ
* ドメインに依らないソケット操作
* typeには依る
  + stream socketとdgramソケットで送受信関数が別


# Socket.AF
------------

* ソケットのアドレスファミリ関連
* 仕様では具体的なファミリを定義しない


# Socket.SOCK
-------------

* ソケットにも種類がある
  + stream/diagram
* さらにstreamにはactive/passiveがある
* それらの型。


# [INetSock](http://sml-family.org/Basis/inet-sock.html#INetSock:STR:SPEC)
--------------

* IP - TCP/UDPのソケットを作る/操作するやつ。
* ここの関数はインターネットドメインソケットしか受け付けない


# Socketについて整理
----------------

* sockにはtypeとafの属性がある
* afは色々ある
* typeはstreamとdgramがある
* streamにはさらにactiveとpassiveがある
* 特定のaf, 特定のtypeしか受け付けない関数がある


# Socketについて整理
----------------

```
   (AF_UN)
        v
     [unix sock]...
         |                       (Active)
[socket]-+           [TCP(stream)]-+
         |             |         (Passive)
     [inet/inet6 sock]-+
        ^              |
   (AF_INET/INET6)   [UDP(dgram)]
```


&lt;span style=&#34;font-size:500%;&#34;&gt;幽霊型&lt;/sapn&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Socketの幽霊型
---------------

```sml
type (&#39;af,&#39;sock_type) sock
type &#39;af sock_addr
type dgram
type &#39;mode stream
type passive
type active
```

# サーバのSocket操作(stream)
---------------------------

* INetSock(UnixSock)でソケットを作る(af, sock typeの選択, プロセス側の準備)
* bindでソケットをsock_addrにバインドする(アドレスの割り当て)
* listenでソケットの特定のポートを開ける(TCPの開始)
  + passive streamしか受け付けない
* acceptでクライアントからの入力を受け付ける(接続)
  + passive streamしか受け付けない
  + passive streamがactive streamになる
  + 一度acceptしたsockはlisten/accept出来ない

# データの送受信
---------------

* `send` / `recv`
* それぞれArraySlice/VectorSliceの制御フラグ有り/無しがある
  + 実装がまあまあ面倒


# SML# でのバインディング
------------------------

* sock - fd = int
* sock_addr - AFによってサイズが違う。ヤバい。
 + 任意のsock_addrを格納出来るsockaddr_storageを使う
 + Solarisだとsockaddr_unを格納出来ないらしい（任意のaddrを格納出来るとは）
   - SML#はSolarisでは動かないので問題ない。
* AF_* とか - Cではただのint。SML#は関数しかインポート出来ない。
 + C側で定数関数でラップしてSML#で呼び出した値を束縛
* その他 - straitforward


# 非同期IO

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 非同期IO
----------

* HTTPサーバは複数のクライアントとのコネクションを持つ
* それらのコネクションを要領良く扱わないといけない
* 相手の処理速度や通信速度によって即座にデータを読み書き出来ない時がある
  + 勿論クライアント毎に状況が異なる
* 読み書き出来ない時にやったらブロック(CPU時間の無駄遣い)する
* 「読み書き出来るならする」/「読み書き出来るクライアントを選ぶ」APIが必要


# 非同期API
----------

* select - 複数のクライアントを登録して、読み書き出来るやつを選ぶ
* \*NB - 読み書き出来るならやって、出来ないならブロックせずにリターンする
* poll - selectと同じような（ちょっと速い）API。SocketではなくIOにある。
  + pollがあるのに何故Socketにselectがあるの…。



# 非同期APIのFFI
----------------

* select - Cに対応する関数が。構造体の変換でメモリアロケーションが起きて遅い
* \*NB - O_NONBLOCKを付けたsend/recv。
* poll - SML#にある


# 非同期HTTPサーバ概略
---------------------

```sml
bind(sock, addr);
listen(sock, port);
create_thread(n, fn i =&gt; let
  val clientList = makeClientList()
  fun loop () = let
    val clientList =
      Option.map (acceptNB(sock))
      (fn client =&gt; addReadClient clientList client)
      handle SysErr =&gt; ...
    val {rds, wds, exs} = select (makeSelectList clientList)
  in
    recvAndParseHTTPThenCallHandler clientList rds;
    sendResponse clientList wds;
    loop ()
  end
end)
```


# Cバインディングの憂鬱

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# importとメモリ割り当て
-----------------------

* SML#にはポインタかワードサイズ以下の値しか渡せない
  + stringとかはポインタからインポートする関数がある
  + インポートしたものはSML#のヒープに **コピーされる**
* cでポインタを返すにはmallocが必要
* **すぐコピーされてfreeされるもののためにmalloc??**
* SML#からコールバックを渡してCのスタックの変数をインポート
* CF https://github.com/KeenS/SmlSharpSocketSupport/blob/master/lib/net_host_db.c#L74


# メモリ管理
------------

* SML#にインポート出来る型は限られている
  + array, string
* 他の型はポインタのまま扱う。
* ポインタはGCされない
* `sockaddr` は仕様的にファイナライザを持っていない
  + 現状 **メモリリークする**
* SML#側でどうにかしてもらわないとダメ？
  + パンドラの壷(sml_alloc)使う？


# 型隠蔽
-------

* sockは本来はioDescに変換出来ないといけない
 + SML#でioDescはsockと同じくint
* しかし型隠蔽のせいでintをioDescに変換出来ない
* 手詰まり


# まとめ
--------

* socketとかその辺を解説したよ
* SML#向けにSocket関連Basisのバインディング作ってるよ
* BasisのAPI使うと非同期HTTPサーバ作れるよ
* SML#のFFIはやっぱりつらいよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustの所有権/ミュータビリティの分割</title>
      <link>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</link>
      <pubDate>Sun, 19 Jun 2016 20:42:14 +0900</pubDate>
      
      <guid>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</guid>
      <description>

&lt;p&gt;κeenです。昔所有権/ミュータビリティを分割したくなったけどぱっと方法が思いつかなくて困ったことがあるので今更ながら備忘録として残しておきます。&lt;/p&gt;

&lt;h1 id=&#34;ミュータビリティ&#34;&gt;ミュータビリティ&lt;/h1&gt;

&lt;p&gt;例えば、HTTPパーサを作ろうとしてるとしましょう。
受け取ったバイト列のバッファをパースしてヘッダやらボディやらのサブスライスを返します。この時、返り値のサブスライスはユーザへの自由を与えるために &lt;code&gt;mut&lt;/code&gt; にしたいですよね。&lt;/p&gt;

&lt;p&gt;そう思ってこういうコードを書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io;

fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...
    Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mutability_split.rs:4:31: 4:34 error: cannot borrow `*buf` as mutable more than once at a time [E0499]
mutability_split.rs:4     Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通にやろうとすると
1つ1つミュータブルなサブスライスを作ることになり、2つ目以降でborrow checkに引っ掛かってしまいます。2つのバッファがオーバーラップしてなくても。難儀ですね。コピーするくらいしかないのでしょうか。いいえ。rustはちゃんと助けになるAPIを用意してくれています。&lt;/p&gt;

&lt;h2 id=&#34;split-at-mut-https-doc-rust-lang-org-std-primitive-slice-html-method-split-at-mut&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut&#34;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn split_at_mut(&amp;amp;mut self, mid: usize) -&amp;gt; (&amp;amp;mut [T], &amp;amp;mut [T])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スライスを2つに分割してくれます。重要なのが、ミュータビリティも分割してくれるところです。返り値の2つ共に &lt;code&gt;mut&lt;/code&gt; がついています。ということで、次のように実装出来ます。（実行してないので結果が正しいかは確認してませんが）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...

    let (h, b) = buf.split_at_mut(bstart);
    let h = {
        let (_, h) = h.split_at_mut(hstart);
        let (_, h) = h.split_at_mut(hend - hstart);
        h
    };

    let (_, b) = b.split_at_mut(bend - bstart);

    Ok((h, b))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;所有権&#34;&gt;所有権&lt;/h1&gt;

&lt;p&gt;似たような話で、構造体の所有権というか、貸与権(?)を分割したい時もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonDB {
    name: String,
    age: usize,
    address: String,
}


fn use_immutable(s: &amp;amp;str) {
    // empty
}

fn use_mutable(s: &amp;amp;mut str) {
    // empty
}



fn from_db(person: PersonDB) {
    let name = &amp;amp;person.name;
    let mut address = &amp;amp;mut person.address;
    use_immutable(name);
    use_mutable(address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イミュータブルとミュータブル両方の借用があるのでエラーになってしまいます。実際は別のフィールドなので問題は起きないのですが、コンパイラに怒られます。理不尽ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mutability_split.rs:36:28: 36:42 error: cannot borrow immutable field `person.address` as mutable
mutability_split.rs:36     let mut address = &amp;amp;mut person.address;
                                                  ^~~~~~~~~~~~~~

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そういう時は、パターンマッチによる分配束縛でクリア出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn from_db(person: PersonDB) {
    let PersonDB {name, mut address, ..} = person;
    use_immutable(&amp;amp;name);
    use_mutable(&amp;amp;mut address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Rustの所有権やミュータブルな参照など、1つしか存在出来ないとされるものが分割出来ることを示しました。
地味に悩む所なので誰かの助けになれば幸いです。&lt;/p&gt;

&lt;p&gt;蛇足を足すと、本当は所有権の分割についても書く予定でしたがエラーになる筈のコードがあっさりコンパイルを通ってしまったのでナシになりました。コンパイラも進化してますね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>multirustが非推奨になったようなのでrustupに移行する</title>
      <link>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</link>
      <pubDate>Sun, 12 Jun 2016 15:23:06 +0900</pubDate>
      
      <guid>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</guid>
      <description>

&lt;p&gt;κeenです。どうやらもうそろそろRustのツールチェーン管理はmultirustじゃなくてrustupを使った方が良さそうなので移行しようと思います。&lt;/p&gt;

&lt;p&gt;きっかけはmultirustにそういうコミットがされたから。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;もうmultirustじゃなくてrustup使え、と。&lt;br&gt;&lt;br&gt;Update README.md · brson/multirust@84c3459&lt;a href=&#34;https://t.co/ySeRB50x5C&#34;&gt;https://t.co/ySeRB50x5C&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/741077158651514882&#34;&gt;2016年6月10日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;因みにrustupは&lt;a href=&#34;https://github.com/rust-lang/rustup.sh&#34;&gt;rust-lang/rustup.sh: The rustup.sh script for installing Rust from release channels&lt;/a&gt;ではなく&lt;a href=&#34;https://github.com/rust-lang-nursery/rustup.rs&#34;&gt;rust-lang-nursery/rustup.rs: The Rust toolchain installer&lt;/a&gt;の方です。インストールガイドなどはこちらから。&lt;a href=&#34;https://www.rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なんかベータ版のようですが推奨していいんですかね…。&lt;/p&gt;

&lt;p&gt;とりあえずmultirustを入れたままコマンドを叩いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer
warning: it looks like you have an existing installation of multirust
warning: rustup cannot be installed alongside multirust
warning: run `/usr/local/lib/rustlib/uninstall.sh` as root and delete `/home/kim/.multirust/version` before installing rustup
error: cannot install while multirust is installed
rustup: command failed: /tmp/tmp.9kjQj9WT5O/rustup-init

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふーむ。アンインストールしろ、と。一応指示された通りmultirust自体はアンインストールせずにversionだけを削除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/local/lib/rustlib/uninstall.sh
install: uninstalling component &#39;multirust&#39;

    multirust is uninstalled.
$ rm -rf ~/.multirust/version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう一度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;選択肢が出ました。とりあえず1を選択します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: toolchain &#39;stable&#39; is not installed
info: caused by: not a directory: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu&#39;
rustup: command failed: /tmp/tmp.nugK4VN4p8/rustup-init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;えー。ちょっと…。仕方ないのでシンボリックリンクを貼って騙してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls ~/.multirust/toolchains/
beta  nightly  stable
$ ln -s ~/.multirust/toolchains/{stable,stable-x86_64-unknown-linux-gnu}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3度目の正直なるか&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
1

info: updating existing rustup installation


Rust is installed now. Great!

To get started you need Cargo&#39;s bin directory in your PATH environment variable.
Next time you log in this will be done automatically.

To configure your current shell run source $HOME/.cargo/env.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストール出来たよう。しかしセットアップは &lt;code&gt;~/.profile&lt;/code&gt; に書かれたようなので &lt;code&gt;.zshrc&lt;/code&gt; は自分で更新します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/zshrc b/zshrc
index 0178873..589c6a5 100644
--- a/zshrc
+++ b/zshrc
@@ -213,7 +213,7 @@ export PATSHOME=~/compile/ATS2-Postiats-$ATS_VERSION/
 export PATH=$PATSHOME/bin:$PATH
 export PATSHOMERELOC=~/compile/ATS2-Postiats-contrib-$ATS_VERSION
 
-export PATH=$PATH:~/.multirust/toolchains/stable/cargo/bin
+export PATH=&amp;quot;$HOME/.cargo/bin:$PATH&amp;quot;
 
 # OPAM configuration
 . /home/kim/.opam/opam-init/init.sh &amp;gt; /dev/null 2&amp;gt; /dev/null || true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup 0.1.12 (c6e430a 2016-05-12)
The Rust toolchain installer

USAGE:
    rustup [FLAGS] [SUBCOMMAND]

FLAGS:
    -v, --verbose    Enable verbose output
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    show         Show the active and installed toolchains
    update       Update Rust toolchains
    default      Set the default toolchain
    toolchain    Modify or query the installed toolchains
    target       Modify a toolchain&#39;s supported targets
    override     Modify directory toolchain overrides
    run          Run a command with an environment configured for a given toolchain
    which        Display which binary will be run for a given command
    doc          Open the documentation for the current toolchain.
    self         Modify the rustup installation
    telemetry    rustup telemetry commands
    help         Prints this message or the help of the given subcommand(s)

rustup installs The Rust Programming Language from the official
release channels, enabling you to easily switch between stable, beta,
and nightly compilers and keep them updated. It makes cross-compiling
simpler with binary builds of the standard library for common platforms.

If you are new to Rust consider running `rustup doc --book`
to learn Rust.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;multirustを使っていたら馴染めそうですね。&lt;/p&gt;

&lt;p&gt;一応どこにインストールされたのか確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which rustc
/home/kim/.cargo/bin/rustc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふむふむ。ちょいとアップデートしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.1 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.0 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   2.3 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %) 953.6 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.2 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.5 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 44.8 MiB /  44.8 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 57.9 MiB /  57.9 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.0 MiB /   7.0 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.3 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 46.5 MiB /  46.5 MiB (100 %) 924.8 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 59.0 MiB /  59.0 MiB (100 %)   2.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.3 MiB /   7.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   3.2 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: checking for self-updates
info: rustup is up to date

                           stable update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
  stable-x86_64-unknown-linux-gnu update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                                 beta installed - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                              nightly installed - rustc 1.11.0-nightly (0554abac6 2016-06-10)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、なんかコケてる…。シンボリックリンクが悪さしたかな…。しかし試しに手元のプロダクトをコンパイルしてみたら通ったので使えているよう。&lt;/p&gt;

&lt;p&gt;さて、クロスコンパイルの方はどうでしょうか。以前Raspberry Pi向けにクロスコンパイルしました &lt;a href=&#34;http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/&#34;&gt;RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog&lt;/a&gt;。これは動くでしょうか。&lt;/p&gt;

&lt;p&gt;とりあえずインストール可能なターゲットを確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………。無理矢理addしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target add nightly-arm-unknown-linux-gnueabihf
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………………………………。&lt;/p&gt;

&lt;p&gt;なんか変ですね。&lt;/p&gt;

&lt;p&gt;一旦&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm ~/.multirust/toolchains/stable-x86_64-unknown-linux-gnu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;してもう一度 &lt;code&gt;rustup update&lt;/code&gt; します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.6 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.7 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   5.0 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: checking for self-updates
info: rustup is up to date

                            stable installed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                              beta unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
     beta-x86_64-unknown-linux-gnu unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                           nightly unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
  nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、今回は上手くいった。やっぱりシンボリックリンクが悪かったよう。リトライ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target add --toolchain nightly arm-unknown-linux-gnueabihf
info: downloading component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
 62.6 MiB /  62.6 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: installing component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んー、ちゃんとnightlyが入ったのか分からない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup show
installed toolchains
--------------------

stable
stable-x86_64-unknown-linux-gnu (default)
beta
beta-x86_64-unknown-linux-gnu
nightly
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.9.0 (e4e8b6668 2016-05-18)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし件のARM向けプロジェクトのクロスコンパイルは出来たよう。&lt;/p&gt;

&lt;p&gt;もう一度listを見る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;arm-unknown-linux-gnueabihf (installed)&lt;/code&gt; とあるのでインストール出来ているよう。しかし本当にnightlyなのか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup target list --toolchain stable
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target list --toolchain nightly
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら本当にnightlyのよう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;色々あたふたとしましたがrustupをインストールして使ってみました。multirustを使っているとインストールあたりでやや難はありそうですがそれ以降は普通に使えそうです。&lt;/p&gt;

&lt;p&gt;皆様もお試しあれ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DOT/dottyについて調べてみた</title>
      <link>/slide/DOT_dottynitsuiteshirabetemita/</link>
      <pubDate>Tue, 24 May 2016 23:40:36 +0900</pubDate>
      
      <guid>/slide/DOT_dottynitsuiteshirabetemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# DOT/dottyについて調べてみた
----------------------
サイバーエージェント Scala Meet Up  
2016-05-27

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + Scala初心者
   + Scala歴1年未満&amp;gt;&amp;lt;


# Scalaコンパイラ
----------------

* 型推論（特にimplicit）が遅い
* コンパイルフェーズが多い
  + 中間オブジェクトが多くて遅くなる
* 多くのクラスファイルを生成する
  + コンパイラのくせにディスクIOが多い
* 気を抜いてると `Any` に推論される  
  e.g.) `if(x) 1 else &#34;a&#34;`
* そもそものScalaの設計に起因する点が多い
  + 抜本的変更が必要


# Scala基礎
-----------

* Scalaが成立するのに最低限必要な機能って？
  + e.g.) `case class` はなくても `class` だけでどうにかなる
* 「最低限の機能」を減らせばコンパイラがシンプルになる
  + 他の機能はただのシンタックスシュガーになる
  + コンパイラのバグを減らせる
  + 機能追加時の矛盾確認が楽
* コア言語


# Featherlight Scala
---------------------

* Scalaのシンタックスシュガーを減らした感じ
* 小さな言語
* 元のScalaはこれをベースに議論されてきた


# 形式言語理論
-------------

* 最低限必要な機能を形式的にモデル化
  + 全ての動作は予め決められた「規則」に基く
  + 実際に書いて動かすものではない
* 形式的にすることで「証明」とかが出来る
  + 「型検査に通れば実行時に型エラーが起きない」
  + 「型検査が必ず終了する」
* 逆に、「このモデルだとこの機能は実現出来ない」とかも分かる


# Dependent Object Type
------

* Scalaのコアをモデル化したもの（要出典）
* 形式言語
* ジェネリクスもなければクラスも継承もない、パッケージもない。
* 小さい言語ながら表現力豊か
* 全ての値はオブジェクト。
  + オブジェクトのフィールドとメソッドと型メンバーだけ
  + 型はそのまま
* Path Dependent Type
* サブタイピング



# About DOT
---------

* 型付の健全性が証明された
* System F&lt;:より強力
  * System F&lt;: -&gt; System D&lt;: -&gt; DOT
* existential typeを自然に表現出来る
* 交差型と合併型
  + `A extends B` -&gt; `A &amp; B`
  + 合併型は主に型推論の結果に出てくる


```scala
package scala.collection.immutable trait List[+A] {
  def isEmpty: Boolean; def head: A; def tail: List[A]
}
object List {
  def nil: List[Nothing] = new List[Nothing] {
    def isEmpty = true; def head = head; def tail = tail /* infinite loops */
  }
  def cons[A](hd: A, tl: List[A]) = new List[A] {
    def isEmpty = false; def head = hd; def tail = tl
  }
}
```


```scala
object scala_collection_immutable { sci =&gt;
  trait List { self =&gt;
    type A
    def isEmpty: Boolean
    def head: self.A def
      tail: List{type A &lt;: self.A}
  }
  def nil: sci.List{type A = Nothing} = new List{ self =&gt;
    type A = Nothing
    def isEmpty = true
    def head: A = self.head
    def tail: List{type A = Nothing} = self.tail
  }
  def cons(x: {type A})(hd: x.A)(tl: sci.List{type A &lt;: x.A})
      : sci.List{type A &lt;: x.A} = new List{ self =&gt;
    type A = x.A
    def isEmpty = false
    def head = hd
    def tail = tl
  }
}
```


# dotty
--------

* DOTに影響を受けたコンパイラ
* いくつかの新しい機能
  + DOTの交差型、合併型も
  + Nullable = `T | Null`
  + `if (x) 1 else &#34;a&#34;` は `Int | String` にアノテーション可能
* `forSome` が消えた
  + DOTのお陰


# dotty
--------

* Java8のラムダを使う
  + 生成するclassファイルの減少
* Implicitの探索アルゴリズムを改善
  + 反変implicitについても改善
* 型推論のアルゴリズムを改善
  + DOTのお陰
  + 特にサブタイピングが交差/合併型で楽に
* コンパイルパスを融合して高速化
  + 中間木がなくなってGCにやさしい
* 他にも一杯改善が



```scala
object DaysOfTheWeek{
  object Mon
  object Tue
  object Wed
  object Thu
  object Fri
  object Sat
  object Sun

  type Weekend = Sat.type | Sun.type
  type Workweek = Mon.type | Tue.type | Wed.type | Thu.type | Fri.type
  type All = Weekend | Workweek
}
```


# TASTY/Linker
--------------

* classファイルを作るとScala固有の情報が落ちる
* プログラム全体を見渡すと不要なコードとかもコンパイルしないといけない
* かといって毎回プログラム全部をコンパイルし直すのは遅い
* → TASTY。型推論後のASTをシリアライズする
  + Scalaは型推論が遅いのでそこをスキップ出来るだけでそこそこ速くなる
* classファイルを跨げるようになったのでユーザが最適化とかも書ける
* Scala/Scala.js/Scala Native共通プラットフォーム化への布石？
* どうやらclassファイルにバイトコードとTASTYを埋め込む??


# まとめ
--------

* Scalaの基礎にDOTがあるよ
* DOTを参考にdottyが作られたよ
* dottyで色々改善されるよ
* ついでにTASTY/Linkerについて話したよ


# 参考1
------

* [The Essence of Dependent Object Types](https://infoscience.epfl.ch/record/215280/files/paper_1.pdf)
* [From F to DOT: Type Soundness Proofs with Definitional Interpreters](http://arxiv.org/pdf/1510.05216v2.pdf)
* [Dependent Object Types](http://www.cs.uwm.edu/~boyland/fool2012/papers/fool2012_submission_3.pdf)
* [Why is the Scala compiler so slow? - Quora](https://www.quora.com/Why-is-the-Scala-compiler-so-slow)
* [performance - Java compile speed vs Scala compile speed - Stack Overflow](http://stackoverflow.com/questions/3490383/java-compile-speed-vs-scala-compile-speed/3612212#3612212)


# 参考2
-------

* [GHC doesn&#39;t do subtyping. I suspect that is the main reason why Scala is slow - ... | Hacker News](https://news.ycombinator.com/item?id=5008761)
* [A Core Calculus for Scala Type Checking](http://lampwww.epfl.ch/~odersky/papers/mfcs06.pdf)
* [namin/dot: formalization of the Dependent Object Types (DOT) calculus](https://github.com/namin/dot)
* [The DOT Calculus](http://lampwww.epfl.ch/%7Eamin/dot/current_rules.pdf)
* [Dotty: exploring the future of scala](https://d-d.me/talks/scalaworld2015/)
* [Dotty and types: the story so far](http://guillaume.martres.me/talks/typelevel-summit-oslo/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>cargo-profilerを試す</title>
      <link>/blog/2016/05/14/cargo_profilerwotamesu</link>
      <pubDate>Sat, 14 May 2016 20:59:13 +0900</pubDate>
      
      <guid>/blog/2016/05/14/cargo_profilerwotamesu</guid>
      <description>

&lt;p&gt;κeenです。先日Rustのニュースに流れてきたcargo profilerを試してみます。
元の紹介記事はこちら&lt;a href=&#34;http://www.suchin.co/2016/05/11/Introducing-Cargo-Profiler/&#34;&gt;Introducing Cargo Profiler · suchin&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;GitHubレポジトリはこちら&lt;a href=&#34;https://github.com/pegasos1/cargo-profiler&#34;&gt;pegasos1/cargo-profiler: cargo subcommand to profile binaries&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Profilerとはいっても自身でプロファイラを持っている訳ではなくて外部のプロファイラ（現状valgrind）を呼び出して整形してくれるツールのようです。
Rust向けに関数をモジュールパス付きで表示してくれたりするのでRustから使うにはvalgrind生より便利そうです。&lt;/p&gt;

&lt;h1 id=&#34;インストール&#34;&gt;インストール&lt;/h1&gt;

&lt;p&gt;READMEに従って&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt install valgrind
$ cargo install cargo-profiler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;h1 id=&#34;プロジェクトの準備&#34;&gt;プロジェクトの準備&lt;/h1&gt;

&lt;p&gt;適当なものがないので手元の[κLisp]()でフィボナッチ数列を動かしてみます。(と思ったらκLispに比較演算子がなかったのでそれを作るところから始まりましたがそれはまた別の話)。&lt;/p&gt;

&lt;p&gt;main.rsはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate kappa_lisp;
use kappa_lisp::kappa_lisp::{run, init};
use kappa_lisp::env::Env;

fn main() {
    let mut env = Env::new();
    init(&amp;amp;mut env).unwrap();
    run(&amp;amp;mut env, r&amp;quot;
(defun fib (n)
  (if (&amp;lt; n 2)
      1
      (+ (fib (- n 1)) (fib (- n 2)))))
&amp;quot;).unwrap();
    let expr = run(&amp;amp;mut env, r&amp;quot; (fib 20) &amp;quot;).unwrap();
    println!(&amp;quot;{}&amp;quot;, expr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;割と遅いので20くらいで限界でした。&lt;/p&gt;

&lt;p&gt;さて、これを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo build --release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてビルドします。&lt;/p&gt;

&lt;h1 id=&#34;プロファイル&#34;&gt;プロファイル&lt;/h1&gt;

&lt;p&gt;今のところcallgrindとcachegrindが実装されているようです。1つづづ試してみます。&lt;/p&gt;

&lt;h2 id=&#34;callgrind&#34;&gt;callgrind&lt;/h2&gt;

&lt;p&gt;よく分かってないのですが多分実行時間に占める関数毎の割合を出してくれるんですかね。-nで上位何件を表示するか指定出来ます。&lt;/p&gt;

&lt;p&gt;とりあえず上位10件出してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo profiler callgrind --bin ./target/release/kappa_lisp -n 10
Profiling kappa_lisp with callgrind...

Total Instructions...571,437,255

142,527,726 (24.9%) ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
107,551,309 (18.8%) ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
39,749,571 (7.0%) ???:collections::hash::map::HashMap..K$C$..V$C$..S..::get
-----------------------------------------------------------------------
38,693,006 (6.8%) ???:sdallocx
-----------------------------------------------------------------------
37,670,732 (6.6%) ???:mallocx
-----------------------------------------------------------------------
34,608,049 (6.1%) ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
26,539,906 (4.6%) ???:eval::eval
-----------------------------------------------------------------------
19,887,024 (3.5%) ???:util::f_foldr
-----------------------------------------------------------------------
16,634,175 (2.9%) ???:eval::feval
-----------------------------------------------------------------------
14,353,992 (2.5%) ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、こんな感じです。ハッシュテーブル関連が時間喰ってますね。これは関数呼び出しの度に行われてます。
ちょっと実装が雑すぎるので直さなきゃ…。&lt;/p&gt;

&lt;h1 id=&#34;cachegrind&#34;&gt;cachegrind&lt;/h1&gt;

&lt;p&gt;キャッシュミスを表示してくれます。本気出してチューニングする時に必要ですね。&lt;/p&gt;

&lt;p&gt;同じく -nで件数を絞り込めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10  


Profiling kappa_lisp with cachegrind...

Total Memory Accesses...800,070,388	

Total L1 I-Cache Misses...100,068 (0%)	
Total LL I-Cache Misses...422 (0%)	
Total L1 D-Cache Misses...4,346,335 (0%)	
Total LL D-Cache Misses...7,724 (0%)	

 Ir  I1mr ILmr  Dr  D1mr DLmr  Dw  D1mw DLmw
0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get
-----------------------------------------------------------------------
0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx
-----------------------------------------------------------------------
0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx
-----------------------------------------------------------------------
0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval
-----------------------------------------------------------------------
0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr
-----------------------------------------------------------------------
0.03 0.02 0.05 0.04 0.05 0.00 0.02 0.06 0.05 ???:eval::feval
-----------------------------------------------------------------------
0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やはりハッシュテーブルが酷いですが同じコードを繰り返し実行するタイプのマイクロベンチマークなのでキャッシュミスは少ないです。&lt;/p&gt;

&lt;p&gt;因みにそれぞれの列はこういう意味だそうです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ir -&amp;gt; Total Instructions&lt;/li&gt;
&lt;li&gt;I1mr -&amp;gt; Level 1 I-Cache misses&lt;/li&gt;
&lt;li&gt;ILmr -&amp;gt; Last Level I-Cache misses&lt;/li&gt;
&lt;li&gt;Dr -&amp;gt; Total Memory Reads&lt;/li&gt;
&lt;li&gt;D1mr -&amp;gt; Level 1 D-Cache read misses&lt;/li&gt;
&lt;li&gt;DLmr -&amp;gt; Last Level D-cache read misses&lt;/li&gt;
&lt;li&gt;Dw -&amp;gt; Total Memory Writes&lt;/li&gt;
&lt;li&gt;D1mw -&amp;gt; Level 1 D-Cache write misses&lt;/li&gt;
&lt;li&gt;DLmw -&amp;gt; Last Level D-cache write misses&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;--sort&lt;/code&gt; オプションでどの列をみるのか指定出来るようです。全メモリアクセスのミスレートを見てみましょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10 --sort dr


Profiling kappa_lisp with cachegrind...

Total Memory Accesses...800,082,686	

Total L1 I-Cache Misses...100,083 (0%)	
Total LL I-Cache Misses...420 (0%)	
Total L1 D-Cache Misses...4,321,895 (0%)	
Total LL D-Cache Misses...7,721 (0%)	

 Ir  I1mr ILmr  Dr  D1mr DLmr  Dw  D1mw DLmw
0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx
-----------------------------------------------------------------------
0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get
-----------------------------------------------------------------------
0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx
-----------------------------------------------------------------------
0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval
-----------------------------------------------------------------------
0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr
-----------------------------------------------------------------------
0.03 0.02 0.05 0.04 0.04 0.00 0.02 0.06 0.05 ???:eval::feval
-----------------------------------------------------------------------
0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やっぱりハッシュテーブル関連が重い…。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;私にとっては薮蛇にκLispの実装の筋が悪いことが分かったりしてショックでしたがまあ、簡単にプロファイルをとれるツールを紹介しました。&lt;/p&gt;

&lt;p&gt;Rustで高速なアプリケーションを作りたい方、利用してみては如何でしょうか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>高速な継続ライブラリに向けて</title>
      <link>/slide/kousokunakeizokuraiburarinimukete/</link>
      <pubDate>Sun, 08 May 2016 21:26:32 +0900</pubDate>
      
      <guid>/slide/kousokunakeizokuraiburarinimukete/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 高速な継続ライブラリに向けて
----------------------
[継続勉強会](http://connpass.com/event/28150/) 2016-05-22
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

# 継続欲しい
-----------

* 色々な場面で便利
* Schemeで使い回してるのうらやましい
* Common Lispでも使いたい
* 現実には限定継続が欲しい
  +  Common Lispには大域脱出はある


# 限定継続を使う例
-----------------
## 非同期プログラミング

* コールバック形式だと厳しい
* 限定継続を使うと綺麗に書き直せる


# 限定継続を使う例
-----------------
## ゲームのコルーチン

* 複数のオブジェクトを制御するのにコルーチンが欲しい
* cf [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)


# 限定継続を使う例
-----------------
## do記法

* モナドのdo記法は限定継続を使って実装出来る
* [Operational monad in scheme](http://www.slideshare.net/yuichinishiwaki/operational-monad-in-scheme)



# Common Lispでの限定継続の実現
---------------

1. 仕様に入れてもらう
2. 処理系に手を入れる
3. ユーザレベルで(限定)継続ライブラリを作る
   + 柔軟なCommon Lispでは可能


# CPS変換
---------

* (限定)継続の実現方法の1つ
  + スタックを切り取る方式とかもある
* 機械的にも出来る
* グローバルな変換なのとプリミティブな式しか書けないでコンパイラ内部でやることが多い
  + 継続関係なしに中間形式として採用されることが多い
* 関数定義/呼び出し以外にも諸々の構文とかに対しても定義が必要


# CPS変換
----------

Q. Common Lispだといくつの構文に対して定義が必要?

1. 1つ
2. 26つ
3. 42つ
4. 無数



# CPS変換
----------

A. 26つ (スペシャルフォーム25+funcall)


# Common Lispのプリミティブ
--------------------------

* スペシャルフォームと呼ばれる
* 仕様で25個定められている
* [CLHS: Section 3.1.2.1.2.1](http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm)
* この中に関数定義だとか例外だとかは入っていない
  + マクロで定義されている


# マクロ
--------

* 構文木 to 構文木(S式to S式)変換器( = 普通のLispの関数)
* 新しい構文を作れる
* CPS変換は?????


# `macroexpand`
-------------

* [CLHS: Function MACROEXPAND, MACROEXPAND-1](http://clhs.lisp.se/Body/f_mexp_.htm)
* マクロを手動展開する関数
* 雑にいうと普段pre-orderなマクロ展開をin-orderやpost-orderにする時に使う
* 本来はあまり使いたくない
  + 処理系の展開器に任せた方が間違いが少ない
* これでマクロを排したプリミティブのCommon Lispの構文木にアクセス出来る


# cl-cont
---------

* 上記のことを全てやったライブラリ
* デファクトというか唯一のライブラリ
* [Common Lispで限定継続と遊ぶ | κeenのHappy Hacκing Blog](http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/)


&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;「shift/resetがわからない時にあげる声」&lt;/p&gt;&amp;mdash; かず(原材料に小麦粉を含む) (@kazzna) &lt;a href=&#34;https://twitter.com/kazzna/status/674026894602309632&#34;&gt;2015年12月8日&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# cl-contの使用例

``` common-lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```


# cl-contの使用例

``` common-lisp
(FUNCALL
 (LAMBDA (&amp;OPTIONAL #:G542 &amp;REST #:G543)
   (DECLARE (IGNORABLE #:G542))
   (DECLARE (IGNORE #:G543))
   (FUNCALL
    (LAMBDA (&amp;OPTIONAL #:G544 &amp;REST #:G545)
      (DECLARE (IGNORABLE #:G544))
      (DECLARE (IGNORE #:G545))
      (FUNCALL (LAMBDA (K) (FUNCALL K 1))
               (LAMBDA (&amp;OPTIONAL #:G546 &amp;REST #:G547)
                 (DECLARE (IGNORABLE #:G546))
                 (DECLARE (IGNORE #:G547))
                 (FUNCALL (CL-CONT::FDESIGNATOR-TO-FUNCTION/CC #:G542) #&#39;VALUES
                          #:G544 #:G546))))
    1))
 #&#39;+)
```



# cl-contへの不満
-----------------

* 遅い
* lambda多い。
  + 多分コンパイラと相性が悪い
* lambda禁止おじさんと分かりあえる


# cl-fast-cont


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# cl-fast-cont
--------------

* [KeenS/cl-fast-cont: faster partial contiuation library of common lisp](https://github.com/KeenS/cl-fast-cont)
* とりあえずレポジトリ作っただけ
* 完成させたい…


# アプローチ1
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# SSA使う
---------

* CPSと等価
* だけどSSAだったらlambda出てこない
* Common Lispならgotoあるしいけるんじゃね？


```common-lisp
(let (x y z)
 (tagbody
    (setq x 1)
  :call/cc
    (setq y 1)
    (setq z (+ x y))))
```



# 問題
-------

* ネイティブスタックとは別に自分でスタック作らないといけない
  + 例外とかでスタック巻き戻されるとつらい
* gotoのタグをtagbodyの外に持ち出せない(=継続を外に持ち出せない)
* 変数を準備するのが面倒orパフォーマンスに影響しそう
* そもそもtagbodyそこまで柔軟じゃなかった
* 関数が消し飛ぶ


# アプローチ2
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# SSA+CPS
---------

* SSAとCPSを組み合わせる
* 基本はSSA
* スタックを使う/継続が必要な所でだけCPS

# 問題
-------

* SSAの部分意味なくね？
* そもそも継続を取り出すのが目的なので関係ない所で変換しても意味がない


# アプローチ3
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Selective CPS
----------------

* 継続が必要な部分でのみ変換
* 2 pass transformation
* [A Selective CPS Transformation](http://www.sciencedirect.com/science/article/pii/S1571066104809691)


```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    (+ 1 (call/cc
          (lambda (k)
            (funcall k y))))))

```



```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    (+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```



```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    @(+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```



```common-lisp
(with-call/cc
  @(let ((x 3) y)
    (setq y (* x x))
    @(+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```


# そもそもCommon Lispのつらい話
-------------------------------
* セマンティクスが動的
  + catch, block, tagbody
  + special variable
  + 変換は静的なのでどう頑張っても追い付かない
* multiple valueが面倒



# ダイナミック!!
----------------

``` common-lisp
(block name
 (let ((f
        (lambda (x) (return-from name x))))
   (with-call/cc
       (funcall
        f
        (call/cc
         (lambda (k)
           (funcall k 2)))))))
```


# スペシャル変数
---------------

* Common Lispにはレキシカルスコープとダイナミックスコープ両方ある
* CPS変換すると継続の全てがスコープ下に入る
  + 関数の呼び出し関係が木だったのが線型になる
  + ダイナミックスコープだと困る

![CPS前のAST](/images/cps/pre-cps.png)



![CPS後のAST](/images/cps/post-cps.png)



```
(defvar *x* 1)
(with-call/cc
  (progn
    (let ((*x* 2))
      (call/cc ..)
      (format t &#34;~a~%&#34; *x*)) ; *x* = 2
    (format t &#34;~a~%&#34; *x*))) ; *x* = 1

```



```
(defvar *x* 1)
(with-call/cc
  (progn
    (let ((*x* 2))
      (...
       (lambda (ignore)
         ((lambda (ignore)
            (format t &#34;~a~%&#34; *x*)) ; *x* = 2!!
          (format t &#34;~a~%&#34; *x*))))))) ; *x* = 1
```


# 多値
------

* Common Lispの多値はGoと違って無視出来る
* 変換が空気読む必要がある
* 下手するとプログラムを壊す
  1. 本当は多値を返してるのに変換で無視された
  2. 意図的に無視してるのに変換で加えられた


# 関数定義と引数の数
-----------------

* **Selective** CPS
* 関数をCPS変換するときとしない時がある
* 呼び出す時にどっちか分かんなくね？
  1. 統一的に変換してしまう
  2. Selectiveに変換して関数にメタデータつける

-&gt; まだ決めきれてない


# パフォーマンス
----------------


&lt;!-- .slide: class=&#34;center&#34; --&gt;


# フィボナッチ数列
-----------------
* とりえあずのフィボナッチ数列で計測
  + Full CPS変換に割と不利
  + 何も考えずにライブラリを使うとこうなるよって例
* Selective CPSは何もしない=普通の定義と同じ



```common-lisp
(defun fib (n)
  (if (&lt;= n 1)
      1
      (+ (fib (- n 1)) (fib (- n 2)))))
```

``` common-lisp
(defun/cc fib-cont (n)
  (if (&lt;= n 1)
      1
      (+ (fib-cont (- n 1)) (fib-cont (- n 2)))))
```


# Selective


```
Evaluation took:
  1.517 seconds of real time
  1.516000 seconds of total run time (1.516000 user, 0.000000 system)
  99.93% CPU
  4,388,993,782 processor cycles
  0 bytes consed
```


# Full

```
Evaluation took:
  18.347 seconds of real time
  18.576000 seconds of total run time (18.248000 user, 0.328000 system)
  [ Run times consist of 1.396 seconds GC time, and 17.180 seconds non-GC time. ]
  101.25% CPU
  53,149,416,888 processor cycles
  22,922,853,904 bytes consed
```

# コルーチン
------------

* そこまでFull CPSに不利じゃない
* 割と実用しそうな例
* Selective CPSは少しだけラムダが少ない


# Selective

``` common-lisp
(let (c)
  (setf c ((lambda ()
             (write-line &#34;in thread A 1&#34;)
             (lambda ()
              (write-line &#34;in thread A 2&#34;)
              (lambda ()
                (write-line &#34;in thread A 3&#34;))))))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```



# full

```common-lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```

# Selective

```
Evaluation took:
  0.905 seconds of real time
  0.904000 seconds of total run time (0.904000 user, 0.000000 system)
  99.89% CPU
  2,617,396,241 processor cycles
  0 bytes consed

```


# full

```
Evaluation took:
  1.272 seconds of real time
  1.272000 seconds of total run time (1.272000 user, 0.000000 system)
  100.00% CPU
  3,681,362,466 processor cycles
  0 bytes consed
```


# まとめ
--------

* 限定継続便利だよ
* マクロを使えばCPS変換で限定継続実装出来るよ
* でもパフォーマンや言語の問題もあるよ
* Selective CPSを使えばパフォーマンスの問題解決出来るよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>RustでベアメタルRaspberry PiのLチカ</title>
      <link>/blog/2016/05/04/rustdebeametaruraspberry_pinolchika</link>
      <pubDate>Wed, 04 May 2016 11:43:26 +0900</pubDate>
      
      <guid>/blog/2016/05/04/rustdebeametaruraspberry_pinolchika</guid>
      <description>

&lt;p&gt;κeenです。GWもくもく会で机の片隅で埃被ってたRSPiのベアメタルを触ってみたのでその成果報告を。
ベアメタルについて知らない人でも読めるように書きます。そしてアセンブラもCも出てきませんし、半田付けも必要ありません。
Rustしか使いません。&lt;/p&gt;

&lt;p&gt;Rustは分かるけどLチカは全く知らない、けど興味のある方は是非読んでみて下さい。&lt;/p&gt;

&lt;h1 id=&#34;ベアメタルって&#34;&gt;ベアメタルって？&lt;/h1&gt;

&lt;p&gt;普段我々が使っているパソコンはOSの上で動いています。
OSはざっくりいうとハードウェアへのアクセスを抽象化し、プロセスという単位でプログラムの実行を分離します。
ベアメタルはそのOSがない状態、ハードウェアの初期化やプロトコルなどは自分でやるしメモリ管理だとかも自分でやる環境です。
丁度ハードウェアが抽象化されてなくて機械が生で見えているようなのでこう呼ぶようです。&lt;/p&gt;

&lt;p&gt;OSがないのは中々イメージつきづらいですが、標準出力なんてものはないのでHello Worldも動きませんしメモリも仮想化されていないのでmallocも発効出来ません。
さらにはスタックとヒープみたいな区別もOSが与えてくれるものなので、自分で作らない限りスタック領域も使えません。
自分で書いたプログラムが唯一走るプログラムなのでプロセスの感覚でプログラムを終了させてはいけません。&lt;/p&gt;

&lt;p&gt;なんでそんな環境でプログラムしたいかというといくつかモチベーションがありそうです。1つはOSそのものを作ってみたい人が練習がてら。
もう1つにはOSが動かないような小さな環境だとそれしか選択肢がない。&lt;/p&gt;

&lt;p&gt;RSPiの場合はOSが動くので選択肢がないという訳ではないのですが私はそういう小さなデバイスを持っていないので実験台としてRSPiを使いました。&lt;/p&gt;

&lt;p&gt;さて、Hello Worldすら動かないシステムでの入門的なプログラムは信号のON/OFFを切り替えてあげるだけで出来るLEDをチカチカさせるプログラムという訳です。&lt;/p&gt;

&lt;h1 id=&#34;raspberry-pi&#34;&gt;Raspberry Pi&lt;/h1&gt;

&lt;p&gt;言わずと知れた名刺サイズの小型コンピュータ、Raspberry Piです。
Raspberry Piと一口にいっても&lt;a href=&#34;https://ja.wikipedia.org/wiki/Raspberry_Pi&#34;&gt;色々種類がある&lt;/a&gt;のですが、私が持っているのはRaspberry Pi 1 Model Bの後期モデルです(Raspberry Pi 1 Model Bは販売途中で仕様がアップグレードしてメモリが増えた)。&lt;/p&gt;

&lt;p&gt;ARMv6アーキテクチャのチップ(ARM1176JZF-S)で動いていて、SDカードから起動します。特別なライターなどは必要なく、PCからSDカードに書き込んでRSPiに挿して電源を繋ぐだけで簡単に起動出来る訳です。
さらに配線とかが必要なGPIOに加えてボードにLEDもついているので物理の知識必要なくて今回のようにLチカだけをやりたいなら手軽に遊べます。&lt;/p&gt;

&lt;h1 id=&#34;準備&#34;&gt;準備&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 1 Model B&lt;/li&gt;
&lt;li&gt;USB - micro USBケーブル(Raspberry Piへの給電用)&lt;/li&gt;
&lt;li&gt;SDカード(FAT32でフォーマットしておく)&lt;/li&gt;
&lt;li&gt;GCCのARM向けクロスコンパイラ(後述)&lt;/li&gt;
&lt;li&gt;RustのARM向けクロスコンパイラ(後述)&lt;/li&gt;
&lt;li&gt;ブートローダ(後述)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gccのクロスコンパイラ&#34;&gt;GCCのクロスコンパイラ&lt;/h2&gt;

&lt;p&gt;GCCのクロスコンパイラは&lt;a href=&#34;https://launchpad.net/gcc-arm-embedded&#34;&gt;GCC ARM Embedded in Launchpad&lt;/a&gt;というプロジェクトがあるので簡単に用意出来ます。Ubuntu環境なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install gcc-arm-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストールできます。どうやらRSPiには不動小数点数計算ユニット(FPU)がついているようなのでhf(Hardware Float)で大丈夫みたいです。
HomebrewやPacmanにもパッケージはあるようです。&lt;/p&gt;

&lt;h2 id=&#34;rustのクロスコンパイラ&#34;&gt;Rustのクロスコンパイラ&lt;/h2&gt;

&lt;p&gt;次にRustのクロスコンパイラですが、&lt;a href=&#34;https://github.com/brson/multirust&#34;&gt;multirust&lt;/a&gt;を使うと簡単にインストール出来ます。今回はunstable機能も使うのでnightlyコンパイラを使います。
因みに私が昔インストールしたmultirustだと古くて以下のコマンドが実行出来なかったので出来ない方はmultirustをアップデートして試してみて下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# インストール可能なターゲットを確認
$ multirust list-available-targets nightly
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-linux-gnu
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
# インストール
$ multirust add-target nightly arm-unknown-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ブートローダ&#34;&gt;ブートローダ&lt;/h2&gt;

&lt;p&gt;まず、ブートローダが何をするものなのかから説明しましょう。興味がない人は飛ばして下さい。&lt;/p&gt;

&lt;h3 id=&#34;説明&#34;&gt;説明&lt;/h3&gt;

&lt;p&gt;Raspberry PiにはCPUとGPUが両方ついているのでやや面倒です。&lt;/p&gt;

&lt;p&gt;CPU/GPUは電源がONになってすぐは何の機能もない、ただの命令を実行する機械です。メモリにすらアクセス出来ません。RSPiにSDカードを挿したところでSDカードのプロトコルを喋らないとそこに書いてあるプログラムが読めません。
SDカードのプロトコルを喋るプログラム(BIOS)は、RSPiに組込みで入っています。これは普段我々が使うメモリ(RAM)とは別の場所(ROM)に入っています。&lt;/p&gt;

&lt;p&gt;最初はGPUがそいつを起動し、(この時点ではCPUは起動してない)SDカードを読みにいきます。名前決め打ちでbootcode.binという名前のプログラムを、RAMではなくGPU(のL2キャッシュ)に直接ロードして実行します(メモリはまだ使えません)。
GPUのキャッシュは非常に小さいのでbootcode.binは小さなプログラムでないといけません。&lt;/p&gt;

&lt;p&gt;bootcode.binはRAMを有効にしてstart.elfをRAMに読み込み、GPUがそれを実行します。start.elfはRAMを使えるのである程度大きくても構いません。&lt;/p&gt;

&lt;p&gt;start.elfはconfig.txt、cmdline.txtとkernel.imgを読みにいき、kernel.imgを0x8000番地のメモリに配置します。そしてconfgやcmdlineに基いてCPUを設定してkernel.imgに引数を渡しつつ実行します。&lt;/p&gt;

&lt;p&gt;このkernel.imgは普段はLinuxカーネルなどのカーネル、今回は我々が作るLチカのプログラムです。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://kernhack.hatenablog.com/entry/2014/01/11/102237&#34;&gt;Raspberry Piのブートプロセスメモ - φ(・・*)ゞ ｳｰﾝ　カーネルとか弄ったりのメモ&lt;/a&gt;
昔はloader.binもあったようですが今はなくて大丈夫なようです。&lt;/p&gt;

&lt;h3 id=&#34;インストール&#34;&gt;インストール&lt;/h3&gt;

&lt;p&gt;bootcode.bin, start.elfは&lt;a href=&#34;https://github.com/raspberrypi/firmware/tree/master/boot&#34;&gt;こちら&lt;/a&gt;から入手出来ます。config.txtとcmdline.txtはなくていいようです。&lt;/p&gt;

&lt;p&gt;こいつらはSDカードに放り込んでおきます。&lt;/p&gt;

&lt;h1 id=&#34;環境確認&#34;&gt;環境確認&lt;/h1&gt;

&lt;p&gt;まずはコンパイラツールチェーンが正常に動くか確認しましょう。
以下にrustコードを。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(lang_items, asm)]
#![crate_type = &amp;quot;staticlib&amp;quot;]
#![no_std]

#[no_mangle]
pub extern fn main() {
    loop{}
}


#[no_mangle]
pub extern fn _sbrk() {}
#[no_mangle]
pub extern fn _exit() {}
#[no_mangle]
pub extern fn _kill() {}
#[no_mangle]
pub extern fn _getpid() {}


#[lang = &amp;quot;eh_personality&amp;quot;]
extern fn eh_personality() {}

#[lang = &amp;quot;panic_fmt&amp;quot;]
extern fn panic_fmt() {}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、今回作るのは &lt;code&gt;#![crate_type = &amp;quot;staticlib&amp;quot;]&lt;/code&gt; を使って静的リンクライブラリを作れと指定しています。そして &lt;code&gt;#[no_mangle] pub extern fn main() {&lt;/code&gt; でC言語と同じような規則でmain関数を定義する(アセンブラからmain関数を実行出来るようにする)と指定しています。
ベアメタル環境なのでファイルだとか諸々のものはなく、stdを使えないので &lt;code&gt;#![no_std]&lt;/code&gt; を指定してstdを使わずにcoreライブラリを使うようにしました。その代わり&lt;code&gt;#[lang = &amp;quot;eh_personality&amp;quot;] extern fn eh_personality() {}&lt;/code&gt; と &lt;code&gt;#[lang = &amp;quot;panic_fmt&amp;quot;] extern fn panic_fmt() {}&lt;/code&gt; を実装してあげないといけません(この実装はあまりよろしくないのですが今回はとりあえずコンパイルが通るようにということでこうしてます)。&lt;/p&gt;

&lt;p&gt;そしてよく分かってないのですがRustが &lt;code&gt;_sbrk&lt;/code&gt; 、 &lt;code&gt;_exit&lt;/code&gt; 、 &lt;code&gt;_kill&lt;/code&gt; 、 &lt;code&gt;_getpid&lt;/code&gt; のシンボルを捜しにいくのでとりあえずスタブを挿してます。&lt;/p&gt;

&lt;p&gt;no_mangle, no_std, lang_itemsについて詳しくは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/&#34;&gt;ドキュメント&lt;/a&gt;をご覧下さい。
&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/ffi.html&#34;&gt;他言語関数インターフェイス&lt;/a&gt;、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/no-stdlib.html&#34;&gt;No stdlib&lt;/a&gt;、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/lang-items.html&#34;&gt;言語アイテム&lt;/a&gt;あたりが参考になるかと思います。&lt;/p&gt;

&lt;p&gt;以下のようにコンパイル出来ればRustはOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustc --target arm-unknown-linux-gnueabihf --emit=obj test.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、elfファイルを作ります。これは以下のコマンドで出来ます。Cのクロスコンパイラを使っていますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles test.o -o kernel.elf
/usr/lib/gcc/arm-none-eabi/4.9.3/../../../arm-none-eabi/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000008000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-mで始まるオプションはRaspberry Piのチップ固有の指定、 -nostartfiles はベアメアルで動かすのに必要な指定ですね。&lt;/p&gt;

&lt;p&gt;最後にelfファイルからimgファイルを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arm-none-eabi-objcopy kernel.elf -O binary kernel.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私もよく分かってないのですがobjファイルが不完全なバイナリファイル、elfが完全なバイナリファイル、imgがelfを実際のメモリに展開した時のものそのままなんですかね。
逆にいうとOSのない環境で動かすには生のimgが欲しいけどそれを作るのは難しいから一旦elfを作ってそこからimgを生成している？&lt;/p&gt;

&lt;p&gt;さて、とりあえずここまで来れば環境は整いました。あとはプログラムを書くだけです。&lt;/p&gt;

&lt;h1 id=&#34;lチカ&#34;&gt;Lチカ&lt;/h1&gt;

&lt;p&gt;RSPiにくっついているLEDはデバイスとしてはGPIOのように見えるみたいです。
そしてGPIOはMemory Mapped IO、特定の位置のメモリを読み書きすることでデバイスをいじれるようになってるみたいです。
このセットアップは誰がやったんだって気になりますがBIOSなんですかね。&lt;/p&gt;

&lt;p&gt;さて、この「特定の位置のメモリ」ですが、Raspberry Pi 1だと &lt;code&gt;0x20200000&lt;/code&gt; から始まるアドレス、のようです。2だと &lt;code&gt;3F200000&lt;/code&gt; のよう。&lt;/p&gt;

&lt;p&gt;そして0x20200000からいくつかの32bitレジスタが配列のように並んでいる訳ですがこれまたRSPi+やRSP 2とRSPi 1はLEDに対応するレジスタがやや違うようです。&lt;/p&gt;

&lt;p&gt;面倒なのでコピペで済ませると(私はCのコードからRustに移植しました。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Raspberry Pi2
//pub const GPIO_BASE: u32 = 0x3F200000;
// other
pub const GPIO_BASE: u32 = 0x20200000;



// Raspberrp Pi+ or Raspberry Pi2
//pub const LED_GPFSEL: isize   = GPIO_GPFSEL4;
//pub const LED_GPFBIT: i32     = 21;
//pub const LED_GPSET: isize    = GPIO_GPSET1;
//pub const LED_GPCLR: isize    = GPIO_GPCLR1;
//pub const LED_GPIO_BIT: isize = 15;
//  other
pub const LED_GPFSEL: isize = GPIO_GPFSEL1;
pub const LED_GPFBIT: i32 = 18;
pub const LED_GPCLR: isize = GPIO_GPCLR0;
pub const LED_GPSET: isize = GPIO_GPSET0;
pub const LED_GPIO_BIT: i32 = 16;

pub const GPIO_GPFSEL0: isize   = 0;
pub const GPIO_GPFSEL1: isize   = 1;
pub const GPIO_GPFSEL2: isize   = 2;
pub const GPIO_GPFSEL3: isize   = 3;
pub const GPIO_GPFSEL4: isize   = 4;
pub const GPIO_GPFSEL5: isize   = 5;
pub const GPIO_GPSET0: isize    = 7;
pub const GPIO_GPSET1: isize    = 8;
pub const GPIO_GPCLR0: isize    = 10;
pub const GPIO_GPCLR1: isize    = 11;
pub const GPIO_GPLEV0: isize    = 13;
pub const GPIO_GPLEV1: isize    = 14;
pub const GPIO_GPEDS0: isize    = 16;
pub const GPIO_GPEDS1: isize    = 17;
pub const GPIO_GPREN0: isize    = 19;
pub const GPIO_GPREN1: isize    = 20;
pub const GPIO_GPFEN0: isize    = 22;
pub const GPIO_GPFEN1: isize    = 23;
pub const GPIO_GPHEN0: isize    = 25;
pub const GPIO_GPHEN1: isize    = 26;
pub const GPIO_GPLEN0: isize    = 28;
pub const GPIO_GPLEN1: isize    = 29;
pub const GPIO_GPAREN0: isize   = 31;
pub const GPIO_GPAREN1: isize   = 32;
pub const GPIO_GPAFEN0: isize   = 34;
pub const GPIO_GPAFEN1: isize   = 35;
pub const GPIO_GPPUD: isize     = 37;
pub const GPIO_GPPUDCLK0: isize = 38;
pub const GPIO_GPPUDCLK1: isize = 39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうなります(cfgを使ってないです。ごめんなさい。)。&lt;/p&gt;

&lt;p&gt;次にLチカですが、
LEDに対応するGPIOをwriteに初期化する→ループ{LEDに対応するGPIOをセットする → スリープ → LEDに対応するGPIOをクリアする → スリープ}&lt;/p&gt;

&lt;p&gt;のプログラムを書きます。&lt;/p&gt;

&lt;p&gt;色々試したのですが簡単なプログラムだと最適化で消えてしまうので消えないように工夫する必要があります。&lt;/p&gt;

&lt;p&gt;スリープはとりあえずタイマーを使わずに空ループを回すのですが、ループの中身は空インラインアセンブラを使うと消えないようです。&lt;/p&gt;

&lt;p&gt;また、メモリへの書き込みは&lt;a href=&#34;https://doc.rust-lang.org/core/intrinsics/&#34;&gt;intrinsic&lt;/a&gt;の&lt;a href=&#34;https://doc.rust-lang.org/core/intrinsics/fn.volatile_store.html&#34;&gt;volatile_store&lt;/a&gt;を使います。&lt;/p&gt;

&lt;p&gt;ということでコードは以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(lang_items, asm, core_intrinsics)]
#![crate_type = &amp;quot;staticlib&amp;quot;]
#![no_std]

use core::intrinsics::volatile_store;

// Raspberry Pi2
//pub const GPIO_BASE: u32 = 0x3F200000;
// other
pub const GPIO_BASE: u32 = 0x20200000;



// Raspberrp Pi+ or Raspberry Pi2
//pub const LED_GPFSEL: isize   = GPIO_GPFSEL4;
//pub const LED_GPFBIT: i32     = 21;
//pub const LED_GPSET: isize    = GPIO_GPSET1;
//pub const LED_GPCLR: isize    = GPIO_GPCLR1;
//pub const LED_GPIO_BIT: isize = 15;
//  other
pub const LED_GPFSEL: isize = GPIO_GPFSEL1;
pub const LED_GPFBIT: i32 = 18;
pub const LED_GPCLR: isize = GPIO_GPCLR0;
pub const LED_GPSET: isize = GPIO_GPSET0;
pub const LED_GPIO_BIT: i32 = 16;

pub const GPIO_GPFSEL0: isize   = 0;
pub const GPIO_GPFSEL1: isize   = 1;
pub const GPIO_GPFSEL2: isize   = 2;
pub const GPIO_GPFSEL3: isize   = 3;
pub const GPIO_GPFSEL4: isize   = 4;
pub const GPIO_GPFSEL5: isize   = 5;
pub const GPIO_GPSET0: isize    = 7;
pub const GPIO_GPSET1: isize    = 8;
pub const GPIO_GPCLR0: isize    = 10;
pub const GPIO_GPCLR1: isize    = 11;
pub const GPIO_GPLEV0: isize    = 13;
pub const GPIO_GPLEV1: isize    = 14;
pub const GPIO_GPEDS0: isize    = 16;
pub const GPIO_GPEDS1: isize    = 17;
pub const GPIO_GPREN0: isize    = 19;
pub const GPIO_GPREN1: isize    = 20;
pub const GPIO_GPFEN0: isize    = 22;
pub const GPIO_GPFEN1: isize    = 23;
pub const GPIO_GPHEN0: isize    = 25;
pub const GPIO_GPHEN1: isize    = 26;
pub const GPIO_GPLEN0: isize    = 28;
pub const GPIO_GPLEN1: isize    = 29;
pub const GPIO_GPAREN0: isize   = 31;
pub const GPIO_GPAREN1: isize   = 32;
pub const GPIO_GPAFEN0: isize   = 34;
pub const GPIO_GPAFEN1: isize   = 35;
pub const GPIO_GPPUD: isize     = 37;
pub const GPIO_GPPUDCLK0: isize = 38;
pub const GPIO_GPPUDCLK1: isize = 39;

#[no_mangle]
pub extern fn main() {
    // GPIO_BASEを符号無し32bit整数を指すポインタにキャストする
    let gpio = GPIO_BASE as *const u32;
    // offsetを使うことでCの配列のようにポインタの何番地か先のメモリを指せる
    let init   = unsafe {gpio.offset(LED_GPFSEL) as *mut u32};
    let led_on = unsafe { gpio.offset(LED_GPSET) as *mut u32 };
    let led_off = unsafe { gpio.offset(LED_GPCLR) as *mut u32 };

    // LEDのGPIOを書き込みに設定
    unsafe{
        volatile_store(init, *(init) | 1 &amp;lt;&amp;lt; LED_GPFBIT);
    }

    loop {
        // LEDをOFFにする
        unsafe {
            volatile_store(led_off, 1 &amp;lt;&amp;lt; LED_GPIO_BIT);
        }
        // 適当な長さbusy loopで時間を空ける
        for _ in 1..500000 {
            unsafe { asm!(&amp;quot;&amp;quot;); }
        }

        // LEDをONにする
        unsafe {
            volatile_store(led_on, 1 &amp;lt;&amp;lt; LED_GPIO_BIT);
        }
        // また適当な長さ空ける
        for _ in 1..500000 {
            unsafe { asm!(&amp;quot;&amp;quot;); }
        }
    }
}


#[no_mangle]
pub extern fn _sbrk() {}
#[no_mangle]
pub extern fn _exit() {}
#[no_mangle]
pub extern fn _kill() {}
#[no_mangle]
pub extern fn _getpid() {}


#[lang = &amp;quot;eh_personality&amp;quot;]
extern fn eh_personality() {}

#[lang = &amp;quot;panic_fmt&amp;quot;]
extern fn panic_fmt() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをkernel.rsとして保存し、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustc  -O --target arm-unknown-linux-gnueabihf --emit=obj kernel.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でコンパイルします。どうやら使っていないのにrustが余計なシンボルを付けるようで、-Oをつけてそいつらをoptimize outさせないとコンパイルが通りませんでした。
この辺、コンパイラのバージョンに依存しそうで怖いですね。&lt;/p&gt;

&lt;p&gt;さて、あとは先程と同じく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles kernel.o -o kernel.elf
$ arm-none-eabi-objcopy kernel.elf -O binary kernel.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でイメージを作ってあげます。&lt;/p&gt;

&lt;p&gt;そしたらこのkernel.imgをSDカードに放り込みます。&lt;/p&gt;

&lt;p&gt;SDカードの中身はこうなっている筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls  /media/kim/6F6F-DCD9
bootcode.bin  kernel.img  start.elf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このSDカードをRSPiに挿して、電源を繋いであげるとLEDがすごい勢いでチカチカする筈です。そうなったら成功です。おめでとうございます。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/RaspPi&#34;&gt;ここ&lt;/a&gt;に置いておきます。とはいってもそのままではなくてCargo化したりMakefileを書いたり色々しています。&lt;/p&gt;

&lt;p&gt;今回の作業をするにあたって参考にした資料のURLを挙げておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valvers.com/open-software/raspberry-pi/step01-bare-metal-programming-in-cpt1/&#34;&gt;Step01 – Bare Metal Programming in C Pt1 – Valvers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valvers.com/open-software/raspberry-pi/step02-bare-metal-programming-in-c-pt2/&#34;&gt;Step02 – Bare Metal Programming in C Pt2 – Valvers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.thiago.me/raspberry-pi-bare-metal-programming-with-rust/&#34;&gt;Raspberry Pi Bare Metal Programming with Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.bobuhiro11.net/2014/01-13-baremetal.html&#34;&gt;piでベアメタルプログラミング - bobuhiro11&amp;rsquo;s diary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>LXDがリリースされたらしい</title>
      <link>/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii</link>
      <pubDate>Thu, 14 Apr 2016 22:51:20 +0900</pubDate>
      
      <guid>/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii</guid>
      <description>&lt;p&gt;κeenです。頭痛い。LXDがリリースされたようなので1つ記事をば。
LXDはLinuxで動く軽量仮想化コンテナ、LXCのラッパでREST APIとCLIが提供されています。&lt;/p&gt;

&lt;p&gt;LXC、LXD共にUbuntuの開発元、Canonicalが開発しています。
LXCについては初期のDockerがバックエンドに使っていたので知名度もそこそこあるかと思いますが、
そのラッパであるLXDはこの度ようやく正式リリースされました。&lt;/p&gt;

&lt;p&gt;既にDockerがあるのになぜわざわざ新たにLXDを使うんだって気もしますが、対象とするレイヤーが違います。
Dockerはアプリケーションコンテナ、つまりアプリケーションを動かすためのプロセスより強い分離環境を提供するために使われますが
LXDはシステムコンテナ、つまり仮想マシンより軽い仮想化環境を提供します。
なのでファイルシステムはCopy on Writeしませんし一度終了したコンテナは破棄されず、再起動出来ます。
詳しくはここら辺に書いてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.stgraber.org/2016/03/11/lxd-2-0-blog-post-series-012/&#34;&gt;LXD 2.0: Blog post series [0/12] | Stéphane Graber&amp;rsquo;s website&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1つDockerとLXDの違いの分かりやすい例を出すと、それぞれのOpenStackでの立ち位置を見ると面白そうです。
Dockerは&lt;a href=&#34;https://wiki.openstack.org/wiki/Magnum&#34;&gt;OpenStack Magnum&lt;/a&gt;でOpenStack上で扱えますが、OpenStackのコンピュートノード &lt;strong&gt;上&lt;/strong&gt; で動作します。
一方LXDは&lt;a href=&#34;https://insights.ubuntu.com/2015/05/06/introduction-to-nova-compute-lxd/&#34;&gt;nova-compute-lxd&lt;/a&gt;でOpenStack上で扱えますが、 OpenStackのコンピュートノード &lt;strong&gt;として&lt;/strong&gt; 動作します。
なんだかんだ重いVMがコンテナのお陰で軽くなる訳です。そして勿論のこと、Docker in LXDなんかも出来るのでちゃんと共存出来ます。&lt;/p&gt;

&lt;p&gt;今のところUbuntu 14.04あるいは未来の16.04でリリースされているようです。Ubuntu 15.10をお使いの方は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add-apt-repository ppa:ubuntu-lxc/lxd-stable
apt-get update
apt-get dist-upgrade
apt-get install lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストール出来るようです(&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;マニュアル&lt;/a&gt;より)。
LXDはLXCのラッパでありながらもliblxcにしか依存しないのでlxc自体はインストールする必要はありません。&lt;/p&gt;

&lt;p&gt;さてこれでLXDがインストールされた訳ですが、LXDはコンテナなどのリソースを管理するデーモンとそのCLIから成ります。
CLIのコマンド名はなんと&lt;code&gt;lxc&lt;/code&gt;です。LXCのコマンド群が&lt;code&gt;lxc-*&lt;/code&gt;なので非常に勘違いしやすいですね。&lt;/p&gt;

&lt;p&gt;詳しいコマンド群は&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;マニュアル&lt;/a&gt;を読めばいいのですがそれだけだとお粗末なので多少紹介します。&lt;/p&gt;

&lt;p&gt;インストール直後は新規に作ったグループを今のログインセッションに反映させる必要があるので&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;newgrp lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする必要があります。その次は初期化が必要になります。&lt;code&gt;lxd init&lt;/code&gt;です。いくつか質問されますがデフォルトの回答を選んでいけば問題なさそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
Name of the storage backend to use (dir or zfs): zfs
error: The requested backend &#39;zfs&#39; isn&#39;t available on your system (missing tools).
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? yes
Address to bind LXD to (not including port): 0.0.0.0
Port to bind LXD to (8443 recommended): 
Invalid input, try again.

Port to bind LXD to (8443 recommended): 8443
Trust password for new clients: 
Again: 
Do you want to configure the LXD bridge (yes/no)? yes
Warning: Stopping lxd.service, but it can still be activated by:
  lxd.socket
LXD has been successfully configured.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntuでzfsが使えるのは16.04からなので15.10では使えませんでした。また、ブリッジのコンフィギュアにはウィザードが出てきます。&lt;/p&gt;

&lt;p&gt;これで初期化が終わり、コンテナを立ち上げる準備が出来ました。&lt;/p&gt;

&lt;p&gt;コンテナはイメージを元に立ち上げるのですが、今回はイメージはネット上のものから立ち上げます。
インストール時点でいくつかサーバが登録されているので名前で指定してあげるだけでよいようです。
他にイメージを使う方法はリモートのLXDをサーバとして使う、手動でファイルからインポートするなどがあるようです。&lt;/p&gt;

&lt;p&gt;ということでコンテナの立ち上げはこうです。折角なので未来のUbuntu 16.04を使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc launch ubuntu:16.04 future-ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドでビルトインの&amp;rdquo;Ubuntu&amp;rdquo;サーバにある16.04バージョンのイメージをfuture-ubuntuという名前のコンテナで立ち上げます。&lt;/p&gt;

&lt;p&gt;これでコンテナが立ち上がりました。確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc list
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
|     NAME      |  STATE  |              IPV4              |                     IPV6                     |    TYPE    | SNAPSHOTS |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
| future-ubuntu | RUNNING | 10.197.202.251 (eth0)          | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0         |
|               |         | 10.0.3.1 (lxcbr0)              |                                              |            |           |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにローカルにあるイメージも確認しましょう。インポートまで終わっているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc image list
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |                DESCRIPTION                |  ARCH  |   SIZE   |         UPLOAD DATE          |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
|       | 6cb0ba80a5fe | no     | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立ち上げたコンテナにログインしてみましょう。これはDockerをお使いの方は馴染があるんじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc exec future-ubuntu -- /bin/bash
root@future-ubuntu:~# lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu Xenial Xerus (development branch)
Release:	16.04
Codename:	xenial
root@future-ubuntu:~# exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと16.04になっているようです。&lt;/p&gt;

&lt;p&gt;コンテナの停止は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc stop future-ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。ちゃんと止まったか確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc list
+---------------+---------+------+------+------------+-----------+
|     NAME      |  STATE  | IPV4 | IPV6 |    TYPE    | SNAPSHOTS |
+---------------+---------+------+------+------------+-----------+
| future-ubuntu | STOPPED |      |      | PERSISTENT | 0         |
+---------------+---------+------+------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんとSTATEがSTOPPEDになってますね&lt;/p&gt;

&lt;p&gt;もう一度起動してみます&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc start future-ubuntu
sudo lxc list
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
|     NAME      |  STATE  |              IPV4              |                     IPV6                     |    TYPE    | SNAPSHOTS |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
| future-ubuntu | RUNNING | 10.197.202.251 (eth0)          | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0         |
|               |         | 10.0.3.1 (lxcbr0)              |                                              |            |           |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次はコンテナを削除します&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc stop future-ubuntu
sudo lxc delete future-ubuntu
sudo lxc list
+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
sudo lxc image list
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |                DESCRIPTION                |  ARCH  |   SIZE   |         UPLOAD DATE          |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
|       | 6cb0ba80a5fe | no     | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナが消えただけでイメージは残るんですね。&lt;/p&gt;

&lt;p&gt;さて、いかがでしょうか。軽量なVMと考えれば非常に手軽で中々面白いんじゃないでしょうか。
因みにコンテナとホスト間でのファイルのやりとりも簡単(&lt;code&gt;lxc file pull/push&lt;/code&gt;)なようなのでコンテナ内でコンパイラを動かしてホストにもってくるとかをすれば開発環境の隔離環境としても使えそうです。&lt;/p&gt;

&lt;p&gt;時間があればもう少し詳細に検証してみます。SNAPSHOTとかも試してみたかった。それでは今日はこの辺で。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>テストについて、Scalaと。</title>
      <link>/slide/tesutonitsuite_Scalato_/</link>
      <pubDate>Tue, 12 Apr 2016 22:31:51 +0900</pubDate>
      
      <guid>/slide/tesutonitsuite_Scalato_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# テストについて、Scalaと。
----------------------
サイバーエージェント アドテクスタジオ  
ScalaMeetUp テスト回

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
   + 基盤開発グループでScalaで基盤開発してます
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# Scalaのテスト
---------------

* ScalaTest
  + 機能豊富
  + 複数のテストスタイルを選べる
  + 他のフレームワークとの統合がある
* Specs2
  + 普通に使いやすい
* 他にもScalaCheck、JUnit、Gatlingなどなど


# ScalaTestのスタイルたち
-----------

* FunSuite
  + xUnitっぽいらしい
* FlatSpec
  + xUnitからBDDに移行した人向けらしい
* FunSpec
  + RSpecっぽいBDD用の


# ScalaTestのスタイルたち
-----------

* WordSpec
  + Specs2に似てる。
* FreeSpec
  + 何段にでもネスト出来る。自由。
* Spec
  + テスト=メソッド。速いらしい。


# ScalaTestのスタイルたち
-----------
* PropSpec
  + プロパティベースのテスト。ScalaCheckとの統合。
* FeatureSpec
  + シナリオテスト。

# その他の機能
-------------

* mockitoのシュガー
* Matcher DSL
* 複数のランナー（複数のツールとの統合）


# Axionのテスト
コード紹介を多めに
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 単体テスト
---------------

* 普通の単体テストはWordSpec
* ホーアの3つ組に基いて事前条件、コマンド、事後条件(不変条件)に分ける
  + 「{事前条件}が成り立つ時{コマンド}を実行し、停止するなら{事後条件(不変条件)}が成り立つ」の列挙
* [テストについて考えてみた | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/tesutonitsuitekangaetemita/)
* コマンドの実行と事後条件への表明を明確に分離
* テストの分け方に試行錯誤


# 事前条件
----------

* 基本的にはmockitoをフルに使う
* テストは並行に走るのでテストケース毎にモックを準備
* コンテキストの共有は基本的にはしない
  + 情報の局所性を上げて何をテストするかを理解しやすくする
  + 逆にノイズが乗ってわかりにくい？
* メソッドの実行に必要な引数と環境全てを構築する


# コマンドの実行
---------------

* 例外が起きないことだけ表明する
* 結果はvarに保存して外に持ち出す。


# 事後条件
----------

* コマンドを実行した結果に対する表明
* 環境に対する表明
  + 環境が変化した/しなかった
  + 依存オブジェクトのメソッドが呼ばれた/なかった


メソッド毎にテストケースをグルーピング

``` scala
&#34;Class#method&#34; when {
  &#34;precondition&#34; should {
    ...
    var ret: Type = null
    &#34;method invocation&#34; in {
      ret = ...
    }

    &#34;post conditions&#34; in {
      ...
    }
  }
}

```


# Tips
------

* エディタでテンプレートを用意しておくと楽
  + ensimeのテストテンプレートとか
* やや冗長でも頭を使わずに書ける/理解出来るテストを書く


# ユーティリ
---------------

* ユーティリティのテストはPropSpec
* ユーティリティ = 汎用的(文脈に依存しない)、副作用がない、小さい
  + まさにプロパティベースのテストに向く
* ほとんどGenerator Driven Test
  + 半分くらいScalaCheckの機能を使う
* 一部Tebale Driven Test
  + Generatorがコーナーケースを生成してくれない時がある


# 他のテスト
------------

* インテグレーションテスト/パフォーマンステストはGatling(の予定)
* Gatlingでエラーレート、パーセンタイル、レスポンスなどをテスト出来る
* パフォーマンステストは実行インスタンスを固定しないといけない問題が…
* シナリオテストはない(APIがReadのみなため)


# 他のテスト
---------------

* AxionはThriftプロトコルだがGatlingのAPIをいくつか実装すればGatlingを独自プロトコルに対応出来る
  + 実装量はほとんどない
  + 2~3個DSLを作るだけ
  + 簡単とはいってない(ドキュメントがないつらさ)
* Gatlingのおかげでパフォーマンスに対する表明やリクエスト毎のチェックなどが簡単
* そのうちノウハウを公開するかも？
  + 2.1.Xと2.2.XでAPIが違う問題も…


# まとめ
--------

* ScalaTestを紹介したよ
* ScalaTestの実用例を紹介したよ
* Gatlingについて紹介したよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Mirah関連ツールまとめ</title>
      <link>/blog/2016/04/04/mirahkanrentsu_rumatome</link>
      <pubDate>Mon, 04 Apr 2016 01:16:31 +0900</pubDate>
      
      <guid>/blog/2016/04/04/mirahkanrentsu_rumatome</guid>
      <description>

&lt;p&gt;κeenです。寝付けないのでMirah関連ツールについてまとめようかと。
とはいってもそんなにないのですが。Mirahについて知らない人は適当にググって下さい。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラ&#34;&gt;コンパイラ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mirah/mirah/releases&#34;&gt;Releases · mirah/mirah&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本家のものを使うべし&lt;/p&gt;

&lt;h1 id=&#34;開発支援&#34;&gt;開発支援&lt;/h1&gt;

&lt;h2 id=&#34;netbeansプラグイン&#34;&gt;NetBeansプラグイン&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/shannah/mirah-nbm&#34;&gt;shannah/mirah-nbm: Netbeans Module for Mirah&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このプラグインのためにパーサのAPIに変更を加える議論がされたりしていて恐らく現状一番まともに動くやつと思う。&lt;/p&gt;

&lt;h2 id=&#34;emacs&#34;&gt;Emacs&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/mirah-mode.el&#34;&gt;KeenS/mirah-mode.el:&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ruby-modeにやっつけで雑に機能を追加したやつ。コメントのハイライトにコーナーケース(&lt;code&gt;/*/*/**/*/*/&lt;/code&gt; みたいなの)があったり雑。
まあ、とりあえずそれっぽくは動く&lt;/p&gt;

&lt;h1 id=&#34;ビルドツール統合&#34;&gt;ビルドツール統合&lt;/h1&gt;

&lt;h2 id=&#34;gradle&#34;&gt;Gradle&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ysb33r/gradle-mirah-plugin&#34;&gt;ysb33r/gradle-mirah-plugin: Gradleplugin to compile Mirah source code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近作られたやつ。&lt;a href=&#34;https://github.com/KeenS/mirah_sample_gradle&#34;&gt;軽く使てみた&lt;/a&gt;ら簡単に動いたし良さげ。&lt;/p&gt;

&lt;h2 id=&#34;maven&#34;&gt;Maven&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mirah/maven-mirah-plugin&#34;&gt;mirah/maven-mirah-plugin: Plugin to compile Mirah source with Maven&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;公式サポートだし良さげ。&lt;/p&gt;

&lt;h1 id=&#34;その他&#34;&gt;その他&lt;/h1&gt;

&lt;h2 id=&#34;コードトランスレート&#34;&gt;コードトランスレート&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/captn3m0/java2mirah&#34;&gt;captn3m0/java2mirah: A java to mirah transpiler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;javaからMirahに変換してくれるツール。試したことはないけどそんなに期待はしてない。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;私が把握してるのはこれくらい。ビルドツール統合と開発支援があればどうにかなるっしょ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLで函数型的正規表現マッチ</title>
      <link>/slide/SMLdekansuukatatekiseikihyougenmatchi/</link>
      <pubDate>Tue, 29 Mar 2016 01:44:39 +0900</pubDate>
      
      <guid>/slide/SMLdekansuukatatekiseikihyougenmatchi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLで函数型的正規表現マッチ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# 元ネタ
--------
[関数型的正規表現マッチ | Preferred Research](https://research.preferred.jp/2010/11/regexp-play/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 正規表現
----------

必要最小限の要素は5つだけ

1. 空文字
2. アルファベット1つ
3. 正規表現のOR結合
4. 正規表現のAND結合
5. 正規表現の繰り返し


# SMLで表してみる
-----------------

``` sml
datatype  reg
  = Empty
  | Sym of t
  | Or of reg * reg
  | And of reg * reg
  | Rep of reg
```

# 本当に大丈夫？

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# `/(a|b)*c/`
-----------

``` sml
And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)
```


# `/https?:\/\/[a-z]*/`
-----------

``` sml
val a_z = Or(Sym&#34;a&#34;, Or(Sym &#34;b&#34;, Or(Sym &#34;d&#34;, ...)))
And(Sym &#34;http&#34;, And(Or(Sym &#34;s&#34;, Empty), And(Sym &#34;://&#34;, Rep a_z)))
```


# 実装してみる

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# `Empty`, `Sym`, `Or`
----------------
trivial

``` sml
fun match Empty u = isEmpty u
  | match (Sym a) u = a = u
  | match (Or(p, q)) u = match p u orelse match q u
```


# `And`
--------

`And(p, q)` に入力が`u`の時`p`がどこまでマッチするか分からないので

* `u` から一部取ってきて`p`にマッチするか確認
* 残りの文字列が`q`にマッチするか確認


# `And`
--------
`match (And (Sym &#34;a&#34;, Sym &#34;b&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;&#34;)、(Sym &#34;b&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;b&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;b&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;abd&#34;)、(Sym &#34;b&#34;と&#34;&#34;)



# `And`
--------

``` sml
  | match (And(p, q)) u = 
    withSprits u (fn (u1, u2) =&gt; 
      match p u1 andalso match q u2)

```

`withSprits u f` は`u`を2分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。


# `Rep`
-------

`Rep(r)` に入力が`u`の時、`r`がどこまでマッチするかも`Rep`が何回繰り返すかも分からないので

* `u` を任意の個数に分割し
* その全てが`r`にマッチするか確認



# `Rep`
--------
`match (Rep (Sym &#34;a&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;b&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)




# `Rep`
--------

``` sml
  | match (Rep(r)) u =
    withParts u (fn input =&gt;
      List.all (match r) input)
```

`withParts u f` は`u`を分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。



# チェック
----------

```
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbca&#34;;
val it = false : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbc&#34;;
val it = true : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;c&#34;;
val it = true : bool
```


# まとめ
--------

* 適当に実装したら正規表現も簡単に実装出来るよ
* SMLで正規表現実装したよ


# 参考
------

* [KeenS/regexp](https://github.com/KeenS/regexp)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ビッグデータしないDrill、ローカルで快適に使うために</title>
      <link>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</link>
      <pubDate>Sun, 06 Mar 2016 14:54:30 +0900</pubDate>
      
      <guid>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ビッグデータしないDrill、ローカルで快適に使うために
----------------------
[Tokyo Apache Drill Meetup](http://drill.connpass.com/event/27414/)  
2016-03-22

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + サイバーエージェントのエンジニア
   + アドテクスタジオ所属
   + データエンジニアじゃなくてもデータを触ることはある


# なぜローカルか
---------------

* ビッグデータ重い
* 使いたいデータが絞れる時には大袈裟
  + 「売り上げ上位1000のユーザの行動」とか
* 同じようなクエリの重複
  + 新しいテーブル作れないDBとかview作れないDBとか
* 結果をRに渡したりとかが面倒
  + CSVダウンロードがGUI

# キャッシュ的な
----------------

```
+---------------------------------+
| BIG DATA (BigQuery, Spark, etc) |
+---------------------------------+
        ^ |  ^  |
        | |  |  |
        | v  |  v
   +-------------------+
   | ローカルキャッシュ | &lt;- ???
   +-------------------+
     ^ | ^ | ^ | ^ |
     | v | v | v | |
     +----------+  |
     |   自分   |  |
     +----------+  v
     +---+    +-----+
     | R | &lt;--| CSV |
     +---+    +-----+
```


# やりたいこと
--------------

* パパッっと処理を始められる
  + だいたい「CSVを簡単に読める」に同じ
  + たまにJSONとか
* 簡単に処理出来る
  + 自分が馴れているかどうか
* CSVを吐ける
  + 最後はRに渡したい


# 候補
-------

* ローカルMySQL
  + 事前のScheme定義が必要
* R
  + 扱い馴れない
* SQLite
  + 事前のScheme定義が必要
* (Python)
  + あまり向いてない？



&lt;pre style=&#39;font-size: 200%&#39;&gt;
＿人人人人人人人＿
＞　突然のDrill　＜
￣Y^Y^Y^Y^Y^Y￣
&lt;/pre&gt;


# なぜ Drill
------------

* (デーモン立ち上げておけば)サクっと始められる
* CSVをそのまま読める
  + Schema定義がいらない!
* ついでにJSONも読める
* 馴れたSQLで操作出来る
* CSV吐ける


# Drillを便利にするために
-------------------------

* いくつかのシェル関数
* Drillのデーモン/クライアントの起動を便利に

```sh
drill-start() {
    ~/compile/zookeeper-3.4.8/bin/zkServer.sh start
    drillbit.sh start
}

drill-cli() {
    sqlline -u jdbc:drill:zk=localhost:2181
}

drill-web() {
   firefox http://localhost:8047
}
```


# もっと便利に
--------------

* REPLでの操作が面倒
  + ヒストリ遡るのとか
  + ミスった時の訂正が地味に不便
* シンタックスハイライト欲しい
* 馴れたツールで編集したい


# sql-drill.el
--------------

* [KeenS/sql-drill.el](https://github.com/KeenS/sql-drill.el)
* Emacsのsql-modeのDrillサポート
  + emacsのsql-modeは拡張可能
* シンタックスハイライト
* REPL


# DEMO
------
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# まとめ
--------

* ローカルでデータ分析したい時があるよ
* その時にDrillは便利だよ
* Emacs向けのDrillプラグイン作ったよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustとは何か。どんな言語か。</title>
      <link>/slide/Rusttohananika_donnagengoka_/</link>
      <pubDate>Sun, 06 Mar 2016 05:27:39 +0900</pubDate>
      
      <guid>/slide/Rusttohananika_donnagengoka_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustとは何か。どんな言語か。
----------------------
[異種プログラミング言語格闘勉強会](http://kbkz.connpass.com/event/26677/)  
2016-03-20


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# Rustって?
----------

* システムプログラミング言語
* だけど函数型言語から影響を受けた
* 安全かつ高速
* ゼロコスト抽象化


## システムプログラミング言語
---------------------------

* スレッドはネイティブ、Cとの相互呼び出し、小さなバイナリサイズ
* ゲームエンジンとか作れる([piston](https://github.com/PistonDevelopers/piston))
* レンダリングエンジンとか作れる([Servo](https://github.com/servo/servo))
* Lチカとか出来る
* OSとか作れる([Redox](https://github.com/redox-os/redox))


## 函数型言語的からの影響
-----------------------

最近ではめずらしくなくなった


* デフォルトイミュータブル
* 代数的データ型
* コンビネータ
* トレイト (型クラス)


## 安全かつ高速
--------------

* データ競合が起きない
  + 所有権システム
  + だいたいコンパイル時Read Writeロック
  + Read only参照複数 or Write可能参照1つ
* LLVMベースの強力な最適化
* スレッド周辺のAPIが揃ってる


## ゼロコスト抽象化
------------------
省略

* [Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/)


# Rustの誤解
-----------

* 安定してないって聞いたよ
* 函数型言語ってホント?
* GCがなくて大丈夫?
* 継承がなくて大丈夫?


## 安定してないって聞いたよ

* 1.0以前の話
* 1.0(2015-05以降)はAPIの変更がルール化された
* 新規APIのstablizeはあれどdeprecateはまれ


## 函数型言語ってホント?

* 函数型言語の機能をつまみぐいしてるだけ
* 標準ライブラリとかはバリバリ手続的
* Lispよりも函数型言語っぽくない。
* とはいえ抽象力は高いのでそこまで煩雑にはならない


## GCがなくて大丈夫?

* GCはなくてもメモリ管理は自動でする
* コンパイル時にメモリ管理
  + コンパイラが必要なところにmalloc/freeを挟むイメージ
* むしろメモリ以外(fd、ロックなど)も自動管理
  + GCがある言語よりリソース管理の自動化が徹底してる
* [リージョンについて | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/)


## 継承がなくて大丈夫?

* むしろ継承必要？インターフェースだけでよくない？
* Rustはデータ型とメソッドを分離するので継承のメリットそんなにない
  + トレイトが強力ともいう
* 逆にサブタイプ関係による複雑さの上昇のデメリットが多い
  + 3回以上継承してるの全部把握出来るの？
* ジェネリクスとかはあるよ


# Rustをとりまく環境
-------------------

* racer/rustfmt
* Cargo
* crates.io
* [Rust Playground](https://play.rust-lang.org/)
* The Rust Programming Language



# racer/rustfmt
---------------

* racerがコーディング支援ツール
  + 補完
  + 定義元ジャンプ
  + 型情報
  + 各種エディタプラグインあり
* rustfmtがコードフォーマッタ
  + エディタプラグインあり
  + ビルドツール連携あり


# Cargo
-------

* Rustのビルドツール兼パッケージマネージャ
* これだけ覚えとけば困らない


# crates.io
-----------

* Rustパッケージのセントラルレポジトリ
* 必ずビルドが通るような工夫
  + cargo yank
  + 同じライブラリの違うバージョンがいても大丈夫
* Cargoとの連携
* Cargoからpublishも可能


# [Rust Playground](https://play.rust-lang.org/)
---------------------------------------

* webからRustを試せる
* とりあえず試すと色々分かる
  + 所有権難しいとか


# [The Rust Programming Language](https://doc.rust-lang.org/book/)
------------------------------

* Rustの入門用ドキュメント
* とりあえずこれ読めば始められる
* [和訳版](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)もある
  + [GitHub](https://github.com/rust-lang-ja/the-rust-programming-language-ja)で作業中
  + これの宣伝しに来ただけ
* 1.6ほぼ終わり、1.7はまだ


# ライブラリ紹介
----------------
## MIO

* [mio](https://github.com/carllerche/mio)
* 低レベルな非同期IOライブラリ
  + libuvやlibev2相当
  + イベントスレッドではなくイベントループ
* これを純Rustで実装
* つまり(比較的)高水準なAPIで使える
* 色んなライブラリの下地になっている


# ライブラリ紹介
----------------
## diesel

* [diesel](https://github.com/sgrif/diesel)
* ORM &amp; クエリビルダ
  + mioとはうってかわって高水準なライブラリ
* `infer_schema!(dotenv!(&#34;DATABASE_URL&#34;));` でコンパイル時に
  + DBにアクセスしてスキーマ情報抜いて
  + コード生成
* モデルもCRUDでちゃんと使い分けている


# 所有権難しい
--------------
下記のコードは動かない。

``` rust
fn main(){
    let hello = &#34;Hello, &#34;.to_owned();
    let world = &#34;World!&#34;;
    let hello_world =  hello + world;
    println!(&#34;{}&#34;, hello);
    println!(&#34;{}&#34;, world);
    println!(&#34;{}&#34;, hello_world);
}

```



# まとめ
--------

* Rustはシステムプログラミング言語だよ
* 面白い機能いっぱいあるよ
* もう「安定待ち」じゃないよ
* Try it now!



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>