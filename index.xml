<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 12 Jun 2016 15:23:06 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>multirustが非推奨になったようなのでrustupに移行する</title>
      <link>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</link>
      <pubDate>Sun, 12 Jun 2016 15:23:06 +0900</pubDate>
      
      <guid>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</guid>
      <description>

&lt;p&gt;κeenです。どうやらもうそろそろRustのツールチェーン管理はmultirustじゃなくてrustupを使った方が良さそうなので移行しようと思います。&lt;/p&gt;

&lt;p&gt;きっかけはmultirustにそういうコミットがされたから。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;もうmultirustじゃなくてrustup使え、と。&lt;br&gt;&lt;br&gt;Update README.md · brson/multirust@84c3459&lt;a href=&#34;https://t.co/ySeRB50x5C&#34;&gt;https://t.co/ySeRB50x5C&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/741077158651514882&#34;&gt;2016年6月10日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;因みにrustupは&lt;a href=&#34;https://github.com/rust-lang/rustup.sh&#34;&gt;rust-lang/rustup.sh: The rustup.sh script for installing Rust from release channels&lt;/a&gt;ではなく&lt;a href=&#34;https://github.com/rust-lang-nursery/rustup.rs&#34;&gt;rust-lang-nursery/rustup.rs: The Rust toolchain installer&lt;/a&gt;の方です。インストールガイドなどはこちらから。&lt;a href=&#34;https://www.rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なんかベータ版のようですが推奨していいんですかね…。&lt;/p&gt;

&lt;p&gt;とりあえずmultirustを入れたままコマンドを叩いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer
warning: it looks like you have an existing installation of multirust
warning: rustup cannot be installed alongside multirust
warning: run `/usr/local/lib/rustlib/uninstall.sh` as root and delete `/home/kim/.multirust/version` before installing rustup
error: cannot install while multirust is installed
rustup: command failed: /tmp/tmp.9kjQj9WT5O/rustup-init

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふーむ。アンインストールしろ、と。一応指示された通りmultirust自体はアンインストールせずにversionだけを削除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/local/lib/rustlib/uninstall.sh
install: uninstalling component &#39;multirust&#39;

    multirust is uninstalled.
$ rm -rf ~/.multirust/version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう一度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;選択肢が出ました。とりあえず1を選択します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: toolchain &#39;stable&#39; is not installed
info: caused by: not a directory: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu&#39;
rustup: command failed: /tmp/tmp.nugK4VN4p8/rustup-init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;えー。ちょっと…。仕方ないのでシンボリックリンクを貼って騙してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls ~/.multirust/toolchains/
beta  nightly  stable
$ ln -s ~/.multirust/toolchains/{stable,stable-x86_64-unknown-linux-gnu}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3度目の正直なるか&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
1

info: updating existing rustup installation


Rust is installed now. Great!

To get started you need Cargo&#39;s bin directory in your PATH environment variable.
Next time you log in this will be done automatically.

To configure your current shell run source $HOME/.cargo/env.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストール出来たよう。しかしセットアップは &lt;code&gt;~/.profile&lt;/code&gt; に書かれたようなので &lt;code&gt;.zshrc&lt;/code&gt; は自分で更新します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/zshrc b/zshrc
index 0178873..589c6a5 100644
--- a/zshrc
+++ b/zshrc
@@ -213,7 +213,7 @@ export PATSHOME=~/compile/ATS2-Postiats-$ATS_VERSION/
 export PATH=$PATSHOME/bin:$PATH
 export PATSHOMERELOC=~/compile/ATS2-Postiats-contrib-$ATS_VERSION
 
-export PATH=$PATH:~/.multirust/toolchains/stable/cargo/bin
+export PATH=&amp;quot;$HOME/.cargo/bin:$PATH&amp;quot;
 
 # OPAM configuration
 . /home/kim/.opam/opam-init/init.sh &amp;gt; /dev/null 2&amp;gt; /dev/null || true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup 0.1.12 (c6e430a 2016-05-12)
The Rust toolchain installer

USAGE:
    rustup [FLAGS] [SUBCOMMAND]

FLAGS:
    -v, --verbose    Enable verbose output
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    show         Show the active and installed toolchains
    update       Update Rust toolchains
    default      Set the default toolchain
    toolchain    Modify or query the installed toolchains
    target       Modify a toolchain&#39;s supported targets
    override     Modify directory toolchain overrides
    run          Run a command with an environment configured for a given toolchain
    which        Display which binary will be run for a given command
    doc          Open the documentation for the current toolchain.
    self         Modify the rustup installation
    telemetry    rustup telemetry commands
    help         Prints this message or the help of the given subcommand(s)

rustup installs The Rust Programming Language from the official
release channels, enabling you to easily switch between stable, beta,
and nightly compilers and keep them updated. It makes cross-compiling
simpler with binary builds of the standard library for common platforms.

If you are new to Rust consider running `rustup doc --book`
to learn Rust.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;multirustを使っていたら馴染めそうですね。&lt;/p&gt;

&lt;p&gt;一応どこにインストールされたのか確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which rustc
/home/kim/.cargo/bin/rustc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふむふむ。ちょいとアップデートしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.1 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.0 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   2.3 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %) 953.6 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.2 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.5 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 44.8 MiB /  44.8 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 57.9 MiB /  57.9 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.0 MiB /   7.0 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.3 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 46.5 MiB /  46.5 MiB (100 %) 924.8 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 59.0 MiB /  59.0 MiB (100 %)   2.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.3 MiB /   7.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   3.2 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: checking for self-updates
info: rustup is up to date

                           stable update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
  stable-x86_64-unknown-linux-gnu update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                                 beta installed - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                              nightly installed - rustc 1.11.0-nightly (0554abac6 2016-06-10)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、なんかコケてる…。シンボリックリンクが悪さしたかな…。しかし試しに手元のプロダクトをコンパイルしてみたら通ったので使えているよう。&lt;/p&gt;

&lt;p&gt;さて、クロスコンパイルの方はどうでしょうか。以前Raspberry Pi向けにクロスコンパイルしました &lt;a href=&#34;http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/&#34;&gt;RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog&lt;/a&gt;。これは動くでしょうか。&lt;/p&gt;

&lt;p&gt;とりあえずインストール可能なターゲットを確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………。無理矢理addしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target add nightly-arm-unknown-linux-gnueabihf
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………………………………。&lt;/p&gt;

&lt;p&gt;なんか変ですね。&lt;/p&gt;

&lt;p&gt;一旦&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm ~/.multirust/toolchains/stable-x86_64-unknown-linux-gnu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;してもう一度 &lt;code&gt;rustup update&lt;/code&gt; します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.6 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.7 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   5.0 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: checking for self-updates
info: rustup is up to date

                            stable installed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                              beta unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
     beta-x86_64-unknown-linux-gnu unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                           nightly unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
  nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、今回は上手くいった。やっぱりシンボリックリンクが悪かったよう。リトライ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target add --toolchain nightly arm-unknown-linux-gnueabihf
info: downloading component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
 62.6 MiB /  62.6 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: installing component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んー、ちゃんとnightlyが入ったのか分からない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup show
installed toolchains
--------------------

stable
stable-x86_64-unknown-linux-gnu (default)
beta
beta-x86_64-unknown-linux-gnu
nightly
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.9.0 (e4e8b6668 2016-05-18)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし件のARM向けプロジェクトのクロスコンパイルは出来たよう。&lt;/p&gt;

&lt;p&gt;もう一度listを見る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;arm-unknown-linux-gnueabihf (installed)&lt;/code&gt; とあるのでインストール出来ているよう。しかし本当にnightlyなのか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup target list --toolchain stable
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target list --toolchain nightly
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら本当にnightlyのよう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:c28f45112bee5b568eeb1f1b4938ccbb&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;色々あたふたとしましたがrustupをインストールして使ってみました。multirustを使っているとインストールあたりでやや難はありそうですがそれ以降は普通に使えそうです。&lt;/p&gt;

&lt;p&gt;皆様もお試しあれ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DOT/dottyについて調べてみた</title>
      <link>/slide/DOT_dottynitsuiteshirabetemita/</link>
      <pubDate>Tue, 24 May 2016 23:40:36 +0900</pubDate>
      
      <guid>/slide/DOT_dottynitsuiteshirabetemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# DOT/dottyについて調べてみた
----------------------
サイバーエージェント Scala Meet Up  
2016-05-27

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + Scala初心者
   + Scala歴1年未満&amp;gt;&amp;lt;


# Scalaコンパイラ
----------------

* 型推論（特にimplicit）が遅い
* コンパイルフェーズが多い
  + 中間オブジェクトが多くて遅くなる
* 多くのクラスファイルを生成する
  + コンパイラのくせにディスクIOが多い
* 気を抜いてると `Any` に推論される  
  e.g.) `if(x) 1 else &#34;a&#34;`
* そもそものScalaの設計に起因する点が多い
  + 抜本的変更が必要


# Scala基礎
-----------

* Scalaが成立するのに最低限必要な機能って？
  + e.g.) `case class` はなくても `class` だけでどうにかなる
* 「最低限の機能」を減らせばコンパイラがシンプルになる
  + 他の機能はただのシンタックスシュガーになる
  + コンパイラのバグを減らせる
  + 機能追加時の矛盾確認が楽
* コア言語


# Featherlight Scala
---------------------

* Scalaのシンタックスシュガーを減らした感じ
* 小さな言語
* 元のScalaはこれをベースに議論されてきた


# 形式言語理論
-------------

* 最低限必要な機能を形式的にモデル化
  + 全ての動作は予め決められた「規則」に基く
  + 実際に書いて動かすものではない
* 形式的にすることで「証明」とかが出来る
  + 「型検査に通れば実行時に型エラーが起きない」
  + 「型検査が必ず終了する」
* 逆に、「このモデルだとこの機能は実現出来ない」とかも分かる


# Dependent Object Type
------

* Scalaのコアをモデル化したもの（要出典）
* 形式言語
* ジェネリクスもなければクラスも継承もない、パッケージもない。
* 小さい言語ながら表現力豊か
* 全ての値はオブジェクト。
  + オブジェクトのフィールドとメソッドと型メンバーだけ
  + 型はそのまま
* Path Dependent Type
* サブタイピング



# About DOT
---------

* 型付の健全性が証明された
* System F&lt;:より強力
  * System F&lt;: -&gt; System D&lt;: -&gt; DOT
* existential typeを自然に表現出来る
* 交差型と合併型
  + `A extends B` -&gt; `A &amp; B`
  + 合併型は主に型推論の結果に出てくる


```scala
package scala.collection.immutable trait List[+A] {
  def isEmpty: Boolean; def head: A; def tail: List[A]
}
object List {
  def nil: List[Nothing] = new List[Nothing] {
    def isEmpty = true; def head = head; def tail = tail /* infinite loops */
  }
  def cons[A](hd: A, tl: List[A]) = new List[A] {
    def isEmpty = false; def head = hd; def tail = tl
  }
}
```


```scala
object scala_collection_immutable { sci =&gt;
  trait List { self =&gt;
    type A
    def isEmpty: Boolean
    def head: self.A def
      tail: List{type A &lt;: self.A}
  }
  def nil: sci.List{type A = Nothing} = new List{ self =&gt;
    type A = Nothing
    def isEmpty = true
    def head: A = self.head
    def tail: List{type A = Nothing} = self.tail
  }
  def cons(x: {type A})(hd: x.A)(tl: sci.List{type A &lt;: x.A})
      : sci.List{type A &lt;: x.A} = new List{ self =&gt;
    type A = x.A
    def isEmpty = false
    def head = hd
    def tail = tl
  }
}
```


# dotty
--------

* DOTに影響を受けたコンパイラ
* いくつかの新しい機能
  + DOTの交差型、合併型も
  + Nullable = `T | Null`
  + `if (x) 1 else &#34;a&#34;` は `Int | String` にアノテーション可能
* `forSome` が消えた
  + DOTのお陰


# dotty
--------

* Java8のラムダを使う
  + 生成するclassファイルの減少
* Implicitの探索アルゴリズムを改善
  + 反変implicitについても改善
* 型推論のアルゴリズムを改善
  + DOTのお陰
  + 特にサブタイピングが交差/合併型で楽に
* コンパイルパスを融合して高速化
  + 中間木がなくなってGCにやさしい
* 他にも一杯改善が



```scala
object DaysOfTheWeek{
  object Mon
  object Tue
  object Wed
  object Thu
  object Fri
  object Sat
  object Sun

  type Weekend = Sat.type | Sun.type
  type Workweek = Mon.type | Tue.type | Wed.type | Thu.type | Fri.type
  type All = Weekend | Workweek
}
```


# TASTY/Linker
--------------

* classファイルを作るとScala固有の情報が落ちる
* プログラム全体を見渡すと不要なコードとかもコンパイルしないといけない
* かといって毎回プログラム全部をコンパイルし直すのは遅い
* → TASTY。型推論後のASTをシリアライズする
  + Scalaは型推論が遅いのでそこをスキップ出来るだけでそこそこ速くなる
* classファイルを跨げるようになったのでユーザが最適化とかも書ける
* Scala/Scala.js/Scala Native共通プラットフォーム化への布石？
* どうやらclassファイルにバイトコードとTASTYを埋め込む??


# まとめ
--------

* Scalaの基礎にDOTがあるよ
* DOTを参考にdottyが作られたよ
* dottyで色々改善されるよ
* ついでにTASTY/Linkerについて話したよ


# 参考1
------

* [The Essence of Dependent Object Types](https://infoscience.epfl.ch/record/215280/files/paper_1.pdf)
* [From F to DOT: Type Soundness Proofs with Definitional Interpreters](http://arxiv.org/pdf/1510.05216v2.pdf)
* [Dependent Object Types](http://www.cs.uwm.edu/~boyland/fool2012/papers/fool2012_submission_3.pdf)
* [Why is the Scala compiler so slow? - Quora](https://www.quora.com/Why-is-the-Scala-compiler-so-slow)
* [performance - Java compile speed vs Scala compile speed - Stack Overflow](http://stackoverflow.com/questions/3490383/java-compile-speed-vs-scala-compile-speed/3612212#3612212)


# 参考2
-------

* [GHC doesn&#39;t do subtyping. I suspect that is the main reason why Scala is slow - ... | Hacker News](https://news.ycombinator.com/item?id=5008761)
* [A Core Calculus for Scala Type Checking](http://lampwww.epfl.ch/~odersky/papers/mfcs06.pdf)
* [namin/dot: formalization of the Dependent Object Types (DOT) calculus](https://github.com/namin/dot)
* [The DOT Calculus](http://lampwww.epfl.ch/%7Eamin/dot/current_rules.pdf)
* [Dotty: exploring the future of scala](https://d-d.me/talks/scalaworld2015/)
* [Dotty and types: the story so far](http://guillaume.martres.me/talks/typelevel-summit-oslo/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>cargo-profilerを試す</title>
      <link>/blog/2016/05/14/cargo_profilerwotamesu</link>
      <pubDate>Sat, 14 May 2016 20:59:13 +0900</pubDate>
      
      <guid>/blog/2016/05/14/cargo_profilerwotamesu</guid>
      <description>

&lt;p&gt;κeenです。先日Rustのニュースに流れてきたcargo profilerを試してみます。
元の紹介記事はこちら&lt;a href=&#34;http://www.suchin.co/2016/05/11/Introducing-Cargo-Profiler/&#34;&gt;Introducing Cargo Profiler · suchin&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;GitHubレポジトリはこちら&lt;a href=&#34;https://github.com/pegasos1/cargo-profiler&#34;&gt;pegasos1/cargo-profiler: cargo subcommand to profile binaries&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Profilerとはいっても自身でプロファイラを持っている訳ではなくて外部のプロファイラ（現状valgrind）を呼び出して整形してくれるツールのようです。
Rust向けに関数をモジュールパス付きで表示してくれたりするのでRustから使うにはvalgrind生より便利そうです。&lt;/p&gt;

&lt;h1 id=&#34;インストール:c9a67fd2ebaec3ab35855c9653734324&#34;&gt;インストール&lt;/h1&gt;

&lt;p&gt;READMEに従って&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt install valgrind
$ cargo install cargo-profiler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;h1 id=&#34;プロジェクトの準備:c9a67fd2ebaec3ab35855c9653734324&#34;&gt;プロジェクトの準備&lt;/h1&gt;

&lt;p&gt;適当なものがないので手元の[κLisp]()でフィボナッチ数列を動かしてみます。(と思ったらκLispに比較演算子がなかったのでそれを作るところから始まりましたがそれはまた別の話)。&lt;/p&gt;

&lt;p&gt;main.rsはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate kappa_lisp;
use kappa_lisp::kappa_lisp::{run, init};
use kappa_lisp::env::Env;

fn main() {
    let mut env = Env::new();
    init(&amp;amp;mut env).unwrap();
    run(&amp;amp;mut env, r&amp;quot;
(defun fib (n)
  (if (&amp;lt; n 2)
      1
      (+ (fib (- n 1)) (fib (- n 2)))))
&amp;quot;).unwrap();
    let expr = run(&amp;amp;mut env, r&amp;quot; (fib 20) &amp;quot;).unwrap();
    println!(&amp;quot;{}&amp;quot;, expr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;割と遅いので20くらいで限界でした。&lt;/p&gt;

&lt;p&gt;さて、これを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo build --release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてビルドします。&lt;/p&gt;

&lt;h1 id=&#34;プロファイル:c9a67fd2ebaec3ab35855c9653734324&#34;&gt;プロファイル&lt;/h1&gt;

&lt;p&gt;今のところcallgrindとcachegrindが実装されているようです。1つづづ試してみます。&lt;/p&gt;

&lt;h2 id=&#34;callgrind:c9a67fd2ebaec3ab35855c9653734324&#34;&gt;callgrind&lt;/h2&gt;

&lt;p&gt;よく分かってないのですが多分実行時間に占める関数毎の割合を出してくれるんですかね。-nで上位何件を表示するか指定出来ます。&lt;/p&gt;

&lt;p&gt;とりあえず上位10件出してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo profiler callgrind --bin ./target/release/kappa_lisp -n 10
Profiling kappa_lisp with callgrind...

Total Instructions...571,437,255

142,527,726 (24.9%) ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
107,551,309 (18.8%) ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
39,749,571 (7.0%) ???:collections::hash::map::HashMap..K$C$..V$C$..S..::get
-----------------------------------------------------------------------
38,693,006 (6.8%) ???:sdallocx
-----------------------------------------------------------------------
37,670,732 (6.6%) ???:mallocx
-----------------------------------------------------------------------
34,608,049 (6.1%) ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
26,539,906 (4.6%) ???:eval::eval
-----------------------------------------------------------------------
19,887,024 (3.5%) ???:util::f_foldr
-----------------------------------------------------------------------
16,634,175 (2.9%) ???:eval::feval
-----------------------------------------------------------------------
14,353,992 (2.5%) ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、こんな感じです。ハッシュテーブル関連が時間喰ってますね。これは関数呼び出しの度に行われてます。
ちょっと実装が雑すぎるので直さなきゃ…。&lt;/p&gt;

&lt;h1 id=&#34;cachegrind:c9a67fd2ebaec3ab35855c9653734324&#34;&gt;cachegrind&lt;/h1&gt;

&lt;p&gt;キャッシュミスを表示してくれます。本気出してチューニングする時に必要ですね。&lt;/p&gt;

&lt;p&gt;同じく -nで件数を絞り込めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10  


Profiling kappa_lisp with cachegrind...

Total Memory Accesses...800,070,388	

Total L1 I-Cache Misses...100,068 (0%)	
Total LL I-Cache Misses...422 (0%)	
Total L1 D-Cache Misses...4,346,335 (0%)	
Total LL D-Cache Misses...7,724 (0%)	

 Ir  I1mr ILmr  Dr  D1mr DLmr  Dw  D1mw DLmw
0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get
-----------------------------------------------------------------------
0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx
-----------------------------------------------------------------------
0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx
-----------------------------------------------------------------------
0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval
-----------------------------------------------------------------------
0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr
-----------------------------------------------------------------------
0.03 0.02 0.05 0.04 0.05 0.00 0.02 0.06 0.05 ???:eval::feval
-----------------------------------------------------------------------
0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やはりハッシュテーブルが酷いですが同じコードを繰り返し実行するタイプのマイクロベンチマークなのでキャッシュミスは少ないです。&lt;/p&gt;

&lt;p&gt;因みにそれぞれの列はこういう意味だそうです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ir -&amp;gt; Total Instructions&lt;/li&gt;
&lt;li&gt;I1mr -&amp;gt; Level 1 I-Cache misses&lt;/li&gt;
&lt;li&gt;ILmr -&amp;gt; Last Level I-Cache misses&lt;/li&gt;
&lt;li&gt;Dr -&amp;gt; Total Memory Reads&lt;/li&gt;
&lt;li&gt;D1mr -&amp;gt; Level 1 D-Cache read misses&lt;/li&gt;
&lt;li&gt;DLmr -&amp;gt; Last Level D-cache read misses&lt;/li&gt;
&lt;li&gt;Dw -&amp;gt; Total Memory Writes&lt;/li&gt;
&lt;li&gt;D1mw -&amp;gt; Level 1 D-Cache write misses&lt;/li&gt;
&lt;li&gt;DLmw -&amp;gt; Last Level D-cache write misses&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;--sort&lt;/code&gt; オプションでどの列をみるのか指定出来るようです。全メモリアクセスのミスレートを見てみましょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10 --sort dr


Profiling kappa_lisp with cachegrind...

Total Memory Accesses...800,082,686	

Total L1 I-Cache Misses...100,083 (0%)	
Total LL I-Cache Misses...420 (0%)	
Total L1 D-Cache Misses...4,321,895 (0%)	
Total LL D-Cache Misses...7,721 (0%)	

 Ir  I1mr ILmr  Dr  D1mr DLmr  Dw  D1mw DLmw
0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx
-----------------------------------------------------------------------
0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get
-----------------------------------------------------------------------
0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx
-----------------------------------------------------------------------
0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval
-----------------------------------------------------------------------
0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr
-----------------------------------------------------------------------
0.03 0.02 0.05 0.04 0.04 0.00 0.02 0.06 0.05 ???:eval::feval
-----------------------------------------------------------------------
0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やっぱりハッシュテーブル関連が重い…。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:c9a67fd2ebaec3ab35855c9653734324&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;私にとっては薮蛇にκLispの実装の筋が悪いことが分かったりしてショックでしたがまあ、簡単にプロファイルをとれるツールを紹介しました。&lt;/p&gt;

&lt;p&gt;Rustで高速なアプリケーションを作りたい方、利用してみては如何でしょうか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>高速な継続ライブラリに向けて</title>
      <link>/slide/kousokunakeizokuraiburarinimukete/</link>
      <pubDate>Sun, 08 May 2016 21:26:32 +0900</pubDate>
      
      <guid>/slide/kousokunakeizokuraiburarinimukete/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 高速な継続ライブラリに向けて
----------------------
[継続勉強会](http://connpass.com/event/28150/) 2016-05-22
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

# 継続欲しい
-----------

* 色々な場面で便利
* Schemeで使い回してるのうらやましい
* Common Lispでも使いたい
* 現実には限定継続が欲しい
  +  Common Lispには大域脱出はある


# 限定継続を使う例
-----------------
## 非同期プログラミング

* コールバック形式だと厳しい
* 限定継続を使うと綺麗に書き直せる


# 限定継続を使う例
-----------------
## ゲームのコルーチン

* 複数のオブジェクトを制御するのにコルーチンが欲しい
* cf [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)


# 限定継続を使う例
-----------------
## do記法

* モナドのdo記法は限定継続を使って実装出来る
* [Operational monad in scheme](http://www.slideshare.net/yuichinishiwaki/operational-monad-in-scheme)



# Common Lispでの限定継続の実現
---------------

1. 仕様に入れてもらう
2. 処理系に手を入れる
3. ユーザレベルで(限定)継続ライブラリを作る
   + 柔軟なCommon Lispでは可能


# CPS変換
---------

* (限定)継続の実現方法の1つ
  + スタックを切り取る方式とかもある
* 機械的にも出来る
* グローバルな変換なのとプリミティブな式しか書けないでコンパイラ内部でやることが多い
  + 継続関係なしに中間形式として採用されることが多い
* 関数定義/呼び出し以外にも諸々の構文とかに対しても定義が必要


# CPS変換
----------

Q. Common Lispだといくつの構文に対して定義が必要?

1. 1つ
2. 26つ
3. 42つ
4. 無数



# CPS変換
----------

A. 26つ (スペシャルフォーム25+funcall)


# Common Lispのプリミティブ
--------------------------

* スペシャルフォームと呼ばれる
* 仕様で25個定められている
* [CLHS: Section 3.1.2.1.2.1](http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm)
* この中に関数定義だとか例外だとかは入っていない
  + マクロで定義されている


# マクロ
--------

* 構文木 to 構文木(S式to S式)変換器( = 普通のLispの関数)
* 新しい構文を作れる
* CPS変換は?????


# `macroexpand`
-------------

* [CLHS: Function MACROEXPAND, MACROEXPAND-1](http://clhs.lisp.se/Body/f_mexp_.htm)
* マクロを手動展開する関数
* 雑にいうと普段pre-orderなマクロ展開をin-orderやpost-orderにする時に使う
* 本来はあまり使いたくない
  + 処理系の展開器に任せた方が間違いが少ない
* これでマクロを排したプリミティブのCommon Lispの構文木にアクセス出来る


# cl-cont
---------

* 上記のことを全てやったライブラリ
* デファクトというか唯一のライブラリ
* [Common Lispで限定継続と遊ぶ | κeenのHappy Hacκing Blog](http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/)


&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;「shift/resetがわからない時にあげる声」&lt;/p&gt;&amp;mdash; かず(原材料に小麦粉を含む) (@kazzna) &lt;a href=&#34;https://twitter.com/kazzna/status/674026894602309632&#34;&gt;2015年12月8日&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# cl-contの使用例

``` common-lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```


# cl-contの使用例

``` common-lisp
(FUNCALL
 (LAMBDA (&amp;OPTIONAL #:G542 &amp;REST #:G543)
   (DECLARE (IGNORABLE #:G542))
   (DECLARE (IGNORE #:G543))
   (FUNCALL
    (LAMBDA (&amp;OPTIONAL #:G544 &amp;REST #:G545)
      (DECLARE (IGNORABLE #:G544))
      (DECLARE (IGNORE #:G545))
      (FUNCALL (LAMBDA (K) (FUNCALL K 1))
               (LAMBDA (&amp;OPTIONAL #:G546 &amp;REST #:G547)
                 (DECLARE (IGNORABLE #:G546))
                 (DECLARE (IGNORE #:G547))
                 (FUNCALL (CL-CONT::FDESIGNATOR-TO-FUNCTION/CC #:G542) #&#39;VALUES
                          #:G544 #:G546))))
    1))
 #&#39;+)
```



# cl-contへの不満
-----------------

* 遅い
* lambda多い。
  + 多分コンパイラと相性が悪い
* lambda禁止おじさんと分かりあえる


# cl-fast-cont


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# cl-fast-cont
--------------

* [KeenS/cl-fast-cont: faster partial contiuation library of common lisp](https://github.com/KeenS/cl-fast-cont)
* とりあえずレポジトリ作っただけ
* 完成させたい…


# アプローチ1
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# SSA使う
---------

* CPSと等価
* だけどSSAだったらlambda出てこない
* Common Lispならgotoあるしいけるんじゃね？


```common-lisp
(let (x y z)
 (tagbody
    (setq x 1)
  :call/cc
    (setq y 1)
    (setq z (+ x y))))
```



# 問題
-------

* ネイティブスタックとは別に自分でスタック作らないといけない
  + 例外とかでスタック巻き戻されるとつらい
* gotoのタグをtagbodyの外に持ち出せない(=継続を外に持ち出せない)
* 変数を準備するのが面倒orパフォーマンスに影響しそう
* そもそもtagbodyそこまで柔軟じゃなかった
* 関数が消し飛ぶ


# アプローチ2
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# SSA+CPS
---------

* SSAとCPSを組み合わせる
* 基本はSSA
* スタックを使う/継続が必要な所でだけCPS

# 問題
-------

* SSAの部分意味なくね？
* そもそも継続を取り出すのが目的なので関係ない所で変換しても意味がない


# アプローチ3
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Selective CPS
----------------

* 継続が必要な部分でのみ変換
* 2 pass transformation
* [A Selective CPS Transformation](http://www.sciencedirect.com/science/article/pii/S1571066104809691)


```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    (+ 1 (call/cc
          (lambda (k)
            (funcall k y))))))

```



```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    (+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```



```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    @(+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```



```common-lisp
(with-call/cc
  @(let ((x 3) y)
    (setq y (* x x))
    @(+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```


# そもそもCommon Lispのつらい話
-------------------------------
* セマンティクスが動的
  + catch, block, tagbody
  + special variable
  + 変換は静的なのでどう頑張っても追い付かない
* multiple valueが面倒



# ダイナミック!!
----------------

``` common-lisp
(block name
 (let ((f
        (lambda (x) (return-from name x))))
   (with-call/cc
       (funcall
        f
        (call/cc
         (lambda (k)
           (funcall k 2)))))))
```


# スペシャル変数
---------------

* Common Lispにはレキシカルスコープとダイナミックスコープ両方ある
* CPS変換すると継続の全てがスコープ下に入る
  + 関数の呼び出し関係が木だったのが線型になる
  + ダイナミックスコープだと困る

![CPS前のAST](/images/cps/pre-cps.png)



![CPS後のAST](/images/cps/post-cps.png)



```
(defvar *x* 1)
(with-call/cc
  (progn
    (let ((*x* 2))
      (call/cc ..)
      (format t &#34;~a~%&#34; *x*)) ; *x* = 2
    (format t &#34;~a~%&#34; *x*))) ; *x* = 1

```



```
(defvar *x* 1)
(with-call/cc
  (progn
    (let ((*x* 2))
      (...
       (lambda (ignore)
         ((lambda (ignore)
            (format t &#34;~a~%&#34; *x*)) ; *x* = 2!!
          (format t &#34;~a~%&#34; *x*))))))) ; *x* = 1
```


# 多値
------

* Common Lispの多値はGoと違って無視出来る
* 変換が空気読む必要がある
* 下手するとプログラムを壊す
  1. 本当は多値を返してるのに変換で無視された
  2. 意図的に無視してるのに変換で加えられた


# 関数定義と引数の数
-----------------

* **Selective** CPS
* 関数をCPS変換するときとしない時がある
* 呼び出す時にどっちか分かんなくね？
  1. 統一的に変換してしまう
  2. Selectiveに変換して関数にメタデータつける

-&gt; まだ決めきれてない


# パフォーマンス
----------------


&lt;!-- .slide: class=&#34;center&#34; --&gt;


# フィボナッチ数列
-----------------
* とりえあずのフィボナッチ数列で計測
  + Full CPS変換に割と不利
  + 何も考えずにライブラリを使うとこうなるよって例
* Selective CPSは何もしない=普通の定義と同じ



```common-lisp
(defun fib (n)
  (if (&lt;= n 1)
      1
      (+ (fib (- n 1)) (fib (- n 2)))))
```

``` common-lisp
(defun/cc fib-cont (n)
  (if (&lt;= n 1)
      1
      (+ (fib-cont (- n 1)) (fib-cont (- n 2)))))
```


# Selective


```
Evaluation took:
  1.517 seconds of real time
  1.516000 seconds of total run time (1.516000 user, 0.000000 system)
  99.93% CPU
  4,388,993,782 processor cycles
  0 bytes consed
```


# Full

```
Evaluation took:
  18.347 seconds of real time
  18.576000 seconds of total run time (18.248000 user, 0.328000 system)
  [ Run times consist of 1.396 seconds GC time, and 17.180 seconds non-GC time. ]
  101.25% CPU
  53,149,416,888 processor cycles
  22,922,853,904 bytes consed
```

# コルーチン
------------

* そこまでFull CPSに不利じゃない
* 割と実用しそうな例
* Selective CPSは少しだけラムダが少ない


# Selective

``` common-lisp
(let (c)
  (setf c ((lambda ()
             (write-line &#34;in thread A 1&#34;)
             (lambda ()
              (write-line &#34;in thread A 2&#34;)
              (lambda ()
                (write-line &#34;in thread A 3&#34;))))))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```



# full

```common-lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```

# Selective

```
Evaluation took:
  0.905 seconds of real time
  0.904000 seconds of total run time (0.904000 user, 0.000000 system)
  99.89% CPU
  2,617,396,241 processor cycles
  0 bytes consed

```


# full

```
Evaluation took:
  1.272 seconds of real time
  1.272000 seconds of total run time (1.272000 user, 0.000000 system)
  100.00% CPU
  3,681,362,466 processor cycles
  0 bytes consed
```


# まとめ
--------

* 限定継続便利だよ
* マクロを使えばCPS変換で限定継続実装出来るよ
* でもパフォーマンや言語の問題もあるよ
* Selective CPSを使えばパフォーマンスの問題解決出来るよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>RustでベアメタルRaspberry PiのLチカ</title>
      <link>/blog/2016/05/04/rustdebeametaruraspberry_pinolchika</link>
      <pubDate>Wed, 04 May 2016 11:43:26 +0900</pubDate>
      
      <guid>/blog/2016/05/04/rustdebeametaruraspberry_pinolchika</guid>
      <description>

&lt;p&gt;κeenです。GWもくもく会で机の片隅で埃被ってたRSPiのベアメタルを触ってみたのでその成果報告を。
ベアメタルについて知らない人でも読めるように書きます。そしてアセンブラもCも出てきませんし、半田付けも必要ありません。
Rustしか使いません。&lt;/p&gt;

&lt;p&gt;Rustは分かるけどLチカは全く知らない、けど興味のある方は是非読んでみて下さい。&lt;/p&gt;

&lt;h1 id=&#34;ベアメタルって:491c584db4092bf0e3567730a02ae671&#34;&gt;ベアメタルって？&lt;/h1&gt;

&lt;p&gt;普段我々が使っているパソコンはOSの上で動いています。
OSはざっくりいうとハードウェアへのアクセスを抽象化し、プロセスという単位でプログラムの実行を分離します。
ベアメタルはそのOSがない状態、ハードウェアの初期化やプロトコルなどは自分でやるしメモリ管理だとかも自分でやる環境です。
丁度ハードウェアが抽象化されてなくて機械が生で見えているようなのでこう呼ぶようです。&lt;/p&gt;

&lt;p&gt;OSがないのは中々イメージつきづらいですが、標準出力なんてものはないのでHello Worldも動きませんしメモリも仮想化されていないのでmallocも発効出来ません。
さらにはスタックとヒープみたいな区別もOSが与えてくれるものなので、自分で作らない限りスタック領域も使えません。
自分で書いたプログラムが唯一走るプログラムなのでプロセスの感覚でプログラムを終了させてはいけません。&lt;/p&gt;

&lt;p&gt;なんでそんな環境でプログラムしたいかというといくつかモチベーションがありそうです。1つはOSそのものを作ってみたい人が練習がてら。
もう1つにはOSが動かないような小さな環境だとそれしか選択肢がない。&lt;/p&gt;

&lt;p&gt;RSPiの場合はOSが動くので選択肢がないという訳ではないのですが私はそういう小さなデバイスを持っていないので実験台としてRSPiを使いました。&lt;/p&gt;

&lt;p&gt;さて、Hello Worldすら動かないシステムでの入門的なプログラムは信号のON/OFFを切り替えてあげるだけで出来るLEDをチカチカさせるプログラムという訳です。&lt;/p&gt;

&lt;h1 id=&#34;raspberry-pi:491c584db4092bf0e3567730a02ae671&#34;&gt;Raspberry Pi&lt;/h1&gt;

&lt;p&gt;言わずと知れた名刺サイズの小型コンピュータ、Raspberry Piです。
Raspberry Piと一口にいっても&lt;a href=&#34;https://ja.wikipedia.org/wiki/Raspberry_Pi&#34;&gt;色々種類がある&lt;/a&gt;のですが、私が持っているのはRaspberry Pi 1 Model Bの後期モデルです(Raspberry Pi 1 Model Bは販売途中で仕様がアップグレードしてメモリが増えた)。&lt;/p&gt;

&lt;p&gt;ARMv6アーキテクチャのチップ(ARM1176JZF-S)で動いていて、SDカードから起動します。特別なライターなどは必要なく、PCからSDカードに書き込んでRSPiに挿して電源を繋ぐだけで簡単に起動出来る訳です。
さらに配線とかが必要なGPIOに加えてボードにLEDもついているので物理の知識必要なくて今回のようにLチカだけをやりたいなら手軽に遊べます。&lt;/p&gt;

&lt;h1 id=&#34;準備:491c584db4092bf0e3567730a02ae671&#34;&gt;準備&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 1 Model B&lt;/li&gt;
&lt;li&gt;USB - micro USBケーブル(Raspberry Piへの給電用)&lt;/li&gt;
&lt;li&gt;SDカード(FAT32でフォーマットしておく)&lt;/li&gt;
&lt;li&gt;GCCのARM向けクロスコンパイラ(後述)&lt;/li&gt;
&lt;li&gt;RustのARM向けクロスコンパイラ(後述)&lt;/li&gt;
&lt;li&gt;ブートローダ(後述)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gccのクロスコンパイラ:491c584db4092bf0e3567730a02ae671&#34;&gt;GCCのクロスコンパイラ&lt;/h2&gt;

&lt;p&gt;GCCのクロスコンパイラは&lt;a href=&#34;https://launchpad.net/gcc-arm-embedded&#34;&gt;GCC ARM Embedded in Launchpad&lt;/a&gt;というプロジェクトがあるので簡単に用意出来ます。Ubuntu環境なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install gcc-arm-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストールできます。どうやらRSPiには不動小数点数計算ユニット(FPU)がついているようなのでhf(Hardware Float)で大丈夫みたいです。
HomebrewやPacmanにもパッケージはあるようです。&lt;/p&gt;

&lt;h2 id=&#34;rustのクロスコンパイラ:491c584db4092bf0e3567730a02ae671&#34;&gt;Rustのクロスコンパイラ&lt;/h2&gt;

&lt;p&gt;次にRustのクロスコンパイラですが、&lt;a href=&#34;https://github.com/brson/multirust&#34;&gt;multirust&lt;/a&gt;を使うと簡単にインストール出来ます。今回はunstable機能も使うのでnightlyコンパイラを使います。
因みに私が昔インストールしたmultirustだと古くて以下のコマンドが実行出来なかったので出来ない方はmultirustをアップデートして試してみて下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# インストール可能なターゲットを確認
$ multirust list-available-targets nightly
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-linux-gnu
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
# インストール
$ multirust add-target nightly arm-unknown-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ブートローダ:491c584db4092bf0e3567730a02ae671&#34;&gt;ブートローダ&lt;/h2&gt;

&lt;p&gt;まず、ブートローダが何をするものなのかから説明しましょう。興味がない人は飛ばして下さい。&lt;/p&gt;

&lt;h3 id=&#34;説明:491c584db4092bf0e3567730a02ae671&#34;&gt;説明&lt;/h3&gt;

&lt;p&gt;Raspberry PiにはCPUとGPUが両方ついているのでやや面倒です。&lt;/p&gt;

&lt;p&gt;CPU/GPUは電源がONになってすぐは何の機能もない、ただの命令を実行する機械です。メモリにすらアクセス出来ません。RSPiにSDカードを挿したところでSDカードのプロトコルを喋らないとそこに書いてあるプログラムが読めません。
SDカードのプロトコルを喋るプログラム(BIOS)は、RSPiに組込みで入っています。これは普段我々が使うメモリ(RAM)とは別の場所(ROM)に入っています。&lt;/p&gt;

&lt;p&gt;最初はGPUがそいつを起動し、(この時点ではCPUは起動してない)SDカードを読みにいきます。名前決め打ちでbootcode.binという名前のプログラムを、RAMではなくGPU(のL2キャッシュ)に直接ロードして実行します(メモリはまだ使えません)。
GPUのキャッシュは非常に小さいのでbootcode.binは小さなプログラムでないといけません。&lt;/p&gt;

&lt;p&gt;bootcode.binはRAMを有効にしてstart.elfをRAMに読み込み、GPUがそれを実行します。start.elfはRAMを使えるのである程度大きくても構いません。&lt;/p&gt;

&lt;p&gt;start.elfはconfig.txt、cmdline.txtとkernel.imgを読みにいき、kernel.imgを0x8000番地のメモリに配置します。そしてconfgやcmdlineに基いてCPUを設定してkernel.imgに引数を渡しつつ実行します。&lt;/p&gt;

&lt;p&gt;このkernel.imgは普段はLinuxカーネルなどのカーネル、今回は我々が作るLチカのプログラムです。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://kernhack.hatenablog.com/entry/2014/01/11/102237&#34;&gt;Raspberry Piのブートプロセスメモ - φ(・・*)ゞ ｳｰﾝ　カーネルとか弄ったりのメモ&lt;/a&gt;
昔はloader.binもあったようですが今はなくて大丈夫なようです。&lt;/p&gt;

&lt;h3 id=&#34;インストール:491c584db4092bf0e3567730a02ae671&#34;&gt;インストール&lt;/h3&gt;

&lt;p&gt;bootcode.bin, start.elfは&lt;a href=&#34;https://github.com/raspberrypi/firmware/tree/master/boot&#34;&gt;こちら&lt;/a&gt;から入手出来ます。config.txtとcmdline.txtはなくていいようです。&lt;/p&gt;

&lt;p&gt;こいつらはSDカードに放り込んでおきます。&lt;/p&gt;

&lt;h1 id=&#34;環境確認:491c584db4092bf0e3567730a02ae671&#34;&gt;環境確認&lt;/h1&gt;

&lt;p&gt;まずはコンパイラツールチェーンが正常に動くか確認しましょう。
以下にrustコードを。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(lang_items, asm)]
#![crate_type = &amp;quot;staticlib&amp;quot;]
#![no_std]

#[no_mangle]
pub extern fn main() {
    loop{}
}


#[no_mangle]
pub extern fn _sbrk() {}
#[no_mangle]
pub extern fn _exit() {}
#[no_mangle]
pub extern fn _kill() {}
#[no_mangle]
pub extern fn _getpid() {}


#[lang = &amp;quot;eh_personality&amp;quot;]
extern fn eh_personality() {}

#[lang = &amp;quot;panic_fmt&amp;quot;]
extern fn panic_fmt() {}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、今回作るのは &lt;code&gt;#![crate_type = &amp;quot;staticlib&amp;quot;]&lt;/code&gt; を使って静的リンクライブラリを作れと指定しています。そして &lt;code&gt;#[no_mangle] pub extern fn main() {&lt;/code&gt; でC言語と同じような規則でmain関数を定義する(アセンブラからmain関数を実行出来るようにする)と指定しています。
ベアメタル環境なのでファイルだとか諸々のものはなく、stdを使えないので &lt;code&gt;#![no_std]&lt;/code&gt; を指定してstdを使わずにcoreライブラリを使うようにしました。その代わり&lt;code&gt;#[lang = &amp;quot;eh_personality&amp;quot;] extern fn eh_personality() {}&lt;/code&gt; と &lt;code&gt;#[lang = &amp;quot;panic_fmt&amp;quot;] extern fn panic_fmt() {}&lt;/code&gt; を実装してあげないといけません(この実装はあまりよろしくないのですが今回はとりあえずコンパイルが通るようにということでこうしてます)。&lt;/p&gt;

&lt;p&gt;そしてよく分かってないのですがRustが &lt;code&gt;_sbrk&lt;/code&gt; 、 &lt;code&gt;_exit&lt;/code&gt; 、 &lt;code&gt;_kill&lt;/code&gt; 、 &lt;code&gt;_getpid&lt;/code&gt; のシンボルを捜しにいくのでとりあえずスタブを挿してます。&lt;/p&gt;

&lt;p&gt;no_mangle, no_std, lang_itemsについて詳しくは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/&#34;&gt;ドキュメント&lt;/a&gt;をご覧下さい。
&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/ffi.html&#34;&gt;他言語関数インターフェイス&lt;/a&gt;、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/no-stdlib.html&#34;&gt;No stdlib&lt;/a&gt;、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/lang-items.html&#34;&gt;言語アイテム&lt;/a&gt;あたりが参考になるかと思います。&lt;/p&gt;

&lt;p&gt;以下のようにコンパイル出来ればRustはOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustc --target arm-unknown-linux-gnueabihf --emit=obj test.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、elfファイルを作ります。これは以下のコマンドで出来ます。Cのクロスコンパイラを使っていますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles test.o -o kernel.elf
/usr/lib/gcc/arm-none-eabi/4.9.3/../../../arm-none-eabi/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000008000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-mで始まるオプションはRaspberry Piのチップ固有の指定、 -nostartfiles はベアメアルで動かすのに必要な指定ですね。&lt;/p&gt;

&lt;p&gt;最後にelfファイルからimgファイルを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arm-none-eabi-objcopy kernel.elf -O binary kernel.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私もよく分かってないのですがobjファイルが不完全なバイナリファイル、elfが完全なバイナリファイル、imgがelfを実際のメモリに展開した時のものそのままなんですかね。
逆にいうとOSのない環境で動かすには生のimgが欲しいけどそれを作るのは難しいから一旦elfを作ってそこからimgを生成している？&lt;/p&gt;

&lt;p&gt;さて、とりあえずここまで来れば環境は整いました。あとはプログラムを書くだけです。&lt;/p&gt;

&lt;h1 id=&#34;lチカ:491c584db4092bf0e3567730a02ae671&#34;&gt;Lチカ&lt;/h1&gt;

&lt;p&gt;RSPiにくっついているLEDはデバイスとしてはGPIOのように見えるみたいです。
そしてGPIOはMemory Mapped IO、特定の位置のメモリを読み書きすることでデバイスをいじれるようになってるみたいです。
このセットアップは誰がやったんだって気になりますがBIOSなんですかね。&lt;/p&gt;

&lt;p&gt;さて、この「特定の位置のメモリ」ですが、Raspberry Pi 1だと &lt;code&gt;0x20200000&lt;/code&gt; から始まるアドレス、のようです。2だと &lt;code&gt;3F200000&lt;/code&gt; のよう。&lt;/p&gt;

&lt;p&gt;そして0x20200000からいくつかの32bitレジスタが配列のように並んでいる訳ですがこれまたRSPi+やRSP 2とRSPi 1はLEDに対応するレジスタがやや違うようです。&lt;/p&gt;

&lt;p&gt;面倒なのでコピペで済ませると(私はCのコードからRustに移植しました。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Raspberry Pi2
//pub const GPIO_BASE: u32 = 0x3F200000;
// other
pub const GPIO_BASE: u32 = 0x20200000;



// Raspberrp Pi+ or Raspberry Pi2
//pub const LED_GPFSEL: isize   = GPIO_GPFSEL4;
//pub const LED_GPFBIT: i32     = 21;
//pub const LED_GPSET: isize    = GPIO_GPSET1;
//pub const LED_GPCLR: isize    = GPIO_GPCLR1;
//pub const LED_GPIO_BIT: isize = 15;
//  other
pub const LED_GPFSEL: isize = GPIO_GPFSEL1;
pub const LED_GPFBIT: i32 = 18;
pub const LED_GPCLR: isize = GPIO_GPCLR0;
pub const LED_GPSET: isize = GPIO_GPSET0;
pub const LED_GPIO_BIT: i32 = 16;

pub const GPIO_GPFSEL0: isize   = 0;
pub const GPIO_GPFSEL1: isize   = 1;
pub const GPIO_GPFSEL2: isize   = 2;
pub const GPIO_GPFSEL3: isize   = 3;
pub const GPIO_GPFSEL4: isize   = 4;
pub const GPIO_GPFSEL5: isize   = 5;
pub const GPIO_GPSET0: isize    = 7;
pub const GPIO_GPSET1: isize    = 8;
pub const GPIO_GPCLR0: isize    = 10;
pub const GPIO_GPCLR1: isize    = 11;
pub const GPIO_GPLEV0: isize    = 13;
pub const GPIO_GPLEV1: isize    = 14;
pub const GPIO_GPEDS0: isize    = 16;
pub const GPIO_GPEDS1: isize    = 17;
pub const GPIO_GPREN0: isize    = 19;
pub const GPIO_GPREN1: isize    = 20;
pub const GPIO_GPFEN0: isize    = 22;
pub const GPIO_GPFEN1: isize    = 23;
pub const GPIO_GPHEN0: isize    = 25;
pub const GPIO_GPHEN1: isize    = 26;
pub const GPIO_GPLEN0: isize    = 28;
pub const GPIO_GPLEN1: isize    = 29;
pub const GPIO_GPAREN0: isize   = 31;
pub const GPIO_GPAREN1: isize   = 32;
pub const GPIO_GPAFEN0: isize   = 34;
pub const GPIO_GPAFEN1: isize   = 35;
pub const GPIO_GPPUD: isize     = 37;
pub const GPIO_GPPUDCLK0: isize = 38;
pub const GPIO_GPPUDCLK1: isize = 39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうなります(cfgを使ってないです。ごめんなさい。)。&lt;/p&gt;

&lt;p&gt;次にLチカですが、
LEDに対応するGPIOをwriteに初期化する→ループ{LEDに対応するGPIOをセットする → スリープ → LEDに対応するGPIOをクリアする → スリープ}&lt;/p&gt;

&lt;p&gt;のプログラムを書きます。&lt;/p&gt;

&lt;p&gt;色々試したのですが簡単なプログラムだと最適化で消えてしまうので消えないように工夫する必要があります。&lt;/p&gt;

&lt;p&gt;スリープはとりあえずタイマーを使わずに空ループを回すのですが、ループの中身は空インラインアセンブラを使うと消えないようです。&lt;/p&gt;

&lt;p&gt;また、メモリへの書き込みは&lt;a href=&#34;https://doc.rust-lang.org/core/intrinsics/&#34;&gt;intrinsic&lt;/a&gt;の&lt;a href=&#34;https://doc.rust-lang.org/core/intrinsics/fn.volatile_store.html&#34;&gt;volatile_store&lt;/a&gt;を使います。&lt;/p&gt;

&lt;p&gt;ということでコードは以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(lang_items, asm, core_intrinsics)]
#![crate_type = &amp;quot;staticlib&amp;quot;]
#![no_std]

use core::intrinsics::volatile_store;

// Raspberry Pi2
//pub const GPIO_BASE: u32 = 0x3F200000;
// other
pub const GPIO_BASE: u32 = 0x20200000;



// Raspberrp Pi+ or Raspberry Pi2
//pub const LED_GPFSEL: isize   = GPIO_GPFSEL4;
//pub const LED_GPFBIT: i32     = 21;
//pub const LED_GPSET: isize    = GPIO_GPSET1;
//pub const LED_GPCLR: isize    = GPIO_GPCLR1;
//pub const LED_GPIO_BIT: isize = 15;
//  other
pub const LED_GPFSEL: isize = GPIO_GPFSEL1;
pub const LED_GPFBIT: i32 = 18;
pub const LED_GPCLR: isize = GPIO_GPCLR0;
pub const LED_GPSET: isize = GPIO_GPSET0;
pub const LED_GPIO_BIT: i32 = 16;

pub const GPIO_GPFSEL0: isize   = 0;
pub const GPIO_GPFSEL1: isize   = 1;
pub const GPIO_GPFSEL2: isize   = 2;
pub const GPIO_GPFSEL3: isize   = 3;
pub const GPIO_GPFSEL4: isize   = 4;
pub const GPIO_GPFSEL5: isize   = 5;
pub const GPIO_GPSET0: isize    = 7;
pub const GPIO_GPSET1: isize    = 8;
pub const GPIO_GPCLR0: isize    = 10;
pub const GPIO_GPCLR1: isize    = 11;
pub const GPIO_GPLEV0: isize    = 13;
pub const GPIO_GPLEV1: isize    = 14;
pub const GPIO_GPEDS0: isize    = 16;
pub const GPIO_GPEDS1: isize    = 17;
pub const GPIO_GPREN0: isize    = 19;
pub const GPIO_GPREN1: isize    = 20;
pub const GPIO_GPFEN0: isize    = 22;
pub const GPIO_GPFEN1: isize    = 23;
pub const GPIO_GPHEN0: isize    = 25;
pub const GPIO_GPHEN1: isize    = 26;
pub const GPIO_GPLEN0: isize    = 28;
pub const GPIO_GPLEN1: isize    = 29;
pub const GPIO_GPAREN0: isize   = 31;
pub const GPIO_GPAREN1: isize   = 32;
pub const GPIO_GPAFEN0: isize   = 34;
pub const GPIO_GPAFEN1: isize   = 35;
pub const GPIO_GPPUD: isize     = 37;
pub const GPIO_GPPUDCLK0: isize = 38;
pub const GPIO_GPPUDCLK1: isize = 39;

#[no_mangle]
pub extern fn main() {
    // GPIO_BASEを符号無し32bit整数を指すポインタにキャストする
    let gpio = GPIO_BASE as *const u32;
    // offsetを使うことでCの配列のようにポインタの何番地か先のメモリを指せる
    let init   = unsafe {gpio.offset(LED_GPFSEL) as *mut u32};
    let led_on = unsafe { gpio.offset(LED_GPSET) as *mut u32 };
    let led_off = unsafe { gpio.offset(LED_GPCLR) as *mut u32 };

    // LEDのGPIOを書き込みに設定
    unsafe{
        volatile_store(init, *(init) | 1 &amp;lt;&amp;lt; LED_GPFBIT);
    }

    loop {
        // LEDをOFFにする
        unsafe {
            volatile_store(led_off, 1 &amp;lt;&amp;lt; LED_GPIO_BIT);
        }
        // 適当な長さbusy loopで時間を空ける
        for _ in 1..500000 {
            unsafe { asm!(&amp;quot;&amp;quot;); }
        }

        // LEDをONにする
        unsafe {
            volatile_store(led_on, 1 &amp;lt;&amp;lt; LED_GPIO_BIT);
        }
        // また適当な長さ空ける
        for _ in 1..500000 {
            unsafe { asm!(&amp;quot;&amp;quot;); }
        }
    }
}


#[no_mangle]
pub extern fn _sbrk() {}
#[no_mangle]
pub extern fn _exit() {}
#[no_mangle]
pub extern fn _kill() {}
#[no_mangle]
pub extern fn _getpid() {}


#[lang = &amp;quot;eh_personality&amp;quot;]
extern fn eh_personality() {}

#[lang = &amp;quot;panic_fmt&amp;quot;]
extern fn panic_fmt() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをkernel.rsとして保存し、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustc  -O --target arm-unknown-linux-gnueabihf --emit=obj kernel.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でコンパイルします。どうやら使っていないのにrustが余計なシンボルを付けるようで、-Oをつけてそいつらをoptimize outさせないとコンパイルが通りませんでした。
この辺、コンパイラのバージョンに依存しそうで怖いですね。&lt;/p&gt;

&lt;p&gt;さて、あとは先程と同じく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles kernel.o -o kernel.elf
$ arm-none-eabi-objcopy kernel.elf -O binary kernel.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でイメージを作ってあげます。&lt;/p&gt;

&lt;p&gt;そしたらこのkernel.imgをSDカードに放り込みます。&lt;/p&gt;

&lt;p&gt;SDカードの中身はこうなっている筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls  /media/kim/6F6F-DCD9
bootcode.bin  kernel.img  start.elf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このSDカードをRSPiに挿して、電源を繋いであげるとLEDがすごい勢いでチカチカする筈です。そうなったら成功です。おめでとうございます。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:491c584db4092bf0e3567730a02ae671&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/RaspPi&#34;&gt;ここ&lt;/a&gt;に置いておきます。とはいってもそのままではなくてCargo化したりMakefileを書いたり色々しています。&lt;/p&gt;

&lt;p&gt;今回の作業をするにあたって参考にした資料のURLを挙げておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valvers.com/open-software/raspberry-pi/step01-bare-metal-programming-in-cpt1/&#34;&gt;Step01 – Bare Metal Programming in C Pt1 – Valvers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valvers.com/open-software/raspberry-pi/step02-bare-metal-programming-in-c-pt2/&#34;&gt;Step02 – Bare Metal Programming in C Pt2 – Valvers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.thiago.me/raspberry-pi-bare-metal-programming-with-rust/&#34;&gt;Raspberry Pi Bare Metal Programming with Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.bobuhiro11.net/2014/01-13-baremetal.html&#34;&gt;piでベアメタルプログラミング - bobuhiro11&amp;rsquo;s diary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>LXDがリリースされたらしい</title>
      <link>/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii</link>
      <pubDate>Thu, 14 Apr 2016 22:51:20 +0900</pubDate>
      
      <guid>/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii</guid>
      <description>&lt;p&gt;κeenです。頭痛い。LXDがリリースされたようなので1つ記事をば。
LXDはLinuxで動く軽量仮想化コンテナ、LXCのラッパでREST APIとCLIが提供されています。&lt;/p&gt;

&lt;p&gt;LXC、LXD共にUbuntuの開発元、Canonicalが開発しています。
LXCについては初期のDockerがバックエンドに使っていたので知名度もそこそこあるかと思いますが、
そのラッパであるLXDはこの度ようやく正式リリースされました。&lt;/p&gt;

&lt;p&gt;既にDockerがあるのになぜわざわざ新たにLXDを使うんだって気もしますが、対象とするレイヤーが違います。
Dockerはアプリケーションコンテナ、つまりアプリケーションを動かすためのプロセスより強い分離環境を提供するために使われますが
LXDはシステムコンテナ、つまり仮想マシンより軽い仮想化環境を提供します。
なのでファイルシステムはCopy on Writeしませんし一度終了したコンテナは破棄されず、再起動出来ます。
詳しくはここら辺に書いてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.stgraber.org/2016/03/11/lxd-2-0-blog-post-series-012/&#34;&gt;LXD 2.0: Blog post series [0/12] | Stéphane Graber&amp;rsquo;s website&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1つDockerとLXDの違いの分かりやすい例を出すと、それぞれのOpenStackでの立ち位置を見ると面白そうです。
Dockerは&lt;a href=&#34;https://wiki.openstack.org/wiki/Magnum&#34;&gt;OpenStack Magnum&lt;/a&gt;でOpenStack上で扱えますが、OpenStackのコンピュートノード &lt;strong&gt;上&lt;/strong&gt; で動作します。
一方LXDは&lt;a href=&#34;https://insights.ubuntu.com/2015/05/06/introduction-to-nova-compute-lxd/&#34;&gt;nova-compute-lxd&lt;/a&gt;でOpenStack上で扱えますが、 OpenStackのコンピュートノード &lt;strong&gt;として&lt;/strong&gt; 動作します。
なんだかんだ重いVMがコンテナのお陰で軽くなる訳です。そして勿論のこと、Docker in LXDなんかも出来るのでちゃんと共存出来ます。&lt;/p&gt;

&lt;p&gt;今のところUbuntu 14.04あるいは未来の16.04でリリースされているようです。Ubuntu 15.10をお使いの方は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add-apt-repository ppa:ubuntu-lxc/lxd-stable
apt-get update
apt-get dist-upgrade
apt-get install lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストール出来るようです(&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;マニュアル&lt;/a&gt;より)。
LXDはLXCのラッパでありながらもliblxcにしか依存しないのでlxc自体はインストールする必要はありません。&lt;/p&gt;

&lt;p&gt;さてこれでLXDがインストールされた訳ですが、LXDはコンテナなどのリソースを管理するデーモンとそのCLIから成ります。
CLIのコマンド名はなんと&lt;code&gt;lxc&lt;/code&gt;です。LXCのコマンド群が&lt;code&gt;lxc-*&lt;/code&gt;なので非常に勘違いしやすいですね。&lt;/p&gt;

&lt;p&gt;詳しいコマンド群は&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;マニュアル&lt;/a&gt;を読めばいいのですがそれだけだとお粗末なので多少紹介します。&lt;/p&gt;

&lt;p&gt;インストール直後は新規に作ったグループを今のログインセッションに反映させる必要があるので&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;newgrp lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする必要があります。その次は初期化が必要になります。&lt;code&gt;lxd init&lt;/code&gt;です。いくつか質問されますがデフォルトの回答を選んでいけば問題なさそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
Name of the storage backend to use (dir or zfs): zfs
error: The requested backend &#39;zfs&#39; isn&#39;t available on your system (missing tools).
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? yes
Address to bind LXD to (not including port): 0.0.0.0
Port to bind LXD to (8443 recommended): 
Invalid input, try again.

Port to bind LXD to (8443 recommended): 8443
Trust password for new clients: 
Again: 
Do you want to configure the LXD bridge (yes/no)? yes
Warning: Stopping lxd.service, but it can still be activated by:
  lxd.socket
LXD has been successfully configured.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntuでzfsが使えるのは16.04からなので15.10では使えませんでした。また、ブリッジのコンフィギュアにはウィザードが出てきます。&lt;/p&gt;

&lt;p&gt;これで初期化が終わり、コンテナを立ち上げる準備が出来ました。&lt;/p&gt;

&lt;p&gt;コンテナはイメージを元に立ち上げるのですが、今回はイメージはネット上のものから立ち上げます。
インストール時点でいくつかサーバが登録されているので名前で指定してあげるだけでよいようです。
他にイメージを使う方法はリモートのLXDをサーバとして使う、手動でファイルからインポートするなどがあるようです。&lt;/p&gt;

&lt;p&gt;ということでコンテナの立ち上げはこうです。折角なので未来のUbuntu 16.04を使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc launch ubuntu:16.04 future-ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドでビルトインの&amp;rdquo;Ubuntu&amp;rdquo;サーバにある16.04バージョンのイメージをfuture-ubuntuという名前のコンテナで立ち上げます。&lt;/p&gt;

&lt;p&gt;これでコンテナが立ち上がりました。確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc list
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
|     NAME      |  STATE  |              IPV4              |                     IPV6                     |    TYPE    | SNAPSHOTS |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
| future-ubuntu | RUNNING | 10.197.202.251 (eth0)          | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0         |
|               |         | 10.0.3.1 (lxcbr0)              |                                              |            |           |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにローカルにあるイメージも確認しましょう。インポートまで終わっているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc image list
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |                DESCRIPTION                |  ARCH  |   SIZE   |         UPLOAD DATE          |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
|       | 6cb0ba80a5fe | no     | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立ち上げたコンテナにログインしてみましょう。これはDockerをお使いの方は馴染があるんじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc exec future-ubuntu -- /bin/bash
root@future-ubuntu:~# lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu Xenial Xerus (development branch)
Release:	16.04
Codename:	xenial
root@future-ubuntu:~# exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと16.04になっているようです。&lt;/p&gt;

&lt;p&gt;コンテナの停止は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc stop future-ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。ちゃんと止まったか確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc list
+---------------+---------+------+------+------------+-----------+
|     NAME      |  STATE  | IPV4 | IPV6 |    TYPE    | SNAPSHOTS |
+---------------+---------+------+------+------------+-----------+
| future-ubuntu | STOPPED |      |      | PERSISTENT | 0         |
+---------------+---------+------+------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんとSTATEがSTOPPEDになってますね&lt;/p&gt;

&lt;p&gt;もう一度起動してみます&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc start future-ubuntu
sudo lxc list
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
|     NAME      |  STATE  |              IPV4              |                     IPV6                     |    TYPE    | SNAPSHOTS |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
| future-ubuntu | RUNNING | 10.197.202.251 (eth0)          | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0         |
|               |         | 10.0.3.1 (lxcbr0)              |                                              |            |           |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次はコンテナを削除します&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc stop future-ubuntu
sudo lxc delete future-ubuntu
sudo lxc list
+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
sudo lxc image list
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |                DESCRIPTION                |  ARCH  |   SIZE   |         UPLOAD DATE          |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
|       | 6cb0ba80a5fe | no     | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナが消えただけでイメージは残るんですね。&lt;/p&gt;

&lt;p&gt;さて、いかがでしょうか。軽量なVMと考えれば非常に手軽で中々面白いんじゃないでしょうか。
因みにコンテナとホスト間でのファイルのやりとりも簡単(&lt;code&gt;lxc file pull/push&lt;/code&gt;)なようなのでコンテナ内でコンパイラを動かしてホストにもってくるとかをすれば開発環境の隔離環境としても使えそうです。&lt;/p&gt;

&lt;p&gt;時間があればもう少し詳細に検証してみます。SNAPSHOTとかも試してみたかった。それでは今日はこの辺で。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>テストについて、Scalaと。</title>
      <link>/slide/tesutonitsuite_Scalato_/</link>
      <pubDate>Tue, 12 Apr 2016 22:31:51 +0900</pubDate>
      
      <guid>/slide/tesutonitsuite_Scalato_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# テストについて、Scalaと。
----------------------
サイバーエージェント アドテクスタジオ  
ScalaMeetUp テスト回

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
   + 基盤開発グループでScalaで基盤開発してます
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# Scalaのテスト
---------------

* ScalaTest
  + 機能豊富
  + 複数のテストスタイルを選べる
  + 他のフレームワークとの統合がある
* Specs2
  + 普通に使いやすい
* 他にもScalaCheck、JUnit、Gatlingなどなど


# ScalaTestのスタイルたち
-----------

* FunSuite
  + xUnitっぽいらしい
* FlatSpec
  + xUnitからBDDに移行した人向けらしい
* FunSpec
  + RSpecっぽいBDD用の


# ScalaTestのスタイルたち
-----------

* WordSpec
  + Specs2に似てる。
* FreeSpec
  + 何段にでもネスト出来る。自由。
* Spec
  + テスト=メソッド。速いらしい。


# ScalaTestのスタイルたち
-----------
* PropSpec
  + プロパティベースのテスト。ScalaCheckとの統合。
* FeatureSpec
  + シナリオテスト。

# その他の機能
-------------

* mockitoのシュガー
* Matcher DSL
* 複数のランナー（複数のツールとの統合）


# Axionのテスト
コード紹介を多めに
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 単体テスト
---------------

* 普通の単体テストはWordSpec
* ホーアの3つ組に基いて事前条件、コマンド、事後条件(不変条件)に分ける
  + 「{事前条件}が成り立つ時{コマンド}を実行し、停止するなら{事後条件(不変条件)}が成り立つ」の列挙
* [テストについて考えてみた | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/tesutonitsuitekangaetemita/)
* コマンドの実行と事後条件への表明を明確に分離
* テストの分け方に試行錯誤


# 事前条件
----------

* 基本的にはmockitoをフルに使う
* テストは並行に走るのでテストケース毎にモックを準備
* コンテキストの共有は基本的にはしない
  + 情報の局所性を上げて何をテストするかを理解しやすくする
  + 逆にノイズが乗ってわかりにくい？
* メソッドの実行に必要な引数と環境全てを構築する


# コマンドの実行
---------------

* 例外が起きないことだけ表明する
* 結果はvarに保存して外に持ち出す。


# 事後条件
----------

* コマンドを実行した結果に対する表明
* 環境に対する表明
  + 環境が変化した/しなかった
  + 依存オブジェクトのメソッドが呼ばれた/なかった


メソッド毎にテストケースをグルーピング

``` scala
&#34;Class#method&#34; when {
  &#34;precondition&#34; should {
    ...
    var ret: Type = null
    &#34;method invocation&#34; in {
      ret = ...
    }

    &#34;post conditions&#34; in {
      ...
    }
  }
}

```


# Tips
------

* エディタでテンプレートを用意しておくと楽
  + ensimeのテストテンプレートとか
* やや冗長でも頭を使わずに書ける/理解出来るテストを書く


# ユーティリ
---------------

* ユーティリティのテストはPropSpec
* ユーティリティ = 汎用的(文脈に依存しない)、副作用がない、小さい
  + まさにプロパティベースのテストに向く
* ほとんどGenerator Driven Test
  + 半分くらいScalaCheckの機能を使う
* 一部Tebale Driven Test
  + Generatorがコーナーケースを生成してくれない時がある


# 他のテスト
------------

* インテグレーションテスト/パフォーマンステストはGatling(の予定)
* Gatlingでエラーレート、パーセンタイル、レスポンスなどをテスト出来る
* パフォーマンステストは実行インスタンスを固定しないといけない問題が…
* シナリオテストはない(APIがReadのみなため)


# 他のテスト
---------------

* AxionはThriftプロトコルだがGatlingのAPIをいくつか実装すればGatlingを独自プロトコルに対応出来る
  + 実装量はほとんどない
  + 2~3個DSLを作るだけ
  + 簡単とはいってない(ドキュメントがないつらさ)
* Gatlingのおかげでパフォーマンスに対する表明やリクエスト毎のチェックなどが簡単
* そのうちノウハウを公開するかも？
  + 2.1.Xと2.2.XでAPIが違う問題も…


# まとめ
--------

* ScalaTestを紹介したよ
* ScalaTestの実用例を紹介したよ
* Gatlingについて紹介したよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Mirah関連ツールまとめ</title>
      <link>/blog/2016/04/04/mirahkanrentsu_rumatome</link>
      <pubDate>Mon, 04 Apr 2016 01:16:31 +0900</pubDate>
      
      <guid>/blog/2016/04/04/mirahkanrentsu_rumatome</guid>
      <description>

&lt;p&gt;κeenです。寝付けないのでMirah関連ツールについてまとめようかと。
とはいってもそんなにないのですが。Mirahについて知らない人は適当にググって下さい。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラ:0faeefa240fb02d643ee85f5ee89e65e&#34;&gt;コンパイラ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mirah/mirah/releases&#34;&gt;Releases · mirah/mirah&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本家のものを使うべし&lt;/p&gt;

&lt;h1 id=&#34;開発支援:0faeefa240fb02d643ee85f5ee89e65e&#34;&gt;開発支援&lt;/h1&gt;

&lt;h2 id=&#34;netbeansプラグイン:0faeefa240fb02d643ee85f5ee89e65e&#34;&gt;NetBeansプラグイン&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/shannah/mirah-nbm&#34;&gt;shannah/mirah-nbm: Netbeans Module for Mirah&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このプラグインのためにパーサのAPIに変更を加える議論がされたりしていて恐らく現状一番まともに動くやつと思う。&lt;/p&gt;

&lt;h2 id=&#34;emacs:0faeefa240fb02d643ee85f5ee89e65e&#34;&gt;Emacs&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/mirah-mode.el&#34;&gt;KeenS/mirah-mode.el:&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ruby-modeにやっつけで雑に機能を追加したやつ。コメントのハイライトにコーナーケース(&lt;code&gt;/*/*/**/*/*/&lt;/code&gt; みたいなの)があったり雑。
まあ、とりあえずそれっぽくは動く&lt;/p&gt;

&lt;h1 id=&#34;ビルドツール統合:0faeefa240fb02d643ee85f5ee89e65e&#34;&gt;ビルドツール統合&lt;/h1&gt;

&lt;h2 id=&#34;gradle:0faeefa240fb02d643ee85f5ee89e65e&#34;&gt;Gradle&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ysb33r/gradle-mirah-plugin&#34;&gt;ysb33r/gradle-mirah-plugin: Gradleplugin to compile Mirah source code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近作られたやつ。&lt;a href=&#34;https://github.com/KeenS/mirah_sample_gradle&#34;&gt;軽く使てみた&lt;/a&gt;ら簡単に動いたし良さげ。&lt;/p&gt;

&lt;h2 id=&#34;maven:0faeefa240fb02d643ee85f5ee89e65e&#34;&gt;Maven&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mirah/maven-mirah-plugin&#34;&gt;mirah/maven-mirah-plugin: Plugin to compile Mirah source with Maven&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;公式サポートだし良さげ。&lt;/p&gt;

&lt;h1 id=&#34;その他:0faeefa240fb02d643ee85f5ee89e65e&#34;&gt;その他&lt;/h1&gt;

&lt;h2 id=&#34;コードトランスレート:0faeefa240fb02d643ee85f5ee89e65e&#34;&gt;コードトランスレート&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/captn3m0/java2mirah&#34;&gt;captn3m0/java2mirah: A java to mirah transpiler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;javaからMirahに変換してくれるツール。試したことはないけどそんなに期待はしてない。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;私が把握してるのはこれくらい。ビルドツール統合と開発支援があればどうにかなるっしょ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLで函数型的正規表現マッチ</title>
      <link>/slide/SMLdekansuukatatekiseikihyougenmatchi/</link>
      <pubDate>Tue, 29 Mar 2016 01:44:39 +0900</pubDate>
      
      <guid>/slide/SMLdekansuukatatekiseikihyougenmatchi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLで函数型的正規表現マッチ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# 元ネタ
--------
[関数型的正規表現マッチ | Preferred Research](https://research.preferred.jp/2010/11/regexp-play/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 正規表現
----------

必要最小限の要素は5つだけ

1. 空文字
2. アルファベット1つ
3. 正規表現のOR結合
4. 正規表現のAND結合
5. 正規表現の繰り返し


# SMLで表してみる
-----------------

``` sml
datatype  reg
  = Empty
  | Sym of t
  | Or of reg * reg
  | And of reg * reg
  | Rep of reg
```

# 本当に大丈夫？

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# `/(a|b)*c/`
-----------

``` sml
And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)
```


# `/https?:\/\/[a-z]*/`
-----------

``` sml
val a_z = Or(Sym&#34;a&#34;, Or(Sym &#34;b&#34;, Or(Sym &#34;d&#34;, ...)))
And(Sym &#34;http&#34;, And(Or(Sym &#34;s&#34;, Empty), And(Sym &#34;://&#34;, Rep a_z)))
```


# 実装してみる

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# `Empty`, `Sym`, `Or`
----------------
trivial

``` sml
fun match Empty u = isEmpty u
  | match (Sym a) u = a = u
  | match (Or(p, q)) u = match p u orelse match q u
```


# `And`
--------

`And(p, q)` に入力が`u`の時`p`がどこまでマッチするか分からないので

* `u` から一部取ってきて`p`にマッチするか確認
* 残りの文字列が`q`にマッチするか確認


# `And`
--------
`match (And (Sym &#34;a&#34;, Sym &#34;b&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;&#34;)、(Sym &#34;b&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;b&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;b&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;abd&#34;)、(Sym &#34;b&#34;と&#34;&#34;)



# `And`
--------

``` sml
  | match (And(p, q)) u = 
    withSprits u (fn (u1, u2) =&gt; 
      match p u1 andalso match q u2)

```

`withSprits u f` は`u`を2分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。


# `Rep`
-------

`Rep(r)` に入力が`u`の時、`r`がどこまでマッチするかも`Rep`が何回繰り返すかも分からないので

* `u` を任意の個数に分割し
* その全てが`r`にマッチするか確認



# `Rep`
--------
`match (Rep (Sym &#34;a&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;b&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)




# `Rep`
--------

``` sml
  | match (Rep(r)) u =
    withParts u (fn input =&gt;
      List.all (match r) input)
```

`withParts u f` は`u`を分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。



# チェック
----------

```
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbca&#34;;
val it = false : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbc&#34;;
val it = true : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;c&#34;;
val it = true : bool
```


# まとめ
--------

* 適当に実装したら正規表現も簡単に実装出来るよ
* SMLで正規表現実装したよ


# 参考
------

* [KeenS/regexp](https://github.com/KeenS/regexp)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ビッグデータしないDrill、ローカルで快適に使うために</title>
      <link>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</link>
      <pubDate>Sun, 06 Mar 2016 14:54:30 +0900</pubDate>
      
      <guid>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ビッグデータしないDrill、ローカルで快適に使うために
----------------------
[Tokyo Apache Drill Meetup](http://drill.connpass.com/event/27414/)  
2016-03-22

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + サイバーエージェントのエンジニア
   + アドテクスタジオ所属
   + データエンジニアじゃなくてもデータを触ることはある


# なぜローカルか
---------------

* ビッグデータ重い
* 使いたいデータが絞れる時には大袈裟
  + 「売り上げ上位1000のユーザの行動」とか
* 同じようなクエリの重複
  + 新しいテーブル作れないDBとかview作れないDBとか
* 結果をRに渡したりとかが面倒
  + CSVダウンロードがGUI

# キャッシュ的な
----------------

```
+---------------------------------+
| BIG DATA (BigQuery, Spark, etc) |
+---------------------------------+
        ^ |  ^  |
        | |  |  |
        | v  |  v
   +-------------------+
   | ローカルキャッシュ | &lt;- ???
   +-------------------+
     ^ | ^ | ^ | ^ |
     | v | v | v | |
     +----------+  |
     |   自分   |  |
     +----------+  v
     +---+    +-----+
     | R | &lt;--| CSV |
     +---+    +-----+
```


# やりたいこと
--------------

* パパッっと処理を始められる
  + だいたい「CSVを簡単に読める」に同じ
  + たまにJSONとか
* 簡単に処理出来る
  + 自分が馴れているかどうか
* CSVを吐ける
  + 最後はRに渡したい


# 候補
-------

* ローカルMySQL
  + 事前のScheme定義が必要
* R
  + 扱い馴れない
* SQLite
  + 事前のScheme定義が必要
* (Python)
  + あまり向いてない？



&lt;pre style=&#39;font-size: 200%&#39;&gt;
＿人人人人人人人＿
＞　突然のDrill　＜
￣Y^Y^Y^Y^Y^Y￣
&lt;/pre&gt;


# なぜ Drill
------------

* (デーモン立ち上げておけば)サクっと始められる
* CSVをそのまま読める
  + Schema定義がいらない!
* ついでにJSONも読める
* 馴れたSQLで操作出来る
* CSV吐ける


# Drillを便利にするために
-------------------------

* いくつかのシェル関数
* Drillのデーモン/クライアントの起動を便利に

```sh
drill-start() {
    ~/compile/zookeeper-3.4.8/bin/zkServer.sh start
    drillbit.sh start
}

drill-cli() {
    sqlline -u jdbc:drill:zk=localhost:2181
}

drill-web() {
   firefox http://localhost:8047
}
```


# もっと便利に
--------------

* REPLでの操作が面倒
  + ヒストリ遡るのとか
  + ミスった時の訂正が地味に不便
* シンタックスハイライト欲しい
* 馴れたツールで編集したい


# sql-drill.el
--------------

* [KeenS/sql-drill.el](https://github.com/KeenS/sql-drill.el)
* Emacsのsql-modeのDrillサポート
  + emacsのsql-modeは拡張可能
* シンタックスハイライト
* REPL


# DEMO
------
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# まとめ
--------

* ローカルでデータ分析したい時があるよ
* その時にDrillは便利だよ
* Emacs向けのDrillプラグイン作ったよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustとは何か。どんな言語か。</title>
      <link>/slide/Rusttohananika_donnagengoka_/</link>
      <pubDate>Sun, 06 Mar 2016 05:27:39 +0900</pubDate>
      
      <guid>/slide/Rusttohananika_donnagengoka_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustとは何か。どんな言語か。
----------------------
[異種プログラミング言語格闘勉強会](http://kbkz.connpass.com/event/26677/)  
2016-03-20


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# Rustって?
----------

* システムプログラミング言語
* だけど函数型言語から影響を受けた
* 安全かつ高速
* ゼロコスト抽象化


## システムプログラミング言語
---------------------------

* スレッドはネイティブ、Cとの相互呼び出し、小さなバイナリサイズ
* ゲームエンジンとか作れる([piston](https://github.com/PistonDevelopers/piston))
* レンダリングエンジンとか作れる([Servo](https://github.com/servo/servo))
* Lチカとか出来る
* OSとか作れる([Redox](https://github.com/redox-os/redox))


## 函数型言語的からの影響
-----------------------

最近ではめずらしくなくなった


* デフォルトイミュータブル
* 代数的データ型
* コンビネータ
* トレイト (型クラス)


## 安全かつ高速
--------------

* データ競合が起きない
  + 所有権システム
  + だいたいコンパイル時Read Writeロック
  + Read only参照複数 or Write可能参照1つ
* LLVMベースの強力な最適化
* スレッド周辺のAPIが揃ってる


## ゼロコスト抽象化
------------------
省略

* [Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/)


# Rustの誤解
-----------

* 安定してないって聞いたよ
* 函数型言語ってホント?
* GCがなくて大丈夫?
* 継承がなくて大丈夫?


## 安定してないって聞いたよ

* 1.0以前の話
* 1.0(2015-05以降)はAPIの変更がルール化された
* 新規APIのstablizeはあれどdeprecateはまれ


## 函数型言語ってホント?

* 函数型言語の機能をつまみぐいしてるだけ
* 標準ライブラリとかはバリバリ手続的
* Lispよりも函数型言語っぽくない。
* とはいえ抽象力は高いのでそこまで煩雑にはならない


## GCがなくて大丈夫?

* GCはなくてもメモリ管理は自動でする
* コンパイル時にメモリ管理
  + コンパイラが必要なところにmalloc/freeを挟むイメージ
* むしろメモリ以外(fd、ロックなど)も自動管理
  + GCがある言語よりリソース管理の自動化が徹底してる
* [リージョンについて | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/)


## 継承がなくて大丈夫?

* むしろ継承必要？インターフェースだけでよくない？
* Rustはデータ型とメソッドを分離するので継承のメリットそんなにない
  + トレイトが強力ともいう
* 逆にサブタイプ関係による複雑さの上昇のデメリットが多い
  + 3回以上継承してるの全部把握出来るの？
* ジェネリクスとかはあるよ


# Rustをとりまく環境
-------------------

* racer/rustfmt
* Cargo
* crates.io
* [Rust Playground](https://play.rust-lang.org/)
* The Rust Programming Language



# racer/rustfmt
---------------

* racerがコーディング支援ツール
  + 補完
  + 定義元ジャンプ
  + 型情報
  + 各種エディタプラグインあり
* rustfmtがコードフォーマッタ
  + エディタプラグインあり
  + ビルドツール連携あり


# Cargo
-------

* Rustのビルドツール兼パッケージマネージャ
* これだけ覚えとけば困らない


# crates.io
-----------

* Rustパッケージのセントラルレポジトリ
* 必ずビルドが通るような工夫
  + cargo yank
  + 同じライブラリの違うバージョンがいても大丈夫
* Cargoとの連携
* Cargoからpublishも可能


# [Rust Playground](https://play.rust-lang.org/)
---------------------------------------

* webからRustを試せる
* とりあえず試すと色々分かる
  + 所有権難しいとか


# [The Rust Programming Language](https://doc.rust-lang.org/book/)
------------------------------

* Rustの入門用ドキュメント
* とりあえずこれ読めば始められる
* [和訳版](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)もある
  + [GitHub](https://github.com/rust-lang-ja/the-rust-programming-language-ja)で作業中
  + これの宣伝しに来ただけ
* 1.6ほぼ終わり、1.7はまだ


# ライブラリ紹介
----------------
## MIO

* [mio](https://github.com/carllerche/mio)
* 低レベルな非同期IOライブラリ
  + libuvやlibev2相当
  + イベントスレッドではなくイベントループ
* これを純Rustで実装
* つまり(比較的)高水準なAPIで使える
* 色んなライブラリの下地になっている


# ライブラリ紹介
----------------
## diesel

* [diesel](https://github.com/sgrif/diesel)
* ORM &amp; クエリビルダ
  + mioとはうってかわって高水準なライブラリ
* `infer_schema!(dotenv!(&#34;DATABASE_URL&#34;));` でコンパイル時に
  + DBにアクセスしてスキーマ情報抜いて
  + コード生成
* モデルもCRUDでちゃんと使い分けている


# 所有権難しい
--------------
下記のコードは動かない。

``` rust
fn main(){
    let hello = &#34;Hello, &#34;.to_owned();
    let world = &#34;World!&#34;;
    let hello_world =  hello + world;
    println!(&#34;{}&#34;, hello);
    println!(&#34;{}&#34;, world);
    println!(&#34;{}&#34;, hello_world);
}

```



# まとめ
--------

* Rustはシステムプログラミング言語だよ
* 面白い機能いっぱいあるよ
* もう「安定待ち」じゃないよ
* Try it now!



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>リージョンとRustの返り値</title>
      <link>/blog/2016/03/02/ri_jontorustnokaerichi</link>
      <pubDate>Wed, 02 Mar 2016 00:05:03 +0900</pubDate>
      
      <guid>/blog/2016/03/02/ri_jontorustnokaerichi</guid>
      <description>&lt;p&gt;Rustにおいては返り値ポインタで返すよりもそのまま返して、受け取る側でポインタで受け取るかそのまま受け取るかを指定するのが良い選択肢だ、といっています。
しかし初めて見る時にはどうしてそんなことが出来るのかわからず、びっくりしますよね。
それをRustがリージョンを使ってメモリ管理をしていると分かればどうなっているのか分かったのですこしばかり。&lt;/p&gt;

&lt;p&gt;Rustにおいては以下のように関数が値を返す時にポインタを返すコードは好ましくなく、（というかコンパイル出来ない）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; &amp;amp;BigStruct {
    &amp;amp;BigStruct{ .... }
}

let bs = new_value();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数が返す値はスタックに載らないような大きな値でもそのまま返して、受け取り側でヒープに保存してあげるのが良いスタイルとされています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; BigStruct {
    BigStruct{ .... }
}

let bs = Box::new(new_value());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までの言語の感覚だとRustにおいて良いとされるスタイルは大きな値を一旦スタックに載せた後で&lt;code&gt;Box&lt;/code&gt;によって作られたヒープ領域に確保されているように見えます。&lt;/p&gt;

&lt;p&gt;これはリージョンについて理解すると動作が理解できます。&lt;/p&gt;

&lt;p&gt;リージョンについては以前のブログを参照して下さい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/&#34;&gt;リージョンについて | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、リージョンによるメモリ管理は「メモリを確保すべき場所」が先にあって、値はそこに置かれます。
特に、関数呼び出しにおいて、関数の「返り値を確保すべき場所」は関数の外から与えます。&lt;/p&gt;

&lt;p&gt;ここまで説明したらお分りかと思いますが、&lt;code&gt;Box::new(new_value());&lt;/code&gt;というコードは&lt;code&gt;new_value()&lt;/code&gt;の返り値を保存する場所としてヒープ領域を渡していて、
関数内部でそのヒープ領域にBigStructの値を書き込んでいるのです。&lt;/p&gt;

&lt;p&gt;もやもやしていたものがスッキリしたし返り値のサイズが決まってないと関数から返せないのも分かるようになった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustのゼロコスト抽象化</title>
      <link>/blog/2016/03/01/rustnozerokosutochuushouka</link>
      <pubDate>Tue, 01 Mar 2016 23:32:12 +0900</pubDate>
      
      <guid>/blog/2016/03/01/rustnozerokosutochuushouka</guid>
      <description>&lt;p&gt;κeenです。今日Twitter上でのやりとりから少し面白いことが分かったのでそれについて。&lt;/p&gt;

&lt;p&gt;最近1.0が出たKotlinについて、水島さんがツイートしてました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;nullableに対してはmapとかの高階関数を一切使えないのが痛い。 ?. でカバーできるケースは一部だけだ。zero-overhead null-safetyと唄っとるが、代わりにnullチェックお化けになるわけで、どこがzero-overheadだ &lt;a href=&#34;https://twitter.com/hashtag/kotlin_dis?src=hash&#34;&gt;#kotlin_dis&lt;/a&gt;&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704453235277324288&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;それについて私が無関係なツイートを。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;全く無関係だけどRustはOptionみたいな0-1の型をnull or valueに最適化するそうな。これこそがゼロコスト抽象かな &lt;a href=&#34;https://t.co/5Y7cBEyrMe&#34;&gt;https://t.co/5Y7cBEyrMe&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704453898996547584&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;これはRustのnomiconに書かれています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/repr-rust.html&#34;&gt;repr(Rust)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;そうすると水島さんからお返事が。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; Rust詳しくないですけど、Optionにmapとかした場合インライン展開されるんですかね？だとしたらとても理想的。&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704455185125408768&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;確かにそうなると面白そう。ということで少し調べてみました。&lt;/p&gt;

&lt;p&gt;まず、上記の話をまとめると、Rustの&lt;code&gt;Option&lt;/code&gt;に対する&lt;code&gt;map&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    match self {
        Some(x) =&amp;gt; Some(f(x)),
        None =&amp;gt; None,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;code&gt;x&lt;/code&gt;がポインタ型だった時に以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    if (self != nullPointer ) {
        f(x)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、&lt;a href=&#34;https://github.com/rust-lang/rust/blob/master/src/libcore/option.rs#L386&#34;&gt;&lt;code&gt;map&lt;/code&gt;はインライン宣言されている&lt;/a&gt;ので以下のコード&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  (|x| x + 1)(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、ここで無名関数がどうコンパイルされるかという問題が出てきますが、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャのドキュメント&lt;/a&gt;によるとこういう雰囲気のコードになるらしいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
struct AnonymousType;

impl FnOnce&amp;lt;(&amp;amp;i32)&amp;gt; for AnonymousType {
    type Output = i32;
    fn call_once(self, args: (&amp;amp;i32)) -&amp;gt; Self::Output {
        args + 1
    }
}

if (opt != nullPointer) {
    let fn_once: FnOnce = AnonymousType;
    fn_once.call_once(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思ったよりも複雑…。さて、問題は&lt;code&gt;let fn_once: FnOnce = AnonymousType;&lt;/code&gt;としているので一旦元の無名関数の情報が抜けてしまいそうな気がします。
となるとコンパイル時に具体的なメソッドを決定出来ないので&lt;code&gt;fn_once.call_once(opt);&lt;/code&gt;は以下のような雰囲気のコードになってしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回呼び出すべき関数の取得が入るのは面倒ですね。&lt;/p&gt;

&lt;p&gt;しかしなががらクロージャのドキュメントをよく読むと無名関数は静的ディスパッチされると書いてあります。つまり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と2段ではなく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;the_call_once_fn_of_AnonymousType(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイルされ、&lt;/p&gt;

&lt;p&gt;よって&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn the_call_once_fn_of_AnonymousType(x: &amp;amp;i32) -&amp;gt; i32 {
    x + 1
}


let opt = &amp;amp;v;
if (opt != nullPointer) {
  the_call_once_fn_of_AnonymousType(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と同値ということです。&lt;/p&gt;

&lt;p&gt;ここからは私の推測ですが、&lt;code&gt;the_call_once_fn_of_AnonymousType&lt;/code&gt;は本体が小さい上に1回しか呼ばれないのでインライン化されるのではないかと思います。
よってこの推測が正しければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  opt + 1
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる筈です。&lt;/p&gt;

&lt;p&gt;ゼロコスト抽象化すごい!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>テストについて考えてみた</title>
      <link>/blog/2016/03/01/tesutonitsuitekangaetemita</link>
      <pubDate>Tue, 01 Mar 2016 22:49:23 +0900</pubDate>
      
      <guid>/blog/2016/03/01/tesutonitsuitekangaetemita</guid>
      <description>

&lt;p&gt;κeenです。
普段はテストをあまり書かない人なのですが業務では流石に書く必要があって、馴れないことをしていると色々と考えることがあったのでまとめます。
まだ私はテストのセオリーとかには詳しくないので勝手気儘に考えたことです。&lt;/p&gt;

&lt;p&gt;2016-03-05 追記:
酷い誤りがあったので修正しました。s/ホーア理論/ホーア論理/。&lt;/p&gt;

&lt;p&gt;今まではテストは「とりあえずエッジケースとかをカバー出来てればいいんでしょ」くらいにしか考えてませんでした。
しかしオブジェクト指向をしていて他のオブジェクトの振舞いに依存するだとか関数の引数が複雑だとかの時には適切なケースを書くのが困難でした。&lt;/p&gt;

&lt;p&gt;チームの人とかとどう書くのが適切かと話しているとなんとなくまとまってきました。&lt;/p&gt;

&lt;h1 id=&#34;ホーア論理:a6610a259e229e09be210cb3df2778c4&#34;&gt;ホーア論理&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://proofcafe.org/sf/Hoare_J.html&#34;&gt;ホーア論理&lt;/a&gt;的にはソフトウェアの振舞/性質を表すのには3つの要素が必要です。事前条件、操作、事後条件です。&lt;/p&gt;

&lt;p&gt;「事前条件Pが満たされるときに操作Oを行い、それが停止するならば事後条件Qが満たされる」&lt;/p&gt;

&lt;p&gt;エンジニアリング的には以下のように読み替えられます。&lt;/p&gt;

&lt;p&gt;事前条件とは、メソッドを実行するまでのお善立て。引数を用意する、依存するオブジェクトのモックを用意する、などなど。
操作が実際のメソッドの実行。
事後条件こそがassertなどを使ったテストケース群です。&lt;/p&gt;

&lt;h1 id=&#34;テストフレームワークとホーア論理:a6610a259e229e09be210cb3df2778c4&#34;&gt;テストフレームワークとホーア論理&lt;/h1&gt;

&lt;p&gt;テストを書く時にもこの考え方は役に立つな、と思いました。事前条件 x 操作 x 事後条件を網羅していけばいい訳です。&lt;/p&gt;

&lt;p&gt;ところで、テストフレームワークにはテストをグルーピングしたりといくつかのスコープをネスト出来る機能を持っているものもあります。
ホーア論理では要素が3つある訳ですから3段にネストするのが適切な気がするのは納得いくと思います。しかしどの順番でネストするかは議論の余地がありそうです。&lt;/p&gt;

&lt;p&gt;勿論、ホーア論理に従うなら操作の時系列的に事前条件&amp;gt;操作&amp;gt;事後条件のネストの仕方が一番自然かと思います。
しかしテストしたい主役は振舞、メソッドなのでそれを階層の最上位に持ってくる方が可読性、ひいてはテストの意味が高まりそうです。&lt;/p&gt;

&lt;p&gt;あるいは、4段にネストして最上位にだたのグルーピング目的にメソッドを、そしてその下に事前条件&amp;gt;操作&amp;gt;事後条件を持っていく手法もありそうです。
しかしこれだとネストが深すぎますね。また、後述するように操作の子階層を作ると例外がどこ由来なのか分かりづらいという問題もあります。&lt;/p&gt;

&lt;p&gt;これの改良版は最上位にだたのグルーピング目的にメソッドを、そして事前条件&amp;gt;(操作+事後条件)という形のネストの仕方をする方法です。
これは例外の出所を明確に出来る他、多くのテストフレームワークで操作に対する表明と事後条件に対する表明を区別しない問題もクリア出来るという利点があります。
1つある欠点は、操作と事後条件のスコープが分かれているので操作の返り値に対して事後条件で表明したい時にどうにかしてスコープの外に出してやる必要がある点です。
副作用を容易に許す言語なら外のスコープの変数に代入すればいいだけですが、純粋な言語だと簡単ではありません。
そういう意味でも操作に対する表明と事後条件に対する表明は分けたいなと思う次第。&lt;/p&gt;

&lt;h1 id=&#34;操作に対する表明:a6610a259e229e09be210cb3df2778c4&#34;&gt;操作に対する表明&lt;/h1&gt;

&lt;p&gt;本来のホーア論理的には事後条件で表明すれば十分ですが、実際には不十分な点があります。もう一度ホーア論理の表明について思い出しましょう。&lt;/p&gt;

&lt;p&gt;「事前条件pが満たされるときに操作oを行い、 &lt;strong&gt;それが停止するならば&lt;/strong&gt; 事後条件qが満たされる」&lt;/p&gt;

&lt;p&gt;現実的に、関数が正しく停止することも保証したいです。「無限ループを書く方が悪い」という訳ではありません。関数が停止しないのは何も無限ループだけでなく、例外などで脱出した場合も含みます。&lt;/p&gt;

&lt;p&gt;なので例外を出す/出さないの表明も欲しくなる訳です。
もう少し踏み込んで考えると、多くのテストフレームワークでassertと例外の送出の有無を同列扱いますが、前者は事後条件に対する表明、後者は操作に対する表明なので本来は分かれるべきです。&lt;/p&gt;

&lt;p&gt;また、操作に対する表明はスコープを作るとしても操作の返り値を返す手段を用意してくれると事後条件の表明がやりやすくなるな、と思いました。まる。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:a6610a259e229e09be210cb3df2778c4&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;テストをする時には3つの要素に分けて考えると考えやすくなります。その3つとは事前条件、操作、事後条件で、それぞれの組み合わせがあるのでテストケースのネストは合理的です。
しかしながら人間の認識のためにネストの順番は入れ替えた方がよいのですが、そうするとコード上いくつか問題が発生します。&lt;/p&gt;

&lt;p&gt;グルーピング目的にメソッドを、そして事前条件&amp;gt;(操作+事後条件)というネストの仕方が最終案に思えますが、それを的確に表現出来、かつコード上の問題をクリア出来るテストフレームワークが中々ないのが現状です。&lt;/p&gt;

&lt;h1 id=&#34;付録a:a6610a259e229e09be210cb3df2778c4&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;考えがまとまるまでの過程&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;テスト書いててなぜテストライブラリがテストスートを階層構造にしてるのか考えたけど1つの事前条件に対して複数の操作が考えれてそれぞれの操作に対して保証したい不変条件と事後条件があるから少なくとも3段にネストしないと上手くグルーピング出来ないのかな。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704586009464311808&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;しかしネストする順番はどうだろう。メソッドに対するテストでグルーピングしたいからメソッド&amp;gt;事前条件&amp;gt;事後/不変条件になるのかな。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704586479427670016&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;事前条件を最上位に持ってきた方が理解しやすいし事前条件の使い回しもしやすいけど並行にテストを走らせようと思ったらやっぱり操作毎に事前条件用意してあげた方がいいし事前条件と事後条件が近い方が性質を理解しやすい?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704587239402008576&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;あれ?もしかして操作ってメソッドじゃなくてメソッド+引数になる?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704588326175551488&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うーん。操作を行うパートと条件の準備/確認のパートを分けたいんだけど難しい。例えば操作によって例外が出ることを確認したいとかが非常にやりづらい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704601381605232640&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;いや?やっぱり操作と事後/不変条件のパートは分けれるな?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704602157148872704&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そしてやはり操作をネストのトップレベルにもってくると操作の引数とかが事前条件/前提条件に依存するのでやりづらい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704602629737811968&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RustのHigher-Kinded type Trait</title>
      <link>/blog/2016/02/28/rustnohigherkinded_type_trait</link>
      <pubDate>Sun, 28 Feb 2016 14:40:59 +0900</pubDate>
      
      <guid>/blog/2016/02/28/rustnohigherkinded_type_trait</guid>
      <description>

&lt;p&gt;κeenです。少し前の話になりますがRustの関連型を駆使してHigher Kinded type Trait（高階型トレイト）を実現してしまったものが出回ってたのでそれについて。
本来RustはHKTをサポートしていませんが不思議なことに実装出来てしまっているのです。&lt;/p&gt;

&lt;p&gt;HKTについて微塵も知らない方にも分かるように解説していきます。&lt;/p&gt;

&lt;h1 id=&#34;map-可能なトレイト:b27135531fb7377c493eecfb210d7b92&#34;&gt;&lt;code&gt;map&lt;/code&gt; 可能なトレイト&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/core/option/enum.Option.html#method.map&#34;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;https://doc.rust-lang.org/core/result/enum.Result.html#method.map&#34;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;、etc 色々なトレイトが &lt;code&gt;map&lt;/code&gt; メソッドを実装しています。&lt;/p&gt;

&lt;p&gt;それぞれ型シグネチャを抜き出してみましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Option: &lt;code&gt;map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Result: &lt;code&gt;map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, op: F) -&amp;gt; Result&amp;lt;U, E&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;驚く程似てますね。これを抽象化して「&lt;code&gt;map&lt;/code&gt;メソッドを持つ」トレイトを定義したくなるかもしれません。
しかしそれは簡単には書けません。何故なら&lt;code&gt;map&lt;/code&gt;はコンテナ型、つまり「型引数を取る型」に定義される型だからです。
現在のRustは「型引数を取る型」に対するジェネリクスはサポートしていません。もし書こうとするとこのようになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;M&amp;lt;_&amp;gt;, T&amp;gt; where Self: M&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; M&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt; なんて型パラメータを書くことは出来ませんし&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;も無理があります。残念ですね。&lt;/p&gt;

&lt;h1 id=&#34;iterator-との違い:b27135531fb7377c493eecfb210d7b92&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt; との違い&lt;/h1&gt;

&lt;p&gt;さて、&lt;code&gt;Iterator&lt;/code&gt;にも&lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;はあります。
これこそが求めている「&lt;code&gt;.map&lt;/code&gt; 可能なトレイト」ではないのでしょうか。
これはおおよそは合っているのですがやや期待とは違う動作をします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt;の&lt;code&gt;map&lt;/code&gt;は不自由なく使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let o = Some(1);
let o = o.map(|i| i + 1);
println!(&amp;quot;{:?}&amp;quot;, o);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一方、&lt;code&gt;Vec&lt;/code&gt;は全く同じような書き方は出来ません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = vec![1];
let v = v.map(|i| i + 1);
println!(&amp;quot;{:?}&amp;quot;, v);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;anon&amp;gt;:3:11: 3:25 error: no method named `map` found for type `collections::vec::Vec&amp;lt;_&amp;gt;` in the current scope
&amp;lt;anon&amp;gt;:3 let v = v.map(|i| i + 1);
                   ^~~~~~~~~~~~~~
&amp;lt;anon&amp;gt;:3:11: 3:25 note: the method `map` exists but the following trait bounds were not satisfied: `collections::vec::Vec&amp;lt;_&amp;gt; : core::iter::Iterator`, `[_] : core::iter::Iterator`
error: aborting due to previous error
playpen: application terminated with error code 101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正しくは、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = vec![1];
let v: Vec&amp;lt;i32&amp;gt; = v.iter().map(|i| i + 1).collect();
println!(&amp;quot;{:?}&amp;quot;, v);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;色々実装上のノイズが乗っているのでやや例として不適切だったかもしれませんが、注目して欲しい部分はここです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v: Vec&amp;lt;i32&amp;gt; = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt;から取り出したイテレータなのに&lt;code&gt;Vec&lt;/code&gt;に戻すためにわざわざ型アノテーションを書く必要があります。&lt;/p&gt;

&lt;p&gt;どうしてこうなるかというとイテレータを取り出した時点で元のコンテナ型が&lt;code&gt;Vec&amp;lt;&amp;gt;&lt;/code&gt;であるという情報が失われているからです。
これはRustの型システム上どうしても仕方のないことで、なので恐らくRustは「&lt;code&gt;map&lt;/code&gt;可能なトレイト」などを定義せず、コレクションの操作を&lt;code&gt;Iterator&lt;/code&gt;に集約しているんだと思います。
この方式はある程度は上手くいきますが&lt;code&gt;Option&lt;/code&gt;や&lt;code&gt;Result&lt;/code&gt;はIteratorになれはしてもIteratorからは作れない(2要素のイテレータからOptionは作れない)ので独自でmapメソッドを持つことになってしまいます。&lt;/p&gt;

&lt;h1 id=&#34;map-可能なトレイト-again:b27135531fb7377c493eecfb210d7b92&#34;&gt;&lt;code&gt;map&lt;/code&gt; 可能なトレイト again&lt;/h1&gt;

&lt;p&gt;先程そういうのは作れないと言ったばかりですが実はどうにかする方法がなくもないです。先程の(仮想の)定義を思い出して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;M&amp;lt;_&amp;gt;, T&amp;gt; where Self: M&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; M&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジェネリクスになっている登場人物は&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;、&lt;code&gt;U&lt;/code&gt;、&lt;code&gt;T&lt;/code&gt; ですね。しかし&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;は実際にはそのまま使われいる訳ではなく&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;または&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;の形でのみ使われています。
では、&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;をパラメータに取るようにしてはどうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;T, MT&amp;gt; where Self: MT {
  fn map&amp;lt;U, MU, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで出来…てません。これは欲しい、正しいもの &lt;em&gt;も&lt;/em&gt; 作れてはいるのですが正しくないものも含んでいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;T, MT: Option&amp;lt;T&amp;gt; Mappable&amp;lt;MT, T&amp;gt;  for Option&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, MU, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU {...}
}

let r: Result&amp;lt;String, ()&amp;gt; = Some(1).map(|i| i.to_string());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt; に対する&lt;code&gt;map&lt;/code&gt;を&lt;code&gt;Result&lt;/code&gt;で受けようとしています。
これはもちろんおかしなことですが上記の型定義に従うとこういうことが出来てしまいます。
もうちょっというと上のトレイトの定義はこういう「おかしなこと」が起こるような実装をしろ、と言っている訳で、実際には実装出来ません。&lt;/p&gt;

&lt;p&gt;本来なら自由パラメータが3つなのに4つの自由パラメータを取ってしまったので不整合が起きる訳です。
では、自由パラメータを3つにして1つを従属パラメータにしてはどうでしょうか。それは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;を使えばRustでも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;T, U, MT&amp;gt; where Self: MT {
  type MU;
  fn map&amp;lt;F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これである程度上手くいきます。
もちろん、実際に&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;を取れるのに比べると不自由で下手をするとバグる(MUを無関係な型に定義できてしまう)可能性があるのですが、先程の4パラメータの時と比べて
トレイトが定義された時点で返す型は決まっているのでちゃんと実装出来ますし、使う時に不整合が起きることもありません。&lt;/p&gt;

&lt;h1 id=&#34;hkt:b27135531fb7377c493eecfb210d7b92&#34;&gt;HKT&lt;/h1&gt;

&lt;p&gt;さて、先の&lt;code&gt;Mappable&lt;/code&gt;の仮想定義、&lt;code&gt;map&lt;/code&gt;関数を除いて汎用的にするとこうなりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U, MT&amp;gt; where Self: MT {
  type MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Self: MT&lt;/code&gt; というアノテーションをつけてますが実際には使えません。&lt;code&gt;impl&lt;/code&gt;を書くときに気をつけて実装するしかないです。なのでこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U&amp;gt; {
  type MU;
}

impl &amp;lt;T, U&amp;gt; HKT&amp;lt;T, U&amp;gt; for Option&amp;lt;T&amp;gt; {
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、こう書くとするとこういうことも出来てしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U&amp;gt; {
  type MU;
}

impl &amp;lt;S, T, U&amp;gt; HKT&amp;lt;T, U&amp;gt; for Option&amp;lt;S&amp;gt; {
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;T&lt;/code&gt;とは独立な&lt;code&gt;S&lt;/code&gt;に対するコンテナに対して実装できてしまうのです。「実装するときに気をつける」とはいいましたが制約を書けるなら書いた方がいいです。こうしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;U&amp;gt; {
  type T;
  type MU;
}

impl &amp;lt;T, U&amp;gt; HKT&amp;lt;U&amp;gt; for Option&amp;lt;T&amp;gt; {
  type T = T;
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで冒頭に紹介したHKTの実装になりました。&lt;/p&gt;

&lt;p&gt;逆にこのHKTの実装からMappableを定義するには、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;U&amp;gt;: HKT&amp;lt;U&amp;gt; {
  fn map&amp;lt;F: FunOnce(Self::T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Self::MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hktについてもっと:b27135531fb7377c493eecfb210d7b92&#34;&gt;HKTについてもっと&lt;/h1&gt;

&lt;p&gt;ようやく話題のHKTの元実装です。こちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/14427/af90a21b917d2892eace&#34;&gt;Higher-kinded type trait&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ずいぶんとモナモナしいですがやはり高階型を使った一番実績のある構造はこのあたりでしょう。&lt;/p&gt;

&lt;p&gt;こういうのを扱えるとプログラミングの幅が広がりますね。&lt;/p&gt;

&lt;h1 id=&#34;ノート:b27135531fb7377c493eecfb210d7b92&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;モナドの話題が出ましたがRustでモナドを実現するには高階型だけでなく複数ある関数トレイトのどれを選ぶかだとかその他諸々の問題を扱う必要があるようです。
&lt;a href=&#34;https://m4rw3r.github.io/rust-and-monad-trait/&#34;&gt;Rust and the Monad trait - Not just higher kinded types · m4rw3r&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>