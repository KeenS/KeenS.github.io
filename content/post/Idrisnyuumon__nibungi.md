---
categories: ["Idris"]
date: 2019-01-17T23:34:55+09:00
draft: true
title: "Idris入門: 二分木"
---

κeenです。[Idris入門: 数当てゲーム | κeenのHappy Hacκing Blog](https://keens.github.io/blog/2019/01/07/idrisnyuumon__kazuatege_mu/)に続いて入門記事を書いてみます。
前回はバイナリを作ったので今回はライブラリを作ります。題材は(非平衡)二分木。
<!--more-->
非平衡なのは平衡にすると複雑になるのと、平衡にするときは別のネタ(依存型)があるのでそれまでとっておくためです。

対象読者は前回の数当てゲームのチュートリアルを終えた人に設定します。

# プロジェクト作成

以下のような構成でディレクトリを作りましょう。

``` text
├── btree.ipkg
└── src
    └── BTree.idr
```

btree.ipkgには以下を書きます。

```text
package btree

sourcedir = src

modules = BTree
```

そして `BTree.idr` に今から二分木を実装していきます。


# 二分木とは

二分木とはデータ構造です。
値の保持、検索、削除ができるので集合やKey-Valueストアの実装に使われます。
手続き型言語ではそれらの実装にハッシュセットやハッシュマップがよく使われますが、関数型言語では二分木のほうが使われるようです。

二分木はノード(節)とリーフ(葉)からなります。ノードは1つの値と2つの子(部分木)を持ちます。リーフは何もデータを持ちません。
ノードには「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい」という条件が成り立ちます。


図にするとこんな感じでしょうか

![二分木の図]()

``` text
    3
   / \
  1   4
 / \ / \
L   2L  5
   / \ / \
  L   L   L
```

1, 2, 3, 4, 5がノードに保持されている値です。一番上にあるノード(ここでは3を保持しているノード)を根と呼びます。
「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい」という条件もちゃんと成り立っています。

![二分木の図の解説]()



# 二分木への操作

まずは検索と挿入を説明しましょう。

## 検索
検索は二分探索をそのまま行えます。
例えば以下の1, 2, 3, 4, 5を保持している木に2が含まれるか検索してみましょう。


``` text
    3    2
   / \
  1   4
 / \ / \
L   2L  5
   / \ / \
  L   L   L
```

まず3と2を比較します。2は3より小さいのであるとしたら左の子にあるはずです。左の子を見てみましょう。


``` text
    3    2
   / \
  1   4
 / \ / \
L   2L  5
   / \ / \
  L   L   L
```

左の子は1を保持しています。2は1より大きいのであるとしたら右の子にあるはずです。右の子をみてましょう。

``` text
    3    2
   / \
  1   4
 / \ / \
L   2L  5
   / \ / \
  L   L   L
```

右の子は2を保持しています。検索している値が見つかったのでこの木に2が含まれることが分かります。

同様の検索をして葉に行き当たったら検索している値は見つからないことが分かります。

## 挿入

挿入も検索と似たようなことをします。この木に6という値を挿入してみましょう。

``` text
    3    6
   / \
  1   4
 / \ / \
L   2L  5
   / \ / \
  L   L   L
```

6は3より大きいので右の子を見ます。

``` text
    3    6
   / \
  1   4
 / \ / \
L   2L  5
   / \ / \
  L   L   L
```

右の子を見ると6は4より大きいのでさらに右の子を見ます。

``` text
    3    6
   / \
  1   4
 / \ / \
L   2L  5
   / \ / \
  L   L   L
```

6は5より大きいので更に右の子を見ます。


``` text
    3    6
   / \
  1   4
 / \ / \
L   2L  5
   / \ / \
  L   L   L
```


右の子はリーフなのでこの木には6がいないことが分かりました。
そこで6だけを保持する **新しいノードを作ります**。


``` text
    3      6
   / \    / \
  1   4  L   L
 / \ / \
L   2L  5
   / \ / \
  L   L   L
```

5を保持するノードの右の子を今作ったノードにした **新しいノードを作ります**。

``` text
    3
   / \
  1   4
 / \ /
L   2L    5
   / \   / \
  L   L L   6
           / \
          L   L
```

4を保持するノードの右の子を今作ったノードにした **新しいノードを作ります**。

``` text
    3
   / 
  1     4
 / \   / \
L   2  L  5
   / \   / \
  L   L L   6
           / \
          L   L
```

3を保持するノードの右の子を今作ったノードにした **新しいノードを作ります**。

``` text
    3
   / \
  1   4
 / \ / \
L   2L  5
   / \ / \
  L   L   6
         / \
        L   L
```

これで更新が完了しました。

更新というよりは挿入する値も保持した新しい木を作る操作ですね。Idrisは純粋関数型言語なので破壊的変更ができません。なので更新ではなく新しい値を作ることになります。そういったときに部分構造を共有できる二分木は無駄が少なく効率的なデータ構造になるのです。


# 二分木の実装

さて、座学はこのくらいにして実装していきましょう。

## データ型の定義
まずはデータ構造の定義です。二分木とはリーフ、または2つの子と値を持ったノードからなるのでした。
BTree.idrに以下を実装します。

``` idris
module BTree

data BTree a = Leaf
             | Node (BTree a) a (BTree a)
```


これはデータ型の定義です。`BTree a` というのは `a` 型の値を保持するBTreeという意味です。ジェネリクスになってますね。

定義の中身は `Leaf` または `Node` です。 `Leaf` はデータを持ちません。 `Node` は2つの子(`BTree a`)と 値(`a`)を持ちます。

## 挿入

このデータ型に対して挿入を実装してみましょう。まずは型は木 `BTree a` と値 `a` を受け取って新しい `BTree a` を返すのでこうなりそうです。

``` idris
insert : BTree a -> a -> BTree a
```

実装の方はリーフかノードかで分岐が発生します。
以下のように書けるでしょう。

``` idris
insert tree x = case tree of
                  Leaf => -- ...
                  Node l v r => -- ...
```

しかし引数で分岐するときは別の記法があります。以下のように書けるのです。

``` idris
insert Leaf         x = -- ...
insert (Node l v r) x = -- ...
```

こちらの方がより宣言的で読みやすいスタイルだとされています。


### 余談: エディタサポート
今の実装は実は自動化できます。
ここを書いたところまで巻き戻ってみましょう。

``` idris
insert : BTree a -> a -> BTree a
```

この状態で`insert`にカーソルを合わせてaddclauseと呼ばれるコマンド(Emacsなら`C-c C-s`, Vimなら `\d`)を打つとこうなります。

``` idris
insert:  BTree a ->  a -> BTree a
insert x y = ?insert_rhs
```

変数名が適当ですが定義のモックが自動生成されました。`?` マークで始まるのは穴(Hole)と呼ばれ、「あとで実装する」のマークです。詳しくは[ドキュメント](http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#holes)を読んで下さい。

名前はおいておいて、エディタサポートの話を続けます。ここでの `x` で分岐したいのでした。
`x` にカーソルを合わせてcasesplitと呼ばれるコマンド(Emacsなら `C-c C-c`, Vimなら `\c`)を打つとこうなります。

``` idris
insert:  BTree a ->  a -> BTree a
insert Leaf y = ?insert_rhs_1
insert (Node x z w) y = ?insert_rhs_2
```

ここまで自動生成できました。

自動生成される名前を制御するにはこのチュートリアルを大きく超える内容が必要です。
型には `%name` ディレクティブを、ヴァリアントにはGADTを使ってそれぞれこう定義したら目的を達成できます。

``` idris
data BTree: (a : Type) -> Type where
  Leaf : BTree a
  Node : (l: BTree a) -> (v: a) -> (r: BTree a) -> BTree a

%name BTree tree, tree1, tree2
```

これで生成したコードは以下です。

``` idris
insert:  BTree a ->  a -> BTree a
insert Leaf x = ?insert_rhs_1
insert (Node l v r) x = ?insert_rhs_2
```

記法やコンパイラ補助の違いだけで、元の記法もこちらの記法も同じデータ型を定義しているので使わせて盲目的に定義を置き換えてしまうのも手です。

/余談


さて、これから実装していきましょう。
まずは`Leaf`の方です。`Leaf` なら新しい値を持ったノードで置き換えるのでした。

``` idris
insert: Ord a => BTree a ->  a -> BTree a
insert Leaf x = Node Leaf x Leaf
insert (Node l v r) x = ...
```

