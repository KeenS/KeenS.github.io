<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sql on κeenのHappy Hacκing Blog</title>
    <link>/categories/sql/</link>
    <description>Recent content in Sql on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 06 Mar 2016 14:54:30 +0900</lastBuildDate>
    <atom:link href="/categories/sql/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ビッグデータしないDrill、ローカルで快適に使うために</title>
      <link>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</link>
      <pubDate>Sun, 06 Mar 2016 14:54:30 +0900</pubDate>
      
      <guid>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ビッグデータしないDrill、ローカルで快適に使うために
----------------------
[Tokyo Apache Drill Meetup](http://drill.connpass.com/event/27414/)  
2016-03-22

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + サイバーエージェントのエンジニア
   + アドテクスタジオ所属
   + データエンジニアじゃなくてもデータを触ることはある

===
# なぜローカルか
---------------

* ビッグデータ重い
* 使いたいデータが絞れる時には大袈裟
  + 「売り上げ上位1000のユーザの行動」とか
* 同じようなクエリの重複
  + 新しいテーブル作れないDBとかview作れないDBとか
* 結果をRに渡したりとかが面倒
  + CSVダウンロードがGUI
===
# キャッシュ的な
----------------

```
+---------------------------------+
| BIG DATA (BigQuery, Spark, etc) |
+---------------------------------+
        ^ |  ^  |
        | |  |  |
        | v  |  v
   +-------------------+
   | ローカルキャッシュ | &lt;- ???
   +-------------------+
     ^ | ^ | ^ | ^ |
     | v | v | v | |
     +----------+  |
     |   自分   |  |
     +----------+  v
     +---+    +-----+
     | R | &lt;--| CSV |
     +---+    +-----+
```

===
# やりたいこと
--------------

* パパッっと処理を始められる
  + だいたい「CSVを簡単に読める」に同じ
  + たまにJSONとか
* 簡単に処理出来る
  + 自分が馴れているかどうか
* CSVを吐ける
  + 最後はRに渡したい

===
# 候補
-------

* ローカルMySQL
  + 事前のScheme定義が必要
* R
  + 扱い馴れない
* SQLite
  + 事前のScheme定義が必要
* (Python)
  + あまり向いてない？

===

&lt;pre style=&#39;font-size: 200%&#39;&gt;
＿人人人人人人人＿
＞　突然のDrill　＜
￣Y^Y^Y^Y^Y^Y￣
&lt;/pre&gt;

===
# なぜ Drill
------------

* (デーモン立ち上げておけば)サクっと始められる
* CSVをそのまま読める
  + Schema定義がいらない!
* ついでにJSONも読める
* 馴れたSQLで操作出来る
* CSV吐ける

===
# Drillを便利にするために
-------------------------

* いくつかのシェル関数
* Drillのデーモン/クライアントの起動を便利に

```sh
drill-start() {
    ~/compile/zookeeper-3.4.8/bin/zkServer.sh start
    drillbit.sh start
}

drill-cli() {
    sqlline -u jdbc:drill:zk=localhost:2181
}

drill-web() {
   firefox http://localhost:8047
}
```

===
# もっと便利に
--------------

* REPLでの操作が面倒
  + ヒストリ遡るのとか
  + ミスった時の訂正が地味に不便
* シンタックスハイライト欲しい
* 馴れたツールで編集したい

===
# sql-drill.el
--------------

* [KeenS/sql-drill.el](https://github.com/KeenS/sql-drill.el)
* Emacsのsql-modeのDrillサポート
  + emacsのsql-modeは拡張可能
* シンタックスハイライト
* REPL

===
# DEMO
------
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# まとめ
--------

* ローカルでデータ分析したい時があるよ
* その時にDrillは便利だよ
* Emacs向けのDrillプラグイン作ったよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Apache Drillの不自然な挙動</title>
      <link>/blog/2015/12/20/apache_drillnofushizennakyodou</link>
      <pubDate>Sun, 20 Dec 2015 23:04:37 +0900</pubDate>
      
      <guid>/blog/2015/12/20/apache_drillnofushizennakyodou</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/drill&#34;&gt;Apache Drill Advent Calendar 2015&lt;/a&gt;21日目のエントリです&lt;/p&gt;

&lt;p&gt;最初は備忘録がてら普段使うMySQL、BigQuery、SQLite、Apache DrillのSQLシンタックスの違いでも書こうかと思ったのですが調査が思ったより大変だったのでやめました。ANSI SQLも色々変わってるということは理解出来ました。&lt;/p&gt;

&lt;p&gt;ということでApache Drillを使ってて「ん？」と思った挙動をいくつか出してみようかと。1.4時点での情報です。&lt;/p&gt;

&lt;h1 id=&#34;select-1&#34;&gt;&lt;code&gt;SELECT 1&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;シェルで手持ち無沙汰に&lt;code&gt;ls&lt;/code&gt;や&lt;code&gt;pwd&lt;/code&gt;を打つようにSQLプロンプトで&lt;code&gt;SELECT 1;&lt;/code&gt;を打つ訳ですが、Apache Drillはこれを受け付けてくれません。&lt;/p&gt;

&lt;p&gt;まあ、これは不自然というかそういう仕様なのですが正しくは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT 1 FROM (VALUES(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。手持ち無沙汰に打つには少し面倒ですね。そうでなくても日付関数の挙動を確かめたい時にも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT NOW();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとやりたい訳ですがそれにも&lt;code&gt;FROM (VALUES(1));&lt;/code&gt;とダミーの&lt;code&gt;FROM&lt;/code&gt;句を付けてあげる必要があります。面倒ですね。&lt;/p&gt;

&lt;h1 id=&#34;union-と-union-all&#34;&gt;&lt;code&gt;UNION&lt;/code&gt;と&lt;code&gt;UNION ALL&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;UNION&lt;/code&gt;はテーブル同士のレコード間で重複を取り除いた集合を、&lt;code&gt;UNION ALL&lt;/code&gt;は重複を取り除かない集合を返します。Apache Drillでも試してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM (VALUES (1, 2, 3) UNION VALUES(4, 5, 6) UNION VALUES(7, 8, 9) UNION VALUES(1, 2, 3));
SELECT * FROM (VALUES (1, 2, 3) UNION ALL VALUES(4, 5, 6) UNION ALL VALUES(7, 8, 9) UNION ALL VALUES(1, 2, 3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのクエリはどういう結果になるでしょうか。答えはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT * FROM (VALUES (1, 2, 3) UNION VALUES(4, 5, 6) UNION VALUES(7, 8, 9) UNION VALUES(1, 2, 3));
+---------+---------+---------+
| EXPR$0  | EXPR$1  | EXPR$2  |
+---------+---------+---------+
| 1       | 2       | 3       |
+---------+---------+---------+
1 row selected (0.416 seconds)
0: jdbc:drill:zk=local&amp;gt; SELECT * FROM (VALUES (1, 2, 3) UNION ALL VALUES(4, 5, 6) UNION ALL VALUES(7, 8, 9) UNION ALL VALUES(1, 2, 3));
+---------+---------+---------+
| EXPR$0  | EXPR$1  | EXPR$2  |
+---------+---------+---------+
| 7       | 8       | 9       |
| 7       | 8       | 9       |
| 7       | 8       | 9       |
| 7       | 8       | 9       |
+---------+---------+---------+
4 rows selected (0.115 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うーん。これはバグだと思うんですよね。定数テーブルをキャッシュするようにしてたら全てのレコードで同じ値を参照しちゃって値を書き換えてしまったとか。
&lt;code&gt;UNION&lt;/code&gt;が&lt;code&gt;UNION ALL&lt;/code&gt;の結果から&lt;code&gt;DISTINCT&lt;/code&gt;相当の処理をするなら2番目の結果を見れば最初の結果が従うのもうなずけますし。&lt;/p&gt;

&lt;h1 id=&#34;ヘッダ付きcsv&#34;&gt;ヘッダ付きCSV&lt;/h1&gt;

&lt;p&gt;Drill 1.4からヘッダ付きCSVの扱いが楽になりましたね。拡張子が&lt;code&gt;csv&lt;/code&gt;のままヘッダ付きCSVにクエリを投げられます。ちょっと試しましょう。&lt;/p&gt;

&lt;p&gt;次のようなCSVファイルを用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/Csv/test.csv
foo,bar,baz
1,1.0,&amp;quot;a&amp;quot;
2,2.0,&amp;quot;b&amp;quot;
3,3.0,&amp;quot;c&amp;quot;
4,4.0,&amp;quot;d&amp;quot;
5,5.0,&amp;quot;e&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリを投げてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT * FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+------+------+
| foo  | bar  | baz  |
+------+------+------+
| 1    | 1.0  | a    |
| 2    | 2.0  | b    |
| 3    | 3.0  | c    |
| 4    | 4.0  | d    |
| 5    | 5.0  | e    |
+------+------+------+
5 rows selected (0.12 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。じゃあ今度は&lt;code&gt;baz&lt;/code&gt;カラムだけ取り出してみましょう。ここで、会社のMacだと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT baz FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+------+------+
| foo  | bar  | baz  |
+------+------+------+
| 1    | 1.0  | a    |
| 2    | 2.0  | b    |
| 3    | 3.0  | c    |
| 4    | 4.0  | d    |
| 5    | 5.0  | e    |
+------+------+------+
5 rows selected (0.12 seconds)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにカラムを指定しているのにも関らず全てのデータが返ってきていました。その旨を書こうと思ったのですが手元のLinuxマシンだと正しい結果が返ってくるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT `bar` FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+
| bar  |
+------+
| 1.0  |
| 2.0  |
| 3.0  |
| 4.0  |
| 5.0  |
+------+
5 rows selected (0.088 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと会社で見たのが幻覚だったかもしれないので要調査ですね。&lt;/p&gt;

&lt;h1 id=&#34;mysqlへの接続&#34;&gt;MySQLへの接続&lt;/h1&gt;

&lt;p&gt;以下のようなSQLを投げた所、ひどく時間が掛かりました。投げた対象はプロダクションのデータが入ってる分析用のDBで、結構な量のデータが入ってます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM mysql.mydb.`test` LIMIT 20;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache Drill自体レスポンスが悪いのでクエリによってはそんなものかな、と思って最初はそのままにしたのですがふと気になって&lt;code&gt;EXPLAIN&lt;/code&gt;してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=localhost:2181&amp;gt; EXPLAIN PLAN FOR SELECT * FROM mysql.mydb.`test` LIMIT 20;
+------+------+
| text | json |
+------+------+
| 00-00    Screen
00-01      Project(columns....)
00-02        SelectionVectorRemover
00-03          Limit(fetch=[20])
00-04            Limit(fetch=[20])
00-05              Jdbc(sql=[SELECT * FROM `mydb`.`test`])
| {
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Jdbc(sql=[SELECT * FROM mydb.test])&lt;/code&gt; とあるのでなんとMySQLに&lt;code&gt;LIMIT&lt;/code&gt;をつけずにクエリを投げてます。そしてさらに何故か&lt;code&gt;Limit(fetch=[20])&lt;/code&gt;を2回やっています。&lt;/p&gt;

&lt;p&gt;まあ、内部でLimitを2回やってるのは良いとしてもMySQLにLimit無しで投げるのはいただけないですね。
分散モデルのDrillからしたら「分散してる俺らの方が処理が速いから全部俺らでやってやるよ」という気概なのかもしれませんがこちらとしてはDBへの負荷も考えて欲しいものです。
まあ、かといって&lt;code&gt;WHERE&lt;/code&gt;句にインデックスが付く/付かないだとかその他の句によってMySQLのへの負荷も変わるのでなんとも言えないといえばそうなんですが簡単な場合にpush downしてくれるか
あるいは手動でpush down出来る仕組みが欲しいですね。&lt;code&gt;FORCE INDEX&lt;/code&gt;みたいに。&lt;/p&gt;

&lt;p&gt;さて、色々気になる点はありましたがApache Drillは面白いプロダクトです。
主にビッグデータ分析に使われるようですが私は大きなテーブルからアドホックに抽出したCSVとMySQLにあるマスターデータをJOINするなどの目的で使っていきたいなと思っています。&lt;/p&gt;

&lt;p&gt;皆様良いデータ分析ライフを！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>