<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ml on </title>
    <link>/categories/ml/</link>
    <description>Recent content in Ml on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 11 Jan 2016 00:57:20 +0900</lastBuildDate>
    <atom:link href="/categories/ml/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SML#のpthreadバインディング作った</title>
      <link>/post/SML_nopthreadbaindingutsukutta/</link>
      <pubDate>Mon, 11 Jan 2016 00:57:20 +0900</pubDate>
      
      <guid>/post/SML_nopthreadbaindingutsukutta/</guid>
      <description>

&lt;p&gt;κeenです。またしても深夜になってしまいましたがSML#のpthreadバインディングを作ったのでその報告を。&lt;/p&gt;

&lt;p&gt;SML#はC FFIを簡単に書け、さらにランタイムがnon Moving GCなのでSML#自体はサポートしていないもののランタイムそのものはマルチスレッドに対応しているという大変興味深い特徴を持っています。
処理系側としてもマルチスレッドが欲しいならpthreadのFFIを使って好きにやってくれというスタンスのようです。&lt;/p&gt;

&lt;p&gt;ということでさまざまなマルチスレッドアプリケーションの下地になるべくpthreadのバインディングを作りました。とはいってもまだ不完全ですが。&lt;/p&gt;

&lt;p&gt;どういうものが用意出来ているかは&lt;a href=&#34;https://github.com/KeenS/smlsharp_pthread/blob/master/src/pthread.smi&#34;&gt;こちら&lt;/a&gt;が一覧として機能しています。&lt;/p&gt;

&lt;p&gt;SML的には改善の余地がある(例えば、排他的なフラグをdatatypeで定義するとか)のですが、あくまで低レベルなバインディングに徹するためにintのままで残してあります。&lt;/p&gt;

&lt;p&gt;他にはCのマクロで実現されていたものはインポート出来ないのでどうにかしてあったりどうにかしてなかったりしてます。
例えば&lt;code&gt;PTHREAD_XXX_INITIALIZER&lt;/code&gt;はマクロで定義された初期値ですが、SMLからは参照出来ないのであきらめました。
代わりに&lt;code&gt;pthread_xxx_new&lt;/code&gt;関数を用意したので&lt;code&gt;pthread_xxx_init&lt;/code&gt;と併せて使うことでそれらの値を初期化出来ます。
メモリ確保と初期化同時にやれよとの声が聞こえてきそうですが繰り返すとあくまで低レベルなバインディングなのでそういうのは他に譲ることにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pthread_cleanup_{pop/push}&lt;/code&gt;はバインディングが書けませんでした。
それらはマクロとして実現されていて、しかも&lt;code&gt;pthread_cleanup_push&lt;/code&gt;で開き括弧を挿入して&lt;code&gt;pthread_cleanup_pop&lt;/code&gt;で閉じるというエグい実装なので移植は無理でしょう。
POSIX的にもマクロとして実現して良いことになっているので文句は言えません。&lt;/p&gt;

&lt;h1 id=&#34;サンプルコード:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;サンプルコード&lt;/h1&gt;

&lt;p&gt;レポジトリにも入ってますが、スレッドを作る小さな例だとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;open PThread
fun exit reason = (
    print (reason ^ &amp;quot;\n&amp;quot;);
    OS.Process.exit OS.Process.failure
)


val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr
(* durty hack *)
val sml_str_new = _import &amp;quot;sml_str_new&amp;quot;: (string) -&amp;gt; char ptr

fun threadFunc (arg:unit ptr): unit ptr = let
    val cp: char ptr = fromUnitPtr arg
    val s = Pointer.importString cp
    val () = print s
    (* val ret =ref _NULL *)
    (* val () = ret := (String.size s) *)
in
    (* ret *)
    _NULL
end
                   
val () = let
    val tattr = ref (pthread_attr_new())
    val s = pthread_attr_init(tattr)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;pthread_attr_init&amp;quot;
             else ()
    val thread_ref = ref (pthread_new())
    val arg = sml_str_new &amp;quot;Hello world\n&amp;quot;
    val s = pthread_create(thread_ref, tattr, threadFunc, toUnitPtr arg)
    val t1 = !thread_ref
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;thread creation failed&amp;quot;
             else ()
    val s = pthread_attr_destroy(tattr)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;pthread_attr_destroy&amp;quot;
             else ()
    val () = print &amp;quot;Message from main()\n&amp;quot;;
    val resRef = ref (Pointer.NULL ())
    val s = pthread_join(t1, resRef)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;thread creation failed&amp;quot;
             else ()
    (* val () = print (&amp;quot;Thread returned&amp;quot; ^ Int.toString  (!resRef) ^ &amp;quot;\n&amp;quot;) *)
in
    ()
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;言わずとも雰囲気で読み取れそうですがこの例はCのサンプルをそのまま移植しました。Cだと&lt;code&gt;(void *)&lt;/code&gt;と文字列で相互変換が出来るのですがSML#だと一筋縄では出来ないので内部APIを叩くとかのかなりアレなハックしてます。
&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/45&#34;&gt;SML#にイシューに上げ&lt;/a&gt;ましたが&lt;code&gt;(void *)&lt;/code&gt;が強敵ですね。&lt;/p&gt;

&lt;h1 id=&#34;可搬性の話:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;可搬性の話&lt;/h1&gt;

&lt;p&gt;ところで、pthreadはp(POSIX)の名が付いている通り様々なプラットフォームで利用出来、そしてそれぞれのプラットフォーム毎に実装が異なります。
勿論、POSIXで定められているのでAPIレベルでは互換性がある(≒関数のバインディングは問題ない)のですが、ABI、データの表現に互換性がありません(≒データ型のバインディングに問題がある)&lt;/p&gt;

&lt;p&gt;実はその辺で苦労がありました。今のところ手元の環境(Linux)でしか移植が済んでません。しかし他のプラットフォームの移植は書ける形になっています。
これは&lt;a href=&#34;//KeenS.github.io/blog/2015/12/26/sml_tocpuripurosessanorenkei/&#34;&gt;以前&lt;/a&gt;書いたSMLのファイルにCのプリプロセッサを適用するというなんともいえないハックを使うことで実現しています。
他のプラットフォームに移植するには&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;どういうマクロが定義されている時にどのプラットフォームのpthreadを使っているかの対応を調べる&lt;/li&gt;
&lt;li&gt;そのプラットフォームの&lt;code&gt;pthread.h&lt;/code&gt;を入手してデータ型を移植する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;手順が必要です。私は手元の環境で動かすのが精一杯なのでMacとかで動かしたい方がいればプルリクを頂けると。
前述の通り、関数のバインディングは可搬性があるので必要なのはデータ型と定数の移植です。ある程度はプリプロセッサも使えるのでほぼヘッダファイルを移植する感じですね。&lt;/p&gt;

&lt;p&gt;まあ、実をいうと関数の移植も細々したものが面倒なので放置していたりします。ここら辺は作業ゲーなので気が向いたらやります。&lt;/p&gt;

&lt;p&gt;あとは若干迷っているのが必ずしも実装されているとは限らないオプショナルな機能の移植ですね。
バリアやリードライトロック、スピンロックがそれにあたります。
可搬性とはいってもSML#自身が動く環境が限られているのでMacでもそれらが使えるなら移植してしまおうかと思っていますがまだ調べきれてません。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;pthreadのバインディング作ったよ&lt;/li&gt;
&lt;li&gt;まだバインドが書かれてない関数もあるよ&lt;/li&gt;
&lt;li&gt;Macの移植パッチ待ってるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ATS2の観が整理出来た</title>
      <link>/post/ATS2nokangaseiridekita/</link>
      <pubDate>Fri, 01 Jan 2016 18:52:56 +0900</pubDate>
      
      <guid>/post/ATS2nokangaseiridekita/</guid>
      <description>

&lt;p&gt;κeenです。ATS2には3つの世界があります。動的な世界、静的な世界、証明の世界。
&lt;a href=&#34;//KeenS.github.io/blog/2015/12/29/ats2noizongatawotsukatteavlki/&#34;&gt;前回&lt;/a&gt;の記事では静的な世界を色々扱ってみました。
今回は証明の世界である観について少し。&lt;/p&gt;

&lt;p&gt;2016-1-2: いくつか誤植を直しました(用語で言えば、 注観→駐観 が正解でした)。&lt;/p&gt;

&lt;h1 id=&#34;観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;観&lt;/h1&gt;

&lt;p&gt;観(view)は、線形型によるリソース管理をするための仕組みです。
静的な世界と同様コンパイル時に検査されたらバイナリには現われませんが関数の引数として渡したり観を扱う関数(証明関数)を定義出来たり
動的な世界と似た部分があります。&lt;/p&gt;

&lt;h1 id=&#34;駐観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;駐観&lt;/h1&gt;

&lt;p&gt;at-viewの和訳だそうです。これは観の中でも特に特定のアドレスにデータが存在することの証明を表わす観です。
線形型の主な管理対象がメモリなので特別扱いされているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;抽象観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;抽象観&lt;/h1&gt;

&lt;p&gt;任意のリソース管理に使っていい観。これ自体は実体を持たないので後述のデータ観などで実体を与える必要があります。
ドキュメントではロックの管理だとかに使う例が載っていました。&lt;/p&gt;

&lt;h1 id=&#34;観型:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;観型&lt;/h1&gt;

&lt;p&gt;ただ単に観と型をくっつけたものです。「あると便利なのは分かるけど…」と思ってましたが、だんだん理解が追いついてきました。&lt;/p&gt;

&lt;p&gt;1つには観と型を1つの記法で表わせるので記述が楽になる。もう1つにはある型に対して必ず線形型によるリスース管理がされることを保証出来る。&lt;/p&gt;

&lt;p&gt;もう1つの用途が思い浮かんだらなるほど、となりました。&lt;/p&gt;

&lt;p&gt;こちらは駐観に限らず任意の観と任意の型を組み合わせれるようです。&lt;/p&gt;

&lt;h1 id=&#34;データ観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;データ観&lt;/h1&gt;

&lt;p&gt;動的な世界でのデータ型のように、静的な世界でのデータ種のように、証明の世界にもデータ観というものがあります。&lt;/p&gt;

&lt;p&gt;例えば、あるかもしれないしないかもしれないリソースを表わすのにオプショナル観が使えそうだ、など。&lt;/p&gt;

&lt;p&gt;これ自体は新しい観を作るためのものです。&lt;/p&gt;

&lt;h1 id=&#34;データ観型:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;データ観型&lt;/h1&gt;

&lt;p&gt;これは動的な世界と証明の世界両方に跨るものです。おおざっぱにはデータ型とデータ観を組み合わせたものです。
つまり、データ型であり、データ観であり、両方合わさってるので観型でもあります。&lt;/p&gt;

&lt;p&gt;「データ型を観で管理しようとしたら同じようなデータ観を作ることになるしまとめて作れたら嬉しいよね」が一番分かりやすい説明でしょうか。&lt;/p&gt;

&lt;p&gt;データ観型専用のシンタックスなどもあるようなので単なるシンタックスシュガーではなさそうです。&lt;/p&gt;

&lt;p&gt;こちらは駐観というかメモリ管理の観が割り当てられるみたいです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Rustと比べると随分リッチなリソース管理が出来ますね。&lt;/p&gt;

&lt;h1 id=&#34;まだ良く分かってない部分:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;まだ良く分かってない部分&lt;/h1&gt;

&lt;p&gt;ATS2にはprop（命題）というものもあります。「観はpropの線形バージョン」と書いてあるのですがどう分けられているのでしょうか。
例えば観型にpropは渡せなそうな気がしますが、証明関数には命題も観も渡せそうな気がします。&lt;/p&gt;

&lt;p&gt;微妙に命題と観が共存していたり排他的であったりします。動的な世界のdatatyp, 静的な世界のdatasort, 証明の世界のdataviewという理解でいるとdatapropの居場所がなくなります。&lt;/p&gt;

&lt;p&gt;今のところ、証明の世界も普通の命題であるpropと線形の命題であるviewに分かれていて、
それらはsortが違うので一部では排他的であり、どちらのsortに対しても対応しているものもあるので共存してるようにも見えるという仮説を立てています。&lt;/p&gt;

&lt;p&gt;ドキュメントにも種viewや種propという記述があるので種がsortが違うのは正しそうです。&lt;/p&gt;

&lt;p&gt;しかしそうするとdatasortとかで新しく作った種はどこの世界に住むことになるんでしょうか。静的な世界?証明の世界に住む新しい種を定義出来ない?&lt;/p&gt;

&lt;p&gt;ビルトインの種viewと種propの静的な項(の静的な項)だけが証明の世界の住人になれる?&lt;/p&gt;

&lt;p&gt;datasortとかで作った新しい種は依存型や依存命題(?)、依存観(?)で使うためにある?&lt;/p&gt;

&lt;p&gt;分からないことが多いですね。もう少しATS2の世界の整理をつけたい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ATS2の依存型を使ってAVL木</title>
      <link>/post/ATS2noizongatawotsukatteAVLki/</link>
      <pubDate>Tue, 29 Dec 2015 23:40:45 +0900</pubDate>
      
      <guid>/post/ATS2noizongatawotsukatteAVLki/</guid>
      <description>

&lt;p&gt;κeenです。少しばかりATS2を触ってみたので成果報告でも。&lt;/p&gt;

&lt;p&gt;AVL木は左右のノードの高さが高々1しか違わない平衡二分木です。OCamlやSMLでナイーブに実装すると本当に1しか違わないことを保証するのは難しく、精々テストなどで部分的に検査するだけです。&lt;/p&gt;

&lt;p&gt;ところがSMLに似た文法を持つATS2には依存型があり、左右のノードの高さが高々1しか違わないことを型で保証出来ます。
つまり、左右のノードの高さが2以上違う木を作ろうとしてもコンパイルエラーになるのでコンパイルが通れば高さについてはバグがないこと保証されます。&lt;/p&gt;

&lt;p&gt;そういうAVL木を使ってTreeSetを作ってみたので紹介します。&lt;/p&gt;

&lt;p&gt;私のブログ(のこの記事)の読者ならATS2も依存型もAVL木も知ってそうですが一応説明します。&lt;/p&gt;

&lt;h1 id=&#34;ats2って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;ATS2って何?&lt;/h1&gt;

&lt;p&gt;詳しい説明は&lt;a href=&#34;http://jats-ug.metasepi.org/#document&#34;&gt;日本ATSユーザグループ&lt;/a&gt;に譲るとして、この記事にて重要な点を挙げます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SMLに似た文法を持つML方言&lt;/li&gt;
&lt;li&gt;型の部分に型以外の項（例えば整数とか）が使える&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E5%9E%8B&#34;&gt;依存型&lt;/a&gt;を持つ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他にももっと素晴しい型システムや機能、特徴があるのですがとりあえずのところは上記の特徴を押えておいて下さい。&lt;/p&gt;

&lt;h1 id=&#34;依存型って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;依存型って何?&lt;/h1&gt;

&lt;p&gt;先程も述べた通り、ざっくり言うと型の部分に型以外の項が使える型システムです。&lt;/p&gt;

&lt;p&gt;例えば、次のSMLのコードを考えてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Array.get(arr: int array, index: int): int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型から読み取れるのは「&lt;code&gt;int&lt;/code&gt;の配列&lt;code&gt;arr&lt;/code&gt;と整数&lt;code&gt;index&lt;/code&gt;を受け取って&lt;code&gt;int&lt;/code&gt;の値を返す」関数です。
しかしこの関数は&lt;code&gt;index&lt;/code&gt;が&lt;code&gt;arr&lt;/code&gt;の長さよりも大きい時に実行時例外を上げます。内部でメモリを護るために境界チェックをして、チェックに落ちた時に例外を挙げている筈です。。
配列アクセスの度に実行時例外をハンドルするのはコード上もパフォーマンス上も避けたいですよね。
こういうものをコンパイル時に防ぎたくありませんか？無駄な境界チェックを省きたくありまんか？依存型を使えばそれが出来ます。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;array_get{n, i: nat| i &amp;lt; n}(arr: arrayref(int, n), index: int(i)): int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは「長さ&lt;code&gt;n&lt;/code&gt;の&lt;code&gt;int&lt;/code&gt;配列&lt;code&gt;arr&lt;/code&gt;と&lt;code&gt;n&lt;/code&gt;以下の自然数&lt;code&gt;index&lt;/code&gt;を受け取って&lt;code&gt;int&lt;/code&gt;の値を返す」関数です。
正しい入力しか受け取らないので実行時例外が起きませんし内部で境界チェックも必要ありません。面白くないですか？&lt;/p&gt;

&lt;p&gt;私も大して型システムに詳しくないのでこのくらいの例しか挙げることが出来ませんがきっとさらに面白い世界が広がっているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;avl木って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;AVL木って何？&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/AVL%E6%9C%A8&#34;&gt;Wikipedia&lt;/a&gt;を参照すると詳しいことが載っています。前の説明を繰り返すと、左右のノードの高さが高々1しか違わない平衡二分木です。自身の高さは左右の高さの高い方+1です。
データ構造は左右の木、ノードの保持する値の他にそのノードの高さを保持します。&lt;/p&gt;

&lt;p&gt;なので平衡度は赤黒木より高く、検索が高速な一方、要素数を変更する操作の度に平衡を取らないといけないので挿入や削除は赤黒木に負けるそうです。
OCamlのstdlibのMap/Setの実装に使われています。(OCamlは左右の高さが高々2違う木なので厳密にはAVL木ではないのですがアルゴリズムは同じです。)&lt;/p&gt;

&lt;p&gt;因みにAVLは人の名前の頭文字みたいです。&lt;/p&gt;

&lt;h1 id=&#34;作ってみよう:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;作ってみよう&lt;/h1&gt;

&lt;p&gt;今回、ATS2の依存型に関係ない機能、関数テンプレートなどは理解（読解）の妨げになると判断してそれらを使わないコード例を出します。
(関数テンプーレートを使わなくても多相型を使えば良さそうですが、ATS wayではなさそうです。)&lt;/p&gt;

&lt;p&gt;ということで、整数を格納するSetを作ってみましょう。&lt;/p&gt;

&lt;p&gt;実装に先立って、&lt;a href=&#34;https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml&#34;&gt;OCamlのSet&lt;/a&gt;や&lt;a href=&#34;https://tech.bezoomnyville.com/2015/12/07/A-GADT-implementation-of-AVL-tree.html&#34;&gt;GADTを使ったAVLの実装&lt;/a&gt;を読んでおくと比較が出来るかと思います。&lt;/p&gt;

&lt;p&gt;今回OCamlのSetを参考にして作ったので比較のためにコードを載せたいのですがOCamlは確かコードの再配布に厳しいライセンスだった気がするのでやめておきます。(スニペットくらいなら著作権は発生せず、ライセンス関係なしに使えるのですが念のため。)&lt;/p&gt;

&lt;h2 id=&#34;おまじない:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;おまじない&lt;/h2&gt;

&lt;p&gt;標準的な操作を取り込むため、以下をファイルの先頭に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;#include &amp;quot;share/atspre_staload.hats&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;データ型:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;データ型&lt;/h2&gt;

&lt;p&gt;高さnのAVL木を表わすデータ型を考えます。このデータ型は、&amp;rdquo;型パラメータとして&amp;rdquo;木の高さnを取ります。&lt;/p&gt;

&lt;p&gt;書き出しはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続けて、Emptyを書きます。Emptyは高さ0です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
    Empty(0)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いて、Nodeですが、左の木の高さと右の木の高さを表わす変数を導入します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat} Node of ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このクルクル括弧&lt;code&gt;{}&lt;/code&gt;で囲まれた部分は「任意の&lt;code&gt;nat&lt;/code&gt;なる&lt;code&gt;l&lt;/code&gt;,&lt;code&gt;m&lt;/code&gt;に対して」と読めば読み易いです。&lt;/p&gt;

&lt;p&gt;データ構造は、左右の木、値、高さを持つのでした。ここで、高さは&lt;code&gt;n&lt;/code&gt;であると型で制約されてます。ということでこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat} Node of (avlt(l), int, avlt(m), int(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の高さの部分で&lt;code&gt;int(n)&lt;/code&gt;となっているのは、&lt;code&gt;n&lt;/code&gt;は種&lt;code&gt;int&lt;/code&gt;であって型ではないので「整数&lt;code&gt;n&lt;/code&gt;の&lt;code&gt;int&lt;/code&gt;&amp;ldquo;型&amp;rdquo;」にする為に&lt;code&gt;int()&lt;/code&gt;を適用する必要があるのです。依存型だと「ただの整数値」だけでなく「整数3」などの型も作れるのです。&lt;/p&gt;

&lt;p&gt;さて、このままだと左右の木の高さが高々1しか違わないということを表わせていません。さらにいうと、自身の高さについての制約も書けていません。これらの制約はこう書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat | &amp;lt;制約&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回の制約はこうなりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat |
    (l + 2 == n &amp;amp;&amp;amp; m + 1 == n) || // 右が左より1高い 又は
    (l + 1 == n &amp;amp;&amp;amp; m + 1 == n) || // 左右同じ高さ 又は
    (l + 1 == n &amp;amp;&amp;amp; m + 2 == n)    // 左が右より1高い
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果、データ型はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
    Empty(0)
  | {l, m: nat |
    (l + 2 == n &amp;amp;&amp;amp; m + 1 == n) ||
    (l + 1 == n &amp;amp;&amp;amp; m + 1 == n) ||
    (l + 1 == n &amp;amp;&amp;amp; m + 2 == n)
} Node of (avlt(l), int, avlt(m), int(n))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中々複雑ですね。&lt;/p&gt;

&lt;h2 id=&#34;height:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;軽い関数から作っていきましょう。まずは木の高さを返す関数&lt;code&gt;height&lt;/code&gt;です。高さ&lt;code&gt;n&lt;/code&gt;の木を受け取って整数&lt;code&gt;n&lt;/code&gt;を返します。&lt;/p&gt;

&lt;p&gt;書き出しはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;code&gt;n&lt;/code&gt;を導入します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数は「高さ&lt;code&gt;n&lt;/code&gt;の木」ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n))...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値は「整数&lt;code&gt;n&lt;/code&gt;」です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n)): int(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数本体は普通です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n)): int(n) = 
  case+ tree of
  | Empty () =&amp;gt; 0
  | Node (_, _, _, n) =&amp;gt; n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで使っている&lt;code&gt;case+&lt;/code&gt;ですが、普通の&lt;code&gt;case&lt;/code&gt;より強くて網羅性検査に落ちるとコンパイルエラーになります。&lt;/p&gt;

&lt;h2 id=&#34;create:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;これから&lt;code&gt;insert&lt;/code&gt;を実装していく訳ですが、ユーティリティから少しづつ実装していきます。まずは高さが高々1しか違わない木2つと値を1つ受け取って新たな木を作る&lt;code&gt;create&lt;/code&gt;です。&lt;code&gt;Node&lt;/code&gt;を生で使うのに比べて高さの計算が必要なくなります。&lt;/p&gt;

&lt;p&gt;これは先に実装を与えて、後で型を考えましょう。先程の&lt;code&gt;height&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create??(l: ??, v: int, r: ??): ?? = let
  val hl = height l
  val hr = height r
in
  if hl &amp;gt;= hr
  then Node(l, v, r, hl + 1)
  else Node(l, v, r, hr + 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、型を考えていきます。まずは&lt;code&gt;l&lt;/code&gt;と&lt;code&gt;r&lt;/code&gt;はある高さを持つ木です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{l, m: nat} (l: avlt(l), v: int, r: avlt(m)): ?? = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、左右で高さが高々1しか違わないことを制約したいです。これは&lt;code&gt;Node&lt;/code&gt;の定義を参考にすると書けるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{
  l, m: nat |
  l + 1 == m ||
  l == m + 1 ||
  l == m
  } (l: avlt(l), v: int, r: avlt(m)): ?? = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に返り値の型を考えます。返り値は「&lt;code&gt;l&lt;/code&gt;か&lt;code&gt;m&lt;/code&gt;どちらか大きい方+1の高さを持つ木」です。私は最初、それをこう表現していました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create...(...): [n: nat | n == m + 1 || n == l + 1] avlt(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[n: nat | n == m + 1 || n == l + 1] avlt(n)&lt;/code&gt;の部分を読み下すと、「&lt;code&gt;n = m + 1&lt;/code&gt;又は&lt;code&gt;n = l + 1&lt;/code&gt;を満たす&lt;code&gt;n&lt;/code&gt;に対して&lt;code&gt;avlt(n)&lt;/code&gt;」という型になります。これは、間違ってはいないのですが正確ではありませんでした。なぜならこの型に忠実に従うと&lt;code&gt;l = m + 1&lt;/code&gt;の時に&lt;code&gt;n = m + 1&lt;/code&gt;、すなわち&lt;code&gt;n = l&lt;/code&gt;もありえてしまいます。勿論そんなことはなく、&lt;code&gt;l = m + 1&lt;/code&gt;ならば&lt;code&gt;n = l + 1&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;よって正しい型は&lt;code&gt;[n: nat | (m &amp;gt; l &amp;amp;&amp;amp; n == m + 1) || (l &amp;gt;= m &amp;amp;&amp;amp; n == l + 1)] avlt(x, n)&lt;/code&gt;です。やたら長いですね。&lt;/p&gt;

&lt;p&gt;全体を載せると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{
  l, m: nat |
  l + 1 == m ||
  l == m + 1 ||
  l == m
  } (l: avlt(l), v: int, r: avlt(m)): [n: nat | (m &amp;gt; l &amp;amp;&amp;amp; n == m + 1) || (l &amp;gt;= m &amp;amp;&amp;amp; n == l + 1)] avlt(n) = let
  val hl = height l
  val hr = height r
in
  if hl &amp;gt;= hr
  then Node(l, v, r, hl + 1)
  else Node(l, v, r, hr + 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;rotate:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;rotate&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;OCamlのSetでは1まとめに&lt;code&gt;bal&lt;/code&gt;としていますが、条件分岐が多すぎて読みづらいので&lt;code&gt;right&lt;/code&gt;と&lt;code&gt;left&lt;/code&gt;に分離することにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rotate_xxx&lt;/code&gt;は、左右で高さがちょうど2違う木と値を受け取って、バランスのとれた木を作って返す関数です。
&lt;code&gt;rotate_right&lt;/code&gt;なら左の木が右の木より2高い木を受け取って上手い具合に木の付け替えをして新たな木を返します。&lt;/p&gt;

&lt;p&gt;返り値の木は左の木と同じ高さかあるいはそれより1高い木です。&lt;/p&gt;

&lt;p&gt;そろそろ慣れてきたと思うので型までを一気に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、さらに左側の木の左右の高さでも場合分けが必要になるのでまずは色々バラします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let
  val+ Node(ll, lv, lr, _) = l
  val hll = height ll
  val hlr = height lr
in
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、ここが一番面白い所です。&lt;code&gt;val+ Node(ll, lv, lr, _) = l&lt;/code&gt;に注目して下さい。 OCamlでは&lt;code&gt;match l with Empty -&amp;gt; invalid_arg &amp;quot;Set.bal&amp;quot; | Node (ll, lv, lr, _) -&amp;gt; ...&lt;/code&gt;となっていた部分です。
型制約から、&lt;code&gt;l&lt;/code&gt;は高さ2以上の木であることが分かっているので&lt;code&gt;Empty&lt;/code&gt;でないことが保証されます。なので &lt;strong&gt;&lt;code&gt;Node&lt;/code&gt;だけで網羅出来ているとコンパイラが理解してくれ&lt;/strong&gt; ます。マッチが1節しかないので&lt;code&gt;val&lt;/code&gt;のパターンマッチで代用出来ますね。
&lt;code&gt;val+&lt;/code&gt;は&lt;code&gt;case+&lt;/code&gt;と同じく網羅性検査に落ちるとコンパイルエラーになるバージョンの&lt;code&gt;val&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;残りの実装をまとめると、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let
  val+ Node(ll, lv, lr, _) = l
  val hll = height ll
  val hlr = height lr
in
  if  hll &amp;gt;= hlr
  then create(ll, lv, create(lr, v, r))
  else let
       val+ Node(lrl, lrv, lrr, _) =  lr
  in
    create(create(ll, lv, lrl), lrv, create(lrr, v, r))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rotate_left&lt;/code&gt;はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_left{hl, hr: nat |
  hl + 2 == hr
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hr || n == hr + 1] avlt(n) = let
  val+ Node(rl, rv, rr, _) = r
  val hrl = height rl
  val hrr = height rr
in
  if  hrr &amp;gt;= hrl
  then create(create(l, v, rl), rv, rr)
  else let
    val+ Node(rll, rlv, rlr, _) =  rl
  in
    create(create(l, v, rll), rlv, create(rlr, rv, rr))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bal:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;bal&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;rotate_right&lt;/code&gt;, &lt;code&gt;rotate_left&lt;/code&gt;, &lt;code&gt;create&lt;/code&gt;を1まとめにして左右の高さの差が高々2の2つの木と値を受け取ってバランスのとれた木を作って返す&lt;code&gt;bal&lt;/code&gt;を作りましょう。&lt;/p&gt;

&lt;p&gt;型がエグいことになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun bal{hl, hr: nat |
  ~2 &amp;lt;= hl - hr  &amp;amp;&amp;amp; hl - hr &amp;lt;= 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat|
 (hl == hr - 2 &amp;amp;&amp;amp; n == hr    ) ||
 (hl == hr - 2 &amp;amp;&amp;amp; n == hr + 1) ||
 (hl == hr - 1 &amp;amp;&amp;amp; n == hr + 1) ||
 (hl == hr     &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 1 &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 2 &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 2 &amp;amp;&amp;amp; n == hl    )
] avlt(n) = let
  val hl = height l
  val hr = height r
in
  if hl = hr + 2
  then rotate_right(l, v, r)
  else if hl = hr - 2
  then rotate_left(l, v, r)
  else create(l, v, r)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cmp:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;さて、本来のOCamlのSetはファンクタで出来てますがATS2には原始的なファンクタしかないのでファンクタを使わずにこれまで実装してきました。
あまりよろしくありませんが&lt;code&gt;cmp&lt;/code&gt;もベタっと実装してしまいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun cmp(x: int, y: int): int = x - y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;empty-singleton:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;singleton&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun empty(): avlt(0) = Empty()
fun singleton(x: int): avlt(1) = Node(Empty, x, Empty, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insert:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ここまで辿りついたらもう難しいところはありません。&lt;code&gt;insert&lt;/code&gt;した結果、木の高さが変わらないか1増えるだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun insert{m: nat}(x: int, tree: avlt(m)): [n: nat | n == m || n == m + 1]avlt(n) =
  case+ tree of
  | Empty () =&amp;gt; singleton(x)
  | t as Node(l, v, r, _) =&amp;gt; let
    val c = cmp(x, v)
  in
    if c = 0 then t
    else if c &amp;lt; 0
    then bal(insert(x, l), v, r)
    else bal(l, v, insert(x, r))
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mem:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;mem&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun mem{m: nat}(x: int, tree: avlt(m)): bool =
  case+ tree of
  | Empty () =&amp;gt; false
  | Node(l, v, r, _) =&amp;gt; let
    val c = cmp(x, v)
  in
    if c = 0
    then true
    else if c &amp;lt; 0
    then mem(x, r)
    else mem(x, l)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;遊ぶ:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;遊ぶ&lt;/h1&gt;

&lt;p&gt;さて、少しばかり遊んでみましょう&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;
implement
main0 () =  {
  val tree = Empty
  val tree = insert(1, tree)
  val tree = insert(2, tree)
  val tree = insert(4, tree)
  val b = mem(2, tree)
  val c = mem(3, tree)
  val () = fprintln!(stdout_ref, b)
  val () = fprintln!(stdout_ref, c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これまでのファイルを&lt;code&gt;avlset_int.dat&lt;/code&gt;に保存して、以下のようにコンパイル/実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ patscc avlset.dats -DATS_MEMALLOC_LIBC
$ ./a.out
true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと動いているようです。(GCをリンクしてないのでメモリリークしてる気がしますが、GCのリンクの仕方が分からなかったのでこのままにします。)&lt;/p&gt;

&lt;p&gt;追記: GCのリンクの仕方を教えてもらいました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; GC付きコンパイルには -DATS_MEMALLOC_GCBDW -lgc を使うようです。僕も今知りました。。。 / master · githwxi/ATS-Postiats-contrib &lt;a href=&#34;https://t.co/4DPotHeUJ1&#34;&gt;https://t.co/4DPotHeUJ1&lt;/a&gt;&lt;/p&gt;&amp;mdash; Myu-Myu- ATS-tan! (@masterq_mogumog) &lt;a href=&#34;https://twitter.com/masterq_mogumog/status/682142334704717824&#34;&gt;2015, 12月 30&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;まとめ:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;依存型を持つATS2を使うことでAVL木の高さに関する要件を必ず満たす木を作ることが出来ました。
これは変な入力がないことを保証するばかりでなく、自らの実装がバグっていないことの確認にも使えます。
また、&lt;code&gt;val+&lt;/code&gt;の例で見た通り、パターンマッチについてもより厳格な検査が出来るので無意味なコードを書かなくて済みました。&lt;/p&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/avlset&#34;&gt;こちら&lt;/a&gt;に置いておきます。また、関数テンプレートを使ったよりジェネリックな実装もあります。&lt;/p&gt;

&lt;h1 id=&#34;ノート:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;今回型レベルで保証したのは高さに対する要件だけでした。
「ノードの左側の木にはそのノードの保持する値より小さい値しか入っていない」「一度&lt;code&gt;insert&lt;/code&gt;した値は&lt;code&gt;mem&lt;/code&gt;すると&lt;code&gt;true&lt;/code&gt;が返ってくる」などの要件については無保証のままです。
実はATS2には&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/c2849.html&#34;&gt;定理証明器&lt;/a&gt;も付いており、そのような振舞に関しても保証出来ます。&lt;/li&gt;
&lt;li&gt;ATS2には依存型の他にも&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/p3301.html&#34;&gt;線形型&lt;/a&gt;を持っていて、GCに頼らないメモリ管理が可能です。
今回のコードも線形型を使ってメモリリークしないように出来るでしょう。&lt;/li&gt;
&lt;li&gt;関数テンプレートを使ったAVL木の実装には若干危い点があります。関数テンプレートは実装をアドホックに変更出来るので
比較関数を差し替えれてしまいます。&lt;code&gt;cmp(x, y) = x - y&lt;/code&gt;で木を作った後に&lt;code&gt;cmp(x, y) = y - x&lt;/code&gt;にしてさらに要素を挿入したら大惨事になるでしょう。
そこまで気にするようなら&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/x1974.html&#34;&gt;ファンクタ&lt;/a&gt;を使うべきです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;その他:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;その他&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CoqやAgdaのように依存型も定理証明器もある言語がありますが、それらと違ってATS2は「汎用プログラミング言語に表現力の高い依存型を付けて、ついでに定理証明器もついてる」くらいです。
本格的な証明には向かない一方汎用プログラミングにはATS2の方が向いているでしょう。&lt;/li&gt;
&lt;li&gt;しかしCoqと似ている面もあり、ATS2の世界で依存型や線形型、証明などで強い保証を付けた後は一旦Cのコードをエクストラクトして、それをコンパイルしています。&lt;/li&gt;
&lt;li&gt;Cにエクストラクトされるということで、ATS2はCとの相互連携が出来ます。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、ATS2には心躍る特徴がたくさんあります。依存型で実行時検査をコンパイル時検査に持ち上げ、定理証明器でバグも潰せて、
線形型でボックス/アンボックデータの扱いやGCに頼らないリソース管理やデータ競合の回避が出来、
並列プログラミングもサポート、低レベルなCのコードを呼べてバイナリサイズも小さいなどなど。&lt;/p&gt;

&lt;p&gt;しかし、これらの機能を得るのにATS2は1つだけ代償を払いました。学習コストです。
私はCも書きますしSMLも書きます。依存型のあるCoqや線形型より少し弱いアフィン型のあるRustも書いたことがあります。そんな私にもATS2は難解です。
最近難解な言語として名高くなってきたRustですら足元に及ばないでしょう。&lt;/p&gt;

&lt;p&gt;それでも、急峻な学習曲線の崖をよじ登った先には素晴しい世界が広がっているのです。1つ、修行だと思ってトライしてみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://fumieval.tumblr.com/post/28324791101/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%81%AE%E5%8C%BA%E5%88%86&#34;&gt;プログラマの区分&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#とCプリプロセッサの連携</title>
      <link>/post/SML_toCpuripurosessanorenkei/</link>
      <pubDate>Sat, 26 Dec 2015 20:09:24 +0900</pubDate>
      
      <guid>/post/SML_toCpuripurosessanorenkei/</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第3段はSML#とCプリプロセッサで連携する話。&lt;/p&gt;

&lt;p&gt;SML#のC FFIを使ってるとマクロで定義された値などを触りたくなるのですが、触れないのでどうにかしようかと。&lt;/p&gt;

&lt;p&gt;発想自体は単純で、SMLファイルの中でCのヘッダをインクルードしてCプリプロセッサを呼んであげればどうにかなります。&lt;/p&gt;

&lt;h1 id=&#34;簡単な例:17ab4ed508953994d38c55ce3a68a752&#34;&gt;簡単な例&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;//KeenS.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi/&#34;&gt;JITを作る話&lt;/a&gt;の時のように、定数に触りたいとします。
その時、以下のように.smlファイルを記述して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* 
#include&amp;lt;sys/mman.h&amp;gt;
*)

(* ====END_OF_HEADER==== *)
datatype dummy = $ of int
              
val $PROT_READ  = $ PROT_READ
val $PROT_WRITE = $ PROT_WRITE
val $PROT_EXEC  = $ PROT_EXEC
val $PROT_NONE  = $ PROT_NONE

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E cpp_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; cpp.sml 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントを挙げると、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;smlファイルに&lt;code&gt;#include&lt;/code&gt;を書く。lintでエラーが出ないように&lt;code&gt;#include&lt;/code&gt;はコメントで囲む&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt;をコメントで囲ったところで安全でない( インクルードしたファイルに&amp;rsquo;&lt;code&gt;*)&lt;/code&gt;&amp;lsquo;、例えば &lt;code&gt;int f(char *);&lt;/code&gt;とかが入ってるとコメントが終端される)ので、&lt;code&gt;include&lt;/code&gt;の部分は後で削除する。
そのための識別子として、&lt;code&gt;====END_OF_HEADER====&lt;/code&gt;を置いておく(これも完全には安全ではないが比較的マシ)。&lt;/li&gt;
&lt;li&gt;Cのマクロと同じ識別子を使おうとすると識別子も置換されてしまうので左辺にダミーで&lt;code&gt;$&lt;/code&gt;をつけておく。スペースは空けない。
逆に右辺は置換されてほしいので&lt;code&gt;$&lt;/code&gt;の後にスペースを空ける。&lt;/li&gt;
&lt;li&gt;最後にCプリプロセッサを呼び、sedでヘッダ部分や無駄に追加されたCのコメントを除く。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ちょっと&lt;code&gt;$&lt;/code&gt;の部分がこの方式だとintにしか使えないのでイケてませんがないよりマシでしょう。因みに処理結果はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype dummy = $ of int

val $PROT_READ = $ 
                   0x1

val $PROT_WRITE = $ 
                   0x2

val $PROT_EXEC = $ 
                   0x4

val $PROT_NONE = $ 
                   0x0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ifdef:17ab4ed508953994d38c55ce3a68a752&#34;&gt;&lt;code&gt;ifdef&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;一旦発想さえ得てしまえば話は簡単です。次は&lt;code&gt;ifdef&lt;/code&gt;を使う例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* ====END_OF_HEADER==== *)


(* 
#ifdef Debug
*)
val debug = true
(* 
#else
*)
val debug = false

(* 
#endif
*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E -DDebug ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;Debug&lt;/code&gt;を定義して処理すればifdef.smlの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*

*)
val debug = true
(*






*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となりますし、定義せずに&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
``` sh
cpp -pipe -E ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と処理すれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*





*)
val debug = false

(*

*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってどちらでもSMLとして有効な文法になります。&lt;code&gt;ifndef&lt;/code&gt;だったり、&lt;code&gt;elif&lt;/code&gt;があったとしても有効な文法のままです。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:17ab4ed508953994d38c55ce3a68a752&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CプリプロセッサでSMLファイルを処理する方法を提示したよ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifdef&lt;/code&gt;も使えるよ&lt;/li&gt;
&lt;li&gt;関数マクロは使えないよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#のオレオレREPLを作る話 初級</title>
      <link>/post/SML_nooreoreREPLwotsukuruhanashi_shokyuu/</link>
      <pubDate>Sat, 26 Dec 2015 19:48:30 +0900</pubDate>
      
      <guid>/post/SML_nooreoreREPLwotsukuruhanashi_shokyuu/</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第2段はSML#のオレオレREPLを作る話の初級。&lt;/p&gt;

&lt;p&gt;SML#にはFFIがあり、任意のオブジェクトファイル/ライブラリをリンクしてC関数を呼び出すことが出来ますが、REPLで試そうとしてもREPLにリンクされていないので呼び出せません。
そこで呼び出したいオブジェクトファイルをリンクしたREPLを作れば捗るよね、という発想です。&lt;/p&gt;

&lt;h1 id=&#34;事前に必要なもの:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;事前に必要なもの&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;SML#のビルド時に使ったLLVMのパス&lt;/li&gt;
&lt;li&gt;SML#をビルドした時のオブジェクトファイルの残骸（一部）&lt;/li&gt;
&lt;li&gt;SML#のソーコード（一部）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;コマンド:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;コマンド&lt;/h1&gt;

&lt;p&gt;まず、普通のREPLを作るだけならこれだけです。（コンパイラも一緒にくっついてきますが面倒なのでそのままにしてます。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o oreore_repl &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot;  &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは最後のリンクコマンドにフラグを足せばいいでしょう。注意点として、64bit OSを使ってるならちゃんと32bitでビルドしたライブラリをリンクしましょう。例えばlibuvをリンクするならこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o smlsharp_uv &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot; -L /opt/libuv32/lib -luv &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;終わりに:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;終わりに&lt;/h1&gt;

&lt;p&gt;やり方さえ分かってしまえば簡単ですが見付けるのが難しい小ネタでした。因みに今回初級ですが、REPLにlibeditを統合するなどの上級ネタはいつか気が向いたら書くかもしれません。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>