<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Advent Calendar 2015 on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/advent-calendar-2015/</link>
    <description>Recent content in Advent Calendar 2015 on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Dec 2015 17:14:18 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/advent-calendar-2015/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rustでの日本語の扱い</title>
      <link>http://keens.github.io/blog/2015/12/13/rustdenonihongonoatsukai</link>
      <pubDate>Sun, 13 Dec 2015 17:14:18 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/13/rustdenonihongonoatsukai</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar&lt;/a&gt; 14日目の記事です&lt;br /&gt;
前:gifnksmさんの &lt;a href=&#34;http://gifnksm.hatenablog.jp/entry/2015/12/13/204655&#34;&gt;kcovを使ってRustプログラムのカバレッジを測定する - gifnksmの雑多なメモ&lt;/a&gt;&lt;br /&gt;
後:nacika_insさんのtimeこわい&lt;/p&gt;

&lt;p&gt;κeenです。当初の予定より小ネタになってしまいましたがRustでの日本語の扱いについて書こうかと。&lt;/p&gt;

&lt;p&gt;ご存じの通りRustはマルチバイト文字をサポートしていますが、その殆どがUTF-8だけです。しかし日本人にはUTF-8だけでは少し辛いものがありますのでどうにかして対応しようかと。&lt;/p&gt;

&lt;p&gt;ソースコード中でもマルチバイト文字を扱えますが、UTF-8である必要があります。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rs&#34;&gt;fn main() {
  println!(&amp;quot;あああ&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをISO-2022-JPで保存してrustcに食わせても、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error: couldn&#39;t read &amp;quot;src/main.rs&amp;quot;: stream did not contain valid UTF-8
Could not compile `japanese`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と無下もないエラーが出てしまいます。&lt;/p&gt;

&lt;p&gt;内部エンコーディングにもUTF-8が使われているのでRustの文字列をUTF-8以外で出力するにはなんとなく変換が必要そうなのは理解出来ますが、変に出入力をラップしてる関数を使うとまた意図せぬエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;

fn main() {
  let file = File::open(&amp;quot;japanese.txt&amp;quot;);
  let br = BufReader::new(&amp;amp;file);
  for line in br.lines() {
    matich line {
      Ok(l) =&amp;gt; println!(&amp;quot;Ok: {}&amp;quot;, l),
      Err(e) =&amp;gt; println!(&amp;quot;{:?}&amp;quot;, e)
    };
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもまた、&lt;code&gt;stream did not contain valid UTF-8&lt;/code&gt;エラーを出します。&lt;/p&gt;

&lt;p&gt;ReadもBufReadもbyte orientedって言ってるのに何故か文字列を扱えるのが若干気になりますがまあ、そういうもんなんでしょう。&lt;/p&gt;

&lt;h1 id=&#34;encoding:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;encoding&lt;/h1&gt;

&lt;p&gt;そこで救世主となるライブラリが&lt;a href=&#34;https://github.com/lifthrasiir/rust-encoding&#34;&gt;lifthrasiir/rust-encoding&lt;/a&gt;です。文字列のエンコーディングをサポートします。
READMEに詳しい使い方が載っているのですが、このライブラリは与えられたスライスに対して指定されたエンコーディングでエンコード/デコードします。&lt;/p&gt;

&lt;p&gt;なので先の例のようにISO-2022-JPで&lt;code&gt;&amp;quot;あああ&amp;quot;&lt;/code&gt;と出力したいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use encoding::{Encoding, EncoderTrap};
use encoding::all::ISO_2022_JP;
use std::io::Stdout;

fn main() {
  let bytes = ISO_2022_JP.encode(&amp;quot;あああ&amp;quot;, EncoderTrap::Ignore);
  Stdout.write_all(&amp;amp;bytes[..]);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出来るでしょう。(即興で書いてコンパイルすらしてないので本当に出来るかは分かりませんが)&lt;/p&gt;

&lt;p&gt;読み取りに関しては…………。そう、このライブラリはバッファに対してしか動作せず、ストリームに使えないのです。提供してくれたら良さそうなのですが、作者の方が忙しいようです。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; stream encoding/decodingは計画してはいるのですが、私が忙しくてなかなか作業をすることができません&amp;hellip; orz&lt;/p&gt;&amp;mdash; Kang Seonghoon (@senokay) &lt;a href=&#34;https://twitter.com/senokay/status/666516796942319616&#34;&gt;2015, 11月 17&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;余談ですがこの方は韓国の方のようですが、日本語もある程度分かるそうです。すごいですね。&lt;/p&gt;

&lt;p&gt;さて、ストリームに対して使えないと分かったなら自分で対応するまで。幸いにも我々が使っているのはRustです。新しいものを既存の仕組みに載せるのは造作もありません。
ストリームを良い感じにデコードするには&lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Read.html&#34;&gt;std::io::Read&lt;/a&gt;を実装した何かを作れば十分です。作っていきましょう。&lt;code&gt;Read&lt;/code&gt;トレイトを実装するには最低&lt;code&gt;read&lt;/code&gt;だけ実装してしまえば十分です。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;read&lt;/code&gt;ですが、ドキュメントを読むと中々制限が緩いようです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pull some bytes from this source into the specified buffer, returning how many bytes were read.&lt;/p&gt;

&lt;p&gt;This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an Err return value.&lt;/p&gt;

&lt;p&gt;If the return value of this method is Ok(n), then it must be guaranteed that 0 &amp;lt;= n &amp;lt;= buf.len(). A nonzero n value indicates that the buffer buf has been filled in with n bytes of data from this source. If n is 0, then it can indicate one of two scenarios:&lt;/p&gt;

&lt;p&gt;This reader has reached its &amp;ldquo;end of file&amp;rdquo; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will always no longer be able to produce bytes.
   The buffer specified was 0 bytes in length.&lt;/p&gt;

&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true. It is recommended that implementations only write data to buf instead of reading its contents.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「関数が呼ばれる際に&lt;code&gt;buf&lt;/code&gt;に対しては何如なる保証もなく、呼出側はバッファの内容に対して何如なる不変条件も期待してはいけません」とあります。つまり、4096 byteのバッファが与えられても1呼び出しにつき1バイトしか返さないような実装でも許容されます。
また、非同期ベースのIOのようにキャッシュにデータがなければIOブロッキングせずにエラーだとかの挙動もありえます。非常にシステムプログラミング言語らしい仕様ですね。&lt;/p&gt;

&lt;p&gt;今から作ろうとしているデコーディングストリームも読み出したバイト列がデコード後に何バイトになるのか予測がつかないのでこの仕様は有難いですね。&lt;/p&gt;

&lt;p&gt;さて、作っていきましょうか。まずは必要そうなライブラリを読み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use self::encoding::{EncodingRef, DecoderTrap};
use std::io::Read;
use std::io;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてメインとなる構造体です。とある&lt;code&gt;Read&lt;/code&gt;を実装した型をラップする形にしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct DecodingReader&amp;lt;R&amp;gt; {
    inner: R,
    encoding: EncodingRef,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;はトレイトなので&lt;code&gt;inner&lt;/code&gt;のところを&lt;code&gt;&amp;amp;R&lt;/code&gt;としなくて大丈夫です。&lt;code&gt;Read&lt;/code&gt;の実装側が調整します。&lt;/p&gt;

&lt;p&gt;そしてコンストラクタですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; DecodingReader&amp;lt;R&amp;gt; {
    pub fn new(coding: EncodingRef, read: R)-&amp;gt; Self {
        EncodingReader {
            inner: read,
            encoding: coding
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのままですね。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;の実装です。まずは&lt;code&gt;inner&lt;/code&gt;の&lt;code&gt;read&lt;/code&gt;を呼んで、その結果を一旦デコードしてからまたバイト列に変換します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; Read for DecodingReader&amp;lt;R&amp;gt; {
    fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;usize&amp;gt;{
        // TODO set appropriate buffer size
        let len = buf.len() / 2;
        let n = try!(self.inner.read(&amp;amp;mut buf[..len]));
        // TODO don&#39;t ignore input code
        let str = self.encoding.decode(&amp;amp;mut buf[..n], DecoderTrap::Ignore).unwrap();
        let mut i = 0;
        for (d, s) in buf.iter_mut().zip(str.bytes()) {
            *d = s;
            i+=1;
            if i == 0 {
                break
            };
        }
        assert!(i &amp;lt;= buf.len());
        Ok(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程も言った通りデコード読み込んだバイト列をUTF-8にした時にどれくらいバイト数が変わるか分からないので山勘で2倍くらいに膨らむだろうとして与えられたバッファ長の半分を使います。
ここはもう少し調整が必要ですね。エンコーディング毎に適切なバッファ長を設定したい…&lt;/p&gt;

&lt;p&gt;バッファを確保出来たら&lt;code&gt;let n = try!(self.inner.read(&amp;amp;mut buf[..len]));&lt;/code&gt;してそれっぽいサイズ読み込んで、読み込んだサイズをデコードにかけます。&lt;/p&gt;

&lt;p&gt;現在&lt;code&gt;DecoderTrap&lt;/code&gt;を&lt;code&gt;Ignore&lt;/code&gt;にして&lt;code&gt;unwrap&lt;/code&gt;してますが、これは少し雑すぎますね。例えば入力が全てvalidな文字を含んでいたとしても&lt;code&gt;read&lt;/code&gt;が多バイト文字の真ん中までしか読まなかった時にそれが無効なエンコーディングと判定されて無視されるのでユーザからしたら「合ってる筈なのに何故か1文字欠損するバグ」として現れます。今回即席で作ったので勘弁して下さい。&lt;/p&gt;

&lt;p&gt;変換は文字列にしか出来ないようなので一旦文字列に落してからまたバイト列として取り出し、バッファに書き出します。デコード後のバイト列が&lt;code&gt;read&lt;/code&gt;したバイト列より小さかったら一部&lt;code&gt;read&lt;/code&gt;したデータが残ってしまいそうですが、「何如なる不変条件も…」とあるので問題ないでしょう。返り値にデコード後のバイト列の長さを返していれば良い筈です。&lt;/p&gt;

&lt;p&gt;さて、エンコードのエラーハンドリングしてないだとか本当に読み込みのバッファ長が適切なのかとかの疑問はあるものの、一応ストリームのデコーダが出来ました。使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
extern crate japanese;

use encoding::{Encoding, DecoderTrap};
use encoding::all::ISO_2022_JP;

use std::fs::File;
use std::io::BufReader;
use std::io::BufRead;
use std::str::from_utf8;
use japanese::buf::DecodingReader;


fn main() {
    let file = File::open(&amp;quot;src/japanese.txt&amp;quot;).unwrap();
    let e = DecodingReader::new(ISO_2022_JP, &amp;amp;file);
    let mut br = BufReader::new(e);
    for line in br.lines() {
        println!(&amp;quot;{}&amp;quot;, line.unwrap());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでちゃんとISO-2022-JPのファイルを読めます。&lt;/p&gt;

&lt;p&gt;Javaに慣れてる人ならこういうIOに対するデコレータパターンは見覚えがあるでしょう。&lt;/p&gt;

&lt;p&gt;今更ですがiso-2022-jpはいわゆるjisエンコーディングです。rust-encodingはshift_jisの拡張にあたるwindows31jだとかeuc-jpも扱えます(&lt;a href=&#34;https://lifthrasiir.github.io/rust-encoding/encoding/codec/japanese/index.html&#34;&gt;参考&lt;/a&gt;)。&lt;/p&gt;

&lt;h1 id=&#34;今後:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;今後&lt;/h1&gt;

&lt;p&gt;ライブラリとして公開するか、あるいは作者の方がやる気はあるようなのでプルリクを送るかが終着点かな、と思っていますが如何せん雑にしか実装してないので微妙ですね。
例の境界とマルチバイトの問題は&lt;code&gt;Read&lt;/code&gt;じゃなく&lt;code&gt;BufRead&lt;/code&gt;を要求して1文字分読み切るまで来るまで1バイトずつ読むとかになると思います。ダルい。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Rust標準だけでUTF-8以外の文字列を使うのはつらいよ&lt;/li&gt;
&lt;li&gt;Rustのエンコーディングライブラリを紹介したよ&lt;/li&gt;
&lt;li&gt;エンコーディングライブラリを使ってストリームデコーダを実装してみたよ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/japanese&#34;&gt;こちら&lt;/a&gt;にあります&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#に学ぶコンパイラ言語におけるREPLの実装方法</title>
      <link>http://keens.github.io/blog/2015/12/12/sml_nimanabukonpairagengoniokerureplnojissouhouhou</link>
      <pubDate>Sat, 12 Dec 2015 19:42:52 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/12/sml_nimanabukonpairagengoniokerureplnojissouhouhou</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装 Advent Calendar 2015&lt;/a&gt;16日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。かねてより気になっていたREPLの実装方法について、SML#のソースコードを読んだのでその話でもします。&lt;/p&gt;

&lt;p&gt;さて、ソースコードを読みながらやっていきましょう。SML# 2.0.0のソースコードです。&lt;/p&gt;

&lt;p&gt;REPLのエントリポイントは&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/compiler/main/main/SimpleMain.sml#L949&#34;&gt;src/compiler/main/main/SimpleMain.smlL949&lt;/a&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      | Interactive (options, context) =&amp;gt;
        let
          val newContext =
              Top.loadInteractiveEnv
                {stopAt = Top.NoStop,
                 stdPath = [#systemBaseDir options],
                 loadPath = nil}
                context
                (Filename.concatPath
                   (#systemBaseDir options, Filename.fromString &amp;quot;prelude.smi&amp;quot;))
          val context =
              let
                val context = Top.extendContext (context, newContext)
                val context = Top.incVersion context
              in
                context
              end
          val _ = ReifiedTermData.init (#topEnv context)
                  handle e =&amp;gt; raise e
        in
          RunLoop.interactive options context;
          SUCCESS
        end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いろいろごちゃごちゃやってますがオプションと共に&lt;code&gt;RunLoop.interactive&lt;/code&gt;を呼んでるだけです。&lt;/p&gt;

&lt;p&gt;さて、RunLoop.smlはSimpleMain.smlと同じディレクトリにあります。&lt;code&gt;interactive&lt;/code&gt;関数は次のように定義されています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun interactive options context =
      let
        ...
        val state = initInteractive ()
        fun loop context input =
            if !(#eof state) then ()
            else
              (Counter.reset();
               NameEvalEnv.intExnConList();
               case run options context input of
                 SUCCESS newContext =&amp;gt;
                 ....
               | FAILED =&amp;gt;
                 loop (Top.incVersion context) (interactiveInput state)
              )
      in
        loop context (interactiveInput state)
      end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何やら状態を初期化した後は&lt;code&gt;interactiveInput&lt;/code&gt;で得られた結果を&lt;code&gt;run&lt;/code&gt;に渡しているようです。&lt;code&gt;run&lt;/code&gt;を見ましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun run ({stdPath, loadPath, LDFLAGS, LIBS, errorOutput, llvmOptions,
            ...}:options)
          context input =
      let
        fun puts s = TextIO.output (errorOutput, s ^ &amp;quot;\n&amp;quot;)
        val options = {stopAt = Top.NoStop,
                       baseFilename = NONE,
                       stdPath = stdPath,
                       loadPath = loadPath}
        val ({interfaceNameOpt, ...}, result) =
             Top.compile options context input
             handle e =&amp;gt;
             (
               case e of
                 UserError.UserErrors errs =&amp;gt;
                 app (fn e =&amp;gt; puts (userErrorToString e)) errs
               | UserError.UserErrorsWithoutLoc errs =&amp;gt;
                 app (fn (k,e) =&amp;gt; puts (userErrorToString (Loc.noloc,k,e))) errs
               | Bug.Bug s =&amp;gt; puts (&amp;quot;Compiler bug:&amp;quot; ^ s)
               | exn =&amp;gt; raise exn;
               raise CompileError
            )
        val (newContext, module) =
            case result of
              Top.RETURN (newContext, module) =&amp;gt; (newContext, module)
            | Top.STOPPED =&amp;gt; raise Bug.Bug &amp;quot;run&amp;quot;
      in
        let
          val objfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.OBJEXT ())
          val asmfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.ASMEXT ())
          val _ = #start Counter.llvmOutputTimeCounter()
          val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile,
                                            Filename.toString asmfile)
          val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile,
                                            Filename.toString objfile)
          val _ = #stop Counter.llvmOutputTimeCounter()
          val _ = LLVM.LLVMDisposeModule module
          val sofile = TempFile.create (SMLSharp_Config.DLLEXT ())
          val ldflags =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                [&amp;quot;-Wl,-out-implib,&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
              | SMLSharp_Config.Mingw =&amp;gt;
                [&amp;quot;-Wl,--out-implib=&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
          val libfiles =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
              | SMLSharp_Config.Mingw =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
          val _ = BinUtils.link
                    {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS
                             @ ldflags,
                     libs = libfiles @ LIBS,
                     objects = [objfile],
                     dst = sofile,
                     useCXX = false,
                     quiet = not (!Control.printCommand)}
          val so = DynamicLink.dlopen&#39; (Filename.toString sofile,
                                        DynamicLink.GLOBAL,
                                        DynamicLink.NOW)
                   handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} =
              GenerateMain.moduleName (interfaceNameOpt, #version context)
          val smap = DynamicLink.dlsym&#39; (so, stackMapSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val base = DynamicLink.dlsym&#39; (so, codeBeginSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val _ = sml_register_stackmap (smap, base)
          val ptr = DynamicLink.dlsym (so, mainSymbol)
                    handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          (*
           * Note that &amp;quot;ptr&amp;quot; points to an ML toplevel code. This toplevel code
           * should be called by the calling convention for ML toplevels of
           * ML object files.  __attribute__((fastcc,no_callback)) is an ad
           * hoc way of yielding this convention code; no_callback avoids
           * calling sml_control_suspend.  If we change how to compile
           * attributes in the future, we should revisit here and update the
           * __attribute__ annotation.
           *)
          val mainFn =
              ptr : _import __attribute__((fastcc,no_callback)) () -&amp;gt; ()
        in
          loadedFiles := sofile :: !loadedFiles;
          mainFn () handle e =&amp;gt; raise UncaughtException e;
          SUCCESS newContext
        end
        handle e =&amp;gt;
          (
            case e of
              UserError.UserErrors errs =&amp;gt;
              app (fn e =&amp;gt; puts (userErrorToString e)) errs
            | UserError.UserErrorsWithoutLoc errs =&amp;gt;
              app (fn (k,e) =&amp;gt; puts (userErrorToString (Loc.noloc,k,e))) errs
            | DLError s =&amp;gt;
              puts (&amp;quot;failed dynamic linking. Perhaps incorrect name in _import declaration: &amp;quot; ^ s)
            | UncaughtException exn =&amp;gt;
              puts (&amp;quot;uncaught exception &amp;quot; ^ exnMessage exn)
            | CoreUtils.Failed {command, message} =&amp;gt;
              (puts (&amp;quot;command failed: &amp;quot; ^ command); puts message)
            | _ =&amp;gt; raise e;
            FAILED
          )
      end
      handle CompileError =&amp;gt; FAILED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デカいですね。どうやら&lt;code&gt;run&lt;/code&gt;がREPLの本体のようです。少しずつ見ていきます。&lt;/p&gt;

&lt;p&gt;まずはコンパイルしているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;        val ({interfaceNameOpt, ...}, result) =
             Top.compile options context input
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして結果からcontextとmoduleを取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;        val (newContext, module) =
            case result of
              Top.RETURN (newContext, module) =&amp;gt; (newContext, module)
            | Top.STOPPED =&amp;gt; raise Bug.Bug &amp;quot;run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恐らくcontextが変数名とかを持っているのでしょう。
moduleに関しては&lt;code&gt;Top.compile&lt;/code&gt;が最後にLLVMEmitをしてるのでLLVMのmodule(コンパイルされる最大単位)のことだと思います。だとするとここまではまだコードはメモリ上にあるはずです。&lt;/p&gt;

&lt;p&gt;moduleを取り出した後どうしてるかというとオブジェクトファイルを作っているようです。ここでファイルに書き出されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          val objfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.OBJEXT ())
          val asmfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.ASMEXT ())
          val _ = #start Counter.llvmOutputTimeCounter()
          val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile,
                                            Filename.toString asmfile)
          val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile,
                                            Filename.toString objfile)
          val _ = #stop Counter.llvmOutputTimeCounter()
          val _ = LLVM.LLVMDisposeModule module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に呼んでるDisposeModuleはデストラクタですかね。ちゃんとお片付けしてます。&lt;/p&gt;

&lt;p&gt;さらに、ダイナミックリンクファイルを作るようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val sofile = TempFile.create (SMLSharp_Config.DLLEXT ())
          val ldflags =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                [&amp;quot;-Wl,-out-implib,&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
              | SMLSharp_Config.Mingw =&amp;gt;
                [&amp;quot;-Wl,--out-implib=&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
          val libfiles =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
              | SMLSharp_Config.Mingw =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
          val _ = BinUtils.link
                    {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS
                             @ ldflags,
                     libs = libfiles @ LIBS,
                     objects = [objfile],
                     dst = sofile,
                     useCXX = false,
                     quiet = not (!Control.printCommand)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時、Windowsでは何かしらの制約があるのか過去にリンクしたダイナミックリンクファイル(libfiles)も今回作るダイナミックリンクファイルにリンクしているようです。&lt;/p&gt;

&lt;p&gt;さて、ダイナミックリンクファイルを作った後は&lt;code&gt;dlopen&lt;/code&gt;を使ってダイナミックリンクします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val so = DynamicLink.dlopen&#39; (Filename.toString sofile,
                                        DynamicLink.GLOBAL,
                                        DynamicLink.NOW)
                   handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後はエントリポイントを捜してインポート、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} =
              GenerateMain.moduleName (interfaceNameOpt, #version context)
          val smap = DynamicLink.dlsym&#39; (so, stackMapSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val base = DynamicLink.dlsym&#39; (so, codeBeginSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val _ = sml_register_stackmap (smap, base)
          val ptr = DynamicLink.dlsym (so, mainSymbol)
                    handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val mainFn =
              ptr : _import __attribute__((fastcc,no_callback)) () -&amp;gt; ()
        in
          loadedFiles := sofile :: !loadedFiles;
          mainFn () handle e =&amp;gt; raise UncaughtException e;
          SUCCESS newContext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果を印字しているところが見当らないのですが吐かれたコードに印字部分も入っているんですかね。&lt;/p&gt;

&lt;p&gt;あとは&lt;code&gt;interactive&lt;/code&gt;に返ってコンテキストを拡張したりバージョンをインクリメントしたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;                   val context = Top.extendContext (context, newContext)
                   val context = Top.incVersion context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バージョンによってシンボル名を変えることで何度もsoファイルをロードしても大丈夫なようにしてるんですかね。&lt;/p&gt;

&lt;p&gt;ということでREPLの実装は入力を一旦ダイナミックリンクとしてコンパイルしてからロードしているようでした。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:7f851921bbb9914fa0252d9b589a6af0&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;REPLの入力部分は次のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;
  fun initInteractive () =
      let
        val lineCount = ref 1
        val eof = ref false
        fun read (isFirst, _:int) =
            let
              val prompt = if isFirst then &amp;quot;# &amp;quot; else &amp;quot;&amp;gt; &amp;quot;
              val _ = TextIO.output (TextIO.stdOut, prompt)
              val _ = TextIO.flushOut TextIO.stdOut
              val line = TextIO.inputLine TextIO.stdIn
              val _ = lineCount := !lineCount + 1
            in
              case line of NONE =&amp;gt; (eof := true; &amp;quot;&amp;quot;) | SOME s =&amp;gt; s
            end
      in
        {lineCount = lineCount, eof = eof, read = read}
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結構小さいので色々Hack出来ます。例えば&lt;a href=&#34;https://github.com/smlsharp/smlsharp/pull/13&#34;&gt;hskさんのように&lt;/a&gt;REPLを付けることも出来ます。&lt;/p&gt;

&lt;p&gt;このパッチで外部コマンドを呼ぶのが少し嫌な人はさらに&lt;code&gt;ioctl(2)&lt;/code&gt;を使ってrawモードにするパッチを当てるかlibeditなんかを使ってリッチな入力を実現するかをすればいいでしょう。
個人利用なら(他人に配布しないなら)GPLv3のreadlineも使えるんですかね（ライセンスに詳しくない）。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:7f851921bbb9914fa0252d9b589a6af0&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;REPLの実装にはダイナミックリンクを使う方法があるよ&lt;/li&gt;
&lt;li&gt;SML#のREPLはHack出来そうだよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#でJITコンパイラを作る軽い話</title>
      <link>http://keens.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi</link>
      <pubDate>Sat, 12 Dec 2015 17:26:24 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/848&#34;&gt;ML Advent Calendar 2015&lt;/a&gt;及び&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装 Advent Calendar 2015&lt;/a&gt;15日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。先日流れてきた&lt;a href=&#34;http://www.jonathanturner.org/2015/12/building-a-simple-jit-in-rust.html&#34;&gt;RustでJITコンパイラを作る話&lt;/a&gt;が面白かったのでSML#でもやってみます。&lt;/p&gt;

&lt;h1 id=&#34;jitコンパイラってなに:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;JITコンパイラってなに？&lt;/h1&gt;

&lt;p&gt;JITはJust In Timeで、日本語にすると「間に合って」になります。誤読されかねませんが「臨時コンパイラ」と訳すのが適当なのでしょうか。&lt;/p&gt;

&lt;p&gt;普通のインタプリタがソースコードを直接評価するのに対してJITコンパイラはソースコードを内部で一旦ネイティブコードにコンパイルして実行します。&lt;/p&gt;

&lt;p&gt;よく、JITコンパイラ/JITコンパイルのことをJITと略して呼びます。&lt;/p&gt;

&lt;h1 id=&#34;どこで使うの:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;どこで使うの？&lt;/h1&gt;

&lt;p&gt;主に、インタプリタの高速化の目的で使われるようです。他にはコンパイラをインタプリタ化させる(REPLの実装とか)でも使えそうな気がしますが、詳しくは知りません。&lt;/p&gt;

&lt;h1 id=&#34;jitってどうやって作るの:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;JITってどうやって作るの？&lt;/h1&gt;

&lt;p&gt;JIT &lt;strong&gt;でない&lt;/strong&gt; コンパイラが吐いたコードは一旦ディスクからメモリに読まれ、メモリ上で実行されます。&lt;/p&gt;

&lt;p&gt;JITコンパイラが吐くコードは直接メモリに吐かれ、メモリ上で実行されます。なので細かい条件を無視すれば&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;吐かれる命令のための(特殊な)メモリ領域を用意する&lt;/li&gt;
&lt;li&gt;そこに実行したい命令列を書き込む&lt;/li&gt;
&lt;li&gt;書き込んだ命令列を実行する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;だけです。
3.の「書き込んだ命令を実行する」が若干ふわっとしてますが、多くの場合は命令の書かれたメモリを関数ポインタとして扱って、その関数を呼び出す形で実行されます。
一応直接プログラムカウンタをいじって書き込んだ命令列を実行させることも出来ます。&lt;/p&gt;

&lt;h1 id=&#34;一緒に作ってみよう:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;一緒に作ってみよう&lt;/h1&gt;

&lt;p&gt;思ったより簡単そうですね。作ってみましょう。&lt;/p&gt;

&lt;h2 id=&#34;1-メモリ領域を準備する:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;1. メモリ領域を準備する&lt;/h2&gt;

&lt;p&gt;先に「特殊な」と付言しましたのでそれについて説明しましょう。プロセス上のメモリは、OSによって保護されています。
特に、そのままではそのメモリ上の命令列を実行出来ません。その保護を外すために&lt;code&gt;mprotect(2)&lt;/code&gt;システムコールを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int mprotect(void *addr, size_t len, int prot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SML#を使えば簡単に使えるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val mprotect = _import &amp;quot;mprotect&amp;quot;: (unit ptr, word, word) -&amp;gt; int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SML#は2.0.0時点では32bitでしか動かないのでsize_tをwordとしてしまって大丈夫です。また、bit演算をやりたいので&lt;code&gt;prot&lt;/code&gt;は本来はintですがwordにしました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mprotect(2)&lt;/code&gt;はPOSIX(SUSv4)的には引数の&lt;code&gt;addr&lt;/code&gt;がシステムのページの境界上にあることを要求しても良いことになっています。
実際、OS Xが要求するらしいです。また、メモリ保護はページ単位で行われるため、&lt;code&gt;len&lt;/code&gt;もページサイズの倍数である必要があります。
&lt;code&gt;prot&lt;/code&gt;は保護フラグですね。&lt;/p&gt;

&lt;p&gt;メモリの確保、特にページの境界にアラインメントされたメモリ領域を確保するにはSML#では厳しそうなのでこれもCの関数に頼ります。
Linuxならいくつか方法はありますが、ポータブルには&lt;code&gt;posix_memalign(3)&lt;/code&gt;を使うのが良いようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int posix_memalign(void **memptr, size_t alignment, size_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもSML#から簡単に使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val posix_memalign = _import &amp;quot;posix_memalign&amp;quot;: (unit ptr ref, word, word) -&amp;gt; int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにメモリの解放も必要ですね。&lt;code&gt;free(3)&lt;/code&gt;もインポートしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val free = _import &amp;quot;free&amp;quot;: unit ptr -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、メモリを確保するのにいくつかCのマクロで定義された定数を定義しましょう。今のところSML#にCのマクロを使う術はなさそうです。どうにかしてCプリプロセッサを使えれば良いのですが…。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val PROT_READ  = 0wx1
val PROT_WRITE = 0wx2
val PROT_EXEC  = 0wx4
val PROT_NONE  = 0wx0

val PAGE_SIZE = 0w4096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ページサイズは本当は&lt;code&gt;sysconf(3)&lt;/code&gt;を使って&lt;code&gt;sysconf(PAGESIZE)&lt;/code&gt;として取るのが作法ですが面倒なので4KiB決め打ちにしてしまいました。&lt;/p&gt;

&lt;p&gt;さて、これらを用いてJIT用のメモリは次のように確保します。&lt;code&gt;Pointer&lt;/code&gt;モジュールが必要なのでsmiファイルで&lt;code&gt;require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt;しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val op orb = Word.orb
infix 5 orb
val size = 0wx1
val msize = size * PAGE_SIZE
val pageRef: unit ptr ref = ref (Pointer.NULL ())
val ret = posix_memalign (pageRef, PAGE_SIZE, msize)
val page = if ret = 0
           then !pageRef
           else raise Fail &amp;quot;memory allocation failed&amp;quot;
val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC
val ret = mprotect (page, msize, PROT_RWEX)
val () = if ret = 0
         then ()
         else raise Fail &amp;quot;memory protection error&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;page&lt;/code&gt;に実行可能フラグが立ったメモリが確保出来ました。sizeは書き込みたい命令列に応じて変えます。&lt;/p&gt;

&lt;h1 id=&#34;2-命令列を書き込む:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;2. 命令列を書き込む&lt;/h1&gt;

&lt;p&gt;さて、ここらへんからアセンブラの世界になってきます。&lt;/p&gt;

&lt;p&gt;まず、安全のために件のメモリ領域を&lt;code&gt;ret&lt;/code&gt;命令で埋めます。
&lt;code&gt;ret&lt;/code&gt;命令は関数から戻る時に使われる命令で、変なことをしても&lt;code&gt;ret&lt;/code&gt;で元の場所に戻ればどうにかなる可能性があるのです。&lt;/p&gt;

&lt;p&gt;メモリを一気に埋めるには&lt;code&gt;memset(3)&lt;/code&gt;が便利です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void *memset(void *s, int c, size_t n);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをSMLにインポートして使いましょう。&lt;code&gt;ret&lt;/code&gt;命令に対応するマシン語は&lt;code&gt;0xc3&lt;/code&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val memset = _import &amp;quot;memset&amp;quot;: (unit ptr, word, word) -&amp;gt; unit ptr
val _ = memset (page, 0wxc3, msize)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃあ、命令を書き込んでいきましょう。最初はただ1を返すだけの関数に相当する命令です。
64bitマシンを使っていても32bitでコンパイルしたSML#を使っている限りはx86(IA32)のアセンブラを使います。
x86は値を&lt;code&gt;eax&lt;/code&gt;レジスタに入れることで返り値とします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;mov 1 eax
ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードを&lt;a href=&#34;https://defuse.ca/online-x86-assembler.htm#disassembly&#34;&gt;オンラインアセンブラ&lt;/a&gt;でアセンブルしてみると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0:  b8 01 00 00 00          mov    eax,0x1
5:  c3                      ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;との結果が返ってきました。これを真心込めて1つづつメモリに書き込んでいきます。
SML#からメモリに直接書き込むには内部APIっぽいものを触る必要があります。
タイプ数を減らすためにいくつかエイリアスを定義しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
val store = Pointer.store
val advance = Pointer.advance
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メモリにword8の値を書き込むのにキャストが必要になるので&lt;code&gt;fromUnitPtr&lt;/code&gt;を使います。
さて、書き込んでいきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val mem: word8 ptr = fromUnitPtr page
val () = store page 0wxb8
val mem = advance mem
val () = store page 0wx01
val mem = advance mem
val () = store page 0wx00
val mem = advance mem
val () = store mem 0wx00
val mem = advance mem
val () = store mem 0wx00
val mem = advance mem
val () = store mem 0wxc3
val _ = advance mem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;page&lt;/code&gt;に1を返すだけの命令列が書き込まれした。&lt;/p&gt;

&lt;h2 id=&#34;3-書き込んだ命令列を実行する:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;3. 書き込んだ命令列を実行する&lt;/h2&gt;

&lt;p&gt;書き込んだ命令列は関数にキャストして使うことが多いと言いました。今回もそのようにします。&lt;/p&gt;

&lt;p&gt;そのために、また内部APIっぽいものを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;codeptr&lt;/code&gt;型は関数ポインタを表すもののようです。&lt;code&gt;DynamicLink&lt;/code&gt;モジュールなどで使われています。&lt;/p&gt;

&lt;p&gt;さて、今回の1を返すだけの命令列は&lt;code&gt;() -&amp;gt; int&lt;/code&gt;型になりますね。
それをインポート、実行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val freturn1 = toCodePtr page: _import () -&amp;gt; int
val () = print ((Int.toString (freturn1 ())) ^ &amp;quot;\n&amp;quot;)
val _ = free page
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで見事&lt;code&gt;1&lt;/code&gt;が印字されたら成功です。&lt;/p&gt;

&lt;h1 id=&#34;さらに:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;さらに&lt;/h1&gt;

&lt;p&gt;先程のコードは繰り返しが多く、整理されていませんでした。もう少し整理しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure Emit = struct
    val posix_memalign = _import &amp;quot;posix_memalign&amp;quot;: (unit ptr ref, word, word) -&amp;gt; int
    val mprotect = _import &amp;quot;mprotect&amp;quot;: (unit ptr, word, word) -&amp;gt; int
    val memset = _import &amp;quot;memset&amp;quot;: (unit ptr, word, word) -&amp;gt; unit ptr
    val free = _import &amp;quot;free&amp;quot;: unit ptr -&amp;gt; ()
    val printf = _import &amp;quot;printf&amp;quot;: (string, unit ptr) -&amp;gt; ()

    (* 
#define PROT_READ	0x1		/* Page can be read.  */
#define PROT_WRITE	0x2		/* Page can be written.  */
#define PROT_EXEC	0x4		/* Page can be executed.  */
#define PROT_NONE	0x0		/* Page can not be accessed.  */
    *)

    val PROT_READ  = 0wx1
    val PROT_WRITE = 0wx2
    val PROT_EXEC  = 0wx4
    val PROT_NONE  = 0wx0

    val PAGE_SIZE = 0w4096

    type jitptr = word8 ptr
    val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
    val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr
    val toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr
    val store = Pointer.store
    val advance = Pointer.advance


    fun jitMemory size: jitptr = let
        val op orb = Word.orb
        infix 5 orb
        val msize = size * PAGE_SIZE
        val pageRef: unit ptr ref = ref (Pointer.NULL ())
        val ret = posix_memalign (pageRef, PAGE_SIZE, msize)
        val page = if ret = 0
                   then !pageRef
                   else raise Fail &amp;quot;memory allocation failed&amp;quot;
        val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC
        val ret = mprotect (page, msize, PROT_RWEX)
        val () = if ret = 0
                 then ()
                 else raise Fail &amp;quot;memory protection error&amp;quot;
        (* init with ret for safety *)
        val _ = memset (page, 0wxc3, msize)
    in
        fromUnitPtr page
    end

    fun freeJit (jitMem: jitptr) = free (SMLSharp_Builtin.Pointer.toUnitPtr jitMem)

    fun pushWord page (word: word8) = (store (page, word); advance (page, 1))
    fun pushWords (page: jitptr) l = List.foldl (fn(w,page) =&amp;gt; pushWord page w) page l

    val import: jitptr -&amp;gt; codeptr = toCodeptr o toUnitPtr

    fun fromMachineCode l = let
        val len = Word.fromInt(List.length l)
        val size = (len + PAGE_SIZE) div PAGE_SIZE
        val page = jitMemory size
        val _ = pushWords page l
    in
        import page
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のように使います。一回importした関数はfreeしないことにしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun println x = print (x ^ &amp;quot;\n&amp;quot;)
val return1  =
    (* 0:  b8 01 00 00 00          mov    eax,0x1  *)
    [
      0wxb8, 0wx01, 0wx00, 0wx00, 0wx00
    ] 
val freturn1 = Emit.fromMachineCode return1 :_import () -&amp;gt; int
val () = println (Int.toString (freturn1 ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引数を取る:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;引数を取る&lt;/h2&gt;

&lt;p&gt;もうアセンブラの話になります。&lt;/p&gt;

&lt;p&gt;x86では引数は右から順にスタックに積まれます。intを1つ取ってそれに1足して返す関数はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val add1 = 
    (* 0:  8b 44 24 04             mov    eax,DWORD PTR [esp+0x4] *)
    (* 4:  83 c0 01                add    eax,0x1 *)
    [
      0wx8b, 0wx44, 0wx24, 0wx04,
      0wx83, 0wxc0, 0wx01
    ]
val fadd1 = Emit.fromMachineCode add1 :_import (int) -&amp;gt; int
val () = println (Int.toString (fadd1 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常に動けば4が印字されます。&lt;/p&gt;

&lt;h1 id=&#34;つらい話:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;つらい話&lt;/h1&gt;

&lt;h2 id=&#34;バグ:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;バグ&lt;/h2&gt;

&lt;p&gt;最初、&lt;code&gt;Pointer.store&lt;/code&gt;でなく、&lt;code&gt;SMLSharp_Builtin.Pointer.store&lt;/code&gt;を使っていたら&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/43&#34;&gt;変なバグ&lt;/a&gt;踏みました。バグというか使い方が悪かった。&lt;/p&gt;

&lt;h2 id=&#34;デバッグ:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;デバッグ&lt;/h2&gt;

&lt;p&gt;デバッガがないので非常につらいです。書き出された命令列を見るのに困りました。gdbで見たかったので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val printf = _import &amp;quot;printf&amp;quot;: (string, unit ptr) -&amp;gt; int
val _ = pritnf (&amp;quot;page pointr: %p&amp;quot;, page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;して&lt;code&gt;printf&lt;/code&gt;にブレークポイントを張り、そこで止めつつページのアドレスを取得、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;(gdb) x/20xh 0x81ca000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとして見ていました。&lt;/p&gt;

&lt;h1 id=&#34;もっと:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;もっと&lt;/h1&gt;

&lt;p&gt;JITコンパイラが楽しかったのでアセンブラのDSLを作ってみました。1、2個の命令吐けるだけですがちゃんと動きました。今のところこのように書けます。Intel記法だとしんどそうだったのでAT&amp;amp;T記法っぽく書けるようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val freturn1&#39; = Emit.fromInsts [
        xorl eax eax,
        addl ($1) eax,
        ret
    ]:_import () -&amp;gt; int
val () = println (Int.toString (freturn1&#39; ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x86は命令フォーマットが1バイトから15バイトまでの可変長で、内部表現をどのようにするか決めるだけでも一苦労でした。x86つらい。&lt;/p&gt;

&lt;p&gt;アドレッシングが複雑なのも悩みどころで、複数のアドレッシングを統一的に扱えるようにオーバーロードされた関数を用意したのですがあえなくSML#のバグを踏んで死亡しました。本当はこういう記法が出来る筈だった…&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;addl (%eax) eax
addl eax (%eax)
addl eax (%(eax, ebx))
addl eax (%(eax, ebx, 4))
addl eax (%(4, eax))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/bin/smlsharp   -c -o main.o main.sml
uncaught exception: Bug.Bug: InferType: FIXME: user error: invalid instTy at src/compiler/typeinference2/main/InferTypes2.sml:47
Makefile:11: recipe for target &#39;main.o&#39; failed
make: *** [main.o] Error 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;movl&lt;/code&gt;を実装しようとしたらアドレッシングが動かなかったので萎えてまだ実装してません。&lt;/p&gt;

&lt;p&gt;よく考えたら&lt;code&gt;%&lt;/code&gt;ってミスリーディングだし名前変えよう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;JITを作るにはメモリ保護をいじれて関数ポインタのインポートが出来ればいいよ&lt;/li&gt;
&lt;li&gt;SML#でもJIT作れるよ&lt;/li&gt;
&lt;li&gt;アセンブラっぽいの作ったよ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/smljit&#34;&gt;こちら&lt;/a&gt;にあります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>リージョンについて</title>
      <link>http://keens.github.io/blog/2015/12/09/ri_jonnitsuite</link>
      <pubDate>Wed, 09 Dec 2015 22:16:50 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/09/ri_jonnitsuite</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装Advent Calendar 2015&lt;/a&gt; 10日目の記事です&lt;/p&gt;

&lt;p&gt;κeenです。今日はある程度gcに頼らずメモリを管理する手法、リージョンについて話そうと思います。
リージョン推論とそのアルゴリズムまで話せればよかったのですがサーベイが間に合わず…&lt;/p&gt;

&lt;h1 id=&#34;スタックベースのメモリ管理:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;スタックベースのメモリ管理&lt;/h1&gt;

&lt;p&gt;gcのない言語、例えばcでも自動で解放される類のメモリがあります。ローカル変数です。&lt;/p&gt;

&lt;p&gt;ローカル変数のメモリ確保/解放戦略は単純です。ブロックの開始に確保され、ブロックの終わりに解放されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{
  int x;         // &amp;lt;- xが確保される
  {
    int y = 2;   // &amp;lt;- yが確保される
    {
      int z = 3; // &amp;lt;- zが確保される
      x = y + z;
    }            // &amp;lt;- zが解放される
  }              // &amp;lt;- yが解放される
}                // &amp;lt;- xが解放される
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ブロックはネスト構造をとるのでメモリ管理はスタックがあれば十分で、概念としても実装としても非常にシンプルです。&lt;/p&gt;

&lt;p&gt;しかしシンプルな一方で柔軟性に欠ける部分もあります。
初心者の時に次のようなコードを書いてコンパイラに怒られた、あるいはバグらせたことは誰しもあるのではないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{
  int i;
  int *x;
  {
    int y[5] = {1, 2, 3, 4, 5};
    x = y + 1; 
  }     // &amp;lt;- yに割り当てられたメモリはここで解放されるため、外のブロックにあるxで参照出来ない
  for(i = 0; i &amp;lt; 4; ++i) {
    printf(&amp;quot;%i\n&amp;quot;, x[i]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとわざとらしい例ですがこのようにブロック内で確保されたメモリが必ずブロックが終わった時に解放されるのは嬉しくないケースがあります。&lt;/p&gt;

&lt;h1 id=&#34;リージョン:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;リージョン&lt;/h1&gt;

&lt;p&gt;リージョンはブロックと基本的には同じ考え方です。リージョンの開始でメモリが準備され、リージョンの終わりでメモリが解放される。そしてリージョンは入れ子構造を作る。
リージョンとブロックの違いはリージョンには名前があることと、メモリを割り当てる時にどのリージョンに置くかを指定できることです。&lt;/p&gt;

&lt;p&gt;リージョンについて説明するためにml風の小さな言語で説明しましょう。この言語にgcはありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;let
  x = [1, 2, 3]
in
  let
    l = let
      y = append ([4, 5], x)
    in
      y
    end 
  in
    len l
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコープによるメモリ管理を考えてみましょう。&lt;code&gt;y&lt;/code&gt;について考えます。先程の考え方でいくと一番内側のスコープで作られた&lt;code&gt;y&lt;/code&gt;はスコープの外まで生きていないので&lt;code&gt;l&lt;/code&gt;に渡すのは不正です。
これはつらいですね。代入を許さない言語だと値を返せなくなります。&lt;/p&gt;

&lt;p&gt;次に、リージョンを導入してみます。リージョンを作る構文として、&lt;code&gt;letregion&lt;/code&gt;を導入します。&lt;/p&gt;

&lt;p&gt;リージョン&lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;r2&lt;/code&gt;を導入するには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;letregion r1, r2 in
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きます。そしてリージョン&lt;code&gt;r1&lt;/code&gt;に&lt;code&gt;[1, 2, 3]&lt;/code&gt;をアロケートするには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;[1, 2, 3] at r1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きます。また、関数&lt;code&gt;f&lt;/code&gt;の返り値をリージョン&lt;code&gt;r1&lt;/code&gt;にアロケートするには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;f[r1] args ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きます。今回端折り気味の説明なのでこの記法の詳細は後回しにします。&lt;/p&gt;

&lt;p&gt;リージョンとこの記法を導入した時に、先程の何がしたいのか分からないプログラムは次のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;letregion r1, r2 in
  let
    x = [1, 2, 3] at r1
  in
    letregion r3, r4 in
      let
        l = let
          letregion r5 in
            y = append[r3] (([4, 5] at r4, x) at r5)
          end
        in
          y
        end 
      in
        len[r2] l
      end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このプログラムはちゃんと齟齬なく値を渡せていて、アロケートしたメモリも全て解放されています。
リージョンを導入することでこのような小さなプログラムならgc無しでもメモリ管理が出来るようになりました。
特に、このプログラムのメモリ管理は静的です。つまりメモリをアロケートする箇所と解放する箇所がコンパイル時に決定します。&lt;/p&gt;

&lt;h1 id=&#34;リージョンと関数:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;リージョンと関数&lt;/h1&gt;

&lt;p&gt;先程までは値の計算だけでした。今度は関数を定義してみましょう。
関数は返り値をどこかに返さないといけないので返り値の置き場となるリージョンを外から与える必要があります。
ということで関数はリージョンパラメータを取ります。先程の関数を返り値のリージョンを指定する構文は厳密には関数にリージョンを渡していた訳です。&lt;/p&gt;

&lt;p&gt;試しに&lt;code&gt;append&lt;/code&gt;を定義してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;letlec append[r1] p =
  let (xs, ys) = p
  in case xs of
      nil =&amp;gt; ys
    | x::xs&#39; =&amp;gt; (x::letregion r2 in
      (append[r1] ((xs&#39;, ys) at r2))
    end at r1)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数&lt;code&gt;append&lt;/code&gt;はリージョン&lt;code&gt;r1&lt;/code&gt;とタプル&lt;code&gt;p&lt;/code&gt;を受け取って、&lt;code&gt;r1&lt;/code&gt;にアロケートされた値を返します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(xs&#39;, ys)&lt;/code&gt;のように&lt;code&gt;append&lt;/code&gt;の呼び出しのためだけに作られたタプルは短命な&lt;code&gt;r2&lt;/code&gt;にアロケートしつつ、再帰呼び出しの&lt;code&gt;app&lt;/code&gt;の返り値は
関数全体の返り値の一部になるので&lt;code&gt;r1&lt;/code&gt;にアロケートしています。&lt;/p&gt;

&lt;p&gt;このように、リージョンさえなければ普通のmlと変わらないのにgcに頼らずメモリ管理が出来ています。&lt;/p&gt;

&lt;h1 id=&#34;リージョン推論:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;リージョン推論&lt;/h1&gt;

&lt;p&gt;さてさて、先程リージョンなしのml言語にリージョンを導入することでメモリを静的に管理出来ました。しかしリージョンを手で指定していくのは中々つらいものがあります。ということでリージョンをコンパイラで勝手に推論してしまおうというのがリージョン推論です。&lt;/p&gt;

&lt;p&gt;リージョン推論を導入することで今までgcでメモリを管理していたのをある程度静的に管理することが出来ます。
リージョン推論のアルゴリズムは冒頭で述べたようにサーベイが間に合いませんでした。&lt;/p&gt;

&lt;p&gt;sml処理系の&lt;a href=&#34;http://www.elsman.com/mlkit/&#34;&gt;ml kit&lt;/a&gt;はリージョン推論を導入することでgcをほとんど無くし、リアルタイム性に優れる処理系になりました。
先程から「ほとんど」といっているのは既存のプログラミング言語だとリージョンを綺麗に割り当てることが出来なくてほとんどのオブジェクトがトップレベルリージョンに推論されてしまい、あまり意味がなくなってしまうからだとか。丁度動的型付き言語に型推論を入れてもほとんどobject型になってしまうのと同じような話なんですかね。&lt;/p&gt;

&lt;h1 id=&#34;発展的話題:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;発展的話題&lt;/h1&gt;

&lt;h2 id=&#34;リージョンサイズ解析:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;リージョンサイズ解析&lt;/h2&gt;

&lt;p&gt;今まで、リージョンによるメモリの確保/解放については話してきましたが確保するサイズについては触れてきませんでした。
簡単には&lt;code&gt;malloc&lt;/code&gt; &lt;code&gt;realloc&lt;/code&gt; &lt;code&gt;free&lt;/code&gt;相当の機能を考えれば済むのですが、例えばコンパイル時点で最大確保サイズが分かっているのなら
コールスタックに載せて確保/解放を高速化することが出来ます。&lt;/p&gt;

&lt;p&gt;そのコンパイル時に出来るだけリージョンの最大サイズを判明させようというのがリージョンサイズ解析です。&lt;/p&gt;

&lt;h2 id=&#34;線形-アフィン型:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;線形/アフィン型&lt;/h2&gt;

&lt;p&gt;線形型は全てのリソースに対が必ず丁度1回消費されることを要求する型システムです。必ず消費されるのでメモリの解放が必ず行われることを型レベルで保障します。そして最大1回しか消費されないので他者が同じリソースを触って大惨事になるデータ競合を防ぐことが出来ます。
しかし推論は完全には出来ず、ユーザがちょくちょく整合性が取れていることの証明を書く必要があります。&lt;a href=&#34;http://www.ats-lang.org/&#34;&gt;ATS2&lt;/a&gt;は線形型を持っており、厳密なリソース管理が出来ます。&lt;/p&gt;

&lt;p&gt;アフィン型は線形型よりは少し緩い型システムで、リソースが最大でも1回しか消費されないことを要求します。メモリなどの管理は出来ませんがデータ競合を防ぐことは出来ます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt;はアフィン型を導入してるらしいです。多分所有権回りの話なんでしょう。リージョンも導入してるらしいです。生存期間回りの話なんでしょう。&lt;/p&gt;

&lt;p&gt;余談ですがリージョンとアフィン型の関係を調べようとしたら画像の特定領域に台形変換を掛ける話しかヒットしませんでした。ググラビリティ低い…&lt;/p&gt;

&lt;h1 id=&#34;まとめ:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;リージョンについて話した&lt;/li&gt;
&lt;li&gt;リージョン推論のアルゴリズムについては話さなかった&lt;/li&gt;
&lt;li&gt;リージョン以外にもリソースを管理する方法はあるよ&lt;/li&gt;
&lt;li&gt;みんなRust使おう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;全然理解が追い付かないまま期限が来て半知半解で書いてるので詳しい方&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;κeen&lt;/a&gt;までツッコみお願いします。&lt;/p&gt;

&lt;h1 id=&#34;参考文献:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;参考文献&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.elsman.com/mlkit/pdf/ismm98.pdf&#34;&gt;A Brief Introduction to Regions&lt;/a&gt; 今回の記事はこの論文の内容をかい摘んで書いてある。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://melsman.github.io/mlkit/pdf/popl94.pdf&#34;&gt;Implementation of the Typed Call-by-value lambda-calculus using a Stack of Regions&lt;/a&gt; (多分)リージョンの初出論文&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://melsman.github.io/mlkit/pdf/toplas98.pdf&#34;&gt;A Region Inference Algorithm&lt;/a&gt; リージョン推論のアルゴリズム。70ページある…&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.elsman.com/mlkit/papers.html&#34;&gt;ML Kitの論文たち&lt;/a&gt; ここに色々論文ある。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SML#でDBに接続</title>
      <link>http://keens.github.io/blog/2015/12/05/sml_dedbnisetsuzoku</link>
      <pubDate>Sat, 05 Dec 2015 22:04:25 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/05/sml_dedbnisetsuzoku</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/848&#34;&gt;ML Advent Calendar&lt;/a&gt;6日目の記事です。&lt;br /&gt;
次はdico_leque先生で、「ML中心にしつつ何か」です。&lt;/p&gt;

&lt;p&gt;κeenです。SMl#はDB接続及びSQLを言語レベルでサポートしていることが大きな特徴ですが詳細な方法についてはあまり情報がなく、
実際に利用するのは難しい状況にあります。そこで私がなんとかソースコードを読んで得られた知識を少し共有したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;接続サーバ設定:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続サーバ設定&lt;/h1&gt;

&lt;p&gt;DBへの接続サーバ設定には&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_sqlserver serverLocation : τ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;式を使います。このserverLocationはDB毎に指定方法が異なります。公式のドキュメントにはデフォルトDBであるPostgreSQLへの接続方法しか書かれていませんが、いくつかのDBをサポートします。&lt;/p&gt;

&lt;p&gt;SML#はDB接続時にテーブルの型を要求します(上でいう型注釈の&lt;code&gt;τ&lt;/code&gt;がそれです。文法的に型注釈がないといけません。)。今回の例では公式ドキュメントにある通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE mydb;
CREATE TABLE Persons (
  name text not null,
  age int not null,
  salary int not null
);
USE mydb;
INSERT INTO Persons VALUES (&#39;Joe&#39;, 21, 10000);
INSERT INTO Persons VALUES (&#39;Sue&#39;, 31, 20000);
INSERT INTO Persons VALUES (&#39;Bob&#39;, 41, 30000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で作ったDBへ接続することにします。&lt;/p&gt;

&lt;h2 id=&#34;テーブルの型:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;テーブルの型&lt;/h2&gt;

&lt;p&gt;深追いしてないので分かりません。とりあえず今回使う&lt;code&gt;mydb&lt;/code&gt;は&lt;code&gt;{Persons:{name:string, age:int, salary :int}&lt;/code&gt;で接続出来るみたいです。これも追わねば…&lt;/p&gt;

&lt;p&gt;一応ソースを読む限りだとint, decimal, real32, float, real, string, bool, timestampがあるようです。NULLableなカラムにはoptionを使うようです。&lt;/p&gt;

&lt;p&gt;SMLで見慣れないdecimal, float, timestampはSML#が実装を持っているようです。&lt;/p&gt;

&lt;p&gt;float, decimalは内部表現は文字列で、文字列との相互及びrealとIEEERealへの変換が出来るようです。&lt;/p&gt;

&lt;p&gt;timestampは文字列との相互変換及び&lt;code&gt;now()&lt;/code&gt;関数, &lt;code&gt;defaultTimestamp&lt;/code&gt;が存在します(スキーマに&lt;code&gt;DEFAULT&lt;/code&gt;指定があった時用)。内部表現はunix timeなのか、intです。&lt;/p&gt;

&lt;p&gt;それぞれ&lt;code&gt;SQL.Float&lt;/code&gt;, &lt;code&gt;SQL.Decimal&lt;/code&gt;, &lt;code&gt;SQL.TimeStamp&lt;/code&gt;モジュールに入っています。&lt;/p&gt;

&lt;h2 id=&#34;postgresql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;PostgreSQL&lt;/h2&gt;

&lt;p&gt;デフォルト設定のpgのmydbというDBへ接続したいならこれで接続出来ると公式ドキュメントに書いてあるのですが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (dbname=&amp;quot;mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと最後の &lt;code&gt;}&lt;/code&gt;が1つ抜けている上、それを補っても&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(interactive):2.27-2.32 Error: (name evaluation &amp;quot;190&amp;quot;) unbound variable: dbname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と返してきます。正しくは(?)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。他のパラメータ、例えばホストやポート、パスワードを渡したい場合はスペース区切で渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb host=localhost password=hogehoge&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この文字列はそのままPostgreSQLの&lt;a href=&#34;http://www.fireproject.jp/feature/postgresql/programing_libpq/connect.html#2&#34;&gt;&lt;code&gt;PGconnectdb&lt;/code&gt;&lt;/a&gt;という関数に渡っているのでそのドキュメントに完全な受付可能なキーが書いてあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host: DBサーバ名&lt;/li&gt;
&lt;li&gt;hostaddr: DBサーバのIPアドレス&lt;/li&gt;
&lt;li&gt;user: DB接続時のユーザ名&lt;/li&gt;
&lt;li&gt;password: userに対するパスワード&lt;/li&gt;
&lt;li&gt;dbname: DB名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とのことです。&lt;/p&gt;

&lt;h2 id=&#34;mysql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;MySQL&lt;/h2&gt;

&lt;p&gt;ドキュメントはありませんがソースコードを読んである程度勘を効かせた上で色々書いて試行錯誤すれば接続方法は分かります。&lt;/p&gt;

&lt;p&gt;MySQLに接続するには以下のように&lt;code&gt;SQL.mysql&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = _sqlserver (SQL.mysql &amp;quot;dbname=mydb&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余談ですが&lt;code&gt;_sqlserver&lt;/code&gt;はオーバーロードされていて、backend型とstring型両方を受け付けます。
文字列が来た時には&lt;code&gt;SQL.default&lt;/code&gt;に渡されます。そして &lt;code&gt;val default = postgresql&lt;/code&gt;です。つまり、PostgreSQLの例は&lt;code&gt;_sqlserver (SQL.postgresql &amp;quot;dbname=mydb&amp;quot;)&lt;/code&gt;
としているのと同じです。&lt;/p&gt;

&lt;p&gt;閑話休題。MySQLの時に渡せるパラメータの話をしましょう。こちらはバックエンドの接続関数にそのまま渡してる訳ではないのですが、
SML#側でパーサを持っているのでPostgreSQLの時のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;SQL.mysql &amp;quot;dbname=mydb host=localhost&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで使えるキーは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val availableKeys = [&amp;quot;host&amp;quot;, &amp;quot;port&amp;quot;, &amp;quot;user&amp;quot;, &amp;quot;password&amp;quot;, &amp;quot;dbname&amp;quot;, &amp;quot;unix_socket&amp;quot;, &amp;quot;flags&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義されています&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。因みにこれはパースエラーにならない文字列の集合であって、&lt;code&gt;unix_socket&lt;/code&gt;を使おうとするとコネクションエラーになるようです(&lt;code&gt;raise Connect &amp;quot;unix_socket is not supported&amp;quot;&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;文法に関して深掘りすると、一応パーサ(&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/KeyValuePair.sml&#34;&gt;src/sql/main/KeyValuePair.sml&lt;/a&gt;)を読む限りだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;keyは &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;(&lt;code&gt;isAlphanum&lt;/code&gt; + &lt;code&gt;#&#39;_&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueはスペース以外の文字列(e.g. &lt;code&gt;hogehoge&lt;/code&gt;)又は&lt;code&gt;&#39;&lt;/code&gt;で囲まれた文字列(e.g. &lt;code&gt;&#39;hoge hoge&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueでは&lt;code&gt;\&lt;/code&gt;によるエスケープが可能(e.g. &lt;code&gt;hoge\ hoge&lt;/code&gt;, &lt;code&gt;&#39;a \&#39;quote\&#39;&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;\&lt;/code&gt;については文字列の中なので&lt;code&gt;\&lt;/code&gt;自身のエスケープが必要なことに注意して下さい。&lt;/p&gt;

&lt;h2 id=&#34;unixodbc:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;unixODBC&lt;/h2&gt;

&lt;p&gt;ご存知ない方に説明するとODBCはOpen Database Connectivityの略です。Microsoftが主導となって定めたDB接続のインターフェースです。また、そのインターフェースに従うドライバマネージャのことも指します。
一旦抽象化レイヤを挟むのでパフォーマンス面では生の接続に負けますが、豊富な接続先が魅力です。
MicroSoftのSQL ServerやMicroSoft Accessを始めとし、Oracle, MySQL, PostgreSQL, SQLite3, 果てはMongoDBなどにまで接続出来ます。
まあ、接続出来るからといって投げたクエリを正しく解釈、実行してくれるとは限りませんが…&lt;/p&gt;

&lt;p&gt;unixODBCはODBCのunix実装のようです。つまりODBCドライバを持つDBにunixから接続出来ます。&lt;/p&gt;

&lt;p&gt;さてさて、odbcに繋ぐには以下のようにします。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = (SQL.odbc &amp;quot;mydb username mypassword&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜ記法変えたし…。&lt;del&gt;しかも必ずスペースで区切るのでクォートも出来なければ空のユーザパスワードを渡すことも出来ません。もしかしたら&lt;code&gt;&amp;quot;&#39;&#39;&amp;quot;&lt;/code&gt;としたら後側で空の文字列と扱ってくれるかもしれませんが。&lt;/del&gt;
私が&lt;code&gt;String.fields&lt;/code&gt;の挙動を勘違いしてました。スペースで区切って空にしておけば空パスワードを渡せます(e.g. &lt;code&gt;&amp;quot;mydb username &amp;quot;&lt;/code&gt;)。あるいは空ユーザ名も(&lt;code&gt;&amp;quot;mydb  &amp;quot;&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;私自身ODBCに詳しくないのですが、ODBCに接続するときはData Source Nameと呼ばれるものがシステムの特定の場所に存在するので他の接続情報は必要ないみたいです。&lt;/p&gt;

&lt;h1 id=&#34;接続:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続&lt;/h1&gt;

&lt;p&gt;さっきまでは接続サーバの設定の話でした。今度は実際に接続する話です。DBMS固有の話はサーバ設定までなのでこれからは総のDBに共通です。&lt;/p&gt;

&lt;p&gt;接続するには公式のドキュメント通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val conn = SQL.connet myServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で繋げます。ここで各クライアントのダイナミックリンクライブラリがないとエラーになります。64dbit環境でSML#を32bitでビルドしている人はライブラリも32bitでビルドされていることを確認しましょう。&lt;/p&gt;

&lt;h1 id=&#34;クエリ:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;クエリ&lt;/h1&gt;

&lt;p&gt;これもドキュメント通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myQuery = _sql db =&amp;gt; select #P.name as name, #P.age as age
      from #db.Persons as P
      where SQL.&amp;gt;(#P.salary, 10000)
val rel = _sqleval myQuery conn
val result = SQL.fetchAll rel; (* =&amp;gt; [{age=32, name=&amp;quot;Sue&amp;quot;}, {age=41, name=&amp;quot;Bob&amp;quot;}] *)
val () = SQL.closeRel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;p&gt;可能な文法については主に&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch10.S5.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;を参考にしましょう。&lt;/p&gt;

&lt;p&gt;insert, update, deleteをサポートしている他、トランザクション(&lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt;)をサポートしているようです。詳しくは&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/compiler/parser2/main/iml.grm#L727&#34;&gt;BNF&lt;/a&gt;を読んで下さい。&lt;/p&gt;

&lt;p&gt;SQLを投げて返ってきたリレーションに対しては結果を総取得する&lt;code&gt;SQL.fetchAll&lt;/code&gt;、結果をoption型で1つ取得する&lt;code&gt;SQL.fetch&lt;/code&gt;、結果を1つ取得するか例外になる&lt;code&gt;SQL.fetchOne&lt;/code&gt;を使います。&lt;code&gt;fetchOne&lt;/code&gt;の上げる例外は&lt;code&gt;SQL.NotOne&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;クエリ結果を使い終わったら必ず&lt;code&gt;SQL.closeRel&lt;/code&gt;で開放しましょう。そしてコネクションも、終わったら&lt;code&gt;SQL.closeCon&lt;/code&gt;で開放しましょう。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;本当は実際に試してから記事を書きたかったのですが、32bitの壁に阻まれて出来ませんでした。しかしソースを読んで裏を取って書いてあるのでまあまあ信憑性のある内容だと思います。
SML# からデータベースに接続したい方の一助になれば幸いです。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Rustで小さなツールを作ってみる(後編)</title>
      <link>http://keens.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_</link>
      <pubDate>Sun, 29 Nov 2015 13:54:39 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 2日目の記事です。&lt;br /&gt;
前 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru/&#34;&gt;Rustで小さなツールを作ってみる(前編)&lt;/a&gt;&lt;br /&gt;
次 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/cargonotsukaikata/&#34;&gt;Cargoの使い方&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。昨日の記事で作りかけだったIRCの生ログのDBへのインポートの続きです。今日はDBへのインポートをやります。&lt;/p&gt;

&lt;p&gt;とはいってもRustでDBを扱った経験がないので探り探りです。&lt;/p&gt;

&lt;h1 id=&#34;要件:b5100d6caeb6e32800002ace57fa8102&#34;&gt;要件&lt;/h1&gt;

&lt;p&gt;今回は簡単なのでORMは要らない気がしますが、サンプルということでORMも使いましょう。さらに、サンプルということでクエリビルダも使いましょう。&lt;/p&gt;

&lt;p&gt;…と思ったのですが中々良いライブラリがありませんでした。ドキュメントもろくにないまま放置されてる&lt;a href=&#34;https://github.com/deuterium-orm/deuterium&#34;&gt;deuterium&lt;/a&gt;と開発途中でまだpostgresしかサポートされていない&lt;a href=&#34;https://github.com/ivanceras/rustorm&#34;&gt;rustorm&lt;/a&gt;/&lt;a href=&#34;https://github.com/ivanceras/codegenta&#34;&gt;codegenta&lt;/a&gt;くらいしかないようです。うぅ。
最近話題になった&lt;a href=&#34;https://github.com/sgrif/diesel&#34;&gt;diesel&lt;/a&gt;もまだ若すぎるようです。&lt;/p&gt;

&lt;p&gt;ということでシンプルなDBIを使います。そろそろ牡蠣の美味しい季節ですしSQL生書きしましょう。当たると怖いですが。で、テスト用にsqlite3を、（今回は使いませんが）本番用（？）にMySQLを使える奴を捜しましょう。&lt;/p&gt;

&lt;h1 id=&#34;ライブラリ捜し:b5100d6caeb6e32800002ace57fa8102&#34;&gt;ライブラリ捜し&lt;/h1&gt;

&lt;p&gt;まずは&lt;a href=&#34;https://crates.io&#34;&gt;crates.io&lt;/a&gt;を捜します。&amp;rdquo;sqlite&amp;rdquo;で捜せばいいでしょうか。&lt;/p&gt;

&lt;p&gt;MySQLとSQLite3をサポートしているライブラリ…&lt;a href=&#34;https://github.com/sfackler/r2d2&#34;&gt;r2d2&lt;/a&gt;がそれのようです。
コネクションプールのライブラリなので何か違う気がしますが、mysqlもsqlite3も扱えて、結果コネクションを抽象化してくれるので大体大丈夫です。&lt;/p&gt;

&lt;p&gt;蛇足ですが、名前はJavaにc3p0というコネクションプールがあるのでそこから来ているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;スキーマ定義:b5100d6caeb6e32800002ace57fa8102&#34;&gt;スキーマ定義&lt;/h1&gt;

&lt;p&gt;SQLiteを使い慣れないのですが大したことやってないので大丈夫でしょう。&lt;code&gt;DATETIME&lt;/code&gt; 型がないのが苦しいですね。&lt;/p&gt;

&lt;p&gt;自然キーが文字列や複合キーなのでサロゲートキーを使って自然キーにUNIQUE制約をかけてますがちょっと気持悪いですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- _*_ mode: sql; sql-product: &#39;sqlite _*_

CREATE TABLE servers(
        id   INTEGER PRIMARY KEY,
        name  TEXT NOT NULL UNIQUE,
        address TEXT
        );
m
CREATE TABLE channels(
        id INTEGER PRIMARY KEY,
        server_id INTEGER REFERENCES servers(id) ON UPDATE CASCADE,
        name TEXT NOT NULL,
        UNIQUE(server_id, name)
        );

CREATE TABLE entries(
        id INTEGER PRIMARY KEY,
        channel_id INTEGER REFERENCES channels(id) ON UPDATE CASCADE,
        user_id INTEGER REFERENCES users(i) ON UPDATE CASCADE,
        type TEXT NOT NULL,
        body TEXT NOT NULL,
        created_at TEXT NOT NULL
        );

CREATE TABLE users(
        id INTEGER PRIMARY KEY,
        server_id INTEGER REFERENCES servers(id) ON UPDATE CASCADE,
        name TEXT NOT NULL,
        UNIQUE(server_id, name)
        );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをetc/schema.sqlに保存します。&lt;/p&gt;

&lt;h1 id=&#34;モデル定義:b5100d6caeb6e32800002ace57fa8102&#34;&gt;モデル定義&lt;/h1&gt;

&lt;p&gt;折角シンプルなツールを作っているのでモデルは使わない。&lt;/p&gt;

&lt;h1 id=&#34;コネクションまで:b5100d6caeb6e32800002ace57fa8102&#34;&gt;コネクションまで&lt;/h1&gt;

&lt;p&gt;あらかじめ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sqlite test.db &amp;lt; etc/schema.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてDBを作っておきましょう。&lt;/p&gt;

&lt;p&gt;Cargo.tomlのdependenciesには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;r2d2_sqlite = &amp;quot;0.0.3&amp;quot;
r2d2 = &amp;quot;0.6.1&amp;quot;
rusqlite = &amp;quot;0.4.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記。&lt;/p&gt;

&lt;p&gt;src/main.rsの先頭部分に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate r2d2;
extern crate r2d2_sqlite;
extern crate rusqlite;
use std::sync::Arc;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::SqliteError;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記しましょう。&lt;/p&gt;

&lt;p&gt;そしてmainの中に次を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let manager = SqliteConnectionManager::new(&amp;quot;test.db&amp;quot;).unwrap();
    let config = r2d2::Config::builder().pool_size(16).build();
    let pool = Arc::new(r2d2::Pool::new(config, manager).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで一旦コンパイル。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これが通れば良いです。&lt;/p&gt;

&lt;h1 id=&#34;はじめての挿入:b5100d6caeb6e32800002ace57fa8102&#34;&gt;はじめての挿入&lt;/h1&gt;

&lt;p&gt;INSERTを発行してみましょう。&lt;code&gt;on_channel_dir&lt;/code&gt;の引数を変える必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path, pool: Arc&amp;lt;r2d2::Pool&amp;lt;SqliteConnectionManager&amp;gt;&amp;gt;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;併せて、呼び出しも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        on_channel_dir(&amp;amp;path, pool.clone());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;/p&gt;

&lt;p&gt;そうしたら&lt;code&gt;on_channel_dir&lt;/code&gt;の中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていた辺でまずはserversへのインサートを発行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let conn = pool.get().unwrap();
    let server_id = match conn.execute(&amp;quot;INSERT INTO servers (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;server]) {
        // unique constraint failed
        Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM servers WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;server], |r| r.get(0)).unwrap(),
        Ok(_) =&amp;gt; conn.last_insert_rowid(),
        e =&amp;gt; {e.unwrap(); return}
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プールからコネクションを持ってきて&lt;code&gt;INSERT&lt;/code&gt;を発行します。成功するか既にUNIQUEな名前が存在していて失敗したらサーバのidを持ってきます。それ以外の失敗だったらそのままパニックしていいでしょう。&lt;/p&gt;

&lt;p&gt;しかしラッパがちょっと雑すぎやしませんかね。エラーステータスくらいenumでラップして欲しかった。&lt;/p&gt;

&lt;p&gt;同じくチャネルもインサートしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel_id = match conn.execute(&amp;quot;INSERT INTO channels (name, server_id) VALUES ($1, $2)&amp;quot;, &amp;amp;[&amp;amp;channel, &amp;amp;server_id]) {
        // unique constraint failed
        Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM channels WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;channel], |r| r.get(0)).unwrap(),
        Ok(_) =&amp;gt; conn.last_insert_rowid(),
        e =&amp;gt; {e.unwrap(); return}

    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こういうupsertというかinsert or get_idってどうやるのが正解なんでしょう。DB力が低い…&lt;/p&gt;

&lt;h1 id=&#34;エントリのインサート:b5100d6caeb6e32800002ace57fa8102&#34;&gt;エントリのインサート&lt;/h1&gt;

&lt;p&gt;同じく&lt;code&gt;on_log&lt;/code&gt;の引数を増やします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_log(log: &amp;amp;Path, channel_id: i64,  pool: Arc&amp;lt;r2d2::Pool&amp;lt;SqliteConnectionManager&amp;gt;&amp;gt;) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し側も。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let pool_ = pool.clone();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log, channel_id, pool_))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt;する前に&lt;code&gt;clone&lt;/code&gt;しないとダメですね。所有権難しい。&lt;/p&gt;

&lt;p&gt;さて、今度は色々することがあります。
まず、dateとtimeをくっつけてdatetimeにしましょう。timeがイミュータブルだったので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let mut time = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とし、その下で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        time.tm_mday = date.tm_mday;
        time.tm_mon = date.tm_mon;
        time.tm_year = date.tm_year;
        let created_at = time.to_timespec();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。わざわざ&lt;code&gt;to_timespec&lt;/code&gt;で変換してるのは&lt;code&gt;Timespec&lt;/code&gt;だとDBライブラリが良い感じに変換してくれるからですね。&lt;/p&gt;

&lt;p&gt;次にメッセージの抜き出し部分も値を返すように変更。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let (user, type_, body) = match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;sysmsg&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;join&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;part&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; (user, &amp;quot;msg&amp;quot;, body),
                None =&amp;gt; {
                    warn!(&amp;quot;cannot parse the entry; skipping&amp;quot;);
                    continue;
                }
            },
            _ =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;notice&amp;quot;, &amp;amp;msg[1..]),
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまで来たらあとはユーザとエントリをインサートするだけですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let conn = pool.get().unwrap();
        let user_id = match conn.execute(&amp;quot;INSERT INTO users (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;user]) {
            // unique constraint failed
            Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM users WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;user], |r| r.get(0)).unwrap(),
            Ok(_) =&amp;gt; conn.last_insert_rowid(),
            e =&amp;gt; {e.unwrap(); return}
        };
        conn.execute(&amp;quot;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)&amp;quot;, &amp;amp;[&amp;amp;channel_id, &amp;amp;user_id, &amp;amp;type_, &amp;amp;body, &amp;amp;created_at]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦これで走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#hongo@utmc/2015-02-15.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-08-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-12-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-02-26.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-05-23.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-04-30.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2013-10-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-14.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-01-19.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-08-12.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-06-03.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-02-05.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あちゃー。マルチスレッドでINSERTしてるのでロックが掛かってますね。SQLiteはファイルロックしか持たないので並列インサートはつらそう。&lt;/p&gt;

&lt;h1 id=&#34;トランザクション:b5100d6caeb6e32800002ace57fa8102&#34;&gt;トランザクション&lt;/h1&gt;

&lt;p&gt;はい、そういう時のトランザクションですよ。&lt;/p&gt;

&lt;p&gt;最後のユーザやエントリーをインサートしてる部分で使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let conn = pool.get().unwrap();
        let trx = conn.transaction().unwrap();
        let user_id = match conn.execute(&amp;quot;INSERT INTO users (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;user]) {
            // unique constraint failed
            Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM users WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;user], |r| r.get(0)).unwrap(),
            Ok(_) =&amp;gt; conn.last_insert_rowid(),
            e =&amp;gt; {e.unwrap(); return}
        };
        trx.commit();
        let trx = conn.transaction().unwrap();
        conn.execute(&amp;quot;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)&amp;quot;, &amp;amp;[&amp;amp;channel_id, &amp;amp;user_id, &amp;amp;type_, &amp;amp;body, &amp;amp;created_at]);
        trx.commit();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排他制御が目的なのでトランザクションを2回取ってます。&lt;/p&gt;

&lt;p&gt;これだとどうなるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#hongo@utmc/2015-02-15.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-08-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-12-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-02-26.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-05-23.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-04-30.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2013-10-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-14.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-01-19.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-08-12.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-06-03.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-02-05.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーは減ったもののまだ出ます。&lt;/p&gt;

&lt;h1 id=&#34;その他:b5100d6caeb6e32800002ace57fa8102&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;他にスレッドプールを使って並列度を下げる、ワーカースレッドを使ってSQLiteへの書き込みを1スレッドにするなども試したのですが上手く行きませんでした。&lt;/p&gt;

&lt;p&gt;スレッドプールについては、今回エラーハンドリングのためにスレッドを立てている訳ですが、パニックを出してスレッドが死ぬとあまり思わしくない挙動をするのでダメでした。&lt;/p&gt;

&lt;p&gt;ワーカースレッドは書き込んだ後にまたchannel_idなどを受け取らないといけないのでやめました。promiseなどを使えば上手くいきそうな気もしますが色々面倒そうなので止めておきます。&lt;/p&gt;

&lt;h1 id=&#34;コネクション:b5100d6caeb6e32800002ace57fa8102&#34;&gt;コネクション&lt;/h1&gt;

&lt;p&gt;並列度を下げる方法はもう1つあります。&lt;/p&gt;

&lt;p&gt;mainの中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let config = r2d2::Config::builder().pool_size(16).build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていたのを覚えていますでしょうか。これはコネクションプールに16個のコネクションを持っています。この数を落とせばなんとかならないでしょうか。&lt;/p&gt;

&lt;p&gt;結論からいうとダメでした。今度は複数スレッドがコネクションを取り合ってタイムアウトが発生してしまいます。&lt;/p&gt;

&lt;h1 id=&#34;並列度を下げる:b5100d6caeb6e32800002ace57fa8102&#34;&gt;並列度を下げる&lt;/h1&gt;

&lt;p&gt;最後の最後、本当に並列度を下げる方法があります。スレッドを立てていた部分で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let threads = logs.map(|log| {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log))
    }).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
    for thread in threads {
        let _ = thread.unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていました。これはファイル数分並列に実行してしまいます。ここを抑えましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    for log in logs {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        let pool_ = pool.clone();
        let _ = Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log, channel_id, pool_)).unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;spawn&lt;/code&gt;してそのまま&lt;code&gt;join&lt;/code&gt;します。こうすれば並列度を抑えつつパニックをスレッドに分離出来ます。&lt;/p&gt;

&lt;p&gt;これで実行するとどうなるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#lisp-ja@freenode/2015-04-08.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いくつかタイムアウトを出します。えー。並列度1でこれならもうどうしようもないでしょう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:b5100d6caeb6e32800002ace57fa8102&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;さて、小さなツールを作るというタイトルにしては後半(執筆が)重い内容になってしまいました。というか、sqlite3の問題もしますが。&lt;/p&gt;

&lt;p&gt;このブログの内容としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rustでディレクトリを扱った&lt;/li&gt;
&lt;li&gt;ファイルを扱った&lt;/li&gt;
&lt;li&gt;文字列を扱った&lt;/li&gt;
&lt;li&gt;日付を扱った&lt;/li&gt;
&lt;li&gt;スレッドを扱った&lt;/li&gt;
&lt;li&gt;ロガーライブラリを扱った&lt;/li&gt;
&lt;li&gt;エラーハンドリングをした&lt;/li&gt;
&lt;li&gt;パニックのハンドリングをした&lt;/li&gt;
&lt;li&gt;DBを扱った&lt;/li&gt;
&lt;li&gt;sqlite3に並列書き込みはつらい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ボツ案も含めれば私個人はORMやスレッドプール、チャネルも扱いましたが関係ないですね。&lt;/p&gt;

&lt;p&gt;こういう簡単なツールでも思ったより色々な機能を触れるのでみなさん試してみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;ソースコード全体は&lt;a href=&#34;https://github.com/KeenS/irc_log&#34;&gt;ここ&lt;/a&gt;においておきます。&lt;/p&gt;

&lt;p&gt;因みに本筋とは外れますが、今回のSQLiteの問題を扱うには一旦CSVファイルに書き出してからCSVインポートでバルクインサートが考えられます。
CSVに書き出すのはちまちまやってもいいし今回のデータ量ならオンメモリ構築して一気に書き出しも出来るでしょう。あるいはSQLiteをやめてMySQLを使う。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustで小さなツールを作ってみる(前編)</title>
      <link>http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru</link>
      <pubDate>Sat, 14 Nov 2015 23:57:43 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 1日目の記事です。&lt;br /&gt;
次 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_/&#34;&gt;Rustで小さなツールを作ってみる(後編)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。Rust Advent Calendar初日ということで軽い話から。
小さなツールって何だよって感じですが手元にIRCの生ログが大量にあるのでそれをDBにインポートしてみましょう。
あまりRustに向いた仕事じゃなさそうですが手始めとして。&lt;/p&gt;

&lt;p&gt;前編でログのパースを、後編でDBへのインポートをやります。&lt;/p&gt;

&lt;p&gt;IRCの生ログは&lt;a href=&#34;http://www.clovery.jp/tiarra/&#34;&gt;tiarra&lt;/a&gt;が吐いたものです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#emacs@freenode&lt;/code&gt;のように&lt;code&gt;チャネル名@サーバ名&lt;/code&gt;のディレクトリに入っていて、ファイル名は&lt;code&gt;YYYY-mm-dd.txt&lt;/code&gt;で、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;13:43:24 &amp;lt;#emacs@freenode:codingquark&amp;gt; Such key generation, much wow.
13:43:59 ! Vejeta` (Ping timeout: 264 seconds)
13:44:30 + jcazevedo (jcazevedo!~jcazevedo@a94-132-141-99.cpe.netcabo.pt) to #emacs@freenode
13:45:30 + quazimodo (quazimodo!~quazimodo@155.143.14.28) to #emacs@freenode
13:45:32 ! Hugehead_ (Read error: Connection reset by peer)
13:48:48 + favadi (favadi!~textual@113.190.4.106) to #emacs@freenode
13:51:06 wizzo -&amp;gt; bitchimightbe
13:52:23 bitchimightbe -&amp;gt; wizzo
13:53:05 - frost3772 from #emacs@freenode (&amp;quot;ERC (IRC client for Emacs 24.5.1)&amp;quot;)
13:56:37 ! chandan (Quit: WeeChat 1.2)
13:56:38 ! plunderous (Read error: Connection res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような形式で入ってます。先頭に&lt;code&gt;&amp;lt;&lt;/code&gt;が付いてるのが発言、&lt;code&gt;!&lt;/code&gt;がついてるのがなんかメッセージ(多分quitとかkillとか)、&lt;code&gt;+&lt;/code&gt;がjoin、&lt;code&gt;-&lt;/code&gt;がpart、無しがnickとかnoticeですかね。他にもログ取ってるircコマンドはあるのですが&lt;code&gt;!&lt;/code&gt;に内包されてそうですね(tiarraのマニュアルに載ってそうですが見るの面倒)&lt;/p&gt;

&lt;p&gt;因みにログ全体は&lt;code&gt;~/log&lt;/code&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;一応treeするとこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── #emacs@freenode
│   ├── 2014-04-11.txt
│   ├── 2014-04-12.txt
│   ├── 2014-04-13.txt
..  ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2014-04-11から2015-11-01までの間ロギングしてます。&lt;/p&gt;

&lt;h1 id=&#34;ディレクトリリスティングまで:a7315be0136fc976c0c4320441efd799&#34;&gt;ディレクトリリスティングまで&lt;/h1&gt;

&lt;p&gt;まずは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new irc_log --bin
$ cd irc_log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;code&gt;src/main.rs&lt;/code&gt;を開いて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs;

fn main() {
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, path.to_string_lossy().to_string());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きましょう。path path煩いですね。OSの返す文字列(Cの文字列)とRustの文字列の違いだとか一旦&lt;code&gt;Path&lt;/code&gt;で抽象化してるだとかで文字列を抜き出すのは一苦労です。&lt;/p&gt;

&lt;p&gt;さて、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でディレクトリ名が出てくればOK。&lt;/p&gt;

&lt;h1 id=&#34;ファイル名リスティング:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイル名リスティング&lt;/h1&gt;

&lt;p&gt;mainを&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs;

fn main() {
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        on_channel_dir(&amp;amp;path);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と置き換えてチャネルのディレクトリでの作業は&lt;code&gt;on_channel_dir&lt;/code&gt;でやりましょう。&lt;/p&gt;

&lt;h2 id=&#34;チャネル名とサーバ名の抜き出し:a7315be0136fc976c0c4320441efd799&#34;&gt;チャネル名とサーバ名の抜き出し&lt;/h2&gt;

&lt;p&gt;ディレクトリ名が&lt;code&gt;チャネル名@サーバ名&lt;/code&gt; の 形をしているので @の前後を抜き出せば良さそうです。&lt;/p&gt;

&lt;p&gt;src/main.rsの先頭に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::path::Path;
use std::str::from_utf8;
use std::os::unix::prelude::OsStrExt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でとりあえず&lt;code&gt;/&lt;/code&gt;の付かないディレクトリ名を取れそうです。難しい。やはりOSの返す文字列の扱いは面倒ですね。
しかし一旦Rustの文字列になってしまえばこちらのもの。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;@&lt;/code&gt;の位置を取得出来ます。&lt;code&gt;@&lt;/code&gt;がなかったらreturnして無視しておきましょう（実際そういう名前のディレクトリがあるのですが今回の集計の対象外なので）。&lt;/p&gt;

&lt;p&gt;あとは部分文字列を取るだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ファイルリスティング:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルリスティング&lt;/h2&gt;

&lt;p&gt;これは先程と同じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        let log = log.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, log.to_string_lossy().to_string());
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、&lt;code&gt;on_channel_dir&lt;/code&gt;全体はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        let log = log.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, log.to_string_lossy().to_string());
    };
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ファイルのパース:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルのパース&lt;/h1&gt;

&lt;p&gt;次にまた&lt;code&gt;println!&lt;/code&gt;の部分を&lt;code&gt;on_log&lt;/code&gt;としてファイルをパースしていきましょう。&lt;/p&gt;

&lt;h2 id=&#34;日付の抜き出し:a7315be0136fc976c0c4320441efd799&#34;&gt;日付の抜き出し&lt;/h2&gt;

&lt;p&gt;先程と似てますので飛ばし気味にいきます。&lt;/p&gt;

&lt;p&gt;簡単にやっても良いのですがお作法として日付ライブラリを使ってパースしましょう。
&lt;code&gt;Cargo.toml&lt;/code&gt;に以下を追記。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]
time = &amp;quot;*&amp;quot;
log = &amp;quot;0.3.3&amp;quot;
env_logger = &amp;quot;0.3.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本当はバージョンも指定した方が良いのですが書き捨てのコードなのでまあ、良いでしょう。因みにtimeライブラリ自体扱いづらいとか色々問題があるのですがそれは後のAdvent Calendarに譲りましょう。しれっとloggerも導入します。printfデバッグにlogger便利!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;してdependenciesをインストールします。因みに&lt;code&gt;log&lt;/code&gt;がlogger facadで&lt;code&gt;env_logger&lt;/code&gt;がloggerの実装です。使い方は後程。&lt;/p&gt;

&lt;p&gt;またsrc/main.rsの先頭に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[macro_use]
extern crate log;
extern crate env_logger;
extern crate time;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記。&lt;/p&gt;

&lt;p&gt;そして&lt;code&gt;on_log&lt;/code&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_log(log: &amp;amp;Path) {
    let datestr = from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();
    let date = time::strptime(&amp;amp;datestr, &amp;quot;%Y-%m-%d&amp;quot;).urwrap();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は失敗しないことが分かってるので全部&lt;code&gt;unwrap&lt;/code&gt;してます。本当は&lt;code&gt;try!&lt;/code&gt;を使って上流に委ねた方がいいのですが今回は面倒なのでこうしちゃってます。正しいエラーハンドリングはtrplの&lt;a href=&#34;https://doc.rust-lang.org/book/error-handling.html&#34;&gt;Error Handling&lt;/a&gt;を読みましょう。&lt;/p&gt;

&lt;h2 id=&#34;ファイルの読み出し:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルの読み出し&lt;/h2&gt;

&lt;h3 id=&#34;開く:a7315be0136fc976c0c4320441efd799&#34;&gt;開く&lt;/h3&gt;

&lt;p&gt;コードをいきなり載せると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let file = match fs::File::open(log) {
        Ok(f) =&amp;gt; f,
        Err(e) =&amp;gt; {
            error!(&amp;quot;could not open {}; skipping.&amp;quot;, log.display());
            return;
        }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。これはエラーハンドリングします。1つのファイルに失敗しても次があるので。ここで使ってる&lt;code&gt;error!&lt;/code&gt;がloggerのマクロです。&lt;/p&gt;

&lt;h2 id=&#34;行毎の読み出し:a7315be0136fc976c0c4320441efd799&#34;&gt;行毎の読み出し&lt;/h2&gt;

&lt;p&gt;行毎の読み出しはバッファーリーダーが必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io::BufReader;
use std::io::BufRead;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をsrc/main.rsの先頭部分に追記しましょう。因みに&lt;code&gt;BufRead&lt;/code&gt;がトレイトで、&lt;code&gt;BufReader&lt;/code&gt;が実装です。実装が必要なのは良いとして、トレイトまで必要なのはトレイトで定義された関数を呼び出すのにトレイトのインポートが必要だからですね。&lt;/p&gt;

&lt;p&gt;さてさて、行の読み出しを進めます。先程オープンしたファイルを&lt;code&gt;BufReader&lt;/code&gt;で包んでやればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let br = BufReader::new(&amp;amp;file);
    for line in br.lines() {
        let line = match line {
            Ok(l) =&amp;gt; l,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;ignoring error {}&amp;quot;, e);
                continue;
            }
        };
        ....
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行の読み出し結果もResultで返ってくるんですね。これも失敗したら読み飛ばせばいいので&lt;code&gt;urwrap&lt;/code&gt;せずに扱います。&lt;/p&gt;

&lt;h2 id=&#34;行のパース:a7315be0136fc976c0c4320441efd799&#34;&gt;行のパース&lt;/h2&gt;

&lt;h3 id=&#34;ガード:a7315be0136fc976c0c4320441efd799&#34;&gt;ガード&lt;/h3&gt;

&lt;p&gt;先頭部分の時間をパースする時に部分文字列を抜き出しますが、変な行だと10文字もなかったりするので一旦ガードを付けておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        if line.len() &amp;lt; 10 {
            warn!(&amp;quot;ignoring line {}&amp;quot;, line);
            continue;
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;時間のパース:a7315be0136fc976c0c4320441efd799&#34;&gt;時間のパース&lt;/h3&gt;

&lt;p&gt;これはファイル名の時とほぼ同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let time = match time::strptime(&amp;amp;line[0..8], &amp;quot;%H:%M:%S&amp;quot;) {
            Ok(t) =&amp;gt; t,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;Parse error {}; ignoring&amp;quot;, e);
                continue;

            }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度は変な行が紛れてそうな（実際、ログファイルにはよくある）のでエラーは無視します。&lt;/p&gt;

&lt;h3 id=&#34;メッセージのパース:a7315be0136fc976c0c4320441efd799&#34;&gt;メッセージのパース&lt;/h3&gt;

&lt;p&gt;0-8文字目に時間があって、1スペース挟むので9文字目からがメッセージですね。そして先頭の文字で判断出来るのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let msg = &amp;amp;line[9..];
        match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; println!(&amp;quot;sysmsg {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; println!(&amp;quot;join {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; println!(&amp;quot;part {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; println!(&amp;quot;user: {} body: {}&amp;quot;, user, body),
                None =&amp;gt; ()
            },
            _ =&amp;gt; println!(&amp;quot;info {}&amp;quot;, &amp;amp;msg[1..]),
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で判断出来そうです。パースした後の話は後回し。&lt;/p&gt;

&lt;h1 id=&#34;ソース全体:a7315be0136fc976c0c4320441efd799&#34;&gt;ソース全体&lt;/h1&gt;

&lt;p&gt;ソースの断片が続いたので一旦ここまでの全体像を出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[macro_use]
extern crate log;
extern crate env_logger;
extern crate time;
use std::str::from_utf8;
use std::io::BufReader;
use std::io::BufRead;
use std::fs;
use std::path::Path;
use std::os::unix::prelude::OsStrExt;


fn on_log(log: &amp;amp;Path) {
    let datestr = from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();
    let date = time::strptime(&amp;amp;datestr, &amp;quot;%Y-%m-%d&amp;quot;);
    let file = match fs::File::open(log) {
        Ok(f) =&amp;gt; f,
        Err(e) =&amp;gt; {
            error!(&amp;quot;could not open {}; skipping.&amp;quot;, log.display());
            return;
        }
    };
    let br = BufReader::new(&amp;amp;file);
    for line in br.lines() {
        let line = match line {
            Ok(l) =&amp;gt; l,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;ignoring error {}&amp;quot;, e);
                continue;
            }
        };
        if line.len() &amp;lt; 10 {
            warn!(&amp;quot;ignoring line {}&amp;quot;, line);
            continue;
        }
        let time = match time::strptime(&amp;amp;line[0..8], &amp;quot;%H:%M:%S&amp;quot;) {
            Ok(t) =&amp;gt; t,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;Parse error {}; ignoring&amp;quot;, e);
                continue;

            }
        };
        let msg = &amp;amp;line[9..];
        match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; println!(&amp;quot;sysmsg {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; println!(&amp;quot;join {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; println!(&amp;quot;part {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; println!(&amp;quot;user: {} body: {}&amp;quot;, user, body),
                None =&amp;gt; ()
            },
            _ =&amp;gt; println!(&amp;quot;info {}&amp;quot;, &amp;amp;msg[1..]),
        }
    }
}

fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        on_log(&amp;amp;log.unwrap().path());
    };
}


fn main(){
    env_logger::init().unwrap();
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        on_channel_dir(&amp;amp;path);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はmainの先頭で&lt;code&gt;env_logger::init().unwrap();&lt;/code&gt;でロガーの初期化してました。忘れてましたね。ごめんなさい。&lt;/p&gt;

&lt;p&gt;さて、これで一旦走らせてみましょう。動く筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動いてるようですが、遅い。出力が多くてターミナル側がボトルネックのようです。&lt;/p&gt;

&lt;h1 id=&#34;パニックハンドルとチューニング:a7315be0136fc976c0c4320441efd799&#34;&gt;パニックハンドルとチューニング&lt;/h1&gt;

&lt;p&gt;一旦メッセージを出力をやめて様子見してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;            &amp;quot;!&amp;quot; =&amp;gt; (),
            &amp;quot;+&amp;quot; =&amp;gt; (),
            &amp;quot;-&amp;quot; =&amp;gt; (),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; (),
            _ =&amp;gt; (),

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それでもまだ遅い上に謎のパニックが出てます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;/home/kim/log/#lisp@freenode&#39; panicked at &#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary&#39;, ../src/libcore/str/mod.rs:1311
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログを見てみましょう。env_loggerは環境変数からログレベルを渡してあげるとログを出します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ RUST_LOG=Trace cargo run
...
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意外と変な行が一杯あるのですね。しかしこれらはちゃんとエラーハンドリングしてるので問題ありません。&lt;/p&gt;

&lt;p&gt;各所で&lt;code&gt;unwrap&lt;/code&gt;してるせいな気もしますが、&lt;code&gt;urwrap&lt;/code&gt;のせいならそういうメッセージが出るので違います。&lt;/p&gt;

&lt;p&gt;実はこれ、非UTF-8のバイト列でrustの標準ライブラリが内部でパニックを出してます。
これの扱いも後のAdvent Calendarに譲るとして、ワークアラウンドを捜しましょう。rust1.4時点ではパニックをハンドルする手段はありません。&lt;/p&gt;

&lt;p&gt;パニックメッセージの先頭に&lt;code&gt;thread&lt;/code&gt;とついてるのでthreadで包めば良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;thread:a7315be0136fc976c0c4320441efd799&#34;&gt;Thread&lt;/h2&gt;

&lt;p&gt;まずはthreadをインポートします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::thread::Builder;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてon_channel_logを少し弄りましょう。無効なバイト列を含むファイルをざっくり切る感じで。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    for log in logs {
        on_log(&amp;amp;log.unwrap().path());
    };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていた部分を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let threads = logs.map(|log| {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log))
    }).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
    for thread in threads {
        let _ = thread.unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。一見複雑ですが、ファイル毎にスレッドを作って全部をvectorにして集めてそれぞれjoinを待ってるだけです。
そしてスレッド名を処理するファイル名にしたいのでスレッドビルダを使っています。&lt;/p&gt;

&lt;p&gt;さて、これで走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time cargo run
...
#lisp at freenode
thread &#39;/home/kim/log/#lisp@freenode/2014-08-18.txt&#39; panicked at &#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary&#39;, ../src/libcore/str/mod.rs:1311
#emacs at freenode
...
cargo run  327.21s user 8.71s system 630% cpu 53.289 total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lispチャネルの1ファイルだけに変なバイト列があることが分かりました。&lt;/p&gt;

&lt;p&gt;そしてパフォーマンスですが、とりあえず&lt;code&gt;top&lt;/code&gt;で見る限りCPUは最大770%使ってくれてます（8コアマシン）。ファイル毎にスレッド作ってるので若干リソースの食い合いが発生してますがこれだけ並列度があればスレッドプールを使うまでもないでしょう。&lt;/p&gt;

&lt;h2 id=&#34;さらなるチューニング:a7315be0136fc976c0c4320441efd799&#34;&gt;さらなるチューニング…？&lt;/h2&gt;

&lt;p&gt;しかしそれでもまだ遅いですね。ちょこっと書いては走らせるのサイクルを回すには耐えられません。&lt;/p&gt;

&lt;p&gt;そういえばログ全体のファイルサイズを確認してなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -h
...
774M   .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意外と小さい。まだチューニングの余地はありそうです。メモリアロケーションを減らしましょうか、それとも時間のパースを手書きでやりましょうか。&lt;/p&gt;

&lt;p&gt;いいえ。もっと簡単に速くする方法があります。&lt;code&gt;--release&lt;/code&gt;をつけて実行すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
...
cargo run --release  3.63s user 5.44s system 203% cpu 4.453 total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(/ 53.289 4.453);=&amp;gt; 11.966988547046935&lt;/code&gt; 。12倍速くなりました。1ディレクトリ700以上のファイルがあってそれぞれにスレッドを作っているのでそろそろそのオーバーヘッドが効いてきてますね。&lt;/p&gt;

&lt;p&gt;スレッドプールを試してみたい気もしますがひとまずこれで置いておきましょう。&lt;/p&gt;

&lt;p&gt;次は後編、DBへのインポートです。&lt;/p&gt;

&lt;p&gt;蛇足ですが行のパースのところは正規表現でも出来ましたね。そっちの方が好きな方は試してみて下さい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>