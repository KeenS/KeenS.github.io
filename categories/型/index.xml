<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/categories/%E5%9E%8B/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/%E5%9E%8B/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rustの所有権、ライフタイム、参照、型、しがらみ</title>
      <link>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</link>
      <pubDate>Wed, 14 Dec 2016 11:19:12 +0900</pubDate>
      
      <guid>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</guid>
      <description>&lt;p&gt;κeenです。Rustには所有権やらライフタイムやら参照やらがあって型システムが面倒ですよね。線形（アフィン）と言われてるのに「あれ？」と思う部分もあるので詳しく探っていこうと思います。&lt;/p&gt;

&lt;p&gt;尚、この記事は型システムに興味のある人向けです。単にRustを書きたい方に有用な情報があるかは分かりません。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;線形型-アフィン型&#34;&gt;線形型？アフィン型？&lt;/h1&gt;

&lt;p&gt;はじめにこの辺をハッキりさせておきたいです。
アフィン型は線形型に弱化規則を許す型です。
プログラミング的に言えば線形型は &lt;code&gt;free&lt;/code&gt; しないと型エラーになるけどアフィン型はそうでない。
Rustはご存知の通り &lt;code&gt;free&lt;/code&gt; 相当のものを手で書くことはないのでアフィンな気がしますし、昔のドキュメントにもそう書いてました。&lt;/p&gt;

&lt;p&gt;しかし実際に実行されるプログラムではコンパイラが差し込んだ &lt;code&gt;free&lt;/code&gt; が実行されるので &lt;code&gt;free&lt;/code&gt; を省略出来るというシンタックスシュガーの類な気もします。&lt;/p&gt;

&lt;p&gt;ただまあ、 &lt;code&gt;free&lt;/code&gt; を差し込む位置を特定するのに弱化規則を使った場所で推論している筈なのでアフィンを使ってる筈ですよね。&lt;/p&gt;

&lt;p&gt;ってことで今回の記事はアフィン型で統一したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;参照も値&#34;&gt;参照も値&lt;/h1&gt;

&lt;p&gt;なんとなく、構文が用意されているので参照自体特別な存在な気がしますが、そんなことはありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_any&amp;lt;T&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように任意の値を取れる関数を用意してあげます。
すると、以下のように所有、参照、可変参照全て渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let mut s = take_any(s);
take_any(&amp;amp;s);
take_any(&amp;amp;mut s);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;は-copy-mut-は違う&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; は違う&lt;/h1&gt;

&lt;p&gt;先と同じように &lt;code&gt;Copy&lt;/code&gt; を実装した型を受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_copy&amp;lt;T: Copy&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに参照を渡してあげると、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
take_copy(&amp;amp;s);
take_copy(&amp;amp;mut s); // error[E0277]: the trait bound `&amp;amp;mut std::string::String: std::marker::Copy` is not satisfied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、 &lt;code&gt;Copy&lt;/code&gt; なので普通に何度も使えます。線形型でいう &lt;code&gt;!&lt;/code&gt; に近いですね。違いますけど。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let ref_s = &amp;amp;s;
let x: &amp;amp;String = ref_s;
let y: &amp;amp;String = ref_s;
// Copy(が要求するClone)に実装されているメソッドを陽に呼ぶ
let z: &amp;amp;String = (&amp;amp;ref_s).clone();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、 &lt;code&gt;Copy&lt;/code&gt; への参照は参照外しが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x: isize = 1;
let ref_x = &amp;amp;x;
let x: isize = *x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; は &lt;code&gt;&amp;amp;&lt;/code&gt; への参照（&lt;code&gt;Copy&lt;/code&gt;への参照）なので &lt;code&gt;&amp;amp;&lt;/code&gt; へ参照外しが可能ですが、 &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; は&lt;code&gt;&amp;amp;mut&lt;/code&gt;への参照（&lt;code&gt;Copy&lt;/code&gt;ではない値への参照）なので参照外し出来ません。&lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; とややこしいですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
// &amp;amp;&amp;amp;
{
    let ref_ref_s = &amp;amp;&amp;amp;s;
    let ref_s: &amp;amp;String = *ref_refs;
}
// &amp;amp;mut &amp;amp;
{
    let refmut_ref_s = &amp;amp;mut &amp;amp; s;
    let reft_s: &amp;amp;String = *s;
}

// &amp;amp;&amp;amp;mut
{
    let ref_refmut_s = &amp;amp;&amp;amp;mut s;
    let refmut_s: &amp;amp;mut String = *s; // error[E0389]: cannot borrow data mutably in a `&amp;amp;` reference
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;T&lt;/code&gt; が &lt;code&gt;&amp;amp;T&lt;/code&gt; に参照外し出来る理由も分かったかと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-は-deref&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; は &lt;code&gt;Deref&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がたまに &lt;code&gt;&amp;amp;&lt;/code&gt; のように振る舞うことがありますが、これは &lt;code&gt;Deref&lt;/code&gt; のせいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::Deref;

let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
{
    // derefを陽に呼ぶ
    let ref_s: &amp;amp;string = refmut_s.deref();
}

{
    // 暗黙のDerefによる型強制
    let ref_s: &amp;amp;string = refmut_s;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rustは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/deref-coercions.html&#34;&gt;&lt;code&gt;deref&lt;/code&gt; による型強制&lt;/a&gt;を行うため、無言で &lt;code&gt;&amp;amp;mut&lt;/code&gt; を &lt;code&gt;&amp;amp;&lt;/code&gt; に変換することが出来ます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、ここまでで &lt;code&gt;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&lt;/code&gt; もただの値であること、アフィン型に反しないことを調べました。
次はライフタイムについて探ります。&lt;/p&gt;

&lt;h1 id=&#34;ライフタイムとサブタイピング&#34;&gt;ライフタイムとサブタイピング&lt;/h1&gt;

&lt;p&gt;実は、Rustにはサブタイピングがあります。ライフタイムです。ライフタイムにはサブタイプ関係があるのです。&lt;/p&gt;

&lt;p&gt;このように、2つの引数が厳密に同じライフタイムであることを要求する関数を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_ref&amp;lt;&#39;a&amp;gt;(_: &amp;amp;&#39;a String, _: &amp;amp;&#39;a String) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに、違うライフタイムを持つ型を放り込んでみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
    let a = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;a;
    {
        let b = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;b;
        take_two_ref(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはコンパイルが通ります。明示的にライフタイムを書くとこうです。これは有効な構文ではないです（余談ですがラベル付きbreak文のための構文と衝突します）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {
    let a = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;&#39;a a;
    &#39;b: {
        let b = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;&#39;b b;
        take_two_ref::&amp;lt;&#39;b&amp;gt;(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大は小を兼ねるので &lt;code&gt;&#39;a&lt;/code&gt; は &lt;code&gt;&#39;b&lt;/code&gt; のサブタイプになっています。
ちょっと言葉がややこしいのですが、スコープが狭いライフタイムの方が大きい型です。狭い方が大きい。この言い回しに馴れてない人に説明すると、上の例でいえば &lt;code&gt;&#39;b&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; と &lt;code&gt;&#39;b&lt;/code&gt; 2つありますが、 &lt;code&gt;&#39;a&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; だけです。 2つと1つだったら2つの方が大きいですよね。&lt;/p&gt;

&lt;p&gt;さて、今回の例ではちゃんとスコープの入れ子とサブタイプ関係が一致していました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {----------
              |
              |
    &#39;b: {--   |
          |   |
          |   |
          |   |
    }------   |
}--------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参照を取るときは参照のライフタイムが元のライフタイムのサブタイプになっている必要があります。&lt;/p&gt;

&lt;p&gt;この関係に反するとエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();
    ref_s = &amp;amp;s; // error: `s` does not live long enough
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;図示するとこうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();-----
    ref_s = &amp;amp;s; ----------------  |
                               |  |
}------------------------------+---
                               |
--------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ライフタイムといえどある種、型なんですね。余談ですが確かリージョンの論文には「リージョンはプログラム全体を静的に伝播する型のようなもの」と表現していた気がします。既存の型と直行するので型とは別とも言えますし、タプルのように両方並べたものを型と言うことも出来ますね。&lt;/p&gt;

&lt;h1 id=&#34;所有型とライフタイムと-static&#34;&gt;所有型とライフタイムと &lt;code&gt;&#39;static&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;適切な語彙がなかったので勝手に所有型と名付けましたが、参照でない型のことを指しています。（先の例で見せた通り、参照型にも所有権はあるので適切ではないですがひとまず我慢して下さい。）&lt;/p&gt;

&lt;p&gt;さて、なんとなくライフタイムと参照型は結び付いている気がしますが、参照じゃない型にもライフタイムはあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_value&amp;lt;&#39;a, T: &#39;a, S: &#39;a&amp;gt;(_: T, _: S){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、任意の2つの型を取るけども両方ともにライフタイムを要求する関数を書いてみます。&lt;/p&gt;

&lt;p&gt;これに、所有型を渡すことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let t = &amp;quot;t&amp;quot;.to_string();
{
    let s = &amp;quot;s&amp;quot;.to_string();
    let s_ref = &amp;amp;s;
        take_two_value(t, s_ref);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、所有型にもライフタイムはあります。&lt;/p&gt;

&lt;p&gt;ところで、ライフタイムのボトム型相当のものに &lt;code&gt;&#39;static&lt;/code&gt; というものがあります。
グローバル変数やリテラルなどに割り当てられるライフタイムで、プログラムが死ぬまで生き続けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&#39;static&lt;/code&gt; のみを受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_static&amp;lt;T: &#39;static&amp;gt;(_: T){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、先の例に出たstaticな値達を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar;
    take_static(foo);
    take_static(x);
    take_static(ref_bar);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これに所有型を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、任意の参照型は渡せません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(&amp;amp;s); // error: `s` does not live long enough
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで所有型には &lt;code&gt;&#39;static&lt;/code&gt; というライフタイムが付いているのでした。
&lt;code&gt;&#39;static&lt;/code&gt; イメージとしては「自分がその値を保持している限り無効になることはない型」ですかね。&lt;/p&gt;

&lt;p&gt;これに関連するTipsとして関数や構造体のジェネリクスで所有型しか受け取らないようにするには &lt;code&gt;&amp;lt;T: &#39;static&amp;gt;&lt;/code&gt; が使えます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さてさて、これまた参照型は特別扱いされることなく他のRustの値と同じようにライフタイムで管理されていることを調べました。&lt;/p&gt;

&lt;p&gt;最後に今回到達出来なかった謎、「参照を取る」について考えたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-の規則&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; の規則&lt;/h1&gt;

&lt;p&gt;みなさん御存じの通り、&lt;code&gt;&amp;amp;mut&lt;/code&gt; を取ると値への他の操作が許されなくなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
let t = s;  // error[E0505]: cannot move out of `s` because it is borrowed
let ref_s = &amp;amp;s; // error[E0502]: cannot borrow `s` as immutable because it is also borrowed as mutable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;mut T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; が相互排他的なのでこれは線形論理のシーケント計算っぽく書くと以下のような規則を考えれば良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Γ, T:&#39;a |- Σ
-------------- &amp;amp;mut-intro
Γ, &amp;amp;&#39;b mut (T:&#39;a) |- Σ
where &#39;a &amp;lt;: &#39;b

Γ, &amp;amp;&#39;a mut (T:&#39;b) |- &amp;amp;&#39;a mut (T: &#39;b), Σ
----------------------- &amp;amp;mut-elim
Γ, T: &#39;b |- Σ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型付け規則の書き方になれてないのでシーケント計算で書きましたがサブタイプの記述で困りましたね。&lt;/p&gt;

&lt;h1 id=&#34;の謎&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; の謎&lt;/h1&gt;

&lt;p&gt;さて、問題は &lt;code&gt;&amp;amp;&lt;/code&gt; です。 &lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; なのでそこら中に生えてきます。
なので &lt;code&gt;&amp;amp;-elim&lt;/code&gt; のような規則では対応出来ません。&lt;/p&gt;

&lt;p&gt;ただ、ライフタイムによる制約があるので「参照のライフタイムが死ぬときに元の値が復活する」ような規則を考えたくなります。&lt;/p&gt;

&lt;p&gt;しかし、それでもだめです。複数回 &lt;code&gt;&amp;amp;&lt;/code&gt; を取れてしまうので、以下のように複数のライフタイムを持つ場合で破綻します。&lt;code&gt;&amp;amp; T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; の間でなにかしらのしがらみがある筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
{
    let ref_s1 = &amp;amp;s;
    {
        let ref_s2 = &amp;amp;s;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それに、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; と &lt;code&gt;&amp;amp;&lt;/code&gt; が相互排他であることも説明出来る規則でないといけません。謎が多い。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;さて、Rustの型システムのリソース管理回りを探ってみました。とりあえず分かったことを纏めると&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;値には全てアフィン型が付く

&lt;ul&gt;
&lt;li&gt;参照型も例外ではない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;値には全てライフタイムが付く

&lt;ul&gt;
&lt;li&gt;所有型も例外ではない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「参照を取る」のセマンティクスが謎

&lt;ul&gt;
&lt;li&gt;勿論、直感的には分かる&lt;/li&gt;
&lt;li&gt;どういう規則なんだろう&lt;/li&gt;
&lt;li&gt;アフィン型とライフタイム両方が絡むはず。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特に論文も読んでないのでちょっと遠回りだったかもしれません。
もしかしたら論文漁ったら一発で解決するのかも。
詳しい方、 &lt;code&gt;&amp;amp;&lt;/code&gt; の謎を教えて下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustの関連型の使いどころ</title>
      <link>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</link>
      <pubDate>Tue, 22 Nov 2016 18:26:47 +0900</pubDate>
      
      <guid>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</guid>
      <description>&lt;p&gt;κeenです。昨日は&lt;a href=&#34;https://rust.connpass.com/event/41467/&#34;&gt;RustのLT会！ Rust入門者の集い - connpass&lt;/a&gt;に参加してきました。
そこで&lt;a href=&#34;http://qiita.com/tacke_jp/items/9c7617971dc341146c0f&#34;&gt;関連型に関する発表&lt;/a&gt;があったので感化されて私も一筆。&lt;/p&gt;

&lt;p&gt;
馴れないと関連型はジェネリクスでいいじゃんと思えますが、両者は別の機能を提供するものです。
設計による使い分けではなくて実現したいことに応じた機能による使い分けをするので馴れてしまえば迷うことなくどちらを使うか判断出来ます。&lt;/p&gt;

&lt;p&gt;ということで関連型のパターンをいくつか。
もちろん、根底にある関連型という機能は共通なのでほとんど同じようなことを言ってますが気持としてパターンを知っておくと便利です。&lt;/p&gt;

&lt;h1 id=&#34;型レベルの関数として&#34;&gt;型レベルの関数として&lt;/h1&gt;

&lt;p&gt;「関連」型なのである型に関連する型を表現します。ちょっと見方を変えると型から型への写像、つまり関数になります。
例えばこういうのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ToUnsigned {
    type Counterpart;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart;
}

impl ToUnsigned for i32 {
    type Counterpart = u32;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart {
        self as u32
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;i32&lt;/code&gt; から &lt;code&gt;u32&lt;/code&gt; への関数になってそうなのが見えますかね？もちろん、 &lt;code&gt;i64&lt;/code&gt; から &lt;code&gt;u64&lt;/code&gt; などへの対応も作れます。
こういうのは例えば符号無し数にのみ演算が定義されている場合とかに便利ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn write_bigendian_signed&amp;lt;I, U&amp;gt;(i: I) -&amp;gt; ()
    where I: ToUnsigned&amp;lt;Counterpart = U&amp;gt;,
          U: ...,  {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;トレイト内で使う型を固定するため&#34;&gt;トレイト内で使う型を固定するため&lt;/h1&gt;

&lt;p&gt;これが一番目にするやつじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Handler {
    type Request;
    type Response;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}

struct HTTPHandler;

impl Handler for HTTPHandler {
    type Request = HTTPRequest;
    type Response = HTTPResponse;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定というか特殊化というか、トレイト自体は汎用的に作られていて、それを実装する型が特定の処理に特化するパターンです。
ジェネリクスで受け取る訳にはいかなくて、実装すべき型をトレイトの中で定義してあげる必要があるのは分かると思います。&lt;/p&gt;

&lt;h1 id=&#34;関数の返り値を一般化するため&#34;&gt;関数の返り値を一般化するため&lt;/h1&gt;

&lt;p&gt;これは現在のRust(rust-1.13.0)が &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1522&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;をサポートしていないために必要になるテクニックです。
関連型とトレイト境界を組み合わせて使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ReverseIter {
    type Item;
    type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;
    fn rev_iter(&amp;amp;self) -&amp;gt; Iter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの &lt;code&gt;type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt; の方です。
返り値のIteratorを抽象化したいのですが、現在のRustでは&lt;code&gt;fn rev_iter(&amp;amp;self) -&amp;gt; Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt;のような書き方が出来ないので仕方なく関連型を使ってあげる必要があります。&lt;/p&gt;

&lt;p&gt;ちょっと踏み込んだ話をすると、関数の引数の多相性は∀の量化、返り値の多相は∃の量化です。そしてトレイトのジェネリクスも∀の量化で関連型が∃の量化なのでそういう対応がある訳です。&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;結構理論的にも色々あるようなので調べてみると様々なブログポストが見付かると思います。&lt;/p&gt;

&lt;p&gt;ぱぱっと思いついたパターンを3つ挙げました。もしかしたら他にもパターンがあるかもしれません。&lt;/p&gt;

&lt;p&gt;これを知っておけば&lt;a href=&#34;https://github.com/tokio-rs/tokio-service&#34;&gt;tokio-service&lt;/a&gt;の&lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;Service&lt;/a&gt;みたいな関連型を多用するパターンでもひるまなくなります。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;h2 id=&#34;関連型とimpl-traitに関して&#34;&gt;関連型とimpl Traitに関して&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rust-lang-ja.org/rust-by-example/generics/assoc_items/the_problem.html&#34;&gt;関連型が必要になる状況 | Rust by Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ncameron.org/blog/abstract-return-types-aka-%60impl-trait%60/&#34;&gt;Abstract return types, aka &lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;応用&#34;&gt;応用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2016/02/28/rustnohigherkinded_type_trait/&#34;&gt;RustのHigher-Kinded type Trait | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;発展的な話題&#34;&gt;発展的な話題&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/02/associated-type-constructors-part-1-basic-concepts-and-introduction/&#34;&gt;Associated type constructors, part 1: basic concepts and introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/03/associated-type-constructors-part-2-family-traits/&#34;&gt;Associated type constructors, part 2: family traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/04/associated-type-constructors-part-3-what-higher-kinded-types-might-look-like/&#34;&gt;Associated type constructors, part 3: What higher-kinded types might look like&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/09/associated-type-constructors-part-4-unifying-atc-and-hkt/&#34;&gt;Associated type constructors, part 4: Unifying ATC and HKT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1598&#34;&gt;Associated type constructors (a form of higher-kinded polymorphism). by withoutboats · Pull Request #1598 · rust-lang/rfcs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>幽霊型を知った</title>
      <link>/blog/2015/05/24/yuureikatawoshitta</link>
      <pubDate>Sun, 24 May 2015 22:38:47 +0900</pubDate>
      
      <guid>/blog/2015/05/24/yuureikatawoshitta</guid>
      <description>&lt;p&gt;κeenです。かねてより気になっていた幽霊型(Phantom Type)について知ったのでアウトプット。
&lt;a href=&#34;http://www.cs.rit.edu/~mtf/research/phantom-subtyping/jfp06/jfp06.pdf&#34;&gt;このPDF&lt;/a&gt;がベースになって
ます。&lt;/p&gt;

&lt;p&gt;余談ですが英語がファントム・タイプと中々中二な名前なので和訳も幻影型とかそういう方向に走って欲かったな。
&lt;/p&gt;

&lt;p&gt;「幽霊型」で調べると真っ先に&lt;a href=&#34;https://kagamilove0707.github.io/programming/2014/02/20/about-phantom-type/&#34;&gt;このサイト&lt;/a&gt;が出てくるのですが、ミスリーディングと言われていました。
別に間違ったことを書いている訳ではないのですが、幽霊型の応用例なのでこれこそが幽霊型だと思ってしまうと少し視野が狭くなってしまうようです。&lt;/p&gt;

&lt;h1 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h1&gt;

&lt;p&gt;ブーリアンと整数と条件分岐と足し算と比較が出来るミニ言語を考えてみます。自動で型変換は行わない(つまりintとboolの比較などは出来ない)言語とします。こんな感じでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype exp
  = Int of int
  | Bool of bool
  | If of exp * exp * exp
  | Plus of exp * exp
  | Equal of exp * exp

fun mkInt x = Int x
fun mkBool x = Bool x
fun mkIf cnd thn els = If(cnd, thn, els)
fun mkPlus x y = Plus(x, y)
fun mkEqual x y = Equal(x, y)

exception Type

fun evalIf cnd thn els =
  case eval cnd of
      Bool x =&amp;gt; if x then eval thn else eval els
    | _ =&amp;gt; raise Type

fun evalPlus x y =
  case (eval x, eval y) of
      (Int x&#39;, Int y&#39;) =&amp;gt; Int(x&#39; + y&#39;)
    | _  =&amp;gt; raise Type

fun evalEqual x y =
  case (eval x, eval y) of
      (Int x&#39;, Int y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
    | (Bool x&#39;, Bool y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
    | _  =&amp;gt; raise Type

fun eval exp =
  case exp of
      If(cnd, thn, els) =&amp;gt; evalIf cnd thn els
    | Plus(x, y) =&amp;gt; evalPlus x y
    | Equal(x, y) =&amp;gt; evalEqual x y
    | e =&amp;gt; e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この定義に従うと次のような自明に間違ったプログラムもコンパイルを通ってしまいます&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;mkEqual (mkInt 1) (mkBool false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;勿論、評価するとエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;eval (mkEqual (mkInt 1) (mkBool false));

uncaught exception Type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こういうものを極力コンパイル時に発見出来ないかとうのがモチベーションです。因みにこのモチベーションは変な型変換を行わない言語なら動的型付き言語でも同じで、SBCLで&lt;code&gt;(+ 1 t)&lt;/code&gt;を評価するとちゃんとコンパイルエラーになります。&lt;/p&gt;

&lt;h1 id=&#34;問題の分析&#34;&gt;問題の分析&lt;/h1&gt;

&lt;p&gt;今回、&lt;code&gt;Int&lt;/code&gt;だとか&lt;code&gt;Bool&lt;/code&gt;だとかの型情報をタグ、つまり値として持たせました。しかしコンパイル時に値にはアクセス出来ません。コンパイル時にアクセスできるのは型です。ということでメタデータとして型を付与しましょう。&lt;/p&gt;

&lt;h1 id=&#34;幽霊型&#34;&gt;幽霊型&lt;/h1&gt;

&lt;p&gt;メタデータとして型を付けたのが幽霊型です。名前的に&lt;code&gt;&#39;a texp&lt;/code&gt;ではなく&lt;code&gt;&#39;a&lt;/code&gt;の部分が幽霊型なんですかね。&lt;/p&gt;

&lt;p&gt;使い方は割と分かりやすくて、&lt;code&gt;datatype&lt;/code&gt;に余計な型をつけます。この&lt;code&gt;&#39;a&lt;/code&gt;は使われていませんがメタデータなのでそういうもんです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype &#39;a texp = E of exp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、&lt;code&gt;mkXxx&lt;/code&gt; にも型を付けます。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;mkInt&lt;/code&gt;なら返り値はIntなので&lt;code&gt;&#39;a&lt;/code&gt;の部分にその情報を詰め込みます。今回は&lt;code&gt;int&lt;/code&gt;が宜しいようです。
毎回&lt;code&gt;E&lt;/code&gt;がつくのが面倒ですが我慢して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun mkInt x: int texp = E (Int x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mkBool&lt;/code&gt;も同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun mkBool x: bool texp = E (Bool x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次は&lt;code&gt;mkIf&lt;/code&gt;ですが、condにはBool型、thenとelseには同じ型が来て欲しいです。そして返り値というかこのIfを
evalした型はthenやelseと同じ型なのでこのような型になります。Ifに渡す為に一旦&lt;code&gt;E&lt;/code&gt;を剥がしてます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun mkIf (E cnd: &#39;b texp) (E thn: &#39;a texp) (E els: &#39;a texp): &#39;a texp = E (If(cnd, thn, els))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じように考えたら&lt;code&gt;mkPlus&lt;/code&gt;や&lt;code&gt;mkEqual&lt;/code&gt;も型付け出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun mkPlus (E x: int texp) (E y: int texp): int texp = E (Plus(x, y))
fun mkEqual (E x: &#39;a texp) (E y: &#39;a texp): bool texp = E (Equal(x, y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ以後は変更ありません。一応修正後のプログラムを載せると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype exp
  = Int of int
  | Bool of bool
  | If of exp * exp * exp
  | Plus of exp * exp
  | Equal of exp * exp

datatype &#39;a texp = E of exp

fun mkInt x: int texp = E (Int x)
fun mkBool x: bool texp = E (Bool x)
fun mkIf (E cnd: &#39;b texp) (E thn: &#39;a texp) (E els: &#39;a texp): &#39;a texp = E (If(cnd, thn, els))
fun mkPlus (E x: int texp) (E y: int texp): int texp = E (Plus(x, y))
fun mkEqual (E x: &#39;a texp) (E y: &#39;a texp): bool texp = E (Equal(x, y))

exception Type

fun evalIf cnd thn els =
  case eval&#39; cnd of
      Bool x =&amp;gt; if x then eval&#39; thn else eval&#39; els
    | _ =&amp;gt; raise Type

and evalPlus x y =
    case (eval&#39; x, eval&#39; y) of
        (Int x&#39;, Int y&#39;) =&amp;gt; Int(x&#39; + y&#39;)
      | _  =&amp;gt; raise Type

and evalEqual x y =
    case (eval&#39; x, eval&#39; y) of
        (Int x&#39;, Int y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
      | (Bool x&#39;, Bool y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
      | _  =&amp;gt; raise Type

and eval&#39; exp =
    case exp of
        If(cnd, thn, els) =&amp;gt; evalIf cnd thn els
      | Plus(x, y) =&amp;gt; evalPlus x y
      | Equal(x, y) =&amp;gt; evalEqual x y
      | e =&amp;gt; e

fun eval (E x) = eval&#39; x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。ユーザインターフェースレベルでの変更はありません。
さて、ということで先の式をもう一度評価してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkEqual (mkInt 1) (mkBool false);
stdIn:1.2-1.34 Error: operator and operand don&#39;t agree [tycon mismatch]
  operator domain: int texp
  operand:         bool texp
  in expression:
    (mkEqual (mkInt 1)) (mkBool false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんとエラーが出ました。楽しいですね。&lt;/p&gt;

&lt;h1 id=&#34;発展1-任意の型&#34;&gt;発展1 - 任意の型&lt;/h1&gt;

&lt;p&gt;任意の型を作る手段としてタグ1つ、引数無しのタグ付き共用体を使う方法があります。それを使った技が先のPDFに載ってます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype tcp = TCP
datatype udp = UDP
datatype &#39;a safe_socket = W of Word32.word

fun mkTCP ....
fun mkUDP ....
fun sendTCP ...
fun sendUPD ...
fun close ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように型安全に、そして&lt;code&gt;close&lt;/code&gt;のように可能なものはジェネリックにプログラムを書くことが出来ます。&lt;/p&gt;

&lt;h1 id=&#34;発展2-サブタイプ&#34;&gt;発展2 - サブタイプ&lt;/h1&gt;

&lt;p&gt;次のようにヒエラルキーがある場合の話です。面倒なので言語を縮小しますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype num
  = Int of int
  | Real of real

datatype exp
  = Num of num
  | Bool of bool
  | Plus of exp * exp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、こうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype num
  = Int of int
  | Real of real

datatype exp
  = Num of num
  | Bool of bool
  | Plus of exp * exp

datatype &#39;a tnum = N
datatype &#39;a texp = E of exp

exception Type

fun mkInt x: (int tnum texp) = E (Num  (Int x))
fun mkReal x: (real tnum texp) = E (Num (Real x))
fun mkBool x: (bool texp) = E (Bool x)


fun mkPlus (E x: &#39;a tnum texp) (E y: &#39;a tnum texp): &#39;a tnum texp =
  case (x, y) of
      (Num (Int x&#39;), Num (Int y&#39;)) =&amp;gt; E (Num (Int (x&#39; + y&#39;)))
    | (Num (Real x&#39;), Num (Real y&#39;)) =&amp;gt; E (Num (Real (x&#39; + y&#39;)))
    | _ =&amp;gt; raise Type  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;疲れてきたので説明省略しますが型パラメータを入れ子にしたら上手い具合にサブタイプの親子関係を表せるよねって話です。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;幽霊型を使うと値レベルの話を一部型レベルに持ち上げれる（ってことで良いのかな？）&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;どうしても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype &#39;a texp = E of exp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としている所の&lt;code&gt;E&lt;/code&gt;が気になりますね。型システム上必要っぽい(&lt;code&gt;type &#39;a texp = exp&lt;/code&gt;としてもダメだった)ので必要なコストだとは思うのですが
少くとも内部的にはゼロオーバーヘッドであって欲しいです。最適化で消せそうですが実際に消してる処理系はどれほどあるのでしょう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type &#39;a texp = exp&lt;/code&gt;でダメだった(型がミスマッチしてるのにコンパイルが通ってしまった)のも気になります。smlの&lt;code&gt;type&lt;/code&gt;ってただのエイリアスなんでしたっけ？&lt;/p&gt;

&lt;p&gt;若干のモヤモヤは残るものの一応幽霊型について知りました。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;因みにこのコードをSML#のREPLで評価すると返ってこなくなります。&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/24&#34;&gt;イシュー&lt;/a&gt;に上がってます。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>