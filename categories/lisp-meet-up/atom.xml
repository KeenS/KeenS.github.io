<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp meet up | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/lisp-meet-up/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-12-07T00:28:29+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[lisp meet up #22でLTしてきた]]></title>
    <link href="http://KeenS.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita/"/>
    <updated>2014-11-28T23:17:12+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita</id>
    <content type="html"><![CDATA[<p>κeenです。先日 Lisp Meet Up #22 でLTしてきたので報告です。</p>

<!-- more -->


<p>LTは事前に登録されたのが2件、私が当日17時くらいに登録したの1件で、参加は20人募集の内20人応募、20人参加と最近中々の人気を見せてます。</p>

<h1>Common Lispで高速なHTTPパーサーを書く(仮)</h1>

<p>LT1件目は深町さんより、「Common Lispで高速なHTTPパーサーを書く(仮)」。fast-httpを作ったときの話。</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/42153462" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/fukamachi/writing-a-fast-http-parser" title="Writing a fast HTTP parser" target="_blank">Writing a fast HTTP parser</a> </strong> from <strong><a href="//www.slideshare.net/fukamachi" target="_blank">fukamachi</a></strong> </div></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVARnhncWZpRFdUOWM/preview">動画</a></p>

<p><a href="http://blog.8arrow.org/entries/2014/10/23">深町さんのブログ</a>に書かれていることの他、fast-httpが高速になるまでの経緯や実装方針などの話もありました。</p>

<p>最初ベースにしたnode.jsのHTTPパーサ、http-parseは状態を持っていて、1文字読む毎に状態を保存していた。次にベースにしたpicohttpparseは状態を持たず、HTTPリクエストが全部届く前にパースを始めてしまった場合はあきらめて最初からパースするようにしていた。fast-httpは1行パースする毎に状態を保存するようにした。など。</p>

<p>もう一つ、http-parseは<code>while</code>ループの中に巨大な<code>case</code>文があって、現在の状態で<code>case</code>でディスパッチし、その節の中で読んだ文字に依って現在の状態を変え、またループで先頭に戻って状態に依ってディスパッチするという手法だったそうです。Common Lispの場合は<code>case</code>が全て<code>(cond ((eql ..) ....) ...)</code>に展開されて遅い<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>ので<code>while</code>と<code>case</code>じゃなくて<code>tagbody</code>と<code>goto</code>で実装したそうです。</p>

<p>この手法は一般にDirect(Navive) ThreadingだとかThreaded Codeだとか呼ばれています。主にバイトコードインタプリタを実装する時にバイトコードに依るディスパッチの部分で使われるようです。Rubyの解説が丁寧だったようなので参考資料として置いておきます。</p>

<p><a href="http://magazine.rubyist.net/?0008-YarvManiacs">Rubyist Magazine &ndash; YARV Maniacs 【第 3 回】 命令ディスパッチの高速化</a></p>

<p>会場からはアーキテクチャ依存の最適化はしないのかとの質問がありました。SBCLにはインラインアセンブラであるVOPなるものが存在するのでSIMD命令使えば、とかいう怖い話ですね。</p>

<h1>symbol tree diff</h1>

<p>LT2件目はchikuさんより「symbol tree diff」。chikuさんが以前から取り組んでいるプログラムのdiffを構文レベルでとる話の進捗。</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/42160384" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/samugari/symbol-treediff" title="Symbol tree-diff" target="_blank">Symbol tree-diff</a> </strong> from <strong><a href="//www.slideshare.net/samugari" target="_blank">samugari</a></strong> </div></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVARUoxVGtiMlFrRVU/preview">動画</a></p>

<p>diff自体はとれるようになったようですが見せ方に問題があり、見易い形式を模索中のようです。会場に見易い形式は何か投げ掛けましたが良い案を見付けるのは難しいようです。</p>

<h1>Semantic S式</h1>

<p>私から「Semantic S式」。括弧が多い方が嬉しいこともあるよねーというゆるい話。
<a href="http://keens.github.io/slide/semantic-sshi.html">Semantic S式 | κeenのHappy Hacκing Blog</a></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVAQms2QkZDcnZfVlU/preview">動画</a></p>

<p>会場からは半分同意、半分ツッコみたいとの反応が。plistをリテラルから<code>getf</code>するやついないだろ、とか。</p>

<h1>懇親会</h1>

<p>私の発表で21時あたりだったのでそのまま解散して懇親会。隣にLand of Lispを読んでLispに興味持ってLispの授業をとってる方がいたのでどの本が入門に良いかなど。</p>

<p>VOPの話の続きもしました。どうしても資料がないのがネックだよねー、と。私の知っているのは</p>

<p><a href="http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/">How to Define New Intrinsics in SBCL &ndash; Paul Khuong mostly on Lisp</a></p>

<p>や</p>

<p><a href="http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html">Hacking SSE Intrinsics in SBCL (part 1) &ndash; Paul Khuong mostly on Lisp</a></p>

<p>かな。日本語のやってみた系だとg1さんの</p>

<p><a href="http://g000001.cddddr.org/2011-12-08">#:g1: SBCLでVOPを使ってみよう</a></p>

<p>あたり。</p>

<h1>その他</h1>

<p>テンプレートエンジンを作ってるって以前深町さんに話してたら「まだ出来ないんですか？」とさんざん煽られました。はい。頑張ります。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><code>cond</code>は先頭から順番に比較する仕様です。<code>case</code>は<code>cond</code>に展開されることが仕様で定められていた筈。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Semantic S式]]></title>
    <link href="http://KeenS.github.io/slide/semantic-sshi.html"/>
    <updated>2014-11-27T15:30:00+09:00</updated>
    <id>http://KeenS.github.io/slide/semantic-sshi.markdown</id>
    <content type="html"><![CDATA[<h1>Semantic S式</h1>

<hr />

<p>2014-11-27<br/>
κeen(@blackenedgold)</p>

<h1>About Me</h1>

<hr />

<p><img src="/images/icon.png" alt="κeenのアイコン" /></p>

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
</ul>


<h1>Semantic Web とは</h1>

<h1><a href="http://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A6%E3%82%A7%E3%83%96">Semantic Web</a></h1>

<hr />

<ul>
<li>W3C のティム・バーナーズ＝リーが提唱</li>
<li>文章の見た目を記述するんじゃなくて構造を記述しよう</li>
<li>そうすると機械がクローリングするの楽になるよね</li>
</ul>


<h1>Semantic S式とは</h1>

<h1>Semantic S式</h1>

<hr />

<ul>
<li>Shibuya.lispのκeenが提唱 (昨日思い付いた)</li>
<li>S式の見た目じゃなくて構造で括弧をつけよう</li>
<li>そうするとコーディングが楽になるよね</li>
</ul>


<h1>良いところ</h1>

<hr />

<ol>
<li>意味が分かり易い</li>
<li>パースし易い</li>
<li>編集が楽になる</li>
<li>壊れにくい</li>
</ol>


<h1>1. 意味が分かり易い</h1>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例1</h2>

<ul>
<li><p>Clojure
<code>clojure
(let [a 1
      b 2]
  ...)
</code></p></li>
<li><p>Common Lisp
<code>lisp
(let ((a 1)
      (b 2))
  ....)
</code>
どっちが分かり易い？</p></li>
</ul>


<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例1</h2>

<p>（日本語にしてみる（イメージ））</p>

<ul>
<li>Clojure<br/>
aを1bを2とする</li>
<li>Common Lisp
<table border="1"><tr><td><code>a</code></td><td>1</td></tr><tr><td><code>b</code></td><td>2</td></tr></table>
とする</li>
</ul>


<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例2</h2>

<p>何をしてる？</p>

<p>```lisp
(destructuring-bind (a b)</p>

<pre><code>(some-function)
</code></pre>

<p>  &hellip;)
```</p>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例2</h2>

<p>何をしてる？</p>

<p>```lisp
(destructuring-bind ((a b)</p>

<pre><code>(some-function))
</code></pre>

<p>  &hellip;)
```</p>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例3</h2>

<p>これの返り値は？
<code>lisp
(getf '(:hoge :foo :huga :baz :piyo :pon :chun) :pon)
</code></p>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例3</h2>

<p>これの返り値は？
<code>lisp
(assoc :pon '((:hoge :foo) (:huga :baz) (:piyo :pon) (:chun)))
</code></p>

<h1>2. パースし易い</h1>

<h1>2. パースし易い</h1>

<hr />

<h2>例</h2>

<ul>
<li><p>Clojure
<code>clojure
(let [a 1
      b 2]
  ...)
</code></p></li>
<li><p>Common Lisp
<code>lisp
(let ((a 1)
      (b 2))
  ....)
</code>
どっちが実装し易い？</p></li>
</ul>


<h1>2. パースし易い</h1>

<hr />

<ul>
<li>Common Lispの方は意味で分割してある</li>
<li>括弧は無くてもパースは出来る</li>
<li>機械にパースし易い≒人間にパースし易い</li>
</ul>


<h1>3. 編集が楽になる</h1>

<h1>3. 編集が楽になる</h1>

<hr />

<h2>前提</h2>

<ul>
<li>エディタに文/式/トークン(Lispの場合は全てS式)単位の編集機能がある

<ul>
<li>S式単位でカーソル移動</li>
<li>S式単位の削除/カット</li>
<li>S式単位のスワップ</li>
<li>etc&hellip;.</li>
</ul>
</li>
</ul>


<h1>3. 編集が楽になる</h1>

<hr />

<h2>例（偶によくある）</h2>

<p>この<code>c</code>の束縛を上のletに持っていきたいときどうする？</p>

<p>```lisp
(let ((a 1)</p>

<pre><code>  (b 2))
</code></pre>

<p>  &hellip;.
  (let ((c 3)</p>

<pre><code>    (d 4))
...))
</code></pre>

<p>```</p>

<h1>3. 編集が楽になる</h1>

<hr />

<h2>例（偶によくある）</h2>

<ul>
<li>意味で括弧をつけていれば1カット移動1ペースト</li>
<li>Clojure方式だと2カット移動1ペースト</li>
<li><code>c</code>だけじゃなくて<code>d</code>も、と考えると…</li>
</ul>


<h1>4. 壊れにくい</h1>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>ageの計算が壊れているとする</p>

<p><code>lisp
(:name "κeen"
 :age  (year-of-time-interval (date- (today) (date 1992 5 17)))
 :place "Shibuya")
</code></p>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>コメントアウトしてみる（壊れた）</p>

<p><code>lisp
(:name "κeen"
 :age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 :place "Shibuya")
</code></p>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>ageの計算が壊れているとする</p>

<p><code>lisp
((:name "κeen")
 (:age  (year-of-time-interval (date- (today) (date 1992 5 17))))
 (:place "Shibuya"))
</code></p>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>(エディタサポートあり)</p>

<p>コメントアウトしてみる（壊れない）</p>

<p><code>lisp
((:name "κeen")
 (:age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 )
 (:place "Shibuya"))
</code></p>

<h1>ここまでのまとめ</h1>

<hr />

<ul>
<li>構造が文脈に依存していると

<ul>
<li>人間に分りづらい</li>
<li>プログラムに分りづらい</li>
<li>エディタに分りづらい</li>
<li>壊れやすい</li>
</ul>
</li>
</ul>


<h1>Q. When Semantic?</h1>

<hr />

<h2>A. 言語を設計するとき <!-- .element: class="fragment" data-fragment-index="1" --></h2>

<ul>
<li>つまりマクロを書くとき <!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>


<h1>Q. When Semantic?</h1>

<hr />

<h2>A. 言語を設計するとき</h2>

<ul>
<li>マクロを書くときそれなりのDSLを設計する</li>
<li>プログラム上は必須ではない括弧もあった方が良いときもある</li>
</ul>


<h1>まとめ</h1>

<hr />

<ul>
<li>括弧が少ない方が書き易いとは限らない

<ul>
<li>「書く」だけなら速くてもwrite onlyになってしまうかも<!-- .element: class="fragment" data-fragment-index="1" --></li>
</ul>
</li>
<li>プログラムの意味を考えながら括弧つけよう

<ul>
<li>Lisperはどうせ括弧は見えない<!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>
</li>
</ul>


<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[claspを少し触ってみた]]></title>
    <link href="http://KeenS.github.io/slide/clasp.html"/>
    <updated>2014-10-28T16:17:00+09:00</updated>
    <id>http://KeenS.github.io/slide/clasp.markdown</id>
    <content type="html"><![CDATA[<h1>claspを少し触ってみた</h1>

<hr />

<p>Lisp Meet Up presented by Shibuya.lisp #21<br/>
2014-10-29<br/>
κeen(@blackenedgold)</p>

<h1>About Me</h1>

<hr />

<p><img src="/images/icon.png" alt="κeenのアイコン" /> <!-- .element: style="position:relative;right 0;" --></p>

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
</ul>


<h1>clasp</h1>

<hr />

<ul>
<li>Github: <a href="https://github.com/drmeister/clasp">drmeister/clasp</a></li>
<li>2014-09-18に0.1リリース(現在0.11プレビューが出ている)</li>
<li>今は0.11プレビューが出ている</li>
<li>ANSI Common Lisp準拠を目指す(現在80 ~90%)</li>
<li>ECLからのフォーク</li>
<li>LLVMベースのJIT(<a href="http://llvm.org/docs/MCJITDesignAndImplementation.html">MCJIT</a>)搭載</li>
<li>C++とLispで書かれている</li>
<li>C++との連携を意識</li>
</ul>


<p>Note:
C++との連携の部分を強調。今回は0.11プレビューでの話</p>

<h1>メモリ管理</h1>

<hr />

<ul>
<li>Memory Pool Systemと Boehm GCから選べる</li>
<li>ビルドするときにどっちかを選ぶ</li>
</ul>


<h1>メモリ管理</h1>

<hr />

<h2><a href="http://www.hboehm.info/gc/">Boehm GC</a></h2>

<ul>
<li>Mark &amp; Sweepのライブラリ</li>
<li>枯れた有名なライブラリ</li>
<li>Lisp有名どころではGaucheが使う</li>
<li>RedHat系だとこれを使ってないとrpmリジェクトされやすいらしい(?)</li>
</ul>


<p>Note:
他にはMozilla, W3M, GNU GCJ, GNU Obj-Cなどなど</p>

<h1>メモリ管理</h1>

<hr />

<h2><a href="http://www.ravenbrook.com/project/mps/">Memory Pool System</a></h2>

<ul>
<li>複数のGCアルゴリズムを組み合わせて使えるらしい</li>
<li>since 1994</li>
<li>あまり分からないです&gt;&lt;</li>
</ul>


<h1>依存ライブラリ</h1>

<hr />

<ul>
<li>LLVM <strong>3.6</strong></li>
<li>LLVM/clang <strong>3.5</strong> compiler</li>
<li>Boost build v2</li>
<li>boost libraries ver 1.55</li>
<li>Boehm 7.2</li>
<li>gmp-6.0.0</li>
<li>expat-2.0.1</li>
<li>zlib-1.2.8</li>
<li>readline-6.2</li>
</ul>


<p><span style="font-size:600%">無理</span></p>

<h1>externals-clasp</h1>

<hr />

<ul>
<li>Github: <a href="https://github.com/drmeister/externals-clasp">drmeister/externals-clasp</a></li>
<li>依存ライブラリを揃えるのが難しいとの声から作られた</li>
<li>依存ライブラリを全てビルド<!-- .element: class="fragment grow" --></li>
</ul>


<p><span style="font-size:300%">＼LLVMをビルド／</span></p>

<p><span style="font-size:300%">＼Boostをビルド／</span></p>

<p><span style="font-size:200%">ビルド時間はお察しです</span></p>

<h1>本体のビルド</h1>

<hr />

<p>Twitter実況をどうぞ↓↓</p>

<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>clangがメモリ6GB以上食い続けてて怖い。何やってんの。</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526417151486205952">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>clangの起動時間1時間超えてますよ…</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526418636735401984">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>HDDプチプチ言ってるし今にも壊れそう</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526420001587068929">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/nobkz">@nobkz</a> claspのコンパイル中です。&#10;clangなのにIOネックという謎の状態です。</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526420473232367616">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>clangの消費メモリ7GB超えた</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526423982992420864">2014, 10月 26</a></blockquote>


<p><span style="font-size:300%">ビルドは自己責任で</span></p>

<h1>使ってみる</h1>

<hr />

<h2>起動オプション</h2>

<p><code>
/usr/local/clasp/bin/clasp_mps_o --help
clasp options
-I/--ignore-image    - Don't load the boot image/start with init.lsp
-i/--image file      - Use the file as the boot image
-N/--non-interactive - Suppress all repls
-v/--version         - Print version
-s/--verbose         - Print more info while booting
-f/--feature feature - Add the feature to *features*
-e/--eval {form}     - Evaluate a form
-l/--load {file}     - LOAD the file
-r/--norc            - Don't load the ~/.clasprc file
-n/--noinit          - Don't load the init.lsp (very minimal environment)
-s/--seed #          - Seed the random number generator
-- {ARGS}*           - Trailing are added to core:*command-line-arguments*
</code></p>

<h1>使ってみる</h1>

<hr />

<h2>ASDF</h2>

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->動かない

<ul>
<li><!-- .element: class="fragment" data-fragment-index="2" -->ASDFの処理系依存の部分(<code>#+</code>)の問題</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->ECLと見做されるけどECLのコードは動かない</li>
</ul>
</li>
</ul>


<h1>使ってみる</h1>

<hr />

<h2>cl-ppcre</h2>

<ul>
<li><a href="https://gist.github.com/KeenS/4e25cb6e424ebe4e7a4a">手動ロードスクリプト</a></li>
<li><!-- .element: class="fragment" data-fragment-index="1" -->動かない

<ul>
<li><!-- .element: class="fragment" data-fragment-index="2" --><code>schar</code>がない</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->ANSI Common Lispにあるのに…</li>
</ul>
</li>
</ul>


<h1>使ってみる</h1>

<hr />

<h2>C++との連携</h2>

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->ドキュメントがない</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->サンプルコードもない</li>
<li><!-- .element: class="fragment" data-fragment-index="3" -->遂行不能</li>
</ul>


<h1>使ってみる</h1>

<hr />

<h2>LLVMの呼び出し</h2>

<ul>
<li><a href="https://github.com/drmeister/clasp/blob/master/src/llvmo/demo.lsp">clasp/src/llvmo/demo.lisp</a></li>
<li><!-- .element: class="fragment" data-fragment-index="1" -->動かない</li>
</ul>


<h1>使ってみる</h1>

<hr />



<table>
<thead>
<tr>
<th>処理系              </th>
<th>  <code>(time (fib 29))</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>clasp-0.1(boehm)    </td>
<td> <div class="graph fragment" style="width:calc(264.3px * 3);" data-fragment-index="1">26.43s</div></td>
</tr>
<tr>
<td>clasp-0.1(mps)      </td>
<td> <div class="graph fragment" style="width:calc(172.8px * 3);" data-fragment-index="1">17.28s</div></td>
</tr>
<tr>
<td>clasp-0.11(boehm)   </td>
<td> <div class="graph fragment" style="width:calc(213.2px * 3);" data-fragment-index="2">21.32s</div></td>
</tr>
<tr>
<td>clasp-0.11(mps)     </td>
<td> <div class="graph fragment" style="width:calc(187.9px * 3);" data-fragment-index="2">18.79s</div></td>
</tr>
<tr>
<td>ECL-13.5.1          </td>
<td> <div class="graph" style="width:calc( 16.0px * 3);">1.603s</div></td>
</tr>
<tr>
<td>ECL-13.5.1(compile) </td>
<td> <div class="graph" style="width:calc(  1.9px * 3);">0.192s</div></td>
</tr>
<tr>
<td>ABCL-1.3.1          </td>
<td> <div class="graph" style="width:calc( 32.9px * 3);">3.292s</div></td>
</tr>
<tr>
<td>ABCL-1.3.1(compile) </td>
<td> <div class="graph" style="width:calc(  2.4px * 3);">0.241s</div></td>
</tr>
</tbody>
</table>


<h1>使ってみる</h1>

<hr />

<table>
<thead>
<tr>
<th>処理系              </th>
<th>  <code>(time (fib 29))</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>CLISP-2.49          </td>
<td> <div class="graph" style="width:calc( 38.4px * 3);">3.847s</div></td>
</tr>
<tr>
<td>CLISP-2.49(compile) </td>
<td> <div class="graph" style="width:calc(  7.1px * 3);">0.7146s</div></td>
</tr>
<tr>
<td>ccl-1.10            </td>
<td> <div class="graph" style="width:calc(  0.4px * 3);">0.04033s</div></td>
</tr>
<tr>
<td>sbcl-1.2.5          </td>
<td> <div class="graph" style="width:calc(  0.6px * 3);">0.06469s</div></td>
</tr>
<tr>
<td>alisp-9.0           </td>
<td> <div class="graph" style="width:calc(  230px * 3);">23.09s</div></td>
</tr>
<tr>
<td>alisp-9.0(compile)  </td>
<td> <div class="graph" style="width:calc(  0.6px * 3);">0.06194s</div></td>
</tr>
</tbody>
</table>


<p><span style="font-size:200%">LLVM/JITなのになぜ遅い？</span></p>

<h1>LLVM/JITで遅い？</h1>

<hr />

<ul>
<li>LLVMって速いんじゃ？</li>
<li>JIT搭載した○○が速いって聞いたよ

<ul>
<li>JVM</li>
<li>lua-jit</li>
<li>Rubinius</li>
<li>pypy</li>
</ul>
</li>
</ul>


<h1>言葉の罠: LLVM</h1>

<hr />

<ul>
<li>遅いコードはどんなに頑張っても遅い</li>
<li>ECLのバックエンドにClang(=LLVM)を使ってもSBCLに勝てないのと同じ</li>
</ul>


<h1>言葉の罠: JIT搭載</h1>

<hr />

<ul>
<li>JIT(実行時コンパイル)の意味は広い</li>
<li>実行時にネイティブコードを吐けばJITと言える</li>
<li>claspは実行直前にコンパイルするだけ</li>
<li>多くの速いJIT処理系はTracing JITを使う

<ul>
<li>またの名を適応的コンパイル</li>
<li>実行時の情報に基いて実行中に最適化する</li>
<li><code>(declare ...)</code> を自動生成してる的な</li>
</ul>
</li>
</ul>


<h1>Tracing JITへの道</h1>

<hr />

<ul>
<li>LLVMのJITは実行直前にコンパイルするだけ

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->Tracing JITのバックエンドには使える</li>
</ul>
</li>
<li>実行時最適化には最適化用のコードが必要

<ul>
<li><!-- .element: class="fragment" data-fragment-index="2" -->Common Lispでは<code>(declare ...)</code>用のコードを使い回せる</li>
</ul>
</li>
<li><!-- .element: class="fragment" data-fragment-index="3" -->案外近い</li>
</ul>


<h1>結論</h1>

<hr />

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->遅い</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->時期尚早</li>
<li><!-- .element: class="fragment" data-fragment-index="3" -->今後機能や速度改善があれば使えるようになるかも</li>
</ul>


<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lisp Meet Up #20でLTしてきました]]></title>
    <link href="http://KeenS.github.io/blog/2014/09/30/lisp-meet-up-number-20/"/>
    <updated>2014-09-30T09:35:05+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/09/30/lisp-meet-up-number-20</id>
    <content type="html"><![CDATA[<p>κeenです。lisp meet up # 20に参加したのでレポートです。</p>

<!-- more -->


<p>20人の募集に19人参加予定。会場は今回初めてのところでした。</p>

<h1>LT</h1>

<p>LTはTOYOZUMIさんが仕事で来れなくなったので私の1件のみ。内容はpicrinのチューニングの話と思わせてほとんどがその前振りのGCの話。</p>

<p>スライドはこちら。</p>

<p><a href="http://keens.github.io/slide/picrin-gc.html">Picrinのチューニングの話、もといGCの話 | κeenのHappy Hacκing Blog</a></p>

<p>TOYOZUMIさんのdocstringの話聞きたかった</p>

<h2>飛び入り</h2>

<ul>
<li>ブラウザ上でbiwa schemeの環境(REPLだけでなくオートインデントとか)を作ってる</li>
<li>関連して、websocketでswankと対話できるやつ作ってる</li>
<li>関連して、ブラウザ上で動くLispに似てそうなBlockyというヴィジュアル言語がある
なんかの話がありました。</li>
</ul>


<h1>余った時間</h1>

<p>chikuさんが前でGCの話してました。んで話が尽きたあたりで私がpicrinの宣伝しました。<code>(picrin control list)</code>の話です。非同期プロミス然りpicrinにはトリッキーな機能が多いですね。</p>

<p>結局ライブコーディングはしませんでしたね。</p>

<h1>懇親会</h1>

<p>Raspberry Piの話とかちょいとGCの話とかVarnishの話とかaltJSとか。ブログの話題が出たのでOctopress推しといたり。なんでみんなGithub Pages + Octopress使わないん？便利ですやん。</p>

<p>結構色々話してた気がするんですが覚えてないですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Picrinのチューニングの話、もといGCの話]]></title>
    <link href="http://KeenS.github.io/slide/picrin-gc.html"/>
    <updated>2014-09-29T14:37:00+09:00</updated>
    <id>http://KeenS.github.io/slide/picrin-gc.markdown</id>
    <content type="html"><![CDATA[<h1>Picrinのチューニングの話、もといGCの話</h1>

<hr />

<p>Lisp Meet Up presented by Shibuya.lisp #20<br/>
2014-09-29<br/>
κeen(@blackenedgold)</p>

<h1>自己紹介</h1>

<hr />

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
<li><a href="https://github.com/picrin-scheme/picrin">picrin</a>のコミッタです</li>
</ul>


<h1>picrin</h1>

<hr />

<p><img src="/images/picrin/picrin-logo-fin01-02.png" alt="picrin" /></p>

<h1>picrin</h1>

<hr />

<ul>
<li>R7RS compatibility</li>
<li>bytecode interpreter (based on stack VM)</li>
<li>internal representation by nan-boxing</li>
<li>conservative call/cc implementation (users can freely interleave native stack with VM stack)</li>
<li>exact GC (simple mark and sweep, partially reference count is used as well)</li>
<li>string representation by rope data structure</li>
</ul>


<h1>picrin</h1>

<hr />

<ul>
<li>R7RS compatibility</li>
<li><strong>bytecode interpreter (based on stack VM)</strong></li>
<li>internal representation by nan-boxing</li>
<li>conservative call/cc implementation (users can freely interleave native stack with VM stack)</li>
<li><strong>exact GC (simple mark and sweep, partially reference count is used as well)</strong></li>
<li><strong>string representation by rope data structure</strong></li>
</ul>


<h1>picrin開発者の不満</h1>

<hr />

<ul>
<li>picrinの起動が遅い<!-- .element: class="fragment" data-fragment-index="1" -->

<ul>
<li>2秒くらいかかる <!-- .element: class="fragment" data-fragment-index="1" --></li>
</ul>
</li>
<li>picrinのテストが遅い<!-- .element: class="fragment" data-fragment-index="2" -->

<ul>
<li>16秒くらいかかる <!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>
</li>
</ul>


<h1>少しGCの話</h1>

<hr />

<p>GC(ごみ集め)とは</p>

<ul>
<li>使われていないオブジェクトを自動的に解法する

<ul>
<li>メモリ管理に煩わせられないで済む</li>
<li>メモリーリークを防ぐ。</li>
</ul>
</li>
<li>「使われていないオブジェクト」を判定するのはいくつかアルゴリズムがある</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>主なGCのアルゴリズム</h2>

<ul>
<li>マーク&amp;スイープ</li>
<li>参照カウント</li>
<li>Copying GC</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>マーク&amp;スイープ</h2>

<ol>
<li>あらかじめ全てのオブジェクトはどこかで一元管理する<!-- .element: class="fragment" data-fragment-index="1" --></li>
<li>一元管理元(ヒープ(ページ))でメモリが足りなくなったらGCを開始<!-- .element: class="fragment" data-fragment-index="2" --></li>
<li>スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする<!-- .element: class="fragment" data-fragment-index="3" --></li>
<li>そこから辿れるオブジェクトも再帰的にマークする<!-- .element: class="fragment" data-fragment-index="4" --></li>
<li>ヒープからマークされていないオブジェクトを開放する<!-- .element: class="fragment" data-fragment-index="5" --></li>
<li>それでもメモリが足りなければ一ヒープのページを増やす<!-- .element: class="fragment" data-fragment-index="6" --></li>
<li>増やせなければメモリを使い果したのでabort<!-- .element: class="fragment" data-fragment-index="7" --></li>
</ol>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>マーク&amp;スイープの特徴</h2>

<ul>
<li>そこそこ速い</li>
<li>正確に集められる</li>
<li>GC以外ではメモリ管理を考えなくて良い(≒プラグインは書き易い)</li>
<li>長生きのオブジェクトは何度もマークされる(=>世代別GC)</li>
<li>負荷は1点に集中する</li>
<li>メモリの断片化が起きる(=オブジェクトのアロケートが遅くなる)</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>参照カウント</h2>

<ol>
<li>オブジェクトに他から参照されている数(参照カウント)を記憶させる<!-- .element: class="fragment" data-fragment-index="1" --></li>
<li>オブジェクトの参照を変えるときはその都度参照カウントを変える<!-- .element: class="fragment" data-fragment-index="2" --></li>
<li>参照カウントが0になったら開放する<!-- .element: class="fragment" data-fragment-index="3" --></li>
</ol>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>参照カウントの特徴</h2>

<ul>
<li>負荷は分散する</li>
<li>GCの実装は楽</li>
<li>少し遅い(必ずfreeする必要がある)</li>
<li>正確でない(循環参照に弱い)(cf. 大相撲の星の回しあい)</li>
<li>プラグインは面倒</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>Copying GC</h2>

<ol>
<li>オブジェクトプールを2つ用意する(1, 2)とする<!-- .element: class="fragment" data-fragment-index="1" --></li>
<li>オブジェクトを確保するときは必ず1に確保する<!-- .element: class="fragment" data-fragment-index="2" --></li>
<li>1のメモリが足りなくなったらgcを開始<!-- .element: class="fragment" data-fragment-index="3" --></li>
<li>1の生きているオブジェクトを再帰的に2に移動する<!-- .element: class="fragment" data-fragment-index="4" --></li>
<li>1に残っているものは全てゴミとして良い<!-- .element: class="fragment" data-fragment-index="5" --></li>
<li>1、2のラベルを付け換える<!-- .element: class="fragment" data-fragment-index="6" --></li>
</ol>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>Copying GCの特徴</h2>

<ul>
<li>正確</li>
<li>メモリの断片化が起きない(Windowsのデフラグ)(=アロケートが速くなる)</li>
<li>負荷は1点に集中する</li>
<li>遅い(オブジェクトの移動が必要)</li>
<li>メモリ食う(オブジェクトプール2つ分)</li>
<li>ポインタも変わるため、ハッシュの再計算などが必要</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>GCの主な属性</h2>

<ul>
<li>世代別

<ul>
<li>新しいオブジェクトだけGCの対象にする<!-- .element: class="fragment" data-fragment-index="1" --></li>
</ul>
</li>
<li>正確

<ul>
<li>ゴミは必ず回収する<!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>
</li>
<li>インクリメンタル

<ul>
<li>一度にやらずに少しづつGCを進める<!-- .element: class="fragment" data-fragment-index="3" --></li>
</ul>
</li>
</ul>


<h1>picrinのGC</h1>

<hr />

<p><img src="/images/picrin/picrin-logo-fin01-02.png" alt="picrin" /></p>

<h1>picrinのGC</h1>

<hr />

<ul>
<li>基本は普通の正確なマーク&amp;スイープ

<ul>
<li>Copying GCはlightweightでない</li>
</ul>
</li>
<li>ropeには参照カウント

<ul>
<li>ropeには循環参照が起きない</li>
</ul>
</li>
</ul>


<h1>picrinのGC</h1>

<hr />

<ul>
<li>基本はマーク&amp;スイープ</li>
</ul>


<blockquote><ol>
<li>スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする</li>
</ol>
</blockquote>

<ul>
<li>schemeの変数はそのまま</li>
<li>Cの変数は読めないのでアリーナという場所を用意してC内ではそこに一時保管してもらう

<ul>
<li>スコープはFILOなのでスタックを用いればヒープより速くアロケート出来る</li>
</ul>
</li>
</ul>


<h1>picrinのチューニング</h1>

<h2>プロファイルをとってみる</h2>

<hr />

<p><code>
 % cumulative self self total
time seconds seconds calls s/call s/call name
37.14 0.78 0.78 13136494 0.00 0.00 XROPE_DECREF
23.81 1.28 0.50 1544 0.00 0.00 gc_sweep_phase
15.72 1.61 0.33 59344814 0.00 0.00 gc_mark_object
10.00 1.82 0.21 1544 0.00 0.00 gc_mark_phase
6.67 1.96 0.14 1544 0.00 0.00 gc_mark_trie
2.38 2.01 0.05 6523 0.00 0.00 pic_apply
</code></p>

<p><span style="font-size:200%">ほとんどGCですね。<br/>
本当にありがとう御座いました。</span></p>

<h1>解決案</h1>

<hr />

<ul>
<li>GCのアルゴリズムを変える</li>
<li>オブジェクトをアロケートしないようにする</li>
<li>パラメーターをいじる</li>
</ul>


<h1>解決案</h1>

<hr />

<ul>
<li>GCのアルゴリズムを変える</li>
<li>オブジェクトをアロケートしないようにする</li>
<li><strong>パラメーターをいじる</strong></li>
</ul>


<h1>GCに関連するパラメータ</h1>

<hr />

<p>元々tinyに設計されている
```C
/<em> アリーナのサイズ </em>/</p>

<h1>define PIC_ARENA_SIZE 1000</h1>

<p>/<em> ヒープページのサイズ </em>/</p>

<h1>define PIC_HEAP_PAGE_SIZE 10000</h1>

<p>/<em> シンボルプール(ハッシュ)のサイズ </em>/</p>

<h1>define PIC_SYM_POOL_SIZE 128</h1>

<p>```</p>

<h1>GCに関連するパラメータ</h1>

<hr />

<p>チューニング後
```C
/<em> アリーナのサイズ </em>/</p>

<h1>define PIC_ARENA_SIZE 8 * 1024</h1>

<p>/<em> ヒープページのサイズ </em>/</p>

<h1>define PIC_HEAP_PAGE_SIZE 2 * 1024 * 1024</h1>

<p>/<em> シンボルプール(ハッシュ)のサイズ </em>/</p>

<h1>define PIC_SYM_POOL_SIZE 2048</h1>

<p>```</p>

<h1>結果</h1>

<hr />

<ul>
<li><p>昔</p>

<blockquote><p>テストに16秒</p></blockquote></li>
<li><p>変更後</p>

<blockquote><p>time make test-r7rs<br/>
make test-r7rs  <strong>1.68s</strong> user 0.23s system 98% cpu 1.931 total
<!-- .element: class="fragment" data-fragment-index="1" --></p></blockquote></li>
</ul>


<h1>今後</h1>

<hr />

<ul>
<li>GCのアルゴリズムを変える</li>
<li>世代別GCにしたいよねー</li>
<li>そもそもマーク&amp;スイープの実装が適当すぎるだとか。協議中。</li>
<li>組み込み目指すならインクリメンタル性必要では？</li>
<li>オブジェクトをアロケートしないようにする

<ul>
<li>バイトコンパイルするときにもめちゃくちゃアロケートしてる。その辺どうにかする。</li>
<li><a href="https://github.com/picrin-scheme/picrin/pull/207">Fast Reader</a></li>
</ul>
</li>
</ul>


<h1>まとめ</h1>

<hr />

<ul>
<li>基本的なGCの解説をした</li>
<li>picrinのGCの戦略を話した</li>
<li>GCチューニング大事</li>
</ul>


<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
</feed>
