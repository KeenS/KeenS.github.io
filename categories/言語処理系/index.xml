<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>言語処理系 on κeenのHappy Hacκing Blog</title>
    <link>/categories/%E8%A8%80%E8%AA%9E%E5%87%A6%E7%90%86%E7%B3%BB/</link>
    <description>Recent content in 言語処理系 on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 24 May 2016 23:40:36 +0900</lastBuildDate>
    <atom:link href="/categories/%E8%A8%80%E8%AA%9E%E5%87%A6%E7%90%86%E7%B3%BB/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>DOT/dottyについて調べてみた</title>
      <link>/slide/DOT_dottynitsuiteshirabetemita/</link>
      <pubDate>Tue, 24 May 2016 23:40:36 +0900</pubDate>
      
      <guid>/slide/DOT_dottynitsuiteshirabetemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# DOT/dottyについて調べてみた
----------------------
サイバーエージェント Scala Meet Up  
2016-05-27

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + Scala初心者
   + Scala歴1年未満&amp;gt;&amp;lt;

===
# Scalaコンパイラ
----------------

* 型推論（特にimplicit）が遅い
* コンパイルフェーズが多い
  + 中間オブジェクトが多くて遅くなる
* 多くのクラスファイルを生成する
  + コンパイラのくせにディスクIOが多い
* 気を抜いてると `Any` に推論される  
  e.g.) `if(x) 1 else &#34;a&#34;`
* そもそものScalaの設計に起因する点が多い
  + 抜本的変更が必要

===
# Scala基礎
-----------

* Scalaが成立するのに最低限必要な機能って？
  + e.g.) `case class` はなくても `class` だけでどうにかなる
* 「最低限の機能」を減らせばコンパイラがシンプルになる
  + 他の機能はただのシンタックスシュガーになる
  + コンパイラのバグを減らせる
  + 機能追加時の矛盾確認が楽
* コア言語

===
# Featherlight Scala
---------------------

* Scalaのシンタックスシュガーを減らした感じ
* 小さな言語
* 元のScalaはこれをベースに議論されてきた

===
# 形式言語理論
-------------

* 最低限必要な機能を形式的にモデル化
  + 全ての動作は予め決められた「規則」に基く
  + 実際に書いて動かすものではない
* 形式的にすることで「証明」とかが出来る
  + 「型検査に通れば実行時に型エラーが起きない」
  + 「型検査が必ず終了する」
* 逆に、「このモデルだとこの機能は実現出来ない」とかも分かる

===
# Dependent Object Type
------

* Scalaのコアをモデル化したもの（要出典）
* 形式言語
* ジェネリクスもなければクラスも継承もない、パッケージもない。
* 小さい言語ながら表現力豊か
* 全ての値はオブジェクト。
  + オブジェクトのフィールドとメソッドと型メンバーだけ
  + 型はそのまま
* Path Dependent Type
* サブタイピング


===
# About DOT
---------

* 型付の健全性が証明された
* System F&lt;:より強力
  * System F&lt;: -&gt; System D&lt;: -&gt; DOT
* existential typeを自然に表現出来る
* 交差型と合併型
  + `A extends B` -&gt; `A &amp; B`
  + 合併型は主に型推論の結果に出てくる

===
```scala
package scala.collection.immutable trait List[+A] {
  def isEmpty: Boolean; def head: A; def tail: List[A]
}
object List {
  def nil: List[Nothing] = new List[Nothing] {
    def isEmpty = true; def head = head; def tail = tail /* infinite loops */
  }
  def cons[A](hd: A, tl: List[A]) = new List[A] {
    def isEmpty = false; def head = hd; def tail = tl
  }
}
```

===
```scala
object scala_collection_immutable { sci =&gt;
  trait List { self =&gt;
    type A
    def isEmpty: Boolean
    def head: self.A def
      tail: List{type A &lt;: self.A}
  }
  def nil: sci.List{type A = Nothing} = new List{ self =&gt;
    type A = Nothing
    def isEmpty = true
    def head: A = self.head
    def tail: List{type A = Nothing} = self.tail
  }
  def cons(x: {type A})(hd: x.A)(tl: sci.List{type A &lt;: x.A})
      : sci.List{type A &lt;: x.A} = new List{ self =&gt;
    type A = x.A
    def isEmpty = false
    def head = hd
    def tail = tl
  }
}
```

===
# dotty
--------

* DOTに影響を受けたコンパイラ
* いくつかの新しい機能
  + DOTの交差型、合併型も
  + Nullable = `T | Null`
  + `if (x) 1 else &#34;a&#34;` は `Int | String` にアノテーション可能
* `forSome` が消えた
  + DOTのお陰

===
# dotty
--------

* Java8のラムダを使う
  + 生成するclassファイルの減少
* Implicitの探索アルゴリズムを改善
  + 反変implicitについても改善
* 型推論のアルゴリズムを改善
  + DOTのお陰
  + 特にサブタイピングが交差/合併型で楽に
* コンパイルパスを融合して高速化
  + 中間木がなくなってGCにやさしい
* 他にも一杯改善が

===

```scala
object DaysOfTheWeek{
  object Mon
  object Tue
  object Wed
  object Thu
  object Fri
  object Sat
  object Sun

  type Weekend = Sat.type | Sun.type
  type Workweek = Mon.type | Tue.type | Wed.type | Thu.type | Fri.type
  type All = Weekend | Workweek
}
```

===
# TASTY/Linker
--------------

* classファイルを作るとScala固有の情報が落ちる
* プログラム全体を見渡すと不要なコードとかもコンパイルしないといけない
* かといって毎回プログラム全部をコンパイルし直すのは遅い
* → TASTY。型推論後のASTをシリアライズする
  + Scalaは型推論が遅いのでそこをスキップ出来るだけでそこそこ速くなる
* classファイルを跨げるようになったのでユーザが最適化とかも書ける
* Scala/Scala.js/Scala Native共通プラットフォーム化への布石？
* どうやらclassファイルにバイトコードとTASTYを埋め込む??

===
# まとめ
--------

* Scalaの基礎にDOTがあるよ
* DOTを参考にdottyが作られたよ
* dottyで色々改善されるよ
* ついでにTASTY/Linkerについて話したよ

===
# 参考1
------

* [The Essence of Dependent Object Types](https://infoscience.epfl.ch/record/215280/files/paper_1.pdf)
* [From F to DOT: Type Soundness Proofs with Definitional Interpreters](http://arxiv.org/pdf/1510.05216v2.pdf)
* [Dependent Object Types](http://www.cs.uwm.edu/~boyland/fool2012/papers/fool2012_submission_3.pdf)
* [Why is the Scala compiler so slow? - Quora](https://www.quora.com/Why-is-the-Scala-compiler-so-slow)
* [performance - Java compile speed vs Scala compile speed - Stack Overflow](http://stackoverflow.com/questions/3490383/java-compile-speed-vs-scala-compile-speed/3612212#3612212)

===
# 参考2
-------

* [GHC doesn&#39;t do subtyping. I suspect that is the main reason why Scala is slow - ... | Hacker News](https://news.ycombinator.com/item?id=5008761)
* [A Core Calculus for Scala Type Checking](http://lampwww.epfl.ch/~odersky/papers/mfcs06.pdf)
* [namin/dot: formalization of the Dependent Object Types (DOT) calculus](https://github.com/namin/dot)
* [The DOT Calculus](http://lampwww.epfl.ch/%7Eamin/dot/current_rules.pdf)
* [Dotty: exploring the future of scala](https://d-d.me/talks/scalaworld2015/)
* [Dotty and types: the story so far](http://guillaume.martres.me/talks/typelevel-summit-oslo/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SML#に学ぶコンパイラ言語におけるREPLの実装方法</title>
      <link>/blog/2015/12/12/sml_nimanabukonpairagengoniokerureplnojissouhouhou</link>
      <pubDate>Sat, 12 Dec 2015 19:42:52 +0900</pubDate>
      
      <guid>/blog/2015/12/12/sml_nimanabukonpairagengoniokerureplnojissouhouhou</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装 Advent Calendar 2015&lt;/a&gt;16日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。かねてより気になっていたREPLの実装方法について、SML#のソースコードを読んだのでその話でもします。&lt;/p&gt;

&lt;p&gt;さて、ソースコードを読みながらやっていきましょう。SML# 2.0.0のソースコードです。&lt;/p&gt;

&lt;p&gt;REPLのエントリポイントは&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/compiler/main/main/SimpleMain.sml#L949&#34;&gt;src/compiler/main/main/SimpleMain.smlL949&lt;/a&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      | Interactive (options, context) =&amp;gt;
        let
          val newContext =
              Top.loadInteractiveEnv
                {stopAt = Top.NoStop,
                 stdPath = [#systemBaseDir options],
                 loadPath = nil}
                context
                (Filename.concatPath
                   (#systemBaseDir options, Filename.fromString &amp;quot;prelude.smi&amp;quot;))
          val context =
              let
                val context = Top.extendContext (context, newContext)
                val context = Top.incVersion context
              in
                context
              end
          val _ = ReifiedTermData.init (#topEnv context)
                  handle e =&amp;gt; raise e
        in
          RunLoop.interactive options context;
          SUCCESS
        end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いろいろごちゃごちゃやってますがオプションと共に&lt;code&gt;RunLoop.interactive&lt;/code&gt;を呼んでるだけです。&lt;/p&gt;

&lt;p&gt;さて、RunLoop.smlはSimpleMain.smlと同じディレクトリにあります。&lt;code&gt;interactive&lt;/code&gt;関数は次のように定義されています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun interactive options context =
      let
        ...
        val state = initInteractive ()
        fun loop context input =
            if !(#eof state) then ()
            else
              (Counter.reset();
               NameEvalEnv.intExnConList();
               case run options context input of
                 SUCCESS newContext =&amp;gt;
                 ....
               | FAILED =&amp;gt;
                 loop (Top.incVersion context) (interactiveInput state)
              )
      in
        loop context (interactiveInput state)
      end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何やら状態を初期化した後は&lt;code&gt;interactiveInput&lt;/code&gt;で得られた結果を&lt;code&gt;run&lt;/code&gt;に渡しているようです。&lt;code&gt;run&lt;/code&gt;を見ましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun run ({stdPath, loadPath, LDFLAGS, LIBS, errorOutput, llvmOptions,
            ...}:options)
          context input =
      let
        fun puts s = TextIO.output (errorOutput, s ^ &amp;quot;\n&amp;quot;)
        val options = {stopAt = Top.NoStop,
                       baseFilename = NONE,
                       stdPath = stdPath,
                       loadPath = loadPath}
        val ({interfaceNameOpt, ...}, result) =
             Top.compile options context input
             handle e =&amp;gt;
             (
               case e of
                 UserError.UserErrors errs =&amp;gt;
                 app (fn e =&amp;gt; puts (userErrorToString e)) errs
               | UserError.UserErrorsWithoutLoc errs =&amp;gt;
                 app (fn (k,e) =&amp;gt; puts (userErrorToString (Loc.noloc,k,e))) errs
               | Bug.Bug s =&amp;gt; puts (&amp;quot;Compiler bug:&amp;quot; ^ s)
               | exn =&amp;gt; raise exn;
               raise CompileError
            )
        val (newContext, module) =
            case result of
              Top.RETURN (newContext, module) =&amp;gt; (newContext, module)
            | Top.STOPPED =&amp;gt; raise Bug.Bug &amp;quot;run&amp;quot;
      in
        let
          val objfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.OBJEXT ())
          val asmfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.ASMEXT ())
          val _ = #start Counter.llvmOutputTimeCounter()
          val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile,
                                            Filename.toString asmfile)
          val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile,
                                            Filename.toString objfile)
          val _ = #stop Counter.llvmOutputTimeCounter()
          val _ = LLVM.LLVMDisposeModule module
          val sofile = TempFile.create (SMLSharp_Config.DLLEXT ())
          val ldflags =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                [&amp;quot;-Wl,-out-implib,&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
              | SMLSharp_Config.Mingw =&amp;gt;
                [&amp;quot;-Wl,--out-implib=&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
          val libfiles =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
              | SMLSharp_Config.Mingw =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
          val _ = BinUtils.link
                    {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS
                             @ ldflags,
                     libs = libfiles @ LIBS,
                     objects = [objfile],
                     dst = sofile,
                     useCXX = false,
                     quiet = not (!Control.printCommand)}
          val so = DynamicLink.dlopen&#39; (Filename.toString sofile,
                                        DynamicLink.GLOBAL,
                                        DynamicLink.NOW)
                   handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} =
              GenerateMain.moduleName (interfaceNameOpt, #version context)
          val smap = DynamicLink.dlsym&#39; (so, stackMapSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val base = DynamicLink.dlsym&#39; (so, codeBeginSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val _ = sml_register_stackmap (smap, base)
          val ptr = DynamicLink.dlsym (so, mainSymbol)
                    handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          (*
           * Note that &amp;quot;ptr&amp;quot; points to an ML toplevel code. This toplevel code
           * should be called by the calling convention for ML toplevels of
           * ML object files.  __attribute__((fastcc,no_callback)) is an ad
           * hoc way of yielding this convention code; no_callback avoids
           * calling sml_control_suspend.  If we change how to compile
           * attributes in the future, we should revisit here and update the
           * __attribute__ annotation.
           *)
          val mainFn =
              ptr : _import __attribute__((fastcc,no_callback)) () -&amp;gt; ()
        in
          loadedFiles := sofile :: !loadedFiles;
          mainFn () handle e =&amp;gt; raise UncaughtException e;
          SUCCESS newContext
        end
        handle e =&amp;gt;
          (
            case e of
              UserError.UserErrors errs =&amp;gt;
              app (fn e =&amp;gt; puts (userErrorToString e)) errs
            | UserError.UserErrorsWithoutLoc errs =&amp;gt;
              app (fn (k,e) =&amp;gt; puts (userErrorToString (Loc.noloc,k,e))) errs
            | DLError s =&amp;gt;
              puts (&amp;quot;failed dynamic linking. Perhaps incorrect name in _import declaration: &amp;quot; ^ s)
            | UncaughtException exn =&amp;gt;
              puts (&amp;quot;uncaught exception &amp;quot; ^ exnMessage exn)
            | CoreUtils.Failed {command, message} =&amp;gt;
              (puts (&amp;quot;command failed: &amp;quot; ^ command); puts message)
            | _ =&amp;gt; raise e;
            FAILED
          )
      end
      handle CompileError =&amp;gt; FAILED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デカいですね。どうやら&lt;code&gt;run&lt;/code&gt;がREPLの本体のようです。少しずつ見ていきます。&lt;/p&gt;

&lt;p&gt;まずはコンパイルしているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;        val ({interfaceNameOpt, ...}, result) =
             Top.compile options context input
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして結果からcontextとmoduleを取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;        val (newContext, module) =
            case result of
              Top.RETURN (newContext, module) =&amp;gt; (newContext, module)
            | Top.STOPPED =&amp;gt; raise Bug.Bug &amp;quot;run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恐らくcontextが変数名とかを持っているのでしょう。
moduleに関しては&lt;code&gt;Top.compile&lt;/code&gt;が最後にLLVMEmitをしてるのでLLVMのmodule(コンパイルされる最大単位)のことだと思います。だとするとここまではまだコードはメモリ上にあるはずです。&lt;/p&gt;

&lt;p&gt;moduleを取り出した後どうしてるかというとオブジェクトファイルを作っているようです。ここでファイルに書き出されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          val objfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.OBJEXT ())
          val asmfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.ASMEXT ())
          val _ = #start Counter.llvmOutputTimeCounter()
          val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile,
                                            Filename.toString asmfile)
          val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile,
                                            Filename.toString objfile)
          val _ = #stop Counter.llvmOutputTimeCounter()
          val _ = LLVM.LLVMDisposeModule module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に呼んでるDisposeModuleはデストラクタですかね。ちゃんとお片付けしてます。&lt;/p&gt;

&lt;p&gt;さらに、ダイナミックリンクファイルを作るようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val sofile = TempFile.create (SMLSharp_Config.DLLEXT ())
          val ldflags =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                [&amp;quot;-Wl,-out-implib,&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
              | SMLSharp_Config.Mingw =&amp;gt;
                [&amp;quot;-Wl,--out-implib=&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
          val libfiles =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
              | SMLSharp_Config.Mingw =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
          val _ = BinUtils.link
                    {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS
                             @ ldflags,
                     libs = libfiles @ LIBS,
                     objects = [objfile],
                     dst = sofile,
                     useCXX = false,
                     quiet = not (!Control.printCommand)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時、Windowsでは何かしらの制約があるのか過去にリンクしたダイナミックリンクファイル(libfiles)も今回作るダイナミックリンクファイルにリンクしているようです。&lt;/p&gt;

&lt;p&gt;さて、ダイナミックリンクファイルを作った後は&lt;code&gt;dlopen&lt;/code&gt;を使ってダイナミックリンクします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val so = DynamicLink.dlopen&#39; (Filename.toString sofile,
                                        DynamicLink.GLOBAL,
                                        DynamicLink.NOW)
                   handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後はエントリポイントを捜してインポート、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} =
              GenerateMain.moduleName (interfaceNameOpt, #version context)
          val smap = DynamicLink.dlsym&#39; (so, stackMapSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val base = DynamicLink.dlsym&#39; (so, codeBeginSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val _ = sml_register_stackmap (smap, base)
          val ptr = DynamicLink.dlsym (so, mainSymbol)
                    handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val mainFn =
              ptr : _import __attribute__((fastcc,no_callback)) () -&amp;gt; ()
        in
          loadedFiles := sofile :: !loadedFiles;
          mainFn () handle e =&amp;gt; raise UncaughtException e;
          SUCCESS newContext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果を印字しているところが見当らないのですが吐かれたコードに印字部分も入っているんですかね。&lt;/p&gt;

&lt;p&gt;あとは&lt;code&gt;interactive&lt;/code&gt;に返ってコンテキストを拡張したりバージョンをインクリメントしたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;                   val context = Top.extendContext (context, newContext)
                   val context = Top.incVersion context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バージョンによってシンボル名を変えることで何度もsoファイルをロードしても大丈夫なようにしてるんですかね。&lt;/p&gt;

&lt;p&gt;ということでREPLの実装は入力を一旦ダイナミックリンクとしてコンパイルしてからロードしているようでした。&lt;/p&gt;

&lt;h1 id=&#34;おまけ&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;REPLの入力部分は次のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;
  fun initInteractive () =
      let
        val lineCount = ref 1
        val eof = ref false
        fun read (isFirst, _:int) =
            let
              val prompt = if isFirst then &amp;quot;# &amp;quot; else &amp;quot;&amp;gt; &amp;quot;
              val _ = TextIO.output (TextIO.stdOut, prompt)
              val _ = TextIO.flushOut TextIO.stdOut
              val line = TextIO.inputLine TextIO.stdIn
              val _ = lineCount := !lineCount + 1
            in
              case line of NONE =&amp;gt; (eof := true; &amp;quot;&amp;quot;) | SOME s =&amp;gt; s
            end
      in
        {lineCount = lineCount, eof = eof, read = read}
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結構小さいので色々Hack出来ます。例えば&lt;a href=&#34;https://github.com/smlsharp/smlsharp/pull/13&#34;&gt;hskさんのように&lt;/a&gt;REPLを付けることも出来ます。&lt;/p&gt;

&lt;p&gt;このパッチで外部コマンドを呼ぶのが少し嫌な人はさらに&lt;code&gt;ioctl(2)&lt;/code&gt;を使ってrawモードにするパッチを当てるかlibeditなんかを使ってリッチな入力を実現するかをすればいいでしょう。
個人利用なら(他人に配布しないなら)GPLv3のreadlineも使えるんですかね（ライセンスに詳しくない）。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;REPLの実装にはダイナミックリンクを使う方法があるよ&lt;/li&gt;
&lt;li&gt;SML#のREPLはHack出来そうだよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#でJITコンパイラを作る軽い話</title>
      <link>/blog/2015/12/12/sml_dejitwotsukurukaruihanashi</link>
      <pubDate>Sat, 12 Dec 2015 17:26:24 +0900</pubDate>
      
      <guid>/blog/2015/12/12/sml_dejitwotsukurukaruihanashi</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/848&#34;&gt;ML Advent Calendar 2015&lt;/a&gt;及び&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装 Advent Calendar 2015&lt;/a&gt;15日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。先日流れてきた&lt;a href=&#34;http://www.jonathanturner.org/2015/12/building-a-simple-jit-in-rust.html&#34;&gt;RustでJITコンパイラを作る話&lt;/a&gt;が面白かったのでSML#でもやってみます。&lt;/p&gt;

&lt;h1 id=&#34;jitコンパイラってなに&#34;&gt;JITコンパイラってなに？&lt;/h1&gt;

&lt;p&gt;JITはJust In Timeで、日本語にすると「間に合って」になります。誤読されかねませんが「臨時コンパイラ」と訳すのが適当なのでしょうか。&lt;/p&gt;

&lt;p&gt;普通のインタプリタがソースコードを直接評価するのに対してJITコンパイラはソースコードを内部で一旦ネイティブコードにコンパイルして実行します。&lt;/p&gt;

&lt;p&gt;よく、JITコンパイラ/JITコンパイルのことをJITと略して呼びます。&lt;/p&gt;

&lt;h1 id=&#34;どこで使うの&#34;&gt;どこで使うの？&lt;/h1&gt;

&lt;p&gt;主に、インタプリタの高速化の目的で使われるようです。他にはコンパイラをインタプリタ化させる(REPLの実装とか)でも使えそうな気がしますが、詳しくは知りません。&lt;/p&gt;

&lt;h1 id=&#34;jitってどうやって作るの&#34;&gt;JITってどうやって作るの？&lt;/h1&gt;

&lt;p&gt;JIT &lt;strong&gt;でない&lt;/strong&gt; コンパイラが吐いたコードは一旦ディスクからメモリに読まれ、メモリ上で実行されます。&lt;/p&gt;

&lt;p&gt;JITコンパイラが吐くコードは直接メモリに吐かれ、メモリ上で実行されます。なので細かい条件を無視すれば&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;吐かれる命令のための(特殊な)メモリ領域を用意する&lt;/li&gt;
&lt;li&gt;そこに実行したい命令列を書き込む&lt;/li&gt;
&lt;li&gt;書き込んだ命令列を実行する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;だけです。
3.の「書き込んだ命令を実行する」が若干ふわっとしてますが、多くの場合は命令の書かれたメモリを関数ポインタとして扱って、その関数を呼び出す形で実行されます。
一応直接プログラムカウンタをいじって書き込んだ命令列を実行させることも出来ます。&lt;/p&gt;

&lt;h1 id=&#34;一緒に作ってみよう&#34;&gt;一緒に作ってみよう&lt;/h1&gt;

&lt;p&gt;思ったより簡単そうですね。作ってみましょう。&lt;/p&gt;

&lt;h2 id=&#34;1-メモリ領域を準備する&#34;&gt;1. メモリ領域を準備する&lt;/h2&gt;

&lt;p&gt;先に「特殊な」と付言しましたのでそれについて説明しましょう。プロセス上のメモリは、OSによって保護されています。
特に、そのままではそのメモリ上の命令列を実行出来ません。その保護を外すために&lt;code&gt;mprotect(2)&lt;/code&gt;システムコールを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int mprotect(void *addr, size_t len, int prot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SML#を使えば簡単に使えるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val mprotect = _import &amp;quot;mprotect&amp;quot;: (unit ptr, word, word) -&amp;gt; int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SML#は2.0.0時点では32bitでしか動かないのでsize_tをwordとしてしまって大丈夫です。また、bit演算をやりたいので&lt;code&gt;prot&lt;/code&gt;は本来はintですがwordにしました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mprotect(2)&lt;/code&gt;はPOSIX(SUSv4)的には引数の&lt;code&gt;addr&lt;/code&gt;がシステムのページの境界上にあることを要求しても良いことになっています。
実際、OS Xが要求するらしいです。また、メモリ保護はページ単位で行われるため、&lt;code&gt;len&lt;/code&gt;もページサイズの倍数である必要があります。
&lt;code&gt;prot&lt;/code&gt;は保護フラグですね。&lt;/p&gt;

&lt;p&gt;メモリの確保、特にページの境界にアラインメントされたメモリ領域を確保するにはSML#では厳しそうなのでこれもCの関数に頼ります。
Linuxならいくつか方法はありますが、ポータブルには&lt;code&gt;posix_memalign(3)&lt;/code&gt;を使うのが良いようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int posix_memalign(void **memptr, size_t alignment, size_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもSML#から簡単に使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val posix_memalign = _import &amp;quot;posix_memalign&amp;quot;: (unit ptr ref, word, word) -&amp;gt; int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにメモリの解放も必要ですね。&lt;code&gt;free(3)&lt;/code&gt;もインポートしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val free = _import &amp;quot;free&amp;quot;: unit ptr -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、メモリを確保するのにいくつかCのマクロで定義された定数を定義しましょう。今のところSML#にCのマクロを使う術はなさそうです。どうにかしてCプリプロセッサを使えれば良いのですが…。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val PROT_READ  = 0wx1
val PROT_WRITE = 0wx2
val PROT_EXEC  = 0wx4
val PROT_NONE  = 0wx0

val PAGE_SIZE = 0w4096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ページサイズは本当は&lt;code&gt;sysconf(3)&lt;/code&gt;を使って&lt;code&gt;sysconf(PAGESIZE)&lt;/code&gt;として取るのが作法ですが面倒なので4KiB決め打ちにしてしまいました。&lt;/p&gt;

&lt;p&gt;さて、これらを用いてJIT用のメモリは次のように確保します。&lt;code&gt;Pointer&lt;/code&gt;モジュールが必要なのでsmiファイルで&lt;code&gt;require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt;しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val op orb = Word.orb
infix 5 orb
val size = 0wx1
val msize = size * PAGE_SIZE
val pageRef: unit ptr ref = ref (Pointer.NULL ())
val ret = posix_memalign (pageRef, PAGE_SIZE, msize)
val page = if ret = 0
           then !pageRef
           else raise Fail &amp;quot;memory allocation failed&amp;quot;
val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC
val ret = mprotect (page, msize, PROT_RWEX)
val () = if ret = 0
         then ()
         else raise Fail &amp;quot;memory protection error&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;page&lt;/code&gt;に実行可能フラグが立ったメモリが確保出来ました。sizeは書き込みたい命令列に応じて変えます。&lt;/p&gt;

&lt;h1 id=&#34;2-命令列を書き込む&#34;&gt;2. 命令列を書き込む&lt;/h1&gt;

&lt;p&gt;さて、ここらへんからアセンブラの世界になってきます。&lt;/p&gt;

&lt;p&gt;まず、安全のために件のメモリ領域を&lt;code&gt;ret&lt;/code&gt;命令で埋めます。
&lt;code&gt;ret&lt;/code&gt;命令は関数から戻る時に使われる命令で、変なことをしても&lt;code&gt;ret&lt;/code&gt;で元の場所に戻ればどうにかなる可能性があるのです。&lt;/p&gt;

&lt;p&gt;メモリを一気に埋めるには&lt;code&gt;memset(3)&lt;/code&gt;が便利です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void *memset(void *s, int c, size_t n);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをSMLにインポートして使いましょう。&lt;code&gt;ret&lt;/code&gt;命令に対応するマシン語は&lt;code&gt;0xc3&lt;/code&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val memset = _import &amp;quot;memset&amp;quot;: (unit ptr, word, word) -&amp;gt; unit ptr
val _ = memset (page, 0wxc3, msize)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃあ、命令を書き込んでいきましょう。最初はただ1を返すだけの関数に相当する命令です。
64bitマシンを使っていても32bitでコンパイルしたSML#を使っている限りはx86(IA32)のアセンブラを使います。
x86は値を&lt;code&gt;eax&lt;/code&gt;レジスタに入れることで返り値とします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;mov 1 eax
ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードを&lt;a href=&#34;https://defuse.ca/online-x86-assembler.htm#disassembly&#34;&gt;オンラインアセンブラ&lt;/a&gt;でアセンブルしてみると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0:  b8 01 00 00 00          mov    eax,0x1
5:  c3                      ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;との結果が返ってきました。これを真心込めて1つづつメモリに書き込んでいきます。
SML#からメモリに直接書き込むには内部APIっぽいものを触る必要があります。
タイプ数を減らすためにいくつかエイリアスを定義しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
val store = Pointer.store
val advance = Pointer.advance
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メモリにword8の値を書き込むのにキャストが必要になるので&lt;code&gt;fromUnitPtr&lt;/code&gt;を使います。
さて、書き込んでいきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val mem: word8 ptr = fromUnitPtr page
val () = store page 0wxb8
val mem = advance mem
val () = store page 0wx01
val mem = advance mem
val () = store page 0wx00
val mem = advance mem
val () = store mem 0wx00
val mem = advance mem
val () = store mem 0wx00
val mem = advance mem
val () = store mem 0wxc3
val _ = advance mem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;page&lt;/code&gt;に1を返すだけの命令列が書き込まれした。&lt;/p&gt;

&lt;h2 id=&#34;3-書き込んだ命令列を実行する&#34;&gt;3. 書き込んだ命令列を実行する&lt;/h2&gt;

&lt;p&gt;書き込んだ命令列は関数にキャストして使うことが多いと言いました。今回もそのようにします。&lt;/p&gt;

&lt;p&gt;そのために、また内部APIっぽいものを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;codeptr&lt;/code&gt;型は関数ポインタを表すもののようです。&lt;code&gt;DynamicLink&lt;/code&gt;モジュールなどで使われています。&lt;/p&gt;

&lt;p&gt;さて、今回の1を返すだけの命令列は&lt;code&gt;() -&amp;gt; int&lt;/code&gt;型になりますね。
それをインポート、実行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val freturn1 = toCodePtr page: _import () -&amp;gt; int
val () = print ((Int.toString (freturn1 ())) ^ &amp;quot;\n&amp;quot;)
val _ = free page
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで見事&lt;code&gt;1&lt;/code&gt;が印字されたら成功です。&lt;/p&gt;

&lt;h1 id=&#34;さらに&#34;&gt;さらに&lt;/h1&gt;

&lt;p&gt;先程のコードは繰り返しが多く、整理されていませんでした。もう少し整理しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure Emit = struct
    val posix_memalign = _import &amp;quot;posix_memalign&amp;quot;: (unit ptr ref, word, word) -&amp;gt; int
    val mprotect = _import &amp;quot;mprotect&amp;quot;: (unit ptr, word, word) -&amp;gt; int
    val memset = _import &amp;quot;memset&amp;quot;: (unit ptr, word, word) -&amp;gt; unit ptr
    val free = _import &amp;quot;free&amp;quot;: unit ptr -&amp;gt; ()
    val printf = _import &amp;quot;printf&amp;quot;: (string, unit ptr) -&amp;gt; ()

    (* 
#define PROT_READ	0x1		/* Page can be read.  */
#define PROT_WRITE	0x2		/* Page can be written.  */
#define PROT_EXEC	0x4		/* Page can be executed.  */
#define PROT_NONE	0x0		/* Page can not be accessed.  */
    *)

    val PROT_READ  = 0wx1
    val PROT_WRITE = 0wx2
    val PROT_EXEC  = 0wx4
    val PROT_NONE  = 0wx0

    val PAGE_SIZE = 0w4096

    type jitptr = word8 ptr
    val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
    val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr
    val toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr
    val store = Pointer.store
    val advance = Pointer.advance


    fun jitMemory size: jitptr = let
        val op orb = Word.orb
        infix 5 orb
        val msize = size * PAGE_SIZE
        val pageRef: unit ptr ref = ref (Pointer.NULL ())
        val ret = posix_memalign (pageRef, PAGE_SIZE, msize)
        val page = if ret = 0
                   then !pageRef
                   else raise Fail &amp;quot;memory allocation failed&amp;quot;
        val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC
        val ret = mprotect (page, msize, PROT_RWEX)
        val () = if ret = 0
                 then ()
                 else raise Fail &amp;quot;memory protection error&amp;quot;
        (* init with ret for safety *)
        val _ = memset (page, 0wxc3, msize)
    in
        fromUnitPtr page
    end

    fun freeJit (jitMem: jitptr) = free (SMLSharp_Builtin.Pointer.toUnitPtr jitMem)

    fun pushWord page (word: word8) = (store (page, word); advance (page, 1))
    fun pushWords (page: jitptr) l = List.foldl (fn(w,page) =&amp;gt; pushWord page w) page l

    val import: jitptr -&amp;gt; codeptr = toCodeptr o toUnitPtr

    fun fromMachineCode l = let
        val len = Word.fromInt(List.length l)
        val size = (len + PAGE_SIZE) div PAGE_SIZE
        val page = jitMemory size
        val _ = pushWords page l
    in
        import page
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のように使います。一回importした関数はfreeしないことにしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun println x = print (x ^ &amp;quot;\n&amp;quot;)
val return1  =
    (* 0:  b8 01 00 00 00          mov    eax,0x1  *)
    [
      0wxb8, 0wx01, 0wx00, 0wx00, 0wx00
    ] 
val freturn1 = Emit.fromMachineCode return1 :_import () -&amp;gt; int
val () = println (Int.toString (freturn1 ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引数を取る&#34;&gt;引数を取る&lt;/h2&gt;

&lt;p&gt;もうアセンブラの話になります。&lt;/p&gt;

&lt;p&gt;x86では引数は右から順にスタックに積まれます。intを1つ取ってそれに1足して返す関数はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val add1 = 
    (* 0:  8b 44 24 04             mov    eax,DWORD PTR [esp+0x4] *)
    (* 4:  83 c0 01                add    eax,0x1 *)
    [
      0wx8b, 0wx44, 0wx24, 0wx04,
      0wx83, 0wxc0, 0wx01
    ]
val fadd1 = Emit.fromMachineCode add1 :_import (int) -&amp;gt; int
val () = println (Int.toString (fadd1 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常に動けば4が印字されます。&lt;/p&gt;

&lt;h1 id=&#34;つらい話&#34;&gt;つらい話&lt;/h1&gt;

&lt;h2 id=&#34;バグ&#34;&gt;バグ&lt;/h2&gt;

&lt;p&gt;最初、&lt;code&gt;Pointer.store&lt;/code&gt;でなく、&lt;code&gt;SMLSharp_Builtin.Pointer.store&lt;/code&gt;を使っていたら&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/43&#34;&gt;変なバグ&lt;/a&gt;踏みました。バグというか使い方が悪かった。&lt;/p&gt;

&lt;h2 id=&#34;デバッグ&#34;&gt;デバッグ&lt;/h2&gt;

&lt;p&gt;デバッガがないので非常につらいです。書き出された命令列を見るのに困りました。gdbで見たかったので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val printf = _import &amp;quot;printf&amp;quot;: (string, unit ptr) -&amp;gt; int
val _ = pritnf (&amp;quot;page pointr: %p&amp;quot;, page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;して&lt;code&gt;printf&lt;/code&gt;にブレークポイントを張り、そこで止めつつページのアドレスを取得、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;(gdb) x/20xh 0x81ca000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとして見ていました。&lt;/p&gt;

&lt;h1 id=&#34;もっと&#34;&gt;もっと&lt;/h1&gt;

&lt;p&gt;JITコンパイラが楽しかったのでアセンブラのDSLを作ってみました。1、2個の命令吐けるだけですがちゃんと動きました。今のところこのように書けます。Intel記法だとしんどそうだったのでAT&amp;amp;T記法っぽく書けるようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val freturn1&#39; = Emit.fromInsts [
        xorl eax eax,
        addl ($1) eax,
        ret
    ]:_import () -&amp;gt; int
val () = println (Int.toString (freturn1&#39; ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x86は命令フォーマットが1バイトから15バイトまでの可変長で、内部表現をどのようにするか決めるだけでも一苦労でした。x86つらい。&lt;/p&gt;

&lt;p&gt;アドレッシングが複雑なのも悩みどころで、複数のアドレッシングを統一的に扱えるようにオーバーロードされた関数を用意したのですがあえなくSML#のバグを踏んで死亡しました。本当はこういう記法が出来る筈だった…&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;addl (%eax) eax
addl eax (%eax)
addl eax (%(eax, ebx))
addl eax (%(eax, ebx, 4))
addl eax (%(4, eax))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/bin/smlsharp   -c -o main.o main.sml
uncaught exception: Bug.Bug: InferType: FIXME: user error: invalid instTy at src/compiler/typeinference2/main/InferTypes2.sml:47
Makefile:11: recipe for target &#39;main.o&#39; failed
make: *** [main.o] Error 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;movl&lt;/code&gt;を実装しようとしたらアドレッシングが動かなかったので萎えてまだ実装してません。&lt;/p&gt;

&lt;p&gt;よく考えたら&lt;code&gt;%&lt;/code&gt;ってミスリーディングだし名前変えよう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;JITを作るにはメモリ保護をいじれて関数ポインタのインポートが出来ればいいよ&lt;/li&gt;
&lt;li&gt;SML#でもJIT作れるよ&lt;/li&gt;
&lt;li&gt;アセンブラっぽいの作ったよ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/smljit&#34;&gt;こちら&lt;/a&gt;にあります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCOと例外ハンドル</title>
      <link>/blog/2015/05/31/tcotoreigaihandoru</link>
      <pubDate>Sun, 31 May 2015 21:02:08 +0900</pubDate>
      
      <guid>/blog/2015/05/31/tcotoreigaihandoru</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou&#34;&gt;先日のエントリー&lt;/a&gt;の最後でループ内で例外ハンドルをすると極端に遅くなるということを書きましたが、それについて。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/604235677337714689&#34;&gt;2015, 5月 29&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; うーん、ちょっと例外のことは詳しくないんですが、予想だと例外ハンドラをループ内にいれると毎回スタックに積むんで外す操作がはさまることになるのでレジスタで完結してるようなループ処理だと露骨に遅くなるかもしれません&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604537509771501569&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; あーありえますね。ジャンプで済むところを戻ってきてスタックに積んだのを除去しないといけませんからね。ちょっと手元にマシンが無いのですがネイティブコードで実験してみますー&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604540519188815872&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; ocamlでも例外ハンドラのはさみ方で末尾再帰になったり、ならなかったりするというのは聞いたことがあるので多分あたりな気がします&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604545844000325632&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということで実験してみましょう。&lt;/p&gt;

&lt;p&gt;次のような何がしたいのか分からないループのベンチマークを取ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は無限ループではなく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uncaught exception: Subscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、境界外アクセスの例外が出ます。因みにSubscripは添字って意味だそうです。&lt;/p&gt;

&lt;p&gt;これではベンチマークがとれないので、例外が起きたらループを抜けるようにしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Subscript =&amp;gt; ()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 5 ms/1calls
  [Average] 5.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一瞬ですね。では、末尾呼び出し位置でhandleしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(100, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
        handle Subscript =&amp;gt; ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 1729 ms/1calls
  [Average] 1729.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふーむ。やはり大分遅くなってますね。しかしループ内で例外をハンドルした所為かもしれないのでループ内で非末尾位置で例外をハンドルしてみます。大域脱出に例外使いますがまあ、パフォーマンスに問題ないでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;exception Exit
val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1)
        handle Subscript =&amp;gt; raise Exit;
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Exit =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 11 ms/1calls
  [Average] 11.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やはり多少は遅くなってますが末尾位置の時のように極端には遅くなってないようです。&lt;/p&gt;

&lt;p&gt;最後に非末尾再帰ループの速度を測っておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        1 + (loop ())
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Subscript =&amp;gt; 0
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 403 ms/1calls
  [Average] 403.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思ったより遅いですね。ループか末尾例外ハンドルかというと末尾例外ハンドルに近いスコア。&lt;/p&gt;

&lt;h1 id=&#34;考察&#34;&gt;考察&lt;/h1&gt;

&lt;p&gt;末尾位置で例外をハンドルすると遅くなる原因はTCOが効かないから、で合ってそうです。&lt;/p&gt;

&lt;p&gt;しかしそれにしても遅いですね。例外ハンドラをスタックに積むのが1関数呼び出しくらいならせいぜい倍くらいの遅さで済む筈です。
もしかしたらループ展開とかの外の最適化も掛からなくなるのかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;結論&#34;&gt;結論&lt;/h1&gt;

&lt;p&gt;例外をハンドルする時は位置に気をつけましょうね。&lt;/p&gt;

&lt;h1 id=&#34;付録a&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;ベンチマーカはこんなコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure Benchmark =
struct
fun repeat 0 f = ()
  | repeat n f =  (f ();repeat (n - 1) f)
 
fun bench n f = let
    val startTime = Time.now ()
    val _ = repeat n f
    val endTime = Time.now ()
in
    Time.toMilliseconds (Time.-(endTime, startTime))
end
 
fun benchmark name n f = let
    val time = bench n f
in
    print (name ^ &amp;quot;\n&amp;quot;);
    print (&amp;quot; Time:\n&amp;quot;);
    print (&amp;quot;    [Total] &amp;quot; ^ (LargeInt.toString time) ^ &amp;quot; ms/&amp;quot; ^ (Int.toString n) ^ &amp;quot;calls\n&amp;quot;);
    print (&amp;quot;  [Average] &amp;quot; ^ (Real.toString((Real.fromLargeInt time) / (Real.fromInt n))) ^ &amp;quot; ms/call\n&amp;quot;)
end

fun nChars n char = CharArray.vector(CharArray.array(n, char))

fun toWidth width str = let
    val len = String.size str
in
    if len &amp;lt; width
    then str ^ (nChars (width - len) #&amp;quot; &amp;quot;)
    else str
end

fun histLine width base value =
  (nChars (Int.fromLarge(width * value div base)) #&amp;quot;*&amp;quot;) ^ &amp;quot;\n&amp;quot;

fun benchset name n fs = let
    val res = List.map (fn (label, f) =&amp;gt; (label, bench n f)) fs
    val max = List.foldl (fn ((_, time), m) =&amp;gt; LargeInt.max(time, m)) 0 res
    val maxLen = List.foldl (fn ((label, _), m) =&amp;gt; Int.max(String.size label,  m)) 0 fs
in
    print &amp;quot;name:\n&amp;quot;;
    print ((nChars ((String.size &amp;quot; &amp;quot;) + maxLen) #&amp;quot;-&amp;quot;) ^ &amp;quot;+&amp;quot; ^ (nChars ((String.size &amp;quot;|&amp;quot;) +  50) #&amp;quot;-&amp;quot;) ^ &amp;quot;\n&amp;quot;);
    app (fn (label, time) =&amp;gt; print(&amp;quot; &amp;quot; ^ (toWidth maxLen label) ^ &amp;quot;|&amp;quot; ^(histLine (50:LargeInt.int) max time))) res;
    print ((nChars ((String.size &amp;quot; &amp;quot;) + maxLen) #&amp;quot;-&amp;quot;) ^ &amp;quot;+&amp;quot; ^ (nChars ((String.size &amp;quot;|&amp;quot;) +  50) #&amp;quot;-&amp;quot;) ^ &amp;quot;\n&amp;quot;)
end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;付録b&#34;&gt;付録B&lt;/h1&gt;

&lt;p&gt;元々、なんでこの問題が生じたかというと一々境界チェックして配列にアクセスするより例外出させといた方が速いんじゃね？ってことでそういうコードを書いたからです。
例外が出るってことは内部でも境界チェックしてる筈ですから。&lt;/p&gt;

&lt;p&gt;ということでどちらが速いか確認してみましょう。&lt;/p&gt;

&lt;p&gt;まず例外ハンドル方式。先程のままだと数ミリ秒で終わってたので配列の大きさを10倍しました。あと。実際に書きそうな書き方に変えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val len = 10000000
    val arr = Array.array(len, 0)
    fun loop i = (
        Array.update(arr, i, 1);
        loop (i + 1)
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop 0
                                     handle Subscript =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 48 ms/1calls
  [Average] 48.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ、こんなもんですね。&lt;/p&gt;

&lt;p&gt;次にifで分岐するやりかた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val len = 10000000
    val arr = Array.array(len, 0)
    fun
    loop i = if i &amp;lt; len
             then (
                 Array.update(arr, i, 1);
                 loop (i + 1))
             else ()
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop 0
                                     handle Subscript =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 96 ms/1calls
  [Average] 96.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;倍くらい遅くなってますね。&lt;/p&gt;

&lt;p&gt;ということでみだりに境界チェックするより例外を出させといた方が速いようです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第一級ラベルを持たない言語におけるDirect Threaded VMの実装</title>
      <link>/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou</link>
      <pubDate>Fri, 29 May 2015 20:26:41 +0900</pubDate>
      
      <guid>/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou</guid>
      <description>

&lt;p&gt;こんにちは。κeenです。このブログでちょくちょく出てくるDirect Threaded VMについて。
SMLのようにgotoがない言語だとDT VMの実装出来ないよなー、と思ってた所、ふとアイディアが浮かんだのでそれについて。&lt;/p&gt;

&lt;h1 id=&#34;序論&#34;&gt;序論&lt;/h1&gt;

&lt;p&gt;DSL、例えば正規表現などの処理系を実装することを考えてみて下さい。&lt;/p&gt;

&lt;p&gt;言語処理系において最も素朴な実装はインタプリタですが、速度面で不利なので一旦仮想命令にコンパイルして仮想命令実行器(VM)で実行することが一般的です。
コンパイラのように複雑な記号処理をするプログラムはCommon LispやMLのような記号処理に強い高級言語が得意とする分野です。
一方、ランタイムには低レベルなことが出来て処理速度の速いCommon LispやCを使いたくなるでしょう。&lt;/p&gt;

&lt;p&gt;Common Lisp以外の言語ではコンパイラとランタイムを分離するのが妥当な選択肢のようですが、高級言語とcの間のブッジングが必要になり、少なからぬコストを支払う必要があります。
また、ffiを持たない言語ではブリッジ出来ないのでランタイムもその言語で実装する必要があります。つまり、高級言語でVMを実装する必要があるケースが存在します。&lt;/p&gt;

&lt;p&gt;VMの実行を高速化する技術の一つとしてDirect Threadingというものがあります。
命令ディスパッチのループを短絡することで余計なオーバーヘッドが減り、また、命令毎にジャンプ命令を持つことで分岐予測も効きやすくなるのでVMが高速化します。
しかしDTの実装にはgotoのラベルを第一級オブジェクトとして保存する必要があり、gccやclangのように拡張されたcコンパイラなど、限られた言語でしか実現出来ません。まあ、Common Lispなら&lt;code&gt;eval&lt;/code&gt;と&lt;code&gt;compile&lt;/code&gt;を使えばJITが出来るので不要ですが。&lt;/p&gt;

&lt;p&gt;そこで、gotoのない言語でDirect Threadingを実現してみたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;direct-threading&#34;&gt;Direct Threading&lt;/h1&gt;

&lt;p&gt;Direct Threaded &lt;em&gt;でない&lt;/em&gt; VMは大抵次のような構造をしています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loop {
  op = fetchNextOp
  switch(op) {
    case op1:
     ....
     break
    case op2:
     ....
     break
    ....
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;次の命令を取得する&lt;/li&gt;
&lt;li&gt;命令でディスパッチする&lt;/li&gt;
&lt;li&gt;命令に対応するコードを実行する&lt;/li&gt;
&lt;li&gt;ディスパッチを抜ける&lt;/li&gt;
&lt;li&gt;1.に戻る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という動きをします。自然に思えるかもしれませんが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;命令のディスパッチはlogオーダの時間が掛かる（可能性がある）。&lt;/li&gt;
&lt;li&gt;4. 5. のステップが不要&lt;/li&gt;
&lt;li&gt;2. で毎回違う命令にディスパッチするので分岐予測がほぼ意味を成さない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という無駄があります。それを改良したのがDirect Threaded VMで、オペコードではなくgotoのラベルを使うことで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;label = fetchNextLabel
goto label
label1:
  ...
  label = fetchNextLabel
  goto label
label2:
  ...
  label = fetchNextLabel
  goto label
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;次のラベルを取得する&lt;/li&gt;
&lt;li&gt;ラベルにgotoする&lt;/li&gt;
&lt;li&gt;命令に対応するコードを実行する&lt;/li&gt;
&lt;li&gt;次のラベルを取得する&lt;/li&gt;
&lt;li&gt;ラベルにgotoする(次の処理は3. 相当)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;と、ループ内の2ステップを飛ばした他、ディスパッチもなくなるので高速になります。
また、ラベル毎にgotoがついていて、それぞれのgotoに分岐予測があるので普通のVMに比べて分岐予測がある程度効きます。&lt;/p&gt;

&lt;h1 id=&#34;第一級ラベルを持たない言語におけるdirect-threaded-vm&#34;&gt;第一級ラベルを持たない言語におけるDirect Threaded VM&lt;/h1&gt;

&lt;p&gt;結論から言うと関数の配列を使います。ラベルの代わりに配列のインデックス、gotoの代わりに配列へのアクセスとcallを使います。
ランダムアクセスでアドレスの取得をするために配列を、任意コードへのジャンプのために関数を使えばエミュレート出来るよねって発想です。&lt;/p&gt;

&lt;h1 id=&#34;実装&#34;&gt;実装&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/SML-VM&#34;&gt;ソースコード全体&lt;/a&gt;はGithuに上げてます。SML/NJで動きます。SML#向けのインターフェースファイルを書いていますが何故かコンパイルが通りません。&lt;/p&gt;

&lt;p&gt;次のようなASTを実行するインタプリタ、VM、Direct Threaded VMを実装しました。但し、VMとDTVMはクロージャをサポートしていません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype monoop
  = Not

datatype binop
  = Equal
  | GreaterThan
  | Add

datatype t
  = Int of int
  | Bool of bool
  | MonoOp of monoop * t
  | BinOp of binop * t * t
  | Bind of t * t
  | If of t * t * t
  | Var of string
  | Lambda of t list * t
  | Call of t * t list
  | Progn of t list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インタプリタはこのASTを解釈実行、VMはいくつかの中間表現を経てオペコードにコンパイルし、それを実行します。尚、最適化は行いません。&lt;/p&gt;

&lt;p&gt;VMのディスパッチ部分は次のような実装になっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;    fun aux () = (
        case  (Array.sub(ops, !pc)) of
            O.Not =&amp;gt; (case pop vm of
                         V.Bool x =&amp;gt; push vm (V.Bool (not x))
                       | _ =&amp;gt; raise Type)
          | O.Add =&amp;gt; (case (pop vm, pop vm) of
                         (V.Int x, V.Int y) =&amp;gt; push vm (V.Int (x + y))
                       | _ =&amp;gt; raise Type)
          | O.Eq =&amp;gt; (case (pop vm, pop vm) of
                        (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x = y))
                      | (V.Bool x, V.Bool y) =&amp;gt; push vm (V.Bool (x = y))
                      | _ =&amp;gt; raise Type)
          | O.Gt =&amp;gt; (case (pop vm, pop vm) of
                        (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x &amp;lt; y))
                      | _ =&amp;gt; raise Type)
          | O.Jump label =&amp;gt; pc := (label - 1)
          | O.Jtrue label =&amp;gt; (case pop vm of
                                 V.Bool true =&amp;gt; pc := (label - 1)
                               | V.Bool false =&amp;gt; ()
                               | _ =&amp;gt; raise Type)
          | O.Call i =&amp;gt; (case (pop vm) of
                            V.Lambda label =&amp;gt; (
                             pushCi vm;
                             fp := (!fp) - i;
                             pc := (label - 1))
                          | _ =&amp;gt; raise Type)
          | O.Ret =&amp;gt; (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1));
                     popCi vm;
                     pc := (!pc))
          | O.Push v =&amp;gt; push vm v
          | O.Pop =&amp;gt; (pop vm;())
          | O.Lref i =&amp;gt; push vm (Array.sub(stack, (!fp) + i))
          | O.Lset i =&amp;gt;  ((Array.update(stack, (!fp) + i, pop vm));
                         push vm (V.Bool true))
          | O.Gref i =&amp;gt; push vm (Array.sub(pool, i))
          | O.Gset i =&amp;gt;  (Array.update(pool, i, pop vm); push vm (V.Bool true))
          | O.Nop =&amp;gt; ()
          | O.End =&amp;gt; raise Exit
      ;
        pc := (!pc) + 1;
      aux ())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DT VMではこれを次のように書き換えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun next () = let
    val () = pc := (!pc) + 1;
    val (index, arg) = Array.sub(cops, !pc) in
    Array.sub(opArray, index) arg
end

Array.fromList [
            (* Not *)
            fn _ =&amp;gt;
                (case pop vm of
                    V.Bool x =&amp;gt; push vm (V.Bool (not x))
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Add *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Int (x + y))
                  | _ =&amp;gt; raise Type;
                 next ()),
            (* Eq *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x = y))
                  | (V.Bool x, V.Bool y) =&amp;gt; push vm (V.Bool (x = y))
                  | _ =&amp;gt; raise Type;
                  next ()),
            (* Gt *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x &amp;lt; y))
                  | _ =&amp;gt; raise Type;
                 next ()),
            (* Jump *)
            fn ({int = label, ...}: oparg) =&amp;gt;
               (pc := (label - 1);
               next ()),
            (* Jtrue *)
            fn ({int = label, ...}: oparg) =&amp;gt;
                (case pop vm of
                    V.Bool true =&amp;gt; pc := (label - 1)
                  | V.Bool false =&amp;gt; ()
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Call *)
            fn ({int = i, ...}: oparg) =&amp;gt;
                (case (pop vm) of
                    V.Lambda label =&amp;gt; (
                     pushCi vm;
                     fp := (!fp) - i;
                     pc := (label - 1))
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Ret *)
            fn _ =&amp;gt;
                (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1));
                 popCi vm;
                 pc := (!pc);
                next ()),
            (* Push *)
            fn ({vmvalue = v, ...}: oparg) =&amp;gt;
               (push vm v;
               next ()),
            (* Pop *)
            fn _ =&amp;gt;
               (pop vm;
                next ()),
            (* Lref *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (push vm (Array.sub(stack, (!fp) + i));
               next ()),
            (* Lset *)
            fn ({int = i, ...}: oparg) =&amp;gt;
                ((Array.update(stack, (!fp) + i, pop vm));
                 push vm (V.Bool true);
                next ()),
            (* Gref *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (push vm (Array.sub(pool, i));
               next ()),
            (* Gset *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (Array.update(pool, i, pop vm);
                push vm (V.Bool true);
               next ()),
            (* Nop *)
            (fn _ =&amp;gt;
                next ()),
            (fn _ =&amp;gt;
                raise Exit)
        ]

fun aux () = let val (index, arg) = Array.sub(cops, !pc) in
                 Array.sub(opArray, index) arg
             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1引数を受け取ってunitを返す関数の配列としてVMを表しています。
1つ注意点として、前処理としてタグ付き共用体として表されている命令をタグ(配列のインデックス)と共用体に分解するのですが、SMLに共用体はないので構造体で代用しています。 &lt;code&gt;oparg&lt;/code&gt; 型がそれにあたります。&lt;/p&gt;

&lt;p&gt;ディスパッチを関数&lt;code&gt;next&lt;/code&gt;に括り出していて、一見すると分岐予測に関する利点が失われるように思われますが、
&lt;code&gt;next&lt;/code&gt;は小さいのでインライン化されるだろうと踏んでそのままにしています。実際、手動でインライン化しても速度に変化はありませんでした。&lt;/p&gt;

&lt;p&gt;今回のメインの話はVMなのでインタプリタについては省略します。&lt;/p&gt;

&lt;h1 id=&#34;実行速度&#34;&gt;実行速度&lt;/h1&gt;

&lt;h2 id=&#34;予測&#34;&gt;予測&lt;/h2&gt;

&lt;p&gt;普通のVMはディスパッチをlogオーダーの時間で行ないますがDT VMは定数オーダーの時間で行ないます。しかし配列の参照と関数呼び出しを挟むので定数倍の部分は大きくなります。
どちらが速いでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;計測&#34;&gt;計測&lt;/h2&gt;

&lt;p&gt;今回、次のようなフィボナッチ数列を計算するコードの実行速度を計測しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun fib n = (Progn [
                Bind (Var &amp;quot;fib&amp;quot;,
                      Lambda([Var &amp;quot;n&amp;quot;],
                               (If (BinOp(GreaterThan,
                                          (Int 2),
                                          (Var &amp;quot;n&amp;quot;)),
                                    Int(1),
                                    BinOp(Add,
                                          Call(Var &amp;quot;fib&amp;quot;, [BinOp(Add,
                                                                 Var &amp;quot;n&amp;quot;,
                                                                 Int ~1)]),
                                          Call(Var &amp;quot;fib&amp;quot;, [BinOp(Add,
                                                                 Var &amp;quot;n&amp;quot;,
                                                                 Int ~2)])))))),
                Call(Var &amp;quot;fib&amp;quot;, [Int n])])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンパイラは以下のような命令列を吐きます。命令の内部表現が違うだけで命令列自体はVMとDTVMで共通です。
繰り返しますが、最適化はしてないのでL25で次の命令にジャンプしてるだとか目に見えて無駄なコードもあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0	Push Lambda 7
1	Gset 0
2	Pop
3	Push 35
4	Gref 0
5	Call 1
6	End
7	Push 2
8	Lref 0
9	Gt
10	Jtrue 12
11	Jump 14
12	Push 1
13	Jump 26
14	Lref 0
15	Push ~1
16	Add
17	Gref 0
18	Call 1
19	Lref 0
20	Push ~2
21	Add
22	Gref 0
23	Call 1
24	Add
25	Jump 26
26	Ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;計測には次のようなコードを使いました。コンパイラは実行効率を無視して書いたのでベンチマークには含めていません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val target = (AST.fib 35)
val compiled = VM.compile target
val dtcompiled = DTVM.compile target
val vm = VM.new ()
val dtvm = DTVM.new ()

val _ = Benchmark.benchset &amp;quot;fib 35&amp;quot; 1 [
        (&amp;quot;Interpreter&amp;quot;,
         fn () =&amp;gt; (Interp.run target; ())),
        (&amp;quot;Normal VM&amp;quot;,
         fn () =&amp;gt; (VM.run vm compiled; ())),
        (&amp;quot;Direct Threaded VM&amp;quot;,
         fn () =&amp;gt; (DTVM.run dtvm dtcompiled; ()))
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;Intel Core i5 M450 2.4GHz 2コア4スレッド、Ubunt 15.04、SML/NJ v110.77で実行しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-------------------+---------------------------------------------------
 Interpreter       |********************************************* 47170ms
 Normal VM         |****************** 19170ms
 Direct Threaded VM|************************************************** 51460ms
-------------------+---------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ダントツで速いのがVMで、インタプリタに比べてかなりの性能向上が見られます。一方DT VMはインタプリタより遅いという結果になりました。&lt;/p&gt;

&lt;h1 id=&#34;考察&#34;&gt;考察&lt;/h1&gt;

&lt;p&gt;冷静に考えたらインタプリタは毎回関数呼び出して遅いよねってことからループで処理を済ませるのがVMなのにVMで毎回関数を呼び出してたら遅いに決まってるじゃん。
というかこれ、Direct Threaded VMじゃないじゃん。死にたい。&lt;/p&gt;

&lt;h1 id=&#34;余談&#34;&gt;余談&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/604235677337714689&#34;&gt;2015, 5月 29&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;尚、このつぶやきはfibの引数を小さくして繰り返しを増やした時のものです。多分コンパイルを外に出してるので繰り返しが多いとその分のオーバーヘッドの差が効いてくるのでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val target = (AST.fib 24)
val compiled = VM.compile target
val dtcompiled = DTVM.compile target
val vm = VM.new ()
val dtvm = DTVM.new ()

val _ = Benchmark.benchset &amp;quot;fib 24&amp;quot; 10 [
        (&amp;quot;Interpreter&amp;quot;,
         fn () =&amp;gt; (Interp.run target; ())),
        (&amp;quot;Normal VM&amp;quot;,
         fn () =&amp;gt; (VM.run vm compiled; ())),
        (&amp;quot;Direct Threaded VM&amp;quot;,
         fn () =&amp;gt; (DTVM.run dtvm dtcompiled; ()))
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-------------------+---------------------------------------------------
 Interpreter       |************************************************** 2052ms
 Normal VM         |** 104ms
 Direct Threaded VM|***** 238ms
-------------------+---------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>実装から理解するクロージャ</title>
      <link>/slide/jissoukararikaisurukuro_ja/</link>
      <pubDate>Sun, 17 May 2015 01:33:39 +0900</pubDate>
      
      <guid>/slide/jissoukararikaisurukuro_ja/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 実装から理解するクロージャ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

===
# クロージャとは？
-----------------

* 日本語にすると（関数）閉包
* 関数が外側のローカル変数を補足する
* 補足されたローカル変数は無限の生存期間を持つ
  + ローカル変数は本来スコープを抜けると生存期間が終わる
  + 言い換えるとグローバル変数みたいになる
  + でもあくまでスコープはローカル
===
# コード例
---------

```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p = genpower(2);
```
===
# コード例
----------

```js
p()  // =&gt; 2
p()  // =&gt; 4
p()  // =&gt; 8
x * 2 // x is not defined
```

===
# コード例
----------

* `p`が`n`と`x`を補足しているので関数を抜けた後も`x`と`n`は使える。
  + 関数の仮引数もローカル変数。
* でもローカル変数なので外からは見えない。

===

```
+-----------------------+
| function genpower(n){ |
|   var x = 1;          |
| ...   ^               |
| }     |               |
+-----------------------+
        |
 +------+
 |
+-------------+
||function(){ |
|+-- x *= n;  |
|   return x; |
| };          |
+-------------+
```

===

# コード例2
----------

```js
function incdec(){
    var x = 0;
    return [function(){ return ++x;},
            function(){ return --x;}];
}
var fs = incdec();
var inc = fs[0];
var dec = fs[1];
```
===
# コード例2
----------

```js
inc() // =&gt; 1
inc() // =&gt; 2
dec() // =&gt; 1
inc() // =&gt; 2
```
===
# コード例2
----------

* 同じタイミングで作られたクロージャ群は捕捉変数を共有する

===

```
+--------------------+
| function incdec(){ |
|   var x = 0;       |
|   ... ^            |
| }     |            |
+--------------------+
        +--------------+----+
                       |    |
+----------------------|---+|
| function(){ return ++x;} ||
+--------------------------+|
                       +----+
+----------------------|---+
| function(){ return --x;} |
+--------------------------+
```
===
# コード例3
----------

```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p1 = genpower(2);
var p2 = genpower(2);
```
===
# コード例3
----------

```js
p1()  // =&gt; 2
p1()  // =&gt; 4
p2()  // =&gt; 2
p2()  // =&gt; 4
```
===
# コード例3
----------

* 逆に、同じ関数から生まれても違うタイミングなら共有しない。

===
```
+-----------------------+ +-----------------------+
| function genpower(n){ | | function genpower(n){ |
|   var x = 1;          | |   var x = 1;          |
| ...   ^               | | ...   ^               |
| }     |               | | }     |               |
+-----------------------+ +-----------------------+
        |                         |
 +------+                  +------+
 |                         |
+-------------+           +-------------+
||function(){ |           ||function(){ |
|+-- x *= n;  |           |+-- x *= n;  |
|   return x; |           |   return x; |
| };          |           | };          |
+-------------+           +-------------+

```
===
# 実装方法
----------

* ここでは複数ある実装方法のうちの1つを紹介する。
* 言語はVM型のインタプリタ（大抵のインタプリタの実装に同じ）を仮定する

===
# 用語整理
----------
* `outer`から見たら`x`は捕捉(Captured)変数
  + `inner`から捕捉されてるから
* `inner`から見たら`x`は自由(Free)変数
  + `inner`からしたら`x`は知らない子だから

```js
function outer(x) {
    function inner(y){
        return x * y;
    }
}
```

===
# 実装概要
----------

* **クロージャとは捕捉変数の集まり**
  + つまり、捕捉した側ではなくされた側が作る
  + 捕捉した側は作られたものを参照するだけ
===
# 変数の話
---------

* グローバル変数はヒープ領域に置かれる
  + グローバル DB（大抵巨大なハッシュテーブル）に登録される
* ローカル変数はコールスタックに置かれる
  + 配列が作られ、インデックスでアクセスされる感じ。
  + ローカル変数の数は関数定義時に決定するので配列で管理出来る
  + 関数の実引数も同じように置かれる
===
# 捕捉変数の話
-------------

* 捕捉変数はヒープ領域に置かれる
  + 簡単には小さなハッシュテーブルに登録される
    - つまり、グローバル変数と同じ
    - 捕捉変数も関数定義時に決定するので配列でも管理出来る
  + ハッシュテーブル/配列はクロージャ毎に作られる

※ [本気出した実装](http://practical-scheme.net/docs/stack-j.html)だとコールスタックでどうにかすることもある
===
```js
var g = 1;
function sample(a) {
    var l = 2;
    var c = 3;
    return function(){ return c;};
}
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

```
| ....          |
|---------------|
| args[0] = _   | a
|---------------| 
| locals[0] = 1 | var l
|---------------|--コールスタック↑--
| ....          |
| ....          |
|---------------|--ヒープ領域↓--
| caps[c] = 3   | var c = 3
|---------------|
| global[g] = 1 | var g = 1
| global[_] = _ |
| ....          |
| ....          |

```
===
```js
function incdec(){
    var x = 0;
    return [function(){ return ++x;},
            function(){ return --x;}];
}
var fs = incdec();
var inc = fs[0];
var dec = fs[1];
```
===
```
| ....          |
|---------------|--ヒープ領域↓--
| caps[x] = 0 &lt;-++------------------------+
|---------------|| +----------------------|---+
| global[_] = _ || | function(){ return ++x;} |
| ....          || +--------------------------+
| ....          |+------------------------+
| ....          |  +----------------------|---+
| ....          |  | function(){ return --x;} |
| ....          |  +--------------------------+
| ....          |
| ....          |
| ....          |

```
===
```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p1 = genpower(2);
var p2 = genpower(2);
```
===
AA略

```
| ....          |
|---------------|--ヒープ領域↓--
| caps[x] = 0 &lt;-+-|p1|
|---------------|
| caps[x] = 0 &lt;-+-|p2|
|---------------|
| global[_] = _ |
| ....          |
| ....          |

```

===
# 捕捉変数の実装
-----------------

* クロージャ毎にcapturedが作られる
* capturedとlocalはソース上の見た目は似ているが実装は大きく異なる
  + 多分この所為で分かりづらい
* グローバルアクセス出来ないだけでグローバル変数に似ている
===
# まとまってないけどまとめ
-------------------------

* クロージャについて説明した
* クロージャの正体は捕捉変数の集まり
* 捕捉変数はヒープ領域に置かれるローカルスコープな変数

※あくまで実装の1例です

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>誰がUTF-32が使われてないなんて言ったんだ</title>
      <link>/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</link>
      <pubDate>Tue, 31 Mar 2015 19:41:05 +0900</pubDate>
      
      <guid>/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</guid>
      <description>

&lt;p&gt;最近ではUTF-8でソースコードを書いてUTF-8で出入力をする。それ以外のエンコーディングは使われていない。…だと？誰がそんなこと言ったんだ&lt;/p&gt;

&lt;h1 id=&#34;asciiと古いunicodeと新しいunicode&#34;&gt;ASCIIと古いUnicodeと新しいUnicode&lt;/h1&gt;

&lt;p&gt;少し長くなるが文字コードの話から始まる。ASCIIはお馴染み最低7bitあればASCIIの定義する文字集合を表せる。&lt;/p&gt;

&lt;p&gt;古いUnicodeは16bitで全ての文字を表わすことを目標に作られた。&lt;/p&gt;

&lt;p&gt;新しいUnicodeは文字(主に漢字)が多過ぎて16bitでは表せなかったので21bitに拡張された。&lt;/p&gt;

&lt;h1 id=&#34;文字コードとエンコーディング&#34;&gt;文字コードとエンコーディング&lt;/h1&gt;

&lt;p&gt;文字コードをどういう形式で表すかがエンコーディングだ。文字コードが7bit、16bit、21bitだからといってそのままのサイズで表わす訳ではない。ASCIIは普通8bitの型で表わすし21bitの型を用意するよりは32bitの型に格納した方が扱い易そうだ。あるいは8bit型の配列に16bitや21bitを収めるとプログラムコードの変更が少なそうだ。&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32&#34;&gt;UTF-8とUTF-16とUTF-32&lt;/h1&gt;

&lt;p&gt;さて、ここまで来ればお分かりだろう。UTF-8はASCIIとの互換性を保つ8bitベースのエンコーディング、UTF-16は古いUnicodeの時に作られて新しいUnicodeにも対応した16bitベースのエンコーディング、UTF-32は新しいUnicodeのために作られた32bitベースのエンコーディングだ。
ここで注意して欲しいのはUTF-8とUTF-16は8bitや16bitの単位を複数使うことで新しいUnicodeの範囲も扱える点、逆に言えば1単位が1文字に対応しない点だ。日本語を含んだ文字列に対して&lt;code&gt;length&lt;/code&gt;を使うと正しい結果が帰って来ないなどの経験は誰しもあるだろう&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32それぞれの特徴&#34;&gt;UTF-8とUTF-16とUTF-32それぞれの特徴&lt;/h1&gt;

&lt;h2 id=&#34;utf-8&#34;&gt;UTF-8&lt;/h2&gt;

&lt;p&gt;8bit(オクテット)の配列に文字列を収めることになる。16bitや21bitの範囲の文字を表す時は8bitに対してASCIIは7bitしか使わないのでその1bitを使って次に続くことを表わす。最大4オクテットまで使うことがある。 UTF-8の特徴はなんと言ってもASCIIとの互換性があること。UTF-8でASCIIの範囲のみの文字をエンコードするとASCIIと同一になるし、ASCIIでエンコードされたものはUTF-8で読んでも同じ内容になる。なのでどんなエンコードか分からないものはとりあえずUTF-8で読んでおくと間違いが少ない。よって冒頭で書いたように出入力、保存ファイル、GUIに表示する文字列などに使われる。&lt;/p&gt;

&lt;p&gt;UTF-8にも欠点はあり、ASCII外の文字を大量に扱うと空間効率が悪い。さらに先頭から順番に辿らないとどのオクテットが何文字目かも分からないので(配列長が既知であっても)文字列へのlengthやランダムアクセスなどの多くの操作がO(n)になってしまう点だ。文字の置換に至ってはin placeでは出来ないことすらある。&lt;/p&gt;

&lt;h2 id=&#34;utf-16&#34;&gt;UTF-16&lt;/h2&gt;

&lt;p&gt;16bitの配列に文字列を収める。21bitまで扱うために特定の範囲の値が来たら次の16bitも読んで2つ併わせて1つの文字とみなす。このペアをサロゲートペアという。C言語には&lt;code&gt;wchar&lt;/code&gt;なるマルチバイト文字用の型があるが、仕様では最低で16bitという要求になっているのでwcharを使う時はUTF-16でエンコードする（と思う）。UTF-16もUTF-8と同じく文字列操作がO(n)になる。Unicode公式のエンコーディングであるという点を除いて特に良い点が見当たらないので後方互換性の必要な場面でないと使われてなさそうな気がする。例えばWindowsのファイルシステムはファイル名をUTF-16で保持しているらしい。&lt;/p&gt;

&lt;p&gt;尚、16bitのエンディアンは指定されてないのでファイルの先頭にバイトオーダーマーク(BOM)と呼ばれる空白文字を置いてそれでエンディアンを指定/判別する慣習になっている。&lt;/p&gt;

&lt;h2 id=&#34;utf-32&#34;&gt;UTF-32&lt;/h2&gt;

&lt;p&gt;32bitの配列に文字列を収める。必ず32bitで1文字を表すので文字列操作が効率的に行なえる。欠点はASCIIの範囲の文字が多いとメモリを無駄にし易い点。どんな文字列を扱うか分からない(ASCIIの範囲が多いとは言い切れない)汎用ライブラリや言語処理系そのものでよく使われる。&lt;/p&gt;

&lt;h1 id=&#34;言語処理系の内部表現と外部エンコーディング&#34;&gt;言語処理系の内部表現と外部エンコーディング&lt;/h1&gt;

&lt;p&gt;ここで罠になるのがソースコードをUTF-8で書いて出入力をUTF-8で行なう処理系でも内部では先述の理由でUTF-8以外を使うことがあることだ。メジャーな言語について少し調べてみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SBCL(Common Lispのメジャーな処理系)はUTF-32を使う&lt;/li&gt;
&lt;li&gt;SpiderMonkey(FirefoxのJavaScript処理系)はUTF-8を使う。HTMLはマルチバイト文字を使う言語で書かれていても大半がASCIIになるからとのこと。また、文字列をropeで表現しており、UTF-8のデメリットを軽減出来る。&lt;/li&gt;
&lt;li&gt;Rubyは多言語対応の時に内部表現はなんでもアリ(渡された文字列そのまま)になった&lt;/li&gt;
&lt;li&gt;PerlはUTF-8を使う&lt;/li&gt;
&lt;li&gt;PythonはconfigureのオプションでUCS2(ほぼUTF-16に同じ)やUCS4(UTF-32形式のUnicodeと概ね互換)が選べる。FedoraやUbuntuはUCS4でビルドしている&lt;/li&gt;
&lt;li&gt;PHPは言語で動的に変更出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ソースコードをUTF-8で書いて出入力をUTF-8で行なうから変換コストなんてないと思ったら大間違いだ。裏ではUTF-32が使われていて、出入力の度に変換が走る。誰がUTF-32が使われてないなんて言ったんだ。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>