<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/lisp/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-11-27T16:51:50+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Semantic S式]]></title>
    <link href="http://KeenS.github.io/slide/semantic-sshi.html"/>
    <updated>2014-11-27T15:30:00+09:00</updated>
    <id>http://KeenS.github.io/slide/semantic-sshi.markdown</id>
    <content type="html"><![CDATA[<h1>Semantic S式</h1>

<hr />

<p>2014-11-27<br/>
κeen(@blackenedgold)</p>

<h1>About Me</h1>

<hr />

<p><img src="/images/icon.png" alt="κeenのアイコン" /></p>

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
</ul>


<h1>Semantic Web とは</h1>

<h1><a href="http://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A6%E3%82%A7%E3%83%96">Semantic Web</a></h1>

<hr />

<ul>
<li>W3C のティム・バーナーズ＝リーが提唱</li>
<li>文章の見た目を記述するんじゃなくて構造を記述しよう</li>
<li>そうすると機械がクローリングするの楽になるよね</li>
</ul>


<h1>Semantic S式とは</h1>

<h1>Semantic S式</h1>

<hr />

<ul>
<li>Shibuya.lispのκeenが提唱 (昨日思い付いた)</li>
<li>S式の見た目じゃなくて構造で括弧をつけよう</li>
<li>そうするとコーディングが楽になるよね</li>
</ul>


<h1>良いところ</h1>

<hr />

<ol>
<li>意味が分かり易い</li>
<li>パースし易い</li>
<li>編集が楽になる</li>
<li>壊れにくい</li>
</ol>


<h1>1. 意味が分かり易い</h1>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例1</h2>

<ul>
<li><p>Clojure
<code>clojure
(let [a 1
      b 2]
  ...)
</code></p></li>
<li><p>Common Lisp
<code>lisp
(let ((a 1)
      (b 2))
  ....)
</code>
どっちが分かり易い？</p></li>
</ul>


<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例1</h2>

<p>（日本語にしてみる（イメージ））</p>

<ul>
<li>Clojure<br/>
aを1bを2とする</li>
<li>Common Lisp
<table border="1"><tr><td><code>a</code></td><td>1</td></tr><tr><td><code>b</code></td><td>2</td></tr></table>
とする</li>
</ul>


<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例2</h2>

<p>何をしてる？</p>

<p>```lisp
(destructuring-bind (a b)</p>

<pre><code>(some-function)
</code></pre>

<p>  &hellip;)
```</p>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例2</h2>

<p>何をしてる？</p>

<p>```lisp
(destructuring-bind ((a b)</p>

<pre><code>(some-function))
</code></pre>

<p>  &hellip;)
```</p>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例3</h2>

<p>これの返り値は？
<code>lisp
(getf '(:hoge :foo :huga :baz :piyo :pon :chun) :pon)
</code></p>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例3</h2>

<p>これの返り値は？
<code>lisp
(assoc :pon '((:hoge :foo) (:huga :baz) (:piyo :pon) (:chun)))
</code></p>

<h1>2. パースし易い</h1>

<h1>2. パースし易い</h1>

<hr />

<h2>例</h2>

<ul>
<li><p>Clojure
<code>clojure
(let [a 1
      b 2]
  ...)
</code></p></li>
<li><p>Common Lisp
<code>lisp
(let ((a 1)
      (b 2))
  ....)
</code>
どっちが実装し易い？</p></li>
</ul>


<h1>2. パースし易い</h1>

<hr />

<ul>
<li>Common Lispの方は意味で分割してある</li>
<li>括弧は無くてもパースは出来る</li>
<li>機械にパースし易い≒人間にパースし易い</li>
</ul>


<h1>3. 編集が楽になる</h1>

<h1>3. 編集が楽になる</h1>

<hr />

<h2>前提</h2>

<ul>
<li>エディタに文/式/トークン(Lispの場合は全てS式)単位の編集機能がある

<ul>
<li>S式単位でカーソル移動</li>
<li>S式単位の削除/カット</li>
<li>S式単位のスワップ</li>
<li>etc&hellip;.</li>
</ul>
</li>
</ul>


<h1>3. 編集が楽になる</h1>

<hr />

<h2>例（偶によくある）</h2>

<p>この<code>c</code>の束縛を上のletに持っていきたいときどうする？</p>

<p>```lisp
(let ((a 1)</p>

<pre><code>  (b 2))
</code></pre>

<p>  &hellip;.
  (let ((c 3)</p>

<pre><code>    (d 4))
...))
</code></pre>

<p>```</p>

<h1>3. 編集が楽になる</h1>

<hr />

<h2>例（偶によくある）</h2>

<ul>
<li>意味で括弧をつけていれば1カット移動1ペースト</li>
<li>Clojure方式だと2カット移動1ペースト</li>
<li><code>c</code>だけじゃなくて<code>d</code>も、と考えると…</li>
</ul>


<h1>4. 壊れにくい</h1>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>ageの計算が壊れているとする</p>

<p><code>lisp
(:name "κeen"
 :age  (year-of-time-interval (date- (today) (date 1992 5 17)))
 :place "Shibuya")
</code></p>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>コメントアウトしてみる（壊れた）</p>

<p><code>lisp
(:name "κeen"
 :age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 :place "Shibuya")
</code></p>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>ageの計算が壊れているとする</p>

<p><code>lisp
((:name "κeen")
 (:age  (year-of-time-interval (date- (today) (date 1992 5 17))))
 (:place "Shibuya"))
</code></p>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>(エディタサポートあり)</p>

<p>コメントアウトしてみる（壊れない）</p>

<p><code>lisp
((:name "κeen")
 (:age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 )
 (:place "Shibuya"))
</code></p>

<h1>ここまでのまとめ</h1>

<hr />

<ul>
<li>構造が文脈に依存していると

<ul>
<li>人間に分りづらい</li>
<li>プログラムに分りづらい</li>
<li>エディタに分りづらい</li>
<li>壊れやすい</li>
</ul>
</li>
</ul>


<h1>Q. When Semantic?</h1>

<hr />

<h2>A. 言語を設計するとき <!-- .element: class="fragment" data-fragment-index="1" --></h2>

<ul>
<li>つまりマクロを書くとき <!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>


<h1>Q. When Semantic?</h1>

<hr />

<h2>A. 言語を設計するとき</h2>

<ul>
<li>マクロを書くときそれなりのDSLを設計する</li>
<li>プログラム上は必須ではない括弧もあった方が良いときもある</li>
</ul>


<h1>まとめ</h1>

<hr />

<ul>
<li>括弧が少ない方が書き易いとは限らない

<ul>
<li>「書く」だけなら速くてもwrite onlyになってしまうかも<!-- .element: class="fragment" data-fragment-index="1" --></li>
</ul>
</li>
<li>プログラムの意味を考えながら括弧つけよう

<ul>
<li>Lisperはどうせ括弧は見えない<!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>
</li>
</ul>


<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Get Clojure Faster]]></title>
    <link href="http://KeenS.github.io/slide/get-clojure-faster.html"/>
    <updated>2014-10-28T21:35:00+09:00</updated>
    <id>http://KeenS.github.io/slide/get-clojure-faster.markdown</id>
    <content type="html"><![CDATA[<h1>Get Clojure Faster</h1>

<hr />

<p>2014-10-28<br/>
κeen(@blackenedgold)</p>

<h1>About Me</h1>

<hr />

<ul>
<li>κeen<img src="/images/icon.png" alt="κeenのアイコン" /></li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
</ul>


<h1><code>lein repl</code></h1>

<hr />

<p><code>
$ time  lein repl &lt;/dev/null
...
snip
...
lein repl &lt; /dev/null  23.05s user 0.97s system 159% cpu 15.048 total
</code></p>

<p>起動に20秒…</p>

<h1>drip</h1>

<hr />

<ul>
<li>JVMの起動時間を速くすくやつ</li>
<li>類似プロジェクトにCakeやNailgun</li>
<li>でもCakeやNailgunの踏んだ地雷は避ける

<ul>
<li>JVMサーバを使い回すのではなく起動イメージを準備</li>
<li>Common Lispでのコアダンプに近い？</li>
</ul>
</li>
</ul>


<h1>drip</h1>

<hr />

<h2>導入</h2>

<p><code>
curl -L http://drip.flatland.org &gt; ~/bin/drip
chmod 755 ~/bin/drip
</code>
又は</p>

<p><code>
git clone https://github.com/flatland/drip.git
cd drip &amp;&amp; make prefix=~/bin install
</code>
そして
<code>
export LEIN_JAVA_CMD=drip
</code></p>

<h1>drip</h1>

<hr />

<h2>結果</h2>

<p><code>
$ time  lein repl &lt;/dev/null
lein repl &lt; /dev/null  0.11s user 0.27s system 6% cpu 6.153 total
</code></p>

<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[claspを少し触ってみた]]></title>
    <link href="http://KeenS.github.io/slide/clasp.html"/>
    <updated>2014-10-28T16:17:00+09:00</updated>
    <id>http://KeenS.github.io/slide/clasp.markdown</id>
    <content type="html"><![CDATA[<h1>claspを少し触ってみた</h1>

<hr />

<p>Lisp Meet Up presented by Shibuya.lisp #21<br/>
2014-10-29<br/>
κeen(@blackenedgold)</p>

<h1>About Me</h1>

<hr />

<p><img src="/images/icon.png" alt="κeenのアイコン" /> <!-- .element: style="position:relative;right 0;" --></p>

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
</ul>


<h1>clasp</h1>

<hr />

<ul>
<li>Github: <a href="https://github.com/drmeister/clasp">drmeister/clasp</a></li>
<li>2014-09-18に0.1リリース(現在0.11プレビューが出ている)</li>
<li>今は0.11プレビューが出ている</li>
<li>ANSI Common Lisp準拠を目指す(現在80 ~90%)</li>
<li>ECLからのフォーク</li>
<li>LLVMベースのJIT(<a href="http://llvm.org/docs/MCJITDesignAndImplementation.html">MCJIT</a>)搭載</li>
<li>C++とLispで書かれている</li>
<li>C++との連携を意識</li>
</ul>


<p>Note:
C++との連携の部分を強調。今回は0.11プレビューでの話</p>

<h1>メモリ管理</h1>

<hr />

<ul>
<li>Memory Pool Systemと Boehm GCから選べる</li>
<li>ビルドするときにどっちかを選ぶ</li>
</ul>


<h1>メモリ管理</h1>

<hr />

<h2><a href="http://www.hboehm.info/gc/">Boehm GC</a></h2>

<ul>
<li>Mark &amp; Sweepのライブラリ</li>
<li>枯れた有名なライブラリ</li>
<li>Lisp有名どころではGaucheが使う</li>
<li>RedHat系だとこれを使ってないとrpmリジェクトされやすいらしい(?)</li>
</ul>


<p>Note:
他にはMozilla, W3M, GNU GCJ, GNU Obj-Cなどなど</p>

<h1>メモリ管理</h1>

<hr />

<h2><a href="http://www.ravenbrook.com/project/mps/">Memory Pool System</a></h2>

<ul>
<li>複数のGCアルゴリズムを組み合わせて使えるらしい</li>
<li>since 1994</li>
<li>あまり分からないです&gt;&lt;</li>
</ul>


<h1>依存ライブラリ</h1>

<hr />

<ul>
<li>LLVM <strong>3.6</strong></li>
<li>LLVM/clang <strong>3.5</strong> compiler</li>
<li>Boost build v2</li>
<li>boost libraries ver 1.55</li>
<li>Boehm 7.2</li>
<li>gmp-6.0.0</li>
<li>expat-2.0.1</li>
<li>zlib-1.2.8</li>
<li>readline-6.2</li>
</ul>


<p><span style="font-size:600%">無理</span></p>

<h1>externals-clasp</h1>

<hr />

<ul>
<li>Github: <a href="https://github.com/drmeister/externals-clasp">drmeister/externals-clasp</a></li>
<li>依存ライブラリを揃えるのが難しいとの声から作られた</li>
<li>依存ライブラリを全てビルド<!-- .element: class="fragment grow" --></li>
</ul>


<p><span style="font-size:300%">＼LLVMをビルド／</span></p>

<p><span style="font-size:300%">＼Boostをビルド／</span></p>

<p><span style="font-size:200%">ビルド時間はお察しです</span></p>

<h1>本体のビルド</h1>

<hr />

<p>Twitter実況をどうぞ↓↓</p>

<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>clangがメモリ6GB以上食い続けてて怖い。何やってんの。</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526417151486205952">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>clangの起動時間1時間超えてますよ…</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526418636735401984">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>HDDプチプチ言ってるし今にも壊れそう</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526420001587068929">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/nobkz">@nobkz</a> claspのコンパイル中です。&#10;clangなのにIOネックという謎の状態です。</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526420473232367616">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>clangの消費メモリ7GB超えた</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526423982992420864">2014, 10月 26</a></blockquote>


<p><span style="font-size:300%">ビルドは自己責任で</span></p>

<h1>使ってみる</h1>

<hr />

<h2>起動オプション</h2>

<p><code>
/usr/local/clasp/bin/clasp_mps_o --help
clasp options
-I/--ignore-image    - Don't load the boot image/start with init.lsp
-i/--image file      - Use the file as the boot image
-N/--non-interactive - Suppress all repls
-v/--version         - Print version
-s/--verbose         - Print more info while booting
-f/--feature feature - Add the feature to *features*
-e/--eval {form}     - Evaluate a form
-l/--load {file}     - LOAD the file
-r/--norc            - Don't load the ~/.clasprc file
-n/--noinit          - Don't load the init.lsp (very minimal environment)
-s/--seed #          - Seed the random number generator
-- {ARGS}*           - Trailing are added to core:*command-line-arguments*
</code></p>

<h1>使ってみる</h1>

<hr />

<h2>ASDF</h2>

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->動かない

<ul>
<li><!-- .element: class="fragment" data-fragment-index="2" -->ASDFの処理系依存の部分(<code>#+</code>)の問題</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->ECLと見做されるけどECLのコードは動かない</li>
</ul>
</li>
</ul>


<h1>使ってみる</h1>

<hr />

<h2>cl-ppcre</h2>

<ul>
<li><a href="https://gist.github.com/KeenS/4e25cb6e424ebe4e7a4a">手動ロードスクリプト</a></li>
<li><!-- .element: class="fragment" data-fragment-index="1" -->動かない

<ul>
<li><!-- .element: class="fragment" data-fragment-index="2" --><code>schar</code>がない</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->ANSI Common Lispにあるのに…</li>
</ul>
</li>
</ul>


<h1>使ってみる</h1>

<hr />

<h2>C++との連携</h2>

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->ドキュメントがない</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->サンプルコードもない</li>
<li><!-- .element: class="fragment" data-fragment-index="3" -->遂行不能</li>
</ul>


<h1>使ってみる</h1>

<hr />

<h2>LLVMの呼び出し</h2>

<ul>
<li><a href="https://github.com/drmeister/clasp/blob/master/src/llvmo/demo.lsp">clasp/src/llvmo/demo.lisp</a></li>
<li><!-- .element: class="fragment" data-fragment-index="1" -->動かない</li>
</ul>


<h1>使ってみる</h1>

<hr />



<table>
<thead>
<tr>
<th>処理系              </th>
<th>  <code>(time (fib 29))</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>clasp-0.1(boehm)    </td>
<td> <div class="graph fragment" style="width:calc(264.3px * 3);" data-fragment-index="1">26.43s</div></td>
</tr>
<tr>
<td>clasp-0.1(mps)      </td>
<td> <div class="graph fragment" style="width:calc(172.8px * 3);" data-fragment-index="1">17.28s</div></td>
</tr>
<tr>
<td>clasp-0.11(boehm)   </td>
<td> <div class="graph fragment" style="width:calc(213.2px * 3);" data-fragment-index="2">21.32s</div></td>
</tr>
<tr>
<td>clasp-0.11(mps)     </td>
<td> <div class="graph fragment" style="width:calc(187.9px * 3);" data-fragment-index="2">18.79s</div></td>
</tr>
<tr>
<td>ECL-13.5.1          </td>
<td> <div class="graph" style="width:calc( 16.0px * 3);">1.603s</div></td>
</tr>
<tr>
<td>ECL-13.5.1(compile) </td>
<td> <div class="graph" style="width:calc(  1.9px * 3);">0.192s</div></td>
</tr>
<tr>
<td>ABCL-1.3.1          </td>
<td> <div class="graph" style="width:calc( 32.9px * 3);">3.292s</div></td>
</tr>
<tr>
<td>ABCL-1.3.1(compile) </td>
<td> <div class="graph" style="width:calc(  2.4px * 3);">0.241s</div></td>
</tr>
</tbody>
</table>


<h1>使ってみる</h1>

<hr />

<table>
<thead>
<tr>
<th>処理系              </th>
<th>  <code>(time (fib 29))</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>CLISP-2.49          </td>
<td> <div class="graph" style="width:calc( 38.4px * 3);">3.847s</div></td>
</tr>
<tr>
<td>CLISP-2.49(compile) </td>
<td> <div class="graph" style="width:calc(  7.1px * 3);">0.7146s</div></td>
</tr>
<tr>
<td>ccl-1.10            </td>
<td> <div class="graph" style="width:calc(  0.4px * 3);">0.04033s</div></td>
</tr>
<tr>
<td>sbcl-1.2.5          </td>
<td> <div class="graph" style="width:calc(  0.6px * 3);">0.06469s</div></td>
</tr>
<tr>
<td>alisp-9.0           </td>
<td> <div class="graph" style="width:calc(  230px * 3);">23.09s</div></td>
</tr>
<tr>
<td>alisp-9.0(compile)  </td>
<td> <div class="graph" style="width:calc(  0.6px * 3);">0.06194s</div></td>
</tr>
</tbody>
</table>


<p><span style="font-size:200%">LLVM/JITなのになぜ遅い？</span></p>

<h1>LLVM/JITで遅い？</h1>

<hr />

<ul>
<li>LLVMって速いんじゃ？</li>
<li>JIT搭載した○○が速いって聞いたよ

<ul>
<li>JVM</li>
<li>lua-jit</li>
<li>Rubinius</li>
<li>pypy</li>
</ul>
</li>
</ul>


<h1>言葉の罠: LLVM</h1>

<hr />

<ul>
<li>遅いコードはどんなに頑張っても遅い</li>
<li>ECLのバックエンドにClang(=LLVM)を使ってもSBCLに勝てないのと同じ</li>
</ul>


<h1>言葉の罠: JIT搭載</h1>

<hr />

<ul>
<li>JIT(実行時コンパイル)の意味は広い</li>
<li>実行時にネイティブコードを吐けばJITと言える</li>
<li>claspは実行直前にコンパイルするだけ</li>
<li>多くの速いJIT処理系はTracing JITを使う

<ul>
<li>またの名を適応的コンパイル</li>
<li>実行時の情報に基いて実行中に最適化する</li>
<li><code>(declare ...)</code> を自動生成してる的な</li>
</ul>
</li>
</ul>


<h1>Tracing JITへの道</h1>

<hr />

<ul>
<li>LLVMのJITは実行直前にコンパイルするだけ

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->Tracing JITのバックエンドには使える</li>
</ul>
</li>
<li>実行時最適化には最適化用のコードが必要

<ul>
<li><!-- .element: class="fragment" data-fragment-index="2" -->Common Lispでは<code>(declare ...)</code>用のコードを使い回せる</li>
</ul>
</li>
<li><!-- .element: class="fragment" data-fragment-index="3" -->案外近い</li>
</ul>


<h1>結論</h1>

<hr />

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->遅い</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->時期尚早</li>
<li><!-- .element: class="fragment" data-fragment-index="3" -->今後機能や速度改善があれば使えるようになるかも</li>
</ul>


<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#関数型なんたら で喋ってきた]]></title>
    <link href="http://KeenS.github.io/blog/2014/10/26/number-guan-shu-xing-nantara-nican-jia-sitekita/"/>
    <updated>2014-10-26T17:14:10+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/10/26/number-guan-shu-xing-nantara-nican-jia-sitekita</id>
    <content type="html"><![CDATA[<p>κeenです。昨日<a href="http://connpass.com/event/8634/">函数型なんたらの集い</a>に参加してきたので報告/感想です。</p>

<!-- more -->


<p>会場提供はドワンゴということでトークはニコ生に流された模様。ちらっと覗いてみたらLinuxでも見れましたね。いつのまにかFlashのバグ直ってたんですね。
とはいえ私自身のトーク中のコメントが見れなかったのであまり意味はないのですが…</p>

<p>プレミアム会員は放送後7日は生放送の内容を見れるそうですね。見れる方々は<a href="http://live.nicovideo.jp/gate/lv196879029">コチラ</a>からどうぞ。次回からはタイムシフト予約しておこう。</p>

<h1>話した内容</h1>

<p><a href="http://keens.github.io/slide/c6h6-plus-hno3.html">C6H6+HNO3</a>というタイトルで、picrinのbenzとnitrosについて。本当はnitrosの依存関係解決器sulfuricを完成させてそれについて話し、nitroを書こう!って言う予定だったんですが着手が遅れて完成しないまま発表になりました。</p>

<p>普段関数型言語のヒトは型やらモナドで殴ってる印象があったのでマクロで殴ろうと思ったのですがマクロの話のところで焦ってしまって話が飛んでしまい、殴れずに終わりました。</p>

<p>ガチの組み込み屋さんから組み込み機器で動作検証したのかとの質問がありましたがそもそも持ってないです。そろそろ1.0が出ると思うのでそのあたりでやります。</p>

<p><strong>GCがconservativeかとの質問に対して「はい」と答えてしまいましたが間違いでした。</strong> conservativeなのはcall/ccでした。GCはexactですね。<a href="http://picrin.readthedocs.org/en/latest/intro.html">ドキュメント</a>に載ってます。</p>

<p>wasabizの名前に反応した人が多かったようですね。やっぱ有名人なのかぁ。</p>

<h1>興味深かった話</h1>

<h2><a href="http://www.slideshare.net/RuiccRail/engineerusesmonads?ref=http://connpass.com/event/8634/presentation/">エンジニアとモナド</a></h2>

<p>またモナドで殴る話かと思ったら全然違いました。トップダウンで設計するときにそれぞれを小さなDSLに分割してそれらをモナドで実装し、モナド変換子で組み合わせると良いよねとのこと。タスクアサインもモナド単位になるし分かり易い。スピードのために実際には単相化すると良いとか現実的な話をしてて非常に良かったです。</p>

<p>Lispで考えるとこうはいかないなと思います。トップダウンで設計するのが他の言語以上に向いてない気がします。というか、ボトムアップに向きすぎてる。小っさく始めて抽象が欲しければマクロを書いて…って。オブジェクト指向で作るにしてもオブジェクトとメソッドが分離してるのでボトムアップと相性が良い。この辺はポールグレアムの「ハッカーと画家」に詳しいです。</p>

<h2><a href="http://xuwei-k.github.io/slides/functional-something-shapeless/#0">shapelessの紹介</a></h2>

<p>興味を持ったのはshaplessそのものではなくてヘテロなリストやヘテロなハッシュに型をつける話。<code>{ 1 =&gt; "foo", "bar" =&gt; 2}</code>に型がつくのは面白すぎます。「高度に多相化された静的型は動的型と区別がつかなくなる」っぽかったです。</p>

<h2>パターンマッチいろいろ</h2>

<p>議論を呼んだ発表。パターンマッチを拡張する話。例えば年月日に対して<code>YMD(y, 12 25)</code>でクリスマスならそのときの年を取り出せるだとかさらにアンドを使えばHMSも一緒にマッチ出来るだとか。
そこからEgisonに話が飛んでEgisonの例のようにポーカーの役をScalaでパターンマッチする例の紹介。</p>

<p>議論を呼んだというのはパターンマッチにガードが吸収されてる件ですね。データ型のコンストラクタとエクストラクタが一対一対応してこそパターンマッチは真価を発揮する派vsパターンマッチの表現力が高ければ高い方が良い派の対立ですね。さらに前者は型の表現力が足りてないのなら型をもっと複雑にすべき派とガードを付けて網羅性の証明をすれば良い派に分かれます。私はパターンマッチには表現力があればあるほど良いよね派。</p>

<p>これはそもそもパターンに対する立場の違いがある気がするんですよね。私はパターンマッチは同じデータに対する条件判定のシンタックスシュガーとして捉えています。マッチと束縛を一緒に行なうのは便利なのとパフォーマンスのため。ガードが必要なのはパターンの表現力が足りないため。だからパターンがリッチならリッチな方が良い。そもそもLispでは網羅性のチェックは期待出来ませんので。そもそもの話動的言語はコンパイル時の検査をあきらめてその代わり表現力を得ようという思想ですからね。</p>

<p>パターンが複雑になるとメモリが爆発するとの指摘がありましたがそれに直面した人がいるらしく、パターンによる分岐の枝を実行時に伸ばしていくようなパターンマッチライブラリも存在します。（Lispは実行時にもマクロが動いていて、実行時にコードを生成することも可能なのです。）</p>

<h1>懇親会その他</h1>

<p>名古屋の<s>型々</s>方々と色々喋れました。偶々でこれきさん、みずぴーさんと同じテーブルに座り、昼御飯も一緒に。普段休日出勤してる印象が強く、名古屋に行かないと会えないと思っていたブレイスさんといよさんも一緒でした。でこれき先生はやっぱり大先生だった。</p>

<p>よんたさんにSML#のコードリーディング会開いて下さいって言ったら良いよって言ってもらいました。そろそろ64bit版も出るそうなのでリリース記念コードリーディング会&amp;芋煮会やろうって話になりました。</p>

<p>OCamlのユニコードライブラリを作ってる方とも話しました。内部でropeで持ってるらしく、その話を聞きました。ropeのユニコード化はどうやら普通に文字列をUTF-8で保持し、ropeに文字列長のフィールドを保たせるだけで良いよう。ただ、picrinはCとの連携のためちょくちょくCの文字列に変換してまた新たにropeを作って、とするので若干勝手というかボトルネックが違いそう。</p>

<p>Schemeのネイティブコンパイラを作ってる方とも話しました。Schemeの実装について喋ったり、GCについて喋ったり。GCについては興味深いことを聴いたのでもう1本エントリー書きます。あとはプロセス代数とかモデル検査とか。</p>

<h1>まとめ</h1>

<p>楽しかった。どうしてもLispは関数型とはあまり言われない（し、私も関数型言語とは思ってない）のでLisperが少なかったのですが私自身はMLも好きなので楽しめました。GCとTaPLとHaskellとScalaとEgisonに対するモチベーションが上がりました。</p>

<p>最後に開催して下さった主催の方々、会場を提供して下さったドワンゴ様、ありがとう御座いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C6H6+HNO3]]></title>
    <link href="http://KeenS.github.io/slide/c6h6-plus-hno3.html"/>
    <updated>2014-10-24T21:47:00+09:00</updated>
    <id>http://KeenS.github.io/slide/c6h6-plus-hno3.markdown</id>
    <content type="html"><![CDATA[<h1>$\mathbf{C_6H_6+HNO_3}$</h1>

<hr />

<p>関数型なんたらの集い &lt;2014-10-25><br/>
κeen(@blackenedgold)</p>

<h1>picrinについて</h1>

<hr />

<p><img src="/images/picrin/picrin-structure.png" alt="ピクリン酸の構造式" /><br/>
化学式 $\mathbf{C_6H_3N_3O_7}$、示性式 $\mathbf{C_6H_2(OH)(NO_2)_3}$ で表される芳香族のニトロ化合物。<br/>
一般にはフェノールのニトロ化によって得られる。</p>

<p>Note:
ニトロ化に硫酸を使うことを触れる。</p>

<p><img src="/images/picrin/picrin-logo-fin01-02.png" alt="picrinのロゴ" /></p>

<h1>About Me</h1>

<hr />

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, ML, Shell Scriptあたりを書きます</li>
<li><a href="https://github.com/picrin-scheme/picrin">picrin</a>のコミッタです</li>
</ul>


<h1>picrinについて</h1>

<hr />

<ul>
<li>github: picrin-scheme/picrin</li>
<li>R7RS-small scheme 処理系</li>
<li>速い、軽い、高機能を目指す</li>
<li>組み込み向けを意識</li>
<li>1年くらい開発</li>
<li>κeenがコミットし始めてから半年弱</li>
</ul>


<h1>picrinの プロジェクト構成</h1>

<hr />

<p>コア(benz)はC、ビルドツールはCMake。</p>

<p><code>
├── contrib (nitros)
   .......
├── docs
├── etc
├── extlib
│   └── benz
├── piclib
   ....
└── src
</code></p>

<p>Note:
contribとextlib/benzを強調。
srcはほぼ空であることにも触れる。</p>

<h1>nitrosの紹介</h1>

<hr />

<ul>
<li>schemeやCで書かれている</li>
<li>picrinのコンパイル時に一緒にlibpicrinに入る</li>
<li>picrinと共にCMakeで管理されている</li>
</ul>


<p>Note:
schemeファイルもlibpicrinにCの文字列として入ってることに触れる。
バイトコンパイルプロジェクトにも触れる。
nitrosも一緒にコンパイルされることを強調する。</p>

<h1>nitroの紹介</h1>

<hr />

<h2><a href="https://github.com/picrin-scheme/picrin/tree/master/contrib/05.r7rs/scheme">R7RS</a></h2>

<ul>
<li>picrinではr7rsもただのライブラリ</li>
<li>組み込みのときに必要なければ外せばよい</li>
</ul>


<p>Note:
リンクを辿る必要はない。
スライドは下に続く。</p>

<h1>nitroの紹介</h1>

<hr />

<h2><a href="https://github.com/picrin-scheme/picrin/blob/master/contrib/10.partcont/piclib/partcont.scm">partcont</a></h2>

<ul>
<li>ただの限定継続ライブラリ</li>
<li>ねこはるさんが詳しく話すと思うのでそちらに譲ります</li>
</ul>


<p>Note:
リンクを辿ってソースを見せる。</p>

<h1>nitroの紹介</h1>

<hr />

<h2><a href="https://github.com/picrin-scheme/picrin/blob/master/contrib/20.for/piclib/for.scm">for</a></h2>

<ul>
<li>非決定性計算ライブラリ</li>
<li>またの名をListモナド</li>
</ul>


<p>Note:
リンクを辿ってソースを見せる。</p>

<h1>nitroの紹介</h1>

<hr />

<h2><a href="https://github.com/picrin-scheme/picrin/blob/master/contrib/10.regexp/src/regexp.c">regexp</a></h2>

<ul>
<li>Unixのregexライブラリのバインディング</li>
<li>Cで書かれている</li>
</ul>


<p>Note:
リンクを辿ってソースを見せる。
詳細に説明する。</p>

<ul>
<li><code>regexp_t</code>型</li>
<li>dtor</li>
<li>GCに乗ることは強調</li>
</ul>


<h1>nitroの依存関係の話</h1>

<hr />

<ul>
<li>nitro同士に依存関係がある</li>
<li>forはpartcontに依存する</li>
<li>REPLはeditlineに依存する</li>
<li>etc&hellip;</li>
</ul>


<h1>picrinの依存関係解決法</h1>

<hr />

<p><a href="https://github.com/picrin-scheme/picrin/tree/master/contrib">picrin/contrib</a></p>

<p>Note:</p>

<ul>
<li>リンクを辿る</li>
<li>ディレクトリ名が数字で始まることを説明</li>
<li>03まできてそろそろ限界であることを説明</li>
</ul>


<p>どう見ても<span style="font-size:150%">手動(ディレクトリ名)ソート</span>ですね。<br/>
本当にありがとうございました。</p>

<ul>
<li>さすがにどうにかしたい</li>
<li>依存関係解決ツールが欲しい</li>
<li>なんかmrubyのmrbgemとかみたいにしたら楽しいんじゃね？</li>
<li>個々のnitroを別プロジェクトにも出来る!</li>
</ul>


<h1>sulfuricプロジェクト</h1>

<h1>sulfuricプロジェクト</h1>

<hr />

<ul>
<li>sulfuric acid = 硫酸</li>
<li>nitro定義、依存解決、ビルドコンフィグ etc&hellip;</li>
<li>最終的にはCMakeと連携</li>
<li>定義ファイルはschemeで書きたい</li>
</ul>


<p>Note:
個人案なことに触れる。
chikenのeggsやRacketのPlanetにも触れる。</p>

<h1>sulfuricプロジェクト</h1>

<hr />

<ul>
<li>あれ？R7RSってnitroじゃね？</li>
<li>そもそもschemeをビルドするためにschemeを書く…？</li>
<li>てかCMakeとの連携どうするよ</li>
</ul>


<p>Note:
進捗はまだinitial commitすら出来てない。
書いてる内に大きくなっていったことも説明。
最初は他のschemeでビルドする案やフェノールでビルドする案も話す。
solutionディレクトリに入れたいよねーも話す。
フェノールの合成にベンゼンスルホン酸が使われる</p>

<h1>picrinにコミットしよう</h1>

<hr />

<ul>
<li>picrinはまだ若い

<ul>
<li>ちょろっと覗くだけでコミット出来るところが見付かる</li>
</ul>
</li>
<li>開発者全員日本人</li>
</ul>


<h1>コミットはとっても簡単</h1>

<hr />

<ol>
<li><a href="https://github.com/picrin-scheme/picrin/issues">issue</a>を覗く</li>
<li>簡単そうなのをサクっと実装</li>
<li>PR</li>
</ol>


<p>Note:
イシューの中から</p>

<ul>
<li>#224 feature request: data structures</li>
<li>#210 Add MQTT support</li>
</ul>


<p>を見せる</p>

<h1>Q. なぜpicrin?</h1>

<hr />

<h1>A. picrinの独自拡張</h1>

<hr />

<ul>
<li><a href="http://picrin.readthedocs.org/en/latest/">ドキュメント</a>に色々書いてある</li>
<li>C拡張の書き方も書いてある</li>
</ul>


<p>Note:
arrayとdictionaryに触れる。
マクロに触れる
C APIの項目があることにも触れる。</p>

<h1>picrinのマクロ</h1>

<hr />

<ul>
<li><code>syntax-rules</code> (R7RS)</li>
<li><code>sc-macro-transformer</code></li>
<li><code>rsc-macro-transformer</code></li>
<li><code>ir-macro-transformer</code></li>
<li><code>er-macro-transformer</code></li>
<li><code>define-macro</code> (Common Lisp)</li>
</ul>


<p>参考: <a href="http://d.hatena.ne.jp/leque/20080528/p1">様々な Hygienic Macro &ndash; 月の塵</a></p>

<h1>picrinにコミットしよう</h1>

<hr />

<ul>
<li>issueに上がってなくても大歓迎</li>
<li>Schemeの練習に</li>
<li>「便利なライブラリ書いたけどどこ置いたら良いの」</li>
</ul>


<h1>picrinにコミットしよう</h1>

<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
</feed>
