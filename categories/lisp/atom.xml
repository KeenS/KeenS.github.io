<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/lisp/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-12-03T02:31:28+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VOPで遊ぶ]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/02/vopdeyou-bu/"/>
    <updated>2014-12-02T23:38:26+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/02/vopdeyou-bu</id>
    <content type="html"><![CDATA[<p>(:meta<br/>
 ((:this &ldquo;<a href="http://qiita.com/advent-calendar/2014/lisp">Lisp Advent Calendar 2014</a>の3日目の記事&rdquo;)<br/>
  (:prev (:author &ldquo;tk_riple&rdquo; :title <a href="http://compassoftime.blogspot.jp/2014/12/r7rs.html">&ldquo;時の羅針盤＠blog: R7RSポータブルライブラリを書く際の落とし穴&rdquo;</a>))<br/>
  (:next (:author &ldquo;nobkz&rdquo; :tite &ldquo;Shenについて&rdquo;))))</p>

<p>κeenです。さっきまでVOPで遊んでたので当初の予定を変更してVOPの話をします。</p>

<!-- more -->


<h1>VOPとは何か</h1>

<p>SBCLやCMU CLで使われているネイティブコードを吐くための機構、要はインラインアセンブラです。</p>

<h1>VOPとはどんなものか</h1>

<p>とりあえずコードをば。x86-64用です。</p>

<p>```lisp
(in-package :cl-user)
(defpackage vop-sample
  (:use :cl :sb-ext :sb-c))
(in-package :vop-sample)</p>

<p>(defknown add (fixnum fixnum)          ; addのftypeを宣言</p>

<pre><code>fixnum
(movable                            ; 副作用がない
 flushable                          ; デッドコードとして除去してよい
 foldable                           ; 定数畳み込みをしてよい
 always-translatable)               ; 必ずアセンブラコードになる
</code></pre>

<p>  :overwrite-fndb-silently t)           ; 関数上書きのエラーを出さない</p>

<p>(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::add)          ; VOP名
  (:translate vop-sample::add)         ; 関数名
  (:policy :fast-safe)                  ; declare optimize的な
  (:args (x :scs (signed-reg))          ; 引数宣言。後述</p>

<pre><code>     (y :scs (signed-reg)))
</code></pre>

<p>  (:arg-types fixnum fixnum)            ; 引数の型宣言
  (:results (r :scs (signed-reg)))      ; 返り値宣言。後述
  (:result-types fixnum)                ; 返り値の型宣言
  (:generator 4                         ; 翻訳するときのコスト</p>

<pre><code>          (move r x)                ; 返り値レジスタにxを移動
          (inst add r y)))          ; 返り値レジスタにyを足し込む
</code></pre>

<p>(in-package :vop-sample)</p>

<p>(defun add (x y)                        ; 安全なバージョンでラップする
  (add x y))
```</p>

<p>ちょっとおまじないが多いですね。</p>

<p>すこし解説すると引数は基本レジスタ渡しで、レジスタが足りなければスタックも使います。で、レジスタやスタックの値には型があります。それがストレージクラス(sc)です。この場合、x、y、rは<code>signed-reg</code>と宣言されてますね。符号付きレジスタです。<code>:scs</code>の最後のsは複数形のsです。今回は1つしか指定してませんが複数指定することも可能なのです。</p>

<p><code>move</code>というのはアセンブラ命令ではなく、マクロかなんかです（適当）。VOPなのかな？どのストレージクラスからどのストレージクラスに移動するかを認知して適切な命令を吐きます。</p>

<p><code>inst</code>が付いてるのがアセンブラですね。</p>

<p>このコード、xとrが等しいときに最適化出来るのですがそれはまあおいといて、こいつをディスアセンブルしてみましょう。</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'add)
; disassembly for ADD
; Size: 43 bytes. Origin: #x1005C26416
; 16:       488BD3           MOV RDX, RBX                     ; no-arg-parsing entry point
; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
; 2E:       CC0A             BREAK 10                         ; error trap
; 30:       02               BYTE #X02
; 31:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 32:       9A               BYTE #X9A                        ; RCX
; 33:       CC0A             BREAK 10                         ; error trap
; 35:       04               BYTE #X04
; 36:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 37:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 3A:       CC0A             BREAK 10                         ; error trap
; 3C:       04               BYTE #X04
; 3D:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 3E:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
</code></pre>

<p>主要な部分はここです。</p>

<pre><code>; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
</code></pre>

<p><code>ADD</code>の他に無駄な命令がいくつかありますね。</p>

<p>SBCLはintの下位1bitをGCのときのタグとして使ってるのでアセンブラに渡す前に算術右シフト(<code>SAR</code>)して渡してます。
そして返るときはまた左シフト(<code>SHL</code>)してます。</p>

<p>その後の</p>

<pre><code>; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
</code></pre>

<p>は関数から返るときのイディオム(スタックポインタを復元してフラグをクリアして呼び出し元に戻る)です。</p>

<p>余談ですがLispマシンなどのタグマシンは下位ビットにあるタグを無視して計算出来るのでシフトが不要になります。なので速いんですね。</p>

<h1>シフトをなくす</h1>

<p>さっきは<code>signed-reg</code>を指定しました。つまり「（アセンブラの）intをくれ」と要求した訳です。
intの下位1bitは0なので足し算する分には別にシフトされなくても問題ありませんよね。シフトを殺しましょう。</p>

<p>さっきのコードの下にこれを足します。<code>add</code>は再定義しないと反映されないようでした。</p>

<p>```lisp
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::add/v2)        ; vop名は異なる
  (:translate vop-sample::add)          ; 関数名は同じ
  (:policy :fast-safe)
  (:args (x :scs (any-reg))             ; any-regになってる</p>

<pre><code>     (y :scs (any-reg)))            ; any-regになってる
</code></pre>

<p>  (:arg-types fixnum fixnum)
  (:results (r :scs (any-reg)))         ; any-regになってる
  (:result-types fixnum)
  (:generator 3                         ; コストをさっきより低くすると優先して使ってくれる</p>

<pre><code>          (move r x)
          (inst add r y)))
</code></pre>

<p>(in-package :vop-sample)</p>

<p>(defun add (x y)
  (add x y))</p>

<p>```</p>

<p>んで、ディスアセンブルしてみると</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'add)

; disassembly for ADD
; Size: 31 bytes. Origin: #x1004C2AB83
; 83:       488BD1           MOV RDX, RCX                     ; no-arg-parsing entry point
; 86:       4801FA           ADD RDX, RDI
; 89:       488BE5           MOV RSP, RBP
; 8C:       F8               CLC
; 8D:       5D               POP RBP
; 8E:       C3               RET
; 8F:       CC0A             BREAK 10                         ; error trap
; 91:       02               BYTE #X02
; 92:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 93:       9A               BYTE #X9A                        ; RCX
; 94:       CC0A             BREAK 10                         ; error trap
; 96:       04               BYTE #X04
; 97:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 98:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 9B:       CC0A             BREAK 10                         ; error trap
; 9D:       04               BYTE #X04
; 9E:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 9F:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
</code></pre>

<p>はい。見事にSARとSHLが消えましたね。</p>

<h1>もう少し複雑な型を扱う</h1>

<p>アセンブラですし<code>(simple-array (unsigned-byte 8) (*))</code>(以下octets)を扱いたいですよね。とりあえず難しいことは考えずにoctetsの0番目の要素にアクセスしてみましょう。とはいっても<code>simple-array</code>は長さや要素の型の情報も持っていることが予想されるので少しデータを読み飛ばさないといけませんね。</p>

<p>その辺の計算が分からなかったのでsbclのソースからそれっぽいものを参考にしました。</p>

<p>```lisp
(defknown access-simple-array-0 ((simple-array (unsigned-byte 8) (*)))</p>

<pre><code>(unsigned-byte 8)
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::access-simple-array-0)
  (:translate vop-sample::access-simple-array-0)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg)))
  (:arg-types *)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4</p>

<pre><code>          (inst movzx r 
           (make-ea :byte :base x
                    :disp (- (* vector-data-offset n-word-bytes)
                           other-pointer-lowtag)))))
</code></pre>

<p>(in-package :vop-sample)
(defvar <em>octets</em> (make-array 4</p>

<pre><code>                         :element-type '(unsigned-byte 8)
                         :initial-contents '(10 11 12 13)))
</code></pre>

<p>(defun access-simple-array-0 (x)
  (access-simple-array-0 x))
```</p>

<p>こんな感じになります。境界チェックとかはやってませんが許して下さい。</p>

<p><code>descriptor-reg</code>というのがポインタが入ってるレジスタっぽいです。<code>movzx</code>は8bitの値を64bitのレジスタに符号拡張しながらロードする命令です。</p>

<p><code>make-ea</code>というのがアドレッシングですね。<code>x</code>レジスタを起点として<code>(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)</code>バイト(？ワード？)先のメモリ1byteを指します。</p>

<p>ディスアセンブルしてみましょう。みなさんもう慣れてきたと思うので主要部だけ抜き出します。</p>

<pre><code>; 65:       0FB65101         MOVZX EDX, BYTE PTR [RCX+1]      ; no-arg-parsing entry point
; 69:       48D1E2           SHL RDX, 1
</code></pre>

<p>短いですね。この<code>BYTE PTR [RCX+1]</code>が<code>make-ea</code>した値に対応します。<code>RCX</code>は<code>x</code>で<code>(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)</code>の結果が1に現れてるんでしょう。補足しておくと、<code>EDX</code>と<code>RDX</code>は同じ場所を指します。32bitとして扱うときはE、64bitとして扱うときはRで指します。</p>

<p>さて、私はx86のアドレッシングモードなんて全然知らないのですがコードを見る限りもうちょっと複雑なアドレッシングが出来るようです。</p>

<p>配列のn番目にアクセスするコードが良い例のようです。</p>

<p>```lisp
(defknown access-simple-array-n ((simple-array (unsigned-byte 8) (*)) (unsigned-byte 64))</p>

<pre><code>(unsigned-byte 8)
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::access-simple-array-n)
  (:translate vop-sample::access-simple-array-n)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg))</p>

<pre><code>     (i :scs (unsigned-reg)))
</code></pre>

<p>  (:arg-types * unsigned-num)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4</p>

<pre><code>          (inst movzx r 
           (make-ea :byte :base x
                    :scale 1
                    :index i
                    :disp (- (* vector-data-offset n-word-bytes)
                           other-pointer-lowtag)))))
</code></pre>

<p>(in-package :vop-sample)
(defun access-simple-array-n (x i)
  (access-simple-array-n x i))
```</p>

<p>新たに引数<code>i</code>をとるようになったのと<code>make-ea</code>の引数に<code>:scale 1 :index i</code>が加わってます。</p>

<p>ディスアセンブルしてみましょう。</p>

<pre><code>; 98:       0FB6543901       MOVZX EDX, BYTE PTR [RCX+RDI+1]  ; no-arg-parsing entry point
; 9D:       48D1E2           SHL RDX, 1
</code></pre>

<p>アドレッシングに<code>+RDI</code>が加わりましたね。どうして<code>i</code>(<code>RDI</code>)を<code>RAS</code>しなくていいのか気になりますがまあ、とりあえず正常に動いてるようです。</p>

<p>おわかりかと思いますがアドレッシングが<code>x</code>をベースにして今までの定数オフセット+新たにレジスタで指定したオフセットになってます。</p>

<p><code>make-ea</code>に渡した<code>:index</code>は何か分かるとしても<code>:scale</code>が気になりますよね。<code>scale</code>を2にしてディスアセンブルしてみます。</p>

<pre><code>; 58:       0FB6547901       MOVZX EDX, BYTE PTR [RCX+RDI*2+1]  ; no-arg-parsing entry point
; 5D:       48D1E2           SHL RDX, 1
</code></pre>

<p>はい。インデックスを定数倍するようですね。</p>

<h1>SSEにチャレンジ</h1>

<p>インテルアーキテクチャにあるSSEとはStreaming SIMD Extensionsの略です。じゃあSIMDは何かというとSimple Instruction Mulitple Dataの略で、1命令で複数のデータを処理出来ます。</p>

<p>この「複数のデータ」というのは64bit2つや32bit4つなどを128bitにまとめて渡します。128bitの値なんてどうやって作るんだよって感じですがsbcl-1.1.8から入った<code>sb-ext:%make-simd-pack-*</code>が存在します。</p>

<pre><code>VOP-SAMPLE&gt; (%make-simd-pack-ub32 1 2 3 4)
#&lt;SIMD-PACK  01 00 00 00  02 00 00 00  03 00 00 00  04 00 00 00&gt;
</code></pre>

<p>こんな感じです。x86_64がリトルエンディアンだったのを思い出させる表記ですね。ub32の他にub64、single、doubleが存在します。</p>

<p>ストレージクラスも<code>*-sse-reg</code>というものがあるのでこれを使いましょう。</p>

<p>```lisp
(defknown simd-add ((simd-pack (unsigned-byte 64)) (simd-pack (unsigned-byte 64)))</p>

<pre><code>(simd-pack (unsigned-byte 32))
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::simd-add)
  (:translate vop-sample::simd-add)
  (:policy :fast-safe)
  (:args (x :scs (int-sse-reg))</p>

<pre><code>     (y :scs (int-sse-reg)))
</code></pre>

<p>  (:arg-types simd-pack-int simd-pack-int)
  (:results (r :scs (int-sse-reg)))
  (:result-types simd-pack-int)
  (:generator 4</p>

<pre><code>          (move r x)
          (inst padddw r y)))
</code></pre>

<p>(in-package :vop-sample)
(defun simd-add (x y)
  (simd-add x y))
```</p>

<p>はい。こんな感じですね。<code>paddw</code>はparallel add wordですかね。これをディスアセンブルすると思ったより大きな命令になったので全部貼っときますね。</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'simd-add)

; disassembly for SIMD-ADD
; Size: 108 bytes. Origin: #x1006D64A21
; 21:       660F6FC2         MOVDQA XMM0, XMM2                ; no-arg-parsing entry point
; 25:       660FFDC1         PADDW XMM0, XMM1
; 29:       49896C2440       MOV [R12+64], RBP                ; thread.pseudo-atomic-bits
; 2E:       4D8B5C2418       MOV R11, [R12+24]                ; thread.alloc-region
; 33:       498D5320         LEA RDX, [R11+32]
; 37:       493B542420       CMP RDX, [R12+32]
; 3C:       7740             JNBE L2
; 3E:       4989542418       MOV [R12+24], RDX                ; thread.alloc-region
; 43:       498D530F         LEA RDX, [R11+15]
; 47: L0:   48C742F165030000 MOV QWORD PTR [RDX-15], 869
; 4F:       48C742F900000000 MOV QWORD PTR [RDX-7], 0
; 57:       660F7F4201       MOVDQA [RDX+1], XMM0
; 5C:       49316C2440       XOR [R12+64], RBP                ; thread.pseudo-atomic-bits
; 61:       7402             JEQ L1
; 63:       cc09             break 9                          ; pending interrupt trap
; 65: l1:   488be5           mov rsp, rbp
; 68:       f8               clc
; 69:       5d               pop rbp
; 6a:       c3               ret
; 6b:       cc0a             break 10                         ; error trap
; 6d:       02               byte #x02
; 6e:       19               byte #x19                        ; invalid-arg-count-error
; 6f:       9a               byte #x9a                        ; rcx
; 70:       cc0a             break 10                         ; error trap
; 72:       04               byte #x04
; 73:       32               byte #x32                        ; object-not-simd-pack-error
; 74:       fe1b01           byte #xfe, #x1b, #x01            ; rdx
; 77:       cc0a             break 10                         ; error trap
; 79:       04               byte #x04
; 7a:       32               byte #x32                        ; object-not-simd-pack-error
; 7b:       fe9b03           byte #xfe, #x9b, #x03            ; rdi
; 7e: l2:   6a20             push 32
; 80:       bac0854200       mov edx, 4359616                 ; alloc_tramp
; 85:       ffd2             call rdx
; 87:       5a               pop rdx
; 88:       80ca0f           or dl, 15
; 8b:       ebba             jmp l0
nil
</code></pre>

<p>なにやってるのやら。</p>

<h1>出来なかったこと</h1>

<p><code>PCMPESTRI</code>を使ってみたかったのですが扱いがトリッキーなので断念しました。具体的に言うと操作する値を格納するレジスタがEAXとECX固定なようなのです。
<code>:temporary</code>節で内部で使うレジスタも要求出来るようなのですが名指しでもらえるんですかね。</p>

<p>SSEの使い方とsimple-arrayから要素の配列を取り出す方法までは示したので誰かやって下さい。</p>

<p>参考資料いっぱい置いときますね。</p>

<p>VOPの使い方。最初の方に出てきたaddの最適化のやつとかも出てくる。(en)
: <a href="http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/">How to Define New Intrinsics in SBCL &ndash; Paul Khuong mostly on Lisp</a></p>

<p>SBCLのsimd-packの具体的解説(en)
: <a href="http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html">Hacking SSE Intrinsics in SBCL (part 1) &ndash; Paul Khuong mostly on Lisp</a></p>

<p>SBCLでVOPとSSEを使ってマンデルブロ集合を計算する(en)
<a href="http://www.pvk.ca/Blog/2013/06/05/fresh-in-sbcl-1-dot-1-8-sse-intrinsics/">Fresh in SBCL 1.1.8: SSE Intrinsics! &ndash; Paul Khuong mostly on Lisp</a></p>

<p>IntelのPCMPESTRIとかのマニュアル(en)
: <a href="https://software.intel.com/en-us/node/514244">Packed Compare Intrinsics</a></p>

<p>MicrosoftのPCMPESTRIのマニュアル。こっちの方が分かりやすい(en)
<a href="http://msdn.microsoft.com/en-us/library/bb531465.aspx">_mm_cmpestri</a></p>

<p>PCMPISTRIを使った<code>strlen</code>の実装例(ja)
: <a href="http://homepage1.nifty.com/herumi/prog/intel-opt.html">Intel optimization</a></p>

<p>PCMPESTRIを使ってHTTPパーサーを高速化した話。これをやりたかった。(en)
: <a href="http://blog.kazuhooku.com/2014/12/improving-parser-performance-using-sse.html">Kazuho&rsquo;s Weblog: Improving Parser Performance using SSE Instructions (in case of PicoHTTPParser)</a></p>

<h1>おわりに</h1>

<p>おつかれ様でした。たまには低レベルなことをやっても良いんじゃないでしょうか。</p>

<p>明日はnobkzさんで、Shenについてです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[require, ASDF, quicklispを正しく使う]]></title>
    <link href="http://KeenS.github.io/blog/2014/11/30/quicklisp/"/>
    <updated>2014-11-30T22:05:39+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/11/30/quicklisp</id>
    <content type="html"><![CDATA[<p>κeenです。最近のCommon Lispのパッケージ管理は<code>ql:quickload</code>しか知らないという方も多いのではないでしょうか。しかしそれだけでは機能が足りないこともあります。Common Lispには様々な管理システムがあるので整理しましょう。</p>

<!-- more -->


<h1><code>provide</code>, <code>require</code></h1>

<p>同じファイルを読み込まないための原始的なシステムです。Common Lispの標準の機能です。<code>(require 'foo)</code>がファイルをロードし、ロードされたファイル内で<code>(provide 'foo)</code>しておくと2回目以降の<code>(require 'foo')</code>はファイルを読まずにすぐさま返ります。</p>

<p>ここで問題なのが<code>require</code>がどこのファイルを捜しにいくかは処理系依存なところですね。なので生の<code>require</code>は使えないと思っておいた方が良いでしょう。</p>

<h1>ASDF 3</h1>

<p>Another Sysytem Defininion Facility。過去にはAnotherじゃないSysytem Defininion Facilityもあった模様。最新版は3系です。結構APIが変っているので必ず3の情報を捜しましょう。</p>

<p>この「System」というのが聞き慣れませんが、ASDFの<code>defsystem</code>で</p>

<ol>
<li>systemに含まれるファイルの定義</li>
<li>依存systemの記述</li>
<li>その他作者、ライセンス、バージョンなどの記述</li>
<li>systemのコンパイルやロード、テストなどの操作</li>
</ol>


<p>が可能です。ASDFはCにとってのmake + ldを標榜しています。Makefile的なものは(systemname).asdになります。</p>

<p><code>require</code>との統合もされており、ASDFを適切に設定することで<code>defsystem</code>されたsystemを<code>require</code>でロードすることが出来ます。このときASDFは処理系に依存せずにASDFのパスに従って.asdファイルを捜しにいきます。</p>

<p>また、ほとんどの処理系はASDFを標準添付していて、大抵<code>(require 'asdf)</code>すれば使えるようになっています。</p>

<p>尚、コンパイル後のファイルは処理系、バージョン毎に互換性がないので本来なら適切に管理する必要がありますが、ASDFが適切に~/.cache/common-lisp以下に管理してくれます。優秀ですね。</p>

<h1>quicklisp</h1>

<p>lispプロジェクトのインストーラと微妙にパッケージマネージャ的な役割をします。</p>

<p><a href="http://beta.quicklisp.org/quicklisp.lisp">http://beta.quicklisp.org/quicklisp.lisp</a> をダウンロードしてきてそのファイルを読み込んで<code>(quicklisp-quickstart:install)</code>すれば~/quicklisp/以下にquicklispがインストールされ、ロードされます。処理系を再起動したあとまたquicklispをロードするには~/quicklisp/setup.lispを<code>load</code>します。が、毎回それをやるのが面倒な人は<code>(ql:add-to-init-file)</code>しておけば処理系の初期化ファイルに~/quicklisp/setup.lispを読み込む処理が書き加えられます。</p>

<p>さて、このquicklispを扱う上で3つの概念を覚えておくと良いです。</p>

<p>dist
:    releaseの配布元。普通は'quicklisp'のみだがほかのdistを使うことも可能。自前のやつとか。新たなdistを追加したり削除したり出来る。gitのremoteをイメージすればよい。</p>

<p>release
:    quicklispがダウンロードしてくる単位。ライブラリの作者が登録するときの単位。複数のsystemをもつこともある。</p>

<p>system
:    ASDFのsystem。ユーザーが使うときの単位。</p>

<p>さて、quicklispを使うときは通常使いたいシステムを<code>ql:quickload</code>すればそのシステムと依存システムの含まれているリリースをダウンロード、展開、ロードまでしてくれます。</p>

<p>開発中はREPLを立ち上げているので「あ、このライブライリ使おう」と思ったら<code>ql:quickload</code>するだけで即座に使えるようになりますね。</p>

<p>quicklispのリリースは毎月下旬にアップデートされていて、毎月ちゃんと全てのライブラリが対応処理系で動くことがテストされています。なのでメンテナが居なくなったライブラリはドロップします。代わりにquicklispの作者がテスト出来ないライブラリは登録させてもらえなかったりします（cl-cudaとか）</p>

<h1>quicklispの問題</h1>

<p>既にCommon Lispのライブラリマネージャとしてデファクトスタンダード的位置を築きつつあるquicklispですが、私は結構不満があります。</p>

<ul>
<li>~/quicklisp/setup.lispを読み込むとquicklispの全てを読み込んでしまう: これには過去全てのバージョンのdistとreleaseとsystemのデータベース、HTTPクライアント、圧縮ファイルの解凍ライブラリなども含まれており、処理系の起動が非常に遅くなる</li>
<li>特にデータベースはファイルに書かれていても高速に読める形式なのに初期化時に毎回全ての内容をLispのハッシュに変換するという愚行をする。</li>
<li><code>(ql:add-to-init-file)</code>が推奨されているが、前述の通り処理系の起動が遅くなってしまう。特に、（インストーラではなく、インストール済みの）ライブラリマネージャとして使いたくてもインストーラの機能までロードしてしまう。結構メモリを食うしアプリケーションには要らない。</li>
<li>処理系に依っては初期化ファイルはlispファイルをスクリプトとして使うときは読み込まれないこともあるのでスクリプトには使えない。まあ、前述の通り使いたくもない。</li>
</ul>


<p>のでライブラリマネージャにはASDFが向いてるのですが、</p>

<ul>
<li>quicklispでインストールしたシステムはquicklispを一旦ロードするかASDFの設定をいじるかしなければASDFからは使えない</li>
<li>quicklispはシステムのダウンロード/インストールだけすれば良いものをロードまでする</li>
<li>要はASDFを隠す</li>
<li>じゃASDFのラッパーかというとロードしかせず、コンパイルやテストなどはしない</li>
</ul>


<p>など様々な問題があります。</p>

<p>一応quicklispの弁護をしておくと、Common Lispは他のスクリプト言語とはちょっと使い方が違って、</p>

<ul>
<li>初期化ファイルは大抵オレオレライブラリで埋め尽くされていてそもそも起動には時間がかかる</li>
<li>Emacsのように一度REPLを立ち上げたら滅多に落とさない</li>
<li>アプリケーションも基本的にはREPLの中で使う</li>
<li>起動時間を気にするなら初期化ファイルを全てロードした、コアファイルをダンプしておいて使う</li>
</ul>


<p>といった使い方をされることが多いのです。そのような人からしてみたら細々処理されるよりも起動時間とメモリは気にしないから速いやつをくれ、となるのです。</p>

<p>じゃあそれなりにCommon Lispを使う私が何故そうしないかというと</p>

<ul>
<li>立ち上げっぱなしというのが性に合わない。立ち上がっているものを見るとすぐに落としたくなる。EmacsのヘビーユーザーだがEmacsもすぐ落とす。</li>
<li>コマンドラインアプリケーションを作りたいため、起動時間が命になる。</li>
<li>私はSBCLの開発版を使っていて、コアファイルはすぐに無効になるためコアダンプはしない（意味がない）</li>
</ul>


<p>といった理由があります。これは初心者にも共通する部分があるんじゃないでしょうか。REPLを立ち上げっぱなしにはしないし「コアダンプ？なにそれ？エラー出してんじゃん」状態でしょう。</p>

<h1>ASDFを正しく使う</h1>

<p>ということでquicklispをあまり使わない方法を紹介します。</p>

<p>前述の通り、quicklispでインストールしたシステムはquicklispを一旦ロードするかasdfの設定をいじるかしなければasdfからは使えません。具体的に言うと、</p>

<ul>
<li>ASDFのデフォルトパスは~/common-lisp以下</li>
<li>quicklispのシステムのインストールパスは~/quicklisp/dists/(dist name)/software/以下</li>
</ul>


<p>なので~/quicklisp/dists/以下にパスを通します。少し無駄なディレクトリもパスに含まれてしまうので気にする人はそれぞれのdistについて~/quicklisp/dists/(dist name)/software/にパスを通しましょう。</p>

<p>因みに拙作の<a href="https://github.com/KeenS/CIM">CIM</a>は~/.cim/quicklisp以下にquicklispをインストールするのでCIM使いの方は~/.cim/quicklisp/dists/ですね。~/quicklispの方が混乱少ないかなあ。</p>

<p>さて、ASDFの設定は<a href="http://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems">公式マニュアル</a>を参照すれば良いのですが一応実際のものを書いておくと</p>

<p>~/.config/common-lisp/source-registry.conf に
<code>lisp
(:source-registry
  (:tree "~/quicklisp/dists/")
  (:tree (:home "Lisp/"))
  :INHERIT-CONFIGURATION)
</code>
を書けばOKです。2つめのLisp/は私がCommon Lispファイルを置いているディレクトリですね。この書き方だとquicklispより自分のLispライブラリを優先して読みにいきます。開発版を使いたいときとかむしろ開発をするときとかに必須です。この設定をミスるといくら開発してもロードされてるのはリリース版で、機能が動かないとかの地獄を見ます。</p>

<p>ここまでくれば</p>

<p><code>lisp
(require 'asdf)
(require 'hoge)
</code>
とすればquicklispでインストールしたライブラリをロード出来ます。</p>

<h2>require以外のASDFの使い方</h2>

<p>バージョンに依って使い方が異なるのですが、3系だと<code>(asdf:xxx-system 'hoge)</code>などとします。具体的には</p>

<ul>
<li><code>(asdf:load-system 'hoge)</code> ( = <code>(require 'hoge)</code>)</li>
<li><code>(asdf:test-system 'hoge)</code> (テストがあるときのみ)</li>
<li><code>(asdf:compile-system 'hoge)</code></li>
</ul>


<p>を覚えておけば良いでしょう。他にもいくつか操作があるようですが私は使ったことがないです。<code>asdf:locate-system</code>は名前的に便利そうではあるんですけどね。</p>

<p>開発するときはまず.asdファイルを書いておいて(あるいはcl-projectから生成して)、<code>(require 'hoge)</code>で始めて書いていき、ある程度進んだらテストを書いてテストの項目を.asdファイルに書き足して<code>(asdf:test-system 'hoge)</code>、それなりに動くようになったら<code>(asdf:compile-system 'hoge)</code>してコンパイルの様子を見たりコンパイル後のベンチマークを取ったりします。</p>

<h2>quickloadを成仏させる</h2>

<p>これでロードの処理はASDFで全てカバー出来るようになりました。じゃあquickloadのロード機能は邪魔ですね。quicklispをインストーラとしてのみ使いましょう。</p>

<p>まず処理系の初期化ファイル(sbclなら~/.sbclrc)から</p>

<p>```lisp
;;; The following lines added by ql:add-to-init-file:</p>

<h1>-quicklisp</h1>

<p>(let ((quicklisp-init (merge-pathnames &ldquo;~quicklisp/setup.lisp&rdquo;</p>

<pre><code>                                   (user-homedir-pathname))))
</code></pre>

<p>  (when (probe-file quicklisp-init)</p>

<pre><code>(load quicklisp-init :verbose nil)))
</code></pre>

<p>```</p>

<p>を削除します。quicklispを使いたいときだけ<code>(load "~/quicklisp/setup.lisp")</code>します。そして欲しいシステムをインストールするには</p>

<p><code>lisp
(ql::recursively-install "foo")
</code></p>

<p>します。quickloadに比べて爆速です。ここにきて名前が文字列な上にexportされてないシンポル参照してますね。気持ち悪いという方は大人しくquickloadしましょう。</p>

<p>拙作のCIMにはこれをコマンドラインから行なう<code>ql install</code>なるコマンドが存在します。</p>

<h1>最後に</h1>

<p>quicklispが嫌いなのは私の好みですがASDFを正しく使えて損はないと思うので知らなかった方々は是非試してみて下さい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lisp meet up #22でLTしてきた]]></title>
    <link href="http://KeenS.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita/"/>
    <updated>2014-11-28T23:17:12+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita</id>
    <content type="html"><![CDATA[<p>κeenです。先日 Lisp Meet Up #22 でLTしてきたので報告です。</p>

<!-- more -->


<p>LTは事前に登録されたのが2件、私が当日17時くらいに登録したの1件で、参加は20人募集の内20人応募、20人参加と最近中々の人気を見せてます。</p>

<h1>Common Lispで高速なHTTPパーサーを書く(仮)</h1>

<p>LT1件目は深町さんより、「Common Lispで高速なHTTPパーサーを書く(仮)」。fast-httpを作ったときの話。</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/42153462" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/fukamachi/writing-a-fast-http-parser" title="Writing a fast HTTP parser" target="_blank">Writing a fast HTTP parser</a> </strong> from <strong><a href="//www.slideshare.net/fukamachi" target="_blank">fukamachi</a></strong> </div></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVARnhncWZpRFdUOWM/preview">動画</a></p>

<p><a href="http://blog.8arrow.org/entries/2014/10/23">深町さんのブログ</a>に書かれていることの他、fast-httpが高速になるまでの経緯や実装方針などの話もありました。</p>

<p>最初ベースにしたnode.jsのHTTPパーサ、http-parseは状態を持っていて、1文字読む毎に状態を保存していた。次にベースにしたpicohttpparseは状態を持たず、HTTPリクエストが全部届く前にパースを始めてしまった場合はあきらめて最初からパースするようにしていた。fast-httpは1行パースする毎に状態を保存するようにした。など。</p>

<p>もう一つ、http-parseは<code>while</code>ループの中に巨大な<code>case</code>文があって、現在の状態で<code>case</code>でディスパッチし、その節の中で読んだ文字に依って現在の状態を変え、またループで先頭に戻って状態に依ってディスパッチするという手法だったそうです。Common Lispの場合は<code>case</code>が全て<code>(cond ((eql ..) ....) ...)</code>に展開されて遅い<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>ので<code>while</code>と<code>case</code>じゃなくて<code>tagbody</code>と<code>goto</code>で実装したそうです。</p>

<p>この手法は一般にDirect(Navive) ThreadingだとかThreaded Codeだとか呼ばれています。主にバイトコードインタプリタを実装する時にバイトコードに依るディスパッチの部分で使われるようです。Rubyの解説が丁寧だったようなので参考資料として置いておきます。</p>

<p><a href="http://magazine.rubyist.net/?0008-YarvManiacs">Rubyist Magazine &ndash; YARV Maniacs 【第 3 回】 命令ディスパッチの高速化</a></p>

<p>会場からはアーキテクチャ依存の最適化はしないのかとの質問がありました。SBCLにはインラインアセンブラであるVOPなるものが存在するのでSIMD命令使えば、とかいう怖い話ですね。</p>

<h1>symbol tree diff</h1>

<p>LT2件目はchikuさんより「symbol tree diff」。chikuさんが以前から取り組んでいるプログラムのdiffを構文レベルでとる話の進捗。</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/42160384" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/samugari/symbol-treediff" title="Symbol tree-diff" target="_blank">Symbol tree-diff</a> </strong> from <strong><a href="//www.slideshare.net/samugari" target="_blank">samugari</a></strong> </div></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVARUoxVGtiMlFrRVU/preview">動画</a></p>

<p>diff自体はとれるようになったようですが見せ方に問題があり、見易い形式を模索中のようです。会場に見易い形式は何か投げ掛けましたが良い案を見付けるのは難しいようです。</p>

<h1>Semantic S式</h1>

<p>私から「Semantic S式」。括弧が多い方が嬉しいこともあるよねーというゆるい話。
<a href="http://keens.github.io/slide/semantic-sshi.html">Semantic S式 | κeenのHappy Hacκing Blog</a></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVAQms2QkZDcnZfVlU/preview">動画</a></p>

<p>会場からは半分同意、半分ツッコみたいとの反応が。plistをリテラルから<code>getf</code>するやついないだろ、とか。</p>

<h1>懇親会</h1>

<p>私の発表で21時あたりだったのでそのまま解散して懇親会。隣にLand of Lispを読んでLispに興味持ってLispの授業をとってる方がいたのでどの本が入門に良いかなど。</p>

<p>VOPの話の続きもしました。どうしても資料がないのがネックだよねー、と。私の知っているのは</p>

<p><a href="http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/">How to Define New Intrinsics in SBCL &ndash; Paul Khuong mostly on Lisp</a></p>

<p>や</p>

<p><a href="http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html">Hacking SSE Intrinsics in SBCL (part 1) &ndash; Paul Khuong mostly on Lisp</a></p>

<p>かな。日本語のやってみた系だとg1さんの</p>

<p><a href="http://g000001.cddddr.org/2011-12-08">#:g1: SBCLでVOPを使ってみよう</a></p>

<p>あたり。</p>

<h1>その他</h1>

<p>テンプレートエンジンを作ってるって以前深町さんに話してたら「まだ出来ないんですか？」とさんざん煽られました。はい。頑張ります。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><code>cond</code>は先頭から順番に比較する仕様です。<code>case</code>は<code>cond</code>に展開されることが仕様で定められていた筈。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Semantic S式]]></title>
    <link href="http://KeenS.github.io/slide/semantic-sshi.html"/>
    <updated>2014-11-27T15:30:00+09:00</updated>
    <id>http://KeenS.github.io/slide/semantic-sshi.markdown</id>
    <content type="html"><![CDATA[<h1>Semantic S式</h1>

<hr />

<p>2014-11-27<br/>
κeen(@blackenedgold)</p>

<h1>About Me</h1>

<hr />

<p><img src="/images/icon.png" alt="κeenのアイコン" /></p>

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
</ul>


<h1>Semantic Web とは</h1>

<h1><a href="http://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A6%E3%82%A7%E3%83%96">Semantic Web</a></h1>

<hr />

<ul>
<li>W3C のティム・バーナーズ＝リーが提唱</li>
<li>文章の見た目を記述するんじゃなくて構造を記述しよう</li>
<li>そうすると機械がクローリングするの楽になるよね</li>
</ul>


<h1>Semantic S式とは</h1>

<h1>Semantic S式</h1>

<hr />

<ul>
<li>Shibuya.lispのκeenが提唱 (昨日思い付いた)</li>
<li>S式の見た目じゃなくて構造で括弧をつけよう</li>
<li>そうするとコーディングが楽になるよね</li>
</ul>


<h1>良いところ</h1>

<hr />

<ol>
<li>意味が分かり易い</li>
<li>パースし易い</li>
<li>編集が楽になる</li>
<li>壊れにくい</li>
</ol>


<h1>1. 意味が分かり易い</h1>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例1</h2>

<ul>
<li><p>Clojure
<code>clojure
(let [a 1
      b 2]
  ...)
</code></p></li>
<li><p>Common Lisp
<code>lisp
(let ((a 1)
      (b 2))
  ....)
</code>
どっちが分かり易い？</p></li>
</ul>


<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例1</h2>

<p>（日本語にしてみる（イメージ））</p>

<ul>
<li>Clojure<br/>
aを1bを2とする</li>
<li>Common Lisp
<table border="1"><tr><td><code>a</code></td><td>1</td></tr><tr><td><code>b</code></td><td>2</td></tr></table>
とする</li>
</ul>


<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例2</h2>

<p>何をしてる？</p>

<p>```lisp
(destructuring-bind (a b)</p>

<pre><code>(some-function)
</code></pre>

<p>  &hellip;)
```</p>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例2</h2>

<p>何をしてる？</p>

<p>```lisp
(destructuring-bind ((a b)</p>

<pre><code>(some-function))
</code></pre>

<p>  &hellip;)
```</p>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例3</h2>

<p>これの返り値は？
<code>lisp
(getf '(:hoge :foo :huga :baz :piyo :pon :chun) :pon)
</code></p>

<h1>1. 意味が分かり易い</h1>

<hr />

<h2>例3</h2>

<p>これの返り値は？
<code>lisp
(assoc :pon '((:hoge :foo) (:huga :baz) (:piyo :pon) (:chun)))
</code></p>

<h1>2. パースし易い</h1>

<h1>2. パースし易い</h1>

<hr />

<h2>例</h2>

<ul>
<li><p>Clojure
<code>clojure
(let [a 1
      b 2]
  ...)
</code></p></li>
<li><p>Common Lisp
<code>lisp
(let ((a 1)
      (b 2))
  ....)
</code>
どっちが実装し易い？</p></li>
</ul>


<h1>2. パースし易い</h1>

<hr />

<ul>
<li>Common Lispの方は意味で分割してある</li>
<li>括弧は無くてもパースは出来る</li>
<li>機械にパースし易い≒人間にパースし易い</li>
</ul>


<h1>3. 編集が楽になる</h1>

<h1>3. 編集が楽になる</h1>

<hr />

<h2>前提</h2>

<ul>
<li>エディタに文/式/トークン(Lispの場合は全てS式)単位の編集機能がある

<ul>
<li>S式単位でカーソル移動</li>
<li>S式単位の削除/カット</li>
<li>S式単位のスワップ</li>
<li>etc&hellip;.</li>
</ul>
</li>
</ul>


<h1>3. 編集が楽になる</h1>

<hr />

<h2>例（偶によくある）</h2>

<p>この<code>c</code>の束縛を上のletに持っていきたいときどうする？</p>

<p>```lisp
(let ((a 1)</p>

<pre><code>  (b 2))
</code></pre>

<p>  &hellip;.
  (let ((c 3)</p>

<pre><code>    (d 4))
...))
</code></pre>

<p>```</p>

<h1>3. 編集が楽になる</h1>

<hr />

<h2>例（偶によくある）</h2>

<ul>
<li>意味で括弧をつけていれば1カット移動1ペースト</li>
<li>Clojure方式だと2カット移動1ペースト</li>
<li><code>c</code>だけじゃなくて<code>d</code>も、と考えると…</li>
</ul>


<h1>4. 壊れにくい</h1>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>ageの計算が壊れているとする</p>

<p><code>lisp
(:name "κeen"
 :age  (year-of-time-interval (date- (today) (date 1992 5 17)))
 :place "Shibuya")
</code></p>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>コメントアウトしてみる（壊れた）</p>

<p><code>lisp
(:name "κeen"
 :age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 :place "Shibuya")
</code></p>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>ageの計算が壊れているとする</p>

<p><code>lisp
((:name "κeen")
 (:age  (year-of-time-interval (date- (today) (date 1992 5 17))))
 (:place "Shibuya"))
</code></p>

<h1>4. 壊れにくい</h1>

<hr />

<h2>例</h2>

<p>(エディタサポートあり)</p>

<p>コメントアウトしてみる（壊れない）</p>

<p><code>lisp
((:name "κeen")
 (:age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 )
 (:place "Shibuya"))
</code></p>

<h1>ここまでのまとめ</h1>

<hr />

<ul>
<li>構造が文脈に依存していると

<ul>
<li>人間に分りづらい</li>
<li>プログラムに分りづらい</li>
<li>エディタに分りづらい</li>
<li>壊れやすい</li>
</ul>
</li>
</ul>


<h1>Q. When Semantic?</h1>

<hr />

<h2>A. 言語を設計するとき <!-- .element: class="fragment" data-fragment-index="1" --></h2>

<ul>
<li>つまりマクロを書くとき <!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>


<h1>Q. When Semantic?</h1>

<hr />

<h2>A. 言語を設計するとき</h2>

<ul>
<li>マクロを書くときそれなりのDSLを設計する</li>
<li>プログラム上は必須ではない括弧もあった方が良いときもある</li>
</ul>


<h1>まとめ</h1>

<hr />

<ul>
<li>括弧が少ない方が書き易いとは限らない

<ul>
<li>「書く」だけなら速くてもwrite onlyになってしまうかも<!-- .element: class="fragment" data-fragment-index="1" --></li>
</ul>
</li>
<li>プログラムの意味を考えながら括弧つけよう

<ul>
<li>Lisperはどうせ括弧は見えない<!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>
</li>
</ul>


<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Get Clojure Faster]]></title>
    <link href="http://KeenS.github.io/slide/get-clojure-faster.html"/>
    <updated>2014-10-28T21:35:00+09:00</updated>
    <id>http://KeenS.github.io/slide/get-clojure-faster.markdown</id>
    <content type="html"><![CDATA[<h1>Get Clojure Faster</h1>

<hr />

<p>2014-10-28<br/>
κeen(@blackenedgold)</p>

<h1>About Me</h1>

<hr />

<ul>
<li>κeen<img src="/images/icon.png" alt="κeenのアイコン" /></li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
</ul>


<h1><code>lein repl</code></h1>

<hr />

<p><code>
$ time  lein repl &lt;/dev/null
...
snip
...
lein repl &lt; /dev/null  23.05s user 0.97s system 159% cpu 15.048 total
</code></p>

<p>起動に20秒…</p>

<h1>drip</h1>

<hr />

<ul>
<li>JVMの起動時間を速くすくやつ</li>
<li>類似プロジェクトにCakeやNailgun</li>
<li>でもCakeやNailgunの踏んだ地雷は避ける

<ul>
<li>JVMサーバを使い回すのではなく起動イメージを準備</li>
<li>Common Lispでのコアダンプに近い？</li>
</ul>
</li>
</ul>


<h1>drip</h1>

<hr />

<h2>導入</h2>

<p><code>
curl -L http://drip.flatland.org &gt; ~/bin/drip
chmod 755 ~/bin/drip
</code>
又は</p>

<p><code>
git clone https://github.com/flatland/drip.git
cd drip &amp;&amp; make prefix=~/bin install
</code>
そして
<code>
export LEIN_JAVA_CMD=drip
</code></p>

<h1>drip</h1>

<hr />

<h2>結果</h2>

<p><code>
$ time  lein repl &lt;/dev/null
lein repl &lt; /dev/null  0.11s user 0.27s system 6% cpu 6.153 total
</code></p>

<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
</feed>
