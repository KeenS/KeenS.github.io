<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/lisp/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-12-07T23:17:27+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[H2Oにpicrinを溶かす]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/07/h2onipicrinworong-kasu/"/>
    <updated>2014-12-07T22:37:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/07/h2onipicrinworong-kasu</id>
    <content type="html"><![CDATA[<p>このエントリーは<br/>
<a href="http://qiita.com/advent-calendar/2014/lisp">Lisp Advent Calendar</a> 7日目<br/>
兼<br/>
<a href="http://qiita.com/advent-calendar/2014/h2o">H2O Advent Calendar</a> 7日目<br/>
の記事です。</p>

<p>κeenです。タイトルの通りです。</p>

<!-- more -->


<h1>H2Oとは</h1>

<p>水。</p>

<h1>picrinとは</h1>

<p><a href="http://ja.wikipedia.org/wiki/%E3%83%94%E3%82%AF%E3%83%AA%E3%83%B3%E9%85%B8">Wikipedia</a>にあるように、フェノールのトリニトロ化合物で、水溶性があります。</p>

<h1>ではなくて</h1>

<p>H2OはHTTP1, HTTP2, WebsocketをサポートするNginXより速いHTTPサーバです。<a href="https://github.com/h2o/h2o">Github</a>で開発されています。開発者は@kazuhoさん。</p>

<p>picrinは「速い、軽い、高機能」を目指して作られているScheme処理系です。<a href="https://github.com/picrin-scheme/picrin">Github</a>で開発されています。開発者は@wasabizさん。</p>

<h1>混ぜる</h1>

<p>picrinのように組込み向けで開発されている処理系は</p>

<ul>
<li>picrinからH2Oを使えるようにする</li>
<li>H2Oにpicrinを埋め込む</li>
</ul>


<p>と、2種類考えられますが、今回は後者です。H2Oにpicrinを溶かしてる感じしますね。</p>

<p>まあ、Apatch HTTPDやNginX宜しくmod_picrinを作れば済むでしょう。</p>

<h1>絶望</h1>

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/blackenedgold">@blackenedgold</a> モジュラーにできるようにはしてるけど、まだsoをロードする仕組みはないです。というか、APIがまだunstableだし</p>&mdash; Kazuho Oku (@kazuho) <a href="https://twitter.com/kazuho/status/540692011003559936">2014, 12月 5</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>つらい</p>

<h1>solシステムの導入</h1>

<p>mod_xxxにしようと思ったんですけど水だし溶液ってことでsol_xxxにします。</p>

<p>H2Oにこんな感じのパッチ当てて</p>

<p>```
diff &mdash;git a/src/main.c b/src/main.c
index 7fc4680..57804a6 100644
&mdash;&ndash; a/src/main.c
+++ b/src/main.c
@@ -30,6 +30,7 @@
 #include &lt;signal.h>
 #include &lt;stdio.h>
 #include &lt;unistd.h>
+#include &lt;dlfcn.h>
 #include &lt;sys/stat.h>
 #include &lt;sys/socket.h>
 #include &lt;sys/types.h>
@@ -76,6 +77,8 @@ struct config_t {</p>

<pre><code> } state;
</code></pre>

<p> };</p>

<p>+typedef int(<em>sol_init_fn)(h2o_configurator_command_t </em>, h2o_configurator_context_t <em>, const char </em>, yoml_t *);
+
 static unsigned long openssl_thread_id_callback(void)
 {</p>

<pre><code> return (unsigned long)pthread_self();
</code></pre>

<p>@@ -381,6 +384,43 @@ static int on_config_num_threads(h2o_configurator_command_t *cmd, h2o_configurat</p>

<pre><code> return h2o_config_scanf(cmd, config_file, config_node, "%u", &amp;conf-&gt;num_threads);
</code></pre>

<p> }</p>

<p>+static int on_config_use(h2o_configurator_command_t <em>cmd, h2o_configurator_context_t </em>ctx, const char <em>config_file, yoml_t </em>config_node)
+{
+  /<em> struct config_t </em>conf = H2O_STRUCT_FROM_MEMBER(struct config_t, global_config, ctx->globalconf); <em>/
+  char </em>sol_name;
+  sol_init_fn init_fn;
+  void <em>handle;
+
+  /</em> fetch solution name <em>/
+  switch (config_node->type) {
+  case YOML_TYPE_SCALAR:
+    sol_name = config_node->data.scalar;
+    break;
+  default:
+    h2o_config_print_error(cmd, config_file, config_node, &ldquo;value must be a string or a mapping (with keys: <code>port</code> and optionally <code>host</code>)&rdquo;);
+    return -1;
+  }
+
+  char dl_name[strlen(&ldquo;sol<em>.so&rdquo;) + strlen(sol_name) + 1];
+  char init_fn_name[strlen(&ldquo;init_sol</em>&rdquo;) + strlen(sol_name) + 1];
+
+  sprintf(dl_name, &ldquo;./sol<em>%s.so&rdquo;, sol_name);
+  sprintf(init_fn_name, &ldquo;init_sol</em>%s&rdquo;, sol_name);
+  handle = dlopen(dl_name, RTLD_LAZY);
+  if (! handle){
+    h2o_config_print_error(cmd, config_file, config_node, &ldquo;cannot load the solution&rdquo;);
+    return -1;
+  }
+
+  init_fn = dlsym(handle, init_fn_name);
+  if(dlerror()){
+    h2o_config_print_error(cmd, config_file, config_node, &ldquo;cannot find the initialize function&rdquo;);
+    return -1;
+  }
+  return (</em>init_fn)(cmd, ctx, config_file, config_node);
+
+}
+
 static void usage_print_directives(h2o_globalconf_t *conf)
 {</p>

<pre><code> h2o_linklist_t *node;
</code></pre>

<p>@@ -606,6 +646,10 @@ int main(int argc, char **argv)</p>

<pre><code>         c, "num-threads", H2O_CONFIGURATOR_FLAG_GLOBAL,
         on_config_num_threads,
         "number of worker threads (default: 1)");
</code></pre>

<ul>
<li><pre><code> h2o_config_define_command(
</code></pre></li>
<li><pre><code>     c, "use", H2O_CONFIGURATOR_FLAG_GLOBAL,
</code></pre></li>
<li><pre><code>     on_config_use,
</code></pre></li>
<li><pre><code>     "use the solution");
</code></pre>

<p> }</p>

<p> h2o_access_log_register_configurator(&amp;config.global_config);
```</p></li>
</ul>


<p>こんな感じのソリューション用意して</p>

<p>```C</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;pthread.h></h1>

<h1>include &ldquo;picrin.h&rdquo;</h1>

<h1>include &ldquo;picrin/pair.h&rdquo;</h1>

<h1>include &ldquo;picrin/string.h&rdquo;</h1>

<h1>include &ldquo;picrin/error.h&rdquo;</h1>

<h1>include &ldquo;h2o.h&rdquo;</h1>

<p>pic_state <em>pic;
struct pic_lib </em>PICRIN_BASE;</p>

<p>void pic_init_contrib(pic_state <em>);
void pic_load_piclib(pic_state </em>);</p>

<p>static pic_value
pic_features(pic_state *pic)
{
  pic_get_args(pic, &ldquo;&rdquo;);</p>

<p>  return pic->features;
}</p>

<p>static pic_value
pic_libraries(pic_state *pic)
{
  pic_value libs = pic_nil_value(), lib;</p>

<p>  pic_get_args(pic, &ldquo;&rdquo;);</p>

<p>  pic_for_each (lib, pic->libs) {</p>

<pre><code>libs = pic_cons(pic, pic_car(pic, lib), libs);
</code></pre>

<p>  }</p>

<p>  return libs;
}</p>

<p>void
pic_init_picrin(pic_state <em>pic)
{
  const char </em>scheme =</p>

<pre><code>"(import (scheme base)"
"        (scheme write))"
"(define-syntax call-with-output-to-string"
"  (syntax-rules ()"
"    ((_ proc)"
"     (let ((s (open-output-string)))"
"       (proc s)"
"       (get-output-string s)))))"
"(define (-&gt;string e)"
"  (call-with-output-to-string"
"   (lambda (s)"
"     (display e s))))";
</code></pre>

<p>  pic_add_feature(pic, &ldquo;r7rs&rdquo;);</p>

<p>  pic_deflibrary (pic, &ldquo;(picrin library)&rdquo;) {</p>

<pre><code>pic_defun(pic, "libraries", pic_libraries);
</code></pre>

<p>  }</p>

<p>  pic_deflibrary (pic, &ldquo;(scheme base)&rdquo;) {</p>

<pre><code>pic_defun(pic, "features", pic_features);

pic_init_contrib(pic);
pic_load_piclib(pic);
</code></pre>

<p>  }
  pic_deflibrary (pic, &ldquo;(picrin base)&rdquo;) {</p>

<pre><code>pic_load_cstr(pic, scheme);
</code></pre>

<p>  }
}</p>

<p>const char *
pic_eval_cstr_into_cstr(pic_state <em>pic, const char </em>input)
{
  pic_value v;</p>

<p>  v = pic_read_cstr(pic, input);
  v = pic_eval(pic, v, PICRIN_BASE);
  v = pic_funcall(pic, PICRIN_BASE, &ldquo;&ndash;>string&rdquo;, pic_list1(pic, v));
  return pic_str_cstr(pic_str_ptr(v));
}</p>

<p>int
on_picrin(h2o_configurator_command_t <em>cmd, h2o_configurator_context_t </em>ctx, const char <em>config_file, yoml_t </em>config_node)
{
  const char *sexp;</p>

<p>  switch (config_node->type) {
  case YOML_TYPE_SCALAR:</p>

<pre><code>sexp = config_node-&gt;data.scalar;
break;
</code></pre>

<p>  default:</p>

<pre><code>h2o_config_print_error(cmd, config_file, config_node, "value must be a string");
return -1;
</code></pre>

<p>  }</p>

<p>  pic_try{</p>

<pre><code>puts(pic_eval_cstr_into_cstr(pic, sexp));
</code></pre>

<p>  }
  pic_catch{</p>

<pre><code>pic_print_backtrace(pic);
return -1;
</code></pre>

<p>  }
  return 0;</p>

<p>}</p>

<p>int
init_sol_picrin(h2o_configurator_command_t <em>cmd, h2o_configurator_context_t </em>ctx, const char <em>config_file, yoml_t </em>config_node)
{</p>

<p>  h2o_configurator_t *c = cmd->configurator;</p>

<p>  pic = pic_open(0, NULL, NULL);</p>

<p>  pic_init_picrin(pic);</p>

<p>  PICRIN_BASE = pic_find_library(pic, pic_read_cstr(pic, &ldquo;(picrin base)&rdquo;));</p>

<p>  h2o_config_define_command(</p>

<pre><code>  c, "picrin", H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
  on_picrin,
  "run picrin");
</code></pre>

<p>  return 0;</p>

<p>}
```</p>

<p>んでコンフィグは</p>

<p>```</p>

<h1>to find out the configuration commands, run: h2o &mdash;help</h1>

<p>use: picrin
listen:
  port:
listen:
  port: 8081
  ssl:</p>

<pre><code>certificate-file: examples/h2o/server.crt
key-file: examples/h2o/server.key
</code></pre>

<p>picrin: &ldquo;(string-append \"Hello, \&rdquo; \&ldquo;World\&rdquo;)&ldquo;
hosts:
  default:</p>

<pre><code>paths:
  /:
    file.dir: examples/doc_root
access-log: /dev/stdout
</code></pre>

<p>```</p>

<p>そして魔法のコマンドを叩いて</p>

<p><code>
$ cp ~/compile/picrin/src/{init_contrib.c,load_piclib.c} ./
$ gcc -c sol_picrin.c -std=c99   -o sol_picrin.o -I ~/compile/picrin/extlib/benz/include -I ~/compile/h2o/include -I ~/compile/h2o/deps/picohttpparser -I ~/compile/h2o/deps/yoml -DH2O_USE_LIBUV=0 -fPIC
$ gcc sol_picrin.o load_piclib.o init_contrib.o -L ~/compile/picrin/build/lib/ -l picrin -fPIC -shared -o sol_picrin.so
$ cp sol_picrin.so ~/compile/h2o
</code></p>

<p>実行すると</p>

<p><code>
$ cd ~/compile/h2o
$ ./h2o --conf example/h2o/h2o.conf
Hello, Wold
</code></p>

<p>ヤッタ！</p>

<h1>標準出力かよ</h1>

<p>ううっ。ごめんなさい。</p>

<h1>で、HTTPレスポンス版は？</h1>

<p>ごめんなさい、まだです。</p>

<p><code>file.c</code>をベースにして</p>

<p>```yaml</p>

<pre><code>paths:
  /:
    picrin.exp: "(string-append \"Hello, \" \"World\")"
</code></pre>

<p>```</p>

<p>とかしたかったんですけど間に合いませんでした。</p>

<p>ソリューションなりモジュールなりのシステムが出来たらまたトライします</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[claspがアップデートされたよ]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/06/claspgaatupudetosaretayo/"/>
    <updated>2014-12-06T23:29:46+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/06/claspgaatupudetosaretayo</id>
    <content type="html"><![CDATA[<p>κeenです。アドベントカレンダーめっちゃ書いてますね。</p>

<!-- more -->


<h1>Clasp!</h1>

<p><a href="https://github.com/drmeister/clasp">clasp</a>のmasterに色々マージされました。リリースノートには、</p>

<blockquote><p>Clasp version 0.11
* Added ASDF support.
This is still alpha. Compile the ASDF module using (core:compile-asdf).
After that you can load the module using (load &ldquo;sys:kernel;asdf;build;asdf.bundle&rdquo;).
It takes between 15-30 seconds to load (this is why I&rsquo;m integrating Cleavir).
* Added the :CLASP <em>feature</em> and removed the :ECL <em>feature</em>.
Clasp will continue to mimic the underlying ECL functionality so that
Common Lisp code that supports ECL can be made to support Clasp by converting</p>

<h1>+ecl to #+(or ecl clasp) and #-ecl to #&ndash;(or ecl clasp)</h1>

<ul>
<li>Added code to generate object files directly from Clasp.
The LLVM bitcode compiler &ldquo;llc&rdquo; no longer needs to be in the PATH
for Clasp to generate object files from Common Lisp source.
The &ldquo;ld&rdquo; linker does need to be accessible.</li>
</ul>
</blockquote>

<p>とあります。ASDFが使える！リリースノートには書いてませんがslimeサポートもmasterにコミットされてます。あとコミット読んだら最適化もされてるような…。</p>

<p><a href="http://keens.github.io/slide/clasp.html">以前</a>二十数秒掛かっていた<code>(fib 29)</code>ですが、今回はなんと</p>

<p>```
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 &hellip; loading image&hellip; it takes a few seconds
Top level.</p>

<blockquote><p>(load &ldquo;fib.lisp&rdquo;)
1346269
real time : 34.294 secs
run time  : 38.844 secs
T
(compile-file &ldquo;fib.lisp&rdquo;)</p></blockquote>

<h1>P"/home/kim/Lisp/fib.bc"</h1>

<p>NIL
NIL</p>

<blockquote><p>(load &ldquo;fib.bc&rdquo;)
1346269
real time : 21.355 secs
run time  : 25.785 secs
T
```</p></blockquote>

<p>うわぁ。遅くなってる。</p>

<p>因みに.bcファイルはLLVMの中間ファイルなのでClaspとは独立に<code>opt -f -O3 fib.bc &gt; fib.opt.bc</code>で最適化出来ます。それをやると</p>

<p>```
$ opt -f -O3 fib.bc > fib.opt.bc
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 &hellip; loading image&hellip; it takes a few seconds
Top level.</p>

<blockquote><p>(load &ldquo;fib.opt.bc&rdquo;)
1346269
real time : 34.981 secs
run time  : 37.986 secs
T
```
あれ？遅くなった。</p></blockquote>

<p>mpsはまだコンパイル中だから待ってね</p>

<h1>ASDFを使ってみる</h1>

<p>```
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 &hellip; loading image&hellip; it takes a few seconds
Top level.</p>

<blockquote><p>(time (core:compile-asdf))
zsh: segmentation fault (core dumped)  /usr/local/clasp/bin/clasp_boehm_o
```</p></blockquote>

<p>はい。解散。因みに50分くらいは動いてた。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VOPで遊ぶ]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/02/vopdeyou-bu/"/>
    <updated>2014-12-02T23:38:26+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/02/vopdeyou-bu</id>
    <content type="html"><![CDATA[<p>(:meta<br/>
 ((:this &ldquo;<a href="http://qiita.com/advent-calendar/2014/lisp">Lisp Advent Calendar 2014</a>の3日目の記事&rdquo;)<br/>
  (:prev (:author &ldquo;tk_riple&rdquo; :title <a href="http://compassoftime.blogspot.jp/2014/12/r7rs.html">&ldquo;時の羅針盤＠blog: R7RSポータブルライブラリを書く際の落とし穴&rdquo;</a>))<br/>
  (:next (:author &ldquo;nobkz&rdquo; :tite &ldquo;Shenについて&rdquo;))))</p>

<p>κeenです。さっきまでVOPで遊んでたので当初の予定を変更してVOPの話をします。</p>

<!-- more -->


<h1>VOPとは何か</h1>

<p>SBCLやCMU CLで使われているネイティブコードを吐くための機構、要はインラインアセンブラです。</p>

<h1>VOPとはどんなものか</h1>

<p>とりあえずコードをば。x86-64用です。</p>

<p>```lisp
(in-package :cl-user)
(defpackage vop-sample
  (:use :cl :sb-ext :sb-c))
(in-package :vop-sample)</p>

<p>(defknown add (fixnum fixnum)          ; addのftypeを宣言</p>

<pre><code>fixnum
(movable                            ; 副作用がない
 flushable                          ; デッドコードとして除去してよい
 foldable                           ; 定数畳み込みをしてよい
 always-translatable)               ; 必ずアセンブラコードになる
</code></pre>

<p>  :overwrite-fndb-silently t)           ; 関数上書きのエラーを出さない</p>

<p>(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::add)          ; VOP名
  (:translate vop-sample::add)         ; 関数名
  (:policy :fast-safe)                  ; declare optimize的な
  (:args (x :scs (signed-reg))          ; 引数宣言。後述</p>

<pre><code>     (y :scs (signed-reg)))
</code></pre>

<p>  (:arg-types fixnum fixnum)            ; 引数の型宣言
  (:results (r :scs (signed-reg)))      ; 返り値宣言。後述
  (:result-types fixnum)                ; 返り値の型宣言
  (:generator 4                         ; 翻訳するときのコスト</p>

<pre><code>          (move r x)                ; 返り値レジスタにxを移動
          (inst add r y)))          ; 返り値レジスタにyを足し込む
</code></pre>

<p>(in-package :vop-sample)</p>

<p>(defun add (x y)                        ; 安全なバージョンでラップする
  (add x y))
```</p>

<p>ちょっとおまじないが多いですね。</p>

<p>すこし解説すると引数は基本レジスタ渡しで、レジスタが足りなければスタックも使います。で、レジスタやスタックの値には型があります。それがストレージクラス(sc)です。この場合、x、y、rは<code>signed-reg</code>と宣言されてますね。符号付きレジスタです。<code>:scs</code>の最後のsは複数形のsです。今回は1つしか指定してませんが複数指定することも可能なのです。</p>

<p><code>move</code>というのはアセンブラ命令ではなく、マクロかなんかです（適当）。VOPなのかな？どのストレージクラスからどのストレージクラスに移動するかを認知して適切な命令を吐きます。</p>

<p><code>inst</code>が付いてるのがアセンブラですね。</p>

<p>このコード、xとrが等しいときに最適化出来るのですがそれはまあおいといて、こいつをディスアセンブルしてみましょう。</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'add)
; disassembly for ADD
; Size: 43 bytes. Origin: #x1005C26416
; 16:       488BD3           MOV RDX, RBX                     ; no-arg-parsing entry point
; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
; 2E:       CC0A             BREAK 10                         ; error trap
; 30:       02               BYTE #X02
; 31:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 32:       9A               BYTE #X9A                        ; RCX
; 33:       CC0A             BREAK 10                         ; error trap
; 35:       04               BYTE #X04
; 36:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 37:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 3A:       CC0A             BREAK 10                         ; error trap
; 3C:       04               BYTE #X04
; 3D:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 3E:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
</code></pre>

<p>主要な部分はここです。</p>

<pre><code>; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
</code></pre>

<p><code>ADD</code>の他に無駄な命令がいくつかありますね。</p>

<p>SBCLはintの下位1bitをGCのときのタグとして使ってるのでアセンブラに渡す前に算術右シフト(<code>SAR</code>)して渡してます。
そして返るときはまた左シフト(<code>SHL</code>)してます。</p>

<p>その後の</p>

<pre><code>; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
</code></pre>

<p>は関数から返るときのイディオム(スタックポインタを復元してフラグをクリアして呼び出し元に戻る)です。</p>

<p>余談ですがLispマシンなどのタグマシンは下位ビットにあるタグを無視して計算出来るのでシフトが不要になります。なので速いんですね。</p>

<h1>シフトをなくす</h1>

<p>さっきは<code>signed-reg</code>を指定しました。つまり「（アセンブラの）intをくれ」と要求した訳です。
intの下位1bitは0なので足し算する分には別にシフトされなくても問題ありませんよね。シフトを殺しましょう。</p>

<p>さっきのコードの下にこれを足します。<code>add</code>は再定義しないと反映されないようでした。</p>

<p>```lisp
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::add/v2)        ; vop名は異なる
  (:translate vop-sample::add)          ; 関数名は同じ
  (:policy :fast-safe)
  (:args (x :scs (any-reg))             ; any-regになってる</p>

<pre><code>     (y :scs (any-reg)))            ; any-regになってる
</code></pre>

<p>  (:arg-types fixnum fixnum)
  (:results (r :scs (any-reg)))         ; any-regになってる
  (:result-types fixnum)
  (:generator 3                         ; コストをさっきより低くすると優先して使ってくれる</p>

<pre><code>          (move r x)
          (inst add r y)))
</code></pre>

<p>(in-package :vop-sample)</p>

<p>(defun add (x y)
  (add x y))</p>

<p>```</p>

<p>んで、ディスアセンブルしてみると</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'add)

; disassembly for ADD
; Size: 31 bytes. Origin: #x1004C2AB83
; 83:       488BD1           MOV RDX, RCX                     ; no-arg-parsing entry point
; 86:       4801FA           ADD RDX, RDI
; 89:       488BE5           MOV RSP, RBP
; 8C:       F8               CLC
; 8D:       5D               POP RBP
; 8E:       C3               RET
; 8F:       CC0A             BREAK 10                         ; error trap
; 91:       02               BYTE #X02
; 92:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 93:       9A               BYTE #X9A                        ; RCX
; 94:       CC0A             BREAK 10                         ; error trap
; 96:       04               BYTE #X04
; 97:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 98:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 9B:       CC0A             BREAK 10                         ; error trap
; 9D:       04               BYTE #X04
; 9E:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 9F:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
</code></pre>

<p>はい。見事にSARとSHLが消えましたね。</p>

<h1>もう少し複雑な型を扱う</h1>

<p>アセンブラですし<code>(simple-array (unsigned-byte 8) (*))</code>(以下octets)を扱いたいですよね。とりあえず難しいことは考えずにoctetsの0番目の要素にアクセスしてみましょう。とはいっても<code>simple-array</code>は長さや要素の型の情報も持っていることが予想されるので少しデータを読み飛ばさないといけませんね。</p>

<p>その辺の計算が分からなかったのでsbclのソースからそれっぽいものを参考にしました。</p>

<p>```lisp
(defknown access-simple-array-0 ((simple-array (unsigned-byte 8) (*)))</p>

<pre><code>(unsigned-byte 8)
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::access-simple-array-0)
  (:translate vop-sample::access-simple-array-0)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg)))
  (:arg-types *)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4</p>

<pre><code>          (inst movzx r 
           (make-ea :byte :base x
                    :disp (- (* vector-data-offset n-word-bytes)
                           other-pointer-lowtag)))))
</code></pre>

<p>(in-package :vop-sample)
(defvar <em>octets</em> (make-array 4</p>

<pre><code>                         :element-type '(unsigned-byte 8)
                         :initial-contents '(10 11 12 13)))
</code></pre>

<p>(defun access-simple-array-0 (x)
  (access-simple-array-0 x))
```</p>

<p>こんな感じになります。境界チェックとかはやってませんが許して下さい。</p>

<p><code>descriptor-reg</code>というのがポインタが入ってるレジスタっぽいです。<code>movzx</code>は8bitの値を64bitのレジスタに符号拡張しながらロードする命令です。</p>

<p><code>make-ea</code>というのがアドレッシングですね。<code>x</code>レジスタを起点として<code>(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)</code>バイト(？ワード？)先のメモリ1byteを指します。</p>

<p>ディスアセンブルしてみましょう。みなさんもう慣れてきたと思うので主要部だけ抜き出します。</p>

<pre><code>; 65:       0FB65101         MOVZX EDX, BYTE PTR [RCX+1]      ; no-arg-parsing entry point
; 69:       48D1E2           SHL RDX, 1
</code></pre>

<p>短いですね。この<code>BYTE PTR [RCX+1]</code>が<code>make-ea</code>した値に対応します。<code>RCX</code>は<code>x</code>で<code>(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)</code>の結果が1に現れてるんでしょう。補足しておくと、<code>EDX</code>と<code>RDX</code>は同じ場所を指します。32bitとして扱うときはE、64bitとして扱うときはRで指します。</p>

<p>さて、私はx86のアドレッシングモードなんて全然知らないのですがコードを見る限りもうちょっと複雑なアドレッシングが出来るようです。</p>

<p>配列のn番目にアクセスするコードが良い例のようです。</p>

<p>```lisp
(defknown access-simple-array-n ((simple-array (unsigned-byte 8) (*)) (unsigned-byte 64))</p>

<pre><code>(unsigned-byte 8)
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::access-simple-array-n)
  (:translate vop-sample::access-simple-array-n)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg))</p>

<pre><code>     (i :scs (unsigned-reg)))
</code></pre>

<p>  (:arg-types * unsigned-num)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4</p>

<pre><code>          (inst movzx r 
           (make-ea :byte :base x
                    :scale 1
                    :index i
                    :disp (- (* vector-data-offset n-word-bytes)
                           other-pointer-lowtag)))))
</code></pre>

<p>(in-package :vop-sample)
(defun access-simple-array-n (x i)
  (access-simple-array-n x i))
```</p>

<p>新たに引数<code>i</code>をとるようになったのと<code>make-ea</code>の引数に<code>:scale 1 :index i</code>が加わってます。</p>

<p>ディスアセンブルしてみましょう。</p>

<pre><code>; 98:       0FB6543901       MOVZX EDX, BYTE PTR [RCX+RDI+1]  ; no-arg-parsing entry point
; 9D:       48D1E2           SHL RDX, 1
</code></pre>

<p>アドレッシングに<code>+RDI</code>が加わりましたね。どうして<code>i</code>(<code>RDI</code>)を<code>RAS</code>しなくていいのか気になりますがまあ、とりあえず正常に動いてるようです。</p>

<p>おわかりかと思いますがアドレッシングが<code>x</code>をベースにして今までの定数オフセット+新たにレジスタで指定したオフセットになってます。</p>

<p><code>make-ea</code>に渡した<code>:index</code>は何か分かるとしても<code>:scale</code>が気になりますよね。<code>scale</code>を2にしてディスアセンブルしてみます。</p>

<pre><code>; 58:       0FB6547901       MOVZX EDX, BYTE PTR [RCX+RDI*2+1]  ; no-arg-parsing entry point
; 5D:       48D1E2           SHL RDX, 1
</code></pre>

<p>はい。インデックスを定数倍するようですね。</p>

<h1>SSEにチャレンジ</h1>

<p>インテルアーキテクチャにあるSSEとはStreaming SIMD Extensionsの略です。じゃあSIMDは何かというとSimple Instruction Mulitple Dataの略で、1命令で複数のデータを処理出来ます。</p>

<p>この「複数のデータ」というのは64bit2つや32bit4つなどを128bitにまとめて渡します。128bitの値なんてどうやって作るんだよって感じですがsbcl-1.1.8から入った<code>sb-ext:%make-simd-pack-*</code>が存在します。</p>

<pre><code>VOP-SAMPLE&gt; (%make-simd-pack-ub32 1 2 3 4)
#&lt;SIMD-PACK  01 00 00 00  02 00 00 00  03 00 00 00  04 00 00 00&gt;
</code></pre>

<p>こんな感じです。x86_64がリトルエンディアンだったのを思い出させる表記ですね。ub32の他にub64、single、doubleが存在します。</p>

<p>ストレージクラスも<code>*-sse-reg</code>というものがあるのでこれを使いましょう。</p>

<p>```lisp
(defknown simd-add ((simd-pack (unsigned-byte 64)) (simd-pack (unsigned-byte 64)))</p>

<pre><code>(simd-pack (unsigned-byte 32))
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::simd-add)
  (:translate vop-sample::simd-add)
  (:policy :fast-safe)
  (:args (x :scs (int-sse-reg))</p>

<pre><code>     (y :scs (int-sse-reg)))
</code></pre>

<p>  (:arg-types simd-pack-int simd-pack-int)
  (:results (r :scs (int-sse-reg)))
  (:result-types simd-pack-int)
  (:generator 4</p>

<pre><code>          (move r x)
          (inst padddw r y)))
</code></pre>

<p>(in-package :vop-sample)
(defun simd-add (x y)
  (simd-add x y))
```</p>

<p>はい。こんな感じですね。<code>paddw</code>はparallel add wordですかね。これをディスアセンブルすると思ったより大きな命令になったので全部貼っときますね。</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'simd-add)

; disassembly for SIMD-ADD
; Size: 108 bytes. Origin: #x1006D64A21
; 21:       660F6FC2         MOVDQA XMM0, XMM2                ; no-arg-parsing entry point
; 25:       660FFDC1         PADDW XMM0, XMM1
; 29:       49896C2440       MOV [R12+64], RBP                ; thread.pseudo-atomic-bits
; 2E:       4D8B5C2418       MOV R11, [R12+24]                ; thread.alloc-region
; 33:       498D5320         LEA RDX, [R11+32]
; 37:       493B542420       CMP RDX, [R12+32]
; 3C:       7740             JNBE L2
; 3E:       4989542418       MOV [R12+24], RDX                ; thread.alloc-region
; 43:       498D530F         LEA RDX, [R11+15]
; 47: L0:   48C742F165030000 MOV QWORD PTR [RDX-15], 869
; 4F:       48C742F900000000 MOV QWORD PTR [RDX-7], 0
; 57:       660F7F4201       MOVDQA [RDX+1], XMM0
; 5C:       49316C2440       XOR [R12+64], RBP                ; thread.pseudo-atomic-bits
; 61:       7402             JEQ L1
; 63:       cc09             break 9                          ; pending interrupt trap
; 65: l1:   488be5           mov rsp, rbp
; 68:       f8               clc
; 69:       5d               pop rbp
; 6a:       c3               ret
; 6b:       cc0a             break 10                         ; error trap
; 6d:       02               byte #x02
; 6e:       19               byte #x19                        ; invalid-arg-count-error
; 6f:       9a               byte #x9a                        ; rcx
; 70:       cc0a             break 10                         ; error trap
; 72:       04               byte #x04
; 73:       32               byte #x32                        ; object-not-simd-pack-error
; 74:       fe1b01           byte #xfe, #x1b, #x01            ; rdx
; 77:       cc0a             break 10                         ; error trap
; 79:       04               byte #x04
; 7a:       32               byte #x32                        ; object-not-simd-pack-error
; 7b:       fe9b03           byte #xfe, #x9b, #x03            ; rdi
; 7e: l2:   6a20             push 32
; 80:       bac0854200       mov edx, 4359616                 ; alloc_tramp
; 85:       ffd2             call rdx
; 87:       5a               pop rdx
; 88:       80ca0f           or dl, 15
; 8b:       ebba             jmp l0
nil
</code></pre>

<p>なにやってるのやら。</p>

<h1>出来なかったこと</h1>

<p><code>PCMPESTRI</code>を使ってみたかったのですが扱いがトリッキーなので断念しました。具体的に言うと操作する値を格納するレジスタがEAXとECX固定なようなのです。
<code>:temporary</code>節で内部で使うレジスタも要求出来るようなのですが名指しでもらえるんですかね。</p>

<p>SSEの使い方とsimple-arrayから要素の配列を取り出す方法までは示したので誰かやって下さい。</p>

<p>参考資料いっぱい置いときますね。</p>

<p>VOPの使い方。最初の方に出てきたaddの最適化のやつとかも出てくる。(en)
: <a href="http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/">How to Define New Intrinsics in SBCL &ndash; Paul Khuong mostly on Lisp</a></p>

<p>SBCLのsimd-packの具体的解説(en)
: <a href="http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html">Hacking SSE Intrinsics in SBCL (part 1) &ndash; Paul Khuong mostly on Lisp</a></p>

<p>SBCLでVOPとSSEを使ってマンデルブロ集合を計算する(en)
<a href="http://www.pvk.ca/Blog/2013/06/05/fresh-in-sbcl-1-dot-1-8-sse-intrinsics/">Fresh in SBCL 1.1.8: SSE Intrinsics! &ndash; Paul Khuong mostly on Lisp</a></p>

<p>IntelのPCMPESTRIとかのマニュアル(en)
: <a href="https://software.intel.com/en-us/node/514244">Packed Compare Intrinsics</a></p>

<p>MicrosoftのPCMPESTRIのマニュアル。こっちの方が分かりやすい(en)
<a href="http://msdn.microsoft.com/en-us/library/bb531465.aspx">_mm_cmpestri</a></p>

<p>PCMPISTRIを使った<code>strlen</code>の実装例(ja)
: <a href="http://homepage1.nifty.com/herumi/prog/intel-opt.html">Intel optimization</a></p>

<p>PCMPESTRIを使ってHTTPパーサーを高速化した話。これをやりたかった。(en)
: <a href="http://blog.kazuhooku.com/2014/12/improving-parser-performance-using-sse.html">Kazuho&rsquo;s Weblog: Improving Parser Performance using SSE Instructions (in case of PicoHTTPParser)</a></p>

<h1>おわりに</h1>

<p>おつかれ様でした。たまには低レベルなことをやっても良いんじゃないでしょうか。</p>

<p>明日はnobkzさんで、Shenについてです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[require, ASDF, quicklispを正しく使う]]></title>
    <link href="http://KeenS.github.io/blog/2014/11/30/quicklisp/"/>
    <updated>2014-11-30T22:05:39+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/11/30/quicklisp</id>
    <content type="html"><![CDATA[<p>κeenです。最近のCommon Lispのパッケージ管理は<code>ql:quickload</code>しか知らないという方も多いのではないでしょうか。しかしそれだけでは機能が足りないこともあります。Common Lispには様々な管理システムがあるので整理しましょう。</p>

<!-- more -->


<h1><code>provide</code>, <code>require</code></h1>

<p>同じファイルを読み込まないための原始的なシステムです。Common Lispの標準の機能です。<code>(require 'foo)</code>がファイルをロードし、ロードされたファイル内で<code>(provide 'foo)</code>しておくと2回目以降の<code>(require 'foo')</code>はファイルを読まずにすぐさま返ります。</p>

<p>ここで問題なのが<code>require</code>がどこのファイルを捜しにいくかは処理系依存なところですね。なので生の<code>require</code>は使えないと思っておいた方が良いでしょう。</p>

<h1>ASDF 3</h1>

<p>Another Sysytem Defininion Facility。過去にはAnotherじゃないSysytem Defininion Facilityもあった模様。最新版は3系です。結構APIが変っているので必ず3の情報を捜しましょう。</p>

<p>この「System」というのが聞き慣れませんが、ASDFの<code>defsystem</code>で</p>

<ol>
<li>systemに含まれるファイルの定義</li>
<li>依存systemの記述</li>
<li>その他作者、ライセンス、バージョンなどの記述</li>
<li>systemのコンパイルやロード、テストなどの操作</li>
</ol>


<p>が可能です。ASDFはCにとってのmake + ldを標榜しています。Makefile的なものは(systemname).asdになります。</p>

<p><code>require</code>との統合もされており、ASDFを適切に設定することで<code>defsystem</code>されたsystemを<code>require</code>でロードすることが出来ます。このときASDFは処理系に依存せずにASDFのパスに従って.asdファイルを捜しにいきます。</p>

<p>また、ほとんどの処理系はASDFを標準添付していて、大抵<code>(require 'asdf)</code>すれば使えるようになっています。</p>

<p>尚、コンパイル後のファイルは処理系、バージョン毎に互換性がないので本来なら適切に管理する必要がありますが、ASDFが適切に~/.cache/common-lisp以下に管理してくれます。優秀ですね。</p>

<h1>quicklisp</h1>

<p>lispプロジェクトのインストーラと微妙にパッケージマネージャ的な役割をします。</p>

<p><a href="http://beta.quicklisp.org/quicklisp.lisp">http://beta.quicklisp.org/quicklisp.lisp</a> をダウンロードしてきてそのファイルを読み込んで<code>(quicklisp-quickstart:install)</code>すれば~/quicklisp/以下にquicklispがインストールされ、ロードされます。処理系を再起動したあとまたquicklispをロードするには~/quicklisp/setup.lispを<code>load</code>します。が、毎回それをやるのが面倒な人は<code>(ql:add-to-init-file)</code>しておけば処理系の初期化ファイルに~/quicklisp/setup.lispを読み込む処理が書き加えられます。</p>

<p>さて、このquicklispを扱う上で3つの概念を覚えておくと良いです。</p>

<p>dist
:    releaseの配布元。普通は'quicklisp'のみだがほかのdistを使うことも可能。自前のやつとか。新たなdistを追加したり削除したり出来る。gitのremoteをイメージすればよい。</p>

<p>release
:    quicklispがダウンロードしてくる単位。ライブラリの作者が登録するときの単位。複数のsystemをもつこともある。</p>

<p>system
:    ASDFのsystem。ユーザーが使うときの単位。</p>

<p>さて、quicklispを使うときは通常使いたいシステムを<code>ql:quickload</code>すればそのシステムと依存システムの含まれているリリースをダウンロード、展開、ロードまでしてくれます。</p>

<p>開発中はREPLを立ち上げているので「あ、このライブライリ使おう」と思ったら<code>ql:quickload</code>するだけで即座に使えるようになりますね。</p>

<p>quicklispのリリースは毎月下旬にアップデートされていて、毎月ちゃんと全てのライブラリが対応処理系で動くことがテストされています。なのでメンテナが居なくなったライブラリはドロップします。代わりにquicklispの作者がテスト出来ないライブラリは登録させてもらえなかったりします（cl-cudaとか）</p>

<h1>quicklispの問題</h1>

<p>既にCommon Lispのライブラリマネージャとしてデファクトスタンダード的位置を築きつつあるquicklispですが、私は結構不満があります。</p>

<ul>
<li>~/quicklisp/setup.lispを読み込むとquicklispの全てを読み込んでしまう: これには過去全てのバージョンのdistとreleaseとsystemのデータベース、HTTPクライアント、圧縮ファイルの解凍ライブラリなども含まれており、処理系の起動が非常に遅くなる</li>
<li>特にデータベースはファイルに書かれていても高速に読める形式なのに初期化時に毎回全ての内容をLispのハッシュに変換するという愚行をする。</li>
<li><code>(ql:add-to-init-file)</code>が推奨されているが、前述の通り処理系の起動が遅くなってしまう。特に、（インストーラではなく、インストール済みの）ライブラリマネージャとして使いたくてもインストーラの機能までロードしてしまう。結構メモリを食うしアプリケーションには要らない。</li>
<li>処理系に依っては初期化ファイルはlispファイルをスクリプトとして使うときは読み込まれないこともあるのでスクリプトには使えない。まあ、前述の通り使いたくもない。</li>
</ul>


<p>のでライブラリマネージャにはASDFが向いてるのですが、</p>

<ul>
<li>quicklispでインストールしたシステムはquicklispを一旦ロードするかASDFの設定をいじるかしなければASDFからは使えない</li>
<li>quicklispはシステムのダウンロード/インストールだけすれば良いものをロードまでする</li>
<li>要はASDFを隠す</li>
<li>じゃASDFのラッパーかというとロードしかせず、コンパイルやテストなどはしない</li>
</ul>


<p>など様々な問題があります。</p>

<p>一応quicklispの弁護をしておくと、Common Lispは他のスクリプト言語とはちょっと使い方が違って、</p>

<ul>
<li>初期化ファイルは大抵オレオレライブラリで埋め尽くされていてそもそも起動には時間がかかる</li>
<li>Emacsのように一度REPLを立ち上げたら滅多に落とさない</li>
<li>アプリケーションも基本的にはREPLの中で使う</li>
<li>起動時間を気にするなら初期化ファイルを全てロードした、コアファイルをダンプしておいて使う</li>
</ul>


<p>といった使い方をされることが多いのです。そのような人からしてみたら細々処理されるよりも起動時間とメモリは気にしないから速いやつをくれ、となるのです。</p>

<p>じゃあそれなりにCommon Lispを使う私が何故そうしないかというと</p>

<ul>
<li>立ち上げっぱなしというのが性に合わない。立ち上がっているものを見るとすぐに落としたくなる。EmacsのヘビーユーザーだがEmacsもすぐ落とす。</li>
<li>コマンドラインアプリケーションを作りたいため、起動時間が命になる。</li>
<li>私はSBCLの開発版を使っていて、コアファイルはすぐに無効になるためコアダンプはしない（意味がない）</li>
</ul>


<p>といった理由があります。これは初心者にも共通する部分があるんじゃないでしょうか。REPLを立ち上げっぱなしにはしないし「コアダンプ？なにそれ？エラー出してんじゃん」状態でしょう。</p>

<h1>ASDFを正しく使う</h1>

<p>ということでquicklispをあまり使わない方法を紹介します。</p>

<p>前述の通り、quicklispでインストールしたシステムはquicklispを一旦ロードするかasdfの設定をいじるかしなければasdfからは使えません。具体的に言うと、</p>

<ul>
<li>ASDFのデフォルトパスは~/common-lisp以下</li>
<li>quicklispのシステムのインストールパスは~/quicklisp/dists/(dist name)/software/以下</li>
</ul>


<p>なので~/quicklisp/dists/以下にパスを通します。少し無駄なディレクトリもパスに含まれてしまうので気にする人はそれぞれのdistについて~/quicklisp/dists/(dist name)/software/にパスを通しましょう。</p>

<p>因みに拙作の<a href="https://github.com/KeenS/CIM">CIM</a>は~/.cim/quicklisp以下にquicklispをインストールするのでCIM使いの方は~/.cim/quicklisp/dists/ですね。~/quicklispの方が混乱少ないかなあ。</p>

<p>さて、ASDFの設定は<a href="http://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems">公式マニュアル</a>を参照すれば良いのですが一応実際のものを書いておくと</p>

<p>~/.config/common-lisp/source-registry.conf に
<code>lisp
(:source-registry
  (:tree "~/quicklisp/dists/")
  (:tree (:home "Lisp/"))
  :INHERIT-CONFIGURATION)
</code>
を書けばOKです。2つめのLisp/は私がCommon Lispファイルを置いているディレクトリですね。この書き方だとquicklispより自分のLispライブラリを優先して読みにいきます。開発版を使いたいときとかむしろ開発をするときとかに必須です。この設定をミスるといくら開発してもロードされてるのはリリース版で、機能が動かないとかの地獄を見ます。</p>

<p>ここまでくれば</p>

<p><code>lisp
(require 'asdf)
(require 'hoge)
</code>
とすればquicklispでインストールしたライブラリをロード出来ます。</p>

<h2>require以外のASDFの使い方</h2>

<p>バージョンに依って使い方が異なるのですが、3系だと<code>(asdf:xxx-system 'hoge)</code>などとします。具体的には</p>

<ul>
<li><code>(asdf:load-system 'hoge)</code> ( = <code>(require 'hoge)</code>)</li>
<li><code>(asdf:test-system 'hoge)</code> (テストがあるときのみ)</li>
<li><code>(asdf:compile-system 'hoge)</code></li>
</ul>


<p>を覚えておけば良いでしょう。他にもいくつか操作があるようですが私は使ったことがないです。<code>asdf:locate-system</code>は名前的に便利そうではあるんですけどね。</p>

<p>開発するときはまず.asdファイルを書いておいて(あるいはcl-projectから生成して)、<code>(require 'hoge)</code>で始めて書いていき、ある程度進んだらテストを書いてテストの項目を.asdファイルに書き足して<code>(asdf:test-system 'hoge)</code>、それなりに動くようになったら<code>(asdf:compile-system 'hoge)</code>してコンパイルの様子を見たりコンパイル後のベンチマークを取ったりします。</p>

<h2>quickloadを成仏させる</h2>

<p>これでロードの処理はASDFで全てカバー出来るようになりました。じゃあquickloadのロード機能は邪魔ですね。quicklispをインストーラとしてのみ使いましょう。</p>

<p>まず処理系の初期化ファイル(sbclなら~/.sbclrc)から</p>

<p>```lisp
;;; The following lines added by ql:add-to-init-file:</p>

<h1>-quicklisp</h1>

<p>(let ((quicklisp-init (merge-pathnames &ldquo;~quicklisp/setup.lisp&rdquo;</p>

<pre><code>                                   (user-homedir-pathname))))
</code></pre>

<p>  (when (probe-file quicklisp-init)</p>

<pre><code>(load quicklisp-init :verbose nil)))
</code></pre>

<p>```</p>

<p>を削除します。quicklispを使いたいときだけ<code>(load "~/quicklisp/setup.lisp")</code>します。そして欲しいシステムをインストールするには</p>

<p><code>lisp
(ql::recursively-install "foo")
</code></p>

<p>します。quickloadに比べて爆速です。ここにきて名前が文字列な上にexportされてないシンポル参照してますね。気持ち悪いという方は大人しくquickloadしましょう。</p>

<p>拙作のCIMにはこれをコマンドラインから行なう<code>ql install</code>なるコマンドが存在します。</p>

<h1>最後に</h1>

<p>quicklispが嫌いなのは私の好みですがASDFを正しく使えて損はないと思うので知らなかった方々は是非試してみて下さい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lisp meet up #22でLTしてきた]]></title>
    <link href="http://KeenS.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita/"/>
    <updated>2014-11-28T23:17:12+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita</id>
    <content type="html"><![CDATA[<p>κeenです。先日 Lisp Meet Up #22 でLTしてきたので報告です。</p>

<!-- more -->


<p>LTは事前に登録されたのが2件、私が当日17時くらいに登録したの1件で、参加は20人募集の内20人応募、20人参加と最近中々の人気を見せてます。</p>

<h1>Common Lispで高速なHTTPパーサーを書く(仮)</h1>

<p>LT1件目は深町さんより、「Common Lispで高速なHTTPパーサーを書く(仮)」。fast-httpを作ったときの話。</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/42153462" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/fukamachi/writing-a-fast-http-parser" title="Writing a fast HTTP parser" target="_blank">Writing a fast HTTP parser</a> </strong> from <strong><a href="//www.slideshare.net/fukamachi" target="_blank">fukamachi</a></strong> </div></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVARnhncWZpRFdUOWM/preview">動画</a></p>

<p><a href="http://blog.8arrow.org/entries/2014/10/23">深町さんのブログ</a>に書かれていることの他、fast-httpが高速になるまでの経緯や実装方針などの話もありました。</p>

<p>最初ベースにしたnode.jsのHTTPパーサ、http-parseは状態を持っていて、1文字読む毎に状態を保存していた。次にベースにしたpicohttpparseは状態を持たず、HTTPリクエストが全部届く前にパースを始めてしまった場合はあきらめて最初からパースするようにしていた。fast-httpは1行パースする毎に状態を保存するようにした。など。</p>

<p>もう一つ、http-parseは<code>while</code>ループの中に巨大な<code>case</code>文があって、現在の状態で<code>case</code>でディスパッチし、その節の中で読んだ文字に依って現在の状態を変え、またループで先頭に戻って状態に依ってディスパッチするという手法だったそうです。Common Lispの場合は<code>case</code>が全て<code>(cond ((eql ..) ....) ...)</code>に展開されて遅い<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>ので<code>while</code>と<code>case</code>じゃなくて<code>tagbody</code>と<code>goto</code>で実装したそうです。</p>

<p>この手法は一般にDirect(Navive) ThreadingだとかThreaded Codeだとか呼ばれています。主にバイトコードインタプリタを実装する時にバイトコードに依るディスパッチの部分で使われるようです。Rubyの解説が丁寧だったようなので参考資料として置いておきます。</p>

<p><a href="http://magazine.rubyist.net/?0008-YarvManiacs">Rubyist Magazine &ndash; YARV Maniacs 【第 3 回】 命令ディスパッチの高速化</a></p>

<p>会場からはアーキテクチャ依存の最適化はしないのかとの質問がありました。SBCLにはインラインアセンブラであるVOPなるものが存在するのでSIMD命令使えば、とかいう怖い話ですね。</p>

<h1>symbol tree diff</h1>

<p>LT2件目はchikuさんより「symbol tree diff」。chikuさんが以前から取り組んでいるプログラムのdiffを構文レベルでとる話の進捗。</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/42160384" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/samugari/symbol-treediff" title="Symbol tree-diff" target="_blank">Symbol tree-diff</a> </strong> from <strong><a href="//www.slideshare.net/samugari" target="_blank">samugari</a></strong> </div></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVARUoxVGtiMlFrRVU/preview">動画</a></p>

<p>diff自体はとれるようになったようですが見せ方に問題があり、見易い形式を模索中のようです。会場に見易い形式は何か投げ掛けましたが良い案を見付けるのは難しいようです。</p>

<h1>Semantic S式</h1>

<p>私から「Semantic S式」。括弧が多い方が嬉しいこともあるよねーというゆるい話。
<a href="http://keens.github.io/slide/semantic-sshi.html">Semantic S式 | κeenのHappy Hacκing Blog</a></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVAQms2QkZDcnZfVlU/preview">動画</a></p>

<p>会場からは半分同意、半分ツッコみたいとの反応が。plistをリテラルから<code>getf</code>するやついないだろ、とか。</p>

<h1>懇親会</h1>

<p>私の発表で21時あたりだったのでそのまま解散して懇親会。隣にLand of Lispを読んでLispに興味持ってLispの授業をとってる方がいたのでどの本が入門に良いかなど。</p>

<p>VOPの話の続きもしました。どうしても資料がないのがネックだよねー、と。私の知っているのは</p>

<p><a href="http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/">How to Define New Intrinsics in SBCL &ndash; Paul Khuong mostly on Lisp</a></p>

<p>や</p>

<p><a href="http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html">Hacking SSE Intrinsics in SBCL (part 1) &ndash; Paul Khuong mostly on Lisp</a></p>

<p>かな。日本語のやってみた系だとg1さんの</p>

<p><a href="http://g000001.cddddr.org/2011-12-08">#:g1: SBCLでVOPを使ってみよう</a></p>

<p>あたり。</p>

<h1>その他</h1>

<p>テンプレートエンジンを作ってるって以前深町さんに話してたら「まだ出来ないんですか？」とさんざん煽られました。はい。頑張ります。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><code>cond</code>は先頭から順番に比較する仕様です。<code>case</code>は<code>cond</code>に展開されることが仕様で定められていた筈。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
