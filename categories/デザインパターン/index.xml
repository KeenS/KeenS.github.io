<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>デザインパターン on κeenのHappy Hacκing Blog</title>
    <link>/categories/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/index.xml</link>
    <description>Recent content in デザインパターン on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rust風にデザインパターン23種</title>
      <link>/blog/2017/05/06/rustkazenidezainpata_n23tane</link>
      <pubDate>Sat, 06 May 2017 21:59:30 +0900</pubDate>
      
      <guid>/blog/2017/05/06/rustkazenidezainpata_n23tane</guid>
      <description>&lt;p&gt;κeenです。
GoFのデザインパターンは有名ですが、言語機能によっては単純化できたりあるいは不要だったりするのでRust風に書き換えたらどうなるか試してみます。

発端はこのツイート。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;デザインパターン、古いJavaの機能の足りなさのワークアラウンド的なテクニックも含まれてるからあまり宜しくないんだよね。enumやクロージャで十分なのもいくつかある。&lt;br&gt;&lt;br&gt;Rustで写経、デザインパターン23種 - Qiita&lt;a href=&#34;https://t.co/MhpS3Z2OlF&#34;&gt;https://t.co/MhpS3Z2OlF&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/860635079600513024&#34;&gt;2017年5月5日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;一応誤解のないように説明しておくと、該当のQiitaの記事に不満がある訳ではなくてGoFのデザインパターンついての言及です。&lt;/p&gt;

&lt;p&gt;リンク先のコードで十分な時にはここでは流すのでリンク先も同時に参照下さい。
また、比較しやすいようにサンプルコードはリンク先のものに則って書きます。&lt;/p&gt;

&lt;p&gt;一応デザインパターンの教科書として結城先生の本を参照しつつ書いていきます。&lt;/p&gt;

&lt;h1 id=&#34;command-パターン&#34;&gt;Command パターン&lt;/h1&gt;

&lt;p&gt;列挙型を使うところです。
Javaにまともなenumがないのでクラスが使われていますが、列挙型があるならそちらの方がデータとコードの分離ができて見通しがいいです。また、コマンドが1つの型に収まるのでトレイトオブジェクトを作る必要がなくなります。&lt;/p&gt;

&lt;p&gt;比較的マイナーな変更です。&lt;/p&gt;

&lt;p&gt;Lispだとクロージャで解決したりしますが、Rustだと列挙型の方がしっくりくるかなと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Command&amp;lt;T&amp;gt; {
    fn execute(&amp;amp;self, &amp;amp;mut T);
    fn undo(&amp;amp;self, &amp;amp;mut T);
}



struct Invoker&amp;lt;&#39;a, Cmd, T: &#39;a&amp;gt; {
    commands: Vec&amp;lt;Cmd&amp;gt;,
    target: &amp;amp;&#39;a mut T,
    current_index: usize,
}


impl&amp;lt;&#39;a, Cmd, T&amp;gt; Invoker&amp;lt;&#39;a, Cmd, T&amp;gt; {
    fn new(t: &amp;amp;&#39;a mut T) -&amp;gt; Self {
        Invoker {
            commands: Vec::new(),
            target: t,
            current_index: 0,
        }
    }


    fn target(&amp;amp;self) -&amp;gt; &amp;amp;T {
        self.target
    }

    fn append_command(&amp;amp;mut self, c: Cmd) {
        self.commands.push(c);
    }
}

impl&amp;lt;&#39;a, Cmd, T&amp;gt; Invoker&amp;lt;&#39;a, Cmd, T&amp;gt;
    where Cmd: Command&amp;lt;T&amp;gt;
{
    fn execute_command(&amp;amp;mut self) {
        if self.commands.len() &amp;lt;= self.current_index {
            // Nothing to do.
            return;
        }

        let c = &amp;amp;self.commands[self.current_index];
        let t = &amp;amp;mut *self.target;
        c.execute(t);

        self.current_index += 1;
    }

    fn execute_all_commands(&amp;amp;mut self) {
        for _ in self.current_index..self.commands.len() {
            self.execute_command();
        }
    }

    fn undo(&amp;amp;mut self) {
        if 0 == self.current_index {
            return;
        }

        self.current_index -= 1;

        let c = &amp;amp;self.commands[self.current_index];
        let t = &amp;amp;mut *self.target;
        c.undo(t);
    }
}


#[derive(Debug, Eq, PartialEq)]
struct Robot {
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
}


impl Robot {
    fn new() -&amp;gt; Robot {
        Robot {
            x: 0,
            y: 0,
            dx: 0,
            dy: 1,
        }
    }

    fn move_forward(&amp;amp;mut self) {
        self.x += self.dx;
        self.y += self.dy;
    }

    fn set_direction(&amp;amp;mut self, d: (i32, i32)) {
        self.dx = d.0;
        self.dy = d.1;
    }

    fn get_direction(&amp;amp;self) -&amp;gt; (i32, i32) {
        (self.dx, self.dy)
    }
}

enum RoboCommand {
    MoveForward,
    TurnRight,
    TurnLeft,
}

impl Command&amp;lt;Robot&amp;gt; for RoboCommand {
    fn execute(&amp;amp;self, r: &amp;amp;mut Robot) {
        use RoboCommand::*;
        match *self {
            MoveForward =&amp;gt; r.move_forward(),
            TurnRight =&amp;gt; {
                let (dx, dy) = r.get_direction();
                r.set_direction((dy, -dx))
            }
            TurnLeft =&amp;gt; {
                let (dx, dy) = r.get_direction();
                r.set_direction((-dy, dx));
            }

        }
    }
    fn undo(&amp;amp;self, r: &amp;amp;mut Robot) {
        use RoboCommand::*;
        match *self {
            MoveForward =&amp;gt; {
                let c1 = TurnRight;
                c1.execute(r);
                c1.execute(r);
                self.execute(r);
                c1.execute(r);
                c1.execute(r);
            }
            TurnRight =&amp;gt; {
                let c = TurnLeft;
                c.execute(r);
            }
            TurnLeft =&amp;gt; {
                let c = TurnRight;
                c.execute(r);

            }

        }
    }
}



fn main() {
    let mut r = Robot::new();

    let mut invoker = Invoker::new(&amp;amp;mut r);
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 0,
                   dy: 1,
               });

    {
        use RoboCommand::*;
        invoker.append_command(TurnRight);
        invoker.append_command(TurnLeft);
        invoker.append_command(MoveForward);
    }

    invoker.execute_all_commands();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 1,
                   dx: 0,
                   dy: 1,
               });

    invoker.undo();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 0,
                   dy: 1,
               });

    invoker.undo();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 1,
                   dy: 0,
               });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;stateパターン&#34;&gt;Stateパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。トレイトオブジェクトを使う代表的なケースだと思います。。
あるいは列挙型を使う可能性もあります。&lt;/p&gt;

&lt;h1 id=&#34;strategyパターン&#34;&gt;Strategyパターン&lt;/h1&gt;

&lt;p&gt;参照先でも説明されていますが、Rustにはクロージャがあるので不要です。&lt;/p&gt;

&lt;h1 id=&#34;template-methodパターン&#34;&gt;Template Methodパターン&lt;/h1&gt;

&lt;p&gt;そもそもトレイトを使った普通のプログラミングなのでRustでわざわざ名前をつけるほどかな？と個人的には思いますがあえて書くなら参照先のままです。
あるいはものによっては高階関数でも。&lt;/p&gt;

&lt;p&gt;個人的にはトレイトオブジェクトを作るより関連型を使った方が好みです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait AbstractFactory&amp;lt;&#39;a&amp;gt; {
    type ProdX: ProductX;
    type ProdY: ProductY;
    fn create_product_x(&amp;amp;self) -&amp;gt; Box&amp;lt;ProdX + &#39;a&amp;gt;;
    fn create_product_y(&amp;amp;self) -&amp;gt; Box&amp;lt;ProdY + &#39;a&amp;gt;;
}

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;mementoパターン&#34;&gt;Mementoパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです&lt;/p&gt;

&lt;h1 id=&#34;observerパターン&#34;&gt;Observerパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです&lt;/p&gt;

&lt;h1 id=&#34;visitorパターン&#34;&gt;Visitorパターン&lt;/h1&gt;

&lt;p&gt;参照先では簡単な例なので分かりづらいのですが、列挙型を使うところです。
まともな列挙型がない+シングルディスパッチしかなく引数はオーバーロードという二重苦によって生まれたパターンであり、まともな列挙型か多重ディスパッチがあれば複雑怪奇なプログラムは書かなくて済みます。&lt;/p&gt;

&lt;p&gt;ここでは参照先とは違ってもう少し複雑な例を出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Visitor&amp;lt;T&amp;gt; {
    fn visit(&amp;amp;mut self, &amp;amp;T);
}

enum Entity {
    File(String),
    Dir(String, Vec&amp;lt;Entity&amp;gt;),
}

struct ConcreteFileVisitor;

impl Visitor&amp;lt;Entity&amp;gt; for ConcreteFileVisitor {
    fn visit(&amp;amp;mut self, e: &amp;amp;Entity) {
        use Entity::*;
        match *e {
            File(ref name) =&amp;gt; println!(&amp;quot;file: {}&amp;quot;, name),
            Dir(ref name, ref files) =&amp;gt; {
                println!(&amp;quot;dir: {}&amp;quot;, name);
                for file in files {
                    self.visit(file)
                }
            }
        }
    }
}

fn main() {
    use Entity::*;
    let e = Dir(&amp;quot;/&amp;quot;.to_string(),
                vec![File(&amp;quot;etc&amp;quot;.to_string()), File(&amp;quot;usr&amp;quot;.to_string())]);
    let mut visitor = ConcreteFileVisitor;
    visitor.visit(&amp;amp;e);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特段パターンというほどの処理をしている感じがしませんね。&lt;/p&gt;

&lt;h1 id=&#34;iteratorパターン&#34;&gt;Iteratorパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;mediatorパターン&#34;&gt;Mediatorパターン&lt;/h1&gt;

&lt;p&gt;だいたい参照先のままです。複雑なことをしようと思うと&lt;code&gt;Colleague&lt;/code&gt;が複数種類出てきて列挙型かトレイトオブジェクトが必要になりそうな気がします。&lt;/p&gt;

&lt;h1 id=&#34;interpreterパターン&#34;&gt;Interpreterパターン&lt;/h1&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h1 id=&#34;builderパターン&#34;&gt;Builderパターン&lt;/h1&gt;

&lt;p&gt;あまりここまで抽象化してるのは見たことありませんがやるとしたら参照先のままです。
そもそもRustには継承がないので抽象化する意義があまりなく、型固有のBuilderパターンで十分です。&lt;/p&gt;

&lt;h1 id=&#34;prototypeパターン&#34;&gt;Prototypeパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;factoryパターン&#34;&gt;Factoryパターン&lt;/h1&gt;

&lt;p&gt;クロージャで十分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Product {
    fn convert(&amp;amp;self, String) -&amp;gt; String;
}


struct Factory;

impl Factory {
    fn convert&amp;lt;P, F&amp;gt;(&amp;amp;self, s: String, create_product: F) -&amp;gt; String
        where P: Product,
              F: FnOnce() -&amp;gt; P
    {
        create_product().convert(s)
    }
}


struct ConcreteProductX;
impl Product for ConcreteProductX {
    fn convert(&amp;amp;self, s: String) -&amp;gt; String {
        s.to_uppercase()
    }
}


fn main() {
    let f = Factory;
    println!(&amp;quot;{}&amp;quot;,
             f.convert(&amp;quot;hogehoge piyopiyo&amp;quot;.to_string(), || ConcreteProductX))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;abstractfactoryパターン&#34;&gt;AbstractFactoryパターン&lt;/h1&gt;

&lt;p&gt;そもそもここまでやる？というのは置いといてやるとしたら参照先のままかなぁと思います。&lt;/p&gt;

&lt;p&gt;TemplateMethodパターンでも述べた通り個人的には関連型を使う方が好みです。&lt;/p&gt;

&lt;h1 id=&#34;chain-of-responsibility-cor-パターン&#34;&gt;Chain of Responsibility/CoR パターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;singletonパターン&#34;&gt;Singletonパターン&lt;/h1&gt;

&lt;p&gt;そもそもアンチパターンです。分かりづらいグローバル変数なだけです。あえてRustでやるとしたら&lt;a href=&#34;https://github.com/rust-lang-nursery/lazy-static.rs&#34;&gt;lazy_static&lt;/a&gt;かなと思います。&lt;/p&gt;

&lt;h1 id=&#34;adapterパターン&#34;&gt;Adapterパターン&lt;/h1&gt;

&lt;p&gt;これは捉え方が2種類あるかなーと思います。。&lt;/p&gt;

&lt;p&gt;1つにはクラスの定義時にしかインターフェースを実装できない窮屈な言語仕様へのワークアラウンドとして。
この捉え方では参照先のコードようにただトレイトを実装してしまえば終わりです。&lt;/p&gt;

&lt;p&gt;もう1つにはラッパーオブジェクトとして。&lt;code&gt;std::fs::File&lt;/code&gt;の実装とかがそれっぽいと思います。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct File {
    inner: fs_imp::File,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bridgeパターン&#34;&gt;Bridgeパターン&lt;/h1&gt;

&lt;p&gt;そもそも機能の追加とAPIの抽象化をどちらも継承に押し込める言語仕様が悪い。
それにRustでは継承しないので関係ないです。&lt;/p&gt;

&lt;h1 id=&#34;proxyパターン&#34;&gt;Proxyパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;facadeパターン&#34;&gt;Facadeパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。Rustにはモジュールや可視性の制御があって特別意識することなく普段からやっていることなのであまり名前をつけるほどのことではないと思ってます。&lt;/p&gt;

&lt;h1 id=&#34;flyweightパターン&#34;&gt;Flyweightパターン&lt;/h1&gt;

&lt;p&gt;所有権があるのでRustだとちょっと難しいパターンです。
参照だけなら参照先のように&lt;code&gt;HashMap&lt;/code&gt;にいれるか、オブジェクトを区別しないなら&lt;code&gt;Vec&lt;/code&gt;にいれるかなと思います。&lt;/p&gt;

&lt;p&gt;因みにLispとかでは&lt;code&gt;intern&lt;/code&gt;という名前で呼ばれてると思います。&lt;/p&gt;

&lt;h1 id=&#34;compositeパターン&#34;&gt;Compositeパターン&lt;/h1&gt;

&lt;p&gt;ただの列挙型の再実装です。&lt;/p&gt;

&lt;h1 id=&#34;decoratorパターン&#34;&gt;Decoratorパターン&lt;/h1&gt;

&lt;p&gt;よくあるやつです。参照先のコードの他、&lt;code&gt;std::io::WriteBuf&lt;/code&gt;のようなものが代表的です。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;デザインパターンをdisろうと思って書いたのですが案外多くのケースで便利でした。Rustで不要なものは10本指で数えられる程度でしたね。すごい。&lt;/p&gt;

&lt;p&gt;因みにLisperでAIの研究者（確か今GoogleのAI研究所の所長）のPeter Norvigは&lt;a href=&#34;http://www.norvig.com/design-patterns/design-patterns.pdf&#34;&gt;Design Patterns in Dynamic Languages&lt;/a&gt;で16個はLispの機能を使えばパターンという程のものではなくなると言ってます。
それぞれどの機能でどれが不要になるかを解説しているのですが、Rustは高階関数とモジュールの分に加えて列挙型の分で不要になってるかなと思います。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RustのちょっとやりすぎなBuilderパターン</title>
      <link>/blog/2017/02/09/rustnochottoyarisuginabuilderpata_n</link>
      <pubDate>Thu, 09 Feb 2017 23:03:45 +0900</pubDate>
      
      <guid>/blog/2017/02/09/rustnochottoyarisuginabuilderpata_n</guid>
      <description>&lt;p&gt;κeenです。Rustでちょっとやりすぎだけど使う側の自由度が高くて安全なBuilderパターンを思い付いたので紹介しますね。&lt;/p&gt;

&lt;p&gt;※2017-02-11T13:18:58Z+09:00 最下部に追記しました
&lt;/p&gt;

&lt;h1 id=&#34;目的コード&#34;&gt;目的コード&lt;/h1&gt;

&lt;p&gt;以下のような構造体のビルダーを作りたいとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-struct&#34;&gt;#[derive(Debug)]
struct Person {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;雑にやると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilder {
    id: Option&amp;lt;u32&amp;gt;,
    name: Option&amp;lt;String&amp;gt;,
    age: Option&amp;lt;u32&amp;gt;,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilder {
  pub fn new() -&amp;gt; Self { ... }
  pub fn id(self, id: u32) -&amp;gt; Self { ... }
  pub fn name(self, name: String) -&amp;gt; Self { ... }
  pub fn age(self, id: u32) -&amp;gt; Self { ... }
  pub fn address(self, address: String) -&amp;gt; Self { ... }
  pub fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // 返り値がOption型になってしまう
  pub fn build(self) -&amp;gt; Option&amp;lt;Person&amp;gt; {
    // try_opt!は標準ライブラリには存在しませんが各所で使われてるので動きは分かると思います
    Person {
       id: try_opt!(self.id),
       name: try_opt!(self.name),
       age: try_opt!(self.age),
       address: self.address,
       zipcode: self.zipcode,
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とbuildの返り値が&lt;code&gt;Option&lt;/code&gt;型になってしまい、あまりうれしくありません。
さらには例えば&lt;code&gt;id&lt;/code&gt;を2回呼んだらどうなるんだとかツッコミどころが数多くあります。&lt;/p&gt;

&lt;p&gt;ということで色々な回避策を先人達は考えてきました。&lt;/p&gt;

&lt;h1 id=&#34;不自由なコード&#34;&gt;不自由なコード&lt;/h1&gt;

&lt;p&gt;普通にやるなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilder {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilder {
  fn new(id: u32, name: String, age: String) -&amp;gt; Self { ... }
  fn address(self, address: String) -&amp;gt; Self { ... }
  fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // 返り値がOptionじゃない
  fn build(self) -&amp;gt; Person { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;Option&lt;/code&gt;でないフィールドをコンストラクタで受け取れば安全に作れますが、コンストラクタを呼ぶ時点でいくつかフィールドが揃っている必要がある、そもそも元の構造体と何が違うんだ、など色々問題があります。&lt;/p&gt;

&lt;h1 id=&#34;少しマシなコード&#34;&gt;少しマシなコード&lt;/h1&gt;

&lt;p&gt;オートマトンのようにビルダーが状態遷移するコードを使うと、1つ1つの引数をビルドしつつ安全なコードが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilderId;
struct PersonBuilderName{id: u32}
struct PersonBuilderAge{id: u32, name: String}
struct PersonBuilder {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilderId {
  pub fn new() -&amp;gt; Self { ... }
  // idの次はname
  pub fn id(self, id: u32) -&amp;gt; PersonBuilderName {
    PersonBuilderName { id: id }
  }
}

impl PersonBuilderName {
  // nameの次はage
  pub name(self, name: String) -&amp;gt; PersonBuilderAge {
    PersonBuilderAge {
      id: self.id,
      name: name,
    }
  }
}
impl PersonBuilderAge {
  // ageは最後
  pub name(self, age: u32) -&amp;gt; PersonBuilder {
    PersonBuilder {
      id: self.id,
      name: self.name,
      age: age,
      address: None,
      zipcode: None,
    }
  }
}

impl PersonBuilder {
  // 気持ち悪いけど PersonBuilderIdを返す
  pub fn new -&amp;gt; PersonBuilderId { ... }
  pub fn address(self, address: String) -&amp;gt; Self { ... }
  pub fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // これまたOptionじゃなくなってる
  pub fn build(self) -&amp;gt; Person { ... }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは以下のように&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
  let person = PersonBuilder::new()
         .id(1)
         .name(&amp;quot;κeen&amp;quot;.to_string())
         .age(24)
         .address(&amp;quot;Tokyo&amp;quot;.to_string())
         .build();
  println!(&amp;quot;{:?}&amp;quot;, person)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と使えます(即興で書いたので試してないけど)。&lt;/p&gt;

&lt;p&gt;とりあえず使えそうな気がしますが、型レベルで状態遷移をハードコードしているのでメソッドを呼び出す順番が固定されてしまいます。
なので以下はエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
  let person = PersonBuilder::new()
         // nameとidを逆順に呼び出してみる
         .name(&amp;quot;κeen&amp;quot;.to_string())
         .id(1)
         .age(24)
         .address(&amp;quot;Tokyo&amp;quot;.to_string())
         .build();
  println!(&amp;quot;{:?}&amp;quot;, person)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは単純に&lt;code&gt;struct PersonBuilderId&lt;/code&gt;、&lt;code&gt;struct PersonBuilderName{id: u32}&lt;/code&gt;、&lt;code&gt;struct PersonBuilderAge{id: u32, name: String}&lt;/code&gt;と作っていくのが面倒という話もあります。&lt;/p&gt;

&lt;p&gt;今回はそれを改善したいという話&lt;/p&gt;

&lt;h1 id=&#34;幽霊型を使ったフィールド状態&#34;&gt;幽霊型を使ったフィールド状態&lt;/h1&gt;

&lt;p&gt;今回提案するビルダー型はこれです。提案するといってもどうせ既に誰かが考えてるでしょうが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::marker::PhantomData;
struct Empty;
struct Filled;

struct PersonBuilder&amp;lt;Id, Name, Age&amp;gt; {
    id: Option&amp;lt;u32&amp;gt;,
    id_state: PhantomData&amp;lt;Id&amp;gt;,
    name: Option&amp;lt;String&amp;gt;,
    name_state: PhantomData&amp;lt;Name&amp;gt;,
    age: Option&amp;lt;u32&amp;gt;,
    age_state: PhantomData&amp;lt;Age&amp;gt;,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/marker/struct.PhantomData.html&#34;&gt;PhantomData&lt;/a&gt;という特殊な型を使ってビルダーに余計な型を付けています。&lt;/p&gt;

&lt;p&gt;この型、最初は&lt;code&gt;Empty&lt;/code&gt;から出発します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl PersonBuilder&amp;lt;Empty, Empty, Empty&amp;gt; {
    pub fn new() -&amp;gt; Self {
        PersonBuilder {
            id: None,
            id_state: PhantomData,
            name: None,
            name_state: PhantomData,
            age: None,
            age_state: PhantomData,
            address: None,
            zipcode: None,
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてフィールドが埋められると対応する型がEmptyからFilledになります。&lt;/p&gt;

&lt;p&gt;フィールドに&lt;code&gt;Some&lt;/code&gt;が埋められるのと同時に対応する&lt;code&gt;_state&lt;/code&gt;フィールドを&lt;code&gt;Empty&lt;/code&gt;から&lt;code&gt;Filled&lt;/code&gt;にすると整合性が崩れません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Id以外、つまりNameとAgeはいじらないのでジェネリクスに
impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        PersonBuilder {
            id: Some(id),
            id_state: PhantomData,
            name: self.name,
            name_state: self.name_state,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
impl&amp;lt;Id, Age&amp;gt; PersonBuilder&amp;lt;Id, Empty, Age&amp;gt; {
    // 地味なテクニックとして、SringではなくてInto&amp;lt;String&amp;gt;で受けることでリテラルのStringとかも受け取れる。
    pub fn name&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(self, name: S) -&amp;gt; PersonBuilder&amp;lt;Id, Filled, Age&amp;gt; {
        PersonBuilder {
            id: self.id,
            id_state: self.id_state,
            name: Some(name.into()),
            name_state: PhantomData,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}

impl&amp;lt;Id, Name&amp;gt; PersonBuilder&amp;lt;Id, Name, Empty&amp;gt; {
    pub fn age(self, age: u32) -&amp;gt; PersonBuilder&amp;lt;Id, Name, Filled&amp;gt; {
        PersonBuilder {
            id: self.id,
            id_state: self.id_state,
            name: self.name,
            name_state: self.name_state,
            age: Some(age),
            age_state: PhantomData,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt;のままで構わないフィールドについては雑で構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;Id, Name, Age&amp;gt; PersonBuilder&amp;lt;Id, Name, Age&amp;gt; {
    pub fn address&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(mut self, address: S) -&amp;gt; Self {
        self.address = Some(address.into());
        self
    }

    pub fn zipcode&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(mut self, zipcode: S) -&amp;gt; Self {
        self.zipcode = Some(zipcode.into());
        self
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして必須フィールド全てが満たされた時にだけ&lt;code&gt;build&lt;/code&gt;が呼べます。&lt;code&gt;unwrap&lt;/code&gt;を呼んでますが安全であることに注意して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl PersonBuilder&amp;lt;Filled, Filled, Filled&amp;gt; {
    pub fn build(self) -&amp;gt; Person {
        Person {
            id: self.id.unwrap(),
            name: self.name.unwrap(),
            age: self.age.unwrap(),
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、呼び出しが非常に自由になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let person = PersonBuilder::new()
        .age(24)
        .id(1)
        .address(&amp;quot;Tokyo&amp;quot;)
        .name(&amp;quot;κeen&amp;quot;)
        .build();
    println!(&amp;quot;{:?}&amp;quot;, person);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メソッドは自由に組み換えられますが、必須フィールドがなかったら&lt;code&gt;build&lt;/code&gt;が呼べません（コンパイルエラー）になります。&lt;/p&gt;

&lt;p&gt;これは応用も出来て、それぞれの状態が独立しているので例えば「2つのVector合計3つ以上要素が入っていたら」、とか「R、G、BあるいはH、S、Vの3つが揃っていたら」とかオートマトンではエンコードしづらいものでも比較的楽に書けます。&lt;/p&gt;

&lt;p&gt;ということで便利なbuilderが出来ました。めでたしめでたし。といいたいところですが、ちょっとコードが冗長ですよね。マクロで生成なんかも出来るのですがあまりやりたくありません。ということで「ちょっとやりすぎな」Builderパターンでした。&lt;/p&gt;

&lt;h1 id=&#34;some-like-it-unsafe&#34;&gt;Some like it unsafe&lt;/h1&gt;

&lt;p&gt;上のコード、実はもうちょっと短く書けます。ただし&lt;code&gt;unsafe&lt;/code&gt;な機能を使いますが。&lt;/p&gt;

&lt;p&gt;こう書いていたものが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        PersonBuilder {
            id: Some(id),
            id_state: PhantomData,
            name: self.name,
            name_state: self.name_state,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/mem/fn.transmute.html&#34;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;を使うことで2行になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::transmute;

impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(mut self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        self.id = Some(id);
        unsafe { transmute(self) }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すごいですね。
しかし、案外しょっちゅうtransmuteはミスなどで間違った変換をしてしまう（上記で言えばidフィールドを更新したのにname_stateの型を変更してしまう）上に型検査で弾けないので個人的にはあまりおすすめ出来ません。
これも「ちょっとやりすぎ」なTipsでした。&lt;/p&gt;

&lt;h1 id=&#34;2017-02-11t13-18-58z-09-00-追記&#34;&gt;2017-02-11T13:18:58Z+09:00 追記&lt;/h1&gt;

&lt;p&gt;qnighyさんからもっと便利な方法の提案がありました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;こう &lt;a href=&#34;https://t.co/undNgEM2IQ&#34;&gt;https://t.co/undNgEM2IQ&lt;/a&gt; やったらunwrapしなくてすみそう？ / “RustのちょっとやりすぎなBuilderパターン | κeenのHappy Hacκing Blog” &lt;a href=&#34;https://t.co/ogDOpYifjh&#34;&gt;https://t.co/ogDOpYifjh&lt;/a&gt;&lt;/p&gt;&amp;mdash; Masaki⊣Hara (@qnighy) &lt;a href=&#34;https://twitter.com/qnighy/status/830053476096843776&#34;&gt;2017年2月10日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;実際のコードはこちら。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/qnighy/e7a833eebd57ef778eaff3a8ab3649d7.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;transmuteを使ったサボった実装は出来なくなるけどそもそも余計なフィールドを使う必要がなくなるので手軽ですね。&lt;/p&gt;

&lt;p&gt;qnighyさんありがとうございました。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>