<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on </title>
    <link>/categories/linux/</link>
    <description>Recent content in Linux on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 14 Feb 2016 22:37:35 +0900</lastBuildDate>
    <atom:link href="/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>readlineの作り方</title>
      <link>/post/readlinenotsukurikata/</link>
      <pubDate>Sun, 14 Feb 2016 22:37:35 +0900</pubDate>
      
      <guid>/post/readlinenotsukurikata/</guid>
      <description>

&lt;p&gt;κeenです。なんか伏線っぽいもの回収しといた方が良いかなと思ってLinuxっぽい話でも。&lt;/p&gt;

&lt;p&gt;readlineって便利ですよね。
でもCで書かれているから他の言語から使おうと思うと面倒だったり使えなかったりGPLv3の所為で使えなかったりしますよね。
そこである程度POSIXのインターフェースを扱わせてくれる言語でのreadlineの作り方でも。&lt;/p&gt;

&lt;h1 id=&#34;カノニカルモードとエコーモード:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;カノニカルモードとエコーモード&lt;/h1&gt;

&lt;p&gt;readlineの仕組み自体は簡単で、全ての文字入力を受け取って、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readlineの制御キーシーケンスなら指定の制御を行なう&lt;/li&gt;
&lt;li&gt;普通の文字ならそのまま画面に表示する&lt;/li&gt;
&lt;li&gt;コントロールシーケンスなら &lt;code&gt;^W&lt;/code&gt; などとエスケープ表示する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これだけです。しかしそう簡単ではありません。
あなたのお気に入りの言語で &lt;code&gt;readchar&lt;/code&gt; っぽい関数を実行してみると分かるかと思いますが、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一文字入力しただけではプログラムに入力文字が渡されない。エンターキーを押して初めてプログラムの &lt;code&gt;readchar&lt;/code&gt; 関数が返る。&lt;/li&gt;
&lt;li&gt;入力した文字がそのままエコーバックされる。すなわち、 &lt;code&gt;←&lt;/code&gt; を押しても &lt;code&gt;^[[D&lt;/code&gt; が入力されてしまい、制御上不都合。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;私は昔はこれらの挙動が適切な関数がないからだと思ってました。しかし、そうではありません。
このような挙動をするのはプログラムの責任でもでもシェルの責任でもなくターミナルの責任です。&lt;/p&gt;

&lt;p&gt;ターミナルには多彩なモードがあり、それによって挙動が変わるのです。
つまり、1.の挙動をするのはカノニカルモードの挙動、2.の挙動をするのはエコーモードの挙動なのです。&lt;/p&gt;

&lt;h1 id=&#34;tcgetattr-と-tcsetattr:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;&lt;code&gt;tcgetattr&lt;/code&gt; と &lt;code&gt;tcsetattr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、ターミナルのモードはプログラム側から変更出来ます。それを行なうのが &lt;code&gt;tcgetattr(3)&lt;/code&gt; と &lt;code&gt;tcsetattr(3)&lt;/code&gt; です。
ざっくり言うと &lt;code&gt;tcgetattr&lt;/code&gt; で現在のターミナルのコンフィグレーションを取得して、それを所望のモードに書き換え、 &lt;code&gt;tcsetattr&lt;/code&gt; を使って反映出来ます。&lt;/p&gt;

&lt;p&gt;今回はカノニカルモードとエコーモードをoffにしたいのですごい雑なコードだとこう書けるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;sb-posix)
(let* ((stdin 0)
       (termios (sb-posix:tcgetattr stdin))
       (lflag (sb-posix:termios-lflag termios)))
  (setf lflag (logand lflag (lognot sb-posix:icanon)))
  (setf lflag (logand lflag (lognot sb-posix:echo)))
  (setf (sb-posix:termios-lflag termios) lflag)
  (sb-posix:tcsetattr stdin sb-posix:tcsadrain termios))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、これは雑すぎます。なぜならreadlineを実行し終わった後にターミナルを元の状態に復元する必要があるからです。
そうしないとreadlineするつもりのない入力関数が予期せぬ挙動をするでしょう。
あるいはLispプロセスを終了した後のターミナルにまで影響が及びます。
なので &lt;strong&gt;必ず&lt;/strong&gt; 処理が終わったらターミナルの状態を復元する必要があります。&lt;/p&gt;

&lt;p&gt;さて、Common Lispではこの「必ず」は &lt;code&gt;unwind-protect&lt;/code&gt; を使った &lt;code&gt;with-&lt;/code&gt; マクロで実現するのが常套手段です。
コードはこのようになるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro with-readline-mode (&amp;amp;body body)
  (let ((stdin       (gensym &amp;quot;stdin&amp;quot;))
        (old-termios (gensym &amp;quot;old-termios&amp;quot;))
        (new-termios (gensym &amp;quot;new-termios&amp;quot;))
        (lflag       (gensym &amp;quot;lflag&amp;quot;)))
    `(let* ((,stdin 0)
            (,old-termios (sb-posix:tcgetattr ,stdin))
            (,new-termios (sb-posix:tcgetattr ,stdin))
            (,lflag (sb-posix:termios-lflag ,new-termios)))
       (unwind-protect
            (progn
              (setf ,lflag (logand ,lflag (lognot sb-posix:icanon)))
              (setf ,lflag (logand ,lflag (lognot sb-posix:echo)))
              (setf (sb-posix:termios-lflag ,new-termios) ,lflag)
              (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,new-termios)
              ,@body)
        (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,old-termios)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(with-readline-mode
  (format t &amp;quot;~a~%&amp;quot; (read-char)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとするとターミナルのモードが変わったことが実感出来るでしょう。&lt;/p&gt;

&lt;p&gt;尚、繰り返すとこれはターミナルの設定の話なのでEmacs内から試そうとしても正常に動作しない筈です。&lt;/p&gt;

&lt;h1 id=&#34;コントロールシーケンス:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;コントロールシーケンス&lt;/h1&gt;

&lt;p&gt;さて、Common Lispの標準にない拡張機能が必要なのはターミナルのモード変更だけで、あとは好き勝手出来るのですが私も少し嵌った部分があるのでそこだけ。&lt;/p&gt;

&lt;p&gt;readlineに欲しい機能はなんでしょうか。色々あるかと思いますが、まずは &lt;code&gt;←&lt;/code&gt; 、 &lt;code&gt;→&lt;/code&gt; でカーソル移動をしたいのではないでしょうか。
実はこれが大落し穴。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;←&lt;/code&gt; キーを押すとターミナルにはなんと3文字入力されます。すなわち、 Esc文字の &lt;code&gt;^[&lt;/code&gt; 、普通のASCII文字の &lt;code&gt;[&lt;/code&gt; 、そして大文字の &lt;code&gt;D&lt;/code&gt; です。&lt;/p&gt;

&lt;p&gt;そしてカーソルの移動文字を受けてカーソルを移動するにはターミナルにそのままEsc文字の &lt;code&gt;^[&lt;/code&gt; 、普通のASCII文字の &lt;code&gt;[&lt;/code&gt; 、そして大文字の &lt;code&gt;D&lt;/code&gt; を入力してあげれば出来ます。&lt;/p&gt;

&lt;p&gt;なのでこのようなコードになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defconstant left &amp;quot;[d&amp;quot;)
(defconstant right &amp;quot;[c&amp;quot;)

(defun left ()
  (format t &amp;quot;~a&amp;quot; left)
  (force-output))

(defun right ()
  (format t &amp;quot;~a&amp;quot; right)
  (force-output))


(defun readline ()
  (let ((line &#39;()))
    (flet ((self-insert (char)
             (format t &amp;quot;~c&amp;quot; char)
             (setf line (cons char line))
             (force-output)))
      (with-readline-mode
       (loop
          (let* ((char (read-char))
                 (code (char-code char)))
            (case code
              ; escape
              ((#b11011)
               (let* ((char (read-char))
                      (code (char-code char)))
                 ;; (write-line &amp;quot;called&amp;quot;)
                 ;; (format t &amp;quot;~a~%&amp;quot; char)
                 ;; (format t &amp;quot;~a~%&amp;quot; code)
                 (case char
                   ((#\[)
                    (let* ((char (read-char))
                           (code (char-code char)))
                      (case char
                        ((#\c) (right))
                        ((#\d) (left)))))
                   ((t)
                    (self-insert #\escape)
                    (self-insert char)))))
              ((#b1010)
               (return-from readline (coerce (reverse line) &#39;string)))
              (t (self-insert char)))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;case&lt;/code&gt; をネストしていくのはダルいし拡張性がないので現実的にはtrie木を使うことになるかと思いますが単純にはこのようなコードでreadlineを作れます。&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s Happy Hacκking!&lt;/p&gt;

&lt;h1 id=&#34;付録a-伏線:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;付録A: 伏線&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;適当に魚と野菜炒めたらオサレっぽくなった &lt;a href=&#34;https://t.co/9IIzhIGjzd&#34;&gt;pic.twitter.com/9IIzhIGjzd&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/698821538686984192&#34;&gt;2016, 2月 14&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 魚は何？タラ？だったら季節物だし、旬の鱈と野菜のソテー、詳解Linuxカーネルを添えて。と命名しよう&lt;/p&gt;&amp;mdash; Shinnosuke Takeda (@cnosuke) &lt;a href=&#34;https://twitter.com/cnosuke/status/698824048319410176&#34;&gt;2016, 2月 14&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;付録b-pure-rubyなreadlineのソースコード:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;付録B: Pure Rubyなreadlineのソースコード&lt;/h1&gt;

&lt;p&gt;努力が必要ということが読み解ければ幸いです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ConnorAtherton/rb-readline/blob/master/lib/rbreadline.rb&#34;&gt;rb-readline/rbreadline.rb at master · ConnorAtherton/rb-readline&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一時ファイルの作り方</title>
      <link>/post/ichijifairunotsukurikata/</link>
      <pubDate>Sun, 08 Nov 2015 21:40:14 +0900</pubDate>
      
      <guid>/post/ichijifairunotsukurikata/</guid>
      <description>

&lt;p&gt;Rustに&lt;a href=&#34;https://github.com/Stebalien/tempfile&#34;&gt;tempfile&lt;/a&gt;というライブラリがある。その名の通りテンポラリファイルを作るライブラリだ。
必要に迫られてそのライブラリにPRを送ろうとして実装を読んだのだが普段あまり意識しなかったテンポラリファイルの作り方を知ったのでちょっと解説してみる。&lt;/p&gt;

&lt;p&gt;Rustはほぼそのままの使い心地でCのライブラリを呼べるのでCが分かる人になら伝わると思う。&lt;/p&gt;

&lt;p&gt;ライブラリの構成として、src/*.rsにOS非依存なコードやユーザ向けのAPIがあり、src/imp/{windows,unix}.rsにOS依存なコードがある。
私はWindowsの実装には興味ないし詳しくもないのでunix向けの実装だけを見る。&lt;/p&gt;

&lt;p&gt;imp以下を見る前にこのライブライが提供するAPIを解説しておくと、大きく分けて&lt;code&gt;TempFile&lt;/code&gt;と&lt;code&gt;NamedTempFile&lt;/code&gt;がある。無名、Namedどちらにもデフォルトの一時ファイルディレクトリ下に一時ファイルを作るAPIと指定したディレクトリ以下に作るAPIとがある。
&lt;code&gt;TempFile&lt;/code&gt;が作るファイルは完全に匿名で、ファイルシステムに残らない。I/Oが出来るストリームだけを返す。定期的に/tmp以下を削除するジョブが走っていたとしても安全だし、他のプロセスに中身を読まれる危険性もない。
一方&lt;code&gt;NamedTempFile&lt;/code&gt;の方は予測不可能なファイル名でファイルを作るものの、ファイルシステムに残るので安全ではない。しかしファイル名を要求する関数や外部プロセスと協調する時に使える。&lt;/p&gt;

&lt;p&gt;それぞれで実装を見ていく。&lt;/p&gt;

&lt;h1 id=&#34;tempfile:047d25333d01b489b97d09f703fb9afe&#34;&gt;TempFile&lt;/h1&gt;

&lt;p&gt;これはLinuxとその他で実装が分かれる。ユーザーAPI側でテンポラリファイルを作るディレクトリの指定は吸収しているのでこちらではただ指定されたディレクトリ下にテンポラリファイルを作ればいい。&lt;/p&gt;

&lt;h2 id=&#34;linux:047d25333d01b489b97d09f703fb9afe&#34;&gt;Linux&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(target_os = &amp;quot;linux&amp;quot;)]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    const O_TMPFILE: libc::c_int = 0o20200000;
    match unsafe {
        libc::open(try!(cstr(dir)).as_ptr(), O_CLOEXEC | O_EXCL | O_TMPFILE | O_RDWR, 0o600)
    } {
        -1 =&amp;gt; create_unix(dir),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux 3.11から&lt;code&gt;O_TMPFILE&lt;/code&gt;が入ったので実装は直接的だ。&lt;code&gt;O_TMPFILE&lt;/code&gt;はテンポラリファイル向けにファイルシステムに名前が登録されない匿名のファイルを作る。Lispのgensymに似ている。
O_EXCLでリンクによる別名での参照を回避し、Linux 2.6.23以後で入ったO_CLOEXECで&lt;code&gt;exec(2)&lt;/code&gt;した時にfdを閉じるようにする。そうすれば関係のないプログラムからファイルが参照されるのを防げる。&lt;/p&gt;

&lt;p&gt;このライブラリコールが成功すればそのままFileを返す。&lt;/p&gt;

&lt;p&gt;Linux 3.11未満やO_TMPFILEをサポートしないファイルシステムだったら失敗し、-1が返るのでLinuxに依存しない汎用の&lt;code&gt;create_unix&lt;/code&gt;にフォールバックする。&lt;/p&gt;

&lt;h2 id=&#34;unix:047d25333d01b489b97d09f703fb9afe&#34;&gt;Unix&lt;/h2&gt;

&lt;p&gt;Unix向けの実装は恐らくPOSIX互換なシステムなら全てで動く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(not(target_os = &amp;quot;linux&amp;quot;))]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    create_unix(dir)
}

fn create_unix(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        let tmp_path = dir.join(&amp;amp;tmpname());
        return match create_named(&amp;amp;tmp_path) {
            Ok(file) =&amp;gt; {
                // I should probably tell the user this failed but the temporary file creation
                // didn&#39;t really fail...
                let _ = fs::remove_file(tmp_path);
                Ok(file)
            },
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        }
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;汎用の&lt;code&gt;create_unix&lt;/code&gt;では完全に無名のテンポラリファイルを作るのを諦めて、一旦ランダム生成な名前のファイルを作って開き、成功したらそのファイルを削除する。
1つでも開いてるプロセスがある時に削除されるとUnixのファイルはそのプロセスからは見れるが他のプロセスからは見れない状態になるので色々便利に使われている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;create_named&lt;/code&gt;は後程見るとして、ランダム生成なファイル名だと稀に既に存在するファイル名と被る可能性があるので何度かリトライしている。
リトライ回数はsrc/lib.rsで定義されていて、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const NUM_RETRIES: u32 = 1 &amp;lt;&amp;lt; 31;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。思ったよりえけつない回数リトライしている。もちろん、ファイル名が被った以外の理由でファイル生成が失敗したのならリトライに意味はないので大人しくreturnしている。&lt;/p&gt;

&lt;p&gt;で、&lt;code&gt;create_named&lt;/code&gt;だが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    match unsafe {
        libc::open(try!(cstr(&amp;amp;path)).as_ptr(), O_CLOEXEC | O_EXCL | O_RDWR | O_CREAT, 0o600)
    } {
        -1 =&amp;gt; Err(io::Error::last_os_error()),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。単に&lt;code&gt;create&lt;/code&gt;のフラグの&lt;code&gt;O_TMPFILE&lt;/code&gt;が&lt;code&gt;O_CREAT&lt;/code&gt;になっただけ。&lt;/p&gt;

&lt;h1 id=&#34;namedtempfile:047d25333d01b489b97d09f703fb9afe&#34;&gt;NamedTempFile&lt;/h1&gt;

&lt;p&gt;こちらはユーザーAPIの中から直接OS互換用コードを呼んでいる。src/named.rsに実装がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    /// Create a new temporary file in the specified directory.
    pub fn new_in&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(dir: P) -&amp;gt; io::Result&amp;lt;NamedTempFile&amp;gt; {
        for _ in 0..::NUM_RETRIES {
            let path = dir.as_ref().join(&amp;amp;util::tmpname());
            return match imp::create_named(&amp;amp;path) {
                Ok(file) =&amp;gt; Ok(NamedTempFile(Some(NamedTempFileInner { path: path, file: file, }))),
                Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
                Err(e) =&amp;gt; Err(e),
            }
        }
        Err(io::Error::new(io::ErrorKind::AlreadyExists,
                           &amp;quot;too many temporary directories already exist&amp;quot;))
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値をユーザAPI向けにラップしている以外は無名の一時ファイルと変わらない。余談だがここで使われているファイル名にユーザが干渉することが出来ず、完全にランダムなファイル名になっている。
ファイルの末尾(例えば拡張子)や先頭(例えばapp_nameなどの識別子)を挟めない。私が今作業してるパッチはその辺をもう少し自由にするものだ。&lt;/p&gt;

&lt;p&gt;閑話休題。似たような実装が2つもあるのは気になるので一応windows向けの実装も読んでみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const ACCESS: DWORD     = winapi::FILE_GENERIC_READ
                        | winapi::FILE_GENERIC_WRITE;
const SHARE_MODE: DWORD = winapi::FILE_SHARE_DELETE
                        | winapi::FILE_SHARE_READ
                        | winapi::FILE_SHARE_WRITE;
const FLAGS: DWORD      = winapi::FILE_ATTRIBUTE_HIDDEN
                        | winapi::FILE_ATTRIBUTE_TEMPORARY;


fn to_utf16(s: &amp;amp;Path) -&amp;gt; Vec&amp;lt;u16&amp;gt; {
    s.as_os_str().encode_wide().chain(Some(0).into_iter()).collect()
}

fn win_create(path: &amp;amp;Path,
                     access: DWORD,
                     share_mode: DWORD,
                     disp: DWORD,
                     flags: DWORD) -&amp;gt; io::Result&amp;lt;File&amp;gt; {

    let path = to_utf16(path);
    let handle = unsafe {
        CreateFileW(
            path.as_ptr(),
            access,
            share_mode,
            0 as *mut _,
            disp,
            flags,
            ptr::null_mut())
    };
    if handle == winapi::INVALID_HANDLE_VALUE {
        Err(io::Error::last_os_error())
    } else {
        Ok(unsafe { File::from_raw_handle(handle as RawHandle) })
    }
}

pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    win_create(path, ACCESS, SHARE_MODE, winapi::CREATE_NEW, FLAGS)
}

pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        return match win_create(
            &amp;amp;dir.join(&amp;amp;tmpname()),
            ACCESS,
            SHARE_MODE,
            winapi::CREATE_NEW,
            FLAGS | winapi::FILE_FLAG_DELETE_ON_CLOSE)
        {
            Ok(f) =&amp;gt; Ok(f),
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        };
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows向けの実装は必ずファイル名を指定する必要があり、リトライが必要そう？&lt;code&gt;NamedTempFile&lt;/code&gt;を作るには(理論的に)どの実装でもリトライが必要だからユーザAPI側で纏めたのかな？&lt;/p&gt;

&lt;h1 id=&#34;まとめ:047d25333d01b489b97d09f703fb9afe&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;テンポラリファイルを作るならまずは&lt;code&gt;O_TMPFILE&lt;/code&gt;を試す&lt;/li&gt;
&lt;li&gt;ダメならランダム生成なファイル名で成功するまでリトライ、成功したら即座にファイルを削除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作業中のコードをpushし忘れて土日に進捗出来なかったのでまたお茶を濁すはめになった。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>