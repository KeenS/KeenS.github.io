<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on κeenのHappy Hacκing Blog</title>
    <link>/categories/linux/</link>
    <description>Recent content in Linux on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 14 Apr 2016 22:51:20 +0900</lastBuildDate>
    <atom:link href="/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LXDがリリースされたらしい</title>
      <link>/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii</link>
      <pubDate>Thu, 14 Apr 2016 22:51:20 +0900</pubDate>
      
      <guid>/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii</guid>
      <description>&lt;p&gt;κeenです。頭痛い。LXDがリリースされたようなので1つ記事をば。
LXDはLinuxで動く軽量仮想化コンテナ、LXCのラッパでREST APIとCLIが提供されています。&lt;/p&gt;

&lt;p&gt;LXC、LXD共にUbuntuの開発元、Canonicalが開発しています。
LXCについては初期のDockerがバックエンドに使っていたので知名度もそこそこあるかと思いますが、
そのラッパであるLXDはこの度ようやく正式リリースされました。&lt;/p&gt;

&lt;p&gt;既にDockerがあるのになぜわざわざ新たにLXDを使うんだって気もしますが、対象とするレイヤーが違います。
Dockerはアプリケーションコンテナ、つまりアプリケーションを動かすためのプロセスより強い分離環境を提供するために使われますが
LXDはシステムコンテナ、つまり仮想マシンより軽い仮想化環境を提供します。
なのでファイルシステムはCopy on Writeしませんし一度終了したコンテナは破棄されず、再起動出来ます。
詳しくはここら辺に書いてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.stgraber.org/2016/03/11/lxd-2-0-blog-post-series-012/&#34;&gt;LXD 2.0: Blog post series [0/12] | Stéphane Graber&amp;rsquo;s website&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1つDockerとLXDの違いの分かりやすい例を出すと、それぞれのOpenStackでの立ち位置を見ると面白そうです。
Dockerは&lt;a href=&#34;https://wiki.openstack.org/wiki/Magnum&#34;&gt;OpenStack Magnum&lt;/a&gt;でOpenStack上で扱えますが、OpenStackのコンピュートノード &lt;strong&gt;上&lt;/strong&gt; で動作します。
一方LXDは&lt;a href=&#34;https://insights.ubuntu.com/2015/05/06/introduction-to-nova-compute-lxd/&#34;&gt;nova-compute-lxd&lt;/a&gt;でOpenStack上で扱えますが、 OpenStackのコンピュートノード &lt;strong&gt;として&lt;/strong&gt; 動作します。
なんだかんだ重いVMがコンテナのお陰で軽くなる訳です。そして勿論のこと、Docker in LXDなんかも出来るのでちゃんと共存出来ます。&lt;/p&gt;

&lt;p&gt;今のところUbuntu 14.04あるいは未来の16.04でリリースされているようです。Ubuntu 15.10をお使いの方は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add-apt-repository ppa:ubuntu-lxc/lxd-stable
apt-get update
apt-get dist-upgrade
apt-get install lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストール出来るようです(&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;マニュアル&lt;/a&gt;より)。
LXDはLXCのラッパでありながらもliblxcにしか依存しないのでlxc自体はインストールする必要はありません。&lt;/p&gt;

&lt;p&gt;さてこれでLXDがインストールされた訳ですが、LXDはコンテナなどのリソースを管理するデーモンとそのCLIから成ります。
CLIのコマンド名はなんと&lt;code&gt;lxc&lt;/code&gt;です。LXCのコマンド群が&lt;code&gt;lxc-*&lt;/code&gt;なので非常に勘違いしやすいですね。&lt;/p&gt;

&lt;p&gt;詳しいコマンド群は&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;マニュアル&lt;/a&gt;を読めばいいのですがそれだけだとお粗末なので多少紹介します。&lt;/p&gt;

&lt;p&gt;インストール直後は新規に作ったグループを今のログインセッションに反映させる必要があるので&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;newgrp lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする必要があります。その次は初期化が必要になります。&lt;code&gt;lxd init&lt;/code&gt;です。いくつか質問されますがデフォルトの回答を選んでいけば問題なさそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
Name of the storage backend to use (dir or zfs): zfs
error: The requested backend &#39;zfs&#39; isn&#39;t available on your system (missing tools).
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? yes
Address to bind LXD to (not including port): 0.0.0.0
Port to bind LXD to (8443 recommended): 
Invalid input, try again.

Port to bind LXD to (8443 recommended): 8443
Trust password for new clients: 
Again: 
Do you want to configure the LXD bridge (yes/no)? yes
Warning: Stopping lxd.service, but it can still be activated by:
  lxd.socket
LXD has been successfully configured.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntuでzfsが使えるのは16.04からなので15.10では使えませんでした。また、ブリッジのコンフィギュアにはウィザードが出てきます。&lt;/p&gt;

&lt;p&gt;これで初期化が終わり、コンテナを立ち上げる準備が出来ました。&lt;/p&gt;

&lt;p&gt;コンテナはイメージを元に立ち上げるのですが、今回はイメージはネット上のものから立ち上げます。
インストール時点でいくつかサーバが登録されているので名前で指定してあげるだけでよいようです。
他にイメージを使う方法はリモートのLXDをサーバとして使う、手動でファイルからインポートするなどがあるようです。&lt;/p&gt;

&lt;p&gt;ということでコンテナの立ち上げはこうです。折角なので未来のUbuntu 16.04を使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc launch ubuntu:16.04 future-ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドでビルトインの&amp;rdquo;Ubuntu&amp;rdquo;サーバにある16.04バージョンのイメージをfuture-ubuntuという名前のコンテナで立ち上げます。&lt;/p&gt;

&lt;p&gt;これでコンテナが立ち上がりました。確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc list
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
|     NAME      |  STATE  |              IPV4              |                     IPV6                     |    TYPE    | SNAPSHOTS |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
| future-ubuntu | RUNNING | 10.197.202.251 (eth0)          | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0         |
|               |         | 10.0.3.1 (lxcbr0)              |                                              |            |           |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにローカルにあるイメージも確認しましょう。インポートまで終わっているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc image list
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |                DESCRIPTION                |  ARCH  |   SIZE   |         UPLOAD DATE          |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
|       | 6cb0ba80a5fe | no     | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立ち上げたコンテナにログインしてみましょう。これはDockerをお使いの方は馴染があるんじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc exec future-ubuntu -- /bin/bash
root@future-ubuntu:~# lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu Xenial Xerus (development branch)
Release:	16.04
Codename:	xenial
root@future-ubuntu:~# exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと16.04になっているようです。&lt;/p&gt;

&lt;p&gt;コンテナの停止は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc stop future-ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。ちゃんと止まったか確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc list
+---------------+---------+------+------+------------+-----------+
|     NAME      |  STATE  | IPV4 | IPV6 |    TYPE    | SNAPSHOTS |
+---------------+---------+------+------+------------+-----------+
| future-ubuntu | STOPPED |      |      | PERSISTENT | 0         |
+---------------+---------+------+------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんとSTATEがSTOPPEDになってますね&lt;/p&gt;

&lt;p&gt;もう一度起動してみます&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc start future-ubuntu
sudo lxc list
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
|     NAME      |  STATE  |              IPV4              |                     IPV6                     |    TYPE    | SNAPSHOTS |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
| future-ubuntu | RUNNING | 10.197.202.251 (eth0)          | fdc:d0ef:6a90:89f5:216:3eff:fe42:fb45 (eth0) | PERSISTENT | 0         |
|               |         | 10.0.3.1 (lxcbr0)              |                                              |            |           |
+---------------+---------+--------------------------------+----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次はコンテナを削除します&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc stop future-ubuntu
sudo lxc delete future-ubuntu
sudo lxc list
+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
sudo lxc image list
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |                DESCRIPTION                |  ARCH  |   SIZE   |         UPLOAD DATE          |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
|       | 6cb0ba80a5fe | no     | ubuntu 16.04 LTS amd64 (beta2) (20160322) | x86_64 | 140.43MB | Apr 14, 2016 at 3:55pm (UTC) |
+-------+--------------+--------+-------------------------------------------+--------+----------+------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナが消えただけでイメージは残るんですね。&lt;/p&gt;

&lt;p&gt;さて、いかがでしょうか。軽量なVMと考えれば非常に手軽で中々面白いんじゃないでしょうか。
因みにコンテナとホスト間でのファイルのやりとりも簡単(&lt;code&gt;lxc file pull/push&lt;/code&gt;)なようなのでコンテナ内でコンパイラを動かしてホストにもってくるとかをすれば開発環境の隔離環境としても使えそうです。&lt;/p&gt;

&lt;p&gt;時間があればもう少し詳細に検証してみます。SNAPSHOTとかも試してみたかった。それでは今日はこの辺で。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>readlineの作り方</title>
      <link>/blog/2016/02/14/readlinenotsukurikata</link>
      <pubDate>Sun, 14 Feb 2016 22:37:35 +0900</pubDate>
      
      <guid>/blog/2016/02/14/readlinenotsukurikata</guid>
      <description>

&lt;p&gt;κeenです。なんか伏線っぽいもの回収しといた方が良いかなと思ってLinuxっぽい話でも。&lt;/p&gt;

&lt;p&gt;readlineって便利ですよね。
でもCで書かれているから他の言語から使おうと思うと面倒だったり使えなかったりGPLv3の所為で使えなかったりしますよね。
そこである程度POSIXのインターフェースを扱わせてくれる言語でのreadlineの作り方でも。&lt;/p&gt;

&lt;h1 id=&#34;カノニカルモードとエコーモード&#34;&gt;カノニカルモードとエコーモード&lt;/h1&gt;

&lt;p&gt;readlineの仕組み自体は簡単で、全ての文字入力を受け取って、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readlineの制御キーシーケンスなら指定の制御を行なう&lt;/li&gt;
&lt;li&gt;普通の文字ならそのまま画面に表示する&lt;/li&gt;
&lt;li&gt;コントロールシーケンスなら &lt;code&gt;^W&lt;/code&gt; などとエスケープ表示する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これだけです。しかしそう簡単ではありません。
あなたのお気に入りの言語で &lt;code&gt;readchar&lt;/code&gt; っぽい関数を実行してみると分かるかと思いますが、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一文字入力しただけではプログラムに入力文字が渡されない。エンターキーを押して初めてプログラムの &lt;code&gt;readchar&lt;/code&gt; 関数が返る。&lt;/li&gt;
&lt;li&gt;入力した文字がそのままエコーバックされる。すなわち、 &lt;code&gt;←&lt;/code&gt; を押しても &lt;code&gt;^[[D&lt;/code&gt; が入力されてしまい、制御上不都合。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;私は昔はこれらの挙動が適切な関数がないからだと思ってました。しかし、そうではありません。
このような挙動をするのはプログラムの責任でもでもシェルの責任でもなくターミナルの責任です。&lt;/p&gt;

&lt;p&gt;ターミナルには多彩なモードがあり、それによって挙動が変わるのです。
つまり、1.の挙動をするのはカノニカルモードの挙動、2.の挙動をするのはエコーモードの挙動なのです。&lt;/p&gt;

&lt;h1 id=&#34;tcgetattr-と-tcsetattr&#34;&gt;&lt;code&gt;tcgetattr&lt;/code&gt; と &lt;code&gt;tcsetattr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、ターミナルのモードはプログラム側から変更出来ます。それを行なうのが &lt;code&gt;tcgetattr(3)&lt;/code&gt; と &lt;code&gt;tcsetattr(3)&lt;/code&gt; です。
ざっくり言うと &lt;code&gt;tcgetattr&lt;/code&gt; で現在のターミナルのコンフィグレーションを取得して、それを所望のモードに書き換え、 &lt;code&gt;tcsetattr&lt;/code&gt; を使って反映出来ます。&lt;/p&gt;

&lt;p&gt;今回はカノニカルモードとエコーモードをoffにしたいのですごい雑なコードだとこう書けるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;sb-posix)
(let* ((stdin 0)
       (termios (sb-posix:tcgetattr stdin))
       (lflag (sb-posix:termios-lflag termios)))
  (setf lflag (logand lflag (lognot sb-posix:icanon)))
  (setf lflag (logand lflag (lognot sb-posix:echo)))
  (setf (sb-posix:termios-lflag termios) lflag)
  (sb-posix:tcsetattr stdin sb-posix:tcsadrain termios))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、これは雑すぎます。なぜならreadlineを実行し終わった後にターミナルを元の状態に復元する必要があるからです。
そうしないとreadlineするつもりのない入力関数が予期せぬ挙動をするでしょう。
あるいはLispプロセスを終了した後のターミナルにまで影響が及びます。
なので &lt;strong&gt;必ず&lt;/strong&gt; 処理が終わったらターミナルの状態を復元する必要があります。&lt;/p&gt;

&lt;p&gt;さて、Common Lispではこの「必ず」は &lt;code&gt;unwind-protect&lt;/code&gt; を使った &lt;code&gt;with-&lt;/code&gt; マクロで実現するのが常套手段です。
コードはこのようになるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro with-readline-mode (&amp;amp;body body)
  (let ((stdin       (gensym &amp;quot;stdin&amp;quot;))
        (old-termios (gensym &amp;quot;old-termios&amp;quot;))
        (new-termios (gensym &amp;quot;new-termios&amp;quot;))
        (lflag       (gensym &amp;quot;lflag&amp;quot;)))
    `(let* ((,stdin 0)
            (,old-termios (sb-posix:tcgetattr ,stdin))
            (,new-termios (sb-posix:tcgetattr ,stdin))
            (,lflag (sb-posix:termios-lflag ,new-termios)))
       (unwind-protect
            (progn
              (setf ,lflag (logand ,lflag (lognot sb-posix:icanon)))
              (setf ,lflag (logand ,lflag (lognot sb-posix:echo)))
              (setf (sb-posix:termios-lflag ,new-termios) ,lflag)
              (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,new-termios)
              ,@body)
        (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,old-termios)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(with-readline-mode
  (format t &amp;quot;~a~%&amp;quot; (read-char)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとするとターミナルのモードが変わったことが実感出来るでしょう。&lt;/p&gt;

&lt;p&gt;尚、繰り返すとこれはターミナルの設定の話なのでEmacs内から試そうとしても正常に動作しない筈です。&lt;/p&gt;

&lt;h1 id=&#34;コントロールシーケンス&#34;&gt;コントロールシーケンス&lt;/h1&gt;

&lt;p&gt;さて、Common Lispの標準にない拡張機能が必要なのはターミナルのモード変更だけで、あとは好き勝手出来るのですが私も少し嵌った部分があるのでそこだけ。&lt;/p&gt;

&lt;p&gt;readlineに欲しい機能はなんでしょうか。色々あるかと思いますが、まずは &lt;code&gt;←&lt;/code&gt; 、 &lt;code&gt;→&lt;/code&gt; でカーソル移動をしたいのではないでしょうか。
実はこれが大落し穴。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;←&lt;/code&gt; キーを押すとターミナルにはなんと3文字入力されます。すなわち、 Esc文字の &lt;code&gt;^[&lt;/code&gt; 、普通のASCII文字の &lt;code&gt;[&lt;/code&gt; 、そして大文字の &lt;code&gt;D&lt;/code&gt; です。&lt;/p&gt;

&lt;p&gt;そしてカーソルの移動文字を受けてカーソルを移動するにはターミナルにそのままEsc文字の &lt;code&gt;^[&lt;/code&gt; 、普通のASCII文字の &lt;code&gt;[&lt;/code&gt; 、そして大文字の &lt;code&gt;D&lt;/code&gt; を入力してあげれば出来ます。&lt;/p&gt;

&lt;p&gt;なのでこのようなコードになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defconstant left &amp;quot;[d&amp;quot;)
(defconstant right &amp;quot;[c&amp;quot;)

(defun left ()
  (format t &amp;quot;~a&amp;quot; left)
  (force-output))

(defun right ()
  (format t &amp;quot;~a&amp;quot; right)
  (force-output))


(defun readline ()
  (let ((line &#39;()))
    (flet ((self-insert (char)
             (format t &amp;quot;~c&amp;quot; char)
             (setf line (cons char line))
             (force-output)))
      (with-readline-mode
       (loop
          (let* ((char (read-char))
                 (code (char-code char)))
            (case code
              ; escape
              ((#b11011)
               (let* ((char (read-char))
                      (code (char-code char)))
                 ;; (write-line &amp;quot;called&amp;quot;)
                 ;; (format t &amp;quot;~a~%&amp;quot; char)
                 ;; (format t &amp;quot;~a~%&amp;quot; code)
                 (case char
                   ((#\[)
                    (let* ((char (read-char))
                           (code (char-code char)))
                      (case char
                        ((#\c) (right))
                        ((#\d) (left)))))
                   ((t)
                    (self-insert #\escape)
                    (self-insert char)))))
              ((#b1010)
               (return-from readline (coerce (reverse line) &#39;string)))
              (t (self-insert char)))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;case&lt;/code&gt; をネストしていくのはダルいし拡張性がないので現実的にはtrie木を使うことになるかと思いますが単純にはこのようなコードでreadlineを作れます。&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s Happy Hacκking!&lt;/p&gt;

&lt;h1 id=&#34;付録a-伏線&#34;&gt;付録A: 伏線&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;適当に魚と野菜炒めたらオサレっぽくなった &lt;a href=&#34;https://t.co/9IIzhIGjzd&#34;&gt;pic.twitter.com/9IIzhIGjzd&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/698821538686984192&#34;&gt;2016, 2月 14&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 魚は何？タラ？だったら季節物だし、旬の鱈と野菜のソテー、詳解Linuxカーネルを添えて。と命名しよう&lt;/p&gt;&amp;mdash; Shinnosuke Takeda (@cnosuke) &lt;a href=&#34;https://twitter.com/cnosuke/status/698824048319410176&#34;&gt;2016, 2月 14&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;付録b-pure-rubyなreadlineのソースコード&#34;&gt;付録B: Pure Rubyなreadlineのソースコード&lt;/h1&gt;

&lt;p&gt;努力が必要ということが読み解ければ幸いです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ConnorAtherton/rb-readline/blob/master/lib/rbreadline.rb&#34;&gt;rb-readline/rbreadline.rb at master · ConnorAtherton/rb-readline&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一時ファイルの作り方</title>
      <link>/blog/2015/11/08/ichijifairunotsukurikata</link>
      <pubDate>Sun, 08 Nov 2015 21:40:14 +0900</pubDate>
      
      <guid>/blog/2015/11/08/ichijifairunotsukurikata</guid>
      <description>

&lt;p&gt;Rustに&lt;a href=&#34;https://github.com/Stebalien/tempfile&#34;&gt;tempfile&lt;/a&gt;というライブラリがある。その名の通りテンポラリファイルを作るライブラリだ。
必要に迫られてそのライブラリにPRを送ろうとして実装を読んだのだが普段あまり意識しなかったテンポラリファイルの作り方を知ったのでちょっと解説してみる。&lt;/p&gt;

&lt;p&gt;Rustはほぼそのままの使い心地でCのライブラリを呼べるのでCが分かる人になら伝わると思う。&lt;/p&gt;

&lt;p&gt;ライブラリの構成として、src/*.rsにOS非依存なコードやユーザ向けのAPIがあり、src/imp/{windows,unix}.rsにOS依存なコードがある。
私はWindowsの実装には興味ないし詳しくもないのでunix向けの実装だけを見る。&lt;/p&gt;

&lt;p&gt;imp以下を見る前にこのライブライが提供するAPIを解説しておくと、大きく分けて&lt;code&gt;TempFile&lt;/code&gt;と&lt;code&gt;NamedTempFile&lt;/code&gt;がある。無名、Namedどちらにもデフォルトの一時ファイルディレクトリ下に一時ファイルを作るAPIと指定したディレクトリ以下に作るAPIとがある。
&lt;code&gt;TempFile&lt;/code&gt;が作るファイルは完全に匿名で、ファイルシステムに残らない。I/Oが出来るストリームだけを返す。定期的に/tmp以下を削除するジョブが走っていたとしても安全だし、他のプロセスに中身を読まれる危険性もない。
一方&lt;code&gt;NamedTempFile&lt;/code&gt;の方は予測不可能なファイル名でファイルを作るものの、ファイルシステムに残るので安全ではない。しかしファイル名を要求する関数や外部プロセスと協調する時に使える。&lt;/p&gt;

&lt;p&gt;それぞれで実装を見ていく。&lt;/p&gt;

&lt;h1 id=&#34;tempfile&#34;&gt;TempFile&lt;/h1&gt;

&lt;p&gt;これはLinuxとその他で実装が分かれる。ユーザーAPI側でテンポラリファイルを作るディレクトリの指定は吸収しているのでこちらではただ指定されたディレクトリ下にテンポラリファイルを作ればいい。&lt;/p&gt;

&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(target_os = &amp;quot;linux&amp;quot;)]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    const O_TMPFILE: libc::c_int = 0o20200000;
    match unsafe {
        libc::open(try!(cstr(dir)).as_ptr(), O_CLOEXEC | O_EXCL | O_TMPFILE | O_RDWR, 0o600)
    } {
        -1 =&amp;gt; create_unix(dir),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux 3.11から&lt;code&gt;O_TMPFILE&lt;/code&gt;が入ったので実装は直接的だ。&lt;code&gt;O_TMPFILE&lt;/code&gt;はテンポラリファイル向けにファイルシステムに名前が登録されない匿名のファイルを作る。Lispのgensymに似ている。
O_EXCLでリンクによる別名での参照を回避し、Linux 2.6.23以後で入ったO_CLOEXECで&lt;code&gt;exec(2)&lt;/code&gt;した時にfdを閉じるようにする。そうすれば関係のないプログラムからファイルが参照されるのを防げる。&lt;/p&gt;

&lt;p&gt;このライブラリコールが成功すればそのままFileを返す。&lt;/p&gt;

&lt;p&gt;Linux 3.11未満やO_TMPFILEをサポートしないファイルシステムだったら失敗し、-1が返るのでLinuxに依存しない汎用の&lt;code&gt;create_unix&lt;/code&gt;にフォールバックする。&lt;/p&gt;

&lt;h2 id=&#34;unix&#34;&gt;Unix&lt;/h2&gt;

&lt;p&gt;Unix向けの実装は恐らくPOSIX互換なシステムなら全てで動く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(not(target_os = &amp;quot;linux&amp;quot;))]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    create_unix(dir)
}

fn create_unix(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        let tmp_path = dir.join(&amp;amp;tmpname());
        return match create_named(&amp;amp;tmp_path) {
            Ok(file) =&amp;gt; {
                // I should probably tell the user this failed but the temporary file creation
                // didn&#39;t really fail...
                let _ = fs::remove_file(tmp_path);
                Ok(file)
            },
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        }
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;汎用の&lt;code&gt;create_unix&lt;/code&gt;では完全に無名のテンポラリファイルを作るのを諦めて、一旦ランダム生成な名前のファイルを作って開き、成功したらそのファイルを削除する。
1つでも開いてるプロセスがある時に削除されるとUnixのファイルはそのプロセスからは見れるが他のプロセスからは見れない状態になるので色々便利に使われている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;create_named&lt;/code&gt;は後程見るとして、ランダム生成なファイル名だと稀に既に存在するファイル名と被る可能性があるので何度かリトライしている。
リトライ回数はsrc/lib.rsで定義されていて、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const NUM_RETRIES: u32 = 1 &amp;lt;&amp;lt; 31;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。思ったよりえけつない回数リトライしている。もちろん、ファイル名が被った以外の理由でファイル生成が失敗したのならリトライに意味はないので大人しくreturnしている。&lt;/p&gt;

&lt;p&gt;で、&lt;code&gt;create_named&lt;/code&gt;だが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    match unsafe {
        libc::open(try!(cstr(&amp;amp;path)).as_ptr(), O_CLOEXEC | O_EXCL | O_RDWR | O_CREAT, 0o600)
    } {
        -1 =&amp;gt; Err(io::Error::last_os_error()),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。単に&lt;code&gt;create&lt;/code&gt;のフラグの&lt;code&gt;O_TMPFILE&lt;/code&gt;が&lt;code&gt;O_CREAT&lt;/code&gt;になっただけ。&lt;/p&gt;

&lt;h1 id=&#34;namedtempfile&#34;&gt;NamedTempFile&lt;/h1&gt;

&lt;p&gt;こちらはユーザーAPIの中から直接OS互換用コードを呼んでいる。src/named.rsに実装がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    /// Create a new temporary file in the specified directory.
    pub fn new_in&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(dir: P) -&amp;gt; io::Result&amp;lt;NamedTempFile&amp;gt; {
        for _ in 0..::NUM_RETRIES {
            let path = dir.as_ref().join(&amp;amp;util::tmpname());
            return match imp::create_named(&amp;amp;path) {
                Ok(file) =&amp;gt; Ok(NamedTempFile(Some(NamedTempFileInner { path: path, file: file, }))),
                Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
                Err(e) =&amp;gt; Err(e),
            }
        }
        Err(io::Error::new(io::ErrorKind::AlreadyExists,
                           &amp;quot;too many temporary directories already exist&amp;quot;))
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値をユーザAPI向けにラップしている以外は無名の一時ファイルと変わらない。余談だがここで使われているファイル名にユーザが干渉することが出来ず、完全にランダムなファイル名になっている。
ファイルの末尾(例えば拡張子)や先頭(例えばapp_nameなどの識別子)を挟めない。私が今作業してるパッチはその辺をもう少し自由にするものだ。&lt;/p&gt;

&lt;p&gt;閑話休題。似たような実装が2つもあるのは気になるので一応windows向けの実装も読んでみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const ACCESS: DWORD     = winapi::FILE_GENERIC_READ
                        | winapi::FILE_GENERIC_WRITE;
const SHARE_MODE: DWORD = winapi::FILE_SHARE_DELETE
                        | winapi::FILE_SHARE_READ
                        | winapi::FILE_SHARE_WRITE;
const FLAGS: DWORD      = winapi::FILE_ATTRIBUTE_HIDDEN
                        | winapi::FILE_ATTRIBUTE_TEMPORARY;


fn to_utf16(s: &amp;amp;Path) -&amp;gt; Vec&amp;lt;u16&amp;gt; {
    s.as_os_str().encode_wide().chain(Some(0).into_iter()).collect()
}

fn win_create(path: &amp;amp;Path,
                     access: DWORD,
                     share_mode: DWORD,
                     disp: DWORD,
                     flags: DWORD) -&amp;gt; io::Result&amp;lt;File&amp;gt; {

    let path = to_utf16(path);
    let handle = unsafe {
        CreateFileW(
            path.as_ptr(),
            access,
            share_mode,
            0 as *mut _,
            disp,
            flags,
            ptr::null_mut())
    };
    if handle == winapi::INVALID_HANDLE_VALUE {
        Err(io::Error::last_os_error())
    } else {
        Ok(unsafe { File::from_raw_handle(handle as RawHandle) })
    }
}

pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    win_create(path, ACCESS, SHARE_MODE, winapi::CREATE_NEW, FLAGS)
}

pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        return match win_create(
            &amp;amp;dir.join(&amp;amp;tmpname()),
            ACCESS,
            SHARE_MODE,
            winapi::CREATE_NEW,
            FLAGS | winapi::FILE_FLAG_DELETE_ON_CLOSE)
        {
            Ok(f) =&amp;gt; Ok(f),
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        };
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows向けの実装は必ずファイル名を指定する必要があり、リトライが必要そう？&lt;code&gt;NamedTempFile&lt;/code&gt;を作るには(理論的に)どの実装でもリトライが必要だからユーザAPI側で纏めたのかな？&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;テンポラリファイルを作るならまずは&lt;code&gt;O_TMPFILE&lt;/code&gt;を試す&lt;/li&gt;
&lt;li&gt;ダメならランダム生成なファイル名で成功するまでリトライ、成功したら即座にファイルを削除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作業中のコードをpushし忘れて土日に進捗出来なかったのでまたお茶を濁すはめになった。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>