<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: picrin | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/picrin/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-12-19T15:28:27+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[H2Oにpicrinを溶かす]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/07/h2onipicrinworong-kasu/"/>
    <updated>2014-12-07T22:37:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/07/h2onipicrinworong-kasu</id>
    <content type="html"><![CDATA[<p>このエントリーは<br/>
<a href="http://qiita.com/advent-calendar/2014/lisp">Lisp Advent Calendar</a> 7日目<br/>
兼<br/>
<a href="http://qiita.com/advent-calendar/2014/h2o">H2O Advent Calendar</a> 7日目<br/>
の記事です。</p>

<p>κeenです。タイトルの通りです。</p>

<!-- more -->


<h1>H2Oとは</h1>

<p>水。</p>

<h1>picrinとは</h1>

<p><a href="http://ja.wikipedia.org/wiki/%E3%83%94%E3%82%AF%E3%83%AA%E3%83%B3%E9%85%B8">Wikipedia</a>にあるように、フェノールのトリニトロ化合物で、水溶性があります。</p>

<h1>ではなくて</h1>

<p>H2OはHTTP1, HTTP2, WebsocketをサポートするNginXより速いHTTPサーバです。<a href="https://github.com/h2o/h2o">Github</a>で開発されています。開発者は@kazuhoさん。</p>

<p>picrinは「速い、軽い、高機能」を目指して作られているScheme処理系です。<a href="https://github.com/picrin-scheme/picrin">Github</a>で開発されています。開発者は@wasabizさん。</p>

<h1>混ぜる</h1>

<p>picrinのように組込み向けで開発されている処理系は</p>

<ul>
<li>picrinからH2Oを使えるようにする</li>
<li>H2Oにpicrinを埋め込む</li>
</ul>


<p>と、2種類考えられますが、今回は後者です。H2Oにpicrinを溶かしてる感じしますね。</p>

<p>まあ、Apatch HTTPDやNginX宜しくmod_picrinを作れば済むでしょう。</p>

<h1>絶望</h1>

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/blackenedgold">@blackenedgold</a> モジュラーにできるようにはしてるけど、まだsoをロードする仕組みはないです。というか、APIがまだunstableだし</p>&mdash; Kazuho Oku (@kazuho) <a href="https://twitter.com/kazuho/status/540692011003559936">2014, 12月 5</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>つらい</p>

<h1>solシステムの導入</h1>

<p>mod_xxxにしようと思ったんですけど水だし溶液ってことでsol_xxxにします。</p>

<p>H2Oにこんな感じのパッチ当てて</p>

<p>```
diff &mdash;git a/src/main.c b/src/main.c
index 7fc4680..57804a6 100644
&mdash;&ndash; a/src/main.c
+++ b/src/main.c
@@ -30,6 +30,7 @@
 #include &lt;signal.h>
 #include &lt;stdio.h>
 #include &lt;unistd.h>
+#include &lt;dlfcn.h>
 #include &lt;sys/stat.h>
 #include &lt;sys/socket.h>
 #include &lt;sys/types.h>
@@ -76,6 +77,8 @@ struct config_t {</p>

<pre><code> } state;
</code></pre>

<p> };</p>

<p>+typedef int(<em>sol_init_fn)(h2o_configurator_command_t </em>, h2o_configurator_context_t <em>, const char </em>, yoml_t *);
+
 static unsigned long openssl_thread_id_callback(void)
 {</p>

<pre><code> return (unsigned long)pthread_self();
</code></pre>

<p>@@ -381,6 +384,43 @@ static int on_config_num_threads(h2o_configurator_command_t *cmd, h2o_configurat</p>

<pre><code> return h2o_config_scanf(cmd, config_file, config_node, "%u", &amp;conf-&gt;num_threads);
</code></pre>

<p> }</p>

<p>+static int on_config_use(h2o_configurator_command_t <em>cmd, h2o_configurator_context_t </em>ctx, const char <em>config_file, yoml_t </em>config_node)
+{
+  /<em> struct config_t </em>conf = H2O_STRUCT_FROM_MEMBER(struct config_t, global_config, ctx->globalconf); <em>/
+  char </em>sol_name;
+  sol_init_fn init_fn;
+  void <em>handle;
+
+  /</em> fetch solution name <em>/
+  switch (config_node->type) {
+  case YOML_TYPE_SCALAR:
+    sol_name = config_node->data.scalar;
+    break;
+  default:
+    h2o_config_print_error(cmd, config_file, config_node, &ldquo;value must be a string or a mapping (with keys: <code>port</code> and optionally <code>host</code>)&rdquo;);
+    return -1;
+  }
+
+  char dl_name[strlen(&ldquo;sol<em>.so&rdquo;) + strlen(sol_name) + 1];
+  char init_fn_name[strlen(&ldquo;init_sol</em>&rdquo;) + strlen(sol_name) + 1];
+
+  sprintf(dl_name, &ldquo;./sol<em>%s.so&rdquo;, sol_name);
+  sprintf(init_fn_name, &ldquo;init_sol</em>%s&rdquo;, sol_name);
+  handle = dlopen(dl_name, RTLD_LAZY);
+  if (! handle){
+    h2o_config_print_error(cmd, config_file, config_node, &ldquo;cannot load the solution&rdquo;);
+    return -1;
+  }
+
+  init_fn = dlsym(handle, init_fn_name);
+  if(dlerror()){
+    h2o_config_print_error(cmd, config_file, config_node, &ldquo;cannot find the initialize function&rdquo;);
+    return -1;
+  }
+  return (</em>init_fn)(cmd, ctx, config_file, config_node);
+
+}
+
 static void usage_print_directives(h2o_globalconf_t *conf)
 {</p>

<pre><code> h2o_linklist_t *node;
</code></pre>

<p>@@ -606,6 +646,10 @@ int main(int argc, char **argv)</p>

<pre><code>         c, "num-threads", H2O_CONFIGURATOR_FLAG_GLOBAL,
         on_config_num_threads,
         "number of worker threads (default: 1)");
</code></pre>

<ul>
<li><pre><code> h2o_config_define_command(
</code></pre></li>
<li><pre><code>     c, "use", H2O_CONFIGURATOR_FLAG_GLOBAL,
</code></pre></li>
<li><pre><code>     on_config_use,
</code></pre></li>
<li><pre><code>     "use the solution");
</code></pre>

<p> }</p>

<p> h2o_access_log_register_configurator(&amp;config.global_config);
```</p></li>
</ul>


<p>こんな感じのソリューション用意して</p>

<p>```C</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;pthread.h></h1>

<h1>include &ldquo;picrin.h&rdquo;</h1>

<h1>include &ldquo;picrin/pair.h&rdquo;</h1>

<h1>include &ldquo;picrin/string.h&rdquo;</h1>

<h1>include &ldquo;picrin/error.h&rdquo;</h1>

<h1>include &ldquo;h2o.h&rdquo;</h1>

<p>pic_state <em>pic;
struct pic_lib </em>PICRIN_BASE;</p>

<p>void pic_init_contrib(pic_state <em>);
void pic_load_piclib(pic_state </em>);</p>

<p>static pic_value
pic_features(pic_state *pic)
{
  pic_get_args(pic, &ldquo;&rdquo;);</p>

<p>  return pic->features;
}</p>

<p>static pic_value
pic_libraries(pic_state *pic)
{
  pic_value libs = pic_nil_value(), lib;</p>

<p>  pic_get_args(pic, &ldquo;&rdquo;);</p>

<p>  pic_for_each (lib, pic->libs) {</p>

<pre><code>libs = pic_cons(pic, pic_car(pic, lib), libs);
</code></pre>

<p>  }</p>

<p>  return libs;
}</p>

<p>void
pic_init_picrin(pic_state <em>pic)
{
  const char </em>scheme =</p>

<pre><code>"(import (scheme base)"
"        (scheme write))"
"(define-syntax call-with-output-to-string"
"  (syntax-rules ()"
"    ((_ proc)"
"     (let ((s (open-output-string)))"
"       (proc s)"
"       (get-output-string s)))))"
"(define (-&gt;string e)"
"  (call-with-output-to-string"
"   (lambda (s)"
"     (display e s))))";
</code></pre>

<p>  pic_add_feature(pic, &ldquo;r7rs&rdquo;);</p>

<p>  pic_deflibrary (pic, &ldquo;(picrin library)&rdquo;) {</p>

<pre><code>pic_defun(pic, "libraries", pic_libraries);
</code></pre>

<p>  }</p>

<p>  pic_deflibrary (pic, &ldquo;(scheme base)&rdquo;) {</p>

<pre><code>pic_defun(pic, "features", pic_features);

pic_init_contrib(pic);
pic_load_piclib(pic);
</code></pre>

<p>  }
  pic_deflibrary (pic, &ldquo;(picrin base)&rdquo;) {</p>

<pre><code>pic_load_cstr(pic, scheme);
</code></pre>

<p>  }
}</p>

<p>const char *
pic_eval_cstr_into_cstr(pic_state <em>pic, const char </em>input)
{
  pic_value v;</p>

<p>  v = pic_read_cstr(pic, input);
  v = pic_eval(pic, v, PICRIN_BASE);
  v = pic_funcall(pic, PICRIN_BASE, &ldquo;&ndash;>string&rdquo;, pic_list1(pic, v));
  return pic_str_cstr(pic_str_ptr(v));
}</p>

<p>int
on_picrin(h2o_configurator_command_t <em>cmd, h2o_configurator_context_t </em>ctx, const char <em>config_file, yoml_t </em>config_node)
{
  const char *sexp;</p>

<p>  switch (config_node->type) {
  case YOML_TYPE_SCALAR:</p>

<pre><code>sexp = config_node-&gt;data.scalar;
break;
</code></pre>

<p>  default:</p>

<pre><code>h2o_config_print_error(cmd, config_file, config_node, "value must be a string");
return -1;
</code></pre>

<p>  }</p>

<p>  pic_try{</p>

<pre><code>puts(pic_eval_cstr_into_cstr(pic, sexp));
</code></pre>

<p>  }
  pic_catch{</p>

<pre><code>pic_print_backtrace(pic);
return -1;
</code></pre>

<p>  }
  return 0;</p>

<p>}</p>

<p>int
init_sol_picrin(h2o_configurator_command_t <em>cmd, h2o_configurator_context_t </em>ctx, const char <em>config_file, yoml_t </em>config_node)
{</p>

<p>  h2o_configurator_t *c = cmd->configurator;</p>

<p>  pic = pic_open(0, NULL, NULL);</p>

<p>  pic_init_picrin(pic);</p>

<p>  PICRIN_BASE = pic_find_library(pic, pic_read_cstr(pic, &ldquo;(picrin base)&rdquo;));</p>

<p>  h2o_config_define_command(</p>

<pre><code>  c, "picrin", H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
  on_picrin,
  "run picrin");
</code></pre>

<p>  return 0;</p>

<p>}
```</p>

<p>んでコンフィグは</p>

<p>```</p>

<h1>to find out the configuration commands, run: h2o &mdash;help</h1>

<p>use: picrin
listen:
  port:
listen:
  port: 8081
  ssl:</p>

<pre><code>certificate-file: examples/h2o/server.crt
key-file: examples/h2o/server.key
</code></pre>

<p>picrin: &ldquo;(string-append \"Hello, \&rdquo; \&ldquo;World\&rdquo;)&ldquo;
hosts:
  default:</p>

<pre><code>paths:
  /:
    file.dir: examples/doc_root
access-log: /dev/stdout
</code></pre>

<p>```</p>

<p>そして魔法のコマンドを叩いて</p>

<p><code>
$ cp ~/compile/picrin/src/{init_contrib.c,load_piclib.c} ./
$ gcc -c sol_picrin.c -std=c99   -o sol_picrin.o -I ~/compile/picrin/extlib/benz/include -I ~/compile/h2o/include -I ~/compile/h2o/deps/picohttpparser -I ~/compile/h2o/deps/yoml -DH2O_USE_LIBUV=0 -fPIC
$ gcc sol_picrin.o load_piclib.o init_contrib.o -L ~/compile/picrin/build/lib/ -l picrin -fPIC -shared -o sol_picrin.so
$ cp sol_picrin.so ~/compile/h2o
</code></p>

<p>実行すると</p>

<p><code>
$ cd ~/compile/h2o
$ ./h2o --conf example/h2o/h2o.conf
Hello, Wold
</code></p>

<p>ヤッタ！</p>

<h1>標準出力かよ</h1>

<p>ううっ。ごめんなさい。</p>

<h1>で、HTTPレスポンス版は？</h1>

<p>ごめんなさい、まだです。</p>

<p><code>file.c</code>をベースにして</p>

<p>```yaml</p>

<pre><code>paths:
  /:
    picrin.exp: "(string-append \"Hello, \" \"World\")"
</code></pre>

<p>```</p>

<p>とかしたかったんですけど間に合いませんでした。</p>

<p>ソリューションなりモジュールなりのシステムが出来たらまたトライします</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#関数型なんたら で喋ってきた]]></title>
    <link href="http://KeenS.github.io/blog/2014/10/26/number-guan-shu-xing-nantara-nican-jia-sitekita/"/>
    <updated>2014-10-26T17:14:10+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/10/26/number-guan-shu-xing-nantara-nican-jia-sitekita</id>
    <content type="html"><![CDATA[<p>κeenです。昨日<a href="http://connpass.com/event/8634/">函数型なんたらの集い</a>に参加してきたので報告/感想です。</p>

<!-- more -->


<p>会場提供はドワンゴということでトークはニコ生に流された模様。ちらっと覗いてみたらLinuxでも見れましたね。いつのまにかFlashのバグ直ってたんですね。
とはいえ私自身のトーク中のコメントが見れなかったのであまり意味はないのですが…</p>

<p>プレミアム会員は放送後7日は生放送の内容を見れるそうですね。見れる方々は<a href="http://live.nicovideo.jp/gate/lv196879029">コチラ</a>からどうぞ。次回からはタイムシフト予約しておこう。</p>

<h1>話した内容</h1>

<p><a href="http://keens.github.io/slide/c6h6-plus-hno3.html">C6H6+HNO3</a>というタイトルで、picrinのbenzとnitrosについて。本当はnitrosの依存関係解決器sulfuricを完成させてそれについて話し、nitroを書こう!って言う予定だったんですが着手が遅れて完成しないまま発表になりました。</p>

<p>普段関数型言語のヒトは型やらモナドで殴ってる印象があったのでマクロで殴ろうと思ったのですがマクロの話のところで焦ってしまって話が飛んでしまい、殴れずに終わりました。</p>

<p>ガチの組み込み屋さんから組み込み機器で動作検証したのかとの質問がありましたがそもそも持ってないです。そろそろ1.0が出ると思うのでそのあたりでやります。</p>

<p><strong>GCがconservativeかとの質問に対して「はい」と答えてしまいましたが間違いでした。</strong> conservativeなのはcall/ccでした。GCはexactですね。<a href="http://picrin.readthedocs.org/en/latest/intro.html">ドキュメント</a>に載ってます。</p>

<p>wasabizの名前に反応した人が多かったようですね。やっぱ有名人なのかぁ。</p>

<h1>興味深かった話</h1>

<h2><a href="http://www.slideshare.net/RuiccRail/engineerusesmonads?ref=http://connpass.com/event/8634/presentation/">エンジニアとモナド</a></h2>

<p>またモナドで殴る話かと思ったら全然違いました。トップダウンで設計するときにそれぞれを小さなDSLに分割してそれらをモナドで実装し、モナド変換子で組み合わせると良いよねとのこと。タスクアサインもモナド単位になるし分かり易い。スピードのために実際には単相化すると良いとか現実的な話をしてて非常に良かったです。</p>

<p>Lispで考えるとこうはいかないなと思います。トップダウンで設計するのが他の言語以上に向いてない気がします。というか、ボトムアップに向きすぎてる。小っさく始めて抽象が欲しければマクロを書いて…って。オブジェクト指向で作るにしてもオブジェクトとメソッドが分離してるのでボトムアップと相性が良い。この辺はポールグレアムの「ハッカーと画家」に詳しいです。</p>

<h2><a href="http://xuwei-k.github.io/slides/functional-something-shapeless/#0">shapelessの紹介</a></h2>

<p>興味を持ったのはshaplessそのものではなくてヘテロなリストやヘテロなハッシュに型をつける話。<code>{ 1 =&gt; "foo", "bar" =&gt; 2}</code>に型がつくのは面白すぎます。「高度に多相化された静的型は動的型と区別がつかなくなる」っぽかったです。</p>

<h2>パターンマッチいろいろ</h2>

<p>議論を呼んだ発表。パターンマッチを拡張する話。例えば年月日に対して<code>YMD(y, 12 25)</code>でクリスマスならそのときの年を取り出せるだとかさらにアンドを使えばHMSも一緒にマッチ出来るだとか。
そこからEgisonに話が飛んでEgisonの例のようにポーカーの役をScalaでパターンマッチする例の紹介。</p>

<p>議論を呼んだというのはパターンマッチにガードが吸収されてる件ですね。データ型のコンストラクタとエクストラクタが一対一対応してこそパターンマッチは真価を発揮する派vsパターンマッチの表現力が高ければ高い方が良い派の対立ですね。さらに前者は型の表現力が足りてないのなら型をもっと複雑にすべき派とガードを付けて網羅性の証明をすれば良い派に分かれます。私はパターンマッチには表現力があればあるほど良いよね派。</p>

<p>これはそもそもパターンに対する立場の違いがある気がするんですよね。私はパターンマッチは同じデータに対する条件判定のシンタックスシュガーとして捉えています。マッチと束縛を一緒に行なうのは便利なのとパフォーマンスのため。ガードが必要なのはパターンの表現力が足りないため。だからパターンがリッチならリッチな方が良い。そもそもLispでは網羅性のチェックは期待出来ませんので。そもそもの話動的言語はコンパイル時の検査をあきらめてその代わり表現力を得ようという思想ですからね。</p>

<p>パターンが複雑になるとメモリが爆発するとの指摘がありましたがそれに直面した人がいるらしく、パターンによる分岐の枝を実行時に伸ばしていくようなパターンマッチライブラリも存在します。（Lispは実行時にもマクロが動いていて、実行時にコードを生成することも可能なのです。）</p>

<h1>懇親会その他</h1>

<p>名古屋の<s>型々</s>方々と色々喋れました。偶々でこれきさん、みずぴーさんと同じテーブルに座り、昼御飯も一緒に。普段休日出勤してる印象が強く、名古屋に行かないと会えないと思っていたブレイスさんといよさんも一緒でした。でこれき先生はやっぱり大先生だった。</p>

<p>よんたさんにSML#のコードリーディング会開いて下さいって言ったら良いよって言ってもらいました。そろそろ64bit版も出るそうなのでリリース記念コードリーディング会&amp;芋煮会やろうって話になりました。</p>

<p>OCamlのユニコードライブラリを作ってる方とも話しました。内部でropeで持ってるらしく、その話を聞きました。ropeのユニコード化はどうやら普通に文字列をUTF-8で保持し、ropeに文字列長のフィールドを保たせるだけで良いよう。ただ、picrinはCとの連携のためちょくちょくCの文字列に変換してまた新たにropeを作って、とするので若干勝手というかボトルネックが違いそう。</p>

<p>Schemeのネイティブコンパイラを作ってる方とも話しました。Schemeの実装について喋ったり、GCについて喋ったり。GCについては興味深いことを聴いたのでもう1本エントリー書きます。あとはプロセス代数とかモデル検査とか。</p>

<h1>まとめ</h1>

<p>楽しかった。どうしてもLispは関数型とはあまり言われない（し、私も関数型言語とは思ってない）のでLisperが少なかったのですが私自身はMLも好きなので楽しめました。GCとTaPLとHaskellとScalaとEgisonに対するモチベーションが上がりました。</p>

<p>最後に開催して下さった主催の方々、会場を提供して下さったドワンゴ様、ありがとう御座いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C6H6+HNO3]]></title>
    <link href="http://KeenS.github.io/slide/c6h6-plus-hno3.html"/>
    <updated>2014-10-24T21:47:00+09:00</updated>
    <id>http://KeenS.github.io/slide/c6h6-plus-hno3.markdown</id>
    <content type="html"><![CDATA[<h1>$\mathbf{C_6H_6+HNO_3}$</h1>

<hr />

<p>関数型なんたらの集い &lt;2014-10-25><br/>
κeen(@blackenedgold)</p>

<h1>picrinについて</h1>

<hr />

<p><img src="/images/picrin/picrin-structure.png" alt="ピクリン酸の構造式" /><br/>
化学式 $\mathbf{C_6H_3N_3O_7}$、示性式 $\mathbf{C_6H_2(OH)(NO_2)_3}$ で表される芳香族のニトロ化合物。<br/>
一般にはフェノールのニトロ化によって得られる。</p>

<p>Note:
ニトロ化に硫酸を使うことを触れる。</p>

<p><img src="/images/picrin/picrin-logo-fin01-02.png" alt="picrinのロゴ" /></p>

<h1>About Me</h1>

<hr />

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, ML, Shell Scriptあたりを書きます</li>
<li><a href="https://github.com/picrin-scheme/picrin">picrin</a>のコミッタです</li>
</ul>


<h1>picrinについて</h1>

<hr />

<ul>
<li>github: picrin-scheme/picrin</li>
<li>R7RS-small scheme 処理系</li>
<li>速い、軽い、高機能を目指す</li>
<li>組み込み向けを意識</li>
<li>1年くらい開発</li>
<li>κeenがコミットし始めてから半年弱</li>
</ul>


<h1>picrinの プロジェクト構成</h1>

<hr />

<p>コア(benz)はC、ビルドツールはCMake。</p>

<p><code>
├── contrib (nitros)
   .......
├── docs
├── etc
├── extlib
│   └── benz
├── piclib
   ....
└── src
</code></p>

<p>Note:
contribとextlib/benzを強調。
srcはほぼ空であることにも触れる。</p>

<h1>nitrosの紹介</h1>

<hr />

<ul>
<li>schemeやCで書かれている</li>
<li>picrinのコンパイル時に一緒にlibpicrinに入る</li>
<li>picrinと共にCMakeで管理されている</li>
</ul>


<p>Note:
schemeファイルもlibpicrinにCの文字列として入ってることに触れる。
バイトコンパイルプロジェクトにも触れる。
nitrosも一緒にコンパイルされることを強調する。</p>

<h1>nitroの紹介</h1>

<hr />

<h2><a href="https://github.com/picrin-scheme/picrin/tree/master/contrib/05.r7rs/scheme">R7RS</a></h2>

<ul>
<li>picrinではr7rsもただのライブラリ</li>
<li>組み込みのときに必要なければ外せばよい</li>
</ul>


<p>Note:
リンクを辿る必要はない。
スライドは下に続く。</p>

<h1>nitroの紹介</h1>

<hr />

<h2><a href="https://github.com/picrin-scheme/picrin/blob/master/contrib/10.partcont/piclib/partcont.scm">partcont</a></h2>

<ul>
<li>ただの限定継続ライブラリ</li>
<li>ねこはるさんが詳しく話すと思うのでそちらに譲ります</li>
</ul>


<p>Note:
リンクを辿ってソースを見せる。</p>

<h1>nitroの紹介</h1>

<hr />

<h2><a href="https://github.com/picrin-scheme/picrin/blob/master/contrib/20.for/piclib/for.scm">for</a></h2>

<ul>
<li>非決定性計算ライブラリ</li>
<li>またの名をListモナド</li>
</ul>


<p>Note:
リンクを辿ってソースを見せる。</p>

<h1>nitroの紹介</h1>

<hr />

<h2><a href="https://github.com/picrin-scheme/picrin/blob/master/contrib/10.regexp/src/regexp.c">regexp</a></h2>

<ul>
<li>Unixのregexライブラリのバインディング</li>
<li>Cで書かれている</li>
</ul>


<p>Note:
リンクを辿ってソースを見せる。
詳細に説明する。</p>

<ul>
<li><code>regexp_t</code>型</li>
<li>dtor</li>
<li>GCに乗ることは強調</li>
</ul>


<h1>nitroの依存関係の話</h1>

<hr />

<ul>
<li>nitro同士に依存関係がある</li>
<li>forはpartcontに依存する</li>
<li>REPLはeditlineに依存する</li>
<li>etc&hellip;</li>
</ul>


<h1>picrinの依存関係解決法</h1>

<hr />

<p><a href="https://github.com/picrin-scheme/picrin/tree/master/contrib">picrin/contrib</a></p>

<p>Note:</p>

<ul>
<li>リンクを辿る</li>
<li>ディレクトリ名が数字で始まることを説明</li>
<li>03まできてそろそろ限界であることを説明</li>
</ul>


<p>どう見ても<span style="font-size:150%">手動(ディレクトリ名)ソート</span>ですね。<br/>
本当にありがとうございました。</p>

<ul>
<li>さすがにどうにかしたい</li>
<li>依存関係解決ツールが欲しい</li>
<li>なんかmrubyのmrbgemとかみたいにしたら楽しいんじゃね？</li>
<li>個々のnitroを別プロジェクトにも出来る!</li>
</ul>


<h1>sulfuricプロジェクト</h1>

<h1>sulfuricプロジェクト</h1>

<hr />

<ul>
<li>sulfuric acid = 硫酸</li>
<li>nitro定義、依存解決、ビルドコンフィグ etc&hellip;</li>
<li>最終的にはCMakeと連携</li>
<li>定義ファイルはschemeで書きたい</li>
</ul>


<p>Note:
個人案なことに触れる。
chikenのeggsやRacketのPlanetにも触れる。</p>

<h1>sulfuricプロジェクト</h1>

<hr />

<ul>
<li>あれ？R7RSってnitroじゃね？</li>
<li>そもそもschemeをビルドするためにschemeを書く…？</li>
<li>てかCMakeとの連携どうするよ</li>
</ul>


<p>Note:
進捗はまだinitial commitすら出来てない。
書いてる内に大きくなっていったことも説明。
最初は他のschemeでビルドする案やフェノールでビルドする案も話す。
solutionディレクトリに入れたいよねーも話す。
フェノールの合成にベンゼンスルホン酸が使われる</p>

<h1>picrinにコミットしよう</h1>

<hr />

<ul>
<li>picrinはまだ若い

<ul>
<li>ちょろっと覗くだけでコミット出来るところが見付かる</li>
</ul>
</li>
<li>開発者全員日本人</li>
</ul>


<h1>コミットはとっても簡単</h1>

<hr />

<ol>
<li><a href="https://github.com/picrin-scheme/picrin/issues">issue</a>を覗く</li>
<li>簡単そうなのをサクっと実装</li>
<li>PR</li>
</ol>


<p>Note:
イシューの中から</p>

<ul>
<li>#224 feature request: data structures</li>
<li>#210 Add MQTT support</li>
</ul>


<p>を見せる</p>

<h1>Q. なぜpicrin?</h1>

<hr />

<h1>A. picrinの独自拡張</h1>

<hr />

<ul>
<li><a href="http://picrin.readthedocs.org/en/latest/">ドキュメント</a>に色々書いてある</li>
<li>C拡張の書き方も書いてある</li>
</ul>


<p>Note:
arrayとdictionaryに触れる。
マクロに触れる
C APIの項目があることにも触れる。</p>

<h1>picrinのマクロ</h1>

<hr />

<ul>
<li><code>syntax-rules</code> (R7RS)</li>
<li><code>sc-macro-transformer</code></li>
<li><code>rsc-macro-transformer</code></li>
<li><code>ir-macro-transformer</code></li>
<li><code>er-macro-transformer</code></li>
<li><code>define-macro</code> (Common Lisp)</li>
</ul>


<p>参考: <a href="http://d.hatena.ne.jp/leque/20080528/p1">様々な Hygienic Macro &ndash; 月の塵</a></p>

<h1>picrinにコミットしよう</h1>

<hr />

<ul>
<li>issueに上がってなくても大歓迎</li>
<li>Schemeの練習に</li>
<li>「便利なライブラリ書いたけどどこ置いたら良いの」</li>
</ul>


<h1>picrinにコミットしよう</h1>

<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lisp Meet Up #20でLTしてきました]]></title>
    <link href="http://KeenS.github.io/blog/2014/09/30/lisp-meet-up-number-20/"/>
    <updated>2014-09-30T09:35:05+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/09/30/lisp-meet-up-number-20</id>
    <content type="html"><![CDATA[<p>κeenです。lisp meet up # 20に参加したのでレポートです。</p>

<!-- more -->


<p>20人の募集に19人参加予定。会場は今回初めてのところでした。</p>

<h1>LT</h1>

<p>LTはTOYOZUMIさんが仕事で来れなくなったので私の1件のみ。内容はpicrinのチューニングの話と思わせてほとんどがその前振りのGCの話。</p>

<p>スライドはこちら。</p>

<p><a href="http://keens.github.io/slide/picrin-gc.html">Picrinのチューニングの話、もといGCの話 | κeenのHappy Hacκing Blog</a></p>

<p>TOYOZUMIさんのdocstringの話聞きたかった</p>

<h2>飛び入り</h2>

<ul>
<li>ブラウザ上でbiwa schemeの環境(REPLだけでなくオートインデントとか)を作ってる</li>
<li>関連して、websocketでswankと対話できるやつ作ってる</li>
<li>関連して、ブラウザ上で動くLispに似てそうなBlockyというヴィジュアル言語がある
なんかの話がありました。</li>
</ul>


<h1>余った時間</h1>

<p>chikuさんが前でGCの話してました。んで話が尽きたあたりで私がpicrinの宣伝しました。<code>(picrin control list)</code>の話です。非同期プロミス然りpicrinにはトリッキーな機能が多いですね。</p>

<p>結局ライブコーディングはしませんでしたね。</p>

<h1>懇親会</h1>

<p>Raspberry Piの話とかちょいとGCの話とかVarnishの話とかaltJSとか。ブログの話題が出たのでOctopress推しといたり。なんでみんなGithub Pages + Octopress使わないん？便利ですやん。</p>

<p>結構色々話してた気がするんですが覚えてないですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Picrinのチューニングの話、もといGCの話]]></title>
    <link href="http://KeenS.github.io/slide/picrin-gc.html"/>
    <updated>2014-09-29T14:37:00+09:00</updated>
    <id>http://KeenS.github.io/slide/picrin-gc.markdown</id>
    <content type="html"><![CDATA[<h1>Picrinのチューニングの話、もといGCの話</h1>

<hr />

<p>Lisp Meet Up presented by Shibuya.lisp #20<br/>
2014-09-29<br/>
κeen(@blackenedgold)</p>

<h1>自己紹介</h1>

<hr />

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
<li><a href="https://github.com/picrin-scheme/picrin">picrin</a>のコミッタです</li>
</ul>


<h1>picrin</h1>

<hr />

<p><img src="/images/picrin/picrin-logo-fin01-02.png" alt="picrin" /></p>

<h1>picrin</h1>

<hr />

<ul>
<li>R7RS compatibility</li>
<li>bytecode interpreter (based on stack VM)</li>
<li>internal representation by nan-boxing</li>
<li>conservative call/cc implementation (users can freely interleave native stack with VM stack)</li>
<li>exact GC (simple mark and sweep, partially reference count is used as well)</li>
<li>string representation by rope data structure</li>
</ul>


<h1>picrin</h1>

<hr />

<ul>
<li>R7RS compatibility</li>
<li><strong>bytecode interpreter (based on stack VM)</strong></li>
<li>internal representation by nan-boxing</li>
<li>conservative call/cc implementation (users can freely interleave native stack with VM stack)</li>
<li><strong>exact GC (simple mark and sweep, partially reference count is used as well)</strong></li>
<li><strong>string representation by rope data structure</strong></li>
</ul>


<h1>picrin開発者の不満</h1>

<hr />

<ul>
<li>picrinの起動が遅い<!-- .element: class="fragment" data-fragment-index="1" -->

<ul>
<li>2秒くらいかかる <!-- .element: class="fragment" data-fragment-index="1" --></li>
</ul>
</li>
<li>picrinのテストが遅い<!-- .element: class="fragment" data-fragment-index="2" -->

<ul>
<li>16秒くらいかかる <!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>
</li>
</ul>


<h1>少しGCの話</h1>

<hr />

<p>GC(ごみ集め)とは</p>

<ul>
<li>使われていないオブジェクトを自動的に解法する

<ul>
<li>メモリ管理に煩わせられないで済む</li>
<li>メモリーリークを防ぐ。</li>
</ul>
</li>
<li>「使われていないオブジェクト」を判定するのはいくつかアルゴリズムがある</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>主なGCのアルゴリズム</h2>

<ul>
<li>マーク&amp;スイープ</li>
<li>参照カウント</li>
<li>Copying GC</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>マーク&amp;スイープ</h2>

<ol>
<li>あらかじめ全てのオブジェクトはどこかで一元管理する<!-- .element: class="fragment" data-fragment-index="1" --></li>
<li>一元管理元(ヒープ(ページ))でメモリが足りなくなったらGCを開始<!-- .element: class="fragment" data-fragment-index="2" --></li>
<li>スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする<!-- .element: class="fragment" data-fragment-index="3" --></li>
<li>そこから辿れるオブジェクトも再帰的にマークする<!-- .element: class="fragment" data-fragment-index="4" --></li>
<li>ヒープからマークされていないオブジェクトを開放する<!-- .element: class="fragment" data-fragment-index="5" --></li>
<li>それでもメモリが足りなければ一ヒープのページを増やす<!-- .element: class="fragment" data-fragment-index="6" --></li>
<li>増やせなければメモリを使い果したのでabort<!-- .element: class="fragment" data-fragment-index="7" --></li>
</ol>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>マーク&amp;スイープの特徴</h2>

<ul>
<li>そこそこ速い</li>
<li>正確に集められる</li>
<li>GC以外ではメモリ管理を考えなくて良い(≒プラグインは書き易い)</li>
<li>長生きのオブジェクトは何度もマークされる(=>世代別GC)</li>
<li>負荷は1点に集中する</li>
<li>メモリの断片化が起きる(=オブジェクトのアロケートが遅くなる)</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>参照カウント</h2>

<ol>
<li>オブジェクトに他から参照されている数(参照カウント)を記憶させる<!-- .element: class="fragment" data-fragment-index="1" --></li>
<li>オブジェクトの参照を変えるときはその都度参照カウントを変える<!-- .element: class="fragment" data-fragment-index="2" --></li>
<li>参照カウントが0になったら開放する<!-- .element: class="fragment" data-fragment-index="3" --></li>
</ol>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>参照カウントの特徴</h2>

<ul>
<li>負荷は分散する</li>
<li>GCの実装は楽</li>
<li>少し遅い(必ずfreeする必要がある)</li>
<li>正確でない(循環参照に弱い)(cf. 大相撲の星の回しあい)</li>
<li>プラグインは面倒</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>Copying GC</h2>

<ol>
<li>オブジェクトプールを2つ用意する(1, 2)とする<!-- .element: class="fragment" data-fragment-index="1" --></li>
<li>オブジェクトを確保するときは必ず1に確保する<!-- .element: class="fragment" data-fragment-index="2" --></li>
<li>1のメモリが足りなくなったらgcを開始<!-- .element: class="fragment" data-fragment-index="3" --></li>
<li>1の生きているオブジェクトを再帰的に2に移動する<!-- .element: class="fragment" data-fragment-index="4" --></li>
<li>1に残っているものは全てゴミとして良い<!-- .element: class="fragment" data-fragment-index="5" --></li>
<li>1、2のラベルを付け換える<!-- .element: class="fragment" data-fragment-index="6" --></li>
</ol>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>Copying GCの特徴</h2>

<ul>
<li>正確</li>
<li>メモリの断片化が起きない(Windowsのデフラグ)(=アロケートが速くなる)</li>
<li>負荷は1点に集中する</li>
<li>遅い(オブジェクトの移動が必要)</li>
<li>メモリ食う(オブジェクトプール2つ分)</li>
<li>ポインタも変わるため、ハッシュの再計算などが必要</li>
</ul>


<h1>GCのアルゴリズム</h1>

<hr />

<h2>GCの主な属性</h2>

<ul>
<li>世代別

<ul>
<li>新しいオブジェクトだけGCの対象にする<!-- .element: class="fragment" data-fragment-index="1" --></li>
</ul>
</li>
<li>正確

<ul>
<li>ゴミは必ず回収する<!-- .element: class="fragment" data-fragment-index="2" --></li>
</ul>
</li>
<li>インクリメンタル

<ul>
<li>一度にやらずに少しづつGCを進める<!-- .element: class="fragment" data-fragment-index="3" --></li>
</ul>
</li>
</ul>


<h1>picrinのGC</h1>

<hr />

<p><img src="/images/picrin/picrin-logo-fin01-02.png" alt="picrin" /></p>

<h1>picrinのGC</h1>

<hr />

<ul>
<li>基本は普通の正確なマーク&amp;スイープ

<ul>
<li>Copying GCはlightweightでない</li>
</ul>
</li>
<li>ropeには参照カウント

<ul>
<li>ropeには循環参照が起きない</li>
</ul>
</li>
</ul>


<h1>picrinのGC</h1>

<hr />

<ul>
<li>基本はマーク&amp;スイープ</li>
</ul>


<blockquote><ol>
<li>スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする</li>
</ol>
</blockquote>

<ul>
<li>schemeの変数はそのまま</li>
<li>Cの変数は読めないのでアリーナという場所を用意してC内ではそこに一時保管してもらう

<ul>
<li>スコープはFILOなのでスタックを用いればヒープより速くアロケート出来る</li>
</ul>
</li>
</ul>


<h1>picrinのチューニング</h1>

<h2>プロファイルをとってみる</h2>

<hr />

<p><code>
 % cumulative self self total
time seconds seconds calls s/call s/call name
37.14 0.78 0.78 13136494 0.00 0.00 XROPE_DECREF
23.81 1.28 0.50 1544 0.00 0.00 gc_sweep_phase
15.72 1.61 0.33 59344814 0.00 0.00 gc_mark_object
10.00 1.82 0.21 1544 0.00 0.00 gc_mark_phase
6.67 1.96 0.14 1544 0.00 0.00 gc_mark_trie
2.38 2.01 0.05 6523 0.00 0.00 pic_apply
</code></p>

<p><span style="font-size:200%">ほとんどGCですね。<br/>
本当にありがとう御座いました。</span></p>

<h1>解決案</h1>

<hr />

<ul>
<li>GCのアルゴリズムを変える</li>
<li>オブジェクトをアロケートしないようにする</li>
<li>パラメーターをいじる</li>
</ul>


<h1>解決案</h1>

<hr />

<ul>
<li>GCのアルゴリズムを変える</li>
<li>オブジェクトをアロケートしないようにする</li>
<li><strong>パラメーターをいじる</strong></li>
</ul>


<h1>GCに関連するパラメータ</h1>

<hr />

<p>元々tinyに設計されている
```C
/<em> アリーナのサイズ </em>/</p>

<h1>define PIC_ARENA_SIZE 1000</h1>

<p>/<em> ヒープページのサイズ </em>/</p>

<h1>define PIC_HEAP_PAGE_SIZE 10000</h1>

<p>/<em> シンボルプール(ハッシュ)のサイズ </em>/</p>

<h1>define PIC_SYM_POOL_SIZE 128</h1>

<p>```</p>

<h1>GCに関連するパラメータ</h1>

<hr />

<p>チューニング後
```C
/<em> アリーナのサイズ </em>/</p>

<h1>define PIC_ARENA_SIZE 8 * 1024</h1>

<p>/<em> ヒープページのサイズ </em>/</p>

<h1>define PIC_HEAP_PAGE_SIZE 2 * 1024 * 1024</h1>

<p>/<em> シンボルプール(ハッシュ)のサイズ </em>/</p>

<h1>define PIC_SYM_POOL_SIZE 2048</h1>

<p>```</p>

<h1>結果</h1>

<hr />

<ul>
<li><p>昔</p>

<blockquote><p>テストに16秒</p></blockquote></li>
<li><p>変更後</p>

<blockquote><p>time make test-r7rs<br/>
make test-r7rs  <strong>1.68s</strong> user 0.23s system 98% cpu 1.931 total
<!-- .element: class="fragment" data-fragment-index="1" --></p></blockquote></li>
</ul>


<h1>今後</h1>

<hr />

<ul>
<li>GCのアルゴリズムを変える</li>
<li>世代別GCにしたいよねー</li>
<li>そもそもマーク&amp;スイープの実装が適当すぎるだとか。協議中。</li>
<li>組み込み目指すならインクリメンタル性必要では？</li>
<li>オブジェクトをアロケートしないようにする

<ul>
<li>バイトコンパイルするときにもめちゃくちゃアロケートしてる。その辺どうにかする。</li>
<li><a href="https://github.com/picrin-scheme/picrin/pull/207">Fast Reader</a></li>
</ul>
</li>
</ul>


<h1>まとめ</h1>

<hr />

<ul>
<li>基本的なGCの解説をした</li>
<li>picrinのGCの戦略を話した</li>
<li>GCチューニング大事</li>
</ul>


<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
</feed>
