<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/categories/rust/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/rust/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rustのクロージャ3種を作って理解する</title>
      <link>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</link>
      <pubDate>Mon, 10 Oct 2016 16:48:43 +0900</pubDate>
      
      <guid>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</guid>
      <description>&lt;p&gt;κeenです。Rustのクロージャ、3種類もあって複雑ですよね。
こういう複雑なものはRustの気持になって考えれば理解出来たりします。ということで手でクロージャを作って理解してみましょう。&lt;/p&gt;

&lt;p&gt;尚、これはRustの1.12.0-stableと1.14.0-nightly (6e8f92f11 2016-10-07)で実験しています。
&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;関数 - 関数&lt;/li&gt;
&lt;li&gt;無名関数 - 名前のついていない関数&lt;/li&gt;
&lt;li&gt;自由変数 - そのスコープの中で束縛されていない変数&lt;/li&gt;
&lt;li&gt;クロージャ - 関数に、自由変数の値(環境)もくっつけてそれだけで閉じるようにしたもの&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;クロージャについては関数が閉じ込める環境だけを指してクロージャとする人もいますが、ここでは関数本体と環境を合わせてクロージャとします。&lt;/p&gt;

&lt;p&gt;よく、無名関数とクロージャ(関数閉包)を一緒くたにすることがありますが明確に区別しましょう。まあ、大抵の無名関数はクロージャになりますが、動的スコープの言語みたいにそうならないケースもあります。&lt;/p&gt;

&lt;p&gt;余談ですが「ラムダ式」は言語がよく無名関数に付ける名前です。「関数」も言語によって「手続き」だったり「メソッド」だったりしますね。&lt;/p&gt;

&lt;h1 id=&#34;fnonce-fnmut-fn&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、「作って理解する」なので例を出します。なんかよく分からないけど0から9の値に1を足して印字するプログラムです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = |arg|{ i + arg };
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無名関数を作って &lt;code&gt;cls&lt;/code&gt; という変数に束縛しています。 &lt;code&gt;cls&lt;/code&gt; は自由変数 &lt;code&gt;i&lt;/code&gt; を含みますので、 &lt;code&gt;cls&lt;/code&gt; のクロージャを取ると 「&lt;code&gt;cls&lt;/code&gt; の定義 + &lt;code&gt;i&lt;/code&gt; の定義」になります。&lt;/p&gt;

&lt;p&gt;では &lt;code&gt;i&lt;/code&gt; という変数を保持したオブジェクトを作りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Closure {
    i: isize,
}


fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // もちろん、Closureは関数でないので呼び出せない
        // println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このままだと &lt;code&gt;cls&lt;/code&gt; は呼び出せません。しかし &lt;code&gt;+&lt;/code&gt; なんかのオーバーロードを許しているRustはなんと関数呼び出し構文 &lt;code&gt;name(arg, ...)&lt;/code&gt; もオーバーロード出来ます。実装すべきトレイトは &lt;code&gt;std::ops::{FnOnce, FnMut, Fn}&lt;/code&gt; です。これがクロージャ3種です。&lt;/p&gt;

&lt;p&gt;これらは継承関係にあって、上から順に &lt;code&gt;FnOnce&lt;/code&gt;  &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait FnOnce&amp;lt;Args&amp;gt; {
    type Output;
    extern &amp;quot;rust-call&amp;quot; fn call_once(self, args: Args) -&amp;gt; Self::Output;
}

pub trait FnMut&amp;lt;Args&amp;gt;: FnOnce&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, args: Args) -&amp;gt; Self::Output;
}

pub trait Fn&amp;lt;Args&amp;gt;: FnMut&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, args: Args) -&amp;gt; Self::Output;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらの違いは &lt;code&gt;self&lt;/code&gt; をムーブして受け取るか &lt;code&gt;&amp;amp;mut&lt;/code&gt; で受けるか &lt;code&gt;&amp;amp;&lt;/code&gt; で受けるかです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;とりあえず先程の &lt;code&gt;Closure&lt;/code&gt; にこれを実装してみましょう。ちょいとunstableな機能なようなので &lt;code&gt;feature&lt;/code&gt; を使って、nightlyでコンパイルするようにしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

// 再掲
struct Closure {
    i: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
    type Output = isize;

    extern &amp;quot;rust-call&amp;quot; fn call_once(self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.i + arg
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで呼び出しが出来る筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = Closure {i: i};
        // 呼出せるようになる
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;勿論、これは以下のように明示的にメソッドを呼んでも同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // メソッドで呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls.call_once((x, )));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fnmut-fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;FnOnce&lt;/code&gt; で出来るんならなんで &lt;code&gt;FnMut&lt;/code&gt; と &lt;code&gt;FnMut&lt;/code&gt; が存在するかというと、クロージャが閉じ込めた環境の所有権の問題ですね。&lt;/p&gt;

&lt;p&gt;例えば以下のコードを手で実装してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = |arg| { x + arg};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程と同じ &lt;code&gt;Closure&lt;/code&gt; ではコンパイル出来ません（統一感のために &lt;code&gt;Closure&lt;/code&gt; のメンバ名を変えました）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

struct Closure {
    x: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
  // ...略
}


fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = Closure {x: x};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error[E0382]: use of moved value: `cls`
  --&amp;gt; closure.rs:45:28
   |
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ value moved here in previous iteration of loop
   |
   = note: move occurs because `cls` has type `Closure`, which does not implement the `Copy` trait

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1回目のループでは問題ないのですが &lt;code&gt;call_once(self, (arg, ): (isize,))&lt;/code&gt; の呼び出しでムーブしてしまうので2回目以降は呼べません。ということで1つ下のトレイト、 &lt;code&gt;FnMut&lt;/code&gt; も実装してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl FnMut&amp;lt;(isize,)&amp;gt; for Closure {

    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はこれでも怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:45:28
   |
43 |         let cls = Closure {x: x};
   |             --- use `mut cls` here to make mutable
44 |         for i in 0..10 {
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ cannot borrow mutably

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;mut&lt;/code&gt; を要求しているから。正確にはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略


fn main() {
    let x = 1;
    // `mut` を付ける
    let mut cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。しかしまあ、何か書き換えてる訳でもないのに &lt;code&gt;mut&lt;/code&gt; が付いているのは嫌ですね。&lt;code&gt;mut&lt;/code&gt; を要求しないように定義してあげようと思ったら &lt;code&gt;Fn&lt;/code&gt; が必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl Fn&amp;lt;(isize,)&amp;gt; for Closure {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, (arg,): (isize, )) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。&lt;/p&gt;

&lt;h2 id=&#34;整理&#34;&gt;整理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;クロージャとは関数とその環境のセットだよ&lt;/li&gt;
&lt;li&gt;環境にも所有権はあるよ&lt;/li&gt;
&lt;li&gt;Rustは所有権でクロージャの呼び出しを使い分けるよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;構文&#34;&gt;構文&lt;/h1&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; に対応するRustの構文を探っていきます。&lt;/p&gt;

&lt;h2 id=&#34;fn&#34;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;先程 &lt;code&gt;Fn&lt;/code&gt; まで実装しないとコンパイルが通らなかった&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    let cls = |arg| { x + arg};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は &lt;code&gt;||{}&lt;/code&gt; でコンパイルが通っているので &lt;code&gt;||{}&lt;/code&gt; は &lt;code&gt;Fn&lt;/code&gt; を作るようです。&lt;/p&gt;

&lt;h2 id=&#34;fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;call_mut&lt;/code&gt; を要求しそうにちょっと変えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、予想通りエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:37:13
   |
35 |         let cls = |arg|{ x += arg };
   |             --- use `mut cls` here to make mutable
36 |         for i in 0..10 {
37 |             cls(i);
   |             ^^^ cannot borrow mutably

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let cls = |arg|{ x += arg };
   |                   -----  - previous borrow occurs due to use of `x` in closure
   |                   |
   |                   mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to 2 previous errors

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程の &lt;code&gt;FnMut&lt;/code&gt; の例のように &lt;code&gt;cls&lt;/code&gt; に &lt;code&gt;mut&lt;/code&gt; を付けてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let mut cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これでもエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let mut cls = |arg|{ x += arg };
   |                       -----  - previous borrow occurs due to use of `x` in closure
   |                       |
   |                       mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;cls&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; を捕捉し続けているから。これは &lt;code&gt;cls&lt;/code&gt; のライフタイムを &lt;code&gt;println!&lt;/code&gt; の前で終わらせてあげると解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    {
        // `{}` でスコープを作ることでライフタイムをコントロールする
        let mut cls = |arg|{ x += arg };
        for i in 0..10 {
            cls(i);
        }
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FnMut&lt;/code&gt; は変数を &lt;code&gt;mut&lt;/code&gt; にする無名関数と同じなようです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce-1&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; は？ &lt;code&gt;std::mem::drop&lt;/code&gt; を使って所有権を無理矢理奪うクロージャを作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::drop;

fn main() {
    let x = String::new();
    let cls = || {drop(x)};
    cls();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、実はこれでOKです。冷静に考えたら &lt;code&gt;FnOnce&lt;/code&gt; を継承している &lt;code&gt;Fn&lt;/code&gt; を &lt;code&gt;||{}&lt;/code&gt; で作れた時点で問題ありませんでしたね。&lt;/p&gt;

&lt;h1 id=&#34;落穂拾い&#34;&gt;落穂拾い&lt;/h1&gt;

&lt;h2 id=&#34;move-クロージャ&#34;&gt;&lt;code&gt;move&lt;/code&gt; クロージャ&lt;/h2&gt;

&lt;p&gt;じゃあ、Rustが良い感じに使い分けてくれるなら &lt;code&gt;move&lt;/code&gt; クロージャって何のためにあるの？と思いますが、これは環境を捕捉する際に &lt;code&gt;Copy&lt;/code&gt; なんかが起こらないようにするためのものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; しない例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; する例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt; は環境 &lt;strong&gt;へ&lt;/strong&gt; 所有権を移すかどうか、 &lt;code&gt;FnOnce&lt;/code&gt; などは環境 &lt;strong&gt;から&lt;/strong&gt; 所有権を移すかどうかです。&lt;/p&gt;

&lt;h2 id=&#34;関数ポインタ&#34;&gt;関数ポインタ&lt;/h2&gt;

&lt;p&gt;クロージャを持たない関数は、 &lt;code&gt;fn(i32) -&amp;gt; i32&lt;/code&gt; のような型を持ちます。これは空の環境を持つクロージャと同じですね。空の環境に所有権も何もないのでプリミティブの &lt;code&gt;fn&lt;/code&gt; は &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; のいずれとしても振舞います。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;p&gt;ここまで書いて普通にドキュメントに詳しく載っているのに気付きました（汗&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/functions.html&#34;&gt;関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustでシェル作った</title>
      <link>/blog/2016/09/04/rustdeshierutsukutta</link>
      <pubDate>Sun, 04 Sep 2016 16:26:20 +0900</pubDate>
      
      <guid>/blog/2016/09/04/rustdeshierutsukutta</guid>
      <description>&lt;p&gt;κeenです。
先日、先輩社員と話してるとシェルを作る話になりました。
だいたいのコンピュータサイエンスの学生なら学部生の頃に課題でシェルを作りますが数学科にいた私は作ったことありませんでした。
でも、その時「今ならシェルなんて作ろうと思えばすぐに作れますよ」なんて言っちゃったのでなんか作りました。
まあ、習作程度の雑なものです。&lt;/p&gt;

&lt;p&gt;
作ったのはこれ、&lt;a href=&#34;https://github.com/KeenS/igaguri&#34;&gt;KeenS/igaguri: my toy shell written in Rust&lt;/a&gt;。
名前は、Shellは木の実を覆う殻のようにカーネルを覆う殻とのことなのでRustのロゴに似てる毬栗を選びました。&lt;/p&gt;

&lt;h1 id=&#34;パーサ&#34;&gt;パーサ&lt;/h1&gt;

&lt;p&gt;パーサコンビネータライブラリの&lt;a href=&#34;https://github.com/Geal/nom&#34;&gt;nom&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;雰囲気こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;named!(token&amp;lt;String&amp;gt;, map!(map_res!(is_a!(&amp;quot;abcdefghijklmnopqlrstuvwxyzABCDEFGHIJKLMNOPQLRSTUVWXYZ-!$%^&amp;amp;@/1234567890&amp;quot;), str::from_utf8), |i: &amp;amp;str| i.to_string()));
named!(pipe, tag!(&amp;quot;|&amp;quot;));
named!(redirect_out&amp;lt;String&amp;gt;, chain!(tag!(&amp;quot;&amp;gt;&amp;quot;) ~ opt!(multispace) ~ filename: token, || filename));

named!(command&amp;lt;Ast&amp;gt;, chain!(
    opt!(multispace)
        ~ cmd: separated_list!(multispace, token)
        ~ outfile: opt!(chain!(multispace ~ out: redirect_out, || out))
        ~ opt!(multispace), || Ast::Command{cmd: cmd, out: outfile}));
named!(parse&amp;lt;Ast&amp;gt;, map!(separated_list!(pipe, command), Ast::Pipe));

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;入力ハンドリング&#34;&gt;入力ハンドリング&lt;/h1&gt;

&lt;p&gt;readlineのRust実装、&lt;a href=&#34;https://github.com/kkawakam/rustyline&#34;&gt;rustyline&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;それっぽいからとりあえず、で選んだものの、複数行入力（履歴）とか考えるともうちょっとリッチなものを選んだ方が良かったかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;実行&#34;&gt;実行&lt;/h1&gt;

&lt;p&gt;最初、&lt;a href=&#34;https://github.com/rust-lang/libc&#34;&gt;libcバインディング&lt;/a&gt;の &lt;code&gt;pipe&lt;/code&gt; や &lt;code&gt;fork&lt;/code&gt; 、 &lt;code&gt;execve&lt;/code&gt; なんかを考えてましたが、標準ライブラリの &lt;a href=&#34;https://doc.rust-lang.org/std/process/struct.Command.html&#34;&gt;&lt;code&gt;std::process::Command&lt;/code&gt;&lt;/a&gt;で実現出来そうだったのでそれを使いました。&lt;/p&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Command::new(cmd)
    .args(&amp;amp;terms)
    .stdin(stdin)
    .stdout(stdout)
    .stderr(stderr)
    .spawn()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パイプ-リダイレクト&#34;&gt;パイプ/リダイレクト&lt;/h2&gt;

&lt;p&gt;一応、パイプも標準ライブラリでサポートされてるのでそれを使いました。&lt;/p&gt;

&lt;p&gt;ただ、普通のCとは違って子プロセスと親プロセスの間に一旦パイプを作って、子プロセスの出力の生のfdを取り出して、次の子プロセスの入力に与えて、と案外面倒でした。 &lt;code&gt;unsafe&lt;/code&gt; も出てくれば &lt;code&gt;unreachable&lt;/code&gt; も出てくるのでもう少し書き直したい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut si = stdin;
let mut itr = commands.into_iter().peekable();
unsafe {
    while let Some(command) = itr.next() {
        if itr.peek().is_some() {
            let process =
                try!(self.run(command, si, Stdio::piped(), Stdio::inherit()));
            si = Stdio::from_raw_fd(process.stdout.unwrap().into_raw_fd());
        } else {
            return self.run(command, si, stdout, stderr);
        }
    }
}
unreachable!()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リダイレクトも似たようなもので、ファイルを作って生のfdを取り出して、とやります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let stdout = out.map(|f| {
    unsafe {
        let file = File::create(f)
        // FIXME: do not panic
            .unwrap();
        Stdio::from_raw_fd(file.into_raw_fd())
    }

}).unwrap_or(stdout);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;昨日の夜からちょろっと作り始めてさっきそれっぽく動くようになった程度なのでまだ適当にしか動きません。
パイプと標準出力のリダイレクトだけで、 &lt;code&gt;cd&lt;/code&gt; なんかのシェルコマンドもなければシェル変数もありません。
が、そろそろ飽きたのでこの辺で。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そろそろ飽きてきた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/772334565264232454&#34;&gt;2016年9月4日&lt;/a&gt;&amp;lt;/
blockquote&amp;gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;シェルコマンドとシェル変数くらいはいつか実装しようかな。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustの所有権/ミュータビリティの分割</title>
      <link>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</link>
      <pubDate>Sun, 19 Jun 2016 20:42:14 +0900</pubDate>
      
      <guid>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</guid>
      <description>&lt;p&gt;κeenです。昔所有権/ミュータビリティを分割したくなったけどぱっと方法が思いつかなくて困ったことがあるので今更ながら備忘録として残しておきます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;ミュータビリティ&#34;&gt;ミュータビリティ&lt;/h1&gt;

&lt;p&gt;例えば、HTTPパーサを作ろうとしてるとしましょう。
受け取ったバイト列のバッファをパースしてヘッダやらボディやらのサブスライスを返します。この時、返り値のサブスライスはユーザへの自由を与えるために &lt;code&gt;mut&lt;/code&gt; にしたいですよね。&lt;/p&gt;

&lt;p&gt;そう思ってこういうコードを書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io;

fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...
    Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mutability_split.rs:4:31: 4:34 error: cannot borrow `*buf` as mutable more than once at a time [E0499]
mutability_split.rs:4     Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通にやろうとすると
1つ1つミュータブルなサブスライスを作ることになり、2つ目以降でborrow checkに引っ掛かってしまいます。2つのバッファがオーバーラップしてなくても。難儀ですね。コピーするくらいしかないのでしょうか。いいえ。rustはちゃんと助けになるAPIを用意してくれています。&lt;/p&gt;

&lt;h2 id=&#34;split-at-mut-https-doc-rust-lang-org-std-primitive-slice-html-method-split-at-mut&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut&#34;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn split_at_mut(&amp;amp;mut self, mid: usize) -&amp;gt; (&amp;amp;mut [T], &amp;amp;mut [T])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スライスを2つに分割してくれます。重要なのが、ミュータビリティも分割してくれるところです。返り値の2つ共に &lt;code&gt;mut&lt;/code&gt; がついています。ということで、次のように実装出来ます。（実行してないので結果が正しいかは確認してませんが）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...

    let (h, b) = buf.split_at_mut(bstart);
    let h = {
        let (_, h) = h.split_at_mut(hstart);
        let (_, h) = h.split_at_mut(hend - hstart);
        h
    };

    let (_, b) = b.split_at_mut(bend - bstart);

    Ok((h, b))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;所有権&#34;&gt;所有権&lt;/h1&gt;

&lt;p&gt;似たような話で、構造体の所有権というか、貸与権(?)を分割したい時もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonDB {
    name: String,
    age: usize,
    address: String,
}


fn use_immutable(s: &amp;amp;str) {
    // empty
}

fn use_mutable(s: &amp;amp;mut str) {
    // empty
}



fn from_db(person: PersonDB) {
    let name = &amp;amp;person.name;
    let mut address = &amp;amp;mut person.address;
    use_immutable(name);
    use_mutable(address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イミュータブルとミュータブル両方の借用があるのでエラーになってしまいます。実際は別のフィールドなので問題は起きないのですが、コンパイラに怒られます。理不尽ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mutability_split.rs:36:28: 36:42 error: cannot borrow immutable field `person.address` as mutable
mutability_split.rs:36     let mut address = &amp;amp;mut person.address;
                                                  ^~~~~~~~~~~~~~

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そういう時は、パターンマッチによる分配束縛でクリア出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn from_db(person: PersonDB) {
    let PersonDB {name, mut address, ..} = person;
    use_immutable(&amp;amp;name);
    use_mutable(&amp;amp;mut address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Rustの所有権やミュータブルな参照など、1つしか存在出来ないとされるものが分割出来ることを示しました。
地味に悩む所なので誰かの助けになれば幸いです。&lt;/p&gt;

&lt;p&gt;蛇足を足すと、本当は所有権の分割についても書く予定でしたがエラーになる筈のコードがあっさりコンパイルを通ってしまったのでナシになりました。コンパイラも進化してますね。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>multirustが非推奨になったようなのでrustupに移行する</title>
      <link>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</link>
      <pubDate>Sun, 12 Jun 2016 15:23:06 +0900</pubDate>
      
      <guid>/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru</guid>
      <description>&lt;p&gt;κeenです。どうやらもうそろそろRustのツールチェーン管理はmultirustじゃなくてrustupを使った方が良さそうなので移行しようと思います。

きっかけはmultirustにそういうコミットがされたから。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;もうmultirustじゃなくてrustup使え、と。&lt;br&gt;&lt;br&gt;Update README.md · brson/multirust@84c3459&lt;a href=&#34;https://t.co/ySeRB50x5C&#34;&gt;https://t.co/ySeRB50x5C&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/741077158651514882&#34;&gt;2016年6月10日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;因みにrustupは&lt;a href=&#34;https://github.com/rust-lang/rustup.sh&#34;&gt;rust-lang/rustup.sh: The rustup.sh script for installing Rust from release channels&lt;/a&gt;ではなく&lt;a href=&#34;https://github.com/rust-lang-nursery/rustup.rs&#34;&gt;rust-lang-nursery/rustup.rs: The Rust toolchain installer&lt;/a&gt;の方です。インストールガイドなどはこちらから。&lt;a href=&#34;https://www.rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なんかベータ版のようですが推奨していいんですかね…。&lt;/p&gt;

&lt;p&gt;とりあえずmultirustを入れたままコマンドを叩いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer
warning: it looks like you have an existing installation of multirust
warning: rustup cannot be installed alongside multirust
warning: run `/usr/local/lib/rustlib/uninstall.sh` as root and delete `/home/kim/.multirust/version` before installing rustup
error: cannot install while multirust is installed
rustup: command failed: /tmp/tmp.9kjQj9WT5O/rustup-init

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふーむ。アンインストールしろ、と。一応指示された通りmultirust自体はアンインストールせずにversionだけを削除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/local/lib/rustlib/uninstall.sh
install: uninstalling component &#39;multirust&#39;

    multirust is uninstalled.
$ rm -rf ~/.multirust/version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう一度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;選択肢が出ました。とりあえず1を選択します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: toolchain &#39;stable&#39; is not installed
info: caused by: not a directory: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu&#39;
rustup: command failed: /tmp/tmp.nugK4VN4p8/rustup-init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;えー。ちょっと…。仕方ないのでシンボリックリンクを貼って騙してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls ~/.multirust/toolchains/
beta  nightly  stable
$ ln -s ~/.multirust/toolchains/{stable,stable-x86_64-unknown-linux-gnu}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3度目の正直なるか&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust programming 
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin 
directory, located at:

  /home/kim/.cargo/bin

This path will then be added to your PATH environment variable by modifying the 
profile file located at:

  /home/kim/.profile

You can uninstall at any time with rustup self uninstall and these changes will 
be reverted.

WARNING: This is beta software.

Current installation options:

     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
1

info: updating existing rustup installation


Rust is installed now. Great!

To get started you need Cargo&#39;s bin directory in your PATH environment variable.
Next time you log in this will be done automatically.

To configure your current shell run source $HOME/.cargo/env.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストール出来たよう。しかしセットアップは &lt;code&gt;~/.profile&lt;/code&gt; に書かれたようなので &lt;code&gt;.zshrc&lt;/code&gt; は自分で更新します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/zshrc b/zshrc
index 0178873..589c6a5 100644
--- a/zshrc
+++ b/zshrc
@@ -213,7 +213,7 @@ export PATSHOME=~/compile/ATS2-Postiats-$ATS_VERSION/
 export PATH=$PATSHOME/bin:$PATH
 export PATSHOMERELOC=~/compile/ATS2-Postiats-contrib-$ATS_VERSION
 
-export PATH=$PATH:~/.multirust/toolchains/stable/cargo/bin
+export PATH=&amp;quot;$HOME/.cargo/bin:$PATH&amp;quot;
 
 # OPAM configuration
 . /home/kim/.opam/opam-init/init.sh &amp;gt; /dev/null 2&amp;gt; /dev/null || true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup 0.1.12 (c6e430a 2016-05-12)
The Rust toolchain installer

USAGE:
    rustup [FLAGS] [SUBCOMMAND]

FLAGS:
    -v, --verbose    Enable verbose output
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    show         Show the active and installed toolchains
    update       Update Rust toolchains
    default      Set the default toolchain
    toolchain    Modify or query the installed toolchains
    target       Modify a toolchain&#39;s supported targets
    override     Modify directory toolchain overrides
    run          Run a command with an environment configured for a given toolchain
    which        Display which binary will be run for a given command
    doc          Open the documentation for the current toolchain.
    self         Modify the rustup installation
    telemetry    rustup telemetry commands
    help         Prints this message or the help of the given subcommand(s)

rustup installs The Rust Programming Language from the official
release channels, enabling you to easily switch between stable, beta,
and nightly compilers and keep them updated. It makes cross-compiling
simpler with binary builds of the standard library for common platforms.

If you are new to Rust consider running `rustup doc --book`
to learn Rust.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;multirustを使っていたら馴染めそうですね。&lt;/p&gt;

&lt;p&gt;一応どこにインストールされたのか確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which rustc
/home/kim/.cargo/bin/rustc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふむふむ。ちょいとアップデートしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.1 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.0 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   2.3 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %) 953.6 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   2.2 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.5 MiB/s ETA:   0 s                
info: rolling back changes
error: could not read component file: &#39;/home/kim/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/manifest-&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 44.8 MiB /  44.8 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 57.9 MiB /  57.9 MiB (100 %)   2.9 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.0 MiB /   7.0 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   1.3 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 46.5 MiB /  46.5 MiB (100 %) 924.8 KiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 59.0 MiB /  59.0 MiB (100 %)   2.4 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  7.3 MiB /   7.3 MiB (100 %)   1.8 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
  4.1 MiB /   4.1 MiB (100 %)   3.2 MiB/s ETA:   0 s                
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: checking for self-updates
info: rustup is up to date

                           stable update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
  stable-x86_64-unknown-linux-gnu update failed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                                 beta installed - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                              nightly installed - rustc 1.11.0-nightly (0554abac6 2016-06-10)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、なんかコケてる…。シンボリックリンクが悪さしたかな…。しかし試しに手元のプロダクトをコンパイルしてみたら通ったので使えているよう。&lt;/p&gt;

&lt;p&gt;さて、クロスコンパイルの方はどうでしょうか。以前Raspberry Pi向けにクロスコンパイルしました &lt;a href=&#34;http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/&#34;&gt;RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog&lt;/a&gt;。これは動くでしょうか。&lt;/p&gt;

&lt;p&gt;とりあえずインストール可能なターゲットを確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………。無理矢理addしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target add nightly-arm-unknown-linux-gnueabihf
error: toolchain &#39;stable-x86_64-unknown-linux-gnu&#39; does not support components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…………………………………。&lt;/p&gt;

&lt;p&gt;なんか変ですね。&lt;/p&gt;

&lt;p&gt;一旦&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm ~/.multirust/toolchains/stable-x86_64-unknown-linux-gnu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;してもう一度 &lt;code&gt;rustup update&lt;/code&gt; します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup update
info: syncing channel updates for &#39;stable-x86_64-unknown-linux-gnu&#39;
info: downloading component &#39;rustc&#39;
 43.2 MiB /  43.2 MiB (100 %)   2.6 MiB/s ETA:   0 s                
info: downloading component &#39;rust-std&#39;
 55.3 MiB /  55.3 MiB (100 %)   3.7 MiB/s ETA:   0 s                
info: downloading component &#39;rust-docs&#39;
  6.4 MiB /   6.4 MiB (100 %)   5.0 MiB/s ETA:   0 s                
info: downloading component &#39;cargo&#39;
info: installing component &#39;rustc&#39;
info: installing component &#39;rust-std&#39;
info: installing component &#39;rust-docs&#39;
info: installing component &#39;cargo&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;beta-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: syncing channel updates for &#39;nightly-x86_64-unknown-linux-gnu&#39;
info: checking for self-updates
info: rustup is up to date

                            stable installed - rustc 1.9.0 (e4e8b6668 2016-05-18)
                              beta unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
     beta-x86_64-unknown-linux-gnu unchanged - rustc 1.10.0-beta.2 (39f3c16cc 2016-05-26)
                           nightly unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
  nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.11.0-nightly (0554abac6 2016-06-10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ、今回は上手くいった。やっぱりシンボリックリンクが悪かったよう。リトライ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target add --toolchain nightly arm-unknown-linux-gnueabihf
info: downloading component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
 62.6 MiB /  62.6 MiB (100 %)   1.4 MiB/s ETA:   0 s                
info: installing component &#39;rust-std&#39; for &#39;arm-unknown-linux-gnueabihf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んー、ちゃんとnightlyが入ったのか分からない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup show
installed toolchains
--------------------

stable
stable-x86_64-unknown-linux-gnu (default)
beta
beta-x86_64-unknown-linux-gnu
nightly
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.9.0 (e4e8b6668 2016-05-18)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし件のARM向けプロジェクトのクロスコンパイルは出来たよう。&lt;/p&gt;

&lt;p&gt;もう一度listを見る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rustup target list
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;arm-unknown-linux-gnueabihf (installed)&lt;/code&gt; とあるのでインストール出来ているよう。しかし本当にnightlyなのか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustup target list --toolchain stable
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
$ rustup target list --toolchain nightly
aarch64-apple-ios
aarch64-linux-android
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf (installed)
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-linux-android
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-freebsd
i686-unknown-linux-gnu
i686-unknown-linux-musl
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu (default)
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら本当にnightlyのよう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;色々あたふたとしましたがrustupをインストールして使ってみました。multirustを使っているとインストールあたりでやや難はありそうですがそれ以降は普通に使えそうです。&lt;/p&gt;

&lt;p&gt;皆様もお試しあれ。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>cargo-profilerを試す</title>
      <link>/blog/2016/05/14/cargo_profilerwotamesu</link>
      <pubDate>Sat, 14 May 2016 20:59:13 +0900</pubDate>
      
      <guid>/blog/2016/05/14/cargo_profilerwotamesu</guid>
      <description>&lt;p&gt;κeenです。先日Rustのニュースに流れてきたcargo profilerを試してみます。
元の紹介記事はこちら&lt;a href=&#34;http://www.suchin.co/2016/05/11/Introducing-Cargo-Profiler/&#34;&gt;Introducing Cargo Profiler · suchin&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;GitHubレポジトリはこちら&lt;a href=&#34;https://github.com/pegasos1/cargo-profiler&#34;&gt;pegasos1/cargo-profiler: cargo subcommand to profile binaries&lt;/a&gt;。

Profilerとはいっても自身でプロファイラを持っている訳ではなくて外部のプロファイラ（現状valgrind）を呼び出して整形してくれるツールのようです。
Rust向けに関数をモジュールパス付きで表示してくれたりするのでRustから使うにはvalgrind生より便利そうです。&lt;/p&gt;

&lt;h1 id=&#34;インストール&#34;&gt;インストール&lt;/h1&gt;

&lt;p&gt;READMEに従って&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt install valgrind
$ cargo install cargo-profiler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;h1 id=&#34;プロジェクトの準備&#34;&gt;プロジェクトの準備&lt;/h1&gt;

&lt;p&gt;適当なものがないので手元の[κLisp]()でフィボナッチ数列を動かしてみます。(と思ったらκLispに比較演算子がなかったのでそれを作るところから始まりましたがそれはまた別の話)。&lt;/p&gt;

&lt;p&gt;main.rsはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate kappa_lisp;
use kappa_lisp::kappa_lisp::{run, init};
use kappa_lisp::env::Env;

fn main() {
    let mut env = Env::new();
    init(&amp;amp;mut env).unwrap();
    run(&amp;amp;mut env, r&amp;quot;
(defun fib (n)
  (if (&amp;lt; n 2)
      1
      (+ (fib (- n 1)) (fib (- n 2)))))
&amp;quot;).unwrap();
    let expr = run(&amp;amp;mut env, r&amp;quot; (fib 20) &amp;quot;).unwrap();
    println!(&amp;quot;{}&amp;quot;, expr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;割と遅いので20くらいで限界でした。&lt;/p&gt;

&lt;p&gt;さて、これを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo build --release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてビルドします。&lt;/p&gt;

&lt;h1 id=&#34;プロファイル&#34;&gt;プロファイル&lt;/h1&gt;

&lt;p&gt;今のところcallgrindとcachegrindが実装されているようです。1つづづ試してみます。&lt;/p&gt;

&lt;h2 id=&#34;callgrind&#34;&gt;callgrind&lt;/h2&gt;

&lt;p&gt;よく分かってないのですが多分実行時間に占める関数毎の割合を出してくれるんですかね。-nで上位何件を表示するか指定出来ます。&lt;/p&gt;

&lt;p&gt;とりあえず上位10件出してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo profiler callgrind --bin ./target/release/kappa_lisp -n 10
Profiling kappa_lisp with callgrind...

Total Instructions...571,437,255

142,527,726 (24.9%) ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
107,551,309 (18.8%) ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
39,749,571 (7.0%) ???:collections::hash::map::HashMap..K$C$..V$C$..S..::get
-----------------------------------------------------------------------
38,693,006 (6.8%) ???:sdallocx
-----------------------------------------------------------------------
37,670,732 (6.6%) ???:mallocx
-----------------------------------------------------------------------
34,608,049 (6.1%) ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
26,539,906 (4.6%) ???:eval::eval
-----------------------------------------------------------------------
19,887,024 (3.5%) ???:util::f_foldr
-----------------------------------------------------------------------
16,634,175 (2.9%) ???:eval::feval
-----------------------------------------------------------------------
14,353,992 (2.5%) ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、こんな感じです。ハッシュテーブル関連が時間喰ってますね。これは関数呼び出しの度に行われてます。
ちょっと実装が雑すぎるので直さなきゃ…。&lt;/p&gt;

&lt;h1 id=&#34;cachegrind&#34;&gt;cachegrind&lt;/h1&gt;

&lt;p&gt;キャッシュミスを表示してくれます。本気出してチューニングする時に必要ですね。&lt;/p&gt;

&lt;p&gt;同じく -nで件数を絞り込めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10  


Profiling kappa_lisp with cachegrind...

Total Memory Accesses...800,070,388	

Total L1 I-Cache Misses...100,068 (0%)	
Total LL I-Cache Misses...422 (0%)	
Total L1 D-Cache Misses...4,346,335 (0%)	
Total LL D-Cache Misses...7,724 (0%)	

 Ir  I1mr ILmr  Dr  D1mr DLmr  Dw  D1mw DLmw
0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get
-----------------------------------------------------------------------
0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx
-----------------------------------------------------------------------
0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx
-----------------------------------------------------------------------
0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval
-----------------------------------------------------------------------
0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr
-----------------------------------------------------------------------
0.03 0.02 0.05 0.04 0.05 0.00 0.02 0.06 0.05 ???:eval::feval
-----------------------------------------------------------------------
0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やはりハッシュテーブルが酷いですが同じコードを繰り返し実行するタイプのマイクロベンチマークなのでキャッシュミスは少ないです。&lt;/p&gt;

&lt;p&gt;因みにそれぞれの列はこういう意味だそうです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ir -&amp;gt; Total Instructions&lt;/li&gt;
&lt;li&gt;I1mr -&amp;gt; Level 1 I-Cache misses&lt;/li&gt;
&lt;li&gt;ILmr -&amp;gt; Last Level I-Cache misses&lt;/li&gt;
&lt;li&gt;Dr -&amp;gt; Total Memory Reads&lt;/li&gt;
&lt;li&gt;D1mr -&amp;gt; Level 1 D-Cache read misses&lt;/li&gt;
&lt;li&gt;DLmr -&amp;gt; Last Level D-cache read misses&lt;/li&gt;
&lt;li&gt;Dw -&amp;gt; Total Memory Writes&lt;/li&gt;
&lt;li&gt;D1mw -&amp;gt; Level 1 D-Cache write misses&lt;/li&gt;
&lt;li&gt;DLmw -&amp;gt; Last Level D-cache write misses&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;--sort&lt;/code&gt; オプションでどの列をみるのか指定出来るようです。全メモリアクセスのミスレートを見てみましょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo profiler cachegrind --bin ./target/release/kappa_lisp -n 10 --sort dr


Profiling kappa_lisp with cachegrind...

Total Memory Accesses...800,082,686	

Total L1 I-Cache Misses...100,083 (0%)	
Total LL I-Cache Misses...420 (0%)	
Total L1 D-Cache Misses...4,321,895 (0%)	
Total LL D-Cache Misses...7,721 (0%)	

 Ir  I1mr ILmr  Dr  D1mr DLmr  Dw  D1mw DLmw
0.19 0.00 0.03 0.13 0.00 0.00 0.11 0.01 0.01 ???:hash::sip::SipHasher.Hasher::write
-----------------------------------------------------------------------
0.07 0.00 0.01 0.13 0.06 0.01 0.07 0.00 0.00 ???:expr..Expr::drop.9629
-----------------------------------------------------------------------
0.07 0.02 0.03 0.11 0.02 0.01 0.04 0.01 0.01 ???:mallocx
-----------------------------------------------------------------------
0.07 0.00 0.01 0.10 0.08 0.00 0.12 0.03 0.04 ???:collections::hash::map::HashMapK$C$V$C$S::get
-----------------------------------------------------------------------
0.25 0.00 0.02 0.09 0.00 0.01 0.11 0.05 0.06 ???:collections::hash::table::make_hash
-----------------------------------------------------------------------
0.07 0.00 0.03 0.09 0.01 0.00 0.03 0.00 0.00 ???:sdallocx
-----------------------------------------------------------------------
0.05 0.06 0.20 0.06 0.29 0.21 0.09 0.25 0.16 ???:eval::eval
-----------------------------------------------------------------------
0.03 0.00 0.03 0.04 0.14 0.15 0.09 0.13 0.09 ???:util::f_foldr
-----------------------------------------------------------------------
0.03 0.02 0.05 0.04 0.04 0.00 0.02 0.06 0.05 ???:eval::feval
-----------------------------------------------------------------------
0.03 0.00 0.02 0.03 0.00 0.01 0.08 0.05 0.09 ???:util::kcons
-----------------------------------------------------------------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やっぱりハッシュテーブル関連が重い…。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;私にとっては薮蛇にκLispの実装の筋が悪いことが分かったりしてショックでしたがまあ、簡単にプロファイルをとれるツールを紹介しました。&lt;/p&gt;

&lt;p&gt;Rustで高速なアプリケーションを作りたい方、利用してみては如何でしょうか。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RustでベアメタルRaspberry PiのLチカ</title>
      <link>/blog/2016/05/04/rustdebeametaruraspberry_pinolchika</link>
      <pubDate>Wed, 04 May 2016 11:43:26 +0900</pubDate>
      
      <guid>/blog/2016/05/04/rustdebeametaruraspberry_pinolchika</guid>
      <description>&lt;p&gt;κeenです。GWもくもく会で机の片隅で埃被ってたRSPiのベアメタルを触ってみたのでその成果報告を。
ベアメタルについて知らない人でも読めるように書きます。そしてアセンブラもCも出てきませんし、半田付けも必要ありません。
Rustしか使いません。&lt;/p&gt;

&lt;p&gt;Rustは分かるけどLチカは全く知らない、けど興味のある方は是非読んでみて下さい。
&lt;/p&gt;

&lt;h1 id=&#34;ベアメタルって&#34;&gt;ベアメタルって？&lt;/h1&gt;

&lt;p&gt;普段我々が使っているパソコンはOSの上で動いています。
OSはざっくりいうとハードウェアへのアクセスを抽象化し、プロセスという単位でプログラムの実行を分離します。
ベアメタルはそのOSがない状態、ハードウェアの初期化やプロトコルなどは自分でやるしメモリ管理だとかも自分でやる環境です。
丁度ハードウェアが抽象化されてなくて機械が生で見えているようなのでこう呼ぶようです。&lt;/p&gt;

&lt;p&gt;OSがないのは中々イメージつきづらいですが、標準出力なんてものはないのでHello Worldも動きませんしメモリも仮想化されていないのでmallocも発効出来ません。
さらにはスタックとヒープみたいな区別もOSが与えてくれるものなので、自分で作らない限りスタック領域も使えません。
自分で書いたプログラムが唯一走るプログラムなのでプロセスの感覚でプログラムを終了させてはいけません。&lt;/p&gt;

&lt;p&gt;なんでそんな環境でプログラムしたいかというといくつかモチベーションがありそうです。1つはOSそのものを作ってみたい人が練習がてら。
もう1つにはOSが動かないような小さな環境だとそれしか選択肢がない。&lt;/p&gt;

&lt;p&gt;RSPiの場合はOSが動くので選択肢がないという訳ではないのですが私はそういう小さなデバイスを持っていないので実験台としてRSPiを使いました。&lt;/p&gt;

&lt;p&gt;さて、Hello Worldすら動かないシステムでの入門的なプログラムは信号のON/OFFを切り替えてあげるだけで出来るLEDをチカチカさせるプログラムという訳です。&lt;/p&gt;

&lt;h1 id=&#34;raspberry-pi&#34;&gt;Raspberry Pi&lt;/h1&gt;

&lt;p&gt;言わずと知れた名刺サイズの小型コンピュータ、Raspberry Piです。
Raspberry Piと一口にいっても&lt;a href=&#34;https://ja.wikipedia.org/wiki/Raspberry_Pi&#34;&gt;色々種類がある&lt;/a&gt;のですが、私が持っているのはRaspberry Pi 1 Model Bの後期モデルです(Raspberry Pi 1 Model Bは販売途中で仕様がアップグレードしてメモリが増えた)。&lt;/p&gt;

&lt;p&gt;ARMv6アーキテクチャのチップ(ARM1176JZF-S)で動いていて、SDカードから起動します。特別なライターなどは必要なく、PCからSDカードに書き込んでRSPiに挿して電源を繋ぐだけで簡単に起動出来る訳です。
さらに配線とかが必要なGPIOに加えてボードにLEDもついているので物理の知識必要なくて今回のようにLチカだけをやりたいなら手軽に遊べます。&lt;/p&gt;

&lt;h1 id=&#34;準備&#34;&gt;準備&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 1 Model B&lt;/li&gt;
&lt;li&gt;USB - micro USBケーブル(Raspberry Piへの給電用)&lt;/li&gt;
&lt;li&gt;SDカード(FAT32でフォーマットしておく)&lt;/li&gt;
&lt;li&gt;GCCのARM向けクロスコンパイラ(後述)&lt;/li&gt;
&lt;li&gt;RustのARM向けクロスコンパイラ(後述)&lt;/li&gt;
&lt;li&gt;ブートローダ(後述)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gccのクロスコンパイラ&#34;&gt;GCCのクロスコンパイラ&lt;/h2&gt;

&lt;p&gt;GCCのクロスコンパイラは&lt;a href=&#34;https://launchpad.net/gcc-arm-embedded&#34;&gt;GCC ARM Embedded in Launchpad&lt;/a&gt;というプロジェクトがあるので簡単に用意出来ます。Ubuntu環境なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install gcc-arm-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストールできます。どうやらRSPiには不動小数点数計算ユニット(FPU)がついているようなのでhf(Hardware Float)で大丈夫みたいです。
HomebrewやPacmanにもパッケージはあるようです。&lt;/p&gt;

&lt;h2 id=&#34;rustのクロスコンパイラ&#34;&gt;Rustのクロスコンパイラ&lt;/h2&gt;

&lt;p&gt;次にRustのクロスコンパイラですが、&lt;a href=&#34;https://github.com/brson/multirust&#34;&gt;multirust&lt;/a&gt;を使うと簡単にインストール出来ます。今回はunstable機能も使うのでnightlyコンパイラを使います。
因みに私が昔インストールしたmultirustだと古くて以下のコマンドが実行出来なかったので出来ない方はmultirustをアップデートして試してみて下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# インストール可能なターゲットを確認
$ multirust list-available-targets nightly
aarch64-apple-ios
aarch64-unknown-linux-gnu
arm-linux-androideabi
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-apple-ios
armv7-unknown-linux-gnueabihf
armv7s-apple-ios
i386-apple-ios
i586-pc-windows-msvc
i586-unknown-linux-gnu
i686-apple-darwin
i686-pc-windows-gnu
i686-pc-windows-msvc
i686-unknown-linux-gnu
mips-unknown-linux-gnu
mips-unknown-linux-musl
mipsel-unknown-linux-gnu
mipsel-unknown-linux-musl
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
x86_64-apple-darwin
x86_64-apple-ios
x86_64-pc-windows-gnu
x86_64-pc-windows-msvc
x86_64-rumprun-netbsd
x86_64-unknown-freebsd
x86_64-unknown-linux-gnu
x86_64-unknown-linux-musl
x86_64-unknown-netbsd
# インストール
$ multirust add-target nightly arm-unknown-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ブートローダ&#34;&gt;ブートローダ&lt;/h2&gt;

&lt;p&gt;まず、ブートローダが何をするものなのかから説明しましょう。興味がない人は飛ばして下さい。&lt;/p&gt;

&lt;h3 id=&#34;説明&#34;&gt;説明&lt;/h3&gt;

&lt;p&gt;Raspberry PiにはCPUとGPUが両方ついているのでやや面倒です。&lt;/p&gt;

&lt;p&gt;CPU/GPUは電源がONになってすぐは何の機能もない、ただの命令を実行する機械です。メモリにすらアクセス出来ません。RSPiにSDカードを挿したところでSDカードのプロトコルを喋らないとそこに書いてあるプログラムが読めません。
SDカードのプロトコルを喋るプログラム(BIOS)は、RSPiに組込みで入っています。これは普段我々が使うメモリ(RAM)とは別の場所(ROM)に入っています。&lt;/p&gt;

&lt;p&gt;最初はGPUがそいつを起動し、(この時点ではCPUは起動してない)SDカードを読みにいきます。名前決め打ちでbootcode.binという名前のプログラムを、RAMではなくGPU(のL2キャッシュ)に直接ロードして実行します(メモリはまだ使えません)。
GPUのキャッシュは非常に小さいのでbootcode.binは小さなプログラムでないといけません。&lt;/p&gt;

&lt;p&gt;bootcode.binはRAMを有効にしてstart.elfをRAMに読み込み、GPUがそれを実行します。start.elfはRAMを使えるのである程度大きくても構いません。&lt;/p&gt;

&lt;p&gt;start.elfはconfig.txt、cmdline.txtとkernel.imgを読みにいき、kernel.imgを0x8000番地のメモリに配置します。そしてconfgやcmdlineに基いてCPUを設定してkernel.imgに引数を渡しつつ実行します。&lt;/p&gt;

&lt;p&gt;このkernel.imgは普段はLinuxカーネルなどのカーネル、今回は我々が作るLチカのプログラムです。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://kernhack.hatenablog.com/entry/2014/01/11/102237&#34;&gt;Raspberry Piのブートプロセスメモ - φ(・・*)ゞ ｳｰﾝ　カーネルとか弄ったりのメモ&lt;/a&gt;
昔はloader.binもあったようですが今はなくて大丈夫なようです。&lt;/p&gt;

&lt;h3 id=&#34;インストール&#34;&gt;インストール&lt;/h3&gt;

&lt;p&gt;bootcode.bin, start.elfは&lt;a href=&#34;https://github.com/raspberrypi/firmware/tree/master/boot&#34;&gt;こちら&lt;/a&gt;から入手出来ます。config.txtとcmdline.txtはなくていいようです。&lt;/p&gt;

&lt;p&gt;こいつらはSDカードに放り込んでおきます。&lt;/p&gt;

&lt;h1 id=&#34;環境確認&#34;&gt;環境確認&lt;/h1&gt;

&lt;p&gt;まずはコンパイラツールチェーンが正常に動くか確認しましょう。
以下にrustコードを。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(lang_items, asm)]
#![crate_type = &amp;quot;staticlib&amp;quot;]
#![no_std]

#[no_mangle]
pub extern fn main() {
    loop{}
}


#[no_mangle]
pub extern fn _sbrk() {}
#[no_mangle]
pub extern fn _exit() {}
#[no_mangle]
pub extern fn _kill() {}
#[no_mangle]
pub extern fn _getpid() {}


#[lang = &amp;quot;eh_personality&amp;quot;]
extern fn eh_personality() {}

#[lang = &amp;quot;panic_fmt&amp;quot;]
extern fn panic_fmt() {}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、今回作るのは &lt;code&gt;#![crate_type = &amp;quot;staticlib&amp;quot;]&lt;/code&gt; を使って静的リンクライブラリを作れと指定しています。そして &lt;code&gt;#[no_mangle] pub extern fn main() {&lt;/code&gt; でC言語と同じような規則でmain関数を定義する(アセンブラからmain関数を実行出来るようにする)と指定しています。
ベアメタル環境なのでファイルだとか諸々のものはなく、stdを使えないので &lt;code&gt;#![no_std]&lt;/code&gt; を指定してstdを使わずにcoreライブラリを使うようにしました。その代わり&lt;code&gt;#[lang = &amp;quot;eh_personality&amp;quot;] extern fn eh_personality() {}&lt;/code&gt; と &lt;code&gt;#[lang = &amp;quot;panic_fmt&amp;quot;] extern fn panic_fmt() {}&lt;/code&gt; を実装してあげないといけません(この実装はあまりよろしくないのですが今回はとりあえずコンパイルが通るようにということでこうしてます)。&lt;/p&gt;

&lt;p&gt;そしてよく分かってないのですがRustが &lt;code&gt;_sbrk&lt;/code&gt; 、 &lt;code&gt;_exit&lt;/code&gt; 、 &lt;code&gt;_kill&lt;/code&gt; 、 &lt;code&gt;_getpid&lt;/code&gt; のシンボルを捜しにいくのでとりあえずスタブを挿してます。&lt;/p&gt;

&lt;p&gt;no_mangle, no_std, lang_itemsについて詳しくは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/&#34;&gt;ドキュメント&lt;/a&gt;をご覧下さい。
&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/ffi.html&#34;&gt;他言語関数インターフェイス&lt;/a&gt;、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/no-stdlib.html&#34;&gt;No stdlib&lt;/a&gt;、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/lang-items.html&#34;&gt;言語アイテム&lt;/a&gt;あたりが参考になるかと思います。&lt;/p&gt;

&lt;p&gt;以下のようにコンパイル出来ればRustはOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustc --target arm-unknown-linux-gnueabihf --emit=obj test.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、elfファイルを作ります。これは以下のコマンドで出来ます。Cのクロスコンパイラを使っていますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles test.o -o kernel.elf
/usr/lib/gcc/arm-none-eabi/4.9.3/../../../arm-none-eabi/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000008000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-mで始まるオプションはRaspberry Piのチップ固有の指定、 -nostartfiles はベアメアルで動かすのに必要な指定ですね。&lt;/p&gt;

&lt;p&gt;最後にelfファイルからimgファイルを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arm-none-eabi-objcopy kernel.elf -O binary kernel.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私もよく分かってないのですがobjファイルが不完全なバイナリファイル、elfが完全なバイナリファイル、imgがelfを実際のメモリに展開した時のものそのままなんですかね。
逆にいうとOSのない環境で動かすには生のimgが欲しいけどそれを作るのは難しいから一旦elfを作ってそこからimgを生成している？&lt;/p&gt;

&lt;p&gt;さて、とりあえずここまで来れば環境は整いました。あとはプログラムを書くだけです。&lt;/p&gt;

&lt;h1 id=&#34;lチカ&#34;&gt;Lチカ&lt;/h1&gt;

&lt;p&gt;RSPiにくっついているLEDはデバイスとしてはGPIOのように見えるみたいです。
そしてGPIOはMemory Mapped IO、特定の位置のメモリを読み書きすることでデバイスをいじれるようになってるみたいです。
このセットアップは誰がやったんだって気になりますがBIOSなんですかね。&lt;/p&gt;

&lt;p&gt;さて、この「特定の位置のメモリ」ですが、Raspberry Pi 1だと &lt;code&gt;0x20200000&lt;/code&gt; から始まるアドレス、のようです。2だと &lt;code&gt;3F200000&lt;/code&gt; のよう。&lt;/p&gt;

&lt;p&gt;そして0x20200000からいくつかの32bitレジスタが配列のように並んでいる訳ですがこれまたRSPi+やRSP 2とRSPi 1はLEDに対応するレジスタがやや違うようです。&lt;/p&gt;

&lt;p&gt;面倒なのでコピペで済ませると(私はCのコードからRustに移植しました。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Raspberry Pi2
//pub const GPIO_BASE: u32 = 0x3F200000;
// other
pub const GPIO_BASE: u32 = 0x20200000;



// Raspberrp Pi+ or Raspberry Pi2
//pub const LED_GPFSEL: isize   = GPIO_GPFSEL4;
//pub const LED_GPFBIT: i32     = 21;
//pub const LED_GPSET: isize    = GPIO_GPSET1;
//pub const LED_GPCLR: isize    = GPIO_GPCLR1;
//pub const LED_GPIO_BIT: isize = 15;
//  other
pub const LED_GPFSEL: isize = GPIO_GPFSEL1;
pub const LED_GPFBIT: i32 = 18;
pub const LED_GPCLR: isize = GPIO_GPCLR0;
pub const LED_GPSET: isize = GPIO_GPSET0;
pub const LED_GPIO_BIT: i32 = 16;

pub const GPIO_GPFSEL0: isize   = 0;
pub const GPIO_GPFSEL1: isize   = 1;
pub const GPIO_GPFSEL2: isize   = 2;
pub const GPIO_GPFSEL3: isize   = 3;
pub const GPIO_GPFSEL4: isize   = 4;
pub const GPIO_GPFSEL5: isize   = 5;
pub const GPIO_GPSET0: isize    = 7;
pub const GPIO_GPSET1: isize    = 8;
pub const GPIO_GPCLR0: isize    = 10;
pub const GPIO_GPCLR1: isize    = 11;
pub const GPIO_GPLEV0: isize    = 13;
pub const GPIO_GPLEV1: isize    = 14;
pub const GPIO_GPEDS0: isize    = 16;
pub const GPIO_GPEDS1: isize    = 17;
pub const GPIO_GPREN0: isize    = 19;
pub const GPIO_GPREN1: isize    = 20;
pub const GPIO_GPFEN0: isize    = 22;
pub const GPIO_GPFEN1: isize    = 23;
pub const GPIO_GPHEN0: isize    = 25;
pub const GPIO_GPHEN1: isize    = 26;
pub const GPIO_GPLEN0: isize    = 28;
pub const GPIO_GPLEN1: isize    = 29;
pub const GPIO_GPAREN0: isize   = 31;
pub const GPIO_GPAREN1: isize   = 32;
pub const GPIO_GPAFEN0: isize   = 34;
pub const GPIO_GPAFEN1: isize   = 35;
pub const GPIO_GPPUD: isize     = 37;
pub const GPIO_GPPUDCLK0: isize = 38;
pub const GPIO_GPPUDCLK1: isize = 39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうなります(cfgを使ってないです。ごめんなさい。)。&lt;/p&gt;

&lt;p&gt;次にLチカですが、
LEDに対応するGPIOをwriteに初期化する→ループ{LEDに対応するGPIOをセットする → スリープ → LEDに対応するGPIOをクリアする → スリープ}&lt;/p&gt;

&lt;p&gt;のプログラムを書きます。&lt;/p&gt;

&lt;p&gt;色々試したのですが簡単なプログラムだと最適化で消えてしまうので消えないように工夫する必要があります。&lt;/p&gt;

&lt;p&gt;スリープはとりあえずタイマーを使わずに空ループを回すのですが、ループの中身は空インラインアセンブラを使うと消えないようです。&lt;/p&gt;

&lt;p&gt;また、メモリへの書き込みは&lt;a href=&#34;https://doc.rust-lang.org/core/intrinsics/&#34;&gt;intrinsic&lt;/a&gt;の&lt;a href=&#34;https://doc.rust-lang.org/core/intrinsics/fn.volatile_store.html&#34;&gt;volatile_store&lt;/a&gt;を使います。&lt;/p&gt;

&lt;p&gt;ということでコードは以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(lang_items, asm, core_intrinsics)]
#![crate_type = &amp;quot;staticlib&amp;quot;]
#![no_std]

use core::intrinsics::volatile_store;

// Raspberry Pi2
//pub const GPIO_BASE: u32 = 0x3F200000;
// other
pub const GPIO_BASE: u32 = 0x20200000;



// Raspberrp Pi+ or Raspberry Pi2
//pub const LED_GPFSEL: isize   = GPIO_GPFSEL4;
//pub const LED_GPFBIT: i32     = 21;
//pub const LED_GPSET: isize    = GPIO_GPSET1;
//pub const LED_GPCLR: isize    = GPIO_GPCLR1;
//pub const LED_GPIO_BIT: isize = 15;
//  other
pub const LED_GPFSEL: isize = GPIO_GPFSEL1;
pub const LED_GPFBIT: i32 = 18;
pub const LED_GPCLR: isize = GPIO_GPCLR0;
pub const LED_GPSET: isize = GPIO_GPSET0;
pub const LED_GPIO_BIT: i32 = 16;

pub const GPIO_GPFSEL0: isize   = 0;
pub const GPIO_GPFSEL1: isize   = 1;
pub const GPIO_GPFSEL2: isize   = 2;
pub const GPIO_GPFSEL3: isize   = 3;
pub const GPIO_GPFSEL4: isize   = 4;
pub const GPIO_GPFSEL5: isize   = 5;
pub const GPIO_GPSET0: isize    = 7;
pub const GPIO_GPSET1: isize    = 8;
pub const GPIO_GPCLR0: isize    = 10;
pub const GPIO_GPCLR1: isize    = 11;
pub const GPIO_GPLEV0: isize    = 13;
pub const GPIO_GPLEV1: isize    = 14;
pub const GPIO_GPEDS0: isize    = 16;
pub const GPIO_GPEDS1: isize    = 17;
pub const GPIO_GPREN0: isize    = 19;
pub const GPIO_GPREN1: isize    = 20;
pub const GPIO_GPFEN0: isize    = 22;
pub const GPIO_GPFEN1: isize    = 23;
pub const GPIO_GPHEN0: isize    = 25;
pub const GPIO_GPHEN1: isize    = 26;
pub const GPIO_GPLEN0: isize    = 28;
pub const GPIO_GPLEN1: isize    = 29;
pub const GPIO_GPAREN0: isize   = 31;
pub const GPIO_GPAREN1: isize   = 32;
pub const GPIO_GPAFEN0: isize   = 34;
pub const GPIO_GPAFEN1: isize   = 35;
pub const GPIO_GPPUD: isize     = 37;
pub const GPIO_GPPUDCLK0: isize = 38;
pub const GPIO_GPPUDCLK1: isize = 39;

#[no_mangle]
pub extern fn main() {
    // GPIO_BASEを符号無し32bit整数を指すポインタにキャストする
    let gpio = GPIO_BASE as *const u32;
    // offsetを使うことでCの配列のようにポインタの何番地か先のメモリを指せる
    let init   = unsafe {gpio.offset(LED_GPFSEL) as *mut u32};
    let led_on = unsafe { gpio.offset(LED_GPSET) as *mut u32 };
    let led_off = unsafe { gpio.offset(LED_GPCLR) as *mut u32 };

    // LEDのGPIOを書き込みに設定
    unsafe{
        volatile_store(init, *(init) | 1 &amp;lt;&amp;lt; LED_GPFBIT);
    }

    loop {
        // LEDをOFFにする
        unsafe {
            volatile_store(led_off, 1 &amp;lt;&amp;lt; LED_GPIO_BIT);
        }
        // 適当な長さbusy loopで時間を空ける
        for _ in 1..500000 {
            unsafe { asm!(&amp;quot;&amp;quot;); }
        }

        // LEDをONにする
        unsafe {
            volatile_store(led_on, 1 &amp;lt;&amp;lt; LED_GPIO_BIT);
        }
        // また適当な長さ空ける
        for _ in 1..500000 {
            unsafe { asm!(&amp;quot;&amp;quot;); }
        }
    }
}


#[no_mangle]
pub extern fn _sbrk() {}
#[no_mangle]
pub extern fn _exit() {}
#[no_mangle]
pub extern fn _kill() {}
#[no_mangle]
pub extern fn _getpid() {}


#[lang = &amp;quot;eh_personality&amp;quot;]
extern fn eh_personality() {}

#[lang = &amp;quot;panic_fmt&amp;quot;]
extern fn panic_fmt() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをkernel.rsとして保存し、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rustc  -O --target arm-unknown-linux-gnueabihf --emit=obj kernel.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でコンパイルします。どうやら使っていないのにrustが余計なシンボルを付けるようで、-Oをつけてそいつらをoptimize outさせないとコンパイルが通りませんでした。
この辺、コンパイラのバージョンに依存しそうで怖いですね。&lt;/p&gt;

&lt;p&gt;さて、あとは先程と同じく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arm-none-eabi-gcc -O2 -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostartfiles kernel.o -o kernel.elf
$ arm-none-eabi-objcopy kernel.elf -O binary kernel.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でイメージを作ってあげます。&lt;/p&gt;

&lt;p&gt;そしたらこのkernel.imgをSDカードに放り込みます。&lt;/p&gt;

&lt;p&gt;SDカードの中身はこうなっている筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls  /media/kim/6F6F-DCD9
bootcode.bin  kernel.img  start.elf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このSDカードをRSPiに挿して、電源を繋いであげるとLEDがすごい勢いでチカチカする筈です。そうなったら成功です。おめでとうございます。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/RaspPi&#34;&gt;ここ&lt;/a&gt;に置いておきます。とはいってもそのままではなくてCargo化したりMakefileを書いたり色々しています。&lt;/p&gt;

&lt;p&gt;今回の作業をするにあたって参考にした資料のURLを挙げておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valvers.com/open-software/raspberry-pi/step01-bare-metal-programming-in-cpt1/&#34;&gt;Step01 – Bare Metal Programming in C Pt1 – Valvers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valvers.com/open-software/raspberry-pi/step02-bare-metal-programming-in-c-pt2/&#34;&gt;Step02 – Bare Metal Programming in C Pt2 – Valvers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.thiago.me/raspberry-pi-bare-metal-programming-with-rust/&#34;&gt;Raspberry Pi Bare Metal Programming with Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.bobuhiro11.net/2014/01-13-baremetal.html&#34;&gt;piでベアメタルプログラミング - bobuhiro11&amp;rsquo;s diary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustとは何か。どんな言語か。</title>
      <link>/slide/Rusttohananika_donnagengoka_/</link>
      <pubDate>Sun, 06 Mar 2016 05:27:39 +0900</pubDate>
      
      <guid>/slide/Rusttohananika_donnagengoka_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustとは何か。どんな言語か。
----------------------
[異種プログラミング言語格闘勉強会](http://kbkz.connpass.com/event/26677/)  
2016-03-20


&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# Rustって?
----------

* システムプログラミング言語
* だけど函数型言語から影響を受けた
* 安全かつ高速
* ゼロコスト抽象化

===
## システムプログラミング言語
---------------------------

* スレッドはネイティブ、Cとの相互呼び出し、小さなバイナリサイズ
* ゲームエンジンとか作れる([piston](https://github.com/PistonDevelopers/piston))
* レンダリングエンジンとか作れる([Servo](https://github.com/servo/servo))
* Lチカとか出来る
* OSとか作れる([Redox](https://github.com/redox-os/redox))

===
## 函数型言語的からの影響
-----------------------

最近ではめずらしくなくなった


* デフォルトイミュータブル
* 代数的データ型
* コンビネータ
* トレイト (型クラス)

===
## 安全かつ高速
--------------

* データ競合が起きない
  + 所有権システム
  + だいたいコンパイル時Read Writeロック
  + Read only参照複数 or Write可能参照1つ
* LLVMベースの強力な最適化
* スレッド周辺のAPIが揃ってる

===
## ゼロコスト抽象化
------------------
省略

* [Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/)

===
# Rustの誤解
-----------

* 安定してないって聞いたよ
* 函数型言語ってホント?
* GCがなくて大丈夫?
* 継承がなくて大丈夫?

===
## 安定してないって聞いたよ

* 1.0以前の話
* 1.0(2015-05以降)はAPIの変更がルール化された
* 新規APIのstablizeはあれどdeprecateはまれ

===
## 函数型言語ってホント?

* 函数型言語の機能をつまみぐいしてるだけ
* 標準ライブラリとかはバリバリ手続的
* Lispよりも函数型言語っぽくない。
* とはいえ抽象力は高いのでそこまで煩雑にはならない

===
## GCがなくて大丈夫?

* GCはなくてもメモリ管理は自動でする
* コンパイル時にメモリ管理
  + コンパイラが必要なところにmalloc/freeを挟むイメージ
* むしろメモリ以外(fd、ロックなど)も自動管理
  + GCがある言語よりリソース管理の自動化が徹底してる
* [リージョンについて | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/)

===
## 継承がなくて大丈夫?

* むしろ継承必要？インターフェースだけでよくない？
* Rustはデータ型とメソッドを分離するので継承のメリットそんなにない
  + トレイトが強力ともいう
* 逆にサブタイプ関係による複雑さの上昇のデメリットが多い
  + 3回以上継承してるの全部把握出来るの？
* ジェネリクスとかはあるよ

===
# Rustをとりまく環境
-------------------

* racer/rustfmt
* Cargo
* crates.io
* [Rust Playground](https://play.rust-lang.org/)
* The Rust Programming Language


===
# racer/rustfmt
---------------

* racerがコーディング支援ツール
  + 補完
  + 定義元ジャンプ
  + 型情報
  + 各種エディタプラグインあり
* rustfmtがコードフォーマッタ
  + エディタプラグインあり
  + ビルドツール連携あり

===
# Cargo
-------

* Rustのビルドツール兼パッケージマネージャ
* これだけ覚えとけば困らない

===
# crates.io
-----------

* Rustパッケージのセントラルレポジトリ
* 必ずビルドが通るような工夫
  + cargo yank
  + 同じライブラリの違うバージョンがいても大丈夫
* Cargoとの連携
* Cargoからpublishも可能

===
# [Rust Playground](https://play.rust-lang.org/)
---------------------------------------

* webからRustを試せる
* とりあえず試すと色々分かる
  + 所有権難しいとか

===
# [The Rust Programming Language](https://doc.rust-lang.org/book/)
------------------------------

* Rustの入門用ドキュメント
* とりあえずこれ読めば始められる
* [和訳版](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)もある
  + [GitHub](https://github.com/rust-lang-ja/the-rust-programming-language-ja)で作業中
  + これの宣伝しに来ただけ
* 1.6ほぼ終わり、1.7はまだ

===
# ライブラリ紹介
----------------
## MIO

* [mio](https://github.com/carllerche/mio)
* 低レベルな非同期IOライブラリ
  + libuvやlibev2相当
  + イベントスレッドではなくイベントループ
* これを純Rustで実装
* つまり(比較的)高水準なAPIで使える
* 色んなライブラリの下地になっている

===
# ライブラリ紹介
----------------
## diesel

* [diesel](https://github.com/sgrif/diesel)
* ORM &amp; クエリビルダ
  + mioとはうってかわって高水準なライブラリ
* `infer_schema!(dotenv!(&#34;DATABASE_URL&#34;));` でコンパイル時に
  + DBにアクセスしてスキーマ情報抜いて
  + コード生成
* モデルもCRUDでちゃんと使い分けている

===
# 所有権難しい
--------------
下記のコードは動かない。

``` rust
fn main(){
    let hello = &#34;Hello, &#34;.to_owned();
    let world = &#34;World!&#34;;
    let hello_world =  hello + world;
    println!(&#34;{}&#34;, hello);
    println!(&#34;{}&#34;, world);
    println!(&#34;{}&#34;, hello_world);
}

```


===
# まとめ
--------

* Rustはシステムプログラミング言語だよ
* 面白い機能いっぱいあるよ
* もう「安定待ち」じゃないよ
* Try it now!



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>リージョンとRustの返り値</title>
      <link>/blog/2016/03/02/ri_jontorustnokaerichi</link>
      <pubDate>Wed, 02 Mar 2016 00:05:03 +0900</pubDate>
      
      <guid>/blog/2016/03/02/ri_jontorustnokaerichi</guid>
      <description>&lt;p&gt;Rustにおいては返り値ポインタで返すよりもそのまま返して、受け取る側でポインタで受け取るかそのまま受け取るかを指定するのが良い選択肢だ、といっています。
しかし初めて見る時にはどうしてそんなことが出来るのかわからず、びっくりしますよね。
それをRustがリージョンを使ってメモリ管理をしていると分かればどうなっているのか分かったのですこしばかり。
&lt;/p&gt;

&lt;p&gt;Rustにおいては以下のように関数が値を返す時にポインタを返すコードは好ましくなく、（というかコンパイル出来ない）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; &amp;amp;BigStruct {
    &amp;amp;BigStruct{ .... }
}

let bs = new_value();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数が返す値はスタックに載らないような大きな値でもそのまま返して、受け取り側でヒープに保存してあげるのが良いスタイルとされています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; BigStruct {
    BigStruct{ .... }
}

let bs = Box::new(new_value());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までの言語の感覚だとRustにおいて良いとされるスタイルは大きな値を一旦スタックに載せた後で&lt;code&gt;Box&lt;/code&gt;によって作られたヒープ領域に確保されているように見えます。&lt;/p&gt;

&lt;p&gt;これはリージョンについて理解すると動作が理解できます。&lt;/p&gt;

&lt;p&gt;リージョンについては以前のブログを参照して下さい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/&#34;&gt;リージョンについて | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、リージョンによるメモリ管理は「メモリを確保すべき場所」が先にあって、値はそこに置かれます。
特に、関数呼び出しにおいて、関数の「返り値を確保すべき場所」は関数の外から与えます。&lt;/p&gt;

&lt;p&gt;ここまで説明したらお分りかと思いますが、&lt;code&gt;Box::new(new_value());&lt;/code&gt;というコードは&lt;code&gt;new_value()&lt;/code&gt;の返り値を保存する場所としてヒープ領域を渡していて、
関数内部でそのヒープ領域にBigStructの値を書き込んでいるのです。&lt;/p&gt;

&lt;p&gt;もやもやしていたものがスッキリしたし返り値のサイズが決まってないと関数から返せないのも分かるようになった。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのゼロコスト抽象化</title>
      <link>/blog/2016/03/01/rustnozerokosutochuushouka</link>
      <pubDate>Tue, 01 Mar 2016 23:32:12 +0900</pubDate>
      
      <guid>/blog/2016/03/01/rustnozerokosutochuushouka</guid>
      <description>&lt;p&gt;κeenです。今日Twitter上でのやりとりから少し面白いことが分かったのでそれについて。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;最近1.0が出たKotlinについて、水島さんがツイートしてました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;nullableに対してはmapとかの高階関数を一切使えないのが痛い。 ?. でカバーできるケースは一部だけだ。zero-overhead null-safetyと唄っとるが、代わりにnullチェックお化けになるわけで、どこがzero-overheadだ &lt;a href=&#34;https://twitter.com/hashtag/kotlin_dis?src=hash&#34;&gt;#kotlin_dis&lt;/a&gt;&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704453235277324288&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;それについて私が無関係なツイートを。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;全く無関係だけどRustはOptionみたいな0-1の型をnull or valueに最適化するそうな。これこそがゼロコスト抽象かな &lt;a href=&#34;https://t.co/5Y7cBEyrMe&#34;&gt;https://t.co/5Y7cBEyrMe&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704453898996547584&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;これはRustのnomiconに書かれています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/repr-rust.html&#34;&gt;repr(Rust)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;そうすると水島さんからお返事が。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; Rust詳しくないですけど、Optionにmapとかした場合インライン展開されるんですかね？だとしたらとても理想的。&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704455185125408768&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;確かにそうなると面白そう。ということで少し調べてみました。&lt;/p&gt;

&lt;p&gt;まず、上記の話をまとめると、Rustの&lt;code&gt;Option&lt;/code&gt;に対する&lt;code&gt;map&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    match self {
        Some(x) =&amp;gt; Some(f(x)),
        None =&amp;gt; None,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;code&gt;x&lt;/code&gt;がポインタ型だった時に以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    if (self != nullPointer ) {
        f(x)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、&lt;a href=&#34;https://github.com/rust-lang/rust/blob/master/src/libcore/option.rs#L386&#34;&gt;&lt;code&gt;map&lt;/code&gt;はインライン宣言されている&lt;/a&gt;ので以下のコード&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  (|x| x + 1)(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、ここで無名関数がどうコンパイルされるかという問題が出てきますが、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャのドキュメント&lt;/a&gt;によるとこういう雰囲気のコードになるらしいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
struct AnonymousType;

impl FnOnce&amp;lt;(&amp;amp;i32)&amp;gt; for AnonymousType {
    type Output = i32;
    fn call_once(self, args: (&amp;amp;i32)) -&amp;gt; Self::Output {
        args + 1
    }
}

if (opt != nullPointer) {
    let fn_once: FnOnce = AnonymousType;
    fn_once.call_once(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思ったよりも複雑…。さて、問題は&lt;code&gt;let fn_once: FnOnce = AnonymousType;&lt;/code&gt;としているので一旦元の無名関数の情報が抜けてしまいそうな気がします。
となるとコンパイル時に具体的なメソッドを決定出来ないので&lt;code&gt;fn_once.call_once(opt);&lt;/code&gt;は以下のような雰囲気のコードになってしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回呼び出すべき関数の取得が入るのは面倒ですね。&lt;/p&gt;

&lt;p&gt;しかしなががらクロージャのドキュメントをよく読むと無名関数は静的ディスパッチされると書いてあります。つまり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と2段ではなく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;the_call_once_fn_of_AnonymousType(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイルされ、&lt;/p&gt;

&lt;p&gt;よって&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn the_call_once_fn_of_AnonymousType(x: &amp;amp;i32) -&amp;gt; i32 {
    x + 1
}


let opt = &amp;amp;v;
if (opt != nullPointer) {
  the_call_once_fn_of_AnonymousType(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と同値ということです。&lt;/p&gt;

&lt;p&gt;ここからは私の推測ですが、&lt;code&gt;the_call_once_fn_of_AnonymousType&lt;/code&gt;は本体が小さい上に1回しか呼ばれないのでインライン化されるのではないかと思います。
よってこの推測が正しければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  opt + 1
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる筈です。&lt;/p&gt;

&lt;p&gt;ゼロコスト抽象化すごい!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RustのHigher-Kinded type Trait</title>
      <link>/blog/2016/02/28/rustnohigherkinded_type_trait</link>
      <pubDate>Sun, 28 Feb 2016 14:40:59 +0900</pubDate>
      
      <guid>/blog/2016/02/28/rustnohigherkinded_type_trait</guid>
      <description>&lt;p&gt;κeenです。少し前の話になりますがRustの関連型を駆使してHigher Kinded type Trait（高階型トレイト）を実現してしまったものが出回ってたのでそれについて。
本来RustはHKTをサポートしていませんが不思議なことに実装出来てしまっているのです。&lt;/p&gt;

&lt;p&gt;HKTについて微塵も知らない方にも分かるように解説していきます。
&lt;/p&gt;

&lt;h1 id=&#34;map-可能なトレイト&#34;&gt;&lt;code&gt;map&lt;/code&gt; 可能なトレイト&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/core/option/enum.Option.html#method.map&#34;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;https://doc.rust-lang.org/core/result/enum.Result.html#method.map&#34;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;、etc 色々なトレイトが &lt;code&gt;map&lt;/code&gt; メソッドを実装しています。&lt;/p&gt;

&lt;p&gt;それぞれ型シグネチャを抜き出してみましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Option: &lt;code&gt;map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Result: &lt;code&gt;map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, op: F) -&amp;gt; Result&amp;lt;U, E&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;驚く程似てますね。これを抽象化して「&lt;code&gt;map&lt;/code&gt;メソッドを持つ」トレイトを定義したくなるかもしれません。
しかしそれは簡単には書けません。何故なら&lt;code&gt;map&lt;/code&gt;はコンテナ型、つまり「型引数を取る型」に定義される型だからです。
現在のRustは「型引数を取る型」に対するジェネリクスはサポートしていません。もし書こうとするとこのようになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;M&amp;lt;_&amp;gt;, T&amp;gt; where Self: M&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; M&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt; なんて型パラメータを書くことは出来ませんし&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;も無理があります。残念ですね。&lt;/p&gt;

&lt;h1 id=&#34;iterator-との違い&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt; との違い&lt;/h1&gt;

&lt;p&gt;さて、&lt;code&gt;Iterator&lt;/code&gt;にも&lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;はあります。
これこそが求めている「&lt;code&gt;.map&lt;/code&gt; 可能なトレイト」ではないのでしょうか。
これはおおよそは合っているのですがやや期待とは違う動作をします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt;の&lt;code&gt;map&lt;/code&gt;は不自由なく使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let o = Some(1);
let o = o.map(|i| i + 1);
println!(&amp;quot;{:?}&amp;quot;, o);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一方、&lt;code&gt;Vec&lt;/code&gt;は全く同じような書き方は出来ません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = vec![1];
let v = v.map(|i| i + 1);
println!(&amp;quot;{:?}&amp;quot;, v);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;anon&amp;gt;:3:11: 3:25 error: no method named `map` found for type `collections::vec::Vec&amp;lt;_&amp;gt;` in the current scope
&amp;lt;anon&amp;gt;:3 let v = v.map(|i| i + 1);
                   ^~~~~~~~~~~~~~
&amp;lt;anon&amp;gt;:3:11: 3:25 note: the method `map` exists but the following trait bounds were not satisfied: `collections::vec::Vec&amp;lt;_&amp;gt; : core::iter::Iterator`, `[_] : core::iter::Iterator`
error: aborting due to previous error
playpen: application terminated with error code 101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正しくは、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = vec![1];
let v: Vec&amp;lt;i32&amp;gt; = v.iter().map(|i| i + 1).collect();
println!(&amp;quot;{:?}&amp;quot;, v);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;色々実装上のノイズが乗っているのでやや例として不適切だったかもしれませんが、注目して欲しい部分はここです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v: Vec&amp;lt;i32&amp;gt; = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt;から取り出したイテレータなのに&lt;code&gt;Vec&lt;/code&gt;に戻すためにわざわざ型アノテーションを書く必要があります。&lt;/p&gt;

&lt;p&gt;どうしてこうなるかというとイテレータを取り出した時点で元のコンテナ型が&lt;code&gt;Vec&amp;lt;&amp;gt;&lt;/code&gt;であるという情報が失われているからです。
これはRustの型システム上どうしても仕方のないことで、なので恐らくRustは「&lt;code&gt;map&lt;/code&gt;可能なトレイト」などを定義せず、コレクションの操作を&lt;code&gt;Iterator&lt;/code&gt;に集約しているんだと思います。
この方式はある程度は上手くいきますが&lt;code&gt;Option&lt;/code&gt;や&lt;code&gt;Result&lt;/code&gt;はIteratorになれはしてもIteratorからは作れない(2要素のイテレータからOptionは作れない)ので独自でmapメソッドを持つことになってしまいます。&lt;/p&gt;

&lt;h1 id=&#34;map-可能なトレイト-again&#34;&gt;&lt;code&gt;map&lt;/code&gt; 可能なトレイト again&lt;/h1&gt;

&lt;p&gt;先程そういうのは作れないと言ったばかりですが実はどうにかする方法がなくもないです。先程の(仮想の)定義を思い出して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;M&amp;lt;_&amp;gt;, T&amp;gt; where Self: M&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; M&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジェネリクスになっている登場人物は&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;、&lt;code&gt;U&lt;/code&gt;、&lt;code&gt;T&lt;/code&gt; ですね。しかし&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;は実際にはそのまま使われいる訳ではなく&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;または&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;の形でのみ使われています。
では、&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;をパラメータに取るようにしてはどうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;T, MT&amp;gt; where Self: MT {
  fn map&amp;lt;U, MU, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで出来…てません。これは欲しい、正しいもの &lt;em&gt;も&lt;/em&gt; 作れてはいるのですが正しくないものも含んでいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;T, MT: Option&amp;lt;T&amp;gt; Mappable&amp;lt;MT, T&amp;gt;  for Option&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, MU, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU {...}
}

let r: Result&amp;lt;String, ()&amp;gt; = Some(1).map(|i| i.to_string());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt; に対する&lt;code&gt;map&lt;/code&gt;を&lt;code&gt;Result&lt;/code&gt;で受けようとしています。
これはもちろんおかしなことですが上記の型定義に従うとこういうことが出来てしまいます。
もうちょっというと上のトレイトの定義はこういう「おかしなこと」が起こるような実装をしろ、と言っている訳で、実際には実装出来ません。&lt;/p&gt;

&lt;p&gt;本来なら自由パラメータが3つなのに4つの自由パラメータを取ってしまったので不整合が起きる訳です。
では、自由パラメータを3つにして1つを従属パラメータにしてはどうでしょうか。それは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;を使えばRustでも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;T, U, MT&amp;gt; where Self: MT {
  type MU;
  fn map&amp;lt;F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これである程度上手くいきます。
もちろん、実際に&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;を取れるのに比べると不自由で下手をするとバグる(MUを無関係な型に定義できてしまう)可能性があるのですが、先程の4パラメータの時と比べて
トレイトが定義された時点で返す型は決まっているのでちゃんと実装出来ますし、使う時に不整合が起きることもありません。&lt;/p&gt;

&lt;h1 id=&#34;hkt&#34;&gt;HKT&lt;/h1&gt;

&lt;p&gt;さて、先の&lt;code&gt;Mappable&lt;/code&gt;の仮想定義、&lt;code&gt;map&lt;/code&gt;関数を除いて汎用的にするとこうなりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U, MT&amp;gt; where Self: MT {
  type MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Self: MT&lt;/code&gt; というアノテーションをつけてますが実際には使えません。&lt;code&gt;impl&lt;/code&gt;を書くときに気をつけて実装するしかないです。なのでこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U&amp;gt; {
  type MU;
}

impl &amp;lt;T, U&amp;gt; HKT&amp;lt;T, U&amp;gt; for Option&amp;lt;T&amp;gt; {
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、こう書くとするとこういうことも出来てしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U&amp;gt; {
  type MU;
}

impl &amp;lt;S, T, U&amp;gt; HKT&amp;lt;T, U&amp;gt; for Option&amp;lt;S&amp;gt; {
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;T&lt;/code&gt;とは独立な&lt;code&gt;S&lt;/code&gt;に対するコンテナに対して実装できてしまうのです。「実装するときに気をつける」とはいいましたが制約を書けるなら書いた方がいいです。こうしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;U&amp;gt; {
  type T;
  type MU;
}

impl &amp;lt;T, U&amp;gt; HKT&amp;lt;U&amp;gt; for Option&amp;lt;T&amp;gt; {
  type T = T;
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで冒頭に紹介したHKTの実装になりました。&lt;/p&gt;

&lt;p&gt;逆にこのHKTの実装からMappableを定義するには、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;U&amp;gt;: HKT&amp;lt;U&amp;gt; {
  fn map&amp;lt;F: FunOnce(Self::T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Self::MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hktについてもっと&#34;&gt;HKTについてもっと&lt;/h1&gt;

&lt;p&gt;ようやく話題のHKTの元実装です。こちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/14427/af90a21b917d2892eace&#34;&gt;Higher-kinded type trait&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ずいぶんとモナモナしいですがやはり高階型を使った一番実績のある構造はこのあたりでしょう。&lt;/p&gt;

&lt;p&gt;こういうのを扱えるとプログラミングの幅が広がりますね。&lt;/p&gt;

&lt;h1 id=&#34;ノート&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;モナドの話題が出ましたがRustでモナドを実現するには高階型だけでなく複数ある関数トレイトのどれを選ぶかだとかその他諸々の問題を扱う必要があるようです。
&lt;a href=&#34;https://m4rw3r.github.io/rust-and-monad-trait/&#34;&gt;Rust and the Monad trait - Not just higher kinded types · m4rw3r&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustのパッケージをcrates.ioに登録する</title>
      <link>/blog/2016/01/31/rustnopakke_jiwocrates_ionitourokusuru</link>
      <pubDate>Sun, 31 Jan 2016 14:43:14 +0900</pubDate>
      
      <guid>/blog/2016/01/31/rustnopakke_jiwocrates_ionitourokusuru</guid>
      <description>&lt;p&gt;κeenです。技術の話題を書くのは久し振りですね。今日初めてRustのパッケージのセントラルレポジトリ、&lt;a href=&#34;crates.io&#34;&gt;crates.io&lt;/a&gt;にパッケージを登録したのでその流れを共有します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;登録したいパッケージを用意する&#34;&gt;登録したいパッケージを用意する&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logge&lt;/a&gt;を作りました。
しばらく前に(Advent Calendar向けに)それっぽく動くところまで作って放置してたやつですね。これを整形していきます。&lt;/p&gt;

&lt;h1 id=&#34;任意-ドキュメントを生成する&#34;&gt;(任意)ドキュメントを生成する&lt;/h1&gt;

&lt;p&gt;Rustには素晴しき &lt;code&gt;cargo doc&lt;/code&gt; があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo doc --no-deps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でドキュメントを生成しましょう。ドキュメントを書いてないなら&lt;a href=&#34;http://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/documentation.html&#34;&gt;こちら&lt;/a&gt;を見ながら書きましょう（すいません、私の奴は全然書いてないです…）。
&lt;code&gt;target/doc&lt;/code&gt; 以下に生成されたドキュメントがあるので適当に &lt;code&gt;gh-pages&lt;/code&gt; ブランチに放り込みましょう。
尚、&lt;code&gt;--no-deps&lt;/code&gt; オプションがないと依存パッケージのドキュメントも全部生成してしまいます。&lt;/p&gt;

&lt;p&gt;求: gh-pages管理のベストプラクティス。&lt;/p&gt;

&lt;h1 id=&#34;パッケージ情報を充実させる&#34;&gt;パッケージ情報を充実させる&lt;/h1&gt;

&lt;p&gt;普段使っているままの &lt;code&gt;Cargo.toml&lt;/code&gt; だとcrates.ioで見た時に情報が全然ありません。
&lt;code&gt;[package]&lt;/code&gt; セクションに色々書きましょう。私の場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[package]
name = &amp;quot;file_logger&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Sunrin SHIMURA (keen) &amp;lt;3han5chou7@gmail.com&amp;gt;&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;から&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[package]
name = &amp;quot;file_logger&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Sunrin SHIMURA (keen) &amp;lt;3han5chou7@gmail.com&amp;gt;&amp;quot;]
repository = &amp;quot;https://github.com/KeenS/file_logger&amp;quot;
keywords = [&amp;quot;log&amp;quot;, &amp;quot;file&amp;quot;]
license-file = &amp;quot;LICENSE&amp;quot;
readme = &amp;quot;README.md&amp;quot;
description = &amp;quot;A simple logger backend that outputs to a file. \nThis is alpha state.&amp;quot;
documentation = http://KeenS.github.io/file_logger/file_logger/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になりました。
あ、ちゃんとライセンスも明示しましょうね。&lt;/p&gt;

&lt;p&gt;どういう情報が書けるのかは&lt;a href=&#34;http://doc.crates.io/manifest.html&#34;&gt;ここ&lt;/a&gt;に載ってます。&lt;/p&gt;

&lt;h1 id=&#34;crates-ioにログインする&#34;&gt;crates.ioにログインする&lt;/h1&gt;

&lt;p&gt;[crates.io]()に行き、右上にあるGitHubログインボタンをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/login.png&#34; alt=&#34;github login&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そうするとログイン状態になります&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/loggedin.png&#34; alt=&#34;github logged in&#34; /&gt;&lt;/p&gt;

&lt;p&gt;メニューから&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/menu.png&#34; alt=&#34;menu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Account Settingsに飛ぶと下記のようにログイン用cargoコマンドが提示されるのでそのままペタっとコマンドラインに貼って終了です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/account_settings.png&#34; alt=&#34;account settings&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;パッケージング&#34;&gt;パッケージング&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ cargo package
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;crates-ioに登録する&#34;&gt;crates.ioに登録する&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ cargo publish
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;その他&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;パッケージに含めるファイルを細かく調整したい、既にpublishしたパッケージをdeprecated的な扱いにしたいなどは&lt;a href=&#34;http://doc.crates.io/crates-io.html&#34;&gt;こちら&lt;/a&gt;にドキュメントが載っています。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;crates.ioにログインしたよ&lt;/li&gt;
&lt;li&gt;Cargoを使えば簡単にパッケージを登録出来るよ&lt;/li&gt;
&lt;li&gt;Cargoってすごいね&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustといえどリソースの解放は注意</title>
      <link>/blog/2016/01/08/rusttoiedoriso_sunokaihouhachuui</link>
      <pubDate>Fri, 08 Jan 2016 00:50:31 +0900</pubDate>
      
      <guid>/blog/2016/01/08/rusttoiedoriso_sunokaihouhachuui</guid>
      <description>&lt;p&gt;κeenです。深夜にですが小ネタを。
&lt;/p&gt;

&lt;p&gt;Rustを使っているとついついリソースの解放のことは忘れてしまうのですが、注意しないといけない類のリソースがあります。&lt;/p&gt;

&lt;p&gt;その1つが&lt;code&gt;BufWriter&lt;/code&gt;です。
バッファリングライター全般に言えることですが、奴らはメモリ上にまだ書き込まれてない値を保持しているので解放する前にそれらを掃き出す必要があります。
その時に書き込み例外が起き得るので、解放も安全な処理ではないのです。Javaのtry-with-resource文を使わないファイルの扱いについては悪名高いですが、あれは仕方ない話なのです。&lt;/p&gt;

&lt;p&gt;ところでRustのリソースの解放は&lt;code&gt;Drop&lt;/code&gt;トレイトの&lt;code&gt;drop&lt;/code&gt;が担っていますが、返り値は&lt;code&gt;void&lt;/code&gt;です。基本的には裏で動くので当然ですね。
そして、&lt;code&gt;drop&lt;/code&gt;はpanicを起こさないことが望ましいです。Rustは今のところ(1.5時点)panicから回復出来ないのでそれはそうでしょう。では、エラーを返り値でも返せない、panicも起こせない中&lt;code&gt;BufWrite&lt;/code&gt;はどうエラーを扱っているのでしょう。それは実装を見ると分かります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;W: Write&amp;gt; Drop for BufWriter&amp;lt;W&amp;gt; {
    fn drop(&amp;amp;mut self) {
        if self.inner.is_some() {
            // dtors should not panic, so we ignore a failed flush
            // 訳: dropはパニックすべきではない、だからflushの失敗は無視する
            let _r = self.flush_buf();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…はい。中々アレなことをやってくれますね。&lt;/p&gt;

&lt;p&gt;ということで&lt;code&gt;BufWrite&lt;/code&gt;を使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
  let file = File::create(&amp;quot;some_file.txt&amp;quot;).unwrap();
  let br = BufWrite::new(&amp;amp;file);

  // do something

  match br.flush_buf() {
    Ok(()) =&amp;gt; (),
    Err(e) =&amp;gt; // handle errors
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにライフタイムの終わりで&lt;code&gt;flush_buf&lt;/code&gt;を呼ぶのが作法的な方法です。
&lt;code&gt;unwrap&lt;/code&gt;と同じく掃き出せない時に無視されてもいいならそこまでする必要はありませんが、それでもスコープの終わりに意図的に&lt;code&gt;flush_buf&lt;/code&gt;を呼んでない旨を書くと丁寧でしょう。&lt;/p&gt;

&lt;p&gt;因みにスコープが大きすぎる時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
  let file = File::create(&amp;quot;some_file.txt&amp;quot;).unwrap();
  {
    let br = BufWrite::new(&amp;amp;file);
  
    // do something with br
  
    match br.flush_buf() {
      Ok(()) =&amp;gt; (),
      Err(e) =&amp;gt; // handle errors
    }
  }
  
  // do other things

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにスコープを作って不要なライフタイムを切り詰めるイディオムもあるので併せてどうぞ。&lt;/p&gt;

&lt;p&gt;余談ですが&lt;code&gt;std::fs::File&lt;/code&gt;の実体はCの&lt;code&gt;FILE&lt;/code&gt;構造体ではなくファイルディスクリプタなのでバッファリングはしてません。のでこちらは気にする必要はありません。&lt;/p&gt;

&lt;p&gt;という訳で小ネタでした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのロガーを作る</title>
      <link>/blog/2015/12/26/rustnoroga_wotsukuru</link>
      <pubDate>Sat, 26 Dec 2015 19:18:31 +0900</pubDate>
      
      <guid>/blog/2015/12/26/rustnoroga_wotsukuru</guid>
      <description>&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第1段はRustのロガーを作る話。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar&lt;/a&gt;の&lt;a href=&#34;//KeenS.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru/&#34;&gt;初日&lt;/a&gt;でロガーはfacadと実装に分かれてると書きましたが、実装を作る話ですね。

&lt;a href=&#34;https://doc.rust-lang.org/log/log/index.html&#34;&gt;ドキュメント&lt;/a&gt;を見てもらえば分かる通り、logは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Log: Sync + Send {
    fn enabled(&amp;amp;self, metadata: &amp;amp;LogMetadata) -&amp;gt; bool;
    fn log(&amp;amp;self, record: &amp;amp;LogRecord);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とだけインターフェースが定まっているのでそこを実装してあげれば終わりです。
なぜまたloggerを作ろうとしたのかというと、Rust公式の&lt;a href=&#34;https://crates.io/crates/env_logger/&#34;&gt;env_logger&lt;/a&gt;は標準出力にしか出せず、crates.ioを捜しても（作ろうと思った時点ではパっと見）ファイルに書き出せるものがなさそうだったからです。&lt;/p&gt;

&lt;p&gt;私が作ったのは&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logger&lt;/a&gt;といいます。まだcrates.ioには出してません。TOMLでコンフィグを書けるようになったら出そうかと思うのですがもう既にファイルに書きだせるものが他にありますかね。&lt;/p&gt;

&lt;p&gt;今回作るにあたって目指したのは1つのことにだけ集中する他と組み合わせられるライブラリです。
logはロガーをグローバル変数に代入して使い回してるので同時に1つしかロガーを登録出来ません。そこでロガーアグリケーターのようなものを作ってそれに複数のロガーを登録することが考えられます。
調べきれてませんが恐らく既にいくつか存在するでしょう。アグリゲータの存在を仮定してしまえばアグリゲータに任せれる部分は任せてしまうのが良いでしょう。&lt;/p&gt;

&lt;p&gt;ということで次のことを最初に決めました&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ログフォーマットは柔軟性を持たせる&lt;/li&gt;
&lt;li&gt;ログメッセージの内容に応じて出力を制御出来るフィルターを入れる。(アグリゲータが無差別にログを流し込んで来た時のため)&lt;/li&gt;
&lt;li&gt;複数ファイルへのログはサポートしない。アグリゲータに任せる&lt;/li&gt;
&lt;li&gt;プラグインはサポートしない。アグリゲータに任せる&lt;/li&gt;
&lt;li&gt;ログローテーションはしない。&lt;code&gt;Write&lt;/code&gt;の実装に任せる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一応file loggerですがWriteをすべからく受け取れるので実際はストリームにも使えたりします。今書き出してみたらフォーマッタとかフィルタとかもアグリゲータに任せた方がいいのかなって気がしてきた。
しかし単体での利便性を考えると仕方ない。&lt;/p&gt;

&lt;p&gt;実装は大したことをやっていなくて、精々ログフォーマットを文字列で書けるように（TOMLで設定を書きたいため）フォーマットのパーサを書いた程度でしょうか。&lt;/p&gt;

&lt;p&gt;もう少し考えてからリリースします。あとFile Lotating Writerも一緒に出さなきゃ片手落ちですかね…&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>最近作ってるLispの話</title>
      <link>/blog/2015/12/20/saikintsukutterulispnohanashi</link>
      <pubDate>Sun, 20 Dec 2015 22:40:16 +0900</pubDate>
      
      <guid>/blog/2015/12/20/saikintsukutterulispnohanashi</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lisp&#34;&gt;Lisp Advent Calendar 2015&lt;/a&gt;21日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。最近あまりLispを書いてなくてネタがないので最近作ってるLispの話でもしようかと。&lt;/p&gt;

&lt;p&gt;
&lt;a href=&#34;https://github.com/KeenS/kappaLisp&#34;&gt;κLisp&lt;/a&gt;といいます。まだまだ完成には程遠いです。現在、&lt;a href=&#34;https://github.com/KeenS/kappaLisp/blob/master/src/eval.rs#L378&#34;&gt;ここら辺&lt;/a&gt;くらいの式なら評価出来ます。&lt;/p&gt;

&lt;p&gt;このLispはSKK辞書に使われているS式を評価するために作られました。
SKKは様々な場所に移植されているのでマルチプラットフォームで動いて他の言語と協調が出来る言語で作るのが望ましいのですが、今回はRustを選びました。
最初はCにしようかと思ったのですがちょいとRustを試してみようかと(当時Rustほとんど書いたことがない初心者)。&lt;/p&gt;

&lt;p&gt;SKKに書かれているS式を処理出来るLisp処理系はあるのですがGPLでライセンスされており、それを使ったiOSアプリをAppStoreに登録出来ないという問題があるそうです。
なのでMITライセンスで作り始めました。&lt;/p&gt;

&lt;p&gt;さて、Lisp処理系くらい簡単に作れそうなものですが、いくつかの点で詰まっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;そもそもRustが難しい&lt;/li&gt;
&lt;li&gt;関数ポインタが思うように扱えない&lt;/li&gt;
&lt;li&gt;やろうとした事がborrow checkに引っ掛かって出来なかった&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この詰まった点はRustが悪い訳ではなくて単に私がRustに合わせた設計が出来なかっただけですね。そろそろRustにも少しづつですが慣れて来たのでどこかのタイミングでリファクタリングして進めていきたいですね。&lt;/p&gt;

&lt;p&gt;一応現状でも進めようと思えば進めれるのですが&lt;a href=&#34;https://github.com/KeenS/kappaLisp/blob/master/src/eval.rs#L232&#34;&gt;ここ&lt;/a&gt;のように明らかにイケてないコードが続くので進めるモチベーション起きませんよね。&lt;/p&gt;

&lt;p&gt;設計とかの話をすると、最終的にはC APIでS式の文字列を受け取ったらそれを評価した結果の文字列を返す関数を晒せばいいかな、と思ってます。
ちゃんとiOSへのクロスコンパイルも出来ますしObj-C, Swift双方C FFIがあるのでそれで十分でしょう。(CF &lt;a href=&#34;http://qiita.com/moriturus/items/1190614dcbbe31ecfc2f&#34;&gt;http://qiita.com/moriturus/items/1190614dcbbe31ecfc2f&lt;/a&gt; , &lt;a href=&#34;http://safx-dev.blogspot.jp/2014/06/rustios.html&#34;&gt;http://safx-dev.blogspot.jp/2014/06/rustios.html&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;パーサは手書きで、実行はインタプリタ、Emacs Lispに則ってLisp2のダイナミックスコープです。設計がクソなのでメモリ管理らしいメモリ管理はやってませんがRustのメモリ管理のお陰でメモリリークはしてません。
ちゃんと設計してReference Countなメモリ管理でもしようかと。フットプリントの軽さ大事。&lt;/p&gt;

&lt;p&gt;全然まとまりませんがいつか使えるようになってAquaSKKやFlickSKKに取り込まれるかもしれないのでその時には裏でこのLispが動いてるかもと思い出してあげて下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>travisとappveyorでクロスプラットフォームなCIする話</title>
      <link>/blog/2015/12/20/travistoappveyerdekurosupurattofo_munacisuruhanashi</link>
      <pubDate>Sun, 20 Dec 2015 22:19:21 +0900</pubDate>
      
      <guid>/blog/2015/12/20/travistoappveyerdekurosupurattofo_munacisuruhanashi</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt;20日目の記事です。
日付を覚え間違っていて、締切ギリギリに書いてます。&lt;/p&gt;

&lt;p&gt;κeenです。ものすごい小ネタですがRustでCIする話でも。
&lt;/p&gt;

&lt;p&gt;Rustはクロスプラットフォームな言語なのでLinux, Macそしてあまり聞き慣れませんがWindowsというOSでも動きます。
とは言っても普段の開発環境がLinux、運悪くMacを使わざるを得ない人はMacで開発をしているとそれらでの動作検証は出来るでしょうが他のOSでの動作検証が難しいでしょう。&lt;/p&gt;

&lt;p&gt;そこでCIしましょう。Travis CIはLinuxと、あまり使われていませんがMacでのCI環境を、AppveyorでWindowsというOSでのCI環境を作ります。&lt;/p&gt;

&lt;p&gt;しかしクロスプラットフォームでしかもテスト方法がCargoで統一されているRustではそこまで難しいこともなく、以下の設定をコピペするだけです。&lt;/p&gt;

&lt;p&gt;travis&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: rust
rust:
  - nightly
  - beta
  - stable
os:
  - linux
  - osx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;appveyor&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;branches:
  except:
    - gh-pages

platform:
  - x64
environment:
  RUST_INSTALL_DIR: C:\Rust
  matrix:
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: 1.4.0
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: beta
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: nightly
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: 1.4.0
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: beta
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: nightly

install:
  - ps: Start-FileDownload &amp;quot;https://static.rust-lang.org/dist/rust-${env:RUST_VERSION}-${env:RUST_INSTALL_TRIPLE}.exe&amp;quot;
  - cmd: rust-%RUST_VERSION%-%RUST_INSTALL_TRIPLE%.exe /VERYSILENT /NORESTART /DIR=&amp;quot;%RUST_INSTALL_DIR%&amp;quot;
  - cmd: SET PATH=%PATH%;%RUST_INSTALL_DIR%\bin
  - rustc --version
  - cargo --version

build: false
test_script:
  - cargo build --verbose
  - cargo test --verbose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バッジとかは適当に持ってきましょう。&lt;/p&gt;

&lt;p&gt;サンプルが欲しければ&lt;a href=&#34;https://github.com/Stebalien/tempfile&#34;&gt;Stebalien/tempfile&lt;/a&gt;あたりを参考にしましょう。&lt;/p&gt;

&lt;p&gt;それではHave Happy Hacκings!&lt;/p&gt;

&lt;p&gt;※OS関連の煽りはただのネタです。また「あまり使われていませんがMacでのCI環境を」は「(travisの中では)あまり使われていません(のでもしかしたら使えることを知らない人がいるかもしれません)が」という意味です。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>