<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/rust/</link>
    <description>Recent content in Rust on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 23 Sep 2015 22:43:14 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/rust/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>rust初心者へのガイド</title>
      <link>http://keens.github.io/blog/2015/09/23/rustwokakutokinochiken</link>
      <pubDate>Wed, 23 Sep 2015 22:43:14 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/09/23/rustwokakutokinochiken</guid>
      <description>

&lt;p&gt;シルバーウィークの進捗が芳しくなかったので雑な記事書いてお茶を濁しとく。rustをそれなりに（といっても1000行くらい）書いて溜まった知見をとりあえず出す。rust1.3時点。&lt;/p&gt;

&lt;p&gt;最初の方で熱く語ってるが多くの人にとって欲しい情報は下の方にあると思う。&lt;/p&gt;

&lt;h1 id=&#34;どんな言語:64b642c20ac103c85395c6858549d1b9&#34;&gt;どんな言語&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;から持ってくるとこんな感じ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;zero-cost abstractions

&lt;ul&gt;
&lt;li&gt;C++くらいの性能と思えばいい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;move semantics

&lt;ul&gt;
&lt;li&gt;他にはない難しい概念。しかしこれのおかげで様々な機能を教授出来る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;guaranteed memory safety

&lt;ul&gt;
&lt;li&gt;move semanticsにより安全でない操作はコンパイル時に弾ける。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;threads without data races

&lt;ul&gt;
&lt;li&gt;move semanticsその他により安全でない操作は(ry&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;trait-based generics

&lt;ul&gt;
&lt;li&gt;継承ベースとは違って開いている。型を定義した後に機能を追加出来る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;pattern matching

&lt;ul&gt;
&lt;li&gt;便利だよねー。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;type inference

&lt;ul&gt;
&lt;li&gt;(超)重量級言語ながらタイプ数は少なめ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;minimal runtime

&lt;ul&gt;
&lt;li&gt;move semanticsのお陰でGCがないので本当に小さい。hello, worldが277KBだった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;efficient C bindings

&lt;ul&gt;
&lt;li&gt;ABI的に良い感じなのでブリッジングコストがほぼない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、ここでは足りないことを書いておくと、現在Mozillaで開発されている言語で、LLVMバックエンドのネイティブコンパイル言語。LLVMにトラウマがある人もバイナリ配布されているので気軽に使える。
rustを使った大きなプロジェクトはレンダリングエンジンの&lt;a href=&#34;https://github.com/servo/servo&#34;&gt;Servo&lt;/a&gt;がある。&lt;/p&gt;

&lt;p&gt;レンダリングエンジンに使われているだけあって対応OS/アーキテクチャは広く、iOSやAndroidでも動く。C FFIもC APIもある。&lt;/p&gt;

&lt;p&gt;コミュニティは非常に活発で、インフラやライブラリは一通り揃った感じはする。マイナー言語を見てきた身としては1000ライラリくらい集まると一通りのことは出来るようになるかな、と思っているがrustは若い言語ながら3000ある。増えるペースも速いので欲しいものはまずあると思っていい。&lt;/p&gt;

&lt;p&gt;長らくAPIの破壊的変更をガンガンやる時期があって、1ヶ月前のhello worldが動かないとかもザラだったが2015年5月に1.0が出て以来見違えたように大人しくなって人が増え始めている。APIについてはunstable, stableだとかのラベルを付けるようになったので安心して使える。&lt;/p&gt;

&lt;p&gt;開発フローについてはFirefoxと同じく6週間毎に上流から新しいバージョンが降ってくる。ので今はもう1.3が出ている。1.0から1.3はコンパイル/実行時のパフォーマンス改善が主。新しい機能はPythonのPEPみたいにRFCで管理している。&lt;/p&gt;

&lt;p&gt;所有権や生存期間など新しい概念を導入していてとっつきにくいがこれらの概念のお陰で並列化しても安全だし、何よりメモリ管理を静的に解決出来るのでGCがなくてパフォーマンスが出るわ安定するわStop the Worldがないわで非常に良い言語。個人的にはデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。&lt;/p&gt;

&lt;p&gt;何指向言語かと言われると難しい。安全指向？継承はないがオブジェクト指向といえばそうだし函数型っぽくなくもない。並行を意識して作ってあるから並行指向と言えなくもない。継承を止めたC++のような所有権と副作用を入れたHaskellのような言語。副作用はバリバリ使うのであまり函数型言語として見ない方が幸せになれると思っている。&lt;/p&gt;

&lt;p&gt;traitがどんなものかというとHaskellの型クラスに（多分）同じ。しかもHaskellの&lt;code&gt;deriving Show&lt;/code&gt;みたいに&lt;code&gt;#[derive(Debug)]&lt;/code&gt;とかも書ける。便利。&lt;/p&gt;

&lt;p&gt;生存期間と所有権がどういうものかというと、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let foo = Foo::new(1);
println!(&amp;quot;{:?}&amp;quot;, foo);
let foo = Foo::new(2);
println!(&amp;quot;{:?}&amp;quot;, foo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;foo&lt;/code&gt;を&lt;code&gt;Foo::new(2)&lt;/code&gt;にバインドした時、&lt;code&gt;Foo::new(1)&lt;/code&gt;は所有者が居なくなるのでその時点で開放される。GCと違う点は、GCはその時点ではゴミになるだけで、次にGCが走った時にようやく開放されるが、rustはその場で開放される、&lt;code&gt;free&lt;/code&gt;を自動で挟む。そうなると、コンパイラは最適化で同じサイズを&lt;code&gt;free&lt;/code&gt;してまたアロケートするのを同じ領域を使うようにする筈だ。これで領域の節約とかアロケーションコストの節約の他に、「今使った」メモリを再利用出来るのでキャッシュに載ったままメモリを使える。ここまでの効率化を「自動で」やってくれるのはrustだけではないかと思っている。&lt;/p&gt;

&lt;p&gt;このように素晴しい言語機能があってコミュニティも活発で安定した言語なので流行ればいいなと思っている。とはいっても気軽に書ける言語ではないのであらゆる所で使われる言語とは思っていない。先に言ったようにデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。goがnext Cならrustはnext C++かな、と。&lt;/p&gt;

&lt;p&gt;rustは難しい。学習曲線が急峻だ。しかし手を動かしてその急峻な崖を乗り越えるだけの価値はある言語だと思うので是非試してみて欲しい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、情報セクションだ。&lt;/p&gt;

&lt;h1 id=&#34;ドキュメント:64b642c20ac103c85395c6858549d1b9&#34;&gt;ドキュメント&lt;/h1&gt;

&lt;h2 id=&#34;入門:64b642c20ac103c85395c6858549d1b9&#34;&gt;入門&lt;/h2&gt;

&lt;p&gt;trplと略される&lt;a href=&#34;https://doc.rust-lang.org/stable/book/&#34;&gt;The Rust Programming Language&lt;/a&gt;を読むととりあえず基本的な概念を一通り学習出来る。&lt;/p&gt;

&lt;h2 id=&#34;書き始めた:64b642c20ac103c85395c6858549d1b9&#34;&gt;書き始めた&lt;/h2&gt;

&lt;p&gt;文法とかをサクっと確認したいなら&lt;a href=&#34;https://doc.rust-lang.org/stable/reference.html&#34;&gt;The Rust Reference&lt;/a&gt;がある。&lt;/p&gt;

&lt;p&gt;標準ライブラリを調べたいなら&lt;a href=&#34;https://doc.rust-blang.org/stable/std/&#34;&gt;APIドキュメント&lt;/a&gt;がある。一見分かりづらいが一番上に検索窓があるので全体検索が出来る。&lt;/p&gt;

&lt;p&gt;コード例が欲しいなら&lt;a href=&#34;http://rustbyexample.com/&#34;&gt;Rust by Example&lt;/a&gt;がある。&lt;/p&gt;

&lt;h1 id=&#34;軽く試す:64b642c20ac103c85395c6858549d1b9&#34;&gt;軽く試す&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://play.rust-lang.org/&#34;&gt;Rust Playground&lt;/a&gt;を使えばWeb上で試せる。質問とか投げる時にサンプルコードをここに載せて渡すと捗る。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:64b642c20ac103c85395c6858549d1b9&#34;&gt;開発環境&lt;/h1&gt;

&lt;h2 id=&#34;コンパイラ:64b642c20ac103c85395c6858549d1b9&#34;&gt;コンパイラ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;から簡単にバイナリ落としてこれる。Macだとbrewでも入った気がする。FreeBSDだとpkgで入る。Debianのパッケージも出来たらしい(&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;)がUbuntuにはまだ(&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;)きてない。すぐ来るだろう。&lt;/p&gt;

&lt;p&gt;しかし後述のracerのためにソースが必要なので別途ソースはダウンロードする必要がある。&lt;/p&gt;

&lt;h2 id=&#34;エディタ:64b642c20ac103c85395c6858549d1b9&#34;&gt;エディタ&lt;/h2&gt;

&lt;p&gt;Emacs, Vim, Atomだったら&lt;a href=&#34;https://github.com/phildawes/racer&#34;&gt;racer&lt;/a&gt;を使う。
racerのソースを持ってきてコンパイルしてエディタプラグインをエディタに入れてrustコンパイラのソース持ってきて2行設定書けば使える。ソース補完と定義元ジャンプがある。ちゃんと型を見て補完候補出してくれるし標準ライブラリのソースにもジャンプ出来るので中々便利。&lt;/p&gt;

&lt;p&gt;gofmtのrust版、&lt;a href=&#34;https://github.com/nrc/rustfmt&#34;&gt;rustfmt&lt;/a&gt;は開発版のコンパイラを持ってこないとコンパイル出来ないので私は諦めているが使いたい人は試すといいと思う。少なくともEmacs向けのプラグインはある。&lt;/p&gt;

&lt;h1 id=&#34;ビルドツール:64b642c20ac103c85395c6858549d1b9&#34;&gt;ビルドツール&lt;/h1&gt;

&lt;p&gt;コンパイラと一緒に配布される(FreeBSDのpkgでは別になってる)Cagroがある。雛形作成、依存解決、ビルド、テスト、ベンチマークなどのタスクが出来る。クロスコンパイルとかも。&lt;/p&gt;

&lt;h1 id=&#34;パッケージ管理:64b642c20ac103c85395c6858549d1b9&#34;&gt;パッケージ管理&lt;/h1&gt;

&lt;p&gt;クライアント側はCargo。セントラルレポジトリ的なのは&lt;a href=&#34;https://crates.io/&#34;&gt;crates.io&lt;/a&gt;。crates.ioに登録されてなくてもCargoはgitから取ってくるとかも出来るので野良パッケージも使える。&lt;/p&gt;

&lt;h1 id=&#34;テスト:64b642c20ac103c85395c6858549d1b9&#34;&gt;テスト&lt;/h1&gt;

&lt;p&gt;関数に&lt;code&gt;#[test]&lt;/code&gt;アノテーションを付ければ良い。つまり、ソースとテストを同じファイルに書ける。結構便利。テスト用ビルドでのみコンパイルされて他のビルドだと無視される（と思う。）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn fib(n:isize) -&amp;gt; isize{
    if n &amp;lt; 2 {
       1 
    }
    else {
        fib(n - 1) + fib(n - 2)
    }
}

#[test]
fn test_fib(){
    assert(fib(1) == 1);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;これ便利とかここ躓いたとか。&lt;/p&gt;

&lt;h1 id=&#34;所有権:64b642c20ac103c85395c6858549d1b9&#34;&gt;所有権&lt;/h1&gt;

&lt;p&gt;分かってたけどやっぱり躓いた。局所的には「あ、ここ所有権必要だわ」とか分かるのだが大域的には難しい。&lt;/p&gt;

&lt;p&gt;例えばボトムアップで作っていくと、小さな関数で所有権が必要だがそれを呼び出そうとしたら呼出元が所有権を持っていなくて困るとか。小さな値とか状態を持たない値だったら&lt;code&gt;clone&lt;/code&gt;して渡すのだがそうでなければ手戻りが発生する。この辺は実際に書いて経験を積むしかなさそう。&lt;/p&gt;

&lt;p&gt;因みに代数的データ型と所有権でも困っている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
enum Value {
   Str(String),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とかすると&lt;code&gt;Str&lt;/code&gt;データコンストラクタがStringの所有権を持っているのでパターンマッチで取り出す時に所有権が貰えず、&lt;code&gt;match{Value::Str(ref str) =&amp;gt; ...,}&lt;/code&gt;と、&lt;code&gt;ref&lt;/code&gt;を使って借りるしかない。&lt;/p&gt;

&lt;p&gt;まだ経験が足りないので困ったまま。&lt;/p&gt;

&lt;h1 id=&#34;サイズ:64b642c20ac103c85395c6858549d1b9&#34;&gt;サイズ&lt;/h1&gt;

&lt;p&gt;rustはコンパイル時にメモリ管理を決定するのでコンパイル時にデータのメモリサイズが決まってないといけない。例えば以下のコードはコンパイルが通らない。Bazにおいて、fooのサイズが決定出来ないと言われる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Foo {

}


struct Bar {
}

impl Foo for Bar {

}


struct Baz {
  foo: Foo
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;Foo&lt;/code&gt;はただのインターフェースの定義であって、データを定義してないので実際にFooを実装したデータ型のサイズが分からないからだ(今後変更がある模様。)。次のようにパラメータにすれば解決出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Baz&amp;lt;T&amp;gt; {
  foo: T
}

impl &amp;lt;T:Foo&amp;gt; Baz&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに元の定義とは変わってデータの時点ではTで、implを書く時にFooに絞っているのは不要な所では不要な条件を付けないようにしているからだろうか。
変な値を入れられて困りそうだが、構造体のフィールドを公開しなければ勝手に値が作られることはなく、impl内に書いたコンストラクタを通してのみ値が作られるので心配無用である。&lt;/p&gt;

&lt;h1 id=&#34;t-と-vec-t-str-と-string:64b642c20ac103c85395c6858549d1b9&#34;&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt;と&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;str&lt;/code&gt;と&lt;code&gt;String&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;使い分けは&lt;a href=&#34;http://qiita.com/kondei/items/4a3496786fce0c1a1b43&#34;&gt;Rustの文字列のガイド - Qiita&lt;/a&gt;を見て欲しいが、相互変換で困ることがあったので。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;String&lt;/code&gt;から&lt;code&gt;&amp;amp;str&lt;/code&gt;に変換する時に「&lt;code&gt;as_slice&lt;/code&gt;はunstable」と言われる。こうしてやれば良いようだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let string = &amp;quot;String&amp;quot;.to_string();
let lent_str = &amp;amp;string[..]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vectorも同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let vector = vec![1, 2, 3];
let lent_slice = &amp;amp;vector[..]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hashmap:64b642c20ac103c85395c6858549d1b9&#34;&gt;HashMap&lt;/h1&gt;

&lt;p&gt;所有権周りで困る。例えば次のコードはコンパイルが通らない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;match hash.get(key) {
    Some(v) =&amp;gt; v,
    None =&amp;gt; {hash.insert(key, default); default}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matchの中でhashがborrowされてると判断されるのでNone節でhashにinsert出来ない。&lt;a href=&#34;http://stackoverflow.com/questions/28512394/how-to-lookup-from-and-insert-into-a-hashmap-efficiently&#34;&gt;ワークアラウンド&lt;/a&gt;
もあるが、どう考えてもイケてないので&lt;a href=&#34;http://blog.rust-lang.org/2015/08/14/Next-year.html&#34;&gt;改善される模様&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;データ型と参照:64b642c20ac103c85395c6858549d1b9&#34;&gt;データ型と参照&lt;/h1&gt;

&lt;p&gt;データ型の中で参照を使いづらい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Value {
   Str(&amp;amp;str),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、怒られる。&lt;code&gt;&amp;amp;str&lt;/code&gt;は自分の物ではないので生存期間が分からないからパラメータで受け取らないといけない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct &amp;lt;&#39;a&amp;gt;Value&amp;lt;&#39;a&amp;gt; {
   Str(&amp;amp;&#39;a str),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、やはり所有権を持っていないので次のようなメソッドを定義出来ない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;&#39;a&amp;gt;Value&amp;lt;&#39;a&amp;gt; {
    fn empty_str() -&amp;gt; &amp;lt;&#39;a&amp;gt; {
        Value::Str(&amp;quot;&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…と思ったらなんか出来ちゃった。今まで使い方が悪かったのかも。これはナシ。&lt;/p&gt;

&lt;h1 id=&#34;モナド:64b642c20ac103c85395c6858549d1b9&#34;&gt;モナド&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/TeXitoi/rust-mdo&#34;&gt;mdo&lt;/a&gt;というdo記法っぽく書けるマクロがあるがクロージャを作るとそのクロージャが変数の所有権を持っていって面倒だったのでそんなに良くなかった。optionモナドに関しては素直にmapとandThenを使った方が良い。&lt;/p&gt;

&lt;h1 id=&#34;try:64b642c20ac103c85395c6858549d1b9&#34;&gt;try!&lt;/h1&gt;

&lt;p&gt;rustのコードでは至る所でResult(Either)型が返ってくる。それに対して毎回パターンマッチするのはやってられない。かといって安全でない&lt;code&gt;unwrap()&lt;/code&gt;を各所で使うのも精神衛生に良くない。Errに対してunwrapを使うとpanicになるが、rustにはpanicをハンドルする方法はない。&lt;/p&gt;

&lt;p&gt;そこで&lt;code&gt;try!&lt;/code&gt;。返り値がErrだったらそのままErrで関数から抜け、Okだったらその値を返すマクロ。多分展開結果はこんな形になってる:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = try!(foo());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = match foo() {
   Ok(v) =&amp;gt; v,
   e @ Err(_) =&amp;gt; return e
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;。&lt;/p&gt;

&lt;p&gt;これの逆、成功したらその値で抜け、ErrだったらErrを返して処理を継続するやつとかオプション版とかも欲しい。&lt;/p&gt;

&lt;h1 id=&#34;最後に:64b642c20ac103c85395c6858549d1b9&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;Lisp処理系作ろうとしたけど完成しなかったのでそっとここに置いときますね&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/kappaLisp&#34;&gt;κLisp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustでstructのmutableなfieldあれこれ</title>
      <link>http://keens.github.io/blog/2015/06/14/rustdestructnomutablenafieldarekore</link>
      <pubDate>Sun, 14 Jun 2015 17:53:11 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/14/rustdestructnomutablenafieldarekore</guid>
      <description>

&lt;p&gt;κeenです。人々にRustを薦めておきながら本人は昨日ようやく入門しました。その時に困ったことをメモ。タイトルがルー語になってますが気にしない。&lt;/p&gt;

&lt;p&gt;因みにこれはRust 1.0の情報です。&lt;/p&gt;

&lt;h1 id=&#34;導入:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;導入&lt;/h1&gt;

&lt;p&gt;Rustを知らない人のために説明すると、Rustの値はデフォルトでイミュータブルです。デフォルトで、というのはもちろんミュータブルにすることも出来ます。
標準ライブラリにも値がイミュータブルであることを要求するものもあります。
そしてミュータビリティは&lt;code&gt;mut&lt;/code&gt;として型にも現れます。厳密に同じかは知りませんが&lt;code&gt;const&lt;/code&gt;の逆、と思えばいいでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Point {
    x: isize,
    y: isize
}

fn double(p: &amp;amp;mut Point) {
    p.x = p.x * 2;
    p.y = p.y * 2;
}

fn main(){
    let mut p1 = Point{x: 1, y: 2};
    let p2 = Point{x: 1, y: 2};
    double(&amp;amp;mut p1);
    double(&amp;amp;mut p2); // error! p2 is immutable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イミュータビリティは継承します。親のstructがイミュータブルなら子もイミュータルになります。因みにフィールドに&lt;code&gt;mut&lt;/code&gt;を指定することは出来ないようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::collections::HashMap;

struct IntHashMap {
    hash: HashMap&amp;lt;isize, isize&amp;gt;
}
fn main(){
    let h = IntHashMap{hash: HashMap::new()};
    h.hash.insert(1, 2);        // error! h.hash is immutable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、少し本筋とずれますがtraitについて。他の言語でいうインターフェースのようなものです。今回これで困ったので。&lt;/p&gt;

&lt;p&gt;例えばHTTPライブラリの&lt;a href=&#34;http://hyper.rs/hyper/hyper/server/trait.Handler.html&#34;&gt;hyper&lt;/a&gt;では次のようなトレイトを実装しているstructをrequest handlerとして登録できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Handler: Sync + Send {
    fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;);

    fn check_continue(&amp;amp;self, _: (&amp;amp;Method, &amp;amp;RequestUri, &amp;amp;Headers)) -&amp;gt; StatusCode { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを見て下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self&lt;/code&gt;に&lt;code&gt;mut&lt;/code&gt;がついてませんね。つまりhandlerはイミュータブルな値として渡されます。例えば先の例のようにフィールドにハッシュマップを持っていても更新出来ません。ちょっと困りますね。&lt;/p&gt;

&lt;h1 id=&#34;cell-refcell:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;Cell/RefCell&lt;/h1&gt;

&lt;p&gt;ということでフィールドにミュータビリティを入れるのが &lt;code&gt;std::cell::{Cell, RefCell}&lt;/code&gt; です。この辺のブログを参考に。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://saneyukis.hatenablog.com/entry/2014/05/30/230351&#34;&gt;#rustlang における構造体のmutabilityと&lt;code&gt;Cell/RefCell&lt;/code&gt; - snyk_s log&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;で、喜び勇んで使ったのですが次なるエラーが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyHandler {
    cache: RefCell&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;
}

impl Handler for MyHandler {
    fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;){
        ....
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;the trait `core::marker::Sync` is not implemented for the type `core::cell::UnsafeCell&amp;lt;...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうも、hyperは複数スレッドでも動かせるのでハンドラにスレッドセーフであることが要求されるようです。そしてRustコンパイラはRefCellがスレッドセーフでない事を知っているのでコンパイルを弾きます。怖いですね。&lt;/p&gt;

&lt;h1 id=&#34;mutex:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;Mutex&lt;/h1&gt;

&lt;p&gt;無理っぽいので最早別の手段を捜し始めます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;キャッシュ用のアクター走らせるのが良い気がしてきた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/609471732970209280&#34;&gt;2015, 6月 12&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これはちょっと無理がありそうですね。&lt;/p&gt;

&lt;p&gt;しかし、別の方法があるようでした。&lt;a href=&#34;https://doc.rust-lang.org/std/sync/struct.Mutex.html&#34;&gt;std::sync::Mutex&lt;/a&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyHandler {
    cache: Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで&lt;code&gt;lock().unwrap()&lt;/code&gt;するだけで使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut cache = self.cache.lock().unwrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにロックの解除は不要です。Rustコンパイラは値の生存期間を知っているので値がこれ以上使われなくなった箇所にコンパイラがunlockを挟みます。(正確に言うとdrop(デストラクタ)が挿入され、dropがリソースの開放を行なう)&lt;/p&gt;

&lt;h1 id=&#34;まとめ:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;rustのイミュータビリティは継承する&lt;/li&gt;
&lt;li&gt;structのfieldに直接&lt;code&gt;mut&lt;/code&gt;は指定出来ない&lt;/li&gt;
&lt;li&gt;シングルスレッドでミュータブルなフィールドが欲しいなら&lt;code&gt;Cell&lt;/code&gt;/&lt;code&gt;RefCell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;マルチスレッドなら&lt;code&gt;Mutex&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>静的なメモリ管理の話。リージョン推論とλ計算からRustまで</title>
      <link>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</link>
      <pubDate>Tue, 21 Apr 2015 00:25:56 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 静的なメモリ管理の話。リージョン推論とλ計算からRustまで
----------------------
サイバーエージェント新卒エンジニア勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 大学では非情報系学科。趣味のプログラマ。
   + 非ガチ勢なので優しくして下さい&gt;&lt;
 * Lisp, Ruby, OCaml, Shell Scriptあたりを書きます


# メモリ管理の話
---------------
(一般的ではない用語)

* 弱い静的メモリ管理
* 強い動的メモリ管理
* (弱い動的メモリ管理)
* 強い静的メモリ管理


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 静的 = コンパイル時にメモリ管理が決定する

### 例

* C言語


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 利点

* 実行時は安定している

### 欠点
* バグる
* 面倒
* 危険


# メモリ管理の話
---------------
## 強い動的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* GCのある言語全般

# メモリ管理の話
---------------
## 強い動的メモリ管理
### 利点

* メモリ管理からの開放

### 欠点

* 動作が不安定 (cf [これがCassandra](http://www.slideshare.net/TakehiroTorigaki/cassandra-21191674))
* パフォーマンスの問題
* リアルタイム性の問題


# メモリ管理の話
---------------
## (弱い動的メモリ管理)
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* バグったGC
  + 普通はない
  + (参照カウント？)


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 静的 = コンパイル時にメモリ管理が決定する


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 利点

* メモリ管理からの開放
* 実行時は安定している
* リアルタイム
* パフォーマンスが出る

### 欠点

* 実現可能性は？


# 強い静的メモリ管理の話をしよう


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 強い静的メモリ管理の話をしよう
------------------------------

* まずは可能性の議論が必要
* 実現可能性
* 実用性


# 可能性の議論
-------------

* プログラミング言語の理論 ≒ λ計算
* そもそもλ計算はメモリのことを考慮してない
  + GCがあるかのように記述される


# 可能性の議論
-------------

* λ計算にメモリ管理まで含めて理論を立てたものは存在する（静的なメモリ管理）
  + リージョンというものをベースにしている [参考](http://www.elsman.com/mlkit/pdf/popl94.pdf)
* さらにリージョンを自動で推論する理論もある（強いメモリ管理）
  + リージョン推論という


# 軽くリージョンの話
-------------------

* 型と同じようにプログラム全体を伝わるメタデータ。
* データが保存される場所を指す。リージョンはいくつもある。
* リージョン推論でデータがどのリージョンに入るかが分かる
* さらにリージョンのサイズもある程度予想がつくので静的に管理出来る
* 関数などは引数のリージョンに対して多相になる「リージョン多相」などもある
* この辺は[Martin Elsmanの論文たち](http://www.elsman.com/mlkit/papers.html)を参考にして下さい
  + [A Brief Introduction to Regions](http://www.elsman.com/mlkit/pdf/ismm98.pdf)とか。



# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* 実現可能性
* 実用性

# 実現可能性

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 実現可能性
-----------

* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;Martin ElsmanによるSML処理系、[ML Kitに一部導入された](http://www.elsman.com/mlkit/pdf/pldi2002.pdf)（多分世界初）
  + 但し完全ではなく、GCと組み合わせてある
  + 動的型付き言語に無理矢理静的型を付けても完全には上手くいかないようなもの？
  + 多分リージョン推論を前提とした言語を設計する必要がある
* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;Cyclone というC likeな文法の言語が完全に[リージョン推論のみでメモリ管理を実現した](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf)


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* 実用性


# 実用性


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Rust言語
----------

* Mozillaが開発した言語
* 2008~
* Cycloneを参考にしたらしい。
* 活発に開発される
* 大きなプロジェクトに現行のレンダリングエンジン、Geckoを置き換えるべく開発された[Servo](https://github.com/servo/servo)がある
  + 既にC++製のGockoの3倍速い
  + 並列レンダリングすればさらに速い。


# Rust言語
----------

* リージョン推論(ライフタイム)でメモリを管理する
  - かなり賢くて、ヒープにアロケートする必要なけばスタックを使う。
* mallocとfreeは全てコンパイル時に自動で挿入される
* (多分)リージョン推論のみでメモリ管理するために所有権という概念がある。
  + 所有権自体は並列性の導入などにも有用だと思われる。
    -  競合状態の回避とか
* その他
  + 代数的データ型とパターンマッチ
  + トレイトベース(non-nominal)のジェネリクス

詳細は[公式ページ](http://www.rust-lang.org/)から


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* ✓ 実用性


# Rustのライフタイムと所有権
-------------------------


&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Cの例
-------

```c
{
    int *x = malloc(sizeof(int));

    // we can now do stuff with our handle x
    *x = 5;

    free(x);
}
```


# Rustに翻訳
------------

```rust
{
    let x = Box::new(5);
}
```


# 少しいじってみる
---------------

trivialに見える

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
---------------

printlnを追加してみる

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);

    println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
----------------

エラーになる。

```
error: use of moved value: `x`
   println!(&#34;{}&#34;, x);
                  ^
```


# 所有権
-------

`add_one` を呼んだ時点で所有権が `add_one` に移るので `println!` では使えない。

```rust
fn main() {
  let x = Box::new(5);

  add_one(x);

  println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 所有権
-------
新たに値を返してもらえば使える。

```rust
fn main() {
  let x = Box::new(5);

  let y = add_one(x);

  println!(&#34;{}&#34;, y);
}

fn add_one(mut num: Box&lt;i32&gt;) -&gt; Box&lt;i32&gt; {
  *num += 1;

  num
}
```


# 所有権の貸し借り
---------------

* さっきの例は面倒。
* `add_one` が `x` を奪ったのが問題。
* `x` を「借り」ることが出来る。


# 所有権の貸し借り
----------------

```rust
fn main() {
  let mut x = 5;

  add_one(&amp;mut x);

  println!(&#34;{}&#34;, x);
}

fn add_one(num: &amp;mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

先の `add_one` はライフタイム(リージョン)アノテーションを省略していた。  
省略せずに書くとこうなる。(リージョン多相)

```rust
fn add_one&lt;&#39;a&gt;(num: &amp;&#39;a mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

スコープの終わりでライフタイムが終わる。

```rust
fn main() {
  let y = &amp;5;     // -+ y goes into scope
                  //  |
  // stuff        //  |
                  //  |
}                 // -+ y goes out of scope
```


# LTの明示的宣言
--------------
こんな構造体を宣言したとする。 `x` はコンストラクタに渡された値のライフタイムを引き継ぐ。

```rust
struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}
```


# LTの明示的宣言
--------------
`f.x`のライフタイムが `y` のライフタイムに制限されるので
`y` より広いスコープにある `x` には代入出来ない。

```rust
fn main() {
  let x;                  // -+ x goes into scope
                          //  |
  {                       //  |
    let y = &amp;5;           // ---+ y goes into scope
    let f = Foo { x: y }; // ---+ f goes into scope
    x = &amp;f.x;             //  | | error here
  }                       // ---+ f and y go out of scope
                          //  |
  println!(&#34;{}&#34;, x);      //  |
}                         // -+ x goes out of scope
```


# まとめ
-------

* メモリ管理の性質についてまとめた
* 静的メモリ管理が出来れば
  + メモリ管理からの開放
  + 実行時は安定している
  + リアルタイム
  + パフォーマンスが出る
* 強い静的メモリ管理の手法としてリージョン推論がある
* Rust言語がリージョン推論を利用している。
* Rustをみんな使おう!


# 参考
* [ML Kit](http://www.elsman.com/mlkit/)
* [Rust](http://www.rust-lang.org/)
* [Allocators in Rust - Baby Steps](http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>