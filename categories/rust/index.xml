<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/categories/rust/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/rust/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rustのモジュールの使い方</title>
      <link>/blog/2017/01/15/rustnomoju_runokirikata</link>
      <pubDate>Sun, 15 Jan 2017 20:52:14 +0900</pubDate>
      
      <guid>/blog/2017/01/15/rustnomoju_runokirikata</guid>
      <description>&lt;p&gt;κeenです。たまにRustのモジュールが分かりづらいとの声を聞くので解説しますね。&lt;/p&gt;

&lt;p&gt;
とりあえずサンプルプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new module
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;エラいのは-lib-rs-と-main-rs&#34;&gt;エラいのは &lt;code&gt;lib.rs&lt;/code&gt; と &lt;code&gt;main.rs&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;モジュールの話をする前にクレートの話をしないといけません。
クレートはRustのプログラムの一番大きな単位です。
大きく分けてライブラリを作るlibクレートと実行可能ファイルを作るbinクレートがあります。&lt;/p&gt;

&lt;p&gt;libクレートならば&lt;code&gt;lib.rs&lt;/code&gt;が、binクレートならば&lt;code&gt;main.rs&lt;/code&gt;がルートにあたるファイルです。ここから辿れるモジュールが全てです。プロジェクトにファイルが存在していてもこれらから辿れなかったらコンパイルされません。&lt;/p&gt;

&lt;h1 id=&#34;モジュールの作り方は3種類&#34;&gt;モジュールの作り方は3種類&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;ファイルの中にインラインで作る&lt;/li&gt;
&lt;li&gt;1ファイルで作る&lt;/li&gt;
&lt;li&gt;1ディレクトリで作る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;のやり方があります。 1.はそんなに使われなくて、説明のために1ファイルにまとめたい時や、可視性でアレコレする時のテクニックなんかに使われます。&lt;/p&gt;

&lt;p&gt;2.と3.の境界はサブモジュールを持つかどうかです。&lt;/p&gt;

&lt;p&gt;2.のファイルで作る時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように作っておいて、lib.rsの中を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod new_module;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;mod&lt;/code&gt;で参照してあげれば使えます。&lt;/p&gt;

&lt;p&gt;3.のディレクトリの時もそんなに変わらなくて、&lt;code&gt;lib.rs&lt;/code&gt;は変わらず、ファイルを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module
src/new_module/mod.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにしてあげます。&lt;code&gt;mod.rs&lt;/code&gt;の名前はこれでないといけません。丁度サブモジュールの&lt;code&gt;new_module&lt;/code&gt;にとっての&lt;code&gt;lib.rs&lt;/code&gt;のような存在が&lt;code&gt;mod.rs&lt;/code&gt;な訳です。&lt;/p&gt;

&lt;h1 id=&#34;兄弟モジュール同士の可視性&#34;&gt;兄弟モジュール同士の可視性&lt;/h1&gt;

&lt;h2 id=&#34;モジュールの身分&#34;&gt;モジュールの身分&lt;/h2&gt;

&lt;p&gt;さて、次のように2つのモジュールを作ってみましょう。lib.rsには&lt;code&gt;module_a&lt;/code&gt;のみ&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;module_a.rs&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build
   Compiling module v0.1.0 (file:///home/kim/Rust/module)
error[E0432]: unresolved import `module_a`
 --&amp;gt; src/lib.rs:1:5
  |
1 | use module_a;
  |     ^^^^^^^^ no `module_a` in the root

error: aborting due to previous error

error: Could not compile `module`.

To learn more, run the command again with --verbose.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と怒られます。一番エラいのは&lt;code&gt;lib.rs&lt;/code&gt;ですから、身分の低い &lt;code&gt;module_a&lt;/code&gt;では&lt;code&gt;mod&lt;/code&gt;宣言出来ません。&lt;/p&gt;

&lt;h2 id=&#34;君の名は&#34;&gt;君の名は&lt;/h2&gt;

&lt;p&gt;同じ設定で、&lt;code&gt;lib.rs&lt;/code&gt;に&lt;code&gt;module_a&lt;/code&gt;と&lt;code&gt;module_b&lt;/code&gt;両方を&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時、&lt;code&gt;module_b&lt;/code&gt;が&lt;code&gt;lib.rs&lt;/code&gt;から見た時と&lt;code&gt;module_a.rs&lt;/code&gt;から見た時で名前が変わります。&lt;/p&gt;

&lt;p&gt;lib.rsから見た時は、以下の3つが使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use self::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self&lt;/code&gt;というのは予約語で、ディレクトリでいうところの&lt;code&gt;.&lt;/code&gt;に相当します。&lt;/p&gt;

&lt;p&gt;module_a.rsからは同じく3つが使えますが、相対パスが変わります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;super&lt;/code&gt;も予約語で、&lt;code&gt;..&lt;/code&gt;に相当します。
ファイルが同じディレクトリにいるので分かりづらいですが、libが1つ上の階層で、その下にmodule_aとmodule_bがぶら下がってる感じですね。&lt;/p&gt;

&lt;h1 id=&#34;おじさんと隠し子&#34;&gt;おじさんと隠し子&lt;/h1&gt;

&lt;p&gt;次のように、サブモジュールを作ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$src
src/lib.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この時&lt;code&gt;sumbmodule&lt;/code&gt;から見た&lt;code&gt;module_b&lt;/code&gt;の名前はどうなるでしょうか。もうお分かりかと思いますが、以下の3つです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃ、逆に&lt;code&gt;module_b&lt;/code&gt;から見た&lt;code&gt;submodule&lt;/code&gt;はどうなるでしょうか。実は、&lt;code&gt;module_b&lt;/code&gt;から&lt;code&gt;submodule&lt;/code&gt;は見えません（lib.rsからも見えません）。&lt;code&gt;module_a&lt;/code&gt;1つで所帯を持っているので子である&lt;code&gt;submodule&lt;/code&gt;を外に出すかは&lt;code&gt;module_a&lt;/code&gt;の一存で決まります。今回は隠し子にしている訳ですね。いくら兄弟モジュールとはいえ家庭にまでは入り込めないのです。&lt;/p&gt;

&lt;p&gt;子供をちゃんと公開するには&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていたモジュール宣言を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてあげればOKです。そうすると&lt;code&gt;module_b&lt;/code&gt;からも見えて、以下の3種類で参照出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a::submodule;
use module_a::submodule;
use super::module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;木箱の外から&#34;&gt;木箱の外から&lt;/h1&gt;

&lt;p&gt;さて、今までは1クレート内での話でした。クレートの外から見るとどうなるでしょうか。&lt;/p&gt;

&lt;p&gt;新たに&lt;code&gt;main.rs&lt;/code&gt;を追加しましょう。先程 &lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;がエラいと話しましたが、どちらも別々のクレートを作るので&lt;code&gt;main.rs&lt;/code&gt;は完全にクレートの外です。&lt;/p&gt;

&lt;p&gt;こんな感じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/main.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、外部のクレートを参照するには&lt;code&gt;extern crate&lt;/code&gt;を書く必要があります。あとまあ、binクレートなので&lt;code&gt;main&lt;/code&gt;関数も必要ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.rs
extern carte module;
fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、&lt;code&gt;module_b&lt;/code&gt;はどういう名前で見えるでしょうか。見えません。一番エラい&lt;code&gt;lib.rs&lt;/code&gt;が&lt;code&gt;module_b&lt;/code&gt;を&lt;code&gt;pub&lt;/code&gt;にしていないのでクレートの外からは見えなくなっています。見たければ、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにします。&lt;/p&gt;

&lt;p&gt;さて、これでmain.rsからどのように見えるかというと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module::module_b;
use module::module_b;
use self::module::module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように気持的にルート直下にクレートがモジュールとして配置されたように見えます。&lt;/p&gt;

&lt;h1 id=&#34;家出&#34;&gt;家出&lt;/h1&gt;

&lt;p&gt;さて、同じように&lt;code&gt;lib.rs&lt;/code&gt;で&lt;code&gt;module_a&lt;/code&gt;を&lt;code&gt;pub mod&lt;/code&gt;すれば&lt;code&gt;module::module_a::submodule&lt;/code&gt;も参照出来るようになります。ところで、例えば&lt;code&gt;module_a&lt;/code&gt;は外に出さずに&lt;code&gt;submodule&lt;/code&gt;だけを公開したい時にはどうしたらいいでしょうか。そんなケースあるのかと疑問に思うかもしれませんが、あります。同じクレートであっても&lt;code&gt;pub&lt;/code&gt;にしないとサブモジュールにアクセス出来ないことを思い出して下さい。そうすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub mod submodule;
pub mod internal_submodule_a;
pub mod internal_submodule_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなケースが発生するのは想像出来ると思います。そういう時は、&lt;code&gt;lib.rs&lt;/code&gt;側でどうにかいじれます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていると思いますが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、&lt;code&gt;pub use&lt;/code&gt; を加えてあげることで&lt;code&gt;module_a&lt;/code&gt;の下から出すことが出来ます。&lt;/p&gt;

&lt;p&gt;これを&lt;code&gt;main.rs&lt;/code&gt;から使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように名字の&lt;code&gt;module_a&lt;/code&gt;が取れます。&lt;/p&gt;

&lt;p&gt;さらに踏み込めば、&lt;code&gt;use&lt;/code&gt;は&lt;code&gt;as&lt;/code&gt;を使ってリネーム出来るので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule as module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにリネーム&lt;code&gt;use&lt;/code&gt;してあげれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように参照することも出来ます。完全に籍を外れて名前の上では別人ですね。&lt;/p&gt;

&lt;p&gt;実装する時の都合とAPIとして公開する時の都合が違うので公開用にいじれる作りになってるんですね。&lt;/p&gt;

&lt;h1 id=&#34;lib-rsとmain-rs&#34;&gt;lib.rsとmain.rs&lt;/h1&gt;

&lt;p&gt;上では&lt;code&gt;lib.rs&lt;/code&gt;を使って説明しましたが、&lt;code&gt;main.rs&lt;/code&gt;でも同じことが出来ます。&lt;/p&gt;

&lt;p&gt;さて、ここからはスタイルの話ですが、私がRustを書く時は&lt;code&gt;main.rs&lt;/code&gt;の中に&lt;code&gt;mod&lt;/code&gt;を書くことはないです。必ず&lt;code&gt;lib.rs&lt;/code&gt;を作って、そこでライブラリとしてまとめてから&lt;code&gt;main.rs&lt;/code&gt;で使います。「アプリケーションはアプリケーションを記述するための巨大なDSLとそれを使った小さな実装からなる」という思想ですね。明示的に境界を作ることで自然とAPIを設計出来るのでコードが整理しやすくなります。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;が一番エラい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mod&lt;/code&gt; で「モジュールがある」宣言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub mod&lt;/code&gt; で加えて上位のモジュールにも公開&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt;と&lt;code&gt;super&lt;/code&gt;の予約語&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub use&lt;/code&gt; で改名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;力尽きてテストのためのモジュールの話が出来なかったので&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/testing.html#tests-%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB&#34;&gt;ドキュメント&lt;/a&gt;を読んでみて下さい。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;https://github.com/BurntSushi/fst/blob/master/src/lib.rs&#34;&gt;これ&lt;/a&gt;のようにテクニックが詰まった&lt;code&gt;lib.rs&lt;/code&gt;ファイルなんかも存在するので参考にどうぞ。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>気付いたらRustの環境構築がかなり楽になってた</title>
      <link>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</link>
      <pubDate>Thu, 29 Dec 2016 11:52:55 +0900</pubDate>
      
      <guid>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</guid>
      <description>&lt;p&gt;κeenです。ここのところRustの開発ツール回りでリリースが続いてセットアップが楽になってるようだったので最新の情報をお届けします。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;とりあえず私は既存の環境があるので一旦全て破棄してから再度セットアップしてみます。&lt;/p&gt;

&lt;h1 id=&#34;rustのインストール&#34;&gt;Rustのインストール&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;がリリースされたので以下で一発です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;source $HOME/.cargo/env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をシェルのrcファイルに書き加えたらOKです。
今のシェルにも反映するには同じく上記のコマンドを打ちます。&lt;/p&gt;

&lt;h1 id=&#34;周辺ツールのインストール&#34;&gt;周辺ツールのインストール&lt;/h1&gt;

&lt;p&gt;cargoがあるので楽ですね&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# コードフォーマッタ
$ cargo install rustfmt
# 補完、定義ジャンプなど
$ cargo install racer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあ時間がかかります。&lt;/p&gt;

&lt;h1 id=&#34;エディタ-emacs-の設定&#34;&gt;エディタ(Emacs)の設定&lt;/h1&gt;

&lt;p&gt;私がEmacsを使ってるのでEmacsの設定を。&lt;/p&gt;

&lt;p&gt;まず、必要パッケージをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;rustfmt&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。rust-modeにrustfmtの機能が含まれているようでした。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; rustfmtを emacsから使うの rust-modeが現在サポートしているので, rustfmt.elパッケージは不要ですね. rust-format-on-saveが non-nilなら保存時に rustfmtが実行されます.&lt;/p&gt;&amp;mdash; Syohei YOSHIDA (@syohex) &lt;a href=&#34;https://twitter.com/syohex/status/814354653672415232&#34;&gt;2016年12月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;;;; racerやrustfmt、コンパイラにパスを通す
(add-to-list &#39;exec-path (expand-file-name &amp;quot;~/.cargo/bin/&amp;quot;))
;;; rust-modeでrust-format-on-saveをtにすると自動でrustfmtが走る
(eval-after-load &amp;quot;rust-mode&amp;quot;
  &#39;(setq-default rust-format-on-save t))
;;; rustのファイルを編集するときにracerとflycheckを起動する
(add-hook &#39;rust-mode-hook (lambda ()
                            (racer-mode)
                            (flycheck-rust-setup)))
;;; racerのeldocサポートを使う
(add-hook &#39;racer-mode-hook #&#39;eldoc-mode)
;;; racerの補完サポートを使う
(add-hook &#39;racer-mode-hook (lambda ()
                             (company-mode)
                             ;;; この辺の設定はお好みで
                             (set (make-variable-buffer-local &#39;company-idle-delay) 0.1)
                             (set (make-variable-buffer-local &#39;company-minimum-prefix-length) 0)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とりあえずこれでセットアップ完了です。racerの最新版でrustのソースコードの位置を設定しなくてよくなったので簡潔になりましたね。&lt;/p&gt;

&lt;p&gt;racer-modeは補完をしてくれる他、&lt;code&gt;M-.&lt;/code&gt;で定義元ジャンプ、&lt;code&gt;M-,&lt;/code&gt;でジャンプ元に戻れます。
あとは&lt;code&gt;M-x racer-describe&lt;/code&gt;でポイント位置にあるシンボルのrustdocを(Emacs内で)表示してくれます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;おお! racerでEmacs内でrustdocレンダ出来るようになってる！便利！！&lt;br&gt;&lt;br&gt;Rustdoc Meets The Self-Documenting Editor&lt;a href=&#34;https://t.co/gDEHl2fSfx&#34;&gt;https://t.co/gDEHl2fSfx&lt;/a&gt; &lt;a href=&#34;https://t.co/sdrX9OoEnr&#34;&gt;pic.twitter.com/sdrX9OoEnr&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/770796719185408000&#34;&gt;2016年8月31日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;その他は放っておくと勝手に機能してくれるので考えることが少なくていいですね。&lt;/p&gt;

&lt;h1 id=&#34;その他便利ツール&#34;&gt;その他便利ツール&lt;/h1&gt;

&lt;p&gt;セットアップがあっけなかったのでついでに入れておくと便利なツールをいくつか紹介します。&lt;/p&gt;

&lt;h2 id=&#34;cargo-edit&#34;&gt;cargo-edit&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-edit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「libcクレートの最新版に依存したい」なんて時に一々libcの最新版を確認するのは面倒ですよね。そんなときにcargo-editがあれば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo add libc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で &lt;code&gt;Cargo.toml&lt;/code&gt; に追記してくれます。&lt;/p&gt;

&lt;h2 id=&#34;cargo-script&#34;&gt;cargo-script&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとした実験スクリプトとかをコンパイル→実行のステップを踏まずにいきなり実行出来ます。
&lt;code&gt;cargo script FILE&lt;/code&gt;でファイルを実行出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; hello.rs
fn main() {
    println!(&amp;quot;hello, script&amp;quot;)
}
EOF
$ cargo script hello.rs
   Compiling hello v0.1.0 (file:///home/kim/.cargo/.cargo/script-cache/file-hello-f6b1735a519bb659)
    Finished release [optimized] target(s) in 0.15 secs
hello, script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というふうに使います。&lt;/p&gt;

&lt;p&gt;シェルのrcファイルで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;alias rust=&#39;cargo-script&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としておくと吉。&lt;/p&gt;

&lt;h2 id=&#34;cargo-update&#34;&gt;cargo-update&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までインストールしたバイナリのアップデートを出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install-update -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのライフタイムを使ったスコープ解析</title>
      <link>/blog/2016/12/24/rustnoraifutaimuwotsukattasuko_pukaiseki</link>
      <pubDate>Sat, 24 Dec 2016 22:51:46 +0900</pubDate>
      
      <guid>/blog/2016/12/24/rustnoraifutaimuwotsukattasuko_pukaiseki</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;の25日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。大トリに小ネタで申し訳ないのですが最近書いたコードでちょっと便利だなと思ったテクニックを紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;次のような言語のインタプリタを作ることを考えます。意味論はエスパーして下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 1
y = 2
println(&amp;quot;x = &amp;quot;, x)
println(&amp;quot;y = &amp;quot;, y)

println(&amp;quot;--&amp;quot;)

{
    x = 3
    println(&amp;quot;x = &amp;quot;, x)
    println(&amp;quot;y = &amp;quot;, y)
}

println(&amp;quot;--&amp;quot;)

println(&amp;quot;x = &amp;quot;, x)
println(&amp;quot;y = &amp;quot;, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この実行結果は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になりますね。このインタプリタをRustで作りましょう。&lt;/p&gt;

&lt;h1 id=&#34;初期実装&#34;&gt;初期実装&lt;/h1&gt;

&lt;p&gt;雛形はこんなもんでしょうか。後でリファレンスが出てきてややこしくなるので値は全て所有権を貰っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Debug, Clone)]
struct AST(Vec&amp;lt;Stmt&amp;gt;);

#[derive(Debug, Clone)]
enum Stmt {
    Subst(String, Expr),
    Print(Vec&amp;lt;Expr&amp;gt;),
    Block(Vec&amp;lt;Stmt&amp;gt;),
}


#[derive(Debug, Clone)]
enum Expr {
    Str(String),
    Num(isize),
    Var(String),
}


struct Interpreter {
    // これを実装する
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{}
    }

    fn run(&amp;amp;mut self, ast: AST) {
        for stmt in ast.0 {
            self.run_stmt(stmt);
        }
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        // これを実装する
    }
}

fn main() {
    let ast = {
        use Stmt::*;
        use Expr::*;
        AST(
            vec![
                Subst(&amp;quot;x&amp;quot;.to_string(), Num(1)),
                Subst(&amp;quot;y&amp;quot;.to_string(), Num(2)),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Block(vec![
                    Subst(&amp;quot;x&amp;quot;.to_string(), Num(3)),
                    Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                    Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                ]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
            ]
        )
    };
    let mut interpreter = Interpreter::new();

    interpreter.run(ast);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(コンストラクタ関数作っときゃよかったかも)&lt;/p&gt;

&lt;p&gt;今回の本質ではないのでパーサは用意してません。&lt;/p&gt;

&lt;p&gt;さて、とりあえずのところ変数の管理のためにシンボルテーブルが必要です。実装しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;//...

use std::collections::HashMap;
struct Interpreter {
    symbol_table: HashMap&amp;lt;String, Expr&amp;gt;,
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{
            symbol_table: HashMap::new(),
        }
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        self.symbol_table.insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        self.symbol_table
            .get(name)
            .expect(&amp;quot;reference to unknown variable&amp;quot;)
            .clone()
    }

  //...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡略化のためにcloneやpanicしてますがご愛嬌。&lt;/p&gt;

&lt;p&gt;これがあれば&lt;code&gt;run_stmt&lt;/code&gt;のそれっぽい実装は出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            Subst(name, expr) =&amp;gt; {
                let expr = self.eval(expr);
                self.add_to_scope(name, expr);
            },
            Print(exprs) =&amp;gt; {
                for expr in exprs {
                    self.print_expr(expr);
                }
                println!(&amp;quot;&amp;quot;);
            },
            Block(stmts) =&amp;gt; {
                for stmt in stmts {
                    self.run_stmt(stmt);
                }
            },
        }

    }

    fn eval(&amp;amp;self, expr: Expr) -&amp;gt; Expr {
        use Expr::*;
        match expr {
            Var(v) =&amp;gt; self.find_scope(&amp;amp;v),
            e @ Str(_) |
            e @ Num(_) =&amp;gt; e
        }
    }

    fn print_expr(&amp;amp;self, expr: Expr) {
        use Expr::*;
        match self.eval(expr) {
            Str(ref s) =&amp;gt; print!(&amp;quot;{}&amp;quot;, s),
            Num(ref n) =&amp;gt; print!(&amp;quot;{}&amp;quot;, n),
            Var(_) =&amp;gt; panic!(&amp;quot;reference to unknown variable&amp;quot;) ,
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、これを走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 3
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコープを実装していないので最後の&lt;code&gt;x&lt;/code&gt;が3になっていますね。スコープを実装しましょう。&lt;/p&gt;

&lt;p&gt;スコープを実装するには簡単にはハッシュテーブルを複数持てば良さそうです。
3段にネストしたスコープなら3つのハッシュテーブルを持ちます。
そしてスコープを抜けた時にそのスコープに対応するハッシュテーブルを消せば（忘れれば）良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Interpreter {
   // スコープに対応したテーブル達。
   symbol_tables: Vec&amp;lt;HashMap&amp;lt;String, Expr&amp;gt;&amp;gt;,
   // 今どのスコープを指しているか。
   // スコープを抜けてもベクトルは縮まないのでこれが必要。
   pos: usize,
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        // 新しいフィールドの初期化
        Interpreter{
            symbol_tables: Vec::new(),
            // ややこしくなるが、0で初期化しているのでpos-1番目のハッシュマップが現スコープのテーブルになる
            pos: 0,
        }
    }

    // スコープに入る処理。
    fn in_scope(&amp;amp;mut self) {
        let pos = self.pos;
        // スコープから抜けてもハッシュマップは消えないので
        // 入る → 出る → 入るをしたときに既にテーブルがある場合が出てくる。
        // 必要なテーブルが既にある場合とない場合で条件分岐
        if self.symbol_tables.len() &amp;lt;= pos {
            self.symbol_tables.push(HashMap::new())
        } else {
            // 既にテーブルがある場合は古い情報を消す
            self.symbol_tables[pos - 1].clear()
        }
        // ポジションは忘れずインクリメント
        self.pos += 1;
    }

    // スコープから抜ける処理
    fn out_scope(&amp;amp;mut self) {
        // スコープから抜けるのはデクリメントのみでOK
        self.pos -= 1;
    }

    pub fn run(&amp;amp;mut self, ast: AST) {
        // in_scope が増えた
        self.in_scope();
        for stmt in ast.0 {
            self.run_stmt(stmt);
        }
        // out_scope が増えた
        self.out_scope();
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        // 現在のスコープに変数を入れる
        let pos = self.pos - 1;
        self.symbol_tables[pos].insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        let pos = self.pos;
        // 一番内側(現在)のスコープから外側のスコープの順に調べていく。
        // `[0..pos]` や `rev()` に注意。
        for table in self.symbol_tables[0..pos].iter().rev() {
            if let Some(e) = table.get(name) {
                return e.clone()
            }
        }
        // どこにもなければ未定義変数
        panic!(&amp;quot;reference to unknown variable&amp;quot;)
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            // ..
            Block(stmts) =&amp;gt; {
                // in_scope が増えた
                self.in_scope();
                for stmt in stmts {
                    self.run_stmt(stmt);
                }
                // out_scope が増えた
                self.out_scope();
            },
        }

    }

    // ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで走らせてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。動きました。&lt;/p&gt;

&lt;h1 id=&#34;scope-の導入&#34;&gt;&lt;code&gt;Scope&lt;/code&gt; の導入&lt;/h1&gt;

&lt;p&gt;さて、上のコードでは&lt;code&gt;in_scope&lt;/code&gt;と&lt;code&gt;out_scope&lt;/code&gt;が対で現れました。というか現れないといけません。
でもプログラミングエラーで&lt;code&gt;out_scope&lt;/code&gt;を忘れるなんてことはよくある話です（現に私はこのサンプルを書いてて間違えかけました）。これをRustのライフタイムの仕組みに乗っけて自動で解決しようというのが今回のお話。&lt;/p&gt;

&lt;p&gt;手法は簡単で、とりあえず&lt;code&gt;Scope&lt;/code&gt;という型を用意します。そして&lt;code&gt;new&lt;/code&gt;する時に&lt;code&gt;in_scope&lt;/code&gt;を呼んであげて、&lt;code&gt;drop&lt;/code&gt;する時に&lt;code&gt;out_scope&lt;/code&gt;を呼んであげます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::Drop;
struct Scope&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a mut Interpreter);

impl &amp;lt;&#39;a&amp;gt;Scope&amp;lt;&#39;a&amp;gt; {
    fn new(inpr: &amp;amp;&#39;a mut Interpreter) -&amp;gt; Self {
        inpr.in_scope();
        Scope(inpr)
    }
}

impl &amp;lt;&#39;a&amp;gt;Drop for Scope&amp;lt;&#39;a&amp;gt; {
    fn drop(&amp;amp;mut self) {
        self.0.out_scope()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この&lt;code&gt;&amp;amp;mut Interpreter&lt;/code&gt;で参照しているというのが丁度良くて、Scopeの分岐というのを防ぐことが出来ます。こういうやつですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let scope1 = Scope::new(&amp;amp;mut intr);
let scope2 = Scope::new(&amp;amp;mut intr); // error: 既に&amp;amp;mut されている変数は&amp;amp;mut出来ない
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、これを使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    pub fn run(&amp;amp;mut self, ast: AST) {
        // in_scopeをScope::new()に置き換えた
        let scope = Scope::new(self);
        for stmt in ast.0 {
            // scopeに渡してしまったのでselfはsope.0で参照する必要がある
            scope.0.run_stmt(stmt);
        }
        // out_scopeは自動で呼ばれる
    }

    // run_stmtのBlockも同様に書き換える
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きました。でも、あまり&lt;code&gt;scope.0&lt;/code&gt;なんて使いたくないですよね。出来れば透過的に扱いたい。
そんなときのために&lt;code&gt;Deref&lt;/code&gt; と &lt;code&gt;DerefMut&lt;/code&gt; です。Rustは型が合わなければ自動で&lt;code&gt;deref&lt;/code&gt;を呼んでくれます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Deref&lt;/code&gt; と &lt;code&gt;DerefMut&lt;/code&gt; を実装しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::{Deref, DerefMut};
impl &amp;lt;&#39;a&amp;gt; Deref for Scope&amp;lt;&#39;a&amp;gt; {
    type Target = Interpreter;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Interpreter {
        self.0
    }
}

impl &amp;lt;&#39;a&amp;gt; DerefMut for Scope&amp;lt;&#39;a&amp;gt; {
    fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Interpreter {
        self.0
    }
}

impl Interpreter {
    // ..

    pub fn run(&amp;amp;mut self, ast: AST) {
        // deref_mutするために mutをつける
        let mut scope = Scope::new(self);
        for stmt in ast.0 {
            // scope.0しなくてもInterpreterのメソッドが呼べる
            scope.run_stmt(stmt);
        }
    }

   // ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;生成と消滅が対になるものはRustのオブジェクトで管理出来るよ&lt;/li&gt;
&lt;li&gt;シンプルなラッパー型は&lt;code&gt;Deref&lt;/code&gt;や&lt;code&gt;DerefMut&lt;/code&gt;を実装しておくと便利だよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/drop.html&#34;&gt;Drop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/deref-coercions.html&#34;&gt;&lt;code&gt;Deref&lt;/code&gt; による型強制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;付録a&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;最終的なソースコード全文を掲載します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Debug, Clone)]
struct AST(Vec&amp;lt;Stmt&amp;gt;);

#[derive(Debug, Clone)]
enum Stmt {
    Subst(String, Expr),
    Print(Vec&amp;lt;Expr&amp;gt;),
    Block(Vec&amp;lt;Stmt&amp;gt;),
}


#[derive(Debug, Clone)]
enum Expr {
    Str(String),
    Num(isize),
    Var(String),
}


use std::collections::HashMap;
struct Interpreter {
   symbol_tables: Vec&amp;lt;HashMap&amp;lt;String, Expr&amp;gt;&amp;gt;,
   pos: usize,
}

use std::ops::{Drop, Deref, DerefMut};
struct Scope&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a mut Interpreter);

impl &amp;lt;&#39;a&amp;gt;Scope&amp;lt;&#39;a&amp;gt; {
    fn new(inpr: &amp;amp;&#39;a mut Interpreter) -&amp;gt; Self {
        inpr.in_scope();
        Scope(inpr)
    }
}

impl &amp;lt;&#39;a&amp;gt;Drop for Scope&amp;lt;&#39;a&amp;gt; {
    fn drop(&amp;amp;mut self) {
        self.0.out_scope()
    }
}

impl &amp;lt;&#39;a&amp;gt; Deref for Scope&amp;lt;&#39;a&amp;gt; {
    type Target = Interpreter;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Interpreter {
        self.0
    }
}

impl &amp;lt;&#39;a&amp;gt; DerefMut for Scope&amp;lt;&#39;a&amp;gt; {
    fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Interpreter {
        self.0
    }
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{
            symbol_tables: Vec::new(),
            pos: 0,
        }
    }

    fn in_scope(&amp;amp;mut self) {
        let pos = self.pos;
        if self.symbol_tables.len() &amp;lt;= pos {
            self.symbol_tables.push(HashMap::new())
        } else {
            self.symbol_tables[pos - 1].clear()
        }
        self.pos += 1;
    }

    fn out_scope(&amp;amp;mut self) {
        self.pos -= 1;
    }

    pub fn run(&amp;amp;mut self, ast: AST) {
        let mut scope = Scope::new(self);
        for stmt in ast.0 {
            scope.run_stmt(stmt);
        }
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        let pos = self.pos - 1;
        self.symbol_tables[pos].insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        let pos = self.pos;
        for table in self.symbol_tables[0..pos].iter().rev() {
            if let Some(e) = table.get(name) {
                return e.clone()
            }
        }
        panic!(&amp;quot;reference to unknown variable&amp;quot;)
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            Subst(name, expr) =&amp;gt; {
                let expr = self.eval(expr);
                self.add_to_scope(name, expr);
            },
            Print(exprs) =&amp;gt; {
                for expr in exprs {
                    self.print_expr(expr);
                }
                println!(&amp;quot;&amp;quot;);
            },
            Block(stmts) =&amp;gt; {
                let scope = Scope::new(self);

                for stmt in stmts {
                    scope.0.run_stmt(stmt);
                }
            },
        }

    }

    fn eval(&amp;amp;self, expr: Expr) -&amp;gt; Expr {
        use Expr::*;
        match expr {
            Var(v) =&amp;gt; self.find_scope(&amp;amp;v),
            e @ Str(_) |
            e @ Num(_) =&amp;gt; e
        }
    }

    fn print_expr(&amp;amp;self, expr: Expr) {
        use Expr::*;
        match self.eval(expr) {
            Str(ref s) =&amp;gt; print!(&amp;quot;{}&amp;quot;, s),
            Num(ref n) =&amp;gt; print!(&amp;quot;{}&amp;quot;, n),
            Var(_) =&amp;gt; panic!(&amp;quot;reference to unknown variable&amp;quot;) ,
        }
    }
}

fn main() {
    let ast = {
        use Stmt::*;
        use Expr::*;
        AST(
            vec![
                Subst(&amp;quot;x&amp;quot;.to_string(), Num(1)),
                Subst(&amp;quot;y&amp;quot;.to_string(), Num(2)),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Block(vec![
                    Subst(&amp;quot;x&amp;quot;.to_string(), Num(3)),
                    Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                    Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                ]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
            ]
        )
    };
    let mut interpreter = Interpreter::new();

    interpreter.run(ast);
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Rustの所有権、ライフタイム、参照、型、しがらみ</title>
      <link>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</link>
      <pubDate>Wed, 14 Dec 2016 11:19:12 +0900</pubDate>
      
      <guid>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</guid>
      <description>&lt;p&gt;κeenです。Rustには所有権やらライフタイムやら参照やらがあって型システムが面倒ですよね。線形（アフィン）と言われてるのに「あれ？」と思う部分もあるので詳しく探っていこうと思います。&lt;/p&gt;

&lt;p&gt;尚、この記事は型システムに興味のある人向けです。単にRustを書きたい方に有用な情報があるかは分かりません。&lt;/p&gt;

&lt;p&gt;2016-212-14T15:28Z09:00 加筆訂正しました。diffは&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/commit/f86c03a3793fde1787a9c0eb47f8efda305c2be4&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;線形型-アフィン型&#34;&gt;線形型？アフィン型？&lt;/h1&gt;

&lt;p&gt;はじめにこの辺をハッキりさせておきたいです。
アフィン型は線形型に弱化規則を許す型です。
プログラミング的に言えば線形型は &lt;code&gt;free&lt;/code&gt; しないと型エラーになるけどアフィン型はそうでない。
Rustはご存知の通り &lt;code&gt;free&lt;/code&gt; 相当のものを手で書くことはないのでアフィンな気がしますし、昔のドキュメントにもそう書いてました。&lt;/p&gt;

&lt;p&gt;しかし実際に実行されるプログラムではコンパイラが差し込んだ &lt;code&gt;free&lt;/code&gt; が実行されるので &lt;code&gt;free&lt;/code&gt; を省略出来るというシンタックスシュガーの類な気もします。&lt;/p&gt;

&lt;p&gt;ただまあ、 &lt;code&gt;free&lt;/code&gt; を差し込む位置を特定するのに弱化規則を使った場所で推論している筈なのでアフィンを使ってる筈ですよね。&lt;/p&gt;

&lt;p&gt;ってことで今回の記事はアフィン型で統一したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;参照も値&#34;&gt;参照も値&lt;/h1&gt;

&lt;p&gt;なんとなく、構文が用意されているので参照自体特別な存在な気がしますが、そんなことはありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_any&amp;lt;T&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように任意の値を取れる関数を用意してあげます。
すると、以下のように所有、参照、可変参照全て渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let mut s = take_any(s);
take_any(&amp;amp;s);
take_any(&amp;amp;mut s);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;は-copy-mut-は違う&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; は違う&lt;/h1&gt;

&lt;p&gt;先と同じように &lt;code&gt;Copy&lt;/code&gt; を実装した型を受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_copy&amp;lt;T: Copy&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに参照を渡してあげると、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
take_copy(&amp;amp;s);
take_copy(&amp;amp;mut s); // error[E0277]: the trait bound `&amp;amp;mut std::string::String: std::marker::Copy` is not satisfied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、 &lt;code&gt;Copy&lt;/code&gt; なので普通に何度も使えます。線形型でいう &lt;code&gt;!&lt;/code&gt; に近いですね。違いますけど。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let ref_s = &amp;amp;s;
let x: &amp;amp;String = ref_s;
let y: &amp;amp;String = ref_s;
// Copy(が要求するClone)に実装されているメソッドを陽に呼ぶ
let z: &amp;amp;String = (&amp;amp;ref_s).clone();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、 &lt;code&gt;Copy&lt;/code&gt; への参照は参照外しが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x: isize = 1;
let ref_x = &amp;amp;x;
let x: isize = *x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; は &lt;code&gt;&amp;amp;&lt;/code&gt; への参照（&lt;code&gt;Copy&lt;/code&gt;への参照）なので &lt;code&gt;&amp;amp;&lt;/code&gt; へ参照外しが可能ですが、 &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; は&lt;code&gt;&amp;amp;mut&lt;/code&gt;への参照（&lt;code&gt;Copy&lt;/code&gt;ではない値への参照）なので参照外し出来ません。&lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; とややこしいですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
// &amp;amp;&amp;amp;
{
    let ref_ref_s = &amp;amp;&amp;amp;s;
    let ref_s: &amp;amp;String = *ref_refs;
}
// &amp;amp;mut &amp;amp;
{
    let refmut_ref_s = &amp;amp;mut &amp;amp; s;
    let reft_s: &amp;amp;String = *s;
}

// &amp;amp;&amp;amp;mut
{
    let ref_refmut_s = &amp;amp;&amp;amp;mut s;
    let refmut_s: &amp;amp;mut String = *s; // error[E0389]: cannot borrow data mutably in a `&amp;amp;` reference
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;T&lt;/code&gt; が &lt;code&gt;&amp;amp;T&lt;/code&gt; に参照外し出来る理由も分かったかと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-は-deref&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; は &lt;code&gt;Deref&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がたまに &lt;code&gt;&amp;amp;&lt;/code&gt; のように振る舞うことがありますが、これは &lt;code&gt;Deref&lt;/code&gt; のせいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::Deref;

let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
{
    // derefを陽に呼ぶ
    let ref_s: &amp;amp;string = refmut_s.deref();
}

{
    // 暗黙のDerefによる型強制
    let ref_s: &amp;amp;string = refmut_s;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rustは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/deref-coercions.html&#34;&gt;&lt;code&gt;deref&lt;/code&gt; による型強制&lt;/a&gt;を行うため、無言で &lt;code&gt;&amp;amp;mut&lt;/code&gt; を &lt;code&gt;&amp;amp;&lt;/code&gt; に変換することが出来ます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、ここまでで &lt;code&gt;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&lt;/code&gt; もただの値であること、アフィン型に反しないことを調べました。
次はライフタイムについて探ります。&lt;/p&gt;

&lt;h1 id=&#34;ライフタイムとサブタイピング&#34;&gt;ライフタイムとサブタイピング&lt;/h1&gt;

&lt;p&gt;実は、Rustにはサブタイピングがあります。ライフタイムです。ライフタイムにはサブタイプ関係があるのです。&lt;/p&gt;

&lt;p&gt;このように、2つの引数が厳密に同じライフタイムであることを要求する関数を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_ref&amp;lt;&#39;a&amp;gt;(_: &amp;amp;&#39;a String, _: &amp;amp;&#39;a String) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに、違うライフタイムを持つ型を放り込んでみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
    let a = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;a;
    {
        let b = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;b;
        take_two_ref(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはコンパイルが通ります。明示的にライフタイムを書くとこうです。これは有効な構文ではないです（余談ですがラベル付きbreak文のための構文と衝突します）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {
    let a: &#39;a String = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;&#39;a a;
    &#39;b: {
        let b: &#39;b String = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;&#39;b b;
        take_two_ref::&amp;lt;&#39;b&amp;gt;(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大は小を兼ねるので &lt;code&gt;&#39;a&lt;/code&gt; は &lt;code&gt;&#39;b&lt;/code&gt; のサブタイプになっています。
ちょっと言葉がややこしいのですが、スコープが狭いライフタイムの方が大きい型です。狭い方が大きい。この言い回しに馴れてない人に説明すると、上の例でいえば &lt;code&gt;&#39;b&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; と &lt;code&gt;&#39;b&lt;/code&gt; 2つありますが、 &lt;code&gt;&#39;a&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; だけです。 2つと1つだったら2つの方が大きいですよね。&lt;/p&gt;

&lt;p&gt;さて、今回の例ではちゃんとスコープの入れ子とサブタイプ関係が一致していました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {----------
              |
              |
    &#39;b: {--   |
          |   |
          |   |
          |   |
    }------   |
}--------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参照を取るときは参照のライフタイムが元のライフタイムのサブタイプになっている必要があります。&lt;/p&gt;

&lt;p&gt;この関係に反するとエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();
    ref_s = &amp;amp;s; // error: `s` does not live long enough
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;図示するとこうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();-----
    ref_s = &amp;amp;s; ----------------  |
                               |  |
}------------------------------+---
                               |
--------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ライフタイムといえどある種、型なんですね。余談ですが確かリージョンの論文には「リージョンはプログラム全体を静的に伝播する型のようなもの」と表現していた気がします。既存の型と直行するので型とは別とも言えますし、タプルのように両方並べたものを型と言うことも出来ますね。&lt;/p&gt;

&lt;h1 id=&#34;所有型とライフタイムと-static&#34;&gt;所有型とライフタイムと &lt;code&gt;&#39;static&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;適切な語彙がなかったので勝手に所有型と名付けましたが、参照でない型のことを指しています。（先の例で見せた通り、参照型にも所有権はあるので適切ではないですがひとまず我慢して下さい。）&lt;/p&gt;

&lt;p&gt;さて、なんとなくライフタイムと参照型は結び付いている気がしますが、参照じゃない型にもライフタイムはあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_value&amp;lt;&#39;a, T: &#39;a, S: &#39;a&amp;gt;(_: T, _: S){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、任意の2つの型を取るけども両方ともにライフタイムを要求する関数を書いてみます。&lt;/p&gt;

&lt;p&gt;これに、所有型を渡すことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let t = &amp;quot;t&amp;quot;.to_string();
{
    let s = &amp;quot;s&amp;quot;.to_string();
    let s_ref = &amp;amp;s;
    take_two_value(t, s_ref);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、所有型にもライフタイムはあります（多分）。&lt;/p&gt;

&lt;p&gt;ところで、ライフタイムのボトム型相当のものに &lt;code&gt;&#39;static&lt;/code&gt; というものがあります。
グローバル変数やリテラルなどに割り当てられるライフタイムで、プログラムが死ぬまで生き続けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&#39;static&lt;/code&gt; のみを受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_static&amp;lt;T: &#39;static&amp;gt;(_: T){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、先の例に出たstaticな値達を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar;
    take_static(foo);
    take_static(x);
    take_static(ref_bar);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これに所有型を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、任意の参照型は渡せません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(&amp;amp;s); // error: `s` does not live long enough
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで所有型には &lt;code&gt;&#39;static&lt;/code&gt; というライフタイムが付いているようです（？）。
&lt;code&gt;&#39;static&lt;/code&gt; イメージとしては「自分がその値を保持している限り無効になることはない型」ですかね。&lt;/p&gt;

&lt;p&gt;これに関連するTipsとして関数や構造体のジェネリクスで所有型しか受け取らないようにするには &lt;code&gt;&amp;lt;T: &#39;static&amp;gt;&lt;/code&gt; が使えます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さてさて、これまた参照型は特別扱いされることなく他のRustの値と同じようにライフタイムで管理されていることを調べました。&lt;/p&gt;

&lt;p&gt;最後に今回到達出来なかった謎、「参照を取る」について考えたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-の規則&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; の規則&lt;/h1&gt;

&lt;p&gt;みなさん御存じの通り、&lt;code&gt;&amp;amp;mut&lt;/code&gt; を取ると値への他の操作が許されなくなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
let t = s;  // error[E0505]: cannot move out of `s` because it is borrowed
let ref_s = &amp;amp;s; // error[E0502]: cannot borrow `s` as immutable because it is also borrowed as mutable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;mut T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; が相互排他的なのでこれは線形論理のシーケント計算っぽく書くと以下のような規則を考えれば良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Γ, T:&#39;a |- Σ
-------------- &amp;amp;mut-intro
Γ, (&amp;amp;&#39;a mut T): &#39;b |- Σ
where &#39;a &amp;lt;: &#39;b

Γ, (&amp;amp;&#39;a mut T):&#39;b |- (&amp;amp;&#39;a mut T): &#39;b, Σ
----------------------- &amp;amp;mut-elim
Γ, T: &#39;a |- Σ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型付け規則の書き方になれてないのでシーケント計算で書きましたがサブタイプの記述で困りましたね。&lt;/p&gt;

&lt;h1 id=&#34;の謎&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; の謎&lt;/h1&gt;

&lt;p&gt;さて、問題は &lt;code&gt;&amp;amp;&lt;/code&gt; です。 &lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; なのでそこら中に生えてきます。
なので &lt;code&gt;&amp;amp;-elim&lt;/code&gt; のような規則では対応出来ません。&lt;/p&gt;

&lt;p&gt;ただ、ライフタイムによる制約があるので「参照のライフタイムが死ぬときに元の値が復活する」ような規則を考えたくなります。&lt;/p&gt;

&lt;p&gt;しかし、それでもだめです。複数回 &lt;code&gt;&amp;amp;&lt;/code&gt; を取れてしまうので、以下のように複数のライフタイムを持つ場合で破綻します。&lt;code&gt;&amp;amp; T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; の間でなにかしらのしがらみがある筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
{
    let ref_s1 = &amp;amp;s;
    {
        let ref_s2 = &amp;amp;s;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それに、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; と &lt;code&gt;&amp;amp;&lt;/code&gt; が相互排他であることも説明出来る規則でないといけません。謎が多い。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;さて、Rustの型システムのリソース管理回りを探ってみました。とりあえず分かったことを纏めると&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;値には全てアフィン型が付く

&lt;ul&gt;
&lt;li&gt;参照型も例外ではない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;値には全てライフタイムが付く

&lt;ul&gt;
&lt;li&gt;所有型も例外ではないっぽい&lt;/li&gt;
&lt;li&gt;もしかしたら所有型はライフタイムを無視している？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「参照を取る」のセマンティクスが謎

&lt;ul&gt;
&lt;li&gt;勿論、直感的には分かる&lt;/li&gt;
&lt;li&gt;どういう規則なんだろう&lt;/li&gt;
&lt;li&gt;アフィン型とライフタイム両方が絡むはず。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特に論文も読んでないのでちょっと遠回りだったかもしれません。
もしかしたら論文漁ったら一発で解決するのかも。
詳しい方、 &lt;code&gt;&amp;amp;&lt;/code&gt; の謎を教えて下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのstructとtraitって似てるよね</title>
      <link>/blog/2016/12/03/rustnostructtotraittteniteruyone</link>
      <pubDate>Sat, 03 Dec 2016 22:06:18 +0900</pubDate>
      
      <guid>/blog/2016/12/03/rustnostructtotraittteniteruyone</guid>
      <description>&lt;p&gt;κeenです。関連型について考えてたらtraitがstructに見えてきたので一筆。小ネタです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;structは普通の構造体とtupl structと言われる形式二種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Color {
  r: u8,
  g: u8,
  b: u8,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Color(u8, u8, u8);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;traitはというと関連型と型パラメータ二種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Into {
  type Item;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Into&amp;lt;T&amp;gt;{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インスタンス化も似てます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// struct
struct Color {
  r: 255,
  g: 0,
  b: 0,
}

struct Color(255, 0, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// trait
struct Dummy;

impl Into for Dummy {
  type Item = i8
}

impl Into&amp;lt;i8&amp;gt; for Dummy {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、両者の使い分けも名前で参照したいかor手軽に使いたいかで使い分けます。&lt;/p&gt;

&lt;p&gt;以上小ネタでした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのプロセス</title>
      <link>/blog/2016/12/02/rustnopurosesu</link>
      <pubDate>Fri, 02 Dec 2016 17:52:30 +0900</pubDate>
      
      <guid>/blog/2016/12/02/rustnopurosesu</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;3日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。Rustの&lt;a href=&#34;https://doc.rust-lang.org/std/process/index.html&#34;&gt;&lt;code&gt;std::process&lt;/code&gt;&lt;/a&gt;の扱い方を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;ビルダー&#34;&gt;ビルダー&lt;/h1&gt;

&lt;p&gt;これはビルダーになっていて、以下のように使えます。公式ドキュメントの例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;sh&amp;quot;)
    .arg(&amp;quot;-c&amp;quot;)
    .arg(&amp;quot;echo hello&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境変数も渡せます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;sh&amp;quot;)
    .arg(&amp;quot;-c&amp;quot;)
    // 環境変数を参照するコマンド
    .arg(&amp;quot;echo $HELLO&amp;quot;)
    // 環境変数を設定する
    .env(&amp;quot;HELLO&amp;quot;, &amp;quot;hello, world&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;hello, world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは実行するディレクトリも指定出来ます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;ls&amp;quot;)
    // プロセスを実行するディレクトリを指定する
    .current_dir(&amp;quot;/&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
boot
cdrom
core
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;出力&#34;&gt;出力&lt;/h1&gt;

&lt;p&gt;上の例では &lt;code&gt;output&lt;/code&gt; でstdio,stderr, exitstatus取り出していますが、子プロセスとして実行することも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut child = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // outputではなくspawnを使う
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);
let status = child.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin  boot  cdrom  core  dev  etc  home  initrd.img  initrd.img.old  lib  lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  sys  tmp  usr  var  vmlinuz  vmlinuz.old
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、子プロセスはRustへではなく直接stdoutへ出力するのでSIGPIPEが送られません。&lt;/p&gt;

&lt;p&gt;あるいは出力先を手で指定することも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let child = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // stdoutをnullにする
    .stdout(Stdio::null())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);
let status = child.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではstdoutをnull ioに指定しています。他には&lt;code&gt;inherit&lt;/code&gt;で親プロセスのものを引き継ぐか、&lt;code&gt;piped&lt;/code&gt;で次のプロセスに渡すことも出来ます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// 1つめのプロセスを作る
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // 出力は親プロセスへパイプする
    .stdout(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);

// 2つめのプロセスを作る
let mut child2 = Command::new(&amp;quot;grep&amp;quot;)
    .arg(&amp;quot;bin&amp;quot;)
    // 入力は親プロセスへパイプする
    .stdin(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);

{
    // Someと分かっているのでunwrapする。
    // この辺はrustの型システテムの限界。
    let out = child1.stdout.as_mut().unwrap();
    let in_ = child2.stdin.as_mut().unwrap();
    // 1つめのプロセスの出力から2つめのプロセスの入力へデータをコピーする
    io::copy(out, in_).unwrap();
}


let status1 = child1.wait().unwrap();
let status2 = child2.wait().unwrap();
println!(&amp;quot;{}, {}&amp;quot;, status1, status2);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
sbin
exit code: 0, exit code: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと繋ぎ込みが面倒ですし&lt;code&gt;io::copy&lt;/code&gt;を使って手でコピーしてるのが頂けませんね。&lt;/p&gt;

&lt;h1 id=&#34;unix&#34;&gt;Unix&lt;/h1&gt;

&lt;p&gt;Unixに依存することを認めてしまえばもうちょっと色々なことが出来ます。&lt;/p&gt;

&lt;p&gt;1つには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::process::CommandExt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するといくつか追加のメソドが生えてくる仕組みになってます。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;exec&lt;/code&gt; が使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let error = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // execを呼ぶ
    .exec();

println!(&amp;quot;after exec!!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;した後はRustのプロセスを別のものに置き換えてしまうので&lt;code&gt;println!(&amp;quot;after exec!!&amp;quot;);&lt;/code&gt;の行が実行されません。
されるとしたら何らかの理由で&lt;code&gt;exec&lt;/code&gt;に失敗した場合だけです。なので面白いことに&lt;code&gt;exec&lt;/code&gt;の返り値はエラーのみです。&lt;/p&gt;

&lt;p&gt;あるいは、&lt;code&gt;unsafe&lt;/code&gt;なコードを認めるなら先のプロセスの繋ぎ込みはもうちょっとスマートに書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::io::{AsRawFd, FromRawFd};
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // 標準出力をパイプする
    .stdout(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

let mut child2 = Command::new(&amp;quot;grep&amp;quot;)
    .arg(&amp;quot;bin&amp;quot;)
    // 標準入力は手で作ったStdioオブジェクトにする。
    // ここでは1つめのプロセスの標準出力を直接繋ぐ。
    .stdin(unsafe{Stdio::from_raw_fd(child1.stdout.as_ref().unwrap().as_raw_fd())})
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

// 直接繋いでしまったのでコピーの必要はない

let status1 = child1.wait().unwrap();
let status2 = child2.wait().unwrap();
println!(&amp;quot;{}, {}&amp;quot;, status1, status2);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
sbin
exit code: 0, exit code: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Stdio&lt;/code&gt;がfdと行き来出来るのでそれを経由することでパイプを作れます。&lt;/p&gt;

&lt;p&gt;もちろん、ファイルに書き出すことも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::io::{AsRawFd, FromRawFd};

let file = File::create(&amp;quot;test.txt&amp;quot;).unwrap();
// ファイルからFDを経由してStdioを作る
let out = unsafe{Stdio::from_raw_fd(file.as_raw_fd())};
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    .stdout(out)
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

let status1 = child1.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status1);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat test.txt
bin
boot
cdrom
core
dev
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;最初は思ったよりCのプロセス回りのAPIと違って戸惑いますが馴れてしまえば使いやすいAPIでしょう。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>新しいコンパイラバックエンドcretonne</title>
      <link>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</link>
      <pubDate>Fri, 02 Dec 2016 14:00:11 +0900</pubDate>
      
      <guid>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;3日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。先日、Rustの開発者フォーラムに新しいバックエンドして&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;cretonne&lt;/a&gt;が&lt;a href=&#34;https://internals.rust-lang.org/t/possible-alternative-compiler-backend-cretonne/4275&#34;&gt;提案されていました&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ちょっと気になったのでそれを紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;概略&#34;&gt;概略&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/index.html&#34;&gt;ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;フォーラムによると、WebAssemblyをエンコードするために作られたコンパイラバックエンドで、FirefoxのJSエンジンであるSpiderMonkeyに載せる予定だそうです。JITが主な目的？&lt;/p&gt;

&lt;p&gt;LLVMのように最適化を頑張る方ではなくてコードを吐くまでのレイテンシを気にして作られているとのこと。なのでcretonne自身は最適化を行いません。&lt;/p&gt;

&lt;p&gt;特徴はドキュメントの&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/compare-llvm.html&#34;&gt;LLVMとの比較&lt;/a&gt;によくまとまってますが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LLVMは複数種類の中間言語を持つのに対してcretonneは1種類&lt;/li&gt;
&lt;li&gt;アセンブラもディスアセンブラもない

&lt;ul&gt;
&lt;li&gt;コードジェネレータが吐く命令だけサポート&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中間言語はISA非依存で、legalization / instruction selectionをするとISA固有のアノテーションが付く&lt;/li&gt;
&lt;li&gt;最大抽象単位が関数(LLVMはモジュール)。cretonneは関数のインライン化とかもしない。&lt;/li&gt;
&lt;li&gt;Extended Basic Blockを使う(LLVMはBasic Block)。

&lt;ul&gt;
&lt;li&gt;ebbは分岐命令のfalse branchを指定せず、fall throughする。よくあるマシン語に近い。&lt;/li&gt;
&lt;li&gt;分岐の合流はebbに引数を持たせることで行う(LLVMはphi nodeを使う)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;undefined behaviorが存在しない&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なんとなくWebAssemblyを意識した仕様ですね。&lt;/p&gt;

&lt;h1 id=&#34;雰囲気&#34;&gt;雰囲気&lt;/h1&gt;

&lt;p&gt;以下のCのコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;float
average(const float *array, size_t count)
{
    double sum = 0;
    for (size_t i = 0; i &amp;lt; count; i++)
        sum += array[i];
    return sum / count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のcretonneのIRに落ちるそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss1 = stack_slot 8, align 4   ; Stack slot for ``sum``.

ebb1(v1: i32, v2: i32):
    v3 = f64const 0x0.0
    stack_store v3, ss1
    brz v2, ebb3                  ; Handle count == 0.
    v4 = iconst.i32 0
    br ebb2(v4)

ebb2(v5: i32):
    v6 = imul_imm v5, 4
    v7 = iadd v1, v6
    v8 = heap_load.f32 v7         ; array[i]
    v9 = fext.f64 v8
    v10 = stack_load.f64 ss1
    v11 = fadd v9, v10
    stack_store v11, ss1
    v12 = iadd_imm v5, 1
    v13 = icmp ult v12, v2
    brnz v13, ebb2(v12)           ; Loop backedge.
    v14 = stack_load.f64 ss1
    v15 = cvt_utof.f64 v2
    v16 = fdiv v14, v15
    v17 = ftrunc.f32 v16
    return v17

ebb3:
    v100 = f32const qNaN
    return v100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ、実際はファイルヘッダとかも付きますがこんな感じです。&lt;/p&gt;

&lt;p&gt;ebbに引数があったりebbの途中で平気でブランチしてたり中々やんちゃですね。&lt;/p&gt;

&lt;h1 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h1&gt;

&lt;p&gt;コードを吐くところまでやりたかったのですがまだ絶賛開発中ということもあってそのような操作が見当りませんでした。&lt;/p&gt;

&lt;p&gt;ということでファイルの方を扱ってると面白みがないのでRust APIの方で関数を構築して正当性を検証してから中間言語を吐き出してみます。&lt;/p&gt;

&lt;h2 id=&#34;一歩&#34;&gt;一歩&lt;/h2&gt;

&lt;p&gt;まずはcretonneをcloneしてきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new cretonne-sample --bin
$ cd cretonne-sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んでCargo.tomlのdependenciesに&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cretonne = {path = &amp;quot;path/cretonne/lib/cretonne/&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加します。どうやらトップレベルのプロジェクトはただのユーティリティのようでした。本体は&lt;code&gt;lib/cretonne/&lt;/code&gt;以下にいます。&lt;/p&gt;

&lt;p&gt;そしてmainファイルの中身はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate cretonne;
use cretonne::ir::*;
use cretonne::ir::{types as ty};
use cretonne::ir::{immediates as imm};
use cretonne::isa;
use cretonne::settings::{self, Configurable};
use cretonne::{write_function, legalize_function, verify_function};

fn main() {
    let mut func = {
        let name = FunctionName::new(&amp;quot;average&amp;quot;);
        let mut sig = Signature::new();
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.return_types.push(ArgumentType::new(ty::F32));
        Function::with_name_signature(name, sig)
    };

    let isa = {
        let mut b = settings::builder();
        b.set(&amp;quot;opt_level&amp;quot;, &amp;quot;fastest&amp;quot;).unwrap();
        let f = settings::Flags::new(&amp;amp;b);
        let builder = isa::lookup(&amp;quot;intel&amp;quot;).unwrap();
        builder.finish(f)
    };
    verify_function(&amp;amp;func).unwrap();
    legalize_function(&amp;amp;mut func, isa.as_ref());
    let mut o = String::new();
    write_function(&amp;amp;mut o, &amp;amp;func, Some(isa.as_ref())).unwrap();
    println!(&amp;quot;{}&amp;quot;, o);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;function average(i32, i32) -&amp;gt; f32 {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おおまかには&lt;code&gt;func&lt;/code&gt;を構築して&lt;code&gt;isa&lt;/code&gt;を決めて&lt;code&gt;verify_function&lt;/code&gt;で検証、さらに&lt;code&gt;legalize_function&lt;/code&gt;で今回のアーキテクチャ向けに微調整、&lt;code&gt;write_function&lt;/code&gt;で書き出しです。&lt;/p&gt;

&lt;h2 id=&#34;スタックスロットの追加&#34;&gt;スタックスロットの追加&lt;/h2&gt;

&lt;p&gt;まあ、スタック領域ですね。8byteの領域を確保します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;にstack_slotsフィールドがあるのでそこにpushします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;push&lt;/code&gt;の返り値はスタック領域を指すキーです。&lt;/p&gt;

&lt;h2 id=&#34;ebbの追加&#34;&gt;EBBの追加&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;構造体のフィールドに&lt;code&gt;dfg&lt;/code&gt;がいて、そいつを色々いじります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let ebb0 = func.dfg.make_ebb();
        let v1 = func.dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = func.dfg.append_ebb_arg(ebb0, types::I32);

        cur.insert_ebb(ebb0);
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

ebb0(vx0: i32, vx1: i32):
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EBBの追加にはカーソルを決めてあげて、dfgにebbを作ってあげて、カーソルの位置にebbの追加という形になります。&lt;/p&gt;

&lt;p&gt;EBBには任意に引数を追加出来ます。&lt;code&gt;append_ebb_arg&lt;/code&gt;の返り値はSSAの変数です。&lt;/p&gt;

&lt;h2 id=&#34;命令を追加する&#34;&gt;命令を追加する&lt;/h2&gt;

&lt;p&gt;命令はpythonのスクリプトによって生成されるので補完が効かず、中々扱いづらいですが頑張ります。&lt;/p&gt;

&lt;p&gt;さて、今回コードの検証を入れているので以下のようなコードは検証に落ちてしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);

        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Error { location: Ebb(Ebb(0)), message: &amp;quot;block does not end in a terminator instruction!&amp;quot; }&#39;, ../src/libcore/result.rs:799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の命令が定数であるため、正常なブロックと見做されないのです。&lt;/p&gt;

&lt;p&gt;ひとまずv3を返すことで凌ぎます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        ....
        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     return v0
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令の頭に付いてる &lt;code&gt;[-]&lt;/code&gt;はlegalizeすると付くようです。&lt;/p&gt;

&lt;h2 id=&#34;ブランチ&#34;&gt;ブランチ&lt;/h2&gt;

&lt;p&gt;もう1つebbを追加してあげる必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let ebb3 = dfg.make_ebb();  // &amp;lt;- ebb3を作成
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new()); // &amp;lt;-ebb3にジャンプ

        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);

        cur.insert_ebb(ebb3); // &amp;lt;- ebb3を追加
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     brz vx1, ebb1
[-]                     return v0

                    ebb1:
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;残り&#34;&gt;残り&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;

        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb2 =  dfg.make_ebb();
        let v5 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb3 = dfg.make_ebb();

        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new());
        let v4 = dfg.ins(cur).iconst(types::I32, 0);
        let mut ebb2_arg = VariableArgs::new();
        ebb2_arg.push(v4);
        dfg.ins(cur).jump(ebb2, ebb2_arg);

        cur.insert_ebb(ebb2);
        let v6 = dfg.ins(cur).imul_imm(v5, 4);
        let v7 = dfg.ins(cur).iadd(v1, v6);
        dfg.ins(cur).jump(ebb3, VariableArgs::new());

        cur.insert_ebb(ebb3);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで進めていこうと思いましたがどうやらまだstack/heapを触る命令がない？？ようなので詰みました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;コンパイラバックエンドcretonneについて紹介しました&lt;/li&gt;
&lt;li&gt;cretonneのRust APIを触ってみましたがダメでした。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustでバイト列を扱う時のtips</title>
      <link>/blog/2016/12/01/rustdebaitoretsuwoatsukautokinotips</link>
      <pubDate>Thu, 01 Dec 2016 14:29:33 +0900</pubDate>
      
      <guid>/blog/2016/12/01/rustdebaitoretsuwoatsukautokinotips</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;2日目の記事です。&lt;/p&gt;

&lt;p&gt;Rustはシステムプログラミング言語なのでバイト列をあれこれしたいことがあると思います。その時にイテレータでバイト列を舐める以外にも色々方法があるなと気付いたので。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;read-と-write&#34;&gt;&lt;code&gt;Read&lt;/code&gt; と &lt;code&gt;Write&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;私には割と衝撃だったのですが&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;や&lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt;、&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;は直接&lt;code&gt;Read&lt;/code&gt;や&lt;code&gt;Write&lt;/code&gt;のインスタンスになってます。
例えば&lt;code&gt;Read&lt;/code&gt;ならこういう風に使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes: &amp;amp;[u8] = &amp;amp;[1, 2, 3, 4, 5, 6];
let mut buf = [0;3];
bytes.read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;read: [1, 2, 3], rest: [4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは &lt;code&gt;.bytes()&lt;/code&gt;でbyteのイテレータを取り出してもいいですし、如何様にも扱えます。&lt;/p&gt;

&lt;p&gt;少し注意が必要なのは&lt;code&gt;Vec&lt;/code&gt;は &lt;code&gt;Read&lt;/code&gt; を実装してないので一旦スライスに変換してあげる必要がありますが、やり方を工夫する必要があります。&lt;/p&gt;

&lt;p&gt;以下は少しびっくりする例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = vec![1, 2, 3, 4, 5, 6];
let mut buf = [0;3];
(&amp;amp;bytes[..]).read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;read: [1, 2, 3], rest: [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦スライスを取り出してその場で捨てているので&lt;code&gt;bytes&lt;/code&gt;は消費されません。&lt;/p&gt;

&lt;p&gt;そうやりたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = vec![1, 2, 3, 4, 5, 6];
let mut bytes = &amp;amp;bytes[..];
let mut buf = [0;3];
bytes.read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように一旦スライスを束縛してから使います。&lt;/p&gt;

&lt;p&gt;Writeの方も似ていて、そのまま&lt;code&gt;write&lt;/code&gt;出来ますし、消費されます。ただ、書き込み領域が空になってもそのままスルーされるので注意です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mut bytes: &amp;amp;mut [u8] = &amp;amp;mut [0; 6];
let data = &amp;amp;[1, 2, 3];
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;data: [1, 2, 3], buf: [0, 0, 0, 0, 0, 0]
data: [1, 2, 3], buf: [0, 0, 0]
data: [1, 2, 3], buf: []
data: [1, 2, 3], buf: []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後、バッファが空になった状態で書き込んでも無言で書き込みが終了しています。そして書き込んだデータへのアクセスは出来てないですね。&lt;/p&gt;

&lt;p&gt;こうすると出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes:[u8; 6] =  [0; 6];
let data = &amp;amp;[1, 2, 3];
{
    let mut buf: &amp;amp;mut [u8] = &amp;amp;mut bytes;
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
    buf.write(data).unwrap();
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
    buf.write(data).unwrap();
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
}
println!(&amp;quot;bytes: {:?}&amp;quot;, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [1, 2, 3], buf: [0, 0, 0, 0, 0, 0]
data: [1, 2, 3], buf: [0, 0, 0]
data: [1, 2, 3], buf: []
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあ面倒ですね。というかそもそも固定長のバッファに書き込みたいという需要が少ない。&lt;/p&gt;

&lt;p&gt;でもこれは&lt;code&gt;Vec&lt;/code&gt;を使えば解決します。可変長ですし&lt;code&gt;Write&lt;/code&gt; も実装しているので便利です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes: Vec&amp;lt;u8&amp;gt; = Vec::new();
let data = &amp;amp;[1, 2, 3];
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
println!(&amp;quot;bytes: {:?}&amp;quot;, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [1, 2, 3], buf: []
data: [1, 2, 3], buf: [1, 2, 3]
data: [1, 2, 3], buf: [1, 2, 3, 1, 2, 3]
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cursor&#34;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、上で見た通り、なんとなく生のバイト列だと扱いづらそうな場面がありそうですよね。
そこで &lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/struct.Cursor.html&#34;&gt;&lt;code&gt;std::io::Cursor&lt;/code&gt;&lt;/a&gt;を使うと便利です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Cursor&lt;/code&gt;はコンストラクタで引数の所有権を奪うタイプの、ラッパーオブジェクト的構造体です。&lt;/p&gt;

&lt;p&gt;readだとこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: &amp;amp;[u8] = &amp;amp;[1,2,3,4,5,6];
let data: &amp;amp;mut [u8] = &amp;amp;mut [0;3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
cur.read_exact(data).unwrap();
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
cur.read_exact(data).unwrap();
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
println!(&amp;quot;bytes: {:?}&amp;quot;, cur.into_inner());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [0, 0, 0], position 0
data: [1, 2, 3], position 3
data: [4, 5, 6], position 6
bytes: [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポジションが取れるのと元のオブジェクトが無事なのが違いますね。&lt;/p&gt;

&lt;p&gt;Writeも同様です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: &amp;amp;mut [u8] = &amp;amp;mut [0;6];
let data: &amp;amp;[u8] = &amp;amp;[1, 2, 3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
println!(&amp;quot;bytes: {:?}&amp;quot;, cur.into_inner());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;data: [0, 0, 0, 0, 0, 0], position 0
data: [1, 2, 3, 0, 0, 0], position 3
data: [1, 2, 3, 1, 2, 3], position 6
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この&lt;code&gt;Cursor&lt;/code&gt;の面白いのは&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;でなく&lt;code&gt;AsRef&amp;lt;[u8]&amp;gt;&lt;/code&gt;で&lt;code&gt;Read&lt;/code&gt;を実装していますし&lt;code&gt;std::io::Seek&lt;/code&gt;も実装しているのでこういうことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = Vec::new();
let data: &amp;amp;[u8] = &amp;amp;[1, 2, 3];
let buf: &amp;amp;mut [u8] = &amp;amp;mut [0; 3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.seek(SeekFrom::Start(0)).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.read(buf).unwrap();
println!(&amp;quot;bytes: {:?}, position {}, buf: {:?}&amp;quot;, cur.get_ref(), cur.position(), buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bytes: [], position 0
bytes: [1, 2, 3], position 3
bytes: [1, 2, 3, 1, 2, 3], position 6
bytes: [1, 2, 3, 1, 2, 3], position 0  // &amp;lt;- 0にシークした
bytes: [1, 2, 3, 1, 2, 3], position 3, buf: [1, 2, 3] // &amp;lt;- 0からリード出来てる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生の&lt;code&gt;Vec&lt;/code&gt;では出来なかったread and writeが実現出来ています。そして好きにカーソルをシーク出来ます。
ここまでくるとほとんどファイルと変わらなく扱えますね。&lt;/p&gt;

&lt;h1 id=&#34;おりに&#34;&gt;おりに&lt;/h1&gt;

&lt;p&gt;ちょっとしたTipsですが道具箱にこういうのを増やしておくと便利ですよね！！&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Read.html&#34;&gt;std::io::Read - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Write.html&#34;&gt;std::io::Write - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/struct.Cursor.html&#34;&gt;std::io::Cursor - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Seek.html&#34;&gt;std::io::Seek - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/enum.SeekFrom.html&#34;&gt;std::io::SeekFrom - Rust&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustで非同期Thriftしたい</title>
      <link>/slide/RustdehidoukiThriftshitai/</link>
      <pubDate>Sat, 26 Nov 2016 13:07:29 +0900</pubDate>
      
      <guid>/slide/RustdehidoukiThriftshitai/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Rustで非同期Thrift
----------------------
[歌舞伎座.tech#12「メッセージフォーマット/RPC勉強会」 - connpass](https://kbkz.connpass.com/event/40629/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

* &lt;span style=&#34;font-size:150%&#34;&gt;X&lt;/span&gt; RPCライブラリを使う話
* &lt;span style=&#34;font-size:150%&#34;&gt;O&lt;/span&gt; RPCライブラリを作る話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# RPC
-----

* Remote Procedure Call
* リモートで呼べる
* 言語跨げる
* シリアライズフォーマットが決まれば大体出来る
* Thrift, protobuf/gRPC, avro...
* 大抵バイナリ
  + JSONに比べて2倍くらい効率がいい

===

# Thrift
--------

* Facebook発(現apache)RPCフレームワーク
* IDLから複数の言語向けのコードを吐ける
* 対応言語多い
* 新しい言語はthriftレポジトリフォークして追加

===

# Thrift vs gRPC
----------------

\                       | Thrift | gRPC
------------------------|:------:|:----:
ベース                  | 自前   | HTTP/2
コード生成              | o      | o
プロトコルのアップデート | o      | o
通信の多重化            | トランスポート次第  | o (HTTP/2)
認証                    | x  | o
例外                    | ユーザ定義可能 | 事前定義のみ?
対応言語                | 多い   | ほどほど
その他                  | union  | timestamp, anyなど
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;

===

# 何故Thrift?
-------------

* 仕事で使ってたから
* 仕事は「gRPCかthrift、まあthriftでいっしょ」で決まった

===

# RustとThrift
--------------
いくつか実装がある

===

## [sgnr/rust-thrift](https://github.com/sgnr/rust-thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![sgnr/rust-thrift is deprecated](/images/thrift/sgnr-rust-thrift.png)

===

## [maximg/thrift](https://github.com/maximg/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![maximg/thrift is deprecated](/images/thrift/maximg-thrift.png)

===

## [terminalcloud/thrift](https://github.com/terminalcloud/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![terminalcloud/thrift is deprecated](/images/thrift/terminalcloud.png)

===

# [thehydroimpulse/thrust](https://github.com/thehydroimpulse/thrust)
---------------------------

* Thrift RPC in Rust (Async I/O)
* 非同期!!
* apache/thriftベースじゃない（フルスクラッチ）
* コンパイラプラグインサポートとかも
* 作りかけ
  + `Latest commit 0a37b77 on 11 Apr`

→ フォークすることに

===

# [Finagle](https://github.com/twitter/finagle)
---------

* **Scalaの** RPCフレームワーク
* [You Server as a Function](https://monkey.org/~marius/funsrv.pdf)
* Nettyベース
* サーバとクライアント両方サポート
* Twitter製
* 良くも悪くもTwitterべったり

===

# Finagle Client
--------

* クライアントが賢い
* RPCではTCPベースのLBが使えない
  + クライアントはコネクション張りっぱなし
* クライアントサイドロードバランシングが必要
* Finagleはそこまでカバー
* 他にもエラーが起きたサーバ外したり色々

===

# Tokio
--------

* **Rustの** RPCフレームワーク
* mioベース
* Finagleを参考に開発
  + **開発中**
* tokio-core
  + コア部分
* tokio-proto
  + プロトコル実装のサポート
  + 絶賛API変更中
* tokio-service
  + サービス実装のサポート


===

# TokioとFinagle
-----------------

  \           | Tokio       | Finagle
--------------|:-----------:|:-------:
コア          | [tokio-core](https://github.com/tokio-rs/tokio-core) | [finagle-core](https://github.com/twitter/finagle/tree/develop/finagle-core)
Future        | [future](https://github.com/alexcrichton/futures-rs) | [twitter util](https://github.com/twitter/util)
非同期エンジン | [mio](https://github.com/carllerche/mio) | [netty](http://netty.io/)
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;


===

# [mio](https://github.com/carllerche/mio)
------

* 非同期イベントループライブラリ
* イベントドリブン
* ループ内ゼロアロケーション
* `epoll` などの薄いラッパ
* libuv, libevent, libev2などのRust版
* ソケットだけでなく *ファイルIO* 、インメモリチャネルとかも監視出来る

===

# [future](https://github.com/alexcrichton/futures-rs)
--------------

* [Zero-cost futures in Rust · Aaron Turon](https://aturon.github.io/blog/2016/08/11/futures/)
* ゼロコスト
* 普通にFutureを使うとランタイムにステートマシンになる
* 「将来実行される」という「状態」を第一級の値として表現する大事な手段
* お型付けは大変
    + `map` したら `Map&lt;A, fn (A)-&gt;B&gt;` の型が返ったり
* ストリーミング指向のAPIもある

===

# [tokio-core](https://github.com/tokio-rs/tokio-core)
--------------

* 非同期IOのフレームワーク
* Futureベース
* フレームドIOとストリーミングIO
* フレームワークというよりユーティリティ？
  + mioとfutureを合わせて使う

===

# [tokio-proto](https://github.com/tokio-rs/tokio-proto)
-------------

* 主にバイナリ列&lt;-&gt;構造体の部分の面倒を見てくれる
* API変更中…
* バッファリングしてパースしやすくしてくれる
* プロトコルの多重化やってくれる(後述)

===

# [tokio-service](https://github.com/tokio-rs/tokio-service)
-----------------

* タスクサーバの面倒見てくれる
* 主にロードバランシング


===

# [Service](https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html)
-------------

``` rust
pub trait Service {
    type Request;
    type Response;
    type Error;
    type Future: Future&lt;Item=Self::Response, Error=Self::Error&gt;;
    fn call(&amp;self, req: Self::Request) -&gt; Self::Future;
}
```

===

# Service
----------

* いわゆるハンドラ
* インターフェースさえ満たせばいい
  + ミドルウェアもハンドラも同じ扱い

===

# [NewService](https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html)
--------------

```rust
pub trait NewService {
    type Request;
    type Response;
    type Error;
    type Instance: Service&lt;Request=Self::Request, Response=Self::Response, Error=Self::Error&gt;;
    fn new_service(&amp;self) -&gt; Result&lt;Self::Instance&gt;;
}

impl&lt;F, R&gt; NewService for F where F: Fn() -&gt; Result&lt;R&gt;, R: Service
```

===

# NewService
------------

* いわゆるAbstractServiceFactory的な存在
* コア数に応じてサービスを作ってくれる
* ただし`Service`を返す普通の関数も`NewService`になる
* [example](https://github.com/tokio-rs/tokio-line/blob/master/examples/echo_client_server.rs#L21)


===

# tokio-thrift
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# [tokio-thrift](https://github.com/KeenS/tokio-thrift)
--------------

* [KeenS/tokio-thrift](https://github.com/KeenS/tokio-thrift)
* この発表のために作った（作ってる）
* tokioベースのrustのthriftサポート
* thrustのフォーク
* 基本ツール全て
  + コードジェネレータ
  + コンパイラプラグイン
  + ランタイムライブラリ

===

# プロトコルスタック
-------------------

ユーザは実装に集中出来る仕組み

```
+------------------------------------------------+
| service   | tokio-service + 生成コード + ユーザ |
|------------------------------------------------|
| protocol  | tokio-proto   + tokio-thrift       |
|------------------------------------------------|
| transport | tokio-core                         |
+------------------------------------------------+
```

===

# サンプルコード
----------------

* [これ](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/main.rs)

===

# ユーザビリティ
---------------

* サーバ: ユーザはインターフェースに沿ったコードを書くだけ
* クライアント: インターフェース通りに呼べる
* 返り値はFuture
* サーバ: 非同期実装と相性がいい
* クライアント: 非同期通信をそのままエンコード

===

# 実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# Thriftのプロトコル
-------------------

* 現状binary protocolのみ
  + fork元が実装してあった
* compactとか需要ある？
* 因みにJSONはやめとけ

===

# 所有権とゼロコピー
-------------------

* プロトコルのパースの部分の話
* Rustっぽい部分
* バッファの所有権をパース結果に渡すことでデータのコピーを避ける

===

# 所有権とゼロコピー
-------------------
バッファをresultにパースして

```
buffer
  |
+-+---------------+
|                 |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 所有権とゼロコピー
-------------------
resultにデータの所有権を渡してしまう

```
 result   buffer
   |        |
+--+----++--+-----+
|       ||        |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 複数メソッド
-------------

* 複数メソッドだと複数の引数/返値の型を扱う
* コネクションのハンドラは1つ
* 複数型をどうやって扱う？
  + [enumを定義](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/thrift.rs#L67)
  + ゼロオーバーヘッド…

===

# 複数メソッド
-------------

```
 (methodA) (methodB)
     |         |
     +----+----+
          | &lt;----- enum化
      [client]
          |
      [server]
          | &lt;----- enumでディスパッチ
     +----+-----+
     |          |
(handlerA) (handlerB)
```

===

# つらい話
-----------------

* Thrift IDLのセマンティクスが書いてない
  + throws節のフィールドは直積？直和？
  + Javaで生成してみて推測するしかない
* フォークライブラリの実装が不完全
  + パーサはフルスクラッチで書き直した
  + [パーサコンビネータ便利](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-codegen/src/parser.rs#L517)
  + フォークした意味…
* Rustにエンコード出来ないthriftの機能もある
  + mapの定数は普通には無理
  + エラーどうしよう(`Error`トレイトの実装とEnum)
* 所有権の問題

===

# 言語との統合
-------------

* Rustには公式のシリアライズフレームワークがある
* [rustc-serialize](https://github.com/rust-lang-nursery/rustc-serialize)
* あるいはユーザ側のも
* [serde](https://github.com/serde-rs/serde)
* のっかりたいけどThriftに必要なデータがない
  + フィールドのシーケンス番号とか
* 今のところ自動生成に頼る
  + フレームワークにフィードバックした方がいい？

===

# コード生成の話
---------------

* [コンパイラプラグイン](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-macros/tests/service.rs#L10)微妙
  + 定義元ジャンプ、フィールド名補完などに難
* CLI生成は悪手
  + IDL変更する度CLI実行？
  + 生成コードはコミット？
    - CLIのバージョンがあるので基本はコミット。でも…
* ビルドツール統合が最良
  + FinagleにはScoogeがある
  + tokio-thriftでもやりたい
    - build.rsのサポート

===

# 多重化の話
------------

* 生のthrift on TCPだと通信を多重化出来ない
* tokio-proto側でpipelineやmultiplexなどをサポート
* pipeline: レスポンスを待たずに次のリクエスト
* multiplex: リクエストとレスポンスが入り乱れてもよい。プロトコルオーバーヘッドがある
* tokio-thriftは未対応

===

# Tokioの利点
-------------

* service: サーバとクライアント両方面倒見てくれる
  + サーバもCPUの数だけハンドラをクローンしてくれたりする
* protocol: 面倒毎が少ない(バッファ使ってくれる)
* Futureベースの非同期
* pipeline, multiplexによる多重化

===

# Tokioの欠点
-------------

* APIが不安定
  + tokio-thriftは今動かないorz
* thriftはストリーミング指向なのにバッファ使う
* Rustの痒い所に当たる
  + 返り値多相がない(`Future`を直接返せない)
  + アロケーションが必要になる
  + ダイナミックディスパッチが必要になる
  + 他言語と同水準のコスト

===

# まとめ
--------

* Thriftは広さで勝負
* コードジェネレータはビルドツールへの統合を
* IDLは既存のコードに乗っかった方が楽（上と競合）
* フレームワークを使うとみんな幸せ
* RPCはインターフェースベースであるべき
* 多重化はRPCより下のレイヤーで出来る

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustの関連型の使いどころ</title>
      <link>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</link>
      <pubDate>Tue, 22 Nov 2016 18:26:47 +0900</pubDate>
      
      <guid>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</guid>
      <description>&lt;p&gt;κeenです。昨日は&lt;a href=&#34;https://rust.connpass.com/event/41467/&#34;&gt;RustのLT会！ Rust入門者の集い - connpass&lt;/a&gt;に参加してきました。
そこで&lt;a href=&#34;http://qiita.com/tacke_jp/items/9c7617971dc341146c0f&#34;&gt;関連型に関する発表&lt;/a&gt;があったので感化されて私も一筆。&lt;/p&gt;

&lt;p&gt;
馴れないと関連型はジェネリクスでいいじゃんと思えますが、両者は別の機能を提供するものです。
設計による使い分けではなくて実現したいことに応じた機能による使い分けをするので馴れてしまえば迷うことなくどちらを使うか判断出来ます。&lt;/p&gt;

&lt;p&gt;ということで関連型のパターンをいくつか。
もちろん、根底にある関連型という機能は共通なのでほとんど同じようなことを言ってますが気持としてパターンを知っておくと便利です。&lt;/p&gt;

&lt;h1 id=&#34;型レベルの関数として&#34;&gt;型レベルの関数として&lt;/h1&gt;

&lt;p&gt;「関連」型なのである型に関連する型を表現します。ちょっと見方を変えると型から型への写像、つまり関数になります。
例えばこういうのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ToUnsigned {
    type Counterpart;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart;
}

impl ToUnsigned for i32 {
    type Counterpart = u32;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart {
        self as u32
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;i32&lt;/code&gt; から &lt;code&gt;u32&lt;/code&gt; への関数になってそうなのが見えますかね？もちろん、 &lt;code&gt;i64&lt;/code&gt; から &lt;code&gt;u64&lt;/code&gt; などへの対応も作れます。
こういうのは例えば符号無し数にのみ演算が定義されている場合とかに便利ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn write_bigendian_signed&amp;lt;I, U&amp;gt;(i: I) -&amp;gt; ()
    where I: ToUnsigned&amp;lt;Counterpart = U&amp;gt;,
          U: ...,  {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;トレイト内で使う型を固定するため&#34;&gt;トレイト内で使う型を固定するため&lt;/h1&gt;

&lt;p&gt;これが一番目にするやつじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Handler {
    type Request;
    type Response;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}

struct HTTPHandler;

impl Handler for HTTPHandler {
    type Request = HTTPRequest;
    type Response = HTTPResponse;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定というか特殊化というか、トレイト自体は汎用的に作られていて、それを実装する型が特定の処理に特化するパターンです。
ジェネリクスで受け取る訳にはいかなくて、実装すべき型をトレイトの中で定義してあげる必要があるのは分かると思います。&lt;/p&gt;

&lt;h1 id=&#34;関数の返り値を一般化するため&#34;&gt;関数の返り値を一般化するため&lt;/h1&gt;

&lt;p&gt;これは現在のRust(rust-1.13.0)が &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1522&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;をサポートしていないために必要になるテクニックです。
関連型とトレイト境界を組み合わせて使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ReverseIter {
    type Item;
    type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;
    fn rev_iter(&amp;amp;self) -&amp;gt; Iter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの &lt;code&gt;type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt; の方です。
返り値のIteratorを抽象化したいのですが、現在のRustでは&lt;code&gt;fn rev_iter(&amp;amp;self) -&amp;gt; Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt;のような書き方が出来ないので仕方なく関連型を使ってあげる必要があります。&lt;/p&gt;

&lt;p&gt;ちょっと踏み込んだ話をすると、関数の引数の多相性は∀の量化、返り値の多相は∃の量化です。そしてトレイトのジェネリクスも∀の量化で関連型が∃の量化なのでそういう対応がある訳です。&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;結構理論的にも色々あるようなので調べてみると様々なブログポストが見付かると思います。&lt;/p&gt;

&lt;p&gt;ぱぱっと思いついたパターンを3つ挙げました。もしかしたら他にもパターンがあるかもしれません。&lt;/p&gt;

&lt;p&gt;これを知っておけば&lt;a href=&#34;https://github.com/tokio-rs/tokio-service&#34;&gt;tokio-service&lt;/a&gt;の&lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;Service&lt;/a&gt;みたいな関連型を多用するパターンでもひるまなくなります。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;h2 id=&#34;関連型とimpl-traitに関して&#34;&gt;関連型とimpl Traitに関して&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rust-lang-ja.org/rust-by-example/generics/assoc_items/the_problem.html&#34;&gt;関連型が必要になる状況 | Rust by Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ncameron.org/blog/abstract-return-types-aka-%60impl-trait%60/&#34;&gt;Abstract return types, aka &lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;応用&#34;&gt;応用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2016/02/28/rustnohigherkinded_type_trait/&#34;&gt;RustのHigher-Kinded type Trait | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;発展的な話題&#34;&gt;発展的な話題&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/02/associated-type-constructors-part-1-basic-concepts-and-introduction/&#34;&gt;Associated type constructors, part 1: basic concepts and introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/03/associated-type-constructors-part-2-family-traits/&#34;&gt;Associated type constructors, part 2: family traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/04/associated-type-constructors-part-3-what-higher-kinded-types-might-look-like/&#34;&gt;Associated type constructors, part 3: What higher-kinded types might look like&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/09/associated-type-constructors-part-4-unifying-atc-and-hkt/&#34;&gt;Associated type constructors, part 4: Unifying ATC and HKT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1598&#34;&gt;Associated type constructors (a form of higher-kinded polymorphism). by withoutboats · Pull Request #1598 · rust-lang/rfcs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustの話とリソースの話</title>
      <link>/slide/Rustnohanashitoriso_sunohanashi/</link>
      <pubDate>Sun, 20 Nov 2016 14:08:07 +0900</pubDate>
      
      <guid>/slide/Rustnohanashitoriso_sunohanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustの話とリソースの話
----------------------
[RustのLT会！ Rust入門者の集い](https://rust.connpass.com/event/41467/)  
2016-11-21

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 若者
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます
 * [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)の翻訳
 * [Join rust-jp on Slack!](http://rust-jp.herokuapp.com/) にもいます。
 * [Rust その2 Advent Calendar 2016 - Qiita](http://qiita.com/advent-calendar/2016/rust-lang-2)

===

# 注意
------

* たまにマニアックな話が出ますが気にせず無視して下さい
* 「なんかRustすげー」って思ってもらえれば幸いです


===

# Rustとの出会い
----------------

* 元々Lisperだった
* 他にはML, Ruby, JVM言語など

===

![lis books](/images/rust-and-resource/lisp.jpg)&lt;!-- .element: height=&#34;640px&#34; --&gt;

===

&lt;span style=&#34;font-size: 150%&#34;&gt;「Lisperは自分で処理系作って一人前」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![compiler books](/images/rust-and-resource/compiler.jpg) &lt;!-- .element: height=&#34;640px&#34;&#34; --&gt;

===

# 苦悩
-------

* Cは低級すぎる
* Javaは向いてない
* C++は怖そう
  + 闇の軍団
  + 縄文土器飛んできそう
  + あと **nullあるしメモリ破壊あるし**
* MLは向いてるけどシステムプログラミングしづらい
* ATS2, Golang, D...

===

# Rustと出会う
----------------

* 正直最初は色物言語と思ってた
* 調べてみたら気に入った

===

# ゼロコスト抽象化
----------------------------

``` rust
fn sum_pos(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    v.iter().filter(|i| **i &gt; 0).sum()
```

===

高階関数が消えた…！？

``` asm
_ZN21higher_order_function7sum_pos17h2f9de4f69306ec0aE:
	.cfi_startproc
	movq	(%rdi), %rcx
	movq	16(%rdi), %rax
	leaq	(%rcx,%rax,4), %rdx
	xorl	%eax, %eax
	jmp	.LBB0_1
.LBB0_3:
	addl	%esi, %eax
	.p2align	4, 0x90
.LBB0_1:
	cmpq	%rcx, %rdx
	je	.LBB0_4
	movl	(%rcx), %esi
	addq	$4, %rcx
	testl	%esi, %esi
	jle	.LBB0_1
	jmp	.LBB0_3
.LBB0_4:
	retq
```

===


# スタックとヒープ
------------------


* Rustは手で割り当てを変えられる
* 「ヒープを使ったら負け」ゲームが出来る
* ループの中でヒープアロケートしたくないよね

===

# マクロとコンパイラプラグイン
-----------------------------

例えば正規表現リテラルを作れるか、とか。

1. Common Lisp
2. 衛生的マクロ + 手続的マクロ &lt;- Rust
2. 衛生的マクロ + コンパイラプラグイン &lt;- Rust
3. 手続的マクロ
4. コンパイラプラグイン
4. 衛生的マクロ

===

# トレイト
----------

* 型クラス
  + 継承を駆逐する
  + MLにも欲しい超便利機能
* 関連型
  + 表現力が高いことが知られている
  + CF [Rustの型レベルLispっぽいの作った | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/11/06/rustnokatareberulispppoinotsukutta/)

===

# パターンマッチ、代数的データ型
-------------------------------

* 便利ってかないと困る

``` rust
    match expr {
        &amp;Expr::Nil |
        &amp;Expr::EOF |
        &amp;Expr::Str(_) |
        &amp;Expr::Int(_) |
        &amp;Expr::Float(_) |
        &amp;Expr::Proc(_) =&gt; Ok(expr.clone()),
        &amp;Expr::Sym(ref name) =&gt; {
            match env.find(&amp;name.to_owned()) {
                Ok(v) =&gt; Ok(v.clone()),
                Err(m) =&gt; {
                    if name.deref() == &#34;t&#34; {
                        Ok(ksym(&#34;t&#34;))
                    } else {
                        Err(m)
                    }
                }
            }
        }
        &amp;Expr::Cons(ref car, ref cdr) =&gt; {
        ....
```


===

# C インターフェース
---------------------

* C FFI, C API共に1行
* 構造体なんかも互換

``` rust
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}
```

``` rust
#[no_mangle]
pub extern fn hello_rust() -&gt; *const u8 {
    &#34;Hello, world!\0&#34;.as_ptr()
}
```


===

# ランタイムなし
---------------

* [RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/)
* [Writing an OS in Rust](http://os.phil-opp.com/)
* [Redox - Your Next(Gen) OS](http://www.redox-os.org/)

===

# 生ポインタ
------------

* Cとのやりとりで大事
* あるいはパフォーマンスチューニングに

``` rust
pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}
```

``` rust
unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Vec&lt;T&gt;
```


===

# エラー処理
------------

* 例外じゃない
* [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html)
* `?` (元 `try!`)も便利
* Erro as a data
* 巻き戻し例外って扱い難しいよね
  + 値継続と例外継続の使い分けつらい

===

# リソースの話（本題）
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# リソースの重要性
-------------------

* プログラムはIOの塊、すなわりリソースの塊
* 従来は手動で管理するかGCで管理するかしていた
* RustはGCを使わず自動で管理する
* 所有権の概念が「ただの自動」以上に便利

===

# メモリ管理
------------

* Cでいう`free`を自動で挟んでくれる
* 基本

===

# Vecとslice
-------------

* sliceを`Vec`のviewとして使える
  + zero copy
  + 例えばJavaとかだと出来ない
* zero copy parserとかも書ける

===

# `File` 、 `Lock`
------------------

* `Drop`があるので自動
* ところでGCがあるのに手動で管理する言語があるらしいですね
  + 例えばRubyの`File.open(..) do ... end` も半手動
  + GCで処理すべきなのに手で`do ... end`を書いてる

===

# Rust
-------

``` rust
let file = File::open(&#34;text.txs&#34;).unwrap();
let mut br = BufReader::new(file);
...
```


===

# Java
-------
※try-with-resourceを使うともっと簡単に書けます。極端な比較のためにこう書いてます

``` java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader(&#34;test.txt&#34;));
    ...
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (br != null)
        try {
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
}
```

===

# Use after close
------------------

* プログラミングエラーの一種
* あらゆるリソースで起きうる
* GCのある言語ではメモリでのエラー **のみ** 防げる
* 他のリソースだとダメ
* Rustは **全ての** リソースで防げる

===

# Ruby
------

``` ruby
file = nil
File.open(&#34;file.rb&#34;) do |f|
  file = f
end
puts file.read

```

```
#&lt;File:file.rb (closed)&gt;
file.rb:6:in `read&#39;: closed stream (IOError)
        from file.rb:6:in `&lt;main&gt;&#39;
```


===

# Rust
-------

* 所有権のある限り勝手に`close`されない

``` rust
let mut file = None;
{
  let f = File::open(&#34;file.rs&#34;).unwrap();
  file = Some(f);
}
let mut s = String::new();
file.unwrap().read_to_string(&amp;mut s).unwrap();
println!(&#34;{}&#34;, s);
```

===

# ラッパーオブジェクト
--------------------

* 所有権便利って話

===

# Scala
------

``` scala
val kc = new KafkaProducer(...)
val sk = new SimpleKafkaClient(kc)
kc.close // &lt;- !?!?!?
...
```

===

# Rust
-------

``` rust
let kc = KafkaClient(...);
val mut sk = SimpleKafkaClient(kc);
kc.close(); // &lt;- Compile error because kc has been moved
```

===

# 責任者問題
-----------

* ラッパーオブジェクトの続き
* ラップされたオブジェクトは誰が閉じるの？


===

# Scala
------

``` scala
val kc = new KafkaProducer(...)
val sk = new SimpleKafkaClient(kc)
...
sk.close
kc.close // 本当に必要？
```

===

# Rust
-------

``` rust
let kc = KafkaClient(...);
val mut sk = SimpleKafkaClient(kc); // ここでmove
...
sk.close(); // moveされたskがcolseすることが型で分かる
```

===

# まとめ
--------

* Rust = 便利機能詰め合わせ + 所有権
* さらにランタイムもないしCとの相互連携も出来る
* リソース管理って大事
* 所有権は制限だけじゃないよ



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustの型レベルLispっぽいの作った</title>
      <link>/blog/2016/11/06/rustnokatareberulispppoinotsukutta</link>
      <pubDate>Sun, 06 Nov 2016 11:49:43 +0900</pubDate>
      
      <guid>/blog/2016/11/06/rustnokatareberulispppoinotsukutta</guid>
      <description>&lt;p&gt;κeenです。ふとした気紛れでRustの型レベルLispっぽいの作りました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;実装自体は&lt;a href=&#34;https://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/&#34;&gt;去年Scalaで作た時&lt;/a&gt;とほぼ同じ。
ただしRustでコンパイル時に文字列を処理しようとするとコンパイラプラグインが必要になるので今回はあきらめて素のRustの式のまま。&lt;/p&gt;

&lt;p&gt;こんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;println!(&amp;quot;{}&amp;quot;, eval!(List3&amp;lt;Add, _2, _3&amp;gt;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lisp…？感ありますがLispと言い張ります。&lt;/p&gt;

&lt;p&gt;少しだけ工夫した点はシンボルをアルファベットのListにすることで任意の文字列を表現出来るようにした点、関数を&lt;code&gt;Fun&lt;/code&gt; 、 &lt;code&gt;Fun2&lt;/code&gt; といったトレイトで抽象化することでユーザも関数を定義出来るようにした点です。&lt;/p&gt;

&lt;p&gt;例えばフィボナッチ数列は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub type Fib = Symbol&amp;lt;Sym3&amp;lt;F, I, B&amp;gt;&amp;gt;;

impl Fun1&amp;lt;_0&amp;gt; for Fib {
    type Out = _1;
}

impl Fun1&amp;lt;_1&amp;gt; for Fib {
    type Out = _1;
}

impl &amp;lt;T1N: Num, N1_O: Num, N2_O: Num, NO: Num&amp;gt;Fun1&amp;lt;Number&amp;lt;Succ&amp;lt;Succ&amp;lt;T1N&amp;gt;&amp;gt;&amp;gt;&amp;gt; for Fib
    where Fib: Fun1&amp;lt;Number&amp;lt;Succ&amp;lt;T1N&amp;gt;&amp;gt;, Out = Number&amp;lt;N1_O&amp;gt;&amp;gt;,
          Fib: Fun1&amp;lt;Number&amp;lt;     T1N &amp;gt;, Out = Number&amp;lt;N2_O&amp;gt;&amp;gt;,
          Add: Fun2&amp;lt;Number&amp;lt;N1_O&amp;gt;, Number&amp;lt;N2_O&amp;gt;, Out = Number&amp;lt;NO&amp;gt;&amp;gt;
{
    type Out = Number&amp;lt;NO&amp;gt;;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義出来ます。&lt;/p&gt;

&lt;p&gt;ただし、Rustの型検査が許す再帰深度がかなり小さいため、&lt;code&gt;List2&amp;lt;Fib, _6&amp;gt;&lt;/code&gt;で音を上げます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Compiling rustlisp v0.1.0 (file:///home/kim/Rust/rustlisp)
error[E0275]: overflow evaluating the requirement `_: std::marker::Sized`
 --&amp;gt; &amp;lt;rustlisp macros&amp;gt;:1:20
  |
1 | ( $ t : ty ) =&amp;gt; { &amp;lt;&amp;lt; $ t as Eval &amp;gt; :: Out as Expr &amp;gt; :: to_string (  ) }
  |                    ^^^^^^^^^^^^^^^^^^^^^^
src/main.rs:18:20: 18:41 note: in this expansion of eval! (defined in &amp;lt;rustlisp macros&amp;gt;)
&amp;lt;std macros&amp;gt;:2:27: 2:58 note: in this expansion of format_args!
&amp;lt;std macros&amp;gt;:3:1: 3:54 note: in this expansion of print! (defined in &amp;lt;std macros&amp;gt;)
src/main.rs:18:5: 18:43 note: in this expansion of println! (defined in &amp;lt;std macros&amp;gt;)
  |
  = note: consider adding a `#![recursion_limit=&amp;quot;128&amp;quot;]` attribute to your crate
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun1&amp;lt;rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::F, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::I, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::B, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::eval::Eval` for `rustlisp::cons::ConsCell&amp;lt;rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::F, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::I, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::B, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;, rustlisp::cons::ConsCell&amp;lt;rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;, rustlisp::cons::Nil&amp;gt;&amp;gt;`

error: aborting due to previous error

error: Could not compile `rustlisp`.

To learn more, run the command again with --verbose.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スタックを作ってどうこう、とかも考えたのですが上手くいきませんでした。悲しい。&lt;/p&gt;

&lt;p&gt;ということで小ネタでした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのクロージャ3種を作って理解する</title>
      <link>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</link>
      <pubDate>Mon, 10 Oct 2016 16:48:43 +0900</pubDate>
      
      <guid>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</guid>
      <description>&lt;p&gt;κeenです。Rustのクロージャ、3種類もあって複雑ですよね。
こういう複雑なものはRustの気持になって考えれば理解出来たりします。ということで手でクロージャを作って理解してみましょう。&lt;/p&gt;

&lt;p&gt;尚、これはRustの1.12.0-stableと1.14.0-nightly (6e8f92f11 2016-10-07)で実験しています。
&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;関数 - 関数&lt;/li&gt;
&lt;li&gt;無名関数 - 名前のついていない関数&lt;/li&gt;
&lt;li&gt;自由変数 - そのスコープの中で束縛されていない変数&lt;/li&gt;
&lt;li&gt;クロージャ - 関数に、自由変数の値(環境)もくっつけてそれだけで閉じるようにしたもの&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;クロージャについては関数が閉じ込める環境だけを指してクロージャとする人もいますが、ここでは関数本体と環境を合わせてクロージャとします。&lt;/p&gt;

&lt;p&gt;よく、無名関数とクロージャ(関数閉包)を一緒くたにすることがありますが明確に区別しましょう。まあ、大抵の無名関数はクロージャになりますが、動的スコープの言語みたいにそうならないケースもあります。&lt;/p&gt;

&lt;p&gt;余談ですが「ラムダ式」は言語がよく無名関数に付ける名前です。「関数」も言語によって「手続き」だったり「メソッド」だったりしますね。&lt;/p&gt;

&lt;h1 id=&#34;fnonce-fnmut-fn&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、「作って理解する」なので例を出します。なんかよく分からないけど0から9の値に1を足して印字するプログラムです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = |arg|{ i + arg };
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無名関数を作って &lt;code&gt;cls&lt;/code&gt; という変数に束縛しています。 &lt;code&gt;cls&lt;/code&gt; は自由変数 &lt;code&gt;i&lt;/code&gt; を含みますので、 &lt;code&gt;cls&lt;/code&gt; のクロージャを取ると 「&lt;code&gt;cls&lt;/code&gt; の定義 + &lt;code&gt;i&lt;/code&gt; の定義」になります。&lt;/p&gt;

&lt;p&gt;では &lt;code&gt;i&lt;/code&gt; という変数を保持したオブジェクトを作りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Closure {
    i: isize,
}


fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // もちろん、Closureは関数でないので呼び出せない
        // println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このままだと &lt;code&gt;cls&lt;/code&gt; は呼び出せません。しかし &lt;code&gt;+&lt;/code&gt; なんかのオーバーロードを許しているRustはなんと関数呼び出し構文 &lt;code&gt;name(arg, ...)&lt;/code&gt; もオーバーロード出来ます。実装すべきトレイトは &lt;code&gt;std::ops::{FnOnce, FnMut, Fn}&lt;/code&gt; です。これがクロージャ3種です。&lt;/p&gt;

&lt;p&gt;これらは継承関係にあって、上から順に &lt;code&gt;FnOnce&lt;/code&gt;  &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait FnOnce&amp;lt;Args&amp;gt; {
    type Output;
    extern &amp;quot;rust-call&amp;quot; fn call_once(self, args: Args) -&amp;gt; Self::Output;
}

pub trait FnMut&amp;lt;Args&amp;gt;: FnOnce&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, args: Args) -&amp;gt; Self::Output;
}

pub trait Fn&amp;lt;Args&amp;gt;: FnMut&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, args: Args) -&amp;gt; Self::Output;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらの違いは &lt;code&gt;self&lt;/code&gt; をムーブして受け取るか &lt;code&gt;&amp;amp;mut&lt;/code&gt; で受けるか &lt;code&gt;&amp;amp;&lt;/code&gt; で受けるかです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;とりあえず先程の &lt;code&gt;Closure&lt;/code&gt; にこれを実装してみましょう。ちょいとunstableな機能なようなので &lt;code&gt;feature&lt;/code&gt; を使って、nightlyでコンパイルするようにしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

// 再掲
struct Closure {
    i: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
    type Output = isize;

    extern &amp;quot;rust-call&amp;quot; fn call_once(self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.i + arg
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで呼び出しが出来る筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = Closure {i: i};
        // 呼出せるようになる
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;勿論、これは以下のように明示的にメソッドを呼んでも同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // メソッドで呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls.call_once((x, )));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fnmut-fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;FnOnce&lt;/code&gt; で出来るんならなんで &lt;code&gt;FnMut&lt;/code&gt; と &lt;code&gt;FnMut&lt;/code&gt; が存在するかというと、クロージャが閉じ込めた環境の所有権の問題ですね。&lt;/p&gt;

&lt;p&gt;例えば以下のコードを手で実装してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = |arg| { x + arg};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程と同じ &lt;code&gt;Closure&lt;/code&gt; ではコンパイル出来ません（統一感のために &lt;code&gt;Closure&lt;/code&gt; のメンバ名を変えました）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

struct Closure {
    x: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
  // ...略
}


fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = Closure {x: x};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error[E0382]: use of moved value: `cls`
  --&amp;gt; closure.rs:45:28
   |
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ value moved here in previous iteration of loop
   |
   = note: move occurs because `cls` has type `Closure`, which does not implement the `Copy` trait

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1回目のループでは問題ないのですが &lt;code&gt;call_once(self, (arg, ): (isize,))&lt;/code&gt; の呼び出しでムーブしてしまうので2回目以降は呼べません。ということで1つ下のトレイト、 &lt;code&gt;FnMut&lt;/code&gt; も実装してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl FnMut&amp;lt;(isize,)&amp;gt; for Closure {

    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はこれでも怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:45:28
   |
43 |         let cls = Closure {x: x};
   |             --- use `mut cls` here to make mutable
44 |         for i in 0..10 {
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ cannot borrow mutably

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;mut&lt;/code&gt; を要求しているから。正確にはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略


fn main() {
    let x = 1;
    // `mut` を付ける
    let mut cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。しかしまあ、何か書き換えてる訳でもないのに &lt;code&gt;mut&lt;/code&gt; が付いているのは嫌ですね。&lt;code&gt;mut&lt;/code&gt; を要求しないように定義してあげようと思ったら &lt;code&gt;Fn&lt;/code&gt; が必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl Fn&amp;lt;(isize,)&amp;gt; for Closure {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, (arg,): (isize, )) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。&lt;/p&gt;

&lt;h2 id=&#34;整理&#34;&gt;整理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;クロージャとは関数とその環境のセットだよ&lt;/li&gt;
&lt;li&gt;環境にも所有権はあるよ&lt;/li&gt;
&lt;li&gt;Rustは所有権でクロージャの呼び出しを使い分けるよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;構文&#34;&gt;構文&lt;/h1&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; に対応するRustの構文を探っていきます。&lt;/p&gt;

&lt;h2 id=&#34;fn&#34;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;先程 &lt;code&gt;Fn&lt;/code&gt; まで実装しないとコンパイルが通らなかった&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    let cls = |arg| { x + arg};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は &lt;code&gt;||{}&lt;/code&gt; でコンパイルが通っているので &lt;code&gt;||{}&lt;/code&gt; は &lt;code&gt;Fn&lt;/code&gt; を作るようです。&lt;/p&gt;

&lt;h2 id=&#34;fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;call_mut&lt;/code&gt; を要求しそうにちょっと変えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、予想通りエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:37:13
   |
35 |         let cls = |arg|{ x += arg };
   |             --- use `mut cls` here to make mutable
36 |         for i in 0..10 {
37 |             cls(i);
   |             ^^^ cannot borrow mutably

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let cls = |arg|{ x += arg };
   |                   -----  - previous borrow occurs due to use of `x` in closure
   |                   |
   |                   mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to 2 previous errors

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程の &lt;code&gt;FnMut&lt;/code&gt; の例のように &lt;code&gt;cls&lt;/code&gt; に &lt;code&gt;mut&lt;/code&gt; を付けてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let mut cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これでもエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let mut cls = |arg|{ x += arg };
   |                       -----  - previous borrow occurs due to use of `x` in closure
   |                       |
   |                       mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;cls&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; を捕捉し続けているから。これは &lt;code&gt;cls&lt;/code&gt; のライフタイムを &lt;code&gt;println!&lt;/code&gt; の前で終わらせてあげると解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    {
        // `{}` でスコープを作ることでライフタイムをコントロールする
        let mut cls = |arg|{ x += arg };
        for i in 0..10 {
            cls(i);
        }
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FnMut&lt;/code&gt; は変数を &lt;code&gt;mut&lt;/code&gt; にする無名関数と同じなようです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce-1&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; は？ &lt;code&gt;std::mem::drop&lt;/code&gt; を使って所有権を無理矢理奪うクロージャを作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::drop;

fn main() {
    let x = String::new();
    let cls = || {drop(x)};
    cls();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、実はこれでOKです。冷静に考えたら &lt;code&gt;FnOnce&lt;/code&gt; を継承している &lt;code&gt;Fn&lt;/code&gt; を &lt;code&gt;||{}&lt;/code&gt; で作れた時点で問題ありませんでしたね。&lt;/p&gt;

&lt;h1 id=&#34;落穂拾い&#34;&gt;落穂拾い&lt;/h1&gt;

&lt;h2 id=&#34;move-クロージャ&#34;&gt;&lt;code&gt;move&lt;/code&gt; クロージャ&lt;/h2&gt;

&lt;p&gt;じゃあ、Rustが良い感じに使い分けてくれるなら &lt;code&gt;move&lt;/code&gt; クロージャって何のためにあるの？と思いますが、これは環境を捕捉する際に &lt;code&gt;Copy&lt;/code&gt; なんかが起こらないようにするためのものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; しない例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; する例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt; は環境 &lt;strong&gt;へ&lt;/strong&gt; 所有権を移すかどうか、 &lt;code&gt;FnOnce&lt;/code&gt; などは環境 &lt;strong&gt;から&lt;/strong&gt; 所有権を移すかどうかです。&lt;/p&gt;

&lt;h2 id=&#34;関数ポインタ&#34;&gt;関数ポインタ&lt;/h2&gt;

&lt;p&gt;クロージャを持たない関数は、 &lt;code&gt;fn(i32) -&amp;gt; i32&lt;/code&gt; のような型を持ちます。これは空の環境を持つクロージャと同じですね。空の環境に所有権も何もないのでプリミティブの &lt;code&gt;fn&lt;/code&gt; は &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; のいずれとしても振舞います。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;p&gt;ここまで書いて普通にドキュメントに詳しく載っているのに気付きました（汗&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/functions.html&#34;&gt;関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustでシェル作った</title>
      <link>/blog/2016/09/04/rustdeshierutsukutta</link>
      <pubDate>Sun, 04 Sep 2016 16:26:20 +0900</pubDate>
      
      <guid>/blog/2016/09/04/rustdeshierutsukutta</guid>
      <description>&lt;p&gt;κeenです。
先日、先輩社員と話してるとシェルを作る話になりました。
だいたいのコンピュータサイエンスの学生なら学部生の頃に課題でシェルを作りますが数学科にいた私は作ったことありませんでした。
でも、その時「今ならシェルなんて作ろうと思えばすぐに作れますよ」なんて言っちゃったのでなんか作りました。
まあ、習作程度の雑なものです。&lt;/p&gt;

&lt;p&gt;
作ったのはこれ、&lt;a href=&#34;https://github.com/KeenS/igaguri&#34;&gt;KeenS/igaguri: my toy shell written in Rust&lt;/a&gt;。
名前は、Shellは木の実を覆う殻のようにカーネルを覆う殻とのことなのでRustのロゴに似てる毬栗を選びました。&lt;/p&gt;

&lt;h1 id=&#34;パーサ&#34;&gt;パーサ&lt;/h1&gt;

&lt;p&gt;パーサコンビネータライブラリの&lt;a href=&#34;https://github.com/Geal/nom&#34;&gt;nom&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;雰囲気こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;named!(token&amp;lt;String&amp;gt;, map!(map_res!(is_a!(&amp;quot;abcdefghijklmnopqlrstuvwxyzABCDEFGHIJKLMNOPQLRSTUVWXYZ-!$%^&amp;amp;@/1234567890&amp;quot;), str::from_utf8), |i: &amp;amp;str| i.to_string()));
named!(pipe, tag!(&amp;quot;|&amp;quot;));
named!(redirect_out&amp;lt;String&amp;gt;, chain!(tag!(&amp;quot;&amp;gt;&amp;quot;) ~ opt!(multispace) ~ filename: token, || filename));

named!(command&amp;lt;Ast&amp;gt;, chain!(
    opt!(multispace)
        ~ cmd: separated_list!(multispace, token)
        ~ outfile: opt!(chain!(multispace ~ out: redirect_out, || out))
        ~ opt!(multispace), || Ast::Command{cmd: cmd, out: outfile}));
named!(parse&amp;lt;Ast&amp;gt;, map!(separated_list!(pipe, command), Ast::Pipe));

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;入力ハンドリング&#34;&gt;入力ハンドリング&lt;/h1&gt;

&lt;p&gt;readlineのRust実装、&lt;a href=&#34;https://github.com/kkawakam/rustyline&#34;&gt;rustyline&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;p&gt;それっぽいからとりあえず、で選んだものの、複数行入力（履歴）とか考えるともうちょっとリッチなものを選んだ方が良かったかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;実行&#34;&gt;実行&lt;/h1&gt;

&lt;p&gt;最初、&lt;a href=&#34;https://github.com/rust-lang/libc&#34;&gt;libcバインディング&lt;/a&gt;の &lt;code&gt;pipe&lt;/code&gt; や &lt;code&gt;fork&lt;/code&gt; 、 &lt;code&gt;execve&lt;/code&gt; なんかを考えてましたが、標準ライブラリの &lt;a href=&#34;https://doc.rust-lang.org/std/process/struct.Command.html&#34;&gt;&lt;code&gt;std::process::Command&lt;/code&gt;&lt;/a&gt;で実現出来そうだったのでそれを使いました。&lt;/p&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Command::new(cmd)
    .args(&amp;amp;terms)
    .stdin(stdin)
    .stdout(stdout)
    .stderr(stderr)
    .spawn()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パイプ-リダイレクト&#34;&gt;パイプ/リダイレクト&lt;/h2&gt;

&lt;p&gt;一応、パイプも標準ライブラリでサポートされてるのでそれを使いました。&lt;/p&gt;

&lt;p&gt;ただ、普通のCとは違って子プロセスと親プロセスの間に一旦パイプを作って、子プロセスの出力の生のfdを取り出して、次の子プロセスの入力に与えて、と案外面倒でした。 &lt;code&gt;unsafe&lt;/code&gt; も出てくれば &lt;code&gt;unreachable&lt;/code&gt; も出てくるのでもう少し書き直したい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut si = stdin;
let mut itr = commands.into_iter().peekable();
unsafe {
    while let Some(command) = itr.next() {
        if itr.peek().is_some() {
            let process =
                try!(self.run(command, si, Stdio::piped(), Stdio::inherit()));
            si = Stdio::from_raw_fd(process.stdout.unwrap().into_raw_fd());
        } else {
            return self.run(command, si, stdout, stderr);
        }
    }
}
unreachable!()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リダイレクトも似たようなもので、ファイルを作って生のfdを取り出して、とやります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let stdout = out.map(|f| {
    unsafe {
        let file = File::create(f)
        // FIXME: do not panic
            .unwrap();
        Stdio::from_raw_fd(file.into_raw_fd())
    }

}).unwrap_or(stdout);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;昨日の夜からちょろっと作り始めてさっきそれっぽく動くようになった程度なのでまだ適当にしか動きません。
パイプと標準出力のリダイレクトだけで、 &lt;code&gt;cd&lt;/code&gt; なんかのシェルコマンドもなければシェル変数もありません。
が、そろそろ飽きたのでこの辺で。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そろそろ飽きてきた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/772334565264232454&#34;&gt;2016年9月4日&lt;/a&gt;&amp;lt;/
blockquote&amp;gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;シェルコマンドとシェル変数くらいはいつか実装しようかな。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustの所有権/ミュータビリティの分割</title>
      <link>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</link>
      <pubDate>Sun, 19 Jun 2016 20:42:14 +0900</pubDate>
      
      <guid>/blog/2016/06/19/rustnoshoyuuken_myu_tabiriteinobunkatsu</guid>
      <description>&lt;p&gt;κeenです。昔所有権/ミュータビリティを分割したくなったけどぱっと方法が思いつかなくて困ったことがあるので今更ながら備忘録として残しておきます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;ミュータビリティ&#34;&gt;ミュータビリティ&lt;/h1&gt;

&lt;p&gt;例えば、HTTPパーサを作ろうとしてるとしましょう。
受け取ったバイト列のバッファをパースしてヘッダやらボディやらのサブスライスを返します。この時、返り値のサブスライスはユーザへの自由を与えるために &lt;code&gt;mut&lt;/code&gt; にしたいですよね。&lt;/p&gt;

&lt;p&gt;そう思ってこういうコードを書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io;

fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...
    Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mutability_split.rs:4:31: 4:34 error: cannot borrow `*buf` as mutable more than once at a time [E0499]
mutability_split.rs:4     Ok((&amp;amp;mut buf[hstart..hend], &amp;amp;mut buf[bstart..bend]))
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通にやろうとすると
1つ1つミュータブルなサブスライスを作ることになり、2つ目以降でborrow checkに引っ掛かってしまいます。2つのバッファがオーバーラップしてなくても。難儀ですね。コピーするくらいしかないのでしょうか。いいえ。rustはちゃんと助けになるAPIを用意してくれています。&lt;/p&gt;

&lt;h2 id=&#34;split-at-mut-https-doc-rust-lang-org-std-primitive-slice-html-method-split-at-mut&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut&#34;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn split_at_mut(&amp;amp;mut self, mid: usize) -&amp;gt; (&amp;amp;mut [T], &amp;amp;mut [T])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スライスを2つに分割してくれます。重要なのが、ミュータビリティも分割してくれるところです。返り値の2つ共に &lt;code&gt;mut&lt;/code&gt; がついています。ということで、次のように実装出来ます。（実行してないので結果が正しいかは確認してませんが）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn parse(buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(&amp;amp;mut [u8], &amp;amp;mut [u8])&amp;gt; {
    ...

    let (h, b) = buf.split_at_mut(bstart);
    let h = {
        let (_, h) = h.split_at_mut(hstart);
        let (_, h) = h.split_at_mut(hend - hstart);
        h
    };

    let (_, b) = b.split_at_mut(bend - bstart);

    Ok((h, b))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;所有権&#34;&gt;所有権&lt;/h1&gt;

&lt;p&gt;似たような話で、構造体の所有権というか、貸与権(?)を分割したい時もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonDB {
    name: String,
    age: usize,
    address: String,
}


fn use_immutable(s: &amp;amp;str) {
    // empty
}

fn use_mutable(s: &amp;amp;mut str) {
    // empty
}



fn from_db(person: PersonDB) {
    let name = &amp;amp;person.name;
    let mut address = &amp;amp;mut person.address;
    use_immutable(name);
    use_mutable(address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イミュータブルとミュータブル両方の借用があるのでエラーになってしまいます。実際は別のフィールドなので問題は起きないのですが、コンパイラに怒られます。理不尽ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mutability_split.rs:36:28: 36:42 error: cannot borrow immutable field `person.address` as mutable
mutability_split.rs:36     let mut address = &amp;amp;mut person.address;
                                                  ^~~~~~~~~~~~~~

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そういう時は、パターンマッチによる分配束縛でクリア出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn from_db(person: PersonDB) {
    let PersonDB {name, mut address, ..} = person;
    use_immutable(&amp;amp;name);
    use_mutable(&amp;amp;mut address);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Rustの所有権やミュータブルな参照など、1つしか存在出来ないとされるものが分割出来ることを示しました。
地味に悩む所なので誰かの助けになれば幸いです。&lt;/p&gt;

&lt;p&gt;蛇足を足すと、本当は所有権の分割についても書く予定でしたがエラーになる筈のコードがあっさりコンパイルを通ってしまったのでナシになりました。コンパイラも進化してますね。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>