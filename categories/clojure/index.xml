<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clojure on κeenのHappy Hacκing Blog</title>
    <link>/categories/clojure/</link>
    <description>Recent content in Clojure on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Mon, 22 Feb 2016 20:19:11 +0900</lastBuildDate>
    <atom:link href="/categories/clojure/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ClojureでSSPを作った話</title>
      <link>/slide/ClojuredeSSPwotsukuttahanashi/</link>
      <pubDate>Mon, 22 Feb 2016 20:19:11 +0900</pubDate>
      
      <guid>/slide/ClojuredeSSPwotsukuttahanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClojureでSSPを作った話
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# SSPとは
-------
※今回作ったものの話なので実際は少し違う

* Supplier Side Platform
* メディアからの広告リクエストを受けて表示権をオークションに掛け、落札された広告を表示する
  0. 広告リクエストを受け取って
  1. 各DSPに競りの通知を投げて
  2. 入札を受け取って
  3. 落札者と落札価格を決めて
  4. 落札通知を出す

===
# アドテクコンペ
---------------

* [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380)
* サイバーエージェントの学生向けインターン
* 3日間、3、4人のチームで **DSP** を作る
* 学生は7チーム、1チームあたり2000q/sを捌くことになってる
* 学生のDSPを繋ぐための **SSP** が必要になったので作ることに。

===
&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/92I5tQt6q6IjII&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/prir/ss-35918532&#34; title=&#34;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&#34; target=&#34;_blank&#34;&gt;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/prir&#34; target=&#34;_blank&#34;&gt;CyberAgent, Inc.&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

===
# 作るもの
----------

* 各DSPに競りの通知(HTTPリクエスト)を投げる大規模HTTPクライアント
  + 各DSPが2000q/s x 7チーム + 落札通知 = 16000q/s
  + 丁度2000q/sになるような制御も必要
* 入札を受けてのオークション、結果のロギングなど
* 管理画面

===
# s7pについて
-------------

* 今回作ったSSP
* [KeenS/s7p](https://github.com/KeenS/s7p)
* Clojure製
* 3日くらいで作った
* やや粗い部分も

===
# 今日話すこと
--------------

* なぜClojureか
* 16000q/s出すための工夫
* 16000q/sに抑えるための制御
* 運用して困った話とか

===

# なぜClojureか

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# なぜClojureか
---------------

* リクエストの数が多いので非同期IOは必須
* 100msでタイムアウトする仕様なのでタイムアウト処理も
* もともとはScala(akka)で作ったs6pがあった
* Actorの設計が良くなかったので遅かった
* あと非同期HTTPクライアントにタイムアウトがなかった
* プロダクションコードを流用したのでインターンが終わった後公開出来なかった
* 別言語で書き直すにあたってGo, Clojure, Common Lisp, Rust, Erlangが検討された
===
# なぜClojureか
---------------

* Common Lisp: 一番慣れてるが、非同期HTTPクライアント(とfutureライブラリ)が使いづらそうなのでやめた
* Rust: とりあえずパフォーマンスは出そうだし使いたかったが非同期HTTPクライアントが見付からなかった
* Clojure: そこそこ慣れてるし速そうな非同期HTTPクライアントがあった。core.asyncで非同期プログラミングもし易い
* Erlang: 恐らく一番向いてるが、ほとんど経験がない
* Go: 結構向いてそうだがあまり経験がないのでClojureを選んだ

===
# 16kq/s出すための工夫
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 16kq/s出すための工夫
------------------------
非同期IO（一部同期しちゃったけど）

``` clojure
(defn work [test req result]
  (-&gt;&gt; @dsps
       (sequence (comp
       ;; 全DSPにPOSTしてから(timeout 100ms)
                  (map (fn [dsp] {:dsp dsp :response (http/post (:url dsp) (json-request-option req))}))
       ;; 結果を待ち合わせる
                  (map destruct)
                  ...))
       ...))
    ....
```

===
# 16kq/s出すための工夫2
------------------------
一部同期したのでとにかくスレッド。スレッドへのディスパッチはチャネルで一発解決。

``` clojure
(defn worker [c]
  (thread
   ...))
```

```clojure
(defn make-workers [ch n]
  (doall (map (fn [_] (core/worker ch)) (range n))))
```

``` clojure
 workers (manage/make-workers ch 1024)
```

===
# 16kq/s出すための工夫3
------------------------
ZeroMQを使ったmaster-slave構成
(最終的にSlave18台)

![master-slave構成図](/images/s7p/s7p.svg)


===
# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------

* DSPの買い付け能力というビジネス的な問題ではなくサーバの負荷という技術的な問題による制御
* 1秒で160kクエリ投げて9秒休むとかは出来ない。もう少し細かく制御する必要がある。
* しかし制御をあまり細かくしすぎると今度はそこで遅くなりそう。
* リクエストを実際に投げるSlaveは分散してるけど統一した制御が必要

===
# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------
Master側で100ms毎にに200個だけZeroMQのキューに積む

![QPS制御の図](/images/s7p/qps_control.svg)

===
# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------
実装にはcore.asyncの `chan` と `timeout` を使用。(非同期プログラミング便利!)

```Clojure
(defn start-query [sender reqs]
  (let [timer (timer 100)]
    (go-loop []
      (let [t (&lt;! timer)
            took (take @qp100ms @reqs)]
        (doall
         (doseq [req took]
           (zmq/send-str sender (json/generate-string req))))
        (swap! reqs #(drop @qp100ms %))
        (if (and t (not (empty? took)))
          (recur)
          (println &#34;request done&#34;))))
    timer))
```

===
# 運用して困った話とか
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 50%&#34;&gt;レスポンスが遅いDSPにSSPのパフォーマンスが引き摺られる&lt;/span&gt;
* DSPが速ければ余裕を見ても10台あれば十分だった
* DSPのパフォーマンスに仮定をおけないので上限ギリギリの18台
* 同期: 「DSP作ってる時はちょっとくらい待ってくれよ、って思ってたけどSSP運用したら遅いDSPガンガン切りたくなる気持分かった」
===
# 運用して困った話とか
---------------------
## パフォーマンス検証が大変
* リクエストを捌くサーバのパフォーマンスをどうするか悩む
* サーバをチューニングすればSSPも速くなるが、検証にならない
* かといって投げたクエリを捌けないサーバに対して検証する訳にもいかない
* 結局安全側に倒したパフォーマンス見積りに。

===
# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 80%&#34;&gt;Masterがログ吐きすぎてDisk Full&lt;/span&gt;
* 最初の予定ではMasterはディスクをそんなに使わなかったのでディスクの小さいインスタンスだった
* ディスクスペース空けてMaster再起動で復旧。焦った。
===
# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 60%&#34;&gt;timeoutし続けるDSPがいてSlave完全沈黙&lt;/span&gt;
* コネクションのクローズ待ちで固まってた
* 該当DSPを切った上でSlaveの再起動で復旧
  * カーネルのチューニングかtimeout頻度の検知が必要そう
* timeoutを考慮に入れた構成にしてた筈なので想定外だった
===
# まとめ
---------

* ClojureでSSP作ったよ
* Clojure使えば非同期プログラミングが簡単に出来るよ
* 運用って大変だよ

===
# 参考
-------

* [KeenS/s7p: sexp version of s6p; a toy SSP.](https://github.com/KeenS/s7p)
* [ClojureでDSPを作った話 | κeenのHappy Hacκing Blog](http://keens.github.io/slide/ClojuredeDSPwotsukuttahanashi/)
* [KeenS/b11d: A toy DSP](https://github.com/KeenS/b11d)
* [アドテクコンペ | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/recruit/fresh/program_detail/id=11303&amp;season=2016)
* [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでReactive Messaging Pattern</title>
      <link>/blog/2015/12/19/clojuredereactive_messaging_pattern</link>
      <pubDate>Sat, 19 Dec 2015 22:30:19 +0900</pubDate>
      
      <guid>/blog/2015/12/19/clojuredereactive_messaging_pattern</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/clojure&#34;&gt;Clojure Advent Calendar 2015&lt;/a&gt;の16日目の記事です（大遅刻）&lt;/p&gt;

&lt;p&gt;κeenです。ここのところ体調優れず、また、特に面白いネタもなくClojure Advent Calendarに遅刻したことをお詫び申し上げます。&lt;/p&gt;

&lt;p&gt;さて、今日はReactive Messaging PatternをClojureのcore.asyncでやってみたいと思います。Reactive Messaging Pattersは、Java/Scala向けActorシステムの&lt;a href=&#34;http://akka.io/&#34;&gt;Akka&lt;/a&gt;の作者が著した本、&lt;a href=&#34;http://www.amazon.co.jp/Reactive-Messaging-Patterns-Actor-Model-ebook/dp/B011S8YC5G&#34;&gt;Amazon.co.jp: Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&lt;/a&gt;で書かれているデザインパターンです。&lt;/p&gt;

&lt;p&gt;非常に興味深い本なのですがScala及びAkka初心者の私には中々辛いので一旦Clojureで試してみようかと。&lt;/p&gt;

&lt;p&gt;ところで、AkkaとClojureのcore.asynkには若干のモデルの違いがあります。詳しくは&lt;a href=&#34;http://blog.paralleluniverse.co/2015/05/21/quasar-vs-akka/&#34;&gt;ここ&lt;/a&gt;とかにあるのですが、一番大きくは非同期/同期モデルの違いがあります。
Akkaの場合はActorにメッセージを送っても届いたという保障はなく(「その瞬間に」届いてないだけでなく、届く前にActorが再起動したらメッセージがロストしてしまう!)、また、メッセージの受信も&lt;code&gt;receive&lt;/code&gt;というコールバック用のメソッドを用意してそこでハンドルすることになります。&lt;/p&gt;

&lt;p&gt;そういう違いがある中でどれだけClojureに翻訳出来るか多少不安ですがチャレンジしてみます。尚、原書には様々なパターンがあるのですが流石に本一冊分全部は紹介し切れないので面白そうでかつClojureでも役立ちそうなものだけ紹介することにします。このコードは原書のものをClojureに翻訳したものではなく、私が勝手に書いたものです。コードを参考にするのは雰囲気程度に留めて、実際を知りたかったら原書を読みましょう。&lt;/p&gt;

&lt;p&gt;今回、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject reactive-message-patterns &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.7.0&amp;quot;]
                 [org.clojure/core.async &amp;quot;0.2.374&amp;quot;]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というプロジェクト設定で試しました。また、ソースコードは&lt;a href=&#34;https://github.com/KeenS/reactive-message-patterns&#34;&gt;こちら&lt;/a&gt;で公開しています。&lt;/p&gt;

&lt;h1 id=&#34;messaging-with-actors&#34;&gt;Messaging With Actors&lt;/h1&gt;

&lt;h2 id=&#34;pipes-and-filters&#34;&gt;Pipes And Filters&lt;/h2&gt;

&lt;p&gt;メッセージが来る際に、そのまま受け取るのではなく一旦Filter用のActorで変換やvalidationをかけて本処理に入ります。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;Clojureなら&lt;code&gt;filter&amp;lt;&lt;/code&gt;/&lt;code&gt;filter&amp;gt;&lt;/code&gt;/ transducerで瞬殺&lt;/del&gt; Filter処理をActorに分離することで並列性やモジュール性が上がります。原書の例ではまずDecrypt Filterを噛ませてAuthenticate Filterで認証出来たら De-dup Filterで重複を取り除いてメッセージをクリーンにしてから処理を始める、とういうように非常に実用的な例が出ています。&lt;/p&gt;

&lt;p&gt;また、(transformでなく、篩い分けの)Filterを分離することでFilterした後の処理、例えばinvalidなメッセージが来たらログに出すなどの柔軟性を得ることが出来ます。&lt;/p&gt;

&lt;p&gt;これを実装してみましょう。すごい適当ですがメッセージが来たらそれを2倍するfilterを作ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(use &#39;clojure.core.async)

(defn filter-actor
  ([f]
   (let [in (chan)
         out (chan)]
     (do
       (filter-actor f in out)
       [in out])))
  ([f in out]
   (go-loop []
     (if-let [v (&amp;lt;! in)]
       (if-let [ret (f v)]
         (if (&amp;gt;! out ret)
           (recur)))
       (close! out)))))

(let [[in out] (filter-actor (fn [x] (* x 2)))]
  (go
    ;; producer
    (doseq [v (range 1 10)]
      (&amp;gt;! in v))
    (close! in))
  (go-loop []
    ;; consumer
    (if-let [v (&amp;lt;! out)]
      (do
        (println v)
        (recur))
      (close! out))))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単ですね。チャネルが終わったかどうか調べるのに一々&lt;code&gt;if-let&lt;/code&gt;を使うのが面倒ですがリストに対する再帰関数もそんな感じなのでまあ、こういうもんなんでしょう。&lt;/p&gt;

&lt;h2 id=&#34;その他&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;他にもMessaging With ActorsにはMessage Router, Message Translator, Message Endpointsなどのパターンが載っているのですが割愛します。特にMessage Translatorは外部システム(HTTPリクエスト、MQ, SQLなど)とのやりとりの話なので簡単に試すには少し重すぎるようです。&lt;/p&gt;

&lt;h1 id=&#34;messaging-channels&#34;&gt;Messaging Channels&lt;/h1&gt;

&lt;p&gt;この章にはActor同士のメッセージのやりとりの方法が色々書かれています。
Point-to-Point Channel, Publish-Subscribe Channel, Datatype Channel, Invalid Message Channel, Dead Letter Channel, Guaranteed Delivery, Channel Adapter, Message Bridge, Message Bus。
中々多くのパターンが載っているのですが一部はAkka固有であったりClojureには必要なかったりしますので、私が興味を持ったものを紹介します。&lt;/p&gt;

&lt;h2 id=&#34;publish-subscribe&#34;&gt;Publish-Subscribe&lt;/h2&gt;

&lt;p&gt;定番ですね。概念自体の説明は不要と思います。core.asyncだとどうなるのかを見てみます。&lt;code&gt;pub&lt;/code&gt;と&lt;code&gt;sub&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [publisher (chan)
      publication (pub publisher :topic)
      subscriber1 (chan)
      subscriber2 (chan)]
  (sub publication :delete subscriber1)
  (sub publication :create subscriber1)

  (sub publication :update subscriber2)
  (sub publication :read subscriber2)

  ;; start subscribers before publish start
  (go-loop [] (when-let [v (&amp;lt;! subscriber1)] (printf &amp;quot;I&#39;m One, got %s\n&amp;quot; (:type v)) (recur)))
  (go-loop [] (when-let [v (&amp;lt;! subscriber2)] (printf &amp;quot;I&#39;m Two, got %s\n&amp;quot; (:type v)) (recur)))

  (go (onto-chan publisher [{:topic :update, :type &amp;quot;dog&amp;quot;}
                            {:topic :create, :type &amp;quot;cat&amp;quot;}
                            {:topic :read  , :type &amp;quot;fox&amp;quot;}]))
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おもちゃのような例ですがこれで動くようです。因みに原書ではここに結構なページ数が割かれていて、分散システムを念頭に、異なるシステムにメッセージを送る話なども扱っています。core.asyncだとそこまでは出来そうにないですね。&lt;/p&gt;

&lt;h2 id=&#34;invalid-message-channel&#34;&gt;Invalid Message Channel&lt;/h2&gt;

&lt;p&gt;とあるActorに予期しないメッセージが届いたらどうしましょうか。そのまま捨てますか？もしかしたらバグを潰せる好機かもしれないのにそのまま捨てるには勿体なすぎます。
かといって全てのActorにデバッグ用のコードを入れていては埒が明かないどころかコードが複雑化してしまいます。そこでInvalid Massage Channelを使いましょう。&lt;/p&gt;

&lt;p&gt;あるActorに予期しないメッセージが届いた時に、全てを放り投げるチャネルを用意しておいて、その先のActorでログを出すなりするのです。&lt;/p&gt;

&lt;p&gt;今回は&lt;code&gt;:price&lt;/code&gt;タグのついていないメッセージが届いた時にinvalid actorに放り投げ、ログを出すものを作りました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn invalid [data]
  {:data data
   :from (Thread/currentThread)})

(let [invalid-chan (chan)
      in (chan)
      tax 0.08]
  ;; invalid message processor
  (go-loop []
    (when-let [{data :data from :from} (&amp;lt;! invalid-chan)]
      (printf &amp;quot;invalid data %s from %s from\n&amp;quot; data from)
      (recur)))

  ;; main processing actor
  (go-loop []
    (when-let [v (&amp;lt;! in)]
      (if-let [price (:price v)]
        (printf &amp;quot;price: %f\n&amp;quot; (* price (+ 1 tax)))
        (&amp;gt;! invalid-chan (invalid v)))
      (recur)))

  (go (onto-chan in [{:goods &amp;quot;はじめてのClojure&amp;quot;
                      :price 1900}
                     {:goods &amp;quot;プログラミングClojure&amp;quot;
                      :price 3400}
                     {:goods &amp;quot;へび&amp;quot;
                      :description &amp;quot;にょろにょろ&amp;quot;}])))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;from&lt;/code&gt;についてはActorならアクターオブジェクトに対してリフレクションかけて何かしらの情報をとれるのですが&lt;code&gt;go&lt;/code&gt;に対するリフレクションが分からなかったので代わりにスレッド情報を使いました。
私はこの章を読んだ時にいたく完動しました。ログの扱いを集約出来るし地味にIOして非同期モデルのアクターの邪魔になるログをそれぞれのアクターに持たなくて済む。
しかしこれのActorが落ちたら、とかこのActor自身にinvalidなメッセージが来たら、とか色々考えたくなります。詳しくは原書を読みましょう。&lt;/p&gt;

&lt;h2 id=&#34;その他-1&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;この章には他にも外部システムと連携するMessage Adapter、外部のメッセージングシステムと連携するMessage Bridge、複数のシステム間でメッセージをやりとりするMessage Busなどが載っていますが割愛します。&lt;/p&gt;

&lt;h1 id=&#34;message-construction&#34;&gt;Message Construction&lt;/h1&gt;

&lt;p&gt;この章にはCommand Message, Document Message, Event Message, Request-Reply, Return Address, Correlation Identifire, Message Sequence, Message Expiration, Format Indicatorなどのメッセージ自体にまつわる話題が載っています。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;疲れてきたため&lt;/del&gt; AkkaやScala特有の話題が多いので1つだけに絞ります。。まあ、だいたいErlangとかやってたら自然と覚えるやつらです。&lt;/p&gt;

&lt;h2 id=&#34;document-message&#34;&gt;Document Message&lt;/h2&gt;

&lt;p&gt;Command MessageやEvent Messageは良く見ますが、Document Messageとはどのようなものでしょうか。原書にはこう書いてあります&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Use a Document Message to convey information to a receiver, but without indicating how the data should be used.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「受取側に情報を伝えはするが、その情報がどのように扱われるべきかを指示しない時にDocument Messageを使います」Command Messageに付随する情報でもなくEvent Messageに付随する情報でもなくただ単なる情報です。&lt;/p&gt;

&lt;p&gt;これは例えばデータベースアダプタのような所で使うことになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [db [{:id 1 :name &amp;quot;Aho&amp;quot;} {:id 2 :name &amp;quot;Ulman&amp;quot;} {:id 3 :name &amp;quot;Sethi&amp;quot;}]
      in (chan)]
  (go-loop []
    (when-let [[id return] (&amp;lt;! in)]
      (&amp;gt;! return (some #(when (= id (:id %) ) %) db))
      (recur)))

  (let [chan-cache (chan)]
    (go-loop [id 1]
      (&amp;gt;! in [id chan-cache])
      (when-let [res (&amp;lt;! chan-cache)]
        (println res)
        (recur (+ id 1))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数のアクセスがあることを考えると双方向チャネルがあるからといってそれ1つを使うのは良くないでしょう。混線してしまいます。今回は返信用のチャネル自身も一緒に送ってしまってそこにDocumentを貰うことにしました。
ActorならActor ID(Ref)を送ることになるでしょう。&lt;/p&gt;

&lt;h1 id=&#34;message-routing&#34;&gt;Message Routing&lt;/h1&gt;

&lt;p&gt;この章は主にAkkaのクラスタ、分散実行に関る内容です。それ自体非常に興味深いのですがClojureだと試せないので飛ばします。
まあ、実際にはクラスタを組まなくてもいくつかのactorを使ってactor群同士でやりとりをすればいいのですが準備が中々面倒ですね。&lt;/p&gt;

&lt;p&gt;一応扱われているトピックを拾うとContent Based Router, Message Filter, Dynamic Router, Recipient List, Splitter,
Aggregator, Resequencer, Composed Message Processor, Scatter-Gather, Routing-Slip, Process Manager, Message Brokerです。
見ての通り非常に数が多く、ページ数もかなり割かれています。そして、よく使いそうなパターンが多く載っています。Scatter-Gatherとか重い処理する時に使いそうなんですけどね。&lt;/p&gt;

&lt;h1 id=&#34;などなど&#34;&gt;などなど&lt;/h1&gt;

&lt;p&gt;ここまでで、4~7章を紹介しました。原書は10章まで続きます(1-3章は何故Actorが必要なのかなどを延々語ってます)が私はこの辺で筆を置くことにします。続きが気になる方は原書をお読み下さい。&lt;/p&gt;

&lt;p&gt;Advent Calendar遅刻して大変申し分けありませんでした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでDSPを作った話</title>
      <link>/slide/ClojuredeDSPwotsukuttahanashi/</link>
      <pubDate>Tue, 27 Oct 2015 21:04:20 +0900</pubDate>
      
      <guid>/slide/ClojuredeDSPwotsukuttahanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClojureでDSPを作った話
----------------------
Lisp Meet Up #3
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

===
# DSPとは
--------

* Demand Side Platform
* 広告主から広告を集めて広告の表示権を競り落し、適切な広告を出す
  0. 広告主を集めて
  1. 競りの通知を受け取って
  2. 一番コスパが良さそうな広告を選んで
  3. 入札して
  4. 落札通知を受け取る
  5. 落札したら広告を出す

===

# ひとりDSP
----------

* AdTech Studioの新卒研修
* 2ヶ月間、業務時間の20%を使ってDSPを作る
  + 実質8営業日
* 業務ロジックを理解することが目的
* 最後に新卒の作ったDSP同士で競争、利益が得点になる
* 他には最終発表での得点も
* **研修なので好きにやっていい**
  + Clojureで書くことに
* サーバーの他は広告主データと学習用データが与えられる


===
&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/92I5tQt6q6IjII&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/prir/ss-35918532&#34; title=&#34;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&#34; target=&#34;_blank&#34;&gt;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/prir&#34; target=&#34;_blank&#34;&gt;CyberAgent, Inc.&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

===
# 作るもの
---------

* 競りの通知を受け取って入札するJSON REST API
* 落札の通知を受け取るJSON REST API
  + 割とシンプル
* 「一番コスパが良さそうな広告を選ぶ」部分は色々と工夫する
* 今回は広告を出すところまではやらない
* クリック情報は落札通知に入ってる

===
# b11dについて
-------------

* 今回作ったDSP
* [KeenS/b11d](https://github.com/KeenS/b11d)
* Clojure製
* 5日くらいで作った
* あまりゴテゴテしない方針
  + 今回パフォーマンスは無視していい
  + Clojureに慣れてないので学習コストも抑えたい
* NginXとAppとMySQL構成+α
* DBは綺麗に設計したい
* 1リクエスト毎にDBを引きにいく素敵仕様

===
# WAP
-----

* Compojure
* Sinatra likeなやつ
* ringの上に乗っかてる
* かなりシンプルな部類だがJSON REST API程度ならこれで十分
* ringミドルウェアのでJSON部分も抽象化
* 学習コストが低いので気軽に始められる

===
# JSONライブラリ
--------------

* ring.middleware.json/wrap-json-{body, response}
  + JSON-&gt;マップとマップ-&gt;JSON
  + bodyの方はキーがStringになるのが微妙
    - セキュリティ的に仕方ない
  + Content-Typeを指定しないと動かない罠
* cheshire
  + 事前データをインポートするのに使った
  + ringのJSONミドルウェアの依存なのでそのまま使った
  + 自然で使い易いAPI

===
# データベース接続
----------------

* java.jdbc
* JDBCのClojure向けラッパ?
* DataSourceを自分で渡すのでコネクションプールも簡単
* SQL手書きしたら良い感じにマップを返してくれる
* Storeはカラムと値の対応を手書き
* 便利マクロもいくつか

===
# データベース接続
----------------

* eager loading面倒問題
  + 入れ子オブジェクトを保存する方も面倒だった
  + ORMの便利さを実感。
* bulk insert難しい問題
  + 実行時可変長引数難しい
* ORMはXXXを使うかJavaのやつをそのまま使う?
* JavaはXMLさえ我慢すれば割と良い奴揃ってる
* しかしレスポンスはマップで欲しいかも

===
# 運用
-----

* warに固めてTomcat vs スタンドアロンなfat jar
* 今回はfat jarを選択
* スタンドアロンだとsupervisordとかでの管理が楽
* Tomcatの運用経験がない
* Jetty中々優秀らしい
* jstatを使ってMackerelでメトリクス取った

===
# 非同期化
---------

* core.async/goで手軽に非同期
* DBへの書き込みを非同期にした
* DB書き込みでエラーが出ても500にならない恐怖
* 最初の方で支払いを記録出来てなくて予算管理が死亡
  + 予算管理失敗ペナルティで、大分点数引かれたらしい
* goroutineでの例外処理どうやるんだろう。

===
# 開発環境
---------

* nREPL + Emacs + CIDER
* 補完の設定上手くいかなかった
* 諸々地味に不便
* 起動遅い
* Emacs側からnREPL立ち上げたい
* サーバーのライブリロード欲しい
* 正解が欲しい


===
# その他Clojureについて
---------------------

* コンスのCarを取るのに`hd`か`head`か`car`か分かんなかった
  + 結局どれでもなくて`first`だった
* 引数のパターンマッチが便利
  + JSON REST APIだとリクエストに何を期待してるのか分かりづらい
  + パターンマッチがドキュメントになる
* やっぱJavaのライブラリ使えるの便利

===
# 落穂拾い
---------

* デプロイにはシェルスクリプト
  + お家芸
* 「一番コスパが良さそうな広告を選んで入札」で統計か機械学習が必要
  + 1回表示した時の収益の期待値を計算する
* 今回は事前データの統計を使った
  + 理想的には機械学習。時間変化についていける
* In Appでオンライン学習出来るライブラリが思ったよりない
  + 分散処理向けの大袈裟なのが多い
  + Weka? liblinear-java?
* 後で考えたらIncanter使えばよかった

===
# まとめ
-------

* 給料貰いながらLisp書いた
* ClojureでDSP作った
* Clojureで機械学習したかったけど間に合わなかった

===
# 参考
------

* [Internal of b11d | κeenのHappy Hacκing Blog](//KeenS.github.io/slide/Internal_of_b11d/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Internal of b11d</title>
      <link>/slide/Internal_of_b11d/</link>
      <pubDate>Mon, 19 Oct 2015 21:33:00 +0900</pubDate>
      
      <guid>/slide/Internal_of_b11d/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Internal of b11d
----------------------
サイバーエージェント新卒研修  
ひとりDSP最終発表会

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdのサーバーサイド（？）エンジニア
 + 趣味でLisp, ML, Shell Scriptあたりを書きます
 + 仕事でScalaとShell Scriptあたりを書きます

===
# 今回作ったもの
----------------

* b11d (ぶらっくんどごーるど)
* Clojure (compojure + middleware)製
  + + NginX + MySQL + Supervisord
* 出来る限りシンプルになるように作った
  + 310行
* デプロイその他はシェルスクリプト
* 監視はmackerel

===
# シンプルということ
-------------------

* アプリケーションは状態を持たない
* IO以外副作用を持たない
* つまり、キャッシュを持たない
  + キャッシュはパフォーマンス上の意味しかない
  + 早過ぎる最適化は諸悪の根源
* スケールアウトが容易
* compojureのミドルウェアを上手く使った

===
# シンプルということ2
--------------------

* データベースはだいたい第4正規形（ﾀﾌﾞﾝ）
  + 全てのカラムは`NOT NULL`
  + 広告主の所だけ拡張性を持たせるために第1正規形に落とした
  + 1広告主に対して複数の広告が持てるようになる
* 外部キー制約も全部付ける
* データが綺麗なのでアプリケーション側でのやることが少ない
* 分析する時にも活きる筈

===
# デプロイ
---------

* 全てシェルスクリプトでオペレーション出来る
* 手作業を無くしてミスを無くす
  + 「あれ？設定書き換えたのに反映されてない」 → 「再起動忘れてた」とかを防ぐ
* ☆秘伝☆のシェルテクニック満載！ 
* アプリケーションが1jarに収まるのでデプロイが楽。

===
# 監視
------

* mackerelで色々モニタリング
* Linux, NginX, MySQL, JVM, レスポンスステータス
* ほとんどMackerelに乗っかることで本質的でないことに労力を割かない
  + 本質 = 業務ロジックを理解すること
* アプリケーションの死活監視にはsupervisord
  + 本当はsystemdでやりたかったけどUbuntuのバージョンが古かった

===
# 落穂拾い
----------

* DBへの書き込みは非同期。Clojureなら簡単に書ける
  + `(go ...)` で囲むだけ
* だいたい1700qps。データが増えると多分もうちょい下がる。
  + キャッシュすればデータに依存しない速度。もう少しパフォーマンスも出る。
* アプリケーションサーバには組込みjettyを使った。
  + War + Tomcatでも出来るがデプロイ/運用が楽なのでこちらを採用
* コア数に対してスケールするのでスケールアップも出来る
* CTR予測は訓練データを 広告主xサイトxUA で統計を取って使う
  + 途中からシグモイド関数で変化をつける

===
# 改善点とか今後とか
---------

* win rate, 入札/落札価格, CTRとかをmackerelでモニタリングしたかった
* 管理画面的なの必要？
* フォールトトラレンス性はないのでその辺
  + MySQLが死ぬとヤバい。
* ホットデプロイしたかった
* 折角JVMだし機械学習したかった
* Unix Domain Socket使うの忘れてた
* データベースにタイムスタンプ入れるの忘れてた………orz

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Clojureおじさん</title>
      <link>/slide/Clojureojisan/</link>
      <pubDate>Mon, 22 Jun 2015 22:53:39 +0900</pubDate>
      
      <guid>/slide/Clojureojisan/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Clojureおじさん
----------------------
サイバーエージント新卒  
第5回 Fresh勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます
===
# Clojure 
---------

* 2007年から
* JVMで動くLisp系言語
* 函数型
* 動的型付き
* 値は基本immutable
* 遅延シーケンス
* STMがあり、並列処理に強い

===
# Hello World
-------------

```clojure
(println &#34;Hello, World&#34;)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# JVM
------
## Javaのコードをシームレスに呼べる

* `obj.method()` ではなく `(.method obj)`
* `Class.staticField` ではなく `Class/staticField`
* `obj.method1().method2()` ではなく `(.. obj method1 method2)`

===
# JVM
-----

```clojure
(.println System/out &#34;Hello JVM&#34;)
```

```clojure
(Math/random)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# Immutable
-----------

* 状態を持たないのでコードの見通しが良い
  + 並列で考える時には重要
  + 複雑さだけでなく不整合などバグの原因になりやすい
* 変更可能な値もある
  + それらはトランザクション内でのみ変更可能
  + 不整合が起きない

===
# 函数型
--------

```clojure
(filter odd? (map #(+ 1 %) &#39;(1 2 3)))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 遅延シーケンス
---------------

```clojure
(def natural_number (iterate inc 1))
(take 5 natural_number) ;=&gt; (1 2 3 4 5)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# リスト内包表記
----------------

```clojure
(for [x (range 5)] (* x x))
;=&gt; (1 4 9 16 25)
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
#並列処理に強い
---------------

* 簡単にはJavaのスレッドを呼べばいい
  + Clojureの関数は全てCallableでRunnablea

```clojure
(.start (Thread. (fn [] 
                   (Thread/sleep 1000)
                   (println &#39;foo))))
```

===
#並列処理に強い
---------------
## core.async

* goroutineとgochannelが使える

===
## core.async
-------------

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (go (&gt;! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! (go (&lt;! c)))))
  (close! c))
```

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (thread (&gt;!! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! c)))
  (close! c))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 今回紹介し切れなかったの
-------------------------

* マクロ
* メタデータ
* protocolとかの多態性
* ClojureScript/Om
* Typed Clojure

===
# まとめ
--------

* Clojureを使えばJavaが使える
* Clojureを使えばPythonのリスト内包表記が使える
* Clojureを使えばGoのgoroutine/gochannelが使える

===

&lt;span style=&#34;font-size:200%;&#34;&gt;Why not start Clojure?&lt;/span&gt;
&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでOpenCV 3.0と戯れる</title>
      <link>/blog/2015/06/07/clojuredeopencv3_0totawamureru</link>
      <pubDate>Sun, 07 Jun 2015 16:56:51 +0900</pubDate>
      
      <guid>/blog/2015/06/07/clojuredeopencv3_0totawamureru</guid>
      <description>

&lt;p&gt;κeenです。先日OpenCV 3.0がリリースされましたね。
ちょっと触ってみようと思ったのですが公式バインディングがC++、C、Java、Pythonと中々つらい言語ばっかりなので扱いやすいClojureから触った時のメモです。&lt;/p&gt;

&lt;p&gt;2系とはAPIが変わってる部分もあるらしく、苦労しました。
UbuntuでやってるのでMacの人は適当に読み替えて下さい。&lt;/p&gt;

&lt;h1 id=&#34;準備&#34;&gt;準備&lt;/h1&gt;

&lt;h2 id=&#34;opencv&#34;&gt;OpenCV&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://opencv.org/&#34;&gt;公式&lt;/a&gt;からOpenCV 3.0をダウンロードしてきましょう。展開してからは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-3.0.0
$ cmake .
$ make -j4
$ sudo make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストールまでしてくれます。&lt;/p&gt;

&lt;h2 id=&#34;imshow&#34;&gt;ImShow&lt;/h2&gt;

&lt;p&gt;どうも3.0からHighguiというQtベースのGUIツール群のJavaバインディングが作られなくなったそうです。Swing使えと。&lt;/p&gt;

&lt;p&gt;ということでOpenCVとSwingのブリッジしてくれる軽いライブラリが&lt;a href=&#34;https://github.com/master-atul/ImShow-Java-OpenCV&#34;&gt;ImShow-Java-OpenCV&lt;/a&gt;
です。.javaファイル1枚なので本当に軽いです。&lt;/p&gt;

&lt;p&gt;.jarもレポジトリに入ってるのですがソースコードより古いらしく、自分でビルドする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:master-atul/ImShow-Java-OpenCV.git
$ cd ImShow-Java-OpenCV/ImShow_JCV/src
$ javac com/atul/JavaOpenCV/Imshow.java
$ jar -cf Imshow.jar com/atul/JavaOpenCV/Imshow.class
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lein-プロジェクト&#34;&gt;lein プロジェクト&lt;/h2&gt;

&lt;p&gt;Clojureのプロジェクト管理ツールの&lt;a href=&#34;http://leiningen.org/&#34;&gt;Leiningen&lt;/a&gt;を使います。知らない人は適当にググって下さい。&lt;/p&gt;

&lt;p&gt;まずプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein new opencv-play
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んで、mavenでいうところのpom.xmlにあたるproject.cljをいじります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-play
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]])
$ edit project.clj
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]
                 [cider/cider-nrepl &amp;quot;0.9.0-SNAPSHOT&amp;quot;]]
  :jvm-opts [&amp;quot;-Djava.library.path=./lib&amp;quot;]
  :resource-paths [&amp;quot;./lib/opencv-300.jar&amp;quot;
                   &amp;quot;./lib/Imshow.jar&amp;quot;]
  :injections [(clojure.lang.RT/loadLibrary org.opencv.core.Core/NATIVE_LIBRARY_NAME)])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしたら先程のライブラリ達を配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir lib
$ cp /usr/local/share/OpenCV/java/* lib
$ cp /path/to/ImShow-Java-OpenCV/ImShow_JCV/src/Imshow.jar lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにlenaも呼びましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir img
$ cp /path/to/src/of/opencv-3.0.0/samples/data/lena.jpg img
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;遊ぶ&#34;&gt;遊ぶ&lt;/h1&gt;

&lt;p&gt;準備完了ってことでREPLを起動しましょう。ちょっと遅いですが我慢。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein repl
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
nREPL server started on port 52301 on host 127.0.0.1 - nrepl://127.0.0.1:52301
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_25-b17
    Docs: (doc function-name-here)
          (find-doc &amp;quot;part-of-name-here&amp;quot;)
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このままREPLを使ってもいいですが私はEmacsから&lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt;でnREPLにつなぎます。
REPLでも補完は効くのでEmacsやらのエディタの設定が面倒ならこのままでも十分ですよ。&lt;/p&gt;

&lt;p&gt;まずは画像のロードから。2系とは違ってImagecodecを使うようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.imgcodecs Imgcodecs])
org.opencv.imgcodecs.Imgcodecs
user&amp;gt; (def lena (Imgcodecs/imread &amp;quot;img/lena.jpg&amp;quot;))
#&#39;user/lena
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いじる前に表示してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [com.atul.JavaOpenCV Imshow])
com.atul.JavaOpenCV.Imshow
user&amp;gt; (def is (Imshow. &amp;quot;Lena&amp;quot;))
#&#39;user/is
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/clojure-opencv/show-lena.png&#34; alt=&#34;lena&#34; /&gt;&lt;/p&gt;

&lt;p&gt;よしよし。表示されましたね。ではこの辺を参考に顔認識してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/woxtu/items/bf39e3d53cbf60396d2c&#34;&gt;Clojure - 二次元絵の顔を検出する - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずは必要なパッケージの読み込み&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core Mat CvType])
org.opencv.core.CvType
user&amp;gt; (import [org.opencv.imgproc Imgproc])
org.opencv.imgproc.Imgproc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前処理のグレースケール変換からヒストグラムの均一化まで一気にやってしまいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def buffer (Mat. 512 512 CvType/CV_8UC3))
#&#39;user/buffer
user&amp;gt; (Imgproc/cvtColor lena buffer Imgproc/COLOR_RGB2GRAY)
nil
user&amp;gt; (Imgproc/equalizeHist buffer buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで一旦画像の確認。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/clojure-opencv/gray-hist-lena.png&#34; alt=&#34;gray-hist-lena&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ふむふむ。ではでは顔を認識しますか。&lt;/p&gt;

&lt;p&gt;まずは色々準備します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core MatOfRect])
org.opencv.core.MatOfRect
user&amp;gt; (import [org.opencv.objdetect CascadeClassifier])
org.opencv.objdetect.CascadeClassifier
user&amp;gt; (def faces (MatOfRect.))
#&#39;user/faces
user&amp;gt; (def classifier (CascadeClassifier.))
#&#39;user/classifier
user&amp;gt; (.load classifier &amp;quot;/usr/local/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml&amp;quot;)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに分類器のデータのロードは成功がtrueで失敗がfalseだそうです。例外投げないんですね。ハマった。パス名に&lt;code&gt;~&lt;/code&gt;を使うと(ホームを省略表記すると)ロードに失敗するようなのでお気をつけて。&lt;/p&gt;

&lt;p&gt;それでは実行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.detectMultiScale classifier buffer faces)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、顔の位置がとれたので画像に重ねるのですがここではSwing(AWT)の描画を使ってみましょう。
OpenCVの描画は画像に描画するのでファイルに書き出しても残っているのに対してSwingのだと表示しているフレームに描画するので書き出した画像には残りません。また、リフレッシュすれば消えるのでインタラクティブに実験するのに向いてます。&lt;/p&gt;

&lt;p&gt;一旦準備。フレームをレナの元画像に戻しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [java.awt Rectangle Color])
java.awt.Color
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImshowのWndowというパブリックなメンバにJFrameが入ってるのでそれを操作します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def g2 (.getGraphics (.Window is)))
#&#39;user/g2
user&amp;gt; (.setColor g2 Color/GREEN)
nil
user&amp;gt; (doseq [face (.toList faces)]
  (let [rect (Rectangle.)]
    (do
      (.setRect rect (.width face) (.height face) (.x face) (.y face))
      (.draw g2 rect))))
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/clojure-opencv/face-recognized-lena.png&#34; alt=&#34;face recognized lena&#34; /&gt;&lt;/p&gt;

&lt;p&gt;パチパチパチ&lt;/p&gt;

&lt;p&gt;因みに四角形を消すには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で十分です。ミスっても何回でもやり直せますね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;因みに3.0のドキュメントが探しづらいのですが、masterにあるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.opencv.org/master/&#34;&gt;OpenCV: OpenCV&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OpenCVをインタラクティブに扱えると楽しいのでみなさんClojure使いましょう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Transducerについて</title>
      <link>/slide/transducernitsuite/</link>
      <pubDate>Wed, 03 Jun 2015 22:29:50 +0900</pubDate>
      
      <guid>/slide/transducernitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Transducerについて
----------------------
サイバーエージェント  
朝の3分スピーチ
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます
===
# Transducerって？
------------------

* Clojure 1.7で入るフレームワーク
* 関数のパイプライン化を簡単にする
* 入力、出力には依存しない

===
# Reduce関数について
-------------------

* `reduce: (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* `(&#39;a -&gt; &#39;b -&gt; &#39;a)` でシーケンスを集約する
* `(reduce + 0 &#39;(1 2 3)) ;=&gt; 6`
* 要はreduceは関数を使って集約する。
===
# Transducerについて
-------------------

* `transduce:((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a)) (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* 集約関数を変換する関数もとる
* `(transduce xf + 0 &#39;(1 2 3))`
* transducerで集約する前に処理を挟める
===
# すごいところ
-------------------------
## コンポーサビリティ

* `((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a))`
* 変換関数は入力と出力が同じ。
* つまり変換関数を合成出来る
* ex) `(comp (filter odd?) (map inc))`

===
# すごいところ2
--------------------------
## 汎用性

* 各関数は入力や出力について知る必要はない
  + シーケンスではなく要素に対して定義される
* シーケンスだけでなく遅延シーケンス、ストリーム、チャネルなどなどにも使える
* 中間シーケンスを作らない
  + 遅延シーケンスやストリームには大きなメリット
* 集約先をシーケンスなどにすることも出来る
  + 関数の汎用性が上がる
===
# すごいところ3
--------------
## 並列/非同期

* core.asyncもtransducerをサポート
* 各変換関数を並列/非同期に実行が可能
* さらに各関数に割り当てるプロセッサの数も細かく制御出来る

===
&lt;span style=&#34;font-size: 500%;&#34;&gt;変換して&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;span style=&#34;font-size: 500%;&#34;&gt;集約する&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;span style=&#34;font-size: 300%;&#34;&gt;何かに似てない？&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;span style=&#34;font-size: 600%;&#34;&gt;MapReduce&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; ozaさんの近しい環境というとHadoop...多段Mapreduceをtransdecerみたいにしようってはなしとかですか？&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605368356393218048&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; まさにその通りです．MapReduce には Combiner という中間集約をする API があるのですが，それをもっと汎用的にしようという話です． &lt;a href=&#34;http://t.co/injEiPjePG&#34;&gt;http://t.co/injEiPjePG&lt;/a&gt;&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605369771505221633&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; すごい楽しそうですね。Clojure向けのAPIがtransducerのバッグエンドになって普段書いてるコードがそのままHadoopで動いたりしたら、とか夢が無限に広がります&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605370461476646912&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; おお，その案は良いですね！！&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605370619509637121&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;span style=&#34;font-size: 200%;&#34;&gt;Clojure 1.7 + Transducer&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;span style=&#34;font-size: 400%;&#34;&gt;Comming Soon&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 参考
------
* [Clojure 1.7のtransducersを動かしてみよう - Qiita](http://qiita.com/tokomakoma123/items/1ca3fb0dddc5b901b032)
* [core.async+transducers Shibuya.lisp #21](http://www.slideshare.net/ktsujister/coreasynctransducers-shibuyalisp-21)
* [Hadoop Combinerメモ(Hishidama&#39;s Hadoop Combiner Memo)](http://www.ne.jp/asahi/hishidama/home/tech/apache/hadoop/Combiner.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>