<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clojure on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/clojure/</link>
    <description>Recent content in Clojure on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 Oct 2015 21:33:00 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/clojure/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Internal of b11d</title>
      <link>http://keens.github.io/slide/Internal_of_b11d/</link>
      <pubDate>Mon, 19 Oct 2015 21:33:00 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Internal_of_b11d/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Internal of b11d
----------------------
サイバーエージェント新卒研修  
ひとりDSP最終発表会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdのサーバーサイド（？）エンジニア
 + 趣味でLisp, ML, Shell Scriptあたりを書きます
 + 仕事でScalaとShell Scriptあたりを書きます


# 今回作ったもの
----------------

* b11d (ぶらっくんどごーるど)
* Clojure (compojure + middleware)製
  + + NginX + MySQL + Supervisord
* 出来る限りシンプルになるように作った
  + 310行
* デプロイその他はシェルスクリプト
* 監視はmackerel


# シンプルということ
-------------------

* アプリケーションは状態を持たない
* IO以外副作用を持たない
* つまり、キャッシュを持たない
  + キャッシュはパフォーマンス上の意味しかない
  + 早過ぎる最適化は諸悪の根源
* スケールアウトが容易
* compojureのミドルウェアを上手く使った


# シンプルということ2
--------------------

* データベースはだいたい第4正規形（ﾀﾌﾞﾝ）
  + 全てのカラムは`NOT NULL`
  + 広告主の所を拡張性を持たせるために第1正規形に落とした
  + 1広告主に対して複数の広告が持てるようになる
* 外部キー制約も全部付ける
* データが綺麗なのでアプリケーション側でのやることが少ない
* 分析する時にも活きる筈


# デプロイ
---------

* 全てシェルスクリプトでオペレーション出来る
* 手作業を無くしてミスを無くす
  + 「あれ？設定書き換えたのに反映されてない」 → 「再起動忘れてた」とかを防ぐ
* ☆秘伝☆のシェルテクニック満載！ 
* アプリケーションが1jarに収まるのでデプロイが楽。


# 監視
------

* mackerelで色々モニタリング
* Linux, NginX, MySQL, JVM, レスポンスステータス
* ほとんどMackerelに乗っかることで本質的でないことに労力を割かない
  + 本質 = 業務ロジックを理解すること
* アプリケーションの死活監視にはsupervisord
  + 本当はsystemdでやりたかったけどUbuntuのバージョンが古かった


# 落穂拾い
----------

* DBへの書き込みは非同期。Clojureなら簡単に書ける
  + `(go ...)` で囲むだけ
* だいたい600qps。データが増えると多分もうちょい下がる。
  + キャッシュすればデータに依存しない速度。もう少しパフォーマンスも出る。
* アプリケーションサーバには組込みjettyを使った。
  + War + Tomcatでも出来るがデプロイ/運用が楽なのでこちらを採用
* コア数に対してスケールするのでスケールアップも出来る
* CTR予測は訓練データを 広告主xサイトxUA で統計を取って使う
  + 動的に変化しない


# 改善点とか今後とか
---------

* win rate, 入札/落札価格, CTRとかをmackerelでモニタリングしたかった
* 管理画面的なの必要？
* フォールトトラレンス性はないのでその辺
  + MySQLが死ぬとヤバい。
* ホットデプロイしたかった
* 折角JVMだし機械学習したかった
* Unix Domain Socket使うの忘れてた
* データベースにタイムスタンプ入れるの忘れてた………orz

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Clojureおじさん</title>
      <link>http://keens.github.io/slide/Clojureojisan/</link>
      <pubDate>Mon, 22 Jun 2015 22:53:39 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Clojureojisan/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Clojureおじさん
----------------------
サイバーエージント新卒  
第5回 Fresh勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# Clojure 
---------

* 2007年から
* JVMで動くLisp系言語
* 函数型
* 動的型付き
* 値は基本immutable
* 遅延シーケンス
* STMがあり、並列処理に強い


# Hello World
-------------

```clojure
(println &#34;Hello, World&#34;)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# JVM
------
## Javaのコードをシームレスに呼べる

* `obj.method()` ではなく `(.method obj)`
* `Class.staticField` ではなく `Class/staticField`
* `obj.method1().method2()` ではなく `(.. obj method1 method2)`


# JVM
-----

```clojure
(.println System/out &#34;Hello JVM&#34;)
```

```clojure
(Math/random)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Immutable
-----------

* 状態を持たないのでコードの見通しが良い
  + 並列で考える時には重要
  + 複雑さだけでなく不整合などバグの原因になりやすい
* 変更可能な値もある
  + それらはトランザクション内でのみ変更可能
  + 不整合が起きない


# 函数型
--------

```clojure
(filter odd? (map #(+ 1 %) &#39;(1 2 3)))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 遅延シーケンス
---------------

```clojure
(def natural_number (iterate inc 1))
(take 5 natural_number) ;=&gt; (1 2 3 4 5)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# リスト内包表記
----------------

```clojure
(for [x (range 5)] (* x x))
;=&gt; (1 4 9 16 25)
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;


#並列処理に強い
---------------

* 簡単にはJavaのスレッドを呼べばいい
  + Clojureの関数は全てCallableでRunnablea

```clojure
(.start (Thread. (fn [] 
                   (Thread/sleep 1000)
                   (println &#39;foo))))
```


#並列処理に強い
---------------
## core.async

* goroutineとgochannelが使える


## core.async
-------------

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (go (&gt;! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! (go (&lt;! c)))))
  (close! c))
```

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (thread (&gt;!! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! c)))
  (close! c))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 今回紹介し切れなかったの
-------------------------

* マクロ
* メタデータ
* protocolとかの多態性
* ClojureScript/Om
* Typed Clojure


# まとめ
--------

* Clojureを使えばJavaが使える
* Clojureを使えばPythonのリスト内包表記が使える
* Clojureを使えばGoのgoroutine/gochannelが使える



&lt;span style=&#34;font-size:200%;&#34;&gt;Why not start Clojure?&lt;/span&gt;
&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでOpenCV 3.0と戯れる</title>
      <link>http://keens.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru</link>
      <pubDate>Sun, 07 Jun 2015 16:56:51 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru</guid>
      <description>

&lt;p&gt;κeenです。先日OpenCV 3.0がリリースされましたね。
ちょっと触ってみようと思ったのですが公式バインディングがC++、C、Java、Pythonと中々つらい言語ばっかりなので扱いやすいClojureから触った時のメモです。&lt;/p&gt;

&lt;p&gt;2系とはAPIが変わってる部分もあるらしく、苦労しました。
UbuntuでやってるのでMacの人は適当に読み替えて下さい。&lt;/p&gt;

&lt;h1 id=&#34;準備:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;準備&lt;/h1&gt;

&lt;h2 id=&#34;opencv:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;OpenCV&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://opencv.org/&#34;&gt;公式&lt;/a&gt;からOpenCV 3.0をダウンロードしてきましょう。展開してからは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-3.0.0
$ cmake .
$ make -j4
$ sudo make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストールまでしてくれます。&lt;/p&gt;

&lt;h2 id=&#34;imshow:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;ImShow&lt;/h2&gt;

&lt;p&gt;どうも3.0からHighguiというQtベースのGUIツール群のJavaバインディングが作られなくなったそうです。Swing使えと。&lt;/p&gt;

&lt;p&gt;ということでOpenCVとSwingのブリッジしてくれる軽いライブラリが&lt;a href=&#34;https://github.com/master-atul/ImShow-Java-OpenCV&#34;&gt;ImShow-Java-OpenCV&lt;/a&gt;
です。.javaファイル1枚なので本当に軽いです。&lt;/p&gt;

&lt;p&gt;.jarもレポジトリに入ってるのですがソースコードより古いらしく、自分でビルドする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:master-atul/ImShow-Java-OpenCV.git
$ cd ImShow-Java-OpenCV/ImShow_JCV/src
$ javac com/atul/JavaOpenCV/Imshow.java
$ jar -cf Imshow.jar com/atul/JavaOpenCV/Imshow.class
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lein-プロジェクト:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;lein プロジェクト&lt;/h2&gt;

&lt;p&gt;Clojureのプロジェクト管理ツールの&lt;a href=&#34;http://leiningen.org/&#34;&gt;Leiningen&lt;/a&gt;を使います。知らない人は適当にググって下さい。&lt;/p&gt;

&lt;p&gt;まずプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein new opencv-play
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んで、mavenでいうところのpom.xmlにあたるproject.cljをいじります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-play
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]])
$ edit project.clj
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]
                 [cider/cider-nrepl &amp;quot;0.9.0-SNAPSHOT&amp;quot;]]
  :jvm-opts [&amp;quot;-Djava.library.path=./lib&amp;quot;]
  :resource-paths [&amp;quot;./lib/opencv-300.jar&amp;quot;
                   &amp;quot;./lib/Imshow.jar&amp;quot;]
  :injections [(clojure.lang.RT/loadLibrary org.opencv.core.Core/NATIVE_LIBRARY_NAME)])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしたら先程のライブラリ達を配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir lib
$ cp /usr/local/share/OpenCV/java/* lib
$ cp /path/to/ImShow-Java-OpenCV/ImShow_JCV/src/Imshow.jar lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにlenaも呼びましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir img
$ cp /path/to/src/of/opencv-3.0.0/samples/data/lena.jpg img
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;遊ぶ:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;遊ぶ&lt;/h1&gt;

&lt;p&gt;準備完了ってことでREPLを起動しましょう。ちょっと遅いですが我慢。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein repl
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
nREPL server started on port 52301 on host 127.0.0.1 - nrepl://127.0.0.1:52301
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_25-b17
    Docs: (doc function-name-here)
          (find-doc &amp;quot;part-of-name-here&amp;quot;)
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このままREPLを使ってもいいですが私はEmacsから&lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt;でnREPLにつなぎます。
REPLでも補完は効くのでEmacsやらのエディタの設定が面倒ならこのままでも十分ですよ。&lt;/p&gt;

&lt;p&gt;まずは画像のロードから。2系とは違ってImagecodecを使うようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.imgcodecs Imgcodecs])
org.opencv.imgcodecs.Imgcodecs
user&amp;gt; (def lena (Imgcodecs/imread &amp;quot;img/lena.jpg&amp;quot;))
#&#39;user/lena
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いじる前に表示してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [com.atul.JavaOpenCV Imshow])
com.atul.JavaOpenCV.Imshow
user&amp;gt; (def is (Imshow. &amp;quot;Lena&amp;quot;))
#&#39;user/is
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/show-lena.png&#34; alt=&#34;lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;よしよし。表示されましたね。ではこの辺を参考に顔認識してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/woxtu/items/bf39e3d53cbf60396d2c&#34;&gt;Clojure - 二次元絵の顔を検出する - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずは必要なパッケージの読み込み&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core Mat CvType])
org.opencv.core.CvType
user&amp;gt; (import [org.opencv.imgproc Imgproc])
org.opencv.imgproc.Imgproc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前処理のグレースケール変換からヒストグラムの均一化まで一気にやってしまいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def buffer (Mat. 512 512 CvType/CV_8UC3))
#&#39;user/buffer
user&amp;gt; (Imgproc/cvtColor lena buffer Imgproc/COLOR_RGB2GRAY)
nil
user&amp;gt; (Imgproc/equalizeHist buffer buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで一旦画像の確認。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/gray-hist-lena.png&#34; alt=&#34;gray-hist-lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ふむふむ。ではでは顔を認識しますか。&lt;/p&gt;

&lt;p&gt;まずは色々準備します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core MatOfRect])
org.opencv.core.MatOfRect
user&amp;gt; (import [org.opencv.objdetect CascadeClassifier])
org.opencv.objdetect.CascadeClassifier
user&amp;gt; (def faces (MatOfRect.))
#&#39;user/faces
user&amp;gt; (def classifier (CascadeClassifier.))
#&#39;user/classifier
user&amp;gt; (.load classifier &amp;quot;/usr/local/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml&amp;quot;)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに分類器のデータのロードは成功がtrueで失敗がfalseだそうです。例外投げないんですね。ハマった。パス名に&lt;code&gt;~&lt;/code&gt;を使うと(ホームを省略表記すると)ロードに失敗するようなのでお気をつけて。&lt;/p&gt;

&lt;p&gt;それでは実行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.detectMultiScale classifier buffer faces)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、顔の位置がとれたので画像に重ねるのですがここではSwing(AWT)の描画を使ってみましょう。
OpenCVの描画は画像に描画するのでファイルに書き出しても残っているのに対してSwingのだと表示しているフレームに描画するので書き出した画像には残りません。また、リフレッシュすれば消えるのでインタラクティブに実験するのに向いてます。&lt;/p&gt;

&lt;p&gt;一旦準備。フレームをレナの元画像に戻しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [java.awt Rectangle Color])
java.awt.Color
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImshowのWndowというパブリックなメンバにJFrameが入ってるのでそれを操作します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def g2 (.getGraphics (.Window is)))
#&#39;user/g2
user&amp;gt; (.setColor g2 Color/GREEN)
nil
user&amp;gt; (doseq [face (.toList faces)]
  (let [rect (Rectangle.)]
    (do
      (.setRect rect (.width face) (.height face) (.x face) (.y face))
      (.draw g2 rect))))
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/face-recognized-lena.png&#34; alt=&#34;face recognized lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;パチパチパチ&lt;/p&gt;

&lt;p&gt;因みに四角形を消すには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で十分です。ミスっても何回でもやり直せますね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;因みに3.0のドキュメントが探しづらいのですが、masterにあるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.opencv.org/master/&#34;&gt;OpenCV: OpenCV&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OpenCVをインタラクティブに扱えると楽しいのでみなさんClojure使いましょう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Transducerについて</title>
      <link>http://keens.github.io/slide/transducernitsuite/</link>
      <pubDate>Wed, 03 Jun 2015 22:29:50 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/transducernitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Transducerについて
----------------------
サイバーエージェント  
朝の3分スピーチ
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# Transducerって？
------------------

* Clojure 1.7で入るフレームワーク
* 関数のパイプライン化を簡単にする
* 入力、出力には依存しない


# Reduce関数について
-------------------

* `reduce: (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* `(&#39;a -&gt; &#39;b -&gt; &#39;a)` でシーケンスを集約する
* `(reduce + 0 &#39;(1 2 3)) ;=&gt; 6`
* 要はreduceは関数を使って集約する。

# Transducerについて
-------------------

* `transduce:((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a)) (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* 集約関数を変換する関数もとる
* `(transduce xf + 0 &#39;(1 2 3))`
* transducerで集約する前に処理を挟める

# すごいところ
-------------------------
## コンポーサビリティ

* `((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a))`
* 変換関数は入力と出力が同じ。
* つまり変換関数を合成出来る
* ex) `(comp (filter odd?) (map inc))`


# すごいところ2
--------------------------
## 汎用性

* 各関数は入力や出力について知る必要はない
  + シーケンスではなく要素に対して定義される
* シーケンスだけでなく遅延シーケンス、ストリーム、チャネルなどなどにも使える
* 中間シーケンスを作らない
  + 遅延シーケンスやストリームには大きなメリット
* 集約先をシーケンスなどにすることも出来る
  + 関数の汎用性が上がる

# すごいところ3
--------------
## 並列/非同期

* core.asyncもtransducerをサポート
* 各変換関数を並列/非同期に実行が可能
* さらに各関数に割り当てるプロセッサの数も細かく制御出来る


&lt;span style=&#34;font-size: 500%;&#34;&gt;変換して&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 500%;&#34;&gt;集約する&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 300%;&#34;&gt;何かに似てない？&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 600%;&#34;&gt;MapReduce&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; ozaさんの近しい環境というとHadoop...多段Mapreduceをtransdecerみたいにしようってはなしとかですか？&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605368356393218048&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; まさにその通りです．MapReduce には Combiner という中間集約をする API があるのですが，それをもっと汎用的にしようという話です． &lt;a href=&#34;http://t.co/injEiPjePG&#34;&gt;http://t.co/injEiPjePG&lt;/a&gt;&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605369771505221633&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; すごい楽しそうですね。Clojure向けのAPIがtransducerのバッグエンドになって普段書いてるコードがそのままHadoopで動いたりしたら、とか夢が無限に広がります&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605370461476646912&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; おお，その案は良いですね！！&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605370619509637121&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 200%;&#34;&gt;Clojure 1.7 + Transducer&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 400%;&#34;&gt;Comming Soon&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 参考
------
* [Clojure 1.7のtransducersを動かしてみよう - Qiita](http://qiita.com/tokomakoma123/items/1ca3fb0dddc5b901b032)
* [core.async+transducers Shibuya.lisp #21](http://www.slideshare.net/ktsujister/coreasynctransducers-shibuyalisp-21)
* [Hadoop Combinerメモ(Hishidama&#39;s Hadoop Combiner Memo)](http://www.ne.jp/asahi/hishidama/home/tech/apache/hadoop/Combiner.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>