<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clojure on κeenのHappy Hacκing Blog</title>
    <link>//KeenS.github.io/categories/clojure/</link>
    <description>Recent content in Clojure on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Mon, 22 Feb 2016 20:19:11 +0900</lastBuildDate>
    
	<atom:link href="//KeenS.github.io/categories/clojure/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ClojureでSSPを作った話</title>
      <link>//KeenS.github.io/slide/clojuredesspwotsukuttahanashi/</link>
      <pubDate>Mon, 22 Feb 2016 20:19:11 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/clojuredesspwotsukuttahanashi/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
SSPとは  ※今回作ったものの話なので実際は少し違う
 Supplier Side Platform メディアからの広告リクエストを受けて表示権をオークションに掛け、落札された広告を表示する 0. 広告リクエストを受け取って  各DSPに競りの通知を投げて 入札を受け取って 落札者と落札価格を決めて 落札通知を出す    ===
アドテクコンペ   ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント サイバーエージェントの学生向けインターン 3日間、3、4人のチームで DSP を作る 学生は7チーム、1チームあたり2000q/sを捌くことになってる 学生のDSPを繋ぐための SSP が必要になったので作ることに。  ===
===
作るもの   各DSPに競りの通知(HTTPリクエスト)を投げる大規模HTTPクライアント  各DSPが2000q/s x 7チーム + 落札通知 = 16000q/s 丁度2000q/sになるような制御も必要   入札を受けてのオークション、結果のロギングなど 管理画面  ===</description>
    </item>
    
    <item>
      <title>ClojureでReactive Messaging Pattern</title>
      <link>//KeenS.github.io/blog/2015/12/19/clojuredereactive_messaging_pattern/</link>
      <pubDate>Sat, 19 Dec 2015 22:30:19 +0900</pubDate>
      
      <guid>//KeenS.github.io/blog/2015/12/19/clojuredereactive_messaging_pattern/</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/clojure&#34;&gt;Clojure Advent Calendar 2015&lt;/a&gt;の16日目の記事です（大遅刻）&lt;/p&gt;
&lt;p&gt;κeenです。ここのところ体調優れず、また、特に面白いネタもなくClojure Advent Calendarに遅刻したことをお詫び申し上げます。&lt;/p&gt;
&lt;p&gt;さて、今日はReactive Messaging PatternをClojureのcore.asyncでやってみたいと思います。Reactive Messaging Pattersは、Java/Scala向けActorシステムの&lt;a href=&#34;http://akka.io/&#34;&gt;Akka&lt;/a&gt;の作者が著した本、&lt;a href=&#34;http://www.amazon.co.jp/Reactive-Messaging-Patterns-Actor-Model-ebook/dp/B011S8YC5G&#34;&gt;Amazon.co.jp: Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&lt;/a&gt;で書かれているデザインパターンです。&lt;/p&gt;
&lt;p&gt;非常に興味深い本なのですがScala及びAkka初心者の私には中々辛いので一旦Clojureで試してみようかと。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ClojureでDSPを作った話</title>
      <link>//KeenS.github.io/slide/clojurededspwotsukuttahanashi/</link>
      <pubDate>Tue, 27 Oct 2015 21:04:20 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/clojurededspwotsukuttahanashi/</guid>
      <description>κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Shell Scriptあたりを書きます  ===
DSPとは   Demand Side Platform 広告主から広告を集めて広告の表示権を競り落し、適切な広告を出す 0. 広告主を集めて  競りの通知を受け取って 一番コスパが良さそうな広告を選んで 入札して 落札通知を受け取る 落札したら広告を出す    ===
ひとりDSP   AdTech Studioの新卒研修 2ヶ月間、業務時間の20%を使ってDSPを作る  実質8営業日   業務ロジックを理解することが目的 最後に新卒の作ったDSP同士で競争、利益が得点になる 他には最終発表での得点も 研修なので好きにやっていい  Clojureで書くことに   サーバーの他は広告主データと学習用データが与えられる  ===
===
作るもの   競りの通知を受け取って入札するJSON REST API 落札の通知を受け取るJSON REST API  割とシンプル   「一番コスパが良さそうな広告を選ぶ」部分は色々と工夫する 今回は広告を出すところまではやらない クリック情報は落札通知に入ってる  ===</description>
    </item>
    
    <item>
      <title>Internal of b11d</title>
      <link>//KeenS.github.io/slide/internal_of_b11d/</link>
      <pubDate>Mon, 19 Oct 2015 21:33:00 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/internal_of_b11d/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS AMoAdのサーバーサイド（？）エンジニア 趣味でLisp, ML, Shell Scriptあたりを書きます 仕事でScalaとShell Scriptあたりを書きます  ===
今回作ったもの   b11d (ぶらっくんどごーるど) Clojure (compojure + middleware)製    NginX + MySQL + Supervisord     出来る限りシンプルになるように作った  310行   デプロイその他はシェルスクリプト 監視はmackerel  ===
シンプルということ   アプリケーションは状態を持たない IO以外副作用を持たない つまり、キャッシュを持たない  キャッシュはパフォーマンス上の意味しかない 早過ぎる最適化は諸悪の根源   スケールアウトが容易 compojureのミドルウェアを上手く使った  ===
シンプルということ2   データベースはだいたい第4正規形（ﾀﾌﾞﾝ）  全てのカラムはNOT NULL 広告主の所だけ拡張性を持たせるために第1正規形に落とした 1広告主に対して複数の広告が持てるようになる   外部キー制約も全部付ける データが綺麗なのでアプリケーション側でのやることが少ない 分析する時にも活きる筈  ===</description>
    </item>
    
    <item>
      <title>Clojureおじさん</title>
      <link>//KeenS.github.io/slide/clojureojisan/</link>
      <pubDate>Mon, 22 Jun 2015 22:53:39 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/clojureojisan/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます ===  Clojure   2007年から JVMで動くLisp系言語 函数型 動的型付き 値は基本immutable 遅延シーケンス STMがあり、並列処理に強い  ===
Hello World  (println &amp;#34;Hello, World&amp;#34;) ===
JVM  Javaのコードをシームレスに呼べる  obj.method() ではなく (.method obj) Class.staticField ではなく Class/staticField obj.method1().method2() ではなく (.. obj method1 method2)  ===
JVM  (.println System/out &amp;#34;Hello JVM&amp;#34;) (Math/random) ===
Immutable   状態を持たないのでコードの見通しが良い  並列で考える時には重要 複雑さだけでなく不整合などバグの原因になりやすい   変更可能な値もある  それらはトランザクション内でのみ変更可能 不整合が起きない    ===</description>
    </item>
    
    <item>
      <title>ClojureでOpenCV 3.0と戯れる</title>
      <link>//KeenS.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru/</link>
      <pubDate>Sun, 07 Jun 2015 16:56:51 +0900</pubDate>
      
      <guid>//KeenS.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru/</guid>
      <description>&lt;p&gt;κeenです。先日OpenCV 3.0がリリースされましたね。
ちょっと触ってみようと思ったのですが公式バインディングがC++、C、Java、Pythonと中々つらい言語ばっかりなので扱いやすいClojureから触った時のメモです。&lt;/p&gt;
&lt;p&gt;2系とはAPIが変わってる部分もあるらしく、苦労しました。
UbuntuでやってるのでMacの人は適当に読み替えて下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Transducerについて</title>
      <link>//KeenS.github.io/slide/transducernitsuite/</link>
      <pubDate>Wed, 03 Jun 2015 22:29:50 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/transducernitsuite/</guid>
      <description>κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます ===  Transducerって？   Clojure 1.7で入るフレームワーク 関数のパイプライン化を簡単にする 入力、出力には依存しない  ===
Reduce関数について   reduce: (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) &#39;a -&amp;gt; &#39;b list (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) でシーケンスを集約する (reduce + 0 &#39;(1 2 3)) ;=&amp;gt; 6 要はreduceは関数を使って集約する。 ===  Transducerについて   transduce:((&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) -&amp;gt; (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a)) (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) &#39;a -&amp;gt; &#39;b list 集約関数を変換する関数もとる (transduce xf + 0 &#39;(1 2 3)) transducerで集約する前に処理を挟める ===  すごいところ  コンポーサビリティ  ((&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) -&amp;gt; (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a)) 変換関数は入力と出力が同じ。 つまり変換関数を合成出来る ex) (comp (filter odd?</description>
    </item>
    
  </channel>
</rss>