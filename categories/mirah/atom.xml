<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mirah | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/mirah/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-10-20T22:57:11+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mirah 0.1.3がリリースされました]]></title>
    <link href="http://KeenS.github.io/blog/2014/08/07/mirah-0-dot-1-3/"/>
    <updated>2014-08-07T23:52:15+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/08/07/mirah-0-dot-1-3</id>
    <content type="html"><![CDATA[<p>本日2回目のκeenです。次はRuby-likeな文法でJavaが書けるMirah言語の0.1.3がリリースたのでこれを期にMirahの紹介をします。</p>

<!-- more -->


<h1>Mirahとは？</h1>

<p><a href="http://mirah.org">公式ページ</a>。JRubyの開発者がJRubyのためにJavaを書くのが嫌になったという理由で作り始めた言語です。2008年にスタートだったかな？JRubyの開発の片手間に開発してるのでコミットペースはゆっくりです。</p>

<p><a href="https://github.com/mirah/mirah">github</a>のREADMEから引用すると、</p>

<ul>
<li>Ruby-like シンタックス</li>
<li>.classにコンパイルされる</li>
<li>Javaと同じスピード</li>
<li>ランタイムライブラリ必要なし</li>
</ul>


<p>な言語です。私的には</p>

<ul>
<li>型推論がある</li>
<li>マクロがある</li>
<li>面倒な部分はコンパイラが補ってくれる</li>
</ul>


<p>、Javaです。多くのJVM上の言語は独自言語+Java FFIって感じですが、Mirahは文法をRuby風にしただけで、吐かれるバイトコードはJavaコンパイラが吐くのものと等価です。</p>

<h1>サンプルコード</h1>

<p>一番Javaっぽいコードを見せましょう。ファイル名は<code>HelloWorld.mirah</code>の他に<code>hello_world.mirah</code>でも構いません。</p>

<p>```ruby
class HelloWorld
  def self.main(args:String[]):void</p>

<pre><code>System.out.println("Hello World")
</code></pre>

<p>  end
end
```</p>

<p>まあ、Javaですね。JavaのstaticメソッドとRubyのクラスメソッドが対応しています。これをMirahの機能を使って書き換えていきます。</p>

<h2>暗黙のクラス</h2>

<p>ファイル名からクラス名が推測出来るので省略することが出来ます。すなわち、トップレベルのメソッド定義は推測されたクラス内でのメソッド定義として扱われます。</p>

<p><code>ruby
def self.main(args:String[]):void
  System.out.println("Hello World")
end
</code></p>

<p>これでも動きます。</p>

<h2>暗黙のmain</h2>

<p>トップレベルの式はmain内のものとして扱われます。</p>

<p><code>ruby
System.out.println("Hello World")
</code></p>

<p>こうも書けることになります。ただし、argsにアクセス出来ないので複雑なことをやりたかったら大人しく<code>self.main</code>を書きましょう。</p>

<h2>putsマクロ</h2>

<p>mirahには組込みで<code>puts</code>というマクロが定義されています。これはコンパイル時に<code>System.out.println</code>に展開されます。</p>

<p><code>ruby
puts "Hello World"
</code></p>

<p>こう書けます。ここまでくるとRubyと同じコードになりますね。あ、()が省略可能なのは良いですよね。Ruby系の言語ではよくあることです。</p>

<h1>もうちょっとサンプル</h1>

<p>mirah/exmpleから面白いのを拾ってきます。だいたいRubyです。</p>

<h2>リテラル</h2>

<p>ほぼRubyです。つまり、<code>[]</code>が配列ではなくArrayListになってます。尚、自動でintがIntegerに変換されてます。
また、hashはHashMapです。</p>

<p><code>ruby
str = 'non-interpolated string'
str2 = "interpolated is better than #{str}"
heredoc = &lt;&lt;EOS
this is a here doc
EOS
int = 42
char = ?a
float = 3.14159265358979323846264
regex = /\d(cow)+\w\\/  # in Java, this would be "\\\\d(cow)+\\\\w\\\\\\\\"
regex2 = /interpolated #{regex}/
list = [1, 2, 3]
list[2] = 4
array = byte[5]
array[0] = byte(0)
hash = { "one" =&gt; 1, "two" =&gt; 2 }
hash["three"] = 3
</code></p>

<h2>修飾import</h2>

<p><code>ruby
import java.util.HashMap as H
</code>
って書けます</p>

<h2>型推論</h2>

<p>Swingの例です。変数の型を書いてないことに注目して下さい。</p>

<p>```ruby
import javax.swing.JFrame
import javax.swing.JButton</p>

<h1>FIXME blocks need to be inside a MethodDefinition, but main doesn&rsquo;t</h1>

<h1>have one.</h1>

<p>def self.run
  frame = JFrame.new &ldquo;Welcome to Mirah&rdquo;
  frame.setSize 300, 300
  frame.setVisible true</p>

<p>  button = JButton.new &ldquo;Press me&rdquo;
  frame.add button
  frame.show</p>

<p>  button.addActionListener do |event|</p>

<pre><code>JButton(event.getSource).setText "Mirah Rocks!"
</code></pre>

<p>  end
end</p>

<p>run
```</p>

<h2>暗黙のInterface及び暗黙のabstractメソッド</h2>

<p>先のSwingの例を良く見て下さい。この部分です。</p>

<p>```ruby
  button.addActionListener do |event|</p>

<pre><code>JButton(event.getSource).setText "Mirah Rocks!"
</code></pre>

<p>  end
```</p>

<p>Javaだと</p>

<p>```java
button.addactionlistener(new ActionListener(){</p>

<pre><code>public void actionPerformed(ActionEvent event){
    JButton(event.getSource).setText("Mirah Rocks!");
}
</code></pre>

<p>});
```
となっていたところが、</p>

<ol>
<li>引数の型がインターフェースだったときはブロックで<code>new Class(){}</code>と同じ働きになる</li>
<li>abstractメソッドが一つのときはそれも省略出来る</li>
</ol>


<p>というルールにより簡潔に書けます。これで引数の中に文が現れるという最悪の事態を回避出来ます。Java8のlambda式に近いのかな？Java8に詳しくなくてゴメンなさい。</p>

<p>似たようなので、Threadも</p>

<p><code>ruby
Thread.new do
 # do something
end.start
</code>
と書けます。</p>

<h2>マクロによる既存クラスの拡張</h2>

<p>マクロは展開後のASTがJavaとして有効であれば良いのでJavaでは出来ない芸当が可能です。</p>

<p>シンプルだけど強力な例</p>

<p><code>ruby
10.times{ puts "Hi"}
</code>
intを<code>times</code>マクロで拡張してます。その他、<code>each</code>などの便利マクロや<code>attr_accessor</code>(getterとsetterを自動生成する)など色々あります。ユーザー定義のマクロで拡張も可能ですが、今シンプルに書けるシンタックスが議論中です。</p>

<h1>Javaとの互換性とか完成度とか</h1>

<p>まだ未実装機能はいっぱいあります。<code>final</code>とか<code>synchronized</code>とか。あとスコープもRuby風に<code>private</code>以下で定義されたものはprivateですがメソッド/フィールド単位では制限出来ません<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。ジェネリクスの構文もまだサポートされてません<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>のでジェネリクスの定義は不可能、使用も型推論で型を明示的に書かなくても良いときのみ可能です。インターフェースやアノテーションはあります。</p>

<p><a href="https://docs.google.com/spreadsheets/d/1t7NVsyysIlj6OF6E26OrVJ1AVrL8i2yzbMv92cdHN8c/edit#gid=0">ここ</a>にTODOがありますが、inner classやlambda(多分Java8のlambda式とは別もの)が弱いようです。</p>

<p>でもまあ、Mirah自体Mirahでセルフホスティングされてますし一つ言語を作れる程度には機能は揃ってます。遊んでみる分には十分使えると思います。</p>

<h1>マクロの話</h1>

<p>Mirahはオブジェクト指向で静的型付けの言語でマクロを実装してます。Lisper的には割と面白かったのでちょいと触れますね。</p>

<p>まずは簡単な例から。</p>

<p><code>ruby
macro def puts(node)
  quote {System.out.println(` [node] `)}
end
</code></p>

<p>Lisperなら</p>

<ul>
<li><code>macro def</code>で<code>defmacro</code></li>
<li><code>quote block</code>でquasiquote</li>
<li>バックスラッシュで囲んでunquote</li>
</ul>


<p>などが読み取れると思います。</p>

<p>今のはASTは陽には出てこない簡単な例でしたが、次はちょっと飛躍しますよ？</p>

<p>```ruby
macro def self.abstract(klass:ClassDefinition)
  anno = Annotation.new(@call.name.position, Constant.new(SimpleString.new(&lsquo;org.mirah.jvm.types.Modifiers&rsquo;)),</p>

<pre><code>                    [HashEntry.new(SimpleString.new('flags'), Array.new([SimpleString.new('ABSTRACT')]))])
</code></pre>

<p>  klass.annotations.add(anno)
  klass.setParent(nil)
  klass
end
```</p>

<ul>
<li>macroにも型がある。その型はASTの型。</li>
<li>というかClassDefinitionとかいう型がある</li>
<li>ASTをいじるときにASTのNodeオブジェクトのメンバをゴニョゴニョするという手段がある</li>
</ul>


<p>などが読み取れると思います。また、ClassDefinitionを受け取ってClassDefinitionを返しているのでmacro chainが可能ですね。</p>

<p>次はASTを自分で組み立てる例です。</p>

<p>```ruby
  macro def self.attr_reader(hash:Hash)</p>

<pre><code>methods = NodeList.new
i = 0
size = hash.size
while i &lt; size
  e = hash.get(i)
  i += 1
  method = quote do
    def `e.key`:`e.value`  #`
      @`e.key`
    end
  end
  methods.add(method)
end
methods
</code></pre>

<p>  end
```</p>

<p>NodeListがprognみたいなものでその中にMethodDefinitionを突っ込んでいってますね。中々楽しい。</p>

<p>余談:ところでgetterメソッド名がgetKeyじゃなくてkeyになってますよね。コンパイル後は変換してくれるのかなと思い、
<code>ruby
@foo = "a"
attr_accessor :foo =&gt; :String
</code>
をコンパイル、ディスアセンブルしてみました。すると、<code>foo</code>と<code>set_foo</code>というメソッドが定義されてましたorz。Ruby的にはまあ良いんですがコンパイル後はJavaなのでそこはgetKey/setKeyにしてほしかったですね。もしかしたら今はシンボルをキャメルケースに変換出来ないのかもしれません</p>

<p>閑話休題。また、呼び出し元の情報もとれます。これはStringの+マクロです。</p>

<p><code>ruby
macro def +(arg)
  quote { "#{`@call.target`}#{`arg`}" }
end
</code></p>

<p><code>@call</code>に呼び出し元の情報が入ってるのでそれを使って情報をとれます。</p>

<p>gensymなんかもあります。これはintのtimesマクロです。</p>

<p>```ruby
macro def times(block:Block)
  i = if block.arguments &amp;&amp; block.arguments.required_size() > 0</p>

<pre><code>block.arguments.required(0).name.identifier
</code></pre>

<p>  else</p>

<pre><code>gensym
</code></pre>

<p>  end
  last = gensym
  quote {</p>

<pre><code>while `i` &lt; `last`
  init { `i` = 0; `last` = `@call.target`}
  post { `i` = `i` + 1 }
  `block.body`
end
</code></pre>

<p>  }
end
<code>``
whileの中にある</code>init<code>と</code>post<code>はRubyでいう</code>BEGIN<code>と</code>END<code>、JVM的には</code>for`の実装のために使われているのでしょうか。</p>

<h1>まとめとか雑感とか</h1>

<p>0.1.3で一番大きな変更はセルフホストされたことですね。今まではJRubyで書かれてたのでHello Worldのコンパイルに16秒とか掛かってました。今のmirahc.jarはかなり小さく、1MBちょっとしかありません。</p>

<p>入手法はgithubから良いかんじにダウンロード出来るんじゃないですかね？（適当）</p>

<p>古いバージョンにはMirahのコードと等価なJavaのソースを吐くオプションがありましたがコンパイラが変わってなくなりました。かつてheadiusはこの機能を使って吐いたコードをJRubyにコミットしたことがあるそうです。今新しいコンパイラが安定してきたのでそろそろ再実装されそうです。</p>

<p>exampleですが一応私のコミットも入ってます。<code>grep keen NOTICE</code>ってやってみて下さい。</p>

<p>mirah-mode.elをちまちま書いてますが道程は通そうです。ブロックコメント(<code>/* .. */</code>)がネスト可能なのですが、正規表現だと<code>/*/*</code>を<code>/*</code>2つと<code>*/</code>1つと認識しちゃってつらいです。</p>

<p>今回細かいところは省きましたがexampleとかあと公式ページとかgithubのwikiとか見て下さいね。</p>

<p>ある程度の完成度になってきてるのでみなさんも遊んでみて下さい。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>pull-reqは入ってるのですが、まだマージされてません<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>まだリテラルの議論が終わってないだけで、内部はジェネリクスに対応してるので近い内に入りそうな気はします。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
