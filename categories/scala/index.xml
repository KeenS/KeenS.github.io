<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scala on κeenのHappy Hacκing Blog</title>
    <link>//KeenS.github.io/categories/scala/</link>
    <description>Recent content in Scala on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 13 Dec 2015 22:42:39 +0900</lastBuildDate>
    <atom:link href="//KeenS.github.io/categories/scala/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>DSLとTagless Final</title>
      <link>//keens.github.io/slide/DSLtoTagless_Final/</link>
      <pubDate>Sun, 13 Dec 2015 22:42:39 +0900</pubDate>
      
      <guid>//keens.github.io/slide/DSLtoTagless_Final/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# DSLとTagless Final
----------------------
サイバーエージェント アドテクスタジオ  
Scala Meet Up 2015-12-18

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒エンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
   - Scalaは初心者 ※ [Scala初心者の新卒が頑張ってLispを作ってみた](http://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/)

# 注意
------

* Scala初心者なのでScalaではなくScalaっぽい疑似コードで説明します
  + ~~コード例動かす時間が無かっただけ~~
* Scala初心者なのでScalaのコードは少なめに説明します


# DSLを作る
-----------

以下のようなHTTPなユーザをエミュレートするDSLを考える

``` scala
val scenario = and(
  get(&#34;/&#34;),
  get(&#34;/users&#34;).andThen(res =&gt;
    post(&#34;/follow&#34;, first(users.getJsonData))))
val Right(_) = runScenario(scenario, &#34;user&#34;)
```


# DSLを作る
-----------

普通は以下のようなAST作ってをラップする

``` scala
trait ScenarioDSL
sealed case class Get(url: String) extends ScenarioDSL
sealed case class Post(url: String, data: JSON) extends ScenarioDSL
sealed case class And(first, ScenarioDSL, second ScenarioDSL) extends ScenarioDSL
sealed case class AndThen(first: ScenarioDSL,
   callBack: (Response) =&gt; ScenarioDSL) extends ScenarioDSL

def get(url: String): ScenarioDSL= Get(url)
....

```


# DSLを作る
-----------

そして`runScenario`を作る

``` scala
def runScenario(scenario: ScenarioDSL, user: String) = {
  scenario match {
    Get(url) =&gt; Client.getInstance(user).get(url)
    Post(url) =&gt; Client.getInstance(user).post(url)
    And(first, second) =&gt; {runSenario(first, user); runSenario(second, user)}
    ....
  }
}


```




# DSLを便利に
-------------

例えば、このDSLを`curl`コマンド関数を追加する

``` scala
def toCurl(scenario: ScenarioDSL, user: String) =
  val auth = makeAuth(user)
  scenario match {
    Get(url) =&gt; &#34;curl ${auth} ${SERVICE_HOST}/url&#34;
    Post(url) =&gt; &#34;curl ${auth} -XPOST ${SERVICE_HOST}/url&#34;
    And(first, second) =&gt; toCurl(first) + &#34;\n&#34; + toCurl(second)
    ....
  }
}

```


# DSLの拡張
-----------

このDSLに新たに`select`を追加する

``` scala
val scenario = and(
  get(&#34;/&#34;),
  select(get(&#34;/users&#34;),
         post(&#34;/update&#34;)))
val _ = runScenario(scenario, &#34;user&#34;)
```


# Expression Problem
-------------------

この時に問題が出る

* DSLを使う全てのコードに変更が必要
  + `runScenario`と`toCurl`で`select`に対応する
* DSLそのものに手を加える必要がある
  + DSLがsealed traitされてる
  + そもそも、DSLがライブラリだったら変更出来るの？
* 実際には使ってなくても全ての関数で新しい機能に対応しないといけない
  + `toCurl`では`select`に対応しないとか
  + 逆に、`toCurl`がプラグインでコードいじれなかったらどうしよう

# Tagless Finalで解決出来るよ
----------------------------

* 元のコードをいじらず
* 必要な所だけを記述して
* しかも元々の実装よりも速い

DSLの作り方があります。それは型クラスを使ったやり方です。


# 型クラスの復習
---------------

型クラスは

* 型の振る舞うインターフェースを定めて
* インスタンスの型ごとに「後付けで」実装を与えると
* 多相的に扱えるアドホックポリモーフィズム

でした


# 型クラスの復習
---------------

``` rust
trait Hello { //型クラス
  fn hello(&amp;self) -&gt; String;
}

impl Hello for isize { //isize型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;I&#39;m {} years old&#34;, self)}
}
impl &lt;&#39;a&gt;Hello for &amp;&#39;a str {//&amp;str型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;My name is {}&#34;, self)}
}
fn main() {
  println!(&#34;{}&#34;, 23.hello());     // =&gt; &#34;I&#39;m 23 years old&#34;
  println!(&#34;{}&#34;, &#34;κeen&#34;.hello()); // =&gt; &#34;My name is κeen&#34;
}
```


# DSLをRustに翻訳
-------------

Scalaで型クラスを説明するとややこしいので一旦先のDSL例をRustに翻訳します

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getJsonData().first)));
runScenario(scenario, &#34;user&#34;).unwrap();
```


# Rustに翻訳
-------------
DSLのASTはこうなります。

``` rust
enum ScenarioDSL {
  Get{url: String},
  Post{url: String, data: RequestData},
  And{first: Box&lt;ScenarioDSL&gt;, second: Box&lt;ScenarioDSL&gt;},
  AndThen{first: Box&lt;ScenarioDSL&gt;,
   callBack: FnOnce&lt;(Scenario, Request) -&gt; ScenarioDSL&gt;},
}
```

# Rustに翻訳
-------------
runScenarioはこうなります。

``` rust
fn runScenario(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; Result&lt;()&gt; {
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; Client::instance(user).get(url),
    &amp;ScenarioDSL::Post{ref url} =&gt; Client::instance(user).post(url),
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      try!(runSenario(first));
      runSenario(second)
    },
   ...
  };
}
```


# Rustに翻訳
-------------
`toCurl`はこうなります

``` rust
fn toCurl(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; String {
  let auth = makeAuth(user)
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; format!(&#34;curl {} {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::Post{ref url} =&gt; format!(&#34;curl {} -X POST {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      let first_str = toCurl(first, user);
      let second_str = toCurl(second, user);
      format!(&#34;{}\n{}&#34;, first_str, second_str)
    },
   ...
  }
}
```


# Tagless Final
---------------

Rustの準備が終わったのでTagless Finalの説明に入ります。


# Tagless Final
----------------

* ASTをデータではなく関数で表わす
* 同じ関数でも欲しい結果によって計算を変えるために型クラスを使う
* どの型クラスのインスタンスとして扱うかで結果を変える
  + そもそもASTは計算を抽象化してデータにしたもの。
  + 抽象的な計算があるならデータにする必要はない

* 型クラスでジェネリックに作って
* 欲しい型を伝えるだけで挙動が変わる


# 型クラス
----------
DSLの文法の型クラスを定義する。  
DSLっぽく見せるため、ラッパを書く(Rust特有)。


``` rust
trait ScenarioSYM {
  fn get(url: String) -&gt; Self;
  fn post(url: String) -&gt; Self;
  fn and(first: Self, second: Self) -&gt; Self;
  ...
}

fn get&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::get(url)}
fn post&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::post(url)}
fn and&lt;C: ScenarioSYM&gt;(first: C, second: C) -&gt; C {C::and(first, second)}
...
```



# `runScenario`
------
結果に`Result`型が結果として欲しいなら`Result`型に`ScenarioSYM`を実装する

```rust
impl ScenarioSYM for Result&lt;()&gt; {
  fn get(self,url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn runScenario(res: Result&lt;()&gt;) -&gt; Result&lt;()&gt; {
  res
}
```


# `toCurl`
----------
`String`が欲しいなら`String`に実装すれば良い。

``` rust
impl ScenarioSYM for String {
  fn get(self, url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn toCurl(str: String) -&gt; String {
  str
}
```


# 完成形
--------

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getData().iter().next())));
  // ↑ここまではジェネリックなScenarioSYM型
  // ↓ここで呼ばれることでResult&lt;()&gt;型にインスタンス化される
runScenario(scenario, &#34;user&#34;).unwrap();
```


# DSLの拡張
-----------

拡張したい文法のDSLを定義して、欲しいものに実装するだけ。

`runScenario`に変更は要らないしサポートしない`toCurl`は気にしなくて良い。

``` rust
trait SelectSYM {
  fn select(self, first: Self, second: Self) -&gt; Self;
}

impl SelectSYM for Result&lt;()&gt; {
  fn select(self, first: Self, second: Self) -&gt; Self {...}
}
```


# Tagless Finalまとめ
---------------------

* この方式だと実行時にタグでパターンマッチしないので速い
* DSLの拡張も機能の拡張も容易
* 型クラス便利


# ScalaでのTagless Final
------------------------
Rustで分かりやすく解説したのでScalaでどうなるか見ていきます。

まずは型クラスを定義

``` scala
trait ScenarioSYM[C] {
  def get(self: C, url: String): C
  def post(self: C, url: String): C
  ...
}
def get(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.get(self, url)
def post(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.post(self, url)
...
```


# `runScenario`
------

``` scala
implicit val resultScenario = new ScenarioSYM[Either[Err, ()]] {
  def get(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  def post(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  ...
}

def runScenario(ast: Either[Err, ()], user: String)
      (implicit i: ScenarioSYM[Either[Err, ()]]) = ast
```


# 完成形
--------
Scalaの型クラスの制約上最初の例と少し異なる
(`val`じゃなくて`implicit`を取る`def`になる)


``` scala
def scenario(implict i: ScenarioSYM[C]) = Scenario
   get(&#34;/&#34;)
   get(&#34;/users&#34;) andThen((scenario, res) =&gt;
    scenario post(&#34;/follow&#34;, first(users.getJsonData)))
val Right(_) = runScenario(scenario, &#34;user&#34;)

```


# まとめ
--------

* Expression Problemについて説明した
* Tagless Finalを紹介した
* 型クラス便利
* Rust便利
* [参考](http://okmij.org/ftp/tagless-final/course/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>#関数型なんたら で喋ってきた</title>
      <link>//keens.github.io/blog/2014/10/26/number-guan-shu-xing-nantara-nican-jia-sitekita</link>
      <pubDate>Sun, 26 Oct 2014 17:14:10 +0000</pubDate>
      
      <guid>//keens.github.io/blog/2014/10/26/number-guan-shu-xing-nantara-nican-jia-sitekita</guid>
      <description>

&lt;p&gt;κeenです。昨日&lt;a href=&#34;http://connpass.com/event/8634/&#34;&gt;函数型なんたらの集い&lt;/a&gt;に参加してきたので報告/感想です。&lt;/p&gt;

&lt;p&gt;会場提供はドワンゴということでトークはニコ生に流された模様。ちらっと覗いてみたらLinuxでも見れましたね。いつのまにかFlashのバグ直ってたんですね。
とはいえ私自身のトーク中のコメントが見れなかったのであまり意味はないのですが…&lt;/p&gt;

&lt;p&gt;プレミアム会員は放送後7日は生放送の内容を見れるそうですね。見れる方々は&lt;a href=&#34;http://live.nicovideo.jp/gate/lv196879029&#34;&gt;コチラ&lt;/a&gt;からどうぞ。次回からはタイムシフト予約しておこう。&lt;/p&gt;

&lt;h1 id=&#34;話した内容:2e493419d503b3224d2e59e7d010df63&#34;&gt;話した内容&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;//KeenS.github.io/slide/c6h6-plus-hno3.html&#34;&gt;C6H6+HNO3&lt;/a&gt;というタイトルで、picrinのbenzとnitrosについて。本当はnitrosの依存関係解決器sulfuricを完成させてそれについて話し、nitroを書こう!って言う予定だったんですが着手が遅れて完成しないまま発表になりました。&lt;/p&gt;

&lt;p&gt;普段関数型言語のヒトは型やらモナドで殴ってる印象があったのでマクロで殴ろうと思ったのですがマクロの話のところで焦ってしまって話が飛んでしまい、殴れずに終わりました。&lt;/p&gt;

&lt;p&gt;ガチの組み込み屋さんから組み込み機器で動作検証したのかとの質問がありましたがそもそも持ってないです。そろそろ1.0が出ると思うのでそのあたりでやります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GCがconservativeかとの質問に対して「はい」と答えてしまいましたが間違いでした。&lt;/strong&gt; conservativeなのはcall/ccでした。GCはexactですね。&lt;a href=&#34;http://picrin.readthedocs.org/en/latest/intro.html&#34;&gt;ドキュメント&lt;/a&gt;に載ってます。&lt;/p&gt;

&lt;p&gt;wasabizの名前に反応した人が多かったようですね。やっぱ有名人なのかぁ。&lt;/p&gt;

&lt;h1 id=&#34;興味深かった話:2e493419d503b3224d2e59e7d010df63&#34;&gt;興味深かった話&lt;/h1&gt;

&lt;h2 id=&#34;エンジニアとモナド-http-www-slideshare-net-ruiccrail-engineerusesmonads-ref-http-connpass-com-event-8634-presentation:2e493419d503b3224d2e59e7d010df63&#34;&gt;&lt;a href=&#34;http://www.slideshare.net/RuiccRail/engineerusesmonads?ref=http://connpass.com/event/8634/presentation/&#34;&gt;エンジニアとモナド&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;またモナドで殴る話かと思ったら全然違いました。トップダウンで設計するときにそれぞれを小さなDSLに分割してそれらをモナドで実装し、モナド変換子で組み合わせると良いよねとのこと。タスクアサインもモナド単位になるし分かり易い。スピードのために実際には単相化すると良いとか現実的な話をしてて非常に良かったです。&lt;/p&gt;

&lt;p&gt;Lispで考えるとこうはいかないなと思います。トップダウンで設計するのが他の言語以上に向いてない気がします。というか、ボトムアップに向きすぎてる。小っさく始めて抽象が欲しければマクロを書いて…って。オブジェクト指向で作るにしてもオブジェクトとメソッドが分離してるのでボトムアップと相性が良い。この辺はポールグレアムの「ハッカーと画家」に詳しいです。&lt;/p&gt;

&lt;h2 id=&#34;shapelessの紹介-http-xuwei-k-github-io-slides-functional-something-shapeless-0:2e493419d503b3224d2e59e7d010df63&#34;&gt;&lt;a href=&#34;http://xuwei-k.github.io/slides/functional-something-shapeless/#0&#34;&gt;shapelessの紹介&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;興味を持ったのはshaplessそのものではなくてヘテロなリストやヘテロなハッシュに型をつける話。&lt;code&gt;{ 1 =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; 2}&lt;/code&gt;に型がつくのは面白すぎます。「高度に多相化された静的型は動的型と区別がつかなくなる」っぽかったです。&lt;/p&gt;

&lt;h2 id=&#34;パターンマッチいろいろ:2e493419d503b3224d2e59e7d010df63&#34;&gt;パターンマッチいろいろ&lt;/h2&gt;

&lt;p&gt;議論を呼んだ発表。パターンマッチを拡張する話。例えば年月日に対して&lt;code&gt;YMD(y, 12 25)&lt;/code&gt;でクリスマスならそのときの年を取り出せるだとかさらにアンドを使えばHMSも一緒にマッチ出来るだとか。
そこからEgisonに話が飛んでEgisonの例のようにポーカーの役をScalaでパターンマッチする例の紹介。&lt;/p&gt;

&lt;p&gt;議論を呼んだというのはパターンマッチにガードが吸収されてる件ですね。データ型のコンストラクタとエクストラクタが一対一対応してこそパターンマッチは真価を発揮する派vsパターンマッチの表現力が高ければ高い方が良い派の対立ですね。さらに前者は型の表現力が足りてないのなら型をもっと複雑にすべき派とガードを付けて網羅性の証明をすれば良い派に分かれます。私はパターンマッチには表現力があればあるほど良いよね派。&lt;/p&gt;

&lt;p&gt;これはそもそもパターンに対する立場の違いがある気がするんですよね。私はパターンマッチは同じデータに対する条件判定のシンタックスシュガーとして捉えています。マッチと束縛を一緒に行なうのは便利なのとパフォーマンスのため。ガードが必要なのはパターンの表現力が足りないため。だからパターンがリッチならリッチな方が良い。そもそもLispでは網羅性のチェックは期待出来ませんので。そもそもの話動的言語はコンパイル時の検査をあきらめてその代わり表現力を得ようという思想ですからね。&lt;/p&gt;

&lt;p&gt;パターンが複雑になるとメモリが爆発するとの指摘がありましたがそれに直面した人がいるらしく、パターンによる分岐の枝を実行時に伸ばしていくようなパターンマッチライブラリも存在します。（Lispは実行時にもマクロが動いていて、実行時にコードを生成することも可能なのです。）&lt;/p&gt;

&lt;h1 id=&#34;懇親会その他:2e493419d503b3224d2e59e7d010df63&#34;&gt;懇親会その他&lt;/h1&gt;

&lt;p&gt;名古屋の&lt;s&gt;型々&lt;/s&gt;方々と色々喋れました。偶々でこれきさん、みずぴーさんと同じテーブルに座り、昼御飯も一緒に。普段休日出勤してる印象が強く、名古屋に行かないと会えないと思っていたブレイスさんといよさんも一緒でした。でこれき先生はやっぱり大先生だった。&lt;/p&gt;

&lt;p&gt;よんたさんにSML#のコードリーディング会開いて下さいって言ったら良いよって言ってもらいました。そろそろ64bit版も出るそうなのでリリース記念コードリーディング会&amp;amp;芋煮会やろうって話になりました。&lt;/p&gt;

&lt;p&gt;OCamlのユニコードライブラリを作ってる方とも話しました。内部でropeで持ってるらしく、その話を聞きました。ropeのユニコード化はどうやら普通に文字列をUTF-8で保持し、ropeに文字列長のフィールドを保たせるだけで良いよう。ただ、picrinはCとの連携のためちょくちょくCの文字列に変換してまた新たにropeを作って、とするので若干勝手というかボトルネックが違いそう。&lt;/p&gt;

&lt;p&gt;Schemeのネイティブコンパイラを作ってる方とも話しました。Schemeの実装について喋ったり、GCについて喋ったり。GCについては興味深いことを聴いたのでもう1本エントリー書きます。あとはプロセス代数とかモデル検査とか。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:2e493419d503b3224d2e59e7d010df63&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;楽しかった。どうしてもLispは関数型とはあまり言われない（し、私も関数型言語とは思ってない）のでLisperが少なかったのですが私自身はMLも好きなので楽しめました。GCとTaPLとHaskellとScalaとEgisonに対するモチベーションが上がりました。&lt;/p&gt;

&lt;p&gt;最後に開催して下さった主催の方々、会場を提供して下さったドワンゴ様、ありがとう御座いました。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>