<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/categories/%E3%83%9D%E3%82%A8%E3%83%A0/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/%E3%83%9D%E3%82%A8%E3%83%A0/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>マクロについて整理してみる</title>
      <link>/blog/2015/07/04/makuronitsuiteseirishitemiru</link>
      <pubDate>Sat, 04 Jul 2015 15:34:46 +0900</pubDate>
      
      <guid>/blog/2015/07/04/makuronitsuiteseirishitemiru</guid>
      <description>&lt;p&gt;何故Lisperがマクロについて語るのか。Lisperと議論してみても満足のいく答を得た人はそんなにいないと思う。
それはLisper自身便利とは思っていても何が便利なのかを意識してなくて他人に上手く説明出来ないからじゃないかと思った。
ちょっと思いついた範囲でまとめてみる。

最近ではマクロシステムを持つ言語は珍しくない。Rust, Scala, Template Haskell, Mirahなどなど。最初にCommon Lispのマクロと他の言語のマクロとの違いを少し考えてみたい。&lt;/p&gt;

&lt;h1 id=&#34;unless&#34;&gt;Unless&lt;/h1&gt;

&lt;p&gt;まず、unlessをマクロで書くことを考えてみたい。単純にifにnotをつければいい。&lt;/p&gt;

&lt;p&gt;Common Lispではこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(if (not foo-p)
    bar)

(defmacro unless (cond then)
  `(if (not ,cond)
       ,then))

(unless foo-p
  bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rustだとこうなるだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
if ! isFoo {
    bar;
}

macro_rules! unless {
    ($cond:expr, $then:stmt) =&amp;gt; {{
        if ! $cond {
            $then
        }
    }};
}

unless!(isFoo, {
    bar;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいはmirahだとこうなる。unlessが予約語なので_unlessにした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if ! isFoo
  bar
end

macro def _unless(cond, block:Block)
  quote{
    if ! `cond`
      `block.body`
    end
  }
end

_unless isFoo do
  bar
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみにCだとこう出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;if(! is_foo)
  bar;

#define unless(cond) if(!(cond))

unless(is_foo)
  bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、上のマクロたちを見比べて欲しい。Common LispのマクロとCのマクロは違和感なく新たな制御構造を作れたのに対してRustとMirahはマクロ呼び出しが剥き出しになっている。&lt;/p&gt;

&lt;p&gt;ここで注意して欲しいのはCはともかくCommon Lisp、Rust、Mirahのマクロは全て引数に必要な構文木をとってそのまま用意したテンプレートにあてはめているだけだ。やっていることに違いはない。
何が違うかというとマクロ呼び出しの構文が制御構造の構文と同じか違うかという点だけだ。私の知る範囲ではそのような構文をした言語はLispしかない。だから「Lispの」マクロなのだ。&lt;/p&gt;

&lt;p&gt;もう一つ。どのマクロ定義も十分直感的に読めたと思う。この範囲なら &lt;strong&gt;S式だからマクロが簡単になるということはない&lt;/strong&gt; と思う。別にS式でなくてもquasiquoteがあれば十分読み易いマクロが書ける。&lt;/p&gt;

&lt;h1 id=&#34;case&#34;&gt;Case&lt;/h1&gt;

&lt;p&gt;caseを生成することを考えよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun fun1 (x)
  (let ((y (case x
             ((:foo) (hoge &amp;quot;foo&amp;quot;))
             ((:bar) (hoge &amp;quot;bar!&amp;quot;)))))
    ...))


(defun fun2 (x)
 (let ((y (case x
            ((:foo) (hoge &amp;quot;foo&amp;quot;))
            ((:baz) (hoge &amp;quot;baz!&amp;quot;)))))
   ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように似たような、しかし微妙に違うcaseが必要になったような時に必要だろう。この時、&lt;code&gt;&#39;(:foo (hoge &amp;quot;foo&amp;quot;) :bar (hoge &amp;quot;bar!&amp;quot;))&lt;/code&gt;のようにリテラルでそのまま書いてしまっては抽象化する意味がなくなる。例えばハッシュテーブルにKey-Valueペアを入れて必要な時に入れたり削除したりすればよい。そのようなマクロはこう書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro case-table (key hash)
  `(case ,key
     ,@(loop
          :for k :being :the :hash-key :of hash :using (hash-value v)
          :collect `((,k) ,v))))

(defparameter *table*)
(setf (gethash :foo *table*) &#39;(hoge &amp;quot;foo&amp;quot;))
(setf (gethash :bar *table*) &#39;(hoge &amp;quot;bar!&amp;quot;))

(defun fun1 (x)
  (let ((y (case-table x #.*table*)))
    ...))

(remhash :bar *table*)
(setf (gethash :baz &#39;(hoge &amp;quot;baz!&amp;quot;)))


(defun fun2 (x)
  (let ((y (case-table x #.*table*)))
    ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ハッシュテーブルを受け取ってリストを返す普通のloopマクロの力をマクロ展開時にも使える。また、ハッシュテーブルには&lt;code&gt;&#39;(hoge &amp;quot;foo&amp;quot;)&lt;/code&gt;などのただのリストを突っ込んだがそれをそのままASTとしても使っている。
Common Lispのマクロのもう1つの良いところはマクロの展開時にもCommon Lispの機能がフルで使えるところであり、マクロの引数に受け取るのが構文木でありデータ構造でもあるS式なところだ。ここでは &lt;strong&gt;S式の同図像性が重要なファクターになっている&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(case-table x #.*table*)&lt;/code&gt; で使っている &lt;code&gt;#.&lt;/code&gt; は &lt;em&gt;リードマクロ&lt;/em&gt; といってマクロ展開(コンパイル時)より前(リード時、構文解析時)に動作するマクロだ。このリードマクロはeval-when-readといってリード時に
値を評価する。その結果、&lt;code&gt;case-table&lt;/code&gt;に渡るのが &lt;code&gt;&#39;*table*&lt;/code&gt;というシンボルでなく&lt;code&gt;*table*&lt;/code&gt;に束縛されているハッシュテーブルになる。因みに &lt;em&gt;コンパイラマクロ&lt;/em&gt; というマクロ展開が終わった後に動作するマクロもある。&lt;/p&gt;

&lt;p&gt;マクロ1つではなくマクロの前後に動作するマクロもあってこそ初めて柔軟性を手にしている。あまりその点は議論されてないのではないだろうか。&lt;/p&gt;

&lt;h1 id=&#34;common-lispの設計&#34;&gt;Common Lispの設計&lt;/h1&gt;

&lt;p&gt;さて、各々言語には予約語や~構文というものがあると思う。メソッド定義構文など。Common Lispにもスペシャルフォームという名前で&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm&#34;&gt;25&lt;/a&gt;個存在する。
驚くべきことに、ここまでに出てきたCommon Lispのコードにはスペシャルフォームは3つしか出てこない。ifとletとquoteだ。setfやloop、defun、defmacro、case、defparameterなんかはマクロで出来ている。&lt;/p&gt;

&lt;p&gt;defunまでマクロで出来ているということはユーザがその気になれば関数定義の構文に手を入れたりも出来るということだ。
普通、そんなことをしたら阿鼻叫喚だがCommon Lispなら安全に出来る。マクロもシンボルに束縛されているので新たにマクロで上書きしたシンボルを名前空間にインポートしなければ今まで通りのdefunやloopが使える。&lt;/p&gt;

&lt;p&gt;もう1つ、普段使うものがマクロで出来ているということはマクロを被せてない機能は相当低レベルだということだ。マクロさえ書けば全く新しい言語機能を追加出来るということであり、あるいは&lt;a href=&#34;http://cl21.org/&#34;&gt;全く新しい言語も作れてしまう&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;このような設計はマクロで制御構造までも作れるから出来るのだ。関数定義構文をマクロで定義している言語はLisp以外に私は知らない。&lt;/p&gt;

&lt;h1 id=&#34;メタプログラミングとcommon-lisp&#34;&gt;メタプログラミングとCommon Lisp&lt;/h1&gt;

&lt;p&gt;ところで、マクロに限らないメタプログラミングについて考えてみたい。メタプログラミングとは、プログラムを書くプログラムを書くことだ。プログラムはテキスト形式のソースコードから実行形式に至るまでの間に様々な中間形式から中間形式に変換される。メタプログラミングはそのどこかの形式を生成することと同義になる。通常、処理系内部で使う形式は変なことをされると困るのであまり外部に公開したくない。メタプログラミングを許すとしても構文解析などのフロントエンドに近い部分になるだろう。&lt;/p&gt;

&lt;p&gt;例えばyaccやlexのようなソースコードジェネレータ、rubyやDのような文字列ベースのメタプログラミングは公開APIであるところのパーサだけを使っているので安全性は高い。しかし文字列だけだと構造がないので書く側はつらい。一応、Common Lispにもread関数とeval関数があるのでCommon Lispのソースコード文字列を吐いてreadしてevalすれば文字列メタプログラミングは出来る。特に嬉しくないのでやらないが。&lt;/p&gt;

&lt;p&gt;次はトークンベースのメタプログラミングがある。Cのプリプロセッサなど。Common Lispでもリードマクロで可能だ。例えば正規表現リテラルを作ったりとかの例がある。&lt;/p&gt;

&lt;p&gt;次はASTベースのメタプログラミングがある。マクロだ。これは今まで見てきた。&lt;/p&gt;

&lt;p&gt;これより先はメタプログラミングとはあまり言わない気がする。JITと呼ぶのではないか。Common Lispにもeval関数やcompile関数があるからそういうことも出来る。正規表現ライブラリなんかが使っている。&lt;/p&gt;

&lt;p&gt;私が言いたいのはCommon Lispにはメタプログラミングの機構が一杯あるということではない。read, eval, compile…。気付いたかもしれないが、LispはLisp自身で出来ている。
Lispを書くとき、Lispを書いてるかもしれないしLispを構成するLispを書いているかもしれない。いくらでもメタプログラミングが出来るということだ。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;何やらCommon Lisp賛美歌になってしまったが一応まとめておく。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;簡単なマクロ定義ならS式である必要はない&lt;/li&gt;
&lt;li&gt;複雑なマクロ定義ならS式であると書き易い。恐らく他の構文でも書けないことはない。&lt;/li&gt;
&lt;li&gt;マクロ呼び出し構文はS式でないと重大な違いがある。&lt;/li&gt;
&lt;li&gt;マクロ以外にもリードマクロやパッケージなど他の言語機能があってこそマクロが活きる。&lt;/li&gt;
&lt;li&gt;言語機能だけでなくマクロを前提とした設計も重要である。&lt;/li&gt;
&lt;li&gt;LispはS式で出来ている以前にLispで出来ている。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>独学のプログラミング</title>
      <link>/blog/2014/12/18/du-xue-falsepuroguramingu</link>
      <pubDate>Thu, 18 Dec 2014 23:51:27 +0000</pubDate>
      
      <guid>/blog/2014/12/18/du-xue-falsepuroguramingu</guid>
      <description>&lt;p&gt;誰向けなのか分からない。多分5年後くらの初心を忘れた自分が読めば良いと思う。あるいは、独学でプログラミングを始めようとしてる人が参考にするのかもしれない。
&lt;/p&gt;

&lt;p&gt;私はプログラミングを独学で学んだ。&lt;/p&gt;

&lt;p&gt;初めて触ったのは中学生のとき、ネットゲームのギルドのホームページを作ろうとなってHTML、CSS、JavaScriptという存在を知った。&lt;a href=&#34;http://www.red.oit-net.jp/tatsuya/java/&#34;&gt;イヌでもわかるJavaScript講座&lt;/a&gt;を見てメモ帳で書いた20行くらいのスクリプトが当時の最高傑作だった。&lt;/p&gt;

&lt;p&gt;それから名前の訊いたことのあったC言語を学ぼうとしたが、Vijuaru Stajioのインストールが出来なくて挫折した。CとC++とC#の違いも分ってなかった。&lt;/p&gt;

&lt;p&gt;その後、ネットゲームもしなくなり高校の間は全くプログラミングに触れずに大学に入った。&lt;/p&gt;

&lt;p&gt;1年夏学期の情報の授業でシェルを知った。最初は慣れなかったが次第に使えるようになって、家でもコマンドプロンプトを使うようになった。冬学期の情報科学でrubyを知った。あくまで情報科学であってプログラミングの授業ではなかったが、rubyに興味を持った。&lt;a href=&#34;http://www.rubylife.jp/ini/&#34;&gt;Ruby入門&lt;/a&gt;を見ながら覚えた。メソッド、クラス、オブジェクト指向…。カタカナ語が多くて中々頭に入らなかった。&lt;/p&gt;

&lt;p&gt;一つ、ターニングポイントになったと思うのは&lt;a href=&#34;http://www.amazon.co.jp/Ruby%E9%80%86%E5%BC%95%E3%81%8D%E3%83%8F%E3%83%B3%E3%83%89%E3%83%96%E3%83%83%E3%82%AF-%E3%82%8B%E3%81%B3%E3%81%8D%E3%81%A1/dp/4863540221&#34;&gt;Ruby逆引きハンドブック&lt;/a&gt;を買った時だと思う。どんな本かも分からずに買った。そして最初から最後まで読んだ。これで一通りプログラミング言語で何が出来るのか分かった気がする。手札の確認というか。逆引きを買ったのが1年生の冬学期の終わりだったかな？そしてバッチファイルで書いていた処理をrubyで置き換えたりしていた。&lt;/p&gt;

&lt;p&gt;その頃にはラップトップにCygwinが入っていた気がする。そしてEmacsをCygwin内で使っていた。いや、怪しいな。Cygwinのbinにパスを通してコマンドプロンプトからEmacsを使っていたかもしれない。&lt;/p&gt;

&lt;p&gt;春休みにプログラミングのバイトに応募してみた。それまでは個別指導をしていたが、兄弟会社でバイトを募集していると告知されたからだ。プログラミング試験はrubyで書いて恐る恐る提出すると合格だった。面談の結果Androidチームに入った。Javaは一行も書けない。最初のミーティングまでにJavaを覚えようとしたが間に合わなかった。戦々恐々と出社したが、仕事がみんなに降ってきて、自分の出来そうな仕事をして相応の報酬を貰う制度だったのでとりあえずのところ書けなくても困らなかった。&lt;/p&gt;

&lt;p&gt;2年生の夏学期。JavaとAndroidとEmacsを勉強していた。PC系サークルにも入った。確かこの頃Ubuntuを使い始めた。バイトはまだ一度もアサインされたことはなかったがどんな仕事はどんな人が持っていくのかはなんとなく分かってきた。Emacsの設定を触るうちにLispに興味を持ったのもこの辺じゃなかったかな。&lt;/p&gt;

&lt;p&gt;2年生の夏休み。合宿と強化練に忙殺されていたがバイトのタスクアサインに初めて手を挙げた気がする。君にはこの仕事はまだ早いと言われ、貰えなかった。もう一つ、ここで進路の決断を迫られた。大学に入ったときは数学科に行くつもりだったが情報系も検討した。最後まで悩んだ挙句数学科を選んだ。今思えば大失敗だったが後悔先に立たず。&lt;/p&gt;

&lt;p&gt;2年生の冬学期。学科の周りの人を見て絶望した。レベルが違い過ぎる。高校の数学が少し得意程度の人が来るべきところではなかった。数学者になる夢はここで潰えた。この時期は授業が少ないので我武者羅にプログラミング関係の情報を集めた。この頃にはRuby、Common Lisp、Javaが使えた筈。でもJavaが嫌いでAndroidアプリをJava以外で書く方法を捜してた。JRubyとRubotを試したけど遅すぎてダメだった。Clojure、Scala、Haskell、OCamlなどの名前もこの辺で知った。Clojureは少し触ってみた気がする。バイトで初めてのタスクアサインを受けたのもこの頃。プログラムを書く仕事ではなくテスターだったが。&lt;/p&gt;

&lt;p&gt;これ以降、順調に学んでいった。QtRubyで胃に穴が空きそうになったり、どうしてもCommon Lispが気になって6月にShibuya.lispに初めて参加したり。&lt;/p&gt;

&lt;p&gt;2つ目のターニングポイントはISUCONだった。ISUCONの案内はPC系サークルのOBから来た。学生枠を設けるから講習会を開くとの案内。その頃は腕に覚えがあったのでバリバリスコア伸ばすつもりで夏期講習に参加した。コテンパンにやられた。手も足も出なかった。Webアプリケーションがどんなものかは分かっているつもりだったがSQLも知らないしNginXの設定も3時間くらい格闘して結局出来なかった。悔しいので予選でリベンジしようと思った。懇親会に出ると同じような人が何人かいて、チームを組むことになった。予選でも手も足も出なかった。私がNginXの担当になったがチューニング方法も全く分からなかった。神風が吹いて上位の学生チームがFailして本戦に出場することになった。流石に本戦で恥かしい思いはしまいと&lt;a href=&#34;http://isucon.net/archives/32976287.html&#34;&gt;公式ブログの解答例&lt;/a&gt;を二人で復習した。NginX、SQL、Capistranoなどの知識を得た。そして本戦。善戦した。他の学生チームが全てFailするというまさかのオチで学生賞をとった。&lt;/p&gt;

&lt;p&gt;ISUCONで学生賞を取ったのとISUCON関係でフォローした人の影響でOpsの方にも興味を持った。&lt;/p&gt;

&lt;p&gt;そういえばこの頃、睡眠時間を気にせずIT系の情報を漁っていたら体調を酷く崩してバイトを辞めた。&lt;/p&gt;

&lt;p&gt;思い出せばこの頃に色々と変わった。変わったというか壁を破ったというか。それまでコンスタントに参加していたShibuya.lispのLisp Meet Upで初めてLTをした。初めてのまともなOSSであるCIMを作った。プロコンに参加してみた。&lt;/p&gt;

&lt;p&gt;そしてそれから1年、勉強会で喋ってGithubで活動してISUCONに出て若干コンピュータサイエンスに興味を持った今の私になった。4年生では数学科らしからずパタヘネとMINIX本を講究でやっている。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これで大体合ってる筈なんだが書きたかったのはこういう事じゃなかった気がする。何がきっかけで殻を破ったか、どうやって独学で身につけたか。時系列は無視して書き連ねていく。&lt;/p&gt;

&lt;p&gt;上でも書いたように逆引きRubyが1つのターニングポイントだった。でも、どうしても書きたいものがあまりなくてソースコードを読んだ。WEBRicks。その頃はまだHTTPサーバーの仕組みを分かってなかったから理解出来なかったけど雰囲気は分かった。それとrush。今では死んだプロジェクトだけどrubyで書かれたシェルに夢を抱いてソースを読んだ。&lt;/p&gt;

&lt;p&gt;最初の頃は何でもググってた気がする。英語はスルーしてた。Common Lispを始めた時にはマイナー言語の宿命で英語は避けて通れなかったので肚を括った。しかしドキュメントも無いプロジェクトも多数あって、結局ソースをかなり読んだ。&lt;/p&gt;

&lt;p&gt;WEB上の情報も頼りにしてたが、やっぱり書籍が便利だった。ディスプレイが1つしか無いからブラウザとEmacsを行き来するのが面倒だったというのもあるかもしれない。今数えると50数冊持っていた。図書館で借りて読んだ本もあるから読んだ本だともうちょっと。&lt;/p&gt;

&lt;p&gt;上には出てこなかったがFreeBSDをKVM上で動かしている。FreeBSDを触り始めた時にはマニュアルを頼りにしろ、と書いてあった。成程、便利だ。それ以来ググるより先に公式ドキュメントやmanページを先に引くようになった。特にmanを引けるようになったのは大きかった気がする。&lt;/p&gt;

&lt;p&gt;「Lisperは一度はLisp処理系を書く」と言われて言語処理系に興味を持った。Rubyやmrubyのコードを読んで図書館でそれっぽい本（後にドラゴンブックと分かる）を手にとった。就活でプログラミング課題が出たときにJavaを書きたくなくてLispを実装してLispで解いた。初めてのLisp処理系だった。それからpicrinを見かけてpicrinにコミットし始めた。言語処理系が中で何をやっているか、そして一番GCなどのメモリ管理について理解が深まったのは大きかったと思う。&lt;/p&gt;

&lt;p&gt;低レベルの世界はパタヘネが導いてくれた。picrinにコミットし始めてCをゴリゴリ書いたのもある。高速なコードを書こうと思った時にアセンブラやCを知っていると全然違った。どうすれば速くてどこが遅くなる原因なのか。勿論、ドラゴンブックで最適化も学んだのでどの程度は処理系がやってくれるのかも少しは分っていた。&lt;/p&gt;

&lt;p&gt;デバッガはpicrinを開発してるときに覚えた。WEBにいくらでも資料がある。実はそれまではずっとprintfデバッグしかしたことがなかった。それからCommon Lispでも少し使うようになった。他の言語はまだ使っていない。&lt;/p&gt;

&lt;p&gt;理論の世界はOCamlとプロコンが入口だった。プロコンは賞金が出るらしいときいてリクルートプロコンに出た。4/10問解けてそれなりに満足して、少し興味を持った。chokudaiさんの講座を受けたり蟻本を買ったりして学んだ。Common Lispで実装しようとしてたらアルゴリズムイントロダクションを勧められた。図書館で借りた本だったので逃げてしまったが道具箱のカタログには入った。
OCamlは、「数学科の主な就職先は金融」「金融では主にOCamlが使われている」と訊いて始めた。OCaml界隈を追ってると、型だとかTaPLだとかCoqだとかが聴こえてきた（主に名古屋の方面から）。少し齧った。そこから関数型言語の世界に入った。HaskellもRWHをざっと読んでモナドを知り、SML#からSMLに入って、SMLも追ってみた。主に研究に使われているらしく、面白い機能を持った処理系がいっぱいあった。型安全pickling、リージョン推論、モジュールのコンパイル時畳み込み…。だいたい論文にリンクが貼ってあって、そこから論文を読むことを覚えた。&lt;/p&gt;

&lt;p&gt;バージョン管理システムは.emacsの管理をsvnで始めたのが最初だった。バイト先が最初svnだったから。DropBoxにsvnサーバを置いてちまちま使っていた。init.elだけはRCSで管理してた時期もあった気がする。バイト先がgitになってから手元もgitに以降した。gitbreakに.emacsを置いた。この時点ではまだGithuはソース読もうと思ったら良く出てくるダウンロードUIが最悪なサイトだった。しかししょっちゅう出てくるので義務感に刈られてアカウントを作った。Shibuya.lispでLTするにあたり、サンプルコードを置くのに初めてpushした。いや、Octopressのブログが先だったか？いずれにせよ3年生の9月あたりからコミットを始めた。gitは経験とWEBで覚えた。今は&lt;code&gt;git help&lt;/code&gt;を参照している。&lt;/p&gt;

&lt;p&gt;OSについてはLinuxディストリを試して回ったときに学んだ。最初はUSBに焼くことしか知らず、同じUSBに何度も色々なディストリを焼いた。Ubuntuの次はArch、Gentoo、FreeBSD、 OpenSUSE。Gentooはブートローダやパーティションについて知る良い機会だった。PCを何度も再起動するのが耐えられなくて回避策を捜したらKVMが出てきた。三つ子の魂なんとやら、今でもコマンドラインから&lt;code&gt;kvm&lt;/code&gt;コマンドで仮想マシンを起動している。そして今はMINIX本でもうちょっと詳しくOSについて学んでいる。&lt;/p&gt;

&lt;p&gt;AIはLispをやってると自然と行きつく。WEBを参考にしながらオセロのAIを作った。そのとき初めてSchemeを触った。なんでSchemeを選んだのかは覚えてない。SICPの影響だったかPC系サークルで部誌を書くにあたりSchemeのチュートリアルがあってそれに乗っかって選んだのか。ほぼGaucheのマニュアルだけでやりきった。魔法のように見えたAIが人工無能であることを理解した。探索、MiniMax、αβ法なんかも理解した。将棋のAI、碁のAIの本も買った。そこで機械学習を知った。&lt;/p&gt;

&lt;p&gt;データ解析はビッグデータの流れから本を捜して学んだ。R。正直そんなに身に入ってないが心には留めている。&lt;/p&gt;

&lt;p&gt;機械学習はAIの流れとデータ解析の流れの合流地点だった。WEB、データ解析の本、AIの本などで断片的に知識を仕入れた。これもあまり身に入ってないがディープラーニングや画像処理の話題についていける程度にはなった。&lt;/p&gt;

&lt;p&gt;画像処理はAIの流れだった。五目並べに似たConnect 6というドマイナーなゲームのAIを作ろうとした。棋譜を打ち込むのが面倒だから画像処理でやろうとした。結局処理は出来なかったけど画像処理が裏で何をやっているのか、OpenCVで何が出来るのか、機械学習がどう使われるのかなどが分かった。公式マニュアルとWEBとオライリーのOpenCVも図書館で借りた気がする。道具箱に入った。&lt;/p&gt;

&lt;p&gt;ネットワークは自宅サーバを立てようとしてルータをいじった時に少し覚えた。WEBで情報を得た。OSをインストールするときにも最初に設定が必要になる。正直まだまだ知識が足りてない。TCP/IPの本を流し読みしたけど覚え切れなかった。&lt;/p&gt;

&lt;p&gt;UnicodeやエンコードはpicrinをUnicode対応させようとしたときに調べた。WEBだとどうしても表面しか書いてない記事が多くて欲しい情報を探しきれなかったので本を買った。&lt;/p&gt;

&lt;p&gt;上に書いたことだと、勉強会はShibuya.lispが暖かく受け入れてくれたことから始まった。怖がらないことが大事。そしてLTを録画してくれるので見直して喋り方やスライドも改善した。&lt;/p&gt;

&lt;p&gt;OpsはISUCONがきっかけだった。Twitterで流れてくる情報を追った。運用に興味を持った。でも、自分で運用しているサービスなんてない。サーバもない。多分だから早くエンジニアになりたいと思ってるんだと思う。&lt;/p&gt;

&lt;p&gt;データベースもISUCONがきっかけだった。SQLも然り。そこからNoSQLに行って7つのDB7つの世界を読んだ。道具箱のカタログの中身が増えた。データベースの実装が気になって少しRDBを作ってみた。トランザクションとかバックアップとかクラスタリングとかはまだどう実装するのか理解していない。&lt;/p&gt;

&lt;p&gt;Linuxプログラミングは自然に覚えた。シェルが内側で何をやっているか、高速なWEBサーバの背後にあるのは何か。データベースを効率的に実装するには何が必要か。picrinに機能を追加する時に最終的に何を使うのか。&lt;/p&gt;

&lt;p&gt;ここで上に書いたものを改めて見てみる。何が必要で何が必要でないか分からない。全然足りない気がする。CPU作ったこともコンパイラ書いたこともデバイスドライバ書いたこともない。同年代の情報系の人は何を学んでいるのか。情報科学科と情報工学科でどれくらいの違いがあるのか。エンジニアに必要なスキルは何なのか。やっぱり見えない敵と戦っている。&lt;/p&gt;

&lt;p&gt;文系からエンジニアになったという人を見掛けた。見てると、大学に入り直して情報科学を体系的に学びたいと言っていた。彼女も多分見えない敵と戦ってるんだと思う。&lt;/p&gt;

&lt;p&gt;何だろう。大学を出るまであと3~4ヶ月。あと何を勉強しておけば良いのかな。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>サイエンスかエンジニアリングか</title>
      <link>/blog/2014/12/18/saiensugaenziniaringu</link>
      <pubDate>Thu, 18 Dec 2014 23:03:41 +0000</pubDate>
      
      <guid>/blog/2014/12/18/saiensugaenziniaringu</guid>
      <description>&lt;p&gt;最近、エンジニアリングかサイエンスかという分類を教えてもらった。それが出てきたのはGoがエンジニアリングから出た言語だと言われた時だった。

その時私はRustを推していたのでRustはサイエンスから出た言語だと言った。&lt;/p&gt;

&lt;p&gt;Goが出た時は「コンパイルの速いシステム記述言語」という触れ込みだった気がする。C++のコンパイルが遅いからGoを作った、ならエンジニアリングから出た言語と言える。
Rustは触れ込みがあった気はしないが代数的データ型やトレイト、リージョン推論（ライフタイム）などサイエンスの成果を反映している。サイエンスから出た言語と言って良いと思う。&lt;/p&gt;

&lt;p&gt;サイエンスとエンジニアリング。この言葉を知ってから随分ともやもやを説明出来るようになった。&lt;/p&gt;

&lt;p&gt;先のGoとRustの話に関連して。Goがここ15年のプログラミング言語の歴史を無視しているだとか、平ぺったい言語だとか言われるのを良く聞く。Goがサイエンスの成果をあまり取り入れなかったからだろう。
折しも関数型言語が流行っている今、サイエンス寄りになったエンジニアには物足りないのだと思う。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;私が競技プログラミングをあまり好きになれない（※個人の感想です）のはあれがサイエンスの一部分を競技化したものだからだ、と説明出来る。何故かというと私が興味があるのはエンジニアリングだから。エンジニアの募集に競プロを使うのは違う気がしていたのもそこなんだな、と気付いた。プログラムの書けないプログラマがどの程度いるのか知らないけど少しずれてる気がする。&lt;/p&gt;

&lt;p&gt;まあ、競プロが好きになれないのは他にも&amp;rdquo;コード&amp;rdquo;という広い意味の単語を競技プログラミングの意味で使ってるだとか私の好きな言語が使えないだとか勝てないだとかの理由もあるのだが。一応、補足しておくと私も競プロは競技としては楽しむ。&lt;/p&gt;

&lt;p&gt;逆に、以前後輩にISUCONのことを説明したらサイエンスの大会と理解されたようだった。違う。あれはエンジニアリングの大会だ。多くのエンジニアが腕を競う。実際にやってみないとエンジニアリングで何十倍も高速化するというのが理解出来ないかったのだろう。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;偶に院進を勧められることがある。理学部に居るし、普通なら院進する。特に父親は心配していた。その時は「なんとなく違う」と返していたが今ではちゃんと説明出来る。私がやりたいのはエンジニアリングだ。実際に手を動かさないと出来ない経験をしたい。エンジニアリングのためのサイエンスをやることはあるがサイエンスのためのサイエンスはしない。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>