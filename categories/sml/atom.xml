<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sml | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/sml/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-12-18T23:48:25+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[mllexを使ってみる。あるいはlexユーザーに対するmllexの解説]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/10/mllexwoshi-tutemiru/"/>
    <updated>2014-12-10T00:21:04+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/10/mllexwoshi-tutemiru</id>
    <content type="html"><![CDATA[<p>このエントリーは<a href="http://qiita.com/advent-calendar/2014/ml">ML Advent Calendar 10日目</a>の記事です。<br/>
前 <a href="http://h-sakurai.hatenablog.com/entry/2014/12/09/144655">OCamlで作ったgoma言語 &ndash; h_sakurai&rsquo;s diary</a></p>

<p>ふと思い立ってPrologのコンパイラかインタプリタかを作ってみようとして、その第一段でlexerに着手しました。</p>

<!-- more -->


<p>ちょ、SML分かる人はmllexくらい常識的に知ってるなんて言わないで下さい。私は初めて触りました。</p>

<p>ちょっと変則的なんですが、smlsharpの配布物にあるドキュメントを読みながらmlton付属のmllexを使い、sml/nj上で動作を確認しました。SMLの処理系管理ガバガバですね。</p>

<p>まあ、初めて使ってみたとは言ってもほぼC版のlexのCを書く部分をそのままSMLで書けば良いだけなので簡単ですね。</p>

<p>因みにPrologの文法は以下のようなもの。</p>

<p>```prolog
%reverse a list into X
reverse([], []).</p>

<p>reverse([Hd|Tl], X):&ndash;</p>

<pre><code>reverse(Tl, Y),
append(Y, [Hd], X).
</code></pre>

<p>reverse(List, X):&ndash;</p>

<pre><code>reverse(List, []).
</code></pre>

<p>```</p>

<p>だいたいの部分は見れば分かるかと思うのですが、小文字で始まるのがリテラル（文字列？識別子？）で大文字から始まるのが変数です。</p>

<p>で、これをイメージしながらlexファイルを書いていきます。</p>

<h1>Lexファイル</h1>

<p>全体はこのようになっています。lexと同じですね。</p>

<p>```
SMLの補助コード部分</p>

<p>%%</p>

<p>補助ルールの記述</p>

<p>%%</p>

<p>解析ルールの記述</p>

<p>```</p>

<p>SMLの補助コードの部分は典型的には<code>datatype</code>を書きます。あとはどうも<code>error : string -&gt; unit</code>と <code>eof : unit -&gt; 'a</code>が必要みたいですね（マニュアルちゃんと読んでない）。<code>'a</code>というのは他の解析ルールと同じ型です。</p>

<p>補助ルールはlexとだいたい同じです。生成した関数やらデータ型を収めるstructureの指定とかもします。</p>

<p>解析ルールもだいたいlexと同じです。</p>

<pre><code>pattern =&gt; (SMLのコード);
</code></pre>

<p>のような形をしてます。</p>

<h1>実際のコード</h1>

<p>結構適当です。あ、カットのこと忘れてた。ほら、適当だった。</p>

<p>このコードをprolog.lexとして保存します。</p>

<p>```sml
datatype lexresult =</p>

<pre><code>     Comment of string
   | LeftParen
   | RightParen
   | LeftBracket
   | RightBracket
   | Comma
   | Dot
   | Bar
   | Medaka
   | UnderScore
   | String of string
   | Number of int
   | Variable of string
   | EOF
</code></pre>

<p>val linenum = ref 1
val error = fn x => print (x ^ &ldquo;\n&rdquo;)
val eof = fn () => EOF
%%
%structure PrologLex</p>

<p>alphanum = [A-Za-z0-9];
alpha    = [A-Za-z];
digit    = [0-9];
ws       = [\ \t\n];</p>

<p>%%</p>

<p>{ws}+            => (lex());
%(.<em>)\n          => (Comment yytext);
&ldquo;(&rdquo;              => (LeftParen);
&ldquo;)&rdquo;              => (RightParen);
&ldquo;[&rdquo;              => (LeftBracket);
&ldquo;]&rdquo;              => (RightBracket);
&ldquo;,&rdquo;              => (Comma);
&ldquo;.&rdquo;              => (Dot);
&ldquo;|&rdquo;              => (Bar);
&ldquo;:&ndash;&rdquo;             => (Medaka);
&ldquo;_&rdquo;              => (UnderScore);
[a-z]{alphanum}</em> => (String yytext);
{digit}+         => (Number (foldl (fn(a, r)=> (ord(a)-ord(#&ldquo;0&rdquo;)) + 10<em>r) 0 (explode yytext)));
[A-Z]{alphanum}</em> => (Variable yytext);</p>

<p>```</p>

<h1>実際に使ってみる。</h1>

<pre><code>$ mllex prolog.lex

Number of states = 19
Number of distinct rows = 8
Approx. memory size of trans. table = 1032 bytes
$ rlwrap sml
Standard ML of New Jersey v110.77 [built: Thu Sep  4 12:32:33 2014]
- use "prolog.lex.sml";
[opening prolog.lex.sml]
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[autoloading done]
structure PrologLex :
  sig
    structure UserDeclarations : &lt;sig&gt;
    exception LexError
    structure Internal : &lt;sig&gt;
    structure YYPosInt : &lt;sig&gt;
    val makeLexer : (int -&gt; string) -&gt; unit -&gt; Internal.result
  end
val it = () : unit
- val lexer = PrologLex.makeLexer (fn i =&gt; TextIO.inputN(TextIO.openIn "reverse.pl", i));
val lexer = fn : unit -&gt; PrologLex.Internal.result
- lexer();
val it = Comment "%reverse a list into X\n" : PrologLex.Internal.result
- lexer();
val it = String "reverse" : PrologLex.Internal.result
- lexer();
val it = LeftParen : PrologLex.Internal.result
- lexer();
val it = LeftBracket : PrologLex.Internal.result
- lexer();
val it = RightBracket : PrologLex.Internal.result
- 
</code></pre>

<p>コメントの扱い失敗してますね。この辺はどうしようもないのかなあ</p>

<h1>困ったところ</h1>

<p>ドキュメントが古いSML/NJのものらしく、SMLのコードをそのまま書いても動かなかった。<code>revfold</code>とか<code>inputc</code>とか。</p>

<p>次回はmlyaccでも触ってみますか。</p>
]]></content>
  </entry>
  
</feed>
