<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sml on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/sml/</link>
    <description>Recent content in Sml on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 04 Sep 2015 06:45:19 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/sml/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SMLでPNGデコーダを作ろうとして分かったこと</title>
      <link>http://keens.github.io/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</link>
      <pubDate>Fri, 04 Sep 2015 06:45:19 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLでPNGデコーダを作ろうとして分かったこと
------------------------------------------
サイバーエージェント アドテクスタジオ  
エンジニア月初会
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
----------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒
 + Lisp, ML, Shell Scriptあたりを書きます


&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うーむ。画像フォーマットの扱い一回くらい書いてみないとなーと思ってたけどやっぱり既存なんだよなー。Common LispかSMLあたりならフロンティアになれそう。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639303085240643584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 仕様を理解するためにデコーダから実装するのがオススメです&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639304790766305281&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; そんな詳しいわけではないんですが、jpegかpngがおすすめです。webpは動画コーデック由来で難しいと思います。tiffは画像コンテナみたいな立ち位置なので画像フォーマット感がないかなと。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639307400244137984&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

明日の朝までに  
&lt;span style=&#39;font-size:150%;&#39;&gt;SMLでpngデコーダを実装しよう&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Standard ML
-------------

* ML系の函数型言語
* 文法はOCamlよりF#に似てる（というかF#が似せてきた）
* 結構書き易い
* 仕様は SML&#39;90とSML&#39;97がある
* 仕様で言語のformal semanticsが定められてたりする
* 要は研究向き
  + **ライブラリほぼなし**
  + **コミュニティほぼなし**


&lt;span style=&#39;font-size:250%;&#39;&gt;＞　無理ゲー　＜&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 一応フォーマットを調べる
------------------------


```
+-----------------+
|     Chunk       | 画像はChunkの集合。
++---------------++ Chunk自体は簡単なフォーマット
|| length | name ||
|+---------------+|
||    data       ||
||    ...        ||
|+---------------+|
||    CRC        ||
++---------------++
|    Chunk        |
|    ...          |
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
意外と単純？
&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# とりあえず書いてみる
---------------------

```sml
structure PNG = struct
    fun readChunk data i = ...
end
```


# 案外苦戦
------------
* 型が厳密なので型の行き来が面倒
  + 8bit &lt;-&gt; 32bit
  + 符号付き &lt;-&gt; 符号無し
  + byte &lt;-&gt; char

```sml
val op &lt;&lt; = Word.&lt;&lt;
val op &gt;&gt; = Word.&gt;&gt;

fun nameToWord name = CharVector.foldl (fn(c, acc) =&gt; &lt;&lt;(acc, 0w8) + (Word.fromInt (ord c))) 0w0 name
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
3時間後
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;さて、メインのデータ抜き出すところまでは行ったけど次復号だ。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639501771430211584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 今更PNGについて
----------------

* GIFの特許問題を回避するために作られたフォーマット
  + LZ77がマズいらしい
* **可逆圧縮アルゴリズムを使う** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + **アルゴリズムは1つとは限らない** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
  + 但し仕様で指定されているのはzlibのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
* フィルタを噛ませることでプログレッシブな表示も可能


# SMLのZLibライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
zlib……実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ZLib
------

* RFC-1950
* zipやpngで使われるフォーマット
* ZLib自体は圧縮データのコンテナで **圧縮アルゴリズム自体は1つとは限らない**  &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + 但し仕様で指定されているのはdeflateのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;


# SMLのDeflateライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
deflate…実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Deflate
---------

* RFC-1951
* ハフマン符号の変種の可逆圧縮アルゴリズム
  + **3種類の符号化方式を自由に使ってよい** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;



&lt;span style=&#39;font-size:250%;&#39;&gt;(心)ボキッ&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 学んだこと
-----------

* PNGは一晩でデコーダを書ける程柔じゃない
  + 事前調査も大事
* 書き易い言語でもコミュニティが大事
* 1晩でLTの準備はつらい


# 付録
------

* [今回のコード](https://github.com/KeenS/sml-png)
* [SMLのパッケージマネージャ](https://github.com/standardml/smackage)
* [PNG](http://www.w3.org/TR/2003/REC-PNG-20031110/)
* [RFC-1950 ZLIB](https://www.ietf.org/rfc/rfc1950.txt)
* [RFC-1951 DEFLATE](https://www.ietf.org/rfc/rfc1950.txt)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>TCOと例外ハンドル</title>
      <link>http://keens.github.io/blog/2015/05/31/tcotoreigaihandoru</link>
      <pubDate>Sun, 31 May 2015 21:02:08 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/31/tcotoreigaihandoru</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;http://KeenS.github.io/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou&#34;&gt;先日のエントリー&lt;/a&gt;の最後でループ内で例外ハンドルをすると極端に遅くなるということを書きましたが、それについて。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/604235677337714689&#34;&gt;2015, 5月 29&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; うーん、ちょっと例外のことは詳しくないんですが、予想だと例外ハンドラをループ内にいれると毎回スタックに積むんで外す操作がはさまることになるのでレジスタで完結してるようなループ処理だと露骨に遅くなるかもしれません&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604537509771501569&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; あーありえますね。ジャンプで済むところを戻ってきてスタックに積んだのを除去しないといけませんからね。ちょっと手元にマシンが無いのですがネイティブコードで実験してみますー&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604540519188815872&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; ocamlでも例外ハンドラのはさみ方で末尾再帰になったり、ならなかったりするというのは聞いたことがあるので多分あたりな気がします&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604545844000325632&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということで実験してみましょう。&lt;/p&gt;

&lt;p&gt;次のような何がしたいのか分からないループのベンチマークを取ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は無限ループではなく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uncaught exception: Subscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、境界外アクセスの例外が出ます。因みにSubscripは添字って意味だそうです。&lt;/p&gt;

&lt;p&gt;これではベンチマークがとれないので、例外が起きたらループを抜けるようにしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Subscript =&amp;gt; ()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 5 ms/1calls
  [Average] 5.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一瞬ですね。では、末尾呼び出し位置でhandleしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(100, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
        handle Subscript =&amp;gt; ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 1729 ms/1calls
  [Average] 1729.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふーむ。やはり大分遅くなってますね。しかしループ内で例外をハンドルした所為かもしれないのでループ内で非末尾位置で例外をハンドルしてみます。大域脱出に例外使いますがまあ、パフォーマンスに問題ないでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;exception Exit
val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1)
        handle Subscript =&amp;gt; raise Exit;
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Exit =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 11 ms/1calls
  [Average] 11.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やはり多少は遅くなってますが末尾位置の時のように極端には遅くなってないようです。&lt;/p&gt;

&lt;p&gt;最後に非末尾再帰ループの速度を測っておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        1 + (loop ())
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Subscript =&amp;gt; 0
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 403 ms/1calls
  [Average] 403.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思ったより遅いですね。ループか末尾例外ハンドルかというと末尾例外ハンドルに近いスコア。&lt;/p&gt;

&lt;h1 id=&#34;考察:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;考察&lt;/h1&gt;

&lt;p&gt;末尾位置で例外をハンドルすると遅くなる原因はTCOが効かないから、で合ってそうです。&lt;/p&gt;

&lt;p&gt;しかしそれにしても遅いですね。例外ハンドラをスタックに積むのが1関数呼び出しくらいならせいぜい倍くらいの遅さで済む筈です。
もしかしたらループ展開とかの外の最適化も掛からなくなるのかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;結論:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;結論&lt;/h1&gt;

&lt;p&gt;例外をハンドルする時は位置に気をつけましょうね。&lt;/p&gt;

&lt;h1 id=&#34;付録a:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;ベンチマーカはこんなコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure Benchmark =
struct
fun repeat 0 f = ()
  | repeat n f =  (f ();repeat (n - 1) f)
 
fun bench n f = let
    val startTime = Time.now ()
    val _ = repeat n f
    val endTime = Time.now ()
in
    Time.toMilliseconds (Time.-(endTime, startTime))
end
 
fun benchmark name n f = let
    val time = bench n f
in
    print (name ^ &amp;quot;\n&amp;quot;);
    print (&amp;quot; Time:\n&amp;quot;);
    print (&amp;quot;    [Total] &amp;quot; ^ (LargeInt.toString time) ^ &amp;quot; ms/&amp;quot; ^ (Int.toString n) ^ &amp;quot;calls\n&amp;quot;);
    print (&amp;quot;  [Average] &amp;quot; ^ (Real.toString((Real.fromLargeInt time) / (Real.fromInt n))) ^ &amp;quot; ms/call\n&amp;quot;)
end

fun nChars n char = CharArray.vector(CharArray.array(n, char))

fun toWidth width str = let
    val len = String.size str
in
    if len &amp;lt; width
    then str ^ (nChars (width - len) #&amp;quot; &amp;quot;)
    else str
end

fun histLine width base value =
  (nChars (Int.fromLarge(width * value div base)) #&amp;quot;*&amp;quot;) ^ &amp;quot;\n&amp;quot;

fun benchset name n fs = let
    val res = List.map (fn (label, f) =&amp;gt; (label, bench n f)) fs
    val max = List.foldl (fn ((_, time), m) =&amp;gt; LargeInt.max(time, m)) 0 res
    val maxLen = List.foldl (fn ((label, _), m) =&amp;gt; Int.max(String.size label,  m)) 0 fs
in
    print &amp;quot;name:\n&amp;quot;;
    print ((nChars ((String.size &amp;quot; &amp;quot;) + maxLen) #&amp;quot;-&amp;quot;) ^ &amp;quot;+&amp;quot; ^ (nChars ((String.size &amp;quot;|&amp;quot;) +  50) #&amp;quot;-&amp;quot;) ^ &amp;quot;\n&amp;quot;);
    app (fn (label, time) =&amp;gt; print(&amp;quot; &amp;quot; ^ (toWidth maxLen label) ^ &amp;quot;|&amp;quot; ^(histLine (50:LargeInt.int) max time))) res;
    print ((nChars ((String.size &amp;quot; &amp;quot;) + maxLen) #&amp;quot;-&amp;quot;) ^ &amp;quot;+&amp;quot; ^ (nChars ((String.size &amp;quot;|&amp;quot;) +  50) #&amp;quot;-&amp;quot;) ^ &amp;quot;\n&amp;quot;)
end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;付録b:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;付録B&lt;/h1&gt;

&lt;p&gt;元々、なんでこの問題が生じたかというと一々境界チェックして配列にアクセスするより例外出させといた方が速いんじゃね？ってことでそういうコードを書いたからです。
例外が出るってことは内部でも境界チェックしてる筈ですから。&lt;/p&gt;

&lt;p&gt;ということでどちらが速いか確認してみましょう。&lt;/p&gt;

&lt;p&gt;まず例外ハンドル方式。先程のままだと数ミリ秒で終わってたので配列の大きさを10倍しました。あと。実際に書きそうな書き方に変えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val len = 10000000
    val arr = Array.array(len, 0)
    fun loop i = (
        Array.update(arr, i, 1);
        loop (i + 1)
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop 0
                                     handle Subscript =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 48 ms/1calls
  [Average] 48.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ、こんなもんですね。&lt;/p&gt;

&lt;p&gt;次にifで分岐するやりかた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val len = 10000000
    val arr = Array.array(len, 0)
    fun
    loop i = if i &amp;lt; len
             then (
                 Array.update(arr, i, 1);
                 loop (i + 1))
             else ()
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop 0
                                     handle Subscript =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 96 ms/1calls
  [Average] 96.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;倍くらい遅くなってますね。&lt;/p&gt;

&lt;p&gt;ということでみだりに境界チェックするより例外を出させといた方が速いようです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第一級ラベルを持たない言語におけるDirect Threaded VMの実装</title>
      <link>http://keens.github.io/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou</link>
      <pubDate>Fri, 29 May 2015 20:26:41 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou</guid>
      <description>

&lt;p&gt;こんにちは。κeenです。このブログでちょくちょく出てくるDirect Threaded VMについて。
SMLのようにgotoがない言語だとDT VMの実装出来ないよなー、と思ってた所、ふとアイディアが浮かんだのでそれについて。&lt;/p&gt;

&lt;h1 id=&#34;序論:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;序論&lt;/h1&gt;

&lt;p&gt;DSL、例えば正規表現などの処理系を実装することを考えてみて下さい。&lt;/p&gt;

&lt;p&gt;言語処理系において最も素朴な実装はインタプリタですが、速度面で不利なので一旦仮想命令にコンパイルして仮想命令実行器(VM)で実行することが一般的です。
コンパイラのように複雑な記号処理をするプログラムはCommon LispやMLのような記号処理に強い高級言語が得意とする分野です。
一方、ランタイムには低レベルなことが出来て処理速度の速いCommon LispやCを使いたくなるでしょう。&lt;/p&gt;

&lt;p&gt;Common Lisp以外の言語ではコンパイラとランタイムを分離するのが妥当な選択肢のようですが、高級言語とcの間のブッジングが必要になり、少なからぬコストを支払う必要があります。
また、ffiを持たない言語ではブリッジ出来ないのでランタイムもその言語で実装する必要があります。つまり、高級言語でVMを実装する必要があるケースが存在します。&lt;/p&gt;

&lt;p&gt;VMの実行を高速化する技術の一つとしてDirect Threadingというものがあります。
命令ディスパッチのループを短絡することで余計なオーバーヘッドが減り、また、命令毎にジャンプ命令を持つことで分岐予測も効きやすくなるのでVMが高速化します。
しかしDTの実装にはgotoのラベルを第一級オブジェクトとして保存する必要があり、gccやclangのように拡張されたcコンパイラなど、限られた言語でしか実現出来ません。まあ、Common Lispなら&lt;code&gt;eval&lt;/code&gt;と&lt;code&gt;compile&lt;/code&gt;を使えばJITが出来るので不要ですが。&lt;/p&gt;

&lt;p&gt;そこで、gotoのない言語でDirect Threadingを実現してみたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;direct-threading:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;Direct Threading&lt;/h1&gt;

&lt;p&gt;Direct Threaded &lt;em&gt;でない&lt;/em&gt; VMは大抵次のような構造をしています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loop {
  op = fetchNextOp
  switch(op) {
    case op1:
     ....
     break
    case op2:
     ....
     break
    ....
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;次の命令を取得する&lt;/li&gt;
&lt;li&gt;命令でディスパッチする&lt;/li&gt;
&lt;li&gt;命令に対応するコードを実行する&lt;/li&gt;
&lt;li&gt;ディスパッチを抜ける&lt;/li&gt;
&lt;li&gt;1.に戻る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という動きをします。自然に思えるかもしれませんが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;命令のディスパッチはlogオーダの時間が掛かる（可能性がある）。&lt;/li&gt;
&lt;li&gt;4. 5. のステップが不要&lt;/li&gt;
&lt;li&gt;2. で毎回違う命令にディスパッチするので分岐予測がほぼ意味を成さない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という無駄があります。それを改良したのがDirect Threaded VMで、オペコードではなくgotoのラベルを使うことで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;label = fetchNextLabel
goto label
label1:
  ...
  label = fetchNextLabel
  goto label
label2:
  ...
  label = fetchNextLabel
  goto label
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;次のラベルを取得する&lt;/li&gt;
&lt;li&gt;ラベルにgotoする&lt;/li&gt;
&lt;li&gt;命令に対応するコードを実行する&lt;/li&gt;
&lt;li&gt;次のラベルを取得する&lt;/li&gt;
&lt;li&gt;ラベルにgotoする(次の処理は3. 相当)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;と、ループ内の2ステップを飛ばした他、ディスパッチもなくなるので高速になります。
また、ラベル毎にgotoがついていて、それぞれのgotoに分岐予測があるので普通のVMに比べて分岐予測がある程度効きます。&lt;/p&gt;

&lt;h1 id=&#34;第一級ラベルを持たない言語におけるdirect-threaded-vm:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;第一級ラベルを持たない言語におけるDirect Threaded VM&lt;/h1&gt;

&lt;p&gt;結論から言うと関数の配列を使います。ラベルの代わりに配列のインデックス、gotoの代わりに配列へのアクセスとcallを使います。
ランダムアクセスでアドレスの取得をするために配列を、任意コードへのジャンプのために関数を使えばエミュレート出来るよねって発想です。&lt;/p&gt;

&lt;h1 id=&#34;実装:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;実装&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/SML-VM&#34;&gt;ソースコード全体&lt;/a&gt;はGithuに上げてます。SML/NJで動きます。SML#向けのインターフェースファイルを書いていますが何故かコンパイルが通りません。&lt;/p&gt;

&lt;p&gt;次のようなASTを実行するインタプリタ、VM、Direct Threaded VMを実装しました。但し、VMとDTVMはクロージャをサポートしていません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype monoop
  = Not

datatype binop
  = Equal
  | GreaterThan
  | Add

datatype t
  = Int of int
  | Bool of bool
  | MonoOp of monoop * t
  | BinOp of binop * t * t
  | Bind of t * t
  | If of t * t * t
  | Var of string
  | Lambda of t list * t
  | Call of t * t list
  | Progn of t list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インタプリタはこのASTを解釈実行、VMはいくつかの中間表現を経てオペコードにコンパイルし、それを実行します。尚、最適化は行いません。&lt;/p&gt;

&lt;p&gt;VMのディスパッチ部分は次のような実装になっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;    fun aux () = (
        case  (Array.sub(ops, !pc)) of
            O.Not =&amp;gt; (case pop vm of
                         V.Bool x =&amp;gt; push vm (V.Bool (not x))
                       | _ =&amp;gt; raise Type)
          | O.Add =&amp;gt; (case (pop vm, pop vm) of
                         (V.Int x, V.Int y) =&amp;gt; push vm (V.Int (x + y))
                       | _ =&amp;gt; raise Type)
          | O.Eq =&amp;gt; (case (pop vm, pop vm) of
                        (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x = y))
                      | (V.Bool x, V.Bool y) =&amp;gt; push vm (V.Bool (x = y))
                      | _ =&amp;gt; raise Type)
          | O.Gt =&amp;gt; (case (pop vm, pop vm) of
                        (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x &amp;lt; y))
                      | _ =&amp;gt; raise Type)
          | O.Jump label =&amp;gt; pc := (label - 1)
          | O.Jtrue label =&amp;gt; (case pop vm of
                                 V.Bool true =&amp;gt; pc := (label - 1)
                               | V.Bool false =&amp;gt; ()
                               | _ =&amp;gt; raise Type)
          | O.Call i =&amp;gt; (case (pop vm) of
                            V.Lambda label =&amp;gt; (
                             pushCi vm;
                             fp := (!fp) - i;
                             pc := (label - 1))
                          | _ =&amp;gt; raise Type)
          | O.Ret =&amp;gt; (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1));
                     popCi vm;
                     pc := (!pc))
          | O.Push v =&amp;gt; push vm v
          | O.Pop =&amp;gt; (pop vm;())
          | O.Lref i =&amp;gt; push vm (Array.sub(stack, (!fp) + i))
          | O.Lset i =&amp;gt;  ((Array.update(stack, (!fp) + i, pop vm));
                         push vm (V.Bool true))
          | O.Gref i =&amp;gt; push vm (Array.sub(pool, i))
          | O.Gset i =&amp;gt;  (Array.update(pool, i, pop vm); push vm (V.Bool true))
          | O.Nop =&amp;gt; ()
          | O.End =&amp;gt; raise Exit
      ;
        pc := (!pc) + 1;
      aux ())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DT VMではこれを次のように書き換えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun next () = let
    val () = pc := (!pc) + 1;
    val (index, arg) = Array.sub(cops, !pc) in
    Array.sub(opArray, index) arg
end

Array.fromList [
            (* Not *)
            fn _ =&amp;gt;
                (case pop vm of
                    V.Bool x =&amp;gt; push vm (V.Bool (not x))
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Add *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Int (x + y))
                  | _ =&amp;gt; raise Type;
                 next ()),
            (* Eq *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x = y))
                  | (V.Bool x, V.Bool y) =&amp;gt; push vm (V.Bool (x = y))
                  | _ =&amp;gt; raise Type;
                  next ()),
            (* Gt *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x &amp;lt; y))
                  | _ =&amp;gt; raise Type;
                 next ()),
            (* Jump *)
            fn ({int = label, ...}: oparg) =&amp;gt;
               (pc := (label - 1);
               next ()),
            (* Jtrue *)
            fn ({int = label, ...}: oparg) =&amp;gt;
                (case pop vm of
                    V.Bool true =&amp;gt; pc := (label - 1)
                  | V.Bool false =&amp;gt; ()
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Call *)
            fn ({int = i, ...}: oparg) =&amp;gt;
                (case (pop vm) of
                    V.Lambda label =&amp;gt; (
                     pushCi vm;
                     fp := (!fp) - i;
                     pc := (label - 1))
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Ret *)
            fn _ =&amp;gt;
                (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1));
                 popCi vm;
                 pc := (!pc);
                next ()),
            (* Push *)
            fn ({vmvalue = v, ...}: oparg) =&amp;gt;
               (push vm v;
               next ()),
            (* Pop *)
            fn _ =&amp;gt;
               (pop vm;
                next ()),
            (* Lref *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (push vm (Array.sub(stack, (!fp) + i));
               next ()),
            (* Lset *)
            fn ({int = i, ...}: oparg) =&amp;gt;
                ((Array.update(stack, (!fp) + i, pop vm));
                 push vm (V.Bool true);
                next ()),
            (* Gref *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (push vm (Array.sub(pool, i));
               next ()),
            (* Gset *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (Array.update(pool, i, pop vm);
                push vm (V.Bool true);
               next ()),
            (* Nop *)
            (fn _ =&amp;gt;
                next ()),
            (fn _ =&amp;gt;
                raise Exit)
        ]

fun aux () = let val (index, arg) = Array.sub(cops, !pc) in
                 Array.sub(opArray, index) arg
             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1引数を受け取ってunitを返す関数の配列としてVMを表しています。
1つ注意点として、前処理としてタグ付き共用体として表されている命令をタグ(配列のインデックス)と共用体に分解するのですが、SMLに共用体はないので構造体で代用しています。 &lt;code&gt;oparg&lt;/code&gt; 型がそれにあたります。&lt;/p&gt;

&lt;p&gt;ディスパッチを関数&lt;code&gt;next&lt;/code&gt;に括り出していて、一見すると分岐予測に関する利点が失われるように思われますが、
&lt;code&gt;next&lt;/code&gt;は小さいのでインライン化されるだろうと踏んでそのままにしています。実際、手動でインライン化しても速度に変化はありませんでした。&lt;/p&gt;

&lt;p&gt;今回のメインの話はVMなのでインタプリタについては省略します。&lt;/p&gt;

&lt;h1 id=&#34;実行速度:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;実行速度&lt;/h1&gt;

&lt;h2 id=&#34;予測:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;予測&lt;/h2&gt;

&lt;p&gt;普通のVMはディスパッチをlogオーダーの時間で行ないますがDT VMは定数オーダーの時間で行ないます。しかし配列の参照と関数呼び出しを挟むので定数倍の部分は大きくなります。
どちらが速いでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;計測:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;計測&lt;/h2&gt;

&lt;p&gt;今回、次のようなフィボナッチ数列を計算するコードの実行速度を計測しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun fib n = (Progn [
                Bind (Var &amp;quot;fib&amp;quot;,
                      Lambda([Var &amp;quot;n&amp;quot;],
                               (If (BinOp(GreaterThan,
                                          (Int 2),
                                          (Var &amp;quot;n&amp;quot;)),
                                    Int(1),
                                    BinOp(Add,
                                          Call(Var &amp;quot;fib&amp;quot;, [BinOp(Add,
                                                                 Var &amp;quot;n&amp;quot;,
                                                                 Int ~1)]),
                                          Call(Var &amp;quot;fib&amp;quot;, [BinOp(Add,
                                                                 Var &amp;quot;n&amp;quot;,
                                                                 Int ~2)])))))),
                Call(Var &amp;quot;fib&amp;quot;, [Int n])])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンパイラは以下のような命令列を吐きます。命令の内部表現が違うだけで命令列自体はVMとDTVMで共通です。
繰り返しますが、最適化はしてないのでL25で次の命令にジャンプしてるだとか目に見えて無駄なコードもあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0	Push Lambda 7
1	Gset 0
2	Pop
3	Push 35
4	Gref 0
5	Call 1
6	End
7	Push 2
8	Lref 0
9	Gt
10	Jtrue 12
11	Jump 14
12	Push 1
13	Jump 26
14	Lref 0
15	Push ~1
16	Add
17	Gref 0
18	Call 1
19	Lref 0
20	Push ~2
21	Add
22	Gref 0
23	Call 1
24	Add
25	Jump 26
26	Ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;計測には次のようなコードを使いました。コンパイラは実行効率を無視して書いたのでベンチマークには含めていません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val target = (AST.fib 35)
val compiled = VM.compile target
val dtcompiled = DTVM.compile target
val vm = VM.new ()
val dtvm = DTVM.new ()

val _ = Benchmark.benchset &amp;quot;fib 35&amp;quot; 1 [
        (&amp;quot;Interpreter&amp;quot;,
         fn () =&amp;gt; (Interp.run target; ())),
        (&amp;quot;Normal VM&amp;quot;,
         fn () =&amp;gt; (VM.run vm compiled; ())),
        (&amp;quot;Direct Threaded VM&amp;quot;,
         fn () =&amp;gt; (DTVM.run dtvm dtcompiled; ()))
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;結果:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;Intel Core i5 M450 2.4GHz 2コア4スレッド、Ubunt 15.04、SML/NJ v110.77で実行しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-------------------+---------------------------------------------------
 Interpreter       |********************************************* 47170ms
 Normal VM         |****************** 19170ms
 Direct Threaded VM|************************************************** 51460ms
-------------------+---------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ダントツで速いのがVMで、インタプリタに比べてかなりの性能向上が見られます。一方DT VMはインタプリタより遅いという結果になりました。&lt;/p&gt;

&lt;h1 id=&#34;考察:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;考察&lt;/h1&gt;

&lt;p&gt;冷静に考えたらインタプリタは毎回関数呼び出して遅いよねってことからループで処理を済ませるのがVMなのにVMで毎回関数を呼び出してたら遅いに決まってるじゃん。
というかこれ、Direct Threaded VMじゃないじゃん。死にたい。&lt;/p&gt;

&lt;h1 id=&#34;余談:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;余談&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/604235677337714689&#34;&gt;2015, 5月 29&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;尚、このつぶやきはfibの引数を小さくして繰り返しを増やした時のものです。多分コンパイルを外に出してるので繰り返しが多いとその分のオーバーヘッドの差が効いてくるのでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val target = (AST.fib 24)
val compiled = VM.compile target
val dtcompiled = DTVM.compile target
val vm = VM.new ()
val dtvm = DTVM.new ()

val _ = Benchmark.benchset &amp;quot;fib 24&amp;quot; 10 [
        (&amp;quot;Interpreter&amp;quot;,
         fn () =&amp;gt; (Interp.run target; ())),
        (&amp;quot;Normal VM&amp;quot;,
         fn () =&amp;gt; (VM.run vm compiled; ())),
        (&amp;quot;Direct Threaded VM&amp;quot;,
         fn () =&amp;gt; (DTVM.run dtvm dtcompiled; ()))
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-------------------+---------------------------------------------------
 Interpreter       |************************************************** 2052ms
 Normal VM         |** 104ms
 Direct Threaded VM|***** 238ms
-------------------+---------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SMLを書くLisperの悩み</title>
      <link>http://keens.github.io/blog/2015/05/03/smlwokakulispernonayami</link>
      <pubDate>Sun, 03 May 2015 13:23:17 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/03/smlwokakulispernonayami</guid>
      <description>&lt;p&gt;SMLばっかり書いてたら「お前Lisperじゃないだろ」って怒られたとかそういう話ではなく。&lt;/p&gt;

&lt;p&gt;ML系の言語は関数は1つの引数しかとれません。じゃあ複数の値を受け取りたい時はどうするかというと 1. 値を組(タプル)にして受け取る 2. 関数を返す関数((を返す関数)*)にして1つづつ受け取る の2種類の方法があります。
それに纏わる話。&lt;/p&gt;

&lt;p&gt;それぞれの記法を例示すると&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;値を組(タプル)にして受け取る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun add (x, y) = x + y
add (1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは、手続型言語に似せて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;add(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするスタイルもあります&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;関数を返す関数((を返す関数)*)に(カリー化)して1つづつ受け取る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun add x y = x + y
add x y  (*= ((add x) y)  *)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。勿論、2.のように何度も関数を呼び出すよりは1.のように一度で全ての値を渡してしまった方が速い筈です。なのでプリミティブっぽい関数はタプル式にした方が良さそうです。
また、無名関数を定義する時にSMLでは&lt;code&gt;fun&lt;/code&gt;のように自動でカリー化してくれる構文がないので複数の引数を受け付ける関数を引数にとる高階関数を定義するときはタプル式の方が都合が良いでしょう。&lt;/p&gt;

&lt;p&gt;例えば二項演算子はタプル式で定義しなければなりませんし、&lt;code&gt;List.foldl&lt;/code&gt;のシグネチャも&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(&#39;a * &#39;b -&amp;gt; &#39;b) -&amp;gt; &#39;b -&amp;gt; &#39;a list -&amp;gt; &#39;b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;p&gt;勿論、積極的に最適化を行なうコンパイラではuncurry optimizationや、closure eliminationでカリー化によるオーバーヘッドはなくなります。
むしろ、カリー化した方が部分適用が出来るので利便性は上がります。となると後は無名関数の問題ですが、OCamlやHaskellなど無名関数にもカリー化した定義が出来る構文のある言語だとそれも問題なく、タプル式の引数の渡し方はしないようです。&lt;/p&gt;

&lt;p&gt;SMLは流石に&amp;rsquo;Standard&amp;rsquo;なので最適化を仮定したり余計な構文を突っ込んだりはしづらいのでしょう。なのでこの問題はSML特有のようです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ここまで、なぜタイトルがML系言語ではなくSML限定なのかの前置き。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;こういう関数呼び出しがあるとします。&lt;code&gt;sub: string * int -&amp;gt; char&lt;/code&gt;は文字列の0番目の文字を取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;sub(str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに&lt;code&gt;Char.isAlpha : char -&amp;gt; bool&lt;/code&gt;を適用します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Char.isAlpha sub(str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ、コンパイルエラーになります。みなさん何でか分かりますか？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sub(str, 0)&lt;/code&gt;はあくまで&lt;code&gt;sub&lt;/code&gt;に&lt;code&gt;(str, 0)&lt;/code&gt;というタプルを渡している文なのでコンパイラはこう解釈するのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(Char.isAlpha sub) (str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回このようなエラーを出すのが面倒なので関数の呼び出しには全て手続き型言語のように括弧をつけることを考え始めます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Char.isAlpha(sub(str, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしそうは問屋が卸さないのがカリー化された関数。&lt;code&gt;String.isPrefix: string -&amp;gt; string -&amp;gt; bool&lt;/code&gt;に次のような呼び出しをすると勿論怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;String.isPrefix(&amp;quot;/usr/local&amp;quot; path)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必ず&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;String.isPrefix &amp;quot;/usr/local&amp;quot; path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としないといけません。これまた関数呼び出しがネストすると面倒で、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;app (fn s =&amp;gt; print (s ^ &amp;quot;\n&amp;quot;)) (List.filter (String.isPrefix &amp;quot;/usr/local&amp;quot;) paths)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように毎回括弧が付き纏います。ここまでくるとS式みたく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(app (fn s =&amp;gt; print (s ^ &amp;quot;\n&amp;quot;)) (List.filter (String.isPrefix &amp;quot;/usr/local&amp;quot;) paths))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きたくなってくるのがLisperの心情。これなら慣れないデータコンストラクタや関数呼び出しや中置演算子の優先順位問題も解決!やったね!!と思ったのですがやっぱりタプル式の関数呼出が行く手を阻むのでした。
&lt;code&gt;(sub(str, i))&lt;/code&gt; とか訳分からなすぎる。括弧多すぎる。&lt;/p&gt;

&lt;p&gt;ということでどっちに揃えたら良いのかさえ分かってないのにどっちにも揃えられてないSMLに対して悩みを抱えるLisperの悩みでした。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;は&lt;code&gt;Char.isAlpha()&lt;/code&gt;のような書き方は無駄な括弧がついてると怒ってきます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#をMacでビルドする</title>
      <link>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</link>
      <pubDate>Wed, 29 Apr 2015 16:09:08 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</guid>
      <description>

&lt;p&gt;κeenです。SML#2.0.0を文鎮と化していたMBAにインストールしたのでメモをば。&lt;/p&gt;

&lt;p&gt;基本は&lt;a href=&#34;http://d.hatena.ne.jp/keita44_f4/20140412/1397279451&#34;&gt;よんたさんの記事&lt;/a&gt;をMacに翻訳した感じです。&lt;/p&gt;

&lt;p&gt;モチベーションは、&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/ja/?Download&#34;&gt;公式の配布物&lt;/a&gt;がMac版だとMacPorts版しかなく、
portsとhomebrewの混在は避けた方が良いと聞いたのでどうにかして自前ビルドしようとしたことです。&lt;/p&gt;

&lt;h1 id=&#34;注意書き:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;注意書き&lt;/h1&gt;

&lt;p&gt;冒頭にも書いてあるようにMBAは普段使ってなくて、このエントリーもMBAじゃないマシンから書いているのでコマンド類はコピペでなく写経してます。
typoがあるかもしれないのでコピペして動かなかったら一応この記事のtypoを疑って下さい。&lt;/p&gt;

&lt;h1 id=&#34;gmp32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;GMP32bitの準備&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ brew install gmp --32-bit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で終わり。バージョン6.0.0aが入りました。
既にインストールされていたら多分64bit版が入っているので一旦 &lt;code&gt;brew remove gmp&lt;/code&gt; してから再度インストールすると良いです。尚、バイナリ版はないようで、ビルドが始まります。checkに時間が掛かる。&lt;/p&gt;

&lt;h1 id=&#34;llvm34-32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;LLVM34 32bitの準備&lt;/h1&gt;

&lt;p&gt;骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://llvm.org/releases/3.4.2/llvm-3.4.2.src.tar.gz
$ gzcat llvm-3.4.2.src.tar.gz | tar xf -
$ cd llvm-3.4.2.src
$ ./configure --build=i686-mac-darwin CC=&#39;gcc -m32&#39; CXX=&#39;g++ -m32&#39; --prefix=/usr/local/Cellar/llvm34/3.4.2a
$ make -j4
$ make -j4 install
$ cd ../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら上手くいきました。何故上手くいったんでしょうねー。あとprefixは割と気持悪いのでみなさん適切な場所にインストールしましょうね。&lt;/p&gt;

&lt;h1 id=&#34;sml-のビルド:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;SML# のビルド&lt;/h1&gt;

&lt;p&gt;これが一番骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.pllab.riec.tohoku.ac.jp/smlsharp/download/smlsharp-2.0.0.tar.gz
$ gzcat smlsharp-2.0.0.tar.gz | tar xf -
$ cd smlsharp-2.0.0
$ ./configure --with-llvm=/usr/local/Cellar/llvm34/3.4.2a/      \
               LDFLAGS=&#39;-L/usr/local/Cellar/gmp/6.0.0a/lib&#39;     \
              CPPFLAGS=&#39;-I/usr/local/Cellar/gmp/6.0.0a/include&#39; \
                    CC=&#39;gcc -m32&#39;                               \
                   CXX=&#39;g++ -m32&#39;
$ make -j4
$ make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら出来ました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;誰かhomebrewにして。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpを使ってSMLのon-the-flyエラーチェック</title>
      <link>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</link>
      <pubDate>Thu, 23 Apr 2015 23:01:17 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</guid>
      <description>

&lt;p&gt;κeenです。最近SMLを結構書いてるのですが中置演算子が乱立する言語はLisperにはつらくて、しょっちゅうコンパイルエラーを出します。
そこでSML#をflymakeで動かしてOn The Flyにエラーチェックをします。&lt;/p&gt;

&lt;p&gt;なぜSML#かというと &lt;code&gt;-ftypecheck-only&lt;/code&gt; オプションがあって、シンタックスと型エラーのチェックだけを行なえるからです。&lt;/p&gt;

&lt;p&gt;色々試したのですが設定はこれだけで済みました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(eval-after-load &#39;flymake
  &#39;(progn 
    (add-to-list &#39;flymake-allowed-file-name-masks &#39;(&amp;quot;.+\\.sml$&amp;quot;
                                                    (lambda ()
                                                      (list &amp;quot;/usr/local/bin/smlsharp&amp;quot; (list &amp;quot;-ftypecheck-only&amp;quot; (buffer-file-name))))
                                                    (lambda () nil)))
    (add-to-list &#39;flymake-err-line-patterns &#39;(&amp;quot;^\\([^: ]*\\):\\([0-9]+\\)\\.\\([0-9]+\\)-[0-9]+\\.[0-9]+ \\(Error\\|Warning\\):&amp;quot;
                                              1 2 3 4))))
(add-hook &#39;sml-mode-hook #&#39;flymake-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;/usr/local/bin/smlsharp&amp;quot;&lt;/code&gt; のところは各自書き換えて下さい。尚、SML#はエラーメッセージを複数行に跨って出すのですがそれがflymakeと相性が悪いのでエラーメッセージの取得は諦めました。&lt;/p&gt;

&lt;p&gt;多くの場合、 &lt;code&gt;flymake-simple&lt;/code&gt; という枠組みの中で設定を書くのですがテンポラリファイルを作る構造がどうしてもインターフェースファイルと相性が悪かったので生のflymakeを使ってます。
というかflymakeは元々 &lt;code&gt;-ftypecheck-only&lt;/code&gt; みたいなのを前提に作られてたのに実際にコンパイル走らせないとエラーメッセージ取得出来ない言語が多過ぎてフレームワークが出来たのでこれが本来の使い方です。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:311ce9d5e51e732b1928a84bcceb27a3&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;というものがあって、スタイルワーニングを出してくれます。ただ、これはパッチを当てないと使えなかったりスタイルワーニングのみしか出さなかったりするので気が向いた時に紹介します&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpでFFIバインディングを書く時の知見</title>
      <link>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</link>
      <pubDate>Sun, 19 Apr 2015 13:51:33 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</guid>
      <description>

&lt;p&gt;κeenです。最近頻繁にSML#を使ってます。SML#のメイン機能の1つであるC連携ですが、ちょっと複雑なことをやろうとするとテクニックが必要になるので共有します。&lt;/p&gt;

&lt;p&gt;Twitterとかにコメントや突っ込みお願いします。&lt;/p&gt;

&lt;h1 id=&#34;簡単な型:017736760057fcde64c6904c3e916b13&#34;&gt;簡単な型&lt;/h1&gt;

&lt;p&gt;型が簡単な関数なら普通に&lt;code&gt;_import&lt;/code&gt;で済みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val puts = _import &amp;quot;puts&amp;quot;: string -&amp;gt; ()
val () = puts &amp;quot;Hello, C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尚、簡単な型とは&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch9.S2.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;にある通り、いわゆる即値、即値の組（タプル）、即値の配列、即値の参照、それらを引数、返り値に持つ関数などです。&lt;/p&gt;

&lt;p&gt;又、以下のような制約もあります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C関数全体の型は，引数リストを組型とするMLの関数型に対応付けられます． ただし，C関数の引数や返り値に書ける相互運用型には，以下の制約があり ます．
   配列型や組型など，Cのポインタ型に対応する相互運用型を，C関数の返り値の 型として指定することはできません．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恐らくGCとの兼ね合いでしょうがつらいですね。stringすら返り値で受け取れません。&lt;/p&gt;

&lt;p&gt;それにこの制約がどこまで効いてるのかが不明で、同じ型でも型付けに成功したり失敗したりすることがあります。例えば上の例でstring型を引数にとる関数をインポートしましたが関数に依ってはstringが相互運用型でないとか怒られることがあります。タプルの配列やタプルの参照などは確実にダメみたいです。&lt;/p&gt;

&lt;p&gt;尚、string型はCでいう &lt;code&gt;const char *&lt;/code&gt; 、タプルは変更不能な構造体へのポインタになるそうです。構造体の即値は扱えないんですね…。また、参照とは別に &lt;code&gt;ptr&lt;/code&gt; 型も存在します。SML#側からは作れず、Cとの相互運用のためだけに存在するようです。&lt;/p&gt;

&lt;h1 id=&#34;魔法の-unit-ptr:017736760057fcde64c6904c3e916b13&#34;&gt;魔法の &lt;code&gt;unit ptr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;じゃあ複雑な型はインポート出来ないのかというとそうでもなく、 &lt;code&gt;unit ptr&lt;/code&gt; 型にしておけばとりあえずインポート出来ます。Cで言うところの &lt;code&gt;void *&lt;/code&gt; です。
邪悪な雰囲気を感じますね。しかしそこは型安全言語、ちゃんと型安全に &lt;code&gt;unit ptr&lt;/code&gt; を扱えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;type file = unit ptr
val fopen = _import &amp;quot;fopen&amp;quot;: (string, string) -&amp;gt; file
val fgetc = _import &amp;quot;fgetc&amp;quot;: (file) -&amp;gt; int
val fclose = _import &amp;quot;fclose&amp;quot;: (file) -&amp;gt; int
val () = let
      val f = fopen(&amp;quot;test&amp;quot;, &amp;quot;r&amp;quot;)
      val c = fgetc(f)
    in
      print(str(chr c));
      fclose(f)
    end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。単に &lt;code&gt;type&lt;/code&gt; で名前をつけてあげれば大丈夫です。SML#側ではポイント先が何であるかには関知せず、インポートしたC関数の間で完結してれば問題ありません。多くのライブラリはそのようなAPIになっているのではないでしょうか。&lt;/p&gt;

&lt;h1 id=&#34;ポインタを扱う:017736760057fcde64c6904c3e916b13&#34;&gt;ポインタを扱う&lt;/h1&gt;

&lt;p&gt;とはいえ時にポインタを扱う必要もあります。構造体の配列を扱えないのでその辺で。&lt;/p&gt;

&lt;p&gt;そういった時に便利なのが &lt;code&gt;SMLSharp_Builtin.Pointer&lt;/code&gt; と &lt;code&gt;Pointer&lt;/code&gt; です。 &lt;code&gt;Pointer&lt;/code&gt; の方は .smi ファイルの中で &lt;code&gt;_require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt; してから使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure SMLSharp_Builtin
  structure Pointer =
  struct
    val identityEqual = _builtin val IdentityEqual : boxed * boxed -&amp;gt; bool
    val advance = _builtin val Ptr_advance : &#39;a ptr * int -&amp;gt; &#39;a ptr
    val deref = _builtin val Ptr_deref : &#39;a ptr -&amp;gt; &#39;a
    val store = _builtin val Ptr_store : &#39;a ptr * &#39;a -&amp;gt; unit

    val toUnitPtr = _builtin val Cast : &#39;a ptr -&amp;gt; unit ptr
    val fromUnitPtr = _builtin val Cast : unit ptr -&amp;gt; &#39;a ptr
    val toCodeptr = _builtin val BitCast : unit ptr -&amp;gt; codeptr
  end
  end

structure Pointer =
struct
  val advance = SMLSharp_Builtin.Pointer.advance

  val load =
      case &#39;a in &#39;a ptr -&amp;gt; &#39;a of
        int =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | char =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.deref

  val store =
      case &#39;a in &#39;a ptr * &#39;a -&amp;gt; unit of
        int =&amp;gt; SMLSharp_Builtin.Pointer.store
      | word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | char =&amp;gt; SMLSharp_Builtin.Pointer.store
      | real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.store

  val isNull : &#39;a ptr -&amp;gt; bool
  val NULL : unit -&amp;gt; &#39;a ptr

  val importBytes : SMLSharp_Builtin.Word8.word ptr * int
                    -&amp;gt; SMLSharp_Builtin.Word8.word vector
  val importString : char ptr -&amp;gt; string
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 、 &lt;code&gt;store&lt;/code&gt; 、 &lt;code&gt;deref&lt;/code&gt; 、 &lt;code&gt;advance&lt;/code&gt; あたりを良く使いそうですね。&lt;/p&gt;

&lt;p&gt;実際にあった話。 &lt;code&gt;struct header { const char *name; int name_len; const char *value; int value_len}&lt;/code&gt; の配列(&lt;code&gt;struct header *&lt;/code&gt;)を扱う必要がありました。
その配列をCの関数に渡して書き換えてもらって、後で値を取り出したいという状況がです。その時値を取り出すコードがこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun getHeader headers i =
      let
          val header_ptr : char ptr ptr = fromUnitPtr(headers)
          val header_ptr = advance(header_ptr, i * 2)
          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val header_ptr = advance(header_ptr , i * 2)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val name = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val nameLen = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val value = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val valueLen = deref(header_ptr)
      in
          if isNull name
          then (NONE, String.substring(importString(value), 0, valueLen))
          else (SOME(String.substring(importString(name), 0, nameLen)),
                String.substring(importString(value), 0, valueLen))
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、タプルは構造体へのポインタなので今回の &lt;code&gt;struct header *&lt;/code&gt; は &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではありません。それは &lt;code&gt;struct header **&lt;/code&gt; になってしまいます。
また、ポインタを扱う関数が &lt;code&gt;ptr&lt;/code&gt; 型しか受け付けないので &lt;code&gt;string&lt;/code&gt; ではなく &lt;code&gt;char ptr&lt;/code&gt; にしておいて後から &lt;code&gt;importString&lt;/code&gt; で文字列にする戦略をとります。&lt;/p&gt;

&lt;p&gt;そして配列のi番目にアクセスしたかったら先述の通り &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではないので地道に &lt;code&gt;char ptr ptr&lt;/code&gt; 2*i個分、 &lt;code&gt;int ptr&lt;/code&gt; 2*i個分ポインタを進めます。
ポインタの型を変える時はダイレクトには変換出来ないようなので一旦 &lt;code&gt;unit ptr&lt;/code&gt; を経由してから変換。そして次のメンバにアクセスするために &lt;code&gt;advance&lt;/code&gt; という形をとります。&lt;/p&gt;

&lt;p&gt;そこまでしたら後は &lt;code&gt;deref&lt;/code&gt; してあげれば欲しい値がとれます。&lt;/p&gt;

&lt;h1 id=&#34;replからのimportと-dynamiclink:017736760057fcde64c6904c3e916b13&#34;&gt;REPLからのimportと &lt;code&gt;DynamicLink&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;SML#のREPLからも勿論インポート出来ますが、SML#のランタイムにリンクされてないライブラリのものはインポート出来ないのでダイナミックリンクを使います。 &lt;code&gt;DynamicLink&lt;/code&gt; にCの &lt;code&gt;dl*&lt;/code&gt; と同じ関数群が用意されているのでそれらを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure DynamicLink =
struct
  type lib (= ptr)
  datatype scope = LOCAL | GLOBAL
  datatype mode = LAZY | NOW
  val dlopen : string -&amp;gt; lib
  val dlopen&#39; : string * scope * mode -&amp;gt; lib
  val dlsym : lib * string -&amp;gt; codeptr
  val dlsym&#39; : lib * string -&amp;gt; unit ptr
  val dlclose : lib -&amp;gt; unit
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;val lib = dlopen(&amp;quot;libawsome.so&amp;quot;)&lt;/code&gt; でライブラリのオープン、 &lt;code&gt;dlsym(lib, &amp;quot;awm_function&amp;quot;): _import () -&amp;gt;unit&lt;/code&gt; で読み込みです。&lt;/p&gt;

&lt;p&gt;これでインポートする関数は必要になった時に読み込んで欲しいのですがトップレベルで &lt;code&gt;val&lt;/code&gt; でバインドすると即読み込まれてしまいます。その辺を上手くやるテクニックがSML#のソースにありました。MySQLのバインディングの部分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun lazy f =
      let
        val r = ref NONE
      in
        fn () =&amp;gt;
           case !r of
             SOME x =&amp;gt; x
           | NONE =&amp;gt;
             let val x = f ()
             in r := SOME x; x
             end
      end

  val lib =
      lazy (fn _ =&amp;gt;
               DynamicLink.dlopen
                 (case OS.Process.getEnv &amp;quot;SMLSHARP_LIBMYSQLCLIENT&amp;quot; of
                    NONE =&amp;gt; &amp;quot;libmysqlclient.16.&amp;quot; ^ SMLSharp_Config.DLLEXT ()
                  | SOME x =&amp;gt; x))

  fun find s = DynamicLink.dlsym(lib (), s)
  val mysql_init =
      lazy (fn _ =&amp;gt; find &amp;quot;mysql_init&amp;quot;
                    : _import (MYSQL) -&amp;gt; MYSQL)


...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遅延評価してますね。これ。呼び出す時は &lt;code&gt;mysql_init () (mysql)&lt;/code&gt; みたいに一旦lazyを剥がさないといけないので注意です。&lt;/p&gt;

&lt;h1 id=&#34;問題とか:017736760057fcde64c6904c3e916b13&#34;&gt;問題とか&lt;/h1&gt;

&lt;h2 id=&#34;cの仕様:017736760057fcde64c6904c3e916b13&#34;&gt;Cの仕様&lt;/h2&gt;

&lt;p&gt;確かCの仕様上構造体のメモリ上の表現にはメンバ以外のものも置いていいことになっていた筈です。
上の方法では変なコンパイラでコンパイルしたコードだと動きそうにないですね。GCCやClangは大丈夫な筈。&lt;/p&gt;

&lt;p&gt;そもそもSML#自体GCCとABI互換なコンパイラでコンパイルしたものじゃないとリンク出来なそうな気がするので杞憂ですかね。&lt;/p&gt;

&lt;h2 id=&#34;メモリ確保:017736760057fcde64c6904c3e916b13&#34;&gt;メモリ確保&lt;/h2&gt;

&lt;p&gt;Cの関数から構造体のポインタが返ってくるケースだと良いんですが自分で構造体を用意してCの関数に渡すケースだとメモリの確保が問題になります。現状、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct header
*prepare_headers(int n)
{
  return malloc(n * sizeof(struct header));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなヘルパ関数を用意して凌いでますが欲しい構造体毎に書かないといけないのであまり嬉しくないです。 &lt;code&gt;sizeof&lt;/code&gt; をSML#側でとれれば単に &lt;code&gt;malloc&lt;/code&gt; をバインドするだけで済むのに。
もう少し欲を言うと &lt;code&gt;malloc&lt;/code&gt; したらGCから外れそうな気がするので明示的に &lt;code&gt;free&lt;/code&gt; する必要がありそうです。GCに載るメモリ確保関数も欲しいですね。
さらに欲を言うとスタックアロケートする版のメモリ確保関数も欲しい。もしかしたら &lt;code&gt;alloca&lt;/code&gt; で大丈夫なんでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;define:017736760057fcde64c6904c3e916b13&#34;&gt;&lt;code&gt;#define&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ヘッダファイル内で定数を &lt;code&gt;#define&lt;/code&gt; してあることが多々あります。それらは地道に手書きでSML#側に持ってくることになりますが気になるのが互換性の問題。
特にOSのヘッダファイルには名前は同じだけどOS毎に値が異なるものが存在します。シグナルとか。OSで条件分岐するか理想的にはプリプロセッサのサポートがあればどうにかなりそうなんですけどねぇ。
現状だとCで定数を返すgetter関数を書いてSML#側でインポートして…ってやればどうにか出来そうですけどやりたくないですね。&lt;/p&gt;

&lt;h2 id=&#34;変数:017736760057fcde64c6904c3e916b13&#34;&gt;変数&lt;/h2&gt;

&lt;p&gt;私はまだ遭遇してないのですがライブラリによってはグローバル変数にアクセスしないといけないものが存在します。これもgetterとsetterを書いて…ってやるとどうにか出来そうですがどうせなら変数のインポートも出来ると良いですよね。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:017736760057fcde64c6904c3e916b13&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SML#でCのバインドを書く時は少しテクニックが必要&lt;/li&gt;
&lt;li&gt;SML#にはポインタを直接扱える関数もある&lt;/li&gt;
&lt;li&gt;それでも機能が足りない時はCでヘルパ関数を書こう。&lt;/li&gt;
&lt;li&gt;ダイナミックリンクライブラリも扱えるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SMLのファンクタに少し踏み込んだ</title>
      <link>http://keens.github.io/blog/2015/04/12/smlnofankutanisukoshifumikonda</link>
      <pubDate>Sun, 12 Apr 2015 19:49:41 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/12/smlnofankutanisukoshifumikonda</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;https://github.com/bleis-tift/SmlSharpContrib&#34;&gt;SmlSharpContrib&lt;/a&gt;にコントリビュートしてます。そこでファンクタを使う用事があったのですが少し踏み込んだ使い方をしようとしたらハマったのでメモ。&lt;/p&gt;

&lt;h1 id=&#34;ファンクタおさらい:921b7b3c7820999b28763bd2de5241d3&#34;&gt;ファンクタおさらい&lt;/h1&gt;

&lt;p&gt;SMLの&lt;code&gt;functor&lt;/code&gt;は&lt;code&gt;structure&lt;/code&gt;に引数がついたもので、モジュールを引数にとり、モジュールを返します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (Args : sig type elem end) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(struct type elem = int end)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;複雑なファンクタ:921b7b3c7820999b28763bd2de5241d3&#34;&gt;複雑なファンクタ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;blog/2015/01/31/mlyaccwotsukattemitehamattatokoro/&#34;&gt;以前mlyaccを使った時&lt;/a&gt;に&lt;code&gt;Join&lt;/code&gt;なる3つのモジュールを引数にとるファンクタが登場したのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの定義を覗いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数のモジュールの他に&lt;code&gt;sharing&lt;/code&gt;なるキーワードも出てきています。それに&lt;code&gt;structure&lt;/code&gt;キーワードもプリフィクスされています。&lt;/p&gt;

&lt;p&gt;先程の例とは大分離れてますね。何があったのでしょう。&lt;code&gt;structure&lt;/code&gt;を付けとけば複数書ける…？&lt;/p&gt;

&lt;h1 id=&#34;省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;省略記法&lt;/h1&gt;

&lt;p&gt;実はファンクタの引数の中では省略記法が使えます。引数のモジュール名と&lt;code&gt;sig ... end&lt;/code&gt;が省略可能なのです。さらに適用の時も&lt;code&gt;struct ... end&lt;/code&gt;も省略可能なのです。&lt;/p&gt;

&lt;p&gt;つまり、最初の例はこうも書けるのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (type elem) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(type elem = int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;モジュール内モジュールと省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;モジュール内モジュールと省略記法&lt;/h1&gt;

&lt;p&gt;そうです。複雑怪奇な&lt;code&gt;Join&lt;/code&gt;ファンクタは省略記法で書かれていたのでした。省略せずに書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(struct
     structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex
     end)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(X: sig
             structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token
             end)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。形式的には引数のモジュールは1つでありながら事実上複数のモジュールを渡していたのです。&lt;code&gt;structure&lt;/code&gt;が付いていたのはモジュール内モジュールだったから、&lt;code&gt;sharing&lt;/code&gt;はモジュール内モジュールに対する制約宣言です。&lt;/p&gt;

&lt;p&gt;なぜこれでハマったかというとSML#のインターフェースファイルでは省略記法が使えなかったからです。地雷の数だけ強くなれるよ♪&lt;/p&gt;

&lt;h1 id=&#34;参考:921b7b3c7820999b28763bd2de5241d3&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://walk.wgag.net/sml/module.html&#34;&gt;モジュール - ウォークスルー Standard ML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch11.S6.xhtml&#34;&gt;ファンクタのサポート in Ch.11. SML#分割コンパイルシステム in プログラミング言語SML#解説&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>mlyaccを使ってみてハマったところ</title>
      <link>http://keens.github.io/blog/2015/01/31/mlyaccwotsukattemitehamattatokoro</link>
      <pubDate>Sat, 31 Jan 2015 11:55:51 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/01/31/mlyaccwotsukattemitehamattatokoro</guid>
      <description>

&lt;p&gt;κeenです。前回の&lt;a href=&#34;http://keens.github.io/blog/2014/12/10/mllexwoshi-tutemiru/&#34;&gt;mllexの記事&lt;/a&gt;の続きです。今回はmlyaccを使ってみました。&lt;/p&gt;

&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;前回はprologをパースするためにこのようなmllexのコードを書いたのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;datatype lexresult =
         Comment of string
       | LeftParen
       | RightParen
       | LeftBracket
       | RightBracket
       | Comma
       | Dot
       | Bar
       | Medaka
       | UnderScore
       | String of string
       | Number of int
       | Variable of string
       | EOF

val linenum = ref 1
val error = fn x =&amp;gt; print (x ^ &amp;quot;\n&amp;quot;)
val eof = fn () =&amp;gt; EOF
%%
%structure PrologLex                      

alphanum = [A-Za-z0-9];
alpha    = [A-Za-z];
digit    = [0-9];
ws       = [\ \t\n];

%%

{ws}+            =&amp;gt; (lex());
%(.*)\n          =&amp;gt; (Comment yytext);
&amp;quot;(&amp;quot;              =&amp;gt; (LeftParen);
&amp;quot;)&amp;quot;              =&amp;gt; (RightParen);
&amp;quot;[&amp;quot;              =&amp;gt; (LeftBracket);
&amp;quot;]&amp;quot;              =&amp;gt; (RightBracket);
&amp;quot;,&amp;quot;              =&amp;gt; (Comma);
&amp;quot;.&amp;quot;              =&amp;gt; (Dot);
&amp;quot;|&amp;quot;              =&amp;gt; (Bar);
&amp;quot;:-&amp;quot;             =&amp;gt; (Medaka);
&amp;quot;_&amp;quot;              =&amp;gt; (UnderScore);
[a-z]{alphanum}* =&amp;gt; (String yytext);
{digit}+         =&amp;gt; (Number (foldl (fn(a, r)=&amp;gt; (ord(a)-ord(#&amp;quot;0&amp;quot;)) + 10*r) 0 (explode yytext)));
[A-Z]{alphanum}* =&amp;gt; (Variable yytext);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでトークナイズしたトークンをパースすることを考えます。結果はAST作るのが面倒なので文字列にします。&lt;/p&gt;

&lt;p&gt;とりあえずコードを晒してから解説します。prologの仕様を読まずに書いたので用語や文法は誤りを含みます。今度直すので今回はこれで勘弁して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
%%
%name PrologParser
%pos int

%term  Comment of string | LeftParen | RightParen | LeftBracket | RightBracket | Comma | Dot | Bar | Medaka | UnderScore | Number of int | String of string | Variable of string | EOF

%nonterm EXP of string | LIST of string | LISTEXPS of string | TOPDEFINITION of string | SUBDEFINITIONS of string | DEFINITION of string | ARG of string | NAME of string | STMT of string | ATOM of string | START of string

%left Comma
%right Bar
%eop EOF
%noshift EOF
%nodefault

%%

START : STMT (STMT)

STMT           : Comment STMT       (Comment ^ &amp;quot;\n&amp;quot; ^ STMT)
               | TOPDEFINITION STMT (TOPDEFINITION ^ &amp;quot;\n&amp;quot; ^ STMT)
               | (&amp;quot;&amp;quot;)

TOPDEFINITION  : DEFINITION Dot                       (DEFINITION ^ &amp;quot;.&amp;quot;)
               | DEFINITION Medaka SUBDEFINITIONS Dot (DEFINITION ^ &amp;quot;:-\n&amp;quot; ^ SUBDEFINITIONS ^ &amp;quot;.&amp;quot;)

SUBDEFINITIONS : DEFINITION Comma SUBDEFINITIONS      (DEFINITION ^ &amp;quot;,\n&amp;quot; ^SUBDEFINITIONS)
               | DEFINITION                           (&amp;quot;  &amp;quot; ^ DEFINITION)

DEFINITION     : NAME ARG (NAME ^ ARG)

NAME           : String     (String)

               
ARG            : LeftParen EXP RightParen (&amp;quot;(&amp;quot; ^ EXP ^ &amp;quot;)&amp;quot;)
               
               
EXP            : EXP Comma EXP  (EXP1 ^ &amp;quot;, &amp;quot; ^ EXP2)
               | LIST           (LIST)
               | ATOM           (ATOM)

LIST           : LeftBracket LISTEXPS RightBracket ( &amp;quot;[&amp;quot; ^ LISTEXPS ^ &amp;quot;]&amp;quot;)

LISTEXPS       : ATOM Bar LISTEXPS (ATOM ^ &amp;quot; | &amp;quot; ^ LISTEXPS)
               | ATOM (ATOM)

ATOM           : UnderScore               (&amp;quot;_&amp;quot;)
               | Number                   (Int.toString Number)
               | String                   (String)
               | Variable                 (Variable)
               | LeftBracket RightBracket (&amp;quot;[]&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全体はやはり&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;補助コード
%%
補助ルール
%%
パースルール
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;/p&gt;

&lt;p&gt;トークンに切り出す部分がないので補助コードはあまり書く必要はないようです。ASTを組み立てる時に必要なことがあるのかな？&lt;/p&gt;

&lt;p&gt;補助ルールは、主なものは終端記号(term)と非終端記号(nonterm)の記述です。パーサに馴染のない人には聞き慣れない言葉かもしれませんが、ASTの葉が終端記号で、節が非終端記号です。あとはパースの終わりの記号にeop、パースの区切にnonshiftを指定しましょう。パースの区切はEOFの他にREPLならNewlineなども候補かもしれません。posの型も必須です。leftやrightは中置演算子があればそれの結合の左右を指定します。複数書くと後の方が優先順位が高くなるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%left Add Sub
%left Mul Div
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように。&lt;/p&gt;

&lt;p&gt;パースルールは見て察して下さい。&lt;/p&gt;

&lt;p&gt;これをprolog.yaccなどと名前をつけて(.grmがよく使われるそうですが。)、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mlyacc prolog.yacc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするとprolog.yacc.smlとprolog.yacc.sigが出来ます。&lt;/p&gt;

&lt;p&gt;追記:
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; あと拡張子ですが、compilation managerは.grmをmlyaccのファイルと認識してくれるはずなので手間が少なそうです。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/561515838461583361&#34;&gt;2015, 1月 31&lt;/a&gt;&lt;/blockquote&gt;
大人しく.grmを使いましょう。&lt;/p&gt;

&lt;p&gt;シグネチャは.sigが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;signature PrologParser_TOKENS =
  sig
    type (&#39;a,&#39;b) token
    type svalue
    val EOF : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Variable : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val String : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Number : int * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val UnderScore : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Medaka : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Bar : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Dot : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Comma : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val RightBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val LeftBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val RightParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val LeftParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Comment : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
  end
signature PrologParser_LRVALS =
  sig
    structure Tokens :
      sig
        type (&#39;a,&#39;b) token
        type svalue
        val EOF : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Variable : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val String : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Number : int * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val UnderScore : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Medaka : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Bar : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Dot : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Comma : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val RightBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val LeftBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val RightParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val LeftParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Comment : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
      end
    structure ParserData :
      sig
        type pos
        type svalue
        type arg
        type result
        structure LrTable : &amp;lt;sig&amp;gt;
        structure Token : &amp;lt;sig&amp;gt;
        structure Actions : &amp;lt;sig&amp;gt;
        structure EC : &amp;lt;sig&amp;gt;
        val table : LrTable.table
        sharing LrTable = Token.LrTable
      end
    sharing type Tokens.svalue = ParserData.svalue
    sharing type Tokens.token = ParserData.Token.token
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、.smlが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor PrologParserLrValsFun(&amp;lt;param&amp;gt;: sig
                                         structure Token : &amp;lt;sig&amp;gt;
                                       end) :
                             sig
                               structure ParserData : &amp;lt;sig&amp;gt;
                               structure Tokens : &amp;lt;sig&amp;gt;
                             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;な感じです。&lt;/p&gt;

&lt;h1 id=&#34;問題点:3f0801502eddac3f0da04697fabc5835&#34;&gt;問題点&lt;/h1&gt;

&lt;p&gt;これ、以前のlexのコードと組み合わせても動きません。パーサはレキサが吐いたトークン列をパースするのでレキサとパーサで同じdatatypeを共有している必要があります。パーサはtermの指定からTokensを自動で生成してしまうのでレキサの方を修正する必要があります。&lt;/p&gt;

&lt;p&gt;こうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;structure Tokens = Tokens

type pos = int
type svalue = Tokens.svalue
type (&#39;a, &#39;b) token = (&#39;a, &#39;b) Tokens.token
type lexresult = (svalue,pos) token
(* datatype lexresult = *)
(*          Comment of string *)
(*        | LeftParen *)
(*        | RightParen *)
(*        | LeftBracket *)
(*        | RightBracket *)
(*        | Comma *)
(*        | Dot *)
(*        | Bar *)
(*        | Medaka *)
(*        | UnderScore *)
(*        | Number of int *)
(*        | String of string *)
(*        | Variable of string *)
(*        | EOF *)
val pos = ref 0
val linenum = ref 1
val error = fn x =&amp;gt; print (x ^ &amp;quot;\n&amp;quot;)
val eof = fn () =&amp;gt; Tokens.EOF(!pos, !pos)

%%
%header (functor PrologLexFun(structure Tokens: PrologParser_TOKENS));

alphanum = [A-Za-z0-9];
alpha    = [A-Za-z];
digit    = [0-9];
ws       = [\ \t\n];

%%

{ws}+            =&amp;gt; (lex());
%(.*)\n          =&amp;gt; (Tokens.Comment(yytext, !pos, !pos));
&amp;quot;(&amp;quot;              =&amp;gt; (Tokens.LeftParen(!pos, !pos));
&amp;quot;)&amp;quot;              =&amp;gt; (Tokens.RightParen(!pos, !pos));
&amp;quot;[&amp;quot;              =&amp;gt; (Tokens.LeftBracket(!pos, !pos));
&amp;quot;]&amp;quot;              =&amp;gt; (Tokens.RightBracket(!pos, !pos));
&amp;quot;,&amp;quot;              =&amp;gt; (Tokens.Comma(!pos, !pos));
&amp;quot;.&amp;quot;              =&amp;gt; (Tokens.Dot(!pos, !pos));
&amp;quot;|&amp;quot;              =&amp;gt; (Tokens.Bar(!pos, !pos));
&amp;quot;:-&amp;quot;             =&amp;gt; (Tokens.Medaka(!pos, !pos));
&amp;quot;_&amp;quot;              =&amp;gt; (Tokens.UnderScore(!pos, !pos));
[a-z]{alphanum}* =&amp;gt; (Tokens.String(yytext, !pos, !pos));
{digit}+         =&amp;gt; (Tokens.Number ((foldl (fn(a, r)=&amp;gt; (ord(a)-ord(#&amp;quot;0&amp;quot;)) + 10*r) 0 (explode yytext)), !pos, !pos));
[A-Z]{alphanum}* =&amp;gt; (Tokens.Variable(yytext, !pos, !pos));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モジュールではなくてファンクタを生成するようになります。シグネチャはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor PrologLexFun(&amp;lt;param&amp;gt;: sig
                                structure Tokens : &amp;lt;sig&amp;gt;
                              end) :
                    sig
                      structure UserDeclarations : &amp;lt;sig&amp;gt;
                      exception LexError
                      structure Internal : &amp;lt;sig&amp;gt;
                      structure YYPosInt : &amp;lt;sig&amp;gt;
                      val makeLexer : (int -&amp;gt; string)
                                      -&amp;gt; unit -&amp;gt; Internal.result
                    end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;組み合わせる:3f0801502eddac3f0da04697fabc5835&#34;&gt;組み合わせる&lt;/h1&gt;

&lt;p&gt;まず、必要なモジュールやシグネチャをmlyaccから読み込みます。前回同様mltonのmlyaccを使って、SML/NJで動作確認を行ないました。&lt;/p&gt;

&lt;p&gt;私は分かってないのですが、useってもしかしてSML/NJの固有の機能なんですかね。&lt;/p&gt;

&lt;p&gt;追記:
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;useはThe Standard ML Basis Libraryに記載があるのでSML/NJ固有の機能ではないですが、implementation dependentと書いてあるのでまぁそういう事なんでしょう&lt;/p&gt;&amp;mdash; ろんだ (@fetburner) &lt;a href=&#34;https://twitter.com/fetburner/status/561514796734877698&#34;&gt;2015, 1月 31&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; useは標準ですが意味は実装依存ですね&amp;gt; &lt;a href=&#34;http://t.co/fPC38xtD1X&#34;&gt;http://t.co/fPC38xtD1X&lt;/a&gt; (例外の直後辺り)&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/561515332469137408&#34;&gt;2015, 1月 31&lt;/a&gt;&lt;/blockquote&gt;
とのことなので処理系依存の機能ではなかった模様。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/base.sig&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/join.sml&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/lrtable.sml&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/stream.sml&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/parser2.sml&amp;quot;;
use &amp;quot;prolog.yacc.sig&amp;quot;;
use &amp;quot;prolog.yacc.sml&amp;quot;;
use &amp;quot;prolog.lex.sml&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mlyacc-libの場所は各自異なるので適宜書き換えて下さい。SML/NJはインストール場所を表わすシンボルを持っているようですが、私はmltonのものを参照しているのでいずれにせよ関係ないですね。&lt;/p&gt;

&lt;p&gt;さて、この.yacc.smlに入ってるファンクタです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor PrologParserLrValsFun(&amp;lt;param&amp;gt;: sig
                                         structure Token : &amp;lt;sig&amp;gt;
                                       end) :
                             sig
                               structure ParserData : &amp;lt;sig&amp;gt;
                               structure Tokens : &amp;lt;sig&amp;gt;
                             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故こうなってるのかは分からないのですがTokenを欲しがってますね。あげましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParserLrVals =
PrologParserLrValsFun(structure Token = LrParser.Token)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LrValsって言ってるのでLRパーサーで使うデータ型が用意出来たのかな？&lt;/p&gt;

&lt;p&gt;これでレキサで使うTokensとパーサで使うParserDataを持つモジュールが出来たのでレキサのファンクタの餌が用意出来ました。食べさせてあげましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologLex =
PrologLexFun(structure Tokens = PrologParserLrVals.Tokens)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは普通にレキサを生成します。&lt;/p&gt;

&lt;p&gt;んで最後にLRパーサとLRパーサで使うデータ型(?)とLRパーサに渡すトークンを生成するレキサを組み合わせます。なんかsharingなる機能を使って組み合わせるらしいのでそれ専用のファンクタが用意されています。sharingなんぞ。いつか&lt;a href=&#34;https://github.com/SMLFamily/The-Definition-of-Standard-ML-Revised&#34;&gt;The Definition of Standard ML Revised&lt;/a&gt;読まねば。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やっぱり&lt;code&gt;LrParser&lt;/code&gt;を使ってるのが腑に落ちませんね。どうして生成した時点で含んでないのかな。複数のパーサを作ったときに無駄を無くすため？自前のパーサが使えるようにするため？&lt;code&gt;LrParser.Token&lt;/code&gt;はまだパーサとsharingしてる必要がありそうなので納得出来ますが。&lt;/p&gt;

&lt;h1 id=&#34;使ってみる:3f0801502eddac3f0da04697fabc5835&#34;&gt;使ってみる&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;makeLexer&lt;/code&gt;と&lt;code&gt;parse&lt;/code&gt;を使うようです。&lt;code&gt;makeLexer&lt;/code&gt;は呼ぶ度にトークンを返すものではなく、トークンのストリームを返すものになってるらしいです。&lt;/p&gt;

&lt;p&gt;prologファイル名を受け取ってその中身をパースして、中身を整形した文字列にするコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun invoke lexstream =
    let
        fun print_error (s, _, _) =
            TextIO.output(TextIO.stdOut,
                          &amp;quot;Error: &amp;quot; ^ s ^ &amp;quot;\n&amp;quot;)
    in
        PrologParser.parse(0, lexstream, print_error, ())
    end

fun parse filename =
    let
        val f = TextIO.openIn filename
        val lexer = PrologParser.makeLexer
                        (fn i =&amp;gt; TextIO.inputN(f, i))
        fun run lexer =
            let
                val (result,lexer) = invoke lexer
            in
                TextIO.output(TextIO.stdOut,
                              &amp;quot;result = &amp;quot; ^ result ^ &amp;quot;\n&amp;quot;)
            end
    in
        run lexer
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回はposのアップデートをサボったので&lt;code&gt;print_error&lt;/code&gt;内では無視してますが本来は&lt;code&gt;print_error&lt;/code&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;print_error (s, start:int, end:int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として受けるべきです。この時startとendはトークンの開始位置と終了位置です。&lt;/p&gt;

&lt;p&gt;他にも説明が足りてない部分がありますが、マニュアルや&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/education/lectures/compiler/code/mlyaccKaisetsu.pdf&#34;&gt;東北大のPDF&lt;/a&gt;を参照して下さい。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:3f0801502eddac3f0da04697fabc5835&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;mlyaccの使い方を書いた&lt;/li&gt;
&lt;li&gt;mllexとmlyaccの組み合わせ方を書いた&lt;/li&gt;
&lt;li&gt;疑問が残った&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次回はASTでも作ってみますが、smlsharpにSMLFormatなるdatatypeの定義とそのプリティプリンタの定義を同時に出来るツールがあるようなのでそれを使ってみます。いくつも中間表現を作ろうと思ったら途中経過も欲しいのでプリティプリンタ重要ですよね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mllexを使ってみる。あるいはlexユーザーに対するmllexの解説</title>
      <link>http://keens.github.io/blog/2014/12/10/mllexwoshi-tutemiru</link>
      <pubDate>Wed, 10 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/10/mllexwoshi-tutemiru</guid>
      <description>

&lt;p&gt;このエントリーは&lt;a href=&#34;http://qiita.com/advent-calendar/2014/ml&#34;&gt;ML Advent Calendar 10日目&lt;/a&gt;の記事です。&lt;br /&gt;
前 &lt;a href=&#34;http://h-sakurai.hatenablog.com/entry/2014/12/09/144655&#34;&gt;OCamlで作ったgoma言語 - h_sakurai&amp;rsquo;s diary&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ふと思い立ってPrologのコンパイラかインタプリタかを作ってみようとして、その第一段でlexerに着手しました。&lt;/p&gt;

&lt;p&gt;ちょ、SML分かる人はmllexくらい常識的に知ってるなんて言わないで下さい。私は初めて触りました。&lt;/p&gt;

&lt;p&gt;ちょっと変則的なんですが、smlsharpの配布物にあるドキュメントを読みながらmlton付属のmllexを使い、sml/nj上で動作を確認しました。SMLの処理系管理ガバガバですね。&lt;/p&gt;

&lt;p&gt;まあ、初めて使ってみたとは言ってもほぼC版のlexのCを書く部分をそのままSMLで書けば良いだけなので簡単ですね。&lt;/p&gt;

&lt;p&gt;因みにPrologの文法は以下のようなもの。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;%reverse a list into X
reverse([], []).

reverse([Hd|Tl], X):-
    reverse(Tl, Y),
    append(Y, [Hd], X).

reverse(List, X):-
    reverse(List, []).

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;だいたいの部分は見れば分かるかと思うのですが、小文字で始まるのがリテラル（文字列？識別子？）で大文字から始まるのが変数です。&lt;/p&gt;

&lt;p&gt;で、これをイメージしながらlexファイルを書いていきます。&lt;/p&gt;

&lt;h1 id=&#34;lexファイル:f008816e5c3a570fa326aa9d961d331a&#34;&gt;Lexファイル&lt;/h1&gt;

&lt;p&gt;全体はこのようになっています。lexと同じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SMLの補助コード部分

%%

補助ルールの記述

%%

解析ルールの記述

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SMLの補助コードの部分は典型的には&lt;code&gt;datatype&lt;/code&gt;を書きます。あとはどうも&lt;code&gt;error : string -&amp;gt; unit&lt;/code&gt;と &lt;code&gt;eof : unit -&amp;gt; &#39;a&lt;/code&gt;が必要みたいですね（マニュアルちゃんと読んでない）。&lt;code&gt;&#39;a&lt;/code&gt;というのは他の解析ルールと同じ型です。&lt;/p&gt;

&lt;p&gt;補助ルールはlexとだいたい同じです。生成した関数やらデータ型を収めるstructureの指定とかもします。&lt;/p&gt;

&lt;p&gt;解析ルールもだいたいlexと同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pattern =&amp;gt; (SMLのコード);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような形をしてます。&lt;/p&gt;

&lt;h1 id=&#34;実際のコード:f008816e5c3a570fa326aa9d961d331a&#34;&gt;実際のコード&lt;/h1&gt;

&lt;p&gt;結構適当です。あ、カットのこと忘れてた。ほら、適当だった。&lt;/p&gt;

&lt;p&gt;このコードをprolog.lexとして保存します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype lexresult =
         Comment of string
       | LeftParen
       | RightParen
       | LeftBracket
       | RightBracket
       | Comma
       | Dot
       | Bar
       | Medaka
       | UnderScore
       | String of string
       | Number of int
       | Variable of string
       | EOF

val linenum = ref 1
val error = fn x =&amp;gt; print (x ^ &amp;quot;\n&amp;quot;)
val eof = fn () =&amp;gt; EOF
%%
%structure PrologLex                      

alphanum = [A-Za-z0-9];
alpha    = [A-Za-z];
digit    = [0-9];
ws       = [\ \t\n];

%%

{ws}+            =&amp;gt; (lex());
%(.*)\n          =&amp;gt; (Comment yytext);
&amp;quot;(&amp;quot;              =&amp;gt; (LeftParen);
&amp;quot;)&amp;quot;              =&amp;gt; (RightParen);
&amp;quot;[&amp;quot;              =&amp;gt; (LeftBracket);
&amp;quot;]&amp;quot;              =&amp;gt; (RightBracket);
&amp;quot;,&amp;quot;              =&amp;gt; (Comma);
&amp;quot;.&amp;quot;              =&amp;gt; (Dot);
&amp;quot;|&amp;quot;              =&amp;gt; (Bar);
&amp;quot;:-&amp;quot;             =&amp;gt; (Medaka);
&amp;quot;_&amp;quot;              =&amp;gt; (UnderScore);
[a-z]{alphanum}* =&amp;gt; (String yytext);
{digit}+         =&amp;gt; (Number (foldl (fn(a, r)=&amp;gt; (ord(a)-ord(#&amp;quot;0&amp;quot;)) + 10*r) 0 (explode yytext)));
[A-Z]{alphanum}* =&amp;gt; (Variable yytext);
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;実際に使ってみる:f008816e5c3a570fa326aa9d961d331a&#34;&gt;実際に使ってみる。&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ mllex prolog.lex

Number of states = 19
Number of distinct rows = 8
Approx. memory size of trans. table = 1032 bytes
$ rlwrap sml
Standard ML of New Jersey v110.77 [built: Thu Sep  4 12:32:33 2014]
- use &amp;quot;prolog.lex.sml&amp;quot;;
[opening prolog.lex.sml]
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[autoloading done]
structure PrologLex :
  sig
    structure UserDeclarations : &amp;lt;sig&amp;gt;
    exception LexError
    structure Internal : &amp;lt;sig&amp;gt;
    structure YYPosInt : &amp;lt;sig&amp;gt;
    val makeLexer : (int -&amp;gt; string) -&amp;gt; unit -&amp;gt; Internal.result
  end
val it = () : unit
- val lexer = PrologLex.makeLexer (fn i =&amp;gt; TextIO.inputN(TextIO.openIn &amp;quot;reverse.pl&amp;quot;, i));
val lexer = fn : unit -&amp;gt; PrologLex.Internal.result
- lexer();
val it = Comment &amp;quot;%reverse a list into X\n&amp;quot; : PrologLex.Internal.result
- lexer();
val it = String &amp;quot;reverse&amp;quot; : PrologLex.Internal.result
- lexer();
val it = LeftParen : PrologLex.Internal.result
- lexer();
val it = LeftBracket : PrologLex.Internal.result
- lexer();
val it = RightBracket : PrologLex.Internal.result
- 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コメントの扱い失敗してますね。この辺はどうしようもないのかなあ&lt;/p&gt;

&lt;h1 id=&#34;困ったところ:f008816e5c3a570fa326aa9d961d331a&#34;&gt;困ったところ&lt;/h1&gt;

&lt;p&gt;ドキュメントが古いSML/NJのものらしく、SMLのコードをそのまま書いても動かなかった。&lt;code&gt;revfold&lt;/code&gt;とか&lt;code&gt;inputc&lt;/code&gt;とか。&lt;/p&gt;

&lt;p&gt;次回はmlyaccでも触ってみますか。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>