<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小ネタ on κeenのHappy Hacκing Blog</title>
    <link>/categories/%E5%B0%8F%E3%83%8D%E3%82%BF/</link>
    <description>Recent content in 小ネタ on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 13 Dec 2015 17:14:18 +0900</lastBuildDate>
    <atom:link href="/categories/%E5%B0%8F%E3%83%8D%E3%82%BF/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rustでの日本語の扱い</title>
      <link>/blog/2015/12/13/rustdenonihongonoatsukai</link>
      <pubDate>Sun, 13 Dec 2015 17:14:18 +0900</pubDate>
      
      <guid>/blog/2015/12/13/rustdenonihongonoatsukai</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar&lt;/a&gt; 14日目の記事です&lt;br /&gt;
前:gifnksmさんの &lt;a href=&#34;http://gifnksm.hatenablog.jp/entry/2015/12/13/204655&#34;&gt;kcovを使ってRustプログラムのカバレッジを測定する - gifnksmの雑多なメモ&lt;/a&gt;&lt;br /&gt;
後:nacika_insさんのtimeこわい&lt;/p&gt;

&lt;p&gt;κeenです。当初の予定より小ネタになってしまいましたがRustでの日本語の扱いについて書こうかと。&lt;/p&gt;

&lt;p&gt;ご存じの通りRustはマルチバイト文字をサポートしていますが、その殆どがUTF-8だけです。しかし日本人にはUTF-8だけでは少し辛いものがありますのでどうにかして対応しようかと。&lt;/p&gt;

&lt;p&gt;ソースコード中でもマルチバイト文字を扱えますが、UTF-8である必要があります。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rs&#34;&gt;fn main() {
  println!(&amp;quot;あああ&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをISO-2022-JPで保存してrustcに食わせても、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error: couldn&#39;t read &amp;quot;src/main.rs&amp;quot;: stream did not contain valid UTF-8
Could not compile `japanese`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と無下もないエラーが出てしまいます。&lt;/p&gt;

&lt;p&gt;内部エンコーディングにもUTF-8が使われているのでRustの文字列をUTF-8以外で出力するにはなんとなく変換が必要そうなのは理解出来ますが、変に出入力をラップしてる関数を使うとまた意図せぬエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;

fn main() {
  let file = File::open(&amp;quot;japanese.txt&amp;quot;);
  let br = BufReader::new(&amp;amp;file);
  for line in br.lines() {
    matich line {
      Ok(l) =&amp;gt; println!(&amp;quot;Ok: {}&amp;quot;, l),
      Err(e) =&amp;gt; println!(&amp;quot;{:?}&amp;quot;, e)
    };
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもまた、&lt;code&gt;stream did not contain valid UTF-8&lt;/code&gt;エラーを出します。&lt;/p&gt;

&lt;p&gt;ReadもBufReadもbyte orientedって言ってるのに何故か文字列を扱えるのが若干気になりますがまあ、そういうもんなんでしょう。&lt;/p&gt;

&lt;h1 id=&#34;encoding&#34;&gt;encoding&lt;/h1&gt;

&lt;p&gt;そこで救世主となるライブラリが&lt;a href=&#34;https://github.com/lifthrasiir/rust-encoding&#34;&gt;lifthrasiir/rust-encoding&lt;/a&gt;です。文字列のエンコーディングをサポートします。
READMEに詳しい使い方が載っているのですが、このライブラリは与えられたスライスに対して指定されたエンコーディングでエンコード/デコードします。&lt;/p&gt;

&lt;p&gt;なので先の例のようにISO-2022-JPで&lt;code&gt;&amp;quot;あああ&amp;quot;&lt;/code&gt;と出力したいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use encoding::{Encoding, EncoderTrap};
use encoding::all::ISO_2022_JP;
use std::io::Stdout;

fn main() {
  let bytes = ISO_2022_JP.encode(&amp;quot;あああ&amp;quot;, EncoderTrap::Ignore);
  Stdout.write_all(&amp;amp;bytes[..]);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出来るでしょう。(即興で書いてコンパイルすらしてないので本当に出来るかは分かりませんが)&lt;/p&gt;

&lt;p&gt;読み取りに関しては…………。そう、このライブラリはバッファに対してしか動作せず、ストリームに使えないのです。提供してくれたら良さそうなのですが、作者の方が忙しいようです。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; stream encoding/decodingは計画してはいるのですが、私が忙しくてなかなか作業をすることができません&amp;hellip; orz&lt;/p&gt;&amp;mdash; Kang Seonghoon (@senokay) &lt;a href=&#34;https://twitter.com/senokay/status/666516796942319616&#34;&gt;2015, 11月 17&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;余談ですがこの方は韓国の方のようですが、日本語もある程度分かるそうです。すごいですね。&lt;/p&gt;

&lt;p&gt;さて、ストリームに対して使えないと分かったなら自分で対応するまで。幸いにも我々が使っているのはRustです。新しいものを既存の仕組みに載せるのは造作もありません。
ストリームを良い感じにデコードするには&lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Read.html&#34;&gt;std::io::Read&lt;/a&gt;を実装した何かを作れば十分です。作っていきましょう。&lt;code&gt;Read&lt;/code&gt;トレイトを実装するには最低&lt;code&gt;read&lt;/code&gt;だけ実装してしまえば十分です。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;read&lt;/code&gt;ですが、ドキュメントを読むと中々制限が緩いようです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pull some bytes from this source into the specified buffer, returning how many bytes were read.&lt;/p&gt;

&lt;p&gt;This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an Err return value.&lt;/p&gt;

&lt;p&gt;If the return value of this method is Ok(n), then it must be guaranteed that 0 &amp;lt;= n &amp;lt;= buf.len(). A nonzero n value indicates that the buffer buf has been filled in with n bytes of data from this source. If n is 0, then it can indicate one of two scenarios:&lt;/p&gt;

&lt;p&gt;This reader has reached its &amp;ldquo;end of file&amp;rdquo; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will always no longer be able to produce bytes.
   The buffer specified was 0 bytes in length.&lt;/p&gt;

&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true. It is recommended that implementations only write data to buf instead of reading its contents.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「関数が呼ばれる際に&lt;code&gt;buf&lt;/code&gt;に対しては何如なる保証もなく、呼出側はバッファの内容に対して何如なる不変条件も期待してはいけません」とあります。つまり、4096 byteのバッファが与えられても1呼び出しにつき1バイトしか返さないような実装でも許容されます。
また、非同期ベースのIOのようにキャッシュにデータがなければIOブロッキングせずにエラーだとかの挙動もありえます。非常にシステムプログラミング言語らしい仕様ですね。&lt;/p&gt;

&lt;p&gt;今から作ろうとしているデコーディングストリームも読み出したバイト列がデコード後に何バイトになるのか予測がつかないのでこの仕様は有難いですね。&lt;/p&gt;

&lt;p&gt;さて、作っていきましょうか。まずは必要そうなライブラリを読み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use self::encoding::{EncodingRef, DecoderTrap};
use std::io::Read;
use std::io;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてメインとなる構造体です。とある&lt;code&gt;Read&lt;/code&gt;を実装した型をラップする形にしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct DecodingReader&amp;lt;R&amp;gt; {
    inner: R,
    encoding: EncodingRef,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;はトレイトなので&lt;code&gt;inner&lt;/code&gt;のところを&lt;code&gt;&amp;amp;R&lt;/code&gt;としなくて大丈夫です。&lt;code&gt;Read&lt;/code&gt;の実装側が調整します。&lt;/p&gt;

&lt;p&gt;そしてコンストラクタですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; DecodingReader&amp;lt;R&amp;gt; {
    pub fn new(coding: EncodingRef, read: R)-&amp;gt; Self {
        EncodingReader {
            inner: read,
            encoding: coding
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのままですね。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;の実装です。まずは&lt;code&gt;inner&lt;/code&gt;の&lt;code&gt;read&lt;/code&gt;を呼んで、その結果を一旦デコードしてからまたバイト列に変換します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; Read for DecodingReader&amp;lt;R&amp;gt; {
    fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;usize&amp;gt;{
        // TODO set appropriate buffer size
        let len = buf.len() / 2;
        let n = try!(self.inner.read(&amp;amp;mut buf[..len]));
        // TODO don&#39;t ignore input code
        let str = self.encoding.decode(&amp;amp;mut buf[..n], DecoderTrap::Ignore).unwrap();
        let mut i = 0;
        for (d, s) in buf.iter_mut().zip(str.bytes()) {
            *d = s;
            i+=1;
            if i == 0 {
                break
            };
        }
        assert!(i &amp;lt;= buf.len());
        Ok(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程も言った通りデコード読み込んだバイト列をUTF-8にした時にどれくらいバイト数が変わるか分からないので山勘で2倍くらいに膨らむだろうとして与えられたバッファ長の半分を使います。
ここはもう少し調整が必要ですね。エンコーディング毎に適切なバッファ長を設定したい…&lt;/p&gt;

&lt;p&gt;バッファを確保出来たら&lt;code&gt;let n = try!(self.inner.read(&amp;amp;mut buf[..len]));&lt;/code&gt;してそれっぽいサイズ読み込んで、読み込んだサイズをデコードにかけます。&lt;/p&gt;

&lt;p&gt;現在&lt;code&gt;DecoderTrap&lt;/code&gt;を&lt;code&gt;Ignore&lt;/code&gt;にして&lt;code&gt;unwrap&lt;/code&gt;してますが、これは少し雑すぎますね。例えば入力が全てvalidな文字を含んでいたとしても&lt;code&gt;read&lt;/code&gt;が多バイト文字の真ん中までしか読まなかった時にそれが無効なエンコーディングと判定されて無視されるのでユーザからしたら「合ってる筈なのに何故か1文字欠損するバグ」として現れます。今回即席で作ったので勘弁して下さい。&lt;/p&gt;

&lt;p&gt;変換は文字列にしか出来ないようなので一旦文字列に落してからまたバイト列として取り出し、バッファに書き出します。デコード後のバイト列が&lt;code&gt;read&lt;/code&gt;したバイト列より小さかったら一部&lt;code&gt;read&lt;/code&gt;したデータが残ってしまいそうですが、「何如なる不変条件も…」とあるので問題ないでしょう。返り値にデコード後のバイト列の長さを返していれば良い筈です。&lt;/p&gt;

&lt;p&gt;さて、エンコードのエラーハンドリングしてないだとか本当に読み込みのバッファ長が適切なのかとかの疑問はあるものの、一応ストリームのデコーダが出来ました。使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
extern crate japanese;

use encoding::{Encoding, DecoderTrap};
use encoding::all::ISO_2022_JP;

use std::fs::File;
use std::io::BufReader;
use std::io::BufRead;
use std::str::from_utf8;
use japanese::buf::DecodingReader;


fn main() {
    let file = File::open(&amp;quot;src/japanese.txt&amp;quot;).unwrap();
    let e = DecodingReader::new(ISO_2022_JP, &amp;amp;file);
    let mut br = BufReader::new(e);
    for line in br.lines() {
        println!(&amp;quot;{}&amp;quot;, line.unwrap());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでちゃんとISO-2022-JPのファイルを読めます。&lt;/p&gt;

&lt;p&gt;Javaに慣れてる人ならこういうIOに対するデコレータパターンは見覚えがあるでしょう。&lt;/p&gt;

&lt;p&gt;今更ですがiso-2022-jpはいわゆるjisエンコーディングです。rust-encodingはshift_jisの拡張にあたるwindows31jだとかeuc-jpも扱えます(&lt;a href=&#34;https://lifthrasiir.github.io/rust-encoding/encoding/codec/japanese/index.html&#34;&gt;参考&lt;/a&gt;)。&lt;/p&gt;

&lt;h1 id=&#34;今後&#34;&gt;今後&lt;/h1&gt;

&lt;p&gt;ライブラリとして公開するか、あるいは作者の方がやる気はあるようなのでプルリクを送るかが終着点かな、と思っていますが如何せん雑にしか実装してないので微妙ですね。
例の境界とマルチバイトの問題は&lt;code&gt;Read&lt;/code&gt;じゃなく&lt;code&gt;BufRead&lt;/code&gt;を要求して1文字分読み切るまで来るまで1バイトずつ読むとかになると思います。ダルい。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Rust標準だけでUTF-8以外の文字列を使うのはつらいよ&lt;/li&gt;
&lt;li&gt;Rustのエンコーディングライブラリを紹介したよ&lt;/li&gt;
&lt;li&gt;エンコーディングライブラリを使ってストリームデコーダを実装してみたよ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/japanese&#34;&gt;こちら&lt;/a&gt;にあります&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cargoの使い方</title>
      <link>/blog/2015/11/29/cargonotsukaikata</link>
      <pubDate>Sun, 29 Nov 2015 23:25:54 +0900</pubDate>
      
      <guid>/blog/2015/11/29/cargonotsukaikata</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 3日目の記事です。&lt;br /&gt;
前 &lt;a href=&#34;/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_/&#34;&gt;Rustで小さなツールを作ってみる(後編)&lt;/a&gt;&lt;br /&gt;
次  szkttyさん インデックス構文によるアクセスを実装する&lt;/p&gt;

&lt;p&gt;κeenです。Rustを使うにはCargoを使う必要がありますが、&lt;code&gt;cargo help&lt;/code&gt;を見てもあまり情報が載っていないので少しばかり書きましょう。&lt;/p&gt;

&lt;h1 id=&#34;new&#34;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Create a new cargo package at &amp;lt;path&amp;gt;

Usage:
    cargo new [options] &amp;lt;path&amp;gt;
    cargo new -h | --help

Options:
    -h, --help          Print this message
    --vcs VCS           Initialize a new repository for the given version
                        control system (git or hg) or do not initialize any version
                        control at all (none) overriding a global configuration.
    --bin               Use a binary instead of a library template
    --name NAME         Set the resulting package name
    -v, --verbose       Use verbose output
    -q, --quiet         No output printed to stdout
    --color WHEN        Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはみなさんよく使うのでほとんど説明不要でしょう。&lt;code&gt;cargo new&lt;/code&gt;または&lt;code&gt;cargo new --bin&lt;/code&gt;の形でよく使います。
オプションを見て分かる通り、&lt;code&gt;cargo new foo-rs --name foo&lt;/code&gt;のようにパスとcrateの名前を変えたりデフォルトのvcsにmercurialを使うことも出来ます。&lt;/p&gt;

&lt;h1 id=&#34;build&#34;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Compile a local package and all of its dependencies

Usage:
    cargo build [options]

Options:
    -h, --help               Print this message
    -p SPEC, --package SPEC  Package to build
    -j N, --jobs N           The number of jobs to run in parallel
    --lib                    Build only this package&#39;s library
    --bin NAME               Build only the specified binary
    --example NAME           Build only the specified example
    --test NAME              Build only the specified test target
    --bench NAME             Build only the specified benchmark target
    --release                Build artifacts in release mode, with optimizations
    --features FEATURES      Space-separated list of features to also build
    --no-default-features    Do not build the `default` feature
    --target TRIPLE          Build for the target triple
    --manifest-path PATH     Path to the manifest to compile
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never

If the --package argument is given, then SPEC is a package id specification
which indicates which package should be built. If it is not given, then the
current package is built. For more information on SPEC and its format, see the
`cargo help pkgid` command.

Compilation can be configured via the use of profiles which are configured in
the manifest. The default profile for this command is `dev`, but passing
the --release flag will use the `release` profile instead.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恐らく一番よく使うタスクですね。ビルド対象を色々指定できるのはいいとして、実は&lt;code&gt;-j&lt;/code&gt;オプションがあります。並行ビルド出来るやつですね。体感速度は変わりませんが。&lt;/p&gt;

&lt;h1 id=&#34;run&#34;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Run the main binary of the local package (src/main.rs)

Usage:
    cargo run [options] [--] [&amp;lt;args&amp;gt;...]

Options:
    -h, --help              Print this message
    --bin NAME              Name of the bin target to run
    --example NAME          Name of the example target to run
    -j N, --jobs N          The number of jobs to run in parallel
    --release               Build artifacts in release mode, with optimizations
    --features FEATURES     Space-separated list of features to also build
    --no-default-features   Do not build the `default` feature
    --target TRIPLE         Build for the target triple
    --manifest-path PATH    Path to the manifest to execute
    -v, --verbose           Use verbose output
    -q, --quiet             No output printed to stdout
    --color WHEN            Coloring: auto, always, never

If neither `--bin` nor `--example` are given, then if the project only has one
bin target it will be run. Otherwise `--bin` specifies the bin target to run,
and `--example` specifies the example target to run. At most one of `--bin` or
`--example` can be provided.

All of the trailing arguments are passed to the binary to run. If you&#39;re passing
arguments to both Cargo and the binary, the ones after `--` go to the binary,
the ones before go to Cargo.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行可能ファイルのプロジェクトだった時に成果物を走らせます。あるいはexampleも走らせられます。とはいってもまだビルドしてなかったらビルドもするのでビルド向けのオプションがいっぱいありますね。&lt;/p&gt;

&lt;p&gt;実行可能ファイルが複数あるなら&lt;code&gt;cargo run --bin xxx&lt;/code&gt;で指定して走らせます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--release&lt;/code&gt;ビルドした成果物を走らせたかったら&lt;code&gt;cargo run --release&lt;/code&gt;しないといけません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cargo run -- args&lt;/code&gt;で成果物に引数を渡せます。&lt;/p&gt;

&lt;h1 id=&#34;test&#34;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Execute all unit and integration tests of a local package

Usage:
    cargo test [options] [--] [&amp;lt;args&amp;gt;...]

Options:
    -h, --help               Print this message
    --lib                    Test only this package&#39;s library
    --bin NAME               Test only the specified binary
    --example NAME           Test only the specified example
    --test NAME              Test only the specified integration test target
    --bench NAME             Test only the specified benchmark target
    --no-run                 Compile, but don&#39;t run tests
    -p SPEC, --package SPEC  Package to run tests for
    -j N, --jobs N           The number of jobs to run in parallel
    --release                Build artifacts in release mode, with optimizations
    --features FEATURES      Space-separated list of features to also build
    --no-default-features    Do not build the `default` feature
    --target TRIPLE          Build for the target triple
    --manifest-path PATH     Path to the manifest to build tests for
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never
    --no-fail-fast           Run all tests regardless of failure

All of the trailing arguments are passed to the test binaries generated for
filtering tests and generally providing options configuring how they run. For
example, this will run all tests with the name `foo` in their name:

    cargo test foo

If the --package argument is given, then SPEC is a package id specification
which indicates which package should be tested. If it is not given, then the
current package is tested. For more information on SPEC and its format, see the
`cargo help pkgid` command.

The --jobs argument affects the building of the test executable but does
not affect how many jobs are used when running the tests.

Compilation can be configured via the `test` profile in the manifest.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テスト走らせるやつです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cargo test&lt;/code&gt;とだけすると全てのテストが走ります。地味にrustdocの中に書いたexampleも走ります。&lt;/p&gt;

&lt;h1 id=&#34;search&#34;&gt;&lt;code&gt;search&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Search packages in crates.io

Usage:
    cargo search [options] &amp;lt;query&amp;gt;
    cargo search [-h | --help]

Options:
    -h, --help               Print this message
    --host HOST              Host of a registry to search in
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;crates.ioからパッケージを捜してきてくれます。よく使いますね。インデックスのアップデートが地味に重い。&lt;/p&gt;

&lt;h1 id=&#34;fetch&#34;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;だんだんニッチなタスクを紹介していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fetch dependencies of a package from the network.

Usage:
    cargo fetch [options]

Options:
    -h, --help               Print this message
    --manifest-path PATH     Path to the manifest to fetch dependencies for
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never

If a lockfile is available, this command will ensure that all of the git
dependencies and/or registries dependencies are downloaded and locally
available. The network is never touched after a `cargo fetch` unless
the lockfile changes.

If the lockfile is not available, then this is the equivalent of
`cargo generate-lockfile`. A lockfile is generated and dependencies are also
all updated.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dependenciesを全てローカルに持ってくるタスクです。&lt;/p&gt;

&lt;h1 id=&#34;generate-lockfile&#34;&gt;&lt;code&gt;generate_lockfile&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Generate the lockfile for a project

Usage:
    cargo generate-lockfile [options]

Options:
    -h, --help               Print this message
    --manifest-path PATH     Path to the manifest to generate a lockfile for
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cargo.lockの生成をします。&lt;code&gt;cargo update&lt;/code&gt;がロックファイルがないと怒ってくるのでそういう時に使うのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;package&#34;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Assemble the local package into a distributable tarball

Usage:
    cargo package [options]

Options:
    -h, --help              Print this message
    -l, --list              Print files included in a package without making one
    --no-verify             Don&#39;t verify the contents by building them
    --no-metadata           Ignore warnings about a lack of human-usable metadata
    --manifest-path PATH    Path to the manifest to compile
    -v, --verbose           Use verbose output
    -q, --quiet             No output printed to stdout
    --color WHEN            Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cargoにはcrates.ioにデプロイする機能もあります。他にも&lt;code&gt;publish&lt;/code&gt;, &lt;code&gt;login&lt;/code&gt;, &lt;code&gt;yank&lt;/code&gt;も見ておきましょう。&lt;/p&gt;

&lt;h1 id=&#34;install&#34;&gt;&lt;code&gt;install&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Install a Rust binary
Usage:
    cargo install [options] [&amp;lt;crate&amp;gt;]
    cargo install [options] --list
Specifying what crate to install:
    --vers VERS               Specify a version to install from crates.io
    --git URL                 Git URL to install the specified crate from
    --branch BRANCH           Branch to use when installing from git
    --tag TAG                 Tag to use when installing from git
    --rev SHA                 Specific commit to use when installing from git
    --path PATH               Filesystem path to local crate to install
Build and install options:
    -h, --help                Print this message
    -j N, --jobs N            The number of jobs to run in parallel
    --features FEATURES       Space-separated list of features to activate
    --no-default-features     Do not build the `default` feature
    --debug                   Build in debug mode instead of release mode
    --bin NAME                Only install the binary NAME
    --example EXAMPLE         Install the example EXAMPLE instead of binaries
    --root DIR                Directory to install packages into
    -v, --verbose             Use verbose output
    -q, --quiet               Less output printed to stdout
    --color WHEN              Coloring: auto, always, never
This command manages Cargo&#39;s local set of install binary crates. Only packages
which have [[bin]] targets can be installed, and all binaries are installed into
the installation root&#39;s `bin` folder. The installation root is determined, in
order of precedence, by `--root`, `$CARGO_INSTALL_ROOT`, the `install.root`
configuration key, and finally the home directory (which is either
`$CARGO_HOME` if set or `$HOME/.cargo` by default).
There are multiple sources from which a crate can be installed. The default
location is crates.io but the `--git` and `--path` flags can change this source.
If the source contains more than one package (such as crates.io or a git
repository with multiple crates) the `&amp;lt;crate&amp;gt;` argument is required to indicate
which crate should be installed.
Crates from crates.io can optionally specify the version they wish to install
via the `--vers` flags, and similarly packages from git repositories can
optionally specify the branch, tag, or revision that should be installed. If a
crate has multiple binaries, the `--bin` argument can selectively install only
one of them, and if you&#39;d rather install examples the `--example` argument can
be used as well.
The `--list` option will list all installed packages (and their versions).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだリリースチャネルには来てませんが、&lt;code&gt;install&lt;/code&gt;も入る予定です。binプロジェクトをソースを持ってきてそのままビルド、インストールまでするやつです。勿論、ローカルのものもインストール出来ますよ。
&lt;a href=&#34;https://github.com/rust-lang-nursery/rustfmt&#34;&gt;rustfmt&lt;/a&gt;のようにREADMEのインストール方法に&lt;code&gt;cargo install&lt;/code&gt;を書いているものもあります。これが使えるようになると配布がぐっと楽になりますね。&lt;/p&gt;

&lt;h1 id=&#34;プラグイン&#34;&gt;プラグイン&lt;/h1&gt;

&lt;p&gt;Cargoのサブコマンドを自分で作るのは簡単です。&lt;code&gt;cargo foo&lt;/code&gt;というタスクを作りたいのなら&lt;code&gt;cargo-foo&lt;/code&gt;という名前の実行可能ファイルをパスに置いておくだけです。&lt;/p&gt;

&lt;p&gt;試してみましょう&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF &amp;gt; ~/bin/cargo-foo
#!/bin/sh
echo args are: &amp;quot;\$@&amp;quot;
echo \\\$0 is: \$0
EOF
$ chmod +x  ~/bin/cargo-foo
$ cargo foo aa bb cc
args are: foo aa bb cc
$0 is: /home/kim/bin/cargo-foo
$ cargo help foo aa bb cc
args are: foo -h
$0 is: /home/kim/bin/cargo-foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと独特な引数の渡り方をしてますね。しかし予め了解しておけば特に問題はなさそうです。1つサブコマンドを作ってみましょう。&lt;/p&gt;

&lt;p&gt;指定した名前のパッケージをCargo.tomlのdependenciesに書き足してくれるサブコマンドです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
usage(){
    cat &amp;lt;&amp;lt;EOF
Add the dependency of crate to Cargo.toml

Usage:
    cargo use &amp;lt;crate&amp;gt; [version]
    cargo use -h | --help

Description:
    Add the dependency of crate to Cargo.toml.
    If vension is omitted, adopt the latest version.

EOF
}

version(){
    cargo search &amp;quot;$1&amp;quot; | grep -Eo &amp;quot;^$1 \(.*?\)&amp;quot; | sed &amp;quot;s/^$1 (\(.*\))/\1/&amp;quot;
}

find_cargo(){
    # TODO: look up parent directories
    ls | grep &#39;^Cargo.toml$&#39;
}

ensure_dep_exists(){
    cargo=&amp;quot;$1&amp;quot;
    if ! grep -F &#39;[dependencies]&#39; &amp;quot;$cargo&amp;quot; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then
        echo &#39;[dependencies]&#39; &amp;gt;&amp;gt; &amp;quot;$cargo&amp;quot;
    fi
}

insert_dep(){
    cargo=&amp;quot;$1&amp;quot;
    crate=&amp;quot;$2&amp;quot;
    version=&amp;quot;$3&amp;quot;
    # FIXME: Because Linux and Mac behaves defferently on null string argument, don&#39;t use it and adopt workaround.
    sed -i&#39;&#39; &amp;quot;/\[dependencies\]/{a\
$crate = \&amp;quot;$version\&amp;quot;
}&amp;quot; &amp;quot;$cargo&amp;quot;
}

run(){
    CARGO_TOML=&amp;quot;$(find_cargo)&amp;quot;
    if [ $? != 0 ]
    then
        echo &amp;quot;Cargo.toml not found&amp;quot; 1&amp;gt;&amp;amp;2
        exit 1
    fi

    if [ -z &amp;quot;$1&amp;quot; ]; then
        usage
        exit 1
    else
        CRATE=&amp;quot;$1&amp;quot;
    fi

    if [ -z &amp;quot;$2&amp;quot; ]; then
        VERSION=&amp;quot;$(version $1)&amp;quot;
    else
        VERSION=&amp;quot;$2&amp;quot;
    fi

    ensure_dep_exists &amp;quot;$CARGO_TOML&amp;quot;
    insert_dep &amp;quot;$CARGO_TOML&amp;quot; &amp;quot;$CRATE&amp;quot; &amp;quot;$VERSION&amp;quot;    
}

main(){
    # $1 is &amp;quot;use&amp;quot; when called as a cargo plugin
    if [ &amp;quot;$1&amp;quot; != use ]; then
        echo &amp;quot;Use this as a cargo plugin&amp;quot;
        usage
        exit 1
    fi
    shift
    if [ &amp;quot;$1&amp;quot; = -h ] || [ &amp;quot;$1&amp;quot; = --help ]; then
        usage
        exit
    else
        run &amp;quot;$@&amp;quot;
    fi
}


main &amp;quot;$@&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだ洗練されていませんがお気に入りのタスクです。誰かCLIからCargo.tomlをいじれるツール作ってくれないかな。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Method Drawでお手軽LGTM生成</title>
      <link>/slide/Method_DrawdeotegaruLGTMseisei/</link>
      <pubDate>Fri, 14 Aug 2015 00:55:37 +0900</pubDate>
      
      <guid>/slide/Method_DrawdeotegaruLGTMseisei/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Method Drawでお手軽LGTM生成
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

===
# Method Draw
-------------

* シンプルなSVG エディタ
* オープンソース
* [editor.method.ac](http://editor.method.ac/)

===
# デモ

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 以上
------
Have a happy hacking life
&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>caveman2、ningle…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト</title>
      <link>/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</link>
      <pubDate>Thu, 05 Mar 2015 13:18:44 +0900</pubDate>
      
      <guid>/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# caveman2、ningle、datafly…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト
----------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
&lt;span style=&#34;font-size:300%&#34;&gt;ずっと俺のターン&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 問題
------
Common Lispは case

* Sensitive &lt;!--.element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;  
* Insensitive &lt;!--.element: class=&#34;fragment shrink&#34; data-fragment-index=&#34;1&#34; --&gt;

どっち?
===
# 問題
-------

あれ？

```lisp
(eql? &#39;CaseInsensitive &#39;caseinsensitive) ;=&gt; t
```

===
# 問題
-------

リーダがデフォルトで大文字にするだけ
```lisp
(eql? &#39;|CaseSensitive| &#39;|casesensitive|) ;=&gt; nil
```

===
# Caveman2
---------

```lisp
@route GET &#34;/hello&#34;
(defun say-hello (&amp;key (|name| &#34;Guest&#34;))
  (format nil &#34;Hello, ~A&#34; |name|))
```
===
# Ningle
--------

```lisp
(setf (ningle:route *app* &#34;/login&#34; :method :POST)
      #&#39;(lambda (params)
          (if (authorize (getf params :|username|)
                         (getf params :|password|))
            &#34;Authorized!&#34;
            &#34;Failed...Try again.&#34;)))
```
===
# 面倒…
----
デフォルトでそのままだたっらいいのに
===
# 魔法の`readtable-case`

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 魔法の`readtable-case`
-----------------------
```lisp
(setf (readtable-case *readtable*) :invert)
```
を使えばOK  
参考: [SBCLでclispとかallegroのmodern mode的なことをする - wasabizの日記](http://wasabiz.hatenablog.com/entry/20120929/1348889601)
===
# 例
----
```lisp
CL-USER&gt; :username
:USERNAME
CL-USER&gt; (setf (readtable-case *readtable*) :invert)
:invert
CL-USER&gt; :username
:username
```
===
# まとめ
--------
* `(setf (readtable-case *readtable*) :invert)`を使うと快適だよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Lispエイリアンの矢印作った</title>
      <link>/blog/2015/03/03/lispeiriannoyajirushitsukutta</link>
      <pubDate>Tue, 03 Mar 2015 21:30:13 +0900</pubDate>
      
      <guid>/blog/2015/03/03/lispeiriannoyajirushitsukutta</guid>
      <description>&lt;p&gt;κeenです。勉強会などで役立ちそうなLispエイリアンの矢印を作りました。&lt;/p&gt;

&lt;p&gt;Lispエイリアンの元データは&lt;a href=&#34;http://www.lisperati.com/logo.html&#34;&gt;こちら&lt;/a&gt;でPNGやSVGで公開されているのでInkscapeの練習がてらそれをいじりました。&lt;/p&gt;

&lt;p&gt;どうぞ&lt;br /&gt;
&lt;img src=&#34;/images/lisplogo_alien_arrow.svg&#34; alt=&#34;lisplogo_alien_arrow.svg&#34; /&gt;&lt;br /&gt;
&lt;a href=&#34;/images/lisplogo_alien_arrow.svg&#34;&gt;lisplogo_alien_arrow.svg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ライセンスは元データに倣ってパブリックドメインとします。&lt;/p&gt;

&lt;p&gt;PNG形式のもの必要…ですか？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>印刷フォマット済みのテキストファイルをPDF化する</title>
      <link>/blog/2015/01/24/a2pdf</link>
      <pubDate>Sat, 24 Jan 2015 10:23:00 +0000</pubDate>
      
      <guid>/blog/2015/01/24/a2pdf</guid>
      <description>&lt;p&gt;小ネタ。古いドキュメントやらポータブルな仕様を落としてくると中身が印刷フォーマット済み(ページネーションやヘッダ、フッタをアスキーアートで表現してる)であることがあります。
それらを普通のテキスト形式だと読みづらいのでPDF化する話。&lt;/p&gt;

&lt;p&gt;結論から言うと&lt;a href=&#34;http://search.cpan.org/~jonallen/a2pdf-1.11/lib/Script/a2pdf.pm&#34;&gt;a2pdf - search.cpan.org&lt;/a&gt;を使いました。選んだ理由は&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;余計な装飾を付与しない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^L&lt;/code&gt;(pagebreak)でちゃんと改ページする&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;です。使い方は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ a2pdf --noheader --noperl-syntax --noline-numbers  foo.txt -o foo.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でok。本当は&lt;code&gt;--nofooter&lt;/code&gt;も付けたいんですがそれつけるとエラー出たのでやむなくフッタは甘受。元々perlのソースコードをPDF化するためのものらしく、デフォルトでそのような設定になってるので無効化する必要があります。&lt;/p&gt;

&lt;p&gt;生成速度なんですけどPDF化すると105ページあるテキストの変換に73秒かかりました。少し遅いですね。このくらいだったらサクっとCommon Lispで書いてしまった方が速かったのかなぁ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MathJaxを使って数式を埋め込む</title>
      <link>/blog/2014/02/21/mathjax</link>
      <pubDate>Fri, 21 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/02/21/mathjax</guid>
      <description>&lt;p&gt;小ネタです。ブログに数式を埋め込むときの話。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mathjax.org/&#34;&gt;MathJax&lt;/a&gt;はHTMLに$\LaTeX$の式を埋め込んでJavaScriptでMathMLに変換するプロジェクトみたいです。&lt;/p&gt;

&lt;p&gt;Octopressで使うには&lt;code&gt;(ocotpressroot)/source/_includes/custom/head.html&lt;/code&gt;に&lt;/p&gt;

&lt;figure class=&#34;code&#34;&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&#34;gutter&#34;&gt;&lt;pre class=&#34;line-numbers&#34;&gt;&lt;span class=&#34;line-number&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;line-number&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;line-number&#34;&gt;3&lt;/span&gt;
&lt;span class=&#34;line-number&#34;&gt;4&lt;/span&gt;
&lt;span class=&#34;line-number&#34;&gt;5&lt;/span&gt;
&lt;span class=&#34;line-number&#34;&gt;6&lt;/span&gt;
&lt;span class=&#34;line-number&#34;&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;&#34;&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;script type=&#34;text/x-mathjax-config&#34;&amp;gt;
&lt;/span&gt;&lt;span class=&#34;line&#34;&gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#34;\\(&#34;,&#34;\\)&#34;]] } });
&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;/script&amp;gt;
&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;script type=&#34;text/javascript&#34;
&lt;/span&gt;&lt;span class=&#34;line&#34;&gt; src=&#34;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&amp;gt;
&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;/script&amp;gt;
&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;meta http-equiv=&#34;X-UA-Compatible&#34; CONTENT=&#34;IE=EmulateIE7&#34; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;を追加するだけです。&lt;/p&gt;

&lt;p&gt;数式を埋め込むには、上の設定だと&lt;code&gt;$数式$&lt;/code&gt;又は&lt;code&gt;\\\(数式\\\)&lt;/code&gt;でインライン、&lt;/p&gt;

&lt;figure class=&#34;code&#34;&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;table&gt;&lt;tr&gt;
&lt;td class=&#34;gutter&#34;&gt;&lt;pre class=&#34;line-numbers&#34;&gt;&lt;span class=&#34;line-number&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;line-number&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;line-number&#34;&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;&#34;&gt;&lt;span class=&#34;line&#34;&gt;\\\[
&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;数式
&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;\\\]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;で別行立ての数式が書けます。markdownとコンフリクトするのでバックスラッシュのエスケープ大変ですね…。&lt;code&gt;\begin{eqnarray*}\end{eqnarray*}&lt;/code&gt;は無理なのかなあ&lt;/p&gt;

&lt;p&gt;インライン\(e^{i\pi} = -1\)&lt;/p&gt;

&lt;p&gt;別行\\[\lim_{n \to \infty} P(Z=l) = e^{–\lambda} \frac{ \lambda ^l}{l!}\]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FreeBSDのmanページを手動インストールする</title>
      <link>/blog/2014/02/01/freebsd-manpage</link>
      <pubDate>Sat, 01 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/02/01/freebsd-manpage</guid>
      <description>&lt;p&gt;FreeBSD10をインストールするときにdocをインストールしなかったら後で困ったのでメモ。環境はUbuntu13.10上のkvmに入れたFreeBSD10です。&lt;/p&gt;

&lt;p&gt;本来なら&lt;code&gt;sudo bsdconfig&lt;/code&gt;(9.xまでは&lt;code&gt;sudo sysinstall&lt;/code&gt;)でメニューを選んでいけばインストールできるのですが、&lt;code&gt;ping&lt;/code&gt;か何かがおかしくてサーバーの名前解決ができない。&lt;code&gt;ping FreeBSD.org&lt;/code&gt;や&lt;code&gt;ping 4.4.4.4&lt;/code&gt;が返ってこない。しかし&lt;code&gt;curl&lt;/code&gt;などは普通に動きます。&lt;/p&gt;

&lt;p&gt;とりあえず&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ftp anonymous@ftp.jp.freebsd.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でログインし、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ftp&amp;gt; cd pub/FreeBSD/releases/i386/10.0-RELEASE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と進んで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ftp&amp;gt; get doc.txz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;します。んで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ftp&amp;gt; bye
$ unxz -cd doc.txz | sudo tar xf - -C /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストール完了。&lt;/p&gt;

&lt;p&gt;普通に配置するだけで良いんですね。mandbとかあるのかと思ってた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rsync小ネタ</title>
      <link>/blog/2013/11/30/something-about-rsync</link>
      <pubDate>Sat, 30 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/11/30/something-about-rsync</guid>
      <description>&lt;p&gt;&lt;a href=&#34;/blog/2013/11/13/what-recent/&#34;&gt;mpdを導入したとき&lt;/a&gt;にrsyncでパーミッションの問題が発生したと言ってましたが解決策がありました。&lt;/p&gt;

&lt;p&gt;まず基本。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rsync&lt;/code&gt;でバックアップをとるときは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rsync -avz dir/ me@remote:backup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;code&gt;dir&lt;/code&gt;のあとの&lt;code&gt;/&lt;/code&gt;は重要です。&lt;code&gt;dir&lt;/code&gt;自体か&lt;code&gt;dir&lt;/code&gt;の中身かを左右します。&lt;code&gt;zsh&lt;/code&gt;はそこんとこイマイチ理解してないようで悲しいです。因みに&lt;code&gt;-a&lt;/code&gt;は&lt;code&gt;-rltogpD&lt;/code&gt;の略です。でも今回みたいにパーミッションを含めたくないときは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rsync -rltogD -vz dir/ me@remote:backup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;-p&lt;/code&gt;を抜くかと思いきや、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rsync -avz --no-p dir/ me@remote:backup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なる記法があるそうです。便利ですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tiarraにercで接続したときの/loadの問題</title>
      <link>/blog/2013/10/06/tiarra-erc</link>
      <pubDate>Sun, 06 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/10/06/tiarra-erc</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.clovery.jp/tiarra/&#34;&gt;tiarra&lt;/a&gt;に &lt;a href=&#34;http://www.emacswiki.org/ERC&#34;&gt;erc&lt;/a&gt;で接続したときの/loadの問題。&lt;/p&gt;

&lt;p&gt;tiarraは有名なircプロキシ。ercはEmacs上で動くircクライアント。これらを使っているとtiarraが自動でログインしてくれないのでおかしいなと思っていたらtiarraの自動ログインモジュールを有効にしていなかった模様。&lt;/p&gt;

&lt;p&gt;書き換えていざ設定を反映しようとすると若干困りました。どこに&lt;code&gt;/load&lt;/code&gt;と打てばいいんだろ。&lt;/p&gt;

&lt;p&gt;最初に誘導されるバッファ(ircバッファ名がプロキシサーバー名になってるやつ)に&lt;code&gt;/load&lt;/code&gt;と打つと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERC&amp;gt; /load
Incorrect arguments. Usage:
/LOAD line
Load the script provided in the LINE.
If LINE continues beyond the file name, the rest of
it is put in a (local) variable `erc-script-args&#39;,
which can be used in Emacs Lisp scripts.


The optional FORCE argument is ignored here - you can&#39;t force loading
a script after exceeding the flood threshold.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですって。ああ…。&lt;code&gt;/load&lt;/code&gt;コマンドがercに食われてる…&lt;/p&gt;

&lt;p&gt;流石に解決策あるだろって思って調べたら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/quote load
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;だそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERC&amp;gt; /quote load
-192.168.1.4- *** Reloaded configuration file.
-192.168.1.4- *** Module Channel::Join::Connect will be loaded newly.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。ちゃんとloadしてくれました。&lt;/p&gt;

&lt;p&gt;以上小ネタでした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FreeBSD10でちょっとこけた</title>
      <link>/blog/2013/09/12/error-on-svn</link>
      <pubDate>Thu, 12 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/09/12/error-on-svn</guid>
      <description>

&lt;p&gt;FreeBSD10をインストールしてたときにちょっとつまったところがあったのでメモ。&lt;/p&gt;

&lt;h2 id=&#34;前回までのあらすじ&#34;&gt;(前回までのあらすじ)&lt;/h2&gt;

&lt;p&gt;FreeBSD10をインストールしたkvmのイメージでFreeBSDのソースをコンパイルできなくなっていたのでκeenはイメージに最新のFreeBSDを上書きインストールすることを決意したのであった&lt;/p&gt;

&lt;h2 id=&#34;今回&#34;&gt;今回&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://pub.allbsd.org/FreeBSD-snapshots/&#34;&gt;https://pub.allbsd.org/FreeBSD-snapshots/&lt;/a&gt;から最新版isoをダウンロードして&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kvm -cdrom ~/Download/FreeBSD-10.0-HEAD-r255472-JPSNAP-i386-i386-disc1.iso -boot d -m 2048 -smp 3 FreeBSD10.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でブート&amp;amp;インストール。普通にインストーラに従って問題無し。&lt;br /&gt;
もう一度&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kvm -m 2048 -smp 3 FreeBSD10.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でブート。&lt;code&gt;/usr/src&lt;/code&gt;が空なのを確認して、最近標準添付になったsvnliteでソースをチェックアウト。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd /usr
# rmdir src
# svnlite co https://svn0.us-west.FreeBSD.org/base/head src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、エラー。&lt;br /&gt;
内容は&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;server sent a truncated http response body.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不明。&lt;code&gt;svn(lite)&lt;/code&gt;のエラーらしいことは分った。&lt;code&gt;https:&lt;/code&gt;が悪い気がするので&lt;code&gt;http:&lt;/code&gt;にしようかと思ったけど、ふとダメ元で以前はできなかった&lt;code&gt;svn:&lt;/code&gt;のスキーマにしてみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# svnlite co svn://svn0.us-west.FreeBSD.org/base/head src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できた。なんだよ。&lt;/p&gt;

&lt;h3 id=&#34;蛇足&#34;&gt;蛇足&lt;/h3&gt;

&lt;p&gt;このあと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# svnlite co svn://svn0.us-west.FreeBSD.org/ports/head ports
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でportsもチェックアウトしましたよ&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>