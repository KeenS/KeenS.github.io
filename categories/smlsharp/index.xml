<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Smlsharp on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/smlsharp/</link>
    <description>Recent content in Smlsharp on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 05 Dec 2015 22:04:25 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/smlsharp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SML#でDBに接続</title>
      <link>http://keens.github.io/blog/2015/12/05/sml_dedbnisetsuzoku</link>
      <pubDate>Sat, 05 Dec 2015 22:04:25 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/05/sml_dedbnisetsuzoku</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/848&#34;&gt;ML Advent Calendar&lt;/a&gt;6日目の記事です。&lt;br /&gt;
次はdico_leque先生で、「ML中心にしつつ何か」です。&lt;/p&gt;

&lt;p&gt;κeenです。SMl#はDB接続及びSQLを言語レベルでサポートしていることが大きな特徴ですが詳細な方法についてはあまり情報がなく、
実際に利用するのは難しい状況にあります。そこで私がなんとかソースコードを読んで得られた知識を少し共有したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;接続サーバ設定:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続サーバ設定&lt;/h1&gt;

&lt;p&gt;DBへの接続サーバ設定には&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_sqlserver serverLocation : τ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;式を使います。このserverLocationはDB毎に指定方法が異なります。公式のドキュメントにはデフォルトDBであるPostgreSQLへの接続方法しか書かれていませんが、いくつかのDBをサポートします。&lt;/p&gt;

&lt;p&gt;SML#はDB接続時にテーブルの型を要求します(上でいう型注釈の&lt;code&gt;τ&lt;/code&gt;がそれです。文法的に型注釈がないといけません。)。今回の例では公式ドキュメントにある通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DB mydb;
CREATE TABLE Persons (
  name text not null,
  age int not null,
  salary int not null
);
USE mydb;
INSERT INTO Persons VALUES (&#39;Joe&#39;, 21, 10000);
INSERT INTO Persons VALUES (&#39;Sue&#39;, 31, 20000);
INSERT INTO Persons VALUES (&#39;Bob&#39;, 41, 30000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で作ったDBへ接続することにします。&lt;/p&gt;

&lt;h2 id=&#34;テーブルの型:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;テーブルの型&lt;/h2&gt;

&lt;p&gt;深追いしてないので分かりません。とりあえず今回使う&lt;code&gt;mydb&lt;/code&gt;は&lt;code&gt;{Persons:{name:string, age:int, salary :int}&lt;/code&gt;で接続出来るみたいです。これも追わねば…&lt;/p&gt;

&lt;p&gt;一応ソースを読む限りだとint, decimal, real32, float, real, string, bool, timestampがあるようです。NULLableなカラムにはoptionを使うようです。&lt;/p&gt;

&lt;p&gt;SMLで見慣れないdecimal, float, timestampはSML#が実装を持っているようです。&lt;/p&gt;

&lt;p&gt;float, decimalは内部表現は文字列で、文字列との相互及びrealとIEEERealへの変換が出来るようです。&lt;/p&gt;

&lt;p&gt;timestampは文字列との相互変換及び&lt;code&gt;now()&lt;/code&gt;関数, &lt;code&gt;defaultTimestamp&lt;/code&gt;が存在します(スキーマに&lt;code&gt;DEFAULT&lt;/code&gt;指定があった時用)。内部表現はunix timeなのか、intです。&lt;/p&gt;

&lt;p&gt;それぞれ&lt;code&gt;SQL.Float&lt;/code&gt;, &lt;code&gt;SQL.Decimal&lt;/code&gt;, &lt;code&gt;SQL.TimeStamp&lt;/code&gt;モジュールに入っています。&lt;/p&gt;

&lt;h2 id=&#34;postgresql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;PostgreSQL&lt;/h2&gt;

&lt;p&gt;デフォルト設定のpgのmydbというDBへ接続したいならこれで接続出来ると公式ドキュメントに書いてあるのですが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (dbname=&amp;quot;mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと最後の &lt;code&gt;}&lt;/code&gt;が1つ抜けている上、それを補っても&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(interactive):2.27-2.32 Error: (name evaluation &amp;quot;190&amp;quot;) unbound variable: dbname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と返してきます。正しくは(?)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。他のパラメータ、例えばホストやポート、パスワードを渡したい場合はスペース区切で渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb host=localhost password=hogehoge&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この文字列はそのままPostgreSQLの&lt;a href=&#34;http://www.fireproject.jp/feature/postgresql/programing_libpq/connect.html#2&#34;&gt;&lt;code&gt;PGconnectdb&lt;/code&gt;&lt;/a&gt;という関数に渡っているのでそのドキュメントに完全な受付可能なキーが書いてあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host: DBサーバ名&lt;/li&gt;
&lt;li&gt;hostaddr: DBサーバのIPアドレス&lt;/li&gt;
&lt;li&gt;user: DB接続時のユーザ名&lt;/li&gt;
&lt;li&gt;password: userに対するパスワード&lt;/li&gt;
&lt;li&gt;dbname: DB名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とのことです。&lt;/p&gt;

&lt;h2 id=&#34;mysql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;MySQL&lt;/h2&gt;

&lt;p&gt;ドキュメントはありませんがソースコードを読んである程度勘を効かせた上で色々書いて試行錯誤すれば接続方法は分かります。&lt;/p&gt;

&lt;p&gt;MySQLに接続するには以下のように&lt;code&gt;SQL.mysql&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = _sqlserver (SQL.mysql &amp;quot;dbname=mydb&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余談ですが&lt;code&gt;_sqlserver&lt;/code&gt;はオーバーロードされていて、backend型とstring型両方を受け付けます。
文字列が来た時には&lt;code&gt;SQL.default&lt;/code&gt;に渡されます。そして &lt;code&gt;val default = postgresql&lt;/code&gt;です。つまり、PostgreSQLの例は&lt;code&gt;_sqlserver (SQL.postgresql &amp;quot;dbname=mydb&amp;quot;)&lt;/code&gt;
としているのと同じです。&lt;/p&gt;

&lt;p&gt;閑話休題。MySQLの時に渡せるパラメータの話をしましょう。こちらはバックエンドの接続関数にそのまま渡してる訳ではないのですが、
SML#側でパーサを持っているのでPostgreSQLの時のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;SQL.mysql &amp;quot;dbname=mydb host=localhost&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで使えるキーは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val availableKeys = [&amp;quot;host&amp;quot;, &amp;quot;port&amp;quot;, &amp;quot;user&amp;quot;, &amp;quot;password&amp;quot;, &amp;quot;dbname&amp;quot;, &amp;quot;unix_socket&amp;quot;, &amp;quot;flags&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義されています&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。因みにこれはパースエラーにならない文字列の集合であって、&lt;code&gt;unix_socket&lt;/code&gt;を使おうとするとコネクションエラーになるようです(&lt;code&gt;raise Connect &amp;quot;unix_socket is not supported&amp;quot;&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;文法に関して深掘りすると、一応パーサ(&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/KeyValuePair.sml&#34;&gt;src/sql/main/KeyValuePair.sml&lt;/a&gt;)を読む限りだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;keyは &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;(&lt;code&gt;isAlphanum&lt;/code&gt; + &lt;code&gt;#&#39;_&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueはスペース以外の文字列(e.g. &lt;code&gt;hogehoge&lt;/code&gt;)又は&lt;code&gt;&#39;&lt;/code&gt;で囲まれた文字列(e.g. &lt;code&gt;&#39;hoge hoge&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueでは&lt;code&gt;\&lt;/code&gt;によるエスケープが可能(e.g. &lt;code&gt;hoge\ hoge&lt;/code&gt;, &lt;code&gt;&#39;a \&#39;quote\&#39;&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;\&lt;/code&gt;については文字列の中なので&lt;code&gt;\&lt;/code&gt;自身のエスケープが必要なことに注意して下さい。&lt;/p&gt;

&lt;h2 id=&#34;unixodbc:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;unixODBC&lt;/h2&gt;

&lt;p&gt;ご存知ない方に説明するとODBCはOpen Database Connectivityの略です。Microsoftが主導となって定めたDB接続のインターフェースです。また、そのインターフェースに従うドライバマネージャのことも指します。
一旦抽象化レイヤを挟むのでパフォーマンス面では生の接続に負けますが、豊富な接続先が魅力です。
MicroSoftのSQL ServerやMicroSoft Accessを始めとし、Oracle, MySQL, PostgreSQL, SQLite3, 果てはMongoDBなどにまで接続出来ます。
まあ、接続出来るからといって投げたクエリを正しく解釈、実行してくれるとは限りませんが…&lt;/p&gt;

&lt;p&gt;unixODBCはODBCのunix実装のようです。つまりODBCドライバを持つDBにunixから接続出来ます。&lt;/p&gt;

&lt;p&gt;さてさて、odbcに繋ぐには以下のようにします。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = (SQL.odbc &amp;quot;mydb username mypassword&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜ記法変えたし…。しかも必ずスペースで区切るのでクォートも出来なければ空のユーザパスワードを渡すことも出来ません。もしかしたら&lt;code&gt;&amp;quot;&#39;&#39;&amp;quot;&lt;/code&gt;としたら後側で空の文字列と扱ってくれるかもしれませんが。&lt;/p&gt;

&lt;p&gt;私自身ODBCに詳しくないのですが、ODBCに接続するときはData Source Nameと呼ばれるものがシステムの特定の場所に存在するので他の接続情報は必要ないみたいです。&lt;/p&gt;

&lt;h1 id=&#34;接続:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続&lt;/h1&gt;

&lt;p&gt;さっきまでは接続サーバの設定の話でした。今度は実際に接続する話です。DBMS固有の話はサーバ設定までなのでこれからは総のDBに共通です。&lt;/p&gt;

&lt;p&gt;接続するには公式のドキュメント通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val conn = SQL.connet myServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で繋げます。ここで各クライアントのダイナミックリンクライブラリがないとエラーになります。64dbit環境でSML#を32bitでビルドしている人はライブラリも32bitでビルドされていることを確認しましょう。&lt;/p&gt;

&lt;h1 id=&#34;クエリ:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;クエリ&lt;/h1&gt;

&lt;p&gt;これもドキュメント通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myQuery = _sql db =&amp;gt; select #P.name as name, #P.age as age
      from #db.Persons as P
      where SQL.&amp;gt;(#P.salary, 10000)
val rel = _sqleval myQuery conn
val result = SQL.fetchAll rel; (* =&amp;gt; [{age=32, name=&amp;quot;Sue&amp;quot;}, {age=41, name=&amp;quot;Bob&amp;quot;}] *)
val () = SQL.closeRel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;p&gt;可能な文法については主に&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch10.S5.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;を参考にしましょう。&lt;/p&gt;

&lt;p&gt;insert, update, deleteをサポートしている他、トランザクション(&lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt;)をサポートしているようです。詳しくは&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/compiler/parser2/main/iml.grm#L727&#34;&gt;BNF&lt;/a&gt;を読んで下さい。&lt;/p&gt;

&lt;p&gt;SQLを投げて返ってきたリレーションに対しては結果を総取得する&lt;code&gt;SQL.fetchAll&lt;/code&gt;、結果をoption型で1つ取得する&lt;code&gt;SQL.fetch&lt;/code&gt;、結果を1つ取得するか例外になる&lt;code&gt;SQL.fetchOne&lt;/code&gt;を使います。&lt;code&gt;fetchOne&lt;/code&gt;の上げる例外は&lt;code&gt;SQL.NotOne&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;クエリ結果を使い終わったら必ず&lt;code&gt;SQL.closeRel&lt;/code&gt;で開放しましょう。そしてコネクションも、終わったら&lt;code&gt;SQL.closeCon&lt;/code&gt;で開放しましょう。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;本当は実際に試してから記事を書きたかったのですが、32bitの壁に阻まれて出来ませんでした。しかしソースを読んで裏を取って書いてあるのでまあまあ信憑性のある内容だと思います。
SML# からデータベースに接続したい方の一助になれば幸いです。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>SML#をMacでビルドする</title>
      <link>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</link>
      <pubDate>Wed, 29 Apr 2015 16:09:08 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</guid>
      <description>

&lt;p&gt;κeenです。SML#2.0.0を文鎮と化していたMBAにインストールしたのでメモをば。&lt;/p&gt;

&lt;p&gt;基本は&lt;a href=&#34;http://d.hatena.ne.jp/keita44_f4/20140412/1397279451&#34;&gt;よんたさんの記事&lt;/a&gt;をMacに翻訳した感じです。&lt;/p&gt;

&lt;p&gt;モチベーションは、&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/ja/?Download&#34;&gt;公式の配布物&lt;/a&gt;がMac版だとMacPorts版しかなく、
portsとhomebrewの混在は避けた方が良いと聞いたのでどうにかして自前ビルドしようとしたことです。&lt;/p&gt;

&lt;h1 id=&#34;注意書き:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;注意書き&lt;/h1&gt;

&lt;p&gt;冒頭にも書いてあるようにMBAは普段使ってなくて、このエントリーもMBAじゃないマシンから書いているのでコマンド類はコピペでなく写経してます。
typoがあるかもしれないのでコピペして動かなかったら一応この記事のtypoを疑って下さい。&lt;/p&gt;

&lt;h1 id=&#34;gmp32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;GMP32bitの準備&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ brew install gmp --32-bit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で終わり。バージョン6.0.0aが入りました。
既にインストールされていたら多分64bit版が入っているので一旦 &lt;code&gt;brew remove gmp&lt;/code&gt; してから再度インストールすると良いです。尚、バイナリ版はないようで、ビルドが始まります。checkに時間が掛かる。&lt;/p&gt;

&lt;h1 id=&#34;llvm34-32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;LLVM34 32bitの準備&lt;/h1&gt;

&lt;p&gt;骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://llvm.org/releases/3.4.2/llvm-3.4.2.src.tar.gz
$ gzcat llvm-3.4.2.src.tar.gz | tar xf -
$ cd llvm-3.4.2.src
$ ./configure --build=i686-mac-darwin CC=&#39;gcc -m32&#39; CXX=&#39;g++ -m32&#39; --prefix=/usr/local/Cellar/llvm34/3.4.2a
$ make -j4
$ make -j4 install
$ cd ../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら上手くいきました。何故上手くいったんでしょうねー。あとprefixは割と気持悪いのでみなさん適切な場所にインストールしましょうね。&lt;/p&gt;

&lt;h1 id=&#34;sml-のビルド:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;SML# のビルド&lt;/h1&gt;

&lt;p&gt;これが一番骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.pllab.riec.tohoku.ac.jp/smlsharp/download/smlsharp-2.0.0.tar.gz
$ gzcat smlsharp-2.0.0.tar.gz | tar xf -
$ cd smlsharp-2.0.0
$ ./configure --with-llvm=/usr/local/Cellar/llvm34/3.4.2a/      \
               LDFLAGS=&#39;-L/usr/local/Cellar/gmp/6.0.0a/lib&#39;     \
              CPPFLAGS=&#39;-I/usr/local/Cellar/gmp/6.0.0a/include&#39; \
                    CC=&#39;gcc -m32&#39;                               \
                   CXX=&#39;g++ -m32&#39;
$ make -j4
$ make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら出来ました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;誰かhomebrewにして。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpを使ってSMLのon-the-flyエラーチェック</title>
      <link>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</link>
      <pubDate>Thu, 23 Apr 2015 23:01:17 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</guid>
      <description>

&lt;p&gt;κeenです。最近SMLを結構書いてるのですが中置演算子が乱立する言語はLisperにはつらくて、しょっちゅうコンパイルエラーを出します。
そこでSML#をflymakeで動かしてOn The Flyにエラーチェックをします。&lt;/p&gt;

&lt;p&gt;なぜSML#かというと &lt;code&gt;-ftypecheck-only&lt;/code&gt; オプションがあって、シンタックスと型エラーのチェックだけを行なえるからです。&lt;/p&gt;

&lt;p&gt;色々試したのですが設定はこれだけで済みました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(eval-after-load &#39;flymake
  &#39;(progn 
    (add-to-list &#39;flymake-allowed-file-name-masks &#39;(&amp;quot;.+\\.sml$&amp;quot;
                                                    (lambda ()
                                                      (list &amp;quot;/usr/local/bin/smlsharp&amp;quot; (list &amp;quot;-ftypecheck-only&amp;quot; (buffer-file-name))))
                                                    (lambda () nil)))
    (add-to-list &#39;flymake-err-line-patterns &#39;(&amp;quot;^\\([^: ]*\\):\\([0-9]+\\)\\.\\([0-9]+\\)-[0-9]+\\.[0-9]+ \\(Error\\|Warning\\):&amp;quot;
                                              1 2 3 4))))
(add-hook &#39;sml-mode-hook #&#39;flymake-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;/usr/local/bin/smlsharp&amp;quot;&lt;/code&gt; のところは各自書き換えて下さい。尚、SML#はエラーメッセージを複数行に跨って出すのですがそれがflymakeと相性が悪いのでエラーメッセージの取得は諦めました。&lt;/p&gt;

&lt;p&gt;多くの場合、 &lt;code&gt;flymake-simple&lt;/code&gt; という枠組みの中で設定を書くのですがテンポラリファイルを作る構造がどうしてもインターフェースファイルと相性が悪かったので生のflymakeを使ってます。
というかflymakeは元々 &lt;code&gt;-ftypecheck-only&lt;/code&gt; みたいなのを前提に作られてたのに実際にコンパイル走らせないとエラーメッセージ取得出来ない言語が多過ぎてフレームワークが出来たのでこれが本来の使い方です。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:311ce9d5e51e732b1928a84bcceb27a3&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;というものがあって、スタイルワーニングを出してくれます。ただ、これはパッチを当てないと使えなかったりスタイルワーニングのみしか出さなかったりするので気が向いた時に紹介します&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpでFFIバインディングを書く時の知見</title>
      <link>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</link>
      <pubDate>Sun, 19 Apr 2015 13:51:33 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</guid>
      <description>

&lt;p&gt;κeenです。最近頻繁にSML#を使ってます。SML#のメイン機能の1つであるC連携ですが、ちょっと複雑なことをやろうとするとテクニックが必要になるので共有します。&lt;/p&gt;

&lt;p&gt;Twitterとかにコメントや突っ込みお願いします。&lt;/p&gt;

&lt;h1 id=&#34;簡単な型:017736760057fcde64c6904c3e916b13&#34;&gt;簡単な型&lt;/h1&gt;

&lt;p&gt;型が簡単な関数なら普通に&lt;code&gt;_import&lt;/code&gt;で済みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val puts = _import &amp;quot;puts&amp;quot;: string -&amp;gt; ()
val () = puts &amp;quot;Hello, C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尚、簡単な型とは&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch9.S2.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;にある通り、いわゆる即値、即値の組（タプル）、即値の配列、即値の参照、それらを引数、返り値に持つ関数などです。&lt;/p&gt;

&lt;p&gt;又、以下のような制約もあります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C関数全体の型は，引数リストを組型とするMLの関数型に対応付けられます． ただし，C関数の引数や返り値に書ける相互運用型には，以下の制約があり ます．
   配列型や組型など，Cのポインタ型に対応する相互運用型を，C関数の返り値の 型として指定することはできません．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恐らくGCとの兼ね合いでしょうがつらいですね。stringすら返り値で受け取れません。&lt;/p&gt;

&lt;p&gt;それにこの制約がどこまで効いてるのかが不明で、同じ型でも型付けに成功したり失敗したりすることがあります。例えば上の例でstring型を引数にとる関数をインポートしましたが関数に依ってはstringが相互運用型でないとか怒られることがあります。タプルの配列やタプルの参照などは確実にダメみたいです。&lt;/p&gt;

&lt;p&gt;尚、string型はCでいう &lt;code&gt;const char *&lt;/code&gt; 、タプルは変更不能な構造体へのポインタになるそうです。構造体の即値は扱えないんですね…。また、参照とは別に &lt;code&gt;ptr&lt;/code&gt; 型も存在します。SML#側からは作れず、Cとの相互運用のためだけに存在するようです。&lt;/p&gt;

&lt;h1 id=&#34;魔法の-unit-ptr:017736760057fcde64c6904c3e916b13&#34;&gt;魔法の &lt;code&gt;unit ptr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;じゃあ複雑な型はインポート出来ないのかというとそうでもなく、 &lt;code&gt;unit ptr&lt;/code&gt; 型にしておけばとりあえずインポート出来ます。Cで言うところの &lt;code&gt;void *&lt;/code&gt; です。
邪悪な雰囲気を感じますね。しかしそこは型安全言語、ちゃんと型安全に &lt;code&gt;unit ptr&lt;/code&gt; を扱えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;type file = unit ptr
val fopen = _import &amp;quot;fopen&amp;quot;: (string, string) -&amp;gt; file
val fgetc = _import &amp;quot;fgetc&amp;quot;: (file) -&amp;gt; int
val fclose = _import &amp;quot;fclose&amp;quot;: (file) -&amp;gt; int
val () = let
      val f = fopen(&amp;quot;test&amp;quot;, &amp;quot;r&amp;quot;)
      val c = fgetc(f)
    in
      print(str(chr c));
      fclose(f)
    end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。単に &lt;code&gt;type&lt;/code&gt; で名前をつけてあげれば大丈夫です。SML#側ではポイント先が何であるかには関知せず、インポートしたC関数の間で完結してれば問題ありません。多くのライブラリはそのようなAPIになっているのではないでしょうか。&lt;/p&gt;

&lt;h1 id=&#34;ポインタを扱う:017736760057fcde64c6904c3e916b13&#34;&gt;ポインタを扱う&lt;/h1&gt;

&lt;p&gt;とはいえ時にポインタを扱う必要もあります。構造体の配列を扱えないのでその辺で。&lt;/p&gt;

&lt;p&gt;そういった時に便利なのが &lt;code&gt;SMLSharp_Builtin.Pointer&lt;/code&gt; と &lt;code&gt;Pointer&lt;/code&gt; です。 &lt;code&gt;Pointer&lt;/code&gt; の方は .smi ファイルの中で &lt;code&gt;_require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt; してから使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure SMLSharp_Builtin
  structure Pointer =
  struct
    val identityEqual = _builtin val IdentityEqual : boxed * boxed -&amp;gt; bool
    val advance = _builtin val Ptr_advance : &#39;a ptr * int -&amp;gt; &#39;a ptr
    val deref = _builtin val Ptr_deref : &#39;a ptr -&amp;gt; &#39;a
    val store = _builtin val Ptr_store : &#39;a ptr * &#39;a -&amp;gt; unit

    val toUnitPtr = _builtin val Cast : &#39;a ptr -&amp;gt; unit ptr
    val fromUnitPtr = _builtin val Cast : unit ptr -&amp;gt; &#39;a ptr
    val toCodeptr = _builtin val BitCast : unit ptr -&amp;gt; codeptr
  end
  end

structure Pointer =
struct
  val advance = SMLSharp_Builtin.Pointer.advance

  val load =
      case &#39;a in &#39;a ptr -&amp;gt; &#39;a of
        int =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | char =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.deref

  val store =
      case &#39;a in &#39;a ptr * &#39;a -&amp;gt; unit of
        int =&amp;gt; SMLSharp_Builtin.Pointer.store
      | word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | char =&amp;gt; SMLSharp_Builtin.Pointer.store
      | real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.store

  val isNull : &#39;a ptr -&amp;gt; bool
  val NULL : unit -&amp;gt; &#39;a ptr

  val importBytes : SMLSharp_Builtin.Word8.word ptr * int
                    -&amp;gt; SMLSharp_Builtin.Word8.word vector
  val importString : char ptr -&amp;gt; string
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 、 &lt;code&gt;store&lt;/code&gt; 、 &lt;code&gt;deref&lt;/code&gt; 、 &lt;code&gt;advance&lt;/code&gt; あたりを良く使いそうですね。&lt;/p&gt;

&lt;p&gt;実際にあった話。 &lt;code&gt;struct header { const char *name; int name_len; const char *value; int value_len}&lt;/code&gt; の配列(&lt;code&gt;struct header *&lt;/code&gt;)を扱う必要がありました。
その配列をCの関数に渡して書き換えてもらって、後で値を取り出したいという状況がです。その時値を取り出すコードがこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun getHeader headers i =
      let
          val header_ptr : char ptr ptr = fromUnitPtr(headers)
          val header_ptr = advance(header_ptr, i * 2)
          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val header_ptr = advance(header_ptr , i * 2)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val name = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val nameLen = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val value = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val valueLen = deref(header_ptr)
      in
          if isNull name
          then (NONE, String.substring(importString(value), 0, valueLen))
          else (SOME(String.substring(importString(name), 0, nameLen)),
                String.substring(importString(value), 0, valueLen))
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、タプルは構造体へのポインタなので今回の &lt;code&gt;struct header *&lt;/code&gt; は &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではありません。それは &lt;code&gt;struct header **&lt;/code&gt; になってしまいます。
また、ポインタを扱う関数が &lt;code&gt;ptr&lt;/code&gt; 型しか受け付けないので &lt;code&gt;string&lt;/code&gt; ではなく &lt;code&gt;char ptr&lt;/code&gt; にしておいて後から &lt;code&gt;importString&lt;/code&gt; で文字列にする戦略をとります。&lt;/p&gt;

&lt;p&gt;そして配列のi番目にアクセスしたかったら先述の通り &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではないので地道に &lt;code&gt;char ptr ptr&lt;/code&gt; 2*i個分、 &lt;code&gt;int ptr&lt;/code&gt; 2*i個分ポインタを進めます。
ポインタの型を変える時はダイレクトには変換出来ないようなので一旦 &lt;code&gt;unit ptr&lt;/code&gt; を経由してから変換。そして次のメンバにアクセスするために &lt;code&gt;advance&lt;/code&gt; という形をとります。&lt;/p&gt;

&lt;p&gt;そこまでしたら後は &lt;code&gt;deref&lt;/code&gt; してあげれば欲しい値がとれます。&lt;/p&gt;

&lt;h1 id=&#34;replからのimportと-dynamiclink:017736760057fcde64c6904c3e916b13&#34;&gt;REPLからのimportと &lt;code&gt;DynamicLink&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;SML#のREPLからも勿論インポート出来ますが、SML#のランタイムにリンクされてないライブラリのものはインポート出来ないのでダイナミックリンクを使います。 &lt;code&gt;DynamicLink&lt;/code&gt; にCの &lt;code&gt;dl*&lt;/code&gt; と同じ関数群が用意されているのでそれらを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure DynamicLink =
struct
  type lib (= ptr)
  datatype scope = LOCAL | GLOBAL
  datatype mode = LAZY | NOW
  val dlopen : string -&amp;gt; lib
  val dlopen&#39; : string * scope * mode -&amp;gt; lib
  val dlsym : lib * string -&amp;gt; codeptr
  val dlsym&#39; : lib * string -&amp;gt; unit ptr
  val dlclose : lib -&amp;gt; unit
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;val lib = dlopen(&amp;quot;libawsome.so&amp;quot;)&lt;/code&gt; でライブラリのオープン、 &lt;code&gt;dlsym(lib, &amp;quot;awm_function&amp;quot;): _import () -&amp;gt;unit&lt;/code&gt; で読み込みです。&lt;/p&gt;

&lt;p&gt;これでインポートする関数は必要になった時に読み込んで欲しいのですがトップレベルで &lt;code&gt;val&lt;/code&gt; でバインドすると即読み込まれてしまいます。その辺を上手くやるテクニックがSML#のソースにありました。MySQLのバインディングの部分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun lazy f =
      let
        val r = ref NONE
      in
        fn () =&amp;gt;
           case !r of
             SOME x =&amp;gt; x
           | NONE =&amp;gt;
             let val x = f ()
             in r := SOME x; x
             end
      end

  val lib =
      lazy (fn _ =&amp;gt;
               DynamicLink.dlopen
                 (case OS.Process.getEnv &amp;quot;SMLSHARP_LIBMYSQLCLIENT&amp;quot; of
                    NONE =&amp;gt; &amp;quot;libmysqlclient.16.&amp;quot; ^ SMLSharp_Config.DLLEXT ()
                  | SOME x =&amp;gt; x))

  fun find s = DynamicLink.dlsym(lib (), s)
  val mysql_init =
      lazy (fn _ =&amp;gt; find &amp;quot;mysql_init&amp;quot;
                    : _import (MYSQL) -&amp;gt; MYSQL)


...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遅延評価してますね。これ。呼び出す時は &lt;code&gt;mysql_init () (mysql)&lt;/code&gt; みたいに一旦lazyを剥がさないといけないので注意です。&lt;/p&gt;

&lt;h1 id=&#34;問題とか:017736760057fcde64c6904c3e916b13&#34;&gt;問題とか&lt;/h1&gt;

&lt;h2 id=&#34;cの仕様:017736760057fcde64c6904c3e916b13&#34;&gt;Cの仕様&lt;/h2&gt;

&lt;p&gt;確かCの仕様上構造体のメモリ上の表現にはメンバ以外のものも置いていいことになっていた筈です。
上の方法では変なコンパイラでコンパイルしたコードだと動きそうにないですね。GCCやClangは大丈夫な筈。&lt;/p&gt;

&lt;p&gt;そもそもSML#自体GCCとABI互換なコンパイラでコンパイルしたものじゃないとリンク出来なそうな気がするので杞憂ですかね。&lt;/p&gt;

&lt;h2 id=&#34;メモリ確保:017736760057fcde64c6904c3e916b13&#34;&gt;メモリ確保&lt;/h2&gt;

&lt;p&gt;Cの関数から構造体のポインタが返ってくるケースだと良いんですが自分で構造体を用意してCの関数に渡すケースだとメモリの確保が問題になります。現状、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct header
*prepare_headers(int n)
{
  return malloc(n * sizeof(struct header));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなヘルパ関数を用意して凌いでますが欲しい構造体毎に書かないといけないのであまり嬉しくないです。 &lt;code&gt;sizeof&lt;/code&gt; をSML#側でとれれば単に &lt;code&gt;malloc&lt;/code&gt; をバインドするだけで済むのに。
もう少し欲を言うと &lt;code&gt;malloc&lt;/code&gt; したらGCから外れそうな気がするので明示的に &lt;code&gt;free&lt;/code&gt; する必要がありそうです。GCに載るメモリ確保関数も欲しいですね。
さらに欲を言うとスタックアロケートする版のメモリ確保関数も欲しい。もしかしたら &lt;code&gt;alloca&lt;/code&gt; で大丈夫なんでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;define:017736760057fcde64c6904c3e916b13&#34;&gt;&lt;code&gt;#define&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ヘッダファイル内で定数を &lt;code&gt;#define&lt;/code&gt; してあることが多々あります。それらは地道に手書きでSML#側に持ってくることになりますが気になるのが互換性の問題。
特にOSのヘッダファイルには名前は同じだけどOS毎に値が異なるものが存在します。シグナルとか。OSで条件分岐するか理想的にはプリプロセッサのサポートがあればどうにかなりそうなんですけどねぇ。
現状だとCで定数を返すgetter関数を書いてSML#側でインポートして…ってやればどうにか出来そうですけどやりたくないですね。&lt;/p&gt;

&lt;h2 id=&#34;変数:017736760057fcde64c6904c3e916b13&#34;&gt;変数&lt;/h2&gt;

&lt;p&gt;私はまだ遭遇してないのですがライブラリによってはグローバル変数にアクセスしないといけないものが存在します。これもgetterとsetterを書いて…ってやるとどうにか出来そうですがどうせなら変数のインポートも出来ると良いですよね。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:017736760057fcde64c6904c3e916b13&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SML#でCのバインドを書く時は少しテクニックが必要&lt;/li&gt;
&lt;li&gt;SML#にはポインタを直接扱える関数もある&lt;/li&gt;
&lt;li&gt;それでも機能が足りない時はCでヘルパ関数を書こう。&lt;/li&gt;
&lt;li&gt;ダイナミックリンクライブラリも扱えるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>