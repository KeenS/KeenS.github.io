<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emacs | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/emacs/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-09-29T17:30:41+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Emacs便利機能/Tips紹介]]></title>
    <link href="http://KeenS.github.io/blog/2014/08/13/emacs-utility-functions/"/>
    <updated>2014-08-13T23:15:37+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/08/13/emacs-utility-functions</id>
    <content type="html"><![CDATA[<p>κeenです。このブログのアクセスログを見てるとEmacsの記事が好評なようなのでここは一つ私の知ってる便利機能を全列挙してみますね。</p>

<!-- more -->


<p>どの辺から常識でどの辺からTipsかは私の主観です。だいたいるびきちさんの本に載ってるのは常識扱いです。</p>

<p>※<code>-!-</code>でカーソル位置、<code>-¡-</code>でマーク位置を表すものとします。<br/>
※私はEmacsのtrunkをビルドして使ってるので最新のリリース版のEmacsにも含まれない機能もあるかもしれません。</p>

<h1>改行/インデント系</h1>

<h2><code>C-m</code> <code>RET</code> <code>C-j</code> <code>C-o</code></h2>

<p>最初の頃は混乱してました。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> key       </th>
<th align="left"> lisp function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> C-m = RET </td>
<td align="left"> <code>newline</code></td>
</tr>
<tr>
<td></td>
<td align="left"> C-j       </td>
<td align="left"> <code>newline-and-indent</code></td>
</tr>
<tr>
<td></td>
<td align="left"> C-o       </td>
<td align="left"> <code>open-line</code></td>
</tr>
</tbody>
</table>


<p>です。<code>C-m</code>と<code>C-o</code>の違いはカーソルが現在行に残るか残らないかです。</p>

<p><code>
aaa-!-aaa
</code>
↓ <code>C-m</code>
<code>
aaa
-!-aaa
</code>
ですが、
<code>
aaa-!-aaa
</code>
↓ <code>C-o</code>
<code>
aaa-!-
aaa
</code>
です。</p>

<p><code>C-o</code>の改行後にインデントする版を捜したのですが<code>C-M-o (split-line)</code>という近いコマンドはあるもののまさにというのはありませんでした。</p>

<p>※trunkではデフォルトで<code>electric-indent-mode</code>がonになってるので<code>C-m/RET</code>と<code>C-j</code>が入れ替わります。<br/>
※現在行と改行した先の行両方をインデントする<code>indent-then-newline-and-indent</code>という関数もあります。</p>

<h2><code>M-^</code>(<code>delete-indentation</code>)</h2>

<p>直感的には<code>newline-and-indent</code>の逆関数です。今の行を上の行にくっつけます。そのとき邪魔になるインデントは取り除いてくれます。<code>M-- M-^</code>とすると下の行を今の行にくっつけてくれます。</p>

<h2><code>C-M-j</code>(<code>indent-new-comment-line</code>)</h2>

<p>コメント内で使う<code>C-j</code>です。
<code>lisp
;;; This is a comment-!-
</code>
↓ <code>C-M-j</code>
<code>lisp
;;; This is a comment
;;; -!-
</code>
です。</p>

<h2><code>M-m</code>(<code>back-to-indentation</code>)</h2>

<p>現在行の空白文字でない最初の文字に移動します。viでいう<code>^</code>です。</p>

<p>```</p>

<pre><code>aaa-!-bbb
</code></pre>

<p><code>
↓
</code></p>

<pre><code>-!-aaabbb
</code></pre>

<p>```
です。</p>

<h2><code>electric-indent-mode</code></h2>

<p>さっきちらっと触れました。<code>C-m</code>が<code>newline-and-indent</code>になって<code>C-j</code>が<code>newline</code>になるモードです。</p>

<h1>削除/kill-ring系</h1>

<h2><code>&lt;C-S-backspace&gt;</code>(<code>kill-whole-line</code>)</h2>

<p>おなじみ <code>C-k</code>(<code>kill-line</code>)は現在位置から行末までを削除しますが、それだとぬるいといって<code>C-k</code>で現在行をまるごと削除する設定(<code>(setq kill-whole-line t)</code>)してる人もいますが、実は<code>&lt;C-S-backspace&gt;</code>で可能なのでした。鍛えられた左手の小指の先と腹でCaps LockとShiftを同時押しすれば難易度もそんなに高くない！</p>

<h2><code>C-M-w</code>(<code>append-next-kill</code>)</h2>

<p>nextのkillコマンドでkillした内容をkill-ringにappendします。チュートリアルにも載ってた気がするんですがすっかり忘れてました。</p>

<h1>編集系</h1>

<h2><code>electric-pair-mode</code></h2>

<p>開き括弧を挿入すると自動で閉じ括弧を挿入してくれます。リージョンを選択して括弧を挿入するとリージョンを囲むように括弧を挿入してくれます。これ大事。挿入後のカーソルは開き/閉じのどちらを入力したかに依ります。まあ、想像付きますね。地味に鉤括弧にも対応。</p>

<p><code>ruby-mode</code>はこの挙動を上書きしてるので殴り殺したくなります。</p>

<h2><code>subword-mode</code></h2>

<p>私はキャメルケースが嫌いという超個人的理由で使ってないのですが、キャメルケースがコーディング規約な言語を使う人には便利でしょう。キャメルケースの1こぶを1単語と見做します。例えば"SubWord"は"Sub" &ldquo;Word"と認識されます。</p>

<pre><code>-!-SubWord 
</code></pre>

<p>で<code>M-f</code>(<code>forward-word</code>)すると通常は</p>

<pre><code>SubWord-!-
</code></pre>

<p>となりますが<code>subword-mode</code>内だと</p>

<pre><code>Sub-!-Word
</code></pre>

<p>となります。その他word系の操作が全部こぶ単位になります。</p>

<p>因みにモードラインの表示が", &ldquo;と、微妙な感じです。</p>

<h2><code>superword-mode</code></h2>

<p><code>subword-mode</code>の逆です。Lispの"this-is-a-symbol"といったシンボルが"this" &ldquo;-is&rdquo; &ldquo;-a&rdquo; &ldquo;-symbol"と認識されていたのが"this-is-a-symbol"と認識されます。</p>

<p>因みにモードラインの表示は &ldquo;$^2$&rdquo; です。</p>

<h2><code>C-x C-u</code>(<code>upcase-region</code>)</h2>

<p>リージョンを選択した状態で使うとリージョンを大文字にしてくれます。
これを使ったTipsです。</p>

<p>シチュエーションは全部大文字の単語(定数とかで良く出てくる)を入力したいが、Caps Lockは既にCtrlにしてあるので使えないって状態です。<br/>
先ず、<code>C-@</code>します。そして目的の単語を小文字のまま入力します。そして<code>C-x C-u</code>します。すると全て大文字になります。便利。<code>C-x C-l</code>(<code>lowercase-region</code>)でも同じこと出来ますが、使いたいシチュエーションは少ないでしょう。</p>

<p>尚、このコマンドはデフォルトで無効になっているので普段使いするには一回使ってダイアログを出さないようにするか<code>init.el</code>に
<code>lisp
(put 'upcase-region 'disabled nil)
</code>
を追加しておく必要があります。</p>

<h2><code>M-- M-u</code>(<code>upcase-word</code>)</h2>

<p><code>upcase-word</code>はカーソルの次の単語を大文字にしますが、負の前置引数を与えると直前の単語を大文字にしてくれます。ちょっと押し辛いですが一応覚えておきましょう。<code>M-- M-l</code>(<code>capitalize-word</code>)もそれなりに使えるかもしれません。</p>

<h1>complete系</h1>

<p><code>icomplete-mode</code>するとミニバッファでの入力時に補完候補が随時表示されますが、実はあの候補に色々操作出来るのです。</p>

<h2><code>M-p</code> / <code>M-n</code></h2>

<p>ヒストリを辿れます</p>

<h2><code>C-j</code></h2>

<p>先頭の候補に決定します。</p>

<h2><code>C-,</code> / <code>C-.</code></h2>

<p>候補を後/先に送ります。キーボードを見て&lt; / &gt;を押せば良いので簡単ですね。</p>

<h2><code>C-M-i</code></h2>

<p>先頭の候補を補完します。続けて<code>C-M-i</code>すると順次次候補になります。</p>

<h2><code>C-r</code></h2>

<p>ヒストリを検索します。</p>

<h2><code>C-s</code></h2>

<p>ミニバッファ内を前方検索します。あまり需要なさそうですね。</p>

<h1>isearch</h1>

<p>isearchはカーソルをバッファに残したままミニバッファを編集するのでキーバインドが特殊です。</p>

<h2><code>C-s</code>(<code>isearch-repeat-forward</code>)</h2>

<p>検索文字列が空の状態で<code>C-s</code>すると前回の検索文字列で検索します。</p>

<h2><code>C-j</code>(<code>isearch-printing-char</code>)</h2>

<p>RETが決定に使われてるので改行はC-jになります。</p>

<h2><code>C-w</code>(<code>isearch-yank-word-or-char</code>)</h2>

<p>カーソル下の単語又は文字を検索文字列にします。連続して押すと範囲を広げます。</p>

<h2><code>C-M-w</code>(<code>isearch-del-char</code>)</h2>

<p>1文字削除します。<code>DEL</code>(<code>isearch-delete-char</code>)とは違って削除してもバッファのポイントは戻りません。</p>

<h2><code>C-M-y</code>(<code>isearch-yank-char</code>)</h2>

<p>カーソル下の文字を検索文字列に足します。</p>

<h2><code>M-s C-e</code>(<code>isearch-yank-line</code>)</h2>

<p>カーソルから行末までを検索文字列にします。</p>

<h2><code>M-s</code>(<code>isearch-toggle-</code>)系</h2>

<p>isearchには実は文字列検索だけでなく、さまざまな検索方法があります。
<code>M-s _</code>(<code>isearch-toggle-symbol</code>)、<code>M-s c</code>(<code>isearch-toggle-case-fold</code>)、<code>M-s r</code>(<code>isearch-toggle-regexp</code>)、<code>M-s w</code>(<code>isearch-toggle-word</code>)、あたりを覚えておくと良いでしょう。</p>

<h1>バッファ/ウィンドウ系</h1>

<h2>split-threshold</h2>

<p>Emacsはデフォルトの状態では何かしらのウィンドウを分割するアクション(e.g. <code>list-buffers</code>)でウィンドウを上下に分割します。しかしワイドディスプレイを使っていると左右に分割して欲しいものです。そこで、この設定です。
<code>lisp
(setq split-height-threshold nil)
(setq split-width-threshold 100)
</code>
この設定で、幅が100桁以上なら左右、100桁未満なら上下に分割するようになります。100という数字は私が試行錯誤して出した最適解です。<code>split-height-threshold</code>と<code>split-width-threshold</code>を同時に設定したら先に<code>split-height-threshold</code>が判定されるようです。</p>

<h2><code>C-x 4</code>(<code>-other-window</code>)系</h2>

<p>ウィンドウを分割して隣のウィンドウに別のファイルを開きたい、あるいは既に分割してある隣のウィンドウに別のバッファを持ってきたいといったときに使うのが<code>C-x 4</code>(<code>-other-window</code>)系のコマンドです。<code>C-x 4 C-f</code>(<code>find-file-other-window</code>)、<code>C-x 4 b</code>(<code>switch-to-buffer-other-window</code>)、<code>C-x 4 0</code>(<code>kill-buffer-and-window</code>)あたりを覚えておけば良いでしょう。詳しくは<code>C-x 4 C-h</code>すると見れます。</p>

<p>似たようなのに、<code>C-x 5</code>(<code>-other-frame</code>)系のコマンドがありますが、私はEmacsのフレームを2つ以上出したいという状況に遭遇したことがないので省略します。</p>

<h2><code>find-alternate-file</code></h2>

<p>ほぼ<code>find-file</code>と同じ挙動ですが、現在のバッファをkillしてから新たなファイルを開きます。あるファイルを開こうとして間違ったファイルを開いてしまったときに使います(バッファの内容が空なので間違ったことが直ぐ分かる)。地味に便利なのですがデフォルトでキーが割り当てられていません。<code>C-x C-a</code>あたりが妥当でしょうか。</p>

<h1>rectangle(矩形選択)系</h1>

<p>最近機能が強化されてるrectangle系です。プリフィクスが<code>C-x r</code>と押し辛いのが難点ですが、使用頻度が高い訳ではないのでまあ妥当でしょう。</p>

<p>region-rectangleはカーソルとマークで成す長方形を範囲とします。
<code>
ab-!-cdefg
hijklmn
opqrs-¡-tu
</code>
のとき、
<code>
cde
jkl
qrs
</code>
がregion-rectangleに入ります。</p>

<p>しかしこれだと分り辛いものです。そこで、最近<code>C-x SPC</code>でregion-rectangleを視覚表示出来るようになりました。るびきちさんの本に載ってる<code>sense-region</code>に近いです。</p>

<h2><code>C-x r k</code>(<code>kill-rectangle</code>) / <code>C-x r d</code>(<code>delete-rectangle</code>) / <code>C-x r M-w</code>(<code>copy-rectangle-as-kill</code>)</h2>

<p>名前のままですね。<code>kill-rectangle</code>や<code>copy-rectangle-as-kill</code>が保存するkill-ringは通常のkill-ringとは異なります。</p>

<p>region-rectangleを視覚表示した状態で<code>C-w</code>すると<code>kill-rectangle</code>になるようです(他のコマンドは未確認)</p>

<h2><code>C-x r y</code>(<code>yank-rectangle</code>)</h2>

<p><code>kill-rectangle</code>や<code>copy-rectangle-as-kill</code>が保存したものを吐きます。どのように挿入されるかというと、<br/>
rectangleのkill-ringが
<code>
cde
jkl
qrs
</code>
で、バッファが
<code>
-!-foo
bar
baz
</code>
のとき、<code>C-x r y</code>すると
<code>
cdefoo
jklbar
qrs-!-baz
</code>
となります。</p>

<h2><code>C-x r t</code>(<code>string-rectangle</code>)</h2>

<p>rectangle-regionを文字列で置換します。ちょっと実用的な例を出しましょうかね。</p>

<p>バッファが
<code>C
pic_-¡-list_first(pic_state *);
pic_list_second(pic_state *);
pic_list-!-_third(pic_state *);
</code>
で<code>C-x r t RET vector</code>すると
<code>C
pic_vector_first(pic_state *);
pic_vector_second(pic_state *);
pic_vector_third(pic_state *);
</code>
となります。最近プレビュー機能が入ったので入力しながらリアルタイムでバッファが書き換わります。最小設定主義のemacsにしては珍しい変更ですね。</p>

<p>尚、幅0のregion-rectangleに使うとプリフィクスを付けられることも覚えておきましょう。</p>

<p><code>
-¡-This sentence is
-!-a quotation
</code>
に<code>C-x r t RET &gt;</code>すると
```</p>

<blockquote><p>This sentence is
a quotation.
```
と出来ます。</p></blockquote>

<h1>register系</h1>

<p>register系も<code>C-x r</code>のブリフィクスを持ちます。非常に高機能なのに押し辛く、rectangleと紛らわしいキーバインドなのは残念です。</p>

<p>registerの概念は分り辛いのですが、「何でも保存出来る箱」で、しかも「キー1つにつき箱一つ」です。viの名前付きバッファと似ていますが何でも保存出来る点で異なります。</p>

<p>それぞれの機能を見てちょっと自分で試してみて理解して下さい。</p>

<h2><code>C-x r SPC</code>(<code>point-to-register</code>)</h2>

<p>レジスタにポイントを登録します。<code>C-x r C-SPC</code>でも<code>C-x r C-@</code>でも同じです。</p>

<p><code>C-x r SPC</code>すると"Point to Register: &ldquo;とプロンプトが出るので、現在のポイントを登録させたいレジスタを選びます。レジスタを選ぶというのは好きなキーを押せばよいです。私は考えるのが面倒なのでaから順番に使っていってます。</p>

<p>これだけだと分かりにくいので次のコマンドも参考にして下さい。</p>

<h2><code>C-x r j</code>(<code>jump-to-register</code>)</h2>

<p><code>point-to-register</code>でレジスタに登録したポイントに飛びます。例えばaレジスタにポイントを登録したなら<code>C-x r j RET a</code>でそこに飛べます。最近、現在登録されてるレジスタ一覧が出るようになったので然程迷わないかと思います。</p>

<h2><code>C-x r x</code>(<code>copy-to-register</code>)</h2>

<p>レジスタに選択範囲の文字列を登録します。<code>C-x r s</code>でも同じです。</p>

<p>rectangleと同じプリフィクスを使っているがために非常に覚え辛いキーバインドになってしまっています。しかもkill-ringとの差別化がイマイチ分からないので需要なさそうですね。</p>

<h2><code>C-x r r</code>(<code>copy-rectangle-to-register</code>)</h2>

<p>region-rectangleをレジスタに登録します。</p>

<h2><code>C-x r i</code>(<code>insert-register</code>)</h2>

<p>レジスタに登録した文字列/rectangle/数字をバッファに挿入します。<code>C-x r g</code>でも同じです。</p>

<p>ポイントを挿入しようとすると数字が入るようです(ポイントは内部的には数字)。</p>

<h2><code>C-x r n</code>(<code>number-to-register</code>)</h2>

<p>レジスタに数字を登録します。登録した数字は<code>C-x r +</code>(<code>increment-regiser</code>)で増やしたり(負の前置引数を与えれば減らすことも可能)<code>insert-register</code>でバッファに挿入することも可能。キーボードマクロなんかで役に立つのかな？</p>

<h2><code>C-x r w</code>(<code>window-configuration-to-register</code>)</h2>

<p>現在のフレームのwindow-configuration(ウィンドウの分割や表示されるバッファ)をレジスタに登録します。復元は<code>C-x r j</code>(<code>jump-to-register</code>)です。</p>

<p>同様の機能を提供するために数々のプラグインが作られてきましたが標準で提供されることになりました。</p>

<p>これと次の<code>frameset-to-register</code>は最近入った機能だった気がします。</p>

<h2><code>C-x r f</code>(<code>frameset-to-register</code>)</h2>

<p>frameset(フレームの数や位置、サイズ、そしてそれぞれのフレームのwindow-configuration)をレジスタに登録します。復元は<code>C-x r j</code>(<code>jump-to-register</code>)です。</p>

<h2>蛇足</h2>

<p>キーは割り当てられてませんがキーボードマクロの保存/実行やレジスタにappend/prependするコマンドもあるようです。</p>

<p>同じ<code>C-x r</code>のプリフィクスの機能にブックマークがありますが、るびきちさんの本に載ってるので割愛します。</p>

<h1>vc(バージョン管理)系</h1>

<p>詳しい使い方は多数の記事があると思うのでそちらに任せるとして、よく使うものを紹介します。尚、るびきちさんの本の頃からは大分進化してるのでvcに関しては参考にしない方が良いかと思います。例えば<code>git init</code>相当をするコマンド(<code>vc-create-repo</code>)は追加されてます。その他mergeやpull/pushなども。</p>

<p>各vcsの対応状況は</p>

<blockquote><p>;; Supported version-control systems presently include CVS, RCS, GNU<br/>
;; Arch, Subversion, Bzr, Git, Mercurial, Monotone and SCCS<br/>
;; (or its free replacement, CSSC).</p></blockquote>

<p>とあります。かなり多いですね。というかこんなにvcsあったんですね。</p>

<p>私が最近gitしか使ってないので他のvcsでどうなるかは分かりません。一応vc.el自体vcsの差異を吸収するものなのですが、vcs固有の挙動もあるのです。</p>

<h2><code>C-x v =</code>(<code>vc-diff</code>)</h2>

<p><code>git diff &lt;バッファのファイル&gt;</code>相当です。大体、しばらく作業してそろそろコミットするかーって時に使います。表示されるバッファはdiff-modeになっているのでdiffの部分でRETすると変更箇所にジャンプ出来ます。</p>

<h2><code>C-x v l</code>(<code>vc-print-log</code>) / <code>C-x v L</code>(<code>vc-root-log</code>)</h2>

<p><code>C-x v l</code>(<code>vc-print-log</code>) で現在ファイルの、 <code>C-x v L</code>(<code>vc-root-log</code>) でバージョン管理下全体のログ(コミットグラフ)を見れます。TABでログ間を移動出来たりRETでログを展開したりDでそのログのdiffを見たり色々なことが出来ます。diffを表示させたら勿論RETで変更箇所に飛べます。変更履歴を追うときは圧倒的に便利。</p>

<p>私もそこまで深追いしてないのでlogバッファでの操作の調査は読者の課題とする。</p>

<h2><code>C-x v v</code>(<code>vc-next-action</code>)</h2>

<p>vcの中で一番有名なコマンドでしょうから詳細は省きます。私が強調したいのはコミットログ書くときのlog-editモードです。地味に機能強化されてます。<code>C-c C-d</code>(<code>log-edit-show-diff</code>)でdiffを表示したり<code>C-c C-e</code>(<code>vc-git-log-edit-toggle-amend</code>)でamendにしたり出来ます。詳しくは<code>C-c ?</code>(<code>log-edit-mode-help</code>)して下さい。</p>

<h2><code>C-x v d</code>(<code>vc-dir</code>)</h2>

<p>ディレクトリ単位での機能を使えます。というかファイル単位でない機能(つまりvcsの多くの機能)を使えます。最近はvcを使うときはこれがメインになってます。色々機能があるので<code>&lt;f1&gt; b</code>(<code>describe-bindings</code>)して確認して下さい。</p>

<h2><code>C-x v u</code>(<code>vc-revert</code>)</h2>

<p>これは逆に使ってはいけないコマンドです。バッファのファイルのみをリバートする(<code>git checkout -- &lt;バッファのファイル&gt;</code>相当)と思いきや、<code>git reset --hard</code>するようです。no more被害者。</p>

<h1>view-mode</h1>

<p>かなりキーバインドが特殊ですが割と便利な機能です。ここで紹介したもの以外にもキーはバインドされてますが非自明なのは大体こんなもんでしょう。</p>

<h2><code>RET</code>(<code>View-scroll-line-forward</code>) / <code>y</code>(<code>View-scroll-line-backward</code>)</h2>

<p>上下に1行スクロールします。ありそうで他にない機能です。</p>

<h2><code>/</code>(<code>View-search-regexp-forward</code>) / <code>\</code>(<code>View-search-regexp-backward</code>)</h2>

<p>まさかのviバインド。ちゃんと<code>n</code>(<code>View-search-last-regexp-forward</code>)と<code>p</code>(<code>View-search-last-regexp-backward</code>)も用意されてます。</p>

<h2><code>s</code>(<code>isearch-forward</code>) / <code>r</code> (<code>isearch-backward</code>)</h2>

<p><code>C-</code>がなくなっただけですね。他にも<code>C-</code>がなくなっただけのコマンドはいっぱいありますが<code>/</code>/<code>\</code>との比較で出しました。</p>

<h2><code>m</code>(<code>point-to-register</code>) / <code>'</code>(<code>register-to-point</code>)</h2>

<p><code>m</code>でマークして<code>'</code>でジャンプです。</p>

<h2>やめる系</h2>

<p>なぜか一杯あります。前提として、view-modeは別のファイルから「view-modeで(時に別ウィンドウで)ファイルを開く」系のコマンドで呼ばれることが多いというのがあります。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> コマンド                   </th>
<th align="left"> 説明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> <code>e</code>(<code>View-exit</code>)           </td>
<td align="left"> view-modeを抜ける。</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>E</code>(<code>View-exit-and-edit</code>)  </td>
<td align="left"> view-modeを抜けてバッファを編集出来るようにする。つまり、read-only-modeも抜ける。</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>c</code>(<code>View-leave</code>)          </td>
<td align="left"> view-modeを抜けてバッファを切り替えるがバッファはkillしない。</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>C</code>(<code>View-kill-and-leave</code>) </td>
<td align="left"> view-modeを抜けてバッファをkillして以前のバッファに切り替る。</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>q</code>(<code>View-quit</code>)           </td>
<td align="left"> view-modeを抜けてウィンドウ内の状態を元に戻し、フォーカスも戻す。大抵バッファをkillする。</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>Q</code>(<code>View-quit-all</code>)       </td>
<td align="left"> view-modeを抜けてウィンドウ構成を元に戻す。大抵バッファをkillする。</td>
</tr>
</tbody>
</table>


<p>うん。覚えられね。</p>

<h1>dired系</h1>

<p>便利なのに情報が少ないdired系。私はUbuntuのUnityを捨ててStumpwmを使っているのでファイルエクスプローラは専らEmacsですからよく使います。<a href="http://localhost:4000/blog/2013/10/04/emacs-dired/">以前のエントリ</a>以外の便利機能を紹介します。</p>

<p>因みに呆れるほどキーがバインドされてるのでここで紹介するのはほんの一部です。画像のサムネイル関連の機能なんかもあります。</p>

<h2><code>+</code>(<code>dired-create-directory</code>)</h2>

<p>ディレクトリを作ります。</p>

<h2><code>(</code>(<code>dired-hide-ditail-mode</code>)</h2>

<p>初期状態では<code>ls -l</code>っぽい内容が表示されてますが<code>ls</code>に変更出来ます。</p>

<h2><code>v</code>(<code>dired-view-file</code>)</h2>

<p>ポイント下のファイルをview-modeで開きます。view-modeでは<code>q</code>でバッファを閉じれるので、あるディレクトリ下のファイルを連続して読みたいときに便利です。</p>

<h2><code>o</code>(<code>dired-find-file-other-window</code>)</h2>

<p>別ウィンドウでファイルを開きます。</p>

<h2><code>C-o</code>(<code>dired-display-file</code>)</h2>

<p>別ウィンドウでファイルを開きますが、フォーカスは移りません。</p>

<p>diredに限らず、ファイルへのリンクをリスト表示するバッファでは大抵<code>v</code>と<code>o</code>と<code>C-o</code>が使えます。</p>

<h2><code>i</code>(<code>dired-maybe-insert-subdir</code>)</h2>

<p>バッファの下にポイント下のディレクトリの内容を追加します。ツリー表示にする機能はないようです。</p>

<h2><code>%</code>(<code>dired--regexp</code>)系</h2>

<p><code>% C</code>(<code>dired-do-copy-regexp</code>)など色々あるのですがとりあえず使いそうなのは<code>% g</code>(<code>dired-mark-files-containing-regexp</code>)と<code>% m</code>(<code>dired-mark-files-regexp</code>)ですかね。</p>

<p>拡張子でマークするコマンドがあった気がしたのですが見当りませんでした。</p>

<h2>検索/置換系</h2>

<p>これも色々ある上にキーバインドが覚えづらいです。ポイント下又はマークしたファイル全てに操作を行います。キーを覚えるより<code>M-x</code>で実行した方が速そうですね。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> キー          </th>
<th align="left"> コマンド</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> <code>Q</code>           </td>
<td align="left"> <code>dired-do-query-replace-regexp</code></td>
</tr>
<tr>
<td></td>
<td align="left"> <code>M-s a C-s</code>   </td>
<td align="left"> <code>dired-do-isearch</code></td>
</tr>
<tr>
<td></td>
<td align="left"> <code>M-s a C-M-s</code> </td>
<td align="left"> <code>dired-do-isearch-regexp</code></td>
</tr>
</tbody>
</table>


<h1>eww (Emacs Web WOWer)</h1>

<p>elispで書かれたブラウザ(正確にはWOWerらしい)です。レンダリングエンジンにはかつてgnusで使われて今は別プロジェクトになったshr.el(Simple HTML Renderer)が使われています。HTMLの他に簡単なCSSも理解します。</p>

<p>libxsltなどのSGML解析系のライブラリを有効にしてビルドしないと使えないのでEmacsを野良ビルドする人は要注意です。</p>

<h2><code>M-x eww</code></h2>

<p>URL又はキーワードで検索します。検索エンンジンは<code>eww-search-prefix</code>で制御出来ます。</p>

<p>googleで検索したかったら
<code>lisp
(setq-default eww-search-prefix "https://www.google.co.jp/search?q=")
</code>
です。</p>

<h2>キーバインド</h2>

<p>infoライクに設定されてます。そんなに多くないのですが、一部抜粋すると<code>n</code>(<code>eww-next-url</code>)、<code>p</code>(<code>eww-previous-url</code>)、<code>l</code>(<code>eww-back-url</code>)、<code>r</code>(<code>eww-forward-url</code>)、<code>H</code>(<code>eww-list-histories</code>)、<code>&amp;</code>(<code>eww-browse-with-external-browser</code>)、<code>b</code>(<code>eww-add-bookmark</code>)、<code>B</code>(<code>eww-list-bookmarks</code>)、<code>q</code>(<code>quit-window</code>)です。</p>

<p><code>n</code> / <code>p</code>と<code>l</code> / <code>r</code>の違いは、<code>l</code> / <code>r</code>はヒストリを辿る機能、<code>n</code> / <code>p</code>はヘッダに<code>&lt;link rel="Next/Prev" ...&gt;</code>が設定されているときにそれを辿ります。あまり馴染がないかもしれませんが広告料稼ぐためにページ分割しているサイトが多いので結構便利ですよ。</p>

<h1>newsticker</h1>

<p>最後に最近見付けたRSS/Atomリーダーの紹介です。</p>

<p>先ず、こんな感じの設定をします。ニュースサイトは自分の好きなものを選んで下さい。</p>

<p>```lisp
(setq-default newsticker-url-list &lsquo;((&ldquo;産経&rdquo; &ldquo;<a href="http://sankei.jp.msn.com/rss/news/points.xml">http://sankei.jp.msn.com/rss/news/points.xml</a>&rdquo;)</p>

<pre><code>                                ("朝日-IT/Sci" "http://rss.asahi.com/rss/asahi/science.rdf")
                                ("技術評論社" "http://rss.rssad.jp/rss/gihyo/feed/rss2?rss")
                                ("Planet Lisp" "http://planet.lisp.org/rss20.xml")
                                ("Hacker News" "https://news.ycombinator.com/rss")))
</code></pre>

<p>(setq-default newsticker-url-list-defaults</p>

<pre><code>          '(("LWN (Linux Weekly News)" "http://lwn.net/headlines/rss")))
</code></pre>

<p>(setq-default newsticker-retrieval-interval 0)
(setq newsticker-html-renderer #&lsquo;shr-render-region)
<code>``
で、</code>M-x newsticker-show-news`でニュースを取ってきてくれます。</p>

<p>3ペインの画面(treeview)になるかと思いますが、基本操作を覚えれば<code>C-x o</code>で移動する必要はありません。</p>

<h2><code>f</code>(<code>newsticker-treeview-next-feed</code>) / <code>F</code>(<code>newsticker-treeview-prev-feed</code>)</h2>

<p>ニュースサイト間を移動します。</p>

<h2><code>n</code>(<code>newsticker-treeview-next-item</code>) / <code>p</code>(<code>newsticker-treeview-prev-item</code>)</h2>

<p>ニュース間を移動します。</p>

<h2><code>SPC</code>(<code>newsticker-treeview-next-page</code>)</h2>

<p>ニュースのページを送ります。戻すキーは無いようです。</p>

<h2><code>v</code>(<code>newsticker-treeview-browse-url</code>)</h2>

<p>今開いているニュースをブラウザで開きます。RSSは概要しか送られてこないのでこの機能は必須ですね。</p>

<h2><code>q</code>(<code>newsticker-treeview-quit</code>)</h2>

<p>画面を閉じます。</p>

<h1>最後に</h1>

<p>いかがだったでしょうか。ちょっと長いので途中読み飛ばし気味だったかもしれませんが1つでも覚えていただけたら幸いです。</p>

<p>因みに、このエントリを書き始めたのは8/13だったのですが、あまりに長く、途中合宿を挟んだりしたので公開は8/20になってしまいました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[.emacsの整理をした話 + EmacsとViとShellとLispを悪魔合体させたら超絶便利だった]]></title>
    <link href="http://KeenS.github.io/blog/2013/12/13/dot-emacs-clean-up/"/>
    <updated>2013-12-13T02:55:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/12/13/dot-emacs-clean-up</id>
    <content type="html"><![CDATA[<p>やや長いタイトルですが・・・年末になって大掃除がやってきましたね。みなさんもそろそろ.emacsの大掃除をしましょう。</p>

<!-- more -->


<p>私の.emacsは元々1300行ちょいあってEmacsの起動に7~8秒(体感)かかってましたが大掃除&amp;高速化をした結果800行弱、起動に1秒(体感)ほどになったので整理の仕方を共有しますね。</p>

<p>前提ですが、私はinitローダーとかは使ってません。全部<code>init.el</code>に書いてます。で、機能毎にページを作って(<code>C-q C-l</code>)ます。ただ、それだけだと視認性が悪いので見出しとして<code>C-u C-u C-u ;</code>で<code>;</code>を64個挿入して次の行にコメントで<code>#</code>付きのタイトルを付けてます。</p>

<p>具体的には</p>

<p><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr>
<td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td>
<td class="code"><pre><code class="common-lisp"><span class="line"><span class="nv">^L</span>
</span><span class="line"><span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span><span class="line"><span class="c1">;; #Lisp</span>
</span></code></pre></td>
</tr></table></div></figure></p>

<p>こんな感じのものが機能毎に書かれてます。これで<code>C-s</code>や<code>M-x occur</code>でハッシュタグのように検索することも<code>C-v</code>でスクロールしていって目grepすることも<code>C-x ]</code>で機能毎にジャンプすることもできます。</p>

<h1>1. Emacsの最新版を使う</h1>

<p>結構重要です。「標準のやつだと欲いこの機能がないから拡張パッケージ入れた」なんてのも最新版では改善されていたりします。例えば私は<code>emacs-w3m</code>を使っていましたが、Emacsのmasterブランチには<code>eww</code>なるEmacs Lisp製のブラウザが入っているのでそれを使うようにしました。</p>

<p><s>ただ、これが絶対的正義かというとそうでもなく、パッケージで入れてない分
Ubuntuのインプットメソッドとの連携部分がなかったので<code>uim.el</code>を入れる
必要が出てきたりと、面倒な部分もありました。Emacs標準のインプットメソッドはどうにも使いものにならず、
<code>ddskk</code>もuim-skkとコンフリクトする(というか<code>C-j</code>上書きとかありえない)ので使いません。インプットメソッドの切り替え部分は</s></p>

<p><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr>
<td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td>
<td class="code"><pre><code class="common-lisp"><span class="line"><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&ldquo;&lt;hiragana-katakana&gt;&rdquo;</span><span class="p">)</span> <span class="nf">#&lsquo;</span><span class="nv">uim-mode</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&ldquo;&lt;zenkaku-hankaku&gt;&rdquo;</span><span class="p">)</span> <span class="nf">#&rsquo;</span><span class="nv">uim-mode</span><span class="p">)</span> <span class="p">(</span><span class="nv">autoload</span> <span class="nf">#&lsquo;</span><span class="nv">uim-mode</span> <span class="s">&ldquo;uim&rdquo;</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
</span></code></pre></td>
</tr></table></div></figure></p>

<p>になりました。</p>

<p>2013-12-16追記<br/>
これは私が<code>~/.Xresources</code>に<code>Emacs*useXIM: false</code>を書いていたのが原因でした。<code>Emacs*useXIM: true</code>に書き換え、<code>xrdb ~/.Xresources</code>すると直りました。</p>

<h1>2. 普段使わない設定は全部消す</h1>

<p>基本ですね。私は<code>summary-edit.el</code>だとか<code>multiverse.el</code>だとかるびきちさんの本を読んで便利そうだから入れたものの、結局使わなかったものの設定&amp;elispをごっそり削除。あとかなりの言語に対してデフォルトで<code>auto-mode-alist</code>が設定されていたので<code>auto-mode-alist</code>の設定も全部消して、必要になったら書き足すようにしました。</p>

<h1>3. 普段使っていても代替の効くものは削除</h1>

<p>これは高速化の意味と自分の環境に依存しない意味があります。最近、自分のラップトップ以外でもEmacsを触ることが多くあって、デフォルトのキーを上書きして使ってる部分で何度も誤操作したのでそれを減らす目的です。<code>bm.el</code>は<code>C-x r SPC</code>の<code>register</code>系や<code>C-x C-SPC</code>で対応(registerは覚えれば使い出がありそうなのでいつか解説書くかもです)、<code>open-junk-file.el</code>は<code>~/tmp</code>を作って対応、<code>recentf-ext.el</code>は<code>helm-file-buffers</code>だとか。</p>

<p>あと全て<code>helm.el</code>に置き換えて<code>helm.el</code>と<code>anything.el</code>が混在してる状態をどうにかしたかったのですが、<code>php-completion.el</code>かなにかが依存しててトドメを刺せませんでした。</p>

<p>あと、<code>viewer</code>の代替を探していたらタイトルにあるように悪魔合体が起きたので後で書きますね。</p>

<h1>4. できる限り標準のものを使う</h1>

<p>標準で提供されているパッケージは<code>autoload</code>が<code>emacs</code>バイナリに組込まれてる(と思う)ので起動時のオーバーヘッドはありません。<code>flymake.el</code>や<code>ruby-mode.el</code>が標準で提供されてるのに気付いたのでそれを使ったりなど。一度<code>(emacsroot)/lisp</code>以下を眺めてみることをお勧めします。結構発見があるものです。</p>

<h1>5.<code>autoload</code>を使う</h1>

<p><code>autoload</code>とはファイルの読み込みを必要になるまで遅らせる仕組みです。「必要になる」ってのはそのファイルで定義されている関数が呼ばれたときです。賢い<code>require</code>と思えば良いでしょう。</p>

<pre><code>(autoload #'関数名 "関数が呼ばれたときに読むファイル名" nil interactivep)
</code></pre>

<p>みたいに使います。<code>interactivep</code>の部分は<code>M-x</code>で呼ぶものなら<code>t</code>、そうでなければ<code>nil</code>です。<code>require</code>を<code>autoload</code>で書き換えていけば理論上起動時の読み込み0にできるのでかなり高速化できます。</p>

<p>が、実際は一々<code>autoload</code>書くのはしんどいので次です。</p>

<h1>6.できる限り<code>package.el</code>を使う</h1>

<p><code>package.el</code>は必要な関数の<code>autoload</code>を自動生成して読み込んでおいてくれるのでかなりの手間が省けます。そして<code>autoload</code>があるのに<code>require</code>してると折角の<code>package.el</code>の配慮が無駄になります。</p>

<p>自動生成された<code>autoload</code>は<code>elpa/パッケージのディレクトリ/パッケージ-autoloads.el</code>にあるので確認しながら<code>init.el</code>の邪魔なものを消していきます。これでかなり<code>init.el</code>の行数が減ります。今まで無駄な設定していたんだなと気付きます。</p>

<h1>7. <code>eval-after-load</code>を使う</h1>

<p>8割程の設定は<code>autoload</code>で対応できるのですが、踏み込んだ設定をしているとパッケージの内部の関数を使ってしまってどうしてもその式が評価される前にパッケージが読み込まれている必要があることがあります。</p>

<p>そんなときは<code>eval-after-load</code>を使います。名前のまんま、ロードした後で<code>eval</code>してくれます。</p>

<pre><code>(eval-after-load 'ファイル名
    '式)
</code></pre>

<p>の形で使います。複数の式を使いたい場合は<code>progn</code>を使って</p>

<pre><code>(eval-after-load 'ファイル名
    '(progn
         式1
         式2...))
</code></pre>

<p>のように使います。あるパッケージの拡張パッケージなんかもここで読むと良いかもしれません。</p>

<h1>8.その他</h1>

<p>メールクライアントを標準のものにしようとしましたが、<code>gnus.el</code>はちょっと受け付けなくてその他はimapを喋らないので断念。でも色々調べてたら<code>mew</code>より<code>wanderlust</code>の方が良いようなので使い初めました。表示が綺麗で良いですね。HTMLのレンダリングも<code>emacs-w3m</code>に頼らず標準の<code>shr.el</code>を使っているのも◎。</p>

<p>同じような経緯で<code>JDEE</code>をやめて<code>malabar.el</code>を使うようにしました。ただ、私は<code>maven</code>使いではないので微妙ではあります。まあ、そもそもプロジェクト単位でJavaを書くことがないってのもあるんですが。Androidのスケルトンがantなのでantでできたら嬉しいなーって。</p>

<h1>EmacsとViとShellとLispを悪魔合体させた話</h1>

<p>私はEmacsの狂信者ですが読み専のときはちょいちょいviを使うこともあります。片手で操作できるのは便利です。Emacsで読み専といえば<code>view-mode</code>です。そこでもhjklを使うべく<code>view-mode-map</code>に手を加えてましたが、大掃除ということで全部削除。</p>

<p>その後で<code>emacsroot/lisp/emulate/</code>以下を読んでいるとなんかviのエミュレーターが3つも見付かりました。<code>vi.el</code>、<code>vip.el</code>、<code>viper.el</code>です。後者になるほどviとの互換性が高くなります。とりあえずは<code>hjkl</code>が使えれば良いので<code>vi.el</code>を使ってみたところ、ん〜…といったところ。<code>vip.el</code>と試して結局<code>viper.el</code>に落ち着きました。</p>

<pre><code>(global-set-key (kbd "C-x C-q") #'(lambda ()
                    (interactive)
                    (toggle-viper-mode)
                    (force-mode-line-update)))
</code></pre>

<p>設定はこんな感じです。<code>toggle-viper-mode</code>してもモードラインの表示が変わらないことがあったので<code>force-mode-line-update</code>を加えました。</p>

<p><code>viper.el</code>は単なるviのエミュレートだけではなく、Levelに応じて良い感じにemacsと悪魔合体してくれます。私は最高レベルの5にしました。”C-x C-s”など基本的なコマンドはそのまま使えるようになってます。<code>:</code>で始まるvi(ex)のコマンドも使えます。<code>C-z</code>でemacs&lt;–>viを切り替えたり。非常に便利です。</p>

<p>尚、私はvi使いであってvim使いではないのでevilは使いません。</p>

<p>もう一つ、shellの話。今までは<code>multiterm</code> × <code>zsh</code>な感じでしたが、「できる限り標準のものを使う」方針で<code>eshell</code>に切り替えました。<code>eshell</code>はEmacs Lispで書かれたshellです。これが思った以上に便利です。るびきちさんの本では標準出力とエラー出力の切り分けができてないと書かれてましたがそれは修正されてるようです。</p>

<p>あとは<code>/dev/kill</code>だとか<code>&gt;&gt;&gt;</code>だとかバッファへのリダイレクトだとか<code>grep</code>の上書きだとか色々楽しい拡張もあるのですが、一番は<code>eshell</code>がLispであること。<code>eshell</code>上で任意のEmacs Lisp式を実行できます。最近Emacs LispやLispに精通してきたので非常に有り難いです。<br/>
それにファイルを開くときもその後で同じディレクトリのファイルを開くことが多いので一旦 <code>cd</code>してから<code>find-file</code>をするとアクセスし易くて捗ります。もう起動時に<code>eshell</code>が立ち上がるようにして、基本そこから操作するようにしてます。guakeもそんなに使わなくなりました。他の環境でも使えるので安心して依存できます。</p>

<p>で、ファイルを開くときはどうしてるかというと実はemacsの<code>find-file</code>ではなくviの<code>:e file-name</code>です。Emacs上でLispで出来たShellを使いつつviを動かしてます。かなり人を選びますが「EmacsのヘビーユーザーでLispに精通しててviを便利だと思ってる人」は試してみてはいかがでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UbuntuでEmacsからGPGを透過的に扱う]]></title>
    <link href="http://KeenS.github.io/blog/2013/12/04/emacs-gpg/"/>
    <updated>2013-12-04T22:52:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/12/04/emacs-gpg</id>
    <content type="html"><![CDATA[<p>暗号化といえばGPGですがEmacsからGPGで暗号化されたファイルを編集しようとすると毎回パスワードを訊かれて鬱陶しいです。これはキーリングを登録することで解決できました。</p>

<!-- more -->


<h2>Step1 Keyringに登録する</h2>

<p>Dashboardから[key]で検索すると[パスワードと鍵]が見付かります。左上の[+]で新たにキーリングを追加します。</p>

<p><img src="/images/2013-12-04-1.png" title="keyring" alt="こんな感じ" /></p>

<p>GPGを選択します</p>

<p><img src="/images/2013-12-04-2.png" title="Selecting GPG" alt="こんな感じ" /></p>

<p>必要な情報を入力します。このメールアドレスは実在しなくても作れますが、ブルートフォースかけられたときの警告とかに使われそうなので実在した方が良い気がします。とりあえず後で使うので覚えておいて下さい。</p>

<p><img src="/images/2013-12-04-3.png" title="'Input info &quot;こんな感じ&quot;" alt="'Input info &quot;こんな感じ&quot;" /></p>

<p>あとはパスワードのプロンプトが出るので入力して、エントロピーを発生させたら終わりです。</p>

<h2>Step2 ファイルを準備する</h2>

<p>ここが肝です。ファイルの先頭に</p>

<pre><code>-*- epa-file-encrypt-to: (my@mailaddress) -*-
</code></pre>

<p>を挿入します。既存の暗号化されたファイルでも同じです。</p>

<h2>Step3 暗号化する</h2>

<p><code>M-x epa-encrypt-file</code>で暗号化できます。暗号化するファイル名を指定したらキーリングを選べます</p>

<p><img src="/images/2013-12-04-4.png" title="Selecting GPG" alt="こんな感じ" /></p>

<h2>Step4 編集する</h2>

<p>あとはもう透過的に使えます。でもなんか実験してたらファイル保存できなかった。先にGPGで暗号化してたやつはできたのに。要調査です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ここ１ヶ月くらいの近況]]></title>
    <link href="http://KeenS.github.io/blog/2013/11/13/what-recent/"/>
    <updated>2013-11-13T21:20:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/11/13/what-recent</id>
    <content type="html"><![CDATA[<p> #isucon 参戦記がフォロワーの多い@tagomorisさんとか@nitro_idiotさんとかにツイートされて普段の数十倍のアクセスが来てテンション上がったので近況書きますね。</p>

<!-- more -->


<h2>isuconの勉強</h2>

<p>件の記事でも書いてますけどMySQLとNginXとCapistranoの勉強しました。SQLって書けると案外楽しいですね。あとN+1問題を学んだり、<code>IF EXISTS TRRIGER</code>的な文がなくて殺そうかと思ったり。</p>

<p>NginXはキャッシュとかですね。キャッシュキーに<code>$cookie_isucon_session</code>とか入れてログインしてるユーザーが来ても対応できたので良かったです（小並感</p>

<p>Capistranoはどうせだからと3.0を使ったのですが調べても2.x時代の情報ばっかり引っ掛かって苦労しました。その代わり、isucon本戦では複数サーバーへのデプロイ機能を存分に使わせて頂きました。ほぼログインしなくても問題ないですね。</p>

<p>例えば</p>

<p><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr>
<td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td>
<td class="code"><pre><code class="ruby"><span class="line"><span class="n">set</span> <span class="ss">:application</span><span class="p">,</span> <span class="s1">&lsquo;my app&rsquo;</span>
</span><span class="line"><span class="n">set</span> <span class="ss">:repo_url</span><span class="p">,</span> <span class="s1">&lsquo;git@bitbucket.org:me/myrepo.git&rsquo;</span>
</span><span class="line"><span class="n">set</span> <span class="ss">:deploy_to</span><span class="p">,</span> <span class="s1">&lsquo;/home/me/app&rsquo;</span>
</span><span class="line"><span class="n">set</span> <span class="ss">:scm</span><span class="p">,</span> <span class="ss">:git</span>
</span><span class="line"><span class="n">set</span> <span class="ss">:deploy_via</span><span class="p">,</span> <span class="ss">:remote_cache</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="n">namespace</span> <span class="ss">:nginx</span> <span class="k">do</span>
</span><span class="line"> <span class="n">task</span> <span class="ss">:reload</span> <span class="k">do</span>
</span><span class="line"> <span class="n">on</span> <span class="n">roles</span><span class="p">(</span><span class="ss">:web</span><span class="p">)</span> <span class="k">do</span>
</span><span class="line"> <span class="n">execute</span> <span class="ss">:sudo</span><span class="p">,</span> <span class="s1">&lsquo;service nginx reload&rsquo;</span>
</span><span class="line"> <span class="k">end</span>
</span><span class="line"> <span class="k">end</span>
</span><span class="line">
</span><span class="line"> <span class="n">task</span> <span class="ss">:restart</span> <span class="k">do</span>
</span><span class="line"> <span class="n">on</span> <span class="n">roles</span><span class="p">(</span><span class="ss">:web</span><span class="p">)</span> <span class="k">do</span>
</span><span class="line"> <span class="n">execute</span> <span class="ss">:sudo</span><span class="p">,</span> <span class="s1">&lsquo;service nginx restart&rsquo;</span>
</span><span class="line"> <span class="k">end</span>
</span><span class="line"> <span class="k">end</span>
</span><span class="line">
</span><span class="line"> <span class="n">task</span> <span class="ss">:start</span> <span class="k">do</span>
</span><span class="line"> <span class="n">on</span> <span class="n">roles</span><span class="p">(</span><span class="ss">:web</span><span class="p">)</span> <span class="k">do</span>
</span><span class="line"> <span class="n">execute</span> <span class="ss">:sudo</span><span class="p">,</span> <span class="s1">&lsquo;service nginx start&rsquo;</span>
</span><span class="line"> <span class="k">end</span>
</span><span class="line"> <span class="k">end</span>
</span><span class="line"><span class="k">end</span>
</span></code></pre></td>
</tr></table></div></figure></p>

<p>こんな感じです。で、もう一つ</p>

<p><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr>
<td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td>
<td class="code"><pre><code class="ruby"><span class="line"><span class="n">set</span> <span class="ss">:stage</span><span class="p">,</span> <span class="ss">:production</span>
</span><span class="line"><span class="n">server</span> <span class="s1">&lsquo;123.4.5.67&rsquo;</span><span class="p">,</span> <span class="ss">user</span><span class="p">:</span> <span class="s1">&lsquo;me&rsquo;</span><span class="p">,</span> <span class="ss">roles</span><span class="p">:</span> <span class="s1">&lsquo;web&rsquo;</span>
</span><span class="line"><span class="n">server</span> <span class="s1">&lsquo;123.4.5.68&rsquo;</span><span class="p">,</span> <span class="ss">user</span><span class="p">:</span> <span class="s1">&lsquo;me&rsquo;</span><span class="p">,</span> <span class="ss">roles</span><span class="p">:</span> <span class="s1">&lsquo;web&rsquo;</span>
</span><span class="line"><span class="n">server</span> <span class="s1">&lsquo;123.4.5.69&rsquo;</span><span class="p">,</span> <span class="ss">user</span><span class="p">:</span> <span class="s1">&lsquo;me&rsquo;</span><span class="p">,</span> <span class="ss">roles</span><span class="p">:</span> <span class="s1">&lsquo;web&rsquo;</span>
</span><span class="line"><span class="n">set</span> <span class="ss">:ssh_options</span><span class="p">,</span> <span class="p">{</span>
</span><span class="line"> <span class="ss">keys</span><span class="p">:</span> <span class="sx">%w(~/.ssh/id_rsa)</span><span class="p">,</span>
</span><span class="line"> <span class="n">forward_agent</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span>
</span><span class="line"> <span class="n">auth_methods</span><span class="p">:</span> <span class="sx">%w(publickey)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td>
</tr></table></div></figure></p>

<p>を書いておけばこの3台のサーバーに一斉にデプロイしてくれます。(上の例だとnginxですが、まあいいでしょう。)</p>

<h2>Shibuya.lisp</h2>

<p>Lisp Meet Up #10で発表してきました。内容は<code>fluentd</code>をCommon Lispから使う話。<br/>
スライド</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/27444839" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe>


<p> <strong><a href="https://www.slideshare.net/blackenedgold/common-lisp-27444839" title="Common Lisp でビッグデータを作ろう">Common Lisp でビッグデータを作ろう</a></strong> from <strong><a href="http://www.slideshare.net/blackenedgold">blackenedgold</a></strong></p>

<p>Ustreamは見つかりませんでした。てへペロ</p>

<p>恐らく、<code>Log4CL</code>はやりたいことと目的が違いますね。全く別のロギングフレームワークを作るのが良さげな気がします。isuconの懇親会で開発者の@tagomorisさんにアドバイスも頂きましたし作るかもしれません。</p>

<h2>mpd</h2>

<p><a href="/blog/2013/09/29/mplayer/">以前、mplayer2が正常に動作しないとかぼやいて</a>ましたが、結局あきらめました。で、代わりに <a href="http://www.musicpd.org/">Music Player Daemon(MPD)</a>なるものを見付けて、しかもRaspberry Piで動き、iPod/Androidから操作できるとのことで、導入しました。</p>

<p>MPDはまさしくRaspberry Piのような機器向で、音楽を鳴らすサーバーと操作するクライアントが完全に分かれてます。</p>

<pre><code>$ sudo apg-get install mpd mpc
</code></pre>

<p>とかでRSPiに入れた気がします。クライアントはAndroidは<code>MPDroid</code>、iPodは<code>MPoD</code>っていうアプリです。</p>

<p><code>scp</code>で手元の曲をRSPiコピーし、iPodから繋ぐも曲が見えない。色々試した結果、<code>scp</code>でコピーしたときにパーミッションの問題が出てたようなのでそこを解決したらちゃんと動きました。</p>

<p>動画(iPod)</p>

<iframe width="560" height="315" src="//www.youtube.com/embed/x5CWtXbCkqo" frameborder="0" allowfullscreen></iframe>


<p>黒ばっかで見づらくて申し訳ありません。iPodからではなくスピーカから音が出てるのが分かりますかね？思ったより音が入ってないので分りづらいですね（汗</p>

<h2>CIM</h2>

<p><a href="https://github.com/fukamachi/shelly/">Shelly</a>を使って <a href="https://gist.github.com/KeenS/7059301">Common Lispスクリプトをexecutableにしよう</a>ってのをやってましたが少しshellyが求めているのと違うようだったので「シェルスクリプトでshelly的な物を実装しよう！ついでにrvmみたいにバージョン管理できたら嬉しいな！！」って思い付きで <a href="https://github.com/KeenS/CIM">Common Lisp Implementation Manager(CIM)</a>を作り始めました。まだCLISP, ECL, GCLのインストールぐらいしかできてません。</p>

<p>初めてシェルスクリプトを書き、初めてBourne Shellを触り(普段はzsh)、早くも挫折しそうです。今めっちゃシェルスクリプトの勉強してます。目的はImplementationの管理じゃなくて統一インターフェースの<code>cl</code>コマンドなのにそこが全然進んでないですね。<code>ql</code>に至っては1行も書いてない。まあ、<code>cl</code>を使って書くつもりなので<code>cl</code>が出来ないことにはどうしようもないんですが。</p>

<p><code>syset</code>とかネーミングセンスが無かったり(発音しずらい。シセット…サイセットって読もうかな)ダウンロードしたアーカイブのチェックサムとか全く見てなかったり色々ツッコみたくなりますが温かい目で見て下さい。気に入ったらpull-reqとかして下さい。</p>

<h2>Octomacs</h2>

<p>Octomacsに一回pull-req送ってからコミッタ気取りのκeenですが、<code>octomacs-preview</code>と<code>octomacs-deploy</code>を実装しました。<code>C-u</code>をつけると<code>generate</code>が付いてきます。テストをしてない（できない？）+サーバーを殺す(<code>octomacs-preview-quit</code>とかの名前かなあ。現状は<code>*octomacs preview*</code>バッファを<code>kill-buffer</code>すればいい)コマンドを実装してないのでpull-reqは投げてませんが使ってみたい方は <a href="https://github.com/KeenS/octomacs">こちら</a>をどうぞ。まあ、今からpushするんですがね。ちゃんとこの記事も<code>octomacs-new-post</code>から始まり、<code>octomacs-preview</code>で確認しつつ<code>octomacs-deploy</code>でデプロイしました。あとは過去の記事を編集する<code>octomacs-edit</code>を実装すれば完璧ですね。</p>

<p>こんなかんじです。<code>CIM</code>がんばります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tiarraにercで接続したときの/loadの問題]]></title>
    <link href="http://KeenS.github.io/blog/2013/10/06/tiarra-erc/"/>
    <updated>2013-10-06T00:35:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/10/06/tiarra-erc</id>
    <content type="html"><![CDATA[<p><a href="http://www.clovery.jp/tiarra/">tiarra</a>に <a href="http://www.emacswiki.org/ERC">erc</a>で接続したときの/loadの問題。</p>

<!-- more -->


<p>tiarraは有名なircプロキシ。ercはEmacs上で動くircクライアント。これらを使っているとtiarraが自動でログインしてくれないのでおかしいなと思っていたらtiarraの自動ログインモジュールを有効にしていなかった模様。</p>

<p>書き換えていざ設定を反映しようとすると若干困りました。どこに<code>/load</code>と打てばいいんだろ。</p>

<p>最初に誘導されるバッファ(ircバッファ名がプロキシサーバー名になってるやつ)に<code>/load</code>と打つと</p>

<pre><code>ERC&gt; /load
Incorrect arguments. Usage:
/LOAD line
Load the script provided in the LINE.
If LINE continues beyond the file name, the rest of
it is put in a (local) variable `erc-script-args',
which can be used in Emacs Lisp scripts.


The optional FORCE argument is ignored here - you can't force loading
a script after exceeding the flood threshold.
</code></pre>

<p>ですって。ああ…。<code>/load</code>コマンドがercに食われてる…</p>

<p>流石に解決策あるだろって思って調べたら</p>

<pre><code>/quote load
</code></pre>

<p>だそうです。</p>

<pre><code>ERC&gt; /quote load
-192.168.1.4- *** Reloaded configuration file.
-192.168.1.4- *** Module Channel::Join::Connect will be loaded newly.
</code></pre>

<p>はい。ちゃんとloadしてくれました。</p>

<p>以上小ネタでした。</p>
]]></content>
  </entry>
  
</feed>
