<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>構文解析 on κeenのHappy Hacκing Blog</title>
    <link>//KeenS.github.io/categories/%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90/</link>
    <description>Recent content in 構文解析 on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 26 Jun 2018 16:02:24 +0900</lastBuildDate>
    
	<atom:link href="//KeenS.github.io/categories/%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>nom勘所</title>
      <link>//KeenS.github.io/slide/nomkandokoro/</link>
      <pubDate>Tue, 26 Jun 2018 16:02:24 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/nomkandokoro/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
nom   GitHub マクロベースのパーサコンビネータ ゼロコピー、速い、バイト指向  ===
nomの使い方   ドキュメントに大量にパーツがあるので分かりづらい 基本的なパーツは以下  named! - パーサを定義 do_parse! - 連接 alt(_complete)! - 選択 tag! - トークン map! - 型変換   1データ型1パーサくらいの感覚 あとは必要に応じて覚える  似たような実装を探して真似る    ===
例: 四則演算  まずは列挙型を定義
#[derive(Debug, Clone, PartialEq)]enum Expr{BinOp(BinOp),Number(Number),}===
例: 四則演算  対応するパーサをalt!で定義
named!(expr&amp;lt;&amp;amp;str,Expr&amp;gt;,alt_complete!(map!(binop,Expr::BinOp)|map!(number,Expr::Number)));===</description>
    </item>
    
    <item>
      <title>構文解析にまつわる小話たち</title>
      <link>//KeenS.github.io/slide/koubunkaisekiarekore/</link>
      <pubDate>Sat, 08 Aug 2015 04:16:50 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/koubunkaisekiarekore/</guid>
      <description>構文解析にまつわる小話たち  #peg_study
===
About Me   κeen @blackenedgold Github: KeenS サイバエージェントの新卒エンジニア Lisp, ML, Shell Scriptあたりを書きます  ===
ウォームアップ ===
構文解析はバッドノウハウ   プログラム言語を使っているなら既にパーサはある  文法も定義されてる   目の前のパーサを使え  パーサAPIがある言語もある(Lispとか)   そうでなくても内部DSLを考えろ  内部DSLで解決出来ないときだけ構文解析 ===    本質はAST   結局はASTになればどんな文法でも同じ 文法はただの外皮、欲しいのはAST シンタックスシュガーは飾り  DRY出来るなら別   S式を使え  ASTをそのまま書き下せる    ===
AST First   最初にASTを考える。そして文法を考える 何が欲しいのかイメージし易くなる 構文解析はAST生成の自動化。普段してないことを自動化するのは愚か。 早めに間違いに気付ける  +は二項演算子。じゃあ &amp;amp;&amp;amp; は？ = は？    Note: Lispだと+は関数、andはマクロ、setqはスペシャルフォーム</description>
    </item>
    
  </channel>
</rss>