<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: common lisp | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/common-lisp/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-12-01T00:51:12+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[require, ASDF, quicklispを正しく使う]]></title>
    <link href="http://KeenS.github.io/blog/2014/11/30/quicklisp/"/>
    <updated>2014-11-30T22:05:39+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/11/30/quicklisp</id>
    <content type="html"><![CDATA[<p>κeenです。最近のCommon Lispのパッケージ管理は<code>ql:quickload</code>しか知らないという方も多いのではないでしょうか。しかしそれだけでは機能が足りないこともあります。Common Lispには様々な管理システムがあるので整理しましょう。</p>

<!-- more -->


<h1><code>provide</code>, <code>require</code></h1>

<p>同じファイルを読み込まないための原始的なシステムです。Common Lispの標準の機能です。<code>(require 'foo)</code>がファイルをロードし、ロードされたファイル内で<code>(provide 'foo)</code>しておくと2回目以降の<code>(require 'foo')</code>はファイルを読まずにすぐさま返ります。</p>

<p>ここで問題なのが<code>require</code>がどこのファイルを捜しにいくかは処理系依存なところですね。なので生の<code>require</code>は使えないと思っておいた方が良いでしょう。</p>

<h1>ASDF 3</h1>

<p>Another Sysytem Defininion Facility。過去にはAnotherじゃないSysytem Defininion Facilityもあった模様。最新版は3系です。結構APIが変っているので必ず3の情報を捜しましょう。</p>

<p>この「System」というのが聞き慣れませんが、ASDFの<code>defsystem</code>で</p>

<ol>
<li>systemに含まれるファイルの定義</li>
<li>依存systemの記述</li>
<li>その他作者、ライセンス、バージョンなどの記述</li>
<li>systemのコンパイルやロード、テストなどの操作</li>
</ol>


<p>が可能です。ASDFはCにとってのmake + ldを標榜しています。Makefile的なものは(systemname).asdになります。</p>

<p><code>require</code>との統合もされており、ASDFを適切に設定することで<code>defsystem</code>されたsystemを<code>require</code>でロードすることが出来ます。このときASDFは処理系に依存せずにASDFのパスに従って.asdファイルを捜しにいきます。</p>

<p>また、ほとんどの処理系はASDFを標準添付していて、大抵<code>(require 'asdf)</code>すれば使えるようになっています。</p>

<p>尚、コンパイル後のファイルは処理系、バージョン毎に互換性がないので本来なら適切に管理する必要がありますが、ASDFが適切に~/.cache/common-lisp以下に管理してくれます。優秀ですね。</p>

<h1>quicklisp</h1>

<p>lispプロジェクトのインストーラと微妙にパッケージマネージャ的な役割をします。</p>

<p><a href="http://beta.quicklisp.org/quicklisp.lisp">http://beta.quicklisp.org/quicklisp.lisp</a> をダウンロードしてきてそのファイルを読み込んで<code>(quicklisp-quickstart:install)</code>すれば~/quicklisp/以下にquicklispがインストールされ、ロードされます。処理系を再起動したあとまたquicklispをロードするには~/quicklisp/setup.lispを<code>load</code>します。が、毎回それをやるのが面倒な人は<code>(ql:add-to-init-file)</code>しておけば処理系の初期化ファイルに~/quicklisp/setup.lispを読み込む処理が書き加えられます。</p>

<p>さて、このquicklispを扱う上で3つの概念を覚えておくと良いです。</p>

<p>dist
:    releaseの配布元。普通は'quicklisp'のみだがほかのdistを使うことも可能。自前のやつとか。新たなdistを追加したり削除したり出来る。gitのremoteをイメージすればよい。</p>

<p>release
:    quicklispがダウンロードしてくる単位。ライブラリの作者が登録するときの単位。複数のsystemをもつこともある。</p>

<p>system
:    ASDFのsystem。ユーザーが使うときの単位。</p>

<p>さて、quicklispを使うときは通常使いたいシステムを<code>ql:quickload</code>すればそのシステムと依存システムの含まれているリリースをダウンロード、展開、ロードまでしてくれます。</p>

<p>開発中はREPLを立ち上げているので「あ、このライブライリ使おう」と思ったら<code>ql:quickload</code>するだけで即座に使えるようになりますね。</p>

<p>quicklispのリリースは毎月下旬にアップデートされていて、毎月ちゃんと全てのライブラリが対応処理系で動くことがテストされています。なのでメンテナが居なくなったライブラリはドロップします。代わりにquicklispの作者がテスト出来ないライブラリは登録させてもらえなかったりします（cl-cudaとか）</p>

<h1>quicklispの問題</h1>

<p>既にCommon Lispのライブラリマネージャとしてデファクトスタンダード的位置を築きつつあるquicklispですが、私は結構不満があります。</p>

<ul>
<li>~/quicklisp/setup.lispを読み込むとquicklispの全てを読み込んでしまう: これには過去全てのバージョンのdistとreleaseとsystemのデータベース、HTTPクライアント、圧縮ファイルの解凍ライブラリなども含まれており、処理系の起動が非常に遅くなる</li>
<li>特にデータベースはファイルに書かれていても高速に読める形式なのに初期化時に毎回全ての内容をLispのハッシュに変換するという愚行をする。</li>
<li><code>(ql:add-to-init-file)</code>が推奨されているが、前述の通り処理系の起動が遅くなってしまう。特に、（インストーラではなく、インストール済みの）ライブラリマネージャとして使いたくてもインストーラの機能までロードしてしまう。結構メモリを食うしアプリケーションには要らない。</li>
<li>処理系に依っては初期化ファイルはlispファイルをスクリプトとして使うときは読み込まれないこともあるのでスクリプトには使えない。まあ、前述の通り使いたくもない。</li>
</ul>


<p>のでライブラリマネージャにはASDFが向いてるのですが、</p>

<ul>
<li>quicklispでインストールしたシステムはquicklispを一旦ロードするかASDFの設定をいじるかしなければASDFからは使えない</li>
<li>quicklispはシステムのダウンロード/インストールだけすれば良いものをロードまでする</li>
<li>要はASDFを隠す</li>
<li>じゃASDFのラッパーかというとロードしかせず、コンパイルやテストなどはしない</li>
</ul>


<p>など様々な問題があります。</p>

<p>一応quicklispの弁護をしておくと、Common Lispは他のスクリプト言語とはちょっと使い方が違って、</p>

<ul>
<li>初期化ファイルは大抵オレオレライブラリで埋め尽くされていてそもそも起動には時間がかかる</li>
<li>Emacsのように一度REPLを立ち上げたら滅多に落とさない</li>
<li>アプリケーションも基本的にはREPLの中で使う</li>
<li>起動時間を気にするなら初期化ファイルを全てロードした、コアファイルをダンプしておいて使う</li>
</ul>


<p>といった使い方をされることが多いのです。そのような人からしてみたら細々処理されるよりも起動時間とメモリは気にしないから速いやつをくれ、となるのです。</p>

<p>じゃあそれなりにCommon Lispを使う私が何故そうしないかというと</p>

<ul>
<li>立ち上げっぱなしというのが性に合わない。立ち上がっているものを見るとすぐに落としたくなる。EmacsのヘビーユーザーだがEmacsもすぐ落とす。</li>
<li>コマンドラインアプリケーションを作りたいため、起動時間が命になる。</li>
<li>私はSBCLの開発版を使っていて、コアファイルはすぐに無効になるためコアダンプはしない（意味がない）</li>
</ul>


<p>といった理由があります。これは初心者にも共通する部分があるんじゃないでしょうか。REPLを立ち上げっぱなしにはしないし「コアダンプ？なにそれ？エラー出してんじゃん」状態でしょう。</p>

<h1>ASDFを正しく使う</h1>

<p>ということでquicklispをあまり使わない方法を紹介します。</p>

<p>前述の通り、quicklispでインストールしたシステムはquicklispを一旦ロードするかasdfの設定をいじるかしなければasdfからは使えません。具体的に言うと、</p>

<ul>
<li>ASDFのデフォルトパスは~/common-lisp以下</li>
<li>quicklispのシステムのインストールパスは~/quicklisp/dists/(dist name)/software/以下</li>
</ul>


<p>なので~/quicklisp/dists/以下にパスを通します。少し無駄なディレクトリもパスに含まれてしまうので気にする人はそれぞれのdistについて~/quicklisp/dists/(dist name)/software/にパスを通しましょう。</p>

<p>因みに拙作の<a href="https://github.com/KeenS/CIM">CIM</a>は~/.cim/quicklisp以下にquicklispをインストールするのでCIM使いの方は~/.cim/quicklisp/dists/ですね。~/quicklispの方が混乱少ないかなあ。</p>

<p>さて、ASDFの設定は<a href="http://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems">公式マニュアル</a>を参照すれば良いのですが一応実際のものを書いておくと</p>

<p>~/.config/common-lisp/source-registry.conf に
<code>lisp
(:source-registry
  (:tree "~/quicklisp/dists/")
  (:tree (:home "Lisp/"))
  :INHERIT-CONFIGURATION)
</code>
を書けばOKです。2つめのLisp/は私がCommon Lispファイルを置いているディレクトリですね。この書き方だとquicklispより自分のLispライブラリを優先して読みにいきます。開発版を使いたいときとかむしろ開発をするときとかに必須です。この設定をミスるといくら開発してもロードされてるのはリリース版で、機能が動かないとかの地獄を見ます。</p>

<p>ここまでくれば</p>

<p><code>lisp
(require 'asdf)
(require 'hoge)
</code>
とすればquicklispでインストールしたライブラリをロード出来ます。</p>

<h2>require以外のASDFの使い方</h2>

<p>バージョンに依って使い方が異なるのですが、3系だと<code>(asdf:xxx-system 'hoge)</code>などとします。具体的には</p>

<ul>
<li><code>(asdf:load-system 'hoge)</code> ( = <code>(require 'hoge)</code>)</li>
<li><code>(asdf:test-system 'hoge)</code> (テストがあるときのみ)</li>
<li><code>(asdf:compile-system 'hoge)</code></li>
</ul>


<p>を覚えておけば良いでしょう。他にもいくつか操作があるようですが私は使ったことがないです。<code>asdf:locate-system</code>は名前的に便利そうではあるんですけどね。</p>

<p>開発するときはまず.asdファイルを書いておいて(あるいはcl-projectから生成して)、<code>(require 'hoge)</code>で始めて書いていき、ある程度進んだらテストを書いてテストの項目を.asdファイルに書き足して<code>(asdf:test-system 'hoge)</code>、それなりに動くようになったら<code>(asdf:compile-system 'hoge)</code>してコンパイルの様子を見たりコンパイル後のベンチマークを取ったりします。</p>

<h2>quickloadを成仏させる</h2>

<p>これでロードの処理はASDFで全てカバー出来るようになりました。じゃあquickloadのロード機能は邪魔ですね。quicklispをインストーラとしてのみ使いましょう。</p>

<p>まず処理系の初期化ファイル(sbclなら~/.sbclrc)から</p>

<p>```lisp
;;; The following lines added by ql:add-to-init-file:</p>

<h1>-quicklisp</h1>

<p>(let ((quicklisp-init (merge-pathnames &ldquo;~quicklisp/setup.lisp&rdquo;</p>

<pre><code>                                   (user-homedir-pathname))))
</code></pre>

<p>  (when (probe-file quicklisp-init)</p>

<pre><code>(load quicklisp-init :verbose nil)))
</code></pre>

<p>```</p>

<p>を削除します。quicklispを使いたいときだけ<code>(load "~/quicklisp/setup.lisp")</code>します。そして欲しいシステムをインストールするには</p>

<p><code>lisp
(ql::recursively-install "foo")
</code></p>

<p>します。quickloadに比べて爆速です。ここにきて名前が文字列な上にexportされてないシンポル参照してますね。気持ち悪いという方は大人しくquickloadしましょう。</p>

<p>拙作のCIMにはこれをコマンドラインから行なう<code>ql install</code>なるコマンドが存在します。</p>

<h1>最後に</h1>

<p>quicklispが嫌いなのは私の好みですがASDFを正しく使えて損はないと思うので知らなかった方々は是非試してみて下さい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lisp meet up #22でLTしてきた]]></title>
    <link href="http://KeenS.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita/"/>
    <updated>2014-11-28T23:17:12+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita</id>
    <content type="html"><![CDATA[<p>κeenです。先日 Lisp Meet Up #22 でLTしてきたので報告です。</p>

<!-- more -->


<p>LTは事前に登録されたのが2件、私が当日17時くらいに登録したの1件で、参加は20人募集の内20人応募、20人参加と最近中々の人気を見せてます。</p>

<h1>Common Lispで高速なHTTPパーサーを書く(仮)</h1>

<p>LT1件目は深町さんより、「Common Lispで高速なHTTPパーサーを書く(仮)」。fast-httpを作ったときの話。</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/42153462" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/fukamachi/writing-a-fast-http-parser" title="Writing a fast HTTP parser" target="_blank">Writing a fast HTTP parser</a> </strong> from <strong><a href="//www.slideshare.net/fukamachi" target="_blank">fukamachi</a></strong> </div></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVARnhncWZpRFdUOWM/preview">動画</a></p>

<p><a href="http://blog.8arrow.org/entries/2014/10/23">深町さんのブログ</a>に書かれていることの他、fast-httpが高速になるまでの経緯や実装方針などの話もありました。</p>

<p>最初ベースにしたnode.jsのHTTPパーサ、http-parseは状態を持っていて、1文字読む毎に状態を保存していた。次にベースにしたpicohttpparseは状態を持たず、HTTPリクエストが全部届く前にパースを始めてしまった場合はあきらめて最初からパースするようにしていた。fast-httpは1行パースする毎に状態を保存するようにした。など。</p>

<p>もう一つ、http-parseは<code>while</code>ループの中に巨大な<code>case</code>文があって、現在の状態で<code>case</code>でディスパッチし、その節の中で読んだ文字に依って現在の状態を変え、またループで先頭に戻って状態に依ってディスパッチするという手法だったそうです。Common Lispの場合は<code>case</code>が全て<code>(cond ((eql ..) ....) ...)</code>に展開されて遅い<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>ので<code>while</code>と<code>case</code>じゃなくて<code>tagbody</code>と<code>goto</code>で実装したそうです。</p>

<p>この手法は一般にDirect(Navive) ThreadingだとかThreaded Codeだとか呼ばれています。主にバイトコードインタプリタを実装する時にバイトコードに依るディスパッチの部分で使われるようです。Rubyの解説が丁寧だったようなので参考資料として置いておきます。</p>

<p><a href="http://magazine.rubyist.net/?0008-YarvManiacs">Rubyist Magazine &ndash; YARV Maniacs 【第 3 回】 命令ディスパッチの高速化</a></p>

<p>会場からはアーキテクチャ依存の最適化はしないのかとの質問がありました。SBCLにはインラインアセンブラであるVOPなるものが存在するのでSIMD命令使えば、とかいう怖い話ですね。</p>

<h1>symbol tree diff</h1>

<p>LT2件目はchikuさんより「symbol tree diff」。chikuさんが以前から取り組んでいるプログラムのdiffを構文レベルでとる話の進捗。</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/42160384" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/samugari/symbol-treediff" title="Symbol tree-diff" target="_blank">Symbol tree-diff</a> </strong> from <strong><a href="//www.slideshare.net/samugari" target="_blank">samugari</a></strong> </div></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVARUoxVGtiMlFrRVU/preview">動画</a></p>

<p>diff自体はとれるようになったようですが見せ方に問題があり、見易い形式を模索中のようです。会場に見易い形式は何か投げ掛けましたが良い案を見付けるのは難しいようです。</p>

<h1>Semantic S式</h1>

<p>私から「Semantic S式」。括弧が多い方が嬉しいこともあるよねーというゆるい話。
<a href="http://keens.github.io/slide/semantic-sshi.html">Semantic S式 | κeenのHappy Hacκing Blog</a></p>

<p><a href="https://docs.google.com/file/d/0B_H0_8eqWuVAQms2QkZDcnZfVlU/preview">動画</a></p>

<p>会場からは半分同意、半分ツッコみたいとの反応が。plistをリテラルから<code>getf</code>するやついないだろ、とか。</p>

<h1>懇親会</h1>

<p>私の発表で21時あたりだったのでそのまま解散して懇親会。隣にLand of Lispを読んでLispに興味持ってLispの授業をとってる方がいたのでどの本が入門に良いかなど。</p>

<p>VOPの話の続きもしました。どうしても資料がないのがネックだよねー、と。私の知っているのは</p>

<p><a href="http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/">How to Define New Intrinsics in SBCL &ndash; Paul Khuong mostly on Lisp</a></p>

<p>や</p>

<p><a href="http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html">Hacking SSE Intrinsics in SBCL (part 1) &ndash; Paul Khuong mostly on Lisp</a></p>

<p>かな。日本語のやってみた系だとg1さんの</p>

<p><a href="http://g000001.cddddr.org/2011-12-08">#:g1: SBCLでVOPを使ってみよう</a></p>

<p>あたり。</p>

<h1>その他</h1>

<p>テンプレートエンジンを作ってるって以前深町さんに話してたら「まだ出来ないんですか？」とさんざん煽られました。はい。頑張ります。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><code>cond</code>は先頭から順番に比較する仕様です。<code>case</code>は<code>cond</code>に展開されることが仕様で定められていた筈。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[claspを少し触ってみた]]></title>
    <link href="http://KeenS.github.io/slide/clasp.html"/>
    <updated>2014-10-28T16:17:00+09:00</updated>
    <id>http://KeenS.github.io/slide/clasp.markdown</id>
    <content type="html"><![CDATA[<h1>claspを少し触ってみた</h1>

<hr />

<p>Lisp Meet Up presented by Shibuya.lisp #21<br/>
2014-10-29<br/>
κeen(@blackenedgold)</p>

<h1>About Me</h1>

<hr />

<p><img src="/images/icon.png" alt="κeenのアイコン" /> <!-- .element: style="position:relative;right 0;" --></p>

<ul>
<li>κeen</li>
<li>東大数学科の4年生</li>
<li>ソーシャルアカウントは上のアイコン達から。</li>
<li>Lisp, Ruby, OCaml, Shell Scriptあたりを書きます</li>
</ul>


<h1>clasp</h1>

<hr />

<ul>
<li>Github: <a href="https://github.com/drmeister/clasp">drmeister/clasp</a></li>
<li>2014-09-18に0.1リリース(現在0.11プレビューが出ている)</li>
<li>今は0.11プレビューが出ている</li>
<li>ANSI Common Lisp準拠を目指す(現在80 ~90%)</li>
<li>ECLからのフォーク</li>
<li>LLVMベースのJIT(<a href="http://llvm.org/docs/MCJITDesignAndImplementation.html">MCJIT</a>)搭載</li>
<li>C++とLispで書かれている</li>
<li>C++との連携を意識</li>
</ul>


<p>Note:
C++との連携の部分を強調。今回は0.11プレビューでの話</p>

<h1>メモリ管理</h1>

<hr />

<ul>
<li>Memory Pool Systemと Boehm GCから選べる</li>
<li>ビルドするときにどっちかを選ぶ</li>
</ul>


<h1>メモリ管理</h1>

<hr />

<h2><a href="http://www.hboehm.info/gc/">Boehm GC</a></h2>

<ul>
<li>Mark &amp; Sweepのライブラリ</li>
<li>枯れた有名なライブラリ</li>
<li>Lisp有名どころではGaucheが使う</li>
<li>RedHat系だとこれを使ってないとrpmリジェクトされやすいらしい(?)</li>
</ul>


<p>Note:
他にはMozilla, W3M, GNU GCJ, GNU Obj-Cなどなど</p>

<h1>メモリ管理</h1>

<hr />

<h2><a href="http://www.ravenbrook.com/project/mps/">Memory Pool System</a></h2>

<ul>
<li>複数のGCアルゴリズムを組み合わせて使えるらしい</li>
<li>since 1994</li>
<li>あまり分からないです&gt;&lt;</li>
</ul>


<h1>依存ライブラリ</h1>

<hr />

<ul>
<li>LLVM <strong>3.6</strong></li>
<li>LLVM/clang <strong>3.5</strong> compiler</li>
<li>Boost build v2</li>
<li>boost libraries ver 1.55</li>
<li>Boehm 7.2</li>
<li>gmp-6.0.0</li>
<li>expat-2.0.1</li>
<li>zlib-1.2.8</li>
<li>readline-6.2</li>
</ul>


<p><span style="font-size:600%">無理</span></p>

<h1>externals-clasp</h1>

<hr />

<ul>
<li>Github: <a href="https://github.com/drmeister/externals-clasp">drmeister/externals-clasp</a></li>
<li>依存ライブラリを揃えるのが難しいとの声から作られた</li>
<li>依存ライブラリを全てビルド<!-- .element: class="fragment grow" --></li>
</ul>


<p><span style="font-size:300%">＼LLVMをビルド／</span></p>

<p><span style="font-size:300%">＼Boostをビルド／</span></p>

<p><span style="font-size:200%">ビルド時間はお察しです</span></p>

<h1>本体のビルド</h1>

<hr />

<p>Twitter実況をどうぞ↓↓</p>

<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>clangがメモリ6GB以上食い続けてて怖い。何やってんの。</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526417151486205952">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>clangの起動時間1時間超えてますよ…</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526418636735401984">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>HDDプチプチ言ってるし今にも壊れそう</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526420001587068929">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/nobkz">@nobkz</a> claspのコンパイル中です。&#10;clangなのにIOネックという謎の状態です。</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526420473232367616">2014, 10月 26</a></blockquote>


<h1>本体のビルド</h1>

<hr />

<blockquote class="twitter-tweet" lang="ja"><p>clangの消費メモリ7GB超えた</p>&mdash; κeen (@blackenedgold) <a href="https://twitter.com/blackenedgold/status/526423982992420864">2014, 10月 26</a></blockquote>


<p><span style="font-size:300%">ビルドは自己責任で</span></p>

<h1>使ってみる</h1>

<hr />

<h2>起動オプション</h2>

<p><code>
/usr/local/clasp/bin/clasp_mps_o --help
clasp options
-I/--ignore-image    - Don't load the boot image/start with init.lsp
-i/--image file      - Use the file as the boot image
-N/--non-interactive - Suppress all repls
-v/--version         - Print version
-s/--verbose         - Print more info while booting
-f/--feature feature - Add the feature to *features*
-e/--eval {form}     - Evaluate a form
-l/--load {file}     - LOAD the file
-r/--norc            - Don't load the ~/.clasprc file
-n/--noinit          - Don't load the init.lsp (very minimal environment)
-s/--seed #          - Seed the random number generator
-- {ARGS}*           - Trailing are added to core:*command-line-arguments*
</code></p>

<h1>使ってみる</h1>

<hr />

<h2>ASDF</h2>

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->動かない

<ul>
<li><!-- .element: class="fragment" data-fragment-index="2" -->ASDFの処理系依存の部分(<code>#+</code>)の問題</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->ECLと見做されるけどECLのコードは動かない</li>
</ul>
</li>
</ul>


<h1>使ってみる</h1>

<hr />

<h2>cl-ppcre</h2>

<ul>
<li><a href="https://gist.github.com/KeenS/4e25cb6e424ebe4e7a4a">手動ロードスクリプト</a></li>
<li><!-- .element: class="fragment" data-fragment-index="1" -->動かない

<ul>
<li><!-- .element: class="fragment" data-fragment-index="2" --><code>schar</code>がない</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->ANSI Common Lispにあるのに…</li>
</ul>
</li>
</ul>


<h1>使ってみる</h1>

<hr />

<h2>C++との連携</h2>

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->ドキュメントがない</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->サンプルコードもない</li>
<li><!-- .element: class="fragment" data-fragment-index="3" -->遂行不能</li>
</ul>


<h1>使ってみる</h1>

<hr />

<h2>LLVMの呼び出し</h2>

<ul>
<li><a href="https://github.com/drmeister/clasp/blob/master/src/llvmo/demo.lsp">clasp/src/llvmo/demo.lisp</a></li>
<li><!-- .element: class="fragment" data-fragment-index="1" -->動かない</li>
</ul>


<h1>使ってみる</h1>

<hr />



<table>
<thead>
<tr>
<th>処理系              </th>
<th>  <code>(time (fib 29))</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>clasp-0.1(boehm)    </td>
<td> <div class="graph fragment" style="width:calc(264.3px * 3);" data-fragment-index="1">26.43s</div></td>
</tr>
<tr>
<td>clasp-0.1(mps)      </td>
<td> <div class="graph fragment" style="width:calc(172.8px * 3);" data-fragment-index="1">17.28s</div></td>
</tr>
<tr>
<td>clasp-0.11(boehm)   </td>
<td> <div class="graph fragment" style="width:calc(213.2px * 3);" data-fragment-index="2">21.32s</div></td>
</tr>
<tr>
<td>clasp-0.11(mps)     </td>
<td> <div class="graph fragment" style="width:calc(187.9px * 3);" data-fragment-index="2">18.79s</div></td>
</tr>
<tr>
<td>ECL-13.5.1          </td>
<td> <div class="graph" style="width:calc( 16.0px * 3);">1.603s</div></td>
</tr>
<tr>
<td>ECL-13.5.1(compile) </td>
<td> <div class="graph" style="width:calc(  1.9px * 3);">0.192s</div></td>
</tr>
<tr>
<td>ABCL-1.3.1          </td>
<td> <div class="graph" style="width:calc( 32.9px * 3);">3.292s</div></td>
</tr>
<tr>
<td>ABCL-1.3.1(compile) </td>
<td> <div class="graph" style="width:calc(  2.4px * 3);">0.241s</div></td>
</tr>
</tbody>
</table>


<h1>使ってみる</h1>

<hr />

<table>
<thead>
<tr>
<th>処理系              </th>
<th>  <code>(time (fib 29))</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>CLISP-2.49          </td>
<td> <div class="graph" style="width:calc( 38.4px * 3);">3.847s</div></td>
</tr>
<tr>
<td>CLISP-2.49(compile) </td>
<td> <div class="graph" style="width:calc(  7.1px * 3);">0.7146s</div></td>
</tr>
<tr>
<td>ccl-1.10            </td>
<td> <div class="graph" style="width:calc(  0.4px * 3);">0.04033s</div></td>
</tr>
<tr>
<td>sbcl-1.2.5          </td>
<td> <div class="graph" style="width:calc(  0.6px * 3);">0.06469s</div></td>
</tr>
<tr>
<td>alisp-9.0           </td>
<td> <div class="graph" style="width:calc(  230px * 3);">23.09s</div></td>
</tr>
<tr>
<td>alisp-9.0(compile)  </td>
<td> <div class="graph" style="width:calc(  0.6px * 3);">0.06194s</div></td>
</tr>
</tbody>
</table>


<p><span style="font-size:200%">LLVM/JITなのになぜ遅い？</span></p>

<h1>LLVM/JITで遅い？</h1>

<hr />

<ul>
<li>LLVMって速いんじゃ？</li>
<li>JIT搭載した○○が速いって聞いたよ

<ul>
<li>JVM</li>
<li>lua-jit</li>
<li>Rubinius</li>
<li>pypy</li>
</ul>
</li>
</ul>


<h1>言葉の罠: LLVM</h1>

<hr />

<ul>
<li>遅いコードはどんなに頑張っても遅い</li>
<li>ECLのバックエンドにClang(=LLVM)を使ってもSBCLに勝てないのと同じ</li>
</ul>


<h1>言葉の罠: JIT搭載</h1>

<hr />

<ul>
<li>JIT(実行時コンパイル)の意味は広い</li>
<li>実行時にネイティブコードを吐けばJITと言える</li>
<li>claspは実行直前にコンパイルするだけ</li>
<li>多くの速いJIT処理系はTracing JITを使う

<ul>
<li>またの名を適応的コンパイル</li>
<li>実行時の情報に基いて実行中に最適化する</li>
<li><code>(declare ...)</code> を自動生成してる的な</li>
</ul>
</li>
</ul>


<h1>Tracing JITへの道</h1>

<hr />

<ul>
<li>LLVMのJITは実行直前にコンパイルするだけ

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->Tracing JITのバックエンドには使える</li>
</ul>
</li>
<li>実行時最適化には最適化用のコードが必要

<ul>
<li><!-- .element: class="fragment" data-fragment-index="2" -->Common Lispでは<code>(declare ...)</code>用のコードを使い回せる</li>
</ul>
</li>
<li><!-- .element: class="fragment" data-fragment-index="3" -->案外近い</li>
</ul>


<h1>結論</h1>

<hr />

<ul>
<li><!-- .element: class="fragment" data-fragment-index="1" -->遅い</li>
<li><!-- .element: class="fragment" data-fragment-index="2" -->時期尚早</li>
<li><!-- .element: class="fragment" data-fragment-index="3" -->今後機能や速度改善があれば使えるようになるかも</li>
</ul>


<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Common Lispの勉強をするには、あるいは情報を得るには]]></title>
    <link href="http://KeenS.github.io/blog/2014/10/20/lisp-ja/"/>
    <updated>2014-10-20T20:35:33+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/10/20/lisp-ja</id>
    <content type="html"><![CDATA[<p><a href="http://blog.8arrow.org/entry/2014/09/05/062028">深町さんのブログ</a>で日本語でCommon Lispの質問をする方法が載ってましたが質問じゃなくて単に情報を得たい、勉強をしたいという場合が書かれてなかったので勝手に補遺。</p>

<!-- more -->


<h1>処理系選び</h1>

<p><a href="http://cl.cddddr.org/index.cgi?%BD%E8%CD%FD%B7%CF%3A%C1%AA%A4%D3%CA%FD%A4%CE%CC%DC%B0%C2">処理系:選び方の目安 &ndash; Common LISP users jp</a>や
<a href="https://sites.google.com/site/shidoinfo/Home/programing-lang/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E/lisp/common-lisp/common-lisp-%E5%87%A6%E7%90%86%E7%B3%BB">Common Lisp 処理系 &ndash; 紫藤のWiki</a>が参考になるかと思います。</p>

<h1>開発環境構築</h1>

<p><a href="http://modern-cl.blogspot.jp/">Modern Common Lisp</a>あたりですかね。著者がちょっと古くなってきたので更新するって言ってました。</p>

<p>処理系のインストールなら*nix環境で使える拙作の<a href="https://github.com/KeenS/CIM">CIM</a>もあります。解説は<a href="http://keens.github.io/blog/2014/01/27/cim-explanation/">こちら</a>。</p>

<h1>入門</h1>

<h2>Web</h2>

<p>私の一番のおすすめはM.HiroiさんのWebページです。一応Common Lispではなくxyzzyですがここで紹介されている内容であればCommon Lispにも共通します。<br/>
<a href="http://www.geocities.jp/m_hiroi/xyzzy_lisp.html">M.Hiroi&rsquo;s Home Page / xyzzy Lisp Programming</a></p>

<h2>書籍</h2>

<ul>
<li><a href="http://www.amazon.co.jp/%E5%AE%9F%E8%B7%B5Common-Lisp-Peter-Seibel/dp/4274067211">実践Common Lisp</a>は入門から実践までいけて素晴らしいです。内容の密度が濃いです。心無しか手にとってみると少し重いです。
loopやformatなど複雑な部分はしっかりベージを割いてるので入門が終わってもリファレンスとして役立ちます。私も今でも参照してます。</li>
<li><a href="http://www.amazon.co.jp/Land-Lisp-M-D-Conrad-Barski/dp/4873115876">Land of Lisp</a>は挿絵が多く、少し学んでは実際に使ってみるのルーチンなので勉強のモチベーションを保ちやすいです。
内容は実践Common Lispに比べると細かな注釈が少ないかな？といったところ。さらっと読めて良いですね。</li>
<li><a href="http://www.amazon.co.jp/gp/product/4798118907/ref=pd_lpo_sbs_dp_ss_2?pf_rd_p=466449256&amp;pf_rd_s=lpo-top-stripe&amp;pf_rd_t=201&amp;pf_rd_i=4873115876&amp;pf_rd_m=AN1VRQENFRJN5&amp;pf_rd_r=1YA4XCHT36XJD6ZEF9KC">実用Common Lisp</a>(通称PAIP本)はぶ厚くて高い本。AI系の内容らしい。私は読んだことが泣いのですが、数理システムが入門書として使ってるそうです。</li>
</ul>


<h1>何か作る</h1>

<h2>Web</h2>

<ul>
<li><a href="http://www.usamimi.info/~ide/programe/stg_doc/stg-commonlisp.pdf">Common LispでSTGを作りますが何か</a>は有名なPDF。STG(シューティングゲーム)を作る内容。多少古い(SDLが1.2系だとか)ものの、練習には十分です。</li>
<li><a href="http://blog.8arrow.org/entry/2013/09/10/110632">Common LispでWebAppの開発に必要なN個のこと &ndash; 八発白中</a>はWeb Appを作るにあたって必要なライブラリを紹介している。紹介しているだけで作り方は書いてないのでどうにか頑張って下さい。</li>
</ul>


<p>あんまり情報無いですね…Lisperのみなさんもっとアウトプットしましょう。</p>

<h1>リファレンス</h1>

<h2>Web</h2>

<ul>
<li><a href="http://www.lispworks.com/documentation/HyperSpec/Front/">Common Lisp Hyper Spec</a>はCommon Lispの機能をサンプルと共に網羅的に、詳細に紹介しています。英語です。
主に<a href="http://www.lispworks.com/documentation/HyperSpec/Front/Contents.htm">コンテンツ</a>からドリルダウンで調べていくと良いです。時間があればじっくり眺めても良いかも。
Common Lispをやる上では必ず必要になるので、英語ですが必ず友達になっておきましょう。</li>
<li><a href="http://tips.cddddr.org/common-lisp/">逆引きCommon Lisp</a>は名前の通りやりたいことからCommon Lispの機能を調べられます。サンプルもあります。残念ながら網羅的ではないのですが凡その需要は満たせると思います。</li>
<li><a href="http://quickdocs.org/">Quickdocs</a>はライブラリのドキュメントサイト(英語)。ライブラリを捜す時にも良いと思います。</li>
</ul>


<h2>書籍</h2>

<ul>
<li><a href="http://www.amazon.co.jp/COMMON-LISP-%E7%AC%AC2%E7%89%88-Guy-L-Steele/dp/4320025881/ref=cm_lmf_tit_10">COMMON LISP 第2版</a>は通称cltl2と呼ばれるCommon Lispの原典の和訳です。一応紹介しました。今のCommon LispはANSI Common Lispになってるので少し違います。</li>
</ul>


<h1>ポータルサイト</h1>

<ul>
<li><a href="http://cl.cddddr.org/index.cgi">Common LISP users jp</a>は日本語で様々な情報が得られます。</li>
<li><a href="http://www.reddit.com/r/lisp_ja/">redditの/r/lisp_ja</a>にはLispに関連するWebページの情報が日々投稿されています。</li>
<li><a href="http://www.cliki.net/">CLiki</a>はCommon Lispの総合Wiki(英語)。非常に有用な情報が溜まってます。</li>
<li><a href="http://common-lisp.net/">Common-Lisp.net</a>はCommon Lispのコミュニティ支援サイト(英語)。多くのプロジェクトをホストしていて、そのWebページなんかもあります。</li>
</ul>


<h1>ソースコードを読む</h1>

<p>κeenの適当チョイスです。他にお勧めがあれば教えて下さい。</p>

<ul>
<li><a href="https://github.com/keithj/alexandria">alexandria</a>は有名なユーティリティパッケージ。小さな関数やマクロで構成されてるのでイディオム集みたいな感じで読めると思います。</li>
<li><a href="https://github.com/7max/log4cl">log4cl</a>はログライブラリ。ドキュメント(英語)をしっかり書いてるので読み易いです。</li>
<li><a href="https://github.com/edicl/hunchentoot">Hunchentoot</a>はWebサーバ。ドキュメント(英語)を過剰に書いてるので読める筈。</li>
</ul>


<h1>ステップアップ</h1>

<h2>Web</h2>

<ul>
<li><a href="http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/">On Lisp</a>は主にマクロについて書かれたCommon Lispプログラミングの指南書。書籍もありますが、Web版もあります。</li>
</ul>


<h2>書籍</h2>

<ul>
<li><a href="http://www.amazon.co.jp/LET-OVER-LAMBDA-Edition-1-0/dp/4434133632">Let Over Lambda</a>(通称LOL)は過激とか狂気とか宗教とか言われるエッセイ。高速化の話とかクロージャの危ない使い方とかが書かれてます。</li>
</ul>


<h1>Lisperとコミュニケーションをとる</h1>

<ul>
<li><a href="http://shibuya.lisp-users.org/">Shibuya.lisp</a>は渋谷を中心に半径2万kmを対象としたLispコミュニティ。毎月下旬の平日夜にLisp Meet Upをやってるのでひょこっとやってくると良いと思います。内容はCommon Lisp, Scheme, Clojureで回してるのでCommon Lisp回は3ヶ月に1回ですが毎回Common Lisperは来てるので別のLispの回でも構わず参加すると良いと思います。
#lispmeetup の情報は<a href="https://atnd.org/users/51173">ここ</a>から入手するのが良いかな？あとは<a href="https://twitter.com/shibuya_lisp">Twitterアカウント</a>もあります。Ustream配信もしてます。</li>
<li>IRCの#lisp-ja@irc.freenode.orgと#common-lisp-ja@irc.freenode.orgにコミュニティがあります。常に誰かがいる訳ではないのですがちょくちょく見てる人はいるので発言してみると反応があるかもしれません。今もこの投稿に対して反応があってCIMとredditの項目を追加しました。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to CIM]]></title>
    <link href="http://KeenS.github.io/slide/introduction-to-cim.html"/>
    <updated>2014-08-30T04:33:00+09:00</updated>
    <id>http://KeenS.github.io/slide/introduction-to-cim.markdown</id>
    <content type="html"><![CDATA[<h1>Introduction to CIM</h1>

<hr />


<p>κeen(@blackenedgold)</p>

<h2>突然ですが</h2>

<p>Common Lispのスクリプトファイルの実行方法知ってますか？</p>

<p>sbcl</p>

<pre><code>sbcl --script $file
</code></pre>

<p>ecl</p>

<pre><code>ecl -shell $file
</code></pre>

<p>ccl</p>

<pre><code>ccl -e $file -e '(quit)'
</code></pre>

<p>&hellip;</p>

<p><strong>シバン可搬性のあるスクリプトが書けない</strong></p>

<h2>そこで、こんなの書きました</h2>

<hr />


<p>```sh
case &ldquo;$LISP_IMPL&rdquo; in</p>

<pre><code>sbcl*)
    sbcl --script $1
    ;;
clisp*)
    clisp -on-error exit -i $1
    ;;
ecl*)
    ecl -shell $1
    ;;
ccl*)
</code></pre>

<p>&hellip;
```</p>

<h2>でも問題がある</h2>

<hr />


<ul>
<li>どの処理系をバックエンドに使うか</li>
<li>処理系のパスをどう捜すか</li>
<li>そもそもどうやって使ってもらうか</li>
</ul>


<h2>κeenの答え</h2>

<hr />


<blockquote><p>処理系の管理までやってしまおう。
そうしたら一緒に使ってもらえる。</p></blockquote>

<p>＿人人人人人人＿<br/>
＞　CIMの誕生　＜<br/>
￣Y<sup>Y</sup><sup>Y</sup><sup>Y</sup><sup>Y</sup>￣</p>

<h2>CIMとは</h2>

<hr />


<ul>
<li>Common Lisp Implementation Manager</li>
<li>ちむ</li>
<li>Rubyのrvmを強く意識</li>
<li>Common Lisp処理系のインストール、切り替え、コマンドラインインターフェースなど。</li>
<li><code>cim</code>、 <code>cl</code>、 <code>ql</code>コマンドから成る</li>
<li>B Shell スクリプト製(マルチプラットフォーム対応のため)</li>
<li>2013/10くらいからぼちぼち開発</li>
</ul>


<h2><code>cim</code>コマンドについて</h2>

<hr />


<p>インストール</p>

<pre><code>cim install sbcl
</code></pre>

<p>バックエンドの切り替え</p>

<pre><code>cim use sbcl
</code></pre>

<p>現在情報</p>

<pre><code>cim info
</code></pre>

<p>CIMのアップデート</p>

<pre><code>cim get
</code></pre>

<p>など。</p>

<h2><code>cl</code>コマンドについて</h2>

<hr />


<ul>
<li>最初に紹介したシェルスクリプトベース</li>
<li>コマンドラインからCommon Lispを使うことを重視</li>
<li>シバン対応も。</li>
<li>REPLは独自実装(デバッガを黙らせるのが主な目的)</li>
<li>オプションはrubyを意識</li>
</ul>


<h2>少しシバンの話</h2>

<hr \>


<h3>だめな例</h3>

<p>```lisp</p>

<h1>!cl</h1>

<p>(write-line &ldquo;ok&rdquo;)
<code>
</code>lisp</p>

<h1>!/home/kim/.cim/bin/cl</h1>

<p>(write-line &ldquo;ok&rdquo;)
<code>
</code>lisp</p>

<h1>!/usr/bin/env cl -q</h1>

<p>(write-line &ldquo;ok&rdquo;)
```</p>

<h3>推奨される例</h3>

<p>```lisp</p>

<h1>!/bin/sh</h1>

<h1>|</h1>

<p>exec cl &mdash;  &ldquo;$0&rdquo; &ldquo;$@&rdquo;
|#
(write-line &ldquo;ok&rdquo;)
```</p>

<h2><code>ql</code>コマンドについて</h2>

<hr />


<ul>
<li>quicklispのコマンドラインインターフェース</li>
<li>まだ未熟</li>
<li>rubyのgem的な。</li>
<li>最近<code>ql install</code>を高速化</li>
</ul>


<h2>その他の話</h2>

<hr />


<h3>対応処理系</h3>

<ul>
<li>処理系はabcl, alisp, ccl, clisp, ecl, sbcl対応</li>
<li>基本ビルドする</li>
<li>gclはANSIじゃないのでドロップ</li>
<li>lispworks他商用ははインストール出来ないのでドロップ</li>
<li>mkcl対応する？</li>
<li>CMU CLはつらい…</li>
</ul>


<h3>実装</h3>

<ul>
<li>B Shell スクリプトで書いたの失敗だった?</li>
<li>つらい</li>
<li>開発速度に影響</li>
<li>テスト（=品質）にも影響</li>
<li>sbclがじゃじゃ馬でつらい</li>
</ul>


<h3>方針</h3>

<ul>
<li>コマンドラインユーティリティである</li>
<li>基本POSIX以外に依存しない</li>
<li>極力環境に影響しない(rvmがひどいのを嫌って)</li>
<li>clコマンドはあくまで薄いラッパ</li>
<li>asdfも使わない</li>
</ul>


<h2><a href="http://www.slideshare.net/blackenedgold/cim-common-lisp-implementation-manager?ref=http://keens.github.io/blog/2014/01/24/lisp-meet-up-number-13/">半年前</a>から何が変わったか</h2>

<hr />


<ul>
<li>バグ潰し</li>
<li>その他細かな改善

<ul>
<li>ダンプされたコアを読み込む機能</li>
<li>SIGINTをハンドル</li>
<li>ビルド時のログ制御</li>
</ul>
</li>
<li>ぼちぼちテスト書き始めた</li>
</ul>


<h2>将来の話</h2>

<hr />


<ul>
<li>テストと品質の安定化</li>
<li>バイナリ配布の処理系は大人しくバイナリ使う？</li>
<li>最適なビルドオプション</li>
<li>コアダンプ機能</li>
<li>Lispスクリプト(実行可能ファイル)インストーラ</li>
<li>cl21との連携（バイナリ生成）</li>
<li>もうちょっとquicklispとの連携</li>
<li>ユーザー拡張</li>
</ul>


<h2>関連リソース</h2>

<hr />


<ul>
<li><a href="http://pupeno.com/2007/08/26/the-problem-with-lisp/">The problem with Lisp </a> : Lispはコマンドが作れないから流行らないという分析</li>
<li><a href="http://keens.github.io/blog/2014/01/27/cim-explanation/">CIMの解説をしてみる コマンド編 | κeenのHappy Hacκing Blog</a> : CIMの解説記事</li>
<li><a href="https://github.com/fukamachi/shelly">shelly</a> : CIMを使うCLのコマンドラインインターフェース</li>
<li><a href="https://github.com/snmsts/lsp">lsp</a> : CIMのC実装</li>
<li><a href="https://github.com/fukamachi/qlot">qlot</a> : <code>ql</code>よりリッチなquicklispラッパ</li>
</ul>


<p><span style="font-size:600%">以上</span><br/>
何か質問あればどうぞ</p>
]]></content>
  </entry>
  
</feed>
