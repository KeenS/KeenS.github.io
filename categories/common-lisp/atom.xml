<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: common lisp | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/common-lisp/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-12-19T15:28:27+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[実用Common Lispを読んだ]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda/"/>
    <updated>2014-12-14T21:45:23+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda</id>
    <content type="html"><![CDATA[<p>以前<a href="http://keens.github.io/blog/2014/10/20/lisp-ja/">Common Lispの勉強の手引の記事</a>を書いたときに実用Common Lispの名を挙げたが読んだことはなかった。</p>

<p>一応名前を挙げた責任として読んでみた。</p>

<!-- more -->


<p>読んだとは言ってもソースはざっくりしか見てないし、演習には目もくれてないので「一通り目を通した」程度。
買った本は逃げないのだし一回で理解する必要はない。最初に一通り内容を掴んで主張を理解してから、あとで気になった時につぶさに読むのが私の読み方。</p>

<p>最初の感想を言うと、古い。Common Lispもcltl2とANSI両方に配慮されて書かれているし、紹介されているAIの事例も1970~1980年代のもの。
古典といった感じ。ただし、その時代はCommon LispとAIの最盛期なのでこの本を読めばCommon LispがAIで名を馳せた理由が良く分かる。</p>

<p>Common Lispの内容は初級程度。まえがきにもあるようにプログラマとしては中級だがLispは初心者レベルの人向に書かれている。基本的なところを押えたらあとはどんどん進んでいく。
プログラミングの経験があればそれでも問題ない筈。心配ならWeb上にいくらでもあるチュートリアルをこなせば良い。</p>

<p>ライブラリなどに関しては本の中で完結しているので良く言えば1から10まで教えてくれる。悪く言えば最近のCommon Lispの動向は全く分からない。その意味では実践入門ではなく学習図書。陳腐化はしない。</p>

<p>AIについては、やはり古い。今では手法が確立されてAIの分野とは扱われないものも含まれている。ただし、これは意図したものなのかもしれない。
古いものというのは単純だ。最初に2部で単純なものを通して「肩馴らし」をしてから3部で手駒を増やして4部で踏み込んだ内容に入る。</p>

<p>また、AIの分野としては扱われていなものも含む、ということはこの本が情報科学の広い範囲をカバーする、ということでもある。900ベージは伊達じゃない。量もあればバラエティもある。</p>

<p>現実にある様々な難解な問題をCommon Lispという強力な道具で快刀乱麻解決していく。ソフトウェア開発手法を学びながらCommon Lispの強力さを思い知るための一冊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[割と処理系ポータブルなCommon Lisp実行可能ファイルを作る]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/"/>
    <updated>2014-12-08T06:17:12+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru</id>
    <content type="html"><![CDATA[<p>κeenです。Lisp Advent Calendarはもう枠埋まっちゃったので普通にブログで。</p>

<p>コマンドラインから実行可能なLispファイルをそれなりに多くの処理系で動くように作る話。</p>

<!-- more -->


<p>この話はCIMの生い立ちとも関連するんだけどシェルからLispを使いたいときは</p>

<p>```</p>

<h1>!/usr/bin/env sbcl &mdash;script</h1>

<p>&hellip;
```</p>

<p>なんて書いてた人も多いんじゃないかと思うんだけどこれは色々問題がある。</p>

<ol>
<li>envは環境に依っては/usr/local/bin/envだったりする</li>
<li>envは環境に依っては複数引数を取れない。"sbcl &mdash;script"という名前のファイルを捜しにいく</li>
<li>sbclでしか動かない</li>
</ol>


<p>この問題の扱いは一応解決策がある</p>

<p>```</p>

<h1>!/bin/sh</h1>

<h1>|</h1>

<p>exec sbcl &mdash;script &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
|#</p>

<p>&hellip;
```</p>

<p>3行目の<code>#|</code>がシェルのコメントでありLispのブロックコメントであるのがポイント。</p>

<ol>
<li>シェルは<code>#!/bin/sh</code>を見てシェルスクリプトとして実行する</li>
<li>1,3行目はコメントなのでシェルは無視</li>
<li>4行目でsbclにそのファイルを引数として与えてexecする。execしたあとはシェルには戻らないのでその後何が書いてあっても構わない</li>
<li>sbclを<code>--script</code>付きで読んでるので1行目の<code>#!</code>で始まる行は無視する</li>
<li>3~5行目はブロックコメントなのでsbclは無視</li>
<li>それ以降がLispとして実行される</li>
</ol>


<p>というカラクリになっている。こういうのをピジン言語っていうんだけ？</p>

<p>まあいいや。</p>

<p>ところでこのブロックコメントの中にはシェルスクリプト書き放題だよね？そのシェルスクリプト内でどのLisp使うか決めたらポータブルになりそうじゃない？</p>

<p>こういうのはどう？</p>

<p>```lisp</p>

<h1>!/bin/sh</h1>

<h1>|</h1>

<p>run_if_exists(){
 command -v $1 > /dev/null 2>&amp;1 &amp;&amp; exec &ldquo;$@&rdquo;
}
 run_if_exists sbcl &mdash;noinform &mdash;no-sysinit &mdash;no-userinit &mdash;script &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
 run_if_exists clisp -norc &mdash;quiet &mdash;silent -on-error exit  &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
 run_if_exists ecl -norc -q -shell &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
 run_if_exists mkcl -norc -q -shell &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
 run_if_exists alisp -qq &ndash;#! &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
|#</p>

<p>(write-line (lisp-implementation-type))
(force-output)
```</p>

<p>cclとabclは1行目のシェバンを読み飛ばせなかった&amp;評価結果をエコーバックしない方法が見当らなかったからパス。CMUCLは自分の環境で動かないから検証出来てない。</p>

<p>これでポータブルに実行は可能。コマンドライン引数の扱いとかはライブラリを頼ってくれ。因みにCIMでは</p>

<p>```lisp
  #+allegro  (cdr (system:command-line-arguments))
  #+sbcl (do<em>  ((var sb-ext:</em>posix-argv* (cdr list))</p>

<pre><code>            (list var var))
           ((string= (car list) "--") (return (cdr list))))
</code></pre>

<p>  #+clisp ext:<em>args</em>
  #+ecl (do*  ((var (si:command-args) (cdr list))</p>

<pre><code>           (list var var))
          ((string= (car list) "--") (return (cdr list))))
</code></pre>

<p>  #+abcl extensions:<em>command-line-argument-list</em>
  #+gcl (do<em>  ((var si::</em>command-args* (cdr list))</p>

<pre><code>           (list var var))
          ((string= (car list) "--") (return (cdr list))))
</code></pre>

<p>  #+cmu ext:<em>command-line-words</em>
  #+ccl ccl:<em>unprocessed-command-line-arguments</em>
  #+mkcl (do*  ((var (si:command-args) (cdr list))</p>

<pre><code>           (list var var))
          ((string= (car list) "--") (return (cdr list))))
</code></pre>

<p>  #+lispworks system:<em>line-arguments-list</em>
```</p>

<p>としている。参考までに。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[claspがアップデートされたよ]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/06/claspgaatupudetosaretayo/"/>
    <updated>2014-12-06T23:29:46+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/06/claspgaatupudetosaretayo</id>
    <content type="html"><![CDATA[<p>κeenです。アドベントカレンダーめっちゃ書いてますね。</p>

<!-- more -->


<h1>Clasp!</h1>

<p><a href="https://github.com/drmeister/clasp">clasp</a>のmasterに色々マージされました。リリースノートには、</p>

<blockquote><p>Clasp version 0.11
* Added ASDF support.
This is still alpha. Compile the ASDF module using (core:compile-asdf).
After that you can load the module using (load &ldquo;sys:kernel;asdf;build;asdf.bundle&rdquo;).
It takes between 15-30 seconds to load (this is why I&rsquo;m integrating Cleavir).
* Added the :CLASP <em>feature</em> and removed the :ECL <em>feature</em>.
Clasp will continue to mimic the underlying ECL functionality so that
Common Lisp code that supports ECL can be made to support Clasp by converting</p>

<h1>+ecl to #+(or ecl clasp) and #-ecl to #&ndash;(or ecl clasp)</h1>

<ul>
<li>Added code to generate object files directly from Clasp.
The LLVM bitcode compiler &ldquo;llc&rdquo; no longer needs to be in the PATH
for Clasp to generate object files from Common Lisp source.
The &ldquo;ld&rdquo; linker does need to be accessible.</li>
</ul>
</blockquote>

<p>とあります。ASDFが使える！リリースノートには書いてませんがslimeサポートもmasterにコミットされてます。あとコミット読んだら最適化もされてるような…。</p>

<p><a href="http://keens.github.io/slide/clasp.html">以前</a>二十数秒掛かっていた<code>(fib 29)</code>ですが、今回はなんと</p>

<p>```
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 &hellip; loading image&hellip; it takes a few seconds
Top level.</p>

<blockquote><p>(load &ldquo;fib.lisp&rdquo;)
1346269
real time : 34.294 secs
run time  : 38.844 secs
T
(compile-file &ldquo;fib.lisp&rdquo;)</p></blockquote>

<h1>P"/home/kim/Lisp/fib.bc"</h1>

<p>NIL
NIL</p>

<blockquote><p>(load &ldquo;fib.bc&rdquo;)
1346269
real time : 21.355 secs
run time  : 25.785 secs
T
```</p></blockquote>

<p>うわぁ。遅くなってる。</p>

<p>因みに.bcファイルはLLVMの中間ファイルなのでClaspとは独立に<code>opt -f -O3 fib.bc &gt; fib.opt.bc</code>で最適化出来ます。それをやると</p>

<p>```
$ opt -f -O3 fib.bc > fib.opt.bc
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 &hellip; loading image&hellip; it takes a few seconds
Top level.</p>

<blockquote><p>(load &ldquo;fib.opt.bc&rdquo;)
1346269
real time : 34.981 secs
run time  : 37.986 secs
T
```
あれ？遅くなった。</p></blockquote>

<p>mpsはまだコンパイル中だから待ってね</p>

<h1>ASDFを使ってみる</h1>

<p>```
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 &hellip; loading image&hellip; it takes a few seconds
Top level.</p>

<blockquote><p>(time (core:compile-asdf))
zsh: segmentation fault (core dumped)  /usr/local/clasp/bin/clasp_boehm_o
```</p></blockquote>

<p>はい。解散。因みに50分くらいは動いてた。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VOPで遊ぶ]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/02/vopdeyou-bu/"/>
    <updated>2014-12-02T23:38:26+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/02/vopdeyou-bu</id>
    <content type="html"><![CDATA[<p>(:meta<br/>
 ((:this &ldquo;<a href="http://qiita.com/advent-calendar/2014/lisp">Lisp Advent Calendar 2014</a>の3日目の記事&rdquo;)<br/>
  (:prev (:author &ldquo;tk_riple&rdquo; :title <a href="http://compassoftime.blogspot.jp/2014/12/r7rs.html">&ldquo;時の羅針盤＠blog: R7RSポータブルライブラリを書く際の落とし穴&rdquo;</a>))<br/>
  (:next (:author &ldquo;nobkz&rdquo; :tite &ldquo;Shenについて&rdquo;))))</p>

<p>κeenです。さっきまでVOPで遊んでたので当初の予定を変更してVOPの話をします。</p>

<!-- more -->


<h1>VOPとは何か</h1>

<p>SBCLやCMU CLで使われているネイティブコードを吐くための機構、要はインラインアセンブラです。</p>

<h1>VOPとはどんなものか</h1>

<p>とりあえずコードをば。x86-64用です。</p>

<p>```lisp
(in-package :cl-user)
(defpackage vop-sample
  (:use :cl :sb-ext :sb-c))
(in-package :vop-sample)</p>

<p>(defknown add (fixnum fixnum)          ; addのftypeを宣言</p>

<pre><code>fixnum
(movable                            ; 副作用がない
 flushable                          ; デッドコードとして除去してよい
 foldable                           ; 定数畳み込みをしてよい
 always-translatable)               ; 必ずアセンブラコードになる
</code></pre>

<p>  :overwrite-fndb-silently t)           ; 関数上書きのエラーを出さない</p>

<p>(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::add)          ; VOP名
  (:translate vop-sample::add)         ; 関数名
  (:policy :fast-safe)                  ; declare optimize的な
  (:args (x :scs (signed-reg))          ; 引数宣言。後述</p>

<pre><code>     (y :scs (signed-reg)))
</code></pre>

<p>  (:arg-types fixnum fixnum)            ; 引数の型宣言
  (:results (r :scs (signed-reg)))      ; 返り値宣言。後述
  (:result-types fixnum)                ; 返り値の型宣言
  (:generator 4                         ; 翻訳するときのコスト</p>

<pre><code>          (move r x)                ; 返り値レジスタにxを移動
          (inst add r y)))          ; 返り値レジスタにyを足し込む
</code></pre>

<p>(in-package :vop-sample)</p>

<p>(defun add (x y)                        ; 安全なバージョンでラップする
  (add x y))
```</p>

<p>ちょっとおまじないが多いですね。</p>

<p>すこし解説すると引数は基本レジスタ渡しで、レジスタが足りなければスタックも使います。で、レジスタやスタックの値には型があります。それがストレージクラス(sc)です。この場合、x、y、rは<code>signed-reg</code>と宣言されてますね。符号付きレジスタです。<code>:scs</code>の最後のsは複数形のsです。今回は1つしか指定してませんが複数指定することも可能なのです。</p>

<p><code>move</code>というのはアセンブラ命令ではなく、マクロかなんかです（適当）。VOPなのかな？どのストレージクラスからどのストレージクラスに移動するかを認知して適切な命令を吐きます。</p>

<p><code>inst</code>が付いてるのがアセンブラですね。</p>

<p>このコード、xとrが等しいときに最適化出来るのですがそれはまあおいといて、こいつをディスアセンブルしてみましょう。</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'add)
; disassembly for ADD
; Size: 43 bytes. Origin: #x1005C26416
; 16:       488BD3           MOV RDX, RBX                     ; no-arg-parsing entry point
; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
; 2E:       CC0A             BREAK 10                         ; error trap
; 30:       02               BYTE #X02
; 31:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 32:       9A               BYTE #X9A                        ; RCX
; 33:       CC0A             BREAK 10                         ; error trap
; 35:       04               BYTE #X04
; 36:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 37:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 3A:       CC0A             BREAK 10                         ; error trap
; 3C:       04               BYTE #X04
; 3D:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 3E:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
</code></pre>

<p>主要な部分はここです。</p>

<pre><code>; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
</code></pre>

<p><code>ADD</code>の他に無駄な命令がいくつかありますね。</p>

<p>SBCLはintの下位1bitをGCのときのタグとして使ってるのでアセンブラに渡す前に算術右シフト(<code>SAR</code>)して渡してます。
そして返るときはまた左シフト(<code>SHL</code>)してます。</p>

<p>その後の</p>

<pre><code>; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
</code></pre>

<p>は関数から返るときのイディオム(スタックポインタを復元してフラグをクリアして呼び出し元に戻る)です。</p>

<p>余談ですがLispマシンなどのタグマシンは下位ビットにあるタグを無視して計算出来るのでシフトが不要になります。なので速いんですね。</p>

<h1>シフトをなくす</h1>

<p>さっきは<code>signed-reg</code>を指定しました。つまり「（アセンブラの）intをくれ」と要求した訳です。
intの下位1bitは0なので足し算する分には別にシフトされなくても問題ありませんよね。シフトを殺しましょう。</p>

<p>さっきのコードの下にこれを足します。<code>add</code>は再定義しないと反映されないようでした。</p>

<p>```lisp
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::add/v2)        ; vop名は異なる
  (:translate vop-sample::add)          ; 関数名は同じ
  (:policy :fast-safe)
  (:args (x :scs (any-reg))             ; any-regになってる</p>

<pre><code>     (y :scs (any-reg)))            ; any-regになってる
</code></pre>

<p>  (:arg-types fixnum fixnum)
  (:results (r :scs (any-reg)))         ; any-regになってる
  (:result-types fixnum)
  (:generator 3                         ; コストをさっきより低くすると優先して使ってくれる</p>

<pre><code>          (move r x)
          (inst add r y)))
</code></pre>

<p>(in-package :vop-sample)</p>

<p>(defun add (x y)
  (add x y))</p>

<p>```</p>

<p>んで、ディスアセンブルしてみると</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'add)

; disassembly for ADD
; Size: 31 bytes. Origin: #x1004C2AB83
; 83:       488BD1           MOV RDX, RCX                     ; no-arg-parsing entry point
; 86:       4801FA           ADD RDX, RDI
; 89:       488BE5           MOV RSP, RBP
; 8C:       F8               CLC
; 8D:       5D               POP RBP
; 8E:       C3               RET
; 8F:       CC0A             BREAK 10                         ; error trap
; 91:       02               BYTE #X02
; 92:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 93:       9A               BYTE #X9A                        ; RCX
; 94:       CC0A             BREAK 10                         ; error trap
; 96:       04               BYTE #X04
; 97:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 98:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 9B:       CC0A             BREAK 10                         ; error trap
; 9D:       04               BYTE #X04
; 9E:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 9F:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
</code></pre>

<p>はい。見事にSARとSHLが消えましたね。</p>

<h1>もう少し複雑な型を扱う</h1>

<p>アセンブラですし<code>(simple-array (unsigned-byte 8) (*))</code>(以下octets)を扱いたいですよね。とりあえず難しいことは考えずにoctetsの0番目の要素にアクセスしてみましょう。とはいっても<code>simple-array</code>は長さや要素の型の情報も持っていることが予想されるので少しデータを読み飛ばさないといけませんね。</p>

<p>その辺の計算が分からなかったのでsbclのソースからそれっぽいものを参考にしました。</p>

<p>```lisp
(defknown access-simple-array-0 ((simple-array (unsigned-byte 8) (*)))</p>

<pre><code>(unsigned-byte 8)
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::access-simple-array-0)
  (:translate vop-sample::access-simple-array-0)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg)))
  (:arg-types *)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4</p>

<pre><code>          (inst movzx r 
           (make-ea :byte :base x
                    :disp (- (* vector-data-offset n-word-bytes)
                           other-pointer-lowtag)))))
</code></pre>

<p>(in-package :vop-sample)
(defvar <em>octets</em> (make-array 4</p>

<pre><code>                         :element-type '(unsigned-byte 8)
                         :initial-contents '(10 11 12 13)))
</code></pre>

<p>(defun access-simple-array-0 (x)
  (access-simple-array-0 x))
```</p>

<p>こんな感じになります。境界チェックとかはやってませんが許して下さい。</p>

<p><code>descriptor-reg</code>というのがポインタが入ってるレジスタっぽいです。<code>movzx</code>は8bitの値を64bitのレジスタに符号拡張しながらロードする命令です。</p>

<p><code>make-ea</code>というのがアドレッシングですね。<code>x</code>レジスタを起点として<code>(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)</code>バイト(？ワード？)先のメモリ1byteを指します。</p>

<p>ディスアセンブルしてみましょう。みなさんもう慣れてきたと思うので主要部だけ抜き出します。</p>

<pre><code>; 65:       0FB65101         MOVZX EDX, BYTE PTR [RCX+1]      ; no-arg-parsing entry point
; 69:       48D1E2           SHL RDX, 1
</code></pre>

<p>短いですね。この<code>BYTE PTR [RCX+1]</code>が<code>make-ea</code>した値に対応します。<code>RCX</code>は<code>x</code>で<code>(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)</code>の結果が1に現れてるんでしょう。補足しておくと、<code>EDX</code>と<code>RDX</code>は同じ場所を指します。32bitとして扱うときはE、64bitとして扱うときはRで指します。</p>

<p>さて、私はx86のアドレッシングモードなんて全然知らないのですがコードを見る限りもうちょっと複雑なアドレッシングが出来るようです。</p>

<p>配列のn番目にアクセスするコードが良い例のようです。</p>

<p>```lisp
(defknown access-simple-array-n ((simple-array (unsigned-byte 8) (*)) (unsigned-byte 64))</p>

<pre><code>(unsigned-byte 8)
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::access-simple-array-n)
  (:translate vop-sample::access-simple-array-n)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg))</p>

<pre><code>     (i :scs (unsigned-reg)))
</code></pre>

<p>  (:arg-types * unsigned-num)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4</p>

<pre><code>          (inst movzx r 
           (make-ea :byte :base x
                    :scale 1
                    :index i
                    :disp (- (* vector-data-offset n-word-bytes)
                           other-pointer-lowtag)))))
</code></pre>

<p>(in-package :vop-sample)
(defun access-simple-array-n (x i)
  (access-simple-array-n x i))
```</p>

<p>新たに引数<code>i</code>をとるようになったのと<code>make-ea</code>の引数に<code>:scale 1 :index i</code>が加わってます。</p>

<p>ディスアセンブルしてみましょう。</p>

<pre><code>; 98:       0FB6543901       MOVZX EDX, BYTE PTR [RCX+RDI+1]  ; no-arg-parsing entry point
; 9D:       48D1E2           SHL RDX, 1
</code></pre>

<p>アドレッシングに<code>+RDI</code>が加わりましたね。どうして<code>i</code>(<code>RDI</code>)を<code>RAS</code>しなくていいのか気になりますがまあ、とりあえず正常に動いてるようです。</p>

<p>おわかりかと思いますがアドレッシングが<code>x</code>をベースにして今までの定数オフセット+新たにレジスタで指定したオフセットになってます。</p>

<p><code>make-ea</code>に渡した<code>:index</code>は何か分かるとしても<code>:scale</code>が気になりますよね。<code>scale</code>を2にしてディスアセンブルしてみます。</p>

<pre><code>; 58:       0FB6547901       MOVZX EDX, BYTE PTR [RCX+RDI*2+1]  ; no-arg-parsing entry point
; 5D:       48D1E2           SHL RDX, 1
</code></pre>

<p>はい。インデックスを定数倍するようですね。</p>

<h1>SSEにチャレンジ</h1>

<p>インテルアーキテクチャにあるSSEとはStreaming SIMD Extensionsの略です。じゃあSIMDは何かというとSimple Instruction Mulitple Dataの略で、1命令で複数のデータを処理出来ます。</p>

<p>この「複数のデータ」というのは64bit2つや32bit4つなどを128bitにまとめて渡します。128bitの値なんてどうやって作るんだよって感じですがsbcl-1.1.8から入った<code>sb-ext:%make-simd-pack-*</code>が存在します。</p>

<pre><code>VOP-SAMPLE&gt; (%make-simd-pack-ub32 1 2 3 4)
#&lt;SIMD-PACK  01 00 00 00  02 00 00 00  03 00 00 00  04 00 00 00&gt;
</code></pre>

<p>こんな感じです。x86_64がリトルエンディアンだったのを思い出させる表記ですね。ub32の他にub64、single、doubleが存在します。</p>

<p>ストレージクラスも<code>*-sse-reg</code>というものがあるのでこれを使いましょう。</p>

<p>```lisp
(defknown simd-add ((simd-pack (unsigned-byte 64)) (simd-pack (unsigned-byte 64)))</p>

<pre><code>(simd-pack (unsigned-byte 32))
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::simd-add)
  (:translate vop-sample::simd-add)
  (:policy :fast-safe)
  (:args (x :scs (int-sse-reg))</p>

<pre><code>     (y :scs (int-sse-reg)))
</code></pre>

<p>  (:arg-types simd-pack-int simd-pack-int)
  (:results (r :scs (int-sse-reg)))
  (:result-types simd-pack-int)
  (:generator 4</p>

<pre><code>          (move r x)
          (inst padddw r y)))
</code></pre>

<p>(in-package :vop-sample)
(defun simd-add (x y)
  (simd-add x y))
```</p>

<p>はい。こんな感じですね。<code>paddw</code>はparallel add wordですかね。これをディスアセンブルすると思ったより大きな命令になったので全部貼っときますね。</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'simd-add)

; disassembly for SIMD-ADD
; Size: 108 bytes. Origin: #x1006D64A21
; 21:       660F6FC2         MOVDQA XMM0, XMM2                ; no-arg-parsing entry point
; 25:       660FFDC1         PADDW XMM0, XMM1
; 29:       49896C2440       MOV [R12+64], RBP                ; thread.pseudo-atomic-bits
; 2E:       4D8B5C2418       MOV R11, [R12+24]                ; thread.alloc-region
; 33:       498D5320         LEA RDX, [R11+32]
; 37:       493B542420       CMP RDX, [R12+32]
; 3C:       7740             JNBE L2
; 3E:       4989542418       MOV [R12+24], RDX                ; thread.alloc-region
; 43:       498D530F         LEA RDX, [R11+15]
; 47: L0:   48C742F165030000 MOV QWORD PTR [RDX-15], 869
; 4F:       48C742F900000000 MOV QWORD PTR [RDX-7], 0
; 57:       660F7F4201       MOVDQA [RDX+1], XMM0
; 5C:       49316C2440       XOR [R12+64], RBP                ; thread.pseudo-atomic-bits
; 61:       7402             JEQ L1
; 63:       cc09             break 9                          ; pending interrupt trap
; 65: l1:   488be5           mov rsp, rbp
; 68:       f8               clc
; 69:       5d               pop rbp
; 6a:       c3               ret
; 6b:       cc0a             break 10                         ; error trap
; 6d:       02               byte #x02
; 6e:       19               byte #x19                        ; invalid-arg-count-error
; 6f:       9a               byte #x9a                        ; rcx
; 70:       cc0a             break 10                         ; error trap
; 72:       04               byte #x04
; 73:       32               byte #x32                        ; object-not-simd-pack-error
; 74:       fe1b01           byte #xfe, #x1b, #x01            ; rdx
; 77:       cc0a             break 10                         ; error trap
; 79:       04               byte #x04
; 7a:       32               byte #x32                        ; object-not-simd-pack-error
; 7b:       fe9b03           byte #xfe, #x9b, #x03            ; rdi
; 7e: l2:   6a20             push 32
; 80:       bac0854200       mov edx, 4359616                 ; alloc_tramp
; 85:       ffd2             call rdx
; 87:       5a               pop rdx
; 88:       80ca0f           or dl, 15
; 8b:       ebba             jmp l0
nil
</code></pre>

<p>なにやってるのやら。</p>

<h1>出来なかったこと</h1>

<p><code>PCMPESTRI</code>を使ってみたかったのですが扱いがトリッキーなので断念しました。具体的に言うと操作する値を格納するレジスタがEAXとECX固定なようなのです。
<code>:temporary</code>節で内部で使うレジスタも要求出来るようなのですが名指しでもらえるんですかね。</p>

<p>SSEの使い方とsimple-arrayから要素の配列を取り出す方法までは示したので誰かやって下さい。</p>

<p>参考資料いっぱい置いときますね。</p>

<p>VOPの使い方。最初の方に出てきたaddの最適化のやつとかも出てくる。(en)
: <a href="http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/">How to Define New Intrinsics in SBCL &ndash; Paul Khuong mostly on Lisp</a></p>

<p>SBCLのsimd-packの具体的解説(en)
: <a href="http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html">Hacking SSE Intrinsics in SBCL (part 1) &ndash; Paul Khuong mostly on Lisp</a></p>

<p>SBCLでVOPとSSEを使ってマンデルブロ集合を計算する(en)
<a href="http://www.pvk.ca/Blog/2013/06/05/fresh-in-sbcl-1-dot-1-8-sse-intrinsics/">Fresh in SBCL 1.1.8: SSE Intrinsics! &ndash; Paul Khuong mostly on Lisp</a></p>

<p>IntelのPCMPESTRIとかのマニュアル(en)
: <a href="https://software.intel.com/en-us/node/514244">Packed Compare Intrinsics</a></p>

<p>MicrosoftのPCMPESTRIのマニュアル。こっちの方が分かりやすい(en)
<a href="http://msdn.microsoft.com/en-us/library/bb531465.aspx">_mm_cmpestri</a></p>

<p>PCMPISTRIを使った<code>strlen</code>の実装例(ja)
: <a href="http://homepage1.nifty.com/herumi/prog/intel-opt.html">Intel optimization</a></p>

<p>PCMPESTRIを使ってHTTPパーサーを高速化した話。これをやりたかった。(en)
: <a href="http://blog.kazuhooku.com/2014/12/improving-parser-performance-using-sse.html">Kazuho&rsquo;s Weblog: Improving Parser Performance using SSE Instructions (in case of PicoHTTPParser)</a></p>

<h1>おわりに</h1>

<p>おつかれ様でした。たまには低レベルなことをやっても良いんじゃないでしょうか。</p>

<p>明日はnobkzさんで、Shenについてです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[require, ASDF, quicklispを正しく使う]]></title>
    <link href="http://KeenS.github.io/blog/2014/11/30/quicklisp/"/>
    <updated>2014-11-30T22:05:39+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/11/30/quicklisp</id>
    <content type="html"><![CDATA[<p>κeenです。最近のCommon Lispのパッケージ管理は<code>ql:quickload</code>しか知らないという方も多いのではないでしょうか。しかしそれだけでは機能が足りないこともあります。Common Lispには様々な管理システムがあるので整理しましょう。</p>

<!-- more -->


<h1><code>provide</code>, <code>require</code></h1>

<p>同じファイルを読み込まないための原始的なシステムです。Common Lispの標準の機能です。<code>(require 'foo)</code>がファイルをロードし、ロードされたファイル内で<code>(provide 'foo)</code>しておくと2回目以降の<code>(require 'foo')</code>はファイルを読まずにすぐさま返ります。</p>

<p>ここで問題なのが<code>require</code>がどこのファイルを捜しにいくかは処理系依存なところですね。なので生の<code>require</code>は使えないと思っておいた方が良いでしょう。</p>

<h1>ASDF 3</h1>

<p>Another Sysytem Defininion Facility。過去にはAnotherじゃないSysytem Defininion Facilityもあった模様。最新版は3系です。結構APIが変っているので必ず3の情報を捜しましょう。</p>

<p>この「System」というのが聞き慣れませんが、ASDFの<code>defsystem</code>で</p>

<ol>
<li>systemに含まれるファイルの定義</li>
<li>依存systemの記述</li>
<li>その他作者、ライセンス、バージョンなどの記述</li>
<li>systemのコンパイルやロード、テストなどの操作</li>
</ol>


<p>が可能です。ASDFはCにとってのmake + ldを標榜しています。Makefile的なものは(systemname).asdになります。</p>

<p><code>require</code>との統合もされており、ASDFを適切に設定することで<code>defsystem</code>されたsystemを<code>require</code>でロードすることが出来ます。このときASDFは処理系に依存せずにASDFのパスに従って.asdファイルを捜しにいきます。</p>

<p>また、ほとんどの処理系はASDFを標準添付していて、大抵<code>(require 'asdf)</code>すれば使えるようになっています。</p>

<p>尚、コンパイル後のファイルは処理系、バージョン毎に互換性がないので本来なら適切に管理する必要がありますが、ASDFが適切に~/.cache/common-lisp以下に管理してくれます。優秀ですね。</p>

<h1>quicklisp</h1>

<p>lispプロジェクトのインストーラと微妙にパッケージマネージャ的な役割をします。</p>

<p><a href="http://beta.quicklisp.org/quicklisp.lisp">http://beta.quicklisp.org/quicklisp.lisp</a> をダウンロードしてきてそのファイルを読み込んで<code>(quicklisp-quickstart:install)</code>すれば~/quicklisp/以下にquicklispがインストールされ、ロードされます。処理系を再起動したあとまたquicklispをロードするには~/quicklisp/setup.lispを<code>load</code>します。が、毎回それをやるのが面倒な人は<code>(ql:add-to-init-file)</code>しておけば処理系の初期化ファイルに~/quicklisp/setup.lispを読み込む処理が書き加えられます。</p>

<p>さて、このquicklispを扱う上で3つの概念を覚えておくと良いです。</p>

<p>dist
:    releaseの配布元。普通は'quicklisp'のみだがほかのdistを使うことも可能。自前のやつとか。新たなdistを追加したり削除したり出来る。gitのremoteをイメージすればよい。</p>

<p>release
:    quicklispがダウンロードしてくる単位。ライブラリの作者が登録するときの単位。複数のsystemをもつこともある。</p>

<p>system
:    ASDFのsystem。ユーザーが使うときの単位。</p>

<p>さて、quicklispを使うときは通常使いたいシステムを<code>ql:quickload</code>すればそのシステムと依存システムの含まれているリリースをダウンロード、展開、ロードまでしてくれます。</p>

<p>開発中はREPLを立ち上げているので「あ、このライブライリ使おう」と思ったら<code>ql:quickload</code>するだけで即座に使えるようになりますね。</p>

<p>quicklispのリリースは毎月下旬にアップデートされていて、毎月ちゃんと全てのライブラリが対応処理系で動くことがテストされています。なのでメンテナが居なくなったライブラリはドロップします。代わりにquicklispの作者がテスト出来ないライブラリは登録させてもらえなかったりします（cl-cudaとか）</p>

<h1>quicklispの問題</h1>

<p>既にCommon Lispのライブラリマネージャとしてデファクトスタンダード的位置を築きつつあるquicklispですが、私は結構不満があります。</p>

<ul>
<li>~/quicklisp/setup.lispを読み込むとquicklispの全てを読み込んでしまう: これには過去全てのバージョンのdistとreleaseとsystemのデータベース、HTTPクライアント、圧縮ファイルの解凍ライブラリなども含まれており、処理系の起動が非常に遅くなる</li>
<li>特にデータベースはファイルに書かれていても高速に読める形式なのに初期化時に毎回全ての内容をLispのハッシュに変換するという愚行をする。</li>
<li><code>(ql:add-to-init-file)</code>が推奨されているが、前述の通り処理系の起動が遅くなってしまう。特に、（インストーラではなく、インストール済みの）ライブラリマネージャとして使いたくてもインストーラの機能までロードしてしまう。結構メモリを食うしアプリケーションには要らない。</li>
<li>処理系に依っては初期化ファイルはlispファイルをスクリプトとして使うときは読み込まれないこともあるのでスクリプトには使えない。まあ、前述の通り使いたくもない。</li>
</ul>


<p>のでライブラリマネージャにはASDFが向いてるのですが、</p>

<ul>
<li>quicklispでインストールしたシステムはquicklispを一旦ロードするかASDFの設定をいじるかしなければASDFからは使えない</li>
<li>quicklispはシステムのダウンロード/インストールだけすれば良いものをロードまでする</li>
<li>要はASDFを隠す</li>
<li>じゃASDFのラッパーかというとロードしかせず、コンパイルやテストなどはしない</li>
</ul>


<p>など様々な問題があります。</p>

<p>一応quicklispの弁護をしておくと、Common Lispは他のスクリプト言語とはちょっと使い方が違って、</p>

<ul>
<li>初期化ファイルは大抵オレオレライブラリで埋め尽くされていてそもそも起動には時間がかかる</li>
<li>Emacsのように一度REPLを立ち上げたら滅多に落とさない</li>
<li>アプリケーションも基本的にはREPLの中で使う</li>
<li>起動時間を気にするなら初期化ファイルを全てロードした、コアファイルをダンプしておいて使う</li>
</ul>


<p>といった使い方をされることが多いのです。そのような人からしてみたら細々処理されるよりも起動時間とメモリは気にしないから速いやつをくれ、となるのです。</p>

<p>じゃあそれなりにCommon Lispを使う私が何故そうしないかというと</p>

<ul>
<li>立ち上げっぱなしというのが性に合わない。立ち上がっているものを見るとすぐに落としたくなる。EmacsのヘビーユーザーだがEmacsもすぐ落とす。</li>
<li>コマンドラインアプリケーションを作りたいため、起動時間が命になる。</li>
<li>私はSBCLの開発版を使っていて、コアファイルはすぐに無効になるためコアダンプはしない（意味がない）</li>
</ul>


<p>といった理由があります。これは初心者にも共通する部分があるんじゃないでしょうか。REPLを立ち上げっぱなしにはしないし「コアダンプ？なにそれ？エラー出してんじゃん」状態でしょう。</p>

<h1>ASDFを正しく使う</h1>

<p>ということでquicklispをあまり使わない方法を紹介します。</p>

<p>前述の通り、quicklispでインストールしたシステムはquicklispを一旦ロードするかasdfの設定をいじるかしなければasdfからは使えません。具体的に言うと、</p>

<ul>
<li>ASDFのデフォルトパスは~/common-lisp以下</li>
<li>quicklispのシステムのインストールパスは~/quicklisp/dists/(dist name)/software/以下</li>
</ul>


<p>なので~/quicklisp/dists/以下にパスを通します。少し無駄なディレクトリもパスに含まれてしまうので気にする人はそれぞれのdistについて~/quicklisp/dists/(dist name)/software/にパスを通しましょう。</p>

<p>因みに拙作の<a href="https://github.com/KeenS/CIM">CIM</a>は~/.cim/quicklisp以下にquicklispをインストールするのでCIM使いの方は~/.cim/quicklisp/dists/ですね。~/quicklispの方が混乱少ないかなあ。</p>

<p>さて、ASDFの設定は<a href="http://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems">公式マニュアル</a>を参照すれば良いのですが一応実際のものを書いておくと</p>

<p>~/.config/common-lisp/source-registry.conf に
<code>lisp
(:source-registry
  (:tree "~/quicklisp/dists/")
  (:tree (:home "Lisp/"))
  :INHERIT-CONFIGURATION)
</code>
を書けばOKです。2つめのLisp/は私がCommon Lispファイルを置いているディレクトリですね。この書き方だとquicklispより自分のLispライブラリを優先して読みにいきます。開発版を使いたいときとかむしろ開発をするときとかに必須です。この設定をミスるといくら開発してもロードされてるのはリリース版で、機能が動かないとかの地獄を見ます。</p>

<p>ここまでくれば</p>

<p><code>lisp
(require 'asdf)
(require 'hoge)
</code>
とすればquicklispでインストールしたライブラリをロード出来ます。</p>

<h2>require以外のASDFの使い方</h2>

<p>バージョンに依って使い方が異なるのですが、3系だと<code>(asdf:xxx-system 'hoge)</code>などとします。具体的には</p>

<ul>
<li><code>(asdf:load-system 'hoge)</code> ( = <code>(require 'hoge)</code>)</li>
<li><code>(asdf:test-system 'hoge)</code> (テストがあるときのみ)</li>
<li><code>(asdf:compile-system 'hoge)</code></li>
</ul>


<p>を覚えておけば良いでしょう。他にもいくつか操作があるようですが私は使ったことがないです。<code>asdf:locate-system</code>は名前的に便利そうではあるんですけどね。</p>

<p>開発するときはまず.asdファイルを書いておいて(あるいはcl-projectから生成して)、<code>(require 'hoge)</code>で始めて書いていき、ある程度進んだらテストを書いてテストの項目を.asdファイルに書き足して<code>(asdf:test-system 'hoge)</code>、それなりに動くようになったら<code>(asdf:compile-system 'hoge)</code>してコンパイルの様子を見たりコンパイル後のベンチマークを取ったりします。</p>

<h2>quickloadを成仏させる</h2>

<p>これでロードの処理はASDFで全てカバー出来るようになりました。じゃあquickloadのロード機能は邪魔ですね。quicklispをインストーラとしてのみ使いましょう。</p>

<p>まず処理系の初期化ファイル(sbclなら~/.sbclrc)から</p>

<p>```lisp
;;; The following lines added by ql:add-to-init-file:</p>

<h1>-quicklisp</h1>

<p>(let ((quicklisp-init (merge-pathnames &ldquo;~quicklisp/setup.lisp&rdquo;</p>

<pre><code>                                   (user-homedir-pathname))))
</code></pre>

<p>  (when (probe-file quicklisp-init)</p>

<pre><code>(load quicklisp-init :verbose nil)))
</code></pre>

<p>```</p>

<p>を削除します。quicklispを使いたいときだけ<code>(load "~/quicklisp/setup.lisp")</code>します。そして欲しいシステムをインストールするには</p>

<p><code>lisp
(ql::recursively-install "foo")
</code></p>

<p>します。quickloadに比べて爆速です。ここにきて名前が文字列な上にexportされてないシンポル参照してますね。気持ち悪いという方は大人しくquickloadしましょう。</p>

<p>拙作のCIMにはこれをコマンドラインから行なう<code>ql install</code>なるコマンドが存在します。</p>

<h1>最後に</h1>

<p>quicklispが嫌いなのは私の好みですがASDFを正しく使えて損はないと思うので知らなかった方々は是非試してみて下さい。</p>
]]></content>
  </entry>
  
</feed>
