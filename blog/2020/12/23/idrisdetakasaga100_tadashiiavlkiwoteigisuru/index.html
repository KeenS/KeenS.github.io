<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="Idrisの依存型で高さが100%正しいAVL木を定義する | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="このエントリはIdris Advent Calendar 2020の22日目の記事です。

κeenです。今回は依存型を使って部分的に正しさを証明したデータ構造を作っていきたいと思います。
慣れてない人には難しめの内容になるかもしれません。" />
        <meta property="og:title" content="Idrisの依存型で高さが100%正しいAVL木を定義する | κeenのHappy Hacκing Blog" />
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https://KeenS.github.io/blog/2020/12/23/idrisdetakasaga100_tadashiiavlkiwoteigisuru/" />
        <meta property="og:description" content="このエントリはIdris Advent Calendar 2020の22日目の記事です。

κeenです。今回は依存型を使って部分的に正しさを証明したデータ構造を作っていきたいと思います。
慣れてない人には難しめの内容になるかもしれません。" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta property="og:image" content="https://KeenS.github.io/images/ogp/post/Idrisdetakasaga100_tadashiiAVLkiwoteigisuru.png" />
        <meta name="twitter:image" content="https://KeenS.github.io/images/ogp/post/Idrisdetakasaga100_tadashiiAVLkiwoteigisuru.png" />
        
        <meta property="og:article:published_time" content="2020-12-23 20:29:01 &#43;0900 JST" />
        <meta property="og:article:modified_time" content="2020-12-23 20:29:01 &#43;0900 JST" />
        
        <meta property="og:article:author" content="κeen" />

        <title>Idrisの依存型で高さが100%正しいAVL木を定義する | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css' />
        <link rel="stylesheet" href="https://KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/liquorice.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="https://KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="https://KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="https://KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
        <link rel="apple-touch-icon-precomposed" href="https://KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/syntax-monokai.css" />
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<link rel="stylesheet" href="//unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css">

    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="https://KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="https://KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="https://KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                    <header class="li-article-header">
                        <h1 class="li-article-title">Idrisの依存型で高さが100%正しいAVL木を定義する</h1>
                        <div class="li-article-meta">
    <time class="li-article-date">2020-12-23</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="https://KeenS.github.io/categories/%e4%be%9d%e5%ad%98%e5%9e%8b">依存型</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/idris">Idris</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/idris-advent-calendar">Idris Advent Calendar</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/advent-calendar-2020">Advent Calendar 2020</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/advent-calendar">Advent Calendar</a>
        </li>
    
</ul>

</div>

                    </header>
                    <section>
                        <p>このエントリは<a href="https://qiita.com/advent-calendar/2020/idris">Idris Advent Calendar 2020</a>の22日目の記事です。</p>

<p>κeenです。今回は依存型を使って部分的に正しさを証明したデータ構造を作っていきたいと思います。
慣れてない人には難しめの内容になるかもしれません。</p>

<h1 id="証明オブジェクト">証明オブジェクト</h1>

<p>本題に入る前に、依存型の難しさについて触れたいと思います。</p>

<p>自然数から1引く <code>dec</code> 関数を定義します。
以下のようなコードになりますよね？</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">dec</span> <span class="ow">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span>
dec n <span class="ow">=</span> n <span class="ow">-</span> <span class="mi">1</span></code></pre></div>
<p>ところがこれ、コンパイルエラーになります。
メッセージは以下です。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">- + Errors (1)
 `-- dec.idr line 3 col 10:
     When checking right hand side of dec with expected type
             Nat
     
     When checking argument smaller to function Prelude.Nat.-:
             Can&#39;t find a value of type 
                     LTE 1 n</code></pre></div>
<p>何故か &ldquo;Can&rsquo;t find a value of type&rdquo; といってますね。これは <code>Nat.(-)</code> のドキュメントを見ると分かります。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Prelude.Nat.(-) : (m : Nat) -&gt; (n : Nat) -&gt; {auto smaller : LTE n m} -&gt; Nat
    
    infixl 8
    
    The function is: Total &amp; public export</code></pre></div>
<p>引数に <code>m</code> と <code>n</code> の他に <code>{auto smaller : LTE n m}</code> がありますね。
これは <strong>証明オブジェクト</strong> を要求しているのです。
どういうことか説明しましょう。</p>

<p>まず、今計算している対象は自然数なので負になれません。
そもそも自由に引き算できない対象な訳です。
ですが、引かれる数が引く数以上であれば結果が0以上であることが保証できるので計算できますね。
<code>Nat.(-)</code> はそういうケースを想定したAPIです。
この「引かれる数が引く数以上である」を表わす値が証明オブジェクトです。
このことは <code>LTE</code> のドキュメントからも確認できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Idris&gt; :doc LTE
Data type Prelude.Nat.LTE : (n : Nat) -&gt; (m : Nat) -&gt; Type
    Proofs that n is less than or equal to m
    Arguments:
        n : Nat  -- the smaller number
        
        m : Nat  -- the larger number
        
    The function is: public export</code></pre></div>
<p><code>LTE n m</code> で <code>n &lt;= m</code> を表わします。</p>

<p>これを踏まえて <code>Prelude.Nat.(-)</code> の型を意訳すると、 「<code>m</code> から <code>n</code> を引きたければ <code>n</code> が <code>m</code> 以下である証明をもってこい」となるのです。
言われてみればそうですよね。</p>

<p>ここまでの話が分からなかったら、以下のことだけ覚えておいて下さい</p>

<p>「自然数同士の引き算は面倒くさい」</p>

<p>これを押さえたら本題に入ります。</p>

<h1 id="avl木">AVL木</h1>

<p><a href="https://ja.wikipedia.org/wiki/AVL%E6%9C%A8">AVL木</a>とは平衡二分探索木の1種です。
二分木なので左右の腕がある訳ですが、その腕同士の高さが、高々1しか違わない木です。
ここではあまり説明しないのでWikipediaの記事を読んで下さい</p>

<p>1つだけ重要なのは<a href="https://ja.wikipedia.org/wiki/%E6%9C%A8%E3%81%AE%E5%9B%9E%E8%BB%A2">木の回転</a>という操作があることです。
新たに要素を追加した結果、左右の腕の高さが2違うようになることがあります。
そうなった場合に木を組み替えて左右の腕の高さが高々1しか違わないようにする操作が回転です。</p>

<p>この木の高さを正しく維持するのは複雑で、よく間違えます。
なので依存型を使ってコンパイル時に正しいことを保証しよう、というのが今回の趣旨です。</p>

<h1 id="依存型を使ったavl木の定義">依存型を使ったAVL木の定義</h1>

<h2 id="定義1">定義1</h2>

<p>高さ <code>h</code> のAVL木の左右の腕の高さは <code>h - 1</code> または <code>h - 2</code> （ただし左右同時に <code>h - 2</code> にはならない）です。
正確には木の高さを $h$ 、左の木の高さを $hl$ 、 右の木の高さを $hr$ としたとき、以下の関係式を満たします。</p>

<p>\[
 (hl = h - 2 \land hr = h - 1) \lor
 (hl = h - 1 \land hr = h - 1) \lor
 (hl = h - 1 \land hr = h - 2)
\]</p>

<p>これを型にエンコードしたAVL木を定義すればよさそうです。
ただし先程紹介したように <code>-</code> は扱いが面倒なので移項して足し算にして、以下の定義が考えられます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">infixr</span> <span class="mi">1</span> <span class="ow">\/</span>, <span class="ow">/\</span>

<span class="ow">(\/)</span> <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
<span class="ow">(\/)</span> a b <span class="ow">=</span> <span class="kt">Either</span> a b

<span class="ow">(/\)</span> <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
<span class="ow">(/\)</span> a b <span class="ow">=</span> <span class="ow">(</span>a, b<span class="ow">)</span>

<span class="kr">data</span> <span class="kt">Tree</span> <span class="ow">:</span> <span class="ow">(</span>n<span class="ow">:</span> <span class="kt">Nat</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>a <span class="ow">:</span> <span class="kt">Type</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="nf">Leaf</span><span class="ow">:</span> <span class="kt">Tree</span> <span class="kt">Z</span> a
  <span class="nf">Node</span> <span class="ow">:</span> <span class="ow">{</span>l, m<span class="ow">:</span> <span class="kt">Nat</span><span class="ow">}</span> <span class="ow">-&gt;</span>
   <span class="ow">((</span><span class="mi">2</span> <span class="ow">+</span> l <span class="ow">=</span> n<span class="ow">)</span> <span class="ow">/\</span> <span class="ow">(</span><span class="mi">1</span> <span class="ow">+</span> m <span class="ow">=</span> n<span class="ow">))</span> <span class="ow">\/</span>
   <span class="ow">((</span><span class="mi">1</span> <span class="ow">+</span> l <span class="ow">=</span> n<span class="ow">)</span> <span class="ow">/\</span> <span class="ow">(</span><span class="mi">1</span> <span class="ow">+</span> m <span class="ow">=</span> n<span class="ow">))</span> <span class="ow">\/</span>
   <span class="ow">((</span><span class="mi">1</span> <span class="ow">+</span> l <span class="ow">=</span> n<span class="ow">)</span> <span class="ow">/\</span> <span class="ow">(</span><span class="mi">2</span> <span class="ow">+</span> m <span class="ow">=</span> n<span class="ow">))</span> <span class="ow">-&gt;</span>
   <span class="kt">Tree</span> l a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> m a <span class="ow">-&gt;</span> <span class="kt">Tree</span> n a</code></pre></div>
<p><code>Node</code> 引数のの前半が重いですね。
これは何をしているかというと、証明オブジェクトを受け取っているということになります。</p>

<p>これでも正しくエンコードできているのですが、例の「面倒くさい」証明オブジェクトが登場してしまいました。
証明オブジェクトが出てきても面倒なだけでプログラムは書けるのですが、どうしても冗長になりがちです。
試しにこの定義に対して操作を書いてみたら、後で出てくる6行の関数 <code>rotateR</code> がこの定義だと48行になってました。
ちょっとやってられないので別の定義を採ることにします。</p>

<h2 id="定義2">定義2</h2>

<p>先程は条件分岐を1箇所に押し込もうとして冗長になってました。
条件分岐は左が右より1高い、左右が同じ高さ、右が左より1高いの3通りです。
であれば、3通りをバラしてしまえばよさそうです。
するとこういう定義ができあがります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Tree</span> <span class="ow">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="ow">(</span>a <span class="ow">:</span> <span class="kt">Type</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="nf">Leaf</span><span class="ow">:</span> <span class="kt">Tree</span> <span class="kt">Z</span> a
  <span class="nf">Lefty</span>  <span class="ow">:</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span>    n  a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span> a
  <span class="nf">Mid</span>    <span class="ow">:</span> <span class="kt">Tree</span>    n  a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span>    n  a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span> a
  <span class="nf">Righty</span> <span class="ow">:</span> <span class="kt">Tree</span>    n  a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span> a</code></pre></div>
<p>これでもおおむねよいのですが、左右の高さに関係のない関数が冗長になってしまいます。
例えば要素が含まれるかを検査する <code>member</code> 関数は3回同じことを書かないといけなくなります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">member</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> <span class="kt">Bool</span>
member <span class="kr">_</span> <span class="kt">Leaf</span> <span class="ow">=</span> <span class="kt">False</span>
member x <span class="ow">(</span><span class="kt">Lefty</span>  l v r<span class="ow">)</span> <span class="kr">with</span> <span class="ow">(</span>compare x v<span class="ow">)</span>
  <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> member x l
  <span class="ow">|</span> <span class="kt">EQ</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="ow">|</span> <span class="kt">GT</span> <span class="ow">=</span> member x r
member x <span class="ow">(</span><span class="kt">Mid</span>    l v r<span class="ow">)</span> <span class="kr">with</span> <span class="ow">(</span>compare x v<span class="ow">)</span>
  <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> member x l
  <span class="ow">|</span> <span class="kt">EQ</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="ow">|</span> <span class="kt">GT</span> <span class="ow">=</span> member x r
member x <span class="ow">(</span><span class="kt">Righty</span> l v r<span class="ow">)</span> <span class="kr">with</span> <span class="ow">(</span>compare x v<span class="ow">)</span>
  <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> member x l
  <span class="ow">|</span> <span class="kt">EQ</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="ow">|</span> <span class="kt">GT</span> <span class="ow">=</span> member x r</code></pre></div>
<p>このくらいであれば必要経費とすることもできるのですが、もうちょっと上手くやる方法があります。</p>

<h2 id="定義3">定義3</h2>

<p><a href="https://keens.github.io/blog/2020/12/22/idrisomoshirokinou_withkoubuntoview/">View</a>のことを思い出してほしいのですが、依存型で値同士の関係をうまいこと制御できるのでした。
この仕組みを使うともう少し整理できます。
左右の木の高さを表現するビューと、実際のデータ構造に分けて管理するのです。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Balance</span> <span class="ow">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="nf">Lefty</span>  <span class="ow">:</span> <span class="kt">Balance</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span>    n
  <span class="nf">Mid</span>    <span class="ow">:</span> <span class="kt">Balance</span>    n     <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span>     n
  <span class="nf">Righty</span> <span class="ow">:</span> <span class="kt">Balance</span>    n  <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span>

<span class="kr">data</span> <span class="kt">Tree</span> <span class="ow">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="ow">(</span>a <span class="ow">:</span> <span class="kt">Type</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="nf">Leaf</span> <span class="ow">:</span> <span class="kt">Tree</span> <span class="kt">Z</span> a
  <span class="nf">Node</span> <span class="ow">:</span> <span class="kt">Balance</span> l n r <span class="ow">-&gt;</span> <span class="kt">Tree</span> l a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> r a <span class="ow">-&gt;</span> <span class="kt">Tree</span> n a</code></pre></div>
<p>これなら十分整理されていると言えるでしょう。この定義を使っていきます。</p>

<h1 id="avl木の簡単な操作">AVL木の簡単な操作</h1>

<p>以下のような簡単な操作ならすぐさま書けるでしょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">empty</span> <span class="ow">:</span> <span class="kt">Tree</span> <span class="kt">Z</span> a
empty <span class="ow">=</span> <span class="kt">Leaf</span>

<span class="kr">total</span>
<span class="nf">singleton</span> <span class="ow">:</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="ow">)</span> a
singleton x <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Mid</span> <span class="kt">Leaf</span> x <span class="kt">Leaf</span>

<span class="kr">total</span>
<span class="nf">member</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> <span class="kt">Bool</span>
member <span class="kr">_</span> <span class="kt">Leaf</span> <span class="ow">=</span> <span class="kt">False</span>
member x <span class="ow">(</span><span class="kt">Node</span> <span class="kr">_</span>   l v r<span class="ow">)</span> <span class="kr">with</span> <span class="ow">(</span>compare x v<span class="ow">)</span>
  <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> member x l
  <span class="ow">|</span> <span class="kt">EQ</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="ow">|</span> <span class="kt">GT</span> <span class="ow">=</span> member x r</code></pre></div>
<p><code>member</code> 関数がちゃんと短かくなってるのがポイントですね。</p>

<h1 id="avl木への挿入">AVL木への挿入</h1>

<p>AVL木は強めに平衡のとれた木なので要素を増減させる操作が重いです。</p>

<p>ちょっとずつ便利関数を積み重ねていきましょう。
まずはノードを作る関数3つ。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">createR</span> <span class="ow">:</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span> a
createR l x r <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Righty</span> l x r

<span class="kr">total</span>
<span class="nf">createM</span> <span class="ow">:</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span> a
createM l x r <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Mid</span> l x r

<span class="kr">total</span>
<span class="nf">createL</span> <span class="ow">:</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span> a
createL l x r <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Lefty</span> l x r</code></pre></div>
<p>ちゃんと高さが正しいものしか作れないような型になっています。
一方でそのために <code>create</code> 関数が3種類に分かれてしまっています。</p>

<p>次が木の右回転をする <code>rotateR</code> 関数です。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">rotateR</span> <span class="ow">:</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="ow">(</span><span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span> a<span class="ow">)</span> <span class="ow">(</span><span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)))</span> a<span class="ow">)</span>
rotateR <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  ll lv lr<span class="ow">)</span>                        v r <span class="ow">=</span> <span class="kt">Left</span>  <span class="ow">$</span> createM          ll lv          <span class="ow">(</span>createM lr  v r<span class="ow">)</span>
rotateR <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Mid</span>    ll lv lr<span class="ow">)</span>                        v r <span class="ow">=</span> <span class="kt">Right</span> <span class="ow">$</span> createR          ll lv          <span class="ow">(</span>createL lr  v r<span class="ow">)</span>
rotateR <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> ll lv <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  lrl lrv lrr<span class="ow">))</span> v r <span class="ow">=</span> <span class="kt">Left</span>  <span class="ow">$</span> createM <span class="ow">(</span>createM ll lv lrl<span class="ow">)</span> lrv <span class="ow">(</span>createR lrr v r<span class="ow">)</span>
rotateR <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> ll lv <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Mid</span>    lrl lrv lrr<span class="ow">))</span> v r <span class="ow">=</span> <span class="kt">Left</span>  <span class="ow">$</span> createM <span class="ow">(</span>createM ll lv lrl<span class="ow">)</span> lrv <span class="ow">(</span>createM lrr v r<span class="ow">)</span>
rotateR <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> ll lv <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> lrl lrv lrr<span class="ow">))</span> v r <span class="ow">=</span> <span class="kt">Left</span>  <span class="ow">$</span> createM <span class="ow">(</span>createL ll lv lrl<span class="ow">)</span> lrv <span class="ow">(</span>createM lrr v r<span class="ow">)</span></code></pre></div>
<p>実装は二分木の回転を実装したことのある方なら見慣れてるかと思いますが、型がちょっと独特です。
返り型 <code>Either (Tree (S (S n)) a) (Tree (S (S (S n))) a)</code> と <code>Either</code> の形になっています。
木の回転をすると高さが1増える場合と増えない場合があるのです。その場合分けのために <code>Either</code> を使っています。
<code>Left</code> が高さが変わらない場合で、 <code>Right</code> が高さが1増える場合ですね。
依存型のついていない普通の関数なら高さが違っても型は同じなので気にしなくていいのですが、今回は必要な分岐です。</p>

<p>これと同様に左回転の <code>rotateL</code> も実装できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">rotateL</span> <span class="ow">:</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span> a <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="ow">(</span><span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">))</span> a<span class="ow">)</span> <span class="ow">(</span><span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)))</span> a<span class="ow">)</span>
rotateL l v <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  rll rlv rlr<span class="ow">)</span> rv rr<span class="ow">)</span> <span class="ow">=</span> <span class="kt">Left</span>  <span class="ow">$</span> createM <span class="ow">(</span>createM l v rll<span class="ow">)</span> rlv <span class="ow">(</span>createR rlr rv rr<span class="ow">)</span>
rotateL l v <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Mid</span>    rll rlv rlr<span class="ow">)</span> rv rr<span class="ow">)</span> <span class="ow">=</span> <span class="kt">Left</span>  <span class="ow">$</span> createM <span class="ow">(</span>createM l v rll<span class="ow">)</span> rlv <span class="ow">(</span>createM rlr rv rr<span class="ow">)</span>
rotateL l v <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> rll rlv rlr<span class="ow">)</span> rv rr<span class="ow">)</span> <span class="ow">=</span> <span class="kt">Left</span>  <span class="ow">$</span> createM <span class="ow">(</span>createL l v rll<span class="ow">)</span> rlv <span class="ow">(</span>createM rlr rv rr<span class="ow">)</span>
rotateL l v <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Mid</span>    rl                        rv rr<span class="ow">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="ow">$</span> createL <span class="ow">(</span>createR l v rl<span class="ow">)</span>                   rv rr
rotateL l v <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> rl                        rv rr<span class="ow">)</span> <span class="ow">=</span> <span class="kt">Left</span>  <span class="ow">$</span> createM <span class="ow">(</span>createM l v rl<span class="ow">)</span>                   rv rr</code></pre></div>
<p>それでは準備が整ったので挿入を定義しましょう。
挿入は回転と同じく木の高さが変わったり変わらなかったりする操作です。
なので型は以下のようになります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">insert</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="ow">(</span><span class="kt">Tree</span> n a<span class="ow">)</span> <span class="ow">(</span><span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span> a<span class="ow">)</span></code></pre></div>
<p>続いて簡単な場合から潰していきましょう。
<code>Leaf</code> への挿入はシングルトンで一撃です。高さは1増えます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">insert x <span class="kt">Leaf</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="ow">$</span> singleton x</code></pre></div>
<p>それ以外の場合はノードの値と挿入しようとしてる値の大小関係を比較して <code>with</code> 構文でひとまとめにパターンマッチしましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">insert x <span class="ow">(</span><span class="kt">Node</span> bal l v r<span class="ow">)</span> <span class="kr">with</span> <span class="ow">(</span>compare x v<span class="ow">)</span></code></pre></div>
<p>それぞれ場合分けしていくのですが、 <code>x</code> と <code>v</code> が等しい場合は挿入せずにそのまま終了します。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">  insert x <span class="ow">(</span><span class="kt">Node</span> bal    l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">EQ</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="ow">$</span> <span class="kt">Node</span> bal    l v r</code></pre></div>
<p><code>x</code> が <code>v</code> より小さい場合は左の木に <code>x</code> を挿入します。</p>

<p>ここで <code>Balance</code> の値に応じて依存型で使っている数値が変化することを思い出して下さい。
この挙動を利用するには <code>Balance</code> の値に対してパターンマッチしないといけません。
ちょっと面倒ですが <code>Balance</code> の値で分岐したあとに <code>x</code> を左の木に挿入することになります。。
つまりこのようなコードになります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="ow">...</span>
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Mid</span>    l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="ow">...</span>
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="ow">...</span></code></pre></div>
<p>それぞれのケースで、 <code>Left</code> の場合、すなわち挿入前と挿入後で木の高さが変わらなかった場合は挿入前と <code>Balance</code> は変わりません。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="kt">Left</span>  l <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Lefty</span> l v r
    <span class="ow">...</span>
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Mid</span>    l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="kt">Left</span>  l <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Mid</span>   l v r
    <span class="ow">...</span>
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="kt">Left</span>  l <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Righty</span> l v r
    <span class="ow">...</span></code></pre></div>
<p><code>Right</code> の場合、すなわち挿入前から高さが1増えた場合は <code>Righty</code> → <code>Mid</code> 、 <code>Mid</code> → <code>Lefty</code> へと変化します。では <code>Lefty</code> の場合はどうなるかというと、回転が発生します。左に寄りすぎたので右回転ですね。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="ow">...</span>
    <span class="kt">Right</span> l <span class="ow">=&gt;</span> rotateR            l v r
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Mid</span>    l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="ow">...</span>
    <span class="kt">Right</span> l <span class="ow">=&gt;</span> <span class="kt">Right</span> <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Lefty</span> l v r
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="ow">...</span>
    <span class="kt">Right</span> l <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Mid</span>    l v r</code></pre></div>
<p>これと同様に <code>x</code> が <code>v</code> より大きい場合も書けますね。
総合して <code>insert</code> は以下のような見た目になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">insert</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Tree</span> n a <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="ow">(</span><span class="kt">Tree</span> n a<span class="ow">)</span> <span class="ow">(</span><span class="kt">Tree</span> <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span> a<span class="ow">)</span>
insert x <span class="kt">Leaf</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="ow">$</span> singleton x
insert x <span class="ow">(</span><span class="kt">Node</span> bal l v r<span class="ow">)</span> <span class="kr">with</span> <span class="ow">(</span>compare x v<span class="ow">)</span>
  insert x <span class="ow">(</span><span class="kt">Node</span> bal    l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">EQ</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="ow">$</span> <span class="kt">Node</span> bal    l v r
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="kt">Left</span>  l <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Lefty</span> l v r
    <span class="kt">Right</span> l <span class="ow">=&gt;</span> rotateR            l v r
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Mid</span>    l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="kt">Left</span>  l <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Mid</span>   l v r
    <span class="kt">Right</span> l <span class="ow">=&gt;</span> <span class="kt">Right</span> <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Lefty</span> l v r
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">LT</span> <span class="ow">=</span> <span class="kr">case</span> insert x l <span class="kr">of</span>
    <span class="kt">Left</span>  l <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Righty</span> l v r
    <span class="kt">Right</span> l <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Mid</span>    l v r
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Lefty</span>  l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">GT</span> <span class="ow">=</span> <span class="kr">case</span> insert x r <span class="kr">of</span>
    <span class="kt">Left</span>  r <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Lefty</span>  l v r
    <span class="kt">Right</span> r <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Mid</span>    l v r
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Mid</span>    l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">GT</span> <span class="ow">=</span> <span class="kr">case</span> insert x r <span class="kr">of</span>
    <span class="kt">Left</span>  r <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Mid</span>    l v r
    <span class="kt">Right</span> r <span class="ow">=&gt;</span> <span class="kt">Right</span> <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Righty</span> l v r
  insert x <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Righty</span> l v r<span class="ow">)</span> <span class="ow">|</span> <span class="kt">GT</span> <span class="ow">=</span> <span class="kr">case</span> insert x r <span class="kr">of</span>
    <span class="kt">Left</span>  r <span class="ow">=&gt;</span> <span class="kt">Left</span>  <span class="ow">$</span> <span class="kt">Node</span> <span class="kt">Righty</span> l v r
    <span class="kt">Right</span> r <span class="ow">=&gt;</span> rotateL             l v r</code></pre></div>
<p>依存型で高さを保ったAVL木の操作が書けました。
型で高さに矛盾がないことを表現しているので、テストなどを書かなくても高さについてはバグがないことが保証できます。</p>

<p>これで木を作れるようになったので試してみましょう。
<code>(insert 1 (insert 10 (insert 3 (insert 1 empty))))</code> で <code>1</code> 、 <code>10</code> 、 <code>3</code> が入った木を作れるはずです。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Idris&gt; :let tree = (insert 1 (insert 10 (insert 3 (insert 1 empty))))
(input):1:14-61:When checking an application of function Main.insert:
        Type mismatch between
                Tree n1 a2 \/ Tree (S n1) a2 (Type of insert _ _)
        and
                Tree n a (Expected type)
        
        Specifically:
                Type mismatch between
                        Either (Tree n1 a2) (Tree (S n1) a2)
                and
                        Tree n a</code></pre></div>
<p>…あれ？何やらエラーが出ていますね。
思い出すと <code>insert</code> の返り型は <code>Either (Tree n a) (Tree (S n) a)</code> なので木ではなく <code>Either</code> 型の値が返っています。これでは連続して <code>insert</code> できませんね。</p>

<p>もう少し言うとこの木を使うユーザに、木の高さで分岐を強要するAPIになっています。
これはいささか以上に不便です。
内部の正しさを保証するのに木の高さを型にエンコードするのはよいのですが、APIでは型から木の高さを消しましょう。</p>

<h1 id="依存ペアによる型消去">依存ペアによる型消去</h1>

<p>APIでは型から木の高さを消しましょうといいましたが、型を消去するなんてできるのでしょうか。
結論からいうと、できます。
くどい話は先送りにして、以下のように書けば型から高さの情報を消せます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Set</span> <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="nf">MkSet</span> <span class="ow">:</span> <span class="ow">(</span>n<span class="ow">:</span> <span class="kt">Nat</span> <span class="ow">**</span> <span class="kt">Tree</span> n a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> a</code></pre></div>
<p>ここでポイントになるのが <code>(n: Nat ** Tree n a)</code> という型です。
「ある自然数 <code>n</code> が存在して、高さ <code>n</code> なる木 <code>Tree n a</code> 」を表現しています。</p>

<p>この型は依存ペア、依存和、Σ型などと呼ばれます（<a href="http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#dependent-pairs">公式ドキュメントでは依存ペア</a>）。
文法がちょっと変わってるのですが、 <code>(変数名: 型 ** &lt;変数を使った型&gt;)</code> の構文です。
さきほど「ある 〜 が存在して」と紹介しましたが、論理学でいう存在量化に相当する機能です。</p>

<p>依存ペアを使うことで依存型を消去できるのです。説明が難しいので細かな解説はあきらめます。</p>

<p>さて、この定義を使ってAPIを定義していきましょう。</p>

<p>手始めに、さっきまでのコードを <code>Internal</code> の名前空間に押し込めましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">name</span>space <span class="kt">Internal</span>
  <span class="kr">data</span> <span class="kt">Balanse</span> <span class="ow">...</span>

  <span class="ow">...</span>
  <span class="kr">total</span>
  <span class="nf">inssert</span> <span class="ow">:</span> <span class="ow">...</span>
  <span class="ow">...</span></code></pre></div>
<p>そしてAPIを定義しはじめます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Set</span> <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="nf">MkSet</span> <span class="ow">:</span> <span class="ow">(</span>n<span class="ow">:</span> <span class="kt">Nat</span> <span class="ow">**</span> <span class="kt">Internal</span><span class="ow">.</span><span class="kt">Tree</span> n a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> a</code></pre></div>
<p>なんだかんだ、APIとして提供できるのは <code>empty</code> 、 <code>insert</code> 、 <code>member</code> くらいですね。これらのラッパーを書きましょう。</p>

<p>まずは <code>empty</code> 。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">empty</span> <span class="ow">:</span> <span class="kt">Set</span> a
empty <span class="ow">=</span> <span class="kt">MkSet</span> <span class="ow">(</span><span class="kr">_</span> <span class="ow">**</span> <span class="kt">Internal</span><span class="ow">.</span>empty<span class="ow">)</span></code></pre></div>
<p>依存ペアの値は <code>(値 ** 値)</code> の構文で作ります。
ところが左側の値、ここでいうの高さは右側の値から簡単に分かります。
そういう場合は <code>_</code> と書くとコンパイラが勝手に埋めてくれます。</p>

<p><code>member</code> 関数も簡単ですね。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">member</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Set</span> a <span class="ow">-&gt;</span> <span class="kt">Bool</span>
member x <span class="ow">(</span><span class="kt">MkSet</span> <span class="ow">(</span><span class="kr">_</span> <span class="ow">**</span> tree<span class="ow">))</span> <span class="ow">=</span> <span class="kt">Internal</span><span class="ow">.</span>member x tree</code></pre></div>
<p><code>insert</code> もほぼラップするだけですが、返り値が <code>Either</code> なのを思い出して <code>Left</code> と <code>Right</code> で処理を分けます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">insert</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Set</span> a <span class="ow">-&gt;</span> <span class="kt">Set</span> a
insert x <span class="ow">(</span><span class="kt">MkSet</span> <span class="ow">(</span><span class="kr">_</span> <span class="ow">**</span> tree<span class="ow">))</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="kt">Internal</span><span class="ow">.</span>insert x tree <span class="kr">of</span>
    <span class="kt">Left</span> t  <span class="ow">=&gt;</span> <span class="kt">MkSet</span> <span class="ow">(</span><span class="kr">_</span> <span class="ow">**</span> t<span class="ow">)</span>
    <span class="kt">Right</span> t <span class="ow">=&gt;</span> <span class="kt">MkSet</span> <span class="ow">(</span><span class="kr">_</span> <span class="ow">**</span> t<span class="ow">)</span></code></pre></div>
<p>因みに木の高さは値として保存されているので取り出すこともできます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">total</span>
<span class="nf">height</span> <span class="ow">:</span> <span class="kt">Set</span> a <span class="ow">-&gt;</span> <span class="kt">Nat</span>
height <span class="ow">(</span><span class="kt">MkSet</span> <span class="ow">(</span>height <span class="ow">**</span> <span class="kr">_</span><span class="ow">))</span> <span class="ow">=</span> height</code></pre></div>
<p>さてさて、これで役者が揃ったので今度こそ動いているか試せます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">Idris&gt;</span> <span class="ow">:</span><span class="kr">let</span> tree <span class="ow">=</span> <span class="ow">(</span>insert <span class="mi">1</span> <span class="ow">(</span>insert <span class="mi">10</span> <span class="ow">(</span>insert <span class="mi">3</span> <span class="ow">(</span>insert <span class="mi">1</span> empty<span class="ow">))))</span>
defined
<span class="kt">Idris</span><span class="ow">&gt;</span> member <span class="mi">1</span> tree
<span class="nf">True</span> <span class="ow">:</span> <span class="kt">Bool</span>
<span class="kt">Idris</span><span class="ow">&gt;</span> member <span class="mi">2</span> tree
<span class="nf">False</span> <span class="ow">:</span> <span class="kt">Bool</span>
<span class="kt">Idris</span><span class="ow">&gt;</span> member <span class="mi">3</span> tree
<span class="nf">True</span> <span class="ow">:</span> <span class="kt">Bool</span>
<span class="kt">Idris</span><span class="ow">&gt;</span> member <span class="mi">9</span> tree
<span class="nf">False</span> <span class="ow">:</span> <span class="kt">Bool</span>
<span class="kt">Idris</span><span class="ow">&gt;</span> member <span class="mi">10</span> tree
<span class="nf">True</span> <span class="ow">:</span> <span class="kt">Bool</span></code></pre></div>
<p>ちゃんと動いてますね。</p>

<h1 id="まとめ">まとめ</h1>

<p>依存型によって木の高さが正しいことが保証されたAVL木を作りました。
その過程で証明オブジェクトや依存ペアなどの機能も学びました。</p>

<h1 id="付録-今回のコード">付録: 今回のコード</h1>

<script src="https://gitlab.com/-/snippets/2053617.js"></script>
                    </section>
                </article>
            </div>
        </div>

        <div class="row li-author">
    <div class="sixteen columns">
        Written by <strong>κeen</strong>
    </div>
</div>


        <div class="row li-pagination">
            <div class="eight columns">
                <div class="li-pagination-previous">
                    
                        Later article<br />
                        <a href="https://KeenS.github.io/blog/2020/12/24/idrisnoffitocodegen_c_javascript_/"> IdrisのFFIとCodegen（C、JavaScript）</a>
                    
                </div>
            </div>
            <div class="eight columns">
                <div class="li-pagination-next">
                    
                        Older article<br />
                        <a href="https://KeenS.github.io/blog/2020/12/22/idrisomoshirokinou_bungeitekiidris/"> Idris面白機能：文芸的Idris</a>
                    
                </div>
            </div>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2021. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="https://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>

