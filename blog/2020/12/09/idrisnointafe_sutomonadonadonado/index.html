<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="Idrisのインタフェースとモナドなどなど | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="このエントリはIdris Advent Calendar 2020の9日目の記事です。
κeenです。Idrisのインタフェースやモナドについて紹介します。" />
        <meta property="og:title" content="Idrisのインタフェースとモナドなどなど | κeenのHappy Hacκing Blog" />
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https://KeenS.github.io/blog/2020/12/09/idrisnointafe_sutomonadonadonado/" />
        <meta property="og:description" content="このエントリはIdris Advent Calendar 2020の9日目の記事です。
κeenです。Idrisのインタフェースやモナドについて紹介します。" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta property="og:image" content="https://KeenS.github.io/images/ogp/post/Idrisnointafe_sutomonadonadonado.png" />
        <meta name="twitter:image" content="https://KeenS.github.io/images/ogp/post/Idrisnointafe_sutomonadonadonado.png" />
        
        <meta property="og:article:published_time" content="2020-12-09 03:34:57 &#43;0900 JST" />
        <meta property="og:article:modified_time" content="2020-12-09 03:34:57 &#43;0900 JST" />
        
        <meta property="og:article:author" content="κeen" />

        <title>Idrisのインタフェースとモナドなどなど | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css' />
        <link rel="stylesheet" href="https://KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/liquorice.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="https://KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="https://KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="https://KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
        <link rel="apple-touch-icon-precomposed" href="https://KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/syntax-monokai.css" />
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<link rel="stylesheet" href="//unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css">

    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="https://KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="https://KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                        
                            <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="https://KeenS.github.io/search/"> Search </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="https://KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                    
                        <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="https://KeenS.github.io/search/"> Search </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                    <header class="li-article-header">
                        <h1 class="li-article-title">Idrisのインタフェースとモナドなどなど</h1>
                        <div class="li-article-meta">
    <time class="li-article-date">2020-12-09</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="https://KeenS.github.io/categories/idris">Idris</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/idris-advent-calendar">Idris Advent Calendar</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/advent-calendar-2020">Advent Calendar 2020</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/advent-calendar">Advent Calendar</a>
        </li>
    
</ul>

</div>

                    </header>
                    <section>
                        <p>このエントリは<a href="https://qiita.com/advent-calendar/2020/idris">Idris Advent Calendar 2020</a>の9日目の記事です。</p>
<p>κeenです。Idrisのインタフェースやモナドについて紹介します。</p>
<h1 id="インタフェース">インタフェース</h1>
<p>色々な言語にあるやつとだいたい一緒です。
厳密にいうとアドホックポリモーフィズムのための機構なのでHaskellの型クラスやRustのトレイトに例えた方がいいのですが、細かい話は置いておきましょう。</p>
<p><code>interface インタフェース名 型変数 where 本体</code> の構文で書きます。
本体の部分には値の型や実装などを書きます。値とは関数も含みます。
例えば任意の型の値を文字列にするインタフェース <code>Show</code> の定義は以下のように書けます。</p>
<p>例：インタフェース <code>Show</code> の定義</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl">interface <span class="kt">Show</span> a <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="nf">show</span> <span class="ow">:</span> a <span class="ow">-&gt;</span> <span class="kt">String</span>
</span></span></code></pre></div><p><code>a</code> が <code>Show</code> を実装する型を表します。
そして <code>show</code> には実装がありません。型だけ示しているのでインタフェースっぽいですね。
因みに、 <code>Show</code> はプレリュードに定義されているので自分で書かなくても使えます。</p>
<p>これを実装するには <code>インタフェース名 型名 where 本体</code> の構文を使います。</p>
<p>例： <code>Name</code> 型にインタフェース <code>Show</code> を実装するコード</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kr">record</span> <span class="kt">Name</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  constructor <span class="kt">MkName</span>
</span></span><span class="line"><span class="cl">  firstName, lastName<span class="ow">:</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">Show</span> <span class="kt">Name</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  show <span class="ow">(</span><span class="kt">MkName</span> firstName lastName<span class="ow">)</span> <span class="ow">=</span> firstName <span class="ow">++</span> <span class="s">&#34; &#34;</span> <span class="ow">++</span> lastName
</span></span></code></pre></div><p>実装の方には逆に型の宣言がありません。</p>
<p>実装した <code>Show</code> は普通の関数のように呼び出すだけで使えます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Idris&gt; show (MkName &#34;Edwin&#34; &#34;Brady&#34;)
</span></span><span class="line"><span class="cl">&#34;Edwin Brady&#34; : String
</span></span></code></pre></div><h2 id="デフォルト実装">デフォルト実装</h2>
<p>先ほどインタフェースの本体には関数の型や <em>実装</em> を書くと説明しました。
インタフェースに実装を持つこともできるんですね。</p>
<p>例えば等価比較を行なうためのインタフェース <code>Eq</code> はデフォルト実装を持ちます。</p>
<p>例：インタフェース <code>Eq</code> の定義</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl">interface <span class="kt">Eq</span> a <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="ow">(==)</span> <span class="ow">:</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span></span><span class="line"><span class="cl">    <span class="ow">(/=)</span> <span class="ow">:</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    x <span class="ow">/=</span> y <span class="ow">=</span> not <span class="ow">(</span>x <span class="ow">==</span> y<span class="ow">)</span>
</span></span><span class="line"><span class="cl">    x <span class="ow">==</span> y <span class="ow">=</span> not <span class="ow">(</span>x <span class="ow">/=</span> y<span class="ow">)</span>
</span></span></code></pre></div><p>等しい（ <code>==</code> ）は等しくない（ <code>/=</code> ）の逆だしその逆もまた然りという定義ですね。
どちらか一方だけ実装すればもう一方は自動でついてくる仕組みです。</p>
<h2 id="関連型">関連型</h2>
<p>Idrisでは特に特別なものではないんですが、HaskellやRustで関連型（associated type）と呼ばれているものも書けます。</p>
<p>例えばとある別の型からその型の値を取得できる <code>Extract</code> というインタフェースを考えてみましょう。それは以下のように定義できます。</p>
<p>例：インタフェース <code>Extract</code> の定義</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl">interface <span class="kt">Extract</span> a <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="nf">From</span><span class="ow">:</span> <span class="kt">Type</span>
</span></span><span class="line"><span class="cl">  <span class="nf">extract</span><span class="ow">:</span> <span class="kt">From</span> <span class="ow">-&gt;</span> a
</span></span></code></pre></div><p>この <code>From</code> が関連型です。
Idrisでは型も値なので関数や値のように普通にメンバーに書けばそれで済みます。</p>
<p>上記の型を <code>Name</code> に実装してみましょう。
まず準備として <code>Name</code> を保持する型 <code>Person</code> を定義しておきます。</p>
<p>例：<code>Person</code> 型の定義</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kr">record</span> <span class="kt">Person</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  constructor <span class="kt">MkPerson</span>
</span></span><span class="line"><span class="cl">  <span class="nf">age</span><span class="ow">:</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">  <span class="kr">name</span><span class="ow">:</span> <span class="kt">Name</span>
</span></span></code></pre></div><p>すると <code>Person</code> から <code>Name</code> を <code>extract</code> できるので、以下のように <code>Extract</code> を <code>name</code> に実装できます。</p>
<p>例：<code>Extract</code> を <code>Name</code> に実装するコード</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kt">Extract</span> <span class="kt">Name</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">From</span> <span class="ow">=</span> <span class="kt">Person</span>
</span></span><span class="line"><span class="cl">  extract <span class="ow">=</span> name
</span></span></code></pre></div><h2 id="多パラメータのインタフェース">多パラメータのインタフェース</h2>
<p>インタフェースの型パラメータは複数書くことができます。
例えばある型から別の型に変換するインタフェース <code>Cast</code> は以下のように定義されています。</p>
<p>例：プレリュードでのインタフェース <code>Cast</code> の定義</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl">interface <span class="kt">Cast</span> from to <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cast</span> <span class="ow">:</span> <span class="ow">(</span>orig <span class="ow">:</span> from<span class="ow">)</span> <span class="ow">-&gt;</span> to
</span></span></code></pre></div><p><code>from</code> と <code>to</code> の2つのパラメータがありますね。
実装するときも2つのパラメータを指定します。</p>
<p>例： <code>Cast</code> を <code>Double</code> と <code>Int</code> に定義するときの書き出し</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kt">Cast</span> <span class="kt">Double</span> <span class="kt">Int</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="c1">-- ...</span>
</span></span></code></pre></div><p><code>Cast</code> のパラメータに <code>Double</code> と <code>Int</code> を指定しています。
<code>cast</code> の実装はプリミティブの呼び出しになるので省略しました。</p>
<h1 id="インタフェースを実装できる条件">インタフェースを実装できる条件</h1>
<p>インタフェースの実装は1つの型につき1つしか持てません <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。また関数はインタフェースを実装できません。</p>
<p>例えば <code>Name</code> に対してもう1つの <code>Show</code> のインタンスを追加しようとするとコンパイルエラーになります。</p>
<p>例：2つ目の <code>Show</code> インタフェースを <code>Name</code> に実装しようとした際に出るエラー</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">- + Errors (1)
</span></span><span class="line"><span class="cl"> `-- (no file) line 0 col -1:
</span></span><span class="line"><span class="cl">     interface.idr:21:1-9:Main.Name implementation of Prelude.Show.Show already defined
</span></span></code></pre></div><p>逆に、意外と実装できるケースにプリミティブを含む既存の型にインタフェースを実装できるというものが挙げられます。</p>
<p>以下にその例を示します。</p>
<p>例：インタフェース <code>Zero</code> を定義し、それをプリミティブ <code>Int</code> に実装するコード</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl">interface <span class="kt">Zero</span> a <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="nf">zero</span> <span class="ow">:</span> a
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">Zero</span> <span class="kt">Int</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  zero <span class="ow">=</span> <span class="mi">0</span>
</span></span></code></pre></div><p>プリミティブである <code>Int</code> に対してインタフェースを実装できました。</p>
<h1 id="ジェネリクスとインタフェース">ジェネリクスとインタフェース</h1>
<p>ジェネリクスで扱う型に特定のインタフェースを実装していることを要求したい場合があります。</p>
<h2 id="ジェネリクス関数へのインタフェース制約">ジェネリクス関数へのインタフェース制約</h2>
<p>例えば引数を2つ受け取って、その小さい方、大きい方の順で並べて返す関数を定義したいとします。そのときに <code>&lt;</code> で比較する必要がありますよね。
今までの知識で関数を定義すると <code>&lt;</code> が実装されていないのでコンパイルエラーになります</p>
<p>例： <code>a</code> 同士を比較できないためエラーになるコード例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="nf">ordered</span><span class="ow">:</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="ow">(</span>a, a<span class="ow">)</span>
</span></span><span class="line"><span class="cl">ordered a b <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">if</span> a <span class="ow">&lt;</span> b
</span></span><span class="line"><span class="cl">  <span class="kr">then</span> <span class="ow">(</span>a, b<span class="ow">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">else</span> <span class="ow">(</span>b, a<span class="ow">)</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">- + Errors (1)
</span></span><span class="line"><span class="cl"> `-- interface.idr line 35 col 2:
</span></span><span class="line"><span class="cl">     When checking right hand side of ordered with expected type
</span></span><span class="line"><span class="cl">             (a, a)
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl">     When checking argument b to function Prelude.Bool.ifThenElse:
</span></span><span class="line"><span class="cl">             Can&#39;t find implementation for Ord a
</span></span></code></pre></div><p>そういうときは特定のインタフェースを実装している型のみ受け付ける制約を書きます。<code>インタフェース名 変数名 =&gt; 型</code> の構文です。<code>&lt;</code> 演算子は <code>Ord</code> インタフェースで定義されているため、上記の <code>ordered</code> を修正すると以下のようになります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="nf">ordered</span><span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="ow">(</span>a, a<span class="ow">)</span>
</span></span><span class="line"><span class="cl">ordered a b <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">if</span> a <span class="ow">&lt;</span> b
</span></span><span class="line"><span class="cl">  <span class="kr">then</span> <span class="ow">(</span>a, b<span class="ow">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">else</span> <span class="ow">(</span>b, a<span class="ow">)</span>
</span></span></code></pre></div><p>また、複数の制約を書きたい場合は <code>(インタフェース名 変数名, インタフェース名 変数名, ....) =&gt; 型</code> と丸括弧で括ってカンマで区切って書きます。</p>
<p>例：ジェネリクスの型変数に複数のインタフェース制約を書いたコード</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="nf">orderedMsg</span><span class="ow">:</span> <span class="ow">(</span><span class="kt">Ord</span> a, <span class="kt">Show</span> a<span class="ow">)</span> <span class="ow">=&gt;</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl">orderedMsg a b <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="ow">(</span>a, b<span class="ow">)</span> <span class="ow">=</span> ordered a b <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="ow">(</span>show a<span class="ow">)</span> <span class="ow">++</span> <span class="s">&#34; &lt; &#34;</span> <span class="ow">++</span> <span class="ow">(</span>show b<span class="ow">)</span>
</span></span></code></pre></div><h2 id="インタフェース実装へのインタフェース制約">インタフェース実装へのインタフェース制約</h2>
<p>インタフェース自身にも関数を含みますからインタフェースの実装にインタフェース制約を加えたいというのも自然な要求です。実際、そういう機能があります。
<code>インタフェース制約 =&gt; インタフェース名 型名 where 本体</code> の構文です。
以下に例を示します。</p>
<p>例：プレリュードのタプルへの <code>Eq</code> の実装例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="ow">(</span><span class="kt">Eq</span> a, <span class="kt">Eq</span> b<span class="ow">)</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="ow">(</span>a, b<span class="ow">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="ow">(==)</span> <span class="ow">(</span>a, c<span class="ow">)</span> <span class="ow">(</span>b, d<span class="ow">)</span> <span class="ow">=</span> <span class="ow">(</span>a <span class="ow">==</span> b<span class="ow">)</span> <span class="ow">&amp;&amp;</span> <span class="ow">(</span>c <span class="ow">==</span> d<span class="ow">)</span>
</span></span></code></pre></div><p>余談ですが、Idrisの3つ組以上のタプルは2つ組の組み合わせの糖衣構文となっています。例えば <code>(A, B, C)</code> は <code>(A, (B, C))</code> です。
なので上記の2つ組のタプルの実装で全てのタプルの実装をカバーできるのです。</p>
<h2 id="インタフェースの拡張">インタフェースの拡張</h2>
<p>インタフェース制約をインタフェースの宣言に書くこともできます。
これは事実上既存のインタフェースを拡張した新しいインタフェースを定義していると捉えることもできますね。
<code>interface インタフェース制約 =&gt; インタフェース名 型変数 where 本体</code> の構文になります。</p>
<p>例えばプレリュードの <code>Neg</code> は <code>Num</code> を拡張したインタフェースです。</p>
<p>例：プレリュードの <code>Num</code> と <code>Neg</code> のコード</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="c1">||| The Num interface defines basic numerical arithmetic.</span>
</span></span><span class="line"><span class="cl">interface <span class="kt">Num</span> ty <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="ow">(+)</span> <span class="ow">:</span> ty <span class="ow">-&gt;</span> ty <span class="ow">-&gt;</span> ty
</span></span><span class="line"><span class="cl">    <span class="ow">(*)</span> <span class="ow">:</span> ty <span class="ow">-&gt;</span> ty <span class="ow">-&gt;</span> ty
</span></span><span class="line"><span class="cl">    <span class="c1">||| Conversion from Integer.</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fromInteger</span> <span class="ow">:</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> ty
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">||| The `Neg` interface defines operations on numbers which can be negative.</span>
</span></span><span class="line"><span class="cl">interface <span class="kt">Num</span> ty <span class="ow">=&gt;</span> <span class="kt">Neg</span> ty <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="c1">||| The underlying of unary minus. `-5` desugars to `negate (fromInteger 5)`.</span>
</span></span><span class="line"><span class="cl">    <span class="nf">negate</span> <span class="ow">:</span> ty <span class="ow">-&gt;</span> ty
</span></span><span class="line"><span class="cl">    <span class="ow">(-)</span> <span class="ow">:</span> ty <span class="ow">-&gt;</span> ty <span class="ow">-&gt;</span> ty
</span></span></code></pre></div><h1 id="高カインド多相とファンクタ">高カインド多相とファンクタ</h1>
<p>少し難しめの機能に入ります。
特に複雑という訳ではないんですが、抽象度が高いので慣れてないと理解に時間のかかる機能です。</p>
<p><code>List a</code> や <code>Maybe a</code> のようにジェネリクスなデータ型がありますね？
これに対してインタフェースを定義したいとします。
例えば <code>map</code> なんかは分かりやすいでしょう。</p>
<p>例： <code>List a</code> と <code>Maybe a</code> に対する素朴な <code>map</code> の実装</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="c1">-- List</span>
</span></span><span class="line"><span class="cl"><span class="nf">map</span> <span class="ow">:</span> <span class="ow">(</span>a <span class="ow">-&gt;</span> b<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">List</span> a <span class="ow">-&gt;</span> <span class="kt">List</span> b
</span></span><span class="line"><span class="cl">map f <span class="ow">[]</span>      <span class="ow">=</span> <span class="ow">[]</span>
</span></span><span class="line"><span class="cl">map f <span class="ow">(</span>x<span class="ow">::</span>xs<span class="ow">)</span> <span class="ow">=</span> f x <span class="ow">::</span> map f xs
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- Maybe</span>
</span></span><span class="line"><span class="cl"><span class="nf">map</span> <span class="ow">:</span> <span class="ow">(</span>a <span class="ow">-&gt;</span> b<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> a <span class="ow">-&gt;</span> <span class="kt">Maybe</span> b
</span></span><span class="line"><span class="cl">map f <span class="ow">(</span><span class="kt">Just</span> x<span class="ow">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="ow">(</span>f x<span class="ow">)</span>
</span></span><span class="line"><span class="cl">map f <span class="kt">Nothing</span>  <span class="ow">=</span> <span class="kt">Nothing</span>
</span></span></code></pre></div><p>これを抽象化するインタフェースを定義します。
するとパラメータになるのは <code>List</code> や <code>Maybe</code> の部分です。
これらは型コンストラクタ、Idris的にいうと <code>Type -&gt; Type</code> の値です。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="nf">Idris&gt;</span> <span class="ow">:</span>t <span class="kt">List</span>
</span></span><span class="line"><span class="cl"><span class="nf">List</span> <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
</span></span><span class="line"><span class="cl"><span class="nf">Idris&gt;</span> <span class="ow">:</span>t <span class="kt">Maybe</span>
</span></span><span class="line"><span class="cl"><span class="nf">Maybe</span> <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
</span></span></code></pre></div><p>従来の型変数（Idris的にいうと <code>Type</code> の値）とは異なるのでインタフェースの定義に少し手を加えます。具体的には型変数が <code>Type</code> ではなく <code>Type -&gt; Type</code> であることを表わすために型注釈を加えます。構文は <code>interface インタフェース名 (変数名: Type -&gt; Type) where 本体</code> です。</p>
<p>例： プレリュードのインタフェース <code>Functor</code> の定義</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl">interface <span class="kt">Functor</span> <span class="ow">(</span>f <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span><span class="ow">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="nf">map</span> <span class="ow">:</span> <span class="ow">(</span>func <span class="ow">:</span> a <span class="ow">-&gt;</span> b<span class="ow">)</span> <span class="ow">-&gt;</span> f a <span class="ow">-&gt;</span> f b
</span></span></code></pre></div><p><code>Functor</code> （関手）は <code>List</code> や <code>Maybe</code> などのように「<code>map</code> できる型」を抽象化する型です。<code>f</code> の部分に <code>List</code> や <code>Maybe</code> などが当て嵌ります。</p>
<p><code>Functor</code> インタフェースのおかげでこのように <code>List</code> や <code>Maybe</code> の値に対して1を足す関数を適用できます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Idris&gt; map (1+) (Just 1)
</span></span><span class="line"><span class="cl">Just 2 : Maybe Integer
</span></span><span class="line"><span class="cl">Idris&gt; map (1+) [1, 2, 3]
</span></span><span class="line"><span class="cl">[2, 3, 4] : List Integer
</span></span></code></pre></div><p>このように <code>Type</code> ではなく <code>Type -&gt; Type</code> などの複雑な「型の型」を持つものに対するジェネリクスを高カインド多相と呼びます（「型の型」はカインド（kind）と呼ばれています）。</p>
<p>因みに <code>map</code> の代わりに <code>&lt;$&gt;</code> という演算子も使えます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kr">infixr</span> <span class="mi">4</span> <span class="ow">&lt;$&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ow">(&lt;$&gt;)</span> <span class="ow">:</span> <span class="kt">Functor</span> f <span class="ow">=&gt;</span> <span class="ow">(</span>func <span class="ow">:</span> a <span class="ow">-&gt;</span> b<span class="ow">)</span> <span class="ow">-&gt;</span> f a <span class="ow">-&gt;</span> f b
</span></span><span class="line"><span class="cl">func <span class="ow">&lt;$&gt;</span> x <span class="ow">=</span> map func x
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Idris&gt; (1+) &lt;$&gt; (Just 1)
</span></span><span class="line"><span class="cl">Just 2 : Maybe Integer
</span></span><span class="line"><span class="cl">Idris&gt; (1+) &lt;$&gt; [1, 2, 3]
</span></span><span class="line"><span class="cl">[2, 3, 4] : List Integer
</span></span></code></pre></div><p>後述するApplicativeと組み合わせるときに便利です。</p>
<p>余談ですがHaskellだとリスト専用の <code>map</code> と <code>Functor</code> で定義される <code>fmap</code> で分かれています。恐らくですが先にリストの <code>map</code> を作ったあとに <code>Functor</code> という抽象化に気付いたので要らぬ複雑性が入ってるんじゃないかと思います。その点IdrisはHaskellの後発なのもあってシンプルですね。</p>
<h1 id="多引数関数とapplicative">多引数関数とApplicative</h1>
<p><code>map</code> は便利ですが、痒いところに手が届かないことがあります。
多引数関数には使いづらいのです。</p>
<p>例えば2引数関数 <code>(+)</code> を <code>Just 1</code> と <code>Just 2</code> に適用したいとしましょう。
そこで素朴に <code>map</code> で適用しようとするとエラーになります。</p>
<p>例： <code>map</code> を使って素朴に <code>(+)</code> を <code>Just 1</code> と <code>Just 2</code> に適用した式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Idris&gt; map (+) (Just 1) (Just 2)
</span></span><span class="line"><span class="cl">(input):1:1-25:When checking an application of function Prelude.Functor.map:
</span></span><span class="line"><span class="cl">        Type mismatch between
</span></span><span class="line"><span class="cl">                Maybe a1 (Type of Just x)
</span></span><span class="line"><span class="cl">        and
</span></span><span class="line"><span class="cl">                (\uv =&gt; _ -&gt; uv) a (Expected type)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Specifically:
</span></span><span class="line"><span class="cl">                Type mismatch between
</span></span><span class="line"><span class="cl">                        Maybe
</span></span><span class="line"><span class="cl">                and
</span></span><span class="line"><span class="cl">                        \uv =&gt; _ -&gt; uv
</span></span></code></pre></div><p>これは落ち着いて型を考えるとエラーになる理由が分かります。
<code>map</code> の型は <code>(a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code> です。 <code>(+)</code> の型は <code>Integer -&gt; Integer -&gt; Integer</code> で、これは <code>Integer -&gt; (Integer -&gt; Integer)</code> です。
これらを組み合わせると、 <code>map (+)</code> は <code>Maybe Integer -&gt; Maybe (Integer -&gt; Integer)</code> になります。これを <code>Just 1</code> に適用すると <code>Maybe (Integer -&gt; Integer)</code> になります。
ここで関数ではなくて <code>Maybe</code> 型の値が出てきてしまいました。これでは <code>Just 2</code> に適用できません。</p>
<p>しかしながらみなさんは無理矢理適用させる実装を思い付くんじゃないでしょうか。
以下のようにパターンマッチで取り出してしまえばいいのです。</p>
<p>例： <code>Maybe</code> に包まれた関数を無理矢理適用してしまうコード</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="nf">ap</span><span class="ow">:</span> <span class="kt">Maybe</span> <span class="ow">(</span>a <span class="ow">-&gt;</span> b<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> a <span class="ow">-&gt;</span> <span class="kt">Maybe</span> b
</span></span><span class="line"><span class="cl">ap <span class="ow">(</span><span class="kt">Just</span> f<span class="ow">)</span> <span class="ow">(</span><span class="kt">Just</span> x<span class="ow">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="ow">(</span>f x<span class="ow">)</span>
</span></span><span class="line"><span class="cl">ap <span class="kr">_</span>        <span class="kr">_</span>        <span class="ow">=</span> <span class="kt">Nothing</span>
</span></span></code></pre></div><p>実現できそうなのでインタフェースで抽象化しましょう。
<code>Functor</code> を拡張したインタフェースにするのが具合がよさそうです。
これはプレリュードで <code>Applicative</code> と呼ばれています。</p>
<p>例：プレリュードの <code>Applicative</code> の定義</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kr">infixl</span> <span class="mi">3</span> <span class="ow">&lt;*&gt;</span>
</span></span><span class="line"><span class="cl">interface <span class="kt">Functor</span> f <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="ow">(</span>f <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span><span class="ow">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pure</span>  <span class="ow">:</span> a <span class="ow">-&gt;</span> f a
</span></span><span class="line"><span class="cl">    <span class="ow">(&lt;*&gt;)</span> <span class="ow">:</span> f <span class="ow">(</span>a <span class="ow">-&gt;</span> b<span class="ow">)</span> <span class="ow">-&gt;</span> f a <span class="ow">-&gt;</span> f b
</span></span></code></pre></div><p><code>ap</code> ではなく <code>&lt;*&gt;</code> という演算子になっていますが、やってることは先程定義した <code>ap</code> と同じものです。
これに対する <code>Maybe</code> の実装は以下のようになっています。</p>
<p>例：プレリュードの <code>Applicative</code> の <code>Maybe</code> への実装</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    pure <span class="ow">=</span> <span class="kt">Just</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="ow">(</span><span class="kt">Just</span> f<span class="ow">)</span> <span class="ow">&lt;*&gt;</span> <span class="ow">(</span><span class="kt">Just</span> a<span class="ow">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="ow">(</span>f a<span class="ow">)</span>
</span></span><span class="line"><span class="cl">    <span class="kr">_</span>        <span class="ow">&lt;*&gt;</span> <span class="kr">_</span>        <span class="ow">=</span> <span class="kt">Nothing</span>
</span></span></code></pre></div><p>ちゃんと <code>&lt;*&gt;</code> の実装が <code>ap</code> と同じものになっていますね。</p>
<p><code>map</code> を <code>&lt;$&gt;</code> と書けることと組み合わせて、以下のように使えます。</p>
<p>例： <code>Functor</code> と <code>Applicative</code> の利用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kt">Idris</span><span class="ow">&gt;</span> <span class="ow">(+)</span> <span class="ow">&lt;$&gt;</span> <span class="ow">(</span><span class="kt">Just</span> <span class="mi">1</span><span class="ow">)</span> <span class="ow">&lt;*&gt;</span> <span class="ow">(</span><span class="kt">Just</span> <span class="mi">2</span><span class="ow">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">Just</span> <span class="mi">3</span> <span class="ow">:</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
</span></span></code></pre></div><p>因みにインタフェースであるからには複数の型（型コンストラクタ）に実装されている訳です。例えば <code>List</code> での実装がどうなっているかというと、全ての要素に対して繰り返すようになっています。</p>
<p>例： <code>List</code> での <code>Functor</code> と <code>Applicative</code> の利用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kt">Idris</span><span class="ow">&gt;</span> <span class="ow">(+)</span> <span class="ow">&lt;$&gt;</span> <span class="ow">[</span><span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span><span class="ow">]</span> <span class="ow">&lt;*&gt;</span> <span class="ow">[</span><span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">12</span><span class="ow">]</span>
</span></span><span class="line"><span class="cl"><span class="ow">[</span><span class="mi">11</span>, <span class="mi">12</span>, <span class="mi">13</span>, <span class="mi">12</span>, <span class="mi">13</span>, <span class="mi">14</span>, <span class="mi">13</span>, <span class="mi">14</span>, <span class="mi">15</span><span class="ow">]</span> <span class="ow">:</span> <span class="kt">List</span> <span class="kt">Integer</span>
</span></span></code></pre></div><p>ところで <code>Applicative</code> に <code>pure</code> というのがいますね。
これの役割に触れておきましょう。
<code>func</code> を <code>x</code> に適用するとします。
<code>func</code> と <code>x</code> の型がそれぞれ <code>Maybe</code> （一般化して <code>f</code>）に包まれている/いないで4つの組み合わせがありますね？それぞれどう適用するか見てみましょう。</p>
<table>
<thead>
<tr>
<th>関数</th>
<th>引数</th>
<th>適用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a -&gt; b</code></td>
<td><code>a</code></td>
<td><code>func x</code></td>
</tr>
<tr>
<td><code>a -&gt; b</code></td>
<td><code>f a</code></td>
<td><code>map func x</code></td>
</tr>
<tr>
<td><code>f (a -&gt; b)</code></td>
<td><code>a</code></td>
<td>????</td>
</tr>
<tr>
<td><code>f (a -&gt; b)</code></td>
<td><code>f a</code></td>
<td><code>func &lt;*&gt; x</code></td>
</tr>
</tbody>
</table>
<p><code>f (a -&gt; b)</code> を <code>a</code> に適用する場合だけまだ出てきてませんね。
この隙間を <code>pure</code> が埋めてくれます。
<code>func &lt;*&gt; (pure x)</code> と書けばいいのです。</p>
<p>余談ですが<code>Functor</code> を使った <code>map func x</code> も <code>(pure func) &lt;*&gt; x</code> と <code>Applicative</code> の機能だけで書くことができますね。そういった意味で <code>Applicative</code> は <code>Functor</code> の拡張になっています。</p>
<h1 id="プログラムとモナド">プログラムとモナド</h1>
<p><code>Applicative</code> で <code>Maybe</code> などのジェネリクス型に包まれているデータや関数に対して操作できるようになりました。では新しく包む操作についてはどうでしょう。</p>
<p>例えば割る数が0以外では割った商を、0では <code>Nothing</code> を返す <code>safeDiv</code> を考えます。</p>
<p>例：<code>safeDiv</code> 関数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="nf">safeDiv</span> <span class="ow">:</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
</span></span><span class="line"><span class="cl">safeDiv <span class="kr">_</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</span></span><span class="line"><span class="cl">safeDiv d m <span class="ow">=</span> d `div` m
</span></span></code></pre></div><p>これを <code>&lt;$&gt;</code> と <code>&lt;*&gt;</code> で組み合わせることもできますが、結果はあまり嬉しくありません。</p>
<p>例：<code>safeDiv</code> を <code>Functor</code> と <code>Applicative</code> と一緒に使った例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Idris&gt; safeDiv &lt;$&gt; (Just 1) &lt;*&gt; (Just 0)
</span></span><span class="line"><span class="cl">Just Nothing : Maybe (Maybe Integer)
</span></span></code></pre></div><p>返り型が <code>Maybe (Maybe Integer)</code> と <code>Maybe</code> が二重に出てきてしまいました。そして返り値も <code>Just Nothing</code> になってしまっています。これは数値が返ってきていないという意味では <code>Nothing</code> と変わりません。<code>Maybe Integer</code> に「潰せ」たらうれしいですよね。</p>
<p>そういう操作は一般に、flatten、あるいはjoinと呼ばれますね。
さらにflattenの派生型であると嬉しいのがflatMapです。Idrisの型で書くと <code>Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b</code> です。flattenとflatMapは片方があればもう片方を定義できるので双子のような存在です。</p>
<p>そんなjoinとflatMapをインタフェースにしたのがモナドです。</p>
<p>例：プレリュードでの <code>Monad</code> の定義</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Idris" data-lang="Idris"><span class="line"><span class="cl"><span class="kr">infixl</span> <span class="mi">1</span> <span class="ow">&gt;&gt;=</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface <span class="kt">Applicative</span> m <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="ow">(</span>m <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span><span class="ow">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="c1">||| Also called `bind`.</span>
</span></span><span class="line"><span class="cl">    <span class="ow">(&gt;&gt;=)</span>  <span class="ow">:</span> m a <span class="ow">-&gt;</span> <span class="ow">((</span>result <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> m b<span class="ow">)</span> <span class="ow">-&gt;</span> m b
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">||| Also called `flatten` or mu</span>
</span></span><span class="line"><span class="cl">    <span class="nf">join</span> <span class="ow">:</span> m <span class="ow">(</span>m a<span class="ow">)</span> <span class="ow">-&gt;</span> m a
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">-- default implementations</span>
</span></span><span class="line"><span class="cl">    <span class="ow">(&gt;&gt;=)</span> x f <span class="ow">=</span> join <span class="ow">(</span>f <span class="ow">&lt;$&gt;</span> x<span class="ow">)</span>
</span></span><span class="line"><span class="cl">    join x <span class="ow">=</span> x <span class="ow">&gt;&gt;=</span> id
</span></span></code></pre></div><p>この <code>Monad</code> を使えば先程の <code>safeDiv</code> は <code>Maybe Integer</code> を返すように使えるようになります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Idris&gt; join (safeDiv &lt;$&gt; (Just 1) &lt;*&gt; (Just 0))
</span></span><span class="line"><span class="cl">Nothing : Maybe Integer
</span></span><span class="line"><span class="cl">Idris&gt; Just 1 &gt;&gt;= \d =&gt; (Just 0 &gt;&gt;= \m =&gt; safeDiv d m)
</span></span><span class="line"><span class="cl">Nothing : Maybe Integer
</span></span></code></pre></div><h2 id="do-記法"><code>do</code> 記法</h2>
<p>先程の例、 <code>Just 1 &gt;&gt;= \d =&gt; (Just 0 &gt;&gt;= \m =&gt; safeDiv d m)</code> は見づらいですよね。演算子や無名関数が乱舞してどこに何が書いてあるのか分かりません。そこでこれを書きやすくする <code>do</code> 記法というのがあります。</p>
<p>先程のコードを <code>do</code> 記法で書き直すと以下のようになります。</p>
<p>例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kr">do</span>
</span></span><span class="line"><span class="cl">  d <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  m <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  safeDiv d m
</span></span></code></pre></div><p>これだとぐっと見やすくなりますね。</p>
<p>ところで基本文法のところで触れ忘れたんですが、オフサイドルールには別の記法もあります。<code>{記述1; 記述2; ...}</code> と <code>{}</code> で包んでそれぞれの記述を <code>;</code> で分けます。こうすることで1行でも書けるようになります。
REPLなどでは1行で書きたいケースもあると思うのでお試し下さい。</p>
<p>例： <code>do</code> 記法をREPLで使うコード</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Idris&gt; do {d &lt;- Just 1; m &lt;- Just 0; safeDiv d m }
</span></span><span class="line"><span class="cl">Nothing : Maybe Integer
</span></span></code></pre></div><p>モナドを使うときは大抵 <code>do</code> 記法を使うことになるでしょう。</p>
<p><code>Monad</code> もまたインタフェースなので <code>Maybe</code> 以外の型も実装を持ちます。例えば <code>List</code> はその要素について繰り返します。
リスト内包表記のようなことを <code>do</code> 記法でもできるのです。</p>
<p>例：九九の左斜め下半分を <code>do</code> 記法で計算するコード</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="kr">do</span>
</span></span><span class="line"><span class="cl">  x <span class="ow">&lt;-</span> <span class="ow">[</span><span class="mi">0</span><span class="ow">..</span><span class="mi">9</span><span class="ow">]</span>
</span></span><span class="line"><span class="cl">  y <span class="ow">&lt;-</span> <span class="ow">[</span><span class="mi">0</span><span class="ow">..</span>x<span class="ow">]</span>
</span></span><span class="line"><span class="cl">  pure <span class="ow">(</span>x <span class="ow">*</span> y<span class="ow">)</span>
</span></span></code></pre></div><h1 id="モナドはdsl">モナドはDSL?</h1>
<p><code>Functor</code> 、 <code>Applicative</code> 、 <code>Monad</code> で何かに包まれた値を計算できるようになりました。では、包まれた値から取り出すにはどうしたらいいでしょう。
残念ながらいい方法はありません。
<code>Nothing</code> なんかは値がないから <code>Nothing</code> な訳で、そこから値を取り出せません。</p>
<p>逆に言うとモナドにすることで操作を「閉じ込めて」しまうことができます。
使える操作は <code>Functor</code> と <code>Applicative</code> で「持ち上げた」操作と、 <code>Monad</code> で「結合」できる <code>a -&gt; m b</code> の型の関数のみです。</p>
<p>そういった意味でモナドはDSLと捉えることができます。
ライブラリなんかでもモナドを提供し、主な操作は <code>do</code> 記法でやるものが多くあります。</p>
<h1 id="ioモナド">IOモナド</h1>
<p>いままで、まともにHollo Worldを解説してませんでしたね。
それはIO操作もモナドで書かれているからです。</p>
<p>ということでモナドを知った今、改めてHello Worldをしてみましょう。
<code>putStrLn</code> は以下のような型をしています。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Idris&gt; :t putStrLn
</span></span><span class="line"><span class="cl">putStrLn : String -&gt; IO ()
</span></span></code></pre></div><p>そしてIdrisは <code>main : IO ()</code> な値からプログラムの実行を始めます。
なのでHello Worldは以下のように書きます。</p>
<p>例：IdrisでのHello World</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="nf">main</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
</span></span><span class="line"><span class="cl">main <span class="ow">=</span> putStrLn <span class="s">&#34;Hello, World&#34;</span>
</span></span></code></pre></div><p>これを <code>Hello.idr</code> として保存し、以下のように実行します。</p>
<p>例：Hello Worldをコンパイル・実行するコマンド</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">$ idris -o Hello Hello.idr
</span></span><span class="line"><span class="cl">$ ./Hello
</span></span><span class="line"><span class="cl">Hello, World
</span></span></code></pre></div><p><code>-o</code> オプションをつけて <code>idris</code> コマンドを起動するとREPLではなくコンパイラが起動し、 <code>-o</code> で指定したファイルへとコンパイル結果を出力します。</p>
<p>もうちょっと複雑なことをしましょう。
<code>getLine: IO String</code> で標準入力から1行取得できます。
これと <code>putStrLn</code> で入力をエコーバックするプログラムはこう書けます。</p>
<p>例： <code>getLine</code> と <code>putStrLn</code> を使ってユーザの入力を表示するプログラム</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="nf">main</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
</span></span><span class="line"><span class="cl">main <span class="ow">=</span> getLine <span class="ow">&gt;&gt;=</span> <span class="ow">\</span>s <span class="ow">=&gt;</span> putStrLn <span class="ow">(</span><span class="s">&#34;Your input is &#34;</span> <span class="ow">++</span> s<span class="ow">)</span>
</span></span></code></pre></div><p>あるいは、 <code>do</code> 記法で書くこともできます。</p>
<p>例： <code>getLine</code> と <code>putStrLn</code> を使ってユーザの入力を表示するプログラムを <code>do</code> 記法で書いたもの</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-idris" data-lang="idris"><span class="line"><span class="cl"><span class="nf">main</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
</span></span><span class="line"><span class="cl">main <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">  s <span class="ow">&lt;-</span> getLine
</span></span><span class="line"><span class="cl">  putStrLn <span class="ow">(</span><span class="s">&#34;Your input is &#34;</span> <span class="ow">++</span> s<span class="ow">)</span>
</span></span></code></pre></div><p>これを <code>Echo.idr</code> に保存し、コンパイル、実行すると以下のように動作します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">$ idris -o Echo Echo.idr
</span></span><span class="line"><span class="cl">$ ./Echo
</span></span><span class="line"><span class="cl">echooooo
</span></span><span class="line"><span class="cl">Your input is echooooo
</span></span></code></pre></div><h2 id="ところでioって何">ところでIOって何？</h2>
<p><code>IO</code> の型にちょっと違和感を覚えた方もいるんじゃないかと思います。
<code>main</code> の型は <code>IO ()</code> という値です。関数じゃありません。
同じく <code>getLine</code> も <code>IO String</code> という値です。
これだと書いたそばから実行されてしまわないでしょうか。
まあ、動いてるからにはそうならないんのは分かるんですが、どういう仕組みなんでしょう。</p>
<p>Idrisのプログラムからは <code>IO</code> の値を実行することができません。
<code>getLine</code> と書いたからといって即座に標準入力から文字列を取り出したりしないのです。
唯一 <code>main</code> に書いた <code>IO</code> の値のみが処理系側で実行されます。
処理系側で実行されてはじめて標準入力から文字列を取り出すというアクションが行なわれます。
<code>IO</code> は実行される前のプログラムのようなものなのです。</p>
<p><code>IO</code> を実行できるのは <code>main</code>の1箇所のみとなると、複数のIO処理をしたいときは <code>IO</code> の値を合成する必要があります。
その仕組みに選ばれたのがモナドという訳です。
<code>&gt;&gt;=</code> は別名 bind （結合）ですが、先程の <code>getLine</code> と <code>putStrLn</code> のように複数のIO処理を結合するのに使われているのです。</p>
<h2 id="純粋関数型言語とio">純粋関数型言語とIO</h2>
<p>さて、 <code>main</code> でしか <code>IO</code> を実行できないとなると他の関数内でIO処理をしたい場合はどうすればいいのでしょう。</p>
<p>1つの答えは「そういう関数は設計が悪いから書くな」です。
純粋関数型言語であるIdrisの基本方針として、IOや変数への破壊的代入などの計算以外の処理はよくないものとされています。
関数を呼んだときに何が起こるか分からなくなるからです。
なので関数内でIO処理を書きたくなったときはまずは「計算部分とIO部分に分離できないか」と考えてみましょう。</p>
<p>もう1つの答えは 「全て <code>IO</code> モナドの中で書く」です。
<code>IO</code> モナドをリレーのように <code>main</code> まで伝えればIOを実行できます。
なので関数の中でIOをしたければ <code>IO</code> モナドの中で書くことにすれば実現できます。
とはいえやっぱりIOの中でプログラムを書くのは面倒なので基本的には純粋な計算部分とIO部分に分けて、
IO部分でだけ <code>IO</code> モナドを使うようになります。</p>
<p>じゃあデバッグプリントを関数の中に仕込みたかったらどうなるの、という疑問はあるかもしれません。
まあ、普通に <code>IO</code> を使ってそれを呼ぶ関数を全て <code>IO</code> モナドの中で書くように変更します。
ちょっと面倒ですよね。一応そういった用途のためのバックドアの機構はあるのでそのうち紹介します。</p>
<h1 id="まとめ">まとめ</h1>
<p>Idrisの重要な機能インタフェースと、重要なインタフェース <code>Monad</code> 、重要なモナド <code>IO</code> を立て続けに紹介しました。
<code>IO</code> まで辿りついたことでIdrisのプログラムを書けるようになりました。</p>
<p>未紹介のIdrisの機能もあるのでAdvent Calendarの残りでは手を動かしつつ他の機能も紹介していけたらなと思います。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>名前付き実装という機能を使えばその限りではないのですが、話がややこしくなるので一旦置いておきます。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
                    </section>
                </article>
            </div>
        </div>

        <div class="row li-author">
    <div class="sixteen columns">
        Written by <strong>κeen</strong>
    </div>
</div>


        <div class="row li-pagination">
            <div class="eight columns">
                <div class="li-pagination-previous">
                    
                        Later article<br />
                        <a href="https://KeenS.github.io/blog/2020/12/10/idristotakahashikun/"> Idrisと高橋君</a>
                    
                </div>
            </div>
            <div class="eight columns">
                <div class="li-pagination-next">
                    
                        Older article<br />
                        <a href="https://KeenS.github.io/blog/2020/12/07/repldeidrisshouryokou/"> REPLでIdris小旅行</a>
                    
                </div>
            </div>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2022. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="https://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>

