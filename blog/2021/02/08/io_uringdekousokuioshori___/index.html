<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="io_uringで高速IO処理（？） | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="κeenです。普段お世話になってるけど使ったことのないAPIを叩いてみよう、ということで io_uring を使ってみます。" />
        <meta property="og:title" content="io_uringで高速IO処理（？） | κeenのHappy Hacκing Blog" />
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https://KeenS.github.io/blog/2021/02/08/io_uringdekousokuioshori___/" />
        <meta property="og:description" content="κeenです。普段お世話になってるけど使ったことのないAPIを叩いてみよう、ということで io_uring を使ってみます。" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta property="og:image" content="https://KeenS.github.io/images/ogp/post/io_uringdekousokuIOshori___.png" />
        <meta name="twitter:image" content="https://KeenS.github.io/images/ogp/post/io_uringdekousokuIOshori___.png" />
        
        <meta property="og:article:published_time" content="2021-02-08 20:33:15 &#43;0900 JST" />
        <meta property="og:article:modified_time" content="2021-02-08 20:33:15 &#43;0900 JST" />
        
        <meta property="og:article:author" content="κeen" />

        <title>io_uringで高速IO処理（？） | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css' />
        <link rel="stylesheet" href="https://KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/liquorice.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="https://KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="https://KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="https://KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
        <link rel="apple-touch-icon-precomposed" href="https://KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/syntax-monokai.css" />
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<link rel="stylesheet" href="//unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css">

    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="https://KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="https://KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                        
                            <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="https://KeenS.github.io/search/"> Search </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="https://KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                    
                        <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="https://KeenS.github.io/search/"> Search </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                    <header class="li-article-header">
                        <h1 class="li-article-title">io_uringで高速IO処理（？）</h1>
                        <div class="li-article-meta">
    <time class="li-article-date">2021-02-08</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="https://KeenS.github.io/categories/linux">Linux</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/rust">Rust</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f">非同期</a>
        </li>
    
</ul>

</div>

                    </header>
                    <section>
                        <p>κeenです。普段お世話になってるけど使ったことのないAPIを叩いてみよう、ということで <code>io_uring</code> を使ってみます。</p>

<p>io_uringが何なのかは以下の記事が詳しかったです。</p>

<ul>
<li><a href="https://qiita.com/tmsn/items/0b9e5f84f9fbc56c1c82">Linuxにおける非同期IOの実装について - Qiita</a></li>
</ul>

<p>ざっくり、io_uringはLinuxで非同期IOをするためのAPIです。
ユーザランドとカーネルランドで2つのキューを共有し、そこを通じて会話をします。
1つのキューはユーザランドからカーネルへのリクエストの提出用、もう1つのキューはカーネルからユーザランドへの完了の通知用です。
また、epollを制御するためにfdもあります。こんなイメージですかね。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">         user

        |   ^   ^
submit |||  || ||| completion
-------|||--fd-|||----------
       |||  || |||
        v    v  |

        kernel</code></pre></div>
<p>それぞれのキューはリングバッファで実装されています。</p>

<p>io_uringではIO処理の依頼とその完了待ちが分離されているので処理を発行しておいて自分のタイミングで結果を受け取ることができます。例えば3つのIO処理をするときにio_uringなしに普通の処理をやろうとすると3回分IOの待ちが発生します。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">|    |
+---&gt;|
|    |
|&lt;---+
+---&gt;|
|    |
|&lt;---+
+---&gt;|
|    |
|&lt;---+</code></pre></div>
<p>しかしio_uringを使えばIOリクエストを矢継ぎ早に送れるので待ち時間を短縮できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">|    |
+---&gt;|
+---&gt;|
+---&gt;|
|    |
|&lt;---+
|&lt;---+
|&lt;---+</code></pre></div>
<p>特にSSDだとコマンドキューにどれだけ命令を詰め込めるかが勝負らしい（？）のでio_uringだと有利なのかもしれません。</p>

<p>ということでio_uringを使ってIO処理を高速化してみましょう。</p>

<h1 id="liburing">liburing</h1>

<p>io_uringはLinuxのAPIですが、そのまま使うにはいささか手間が大きいです。
今までカーネルで全てやってきたことをユーザでコントロールできるようにするということはユーザでやることが増えるということでもあります。そこでio_uringを簡単に使えるライブラリとしてliburingがあります。</p>

<ul>
<li><a href="https://github.com/axboe/liburing">axboe/liburing</a></li>
</ul>

<p>Ubuntuならaptで入ります。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ apt get install liburing-dev</code></pre></div>
<p>liburingの有無で使い勝手がどう違うかは以下のリポジトリが参考になりました。</p>

<ul>
<li><a href="https://github.com/shuveb/io_uring-by-example">shuveb/io_uring-by-example: A companion repository for the io_uring by Example article series</a></li>
</ul>

<p>まあ、今回私はRustのラッパを使うのでliburingは関係ないんですけどね。</p>

<h1 id="rustからio-uringを使ってみる">Rustからio_uringを使ってみる</h1>

<p>ということでio_uringを使ってみましょう。Rustからだといくつかラッパが存在するようですがTokioのio_uringラッパを使ってみましょう。</p>

<ul>
<li><a href="https://github.com/tokio-rs/io-uring">tokio-rs/io-uring: The <code>io_uring</code> library for Rust</a></li>
</ul>

<p>これはliburingを使わずにlibcのio_uringを直接ラップしたライブラリです。</p>

<p>やることはシンプルに &lsquo;aaaaaaa&hellip;&rsquo; と5GiBの &lsquo;a&rsquo; が書かれたファイルを作ってみます。
今回のコード全体は以下に置いておきます。</p>

<ul>
<li><a href="https://github.com/KeenS/io-uring-write-file">KeenS/io-uring-write-file</a></li>
</ul>

<p>以後は重要なところだけを拾って解説していきます。</p>

<h2 id="標準ライブラリでの実装">標準ライブラリでの実装</h2>

<p>io_uringを使ずに標準ライブラリだけで書いたシンプルなコードであれば以下のように書けるでしょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TOTAL</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">DATA</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">4096</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mh">0x61</span><span class="p">;</span><span class="w"> </span><span class="mi">4096</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;std.text&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">npages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">npages</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DATA</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span></code></pre></div>
<p>これと同等のことをio_uringで実装します。</p>

<h2 id="io-uringを使った実装">io-uringを使った実装</h2>

<p>io_uringで書き直してみます。
まずはファイルを開いておきましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;iouring.text&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span></code></pre></div>
<p>そしてio_uringを初期化します。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">io_uring</span>::<span class="n">opcode</span>::<span class="n">types</span>::<span class="n">Fd</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">io_uring</span>::<span class="n">opcode</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">io_uring</span>::<span class="n">IoUring</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">uring</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IoUring</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span><span class="o">?</span><span class="p">;</span></code></pre></div>
<p>引数はリングバッファのサイズです。
2048という数値はまあ、なんか雰囲気で決めました。
Linuxのio_uringではsubmitのキュー（sq）とcompletionのキュー（cq）それぞれ長さを指定できるはずですがTokioのバインディングでは両方とも同じ長さを指定しているようです。</p>

<p>上の方でio_uringにはfd、sq、cqがあるといいましたが、Tokioのバインディングも3つのコンポーネントが取り出せます。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">submitter</span><span class="p">,</span><span class="w"> </span><span class="n">sq</span><span class="p">,</span><span class="w"> </span><span class="n">cq</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uring</span><span class="p">.</span><span class="n">split</span><span class="p">();</span></code></pre></div>
<p>submitterはfd経由でsubmissionを管理するからのネーミングなんでしょう。</p>

<p>一旦データサイズとかを用意して</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TOTAL</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">DATA</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">4096</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mh">0x61</span><span class="p">;</span><span class="w"> </span><span class="mi">4096</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">npages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">();</span></code></pre></div>
<p>タスクを発行したときに完了まで待たないので完了したタスクを管理する変数を別途用意します。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">completed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span></code></pre></div>
<p>さて、ここからIOリクエストを提出する段に入ります。
IOリクエストを <code>entry</code> として、以下の3行でIOリクエストを提出できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w">
</span><span class="w">    </span><span class="n">sq</span><span class="p">.</span><span class="n">available</span><span class="p">().</span><span class="n">push</span><span class="p">(</span><span class="n">entry</span><span class="p">).</span><span class="n">map_err</span><span class="p">(...)</span><span class="o">?</span><span class="w">
</span><span class="w">    </span><span class="n">submitter</span><span class="p">.</span><span class="n">submit</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span></code></pre></div>
<p><code>sq.available()</code> というのがTokioのバインディングのユニークな点で、その時点で空いているキューのビューを提供します。
一瞬「それスレッドセーフじゃなくね？」って思いますがRustなので大丈夫です。所有権システムが守ってくれます。</p>

<p>この <code>submit</code> ですが一気に複数のIOリクエストを溜めて一気に提出できます。
<code>submit</code> の回数は少ない方がカーネルとのやり取りが減って速そうなので1024回分のリクエストを溜めて一気に送ってみます。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ... */</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">sq</span><span class="p">.</span><span class="n">available</span><span class="p">().</span><span class="n">push</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">submitter</span><span class="p">.</span><span class="n">submit</span><span class="p">()</span><span class="o">?</span><span class="p">;</span></code></pre></div>
<p>つまり、全体はこういうイメージです。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">outer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">npages</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">outer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ... */</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">sq</span><span class="p">.</span><span class="n">available</span><span class="p">().</span><span class="n">push</span><span class="p">(</span><span class="n">entry</span><span class="p">).</span><span class="n">map_err</span><span class="p">(...)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">submitter</span><span class="p">.</span><span class="n">submit</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span></code></pre></div>
<p>ここで先送りにしていた <code>entry</code> を作りましょう。
Cだと <code>IORING_OP_XXX</code> で操作を指定してデータを詰めるんですがTokioのバインディングはOPごとに構造体が用意されていて、それをビルダとして <code>Entry</code> を作る設計のようです。</p>

<p>単刀直入にentryを作るコードを書くとこうです。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// libc crateをdependencyに追加しておく
</span><span class="c1"></span><span class="k">use</span><span class="w"> </span><span class="n">libc</span>::<span class="n">off_t</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">io_uring</span>::<span class="n">opcode</span>::<span class="n">types</span>::<span class="n">Fd</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">io_uring</span>::<span class="n">opcode</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Write</span>::<span class="n">new</span><span class="p">(</span><span class="n">Fd</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">as_raw_fd</span><span class="p">()),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DATA</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">offset</span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">off_t</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">();</span></code></pre></div>
<p>要点を解説すると以下です。</p>

<ul>
<li><code>Write</code> で書き込みのIOリクエスト</li>
<li><code>Write</code> にはファイルを表わすfd、バッファと長さを指定

<ul>
<li>今回は固定の内容を書き込むのでバッファを使い回してる</li>
</ul></li>
<li>そのままだとファイルの先頭に書くだけなので <code>offset</code> でファイルのどこに書くかを指定</li>
</ul>

<p>総合して、以下のコードになります。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">outer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">npages</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">outer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Write</span>::<span class="n">new</span><span class="p">(</span><span class="n">Fd</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">as_raw_fd</span><span class="p">()),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DATA</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">offset</span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">off_t</span><span class="p">)</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">build</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">sq</span><span class="p">.</span><span class="n">available</span><span class="p">().</span><span class="n">push</span><span class="p">(</span><span class="n">entry</span><span class="p">).</span><span class="n">map_err</span><span class="p">(...)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">submitter</span><span class="p">.</span><span class="n">submit</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span></code></pre></div>
<p>なんですが、これだと <code>cq</code> が詰まってしまうらしくエラーになります。device busyのエラーだったんですがなんでなんでしょうね。
なので適度に <code>cq</code> も消費します。
今回は返り値には興味がないので返り値が成功かどうかはみずにそのまま消費します。
<code>cq.available()</code> はイテレータになっているので <code>count</code> を呼んであげると <code>completed</code> も計算できて丁度よさそうです。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">outer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">submitter</span><span class="p">.</span><span class="n">submit</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="c1">// cqを消費する
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">completed</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">cq</span><span class="p">.</span><span class="n">available</span><span class="p">().</span><span class="n">count</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span></code></pre></div>
<p>これでIOリクエストを提出できました。</p>

<p>次はIOリクエストの完了待ちです。それには <code>submitter</code> の <code>submit_and_wait</code> を使うとよさそうです。
残ってる分のリクエストを順次消費していきます。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">while</span><span class="w"> </span><span class="n">completed</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">npages</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">npages</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">completed</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">submitter</span><span class="p">.</span><span class="n">submit_and_wait</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cq</span><span class="p">.</span><span class="n">available</span><span class="p">().</span><span class="n">count</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">completed</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">count</span><span class="w">
</span><span class="w"></span><span class="p">}</span></code></pre></div>
<p><code>rest</code> を計算していますがそもそもキューの長さが2048なので最大で2048までしか返ってきませんがまあ、気にしなくてよいでしょう。どのみち <code>while</code> で完了するまで待ちます。</p>

<h2 id="ベンチマーク">ベンチマーク</h2>

<p>高速なIO処理を目指して書いたのでベンチマークを取ってみましょう。
雑に処理の開始と終了の時間の差をとります。
標準ライブラリを使った実装をstd、io_uringを使った実装をuringとします。</p>

<table>
<thead>
<tr>
<th>name</th>
<th align="right">time (ms)</th>
</tr>
</thead>

<tbody>
<tr>
<td>std</td>
<td align="right">2031</td>
</tr>

<tr>
<td>uring</td>
<td align="right">4486</td>
</tr>
</tbody>
</table>

<p>…………。stdの方が倍以上速いという結果になりました。
因みに <code>time</code> コマンドによるとuringの方が使っているCPU時間は短いです。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">$ /usr/bin/time ./target/release/std
2031 ms
0.04user 1.98system 0:02.03elapsed 99%CPU (0avgtext+0avgdata 1888maxresident)k
0inputs+10485760outputs (0major+90minor)pagefaults 0swaps
$ /usr/bin/time ./target/release/iouring
4486 ms
0.02user 0.19system 0:04.48elapsed 4%CPU (0avgtext+0avgdata 1948maxresident)k
0inputs+0outputs (0major+91minor)pagefaults 0swaps</code></pre></div>
<p>キューの待ちでも発生したんですかねぇ？</p>

<h2 id="io-uringの高速化">io_uringの高速化</h2>

<p>ちょっとこのままだと収まりが悪いのでio_uringを高速化してみます。
ポイントは2つあって、ファイルfdの事前登録とバッファの事前登録です。</p>

<p>カーネルのことはよく分からないんですがfdをカーネルに渡してそれをカーネル側であれこれしてもらうのは時間がかかるらしいです。
そこでカーネルに事前に使う予定のfdを事前に渡しておけばその時間を短縮できるらしいです。</p>

<p>もう1つがバッファの事前登録です。これは分かりやすいですね。
<code>submit</code> の度にRustのメモリ領域からカーネル内にデータをコピーして使っています。
これは無駄なので事前にデータ提出に使うバッファをユーザランドとカーネルランドで共有しておけばコピーの手間が省けます。
ただしこれにはカーネルと共有できるメモリを確保したり共有メモリ専用のIOリクエストを使ったりの作業が必要になります。</p>

<p>これら2つの操作はlibc的には <code>io_uring_register</code> で、Tokioのio-uring的にはsubmitterに生えてる <code>register_xxx</code> 系の関数でやります。</p>

<h3 id="ファイルの事前登録">ファイルの事前登録</h3>

<p>これは単純ですね。関数を呼ぶだけです。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">submitter</span><span class="p">.</span><span class="n">register_files</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">file</span><span class="p">.</span><span class="n">as_raw_fd</span><span class="p">()])</span><span class="o">?</span><span class="p">;</span></code></pre></div>
<h3 id="バッファの事前登録">バッファの事前登録</h3>

<p>これはちょっと厄介です。まず、 <code>mmap</code> でANONYMOUSなメモリを確保します。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">libc</span>::<span class="p">{</span><span class="n">mmap</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_PRIVATE</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ffi</span>::<span class="n">c_void</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">null_mut</span>::<span class="o">&lt;</span><span class="n">c_void</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">MAP_PRIVATE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">isize</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span>::<span class="n">last_os_error</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="p">((</span><span class="n">buf</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">).</span><span class="n">offset</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">isize</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DATA</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span></code></pre></div>
<p>それを <code>register_buffers</code> します。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">libc</span>::<span class="n">iovec</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">submitter</span><span class="p">.</span><span class="n">register_buffers</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">iovec</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">iov_base</span>: <span class="nc">buf</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">iov_len</span>: <span class="nc">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w">
</span><span class="w"></span><span class="p">}])</span><span class="o">?</span><span class="p">;</span></code></pre></div>
<p>そして <code>entry</code> を作るところで <code>Write</code> の代わりに <code>WriteFixed</code> を使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">    </span><span class="n">WriteFixed</span>::<span class="n">new</span><span class="p">(</span><span class="n">Fd</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">as_raw_fd</span><span class="p">()),</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">offset</span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">DATA</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">off_t</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">build</span><span class="p">();</span></code></pre></div>
<p><code>WriteFixed</code> は <code>Write</code> と比べて1つ引数が増えており、最後の引数で <code>register</code> したどのバッファを使うのかを指定します。
全体を知りたい方はGitHubのコードを読んで下さい。</p>

<h3 id="ベンチマーク-1">ベンチマーク</h3>

<p>これを走らせてみます。uring&rsquo;と呼びましょうか。</p>

<table>
<thead>
<tr>
<th>name</th>
<th align="right">time (ms)</th>
</tr>
</thead>

<tbody>
<tr>
<td>uring&rsquo;</td>
<td align="right">1917</td>
</tr>
</tbody>
</table>

<p>わずかにstdよりも速く見えますが、測定でそこそこバラつきがあったので多分有意な差はないです。
少なくとも工夫のないio_uringよりは速いことだけは分かります。</p>

<p>因みにですが <code>time</code> コマンドによると相変わらずCPU使用率が低いようです。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">$ /usr/bin/time ./target/release/iouring_tuned
1917 ms
0.02user 0.29system 0:01.97elapsed 16%CPU (0avgtext+0avgdata 1956maxresident)k
0inputs+64outputs (0major+91minor)pagefaults 0swaps</code></pre></div>
<p>stdと実時間では変わらないけどsystemのCPU使用時間と全体のCPU使用率が低いのは気になりますね。</p>

<p>私にはこれ以上深く追求するための知識が足りないのでここまでとします。
perfの結果なんかも微妙に違ってたんですが解釈できないデータを貼っても意味がないので気になった方は手元で走らせてみて下さい。</p>

<p>そもそも、 <code>dd</code> で同様の処理をしてもRustのコードより遅いのでそういうもんなのかもしれません。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">$ /bin/time dd if=/dev/zero of=dd.bin bs=4K count=1310720
1310720+0 レコード入力
1310720+0 レコード出力
5368709120 bytes (5.4 GB, 5.0 GiB) copied, 2.88155 s, 1.9 GB/s
0.09user 2.89system 0:02.99elapsed 99%CPU (0avgtext+0avgdata 2352maxresident)k
0inputs+10486112outputs (0major+91minor)pagefaults 0swaps</code></pre></div>
<p><code>dd</code> がそこまでパフォーマンスを気にして書かれてるか分かりませんが。</p>

<h1 id="まとめ">まとめ</h1>

<p>io_uring APIの雑な紹介とそれをRustから叩くコード3種を紹介しました。
io_uringで処理を高速化する目論みでしたが失敗しました。
よく考えたらどのみちOSのバッファに載って処理されるのでio_uringあんまり関係なかったのではという説もあります。
やるんなら高速化ではなくマルチタスクの方がよかったかもしれませんね。</p>

<p>今出すかよって感じですが実行環境はM.2のNVMe SSD x 4の上にbtrfsでRAID 5を組んだファイルシステムで、ちょっとパフォーマンス特性に癖があったのかもしれません。
調べたらbtrfsはジャーナリングする関係でシーケンシャルアクセスに弱いとかSSDはブロック単位で操作するからどうこうとか色々出てくるのですが、こういうのはfolkloreとかも多くてどこまで信じていいのか分からないので追求しないことにしました。
@naota さんとかが解説してくれないかな…。因みにカーネルのバージョンは5.8.0-41です。</p>

<p>再掲になりますが今回のコードはこちらです。</p>

<ul>
<li><a href="https://github.com/KeenS/io-uring-write-file">KeenS/io-uring-write-file</a></li>
</ul>

<p>何回か走らせて平均と分散とんないと何も議論できなくない？とかファイルキャッシュどうなってるの？とか色々気になるかと思います。そういう方は手元で走らせて実験してみて下さい。</p>

<p>最後に、参考にした資料を貼っておきます。</p>

<ul>
<li><a href="https://qiita.com/tmsn/items/0b9e5f84f9fbc56c1c82">Linuxにおける非同期IOの実装について - Qiita</a></li>
<li><a href="https://github.com/axboe/liburing">axboe/liburing</a>

<ul>
<li>特にexamplesとREADMEに貼ってあるPDF</li>
</ul></li>
<li><a href="https://github.com/shuveb/io_uring-by-example">shuveb/io_uring-by-example: A companion repository for the io_uring by Example article series</a></li>
<li><code>man io_uring_enter</code> 、 <code>man io_uring_register</code></li>
<li><a href="https://docs.rs/io-uring/0.4.0/io_uring/">io_uring - Rust</a></li>
</ul>

<p>締まりのない記事になりましたが参考になる方がいれば幸いです。</p>
                    </section>
                </article>
            </div>
        </div>

        <div class="row li-author">
    <div class="sixteen columns">
        Written by <strong>κeen</strong>
    </div>
</div>


        <div class="row li-pagination">
            <div class="eight columns">
                <div class="li-pagination-previous">
                    
                        Later article<br />
                        <a href="https://KeenS.github.io/search/"> Search</a>
                    
                </div>
            </div>
            <div class="eight columns">
                <div class="li-pagination-next">
                    
                        Older article<br />
                        <a href="https://KeenS.github.io/blog/2021/02/01/epolldetsukuruchattosa_ba/"> epollで作るチャットサーバ</a>
                    
                </div>
            </div>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2021. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="https://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>

