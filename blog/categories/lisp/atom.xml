<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Lisp | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/blog/categories/lisp/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2013-12-16T22:39:11+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[.emacsの整理をした話 + EmacsとViとShellとLispを悪魔合体させたら超絶便利だった]]></title>
    <link href="http://KeenS.github.io/blog/2013/12/13/dot-emacs-clean-up/"/>
    <updated>2013-12-13T02:55:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/12/13/dot-emacs-clean-up</id>
    <content type="html"><![CDATA[<p>やや長いタイトルですが・・・
年末になって大掃除がやってきましたね。みなさんもそろそろ.emacsの大掃除をしましょう。</p>

<!-- more -->


<p>私の.emacsは元々1300行ちょいあってEmacsの起動に7~8秒(体感)かかってましたが
大掃除&amp;高速化をした結果800行弱、起動に1秒(体感)ほどになったので整理の仕方を共有しますね。</p>

<p>前提ですが、私はinitローダーとかは使ってません。全部<code>init.el</code>に書いてます。で、機能毎にページを作って(<code>C-q C-l</code>)ます。
ただ、それだけだと視認性が悪いので見出しとして<code>C-u C-u C-u ;</code>で<code>;</code>を64個挿入して次の行にコメントで<code>#</code>付きのタイトルを付けてます。</p>

<p>具体的には</p>

<p>```common-lisp
^L
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; #Lisp</p>

<p>```</p>

<p>こんな感じのものが機能毎に書かれてます。これで<code>C-s</code>や<code>M-x occur</code>でハッシュタグのように検索することも<code>C-v</code>でスクロールしていって目grepすることも<code>C-x ]</code>で機能毎にジャンプすることもできます。</p>

<h1>1. Emacsの最新版を使う</h1>

<p>結構重要です。「標準のやつだと欲いこの機能がないから拡張パッケージ入れた」なんてのも最新版では改善されていたりします。
例えば私は<code>emacs-w3m</code>を使っていましたが、Emacsのmasterブランチには<code>eww</code>なるEmacs Lisp製のブラウザが入っているのでそれを使うようにしました。</p>

<p> <s>ただ、これが絶対的正義かというとそうでもなく、パッケージで入れてない分
Ubuntuのインプットメソッドとの連携部分がなかったので<code>uim.el</code>を入れる
必要が出てきたりと、面倒な部分もありました。Emacs標準のインプットメソッドはどうにも使いものにならず、
<code>ddskk</code>もuim-skkとコンフリクトする(というか<code>C-j</code>上書きとかありえない)ので使いません。インプットメソッドの切り替え部分は</p>

<p><code>common-lisp
(global-set-key (kbd "&lt;hiragana-katakana&gt;") #'uim-mode)
(global-set-key (kbd "&lt;zenkaku-hankaku&gt;") #'uim-mode) (autoload #'uim-mode "uim" nil t)
</code>
になりました。</s></p>

<p>2013-12-16追記<br/>
これは私が<code>~/.Xresources</code>に<code>Emacs*useXIM: false</code>を書いていたのが原因でした。<code>Emacs*useXIM: true</code>に書き換え、<code>xrdb ~/.Xresources</code>すると直りました。</p>

<h1>2. 普段使わない設定は全部消す</h1>

<p>基本ですね。私は<code>summary-edit.el</code>だとか<code>multiverse.el</code>だとかるびきちさんの本を読んで便利そうだから入れたものの、
結局使わなかったものの設定&amp;elispをごっそり削除。
あとかなりの言語に対してデフォルトで<code>auto-mode-alist</code>が設定されていたので<code>auto-mode-alist</code>の設定も全部消して、必要になったら書き足すようにしました。</p>

<h1>3. 普段使っていても代替の効くものは削除</h1>

<p>これは高速化の意味と自分の環境に依存しない意味があります。
最近、自分のラップトップ以外でもEmacsを触ることが多くあって、デフォルトのキーを上書きして使ってる部分で何度も誤操作したのでそれを減らす目的です。
<code>bm.el</code>は<code>C-x r SPC</code>の<code>register</code>系や<code>C-x C-SPC</code>で対応(registerは覚えれば使い出がありそうなのでいつか解説書くかもです)、<code>open-junk-file.el</code>は<code>~/tmp</code>を作って対応、
<code>recentf-ext.el</code>は<code>helm-file-buffers</code>だとか。</p>

<p>あと全て<code>helm.el</code>に置き換えて<code>helm.el</code>と<code>anything.el</code>が混在してる状態をどうにかしたかったのですが、<code>php-completion.el</code>かなにかが依存しててトドメを刺せませんでした。</p>

<p>あと、<code>viewer</code>の代替を探していたらタイトルにあるように悪魔合体が起きたので後で書きますね。</p>

<h1>4. できる限り標準のものを使う</h1>

<p>標準で提供されているパッケージは<code>autoload</code>が<code>emacs</code>バイナリに組込まれてる(と思う)ので起動時のオーバーヘッドはありません。
<code>flymake.el</code>や<code>ruby-mode.el</code>が標準で提供されてるのに気付いたのでそれを使ったりなど。一度<code>(emacsroot)/lisp</code>以下を眺めてみることをお勧めします。結構発見があるものです。</p>

<h1>5.<code>autoload</code>を使う</h1>

<p><code>autoload</code>とはファイルの読み込みを必要になるまで遅らせる仕組みです。「必要になる」ってのはそのファイルで定義されている関数が呼ばれたときです。
賢い<code>require</code>と思えば良いでしょう。</p>

<pre><code>(autoload #'関数名 "関数が呼ばれたときに読むファイル名" nil interactivep)
</code></pre>

<p>みたいに使います。<code>interactivep</code>の部分は<code>M-x</code>で呼ぶものなら<code>t</code>、そうでなければ<code>nil</code>です。
<code>require</code>を<code>autoload</code>で書き換えていけば理論上起動時の読み込み0にできるのでかなり高速化できます。</p>

<p>が、実際は一々<code>autoload</code>書くのはしんどいので次です。</p>

<h1>6.できる限り<code>package.el</code>を使う</h1>

<p><code>package.el</code>は必要な関数の<code>autoload</code>を自動生成して読み込んでおいてくれるのでかなりの手間が省けます。そして<code>autoload</code>があるのに<code>require</code>してると折角の<code>package.el</code>の配慮が無駄になります。</p>

<p>自動生成された<code>autoload</code>は<code>elpa/パッケージのディレクトリ/パッケージ-autoloads.el</code>にあるので確認しながら<code>init.el</code>の邪魔なものを消していきます。
これでかなり<code>init.el</code>の行数が減ります。今まで無駄な設定していたんだなと気付きます。</p>

<h1>7. <code>eval-after-load</code>を使う</h1>

<p>8割程の設定は<code>autoload</code>で対応できるのですが、
踏み込んだ設定をしているとパッケージの内部の関数を使ってしまって
どうしてもその式が評価される前にパッケージが読み込まれている必要があることがあります。</p>

<p>そんなときは<code>eval-after-load</code>を使います。名前のまんま、ロードした後で<code>eval</code>してくれます。</p>

<pre><code>(eval-after-load 'ファイル名
    '式)
</code></pre>

<p>の形で使います。複数の式を使いたい場合は<code>progn</code>を使って</p>

<pre><code>(eval-after-load 'ファイル名
    '(progn
         式1
         式2...))
</code></pre>

<p>のように使います。あるパッケージの拡張パッケージなんかもここで読むと良いかもしれません。</p>

<h1>8.その他</h1>

<p>メールクライアントを標準のものにしようとしましたが、<code>gnus.el</code>はちょっと受け付けなくてその他はimapを喋らないので断念。
でも色々調べてたら<code>mew</code>より<code>wanderlust</code>の方が良いようなので使い初めました。表示が綺麗で良いですね。
HTMLのレンダリングも<code>emacs-w3m</code>に頼らず標準の<code>shr.el</code>を使っているのも◎。</p>

<p>同じような経緯で<code>JDEE</code>をやめて<code>malabar.el</code>を使うようにしました。ただ、私は<code>maven</code>使いではないので微妙ではあります。
まあ、そもそもプロジェクト単位でJavaを書くことがないってのもあるんですが。Androidのスケルトンがantなのでantでできたら嬉しいなーって。</p>

<h1>EmacsとViとShellとLispを悪魔合体させた話</h1>

<p>私はEmacsの狂信者ですが読み専のときはちょいちょいviを使うこともあります。片手で操作できるのは便利です。
Emacsで読み専といえば<code>view-mode</code>です。そこでもhjklを使うべく<code>view-mode-map</code>に手を加えてましたが、大掃除ということで全部削除。</p>

<p>その後で<code>emacsroot/lisp/emulate/</code>以下を読んでいるとなんかviのエミュレーターが3つも見付かりました。<code>vi.el</code>、<code>vip.el</code>、<code>viper.el</code>です。
後者になるほどviとの互換性が高くなります。とりあえずは<code>hjkl</code>が使えれば良いので<code>vi.el</code>を使ってみたところ、ん〜…といったところ。<code>vip.el</code>と試して結局<code>viper.el</code>に落ち着きました。</p>

<pre><code>(global-set-key (kbd "C-x C-q") #'(lambda ()
                    (interactive)
                    (toggle-viper-mode)
                    (force-mode-line-update)))
</code></pre>

<p>設定はこんな感じです。<code>toggle-viper-mode</code>してもモードラインの表示が変わらないことがあったので<code>force-mode-line-update</code>を加えました。</p>

<p><code>viper.el</code>は単なるviのエミュレートだけではなく、Levelに応じて良い感じにemacsと悪魔合体してくれます。私は最高レベルの5にしました。"C-x C-s"など
基本的なコマンドはそのまま使えるようになってます。<code>:</code>で始まるvi(ex)のコマンドも使えます。<code>C-z</code>でemacs&lt;&ndash;>viを切り替えたり。非常に便利です。</p>

<p>尚、私はvi使いであってvim使いではないのでevilは使いません。</p>

<p>もう一つ、shellの話。今までは<code>multiterm</code> × <code>zsh</code>な感じでしたが、「できる限り標準のものを使う」方針で<code>eshell</code>に切り替えました。<code>eshell</code>はEmacs Lispで書かれたshellです。これが思った以上に便利です。
るびきちさんの本では標準出力とエラー出力の切り分けができてないと書かれてましたがそれは修正されてるようです。</p>

<p>あとは<code>/dev/kill</code>だとか<code>&gt;&gt;&gt;</code>だとかバッファへのリダイレクトだとか<code>grep</code>の上書きだとか色々楽しい拡張もあるのですが、一番は<code>eshell</code>がLispであること。
<code>eshell</code>上で任意のEmacs Lisp式を実行できます。最近Emacs LispやLispに精通してきたので非常に有り難いです。<br/>
それにファイルを開くときもその後で同じディレクトリのファイルを開くことが多いので一旦 <code>cd</code>してから<code>find-file</code>をするとアクセスし易くて捗ります。
もう起動時に<code>eshell</code>が立ち上がるようにして、基本そこから操作するようにしてます。guakeもそんなに使わなくなりました。
他の環境でも使えるので安心して依存できます。</p>

<p>で、ファイルを開くときはどうしてるかというと実はemacsの<code>find-file</code>ではなくviの<code>:e file-name</code>です。Emacs上でLispで出来たShellを使いつつviを動かしてます。
かなり人を選びますが「EmacsのヘビーユーザーでLispに精通しててviを便利だと思ってる人」は試してみてはいかがでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ClackのHandlerの書き方]]></title>
    <link href="http://KeenS.github.io/blog/2013/12/06/lisp-advent-calendar-7/"/>
    <updated>2013-12-06T00:06:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/12/06/lisp-advent-calendar-7</id>
    <content type="html"><![CDATA[<p>(この記事は<a href="http://qiita.com/advent-calendar/2013/lisp">Lisp Advent Calendar</a> 7日目のためのエントリです。<br/>
  (<a href="http://meymao.hatenablog.com/entry/2013/12/06/140029">6日目</a> meymaoさんより「Lisperがクリスマスに贈るべきプレゼント三選」)<br/>
  (<a href="http://www.principia-m.com/ts/0081/index-jp.html">8日目</a> athos0220さんよりマクロとクロージャで作る並行プログラミング言語))</p>

<p>ClackのHandlerの書き方についてちゃちゃっと解説します。</p>

<!-- more -->


<p>さっくりゆるふわな感じで行くので<a href="http://clacklisp.org/">clack公式</a>だとか<a href="http://clacklisp.org/tutorial/ja/">チュートリアル</a>だとかも参考にして下さい。とは言ってもCommon Lispな方なら知ってるでしょう。</p>

<h2>Clackって？</h2>

<p>PerlのPlackやRubyのRackと同じくCommon Lispの統一HTTPサーバーインターフェースです。開発時はHunchentootで、本番はFastCGIでみたいなことが簡単にできます。</p>

<h2>Handlerって？</h2>

<p>HunchentootやFastCGIといったバックエンドとClackとの間でリクエストやレスポンスの受け渡しを担当します。さっくり言うとHandlerを書けばClackで使えるサーバーが増える訳です。今(2013-12現在)のところ、Hunchentoot、FastCGI、Apache + mod_lisp2があるようです。</p>

<p>じゃあ、実際に軽量サーバーの<a href="https://github.com/gigamonkey/toot">toot</a>のハンドラを書きながら解説しますね</p>

<h2>準備</h2>

<p><code>git clone git@github.com:fukamachi/clack.git</code>してclackのソースコードを持ってきます。他のHanderがそうしてるようなので</p>

<ul>
<li> <code>clack/clack-handler-toot.asd</code></li>
<li> <code>clack/src/core/handler/toot.lisp</code></li>
</ul>


<p>   を作ります。<code>core</code>じゃなくて<code>contrib</code>だろとかそもそも自分のリポジトリに作れよとかは自由にやって下さい。<code>clack/clack-handler-toot.asd</code>は適当に似た名前のやつをコピーすれば良いんじゃないですかね？（適当</p>

<h2>書き方</h2>

<p>いたって簡単で、<code>run (app &amp;key debug (port 5000)) -&gt; acceptor</code>と<code>stop (acceptor) -&gt; 多分決まってない</code>を実装すれば良いです。</p>

<p>とはいっても<code>stop</code>は1行で終わりますが<code>run</code>は大きく分けて</p>

<ol>
<li>. サーバーを立ち上げる</li>
<li>. サーバーから渡されたリクエスト(多くの場合<code>request</code>オブジェクト)をplistにして<code>app</code>に渡す</li>
<li>. <code>app</code>のlist形式の返値を適切な形(多くの場合<code>response</code>オブジェクト)にしてサーバーに返す</li>
<li>. エラーハンドリング</li>
</ol>


<p>の4つの作業があります。一つ一つ説明していきますね。</p>

<h3>1 サーバーを立ち上げる</h3>

<p>tootの場合は<code>toot:start-server (&amp;key handler port)</code>を使いました。スレッド立てるのはclackがやってくれます。はい。</p>

<h3>2 サーバー渡されたリクエスト(多くの場合<code>request</code>オブジェクト)をplistにして<code>app</code>に渡す</h3>

<p>tootの場合、<code>key</code>の<code>handler</code>が<code>requesut</code>オブジェクトを受け取って<code>response</code>オブジェクトを返せば良いので</p>

<pre><code>(lambda (req)
    .....
    (call app (handle-request req))
    .....
)
</code></pre>

<p>って感じで<code>handle-request</code>に実装を書きます。</p>

<p><code>handle-request</code>の内部は<code>req</code>を<a href="http://clacklisp.org/tutorial/ja/04-the-environment.html">clack公式のチュートリアル</a>に載っているプロパティに一つ一つ変換していきます。このプロパティとバックエンドのオブジェクトのスロット名と実際のHTTPヘッダの名前が必ずしも一致しないのが泣き所です。さらに、大抵のサーバーの場合リクエストオブジェクトのスロットの詳細まではドキュメントに載ってないのでソースを参照しながら書くことになります。また、そもそも対応する値が無くて、他の情報を切り貼りして作らないといけなかったり、どうしようもなくて空にしないといけないこともあります。</p>

<p>tootハンドラは</p>

<pre><code>(defun handle-request (req)
  "Convert Request from server into a plist
before pass to Clack application."
  (let ((content-length (and (request-header :content-length req)
                             (parse-integer (request-header :content-length req) :junk-allowed t)))
    (port-and-host (get-port-and-host req)))
    (append
     (list
      :request-method (request-method req)
      :script-name ""
      :path-info (url-decode (request-path req))
      :server-name (car port-and-host)
      :server-port (cdr port-and-host)
      :server-protocol (server-protocol req)
      :request-uri (request-uri req)
      :url-scheme :HTTP;(request-scheme req)
      :remote-addr (remote-addr req)
      :remote-port (remote-port req)
      :query-string (request-query req)
      :content-length content-length
      :content-type (request-header :content-type req)
      :raw-body (let ((stream (toot::request-body-stream req)))
                  ;(when content-length
                    ;(setf (flex:flexi-stream-bound stream) content-length))
                  stream)
      :clack.uploads nil
      :clack.handler :toot)

     (loop for (k . v) in (toot::request-headers req)
           unless (find k '(:request-method :script-name :path-info :server-name :server-port :server-protocol :request-uri :remote-addr :remote-port :query-string :content-length :content-type :accept :connection))
             append (list (intern (format nil "HTTP-~:@(~A~)" k) :keyword)
                          v)))))
</code></pre>

<p>こんな感じに実装されてます。tootからインポートしたものの他、一部ヘルパー関数も使ってますが挙動はまあ、名前から察して下さい。</p>

<h3>3 <code>app</code>の返値のplistを適切な形(多くの場合<code>response</code>オブジェクト)にしてサーバーに返す</h3>

<p><code>app</code>を<code>call</code>してやると<code>(status headers body)</code>という形式のlistが返ってきます。<code>status</code>は数値、<code>headers</code>はplist、<code>body</code>はパスネーム又は文字列のリストです。</p>

<p>さっきはこんな感じで呼んだのでした。</p>

<pre><code>(lambda (req)
    .....
    (call app (handle-request req))
    .....
)
</code></pre>

<p>もうお分かりかと思いますが</p>

<pre><code>(lambda (req)
    (handle-response
        (call app (handle-request req)))
)
</code></pre>

<p>として、実装は<code>handle-response</code>に書きます。…が、tootは<code>response</code>オブジェクトではなく<code>request</code>オブジェクトに変更を加えたものを返すようなので</p>

<pre><code>(lambda (req)
    (handle-response
        req
        (call app (handle-request req)))
)
</code></pre>

<p>として、<code>app</code>の返値を元に<code>req</code>を書き換えます。こちらもあまりドキュメントが無いので頑張ってソース読むしかないです。因みに<code>body</code>はパスネームならそのファイルの内容を、文字列のリストならそれぞれを改行(<code>&lt;br&gt;</code>ではなく<code>\n</code>)で連結したものを返す必要があります。</p>

<p>tootハンドラの実装載せときますね。</p>

<pre><code>(defun handle-response (req res)
  (destructuring-bind (status headers body) res
    (etypecase body
      (pathname
       (multiple-value-call #'serve-file
     (values req body (parse-charset (getf headers :content-type)))))
      (list
       ;; XXX: almost same as Clack.Handler.Hunchentoot's one.
       (setf (status-code req) status)
       (loop for (k v) on headers by #'cddr
             with hash = (make-hash-table :test #'eq)
             if (gethash k hash)
               do (setf (gethash k hash)
                        (format nil "~:[~;~:*~A, ~]~A" (gethash k hash) v))
             else if (eq k :content-type)
               do (multiple-value-bind (v charset)
                      (parse-charset v)
                    (setf (gethash k hash) v)
                    (setf (toot::response-charset req) charset))
             else do (setf (gethash k hash) v)
             finally
          (loop for k being the hash-keys in hash
                using (hash-value v)
                do (setf (response-header k req) v)))
       (toot::send-response req (with-output-to-string (s)
      (format s "~{~A~^~%~}" body)))))))
</code></pre>

<p>です。</p>

<pre><code>(destructuring-bind (status headers body) res
  (etypecase body
    (pathname ...)
    (list ...)))
</code></pre>

<p>がテンプレートですね。<code>pathname</code>のときはtootに丸投げして<code>list</code>のときは<code>headers</code>とかを真面目に処理してます。</p>

<h3>4 エラーハンドリング</h3>

<p>早い話が500 internal server errorです。普通、Lispはエラーが起きるとデバッガに落ちますがサーバーは走り続ける必要がるのであらゆるエラーを無視する必要があります。が、しかしデバッグするとき(<code>run</code>のキーワード引数に<code>debug</code>がありましたね)はデバッガに落ちると嬉しいです。なので例のラムダを少し変更します。</p>

<pre><code>(lambda (req)
              (handle-response
               req
               (if debug (call app (handle-request req))
           (aif (handler-case (call app (handle-request req))
              (condition () nil))
            it
            '(500 nil nil)))))
</code></pre>

<p>これで完成です。</p>

<h2>テスト</h2>

<p>Clackにはテストが付いてます。テストケース自体は<code>clack/src/core/test/suite.lisp</code>に書かれてます。</p>

<p><code>clack/t/core/handler/hunchentoot.lisp</code>を参考に<code>clack/t/core/handler/toot.lisp</code>を作り、<code>clack/clack-test.asd</code>の<code>hunchentoot</code>を<code>toot</code>に書き換えたら準備完了です。<code>(ql:quickload :clack-test)</code>しましょう。テストが走ります。そして恐らくエラーが出て止まるでしょう。変な値を返すとサーバーじゃなくてテストの方がエラーで死ぬんですね。</p>

<p>そしたら<code>clack/src/core/test/suite.lisp</code>を開いて期待された値がなんだったかを調べてサーバーを修正します。で、また<code>(ql:quickload :clack-test)</code>の繰り返し。でも一回<code>quickload</code>しちゃうと読み直してくれないので私は一々<code>M-x slime-restart-inferior-lisp</code>してました。なんか違う気がする。これだけじゃなくてテスト全般。溢れるバッドノウハウ感。</p>

<p>とりあえずバックエンドにバグがあるとかのどうしようもない場合を除いてテストに全部合格すれば完成です</p>

<h2>完成したら</h2>

<p>どうしたらいいんでしょうね。分かんないです。clackにpull-req送るんでしょうか。あるいはquicklispに登録?私はとりあえず<a href="https://github.com/KeenS/clack">ブランチに置いてます</a>が恐らく誰も使ってないですし知らないと思います。</p>

<h2>で、何作ればいい？</h2>

<p><a href="https://github.com/fukamachi/clack/issues?state=open">clackのissue</a>にまだ作られてないものがリストされてます。「自分では需要はないけどなんか作ってみたい」といった奇特な方はそこから試すと良いんじゃないでしょうか。GAEとかmongrel2とか需要ありそうな気がします。</p>

<h2>まとめ</h2>

<p>誰得</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emacsのdired-modeを使い易くする]]></title>
    <link href="http://KeenS.github.io/blog/2013/10/04/emacs-dired/"/>
    <updated>2013-10-04T19:51:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/10/04/emacs-dired</id>
    <content type="html"><![CDATA[<p>Emacsの標準ライブラリ<code>dired.el</code>を読んでたら色々発見があったのでメモ兼dired-modeとはなんじゃらほいって方にも一から解説してみます。</p>

<!-- more -->


<p>とは言ってもいきなり解説しなくて申し訳ないのですが、最初に</p>

<pre><code>(ffap-bindings)
</code></pre>

<p>を設定しておきましょう。<code>C-x C-f</code>が非常に便利になります。
だいたいの方が設定してるかと思いますが、まだという方は<code>init.el</code>に書いて保存し、最後の<code>)</code>の後にカーソルを持っていって<code>C-x C-e</code>しましょう。設定が反映されます。
この設定で<code>C-x C-f</code>の入力がファイル以外も受け付けてくれますし、カーソルにポイントされてるファイルやURLをデフォルトで開こうとしてくれます。</p>

<p>…よし。じゃあ解説始めますよ。<code>C-x C-f ~/</code>してみて下さい。上の設定をしていたらディレクトリでも開ける筈です。するとホームディレクトリが<code>ls -al</code>された感じのバッファが出てくると思います。</p>

<p> <img src="/images/Screenshot_from_2013-10-04.png" title="&lsquo;dired-mode-screenshot&rsquo; &lsquo;私のホームはちょっとマズいのがあったので.emacs.dのスクリーンショット&rsquo;" ></p>

<p>これが<code>dired-mode</code>です。これは普通に<code>n</code>(<code>C-n</code>でも可)や<code>p</code>(<code>C-p</code>でも可)で移動して、Enterでそのファイルやディレクトリを開けます。これだけでも十分便利なのですが、ここからさらにファイル操作までできます。</p>

<p>適当なファイルにカーソルを合わせて<code>C</code>するとコピー先を聞かれるので、入力してあげるとコピーしてくれます。複数ファイルをコピーしたいなら、コピーしたいファイル上で<code>m</code>してマークを付けて、<code>C</code>すれば一括でコピーできます。</p>

<p>勿論、他にもコマンドはあります。同じような使い方のできる代表的なものを挙げると、</p>

<table>
<thead>
<tr>
<th></th>
<th> コマンド </th>
<th> 操作(実行されるLinuxコマンド)    </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> <code>C</code>      </td>
<td> コピー(<code>cp</code>)</td>
</tr>
<tr>
<td></td>
<td> <code>R</code>      </td>
<td> リネーム/移動(<code>mv</code>)</td>
</tr>
<tr>
<td></td>
<td> <code>D</code>      </td>
<td> 削除(<code>rm</code>)</td>
</tr>
<tr>
<td></td>
<td> <code>M</code>      </td>
<td> 権限操作(<code>chmod</code>)</td>
</tr>
<tr>
<td></td>
<td> <code>G</code>      </td>
<td> グループ変更(<code>chgrp</code>)</td>
</tr>
<tr>
<td></td>
<td> <code>O</code>      </td>
<td> 所有権変更(<code>chown</code>)</td>
</tr>
<tr>
<td></td>
<td> <code>Z</code>      </td>
<td> 圧縮/展開(<code>compress/uncompress/gunzip/bunzip/unzip</code>)</td>
</tr>
<tr>
<td></td>
<td> <code>B</code>      </td>
<td> (*.elファイルの)バイトコンパイル</td>
</tr>
<tr>
<td></td>
<td> <code>!</code>      </td>
<td> 任意のコマンドの実行。デフォルトで空気読んだコマンドになってる。</td>
</tr>
</tbody>
</table>


<p>他にも無数に操作はありますがファイル操作はこんなものでしょう。あとはバッファを閉じる<code>q</code>や親ディレクトリに移動する<code>^</code>、バッファの更新を行なう<code>g</code>、マークを外す<code>u</code>(<code>U</code>で全解除)を覚えていれば操作には困らない筈です。</p>

<p>が、頻繁に使っているとより良く使いたくなります。そこで今回見付けた設定を紹介します。</p>

<p>まず</p>

<pre><code>(add-hook 'dired-load-hook (lambda ()
                  (define-key dired-mode-map "r" 'wdired-change-to-wdired-mode)))
</code></pre>

<p>から。これはdired-modeで<code>r</code>するとバッファがエディタブルになり、ファイル名を普通に変更できます。そのまま<code>C-x C-s</code>すればリネームの終了です。<br/>
普通にEmacsの編集コマンドが使えるので <code>M-%</code>とかで一括拡張子変更とか<code>C-x r t</code>でファイル名にプリフィクスつけたり自由自在です。</p>

<p>次に</p>

<pre><code>(setq dired-listing-switches (purecopy "-Ahl"))
</code></pre>

<p>Emacsがdired-modeを表示するとき、実際に裏で <code>ls -al</code>を走らせているのですが、そのときのオプションを変更できます。但し内部で<code>-l</code>の結果を利用してるのでこれは必須です。しかしそれ以外は自由に設定できます。因みにWindowsでもEmacsがエミュレートしてくれるので設定可能ですが、一部未実装のものもあるそうです。</p>

<p>頻繁に使うなら</p>

<pre><code>(setq dired-dwim-target t)
</code></pre>

<p>もお勧めです。</p>

<p>これを設定しておくと、ウィンドウを分割して左右にdiredバッファを開いているとき、<code>R</code>や<code>C</code>のデフォルトの宛先がもう片方のディレクトリになります。伝わりますかね？</p>

<p> <img src="/images/Screenshot_from_2013-10-05.png" title="&lsquo;dired-mode in both of split window&rsquo; &lsquo;分割した両方のWindowでdired-modeを実行した状態。&rsquo;" ></p>

<p>のようにdiredでディレクトリA, Bを開いてるときにディレクトリAでファイルのコピーやら移動やらをするときにデフォルトでBに移動やコピーを行なうようになります。いくつかのファイルをディレクトリ間で移動させるときに非常に便利ですね。</p>

<p>あ、<code>C-x C-f /ftp:user@ftp-server:/path/to/dir</code>でFTPサーバーのディレクトリ/ファイルにもアクセスできるのは御存じですよね？これと組合せるとEmacsが割と使い易いFTPクライアントに大変身!</p>

<p>あとは私がどうしても欲しかったtarballですね。
 <div><script src='https://gist.github.com/KeenS/6828197.js?file=dired-tar.el'></script>
<noscript><pre><code>(defun dired-tar (tarname files &amp;optional arg)
  &quot;A dired-mode extension to archive files marked. With prefix argument, the tarball is gziped.&quot;
  (interactive (let ((files (dired-get-marked-files)))
		 (list (read-string &quot;Tarball name: &quot; (concat (file-relative-name (car files)) &quot;.tar.gz&quot;))
		       files &quot;P&quot;)))
  (let ((tar (if arg
		 (if dired-guess-shell-gnutar
		     (concat dired-guess-shell-gnutar &quot; zcf %s %s&quot;)
		   &quot;tar cf - %2s | gzip &gt; %1s&quot;)
	       &quot;tar cf %s %s&quot;)))
    (shell-command (format tar tarname (mapconcat 'file-relative-name files &quot; &quot;)))))
(add-hook 'dired-load-hook (lambda () (define-key dired-mode-map &quot;T&quot; 'dired-tar)))
</code></pre></noscript></div>

これでtarballにまとめたいファイルをマークして<code>T</code>すればまとめてくれます。<code>C-u T</code>するとgzip圧縮までしてくれます。因みに解凍/展開はファイル上で<code>!</code>するとデフォルトコマンドが展開(<code>tar xzvf</code>など)になってるので専用コマンドは必要ありません。補足ですが個人用なのでテストとかしてません。一旦御自身で動作テストなどをされてから実行されることをお勧めします。</p>

<p>他にも色々なコマンドがたくさんあったので興味のある方は探求してみて下さい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shellyを使ってCommon LispファイルをExecutableにする]]></title>
    <link href="http://KeenS.github.io/blog/2013/09/26/shelly-script/"/>
    <updated>2013-09-26T21:25:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/09/26/shelly-script</id>
    <content type="html"><![CDATA[<p>コマンドラインからCommon Lispの関数を実行できる<a href="https://github.com/fukamachi/shelly">Shelly</a>を使ってCommon Lispファイルを実行形式にしてみました。
Shellyは</p>

<pre><code>$ shly + 1 2
3
</code></pre>

<p>みたいに関数を実行できます。</p>

<!-- more -->


<p>モチベーションとしては、<a href="http://blog.8arrow.org/entry/20120521/1337596483">Shellyの作者深町さん</a>がTwitterで「Shellyでloadを使うとスクリプトみたいに実行できる」と発言していたのがきっかけで、Shebangを無視できればUNIX系ではExecutableにできるのでは？と思いついてやってみました。</p>

<p><code>read</code>して<code>eval</code>して…とか考えてましたが、<code>load</code>に<code>stream</code>を渡せるようなので案外簡単にできました。</p>

<p><div><script src='https://gist.github.com/KeenS/6688683.js?file=script.lisp'></script>
<noscript><pre><code>(in-package :shelly)
(export (defvar *argv* nil))
(in-package :cl-user)

(defun script (file argv)
  &quot;Execute a file as script ignoring shebang&quot;
  (setf shelly:*argv* argv)
  (let* ((in (open file :if-does-not-exist :error))
	 (first-char (read-char in))
	 (second-char (read-char in)))
    (cond
      ((and (char= first-char #\#) (char= second-char #\!))
       (read-line in))
      (t (unread-char second-char in)
	 (unread-char first-char in)))
    (load in)
    (values)))
</code></pre></noscript></div>
</p>

<p>コマンドライン引数を受け取るために<code>*argv*</code>という変数を用意してます。</p>

<p>こんなことを<code>~/.shelly/Shellyfile</code>に書いておき、Lispの初期化ファイルに</p>

<pre><code>#+shelly
(load "~/.shelly/Shellyfile")
</code></pre>

<p>と書いてます。この<code>~/.shelly/Shellyfile</code>にはShelly向けの関数を溜め込んでいく予定です。</p>

<p>あとは</p>

<p>```common-lisp</p>

<h1>!shly script</h1>

<p>(defun hello ()
  (format t &ldquo;Hello ~a~%&rdquo; (first shelly:<em>argv</em>)))
(hello)
<code>``
を</code>foo.lisp`に書き込めば</p>

<pre><code>$ chmod u+x foo.lisp
$./foo.lisp κeen
Hello κeen
</code></pre>

<p>と実行できます。勿論、</p>

<pre><code>$shly script foo.lisp κeen
</code></pre>

<p>としても同じです。
一部の処理系ではこのようなことが出来ますが、コマンドライン引数の渡し方とかも処理系依存なのでポータブルに書くなら一つ試してみてはいかがでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Common Lispスタイルガイド]]></title>
    <link href="http://KeenS.github.io/blog/2013/09/21/google-commonlisp-style-guide/"/>
    <updated>2013-09-21T17:00:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/09/21/google-commonlisp-style-guide</id>
    <content type="html"><![CDATA[<p>この度、<a href="http://google-styleguide.googlecode.com/svn/trunk/lispguide.xml">Google Common Lispスタイルガイド</a>が<a href="http://google-common-lisp-style-guide-ja.cddddr.org/">日本語に</a>なりました。</p>

<!-- more -->


<p>私が見付けた時点でほとんど日本語になってたのですが、ちょいちょい訳し残しがあったのでお手伝いをして、とりあえず英文は消えました。</p>

<p>ただまあこれで完成かというとそうでもなく、第一段階で「とりあえず」日本語になっただけ。第二段階がまだ残ってます。直訳も多々ありますし記法が統一できてなかったりします。</p>

<p>ですがこれで英語が苦手な方でも読めるかと思いますので読んでみて、変なところがあったらじゃんじゃんPull-Req送って下さい。マスターリポジトリは@massoさんの<a href="https://github.com/g000001/google-common-lisp-style-guide-ja">https://github.com/g000001/google-common-lisp-style-guide-ja</a>です。コメントに元の英文とか訳者のコメントとか残ってるので日本語が訳わかめな状態だったらそっちの方が分り易いかもしれません。</p>

<p>みなさん第二段階のご協力お願いします。</p>
]]></content>
  </entry>
  
</feed>
