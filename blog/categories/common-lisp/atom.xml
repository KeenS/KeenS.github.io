<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Common Lisp | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/blog/categories/common-lisp/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-01-27T16:10:29+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CIMの解説をしてみる コマンド編]]></title>
    <link href="http://KeenS.github.io/blog/2014/01/27/cim-explanation/"/>
    <updated>2014-01-27T13:55:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/01/27/cim-explanation</id>
    <content type="html"><![CDATA[<p>先日LTで紹介したCIMが思いの外反響を呼んでる(Githubのstarが15)ので解説でもしてみます。</p>

<p>コマンド編の次は実装編です。これでバグにエンカウントしたときの調査とか完璧ですね。</p>

<!-- more -->


<h1>インストーラ</h1>

<p>READMEにあるように</p>

<pre><code>curl https://raw.github.com/KeenS/CIM/master/scripts/cim_installer | /bin/sh
</code></pre>

<p>で<code>~/.cim/</code>にインストールできます。パスを変えたければ</p>

<pre><code>CIM_HOME=/path/to/cim curl https://raw.github.com/KeenS/CIM/master/scripts/cim_installer | /bin/sh
</code></pre>

<p>でOK。Cシェル系なら</p>

<pre><code>env CIM_HOME /path/to/cim curl https://raw.github.com/KeenS/CIM/master/scripts/cim_installer | /bin/sh
</code></pre>

<p>でしょうか。</p>

<p>ここでは<code>curl</code>を使ってますが<code>wget -O -</code>とか<code>fetch -o -</code>など標準出力に吐ければなんでも良いです。</p>

<p>あ、でも<code>CIM_HOME</code>を指定してインストールしたときにバグがある気がしてきました。今から直します。</p>

<p>CIMを使うにはシェルの起動時に初期化が必要ですが、インストーラが初期化ファイルを読みにいく処理を<code>.*rc</code>に書き出してくれます。Bourne Shellは<code>.profile</code>ですね。<br/>
書き出すファイルは<code>$SHELL</code>を見てます。<code>csh</code>、<code>tcsh</code>、<code>sh</code>、<code>bash</code>、<code>zsh</code>に対応してます。</p>

<p>あと<code>~/.emacs.d/eshell/</code>が存在したら<code>~/.emacs.d/eshell/profile</code>にも初期化処理を書き出します。一時期パスが間違ってて<code>~/.emacs.d/profile</code>に書き出してました。ごめんなさい。<br/>
vimshell(だっけ？)でも初期化さえしてしまえば使えると思うので誰か初期化処理書いて下さい。</p>

<h1><code>cim</code></h1>

<p>とりあえず<code>help</code>見ておきましょう。</p>

<p>```
$ cim help
CIM &mdash; Common Lisp Implementation Manager</p>

<p>Commands currently available
install &lt;impl[-version]>       ;; Install the impl.
use &lt;impl[-version]>           ;; Use specified impl as `cl' command&rsquo;s backend.
resume [rm] [resume..]         ;; Resume suspended installation(s) or give it up.
list <command>             ;; List available target of <command>
reinstall &lt;impl[-version]>     ;; Reinstall the impl.
clean <impl>|all           ;; Clean downloaded archive and src of the impl.
distclean <impl>|all           ;; Clean built dists.
uninstall &lt;impl[-version]>     ;; Uninstall the impl.
purge <impl>|all           ;; Just clean and uninstall the impl.
info                       ;; Display current state.
get                ;; Upgrade cim itself.
version                ;; Show the version
help <command>             ;; Show help for <command>. If no commands are specified, show this help.</p>

<p>If you want detailed help, type `cim help <command>&lsquo;.
```</p>

<h2><code>cim install</code></h2>

<p>```
$ cim help install
Usage:</p>

<pre><code>cim install &lt;impl[-version]&gt;
</code></pre>

<p>Description:</p>

<p>Install the given lisp implementation to cim directory.
If version is not specified, install the latest version.
If you want to pass specific options to &lsquo;configure&rsquo; script,
prefix &lsquo;flags=&rsquo;.</p>

<p>Examples:</p>

<pre><code># install sbcl-1.1.14
cim install sbcl-1.1.14

# install latest clisp with option.
flags='--with-libsigsegv-prefix=/usr/local' cim install clisp
</code></pre>

<p>To show available lisp implementations, type &lsquo;cim list install&rsquo;.</p>

<p><code>``
インストールします。はい。
</code>&lt;impl[-version]><code>ってのは</code>sbcl<code>とか</code>clisp-2.48<code>とかですね。バージョンを指定しなかったら最新版になります。
</code>cim list install`でインストール可能なものを表示しますが載ってない古いバージョンとかもインストールできる筈です。多分。</p>

<p><code>configure</code>スクリプトに渡すフラグを指定したいときは<code>flags='flag....' cim install</code>とします。ヘルプにあるように<code>libsigsegv</code>のパスを指定しないとFreeBSDでclispをインストールできなかったので用意しました。</p>

<p>Allegroはライセンス表示した方が良いのかなーとか考えてます。</p>

<h2><code>cim use</code></h2>

<p>```
Usage:</p>

<pre><code>cim use &lt;impl[-version]&gt; [--default]
</code></pre>

<p>Description:</p>

<p>Use <impl> as background for &lsquo;cl&rsquo; command. It also affects bare lisp command.
If version is not given, use latest version.
If &mdash;default is given, use the specified implementation at initial state.</p>

<p>Examples:</p>

<pre><code># use the latest sbcl
cim use sbcl
sbcl --version
-&gt; SBCL 1.1.14
# use old sbcl
cim use sbcl-1.1.10
sbcl --version
-&gt; SBCL 1.1.10

# use ccl-1.9 and set it default
cim use ccl-1.9 --default
</code></pre>

<p><code>``
</code>cl<code>コマンドのバックエンドの切り替えと処理系のバージョンの両方を切り替えます。処理系の指定の仕方は</code>install<code>に同じ。じゃなかった。</code>install<code>に加えて</code>/bin:/usr/bin:/usr/local/bin<code>にあるものを</code>xxx-system<code>として指定できます。</code>sbcl-system`とか。</p>

<p>例えば</p>

<pre><code>cim use clisp-2.48
</code></pre>

<p>ってやると<code>cl</code>コマンドがバックエンドとしてclispのバージョン2.48を使うようになりますし、<code>clisp</code>コマンドのバージョンも2.48になります。
この<code>clisp</code>の部分はリンクを貼り替えてて、一つのシェルで変更すると他のシェルにも影響が及ぶ問題があるのでそのうち直します。これ結構面倒なのでそのうちです。<br/>
clisp = clisp-2.48な状態で<code>cim use sbcl</code>するとclisp = clisp-2.48なまま<code>cl</code>のバックエンドがsbclになります。上手く使って下さい。</p>

<p><code>--default</code>を付けると次回からのデフォルト値を指定したものにしつつ<code>cim use</code>します。</p>

<h2><code>cim resume</code></h2>

<p>```
$ cim help resume
Usage:</p>

<pre><code>cim resume [rm] &lt;impl[-version]&gt; | all
</code></pre>

<p>Description:</p>

<p>Resume interrupted installation of <impl>. If <version> is not given, the latest version is used.
If &lsquo;rm&rsquo; is given, remove <impl> from &lsquo;resume&rsquo; list.
If target is &lsquo;all&rsquo;, do on all the available target.</p>

<p>Examples:</p>

<pre><code># resume the installation of clisp with configure flags
flags='--with-libsigsegv-path=/usr/local' cim resume clisp

# remove all the available target.
cim resume rm all
</code></pre>

<p><code>``
</code>cim install<code>がエラー終了したり</code>Ctrl-C<code>で中断したりしたやつを再開してくれるコマンドです。</code>cim install sbcl<code>を中断したなら</code>cim resume sbcl<code>で再開できます。</code>cim resume all`で中断された全てのインストールを再開します。終了ステータスは再開してもまたエラーで終了したやつの数になります。</p>

<p><code>cim resume rm sbcl</code>だと<code>cim list resume</code>の結果から<code>sbcl</code>を削除できます。<code>resume</code>はしませんよ。<code>cim resume rm all</code>とかも可能です。</p>

<h2><code>cim list</code></h2>

<p>```
$ cim help list
Usage:</p>

<pre><code>cim list &lt;subcommand&gt;
</code></pre>

<p>Description:</p>

<p>List available target for subcommand.</p>

<p>Examples:</p>

<pre><code># list available lisp implementation to install
cim list install

# show available target for list
cim list list

# targets for subsubcommands are also available
cim list resume rm
</code></pre>

<p>```</p>

<p>さっきから出てきてるので分かるかと思いますが、可能なターゲットを表示します。将来的には<code>zsh</code>の補完候補にも使うつもりです。そのときは<code>-b, --batch</code>オプションでhuman readableかmachine readableかを分けようかなと。</p>

<h2><code>cim reinstall</code></h2>

<p>```
$ cim help reinstall
Usage:</p>

<pre><code>cim reinstall &lt;impl[-version]&gt; | all
</code></pre>

<p>Description:</p>

<p>Force install already installed implementaion(s). Downloaded archives are resued if available
If version is not specified, install the latest version.
If target is &lsquo;all&rsquo;, do on all the available targets.</p>

<p>Examples:</p>

<pre><code># reinstall sbcl-1.1.14
cim reinstall sbcl-1.1.14

# reinstall all installed lisp impls
cim reinstall all
</code></pre>

<p>To show available lisp implementations, type &lsquo;cim list reinstall&rsquo;.</p>

<p><code>``
</code>cim install<code>は既にインストールされているものはインストールできないのですが、</code>reinstall<code>を使えば可能です。ダウンロードしたアーカイブがあればそれを使います。なければダウンロードから始めます。</code>all<code>は察しのようにインストール済のものを全て</code>reinstall`します。</p>

<h2><code>cim clean</code></h2>

<p>```
$ cim help clean
Usage:</p>

<pre><code>cim clean &lt;impl[-version]&gt; | all
</code></pre>

<p>Description:</p>

<p>Remove donwloaded archives and extracted sources of the given lisp implementations.
If version is not specified, install the latest version.
If target is &lsquo;all&rsquo;, do on all the available targets.</p>

<p>Examples:</p>

<pre><code># clean sbcl-1.1.14
cim clean sbcl-1.1.14

# clean all installed lisp impls
cim clean all
</code></pre>

<p>To show available lisp implementations, type &lsquo;cim list clean&rsquo;.</p>

<p><code>``
</code>cim install<code>は基本的に不要なものも削除しないので、それが嫌なら</code>clean`を使いましょうというスタンスです。アーカイブとソースを削除します。</p>

<h2><code>cim distclean</code></h2>

<p>```
$cim help distclean
Usage:</p>

<pre><code>cim distclean &lt;impl[-version]&gt; | all
</code></pre>

<p>Description:</p>

<p>Clean built files of the given lisp implementation. It doesn&rsquo;t mean uninstall.
If version is not specified, install the latest version.
If target is &lsquo;all&rsquo;, do on all the available targets.</p>

<p>Examples:</p>

<pre><code># distclean sbcl-1.1.14
cim distclean sbcl-1.1.14

# distclean all installed lisp impls
cim distclean all
</code></pre>

<p>To show available lisp implementations, type &lsquo;cim list distclean&rsquo;.</p>

<p><code>``
</code>cim clean<code>より控えめなコマンドです。コンパイルするときに</code>make<code>で生成されたファイルを削除します。</code>make clean`的な。</p>

<h2><code>cim uninstall</code></h2>

<p>```
$ cim help uninstall
Usage:</p>

<pre><code>cim uninstall &lt;impl[-version]&gt; | all
</code></pre>

<p>Description:</p>

<p>Uninstall the given lisp implementaion(s). It does&rsquo;t remove donwloaded archives and extracted sources.
If version is not specified, install the latest version.
If target is &lsquo;all&rsquo;, do on all the available targets.</p>

<p>Examples:</p>

<pre><code># uninstall sbcl-1.1.14
cim uninstall sbcl-1.1.14

# uninstall all installed lisp impls
cim uninstall all
</code></pre>

<p>To show available lisp implementations, type &lsquo;cim list uninstall&rsquo;.</p>

<p>```
アンインストールします。はい。ただしダウンロードしたアーカイブとソースは削除しません。</p>

<h2><code>cim purge</code></h2>

<p>```
$ cim help purge
Usage:</p>

<pre><code>cim purge &lt;impl[-version]&gt; | all
</code></pre>

<p>Description:</p>

<p>Uninstall and clean up downloaded files of the given lisp implementation.
This command is equivalent to &lsquo;clean&rsquo; and &lsquo;uninstall&rsquo;.</p>

<p>Examples:</p>

<pre><code># purge the latest sbcl
cim purge sbcl
</code></pre>

<p>To show available target for &lsquo;purge&rsquo;, type &lsquo;cim list purge&rsquo;</p>

<p><code>``
</code>uninstall`のアーカイブとソースを削除する版です。</p>

<h2><code>cim info</code></h2>

<p>```
$ cim help info
Usage:</p>

<pre><code>cim info
</code></pre>

<p>Description:</p>

<p>Display information for current cim. It includes environment variables that cim uses, what current and default lisp implementation is, what version of each implementation is used, and where system lisp is.</p>

<p>Example:</p>

<pre><code># display info
cim info
</code></pre>

<p>```
現在の状態を表示します。こんな感じ。</p>

<p>```
$ cim info
CIM_ID   = 22176
CIM_HOME = /home/kim/.cim</p>

<p>current lisp = sbcl-system
default lisp = sbcl-system</p>

<p>abcl  = abcl-1.2.1
alisp = alisp-9.0
ccl   = ccl-1.9
clisp = clisp-2.49
ecl   = ecl-13.5.1
gcl   = gcl-2.6.9
sbcl  = sbcl-system</p>

<p>sbcl-system  = /usr/local/bin/sbcl
gcl-system   = /usr/bin/gcl</p>

<p>```</p>

<p><code>CIM_ID</code>ってのは<code>cim</code>がそれぞれのシェルの状態を管理するためのIDです。まあ、そのシェルのプロセスIDですね。逆にプロセスIDの取得と環境変数の設定さえできれば<code>cim</code>は動かせるのでEmacsでも簡単に動きます。</p>

<h2><code>cim get</code></h2>

<p>```
$ cim help get
Usage:</p>

<pre><code>cim get
</code></pre>

<p>Description:</p>

<p>Upgrade to the latest cim.</p>

<p>Examples:</p>

<pre><code>cim get
</code></pre>

<p>```</p>

<p>cim自身のアップデートです。なんでこんな名前かというと<code>rvm</code>がそうだからです。現状はgithubのKeenS/CIMのmasterからとってきます。stable版ができたらstableに変更しますね。実はブランチを指定してとってくる方法もあったりはします。<code>cim get --branch stable</code>か <code>CIM_INSTALL_BRANCH=stable cim get</code>です。まだブランチが無いので意味ないんですけどね。</p>

<p>この辺で気付いたかもしれませんが結構環境変数で制御できるようにデザインされてます。rubyがそんな感じだからです。</p>

<h2><code>cim version</code></h2>

<p>```
$ cim help version
Usage:</p>

<pre><code>cim version
</code></pre>

<p>Description:</p>

<p>Show current cim&rsquo;s version</p>

<p>Example:</p>

<pre><code>cim version
</code></pre>

<p>```
めちゃくちゃバグがあるのにversionが1.0.0に見えるの気のせいです。きっと100点中の1点なんですよ。</p>

<h2><code>cim help</code></h2>

<p><code>
$ cim help help
Help for 'help' is not prepared, sorry.
</code>
あー。<code>help</code>のhelp用意してなかったー。まあ、上で使ったのが全てです。</p>

<h1><code>cl</code></h1>

<p>```
$ cl -h
Usage: cl [switchs] [&mdash;] [programfile] [argumensts]</p>

<p>-C DIR          set <em>default-pathname-defaults</em> DIR.
-d, &mdash;debug     set debugging flags (push :debug into <em>features</em>)
-e, &mdash;eval SEXP one line of script. Several -e&rsquo;s are allowed. Omit [programfile]
-f, &mdash;load FILE load the FILE
-i EXT          edit <em>argv</em> files in place and make backup with the extension .EXT
-l LIBRARY      quickload the LIBRARY
-L LIBRARY      quickload and use-package the LIBRARY
-r, &mdash;repl      run repl
-q, &mdash;no-init   do not load $CIM_HOME/init.lisp
&mdash;no-rl         do not use rlwrap. This is effective only when &mdash;repl is specified
&mdash;no-right      do not display right prompt. This is effective only when &mdash;repl is specified
&mdash;no-color      do not use color. This is effective only when &mdash;repl is specified
-h, &mdash;help      print this help
-v, &mdash;version   print the version</p>

<p>If neither programfile, -e (&mdash;eval) nor -r (&mdash;repl) are specified, cl reads scripts from the standard input and then eval them.</p>

<p>```</p>

<p>まあ、見たら分かりますね。ruby由来のオプションとShelly由来のオプションと私の好みのオプションがあります。<code>cl</code>を起動する方法は</p>

<ul>
<li><code>cl script.lisp</code></li>
<li><code>cl &lt; script.lisp</code></li>
<li><code>cl -e sexp</code></li>
<li><code>cl -r</code></li>
</ul>


<p>です。<code>cl script.lisp</code>はシェバン(最初の行が<code>#!</code>なもの)を無視します。</p>

<p>また、これも環境変数<code>LISP_IMPL</code>でバックエンドを制御できます。これはShelly由来ですね。</p>

<p>もう一つ、デバッガは起動しません。スクリプトやワンライナーはエラーを吐いて終了して欲しいですし次に述べますがREPLも目的からしてデバッガは相応しくないと思うからです。因みにですが<code>-d</code>オプションをつけてもデバッガは起動しません。理由はオプション解析のほとんどをLispに任せているので起動時のオブションである<code>--disable-debugger</code>を制御できないからです。需要が高そうならシェルスクリプト内で解析して頑張ってみます。</p>

<p>あ、<code>-c, --compile FILE</code>オプションつけ忘れてた。いつか入れます。<code>(compile-file FILE)</code>で可能でしょうからすぐに入るはずです。</p>

<h2><code>cl -r</code></h2>

<p>一応開発向けではなくて、ちょっと試したいときや初心者が本を片手に動かすときを想定して作ってます。エラーはメッセージのみ表示。ちょっと試したいときはあんまりデバッガを必要としませんしスタックトレースもどうせ深さ1~2なのであまり必要でないからです。なにより初心者にとってデバッガは何をして良いか分かりませんし覚えても処理系毎に操作が違います。その辺を分り易い統一インターフェースを作ることも考えたのですが「それって<code>swank</code>」って結論に至ったのでこのままです。</p>

<h1><code>ql</code></h1>

<p>```
ql &mdash; Command line interface for quicklisp</p>

<p>Commands currently available
deps <system>           ;; Install dependencies of <system>.
help [command]          ;; Show help.
install[quickload] <system>&hellip;  ;; Install given system.
list {remote | local}       ;; List available/installed systems.
search[system-propos] <keyword> ;; Search quicklisp.
uninstall <system>          ;; Uninstall system.
update [system]             ;; Update dist info and installed systems.
<code>``
一番未完成なコマンドです。主な理由は私が</code>quicklisp`の使い方を分かってないからです。</p>

<h2><code>ql deps</code></h2>

<p>```
$ ql help deps
Usage:</p>

<pre><code>ql deps [--path &lt;path&gt;] &lt;system&gt;
</code></pre>

<p>Description:</p>

<p>Install dependencies of given system. If path is specified, install dependencies there.
Once you run &lsquo;ql &mdash;path <path> deps&rsquo;, you don&rsquo;t need to specify &lsquo;&mdash;path&rsquo; because the path is written out to &lsquo;.quicklisp-path&rsquo; in current directory.
You can run &lsquo;ql deps&rsquo; for a local system if &lsquo;.asd&rsquo; file is in current directory.
This command is useful when you want to separate quicklisps for local project.</p>

<p>Example:</p>

<pre><code>ql deps --path ./quicklisp my-project
</code></pre>

<p><code>``
rubyの</code>bundler<code>を参考に作りました。</code>Gemfile<code>に対応する</code>QLfile<code>でも読もうかと思いましたが良く考えたら</code>.asd<code>で十分じゃんとの思いに至ったのでカレントパスの</code>asd`ファイルを読みます。<br/>
が、奴は依存システムのバージョンまでは指定できなかった気がするのでやっぱり必要な気がします。</p>

<p><code>ql deps --path ./ql myapp</code>とすると依存システム(+新たな<code>quicklisp</code>本体)を<code>./ql</code>にインストールしてくれます。<code>quicklisp</code>本体のインストールは不要ですがどうやったら回避できるかは今模索中です。<br/>
<code>--path</code>の位置が<code>cim use --default</code>と違うのでご注意下さい。これは主に内部で使ってる<code>parse-option</code>の欠陥に由来します。<br/>
一度指定すると<code>.quicklisp-path</code>にパスを書き出してくれるので次回からは必要なくなります。カレントディレクトリに複数の<code>asd</code>ファイルがあってそれぞれでパスを使い分けたいとかはできません。<br/>
あと、最大の欠陥として<code>./ql</code>にシステムをインストールしてもそれを読み込みにいくコマンドがないので実用性ゼロです← まあ、<code>cl</code>あたりを弄ってカレントパスに<code>.quicklisp-path</code>があったら読みにいくようにします。その辺は<code>.lisp-impl</code>とかも含めて考えます。</p>

<h2><code>ql help</code></h2>

<p>```
$ ql help help
Help for &lsquo;help&rsquo; is not prepared, sorry.</p>

<p>```
こいつもhelp用意してなかった。まあ、良いや。</p>

<h2><code>ql install</code></h2>

<p>```
$ ql help install
Usage:</p>

<pre><code>ql install &lt;system&gt;...
</code></pre>

<p>Description:</p>

<p>Install given system(s) to $CIM_HOME/quicklisp.</p>

<p>Example:</p>

<pre><code># install clack
ql install clack
</code></pre>

<p>```</p>

<p>なんでこいつがhelpの先頭に居ないんでしょうね。<code>cim</code>に比べて適当ですね。</p>

<p><code>ql quickload</code>っていう別名も持ってます。<code>ql help</code>には<code>quickload</code>が本名で<code>install</code>がエイリアスって書いてありましたが実装ミスりました。</p>

<p>名前の通り<code>ql:quickload</code>します。<code>system</code>は複数指定できます。</p>

<h2><code>ql list</code></h2>

<p>```
$ ql list
Usage:</p>

<pre><code>ql list {remote | [local]}
</code></pre>

<p>Description:</p>

<p>List installed systems. if &lsquo;remote&rsquo; is given, list all the available systems. &lsquo;ql list local&rsquo; is equivalent to &lsquo;ql list&rsquo;.</p>

<p>Example:</p>

<pre><code>ql list remote
</code></pre>

<p>```</p>

<p><code>cim list</code>と使い方が違ってアレですね。現状<code>quicklisp</code>に登録されているもの全てを表示する<code>ql list remote</code>とインストールしたものだけを表示する<code>ql list [local]</code>があります。<code>ql deps</code>でパスを指定したやつらにも使いたかったのですが方法が分かんないのでとりあえず先送りです。</p>

<h2><code>ql search</code></h2>

<p>```
$ ql help search
Usage:</p>

<pre><code>ql search &lt;keyword&gt;
</code></pre>

<p>Description:</p>

<p>Search quicklisp for <keyword>.</p>

<p>Example:</p>

<pre><code>ql search http
</code></pre>

<p>```</p>

<p>別名<code>system-apropos</code>。別名と本名が<code>ql help</code>と違うのも単に<code>ql:system-apropos</code>を呼ぶのも<code>ql install</code>と同じです。出力結果をもうちょっと制御したいなと思ってます。</p>

<h2><code>ql uninstall</code></h2>

<p>```
$ ql help uninstall
Usage:</p>

<pre><code>ql uninstall &lt;system&gt;...
</code></pre>

<p>Description:</p>

<p>Uninstall given system(s).</p>

<p>Example:</p>

<pre><code>ql uninstall caveman clack
</code></pre>

<p><code>``
</code>ql:uninstall`に同じ。以上。</p>

<h2><code>ql update</code></h2>

<p>```
$ ql help update
Usage:</p>

<pre><code>ql update [client]
</code></pre>

<p>Description:</p>

<p>Update installed systems. If target &lsquo;client&rsquo; is given, update quicklisp itself.</p>

<p>Example:</p>

<pre><code>ql update client
</code></pre>

<p>```</p>

<p><code>ql:update-all-dists</code>か<code>ql:update-client</code>かを選べます。最初はsystem毎にアップデートしたかったのですが無理っぽいので止めました。</p>

<h1>おわりに</h1>

<p>とりあえずCIMの機能はこれで全部です。あ、開発用に<code>cim reset</code>とかありますけど使わないで下さい。とういうか使うなよ。絶対使うなよ。</p>

<p>これら使ってみてバグがあったらgithubのissueに投げるなりtwitterで報告するなりして下さい。</p>

<p>ところでCIMは私はちむと読んでます。しー・あい・えむと読む人も居るようです。何でも良いです。プロジェクトとしてのちむとコマンドとしてのちむを区別するためにコマンドは小文字で<code>cim</code>、そして<code>cim</code>、<code>cl</code>、<code>ql</code>を含んだプロジェクトは大文字でCIMと書くことにします。今考えました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lisp Meet Up #13でLTしてきました]]></title>
    <link href="http://KeenS.github.io/blog/2014/01/24/lisp-meet-up-number-13/"/>
    <updated>2014-01-24T02:29:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/01/24/lisp-meet-up-number-13</id>
    <content type="html"><![CDATA[<p>もう12時回ったので昨日になってしまいましたが<a href="http://atnd.org/events/46746#comments">Lisp Meet Up presented by Shibya.lisp #13</a>に参加してLTしてきたので報告(?)エントリです。</p>

<!-- more -->


<p>先月東京に戻ってきた深町さんがめちゃくちゃ宣伝してたせいか20人参加希望があり、19人参加しました。</p>

<p>自己紹介ではClojureが多いなーってのとRubyistが混ってたりしたのが印象的でした。Emacs Lispの人も居たり。</p>

<p>LTは一人目がにとり(深町英太郎 (fukamachi))(@nitro_idiot)さん。今更ながら呼び方に困りましたね。内容はO/Rマッパーの<a href="https://github.com/fukamachi/integral"><code>integral</code></a>の機能と実装について。<br/>
非Common Lisperが多い中Meta Object Protocolについて色々説明したりと大変そうでした。私はCommon LisperなのでMOPにそんな使い方がるのかとか結構面白かったです。<br/>
<s>スライドはまだ上げてないみたいです。そのうち上がるでしょう。</s>上がりました。</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/30362150" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/fukamachi/lisp-meet-up-presented-by-shibuyalisp-13" title="Integral - New O/R Mapper for Common Lisp" target="_blank">Integral &ndash; New O/R Mapper for Common Lisp</a> </strong> from <strong><a href="http://www.slideshare.net/fukamachi" target="_blank">fukamachi</a></strong> </div></p>

<p>二人目が私。最近作ってる<a href="https://github.com/KeenS/CIM"><code>CIM</code></a>についてです。スライド見るのが速いですね。</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/30338391" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/blackenedgold/cim-common-lisp-implementation-manager" title="CIM - Common Lisp Implementation Managerを作りました" target="_blank">CIM &ndash; Common Lisp Implementation Managerを作りました</a> </strong> from <strong><a href="http://www.slideshare.net/blackenedgold" target="_blank">blackenedgold</a></strong> </div></p>

<p>実際にそれぞれのコマンドを動かしてみた結果、予想してなかったエラーなとがあったものの割と聴衆の反応は良かったです。あとはPure Bourne Shell Scriptで挑んで爆死した話とかしたりですね。「詳解シェルスクリプト」を読んだり<code>man</code>ページ読んだりして頑張ったんですよ。</p>

<p>それが終わったら一旦休憩。そしたらわざわざ深町さんが私のところに来て下さって「Shellyより良いプロダクトになると思います。頑張って下さい。」との御言葉を頂きました。非常に嬉しかったです。私が作ったものが認められた。しかも着想の元になったShellyの作者の深町さんから。<br/>
でもその後実際に何人か使ってみてくれたのですが、バグが立て続けに3つくらい発覚して「…これ、テスト必要ですね」と絶句。分かってます。分かってますけど難しいんです泣。<br/>
他はgithubでCIMを探そうとしてる方が居たんですが同じ名前のレポジトリがめちゃくちゃあって検索性悪いなとか。何故か私のハンドルネームの最初の文字がk(ケー)ではなくκ(カッパ)なのを知ってたり。</p>

<p>その後の懇親会では向かいが深町さん、隣が佐野さん(実践Common Lispの訳者)で、Common Lispの今後とか色々な話をしてました。<a href="http://redmonk.com/sogrady/2014/01/22/language-rankings-1-14/">ここ</a>のグラフでCommon Lispがありえない位置にいるしどうやったら普及するんだろうねーとか。</p>

<p>運営のchikuさん potixさん、発表を聞いてCIMを試してくれたりGithubにstarくれたりしたみなさんありがとう御座いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ClackのHandlerの書き方]]></title>
    <link href="http://KeenS.github.io/blog/2013/12/06/lisp-advent-calendar-7/"/>
    <updated>2013-12-06T00:06:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/12/06/lisp-advent-calendar-7</id>
    <content type="html"><![CDATA[<p>(この記事は<a href="http://qiita.com/advent-calendar/2013/lisp">Lisp Advent Calendar</a> 7日目のためのエントリです。<br/>
  (<a href="http://meymao.hatenablog.com/entry/2013/12/06/140029">6日目</a> meymaoさんより「Lisperがクリスマスに贈るべきプレゼント三選」)<br/>
  (<a href="http://www.principia-m.com/ts/0081/index-jp.html">8日目</a> athos0220さんよりマクロとクロージャで作る並行プログラミング言語))</p>

<p>ClackのHandlerの書き方についてちゃちゃっと解説します。</p>

<!-- more -->


<p>さっくりゆるふわな感じで行くので<a href="http://clacklisp.org/">clack公式</a>だとか<a href="http://clacklisp.org/tutorial/ja/">チュートリアル</a>だとかも参考にして下さい。とは言ってもCommon Lispな方なら知ってるでしょう。</p>

<h2>Clackって？</h2>

<p>PerlのPlackやRubyのRackと同じくCommon Lispの統一HTTPサーバーインターフェースです。開発時はHunchentootで、本番はFastCGIでみたいなことが簡単にできます。</p>

<h2>Handlerって？</h2>

<p>HunchentootやFastCGIといったバックエンドとClackとの間でリクエストやレスポンスの受け渡しを担当します。さっくり言うとHandlerを書けばClackで使えるサーバーが増える訳です。今(2013-12現在)のところ、Hunchentoot、FastCGI、Apache + mod_lisp2があるようです。</p>

<p>じゃあ、実際に軽量サーバーの<a href="https://github.com/gigamonkey/toot">toot</a>のハンドラを書きながら解説しますね</p>

<h2>準備</h2>

<p><code>git clone git@github.com:fukamachi/clack.git</code>してclackのソースコードを持ってきます。他のHanderがそうしてるようなので</p>

<ul>
<li> <code>clack/clack-handler-toot.asd</code></li>
<li> <code>clack/src/core/handler/toot.lisp</code></li>
</ul>


<p>   を作ります。<code>core</code>じゃなくて<code>contrib</code>だろとかそもそも自分のリポジトリに作れよとかは自由にやって下さい。<code>clack/clack-handler-toot.asd</code>は適当に似た名前のやつをコピーすれば良いんじゃないですかね？（適当</p>

<h2>書き方</h2>

<p>いたって簡単で、<code>run (app &amp;key debug (port 5000)) -&gt; acceptor</code>と<code>stop (acceptor) -&gt; 多分決まってない</code>を実装すれば良いです。</p>

<p>とはいっても<code>stop</code>は1行で終わりますが<code>run</code>は大きく分けて</p>

<ol>
<li>. サーバーを立ち上げる</li>
<li>. サーバーから渡されたリクエスト(多くの場合<code>request</code>オブジェクト)をplistにして<code>app</code>に渡す</li>
<li>. <code>app</code>のlist形式の返値を適切な形(多くの場合<code>response</code>オブジェクト)にしてサーバーに返す</li>
<li>. エラーハンドリング</li>
</ol>


<p>の4つの作業があります。一つ一つ説明していきますね。</p>

<h3>1 サーバーを立ち上げる</h3>

<p>tootの場合は<code>toot:start-server (&amp;key handler port)</code>を使いました。スレッド立てるのはclackがやってくれます。はい。</p>

<h3>2 サーバー渡されたリクエスト(多くの場合<code>request</code>オブジェクト)をplistにして<code>app</code>に渡す</h3>

<p>tootの場合、<code>key</code>の<code>handler</code>が<code>requesut</code>オブジェクトを受け取って<code>response</code>オブジェクトを返せば良いので</p>

<pre><code>(lambda (req)
    .....
    (call app (handle-request req))
    .....
)
</code></pre>

<p>って感じで<code>handle-request</code>に実装を書きます。</p>

<p><code>handle-request</code>の内部は<code>req</code>を<a href="http://clacklisp.org/tutorial/ja/04-the-environment.html">clack公式のチュートリアル</a>に載っているプロパティに一つ一つ変換していきます。このプロパティとバックエンドのオブジェクトのスロット名と実際のHTTPヘッダの名前が必ずしも一致しないのが泣き所です。さらに、大抵のサーバーの場合リクエストオブジェクトのスロットの詳細まではドキュメントに載ってないのでソースを参照しながら書くことになります。また、そもそも対応する値が無くて、他の情報を切り貼りして作らないといけなかったり、どうしようもなくて空にしないといけないこともあります。</p>

<p>tootハンドラは</p>

<pre><code>(defun handle-request (req)
  "Convert Request from server into a plist
before pass to Clack application."
  (let ((content-length (and (request-header :content-length req)
                             (parse-integer (request-header :content-length req) :junk-allowed t)))
    (port-and-host (get-port-and-host req)))
    (append
     (list
      :request-method (request-method req)
      :script-name ""
      :path-info (url-decode (request-path req))
      :server-name (car port-and-host)
      :server-port (cdr port-and-host)
      :server-protocol (server-protocol req)
      :request-uri (request-uri req)
      :url-scheme :HTTP;(request-scheme req)
      :remote-addr (remote-addr req)
      :remote-port (remote-port req)
      :query-string (request-query req)
      :content-length content-length
      :content-type (request-header :content-type req)
      :raw-body (let ((stream (toot::request-body-stream req)))
                  ;(when content-length
                    ;(setf (flex:flexi-stream-bound stream) content-length))
                  stream)
      :clack.uploads nil
      :clack.handler :toot)

     (loop for (k . v) in (toot::request-headers req)
           unless (find k '(:request-method :script-name :path-info :server-name :server-port :server-protocol :request-uri :remote-addr :remote-port :query-string :content-length :content-type :accept :connection))
             append (list (intern (format nil "HTTP-~:@(~A~)" k) :keyword)
                          v)))))
</code></pre>

<p>こんな感じに実装されてます。tootからインポートしたものの他、一部ヘルパー関数も使ってますが挙動はまあ、名前から察して下さい。</p>

<h3>3 <code>app</code>の返値のplistを適切な形(多くの場合<code>response</code>オブジェクト)にしてサーバーに返す</h3>

<p><code>app</code>を<code>call</code>してやると<code>(status headers body)</code>という形式のlistが返ってきます。<code>status</code>は数値、<code>headers</code>はplist、<code>body</code>はパスネーム又は文字列のリストです。</p>

<p>さっきはこんな感じで呼んだのでした。</p>

<pre><code>(lambda (req)
    .....
    (call app (handle-request req))
    .....
)
</code></pre>

<p>もうお分かりかと思いますが</p>

<pre><code>(lambda (req)
    (handle-response
        (call app (handle-request req)))
)
</code></pre>

<p>として、実装は<code>handle-response</code>に書きます。…が、tootは<code>response</code>オブジェクトではなく<code>request</code>オブジェクトに変更を加えたものを返すようなので</p>

<pre><code>(lambda (req)
    (handle-response
        req
        (call app (handle-request req)))
)
</code></pre>

<p>として、<code>app</code>の返値を元に<code>req</code>を書き換えます。こちらもあまりドキュメントが無いので頑張ってソース読むしかないです。因みに<code>body</code>はパスネームならそのファイルの内容を、文字列のリストならそれぞれを改行(<code>&lt;br&gt;</code>ではなく<code>\n</code>)で連結したものを返す必要があります。</p>

<p>tootハンドラの実装載せときますね。</p>

<pre><code>(defun handle-response (req res)
  (destructuring-bind (status headers body) res
    (etypecase body
      (pathname
       (multiple-value-call #'serve-file
     (values req body (parse-charset (getf headers :content-type)))))
      (list
       ;; XXX: almost same as Clack.Handler.Hunchentoot's one.
       (setf (status-code req) status)
       (loop for (k v) on headers by #'cddr
             with hash = (make-hash-table :test #'eq)
             if (gethash k hash)
               do (setf (gethash k hash)
                        (format nil "~:[~;~:*~A, ~]~A" (gethash k hash) v))
             else if (eq k :content-type)
               do (multiple-value-bind (v charset)
                      (parse-charset v)
                    (setf (gethash k hash) v)
                    (setf (toot::response-charset req) charset))
             else do (setf (gethash k hash) v)
             finally
          (loop for k being the hash-keys in hash
                using (hash-value v)
                do (setf (response-header k req) v)))
       (toot::send-response req (with-output-to-string (s)
      (format s "~{~A~^~%~}" body)))))))
</code></pre>

<p>です。</p>

<pre><code>(destructuring-bind (status headers body) res
  (etypecase body
    (pathname ...)
    (list ...)))
</code></pre>

<p>がテンプレートですね。<code>pathname</code>のときはtootに丸投げして<code>list</code>のときは<code>headers</code>とかを真面目に処理してます。</p>

<h3>4 エラーハンドリング</h3>

<p>早い話が500 internal server errorです。普通、Lispはエラーが起きるとデバッガに落ちますがサーバーは走り続ける必要がるのであらゆるエラーを無視する必要があります。が、しかしデバッグするとき(<code>run</code>のキーワード引数に<code>debug</code>がありましたね)はデバッガに落ちると嬉しいです。なので例のラムダを少し変更します。</p>

<pre><code>(lambda (req)
              (handle-response
               req
               (if debug (call app (handle-request req))
           (aif (handler-case (call app (handle-request req))
              (condition () nil))
            it
            '(500 nil nil)))))
</code></pre>

<p>これで完成です。</p>

<h2>テスト</h2>

<p>Clackにはテストが付いてます。テストケース自体は<code>clack/src/core/test/suite.lisp</code>に書かれてます。</p>

<p><code>clack/t/core/handler/hunchentoot.lisp</code>を参考に<code>clack/t/core/handler/toot.lisp</code>を作り、<code>clack/clack-test.asd</code>の<code>hunchentoot</code>を<code>toot</code>に書き換えたら準備完了です。<code>(ql:quickload :clack-test)</code>しましょう。テストが走ります。そして恐らくエラーが出て止まるでしょう。変な値を返すとサーバーじゃなくてテストの方がエラーで死ぬんですね。</p>

<p>そしたら<code>clack/src/core/test/suite.lisp</code>を開いて期待された値がなんだったかを調べてサーバーを修正します。で、また<code>(ql:quickload :clack-test)</code>の繰り返し。でも一回<code>quickload</code>しちゃうと読み直してくれないので私は一々<code>M-x slime-restart-inferior-lisp</code>してました。なんか違う気がする。これだけじゃなくてテスト全般。溢れるバッドノウハウ感。</p>

<p>とりあえずバックエンドにバグがあるとかのどうしようもない場合を除いてテストに全部合格すれば完成です</p>

<h2>完成したら</h2>

<p>どうしたらいいんでしょうね。分かんないです。clackにpull-req送るんでしょうか。あるいはquicklispに登録?私はとりあえず<a href="https://github.com/KeenS/clack">ブランチに置いてます</a>が恐らく誰も使ってないですし知らないと思います。</p>

<h2>で、何作ればいい？</h2>

<p><a href="https://github.com/fukamachi/clack/issues?state=open">clackのissue</a>にまだ作られてないものがリストされてます。「自分では需要はないけどなんか作ってみたい」といった奇特な方はそこから試すと良いんじゃないでしょうか。GAEとかmongrel2とか需要ありそうな気がします。</p>

<h2>まとめ</h2>

<p>誰得</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ここ１ヶ月くらいの近況]]></title>
    <link href="http://KeenS.github.io/blog/2013/11/13/what-recent/"/>
    <updated>2013-11-13T21:20:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/11/13/what-recent</id>
    <content type="html"><![CDATA[<p> #isucon 参戦記がフォロワーの多い@tagomorisさんとか@nitro_idiotさんとかにツイートされて普段の数十倍のアクセスが来てテンション上がったので近況書きますね。</p>

<!-- more -->


<h2>isuconの勉強</h2>

<p>件の記事でも書いてますけどMySQLとNginXとCapistranoの勉強しました。SQLって書けると案外楽しいですね。あとN+1問題を学んだり、<code>IF EXISTS TRRIGER</code>的な文がなくて殺そうかと思ったり。</p>

<p>NginXはキャッシュとかですね。キャッシュキーに<code>$cookie_isucon_session</code>とか入れてログインしてるユーザーが来ても対応できたので良かったです（小並感</p>

<p>Capistranoはどうせだからと3.0を使ったのですが調べても2.x時代の情報ばっかり引っ掛かって苦労しました。その代わり、isucon本戦では複数サーバーへのデプロイ機能を存分に使わせて頂きました。ほぼログインしなくても問題ないですね。</p>

<p>例えば</p>

<p>```ruby
set :application, &lsquo;my app&rsquo;
set :repo_url, &lsquo;git@bitbucket.org:me/myrepo.git&rsquo;
set :deploy_to, &lsquo;/home/me/app&rsquo;
set :scm, :git
set :deploy_via, :remote_cache</p>

<p>namespace :nginx do
  task :reload do</p>

<pre><code>on roles(:web) do
  execute :sudo, 'service nginx reload'
end
</code></pre>

<p>  end</p>

<p>  task :restart do</p>

<pre><code>on roles(:web) do
  execute :sudo, 'service nginx restart'
end
</code></pre>

<p>  end</p>

<p>  task :start do</p>

<pre><code>on roles(:web) do
  execute :sudo, 'service nginx start'
end
</code></pre>

<p>  end
end
```
こんな感じです。で、もう一つ</p>

<p>```ruby
set :stage, :production
server &lsquo;123.4.5.67&rsquo;, user: &lsquo;me&rsquo;, roles: &lsquo;web&rsquo;
server &lsquo;123.4.5.68&rsquo;, user: &lsquo;me&rsquo;, roles: &lsquo;web&rsquo;
server &lsquo;123.4.5.69&rsquo;, user: &lsquo;me&rsquo;, roles: &lsquo;web&rsquo;
set :ssh_options, {
  keys: %w(~/.ssh/id_rsa),
  forward_agent: true,
  auth_methods: %w(publickey)
}</p>

<p>```
を書いておけばこの3台のサーバーに一斉にデプロイしてくれます。(上の例だとnginxですが、まあいいでしょう。)</p>

<h2>Shibuya.lisp</h2>

<p>Lisp Meet Up #10で発表してきました。内容は<code>fluentd</code>をCommon Lispから使う話。<br/>
スライド</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/27444839" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/blackenedgold/common-lisp-27444839" title="Common Lisp でビッグデータを作ろう" target="_blank">Common Lisp でビッグデータを作ろう</a> </strong> from <strong><a href="http://www.slideshare.net/blackenedgold" target="_blank">blackenedgold</a></strong> </div></p>

<p>Ustreamは見つかりませんでした。てへペロ</p>

<p>恐らく、<code>Log4CL</code>はやりたいことと目的が違いますね。全く別のロギングフレームワークを作るのが良さげな気がします。isuconの懇親会で開発者の@tagomorisさんにアドバイスも頂きましたし作るかもしれません。</p>

<h2>mpd</h2>

<p><a href="/blog/2013/09/29/mplayer/">以前、mplayer2が正常に動作しないとかぼやいて</a>ましたが、結局あきらめました。で、代わりに<a href="http://www.musicpd.org/">Music Player Daemon(MPD)</a>なるものを見付けて、しかもRaspberry Piで動き、iPod/Androidから操作できるとのことで、導入しました。</p>

<p>MPDはまさしくRaspberry Piのような機器向で、音楽を鳴らすサーバーと操作するクライアントが完全に分かれてます。</p>

<pre><code>$ sudo apg-get install mpd mpc
</code></pre>

<p>とかでRSPiに入れた気がします。クライアントはAndroidは<code>MPDroid</code>、iPodは<code>MPoD</code>っていうアプリです。</p>

<p><code>scp</code>で手元の曲をRSPiコピーし、iPodから繋ぐも曲が見えない。色々試した結果、<code>scp</code>でコピーしたときにパーミッションの問題が出てたようなのでそこを解決したらちゃんと動きました。</p>

<p>動画(iPod)</p>

<iframe width="560" height="315" src="http://KeenS.github.io//www.youtube.com/embed/x5CWtXbCkqo" frameborder="0" allowfullscreen></iframe>


<p>黒ばっかで見づらくて申し訳ありません。iPodからではなくスピーカから音が出てるのが分かりますかね？思ったより音が入ってないので分りづらいですね（汗</p>

<h2>CIM</h2>

<p><a href="https://github.com/fukamachi/shelly/">Shelly</a>を使って<a href="https://gist.github.com/KeenS/7059301">Common Lispスクリプトをexecutableにしよう</a>ってのをやってましたが少しshellyが求めているのと違うようだったので「シェルスクリプトでshelly的な物を実装しよう！ついでにrvmみたいにバージョン管理できたら嬉しいな！！」って思い付きで<a href="https://github.com/KeenS/CIM">Common Lisp Implementation Manager(CIM)</a>を作り始めました。まだCLISP, ECL, GCLのインストールぐらいしかできてません。</p>

<p>初めてシェルスクリプトを書き、初めてBourne Shellを触り(普段はzsh)、早くも挫折しそうです。今めっちゃシェルスクリプトの勉強してます。目的はImplementationの管理じゃなくて統一インターフェースの<code>cl</code>コマンドなのにそこが全然進んでないですね。<code>ql</code>に至っては1行も書いてない。まあ、<code>cl</code>を使って書くつもりなので<code>cl</code>が出来ないことにはどうしようもないんですが。</p>

<p><code>syset</code>とかネーミングセンスが無かったり(発音しずらい。シセット…サイセットって読もうかな)ダウンロードしたアーカイブのチェックサムとか全く見てなかったり色々ツッコみたくなりますが温かい目で見て下さい。気に入ったらpull-reqとかして下さい。</p>

<h2>Octomacs</h2>

<p>Octomacsに一回pull-req送ってからコミッタ気取りのκeenですが、<code>octomacs-preview</code>と<code>octomacs-deploy</code>を実装しました。<code>C-u</code>をつけると<code>generate</code>が付いてきます。テストをしてない（できない？）+サーバーを殺す(<code>octomacs-preview-quit</code>とかの名前かなあ。現状は<code>*octomacs preview*</code>バッファを<code>kill-buffer</code>すればいい)コマンドを実装してないのでpull-reqは投げてませんが使ってみたい方は<a href="https://github.com/KeenS/octomacs">こちら</a>をどうぞ。まあ、今からpushするんですがね。ちゃんとこの記事も<code>octomacs-new-post</code>から始まり、<code>octomacs-preview</code>で確認しつつ<code>octomacs-deploy</code>でデプロイしました。あとは過去の記事を編集する<code>octomacs-edit</code>を実装すれば完璧ですね。</p>

<p>こんなかんじです。<code>CIM</code>がんばります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shellyを使ってCommon LispファイルをExecutableにする]]></title>
    <link href="http://KeenS.github.io/blog/2013/09/26/shelly-script/"/>
    <updated>2013-09-26T21:25:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/09/26/shelly-script</id>
    <content type="html"><![CDATA[<p>コマンドラインからCommon Lispの関数を実行できる<a href="https://github.com/fukamachi/shelly">Shelly</a>を使ってCommon Lispファイルを実行形式にしてみました。
Shellyは</p>

<pre><code>$ shly + 1 2
3
</code></pre>

<p>みたいに関数を実行できます。</p>

<!-- more -->


<p>モチベーションとしては、<a href="http://blog.8arrow.org/entry/20120521/1337596483">Shellyの作者深町さん</a>がTwitterで「Shellyでloadを使うとスクリプトみたいに実行できる」と発言していたのがきっかけで、Shebangを無視できればUNIX系ではExecutableにできるのでは？と思いついてやってみました。</p>

<p><code>read</code>して<code>eval</code>して…とか考えてましたが、<code>load</code>に<code>stream</code>を渡せるようなので案外簡単にできました。</p>

<p><div><script src='https://gist.github.com/KeenS/6688683.js?file=script.lisp'></script>
<noscript><pre><code>(in-package :shelly)
(export (defvar *argv* nil))
(in-package :cl-user)

(defun script (file argv)
  &quot;Execute a file as script ignoring shebang&quot;
  (setf shelly:*argv* argv)
  (let* ((in (open file :if-does-not-exist :error))
	 (first-char (read-char in))
	 (second-char (read-char in)))
    (cond
      ((and (char= first-char #\#) (char= second-char #\!))
       (read-line in))
      (t (unread-char second-char in)
	 (unread-char first-char in)))
    (load in)
    (values)))
</code></pre></noscript></div>
</p>

<p>コマンドライン引数を受け取るために<code>*argv*</code>という変数を用意してます。</p>

<p>こんなことを<code>~/.shelly/Shellyfile</code>に書いておき、Lispの初期化ファイルに</p>

<pre><code>#+shelly
(load "~/.shelly/Shellyfile")
</code></pre>

<p>と書いてます。この<code>~/.shelly/Shellyfile</code>にはShelly向けの関数を溜め込んでいく予定です。</p>

<p>あとは</p>

<p>```common-lisp</p>

<h1>!shly script</h1>

<p>(defun hello ()
  (format t &ldquo;Hello ~a~%&rdquo; (first shelly:<em>argv</em>)))
(hello)
<code>``
を</code>foo.lisp`に書き込めば</p>

<pre><code>$ chmod u+x foo.lisp
$./foo.lisp κeen
Hello κeen
</code></pre>

<p>と実行できます。勿論、</p>

<pre><code>$shly script foo.lisp κeen
</code></pre>

<p>としても同じです。
一部の処理系ではこのようなことが出来ますが、コマンドライン引数の渡し方とかも処理系依存なのでポータブルに書くなら一つ試してみてはいかがでしょうか。</p>
]]></content>
  </entry>
  
</feed>
