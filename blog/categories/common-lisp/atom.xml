<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Common Lisp | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/blog/categories/common-lisp/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-01-21T02:42:27+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ClackのHandlerの書き方]]></title>
    <link href="http://KeenS.github.io/blog/2013/12/06/lisp-advent-calendar-7/"/>
    <updated>2013-12-06T00:06:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/12/06/lisp-advent-calendar-7</id>
    <content type="html"><![CDATA[<p>(この記事は<a href="http://qiita.com/advent-calendar/2013/lisp">Lisp Advent Calendar</a> 7日目のためのエントリです。<br/>
  (<a href="http://meymao.hatenablog.com/entry/2013/12/06/140029">6日目</a> meymaoさんより「Lisperがクリスマスに贈るべきプレゼント三選」)<br/>
  (<a href="http://www.principia-m.com/ts/0081/index-jp.html">8日目</a> athos0220さんよりマクロとクロージャで作る並行プログラミング言語))</p>

<p>ClackのHandlerの書き方についてちゃちゃっと解説します。</p>

<!-- more -->


<p>さっくりゆるふわな感じで行くので<a href="http://clacklisp.org/">clack公式</a>だとか<a href="http://clacklisp.org/tutorial/ja/">チュートリアル</a>だとかも参考にして下さい。とは言ってもCommon Lispな方なら知ってるでしょう。</p>

<h2>Clackって？</h2>

<p>PerlのPlackやRubyのRackと同じくCommon Lispの統一HTTPサーバーインターフェースです。開発時はHunchentootで、本番はFastCGIでみたいなことが簡単にできます。</p>

<h2>Handlerって？</h2>

<p>HunchentootやFastCGIといったバックエンドとClackとの間でリクエストやレスポンスの受け渡しを担当します。さっくり言うとHandlerを書けばClackで使えるサーバーが増える訳です。今(2013-12現在)のところ、Hunchentoot、FastCGI、Apache + mod_lisp2があるようです。</p>

<p>じゃあ、実際に軽量サーバーの<a href="https://github.com/gigamonkey/toot">toot</a>のハンドラを書きながら解説しますね</p>

<h2>準備</h2>

<p><code>git clone git@github.com:fukamachi/clack.git</code>してclackのソースコードを持ってきます。他のHanderがそうしてるようなので</p>

<ul>
<li> <code>clack/clack-handler-toot.asd</code></li>
<li> <code>clack/src/core/handler/toot.lisp</code></li>
</ul>


<p>   を作ります。<code>core</code>じゃなくて<code>contrib</code>だろとかそもそも自分のリポジトリに作れよとかは自由にやって下さい。<code>clack/clack-handler-toot.asd</code>は適当に似た名前のやつをコピーすれば良いんじゃないですかね？（適当</p>

<h2>書き方</h2>

<p>いたって簡単で、<code>run (app &amp;key debug (port 5000)) -&gt; acceptor</code>と<code>stop (acceptor) -&gt; 多分決まってない</code>を実装すれば良いです。</p>

<p>とはいっても<code>stop</code>は1行で終わりますが<code>run</code>は大きく分けて</p>

<ol>
<li>. サーバーを立ち上げる</li>
<li>. サーバーから渡されたリクエスト(多くの場合<code>request</code>オブジェクト)をplistにして<code>app</code>に渡す</li>
<li>. <code>app</code>のlist形式の返値を適切な形(多くの場合<code>response</code>オブジェクト)にしてサーバーに返す</li>
<li>. エラーハンドリング</li>
</ol>


<p>の4つの作業があります。一つ一つ説明していきますね。</p>

<h3>1 サーバーを立ち上げる</h3>

<p>tootの場合は<code>toot:start-server (&amp;key handler port)</code>を使いました。スレッド立てるのはclackがやってくれます。はい。</p>

<h3>2 サーバー渡されたリクエスト(多くの場合<code>request</code>オブジェクト)をplistにして<code>app</code>に渡す</h3>

<p>tootの場合、<code>key</code>の<code>handler</code>が<code>requesut</code>オブジェクトを受け取って<code>response</code>オブジェクトを返せば良いので</p>

<pre><code>(lambda (req)
    .....
    (call app (handle-request req))
    .....
)
</code></pre>

<p>って感じで<code>handle-request</code>に実装を書きます。</p>

<p><code>handle-request</code>の内部は<code>req</code>を<a href="http://clacklisp.org/tutorial/ja/04-the-environment.html">clack公式のチュートリアル</a>に載っているプロパティに一つ一つ変換していきます。このプロパティとバックエンドのオブジェクトのスロット名と実際のHTTPヘッダの名前が必ずしも一致しないのが泣き所です。さらに、大抵のサーバーの場合リクエストオブジェクトのスロットの詳細まではドキュメントに載ってないのでソースを参照しながら書くことになります。また、そもそも対応する値が無くて、他の情報を切り貼りして作らないといけなかったり、どうしようもなくて空にしないといけないこともあります。</p>

<p>tootハンドラは</p>

<pre><code>(defun handle-request (req)
  "Convert Request from server into a plist
before pass to Clack application."
  (let ((content-length (and (request-header :content-length req)
                             (parse-integer (request-header :content-length req) :junk-allowed t)))
    (port-and-host (get-port-and-host req)))
    (append
     (list
      :request-method (request-method req)
      :script-name ""
      :path-info (url-decode (request-path req))
      :server-name (car port-and-host)
      :server-port (cdr port-and-host)
      :server-protocol (server-protocol req)
      :request-uri (request-uri req)
      :url-scheme :HTTP;(request-scheme req)
      :remote-addr (remote-addr req)
      :remote-port (remote-port req)
      :query-string (request-query req)
      :content-length content-length
      :content-type (request-header :content-type req)
      :raw-body (let ((stream (toot::request-body-stream req)))
                  ;(when content-length
                    ;(setf (flex:flexi-stream-bound stream) content-length))
                  stream)
      :clack.uploads nil
      :clack.handler :toot)

     (loop for (k . v) in (toot::request-headers req)
           unless (find k '(:request-method :script-name :path-info :server-name :server-port :server-protocol :request-uri :remote-addr :remote-port :query-string :content-length :content-type :accept :connection))
             append (list (intern (format nil "HTTP-~:@(~A~)" k) :keyword)
                          v)))))
</code></pre>

<p>こんな感じに実装されてます。tootからインポートしたものの他、一部ヘルパー関数も使ってますが挙動はまあ、名前から察して下さい。</p>

<h3>3 <code>app</code>の返値のplistを適切な形(多くの場合<code>response</code>オブジェクト)にしてサーバーに返す</h3>

<p><code>app</code>を<code>call</code>してやると<code>(status headers body)</code>という形式のlistが返ってきます。<code>status</code>は数値、<code>headers</code>はplist、<code>body</code>はパスネーム又は文字列のリストです。</p>

<p>さっきはこんな感じで呼んだのでした。</p>

<pre><code>(lambda (req)
    .....
    (call app (handle-request req))
    .....
)
</code></pre>

<p>もうお分かりかと思いますが</p>

<pre><code>(lambda (req)
    (handle-response
        (call app (handle-request req)))
)
</code></pre>

<p>として、実装は<code>handle-response</code>に書きます。…が、tootは<code>response</code>オブジェクトではなく<code>request</code>オブジェクトに変更を加えたものを返すようなので</p>

<pre><code>(lambda (req)
    (handle-response
        req
        (call app (handle-request req)))
)
</code></pre>

<p>として、<code>app</code>の返値を元に<code>req</code>を書き換えます。こちらもあまりドキュメントが無いので頑張ってソース読むしかないです。因みに<code>body</code>はパスネームならそのファイルの内容を、文字列のリストならそれぞれを改行(<code>&lt;br&gt;</code>ではなく<code>\n</code>)で連結したものを返す必要があります。</p>

<p>tootハンドラの実装載せときますね。</p>

<pre><code>(defun handle-response (req res)
  (destructuring-bind (status headers body) res
    (etypecase body
      (pathname
       (multiple-value-call #'serve-file
     (values req body (parse-charset (getf headers :content-type)))))
      (list
       ;; XXX: almost same as Clack.Handler.Hunchentoot's one.
       (setf (status-code req) status)
       (loop for (k v) on headers by #'cddr
             with hash = (make-hash-table :test #'eq)
             if (gethash k hash)
               do (setf (gethash k hash)
                        (format nil "~:[~;~:*~A, ~]~A" (gethash k hash) v))
             else if (eq k :content-type)
               do (multiple-value-bind (v charset)
                      (parse-charset v)
                    (setf (gethash k hash) v)
                    (setf (toot::response-charset req) charset))
             else do (setf (gethash k hash) v)
             finally
          (loop for k being the hash-keys in hash
                using (hash-value v)
                do (setf (response-header k req) v)))
       (toot::send-response req (with-output-to-string (s)
      (format s "~{~A~^~%~}" body)))))))
</code></pre>

<p>です。</p>

<pre><code>(destructuring-bind (status headers body) res
  (etypecase body
    (pathname ...)
    (list ...)))
</code></pre>

<p>がテンプレートですね。<code>pathname</code>のときはtootに丸投げして<code>list</code>のときは<code>headers</code>とかを真面目に処理してます。</p>

<h3>4 エラーハンドリング</h3>

<p>早い話が500 internal server errorです。普通、Lispはエラーが起きるとデバッガに落ちますがサーバーは走り続ける必要がるのであらゆるエラーを無視する必要があります。が、しかしデバッグするとき(<code>run</code>のキーワード引数に<code>debug</code>がありましたね)はデバッガに落ちると嬉しいです。なので例のラムダを少し変更します。</p>

<pre><code>(lambda (req)
              (handle-response
               req
               (if debug (call app (handle-request req))
           (aif (handler-case (call app (handle-request req))
              (condition () nil))
            it
            '(500 nil nil)))))
</code></pre>

<p>これで完成です。</p>

<h2>テスト</h2>

<p>Clackにはテストが付いてます。テストケース自体は<code>clack/src/core/test/suite.lisp</code>に書かれてます。</p>

<p><code>clack/t/core/handler/hunchentoot.lisp</code>を参考に<code>clack/t/core/handler/toot.lisp</code>を作り、<code>clack/clack-test.asd</code>の<code>hunchentoot</code>を<code>toot</code>に書き換えたら準備完了です。<code>(ql:quickload :clack-test)</code>しましょう。テストが走ります。そして恐らくエラーが出て止まるでしょう。変な値を返すとサーバーじゃなくてテストの方がエラーで死ぬんですね。</p>

<p>そしたら<code>clack/src/core/test/suite.lisp</code>を開いて期待された値がなんだったかを調べてサーバーを修正します。で、また<code>(ql:quickload :clack-test)</code>の繰り返し。でも一回<code>quickload</code>しちゃうと読み直してくれないので私は一々<code>M-x slime-restart-inferior-lisp</code>してました。なんか違う気がする。これだけじゃなくてテスト全般。溢れるバッドノウハウ感。</p>

<p>とりあえずバックエンドにバグがあるとかのどうしようもない場合を除いてテストに全部合格すれば完成です</p>

<h2>完成したら</h2>

<p>どうしたらいいんでしょうね。分かんないです。clackにpull-req送るんでしょうか。あるいはquicklispに登録?私はとりあえず<a href="https://github.com/KeenS/clack">ブランチに置いてます</a>が恐らく誰も使ってないですし知らないと思います。</p>

<h2>で、何作ればいい？</h2>

<p><a href="https://github.com/fukamachi/clack/issues?state=open">clackのissue</a>にまだ作られてないものがリストされてます。「自分では需要はないけどなんか作ってみたい」といった奇特な方はそこから試すと良いんじゃないでしょうか。GAEとかmongrel2とか需要ありそうな気がします。</p>

<h2>まとめ</h2>

<p>誰得</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ここ１ヶ月くらいの近況]]></title>
    <link href="http://KeenS.github.io/blog/2013/11/13/what-recent/"/>
    <updated>2013-11-13T21:20:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/11/13/what-recent</id>
    <content type="html"><![CDATA[<p> #isucon 参戦記がフォロワーの多い@tagomorisさんとか@nitro_idiotさんとかにツイートされて普段の数十倍のアクセスが来てテンション上がったので近況書きますね。</p>

<!-- more -->


<h2>isuconの勉強</h2>

<p>件の記事でも書いてますけどMySQLとNginXとCapistranoの勉強しました。SQLって書けると案外楽しいですね。あとN+1問題を学んだり、<code>IF EXISTS TRRIGER</code>的な文がなくて殺そうかと思ったり。</p>

<p>NginXはキャッシュとかですね。キャッシュキーに<code>$cookie_isucon_session</code>とか入れてログインしてるユーザーが来ても対応できたので良かったです（小並感</p>

<p>Capistranoはどうせだからと3.0を使ったのですが調べても2.x時代の情報ばっかり引っ掛かって苦労しました。その代わり、isucon本戦では複数サーバーへのデプロイ機能を存分に使わせて頂きました。ほぼログインしなくても問題ないですね。</p>

<p>例えば</p>

<p>```ruby
set :application, &lsquo;my app&rsquo;
set :repo_url, &lsquo;git@bitbucket.org:me/myrepo.git&rsquo;
set :deploy_to, &lsquo;/home/me/app&rsquo;
set :scm, :git
set :deploy_via, :remote_cache</p>

<p>namespace :nginx do
  task :reload do</p>

<pre><code>on roles(:web) do
  execute :sudo, 'service nginx reload'
end
</code></pre>

<p>  end</p>

<p>  task :restart do</p>

<pre><code>on roles(:web) do
  execute :sudo, 'service nginx restart'
end
</code></pre>

<p>  end</p>

<p>  task :start do</p>

<pre><code>on roles(:web) do
  execute :sudo, 'service nginx start'
end
</code></pre>

<p>  end
end
```
こんな感じです。で、もう一つ</p>

<p>```ruby
set :stage, :production
server &lsquo;123.4.5.67&rsquo;, user: &lsquo;me&rsquo;, roles: &lsquo;web&rsquo;
server &lsquo;123.4.5.68&rsquo;, user: &lsquo;me&rsquo;, roles: &lsquo;web&rsquo;
server &lsquo;123.4.5.69&rsquo;, user: &lsquo;me&rsquo;, roles: &lsquo;web&rsquo;
set :ssh_options, {
  keys: %w(~/.ssh/id_rsa),
  forward_agent: true,
  auth_methods: %w(publickey)
}</p>

<p>```
を書いておけばこの3台のサーバーに一斉にデプロイしてくれます。(上の例だとnginxですが、まあいいでしょう。)</p>

<h2>Shibuya.lisp</h2>

<p>Lisp Meet Up #10で発表してきました。内容は<code>fluentd</code>をCommon Lispから使う話。<br/>
スライド</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/27444839" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/blackenedgold/common-lisp-27444839" title="Common Lisp でビッグデータを作ろう" target="_blank">Common Lisp でビッグデータを作ろう</a> </strong> from <strong><a href="http://www.slideshare.net/blackenedgold" target="_blank">blackenedgold</a></strong> </div></p>

<p>Ustreamは見つかりませんでした。てへペロ</p>

<p>恐らく、<code>Log4CL</code>はやりたいことと目的が違いますね。全く別のロギングフレームワークを作るのが良さげな気がします。isuconの懇親会で開発者の@tagomorisさんにアドバイスも頂きましたし作るかもしれません。</p>

<h2>mpd</h2>

<p><a href="/blog/2013/09/29/mplayer/">以前、mplayer2が正常に動作しないとかぼやいて</a>ましたが、結局あきらめました。で、代わりに<a href="http://www.musicpd.org/">Music Player Daemon(MPD)</a>なるものを見付けて、しかもRaspberry Piで動き、iPod/Androidから操作できるとのことで、導入しました。</p>

<p>MPDはまさしくRaspberry Piのような機器向で、音楽を鳴らすサーバーと操作するクライアントが完全に分かれてます。</p>

<pre><code>$ sudo apg-get install mpd mpc
</code></pre>

<p>とかでRSPiに入れた気がします。クライアントはAndroidは<code>MPDroid</code>、iPodは<code>MPoD</code>っていうアプリです。</p>

<p><code>scp</code>で手元の曲をRSPiコピーし、iPodから繋ぐも曲が見えない。色々試した結果、<code>scp</code>でコピーしたときにパーミッションの問題が出てたようなのでそこを解決したらちゃんと動きました。</p>

<p>動画(iPod)</p>

<iframe width="560" height="315" src="http://KeenS.github.io//www.youtube.com/embed/x5CWtXbCkqo" frameborder="0" allowfullscreen></iframe>


<p>黒ばっかで見づらくて申し訳ありません。iPodからではなくスピーカから音が出てるのが分かりますかね？思ったより音が入ってないので分りづらいですね（汗</p>

<h2>CIM</h2>

<p><a href="https://github.com/fukamachi/shelly/">Shelly</a>を使って<a href="https://gist.github.com/KeenS/7059301">Common Lispスクリプトをexecutableにしよう</a>ってのをやってましたが少しshellyが求めているのと違うようだったので「シェルスクリプトでshelly的な物を実装しよう！ついでにrvmみたいにバージョン管理できたら嬉しいな！！」って思い付きで<a href="https://github.com/KeenS/CIM">Common Lisp Implementation Manager(CIM)</a>を作り始めました。まだCLISP, ECL, GCLのインストールぐらいしかできてません。</p>

<p>初めてシェルスクリプトを書き、初めてBourne Shellを触り(普段はzsh)、早くも挫折しそうです。今めっちゃシェルスクリプトの勉強してます。目的はImplementationの管理じゃなくて統一インターフェースの<code>cl</code>コマンドなのにそこが全然進んでないですね。<code>ql</code>に至っては1行も書いてない。まあ、<code>cl</code>を使って書くつもりなので<code>cl</code>が出来ないことにはどうしようもないんですが。</p>

<p><code>syset</code>とかネーミングセンスが無かったり(発音しずらい。シセット…サイセットって読もうかな)ダウンロードしたアーカイブのチェックサムとか全く見てなかったり色々ツッコみたくなりますが温かい目で見て下さい。気に入ったらpull-reqとかして下さい。</p>

<h2>Octomacs</h2>

<p>Octomacsに一回pull-req送ってからコミッタ気取りのκeenですが、<code>octomacs-preview</code>と<code>octomacs-deploy</code>を実装しました。<code>C-u</code>をつけると<code>generate</code>が付いてきます。テストをしてない（できない？）+サーバーを殺す(<code>octomacs-preview-quit</code>とかの名前かなあ。現状は<code>*octomacs preview*</code>バッファを<code>kill-buffer</code>すればいい)コマンドを実装してないのでpull-reqは投げてませんが使ってみたい方は<a href="https://github.com/KeenS/octomacs">こちら</a>をどうぞ。まあ、今からpushするんですがね。ちゃんとこの記事も<code>octomacs-new-post</code>から始まり、<code>octomacs-preview</code>で確認しつつ<code>octomacs-deploy</code>でデプロイしました。あとは過去の記事を編集する<code>octomacs-edit</code>を実装すれば完璧ですね。</p>

<p>こんなかんじです。<code>CIM</code>がんばります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shellyを使ってCommon LispファイルをExecutableにする]]></title>
    <link href="http://KeenS.github.io/blog/2013/09/26/shelly-script/"/>
    <updated>2013-09-26T21:25:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/09/26/shelly-script</id>
    <content type="html"><![CDATA[<p>コマンドラインからCommon Lispの関数を実行できる<a href="https://github.com/fukamachi/shelly">Shelly</a>を使ってCommon Lispファイルを実行形式にしてみました。
Shellyは</p>

<pre><code>$ shly + 1 2
3
</code></pre>

<p>みたいに関数を実行できます。</p>

<!-- more -->


<p>モチベーションとしては、<a href="http://blog.8arrow.org/entry/20120521/1337596483">Shellyの作者深町さん</a>がTwitterで「Shellyでloadを使うとスクリプトみたいに実行できる」と発言していたのがきっかけで、Shebangを無視できればUNIX系ではExecutableにできるのでは？と思いついてやってみました。</p>

<p><code>read</code>して<code>eval</code>して…とか考えてましたが、<code>load</code>に<code>stream</code>を渡せるようなので案外簡単にできました。</p>

<p><div><script src='https://gist.github.com/KeenS/6688683.js?file=script.lisp'></script>
<noscript><pre><code>(in-package :shelly)
(export (defvar *argv* nil))
(in-package :cl-user)

(defun script (file argv)
  &quot;Execute a file as script ignoring shebang&quot;
  (setf shelly:*argv* argv)
  (let* ((in (open file :if-does-not-exist :error))
	 (first-char (read-char in))
	 (second-char (read-char in)))
    (cond
      ((and (char= first-char #\#) (char= second-char #\!))
       (read-line in))
      (t (unread-char second-char in)
	 (unread-char first-char in)))
    (load in)
    (values)))
</code></pre></noscript></div>
</p>

<p>コマンドライン引数を受け取るために<code>*argv*</code>という変数を用意してます。</p>

<p>こんなことを<code>~/.shelly/Shellyfile</code>に書いておき、Lispの初期化ファイルに</p>

<pre><code>#+shelly
(load "~/.shelly/Shellyfile")
</code></pre>

<p>と書いてます。この<code>~/.shelly/Shellyfile</code>にはShelly向けの関数を溜め込んでいく予定です。</p>

<p>あとは</p>

<p>```common-lisp</p>

<h1>!shly script</h1>

<p>(defun hello ()
  (format t &ldquo;Hello ~a~%&rdquo; (first shelly:<em>argv</em>)))
(hello)
<code>``
を</code>foo.lisp`に書き込めば</p>

<pre><code>$ chmod u+x foo.lisp
$./foo.lisp κeen
Hello κeen
</code></pre>

<p>と実行できます。勿論、</p>

<pre><code>$shly script foo.lisp κeen
</code></pre>

<p>としても同じです。
一部の処理系ではこのようなことが出来ますが、コマンドライン引数の渡し方とかも処理系依存なのでポータブルに書くなら一つ試してみてはいかがでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Common Lispスタイルガイド]]></title>
    <link href="http://KeenS.github.io/blog/2013/09/21/google-commonlisp-style-guide/"/>
    <updated>2013-09-21T17:00:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2013/09/21/google-commonlisp-style-guide</id>
    <content type="html"><![CDATA[<p>この度、<a href="http://google-styleguide.googlecode.com/svn/trunk/lispguide.xml">Google Common Lispスタイルガイド</a>が<a href="http://google-common-lisp-style-guide-ja.cddddr.org/">日本語に</a>なりました。</p>

<!-- more -->


<p>私が見付けた時点でほとんど日本語になってたのですが、ちょいちょい訳し残しがあったのでお手伝いをして、とりあえず英文は消えました。</p>

<p>ただまあこれで完成かというとそうでもなく、第一段階で「とりあえず」日本語になっただけ。第二段階がまだ残ってます。直訳も多々ありますし記法が統一できてなかったりします。</p>

<p>ですがこれで英語が苦手な方でも読めるかと思いますので読んでみて、変なところがあったらじゃんじゃんPull-Req送って下さい。マスターリポジトリは@massoさんの<a href="https://github.com/g000001/google-common-lisp-style-guide-ja">https://github.com/g000001/google-common-lisp-style-guide-ja</a>です。コメントに元の英文とか訳者のコメントとか残ってるので日本語が訳わかめな状態だったらそっちの方が分り易いかもしれません。</p>

<p>みなさん第二段階のご協力お願いします。</p>
]]></content>
  </entry>
  
</feed>
