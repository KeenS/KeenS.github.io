<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="マクロクラブ Rust支部 | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="マクロ・クラブのルール


マクロを書くな
それがパターンをカプセル化する唯一の方法ならば、マクロを書け
例外: 同等の関数に比べて、 呼び出し側が楽になるならば、マクロを書いても構わない
" />

        <title>マクロクラブ Rust支部 | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css' />
        <link rel="stylesheet" href="//KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="//KeenS.github.io/css/liquorice.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="//KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="//KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="//KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
        <link rel="apple-touch-icon-precomposed" href="//KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="alternate" href="" type="application/rss+xml" title="κeenのHappy Hacκing Blog" />
        
        <script>
         (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
             (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

         ga('create', 'UA-43779888-1', 'auto');
         ga('send', 'pageview');

        </script>
        
        <link rel="stylesheet" href="//KeenS.github.io/highlight.js/styles/monokai.css" />
<script src="//KeenS.github.io/highlight.js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<link rel="stylesheet" href="//unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css">

    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="//KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="//KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="//KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                    <header class="li-article-header">
                        <h1 class="li-article-title">マクロクラブ Rust支部</h1>
                        <div class="li-article-meta">
    <time class="li-article-date">2018-02-17</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="//KeenS.github.io/categories/rust">Rust</a>
        </li>
    
        <li>
            <a href="//KeenS.github.io/categories/%e3%83%9e%e3%82%af%e3%83%ad">マクロ</a>
        </li>
    
</ul>

</div>

                    </header>
                    <section>
                        <p>マクロ・クラブのルール</p>

<ol>
<li>マクロを書くな</li>
<li>それがパターンをカプセル化する唯一の方法ならば、マクロを書け</li>
<li>例外: 同等の関数に比べて、 呼び出し側が楽になるならば、マクロを書いても構わない</li>
</ol>

<p>
κeenです。レーシックを受けようとしたら角膜が薄くて手術拒否されました。予定が狂って時間が空いたのでブログを書きます。</p>

<p>冒頭のルールは<a href="https://www.ohmsha.co.jp/book/9784274069130/">プログラミングClojure</a>に出てくるマクロの書き方の指南です。
Rustのマクロって色々できるんだよという記事を書くにあたってマクロに一日の長があるLispの知見を引用されていただきました。
ルールにあるとおり、マクロは関数と違ってRustの第一級オブジェクトでないので扱いづらいですし本体がコピーされるのでコードサイズも膨らんでしまいます。
よく考えながら使いましょう。とはいってもRustの構文はLispに比べると複雑ですし型やパターンマッチなどLispに存在しない構文要素もあるのでLispより使いどころは多くありそうです。</p>

<h1 id="マクロって何">マクロって何？</h1>

<p>簡潔に言うとRustのプログラムをプログラミングする仕組みです。
関数がデータを受け取ってデータを返すのに対してマクロはRustの構文の一部(構文木)を受け取ってRustの構文の一部を返します。</p>

<p>マクロはRustコンパイラがコンパイル中に実行するので関数とは全然違うタイミングで動きます。
初めのうちはマクロも意識せずに使えますがまれにマクロについて理解してないと使えないケースもあります。
必要になったらマクロを意識しはじめましょう。</p>

<p>マクロのドキュメントは<a href="https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/macros.html">TRPL</a>や<a href="https://doc.rust-lang.org/book/second-edition/appendix-04-macros.html">TRPL 2nd</a>、<a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html">リファレンスマニュアル</a>、非公式ですが<a href="http://danielkeep.github.io/tlborm/book/">The Little Book of Macros</a>などがあるので詳しく見たい方はそちらを当たるといいかもしれません。ここではあまり難しいことは言わずにマクロを使っていきます。ポジションとしてはTRPLのマクロの章を実際のユースケースに合わせて補完できたらなというところです。</p>

<p>また、Rustにはここで扱う宣言的マクロの他に手続き的マクロもあります。
手続きによってRustの構文を作るので生成されるコードがわかりづらく難しい反面、自由度は高いので宣言的マクロで出来ないことも手続き的マクロでは可能になります。
proc_macroはここでは扱わないので気になる方は適当に調べてみて下さい。</p>

<h1 id="マクロでできること">マクロでできること</h1>

<p>大抵のことはできます。</p>

<h2 id="値">値</h2>

<p>要は関数のようにも扱えるわけですね</p>

<pre><code class="language-rust">macro_rules! add {
    ($e1: expr, $e2: expr) =&gt; {
        $e1 + $e2
    };
}

fn main() {
    let ret = add!(1, 2);
    println!(&quot;{}&quot;, ret); // -&gt; 3
}
</code></pre>

<h2 id="関数呼び出し">関数呼び出し</h2>

<p>関数名を受け取ってそれを呼び出したりもできます。</p>

<pre><code class="language-rust">fn print2(i: i32, j: i32) {
    println!(&quot;{}, {}&quot;, i, j);
}

macro_rules! call_by_double {
    ($name: ident, $e: expr) =&gt; {
      $name($e, $e)
    }
}

fn main() {
    call_by_double!(print2, 1); // -&gt; 1, 1
}
</code></pre>

<h2 id="変数束縛">変数束縛</h2>

<p>新たな束縛を導入したりもできます。
詳しくは触れませんがRustのマクロは衛生的なのでユーザが指定した以外の変数を導入することはできません。</p>

<pre><code class="language-rust">macro_rules! bind {
    ($var: ident, $val: expr) =&gt; (let $var = $val;)
}

fn main() {
    bind!(x, 1 + 2);
    println!(&quot;{}&quot;, x); // -&gt; 3
}
</code></pre>

<h2 id="パターン">パターン</h2>

<p>パターンも書けます。今試したら<code>|</code>パターンは書けないようでした。残念ですね。</p>

<pre><code class="language-rust">macro_rules! exact_one {
    () =&gt; (Some(1))
}

macro_rules! two {
    ($x: ident) =&gt; (Some($x @ 2))
}

macro_rules! three {
    ($x: ident) =&gt; (Some($x @ 3))
}

macro_rules! many_or_none {
    () =&gt; (_)
}

fn main() {
    match Some(2) {
        exact_one!() =&gt; println!(&quot;exact one&quot;),
        two!(x) | three!(x) =&gt; println!(&quot;{}&quot;, x),
        many_or_none!() =&gt; (),
    }
}
</code></pre>

<h2 id="型">型</h2>

<p>型の位置にもマクロが使えます。残念ながらトレイト制約の一には書けませんでした</p>

<pre><code class="language-rust">macro_rules! result {
    () =&gt; {
        Result&lt;i32, ()&gt;
    }
}

fn function() -&gt; result!() {
    Ok(0)
}
</code></pre>

<h2 id="アイテムの定義">アイテムの定義</h2>

<p><code>struct</code>や<code>impl</code>や<code>trait</code>などの定義もできます。</p>

<pre><code class="language-rust">macro_rules! define_id_type {
    ($name: ident) =&gt; {
        pub struct $name(pub u64);
        impl $name {
            pub fn new(id: u64) -&gt; Self {
                $name(id)
            }
        }
    }
}

define_id_type!(UserId);
</code></pre>

<hr />

<p>マクロをどこで使えるかはイマイチドキュメントがなく、実験的に確かめるしかありません。</p>

<h1 id="マクロを定義する">マクロを定義する</h1>

<h2 id="基本の-き">基本の「き」</h2>

<p>マクロで何が書けるかを見てきたので次はマクロを書いてみましょう。とはいってもいままで定義してきましたね。
最初の<code>add!</code>マクロを取り出してみましょう。</p>

<pre><code class="language-rust">macro_rules! add {
    ($e1: expr, $e2: expr) =&gt; {
        $e1 + $e2
    };
}
</code></pre>

<p>これの引数のところを取り出してみましょう</p>

<pre><code>($e1: expr, $e2: expr)
</code></pre>

<p><code>$e1</code>, <code>$e2</code> などはいいですね。引数の変数です。
マクロは引数でパターンマッチできるので変数はそれとの違いを明確にするために<code>$</code>をつけます。</p>

<p><code>:expr</code>の方です。マクロの引数にも型があります。構文を受け取るので型は構文の型です。ここでは<code>expr</code>型の構文を受け取ると言っています。
<code>expr</code> 型はRustの構文でいう式、つまりは計算すると値を返す構文の型です。</p>

<p>他にも構文の型はいくつかあります。</p>

<ul>
<li><code>item</code>: <code>fn</code>定義<code>struct</code>定義などのトップレベルに置かれるものです</li>
<li><code>block</code>: ブロック。雑に言うと波括弧で括られた式/文ですね。<code>{let x = 1; x * 2}</code>など。</li>
<li><code>stmt</code>: 文。雑に言うと<code>;</code>で終わるやつです。<code>let x = 1;</code>など。</li>
<li><code>pat</code>: パターン。<code>match</code>や<code>if let</code>、<code>let</code>などで使えるやつです。</li>
<li><code>expr</code>: 式。先程説明したとおり、計算すると値を返すものです。<code>1 + 2</code>など。</li>
<li><code>ty</code>: 型。</li>
<li><code>ident</code>: 識別子。関数名、変数名などですね。</li>
<li><code>path</code>: パスです。<code>std::collections::HashMap</code>などです。</li>
<li><code>tt</code>: トークンツリー。1塊になってる構文要素です。まあ、なんかなんでもアリみたいなやつです。</li>
<li><code>meta</code>: メタアイテムです。雑にいうと<code>#[]</code>の中身です。</li>
</ul>

<p>これを覚えておけばマクロの引数には困りません。
あと比較的最近、可視性(<code>pub</code>や<code>pub(crate)</code>など)も導入された筈ですがドキュメントが見当たらないので流します。</p>

<p>よく使うのは<code>expr</code>, <code>ty</code>, <code>ident</code>あたりかなーといったところです。</p>

<h2 id="パターン-1">パターン</h2>

<p>マクロの引数の位置にはパターンが書けます。試しに<code>Vec</code>を作る<code>vec!</code>マクロのように<code>HashMap</code>を作る<code>map!</code>マクロを作ってみましょう。</p>

<pre><code class="language-rust">macro_rules! map {
    ($($k: expr =&gt; $v: expr),*) =&gt; {{
        let mut map = ::std::collections::HashMap::new();
        $(map.insert($k, $v);)*
        map
    }};
}

fn main() {
    let nums = map!{1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;};
    println!(&quot;{}&quot;, nums[&amp;2]);
}
</code></pre>

<p>一気に詰め込みすぎましたかね？ひとつづつ見ていきます。</p>

<p>まずはパターンの<code>$k: expr =&gt; $v: expr</code>の部分。
<code>1 =&gt; &quot;one&quot;</code>や<code>2 =&gt; &quot;two&quot;</code>にマッチしています。
それっぽくパターンを書くとrustコンパイラがいい感じにマッチしてくれます。
ここでの<code>=&gt;</code>のようにマクロを使うとRustにない構文でも自由に受け取れるようになります。マクロ便利ですね。
ところで<code>add!</code>マクロで<code>($e1: expr, $e2:expr)</code>のようにカンマで区切っていたのもカンマに対するマッチだった訳ですね。</p>

<p>この新しい記号の導入はある程度制限があります。たとえばここで<code>+</code>を区切りに使うと怒られます。
<code>map![1+1+1]</code>と渡した場合に<code>+</code>がマクロの区切りなのか足し算をしているのか区別が付かないからです。
これはどの記号が許容されるかはドキュメントに書いてあるので気になる人は確認して下さい。
ドキュメントを読まない人はRustの構文解析器の気持ちになって察して下さい。間違ってたらコンパイラが教えてくれるのでそれでもいいと思います。</p>

<p>次に<code>$(...),*</code>の部分。これは0回以上のパターンの繰り返しです。
複数個使おうと思ったら必要ですね。
地味に<code>,</code>の扱いが特別で、<code>map!{1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;}</code>の使用からみても分かるとおり区切りの位置にのみマッチします。<code>map!{1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;,}</code>と最後にカンマを書くとエラーになります。</p>

<p>パターンはいいのですが、使用箇所も見ておきましょう。<code>$(map.insert($k, $v);)*</code>です。
使用時にも<code>$(...)*</code>包んでいます。ここでは<code>$()</code>の中に<code>;</code>を入れているので区切りを使ってませんね。
区切りを外に出して<code>$(map.insert($k, $v));*;</code>と書くことも可能ですが、最後のセミコロンに注意しましょう。</p>

<p>最後に、マクロの本体が複文になったので全体が<code>{{ }}</code>で囲まれています。
外側の<code>{}</code>がマクロの本体を括る括弧で、内側の<code>{}</code>がマクロの返り値を1つの構文要素にするための括弧です。</p>

<p>さて、これでだいたいマクロは説明した気がするので実例をみていきましょう。</p>

<h1 id="マクロ実例集">マクロ実例集</h1>

<h2 id="match-vec"><code>match_vec!</code></h2>

<p>説明していませんでしたが、マクロのパターンは複数書けます。関数定義よりは<code>match</code>を書いている気分に近いですね。</p>

<pre><code class="language-rust">macro_rules! ignore {
    ($pat: tt) =&gt; {}
}

macro_rules! match_vec {
    // `vec![]`パターンの末尾カンマに対応するために末尾カンマを取り除いて本体に渡すための節
    (let vec![$($pat:pat),*,] = $v:expr;) =&gt; (
        match_vec!(let vec![$($pat),*] = $v;)
    );
    // 本体
    (let vec![$($pat:pat),*] = $v:expr;) =&gt; (
        let ($($pat),*) = {
            // * exprで受けたので`vec![1, 2, 3]`などのまだ評価されていない式も来うる。
            //   一旦変数に格納して評価させる。
            // * ついでに`mut`をつけたりイテレータを取り出したり。
            let mut i = $v.into_iter();
            // * `$()*`を使いたいが`$pat`は使わないので`ignore`を使って無視する
            // * お粗末だが`next()`に対して`unwrap()`している。
            //   実行時のマッチ失敗panicを投げる余裕があるなら投げるべき。
            let ret = ($({ignore!($pat); i.next().unwrap()}),*);
            // 同じくvecが余った場合の検査を`assert!`に丸投げしている。
            assert!(i.next().is_none());
            ret
        };
    )
}

</code></pre>

<p>使い方</p>

<pre><code class="language-rust">fn main() {
    let v = vec![1, 2, 3];
    match_vec! {
        let vec![x, y, z] = v;
    }
    // 上の式を展開するとこうなるはず。
    //
    // // 複数のパターンマッチをタプルのマッチに落とし込んでいる。
    // let (x, y, z) = {
    //   // (マニアックな話):Rustのマクロは衛生的なのでマクロ内で定義した`i`がgensym(rename)される。
    //   let mut i_xxx = v.into_iter();
    //   let ret = (
    //     {ignore!(x);i_xxx.next().unwrap()},
    //     {ignore!(y);i_xxx.next().unwrap()},
    //     {ignore!(z);i_xxx.next().unwrap()},
    //   );
    //   assert!(i_xxx.next().is_none());
    //   ret
    // };
    println!(&quot;x: {}, y: {}, z: {}&quot;, x, y, z); // -&gt; x: 1, y: 2, z: 3
}
</code></pre>

<p>興味があるなら<code>HashMap</code>向けのものも書くと練習になるかもしれません。</p>

<h2 id="err"><code>err!</code></h2>

<p>定義自体はシンプルです。</p>

<pre><code class="language-rust">macro_rules! err {
    ($e: expr) =&gt; {
        return Err($e.into())
    }
}

</code></pre>

<p>使うのもシンプル</p>

<pre><code class="language-rust">fn fact(n: i32) -&gt; Result&lt;i32, String&gt; {
    if n &lt; 0 {
        err!(&quot;n is negative&quot;)
    }
    let mut ret = 1;
    for i in 1..(n + 1) {
        ret *= i;
    }

    Ok(ret)
}

fn main() {
    println!(&quot;{:?}&quot;, fact(-3)); // -&gt; Err(&quot;n is negative&quot;) 
}
</code></pre>

<p>シンプルですが<code>return</code>のようにコントロールフローに干渉するようなものは関数では書けなくて、マクロが必要になります。</p>

<h2 id="define-error-enum"><code>define_error_enum!</code></h2>

<p>エラーハンドリングのときに複数のエラーを束ねるenumの実装を生成するやつです。
現実的には<a href="https://github.com/rust-lang-nursery/error-chain">error_chain</a>などのちゃんとしたものを使うべきですが、似たようなケースに遭遇したときに自分でボイラープレートを削減出来るマクロを書けると便利です。</p>

<pre><code class="language-rust">macro_rules! define_error_enum {
    // 普通のenumっぽく書けるようにパターンを工夫してある。
    // 無骨に型名、列挙子と対応するエラー型名だけを受け取っても本質は変わらない。
    ($(#[$meta:meta])*
     pub enum $name: ident { $($variant: ident ($ty: ty),)* } ) =&gt; {
        // この`$(#[$meta])*`を用意しておくとユーザは好きにderiveなどを書ける。
        $(#[$meta])*
        pub enum $name {
            // 本当はvariantにもmetaをつけれるようにすべきだが、面倒なので読者の課題とする
            $($variant($ty),)*
        }

        // 各型毎に`From`を実装
        $(
            impl From&lt;$ty&gt; for $name {
                fn from(e: $ty) -&gt; Self {
                    $name::$variant(e)
                }
            }
        )*


        // この型自体もErrorになるように諸々実装。
        // 実装は内部のエラーにdelegateするだけ。
        impl ::std::fmt::Display for $name {
            fn fmt(&amp;self, f: &amp;mut ::std::fmt::Formatter) -&gt; ::std::fmt::Result {
                use self::$name::*;
                match self {
                    $(&amp;$variant(ref e) =&gt; e.fmt(f),)*
                }
            }
        }

        impl ::std::error::Error for $name {
            fn description(&amp;self) -&gt; &amp;str {
                use self::$name::*;
                match self {
                    $(&amp;$variant(ref e) =&gt; e.description(),)*
                }
            }

            fn cause(&amp;self) -&gt; Option&lt;&amp;::std::error::Error&gt; {
                use self::$name::*;
                match self {
                    $(&amp;$variant(ref e) =&gt; Some(e),)*
                }
            }
        }
    }
}
</code></pre>

<p>結構大きいですがほぼボイラープレートなのでマクロとしてはあんまりおもしろいことはやってないです。</p>

<p>使い方ですが、まずエラー型を適当に用意しましょう。</p>

<pre><code class="language-rust">use std::fmt;
use std::error::Error;

#[derive(Debug)]
pub struct Error1;

impl fmt::Display for Error1 {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;this is error1&quot;)
    }
}

impl Error for Error1 {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;error1 occurred&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; {
        None
    }
}

#[derive(Debug)]
pub struct Error2;

impl fmt::Display for Error2 {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;this is error2&quot;)
    }
}

impl Error for Error2 {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;error2 occurred&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; {
        None
    }
}

</code></pre>

<p>そして</p>

<pre><code class="language-rust">
//ほぼenumの定義っぽく書ける
define_error_enum! {
    #[derive(Debug)]
    pub enum GenericError {
        E1(Error1),
        E2(Error2),
    }
}

fn main() {
    // intoを自動で実装した
    let e: GenericError = Error1.into();
    // displayを自動で実装した
    println!(&quot;{}&quot;, e); // -&gt; this is error1
}

</code></pre>

<p>便利ですね。</p>

<hr />

<p>こういった、「もうちょっとすっきり書けないかな」「ほぼコピペなコードが量産されるんだけどどうにかならないの」な状況にマクロが便利です。</p>

<h1 id="マクロプログラミング">マクロプログラミング</h1>

<p>ここからはプログラミングの余興、サーカス的プログラミングの世界です。</p>

<p>Rustのマクロには再帰(ループ)とパターンマッチ(分岐)があるのでチューリング完全です。
そう訊いたらとりあえずプログラミングしてみたくなりますよね？</p>

<h1 id="最初の試み">最初の試み</h1>

<p>そう聞いたあなたはすぐさま<code>(1, ...)</code>で数値を表すことにして以下のようなマクロを書き下すでしょう。</p>

<pre><code class="language-rust">macro_rules! add {
    (($($l: tt),*), ()) =&gt; {
        ($($l),*)
    };
    (($($l: tt),*), (1)) =&gt; {
        (1, $($l),*)
    };
    (($($l:tt),*), (1, $($r: tt),*)) =&gt; {
        add!((1, $($l),*), ($($r),*))
    };
}

macro_rules! sub {
    (($($l: tt),*), ()) =&gt; {
        ($($l),*)
    };
    ((1 $(, $l: tt)*), (1)) =&gt; {
        ($($l),*)
    };
    ((1 $(, $l:tt)*), (1 $(, $r: tt)*)) =&gt; {
        sub!(($($l),*), ($($r),*))
    };
}

macro_rules! fib {
    (()) =&gt; {(1)};
    ((1)) =&gt; {(1)};
    (($($n:tt),*)) =&gt; {
        add!(fib!(sub!(($($n),*), (1))), fib!(sub!(($($n),*), (1, 1))))
    };
}

fn main() {
    let n = fib!((1, 1, 1));
    println!(&quot;{:?}&quot;, n);
}
</code></pre>

<p>しかしこれはうまく動作しません。</p>

<pre><code>error: no rules expected the token `fib`
  --&gt; macro.rs:29:14
   |
29 |         add!(fib!(sub!(($($n),*), (1))), fib!(sub!(($($n),*), (1, 1))))
   |              ^^^
...
34 |     let n = fib!((1, 1, 1));
   |             --------------- in this macro invocation

error: aborting due to previous error

error: Could not compile `macro`.

To learn more, run the command again with --verbose.
internal error: cargo failed with status 101
</code></pre>

<p>これはマクロの展開の順序が絡んできます。
普通の関数だと内側から展開されますが、マクロは外側から展開するので問題が起きます。
<code>fib!</code>の第3節の本体は<code>add!(sub!($($n),*, (1)), sub!($($n),*, (1, 1)))</code>ですね。
このマクロ式の呼び出しは外側から、つまり<code>add!</code>から展開されます。
<code>add!</code>は<code>(sub!($n, (1)), sub!($n, (1, 1)))</code>に対してパターンマッチしようとして失敗しているのです。</p>

<p>さて、どうしましょう。普通にはプログラミングできません。外側から展開していたものを内側から展開するようにうまいことやる手段はあるでしょうか。</p>

<p>そう、みなさんならおわかりですね。「CPSするとlazyをeagerに変換できる」というやつです。正確にはCPSじゃありませんが。</p>

<h1 id="ck"><code>ck!</code></h1>

<p>コードと継続からなる抽象マシン、CKマシンをマクロで適当にエミュレートするのが<code>ck!</code>マクロです。詳しくはこの記事を→ <a href="https://qiita.com/dico_leque/items/e2c7a88df2e9dfe9a446">syntax-rulesズンドコキヨシ、またはマクロ展開時ズンドコキヨシ</a>。
雑に言うとコールスタックを自前で実装したらネストしたマクロ呼び出しもできるよねってやつです。
ただちょっと面倒なのが引数が複数あるので呼び出しの深さに応じてスタックを縦に積むのと引数の数に応じて中身を横に広げるの2つの操作がある点ですね。これはスタックにタプルを積むことで解決します。</p>

<p>また、rust特有の問題として、マクロ呼び出しが<code>name ! (args...)</code>と3トークンに分かれてしまうのでやや扱いに気をつける必要があります。
もう一つ、値をマクロと同じように扱わないと対応するパターンが爆発してしまうのでLispでいうquote相当のものとして<code>q!</code>という目印を使います。
これは<code>ck!</code>マクロ内で目印として使っているだけのものなので特に実体は必要ありません。</p>

<pre><code class="language-rust">// ck(スタック, 式)という形で評価していく。なんとなく継続を起動してるイメージ
// 評価が終わったら`q!(値)`という形で目印を付ける
//
// スタックは以下のような形。
// [(マクロ名, (まだ評価していない引数...), (評価が終わった引数 ...)), ...]
//
// ここで受け取るマクロは全てスタックを第一引数に取るものとする。CPSでいう継続っぽいもの。
macro_rules! ck {
    // スタックが空で値が出来ているなら値を返す
    ([], q!($value:tt)) =&gt; {
        $value
    };
    // 評価対象がマクロ呼び出しならスタックに積んで第一引数から評価を始める
    ([$($stack:tt),*], $name:ident ! ($argn:ident ! $arga:tt, $($args: tt)*)) =&gt; {
        ck!([($name, ($($args)*), ()) $(,$stack)*], $argn!$arga)
    };
    // コンマの扱いのために1引数の場合も別途定義
    ([$($stack:tt),*], $name:ident ! ($argn:ident ! $arga:tt)) =&gt; {
        ck!([($name, (), ()) $(,$stack)*], $argn!$arga)
    };
    // 無引数マクロは即時評価
    ([$($stack:tt),*], $name:ident ! ()) =&gt; {
        name!([$($stack),*])
    };
    // 1つの引数の評価が終わって、まだ評価していない引数があるなら
    // 評価が終わったリストにその値を加えてまだ評価していない引数を評価する
    ([($name:ident, ($todon:ident ! $todoa:tt, $($todos:tt)*), ($($dones:tt),*)) $(, $stack:tt)*], q!($value:tt)) =&gt; {
        ck!([($name, ($($todos)*), ($($dones,)* $value)) $(, $stack)*], $todon ! $todoa)
    };
    // コンマの扱いのためにtodoが1つの場合も別途定義
    ([($name:ident, ($todon:ident ! $todoa:tt), ($($dones:tt),*)) $(, $stack:tt)*], q!($value:tt)) =&gt; {
        ck!([($name, (), ($($dones,)* $value)) $(, $stack)*], $todon ! $todoa)
    };
    // 全ての引数を評価したなら満を持してマクロを呼ぶ。コールスタックを渡しているので帰ってこれる。
    ([($name:ident, ( ), ($($dones:tt),*)) $(, $stack:tt)*], q!($value:tt)) =&gt; {
        $name!([$($stack),*], $($dones,)* $value)
    };
}
</code></pre>

<p>このCKマクロを使うと次のようにマクロを定義できます。</p>

<pre><code class="language-rust">macro_rules! add {
    ($s:tt, ($($l:tt),*), ()) =&gt; {
        ck!($s, q!(($($l),*)))
    };
    ($s:tt, ($($l:tt),*), (1)) =&gt; {
        ck!($s, q!((1, $($l),*)))
    };
    ($s:tt, ($($l:tt),*), (1 $(, $r:tt)*)) =&gt; {
        ck!($s, add!(q!((1, $($l),*)), q!(($($r),*))))
    };
}

macro_rules! sub {
    ($s:tt, ($($l: tt),*), ()) =&gt; {
        ck!($s, q!(($($l),*)))
    };
    ($s:tt, (1 $(, $l: tt)*), (1)) =&gt; {
        ck!($s, q!(($($l),*)))
    };
    ($s:tt,  (1 $(, $l:tt)*), (1 $(, $r: tt)*)) =&gt; {
        ck!($s, sub!(q!(($($l),*)), q!(($($r),*))))
    };
}

macro_rules! fib {
    ($s: tt, ()) =&gt; {ck!($s, q!((1)))};
    ($s: tt, (1)) =&gt; {ck!($s, q!((1)))};
    ($s: tt, ($($n:tt),*)) =&gt; {
        ck!($s, add!(fib!(sub!(q!(($($n),*)), q!((1)))), fib!(sub!(q!(($($n),*)), q!((1, 1))))))
    };
}
</code></pre>

<p>これで念願の<code>fib!</code>マクロが動きます。</p>

<pre><code class="language-rust">
fn main() {
    let n = ck!([], fib!(q!((1, 1, 1, 1, 1))));
    println!(&quot;{:?}&quot;, n); // -&gt; (1, 1, 1, 1, 1, 1, 1, 1)
}

</code></pre>

<p>ただしマクロの再帰が深くなるので<code>#![recursion_limit = &quot;256&quot;]</code>が必要となります。</p>

<h1 id="おわりに">おわりに</h1>

<p>マクロは便利な使い方もアホな使い方もできるよって話でした。</p>
                    </section>
                </article>
            </div>
        </div>

        <div class="row li-author">
    <div class="sixteen columns">
        Written by <strong>κeen</strong>
    </div>
</div>


        <div class="row li-pagination">
            <div class="eight columns">
                <div class="li-pagination-previous">
                    
                        Later article<br />
                        <a href="//KeenS.github.io/blog/2018/02/24/kansuutekiyou_kansuukarahyoukasuruka_hikisuukarahyoukasuruka/"> 関数適用、関数から評価するか？引数から評価するか？</a>
                    
                </div>
            </div>
            <div class="eight columns">
                <div class="li-pagination-next">
                    
                        Older article<br />
                        <a href="//KeenS.github.io/blog/2018/02/08/aratamemashiterockdbsan/"> 改めましてRocksDBさん</a>
                    
                </div>
            </div>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2018. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="https://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

    <script type="text/javascript">
    <!--
    function toggle(id) {
        var e = document.getElementById(id);
        e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
    }
    
    </script>
    <script type="text/javascript">
     <!--
                                   var _gaq = _gaq || [];
     _gaq.push(['_setAccount', ""]);
     _gaq.push(['_trackPageview']);

     (function() {
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
     })();
    
    </script>
    <script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>

