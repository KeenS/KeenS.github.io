<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="手続き型脳で型推論を実装してみた | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="このエントリは型 Advent Calendar 2019 - Qiita 2日目に遡って投稿しているエントリです。
担当に遅刻した訳ではなくて空いてたので前から詰めて投稿しただけです。
κeenです。世の中に型推論アルゴリズムは色々知られていると思いますが、それを一切無視して型推論を実装してみたので報告します。" />
        <meta property="og:title" content="手続き型脳で型推論を実装してみた | κeenのHappy Hacκing Blog" />
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https://KeenS.github.io/blog/2019/12/08/tetsuzukigatanoudekatasuironwojissoushitemita/" />
        <meta property="og:description" content="このエントリは型 Advent Calendar 2019 - Qiita 2日目に遡って投稿しているエントリです。
担当に遅刻した訳ではなくて空いてたので前から詰めて投稿しただけです。
κeenです。世の中に型推論アルゴリズムは色々知られていると思いますが、それを一切無視して型推論を実装してみたので報告します。" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta property="og:image" content="https://KeenS.github.io/images/ogp/post/tetsuzukigatanoudekatasuironwojissoushitemita.png" />
        <meta name="twitter:image" content="https://KeenS.github.io/images/ogp/post/tetsuzukigatanoudekatasuironwojissoushitemita.png" />
        
        <meta property="og:article:published_time" content="2019-12-08 16:58:42 &#43;0900 JST" />
        <meta property="og:article:modified_time" content="2019-12-08 16:58:42 &#43;0900 JST" />
        
        <meta property="og:article:author" content="κeen" />

        <title>手続き型脳で型推論を実装してみた | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css' />
        <link rel="stylesheet" href="https://KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/liquorice.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="https://KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="https://KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="https://KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
        <link rel="apple-touch-icon-precomposed" href="https://KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/syntax-monokai.css" />
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<link rel="stylesheet" href="//unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css">

    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="https://KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="https://KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                        
                            <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="https://KeenS.github.io/search/"> Search </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="https://KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                    
                        <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="https://KeenS.github.io/search/"> Search </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                    <header class="li-article-header">
                        <h1 class="li-article-title">手続き型脳で型推論を実装してみた</h1>
                        <div class="li-article-meta">
    <time class="li-article-date">2019-12-08</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="https://KeenS.github.io/categories/%e5%9e%8b">型</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/%e5%9e%8b%e6%8e%a8%e8%ab%96">型推論</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/%e8%a8%80%e8%aa%9e%e5%ae%9f%e8%a3%85">言語実装</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/advent-calendar">Advent Calendar</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/advent-calendar-2019">Advent Calendar 2019</a>
        </li>
    
</ul>

</div>

                    </header>
                    <section>
                        <p>このエントリは<a href="https://qiita.com/advent-calendar/2019/type">型 Advent Calendar 2019 - Qiita</a> 2日目に遡って投稿しているエントリです。
担当に遅刻した訳ではなくて空いてたので前から詰めて投稿しただけです。</p>
<p>κeenです。世の中に型推論アルゴリズムは色々知られていると思いますが、それを一切無視して型推論を実装してみたので報告します。</p>
<h1 id="型推論の基本的理解">型推論の基本的理解</h1>
<p>式に型変数を割り当てて、既に分かっている型から制約条件をつけてその制約の連立方程式を解けばいいです。</p>
<p>例えば以下のようなSMLの式を考えましょう。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sml" data-lang="sml"><span class="line"><span class="cl"><span class="kr">val</span> <span class="nv">printLn</span> <span class="p">=</span> <span class="kr">fn</span> <span class="n">s</span> <span class="n">=&gt;</span> <span class="p">(</span><span class="n">print</span> <span class="p">(</span><span class="n">s</span> <span class="n">^</span> <span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">))</span>
</span></span></code></pre></div><p>まずはそれぞれの式に変数を割り当てます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">printLn: &#39;a
</span></span><span class="line"><span class="cl">s: &#39;b
</span></span><span class="line"><span class="cl">print: &#39;c
</span></span><span class="line"><span class="cl">op^ :&#39;d
</span></span><span class="line"><span class="cl">&#34;\n&#34;: &#39;e
</span></span><span class="line"><span class="cl">(s ^ &#34;\n&#34;): &#39;f
</span></span><span class="line"><span class="cl">print (s ^ &#34;\n&#34;): &#39;g
</span></span></code></pre></div><p>使われ方から以下の等式が出ます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">&#39;a = &#39;b -&gt; &#39;g
</span></span><span class="line"><span class="cl">(* 一時的な変数 &#39;h, &#39;i を導入 *)
</span></span><span class="line"><span class="cl">&#39;c = &#39;h -&gt; &#39;i
</span></span><span class="line"><span class="cl">(* 一時的な変数 &#39;j, &#39;k, &#39;l を導入 *)
</span></span><span class="line"><span class="cl">&#39;d = &#39;j * &#39;k -&gt; &#39;l
</span></span><span class="line"><span class="cl">&#39;h = &#39;f
</span></span><span class="line"><span class="cl">&#39;i = &#39;g
</span></span><span class="line"><span class="cl">&#39;j = &#39;b
</span></span><span class="line"><span class="cl">&#39;k = &#39;e
</span></span><span class="line"><span class="cl">&#39;l = &#39;f
</span></span></code></pre></div><p>これから変数の値を全て確定させる （= 全ての変数の制約について、 <code>'x = type</code> という形に変形する）のが目標です。
ひとまずそれぞれの変数の制約状況を見てみましょう。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">&#39;a = &#39;b -&gt; &#39;g
</span></span><span class="line"><span class="cl">&#39;b = ???
</span></span><span class="line"><span class="cl">&#39;c = &#39;h -&gt; &#39;i
</span></span><span class="line"><span class="cl">&#39;d = &#39;j * &#39;k -&gt; &#39;l
</span></span><span class="line"><span class="cl">&#39;e = ???
</span></span><span class="line"><span class="cl">&#39;f = ???
</span></span><span class="line"><span class="cl">&#39;g = ???
</span></span><span class="line"><span class="cl">&#39;h = &#39;f
</span></span><span class="line"><span class="cl">&#39;i = &#39;g
</span></span><span class="line"><span class="cl">&#39;j = &#39;b
</span></span><span class="line"><span class="cl">&#39;k = &#39;e
</span></span><span class="line"><span class="cl">&#39;l = &#39;f
</span></span></code></pre></div><p>ここで <code>print: string -&gt; unit</code> 、 <code>op^: string * string -&gt; string</code> 、 <code>&quot;\n&quot;: string</code> という制約が事前に分かっていたとします。
この式を1つ1つあてはめていきます。</p>
<p>まずは <code>print: string -&gt; unit</code> より <code>'c = string -&gt; unit</code> 。
<code>'c = 'h -&gt; 'i</code> でもあるので <strong>構造的に比較</strong> して、 <code>'h = string</code> 、 <code>'i = unit</code> も得られます。
さらに <code>'h = 'f</code> や <code>'i = 'g</code> などからいくつかの変数の値が <strong>自動的に決まります</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">&#39;a = &#39;b -&gt; unit
</span></span><span class="line"><span class="cl">&#39;b = ???
</span></span><span class="line"><span class="cl">&#39;c = string -&gt; unit
</span></span><span class="line"><span class="cl">&#39;d = &#39;j * &#39;k -&gt; string
</span></span><span class="line"><span class="cl">&#39;e = ???
</span></span><span class="line"><span class="cl">&#39;f = string
</span></span><span class="line"><span class="cl">&#39;g = unit
</span></span><span class="line"><span class="cl">&#39;h = string
</span></span><span class="line"><span class="cl">&#39;i = unit
</span></span><span class="line"><span class="cl">&#39;j = &#39;b
</span></span><span class="line"><span class="cl">&#39;k = &#39;e
</span></span><span class="line"><span class="cl">&#39;l = string
</span></span></code></pre></div><p>同様に <code>op^: string * string -&gt; string</code> から <code>'j = string</code> 、 <code>'k = string</code> 、 <code>string = string</code> などが得られます。
最後の <code>string = string</code> は恒真なのでスルーします。ここで <code>string = unit</code> などが出ると、矛盾としてエラーを出します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">&#39;a = string -&gt; unit
</span></span><span class="line"><span class="cl">&#39;b = string
</span></span><span class="line"><span class="cl">&#39;c = string -&gt; unit
</span></span><span class="line"><span class="cl">&#39;d = string * string -&gt; string
</span></span><span class="line"><span class="cl">&#39;e = string
</span></span><span class="line"><span class="cl">&#39;f = string
</span></span><span class="line"><span class="cl">&#39;g = unit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#39;h = string
</span></span><span class="line"><span class="cl">&#39;i = unit
</span></span><span class="line"><span class="cl">&#39;j = string
</span></span><span class="line"><span class="cl">&#39;k = string
</span></span><span class="line"><span class="cl">&#39;l = string
</span></span></code></pre></div><p>これで既に変数が全部埋まりましたが、これが残りの制約と矛盾してないかの確認も必要なので推論を続けます。 <code>&quot;\n&quot;: string</code> より <code>'e = string</code> 。
これは矛盾しないですね。</p>
<p>ということで型推論が終わりました。特に、 <code>printLn</code> には <code>string -&gt; unit</code> 型が付くことが分かりました。</p>
<p>この手計算を <strong>手続型脳で</strong> プログラムにしていきたいと思います。</p>
<h1 id="ゆにふぁい">ゆにふぁい！</h1>
<p>プログラムに移る前に、先程の例で、ちょっと非自明なことを2つしてました。
そこを掘り下げておきましょう。</p>
<p>1つは構造的比較です。
<code>string -&gt; unit = 'h -&gt; 'i</code> という制約から <code>'h = string</code> 、 <code>'i = unit</code> という式を導き出しました。
この導出はユニフィケーション（unification、単一化とも）と呼ばれ、いくつかのルールにより動作しています。</p>
<ol>
<li><code>string = string</code> のように恒真式なら正常終了</li>
<li><code>string = unit</code> のように矛盾していたら異常終了</li>
<li><code>'x = ty</code> のように、変数と具体的な型のユニフィケーションなら <code>'x</code> に <code>string</code> を代入する</li>
<li><code>'x = 'y</code> のように、変数同士のユニフィケーションなら将来どちらかに代入された場合に他方も同じ値になるように、結び付ける</li>
<li><code>'a -&gt; 'b = 'x -&gt; 'y</code> のように同じ種類の合成型同士のユニフィケーションなら、構成要素のそれぞれでユニフィケーションする。
この例なら <code>'a</code> と <code>'x</code> 、 <code>'b</code> と <code>'y</code> でユニフィケーションする。</li>
<li>それ以外 (<code>'a -&gt; 'b = string</code> のように合成型と基本型、あるいは <code>'a -&gt; 'b = 'a * 'b</code>のように違う合成型同士)の場合は異常終了</li>
</ol>
<p>もう1つは、1つの制約式の追加でいくつかの変数の値が自動的に決まった点です。自動的というか推移的というか。
例えば <code>'a = 'b -&gt; 'c</code> という制約があったところに、 <code>'a = string -&gt; unit</code> という制約を加えると、<code>'b</code> や <code>'c</code> は直接は登場してないのに <code>'b = string</code> 、 <code>'c = unit</code> という制約が得られます。
数式としては至極自然な挙動なのですが、実装は1つ1つ辿っていくとすると大変そうです。
しかしまあ、なんかポインタで1箇所指してれば実現できそうな挙動ではあります。</p>
<h1 id="方針">方針</h1>
<p>型同士をユニファイするコードと、制約を推移的に適用する部分を別々に実装しましょう。</p>
<p>型同士を単一化するやつは簡単なパターンマッチで書けそうです。推移的に適用する部分をもう少し掘り下げましょう。</p>
<h2 id="ユニフィケーションプール">ユニフィケーションプール</h2>
<p>制約を推移的に適用する部分はポインタにしとくと、どうにかなりそうという観測がありました。
もう少し物理的なイメージを膨らませましょう。</p>
<h3 id="表現">表現</h3>
<p>まずは型は全てポインタとします。ポイント先は型の実体の配列です。
例えば <code>string</code> 型はこうです。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">string
</span></span><span class="line"><span class="cl">  |
</span></span><span class="line"><span class="cl">  v
</span></span><span class="line"><span class="cl">+---+---
</span></span><span class="line"><span class="cl">| * | ...
</span></span><span class="line"><span class="cl">+-|-+---
</span></span><span class="line"><span class="cl">  |
</span></span><span class="line"><span class="cl">  S
</span></span></code></pre></div><p>ここで <code>S</code> は <code>string</code> 型を表わす内部表現とします。</p>
<p><code>string -&gt; unit</code> 型はこうです。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">        string -&gt; unit
</span></span><span class="line"><span class="cl">               |
</span></span><span class="line"><span class="cl">     unit      |
</span></span><span class="line"><span class="cl">string |       |
</span></span><span class="line"><span class="cl">  |   ++  +----+
</span></span><span class="line"><span class="cl">  v   v   v
</span></span><span class="line"><span class="cl">+---+---+---+
</span></span><span class="line"><span class="cl">| * | * | * |
</span></span><span class="line"><span class="cl">+-|-+-|-+-|-+
</span></span><span class="line"><span class="cl">  |   |   +----+
</span></span><span class="line"><span class="cl">  S   U        |
</span></span><span class="line"><span class="cl">         F(string, unit)
</span></span></code></pre></div><p>ここで <code>U</code> は <code>unit</code> 型を表わす内部表現、 <code>F</code> は関数型を表わす内部表現とします。
<code>F</code> の引数が <code>S</code> や <code>U</code> ではなく <code>string</code> や <code>unit</code> になっていることに注意して下さい。
<code>F</code> はポインタを引数にとっているので、ポイントの中身が変化したら自動で追従してくれます。</p>
<h3 id="ゆにふぁい１">ゆにふぁい！（１）</h3>
<p>変数と <code>string</code> をユニファイしてみましょう。ゆにふぁい！</p>
<p>まずは <code>'a</code> と <code>string</code> があります。変数 <code>'x</code> の内部表現は <code>V(&quot;x&quot;)</code> とします。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"> &#39;a  string
</span></span><span class="line"><span class="cl">  |   |
</span></span><span class="line"><span class="cl">  v   v
</span></span><span class="line"><span class="cl">+---+---+
</span></span><span class="line"><span class="cl">| * | * |
</span></span><span class="line"><span class="cl">+-|-+-|-+
</span></span><span class="line"><span class="cl">  |   |
</span></span><span class="line"><span class="cl">  |   S
</span></span><span class="line"><span class="cl">V(&#34;a&#34;)
</span></span></code></pre></div><p>ユニフィケーションすると変数の内部表現がポインタに変わります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"> &#39;a  string
</span></span><span class="line"><span class="cl">  |   |
</span></span><span class="line"><span class="cl">  v   v
</span></span><span class="line"><span class="cl">+---+---+
</span></span><span class="line"><span class="cl">| * | * |
</span></span><span class="line"><span class="cl">+-|-+-|-+
</span></span><span class="line"><span class="cl">  |   |
</span></span><span class="line"><span class="cl">  |   S
</span></span><span class="line"><span class="cl">string
</span></span></code></pre></div><p>これで出てくるポインタをどんどん辿っていけば <code>'a</code> から <code>S</code> に到達するので <code>'a</code> が <code>S</code> になることが分かります。無事ユニフィケーションできているようです。</p>
<h3 id="ゆにふぁい２">ゆにふぁい！（２）</h3>
<p>もう1例、 件の <code>'b -&gt; 'c = 'a = string -&gt; unit</code> のユニフィケーションをしてみましょう。ゆにふぁい！</p>
<p>まず、変数 &lsquo;a, &lsquo;b, &lsquo;c があります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"> &#39;a  &#39;b  &#39;c
</span></span><span class="line"><span class="cl">  |   |   |
</span></span><span class="line"><span class="cl">  v   v   v
</span></span><span class="line"><span class="cl">+---+---+---+
</span></span><span class="line"><span class="cl">| * | * | * |
</span></span><span class="line"><span class="cl">+-|-+-|-+-|-+
</span></span><span class="line"><span class="cl">  |   |   |
</span></span><span class="line"><span class="cl">V(&#34;a&#34;)| V(&#34;c&#34;)
</span></span><span class="line"><span class="cl">   V(&#34;b&#34;)
</span></span></code></pre></div><p><code>'a = 'b -&gt; 'c</code> です。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"> &#39;a  &#39;b  &#39;c
</span></span><span class="line"><span class="cl">  |   |   |
</span></span><span class="line"><span class="cl">  v   v   v
</span></span><span class="line"><span class="cl">+---+---+---+
</span></span><span class="line"><span class="cl">| * | * | * |
</span></span><span class="line"><span class="cl">+-|-+-|-+-|-+
</span></span><span class="line"><span class="cl">  |   |   |
</span></span><span class="line"><span class="cl">  |   | V(&#34;c&#34;)
</span></span><span class="line"><span class="cl">  | V(&#34;b&#34;)
</span></span><span class="line"><span class="cl">F(&#39;b, &#39;c)
</span></span></code></pre></div><p><code>string -&gt; unit</code> があります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">                    string -&gt; unit
</span></span><span class="line"><span class="cl">                           |
</span></span><span class="line"><span class="cl">                 unit      |
</span></span><span class="line"><span class="cl"> &#39;a  &#39;b  &#39;c string |       |
</span></span><span class="line"><span class="cl">  |   |   |   |   ++  +----+
</span></span><span class="line"><span class="cl">  v   v   v   v   v   v
</span></span><span class="line"><span class="cl">+---+---+---+---+---+---+
</span></span><span class="line"><span class="cl">| * | * | * | * | * | * |
</span></span><span class="line"><span class="cl">+-|-+-|-+-|-+-|-+-|-+-|-+
</span></span><span class="line"><span class="cl">  |   |   |   |   |   +----+
</span></span><span class="line"><span class="cl">  |   | V(&#34;c&#34;)S   U        |
</span></span><span class="line"><span class="cl">  | V(&#34;b&#34;)           F(string, unit)
</span></span><span class="line"><span class="cl">F(&#39;b, &#39;c)
</span></span></code></pre></div><p><code>'a</code> と <code>string -&gt; unit</code> をユニファイします。</p>
<p><code>'a</code> を辿ると <code>F('b, 'c)</code> 、 <code>string -&gt; unit</code> を辿ると <code>F(string, unit)</code> があります。
ユニフィケーションのルールに則って、それぞれの構成子どうしでユニフィケーションします。
つまり、 <code>'b</code> と <code>string</code> 、 <code>'c</code> と <code>unit</code> でユニフィケーションします。</p>
<p>結果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">                    string -&gt; unit
</span></span><span class="line"><span class="cl">                           |
</span></span><span class="line"><span class="cl">                 unit      |
</span></span><span class="line"><span class="cl"> &#39;a  &#39;b  &#39;c string |       |
</span></span><span class="line"><span class="cl">  |   |   |   |   ++  +----+
</span></span><span class="line"><span class="cl">  v   v   v   v   v   v
</span></span><span class="line"><span class="cl">+---+---+---+---+---+---+
</span></span><span class="line"><span class="cl">| * | * | * | * | * | * |
</span></span><span class="line"><span class="cl">+-|-+-|-+-|-+-|-+-|-+-|-+
</span></span><span class="line"><span class="cl">  |   |   |   |   |   +----+
</span></span><span class="line"><span class="cl">  |   | unit  S   U        |
</span></span><span class="line"><span class="cl">  | string           F(string, unit)
</span></span><span class="line"><span class="cl">F(&#39;b, &#39;c)
</span></span></code></pre></div><p>これで <code>'a</code> を辿っていくと <code>F('b, 'c)</code> 、さらに <code>'b</code> と <code>'c</code> を辿ると <code>string</code> と <code>unit</code> に到達するので <code>'a = string -&gt; unit</code> になってますし、 <code>'b = string</code> 、 <code>'c = unit</code> もでてきました。</p>
<p>この表現でうまくいきそうです。</p>
<h3 id="簡約">簡約</h3>
<p>このままでも問題ないのですが、少しだけ懸案事項があるので解消しておきましょう。</p>
<p><code>'a = 'b = 'c = 'd = string</code> のように、長い制約の連鎖があったとします。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"> &#39;a  &#39;b  &#39;c  &#39;d
</span></span><span class="line"><span class="cl">  |   |   |   |
</span></span><span class="line"><span class="cl">  v   v   v   v
</span></span><span class="line"><span class="cl">+---+---+---+---+
</span></span><span class="line"><span class="cl">| * | * | * | * |
</span></span><span class="line"><span class="cl">+-|-+-|-+-|-+-|-+
</span></span><span class="line"><span class="cl">  |   |   |   |
</span></span><span class="line"><span class="cl"> &#39;b  &#39;c  &#39;d   S
</span></span></code></pre></div><p>このときに <code>'a = string</code> であることは間違いなく表現できているのですが、少し経由するポインタの数が多いですね。
何度も参照すると遅そうです。
もうちょっと定量的に言うと読み取りがセルの数の $O(n)$ に比例する表現はできるだけ避けたいです。 $O(\log n)$ かそれ以下くらいに抑えたいものです。</p>
<p>これには簡単な解決策があります。中間のポインタを省いて値を保持している型に書き換えてしまえばいいのです。先程の例でいくとこうです。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"> &#39;a  &#39;b  &#39;c  &#39;d
</span></span><span class="line"><span class="cl">  |   |   |   |
</span></span><span class="line"><span class="cl">  v   v   v   v
</span></span><span class="line"><span class="cl">+---+---+---+---+
</span></span><span class="line"><span class="cl">| * | * | * | * |
</span></span><span class="line"><span class="cl">+-|-+-|-+-|-+-|-+
</span></span><span class="line"><span class="cl">  |   |   |   |
</span></span><span class="line"><span class="cl"> &#39;d  &#39;d  &#39;d   S
</span></span></code></pre></div><p>この状態なら $O(1)$ です。
あとは操作する度にポイタが変わるので、こういう簡約をいつ行うかという問題だけです。
参照を作る度に神経質にやってては遅そうです。読み取るときに参照を辿っていく道すがらにあるポインタを変換するのがよくある手法らしいです。
しかし今回はRustを使うので、読み取り操作で値を書き換えるのはできるだけ避けたいです。ということで私の実装はユニフィケーションを呼んだときについでに簡約することになってます。
私の実装とは違いますが道すがらのポインタをまとめて最短のポインタに変換する最適化を入れれば全体としては $O(1)$ に近いくらいの速度で動くんじゃないかなと思ってます。</p>
<h1 id="実装">実装</h1>
<p>それでは実装していきましょう。
というか、私が<a href="https://github.com/KeenS/webml">開発中のコンパイラ</a>でのコードを紹介していきましょう。
Rustで書いているStandard MLのコンパイラです。</p>
<p>全体的に、式は 型なし → 型付け中 → 型あり の2段階の変化をします。</p>
<p>最終的にはこういう型になります。
型変数は気の迷いで入ってますが今のところ多相をサポートしてないので使うと後の方で「多相はサポートしてないよ」のエラーが出ます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Type</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Variable</span><span class="p">(</span><span class="kt">u64</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Int</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Real</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Fun</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>そして型付け中の型を表わすのがこのデータ型の定義です。型付け中には変数が必要なのでこっちの変数は気の迷いじゃないです。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Typing</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Variable</span><span class="p">(</span><span class="kt">u64</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Int</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Real</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Fun</span><span class="p">(</span><span class="n">NodeId</span><span class="p">,</span><span class="w"> </span><span class="n">NodeId</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>NodeId</code> はあとで出てきますが、「型はポインタとします」といったときのポインタ相当です。 <code>Typing</code> は内部表現相当です。</p>
<p>それでは型のユニフィケーションと、制約式のユニフィケーションプールを見ていきましょう。</p>
<p>まずはユニフィケーションプールから。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">UnificationPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">pool</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">NodeId</span><span class="p">(</span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>セルの列はベクタで表現します。
セルに保持するデータは <code>Node</code> という型をあとで用意することにします。
<code>NodeId</code> は要するに先程の説明でいう「型はポインタとします」のポインタのことです。</p>
<p>セルの中の値は実際に値を持っているか、それとも別のポインタを持っているかなのでした。
それを表現するコードがこちら。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Value</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Refer</span><span class="p">(</span><span class="n">NodeId</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>この <code>T</code> には実際には型の内部表現、 <code>Typing</code> が入るのですがここでは抽象化しておきます。</p>
<p>この <code>NodeId</code> 、 <code>UnificationPool</code> 、 <code>Node</code> と先程の図による説明、対応がとれますかね？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"> &#39;a    &lt;- NodeId
</span></span><span class="line"><span class="cl">  |
</span></span><span class="line"><span class="cl">  v    ~~~~~~~
</span></span><span class="line"><span class="cl">+---+
</span></span><span class="line"><span class="cl">| * |  &lt;- UnificationPool
</span></span><span class="line"><span class="cl">+-|-+
</span></span><span class="line"><span class="cl">  |    ~~~~~~~
</span></span><span class="line"><span class="cl">  |
</span></span><span class="line"><span class="cl">V(&#34;a&#34;) &lt;- Node
</span></span></code></pre></div><p>さて、いくつかのユーティリティメソッドを生やしましょう。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Node</span>::<span class="n">Value</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">UnificationPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">pool</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[]</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">register</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">node</span>: <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">NodeId</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">pool</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">NodeId</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">pool</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">node_new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">NodeId</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// idが指しているノードを返す
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">at</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">node_id</span>: <span class="nc">NodeId</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">pool</span><span class="p">[</span><span class="n">node_id</span><span class="p">.</span><span class="mi">0</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">at_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">node_id</span>: <span class="nc">NodeId</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">pool</span><span class="p">[</span><span class="n">node_id</span><span class="p">.</span><span class="mi">0</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// idが指しているノードから辿っていって値を返す
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">value_of</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">id</span>: <span class="nc">NodeId</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Node</span>::<span class="n">Value</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Node</span>::<span class="n">Refer</span><span class="p">(</span><span class="n">new_id</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">new_id</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>これでもうユニフィケーションまであと一息です。
簡約を定義します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">UnificationPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">value_id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">id</span>: <span class="nc">NodeId</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">NodeId</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Node</span>::<span class="n">Value</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Node</span>::<span class="n">Refer</span><span class="p">(</span><span class="n">new_id</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">new_id</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">reduction</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">start</span>: <span class="nc">NodeId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 一旦値のあるノードまで辿ってIDを取得して、
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// もう一度舐めて道すがらの参照を変換していくサボり実装
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">value_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value_id</span><span class="p">(</span><span class="n">start</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">at_mut</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Node</span>::<span class="n">Value</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Node</span>::<span class="n">Refer</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="o">*</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>これでもう制約のユニフィケーションを定義できます。
今回型単体のユニフィケーションと制約式を跨いだ処理は分けて書く方針なので引数で型単体のユニフィケーション関数を受け取ります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 値なら取り出し、別セルの参照なら捨てる
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">take</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 所有権の関係でダミー用の値と差し替えることでデータを取り出す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// NodeIdはダミーになっているのでこのNodeは使えなくなっている
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span>::<span class="n">Refer</span><span class="p">(</span><span class="n">NodeId</span><span class="p">(</span><span class="n">std</span>::<span class="kt">usize</span>::<span class="n">MAX</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Node</span>::<span class="n">Value</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Node</span>::<span class="n">Refer</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">UnificationPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">try_unify_with</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">id1</span>: <span class="nc">NodeId</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">id2</span>: <span class="nc">NodeId</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 型単体のユニフィケーションは外部からもらう
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">try_unify</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">NodeId</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// それぞれの値を保持するノードのIDを取得して
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">lid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value_id</span><span class="p">(</span><span class="n">id1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value_id</span><span class="p">(</span><span class="n">id2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// それぞれの値を取り出す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">at_mut</span><span class="p">(</span><span class="n">lid</span><span class="p">).</span><span class="n">take</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">at_mut</span><span class="p">(</span><span class="n">rid</span><span class="p">).</span><span class="n">take</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 値をゆにふぁい！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// 結果が新しい値となる。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_unify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// ユニファイした左の方のノードに値を持たせる。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// これは別にどっちでもいい。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">at_mut</span><span class="p">(</span><span class="n">lid</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">Value</span><span class="p">(</span><span class="n">new</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">at_mut</span><span class="p">(</span><span class="n">rid</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">Refer</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// ついでに簡約
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">id1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">id2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">lid</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>これで制約式部分が完成です。
…といいたいところですがこのコード（<code>try_unify_with</code>）にはバグがあります。どこだか分かりますか？
関数内の2-4行目です。左右の参照先が同じ場合は最初の <code>self.at_mut(lid).take()</code> で値が無になったあと、 続く <code>self.at_mut(rid).take().unwrap()</code> が既に無になったデータを取り出そうとしてパニックになってしまいます。
正しくは2-3行目の間にガードを入れた以下のコードです。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">UnificationPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">try_unify_with</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">id1</span>: <span class="nc">NodeId</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">id2</span>: <span class="nc">NodeId</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">try_unify</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">NodeId</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">lid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value_id</span><span class="p">(</span><span class="n">id1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value_id</span><span class="p">(</span><span class="n">id2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 左右が同じ場合はもうすることがない
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">lid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rid</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">at_mut</span><span class="p">(</span><span class="n">lid</span><span class="p">).</span><span class="n">take</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">at_mut</span><span class="p">(</span><span class="n">rid</span><span class="p">).</span><span class="n">take</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_unify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">at_mut</span><span class="p">(</span><span class="n">lid</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">Value</span><span class="p">(</span><span class="n">new</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">at_mut</span><span class="p">(</span><span class="n">rid</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">Refer</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">id1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">id2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">lid</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>これで本当に制約式部分が完成です。</p>
<p>最後に型単体のユニフィケーション。
型単体のユニフィケーションの途中で変数が出てくると推移的なユニフィケーションが走るので両者は相互再帰します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">try_unify</span><span class="o">&lt;&#39;</span><span class="na">b</span><span class="p">,</span><span class="w"> </span><span class="o">&#39;</span><span class="na">r</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">pool</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">b</span> <span class="nc">mut</span><span class="w"> </span><span class="n">UnificationPool</span><span class="o">&lt;</span><span class="n">Typing</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">t1</span>: <span class="nc">Typing</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">t2</span>: <span class="nc">Typing</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;&#39;</span><span class="na">r</span><span class="p">,</span><span class="w"> </span><span class="n">Typing</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">Typing</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 両者が等価ならそれで終わり
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 片方が変数ならもうに合わせる
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">_</span><span class="p">),</span><span class="w"> </span><span class="n">ty</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">ty</span><span class="p">,</span><span class="w"> </span><span class="n">Variable</span><span class="p">(</span><span class="n">_</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">ty</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 構造的型は構造が同じ場合は構成子それぞれでゆにふぁい！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">(</span><span class="n">Fun</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">),</span><span class="w"> </span><span class="n">Fun</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pool</span><span class="p">.</span><span class="n">try_unify_with</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">try_unify</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pool</span><span class="p">.</span><span class="n">try_unify_with</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">,</span><span class="w"> </span><span class="n">try_unify</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Fun</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="sd">/// それ以外はエラー
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">        </span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">TypeError</span>::<span class="n">MisMatch</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">expected</span>: <span class="nc">conv_ty</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">actual</span>: <span class="nc">conv_ty</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>はい、これでユニフィケーションの仕組みが整いました。
これらをベースに <code>NodeId</code> 同士でユニフィケーションする <code>unify</code> メソッドを定義するのは容易いでしょう。
また、型の内部表現(= <code>Typing</code>)を受け取って、裏側で一旦 <code>UnificationPool</code> に登録して <code>NodeId</code> を取得してから別の型とユニフィケーションする関数 <code>give</code> なども簡単に書けます。</p>
<p>そこまで用意できたらあとは式にあわせて推論していくだけです。例えばApplyは以下のように書かれています。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="n">App</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ty</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">infer_expr</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">infer_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">give</span><span class="p">(</span><span class="n">fun</span><span class="p">.</span><span class="n">ty</span><span class="p">(),</span><span class="w"> </span><span class="n">Typing</span>::<span class="n">Fun</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">ty</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">ty</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>再帰的なアルゴリズムなので <code>infer_expr</code> を再帰呼び出してます。
制約式に順序はないので <code>self.give</code> と <code>self.infer_expr</code> の順序は（多分）どうでもいいですが、なんとなくこの順番で呼んでます。</p>
<p>さて、最終的に型付けが終わったら <code>Typing</code> から <code>Type</code> に変換します。
これはプールから取得していくだけなので簡単ですね。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">resolve</span><span class="p">(</span><span class="n">pool</span>: <span class="kp">&amp;</span><span class="nc">UnificationPool</span><span class="o">&lt;</span><span class="n">Typing</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">id</span>: <span class="nc">NodeId</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Type</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">conv_ty</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">pool</span><span class="p">.</span><span class="n">value_of</span><span class="p">(</span><span class="n">id</span><span class="p">).</span><span class="n">clone</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">conv_ty</span><span class="p">(</span><span class="n">pool</span>: <span class="kp">&amp;</span><span class="nc">UnificationPool</span><span class="o">&lt;</span><span class="n">Typing</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">ty</span>: <span class="nc">Typing</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Type</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">Typing</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Variable</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Type</span>::<span class="n">Variable</span><span class="p">(</span><span class="n">id</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Int</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Type</span>::<span class="n">Int</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Real</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Type</span>::<span class="n">Real</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Fun</span><span class="p">(</span><span class="n">param</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Type</span>::<span class="n">Fun</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">resolve</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="p">)),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">resolve</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">)),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>ということで型推論のコードの紹介は断片的でしたが腕力で実装したユニフィケーションの実装でした。</p>
<h1 id="ノート">ノート</h1>
<ul>
<li>既存のアルゴリズムを（うっすらとは知ってますが）一切ちゃんと調べずに書いたコードなので間違ってる可能性もあります。</li>
<li>このコードを書こうと思ったのは「型推論って<a href="https://ja.wikipedia.org/wiki/%E7%B4%A0%E9%9B%86%E5%90%88%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0">Union-Find木（森）</a>の挙動に似てない？」と思ったからです。
途中で簡約とか計算量の話がでてきたのはそのためです。
<ul>
<li>真面目に分析してませんが、「ユニフィケーションするときにノードの大きい方を根にする」「ノードから値を読み出すときに毎度簡約する」をちゃんとやればUnion-Find木と同じく $O(α(n))$ （ $α(n)$ はアッカーマン関数の逆関数）になるんじゃないかと思ってますが定かではないです。$α(n)$ は実用の範囲ではほぼ定数なので 「$O(1)$ に近いくらいの速度」と言った訳です。</li>
</ul>
</li>
<li>実装してる途中で「これ、Prologの実装ってこんな感じじゃなかったっけ？」という気持になりました。まあ、当たり前っちゃあたりまえなんですけど。</li>
</ul>
<h1 id="おまけ-オーバーロードのサポート">おまけ: オーバーロードのサポート</h1>
<p>SMLには困った仕様としてオーバーロードがあります。
組み込み関数 <code>+</code> はオーバーロードされているので <code>int</code> にも <code>real</code> にも使えます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">- 1 + 1;
</span></span><span class="line"><span class="cl">val it = 2 : int
</span></span><span class="line"><span class="cl">- 1.1 + 1.0;
</span></span><span class="line"><span class="cl">val it = 2.1 : real
</span></span></code></pre></div><p>しかし型システム上はオーバーロードは存在しないので「<code>+</code> は <code>int</code> にも <code>real</code> にも使えるけど、どっちかに決まらなかったら <code>int</code> 決め打ちになる」という仕様があります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">(* x + y では型が決まらないのでintにフォールバックする *)
</span></span><span class="line"><span class="cl">- fun add x y = x + y;
</span></span><span class="line"><span class="cl">val add = fn : int -&gt; int -&gt; int
</span></span><span class="line"><span class="cl">(* なんなら単体でも型は決まらない *)
</span></span><span class="line"><span class="cl">- op+;
</span></span><span class="line"><span class="cl">val it = fn : int * int -&gt; int
</span></span></code></pre></div><p>しかし型推論は式全体全体を見てくれるので局所的に型が分からなくても全体で定まっていれば <code>real</code> にも推論してくれます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">- fun add x y = x + y + 0.0;
</span></span><span class="line"><span class="cl">val add = fn : real -&gt; real -&gt; real
</span></span></code></pre></div><p>この対応面倒ですね。Prolog風にバックトラックを実装しようかとも思いましたが <code>+</code> が連鎖すると多分死ぬのでやめました。</p>
<p>面倒なのでやっつけで実装します。
こいつは <code>Typing</code> に数値演算向けのオーバーロードされた型を入れておきます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Typing</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">OverloadedArith</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>これのユニフィケーション規則はこう。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">(</span><span class="n">Int</span><span class="p">,</span><span class="w"> </span><span class="n">OverloadedArith</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">OverloadedArith</span><span class="p">,</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Int</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">overloadedarith</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">overloadedarith</span><span class="p">,</span><span class="w"> </span><span class="n">real</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ok</span><span class="p">(</span><span class="n">real</span><span class="p">),</span><span class="w">
</span></span></span></code></pre></div><p>もちろん、数値演算は <code>OverloadedArith</code> として推論されます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="n">BinOp</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">ty</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;+&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;-&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;*&#34;</span><span class="p">].</span><span class="n">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">.</span><span class="mf">0.</span><span class="n">as_str</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">infer_expr</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">infer_expr</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">unify</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">ty</span><span class="p">(),</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">ty</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">unify</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">ty</span><span class="p">(),</span><span class="w"> </span><span class="n">overloaded_arith</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">unify</span><span class="p">(</span><span class="o">*</span><span class="n">ty</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">ty</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>最終的に <code>Typing</code> から <code>Type</code> に変換するところで、オーバーロードが残ったままだったら <code>Int</code> にフォールバックするという処理を加えます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">conv_ty</span><span class="p">(</span><span class="n">pool</span>: <span class="kp">&amp;</span><span class="nc">UnificationPool</span><span class="o">&lt;</span><span class="n">Typing</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">ty</span>: <span class="nc">Typing</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Type</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">Typing</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">OverloadedArith</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Type</span>::<span class="n">Int</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>今のところこれで動いてるみたいです。</p>
<p>ちゃんとやるならオーバーロードには型の集合を定義して、ユニフィケーションのときは交差集合をとって…と実装することになるでしょうが、そもそも仕様がやっつけ感あるのでこのくらいで十分でしょう。</p>
                    </section>
                </article>
            </div>
        </div>

        <div class="row li-author">
    <div class="sixteen columns">
        Written by <strong>κeen</strong>
    </div>
</div>


        <div class="row li-pagination">
            <div class="eight columns">
                <div class="li-pagination-previous">
                    
                        Later article<br />
                        <a href="https://KeenS.github.io/slide/wadainoguitsu_rukittoorbtkwoyomu/"> 話題のGUIツールキットOrbtkを読む</a>
                    
                </div>
            </div>
            <div class="eight columns">
                <div class="li-pagination-next">
                    
                        Older article<br />
                        <a href="https://KeenS.github.io/blog/2019/12/07/rustdecpshenkangakantanninattayotoiuhanashi/"> RustでCPS変換が簡単になったよという話</a>
                    
                </div>
            </div>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2023. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="https://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>

