<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Slide-rsses on κeenのHappy Hacκing Blog</title>
    <link>/slide/index.xml</link>
    <description>Recent content in Slide-rsses on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 20 Nov 2016 14:08:07 +0900</lastBuildDate>
    <atom:link href="/slide/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rustの話とリソースの話</title>
      <link>/slide/Rustnohanashitoriso_sunohanashi/</link>
      <pubDate>Sun, 20 Nov 2016 14:08:07 +0900</pubDate>
      
      <guid>/slide/Rustnohanashitoriso_sunohanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustの話とリソースの話
----------------------
[RustのLT会！ Rust入門者の集い](https://rust.connpass.com/event/41467/)  
2016-11-21

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 若者
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます
 * [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)の翻訳
 * [Join rust-jp on Slack!](http://rust-jp.herokuapp.com/) にもいます。
 * [Rust その2 Advent Calendar 2016 - Qiita](http://qiita.com/advent-calendar/2016/rust-lang-2)

===

# 注意
------

* たまにマニアックな話が出ますが気にせず無視して下さい
* 「なんかRustすげー」って思ってもらえれば幸いです


===

# Rustとの出会い
----------------

* 元々Lisperだった
* 他にはML, Ruby, JVM言語など

===

![lis books](/images/rust-and-resource/lisp.jpg)&lt;!-- .element: height=&#34;640px&#34; --&gt;

===

&lt;span style=&#34;font-size: 150%&#34;&gt;「Lisperは自分で処理系作って一人前」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![compiler books](/images/rust-and-resource/compiler.jpg) &lt;!-- .element: height=&#34;640px&#34;&#34; --&gt;

===

# 苦悩
-------

* Cは低級すぎる
* Javaは向いてない
* C++は怖そう
  + 闇の軍団
  + 縄文土器飛んできそう
  + あと **nullあるしメモリ破壊あるし**
* MLは向いてるけどシステムプログラミングしづらい
* ATS2, Golang, D...

===

# Rustと出会う
----------------

* 正直最初は色物言語と思ってた
* 調べてみたら気に入った

===

# ゼロコスト抽象化
----------------------------

``` rust
fn sum_pos(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    v.iter().filter(|i| **i &gt; 0).sum()
```

===

高階関数が消えた…！？

``` asm
_ZN21higher_order_function7sum_pos17h2f9de4f69306ec0aE:
	.cfi_startproc
	movq	(%rdi), %rcx
	movq	16(%rdi), %rax
	leaq	(%rcx,%rax,4), %rdx
	xorl	%eax, %eax
	jmp	.LBB0_1
.LBB0_3:
	addl	%esi, %eax
	.p2align	4, 0x90
.LBB0_1:
	cmpq	%rcx, %rdx
	je	.LBB0_4
	movl	(%rcx), %esi
	addq	$4, %rcx
	testl	%esi, %esi
	jle	.LBB0_1
	jmp	.LBB0_3
.LBB0_4:
	retq
```

===


# スタックとヒープ
------------------


* Rustは手で割り当てを変えられる
* 「ヒープを使ったら負け」ゲームが出来る
* ループの中でヒープアロケートしたくないよね

===

# マクロとコンパイラプラグイン
-----------------------------

例えば正規表現リテラルを作れるか、とか。

1. Common Lisp
2. 衛生的マクロ + 手続的マクロ &lt;- Rust
2. 衛生的マクロ + コンパイラプラグイン &lt;- Rust
3. 手続的マクロ
4. コンパイラプラグイン
4. 衛生的マクロ

===

# トレイト
----------

* 型クラス
  + 継承を駆逐する
  + MLにも欲しい超便利機能
* 関連型
  + 表現力が高いことが知られている
  + CF [Rustの型レベルLispっぽいの作った | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/11/06/rustnokatareberulispppoinotsukutta/)

===

# パターンマッチ、代数的データ型
-------------------------------

* 便利ってかないと困る

``` rust
    match expr {
        &amp;Expr::Nil |
        &amp;Expr::EOF |
        &amp;Expr::Str(_) |
        &amp;Expr::Int(_) |
        &amp;Expr::Float(_) |
        &amp;Expr::Proc(_) =&gt; Ok(expr.clone()),
        &amp;Expr::Sym(ref name) =&gt; {
            match env.find(&amp;name.to_owned()) {
                Ok(v) =&gt; Ok(v.clone()),
                Err(m) =&gt; {
                    if name.deref() == &#34;t&#34; {
                        Ok(ksym(&#34;t&#34;))
                    } else {
                        Err(m)
                    }
                }
            }
        }
        &amp;Expr::Cons(ref car, ref cdr) =&gt; {
        ....
```


===

# C インターフェース
---------------------

* C FFI, C API共に1行
* 構造体なんかも互換

``` rust
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}
```

``` rust
#[no_mangle]
pub extern fn hello_rust() -&gt; *const u8 {
    &#34;Hello, world!\0&#34;.as_ptr()
}
```


===

# ランタイムなし
---------------

* [RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/)
* [Writing an OS in Rust](http://os.phil-opp.com/)
* [Redox - Your Next(Gen) OS](http://www.redox-os.org/)

===

# 生ポインタ
------------

* Cとのやりとりで大事
* あるいはパフォーマンスチューニングに

``` rust
pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}
```

``` rust
unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Vec&lt;T&gt;
```


===

# エラー処理
------------

* 例外じゃない
* [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html)
* `?` (元 `try!`)も便利
* Erro as a data
* 巻き戻し例外って扱い難しいよね
  + 値継続と例外継続の使い分けつらい

===

# リソースの話（本題）
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# リソースの重要性
-------------------

* プログラムはIOの塊、すなわりリソースの塊
* 従来は手動で管理するかGCで管理するかしていた
* RustはGCを使わず自動で管理する
* 所有権の概念が「ただの自動」以上に便利

===

# メモリ管理
------------

* Cでいう`free`を自動で挟んでくれる
* 基本

===

# Vecとslice
-------------

* sliceを`Vec`のviewとして使える
  + zero copy
  + 例えばJavaとかだと出来ない
* zero copy parserとかも書ける

===

# `File` 、 `Lock`
------------------

* `Drop`があるので自動
* ところでGCがあるのに手動で管理する言語があるらしいですね
  + 例えばRubyの`File.open(..) do ... end` も半手動
  + GCで処理すべきなのに手で`do ... end`を書いてる

===

# Rust
-------

``` rust
let file = File::open(&#34;text.txs&#34;).unwrap();
let mut br = BufReader::new(file);
...
```


===

# Java
-------
※try-with-resourceを使うともっと簡単に書けます。極端な比較のためにこう書いてます

``` java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader(&#34;test.txt&#34;));
    ...
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (br != null)
        try {
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
}
```

===

# Use after close
------------------

* プログラミングエラーの一種
* あらゆるリソースで起きうる
* GCのある言語ではメモリでのエラー **のみ** 防げる
* 他のリソースだとダメ
* Rustは **全ての** リソースで防げる

===

# Ruby
------

``` ruby
file = nil
File.open(&#34;file.rb&#34;) do |f|
  file = f
end
puts file.read

```

```
#&lt;File:file.rb (closed)&gt;
file.rb:6:in `read&#39;: closed stream (IOError)
        from file.rb:6:in `&lt;main&gt;&#39;
```


===

# Rust
-------

* 所有権のある限り勝手に`close`されない

``` rust
let mut file = None;
{
  let f = File::open(&#34;file.rs&#34;).unwrap();
  file = Some(f);
}
let mut s = String::new();
file.unwrap().read_to_string(&amp;mut s).unwrap();
println!(&#34;{}&#34;, s);
```

===

# Use  wrapped object
---------------------------

* 所有権便利って話

===

# Java
------

``` scala
val kc = new KafkaProducer(...)
val sk = new SimpleKafkaClient(kc)
kc.close // &lt;- !?!?!?
...
```

===

# Rust
-------

``` rust
let kc = KafkaClient(...);
val mut sk = SimpleKafkaClient(kc);
kc.close(); // &lt;- Compile error because kc has been moved
```

===

# まとめ
--------

* Rust = 便利機能詰め合わせ + 所有権
* さらにランタイムもないしCとの相互連携も出来る
* リソース管理って大事
* 所有権は制限だけじゃないよ



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Scala 2.12.0変更点</title>
      <link>/slide/Scala_2_12_0henkouten/</link>
      <pubDate>Fri, 04 Nov 2016 13:19:01 +0900</pubDate>
      
      <guid>/slide/Scala_2_12_0henkouten/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Scala 2.12.0変更点
----------------------
サイバーエージェント ScalaMeetUp

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * AI Studio Dev Group
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# サマリー
----------
全部[公式ページ](http://www.scala-lang.org/news/2.12.0)に詳細あるよ

* Java8向けの互換性向上したよ
  + トレイトがinterfaceに
  + 無名関数がlambdaに
  + SAMとScalaの関数が統合
* コンパイラが少し賢くなったよ
  + いくつかでinvokedynamicを使うように
  + 中間状態をやめた
  + 最適化をするように
* ライブラリ改善した
  + EitherがRight Biasedに
  + Futureが強化
* 非互換いくつか


===

# トレイトがinterfaceに
-----------------------

``` scala
trait Foo {
  def foo(): String = &#34;foo&#34;
  def bar(): String
}
```

===

# トレイトがinterfaceに
-----------------------


```
$ scalac-2.11 Trait.scala
$ ls
Foo$class.class  Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public interface Foo {
  public abstract java.lang.String foo();
  public abstract java.lang.String bar();
}
$ javap &#39;Foo$class&#39;
Compiled from &#34;Trait.scala&#34;
public abstract class Foo$class {
  public static java.lang.String foo(Foo);
  public static void $init$(Foo);
}

```

===

# トレイトがinterfaceに
-----------------------

```
$ scalac-2.12 Trait.scala
$ ls
Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public interface Foo {
  public static java.lang.String foo$(Foo);
  public java.lang.String foo();
  public abstract java.lang.String bar();
  public static void $init$(Foo);

```

===

# 無名関数がlambdaに
-----------------------

```
class Foo {
  val f = () =&gt; &#34;string&#34;
}
```

===

# 無名関数がlambdaに
-----------------------


```
$ scalac-2.11 Trait.scala
$ ls
Foo$$anonfun$1.class  Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  public scala.Function0&lt;java.lang.String&gt; f();
  public Foo();
}
$ javap  &#39;Foo$$anonfun$1
Compiled from &#34;Trait.scala&#34;
public final class Foo$$anonfun$1 extends scala.runtime.AbstractFunction0&lt;java.lang.String&gt; implements scala.Serializable {
  public static final long serialVersionUID;
  public final java.lang.String apply();
  public final java.lang.Object apply();
  public Foo$$anonfun$1(Foo);
}

```

===

# 無名関数がlambdaに
-----------------------

```
$ scalac-2.12 Trait.scala
$ ls
Foo.class  Trait.scala
$ javap -p Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  private final scala.Function0&lt;java.lang.String&gt; f;
  public scala.Function0&lt;java.lang.String&gt; f();
  public static final java.lang.String $anonfun$f$1();
  public Foo();
  private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda);
$ javap -c -p Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  private final scala.Function0&lt;java.lang.String&gt; f;

  public scala.Function0&lt;java.lang.String&gt; f();
    Code:
       0: aload_0
       1: getfield      #19                 // Field f:Lscala/Function0;
       4: areturn

  public static final java.lang.String $anonfun$f$1();
    Code:
       0: ldc           #25                 // String string
       2: areturn

  public Foo();
    Code:
       0: aload_0
       1: invokespecial #29                 // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
       4: aload_0
       5: invokedynamic #49,  0             // InvokeDynamic #0:apply:()Lscala/Function0;
      10: putfield      #19                 // Field f:Lscala/Function0;
      13: return

  private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda);
    Code:
       0: aload_0
       1: invokedynamic #61,  0             // InvokeDynamic #1:lambdaDeserialize:(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;
       6: areturn
}
```

===

# SAMとScalaの関数が統合
-----------------------

関数をSingle Abstract Methodに出来る

```
scala&gt; val runRunnable: Runnable = () =&gt; println(&#34;Run!&#34;)
runRunnable: Runnable = $$Lambda$1073/754978432@7cf283e1
scala&gt; runRunnable.run()
Run!
```

JavaでLambdaが期待される箇所にScalaの無名関数を書ける

===

# SAMとScalaの関数が統合
-----------------------

逆に、JavaのLambdaでScalaの関数を作れる

```
public class A {
  scala.Function1&lt;String, String&gt; f = s -&gt; s.trim();
}
```

===

# 最適化
--------
とりあえずDead Code Elimination

```
class Foo {
  def add1(i: Int) = {
    val unused = 1 + i
    1 + i
  }

}

```

===

# 最適化
--------

```
$ scalac Trait.java
$ javap -c Foo
...
  public int add1(int);
    Code:
       0: iconst_1
       1: iload_1
       2: iadd
       3: istore_2
       4: iconst_1
       5: iload_1
       6: iadd
       7: ireturn
...
}

```

===

# 最適化
--------

```
$ scalac -opt:l:method Trait.java
$ javap -c Foo
...
  public int add1(int);
    Code:
       0: iconst_1
       1: iload_1
       2: iadd
       3: ireturn
...
```

===

# 非互換
--------

* Object initialization locks and lambdas
  + 無名関数が元のクラスのメソッドになったので変にデッドロックするかも
* Lambdas capturing outer instances
  + 無名関数が元のクラスのメソッドになったのでスコープが少し変わる
  + シリアライズに影響出るかも
* SAM conversion precedes implicits
  + SAM conversionとimplicit comversionだとSAMが優先される

===

# 非互換
--------

* SAM conversion in overloading resolution
  + なんか型が面倒になった
* Inferred types for fields
  + なんかよく分かんなかった
* Changed syntax trees (affects macro and compiler plugin authors)
  + 変わったらしい

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>正しいScalaのコードが欲しい</title>
      <link>/slide/tadashiiScalanoko_dogahoshii/</link>
      <pubDate>Wed, 05 Oct 2016 00:10:25 +0900</pubDate>
      
      <guid>/slide/tadashiiScalanoko_dogahoshii/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 正しいScalaのコードが欲しい
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
   + Scalaはあんまり
===
# Scalaを始めたばかりの頃の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===


``` scala
def revappend[A](
    xs: List[A],
    ys: List[A]): List[A] = match xs {
  case Nil =&gt; Nil
  case x::xs_ =&gt; revappend(xs_, x::ys)
}
```

===

``` scala
def length(xs: List[_]): Int = xs match {
  case Nil =&gt; Nil
  case x::xs_ =&gt; 1 + length(xs_)
}
```

===

``` scala
def append[A](
    xs: List[A],
    ys: List[A]): List[A] = xs match {
  case Nil =&gt; Nil
  case x::xs_ =&gt; x :: append(xs_, ys)
}

append(List(1, 2, 3), List(4, 5, 6))
// =&gt; List(1, 2, 3)

```

===
# Scalaを始めたばかりの頃の話
-----------------------------

* 正しくないコードばかり書いてしまう
  + 他の言語の構文と混ぜてしまう
  + 型エラー
  + 実装ミス
* 正しいScalaのコードが欲しい

===
# 正しさって？
-------------

* 構文が正しいコード?
* コンパイルが通るコード?
* バグのないコード？
  + テストが通るコード?

===
# 正しさって？
-----------

* 数学だったら？
* 数学なら証明されれば正しい
* プログラムの証明????

===
# Isabelle
----------

* 汎用証明支援系
* [Isabelle](https://isabelle.in.tum.de/)
* 結構昔からある
* 関数型言語 + 高階論理

===
# コード
--------

``` isabelle
datatype &#39;a list = Nil                 (&#34;[]&#34;)
  | Cons &#39;a &#34;&#39;a list&#34;    (infixr &#34;#&#34; 65)

primrec app :: &#34;&#39;a list =&gt; &#39;a list =&gt; &#39;a list&#34; (infixr &#34;@&#34; 65)
  where
  &#34;[] @ ys      = ys&#34; |
  &#34;(x # xs) @ ys = x # (xs @ ys)&#34;
```

===

# 証明
------

``` isabelle
lemma app_Nil2 [simp]: &#34;xs @ [] = xs&#34;
  apply(induct_tac xs)
  apply auto
  done

lemma app_assoc [simp]: &#34;(xs @ ys) @ zs = xs @ (ys @ zs)&#34;
  apply (induct_tac xs)
  apply auto
  done
```

===
# Extract
---------

```isabelle
export_code append
   in Scala
   module_name &#34;Example&#34;
   file &#34;Example.scala&#34;
```

===
# Scalaのコード
---------------

証明されたScalaのコードが手に入る

``` scala
object Example {

abstract sealed class list[A]
final case class Nila[A]() extends list[A]
final case class Cons[A](a: A, b: list[A]) extends list[A]

def append[A](x0: list[A], ys: list[A]): list[A] = (x0, ys) match {
  case (Nila(), ys) =&gt; ys
  case (Cons(x, xs), ys) =&gt; Cons[A](x, append[A](xs, ys))
}

} /* object Example */

```

===
# 余談
-------

他の言語にもextract出来る

```isabelle
export_code append
   in SML
   module_name &#34;Example&#34;
   file &#34;Example.sml&#34;
```


===
# まとめ
---------

* プログラムは証明出来るよ
* Isabelleで証明が出来るよ
* Isabelleで証明したら正しいScalaのコードが手に入るよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>型クラスを越えて</title>
      <link>/slide/katakurasuwokoete/</link>
      <pubDate>Sat, 16 Jul 2016 02:53:49 +0900</pubDate>
      
      <guid>/slide/katakurasuwokoete/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 型クラスを越えて
----------------------
[歌舞伎座.tech#10「型クラス勉強会」](http://kbkz.connpass.com/event/32420/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# Rustとは
----------

* システムプログラミング言語
* GCなし！でもメモリ管理は自動
* **Zero-Cost Abstraction**
* **Trait-Based Generics**
* パターンマッチ、代数的データ型などなど
* [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/README.html)

===
# Rustのトレイト的なの
----------------

* 型に固有のメソッド
  + オブジェクト指向的な
* トレイト
  + 型クラス

===
# 型クラスじゃない方
-------------------

``` rust
struct Person {
  name: String,
}
impl Person {
  // Static constructor
  fn new(name: String) -&gt; Self {
    Person{name: name}
  }

  // method
  fn hello(&amp;self) {
    println!(&#34;Hello, {}&#34;, self.name);
  }
}
```

===
``` rust
let person = Person::new(&#34;κeen&#34;);
person.hello();
```

===
# 多相型と制約
--------------

``` rust
struct Temp&lt;T&gt;(T);

impl &lt;T: Celsius&gt; Temp&lt;T&gt; {
  fn fromCelsius(t: isize) -&gt; Self {
    Temp(Celsius(t))
  }
}

impl &lt;T: Fahrenheit&gt; Temp&lt;T&gt; {
  fn fromFahrenheit(t: isize) -&gt; Self {
    Temp(Fahrenheit(t))
  }
}

```

===
# 型クラス
---------

* 便利
* 他の言語にも取り入れてほしい
* 型クラスを入れることで言語設計がどうなるか
* ユーザランドより言語機能的な部分フォーカス

===
# Rustの型クラスの実装
---------------------

* 動的ディスパッチと静的ディスパッチ両方がある
* 動的ディスパッチ
  + implicit parameterを渡すやつ
* 静的ディスパッチ
  + コンパイル時に解決してしまうやつ
* デフォフォルト静的
  + 動的を選ぶことも出来る

===
# 静的ディスパッチの意味
-----------------------

* Zero-Cost Abstraction
* ユーザはパフォーマンスのために設計を曲げる必要がなくなる
* インライン化などの最適化も出来る
* 逆の見方をすればZero-Cost Abstraction出来るからシステムプログラミング言語に高級な機能を入れれた

===
# 型クラス+α
-----------
それぞれ面白い特徴が。

* `FromStr`
* `Write`
* `Add`
* `Default`, `Zero`
* `Iterator`

===
# 型クラス+関数
--------------

* 関連関数
* `FromStr`
* static関数的なものになる

```rust
pub trait FromStr {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
```

===
``` rust
use std::str::FromStr;

let s = &#34;5&#34;;
let x = i32::from_str(s).unwrap();

assert_eq!(5, x);
```

===
# 型クラス+構文
--------------

* = メソッド
* 第一引数が `self` な関数はメソッド構文で呼び出せる
* クラスがなくても継承がなくてもオブジェクト指向
* `Write`

``` rust
trait Write {
  fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
}
```

===
``` rust
impl Write for Foo {
  fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt; {
    ...
  }
}

let foo = Foo::new();
foo.write(aa);
```

===
# 型クラス+UFCS
---------------

* = 実質オーバーロード
* 中身の違うメソッドを複数定義出来る
* どのメソッドを呼ぶかを決定する構文がある
  + = Universal Function Call Syntax

===
```rust
trait Foo {
    fn foo() -&gt; i32;
}

struct Bar;

impl Bar {
    fn foo() -&gt; i32 {
        20
    }
}

impl Foo for Bar {
    fn foo() -&gt; i32 {
        10
    }
}

```
===

```rust
&lt;Bar as Foo&gt;::foo();
Bar::foo();
```


===
# 型クラス+演算子
-----------------

* = 演算子オーバーロード
* `Add`

``` rust
pub trait Add&lt;RHS = Self&gt; {
    type Output;
    fn add(self, rhs: RHS) -&gt; Self::Output;
}
```

===

``` rust
use std::ops::Add;

struct Foo;

impl Add for Foo {
    type Output = Foo;

    fn add(self, _rhs: Foo) -&gt; Foo {
        println!(&#34;Adding!&#34;);
        self
    }
}

fn main() {
    Foo + Foo;
}
```
===
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;for (my_int i = 0; i &amp;lt; 10; i++) { … }&lt;br&gt;&lt;br&gt;Cならどういうアセンブリに落ちるかすぐわかるけどC++ならmy_intはクラスかもしれず=0はコンストラクタを起動し&amp;lt;はメソッド呼び出しになり++はejectを発行して光学ディスクトレイが開き相手は死ぬ&lt;/p&gt;&amp;mdash; わさびず &lt;a href=&#34;https://twitter.com/___yuni/status/681891856335032320&#34;&gt;2015年12月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 型クラス+値
-------------

* = 関連定数
* unstable...
* `Zero`, `Default`

``` rust
// current
pub trait Zero {
    fn zero() -&gt; Self;
}
```

``` rust
// ideal
#![feature(associated_consts)]
pub trait Zero {
    const ZERO: Self;
}
```

===
```rust
trait Monoid: Add&lt;Self&gt; + Zero
  where Self::Output : Add&lt;Self&gt; + Zero {
}

```

===
# 型クラス+型
-------------

* 関連型
* 型族…？
  + あまり違いを分かっていない
  + 関連型を持った型をまとめたのが型族？
* `Iterator`

```rust
pub trait Iterator {
  type Item;
  ....
}
```

===
``` rust
trait Iterator {
  ...
  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
```

===
# 型クラス+暗黙のルール
---------------------

* オーバーライド
* `Drop`
  + 暗黙に呼ばれるデストラクタをオーバーライド出来る

```rust
pub trait Drop {
    fn drop(&amp;mut self);
}
```

===
``` rust
impl Drop for Lock {
    fn drop(&amp;mut self) {
        self.free();
    }
}
```

===
# 型クラス+アノテーション
------------------------

* 単純に便利
* `derive`(`Debug` , `Eq`)

``` rust
#[derive(Debug, Eq)]
struct Foo(usize);
```

===

``` rust
let foo1 = Foo(1);
let foo2 = Foo(2);
println!(&#34;{:?} == {:?} ?: {:?}&#34;,
         foo1,
         foo2,
         foo1 == foo2);
```

===
# まとめ
--------

* 型クラスは便利だよ
* 型クラスの実装は効率的に出来るよ
* 型クラスを使うと言語設計も変わるよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Socket on SML#</title>
      <link>/slide/Socket_on_SML_/</link>
      <pubDate>Sat, 02 Jul 2016 15:25:24 +0900</pubDate>
      
      <guid>/slide/Socket_on_SML_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Socket on SML&amp;#x23;
----------------------
[ML勉強会](http://connpass.com/event/32752/) 2016-07-09

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# HTTP on SML&amp;#x23;?
-------------

* SML#にJSONサポートが入った
  + REST API簡単に叩けるのでは？
* SML#にFully Concurrent GCが入った
  + HTTPサーバ書くとレイテンシ抑えられて嬉しいのでは？
  * スレッドも使えるしスループットも高い筈
* SML#でHTTPの機運
* しかしHTTPサポートはないので自前実装するしかない

===
# Socket on SML&amp;#x23;?
------------------

* HTTPサポートに必要
* Basisにはある (Optional)
  + SML#のBasisはサポートしてない
* FFIあるしユーザランドで実装するか
* [KeenS/SmlSharpSocketSupport](https://github.com/KeenS/SmlSharpSocketSupport)

===
# TCP/IP、ソケットなど
---------------------------

* ソケットアドレス - 自分、相手の居場所。これがないと通信出来ない
  + 複数のアドレスファミリ(AF)がある
  + IP v4, IP v6, UNIXドメインなど。
* ソケット - 通信の仕組み。プログラムからはfdとして見える。
  + AFやtype(stream/diagram)の属性を持つ
* INet - インターネットドメインソケット
  + TCPとUDP
  + IP v4/v6アドレスで通信

===
# 主要なstructure
-----------------

* Socket
* NetHostDB
* INetSock
* (UnixSock)

===
# [NetHostDB](http://sml-family.org/Basis/net-host-db.html#SIG:NET_HOST_DB)
-----------

* ドメイン名からIPアドレスを調べたり逆をやったり
* Cの古い(現在では非推奨な)APIに合わせた設計
  + IPがv4/v6が混じることを考慮してない
  + 非推奨どころか脆弱性もあったり CF [glibc の脆弱性 CVE-2015-0235（通称：GHOST）についてまとめてみた - piyolog](http://d.hatena.ne.jp/Kango/20150128/1422409960)
* 新しいAPIで実装するのが面倒

===
# [Socket](http://sml-family.org/Basis/socket.html#SIG:SOCKET.accept:VAL:SPEC)
---------

* まあまあでかいけどsend/receive関数の変種が一杯あるだけ
* ドメインに依らないソケット操作
* typeには依る
  + stream socketとdgramソケットで送受信関数が別

===
# Socket.AF
------------

* ソケットのアドレスファミリ関連
* 仕様では具体的なファミリを定義しない

===
# Socket.SOCK
-------------

* ソケットにも種類がある
  + stream/diagram
* さらにstreamにはactive/passiveがある
* それらの型。

===
# [INetSock](http://sml-family.org/Basis/inet-sock.html#INetSock:STR:SPEC)
--------------

* IP - TCP/UDPのソケットを作る/操作するやつ。
* ここの関数はインターネットドメインソケットしか受け付けない

===
# Socketについて整理
----------------

* sockにはtypeとafの属性がある
* afは色々ある
* typeはstreamとdgramがある
* streamにはさらにactiveとpassiveがある
* 特定のaf, 特定のtypeしか受け付けない関数がある

===
# Socketについて整理
----------------

```
   (AF_UN)
        v
     [unix sock]...
         |                       (Active)
[socket]-+           [TCP(stream)]-+
         |             |         (Passive)
     [inet/inet6 sock]-+
        ^              |
   (AF_INET/INET6)   [UDP(dgram)]
```

===
&lt;span style=&#34;font-size:500%;&#34;&gt;幽霊型&lt;/sapn&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# Socketの幽霊型
---------------

```sml
type (&#39;af,&#39;sock_type) sock
type &#39;af sock_addr
type dgram
type &#39;mode stream
type passive
type active
```
===
# サーバのSocket操作(stream)
---------------------------

* INetSock(UnixSock)でソケットを作る(af, sock typeの選択, プロセス側の準備)
* bindでソケットをsock_addrにバインドする(アドレスの割り当て)
* listenでソケットの特定のポートを開ける(TCPの開始)
  + passive streamしか受け付けない
* acceptでクライアントからの入力を受け付ける(接続)
  + passive streamしか受け付けない
  + passive streamがactive streamになる
  + 一度acceptしたsockはlisten/accept出来ない
===
# データの送受信
---------------

* `send` / `recv`
* それぞれArraySlice/VectorSliceの制御フラグ有り/無しがある
  + 実装がまあまあ面倒

===
# SML# でのバインディング
------------------------

* sock - fd = int
* sock_addr - AFによってサイズが違う。ヤバい。
 + 任意のsock_addrを格納出来るsockaddr_storageを使う
 + Solarisだとsockaddr_unを格納出来ないらしい（任意のaddrを格納出来るとは）
   - SML#はSolarisでは動かないので問題ない。
* AF_* とか - Cではただのint。SML#は関数しかインポート出来ない。
 + C側で定数関数でラップしてSML#で呼び出した値を束縛
* その他 - straitforward

===
# 非同期IO

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 非同期IO
----------

* HTTPサーバは複数のクライアントとのコネクションを持つ
* それらのコネクションを要領良く扱わないといけない
* 相手の処理速度や通信速度によって即座にデータを読み書き出来ない時がある
  + 勿論クライアント毎に状況が異なる
* 読み書き出来ない時にやったらブロック(CPU時間の無駄遣い)する
* 「読み書き出来るならする」/「読み書き出来るクライアントを選ぶ」APIが必要

===
# 非同期API
----------

* select - 複数のクライアントを登録して、読み書き出来るやつを選ぶ
* \*NB - 読み書き出来るならやって、出来ないならブロックせずにリターンする
* poll - selectと同じような（ちょっと速い）API。SocketではなくIOにある。
  + pollがあるのに何故Socketにselectがあるの…。

===
===
# 非同期APIのFFI
----------------

* select - Cに対応する関数が。構造体の変換でメモリアロケーションが起きて遅い
* \*NB - O_NONBLOCKを付けたsend/recv。
* poll - SML#にある

===
# 非同期HTTPサーバ概略
---------------------

```sml
bind(sock, addr);
listen(sock, port);
create_thread(n, fn i =&gt; let
  val clientList = makeClientList()
  fun loop () = let
    val clientList =
      Option.map (acceptNB(sock))
      (fn client =&gt; addReadClient clientList client)
      handle SysErr =&gt; ...
    val {rds, wds, exs} = select (makeSelectList clientList)
  in
    recvAndParseHTTPThenCallHandler clientList rds;
    sendResponse clientList wds;
    loop ()
  end
end)
```

===
# Cバインディングの憂鬱

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# importとメモリ割り当て
-----------------------

* SML#にはポインタかワードサイズ以下の値しか渡せない
  + stringとかはポインタからインポートする関数がある
  + インポートしたものはSML#のヒープに **コピーされる**
* cでポインタを返すにはmallocが必要
* **すぐコピーされてfreeされるもののためにmalloc??**
* SML#からコールバックを渡してCのスタックの変数をインポート
* CF https://github.com/KeenS/SmlSharpSocketSupport/blob/master/lib/net_host_db.c#L74

===
# メモリ管理
------------

* SML#にインポート出来る型は限られている
  + array, string
* 他の型はポインタのまま扱う。
* ポインタはGCされない
* `sockaddr` は仕様的にファイナライザを持っていない
  + 現状 **メモリリークする**
* SML#側でどうにかしてもらわないとダメ？
  + パンドラの壷(sml_alloc)使う？

===
# 型隠蔽
-------

* sockは本来はioDescに変換出来ないといけない
 + SML#でioDescはsockと同じくint
* しかし型隠蔽のせいでintをioDescに変換出来ない
* 手詰まり

===
# まとめ
--------

* socketとかその辺を解説したよ
* SML#向けにSocket関連Basisのバインディング作ってるよ
* BasisのAPI使うと非同期HTTPサーバ作れるよ
* SML#のFFIはやっぱりつらいよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>DOT/dottyについて調べてみた</title>
      <link>/slide/DOT_dottynitsuiteshirabetemita/</link>
      <pubDate>Tue, 24 May 2016 23:40:36 +0900</pubDate>
      
      <guid>/slide/DOT_dottynitsuiteshirabetemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# DOT/dottyについて調べてみた
----------------------
サイバーエージェント Scala Meet Up  
2016-05-27

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + Scala初心者
   + Scala歴1年未満&amp;gt;&amp;lt;

===
# Scalaコンパイラ
----------------

* 型推論（特にimplicit）が遅い
* コンパイルフェーズが多い
  + 中間オブジェクトが多くて遅くなる
* 多くのクラスファイルを生成する
  + コンパイラのくせにディスクIOが多い
* 気を抜いてると `Any` に推論される  
  e.g.) `if(x) 1 else &#34;a&#34;`
* そもそものScalaの設計に起因する点が多い
  + 抜本的変更が必要

===
# Scala基礎
-----------

* Scalaが成立するのに最低限必要な機能って？
  + e.g.) `case class` はなくても `class` だけでどうにかなる
* 「最低限の機能」を減らせばコンパイラがシンプルになる
  + 他の機能はただのシンタックスシュガーになる
  + コンパイラのバグを減らせる
  + 機能追加時の矛盾確認が楽
* コア言語

===
# Featherlight Scala
---------------------

* Scalaのシンタックスシュガーを減らした感じ
* 小さな言語
* 元のScalaはこれをベースに議論されてきた

===
# 形式言語理論
-------------

* 最低限必要な機能を形式的にモデル化
  + 全ての動作は予め決められた「規則」に基く
  + 実際に書いて動かすものではない
* 形式的にすることで「証明」とかが出来る
  + 「型検査に通れば実行時に型エラーが起きない」
  + 「型検査が必ず終了する」
* 逆に、「このモデルだとこの機能は実現出来ない」とかも分かる

===
# Dependent Object Type
------

* Scalaのコアをモデル化したもの（要出典）
* 形式言語
* ジェネリクスもなければクラスも継承もない、パッケージもない。
* 小さい言語ながら表現力豊か
* 全ての値はオブジェクト。
  + オブジェクトのフィールドとメソッドと型メンバーだけ
  + 型はそのまま
* Path Dependent Type
* サブタイピング


===
# About DOT
---------

* 型付の健全性が証明された
* System F&lt;:より強力
  * System F&lt;: -&gt; System D&lt;: -&gt; DOT
* existential typeを自然に表現出来る
* 交差型と合併型
  + `A extends B` -&gt; `A &amp; B`
  + 合併型は主に型推論の結果に出てくる

===
```scala
package scala.collection.immutable trait List[+A] {
  def isEmpty: Boolean; def head: A; def tail: List[A]
}
object List {
  def nil: List[Nothing] = new List[Nothing] {
    def isEmpty = true; def head = head; def tail = tail /* infinite loops */
  }
  def cons[A](hd: A, tl: List[A]) = new List[A] {
    def isEmpty = false; def head = hd; def tail = tl
  }
}
```

===
```scala
object scala_collection_immutable { sci =&gt;
  trait List { self =&gt;
    type A
    def isEmpty: Boolean
    def head: self.A def
      tail: List{type A &lt;: self.A}
  }
  def nil: sci.List{type A = Nothing} = new List{ self =&gt;
    type A = Nothing
    def isEmpty = true
    def head: A = self.head
    def tail: List{type A = Nothing} = self.tail
  }
  def cons(x: {type A})(hd: x.A)(tl: sci.List{type A &lt;: x.A})
      : sci.List{type A &lt;: x.A} = new List{ self =&gt;
    type A = x.A
    def isEmpty = false
    def head = hd
    def tail = tl
  }
}
```

===
# dotty
--------

* DOTに影響を受けたコンパイラ
* いくつかの新しい機能
  + DOTの交差型、合併型も
  + Nullable = `T | Null`
  + `if (x) 1 else &#34;a&#34;` は `Int | String` にアノテーション可能
* `forSome` が消えた
  + DOTのお陰

===
# dotty
--------

* Java8のラムダを使う
  + 生成するclassファイルの減少
* Implicitの探索アルゴリズムを改善
  + 反変implicitについても改善
* 型推論のアルゴリズムを改善
  + DOTのお陰
  + 特にサブタイピングが交差/合併型で楽に
* コンパイルパスを融合して高速化
  + 中間木がなくなってGCにやさしい
* 他にも一杯改善が

===

```scala
object DaysOfTheWeek{
  object Mon
  object Tue
  object Wed
  object Thu
  object Fri
  object Sat
  object Sun

  type Weekend = Sat.type | Sun.type
  type Workweek = Mon.type | Tue.type | Wed.type | Thu.type | Fri.type
  type All = Weekend | Workweek
}
```

===
# TASTY/Linker
--------------

* classファイルを作るとScala固有の情報が落ちる
* プログラム全体を見渡すと不要なコードとかもコンパイルしないといけない
* かといって毎回プログラム全部をコンパイルし直すのは遅い
* → TASTY。型推論後のASTをシリアライズする
  + Scalaは型推論が遅いのでそこをスキップ出来るだけでそこそこ速くなる
* classファイルを跨げるようになったのでユーザが最適化とかも書ける
* Scala/Scala.js/Scala Native共通プラットフォーム化への布石？
* どうやらclassファイルにバイトコードとTASTYを埋め込む??

===
# まとめ
--------

* Scalaの基礎にDOTがあるよ
* DOTを参考にdottyが作られたよ
* dottyで色々改善されるよ
* ついでにTASTY/Linkerについて話したよ

===
# 参考1
------

* [The Essence of Dependent Object Types](https://infoscience.epfl.ch/record/215280/files/paper_1.pdf)
* [From F to DOT: Type Soundness Proofs with Definitional Interpreters](http://arxiv.org/pdf/1510.05216v2.pdf)
* [Dependent Object Types](http://www.cs.uwm.edu/~boyland/fool2012/papers/fool2012_submission_3.pdf)
* [Why is the Scala compiler so slow? - Quora](https://www.quora.com/Why-is-the-Scala-compiler-so-slow)
* [performance - Java compile speed vs Scala compile speed - Stack Overflow](http://stackoverflow.com/questions/3490383/java-compile-speed-vs-scala-compile-speed/3612212#3612212)

===
# 参考2
-------

* [GHC doesn&#39;t do subtyping. I suspect that is the main reason why Scala is slow - ... | Hacker News](https://news.ycombinator.com/item?id=5008761)
* [A Core Calculus for Scala Type Checking](http://lampwww.epfl.ch/~odersky/papers/mfcs06.pdf)
* [namin/dot: formalization of the Dependent Object Types (DOT) calculus](https://github.com/namin/dot)
* [The DOT Calculus](http://lampwww.epfl.ch/%7Eamin/dot/current_rules.pdf)
* [Dotty: exploring the future of scala](https://d-d.me/talks/scalaworld2015/)
* [Dotty and types: the story so far](http://guillaume.martres.me/talks/typelevel-summit-oslo/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>高速な継続ライブラリに向けて</title>
      <link>/slide/kousokunakeizokuraiburarinimukete/</link>
      <pubDate>Sun, 08 May 2016 21:26:32 +0900</pubDate>
      
      <guid>/slide/kousokunakeizokuraiburarinimukete/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 高速な継続ライブラリに向けて
----------------------
[継続勉強会](http://connpass.com/event/28150/) 2016-05-22
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
===
# 継続欲しい
-----------

* 色々な場面で便利
* Schemeで使い回してるのうらやましい
* Common Lispでも使いたい
* 現実には限定継続が欲しい
  +  Common Lispには大域脱出はある

===
# 限定継続を使う例
-----------------
## 非同期プログラミング

* コールバック形式だと厳しい
* 限定継続を使うと綺麗に書き直せる

===
# 限定継続を使う例
-----------------
## ゲームのコルーチン

* 複数のオブジェクトを制御するのにコルーチンが欲しい
* cf [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)

===
# 限定継続を使う例
-----------------
## do記法

* モナドのdo記法は限定継続を使って実装出来る
* [Operational monad in scheme](http://www.slideshare.net/yuichinishiwaki/operational-monad-in-scheme)


===
# Common Lispでの限定継続の実現
---------------

1. 仕様に入れてもらう
2. 処理系に手を入れる
3. ユーザレベルで(限定)継続ライブラリを作る
   + 柔軟なCommon Lispでは可能

===
# CPS変換
---------

* (限定)継続の実現方法の1つ
  + スタックを切り取る方式とかもある
* 機械的にも出来る
* グローバルな変換なのとプリミティブな式しか書けないでコンパイラ内部でやることが多い
  + 継続関係なしに中間形式として採用されることが多い
* 関数定義/呼び出し以外にも諸々の構文とかに対しても定義が必要

===
# CPS変換
----------

Q. Common Lispだといくつの構文に対して定義が必要?

1. 1つ
2. 26つ
3. 42つ
4. 無数


===
# CPS変換
----------

A. 26つ (スペシャルフォーム25+funcall)

===
# Common Lispのプリミティブ
--------------------------

* スペシャルフォームと呼ばれる
* 仕様で25個定められている
* [CLHS: Section 3.1.2.1.2.1](http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm)
* この中に関数定義だとか例外だとかは入っていない
  + マクロで定義されている

===
# マクロ
--------

* 構文木 to 構文木(S式to S式)変換器( = 普通のLispの関数)
* 新しい構文を作れる
* CPS変換は?????

===
# `macroexpand`
-------------

* [CLHS: Function MACROEXPAND, MACROEXPAND-1](http://clhs.lisp.se/Body/f_mexp_.htm)
* マクロを手動展開する関数
* 雑にいうと普段pre-orderなマクロ展開をin-orderやpost-orderにする時に使う
* 本来はあまり使いたくない
  + 処理系の展開器に任せた方が間違いが少ない
* これでマクロを排したプリミティブのCommon Lispの構文木にアクセス出来る

===
# cl-cont
---------

* 上記のことを全てやったライブラリ
* デファクトというか唯一のライブラリ
* [Common Lispで限定継続と遊ぶ | κeenのHappy Hacκing Blog](http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/)

===
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;「shift/resetがわからない時にあげる声」&lt;/p&gt;&amp;mdash; かず(原材料に小麦粉を含む) (@kazzna) &lt;a href=&#34;https://twitter.com/kazzna/status/674026894602309632&#34;&gt;2015年12月8日&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# cl-contの使用例

``` common-lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```

===
# cl-contの使用例

``` common-lisp
(FUNCALL
 (LAMBDA (&amp;OPTIONAL #:G542 &amp;REST #:G543)
   (DECLARE (IGNORABLE #:G542))
   (DECLARE (IGNORE #:G543))
   (FUNCALL
    (LAMBDA (&amp;OPTIONAL #:G544 &amp;REST #:G545)
      (DECLARE (IGNORABLE #:G544))
      (DECLARE (IGNORE #:G545))
      (FUNCALL (LAMBDA (K) (FUNCALL K 1))
               (LAMBDA (&amp;OPTIONAL #:G546 &amp;REST #:G547)
                 (DECLARE (IGNORABLE #:G546))
                 (DECLARE (IGNORE #:G547))
                 (FUNCALL (CL-CONT::FDESIGNATOR-TO-FUNCTION/CC #:G542) #&#39;VALUES
                          #:G544 #:G546))))
    1))
 #&#39;+)
```


===
# cl-contへの不満
-----------------

* 遅い
* lambda多い。
  + 多分コンパイラと相性が悪い
* lambda禁止おじさんと分かりあえる

===
# cl-fast-cont


&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# cl-fast-cont
--------------

* [KeenS/cl-fast-cont: faster partial contiuation library of common lisp](https://github.com/KeenS/cl-fast-cont)
* とりあえずレポジトリ作っただけ
* 完成させたい…

===
# アプローチ1
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# SSA使う
---------

* CPSと等価
* だけどSSAだったらlambda出てこない
* Common Lispならgotoあるしいけるんじゃね？

===
```common-lisp
(let (x y z)
 (tagbody
    (setq x 1)
  :call/cc
    (setq y 1)
    (setq z (+ x y))))
```


===
# 問題
-------

* ネイティブスタックとは別に自分でスタック作らないといけない
  + 例外とかでスタック巻き戻されるとつらい
* gotoのタグをtagbodyの外に持ち出せない(=継続を外に持ち出せない)
* 変数を準備するのが面倒orパフォーマンスに影響しそう
* そもそもtagbodyそこまで柔軟じゃなかった
* 関数が消し飛ぶ

===
# アプローチ2
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# SSA+CPS
---------

* SSAとCPSを組み合わせる
* 基本はSSA
* スタックを使う/継続が必要な所でだけCPS
===
# 問題
-------

* SSAの部分意味なくね？
* そもそも継続を取り出すのが目的なので関係ない所で変換しても意味がない

===
# アプローチ3
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# Selective CPS
----------------

* 継続が必要な部分でのみ変換
* 2 pass transformation
* [A Selective CPS Transformation](http://www.sciencedirect.com/science/article/pii/S1571066104809691)
===

```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    (+ 1 (call/cc
          (lambda (k)
            (funcall k y))))))

```

===

```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    (+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```

===

```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    @(+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```

===

```common-lisp
(with-call/cc
  @(let ((x 3) y)
    (setq y (* x x))
    @(+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```

===
# そもそもCommon Lispのつらい話
-------------------------------
* セマンティクスが動的
  + catch, block, tagbody
  + special variable
  + 変換は静的なのでどう頑張っても追い付かない
* multiple valueが面倒


===
# ダイナミック!!
----------------

``` common-lisp
(block name
 (let ((f
        (lambda (x) (return-from name x))))
   (with-call/cc
       (funcall
        f
        (call/cc
         (lambda (k)
           (funcall k 2)))))))
```

===
# スペシャル変数
---------------

* Common Lispにはレキシカルスコープとダイナミックスコープ両方ある
* CPS変換すると継続の全てがスコープ下に入る
  + 関数の呼び出し関係が木だったのが線型になる
  + ダイナミックスコープだと困る
===
![CPS前のAST](/images/cps/pre-cps.png)


===
![CPS後のAST](/images/cps/post-cps.png)


===
```
(defvar *x* 1)
(with-call/cc
  (progn
    (let ((*x* 2))
      (call/cc ..)
      (format t &#34;~a~%&#34; *x*)) ; *x* = 2
    (format t &#34;~a~%&#34; *x*))) ; *x* = 1

```

===

```
(defvar *x* 1)
(with-call/cc
  (progn
    (let ((*x* 2))
      (...
       (lambda (ignore)
         ((lambda (ignore)
            (format t &#34;~a~%&#34; *x*)) ; *x* = 2!!
          (format t &#34;~a~%&#34; *x*))))))) ; *x* = 1
```

===
# 多値
------

* Common Lispの多値はGoと違って無視出来る
* 変換が空気読む必要がある
* 下手するとプログラムを壊す
  1. 本当は多値を返してるのに変換で無視された
  2. 意図的に無視してるのに変換で加えられた

===
# 関数定義と引数の数
-----------------

* **Selective** CPS
* 関数をCPS変換するときとしない時がある
* 呼び出す時にどっちか分かんなくね？
  1. 統一的に変換してしまう
  2. Selectiveに変換して関数にメタデータつける

-&gt; まだ決めきれてない

===
# パフォーマンス
----------------


&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# フィボナッチ数列
-----------------
* とりえあずのフィボナッチ数列で計測
  + Full CPS変換に割と不利
  + 何も考えずにライブラリを使うとこうなるよって例
* Selective CPSは何もしない=普通の定義と同じ


===
```common-lisp
(defun fib (n)
  (if (&lt;= n 1)
      1
      (+ (fib (- n 1)) (fib (- n 2)))))
```

``` common-lisp
(defun/cc fib-cont (n)
  (if (&lt;= n 1)
      1
      (+ (fib-cont (- n 1)) (fib-cont (- n 2)))))
```

===
# Selective


```
Evaluation took:
  1.517 seconds of real time
  1.516000 seconds of total run time (1.516000 user, 0.000000 system)
  99.93% CPU
  4,388,993,782 processor cycles
  0 bytes consed
```

===
# Full

```
Evaluation took:
  18.347 seconds of real time
  18.576000 seconds of total run time (18.248000 user, 0.328000 system)
  [ Run times consist of 1.396 seconds GC time, and 17.180 seconds non-GC time. ]
  101.25% CPU
  53,149,416,888 processor cycles
  22,922,853,904 bytes consed
```
===
# コルーチン
------------

* そこまでFull CPSに不利じゃない
* 割と実用しそうな例
* Selective CPSは少しだけラムダが少ない

===
# Selective

``` common-lisp
(let (c)
  (setf c ((lambda ()
             (write-line &#34;in thread A 1&#34;)
             (lambda ()
              (write-line &#34;in thread A 2&#34;)
              (lambda ()
                (write-line &#34;in thread A 3&#34;))))))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```


===
# full

```common-lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```
===
# Selective

```
Evaluation took:
  0.905 seconds of real time
  0.904000 seconds of total run time (0.904000 user, 0.000000 system)
  99.89% CPU
  2,617,396,241 processor cycles
  0 bytes consed

```

===
# full

```
Evaluation took:
  1.272 seconds of real time
  1.272000 seconds of total run time (1.272000 user, 0.000000 system)
  100.00% CPU
  3,681,362,466 processor cycles
  0 bytes consed
```

===
# まとめ
--------

* 限定継続便利だよ
* マクロを使えばCPS変換で限定継続実装出来るよ
* でもパフォーマンや言語の問題もあるよ
* Selective CPSを使えばパフォーマンスの問題解決出来るよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>テストについて、Scalaと。</title>
      <link>/slide/tesutonitsuite_Scalato_/</link>
      <pubDate>Tue, 12 Apr 2016 22:31:51 +0900</pubDate>
      
      <guid>/slide/tesutonitsuite_Scalato_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# テストについて、Scalaと。
----------------------
サイバーエージェント アドテクスタジオ  
ScalaMeetUp テスト回

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
   + 基盤開発グループでScalaで基盤開発してます
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# Scalaのテスト
---------------

* ScalaTest
  + 機能豊富
  + 複数のテストスタイルを選べる
  + 他のフレームワークとの統合がある
* Specs2
  + 普通に使いやすい
* 他にもScalaCheck、JUnit、Gatlingなどなど

===
# ScalaTestのスタイルたち
-----------

* FunSuite
  + xUnitっぽいらしい
* FlatSpec
  + xUnitからBDDに移行した人向けらしい
* FunSpec
  + RSpecっぽいBDD用の

===
# ScalaTestのスタイルたち
-----------

* WordSpec
  + Specs2に似てる。
* FreeSpec
  + 何段にでもネスト出来る。自由。
* Spec
  + テスト=メソッド。速いらしい。

===
# ScalaTestのスタイルたち
-----------
* PropSpec
  + プロパティベースのテスト。ScalaCheckとの統合。
* FeatureSpec
  + シナリオテスト。
===
# その他の機能
-------------

* mockitoのシュガー
* Matcher DSL
* 複数のランナー（複数のツールとの統合）

===
# Axionのテスト
コード紹介を多めに
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 単体テスト
---------------

* 普通の単体テストはWordSpec
* ホーアの3つ組に基いて事前条件、コマンド、事後条件(不変条件)に分ける
  + 「{事前条件}が成り立つ時{コマンド}を実行し、停止するなら{事後条件(不変条件)}が成り立つ」の列挙
* [テストについて考えてみた | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/tesutonitsuitekangaetemita/)
* コマンドの実行と事後条件への表明を明確に分離
* テストの分け方に試行錯誤

===
# 事前条件
----------

* 基本的にはmockitoをフルに使う
* テストは並行に走るのでテストケース毎にモックを準備
* コンテキストの共有は基本的にはしない
  + 情報の局所性を上げて何をテストするかを理解しやすくする
  + 逆にノイズが乗ってわかりにくい？
* メソッドの実行に必要な引数と環境全てを構築する

===
# コマンドの実行
---------------

* 例外が起きないことだけ表明する
* 結果はvarに保存して外に持ち出す。

===
# 事後条件
----------

* コマンドを実行した結果に対する表明
* 環境に対する表明
  + 環境が変化した/しなかった
  + 依存オブジェクトのメソッドが呼ばれた/なかった

===
メソッド毎にテストケースをグルーピング

``` scala
&#34;Class#method&#34; when {
  &#34;precondition&#34; should {
    ...
    var ret: Type = null
    &#34;method invocation&#34; in {
      ret = ...
    }

    &#34;post conditions&#34; in {
      ...
    }
  }
}

```

===
# Tips
------

* エディタでテンプレートを用意しておくと楽
  + ensimeのテストテンプレートとか
* やや冗長でも頭を使わずに書ける/理解出来るテストを書く

===
# ユーティリ
---------------

* ユーティリティのテストはPropSpec
* ユーティリティ = 汎用的(文脈に依存しない)、副作用がない、小さい
  + まさにプロパティベースのテストに向く
* ほとんどGenerator Driven Test
  + 半分くらいScalaCheckの機能を使う
* 一部Tebale Driven Test
  + Generatorがコーナーケースを生成してくれない時がある

===
# 他のテスト
------------

* インテグレーションテスト/パフォーマンステストはGatling(の予定)
* Gatlingでエラーレート、パーセンタイル、レスポンスなどをテスト出来る
* パフォーマンステストは実行インスタンスを固定しないといけない問題が…
* シナリオテストはない(APIがReadのみなため)

===
# 他のテスト
---------------

* AxionはThriftプロトコルだがGatlingのAPIをいくつか実装すればGatlingを独自プロトコルに対応出来る
  + 実装量はほとんどない
  + 2~3個DSLを作るだけ
  + 簡単とはいってない(ドキュメントがないつらさ)
* Gatlingのおかげでパフォーマンスに対する表明やリクエスト毎のチェックなどが簡単
* そのうちノウハウを公開するかも？
  + 2.1.Xと2.2.XでAPIが違う問題も…

===
# まとめ
--------

* ScalaTestを紹介したよ
* ScalaTestの実用例を紹介したよ
* Gatlingについて紹介したよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SMLで函数型的正規表現マッチ</title>
      <link>/slide/SMLdekansuukatatekiseikihyougenmatchi/</link>
      <pubDate>Tue, 29 Mar 2016 01:44:39 +0900</pubDate>
      
      <guid>/slide/SMLdekansuukatatekiseikihyougenmatchi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLで函数型的正規表現マッチ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# 元ネタ
--------
[関数型的正規表現マッチ | Preferred Research](https://research.preferred.jp/2010/11/regexp-play/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 正規表現
----------

必要最小限の要素は5つだけ

1. 空文字
2. アルファベット1つ
3. 正規表現のOR結合
4. 正規表現のAND結合
5. 正規表現の繰り返し

===
# SMLで表してみる
-----------------

``` sml
datatype  reg
  = Empty
  | Sym of t
  | Or of reg * reg
  | And of reg * reg
  | Rep of reg
```
===
# 本当に大丈夫？

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# `/(a|b)*c/`
-----------

``` sml
And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)
```

===
# `/https?:\/\/[a-z]*/`
-----------

``` sml
val a_z = Or(Sym&#34;a&#34;, Or(Sym &#34;b&#34;, Or(Sym &#34;d&#34;, ...)))
And(Sym &#34;http&#34;, And(Or(Sym &#34;s&#34;, Empty), And(Sym &#34;://&#34;, Rep a_z)))
```

===
# 実装してみる

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# `Empty`, `Sym`, `Or`
----------------
trivial

``` sml
fun match Empty u = isEmpty u
  | match (Sym a) u = a = u
  | match (Or(p, q)) u = match p u orelse match q u
```

===
# `And`
--------

`And(p, q)` に入力が`u`の時`p`がどこまでマッチするか分からないので

* `u` から一部取ってきて`p`にマッチするか確認
* 残りの文字列が`q`にマッチするか確認

===
# `And`
--------
`match (And (Sym &#34;a&#34;, Sym &#34;b&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;&#34;)、(Sym &#34;b&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;b&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;b&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;abd&#34;)、(Sym &#34;b&#34;と&#34;&#34;)


===
# `And`
--------

``` sml
  | match (And(p, q)) u = 
    withSprits u (fn (u1, u2) =&gt; 
      match p u1 andalso match q u2)

```

`withSprits u f` は`u`を2分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。

===
# `Rep`
-------

`Rep(r)` に入力が`u`の時、`r`がどこまでマッチするかも`Rep`が何回繰り返すかも分からないので

* `u` を任意の個数に分割し
* その全てが`r`にマッチするか確認

===
===
# `Rep`
--------
`match (Rep (Sym &#34;a&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;b&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)



===
# `Rep`
--------

``` sml
  | match (Rep(r)) u =
    withParts u (fn input =&gt;
      List.all (match r) input)
```

`withParts u f` は`u`を分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。


===
# チェック
----------

```
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbca&#34;;
val it = false : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbc&#34;;
val it = true : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;c&#34;;
val it = true : bool
```

===
# まとめ
--------

* 適当に実装したら正規表現も簡単に実装出来るよ
* SMLで正規表現実装したよ

===
# 参考
------

* [KeenS/regexp](https://github.com/KeenS/regexp)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ビッグデータしないDrill、ローカルで快適に使うために</title>
      <link>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</link>
      <pubDate>Sun, 06 Mar 2016 14:54:30 +0900</pubDate>
      
      <guid>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ビッグデータしないDrill、ローカルで快適に使うために
----------------------
[Tokyo Apache Drill Meetup](http://drill.connpass.com/event/27414/)  
2016-03-22

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + サイバーエージェントのエンジニア
   + アドテクスタジオ所属
   + データエンジニアじゃなくてもデータを触ることはある

===
# なぜローカルか
---------------

* ビッグデータ重い
* 使いたいデータが絞れる時には大袈裟
  + 「売り上げ上位1000のユーザの行動」とか
* 同じようなクエリの重複
  + 新しいテーブル作れないDBとかview作れないDBとか
* 結果をRに渡したりとかが面倒
  + CSVダウンロードがGUI
===
# キャッシュ的な
----------------

```
+---------------------------------+
| BIG DATA (BigQuery, Spark, etc) |
+---------------------------------+
        ^ |  ^  |
        | |  |  |
        | v  |  v
   +-------------------+
   | ローカルキャッシュ | &lt;- ???
   +-------------------+
     ^ | ^ | ^ | ^ |
     | v | v | v | |
     +----------+  |
     |   自分   |  |
     +----------+  v
     +---+    +-----+
     | R | &lt;--| CSV |
     +---+    +-----+
```

===
# やりたいこと
--------------

* パパッっと処理を始められる
  + だいたい「CSVを簡単に読める」に同じ
  + たまにJSONとか
* 簡単に処理出来る
  + 自分が馴れているかどうか
* CSVを吐ける
  + 最後はRに渡したい

===
# 候補
-------

* ローカルMySQL
  + 事前のScheme定義が必要
* R
  + 扱い馴れない
* SQLite
  + 事前のScheme定義が必要
* (Python)
  + あまり向いてない？

===

&lt;pre style=&#39;font-size: 200%&#39;&gt;
＿人人人人人人人＿
＞　突然のDrill　＜
￣Y^Y^Y^Y^Y^Y￣
&lt;/pre&gt;

===
# なぜ Drill
------------

* (デーモン立ち上げておけば)サクっと始められる
* CSVをそのまま読める
  + Schema定義がいらない!
* ついでにJSONも読める
* 馴れたSQLで操作出来る
* CSV吐ける

===
# Drillを便利にするために
-------------------------

* いくつかのシェル関数
* Drillのデーモン/クライアントの起動を便利に

```sh
drill-start() {
    ~/compile/zookeeper-3.4.8/bin/zkServer.sh start
    drillbit.sh start
}

drill-cli() {
    sqlline -u jdbc:drill:zk=localhost:2181
}

drill-web() {
   firefox http://localhost:8047
}
```

===
# もっと便利に
--------------

* REPLでの操作が面倒
  + ヒストリ遡るのとか
  + ミスった時の訂正が地味に不便
* シンタックスハイライト欲しい
* 馴れたツールで編集したい

===
# sql-drill.el
--------------

* [KeenS/sql-drill.el](https://github.com/KeenS/sql-drill.el)
* Emacsのsql-modeのDrillサポート
  + emacsのsql-modeは拡張可能
* シンタックスハイライト
* REPL

===
# DEMO
------
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# まとめ
--------

* ローカルでデータ分析したい時があるよ
* その時にDrillは便利だよ
* Emacs向けのDrillプラグイン作ったよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustとは何か。どんな言語か。</title>
      <link>/slide/Rusttohananika_donnagengoka_/</link>
      <pubDate>Sun, 06 Mar 2016 05:27:39 +0900</pubDate>
      
      <guid>/slide/Rusttohananika_donnagengoka_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustとは何か。どんな言語か。
----------------------
[異種プログラミング言語格闘勉強会](http://kbkz.connpass.com/event/26677/)  
2016-03-20


&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# Rustって?
----------

* システムプログラミング言語
* だけど函数型言語から影響を受けた
* 安全かつ高速
* ゼロコスト抽象化

===
## システムプログラミング言語
---------------------------

* スレッドはネイティブ、Cとの相互呼び出し、小さなバイナリサイズ
* ゲームエンジンとか作れる([piston](https://github.com/PistonDevelopers/piston))
* レンダリングエンジンとか作れる([Servo](https://github.com/servo/servo))
* Lチカとか出来る
* OSとか作れる([Redox](https://github.com/redox-os/redox))

===
## 函数型言語的からの影響
-----------------------

最近ではめずらしくなくなった


* デフォルトイミュータブル
* 代数的データ型
* コンビネータ
* トレイト (型クラス)

===
## 安全かつ高速
--------------

* データ競合が起きない
  + 所有権システム
  + だいたいコンパイル時Read Writeロック
  + Read only参照複数 or Write可能参照1つ
* LLVMベースの強力な最適化
* スレッド周辺のAPIが揃ってる

===
## ゼロコスト抽象化
------------------
省略

* [Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/)

===
# Rustの誤解
-----------

* 安定してないって聞いたよ
* 函数型言語ってホント?
* GCがなくて大丈夫?
* 継承がなくて大丈夫?

===
## 安定してないって聞いたよ

* 1.0以前の話
* 1.0(2015-05以降)はAPIの変更がルール化された
* 新規APIのstablizeはあれどdeprecateはまれ

===
## 函数型言語ってホント?

* 函数型言語の機能をつまみぐいしてるだけ
* 標準ライブラリとかはバリバリ手続的
* Lispよりも函数型言語っぽくない。
* とはいえ抽象力は高いのでそこまで煩雑にはならない

===
## GCがなくて大丈夫?

* GCはなくてもメモリ管理は自動でする
* コンパイル時にメモリ管理
  + コンパイラが必要なところにmalloc/freeを挟むイメージ
* むしろメモリ以外(fd、ロックなど)も自動管理
  + GCがある言語よりリソース管理の自動化が徹底してる
* [リージョンについて | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/)

===
## 継承がなくて大丈夫?

* むしろ継承必要？インターフェースだけでよくない？
* Rustはデータ型とメソッドを分離するので継承のメリットそんなにない
  + トレイトが強力ともいう
* 逆にサブタイプ関係による複雑さの上昇のデメリットが多い
  + 3回以上継承してるの全部把握出来るの？
* ジェネリクスとかはあるよ

===
# Rustをとりまく環境
-------------------

* racer/rustfmt
* Cargo
* crates.io
* [Rust Playground](https://play.rust-lang.org/)
* The Rust Programming Language


===
# racer/rustfmt
---------------

* racerがコーディング支援ツール
  + 補完
  + 定義元ジャンプ
  + 型情報
  + 各種エディタプラグインあり
* rustfmtがコードフォーマッタ
  + エディタプラグインあり
  + ビルドツール連携あり

===
# Cargo
-------

* Rustのビルドツール兼パッケージマネージャ
* これだけ覚えとけば困らない

===
# crates.io
-----------

* Rustパッケージのセントラルレポジトリ
* 必ずビルドが通るような工夫
  + cargo yank
  + 同じライブラリの違うバージョンがいても大丈夫
* Cargoとの連携
* Cargoからpublishも可能

===
# [Rust Playground](https://play.rust-lang.org/)
---------------------------------------

* webからRustを試せる
* とりあえず試すと色々分かる
  + 所有権難しいとか

===
# [The Rust Programming Language](https://doc.rust-lang.org/book/)
------------------------------

* Rustの入門用ドキュメント
* とりあえずこれ読めば始められる
* [和訳版](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)もある
  + [GitHub](https://github.com/rust-lang-ja/the-rust-programming-language-ja)で作業中
  + これの宣伝しに来ただけ
* 1.6ほぼ終わり、1.7はまだ

===
# ライブラリ紹介
----------------
## MIO

* [mio](https://github.com/carllerche/mio)
* 低レベルな非同期IOライブラリ
  + libuvやlibev2相当
  + イベントスレッドではなくイベントループ
* これを純Rustで実装
* つまり(比較的)高水準なAPIで使える
* 色んなライブラリの下地になっている

===
# ライブラリ紹介
----------------
## diesel

* [diesel](https://github.com/sgrif/diesel)
* ORM &amp; クエリビルダ
  + mioとはうってかわって高水準なライブラリ
* `infer_schema!(dotenv!(&#34;DATABASE_URL&#34;));` でコンパイル時に
  + DBにアクセスしてスキーマ情報抜いて
  + コード生成
* モデルもCRUDでちゃんと使い分けている

===
# 所有権難しい
--------------
下記のコードは動かない。

``` rust
fn main(){
    let hello = &#34;Hello, &#34;.to_owned();
    let world = &#34;World!&#34;;
    let hello_world =  hello + world;
    println!(&#34;{}&#34;, hello);
    println!(&#34;{}&#34;, world);
    println!(&#34;{}&#34;, hello_world);
}

```


===
# まとめ
--------

* Rustはシステムプログラミング言語だよ
* 面白い機能いっぱいあるよ
* もう「安定待ち」じゃないよ
* Try it now!



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでSSPを作った話</title>
      <link>/slide/ClojuredeSSPwotsukuttahanashi/</link>
      <pubDate>Mon, 22 Feb 2016 20:19:11 +0900</pubDate>
      
      <guid>/slide/ClojuredeSSPwotsukuttahanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClojureでSSPを作った話
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# SSPとは
-------
※今回作ったものの話なので実際は少し違う

* Supplier Side Platform
* メディアからの広告リクエストを受けて表示権をオークションに掛け、落札された広告を表示する
  0. 広告リクエストを受け取って
  1. 各DSPに競りの通知を投げて
  2. 入札を受け取って
  3. 落札者と落札価格を決めて
  4. 落札通知を出す

===
# アドテクコンペ
---------------

* [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380)
* サイバーエージェントの学生向けインターン
* 3日間、3、4人のチームで **DSP** を作る
* 学生は7チーム、1チームあたり2000q/sを捌くことになってる
* 学生のDSPを繋ぐための **SSP** が必要になったので作ることに。

===
&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/92I5tQt6q6IjII&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/prir/ss-35918532&#34; title=&#34;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&#34; target=&#34;_blank&#34;&gt;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/prir&#34; target=&#34;_blank&#34;&gt;CyberAgent, Inc.&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

===
# 作るもの
----------

* 各DSPに競りの通知(HTTPリクエスト)を投げる大規模HTTPクライアント
  + 各DSPが2000q/s x 7チーム + 落札通知 = 16000q/s
  + 丁度2000q/sになるような制御も必要
* 入札を受けてのオークション、結果のロギングなど
* 管理画面

===
# s7pについて
-------------

* 今回作ったSSP
* [KeenS/s7p](https://github.com/KeenS/s7p)
* Clojure製
* 3日くらいで作った
* やや粗い部分も

===
# 今日話すこと
--------------

* なぜClojureか
* 16000q/s出すための工夫
* 16000q/sに抑えるための制御
* 運用して困った話とか

===

# なぜClojureか

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# なぜClojureか
---------------

* リクエストの数が多いので非同期IOは必須
* 100msでタイムアウトする仕様なのでタイムアウト処理も
* もともとはScala(akka)で作ったs6pがあった
* Actorの設計が良くなかったので遅かった
* あと非同期HTTPクライアントにタイムアウトがなかった
* プロダクションコードを流用したのでインターンが終わった後公開出来なかった
* 別言語で書き直すにあたってGo, Clojure, Common Lisp, Rust, Erlangが検討された
===
# なぜClojureか
---------------

* Common Lisp: 一番慣れてるが、非同期HTTPクライアント(とfutureライブラリ)が使いづらそうなのでやめた
* Rust: とりあえずパフォーマンスは出そうだし使いたかったが非同期HTTPクライアントが見付からなかった
* Clojure: そこそこ慣れてるし速そうな非同期HTTPクライアントがあった。core.asyncで非同期プログラミングもし易い
* Erlang: 恐らく一番向いてるが、ほとんど経験がない
* Go: 結構向いてそうだがあまり経験がないのでClojureを選んだ

===
# 16kq/s出すための工夫
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 16kq/s出すための工夫
------------------------
非同期IO（一部同期しちゃったけど）

``` clojure
(defn work [test req result]
  (-&gt;&gt; @dsps
       (sequence (comp
       ;; 全DSPにPOSTしてから(timeout 100ms)
                  (map (fn [dsp] {:dsp dsp :response (http/post (:url dsp) (json-request-option req))}))
       ;; 結果を待ち合わせる
                  (map destruct)
                  ...))
       ...))
    ....
```

===
# 16kq/s出すための工夫2
------------------------
一部同期したのでとにかくスレッド。スレッドへのディスパッチはチャネルで一発解決。

``` clojure
(defn worker [c]
  (thread
   ...))
```

```clojure
(defn make-workers [ch n]
  (doall (map (fn [_] (core/worker ch)) (range n))))
```

``` clojure
 workers (manage/make-workers ch 1024)
```

===
# 16kq/s出すための工夫3
------------------------
ZeroMQを使ったmaster-slave構成
(最終的にSlave18台)

![master-slave構成図](/images/s7p/s7p.svg)


===
# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------

* DSPの買い付け能力というビジネス的な問題ではなくサーバの負荷という技術的な問題による制御
* 1秒で160kクエリ投げて9秒休むとかは出来ない。もう少し細かく制御する必要がある。
* しかし制御をあまり細かくしすぎると今度はそこで遅くなりそう。
* リクエストを実際に投げるSlaveは分散してるけど統一した制御が必要

===
# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------
Master側で100ms毎にに200個だけZeroMQのキューに積む

![QPS制御の図](/images/s7p/qps_control.svg)

===
# &lt;span style=&#34;font-size: 90%&#34;&gt;16kq/sに抑えるための制御&lt;/span&gt;
---------------------------
実装にはcore.asyncの `chan` と `timeout` を使用。(非同期プログラミング便利!)

```Clojure
(defn start-query [sender reqs]
  (let [timer (timer 100)]
    (go-loop []
      (let [t (&lt;! timer)
            took (take @qp100ms @reqs)]
        (doall
         (doseq [req took]
           (zmq/send-str sender (json/generate-string req))))
        (swap! reqs #(drop @qp100ms %))
        (if (and t (not (empty? took)))
          (recur)
          (println &#34;request done&#34;))))
    timer))
```

===
# 運用して困った話とか
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 50%&#34;&gt;レスポンスが遅いDSPにSSPのパフォーマンスが引き摺られる&lt;/span&gt;
* DSPが速ければ余裕を見ても10台あれば十分だった
* DSPのパフォーマンスに仮定をおけないので上限ギリギリの18台
* 同期: 「DSP作ってる時はちょっとくらい待ってくれよ、って思ってたけどSSP運用したら遅いDSPガンガン切りたくなる気持分かった」
===
# 運用して困った話とか
---------------------
## パフォーマンス検証が大変
* リクエストを捌くサーバのパフォーマンスをどうするか悩む
* サーバをチューニングすればSSPも速くなるが、検証にならない
* かといって投げたクエリを捌けないサーバに対して検証する訳にもいかない
* 結局安全側に倒したパフォーマンス見積りに。

===
# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 80%&#34;&gt;Masterがログ吐きすぎてDisk Full&lt;/span&gt;
* 最初の予定ではMasterはディスクをそんなに使わなかったのでディスクの小さいインスタンスだった
* ディスクスペース空けてMaster再起動で復旧。焦った。
===
# 運用して困った話とか
---------------------
## &lt;span style=&#34;font-size: 60%&#34;&gt;timeoutし続けるDSPがいてSlave完全沈黙&lt;/span&gt;
* コネクションのクローズ待ちで固まってた
* 該当DSPを切った上でSlaveの再起動で復旧
  * カーネルのチューニングかtimeout頻度の検知が必要そう
* timeoutを考慮に入れた構成にしてた筈なので想定外だった
===
# まとめ
---------

* ClojureでSSP作ったよ
* Clojure使えば非同期プログラミングが簡単に出来るよ
* 運用って大変だよ

===
# 参考
-------

* [KeenS/s7p: sexp version of s6p; a toy SSP.](https://github.com/KeenS/s7p)
* [ClojureでDSPを作った話 | κeenのHappy Hacκing Blog](http://keens.github.io/slide/ClojuredeDSPwotsukuttahanashi/)
* [KeenS/b11d: A toy DSP](https://github.com/KeenS/b11d)
* [アドテクコンペ | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/recruit/fresh/program_detail/id=11303&amp;season=2016)
* [ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント](https://www.cyberagent.co.jp/techinfo_detail/id=11380)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>HAMT ~ イミュータブルで高速なハッシュマップ ~</title>
      <link>/slide/HAMT/</link>
      <pubDate>Sun, 31 Jan 2016 16:17:35 +0900</pubDate>
      
      <guid>/slide/HAMT/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# &lt;span style=&#34;font-size: 90%&#34;&gt;Hash-Array Mapped Trie&lt;/span&gt;
----------------------
 ~ イミュータブルで高速なハッシュマップ ~  
サイバーエージェント AdTech Scala Meetup LT大会

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループの新卒
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# &lt;span style=&#34;font-size: 60%&#34;&gt;scala.collections.immutable.HashMap&lt;/span&gt;
-------------------------------------

* 今日の話題。これの実装をみていく。
* イミュータブル
* キー-バリューペア
* 値を追加する度に新たなハッシュマップを作る &lt;!-- .element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;

===
# HashMap
----------------

* `O(1)`のアクセス効率
* 空間効率は悪い
* ハッシュ関数が定義出来れば何でもキーに使える
* 普通はミュータブルに使う
  + 大量のメモリをアロケートするのでコピーはつらい

===
# メモリ効率悪そう？
-------------------------

```scala
val hash = HashMap.empty + (3 -&gt; 1)
// +---+---+---+---+---+----
// | / | 3 | / | / | / | ...
// +---+---+---+---+---+----
//       |
//      +-+
//      |1|
//      +-+
```

===
# メモリ効率悪そう？
-------------------------

```scala
val hash2 = hash + (2 -&gt; 2)
// +---+---+---+---+---+----
// | / | 3 | / | / | / | ...
// +---+---+---+---+---+----
//       |
//      +-+
//      |1|
//      +-+
//  &gt; Copy &lt;
// +---+---+---+---+---+----
// | / | 3 | / | 2 | / | ...
// +---+---+---+---+---+----
//       |       |
//      +-+     +-+
//      |1|     |2|
//      +-+     +-+
```

===
# メモリ効率的データ構造?
----------------------------
## TreeMap

* O(log(n))のアクセス効率
* 空間効率はほどほど
  + イミュータブルに使えばかなり良い
  + 部分構造を再利用出来る
* 全順序関数が定義出来れば何でもキーに出来る
* キーが複数回比較される問題がある

===
# キー同士の比較
---------------
長いキー同士の比較がO(log(n))回走る可能性がある

```scala
treeMap.get(&#34;very long ... key1&#34;)

        ....
       /
&#34;very long ... key3&#34; -&gt; &#34;value3&#34;
       \
   &#34;very long ... key2&#34; -&gt; &#34;value2&#34;
         \
      &#34;very long ...key1&#34; -&gt; &#34;value1&#34;
```

===
# HashMap vs TreeMap
-----------------

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th&gt;HashMap&lt;/th&gt;&lt;th&gt;TreeMap&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;アクセス効率&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34;&gt;`O(1)`&lt;/td&gt;&lt;td&gt;`O(log(n))`&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;イミュータブルな時の空間効率&lt;/th&gt;&lt;td&gt;悪い(毎回コピー)&lt;/td&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;良い(部分構造を共有)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;キーの比較&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;定数回&lt;/td&gt;&lt;td&gt;`O(log(n))`回&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;キーの要件&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;Hash関数が定義されている&lt;/td&gt;&lt;td&gt;全順序関数が定義されている&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
===
# &lt;span style=&#34;font-size: 90%&#34;&gt;Hash-Array Mapped Trie&lt;/span&gt;
------------------------

* `O(1)`のアクセス効率
* 部分構造を共有してメモリ効率も良い
* キーの比較は定数回
* Hash関数が定義されていればキーに出来る

===
# 動作
------

* ざっくり言うと、「Hashして分割してトライ」

===
# 動作
------
## Hashする

* 40bitくらいの値が生成される

``` scala
hash(&#34;key&#34;)
// =&gt; 0b10101101010101001010110101010100
```

===
# 動作
------
## 分割する

* 下位から5bit毎に分割する
  + 5bit = 0 ~ 31
  + 32分木になる

```
11111 00010 10110 10101 01001 01011 01010 10100
```

===
# 動作
------
## トライ

* 32分のトライ木になる
* トライ木の実装は32bitのbitmapを使ったArray Mapped Trieを使う

===
(図が分かりづらいというか不適切)

```
8     7     6     5     4     3     2     1
11111 00010 10110 10101 01001 01011 01010 10100

1    2    3  4
   ...
  /
10100     ...
  \        /
   \    01011
    \   /  \
     \ /   01001....
     01010
       \
        ...
```

===
# 特徴
------

* ハッシュ値が固定長なので`O(1)`で動作
* Treeなので部分構造の共有が簡単
* 木を辿る時の比較はhash値（の一部）なので高速
* キーに全順序がなくてもハッシュ関数さえ定義されていれば木を構築出来る

===
# まとめ
--------

* Scalaのimmutable.HashMapはコピーしても高速だよ
* 裏で動くアルゴリズムを紹介したよ
  + ざっくりなので本物はもう少し工夫してる
  + prefix treeになってる

===
# 参考
------

* PDF [Ideal Hash Trees](http://lampwww.epfl.ch/papers/idealhashtrees.pdf)
  + HAMTの元論文
* [HAMT(Hash Array Mapped Trie) - sileのブログ](http://sile.hatenablog.jp/entry/20100926/1285467529)
  + HAMTの解説ブログ
* PDF [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections](http://michael.steindorfer.name/publications/oopsla15.pdf)
  + HAMTを改善したCHAMPというデータ構造の論文。Clojureにこれが入りそう。
* [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections | the morning paper](http://blog.acolyer.org/2015/11/27/hamt/)
  + CHAMPを解説したブログ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>DSLとTagless Final</title>
      <link>/slide/DSLtoTagless_Final/</link>
      <pubDate>Sun, 13 Dec 2015 22:42:39 +0900</pubDate>
      
      <guid>/slide/DSLtoTagless_Final/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# DSLとTagless Final
----------------------
サイバーエージェント アドテクスタジオ  
Scala Meet Up 2015-12-18

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒エンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
   - Scalaは初心者 ※ [Scala初心者の新卒が頑張ってLispを作ってみた](http://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/)
===
# 注意
------

* Scala初心者なのでScalaではなくScalaっぽい疑似コードで説明します
  + ~~コード例動かす時間が無かっただけ~~
* Scala初心者なのでScalaのコードは少なめに説明します

===
# DSLを作る
-----------

以下のようなHTTPなユーザをエミュレートするDSLを考える

``` scala
val scenario = and(
  get(&#34;/&#34;),
  get(&#34;/users&#34;).andThen(res =&gt;
    post(&#34;/follow&#34;, first(users.getJsonData))))
val Right(_) = runScenario(scenario, &#34;user&#34;)
```

===
# DSLを作る
-----------

普通は以下のようなAST作ってをラップする

``` scala
trait ScenarioDSL
sealed case class Get(url: String) extends ScenarioDSL
sealed case class Post(url: String, data: JSON) extends ScenarioDSL
sealed case class And(first, ScenarioDSL, second ScenarioDSL) extends ScenarioDSL
sealed case class AndThen(first: ScenarioDSL,
   callBack: (Response) =&gt; ScenarioDSL) extends ScenarioDSL

def get(url: String): ScenarioDSL= Get(url)
....

```

===
# DSLを作る
-----------

そして`runScenario`を作る

``` scala
def runScenario(scenario: ScenarioDSL, user: String) = {
  scenario match {
    Get(url) =&gt; Client.getInstance(user).get(url)
    Post(url) =&gt; Client.getInstance(user).post(url)
    And(first, second) =&gt; {runSenario(first, user); runSenario(second, user)}
    ....
  }
}


```



===
# DSLを便利に
-------------

例えば、このDSLを`curl`コマンド関数を追加する

``` scala
def toCurl(scenario: ScenarioDSL, user: String) =
  val auth = makeAuth(user)
  scenario match {
    Get(url) =&gt; &#34;curl ${auth} ${SERVICE_HOST}/url&#34;
    Post(url) =&gt; &#34;curl ${auth} -XPOST ${SERVICE_HOST}/url&#34;
    And(first, second) =&gt; toCurl(first) + &#34;\n&#34; + toCurl(second)
    ....
  }
}

```

===
# DSLの拡張
-----------

このDSLに新たに`select`を追加する

``` scala
val scenario = and(
  get(&#34;/&#34;),
  select(get(&#34;/users&#34;),
         post(&#34;/update&#34;)))
val _ = runScenario(scenario, &#34;user&#34;)
```

===
# Expression Problem
-------------------

この時に問題が出る

* DSLを使う全てのコードに変更が必要
  + `runScenario`と`toCurl`で`select`に対応する
* DSLそのものに手を加える必要がある
  + DSLがsealed traitされてる
  + そもそも、DSLがライブラリだったら変更出来るの？
* 実際には使ってなくても全ての関数で新しい機能に対応しないといけない
  + `toCurl`では`select`に対応しないとか
  + 逆に、`toCurl`がプラグインでコードいじれなかったらどうしよう
===
# Tagless Finalで解決出来るよ
----------------------------

* 元のコードをいじらず
* 必要な所だけを記述して
* しかも元々の実装よりも速い

DSLの作り方があります。それは型クラスを使ったやり方です。

===
# 型クラスの復習
---------------

型クラスは

* 型の振る舞うインターフェースを定めて
* インスタンスの型ごとに「後付けで」実装を与えると
* 多相的に扱えるアドホックポリモーフィズム

でした

===
# 型クラスの復習
---------------

``` rust
trait Hello { //型クラス
  fn hello(&amp;self) -&gt; String;
}

impl Hello for isize { //isize型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;I&#39;m {} years old&#34;, self)}
}
impl &lt;&#39;a&gt;Hello for &amp;&#39;a str {//&amp;str型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;My name is {}&#34;, self)}
}
fn main() {
  println!(&#34;{}&#34;, 23.hello());     // =&gt; &#34;I&#39;m 23 years old&#34;
  println!(&#34;{}&#34;, &#34;κeen&#34;.hello()); // =&gt; &#34;My name is κeen&#34;
}
```

===
# DSLをRustに翻訳
-------------

Scalaで型クラスを説明するとややこしいので一旦先のDSL例をRustに翻訳します

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getJsonData().first)));
runScenario(scenario, &#34;user&#34;).unwrap();
```

===
# Rustに翻訳
-------------
DSLのASTはこうなります。

``` rust
enum ScenarioDSL {
  Get{url: String},
  Post{url: String, data: RequestData},
  And{first: Box&lt;ScenarioDSL&gt;, second: Box&lt;ScenarioDSL&gt;},
  AndThen{first: Box&lt;ScenarioDSL&gt;,
   callBack: FnOnce&lt;(Scenario, Request) -&gt; ScenarioDSL&gt;},
}
```
===
# Rustに翻訳
-------------
runScenarioはこうなります。

``` rust
fn runScenario(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; Result&lt;()&gt; {
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; Client::instance(user).get(url),
    &amp;ScenarioDSL::Post{ref url} =&gt; Client::instance(user).post(url),
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      try!(runSenario(first));
      runSenario(second)
    },
   ...
  };
}
```

===
# Rustに翻訳
-------------
`toCurl`はこうなります

``` rust
fn toCurl(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; String {
  let auth = makeAuth(user)
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; format!(&#34;curl {} {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::Post{ref url} =&gt; format!(&#34;curl {} -X POST {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      let first_str = toCurl(first, user);
      let second_str = toCurl(second, user);
      format!(&#34;{}\n{}&#34;, first_str, second_str)
    },
   ...
  }
}
```

===
# Tagless Final
---------------

Rustの準備が終わったのでTagless Finalの説明に入ります。

===
# Tagless Final
----------------

* ASTをデータではなく関数で表わす
* 同じ関数でも欲しい結果によって計算を変えるために型クラスを使う
* どの型クラスのインスタンスとして扱うかで結果を変える
  + そもそもASTは計算を抽象化してデータにしたもの。
  + 抽象的な計算があるならデータにする必要はない

* 型クラスでジェネリックに作って
* 欲しい型を伝えるだけで挙動が変わる

===
# 型クラス
----------
DSLの文法の型クラスを定義する。  
DSLっぽく見せるため、ラッパを書く(Rust特有)。


``` rust
trait ScenarioSYM {
  fn get(url: String) -&gt; Self;
  fn post(url: String) -&gt; Self;
  fn and(first: Self, second: Self) -&gt; Self;
  ...
}

fn get&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::get(url)}
fn post&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::post(url)}
fn and&lt;C: ScenarioSYM&gt;(first: C, second: C) -&gt; C {C::and(first, second)}
...
```


===
# `runScenario`
------
結果に`Result`型が結果として欲しいなら`Result`型に`ScenarioSYM`を実装する

```rust
impl ScenarioSYM for Result&lt;()&gt; {
  fn get(self,url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn runScenario(res: Result&lt;()&gt;) -&gt; Result&lt;()&gt; {
  res
}
```

===
# `toCurl`
----------
`String`が欲しいなら`String`に実装すれば良い。

``` rust
impl ScenarioSYM for String {
  fn get(self, url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn toCurl(str: String) -&gt; String {
  str
}
```

===
# 完成形
--------

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getData().iter().next())));
  // ↑ここまではジェネリックなScenarioSYM型
  // ↓ここで呼ばれることでResult&lt;()&gt;型にインスタンス化される
runScenario(scenario, &#34;user&#34;).unwrap();
```

===
# DSLの拡張
-----------

拡張したい文法のDSLを定義して、欲しいものに実装するだけ。

`runScenario`に変更は要らないしサポートしない`toCurl`は気にしなくて良い。

``` rust
trait SelectSYM {
  fn select(self, first: Self, second: Self) -&gt; Self;
}

impl SelectSYM for Result&lt;()&gt; {
  fn select(self, first: Self, second: Self) -&gt; Self {...}
}
```

===
# Tagless Finalまとめ
---------------------

* この方式だと実行時にタグでパターンマッチしないので速い
* DSLの拡張も機能の拡張も容易
* 型クラス便利

===
# ScalaでのTagless Final
------------------------
Rustで分かりやすく解説したのでScalaでどうなるか見ていきます。

まずは型クラスを定義

``` scala
trait ScenarioSYM[C] {
  def get(self: C, url: String): C
  def post(self: C, url: String): C
  ...
}
def get(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.get(self, url)
def post(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.post(self, url)
...
```

===
# `runScenario`
------

``` scala
implicit val resultScenario = new ScenarioSYM[Either[Err, ()]] {
  def get(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  def post(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  ...
}

def runScenario(ast: Either[Err, ()], user: String)
      (implicit i: ScenarioSYM[Either[Err, ()]]) = ast
```

===
# 完成形
--------
Scalaの型クラスの制約上最初の例と少し異なる
(`val`じゃなくて`implicit`を取る`def`になる)


``` scala
def scenario(implict i: ScenarioSYM[C]) = Scenario
   get(&#34;/&#34;)
   get(&#34;/users&#34;) andThen((scenario, res) =&gt;
    scenario post(&#34;/follow&#34;, first(users.getJsonData)))
val Right(_) = runScenario(scenario, &#34;user&#34;)

```

===
# まとめ
--------

* Expression Problemについて説明した
* Tagless Finalを紹介した
* 型クラス便利
* Rust便利
* [参考](http://okmij.org/ftp/tagless-final/course/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでDSPを作った話</title>
      <link>/slide/ClojuredeDSPwotsukuttahanashi/</link>
      <pubDate>Tue, 27 Oct 2015 21:04:20 +0900</pubDate>
      
      <guid>/slide/ClojuredeDSPwotsukuttahanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClojureでDSPを作った話
----------------------
Lisp Meet Up #3
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

===
# DSPとは
--------

* Demand Side Platform
* 広告主から広告を集めて広告の表示権を競り落し、適切な広告を出す
  0. 広告主を集めて
  1. 競りの通知を受け取って
  2. 一番コスパが良さそうな広告を選んで
  3. 入札して
  4. 落札通知を受け取る
  5. 落札したら広告を出す

===

# ひとりDSP
----------

* AdTech Studioの新卒研修
* 2ヶ月間、業務時間の20%を使ってDSPを作る
  + 実質8営業日
* 業務ロジックを理解することが目的
* 最後に新卒の作ったDSP同士で競争、利益が得点になる
* 他には最終発表での得点も
* **研修なので好きにやっていい**
  + Clojureで書くことに
* サーバーの他は広告主データと学習用データが与えられる


===
&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/92I5tQt6q6IjII&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/prir/ss-35918532&#34; title=&#34;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&#34; target=&#34;_blank&#34;&gt;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/prir&#34; target=&#34;_blank&#34;&gt;CyberAgent, Inc.&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

===
# 作るもの
---------

* 競りの通知を受け取って入札するJSON REST API
* 落札の通知を受け取るJSON REST API
  + 割とシンプル
* 「一番コスパが良さそうな広告を選ぶ」部分は色々と工夫する
* 今回は広告を出すところまではやらない
* クリック情報は落札通知に入ってる

===
# b11dについて
-------------

* 今回作ったDSP
* [KeenS/b11d](https://github.com/KeenS/b11d)
* Clojure製
* 5日くらいで作った
* あまりゴテゴテしない方針
  + 今回パフォーマンスは無視していい
  + Clojureに慣れてないので学習コストも抑えたい
* NginXとAppとMySQL構成+α
* DBは綺麗に設計したい
* 1リクエスト毎にDBを引きにいく素敵仕様

===
# WAP
-----

* Compojure
* Sinatra likeなやつ
* ringの上に乗っかてる
* かなりシンプルな部類だがJSON REST API程度ならこれで十分
* ringミドルウェアのでJSON部分も抽象化
* 学習コストが低いので気軽に始められる

===
# JSONライブラリ
--------------

* ring.middleware.json/wrap-json-{body, response}
  + JSON-&gt;マップとマップ-&gt;JSON
  + bodyの方はキーがStringになるのが微妙
    - セキュリティ的に仕方ない
  + Content-Typeを指定しないと動かない罠
* cheshire
  + 事前データをインポートするのに使った
  + ringのJSONミドルウェアの依存なのでそのまま使った
  + 自然で使い易いAPI

===
# データベース接続
----------------

* java.jdbc
* JDBCのClojure向けラッパ?
* DataSourceを自分で渡すのでコネクションプールも簡単
* SQL手書きしたら良い感じにマップを返してくれる
* Storeはカラムと値の対応を手書き
* 便利マクロもいくつか

===
# データベース接続
----------------

* eager loading面倒問題
  + 入れ子オブジェクトを保存する方も面倒だった
  + ORMの便利さを実感。
* bulk insert難しい問題
  + 実行時可変長引数難しい
* ORMはXXXを使うかJavaのやつをそのまま使う?
* JavaはXMLさえ我慢すれば割と良い奴揃ってる
* しかしレスポンスはマップで欲しいかも

===
# 運用
-----

* warに固めてTomcat vs スタンドアロンなfat jar
* 今回はfat jarを選択
* スタンドアロンだとsupervisordとかでの管理が楽
* Tomcatの運用経験がない
* Jetty中々優秀らしい
* jstatを使ってMackerelでメトリクス取った

===
# 非同期化
---------

* core.async/goで手軽に非同期
* DBへの書き込みを非同期にした
* DB書き込みでエラーが出ても500にならない恐怖
* 最初の方で支払いを記録出来てなくて予算管理が死亡
  + 予算管理失敗ペナルティで、大分点数引かれたらしい
* goroutineでの例外処理どうやるんだろう。

===
# 開発環境
---------

* nREPL + Emacs + CIDER
* 補完の設定上手くいかなかった
* 諸々地味に不便
* 起動遅い
* Emacs側からnREPL立ち上げたい
* サーバーのライブリロード欲しい
* 正解が欲しい


===
# その他Clojureについて
---------------------

* コンスのCarを取るのに`hd`か`head`か`car`か分かんなかった
  + 結局どれでもなくて`first`だった
* 引数のパターンマッチが便利
  + JSON REST APIだとリクエストに何を期待してるのか分かりづらい
  + パターンマッチがドキュメントになる
* やっぱJavaのライブラリ使えるの便利

===
# 落穂拾い
---------

* デプロイにはシェルスクリプト
  + お家芸
* 「一番コスパが良さそうな広告を選んで入札」で統計か機械学習が必要
  + 1回表示した時の収益の期待値を計算する
* 今回は事前データの統計を使った
  + 理想的には機械学習。時間変化についていける
* In Appでオンライン学習出来るライブラリが思ったよりない
  + 分散処理向けの大袈裟なのが多い
  + Weka? liblinear-java?
* 後で考えたらIncanter使えばよかった

===
# まとめ
-------

* 給料貰いながらLisp書いた
* ClojureでDSP作った
* Clojureで機械学習したかったけど間に合わなかった

===
# 参考
------

* [Internal of b11d | κeenのHappy Hacκing Blog](//KeenS.github.io/slide/Internal_of_b11d/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>