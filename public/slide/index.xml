<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Slides on κeenのHappy Hacκing Blog</title>
    <link>//KeenS.github.io/slide/</link>
    <description>Recent content in Slides on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Mon, 18 Nov 2019 15:28:52 +0900</lastBuildDate>
    
	<atom:link href="//KeenS.github.io/slide/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>安全なシステムプログラミング言語Rustへの招待</title>
      <link>//KeenS.github.io/slide/anzennashisutemupuroguramingugengorusthenoshoutai/</link>
      <pubDate>Mon, 18 Nov 2019 15:28:52 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/anzennashisutemupuroguramingugengorusthenoshoutai/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS GitLab: blackenedgold Idein Inc.のエンジニア   2年半くらい仕事でRustを書いている   Lisp, ML, Rust, Shell Scriptあたりを書きます 実践Rust入門の共著者  ===
Rustって言語があるよ   システムプログラミング言語 2015年に1.0.0がリリース   リリース前に破壊的変更しまくったので1.0以降はかなり安定してる 0.x時代はもちろんのこと、1.0-alphaのあとに1.0-alpha2が出たりもした   6週間毎にコンパイラのリリースで、今は1.39.0 C++03, C++11 みたいなノリでRust 2015とRust 2018の2つの仕様がある  コンパイラはずっと両方サポート    ===
事例   firecracker: AWS Lambdaのセキュアコンテナ Magick Pocket: DropBoxのストレージマネージャ。 Servo: Mozillaの新ブラウザエンジンの実験プロジェクト。一部の成果がFirefoxに反映されている。 Redox: OS TiKV: KVS  ===
システムプログラミング言語っぽさ   ランタイムレス  でもメモリは自動管理   Cと相互に連携できる  C FFIだけでなくCからRustも呼べる   それっぽいプロジェクトもいくつか  libpnet: 生パケット扱うライブラリ awesome-embedded-rust: 組み込み系のキュレーション tokio: 非同期イベントループのライブラリ    ===</description>
    </item>
    
    <item>
      <title>その正規表現エンジン、インタプリタで満足してる？！</title>
      <link>//KeenS.github.io/slide/sonoseikihyougenenjin_intapuritademanzokushiteru__/</link>
      <pubDate>Fri, 18 Oct 2019 02:47:52 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/sonoseikihyougenenjin_intapuritademanzokushiteru__/</guid>
      <description>κeen @blackenedgold Github: KeenS GitLab: blackenedgold Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
今日話すこと   SATySFi 部分評価と二村射影 多段階計算 (正規表現のコンパイル)  ===
SATySFi   政府の支援によりTeXを倒すために作られた組版処理系  ※多少の誇張を含みます   日本語が扱えて、PDFを直接吐ける ML系の言語で拡張ができる  静的に型が付く   ↓ 作者  ===
Hello SATySFi  @require: stdjareport let-inline \show-int n = embed-string (arabic n) in document (| title = {サンプル文書}; author = {組 版太郎}; |) &amp;#39;&amp;lt; +p { 答え: \show-int(42); } &amp;gt; ===</description>
    </item>
    
    <item>
      <title>Idrisの話とIdris2のウワサ</title>
      <link>//KeenS.github.io/slide/idrisnohanashitoidris2nouwasa/</link>
      <pubDate>Sat, 21 Sep 2019 22:11:57 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/idrisnohanashitoidris2nouwasa/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS GitLab: blackenedgold Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
Idris   Edwin Brady 2013 〜 証明支援系ではなくてプログラミング言語 依存型のあるHaskell Eager Evaluation コンパイルするとバイナリが出る  C経由 JSバックエンドなども    ===
Hello, Idris  main : IO () main = putStrLn &amp;#34;Hello&amp;#34;  $ idris -o hello hello.idr $ ./hello &amp;quot;Hello&amp;quot; ===
依存型   値を型に書ける  data Vect : (len : Nat) -&amp;gt; (elem : Type) -&amp;gt; Type where Nil : Vect Z elem (::) : (x : elem) -&amp;gt; (xs : Vect len elem) -&amp;gt; Vect (S len) elem  v : Vect 3 Int v = [1, 2, 3] ===</description>
    </item>
    
    <item>
      <title>Effective Idris: Effects</title>
      <link>//KeenS.github.io/slide/effective_idris__effects/</link>
      <pubDate>Sat, 25 May 2019 15:27:24 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/effective_idris__effects/</guid>
      <description>κeen @blackenedgold Github: KeenS GitLab: blackenedgold Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
今日の話   Effectのハンドラを自分で書く  ===
Effectsって？   Idrisの標準添付ライブラリ Algebraic Effectの実装ライブラリ  Eff言語のEffectを参考に設計したらしい   IOとかRandomとかStateとか色々あるよ  ===
使ってみよう  Step 1
.ipkgに effects を足す
package hoge version = &amp;quot;0.1.0&amp;quot; -- .. -- これ pkgs = effects ===
使ってみよう  Step 2
Effectsをインポート
module Main import Effects import Effect.StdIO ===
使ってみよう  Step 3</description>
    </item>
    
    <item>
      <title>Rustから扱うAWS API</title>
      <link>//KeenS.github.io/slide/rustkaraatsukauaws_api/</link>
      <pubDate>Tue, 12 Mar 2019 00:23:17 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/rustkaraatsukauaws_api/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS GitLab: blackenedgold Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
AWSとは   https://aws.amazon.com/jp/   アマゾン ウェブ サービス（AWS）は、信頼性と拡張性に優れたクラウドコンピューティングサービスを低料金で提供して(中略)います。
  クラウドサービス = オンデマンドの利用 + API (私見) AWSは豊富なサービスとそれを叩けるAPIが用意されている  ===
===
AWS SDK   AWSが公式にAPIバインディングを用意してくれている 残念ながらRustは入ってない  ===
Rusoto   ドキュメント RustのAWS APIバインディング 公式ではない PythonのSDKから自動生成 rusotoのユーザが増えるとAWSから公式サポートくるかも  → みんなRustからAWS API叩こう   初見だと圧倒される  → ===    ===</description>
    </item>
    
    <item>
      <title>void</title>
      <link>//KeenS.github.io/slide/void/</link>
      <pubDate>Wed, 16 Jan 2019 08:35:35 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/void/</guid>
      <description>κeen @blackenedgold Github: KeenS GitLab: blackenedgold Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます ===  発散型   ! ドキュメント  標準ライブラリだと exit とか 他には無限ループ、パニック、 return`/continue` など   呼び出し元に制御が返らない どんな型にもなれる  ===
発散型  usestd::process::exit;// pub fn exit(code: i32) -&amp;gt; ! lethoge: i32 =exit(0);letfuga: ()=exit(0);===
match と型   match の返り値は腕の型で決まる 発散型と他の型の組み合わせだと他の型になる  letpiyo: i32 =match0{// ! 0=&amp;gt;exit(0),// i32 n=&amp;gt;1i32,};===
Void  enum Void{}===
Void   バリアント(=コンストラクタ)がない  値を作れない   もしその値を受け取れるとしたらどうなる？  ===</description>
    </item>
    
    <item>
      <title>イマドキと言われる言語機能について</title>
      <link>//KeenS.github.io/slide/imadokitoiwarerugengokinounitsuite/</link>
      <pubDate>Fri, 11 Jan 2019 00:34:20 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/imadokitoiwarerugengokinounitsuite/</guid>
      <description>κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア  情報科学の教育は受けていない純粋なエンジニア   実際に仕事で使った(ている)のはJava, Scala, Rust  ===
最近っぽい言語     言語 1.0リリース 特徴     Go 2012 goroutineが使えるシンプルな言語   Rust 2015 安全なシステムプログラミング言語   Swift 2014 iOSアプリが作れる   Scala 2004 関数型パラダイムを取り入れたJVM言語   Kotlin 2016 整理されたJava    ===
最近のトレンド   静的型付言語が増えてきた  動的型付言語が主流だった反動？   静的コンパイルする言語が増えてきた インタプリタ言語にも速度が求められるようになってきた 関数型言語の機能を取り入れるようになってきた 速度やマルチコア対応が気にされ始めた マルチタスクのサポートが増えてきた  ===</description>
    </item>
    
    <item>
      <title>Common Lispの多値とその実装達</title>
      <link>//KeenS.github.io/slide/common_lispnotachitosonojissoutachi/</link>
      <pubDate>Thu, 15 Nov 2018 22:55:10 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/common_lispnotachitosonojissoutachi/</guid>
      <description>κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
今日話すこと   多値のこと Common Lispの多値のこと Common Lispの多値の実装のこと  ===
引数と返り値の数  ===
MLの引数   複数引数に見えるがタプルを1つ取っている  fun foo(v1, v2) = v1 + v2  複数引数と違うの？  違う いい悪いではなく違う。    val tuple = (1, 2) foo tuple (* -&amp;gt; 3 *) ===
Lispの多値   複数の値を返せる  CL-USER&amp;gt; (values 1 2) 1 2  タプルと違うの？  違う いい悪いではなく違う。    CL-USER&amp;gt; (identity (values 1 2)) 1 ===</description>
    </item>
    
    <item>
      <title>WebAssemblyとABI</title>
      <link>//KeenS.github.io/slide/webassemblytoabi/</link>
      <pubDate>Sat, 10 Nov 2018 00:49:26 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/webassemblytoabi/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
WebAssmblyとは   Webブラウザで動く アセンブリ ではない  ===
WASMの動作環境   ブラウザ NodeJS CommonWA losfair/IceCore : Build efficient and reliable backend applications in WebAssembly. Introducing Wasmjit: A kernel mode WebAssembly runtime for Linux | Packt Hub piranna/wasmachine: Put WebAssembly in your washing machine  ===
言語としてのWASM   アセンブラっぽい雰囲気 スタックマシン 無限のレジスタ(変数)とスタックがある コードの単位は関数 上位にモジュールがある モジュール毎に1仮想マシン(インスタンス)  ===</description>
    </item>
    
    <item>
      <title>Rust around you</title>
      <link>//KeenS.github.io/slide/rust_around_you/</link>
      <pubDate>Sun, 07 Oct 2018 12:38:57 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/rust_around_you/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
Rust   安全なC++ ML/Haskellみたいな機能  タプル 代数的データ型 トレイト 式指向    ===
みなさんの脳にRustを叩き込みます===
Rustは色々な領域で使われている   OS ネットワーク ブラウザ コンパイラ WebAssembly マイコン VCS  ===
Rustは色々な領域で使われている   CLI ウェブアプリケーション DB ゲーム 暗号通貨 GPU  ===
OS   redos: フルセットのOS  tfs: zfs的なの。並行で動く。 ion: シェル orbital: Windowシステム   intermezzOS: 小さいOS Writin an OS in Rust  RustでOSを書くチュートリアル 30日OS本みたいなの    ===</description>
    </item>
    
    <item>
      <title>Futureとその周辺</title>
      <link>//KeenS.github.io/slide/futuretosonoshuuhensa_bei/</link>
      <pubDate>Fri, 05 Oct 2018 19:55:29 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/futuretosonoshuuhensa_bei/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます 言語処理系と継続が好き 科学っぽい話はできないです &amp;gt;&amp;lt;  ===
背景   非同期計算を上手く扱いたい 色々あるけど難しい 似て非なるものを同じ名前で呼んでて紛らわしい 全体を俯瞰したい  ===
同期計算   同期IO処理はその処理が終わるまで待つ 待ってる間が無駄  ===
非同期計算   待ってる間別のことをやりたい 処理の切り替えどうするの  ===
非同期計算   (限定)継続が取り出せればいい 解決！  ===
限定継続   多くの言語では限定継続は扱えない  Schemeなら簡単なんだけどねー   CPS変換すれば限定継続じみたことができる  要はコールバック形式    ===
問題意識   コールバック地獄 デッドロック  ===</description>
    </item>
    
    <item>
      <title>Inside Pattern Matchings</title>
      <link>//KeenS.github.io/slide/inside_pattern_machings/</link>
      <pubDate>Sun, 16 Sep 2018 01:26:15 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/inside_pattern_machings/</guid>
      <description>===
About Me   κeen ちゅーんさんだよー @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
===
発表について   元ネタ Optimizing Pattern Matching (Fabrice Le Fessant, Luc Maranget) 自作SMLコンパイラにパターンマッチを入れようとしたら難しかった  「コードを生成」が割と厄介 次の中間言語の設計に影響を与える  というか専用の中間言語作るくらいの心意気が必要      ===
発表について   既存手法を調べたら非自明だった  → 既存手法の紹介だけでも価値がありそう → 発表するか (本当は実装までしたかったけど進捗だめです)   変数束縛の話はしない  ワイルドカードで我慢して    ===
パターンについて   パターンは値の集合にマッチする ワイルドカードパターンがある 直積にマッチするときは 横 に伸びる 直和にマッチするときは 縦 に伸びる パターンをネストするときは 奥 に伸びる パターンが 網羅的 であるかに関心がある 複数マッチする場合は最初のものにマッチする  ===</description>
    </item>
    
    <item>
      <title>Rustのこれまでとこれから</title>
      <link>//KeenS.github.io/slide/rustnokoremadetokorekara/</link>
      <pubDate>Sat, 25 Aug 2018 16:09:33 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/rustnokoremadetokorekara/</guid>
      <description>Rustこれまでとこれから&amp;lt;!&amp;ndash; .element: style=&amp;quot;font-size: calc(var(&amp;ndash;title-font-size) * 0.8)&amp;quot;&amp;ndash;&amp;gt;  Learn Languages 2018 in ODC (LL2018) 
===
About Me   κeen ちゅーんさんだよー @blackenedgold Github: KeenS Idein Inc.のエンジニア   Rustで開発してるよ   Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
今日話すこと   X Rustの勉強法 X Rust言語の紹介 O Rustの歩み O Rustの開発体制  ===
Rustとは   システムプログラミング言語 安定性、信頼性が売り 2015年に1.0リリース  いつまで20年ものの言語使ってるの   大体の便利な言語機能を取り入れてる 所有権システムにより GCがない  コンパイラが free を自動挿入    ===</description>
    </item>
    
    <item>
      <title>Rustと3種のDSL</title>
      <link>//KeenS.github.io/slide/rustto3tanenodsl/</link>
      <pubDate>Sun, 01 Jul 2018 21:58:14 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/rustto3tanenodsl/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
DSLとは  Lispでは，プログラムをただプログラミング言語に従って書くことはしない． プログラミング言語を自分の書くプログラムに向けて構築するのだ &amp;ndash; Paul Graham (On Lispより)
 ===
DSLとは   ドメイン特化言語 自分の解きたい問題に合わせてミニ言語を作る  関心に集中 言語を設計することでドメインへの考察が深まる   2種類ある  内部DSL: ホスト言語の式でそれっぽく作る 外部DSL: 外部化してパーサから作る   まずは内部DSLを検討しよう  ===
DSLの使いどころ   だいたい以下の条件   素直に書くと記述が多い 細かなバリエーションがあって関数一つにはまとめられない → スイートスポットがDSL   典型的にはビジネスロジックとか  ===
Actcast   Idein社で開発中のサービス IoTデバイスを管理する  人、管理グループ、デバイス、アプリケーションなどエンティティが多め   APIはOpen API(旧Swagger)を使う まだ開発中  一緒に開発してくれる人募集してます!</description>
    </item>
    
    <item>
      <title>nom勘所</title>
      <link>//KeenS.github.io/slide/nomkandokoro/</link>
      <pubDate>Tue, 26 Jun 2018 16:02:24 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/nomkandokoro/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
nom   GitHub マクロベースのパーサコンビネータ ゼロコピー、速い、バイト指向  ===
nomの使い方   ドキュメントに大量にパーツがあるので分かりづらい 基本的なパーツは以下  named! - パーサを定義 do_parse! - 連接 alt(_complete)! - 選択 tag! - トークン map! - 型変換   1データ型1パーサくらいの感覚 あとは必要に応じて覚える  似たような実装を探して真似る    ===
例: 四則演算  まずは列挙型を定義
#[derive(Debug, Clone, PartialEq)]enum Expr{BinOp(BinOp),Number(Number),}===
例: 四則演算  対応するパーサをalt!で定義
named!(expr&amp;lt;&amp;amp;str,Expr&amp;gt;,alt_complete!(map!(binop,Expr::BinOp)|map!(number,Expr::Number)));===</description>
    </item>
    
    <item>
      <title>GCと1bit</title>
      <link>//KeenS.github.io/slide/gcto1bit/</link>
      <pubDate>Sun, 24 Jun 2018 15:11:23 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/gcto1bit/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます 言語処理系が好き  ===
GCと(メタ)情報   レジスタ/スタック上の値のpointer or not Mark and Sweepのマーク ヒープ上オブジェクトの「どこにポインタがいるか」  これらを節約する話
===
レジスタ中のポインタ   レジスタ上の値がポインタか数値か  GCのrootsetなので判断が必要 1bitの情報量が必要   多くはLSBをタグに使う  ポインタは0  4バイトアラインメントされてると自然にそうなる   数値は1にする  数値が31bit/63bitになる タグを外して計算して戻すので遅い     bit stealしない方法は？  ===
レジスタ分別   レジスタを半分に分ける  片方はポインタ用 もう片方は値用   物理的に1bit取らなくても1bitの情報量が確保できる ただしレジスタが多いアーキじゃないと死ぬ  ===</description>
    </item>
    
    <item>
      <title>オブジェクト指向言語と関数型言語</title>
      <link>//KeenS.github.io/slide/obujiekutoshikougengotokansuugatagengo/</link>
      <pubDate>Wed, 14 Mar 2018 22:22:40 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/obujiekutoshikougengotokansuugatagengo/</guid>
      <description>はじめに   椅子のキーストラップは是非お持ち帰り下さい 主にプログラミング言語を1つ覚えたくらいの人を対象にしています トークで40分全部使い切る予定なので質問はこのあとの職員室でお願いします たまに細かい話が出てきますがスルーして下さい  主に重箱の角をつつく人への対策です    ===
 MANABIYA 2日目5時間目@ギャラリーB
#manabiya
===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア 言語処理系を作るのが好き 仕事での経験: Java, Scala, Rust 趣味: C, Common Lisp, Standard ML, Rust  ===
話すこと   オブジェクト指向/関数型&amp;quot;プログラミング&amp;quot;とはパラダイムのことだよ オブジェクト指向/関数型&amp;quot;言語&amp;quot;とはそのパラダイムを支援する言語のことだよ 言語とパラダイムの区別を明確に！  ===
理想のソフトウェア   変更に強いソフトウェア バグの少ないソフトウェア 凝集度を高めて結合度を低めたい  似たようなものは同じところに 互いの依存関係を減らす   理想のソフトウェアを作るには？  ===
パラダイム   Wikipedia プログラミングにおける思考のフレームワーク  一貫性の取れた設計 組み合わせたときの相性の良さ 一度理解するとその後の学習コストが下がる   特定の言語に依存しない概念 ある程度成功しやすい手法のパターン化  ===</description>
    </item>
    
    <item>
      <title>Rust &amp; Swagger</title>
      <link>//KeenS.github.io/slide/rust___swagger/</link>
      <pubDate>Mon, 18 Dec 2017 19:35:19 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/rust___swagger/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
Swagger   The World&#39;s Most Popular API Tooling JSON APIの定義からドキュメントとコードを生成  ===
rust-server   最近Rustのサポートが入った 軽くデモ  petstore   issueなげよう  </description>
    </item>
    
    <item>
      <title>1ML - コア言語とモジュール言語の統合</title>
      <link>//KeenS.github.io/slide/1ml___koagengotomoju_rugengonotougou/</link>
      <pubDate>Sun, 24 Sep 2017 23:23:57 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/1ml___koagengotomoju_rugengonotougou/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます 型システム初心者です 論文初心者です ===  MLのモジュールについておさらい ===
モジュール、シグネチャ   ストラクチャは型、関数、値をまとめたもの  なんかレコードっぽい   シグネチャはその型 モジュールはシグネチャを充足すればよい（余計なフィールドがあってもよい）  もちろん余計なフィールドは隠蔽される ===    signature S = sig type t val f: t -&amp;gt; t val zero: t end structure M: S = struct type t = int fun f x = x val zero = 0 fun g x = x end ===</description>
    </item>
    
    <item>
      <title>最近のSML#の話題</title>
      <link>//KeenS.github.io/slide/saikinnosml_nowadai/</link>
      <pubDate>Mon, 17 Jul 2017 21:04:57 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/saikinnosml_nowadai/</guid>
      <description>κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
話すこと   SML# 3.0。0以降立て続けにリリースが続いてる 最近の変更を追いきれないのでまとめて追う     ver. date     3.3.0 2017-06-20   3.2.0 2016-09-16   3.1.1 2016-07-15   3.1.0 2016-05-26   3.0.1 2016-04-04   3.0.0 2016-03-31   2.0.0 2014-04-04   1.2.0 2012-11-14    ===
そもそもSML#って？   SML &amp;lsquo;97 互換のコンパイラ  The Definition of Standard ML, Revised Self Hosted 2.</description>
    </item>
    
    <item>
      <title>ジェネリクス ディスパッチ 表裏</title>
      <link>//KeenS.github.io/slide/jienerikusu_disupatchi_omoteura/</link>
      <pubDate>Sat, 17 Jun 2017 22:25:35 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/jienerikusu_disupatchi_omoteura/</guid>
      <description>ジェネリクス ディスパッチ 表裏  ジェネリクス勉強会 - connpass
===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
はじめに   例にはJavaとRustを使います  それ以外にあまり詳しくない たまにScalaが出てくるかも   主に裏側で何が起きてるかに焦点を当てます 一般的な手法の比較と言語固有実装の比較がやや混じります  実例重視   言語や機能を選ぶときの知識が増えればよし  ===
ジェネリクス   型でパラメータ化された何か パラメータ化する方法にいくつか方式が  任意の型に対応する実装にする  Java   使う型毎に実体をつくる  型が引数になるイメージ Rust     便宜上前者をポインタ方式、後者をテンプレート方式と呼ぶ  ===
関数ジェネリクス   Javaコード  public class Generics { public static void main(String[] args) { Generics g = new Generics(); System.</description>
    </item>
    
    <item>
      <title>ソフトウェアエンジニアがFPGAやってみる</title>
      <link>//KeenS.github.io/slide/sofutoueaenjiniagafpgayattemiru/</link>
      <pubDate>Tue, 28 Mar 2017 09:21:33 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/sofutoueaenjiniagafpgayattemiru/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
よくある話  ===
FPGAって？   Field-Programmable Gate Array プログラマブルな集積回路  オレオレ設計のCPU作ったり HDMI入力を直でmpg4にエンコードするデバイスとかも   クロックはASIC(ふつうのCPU)より大分遅い でも上手く嵌れば100倍高速化とか  ===
PYNQって？   PYNQ-Z1 Python Productivity for Zynq - Digilent xilinxのFPGAとARMのチップが載ったSoC ARMで動いてるPython(Jupyter)からFPGAにロジック焼ける  手軽にロジックを試せる   FPGAとの通信はMMIO  特定のアドレスのメモリにデータを書くとFPGAに送られる メモリのデータを読むとFPGAからデータが送られる    ===
===
ハードウェアロジック   ハードウェア記述言語(HDL)を使う  メジャーなのはVHDLとVerilog 今回はVerilogの話   クロックとかレジスタとかワイヤーとか駆使する 電気信号なのでロジックが並列で走る vivadoというツールでコンパイル  Tclで制御も出来る   回路設計とかも コンパイルは結構遅い… CPUと通信するときの規格とかも書かなきゃいけない  AXI LiteとかAXI Fullとか… 一応自動で生成はしてくれる    ===</description>
    </item>
    
    <item>
      <title>Rust in Production</title>
      <link>//KeenS.github.io/slide/rust_in_production/</link>
      <pubDate>Wed, 22 Mar 2017 19:57:28 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/rust_in_production/</guid>
      <description>===
About Me   κeen 若者 @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
Rust採用までの流れ  Ω＜「κeen君継続的ベンチマークサーバ作って」Ω＜「GitHubにpushする度ベンチマーク走る感じで」Ω＜「GPUとRaspberry Piでベンチマークするから」Ω＜「全部任せるね」⸜( ¯⌓¯ )⸝「Rustで書くか」やったこととか知見とかトピック毎にかいつまんで話します
===
Rustのメリット   κeenが馴れてる 社員の半分くらい書ける Linux, Mac, Raspberry Piで動く テスト書かなくてもそんなにバグらなそう 将来のために小さいところでノウハウ溜めていきたい シングルバイナリで楽に動きそう 単純に使いたかった ※今回は速度や安全性は必要ない  ===
コンポーネント   CLIクライアント  各自の手元やCIサーバから起動   アグリゲータ  ワーカに仕事を投げ、結果を受け取る ジョブ管理   ワーカ  GPUマシンやRSPiなどでベンチマーク 結果をアグリゲータに返す   ブラウザ  ベンチマーク結果の閲覧    ===
プロジェクト構成   ワークスペースを使ってサブプロジェクトに分割  モノリシックだとビルドが重かった targetは全てのプロジェクトで共有する   CLI, aggregator, worker, browserの他にmodel, api modelはaggregatorとbrowserで共有 apiはaggergatorとcliとworkerで共有 コード  ===</description>
    </item>
    
    <item>
      <title>仕事でdiesel使ってみた</title>
      <link>//KeenS.github.io/slide/shigotodedieseltsukattemita/</link>
      <pubDate>Wed, 01 Mar 2017 10:57:38 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/shigotodedieseltsukattemita/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
diesel.rs ===
diesel   RustのORM  スキーマからコード自動生成 diesel_codegen   クエリビルダ マイグレーション管理 PostgreSQL, MySQL, SQLiteサポート  ===
準備   docker-composeでmysql &amp;amp; postgreSQL をサクッと起動 - Qiita  cargo install diesel_cli echo DATABASE_URL=postgres://username:password@localhost/hoge &amp;gt; .env diesel setup diesel migration generate create_posts ===
準備  [dependencies] chrono = &amp;#34;0.3.0&amp;#34; diesel = {version = &amp;#34;0.</description>
    </item>
    
    <item>
      <title>WebAssemblyとコンパイラとランタイム</title>
      <link>//KeenS.github.io/slide/webassemblytokonpairatorantaimu/</link>
      <pubDate>Thu, 16 Feb 2017 15:46:21 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/webassemblytokonpairatorantaimu/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
何の話   WebAssemblyをバックエンドに使う言語を作りたい KeenS/webml: An ML like toy language compiler 既に発表したものの補足記事的な  コンパイラの人からみたWebAssembly | κeenのHappy Hacκing Blog ある程度再度説明します    ===
アジェンダ   なぜWebAssembly コンパイラ コード生成 ランタイム  ===
なぜWebAssembly ===
なぜWebAssembly   なんかバイナリでテンション上がる ポータブルでコンパクトで速い 機能的にJSを越えるかもしれない…？ コンパイラがブラウザで動くと言語導入のハードル下がる  気軽に試せる コンパイラだけでなく吐いたコードもブラウザで動かしたい    ===
WASM over LLVM   既存のJS環境と協調する  JSとの相互呼び出しとか   non-determinismが少ない 細かいアラインメント考える必要がない API安定しそう  ===</description>
    </item>
    
    <item>
      <title>コンパイラの人からみたWebAssembly</title>
      <link>//KeenS.github.io/slide/konpairanoninkaramitawebassembly/</link>
      <pubDate>Sun, 22 Jan 2017 13:35:46 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/konpairanoninkaramitawebassembly/</guid>
      <description>コンパイラの人からみたWebAssembly  コンパイラ勉強会 - connpass
===
About Me   κeen @blackenedgold Github: KeenS Idein Inc.のエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
アジェンダ   WebAssemblyの概要 具体的な話 WebAssembly吐こうとした話  ===
WebAssemblyの概要 ===
JavaScript   ブラウザ上で動くスクリプト言語 動的型付 高級 GCとかある 今までブラウザで動く唯一の言語だった 遅い  各ブラウザJITなどで補強    ===
asm.js   プラウザ上で動く言語 低級 GCなし JSのサブセット  asm.jsをサポートしないプラウザでも動かせる   コンパイラから生成されることを想定  emscriptenなど    ===
function geometricMean(start, end) { start = start|0; // start has type int  end = end|0; // end has type int  return +exp(+logSum(start, end) / +((end - start)|0)); } .</description>
    </item>
    
    <item>
      <title>SchemeでClassとProtocol</title>
      <link>//KeenS.github.io/slide/schemedeclasstoprotocol/</link>
      <pubDate>Mon, 28 Nov 2016 15:41:36 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/schemedeclasstoprotocol/</guid>
      <description>κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
Class   ここでは単に値の集合を表わす new のように新しいインスタンスを作る機能はつけない ほとんど型と同じ機能 唯一の機能 instance? を持つ  ===
(instance? 3 &amp;lt;number&amp;gt;) ; =&amp;gt; #t (instance? &amp;#34;foo&amp;#34; &amp;lt;number&amp;gt;) ; =&amp;gt; #f ===
Classの実装   事実上述語があればいい 詳細  (define-class &amp;lt;any&amp;gt; (lambda (x) #t)) (define-class &amp;lt;list&amp;gt; list?) (define-class &amp;lt;procedure&amp;gt; procedure?) (define-class &amp;lt;number&amp;gt; number?) ===
Classの用途   述語だけで意味ある？  プリミティブにのみあった述語をユーザが拡張出来る   その上に何かを構築出来る protocolとか  ===</description>
    </item>
    
    <item>
      <title>Rustで非同期Thriftしたい</title>
      <link>//KeenS.github.io/slide/rustdehidoukithriftshitai/</link>
      <pubDate>Sat, 26 Nov 2016 13:07:29 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/rustdehidoukithriftshitai/</guid>
      <description>Rustで非同期Thrift  歌舞伎座.tech#12「メッセージフォーマット/RPC勉強会」 - connpass
===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
 XRPCライブラリを使う話 ORPCライブラリを作る話  ===
RPC   Remote Procedure Call リモートで呼べる 言語跨げる シリアライズフォーマットが決まれば大体出来る Thrift, protobuf/gRPC, avro&amp;hellip; 大抵バイナリ  JSONに比べて2倍くらい効率がいい    ===
Thrift   Facebook発(現apache)RPCフレームワーク IDLから複数の言語向けのコードを吐ける 対応言語多い 新しい言語はthriftレポジトリフォークして追加  ===
Thrift vs gRPC     \ Thrift gRPC     ベース 自前 HTTP/2   コード生成 o o   プロトコルのアップデート o o   通信の多重化 トランスポート次第 o (HTTP/2)   認証 x o   例外 ユーザ定義可能 事前定義のみ?</description>
    </item>
    
    <item>
      <title>Rustの話とリソースの話</title>
      <link>//KeenS.github.io/slide/rustnohanashitoriso_sunohanashi/</link>
      <pubDate>Sun, 20 Nov 2016 14:08:07 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/rustnohanashitoriso_sunohanashi/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 若者 サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます プログラミング言語Rustの翻訳 Join rust-jp on Slack! にもいます。 Rust その2 Advent Calendar 2016 - Qiita  ===
注意   たまにマニアックな話が出ますが気にせず無視して下さい 「なんかRustすげー」って思ってもらえれば幸いです  ===
Rustとの出会い   元々Lisperだった 他にはML, Ruby, JVM言語など  ===
===
「Lisperは自分で処理系作って一人前」===
===
苦悩   Cは低級すぎる Javaは向いてない C++は怖そう  闇の軍団 縄文土器飛んできそう あと nullあるしメモリ破壊あるし   MLは向いてるけどシステムプログラミングしづらい ATS2, Golang, D&amp;hellip;  ===
Rustと出会う   正直最初は色物言語と思ってた 調べてみたら気に入った  ===</description>
    </item>
    
    <item>
      <title>Scala 2.12.0変更点</title>
      <link>//KeenS.github.io/slide/scala_2_12_0henkouten/</link>
      <pubDate>Fri, 04 Nov 2016 13:19:01 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/scala_2_12_0henkouten/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS AI Studio Dev Group Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
サマリー  全部公式ページに詳細あるよ
 Java8向けの互換性向上したよ  トレイトがinterfaceに 無名関数がlambdaに SAMとScalaの関数が統合   コンパイラが少し賢くなったよ  いくつかでinvokedynamicを使うように 中間状態をやめた 最適化をするように   ライブラリ改善した  EitherがRight Biasedに Futureが強化   非互換いくつか  ===
トレイトがinterfaceに  trait Foo { def foo(): String = &amp;#34;foo&amp;#34; def bar(): String } ===
トレイトがinterfaceに  $ scalac-2.11 Trait.scala $ ls Foo$class.</description>
    </item>
    
    <item>
      <title>正しいScalaのコードが欲しい</title>
      <link>//KeenS.github.io/slide/tadashiiscalanoko_dogahoshii/</link>
      <pubDate>Wed, 05 Oct 2016 00:10:25 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/tadashiiscalanoko_dogahoshii/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 基盤開発グループ Lisp, ML, Rust, Shell Scriptあたりを書きます  Scalaはあんまり ===    Scalaを始めたばかりの頃の話 ===
def revappend[A]( xs: List[A], ys: List[A]): List[A] = match xs { case Nil =&amp;gt; Nil case x::xs_ =&amp;gt; revappend(xs_, x::ys) } ===
def length(xs: List[_]): Int = xs match { case Nil =&amp;gt; Nil case x::xs_ =&amp;gt; 1 + length(xs_) } ===
def append[A]( xs: List[A], ys: List[A]): List[A] = xs match { case Nil =&amp;gt; Nil case x::xs_ =&amp;gt; x :: append(xs_, ys) } append(List(1, 2, 3), List(4, 5, 6)) // =&amp;gt; List(1, 2, 3)  ===</description>
    </item>
    
    <item>
      <title>型クラスを越えて</title>
      <link>//KeenS.github.io/slide/katakurasuwokoete/</link>
      <pubDate>Sat, 16 Jul 2016 02:53:49 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/katakurasuwokoete/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
Rustとは   システムプログラミング言語 GCなし！でもメモリ管理は自動 Zero-Cost Abstraction Trait-Based Generics パターンマッチ、代数的データ型などなど プログラミング言語Rust  ===
Rustのトレイト的なの   型に固有のメソッド  オブジェクト指向的な   トレイト  型クラス    ===
型クラスじゃない方  struct Person{name: String,}implPerson{// Static constructor fn new(name: String)-&amp;gt; Self{Person{name: name}}// method fn hello(&amp;amp;self){println!(&amp;#34;Hello, {}&amp;#34;,self.name);}}===
letperson=Person::new(&amp;#34;κeen&amp;#34;);person.hello();===
多相型と制約  struct Temp&amp;lt;T&amp;gt;(T);impl&amp;lt;T: Celsius&amp;gt;Temp&amp;lt;T&amp;gt;{fn fromCelsius(t: isize)-&amp;gt; Self{Temp(Celsius(t))}}impl&amp;lt;T: Fahrenheit&amp;gt;Temp&amp;lt;T&amp;gt;{fn fromFahrenheit(t: isize)-&amp;gt; Self{Temp(Fahrenheit(t))}}===</description>
    </item>
    
    <item>
      <title>Socket on SML#</title>
      <link>//KeenS.github.io/slide/socket_on_sml_/</link>
      <pubDate>Sat, 02 Jul 2016 15:25:24 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/socket_on_sml_/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
HTTP on SML#?   SML#にJSONサポートが入った  REST API簡単に叩けるのでは？   SML#にFully Concurrent GCが入った  HTTPサーバ書くとレイテンシ抑えられて嬉しいのでは？   スレッドも使えるしスループットも高い筈   SML#でHTTPの機運 しかしHTTPサポートはないので自前実装するしかない  ===
Socket on SML#?   HTTPサポートに必要 Basisにはある (Optional)  SML#のBasisはサポートしてない   FFIあるしユーザランドで実装するか KeenS/SmlSharpSocketSupport  ===
TCP/IP、ソケットなど   ソケットアドレス - 自分、相手の居場所。これがないと通信出来ない  複数のアドレスファミリ(AF)がある IP v4, IP v6, UNIXドメインなど。   ソケット - 通信の仕組み。プログラムからはfdとして見える。  AFやtype(stream/diagram)の属性を持つ   INet - インターネットドメインソケット  TCPとUDP IP v4/v6アドレスで通信    ===</description>
    </item>
    
    <item>
      <title>DOT/dottyについて調べてみた</title>
      <link>//KeenS.github.io/slide/dot_dottynitsuiteshirabetemita/</link>
      <pubDate>Tue, 24 May 2016 23:40:36 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/dot_dottynitsuiteshirabetemita/</guid>
      <description>DOT/dottyについて調べてみた  サイバーエージェント Scala Meet Up
2016-05-27
===
About Me   κeen @blackenedgold Github: KeenS 基盤開発グループ Lisp, ML, Rust, Shell Scriptあたりを書きます Scala初心者  Scala歴1年未満&amp;gt;&amp;lt;    ===
Scalaコンパイラ   型推論（特にimplicit）が遅い コンパイルフェーズが多い  中間オブジェクトが多くて遅くなる   多くのクラスファイルを生成する  コンパイラのくせにディスクIOが多い   気を抜いてると Any に推論される
e.g.) if(x) 1 else &amp;quot;a&amp;quot; そもそものScalaの設計に起因する点が多い  抜本的変更が必要    ===
Scala基礎   Scalaが成立するのに最低限必要な機能って？  e.g.) case class はなくても class だけでどうにかなる   「最低限の機能」を減らせばコンパイラがシンプルになる  他の機能はただのシンタックスシュガーになる コンパイラのバグを減らせる 機能追加時の矛盾確認が楽   コア言語  ===</description>
    </item>
    
    <item>
      <title>高速な継続ライブラリに向けて</title>
      <link>//KeenS.github.io/slide/kousokunakeizokuraiburarinimukete/</link>
      <pubDate>Sun, 08 May 2016 21:26:32 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/kousokunakeizokuraiburarinimukete/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます ===  継続欲しい   色々な場面で便利 Schemeで使い回してるのうらやましい Common Lispでも使いたい 現実には限定継続が欲しい  Common Lispには大域脱出はある    ===
限定継続を使う例  非同期プログラミング  コールバック形式だと厳しい 限定継続を使うと綺麗に書き直せる  ===
限定継続を使う例  ゲームのコルーチン  複数のオブジェクトを制御するのにコルーチンが欲しい cf コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記  ===
限定継続を使う例  do記法  モナドのdo記法は限定継続を使って実装出来る Operational monad in scheme  ===
Common Lispでの限定継続の実現   仕様に入れてもらう 処理系に手を入れる ユーザレベルで(限定)継続ライブラリを作る  柔軟なCommon Lispでは可能    ===</description>
    </item>
    
    <item>
      <title>テストについて、Scalaと。</title>
      <link>//KeenS.github.io/slide/tesutonitsuite_scalato_/</link>
      <pubDate>Tue, 12 Apr 2016 22:31:51 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/tesutonitsuite_scalato_/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア  基盤開発グループでScalaで基盤開発してます   Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
Scalaのテスト   ScalaTest  機能豊富 複数のテストスタイルを選べる 他のフレームワークとの統合がある   Specs2  普通に使いやすい   他にもScalaCheck、JUnit、Gatlingなどなど  ===
ScalaTestのスタイルたち   FunSuite  xUnitっぽいらしい   FlatSpec  xUnitからBDDに移行した人向けらしい   FunSpec  RSpecっぽいBDD用の    ===
ScalaTestのスタイルたち   WordSpec  Specs2に似てる。   FreeSpec  何段にでもネスト出来る。自由。   Spec  テスト=メソッド。速いらしい。    ===</description>
    </item>
    
    <item>
      <title>SMLで函数型的正規表現マッチ</title>
      <link>//KeenS.github.io/slide/smldekansuukatatekiseikihyougenmatchi/</link>
      <pubDate>Tue, 29 Mar 2016 01:44:39 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/smldekansuukatatekiseikihyougenmatchi/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
元ネタ  関数型的正規表現マッチ | Preferred Research
===
正規表現  必要最小限の要素は5つだけ
 空文字 アルファベット1つ 正規表現のOR結合 正規表現のAND結合 正規表現の繰り返し  ===
SMLで表してみる  datatype reg = Empty | Sym of t | Or of reg * reg | And of reg * reg | Rep of reg ===
本当に大丈夫？ ===
/(a|b)*c/  And(Rep(Or(Sym &amp;quot;a&amp;quot;, Sym &amp;quot;b&amp;quot;)), Sym &amp;quot;c&amp;quot;) ===</description>
    </item>
    
    <item>
      <title>ビッグデータしないDrill、ローカルで快適に使うために</title>
      <link>//KeenS.github.io/slide/biggude_tashinaidrill_ro_karudekaitekinitsukautameni/</link>
      <pubDate>Sun, 06 Mar 2016 14:54:30 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/biggude_tashinaidrill_ro_karudekaitekinitsukautameni/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS Lisp, ML, Rust, Shell Scriptあたりを書きます サイバーエージェントのエンジニア  アドテクスタジオ所属 データエンジニアじゃなくてもデータを触ることはある    ===
なぜローカルか   ビッグデータ重い 使いたいデータが絞れる時には大袈裟  「売り上げ上位1000のユーザの行動」とか   同じようなクエリの重複  新しいテーブル作れないDBとかview作れないDBとか   結果をRに渡したりとかが面倒  CSVダウンロードがGUI ===    キャッシュ的な  +---------------------------------+ | BIG DATA (BigQuery, Spark, etc) | +---------------------------------+ ^ | ^ | | | | | | v | v +-------------------+ | ローカルキャッシュ | &amp;lt;- ?</description>
    </item>
    
    <item>
      <title>Rustとは何か。どんな言語か。</title>
      <link>//KeenS.github.io/slide/rusttohananika_donnagengoka_/</link>
      <pubDate>Sun, 06 Mar 2016 05:27:39 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/rusttohananika_donnagengoka_/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
Rustって?   システムプログラミング言語 だけど函数型言語から影響を受けた 安全かつ高速 ゼロコスト抽象化  ===
システムプログラミング言語   スレッドはネイティブ、Cとの相互呼び出し、小さなバイナリサイズ ゲームエンジンとか作れる(piston) レンダリングエンジンとか作れる(Servo) Lチカとか出来る OSとか作れる(Redox)  ===
函数型言語的からの影響  最近ではめずらしくなくなった
 デフォルトイミュータブル 代数的データ型 コンビネータ トレイト (型クラス)  ===
安全かつ高速   データ競合が起きない  所有権システム だいたいコンパイル時Read Writeロック Read only参照複数 or Write可能参照1つ   LLVMベースの強力な最適化 スレッド周辺のAPIが揃ってる  ===
ゼロコスト抽象化  省略
 Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog  ===</description>
    </item>
    
    <item>
      <title>ClojureでSSPを作った話</title>
      <link>//KeenS.github.io/slide/clojuredesspwotsukuttahanashi/</link>
      <pubDate>Mon, 22 Feb 2016 20:19:11 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/clojuredesspwotsukuttahanashi/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
SSPとは  ※今回作ったものの話なので実際は少し違う
 Supplier Side Platform メディアからの広告リクエストを受けて表示権をオークションに掛け、落札された広告を表示する 0. 広告リクエストを受け取って  各DSPに競りの通知を投げて 入札を受け取って 落札者と落札価格を決めて 落札通知を出す    ===
アドテクコンペ   ビジネスモデルもエンジニアリングも学べるアドテクスタジオの育成プログラムとは | 株式会社サイバーエージェント サイバーエージェントの学生向けインターン 3日間、3、4人のチームで DSP を作る 学生は7チーム、1チームあたり2000q/sを捌くことになってる 学生のDSPを繋ぐための SSP が必要になったので作ることに。  ===
===
作るもの   各DSPに競りの通知(HTTPリクエスト)を投げる大規模HTTPクライアント  各DSPが2000q/s x 7チーム + 落札通知 = 16000q/s 丁度2000q/sになるような制御も必要   入札を受けてのオークション、結果のロギングなど 管理画面  ===</description>
    </item>
    
    <item>
      <title>HAMT ~ イミュータブルで高速なハッシュマップ ~</title>
      <link>//KeenS.github.io/slide/hamt/</link>
      <pubDate>Sun, 31 Jan 2016 16:17:35 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/hamt/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 基盤開発グループの新卒 Lisp, ML, Rust, Shell Scriptあたりを書きます  ===
scala.collections.immutable.HashMap   今日の話題。これの実装をみていく。 イミュータブル キー-バリューペア 値を追加する度に新たなハッシュマップを作る   ===
HashMap   O(1)のアクセス効率 空間効率は悪い ハッシュ関数が定義出来れば何でもキーに使える 普通はミュータブルに使う  大量のメモリをアロケートするのでコピーはつらい    ===
メモリ効率悪そう？  val hash = HashMap.empty + (3 -&amp;gt; 1) // +---+---+---+---+---+---- // | / | 3 | / | / | / | ... // +---+---+---+---+---+---- // | // +-+ // |1| // +-+ ===</description>
    </item>
    
    <item>
      <title>DSLとTagless Final</title>
      <link>//KeenS.github.io/slide/dsltotagless_final/</link>
      <pubDate>Sun, 13 Dec 2015 22:42:39 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/dsltotagless_final/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS AMoAdの新卒エンジニア Lisp, ML, Rust, Shell Scriptあたりを書きます  Scalaは初心者 ※ Scala初心者の新卒が頑張ってLispを作ってみた ===    注意   Scala初心者なのでScalaではなくScalaっぽい疑似コードで説明します  コード例動かす時間が無かっただけ   Scala初心者なのでScalaのコードは少なめに説明します  ===
DSLを作る  以下のようなHTTPなユーザをエミュレートするDSLを考える
val scenario = and( get(&amp;#34;/&amp;#34;), get(&amp;#34;/users&amp;#34;).andThen(res =&amp;gt; post(&amp;#34;/follow&amp;#34;, first(users.getJsonData)))) val Right(_) = runScenario(scenario, &amp;#34;user&amp;#34;) ===
DSLを作る  普通は以下のようなAST作ってをラップする
trait ScenarioDSL sealed case class Get(url: String) extends ScenarioDSL sealed case class Post(url: String, data: JSON) extends ScenarioDSL sealed case class And(first, ScenarioDSL, second ScenarioDSL) extends ScenarioDSL sealed case class AndThen(first: ScenarioDSL, callBack: (Response) =&amp;gt; ScenarioDSL) extends ScenarioDSL def get(url: String): ScenarioDSL= Get(url) .</description>
    </item>
    
    <item>
      <title>ClojureでDSPを作った話</title>
      <link>//KeenS.github.io/slide/clojurededspwotsukuttahanashi/</link>
      <pubDate>Tue, 27 Oct 2015 21:04:20 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/clojurededspwotsukuttahanashi/</guid>
      <description>κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Shell Scriptあたりを書きます  ===
DSPとは   Demand Side Platform 広告主から広告を集めて広告の表示権を競り落し、適切な広告を出す 0. 広告主を集めて  競りの通知を受け取って 一番コスパが良さそうな広告を選んで 入札して 落札通知を受け取る 落札したら広告を出す    ===
ひとりDSP   AdTech Studioの新卒研修 2ヶ月間、業務時間の20%を使ってDSPを作る  実質8営業日   業務ロジックを理解することが目的 最後に新卒の作ったDSP同士で競争、利益が得点になる 他には最終発表での得点も 研修なので好きにやっていい  Clojureで書くことに   サーバーの他は広告主データと学習用データが与えられる  ===
===
作るもの   競りの通知を受け取って入札するJSON REST API 落札の通知を受け取るJSON REST API  割とシンプル   「一番コスパが良さそうな広告を選ぶ」部分は色々と工夫する 今回は広告を出すところまではやらない クリック情報は落札通知に入ってる  ===</description>
    </item>
    
    <item>
      <title>Internal of b11d</title>
      <link>//KeenS.github.io/slide/internal_of_b11d/</link>
      <pubDate>Mon, 19 Oct 2015 21:33:00 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/internal_of_b11d/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS AMoAdのサーバーサイド（？）エンジニア 趣味でLisp, ML, Shell Scriptあたりを書きます 仕事でScalaとShell Scriptあたりを書きます  ===
今回作ったもの   b11d (ぶらっくんどごーるど) Clojure (compojure + middleware)製    NginX + MySQL + Supervisord     出来る限りシンプルになるように作った  310行   デプロイその他はシェルスクリプト 監視はmackerel  ===
シンプルということ   アプリケーションは状態を持たない IO以外副作用を持たない つまり、キャッシュを持たない  キャッシュはパフォーマンス上の意味しかない 早過ぎる最適化は諸悪の根源   スケールアウトが容易 compojureのミドルウェアを上手く使った  ===
シンプルということ2   データベースはだいたい第4正規形（ﾀﾌﾞﾝ）  全てのカラムはNOT NULL 広告主の所だけ拡張性を持たせるために第1正規形に落とした 1広告主に対して複数の広告が持てるようになる   外部キー制約も全部付ける データが綺麗なのでアプリケーション側でのやることが少ない 分析する時にも活きる筈  ===</description>
    </item>
    
    <item>
      <title>ISUCONこれまでの流れ</title>
      <link>//KeenS.github.io/slide/isuconkoremadenonagare/</link>
      <pubDate>Fri, 04 Sep 2015 08:47:05 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/isuconkoremadenonagare/</guid>
      <description>κeen @blackenedgold Github: KeenS ISUCON3、 4の予選、本戦に出場（学生枠） ===  ISUCON1 ブログ   node perl ruby kazeburoの罠 ブログのサイドバーが重いやつ 割と親切なルール  ===
ISUCON2 チケット予約サイト   perl ruby node php java python 席ランダムにしてなくてもベンチマーカー通っちゃう 変更が1秒以内に反映されていること → 0.9秒毎に裏でバッチを回す JOINが3連になってる所があってみんなそこに引っ掛かったがボトルネックはそこじゃない ちょっとルールが雑になった  ===
ISUCON3予選 スニペット投稿サイト   go node perl python ruby php AWS1台 Markdown変換がperl製の重いやつ AWSだとプロセスのフォークも重い titleの抜き出しも重い チェッカーが甘くてVarnishを導入しただけで点数爆上がり SQLの典型問題とかも workloadに気付かなかった人多数 学生枠が出来た ベンチマーカが通れば何でもアリな風潮  ===
ISUCON3本戦 画像SNS   go node perl python ruby オンプレ5台 画像の変換が重い 実は帯域もつらい 画像のチェッカがあってチェッカが通れば画質を落としても良かった 組長の罠 ベンチマーカーに通れば何でもアリ 複数サーバーでのファイルの共有にWebDAVが盲点 点数計算の罠に嵌まる人多数  基本点より追加点に目が眩む人がそれなりに   推測するな計測せよ nodeで初期パスワードが間違っているトラブル  ===</description>
    </item>
    
    <item>
      <title>SMLでPNGデコーダを作ろうとして分かったこと</title>
      <link>//KeenS.github.io/slide/smldepngdeko_dawotsukuroutoshitewakattakoto/</link>
      <pubDate>Fri, 04 Sep 2015 06:45:19 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/smldepngdeko_dawotsukuroutoshitewakattakoto/</guid>
      <description>κeen @blackenedgold Github: KeenS AMoAdの新卒 Lisp, ML, Shell Scriptあたりを書きます  ===
===
===
=== 明日の朝までに
SMLでpngデコーダを実装しよう===
Standard ML   ML系の函数型言語 文法はOCamlよりF#に似てる（というかF#が似せてきた） 結構書き易い 仕様は SML&#39;90とSML&#39;97がある 仕様で言語のformal semanticsが定められてたりする 要は研究向き  ライブラリほぼなし コミュニティほぼなし    === ＞　無理ゲー　＜===
一応フォーマットを調べる  +-----------------+ | Chunk | 画像はChunkの集合。 ++---------------++ Chunk自体は簡単なフォーマット || length | name || |+---------------+| || data || || ... || |+---------------+| || CRC || ++---------------++ | Chunk | | ... | === 意外と単純？ ===</description>
    </item>
    
    <item>
      <title>Method Drawでお手軽LGTM生成</title>
      <link>//KeenS.github.io/slide/method_drawdeotegarulgtmseisei/</link>
      <pubDate>Fri, 14 Aug 2015 00:55:37 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/method_drawdeotegarulgtmseisei/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS サイバーエージェントのエンジニア Lisp, ML, Shell Scriptあたりを書きます  ===
Method Draw   シンプルなSVG エディタ オープンソース editor.method.ac  ===
デモ ===
以上  Have a happy hacking life</description>
    </item>
    
    <item>
      <title>構文解析にまつわる小話たち</title>
      <link>//KeenS.github.io/slide/koubunkaisekiarekore/</link>
      <pubDate>Sat, 08 Aug 2015 04:16:50 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/koubunkaisekiarekore/</guid>
      <description>構文解析にまつわる小話たち  #peg_study
===
About Me   κeen @blackenedgold Github: KeenS サイバエージェントの新卒エンジニア Lisp, ML, Shell Scriptあたりを書きます  ===
ウォームアップ ===
構文解析はバッドノウハウ   プログラム言語を使っているなら既にパーサはある  文法も定義されてる   目の前のパーサを使え  パーサAPIがある言語もある(Lispとか)   そうでなくても内部DSLを考えろ  内部DSLで解決出来ないときだけ構文解析 ===    本質はAST   結局はASTになればどんな文法でも同じ 文法はただの外皮、欲しいのはAST シンタックスシュガーは飾り  DRY出来るなら別   S式を使え  ASTをそのまま書き下せる    ===
AST First   最初にASTを考える。そして文法を考える 何が欲しいのかイメージし易くなる 構文解析はAST生成の自動化。普段してないことを自動化するのは愚か。 早めに間違いに気付ける  +は二項演算子。じゃあ &amp;amp;&amp;amp; は？ = は？    Note: Lispだと+は関数、andはマクロ、setqはスペシャルフォーム</description>
    </item>
    
    <item>
      <title>Clojureおじさん</title>
      <link>//KeenS.github.io/slide/clojureojisan/</link>
      <pubDate>Mon, 22 Jun 2015 22:53:39 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/clojureojisan/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます ===  Clojure   2007年から JVMで動くLisp系言語 函数型 動的型付き 値は基本immutable 遅延シーケンス STMがあり、並列処理に強い  ===
Hello World  (println &amp;#34;Hello, World&amp;#34;) ===
JVM  Javaのコードをシームレスに呼べる  obj.method() ではなく (.method obj) Class.staticField ではなく Class/staticField obj.method1().method2() ではなく (.. obj method1 method2)  ===
JVM  (.println System/out &amp;#34;Hello JVM&amp;#34;) (Math/random) ===
Immutable   状態を持たないのでコードの見通しが良い  並列で考える時には重要 複雑さだけでなく不整合などバグの原因になりやすい   変更可能な値もある  それらはトランザクション内でのみ変更可能 不整合が起きない    ===</description>
    </item>
    
    <item>
      <title>Common Lisp処理系拡張の探求 SBCLのマルチスレッドサポート</title>
      <link>//KeenS.github.io/slide/common_lispshorikeikakuchounotankyuu_sbclnomaruchisureddosapo_to/</link>
      <pubDate>Sat, 20 Jun 2015 18:30:52 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/common_lispshorikeikakuchounotankyuu_sbclnomaruchisureddosapo_to/</guid>
      <description>Lisp Meet Up #29
===
About Me   κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます ===  CLのマルチスレッド  bordeaux-threads  色々な処理系のマルチスレッドサポートの抽象レイヤー デファクトスタンダード  スレッド ロック コンディションヴァリアル    ===
SBLCのマルチスレッド ===
SBLCのマルチスレッド   スレッド  スレッド内エラー   アトミック操作 CAS   排他制御（ロック） セマフォ コンディションヴァリアル バリア キュー メールボックス ゲート frlock  ===
アトミック操作 ===
アトミック操作  複雑な動作は同じデータに並行に動かすと壊れうる
 [var = 1] [incf] | [decf] [1]&amp;lt;-------| | |------&amp;gt;[1] [2]---&amp;gt;[var = 2] | | | [var = 0]&amp;lt;--[0] ===</description>
    </item>
    
    <item>
      <title>ボトルネックのイイ話</title>
      <link>//KeenS.github.io/slide/botorunekkunoiihanashi/</link>
      <pubDate>Thu, 04 Jun 2015 00:03:14 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/botorunekkunoiihanashi/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます ===  ボトルネック   ボトルネック (bottleneck) とは、システム設計上の制約の概念。英語の「瓶の首」の意。一部（主に化学分野）においては律速（りっそく、「速さ」を「律する（制御する）」要素を示すために使われる）、また『隘路（あいろ）』と言う同意語も存在する。
 ===
Webアプリの主な登場人物   リバースプロキシ アプリケーションサーバ データベース ===  ===
レスポンスタイムとスループット   レスポンスタイム  リクエストを投げてレスポンスが返ってくるまでの時間 ユーザから見たメトリクス   スループット 一定時間内にシステムがどれだけのリクエストを捌けるか 中の人から見たメトリクス    ===
スループット   スループットの最大 ≒ リソースの限界  ネットワーク帯域 ディスクIO メモリ使用量 CPU負荷   リソースのどれか1つでも限界になったらそれ以上パフォーマンスは上がらない ===  パフォマンスの目安   ネットワーク帯域: bpsで表わす。NICによるが 1Gbpsとか CPU: パーセンテージで表わす。100xコア数が最大マシンに依る。 メモリ: Bで表わす。ピンキリだが1GB ~ 128GBくらい？ ディスクIO: Bpsで表わす。HDDなら 100Bpsとか。SSDなら10倍くらい。  テキトーに調べたので間違ってるかも 誰が何を   リバースプロキシ: ネットワーク、メモリ、CPUなど アプリケーションサーバl: CPU、メモリなど データベース: CPU、ディスクIOなど  === 「CPUは100%に行ってないのにアプリケーションが遅いんだよ」===</description>
    </item>
    
    <item>
      <title>Transducerについて</title>
      <link>//KeenS.github.io/slide/transducernitsuite/</link>
      <pubDate>Wed, 03 Jun 2015 22:29:50 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/transducernitsuite/</guid>
      <description>κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます ===  Transducerって？   Clojure 1.7で入るフレームワーク 関数のパイプライン化を簡単にする 入力、出力には依存しない  ===
Reduce関数について   reduce: (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) &#39;a -&amp;gt; &#39;b list (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) でシーケンスを集約する (reduce + 0 &#39;(1 2 3)) ;=&amp;gt; 6 要はreduceは関数を使って集約する。 ===  Transducerについて   transduce:((&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) -&amp;gt; (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a)) (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) &#39;a -&amp;gt; &#39;b list 集約関数を変換する関数もとる (transduce xf + 0 &#39;(1 2 3)) transducerで集約する前に処理を挟める ===  すごいところ  コンポーサビリティ  ((&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a) -&amp;gt; (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;a)) 変換関数は入力と出力が同じ。 つまり変換関数を合成出来る ex) (comp (filter odd?</description>
    </item>
    
    <item>
      <title>21世紀のエンジニアのためのHTTP/2入門</title>
      <link>//KeenS.github.io/slide/21seikinoenjinianotamenohttp_2nyuumon/</link>
      <pubDate>Mon, 18 May 2015 00:24:08 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/21seikinoenjinianotamenohttp_2nyuumon/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます  ===
HTTPについて   1990年誕生の骨董仕様 Human Readableなテキストベース パフォーマンスはあまり考慮してない  ===
HTTP/1.1の限界   フォーマットがゆるふわでパースしづらい 何度も似たようなヘッダをる  割とネットワーク負荷が高い   基本1コネクションにつき1ファイルの送受信  短命なコネクションをいくつも張ることになる コネクションが&amp;quot;ウォームアップ&amp;quot;する前に切れる   Head of Line Blocking  遅いコンテンツをダウンロードしてると他のコンテンツがダウンロード出来なくなる ===    GET / HTTP/1.1 Host: localhost:8080 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: ja Accept-Encoding: gzip, deflate Cookie: _ga=GA1.</description>
    </item>
    
    <item>
      <title>実装から理解するクロージャ</title>
      <link>//KeenS.github.io/slide/jissoukararikaisurukuro_ja/</link>
      <pubDate>Sun, 17 May 2015 01:33:39 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/jissoukararikaisurukuro_ja/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます  ===
クロージャとは？   日本語にすると（関数）閉包 関数が外側のローカル変数を補足する 補足されたローカル変数は無限の生存期間を持つ  ローカル変数は本来スコープを抜けると生存期間が終わる 言い換えるとグローバル変数みたいになる でもあくまでスコープはローカル ===    コード例  function genpower(n){ var x = 1; return function(){ x *= n; return x; }; } var p = genpower(2); ===
コード例  p() // =&amp;gt; 2 p() // =&amp;gt; 4 p() // =&amp;gt; 8 x * 2 // x is not defined ===</description>
    </item>
    
    <item>
      <title>勉強会駆動勉強で猛勉強</title>
      <link>//KeenS.github.io/slide/benkyoukaikudoubenkyoudetakeshibenkyou/</link>
      <pubDate>Wed, 06 May 2015 22:02:12 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/benkyoukaikudoubenkyoudetakeshibenkyou/</guid>
      <description>κeen @blackenedgold Github: KeenS 渋谷のエンジニア 大学では非情報系の学部にいた Lisp, ML, Shell Scriptあたりを書きます ===  勉強会駆動勉強  ===
勉強会駆動勉強  方法  勉強会を見付ける  (詳しくない内容について)トークを登録する  期日までに勉強する  期日までに資料を作る  発表する   ===
勉強会駆動勉強  ポイント  自分でテーマを決めてる 自分で期限を決めてる 決めた期限は強制力がある アプトプットする 質問などでフィードバックがくる  ===
勉強会駆動勉強  身に付く力  素早く調べる力 要点を素早く見付ける力 プレゼン資料の作成力 プレゼン力  ===
例 ===
前回のRustの話 実は発表決めた時点ではRustを書いたことなかった ===
ISUCON 勉強会じゃないけど出場を決めてから周辺の勉強を始めた ===
おまけ  その他の勉強法
 マイナー言語式勉強法 やっちゃれ勉強法  ===
マイナー言語式勉強法 ===</description>
    </item>
    
    <item>
      <title>Common Lispで限定継続と遊ぶ</title>
      <link>//KeenS.github.io/slide/common_lispdegenteikeizokutoasobu_/</link>
      <pubDate>Sun, 26 Apr 2015 21:09:07 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/common_lispdegenteikeizokutoasobu_/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます  ===
Agenda  cl-contの紹介 限定継続の話 限定継続の使い方の話 限定継続の実装の話  ===
CL-CONTの紹介 ===
CL-CONT   Common Lispの限定継続ライブラリ 結構古くからあるっぽい 割と色々なライブラリが使ってる ===  CL-CONT   API   継続を区切るマクロ  with-call/cc defun/cc lambda/cc   継続を取得するマクロ  call/cc let/cc    ※後で説明するので意味が分からなくても問題ないです。
===
限定継続の話 ===
継続とは   &amp;ldquo;その後&amp;quot;の計算を表わす概念。 値が決定した後トップレベルに戻るまでの計算。 Schemeが一級市民として扱えることで有名 値として取り出した時は0-1引数関数として振る舞う ===  継続とは  fooの継続は、fooを虫食いにしたものと思えば良い。</description>
    </item>
    
    <item>
      <title>非同期処理の「その後」の話。goto、継続、限定継続、CPS、そしてコールバック地獄。</title>
      <link>//KeenS.github.io/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_cps_soshiteko_rubakkujigoku_/</link>
      <pubDate>Sat, 25 Apr 2015 23:44:46 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_cps_soshiteko_rubakkujigoku_/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 渋谷のエンジニア Lisp, ML, Shell Scriptあたりを書きます ===  同期処理とは  通常、外部とやりとり(I/O)する時に待ち時間(ブロック)が発生する。
===
非同期処理とは  待ち時間に(ブロックせずに)別の処理をしようという発想。
 非同期処理の裏側  処理Aと処理Bの他にいつどっちを動かすかを決めるスケジューラが存在することが多い
===
どうやって戻る問題   一時停止した後「その後」の処理にどうやって戻るか   「その後」とは  ... fputc(c); // ここの処理でI/Oが入る // 再開する時にここに戻ってきたい printf(&amp;#34;Work done&amp;#34;); ... ===
GOTO  goto を使えば戻れる
... fputc(c); // ここの処理でI/Oが入る  // 再開する時にここに戻ってきたい RESTART: printf(&amp;#34;Work done&amp;#34;); ... ===
GOTOの問題  こういうコードだとGOTOでは困る
if ((c = fgetc(f)) != -1) .</description>
    </item>
    
    <item>
      <title>静的なメモリ管理の話。リージョン推論とλ計算からRustまで</title>
      <link>//KeenS.github.io/slide/seitekinamemorikanrinohanashi.rijonsuirontolambdakeisankararustmade/</link>
      <pubDate>Tue, 21 Apr 2015 00:25:56 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/seitekinamemorikanrinohanashi.rijonsuirontolambdakeisankararustmade/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 大学では非情報系学科。趣味のプログラマ。  非ガチ勢なので優しくして下さい&amp;gt;&amp;lt;   Lisp, Ruby, OCaml, Shell Scriptあたりを書きます  ===
メモリ管理の話  (一般的ではない用語)
 弱い静的メモリ管理 強い動的メモリ管理 (弱い動的メモリ管理) 強い静的メモリ管理  ===
メモリ管理の話  弱い静的メモリ管理 特徴  弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる 静的 = コンパイル時にメモリ管理が決定する  例  C言語  ===
メモリ管理の話  弱い静的メモリ管理 利点  実行時は安定している  欠点  バグる 面倒 危険  ===
メモリ管理の話  強い動的メモリ管理 特徴  強い = 基本的にメモリでエラーやリークが起きない 動的 = 実行時になるまでメモリの使われ方が分からない  例  GCのある言語全般 ===  メモリ管理の話  強い動的メモリ管理 利点  メモリ管理からの開放  欠点  動作が不安定 (cf これがCassandra) パフォーマンスの問題 リアルタイム性の問題  ===</description>
    </item>
    
    <item>
      <title>caveman2、ningle…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト</title>
      <link>//KeenS.github.io/slide/caveman2-ningle...common-lispnowebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</link>
      <pubDate>Thu, 05 Mar 2015 13:18:44 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/caveman2-ningle...common-lispnowebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</guid>
      <description>=== ずっと俺のターン===
問題  Common Lispは case
 Sensitive  Insensitive   どっち? 問題  あれ？
(eql? &amp;#39;CaseInsensitive &amp;#39;caseinsensitive) ;=&amp;gt; t ===
問題  リーダがデフォルトで大文字にするだけ
(eql? &amp;#39;|CaseSensitive| &amp;#39;|casesensitive|) ;=&amp;gt; nil ===
Caveman2  @route GET &amp;#34;/hello&amp;#34; (defun say-hello (&amp;amp;key (|name| &amp;#34;Guest&amp;#34;)) (format nil &amp;#34;Hello, ~A&amp;#34; |name|)) ===
Ningle  (setf (ningle:route *app* &amp;#34;/login&amp;#34; :method :POST) #&amp;#39;(lambda (params) (if (authorize (getf params :|username|) (getf params :|password|)) &amp;#34;Authorized!&amp;#34; &amp;#34;Failed...Try again.&amp;#34;))) ===</description>
    </item>
    
    <item>
      <title>既存のテンプレートエンジンの問題点と再設計</title>
      <link>//KeenS.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaarrowsnitsuite/</link>
      <pubDate>Mon, 02 Mar 2015 23:36:03 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaarrowsnitsuite/</guid>
      <description>===
About Me   κeen @blackenedgold Github: KeenS 野生のLisper Lisp, Ruby, OCaml, Shell Scriptあたりを書きます ===  Template Engines ===
Existing Architeture  (リクエスト) アプリ 引数を計算 テンプレートに引数を渡す レスポンスをレンダリング  レスポンスをサーバに渡す (レスポンス) ===  Rendering?   結合した文字列はクライアントに返ったらその後はゴミ   GCへ負荷がかかる (後述)   クライアントにとって1つの文字列である必要はない むしろ返せる部分だけ先に返した方が得（後述） ===  GC Pressure (SBCL)   世代別Copy GC 結合した文字列は比較的大きい alloc_spaceに入らない大きさならアロケートが遅い GCを頻繁に起動してしまう 16KBを越えると特別扱いされて遅い/メモリを喰う LispのWebアプリはレスポンスタイムの分散が大きい（要出展）  参考: SBCL GENCGC @ x86 Linux Split Response  例えば、こんなの</description>
    </item>
    
    <item>
      <title>Semantic S式</title>
      <link>//KeenS.github.io/slide/semantic-sshi/</link>
      <pubDate>Thu, 27 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/semantic-sshi/</guid>
      <description>Semantic S式  2014-11-27
κeen(@blackenedgold)
About Me   κeen 東大数学科の4年生 ソーシャルアカウントは上のアイコン達から。 Lisp, Ruby, OCaml, Shell Scriptあたりを書きます  Semantic Web とは Semantic Web   W3C のティム・バーナーズ＝リーが提唱 文章の見た目を記述するんじゃなくて構造を記述しよう そうすると機械がクローリングするの楽になるよね  Semantic S式とは Semantic S式   Shibuya.lispのκeenが提唱 (昨日思い付いた) S式の見た目じゃなくて構造で括弧をつけよう そうするとコーディングが楽になるよね  良いところ   意味が分かり易い パースし易い 編集が楽になる 壊れにくい  1. 意味が分かり易い 1. 意味が分かり易い  例1   Clojure
(let [a 1 b 2] ...)   Common Lisp
(let ((a 1) (b 2)) .</description>
    </item>
    
    <item>
      <title>claspを少し触ってみた</title>
      <link>//KeenS.github.io/slide/clasp/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/clasp/</guid>
      <description>claspを少し触ってみた  Lisp Meet Up presented by Shibuya.lisp #21
2014-10-29
κeen(@blackenedgold)
About Me   κeen 東大数学科の4年生 ソーシャルアカウントは上のアイコン達から。 Lisp, Ruby, OCaml, Shell Scriptあたりを書きます  clasp   Github: drmeister/clasp 2014-09-18に0.1リリース(現在0.11プレビューが出ている) 今は0.11プレビューが出ている ANSI Common Lisp準拠を目指す(現在80 ~90%) ECLからのフォーク LLVMベースのJIT(MCJIT)搭載 C++とLispで書かれている C++との連携を意識  Note: C++との連携の部分を強調。今回は0.11プレビューでの話
メモリ管理   Memory Pool Systemと Boehm GCから選べる ビルドするときにどっちかを選ぶ  メモリ管理  Boehm GC  Mark &amp;amp; Sweepのライブラリ 枯れた有名なライブラリ Lisp有名どころではGaucheが使う RedHat系だとこれを使ってないとrpmリジェクトされやすいらしい(?)  Note: 他にはMozilla, W3M, GNU GCJ, GNU Obj-Cなどなど</description>
    </item>
    
    <item>
      <title>C6H6&#43;HNO3</title>
      <link>//KeenS.github.io/slide/c6h6-plus-hno3/</link>
      <pubDate>Fri, 24 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/c6h6-plus-hno3/</guid>
      <description>picrinについて  化学式 $\mathbf{C_6H_3N_3O_7}$、示性式 $\mathbf{C_6H_2(OH)(NO_2)_3}$ で表される芳香族のニトロ化合物。
一般にはフェノールのニトロ化によって得られる。
Note: ニトロ化に硫酸を使うことを触れる。
About Me   κeen 東大数学科の4年生 ソーシャルアカウントは上のアイコン達から。 Lisp, Ruby, ML, Shell Scriptあたりを書きます picrinのコミッタです  picrinについて   github: picrin-scheme/picrin R7RS-small scheme 処理系 速い、軽い、高機能を目指す 組み込み向けを意識 1年くらい開発 κeenがコミットし始めてから半年弱  picrinの プロジェクト構成  コア(benz)はC、ビルドツールはCMake。
├── contrib (nitros) ....... ├── docs ├── etc ├── extlib │ └── benz ├── piclib .... └── src Note: contribとextlib/benzを強調。 srcはほぼ空であることにも触れる。
nitrosの紹介   schemeやCで書かれている picrinのコンパイル時に一緒にlibpicrinに入る picrinと共にCMakeで管理されている  Note: schemeファイルもlibpicrinにCの文字列として入ってることに触れる。 バイトコンパイルプロジェクトにも触れる。 nitrosも一緒にコンパイルされることを強調する。</description>
    </item>
    
    <item>
      <title>Picrinのチューニングの話、もといGCの話</title>
      <link>//KeenS.github.io/slide/picrin-gc/</link>
      <pubDate>Mon, 29 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/picrin-gc/</guid>
      <description>Picrinのチューニングの話、もといGCの話  Lisp Meet Up presented by Shibuya.lisp #20
2014-09-29
κeen(@blackenedgold)
自己紹介   κeen 東大数学科の4年生 ソーシャルアカウントは上のアイコン達から。 Lisp, Ruby, OCaml, Shell Scriptあたりを書きます picrinのコミッタです  picrin  picrin   R7RS compatibility bytecode interpreter (based on stack VM) internal representation by nan-boxing conservative call/cc implementation (users can freely interleave native stack with VM stack) exact GC (simple mark and sweep, partially reference count is used as well) string representation by rope data structure  picrin   R7RS compatibility bytecode interpreter (based on stack VM) internal representation by nan-boxing conservative call/cc implementation (users can freely interleave native stack with VM stack) exact GC (simple mark and sweep, partially reference count is used as well) string representation by rope data structure  picrin開発者の不満   picrinの起動が遅い 2秒くらいかかる    picrinのテストが遅い 16秒くらいかかる     少しGCの話  GC(ごみ集め)とは</description>
    </item>
    
    <item>
      <title>Introduction to CIM</title>
      <link>//KeenS.github.io/slide/introduction-to-cim/</link>
      <pubDate>Sat, 30 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/introduction-to-cim/</guid>
      <description>Introduction to CIM κeen(@blackenedgold)
突然ですが Common Lispのスクリプトファイルの実行方法知ってますか？
sbcl
sbcl --script $file  ecl
ecl -shell $file  ccl
ccl -e $file -e &#39;(quit)&#39;  &amp;hellip;
シバン可搬性のあるスクリプトが書けないそこで、こんなの書きました case &amp;#34;$LISP_IMPL&amp;#34; in sbcl*) sbcl --script $1 ;; clisp*) clisp -on-error exit -i $1 ;; ecl*) ecl -shell $1 ;; ccl*) ... でも問題がある  どの処理系をバックエンドに使うか 処理系のパスをどう捜すか そもそもどうやって使ってもらうか  κeenの答え  処理系の管理までやってしまおう。 そうしたら一緒に使ってもらえる。
 ＿人人人人人人＿
＞　CIMの誕生　＜
￣Y^Y^Y^Y^Y￣
CIMとは  Common Lisp Implementation Manager ちむ Rubyのrvmを強く意識 Common Lisp処理系のインストール、切り替え、コマンドラインインターフェースなど。 cim、 cl、 qlコマンドから成る B Shell スクリプト製(マルチプラットフォーム対応のため) 2013/10くらいからぼちぼち開発  cimコマンドについて インストール</description>
    </item>
    
    <item>
      <title>授業で半年間moclを使ってみた</title>
      <link>//KeenS.github.io/slide/shibuya-dot-lisp-tt-number-8/</link>
      <pubDate>Thu, 28 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/shibuya-dot-lisp-tt-number-8/</guid>
      <description>授業で半年間moclを使ってみた Shibuya.lisp TT #8
κeen(@blackenedgold)
自己紹介  κeen 東大数学科の4年生 ソーシャルアカウントは上のアイコン達から。 Lisp, Ruby, OCaml, Shell Scriptあたりを書きます  一年前
計算数学II 自分でテーマを決めて半年間取り組む
チーム人造エイリアン Common Lisp でAndroid? mocl What is mocl  iOS, Androidで動くCommon Lisp処理系 LLVMをバックエンドに使う Networking, Unicode, CLOS, and More. Run Countless CL Libraries.  買ってもらった(・ω・)v 注意 私が触ったのは1つ前のバージョンです。
一部5月のアップデートで改善されています。
How it Works コードサンプル 授業で私が作ったオセロのAIのコード
public BoardCanvas(Context context,int width, int height,int color ){ ... CL.cl_init(); CL.init_game(3 - color); ... } void nextHand(){ String[] coord = CL.</description>
    </item>
    
    <item>
      <title>Cloud 9の紹介</title>
      <link>//KeenS.github.io/slide/cloud-9/</link>
      <pubDate>Tue, 29 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/cloud-9/</guid>
      <description>Lisp Meet Up #19 presented by Shibuya.lisp
κeen(@blackenedgold)
自己紹介  κeen 東大数学科の4年生 ソーシャルアカウントは上のアイコン達から。 Lisp, Ruby, OCaml, Shell Scriptあたりを書きます  Lispがあまり使われない原因 Cloud 9について  WEBベースのIDEサービス 40以上の言語に対応（らしい） この間正式リリース 1アカウント毎に1Docker環境与えられる IDEはオープンソース よく分かってない  こんなん デモ 良いところ  難易度低い Lisp環境動く Githubとの連携 どこからでも同じ環境にアクセス キーバインドはうれしい各宗教対応の
{Mac, Windows}x{Default, Emacs, Vim, Sublime}  微妙なところ  シンタックスハイライト微妙
（せめてキーワード引数はどうにか） 補完微妙 インデント微妙 swank使いたい  以上何か質問あればどうぞ</description>
    </item>
    
    <item>
      <title>(S式で書く(altJS)達)</title>
      <link>//KeenS.github.io/slide/sshi-deshu-kualtjs/</link>
      <pubDate>Sun, 13 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/sshi-deshu-kualtjs/</guid>
      <description>自己紹介  κeen 東大数学科の4年生 Twit : @blackenedgold Github : KeenS Blog : κeenのHappy Hacκing Blog Shibuya.lispにいます。(2014-06〜運営になりました) Lisp, Ruby, OCaml, Shell Scriptあたりを書きます  お品書き  (ボツ) Shen.js (ボツ) Embedable Common Lisp with Emscripten (ボツ) Picrin with Emscripten (ボツ) オレオレaltJSの作り方の話 ParenScript  Shen.js Shenの公式ページより
 パターンマッチ λ計算ベース マクロ 遅延評価も可能 静的型検査 関数的なPrologの統合 ビルトインコンパイラコンパイラ  これのJS実装もある。
例 (define factorial 0 -&amp;gt; 1 X -&amp;gt; (* X (factorial (- X 1)))) そもそもaltJSじゃない…
ボツ
ECL with Emscripten  ANSI Common Lisp準拠のCommon Lisp処理系 LispをコンパイルしてCを吐く Emscriptenでコンパイルすれば…  #include &amp;lt;ecl/ecl-cmp.</description>
    </item>
    
    <item>
      <title>言葉遣いの時代変遷を追う</title>
      <link>//KeenS.github.io/slide/nlp/</link>
      <pubDate>Wed, 09 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/nlp/</guid>
      <description>言葉遣いの時代変遷を追う 理学部数学科4年 金 舜琳 （きん すんりん）
概要 古いものから新しいものまであるリソースから単語を抽出し、使用頻度から単語の時代変遷を追う
手法 step1  名詞、形容詞、語尾などが候補 青空は多様性がある/話し言葉もとれるが古いのしかない？ 新聞は均質だからサンプル調査に向いてる？  step2 step3 ##step4</description>
    </item>
    
  </channel>
</rss>