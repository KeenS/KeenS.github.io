<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Slides on κeenのHappy Hacκing Blog </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/slide/index.xml/</link>
    <language>en-us</language>
    
    
    <updated>Thu, 27 Nov 2014 00:00:00 UTC</updated>
    
    <item>
      <title>Semantic S式</title>
      <link>http://localhost:1313/slide/semantic-sshi/</link>
      <pubDate>Thu, 27 Nov 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/slide/semantic-sshi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Semantic S式
---
2014-11-27  
κeen(@blackenedgold)


# About Me
----------
![κeenのアイコン](/images/icon.png)

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

# Semantic Web とは

# [Semantic Web](http://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A6%E3%82%A7%E3%83%96)
----------------

* W3C のティム・バーナーズ＝リーが提唱
* 文章の見た目を記述するんじゃなくて構造を記述しよう
* そうすると機械がクローリングするの楽になるよね


# Semantic S式とは

# Semantic S式
--------------

* Shibuya.lispのκeenが提唱 (昨日思い付いた)
* S式の見た目じゃなくて構造で括弧をつけよう
* そうするとコーディングが楽になるよね


# 良いところ
------------

1. 意味が分かり易い
2. パースし易い
3. 編集が楽になる
4. 壊れにくい


# 1. 意味が分かり易い

# 1. 意味が分かり易い
--------------------
## 例1

* Clojure

  ```clojure
  (let [a 1
        b 2]
    ...)
  ```

* Common Lisp

  ```lisp
  (let ((a 1)
        (b 2))
    ....)
  ```
どっちが分かり易い？

# 1. 意味が分かり易い
--------------------
## 例1
（日本語にしてみる（イメージ））

* Clojure  
  aを1bを2とする
* Common Lisp
  &lt;table border=&#34;1&#34;&gt;&lt;tr&gt;&lt;td&gt;`a`&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;`b`&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  とする


# 1. 意味が分かり易い
--------------------
## 例2
何をしてる？

```lisp
(destructuring-bind (a b)
    (some-function)
  ...)
```

# 1. 意味が分かり易い
--------------------
## 例2
何をしてる？

```lisp
(destructuring-bind ((a b)
    (some-function))
  ...)
```

# 1. 意味が分かり易い
--------------------
## 例3
これの返り値は？

```lisp
(getf &#39;(:hoge :foo :huga :baz :piyo :pon :chun) :pon)
```

# 1. 意味が分かり易い
--------------------
## 例3
これの返り値は？

```lisp
(assoc :pon &#39;((:hoge :foo) (:huga :baz) (:piyo :pon) (:chun)))
```

# 2. パースし易い

# 2. パースし易い
----------------
## 例

* Clojure

  ```clojure
  (let [a 1
        b 2]
    ...)
  ```

* Common Lisp

  ```lisp
  (let ((a 1)
        (b 2))
    ....)
  ```
どっちが実装し易い？

# 2. パースし易い
----------------

* Common Lispの方は意味で分割してある
* 括弧は無くてもパースは出来る
* 機械にパースし易い≒人間にパースし易い


# 3. 編集が楽になる

# 3. 編集が楽になる
------------------
## 前提
* エディタに文/式/トークン(Lispの場合は全てS式)単位の編集機能がある
   + S式単位でカーソル移動
   + S式単位の削除/カット
   + S式単位のスワップ
   + etc....

# 3. 編集が楽になる
------------------
## 例（偶によくある）
この`c`の束縛を上のletに持っていきたいときどうする？

```lisp
(let ((a 1)
      (b 2))
  ....
  (let ((c 3)
        (d 4))
    ...))
```

# 3. 編集が楽になる
------------------
## 例（偶によくある）

* 意味で括弧をつけていれば1カット移動1ペースト
* Clojure方式だと2カット移動1ペースト
* `c`だけじゃなくて`d`も、と考えると…

# 4. 壊れにくい

# 4. 壊れにくい
---------------
## 例
ageの計算が壊れているとする

```lisp
(:name &#34;κeen&#34;
 :age  (year-of-time-interval (date- (today) (date 1992 5 17)))
 :place &#34;Shibuya&#34;)
```


# 4. 壊れにくい
---------------
## 例
コメントアウトしてみる（壊れた）

```lisp
(:name &#34;κeen&#34;
 :age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 :place &#34;Shibuya&#34;)
```

# 4. 壊れにくい
---------------
## 例
ageの計算が壊れているとする

```lisp
((:name &#34;κeen&#34;)
 (:age  (year-of-time-interval (date- (today) (date 1992 5 17))))
 (:place &#34;Shibuya&#34;))
```

# 4. 壊れにくい
---------------
## 例
(エディタサポートあり)

コメントアウトしてみる（壊れない）

```lisp
((:name &#34;κeen&#34;)
 (:age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 )
 (:place &#34;Shibuya&#34;))
```

# ここまでのまとめ
-----------------
* 構造が文脈に依存していると
  + 人間に分りづらい
  + プログラムに分りづらい
  + エディタに分りづらい
  + 壊れやすい

# Q. When Semantic?
------------------------------
## A. 言語を設計するとき &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;

* つまりマクロを書くとき &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;

# Q. When Semantic?
------------------------------
## A. 言語を設計するとき

* マクロを書くときそれなりのDSLを設計する
* プログラム上は必須ではない括弧もあった方が良いときもある


# まとめ
--------

* 括弧が少ない方が書き易いとは限らない
  + 「書く」だけなら速くてもwrite onlyになってしまうかも&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
* プログラムの意味を考えながら括弧つけよう
  + Lisperはどうせ括弧は見えない&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;

&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>claspを少し触ってみた</title>
      <link>http://localhost:1313/slide/clasp/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/slide/clasp/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# claspを少し触ってみた
----------------------
Lisp Meet Up presented by Shibuya.lisp #21  
2014-10-29  
κeen(@blackenedgold)

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:relative;right 0;&#34; --&gt;

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます


# clasp
-------

* Github: [drmeister/clasp](https://github.com/drmeister/clasp)
* 2014-09-18に0.1リリース(現在0.11プレビューが出ている)
* 今は0.11プレビューが出ている
* ANSI Common Lisp準拠を目指す(現在80 ~90%)
* ECLからのフォーク
* LLVMベースのJIT([MCJIT](http://llvm.org/docs/MCJITDesignAndImplementation.html))搭載
* C++とLispで書かれている
* C++との連携を意識

Note:
C++との連携の部分を強調。今回は0.11プレビューでの話


# メモリ管理
------------------

* Memory Pool Systemと Boehm GCから選べる
* ビルドするときにどっちかを選ぶ


# メモリ管理
------------------
## [Boehm GC](http://www.hboehm.info/gc/)

* Mark &amp;amp; Sweepのライブラリ
* 枯れた有名なライブラリ
* Lisp有名どころではGaucheが使う
* RedHat系だとこれを使ってないとrpmリジェクトされやすいらしい(?)

Note:
他にはMozilla, W3M, GNU GCJ, GNU Obj-Cなどなど

# メモリ管理
------------------
## [Memory Pool System](http://www.ravenbrook.com/project/mps/)

* 複数のGCアルゴリズムを組み合わせて使えるらしい
* since 1994
* あまり分からないです&amp;gt;&amp;lt;


# 依存ライブラリ
----------------------

* LLVM **3.6**
* LLVM/clang **3.5** compiler
* Boost build v2
* boost libraries ver 1.55
* Boehm 7.2
* gmp-6.0.0
* expat-2.0.1
* zlib-1.2.8
* readline-6.2


&lt;span style=&#34;font-size:600%&#34;&gt;無理&lt;/span&gt;


# externals-clasp
--------------------------

* Github: [drmeister/externals-clasp](https://github.com/drmeister/externals-clasp)
* 依存ライブラリを揃えるのが難しいとの声から作られた
* 依存ライブラリを全てビルド&lt;!-- .element: class=&#34;fragment grow&#34; --&gt;


&lt;span style=&#34;font-size:300%&#34;&gt;＼LLVMをビルド／&lt;/span&gt;


&lt;span style=&#34;font-size:300%&#34;&gt;＼Boostをビルド／&lt;/span&gt;

&lt;span style=&#34;font-size:200%&#34;&gt;ビルド時間はお察しです&lt;/span&gt;

# 本体のビルド
------------------
Twitter実況をどうぞ↓↓

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangがメモリ6GB以上食い続けてて怖い。何やってんの。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526417151486205952&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangの起動時間1時間超えてますよ…&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526418636735401984&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;HDDプチプチ言ってるし今にも壊れそう&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526420001587068929&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/nobkz&#34;&gt;@nobkz&lt;/a&gt; claspのコンパイル中です。&amp;#10;clangなのにIOネックという謎の状態です。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526420473232367616&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangの消費メモリ7GB超えた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526423982992420864&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;ビルドは自己責任で&lt;/span&gt;

# 使ってみる
------------
## 起動オプション

```
/usr/local/clasp/bin/clasp_mps_o --help
clasp options
-I/--ignore-image    - Don&#39;t load the boot image/start with init.lsp
-i/--image file      - Use the file as the boot image
-N/--non-interactive - Suppress all repls
-v/--version         - Print version
-s/--verbose         - Print more info while booting
-f/--feature feature - Add the feature to *features*
-e/--eval {form}     - Evaluate a form
-l/--load {file}     - LOAD the file
-r/--norc            - Don&#39;t load the ~/.clasprc file
-n/--noinit          - Don&#39;t load the init.lsp (very minimal environment)
-s/--seed #          - Seed the random number generator
-- {ARGS}*           - Trailing are added to core:*command-line-arguments*
```

# 使ってみる
------------
## ASDF

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ASDFの処理系依存の部分(`#+`)の問題
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ECLと見做されるけどECLのコードは動かない

# 使ってみる
------------
## cl-ppcre

* [手動ロードスクリプト](https://gist.github.com/KeenS/4e25cb6e424ebe4e7a4a)
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;`schar`がない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ANSI Common Lispにあるのに…

# 使ってみる
------------
## C++との連携

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;ドキュメントがない
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;サンプルコードもない
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;遂行不能

# 使ってみる
------------
## LLVMの呼び出し
* [clasp/src/llvmo/demo.lisp](https://github.com/drmeister/clasp/blob/master/src/llvmo/demo.lsp)
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない

# 使ってみる
------------
&lt;style type=&#34;text/css&#34;&gt;
.graph{
  background:#aaa;
  border-radius:5px;
  white-space: nowrap;
  text-align: left;
}
td {
  white-space: nowrap;
}
&lt;/style&gt;

処理系              |  `(time (fib 29))`
--------------------|-----------------------------------------------------------------
clasp-0.1(boehm)    | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(264.3px * 3);&#34; data-fragment-index=&#34;1&#34;&gt;26.43s&lt;/div&gt;
clasp-0.1(mps)      | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(172.8px * 3);&#34; data-fragment-index=&#34;1&#34;&gt;17.28s&lt;/div&gt;
clasp-0.11(boehm)   | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(213.2px * 3);&#34; data-fragment-index=&#34;2&#34;&gt;21.32s&lt;/div&gt;
clasp-0.11(mps)     | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(187.9px * 3);&#34; data-fragment-index=&#34;2&#34;&gt;18.79s&lt;/div&gt;
ECL-13.5.1          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 16.0px * 3);&#34;&gt;1.603s&lt;/div&gt;
ECL-13.5.1(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  1.9px * 3);&#34;&gt;0.192s&lt;/div&gt;
ABCL-1.3.1          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 32.9px * 3);&#34;&gt;3.292s&lt;/div&gt;
ABCL-1.3.1(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  2.4px * 3);&#34;&gt;0.241s&lt;/div&gt;


# 使ってみる
------------

処理系              |  `(time (fib 29))`
--------------------|-----------------------------------------------------------------
CLISP-2.49          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 38.4px * 3);&#34;&gt;3.847s&lt;/div&gt;
CLISP-2.49(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  7.1px * 3);&#34;&gt;0.7146s&lt;/div&gt;
ccl-1.10            | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.4px * 3);&#34;&gt;0.04033s&lt;/div&gt;
sbcl-1.2.5          | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.6px * 3);&#34;&gt;0.06469s&lt;/div&gt;
alisp-9.0           | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  230px * 3);&#34;&gt;23.09s&lt;/div&gt;
alisp-9.0(compile)  | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.6px * 3);&#34;&gt;0.06194s&lt;/div&gt;

&lt;span style=&#34;font-size:200%&#34;&gt;LLVM/JITなのになぜ遅い？&lt;/span&gt;

# LLVM/JITで遅い？
-------------------------

* LLVMって速いんじゃ？
* JIT搭載した○○が速いって聞いたよ
  + JVM
  + lua-jit
  + Rubinius
  + pypy


# 言葉の罠: LLVM
--------------------

* 遅いコードはどんなに頑張っても遅い
* ECLのバックエンドにClang(=LLVM)を使ってもSBCLに勝てないのと同じ


# 言葉の罠: JIT搭載
--------------------

* JIT(実行時コンパイル)の意味は広い
* 実行時にネイティブコードを吐けばJITと言える
* claspは実行直前にコンパイルするだけ
* 多くの速いJIT処理系はTracing JITを使う
  + またの名を適応的コンパイル
  + 実行時の情報に基いて実行中に最適化する
  + `(declare ...)` を自動生成してる的な


# Tracing JITへの道
--------------------

* LLVMのJITは実行直前にコンパイルするだけ
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;Tracing JITのバックエンドには使える
* 実行時最適化には最適化用のコードが必要
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;Common Lispでは`(declare ...)`用のコードを使い回せる
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;案外近い


# 結論
------

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;遅い
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;時期尚早
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;今後機能や速度改善があれば使えるようになるかも


&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>C6H6&#43;HNO3</title>
      <link>http://localhost:1313/slide/c6h6-plus-hno3/</link>
      <pubDate>Fri, 24 Oct 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/slide/c6h6-plus-hno3/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# $\mathbf{C_6H_6+HNO_3}$
------------------------
関数型なんたらの集い &lt;2014-10-25&gt;  
κeen(@blackenedgold)

# picrinについて
---------------
![ピクリン酸の構造式](/images/picrin/picrin-structure.png)  
化学式 $\mathbf{C_6H_3N_3O_7}$、示性式 $\mathbf{C_6H_2(OH)(NO_2)_3}$ で表される芳香族のニトロ化合物。  
一般にはフェノールのニトロ化によって得られる。

Note:
ニトロ化に硫酸を使うことを触れる。

![picrinのロゴ](/images/picrin/picrin-logo-fin01-02.png)  

# About Me
----------

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, ML, Shell Scriptあたりを書きます
 + [picrin](https://github.com/picrin-scheme/picrin)のコミッタです


# picrinについて
----------------

* github: picrin-scheme/picrin
* R7RS-small scheme 処理系
* 速い、軽い、高機能を目指す
* 組み込み向けを意識
* 1年くらい開発
* κeenがコミットし始めてから半年弱


# picrinの プロジェクト構成
---------------------------
コア(benz)はC、ビルドツールはCMake。

```
├── contrib (nitros)
   .......
├── docs
├── etc
├── extlib
│   └── benz
├── piclib
   ....
└── src
```

Note:
contribとextlib/benzを強調。
srcはほぼ空であることにも触れる。

# nitrosの紹介
---------------

* schemeやCで書かれている
* picrinのコンパイル時に一緒にlibpicrinに入る
* picrinと共にCMakeで管理されている

Note:
schemeファイルもlibpicrinにCの文字列として入ってることに触れる。
バイトコンパイルプロジェクトにも触れる。
nitrosも一緒にコンパイルされることを強調する。


# nitroの紹介
---------------
## [R7RS](https://github.com/picrin-scheme/picrin/tree/master/contrib/05.r7rs/scheme)

* picrinではr7rsもただのライブラリ
* 組み込みのときに必要なければ外せばよい

Note:
リンクを辿る必要はない。
スライドは下に続く。


# nitroの紹介
---------------
## [partcont](https://github.com/picrin-scheme/picrin/blob/master/contrib/10.partcont/piclib/partcont.scm)

* ただの限定継続ライブラリ
* ねこはるさんが詳しく話すと思うのでそちらに譲ります

Note:
リンクを辿ってソースを見せる。

# nitroの紹介
---------------
## [for](https://github.com/picrin-scheme/picrin/blob/master/contrib/20.for/piclib/for.scm)

* 非決定性計算ライブラリ
* またの名をListモナド

Note:
リンクを辿ってソースを見せる。

# nitroの紹介
---------------
## [regexp](https://github.com/picrin-scheme/picrin/blob/master/contrib/10.regexp/src/regexp.c)

* Unixのregexライブラリのバインディング
* Cで書かれている

Note:
リンクを辿ってソースを見せる。
詳細に説明する。

 + `regexp_t`型
 + dtor
 + GCに乗ることは強調


# nitroの依存関係の話
---------------------

* nitro同士に依存関係がある
* forはpartcontに依存する
* REPLはeditlineに依存する
* etc...


# picrinの依存関係解決法
-----------------------

[picrin/contrib](https://github.com/picrin-scheme/picrin/tree/master/contrib)

Note:

* リンクを辿る
* ディレクトリ名が数字で始まることを説明
* 03まできてそろそろ限界であることを説明


どう見ても&lt;span style=&#34;font-size:150%&#34;&gt;手動(ディレクトリ名)ソート&lt;/span&gt;ですね。  
本当にありがとうございました。


* さすがにどうにかしたい
* 依存関係解決ツールが欲しい
* なんかmrubyのmrbgemとかみたいにしたら楽しいんじゃね？
* 個々のnitroを別プロジェクトにも出来る!


# sulfuricプロジェクト

# sulfuricプロジェクト
---------------------

* sulfuric acid = 硫酸
* nitro定義、依存解決、ビルドコンフィグ etc...
* 最終的にはCMakeと連携
* 定義ファイルはschemeで書きたい

Note:
個人案なことに触れる。
chikenのeggsやRacketのPlanetにも触れる。


# sulfuricプロジェクト
---------------------

* あれ？R7RSってnitroじゃね？
* そもそもschemeをビルドするためにschemeを書く…？
* てかCMakeとの連携どうするよ

Note:
進捗はまだinitial commitすら出来てない。
書いてる内に大きくなっていったことも説明。
最初は他のschemeでビルドする案やフェノールでビルドする案も話す。
solutionディレクトリに入れたいよねーも話す。
フェノールの合成にベンゼンスルホン酸が使われる


# picrinにコミットしよう
-----------------------

* picrinはまだ若い
  + ちょろっと覗くだけでコミット出来るところが見付かる
* 開発者全員日本人


# コミットはとっても簡単
------------

1. [issue](https://github.com/picrin-scheme/picrin/issues)を覗く
2. 簡単そうなのをサクっと実装
3. PR

Note:
イシューの中から

  + \#224 feature request: data structures
  + \#210 Add MQTT support

を見せる


# Q. なぜpicrin?
------------

# A. picrinの独自拡張
-----------------

* [ドキュメント](http://picrin.readthedocs.org/en/latest/)に色々書いてある
* C拡張の書き方も書いてある

Note:
arrayとdictionaryに触れる。
マクロに触れる
C APIの項目があることにも触れる。


# picrinのマクロ
----------------

* `syntax-rules` (R7RS)
* `sc-macro-transformer`
* `rsc-macro-transformer`
* `ir-macro-transformer`
* `er-macro-transformer`
* `define-macro` (Common Lisp)

参考: [様々な Hygienic Macro - 月の塵](http://d.hatena.ne.jp/leque/20080528/p1)


# picrinにコミットしよう
-----------------------

* issueに上がってなくても大歓迎
* Schemeの練習に
* 「便利なライブラリ書いたけどどこ置いたら良いの」



# picrinにコミットしよう


&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Picrinのチューニングの話、もといGCの話</title>
      <link>http://localhost:1313/slide/picrin-gc/</link>
      <pubDate>Mon, 29 Sep 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/slide/picrin-gc/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Picrinのチューニングの話、もといGCの話
---
Lisp Meet Up presented by Shibuya.lisp #20  
2014-09-29  
κeen(@blackenedgold)

# 自己紹介
---
 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます
 + [picrin](https://github.com/picrin-scheme/picrin)のコミッタです

# picrin
---
![picrin](/images/picrin/picrin-logo-fin01-02.png)

# picrin
---
* R7RS compatibility
* bytecode interpreter (based on stack VM)
* internal representation by nan-boxing
* conservative call/cc implementation (users can freely interleave native stack with VM stack)
* exact GC (simple mark and sweep, partially reference count is used as well)
* string representation by rope data structure

# picrin
---
* R7RS compatibility
* &lt;strong&gt;bytecode interpreter (based on stack VM)&lt;/strong&gt;
* internal representation by nan-boxing
* conservative call/cc implementation (users can freely interleave native stack with VM stack)
* &lt;strong&gt;exact GC (simple mark and sweep, partially reference count is used as well)&lt;/strong&gt;
* &lt;strong&gt;string representation by rope data structure&lt;/strong&gt;

# picrin開発者の不満
---
* picrinの起動が遅い&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
  + 2秒くらいかかる &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
* picrinのテストが遅い&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
  + 16秒くらいかかる &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;

# 少しGCの話
---
GC(ごみ集め)とは

* 使われていないオブジェクトを自動的に解法する
  + メモリ管理に煩わせられないで済む
  + メモリーリークを防ぐ。
* 「使われていないオブジェクト」を判定するのはいくつかアルゴリズムがある


# GCのアルゴリズム
---
## 主なGCのアルゴリズム
* マーク&amp;amp;スイープ
* 参照カウント
* Copying GC

# GCのアルゴリズム
---
## マーク&amp;amp;スイープ
 1. あらかじめ全てのオブジェクトはどこかで一元管理する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
 2. 一元管理元(ヒープ(ページ))でメモリが足りなくなったらGCを開始&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
 3. スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;
 4. そこから辿れるオブジェクトも再帰的にマークする&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;4&#34; --&gt;
 5. ヒープからマークされていないオブジェクトを開放する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;5&#34; --&gt;
 6. それでもメモリが足りなければ一ヒープのページを増やす&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;6&#34; --&gt;
 7. 増やせなければメモリを使い果したのでabort&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;7&#34; --&gt;

# GCのアルゴリズム
---
## マーク&amp;amp;スイープの特徴
 * そこそこ速い
 * 正確に集められる
 * GC以外ではメモリ管理を考えなくて良い(≒プラグインは書き易い)
 * 長生きのオブジェクトは何度もマークされる(=&gt;世代別GC)
 * 負荷は1点に集中する
 * メモリの断片化が起きる(=オブジェクトのアロケートが遅くなる)

# GCのアルゴリズム
---
## 参照カウント
 1. オブジェクトに他から参照されている数(参照カウント)を記憶させる&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
 2. オブジェクトの参照を変えるときはその都度参照カウントを変える&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
 3. 参照カウントが0になったら開放する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;

# GCのアルゴリズム
---
## 参照カウントの特徴
 * 負荷は分散する
 * GCの実装は楽
 * 少し遅い(必ずfreeする必要がある)
 * 正確でない(循環参照に弱い)(cf. 大相撲の星の回しあい)
 * プラグインは面倒

# GCのアルゴリズム
---
## Copying GC
 1. オブジェクトプールを2つ用意する(1, 2)とする&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
 2. オブジェクトを確保するときは必ず1に確保する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
 3. 1のメモリが足りなくなったらgcを開始&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;
 4. 1の生きているオブジェクトを再帰的に2に移動する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;4&#34; --&gt;
 5. 1に残っているものは全てゴミとして良い&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;5&#34; --&gt;
 6. 1、2のラベルを付け換える&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;6&#34; --&gt;

# GCのアルゴリズム
---
## Copying GCの特徴
 * 正確
 * メモリの断片化が起きない(Windowsのデフラグ)(=アロケートが速くなる)
 * 負荷は1点に集中する
 * 遅い(オブジェクトの移動が必要)
 * メモリ食う(オブジェクトプール2つ分)
 * ポインタも変わるため、ハッシュの再計算などが必要

# GCのアルゴリズム
---
## GCの主な属性
* 世代別
  + 新しいオブジェクトだけGCの対象にする&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
* 正確
  + ゴミは必ず回収する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
* インクリメンタル
  + 一度にやらずに少しづつGCを進める&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;

# picrinのGC
---
![picrin](/images/picrin/picrin-logo-fin01-02.png)

# picrinのGC
---
* 基本は普通の正確なマーク&amp;amp;スイープ
  + Copying GCはlightweightでない
* ropeには参照カウント
  + ropeには循環参照が起きない

# picrinのGC
---
 * 基本はマーク&amp;amp;スイープ

&gt; 3. スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする

 * schemeの変数はそのまま
 * Cの変数は読めないのでアリーナという場所を用意してC内ではそこに一時保管してもらう
   + スコープはFILOなのでスタックを用いればヒープより速くアロケート出来る

# picrinのチューニング
## プロファイルをとってみる
---

```
 % cumulative self self total
time seconds seconds calls s/call s/call name
37.14 0.78 0.78 13136494 0.00 0.00 XROPE_DECREF
23.81 1.28 0.50 1544 0.00 0.00 gc_sweep_phase
15.72 1.61 0.33 59344814 0.00 0.00 gc_mark_object
10.00 1.82 0.21 1544 0.00 0.00 gc_mark_phase
6.67 1.96 0.14 1544 0.00 0.00 gc_mark_trie
2.38 2.01 0.05 6523 0.00 0.00 pic_apply
```

&lt;span style=&#34;font-size:200%&#34;&gt;ほとんどGCですね。  
本当にありがとう御座いました。&lt;/span&gt;

# 解決案
---
* GCのアルゴリズムを変える
* オブジェクトをアロケートしないようにする
* パラメーターをいじる

# 解決案
---
* GCのアルゴリズムを変える
* オブジェクトをアロケートしないようにする
* &lt;strong&gt;パラメーターをいじる&lt;/strong&gt;

# GCに関連するパラメータ
---
元々tinyに設計されている

```C
/* アリーナのサイズ */
# define PIC_ARENA_SIZE 1000
/* ヒープページのサイズ */
# define PIC_HEAP_PAGE_SIZE 10000
/* シンボルプール(ハッシュ)のサイズ */
# define PIC_SYM_POOL_SIZE 128
```

# GCに関連するパラメータ
---
チューニング後

```C
/* アリーナのサイズ */
# define PIC_ARENA_SIZE 8 * 1024
/* ヒープページのサイズ */
# define PIC_HEAP_PAGE_SIZE 2 * 1024 * 1024
/* シンボルプール(ハッシュ)のサイズ */
# define PIC_SYM_POOL_SIZE 2048
```

# 結果
---
* 昔
  &gt; テストに16秒

* 変更後
  &gt; time make test-r7rs  
  &gt; make test-r7rs  &lt;strong&gt;1.68s&lt;/strong&gt; user 0.23s system 98% cpu 1.931 total
  &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;


# 今後
---
* GCのアルゴリズムを変える
 + 世代別GCにしたいよねー
 + そもそもマーク&amp;amp;スイープの実装が適当すぎるだとか。協議中。
 + 組み込み目指すならインクリメンタル性必要では？
* オブジェクトをアロケートしないようにする
  + バイトコンパイルするときにもめちゃくちゃアロケートしてる。その辺どうにかする。
  + [Fast Reader](https://github.com/picrin-scheme/picrin/pull/207)


# まとめ
---
* 基本的なGCの解説をした
* picrinのGCの戦略を話した
* GCチューニング大事

&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to CIM</title>
      <link>http://localhost:1313/slide/introduction-to-cim/</link>
      <pubDate>Sat, 30 Aug 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/slide/introduction-to-cim/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Introduction to CIM
&lt;hr /&gt;

κeen(@blackenedgold)  

## 突然ですが
Common Lispのスクリプトファイルの実行方法知ってますか？

sbcl

    sbcl --script $file

ecl

    ecl -shell $file

ccl

    ccl -e $file -e &#39;(quit)&#39;

...

&lt;strong&gt;シバン可搬性のあるスクリプトが書けない&lt;/strong&gt;

## そこで、こんなの書きました
&lt;hr /&gt;

```sh
case &#34;$LISP_IMPL&#34; in
    sbcl*)
        sbcl --script $1
        ;;
    clisp*)
        clisp -on-error exit -i $1
        ;;
    ecl*)
        ecl -shell $1
        ;;
    ccl*)
...
```

## でも問題がある
&lt;hr /&gt;

* どの処理系をバックエンドに使うか
* 処理系のパスをどう捜すか
* そもそもどうやって使ってもらうか

## κeenの答え
&lt;hr /&gt;

&gt; 処理系の管理までやってしまおう。
&gt; そうしたら一緒に使ってもらえる。

＿人人人人人人＿  
＞　CIMの誕生　＜  
￣Y^Y^Y^Y^Y￣

## CIMとは
&lt;hr /&gt;

* Common Lisp Implementation Manager
* ちむ
* Rubyのrvmを強く意識
* Common Lisp処理系のインストール、切り替え、コマンドラインインターフェースなど。
* `cim`、 `cl`、 `ql`コマンドから成る
* B Shell スクリプト製(マルチプラットフォーム対応のため)
* 2013/10くらいからぼちぼち開発

## `cim`コマンドについて
&lt;hr /&gt;

インストール

    cim install sbcl

バックエンドの切り替え

    cim use sbcl

現在情報

    cim info

CIMのアップデート

    cim get

など。

## `cl`コマンドについて
&lt;hr /&gt;

* 最初に紹介したシェルスクリプトベース
* コマンドラインからCommon Lispを使うことを重視
* シバン対応も。
* REPLは独自実装(デバッガを黙らせるのが主な目的)
* オプションはrubyを意識

## 少しシバンの話
&lt;hr \&gt;

### だめな例

```lisp
#!cl
(write-line &#34;ok&#34;)
```

```lisp
#!/home/kim/.cim/bin/cl
(write-line &#34;ok&#34;)
```

```lisp
#!/usr/bin/env cl -q
(write-line &#34;ok&#34;)
```

### 推奨される例

```lisp
#!/bin/sh
#|
exec cl --  &#34;$0&#34; &#34;$@&#34;
|#
(write-line &#34;ok&#34;)
```


## `ql`コマンドについて
&lt;hr /&gt;

* quicklispのコマンドラインインターフェース
* まだ未熟
* rubyのgem的な。
* 最近`ql install`を高速化

## その他の話
&lt;hr /&gt;

### 対応処理系
* 処理系はabcl, alisp, ccl, clisp, ecl, sbcl対応
* 基本ビルドする
* gclはANSIじゃないのでドロップ
* lispworks他商用ははインストール出来ないのでドロップ
* mkcl対応する？
* CMU CLはつらい…

### 実装
* B Shell スクリプトで書いたの失敗だった?
* つらい
* 開発速度に影響
* テスト（=品質）にも影響
* sbclがじゃじゃ馬でつらい

### 方針
* コマンドラインユーティリティである
* 基本POSIX以外に依存しない
* 極力環境に影響しない(rvmがひどいのを嫌って)
* clコマンドはあくまで薄いラッパ
* asdfも使わない

## [半年前](http://www.slideshare.net/blackenedgold/cim-common-lisp-implementation-manager?ref=http://keens.github.io/blog/2014/01/24/lisp-meet-up-number-13/)から何が変わったか
&lt;hr /&gt;

* バグ潰し
* その他細かな改善
  + ダンプされたコアを読み込む機能
  + SIGINTをハンドル
  + ビルド時のログ制御
* ぼちぼちテスト書き始めた

## 将来の話
&lt;hr /&gt;

* テストと品質の安定化
* バイナリ配布の処理系は大人しくバイナリ使う？
* 最適なビルドオプション
* コアダンプ機能
* Lispスクリプト(実行可能ファイル)インストーラ
* cl21との連携（バイナリ生成）
* もうちょっとquicklispとの連携
* ユーザー拡張

## 関連リソース
&lt;hr /&gt;

* [The problem with Lisp ](http://pupeno.com/2007/08/26/the-problem-with-lisp/) : Lispはコマンドが作れないから流行らないという分析
* [CIMの解説をしてみる コマンド編 | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2014/01/27/cim-explanation/) : CIMの解説記事
* [shelly](https://github.com/fukamachi/shelly) : CIMを使うCLのコマンドラインインターフェース
* [lsp](https://github.com/snmsts/lsp) : CIMのC実装
* [qlot](https://github.com/fukamachi/qlot) : `ql`よりリッチなquicklispラッパ

&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>授業で半年間moclを使ってみた</title>
      <link>http://localhost:1313/slide/shibuya-dot-lisp-tt-number-8/</link>
      <pubDate>Thu, 28 Aug 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/slide/shibuya-dot-lisp-tt-number-8/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;


# 授業で半年間moclを使ってみた
&lt;hr /&gt;

Shibuya.lisp TT #8  
&lt;br&gt;
κeen(@blackenedgold)  

## 自己紹介
&lt;hr /&gt;

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

 一年前

## [計算数学II](http://ks.ms.u-tokyo.ac.jp/)
![計算数学IIのホームページ](/images/shibuya_lisp_TT8/calculation_math.png)

自分でテーマを決めて半年間取り組む

チーム[人造エイリアン](https://sites.google.com/site/2013ks2/home)
![チーム人造エイリアン](/images/shibuya_lisp_TT8/android_alien.png)

## Common Lisp でAndroid?

## [mocl](https://wukix.com/mocl)
![mocl home](/images/shibuya_lisp_TT8/mocl.png)

## What is mocl
&lt;hr /&gt;

* iOS, Androidで動くCommon Lisp処理系
* LLVMをバックエンドに使う
* Networking, Unicode, CLOS, and More. Run Countless CL Libraries.

## 買ってもらった(・ω・)v
![mocl home](/images/shibuya_lisp_TT8/mocl_ut.png)

## 注意
&lt;hr /&gt;

私が触ったのは1つ前のバージョンです。

一部5月のアップデートで改善されています。

## How it Works
&lt;hr \&gt;

&lt;embed src=&#34;/images/shibuya_lisp_TT8/mocl_flowchart.svg&#34; type=&#34;image/svg+xml&#34; height=&#34;500px&#34; /&gt;

## コードサンプル
&lt;hr \&gt;

授業で私が作ったオセロのAIのコード

```java
public BoardCanvas(Context context,int width, int height,int color ){
    ...
    CL.cl_init();
    CL.init_game(3 - color);
    ...
}
   
void nextHand(){
    String[] coord = CL.next().split(&#34; &#34;);
    CL.jput(Integer.parseInt(coord[0]), Integer.parseInt(coord[1]) , color);
    ...
}
```

```lisp
(declaim (call-in next))
(defun next ()
  (let ((dummy (make-board))
        (max most-negative-fixnum)
	    (x) (y) (score))
    ...
    ))
(declaim (call-in init-game))
(defun init-game (color)
  (setf *board* (make-board))
  (setf *ai* color))
(declaim (call-in jput))
(defun jput (x y color)
  (put *board* x y color))
```


## ライブラリについて
&lt;hr /&gt;

* ASDFが使える
* `MOCL_HOME/systems/`以下に配置
* quicklispでインストールしたやつは`MOCL_HOME/systems/`にひたすら`ln -s`
* 大抵のライブラリは動かない

例えば`cl-annot`を使って

```lisp
(declaim (call-in jput))
(defun jput (x y color)
  (put *board* x y color))
```
を

```lisp
@call-in
(defun jput (x y color)
  (put *board* x y color))
```
としたい

私のときはCFFIを始め、ironclad、cl-annotなど、  
使おうとしたライブラリは全て動かなかった

現在の状態は不明

## 作業フロー(Android)
&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;CLのコードを書いてSBCLで動かす&lt;/li&gt;
&lt;li&gt;ある程度動いたらmoclでAndroid用のコードを生成&lt;/li&gt;
&lt;li&gt;原因不明のエラーが出るので1に戻る&lt;/li&gt;
&lt;li&gt;コンパイルが通れば生成されたCをコンパイル&lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;JavaからCLを呼び出すコードを書く&lt;/li&gt;
&lt;li&gt;アプリをコンパイル&lt;/li&gt;
&lt;li&gt;実機/エミュレータに転送&lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;動かす&lt;/li&gt;
&lt;li&gt;動かない&lt;/li&gt;
&lt;li&gt;ひたすらlogcat眺める&lt;/li&gt;
&lt;li&gt;1に戻る&lt;/li&gt;
&lt;/ol&gt;

### ここがつらい
&lt;hr /&gt;

* 作業が煩雑
* 例外のスタックトレースがJNIのせいで追いづらい
* logを出すには`rt:format`という関数のみ使える(ログレベルを設定出来ない)

※ 今はREPLが端末で動くので環境は良くなっています。

## 制限など
&lt;hr /&gt;

* Java/Obj-CからCLを呼ぶことしか出来ない
  + プラットフォームのライブラリも呼べない
* やりとり出来るのは文字列、数値、真偽値のみ
  + 裏でタスクを回すworker的な役割or純粋関数的な役割のみ

※ 今はCLからObj-Cを呼ぶことが出来ます。

## 成果物
&lt;hr /&gt;

* [コード(抜粋)](https://gist.github.com/KeenS/15e7bb35519818c88c13)
* [最終発表スライド](http://www.slideshare.net/blackenedgold/ss-30373688)
* [デモ動画](http://www.slideshare.net/blackenedgold/ss-30373688)

## おまけ

## 5月のアップデート内容
&lt;hr /&gt;

* OS Xアプリケーション対応
* 端末内でREPLが動く
* FFI強化
* Lisp内Obj-C構文
* iOSとOS XでのネイティブSSL対応
* ARM64サポート
* ドキュメントの改善
* 多くのバグフィクス

&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Cloud 9の紹介</title>
      <link>http://localhost:1313/slide/cloud-9/</link>
      <pubDate>Tue, 29 Jul 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/slide/cloud-9/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Cloud 9の紹介
&lt;hr /&gt;

Lisp Meet Up #19 presented by Shibuya.lisp  
κeen(@blackenedgold)  

## 自己紹介
&lt;hr /&gt;

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

## Lispがあまり使われない原因
&lt;hr /&gt;

&lt;ul&gt;
&lt;li class=&#34;fragment&#34;&gt;認知度が低い&lt;/li&gt;
&lt;li class=&#34;fragment&#34;&gt;&lt;strong&gt;開発環境構築の難易度高い&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

## Cloud 9について
&lt;hr /&gt;

 + WEBベースのIDEサービス
 + 40以上の言語に対応（らしい）
 + この間正式リリース
 + 1アカウント毎に1Docker環境与えられる
 + IDEはオープンソース
 + よく分かってない

## こんなん
&lt;img src=&#34;/images/cloud9/login.png&#34; alt=&#34;ログイン画面&#34; /&gt;

&lt;img src=&#34;/images/cloud9/dashboard.png&#34; alt=&#34;ダッシュボード&#34; /&gt;

&lt;img src=&#34;/images/cloud9/workspace.png&#34; alt=&#34;ワークスペース&#34; /&gt;

&lt;img src=&#34;/images/cloud9/lookandfeel.png&#34; alt=&#34;こんなかんじ&#34; /&gt;

&lt;img src=&#34;/images/cloud9/CIMworks.png&#34; alt=&#34;CIMも動く&#34; /&gt;

&lt;img src=&#34;/images/cloud9/clworks.png&#34; alt=&#34;CLもRun出来る&#34; /&gt;

## デモ

## 良いところ
&lt;hr /&gt;

 + 難易度低い
 + Lisp環境動く
 + Githubとの連携
 + どこからでも同じ環境にアクセス
 + キーバインドはうれしい各宗教対応の  
 {Mac, Windows}x{Default, Emacs, Vim, Sublime}


## 微妙なところ
&lt;hr /&gt;

 + シンタックスハイライト微妙  
 （せめてキーワード引数はどうにか）
 + 補完微妙
 + インデント微妙
 + swank使いたい

&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>(S式で書く(altJS)達)</title>
      <link>http://localhost:1313/slide/sshi-deshu-kualtjs/</link>
      <pubDate>Sun, 13 Jul 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/slide/sshi-deshu-kualtjs/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# (S式で書く(altJS)達)
&lt;2014-06-08 日&gt;  
κeen(@blackenedgold)  
天下一altJS武闘会(#tenka1altJS)  
@渋谷プライムプラザ四階

## 自己紹介
 + κeen
 + 東大数学科の4年生
 + Twit : @blackenedgold
 + Github : KeenS
 + Blog : [κeenのHappy Hacκing Blog](http://KeenS.github.io/)
 + Shibuya.lispにいます。(2014-06〜運営になりました)
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

## お品書き
 - (ボツ) Shen.js
 - (ボツ) Embedable Common Lisp with Emscripten
 - (ボツ) Picrin with Emscripten
 - (ボツ) オレオレaltJSの作り方の話
 - ParenScript

## Shen.js
Shenの公式ページより

  + パターンマッチ
  + λ計算ベース
  + マクロ
  + 遅延評価も可能
  + 静的型検査
  + 関数的なPrologの統合
  + ビルトインコンパイラコンパイラ

これのJS実装もある。

## 例

```lisp
(define factorial
  0 -&gt; 1
  X -&gt; (* X (factorial (- X 1))))
```

そもそもaltJSじゃない…

ボツ

## ECL with Emscripten
  + ANSI Common Lisp準拠のCommon Lisp処理系
  + LispをコンパイルしてCを吐く
  + Emscriptenでコンパイルすれば…

`#include &lt;ecl/ecl-cmp.h&gt;`
が悪さをしてコンパイル出来ない

ボツ

##  picrin
  + R7RS small準拠を目指すScheme処理系
  + R7RS準拠の中では唯一Emscriptenで
    コンパイル出来るらしい
  + SDLもEmscriptenで動くらしいから
    組み合わせればウハウハじゃね？

コンパイル出来ない…
( `va_args` は64bit x Clang3.3では
コンパイル出来ないとか言われる。回避策も効かない)

ボツ

##  オレオレaltJSの作り方の話
escodegenを使う

```javascript
{
    type: &#39;BinaryExpression&#39;,
    operator: &#39;+&#39;,
    left: { type: &#39;Literal&#39;, value: 40 },
    right: { type: &#39;Literal&#39;, value: 2 }
}
→40 + 2
```

オレオレaltJS(S式)  
 ↓ read  
リスト  
 ↓ 変換  (find-file &#34;~/Lisp/translate.lisp&#34;)  
リスト  
 ↓ cl-json  
JSON  
 ↓ escodegen  
JS

escodegenのドキュメントがあんまりない…

ボツ

## ParenScript
  + Common Lisp製
  + Weblocks(WAF)に採用されるなどの実績/伝統
  + Common LispのサブセットをJSにコンパイル
  + 実際はCommon Lispのマクロなので
    Common Lispに組み込んで使える
  + ランタイムライブラリは必要ない
  + Lispを無理矢理変換するというより
    LispっぽくJSを書ける感じ

### 例
~/Lisp/parenscript.lisp

 + `(@ obj property)` でプロパティ参照
 + `(chain obj function/property)` でメソッドチェーン
など

以上
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>言葉遣いの時代変遷を追う</title>
      <link>http://localhost:1313/slide/NLP/</link>
      <pubDate>Wed, 09 Jul 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/slide/NLP/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# 言葉遣いの時代変遷を追う
  理学部数学科4年
  金 舜琳 （きん すんりん）

## 概要
   古いものから新しいものまであるリソースから単語を抽出し、使用頻度から単語の時代変遷を追う

## 手法

## step1
&lt;hr /&gt;
青空か新聞から単語抽出抽出を行なう

* 名詞、形容詞、語尾などが候補
* 青空は多様性がある/話し言葉もとれるが古いのしかない？
* 新聞は均質だからサンプル調査に向いてる？

## step2
&lt;hr/&gt;
年代別に使用頻度上位数十〜百ぐらいを使用頻度順まとめてみる

## step3
&lt;hr/&gt;
似たような意味の単語で順位の入れ替わりが見受けられたら詳細に追ってみる  
とりあえず手動を考えている。発展課題的にプログラムでやっても良いかもしれない

##step4
&lt;hr/&gt;
変遷の背景を考えてみる  
戦前/戦後とか分りやすいものとかなんとか


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>