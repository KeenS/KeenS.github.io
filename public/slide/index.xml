<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Slide-rsses on κeenのHappy Hacκing Blog</title>
    <link>/slide/index.xml</link>
    <description>Recent content in Slide-rsses on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Wed, 01 Mar 2017 10:57:38 +0900</lastBuildDate>
    <atom:link href="/slide/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>仕事でdiesel使ってみた</title>
      <link>/slide/shigotodedieseltsukattemita/</link>
      <pubDate>Wed, 01 Mar 2017 10:57:38 +0900</pubDate>
      
      <guid>/slide/shigotodedieseltsukattemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 仕事でdiesel使ってみた
----------------------
[RustのLT会！ Rust入門者の集い #2 - connpass](https://rust.connpass.com/event/48826/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# [diesel.rs](diesel.rs)

![dieselのwebページ](/images/diesel/diesel-web.png)

===

# diesel
---------


* RustのORM
  * スキーマからコード自動生成
  * diesel_codegen
* クエリビルダ
* マイグレーション管理
* PostgreSQL, MySQL, SQLiteサポート

===

# 準備
-------

* [docker-composeでmysql &amp; postgreSQL をサクッと起動 - Qiita](http://qiita.com/astrsk_hori/items/1e683a7a2f2b7189cb6e)

```
cargo install diesel_cli
echo DATABASE_URL=postgres://username:password@localhost/hoge &gt; .env
diesel setup
diesel migration generate create_posts
```

===

# 準備
-------

``` toml
[dependencies]
chrono = &#34;0.3.0&#34;
diesel = {version = &#34;0.11.4&#34;, features = [&#34;chrono&#34;, &#34;postgres&#34;, &#34;serde_json&#34;]}
dotenv = &#34;0.8.0&#34;
serde_json = &#34;0.9.6&#34;
serde_derive = &#34;0.9.7&#34;
serde = &#34;0.9.7&#34;

[dependencies.diesel_codegen]
features = [&#34;postgres&#34;]
version = &#34;0.11.0&#34;
```

===
# プロジェクト構成
-----------------

* モデルのコンパイルが遅いので分離したい
* Cargoの[ワークスペース](http://doc.crates.io/manifest.html#the-workspace-section)機能を使う

===
# プロジェクト構成
-----------------

```
$ ls
Cargo.lock
Cargo.toml
hoge_model &lt;- diesel_derive使う
hoge_XXX   &lt;- diesel使う
hoge_YYY   &lt;- diesel使う
docker-compose.yml
migrations
...
```
===

# テーブル
---------

* up.sqlとdown.sqlを書く

``` sql
CREATE TABLE hoge_suites (
  id SERIAL PRIMARY KEY,
  hoge_entry_id INT NOT NULL,
  hostname VARCHAR NOT NULL,
  status INT NOT NULL DEFAULT 0,
  CONSTRAINT unique_hoge_entry_id_hostname
             UNIQUE (
                      hoge_entry_id,
                      hostname
                      -- and other matrix
                     ),
  CONSTRAINT fkey_hoge_entry_id
             FOREIGN KEY(hoge_entry_id)
             REFERENCES hoge_entries(id) MATCH SIMPLE
             ON UPDATE NO ACTION
             ON DELETE CASCADE
);

```

===
# モデル
--------

``` rust
// なんかいっぱいderive
// QueryableとInsertableは分ける
#[derive(Default, Queryable, Associations, Identifiable, Debug, Clone)]
// belongs_to関係のstruct
#[belongs_to(HogeEntry)]
// has_many関係のテーブル
#[has_many(hoge_results)]
#[table_name=&#34;hoge_suites&#34;]
pub struct HogeSuite {
    pub id: i32,
    pub bench_entry_id: i32,
    // String
    pub hostname: String,
    pub status: HogeStatus,
}

```

===

# モデル
--------

```
// Insertableの方
#[derive(Default, Insertable, Debug, Clone)]
#[table_name=&#34;hoge_suites&#34;]
pub struct NewHogeSuite&lt;&#39;a&gt; {
    pub hoge_entry_id: i32,
    // Stringではなく&amp;str
    pub hostname: &amp;&#39;a str,
}
```

===

# enumの扱い
-----------

* dieselはenumのcodegenをサポートしてない
* 気合

===

# enumの扱い
-----------

```rust
// Queryableとかはderive出来ない
#[derive(Debug, Clone)]
pub enum HogeStatus {
    Waiting,
    Running,
    Finished,
    Failed,
    Canceled,
}

// 手で実装
impl&lt;BE, QB, BC&gt; FromSql&lt;Integer, BE&gt; for HogeStatus
    where QB: QueryBuilder&lt;BE&gt;,
          BC: BindCollector&lt;BE&gt;,
          BE: Backend&lt;RawValue = [u8], QueryBuilder = QB, BindCollector = BC&gt;
{
    fn from_sql(bytes: Option&lt;&amp;&lt;Pg as Backend&gt;::RawValue&gt;)
                -&gt; Result&lt;Self, Box&lt;Error + Send + Sync&gt;&gt; {
        use self::HogeStatus::*;
        match &lt;i32 as FromSql&lt;Integer, Pg&gt;&gt;::from_sql(bytes)? {
            0 =&gt; Ok(Waiting),
            1 =&gt; Ok(Running),
            2 =&gt; Ok(Finished),
            3 =&gt; Ok(Failed),
            4 =&gt; Ok(Canceled),
            n =&gt; Err(format!(&#34;invalid status: {}&#34;, n).into()),
        }
    }
}

impl&lt;BE, QB, BC&gt; FromSqlRow&lt;Integer, BE&gt; for HogeStatus
    where QB: QueryBuilder&lt;BE&gt;,
          BC: BindCollector&lt;BE&gt;,
          BE: Backend&lt;RawValue = [u8], QueryBuilder = QB, BindCollector = BC&gt;
{
    fn build_from_row&lt;T: Row&lt;BE&gt;&gt;(row: &amp;mut T) -&gt; Result&lt;Self, Box&lt;Error + Send + Sync&gt;&gt; {
        use self::HogeStatus::*;
        match &lt;i32 as FromSqlRow&lt;Integer, BE&gt;&gt;::build_from_row(row)? {
            0 =&gt; Ok(Waiting),
            1 =&gt; Ok(Running),
            2 =&gt; Ok(Finished),
            3 =&gt; Ok(Failed),
            4 =&gt; Ok(Canceled),
            n =&gt; Err(format!(&#34;invalid status: {}&#34;, n).into()),
        }
    }
}
```

===
# クエリ
--------

* モデルプロジェクトとは別
* 各プロジェクトのdb.rsで関数を定義
* SQLよりRsutのイテレータを意識した書き方

===
# クエリ
--------

```rust
pub fn is_hoge_finished&lt;&#39;a, Cn&gt;(conn: &amp;Cn, entry_id: i32) -&gt; Result&lt;bool, Error&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use self::schema::hoge_suites::dsl::*;
    // SELECT ... じゃなくてsourceからfileterして最後にselect
    let ret = hoge_suites
        .filter(hoge_entry_id.eq(entry_id))
        .select(status)
        // ここまでクエリビルダ
        .load::&lt;i32&gt;(conn)?
        // ここからイテレータ
        .into_iter()
        .all(|i| [HogeStatus::Finished as i32, HogeStatus::Failed as i32].contains(&amp;i));
    Ok(ret)
}

```

===
# 複雑なクエリ
-------------

* トランザクション
* join
* order by

===

# 複雑なクエリ
-------------

``` rust
pub fn pic_suite&lt;Cn&gt;(conn: &amp;Cn,
                     query: &amp;api::worker_poll::Request)
                     -&gt; Result&lt;Option&lt;(HogeEntry, HogeSuite)&gt;, Error&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use self::schema::hoge_entries::dsl::*;
    use self::schema::hoge_suites::dsl::*;
    use self::schema::hoge_suites::dsl::id;
    // transaction
    conn.transaction(|| {
        let suite = hoge_suites
             // join
            .inner_join(hoge_entries)
            .filter(status.eq(HogeStatus::Waiting as i32)
                .and(hostname.eq(&amp;query.hostname)))
            // order by
            .order(created_at.asc())
            .select((id, hoge_entry_id, hostname, status))
            .first::&lt;HogeSuite&gt;(conn)
            // NotFoundErrorをOptionにできる
            .optional()?;
        // transactionの中で普通にrustの式が書ける
        if let Some(s) = suite {
            let entry = hoge_entries.find(s.hoge_entry_id)
                .first::&lt;HogeEntry&gt;(conn)?;
            let suite =
                diesel::update(hoge_suites.find(s.id)).set(status.eq(HogeStatus::Running as i32))
                    .get_result::&lt;HogeSuite&gt;(conn)?;
            Ok(Some((entry, suite)))

        } else {
            Ok(None)
        }
    })
}
```

===

# もっと複雑なクエリ
-------------------

* 2重join
* dieselは2重joinを扱えない…

===

# もっと複雑なクエリ
-------------------


``` rust
pub fn load_all_data&lt;&#39;a, Cn&gt;(conn: &amp;Cn)
                             -&gt; Result&lt;Vec&lt;(HogeEntry, Vec&lt;((HogeSuite, HogeResult), Vec&lt;HogeProfile&gt;)&gt;)&gt;&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use diesel::types::{Integer, Timestamp, VarChar, Double};
    use diesel::pg::types::sql_types::{Array, Jsonb};
    use diesel::expression::dsl::*;
    use diesel::select;

    let status = sql::&lt;Integer&gt;(&#34;s.status&#34;);
    let ret = select(sql::&lt;(
        (Integer, VarChar, VarChar, Array&lt;VarChar&gt;,Timestamp, VarChar, Integer, Jsonb),
        (Integer, Integer, VarChar, Integer),
        (Integer, Integer, VarChar, Integer, Integer, VarChar),
        (Integer, Integer, VarChar, Integer, Double))&gt;(
        &#34;
e.id, e.repo, e.committish, e.files, e.created_at, e.command, e.format, e.format_data,
s.id, s.hoge_entry_id, s.hostname, s.status,
r.id, r.hoge_suite_id, r.hoge_name, r.score, r.status, r.result,
p.id, p.hoge_result_id, p.function_name, p.score, p.percent
FROM hoge_profiles p
INNER JOIN hoge_results r on r.id = p.hoge_result_id
INNER JOIN hoge_suites s ON s.id = r.hoge_suite_id
INNER JOIN hoge_entries e ON e.id = s.hoge_entry_id&#34;))
    .filter(status.eq(HogeStatus::Finished as i32))
    .load::&lt;(HogeEntry, HogeSuite, HogeResult, HogeProfile)&gt;(conn)?;
    let mut hash = HashMap::new();
    for (e, s, r, p) in ret {
        let mut hash_entry1 = hash         .entry(e.id).or_insert((e, HashMap::new()));
        let mut hash_entry2 = hash_entry1.1.entry(r.id).or_insert(((s, r), Vec::new()));
        hash_entry2.1.push(p);
    }
    let ret = hash.into_iter().map(|(_, v)| (v.0,  v.1.into_iter().map(|(_, p)| p).collect())).collect();
    Ok(ret)
}

```

===

# テスト
-------

* ￣\＿(ツ)＿/￣

===

# まとめ
--------

* 案外普通に使えるよ
* モデルはちょっと面倒かもね
* クエリは困ったらSQL生牡蠣
* マイグレーションとかはまた今度

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>WebAssemblyとコンパイラとランタイム</title>
      <link>/slide/WebAssemblytokonpairatorantaimu/</link>
      <pubDate>Thu, 16 Feb 2017 15:46:21 +0900</pubDate>
      
      <guid>/slide/WebAssemblytokonpairatorantaimu/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# WebAssemblyとコンパイラとランタイム
----------------------
[emscripten night !! #3 - connpass](https://emsn.connpass.com/event/48100/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# 何の話
---------

* WebAssemblyをバックエンドに使う言語を作りたい
* [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml)
* 既に発表したものの補足記事的な
  + [コンパイラの人からみたWebAssembly | κeenのHappy Hacκing Blog](https://keens.github.io/slide/konpairanoninkaramitaWebAssembly/)
  + ある程度再度説明します

===
# アジェンダ
------------

* なぜWebAssembly
* コンパイラ
* コード生成
* ランタイム

===

# なぜWebAssembly

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# なぜWebAssembly
----------------

* なんかバイナリでテンション上がる
* ポータブルでコンパクトで速い
* 機能的にJSを越えるかもしれない…？
* コンパイラがブラウザで動くと言語導入のハードル下がる
  + 気軽に試せる
  + コンパイラだけでなく吐いたコードもブラウザで動かしたい

===
# WASM over LLVM
----------------

* 既存のJS環境と協調する
  + JSとの相互呼び出しとか
* **non-determinismが少ない**
* 細かいアラインメント考える必要がない
* **API安定しそう**

===

# WASM over asm.js
--------------------

* ブラウザ以外への組込みもサポート
  + Node.jsとか
  + **JITエンジンに使えそう**
* プラットフォーム
* 実行までのレイテンシが短かい
* asm.jsより速度を出しやすい設計
* テキストフォーマットで生成コードの文法エラーが怖い
* 将来機能が増えるかも

===
# WebAssemblyの現状
-------------------

* Minimum Viable Product(MVP)
* 機能を削ってとりあえず動くものを作ってる
* 今はC/C++からLLVMを通して吐けるのが目標
  + C/C++には不要でも自分の言語に欲しい機能は……
* 今後SIMDとかスレッドとかDOM APIとか増えていく

===

# コンパイラ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# WASM概要
----------

* WASMには以下がある
  + 関数
    - 関数内ローカル変数
  + リニアメモリ
  + グローバル変数
  + テーブル
  + importテーブル
  + exportテーブル

===
# WASM実行モデル
--------------

* i32,i64,f32,f64のみ
* **スタックマシン**
  + 命令のオペランドや関数の引数はスタック経由で渡す
  + 1 passのコード生成が楽そう
* 無限のローカル変数が使える
  + 型がある
* 関数の引数はローカル変数経由で渡される
* コントロールフローはgotoじゃなくてstructured
  + 静的検証がしやすいらしい
  + 安全だけどコンパイラ的には…

===

# コントロールフロー
-------------------

* `loop` + `br` (名前付き)
* `block` + `br` (名前付き)
* `br_if` or `br_table`
* `if` + `else` + `end`
* `return`
* 等

===

# コントロールフロー
-------------------

* gotoがない
  + `br` はブランチじゃなくてブレイク
* gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
    + loop, block, br, br_ifを使う
* 高級言語から変換するなら `if` を使う
  + ifが2系統あることになる

===
# サンプル
---------

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===
# サンプル
---------

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (get_local 0)
    (get_local 1)
    (call 1)
    (get_local 1)
    (get_local 0)
    (i64.sub)
    (f64.convert_s/i64)
    (f64.div)
    (call 2))
  ...)
```

===
# サンプル
---------

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (call 2
      (f64.div
       (call 1 (get_local 0) (get_local 1))
       (f64.convert_s/i64
        (i64.sub
         (get_local 1)
         (get_local 0))))))
  ...)
```

===

# WebMLコンパイラ
------------

* パーサ、AST、HIR、MIR、LIR
* LIRがRTLなのでそれをWASMに変換したい
* gotoからstructured control flow…

===

```
[コード]
   | パーサ
 [AST] 型推論とか
   | AST2HIR
 [HIR] 早期最適化、K正規化、A正規化など
   | HIR2MIR
 [MIR] 諸々の最適化
   | MIL2LIR
 [LIR] シリアライズ、レジスタ割り当てなど
   | コード生成
 [WASM]
```

===

# 変数
------

* LIRはレジスタで計算する
* LIRはCFG由来の大量の変数を使う
  + レジスタ割り当ては一旦置いとく
* WASMはスタックで計算する
* どうコード生成すると最適か？

===

```
fun main: () -&gt; i64 = {
    entry@0:
        r0: i64 &lt;- 1
        r1: i32 &lt;- 0
        r2: i64 &lt;- 1
        r3: i64 &lt;- 2
        r4: i64 &lt;- 3
        r5: i64 &lt;- r3 * r4
        r6: i64 &lt;- 4
        r7: i64 &lt;- r5 + r6
        r8: i64 &lt;- r2 + r7
        r9: i64 &lt;- 1
        r10: i64 &lt;- 2
        r11: i64 &lt;- r9 + r10
        r12: i64 &lt;- 3
        r13: i64 &lt;- r11 * r12
        r14: i64 &lt;- 4
        r15: i64 &lt;- r13 + r14
        r16: i32 &lt;- 1
        jump_if_zero r16 then@1
        jump else@2
    then@1:
        r17: i64 &lt;- r8
        jump join@3
    else@2:
        r17: i64 &lt;- r15
        jump join@3
    join@3:
        r18: i64 &lt;- 1
        r19: i64 &lt;- r18 + r15
        r20: i64 &lt;- 1
        r21: i64 &lt;- call d@9(r20, )
        r22: i64 &lt;- 2
        r23: i64 &lt;- call #g37(r22, )
        r24: i64 &lt;- 1
        r25: i64 &lt;- heapalloc(16)
        [r25+0] &lt;- &lt;anonfun&gt;@11
        [r25+8] &lt;- r24
        r26: i64 &lt;- 0
        ret r26
}
```

===

# 変数割り当て
--------------

* SSAの1変数 = WASMの1ローカル変数
* スタックの効率利用を完全に無視
* 計算はLV→スタック→LVに書き戻し
* どうせスタックもLVもレジスタ扱いにしてレジスタ割り当てされるでしょ
* （測ってないけど）多分速度は変わらない

===

# CFG
-----

* コンパイラが一旦gotoを使うコントロールフローグラフを作る
* WASMにはgotoがない
* どうやったら生成出来るか？
* そもそも生成出来るの？

===

# blockと前方ジャンプ
------------

* `block` + `break` で前方ジャンプ
* 閉じ括弧の位置にジャンプ
* `block` の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  ...
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

# loopと前方ジャンプ
------------


* `loop` + `break`で後方ジャンプ
  + `loop` からの `break` はいわゆる `continue`
* 開き括弧の位置にジャンプ
* 閉じ括弧の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  ...
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===
# ジャンプのクロス
------------------

* 単一gotoは割り当て出来る
* 複数のgotoが入り組んだら？

===

# 絶対出来る
------------

* チューリング完全なら必ず書ける
  + whileとswitchでステートマシン作ればいい
* 効率的とは限らない
* 効率的なコードを吐きたい

===
# ステートマシンはつらい
-----------------------

* これをナイーブに変換すると…

```c
#include &lt;stdio.h&gt;
int main() {
  int sum = 0;
  for (int i = 1; i &lt;= 100; i++)
    sum += i;
  printf(&#34;1+...+100=%d\n&#34;, sum);
  return 0;
}
```

===

```javascript
function _main() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    var __label__ = -1;
    while(1)
        switch(__label__) {
        case -1:
            ...
            __label__ = 0;
            break;
        case 0:
            ...
            if ($4) {
              __label__ = 1;
              break;
            } else {
              __label__ = 2;
              break;
            }
        case 1:
            ...
            __label__ = 3;
            break;
        case 3:
            ...
            __label__ = 0;
            break;
        case 2:
            ...
            return 0;
        }
}
```

===
# ステートマシンはつらい
----------------------

* どうにかする必要がある
  + emscriptenは[ReLoop](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)で最適化
* なんか気に食わなかった
* そもそもステートマシンを使わずに生成したい
* 複数のgotoが入り組んだパターンを自分で考えたの紹介します。
* CFGと基本ブロックは知ってるかな？

===
# 前前
------

```
[ ]--+
 |   |
[ ]--+-+
 |   | |
[ ]&lt;-+ |
 |     |
[ ]&lt;---+
```

===
# 前前
------

```
(block
  (block
    ...
    (br 0)-+
    ...    |
    (br 1)-+-+
  )&lt;-------+ |
)&lt;-----------+
```

===
# 後後
------


```
[ ]&lt;-+
 |   |
[ ]&lt;-+-+
 |   | |
[ ]--+ |
 |     |
[ ]----+
```

===
# 後後
------

```
(loop&lt;-----+
  (loop&lt;---+-+
    ...    | |
    (br 1)-+ |
    ...      |
    (br 0)---+
  )
)
```

===
# 後前
------


```
[ ]&lt;-+
 |   |
[ ]--+-+
 |   | |
[ ]--+ |
 |     |
[ ]&lt;---+
```

===
# 後前
------

```
(block
  (loop&lt;---+
    ...    |
    (br 1)-+-+
    ...    | |
    (br 0)-+ |
  )          |
)&lt;-----------+
```

===
# 前後
------

```
[ ]--+
 |   |
[ ]&lt;-+-+
 |   | |
[ ]&lt;-+ |
 |     |
[ ]----+
```

===
# 前後
------

* 素直には出来ない…？
* 部分的にステートマーシン作る？

===
# 部分的ステートマーシン
-------------------------

```
[1]--+
 |   |
[2]&lt;-+-+
 |   | |
[3]&lt;-+ |
 |     |
[4]----+
```

===
# 部分的ステートマーシン
-------------------------

```
   [1] label = 0
    |
+-&gt;[br]-+ if label == 0
|   |   | then goto 3
|   |   | else goto 2
|   |   |
|  [2]  |
|   |   |
|  [3]&lt;-+ label = 1
|   |
+--[4]
```

===
# コード生成

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===

# フォーマット
------------

* バイナリフォーマットとテキストフォーマットがある
* バイナリ: wasm
  + コンパクト
  + intとかもパッキングする
* テキスト: wast
  + 人間可読+機械可読=S式
  + 低級にもちょっと高級にも書ける
  + 一旦アセンブラ噛まさないと動かない

===

# アセンブラ
------------

* オンメモリで生成するためにアセンブラ自作
  + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs)
  + ブラウザで動かすのに必要
  + 既存のツールは使えない
* アセンブラ自体ブラウザで動かすのでRust製
* まだ動かしてない

===

```rust
let mut mb = ModuleBuilder::new();
let f = mb.new_function(FunctionBuilder::new(funtype!((i32, i32) -&gt; i32))
    .code(|cb, args| {
        cb.constant(2)
            .get_local(args[0])
            .i32_add()
    })
    .build());
mb.export(&#34;addTwo&#34;, f);
let module = mb.build();
```

===
# スタック領域
-------------

* Cでいう`struct foo x;`みたいにエフェメラルな多ワード領域が欲しい
* WebAssemblyのローカルストレージはLVだけ
  + 最大1ワードしか保存出来ない
* 可能性
  1. 諦めてメモリに確保（場合によっては最適化で消えるかも）
  2. ワード毎に分割してLVに保存（大変だけど速そう）

===
# ランタイム

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 言語のランタイム
-----------------

* 主にはGC
* その他データのメモリ表現
  + アラインメントも
* スタック領域
* FFI
* コンパイラなのでシンボルテーブルはなし

===
# メモリ
--------

* mallocとかはない
* ページ単位のアロケーションだけ
* 自前でGCを実装することになる

===
# GC
-----

* コールスタックを遡れない
  + コールスタックをGCルートに出来ない
* メモリonlyな走査なら可能
  + ポインタを都度メモリ領域(arena)にコピーすれば良い。
  + arenaもルートになる
  + コールスタックと連動するのでスタックで管理出来る。
  + CF [Matzにっき(2013-07-31)](http://www.rubyist.net/~matz/20130731.html)
  + ただしコンパイラなので関数全部をsave/restoreで囲んだりはしない。

===
# アロケータ
------------

* どうにか書いてブラウザでリンクする必要がある
  + ブラウザにもランタイムライブラリの時代…
  + WASMはライブラリ間でメモリ共有出来る
* とりあえずRustで書く方針
  + WASMのページアロケートとかどうすればいいんだろう
  + まだ色々未定

===

# メモリ表現
------------

* 出来れば楽して64bit統一したかった
  + i32やf32を抹殺したかった
* WASM32しかないのでポインタが32bit…
* 仕方ないので64bitアラインメントでパディングする
* 空いた32bitの使い道は未定
  + 静的型付だし型タグが要らない
  + 代数的データ型のタグ？

===

# 高階関数
----------

* WASMに関数ポインタがない
* テーブルに関数を登録してインデックス参照
  + C++のvtableのための機能
  + 型も動的チェック
* ちょっと遅そう
* 気合でインライン化を頑張ろう

===

# FFI
------

* JSの関数を呼びたい
* 細かいところどうなってるんだろう
  + 例外は？JSオブジェクトは？GCは？
* 型付…
* ノープラン

===
# 雑にまとめ
-------------

* WASMはちょっと高級なので最適化コンパイラは困るよ
  + 雑なコンパイラにはむしろ嬉しい
* コード生成は努力で解決
* GCは割とつらいよ
  + 将来楽になるかも
* JS連携や将来のスレッドとかはみんなで考えよう

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>コンパイラの人からみたWebAssembly</title>
      <link>/slide/konpairanoninkaramitaWebAssembly/</link>
      <pubDate>Sun, 22 Jan 2017 13:35:46 +0900</pubDate>
      
      <guid>/slide/konpairanoninkaramitaWebAssembly/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# コンパイラの人からみたWebAssembly
----------------------
[コンパイラ勉強会 - connpass](https://connpass.com/event/46850/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# アジェンダ
------------

* WebAssemblyの概要
* 具体的な話
* WebAssembly吐こうとした話

===

# WebAssemblyの概要

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===

# JavaScript
-------------

* ブラウザ上で動くスクリプト言語
* 動的型付
* 高級
* GCとかある
* 今までブラウザで動く唯一の言語だった
* 遅い
  + 各ブラウザJITなどで補強

===

# [asm.js](http://asmjs.org/)
------------

* プラウザ上で動く言語
* 低級
* GCなし
* JSのサブセット
  + asm.jsをサポートしないプラウザでも動かせる
* コンパイラから生成されることを想定
  + emscriptenなど

===

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===
# asm.jsの問題点
---------------

* JS互換文法なため嵩張る
* パースも遅い
* そもそもコンパイラが吐くならバイナリでも良いのでは？

===

# WebAssembly
--------------

* ブラウザ上で動く言語
  + 仮想機械命令？
* 低級
* バイナリフォーマット
  + ロード、パース時間が短かい
  + パース20倍くらい速いらしい
* wasm32とwasm64がある
* セマンティクスは（今のところ）ams.jsをほぼ踏襲
  + 実行エンジンは既存のものを使える
* 将来SIMD、スレッドなどの拡張が入る

===

# WASMのゴール
--------------------

* ポータブルでコンパクトで速い
* 仕様策定と実装をインクリメンタルにやっていく
  + 今はとりあえずC/C++をターゲットに
* 既存のJS環境と協調する
  + JSとの相互呼び出しとか
* ブラウザ以外への組込みもサポート
  + Node.jsとか
* プラットフォームになる
  + ツール類のサポートとか

===

# なぜWebAssembly?
------------------

* 実行までのレイテンシが短かい
* asm.jsより速度を出しやすい設計
* クライアントヘビーにしやすい？
* **JSを補完する存在**
* non-determinismが少ない
* LLVM IRと比べてデコードが速くてコンパクト
* (**code generator IR** vs optimization IR)
* 余計なことをしない
  + fast mathとかはない
  + 既に最適化されたコードが吐かれる前提

===
# WebAssemblyの現状
-------------------

* Minimum Viable Product(MVP)
* 機能を削ってとりあえず動くものを作ってる
* 今はC/C++からLLVMを通して吐けるのが目標
* 今後SIMDとかスレッドとかDOM APIとか増えていく
* ChromeとFirefoxでオプトインで使える
  + そろそろFirefoxで普通に動く

===

# 具体的な話
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# セマンティクス
---------------

* https://github.com/WebAssembly/spec
* 形式的定義されている
* 実行以外にも静的バリデーションもある
* 1ファイル1モジュール
  + JSのモジュールと同じ概念

===
# 実行モデル
--------------

* i32,i64,f32,f64のみ
  + bitエンコーディングは指定
* スタックマシン
  + 命令のオペランドや関数の引数はスタック経由で渡す
  + バイナリがコンパクト+雑にコンパイルしても速い
* 無限のローカル変数が使える
  + 型がある
* 関数の引数はローカル変数経由で渡される
* コントロールフローはgotoじゃなくてstructured
  + 静的検証がしやすい

===

# wasm、wast
------------

* バイナリフォーマットだけでは人間が読めない
* テキストフォーマットも欲しい
* バイナリ: wasm
  + コンパクト
  + intとかもパッキングする
* テキスト: wast
  + 人間可読+機械可読=S式
  + 低級にもちょっと高級にも書ける

===

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (get_local 0)
    (get_local 1)
    (call 1)
    (get_local 1)
    (get_local 0)
    (i64.sub)
    (f64.convert_s/i64)
    (f64.div)
    (call 2))
  ...)
```

===

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (call 2
      (f64.div
       (call 1 (get_local 0) (get_local 1))
       (f64.convert_s/i64
        (i64.sub
         (get_local 1)
         (get_local 0))))))
  ...)
```

===

```
0000000: 0061 736d                                 ; WASM_BINARY_MAGIC
0000004: 0d00 0000                                 ; WASM_BINARY_VERSION
; section &#34;TYPE&#34; (1)
0000008: 01                                        ; section code
0000009: 00                                        ; section size (guess)
000000a: 03                                        ; num types
; type 0
000000b: 60                                        ; func
000000c: 02                                        ; num params
000000d: 7e                                        ; i64
000000e: 7e                                        ; i64
000000f: 01                                        ; num results
0000010: 7c                                        ; f64
; type 1
0000011: 60                                        ; func
0000012: 02                                        ; num params
0000013: 7e                                        ; i64
0000014: 7e                                        ; i64
0000015: 01                                        ; num results
0000016: 7c                                        ; f64
; type 2
0000017: 60                                        ; func
0000018: 01                                        ; num params
0000019: 7c                                        ; f64
000001a: 01                                        ; num results
000001b: 7c                                        ; f64
0000009: 12                                        ; FIXUP section size
; section &#34;FUNCTION&#34; (3)
000001c: 03                                        ; section code
000001d: 00                                        ; section size (guess)
000001e: 03                                        ; num functions
000001f: 00                                        ; function 0 signature index
0000020: 01                                        ; function 1 signature index
0000021: 02                                        ; function 2 signature index
000001d: 04                                        ; FIXUP section size
; section &#34;CODE&#34; (10)
000002e: 0a                                        ; section code
000002f: 00                                        ; section size (guess)
0000030: 03                                        ; num functions
; function body 0
0000031: 00                                        ; func body size (guess)
0000032: 00                                        ; local decl count
0000033: 20                                        ; get_local
0000034: 00                                        ; local index
0000035: 20                                        ; get_local
0000036: 01                                        ; local index
0000037: 10                                        ; call
0000038: 01                                        ; func index
0000039: 20                                        ; get_local
000003a: 01                                        ; local index
000003b: 20                                        ; get_local
000003c: 00                                        ; local index
000003d: 7d                                        ; i64.sub
000003e: b9                                        ; f64.convert_s/i64
000003f: a3                                        ; f64.div
0000040: 10                                        ; call
0000041: 02                                        ; func index
0000042: 0b                                        ; end
0000031: 11                                        ; FIXUP func body size
...
```

===

# JS API
---------

``` javascript
var importObj = {js: {
    import1: () =&gt; console.log(&#34;hello,&#34;),
    import2: () =&gt; console.log(&#34;world!&#34;)
}};
fetch(&#39;demo.wasm&#39;).then(response =&gt;
    response.arrayBuffer()
).then(buffer =&gt;
    WebAssembly.instantiate(buffer, importObj)
).then(({module, instance}) =&gt;
    instance.exports.f()
```

===

# メモリ
------------

* メモリアドレスが0から始まって飛びのない **リニアメモリ**
  + 命令で伸び縮み出来る
  + 将来複数のリニアメモリとか出てくるかも
* メモリサイズは32bit(wasm32)か64bit(wasm64)が選べる
  + 現状はwasm32のみ
  + 1つのモジュールでメモリ4GiBバイトも使わないから普通は32bitで十分
* アドレッシングは `アドレス+オフセット`
* アラインメントは必須ではない（した方が速い）
* コード列のメモリは見えない
* スタックスキャンも出来ない

===

# 例外とか
----------

* Trap -- WebAssemblyのインスタンスが異常終了する
  + 例えばメモリの範囲外アクセスとか
* スタックオーバーフロー
  + オーバーフローするとインスタンスが異常終了する
  + 処理系/環境毎にスタック長は違う
    - non-determinism

===

# テーブル
----------

* 要素の配列的なもの
  + 整数インデックスでアクセス出来る
* 今のところ関数を入れてindrect callするため
* 将来的にはOSのハンドラとかGCの参照とか

===

# ローカル変数
--------------

* 無限にある型付きストレージ
* 0 初期化
* 関数の引数もローカル変数に入る

===

# グローバル変数
---------------

* 型付きストレージ
* 可変/不変がある
* 不変Globにsetするとvalidationエラー
* リニアメモリとは違うメモリ領域

===
# import / export
-----------------

* 他のモジュールから色々インポート出来る
* 関数
* テーブル
* グローバル変数
* リニアメモリ
* 勿論exportも

===
# 一旦まとめ
------------

* WASMは1ファイル1モジュール
* WASMには以下がある
  + 関数
    - 関数内ローカル変数
  + リニアメモリ
  + グローバル変数
  + テーブル
  + importテーブル
  + exportテーブル

===

# 命令の話
----------

* コントロールフロー
* Call
* パラメトリック
* 変数アクセス
* メモリ関連
* 定数
* 比較
* 数値
* 変換
* 再解釈

===

# コントロールフロー
-------------------

* `loop` + `br` (名前付き)
* `block` + `br` (名前付き)
* `br_if` or `br_table`
* `if` + `else` + `end`
* `return`
* 等

===

# コントロールフロー
-------------------

* gotoがない
  + `br` はブランチじゃなくてブレイク
* gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
    + loop, block, br, br_ifを使う
* 高級言語から変換するなら `if` を使う
  + ifが2系統あることになる

===

# Call
------

* `call`
* `call_indirect`
  + 関数テーブルを使った呼び出し
  + ダイナミックな関数ディスパッチに

===

# パラメトリック
------

* `drop`
* `select`
  + 三項演算子相当


===

# 変数アクセス
--------------

* `get/set_local`
* `get/set_global`
* `tee_local`
  + スタックに値を残しつつset

===

# メモリ関連
------------

* `{i,f}{32,64}.load{,8,16,32,64}{,_s,_u}`
* `{i,f}{32,64}.store{,8,16,32}`
* `current_memory`
* `grow_memory`
  + メモリを増やす命令もある

===
# 定数
------

* `{i,f}{32,64}.const`

===
# 比較
-------

* 各種 `eq`, `eqz`, `ne`,`lt`, `le`, `gt`, `ge`

===

# 数値
-------

* 四則(`i32.add`とか)
* 論理(`i64.popcnt`とか)
* 丸め,最{大,小}(`f32.ceil`とか)
* ルート(`f64.sqrt`とか)

===

# 変換
------

* `f32.convert_s/i32`とか
* `i32.wrap/i64`とか

===

# 再解釈
--------

* `i32.reinterpret/f32`とか
* ビットキャスト
* ビットエンコーディングが定まってるのでwell-defined

===
# WASM吐こうとした話

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 作ったやつ
-------------

* なんかコンパイラ作ろうと思い立った
* [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml)
* とりあえずSMLのサブセット
* Rust製
* 未完成
  + 正月気抜いてたら進捗ダメでした

===
# やりたかったこと
------------------

* ブラウザで動くコンパイラ作ってみたい
  + Rustはemscripten通せる
* WebAssembly面白そう
* SML処理系作りたかった
* 最適化書く練習

===
# 中身
------------

* パーサ、AST, HIR, MIR, LIR
* LIRがレジスタマシンなのでそれをWASMに変換したい
* オンメモリで生成するためにアセンブラ自作
  + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs)
  + ブラウザで動かすのに必要
* 最適化はまだ

===
# コード生成
-----------

* (ほぼ)SSAの1変数 = 1ローカル変数
  + どうせエンジン側でレジスタ割り当てするでしょ
* スタックはほぼ使わない
* gotoを構造化制御フローにする
  +  一応出来る
  + [Reloop](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
  + 何言ってるのかよく分からない
  + ステートマシンは勿論可能
* →自分で考えた
* なんかつらいので詳解します
* みんな基本ブロックとCFGは分かるかな？

===
# blockと前方ジャンプ
------------

* `block` + `break` で前方ジャンプ
* 閉じ括弧の位置にジャンプ
* `block` の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  ...
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

# loopと前方ジャンプ
------------


* `loop` + `break`で後方ジャンプ
  + `loop` からの `break` はいわゆる `continue`
* 開き括弧の位置にジャンプ
* 閉じ括弧の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  ...
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===
# ジャンプのクロス
------------------

* 単一gotoは割り当て出来る
* 複数のgotoが入り組んだら？

===
# 前前
------

```
   [ ]--+
    |   |
+--[ ]  |
|   |   |
|  [ ]&lt;-+
|   |
+-&gt;[ ]
```

===
# 前前
------

```
(block
  (block
    ...
    (br 0)-+
    ...    |
    (br 1)-+-+
  )&lt;-------+ |
)&lt;-----------+
```

===
# 後後
------


```
   [ ]&lt;-+
    |   |
+-&gt;[ ]  |
|   |   |
|  [ ]--+
|   |
+--[ ]
```

===
# 後後
------

```
(loop&lt;-----+
  (loop&lt;---+-+
    ...    | |
    (br 1)-+ |
    ...      |
    (br 0)---+
  )
)
```

===
# 後前
------


```
   [ ]&lt;-+
    |   |
+--[ ]  |
|   |   |
|  [ ]--+
|   |
+-&gt;[ ]
```

===
# 後前
------

```
(block
  (loop&lt;---+
    ...    |
    (br 1)-+-+
    ...    | |
    (br 0)-+ |
  )          |
)&lt;-----------+
```

===
# 前後
------

```
   [ ]--+
    |   |
+-&gt;[ ]  |
|   |   |
|  [ ]&lt;-+
|   |
+--[ ]
```

===
# 前後
------

* 出来ない…？
* 部分的にステートマーシン作る？
* ブロック組み換えたら出来る…？
* emscriptenはステートマシンっぽい？
* どうすればいいか不明
* もはやCPS変換して全部Callにする？
  + Compiling With Continuations!!!

===
# アルゴリズム
--------------

1. loopを良い感じに割り当てる
  + 最初はジャンプ位置と一番最後のgotoで作って、境界がクロスしないようにendを伸ばす
2. blockを外側のloopめいっぱい使って割り当てる
  + loopと同じく最小に割り当てて、blockをloopまで伸ばす

===
# ランタイム
------------

* スタック走査出来ない
* GC書けないのでは？？？
* 今のところターゲットはC/C++なので問題ない
* 将来はGC Integration入るかも

===
# 現状の解
----------

1. メモリの自動管理を諦める
2. リージョン推論や線形型で静的管理する
3. スタックを使わないコードにする
  + Compiling With Continuations!!!

===
# まとめ
--------

* ブラウザでアセンブリっぽいコードが動くよ
* バイナリはコンパクトだよ
* コントロールフロー難しいよ
* ランタイム難しいよ
* Compiling With Continuations

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SchemeでClassとProtocol</title>
      <link>/slide/Schemedeclasstoprotocol/</link>
      <pubDate>Mon, 28 Nov 2016 15:41:36 +0900</pubDate>
      
      <guid>/slide/Schemedeclasstoprotocol/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClassとProtocol
----------------------
[Lisp Meet Up presented by Shibuya.lisp #46](https://lisp.connpass.com/event/45517/) Scheme回
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# Class
-------

* ここでは単に値の集合を表わす
* `new` のように新しいインスタンスを作る機能はつけない
* ほとんど型と同じ機能
* 唯一の機能 `instance?` を持つ

===

``` scheme
(instance? 3 &lt;number&gt;)     ; =&gt; #t
(instance? &#34;foo&#34; &lt;number&gt;) ; =&gt; #f
```

===

# Classの実装
-------------

* 事実上述語があればいい
* [詳細](https://github.com/picrin-scheme/picrin/blob/master/contrib/50.class/piclib/picrin/class.scm)

``` scheme
(define-class &lt;any&gt; (lambda (x) #t))
(define-class &lt;list&gt; list?)
(define-class &lt;procedure&gt; procedure?)
(define-class &lt;number&gt; number?)
```

===

# Classの用途
-------------

* 述語だけで意味ある？
  + プリミティブにのみあった述語をユーザが拡張出来る
* その上に何かを構築出来る
* protocolとか

===

# Protocol
-----------

* Clojureのprotocol
* 多重ディスパッチの機構
* ディスパッチするのにClassを使う

===

```scheme
(define-protocol (PLUS x y)
  (plus x y))

(define-instance (PLUS &lt;number&gt; &lt;number&gt;)
  (lambda (x y) (+ x y)))


(define-instance (PLUS &lt;number&gt; &lt;string&gt;)
  (lambda (x y) (string-append (number-&gt;string x) y)))

(define-instance (PLUS &lt;string&gt; &lt;string&gt;)
  (lambda (x y) (string-append x y)))

```

===

``` scheme
(display (plus 1 2)) (newline)
; -&gt; 3
(display (plus 1 &#34;foo&#34;)) (newline)
; -&gt; 1foo
(display (plus &#34;bar&#34; &#34;foo&#34;)) (newline)
; -&gt; barfoo
(display (plus &#34;bar&#34; 1)) (newline)
; -&gt; &#34;error: method not found&#34;
```

===
# ユーザ定義型とProtocol
------------------------

``` scheme
(define-record-type complex
  (make-complex real img)
  complex?
  (real complex-real)
  (img  complex-img))

(define (complex-+ c1 c2)
  (make-complex (+ (complex-real c1) (complex-real c2))
                (+ (complex-img  c1) (complex-img  c2))))

(define (complex-&gt;string c)
  (string-append
   (number-&gt;string (complex-real c)) &#34;+&#34;
   (number-&gt;string (complex-img  c)) &#34;i&#34;))
```

===

```scheme
(define-class &lt;complex&gt; complex?)

(define-instance (PLUS &lt;complex&gt; &lt;complex&gt;)
  complex-+)


(display (complex-&gt;string
          (plus (make-complex 1 2)
                (make-complex 2 3)))) (newline)
; -&gt; 3+5i
```

===

# Protocolの実装
----------------

* メソッドの登録とか述語でディスパッチとか割と面倒
* [詳細](https://github.com/picrin-scheme/picrin/blob/master/contrib/80.protocol/piclib/picrin/protocol.scm)

===
# まとめ
---------

* 「追加可能な型」は便利だよ
* 型相当のものがあればダイナミックディスパッチ出来るよ
* picrinに実装されてるよ `(picrin class)` `(picrin protocol)`

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustで非同期Thriftしたい</title>
      <link>/slide/RustdehidoukiThriftshitai/</link>
      <pubDate>Sat, 26 Nov 2016 13:07:29 +0900</pubDate>
      
      <guid>/slide/RustdehidoukiThriftshitai/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Rustで非同期Thrift
----------------------
[歌舞伎座.tech#12「メッセージフォーマット/RPC勉強会」 - connpass](https://kbkz.connpass.com/event/40629/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

* &lt;span style=&#34;font-size:150%&#34;&gt;X&lt;/span&gt; RPCライブラリを使う話
* &lt;span style=&#34;font-size:150%&#34;&gt;O&lt;/span&gt; RPCライブラリを作る話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# RPC
-----

* Remote Procedure Call
* リモートで呼べる
* 言語跨げる
* シリアライズフォーマットが決まれば大体出来る
* Thrift, protobuf/gRPC, avro...
* 大抵バイナリ
  + JSONに比べて2倍くらい効率がいい

===

# Thrift
--------

* Facebook発(現apache)RPCフレームワーク
* IDLから複数の言語向けのコードを吐ける
* 対応言語多い
* 新しい言語はthriftレポジトリフォークして追加

===

# Thrift vs gRPC
----------------

\                       | Thrift | gRPC
------------------------|:------:|:----:
ベース                  | 自前   | HTTP/2
コード生成              | o      | o
プロトコルのアップデート | o      | o
通信の多重化            | トランスポート次第  | o (HTTP/2)
認証                    | x  | o
例外                    | ユーザ定義可能 | 事前定義のみ?
対応言語                | 多い   | ほどほど
その他                  | union  | timestamp, anyなど
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;

===

# 何故Thrift?
-------------

* 仕事で使ってたから
* 仕事は「gRPCかthrift、まあthriftでいっしょ」で決まった

===

# RustとThrift
--------------
いくつか実装がある

===

## [sgnr/rust-thrift](https://github.com/sgnr/rust-thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![sgnr/rust-thrift is deprecated](/images/thrift/sgnr-rust-thrift.png)

===

## [maximg/thrift](https://github.com/maximg/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![maximg/thrift is deprecated](/images/thrift/maximg-thrift.png)

===

## [terminalcloud/thrift](https://github.com/terminalcloud/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![terminalcloud/thrift is deprecated](/images/thrift/terminalcloud.png)

===

# [thehydroimpulse/thrust](https://github.com/thehydroimpulse/thrust)
---------------------------

* Thrift RPC in Rust (Async I/O)
* 非同期!!
* apache/thriftベースじゃない（フルスクラッチ）
* コンパイラプラグインサポートとかも
* 作りかけ
  + `Latest commit 0a37b77 on 11 Apr`

→ フォークすることに

===

# [Finagle](https://github.com/twitter/finagle)
---------

* **Scalaの** RPCフレームワーク
* [You Server as a Function](https://monkey.org/~marius/funsrv.pdf)
* Nettyベース
* サーバとクライアント両方サポート
* Twitter製
* 良くも悪くもTwitterべったり

===

# Finagle Client
--------

* クライアントが賢い
* RPCではTCPベースのLBが使えない
  + クライアントはコネクション張りっぱなし
* クライアントサイドロードバランシングが必要
* Finagleはそこまでカバー
* 他にもエラーが起きたサーバ外したり色々

===

# Tokio
--------

* **Rustの** RPCフレームワーク
* mioベース
* Finagleを参考に開発
  + **開発中**
* tokio-core
  + コア部分
* tokio-proto
  + プロトコル実装のサポート
  + 絶賛API変更中
* tokio-service
  + サービス実装のサポート


===

# TokioとFinagle
-----------------

  \           | Tokio       | Finagle
--------------|:-----------:|:-------:
コア          | [tokio-core](https://github.com/tokio-rs/tokio-core) | [finagle-core](https://github.com/twitter/finagle/tree/develop/finagle-core)
Future        | [future](https://github.com/alexcrichton/futures-rs) | [twitter util](https://github.com/twitter/util)
非同期エンジン | [mio](https://github.com/carllerche/mio) | [netty](http://netty.io/)
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;


===

# [mio](https://github.com/carllerche/mio)
------

* 非同期イベントループライブラリ
* イベントドリブン
* ループ内ゼロアロケーション
* `epoll` などの薄いラッパ
* libuv, libevent, libev2などのRust版
* ソケットだけでなく *ファイルIO* 、インメモリチャネルとかも監視出来る

===

# [future](https://github.com/alexcrichton/futures-rs)
--------------

* [Zero-cost futures in Rust · Aaron Turon](https://aturon.github.io/blog/2016/08/11/futures/)
* ゼロコスト
* 普通にFutureを使うとランタイムにステートマシンになる
* 「将来実行される」という「状態」を第一級の値として表現する大事な手段
* お型付けは大変
    + `map` したら `Map&lt;A, fn (A)-&gt;B&gt;` の型が返ったり
* ストリーミング指向のAPIもある

===

# [tokio-core](https://github.com/tokio-rs/tokio-core)
--------------

* 非同期IOのフレームワーク
* Futureベース
* フレームドIOとストリーミングIO
* フレームワークというよりユーティリティ？
  + mioとfutureを合わせて使う

===

# [tokio-proto](https://github.com/tokio-rs/tokio-proto)
-------------

* 主にバイナリ列&lt;-&gt;構造体の部分の面倒を見てくれる
* API変更中…
* バッファリングしてパースしやすくしてくれる
* プロトコルの多重化やってくれる(後述)

===

# [tokio-service](https://github.com/tokio-rs/tokio-service)
-----------------

* タスクサーバの面倒見てくれる
* 主にロードバランシング


===

# [Service](https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html)
-------------

``` rust
pub trait Service {
    type Request;
    type Response;
    type Error;
    type Future: Future&lt;Item=Self::Response, Error=Self::Error&gt;;
    fn call(&amp;self, req: Self::Request) -&gt; Self::Future;
}
```

===

# Service
----------

* いわゆるハンドラ
* インターフェースさえ満たせばいい
  + ミドルウェアもハンドラも同じ扱い

===

# [NewService](https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html)
--------------

```rust
pub trait NewService {
    type Request;
    type Response;
    type Error;
    type Instance: Service&lt;Request=Self::Request, Response=Self::Response, Error=Self::Error&gt;;
    fn new_service(&amp;self) -&gt; Result&lt;Self::Instance&gt;;
}

impl&lt;F, R&gt; NewService for F where F: Fn() -&gt; Result&lt;R&gt;, R: Service
```

===

# NewService
------------

* いわゆるAbstractServiceFactory的な存在
* コア数に応じてサービスを作ってくれる
* ただし`Service`を返す普通の関数も`NewService`になる
* [example](https://github.com/tokio-rs/tokio-line/blob/master/examples/echo_client_server.rs#L21)


===

# tokio-thrift
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# [tokio-thrift](https://github.com/KeenS/tokio-thrift)
--------------

* [KeenS/tokio-thrift](https://github.com/KeenS/tokio-thrift)
* この発表のために作った（作ってる）
* tokioベースのrustのthriftサポート
* thrustのフォーク
* 基本ツール全て
  + コードジェネレータ
  + コンパイラプラグイン
  + ランタイムライブラリ

===

# プロトコルスタック
-------------------

ユーザは実装に集中出来る仕組み

```
+------------------------------------------------+
| service   | tokio-service + 生成コード + ユーザ |
|------------------------------------------------|
| protocol  | tokio-proto   + tokio-thrift       |
|------------------------------------------------|
| transport | tokio-core                         |
+------------------------------------------------+
```

===

# サンプルコード
----------------

* [これ](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/main.rs)

===

# ユーザビリティ
---------------

* サーバ: ユーザはインターフェースに沿ったコードを書くだけ
* クライアント: インターフェース通りに呼べる
* 返り値はFuture
* サーバ: 非同期実装と相性がいい
* クライアント: 非同期通信をそのままエンコード

===

# 実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# Thriftのプロトコル
-------------------

* 現状binary protocolのみ
  + fork元が実装してあった
* compactとか需要ある？
* 因みにJSONはやめとけ

===

# 所有権とゼロコピー
-------------------

* プロトコルのパースの部分の話
* Rustっぽい部分
* バッファの所有権をパース結果に渡すことでデータのコピーを避ける

===

# 所有権とゼロコピー
-------------------
バッファをresultにパースして

```
buffer
  |
+-+---------------+
|                 |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 所有権とゼロコピー
-------------------
resultにデータの所有権を渡してしまう

```
 result   buffer
   |        |
+--+----++--+-----+
|       ||        |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 複数メソッド
-------------

* 複数メソッドだと複数の引数/返値の型を扱う
* コネクションのハンドラは1つ
* 複数型をどうやって扱う？
  + [enumを定義](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/thrift.rs#L67)
  + ゼロオーバーヘッド…

===

# 複数メソッド
-------------

```
 (methodA) (methodB)
     |         |
     +----+----+
          | &lt;----- enum化
      [client]
          |
      [server]
          | &lt;----- enumでディスパッチ
     +----+-----+
     |          |
(handlerA) (handlerB)
```

===

# つらい話
-----------------

* Thrift IDLのセマンティクスが書いてない
  + throws節のフィールドは直積？直和？
  + Javaで生成してみて推測するしかない
* フォークライブラリの実装が不完全
  + パーサはフルスクラッチで書き直した
  + [パーサコンビネータ便利](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-codegen/src/parser.rs#L517)
  + フォークした意味…
* Rustにエンコード出来ないthriftの機能もある
  + mapの定数は普通には無理
  + エラーどうしよう(`Error`トレイトの実装とEnum)
* 所有権の問題

===

# 言語との統合
-------------

* Rustには公式のシリアライズフレームワークがある
* [rustc-serialize](https://github.com/rust-lang-nursery/rustc-serialize)
* あるいはユーザ側のも
* [serde](https://github.com/serde-rs/serde)
* のっかりたいけどThriftに必要なデータがない
  + フィールドのシーケンス番号とか
* 今のところ自動生成に頼る
  + フレームワークにフィードバックした方がいい？

===

# コード生成の話
---------------

* [コンパイラプラグイン](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-macros/tests/service.rs#L10)微妙
  + 定義元ジャンプ、フィールド名補完などに難
* CLI生成は悪手
  + IDL変更する度CLI実行？
  + 生成コードはコミット？
    - CLIのバージョンがあるので基本はコミット。でも…
* ビルドツール統合が最良
  + FinagleにはScoogeがある
  + tokio-thriftでもやりたい
    - build.rsのサポート

===

# 多重化の話
------------

* 生のthrift on TCPだと通信を多重化出来ない
* tokio-proto側でpipelineやmultiplexなどをサポート
* pipeline: レスポンスを待たずに次のリクエスト
* multiplex: リクエストとレスポンスが入り乱れてもよい。プロトコルオーバーヘッドがある
* tokio-thriftは未対応

===

# Tokioの利点
-------------

* service: サーバとクライアント両方面倒見てくれる
  + サーバもCPUの数だけハンドラをクローンしてくれたりする
* protocol: 面倒毎が少ない(バッファ使ってくれる)
* Futureベースの非同期
* pipeline, multiplexによる多重化

===

# Tokioの欠点
-------------

* APIが不安定
  + tokio-thriftは今動かないorz
* thriftはストリーミング指向なのにバッファ使う
* Rustの痒い所に当たる
  + 返り値多相がない(`Future`を直接返せない)
  + アロケーションが必要になる
  + ダイナミックディスパッチが必要になる
  + 他言語と同水準のコスト

===

# まとめ
--------

* Thriftは広さで勝負
* コードジェネレータはビルドツールへの統合を
* IDLは既存のコードに乗っかった方が楽（上と競合）
* フレームワークを使うとみんな幸せ
* RPCはインターフェースベースであるべき
* 多重化はRPCより下のレイヤーで出来る

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustの話とリソースの話</title>
      <link>/slide/Rustnohanashitoriso_sunohanashi/</link>
      <pubDate>Sun, 20 Nov 2016 14:08:07 +0900</pubDate>
      
      <guid>/slide/Rustnohanashitoriso_sunohanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rustの話とリソースの話
----------------------
[RustのLT会！ Rust入門者の集い](https://rust.connpass.com/event/41467/)  
2016-11-21

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 若者
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます
 * [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)の翻訳
 * [Join rust-jp on Slack!](http://rust-jp.herokuapp.com/) にもいます。
 * [Rust その2 Advent Calendar 2016 - Qiita](http://qiita.com/advent-calendar/2016/rust-lang-2)

===

# 注意
------

* たまにマニアックな話が出ますが気にせず無視して下さい
* 「なんかRustすげー」って思ってもらえれば幸いです


===

# Rustとの出会い
----------------

* 元々Lisperだった
* 他にはML, Ruby, JVM言語など

===

![lis books](/images/rust-and-resource/lisp.jpg)&lt;!-- .element: height=&#34;640px&#34; --&gt;

===

&lt;span style=&#34;font-size: 150%&#34;&gt;「Lisperは自分で処理系作って一人前」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![compiler books](/images/rust-and-resource/compiler.jpg) &lt;!-- .element: height=&#34;640px&#34;&#34; --&gt;

===

# 苦悩
-------

* Cは低級すぎる
* Javaは向いてない
* C++は怖そう
  + 闇の軍団
  + 縄文土器飛んできそう
  + あと **nullあるしメモリ破壊あるし**
* MLは向いてるけどシステムプログラミングしづらい
* ATS2, Golang, D...

===

# Rustと出会う
----------------

* 正直最初は色物言語と思ってた
* 調べてみたら気に入った

===

# ゼロコスト抽象化
----------------------------

``` rust
fn sum_pos(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    v.iter().filter(|i| **i &gt; 0).sum()
```

===

高階関数が消えた…！？

``` asm
_ZN21higher_order_function7sum_pos17h2f9de4f69306ec0aE:
	.cfi_startproc
	movq	(%rdi), %rcx
	movq	16(%rdi), %rax
	leaq	(%rcx,%rax,4), %rdx
	xorl	%eax, %eax
	jmp	.LBB0_1
.LBB0_3:
	addl	%esi, %eax
	.p2align	4, 0x90
.LBB0_1:
	cmpq	%rcx, %rdx
	je	.LBB0_4
	movl	(%rcx), %esi
	addq	$4, %rcx
	testl	%esi, %esi
	jle	.LBB0_1
	jmp	.LBB0_3
.LBB0_4:
	retq
```

===


# スタックとヒープ
------------------


* Rustは手で割り当てを変えられる
* 「ヒープを使ったら負け」ゲームが出来る
* ループの中でヒープアロケートしたくないよね

===

# マクロとコンパイラプラグイン
-----------------------------

例えば正規表現リテラルを作れるか、とか。

1. Common Lisp
2. 衛生的マクロ + 手続的マクロ &lt;- Rust
2. 衛生的マクロ + コンパイラプラグイン &lt;- Rust
3. 手続的マクロ
4. コンパイラプラグイン
4. 衛生的マクロ

===

# トレイト
----------

* 型クラス
  + 継承を駆逐する
  + MLにも欲しい超便利機能
* 関連型
  + 表現力が高いことが知られている
  + CF [Rustの型レベルLispっぽいの作った | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/11/06/rustnokatareberulispppoinotsukutta/)

===

# パターンマッチ、代数的データ型
-------------------------------

* 便利ってかないと困る

``` rust
    match expr {
        &amp;Expr::Nil |
        &amp;Expr::EOF |
        &amp;Expr::Str(_) |
        &amp;Expr::Int(_) |
        &amp;Expr::Float(_) |
        &amp;Expr::Proc(_) =&gt; Ok(expr.clone()),
        &amp;Expr::Sym(ref name) =&gt; {
            match env.find(&amp;name.to_owned()) {
                Ok(v) =&gt; Ok(v.clone()),
                Err(m) =&gt; {
                    if name.deref() == &#34;t&#34; {
                        Ok(ksym(&#34;t&#34;))
                    } else {
                        Err(m)
                    }
                }
            }
        }
        &amp;Expr::Cons(ref car, ref cdr) =&gt; {
        ....
```


===

# C インターフェース
---------------------

* C FFI, C API共に1行
* 構造体なんかも互換

``` rust
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}
```

``` rust
#[no_mangle]
pub extern fn hello_rust() -&gt; *const u8 {
    &#34;Hello, world!\0&#34;.as_ptr()
}
```


===

# ランタイムなし
---------------

* [RustでベアメタルRaspberry PiのLチカ | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/)
* [Writing an OS in Rust](http://os.phil-opp.com/)
* [Redox - Your Next(Gen) OS](http://www.redox-os.org/)

===

# 生ポインタ
------------

* Cとのやりとりで大事
* あるいはパフォーマンスチューニングに

``` rust
pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}
```

``` rust
unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Vec&lt;T&gt;
```


===

# エラー処理
------------

* 例外じゃない
* [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html)
* `?` (元 `try!`)も便利
* Erro as a data
* 巻き戻し例外って扱い難しいよね
  + 値継続と例外継続の使い分けつらい

===

# リソースの話（本題）
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# リソースの重要性
-------------------

* プログラムはIOの塊、すなわりリソースの塊
* 従来は手動で管理するかGCで管理するかしていた
* RustはGCを使わず自動で管理する
* 所有権の概念が「ただの自動」以上に便利

===

# メモリ管理
------------

* Cでいう`free`を自動で挟んでくれる
* 基本

===

# Vecとslice
-------------

* sliceを`Vec`のviewとして使える
  + zero copy
  + 例えばJavaとかだと出来ない
* zero copy parserとかも書ける

===

# `File` 、 `Lock`
------------------

* `Drop`があるので自動
* ところでGCがあるのに手動で管理する言語があるらしいですね
  + 例えばRubyの`File.open(..) do ... end` も半手動
  + GCで処理すべきなのに手で`do ... end`を書いてる

===

# Rust
-------

``` rust
let file = File::open(&#34;text.txs&#34;).unwrap();
let mut br = BufReader::new(file);
...
```


===

# Java
-------
※try-with-resourceを使うともっと簡単に書けます。極端な比較のためにこう書いてます

``` java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader(&#34;test.txt&#34;));
    ...
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (br != null)
        try {
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
}
```

===

# Use after close
------------------

* プログラミングエラーの一種
* あらゆるリソースで起きうる
* GCのある言語ではメモリでのエラー **のみ** 防げる
* 他のリソースだとダメ
* Rustは **全ての** リソースで防げる

===

# Ruby
------

``` ruby
file = nil
File.open(&#34;file.rb&#34;) do |f|
  file = f
end
puts file.read

```

```
#&lt;File:file.rb (closed)&gt;
file.rb:6:in `read&#39;: closed stream (IOError)
        from file.rb:6:in `&lt;main&gt;&#39;
```


===

# Rust
-------

* 所有権のある限り勝手に`close`されない

``` rust
let mut file = None;
{
  let f = File::open(&#34;file.rs&#34;).unwrap();
  file = Some(f);
}
let mut s = String::new();
file.unwrap().read_to_string(&amp;mut s).unwrap();
println!(&#34;{}&#34;, s);
```

===

# ラッパーオブジェクト
--------------------

* 所有権便利って話

===

# Scala
------

``` scala
val kc = new KafkaProducer(...)
val sk = new SimpleKafkaClient(kc)
kc.close // &lt;- !?!?!?
...
```

===

# Rust
-------

``` rust
let kc = KafkaClient(...);
val mut sk = SimpleKafkaClient(kc);
kc.close(); // &lt;- Compile error because kc has been moved
```

===

# 責任者問題
-----------

* ラッパーオブジェクトの続き
* ラップされたオブジェクトは誰が閉じるの？


===

# Scala
------

``` scala
val kc = new KafkaProducer(...)
val sk = new SimpleKafkaClient(kc)
...
sk.close
kc.close // 本当に必要？
```

===

# Rust
-------

``` rust
let kc = KafkaClient(...);
val mut sk = SimpleKafkaClient(kc); // ここでmove
...
sk.close(); // moveされたskがcolseすることが型で分かる
```

===

# まとめ
--------

* Rust = 便利機能詰め合わせ + 所有権
* さらにランタイムもないしCとの相互連携も出来る
* リソース管理って大事
* 所有権は制限だけじゃないよ



&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Scala 2.12.0変更点</title>
      <link>/slide/Scala_2_12_0henkouten/</link>
      <pubDate>Fri, 04 Nov 2016 13:19:01 +0900</pubDate>
      
      <guid>/slide/Scala_2_12_0henkouten/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Scala 2.12.0変更点
----------------------
サイバーエージェント ScalaMeetUp

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * AI Studio Dev Group
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# サマリー
----------
全部[公式ページ](http://www.scala-lang.org/news/2.12.0)に詳細あるよ

* Java8向けの互換性向上したよ
  + トレイトがinterfaceに
  + 無名関数がlambdaに
  + SAMとScalaの関数が統合
* コンパイラが少し賢くなったよ
  + いくつかでinvokedynamicを使うように
  + 中間状態をやめた
  + 最適化をするように
* ライブラリ改善した
  + EitherがRight Biasedに
  + Futureが強化
* 非互換いくつか


===

# トレイトがinterfaceに
-----------------------

``` scala
trait Foo {
  def foo(): String = &#34;foo&#34;
  def bar(): String
}
```

===

# トレイトがinterfaceに
-----------------------


```
$ scalac-2.11 Trait.scala
$ ls
Foo$class.class  Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public interface Foo {
  public abstract java.lang.String foo();
  public abstract java.lang.String bar();
}
$ javap &#39;Foo$class&#39;
Compiled from &#34;Trait.scala&#34;
public abstract class Foo$class {
  public static java.lang.String foo(Foo);
  public static void $init$(Foo);
}

```

===

# トレイトがinterfaceに
-----------------------

```
$ scalac-2.12 Trait.scala
$ ls
Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public interface Foo {
  public static java.lang.String foo$(Foo);
  public java.lang.String foo();
  public abstract java.lang.String bar();
  public static void $init$(Foo);

```

===

# 無名関数がlambdaに
-----------------------

```
class Foo {
  val f = () =&gt; &#34;string&#34;
}
```

===

# 無名関数がlambdaに
-----------------------


```
$ scalac-2.11 Trait.scala
$ ls
Foo$$anonfun$1.class  Foo.class  Trait.scala
$ javap Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  public scala.Function0&lt;java.lang.String&gt; f();
  public Foo();
}
$ javap  &#39;Foo$$anonfun$1
Compiled from &#34;Trait.scala&#34;
public final class Foo$$anonfun$1 extends scala.runtime.AbstractFunction0&lt;java.lang.String&gt; implements scala.Serializable {
  public static final long serialVersionUID;
  public final java.lang.String apply();
  public final java.lang.Object apply();
  public Foo$$anonfun$1(Foo);
}

```

===

# 無名関数がlambdaに
-----------------------

```
$ scalac-2.12 Trait.scala
$ ls
Foo.class  Trait.scala
$ javap -p Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  private final scala.Function0&lt;java.lang.String&gt; f;
  public scala.Function0&lt;java.lang.String&gt; f();
  public static final java.lang.String $anonfun$f$1();
  public Foo();
  private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda);
$ javap -c -p Foo
Compiled from &#34;Trait.scala&#34;
public class Foo {
  private final scala.Function0&lt;java.lang.String&gt; f;

  public scala.Function0&lt;java.lang.String&gt; f();
    Code:
       0: aload_0
       1: getfield      #19                 // Field f:Lscala/Function0;
       4: areturn

  public static final java.lang.String $anonfun$f$1();
    Code:
       0: ldc           #25                 // String string
       2: areturn

  public Foo();
    Code:
       0: aload_0
       1: invokespecial #29                 // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
       4: aload_0
       5: invokedynamic #49,  0             // InvokeDynamic #0:apply:()Lscala/Function0;
      10: putfield      #19                 // Field f:Lscala/Function0;
      13: return

  private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda);
    Code:
       0: aload_0
       1: invokedynamic #61,  0             // InvokeDynamic #1:lambdaDeserialize:(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;
       6: areturn
}
```

===

# SAMとScalaの関数が統合
-----------------------

関数をSingle Abstract Methodに出来る

```
scala&gt; val runRunnable: Runnable = () =&gt; println(&#34;Run!&#34;)
runRunnable: Runnable = $$Lambda$1073/754978432@7cf283e1
scala&gt; runRunnable.run()
Run!
```

JavaでLambdaが期待される箇所にScalaの無名関数を書ける

===

# SAMとScalaの関数が統合
-----------------------

逆に、JavaのLambdaでScalaの関数を作れる

```
public class A {
  scala.Function1&lt;String, String&gt; f = s -&gt; s.trim();
}
```

===

# 最適化
--------
とりあえずDead Code Elimination

```
class Foo {
  def add1(i: Int) = {
    val unused = 1 + i
    1 + i
  }

}

```

===

# 最適化
--------

```
$ scalac Trait.java
$ javap -c Foo
...
  public int add1(int);
    Code:
       0: iconst_1
       1: iload_1
       2: iadd
       3: istore_2
       4: iconst_1
       5: iload_1
       6: iadd
       7: ireturn
...
}

```

===

# 最適化
--------

```
$ scalac -opt:l:method Trait.java
$ javap -c Foo
...
  public int add1(int);
    Code:
       0: iconst_1
       1: iload_1
       2: iadd
       3: ireturn
...
```

===

# 非互換
--------

* Object initialization locks and lambdas
  + 無名関数が元のクラスのメソッドになったので変にデッドロックするかも
* Lambdas capturing outer instances
  + 無名関数が元のクラスのメソッドになったのでスコープが少し変わる
  + シリアライズに影響出るかも
* SAM conversion precedes implicits
  + SAM conversionとimplicit comversionだとSAMが優先される

===

# 非互換
--------

* SAM conversion in overloading resolution
  + なんか型が面倒になった
* Inferred types for fields
  + なんかよく分かんなかった
* Changed syntax trees (affects macro and compiler plugin authors)
  + 変わったらしい

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>正しいScalaのコードが欲しい</title>
      <link>/slide/tadashiiScalanoko_dogahoshii/</link>
      <pubDate>Wed, 05 Oct 2016 00:10:25 +0900</pubDate>
      
      <guid>/slide/tadashiiScalanoko_dogahoshii/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 正しいScalaのコードが欲しい
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
   + Scalaはあんまり
===
# Scalaを始めたばかりの頃の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===


``` scala
def revappend[A](
    xs: List[A],
    ys: List[A]): List[A] = match xs {
  case Nil =&gt; Nil
  case x::xs_ =&gt; revappend(xs_, x::ys)
}
```

===

``` scala
def length(xs: List[_]): Int = xs match {
  case Nil =&gt; Nil
  case x::xs_ =&gt; 1 + length(xs_)
}
```

===

``` scala
def append[A](
    xs: List[A],
    ys: List[A]): List[A] = xs match {
  case Nil =&gt; Nil
  case x::xs_ =&gt; x :: append(xs_, ys)
}

append(List(1, 2, 3), List(4, 5, 6))
// =&gt; List(1, 2, 3)

```

===
# Scalaを始めたばかりの頃の話
-----------------------------

* 正しくないコードばかり書いてしまう
  + 他の言語の構文と混ぜてしまう
  + 型エラー
  + 実装ミス
* 正しいScalaのコードが欲しい

===
# 正しさって？
-------------

* 構文が正しいコード?
* コンパイルが通るコード?
* バグのないコード？
  + テストが通るコード?

===
# 正しさって？
-----------

* 数学だったら？
* 数学なら証明されれば正しい
* プログラムの証明????

===
# Isabelle
----------

* 汎用証明支援系
* [Isabelle](https://isabelle.in.tum.de/)
* 結構昔からある
* 関数型言語 + 高階論理

===
# コード
--------

``` isabelle
datatype &#39;a list = Nil                 (&#34;[]&#34;)
  | Cons &#39;a &#34;&#39;a list&#34;    (infixr &#34;#&#34; 65)

primrec app :: &#34;&#39;a list =&gt; &#39;a list =&gt; &#39;a list&#34; (infixr &#34;@&#34; 65)
  where
  &#34;[] @ ys      = ys&#34; |
  &#34;(x # xs) @ ys = x # (xs @ ys)&#34;
```

===

# 証明
------

``` isabelle
lemma app_Nil2 [simp]: &#34;xs @ [] = xs&#34;
  apply(induct_tac xs)
  apply auto
  done

lemma app_assoc [simp]: &#34;(xs @ ys) @ zs = xs @ (ys @ zs)&#34;
  apply (induct_tac xs)
  apply auto
  done
```

===
# Extract
---------

```isabelle
export_code append
   in Scala
   module_name &#34;Example&#34;
   file &#34;Example.scala&#34;
```

===
# Scalaのコード
---------------

証明されたScalaのコードが手に入る

``` scala
object Example {

abstract sealed class list[A]
final case class Nila[A]() extends list[A]
final case class Cons[A](a: A, b: list[A]) extends list[A]

def append[A](x0: list[A], ys: list[A]): list[A] = (x0, ys) match {
  case (Nila(), ys) =&gt; ys
  case (Cons(x, xs), ys) =&gt; Cons[A](x, append[A](xs, ys))
}

} /* object Example */

```

===
# 余談
-------

他の言語にもextract出来る

```isabelle
export_code append
   in SML
   module_name &#34;Example&#34;
   file &#34;Example.sml&#34;
```


===
# まとめ
---------

* プログラムは証明出来るよ
* Isabelleで証明が出来るよ
* Isabelleで証明したら正しいScalaのコードが手に入るよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>型クラスを越えて</title>
      <link>/slide/katakurasuwokoete/</link>
      <pubDate>Sat, 16 Jul 2016 02:53:49 +0900</pubDate>
      
      <guid>/slide/katakurasuwokoete/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 型クラスを越えて
----------------------
[歌舞伎座.tech#10「型クラス勉強会」](http://kbkz.connpass.com/event/32420/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# Rustとは
----------

* システムプログラミング言語
* GCなし！でもメモリ管理は自動
* **Zero-Cost Abstraction**
* **Trait-Based Generics**
* パターンマッチ、代数的データ型などなど
* [プログラミング言語Rust](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/README.html)

===
# Rustのトレイト的なの
----------------

* 型に固有のメソッド
  + オブジェクト指向的な
* トレイト
  + 型クラス

===
# 型クラスじゃない方
-------------------

``` rust
struct Person {
  name: String,
}
impl Person {
  // Static constructor
  fn new(name: String) -&gt; Self {
    Person{name: name}
  }

  // method
  fn hello(&amp;self) {
    println!(&#34;Hello, {}&#34;, self.name);
  }
}
```

===
``` rust
let person = Person::new(&#34;κeen&#34;);
person.hello();
```

===
# 多相型と制約
--------------

``` rust
struct Temp&lt;T&gt;(T);

impl &lt;T: Celsius&gt; Temp&lt;T&gt; {
  fn fromCelsius(t: isize) -&gt; Self {
    Temp(Celsius(t))
  }
}

impl &lt;T: Fahrenheit&gt; Temp&lt;T&gt; {
  fn fromFahrenheit(t: isize) -&gt; Self {
    Temp(Fahrenheit(t))
  }
}

```

===
# 型クラス
---------

* 便利
* 他の言語にも取り入れてほしい
* 型クラスを入れることで言語設計がどうなるか
* ユーザランドより言語機能的な部分フォーカス

===
# Rustの型クラスの実装
---------------------

* 動的ディスパッチと静的ディスパッチ両方がある
* 動的ディスパッチ
  + implicit parameterを渡すやつ
* 静的ディスパッチ
  + コンパイル時に解決してしまうやつ
* デフォフォルト静的
  + 動的を選ぶことも出来る

===
# 静的ディスパッチの意味
-----------------------

* Zero-Cost Abstraction
* ユーザはパフォーマンスのために設計を曲げる必要がなくなる
* インライン化などの最適化も出来る
* 逆の見方をすればZero-Cost Abstraction出来るからシステムプログラミング言語に高級な機能を入れれた

===
# 型クラス+α
-----------
それぞれ面白い特徴が。

* `FromStr`
* `Write`
* `Add`
* `Default`, `Zero`
* `Iterator`

===
# 型クラス+関数
--------------

* 関連関数
* `FromStr`
* static関数的なものになる

```rust
pub trait FromStr {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
```

===
``` rust
use std::str::FromStr;

let s = &#34;5&#34;;
let x = i32::from_str(s).unwrap();

assert_eq!(5, x);
```

===
# 型クラス+構文
--------------

* = メソッド
* 第一引数が `self` な関数はメソッド構文で呼び出せる
* クラスがなくても継承がなくてもオブジェクト指向
* `Write`

``` rust
trait Write {
  fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
}
```

===
``` rust
impl Write for Foo {
  fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt; {
    ...
  }
}

let foo = Foo::new();
foo.write(aa);
```

===
# 型クラス+UFCS
---------------

* = 実質オーバーロード
* 中身の違うメソッドを複数定義出来る
* どのメソッドを呼ぶかを決定する構文がある
  + = Universal Function Call Syntax

===
```rust
trait Foo {
    fn foo() -&gt; i32;
}

struct Bar;

impl Bar {
    fn foo() -&gt; i32 {
        20
    }
}

impl Foo for Bar {
    fn foo() -&gt; i32 {
        10
    }
}

```
===

```rust
&lt;Bar as Foo&gt;::foo();
Bar::foo();
```


===
# 型クラス+演算子
-----------------

* = 演算子オーバーロード
* `Add`

``` rust
pub trait Add&lt;RHS = Self&gt; {
    type Output;
    fn add(self, rhs: RHS) -&gt; Self::Output;
}
```

===

``` rust
use std::ops::Add;

struct Foo;

impl Add for Foo {
    type Output = Foo;

    fn add(self, _rhs: Foo) -&gt; Foo {
        println!(&#34;Adding!&#34;);
        self
    }
}

fn main() {
    Foo + Foo;
}
```
===
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;for (my_int i = 0; i &amp;lt; 10; i++) { … }&lt;br&gt;&lt;br&gt;Cならどういうアセンブリに落ちるかすぐわかるけどC++ならmy_intはクラスかもしれず=0はコンストラクタを起動し&amp;lt;はメソッド呼び出しになり++はejectを発行して光学ディスクトレイが開き相手は死ぬ&lt;/p&gt;&amp;mdash; わさびず &lt;a href=&#34;https://twitter.com/___yuni/status/681891856335032320&#34;&gt;2015年12月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 型クラス+値
-------------

* = 関連定数
* unstable...
* `Zero`, `Default`

``` rust
// current
pub trait Zero {
    fn zero() -&gt; Self;
}
```

``` rust
// ideal
#![feature(associated_consts)]
pub trait Zero {
    const ZERO: Self;
}
```

===
```rust
trait Monoid: Add&lt;Self&gt; + Zero
  where Self::Output : Add&lt;Self&gt; + Zero {
}

```

===
# 型クラス+型
-------------

* 関連型
* 型族…？
  + あまり違いを分かっていない
  + 関連型を持った型をまとめたのが型族？
* `Iterator`

```rust
pub trait Iterator {
  type Item;
  ....
}
```

===
``` rust
trait Iterator {
  ...
  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
```

===
# 型クラス+暗黙のルール
---------------------

* オーバーライド
* `Drop`
  + 暗黙に呼ばれるデストラクタをオーバーライド出来る

```rust
pub trait Drop {
    fn drop(&amp;mut self);
}
```

===
``` rust
impl Drop for Lock {
    fn drop(&amp;mut self) {
        self.free();
    }
}
```

===
# 型クラス+アノテーション
------------------------

* 単純に便利
* `derive`(`Debug` , `Eq`)

``` rust
#[derive(Debug, Eq)]
struct Foo(usize);
```

===

``` rust
let foo1 = Foo(1);
let foo2 = Foo(2);
println!(&#34;{:?} == {:?} ?: {:?}&#34;,
         foo1,
         foo2,
         foo1 == foo2);
```

===
# まとめ
--------

* 型クラスは便利だよ
* 型クラスの実装は効率的に出来るよ
* 型クラスを使うと言語設計も変わるよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Socket on SML#</title>
      <link>/slide/Socket_on_SML_/</link>
      <pubDate>Sat, 02 Jul 2016 15:25:24 +0900</pubDate>
      
      <guid>/slide/Socket_on_SML_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Socket on SML&amp;#x23;
----------------------
[ML勉強会](http://connpass.com/event/32752/) 2016-07-09

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# HTTP on SML&amp;#x23;?
-------------

* SML#にJSONサポートが入った
  + REST API簡単に叩けるのでは？
* SML#にFully Concurrent GCが入った
  + HTTPサーバ書くとレイテンシ抑えられて嬉しいのでは？
  * スレッドも使えるしスループットも高い筈
* SML#でHTTPの機運
* しかしHTTPサポートはないので自前実装するしかない

===
# Socket on SML&amp;#x23;?
------------------

* HTTPサポートに必要
* Basisにはある (Optional)
  + SML#のBasisはサポートしてない
* FFIあるしユーザランドで実装するか
* [KeenS/SmlSharpSocketSupport](https://github.com/KeenS/SmlSharpSocketSupport)

===
# TCP/IP、ソケットなど
---------------------------

* ソケットアドレス - 自分、相手の居場所。これがないと通信出来ない
  + 複数のアドレスファミリ(AF)がある
  + IP v4, IP v6, UNIXドメインなど。
* ソケット - 通信の仕組み。プログラムからはfdとして見える。
  + AFやtype(stream/diagram)の属性を持つ
* INet - インターネットドメインソケット
  + TCPとUDP
  + IP v4/v6アドレスで通信

===
# 主要なstructure
-----------------

* Socket
* NetHostDB
* INetSock
* (UnixSock)

===
# [NetHostDB](http://sml-family.org/Basis/net-host-db.html#SIG:NET_HOST_DB)
-----------

* ドメイン名からIPアドレスを調べたり逆をやったり
* Cの古い(現在では非推奨な)APIに合わせた設計
  + IPがv4/v6が混じることを考慮してない
  + 非推奨どころか脆弱性もあったり CF [glibc の脆弱性 CVE-2015-0235（通称：GHOST）についてまとめてみた - piyolog](http://d.hatena.ne.jp/Kango/20150128/1422409960)
* 新しいAPIで実装するのが面倒

===
# [Socket](http://sml-family.org/Basis/socket.html#SIG:SOCKET.accept:VAL:SPEC)
---------

* まあまあでかいけどsend/receive関数の変種が一杯あるだけ
* ドメインに依らないソケット操作
* typeには依る
  + stream socketとdgramソケットで送受信関数が別

===
# Socket.AF
------------

* ソケットのアドレスファミリ関連
* 仕様では具体的なファミリを定義しない

===
# Socket.SOCK
-------------

* ソケットにも種類がある
  + stream/diagram
* さらにstreamにはactive/passiveがある
* それらの型。

===
# [INetSock](http://sml-family.org/Basis/inet-sock.html#INetSock:STR:SPEC)
--------------

* IP - TCP/UDPのソケットを作る/操作するやつ。
* ここの関数はインターネットドメインソケットしか受け付けない

===
# Socketについて整理
----------------

* sockにはtypeとafの属性がある
* afは色々ある
* typeはstreamとdgramがある
* streamにはさらにactiveとpassiveがある
* 特定のaf, 特定のtypeしか受け付けない関数がある

===
# Socketについて整理
----------------

```
   (AF_UN)
        v
     [unix sock]...
         |                       (Active)
[socket]-+           [TCP(stream)]-+
         |             |         (Passive)
     [inet/inet6 sock]-+
        ^              |
   (AF_INET/INET6)   [UDP(dgram)]
```

===
&lt;span style=&#34;font-size:500%;&#34;&gt;幽霊型&lt;/sapn&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# Socketの幽霊型
---------------

```sml
type (&#39;af,&#39;sock_type) sock
type &#39;af sock_addr
type dgram
type &#39;mode stream
type passive
type active
```
===
# サーバのSocket操作(stream)
---------------------------

* INetSock(UnixSock)でソケットを作る(af, sock typeの選択, プロセス側の準備)
* bindでソケットをsock_addrにバインドする(アドレスの割り当て)
* listenでソケットの特定のポートを開ける(TCPの開始)
  + passive streamしか受け付けない
* acceptでクライアントからの入力を受け付ける(接続)
  + passive streamしか受け付けない
  + passive streamがactive streamになる
  + 一度acceptしたsockはlisten/accept出来ない
===
# データの送受信
---------------

* `send` / `recv`
* それぞれArraySlice/VectorSliceの制御フラグ有り/無しがある
  + 実装がまあまあ面倒

===
# SML# でのバインディング
------------------------

* sock - fd = int
* sock_addr - AFによってサイズが違う。ヤバい。
 + 任意のsock_addrを格納出来るsockaddr_storageを使う
 + Solarisだとsockaddr_unを格納出来ないらしい（任意のaddrを格納出来るとは）
   - SML#はSolarisでは動かないので問題ない。
* AF_* とか - Cではただのint。SML#は関数しかインポート出来ない。
 + C側で定数関数でラップしてSML#で呼び出した値を束縛
* その他 - straitforward

===
# 非同期IO

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# 非同期IO
----------

* HTTPサーバは複数のクライアントとのコネクションを持つ
* それらのコネクションを要領良く扱わないといけない
* 相手の処理速度や通信速度によって即座にデータを読み書き出来ない時がある
  + 勿論クライアント毎に状況が異なる
* 読み書き出来ない時にやったらブロック(CPU時間の無駄遣い)する
* 「読み書き出来るならする」/「読み書き出来るクライアントを選ぶ」APIが必要

===
# 非同期API
----------

* select - 複数のクライアントを登録して、読み書き出来るやつを選ぶ
* \*NB - 読み書き出来るならやって、出来ないならブロックせずにリターンする
* poll - selectと同じような（ちょっと速い）API。SocketではなくIOにある。
  + pollがあるのに何故Socketにselectがあるの…。

===
===
# 非同期APIのFFI
----------------

* select - Cに対応する関数が。構造体の変換でメモリアロケーションが起きて遅い
* \*NB - O_NONBLOCKを付けたsend/recv。
* poll - SML#にある

===
# 非同期HTTPサーバ概略
---------------------

```sml
bind(sock, addr);
listen(sock, port);
create_thread(n, fn i =&gt; let
  val clientList = makeClientList()
  fun loop () = let
    val clientList =
      Option.map (acceptNB(sock))
      (fn client =&gt; addReadClient clientList client)
      handle SysErr =&gt; ...
    val {rds, wds, exs} = select (makeSelectList clientList)
  in
    recvAndParseHTTPThenCallHandler clientList rds;
    sendResponse clientList wds;
    loop ()
  end
end)
```

===
# Cバインディングの憂鬱

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# importとメモリ割り当て
-----------------------

* SML#にはポインタかワードサイズ以下の値しか渡せない
  + stringとかはポインタからインポートする関数がある
  + インポートしたものはSML#のヒープに **コピーされる**
* cでポインタを返すにはmallocが必要
* **すぐコピーされてfreeされるもののためにmalloc??**
* SML#からコールバックを渡してCのスタックの変数をインポート
* CF https://github.com/KeenS/SmlSharpSocketSupport/blob/master/lib/net_host_db.c#L74

===
# メモリ管理
------------

* SML#にインポート出来る型は限られている
  + array, string
* 他の型はポインタのまま扱う。
* ポインタはGCされない
* `sockaddr` は仕様的にファイナライザを持っていない
  + 現状 **メモリリークする**
* SML#側でどうにかしてもらわないとダメ？
  + パンドラの壷(sml_alloc)使う？

===
# 型隠蔽
-------

* sockは本来はioDescに変換出来ないといけない
 + SML#でioDescはsockと同じくint
* しかし型隠蔽のせいでintをioDescに変換出来ない
* 手詰まり

===
# まとめ
--------

* socketとかその辺を解説したよ
* SML#向けにSocket関連Basisのバインディング作ってるよ
* BasisのAPI使うと非同期HTTPサーバ作れるよ
* SML#のFFIはやっぱりつらいよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>DOT/dottyについて調べてみた</title>
      <link>/slide/DOT_dottynitsuiteshirabetemita/</link>
      <pubDate>Tue, 24 May 2016 23:40:36 +0900</pubDate>
      
      <guid>/slide/DOT_dottynitsuiteshirabetemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# DOT/dottyについて調べてみた
----------------------
サイバーエージェント Scala Meet Up  
2016-05-27

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + Scala初心者
   + Scala歴1年未満&amp;gt;&amp;lt;

===
# Scalaコンパイラ
----------------

* 型推論（特にimplicit）が遅い
* コンパイルフェーズが多い
  + 中間オブジェクトが多くて遅くなる
* 多くのクラスファイルを生成する
  + コンパイラのくせにディスクIOが多い
* 気を抜いてると `Any` に推論される  
  e.g.) `if(x) 1 else &#34;a&#34;`
* そもそものScalaの設計に起因する点が多い
  + 抜本的変更が必要

===
# Scala基礎
-----------

* Scalaが成立するのに最低限必要な機能って？
  + e.g.) `case class` はなくても `class` だけでどうにかなる
* 「最低限の機能」を減らせばコンパイラがシンプルになる
  + 他の機能はただのシンタックスシュガーになる
  + コンパイラのバグを減らせる
  + 機能追加時の矛盾確認が楽
* コア言語

===
# Featherlight Scala
---------------------

* Scalaのシンタックスシュガーを減らした感じ
* 小さな言語
* 元のScalaはこれをベースに議論されてきた

===
# 形式言語理論
-------------

* 最低限必要な機能を形式的にモデル化
  + 全ての動作は予め決められた「規則」に基く
  + 実際に書いて動かすものではない
* 形式的にすることで「証明」とかが出来る
  + 「型検査に通れば実行時に型エラーが起きない」
  + 「型検査が必ず終了する」
* 逆に、「このモデルだとこの機能は実現出来ない」とかも分かる

===
# Dependent Object Type
------

* Scalaのコアをモデル化したもの（要出典）
* 形式言語
* ジェネリクスもなければクラスも継承もない、パッケージもない。
* 小さい言語ながら表現力豊か
* 全ての値はオブジェクト。
  + オブジェクトのフィールドとメソッドと型メンバーだけ
  + 型はそのまま
* Path Dependent Type
* サブタイピング


===
# About DOT
---------

* 型付の健全性が証明された
* System F&lt;:より強力
  * System F&lt;: -&gt; System D&lt;: -&gt; DOT
* existential typeを自然に表現出来る
* 交差型と合併型
  + `A extends B` -&gt; `A &amp; B`
  + 合併型は主に型推論の結果に出てくる

===
```scala
package scala.collection.immutable trait List[+A] {
  def isEmpty: Boolean; def head: A; def tail: List[A]
}
object List {
  def nil: List[Nothing] = new List[Nothing] {
    def isEmpty = true; def head = head; def tail = tail /* infinite loops */
  }
  def cons[A](hd: A, tl: List[A]) = new List[A] {
    def isEmpty = false; def head = hd; def tail = tl
  }
}
```

===
```scala
object scala_collection_immutable { sci =&gt;
  trait List { self =&gt;
    type A
    def isEmpty: Boolean
    def head: self.A def
      tail: List{type A &lt;: self.A}
  }
  def nil: sci.List{type A = Nothing} = new List{ self =&gt;
    type A = Nothing
    def isEmpty = true
    def head: A = self.head
    def tail: List{type A = Nothing} = self.tail
  }
  def cons(x: {type A})(hd: x.A)(tl: sci.List{type A &lt;: x.A})
      : sci.List{type A &lt;: x.A} = new List{ self =&gt;
    type A = x.A
    def isEmpty = false
    def head = hd
    def tail = tl
  }
}
```

===
# dotty
--------

* DOTに影響を受けたコンパイラ
* いくつかの新しい機能
  + DOTの交差型、合併型も
  + Nullable = `T | Null`
  + `if (x) 1 else &#34;a&#34;` は `Int | String` にアノテーション可能
* `forSome` が消えた
  + DOTのお陰

===
# dotty
--------

* Java8のラムダを使う
  + 生成するclassファイルの減少
* Implicitの探索アルゴリズムを改善
  + 反変implicitについても改善
* 型推論のアルゴリズムを改善
  + DOTのお陰
  + 特にサブタイピングが交差/合併型で楽に
* コンパイルパスを融合して高速化
  + 中間木がなくなってGCにやさしい
* 他にも一杯改善が

===

```scala
object DaysOfTheWeek{
  object Mon
  object Tue
  object Wed
  object Thu
  object Fri
  object Sat
  object Sun

  type Weekend = Sat.type | Sun.type
  type Workweek = Mon.type | Tue.type | Wed.type | Thu.type | Fri.type
  type All = Weekend | Workweek
}
```

===
# TASTY/Linker
--------------

* classファイルを作るとScala固有の情報が落ちる
* プログラム全体を見渡すと不要なコードとかもコンパイルしないといけない
* かといって毎回プログラム全部をコンパイルし直すのは遅い
* → TASTY。型推論後のASTをシリアライズする
  + Scalaは型推論が遅いのでそこをスキップ出来るだけでそこそこ速くなる
* classファイルを跨げるようになったのでユーザが最適化とかも書ける
* Scala/Scala.js/Scala Native共通プラットフォーム化への布石？
* どうやらclassファイルにバイトコードとTASTYを埋め込む??

===
# まとめ
--------

* Scalaの基礎にDOTがあるよ
* DOTを参考にdottyが作られたよ
* dottyで色々改善されるよ
* ついでにTASTY/Linkerについて話したよ

===
# 参考1
------

* [The Essence of Dependent Object Types](https://infoscience.epfl.ch/record/215280/files/paper_1.pdf)
* [From F to DOT: Type Soundness Proofs with Definitional Interpreters](http://arxiv.org/pdf/1510.05216v2.pdf)
* [Dependent Object Types](http://www.cs.uwm.edu/~boyland/fool2012/papers/fool2012_submission_3.pdf)
* [Why is the Scala compiler so slow? - Quora](https://www.quora.com/Why-is-the-Scala-compiler-so-slow)
* [performance - Java compile speed vs Scala compile speed - Stack Overflow](http://stackoverflow.com/questions/3490383/java-compile-speed-vs-scala-compile-speed/3612212#3612212)

===
# 参考2
-------

* [GHC doesn&#39;t do subtyping. I suspect that is the main reason why Scala is slow - ... | Hacker News](https://news.ycombinator.com/item?id=5008761)
* [A Core Calculus for Scala Type Checking](http://lampwww.epfl.ch/~odersky/papers/mfcs06.pdf)
* [namin/dot: formalization of the Dependent Object Types (DOT) calculus](https://github.com/namin/dot)
* [The DOT Calculus](http://lampwww.epfl.ch/%7Eamin/dot/current_rules.pdf)
* [Dotty: exploring the future of scala](https://d-d.me/talks/scalaworld2015/)
* [Dotty and types: the story so far](http://guillaume.martres.me/talks/typelevel-summit-oslo/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>高速な継続ライブラリに向けて</title>
      <link>/slide/kousokunakeizokuraiburarinimukete/</link>
      <pubDate>Sun, 08 May 2016 21:26:32 +0900</pubDate>
      
      <guid>/slide/kousokunakeizokuraiburarinimukete/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 高速な継続ライブラリに向けて
----------------------
[継続勉強会](http://connpass.com/event/28150/) 2016-05-22
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
===
# 継続欲しい
-----------

* 色々な場面で便利
* Schemeで使い回してるのうらやましい
* Common Lispでも使いたい
* 現実には限定継続が欲しい
  +  Common Lispには大域脱出はある

===
# 限定継続を使う例
-----------------
## 非同期プログラミング

* コールバック形式だと厳しい
* 限定継続を使うと綺麗に書き直せる

===
# 限定継続を使う例
-----------------
## ゲームのコルーチン

* 複数のオブジェクトを制御するのにコルーチンが欲しい
* cf [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)

===
# 限定継続を使う例
-----------------
## do記法

* モナドのdo記法は限定継続を使って実装出来る
* [Operational monad in scheme](http://www.slideshare.net/yuichinishiwaki/operational-monad-in-scheme)


===
# Common Lispでの限定継続の実現
---------------

1. 仕様に入れてもらう
2. 処理系に手を入れる
3. ユーザレベルで(限定)継続ライブラリを作る
   + 柔軟なCommon Lispでは可能

===
# CPS変換
---------

* (限定)継続の実現方法の1つ
  + スタックを切り取る方式とかもある
* 機械的にも出来る
* グローバルな変換なのとプリミティブな式しか書けないでコンパイラ内部でやることが多い
  + 継続関係なしに中間形式として採用されることが多い
* 関数定義/呼び出し以外にも諸々の構文とかに対しても定義が必要

===
# CPS変換
----------

Q. Common Lispだといくつの構文に対して定義が必要?

1. 1つ
2. 26つ
3. 42つ
4. 無数


===
# CPS変換
----------

A. 26つ (スペシャルフォーム25+funcall)

===
# Common Lispのプリミティブ
--------------------------

* スペシャルフォームと呼ばれる
* 仕様で25個定められている
* [CLHS: Section 3.1.2.1.2.1](http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm)
* この中に関数定義だとか例外だとかは入っていない
  + マクロで定義されている

===
# マクロ
--------

* 構文木 to 構文木(S式to S式)変換器( = 普通のLispの関数)
* 新しい構文を作れる
* CPS変換は?????

===
# `macroexpand`
-------------

* [CLHS: Function MACROEXPAND, MACROEXPAND-1](http://clhs.lisp.se/Body/f_mexp_.htm)
* マクロを手動展開する関数
* 雑にいうと普段pre-orderなマクロ展開をin-orderやpost-orderにする時に使う
* 本来はあまり使いたくない
  + 処理系の展開器に任せた方が間違いが少ない
* これでマクロを排したプリミティブのCommon Lispの構文木にアクセス出来る

===
# cl-cont
---------

* 上記のことを全てやったライブラリ
* デファクトというか唯一のライブラリ
* [Common Lispで限定継続と遊ぶ | κeenのHappy Hacκing Blog](http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/)

===
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;「shift/resetがわからない時にあげる声」&lt;/p&gt;&amp;mdash; かず(原材料に小麦粉を含む) (@kazzna) &lt;a href=&#34;https://twitter.com/kazzna/status/674026894602309632&#34;&gt;2015年12月8日&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# cl-contの使用例

``` common-lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```

===
# cl-contの使用例

``` common-lisp
(FUNCALL
 (LAMBDA (&amp;OPTIONAL #:G542 &amp;REST #:G543)
   (DECLARE (IGNORABLE #:G542))
   (DECLARE (IGNORE #:G543))
   (FUNCALL
    (LAMBDA (&amp;OPTIONAL #:G544 &amp;REST #:G545)
      (DECLARE (IGNORABLE #:G544))
      (DECLARE (IGNORE #:G545))
      (FUNCALL (LAMBDA (K) (FUNCALL K 1))
               (LAMBDA (&amp;OPTIONAL #:G546 &amp;REST #:G547)
                 (DECLARE (IGNORABLE #:G546))
                 (DECLARE (IGNORE #:G547))
                 (FUNCALL (CL-CONT::FDESIGNATOR-TO-FUNCTION/CC #:G542) #&#39;VALUES
                          #:G544 #:G546))))
    1))
 #&#39;+)
```


===
# cl-contへの不満
-----------------

* 遅い
* lambda多い。
  + 多分コンパイラと相性が悪い
* lambda禁止おじさんと分かりあえる

===
# cl-fast-cont


&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# cl-fast-cont
--------------

* [KeenS/cl-fast-cont: faster partial contiuation library of common lisp](https://github.com/KeenS/cl-fast-cont)
* とりあえずレポジトリ作っただけ
* 完成させたい…

===
# アプローチ1
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# SSA使う
---------

* CPSと等価
* だけどSSAだったらlambda出てこない
* Common Lispならgotoあるしいけるんじゃね？

===
```common-lisp
(let (x y z)
 (tagbody
    (setq x 1)
  :call/cc
    (setq y 1)
    (setq z (+ x y))))
```


===
# 問題
-------

* ネイティブスタックとは別に自分でスタック作らないといけない
  + 例外とかでスタック巻き戻されるとつらい
* gotoのタグをtagbodyの外に持ち出せない(=継続を外に持ち出せない)
* 変数を準備するのが面倒orパフォーマンスに影響しそう
* そもそもtagbodyそこまで柔軟じゃなかった
* 関数が消し飛ぶ

===
# アプローチ2
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# SSA+CPS
---------

* SSAとCPSを組み合わせる
* 基本はSSA
* スタックを使う/継続が必要な所でだけCPS
===
# 問題
-------

* SSAの部分意味なくね？
* そもそも継続を取り出すのが目的なので関係ない所で変換しても意味がない

===
# アプローチ3
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# Selective CPS
----------------

* 継続が必要な部分でのみ変換
* 2 pass transformation
* [A Selective CPS Transformation](http://www.sciencedirect.com/science/article/pii/S1571066104809691)
===

```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    (+ 1 (call/cc
          (lambda (k)
            (funcall k y))))))

```

===

```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    (+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```

===

```common-lisp
(with-call/cc
  (let ((x 3) y)
    (setq y (* x x))
    @(+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```

===

```common-lisp
(with-call/cc
  @(let ((x 3) y)
    (setq y (* x x))
    @(+ 1 @(call/cc
          (lambda (k)
            (funcall k y))))))

```

===
# そもそもCommon Lispのつらい話
-------------------------------
* セマンティクスが動的
  + catch, block, tagbody
  + special variable
  + 変換は静的なのでどう頑張っても追い付かない
* multiple valueが面倒


===
# ダイナミック!!
----------------

``` common-lisp
(block name
 (let ((f
        (lambda (x) (return-from name x))))
   (with-call/cc
       (funcall
        f
        (call/cc
         (lambda (k)
           (funcall k 2)))))))
```

===
# スペシャル変数
---------------

* Common Lispにはレキシカルスコープとダイナミックスコープ両方ある
* CPS変換すると継続の全てがスコープ下に入る
  + 関数の呼び出し関係が木だったのが線型になる
  + ダイナミックスコープだと困る
===
![CPS前のAST](/images/cps/pre-cps.png)


===
![CPS後のAST](/images/cps/post-cps.png)


===
```
(defvar *x* 1)
(with-call/cc
  (progn
    (let ((*x* 2))
      (call/cc ..)
      (format t &#34;~a~%&#34; *x*)) ; *x* = 2
    (format t &#34;~a~%&#34; *x*))) ; *x* = 1

```

===

```
(defvar *x* 1)
(with-call/cc
  (progn
    (let ((*x* 2))
      (...
       (lambda (ignore)
         ((lambda (ignore)
            (format t &#34;~a~%&#34; *x*)) ; *x* = 2!!
          (format t &#34;~a~%&#34; *x*))))))) ; *x* = 1
```

===
# 多値
------

* Common Lispの多値はGoと違って無視出来る
* 変換が空気読む必要がある
* 下手するとプログラムを壊す
  1. 本当は多値を返してるのに変換で無視された
  2. 意図的に無視してるのに変換で加えられた

===
# 関数定義と引数の数
-----------------

* **Selective** CPS
* 関数をCPS変換するときとしない時がある
* 呼び出す時にどっちか分かんなくね？
  1. 統一的に変換してしまう
  2. Selectiveに変換して関数にメタデータつける

-&gt; まだ決めきれてない

===
# パフォーマンス
----------------


&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# フィボナッチ数列
-----------------
* とりえあずのフィボナッチ数列で計測
  + Full CPS変換に割と不利
  + 何も考えずにライブラリを使うとこうなるよって例
* Selective CPSは何もしない=普通の定義と同じ


===
```common-lisp
(defun fib (n)
  (if (&lt;= n 1)
      1
      (+ (fib (- n 1)) (fib (- n 2)))))
```

``` common-lisp
(defun/cc fib-cont (n)
  (if (&lt;= n 1)
      1
      (+ (fib-cont (- n 1)) (fib-cont (- n 2)))))
```

===
# Selective


```
Evaluation took:
  1.517 seconds of real time
  1.516000 seconds of total run time (1.516000 user, 0.000000 system)
  99.93% CPU
  4,388,993,782 processor cycles
  0 bytes consed
```

===
# Full

```
Evaluation took:
  18.347 seconds of real time
  18.576000 seconds of total run time (18.248000 user, 0.328000 system)
  [ Run times consist of 1.396 seconds GC time, and 17.180 seconds non-GC time. ]
  101.25% CPU
  53,149,416,888 processor cycles
  22,922,853,904 bytes consed
```
===
# コルーチン
------------

* そこまでFull CPSに不利じゃない
* 割と実用しそうな例
* Selective CPSは少しだけラムダが少ない

===
# Selective

``` common-lisp
(let (c)
  (setf c ((lambda ()
             (write-line &#34;in thread A 1&#34;)
             (lambda ()
              (write-line &#34;in thread A 2&#34;)
              (lambda ()
                (write-line &#34;in thread A 3&#34;))))))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```


===
# full

```common-lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```
===
# Selective

```
Evaluation took:
  0.905 seconds of real time
  0.904000 seconds of total run time (0.904000 user, 0.000000 system)
  99.89% CPU
  2,617,396,241 processor cycles
  0 bytes consed

```

===
# full

```
Evaluation took:
  1.272 seconds of real time
  1.272000 seconds of total run time (1.272000 user, 0.000000 system)
  100.00% CPU
  3,681,362,466 processor cycles
  0 bytes consed
```

===
# まとめ
--------

* 限定継続便利だよ
* マクロを使えばCPS変換で限定継続実装出来るよ
* でもパフォーマンや言語の問題もあるよ
* Selective CPSを使えばパフォーマンスの問題解決出来るよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>テストについて、Scalaと。</title>
      <link>/slide/tesutonitsuite_Scalato_/</link>
      <pubDate>Tue, 12 Apr 2016 22:31:51 +0900</pubDate>
      
      <guid>/slide/tesutonitsuite_Scalato_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# テストについて、Scalaと。
----------------------
サイバーエージェント アドテクスタジオ  
ScalaMeetUp テスト回

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
   + 基盤開発グループでScalaで基盤開発してます
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# Scalaのテスト
---------------

* ScalaTest
  + 機能豊富
  + 複数のテストスタイルを選べる
  + 他のフレームワークとの統合がある
* Specs2
  + 普通に使いやすい
* 他にもScalaCheck、JUnit、Gatlingなどなど

===
# ScalaTestのスタイルたち
-----------

* FunSuite
  + xUnitっぽいらしい
* FlatSpec
  + xUnitからBDDに移行した人向けらしい
* FunSpec
  + RSpecっぽいBDD用の

===
# ScalaTestのスタイルたち
-----------

* WordSpec
  + Specs2に似てる。
* FreeSpec
  + 何段にでもネスト出来る。自由。
* Spec
  + テスト=メソッド。速いらしい。

===
# ScalaTestのスタイルたち
-----------
* PropSpec
  + プロパティベースのテスト。ScalaCheckとの統合。
* FeatureSpec
  + シナリオテスト。
===
# その他の機能
-------------

* mockitoのシュガー
* Matcher DSL
* 複数のランナー（複数のツールとの統合）

===
# Axionのテスト
コード紹介を多めに
&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 単体テスト
---------------

* 普通の単体テストはWordSpec
* ホーアの3つ組に基いて事前条件、コマンド、事後条件(不変条件)に分ける
  + 「{事前条件}が成り立つ時{コマンド}を実行し、停止するなら{事後条件(不変条件)}が成り立つ」の列挙
* [テストについて考えてみた | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/tesutonitsuitekangaetemita/)
* コマンドの実行と事後条件への表明を明確に分離
* テストの分け方に試行錯誤

===
# 事前条件
----------

* 基本的にはmockitoをフルに使う
* テストは並行に走るのでテストケース毎にモックを準備
* コンテキストの共有は基本的にはしない
  + 情報の局所性を上げて何をテストするかを理解しやすくする
  + 逆にノイズが乗ってわかりにくい？
* メソッドの実行に必要な引数と環境全てを構築する

===
# コマンドの実行
---------------

* 例外が起きないことだけ表明する
* 結果はvarに保存して外に持ち出す。

===
# 事後条件
----------

* コマンドを実行した結果に対する表明
* 環境に対する表明
  + 環境が変化した/しなかった
  + 依存オブジェクトのメソッドが呼ばれた/なかった

===
メソッド毎にテストケースをグルーピング

``` scala
&#34;Class#method&#34; when {
  &#34;precondition&#34; should {
    ...
    var ret: Type = null
    &#34;method invocation&#34; in {
      ret = ...
    }

    &#34;post conditions&#34; in {
      ...
    }
  }
}

```

===
# Tips
------

* エディタでテンプレートを用意しておくと楽
  + ensimeのテストテンプレートとか
* やや冗長でも頭を使わずに書ける/理解出来るテストを書く

===
# ユーティリ
---------------

* ユーティリティのテストはPropSpec
* ユーティリティ = 汎用的(文脈に依存しない)、副作用がない、小さい
  + まさにプロパティベースのテストに向く
* ほとんどGenerator Driven Test
  + 半分くらいScalaCheckの機能を使う
* 一部Tebale Driven Test
  + Generatorがコーナーケースを生成してくれない時がある

===
# 他のテスト
------------

* インテグレーションテスト/パフォーマンステストはGatling(の予定)
* Gatlingでエラーレート、パーセンタイル、レスポンスなどをテスト出来る
* パフォーマンステストは実行インスタンスを固定しないといけない問題が…
* シナリオテストはない(APIがReadのみなため)

===
# 他のテスト
---------------

* AxionはThriftプロトコルだがGatlingのAPIをいくつか実装すればGatlingを独自プロトコルに対応出来る
  + 実装量はほとんどない
  + 2~3個DSLを作るだけ
  + 簡単とはいってない(ドキュメントがないつらさ)
* Gatlingのおかげでパフォーマンスに対する表明やリクエスト毎のチェックなどが簡単
* そのうちノウハウを公開するかも？
  + 2.1.Xと2.2.XでAPIが違う問題も…

===
# まとめ
--------

* ScalaTestを紹介したよ
* ScalaTestの実用例を紹介したよ
* Gatlingについて紹介したよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SMLで函数型的正規表現マッチ</title>
      <link>/slide/SMLdekansuukatatekiseikihyougenmatchi/</link>
      <pubDate>Tue, 29 Mar 2016 01:44:39 +0900</pubDate>
      
      <guid>/slide/SMLdekansuukatatekiseikihyougenmatchi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLで函数型的正規表現マッチ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# 元ネタ
--------
[関数型的正規表現マッチ | Preferred Research](https://research.preferred.jp/2010/11/regexp-play/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 正規表現
----------

必要最小限の要素は5つだけ

1. 空文字
2. アルファベット1つ
3. 正規表現のOR結合
4. 正規表現のAND結合
5. 正規表現の繰り返し

===
# SMLで表してみる
-----------------

``` sml
datatype  reg
  = Empty
  | Sym of t
  | Or of reg * reg
  | And of reg * reg
  | Rep of reg
```
===
# 本当に大丈夫？

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# `/(a|b)*c/`
-----------

``` sml
And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)
```

===
# `/https?:\/\/[a-z]*/`
-----------

``` sml
val a_z = Or(Sym&#34;a&#34;, Or(Sym &#34;b&#34;, Or(Sym &#34;d&#34;, ...)))
And(Sym &#34;http&#34;, And(Or(Sym &#34;s&#34;, Empty), And(Sym &#34;://&#34;, Rep a_z)))
```

===
# 実装してみる

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# `Empty`, `Sym`, `Or`
----------------
trivial

``` sml
fun match Empty u = isEmpty u
  | match (Sym a) u = a = u
  | match (Or(p, q)) u = match p u orelse match q u
```

===
# `And`
--------

`And(p, q)` に入力が`u`の時`p`がどこまでマッチするか分からないので

* `u` から一部取ってきて`p`にマッチするか確認
* 残りの文字列が`q`にマッチするか確認

===
# `And`
--------
`match (And (Sym &#34;a&#34;, Sym &#34;b&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;&#34;)、(Sym &#34;b&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;b&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;b&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;abd&#34;)、(Sym &#34;b&#34;と&#34;&#34;)


===
# `And`
--------

``` sml
  | match (And(p, q)) u = 
    withSprits u (fn (u1, u2) =&gt; 
      match p u1 andalso match q u2)

```

`withSprits u f` は`u`を2分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。

===
# `Rep`
-------

`Rep(r)` に入力が`u`の時、`r`がどこまでマッチするかも`Rep`が何回繰り返すかも分からないので

* `u` を任意の個数に分割し
* その全てが`r`にマッチするか確認

===
===
# `Rep`
--------
`match (Rep (Sym &#34;a&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;b&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)



===
# `Rep`
--------

``` sml
  | match (Rep(r)) u =
    withParts u (fn input =&gt;
      List.all (match r) input)
```

`withParts u f` は`u`を分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。


===
# チェック
----------

```
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbca&#34;;
val it = false : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbc&#34;;
val it = true : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;c&#34;;
val it = true : bool
```

===
# まとめ
--------

* 適当に実装したら正規表現も簡単に実装出来るよ
* SMLで正規表現実装したよ

===
# 参考
------

* [KeenS/regexp](https://github.com/KeenS/regexp)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ビッグデータしないDrill、ローカルで快適に使うために</title>
      <link>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</link>
      <pubDate>Sun, 06 Mar 2016 14:54:30 +0900</pubDate>
      
      <guid>/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ビッグデータしないDrill、ローカルで快適に使うために
----------------------
[Tokyo Apache Drill Meetup](http://drill.connpass.com/event/27414/)  
2016-03-22

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
 + サイバーエージェントのエンジニア
   + アドテクスタジオ所属
   + データエンジニアじゃなくてもデータを触ることはある

===
# なぜローカルか
---------------

* ビッグデータ重い
* 使いたいデータが絞れる時には大袈裟
  + 「売り上げ上位1000のユーザの行動」とか
* 同じようなクエリの重複
  + 新しいテーブル作れないDBとかview作れないDBとか
* 結果をRに渡したりとかが面倒
  + CSVダウンロードがGUI
===
# キャッシュ的な
----------------

```
+---------------------------------+
| BIG DATA (BigQuery, Spark, etc) |
+---------------------------------+
        ^ |  ^  |
        | |  |  |
        | v  |  v
   +-------------------+
   | ローカルキャッシュ | &lt;- ???
   +-------------------+
     ^ | ^ | ^ | ^ |
     | v | v | v | |
     +----------+  |
     |   自分   |  |
     +----------+  v
     +---+    +-----+
     | R | &lt;--| CSV |
     +---+    +-----+
```

===
# やりたいこと
--------------

* パパッっと処理を始められる
  + だいたい「CSVを簡単に読める」に同じ
  + たまにJSONとか
* 簡単に処理出来る
  + 自分が馴れているかどうか
* CSVを吐ける
  + 最後はRに渡したい

===
# 候補
-------

* ローカルMySQL
  + 事前のScheme定義が必要
* R
  + 扱い馴れない
* SQLite
  + 事前のScheme定義が必要
* (Python)
  + あまり向いてない？

===

&lt;pre style=&#39;font-size: 200%&#39;&gt;
＿人人人人人人人＿
＞　突然のDrill　＜
￣Y^Y^Y^Y^Y^Y￣
&lt;/pre&gt;

===
# なぜ Drill
------------

* (デーモン立ち上げておけば)サクっと始められる
* CSVをそのまま読める
  + Schema定義がいらない!
* ついでにJSONも読める
* 馴れたSQLで操作出来る
* CSV吐ける

===
# Drillを便利にするために
-------------------------

* いくつかのシェル関数
* Drillのデーモン/クライアントの起動を便利に

```sh
drill-start() {
    ~/compile/zookeeper-3.4.8/bin/zkServer.sh start
    drillbit.sh start
}

drill-cli() {
    sqlline -u jdbc:drill:zk=localhost:2181
}

drill-web() {
   firefox http://localhost:8047
}
```

===
# もっと便利に
--------------

* REPLでの操作が面倒
  + ヒストリ遡るのとか
  + ミスった時の訂正が地味に不便
* シンタックスハイライト欲しい
* 馴れたツールで編集したい

===
# sql-drill.el
--------------

* [KeenS/sql-drill.el](https://github.com/KeenS/sql-drill.el)
* Emacsのsql-modeのDrillサポート
  + emacsのsql-modeは拡張可能
* シンタックスハイライト
* REPL

===
# DEMO
------
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# まとめ
--------

* ローカルでデータ分析したい時があるよ
* その時にDrillは便利だよ
* Emacs向けのDrillプラグイン作ったよ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>