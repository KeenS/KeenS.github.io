<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Slides on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/slide/</link>
    <description>Recent content in Slides on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Aug 2015 04:16:50 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/slide/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>構文解析にまつわる小話たち</title>
      <link>http://keens.github.io/slide/koubunkaisekiarekore/</link>
      <pubDate>Sat, 08 Aug 2015 04:16:50 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/koubunkaisekiarekore/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# 構文解析にまつわる小話たち
----------------------
[#peg_study](https://twitter.com/search?q=%23peg_study&amp;src=typd&amp;vertical=default&amp;f=tweets)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバエージェントの新卒エンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# ウォームアップ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文解析はバッドノウハウ
-------------------------

* プログラム言語を使っているなら既にパーサはある
  + 文法も定義されてる
* 目の前のパーサを使え
  + パーサAPIがある言語もある(Lispとか)
* そうでなくても内部DSLを考えろ
  + 内部DSLで解決出来ないときだけ構文解析

# 本質はAST
-----------

* 結局はASTになればどんな文法でも同じ
* 文法はただの外皮、欲しいのはAST
* シンタックスシュガーは飾り
  + DRY出来るなら別
* S式を使え
  + ASTをそのまま書き下せる


# AST First
-----------

* 最初にASTを考える。そして文法を考える
* 何が欲しいのかイメージし易くなる
* 構文解析はAST生成の自動化。普段してないことを自動化するのは愚か。
* 早めに間違いに気付ける
  + `+`は二項演算子。じゃあ `&amp;&amp;` は？ `=` は？

Note: Lispだと+は関数、andはマクロ、setqはスペシャルフォーム


# 構文解析の流れ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文解析の流れ
---------------

1. Lexer generaterからlexerを作る
  + Lexとか
2. Parser generaterからparserを作る
  + yaccとか
  + BNFという記法
3. ソースファイルをlexerで処理してトークン化する
4. トークン列をparserで処理してASTを作る



```
         [Lexer]        [parser]
[Source]-------&gt;[Tokens]------&gt;[AST]
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# LexerとParserを分ける意味
--------------------------

* (上向き構文解析だと分けないとつらい)
* 役割の分担
  + 困難は分割せよ
* 文字列をシンボル化して比較が高速に
* 思考のフレームワークとして



&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;字句解析器手づくりの簡単さに対して構文解析器手づくりはわりと人を殺しにかかる&lt;/p&gt;&amp;mdash; gfn (@bd_gfngfn) &lt;a href=&#34;https://twitter.com/bd_gfngfn/status/578908166785671168&#34;&gt;2015, 3月 20&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 正規表現の使いどころ
---------------------

* 高速な実装がある
* 部品化しにくい
* 括弧の対応とか入れ子構造(`if .. then .. else`とか)は扱えない
  + perlの正規表現は厳密には正規表現ではない
* 構文解析には向かない
  + 「マッチ」は出来ても「抜き出し」は面倒
* Lexerには向いてる
  + トークン自体末端の部品なので部品化する必要がない

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;依存型のある言語でlexとか作ったら出てくるトークンの型変数に正規表現出てくるのかな&lt;/p&gt;&amp;mdash; eld-r-esh-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/597772476244885505&#34;&gt;2015, 5月 11&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;「bnf = (大雑把に言って)正規表現+括弧の対応」というのはchomsky–schützenbergerの定理という結構マニアックな定理(ドラゴンブックには載ってないと思う)をさらに僕なりに超訳したものなのであまり知られてないと思います．&lt;/p&gt;&amp;mdash; ryoma sin&amp;#39;ya (@sinya8282) &lt;a href=&#34;https://twitter.com/sinya8282/status/597465565654024192&#34;&gt;2015, 5月 10&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 構文クラス

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文クラス
------------

* 学術的だが知っておくと幸せになれる
* 文脈自由文法を解析するためのものを話す
  + 多くのプログラム言語は文脈自由文法
  + 正規言語 ⊂ 文脈自由文法
* 大きく分けると上向き構文解析と下向き構文解析
* 詳しくは[ドラゴンブック](http://www.amazon.co.jp/%e3%82%b3%e3%83%b3%e3%83%91%e3%82%a4%e3%83%a9%e2%80%95%e5%8e%9f%e7%90%86%e3%83%bb%e6%8a%80%e6%b3%95%e3%83%bb%e3%83%84%e3%83%bc%e3%83%ab-information-computing-a-v-%e3%82%a8%e3%82%a4%e3%83%9b/dp/478191229x)参照


# LL(1)
----

* 下向き
  + 再帰降下パーサ
* 定義した言語しか厳密に受け取らない
* 線形線形時間でパース可能
* 手書きに向く
* パーサーコンビネータとかも


# LR(1)
----

* 上向き
  + トークンをくっつけて構文要素に、構文要素をくっつけてさらに上の構文要素に…
* LL(n)⊂LR(n)
* LRそのものの解析は難しくて、いくつかサブクラスがある
  + 単純LR (SLR):  貧弱
  + 先読みLR (LALR): パーサジェネレータでよく使われる
  + 正準LR: 計算コストが高い。メモリ喰う
* 事前計算のコスト（面倒くささ）が高い
  + パーサジェネレータ


# LRパーサジェネレータ
-----

* 基本はBNF(Backus-Naur-Form)
* いくつか方式がある
  + 演算子順位解析も合わせる
    - EmacsのSMIEとか
  + BNFだけでやる
    - 別の言語も受理する可能性がある ドラゴンブック 上 p. 247
    - 普通は問題にならない


# LRの限界とか
-------------

* `-`の単項演算子と二項演算子の衝突
  1. SMLみたいに諦める(単項の`-`を`~`で表す)
  2. Lexerで区別する
* 左再帰で無限ループ
  + 手動でどうにか出来る
  + 自動でどうにかしてくれるジェネレータもある
* BNFの書き方によっては文法があいまいになる
  + `if .. then .. if .. then .. else ..` とか
  + 自動ではどうにもできないので気をつけるしかない


# BNFとパーサージェネレータの良さ
------------

* BNFは言語を定義する。
  + 言語仕様にも使われる
* 要は「仕様からプログラムを生成する」
* 宣言的


# 複数文法のサポートとグローバル変数の衝突
---------------------------------------

* 複数の文法をサポートしたい時がある
  + 独自記法と互換記法とか
* 雑なパーサジェネレータ/コンビネータを使っているとグローバル変数が衝突する
  + パーサライブラリの作者は配慮して下さい。


# 言語仕様の配慮
---------------

* LispはLL
* Java 1.0はLALR
  + 今はLALRではないらしい
* PrologはLALRだった気がする


# 非文脈自由文法
----------------

* 文脈を持つ（雑）
* ひねりなくパーサージェネレータ使っただけじゃ解析出来ない言語のこと。


## sedのs///
-----------

* 実は `s|||`のように区切文字は何でもいい
  + パスネームの置換に便利
* 対応関係が文脈で変わるので非文脈自由


## Markdown
-----------

* 元々のperlの実装は正規表現
  + 再帰を使っているので正規言語ではなく文脈自由文法
* GFMなどのTable記法はカラム数という文脈があるので非文脈自由
* Table記法をサポートする時は覚悟を持って。


# その他
--------

* 関数の仮引数の数と実引数の数の一致
* 変数の使用の前に変数宣言
* 要は構文解析で出来ることには限界がある。


# パーサの実際

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 速度と手軽さ
--------------

* 外部DSLやコンフィグファイルだとパーサの速度は必要ない
  + メインループで使われないので起動時間にしか影響しない。
  + むしろ手軽に作れた方がいい
* HTTPだとかメインループで使うものはどうやってでも速くしたい
  + 労力は惜しまない

# 手書きとジェネレータとコンビネータ
----------------------------------

* 速度が必要ならジェネレータ
* LLでないならジェネレータ
* 手軽さが欲しいならコンビネータ
* 色々手を加えたいなら手書き…かも


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;パーサ手書きするのダサイよなぁ。クラスが分からなくなる。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/597751470834855938&#34;&gt;2015, 5月 11&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ジェネレータの扱いにくさ
--------------------------

* あんまり人気ない気がする
* 2回も前処理必要なのダサいよね
* 新たな文法覚える必要がある
* そもそも作るのにもコストが高い
  + 言語の文法に合わせたプリンタ
  + 拡張性持たせると厄介
* かといって正規表現はやめましょうね

# DSLパーサジェネレータ
----------------------

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;PEGが正規表現と違って辛いところは言語組み込みじゃないのとワンライナーに向かないことなんだよな… &lt;a href=&#34;https://twitter.com/hashtag/peg_study?src=hash&#34;&gt;#peg_study&lt;/a&gt;&lt;/p&gt;&amp;mdash; わかめ@TypeScriptカッコガチ (@vvakame) &lt;a href=&#34;https://twitter.com/vvakame/status/629881217320550401&#34;&gt;2015, 8月 8&lt;/a&gt;&lt;/blockquote&gt; 

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# DSLパーサジェネレータ
----------------------

* あったらそれなりに人気出そう
* メタプログラミングが出来る必要がある
* Common Lisp
  + 作者自身作ってる途中でジェネレータとコンビネータを勘違いする
  + ドキュメントでジェネレータといってるのに実際はコンビネータだったりする
* D
  + なんか作ってる人いるらしい


# 複雑性と分かりやすさ
---------------------

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;オーバーエンジニアリングを「あいつは力に溺れた」と言い変えていくといいと思う&lt;/p&gt;&amp;mdash; イカid:mizchi0x (@mizchi) &lt;a href=&#34;https://twitter.com/mizchi/status/565662999063838720&#34;&gt;2015, 2月 12&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 複雑性と分かりやすさ
---------------------
* パーサが複雑な文法に対応出来ても人間が追い付かない
* 周辺のサポートも必要になるのでやっぱりシンプルな方が良い。
  + LRよりLL
  + S式とかシンプルの極み
  + [Clojureシンタックスハイライター開発から考えるこれからのlispに必要なもの](http://www.slideshare.net/sohta/clojurelisp?ref=http://athos.hatenablog.com/entry/2015/07/29/222535)
* 「出来る」と「した方がいい」は別の話


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;S式はどう考えても読み易い……&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/590528791677546496&#34;&gt;2015, 4月 21&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;}]))みたいなのを書いてると、括弧が一種類の言語、いいなぁ、と思ったりします。&lt;/p&gt;&amp;mdash; mzp (@mzp) &lt;a href=&#34;https://twitter.com/mzp/status/587941717451481088&#34;&gt;2015, 4月 14&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ソースロケーション保持法

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# ソースロケーション保持法
-------------------------

* エラーメッセージを出すためにはソースロケーションを保持する必要がある
* flymakeの情報: ファイル名、開始行/列 終了行/列 エラーメッセージ
  + 最悪これがあればどうにかなる
  + 「分かりやすい」メッセージはツールに任せる
* 字句解析だけでなく意味解析、さらにはつまるところコンパイルが終わるまで保存する必要がある
  + トークンやASTにメンバが増える
  + オブジェクト指向のカプセル化って素晴らしい


# 1. インクルード
----------------------

* トークンのデータに入れてしまうパターン
* `datatype token = Plus of int * int | Symbol of int * int * string` ...
* OOPなら自然だが函数型だとパターンマッチがつらくなる


# 2. ラップ
--------

* ロケーションのレコードでトークンをラップする
* `{start:int, end: int, token: token}`
* パターンマッチは少し楽になる
  + 多相レコードがないとそもそもレコードつらいけどな！！
* MLtonがやってるらしい


# 3. テーブル
-------------

* ロケーションテーブルを持って、トークンにはテーブルへのキーだけ持たせる
* トークンが軽くなるので速そう
* でも面倒そう


# エラー処理
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# エラーメッセージ
------------------------

* 一応ロケーションがとれればエラー箇所は出せる。
* メッセージの親切さはツールとヒューリスティックと根気
* clangとか頑張ってる

```
ERROR: expected tEnd before &#39;&lt;EOF&gt;&#39;
each do {}
          ^
```


# エラー回復
-------------

* シンタックスハイライターは壊れた文法も解析しないといけない
* 1回のコンパイルでできるだけ多くのエラーメッセージを出したい
* シンタックスエラーから回復したい


# Cの易しさ
-----------

* エラーがあってもセミコロンまで読み飛ばせば回復出来る
  + CやJavaは結構コンパイラが教えてくれる
* そういう言語設計も大事


# 拡張方法

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# リードマクロ
--------------

* トークンレベルの拡張
* 特定の「文字」がきた時にユーザ定義関数を使ってパースする
* リテラルをユーザが定義することが出来る
  + 正規表現リテラルとか
  + [Common Lispの正規表現](http://weitz.de/cl-interpol/)


# マクロ
--------

* ASTレベルの拡張
* LispとかScalaとかRustとか
  + Lispは自由度が高い
  + 関数マクロはないよりマシ程度
* ~衛生性~
* [マクロについて整理してみる | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru/)


## Cのマクロ
------------

* プリプロセッサなのでコンパイラの拡張ではない
* プリプロセッサ自体レキサを持つ
  + パーサとレキサを分ける意味
* ASTに関知しないのでやりたい放題


# 中置演算子
-----------

* 新しい中置演算子と優先順位を定義できる言語は多い
  + Haskell, SML, Prolog…
* パーサをその場で書き換えるのは難しいので後で処理する
  + [\[コンパイラ\]\[Haskell\]\[OCaml\] Haskellのinfixの仕組み - mad日記](http://d.hatena.ne.jp/MaD/touch/20090108)
* シンタックスのプラグインをセマンティクスに入れてるのでちょっと無茶


# 中置演算子
-----------

* 人間が同時に覚えられるのは3つまで
  + 優先順位がいくつもあっても覚えられない
  + 優先度40とか900とか無理。
* 本質はAST
  + 文法に問題を抱えるくらいならS式を使え


# Coq
-----

Coqは謎のテクノロジーにより `Notation`を使えば新しい文法を定義出来る

```coq
Notation &#34;&#39;SKIP&#39;&#34; :=
  CSkip.
Notation &#34;X &#39;::=&#39; a&#34; :=
  (CAss X a) (at level 60).
Notation &#34;c1 ; c2&#34; :=
  (CSeq c1 c2) (at level 80, right associativity).
Notation &#34;&#39;WHILE&#39; b &#39;DO&#39; c &#39;END&#39;&#34; :=
  (CWhile b c) (at level 80, right associativity).
Notation &#34;&#39;IFB&#39; e1 &#39;THEN&#39; e2 &#39;ELSE&#39; e3 &#39;FI&#39;&#34; :=
  (CIf e1 e2 e3) (at level 80, right associativity).

Definition fact_in_coq : com :=
  Z ::= AId X;
  Y ::= ANum 1;
  WHILE BNot (BEq (AId Z) (ANum 0)) DO
    Y ::= AMult (AId Y) (AId Z);
    Z ::= AMinus (AId Z) (ANum 1)
  END.
```
  

# 雑な話題

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# テスト
-------

* ASTのテストは案外難しい
  + 微妙な仕様変更で結果が変わる
  + でも言語の動作には関係なかったり

1. あきらめる
2. 不屈の精神でテストを直し続ける
3. 木に対するクエリ言語を使う


# 先読みと副作用
--------------

* 先読みしてバックトラックすると副作用があった時に困る
  1. 副作用を許さない
  2. 副作用は自己責任
  3. 一旦先読みで正しいパスを記憶してから正しいパスでもう一度パース
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Clojureおじさん</title>
      <link>http://keens.github.io/slide/Clojureojisan/</link>
      <pubDate>Mon, 22 Jun 2015 22:53:39 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Clojureojisan/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Clojureおじさん
----------------------
サイバーエージント新卒  
第5回 Fresh勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# Clojure 
---------

* 2007年から
* JVMで動くLisp系言語
* 函数型
* 動的型付き
* 値は基本immutable
* 遅延シーケンス
* STMがあり、並列処理に強い


# Hello World
-------------

```clojure
(println &#34;Hello, World&#34;)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# JVM
------
## Javaのコードをシームレスに呼べる

* `obj.method()` ではなく `(.method obj)`
* `Class.staticField` ではなく `Class/staticField`
* `obj.method1().method2()` ではなく `(.. obj method1 method2)`


# JVM
-----

```clojure
(.println System/out &#34;Hello JVM&#34;)
```

```clojure
(Math/random)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Immutable
-----------

* 状態を持たないのでコードの見通しが良い
  + 並列で考える時には重要
  + 複雑さだけでなく不整合などバグの原因になりやすい
* 変更可能な値もある
  + それらはトランザクション内でのみ変更可能
  + 不整合が起きない


# 函数型
--------

```clojure
(filter odd? (map #(+ 1 %) &#39;(1 2 3)))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 遅延シーケンス
---------------

```clojure
(def natural_number (iterate inc 1))
(take 5 natural_number) ;=&gt; (1 2 3 4 5)
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# リスト内包表記
----------------

```clojure
(for [x (range 5)] (* x x))
;=&gt; (1 4 9 16 25)
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;


#並列処理に強い
---------------

* 簡単にはJavaのスレッドを呼べばいい
  + Clojureの関数は全てCallableでRunnablea

```clojure
(.start (Thread. (fn [] 
                   (Thread/sleep 1000)
                   (println &#39;foo))))
```


#並列処理に強い
---------------
## core.async

* goroutineとgochannelが使える


## core.async
-------------

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (go (&gt;! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! (go (&lt;! c)))))
  (close! c))
```

```clojure
(require &#39;[clojure.core.async :as async :refer :all])
(let [c (chan)]
  (thread (&gt;!! c &#34;hello&#34;))
  (assert (= &#34;hello&#34; (&lt;!! c)))
  (close! c))
```
&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 今回紹介し切れなかったの
-------------------------

* マクロ
* メタデータ
* protocolとかの多態性
* ClojureScript/Om
* Typed Clojure


# まとめ
--------

* Clojureを使えばJavaが使える
* Clojureを使えばPythonのリスト内包表記が使える
* Clojureを使えばGoのgoroutine/gochannelが使える



&lt;span style=&#34;font-size:200%;&#34;&gt;Why not start Clojure?&lt;/span&gt;
&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lisp処理系拡張の探求 SBCLのマルチスレッドサポート</title>
      <link>http://keens.github.io/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</link>
      <pubDate>Sat, 20 Jun 2015 18:30:52 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
### Common Lisp 処理系拡張の探求
SBCLのマルチスレッドサポート

----------------------
Lisp Meet Up #29

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# CLのマルチスレッド
----------------------------
## [bordeaux-threads](https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation)
* 色々な処理系のマルチスレッドサポートの抽象レイヤー
* デファクトスタンダード
  + スレッド
  + ロック
  + コンディションヴァリアル


# SBLCのマルチスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# SBLCのマルチスレッド
----------------------------

* スレッド
  + スレッド内エラー
* アトミック操作&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
  + CAS&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* 排他制御（ロック）
* セマフォ
* コンディションヴァリアル
* バリア
* キュー&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* メールボックス&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* ゲート&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* frlock&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;


# アトミック操作

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# アトミック操作
----------------
複雑な動作は同じデータに並行に動かすと壊れうる

```
        [var = 1]
[incf]      |      [decf]
 [1]&lt;-------|
  |         |------&gt;[1]
 [2]---&gt;[var = 2]    |
            |        | 
        [var = 0]&lt;--[0]
```

# アトミック操作
----------------

* `atomic-{incf, decf}`
  + 動作出来る場所が限られている
* `atomic-{pop, push, update}`
  + CASプロトコルを実装していればどこでも


# CASプロトコル
---------------
* compare and swap
* アトミック操作の基本中の基本
  + ハードウェアレベルのサポート
* ざっくり言うと並行版setf
* `(cas place old new env)`
  + もし`place`が`old`に等しければ`new`を代入
* `(defun (cas foo) (old new))`
  + `cas`版の`setf`定義
* 他にも`setf`相当の機能は揃ってる

# CASプロトコル
---------------

```lisp
(defvar *foo* nil)

(defun (cas foo) (old new)
  (cas (symbol-value &#39;*foo*) old new))
```


# キュー
--------

* 普通のキュー
* スレッドセーフ
* `enqueue`, `dequeue`が基本操作
* `dequeue`が多値で、ブロックしない
  + 空なら第二値がnilになる


# メールボックス
---------------

* キューとほぼ同じ
* スレッドセーフ
* `send-message`, `recieve-message`が基本操作
* `recieve-message`はブロックする
  + タイムアウトも設定出来る
* `recieve-message-no-hangはdequeue`と同じ挙動
* `recieve-pending-messages`もある


# ゲート
--------

* 複数のスレッドが1つのイベントを待つ時に使う
* `wait-on-gate`, `open-gate`, `close-gate`が基本操作



```
[gate (closed)]  [T1] [T2] [T3]
     |            |    |    |
     |     wait   |    |    |
     |&lt;----------------+----+
     |            |    .    .
     |     open   |    .    .
[gate (opened)]&lt;--+    .    .
     +----------------&gt;+---&gt;+
         go            |    |
                       V    V
```


# frlock
--------

* Fast Read Lock
* またの名をRead-Write Lock
* Read Lockは多重に取れる。Write Lockは1つしか取れない。
* 基本操作は`frlock-read`と`frlock-write`
* 普通のlockと違って複数のReadが速くなる


# まとめ
--------

* SBCLのマルチスレッドサポートはbordeaux-threadsよりもリッチ
* 処理系の独自サポート面白い
* 処理系に依存してしまってもいいんじゃないだろうか
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ボトルネックのイイ話</title>
      <link>http://keens.github.io/slide/botorunekkunoiihanashi/</link>
      <pubDate>Thu, 04 Jun 2015 00:03:14 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/botorunekkunoiihanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ボトルネックのイイ話
----------------------
サイバーエージェント15新卒  
FRESH勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# ボトルネック
-------------

&gt; ボトルネック (bottleneck) とは、システム設計上の制約の概念。英語の「瓶の首」の意。一部（主に化学分野）においては律速（りっそく、「速さ」を「律する（制御する）」要素を示すために使われる）、また『隘路（あいろ）』と言う同意語も存在する。 


# Webアプリの主な登場人物
------------------------

* リバースプロキシ
* アプリケーションサーバ
* データベース


![relation of reverse proxy, app and DB](/images/webapp.png)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# レスポンスタイムとスループット
------------------------------

* レスポンスタイム 
  + リクエストを投げてレスポンスが返ってくるまでの時間
  + ユーザから見たメトリクス
* スループット&lt;!-- .element: class=&#34;fragment highlight-red&#34;--&gt;
  + 一定時間内にシステムがどれだけのリクエストを捌けるか
  + 中の人から見たメトリクス


# スループット
-------------

* スループットの最大 ≒ リソースの限界
  + ネットワーク帯域
  + ディスクIO
  + メモリ使用量
  + CPU負荷
* リソースのどれか1つでも限界になったらそれ以上パフォーマンスは上がらない

# パフォマンスの目安
-------------------

* ネットワーク帯域: bpsで表わす。NICによるが 1Gbpsとか
* CPU: パーセンテージで表わす。100xコア数が最大マシンに依る。
* メモリ: Bで表わす。ピンキリだが1GB ~ 128GBくらい？
* ディスクIO: Bpsで表わす。HDDなら 100Bpsとか。SSDなら10倍くらい。

テキトーに調べたので間違ってるかも

# 誰が何を
---------

* リバースプロキシ: ネットワーク、メモリ、CPUなど
* アプリケーションサーバl: CPU、メモリなど
* データベース: CPU、ディスクIOなど


&lt;span style=&#34;font-size: 200%&#34;&gt;「CPUは100%に行ってないのにアプリケーションが遅いんだよ」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* ボトルネックはCPUとは限らない
* 他のメトリクスも一緒に見るべき


# 推測するな。計測せよ
---------------------

* 実際に測ってみないとどこがボトルネックか分からない
* 何をしてどれくらいパフォーマンスが上がったのかも分からない
  + コストパフォーマンスも重要


&lt;span style=&#34;font-size: 200%&#34;&gt;「パフォーマンスが悪いからCPUをグレードアップしよう」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* ボトルネックはCPUとは限らない
* 例えばネットワーク帯域が詰まっているのにCPUを改善しても意味がない
* 帯域が詰まってるならデータを減らす、NIC（マシン）を増やすなどをする


&lt;span style=&#34;font-size: 200%&#34;&gt;「多分アプリケーションを高速化したよ」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* 計測せずに高速化しても意味がない
  + テストの無いリファクタリングがただの破壊なのと同じ
* 高速化した気になって実際はコードが汚なくなっただけの可能性もある

# ボトルネックは変わりうる
------------------------

* 一箇所をずっと改善してても意味がない
* ある程度改善したら次のリソースの限界がきてるかもしれない

&lt;span style=&#34;font-size: 200%&#34;&gt;「アプリケーションを10倍高速化したのにあんまり速くなってない」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* 10倍くらい極端に高速化すると次のリソースがボトルネックになる
* ディスクやネットワークの改善を考えるべき

# リソースの食い合い
-------------------

* 1マシンで完結している場合、リソースの食い合いが発生しうる
  + リバースプロキシとアプリケーションがCPUを食い合うとか
* この時、どのようにして解決するのが適切か？

# 例題
------

* アプリが80%くらいの負荷
* Rプロキシが20%くらいの負荷


# 例題
------

1. アプリが多くCPUを喰ってるからアプリを高速化すべき
2. アプリが多くCPUを必要としてるからRプロキシはアプリにCPUを譲るべき

# 例題
------

1. アプリが多くCPUを喰ってるからアプリを高速化すべき
2. &lt;span style=&#34;color: #aaa;&#34;&gt;アプリが多くCPUを必要としてるからRプロキシはアプリにCPUを譲るべき&lt;/span&gt;

# アムダールの法則
-----------------

* [アムダールの法則 - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%A0%E3%83%80%E3%83%BC%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87)
* ざっくり言うと比率の小さな部分を高速化しても全体の高速化は高が知れてる

&lt;span style=&#34;font-size: 200%&#34;&gt;「ORマッパ使うと遅そうだから生のSQL使おう」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* ORマッピングにかかるコストは微小
* 他にもっと効率的に改善出来る部分に手をつけるべき

# リソースの配分
---------------

* 逆に、与えられたリソースからどれをどこに割り当てるかの問題もある
* 理論的には負荷の高い部分に多くリソースを割り当てれば良い。
* しかしアプリケーションの構成を先に決めないといけないので事前に計測は出来ない
  + 知識と経験と勘

# 例題
------

* 画像配信アプリケーション
* VPS5台 
  + ネット1Mbps/メモリ1G/CPU4コア/HDD
* Rプロキシ、アプリ、DBにそれぞれ何台割り当てる？
  + 1つのマシンに複数機能を持たせても良い。

# チューニングは難しい
---------------------

* 様々な部分の知識が必要
* システム全体を見渡した設計力も大事
* 細かなチューニングテクニックも一杯
  + 今回話してないが、キャッシュ戦略とかも
  + Cache-Control
* 知識がないと計測しても数値の意味が分からない

&lt;span style=&#34;font-size: 200%&#34;&gt;「やった。5%高速化した」&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 誤り
------

* パフォーマンスは計測の度にゆらぎがある
* 5%くらいなら普通に測定誤差の範囲内
* 逆に、5%くらいの改善をしても意味がない

# チューニングは楽しい
---------------------

* パズルゲームみたいな部分もある
* チューニング次第でスループット何十倍とかいく
* 難しい分一気にパフォーマンスが上がると喜びも一入

# ISUCON

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ISUCON
--------

* [ISUCON公式Blog](http://isucon.net/)
* Webアプリケーションチューニングコンテスト
* 優勝賞金100万円
* 何でもアリ。どこをいじってもいい。
* 要はさっきの知識をフルで活用出来る


# ISUCON
--------

* 何でもアリは実は珍しい。
  + 他はデータベースのみ、とかアプリは触っちゃだめ、とか雁字搦め
* 前回は185組（1チーム2~3人）の大きな大会
  + 予選で27チームに絞られる
* 界隈の有名人が揃う天下一武闘会の様相
* 楽しい


# 良質な問題
-----------

* 過去問は教育的な問題が多数。
* 過去問は全て公開。
* 腕試しに丁度良い。

# 今年のISUCON
--------------

* 予選 9/26,27
* 本戦 10/31
* 2~3人のチーム
* Google Cloud Platform
* 出題は[@tagomoris](https://twitter.com/tagomoris)さんと[@kamipo](https://twitter.com/kamipo)さん


&lt;span style=&#34;font-size: 300%&#34;&gt;Let&#39;s ISUCON&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 参考
------
* [ISUCONで学ぶ Webアプケーションのパフォーマンス向上のコツ 実践編 完全版](http://www.slideshare.net/kazeburo/isucon-summerclass2014action2final)
* [ISUCONの話(夏期講習2014)](http://www.slideshare.net/tagomoris/isucon2014)
* [kamipoさんはすごい人](https://twitter.com/search?q=kamipo%E3%81%95%E3%82%93%E3%81%AF%E3%81%99%E3%81%94%E3%81%84%E4%BA%BA&amp;src=typd&amp;vertical=default&amp;f=tweets)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Transducerについて</title>
      <link>http://keens.github.io/slide/transducernitsuite/</link>
      <pubDate>Wed, 03 Jun 2015 22:29:50 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/transducernitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Transducerについて
----------------------
サイバーエージェント  
朝の3分スピーチ
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# Transducerって？
------------------

* Clojure 1.7で入るフレームワーク
* 関数のパイプライン化を簡単にする
* 入力、出力には依存しない


# Reduce関数について
-------------------

* `reduce: (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* `(&#39;a -&gt; &#39;b -&gt; &#39;a)` でシーケンスを集約する
* `(reduce + 0 &#39;(1 2 3)) ;=&gt; 6`
* 要はreduceは関数を使って集約する。

# Transducerについて
-------------------

* `transduce:((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a)) (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* 集約関数を変換する関数もとる
* `(transduce xf + 0 &#39;(1 2 3))`
* transducerで集約する前に処理を挟める

# すごいところ
-------------------------
## コンポーサビリティ

* `((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a))`
* 変換関数は入力と出力が同じ。
* つまり変換関数を合成出来る
* ex) `(comp (filter odd?) (map inc))`


# すごいところ2
--------------------------
## 汎用性

* 各関数は入力や出力について知る必要はない
  + シーケンスではなく要素に対して定義される
* シーケンスだけでなく遅延シーケンス、ストリーム、チャネルなどなどにも使える
* 中間シーケンスを作らない
  + 遅延シーケンスやストリームには大きなメリット
* 集約先をシーケンスなどにすることも出来る
  + 関数の汎用性が上がる

# すごいところ3
--------------
## 並列/非同期

* core.asyncもtransducerをサポート
* 各変換関数を並列/非同期に実行が可能
* さらに各関数に割り当てるプロセッサの数も細かく制御出来る


&lt;span style=&#34;font-size: 500%;&#34;&gt;変換して&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 500%;&#34;&gt;集約する&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 300%;&#34;&gt;何かに似てない？&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 600%;&#34;&gt;MapReduce&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; ozaさんの近しい環境というとHadoop...多段Mapreduceをtransdecerみたいにしようってはなしとかですか？&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605368356393218048&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; まさにその通りです．MapReduce には Combiner という中間集約をする API があるのですが，それをもっと汎用的にしようという話です． &lt;a href=&#34;http://t.co/injEiPjePG&#34;&gt;http://t.co/injEiPjePG&lt;/a&gt;&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605369771505221633&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; すごい楽しそうですね。Clojure向けのAPIがtransducerのバッグエンドになって普段書いてるコードがそのままHadoopで動いたりしたら、とか夢が無限に広がります&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605370461476646912&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; おお，その案は良いですね！！&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605370619509637121&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 200%;&#34;&gt;Clojure 1.7 + Transducer&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 400%;&#34;&gt;Comming Soon&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 参考
------
* [Clojure 1.7のtransducersを動かしてみよう - Qiita](http://qiita.com/tokomakoma123/items/1ca3fb0dddc5b901b032)
* [core.async+transducers Shibuya.lisp #21](http://www.slideshare.net/ktsujister/coreasynctransducers-shibuyalisp-21)
* [Hadoop Combinerメモ(Hishidama&#39;s Hadoop Combiner Memo)](http://www.ne.jp/asahi/hishidama/home/tech/apache/hadoop/Combiner.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>21世紀のエンジニアのためのHTTP/2入門</title>
      <link>http://keens.github.io/slide/21seikinoenjinianotamenoHTTP_2nyuumon/</link>
      <pubDate>Mon, 18 May 2015 00:24:08 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/21seikinoenjinianotamenoHTTP_2nyuumon/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 21世紀のエンジニアのためのHTTP/2入門
----------------------
サイバーエージェントFresh勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# HTTPについて
-------------

* 1990年誕生の骨董仕様
* Human Readableなテキストベース
* パフォーマンスはあまり考慮してない


# HTTP/1.1の限界
---------------

* フォーマットがゆるふわでパースしづらい
* 何度も似たようなヘッダをる
  + 割とネットワーク負荷が高い
* 基本1コネクションにつき1ファイルの送受信
  + 短命なコネクションをいくつも張ることになる
  + コネクションが&#34;ウォームアップ&#34;する前に切れる
* Head of Line Blocking
  + 遅いコンテンツをダウンロードしてると他のコンテンツがダウンロード出来なくなる


```
GET / HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ja
Accept-Encoding: gzip, deflate
Cookie: _ga=GA1.1.1989570020.1429589222; __utma=111872281.1989570020.1429589222.1430193585.1431477266.5; __utmz=111872281.1429589222.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmc=111872281
Connection: keep-alive
Cache-Control: max-age=0
```



```
GET /js/todo.js HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0
Accept: */*
Accept-Language: ja
Accept-Encoding: gzip, deflate
Referer: http://localhost:8080/
Cookie: _ga=GA1.1.1989570020.1429589222; __utma=111872281.1989570020.1429589222.1430193585.1431477266.5; __utmz=111872281.1429589222.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmc=111872281
Connection: keep-alive
Cache-Control: max-age=0
```



```
GET /style/main.css HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0
Accept: text/css,*/*;q=0.1
Accept-Language: ja
Accept-Encoding: gzip, deflate
Referer: http://localhost:8080/
Cookie: _ga=GA1.1.1989570020.1429589222; __utma=111872281.1989570020.1429589222.1430193585.1431477266.5; __utmz=111872281.1429589222.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmc=111872281
Connection: keep-alive
Cache-Control: max-age=0
```

# 涙ぐましい努力
--------------
何度もリクエストをしないためにファイル数を減らす様々な努力がされてきた

* css/js concatenation
  + cssやjsを1つのファイルにまとめてアクセスを減らす
* image inlining
  + 画像をBase64エンコードしてCSS内に埋め込む
* image sprite
  + 複数の画像を1まとめにして表示する時に切り出して使う
* 並列アクセス
  + ブラウザは最大6並列でサーバにアクセスする

# HTTP/2

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# HTTP/2
--------

* 2015-05-15(先週の金曜)に[RFC化](http://jxck.hatenablog.com/entry/http2-rfc7540)
* HTTP/1.1に限界を感じたGoogleによって作られたSPDYがベース
  + 現実の問題を解決している
  + 新しいがある程度の信頼性もある
* これから広まっていく


# HTTP/2の特徴
-------------

* 接続開始はHTTP/1.1のUpgradeを使う。
  + HTTP/1.1と共存可能
* バイナリベースになってパースが楽に
* セマンティクスはHTTP/1.xのものを保持
* ヘッタの圧縮も行なう([HPACK](http://http2.github.io/http2-spec/compression.html#indexing.tables))
* プロキシやリバースプロキシの存在も織り込んだ仕様(Hop by Hop)
* その他拡張も多数

CF [HTTP/2の現状とこれから](http://www.slideshare.net/shigeki_ohtsu/http2-ohtsu-html5conf2015)

## セマンティクスの保持
--------------------

* HTTP/2 -&gt; HTTP/1.xへの変換が可能
* つまり、(リバース)プロキシの内側は1.x、外側は2が可能
  + アプリケーションはいじらずにフロント側が対応すればすぐに使える

CF [nghttpx](http://qiita.com/tatsuhiro-t/items/99a2fd61d0fb16d7241b)

## セマンティクスの保持
--------------------

こういうことが可能

```
+------+           +-------+             +---+
|Client|-[HTTP/2]-&gt;|R.Proxy|-[HTTP/1.1]-&gt;|App|
+------+           +-------+             +---+
```


## HPACK
--------

* よく使うヘッダは数値で表わす
  + Static Table
* 以前送ったヘッダも数値で表わせる
  + Dynamic Table
* それ以外もハフマン符号で圧縮可能


# HTTP/2の新機能
---------------

* ストリーム
* フロー制御
* サーバープッシュ


# ストリーム
------------

* ストリームは論理的なもの
* 1つのコネクション内で複数のストリームを作れる
  + 1コネクション内で複数のファイルをやりとり出来る
  + さらに、1コネクション内で並列に複数のファイルをやりとり出来る
* 短命なコネクションをいくつも張るよりずっと効率的
  + コネクションの性能をほぼフルで使い切れるようになった

# フロー制御
------------

スライド略。

[HTTP2 のフロー制御 - Qiita](http://qiita.com/Jxck_/items/622162ad8bcb69fa043d)

&gt;具体的な状況はいくつか考えられます。
&gt;
&gt; * 大きなファイルの通信が帯域を食いつぶし、他の通信を妨害する。
&gt; * あるリクエストの処理にサーバがかかりっきりになり、他のリクエストをサーバが処理してくれなくなる。
&gt; * 高速なアップロードを行うクライアントと、低速な書き込みをしているサーバとの間に挟まったプロキシが、調整のためにデータを貯めているバッファが溢れる。


# プライオーリティ制御
---------------------

* ストリームの存在が念頭にある
* 複数のストリームの内どれを優先させるかを決める
  + CSSは描画に必要だから優先度高、画像は後で良いから優先度低など
* ブラウザが要求する時に指定出来るし、サーバが指定することも出来る

CF [HTTP2 のプライオリティ制御 - Qiita](http://qiita.com/Jxck_/items/16a5a9e9983e9ea1129f)

# サーバープッシュ
----------------

* サーバが自発的にコンテンツを送れる
  + 今までは必ずクライアントがリクエストを送らないとレスポンスが返せなかった
* サーバがコンテンツの内容を分かってるなら先にコンテンツを送ることが可能
  + 例えばHTMLを生成する前に静的コンテンツを送ればレンダリング完了までの時間が速くなる
* いわゆるPush通知が可能
  + 今まではCommetやWebsocketなどで対応していた

CF [Service WorkerとHTTP/2が切り開く新しいWeb Pushの世界](http://d.hatena.ne.jp/jovi0608/20141204/1417697480)


# Availability
--------------
## ブラウザ

* Firefox 34以降（現38）
* Google Chrome 31以降 (現42)
* Opera
* IE 11 on Windows10


# Availability
--------------
## Servers
[Implementations · http2/http2-spec Wiki](https://github.com/http2/http2-spec/wiki/Implementations)
より抜粋。

![available servers according to http2 wiki](/images/http2_availability.png)


# Availability
--------------
## Servers

* Nginxを始めとして多くのサーバがHTTP/2を実装している
  + H2OのようにHTTP/2を念頭に置いて書かれたものもある
* アプリケーションサーバはそんなに多くない
  + 多分Rackなどの統一サーバインターフェースの問題

# Availability
--------------
少くともこういうことをすれば利用出来る

```
+--------+             +---------+             +-----+
|        |-[HTTP/2]---&gt;|         |             |     |
| Client |             | R.Proxy |-[HTTP/1.1]-&gt;| App |
|        |-[HTTP/1.1]-&gt;|         |             |     |
+--------+             +---------+             +-----+
```


# まとめ
--------

* HTTP/2について紹介した
* HTTP/2は現状の問題を解決する
  + サーバ/クライアント共に幸せになれる
* HTTP/2には段階的に移行出来る
  + 普及はかなり速いかもしれない
* みなさんが配属された時はHTTP/2の存在を前提としてアプリを設計しましょう

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>実装から理解するクロージャ</title>
      <link>http://keens.github.io/slide/jissoukararikaisurukuro_ja/</link>
      <pubDate>Sun, 17 May 2015 01:33:39 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/jissoukararikaisurukuro_ja/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 実装から理解するクロージャ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# クロージャとは？
-----------------

* 日本語にすると（関数）閉包
* 関数が外側のローカル変数を補足する
* 補足されたローカル変数は無限の生存期間を持つ
  + ローカル変数は本来スコープを抜けると生存期間が終わる
  + 言い換えるとグローバル変数みたいになる
  + でもあくまでスコープはローカル

# コード例
---------

```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p = genpower(2);
```

# コード例
----------

```js
p()  // =&gt; 2
p()  // =&gt; 4
p()  // =&gt; 8
x * 2 // x is not defined
```


# コード例
----------

* `p`が`n`と`x`を補足しているので関数を抜けた後も`x`と`n`は使える。
  + 関数の仮引数もローカル変数。
* でもローカル変数なので外からは見えない。



```
+-----------------------+
| function genpower(n){ |
|   var x = 1;          |
| ...   ^               |
| }     |               |
+-----------------------+
        |
 +------+
 |
+-------------+
||function(){ |
|+-- x *= n;  |
|   return x; |
| };          |
+-------------+
```



# コード例2
----------

```js
function incdec(){
    var x = 0;
    return [function(){ return ++x;},
            function(){ return --x;}];
}
var fs = incdec();
var inc = fs[0];
var dec = fs[1];
```

# コード例2
----------

```js
inc() // =&gt; 1
inc() // =&gt; 2
dec() // =&gt; 1
inc() // =&gt; 2
```

# コード例2
----------

* 同じタイミングで作られたクロージャ群は捕捉変数を共有する



```
+--------------------+
| function incdec(){ |
|   var x = 0;       |
|   ... ^            |
| }     |            |
+--------------------+
        +--------------+----+
                       |    |
+----------------------|---+|
| function(){ return ++x;} ||
+--------------------------+|
                       +----+
+----------------------|---+
| function(){ return --x;} |
+--------------------------+
```

# コード例3
----------

```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p1 = genpower(2);
var p2 = genpower(2);
```

# コード例3
----------

```js
p1()  // =&gt; 2
p1()  // =&gt; 4
p2()  // =&gt; 2
p2()  // =&gt; 4
```

# コード例3
----------

* 逆に、同じ関数から生まれても違うタイミングなら共有しない。



```
+-----------------------+ +-----------------------+
| function genpower(n){ | | function genpower(n){ |
|   var x = 1;          | |   var x = 1;          |
| ...   ^               | | ...   ^               |
| }     |               | | }     |               |
+-----------------------+ +-----------------------+
        |                         |
 +------+                  +------+
 |                         |
+-------------+           +-------------+
||function(){ |           ||function(){ |
|+-- x *= n;  |           |+-- x *= n;  |
|   return x; |           |   return x; |
| };          |           | };          |
+-------------+           +-------------+

```

# 実装方法
----------

* ここでは複数ある実装方法のうちの1つを紹介する。
* 言語はVM型のインタプリタ（大抵のインタプリタの実装に同じ）を仮定する


# 用語整理
----------
* `outer`から見たら`x`は捕捉(Captured)変数
  + `inner`から捕捉されてるから
* `inner`から見たら`x`は自由(Free)変数
  + `inner`からしたら`x`は知らない子だから

```js
function outer(x) {
    function inner(y){
        return x * y;
    }
}
```


# 実装概要
----------

* **クロージャとは捕捉変数の集まり**
  + つまり、捕捉した側ではなくされた側が作る
  + 捕捉した側は作られたものを参照するだけ

# 変数の話
---------

* グローバル変数はヒープ領域に置かれる
  + グローバル DB（大抵巨大なハッシュテーブル）に登録される
* ローカル変数はコールスタックに置かれる
  + 配列が作られ、インデックスでアクセスされる感じ。
  + ローカル変数の数は関数定義時に決定するので配列で管理出来る
  + 関数の実引数も同じように置かれる

# 捕捉変数の話
-------------

* 捕捉変数はヒープ領域に置かれる
  + 簡単には小さなハッシュテーブルに登録される
    - つまり、グローバル変数と同じ
    - 捕捉変数も関数定義時に決定するので配列でも管理出来る
  + ハッシュテーブル/配列はクロージャ毎に作られる

※ [本気出した実装](http://practical-scheme.net/docs/stack-j.html)だとコールスタックでどうにかすることもある


```js
var g = 1;
function sample(a) {
    var l = 2;
    var c = 3;
    return function(){ return c;};
}
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;



```
| ....          |
|---------------|
| args[0] = _   | a
|---------------| 
| locals[0] = 1 | var l
|---------------|--コールスタック↑--
| ....          |
| ....          |
|---------------|--ヒープ領域↓--
| caps[c] = 3   | var c = 3
|---------------|
| global[g] = 1 | var g = 1
| global[_] = _ |
| ....          |
| ....          |

```


```js
function incdec(){
    var x = 0;
    return [function(){ return ++x;},
            function(){ return --x;}];
}
var fs = incdec();
var inc = fs[0];
var dec = fs[1];
```


```
| ....          |
|---------------|--ヒープ領域↓--
| caps[x] = 0 &lt;-++------------------------+
|---------------|| +----------------------|---+
| global[_] = _ || | function(){ return ++x;} |
| ....          || +--------------------------+
| ....          |+------------------------+
| ....          |  +----------------------|---+
| ....          |  | function(){ return --x;} |
| ....          |  +--------------------------+
| ....          |
| ....          |
| ....          |

```


```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p1 = genpower(2);
var p2 = genpower(2);
```

AA略

```
| ....          |
|---------------|--ヒープ領域↓--
| caps[x] = 0 &lt;-+-|p1|
|---------------|
| caps[x] = 0 &lt;-+-|p2|
|---------------|
| global[_] = _ |
| ....          |
| ....          |

```


# 捕捉変数の実装
-----------------

* クロージャ毎にcapturedが作られる
* capturedとlocalはソース上の見た目は似ているが実装は大きく異なる
  + 多分この所為で分かりづらい
* グローバルアクセス出来ないだけでグローバル変数に似ている

# まとまってないけどまとめ
-------------------------

* クロージャについて説明した
* クロージャの正体は捕捉変数の集まり
* 捕捉変数はヒープ領域に置かれるローカルスコープな変数

※あくまで実装の1例です

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>勉強会駆動勉強で猛勉強</title>
      <link>http://keens.github.io/slide/benkyoukaikudoubenkyoudetakeshibenkyou/</link>
      <pubDate>Wed, 06 May 2015 22:02:12 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/benkyoukaikudoubenkyoudetakeshibenkyou/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 勉強会駆動勉強で勉強
----------------------
サイバーエージェント15卒FRESH勉強会
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + 大学では非情報系の学部にいた
 + Lisp, ML, Shell Scriptあたりを書きます

# 勉強会駆動勉強
---------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 勉強会駆動勉強
---------------
## 方法

1. 勉強会を見付ける &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
2. (詳しくない内容について)トークを登録する &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
3. 期日までに勉強する &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;
4. 期日までに資料を作る &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;4&#34; --&gt;
5. 発表する &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;5&#34; --&gt;


# 勉強会駆動勉強
---------------
## ポイント

* 自分でテーマを決めてる
* 自分で期限を決めてる
* 決めた期限は強制力がある
* アプトプットする
* 質問などでフィードバックがくる


# 勉強会駆動勉強
---------------
## 身に付く力

* 素早く調べる力
* 要点を素早く見付ける力
* プレゼン資料の作成力
* プレゼン力


# 例

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 前回のRustの話
実は発表決めた時点ではRustを書いたことなかった
![Rust slide](/images/rust_slide.png)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ISUCON
勉強会じゃないけど出場を決めてから周辺の勉強を始めた
![iscon4 blog](/images/isucon4_blog.png)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# おまけ
-------
その他の勉強法

* マイナー言語式勉強法
* やっちゃれ勉強法


# マイナー言語式勉強法

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# マイナー言語式勉強法
---------------------
## 方法

* マイナー言語を始める


# マイナー言語式勉強法
---------------------
## ポイント
![lisplogo](/images/lisplogo_256.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

* 情報が少ない
* ライブラリも少ない
* でも謎技術が使われていたりする


# マイナー言語式勉強法
---------------------
## 身につく力など

* どうにかして情報を見付ける力
* 英語力
* ソースコード読解力
* ライブラリ実装する力
* 他人のソースのバグを見付ける力
* プルリク力
* RFCなどを読む力
* パラダイムが広がる
* 謎技術を使えるようになる


# やっちゃれ勉強法

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# やっちゃれ勉強法
-----------------
## 方法

* (言語/仕様に)詳しくないけどライブラリの実装始めちゃう
* やっちゃれ（やってやれ）の気持で。


# やっちゃれ勉強法
-----------------
## ポイント

* 手を動かしてる


# やっちゃれ勉強法
---------------------
## 身につく力など

* 実装力
* 仕様の理解力
* 言語への理解
* (大抵)低レベルな操作



&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ

&lt;!-- .slide: class=&#34;center&#34; --&gt;


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispで限定継続と遊ぶ</title>
      <link>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</link>
      <pubDate>Sun, 26 Apr 2015 21:09:07 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Common Lispで限定継続と遊ぶ
----------------------
[Lisp Meet Up #27](https://atnd.org/events/64988)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# Agenda
--------

0. cl-contの紹介
1. 限定継続の話
2. 限定継続の使い方の話
3. 限定継続の実装の話


# CL-CONTの紹介

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CL-CONT
---------

* Common Lispの限定継続ライブラリ
* 結構古くからあるっぽい
* 割と色々なライブラリが使ってる

# CL-CONT
---------

![cl-cont dependers](/images/cl-cont-dependers.png)

# API
-----

* 継続を区切るマクロ
  + `with-call/cc`
  + `defun/cc`
  + `lambda/cc`
* 継続を取得するマクロ
  + `call/cc`
  + `let/cc`

※後で説明するので意味が分からなくても問題ないです。


# 限定継続の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後トップレベルに戻るまでの計算。
* Schemeが一級市民として扱えることで有名
* 値として取り出した時は0-1引数関数として振る舞う

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      □)))
```

# 継続とは
----------
あとはそれを関数にするだけ

```lisp
(lambda (k)
  (mapc #&#39;writ-line
        (loop :for x :in list
           :collect (if (evenp x)
                        k))))
```


# 限定継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後 *指定した位置* に戻るまでの計算。
* 継続がトップレベルまで戻るのに対して限定継続途中で止まる。それだけ。
* 部分継続などの言い方もある
  + 英語もpart contとdelimited contで分かれる


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(loop :for x :in list
           :collect (if (evenp x)
                        □))
```


# 限定継続とは
-------------

```lisp
(lambda (k)
  (loop :for x :in list
     :collect (if (evenp x)
                  k)))
```

# 限定継続の挙動
---------------
普通のやつ

```lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```

これは

```lisp
(+ 1 2)
```

と等価

# 限定継続の挙動
---------------
今度は継続を呼ばないでみる

```lisp
(with-call/cc
  (+ 1 (call/cc (lambda (k) 2))))
```

これは

```lisp
2
```

と等価

# 限定継続の挙動
---------------
もうちょっと呼ばない例  
(`(let/cc k ...)` = `(call/cc (lambda (k) ...))`)

```lisp
(with-call/cc
  (write-line &#34;hello&#34;)
  (let/cc k 1)
  (write-line &#34;world&#34;))
```

は

```lisp
(progn
  (write-line &#34;hello&#34;)
  1)
```

と等価


# 限定継続の使い方の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の使い方の話
---------------------

* グリーンスレッド
* コールバックを綺麗に書き換える
* 非決定性計算
* etc...


## グリーンスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


## グリーンスレッド
-----------------

* またの名をコルーチン
* またの名を強調スレッド



## グリーンスレッド
-----------------

```lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```

## グリーンスレッド
-----------------
実行結果

```
in thread A 1
in main thread 1
in thread A 2
in main thread 2
in thread A 2
in main thread 3

```


## コールバックの書き換え

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## コールバックの書き換え
----------------------
本当はこう書きたい

```lisp
(with-event-loop
    (format t &#34;Hello, ~a!~%&#34; (async-read stream)))
```

## コールバックの書き換え
----------------------
しかしライブラリがコールバック関数を要求してくる

```lisp
(with-event-loop
    (async-read stream (lambda (line)
                         (format t &#34;Hello, ~a!~%&#34; line))))
```

## コールバックの書き換え
-----------------------
コールバック = 限定継続（後述）なのでこうしてやれば良い。

```lisp
(with-event-loop
    (with-call/cc
      (format t &#34;Hello, ~a!~%&#34;
              (call/cc (lambda (k))
                       (async-read stream k)))))
```

## 非決定性計算

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## 非決定性計算
-------------
### ベースアイディア

* 継続を関数として取り出した後同じ処理を何回も実行出来るんじゃね？


## 非決定性計算
-------------
### ベースアイディア
複数回呼び出してみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (list (funcall c 1)
        (funcall c 2)
        (funcall c 3)))
```


## 非決定性計算
-------------
### ベースアイディア
普通の1引数関数として使ってみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (mapcar c (list 1 2 3)))
```

## 非決定性計算
-------------
### ベースアイディア
マクロでラップしてみる

```lisp
(defmacro for (&amp;body expr)
  `(with-call/cc ,@expr))
(defmacro in (m)
  `(let/cc k (apply #&#39;append (mapcar k ,m))))
(defun yield (x) (list x))
(defun unit () nil)
```


## 非決定性計算
-------------
使ってみる

```lisp
(for
  (let ((x (in &#39;(1 2 3)))
        (y (in &#39;(a b c))))
    (yield (cons x y))))
```

```
((1 . A) (1 . B) (1 . C) (2 . A) (2 . B) (2 . C) (3 . A) (3 . B) (3 . C))
```


# 限定継続の実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の実装の話
-------------------

* 継続は0~1引数関数として取り出せるのであった。
  + 実は機械的に取り出せる
* 継続は全ての式に暗黙に存在するのであった
  + 全ての式を継続を明示的に使うようにも出来る


# CPS変換

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CPS変換
---------

* 全ての関数の引数を1つ増やして、そこで継続を受け取る
* 値を返す時は暗黙のreturnを使うのではなく明示的に継続を呼ぶ
* 関数を呼ぶ時は必ず継続を渡す。呼び出し元には返ってこない（自然と末尾再帰になる）


# CPS変換
---------
例えば

```lisp
(with-call/cc
  (foo (call/cc
        (lambda (k)
          (funcall k 2)))))
```

は、取り出された継続が

```lisp
(lambda (k) (foo k))
```

。


# CPS変換
---------
よって

```lisp
((lambda (k) (foo k)) 2)
```

と変換される


# CPS変換
---------
再帰関数だと少し面倒

```lisp
(defun fact (n)
  (if (&lt;= n)
      1
      (* n (fact (- n 1))))))

```

が

```lisp
(defun fact (n c)
  (if (&lt;= n)
      (c 1)
      (fact (- n 1) (lambda (v) (* n v)))))
```

となる


# CPS変換
---------

* CPS変換を行なうことでいつでも継続を値として使える


# 限定継続の実装の話
-------------------

* CPS変換を裏で行なっている
* 自動で出来るのでマクロで変換をしている
  + 組み込み関数は変更出来ないので特別扱い
  + スペシャルフォームも気をつける必要がある
* `lambda`が乱立するのでパフォーマンスは酷い。


# まとめ
-------

* cl-contというライブラリがあって、限定継続が扱える
* 限定継続は処理を中断したり再開したり繰り返したりに使える
* 裏ではえげつないことをやっている
* パフォーマンスが必要なところでは使っちゃダメ


# 参考
------
* [picrin/partcont.scm at master · picrin-scheme/picrin](https://github.com/picrin-scheme/picrin)
* [cl-cont | Quickdocs](http://quickdocs.org/cl-cont/)
* [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)
* [継続渡しスタイル - Wikipedia](http://ja.wikipedia.org/wiki/%E7%B6%99%E7%B6%9A%E6%B8%A1%E3%81%97%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB)
* [M.Hiroi&#39;s Home Page / お気楽 Scheme プログラミング入門](http://www.geocities.jp/m_hiroi/func/abcscm20.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>非同期処理の「その後」の話。goto、継続、限定継続、CPS、そしてコールバック地獄。</title>
      <link>http://keens.github.io/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</link>
      <pubDate>Sat, 25 Apr 2015 23:44:46 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 非同期処理の「その後」の話
----------------------
## goto、継続、限定継続、CPS、そしてコールバック地獄

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# 同期処理とは
-------------
通常、外部とやりとり(I/O)する時に待ち時間(ブロック)が発生する。

![sync task image](/images/sync.png)


# 非同期処理とは
---------------
待ち時間に(ブロックせずに)別の処理をしようという発想。

![async task image](/images/async.png)

# 非同期処理の裏側
-----------------
処理Aと処理Bの他にいつどっちを動かすかを決めるスケジューラが存在することが多い

![async scheduler image](/images/async_scheduler.png)


# どうやって戻る問題
-------------------
* 一時停止した後「その後」の処理にどうやって戻るか

![cont image](/images/cont.png)

# 「その後」とは
-----------

```C
...
fputc(c); // ここの処理でI/Oが入る
// 再開する時にここに戻ってきたい
printf(&#34;Work done&#34;);
...
```

# GOTO
------
`goto` を使えば戻れる

```C
...
  fputc(c); // ここの処理でI/Oが入る
  // 再開する時にここに戻ってきたい
RESTART:
  printf(&#34;Work done&#34;);
...
```

# GOTOの問題
------------
こういうコードだとGOTOでは困る

```C
if ((c = fgetc(f)) != -1)
...
```


# GOTOの問題
------------
こんな区切り方をしたい

![cont in code image](/images/codecont.png)


# GOTOの問題
------------

* 式の途中に入れない
* 値を返せない
* I/Oが終わった「その後」が思ったより複雑

# &#34;継続&#34;という概念
-----------------

* continuation
* ここで言ってる「その後」に名前をつけたもの
* その後に行なわれる全ての処理のこと
* 全ての言語に存在する


# (限定)継続を値として扱える言語
------------------------------
値としての継続はちょっとリッチになったGOTO程度。

* Scheme
* OchaCaml
* SML/NJ
* (Ruby)
* etc.


## 正確には限定継続
------------------

* 細かい話だが継続と言うと処理Aとスケジューラ全てを含んでしまうので
今回欲しいのは処理Aの中に限定した限定継続
* 継続を値として扱えれば限定継続を[実装出来る]()ので今回はそこまで深く違いを気にする必要はない


## 正確には限定継続
------------------

![continuation image](/images/continuation.png)


## 正確には限定継続
------------------

![partcont image](/images/partcont.png)


# 限定継続を使った非同期処理の例
------------------------------
Cの例をSchemeに翻訳してみる

```scheme
(if (/= (read-char f) -1)
    ...)
```


# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```


# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme

  (if (/= 
                  (async-read-char f  )
          -1)
      ...)

```


# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(if (/= (read-char f) -1)
    ...)
```


# ここまでのまとめ
-----------------

* 非同期処理を行なう時に継続という概念が出てくる
* 継続を値として扱える言語もある
* 値としての継続は1引数関数として振る舞う
* そのような言語ではユーザレベルで非同期処理をサポート出来る


# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 先に言ったように全ての言語に継続が存在する
  * マシン語レベルでjump命令とほぼ同じ
* 言語処理系レベルで継続を取り出せば使える
* 要は組込み機能


# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 処理系にそこまで求めるのは酷
  * バグり易い
  * デバッグし辛い
* 処理系はもっと別のことに専念すべき
* 機能が追加修正される度に処理系をアップグレードしないといけない

実は継続を値として扱えない言語でもユーザレベルで継続を値として取り出す方法がある


## Continuation Passing Style

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CPS
-----

* 日本語にすると「継続渡し形式」
* 継続を関数として切り出して引数に渡す
  * 継続のために全ての関数の引数が1つ増える
* 継続渡し形式に変換することを「CPS変換という」
* CPS変換は機械的に出来る


# CPS変換
------------
先は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```

になった。

# CPS変換
------------
今回は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(async-read-char f
           (lambda (c) (if (/= c -1) ...)))
```

になる


# CPS変換
---------

* パっと見限定継続のコードの`lambda`の外側と内側が入れ替わる
* そんなり分かりやすくない


# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n)
  (if (&lt;= n 1)
      1
      (* n (fact (- n 1)))))
```


# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n c)
  (if (&lt;= n 1)
      (c 1)
      (fact (- n 1) (lambda (c) (* n c)))))
```

# CPS変換まとめ
--------------

* とりあえず機械的に変換できる
  + 実際、CPS変換をサポートする言語はいくつかある
    - Haskellのdo記法とか
* むしろ機械がやるべきで人間がやることではない


# コールバック地獄の正体

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも

```javascript
async_read_char(f, function(c){
    if(c === -1) {
        ...
    }
})

```


# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも

```javascript
function fact(n, callback) {
    if(n &lt;= 1)
        return callback(n);
    else
        return fact(n - 1, function(c){return n * c;})
}
```


# コールバック地獄の正体
-----------------------

* 人間が手でやることではない&#34;CPS変換&#34;を手でやらせた結果
* altJSは内部でCPS変換を行なうことで非同期プロミスなどを実現している
  + DeNAのJSXとか

# 非同期処理の実装まとめ
------------------------
下に行く程抽象度/汎用性が高い

* コールバックスタイル
  + JavaScript(&lt; ES6)とか
* 言語レベル組み込みサポート
  + C#とか
* 言語レベルCPS変換サポート
  + altJSとか
* 言語レベル(限定)継続サポート
  + Schemeとか
* ユーザーレベルでも限定継続(CPS変換)を実現出来るエレガントなマクロサポート
  * Lisp

※ネタです。マサカリ投げないで下さい。


# まとめ: なぜコールバック&#34;地獄&#34;なのか
------------------------------------

* そもそも難しいことをやろうとしている
* 難しいことをカバーするだけの言語の機能が足りてない

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>静的なメモリ管理の話。リージョン推論とλ計算からRustまで</title>
      <link>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</link>
      <pubDate>Tue, 21 Apr 2015 00:25:56 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 静的なメモリ管理の話。リージョン推論とλ計算からRustまで
----------------------
サイバーエージェント新卒エンジニア勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 大学では非情報系学科。趣味のプログラマ。
   + 非ガチ勢なので優しくして下さい&gt;&lt;
 * Lisp, Ruby, OCaml, Shell Scriptあたりを書きます


# メモリ管理の話
---------------
(一般的ではない用語)

* 弱い静的メモリ管理
* 強い動的メモリ管理
* (弱い動的メモリ管理)
* 強い静的メモリ管理


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 静的 = コンパイル時にメモリ管理が決定する

### 例

* C言語


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 利点

* 実行時は安定している

### 欠点
* バグる
* 面倒
* 危険


# メモリ管理の話
---------------
## 強い動的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* GCのある言語全般

# メモリ管理の話
---------------
## 強い動的メモリ管理
### 利点

* メモリ管理からの開放

### 欠点

* 動作が不安定 (cf [これがCassandra](http://www.slideshare.net/TakehiroTorigaki/cassandra-21191674))
* パフォーマンスの問題
* リアルタイム性の問題


# メモリ管理の話
---------------
## (弱い動的メモリ管理)
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* バグったGC
  + 普通はない
  + (参照カウント？)


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 静的 = コンパイル時にメモリ管理が決定する


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 利点

* メモリ管理からの開放
* 実行時は安定している
* リアルタイム
* パフォーマンスが出る

### 欠点

* 実現可能性は？


# 強い静的メモリ管理の話をしよう


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 強い静的メモリ管理の話をしよう
------------------------------

* まずは可能性の議論が必要
* 実現可能性
* 実用性


# 可能性の議論
-------------

* プログラミング言語の理論 ≒ λ計算
* そもそもλ計算はメモリのことを考慮してない
  + GCがあるかのように記述される


# 可能性の議論
-------------

* λ計算にメモリ管理まで含めて理論を立てたものは存在する（静的なメモリ管理）
  + リージョンというものをベースにしている [参考](http://www.elsman.com/mlkit/pdf/popl94.pdf)
* さらにリージョンを自動で推論する理論もある（強いメモリ管理）
  + リージョン推論という


# 軽くリージョンの話
-------------------

* 型と同じようにプログラム全体を伝わるメタデータ。
* データが保存される場所を指す。リージョンはいくつもある。
* リージョン推論でデータがどのリージョンに入るかが分かる
* さらにリージョンのサイズもある程度予想がつくので静的に管理出来る
* 関数などは引数のリージョンに対して多相になる「リージョン多相」などもある
* この辺は[Martin Elsmanの論文たち](http://www.elsman.com/mlkit/papers.html)を参考にして下さい
  + [A Brief Introduction to Regions](http://www.elsman.com/mlkit/pdf/ismm98.pdf)とか。



# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* 実現可能性
* 実用性

# 実現可能性

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 実現可能性
-----------

* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;Martin ElsmanによるSML処理系、[ML Kitに一部導入された](http://www.elsman.com/mlkit/pdf/pldi2002.pdf)（多分世界初）
  + 但し完全ではなく、GCと組み合わせてある
  + 動的型付き言語に無理矢理静的型を付けても完全には上手くいかないようなもの？
  + 多分リージョン推論を前提とした言語を設計する必要がある
* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;Cyclone というC likeな文法の言語が完全に[リージョン推論のみでメモリ管理を実現した](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf)


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* 実用性


# 実用性


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Rust言語
----------

* Mozillaが開発した言語
* 2008~
* Cycloneを参考にしたらしい。
* 活発に開発される
* 大きなプロジェクトに現行のレンダリングエンジン、Geckoを置き換えるべく開発された[Servo](https://github.com/servo/servo)がある
  + 既にC++製のGockoの3倍速い
  + 並列レンダリングすればさらに速い。


# Rust言語
----------

* リージョン推論(ライフタイム)でメモリを管理する
  - かなり賢くて、ヒープにアロケートする必要なけばスタックを使う。
* mallocとfreeは全てコンパイル時に自動で挿入される
* (多分)リージョン推論のみでメモリ管理するために所有権という概念がある。
  + 所有権自体は並列性の導入などにも有用だと思われる。
    -  競合状態の回避とか
* その他
  + 代数的データ型とパターンマッチ
  + トレイトベース(non-nominal)のジェネリクス

詳細は[公式ページ](http://www.rust-lang.org/)から


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* ✓ 実用性


# Rustのライフタイムと所有権
-------------------------


&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Cの例
-------

```c
{
    int *x = malloc(sizeof(int));

    // we can now do stuff with our handle x
    *x = 5;

    free(x);
}
```


# Rustに翻訳
------------

```rust
{
    let x = Box::new(5);
}
```


# 少しいじってみる
---------------

trivialに見える

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
---------------

printlnを追加してみる

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);

    println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
----------------

エラーになる。

```
error: use of moved value: `x`
   println!(&#34;{}&#34;, x);
                  ^
```


# 所有権
-------

`add_one` を呼んだ時点で所有権が `add_one` に移るので `println!` では使えない。

```rust
fn main() {
  let x = Box::new(5);

  add_one(x);

  println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 所有権
-------
新たに値を返してもらえば使える。

```rust
fn main() {
  let x = Box::new(5);

  let y = add_one(x);

  println!(&#34;{}&#34;, y);
}

fn add_one(mut num: Box&lt;i32&gt;) -&gt; Box&lt;i32&gt; {
  *num += 1;

  num
}
```


# 所有権の貸し借り
---------------

* さっきの例は面倒。
* `add_one` が `x` を奪ったのが問題。
* `x` を「借り」ることが出来る。


# 所有権の貸し借り
----------------

```rust
fn main() {
  let mut x = 5;

  add_one(&amp;mut x);

  println!(&#34;{}&#34;, x);
}

fn add_one(num: &amp;mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

先の `add_one` はライフタイム(リージョン)アノテーションを省略していた。  
省略せずに書くとこうなる。(リージョン多相)

```rust
fn add_one&lt;&#39;a&gt;(num: &amp;&#39;a mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

スコープの終わりでライフタイムが終わる。

```rust
fn main() {
  let y = &amp;5;     // -+ y goes into scope
                  //  |
  // stuff        //  |
                  //  |
}                 // -+ y goes out of scope
```


# LTの明示的宣言
--------------
こんな構造体を宣言したとする。 `x` はコンストラクタに渡された値のライフタイムを引き継ぐ。

```rust
struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}
```


# LTの明示的宣言
--------------
`f.x`のライフタイムが `y` のライフタイムに制限されるので
`y` より広いスコープにある `x` には代入出来ない。

```rust
fn main() {
  let x;                  // -+ x goes into scope
                          //  |
  {                       //  |
    let y = &amp;5;           // ---+ y goes into scope
    let f = Foo { x: y }; // ---+ f goes into scope
    x = &amp;f.x;             //  | | error here
  }                       // ---+ f and y go out of scope
                          //  |
  println!(&#34;{}&#34;, x);      //  |
}                         // -+ x goes out of scope
```


# まとめ
-------

* メモリ管理の性質についてまとめた
* 静的メモリ管理が出来れば
  + メモリ管理からの開放
  + 実行時は安定している
  + リアルタイム
  + パフォーマンスが出る
* 強い静的メモリ管理の手法としてリージョン推論がある
* Rust言語がリージョン推論を利用している。
* Rustをみんな使おう!


# 参考
* [ML Kit](http://www.elsman.com/mlkit/)
* [Rust](http://www.rust-lang.org/)
* [Allocators in Rust - Baby Steps](http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>caveman2、ningle…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト</title>
      <link>http://keens.github.io/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</link>
      <pubDate>Thu, 05 Mar 2015 13:18:44 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# caveman2、ningle、datafly…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト
----------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;ずっと俺のターン&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 問題
------
Common Lispは case

* Sensitive &lt;!--.element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;  
* Insensitive &lt;!--.element: class=&#34;fragment shrink&#34; data-fragment-index=&#34;1&#34; --&gt;

どっち?

# 問題
-------

あれ？

```lisp
(eql? &#39;CaseInsensitive &#39;caseinsensitive) ;=&gt; t
```


# 問題
-------

リーダがデフォルトで大文字にするだけ

```lisp
(eql? &#39;|CaseSensitive| &#39;|casesensitive|) ;=&gt; nil
```


# Caveman2
---------

```lisp
@route GET &#34;/hello&#34;
(defun say-hello (&amp;key (|name| &#34;Guest&#34;))
  (format nil &#34;Hello, ~A&#34; |name|))
```

# Ningle
--------

```lisp
(setf (ningle:route *app* &#34;/login&#34; :method :POST)
      #&#39;(lambda (params)
          (if (authorize (getf params :|username|)
                         (getf params :|password|))
            &#34;Authorized!&#34;
            &#34;Failed...Try again.&#34;)))
```

# 面倒…
----
デフォルトでそのままだたっらいいのに

# 魔法の`readtable-case`

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 魔法の`readtable-case`
-----------------------

```lisp
(setf (readtable-case *readtable*) :invert)
```
を使えばOK  
参考: [SBCLでclispとかallegroのmodern mode的なことをする - wasabizの日記](http://wasabiz.hatenablog.com/entry/20120929/1348889601)

# 例
----

```lisp
CL-USER&gt; :username
:USERNAME
CL-USER&gt; (setf (readtable-case *readtable*) :invert)
:invert
CL-USER&gt; :username
:username
```

# まとめ
--------
* `(setf (readtable-case *readtable*) :invert)`を使うと快適だよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>既存のテンプレートエンジンの問題点と再設計</title>
      <link>http://keens.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</link>
      <pubDate>Mon, 02 Mar 2015 23:36:03 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt;
.red {
color: red;
}
&lt;/style&gt;
# 既存のテンプレートエンジンの問題点と再設計、あるいはArrowsについて
-----------------------------------------------------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 野生のLisper
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

# Template Engines

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Existing Architeture
----------------------
0. (リクエスト)
1. アプリ
  0. 引数を計算
  1. テンプレートに引数を渡す
  2. レスポンスをレンダリング &lt;!--.element: class=&#34;fragment grow&#34;  --&gt;
4. レスポンスをサーバに渡す
5. (レスポンス)

# Rendering?
----------------------
* 結合した文字列はクライアントに返ったらその後はゴミ
 + GCへ負荷がかかる (後述)
* クライアントにとって1つの文字列である必要はない
* むしろ返せる部分だけ先に返した方が得（後述）

# GC Pressure (SBCL)
-----------------
* 世代別Copy GC
* 結合した文字列は比較的大きい
* `alloc_space`に入らない大きさならアロケートが遅い
* GCを頻繁に起動してしまう
* 16KBを越えると特別扱いされて遅い/メモリを喰う
* LispのWebアプリはレスポンスタイムの分散が大きい（要出展）

参考: [SBCL GENCGC @ x86 Linux](http://cl-www.msi.co.jp/reports/sbcl-gc-memo.html)

# Split Response
---------------
例えば、こんなの

&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot; xml:lang=&amp;quot;en&amp;quot; lang=&amp;quot;en-us&amp;quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://localhost:1313//reveal.js/lib/css/xcode.css&amp;quot;&amp;gt;
        &amp;lt;script src=&amp;quot;//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
        ....
        &amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body class=&amp;quot;li-body&amp;quot;&amp;gt;
    &amp;lt;header&amp;gt;{{ header }}&amp;lt;/header&amp;gt;
    {{ body }}
    ...
&lt;/code&gt;&lt;/pre&gt;

# Split Response
---------------
1. `{{ header }}`の前に先頭から`&lt;header&gt;`までを返す
2. `{{ header }}`を返す
3. `&lt;/header&gt;`を返す
4. `{{ body }}`を返す

...


# Pros of Split Response
------------------------
* `header`を計算してる間にクライアントにhead部分が渡る
  + 先に`&lt;link&gt;`や`&lt;script&gt;`を要求出来る
  + サーバ側のスループットやレスポンスタイムは変わらないが
    クライアントのレンダリング完了までの時間は大幅に短縮出来る
* 文字列を結合する必要がない
* 定数部分については長さが判ってるので最適化し易い

# How TEs Work 
---------------------------
## Compilation
1. テンプレート文字列
 + パーサ &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
 + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数

# How TEs Work 
---------------------------
## Rendering
1. レンダリング関数
 + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列

# Misc Problems
---------------
* サーバに渡すのは文字列なのにソケットに書き込む時はオクテット？
  + 文字列で返す？オクテットで返す？（デバッグがー）
  + オクテットの変換はいつ？
* ストリームが遅い？
  + POSIX APIが使える&#34;なら&#34;fdの方が速い？
* ユーザが用意したバッファに書き出したい？
* テンプレートに渡す引数が定数文字列なら畳み込める筈？
* リクエストの度にテンプレートパースするのは筋悪だけど開発中は毎回コンパイルするのは面倒？

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;

# Arrows

Template flies like an arrow

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Arrows
--------
* [KeenS/arrows](https://github.com/KeenS/arrows)
* 現在開発中のテンプレートエンジン
* 複数のテンプレートが選べる（予定）
* 複数のバックエンドが選べる
* バックエンドに依ってはnon-consing

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Compilation
1. テンプレート文字列&lt;span class=&#34;red&#34;&gt; + 定数引数&lt;/span&gt;
  + パーサ&lt;span class=&#34;red&#34;&gt;(default, cl-emd互換...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
  + &lt;span class=&#34;red&#34;&gt;最適化(const folding, concat, convert...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
  + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数&lt;span class=&#34;red&#34;&gt;(string, octets, stream, fast-io ...)&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Rendering
1. レンダリング関数
  + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列&lt;span class=&#34;red&#34;&gt;、オクテット列、ストリーム書き出し、fast-io…&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How compiled
--------------

```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を

```lisp
(compile-template-string :xxx
  &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34; ())
```
とコンパイル

# Stream backend
----------------
&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* ほとんどアロケートしない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Octet backend
----------------

```lisp
(lambda (&amp;key name)
  (with-fast-output (buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;&lt;h1&gt;Hi &#34;)
       buffer)
    (fast-write-sequence
      (string-to-octets
        (encode-for-tt (princ-to-string name)))
                       buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;!&lt;/h1&gt;&#34;)
      buffer)))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------

```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を

```lisp
(compile-template-string :stream
   &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34;
   &#39;(:known-args (:name &#34;&lt;κeen&gt;&#34;)))
```
とコンパイル

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## variable folding

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string (encode-for-tt &#34;&lt;κeen&gt;&#34;) stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 既知の引数は畳み込む
* 文字列なら`princ-to-string`しない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## const folding

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string &#34;&amp;lt;κeen&amp;gt;&#34; stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 定数のエスケープはコンパイル時に済ませる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## append sequence

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &amp;lt;κeen&amp;gt;!&lt;/h1&gt;&#34;
                stream))
```
* 複数シーケンスの書き出しは1つにまとめる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
* 引数計算の遅延
* 引数計算の並列化
* 非同期化
* HTML compction

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の遅延
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は必要になったら値を計算する(Promise パターン)

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の並列化
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は並列に計算して必要になったら値を要求する(Futureパターン)

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 非同期化
* 単純にwriteを非同期にする
* 他にFutureもブロックするので非同期Futureを使う

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## HTML compction

```html
&lt;ol&gt;
  &lt;li&gt; item 1 &lt;/li&gt;
  &lt;li&gt; item 2 &lt;/li&gt;
  &lt;li&gt; item 3 &lt;/li&gt;
&lt;/ol&gt;

```
を

```html
&lt;ol&gt;&lt;li&gt;item 1&lt;/li&gt;&lt;li&gt;item 2&lt;/li&gt;&lt;li&gt;item 3&lt;/li&gt;&lt;/ol&gt;

```
* DOM構造が変わってしまう


&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# TODOs
-------
* 設計上複数シンタックスをサポート可能だがまだしてない
* 既存のテンプレートエンジンとの比較ベンチマーク
* 高速化
* 多機能化
  + テンプレート
  + 最適化
  + バックエンド
* clackとの連携
  + clackのAPIはメモリアロケーションが多めに必要になる

# Summary
---------
* 既存のテンプレートエンジンは非効率
  + メモリを無駄遣いしていた
  + ユーザーのことを考えてなかった
* 新しいテンプレートエンジンを設計した
  + メモリアロケーションをあまりしない
  + ユーザー側の速度まで考慮した
  + 柔軟
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Semantic S式</title>
      <link>http://keens.github.io/slide/semantic-sshi/</link>
      <pubDate>Thu, 27 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/slide/semantic-sshi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Semantic S式
---
2014-11-27  
κeen(@blackenedgold)

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# About Me
----------
![κeenのアイコン](/images/icon.png)

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

# Semantic Web とは

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# [Semantic Web](http://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A6%E3%82%A7%E3%83%96)
----------------

* W3C のティム・バーナーズ＝リーが提唱
* 文章の見た目を記述するんじゃなくて構造を記述しよう
* そうすると機械がクローリングするの楽になるよね


# Semantic S式とは

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Semantic S式
--------------

* Shibuya.lispのκeenが提唱 (昨日思い付いた)
* S式の見た目じゃなくて構造で括弧をつけよう
* そうするとコーディングが楽になるよね


# 良いところ
------------

1. 意味が分かり易い
2. パースし易い
3. 編集が楽になる
4. 壊れにくい


# 1. 意味が分かり易い

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 1. 意味が分かり易い
--------------------
## 例1

* Clojure

  ```clojure
  (let [a 1
        b 2]
    ...)
  ```

* Common Lisp

  ```lisp
  (let ((a 1)
        (b 2))
    ....)
  ```
どっちが分かり易い？

# 1. 意味が分かり易い
--------------------
## 例1
（日本語にしてみる（イメージ））

* Clojure  
  aを1bを2とする
* Common Lisp
  &lt;table border=&#34;1&#34;&gt;&lt;tr&gt;&lt;td&gt;`a`&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;`b`&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  とする


# 1. 意味が分かり易い
--------------------
## 例2
何をしてる？

```lisp
(destructuring-bind (a b)
    (some-function)
  ...)
```

# 1. 意味が分かり易い
--------------------
## 例2
何をしてる？

```lisp
(destructuring-bind ((a b)
    (some-function))
  ...)
```

# 1. 意味が分かり易い
--------------------
## 例3
これの返り値は？

```lisp
(getf &#39;(:hoge :foo :huga :baz :piyo :pon :chun) :pon)
```

# 1. 意味が分かり易い
--------------------
## 例3
これの返り値は？

```lisp
(assoc :pon &#39;((:hoge :foo) (:huga :baz) (:piyo :pon) (:chun)))
```

# 2. パースし易い

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 2. パースし易い
----------------
## 例

* Clojure

  ```clojure
  (let [a 1
        b 2]
    ...)
  ```

* Common Lisp

  ```lisp
  (let ((a 1)
        (b 2))
    ....)
  ```
どっちが実装し易い？

# 2. パースし易い
----------------

* Common Lispの方は意味で分割してある
* 括弧は無くてもパースは出来る
* 機械にパースし易い≒人間にパースし易い


# 3. 編集が楽になる

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 3. 編集が楽になる
------------------
## 前提
* エディタに文/式/トークン(Lispの場合は全てS式)単位の編集機能がある
   + S式単位でカーソル移動
   + S式単位の削除/カット
   + S式単位のスワップ
   + etc....

# 3. 編集が楽になる
------------------
## 例（偶によくある）
この`c`の束縛を上のletに持っていきたいときどうする？

```lisp
(let ((a 1)
      (b 2))
  ....
  (let ((c 3)
        (d 4))
    ...))
```

# 3. 編集が楽になる
------------------
## 例（偶によくある）

* 意味で括弧をつけていれば1カット移動1ペースト
* Clojure方式だと2カット移動1ペースト
* `c`だけじゃなくて`d`も、と考えると…

# 4. 壊れにくい

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 4. 壊れにくい
---------------
## 例
ageの計算が壊れているとする

```lisp
(:name &#34;κeen&#34;
 :age  (year-of-time-interval (date- (today) (date 1992 5 17)))
 :place &#34;Shibuya&#34;)
```


# 4. 壊れにくい
---------------
## 例
コメントアウトしてみる（壊れた）

```lisp
(:name &#34;κeen&#34;
 :age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 :place &#34;Shibuya&#34;)
```

# 4. 壊れにくい
---------------
## 例
ageの計算が壊れているとする

```lisp
((:name &#34;κeen&#34;)
 (:age  (year-of-time-interval (date- (today) (date 1992 5 17))))
 (:place &#34;Shibuya&#34;))
```

# 4. 壊れにくい
---------------
## 例
(エディタサポートあり)

コメントアウトしてみる（壊れない）

```lisp
((:name &#34;κeen&#34;)
 (:age  ;(year-of-time-interval (date- (today) (date 1992 5 17)))
 )
 (:place &#34;Shibuya&#34;))
```

# ここまでのまとめ
-----------------
* 構造が文脈に依存していると
  + 人間に分りづらい
  + プログラムに分りづらい
  + エディタに分りづらい
  + 壊れやすい

# Q. When Semantic?
------------------------------
## A. 言語を設計するとき &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;

* つまりマクロを書くとき &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;

# Q. When Semantic?
------------------------------
## A. 言語を設計するとき

* マクロを書くときそれなりのDSLを設計する
* プログラム上は必須ではない括弧もあった方が良いときもある


# まとめ
--------

* 括弧が少ない方が書き易いとは限らない
  + 「書く」だけなら速くてもwrite onlyになってしまうかも&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
* プログラムの意味を考えながら括弧つけよう
  + Lisperはどうせ括弧は見えない&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;

&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ


&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>claspを少し触ってみた</title>
      <link>http://keens.github.io/slide/clasp/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/slide/clasp/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# claspを少し触ってみた
----------------------
Lisp Meet Up presented by Shibuya.lisp #21  
2014-10-29  
κeen(@blackenedgold)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:relative;right 0;&#34; --&gt;

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます


# clasp
-------

* Github: [drmeister/clasp](https://github.com/drmeister/clasp)
* 2014-09-18に0.1リリース(現在0.11プレビューが出ている)
* 今は0.11プレビューが出ている
* ANSI Common Lisp準拠を目指す(現在80 ~90%)
* ECLからのフォーク
* LLVMベースのJIT([MCJIT](http://llvm.org/docs/MCJITDesignAndImplementation.html))搭載
* C++とLispで書かれている
* C++との連携を意識

Note:
C++との連携の部分を強調。今回は0.11プレビューでの話


# メモリ管理
------------------

* Memory Pool Systemと Boehm GCから選べる
* ビルドするときにどっちかを選ぶ


# メモリ管理
------------------
## [Boehm GC](http://www.hboehm.info/gc/)

* Mark &amp;amp; Sweepのライブラリ
* 枯れた有名なライブラリ
* Lisp有名どころではGaucheが使う
* RedHat系だとこれを使ってないとrpmリジェクトされやすいらしい(?)

Note:
他にはMozilla, W3M, GNU GCJ, GNU Obj-Cなどなど

# メモリ管理
------------------
## [Memory Pool System](http://www.ravenbrook.com/project/mps/)

* 複数のGCアルゴリズムを組み合わせて使えるらしい
* since 1994
* あまり分からないです&amp;gt;&amp;lt;


# 依存ライブラリ
----------------------

* LLVM **3.6**
* LLVM/clang **3.5** compiler
* Boost build v2
* boost libraries ver 1.55
* Boehm 7.2
* gmp-6.0.0
* expat-2.0.1
* zlib-1.2.8
* readline-6.2


&lt;span style=&#34;font-size:600%&#34;&gt;無理&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# externals-clasp
--------------------------

* Github: [drmeister/externals-clasp](https://github.com/drmeister/externals-clasp)
* 依存ライブラリを揃えるのが難しいとの声から作られた
* 依存ライブラリを全てビルド&lt;!-- .element: class=&#34;fragment grow&#34; --&gt;


&lt;span style=&#34;font-size:300%&#34;&gt;＼LLVMをビルド／&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;＼Boostをビルド／&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:200%&#34;&gt;ビルド時間はお察しです&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 本体のビルド
------------------
Twitter実況をどうぞ↓↓

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangがメモリ6GB以上食い続けてて怖い。何やってんの。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526417151486205952&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangの起動時間1時間超えてますよ…&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526418636735401984&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;HDDプチプチ言ってるし今にも壊れそう&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526420001587068929&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/nobkz&#34;&gt;@nobkz&lt;/a&gt; claspのコンパイル中です。&amp;#10;clangなのにIOネックという謎の状態です。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526420473232367616&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangの消費メモリ7GB超えた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526423982992420864&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;ビルドは自己責任で&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 使ってみる
------------
## 起動オプション

```
/usr/local/clasp/bin/clasp_mps_o --help
clasp options
-I/--ignore-image    - Don&#39;t load the boot image/start with init.lsp
-i/--image file      - Use the file as the boot image
-N/--non-interactive - Suppress all repls
-v/--version         - Print version
-s/--verbose         - Print more info while booting
-f/--feature feature - Add the feature to *features*
-e/--eval {form}     - Evaluate a form
-l/--load {file}     - LOAD the file
-r/--norc            - Don&#39;t load the ~/.clasprc file
-n/--noinit          - Don&#39;t load the init.lsp (very minimal environment)
-s/--seed #          - Seed the random number generator
-- {ARGS}*           - Trailing are added to core:*command-line-arguments*
```

# 使ってみる
------------
## ASDF

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ASDFの処理系依存の部分(`#+`)の問題
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ECLと見做されるけどECLのコードは動かない

# 使ってみる
------------
## cl-ppcre

* [手動ロードスクリプト](https://gist.github.com/KeenS/4e25cb6e424ebe4e7a4a)
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;`schar`がない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ANSI Common Lispにあるのに…

# 使ってみる
------------
## C++との連携

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;ドキュメントがない
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;サンプルコードもない
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;遂行不能

# 使ってみる
------------
## LLVMの呼び出し
* [clasp/src/llvmo/demo.lisp](https://github.com/drmeister/clasp/blob/master/src/llvmo/demo.lsp)
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない

# 使ってみる
------------
&lt;style type=&#34;text/css&#34;&gt;
.graph{
  background:#aaa;
  border-radius:5px;
  white-space: nowrap;
  text-align: left;
}
td {
  white-space: nowrap;
}
&lt;/style&gt;

処理系              |  `(time (fib 29))`
--------------------|-----------------------------------------------------------------
clasp-0.1(boehm)    | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(264.3px * 3);&#34; data-fragment-index=&#34;1&#34;&gt;26.43s&lt;/div&gt;
clasp-0.1(mps)      | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(172.8px * 3);&#34; data-fragment-index=&#34;1&#34;&gt;17.28s&lt;/div&gt;
clasp-0.11(boehm)   | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(213.2px * 3);&#34; data-fragment-index=&#34;2&#34;&gt;21.32s&lt;/div&gt;
clasp-0.11(mps)     | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(187.9px * 3);&#34; data-fragment-index=&#34;2&#34;&gt;18.79s&lt;/div&gt;
ECL-13.5.1          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 16.0px * 3);&#34;&gt;1.603s&lt;/div&gt;
ECL-13.5.1(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  1.9px * 3);&#34;&gt;0.192s&lt;/div&gt;
ABCL-1.3.1          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 32.9px * 3);&#34;&gt;3.292s&lt;/div&gt;
ABCL-1.3.1(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  2.4px * 3);&#34;&gt;0.241s&lt;/div&gt;


# 使ってみる
------------

処理系              |  `(time (fib 29))`
--------------------|-----------------------------------------------------------------
CLISP-2.49          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 38.4px * 3);&#34;&gt;3.847s&lt;/div&gt;
CLISP-2.49(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  7.1px * 3);&#34;&gt;0.7146s&lt;/div&gt;
ccl-1.10            | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.4px * 3);&#34;&gt;0.04033s&lt;/div&gt;
sbcl-1.2.5          | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.6px * 3);&#34;&gt;0.06469s&lt;/div&gt;
alisp-9.0           | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  230px * 3);&#34;&gt;23.09s&lt;/div&gt;
alisp-9.0(compile)  | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.6px * 3);&#34;&gt;0.06194s&lt;/div&gt;

&lt;span style=&#34;font-size:200%&#34;&gt;LLVM/JITなのになぜ遅い？&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# LLVM/JITで遅い？
-------------------------

* LLVMって速いんじゃ？
* JIT搭載した○○が速いって聞いたよ
  + JVM
  + lua-jit
  + Rubinius
  + pypy


# 言葉の罠: LLVM
--------------------

* 遅いコードはどんなに頑張っても遅い
* ECLのバックエンドにClang(=LLVM)を使ってもSBCLに勝てないのと同じ


# 言葉の罠: JIT搭載
--------------------

* JIT(実行時コンパイル)の意味は広い
* 実行時にネイティブコードを吐けばJITと言える
* claspは実行直前にコンパイルするだけ
* 多くの速いJIT処理系はTracing JITを使う
  + またの名を適応的コンパイル
  + 実行時の情報に基いて実行中に最適化する
  + `(declare ...)` を自動生成してる的な


# Tracing JITへの道
--------------------

* LLVMのJITは実行直前にコンパイルするだけ
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;Tracing JITのバックエンドには使える
* 実行時最適化には最適化用のコードが必要
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;Common Lispでは`(declare ...)`用のコードを使い回せる
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;案外近い


# 結論
------

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;遅い
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;時期尚早
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;今後機能や速度改善があれば使えるようになるかも


&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>