<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="構文解析にまつわる小話たち | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="PEGと構文解析に関するアレコレの勉強会 Vol.1 あるいは構文解析手法勉強会 での発表資料。PEG以外の構文解析にまつわる話。 " />

        <title>構文解析にまつわる小話たち | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href="//KeenS.github.io/reveal.js/css/reveal.css">
        <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css'>
        <link rel="stylesheet" href="//KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="//KeenS.github.io/css/liquorice.css" />
        <link rel="stylesheet" href="//KeenS.github.io/highlight.js/styles/agate.css">
        <link rel="stylesheet" href="//KeenS.github.io/css/cleanveal.css" type="text/css" />
        <link rel="apple-touch-icon" sizes="180x180" href="//KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="//KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="//KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <link rel="apple-touch-icon-precomposed" href="//KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="alternate" href="" type="application/rss+xml" title="κeenのHappy Hacκing Blog" />
        
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script>
         if( window.location.search.match( /print-pdf/gi ) ) {
             var link = document.createElement( 'link' );
             link.rel = 'stylesheet';
             link.type = 'text/css';
             link.href = '\/\/KeenS.github.io\/reveal.js/css/print/pdf.css';
             document.getElementsByTagName( 'head' )[0].appendChild( link );
         }
        </script>
        
    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="//KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="//KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="//KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






<article id="article-container" class="li-article" style="height: 100%">
    <header id="article-header" class="li-article-header" style="position:fixed;z-index:10;">
        <h1 class="li-article-title">構文解析にまつわる小話たち</h1>
        <div class="li-article-meta">
    <time class="li-article-date">2015-08-08</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="//KeenS.github.io/categories/%e6%a7%8b%e6%96%87%e8%a7%a3%e6%9e%90">構文解析</a>
        </li>
    
</ul>

</div>

    </header>
    <div class="reveal">
        <div class="slides">
            <!-- raw HTML omitted -->
<h1 id="heading">構文解析にまつわる小話たち</h1>
<hr>
<p><a href="https://twitter.com/search?q=%23peg_study&amp;src=typd&amp;vertical=default&amp;f=tweets">#peg_study</a></p>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="about-me">About Me</h1>
<hr>
<p><img src="//KeenS.github.io/images/icon.png" alt="κeenのアイコン"> <!-- raw HTML omitted --></p>
<ul>
<li>κeen</li>
<li><a href="https://twitter.com/blackenedgold">@blackenedgold</a></li>
<li>Github: <a href="https://github.com/KeenS">KeenS</a></li>
<li>サイバエージェントの新卒エンジニア</li>
<li>Lisp, ML, Shell Scriptあたりを書きます</li>
</ul>
<p>===</p>
<h1 id="heading1">ウォームアップ</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading2">構文解析はバッドノウハウ</h1>
<hr>
<ul>
<li>プログラム言語を使っているなら既にパーサはある
<ul>
<li>文法も定義されてる</li>
</ul>
</li>
<li>目の前のパーサを使え
<ul>
<li>パーサAPIがある言語もある(Lispとか)</li>
</ul>
</li>
<li>そうでなくても内部DSLを考えろ
<ul>
<li>内部DSLで解決出来ないときだけ構文解析
===</li>
</ul>
</li>
</ul>
<h1 id="ast">本質はAST</h1>
<hr>
<ul>
<li>結局はASTになればどんな文法でも同じ</li>
<li>文法はただの外皮、欲しいのはAST</li>
<li>シンタックスシュガーは飾り
<ul>
<li>DRY出来るなら別</li>
</ul>
</li>
<li>S式を使え
<ul>
<li>ASTをそのまま書き下せる</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="ast-first">AST First</h1>
<hr>
<ul>
<li>最初にASTを考える。そして文法を考える</li>
<li>何が欲しいのかイメージし易くなる</li>
<li>構文解析はAST生成の自動化。普段してないことを自動化するのは愚か。</li>
<li>早めに間違いに気付ける
<ul>
<li><code>+</code>は二項演算子。じゃあ <code>&amp;&amp;</code> は？ <code>=</code> は？</li>
</ul>
</li>
</ul>
<p>Note: Lispだと+は関数、andはマクロ、setqはスペシャルフォーム</p>
<p>===</p>
<h1 id="heading3">構文解析の流れ</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading4">構文解析の流れ</h1>
<hr>
<ol>
<li>Lexer generaterからlexerを作る</li>
</ol>
<ul>
<li>Lexとか</li>
</ul>
<ol start="2">
<li>Parser generaterからparserを作る</li>
</ol>
<ul>
<li>yaccとか</li>
<li>BNFという記法</li>
</ul>
<ol start="3">
<li>ソースファイルをlexerで処理してトークン化する</li>
<li>トークン列をparserで処理してASTを作る</li>
</ol>
<p>===</p>
<pre><code>         [Lexer]        [parser]
[Source]-------&gt;[Tokens]------&gt;[AST]
</code></pre><!-- raw HTML omitted -->
<p>===</p>
<h1 id="lexerparser">LexerとParserを分ける意味</h1>
<hr>
<ul>
<li>(上向き構文解析だと分けないとつらい)</li>
<li>役割の分担
<ul>
<li>困難は分割せよ</li>
</ul>
</li>
<li>文字列をシンボル化して比較が高速に</li>
<li>思考のフレームワークとして</li>
</ul>
<p>===</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading5">正規表現の使いどころ</h1>
<hr>
<ul>
<li>高速な実装がある</li>
<li>部品化しにくい</li>
<li>括弧の対応とか入れ子構造(<code>if .. then .. else</code>とか)は扱えない
<ul>
<li>perlの正規表現は厳密には正規表現ではない</li>
</ul>
</li>
<li>構文解析には向かない
<ul>
<li>「マッチ」は出来ても「抜き出し」は面倒</li>
</ul>
</li>
<li>Lexerには向いてる
<ul>
<li>トークン自体末端の部品なので部品化する必要がない
===</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading6">構文クラス</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading7">構文クラス</h1>
<hr>
<ul>
<li>学術的だが知っておくと幸せになれる</li>
<li>文脈自由文法を解析するためのものを話す
<ul>
<li>多くのプログラム言語は文脈自由文法</li>
<li>正規言語 ⊂ 文脈自由文法</li>
</ul>
</li>
<li>大きく分けると上向き構文解析と下向き構文解析</li>
<li>詳しくは<a href="http://www.amazon.co.jp/%e3%82%b3%e3%83%b3%e3%83%91%e3%82%a4%e3%83%a9%e2%80%95%e5%8e%9f%e7%90%86%e3%83%bb%e6%8a%80%e6%b3%95%e3%83%bb%e3%83%84%e3%83%bc%e3%83%ab-information-computing-a-v-%e3%82%a8%e3%82%a4%e3%83%9b/dp/478191229x">ドラゴンブック</a>参照</li>
</ul>
<p>===</p>
<h1 id="ll1">LL(1)</h1>
<hr>
<ul>
<li>下向き
<ul>
<li>再帰降下パーサ</li>
</ul>
</li>
<li>定義した言語しか厳密に受け取らない</li>
<li>線形線形時間でパース可能</li>
<li>手書きに向く</li>
<li>パーサーコンビネータとかも</li>
</ul>
<p>===</p>
<h1 id="lr1">LR(1)</h1>
<hr>
<ul>
<li>上向き
<ul>
<li>トークンをくっつけて構文要素に、構文要素をくっつけてさらに上の構文要素に…</li>
</ul>
</li>
<li>LL(n)⊂LR(n)</li>
<li>LRそのものの解析は難しくて、いくつかサブクラスがある
<ul>
<li>単純LR (SLR):  貧弱</li>
<li>先読みLR (LALR): パーサジェネレータでよく使われる</li>
<li>正準LR: 計算コストが高い。メモリ喰う</li>
</ul>
</li>
<li>事前計算のコスト（面倒くささ）が高い
<ul>
<li>パーサジェネレータ</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="lr">LRパーサジェネレータ</h1>
<hr>
<ul>
<li>基本はBNF(Backus-Naur-Form)</li>
<li>いくつか方式がある
<ul>
<li>演算子順位解析も合わせる
<ul>
<li>EmacsのSMIEとか</li>
</ul>
</li>
<li>BNFだけでやる
<ul>
<li>別の言語も受理する可能性がある ドラゴンブック 上 p. 247</li>
<li>普通は問題にならない</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="lr2">LRの限界とか</h1>
<hr>
<ul>
<li><code>-</code>の単項演算子と二項演算子の衝突
<ol>
<li>SMLみたいに諦める(単項の<code>-</code>を<code>~</code>で表す)</li>
<li>Lexerで区別する</li>
</ol>
</li>
<li>左再帰で無限ループ
<ul>
<li>手動でどうにか出来る</li>
<li>自動でどうにかしてくれるジェネレータもある</li>
</ul>
</li>
<li>BNFの書き方によっては文法があいまいになる
<ul>
<li><code>if .. then .. if .. then .. else ..</code> とか</li>
<li>自動ではどうにもできないので気をつけるしかない</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="bnf">BNFとパーサージェネレータの良さ</h1>
<hr>
<ul>
<li>BNFは言語を定義する。
<ul>
<li>言語仕様にも使われる</li>
</ul>
</li>
<li>要は「仕様からプログラムを生成する」</li>
<li>宣言的</li>
</ul>
<p>===</p>
<h1 id="heading8">複数文法のサポートとグローバル変数の衝突</h1>
<hr>
<ul>
<li>複数の文法をサポートしたい時がある
<ul>
<li>独自記法と互換記法とか</li>
</ul>
</li>
<li>雑なパーサジェネレータ/コンビネータを使っているとグローバル変数が衝突する
<ul>
<li>パーサライブラリの作者は配慮して下さい。</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading9">言語仕様の配慮</h1>
<hr>
<ul>
<li>LispはLL</li>
<li>Java 1.0はLALR
<ul>
<li>今はLALRではないらしい</li>
</ul>
</li>
<li>PrologはLALRだった気がする</li>
</ul>
<p>===</p>
<h1 id="heading10">非文脈自由文法</h1>
<hr>
<ul>
<li>文脈を持つ（雑）</li>
<li>ひねりなくパーサージェネレータ使っただけじゃ解析出来ない言語のこと。</li>
</ul>
<p>===</p>
<h2 id="seds">sedのs///</h2>
<hr>
<ul>
<li>実は <code>s|||</code>のように区切文字は何でもいい
<ul>
<li>パスネームの置換に便利</li>
</ul>
</li>
<li>対応関係が文脈で変わるので非文脈自由</li>
</ul>
<p>===</p>
<h2 id="markdown">Markdown</h2>
<hr>
<ul>
<li>元々のperlの実装は正規表現
<ul>
<li>再帰を使っているので正規言語ではなく文脈自由文法</li>
</ul>
</li>
<li>GFMなどのTable記法はカラム数という文脈があるので非文脈自由</li>
<li>Table記法をサポートする時は覚悟を持って。</li>
</ul>
<p>===</p>
<h1 id="heading11">その他</h1>
<hr>
<ul>
<li>関数の仮引数の数と実引数の数の一致</li>
<li>変数の使用の前に変数宣言</li>
<li>要は構文解析で出来ることには限界がある。</li>
</ul>
<p>===</p>
<h1 id="heading12">パーサの実際</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading13">速度と手軽さ</h1>
<hr>
<ul>
<li>外部DSLやコンフィグファイルだとパーサの速度は必要ない
<ul>
<li>メインループで使われないので起動時間にしか影響しない。</li>
<li>むしろ手軽に作れた方がいい</li>
</ul>
</li>
<li>HTTPだとかメインループで使うものはどうやってでも速くしたい
<ul>
<li>労力は惜しまない
===</li>
</ul>
</li>
</ul>
<h1 id="heading14">手書きとジェネレータとコンビネータ</h1>
<hr>
<ul>
<li>速度が必要ならジェネレータ</li>
<li>LLでないならジェネレータ</li>
<li>手軽さが欲しいならコンビネータ</li>
<li>色々手を加えたいなら手書き…かも</li>
</ul>
<p>===</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading15">ジェネレータの扱いにくさ</h1>
<hr>
<ul>
<li>あんまり人気ない気がする</li>
<li>2回も前処理必要なのダサいよね</li>
<li>新たな文法覚える必要がある</li>
<li>そもそも作るのにもコストが高い
<ul>
<li>言語の文法に合わせたプリンタ</li>
<li>拡張性持たせると厄介</li>
</ul>
</li>
<li>かといって正規表現はやめましょうね
===</li>
</ul>
<h1 id="dsl">DSLパーサジェネレータ</h1>
<hr>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="dsl1">DSLパーサジェネレータ</h1>
<hr>
<ul>
<li>あったらそれなりに人気出そう</li>
<li>メタプログラミングが出来る必要がある</li>
<li>Common Lisp
<ul>
<li>作者自身作ってる途中でジェネレータとコンビネータを勘違いする</li>
<li>ドキュメントでジェネレータといってるのに実際はコンビネータだったりする</li>
</ul>
</li>
<li>D
<ul>
<li>なんか作ってる人いるらしい</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading16">複雑性と分かりやすさ</h1>
<hr>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading17">複雑性と分かりやすさ</h1>
<hr>
<ul>
<li>パーサが複雑な文法に対応出来ても人間が追い付かない</li>
<li>周辺のサポートも必要になるのでやっぱりシンプルな方が良い。
<ul>
<li>LRよりLL</li>
<li>S式とかシンプルの極み</li>
<li><a href="http://www.slideshare.net/sohta/clojurelisp?ref=http://athos.hatenablog.com/entry/2015/07/29/222535">Clojureシンタックスハイライター開発から考えるこれからのlispに必要なもの</a></li>
</ul>
</li>
<li>「出来る」と「した方がいい」は別の話</li>
</ul>
<p>===</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading18">ソースロケーション保持法</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading19">ソースロケーション保持法</h1>
<hr>
<ul>
<li>エラーメッセージを出すためにはソースロケーションを保持する必要がある</li>
<li>flymakeの情報: ファイル名、開始行/列 終了行/列 エラーメッセージ
<ul>
<li>最悪これがあればどうにかなる</li>
<li>「分かりやすい」メッセージはツールに任せる</li>
</ul>
</li>
<li>字句解析だけでなく意味解析、さらにはつまるところコンパイルが終わるまで保存する必要がある
<ul>
<li>トークンやASTにメンバが増える</li>
<li>オブジェクト指向のカプセル化って素晴らしい</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="1-">1. インクルード</h1>
<hr>
<ul>
<li>トークンのデータに入れてしまうパターン</li>
<li><code>datatype token = Plus of int * int | Symbol of int * int * string</code> &hellip;</li>
<li>OOPなら自然だが函数型だとパターンマッチがつらくなる</li>
</ul>
<p>===</p>
<h1 id="2-">2. ラップ</h1>
<hr>
<ul>
<li>ロケーションのレコードでトークンをラップする</li>
<li><code>{start:int, end: int, token: token}</code></li>
<li>パターンマッチは少し楽になる
<ul>
<li>多相レコードがないとそもそもレコードつらいけどな！！</li>
</ul>
</li>
<li>MLtonがやってるらしい</li>
</ul>
<p>===</p>
<h1 id="3-">3. テーブル</h1>
<hr>
<ul>
<li>ロケーションテーブルを持って、トークンにはテーブルへのキーだけ持たせる</li>
<li>トークンが軽くなるので速そう</li>
<li>でも面倒そう</li>
</ul>
<p>===</p>
<h1 id="heading20">エラー処理</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading21">エラーメッセージ</h1>
<hr>
<ul>
<li>一応ロケーションがとれればエラー箇所は出せる。</li>
<li>メッセージの親切さはツールとヒューリスティックと根気</li>
<li>clangとか頑張ってる</li>
</ul>
<pre><code>ERROR: expected tEnd before '&lt;EOF&gt;'
each do {}
          ^
</code></pre><p>===</p>
<h1 id="heading22">エラー回復</h1>
<hr>
<ul>
<li>シンタックスハイライターは壊れた文法も解析しないといけない</li>
<li>1回のコンパイルでできるだけ多くのエラーメッセージを出したい</li>
<li>シンタックスエラーから回復したい</li>
</ul>
<p>===</p>
<h1 id="c">Cの易しさ</h1>
<hr>
<ul>
<li>エラーがあってもセミコロンまで読み飛ばせば回復出来る
<ul>
<li>CやJavaは結構コンパイラが教えてくれる</li>
</ul>
</li>
<li>そういう言語設計も大事</li>
</ul>
<p>===</p>
<h1 id="heading23">拡張方法</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading24">リードマクロ</h1>
<hr>
<ul>
<li>トークンレベルの拡張</li>
<li>特定の「文字」がきた時にユーザ定義関数を使ってパースする</li>
<li>リテラルをユーザが定義することが出来る
<ul>
<li>正規表現リテラルとか</li>
<li><a href="http://weitz.de/cl-interpol/">Common Lispの正規表現</a></li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading25">マクロ</h1>
<hr>
<ul>
<li>ASTレベルの拡張</li>
<li>LispとかScalaとかRustとか
<ul>
<li>Lispは自由度が高い</li>
<li>関数マクロはないよりマシ程度</li>
</ul>
</li>
<li>~衛生性~</li>
<li><a href="//KeenS.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru/">マクロについて整理してみる | κeenのHappy Hacκing Blog</a></li>
</ul>
<p>===</p>
<h2 id="c1">Cのマクロ</h2>
<hr>
<ul>
<li>プリプロセッサなのでコンパイラの拡張ではない</li>
<li>プリプロセッサ自体レキサを持つ
<ul>
<li>パーサとレキサを分ける意味</li>
</ul>
</li>
<li>ASTに関知しないのでやりたい放題</li>
</ul>
<p>===</p>
<h1 id="heading26">中置演算子</h1>
<hr>
<ul>
<li>新しい中置演算子と優先順位を定義できる言語は多い
<ul>
<li>Haskell, SML, Prolog…</li>
</ul>
</li>
<li>パーサをその場で書き換えるのは難しいので後で処理する
<ul>
<li><a href="http://d.hatena.ne.jp/MaD/touch/20090108">[コンパイラ][Haskell][OCaml] Haskellのinfixの仕組み - mad日記</a></li>
</ul>
</li>
<li>シンタックスのプラグインをセマンティクスに入れてるのでちょっと無茶</li>
</ul>
<p>===</p>
<h1 id="heading27">中置演算子</h1>
<hr>
<ul>
<li>人間が同時に覚えられるのは3つまで
<ul>
<li>優先順位がいくつもあっても覚えられない</li>
<li>優先度40とか900とか無理。</li>
</ul>
</li>
<li>本質はAST
<ul>
<li>文法に問題を抱えるくらいならS式を使え</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="coq">Coq</h1>
<hr>
<p>Coqは謎のテクノロジーにより <code>Notation</code>を使えば新しい文法を定義出来る</p>
<div class="highlight"><pre class="chroma"><code class="language-coq" data-lang="coq"><span class="kn">Notation</span> <span class="s2">&#34;</span><span class="s2">&#39;SKIP&#39;</span><span class="s2">&#34;</span> <span class="o">:=</span>
  <span class="n">CSkip</span><span class="o">.</span>
<span class="kn">Notation</span> <span class="s2">&#34;</span><span class="s2">X &#39;::=&#39; a</span><span class="s2">&#34;</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">CAss</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">at</span> <span class="n">level</span> <span class="n">60</span><span class="o">)</span><span class="o">.</span>
<span class="kn">Notation</span> <span class="s2">&#34;</span><span class="s2">c1 ; c2</span><span class="s2">&#34;</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">CSeq</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">)</span> <span class="o">(</span><span class="n">at</span> <span class="n">level</span> <span class="n">80</span><span class="o">,</span> <span class="k">right</span> <span class="n">associativity</span><span class="o">)</span><span class="o">.</span>
<span class="kn">Notation</span> <span class="s2">&#34;</span><span class="s2">&#39;WHILE&#39; b &#39;DO&#39; c &#39;END&#39;</span><span class="s2">&#34;</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">CWhile</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">at</span> <span class="n">level</span> <span class="n">80</span><span class="o">,</span> <span class="k">right</span> <span class="n">associativity</span><span class="o">)</span><span class="o">.</span>
<span class="kn">Notation</span> <span class="s2">&#34;</span><span class="s2">&#39;IFB&#39; e1 &#39;THEN&#39; e2 &#39;ELSE&#39; e3 &#39;FI&#39;</span><span class="s2">&#34;</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">CIf</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e3</span><span class="o">)</span> <span class="o">(</span><span class="n">at</span> <span class="n">level</span> <span class="n">80</span><span class="o">,</span> <span class="k">right</span> <span class="n">associativity</span><span class="o">)</span><span class="o">.</span>

<span class="kn">Definition</span> <span class="n">fact_in_coq</span> <span class="o">:</span> <span class="n">com</span> <span class="o">:=</span>
  <span class="n">Z</span> <span class="o">::</span><span class="o">=</span> <span class="n">AId</span> <span class="n">X</span><span class="o">;</span>
  <span class="n">Y</span> <span class="o">::</span><span class="o">=</span> <span class="n">ANum</span> <span class="n">1</span><span class="o">;</span>
  <span class="n">WHILE</span> <span class="n">BNot</span> <span class="o">(</span><span class="n">BEq</span> <span class="o">(</span><span class="n">AId</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">ANum</span> <span class="n">0</span><span class="o">)</span><span class="o">)</span> <span class="n">DO</span>
    <span class="n">Y</span> <span class="o">::</span><span class="o">=</span> <span class="n">AMult</span> <span class="o">(</span><span class="n">AId</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">AId</span> <span class="n">Z</span><span class="o">)</span><span class="o">;</span>
    <span class="n">Z</span> <span class="o">::</span><span class="o">=</span> <span class="n">AMinus</span> <span class="o">(</span><span class="n">AId</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">ANum</span> <span class="n">1</span><span class="o">)</span>
  <span class="n">END</span><span class="o">.</span>
</code></pre></div><p>===</p>
<h1 id="heading28">雑な話題</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading29">テスト</h1>
<hr>
<ul>
<li>ASTのテストは案外難しい
<ul>
<li>微妙な仕様変更で結果が変わる</li>
<li>でも言語の動作には関係なかったり</li>
</ul>
</li>
</ul>
<ol>
<li>あきらめる</li>
<li>不屈の精神でテストを直し続ける</li>
<li>木に対するクエリ言語を使う</li>
</ol>
<p>===</p>
<h1 id="heading30">先読みと副作用</h1>
<hr>
<ul>
<li>先読みしてバックトラックすると副作用があった時に困る
<ol>
<li>副作用を許さない</li>
<li>副作用は自己責任</li>
<li>一旦先読みで正しいパスを記憶してから正しいパスでもう一度パース
<!-- raw HTML omitted --></li>
</ol>
</li>
</ul>
<!-- raw HTML omitted -->

        </div>
    </div>
</article>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2019. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="http://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script src="//KeenS.github.io/reveal.js/lib/js/head.min.js"></script>
<script src="//KeenS.github.io/reveal.js/js/reveal.js"></script>

<script>

 
 
 Reveal.initialize({
     controls: true,
     progress: true,
     history: false,
     center: false,
     slideNumber: true,

     
     transition: Reveal.getQueryHash().transition || 'none', 

     
     
     

     
     dependencies: [
	 { src: '\/\/KeenS.github.io\/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/highlight.js/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
         { src: '\/\/KeenS.github.io\/reveal.js/plugin/math/math.js', async: true }
     ]
 });

</script>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>


<script>
 window.onload = 
     
     (function(document, Reveal) {
         return function() {
             var page_header = document.getElementById("page-header");
             var article_header = document.getElementById("article-header");


             function displayHeader() {
                 article_header.style.display = "block";
                 page_header.style.display = "block";

             }
             function hideHeader() {
                 article_header.style.display = "none";
                 page_header.style.display = "none";
             }
             Reveal.addEventListener( 'slidechanged', function( event ) {
                 if (event.indexh === 0 && event.indexv === 0) {
                     displayHeader();
                 } else {
                     hideHeader();
                 }
             } );

         }
     })(document, Reveal);
</script>
