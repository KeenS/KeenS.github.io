<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="Futureとその周辺 | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="" />

        <title>Futureとその周辺 | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href="//KeenS.github.io/reveal.js/css/reveal.css">
        <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css'>
        <link rel="stylesheet" href="//KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="//KeenS.github.io/css/liquorice.css" />
        <link rel="stylesheet" href="//KeenS.github.io/highlight.js/styles/agate.css">
        <link rel="stylesheet" href="//KeenS.github.io/css/cleanveal.css" type="text/css" />
        <link rel="apple-touch-icon" sizes="180x180" href="//KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="//KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="//KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <link rel="apple-touch-icon-precomposed" href="//KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script>
         if( window.location.search.match( /print-pdf/gi ) ) {
             var link = document.createElement( 'link' );
             link.rel = 'stylesheet';
             link.type = 'text/css';
             link.href = '\/\/KeenS.github.io\/reveal.js/css/print/pdf.css';
             document.getElementsByTagName( 'head' )[0].appendChild( link );
         }
        </script>
        
    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="//KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="//KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="//KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






<article id="article-container" class="li-article" style="height: 100%">
    <header id="article-header" class="li-article-header" style="position:fixed;z-index:10;">
        <h1 class="li-article-title">Futureとその周辺</h1>
        <div class="li-article-meta">
    <time class="li-article-date">2018-10-05</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="//KeenS.github.io/categories/%e9%9d%9e%e5%90%8c%e6%9c%9f">非同期</a>
        </li>
    
        <li>
            <a href="//KeenS.github.io/categories/future">Future</a>
        </li>
    
</ul>

</div>

    </header>
    <div class="reveal">
        <div class="slides">
            <section data-markdown
    data-separator="\n===\n"
    data-vertical="\n---\n"
    data-notes="^Note:">
<script type="text/template">
# Futureとその周辺
----------------------
[情報科学若手の会 #51](https://wakate.org/2018/07/28/51th-general/)

<!-- .slide: class="center" -->
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) <!-- .element: style="position:absolute;right:0;z-index:-1" width="20%" -->

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます
 * 言語処理系と継続が好き
 * 科学っぽい話はできないです ><

===
# 背景
-------

* 非同期計算を上手く扱いたい
* 色々あるけど難しい
* 似て非なるものを同じ名前で呼んでて紛らわしい
* 全体を俯瞰したい

===
# 同期計算
-------------

* 同期IO処理はその処理が終わるまで待つ
* 待ってる間が無駄

![同期計算](/images/sync.png) <!-- .element: width="100%" -->

===

# 非同期計算
-------------

* 待ってる間別のことをやりたい
* 処理の切り替えどうするの

![非同期計算](/images/async.png) <!-- .element: width="100%" -->


===

# 非同期計算
-------------

* (限定)継続が取り出せればいい
* 解決！

![限定継続](/images/cont.png) <!-- .element: width="100%"  -->

===
# 限定継続
----------

* 多くの言語では限定継続は扱えない
  + Schemeなら簡単なんだけどねー
* CPS変換すれば限定継続じみたことができる
  + 要はコールバック形式

===
# 問題意識
----------

* コールバック地獄
* デッドロック


===
# コールバック地獄
--------------

* コールバックがどんとんネストしていく問題
* 非同期呼び出しする度に深くなる
* 視認性が悪くなる

===
# コールバック地獄
--------------

```javascript
fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})
```

http://callbackhell.com/


===
# デッドロック
------------

* 個人的経験
* [Aerospike](https://www.aerospike.jp/)のJavaクライアント
 + 非同期IO
 + コールバックが設定できる
* readしてコールバックでwriteした
* → デッドロックした
* 非同期処理はIOスレッドが実行していた
* コールバックもIOスレッドて呼ばれていた

===
# デッドロック
------------


1. 非同期ReadでIOスレッドを専有
2. IOスレッドでコールバック発火
3. 非同期Write発行
4. WriteはIOスレッド待ち & IOスレッドはWrite待ち
5. デッドロック


===

# 色々な視点
------------

* 実行モデル
  + デッドロックの件は実行モデルの知識が足りなかったから起きた
* ユーザインタフェース ← メイン
  + コールバック地獄は主にユーザインタフェースの問題
* 実装方式
  + 処理系の中身みんな知りたいよね！

===
# 実行モデル
-----------

* 多分無数にある
* ただの遅延計算
* IOスレッド1つ
* スレッドプール
  + ブロックするスレッドとさせたくないスレッドを分離
  + スケジューラに無数のバリエーション
* イベントループ
  + スレッドをブロックせずに一杯タスクをこなす
* その他応用

===
# ユーザインタフェース
---------------------

* コールバック
* Future
  + futureにも色々
  + 少し実装も絡む
* `async`/`await`
* `do` 式 / `for` 式
* coroutine
  + coroutineにも色々
* goroutine

===
# 実装方式
----------

* 完全ユーザレベル
* 完全処理系レベル
* 処理系レベルだけど一部ユーザレベル
* ユーザレベルだけど特殊な処理系の機能を使う

===
# コールバック
-------------

* ユーザインタフェース: コールバック
  + 扱いづらい
* 実行モデル: ものによる
* 実装方式: 完全ユーザレベル

===

# Future
--------

* ユーザインタフェース: Future
  + 少しマシになった
* 実行モデル: ものによる
* 実装方式: 完全ユーザレベル

===
# Future
--------

* 並行デザインパターン
* 計算を非同期実行
* 値の引換券(先物 = future)を返す
* 実行した値を受け取れる
* みなさん知ってますよね

===

# diff to コールバック
-----------------------------

* 値になる
 + 「あとで呼ばれる」という暗黙の文脈が「値」という一級市民になった
* 続けて処理を書ける
  + map, andThen, ...
  + 要はモナド
* そのままだとコールバック地獄は変わらない

===
Scala標準ライブラリ

``` scala
val purchase = usdQuote flatMap {
  usd =>
  chfQuote
    .withFilter(chf => isProfitable(usd, chf))
    .map(chf => connection.buy(amount, chf))
}
```

https://docs.scala-lang.org/ja/overviews/core/futures.html


===
# Future x 実行モデル
--------------------

* Futureは基本的にはコールバックの抽象化
* 特定の実行モデルとは結びつかない
* …とでも思ったか！
* 実装によって千差万別

===
# Future x 実行モデル
--------------------

* Scala: 標準ライブラリの`Future`
  + Futureそのものは実行モデルと結びつかない
  + `Future` の作成にスレッドプールが必要
  + 実装レベルでは分離
  + APIレベルでは結合してる
* Clojure: clojure.coreの`future`
  + 雑にスレッドプールに処理を投げる
  + 完全に密結合

===
# Future x 実行モデル
--------------------

* Scala: TwitterUtilの`Future`
  + Futureそのものは実行モデルと結びつかない
  + APIレベルでも分離
  + 別途スレッドプールも用意される
* Rust: futures-rs
  + Futureそのものは実行モデルと結びつかない
  + APIレベルでも分離
  + 別途スレッドプールも用意される

===
# Future x 実行モデル
--------------------

* Futureとスレッドプールが密結合
  + 手軽に並列化できる
* Futureと実行モデルは粗結合
  + 計算を合成してからスレッドプールに投げられる
   - 計算と実行を別々のライブラリにできる

===
# Futureはいつ実行される
--------------------

* 前のタスクが終了した直後に実行
* ジョブキューに積まれていつか実行
* 値をgetするとき
* イベントループがpollする
* …


===
# Futureの構文糖衣
------------------

* Futureを使ってもコールバック地獄は変わらない
  + 構文糖衣でどうにかする
* Futureはモナド
  + 普通のプログラムっぽい書き方ができるはず
* 普通は構文糖衣は処理系のサポートが必要

===
# Futureの構文糖衣
------------------

* `async`/`await`
  + 大半処理系、一部ユーザ
  + ジェネレーターが必要
* `do` 式/`for`式
  + 処理系の機能に乗っかる
  + 高階多相が必要
* Lispだとマクロでユーザレベルで可能

===
# `async`/`await`
-----------------

``` c#
// Signature specifies Task<TResult>
async Task<int> TaskOfTResult_MethodAsync()
{
    int hours;
    // . . .
    // Return statement specifies an integer result.
    return hours;
}

// Calls to TaskOfTResult_MethodAsync
Task<int> returnedTaskTResult = TaskOfTResult_MethodAsync();
int intResult = await returnedTaskTResult;
// or, in a single statement
int intResult = await TaskOfTResult_MethodAsync();
```

===
# `do` 式
------

``` haskell
   do a1 <- async (getURL url1)
      a2 <- async (getURL url2)
      page1 <- wait a1
      page2 <- wait a2
      ...
```
http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html

===
# `for` 式
-----------

``` scala
val usdQuote = Future { connection.getCurrentValue(USD) }
val chfQuote = Future { connection.getCurrentValue(CHF) }

val purchase = for {
  usd <- usdQuote
  chf <- chfQuote
  if isProfitable(usd, chf)
} yield connection.buy(amount, chf)
```

https://docs.scala-lang.org/ja/overviews/core/futures.html


===
# Lisp
--------

```common-lisp
(alet ((x (grab-x-from-server1))
       (y (grab-y-from-server2)))
  (format t "x + y = ~a~%" (+ x y)))
```

http://orthecreedence.github.io/blackbird/


===

# 発展的話題
------------

* コールバック形式でなくて直接形式で書きたい
* もっと直接限定継続を取得したい
* 1回しか実行しなくていいので限定継続より軽いモデルでいい
* → コルーチン

===
# コルーチン
-----------

* 対称/非対称コルーチンがある
  + 対称: 各コルーチンが対等。 `transfer` で切り替える
  + 非対称: コルーチンに親子関係がある。 `yield` で親に、 `resume` で子に切り替える
* stack full/stack lessがある
  + stack full: 呼び出された関数内から外のコルーチンを `transfer` / `yield` できる
  + stack less: コルーチン直下でしか `transfer` / `yield` できない
* fiber = 準コルーチン = 非対称コルーチン

===

``` ruby
f = Fiber.new do
  n = 0
  loop do
    Fiber.yield(n)
    n += 1
  end
end
```
https://docs.ruby-lang.org/ja/latest/class/Fiber.html

===

``` ruby
require 'fiber'

fr1 = Fiber.new do |v|
  :fugafuga
end

fr2 = Fiber.new do |v|
  fr1.transfer
  :fuga
end

fr3 = Fiber.new do |v|
  fr2.resume
  :hoge
end

p fr3.resume # => :fugafuga
```

https://docs.ruby-lang.org/ja/latest/method/Fiber/i/transfer.html

===

![対称コルーチン](/images/coroutine.png) <!-- .element: width="100%" -->

===

![非対称コルーチン](/images/semicoroutine.png) <!-- .element: width="100%" -->

===
# Futureとの関係
----------------
* `async`/`await`はstack less非対称コルーチン(=generator)の上に実装されることが多い
  + jsの`async`/`await`とか
  + Rustの`async`/`await`もそうなる予定
* `do`式/`for`式はstack less非対称コルーチンを実装できる
  http://hackage.haskell.org/package/monad-coroutine-0.9.0.4/docs/Control-Monad-Coroutine.html

===

![async/awaitと機能の依存](/images/async-await.png) <!-- .element: width="100%" -->

===

![do式と機能の依存](/images/do-async.png) <!-- .element: width="100%" -->


===

# goroutine
------------

* Goのあれ
  + 他の言語にもある
* 完全処理系レベルの実現
* stackfullな対称coroutine(多分) + IOをトリガとした自動スケジュール
  + 直接形式で書ける
* 自分でtransferを書かないのでスレッドに近い見た目

===

``` go
func say(s string) {
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}

func main() {
	go say("world")
	say("hello")
}
```
https://tour.golang.org/concurrency/1

===
# スレッドとの違い
----------------
* スレッドはプリエンプティブ
  + スケジューラが勝手に止めたり起動したりする
* goroutineはノンプリエンプティブ
  + 自身でIOする直前に別のgoroutineにtransferする
  + スケジューラは次にどのgoroutineを起動するか選ぶだけ

===
# goroutine
-----------

* Goのgoroutine
  + mainもgoroutine
  + ランタイムにスケジューラが組込
* JavaのProject Loom
  + 処理系に手を入れることで既存ライブラリもサポート
  + 用語が変
* Clojureのcore.async
  + なんとユーザレベルで実現
  + マクロでSSA変換

===
# goroutine
-----------

* プログラマ的には直接形式で書けるので扱いやすい
* 処理系的には処理系全体でサポートする必要がある
  + IOのタイミングを全部掌握
  + FFIとかも
* 実行モデルは決め打ちになる


===
# 結論
--------

* 非同期に対して色々なアプローチがある
* 同じ名前で中身が違うことが多々有る
* 結局抽象化を解いて中身を見るしかない

===
# まとめ
--------

* コールバックを値にしたのがFuture
* Futureに構文糖衣を被せたのが`async`/`await`とか
* Futureと実行モデルはほぼ直行する
* 別のアプローチとしてgoroutineがある
* goroutineは実行モデルと密結合
* Lispはなんでもできる


</script>
</section>

<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>

        </div>
    </div>
</article>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2019. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="http://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script src="//KeenS.github.io/reveal.js/lib/js/head.min.js"></script>
<script src="//KeenS.github.io/reveal.js/js/reveal.js"></script>

<script>

 
 
 Reveal.initialize({
     controls: true,
     progress: true,
     history: false,
     center: false,
     slideNumber: true,

     
     transition: Reveal.getQueryHash().transition || 'none', 

     
     
     

     
     dependencies: [
	 { src: '\/\/KeenS.github.io\/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/highlight.js/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
         { src: '\/\/KeenS.github.io\/reveal.js/plugin/math/math.js', async: true }
     ]
 });

</script>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>


<script>
 window.onload = 
     
     (function(document, Reveal) {
         return function() {
             var page_header = document.getElementById("page-header");
             var article_header = document.getElementById("article-header");


             function displayHeader() {
                 article_header.style.display = "block";
                 page_header.style.display = "block";

             }
             function hideHeader() {
                 article_header.style.display = "none";
                 page_header.style.display = "none";
             }
             Reveal.addEventListener( 'slidechanged', function( event ) {
                 if (event.indexh === 0 && event.indexv === 0) {
                     displayHeader();
                 } else {
                     hideHeader();
                 }
             } );

         }
     })(document, Reveal);
</script>
