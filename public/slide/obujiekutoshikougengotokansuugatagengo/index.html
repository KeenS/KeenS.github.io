<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="オブジェクト指向言語と関数型言語 | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="manabiya.techでの発表資料。オブジェクト指向と関数型についてのスピリチュアルな話" />

        <title>オブジェクト指向言語と関数型言語 | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href="//KeenS.github.io/reveal.js/css/reveal.css">
        <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css'>
        <link rel="stylesheet" href="//KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="//KeenS.github.io/css/liquorice.css" />
        <link rel="stylesheet" href="//KeenS.github.io/highlight.js/styles/agate.css">
        <link rel="stylesheet" href="//KeenS.github.io/css/cleanveal.css" type="text/css" />
        <link rel="apple-touch-icon" sizes="180x180" href="//KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="//KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="//KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <link rel="apple-touch-icon-precomposed" href="//KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="alternate" href="" type="application/rss+xml" title="κeenのHappy Hacκing Blog" />
        
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script>
         if( window.location.search.match( /print-pdf/gi ) ) {
             var link = document.createElement( 'link' );
             link.rel = 'stylesheet';
             link.type = 'text/css';
             link.href = '\/\/KeenS.github.io\/reveal.js/css/print/pdf.css';
             document.getElementsByTagName( 'head' )[0].appendChild( link );
         }
        </script>
        
    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="//KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="//KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="//KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






<article id="article-container" class="li-article" style="height: 100%">
    <header id="article-header" class="li-article-header" style="position:fixed;z-index:10;">
        <h1 class="li-article-title">オブジェクト指向言語と関数型言語</h1>
        <div class="li-article-meta">
    <time class="li-article-date">2018-03-14</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="//KeenS.github.io/categories/%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e6%8c%87%e5%90%91">オブジェクト指向</a>
        </li>
    
        <li>
            <a href="//KeenS.github.io/categories/%e9%96%a2%e6%95%b0%e5%9e%8b">関数型</a>
        </li>
    
</ul>

</div>

    </header>
    <div class="reveal">
        <div class="slides">
            <!-- raw HTML omitted -->
<h1 id="heading">はじめに</h1>
<hr>
<ul>
<li>椅子のキーストラップは是非お持ち帰り下さい</li>
<li>主にプログラミング言語を1つ覚えたくらいの人を対象にしています</li>
<li>トークで40分全部使い切る予定なので質問はこのあとの職員室でお願いします</li>
<li>たまに細かい話が出てきますがスルーして下さい
<ul>
<li>主に重箱の角をつつく人への対策です</li>
</ul>
</li>
</ul>
<p>===</p>
<!-- raw HTML omitted -->
<hr>
<p><a href="https://manabiya.tech/">MANABIYA</a> 2日目5時間目@ギャラリーB<br>
<a href="https://twitter.com/search?src=typd&amp;q=%23manabiya&amp;lang=ja">#manabiya</a></p>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="about-me">About Me</h1>
<hr>
<p><img src="//KeenS.github.io/images/kappa.png" alt="κeenのアイコン"> <!-- raw HTML omitted --></p>
<ul>
<li>κeen</li>
<li><a href="https://twitter.com/blackenedgold">@blackenedgold</a></li>
<li>Github: <a href="https://github.com/KeenS">KeenS</a></li>
<li><a href="https://idein.jp/">Idein Inc.</a>のエンジニア</li>
<li>言語処理系を作るのが好き</li>
<li>仕事での経験: Java, Scala, Rust</li>
<li>趣味: C, Common Lisp, Standard ML, Rust</li>
</ul>
<p>===</p>
<h1 id="heading1">話すこと</h1>
<hr>
<ul>
<li>オブジェクト指向/関数型&quot;プログラミング&quot;とはパラダイムのことだよ</li>
<li>オブジェクト指向/関数型&quot;言語&quot;とはそのパラダイムを支援する言語のことだよ</li>
<li>言語とパラダイムの区別を明確に！</li>
</ul>
<p>===</p>
<h1 id="heading2">理想のソフトウェア</h1>
<hr>
<ul>
<li>変更に強いソフトウェア</li>
<li>バグの少ないソフトウェア</li>
<li>凝集度を高めて結合度を低めたい
<ul>
<li>似たようなものは同じところに</li>
<li>互いの依存関係を減らす</li>
</ul>
</li>
<li>理想のソフトウェアを作るには？</li>
</ul>
<p>===</p>
<h1 id="heading3">パラダイム</h1>
<hr>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0">Wikipedia</a></li>
<li>プログラミングにおける思考のフレームワーク
<ul>
<li>一貫性の取れた設計</li>
<li>組み合わせたときの相性の良さ</li>
<li>一度理解するとその後の学習コストが下がる</li>
</ul>
</li>
<li>特定の言語に依存しない概念</li>
<li>ある程度成功しやすい手法のパターン化</li>
</ul>
<p>===</p>
<h1 id="heading4">色々なパラダイム</h1>
<hr>
<ul>
<li>手続き型 - プログラムとは機械の操作の記述だ</li>
<li>オブジェクト指向 - プログラムとはオブジェクト間のメッセージのやりとりだ</li>
<li>関数型 - プログラムとは計算だ</li>
<li>論理型 - &hellip;</li>
<li>などなど</li>
</ul>
<p>===</p>
<h1 id="-element-stylefontsize-calcvartitlefontsize--08">複数のパラダイムを知ろう&lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.8)&quot;&ndash;&gt;</h1>
<hr>
<p><a href="https://employment.en-japan.com/engineerhub/entry/2017/05/19/110000"><!-- raw HTML omitted --></a><!-- raw HTML omitted --></p>
<blockquote>
<p>「ハンマーしか持っていなかったら、なんでも釘に見える」という戒めがありますが、第二言語を学ぶことは、まさにハンマー以外の道具を持つことだといえます。</p>
</blockquote>
<p>===</p>
<h1 id="----element-stylefontsize-calcvartitlefontsize--07">オブジェクト指向プログラミング と 関数型プログラミング &lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.7)&quot;&ndash;&gt;</h1>
<hr>
<ul>
<li>何故この２つのパラダイム？
<ul>
<li>→ よく使われるパラダイム2つ</li>
</ul>
</li>
<li>片方しか経験ない人はもう片方も学んでみよう
<ul>
<li>パラダイムが違うので最初は馴れない</li>
<li>コツは過去の成功体験を捨てること
<ul>
<li>パラダイムが違うと作法も違う</li>
</ul>
</li>
</ul>
</li>
<li>ベタな手続き型プログラミングよりいいコードを書きたい</li>
</ul>
<p>===</p>
<h1 id="heading5">参考図書</h1>
<hr>
<p><a href="http://gihyo.jp/book/2016/978-4-7741-8361-9"><!-- raw HTML omitted --></a> <!-- raw HTML omitted -->
<a href="http://gihyo.jp/book/2016/978-4-7741-8390-9"><!-- raw HTML omitted --></a>     <!-- raw HTML omitted --></p>
<p>===</p>
<h1 id="oop">OOPって？</h1>
<hr>
<p><strong>オブジェクト</strong> 同士の <strong>メッセージング</strong> によるプログラミング手法</p>
<ul>
<li>コード同士の依存関係を上手く管理したい</li>
<li>依存関係を上手く扱うことで変更に強いソフトウェアへ
<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88">DDD</a>などの設計手法</li>
</ul>
</li>
<li>コードの分割</li>
<li>コードの再利用</li>
</ul>
<p>===</p>
<h1 id="fp">FPって？</h1>
<hr>
<p><strong>副作用</strong> を出来るだけ使わないプログラミング手法<a href="https://twitter.com/esumii/status/638591159518887936">※</a></p>
<ul>
<li>副作用 = 計算以外のもの
<ul>
<li>破壊的変更、出入力など(深入りするとややこしい)</li>
</ul>
</li>
<li>状態を排除→文脈に依存しないコードへ
<ul>
<li>読みやすくなる</li>
<li>バグが少なくなる</li>
</ul>
</li>
<li>コードの分割と合成</li>
</ul>
<p>===</p>
<h1 id="heading6">何が違うの？</h1>
<hr>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading7">手続き的(自然言語)</h1>
<hr>
<p>入力: <code>array</code> - 配列,  <code>n</code> - 配列の長さ<br>
出力: <code>array</code>の要素の合計</p>
<ol>
<li><code>sum = 0</code>, <code>i=0</code> とする</li>
<li>もし<code>i</code> が<code>n</code>未満なら4へ飛ぶ</li>
<li>7へ飛ぶ</li>
<li><code>sum</code>に<code>array</code>の<code>i</code>番目を足したものを<code>sum</code>に代入</li>
<li><code>i</code>をインクリメント</li>
<li>2へ飛ぶ</li>
<li><code>sum</code>を返す</li>
</ol>
<p>===</p>
<h1 id="c">手続き的(C言語)</h1>
<hr>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span>
<span class="nf">procedual_sum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="p">]</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>===</p>
<h1 id="oop1">OOP的発想</h1>
<hr>
<ul>
<li>データの中身を列挙するオブジェクト(イテレータ)を用意しよう
<ul>
<li>イテレータはデータにメッセージを送って取得しよう</li>
</ul>
</li>
<li>イテレータにメッセージを送って要素を取得しよう</li>
<li>イテレータがあればデータの実装に依存しなくなるな</li>
</ul>
<p>===</p>
<h1 id="heading8">イメージ</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="oopc">OOPコード例(C言語)</h1>
<hr>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">iterable</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">iter</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iterable</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fin</span><span class="p">)</span><span class="p">(</span><span class="k">struct</span> <span class="n">iterable</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iter</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="p">(</span><span class="k">struct</span> <span class="n">iter</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">has_next</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iter</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fin</span><span class="p">)</span><span class="p">(</span><span class="k">struct</span> <span class="n">iter</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">objective_sum</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iterable</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">data</span><span class="o">-</span><span class="o">&gt;</span><span class="n">iter</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-</span><span class="o">&gt;</span><span class="n">has_next</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">iter</span><span class="o">-</span><span class="o">&gt;</span><span class="n">next</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">iter</span><span class="o">-</span><span class="o">&gt;</span><span class="n">fin</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>===</p>
<h1 id="heading9">実装イメージ</h1>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="oopc--element-stylefontsize-calcvartitlefontsize--08">OOPコード例(C言語) 実装&lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.8)&quot;&ndash;&gt;</h1>
<hr>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">array_list</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">iterable</span> <span class="n">super</span><span class="p">;</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">i</span><span class="p">)</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">len</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">inner</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>


<span class="k">struct</span> <span class="nc">array_list_iter</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">iter</span> <span class="n">super</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">iter</span> <span class="o">*</span><span class="nf">array_list_iter</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">iterable</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">array_list_fin</span><span class="p">(</span><span class="k">struct</span> <span class="nc">iterable</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">array_list_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">)</span><span class="p">;</span>
<span class="n">size_t</span> <span class="nf">array_list_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">array_list_iter</span> <span class="o">*</span><span class="nf">array_list_iter_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">array_list_iter_fin</span><span class="p">(</span><span class="k">struct</span> <span class="nc">iter</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">array_list_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="nc">iter</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">array_list_iter_has_next</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">iter</span> <span class="o">*</span><span class="p">)</span><span class="p">;</span>


<span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span>
<span class="nf">array_list_new</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">inner</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">array_list</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">array</span><span class="o">-</span><span class="o">&gt;</span><span class="n">super</span><span class="p">.</span><span class="n">iter</span> <span class="o">=</span> <span class="n">array_list_iter</span><span class="p">;</span>
  <span class="n">array</span><span class="o">-</span><span class="o">&gt;</span><span class="n">super</span><span class="p">.</span><span class="n">fin</span> <span class="o">=</span> <span class="n">array_list_fin</span><span class="p">;</span>
  <span class="n">array</span><span class="o">-</span><span class="o">&gt;</span><span class="n">get</span> <span class="o">=</span> <span class="n">array_list_get</span><span class="p">;</span>
  <span class="n">array</span><span class="o">-</span><span class="o">&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">array_list_len</span><span class="p">;</span>
  <span class="n">array</span><span class="o">-</span><span class="o">&gt;</span><span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="p">;</span>
  <span class="n">array</span><span class="o">-</span><span class="o">&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">array_list_fin</span><span class="p">(</span><span class="k">struct</span> <span class="nc">iterable</span> <span class="o">*</span><span class="n">super</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="p">)</span> <span class="n">super</span><span class="p">;</span>
  <span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">iter</span> <span class="o">*</span>
<span class="nf">array_list_iter</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">iterable</span> <span class="o">*</span><span class="n">super</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="p">)</span> <span class="n">super</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">iter</span> <span class="o">*</span><span class="p">)</span><span class="n">array_list_iter_new</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">array_list_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">self</span><span class="o">-</span><span class="o">&gt;</span><span class="n">inner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">size_t</span>
<span class="nf">array_list_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">self</span><span class="o">-</span><span class="o">&gt;</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="nc">array_list_iter</span> <span class="o">*</span>
<span class="nf">array_list_iter_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">array_list</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">array_list_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">array_list_iter</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">iter</span><span class="o">-</span><span class="o">&gt;</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
  <span class="n">iter</span><span class="o">-</span><span class="o">&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">iter</span><span class="o">-</span><span class="o">&gt;</span><span class="n">super</span><span class="p">.</span><span class="n">fin</span> <span class="o">=</span> <span class="n">array_list_iter_fin</span><span class="p">;</span>
  <span class="n">iter</span><span class="o">-</span><span class="o">&gt;</span><span class="n">super</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">array_list_iter_next</span><span class="p">;</span>
  <span class="n">iter</span><span class="o">-</span><span class="o">&gt;</span><span class="n">super</span><span class="p">.</span><span class="n">has_next</span> <span class="o">=</span> <span class="n">array_list_iter_has_next</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">iter</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">array_list_iter_fin</span><span class="p">(</span><span class="k">struct</span> <span class="nc">iter</span> <span class="o">*</span><span class="n">super</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">array_list_iter</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">array_list_iter</span> <span class="o">*</span><span class="p">)</span><span class="n">super</span><span class="p">;</span>
  <span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">array_list_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="nc">iter</span> <span class="o">*</span><span class="n">super</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">array_list_iter</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">array_list_iter</span> <span class="o">*</span><span class="p">)</span><span class="n">super</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">self</span><span class="o">-</span><span class="o">&gt;</span><span class="n">array</span><span class="o">-</span><span class="o">&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">self</span><span class="o">-</span><span class="o">&gt;</span><span class="n">array</span><span class="p">,</span> <span class="n">self</span><span class="o">-</span><span class="o">&gt;</span><span class="n">i</span><span class="p">)</span><span class="p">;</span>

  <span class="n">self</span><span class="o">-</span><span class="o">&gt;</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>===</p>
<h1 id="oop2">OOPコードの特徴</h1>
<hr>
<ul>
<li>オブジェクトにメッセージを送ってループを書いた
<ul>
<li>オブジェクト = <code>iter</code></li>
<li>メッセージ = <code>has_next</code>、<code>next</code></li>
</ul>
</li>
<li>インターフェースと実装を分離してコードを書いた
<ul>
<li>インターフェース = <code>iterable</code>、<code>iter</code></li>
<li>実装 = <code>array_list</code>、<code>array_list_iter</code></li>
</ul>
</li>
<li>データの中身を知らなくてもコードを書けた
<ul>
<li>木構造や辞書などにも適用できる</li>
</ul>
</li>
<li>具体的実装がなくてもコードを書けた
<ul>
<li>コードの分割ができる</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="fp1">FP的発想</h1>
<hr>
<ul>
<li>配列の中身の合計を求める式を立てよう</li>
<li>計算を一般化して汎用性をあげよう</li>
<li>それをプログラムとして書き下そう</li>
</ul>
<p>===</p>
<h1 id="fp2">FP的記述</h1>
<hr>
<p>\[
\begin{align}
S_0 &amp;= 0 \\<br>
S_n &amp;= S_{n-1} + arr[n - 1]
\end{align}
\]</p>
<p>===</p>
<h1 id="fp3">FP的記述</h1>
<hr>
<p>\[
\begin{align}
S_0 &amp;= init \\<br>
S_n &amp;= f(S_{n-1}, arr[n - 1])
\end{align}
\]</p>
<p>===</p>
<h1 id="fpc">FPコード例(C言語)</h1>
<hr>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span>
<span class="nf">reduce</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="p">]</span><span class="p">,</span> <span class="k">const</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">init</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="p">)</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">init</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span>
<span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">functional_sum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="p">]</span><span class="p">,</span> <span class="k">const</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>===</p>
<h1 id="fp4">FP的コードの特徴</h1>
<hr>
<ul>
<li>ループと中身に分解してコードを書いた
<ul>
<li>ループ = <code>for文</code> → <code>reduce</code></li>
<li>中身 = <code>sum += array[i]</code> → <code>add</code></li>
<li>制御構造を関数にできた</li>
</ul>
</li>
<li>副作用(変数の更新)を行わずにコードを書いた</li>
<li>宣言的になった</li>
</ul>
<p>===</p>
<h1 id="oop3">OOPコードの問題点</h1>
<hr>
<ul>
<li>メッセージパッシングの書き方が冗長
<pre><code>obj-&gt;msg(obj)
</code></pre></li>
<li>普通のコードより遅そう
<ul>
<li>毎回関数ポインタ経由でメッセージ</li>
<li>ことある毎にオブジェクトを作る
<ul>
<li>今回は余計にイテレータオブジェクトを作った</li>
</ul>
</li>
</ul>
</li>
<li><code>int</code>と<code>+</code>はオブジェクトとメッセージになってない
<ul>
<li>設計の一貫性がとれてない</li>
</ul>
</li>
<li>メッセージ増やすとデータサイズが増えそう</li>
</ul>
<p>===</p>
<h1 id="fp5">FPコードの問題点</h1>
<hr>
<ul>
<li>余計な関数定義が増える
<ul>
<li>足し算するための<code>add</code>関数を定義した</li>
</ul>
</li>
<li>データに依存したコードになっている
<ul>
<li>他のデータ型に対して適用できない</li>
</ul>
</li>
<li>副作用を使わない
<ul>
<li>機械の操作とは大分違う</li>
</ul>
</li>
<li>一般には毎回データのコピーが発生する
<ul>
<li>今回の例では運良く<code>int</code>しかコピーしなかった</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading10">問題の解決案</h1>
<hr>
<p>言語による<!-- raw HTML omitted --></p>
<ul>
<li>対象にしているものが広すぎる<!-- raw HTML omitted --></li>
<li>具体的な言語抜きに語っても意味がない<!-- raw HTML omitted --></li>
</ul>
<p>===
そのまえに</p>
<h1 id="xxx">XXX言語とは</h1>
<hr>
<p><a href="https://www.slideshare.net/ksknac/120901fp-key">関数型プログラミングの今昔</a></p>
<ul>
<li>オブジェクト指向(プログラミングを支援する)言語</li>
<li>関数型(プログラミングを支援する)言語</li>
<li>マルチパラダイム言語もある
<ul>
<li>複数のプログラミングパラダイムを支援</li>
<li>それらを混ぜて使うことも</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="oop4">OOP言語色々</h1>
<hr>
<ul>
<li>メソッド呼び出し構文があればOOPを支援(?)
<ul>
<li><code>obj-&gt;msg(obj)</code> → <code>obj.msg()</code></li>
</ul>
</li>
<li>クラスベース
<ul>
<li>Ruby Java C# Python C++ &hellip;</li>
<li>単一継承/多重継承の違いも</li>
</ul>
</li>
<li>プロトタイプベース
<ul>
<li>Smalltalk JS &hellip;</li>
</ul>
</li>
<li>その他
<ul>
<li>go rust &hellip;</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading11">クラスベースの特徴</h1>
<hr>
<ul>
<li>メッセージはクラスが知っている
<ul>
<li>メッセージを増やしてもオブジェクトは肥大化しない</li>
</ul>
</li>
<li>クラス継承によるインターフェースと実装の再利用
<ul>
<li>ある意味では親と子の密結合</li>
</ul>
</li>
<li>リスコフの置換則
<ul>
<li>親クラスはいつでもサブクラスに置き換えられるべき</li>
</ul>
</li>
<li>差分プログラミングをするとスパゲッティコードになる</li>
</ul>
<blockquote>
<p>「オブジェクトの階層構造をコストとして払う代わりに、メッセージの移譲は無料で手に入れられる」</p>
</blockquote>
<p>===</p>
<!-- raw HTML omitted -->
<p>===
抽象の境界と差分プログラミングとスパゲッティコード</p>
<!-- raw HTML omitted -->
<p>===
抽象の境界と差分プログラミングとスパゲッティコード</p>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="java">Javaの特徴</h1>
<hr>
<ul>
<li>クラスベース単一継承</li>
<li>抽象クラスやインターフェースによる抽象化</li>
<li>プリミティブ型はオブジェクトじゃない</li>
<li>遅くならない工夫
<ul>
<li>→ 実行しながら高速化</li>
<li>→ メモリ管理の改善</li>
</ul>
</li>
<li>割とクラスの機能が強い
<ul>
<li>クラスが名前空間も兼任</li>
<li>スタンドアロンな関数が書けない（かった）</li>
<li>コールバックには無名クラスとか</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="java1">Javaのコード例</h1>
<hr>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Figure</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">draw</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span>
  <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="kt">int</span> <span class="n">dx</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dy</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Triangle</span> <span class="kd">extends</span> <span class="n">Figure</span> <span class="o">{</span>
  <span class="n">Point</span> <span class="n">a</span><span class="o">;</span>
  <span class="n">Point</span> <span class="n">b</span><span class="o">;</span>
  <span class="n">Point</span> <span class="n">c</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kt">void</span> <span class="nf">draw</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">drawLine</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="o">;</span>
    <span class="n">drawLine</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span><span class="o">;</span>
    <span class="n">drawLine</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="kt">int</span> <span class="n">dx</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dy</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">a</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">dx</span><span class="o">,</span> <span class="n">dy</span><span class="o">)</span><span class="o">;</span>
    <span class="n">b</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">dx</span><span class="o">,</span> <span class="n">dy</span><span class="o">)</span><span class="o">;</span>
    <span class="n">c</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">dx</span><span class="o">,</span> <span class="n">dy</span><span class="o">)</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">void</span> <span class="nf">drawLine</span><span class="o">(</span><span class="n">Point</span> <span class="n">from</span><span class="o">,</span> <span class="n">Point</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span>

  <span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="kt">int</span> <span class="n">dx</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dy</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">x</span> <span class="o">+</span><span class="o">=</span> <span class="n">dx</span><span class="o">;</span>
      <span class="n">y</span> <span class="o">+</span><span class="o">=</span> <span class="n">dy</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>===</p>
<h1 id="java-element-stylefontsize-calcvartitlefontsize--09">Javaのコード例について&lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.9)&quot;&ndash;&gt;</h1>
<hr>
<ul>
<li>設計は難しい</li>
<li><code>drawLine</code> はだれが持つべき？
<ul>
<li><code>drawLine</code> ってTriangleだけのものじゃないよね</li>
<li>本来は <code>new Line().draw()</code> では？</li>
<li>でも毎回オブジェクト作るの？</li>
</ul>
</li>
<li><code>ColoredTriangle</code> を作ろうとしたらどうする？
<ul>
<li><code>drawLine</code> をオーバーライドする？</li>
<li><code>new ColoredLine</code> にする？</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="ruby">Rubyの特徴</h1>
<hr>
<ul>
<li>クラスベース単一継承</li>
<li>生産性を重視した設計</li>
<li>数値や<code>+</code>などもオブジェクト/メソッド</li>
<li>ダックタイピング
<ul>
<li>メッセージに応答すればなんでもいい</li>
</ul>
</li>
<li>クラスだけでなくモジュールも
<ul>
<li>mix-in</li>
</ul>
</li>
<li>クラスの権限がそんなに強くない
<ul>
<li>オープンクラス</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="ruby1">Rubyらしさ(主観)</h1>
<hr>
<ul>
<li>for文なしでの繰り返し
<ul>
<li>ブロック構文</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="p">(</span><span class="mi">1</span><span class="o"></span><span class="o">..</span><span class="mi">10</span><span class="o"></span><span class="p">)</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">i</span><span class="p">}</span>
</code></pre></div><ul>
<li><a href="https://railsguides.jp/active_support_core_extensions.html#time">ActiveSupport</a>による数値の拡張など
<ul>
<li>オープンクラス 数値もオブジェクト <code>+</code>もメソッド</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="mi">1</span><span class="o"></span><span class="o">.</span><span class="n">week</span> <span class="o">-</span> <span class="mi">2</span><span class="o"></span><span class="o">.</span><span class="n">days</span>
</code></pre></div><p>===</p>
<h1 id="go">Goの特徴</h1>
<hr>
<ul>
<li>メソッド呼び出し構文がある</li>
<li>クラスや継承はない
<ul>
<li>代わりにインターフェースとインクルードがある</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading12">関数型言語色々</h1>
<hr>
<ul>
<li>ML系</li>
</ul>
<ul>
<li>SML</li>
<li>OCaml</li>
<li>F#</li>
</ul>
<ul>
<li>Haskell系</li>
</ul>
<ul>
<li>Haskell (GHC)</li>
<li>Agda</li>
<li>Idris</li>
</ul>
<ul>
<li>Erlang</li>
<li>Lisp系
<ul>
<li>Clojure</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading13">ありがちな機能</h1>
<hr>
<ul>
<li>破壊的変更できないorあまりしない</li>
<li>関数の便利な扱い
<ul>
<li>無名関数</li>
<li>演算子も関数</li>
<li>関数合成</li>
<li>高階関数</li>
<li>カリー化(関数を返す関数)</li>
</ul>
</li>
<li>※「関数型 = Haskell」はHaskellプログラマの麻疹</li>
</ul>
<p>===</p>
<h1 id="heading14">便利な関数の扱い</h1>
<hr>
<ul>
<li>高階関数 演算子も関数 関数合成</li>
</ul>
<pre><code class="language-sml" data-lang="sml">val sum = List.foldl op+ 0;
</code></pre><pre><code class="language-standard-ml" data-lang="standard-ml">val inner_product = List.foldl op+ 0 o List.map op* o ListPair.zip;
inner_product ([1, 2, 3], [1, 2, 3]); (* =&gt; 14 *)
</code></pre><ul>
<li>カリー化</li>
</ul>
<pre><code class="language-standard-ml" data-lang="standard-ml">fun findManabiya list = List.find (String.isPrefix &quot;manabiya&quot;) list
val findManabiya = List.find (String.isPrefix &quot;manabiya&quot;)
</code></pre><ul>
<li>無名関数</li>
</ul>
<pre><code class="language-standard-ml" data-lang="standard-ml">String.tokens (fn c =&gt; c = #&quot; &quot; orelse c = #&quot;\n&quot;)
</code></pre><p>===</p>
<h1 id="heading15">データコピーの話</h1>
<hr>
<ul>
<li>リストを2回コピーしてるけど遅くない？</li>
</ul>
<pre><code class="language-standard-ml" data-lang="standard-ml">fun inner_product l1 = let
  val l2 = ListPair.zip l1
  val l3 = List.map op* l2
in
  List.foldl op+ 0 l3
end
</code></pre><ul>
<li>もうちょっと一般に世の中のアルゴリズムを実装すると遅くない？</li>
</ul>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading16">データコピーの話</h1>
<hr>
<ul>
<li>リストを2回コピーしてるけど遅くない？
<ul>
<li>言語による</li>
<li><a href="https://gist.github.com/KeenS/35345a4661dc696f467abd2de830568d">1倍〜100倍遅い</a>
<ul>
<li>関数型言語に向いたGCアルゴリズムの採用</li>
<li>最適化で消せる</li>
</ul>
</li>
</ul>
</li>
<li>もうちょっと一般に世の中のアルゴリズムを実装すると遅くない？
<ul>
<li>A1. 遅い部分は諦めて副作用を使う</li>
<li>A2. 関数型向きデータ構造/アルゴリズムを使う
<ul>
<li><a href="http://asciidwango.jp/post/160831986220/%E7%B4%94%E7%B2%8B%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0">純粋関数型データ構造</a></li>
<li><a href="http://shop.ohmsha.co.jp/shopdetail/000000004066/">関数プログラミング 珠玉のアルゴリズムデザイン</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="clojure">Clojureの特徴</h1>
<hr>
<ul>
<li>デフォルトイミュータブルなLisp方言</li>
<li>イミュータブルHashMap/Set
<ul>
<li>イミュータブルだけどデータを全部コピーする訳ではない</li>
<li><a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">HAMT</a></li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">assoc </span><span class="p">{</span><span class="ss">:name</span> <span class="s">&#34;κeen&#34;</span><span class="p">}</span> <span class="ss">:age</span> <span class="mi">25</span><span class="p">)</span>
  <span class="c1">; -&gt;{:age 25, :name &#34;κeen&#34;}</span>
</code></pre></div><ul>
<li>並列プログラミングに強い
<ul>
<li>データ競合が起きない</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="sml">SMLの特徴</h1>
<hr>
<ul>
<li>強い静的型付</li>
<li>普通に破壊的変更あるよ</li>
<li>モジュールによるカプセル化</li>
<li>ファンクタによる依存の注入</li>
</ul>
<p>===</p>
<h1 id="sml1">SMLのコード例</h1>
<hr>
<ul>
<li>モジュールによるカプセル化
<ul>
<li>データに対する操作を一箇所に集めるのは変わらない</li>
</ul>
</li>
</ul>
<pre><code class="language-standard-ml" data-lang="standard-ml">structure MyList: sig
              type t
              val len: t -&gt; int
              val get: t -&gt; int -&gt; int
          end = struct
    type t = int list
    val len = List.length
    fun get (x::xs) 0 = x
      | get (x::xs) n = get xs (n-1)
end

</code></pre><p>===</p>
<h1 id="sml2">SMLのコード例</h1>
<hr>
<ul>
<li>ファンクタによる依存の注入</li>
</ul>
<pre><code class="language-standard-ml" data-lang="standard-ml">functor Make(Foldable: sig
                 type 'a t
                 val fold: ('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a t -&gt; 'b
             end) = struct
    val sum = Foldable.fold op+ 0
end
</code></pre><p>===</p>
<h1 id="haskellghc">Haskell(GHC)の特徴</h1>
<hr>
<ul>
<li>強い静的型付け</li>
<li>強力な型システム</li>
<li>型クラスによるデータ抽象</li>
<li>純粋
<ul>
<li>破壊的変更とIOを基本許さない</li>
<li>全て式になる
<ul>
<li>雑にいうとセミコロンなしでプログラミングする</li>
</ul>
</li>
<li>入力からのみ出力が決まる → 型をみたら関数の使い方が大体分かる</li>
</ul>
</li>
<li>遅延評価
<ul>
<li>必要になるまで値を計算しない
<ul>
<li>評価の順番も変わる</li>
</ul>
</li>
<li>純粋なのでプログラムの結果は変わらない
<ul>
<li>(細かいことを言うと無限ループの挙動が違うけど)</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="haskellghc-element-stylefontsize-calcvartitlefontsize--08">Haskell(GHC)のコード例&lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.8)&quot;&ndash;&gt;</h1>
<hr>
<ul>
<li>型クラスによるデータ抽象</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="cm">{-</span><span class="cm"># LANGUAGE NamedFieldPuns #</span><span class="cm">-}</span>

<span class="kr">class</span> <span class="kt">Drawable</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">draw</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>

<span class="kr">class</span> <span class="kt">Movable</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">move</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>


<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Int</span> <span class="kt">Int</span>
  <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">instance</span> <span class="kt">Movable</span> <span class="kt">Point</span> <span class="kr">where</span>
  <span class="n">move</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Triangle</span> <span class="ow">=</span> <span class="kt">Triangle</span> <span class="p">{</span>
  <span class="n">a</span><span class="ow">::</span> <span class="kt">Point</span><span class="p">,</span>
  <span class="n">b</span><span class="ow">::</span> <span class="kt">Point</span><span class="p">,</span>
  <span class="n">c</span><span class="ow">::</span> <span class="kt">Point</span>
<span class="p">}</span>
  <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">instance</span> <span class="kt">Drawable</span> <span class="kt">Triangle</span> <span class="kr">where</span>
  <span class="n">draw</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="kr">instance</span> <span class="kt">Movable</span> <span class="kt">Triangle</span> <span class="kr">where</span>
  <span class="n">move</span> <span class="kt">Triangle</span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">}</span> <span class="n">d</span> <span class="ow">=</span> <span class="kt">Triangle</span> <span class="p">{</span>
    <span class="n">a</span> <span class="ow">=</span> <span class="n">move</span> <span class="n">a</span> <span class="n">d</span><span class="p">,</span>
    <span class="n">b</span> <span class="ow">=</span> <span class="n">move</span> <span class="n">b</span> <span class="n">d</span><span class="p">,</span>
    <span class="n">c</span> <span class="ow">=</span> <span class="n">move</span> <span class="n">c</span> <span class="n">d</span>
    <span class="p">}</span>
</code></pre></div><p>===</p>
<h1 id="haskellghc-element-stylefontsize-calcvartitlefontsize--081">Haskell(GHC)と逐次処理&lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.8)&quot;&ndash;&gt;</h1>
<hr>
<blockquote>
<p>雑にいうとセミコロンなしでプログラミングする</p>
</blockquote>
<ul>
<li>逐次処理はどうするの？(e.g. 1行読んでそれを出力)
<ol>
<li>プログラムを値として扱って合成する</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">Program1</span> <span class="err">○</span> <span class="kt">Program2</span> <span class="ow">-&gt;</span> <span class="kt">Program2&#39;</span>
</code></pre></div><ol start="2">
<li>直前の値も受け取れるようにする</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">Program1</span> <span class="err">○</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Program2</span> <span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Program2&#39;</span>
</code></pre></div><ol start="3">
<li>色々な種類のプログラムに対応可能</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">Program</span> <span class="n">a</span> <span class="err">○</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Program</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Program</span> <span class="n">b</span>
</code></pre></div><ol start="4">
<li>具体的には<code>&gt;&gt;=</code>という演算子で合成
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">getLine</span> <span class="o">&gt;&gt;=</span> <span class="n">putStrLn</span>
</code></pre></div></li>
<li>シンタックスシュガー</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
  <span class="n">putStrLn</span> <span class="n">s</span>
</code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="haskellghc-element-stylefontsize-calcvartitlefontsize--082">Haskell(GHC)の遅延評価&lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.8)&quot;&ndash;&gt;</h1>
<hr>
<ul>
<li>遅延評価
<ul>
<li>同等のCのコードよりずっと速い</li>
<li>計算量が変わる</li>
<li><code>tarai(12, 6, 0)</code>で2,604,860回 vs 110回</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">tarai</span><span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">tarai</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span>
              <span class="kr">then</span> <span class="n">y</span>
              <span class="kr">else</span> <span class="n">tarai</span> <span class="p">(</span><span class="n">tarai</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">y</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="n">tarai</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">z</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">tarai</span> <span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span>
<span class="nf">tarai</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">tarai</span><span class="p">(</span>
                 <span class="n">tarai</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="p">,</span>
                 <span class="n">tarai</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="p">,</span>
                 <span class="n">tarai</span><span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                 <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><!-- raw HTML omitted -->
<p>===</p>
<h1 id="oop5">関数型言語のOOP</h1>
<hr>
<ul>
<li>OCamlのO</li>
<li>SMLのモジュールは割とOOPに似てる？</li>
<li><code>|&gt;</code> は割とメソッドチェーンに似てる？</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="mi">1</span><span class="o">.</span><span class="o">.</span><span class="mi">999</span>
 <span class="o">|&gt;</span> <span class="p"></span><span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rem</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rem</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="p">)</span>
 <span class="o">|&gt;</span> <span class="p"></span><span class="nc">Enum</span><span class="o">.</span><span class="n">sum</span>
 <span class="o">|&gt;</span> <span class="p"></span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span>
</code></pre></div><p>===</p>
<h1 id="fp-element-stylefontsize-calcvartitlefontsize--08">オブジェクト指向言語のFP&lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.8)&quot;&ndash;&gt;</h1>
<hr>
<ul>
<li>高階関数
<ul>
<li>Rubyのブロックも</li>
</ul>
</li>
<li>JavaのStream API
<ul>
<li><a href="https://www.amazon.co.jp/dp/1937785467">FP in Java</a></li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="-element-stylefontsize-calcvartitlefontsize--09">結局どういう関係なの？&lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.9)&quot;&ndash;&gt;</h1>
<hr>
<ul>
<li>大きな部分では変わらない
<ul>
<li>関心毎にコードを集めて粗結合な部品を組み立てる</li>
</ul>
</li>
<li>オブジェクト指向は設計より</li>
<li>関数型はコーディングより</li>
<li>完全に相反するものでもない
<ul>
<li>マルチパラダイム言語</li>
</ul>
</li>
<li>相性の悪い点もある</li>
</ul>
<p>===</p>
<h1 id="-element-stylefontsize-calcvartitlefontsize--075">プログラミング言語のこれから&lt;!&ndash; .element: style=&quot;font-size: calc(var(&ndash;title-font-size) * 0.75)&quot;&ndash;&gt;</h1>
<hr>
<ul>
<li>今回挙げた言語はかなり古い言語
<ul>
<li>Ruby, Java, Haskell, SMLは20年以上前に出来た</li>
</ul>
</li>
<li>古い言語は当時技術を元に設計される
<ul>
<li>ハードウェア</li>
<li>コンパイル技法</li>
<li>ベストプラクティス</li>
</ul>
</li>
<li>これからは新しい概念、いいとこ取りの言語設計も出てくる？
<ul>
<li>並列並行サポート</li>
<li>代数的データ型とパターンマッチ、無名関数</li>
<li>所有権</li>
<li>などなど</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading17">まとめ</h1>
<hr>
<ul>
<li>オブジェクト指向/関数型プログラミングとはパラダイムのことだよ</li>
<li>オブジェクト指向/関数型言語とはそのパラダイムを支援する言語のことだよ
<ul>
<li>言語とパラダイムの区別を明確に！</li>
</ul>
</li>
<li>それぞれ目的もアプローチも違うよ</li>
<li>両方手札に持って使い分けようね</li>
<li>これ以外にも新しい言語にも注目</li>
</ul>
<p><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->

        </div>
    </div>
</article>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2019. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="http://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script src="//KeenS.github.io/reveal.js/lib/js/head.min.js"></script>
<script src="//KeenS.github.io/reveal.js/js/reveal.js"></script>

<script>

 
 
 Reveal.initialize({
     controls: true,
     progress: true,
     history: false,
     center: false,
     slideNumber: true,

     
     transition: Reveal.getQueryHash().transition || 'none', 

     
     
     

     
     dependencies: [
	 { src: '\/\/KeenS.github.io\/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/highlight.js/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
         { src: '\/\/KeenS.github.io\/reveal.js/plugin/math/math.js', async: true }
     ]
 });

</script>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>


<script>
 window.onload = 
     
     (function(document, Reveal) {
         return function() {
             var page_header = document.getElementById("page-header");
             var article_header = document.getElementById("article-header");


             function displayHeader() {
                 article_header.style.display = "block";
                 page_header.style.display = "block";

             }
             function hideHeader() {
                 article_header.style.display = "none";
                 page_header.style.display = "none";
             }
             Reveal.addEventListener( 'slidechanged', function( event ) {
                 if (event.indexh === 0 && event.indexv === 0) {
                     displayHeader();
                 } else {
                     hideHeader();
                 }
             } );

         }
     })(document, Reveal);
</script>
