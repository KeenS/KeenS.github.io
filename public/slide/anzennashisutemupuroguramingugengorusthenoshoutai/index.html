<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="安全なシステムプログラミング言語Rustへの招待 | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="IIJ Labでの発表用。主にシステムプログラミング言語経験者向けの内容" />

        <title>安全なシステムプログラミング言語Rustへの招待 | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href="//KeenS.github.io/reveal.js/css/reveal.css">
        <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css'>
        <link rel="stylesheet" href="//KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="//KeenS.github.io/css/liquorice.css" />
        <link rel="stylesheet" href="//KeenS.github.io/highlight.js/styles/agate.css">
        <link rel="stylesheet" href="//KeenS.github.io/css/cleanveal.css" type="text/css" />
        <link rel="apple-touch-icon" sizes="180x180" href="//KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="//KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="//KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <link rel="apple-touch-icon-precomposed" href="//KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="alternate" href="" type="application/rss+xml" title="κeenのHappy Hacκing Blog" />
        
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script>
         if( window.location.search.match( /print-pdf/gi ) ) {
             var link = document.createElement( 'link' );
             link.rel = 'stylesheet';
             link.type = 'text/css';
             link.href = '\/\/KeenS.github.io\/reveal.js/css/print/pdf.css';
             document.getElementsByTagName( 'head' )[0].appendChild( link );
         }
        </script>
        
    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="//KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="//KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="//KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






<article id="article-container" class="li-article" style="height: 100%">
    <header id="article-header" class="li-article-header" style="position:fixed;z-index:10;">
        <h1 class="li-article-title">安全なシステムプログラミング言語Rustへの招待</h1>
        <div class="li-article-meta">
    <time class="li-article-date">2019-11-18</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="//KeenS.github.io/categories/rust">Rust</a>
        </li>
    
</ul>

</div>

    </header>
    <div class="reveal">
        <div class="slides">
            <!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="about-me">About Me</h1>
<hr>
<p><img src="//KeenS.github.io/images/kappa.png" alt="κeenのアイコン"> <!-- raw HTML omitted --></p>
<ul>
<li>κeen</li>
<li><a href="https://twitter.com/blackenedgold">@blackenedgold</a></li>
<li>Github: <a href="https://github.com/KeenS">KeenS</a></li>
<li>GitLab: <a href="https://gitlab.com/blackenedgold">blackenedgold</a></li>
<li><a href="https://idein.jp/">Idein Inc.</a>のエンジニア</li>
</ul>
<ul>
<li>2年半くらい仕事でRustを書いている</li>
</ul>
<ul>
<li>Lisp, ML, Rust, Shell Scriptあたりを書きます</li>
<li><a href="https://gihyo.jp/book/2019/978-4-297-10559-4">実践Rust入門</a>の共著者</li>
</ul>
<p>===</p>
<h1 id="rust">Rustって言語があるよ</h1>
<hr>
<ul>
<li>システムプログラミング言語</li>
<li>2015年に1.0.0がリリース</li>
</ul>
<ul>
<li>リリース前に破壊的変更しまくったので1.0以降はかなり安定してる</li>
<li>0.x時代はもちろんのこと、1.0-alphaのあとに1.0-alpha2が出たりもした</li>
</ul>
<ul>
<li>6週間毎にコンパイラのリリースで、今は1.39.0</li>
<li>C++03, C++11 みたいなノリでRust 2015とRust 2018の2つの仕様がある
<ul>
<li>コンパイラはずっと両方サポート</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading">事例</h1>
<hr>
<ul>
<li><a href="https://github.com/firecracker-microvm/firecracker">firecracker</a>: AWS Lambdaのセキュアコンテナ</li>
<li><a href="https://www.wired.com/2016/03/epic-story-dropboxs-exodus-amazon-cloud-empire/">Magick Pocket</a>: DropBoxのストレージマネージャ。</li>
<li><a href="https://servo.org/">Servo</a>: Mozillaの新ブラウザエンジンの実験プロジェクト。一部の成果がFirefoxに反映されている。</li>
<li><a href="https://redox-os.org/">Redox</a>: OS</li>
<li><a href="https://github.com/tikv/tikv">TiKV</a>: KVS</li>
</ul>
<p>===</p>
<h1 id="heading1">システムプログラミング言語っぽさ</h1>
<hr>
<ul>
<li>ランタイムレス
<ul>
<li>でもメモリは自動管理</li>
</ul>
</li>
<li>Cと相互に連携できる
<ul>
<li>C FFIだけでなくCからRustも呼べる</li>
</ul>
</li>
<li>それっぽいプロジェクトもいくつか
<ul>
<li><a href="https://github.com/libpnet/libpnet">libpnet</a>: 生パケット扱うライブラリ</li>
<li><a href="https://github.com/rust-embedded/awesome-embedded-rust">awesome-embedded-rust</a>: 組み込み系のキュレーション</li>
<li><a href="https://tokio.rs/">tokio</a>: 非同期イベントループのライブラリ</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading2">メモリ配置</h1>
<hr>
<p>この構造体のサイズは？</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fd32ac47011842c8f12c0fc1425131c1">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Hoge</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">c1</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">i2</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">c2</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Hoge</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="heading3">メモリ配置</h1>
<hr>
<p>デフォルトでサイズが最小になるように詰める</p>
<pre><code class="language-console" data-lang="console">+----+----+----+---------+
| c1 | c1 |\\\\|   i2    |
+----+----+----+---------+
</code></pre><p>===</p>
<h1 id="heading4">メモリ配置</h1>
<hr>
<p>この構造体のサイズは？</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d4290de0065ba2951a486676fafe2ecf">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="cp">#[</span><span class="cp">repr(C)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Hoge</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">c1</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">i2</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">c2</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Hoge</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="heading5">メモリ配置</h1>
<hr>
<p><code>repr(C)</code> をつけると見慣れたメモリ配置になる</p>
<pre><code class="language-console" data-lang="console">+----+----+---------+----+----+
| c1 |\\\\|   i2    | c1 |\\\\|
+----+----+---------+----+----+
</code></pre><p>===</p>
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="rust1">普通のRust</h1>
<hr>
<ul>
<li>便利なイテレータ</li>
<li>素数最初の25個を列挙</li>
</ul>
<p><a href="https://is.gd/Hh0H42">run</a>
<a href="https://godbolt.org/z/JC-DRx">asm</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="mi">2</span><span class="p">.</span><span class="p">.</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="o">&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">.</span><span class="p">.</span><span class="n">n</span><span class="p">)</span><span class="p">.</span><span class="n">all</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="rust2">普通のRust</h1>
<hr>
<ul>
<li>トレイト便利
<ul>
<li>C++のconcept相当らしい</li>
</ul>
</li>
<li>ポリモーフィズムは大抵トレイト経由で実現
<ul>
<li>静的ディスパッチ</li>
<li>演算子のオーバーローオ</li>
<li>動的ディスパッチ</li>
</ul>
</li>
<li>メタプログラミングでいくつかのトレイトは自動で実装できる</li>
</ul>
<p>===</p>
<h1 id="rust3">普通のRust</h1>
<hr>
<p>トレイト</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=e9ba56aa24da63eed8eb3787f2b10ac5">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// `derive(トレイト)` アトリビュートをつけると
</span><span class="c1"></span><span class="c1">// 自動でトレイトを実装してくれる
</span><span class="c1"></span><span class="cp">#[</span><span class="cp">derive(Debug, Clone, PartialEq, Eq)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Cartesian</span><span class="p">(</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="cp">#[</span><span class="cp">derive(Debug, Clone, PartialEq, Eq)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Polar</span><span class="p">(</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="mi">664</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// トレイトを定義
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">ToCartesian</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cartesian</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="err">そ</span><span class="err">れ</span><span class="err">ぞ</span><span class="err">れ</span><span class="err">の</span><span class="err">型</span><span class="err">に</span><span class="err">実</span><span class="err">装</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">ToCartesian</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Cartesian</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cartesian</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">ToCartesian</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Polar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cartesian</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">1.</span><span class="n">cos</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">sin</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// ToCartesianを実装している型のみ渡せる
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">print_point</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">ToCartesian</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;({}, {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Polar</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Debugをderiveしたので印字できる
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// PartialEqをderiveしたので比較できる
</span><span class="c1"></span><span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// ToCartesianを実装したので `print_point` に渡せる
</span><span class="c1"></span><span class="w">    </span><span class="n">print_point</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="rust4">普通のRust</h1>
<hr>
<ul>
<li>割と型検査で事前に不正なコードを弾く</li>
<li>テンプレートと違ってジェネリクス定義時点で型が合ってないとコンパイルできない
<ul>
<li>以下のコードはこれを書いた時点でコンパイルエラー</li>
</ul>
</li>
</ul>
<pre><code>fn print_point&lt;P&gt;(p: P) {
    let p = p.to_cartesian();
    println!(&quot;({}, {})&quot;, p.0, p.1);
}
</code></pre><p>===</p>
<h1 id="rust5">普通のRust</h1>
<hr>
<ul>
<li>便利な <code>enum</code> (代数的データ型)</li>
<li><a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>Ordering</code></a> も便利</li>
<li><code>impl</code> ブロックでデータ型にメソッドを生やせる</li>
</ul>
<p><a href="https://is.gd/Cpgdpo">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Red</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Black</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Leaf</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">color</span>: <span class="nc">Color</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">l</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">v</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">r</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_member</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">Tree</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">Leaf</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">Ordering</span>::<span class="n">Less</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">is_member</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">Ordering</span>::<span class="n">Greater</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">is_member</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="rust6">普通のRust</h1>
<hr>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> 型とパターンマッチはエラーハンドリングに便利
<ul>
<li>Rustに例外はない。</li>
</ul>
</li>
<li>「例外が上がる」という概念ではなくてデータ型という第一級の値で表現することで扱いやすさが向上
<ul>
<li>メソッドを生やしたりできる</li>
</ul>
</li>
</ul>
<pre><code>use std::io::{self, Write};
use std::fs::File;

fn write_string(filename: &amp;str, content: &amp;str) -&gt; io::Result&lt;()&gt; {
    let mut file = match File::create(filename) {
        Ok(file) =&gt; file,
        Err(e) =&gt; {
            eprintln!(&quot;an error occured when opening file: {}&quot;, e);
            return
        }
    };
    match file.write_all(&amp;content.as_bytes())? {
        Ok(file) =&gt; (),
        Err(e) =&gt; {
            eprintln!(&quot;an error occured when writing to file: {}&quot;, e);
            return
        }
    }
    Ok(())
}
</code></pre><p>===</p>
<h1 id="rust7">普通のRust</h1>
<hr>
<ul>
<li>早期リターンする記法もある
<ul>
<li><code>Result</code> (または<code>Option</code>) 型に <code>?</code> 演算子でエラーなら関数から返る</li>
</ul>
</li>
</ul>
<pre><code>use std::io::{self, Write};
use std::fs::File;

fn write_string(filename: &amp;str, content: &amp;str) -&gt; io::Result&lt;()&gt; {
    let mut file = File::create(filename)?;
    file.write_all(&amp;content.as_bytes())?;
    Ok(())
}
</code></pre><p>===</p>
<h1 id="rust8">普通のRust</h1>
<hr>
<ul>
<li>UNIX APIの便利ラッパー</li>
<li>パターンマッチに便利な仕組み</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">nix</span>::<span class="n">unistd</span>::<span class="p">{</span><span class="n">fork</span><span class="p">,</span><span class="w"> </span><span class="n">ForkResult</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">fork</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">       </span><span class="nb">Ok</span><span class="p">(</span><span class="n">ForkResult</span>::<span class="n">Parent</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">           </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Continuing execution in parent process, new child has pid: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">child</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">       </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">       </span><span class="nb">Ok</span><span class="p">(</span><span class="n">ForkResult</span>::<span class="n">Child</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;I&#39;m a new child process&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">       </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Fork failed&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="rust9">普通のRust</h1>
<hr>
<ul>
<li>Cargo
<ul>
<li>便利なビルドツール/パッケージマネージャ</li>
<li>プラグインの仕組みもある</li>
<li>今回は <code>cargo-edit</code> を使ってる (<code>cargo install cargo-edit</code> で入る)</li>
</ul>
</li>
</ul>
<pre><code class="language-console" data-lang="console">$ cargo new fork-example
$ cargo add nix
$ cd fork_example
$ edit src/main.rs
$ cargo run
</code></pre><p>===</p>
<h1 id="why-rust-over-cc">Why Rust (over C/C++)?</h1>
<hr>
<ul>
<li>安全
<ul>
<li>セキュリティ的な嬉しさ</li>
<li>開発面での余計なデバッグの不要</li>
</ul>
</li>
<li>生産性が高い
<ul>
<li>便利な機能があることと低レイヤが扱えることは両立する</li>
<li>例えば最近入った <code>async</code> / <code>await</code> はOSがなくても動く</li>
</ul>
</li>
<li>Cargo(ビルドツール) + crates.io(パッケージレジストリ)が便利</li>
<li>活発なコミュニティ</li>
</ul>
<p>===</p>
<h1 id="heading6">速度と機能の話</h1>
<hr>
<ul>
<li><a href="https://github.com/ixy-languages/ixy-languages/blob/master/Rust-vs-C-performance.md">Why is Rust slightly slower than C?</a>
<ul>
<li>ネットワークドライバを各言語で実装してみる実験</li>
</ul>
</li>
<li>RustはCより少しだけ遅い。でもIPCはRustの方が断然いい。</li>
<li>→ CはCPUを使ってる気になってるけど使いきれてないのでは？</li>
<li>→ CPUも進化してるんだから言語も進化しましょう</li>
</ul>
<p>===</p>
<h1 id="rust10">Rustの安全性について</h1>
<hr>
<p>安全 ≒ 未定義動作を踏まない</p>
<ul>
<li>NULL Pointerはない。
<ul>
<li>令和にもなってセグフォのデバッグはしたくない</li>
</ul>
</li>
<li>use after freeができない</li>
<li>配列の範囲外アクセスが検査される</li>
<li>データ競合(data race)が起きない
<ul>
<li>≒ 多数のスレッドから1つのデータに同時にアクセスできない</li>
</ul>
</li>
<li>競合状態(race condition) は防げないので注意
<ul>
<li>デッドロックとか</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading7">範囲外アクセス</h1>
<hr>
<ul>
<li>(他の安全性とは違って)範囲外アクセスは実行時に検査される
<ul>
<li>範囲外アクセスを静的に弾くのはかなり難しいことが知られている</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// コンパイルは通るけど実行時にパニック
</span><span class="c1"></span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">
</span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading8">範囲外アクセス</h1>
<hr>
<ul>
<li>ただし固定長配列に定数でアクセスする場合はコンパイルエラーにしてくれる</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// コンパイルエラー
</span><span class="c1"></span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">
</span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading9">所有権</h1>
<hr>
<ul>
<li>値にはライフタイムがある</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Data</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="c1">// `data` のライフタイムはこのスコープ
</span><span class="c1"></span><span class="p">}</span><span class="w"> </span><span class="c1">// ← ここで `data` がfreeされる
</span><span class="c1"></span><span class="c1">// ここでは `data` にアクセスできない
</span></code></pre></div><p>===</p>
<h1 id="heading10">所有権</h1>
<hr>
<ul>
<li>所有権は移動する</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Data</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// ここで `data` の所有権が `tmp` に移る
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// 以降 `data` にアクセスするとコンパイルエラー
</span><span class="c1"></span><span class="c1">// tmpが死ぬと `data` はfreeされる
</span></code></pre></div><p>===</p>
<h1 id="heading11">所有権</h1>
<hr>
<ul>
<li>関数に渡しても移動する</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">take_data</span><span class="p">(</span><span class="n">_</span>: <span class="nc">Data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Data</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">take_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// 以降 `data` にアクセスするとコンパイルエラー
</span><span class="c1"></span><span class="c1">// take_data(data);
</span></code></pre></div><p>===</p>
<h1 id="heading12">所有権</h1>
<hr>
<ul>
<li>関数に渡しても移動する</li>
<li>…えっ</li>
</ul>
<p>===</p>
<h1 id="heading13">借用</h1>
<hr>
<ul>
<li>データを一時的に「貸す」こともできる</li>
<li><code>&amp;</code> で参照を取ると貸すことになる</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">borrow_data</span><span class="p">(</span><span class="n">_</span>: <span class="kp">&amp;</span><span class="nc">Data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Data</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// 貸す
</span><span class="c1"></span><span class="n">borrow_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// 返してもらったらまた使える
</span><span class="c1"></span><span class="n">borrow_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="heading14">借用</h1>
<hr>
<ul>
<li><code>&amp;</code> で参照を取ると貸すことになる</li>
<li>参照はポインタの意味もあるけど普段はあんまりポインタとしては意識してない
<ul>
<li>カジュアルに構造体の値渡しをする</li>
<li>「借用するかどうか」で使い分ける</li>
<li>所有するポインタ (<code>Box</code>) もあるけどたまにしか使わない</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading15">借用とライフタイム</h1>
<hr>
<ul>
<li>借りたデータを元のデータより長く生かせない
<ul>
<li>要するにdangling pointer禁止</li>
</ul>
</li>
<li>長く生かそうとするとコンパイルエラー</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// このコードはコンパイルエラー
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">new_data</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Data</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Data</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">&amp;</span><span class="n">data</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// data はここで死ぬので関数から返せない
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="heading16">借用と変更</h1>
<hr>
<ul>
<li>以下の関数の返り値は？</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">int</span>
<span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>===</p>
<h1 id="heading17">借用と変更</h1>
<hr>
<ul>
<li>以下の関数の返り値は？
<ul>
<li><code>&amp;mut</code> は可変ら参照を表わす</li>
<li>Cでいう普通の <code>&amp;</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="heading18">借用と変更</h1>
<hr>
<ul>
<li>Rustでは1つの変数の可変な参照を複数作れない
<ul>
<li>以下はコンパイルエラー</li>
</ul>
<pre><code>let mut a = 1;
func(&amp;mut a, &amp;mut a)
</code></pre><ul>
<li>Rustの <code>memcpy</code> は簡単になる</li>
</ul>
</li>
<li>RustはPointer Aliasの制約が強い
<ul>
<li>→ 挙動が分かりやすい</li>
<li>→ コンパイラが最適化しやすい</li>
</ul>
</li>
<li>不変な借用があるときに可変な参照も作れない
<ul>
<li>要するにコンパイル時 Read-Write Lock</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading19">借用と変更</h1>
<hr>
<ul>
<li>不変な借用があるときに可変な参照も作れない</li>
</ul>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=2d2d3e2fbb67247147ef1cbde75fcbbc">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="nullable">Nullableな値</h1>
<hr>
<ul>
<li>全てのポインタがNullableなのは酷いけどNullがないのも不便な気がする
<ul>
<li>findして結果がなかったらNullを返したい</li>
</ul>
</li>
<li>ポインタとは関係なくNullableであることを表わすデータ型を用意して解決
<ul>
<li><code>i32</code> とかもnullableにできる</li>
<li>メソッドを生やせる</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option</a></li>
<li><code>Option&lt;Pointer&gt;</code> は最適化でただのポインタになる</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="heading20">所有権の例外</h1>
<hr>
<ul>
<li><code>i32</code> とか小さい型をいちいち貸し借りしたくない
<ul>
<li>湯水のごとくじゃぶじゃぶ使いたい</li>
</ul>
</li>
<li>そういう型は無制限に使える仕組みがある</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>トレイトを実装した型は勝手にコピーしてくれる
<ul>
<li>よくRustで所有権を試そうとしてる人がはまりがち</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">take_i32</span><span class="p">(</span><span class="n">_</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">take_i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// 何度でも呼べる
</span><span class="c1"></span><span class="n">take_i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">take_i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="heading21">所有権とか</h1>
<hr>
<ul>
<li>正直スライドだけでは伝えきれない</li>
<li>理解しようとすると<a href="https://doc.rust-jp.rs/book/second-edition/ch04-00-understanding-ownership.html">公式ドキュメント</a>を読むのがよい
<ul>
<li>あとは手を動かさないと分からない。</li>
</ul>
</li>
<li>雑にまとめると
<ul>
<li>データには所有者がいる</li>
<li>ポインタは実体があると保証できる範囲でしか作れない
<ul>
<li>NULL poinerやdangling pointerは存在しない</li>
</ul>
</li>
<li>Writeは排他</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading22">所有権とか</h1>
<hr>
<ul>
<li>結構アプリケーションの設計に関わってくる
<ul>
<li>雑な設計だとすぐに破綻する</li>
<li>それゆえ難しいといわれがち</li>
</ul>
</li>
<li>所有者を意識すると綺麗になりがち
<ul>
<li>長寿のデータ型に持たせる
<ul>
<li><code>App</code> とか <code>Config</code> とか</li>
</ul>
</li>
<li>データ構造は所有者になりがち
<ul>
<li><code>HashMap</code> とか</li>
</ul>
</li>
<li>処理のフローを考えると余計なコピーを省ける
<ul>
<li>HTTPの場合は <code>Request</code> の生存期間で十分だったり</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="1">所有権小話1</h1>
<hr>
<ul>
<li><code>HashMap</code> はデータを所有するので <code>get</code> / <code>get_mut</code> だとデータを借りることしかできない
<ul>
<li>取り出したいのが不変の参照か可変の参照かでメソッドが分かれてるのが普通</li>
</ul>
</li>
<li>データを取り出したいときは <code>remove</code> を使う</li>
</ul>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c633e1e2a6935a12238795f68c22b156">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;one&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;two&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;three&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">.</span><span class="n">into_iter</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;no data&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;got data: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="2">所有権小話2</h1>
<hr>
<ul>
<li>Rustにリソースを開放するAPIはない
<ul>
<li><code>File</code> の <code>open</code> はあるけど <code>close</code> はない</li>
<li><code>Lock</code> の <code>lock</code> はあるけど <code>free</code> はない</li>
</ul>
</li>
<li>RAIIで管理されるのでデータの <code>free</code> のときに一緒に開放される</li>
</ul>
<p><a href="https://is.gd/KKm9Vb">run</a></p>
<pre><code class="language-run" data-lang="run">use std::io::{self, Write};
use std::fs::File;

fn write_string(filename: &amp;str, content: &amp;str) -&gt; io::Result&lt;()&gt; {
    // Fileをwriteモードでopen
    let mut file = File::create(filename)?;
    file.write_all(&amp;content.as_bytes())?;
    Ok(())
    // fileがスコープを抜けるときに自動でcloseされる
}
</code></pre><p>===</p>
<h1 id="rust11">Rustの進歩</h1>
<hr>
<ul>
<li>Rustは問題がある「かもしれない」コードを弾く
<ul>
<li>不思議な力で安全になる訳ではなくて、養成ギプス的にユーザに安全なコードを書かせる</li>
</ul>
</li>
<li>安全にはなるが窮屈
<ul>
<li>極端な話、全てのコードを弾けば実行時エラーは出ない</li>
</ul>
</li>
<li>Rustの進歩でコンパイルが通る範囲もちょっとづつ広がっている</li>
</ul>
<p>===</p>
<h1 id="rust12">Rustの進歩</h1>
<hr>
<ul>
<li>昔は以下のコードがコンパイルできなかった
<ul>
<li>昔 = 1年前</li>
</ul>
</li>
<li>最近は制御フローまで見て問題なければコンパイルを通す</li>
</ul>
<p><a href="https://is.gd/ALWpec">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">insert_or_update</span><span class="p">(</span><span class="n">map</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// get_mutで可変の参照
</span><span class="c1"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">          </span><span class="c1">// その参照が生きている間に更新
</span><span class="c1"></span><span class="w">          </span><span class="n">map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="opt-out">所有権をopt out</h1>
<hr>
<ul>
<li>所有権は便利だけどそれだと書けないデータ構造が発生する
<ul>
<li>グラフとか</li>
</ul>
</li>
<li>そういう場合に実行時に所有権/ミュータビリティ検査をするAPIがある
<ul>
<li><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> (参照カウント) … 複数人でデータを共有できる <a href="https://doc.rust-jp.rs/book/second-edition/ch15-04-rc.html">doc</a></li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> … 実行時に借用検査をする <a href="https://doc.rust-jp.rs/book/second-edition/ch15-05-interior-mutability.html">doc</a></li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="opt-out1">所有権をopt out</h1>
<hr>
<ul>
<li>Rustだけど「何でもあり」にできてしまう例</li>
</ul>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=f7b7e132be264a3de565669565c4e454">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">clone</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// data2を変更。 data2はイミュータブルだが
</span><span class="c1"></span><span class="c1">// `RefCell` なので変更できる
</span><span class="c1"></span><span class="o">*</span><span class="n">data2</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// `Rc` なのでdata2の変更がdataにも反映される
</span><span class="c1"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">.</span><span class="n">borrow</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="heading23">並列</h1>
<hr>
<ul>
<li>Rustはスレッドセーフでないプログラムをマルチスレッドで使うとエラーにする</li>
<li>例えば <code>Rc</code> はスレッドアンセーフ(裏でcountの変更があるため)</li>
</ul>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=9198d0f301cc24e503992ed9b127ef59">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">clone</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">*</span><span class="n">data2</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">.</span><span class="n">borrow</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="heading24">並列</h1>
<hr>
<ul>
<li>スレッドセーフなAPIにしたり <code>Mutex</code> を使ったりするとコンパイルが通る
<ul>
<li><code>Arc</code> = Atomic Reference Count</li>
<li><code>Mutex</code> = mutual exclution、要はロック</li>
</ul>
</li>
</ul>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=13757c7015d10f5954a4978baa8d17e5">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="p">{</span><span class="n">Arc</span><span class="p">,</span><span class="w"> </span><span class="n">Mutex</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">clone</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">*</span><span class="n">data2</span><span class="p">.</span><span class="n">lock</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">.</span><span class="n">lock</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="heading25">並列の安全性の舞台裏</h1>
<hr>
<ul>
<li>トレイトで制御している</li>
<li><code>thread::spawn</code> に渡せるのは <code>Send</code> トレイトを実装した型のみ。</li>
<li><code>Rc</code> や <code>RefCell</code> は <code>Send</code> トレイトを実装していない</li>
<li>→ <code>Rc</code> や <code>RefCell</code> を渡そうとするとコンパイルエラーになる</li>
<li>ドキュメントを読まなくてもスレッドセーフか分かるの素敵</li>
</ul>
<p>===</p>
<h1 id="heading26">安全性を捨てるとき</h1>
<hr>
<ul>
<li>Rustを使ってても安全性を捨てないといけないケースがある
<ul>
<li>Cと連携するとき
<ul>
<li>Rustから見たらCはデフォルトで危険</li>
</ul>
</li>
<li>データ構造を実装するとき
<ul>
<li>ハッシュテーブルみたいに未初期化かもしれないメモリを扱うとき</li>
</ul>
</li>
</ul>
</li>
<li>そういうときのエスケープハッチがある
<ul>
<li>その名も <code>unsafe</code></li>
</ul>
</li>
<li><code>unsafe</code> な部分とsafeな部分を区別する仕組みがある</li>
</ul>
<p>===</p>
<h1 id="heading27">安全性を捨ててみる</h1>
<hr>
<ul>
<li><code>unsafe</code> で囲むとやりたい放題できる</li>
</ul>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=6a04ca87dc616a2dfece0aae00e9e981">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ffi</span>::<span class="n">c_void</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="c1">// FFIの関数のプロトタイプ宣言
</span><span class="c1"></span><span class="w">  </span><span class="c1">// 参照とは別のマジのポインタ型
</span><span class="c1"></span><span class="w">  </span><span class="k">fn</span> <span class="nf">free</span><span class="p">(</span><span class="n">p</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">c_void</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="c1">// unsafeで囲むとやりたい放題
</span><span class="c1"></span><span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// ヌルポが作れる！！
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">null_mut</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// ヌルポに書き込める！！
</span><span class="c1"></span><span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// freeできる！！
</span><span class="c1"></span><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// use after freeできる！！
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>===</p>
<h1 id="unsafe-"><code>unsafe</code> の仕組み</h1>
<hr>
<ul>
<li>Rustはいくつかの操作や関数を <code>unsafe</code> とみなす
<ul>
<li>関数は自分で <code>unsafe</code> とマークできる</li>
</ul>
</li>
<li><code>unsafe</code> な操作は <code>unsafe</code> の内側でしかできないようになっている
<ul>
<li><code>unsafe</code> の境界の安全性はユーザが保証する</li>
</ul>
</li>
</ul>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=3e1c98392da16fea45ed23e0d945ff72">run</a></p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// ヌルポインタを作るだけならsafe
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">null_mut</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// ポインタに触るのはunsafe
</span><span class="c1"></span><span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>===</p>
<h1 id="unsafe-1"><code>unsafe</code> の使いどころ</h1>
<hr>
<ul>
<li>基本は使わない。</li>
<li>どう頑張っても <code>unsafe</code> を使わないと実装できないものは仕方なく使う
<ul>
<li>データ構造の実装に多い</li>
<li>標準ライブラリの <a href="https://doc.rust-lang.org/beta/src/alloc/raw_vec.rs.html#315-359"><code>Vec</code></a> とか</li>
</ul>
</li>
<li>めちゃくちゃ速度が重要で、 <code>unsafe</code> を使うとすごく高速化できる場合にはトレードオフを考えて使う
<ul>
<li>スライスの境界外アクセスを無視して行なう <a href="https://doc.rust-lang.org/beta/std/primitive.slice.html#method.get_unchecked"><code>get_unchecked</code></a>とか</li>
</ul>
</li>
<li>C FFIのラッパを書くときはまあ、仕方ない
<ul>
<li>でも最小限に</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading28">活発なコミュニティ</h1>
<hr>
<ul>
<li>「技術的投資」というならその資産のグロースも考えよう</li>
<li>stack overflowの<a href="https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted">最も愛されている言語</a>
<ul>
<li>2016年から4年連続1位</li>
</ul>
</li>
<li><a href="https://msrc-blog.microsoft.com/2019/11/07/using-rust-in-windows/">Microsoft</a>も導入に乗り気</li>
<li>パッケージのセントラルレポジトリ(<a href="https://crates.io">crates.io</a>)がある
<ul>
<li>30,000+ クレート</li>
<li>参考: rubygemsは150,000+ gems</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading29">コミュニティ中心</h1>
<hr>
<ul>
<li>コミュニティベースの開発
<ul>
<li>「Mozillaの言語」ではない。</li>
<li>Mozilaが初期から支援しているだけ。今は<a href="https://www.atmarkit.co.jp/ait/articles/1910/17/news088.html">AWS</a>とかもサポート。</li>
</ul>
</li>
<li>開発はチームによる。チームの会議もDiscordなどで公開
<ul>
<li>やさしい終身の独裁者的な人はいない</li>
</ul>
</li>
<li>コミュニティから意見を吸い上げる→開発チームがロードマップを出すのサイクル
<ul>
<li><a href="https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html">サーベイ</a> とか <a href="https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html">#rust2020</a></li>
<li>機能追加の提案も <a href="https://github.com/rust-lang/rfcs">GitHub</a> から誰でもできる</li>
</ul>
</li>
</ul>
<p>===</p>
<h1 id="heading30">まとめ</h1>
<hr>
<ul>
<li>Rustは安全なシステムプログラミング言語だよ
<ul>
<li>安全とはUBが起きないことだよ</li>
</ul>
</li>
<li>普通にプログラミング言語としても便利だよ</li>
<li>コミュニティに勢いがあるよ</li>
<li>お試しとしても新天地としても良い言語なんじゃないでしょうか</li>
</ul>
<p><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->

        </div>
    </div>
</article>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2019. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="http://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script src="//KeenS.github.io/reveal.js/lib/js/head.min.js"></script>
<script src="//KeenS.github.io/reveal.js/js/reveal.js"></script>

<script>

 
 
 Reveal.initialize({
     controls: true,
     progress: true,
     history: false,
     center: false,
     slideNumber: true,

     
     transition: Reveal.getQueryHash().transition || 'none', 

     
     
     

     
     dependencies: [
	 { src: '\/\/KeenS.github.io\/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: '\/\/KeenS.github.io\/highlight.js/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
	 { src: '\/\/KeenS.github.io\/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
         { src: '\/\/KeenS.github.io\/reveal.js/plugin/math/math.js', async: true }
     ]
 });

</script>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>


<script>
 window.onload = 
     
     (function(document, Reveal) {
         return function() {
             var page_header = document.getElementById("page-header");
             var article_header = document.getElementById("article-header");


             function displayHeader() {
                 article_header.style.display = "block";
                 page_header.style.display = "block";

             }
             function hideHeader() {
                 article_header.style.display = "none";
                 page_header.style.display = "none";
             }
             Reveal.addEventListener( 'slidechanged', function( event ) {
                 if (event.indexh === 0 && event.indexv === 0) {
                     displayHeader();
                 } else {
                     hideHeader();
                 }
             } );

         }
     })(document, Reveal);
</script>
