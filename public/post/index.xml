<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on κeenのHappy Hacκing Blog</title>
    <link>/post/</link>
    <description>Recent content in Posts on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Wed, 02 Mar 2016 00:05:03 +0900</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>リージョンとRustの返り値</title>
      <link>/blog/2016/03/02/ri_jontorustnokaerichi</link>
      <pubDate>Wed, 02 Mar 2016 00:05:03 +0900</pubDate>
      
      <guid>/blog/2016/03/02/ri_jontorustnokaerichi</guid>
      <description>&lt;p&gt;Rustにおいては返り値ポインタで返すよりもそのまま返して、受け取る側でポインタで受け取るかそのまま受け取るかを指定するのが良い選択肢だ、といっています。
しかし初めて見る時にはどうしてそんなことが出来るのかわからず、びっくりしますよね。
それをRustがリージョンを使ってメモリ管理をしていると分かればどうなっているのか分かったのですこしばかり。&lt;/p&gt;

&lt;p&gt;Rustにおいては以下のように関数が値を返す時にポインタを返すコードは好ましくなく、（というかコンパイル出来ない）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; &amp;amp;BigStruct {
    &amp;amp;BigStruct{ .... }
}

let bs = new_value();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数が返す値はスタックに載らないような大きな値でもそのまま返して、受け取り側でヒープに保存してあげるのが良いスタイルとされています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn new_value() -&amp;gt; BigStruct {
    BigStruct{ .... }
}

let bs = Box::new(new_value());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までの言語の感覚だとRustにおいて良いとされるスタイルは大きな値を一旦スタックに載せた後で&lt;code&gt;Box&lt;/code&gt;によって作られたヒープ領域に確保されているように見えます。&lt;/p&gt;

&lt;p&gt;これはリージョンについて理解すると動作が理解できます。&lt;/p&gt;

&lt;p&gt;リージョンについては以前のブログを参照して下さい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/12/09/ri_jonnitsuite/&#34;&gt;リージョンについて | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、リージョンによるメモリ管理は「メモリを確保すべき場所」が先にあって、値はそこに置かれます。
特に、関数呼び出しにおいて、関数の「返り値を確保すべき場所」は関数の外から与えます。&lt;/p&gt;

&lt;p&gt;ここまで説明したらお分りかと思いますが、&lt;code&gt;Box::new(new_value());&lt;/code&gt;というコードは&lt;code&gt;new_value()&lt;/code&gt;の返り値を保存する場所としてヒープ領域を渡していて、
関数内部でそのヒープ領域にBigStructの値を書き込んでいるのです。&lt;/p&gt;

&lt;p&gt;もやもやしていたものがスッキリしたし返り値のサイズが決まってないと関数から返せないのも分かるようになった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustのゼロコスト抽象化</title>
      <link>/blog/2016/03/01/rustnozerokosutochuushouka</link>
      <pubDate>Tue, 01 Mar 2016 23:32:12 +0900</pubDate>
      
      <guid>/blog/2016/03/01/rustnozerokosutochuushouka</guid>
      <description>&lt;p&gt;κeenです。今日Twitter上でのやりとりから少し面白いことが分かったのでそれについて。&lt;/p&gt;

&lt;p&gt;最近1.0が出たKotlinについて、水島さんがツイートしてました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;nullableに対してはmapとかの高階関数を一切使えないのが痛い。 ?. でカバーできるケースは一部だけだ。zero-overhead null-safetyと唄っとるが、代わりにnullチェックお化けになるわけで、どこがzero-overheadだ &lt;a href=&#34;https://twitter.com/hashtag/kotlin_dis?src=hash&#34;&gt;#kotlin_dis&lt;/a&gt;&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704453235277324288&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;それについて私が無関係なツイートを。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;全く無関係だけどRustはOptionみたいな0-1の型をnull or valueに最適化するそうな。これこそがゼロコスト抽象かな &lt;a href=&#34;https://t.co/5Y7cBEyrMe&#34;&gt;https://t.co/5Y7cBEyrMe&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704453898996547584&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;これはRustのnomiconに書かれています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/repr-rust.html&#34;&gt;repr(Rust)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;そうすると水島さんからお返事が。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; Rust詳しくないですけど、Optionにmapとかした場合インライン展開されるんですかね？だとしたらとても理想的。&lt;/p&gt;&amp;mdash; 水島 宏太(Klassic作成中) (@kmizu) &lt;a href=&#34;https://twitter.com/kmizu/status/704455185125408768&#34;&gt;2016年2月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;確かにそうなると面白そう。ということで少し調べてみました。&lt;/p&gt;

&lt;p&gt;まず、上記の話をまとめると、Rustの&lt;code&gt;Option&lt;/code&gt;に対する&lt;code&gt;map&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    match self {
        Some(x) =&amp;gt; Some(f(x)),
        None =&amp;gt; None,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;code&gt;x&lt;/code&gt;がポインタ型だった時に以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt; {
    if (self != nullPointer ) {
        f(x)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、&lt;a href=&#34;https://github.com/rust-lang/rust/blob/master/src/libcore/option.rs#L386&#34;&gt;&lt;code&gt;map&lt;/code&gt;はインライン宣言されている&lt;/a&gt;ので以下のコード&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は以下と同値です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  (|x| x + 1)(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、ここで無名関数がどうコンパイルされるかという問題が出てきますが、&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャのドキュメント&lt;/a&gt;によるとこういう雰囲気のコードになるらしいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
struct AnonymousType;

impl FnOnce&amp;lt;(&amp;amp;i32)&amp;gt; for AnonymousType {
    type Output = i32;
    fn call_once(self, args: (&amp;amp;i32)) -&amp;gt; Self::Output {
        args + 1
    }
}

if (opt != nullPointer) {
    let fn_once: FnOnce = AnonymousType;
    fn_once.call_once(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思ったよりも複雑…。さて、問題は&lt;code&gt;let fn_once: FnOnce = AnonymousType;&lt;/code&gt;としているので一旦元の無名関数の情報が抜けてしまいそうな気がします。
となるとコンパイル時に具体的なメソッドを決定出来ないので&lt;code&gt;fn_once.call_once(opt);&lt;/code&gt;は以下のような雰囲気のコードになってしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回呼び出すべき関数の取得が入るのは面倒ですね。&lt;/p&gt;

&lt;p&gt;しかしなががらクロージャのドキュメントをよく読むと無名関数は静的ディスパッチされると書いてあります。つまり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let call_once_fn = fn_once.get_call_once_fn();
call_once_fn(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と2段ではなく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;the_call_once_fn_of_AnonymousType(opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイルされ、&lt;/p&gt;

&lt;p&gt;よって&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn the_call_once_fn_of_AnonymousType(x: &amp;amp;i32) -&amp;gt; i32 {
    x + 1
}


let opt = &amp;amp;v;
if (opt != nullPointer) {
  the_call_once_fn_of_AnonymousType(opt)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と同値ということです。&lt;/p&gt;

&lt;p&gt;ここからは私の推測ですが、&lt;code&gt;the_call_once_fn_of_AnonymousType&lt;/code&gt;は本体が小さい上に1回しか呼ばれないのでインライン化されるのではないかと思います。
よってこの推測が正しければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = Some(&amp;amp;v);
opt.map(|x| x + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let opt = &amp;amp;v;
if (opt != nullPointer) {
  opt + 1
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる筈です。&lt;/p&gt;

&lt;p&gt;ゼロコスト抽象化すごい!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>テストについて考えてみた</title>
      <link>/blog/2016/03/01/tesutonitsuitekangaetemita</link>
      <pubDate>Tue, 01 Mar 2016 22:49:23 +0900</pubDate>
      
      <guid>/blog/2016/03/01/tesutonitsuitekangaetemita</guid>
      <description>

&lt;p&gt;κeenです。
普段はテストをあまり書かない人なのですが業務では流石に書く必要があって、馴れないことをしていると色々と考えることがあったのでまとめます。
まだ私はテストのセオリーとかには詳しくないので勝手気儘に考えたことです。&lt;/p&gt;

&lt;p&gt;2016-03-05 追記:
酷い誤りがあったので修正しました。s/ホーア理論/ホーア論理/。&lt;/p&gt;

&lt;p&gt;今まではテストは「とりあえずエッジケースとかをカバー出来てればいいんでしょ」くらいにしか考えてませんでした。
しかしオブジェクト指向をしていて他のオブジェクトの振舞いに依存するだとか関数の引数が複雑だとかの時には適切なケースを書くのが困難でした。&lt;/p&gt;

&lt;p&gt;チームの人とかとどう書くのが適切かと話しているとなんとなくまとまってきました。&lt;/p&gt;

&lt;h1 id=&#34;ホーア論理:a6610a259e229e09be210cb3df2778c4&#34;&gt;ホーア論理&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://proofcafe.org/sf/Hoare_J.html&#34;&gt;ホーア論理&lt;/a&gt;的にはソフトウェアの振舞/性質を表すのには3つの要素が必要です。事前条件、操作、事後条件です。&lt;/p&gt;

&lt;p&gt;「事前条件Pが満たされるときに操作Oを行い、それが停止するならば事後条件Qが満たされる」&lt;/p&gt;

&lt;p&gt;エンジニアリング的には以下のように読み替えられます。&lt;/p&gt;

&lt;p&gt;事前条件とは、メソッドを実行するまでのお善立て。引数を用意する、依存するオブジェクトのモックを用意する、などなど。
操作が実際のメソッドの実行。
事後条件こそがassertなどを使ったテストケース群です。&lt;/p&gt;

&lt;h1 id=&#34;テストフレームワークとホーア論理:a6610a259e229e09be210cb3df2778c4&#34;&gt;テストフレームワークとホーア論理&lt;/h1&gt;

&lt;p&gt;テストを書く時にもこの考え方は役に立つな、と思いました。事前条件 x 操作 x 事後条件を網羅していけばいい訳です。&lt;/p&gt;

&lt;p&gt;ところで、テストフレームワークにはテストをグルーピングしたりといくつかのスコープをネスト出来る機能を持っているものもあります。
ホーア論理では要素が3つある訳ですから3段にネストするのが適切な気がするのは納得いくと思います。しかしどの順番でネストするかは議論の余地がありそうです。&lt;/p&gt;

&lt;p&gt;勿論、ホーア論理に従うなら操作の時系列的に事前条件&amp;gt;操作&amp;gt;事後条件のネストの仕方が一番自然かと思います。
しかしテストしたい主役は振舞、メソッドなのでそれを階層の最上位に持ってくる方が可読性、ひいてはテストの意味が高まりそうです。&lt;/p&gt;

&lt;p&gt;あるいは、4段にネストして最上位にだたのグルーピング目的にメソッドを、そしてその下に事前条件&amp;gt;操作&amp;gt;事後条件を持っていく手法もありそうです。
しかしこれだとネストが深すぎますね。また、後述するように操作の子階層を作ると例外がどこ由来なのか分かりづらいという問題もあります。&lt;/p&gt;

&lt;p&gt;これの改良版は最上位にだたのグルーピング目的にメソッドを、そして事前条件&amp;gt;(操作+事後条件)という形のネストの仕方をする方法です。
これは例外の出所を明確に出来る他、多くのテストフレームワークで操作に対する表明と事後条件に対する表明を区別しない問題もクリア出来るという利点があります。
1つある欠点は、操作と事後条件のスコープが分かれているので操作の返り値に対して事後条件で表明したい時にどうにかしてスコープの外に出してやる必要がある点です。
副作用を容易に許す言語なら外のスコープの変数に代入すればいいだけですが、純粋な言語だと簡単ではありません。
そういう意味でも操作に対する表明と事後条件に対する表明は分けたいなと思う次第。&lt;/p&gt;

&lt;h1 id=&#34;操作に対する表明:a6610a259e229e09be210cb3df2778c4&#34;&gt;操作に対する表明&lt;/h1&gt;

&lt;p&gt;本来のホーア論理的には事後条件で表明すれば十分ですが、実際には不十分な点があります。もう一度ホーア論理の表明について思い出しましょう。&lt;/p&gt;

&lt;p&gt;「事前条件pが満たされるときに操作oを行い、 &lt;strong&gt;それが停止するならば&lt;/strong&gt; 事後条件qが満たされる」&lt;/p&gt;

&lt;p&gt;現実的に、関数が正しく停止することも保証したいです。「無限ループを書く方が悪い」という訳ではありません。関数が停止しないのは何も無限ループだけでなく、例外などで脱出した場合も含みます。&lt;/p&gt;

&lt;p&gt;なので例外を出す/出さないの表明も欲しくなる訳です。
もう少し踏み込んで考えると、多くのテストフレームワークでassertと例外の送出の有無を同列扱いますが、前者は事後条件に対する表明、後者は操作に対する表明なので本来は分かれるべきです。&lt;/p&gt;

&lt;p&gt;また、操作に対する表明はスコープを作るとしても操作の返り値を返す手段を用意してくれると事後条件の表明がやりやすくなるな、と思いました。まる。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:a6610a259e229e09be210cb3df2778c4&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;テストをする時には3つの要素に分けて考えると考えやすくなります。その3つとは事前条件、操作、事後条件で、それぞれの組み合わせがあるのでテストケースのネストは合理的です。
しかしながら人間の認識のためにネストの順番は入れ替えた方がよいのですが、そうするとコード上いくつか問題が発生します。&lt;/p&gt;

&lt;p&gt;グルーピング目的にメソッドを、そして事前条件&amp;gt;(操作+事後条件)というネストの仕方が最終案に思えますが、それを的確に表現出来、かつコード上の問題をクリア出来るテストフレームワークが中々ないのが現状です。&lt;/p&gt;

&lt;h1 id=&#34;付録a:a6610a259e229e09be210cb3df2778c4&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;考えがまとまるまでの過程&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;テスト書いててなぜテストライブラリがテストスートを階層構造にしてるのか考えたけど1つの事前条件に対して複数の操作が考えれてそれぞれの操作に対して保証したい不変条件と事後条件があるから少なくとも3段にネストしないと上手くグルーピング出来ないのかな。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704586009464311808&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;しかしネストする順番はどうだろう。メソッドに対するテストでグルーピングしたいからメソッド&amp;gt;事前条件&amp;gt;事後/不変条件になるのかな。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704586479427670016&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;事前条件を最上位に持ってきた方が理解しやすいし事前条件の使い回しもしやすいけど並行にテストを走らせようと思ったらやっぱり操作毎に事前条件用意してあげた方がいいし事前条件と事後条件が近い方が性質を理解しやすい?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704587239402008576&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;あれ?もしかして操作ってメソッドじゃなくてメソッド+引数になる?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704588326175551488&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うーん。操作を行うパートと条件の準備/確認のパートを分けたいんだけど難しい。例えば操作によって例外が出ることを確認したいとかが非常にやりづらい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704601381605232640&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;いや?やっぱり操作と事後/不変条件のパートは分けれるな?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704602157148872704&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そしてやはり操作をネストのトップレベルにもってくると操作の引数とかが事前条件/前提条件に依存するのでやりづらい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/704602629737811968&#34;&gt;2016年3月1日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RustのHigher-Kinded type Trait</title>
      <link>/blog/2016/02/28/rustnohigherkinded_type_trait</link>
      <pubDate>Sun, 28 Feb 2016 14:40:59 +0900</pubDate>
      
      <guid>/blog/2016/02/28/rustnohigherkinded_type_trait</guid>
      <description>

&lt;p&gt;κeenです。少し前の話になりますがRustの関連型を駆使してHigher Kinded type Trait（高階型トレイト）を実現してしまったものが出回ってたのでそれについて。
本来RustはHKTをサポートしていませんが不思議なことに実装出来てしまっているのです。&lt;/p&gt;

&lt;p&gt;HKTについて微塵も知らない方にも分かるように解説していきます。&lt;/p&gt;

&lt;h1 id=&#34;map-可能なトレイト:b27135531fb7377c493eecfb210d7b92&#34;&gt;&lt;code&gt;map&lt;/code&gt; 可能なトレイト&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/core/option/enum.Option.html#method.map&#34;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;https://doc.rust-lang.org/core/result/enum.Result.html#method.map&#34;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;、etc 色々なトレイトが &lt;code&gt;map&lt;/code&gt; メソッドを実装しています。&lt;/p&gt;

&lt;p&gt;それぞれ型シグネチャを抜き出してみましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Option: &lt;code&gt;map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Option&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Result: &lt;code&gt;map&amp;lt;U, F: FnOnce(T) -&amp;gt; U&amp;gt;(self, op: F) -&amp;gt; Result&amp;lt;U, E&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;驚く程似てますね。これを抽象化して「&lt;code&gt;map&lt;/code&gt;メソッドを持つ」トレイトを定義したくなるかもしれません。
しかしそれは簡単には書けません。何故なら&lt;code&gt;map&lt;/code&gt;はコンテナ型、つまり「型引数を取る型」に定義される型だからです。
現在のRustは「型引数を取る型」に対するジェネリクスはサポートしていません。もし書こうとするとこのようになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;M&amp;lt;_&amp;gt;, T&amp;gt; where Self: M&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; M&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt; なんて型パラメータを書くことは出来ませんし&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;も無理があります。残念ですね。&lt;/p&gt;

&lt;h1 id=&#34;iterator-との違い:b27135531fb7377c493eecfb210d7b92&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt; との違い&lt;/h1&gt;

&lt;p&gt;さて、&lt;code&gt;Iterator&lt;/code&gt;にも&lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;はあります。
これこそが求めている「&lt;code&gt;.map&lt;/code&gt; 可能なトレイト」ではないのでしょうか。
これはおおよそは合っているのですがやや期待とは違う動作をします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt;の&lt;code&gt;map&lt;/code&gt;は不自由なく使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let o = Some(1);
let o = o.map(|i| i + 1);
println!(&amp;quot;{:?}&amp;quot;, o);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一方、&lt;code&gt;Vec&lt;/code&gt;は全く同じような書き方は出来ません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = vec![1];
let v = v.map(|i| i + 1);
println!(&amp;quot;{:?}&amp;quot;, v);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;anon&amp;gt;:3:11: 3:25 error: no method named `map` found for type `collections::vec::Vec&amp;lt;_&amp;gt;` in the current scope
&amp;lt;anon&amp;gt;:3 let v = v.map(|i| i + 1);
                   ^~~~~~~~~~~~~~
&amp;lt;anon&amp;gt;:3:11: 3:25 note: the method `map` exists but the following trait bounds were not satisfied: `collections::vec::Vec&amp;lt;_&amp;gt; : core::iter::Iterator`, `[_] : core::iter::Iterator`
error: aborting due to previous error
playpen: application terminated with error code 101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正しくは、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = vec![1];
let v: Vec&amp;lt;i32&amp;gt; = v.iter().map(|i| i + 1).collect();
println!(&amp;quot;{:?}&amp;quot;, v);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;色々実装上のノイズが乗っているのでやや例として不適切だったかもしれませんが、注目して欲しい部分はここです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v: Vec&amp;lt;i32&amp;gt; = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt;から取り出したイテレータなのに&lt;code&gt;Vec&lt;/code&gt;に戻すためにわざわざ型アノテーションを書く必要があります。&lt;/p&gt;

&lt;p&gt;どうしてこうなるかというとイテレータを取り出した時点で元のコンテナ型が&lt;code&gt;Vec&amp;lt;&amp;gt;&lt;/code&gt;であるという情報が失われているからです。
これはRustの型システム上どうしても仕方のないことで、なので恐らくRustは「&lt;code&gt;map&lt;/code&gt;可能なトレイト」などを定義せず、コレクションの操作を&lt;code&gt;Iterator&lt;/code&gt;に集約しているんだと思います。
この方式はある程度は上手くいきますが&lt;code&gt;Option&lt;/code&gt;や&lt;code&gt;Result&lt;/code&gt;はIteratorになれはしてもIteratorからは作れない(2要素のイテレータからOptionは作れない)ので独自でmapメソッドを持つことになってしまいます。&lt;/p&gt;

&lt;h1 id=&#34;map-可能なトレイト-again:b27135531fb7377c493eecfb210d7b92&#34;&gt;&lt;code&gt;map&lt;/code&gt; 可能なトレイト again&lt;/h1&gt;

&lt;p&gt;先程そういうのは作れないと言ったばかりですが実はどうにかする方法がなくもないです。先程の(仮想の)定義を思い出して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;M&amp;lt;_&amp;gt;, T&amp;gt; where Self: M&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; M&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジェネリクスになっている登場人物は&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;、&lt;code&gt;U&lt;/code&gt;、&lt;code&gt;T&lt;/code&gt; ですね。しかし&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;は実際にはそのまま使われいる訳ではなく&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;または&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;の形でのみ使われています。
では、&lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;M&amp;lt;U&amp;gt;&lt;/code&gt;をパラメータに取るようにしてはどうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;T, MT&amp;gt; where Self: MT {
  fn map&amp;lt;U, MU, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで出来…てません。これは欲しい、正しいもの &lt;em&gt;も&lt;/em&gt; 作れてはいるのですが正しくないものも含んでいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;T, MT: Option&amp;lt;T&amp;gt; Mappable&amp;lt;MT, T&amp;gt;  for Option&amp;lt;T&amp;gt; {
  fn map&amp;lt;U, MU, F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU {...}
}

let r: Result&amp;lt;String, ()&amp;gt; = Some(1).map(|i| i.to_string());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt; に対する&lt;code&gt;map&lt;/code&gt;を&lt;code&gt;Result&lt;/code&gt;で受けようとしています。
これはもちろんおかしなことですが上記の型定義に従うとこういうことが出来てしまいます。
もうちょっというと上のトレイトの定義はこういう「おかしなこと」が起こるような実装をしろ、と言っている訳で、実際には実装出来ません。&lt;/p&gt;

&lt;p&gt;本来なら自由パラメータが3つなのに4つの自由パラメータを取ってしまったので不整合が起きる訳です。
では、自由パラメータを3つにして1つを従属パラメータにしてはどうでしょうか。それは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;を使えばRustでも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;T, U, MT&amp;gt; where Self: MT {
  type MU;
  fn map&amp;lt;F: FunOnce(T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これである程度上手くいきます。
もちろん、実際に&lt;code&gt;M&amp;lt;_&amp;gt;&lt;/code&gt;を取れるのに比べると不自由で下手をするとバグる(MUを無関係な型に定義できてしまう)可能性があるのですが、先程の4パラメータの時と比べて
トレイトが定義された時点で返す型は決まっているのでちゃんと実装出来ますし、使う時に不整合が起きることもありません。&lt;/p&gt;

&lt;h1 id=&#34;hkt:b27135531fb7377c493eecfb210d7b92&#34;&gt;HKT&lt;/h1&gt;

&lt;p&gt;さて、先の&lt;code&gt;Mappable&lt;/code&gt;の仮想定義、&lt;code&gt;map&lt;/code&gt;関数を除いて汎用的にするとこうなりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U, MT&amp;gt; where Self: MT {
  type MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Self: MT&lt;/code&gt; というアノテーションをつけてますが実際には使えません。&lt;code&gt;impl&lt;/code&gt;を書くときに気をつけて実装するしかないです。なのでこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U&amp;gt; {
  type MU;
}

impl &amp;lt;T, U&amp;gt; HKT&amp;lt;T, U&amp;gt; for Option&amp;lt;T&amp;gt; {
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、こう書くとするとこういうことも出来てしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;T, U&amp;gt; {
  type MU;
}

impl &amp;lt;S, T, U&amp;gt; HKT&amp;lt;T, U&amp;gt; for Option&amp;lt;S&amp;gt; {
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;T&lt;/code&gt;とは独立な&lt;code&gt;S&lt;/code&gt;に対するコンテナに対して実装できてしまうのです。「実装するときに気をつける」とはいいましたが制約を書けるなら書いた方がいいです。こうしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait HKT&amp;lt;U&amp;gt; {
  type T;
  type MU;
}

impl &amp;lt;T, U&amp;gt; HKT&amp;lt;U&amp;gt; for Option&amp;lt;T&amp;gt; {
  type T = T;
  type MU = Option&amp;lt;U&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで冒頭に紹介したHKTの実装になりました。&lt;/p&gt;

&lt;p&gt;逆にこのHKTの実装からMappableを定義するには、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Mappable&amp;lt;U&amp;gt;: HKT&amp;lt;U&amp;gt; {
  fn map&amp;lt;F: FunOnce(Self::T) -&amp;gt; U&amp;gt;(self, f: F) -&amp;gt; Self::MU;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hktについてもっと:b27135531fb7377c493eecfb210d7b92&#34;&gt;HKTについてもっと&lt;/h1&gt;

&lt;p&gt;ようやく話題のHKTの元実装です。こちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/14427/af90a21b917d2892eace&#34;&gt;Higher-kinded type trait&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ずいぶんとモナモナしいですがやはり高階型を使った一番実績のある構造はこのあたりでしょう。&lt;/p&gt;

&lt;p&gt;こういうのを扱えるとプログラミングの幅が広がりますね。&lt;/p&gt;

&lt;h1 id=&#34;ノート:b27135531fb7377c493eecfb210d7b92&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;モナドの話題が出ましたがRustでモナドを実現するには高階型だけでなく複数ある関数トレイトのどれを選ぶかだとかその他諸々の問題を扱う必要があるようです。
&lt;a href=&#34;https://m4rw3r.github.io/rust-and-monad-trait/&#34;&gt;Rust and the Monad trait - Not just higher kinded types · m4rw3r&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>druidというリアルタイムデータ分析ツールを知った</title>
      <link>/blog/2016/02/27/druidtoiuriarutaimude_tabunsekitsu_ruwoshitta</link>
      <pubDate>Sat, 27 Feb 2016 21:28:16 +0900</pubDate>
      
      <guid>/blog/2016/02/27/druidtoiuriarutaimude_tabunsekitsu_ruwoshitta</guid>
      <description>&lt;p&gt;κeenです。社内ハッカソンに出てきた。そこでdruidというツール（？）を触ったのでそれについて。&lt;/p&gt;

&lt;p&gt;読み方は「ドゥルイド」でいいのかな？公式ページは&lt;a href=&#34;http://druid.io/&#34;&gt;こちら&lt;/a&gt;。&lt;a href=&#34;https://metamarkets.com/&#34;&gt;Metamarkets&lt;/a&gt;が主導で開発しているようで、&lt;a href=&#34;https://github.com/druid-io/druid&#34;&gt;オープンソースになっている&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;公式サイトを少し回遊してもらうと分かると思うが、時系列データを分散環境でストリーミング処理出来るツール。分散環境で動くだけあってコンポーネントはいくつかある。&lt;/p&gt;

&lt;p&gt;主にはストリーミングデータを取り込む「REALTIME」、クライアントからのクエリを処理する「BROKER」、過去のデータを処理する「HISTORICAL」があるようだ。
BROKERがDEEP STORAGE(s3などの永続データストア)にデータを保存し、HISTORICALがオンデマンドにそのデータを読み出してBROKERに返す。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://druid.io/docs/img/druid-dataflow-3.png&#34; alt=&#34;design of druid&#34; /&gt;&lt;/p&gt;

&lt;p&gt;イメージとしてはこんな感じだが、実際に動かすのには他のコンポーネントも必要で、分散環境に必須なZookeeperが必要なのはもちろんのこと、全体を司る「COORDINATOR」、取り込んだデータのメタデータを保存する「METADATA STORAGE」も必要になる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://druid.io/docs/img/druid-manage-1.png&#34; alt=&#34;detailed design of druid&#34; /&gt;&lt;/p&gt;

&lt;p&gt;画像の出展は&lt;a href=&#34;http://druid.io/docs/0.8.3/design/design.html&#34;&gt;こちら&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;中々に大仰なアーキテクチャだがどのみちリアルタイムデータ分析基盤を作ろうと思うとこれくらい必要になる。それを1まとめにしてディストリビュートしてくれるdruidを使った方がなんぼか近道な気はする。&lt;/p&gt;

&lt;p&gt;さて、これを1インスタンスで動かそうと思うと、DEEP STORAGEはローカルファイルシステム、METADATA STORAGEは組込みのDerby DBでまかなえ、REALTIMEはデータを取り込む時にのみ必要なのでZookeeper、Coordinator、Broker、Historical、都合4つのJava製ミドルウェアを起動すればどうにか使える。
これら合わせても2GBくらいのメモリしか必要なかったので十分手元で動く。&lt;/p&gt;

&lt;p&gt;さて、このDruid、どういうことが出来るかというとクエリに注目すれば「Group By付きのAggrigation Functionを高速に動かす」が主な目的だろうか。&lt;a href=&#34;http://druid.io/docs/0.8.3/querying/querying.html&#34;&gt;他にも色々ある&lt;/a&gt;が。
BIツールや他のダッシュボードツールなんかと連携してストリーミングデータをリアルタイムに可視化するのに一役買う。YahooやAlibabaなんかでも&lt;a href=&#34;http://druid.io/community/&#34;&gt;使われているようだ&lt;/a&gt;。
例えばDruidをサポートするダッシュボードツール、&lt;a href=&#34;https://github.com/mistercrunch/panoramix&#34;&gt;panoramix&lt;/a&gt;なんかもある。&lt;/p&gt;

&lt;p&gt;今回のハッカソンはGCPがテーマで、Cloud Pub/Subからデータを取り込むことになったがDruidにはPub/Subからデータを取り込むREALTIMEがない。ということでハッカソンで&lt;a href=&#34;https://github.com/KeenS/druid/tree/pubsub-extension/extensions/cloud-pubsub&#34;&gt;Pub/Sub extensionを作った&lt;/a&gt;。
メーリスに投稿して様子を覘った上でコードを整理してプルリクを出す予定だ。
拡張は思ったよりも作りやすく、ドキュメントを読まなくても既存のKafka拡張を参考にするだけで書けた。まあ、その後苦労したが。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;はじめて使うDBのプラグイン書いたらデータのロードは出来たもののクエリの投げ方が分からずに入ったデータを確認出来ない…っ…&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/703202304913051648&#34;&gt;2016年2月26日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;今回作ったのはFirehose Pluginと呼ばれるものだが、他にもプラグインの種類は&lt;a href=&#34;http://druid.io/docs/0.8.3/development/modules.html&#34;&gt;色々ある&lt;/a&gt;みたいだ。
しかしFirehose Pluginの基底クラスはあまりストリーミングデータのインポートには良くない気がする。FirehoseV2というのがあって、それが良いインターフェースになっていたが使い方が分からなかった。&lt;/p&gt;

&lt;p&gt;今が0.9.0-SNAPSHOT。1.0.0が出る頃が楽しみだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bind Addressの意味がようやく分かった</title>
      <link>/blog/2016/02/24/bind_addressnoimigayouyakuwakatta</link>
      <pubDate>Wed, 24 Feb 2016 23:57:31 +0900</pubDate>
      
      <guid>/blog/2016/02/24/bind_addressnoimigayouyakuwakatta</guid>
      <description>

&lt;p&gt;κeenです。小ネタを。サーバを立ち上げる時に指定するBind Addressについてよく分かっていなかったのがようやく分かるようになったのでそれについて。&lt;/p&gt;

&lt;p&gt;Bind Addressはサーバ(特にHTTPサーバ)を立ち上げる時によく指定することになりますが、Usageを見ても「バインドするアドレスを指定する」などとトートジーめいたことしか書いてありませんでした。
実際に使ってみても127.0.0.1を指定すればローカルホストから、0.0.0.0を指定すれば外部からでも参照出来るな、くらいの認識しかありませんでした。
意味も分からず使っていると気持ち悪いもので、2つの疑問が湧いてきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0.0.0.0と127.0.0.1は正確に何を意味するのか&lt;/li&gt;
&lt;li&gt;127.0.0.1と0.0.0.0以外のアドレスを指定するのはどのようなケースか&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もちろん、127.0.0.1がlocalhostを指すことは知っていますが0.0.0.0というアドレスはBind Addressでしか見たことありませんし、127.0.0.1が私の知っているlocalhostの意味でない可能性も十分あるな、と思っていました。&lt;/p&gt;

&lt;p&gt;さて、この疑問に答えるには前提知識が必要なのでそこから始めましょう。&lt;/p&gt;

&lt;h1 id=&#34;マシンは複数のipアドレスを持ちうる:a96f766a18fe92e465482ea79d6a2ec6&#34;&gt;マシンは複数のIPアドレスを持ちうる&lt;/h1&gt;

&lt;p&gt;1つのマシンに、複数のIPアドレスが割り当てられることがあります。
典型的なのはルータのようにインターネットとローカルエリアネットワーク両方に参加しているもので、LANには「192.168.1.1」、インターネットには「www.xxx.yyy.zz」という2つのIPアドレスを持つでしょう。
また、どのマシンにも先程述べたlocalhost、127.0.0.1という内部から自身を指すIPアドレスもあります。
図にするとこんな感じでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [インターネット]
       |
       |
       | www.xxx.yyy.zz
[x 127.0.0.1] ルータ
       | 192.168.1.1
       |
   ...-+--+
          | 192.168.1.2
         [ 127.0.0.1]マシンA

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この時に例えばルータの管理WebUIを提供したいとしましょう。このUIは勿論LAN内にいるマシンAからは参照したいですがインターネット全てに公開する訳にはいきません。
こういう時のアクセス制御に使うのがBind Addressです。&lt;/p&gt;

&lt;h1 id=&#34;呼ばれ方で反応を変える:a96f766a18fe92e465482ea79d6a2ec6&#34;&gt;呼ばれ方で反応を変える&lt;/h1&gt;

&lt;p&gt;bind addressは、他のマシンから何という名前で呼ばれたかでメッセージを受け取る/受け取らない（というか見える見えない）を変えるものです。
街中で「田中さん」と呼ばれたら返事したいけど「†漆黒の天翅†さん」と呼ばれたら返事したくないですよね。
少し実験してみましょう。&lt;/p&gt;

&lt;p&gt;さて、私の手元のマシンはifconfigによると127.0.0.1というアドレスと192.168.1.6というアドレスを持っているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ifconfig
lo        Link encap:ローカルループバック  
          inetアドレス:127.0.0.1  マスク:255.0.0.0
          inet6アドレス: ::1/128 範囲:ホスト
          UP LOOPBACK RUNNING  MTU:65536  メトリック:1
          RXパケット:5132 エラー:0 損失:0 オーバラン:0 フレーム:0
          TXパケット:5132 エラー:0 損失:0 オーバラン:0 キャリア:0
          衝突(Collisions):0 TXキュー長:0 
          RXバイト:665331 (665.3 KB)  TXバイト:665331 (665.3 KB)
wlp3s0    Link encap:イーサネット  ハードウェアアドレス cc:3d:82:38:21:e2  
          inetアドレス:192.168.1.6  ブロードキャスト:192.168.1.255  マスク:255.255.255.0
          inet6アドレス: fe80::ce3d:82ff:fe38:21e2/64 範囲:リンク
          UP BROADCAST RUNNING MULTICAST  MTU:1500  メトリック:1
          RXパケット:85578 エラー:0 損失:0 オーバラン:0 フレーム:0
          TXパケット:64002 エラー:0 損失:0 オーバラン:0 キャリア:0
          衝突(Collisions):0 TXキュー長:1000 
          RXバイト:85393847 (85.3 MB)  TXバイト:10710856 (10.7 MB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTPサーバをそれぞれにbindしてみます。今回使うのはRubyのコマンドラインから使えるHTTPサーバです。&lt;/p&gt;

&lt;p&gt;まずは127.0.0.1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -run -e httpd -- ./ --port 8080 --bind 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じですかね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------+
|       |
|     +-+ 127.0.0.1
|ruby-+ |
|       + 192.168.1.6
+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、これにcurlでアクセスしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl 127.0.0.1:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 192.168.1.6:8080
curl: (7) Failed to connect to 192.168.1.6 port 8080: 接続を拒否されました
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に192.168.1.6を試します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -run -e httpd -- ./ --port 8080 --bind 192.168.1.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもこんな感じですかね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------+
|       |
|       + 127.0.0.1
|ruby-+ |
|     +-+ 192.168.1.6
+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じくcurlでアクセスしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl 127.0.0.1:8080
curl: (7) Failed to connect to 127.0.0.1 port 8080: 接続を拒否されました
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 192.168.1.6:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見事にbindしたアドレスに投げた時にしか結果が返ってきません。
また、無関係なアドレス、例えば192.168.1.2などにbindしようとするとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -run -e httpd -- ./ --port 8080 --bind 192.168.1.2
[2016-02-25 00:36:17] INFO  WEBrick 1.3.1
[2016-02-25 00:36:17] INFO  ruby 2.1.5 (2014-11-13) [x86_64-linux-gnu]
/usr/lib/ruby/2.1.0/socket.rb:206:in `bind&#39;: Cannot assign requested address - bind(2) for 192.168.1.2:3000 (Errno::EADDRNOTAVAIL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら正確に自分のアドレスでないとbind出来ないようです。&lt;/p&gt;

&lt;h1 id=&#34;0-0-0-0はワイルドカード:a96f766a18fe92e465482ea79d6a2ec6&#34;&gt;0.0.0.0はワイルドカード&lt;/h1&gt;

&lt;p&gt;さて、これで正確に何という名前で呼ばれたかでアクセスを制御出来るようになりました。しかし公開サーバのように「どこからでも」アクセスさせたい場合にこと細かく指定させるのは不便です（というか複数のネットワークから参照することが出来なくなる？）。
その「どこからでも」を表すのが0.0.0.0です。&lt;/p&gt;

&lt;p&gt;試してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -run -e httpd -- ./ --port 8080 --bind 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうなっているのでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------+
|       |
|     +-+ 127.0.0.1
|ruby-+ |
|     +-+ 192.168.1.6
+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 127.0.0.1:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 192.168.1.6:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl 0.0.0.0:8080
結果が返ってくる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにどのような指定方法でも返ってきます。
curl 0.0.0.0:3000で結果が返ってきた(0.0.0.0が自身を指す)ことに驚きましたがワイルドカードアドレスにbindされた時にだけ結果が返ってきて欲しい時に便利なんですかね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:a96f766a18fe92e465482ea79d6a2ec6&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Bind Addressは本当にBindするAddressでした。足りないのはBind Addressに対する知識ではなくネットワークに対する知識でした。
世の中知らないといけないことが多い。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>readlineの作り方</title>
      <link>/blog/2016/02/14/readlinenotsukurikata</link>
      <pubDate>Sun, 14 Feb 2016 22:37:35 +0900</pubDate>
      
      <guid>/blog/2016/02/14/readlinenotsukurikata</guid>
      <description>

&lt;p&gt;κeenです。なんか伏線っぽいもの回収しといた方が良いかなと思ってLinuxっぽい話でも。&lt;/p&gt;

&lt;p&gt;readlineって便利ですよね。
でもCで書かれているから他の言語から使おうと思うと面倒だったり使えなかったりGPLv3の所為で使えなかったりしますよね。
そこである程度POSIXのインターフェースを扱わせてくれる言語でのreadlineの作り方でも。&lt;/p&gt;

&lt;h1 id=&#34;カノニカルモードとエコーモード:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;カノニカルモードとエコーモード&lt;/h1&gt;

&lt;p&gt;readlineの仕組み自体は簡単で、全ての文字入力を受け取って、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readlineの制御キーシーケンスなら指定の制御を行なう&lt;/li&gt;
&lt;li&gt;普通の文字ならそのまま画面に表示する&lt;/li&gt;
&lt;li&gt;コントロールシーケンスなら &lt;code&gt;^W&lt;/code&gt; などとエスケープ表示する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これだけです。しかしそう簡単ではありません。
あなたのお気に入りの言語で &lt;code&gt;readchar&lt;/code&gt; っぽい関数を実行してみると分かるかと思いますが、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一文字入力しただけではプログラムに入力文字が渡されない。エンターキーを押して初めてプログラムの &lt;code&gt;readchar&lt;/code&gt; 関数が返る。&lt;/li&gt;
&lt;li&gt;入力した文字がそのままエコーバックされる。すなわち、 &lt;code&gt;←&lt;/code&gt; を押しても &lt;code&gt;^[[D&lt;/code&gt; が入力されてしまい、制御上不都合。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;私は昔はこれらの挙動が適切な関数がないからだと思ってました。しかし、そうではありません。
このような挙動をするのはプログラムの責任でもでもシェルの責任でもなくターミナルの責任です。&lt;/p&gt;

&lt;p&gt;ターミナルには多彩なモードがあり、それによって挙動が変わるのです。
つまり、1.の挙動をするのはカノニカルモードの挙動、2.の挙動をするのはエコーモードの挙動なのです。&lt;/p&gt;

&lt;h1 id=&#34;tcgetattr-と-tcsetattr:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;&lt;code&gt;tcgetattr&lt;/code&gt; と &lt;code&gt;tcsetattr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、ターミナルのモードはプログラム側から変更出来ます。それを行なうのが &lt;code&gt;tcgetattr(3)&lt;/code&gt; と &lt;code&gt;tcsetattr(3)&lt;/code&gt; です。
ざっくり言うと &lt;code&gt;tcgetattr&lt;/code&gt; で現在のターミナルのコンフィグレーションを取得して、それを所望のモードに書き換え、 &lt;code&gt;tcsetattr&lt;/code&gt; を使って反映出来ます。&lt;/p&gt;

&lt;p&gt;今回はカノニカルモードとエコーモードをoffにしたいのですごい雑なコードだとこう書けるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;sb-posix)
(let* ((stdin 0)
       (termios (sb-posix:tcgetattr stdin))
       (lflag (sb-posix:termios-lflag termios)))
  (setf lflag (logand lflag (lognot sb-posix:icanon)))
  (setf lflag (logand lflag (lognot sb-posix:echo)))
  (setf (sb-posix:termios-lflag termios) lflag)
  (sb-posix:tcsetattr stdin sb-posix:tcsadrain termios))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、これは雑すぎます。なぜならreadlineを実行し終わった後にターミナルを元の状態に復元する必要があるからです。
そうしないとreadlineするつもりのない入力関数が予期せぬ挙動をするでしょう。
あるいはLispプロセスを終了した後のターミナルにまで影響が及びます。
なので &lt;strong&gt;必ず&lt;/strong&gt; 処理が終わったらターミナルの状態を復元する必要があります。&lt;/p&gt;

&lt;p&gt;さて、Common Lispではこの「必ず」は &lt;code&gt;unwind-protect&lt;/code&gt; を使った &lt;code&gt;with-&lt;/code&gt; マクロで実現するのが常套手段です。
コードはこのようになるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro with-readline-mode (&amp;amp;body body)
  (let ((stdin       (gensym &amp;quot;stdin&amp;quot;))
        (old-termios (gensym &amp;quot;old-termios&amp;quot;))
        (new-termios (gensym &amp;quot;new-termios&amp;quot;))
        (lflag       (gensym &amp;quot;lflag&amp;quot;)))
    `(let* ((,stdin 0)
            (,old-termios (sb-posix:tcgetattr ,stdin))
            (,new-termios (sb-posix:tcgetattr ,stdin))
            (,lflag (sb-posix:termios-lflag ,new-termios)))
       (unwind-protect
            (progn
              (setf ,lflag (logand ,lflag (lognot sb-posix:icanon)))
              (setf ,lflag (logand ,lflag (lognot sb-posix:echo)))
              (setf (sb-posix:termios-lflag ,new-termios) ,lflag)
              (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,new-termios)
              ,@body)
        (sb-posix:tcsetattr ,stdin sb-posix:tcsadrain ,old-termios)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(with-readline-mode
  (format t &amp;quot;~a~%&amp;quot; (read-char)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとするとターミナルのモードが変わったことが実感出来るでしょう。&lt;/p&gt;

&lt;p&gt;尚、繰り返すとこれはターミナルの設定の話なのでEmacs内から試そうとしても正常に動作しない筈です。&lt;/p&gt;

&lt;h1 id=&#34;コントロールシーケンス:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;コントロールシーケンス&lt;/h1&gt;

&lt;p&gt;さて、Common Lispの標準にない拡張機能が必要なのはターミナルのモード変更だけで、あとは好き勝手出来るのですが私も少し嵌った部分があるのでそこだけ。&lt;/p&gt;

&lt;p&gt;readlineに欲しい機能はなんでしょうか。色々あるかと思いますが、まずは &lt;code&gt;←&lt;/code&gt; 、 &lt;code&gt;→&lt;/code&gt; でカーソル移動をしたいのではないでしょうか。
実はこれが大落し穴。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;←&lt;/code&gt; キーを押すとターミナルにはなんと3文字入力されます。すなわち、 Esc文字の &lt;code&gt;^[&lt;/code&gt; 、普通のASCII文字の &lt;code&gt;[&lt;/code&gt; 、そして大文字の &lt;code&gt;D&lt;/code&gt; です。&lt;/p&gt;

&lt;p&gt;そしてカーソルの移動文字を受けてカーソルを移動するにはターミナルにそのままEsc文字の &lt;code&gt;^[&lt;/code&gt; 、普通のASCII文字の &lt;code&gt;[&lt;/code&gt; 、そして大文字の &lt;code&gt;D&lt;/code&gt; を入力してあげれば出来ます。&lt;/p&gt;

&lt;p&gt;なのでこのようなコードになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defconstant left &amp;quot;[d&amp;quot;)
(defconstant right &amp;quot;[c&amp;quot;)

(defun left ()
  (format t &amp;quot;~a&amp;quot; left)
  (force-output))

(defun right ()
  (format t &amp;quot;~a&amp;quot; right)
  (force-output))


(defun readline ()
  (let ((line &#39;()))
    (flet ((self-insert (char)
             (format t &amp;quot;~c&amp;quot; char)
             (setf line (cons char line))
             (force-output)))
      (with-readline-mode
       (loop
          (let* ((char (read-char))
                 (code (char-code char)))
            (case code
              ; escape
              ((#b11011)
               (let* ((char (read-char))
                      (code (char-code char)))
                 ;; (write-line &amp;quot;called&amp;quot;)
                 ;; (format t &amp;quot;~a~%&amp;quot; char)
                 ;; (format t &amp;quot;~a~%&amp;quot; code)
                 (case char
                   ((#\[)
                    (let* ((char (read-char))
                           (code (char-code char)))
                      (case char
                        ((#\c) (right))
                        ((#\d) (left)))))
                   ((t)
                    (self-insert #\escape)
                    (self-insert char)))))
              ((#b1010)
               (return-from readline (coerce (reverse line) &#39;string)))
              (t (self-insert char)))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;case&lt;/code&gt; をネストしていくのはダルいし拡張性がないので現実的にはtrie木を使うことになるかと思いますが単純にはこのようなコードでreadlineを作れます。&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s Happy Hacκking!&lt;/p&gt;

&lt;h1 id=&#34;付録a-伏線:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;付録A: 伏線&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;適当に魚と野菜炒めたらオサレっぽくなった &lt;a href=&#34;https://t.co/9IIzhIGjzd&#34;&gt;pic.twitter.com/9IIzhIGjzd&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/698821538686984192&#34;&gt;2016, 2月 14&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 魚は何？タラ？だったら季節物だし、旬の鱈と野菜のソテー、詳解Linuxカーネルを添えて。と命名しよう&lt;/p&gt;&amp;mdash; Shinnosuke Takeda (@cnosuke) &lt;a href=&#34;https://twitter.com/cnosuke/status/698824048319410176&#34;&gt;2016, 2月 14&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;付録b-pure-rubyなreadlineのソースコード:58de41bc5e8c50f42088984a9312e8c7&#34;&gt;付録B: Pure Rubyなreadlineのソースコード&lt;/h1&gt;

&lt;p&gt;努力が必要ということが読み解ければ幸いです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ConnorAtherton/rb-readline/blob/master/lib/rbreadline.rb&#34;&gt;rb-readline/rbreadline.rb at master · ConnorAtherton/rb-readline&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>分散VCSのモデル、あるいはPijulについて</title>
      <link>/blog/2016/02/14/dvcsnomoderu_aruihapijulnitsuite</link>
      <pubDate>Sun, 14 Feb 2016 17:12:01 +0900</pubDate>
      
      <guid>/blog/2016/02/14/dvcsnomoderu_aruihapijulnitsuite</guid>
      <description>

&lt;p&gt;先日、&lt;a href=&#34;pijul.org&#34;&gt;Pijul&lt;/a&gt;という分散VCSについて知って、それについて調べてみたら少し面白かったのでメモ。&lt;/p&gt;

&lt;p&gt;DVCSで一番有名なのは間違いなくGitだろう。あれは分散グラフ理論木モデルに基いているらしい。ベースになったモデルがあることに驚いたが、調べても出てこなかった。
Gitは高速で信頼性が高い一方、コミット同士をチェーンのように繋げてしまうので柔軟性を欠き、例えばCherry Pickなんかがやりづらい。
あるいはリモートのmasterを取り込まずにローカルのmasterにコミットすると互いに独立した変更であっても一旦remote masterをマージしないとプッシュ出来ず、コミットグラフが汚れてしまう。
また、CUIが直感的でなく、理解しづらいという声もある。それはこういう皮肉にも現れている&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://imgs.xkcd.com/comics/git.png&#34; alt=&#34;gitの皮肉&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まあ、言われてみれば私もこのスライドを見てようやく理解した。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/l0beYVXFDsBY3P&#34; width=&#34;595&#34; height=&#34;485&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/ktateish/git-concept1&#34; title=&#34;コンセプトから理解するGitコマンド&#34; target=&#34;_blank&#34;&gt;コンセプトから理解するGitコマンド&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/ktateish&#34; target=&#34;_blank&#34;&gt;ktateish&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;他のVCSにも色々特色はあって、歴史は神聖なるmercurial、履歴にアクセスしてこそのVCSなFossil、レポジトリとはパッチの集合であるDarcsなどなど。&lt;/p&gt;

&lt;p&gt;この中でもDarcsは大きく毛色が違うように思える。レポジトリは依存関係のあるパッチの集合で、互いに独立なパッチは相互作用しない。なので上に挙げたcherry pickだとかremote vs localの問題とかが起きない。
それにパッチベースの管理なのでメールでパッチを送り合うような古いシステムでも困らない。少なくともforkしてpull requestよりはパッチを送った方がなんぼか筋は良い気がする。他のVCSがsnapshot-basedなのに対してdarcsはpatch-basedになる。&lt;/p&gt;

&lt;p&gt;さて、このDarcs、そこまで知らない人も多いかと思うが古くはGHCの開発に使われていたり(gitに移行した)、common-lisp.netで使われていたり(リニューアルの時に内部がgitlabになってdarcsサポートはドロップされた)した。
Haskellで書かれていたのとモデルが(理論的には)綺麗なので函数型な人達には人気があったようだ。&lt;/p&gt;

&lt;p&gt;Darcsを使っていたプロジェクトがGitに移行したことから分かるように、Darcsにも問題があった(らしい)。1つはパフォーマンスの問題で、Haskellで書かれていたので流石にCで書かれたGitには勝てなかった。
さらには、勘の良い人は気付いたかもしれないが、パッチ同士の依存関係だけで管理してるとマージの時に最悪計算量が $O(2^n)$ になる(多くの場合は $O(n)$ で済むらしい)。&lt;/p&gt;

&lt;p&gt;その他のDarcsの問題についてはこちらを参考されれば。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://togetter.com/li/120640&#34;&gt;GHC の開発の darcs から git への移行 - Togetterまとめ&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;pijul:ea7808ae797e23f21c915a040fcfbb48&#34;&gt;Pijul&lt;/h1&gt;

&lt;p&gt;今回話題に出したPijulはDarcsに影響を受けている。レポジトリとは依存関係を持ったパッチの集合で、パッチ同士の関係はGitに比べれば薄いが、snapshot-basedとpatch-basedの両方の良い所を取り入れている。
Pijulの特色は&lt;a href=&#34;http://arxiv.org/abs/1311.3903&#34;&gt;A Categorical Theory of Patches&lt;/a&gt;の成果を取り入れていて、Darcsにあった計算量の問題が改善している。
この理論はファイルを対象、パッチを射とした圏を考えると、互いにコンフリクトしないパッチは同時に適用出来てかつ適用の順序に依らないことは圏論に於ける「押し出し」に一致することに着目している。
さらにこのパッチ圏を拡張(余完備化)することでコンフリクトが起きないように出来る。&lt;/p&gt;

&lt;p&gt;さて、Pijulにすると何が嬉しいのかというと、色々ある。
Darcsのようにパッチベースな点は言わずもがな、パッチベースなのでパッチを作った後でブランチを切ることが出来る。
実際に作業をしてみてブランチの名前が不適切だったな、とかブランチを切る前に名前を考えるのに一瞬手が止まったりすることがない。
尚、Pijulの現バージョン(0.2)では内部構造的にはブランチを扱えるものの、インターフェースのコマンドがないため事実上ブランチは作れないらしい。
また、データの持ち方的にgit blame相当の機能が速いなどそれなりの特色を出している。&lt;/p&gt;

&lt;p&gt;開発言語もOCaml、Scala、Haskell、Cなどを試して今はRustがベストフィットだと落ち着いたらしい。 &lt;code&gt;cargo install pijul&lt;/code&gt; でインストール出来る。
Rustで開発したお陰もあってDarcsより大分速いらしい。&lt;/p&gt;

&lt;p&gt;Darcsユーザには受けがいいようで、darcs to pijulブリッジも作られようとしているらしい。&lt;/p&gt;

&lt;p&gt;個人で使うには困らない程度にまで安定したら楽しみだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nexus 5にUbuntu Touchのインストール</title>
      <link>/blog/2016/02/10/nexus_5niubuntu_touchnoinsuto_ru</link>
      <pubDate>Wed, 10 Feb 2016 23:09:09 +0900</pubDate>
      
      <guid>/blog/2016/02/10/nexus_5niubuntu_touchnoinsuto_ru</guid>
      <description>

&lt;p&gt;κeenです。先日中古のNexus 5を入手したのでUbuntu Touchをインストールしました。その時のメモ。
尚、Multi ORMなどを使ったマルチブートではなく完全にAndroidを殺したシングルブートです。&lt;/p&gt;

&lt;p&gt;色々調べてみましたが&lt;a href=&#34;https://developer.ubuntu.com/en/start/ubuntu-for-devices/installing-ubuntu-for-devices/&#34;&gt;公式ドキュメント&lt;/a&gt;のままやるのが一番無難なようです。
まあ、スクショがないので他のサイトのスクショは参考にした方がいいかもしれませんが。&lt;/p&gt;

&lt;p&gt;途中adbを使ったりする部分も丁寧に解説してるのでAndroid初心者でも問題ないはず。&lt;/p&gt;

&lt;h1 id=&#34;ツールの準備:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;ツールの準備&lt;/h1&gt;

&lt;p&gt;Ubuntu公式で案外色々なツールを用意してくれている模様。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:ubuntu-sdk-team/ppa
sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でppaを登録した後は&lt;/p&gt;

&lt;p&gt;Ubuntu Touchインストールに必要なツール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install ubuntu-device-flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;USBで繋いだデバイスをデスクトップから操作するのに便利なツール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install phablet-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をインストールします。（恐らく）このコマンドでadbとfastbootも入ります。&lt;/p&gt;

&lt;h1 id=&#34;androidのusbデバッグを有効にする:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;AndroidのUSBデバッグを有効にする&lt;/h1&gt;

&lt;p&gt;普段から自機でAndroidアプリを開発してない人はこのステップが必要でしょう。&lt;/p&gt;

&lt;h2 id=&#34;開発者モードの解放:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;開発者モードの解放&lt;/h2&gt;

&lt;p&gt;[設定のアプリ] → [一般] → [端末情報] → [ソフトウェア情報]&lt;/p&gt;

&lt;p&gt;と進んで[ビルド番号]を7回タップすると開発者モードが解放されます。&lt;/p&gt;

&lt;p&gt;私がAndroid Appを作ってた頃(Android 2.3)にはこんな手順なかったんですけどいつのまにやら変わったんですね。&lt;/p&gt;

&lt;h2 id=&#34;usbデバッグの有効化:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;USBデバッグの有効化&lt;/h2&gt;

&lt;p&gt;さて、これで[一般]タブに戻ると[開発者向けのオプション]という項目が出てくるのでそこからUSBデバッグを有効にしましょう。&lt;/p&gt;

&lt;h1 id=&#34;nexus-5を繋ぐ:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;Nexus 5を繋ぐ&lt;/h1&gt;

&lt;p&gt;USBケーブルでNexus 5をPCに繋ぎます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb devices
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で1つデバイスが表示されていたらちゃんとデバッグモードで繋げています。&lt;/p&gt;

&lt;h1 id=&#34;androidデータのバックアップ:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;Androidデータのバックアップ&lt;/h1&gt;

&lt;p&gt;Androidに未練はなくてももしUbuntu Touchのインストールに失敗した時に引き返せるようにバックアップは必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb backup -apk -shared -all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のコマンドでカレントディレクトリに&lt;code&gt;./backup.ab&lt;/code&gt;という名前でデータが吸い出されます。&lt;/p&gt;

&lt;p&gt;さらにAndroidの再インストールに必要なデバイスデータも取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb shell grep ro.product.name /system/build.prop &amp;gt; mydevicedata \
&amp;amp;&amp;amp; adb shell grep build.id /system/build.prop &amp;gt;&amp;gt; mydevicedata \
&amp;amp;&amp;amp; adb shell grep ro.product.device /system/build.prop &amp;gt;&amp;gt; mydevicedata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中身はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat mydevicedata
ro.product.name=hammerhead
ro.product.device=hammerhead
ro.build.id=MMB29S
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ブートローダのアンロック:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;ブートローダのアンロック&lt;/h1&gt;

&lt;p&gt;そろそろ危いところですね。&lt;/p&gt;

&lt;p&gt;Androidの再起動 &amp;amp; ブートローダへ突入。倒れたドロイド君が現れます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb reboot bootloader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてアンロックします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo fastboot oem unlock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デバイス側で色々訊かれるので音量ボタンと電源ボタンを駆使して答えていきましょう。&lt;/p&gt;

&lt;p&gt;質問が終わってドロイド君の画面に戻ったら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fastboot reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;します。これでAndroidは初期化されてるので最初のセットアップを済ませましょう。どうせ直ぐに殺すので最小限で大丈夫です。&lt;/p&gt;

&lt;h1 id=&#34;ubuntu-touchのインストール:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;Ubuntu Touchのインストール&lt;/h1&gt;

&lt;p&gt;さて、ここは公式ドキュメントと異なる部分です。
&lt;a href=&#34;https://developer.ubuntu.com/en/start/ubuntu-for-devices/image-channels/&#34;&gt;公式サポートのチャネル&lt;/a&gt;ではNexus 5がサポートされていません。
&lt;a href=&#34;https://wiki.ubuntu.com/touch/devices&#34;&gt;Ubuntu wiki&lt;/a&gt;にいくとコミュニティベースでホストされているイメージがあるのでそれを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ubuntu-device-flash --server=https://system-image.ubports.com touch --channel=ubuntu-touch/stable --bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあな量ダウンロードしますが放置しておけばそのままubuntu touchのインストールが完了します。&lt;/p&gt;

&lt;p&gt;おめでとうございます。&lt;/p&gt;

&lt;h1 id=&#34;触ってみた所感:25cc80b2d2efc117f9e9a4e2a1f1b761&#34;&gt;触ってみた所感&lt;/h1&gt;

&lt;p&gt;上下左右の端からスワイプインするとメニューとか諸々が出てくるのは面白い。特に左のメニューはUbuntu使いなら体に馴染む。
使い勝手は悪くなさそう。Android使いならすぐに馴染める。&lt;/p&gt;

&lt;p&gt;アプリはまだまだといった所。ストアのアプリも少なければCanonicalの公式アプリもWeb Appという仕上がり(Twitterがモバイル版Webそのままだった)&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;in&#34; dir=&#34;ltr&#34;&gt;Ubuntu Touch nihongo utenai?&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/696885260655570944&#34;&gt;2016, 2月 9&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;一応パッチは出ている。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://code.launchpad.net/%7Ecosmos-door/ubuntu-keyboard/japanese-keyboard-rebooted/+merge/268158&#34;&gt;Merge into trunk : japanese-keyboard-rebooted : Code : ubuntu-keyboard&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispで高速行列演算</title>
      <link>/blog/2016/02/04/common_lispdekousokugyouretsuenzan</link>
      <pubDate>Thu, 04 Feb 2016 23:47:34 +0900</pubDate>
      
      <guid>/blog/2016/02/04/common_lispdekousokugyouretsuenzan</guid>
      <description>

&lt;p&gt;κeenです。Common Lispから線形代数ライブラリを使うポストで比較にCommon Lispのコードが出されていたのですがもう少し改良出来そうだったので少しばかり高速化してみました。&lt;/p&gt;

&lt;p&gt;そのポストはこちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://d.hatena.ne.jp/masatoi/20160204/1454519281&#34;&gt;Common Lispで行列演算: LLA(Lisp Linear Algebra)を使う - 翡翠はコンピュータに卵を生むか&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;圧倒的にCommon Lispが遅いですね。そのコードはこちらから。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tanakahx.hatenablog.com/entry/2015/09/25/070000&#34;&gt;Python (NumPy) と Common Lisp (LLA) で行列積の実行速度を比較する - 不確定特異点&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;行列計算(GEMM)部分を抜き出すとこうなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun simple-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))
      (dotimes (row rows)
        (dotimes (col cols)
          (dotimes (k cols)
            (incf (aref result row col)
                  (* (aref ma row k) (aref mb k col))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを&lt;code&gt;*N*&lt;/code&gt; = 256, で100回繰り返したら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   4.688 seconds of real time
;;   4.692000 seconds of total run time (4.688000 user, 0.004000 system)
;;   100.09% CPU
;;   13,564,728,093 processor cycles
;;   26,216,000 bytes consed

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とのこと。まあ、まだ高速化の余地はありそうです。&lt;/p&gt;

&lt;h1 id=&#34;キャッシュする:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;キャッシュする&lt;/h1&gt;

&lt;p&gt;内側のループをみるとこうなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;          (dotimes (k cols)
            (incf (aref result row col)
                  (* (aref ma row k) (aref mb k col))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;incf&lt;/code&gt;をばらすとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;          (dotimes (k cols)
            (setf (aref result row col)
                  (+ (aref result row col) (* (aref ma row k) (aref mb k col)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値として参照している方の&lt;code&gt;(aref result row col)&lt;/code&gt;は&lt;code&gt;k&lt;/code&gt;に依存しないのでループの外に出せます。
書き込んでいる方は場所だから仕方ない。&lt;/p&gt;

&lt;p&gt;これをキャッシュするようにすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun caching-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((cell (aref result row col)))
           (dotimes (k cols)
             (setf (aref result row col)
              (+ cell (* (aref ma row k) (aref mb k col)))))
           )))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じパラメータでベンチマークをとると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; 3.971 seconds of real time
;; 3.972000 seconds of total run time (3.972000 user, 0.000000 system)
;; 100.03% CPU
;; 11,491,319,119 processor cycles
;; 26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2016-02-28 追記:&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; キャッシュのところ、resultのインデックスにkは使ってないけど、kが進むごとに対象の要素は変化してるはずなので、このキャッシュのしかたはまずいのでは?&lt;/p&gt;&amp;mdash; goskevich (@gos_k) &lt;a href=&#34;https://twitter.com/gos_k/status/700622885933613056&#34;&gt;2016年2月19日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということでこれは間違ってました。&lt;/p&gt;

&lt;h1 id=&#34;ループアンローリング:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;ループアンローリング&lt;/h1&gt;

&lt;p&gt;さて、先程の内側のループ、仕事が少ないですね。小さな仕事をチマチマループしてるとイテレーションコストが嵩みます。
1回のイテレーションでの仕事を増やすべく、ループアンローリングをしましょう。&lt;/p&gt;

&lt;p&gt;コピペはダルいのでまずはマクロを。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro dotimes-unroll ((i n unroll) &amp;amp;body body)
  (let ((n_      (gensym &amp;quot;n&amp;quot;)))
    `(let ((,n_ ,n))
       (do ((,i 0))
           ((&amp;lt; ,n_ (the fixnum (+ ,unroll ,i)))
            (do ((,i ,i (the fixnum (1+ ,i))))
                ((&amp;lt; ,n_ (the fixnum (1+ ,i))))
              ,@body
              ))
         ,@(loop :repeat unroll :append (append body `((setq ,i (the fixnum (1+ ,i))))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;少し試してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(dotimes-unroll (i 10 3)
  (format t &amp;quot;~%~a&amp;quot;) i)
0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。&lt;/p&gt;

&lt;p&gt;それではこれを使ってアンロールします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun loop-unroll-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((cell (aref result row col)))
           (dotimes-unroll (k cols 16)
             (setf (aref result row col)
              (+ cell (* (aref ma row k) (aref mb k col))))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アンロール数は16が一番パフォーマンス出たようでした。&lt;/p&gt;

&lt;p&gt;さて、ベンチマークをしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   3.847 seconds of real time
;;   3.848000 seconds of total run time (3.848000 user, 0.000000 system)
;;   [ Run times consist of 0.012 seconds GC time, and 3.836 seconds non-GC time. ]
;;   100.03% CPU
;;   11,128,993,432 processor cycles
;;   26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;辛うじて速くなってる…。因みにこれのパフォーマンスはCPUの命令キャッシュの状況に依存するので何度か試すとこれより速いスコアが出ることもあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Evaluation took:
  3.338 seconds of real time
  3.340000 seconds of total run time (3.332000 user, 0.008000 system)
  [ Run times consist of 0.020 seconds GC time, and 3.320 seconds non-GC time. ]
  100.06% CPU
  9,657,259,219 processor cycles
  26,248,768 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;メモリアクセスしない:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;メモリアクセスしない&lt;/h1&gt;

&lt;p&gt;さて、最初にキャッシュした時に書き込まれている方の &lt;code&gt;(aref result row col)&lt;/code&gt; は場所だからキャッシュ出来ないといいました。まあ、それは正しいのですがループの中で毎回書き込む必要はありません。&lt;/p&gt;

&lt;p&gt;レジスタ上で計算を済ませて最後に書き込んであげれば十分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun on-register-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((res (aref result row col)))
           (dotimes-unroll (k cols 16)
             (setf res
                   (the single-float (+ res (* (aref ma row k) (aref mb k col))))))
           (setf (aref result row col) res))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを試してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   2.302 seconds of real time
;;   2.304000 seconds of total run time (2.300000 user, 0.004000 system)
;;   [ Run times consist of 0.008 seconds GC time, and 2.296 seconds non-GC time. ]
;;   100.09% CPU
;;   6,662,273,812 processor cycles
;;   26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;わお！急に速くなりました。 &lt;code&gt;(* 100 (- (/ 4.688 2.302) 1))&lt;/code&gt; ≒ 103、 100%近い高速化です。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;特に深い意味はなかったのですがパタヘネに載っていたやつを試してみたくて遊んでみました。&lt;/p&gt;

&lt;p&gt;普通に行列計算したいなら線形代数ライブラリ使った方が良いと思います。&lt;/p&gt;

&lt;h1 id=&#34;ノート:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ループアンローリングの部分をイテレーションコストで説明しましたが他にも1ループ内の命令数が増えると組み合わせパズルのピースが増えるので最適化されやすくなります。まあ、SBCLは覗き穴最適化をほとんどしないのであまり意味ありませんが。気になる方はディスアセンブルしてみて下さい。&lt;/li&gt;
&lt;li&gt;このあと、 &lt;code&gt;(aref mb k col)&lt;/code&gt; がCPUキャッシュを無駄にしているという話からキャッシュサイズ毎に行、列を分けて計算するやり方を紹介しようとしたのですが逆に遅くなってしまいました。付録Aにコードを置いておきます。うーむ。&lt;/li&gt;
&lt;li&gt;本当はさらにこのセグメント毎にスレッドに計算を投げて並列化したかったのですがセグメントで高速化しなかったので萎えて諦めました。&lt;/li&gt;
&lt;li&gt;パタヘネ的にはSIMDも使うのですが深夜に近付いてきて面倒になったのでこの辺でやめました。Common Lisp(SBCL)からSIMD命令を使うには&lt;a href=&#34;http://keens.github.io/blog/2014/12/02/vopdeyou-bu/&#34;&gt;私の過去のエントリ&lt;/a&gt;を参照して下さい。&lt;/li&gt;
&lt;li&gt;本気で行列計算をしたいなら今回の $O(n^3)$ のアルゴリズムだけでなくStrassenのアルゴリズムやCoppersmith-Winogradのアルゴリズムも検討すべきです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;付録a:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;付録A&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun segmented-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let* ((segment 16)
         (rows (array-dimension ma 0))
         (cols (array-dimension mb 1))
         (colseg (floor cols segment))
         ktmp coltmp
         k col
         )
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (ci colseg)
          (setf coltmp (the fixnum (* ci segment)))
          (dotimes (ki colseg)
            (setf ktmp (the fixnum (* ki segment)))
           (dotimes (cs segment)
             (setf col (the fixnum (+ coltmp cs)))
             (let ((res (aref result row col)))
               (dotimes (ks segment)
                 (setf k (the fixnum (+ ktmp ks)))
                 (setf res
                       (the single-float (+ res (* (aref ma row k) (aref mb k col))))))
               (setf (aref result row col) res))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rustのパッケージをcrates.ioに登録する</title>
      <link>/blog/2016/01/31/rustnopakke_jiwocrates_ionitourokusuru</link>
      <pubDate>Sun, 31 Jan 2016 14:43:14 +0900</pubDate>
      
      <guid>/blog/2016/01/31/rustnopakke_jiwocrates_ionitourokusuru</guid>
      <description>

&lt;p&gt;κeenです。技術の話題を書くのは久し振りですね。今日初めてRustのパッケージのセントラルレポジトリ、&lt;a href=&#34;crates.io&#34;&gt;crates.io&lt;/a&gt;にパッケージを登録したのでその流れを共有します。&lt;/p&gt;

&lt;h1 id=&#34;登録したいパッケージを用意する:68d62f44abaeccb48e3489e820073d3b&#34;&gt;登録したいパッケージを用意する&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logge&lt;/a&gt;を作りました。
しばらく前に(Advent Calendar向けに)それっぽく動くところまで作って放置してたやつですね。これを整形していきます。&lt;/p&gt;

&lt;h1 id=&#34;任意-ドキュメントを生成する:68d62f44abaeccb48e3489e820073d3b&#34;&gt;(任意)ドキュメントを生成する&lt;/h1&gt;

&lt;p&gt;Rustには素晴しき &lt;code&gt;cargo doc&lt;/code&gt; があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo doc --no-deps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でドキュメントを生成しましょう。ドキュメントを書いてないなら&lt;a href=&#34;http://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/documentation.html&#34;&gt;こちら&lt;/a&gt;を見ながら書きましょう（すいません、私の奴は全然書いてないです…）。
&lt;code&gt;target/doc&lt;/code&gt; 以下に生成されたドキュメントがあるので適当に &lt;code&gt;gh-pages&lt;/code&gt; ブランチに放り込みましょう。
尚、&lt;code&gt;--no-deps&lt;/code&gt; オプションがないと依存パッケージのドキュメントも全部生成してしまいます。&lt;/p&gt;

&lt;p&gt;求: gh-pages管理のベストプラクティス。&lt;/p&gt;

&lt;h1 id=&#34;パッケージ情報を充実させる:68d62f44abaeccb48e3489e820073d3b&#34;&gt;パッケージ情報を充実させる&lt;/h1&gt;

&lt;p&gt;普段使っているままの &lt;code&gt;Cargo.toml&lt;/code&gt; だとcrates.ioで見た時に情報が全然ありません。
&lt;code&gt;[package]&lt;/code&gt; セクションに色々書きましょう。私の場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[package]
name = &amp;quot;file_logger&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Sunrin SHIMURA (keen) &amp;lt;3han5chou7@gmail.com&amp;gt;&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;から&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[package]
name = &amp;quot;file_logger&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Sunrin SHIMURA (keen) &amp;lt;3han5chou7@gmail.com&amp;gt;&amp;quot;]
repository = &amp;quot;https://github.com/KeenS/file_logger&amp;quot;
keywords = [&amp;quot;log&amp;quot;, &amp;quot;file&amp;quot;]
license-file = &amp;quot;LICENSE&amp;quot;
readme = &amp;quot;README.md&amp;quot;
description = &amp;quot;A simple logger backend that outputs to a file. \nThis is alpha state.&amp;quot;
documentation = http://KeenS.github.io/file_logger/file_logger/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になりました。
あ、ちゃんとライセンスも明示しましょうね。&lt;/p&gt;

&lt;p&gt;どういう情報が書けるのかは&lt;a href=&#34;http://doc.crates.io/manifest.html&#34;&gt;ここ&lt;/a&gt;に載ってます。&lt;/p&gt;

&lt;h1 id=&#34;crates-ioにログインする:68d62f44abaeccb48e3489e820073d3b&#34;&gt;crates.ioにログインする&lt;/h1&gt;

&lt;p&gt;[crates.io]()に行き、右上にあるGitHubログインボタンをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/login.png&#34; alt=&#34;github login&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そうするとログイン状態になります&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/loggedin.png&#34; alt=&#34;github logged in&#34; /&gt;&lt;/p&gt;

&lt;p&gt;メニューから&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/menu.png&#34; alt=&#34;menu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Account Settingsに飛ぶと下記のようにログイン用cargoコマンドが提示されるのでそのままペタっとコマンドラインに貼って終了です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/crates.io/account_settings.png&#34; alt=&#34;account settings&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;パッケージング:68d62f44abaeccb48e3489e820073d3b&#34;&gt;パッケージング&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ cargo package
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;crates-ioに登録する:68d62f44abaeccb48e3489e820073d3b&#34;&gt;crates.ioに登録する&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ cargo publish
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;その他:68d62f44abaeccb48e3489e820073d3b&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;パッケージに含めるファイルを細かく調整したい、既にpublishしたパッケージをdeprecated的な扱いにしたいなどは&lt;a href=&#34;http://doc.crates.io/crates-io.html&#34;&gt;こちら&lt;/a&gt;にドキュメントが載っています。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:68d62f44abaeccb48e3489e820073d3b&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;crates.ioにログインしたよ&lt;/li&gt;
&lt;li&gt;Cargoを使えば簡単にパッケージを登録出来るよ&lt;/li&gt;
&lt;li&gt;Cargoってすごいね&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Lisp Meetup3周年に寄せて</title>
      <link>/blog/2016/01/27/lisp_meetup3shuunenniyosete</link>
      <pubDate>Wed, 27 Jan 2016 23:40:11 +0900</pubDate>
      
      <guid>/blog/2016/01/27/lisp_meetup3shuunenniyosete</guid>
      <description>&lt;p&gt;κeenです。昨日、&lt;a href=&#34;http://lisp.connpass.com/event/25546/&#34;&gt;Lisp Meetup #36&lt;/a&gt;が行なわれました。1回テックトークを挟んでるのでこれでちょうど丸3年、毎月Lisp Meetupが行われたことになります。&lt;/p&gt;

&lt;p&gt;Lisp Meetupは&lt;a href=&#34;http://shibuya.lisp-users.org/&#34;&gt;Shibuya.lisp&lt;/a&gt;が基本、毎月開催している草の根活動で、Lisper同士の交流を目的として主に希望者によるトークをメインとした会です。&lt;/p&gt;

&lt;p&gt;毎月Common Lisp、Clojure、Scheme回でローテーションしていて、近頃はScheme回にSchemerが来ないことからScheme回を減らして運用されています。
最初に述べた通りLisp Meetupだけで36回、丸3年活動してきました。ここ最近は定員にギリギリまで人が集まるくらいの盛況で何よりです。
ここまで継続したことを祝って記念ステッカーを作りました。私はほとんど何もしてませんが。@potix2さんに感謝。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;今日のLisp Meet Upは3周年記念ですね。先程ステッカー届きました。 &lt;a href=&#34;https://t.co/IRKkKVnkeU&#34;&gt;pic.twitter.com/IRKkKVnkeU&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/691875297940148224&#34;&gt;2016, 1月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;私が初めて参加したのは第7回から、運営になったのが1年後の第19回から(の筈)。
2年半サイバーエージェントの会場に通って気付いたらサイバーエージェントの社員になって、一勉強会がここまで大きく人生に影響するのかと感慨に耽る次第です。
何を大袈裟に、と思うかもしれませんがプログラミング経験が調子に乗ってきた時とLisp Meetupに参加し始めた時期が重なるので個人的には感慨に耽るだけのものがあるのです。&lt;/p&gt;

&lt;p&gt;さて、他のメジャーな言語の勉強会でも中々聞かない3周年ともなるとまた別種の問題も出てくる訳です。
その1つが「固定化」問題です。1度もLisp Meetupに来たことのない方はこう思う訳です: 何度も回を重ねる内にメンバーが固定化されて一見さんお断りな雰囲気になってるんじゃないかと。
実際のところLisp Meetupにはそんな雰囲気はなく、何度も来てる人もいれば久しぶりに来た人、最近よく来る人、初めて来る人色々いる訳です。
実情がどうあれ、お尻の数字が大きいだけで一番来て欲しい初心者が来なくなるならと、一度は名前を変えて連番をリセットしようかとも話されましたが結局今のLisp Meetupのままでいます。
Lisp Meetupといえば私のようによく分からない発表をしてても暖かく受け入れてくれる優しい人達の集りなのですが、とはいえ外から見て「初めての勉強会でLisp Meetupは怖い」などと言われると中々考えることがあります。
まあ、それでも初心者や初参加の人は毎回数人は来てるのでこれ以上増やそうとするとこれより大きな会場を確保する必要があって中々ハードルは高いのですが。初心者は大歓迎ということは伝えておこうかと思います。&lt;/p&gt;

&lt;p&gt;さて、次回はClojure回です。そろそろScheme回を…と思ったのですが発表者が集りそうにないので見送られました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;少し気の早い話ですが来月2月の &lt;a href=&#34;https://twitter.com/hashtag/lispmeetup?src=hash&#34;&gt;#lispmeetup&lt;/a&gt; でSchemeをテーマにするとしたらみなさんどうですか&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/688627343112278017&#34;&gt;2016, 1月 17&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;3月には開催しようかと話し合われている最中なのでSchemer各位、SICP読書中の各位は準備をして開催して欲しいオーラを出して頂けると開催決定の後押しになります。&lt;/p&gt;

&lt;p&gt;ということで来月以降もLisp Meetupをよろしくお願いします。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>独学でプログラミングをやってきた中で良かった技術書50選</title>
      <link>/blog/2016/01/17/dokugakudepuroguraminguwoyattekitanakadeyokattagijutsushowoageteiku</link>
      <pubDate>Sun, 17 Jan 2016 16:48:28 +0900</pubDate>
      
      <guid>/blog/2016/01/17/dokugakudepuroguraminguwoyattekitanakadeyokattagijutsushowoageteiku</guid>
      <description>

&lt;p&gt;今まで読んできた技術書の中で良かったものを挙げていく。
そろそろ本棚が溢れるので捨てる前に書き留めておく。
あとはGitHub PagesがアフィOKとのことなので試してみようかと。50冊分（以上）アフィがあるのでページが重いがご容赦を。&lt;/p&gt;

&lt;p&gt;私は独学でプログラミングを始めたので情報系専攻の人には何をそんなという本も混っているだろうが価値は人それぞれ違う。&lt;/p&gt;

&lt;p&gt;一応私自身について語っておくと学生時代はプログラミングに興味を持ちつつも数学科に進んだ。
しかしそこでもプログラミングへの興味は薄れず、色々本を読んだり同学年の情報科学科の真似をしたりしていた。
今思えば日本の精鋭たる東大情報科学科の人達に勝てる筈もなかったのだが学生時代に我武者羅になれたのは悪い経験ではなかった。
私が興味があったのは主にプログラミング言語そのもの、特にLispとその周辺。&lt;/p&gt;

&lt;h1 id=&#34;何故本か:390eeec2ebe741f3494b487839fdedf9&#34;&gt;何故本か&lt;/h1&gt;

&lt;p&gt;挙げていく前に1つだけ。Webに大量に情報がある今、何故本かについて説明したい。簡潔に言うと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文章が推敲されていて読み易い&lt;/li&gt;
&lt;li&gt;1つの情報ソースに多彩な内容が載っている&lt;/li&gt;
&lt;li&gt;巨大な情報の中で一貫性が取れている&lt;/li&gt;
&lt;li&gt;出版されている以上ある程度内容に責任を持って書かれている&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;どれもWebの情報は断片的で無責任に書かれているような書き方だが凡そ間違ってはいないと思う。
私のブログだってよく間違いが書いてある（そして申し訳ないことに面倒くさがって修正しないままのことも多々ある）。
本屋に足を運んでパラパラ捲って気に入った本を買うのが一番確実な情報収集の仕方だと思う。勿論本だけでは足りないことも多いが。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では、本を挙げていく。順不同で、本棚を見ながらあれこれ挙げることにする。&lt;/p&gt;

&lt;h1 id=&#34;1-作りながら学ぶruby入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;1. 作りながら学ぶRuby入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B00GJGOPU0&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本は私がプログラミングを学び始めた時にお世話になった。初心者には0からアプリケーションを作るまでのノウハウがない。それを丁寧に教えてくれる。
よく「プログラミングを始めたいんですがどうやって覚えました？」と聞かれるが、毎度この本と下記の逆引きを勧めている。&lt;/p&gt;

&lt;p&gt;もしかしたらRubyのバージョンが古くてサンプルコードが動かないかもしれない。&lt;/p&gt;

&lt;h1 id=&#34;2-ruby逆引きハンドブック:390eeec2ebe741f3494b487839fdedf9&#34;&gt;2. Ruby逆引きハンドブック&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4863540221&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;私の人生を変えたともいうべき1冊。プログラミングを英作文に例えるならこの本は和英辞典にあたる。
そして初心者にとっては「○○したいから□□する」は「へー。○○したいという需要があるんだ、そして□□で出来るんだ」と同時に2つを教えてくれる。
この1冊前部読むことでRubyを書くときの手札を確認出来た。&lt;/p&gt;

&lt;p&gt;惜しいことにこの本も少し古くなってきた。&lt;/p&gt;

&lt;h1 id=&#34;3-メタプログラミングruby:390eeec2ebe741f3494b487839fdedf9&#34;&gt;3. メタプログラミングRuby&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873117437&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Rubyをやるならこの本を一度は読んだ方がいい。&lt;code&gt;method_missing&lt;/code&gt;などRubyコミュニティでは非常に重要なテクニックが載っている。私は初版を読んだが第2版が出ているようだ。&lt;/p&gt;

&lt;h1 id=&#34;4-emacsテクニックバイブル:390eeec2ebe741f3494b487839fdedf9&#34;&gt;4. Emacsテクニックバイブル&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774143278&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;るびきちさんの本を紹介したのでついでにこの本も。Emacsの便利な使い方から人気プラグインまで様々に解説されている。Emacsを使い熟したい方にお勧めする(そして私のように帰ってこれなくなるといい。)。
今ではいくつか動かない/入手出来ないプラグインはあるものの基本的な使い熟すための指南というか思想は色褪せない。&lt;/p&gt;

&lt;h1 id=&#34;5-emacs-lispテクニックバイブル:390eeec2ebe741f3494b487839fdedf9&#34;&gt;5. Emacs Lispテクニックバイブル&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774148970&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;同じくるびきちさんの本。コピペだけでinit.elを書くのが嫌な人、片手間程度でもEmacs Lispを書く人にお勧めする。私もこの本を境にして片手間程度にEmacs Lispを書くようになった。
さらにComon Lisperである私にはCommon Lispマクロの解説が非常に分かりやすくて参考になった。&lt;/p&gt;

&lt;h1 id=&#34;6-入門vi:390eeec2ebe741f3494b487839fdedf9&#34;&gt;6. 入門vi&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873110831&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;例え熟練のEmacsユーザでもviは使えた方がいい。サーバに入った時にviしか使えないこともある。
Emacsをインストールしようにもインストールするための設定をviで書く必要がある。
nanoもあるが、リッチテキストエディタに馴れた手にはviの方が馴染む。&lt;/p&gt;

&lt;p&gt;そういう人に、この本は良い。Vim入門のようにごてごてしてなくて欲しい情報だけが書いてある。&lt;/p&gt;

&lt;h1 id=&#34;7-実践common-lisp:390eeec2ebe741f3494b487839fdedf9&#34;&gt;7. 実践Common Lisp&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274067211&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;私はほぼRubyでプログラミングに入門したが&lt;a href=&#34;http://docs.ruby-lang.org/ja/2.0.0/doc/spec=2fintro.html&#34;&gt;RubyはLispを参考に作られたと言われたら&lt;/a&gt;その原典たるLispにも興味が出るのは自然の流れ。当然私もCommon Lispを始めた。
Common Lispに入門するにあたって一番お世話になった一冊。早見表もあれば関数の解説もあり、実践の名の通りアプリケーションを作るところまでいける。
Common Lispといえばまずこの本をお勧めする。&lt;/p&gt;

&lt;h1 id=&#34;8-land-of-lisp:390eeec2ebe741f3494b487839fdedf9&#34;&gt;8. Land of Lisp&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873115876&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;オライリーの中でも異色の表紙で有名なこの本。このエイリアンはオライリーの本が出る前からLisp界隈で活躍していたりする。
モチーフは「他言語プログラマから見たLisper」なのでLisperのペットというようりはLisper自身。&lt;/p&gt;

&lt;p&gt;閑話休題。この本は実践Common Lispよりも易しいというか丁寧で、分かりやすく書いてある。
そしてちょこちょこゲームを作りながら進んでいくので飽きない。手を動かしたい人には本書を、後のリファレンスとしても役立てたい人には先の実践Common Lispをお勧めする。&lt;/p&gt;

&lt;h1 id=&#34;9-on-lisp:390eeec2ebe741f3494b487839fdedf9&#34;&gt;9. On Lisp&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274066371&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;大半がマクロについて書かれているPaul Grahamのマクロの本。Common Lisp中級者向けの必読書。
Common Lispを使っていてマクロを書く必要が出てきたあたりでこの本を読むといいと思う。
変数捕捉の問題から逆に変数を捕捉させるアナフォリックマクロの話、マクロを使って作る継続と非決定性計算などなどが載っている。&lt;/p&gt;

&lt;p&gt;他言語プログラマでも非衛生的なマクロを持つ言語を使うならこの本を読むと良いと思う。私の知る限り世界で一番マクロに詳しい本だ。&lt;/p&gt;

&lt;p&gt;マクロの本とはいったがLisp流のボトムアッププログラミングを指南していたりオブジェクトシステムやパッケージについての解説があったりと中々役に立つ指南書でもある。
また、名言も多いのでLisp界隈でよく言われる元ネタを知りたい時にもいい。&lt;/p&gt;

&lt;p&gt;訳者が高校生の時に訳し始めたので日本語はやや読みづらい。Webで無料で公開されていたりする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/&#34;&gt;On Lisp&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;10-let-over-lambda:390eeec2ebe741f3494b487839fdedf9&#34;&gt;10. LET OVER LAMBDA&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4434201581&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;過激な本。LOLの名で呼ばれる。Land of LispはLoL。一歩間違うと命を落しかねないので注意。「Common Lispこそが史上最高の言語だ」のスタンスで進んでいく。
LET OVER LAMBDA(lambdaの上のlet)とは、ラムダでletで作った変数を捕捉する話、クロージャの話をメインに据えている。
サーカスのようなプログラミングテクニックもあるかと思えば割と便利なツール、あるいはパフォーマンスチューニングについてなども載っていて、飽きない本。&lt;/p&gt;

&lt;p&gt;余談だが某所で「Land of Lispは聖典」と言われていたが本当にバイブル的な意味では先のOn Lisp、宗教的な意味ではこのLET OVER LAMBDAが聖典になると思う。&lt;/p&gt;

&lt;h1 id=&#34;11-real-world-ocaml:390eeec2ebe741f3494b487839fdedf9&#34;&gt;11. Real World OCaml&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=144932391X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Lispが函数型言語と言われいると他の函数型言語にも興味が出る。OCamlに半ば足を突っ込んでる時にこの本が公開されて読んだ。&lt;a href=&#34;https://realworldocaml.org/&#34;&gt;Webで草稿が公開されている&lt;/a&gt;。
普通に初心者に易しい内容だしコマンドラインのパースとか非同期プログラミングとかもあり充実満足な内容。
さらにランタイムシステムやコンパイラプラグインなどの深い話もあってOCaml上級者にも役に立つらしい（私はまだ初級者）。
数少ないOCaml書籍。オライリーでは唯一？&lt;/p&gt;

&lt;p&gt;このノリでReal World Standard MLとか出ないかな、出ないよな。Standard MLの書籍少ない…。これくらい？&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4320120248&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;12-プログラミングerlang:390eeec2ebe741f3494b487839fdedf9&#34;&gt;12. プログラミングErlang&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274067149&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;どうせなら他の函数型言語も試してみるといい。例えばErlangとか。これは飛行機本として有名なErlangの入門書。Erlang作者のJoe Armstrongが著している。
Erlangのアクターモデルについて何も知らなくても恐れる必要はない。この本がついている。全くの初心者からErlangの考え方、ETS、DETS、OTP、Mnesiaなどを学べる。&lt;/p&gt;

&lt;h1 id=&#34;13-すごいerlangゆかいに学ぼう:390eeec2ebe741f3494b487839fdedf9&#34;&gt;13. すごいErlangゆかいに学ぼう!&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274069125&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Erlang界隈では先の飛行機本が定本らしいが私はこのすごいE&amp;reg;本の方が肌に合った。ノリ良く進むしEUnitやDialyzerなどについても解説してある。
Erlang最高！なノリだが「うまい話ばかりじゃないですよ」とちゃんと現実も見ている。&lt;/p&gt;

&lt;h1 id=&#34;14-７つの言語-７つの世界:390eeec2ebe741f3494b487839fdedf9&#34;&gt;14. ７つの言語 ７つの世界&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274068579&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;さらにプログラミング言語に興味を持ったならこの本を読むといい。様々な言語を広く浅くやっている。
普通のプログラマなら言語の10くらい書けるものだがCライクな言語10個書けたところで大したことはない。
比してこの本はそれぞれにパラダイムの違う言語を7つ紹介している。Ruby、Io、Prolog、Scala、Erlang、Clojure、Haskell。
Ioなんかは中々知っている人は少ないのではないだろうか。そういう言語に3日だけ触れてみるのも悪くない。&lt;/p&gt;

&lt;h1 id=&#34;15-java言語で学ぶデザインパターン入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;15. Java言語で学ぶデザインパターン入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4797327030&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;人は、あまりに分かり易い解説を読むと初めてでも既知のように感じる。この本はそういう体験をさせてくれる。
プログラマとして生きる以上知っておかないといけないデザインパターンについて非常に分かりやすく丁寧に解説してある。
著者が物書きもしている結城先生なので日本語も非常に読み易い。&lt;/p&gt;

&lt;p&gt;大きな本だが解説を丁寧にするために膨らんでいるだけなので臆せず読んで欲しい。&lt;/p&gt;

&lt;h1 id=&#34;16-java言語で学ぶデザインパターン入門-マルチスレッド編:390eeec2ebe741f3494b487839fdedf9&#34;&gt;16. Java言語で学ぶデザインパターン入門 マルチスレッド編&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4797331623&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;マルチスレッドプログラミングは複雑で、書いてる本人すら状況を把握しづらい。
先にこの本を読んで基本的な考え方を身に付けているかいないかは大きく響く。
分かりやすい解説に加えて図解もあるので頭の中で動きをイメージしやすい。&lt;/p&gt;

&lt;h1 id=&#34;17-プログラミングコンテストチャレンジブック:390eeec2ebe741f3494b487839fdedf9&#34;&gt;17. プログラミングコンテストチャレンジブック&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4839941068&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;いわゆる蟻本。プログラミングコンテストに興味がなくてもこの本は良い本だ。
様々なアルゴリズムの解説とその実践が出来る。そしてグラフ関連のアルゴリズムに詳しい。
私がアルゴリズムに興味を持つきっかけになった一冊。&lt;/p&gt;

&lt;h1 id=&#34;18-アルゴリズムイントロダクション:390eeec2ebe741f3494b487839fdedf9&#34;&gt;18. アルゴリズムイントロダクション&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=476490408X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;アルゴリズムやデータ構造に詳しくなりたいのならこの本をお勧めする。
相当数のアルゴリズムやデータ構造が載っているばかりか、ちゃんと計算量の解析なんかもしている。しっかりと「考え方」が身につく本である。
練習問題も豊富にある。中々分厚いが辞書と思えば妥当でもある。&lt;/p&gt;

&lt;p&gt;ただ、内容は堅いのでかなりとっつきにくい。さらに、載っているのは疑似コードなので実際に試したいならそれなりに頭を使って自分の言語に翻訳する必要がある。&lt;/p&gt;

&lt;p&gt;アルゴリズムやデータ構造に関して、触りだけでいいならこの本がある。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4797306947&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;随分前に借りて読んだ本で、本棚にも並んでないので記憶が朧げだがプログラミング初学者~初心者に丁度いいくらいの内容だったと思う。&lt;/p&gt;

&lt;h1 id=&#34;19-purely-functional-data-structures:390eeec2ebe741f3494b487839fdedf9&#34;&gt;19. Purely Functional Data Structures&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=0521663504&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本はアルゴリズムイントロダクションの延長にあると言える。
最初に「ならし計算量」(償却計算量)を導入したあと、いくつかのデータ構造を下限オーダの操作のまま簡潔に関数的に実装していく。古い本なので恐らくは多くの人に馴染のないStandard MLで書かれているが簡潔な実装は一目瞭然、SMLを知らなくても読めるだろう。
その後遅延評価を導入して、上手く高速化する話、償却しなくても下限の計算量を維持出来る話、データ構造に「ひずみ」を溜めない話なんかが出てくる。&lt;a href=&#34;http://qiita.com/search?q=%E7%B4%94%E7%B2%8B%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0&amp;amp;sort=rel&#34;&gt;Qiitaに一部の解説がある&lt;/a&gt;のでこれを読んで興味が湧いた人は買うといいと思う。&lt;/p&gt;

&lt;h1 id=&#34;20-関数プログラミング-珠玉のアルゴリズムデザイン:390eeec2ebe741f3494b487839fdedf9&#34;&gt;20. 関数プログラミング 珠玉のアルゴリズムデザイン&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274050645&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本を読んだ時、衝撃を受けた。まず、内容が難しくて理解が及ばなかった。先述のアルゴリズムイントロダクションを読んだ上でだ。
そしてそれ以上に衝撃だったのが複雑なアルゴリズムをHaskellを使って驚くほど簡潔に実装していた点だ。
アルゴリズムを下限のオーダーで実装するのを前提として、「運算」を使って定数倍の高速化を試みる。魔法のようだった。&lt;/p&gt;

&lt;p&gt;比較的小さな本だが内容は見た目の3倍はあると思って読んだ方がいい。&lt;/p&gt;

&lt;p&gt;函数型言語を触る人なら必ず読んだ方がいい。難しいので完全に理解は出来なくてもこういう世界があることは知っておきたい。&lt;/p&gt;

&lt;h1 id=&#34;21-人間に勝つコンピュータ将棋の作り方:390eeec2ebe741f3494b487839fdedf9&#34;&gt;21. 人間に勝つコンピュータ将棋の作り方&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774153265&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;LispはかつてAIの言語として表舞台に立った。ならばLisperとしてAIは知っておきたい。当時まだ探索初心者だった私にとってこの本は色々ためになった。
min maxやnega max、αβ木探索なんかは初めて知ったし評価関数のパラメータを機械学習で決めるのも初耳だった。
読み物程度で詳しい技術の話は載ってないがAIに興味を持っていた私には面白い本だった。&lt;/p&gt;

&lt;h1 id=&#34;22-コンピュータ囲碁:390eeec2ebe741f3494b487839fdedf9&#34;&gt;22. コンピュータ囲碁&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4320123271&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;将棋AIが人間に勝つようになって、そろそろ別のゲームか、と思い始めてこの本を手に取った。
先の本とはうってかわってつぶさな実装が載っている。将棋とは違ったモンテカルロ法のアプローチが新鮮で面白い。
モンテカルロ法の探索を知らないのなら一度は読むと良いかもしれない。&lt;/p&gt;

&lt;p&gt;最近では画像認識によく使われるCNNを使った手法なんかもあるようだが今の囲碁AIはどうなっているのだろうか。&lt;/p&gt;

&lt;h1 id=&#34;23-やさしいインタープリタの作り方入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;23. やさしいインタープリタの作り方入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=487783219X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Lisperは一生に一度は自分のLispを作ると言われている。ならば、とこの本を手に取った。
プログラミング言語がどう動いているのかも知らない初心者には丁度良い内容だった。&lt;/p&gt;

&lt;p&gt;一応言うと私はこの本を参考にインタプリタを作った訳ではなくサラサラと眺めて概略だけを知った。
図書館で借りた本だったのでゆっくり読む時間がなかった。&lt;/p&gt;

&lt;h1 id=&#34;24-やさしいコンパイラの作り方入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;24. やさしいコンパイラの作り方入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4877832203&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;私が作りたいのはインタプリタだったが姉妹本ということで一緒に借りて読んだ。
感想はインタプリタと同じ。今Amazonのレビューを見ると酷評されていたのでゆっくり読むには向いてない本なのかもしれない。&lt;/p&gt;

&lt;h1 id=&#34;25-コンパイラ-原理-技法-ツール:390eeec2ebe741f3494b487839fdedf9&#34;&gt;25. コンパイラ―原理・技法・ツール&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=478191229X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;いわゆるドラゴンブック。コンパイラの定本。もう少しコンパイラに詳しくなろうと手にとった。著者達が構文解析の専門家のようで、本の半分くらいが構文解析に割かれている。
さらっと正規言語(正規表現)についても載っていたりする。私みたいにLispを作りたい人には複雑な構文解析の話は退屈だったが後半の翻訳や最適化の話は非常に面白かった。
中々堅いというか難しい本ではあるが、馴染めるならこれ以上のものはない一冊。&lt;/p&gt;

&lt;p&gt;余談だが著者のエイホはAhoと綴る。I am AHOというとめちゃくちゃコンパイラ出来る人と思われるだろう。&lt;/p&gt;

&lt;p&gt;因みにドラゴンブックと並び語られる本にタイガーブックがあるが私はまだ読んだことがない。その内読まねばと思っている。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4798114685&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;26-コンパイラの構成と最適化:390eeec2ebe741f3494b487839fdedf9&#34;&gt;26. コンパイラの構成と最適化&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4254121776&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;ドラゴンブックよりも最適化についてページを割いている本。人によりけりだがドラゴンブックよりもこの本を勧める人が多い。私もそれが妥当だと思う。
文体はさしてドラゴンブックと変わらないが変にカタカナ文字を日本語にしておらず(インタプリタ、コンパイラを解釈系、翻訳系と訳すなど)読み易い。&lt;/p&gt;

&lt;h1 id=&#34;27-きつねさんでもわかるllvm:390eeec2ebe741f3494b487839fdedf9&#34;&gt;27. きつねさんでもわかるLLVM&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4844334158&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;理論の話が出来ても現実のコンパイラを作るのは難しい。その1つにコードを吐く部分が泥臭い点がある。
LLVMを使えればそういう泥臭さを軽減出来る。さらにLLVMは低レベルな最適化もやってくれるのでコンパイラを作る時の手間をかなり省かせてくれる。&lt;/p&gt;

&lt;p&gt;LLVMは巨大だがこの本を読めばどこで何をやってるのか、LLVM IRがどんなものかは分かるようになる。
さらにパスやバックエンドなどそれぞれのプラグインの書き方も載っているので色々な切り口からLLVMを使いたい人にも役に立つ。
少なくともこの本を読まずしてLLVMが分からないと言ってはいけない。分かってなくて分かりたいなら読むべき。&lt;/p&gt;

&lt;p&gt;ところでLLVMといえばもう一冊あるがこちらはClangのためのLLVMといった感じでClangをハックしたい人向けな内容になっている。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4883379310&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;28-言語実装パターン:390eeec2ebe741f3494b487839fdedf9&#34;&gt;28. 言語実装パターン&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873115329&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;パーサジェネレータのANTLRの開発者が著した本。実際にいくつかDSLなどを作りながら進むのでエンジニア向けなのかもしれない。
一度借りて読んだ後本棚に置きたいなと思いつつまだ買っていない。&lt;/p&gt;

&lt;h1 id=&#34;29-正規表現技術入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;29. 正規表現技術入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774172707&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;一度&lt;a href=&#34;//KeenS.github.io/blog/2015/05/10/seikihyougengijutsunyuumonwoyonda/&#34;&gt;書評を書いた&lt;/a&gt;。
Webではまず得られない正規表現のまとまった情報が得られる。
ドラゴンブックでも扱われている正規言語だがこちらの方がコードを交えながら解説するので詳しくて分かりやすい。&lt;/p&gt;

&lt;p&gt;Onigmoのコードが載っているのでそれを見て&lt;a href=&#34;//KeenS.github.io/blog/2015/05/26/onigmowosaidai49_kousokukashitahanashi/&#34;&gt;最適化し&lt;/a&gt;、最終的には&lt;a href=&#34;http://qiita.com/blackenedgold/items/2ec4d8bfaf220409609d&#34;&gt;パッチがRubyに取り込まれる&lt;/a&gt;までの流れが出来た私にとっての思い出の1冊でもある。&lt;/p&gt;

&lt;p&gt;語彙が足りなくて申し訳ないが素晴しいの一言に付きる。&lt;/p&gt;

&lt;h1 id=&#34;30-型システム入門-プログラミング言語と型の理論:390eeec2ebe741f3494b487839fdedf9&#34;&gt;30. 型システム入門 −プログラミング言語と型の理論−&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274069117&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;コンパイラを作っていて外せないのが型システムの話題。それについて深く扱っているのがこの本。いわゆるTaPL。
初めて読んだ時、λだけで様々な関数を実装していくのが不思議でならなかったし、不動点コンビネータにも感動した。
2回目に読んだ時にはもう少し余裕があって操作的意味論も追えた。
次に読む時はもう少し深くまで読みたい。少くとも手を動かす必要はあるだろう。&lt;/p&gt;

&lt;p&gt;有名な定本ではあるが理論の本なのでどういうことを論じているか分からないまま読める本ではない。
しかし本棚に置いておくと「あれ？System F_ωってどんなシステムだっけ？」などとなった時にサッと引けて便利ではある。&lt;/p&gt;

&lt;h1 id=&#34;31-プログラミング言語の基礎概念:390eeec2ebe741f3494b487839fdedf9&#34;&gt;31. プログラミング言語の基礎概念&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4781912850&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;TaPLよりも軽くやりたいならこの本がある。TaPLに比べてずいぶん（物理的にも）軽く、要点を押えた内容で入り易い。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sampou.connpass.com/&#34;&gt;読書会も開かれている&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この本とTaPLの中間というかもう少しプログラミング言語の意味論に焦点を当てたものとしてWeb上だがソフトウェアの基礎がある。Coqの練習がてら手を動かすと良い。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://proofcafe.org/sf/&#34;&gt;ソフトウェアの基礎&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こちらも&lt;a href=&#34;http://readcoqart.connpass.com/&#34;&gt;読書会が開かれている&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;32-計算機プログラムの構造と解釈:390eeec2ebe741f3494b487839fdedf9&#34;&gt;32. 計算機プログラムの構造と解釈&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=489471163X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;もう少しエンジニア寄りのコンピュータサイエンスの本ならこれがある。
言わずと知れた名著、いわゆるSICP(しっくぴー)。表紙から魔導師本などとも言われる。計算機科学への深い洞察を与える。
訳が堅いとも言われるが大学生の教科書なんてみんな同じようなものだ。解析概論に比べたら読み易い。
初心者にプログラミングを教える時に適当な例を挙げるのに困ることがよくあるが、この本の題材の選び方は完璧だと思う。
理解の妨げになる余分な脂肪は落として完璧なまでに簡潔にしつつも関心を失わせない興味深いものを取り上げている。
題材のプログラミング言語としてSchemeが選ばれているが、そこも正解だと思う。Scheme自身にも余計な脂肪がない。&lt;/p&gt;

&lt;p&gt;最初のレベルはプログラミング初心者に合わせてあるが中身は計算機科学なのでストイックな初心者がゆっくり読むかある程度レベルをつけてから読むのが良いと思う。&lt;/p&gt;

&lt;h1 id=&#34;33-linuxプログラミングインターフェース:390eeec2ebe741f3494b487839fdedf9&#34;&gt;33. Linuxプログラミングインターフェース&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=487311585X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;普段OSのインタフェースがどうなってるかなんてプログラミング言語が隠蔽してくれるが、自分でプログラミング言語、Lispを作ろうと思ったら知る必要がある。
そういう時にこの本は役に立つ。&lt;/p&gt;

&lt;p&gt;C言語の良い所の1つにmanが充実している点が挙げられるが、この本はmanの編集者が著した本だ。
しかもmanよりも詳しくて、Linuxに出てくる概念のつぶさな説明、それぞれのインターフェースの細かな違い、早見表、違いを実感出来るコード例、Linuxに限らないコードの可搬性の話などなど枚挙に暇がない。&lt;/p&gt;

&lt;p&gt;今回挙げる中でも随一の重量を誇るが一番お勧めしたい一冊。無人島に1冊だけ持っていくとしたらこの本を選ぶ。&lt;/p&gt;

&lt;h1 id=&#34;34-operating-systems:390eeec2ebe741f3494b487839fdedf9&#34;&gt;34. Operating Systems&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4894717697&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;やはりOS上でLispを動かす以上OSについては避けて通れない。&lt;/p&gt;

&lt;p&gt;これはいわゆるMINIX本で、UNIXライクな小さなOS、MINIXを題材にOSについて論じる。
私は英語版を読んだが日本のAmazonに出回ってないようなので日本語版のリンクを挙げておく。
MINIXを題材とはいいつつも副題にDesign and Implementationとあるが、Implementationの部分でMINIXのコードリーディングが挟まる程度。Designの部分はMINIXに限らない一般的なことを論じる。&lt;/p&gt;

&lt;p&gt;IOについて、プロセスについて、メモリ管理についてなどなど、普段のプログラミングで使っているのに詳しくないのなら一度は読むべきだ。&lt;/p&gt;

&lt;p&gt;特に、IPC(プロセス間コミュニケーション)の部分はOS関係なく役に立つ。&lt;/p&gt;

&lt;p&gt;OSについてなら最近だと定本ではあるがMINIX本よりこちらの方が良いと勧められたことがあるがまだ読んでいない。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B014I57BEA&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B014RTDMFY&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B014RTDPJM&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;4部構成らしいが、なぜかvolum4が見当らない。&lt;/p&gt;

&lt;h1 id=&#34;35-computer-organization-and-design:390eeec2ebe741f3494b487839fdedf9&#34;&gt;35. Computer Organization and Design&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=0124077269&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;やはりCPU上でLispを動かす以上CPUについては避けて通れない。&lt;/p&gt;

&lt;p&gt;これも名著。いわゆるパタヘネ。副題にThe Hardware/Software Interfaceとある通り、ハードウェアとソフトウェアの境界を行ったり来たりして進んでいく。
コンピュータの中身なんて丸で知らない初心者でも読めて、CPUの構造や(MIPS)アセンブラを知ることが出来る。
本を通してCPUの構造を解説しつつその知識を使って行列計算を高速化していく。それで最後は200倍まで速くなる。高速なコードを書きたい人は是非読むと良い。&lt;/p&gt;

&lt;p&gt;また、この本は最新のCPU事情を追い掛けることも目的としていて、頻繁に改訂されている。
古くからある本だがこの第5版には大規模データセンターやモバイルデバイスでのCPUについても論じられている。&lt;/p&gt;

&lt;p&gt;尚、日本語版もあるが私は読んでないのでコメントは控える。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4822298426&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4822298434&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;余談だが、最初にパタヘネと間違えてヘネパタ、CPUを作る人向けの本を買ってしまったので勿体なくて読んだが私には早すぎたようだった。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=012383872X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;こちらも日本語版があるらしい。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4798126233&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;36-データマイニング入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;36. データマイニング入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4489020457&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;LispをやるならAI、AIでは機械学習が使われいるということから簡単な入門書を選んだ。
最初、これを選んだ時にはそこまで深く考えた訳ではないのだが後にこれ以上の入門書に出会ったことがない。
取り上げるトピックや理論と実践の配分、理論の踏み込み具合、図、などなど絶妙である。&lt;/p&gt;

&lt;p&gt;他にも統計や機械学習の入門書は色々に読んだが全てこの本の前には霞んでしまったのでこれしか挙げられない。&lt;/p&gt;

&lt;h1 id=&#34;37-エンジニアのための-データ可視化-実践-入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;37. エンジニアのための データ可視化[実践]入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774163260&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本の通称何なのだろう。3D円グラフ本？あんちべ本？あんちべ本はこれか。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4627817711&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;小中学校の社会や算数で習ったグラフの発展といったところ。しかし世の中思った以上に可視化の手法があって驚きが多かった。
データを可視化することがあるなら一度手を止めてこの本を読むだけの価値がある。&lt;/p&gt;

&lt;p&gt;詳しくは著者のブログを見るといい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://antibayesian.hateblo.jp/entry/2014/02/16/235830&#34;&gt;エンジニアのためのデータ可視化実践入門という本を書いた - あんちべ！&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;38-詳解-シェルスクリプト:390eeec2ebe741f3494b487839fdedf9&#34;&gt;38. 詳解 シェルスクリプト&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873112672&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Lispの処理系マネージャをシェルスクリプトで書き始めたのが大学3年生のこと。そのあたりでこの本を買った。
シェルスクリプトを書くときには是非この本をお勧めする。便利コマンドやTipsの他にシェルの引数の評価順序、互換性の話などこの本くらいでしか扱ってないような情報が多数載っている。
シェルのテキストベース、行指向の考え方を身につけることが出来る。私も知人からはシェルスクリプトの人と認識されているがその知識の根底にあるのはこの本。&lt;/p&gt;

&lt;h1 id=&#34;39-bsd-hacks:390eeec2ebe741f3494b487839fdedf9&#34;&gt;39. BSD Hacks&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873112184&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;古き良きBSDハッカーに思いを馳せたいならこの本を読むといい。FreeBSDを主としているがNetBSDやOpenBSDについての注釈もある。「telnetでメールを読む」など個人的にはすごい好きな本なのだが恐らく今の時代に需要はない。&lt;/p&gt;

&lt;h1 id=&#34;40-マスタリングnginx:390eeec2ebe741f3494b487839fdedf9&#34;&gt;40. マスタリングNginx&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873116457&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;NginXのパラメータやビルドオプションについて詳しい説明がある。
説明だけでなく、「CPUネックの時はワーカ数をコアと同じだけ、IOネックの時はコア数の1.5~2倍にするといい」など、パラメータ設定の目安もある。
NginXを扱うことがあるなら是非読んだ方がいい。そんなに分量はないので隙間時間に目を通せる。&lt;/p&gt;

&lt;p&gt;最近はnginx実践入門が話題だがまだ読んでいないので何も紹介出来ない。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774178667&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;41-初めてのsql:390eeec2ebe741f3494b487839fdedf9&#34;&gt;41. 初めてのSQL&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873112818&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;今更この本を挙げると笑われそうだが初学者の私には役に立った。SQLは割とノリで書けるところはあるが、GROUP BYなんかは知らないと書けない。&lt;/p&gt;

&lt;h1 id=&#34;42-sqlアンチパターン:390eeec2ebe741f3494b487839fdedf9&#34;&gt;42. SQLアンチパターン&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873115892&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;こういう本は中々ない。いわゆる勘所みたいなのを書いてある。
ちゃんと、アンチパターンを挙げるだけでなくじゃあ代わりにどうしたら上手く解決出来るのか、とかアンチパターンとは言ったがこういう場合は使っていいだとか建設的な議論がされている。
ここで挙げられているアンチパターンには実際に問題が明みになるまでアンチパターンと気付けないようなものも少なくなく、この本で予習するかしないかで生死が分かれる。
テーブル設計のミスは中々に致命的である。&lt;/p&gt;

&lt;h1 id=&#34;43-理論から学ぶデータベース実践入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;43. 理論から学ぶデータベース実践入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4774171972&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;アンチパターンは超絶実践的な話だったがこちらは理論の話。リレーション代数や正規形の話、インデックスのアルゴリズムなど。第4正規形だとか関数従属性だとかが分からないならこの本を読むといい。&lt;/p&gt;

&lt;p&gt;型がある人がやるから型破りとはいう実用上正規形を崩すにせよがまずはこの本で理論的に綺麗なテーブル設計を知ると良いと思う。&lt;/p&gt;

&lt;h1 id=&#34;44-redis入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;44. Redis入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4048917358&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Redisの機能を使いつつアプリケーションをいくつか作っていく。最初読んだ時に割と「そこまでRedisでやるのか」と思った。
入門とはいいつつもシャーディングやLuaによるスクリプティングなども取り扱っており、中々読み応えがある。&lt;/p&gt;

&lt;h1 id=&#34;45-7つのデータベース-7つの世界:390eeec2ebe741f3494b487839fdedf9&#34;&gt;45. 7つのデータベース 7つの世界&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4274069087&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;先に7つの言語 7つの世界を挙げたがこの本も良書だ。むしろ私はこちらの方が好きだ。&lt;/p&gt;

&lt;p&gt;PostgreSQL、 Riak、 Redis、 HBase、 MongoDB、 CouchDB、 Neo4j。思うに、プログラミング言語に比べてデータベースは重くて気軽には試せない。
それを考えると7つというのは非常に大きな数字だ。色々なデータベースを知って適材適所使おうと思うならこの本こそ最適だ。&lt;/p&gt;

&lt;h1 id=&#34;46-適応的分散アルゴリズム:390eeec2ebe741f3494b487839fdedf9&#34;&gt;46. 適応的分散アルゴリズム&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4320122518&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;この本は昔図書館で借りて読んだ。なんとなく名前だけに惹かれて借りた。そして退屈だなと思いつつ読み終わって返した。
しかしそれから幾許か。分散データベースやアクターモデルなんかが頻繁に出てくるようになってよくこの本を思い出す。&lt;/p&gt;

&lt;p&gt;ノードとノードの間にどれだけ遅延があるかも分からないメッセージが届かないかもしれないノードが故障しているかもしれない、あるいは間違った情報を送ってくるかもしれない。
そんな中で合意形成したりリーダを選出したりマルチリードマルチライトなメモリを作ったりと面白いことを議論してある。&lt;/p&gt;

&lt;p&gt;次本屋で見付けたら絶対書いたい。そんな本。&lt;/p&gt;

&lt;h1 id=&#34;47-parallel-and-concurrent-programming-in-haskell:390eeec2ebe741f3494b487839fdedf9&#34;&gt;47. Parallel and Concurrent Programming in Haskell&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B00DWJ1BIG&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Hey Hey Haskell本(?)。和訳も出ている。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4873116899&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&#34;http://community.haskell.org/~simonmar/pcph/&#34;&gt;オンラインで読める&lt;/a&gt;のでそれで読んだ。
内容がHaskellと密結合しているのでなんとなくでもHaskellを読めないとこの本も読めない。&lt;/p&gt;

&lt;p&gt;個々のプログラミング言語の機能の1つとして並列/並行のAPIについて述べられていることはあるがここまで様々に扱っているのは見たことがない。
よく「これ以上詳しく書こうとすると本が一冊書けてしまう」と流される部分を実際に本一冊書いてしまったような内容。&lt;/p&gt;

&lt;p&gt;並列/並行プログラミングに興味があるならHaskellを読めるようになってこの本を読むと良いと思う。&lt;/p&gt;

&lt;h1 id=&#34;48-reactive-messaging-patterns-with-the-actor-model:390eeec2ebe741f3494b487839fdedf9&#34;&gt;48. Reactive Messaging Patterns with the Actor Model&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B011S8YC5G&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;デザインパターンのアクター版。Akkaを題材に扱っている。
これこそ「人類が既に解決している問題」であり、Akkaを使うにあたって読むといいと思う。
Akkaに固有の話もあるが大部分はBeamVMを始めとした他のアクターシステムにも共通する内容になる。&lt;/p&gt;

&lt;p&gt;Akkaを使う各社で読書会が開かれてその内和訳が出るところまで見えた。&lt;/p&gt;

&lt;h1 id=&#34;49-unicode標準入門:390eeec2ebe741f3494b487839fdedf9&#34;&gt;49. Unicode標準入門&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4798100307&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;自分の作ったLispでマルチバイト文字を扱おうと思うとUnicodeについては避けて通れない。
バイト列とエンコーディングとコードポイントと文字集合と文字とグリフとフォントと、これらの違いと関係について分かってないのならUnicodeについて勉強した方がいい。
ただでさえ複雑なUnicodeなのに基本の概念が分かってないのなら話にならない。&lt;/p&gt;

&lt;p&gt;扱っているのがUnicode3.0とやや古いものの基本的な部分は変わらない。というか、最近のUnicodeのバージョンアップは文字集合が拡大されているだけと思ってるんだけど合ってるかな？&lt;/p&gt;

&lt;h1 id=&#34;50-セキュリティコンテストチャレンジブック:390eeec2ebe741f3494b487839fdedf9&#34;&gt;50. セキュリティコンテストチャレンジブック&lt;/h1&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=httpkeensgith-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4839956480&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;セキュリティコンテストに興味がなくてもこの本は役に立つ。
プログラマなら「こういうコードを書くと脆弱性になる」とは知っていても実際にどういう攻撃が可能なのか知っている人はそんなにいないのではないか。
この本を読めば少しは分かるようになる。話題もバイナリ解析からネットワーク、Web、SQLと色々ある。&lt;/p&gt;

&lt;p&gt;ところで今目次をみたら酷い誤植があった。やたらバイナリ解析したいらしい。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;おわりに:390eeec2ebe741f3494b487839fdedf9&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;お気に入りの本を挙げていったら50冊近くあったのでキリ良く50冊にした。
思ったよりも50冊は多くて、日曜日の半分が潰れたが色々吐き出せてよかった。&lt;/p&gt;

&lt;p&gt;みんなアフィ踏んでね！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>プログラミングを独学する時こそインプットを増やした方がいい</title>
      <link>/blog/2016/01/17/puroguraminguwodokugakusurutokikosoinputtowofuyashitahougaii</link>
      <pubDate>Sun, 17 Jan 2016 13:38:03 +0900</pubDate>
      
      <guid>/blog/2016/01/17/puroguraminguwodokugakusurutokikosoinputtowofuyashitahougaii</guid>
      <description>&lt;p&gt;巷でよく「アウトプットを増やせ」というのを聞くが個人的な意見としてインプットを増やした方が良いと思っているのでそれについて書く。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//KeenS.github.io/blog/2014/12/18/du-xue-falsepuroguramingu/&#34;&gt;以前&lt;/a&gt;少し書いたことがあるが、私はプログラミングを独学で学んだ。
その時インプットがメインでほとんどアウトプットをしてこなかった。今でもそれは正解だったと思っている。何故か？
答えは簡単で、「学ぶ」ということは情報を仕入れる、要はインプットのことを指しているからだ。それに独学でない人、つまり情報学科なんかにいる人は死ぬほど勉強している訳でちょろっと勉強したくらいでは到底太刀打ち出来ない。&lt;/p&gt;

&lt;p&gt;全くアウトプットが必要ないかというとそうとも思っていない。アウトプットの瞬間に今まで仕入れた知識が自分に定着するからだ。
インプットとアウトプットどれくらいの比率でやればいいのかというと「インプットが溢れ出した時」にアウトプットすればいいと思っている。&lt;/p&gt;

&lt;p&gt;ただ目だけで追った情報は自分の中ではぼんやりしていて形を成していない。
コードなり文書なりの形にアウトプットする時に同時に自分の中で形を成す。あるいは半知半解の部分が明みになって理解の手向けとなる。
そのぼんやりとしたものが形を成す瞬間が一番成長しているように感じるのでよく「アウトプットを増やせ」と言われるのではと思っている。
しかしそれはぼんやりとした情報が定着しているだけであって知識が増えている訳ではない。アウトプットの時に定着するものは今までのインプットに比例する。インプットがなければアウトプットの時の成長もない。
かといって定着させることなく情報を仕入れ続けると不安になる。あるいは、仕入れた知識を試してみたくなる。そういう時にアウトプットすればいいと思っている。
私はそれを「インプットが溢れた」と呼んでいる。&lt;/p&gt;

&lt;p&gt;もう1つインプットを増やした方が良いと思っているのは大抵の問題は人類は既に解決しているからだ。無理にアウトプットしようと1時間掛けて悩むよりも10分掛けて解決法を学んだ方が手っ取り早い。
プログラミングを独学しようと思うと莫大な時間が必要になる。独学に取れる時間が有限ならば短時間で解決出来る方法を選ぶべきだ。
問題解決能力なんて手札が揃ってから考えればいい。碌な手札も持ってないのにそれで解決しようとするのは無理がある。まずは手札を揃えるべきだ。世の中のプログラマと同じ手札を揃えないとそもそも同じ土俵で戦えない。&lt;/p&gt;

&lt;p&gt;ここで1つ言及しておきたいのが毎日ブログ問題だ。「毎日技術ブログを書き続けろ。つらくてもいいから続けろ。続けた先に見えるものがある。」なんて言われることがある。あれはあまり良くないと思っている。
本当に初学者の時は毎日くらいの頻度でインプットが溢れるかもしれない。しかしその期間は長くは続かない。ちゃんと学んで成長していればインプットのバッファも大きくなる。
すぐに1日の勉強量ではインプットが溢れなくなる。そうなった時にも毎日ブログを書く意味はない。ブログを書くのにも時間が取られるのを忘れてはいけない。ブログを書く達人になりたいのでもなければ時間を使う意味はさしてない。
それよりは平日に進めて土日で仕上げて日曜の夜にそれについてブログを書く、とかの計画的なサイクルを回した方が良い。あるいはもっと長いスパンで。&lt;/p&gt;

&lt;p&gt;1つ、インプットばかりしていると懸念が生じる。それは実用上の問題ではなく自己満足とか成果とかの問題、精神上の問題だ。
何かを学ぶ以上成果が欲しくなる。特に実学なら実用的な成果が欲しくなる。学んではいるものの目に見える成果がないと不安になる。
例えば職のためにプログラミングを始めた人なら切実に成果が欲しいだろう。これについては私は今のところ有効な解決策を見付けていない。
目標のある人はどれだけ目標に近付いているかで測れるかもしれないが私には目標がなかった。
同じくらいの習熟度の人と比べるのが良さそうだが、独学同士相手を見付けるのは中々難しい。同学年の情報科学科の人と比べると正規軍に徒手空拳で挑むようなもので話にならない(そういう経験がある)。
時折たまに溢れ出たアウトプットを眺めてちゃんと前に進んでいるんだと自分に言い聞かせてきた。
不思議と、就職に関してもそれでどうにかなった。目に見える形にはなっていなくても面接などで話すと分かるのだろう。結局、不安は不安のまま抱え続けるしかなかった。独学とはそういうものなのかもしれない。&lt;/p&gt;

&lt;p&gt;私も大学生でプログラミングに目覚めて今丁度丸4年。去年の4月からプログラマとして働いているが未だインプットの足りなさをひしひしと感じる。働きながら勉強を続けるが中々時間がとれない。
時間のある学生の時にもうちょっと効率的にインプットを増やしていたらと思う。そういう後悔をする人を一人でも減らそうと思ってこういう記事を書いてみた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Isabelleに入門した</title>
      <link>/blog/2016/01/12/isabelleninyuumonshita</link>
      <pubDate>Tue, 12 Jan 2016 22:23:45 +0900</pubDate>
      
      <guid>/blog/2016/01/12/isabelleninyuumonshita</guid>
      <description>

&lt;p&gt;κeenです。連休中にIsabelleを少しばかり触ったのでその時のまとめを。&lt;/p&gt;

&lt;h1 id=&#34;isabelleって:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;Isabelleって？&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://isabelle.in.tum.de/&#34;&gt;公式&lt;/a&gt;。定理証明支援系の一つ。SML処理系の1つ、Poly/MLで書かれている。
どうやらHOL(Higher Order Logic)に焦点を当てているようだが詳しいことは分かっていない。&lt;/p&gt;

&lt;p&gt;あと、Linuxが正式にはGNU/LinuxというようにIsabelleもIsabelle/Isar/HOLと言うべきらしいが、まだよく分かっていない。&lt;/p&gt;

&lt;h1 id=&#34;インストール:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;インストール&lt;/h1&gt;

&lt;p&gt;公式サイトからダウンロード出来るが、後述のProofGeneralの関係上Isabelle2014をインストールする。&lt;/p&gt;

&lt;h1 id=&#34;エディタ設定:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;エディタ設定&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ProofGeneral/PG&#34;&gt;ProofGeneral&lt;/a&gt;を使う。恐らくGitHub版を使った方がいい。設定は1行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(load (expand-file-name &amp;quot;/path/to/ProofGeneral/generic/proof-site&amp;quot;) nil t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くだけ。多分&lt;code&gt;prettify-symbol-mode&lt;/code&gt;も自動でonになる。(なってなかったらなんか適当に設定しておこう。global-prettify-symbols-modeとかで。)
Isabelleの古いドキュメントを見てるとX-Symbolsモードなるものが出てくるが、恐らく現在の&lt;code&gt;prettify-symbol-mode&lt;/code&gt;だと思う。&lt;/p&gt;

&lt;h1 id=&#34;はじめる:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;はじめる&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;isabelle.in.tum.de/doc/tutorial.pdf&#34;&gt;この&lt;/a&gt;チュートリアルを進めている。まだ途中。タクティックも&lt;code&gt;tactic_ind&lt;/code&gt;と&lt;code&gt;auto&lt;/code&gt;しか知らない。&lt;/p&gt;

&lt;p&gt;とりあえず拡張子は.thyにしとくとEmacsが認識してくれる。&lt;/p&gt;

&lt;h1 id=&#34;所感:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;所感&lt;/h1&gt;

&lt;p&gt;Coqを触ったことあるとそれなりにスムーズに入れた。ただしダブルクォートはキモい。
Coqも3つくらいの言語が混ってるらしいのでその内のGallinaの部分をクォートで囲っている感じなのだろうか。
クォートの部分はHOLがどうのこうの言ってた気がする。&lt;/p&gt;

&lt;p&gt;まだどんなことが出来るのか分からないのでCoqの方がマシじゃんという感想しかない。&lt;/p&gt;

&lt;h1 id=&#34;困ったところ:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;困ったところ&lt;/h1&gt;

&lt;p&gt;チュートリアル中に数学記号が出てくる。∀とか∃とか¬とか。断りもなしにソースコード中にも。
最初、組版の都合上置き換えたのだろうとCoqのようにforall, exists, notと打っていたがエラーになった。じゃあ、とユニコードで打ってみてもエラーになった。
結局、TeXのようにコマンドを入力するとWYSIWYGのようにシンボルになるらしい。
さらにややこしいことにEmacsに特定のシーケンスでキーを入力するとそのコマンドを挿入してくれる機能がついている。&lt;/p&gt;

&lt;p&gt;とりあえず今のところ分かっているものをまとめる&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;見た目&lt;/th&gt;
&lt;th&gt;Emacsでの入力&lt;/th&gt;
&lt;th&gt;実際のタグ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;∀&lt;/td&gt;
&lt;td&gt;\forall&lt;/td&gt;
&lt;td&gt;&amp;lt;forall&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;∃&lt;/td&gt;
&lt;td&gt;\exists&lt;/td&gt;
&lt;td&gt;&amp;lt;exists&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;¬&lt;/td&gt;
&lt;td&gt;\not&lt;/td&gt;
&lt;td&gt;&amp;lt;not&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;∧&lt;/td&gt;
&lt;td&gt;\and, /&lt;/td&gt;
&lt;td&gt;&amp;lt;and&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;∨&lt;/td&gt;
&lt;td&gt;\or, \/&lt;/td&gt;
&lt;td&gt;&amp;lt;or&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;⇒&lt;/td&gt;
&lt;td&gt;\Rightarrow, =&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;Rightarrow&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;→&lt;/td&gt;
&lt;td&gt;\rightarrow, -&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;rightarrow&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;≡&lt;/td&gt;
&lt;td&gt;\equiv, ==&lt;/td&gt;
&lt;td&gt;&amp;lt;equiv&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;≠&lt;/td&gt;
&lt;td&gt;\noteq, ~=&lt;/td&gt;
&lt;td&gt;&amp;lt;noteq&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;なんかそれっぽい記号を連ねてみたら色々出てきた。けどユニコード入力出来ないから載せれないw。&lt;/p&gt;

&lt;p&gt;逆引きしたい。見た目からコマンドを知りたい。&lt;/p&gt;

&lt;p&gt;なんかまとまりないけどそんな所で。頭痛い。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>