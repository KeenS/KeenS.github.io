<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/post/</link>
    <description>Recent content in Posts on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 29 May 2015 20:26:41 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>第一級ラベルを持たない言語におけるDirect Threaded VMの実装</title>
      <link>http://keens.github.io/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou</link>
      <pubDate>Fri, 29 May 2015 20:26:41 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou</guid>
      <description>

&lt;p&gt;こんにちは。κeenです。このブログでちょくちょく出てくるDirect Threaded VMについて。
SMLのようにgotoがない言語だとDT VMの実装出来ないよなー、と思ってた所、ふとアイディアが浮かんだのでそれについて。&lt;/p&gt;

&lt;h1 id=&#34;序論:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;序論&lt;/h1&gt;

&lt;p&gt;DSL、例えば正規表現などの処理系を実装することを考えてみて下さい。&lt;/p&gt;

&lt;p&gt;言語処理系において最も素朴な実装はインタプリタですが、速度面で不利なので一旦仮想命令にコンパイルして仮想命令実行器(VM)で実行することが一般的です。
コンパイラのように複雑な記号処理をするプログラムはCommon LispやMLのような記号処理に強い高級言語が得意とする分野です。
一方、ランタイムには低レベルなことが出来て処理速度の速いCommon LispやCを使いたくなるでしょう。&lt;/p&gt;

&lt;p&gt;Common Lisp以外の言語ではコンパイラとランタイムを分離するのが妥当な選択肢のようですが、高級言語とcの間のブッジングが必要になり、少なからぬコストを支払う必要があります。
また、ffiを持たない言語ではブリッジ出来ないのでランタイムもその言語で実装する必要があります。つまり、高級言語でVMを実装する必要があるケースが存在します。&lt;/p&gt;

&lt;p&gt;VMの実行を高速化する技術の一つとしてDirect Threadingというものがあります。
命令ディスパッチのループを短絡することで余計なオーバーヘッドが減り、また、命令毎にジャンプ命令を持つことで分岐予測も効きやすくなるのでVMが高速化します。
しかしDTの実装にはgotoのラベルを第一級オブジェクトとして保存する必要があり、gccやclangのように拡張されたcコンパイラなど、限られた言語でしか実現出来ません。まあ、Common Lispなら&lt;code&gt;eval&lt;/code&gt;と&lt;code&gt;compile&lt;/code&gt;を使えばJITが出来るので不要ですが。&lt;/p&gt;

&lt;p&gt;そこで、gotoのない言語でDirect Threadingを実現してみたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;direct-threading:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;Direct Threading&lt;/h1&gt;

&lt;p&gt;Direct Threaded &lt;em&gt;でない&lt;/em&gt; VMは大抵次のような構造をしています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loop {
  op = fetchNextOp
  switch(op) {
    case op1:
     ....
     break
    case op2:
     ....
     break
    ....
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;次の命令を取得する&lt;/li&gt;
&lt;li&gt;命令でディスパッチする&lt;/li&gt;
&lt;li&gt;命令に対応するコードを実行する&lt;/li&gt;
&lt;li&gt;ディスパッチを抜ける&lt;/li&gt;
&lt;li&gt;1.に戻る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という動きをします。自然に思えるかもしれませんが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;命令のディスパッチはlogオーダの時間が掛かる（可能性がある）。&lt;/li&gt;
&lt;li&gt;4. 5. のステップが不要&lt;/li&gt;
&lt;li&gt;2. で毎回違う命令にディスパッチするので分岐予測がほぼ意味を成さない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という無駄があります。それを改良したのがDirect Threaded VMで、オペコードではなくgotoのラベルを使うことで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;label = fetchNextLabel
goto label
label1:
  ...
  label = fetchNextLabel
  goto label
label2:
  ...
  label = fetchNextLabel
  goto label
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;次のラベルを取得する&lt;/li&gt;
&lt;li&gt;ラベルにgotoする&lt;/li&gt;
&lt;li&gt;命令に対応するコードを実行する&lt;/li&gt;
&lt;li&gt;次のラベルを取得する&lt;/li&gt;
&lt;li&gt;ラベルにgotoする(次の処理は3. 相当)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;と、ループ内の2ステップを飛ばした他、ディスパッチもなくなるので高速になります。
また、ラベル毎にgotoがついていて、それぞれのgotoに分岐予測があるので普通のVMに比べて分岐予測がある程度効きます。&lt;/p&gt;

&lt;h1 id=&#34;第一級ラベルを持たない言語におけるdirect-threaded-vm:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;第一級ラベルを持たない言語におけるDirect Threaded VM&lt;/h1&gt;

&lt;p&gt;結論から言うと関数の配列を使います。ラベルの代わりに配列のインデックス、gotoの代わりに配列へのアクセスとcallを使います。
ランダムアクセスでアドレスの取得をするために配列を、任意コードへのジャンプのために関数を使えばエミュレート出来るよねって発想です。&lt;/p&gt;

&lt;h1 id=&#34;実装:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;実装&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/SML-VM&#34;&gt;ソースコード全体&lt;/a&gt;はGithuに上げてます。SML/NJで動きます。SML#向けのインターフェースファイルを書いていますが何故かコンパイルが通りません。&lt;/p&gt;

&lt;p&gt;次のようなASTを実行するインタプリタ、VM、Direct Threaded VMを実装しました。但し、VMとDTVMはクロージャをサポートしていません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype monoop
  = Not

datatype binop
  = Equal
  | GreaterThan
  | Add

datatype t
  = Int of int
  | Bool of bool
  | MonoOp of monoop * t
  | BinOp of binop * t * t
  | Bind of t * t
  | If of t * t * t
  | Var of string
  | Lambda of t list * t
  | Call of t * t list
  | Progn of t list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インタプリタはこのASTを解釈実行、VMはいくつかの中間表現を経てオペコードにコンパイルし、それを実行します。尚、最適化は行いません。&lt;/p&gt;

&lt;p&gt;VMのディスパッチ部分は次のような実装になっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;    fun aux () = (
        case  (Array.sub(ops, !pc)) of
            O.Not =&amp;gt; (case pop vm of
                         V.Bool x =&amp;gt; push vm (V.Bool (not x))
                       | _ =&amp;gt; raise Type)
          | O.Add =&amp;gt; (case (pop vm, pop vm) of
                         (V.Int x, V.Int y) =&amp;gt; push vm (V.Int (x + y))
                       | _ =&amp;gt; raise Type)
          | O.Eq =&amp;gt; (case (pop vm, pop vm) of
                        (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x = y))
                      | (V.Bool x, V.Bool y) =&amp;gt; push vm (V.Bool (x = y))
                      | _ =&amp;gt; raise Type)
          | O.Gt =&amp;gt; (case (pop vm, pop vm) of
                        (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x &amp;lt; y))
                      | _ =&amp;gt; raise Type)
          | O.Jump label =&amp;gt; pc := (label - 1)
          | O.Jtrue label =&amp;gt; (case pop vm of
                                 V.Bool true =&amp;gt; pc := (label - 1)
                               | V.Bool false =&amp;gt; ()
                               | _ =&amp;gt; raise Type)
          | O.Call i =&amp;gt; (case (pop vm) of
                            V.Lambda label =&amp;gt; (
                             pushCi vm;
                             fp := (!fp) - i;
                             pc := (label - 1))
                          | _ =&amp;gt; raise Type)
          | O.Ret =&amp;gt; (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1));
                     popCi vm;
                     pc := (!pc))
          | O.Push v =&amp;gt; push vm v
          | O.Pop =&amp;gt; (pop vm;())
          | O.Lref i =&amp;gt; push vm (Array.sub(stack, (!fp) + i))
          | O.Lset i =&amp;gt;  ((Array.update(stack, (!fp) + i, pop vm));
                         push vm (V.Bool true))
          | O.Gref i =&amp;gt; push vm (Array.sub(pool, i))
          | O.Gset i =&amp;gt;  (Array.update(pool, i, pop vm); push vm (V.Bool true))
          | O.Nop =&amp;gt; ()
          | O.End =&amp;gt; raise Exit
      ;
        pc := (!pc) + 1;
      aux ())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DT VMではこれを次のように書き換えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun next () = let
    val () = pc := (!pc) + 1;
    val (index, arg) = Array.sub(cops, !pc) in
    Array.sub(opArray, index) arg
end

Array.fromList [
            (* Not *)
            fn _ =&amp;gt;
                (case pop vm of
                    V.Bool x =&amp;gt; push vm (V.Bool (not x))
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Add *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Int (x + y))
                  | _ =&amp;gt; raise Type;
                 next ()),
            (* Eq *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x = y))
                  | (V.Bool x, V.Bool y) =&amp;gt; push vm (V.Bool (x = y))
                  | _ =&amp;gt; raise Type;
                  next ()),
            (* Gt *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x &amp;lt; y))
                  | _ =&amp;gt; raise Type;
                 next ()),
            (* Jump *)
            fn ({int = label, ...}: oparg) =&amp;gt;
               (pc := (label - 1);
               next ()),
            (* Jtrue *)
            fn ({int = label, ...}: oparg) =&amp;gt;
                (case pop vm of
                    V.Bool true =&amp;gt; pc := (label - 1)
                  | V.Bool false =&amp;gt; ()
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Call *)
            fn ({int = i, ...}: oparg) =&amp;gt;
                (case (pop vm) of
                    V.Lambda label =&amp;gt; (
                     pushCi vm;
                     fp := (!fp) - i;
                     pc := (label - 1))
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Ret *)
            fn _ =&amp;gt;
                (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1));
                 popCi vm;
                 pc := (!pc);
                next ()),
            (* Push *)
            fn ({vmvalue = v, ...}: oparg) =&amp;gt;
               (push vm v;
               next ()),
            (* Pop *)
            fn _ =&amp;gt;
               (pop vm;
                next ()),
            (* Lref *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (push vm (Array.sub(stack, (!fp) + i));
               next ()),
            (* Lset *)
            fn ({int = i, ...}: oparg) =&amp;gt;
                ((Array.update(stack, (!fp) + i, pop vm));
                 push vm (V.Bool true);
                next ()),
            (* Gref *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (push vm (Array.sub(pool, i));
               next ()),
            (* Gset *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (Array.update(pool, i, pop vm);
                push vm (V.Bool true);
               next ()),
            (* Nop *)
            (fn _ =&amp;gt;
                next ()),
            (fn _ =&amp;gt;
                raise Exit)
        ]

fun aux () = let val (index, arg) = Array.sub(cops, !pc) in
                 Array.sub(opArray, index) arg
             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1引数を受け取ってunitを返す関数の配列としてVMを表しています。
1つ注意点として、前処理としてタグ付き共用体として表されている命令をタグ(配列のインデックス)と共用体に分解するのですが、SMLに共用体はないので構造体で代用しています。 &lt;code&gt;oparg&lt;/code&gt; 型がそれにあたります。&lt;/p&gt;

&lt;p&gt;ディスパッチを関数&lt;code&gt;next&lt;/code&gt;に括り出していて、一見すると分岐予測に関する利点が失われるように思われますが、
&lt;code&gt;next&lt;/code&gt;は小さいのでインライン化されるだろうと踏んでそのままにしています。実際、手動でインライン化しても速度に変化はありませんでした。&lt;/p&gt;

&lt;p&gt;今回のメインの話はVMなのでインタプリタについては省略します。&lt;/p&gt;

&lt;h1 id=&#34;実行速度:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;実行速度&lt;/h1&gt;

&lt;h2 id=&#34;予測:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;予測&lt;/h2&gt;

&lt;p&gt;普通のVMはディスパッチをlogオーダーの時間で行ないますがDT VMは定数オーダーの時間で行ないます。しかし配列の参照と関数呼び出しを挟むので定数倍の部分は大きくなります。
どちらが速いでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;計測:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;計測&lt;/h2&gt;

&lt;p&gt;今回、次のようなフィボナッチ数列を計算するコードの実行速度を計測しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun fib n = (Progn [
                Bind (Var &amp;quot;fib&amp;quot;,
                      Lambda([Var &amp;quot;n&amp;quot;],
                               (If (BinOp(GreaterThan,
                                          (Int 2),
                                          (Var &amp;quot;n&amp;quot;)),
                                    Int(1),
                                    BinOp(Add,
                                          Call(Var &amp;quot;fib&amp;quot;, [BinOp(Add,
                                                                 Var &amp;quot;n&amp;quot;,
                                                                 Int ~1)]),
                                          Call(Var &amp;quot;fib&amp;quot;, [BinOp(Add,
                                                                 Var &amp;quot;n&amp;quot;,
                                                                 Int ~2)])))))),
                Call(Var &amp;quot;fib&amp;quot;, [Int n])])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンパイラは以下のような命令列を吐きます。命令の内部表現が違うだけで命令列自体はVMとDTVMで共通です。
繰り返しますが、最適化はしてないのでL25で次の命令にジャンプしてるだとか目に見えて無駄なコードもあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0	Push Lambda 7
1	Gset 0
2	Pop
3	Push 35
4	Gref 0
5	Call 1
6	End
7	Push 2
8	Lref 0
9	Gt
10	Jtrue 12
11	Jump 14
12	Push 1
13	Jump 26
14	Lref 0
15	Push ~1
16	Add
17	Gref 0
18	Call 1
19	Lref 0
20	Push ~2
21	Add
22	Gref 0
23	Call 1
24	Add
25	Jump 26
26	Ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;計測には次のようなコードを使いました。コンパイラは実行効率を無視して書いたのでベンチマークには含めていません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val target = (AST.fib 35)
val compiled = VM.compile target
val dtcompiled = DTVM.compile target
val vm = VM.new ()
val dtvm = DTVM.new ()

val _ = Benchmark.benchset &amp;quot;fib 35&amp;quot; 1 [
        (&amp;quot;Interpreter&amp;quot;,
         fn () =&amp;gt; (Interp.run target; ())),
        (&amp;quot;Normal VM&amp;quot;,
         fn () =&amp;gt; (VM.run vm compiled; ())),
        (&amp;quot;Direct Threaded VM&amp;quot;,
         fn () =&amp;gt; (DTVM.run dtvm dtcompiled; ()))
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;結果:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;Intel Core i5 M450 2.4GHz 2コア4スレッド、Ubunt 15.04、SML/NJ v110.77で実行しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-------------------+---------------------------------------------------
 Interpreter       |********************************************* 47170ms
 Normal VM         |****************** 19170ms
 Direct Threaded VM|************************************************** 51460ms
-------------------+---------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ダントツで速いのがVMで、インタプリタに比べてかなりの性能向上が見られます。一方DT VMはインタプリタより遅いという結果になりました。&lt;/p&gt;

&lt;h1 id=&#34;考察:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;考察&lt;/h1&gt;

&lt;p&gt;冷静に考えたらインタプリタは毎回関数呼び出して遅いよねってことからループで処理を済ませるのがVMなのにVMで毎回関数を呼び出してたら遅いに決まってるじゃん。
というかこれ、Direct Threaded VMじゃないじゃん。死にたい。&lt;/p&gt;

&lt;h1 id=&#34;余談:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;余談&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/604235677337714689&#34;&gt;2015, 5月 29&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;尚、このつぶやきはfibの引数を小さくして繰り返しを増やした時のものです。多分コンパイルを外に出してるので繰り返しが多いとその分のオーバーヘッドの差が効いてくるのでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val target = (AST.fib 24)
val compiled = VM.compile target
val dtcompiled = DTVM.compile target
val vm = VM.new ()
val dtvm = DTVM.new ()

val _ = Benchmark.benchset &amp;quot;fib 24&amp;quot; 10 [
        (&amp;quot;Interpreter&amp;quot;,
         fn () =&amp;gt; (Interp.run target; ())),
        (&amp;quot;Normal VM&amp;quot;,
         fn () =&amp;gt; (VM.run vm compiled; ())),
        (&amp;quot;Direct Threaded VM&amp;quot;,
         fn () =&amp;gt; (DTVM.run dtvm dtcompiled; ()))
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-------------------+---------------------------------------------------
 Interpreter       |************************************************** 2052ms
 Normal VM         |** 104ms
 Direct Threaded VM|***** 238ms
-------------------+---------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Onigmoを最大49%高速化した話</title>
      <link>http://keens.github.io/blog/2015/05/26/onigmowosaidai49_kousokukashitahanashi</link>
      <pubDate>Tue, 26 May 2015 01:14:54 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/26/onigmowosaidai49_kousokukashitahanashi</guid>
      <description>&lt;p&gt;κeenです。Rubyでも使われてる高速な正規表現エンジン、Onigmo(鬼雲)を高速化したのでその話を。&lt;/p&gt;

&lt;p&gt;先日、&lt;a href=&#34;http://keens.github.io/blog/2015/05/10/seikihyougengijutsunyuumonwoyonda/&#34;&gt;正規表現技術入門を読んだ&lt;/a&gt;というエントリの中で&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ところで本に載ってた鬼雲のコードはDT(編注: Direct Threaded)にしてなかったけど簡単のためなのかな？あるいは厳格にC89に準拠するため？picrinみたくプリプロセッサで分岐すれば使えるのに。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と書いたところ、鬼雲の作者、K.Takataさんから&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/k_takata&#34;&gt;@k_takata&lt;/a&gt; 「picrinみたくプリプロセッサで分岐すれば使えるのに。」これも知らなかった。&lt;/p&gt;&amp;mdash; K.Takata (@k_takata) &lt;a href=&#34;https://twitter.com/k_takata/status/597690447499108352&#34;&gt;2015, 5月 11&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;という反応を頂きました。そして&lt;a href=&#34;https://github.com/k-takata/Onigmo/issues/51&#34;&gt;イシュー&lt;/a&gt;にも乗ったので言い出しっぺとして実装してみました。&lt;a href=&#34;https://github.com/k-takata/Onigmo/pull/52&#34;&gt;こちらのプルリク&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;Direct Threaded VM自体の解説はRubyist Magazineに載っている笹田さんのものが詳しいようです &lt;a href=&#34;http://magazine.rubyist.net/?0008-YarvManiacs&#34;&gt;Rubyist Magazine - YARV Maniacs 【第 3 回】 命令ディスパッチの高速化&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;実装は少し技巧的ですが&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;などをマクロでラップしつつDT VMが有効ならそれらと互換性のあるDT用のコード（&lt;code&gt;goto&lt;/code&gt;やラベル）に展開します。元は&lt;a href=&#34;https://github.com/picrin-scheme/picrin/blob/master/extlib/benz/vm.c#L583&#34;&gt;picrin&lt;/a&gt;で使われていたテクニックです。
このコードは &lt;a href=&#34;https://twitter.com/wasabiz&#34;&gt;@wasabiz&lt;/a&gt;が書いたものなのでpicrinがどこを参考にして書かれたかは@wasabizに聞いて下さい。もしかしたらわさびずの発明かもしれませんね。&lt;/p&gt;

&lt;p&gt;で、パフォーマンスの方ですが、最初、素直に制御命令を1つづつマクロで書き換えたのですが、こうなりました。&lt;/p&gt;

&lt;p&gt;master&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;パターン&lt;/td&gt;&lt;td&gt;時間&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Twain&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;47 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^Twain&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;47 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Twain$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;47 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Huck[a-zA-Z]+|Finn[a-zA-Z]+&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;127 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;a[^x]{20}b&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1172 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Tom|Sawyer|Huckleberry|Finn&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;151 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;.{0,3}(Tom|Sawyer|Huckleberry|Finn)&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;497 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;[a-zA-Z]+ing&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;4032 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^[a-zA-Z]{0,4}ing[^a-zA-Z]&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;96 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;[a-zA-Z]+ing$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;4175 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^[a-zA-Z ]{5,}$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1770 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^.{16,20}$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1757 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;([a-f](.[d-m].){0,2}[h-n]){2}&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1849 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;([A-Za-z]awyer|[A-Za-z]inn)[^a-zA-Z]&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;656 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;&#34;[^&#34;]{0,30}[?!\.]&#34;&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;115 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Tom.{10,25}river|river.{10,25}Tom&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;260 ms&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;DT版&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;パターン&lt;/td&gt;&lt;td&gt;時間&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Twain&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;100 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^Twain&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;99 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Twain$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;100 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Huck[a-zA-Z]+|Finn[a-zA-Z]+&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;246 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;a[^x]{20}b&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;2182 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Tom|Sawyer|Huckleberry|Finn&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;288 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;.{0,3}(Tom|Sawyer|Huckleberry|Finn)&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;847 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;[a-zA-Z]+ing&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;6278 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^[a-zA-Z]{0,4}ing[^a-zA-Z]&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;203 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;[a-zA-Z]+ing$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;6430 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^[a-zA-Z ]{5,}$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;3603 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^.{16,20}$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;3596 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;([a-f](.[d-m].){0,2}[h-n]){2}&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;3239 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;([A-Za-z]awyer|[A-Za-z]inn)[^a-zA-Z]&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1039 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;&#34;[^&#34;]{0,30}[?!\.]&#34;&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;327 ms&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Tom.{10,25}river|river.{10,25}Tom&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;487 ms&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;はい。DT版の方が2倍ちょっと遅いです。そりゃないわー。最適化オプションとかも確認したのですがダメでした。&lt;/p&gt;

&lt;p&gt;諦めて布団に入った後、ふと思い当たる節がありました。&lt;/p&gt;

&lt;p&gt;元のコードで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;case OP_XXX:
   ...
   continue;
   break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というパターンが割と現れます。&lt;code&gt;continue&lt;/code&gt;の後の&lt;code&gt;break&lt;/code&gt;は本来なら不要ですが&lt;code&gt;case&lt;/code&gt;を書く際の作法というか癖というか
とにかく&lt;code&gt;break&lt;/code&gt;を付けるスタイルもあります。これもそうなのでしょう。こいつらをマクロで書き換える時に愚直に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;CASE(OP_XXX)
   ...
   JUMP;
   NEXT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてました。ここで、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#if USE_DIRECT_THREADED_VM
#define NEXT sprev = sbegin; JUMP
#define JUMP goto *oplabels[*p++]
#else
#define NEXT break
#define JUMP continue
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。これはUSE_DIRECT_THREADED_VMが定義されてる時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;L_OP_XXX:
   ...
   goto *oplabels[*p++];
   sprev = sbegin;goto *oplabels[*p++];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と展開され、&lt;code&gt;goto&lt;/code&gt;が2つ現れることになります。どうせ無用コードだし最適化で消えるだろと思ってたらそうでもないらしく、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;CASE(OP_XXX)
   ...
   JUMP;
   NEXT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;CASE(OP_XXX)
   ...
   JUMP;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;にし、マクロの方も&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#if USE_DIRECT_THREADED_VM
#define NEXT sprev = sbegin; JUMP
#define JUMP goto *oplabels[*p++]
#else
#define NEXT break
#define JUMP continue; break
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたらようやく本領発揮してくれました。その結果がこれです。&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Master&lt;/td&gt;&lt;td&gt;This PR&lt;/td&gt;&lt;td&gt;Improve Rate&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Twain&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;47 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;47 ms&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^Twain&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;47 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;47 ms&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Twain$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;47 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;47 ms&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Huck[a-zA-Z]+|Finn[a-zA-Z]+&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;127 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;127 ms&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;a[^x]{20}b&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1172 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;889 ms&lt;/td&gt;&lt;td&gt;31%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Tom|Sawyer|Huckleberry|Finn&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;151 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;153 ms&lt;/td&gt;&lt;td&gt;-1%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;.{0,3}(Tom|Sawyer|Huckleberry|Finn)&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;497 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;449 ms&lt;/td&gt;&lt;td&gt;10%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;[a-zA-Z]+ing&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;4032 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;2705 ms&lt;/td&gt;&lt;td&gt;49%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^[a-zA-Z]{0,4}ing[^a-zA-Z]&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;96 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;98 ms&lt;/td&gt;&lt;td&gt;-2%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;[a-zA-Z]+ing$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;4175 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;2797 ms&lt;/td&gt;&lt;td&gt;49%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^[a-zA-Z ]{5,}$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1770 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1623 ms&lt;/td&gt;&lt;td&gt;9%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;^.{16,20}$&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1757 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1637 ms&lt;/td&gt;&lt;td&gt;7%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;([a-f](.[d-m].){0,2}[h-n]){2}&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1849 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;1670 ms&lt;/td&gt;&lt;td&gt;11%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;([A-Za-z]awyer|[A-Za-z]inn)[^a-zA-Z]&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;656 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;607 ms&lt;/td&gt;&lt;td&gt;8%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;&#34;[^&#34;]{0,30}[?!\.]&#34;&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;115 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;93 ms&lt;/td&gt;&lt;td&gt;24%&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&#34;pattern&#34;&gt;Tom.{10,25}river|river.{10,25}Tom&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;260 ms&lt;/td&gt;&lt;td class=&#34;time&#34;&gt;262 ms&lt;/td&gt;&lt;td&gt;-1%&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;a[^x]{20}b&lt;/code&gt;や&lt;code&gt;[a-zA-Z]+ing&lt;/code&gt;のようにバックトラックが何度も起きてVMループをヘビーに回すパターンでは効果覿面のようで、最大49%の高速化です。素晴しいですね。&lt;/p&gt;

&lt;p&gt;因みに2つめの&lt;code&gt;goto&lt;/code&gt;は実際には実行されないのに何故遅くなったかというとgotoはコンパイラにとってはコントロールフログラフを乱す厄介な奴なので
無用コード除去に引っ掛からなかったどころか最適化ルーチンを引っ掻き回したんじゃないかと思います。&lt;/p&gt;

&lt;p&gt;このコード、私の手元の環境でしかテストしてないのでC89なら須くサポートするOnigmoにマージされるかは分かりませんがマージされると嬉しいですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>幽霊型を知った</title>
      <link>http://keens.github.io/blog/2015/05/24/yuureikatawoshitta</link>
      <pubDate>Sun, 24 May 2015 22:38:47 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/24/yuureikatawoshitta</guid>
      <description>

&lt;p&gt;κeenです。かねてより気になっていた幽霊型(Phantom Type)について知ったのでアウトプット。
&lt;a href=&#34;http://www.cs.rit.edu/~mtf/research/phantom-subtyping/jfp06/jfp06.pdf&#34;&gt;このPDF&lt;/a&gt;がベースになって
ます。&lt;/p&gt;

&lt;p&gt;余談ですが英語がファントム・タイプと中々中二な名前なので和訳も幻影型とかそういう方向に走って欲かったな。&lt;/p&gt;

&lt;p&gt;「幽霊型」で調べると真っ先に&lt;a href=&#34;https://kagamilove0707.github.io/programming/2014/02/20/about-phantom-type/&#34;&gt;このサイト&lt;/a&gt;が出てくるのですが、ミスリーディングと言われていました。
別に間違ったことを書いている訳ではないのですが、幽霊型の応用例なのでこれこそが幽霊型だと思ってしまうと少し視野が狭くなってしまうようです。&lt;/p&gt;

&lt;h1 id=&#34;モチベーション:b3b6b3048912aac849c4ef033d362a0c&#34;&gt;モチベーション&lt;/h1&gt;

&lt;p&gt;ブーリアンと整数と条件分岐と足し算と比較が出来るミニ言語を考えてみます。自動で型変換は行わない(つまりintとboolの比較などは出来ない)言語とします。こんな感じでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype exp
  = Int of int
  | Bool of bool
  | If of exp * exp * exp
  | Plus of exp * exp
  | Equal of exp * exp

fun mkInt x = Int x
fun mkBool x = Bool x
fun mkIf cnd thn els = If(cnd, thn, els)
fun mkPlus x y = Plus(x, y)
fun mkEqual x y = Equal(x, y)

exception Type

fun evalIf cnd thn els =
  case eval cnd of
      Bool x =&amp;gt; if x then eval thn else eval els
    | _ =&amp;gt; raise Type

fun evalPlus x y =
  case (eval x, eval y) of
      (Int x&#39;, Int y&#39;) =&amp;gt; Int(x&#39; + y&#39;)
    | _  =&amp;gt; raise Type

fun evalEqual x y =
  case (eval x, eval y) of
      (Int x&#39;, Int y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
    | (Bool x&#39;, Bool y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
    | _  =&amp;gt; raise Type

fun eval exp =
  case exp of
      If(cnd, thn, els) =&amp;gt; evalIf cnd thn els
    | Plus(x, y) =&amp;gt; evalPlus x y
    | Equal(x, y) =&amp;gt; evalEqual x y
    | e =&amp;gt; e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この定義に従うと次のような自明に間違ったプログラムもコンパイルを通ってしまいます&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:b3b6b3048912aac849c4ef033d362a0c:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:b3b6b3048912aac849c4ef033d362a0c:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;mkEqual (mkInt 1) (mkBool false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;勿論、評価するとエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;eval (mkEqual (mkInt 1) (mkBool false));

uncaught exception Type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こういうものを極力コンパイル時に発見出来ないかとうのがモチベーションです。因みにこのモチベーションは変な型変換を行わない言語なら動的型付き言語でも同じで、SBCLで&lt;code&gt;(+ 1 t)&lt;/code&gt;を評価するとちゃんとコンパイルエラーになります。&lt;/p&gt;

&lt;h1 id=&#34;問題の分析:b3b6b3048912aac849c4ef033d362a0c&#34;&gt;問題の分析&lt;/h1&gt;

&lt;p&gt;今回、&lt;code&gt;Int&lt;/code&gt;だとか&lt;code&gt;Bool&lt;/code&gt;だとかの型情報をタグ、つまり値として持たせました。しかしコンパイル時に値にはアクセス出来ません。コンパイル時にアクセスできるのは型です。ということでメタデータとして型を付与しましょう。&lt;/p&gt;

&lt;h1 id=&#34;幽霊型:b3b6b3048912aac849c4ef033d362a0c&#34;&gt;幽霊型&lt;/h1&gt;

&lt;p&gt;メタデータとして型を付けたのが幽霊型です。名前的に&lt;code&gt;&#39;a texp&lt;/code&gt;ではなく&lt;code&gt;&#39;a&lt;/code&gt;の部分が幽霊型なんですかね。&lt;/p&gt;

&lt;p&gt;使い方は割と分かりやすくて、&lt;code&gt;datatype&lt;/code&gt;に余計な型をつけます。この&lt;code&gt;&#39;a&lt;/code&gt;は使われていませんがメタデータなのでそういうもんです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype &#39;a texp = E of exp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、&lt;code&gt;mkXxx&lt;/code&gt; にも型を付けます。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;mkInt&lt;/code&gt;なら返り値はIntなので&lt;code&gt;&#39;a&lt;/code&gt;の部分にその情報を詰め込みます。今回は&lt;code&gt;int&lt;/code&gt;が宜しいようです。
毎回&lt;code&gt;E&lt;/code&gt;がつくのが面倒ですが我慢して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun mkInt x: int texp = E (Int x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mkBool&lt;/code&gt;も同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun mkBool x: bool texp = E (Bool x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次は&lt;code&gt;mkIf&lt;/code&gt;ですが、condにはBool型、thenとelseには同じ型が来て欲しいです。そして返り値というかこのIfを
evalした型はthenやelseと同じ型なのでこのような型になります。Ifに渡す為に一旦&lt;code&gt;E&lt;/code&gt;を剥がしてます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun mkIf (E cnd: &#39;b texp) (E thn: &#39;a texp) (E els: &#39;a texp): &#39;a texp = E (If(cnd, thn, els))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じように考えたら&lt;code&gt;mkPlus&lt;/code&gt;や&lt;code&gt;mkEqual&lt;/code&gt;も型付け出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun mkPlus (E x: int texp) (E y: int texp): int texp = E (Plus(x, y))
fun mkEqual (E x: &#39;a texp) (E y: &#39;a texp): bool texp = E (Equal(x, y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ以後は変更ありません。一応修正後のプログラムを載せると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype exp
  = Int of int
  | Bool of bool
  | If of exp * exp * exp
  | Plus of exp * exp
  | Equal of exp * exp

datatype &#39;a texp = E of exp

fun mkInt x: int texp = E (Int x)
fun mkBool x: bool texp = E (Bool x)
fun mkIf (E cnd: &#39;b texp) (E thn: &#39;a texp) (E els: &#39;a texp): &#39;a texp = E (If(cnd, thn, els))
fun mkPlus (E x: int texp) (E y: int texp): int texp = E (Plus(x, y))
fun mkEqual (E x: &#39;a texp) (E y: &#39;a texp): bool texp = E (Equal(x, y))

exception Type

fun evalIf cnd thn els =
  case eval&#39; cnd of
      Bool x =&amp;gt; if x then eval&#39; thn else eval&#39; els
    | _ =&amp;gt; raise Type

and evalPlus x y =
    case (eval&#39; x, eval&#39; y) of
        (Int x&#39;, Int y&#39;) =&amp;gt; Int(x&#39; + y&#39;)
      | _  =&amp;gt; raise Type

and evalEqual x y =
    case (eval&#39; x, eval&#39; y) of
        (Int x&#39;, Int y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
      | (Bool x&#39;, Bool y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
      | _  =&amp;gt; raise Type

and eval&#39; exp =
    case exp of
        If(cnd, thn, els) =&amp;gt; evalIf cnd thn els
      | Plus(x, y) =&amp;gt; evalPlus x y
      | Equal(x, y) =&amp;gt; evalEqual x y
      | e =&amp;gt; e

fun eval (E x) = eval&#39; x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。ユーザインターフェースレベルでの変更はありません。
さて、ということで先の式をもう一度評価してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkEqual (mkInt 1) (mkBool false);
stdIn:1.2-1.34 Error: operator and operand don&#39;t agree [tycon mismatch]
  operator domain: int texp
  operand:         bool texp
  in expression:
    (mkEqual (mkInt 1)) (mkBool false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんとエラーが出ました。楽しいですね。&lt;/p&gt;

&lt;h1 id=&#34;発展1-任意の型:b3b6b3048912aac849c4ef033d362a0c&#34;&gt;発展1 - 任意の型&lt;/h1&gt;

&lt;p&gt;任意の型を作る手段としてタグ1つ、引数無しのタグ付き共用体を使う方法があります。それを使った技が先のPDFに載ってます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype tcp = TCP
datatype udp = UDP
datatype &#39;a safe_socket = W of Word32.word

fun mkTCP ....
fun mkUDP ....
fun sendTCP ...
fun sendUPD ...
fun close ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように型安全に、そして&lt;code&gt;close&lt;/code&gt;のように可能なものはジェネリックにプログラムを書くことが出来ます。&lt;/p&gt;

&lt;h1 id=&#34;発展2-サブタイプ:b3b6b3048912aac849c4ef033d362a0c&#34;&gt;発展2 - サブタイプ&lt;/h1&gt;

&lt;p&gt;次のようにヒエラルキーがある場合の話です。面倒なので言語を縮小しますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype num
  = Int of int
  | Real of real

datatype exp
  = Num of num
  | Bool of bool
  | Plus of exp * exp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、こうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype num
  = Int of int
  | Real of real

datatype exp
  = Num of num
  | Bool of bool
  | Plus of exp * exp

datatype &#39;a tnum = N
datatype &#39;a texp = E of exp

exception Type

fun mkInt x: (int tnum texp) = E (Num  (Int x))
fun mkReal x: (real tnum texp) = E (Num (Real x))
fun mkBool x: (bool texp) = E (Bool x)


fun mkPlus (E x: &#39;a tnum texp) (E y: &#39;a tnum texp): &#39;a tnum texp =
  case (x, y) of
      (Num (Int x&#39;), Num (Int y&#39;)) =&amp;gt; E (Num (Int (x&#39; + y&#39;)))
    | (Num (Real x&#39;), Num (Real y&#39;)) =&amp;gt; E (Num (Real (x&#39; + y&#39;)))
    | _ =&amp;gt; raise Type  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;疲れてきたので説明省略しますが型パラメータを入れ子にしたら上手い具合にサブタイプの親子関係を表せるよねって話です。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:b3b6b3048912aac849c4ef033d362a0c&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;幽霊型を使うと値レベルの話を一部型レベルに持ち上げれる（ってことで良いのかな？）&lt;/p&gt;

&lt;h1 id=&#34;最後に:b3b6b3048912aac849c4ef033d362a0c&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;どうしても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype &#39;a texp = E of exp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としている所の&lt;code&gt;E&lt;/code&gt;が気になりますね。型システム上必要っぽい(&lt;code&gt;type &#39;a texp = exp&lt;/code&gt;としてもダメだった)ので必要なコストだとは思うのですが
少くとも内部的にはゼロオーバーヘッドであって欲しいです。最適化で消せそうですが実際に消してる処理系はどれほどあるのでしょう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type &#39;a texp = exp&lt;/code&gt;でダメだった(型がミスマッチしてるのにコンパイルが通ってしまった)のも気になります。smlの&lt;code&gt;type&lt;/code&gt;ってただのエイリアスなんでしたっけ？&lt;/p&gt;

&lt;p&gt;若干のモヤモヤは残るものの一応幽霊型について知りました。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:b3b6b3048912aac849c4ef033d362a0c:1&#34;&gt;因みにこのコードをSML#のREPLで評価すると返ってこなくなります。&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/24&#34;&gt;イシュー&lt;/a&gt;に上がってます。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:b3b6b3048912aac849c4ef033d362a0c:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>正規表現技術入門を読んだ</title>
      <link>http://keens.github.io/blog/2015/05/10/seikihyougengijutsunyuumonwoyonda</link>
      <pubDate>Sun, 10 May 2015 20:32:45 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/10/seikihyougengijutsunyuumonwoyonda</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;http://gihyo.jp/book/2015/978-4-7741-7270-5&#34;&gt;正規表現技術入門&lt;/a&gt;という本の書評が望まれているようなので今日買ってきて読みました。&lt;/p&gt;

&lt;h1 id=&#34;私のバックグラウンドと目的:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;私のバックグラウンドと目的&lt;/h1&gt;

&lt;p&gt;バックグラウンドは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RubyとUnixの正規表現はそこそこ使ってる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/478191229X/ref=pd_lpo_sbs_dp_ss_1?pf_rd_p=187205609&amp;amp;pf_rd_s=lpo-top-stripe&amp;amp;pf_rd_t=201&amp;amp;pf_rd_i=4781905862&amp;amp;pf_rd_m=AN1VRQENFRJN5&amp;amp;pf_rd_r=0R2GCT6BYGWFR0061YND&#34;&gt;ドラゴンブック&lt;/a&gt;は読んだことある&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://swtch.com/~rsc/regexp/regexp1.html&#34;&gt;RE2&lt;/a&gt;の概略も知ってる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/picrin-scheme/picrin&#34;&gt;VMベースの言語処理系&lt;/a&gt;のコミッタなのでVMへの理解もある&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bleis-tift/SmlSharpContrib/pull/20/files&#34;&gt;Standard MLの正規表現エンジン&lt;/a&gt;を開発中。機能はほぼ揃ってる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;な感じです。で、実装中の正規表現エンジンがこの本で紹介されてるVM型でもDFA型でもなくVM型の素朴な形、ASTのインタプリタで
実装されてるので&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;インタプリタのまま追加出来る機能はないか&lt;/li&gt;
&lt;li&gt;高速化を目指すならVM化とDFA化どちらがいいか&lt;/li&gt;
&lt;li&gt;(既存のSMLの正規表現エンジンではVMバックエンドやDFAバックエンドでグルーピングが使えないので)高速な手法でのグルーピングの実装方法が知りたい&lt;/li&gt;
&lt;li&gt;後方参照の実装方法が知りたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などの目的で読みました。割とガチめですね。そういうことを念頭に置いてこの書評を読んで下さい。&lt;/p&gt;

&lt;h1 id=&#34;書評:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;書評&lt;/h1&gt;

&lt;h2 id=&#34;1章-正規表現:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;1章 正規表現&lt;/h2&gt;

&lt;p&gt;正規表現とはなんぞや？から入り使われる記号などを解説してます。「日本酒うめえwww」など出てきてしかも「草を生やす」の意味の解説がありました。フランクですね。
はいはい、と読み進めていったら先読み、後読みなどのあまり理解してない機能の解説やさらに上手い使い方も紹介されておお！となりました。例えばhoge、fuga、piyoの3つが含まれる文字列は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(?=.*hoge.*)(?=.*fuga.*)(?=.*piyo.*).*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けるそうです。飽くまで先読みは文字列ではなく位置にマッチするため、正規表現の重ね合わせが出来るんですね。本来ならhoge、fuga、piyoが3!通りの並び方をするので6つの分岐をしないといけない。&lt;/p&gt;

&lt;p&gt;あと、貪欲、非貪欲の他に強欲マッチなるものを知りました。確かに実装側としては貪欲マッチでバックトラックしてるところが無駄に複雑になるので強欲マッチがあるとありがたいですね。&lt;/p&gt;

&lt;p&gt;正規表現の再帰の話もありました。&lt;code&gt;(?0)&lt;/code&gt;で全体、&lt;code&gt;(?n)&lt;/code&gt;(n &amp;gt;= 1)でグループを再帰します。予想の通りこれは正規言語ではなくなるのですが、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(\d+|\((?0)\))([-+*/](?1))*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で括弧と四則演算の式をパース出来てしまうそうです。もはやパーサジェネレータ並だなと。と思ったら後で出てくる通り対応する括弧にマッチ出来てしまうので文脈自由文法を受理するそうです。すごい。&lt;/p&gt;

&lt;p&gt;導入なので読み飛ばそうと思ったのですがちゃんと飽きさせない内容で良かったですね。&lt;/p&gt;

&lt;p&gt;あとこの章でさらっと(否定)?[先後]読みが正規言語の範疇で出来るという（私にとって）大変重要な事実が書かれてました。実装しますかな。&lt;/p&gt;

&lt;h2 id=&#34;2章-正規表現の歴史:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;2章 正規表現の歴史&lt;/h2&gt;

&lt;p&gt;一口に正規表現といっても色々あるんだよーな感じな内容。恐らく後の章で比較する時のために役者を揃える目的。&lt;/p&gt;

&lt;p&gt;「Unixの正規表現といえばEREのこととする」と書いてあったのでこの章は許さない。あとegrepを使ってる。
奴は互換性のためだけに残された非推奨コマンドで、実体は grep -Eだ。古のシェルスクリプトでもない限りgrep -Eを使え。絶対許さない。&lt;/p&gt;

&lt;h2 id=&#34;3章-プログラマのための一歩進んだ正規表現:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;3章 プログラマのための一歩進んだ正規表現&lt;/h2&gt;

&lt;p&gt;正規表現の形式的な話のあとはエンジン毎のサポートする機能の違いだとかベンチマークだとかの話。VM型とDFA型の性能特徴が出てて面白かった。&lt;/p&gt;

&lt;p&gt;そして正規表現の限界(メールアドレスの精密なバリデーションには正規表現は使えないから妥協しろ、など)にも言及。
恐らく使う側からしたらこの辺の話を聞きたかったんだろうが私はそんなに興味ない。&lt;/p&gt;

&lt;h2 id=&#34;4章-dfa型エンジン:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;4章 DFA型エンジン&lt;/h2&gt;

&lt;p&gt;オートマトンの話から入る。んでNFAからDFAを構築する話。ドラゴンブックに載ってたトンプソンのアルゴリズムや部分集合構成法が紹介されてた。
しかもPythonによる実装も載っててすごいありがたい。理論系の資料だと自然言語によるアルゴリズムだけで分かりづらいんですよねー。解説も平易。&lt;/p&gt;

&lt;p&gt;次にDFAのOn the Fly構成の話。ちゃんと載ってるのはありがたい。しかしほぼ必須の機能といいつつ参考資料が載ってないのが気になった。資料が必要ないくらい簡単なのかな。&lt;/p&gt;

&lt;p&gt;最後にDFAの良いところが載ってる。VMと比較したい人には嬉しい点ですね。&lt;/p&gt;

&lt;h2 id=&#34;5章-vm型エンジン:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;5章 VM型エンジン&lt;/h2&gt;

&lt;p&gt;トイレに行きたくてうずうずしながら読んだので少し軽めにしか読んでない（ごめんなさい）。最初はVMとはなんぞや？という話から正規表現VMの挙動について、CレベルでのAPIについて、実装についてなど。
著者が開発している鬼雲で採用されてる方式なだけあってかなり詳しくて丁寧。VMの仮想アセンブラ例とスタックの遷移なども細かく書いてある。&lt;/p&gt;

&lt;p&gt;最初に必要最小限な機能をナイーブに実装したVMのコードを紹介して読者に雰囲気を掴ませたあと徐々に最適化していき、最後は鬼雲のコードを見せます。&lt;/p&gt;

&lt;p&gt;鬼雲の拡張機能のための命令や高速化のための工夫なども載ってて実装の際にはかなり役立つ筈。ここで目的の1つであったVM方式での後方参照の実装の仕方を知ります。&lt;/p&gt;

&lt;p&gt;Unicodeつらいよねーって話とか。Unicode対応しようかと思いましたがこれ読んで諦めました。&lt;/p&gt;

&lt;p&gt;AST/バイトコードレベルでの最適化の話もありました。私がプリントしたASTが簡単になるように変換していたものや、インタプリタの機能を出来る限り小さくするためにASTレベルで実現していた機能が実は最適化だったことを知りました。&lt;/p&gt;

&lt;h2 id=&#34;正規表現エンジンの三大技術動向:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;正規表現エンジンの三大技術動向&lt;/h2&gt;

&lt;p&gt;JIT、固定文字列探索、ビットパラレルについて。やはりドラゴンブックのように古い本だとこの辺はカバーし切れない。&lt;/p&gt;

&lt;h3 id=&#34;jitの話:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;JITの話&lt;/h3&gt;

&lt;p&gt;まあ、知ってるよって思ったのですがVM命令を実際にアセンブラに変換した例が載っていて後の参考になりそうだった。あとなぜバイトコードよりJITした方が速いのかの図解がめちゃくちゃ分かりやすかった。あの図、Direct Threaded VMの説明にも使えるのでいつか説明する機会があったら参考にさせてもらいます。
ところで本に載ってた鬼雲のコードはDTにしてなかったけど簡単のためなのかな？あるいは厳格にC89に準拠するため？&lt;a href=&#34;https://github.com/picrin-scheme/picrin/blob/master/extlib/benz/vm.c#L583&#34;&gt;picrinみたく&lt;/a&gt;プリプロセッサで分岐すれば使えるのに。&lt;/p&gt;

&lt;p&gt;流石にOn the Flyコンパイルの話はなかった。まあ、あんまりメリットないしやんないか。&lt;/p&gt;

&lt;h3 id=&#34;固定文字列探索の話:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;固定文字列探索の話&lt;/h3&gt;

&lt;p&gt;grepよりgrep -Fの方が速いよねーって話かと思ったらそれだけではなかった。&lt;code&gt;http://([^/?#]*)?([?#]*)(\?([^#]*))?(#(.*))?&lt;/code&gt;みたいな正規表現にマッチさせる時に、まず &lt;code&gt;http://&lt;/code&gt; を固定文字列探索で高速に見付けてからそこを起点にマッチを始める高速化手法があるそうです。固定文字列探索が高速なのはQuick Search（多分尺取り法と同じ）などのアルゴリズムがあるからですねー。あとSIMDやAVXも使える。さらに今回の&lt;code&gt;http://&lt;/code&gt;みたいな&amp;rdquo;キーワード&amp;rdquo;を抽出する技術の話も。&lt;/p&gt;

&lt;h3 id=&#34;ビットパラレルの話:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;ビットパラレルの話&lt;/h3&gt;

&lt;p&gt;先の固定文字列探索の話に関連して。固定文字列ではなく文字クラスまで含めても高速に扱える方法。なるほど〜といったところ。SIMDやAVXが使えない/使いづらい言語でも実践出来そうでいいですね。&lt;/p&gt;

&lt;h2 id=&#34;正規表現の落とし穴:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;正規表現の落とし穴&lt;/h2&gt;

&lt;p&gt;RE2のモチベーションでもある、バックトラックによってマッチングが指数時間になってしまう問題から。「RE2使え」ってくるかと思ったらユーザーレベルでどうにかする話や正規表現の最適化の部分でどうにかする話もあった。&lt;/p&gt;

&lt;p&gt;落とし穴とその対策の話があるのですが、一番気になったのがエンジンによる挙動の違い。私の正規表現エンジンはEREを実装することを目標として、grep -Eで挙動を確かめながら実装してたのですがちょっと怪しくなってきた。&lt;/p&gt;

&lt;p&gt;マッチ戦略が最左最長か自身がないのもあるけどグルーピングの話。pythonではグループは上書きされて、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; r = re.compile(&#39;(\w+,?)*&#39;)
&amp;gt;&amp;gt;&amp;gt; re.match(&#39;apple,banana,kiwi&#39;).groups()
(&#39;kiwi&#39;,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となるそうです。最初、私の正規表現エンジンもこの挙動をしていたのですが、grep -Eは例えば&lt;code&gt;echo &#39;apple,banana,kiwi&#39; | grep -o -E &#39;([a-z],?)*&#39;&lt;/code&gt;が&lt;code&gt;apple,banana,kiwi&lt;/code&gt;を返すのでわざわざ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;| Star =&amp;gt; (case acc of
                           [] =&amp;gt; raise Parse
                         | Group(i, x) :: xs  =&amp;gt; parse(ts, Group(i, Kleene x) :: xs, e, gi)
                         | x :: xs =&amp;gt; parse(ts, Kleene x :: xs, e, gi))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように括弧の後にスターが来たら括弧の中のクリーネ閉包をとってました。まあ、実装はそれぞれらしいのでこれが間違ってる訳ではないのですがパーサを不必要に複雑にしてしまったことを反省。&lt;/p&gt;

&lt;p&gt;残りはアトミックグループの話だとか。&lt;/p&gt;

&lt;h2 id=&#34;正規表現を越えて:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;正規表現を越えて&lt;/h2&gt;

&lt;p&gt;正規表現周りのツールの紹介の後はBNF、PEGの話。恥ずかしながら、BNFの表現範囲である文脈自由言語が正規表現言語+括弧の対応だということを初め知りました。いや、もしかしたらドラゴンブックに書いてたのかもしれませんが見落してました。&lt;/p&gt;

&lt;p&gt;PEGについては、BNFあるしいいやって思ってたのですがマッチが線形時間だったりBNFで表現出来ない範囲まで表現出来たりと中々楽しそうでした。&lt;/p&gt;

&lt;p&gt;あとまさかの「草生やす」の説明をした伏線を回収。&lt;/p&gt;

&lt;h2 id=&#34;付録a-1-正規と非正規の壁:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;付録A.1 正規と非正規の壁&lt;/h2&gt;

&lt;p&gt;正規言語の話とその辺の証明。否定は正規だけど後方参照は非正規だとか。この本で一番理論寄りな話でありながら同値関係とは〜とかから解説していてすごい丁寧（簡単に理解出来るとは言っていない）。いや、でも本当に正規言語関連の証明が欲しかったらまずはここ参照するかってくらい丁寧ですよ。&lt;/p&gt;

&lt;h2 id=&#34;付録a-2-正規性の魅力:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;付録A.2 正規性の魅力&lt;/h2&gt;

&lt;p&gt;だんだん感想が雑になってるのからも分かる通り、この辺で力尽きたのでこの章は流しました。後日読みます。&lt;/p&gt;

&lt;h1 id=&#34;全体を通して:617daf1ef9d19b0890ebaf6be4722a4b&#34;&gt;全体を通して&lt;/h1&gt;

&lt;p&gt;論文やWeb上の資料への参照をばら撒いていますが本書自体は理論寄りになりがちな正規表現の解説を平易に書いていて、かなり敷居を下げてくれたなという印象。正規表現やエンジンの歴史、それによる実装の違いなども説明しているのでこの本を持っていれば正規表現でハマるということもなくなりそう。まえがきにもある通り、Web上では断片的にしか入らない知識が1冊にまとまっている。個人的にはDFAの話をもうちょっと詳しく知りたかった。DFAを実装する時の最適化の話とか。&lt;/p&gt;

&lt;p&gt;私のように正規表現を実装したい人だけでなく「正規表現の最適化ってどこまで賢いの？」だとか「このパターンは正規表現で表現出来るの？」だとか「書いた正規表現が魔境で理解出来ないから綺麗に書きたい」だとか思ってる人にも良い本だと思います。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;http://gihyo.jp/book/2015/978-4-7741-7270-5&#34;&gt;この本&lt;/a&gt;、33,00円ですが私は4,800円でも買った。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>tarballベースの軽量バックアップツール&#39;Sheltar&#39;を作った</title>
      <link>http://keens.github.io/blog/2015/05/06/tarballbe_sunokeiryoubakkuapputsu_rutsukutta</link>
      <pubDate>Wed, 06 May 2015 20:45:53 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/06/tarballbe_sunokeiryoubakkuapputsu_rutsukutta</guid>
      <description>

&lt;p&gt;κeenです。みなさんバックアップは何使ってますか？大抵のOSには標準でバックアップツールが付いてますがそれ使ってます？私も使ってます。
しかしやつらはそのOSでしか動かない/動かす方法があまり知られていないのでマシンがクラッシュしたりマシンを失くした時に困ります。&lt;/p&gt;

&lt;p&gt;そこで候補に上がるのが安心と信頼のtarballですが今度は増分バックアップが取りづらいという問題があります。なのでtarballベースの差分バックアップツールを作りました。&lt;/p&gt;

&lt;p&gt;まあ、捜せば同じようなものが色々あるでしょうが捜し回るのが面倒だし色々インストールするのも嫌なのでえいやと作ってしまいました。&lt;/p&gt;

&lt;p&gt;タイトルにある通り&lt;a href=&#34;https://github.com/KeenS/sheltar&#34;&gt;Sheltar&lt;/a&gt;といいます。ポータブルなB Shellスクリプト製です。どこでも動くと思います。バックアップ（避難）だしshellだしtarだしって適当に付けたら意外にもコンフリクトがありませんでした。しかも&lt;a href=&#34;http://ultra.wikia.com/wiki/Sheltar&#34;&gt;ウルトラ怪獣&lt;/a&gt;にも居るという奇跡的な名前です。&lt;/p&gt;

&lt;h1 id=&#34;目的:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;目的&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E5%A2%97%E5%88%86%E3%83%90%E3%83%83%E3%82%AF%E3%82%A2%E3%83%83%E3%83%97&#34;&gt;増分バックアップ&lt;/a&gt;をとる&lt;/li&gt;
&lt;li&gt;UbuntuとMac間でのデータ同期にも使いたい(家のルータがしょぼいのでrsyncを使いたくなく、USBメモリ経由とかが良い)&lt;/li&gt;
&lt;li&gt;なのでファイル形式はポータブルなtarballで&lt;/li&gt;
&lt;li&gt;メタデータとかは極力置かず、最悪他のツールからでもバックアップデータをサルベージ出来るようにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;です。 GNU tarには増分バックアップ用のオプションがありますがファイル抽出は手作業でやる必要があります。
また、(多分)BSD tarには増分バックアップ用のオプションがないのでそこもカバーする必要があるかなと思って作りました。&lt;/p&gt;

&lt;p&gt;あとオプションがあるとはいっても一々覚えてられないのでスクリプト化してしまいたかったってのもあります。&lt;/p&gt;

&lt;h1 id=&#34;使い方:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;使い方&lt;/h1&gt;

&lt;h2 id=&#34;step0:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;STEP0&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/sheltar&#34;&gt;ここ&lt;/a&gt;からSheltarを入手しましょう。&lt;code&gt;sheltar&lt;/code&gt;スクリプト1つで完結しているのでcloneしなくてもrawをwgetしてきても大丈夫です。&lt;/p&gt;

&lt;h2 id=&#34;step1:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;STEP1&lt;/h2&gt;

&lt;p&gt;増分バックアップなので複数のtarballが作られます。バックアップ用のディレクトリを用意しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir /mnt/dev1/backup
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step2:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;STEP2&lt;/h2&gt;

&lt;p&gt;バックアップしたいファイルをリストアップしましょう。バックアップは継続的に行なうものなので1回限りのコマンドライン引数で渡す訳にはいきませんね。&lt;/p&gt;

&lt;p&gt;pngファイルをバックアップしたいとしましょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ find Pictures -name &#39;*.png&#39; &amp;gt;&amp;gt; list.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで良さそうです。ディレクトリの中身全部をバックアップしたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ echo Pictures/ &amp;gt;&amp;gt; list.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でも構いません。最後の&amp;rsquo;/&amp;lsquo;重要です。最初のバックアップの時には問題ありませんが&amp;rsquo;/&amp;lsquo;がないと増分バックアップの時にディレクトリ自体のlast modified timeを見て変更を判断します。&lt;/p&gt;

&lt;h2 id=&#34;step3:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;STEP3&lt;/h2&gt;

&lt;p&gt;あとは実行するだけですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sheltar backup /mnt/dev1/backup list.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後、増分バックアップを取るのも同じく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sheltar backup /mnt/dev1/backup list.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で可能です。前回のアーカイブファイルのlast modified time より新しいファイルだけをバックアップしてくれます。&lt;/p&gt;

&lt;p&gt;因みに今のところバックアップディレクトリに余計なものがあると正しく動作してくれないので注意です。&lt;/p&gt;

&lt;h2 id=&#34;復元:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;復元&lt;/h2&gt;

&lt;p&gt;全部のファイルをカレントディレクトリにぶちまけたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sheltar extract /mnt/dev1/backup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。抽出するファイルを指定したいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sheltar extract /mnt/dev1/backup file1 file2 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;p&gt;カレントディレクトリに同名ファイルが既にある場合は新しい方を残します。&lt;/p&gt;

&lt;h1 id=&#34;その他:1c518fffcb9f45ff4a1b2c6719541034&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;まだまだ未完成です。欲しい機能があったら&lt;a href=&#34;https://github.com/KeenS/sheltar/issues&#34;&gt;issue&lt;/a&gt;に投げてくれると実装するかもしれません。&lt;a href=&#34;https://github.com/KeenS/sheltar/pulls&#34;&gt;Pull Request&lt;/a&gt;もお待ちしております
あと、ドックフードはまだ食べてません。一応テストはしてますが…。Macをまともに使う気になったら使い始めると思います。&lt;/p&gt;

&lt;p&gt;あ、そうそう。今回比較的コメントを多く書いたのでシェルスクリプトを勉強したい方はソース読んでみて下さい。
こんな感じです。Doxygenがシェルスクリプトに対応してないので疑似ドキュメント形式のコメントですが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Extract the all files from backups in $ST_BACKUP_DIR.
# A file with the same name as extracting file will be preserved if it is newer than its counterpart.
## @filesystem extract all the backup files to CWD
st_extract_all()
{
    # This is preferable to `for TARBALL in $(ls)` because the names of listed files
    # can contain whilespaces
    ls --sort=time -r &amp;quot;${ST_BACKUP_DIR}&amp;quot; | while read TARBALL
    do
        tar xf &amp;quot;${ST_BACKUP_DIR}/${TARBALL}&amp;quot; \
            --keep-newer-files               \
            --preserve-permissions           \
            --preserve-order
    done
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SMLを書くLisperの悩み</title>
      <link>http://keens.github.io/blog/2015/05/03/smlwokakulispernonayami</link>
      <pubDate>Sun, 03 May 2015 13:23:17 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/05/03/smlwokakulispernonayami</guid>
      <description>&lt;p&gt;SMLばっかり書いてたら「お前Lisperじゃないだろ」って怒られたとかそういう話ではなく。&lt;/p&gt;

&lt;p&gt;ML系の言語は関数は1つの引数しかとれません。じゃあ複数の値を受け取りたい時はどうするかというと 1. 値を組(タプル)にして受け取る 2. 関数を返す関数((を返す関数)*)にして1つづつ受け取る の2種類の方法があります。
それに纏わる話。&lt;/p&gt;

&lt;p&gt;それぞれの記法を例示すると&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;値を組(タプル)にして受け取る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun add (x, y) = x + y
add (1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは、手続型言語に似せて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;add(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするスタイルもあります&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;関数を返す関数((を返す関数)*)に(カリー化)して1つづつ受け取る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun add x y = x + y
add x y  (*= ((add x) y)  *)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。勿論、2.のように何度も関数を呼び出すよりは1.のように一度で全ての値を渡してしまった方が速い筈です。なのでプリミティブっぽい関数はタプル式にした方が良さそうです。
また、無名関数を定義する時にSMLでは&lt;code&gt;fun&lt;/code&gt;のように自動でカリー化してくれる構文がないので複数の引数を受け付ける関数を引数にとる高階関数を定義するときはタプル式の方が都合が良いでしょう。&lt;/p&gt;

&lt;p&gt;例えば二項演算子はタプル式で定義しなければなりませんし、&lt;code&gt;List.foldl&lt;/code&gt;のシグネチャも&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(&#39;a * &#39;b -&amp;gt; &#39;b) -&amp;gt; &#39;b -&amp;gt; &#39;a list -&amp;gt; &#39;b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;p&gt;勿論、積極的に最適化を行なうコンパイラではuncurry optimizationや、closure eliminationでカリー化によるオーバーヘッドはなくなります。
むしろ、カリー化した方が部分適用が出来るので利便性は上がります。となると後は無名関数の問題ですが、OCamlやHaskellなど無名関数にもカリー化した定義が出来る構文のある言語だとそれも問題なく、タプル式の引数の渡し方はしないようです。&lt;/p&gt;

&lt;p&gt;SMLは流石に&amp;rsquo;Standard&amp;rsquo;なので最適化を仮定したり余計な構文を突っ込んだりはしづらいのでしょう。なのでこの問題はSML特有のようです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ここまで、なぜタイトルがML系言語ではなくSML限定なのかの前置き。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;こういう関数呼び出しがあるとします。&lt;code&gt;sub: string * int -&amp;gt; char&lt;/code&gt;は文字列の0番目の文字を取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;sub(str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに&lt;code&gt;Char.isAlpha : char -&amp;gt; bool&lt;/code&gt;を適用します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Char.isAlpha sub(str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ、コンパイルエラーになります。みなさん何でか分かりますか？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sub(str, 0)&lt;/code&gt;はあくまで&lt;code&gt;sub&lt;/code&gt;に&lt;code&gt;(str, 0)&lt;/code&gt;というタプルを渡している文なのでコンパイラはこう解釈するのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(Char.isAlpha sub) (str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回このようなエラーを出すのが面倒なので関数の呼び出しには全て手続き型言語のように括弧をつけることを考え始めます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Char.isAlpha(sub(str, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしそうは問屋が卸さないのがカリー化された関数。&lt;code&gt;String.isPrefix: string -&amp;gt; string -&amp;gt; bool&lt;/code&gt;に次のような呼び出しをすると勿論怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;String.isPrefix(&amp;quot;/usr/local&amp;quot; path)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必ず&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;String.isPrefix &amp;quot;/usr/local&amp;quot; path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としないといけません。これまた関数呼び出しがネストすると面倒で、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;app (fn s =&amp;gt; print (s ^ &amp;quot;\n&amp;quot;)) (List.filter (String.isPrefix &amp;quot;/usr/local&amp;quot;) paths)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように毎回括弧が付き纏います。ここまでくるとS式みたく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(app (fn s =&amp;gt; print (s ^ &amp;quot;\n&amp;quot;)) (List.filter (String.isPrefix &amp;quot;/usr/local&amp;quot;) paths))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きたくなってくるのがLisperの心情。これなら慣れないデータコンストラクタや関数呼び出しや中置演算子の優先順位問題も解決!やったね!!と思ったのですがやっぱりタプル式の関数呼出が行く手を阻むのでした。
&lt;code&gt;(sub(str, i))&lt;/code&gt; とか訳分からなすぎる。括弧多すぎる。&lt;/p&gt;

&lt;p&gt;ということでどっちに揃えたら良いのかさえ分かってないのにどっちにも揃えられてないSMLに対して悩みを抱えるLisperの悩みでした。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;は&lt;code&gt;Char.isAlpha()&lt;/code&gt;のような書き方は無駄な括弧がついてると怒ってきます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#をMacでビルドする</title>
      <link>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</link>
      <pubDate>Wed, 29 Apr 2015 16:09:08 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/29/smlsharpwomacdebirudosuru</guid>
      <description>

&lt;p&gt;κeenです。SML#2.0.0を文鎮と化していたMBAにインストールしたのでメモをば。&lt;/p&gt;

&lt;p&gt;基本は&lt;a href=&#34;http://d.hatena.ne.jp/keita44_f4/20140412/1397279451&#34;&gt;よんたさんの記事&lt;/a&gt;をMacに翻訳した感じです。&lt;/p&gt;

&lt;p&gt;モチベーションは、&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/ja/?Download&#34;&gt;公式の配布物&lt;/a&gt;がMac版だとMacPorts版しかなく、
portsとhomebrewの混在は避けた方が良いと聞いたのでどうにかして自前ビルドしようとしたことです。&lt;/p&gt;

&lt;h1 id=&#34;注意書き:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;注意書き&lt;/h1&gt;

&lt;p&gt;冒頭にも書いてあるようにMBAは普段使ってなくて、このエントリーもMBAじゃないマシンから書いているのでコマンド類はコピペでなく写経してます。
typoがあるかもしれないのでコピペして動かなかったら一応この記事のtypoを疑って下さい。&lt;/p&gt;

&lt;h1 id=&#34;gmp32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;GMP32bitの準備&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ brew install gmp --32-bit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で終わり。バージョン6.0.0aが入りました。
既にインストールされていたら多分64bit版が入っているので一旦 &lt;code&gt;brew remove gmp&lt;/code&gt; してから再度インストールすると良いです。尚、バイナリ版はないようで、ビルドが始まります。checkに時間が掛かる。&lt;/p&gt;

&lt;h1 id=&#34;llvm34-32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;LLVM34 32bitの準備&lt;/h1&gt;

&lt;p&gt;骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://llvm.org/releases/3.4.2/llvm-3.4.2.src.tar.gz
$ gzcat llvm-3.4.2.src.tar.gz | tar xf -
$ cd llvm-3.4.2.src
$ ./configure --build=i686-mac-darwin CC=&#39;gcc -m32&#39; CXX=&#39;g++ -m32&#39; --prefix=/usr/local/Cellar/llvm34/3.4.2a
$ make -j4
$ make -j4 install
$ cd ../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら上手くいきました。何故上手くいったんでしょうねー。あとprefixは割と気持悪いのでみなさん適切な場所にインストールしましょうね。&lt;/p&gt;

&lt;h1 id=&#34;sml-のビルド:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;SML# のビルド&lt;/h1&gt;

&lt;p&gt;これが一番骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.pllab.riec.tohoku.ac.jp/smlsharp/download/smlsharp-2.0.0.tar.gz
$ gzcat smlsharp-2.0.0.tar.gz | tar xf -
$ cd smlsharp-2.0.0
$ ./configure --with-llvm=/usr/local/Cellar/llvm34/3.4.2a/      \
               LDFLAGS=&#39;-L/usr/local/Cellar/gmp/6.0.0a/lib&#39;     \
              CPPFLAGS=&#39;-I/usr/local/Cellar/gmp/6.0.0a/include&#39; \
                    CC=&#39;gcc -m32&#39;                               \
                   CXX=&#39;g++ -m32&#39;
$ make -j4
$ make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら出来ました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;誰かhomebrewにして。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpを使ってSMLのon-the-flyエラーチェック</title>
      <link>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</link>
      <pubDate>Thu, 23 Apr 2015 23:01:17 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</guid>
      <description>

&lt;p&gt;κeenです。最近SMLを結構書いてるのですが中置演算子が乱立する言語はLisperにはつらくて、しょっちゅうコンパイルエラーを出します。
そこでSML#をflymakeで動かしてOn The Flyにエラーチェックをします。&lt;/p&gt;

&lt;p&gt;なぜSML#かというと &lt;code&gt;-ftypecheck-only&lt;/code&gt; オプションがあって、シンタックスと型エラーのチェックだけを行なえるからです。&lt;/p&gt;

&lt;p&gt;色々試したのですが設定はこれだけで済みました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(eval-after-load &#39;flymake
  &#39;(progn 
    (add-to-list &#39;flymake-allowed-file-name-masks &#39;(&amp;quot;.+\\.sml$&amp;quot;
                                                    (lambda ()
                                                      (list &amp;quot;/usr/local/bin/smlsharp&amp;quot; (list &amp;quot;-ftypecheck-only&amp;quot; (buffer-file-name))))
                                                    (lambda () nil)))
    (add-to-list &#39;flymake-err-line-patterns &#39;(&amp;quot;^\\([^: ]*\\):\\([0-9]+\\)\\.\\([0-9]+\\)-[0-9]+\\.[0-9]+ \\(Error\\|Warning\\):&amp;quot;
                                              1 2 3 4))))
(add-hook &#39;sml-mode-hook #&#39;flymake-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;/usr/local/bin/smlsharp&amp;quot;&lt;/code&gt; のところは各自書き換えて下さい。尚、SML#はエラーメッセージを複数行に跨って出すのですがそれがflymakeと相性が悪いのでエラーメッセージの取得は諦めました。&lt;/p&gt;

&lt;p&gt;多くの場合、 &lt;code&gt;flymake-simple&lt;/code&gt; という枠組みの中で設定を書くのですがテンポラリファイルを作る構造がどうしてもインターフェースファイルと相性が悪かったので生のflymakeを使ってます。
というかflymakeは元々 &lt;code&gt;-ftypecheck-only&lt;/code&gt; みたいなのを前提に作られてたのに実際にコンパイル走らせないとエラーメッセージ取得出来ない言語が多過ぎてフレームワークが出来たのでこれが本来の使い方です。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:311ce9d5e51e732b1928a84bcceb27a3&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;というものがあって、スタイルワーニングを出してくれます。ただ、これはパッチを当てないと使えなかったりスタイルワーニングのみしか出さなかったりするので気が向いた時に紹介します&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpでFFIバインディングを書く時の知見</title>
      <link>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</link>
      <pubDate>Sun, 19 Apr 2015 13:51:33 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</guid>
      <description>

&lt;p&gt;κeenです。最近頻繁にSML#を使ってます。SML#のメイン機能の1つであるC連携ですが、ちょっと複雑なことをやろうとするとテクニックが必要になるので共有します。&lt;/p&gt;

&lt;p&gt;Twitterとかにコメントや突っ込みお願いします。&lt;/p&gt;

&lt;h1 id=&#34;簡単な型:017736760057fcde64c6904c3e916b13&#34;&gt;簡単な型&lt;/h1&gt;

&lt;p&gt;型が簡単な関数なら普通に&lt;code&gt;_import&lt;/code&gt;で済みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val puts = _import &amp;quot;puts&amp;quot;: string -&amp;gt; ()
val () = puts &amp;quot;Hello, C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尚、簡単な型とは&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch9.S2.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;にある通り、いわゆる即値、即値の組（タプル）、即値の配列、即値の参照、それらを引数、返り値に持つ関数などです。&lt;/p&gt;

&lt;p&gt;又、以下のような制約もあります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C関数全体の型は，引数リストを組型とするMLの関数型に対応付けられます． ただし，C関数の引数や返り値に書ける相互運用型には，以下の制約があり ます．
   配列型や組型など，Cのポインタ型に対応する相互運用型を，C関数の返り値の 型として指定することはできません．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恐らくGCとの兼ね合いでしょうがつらいですね。stringすら返り値で受け取れません。&lt;/p&gt;

&lt;p&gt;それにこの制約がどこまで効いてるのかが不明で、同じ型でも型付けに成功したり失敗したりすることがあります。例えば上の例でstring型を引数にとる関数をインポートしましたが関数に依ってはstringが相互運用型でないとか怒られることがあります。タプルの配列やタプルの参照などは確実にダメみたいです。&lt;/p&gt;

&lt;p&gt;尚、string型はCでいう &lt;code&gt;const char *&lt;/code&gt; 、タプルは変更不能な構造体へのポインタになるそうです。構造体の即値は扱えないんですね…。また、参照とは別に &lt;code&gt;ptr&lt;/code&gt; 型も存在します。SML#側からは作れず、Cとの相互運用のためだけに存在するようです。&lt;/p&gt;

&lt;h1 id=&#34;魔法の-unit-ptr:017736760057fcde64c6904c3e916b13&#34;&gt;魔法の &lt;code&gt;unit ptr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;じゃあ複雑な型はインポート出来ないのかというとそうでもなく、 &lt;code&gt;unit ptr&lt;/code&gt; 型にしておけばとりあえずインポート出来ます。Cで言うところの &lt;code&gt;void *&lt;/code&gt; です。
邪悪な雰囲気を感じますね。しかしそこは型安全言語、ちゃんと型安全に &lt;code&gt;unit ptr&lt;/code&gt; を扱えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;type file = unit ptr
val fopen = _import &amp;quot;fopen&amp;quot;: (string, string) -&amp;gt; file
val fgetc = _import &amp;quot;fgetc&amp;quot;: (file) -&amp;gt; int
val fclose = _import &amp;quot;fclose&amp;quot;: (file) -&amp;gt; int
val () = let
      val f = fopen(&amp;quot;test&amp;quot;, &amp;quot;r&amp;quot;)
      val c = fgetc(f)
    in
      print(str(chr c));
      fclose(f)
    end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。単に &lt;code&gt;type&lt;/code&gt; で名前をつけてあげれば大丈夫です。SML#側ではポイント先が何であるかには関知せず、インポートしたC関数の間で完結してれば問題ありません。多くのライブラリはそのようなAPIになっているのではないでしょうか。&lt;/p&gt;

&lt;h1 id=&#34;ポインタを扱う:017736760057fcde64c6904c3e916b13&#34;&gt;ポインタを扱う&lt;/h1&gt;

&lt;p&gt;とはいえ時にポインタを扱う必要もあります。構造体の配列を扱えないのでその辺で。&lt;/p&gt;

&lt;p&gt;そういった時に便利なのが &lt;code&gt;SMLSharp_Builtin.Pointer&lt;/code&gt; と &lt;code&gt;Pointer&lt;/code&gt; です。 &lt;code&gt;Pointer&lt;/code&gt; の方は .smi ファイルの中で &lt;code&gt;_require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt; してから使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure SMLSharp_Builtin
  structure Pointer =
  struct
    val identityEqual = _builtin val IdentityEqual : boxed * boxed -&amp;gt; bool
    val advance = _builtin val Ptr_advance : &#39;a ptr * int -&amp;gt; &#39;a ptr
    val deref = _builtin val Ptr_deref : &#39;a ptr -&amp;gt; &#39;a
    val store = _builtin val Ptr_store : &#39;a ptr * &#39;a -&amp;gt; unit

    val toUnitPtr = _builtin val Cast : &#39;a ptr -&amp;gt; unit ptr
    val fromUnitPtr = _builtin val Cast : unit ptr -&amp;gt; &#39;a ptr
    val toCodeptr = _builtin val BitCast : unit ptr -&amp;gt; codeptr
  end
  end

structure Pointer =
struct
  val advance = SMLSharp_Builtin.Pointer.advance

  val load =
      case &#39;a in &#39;a ptr -&amp;gt; &#39;a of
        int =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | char =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.deref

  val store =
      case &#39;a in &#39;a ptr * &#39;a -&amp;gt; unit of
        int =&amp;gt; SMLSharp_Builtin.Pointer.store
      | word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | char =&amp;gt; SMLSharp_Builtin.Pointer.store
      | real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.store

  val isNull : &#39;a ptr -&amp;gt; bool
  val NULL : unit -&amp;gt; &#39;a ptr

  val importBytes : SMLSharp_Builtin.Word8.word ptr * int
                    -&amp;gt; SMLSharp_Builtin.Word8.word vector
  val importString : char ptr -&amp;gt; string
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 、 &lt;code&gt;store&lt;/code&gt; 、 &lt;code&gt;deref&lt;/code&gt; 、 &lt;code&gt;advance&lt;/code&gt; あたりを良く使いそうですね。&lt;/p&gt;

&lt;p&gt;実際にあった話。 &lt;code&gt;struct header { const char *name; int name_len; const char *value; int value_len}&lt;/code&gt; の配列(&lt;code&gt;struct header *&lt;/code&gt;)を扱う必要がありました。
その配列をCの関数に渡して書き換えてもらって、後で値を取り出したいという状況がです。その時値を取り出すコードがこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun getHeader headers i =
      let
          val header_ptr : char ptr ptr = fromUnitPtr(headers)
          val header_ptr = advance(header_ptr, i * 2)
          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val header_ptr = advance(header_ptr , i * 2)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val name = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val nameLen = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val value = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val valueLen = deref(header_ptr)
      in
          if isNull name
          then (NONE, String.substring(importString(value), 0, valueLen))
          else (SOME(String.substring(importString(name), 0, nameLen)),
                String.substring(importString(value), 0, valueLen))
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、タプルは構造体へのポインタなので今回の &lt;code&gt;struct header *&lt;/code&gt; は &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではありません。それは &lt;code&gt;struct header **&lt;/code&gt; になってしまいます。
また、ポインタを扱う関数が &lt;code&gt;ptr&lt;/code&gt; 型しか受け付けないので &lt;code&gt;string&lt;/code&gt; ではなく &lt;code&gt;char ptr&lt;/code&gt; にしておいて後から &lt;code&gt;importString&lt;/code&gt; で文字列にする戦略をとります。&lt;/p&gt;

&lt;p&gt;そして配列のi番目にアクセスしたかったら先述の通り &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではないので地道に &lt;code&gt;char ptr ptr&lt;/code&gt; 2*i個分、 &lt;code&gt;int ptr&lt;/code&gt; 2*i個分ポインタを進めます。
ポインタの型を変える時はダイレクトには変換出来ないようなので一旦 &lt;code&gt;unit ptr&lt;/code&gt; を経由してから変換。そして次のメンバにアクセスするために &lt;code&gt;advance&lt;/code&gt; という形をとります。&lt;/p&gt;

&lt;p&gt;そこまでしたら後は &lt;code&gt;deref&lt;/code&gt; してあげれば欲しい値がとれます。&lt;/p&gt;

&lt;h1 id=&#34;replからのimportと-dynamiclink:017736760057fcde64c6904c3e916b13&#34;&gt;REPLからのimportと &lt;code&gt;DynamicLink&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;SML#のREPLからも勿論インポート出来ますが、SML#のランタイムにリンクされてないライブラリのものはインポート出来ないのでダイナミックリンクを使います。 &lt;code&gt;DynamicLink&lt;/code&gt; にCの &lt;code&gt;dl*&lt;/code&gt; と同じ関数群が用意されているのでそれらを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure DynamicLink =
struct
  type lib (= ptr)
  datatype scope = LOCAL | GLOBAL
  datatype mode = LAZY | NOW
  val dlopen : string -&amp;gt; lib
  val dlopen&#39; : string * scope * mode -&amp;gt; lib
  val dlsym : lib * string -&amp;gt; codeptr
  val dlsym&#39; : lib * string -&amp;gt; unit ptr
  val dlclose : lib -&amp;gt; unit
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;val lib = dlopen(&amp;quot;libawsome.so&amp;quot;)&lt;/code&gt; でライブラリのオープン、 &lt;code&gt;dlsym(lib, &amp;quot;awm_function&amp;quot;): _import () -&amp;gt;unit&lt;/code&gt; で読み込みです。&lt;/p&gt;

&lt;p&gt;これでインポートする関数は必要になった時に読み込んで欲しいのですがトップレベルで &lt;code&gt;val&lt;/code&gt; でバインドすると即読み込まれてしまいます。その辺を上手くやるテクニックがSML#のソースにありました。MySQLのバインディングの部分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun lazy f =
      let
        val r = ref NONE
      in
        fn () =&amp;gt;
           case !r of
             SOME x =&amp;gt; x
           | NONE =&amp;gt;
             let val x = f ()
             in r := SOME x; x
             end
      end

  val lib =
      lazy (fn _ =&amp;gt;
               DynamicLink.dlopen
                 (case OS.Process.getEnv &amp;quot;SMLSHARP_LIBMYSQLCLIENT&amp;quot; of
                    NONE =&amp;gt; &amp;quot;libmysqlclient.16.&amp;quot; ^ SMLSharp_Config.DLLEXT ()
                  | SOME x =&amp;gt; x))

  fun find s = DynamicLink.dlsym(lib (), s)
  val mysql_init =
      lazy (fn _ =&amp;gt; find &amp;quot;mysql_init&amp;quot;
                    : _import (MYSQL) -&amp;gt; MYSQL)


...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遅延評価してますね。これ。呼び出す時は &lt;code&gt;mysql_init () (mysql)&lt;/code&gt; みたいに一旦lazyを剥がさないといけないので注意です。&lt;/p&gt;

&lt;h1 id=&#34;問題とか:017736760057fcde64c6904c3e916b13&#34;&gt;問題とか&lt;/h1&gt;

&lt;h2 id=&#34;cの仕様:017736760057fcde64c6904c3e916b13&#34;&gt;Cの仕様&lt;/h2&gt;

&lt;p&gt;確かCの仕様上構造体のメモリ上の表現にはメンバ以外のものも置いていいことになっていた筈です。
上の方法では変なコンパイラでコンパイルしたコードだと動きそうにないですね。GCCやClangは大丈夫な筈。&lt;/p&gt;

&lt;p&gt;そもそもSML#自体GCCとABI互換なコンパイラでコンパイルしたものじゃないとリンク出来なそうな気がするので杞憂ですかね。&lt;/p&gt;

&lt;h2 id=&#34;メモリ確保:017736760057fcde64c6904c3e916b13&#34;&gt;メモリ確保&lt;/h2&gt;

&lt;p&gt;Cの関数から構造体のポインタが返ってくるケースだと良いんですが自分で構造体を用意してCの関数に渡すケースだとメモリの確保が問題になります。現状、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct header
*prepare_headers(int n)
{
  return malloc(n * sizeof(struct header));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなヘルパ関数を用意して凌いでますが欲しい構造体毎に書かないといけないのであまり嬉しくないです。 &lt;code&gt;sizeof&lt;/code&gt; をSML#側でとれれば単に &lt;code&gt;malloc&lt;/code&gt; をバインドするだけで済むのに。
もう少し欲を言うと &lt;code&gt;malloc&lt;/code&gt; したらGCから外れそうな気がするので明示的に &lt;code&gt;free&lt;/code&gt; する必要がありそうです。GCに載るメモリ確保関数も欲しいですね。
さらに欲を言うとスタックアロケートする版のメモリ確保関数も欲しい。もしかしたら &lt;code&gt;alloca&lt;/code&gt; で大丈夫なんでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;define:017736760057fcde64c6904c3e916b13&#34;&gt;&lt;code&gt;#define&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ヘッダファイル内で定数を &lt;code&gt;#define&lt;/code&gt; してあることが多々あります。それらは地道に手書きでSML#側に持ってくることになりますが気になるのが互換性の問題。
特にOSのヘッダファイルには名前は同じだけどOS毎に値が異なるものが存在します。シグナルとか。OSで条件分岐するか理想的にはプリプロセッサのサポートがあればどうにかなりそうなんですけどねぇ。
現状だとCで定数を返すgetter関数を書いてSML#側でインポートして…ってやればどうにか出来そうですけどやりたくないですね。&lt;/p&gt;

&lt;h2 id=&#34;変数:017736760057fcde64c6904c3e916b13&#34;&gt;変数&lt;/h2&gt;

&lt;p&gt;私はまだ遭遇してないのですがライブラリによってはグローバル変数にアクセスしないといけないものが存在します。これもgetterとsetterを書いて…ってやるとどうにか出来そうですがどうせなら変数のインポートも出来ると良いですよね。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:017736760057fcde64c6904c3e916b13&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SML#でCのバインドを書く時は少しテクニックが必要&lt;/li&gt;
&lt;li&gt;SML#にはポインタを直接扱える関数もある&lt;/li&gt;
&lt;li&gt;それでも機能が足りない時はCでヘルパ関数を書こう。&lt;/li&gt;
&lt;li&gt;ダイナミックリンクライブラリも扱えるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SMLのファンクタに少し踏み込んだ</title>
      <link>http://keens.github.io/blog/2015/04/12/smlnofankutanisukoshifumikonda</link>
      <pubDate>Sun, 12 Apr 2015 19:49:41 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/12/smlnofankutanisukoshifumikonda</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;https://github.com/bleis-tift/SmlSharpContrib&#34;&gt;SmlSharpContrib&lt;/a&gt;にコントリビュートしてます。そこでファンクタを使う用事があったのですが少し踏み込んだ使い方をしようとしたらハマったのでメモ。&lt;/p&gt;

&lt;h1 id=&#34;ファンクタおさらい:921b7b3c7820999b28763bd2de5241d3&#34;&gt;ファンクタおさらい&lt;/h1&gt;

&lt;p&gt;SMLの&lt;code&gt;functor&lt;/code&gt;は&lt;code&gt;structure&lt;/code&gt;に引数がついたもので、モジュールを引数にとり、モジュールを返します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (Args : sig type elem end) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(struct type elem = int end)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;複雑なファンクタ:921b7b3c7820999b28763bd2de5241d3&#34;&gt;複雑なファンクタ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;blog/2015/01/31/mlyaccwotsukattemitehamattatokoro/&#34;&gt;以前mlyaccを使った時&lt;/a&gt;に&lt;code&gt;Join&lt;/code&gt;なる3つのモジュールを引数にとるファンクタが登場したのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの定義を覗いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数のモジュールの他に&lt;code&gt;sharing&lt;/code&gt;なるキーワードも出てきています。それに&lt;code&gt;structure&lt;/code&gt;キーワードもプリフィクスされています。&lt;/p&gt;

&lt;p&gt;先程の例とは大分離れてますね。何があったのでしょう。&lt;code&gt;structure&lt;/code&gt;を付けとけば複数書ける…？&lt;/p&gt;

&lt;h1 id=&#34;省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;省略記法&lt;/h1&gt;

&lt;p&gt;実はファンクタの引数の中では省略記法が使えます。引数のモジュール名と&lt;code&gt;sig ... end&lt;/code&gt;が省略可能なのです。さらに適用の時も&lt;code&gt;struct ... end&lt;/code&gt;も省略可能なのです。&lt;/p&gt;

&lt;p&gt;つまり、最初の例はこうも書けるのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (type elem) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(type elem = int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;モジュール内モジュールと省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;モジュール内モジュールと省略記法&lt;/h1&gt;

&lt;p&gt;そうです。複雑怪奇な&lt;code&gt;Join&lt;/code&gt;ファンクタは省略記法で書かれていたのでした。省略せずに書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(struct
     structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex
     end)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(X: sig
             structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token
             end)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。形式的には引数のモジュールは1つでありながら事実上複数のモジュールを渡していたのです。&lt;code&gt;structure&lt;/code&gt;が付いていたのはモジュール内モジュールだったから、&lt;code&gt;sharing&lt;/code&gt;はモジュール内モジュールに対する制約宣言です。&lt;/p&gt;

&lt;p&gt;なぜこれでハマったかというとSML#のインターフェースファイルでは省略記法が使えなかったからです。地雷の数だけ強くなれるよ♪&lt;/p&gt;

&lt;h1 id=&#34;参考:921b7b3c7820999b28763bd2de5241d3&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://walk.wgag.net/sml/module.html&#34;&gt;モジュール - ウォークスルー Standard ML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch11.S6.xhtml&#34;&gt;ファンクタのサポート in Ch.11. SML#分割コンパイルシステム in プログラミング言語SML#解説&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CyberAgentに入社しました</title>
      <link>http://keens.github.io/blog/2015/04/10/cyberagentninyuushashimashita</link>
      <pubDate>Fri, 10 Apr 2015 19:55:59 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/04/10/cyberagentninyuushashimashita</guid>
      <description>&lt;p&gt;κeenです。少し遅くなりましたが4/1付で所属が変わったので報告です。&lt;/p&gt;

&lt;p&gt;タイトルにあるように、株式会社サイバーエージェントに入社しました。こう言うとよく「あれ？サムライトじゃないの？」「もっとストイックな所に行くと思ってた」と言われます。サムライトについては特に関係はないです。エンジニア2人と知り合いなだけです。Common Lispだけが幸せの基準じゃありません。
それにキラキラ女子のイメージが強いかもしれませんがサイバーエージェント、結構ストイックですよ？&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/lXs96toe-B8&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;因みに昨日までで全体研修が終わり、月曜から技術研修が始まります。技術研修を受けずに早期配属される同期や果ては&lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1504/03/news134.html&#34;&gt;社長になる同期&lt;/a&gt;も居る中のんびり6月末まで研修を受けます。フロント周りはからっきしなのでこれを機にその辺も勉強しようかと。&lt;/p&gt;

&lt;p&gt;研修はグループワークが多かったのですが一緒のチームにいて優秀だなと思える人に何人も会ってきたしバックグラウンドを訊いてみて尖ってるエンジニアも一杯いたので正式配属されるのが楽しみです。私もそれなりに尖ってるつもりだったのですが精進が足りませんね。&lt;/p&gt;

&lt;p&gt;まあ、マイペースに歩んでいきます&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;よし、来年Clojureおじさんになろう&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/489246490724810752&#34;&gt;2014, 7月 16&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>誰がUTF-32が使われてないなんて言ったんだ</title>
      <link>http://keens.github.io/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</link>
      <pubDate>Tue, 31 Mar 2015 19:41:05 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</guid>
      <description>

&lt;p&gt;最近ではUTF-8でソースコードを書いてUTF-8で出入力をする。それ以外のエンコーディングは使われていない。…だと？誰がそんなこと言ったんだ&lt;/p&gt;

&lt;h1 id=&#34;asciiと古いunicodeと新しいunicode:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;ASCIIと古いUnicodeと新しいUnicode&lt;/h1&gt;

&lt;p&gt;少し長くなるが文字コードの話から始まる。ASCIIはお馴染み最低7bitあればASCIIの定義する文字集合を表せる。&lt;/p&gt;

&lt;p&gt;古いUnicodeは16bitで全ての文字を表わすことを目標に作られた。&lt;/p&gt;

&lt;p&gt;新しいUnicodeは文字(主に漢字)が多過ぎて16bitでは表せなかったので21bitに拡張された。&lt;/p&gt;

&lt;h1 id=&#34;文字コードとエンコーディング:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;文字コードとエンコーディング&lt;/h1&gt;

&lt;p&gt;文字コードをどういう形式で表すかがエンコーディングだ。文字コードが7bit、16bit、21bitだからといってそのままのサイズで表わす訳ではない。ASCIIは普通8bitの型で表わすし21bitの型を用意するよりは32bitの型に格納した方が扱い易そうだ。あるいは8bit型の配列に16bitや21bitを収めるとプログラムコードの変更が少なそうだ。&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8とUTF-16とUTF-32&lt;/h1&gt;

&lt;p&gt;さて、ここまで来ればお分かりだろう。UTF-8はASCIIとの互換性を保つ8bitベースのエンコーディング、UTF-16は古いUnicodeの時に作られて新しいUnicodeにも対応した16bitベースのエンコーディング、UTF-32は新しいUnicodeのために作られた32bitベースのエンコーディングだ。
ここで注意して欲しいのはUTF-8とUTF-16は8bitや16bitの単位を複数使うことで新しいUnicodeの範囲も扱える点、逆に言えば1単位が1文字に対応しない点だ。日本語を含んだ文字列に対して&lt;code&gt;length&lt;/code&gt;を使うと正しい結果が帰って来ないなどの経験は誰しもあるだろう&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32それぞれの特徴:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8とUTF-16とUTF-32それぞれの特徴&lt;/h1&gt;

&lt;h2 id=&#34;utf-8:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8&lt;/h2&gt;

&lt;p&gt;8bit(オクテット)の配列に文字列を収めることになる。16bitや21bitの範囲の文字を表す時は8bitに対してASCIIは7bitしか使わないのでその1bitを使って次に続くことを表わす。最大4オクテットまで使うことがある。 UTF-8の特徴はなんと言ってもASCIIとの互換性があること。UTF-8でASCIIの範囲のみの文字をエンコードするとASCIIと同一になるし、ASCIIでエンコードされたものはUTF-8で読んでも同じ内容になる。なのでどんなエンコードか分からないものはとりあえずUTF-8で読んでおくと間違いが少ない。よって冒頭で書いたように出入力、保存ファイル、GUIに表示する文字列などに使われる。&lt;/p&gt;

&lt;p&gt;UTF-8にも欠点はあり、ASCII外の文字を大量に扱うと空間効率が悪い。さらに先頭から順番に辿らないとどのオクテットが何文字目かも分からないので(配列長が既知であっても)文字列へのlengthやランダムアクセスなどの多くの操作がO(n)になってしまう点だ。文字の置換に至ってはin placeでは出来ないことすらある。&lt;/p&gt;

&lt;h2 id=&#34;utf-16:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-16&lt;/h2&gt;

&lt;p&gt;16bitの配列に文字列を収める。21bitまで扱うために特定の範囲の値が来たら次の16bitも読んで2つ併わせて1つの文字とみなす。このペアをサロゲートペアという。C言語には&lt;code&gt;wchar&lt;/code&gt;なるマルチバイト文字用の型があるが、仕様では最低で16bitという要求になっているのでwcharを使う時はUTF-16でエンコードする（と思う）。UTF-16もUTF-8と同じく文字列操作がO(n)になる。Unicode公式のエンコーディングであるという点を除いて特に良い点が見当たらないので後方互換性の必要な場面でないと使われてなさそうな気がする。例えばWindowsのファイルシステムはファイル名をUTF-16で保持しているらしい。&lt;/p&gt;

&lt;p&gt;尚、16bitのエンディアンは指定されてないのでファイルの先頭にバイトオーダーマーク(BOM)と呼ばれる空白文字を置いてそれでエンディアンを指定/判別する慣習になっている。&lt;/p&gt;

&lt;h2 id=&#34;utf-32:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-32&lt;/h2&gt;

&lt;p&gt;32bitの配列に文字列を収める。必ず32bitで1文字を表すので文字列操作が効率的に行なえる。欠点はASCIIの範囲の文字が多いとメモリを無駄にし易い点。どんな文字列を扱うか分からない(ASCIIの範囲が多いとは言い切れない)汎用ライブラリや言語処理系そのものでよく使われる。&lt;/p&gt;

&lt;h1 id=&#34;言語処理系の内部表現と外部エンコーディング:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;言語処理系の内部表現と外部エンコーディング&lt;/h1&gt;

&lt;p&gt;ここで罠になるのがソースコードをUTF-8で書いて出入力をUTF-8で行なう処理系でも内部では先述の理由でUTF-8以外を使うことがあることだ。メジャーな言語について少し調べてみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SBCL(Common Lispのメジャーな処理系)はUTF-32を使う&lt;/li&gt;
&lt;li&gt;SpiderMonkey(FirefoxのJavaScript処理系)はUTF-8を使う。HTMLはマルチバイト文字を使う言語で書かれていても大半がASCIIになるからとのこと。また、文字列をropeで表現しており、UTF-8のデメリットを軽減出来る。&lt;/li&gt;
&lt;li&gt;Rubyは多言語対応の時に内部表現はなんでもアリ(渡された文字列そのまま)になった&lt;/li&gt;
&lt;li&gt;PerlはUTF-8を使う&lt;/li&gt;
&lt;li&gt;PythonはconfigureのオプションでUCS2(ほぼUTF-16に同じ)やUCS4(UTF-32形式のUnicodeと概ね互換)が選べる。FedoraやUbuntuはUCS4でビルドしている&lt;/li&gt;
&lt;li&gt;PHPは言語で動的に変更出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ソースコードをUTF-8で書いて出入力をUTF-8で行なうから変換コストなんてないと思ったら大間違いだ。裏ではUTF-32が使われていて、出入力の度に変換が走る。誰がUTF-32が使われてないなんて言ったんだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lispエイリアンの矢印作った</title>
      <link>http://keens.github.io/blog/2015/03/03/lispeiriannoyajirushitsukutta</link>
      <pubDate>Tue, 03 Mar 2015 21:30:13 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/03/03/lispeiriannoyajirushitsukutta</guid>
      <description>&lt;p&gt;κeenです。勉強会などで役立ちそうなLispエイリアンの矢印を作りました。&lt;/p&gt;

&lt;p&gt;Lispエイリアンの元データは&lt;a href=&#34;http://www.lisperati.com/logo.html&#34;&gt;こちら&lt;/a&gt;でPNGやSVGで公開されているのでInkscapeの練習がてらそれをいじりました。&lt;/p&gt;

&lt;p&gt;どうぞ&lt;br /&gt;
&lt;img src=&#34;http://KeenS.github.io/images/lisplogo_alien_arrow.svg&#34; alt=&#34;lisplogo_alien_arrow.svg&#34; /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://KeenS.github.io/images/lisplogo_alien_arrow.svg&#34;&gt;lisplogo_alien_arrow.svg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ライセンスは元データに倣ってパブリックドメインとします。&lt;/p&gt;

&lt;p&gt;PNG形式のもの必要…ですか？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>面接でLispを口にして落ちない企業、私気になります！</title>
      <link>http://keens.github.io/blog/2015/02/10/mensetsudelispwokuchinishiteochinaikigyouwatashikininarimasu</link>
      <pubDate>Tue, 10 Feb 2015 08:01:35 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/02/10/mensetsudelispwokuchinishiteochinaikigyouwatashikininarimasu</guid>
      <description>

&lt;p&gt;κeenです。先日の記事がやたら拡散しました。その中で&lt;/p&gt;

&lt;p&gt;「面接でLispは口にしない方が良い。100%落ちる。」&lt;/p&gt;

&lt;p&gt;の一文がえらく気に入られたようです。Lispの風評被害を防ぐために1つアンケートにご協力下さい。&lt;/p&gt;

&lt;p&gt;このスプレッドシートです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1dUUOSpKqPK_tMqboxzAfPaL1eAEVwAdYy4AP_5HWeVw/edit?usp=sharing&#34;&gt;面接でLispを口にして落ちない企業調査表 - Google スプレッドシート&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;「うちの会社は面接でLispを口にしても落ちないぜ」って方はお手隙ならば書いて下さると嬉しいです。単純な興味目的のゆるふわなアンケートです。調査項目は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;会社名&lt;/li&gt;
&lt;li&gt;会社のURL&lt;/li&gt;
&lt;li&gt;書いた人(本名、スクリーンネーム、なんかのIDかは任意。IDにすると連絡がとれて便利かも)&lt;/li&gt;
&lt;li&gt;コメント、会社のアピールなど(長文可、任意)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;で。&lt;/p&gt;

&lt;p&gt;利用規約(？)は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;社員が書く。会社に全く書かない人は勝手に書かない。&lt;/li&gt;
&lt;li&gt;改竄を防ぐために一度書いたら同じ人しか編集してはいけない。同じ会社の人でもダメ。&lt;/li&gt;
&lt;li&gt;どっかのメディアに掲載されても怒らない。&lt;/li&gt;
&lt;li&gt;メディア側は改竄なしでリスト全部を引用し、引用した日時も付記する。あるいはURLにリンクを張る。二次引用は禁止する。&lt;/li&gt;
&lt;li&gt;問題が生じたら管理者(@blackenedgold)がこのスプレッドシートを非公開にする。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こんなもんですかね。ゆるふわアンケートなので書く側もゆるふわな気持でお願いします。&lt;/p&gt;

&lt;h1 id=&#34;補足:9e6d9857d06fd9b1ba5f4a8582464265&#34;&gt;補足&lt;/h1&gt;

&lt;h1 id=&#34;面接でlispは口にしない方が良い-100-落ちる-について補足:9e6d9857d06fd9b1ba5f4a8582464265&#34;&gt;「面接でLispは口にしない方が良い。100%落ちる。」について補足&lt;/h1&gt;

&lt;p&gt;振り返ってみるとそんなことはありませんでした。就活のある時点までは確かに真で、次の面接でLispを口にしなかったら落ちなかったのでそんなイメージになってました。
しかしよく考えたら私が内定頂いたところはむしろ全部Lispのおかげで内定頂きました。こっちの情報の方が大事だった。拝承。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>就活について思ったことをここに書き記す</title>
      <link>http://keens.github.io/blog/2015/02/07/shuukatsunitsuiteomottakotowokokonikakishirusu</link>
      <pubDate>Sat, 07 Feb 2015 14:27:58 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/02/07/shuukatsunitsuiteomottakotowokokonikakishirusu</guid>
      <description>

&lt;p&gt;私は今4年生なので去年の今頃は就活なんてものをしていた。下の代から若干日程が変わっているがそろそろ就活ムードが出てきているのでなんか吐いておく。思い出かもしれないし愚痴かもしれないし毒かもしれない。経験かもしれないし他人の代弁かもしれない。後輩の役に立つかもしれないし人事の方に向けたメッセージかもしれない。&lt;/p&gt;

&lt;p&gt;念のために書いておくが私はIT系の会社のプログラマ、エンジニア職ばかり応募していた。他の業界、職種に当て嵌まるとは限らない。&lt;/p&gt;

&lt;p&gt;注意&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;良かった企業は名前を出す、悪かった企業はここには名前を書かない方針にする。悪かった企業の具体名が知りたかったら&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt;に訊いて下さい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;リクナビ-メール:019fa2f68fcb27779e09f21baadfe988&#34;&gt;リクナビ、メール&lt;/h1&gt;

&lt;p&gt;周りの流れに乗せられてリクナビに登録することになる。個人情報を大量に打ち込む。すると大量のメールが届く。正直、情報量はゼロに近い。メールは受信しないにチェックした方が良い。&lt;/p&gt;

&lt;p&gt;リクナビの価値は3割くらいがポータルサイトとしての価値、残り7割くらいがリクナビ経由でしか募集してない企業にエントリーするためだけのもの。そういう企業にエントリーしないならリクナビにはあまり近寄らない方が良い。リクナビのサイトは非常に良く出来ていて、不安を煽る情報を的確に伝えてくる。本当にその辺の企業のサイトに爪の垢を煎じて飲ませてやりたいくらいに良く出来ている。&lt;/p&gt;

&lt;p&gt;一応何社かはリクナビ経由で知ってエントリーした。一々個人情報を手打することなくワンクリックでエントリー出来るのは負担を軽減してくれる。統一されたUIで情報を見れるのにはそれなりの価値はある。でもあまり齧りつきすぎると毒に冒される。2週間程放置しておくと「企業からの特別オファー」なる量産メッセージが1000通くらい溜まる。&lt;/p&gt;

&lt;p&gt;Twitterや勉強会で社員と知り合って採用情報などを得られるならそっちを頼った方が良い。Twitterに流れてくる情報の方が有用。&lt;/p&gt;

&lt;h1 id=&#34;説明会:019fa2f68fcb27779e09f21baadfe988&#34;&gt;説明会&lt;/h1&gt;

&lt;p&gt;エントリーに必須でない限り行かなかった。少なくともIT系企業ならWebページの採用情報が一番情報が充実して然るべきだ。&lt;/p&gt;

&lt;h1 id=&#34;マイページ-エントリーシート-性格診断:019fa2f68fcb27779e09f21baadfe988&#34;&gt;マイページ、エントリーシート、性格診断&lt;/h1&gt;

&lt;p&gt;リクナビ経由でエントリーしても結局は企業毎のマイページなるものに登録し、そこで情報を得ないといけない。エントリーシートの提出や面接の登録など。&lt;/p&gt;

&lt;h2 id=&#34;マイページ:019fa2f68fcb27779e09f21baadfe988&#34;&gt;マイページ&lt;/h2&gt;

&lt;p&gt;IT系の企業ならまずはそのマイページが評価基準になる。外注としても最低限のラインというのがある筈だ。マイページ登録にもまた個人情報を大量に打ち込む。まずエントリー時点でそこまで情報が必要なのか、とか大量の情報を入力させるに当たってどこまでUXを考えてるかとか。&lt;/p&gt;

&lt;h3 id=&#34;事例1-とあるグローバル人材を求める企業:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例1 とあるグローバル人材を求める企業&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;入力項目の説明に日本語と英語を併記していた。半分はゴミ情報なので酷く見づらかった&lt;/li&gt;
&lt;li&gt;最初に出身大学が国内か海外かのラジオボタンがあった。その次に出身大学を選ぶウィザードがあった。ウィザードの最初の質問は「出身大学は国内ですか？海外ですか？」のラジオボタン。&lt;/li&gt;
&lt;li&gt;住所と郵便番号も同じようなウィザードだった。住所をウィザードで選んでいくと郵便番号が自動で入力される。その次の項目は住所を手入力だった。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;事例2-yahoo-japan:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例2 Yahoo! JAPAN&lt;/h3&gt;

&lt;p&gt;具体的には覚えてないけど入力補完があった。郵便番号を入力すると住所も自動で入力された。一番使い易かった。&lt;/p&gt;

&lt;h3 id=&#34;事例3-ワークスアプリケーションズ-テクノロジスペシャリスト採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例3 ワークスアプリケーションズ テクノロジスペシャリスト採用&lt;/h3&gt;

&lt;p&gt;そもそもマイページは必要なかった。エントリーには2〜3個のフォーム入力と返信用のメールアドレスのみで良かった。最高。&lt;/p&gt;

&lt;p&gt;次にマイページの内容。クッキーを焼いて「こんにちはn回目の訪問ですね」なんてやってたら即切る。大抵対応ブラウザも書いてあるからそこも見る。モダンブラウザはサポート外とか言ってたら渋い顔になる。私の就活後半は丁度Windows XPのサポートが切れた時期なのでその辺でまだIE 6のサポートをしてたらやっぱり渋い顔になる。対応OSがWindowsとOS Xとか書いてたらキレる。IT系でLinuxユーザは相手にしないだと？&lt;/p&gt;

&lt;h2 id=&#34;エントリーシート:019fa2f68fcb27779e09f21baadfe988&#34;&gt;エントリーシート&lt;/h2&gt;

&lt;p&gt;割と企業の個性が出る。熱意とか意気込みとかはコピペなりでどうにでもなってしまうので適当に書く。そればっか訊いてくるところはエントリーをやめる。書くのに手間が書かるのにまともな基準で評価されてるか分からないから。簡単に詐称可能でしょ…&lt;/p&gt;

&lt;p&gt;これまでの実績とかを訊いてきたらGithubアカウントとかTwitterアカウントとかブログとか大会実績とか過去のLT資料とかを張る。興味のある分野を書く。大抵Markdown形式で書いたがどこもプレビューで改行エスケープをしてなかったので箇条書きが酷く見辛かった。字数は気にしない。&lt;/p&gt;

&lt;h2 id=&#34;性格診断:019fa2f68fcb27779e09f21baadfe988&#34;&gt;性格診断&lt;/h2&gt;

&lt;p&gt;最悪の体験。まず、Windows+IEかOS X+Safariにしか対応してない。単に対応してないだけじゃなくてご丁寧にUAを見てそれ以外を弾く。IT系ならLinuxユーザも居るだろうに。そして内容だが、似たような質問を何度も繰り返す。ただでさえWindowsを使わされてイライラさせられているのに更に追い討ちを掛けてくる。さっきも答えただろ、と悪態をつきながら地獄の20分に耐えることになる。SAN値がほぼ0になる。あれをやらせてる人事の方々は一回体験してみた方が良いと思いますよ。その上であの性格診断が必要か判断して下さい。どっかの企業で性格診断無視してたら普通にそのまま選考進んだ。マジで存在価値が分かならい。&lt;/p&gt;

&lt;h2 id=&#34;筆記試験:019fa2f68fcb27779e09f21baadfe988&#34;&gt;筆記試験&lt;/h2&gt;

&lt;p&gt;SPだっけ？IS？なんかそんなやつ。一回だけ受けた。さんすうとこくごの問題をひたすら解く。英語もあったっけ？覚えてないや。指定の会場じゃないと受けられないし順番待ちがあるしクソみたいな問題しか出ないし2回目は受けたくない。何の判断に使われるかもイマイチ分からない。必要ないなら止めて欲しい。&lt;/p&gt;

&lt;p&gt;それではなくて情報技術/科学に関する問題を出してきたところがあった。LINE。カバー範囲が広く、全ての問題に正当することは要求しない。回答を見て適正を決めて次の面接官を決めてたらしい。非常に良い。出来れば問題用紙を持ち帰らせてくれれば後学に使えたのにと思った。問題使い回してるのかな？&lt;/p&gt;

&lt;h2 id=&#34;プログラミング課題:019fa2f68fcb27779e09f21baadfe988&#34;&gt;プログラミング課題&lt;/h2&gt;

&lt;p&gt;課してくるところは少なかった。楽しいプログラミングかと思いきやそうでもなかった。&lt;/p&gt;

&lt;h3 id=&#34;事例1:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例1&lt;/h3&gt;

&lt;p&gt;言語指定があった。Java。しかもJavaで解くには凡そ不向きな問題。つながりのある複数の問題だったのに1問につき1ファイル指定で共通する機能をクラスに切り出すことも許されなかった。因みにお題は「共通化を考えながら解け」。&lt;/p&gt;

&lt;h3 id=&#34;事例2:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例2&lt;/h3&gt;

&lt;p&gt;仕様があいまいだった。「与えられた入力に対して」。入力はどう与えられるの？標準入力？コマンドライン引数？関数の引数？どれでも良いならそう書いて欲しい。さらに悪いことに時間指定があった。4時間。それは良いんだけど40分くらいで解いて提出したらログインセッションが切れてた。もう一回ログインしたらもう一回課題を受けれた。既に手元に回答は準備してあるので即座に提出したら普通に受理された。よくわからない。ちなみにその企業は唯一エントリーシートで落ちた。&lt;/p&gt;

&lt;h1 id=&#34;面接:019fa2f68fcb27779e09f21baadfe988&#34;&gt;面接&lt;/h1&gt;

&lt;p&gt;自分の話じゃないけどエントリーしまくってた友人は交通費で破産しかけてた。交通費は出してくれると嬉しいけど手続面倒だよねー。Skype面接とか？自分は近場の企業を、それも少数だけにしかエントリーしない方針で凌いだ。1つ落ちたら1つ新たにエントリーした。&lt;/p&gt;

&lt;p&gt;スーツはあまり着たくない。特にIT系なら勤務も私服だし面接も私服OKなところが多い。服装に言及がないとかスーツ必須とかだと悪目立ちする。服装に言及がないときは募集ページのプログラマが私服かどうかで判断していた。一回、募集ページは私服なのに面接官はスーツを着ていることがあった。面接だから、とのこと。学生相手にそこまで気を遣う必要はないと思うのだがお作法なのだろうか。あとエレベータホールまで見送りにきてさらにエレベータの扉が閉まるまで深々と御辞儀されるのも恐縮だ。&lt;/p&gt;

&lt;p&gt;内容はまあいいや。変な質問をされたことはない。こちら一人に対して面接官3人とか4人とかは圧迫感があって嫌だった。あ、一回「スクリプト言語でもディスクIOバウンドやネットワークIOバウンドなら高速なアプリケーションを書ける」と言ったら面接官に「は？」って言われたのが気になった。CPUバウンドじゃないならアーキテクチャの問題だからむしろアプリを簡単に書き換えられるLLで記述すべきでしょ。因みにその面接で落ちた。&lt;/p&gt;

&lt;p&gt;面接でLispは口にしない方が良い。100%落ちる。&lt;/p&gt;

&lt;p&gt;最後に質問はあるかと聞かれる。そんなものはない。エントリーした時点で公開情報で十分納得してある。内定が出たら即座に決めるつもりだ。もう情報は必要ない。面接が早く終われば授業に間に合うかもしれない。早く帰してくれ。聞ける場を用意してくれるのは非常に良いことなんだが質問の内容で評価するのは止めてほしい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;その他の事も色々言いたい。&lt;/p&gt;

&lt;h1 id=&#34;時間:019fa2f68fcb27779e09f21baadfe988&#34;&gt;時間&lt;/h1&gt;

&lt;p&gt;なんか大学生なんだから暇でしょみたいな雰囲気になってる。そんな訳はない。普通に授業がある。遊んでる大学生はごく一部だ。少なくともうちの大学だと遊べるのは1、2年までで3、4年からが勉強の本番になる。空き時間はレポートなりゼミの準備なりバイトなりサークルなりのために空けてある。面接と往復の時間を考えたら授業を1つ2つ犠牲にする必要がある。一応空いてる時間を訊いてくるがこちらが指定しても「それだとこちらが都合が悪いので他を指定して下さい」となって結局授業を潰すことになる。面接にしろ試験にしろ無駄なステップは省いて欲しい。学生の本分は勉強だ。&lt;/p&gt;

&lt;h1 id=&#34;時刻:019fa2f68fcb27779e09f21baadfe988&#34;&gt;時刻&lt;/h1&gt;

&lt;p&gt;機械送信のメッセージの他に手動で送られてくるメールや電話がある。あれの時間は結構気にする。まず、電話はやめて欲しい。電話で連絡取るにしても掛け直すときは前回とは時間帯をずらすとかしてほしい。学生なのだから毎日時間割ベースで活動している。電話をとれない時間帯は固定されている。前日と同じ、電話をとれない時間に電話が掛かってきたら正直バカなの？と思ってしまう。&lt;/p&gt;

&lt;p&gt;あと遅い時間や休日に連絡が来るとあまり良い顔にはならない。困る訳じゃなくて社員がその時間に活動しているということは残業や休出があるということだ。出来ればそういう会社は避けたい。&lt;/p&gt;

&lt;h1 id=&#34;ob訪問:019fa2f68fcb27779e09f21baadfe988&#34;&gt;OB訪問&lt;/h1&gt;

&lt;p&gt;ある企業でマイページ作ったらOB(というか同じ大学出身なだけの全く関係のない社員)と会う場をセッティングされそうになった。しかし相手は人事。話をしたいとしたらエンジニアだ。人事の方には興味はない。無駄な時間は使いたくない。&lt;/p&gt;

&lt;h1 id=&#34;エントリーする企業の決め方:019fa2f68fcb27779e09f21baadfe988&#34;&gt;エントリーする企業の決め方&lt;/h1&gt;

&lt;p&gt;Twitterや勉強会で知った人とかあるいは興味の湧くスライドを書いた人とかの会社を採用ページを見るところから始める。募集要項を見て気に入れば他のPRページも見る。気に入ればエントリーする。あとはGithub採用やってるところはとりあえず出す。他は名前知ってる有名企業とか。&lt;/p&gt;

&lt;p&gt;見るところは勤務形態の自由さ、年収、技術力。技術職なのだから自分の技術力を発揮出来てそれが評価されてまた仕事でスキルアップ出来る所が良い。&lt;/p&gt;

&lt;p&gt;自分の技術力を発揮出来るというのはつまらない規約で制限されないか。スーツ着用とかありえない。合理的理由が全くない。袖のボタンがキーボードに引っかかって作業し辛い。環境を自分の好きに選べるか。椅子、ディスプレイ、キーボード、OS、エディタ等々。バランスボールがオフィスにあると評価が上がる。&lt;/p&gt;

&lt;p&gt;評価されるというのは具体的には年収。札束で頬を引っ張たけばエンジニアは集まる。&lt;/p&gt;

&lt;p&gt;技術力は恐らく会社のWebページでは評価出来ない。中のエンジニアを勉強会で知った、スライドを見た、有名OSSのコミッタが居る、会社のGithubレポジトリの内容。鮎の友釣みたいにエンジニアを自由にさせておけば他のエンジニアも集まる。技術力を求めるのは自分のスキルアップという積極的な理由もあるし、クソコードをレビューしたくないという消極的な理由もある。&lt;/p&gt;

&lt;p&gt;割と年収が決め手だったりする。初任給は高く見えるように書いておいた方が良い。見た目は低くても手当てを入れると手取りがそれなりになるなら参考年収とかを書くと分かり易い。&lt;/p&gt;

&lt;p&gt;因みに会社の将来性は気にしてない。転職が盛んな職種なのだから傾いたら出ていく。&lt;/p&gt;

&lt;p&gt;正直経団連の企業は上の条件を満たしていそうにないので目も呉れてない。向こうも私のような人は求めてないだろうし多分棲み分けが出来てる。主にベンチャーを見ていた。&lt;/p&gt;

&lt;h1 id=&#34;コーディング面接:019fa2f68fcb27779e09f21baadfe988&#34;&gt;コーディング面接&lt;/h1&gt;

&lt;h2 id=&#34;事例1-1:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例1&lt;/h2&gt;

&lt;p&gt;面接で予告なくコーディングがあった。まあ、それは良い。与えられた環境はWindows XP + Eclipseだった。その時点で既にXPのサポートは切れてた。椅子蹴っ飛ばして帰ろうかと思った。一応受けたけどEmacs入ってないしqwertyだしjp配列だしCaps Lockのままだしなんか数分に1回警告が出て邪魔されるし最悪だった。環境固定はありえないなと思った。&lt;/p&gt;

&lt;h2 id=&#34;事例2-pixiv:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例2 pixiv&lt;/h2&gt;

&lt;p&gt;抜き打ちでホワイトボードコーディングをやった。リファレンスや補完が無くても書ける程度の問題だったし「多分この問題はここを訊いてると思うんですが…」「おぉ？！」とか盛り上がってたし楽しかった。シェル芸も披露した。上がり性の人にはつらいのかもしれないけど個人的には積極的にやって欲しい。&lt;/p&gt;

&lt;h2 id=&#34;事例3:019fa2f68fcb27779e09f21baadfe988&#34;&gt;事例3&lt;/h2&gt;

&lt;p&gt;採用フローにオンサイトのプログラミング試験があるところがあった。用意される環境はMac ProとJava 7とEclipseとJava 7のリファレンスだったかな？リファレンスが用意されてる時点でお察しと思うがインターネット接続禁止。なんでや。ググり力が一番大事でしょ。あと環境固定は最悪だって。それ見て受けるのやめた。&lt;/p&gt;

&lt;h1 id=&#34;github採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;Github採用&lt;/h1&gt;

&lt;p&gt;積極的にやってほしい。こちらの負担は軽いから。が、エンジニアへの負担がどれほどなのか分からない。あと(学部生なら)Githubを覚え始める頃と就活を始める頃が重なると思うので「これから伸びる」も考慮してくれると嬉しいなー。自分のGithubアカウントが充実し出したのは就活が終わってからだった。&lt;/p&gt;

&lt;p&gt;一定期間アカウントを観察して行動を見て決めるのなら期間を考えて欲しい。観察期間と試験期間が重なって観察期間中1コミットも出来ないことがあった。&lt;/p&gt;

&lt;p&gt;採用側のコストが低いなら一番推奨されるべき。&lt;/p&gt;

&lt;h1 id=&#34;プロコン採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;プロコン採用&lt;/h1&gt;

&lt;p&gt;あまり感心しない。&lt;a href=&#34;http://keens.github.io/blog/2014/12/18/saiensugaenziniaringu/&#34;&gt;前にもポエム書いた&lt;/a&gt;ようにあれはサイエンスであってエンジニアの採用に有用とは思わない。むしろプロコン採用をやってるところはその辺分かってなさそうで評価が下がる。勿論、動画コーデックの開発をしているドワンゴのようにそういう人材が実際に必要なところはその限りではない。そういうところは積極的にアピールしてくれると誤認が少なくて助かる。&lt;/p&gt;

&lt;p&gt;一応言うとプログラマの中から適性のあるプログラマを見出す方法としては感心しない、と言っている。プログラマ志望の中からプログラム書けるプログラマを見出す方法としてはアリなんじゃないですかね。世の中プログラムの書けないプログラマがどの程度居るのか分かりませんが。&lt;/p&gt;

&lt;h1 id=&#34;isucon-http-isucon-net-採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;&lt;a href=&#34;http://isucon.net&#34;&gt;ISUCON&lt;/a&gt;採用&lt;/h1&gt;

&lt;p&gt;めっちゃやって欲しい。インフラ系の即戦力って結構稀だと思います。はい。&lt;/p&gt;

&lt;p&gt;因みに私は1件だけオファーがありました。その頃は自分にそのオファーに見合うだけの技術があるとは思ってなくて、深く考えずに断っちゃいましたけど。今考えるとそこで内定貰って「ISUCONで内定貰ったぜ！ヒャッハ〜」って言ってれば流れ変わったのかな。&lt;/p&gt;

&lt;h1 id=&#34;アカリク-https-acaric-jp-採用:019fa2f68fcb27779e09f21baadfe988&#34;&gt;&lt;a href=&#34;https://acaric.jp/&#34;&gt;アカリク&lt;/a&gt;採用&lt;/h1&gt;

&lt;p&gt;自分は行ってないけどめっちゃ良さそう。推奨されるべき。&lt;/p&gt;

&lt;h1 id=&#34;インターン:019fa2f68fcb27779e09f21baadfe988&#34;&gt;インターン&lt;/h1&gt;

&lt;p&gt;一番毒吐きたいところ。&lt;/p&gt;

&lt;p&gt;優秀な学生をインターンで獲得すると言っている企業をちらほら見掛ける。ふざけている。優秀な学生がインターンをしてる暇があると思ってるのか？やはりここにも学生なんだから暇でしょという雰囲気を感じる。&lt;/p&gt;

&lt;p&gt;参考に普通の学生たる私の3年生の時の夏休みの日程を挙げる。8月1日から強化錬、間を空けずに合宿、2日休んで合宿、すぐさま試験準備、試験、直後に帰省。東京に戻ってきたのは9月30日。夏休み中の休みは合宿の合間の2日のみ。&lt;/p&gt;

&lt;p&gt;色々突っ込みたいだろうが予想されるものには反論しておく。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;夏休みの真ん中に試験がある大学にいるのが悪い
: これは私からはどうしようもない。高校生の時にそこまで考える人はいないだろう。悪いというならうちの大学を切り捨てればいい。1学年3000人居る。因みに私は夏休みの前半はサークルに勤しんでいたが本来ならそれら全てを試験勉強に充てる。お察しの通り私の試験の出来は良くなかった。その期間にインターンに行きたがる人はそう多くないだろう。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;サークル3つやってるのが悪い
: 私の場合サークルばかりだが他の人でもサークルの他にバイト2つ3つ掛け持ちとかはザラにある。しかもその内の少なくとも1つは大抵教育系なので夏期講習で忙しい。夏期講習で働けなかった分の皺寄せで他のバイトも日程がつまる。夏休みに知人に会うと10連勤明けで死んだ目をしている。サークルやバイトの他にも高校の部活絡みだとか学外活動だとか要因は色々ある。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;就活のためならサークルを犠牲にすればいい
: 副将をやってるとそうもいかない。参加者ではなく主催者になる。それとも主催者の責務を放り出すような人を採りたいのか？副将になったのが悪いという批判も当を得てない。なぜならサークルの同期は9人いて3人が主副将になる。1/3だ。流石に1/3が外れ値と言う人はいないだろう。それに優秀な人こそ責任者になりやすい筈だ。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;インターンでお金貰えるんだからバイトは辞めるなり休むなりすれば良いのでは
: そうも言ってられない。最近のバイトは中々辞めさせてくれないし、休むと言っても勝手にシフトを入れてくる。辞めるには1ヶ月、2ヶ月前に辞意を伝えておかないといけない。インターンにも選考はある訳で、確実に行けると決まるのは夏休み直前だったりする。あるか無いか分からないもののためにリスクは冒したくない。それに一時収入のために定常収入を失う訳にはいかない。辞めるかも、なんて言葉が勝手にシフトを入れてくるような所に通用する訳がない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;帰省は個人の都合では
: そうでもない。多くの大学生は親の扶養下にある。定期的に家族に挨拶をしないと東京で生かしてもらえない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空きの2日を使ってインターンに行けば良いのでは
: インターンが2日で済むのは文系の話だ。理系ならば最低でも2週間、普通1ヶ月。2ヶ月のものもよく見掛ける。学んで動いて成果を出すには2日は短かすぎる。空きの2日どころか合宿をすっぽかしたところでインターンには行けない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;普通の学生じゃなくて優秀な学生の話をしているんだ
: 確かに。ここに書いたのは普通の学部生の日程だ。しかし優秀な人は他人より多くのことをこなすから優秀なのではないか？ならば優秀な人はさらに忙しいのではないか？私の周りの(私が思う)優秀な人は忙しそうにしている。忙しいとは言ってないが暇と言ってるのは見たことない。
院生のスケジュールは研究室次第だろう。何とも言えない。やる事やってるなら他は関知しない、というところもあれば夏休みにもコアタイムのある研究室もあると聞く。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;勿論、ここに書いたことが全ての学生に当て嵌る訳ではない。中には夏休みに時間のある人もいる。だがその人がインターンに行くか、という問題もある。優秀な人は優れた指導教官の下に居る筈だ。その指導教官の下を離れてまでインターンに行く価値があるか。あるいは優秀ならば指導教官がいなくても自ら学べる人は多い。本人の自主学習速度を上回る体験を提供出来るか。優秀な人は職が欲しいなら先のアカリクなどで座して待つだけでやってくる。内定直結は別に魅力ではない。&lt;/p&gt;

&lt;p&gt;私がここまで毒を吐いたのはインターンそのものではない。時間のある学生を集めてインターンを開きたいならそれはそれで良し。両者得をすることがあるだろう。毒を吐いているのはインターンで優秀な学生を獲得すると言っている企業、採用プロセスにインターンを組み込む企業だ。少数、時間のある優秀な学生もいるだろうが多くの優秀な人を自らフィルタしていることに気付かないのか。&lt;/p&gt;

&lt;h1 id=&#34;最後に:019fa2f68fcb27779e09f21baadfe988&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;常体で書いた上に普段使わない汚ない言葉遣い、自分の価値観に合わないものを全力で否定する内容だったので酷く毒毒しいエントリになってしまった。飽くまで個人の日記で毒を吐いただけなので皆さんマジレスしないで下さいね。&lt;/p&gt;

&lt;p&gt;企業は利益のために採用活動をするのに対して大学生はその露命をつなぐために就職活動をする。立場上も身分上も大学生が下手に出るべきだが上から目線な記述が散見される。ここは一つ個人の日記ということで赦して下さい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>