<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on κeenのHappy Hacκing Blog</title>
    <link>/post/index.xml</link>
    <description>Recent content in Post-rsses on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sat, 24 Dec 2016 22:51:46 +0900</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rustのライフタイムを使ったスコープ解析</title>
      <link>/blog/2016/12/24/rustnoraifutaimuwotsukattasuko_pukaiseki</link>
      <pubDate>Sat, 24 Dec 2016 22:51:46 +0900</pubDate>
      
      <guid>/blog/2016/12/24/rustnoraifutaimuwotsukattasuko_pukaiseki</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;の25日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。大トリに小ネタで申し訳ないのですが最近書いたコードでちょっと便利だなと思ったテクニックを紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;次のような言語のインタプリタを作ることを考えます。意味論はエスパーして下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 1
y = 2
println(&amp;quot;x = &amp;quot;, x)
println(&amp;quot;y = &amp;quot;, y)

println(&amp;quot;--&amp;quot;)

{
    x = 3
    println(&amp;quot;x = &amp;quot;, x)
    println(&amp;quot;y = &amp;quot;, y)
}

println(&amp;quot;--&amp;quot;)

println(&amp;quot;x = &amp;quot;, x)
println(&amp;quot;y = &amp;quot;, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この実行結果は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になりますね。このインタプリタをRustで作りましょう。&lt;/p&gt;

&lt;h1 id=&#34;初期実装&#34;&gt;初期実装&lt;/h1&gt;

&lt;p&gt;雛形はこんなもんでしょうか。後でリファレンスが出てきてややこしくなるので値は全て所有権を貰っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Debug, Clone)]
struct AST(Vec&amp;lt;Stmt&amp;gt;);

#[derive(Debug, Clone)]
enum Stmt {
    Subst(String, Expr),
    Print(Vec&amp;lt;Expr&amp;gt;),
    Block(Vec&amp;lt;Stmt&amp;gt;),
}


#[derive(Debug, Clone)]
enum Expr {
    Str(String),
    Num(isize),
    Var(String),
}


struct Interpreter {
    // これを実装する
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{}
    }

    fn run(&amp;amp;mut self, ast: AST) {
        for stmt in ast.0 {
            self.run_stmt(stmt);
        }
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        // これを実装する
    }
}

fn main() {
    let ast = {
        use Stmt::*;
        use Expr::*;
        AST(
            vec![
                Subst(&amp;quot;x&amp;quot;.to_string(), Num(1)),
                Subst(&amp;quot;y&amp;quot;.to_string(), Num(2)),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Block(vec![
                    Subst(&amp;quot;x&amp;quot;.to_string(), Num(3)),
                    Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                    Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                ]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
            ]
        )
    };
    let mut interpreter = Interpreter::new();

    interpreter.run(ast);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(コンストラクタ関数作っときゃよかったかも)&lt;/p&gt;

&lt;p&gt;今回の本質ではないのでパーサは用意してません。&lt;/p&gt;

&lt;p&gt;さて、とりあえずのところ変数の管理のためにシンボルテーブルが必要です。実装しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;//...

use std::collections::HashMap;
struct Interpreter {
    symbol_table: HashMap&amp;lt;String, Expr&amp;gt;,
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{
            symbol_table: HashMap::new(),
        }
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        self.symbol_table.insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        self.symbol_table
            .get(name)
            .expect(&amp;quot;reference to unknown variable&amp;quot;)
            .clone()
    }

  //...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡略化のためにcloneやpanicしてますがご愛嬌。&lt;/p&gt;

&lt;p&gt;これがあれば&lt;code&gt;run_stmt&lt;/code&gt;のそれっぽい実装は出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            Subst(name, expr) =&amp;gt; {
                let expr = self.eval(expr);
                self.add_to_scope(name, expr);
            },
            Print(exprs) =&amp;gt; {
                for expr in exprs {
                    self.print_expr(expr);
                }
                println!(&amp;quot;&amp;quot;);
            },
            Block(stmts) =&amp;gt; {
                for stmt in stmts {
                    self.run_stmt(stmt);
                }
            },
        }

    }

    fn eval(&amp;amp;self, expr: Expr) -&amp;gt; Expr {
        use Expr::*;
        match expr {
            Var(v) =&amp;gt; self.find_scope(&amp;amp;v),
            e @ Str(_) |
            e @ Num(_) =&amp;gt; e
        }
    }

    fn print_expr(&amp;amp;self, expr: Expr) {
        use Expr::*;
        match self.eval(expr) {
            Str(ref s) =&amp;gt; print!(&amp;quot;{}&amp;quot;, s),
            Num(ref n) =&amp;gt; print!(&amp;quot;{}&amp;quot;, n),
            Var(_) =&amp;gt; panic!(&amp;quot;reference to unknown variable&amp;quot;) ,
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、これを走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 3
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコープを実装していないので最後の&lt;code&gt;x&lt;/code&gt;が3になっていますね。スコープを実装しましょう。&lt;/p&gt;

&lt;p&gt;スコープを実装するには簡単にはハッシュテーブルを複数持てば良さそうです。
3段にネストしたスコープなら3つのハッシュテーブルを持ちます。
そしてスコープを抜けた時にそのスコープに対応するハッシュテーブルを消せば（忘れれば）良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Interpreter {
   // スコープに対応したテーブル達。
   symbol_tables: Vec&amp;lt;HashMap&amp;lt;String, Expr&amp;gt;&amp;gt;,
   // 今どのスコープを指しているか。
   // スコープを抜けてもベクトルは縮まないのでこれが必要。
   pos: usize,
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        // 新しいフィールドの初期化
        Interpreter{
            symbol_tables: Vec::new(),
            // ややこしくなるが、0で初期化しているのでpos-1番目のハッシュマップが現スコープのテーブルになる
            pos: 0,
        }
    }

    // スコープに入る処理。
    fn in_scope(&amp;amp;mut self) {
        let pos = self.pos;
        // スコープから抜けてもハッシュマップは消えないので
        // 入る → 出る → 入るをしたときに既にテーブルがある場合が出てくる。
        // 必要なテーブルが既にある場合とない場合で条件分岐
        if self.symbol_tables.len() &amp;lt;= pos {
            self.symbol_tables.push(HashMap::new())
        } else {
            // 既にテーブルがある場合は古い情報を消す
            self.symbol_tables[pos - 1].clear()
        }
        // ポジションは忘れずインクリメント
        self.pos += 1;
    }

    // スコープから抜ける処理
    fn out_scope(&amp;amp;mut self) {
        // スコープから抜けるのはデクリメントのみでOK
        self.pos -= 1;
    }

    pub fn run(&amp;amp;mut self, ast: AST) {
        // in_scope が増えた
        self.in_scope();
        for stmt in ast.0 {
            self.run_stmt(stmt);
        }
        // out_scope が増えた
        self.out_scope();
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        // 現在のスコープに変数を入れる
        let pos = self.pos - 1;
        self.symbol_tables[pos].insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        let pos = self.pos;
        // 一番内側(現在)のスコープから外側のスコープの順に調べていく。
        // `[0..pos]` や `rev()` に注意。
        for table in self.symbol_tables[0..pos].iter().rev() {
            if let Some(e) = table.get(name) {
                return e.clone()
            }
        }
        // どこにもなければ未定義変数
        panic!(&amp;quot;reference to unknown variable&amp;quot;)
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            // ..
            Block(stmts) =&amp;gt; {
                // in_scope が増えた
                self.in_scope();
                for stmt in stmts {
                    self.run_stmt(stmt);
                }
                // out_scope が増えた
                self.out_scope();
            },
        }

    }

    // ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで走らせてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。動きました。&lt;/p&gt;

&lt;h1 id=&#34;scope-の導入&#34;&gt;&lt;code&gt;Scope&lt;/code&gt; の導入&lt;/h1&gt;

&lt;p&gt;さて、上のコードでは&lt;code&gt;in_scope&lt;/code&gt;と&lt;code&gt;out_scope&lt;/code&gt;が対で現れました。というか現れないといけません。
でもプログラミングエラーで&lt;code&gt;out_scope&lt;/code&gt;を忘れるなんてことはよくある話です（現に私はこのサンプルを書いてて間違えかけました）。これをRustのライフタイムの仕組みに乗っけて自動で解決しようというのが今回のお話。&lt;/p&gt;

&lt;p&gt;手法は簡単で、とりあえず&lt;code&gt;Scope&lt;/code&gt;という型を用意します。そして&lt;code&gt;new&lt;/code&gt;する時に&lt;code&gt;in_scope&lt;/code&gt;を呼んであげて、&lt;code&gt;drop&lt;/code&gt;する時に&lt;code&gt;out_scope&lt;/code&gt;を呼んであげます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::Drop;
struct Scope&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a mut Interpreter);

impl &amp;lt;&#39;a&amp;gt;Scope&amp;lt;&#39;a&amp;gt; {
    fn new(inpr: &amp;amp;&#39;a mut Interpreter) -&amp;gt; Self {
        inpr.in_scope();
        Scope(inpr)
    }
}

impl &amp;lt;&#39;a&amp;gt;Drop for Scope&amp;lt;&#39;a&amp;gt; {
    fn drop(&amp;amp;mut self) {
        self.0.out_scope()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この&lt;code&gt;&amp;amp;mut Interpreter&lt;/code&gt;で参照しているというのが丁度良くて、Scopeの分岐というのを防ぐことが出来ます。こういうやつですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let scope1 = Scope::new(&amp;amp;mut intr);
let scope2 = Scope::new(&amp;amp;mut intr); // error: 既に&amp;amp;mut されている変数は&amp;amp;mut出来ない
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、これを使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    pub fn run(&amp;amp;mut self, ast: AST) {
        // in_scopeをScope::new()に置き換えた
        let scope = Scope::new(self);
        for stmt in ast.0 {
            // scopeに渡してしまったのでselfはsope.0で参照する必要がある
            scope.0.run_stmt(stmt);
        }
        // out_scopeは自動で呼ばれる
    }

    // run_stmtのBlockも同様に書き換える
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きました。でも、あまり&lt;code&gt;scope.0&lt;/code&gt;なんて使いたくないですよね。出来れば透過的に扱いたい。
そんなときのために&lt;code&gt;Deref&lt;/code&gt; と &lt;code&gt;DerefMut&lt;/code&gt; です。Rustは型が合わなければ自動で&lt;code&gt;deref&lt;/code&gt;を呼んでくれます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Deref&lt;/code&gt; と &lt;code&gt;DerefMut&lt;/code&gt; を実装しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::{Deref, DerefMut};
impl &amp;lt;&#39;a&amp;gt; Deref for Scope&amp;lt;&#39;a&amp;gt; {
    type Target = Interpreter;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Interpreter {
        self.0
    }
}

impl &amp;lt;&#39;a&amp;gt; DerefMut for Scope&amp;lt;&#39;a&amp;gt; {
    fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Interpreter {
        self.0
    }
}

impl Interpreter {
    // ..

    pub fn run(&amp;amp;mut self, ast: AST) {
        // deref_mutするために mutをつける
        let mut scope = Scope::new(self);
        for stmt in ast.0 {
            // scope.0しなくてもInterpreterのメソッドが呼べる
            scope.run_stmt(stmt);
        }
    }

   // ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;生成と消滅が対になるものはRustのオブジェクトで管理出来るよ&lt;/li&gt;
&lt;li&gt;シンプルなラッパー型は&lt;code&gt;Deref&lt;/code&gt;や&lt;code&gt;DerefMut&lt;/code&gt;を実装しておくと便利だよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/drop.html&#34;&gt;Drop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/deref-coercions.html&#34;&gt;&lt;code&gt;Deref&lt;/code&gt; による型強制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;付録a&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;最終的なソースコード全文を掲載します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Debug, Clone)]
struct AST(Vec&amp;lt;Stmt&amp;gt;);

#[derive(Debug, Clone)]
enum Stmt {
    Subst(String, Expr),
    Print(Vec&amp;lt;Expr&amp;gt;),
    Block(Vec&amp;lt;Stmt&amp;gt;),
}


#[derive(Debug, Clone)]
enum Expr {
    Str(String),
    Num(isize),
    Var(String),
}


use std::collections::HashMap;
struct Interpreter {
   symbol_tables: Vec&amp;lt;HashMap&amp;lt;String, Expr&amp;gt;&amp;gt;,
   pos: usize,
}

use std::ops::{Drop, Deref, DerefMut};
struct Scope&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a mut Interpreter);

impl &amp;lt;&#39;a&amp;gt;Scope&amp;lt;&#39;a&amp;gt; {
    fn new(inpr: &amp;amp;&#39;a mut Interpreter) -&amp;gt; Self {
        inpr.in_scope();
        Scope(inpr)
    }
}

impl &amp;lt;&#39;a&amp;gt;Drop for Scope&amp;lt;&#39;a&amp;gt; {
    fn drop(&amp;amp;mut self) {
        self.0.out_scope()
    }
}

impl &amp;lt;&#39;a&amp;gt; Deref for Scope&amp;lt;&#39;a&amp;gt; {
    type Target = Interpreter;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Interpreter {
        self.0
    }
}

impl &amp;lt;&#39;a&amp;gt; DerefMut for Scope&amp;lt;&#39;a&amp;gt; {
    fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Interpreter {
        self.0
    }
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{
            symbol_tables: Vec::new(),
            pos: 0,
        }
    }

    fn in_scope(&amp;amp;mut self) {
        let pos = self.pos;
        if self.symbol_tables.len() &amp;lt;= pos {
            self.symbol_tables.push(HashMap::new())
        } else {
            self.symbol_tables[pos - 1].clear()
        }
        self.pos += 1;
    }

    fn out_scope(&amp;amp;mut self) {
        self.pos -= 1;
    }

    pub fn run(&amp;amp;mut self, ast: AST) {
        let mut scope = Scope::new(self);
        for stmt in ast.0 {
            scope.run_stmt(stmt);
        }
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        let pos = self.pos - 1;
        self.symbol_tables[pos].insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        let pos = self.pos;
        for table in self.symbol_tables[0..pos].iter().rev() {
            if let Some(e) = table.get(name) {
                return e.clone()
            }
        }
        panic!(&amp;quot;reference to unknown variable&amp;quot;)
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            Subst(name, expr) =&amp;gt; {
                let expr = self.eval(expr);
                self.add_to_scope(name, expr);
            },
            Print(exprs) =&amp;gt; {
                for expr in exprs {
                    self.print_expr(expr);
                }
                println!(&amp;quot;&amp;quot;);
            },
            Block(stmts) =&amp;gt; {
                let scope = Scope::new(self);

                for stmt in stmts {
                    scope.0.run_stmt(stmt);
                }
            },
        }

    }

    fn eval(&amp;amp;self, expr: Expr) -&amp;gt; Expr {
        use Expr::*;
        match expr {
            Var(v) =&amp;gt; self.find_scope(&amp;amp;v),
            e @ Str(_) |
            e @ Num(_) =&amp;gt; e
        }
    }

    fn print_expr(&amp;amp;self, expr: Expr) {
        use Expr::*;
        match self.eval(expr) {
            Str(ref s) =&amp;gt; print!(&amp;quot;{}&amp;quot;, s),
            Num(ref n) =&amp;gt; print!(&amp;quot;{}&amp;quot;, n),
            Var(_) =&amp;gt; panic!(&amp;quot;reference to unknown variable&amp;quot;) ,
        }
    }
}

fn main() {
    let ast = {
        use Stmt::*;
        use Expr::*;
        AST(
            vec![
                Subst(&amp;quot;x&amp;quot;.to_string(), Num(1)),
                Subst(&amp;quot;y&amp;quot;.to_string(), Num(2)),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Block(vec![
                    Subst(&amp;quot;x&amp;quot;.to_string(), Num(3)),
                    Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                    Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                ]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
            ]
        )
    };
    let mut interpreter = Interpreter::new();

    interpreter.run(ast);
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Rustの所有権、ライフタイム、参照、型、しがらみ</title>
      <link>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</link>
      <pubDate>Wed, 14 Dec 2016 11:19:12 +0900</pubDate>
      
      <guid>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</guid>
      <description>&lt;p&gt;κeenです。Rustには所有権やらライフタイムやら参照やらがあって型システムが面倒ですよね。線形（アフィン）と言われてるのに「あれ？」と思う部分もあるので詳しく探っていこうと思います。&lt;/p&gt;

&lt;p&gt;尚、この記事は型システムに興味のある人向けです。単にRustを書きたい方に有用な情報があるかは分かりません。&lt;/p&gt;

&lt;p&gt;2016-212-14T15:28Z09:00 加筆訂正しました。diffは&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/commit/f86c03a3793fde1787a9c0eb47f8efda305c2be4&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;線形型-アフィン型&#34;&gt;線形型？アフィン型？&lt;/h1&gt;

&lt;p&gt;はじめにこの辺をハッキりさせておきたいです。
アフィン型は線形型に弱化規則を許す型です。
プログラミング的に言えば線形型は &lt;code&gt;free&lt;/code&gt; しないと型エラーになるけどアフィン型はそうでない。
Rustはご存知の通り &lt;code&gt;free&lt;/code&gt; 相当のものを手で書くことはないのでアフィンな気がしますし、昔のドキュメントにもそう書いてました。&lt;/p&gt;

&lt;p&gt;しかし実際に実行されるプログラムではコンパイラが差し込んだ &lt;code&gt;free&lt;/code&gt; が実行されるので &lt;code&gt;free&lt;/code&gt; を省略出来るというシンタックスシュガーの類な気もします。&lt;/p&gt;

&lt;p&gt;ただまあ、 &lt;code&gt;free&lt;/code&gt; を差し込む位置を特定するのに弱化規則を使った場所で推論している筈なのでアフィンを使ってる筈ですよね。&lt;/p&gt;

&lt;p&gt;ってことで今回の記事はアフィン型で統一したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;参照も値&#34;&gt;参照も値&lt;/h1&gt;

&lt;p&gt;なんとなく、構文が用意されているので参照自体特別な存在な気がしますが、そんなことはありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_any&amp;lt;T&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように任意の値を取れる関数を用意してあげます。
すると、以下のように所有、参照、可変参照全て渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let mut s = take_any(s);
take_any(&amp;amp;s);
take_any(&amp;amp;mut s);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;は-copy-mut-は違う&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; は違う&lt;/h1&gt;

&lt;p&gt;先と同じように &lt;code&gt;Copy&lt;/code&gt; を実装した型を受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_copy&amp;lt;T: Copy&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに参照を渡してあげると、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
take_copy(&amp;amp;s);
take_copy(&amp;amp;mut s); // error[E0277]: the trait bound `&amp;amp;mut std::string::String: std::marker::Copy` is not satisfied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、 &lt;code&gt;Copy&lt;/code&gt; なので普通に何度も使えます。線形型でいう &lt;code&gt;!&lt;/code&gt; に近いですね。違いますけど。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let ref_s = &amp;amp;s;
let x: &amp;amp;String = ref_s;
let y: &amp;amp;String = ref_s;
// Copy(が要求するClone)に実装されているメソッドを陽に呼ぶ
let z: &amp;amp;String = (&amp;amp;ref_s).clone();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、 &lt;code&gt;Copy&lt;/code&gt; への参照は参照外しが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x: isize = 1;
let ref_x = &amp;amp;x;
let x: isize = *x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; は &lt;code&gt;&amp;amp;&lt;/code&gt; への参照（&lt;code&gt;Copy&lt;/code&gt;への参照）なので &lt;code&gt;&amp;amp;&lt;/code&gt; へ参照外しが可能ですが、 &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; は&lt;code&gt;&amp;amp;mut&lt;/code&gt;への参照（&lt;code&gt;Copy&lt;/code&gt;ではない値への参照）なので参照外し出来ません。&lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; とややこしいですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
// &amp;amp;&amp;amp;
{
    let ref_ref_s = &amp;amp;&amp;amp;s;
    let ref_s: &amp;amp;String = *ref_refs;
}
// &amp;amp;mut &amp;amp;
{
    let refmut_ref_s = &amp;amp;mut &amp;amp; s;
    let reft_s: &amp;amp;String = *s;
}

// &amp;amp;&amp;amp;mut
{
    let ref_refmut_s = &amp;amp;&amp;amp;mut s;
    let refmut_s: &amp;amp;mut String = *s; // error[E0389]: cannot borrow data mutably in a `&amp;amp;` reference
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;T&lt;/code&gt; が &lt;code&gt;&amp;amp;T&lt;/code&gt; に参照外し出来る理由も分かったかと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-は-deref&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; は &lt;code&gt;Deref&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がたまに &lt;code&gt;&amp;amp;&lt;/code&gt; のように振る舞うことがありますが、これは &lt;code&gt;Deref&lt;/code&gt; のせいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::Deref;

let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
{
    // derefを陽に呼ぶ
    let ref_s: &amp;amp;string = refmut_s.deref();
}

{
    // 暗黙のDerefによる型強制
    let ref_s: &amp;amp;string = refmut_s;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rustは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/deref-coercions.html&#34;&gt;&lt;code&gt;deref&lt;/code&gt; による型強制&lt;/a&gt;を行うため、無言で &lt;code&gt;&amp;amp;mut&lt;/code&gt; を &lt;code&gt;&amp;amp;&lt;/code&gt; に変換することが出来ます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、ここまでで &lt;code&gt;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&lt;/code&gt; もただの値であること、アフィン型に反しないことを調べました。
次はライフタイムについて探ります。&lt;/p&gt;

&lt;h1 id=&#34;ライフタイムとサブタイピング&#34;&gt;ライフタイムとサブタイピング&lt;/h1&gt;

&lt;p&gt;実は、Rustにはサブタイピングがあります。ライフタイムです。ライフタイムにはサブタイプ関係があるのです。&lt;/p&gt;

&lt;p&gt;このように、2つの引数が厳密に同じライフタイムであることを要求する関数を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_ref&amp;lt;&#39;a&amp;gt;(_: &amp;amp;&#39;a String, _: &amp;amp;&#39;a String) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに、違うライフタイムを持つ型を放り込んでみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
    let a = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;a;
    {
        let b = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;b;
        take_two_ref(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはコンパイルが通ります。明示的にライフタイムを書くとこうです。これは有効な構文ではないです（余談ですがラベル付きbreak文のための構文と衝突します）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {
    let a: &#39;a String = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;&#39;a a;
    &#39;b: {
        let b: &#39;b String = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;&#39;b b;
        take_two_ref::&amp;lt;&#39;b&amp;gt;(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大は小を兼ねるので &lt;code&gt;&#39;a&lt;/code&gt; は &lt;code&gt;&#39;b&lt;/code&gt; のサブタイプになっています。
ちょっと言葉がややこしいのですが、スコープが狭いライフタイムの方が大きい型です。狭い方が大きい。この言い回しに馴れてない人に説明すると、上の例でいえば &lt;code&gt;&#39;b&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; と &lt;code&gt;&#39;b&lt;/code&gt; 2つありますが、 &lt;code&gt;&#39;a&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; だけです。 2つと1つだったら2つの方が大きいですよね。&lt;/p&gt;

&lt;p&gt;さて、今回の例ではちゃんとスコープの入れ子とサブタイプ関係が一致していました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {----------
              |
              |
    &#39;b: {--   |
          |   |
          |   |
          |   |
    }------   |
}--------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参照を取るときは参照のライフタイムが元のライフタイムのサブタイプになっている必要があります。&lt;/p&gt;

&lt;p&gt;この関係に反するとエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();
    ref_s = &amp;amp;s; // error: `s` does not live long enough
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;図示するとこうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();-----
    ref_s = &amp;amp;s; ----------------  |
                               |  |
}------------------------------+---
                               |
--------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ライフタイムといえどある種、型なんですね。余談ですが確かリージョンの論文には「リージョンはプログラム全体を静的に伝播する型のようなもの」と表現していた気がします。既存の型と直行するので型とは別とも言えますし、タプルのように両方並べたものを型と言うことも出来ますね。&lt;/p&gt;

&lt;h1 id=&#34;所有型とライフタイムと-static&#34;&gt;所有型とライフタイムと &lt;code&gt;&#39;static&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;適切な語彙がなかったので勝手に所有型と名付けましたが、参照でない型のことを指しています。（先の例で見せた通り、参照型にも所有権はあるので適切ではないですがひとまず我慢して下さい。）&lt;/p&gt;

&lt;p&gt;さて、なんとなくライフタイムと参照型は結び付いている気がしますが、参照じゃない型にもライフタイムはあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_value&amp;lt;&#39;a, T: &#39;a, S: &#39;a&amp;gt;(_: T, _: S){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、任意の2つの型を取るけども両方ともにライフタイムを要求する関数を書いてみます。&lt;/p&gt;

&lt;p&gt;これに、所有型を渡すことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let t = &amp;quot;t&amp;quot;.to_string();
{
    let s = &amp;quot;s&amp;quot;.to_string();
    let s_ref = &amp;amp;s;
    take_two_value(t, s_ref);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、所有型にもライフタイムはあります（多分）。&lt;/p&gt;

&lt;p&gt;ところで、ライフタイムのボトム型相当のものに &lt;code&gt;&#39;static&lt;/code&gt; というものがあります。
グローバル変数やリテラルなどに割り当てられるライフタイムで、プログラムが死ぬまで生き続けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&#39;static&lt;/code&gt; のみを受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_static&amp;lt;T: &#39;static&amp;gt;(_: T){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、先の例に出たstaticな値達を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar;
    take_static(foo);
    take_static(x);
    take_static(ref_bar);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これに所有型を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、任意の参照型は渡せません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(&amp;amp;s); // error: `s` does not live long enough
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで所有型には &lt;code&gt;&#39;static&lt;/code&gt; というライフタイムが付いているようです（？）。
&lt;code&gt;&#39;static&lt;/code&gt; イメージとしては「自分がその値を保持している限り無効になることはない型」ですかね。&lt;/p&gt;

&lt;p&gt;これに関連するTipsとして関数や構造体のジェネリクスで所有型しか受け取らないようにするには &lt;code&gt;&amp;lt;T: &#39;static&amp;gt;&lt;/code&gt; が使えます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さてさて、これまた参照型は特別扱いされることなく他のRustの値と同じようにライフタイムで管理されていることを調べました。&lt;/p&gt;

&lt;p&gt;最後に今回到達出来なかった謎、「参照を取る」について考えたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-の規則&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; の規則&lt;/h1&gt;

&lt;p&gt;みなさん御存じの通り、&lt;code&gt;&amp;amp;mut&lt;/code&gt; を取ると値への他の操作が許されなくなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
let t = s;  // error[E0505]: cannot move out of `s` because it is borrowed
let ref_s = &amp;amp;s; // error[E0502]: cannot borrow `s` as immutable because it is also borrowed as mutable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;mut T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; が相互排他的なのでこれは線形論理のシーケント計算っぽく書くと以下のような規則を考えれば良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Γ, T:&#39;a |- Σ
-------------- &amp;amp;mut-intro
Γ, (&amp;amp;&#39;a mut T): &#39;b |- Σ
where &#39;a &amp;lt;: &#39;b

Γ, (&amp;amp;&#39;a mut T):&#39;b |- (&amp;amp;&#39;a mut T): &#39;b, Σ
----------------------- &amp;amp;mut-elim
Γ, T: &#39;a |- Σ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型付け規則の書き方になれてないのでシーケント計算で書きましたがサブタイプの記述で困りましたね。&lt;/p&gt;

&lt;h1 id=&#34;の謎&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; の謎&lt;/h1&gt;

&lt;p&gt;さて、問題は &lt;code&gt;&amp;amp;&lt;/code&gt; です。 &lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; なのでそこら中に生えてきます。
なので &lt;code&gt;&amp;amp;-elim&lt;/code&gt; のような規則では対応出来ません。&lt;/p&gt;

&lt;p&gt;ただ、ライフタイムによる制約があるので「参照のライフタイムが死ぬときに元の値が復活する」ような規則を考えたくなります。&lt;/p&gt;

&lt;p&gt;しかし、それでもだめです。複数回 &lt;code&gt;&amp;amp;&lt;/code&gt; を取れてしまうので、以下のように複数のライフタイムを持つ場合で破綻します。&lt;code&gt;&amp;amp; T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; の間でなにかしらのしがらみがある筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
{
    let ref_s1 = &amp;amp;s;
    {
        let ref_s2 = &amp;amp;s;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それに、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; と &lt;code&gt;&amp;amp;&lt;/code&gt; が相互排他であることも説明出来る規則でないといけません。謎が多い。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;さて、Rustの型システムのリソース管理回りを探ってみました。とりあえず分かったことを纏めると&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;値には全てアフィン型が付く

&lt;ul&gt;
&lt;li&gt;参照型も例外ではない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;値には全てライフタイムが付く

&lt;ul&gt;
&lt;li&gt;所有型も例外ではないっぽい&lt;/li&gt;
&lt;li&gt;もしかしたら所有型はライフタイムを無視している？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「参照を取る」のセマンティクスが謎

&lt;ul&gt;
&lt;li&gt;勿論、直感的には分かる&lt;/li&gt;
&lt;li&gt;どういう規則なんだろう&lt;/li&gt;
&lt;li&gt;アフィン型とライフタイム両方が絡むはず。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特に論文も読んでないのでちょっと遠回りだったかもしれません。
もしかしたら論文漁ったら一発で解決するのかも。
詳しい方、 &lt;code&gt;&amp;amp;&lt;/code&gt; の謎を教えて下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのstructとtraitって似てるよね</title>
      <link>/blog/2016/12/03/rustnostructtotraittteniteruyone</link>
      <pubDate>Sat, 03 Dec 2016 22:06:18 +0900</pubDate>
      
      <guid>/blog/2016/12/03/rustnostructtotraittteniteruyone</guid>
      <description>&lt;p&gt;κeenです。関連型について考えてたらtraitがstructに見えてきたので一筆。小ネタです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;structは普通の構造体とtupl structと言われる形式二種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Color {
  r: u8,
  g: u8,
  b: u8,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Color(u8, u8, u8);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;traitはというと関連型と型パラメータ二種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Into {
  type Item;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Into&amp;lt;T&amp;gt;{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インスタンス化も似てます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// struct
struct Color {
  r: 255,
  g: 0,
  b: 0,
}

struct Color(255, 0, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// trait
struct Dummy;

impl Into for Dummy {
  type Item = i8
}

impl Into&amp;lt;i8&amp;gt; for Dummy {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、両者の使い分けも名前で参照したいかor手軽に使いたいかで使い分けます。&lt;/p&gt;

&lt;p&gt;以上小ネタでした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのプロセス</title>
      <link>/blog/2016/12/02/rustnopurosesu</link>
      <pubDate>Fri, 02 Dec 2016 17:52:30 +0900</pubDate>
      
      <guid>/blog/2016/12/02/rustnopurosesu</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;3日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。Rustの&lt;a href=&#34;https://doc.rust-lang.org/std/process/index.html&#34;&gt;&lt;code&gt;std::process&lt;/code&gt;&lt;/a&gt;の扱い方を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;ビルダー&#34;&gt;ビルダー&lt;/h1&gt;

&lt;p&gt;これはビルダーになっていて、以下のように使えます。公式ドキュメントの例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;sh&amp;quot;)
    .arg(&amp;quot;-c&amp;quot;)
    .arg(&amp;quot;echo hello&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境変数も渡せます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;sh&amp;quot;)
    .arg(&amp;quot;-c&amp;quot;)
    // 環境変数を参照するコマンド
    .arg(&amp;quot;echo $HELLO&amp;quot;)
    // 環境変数を設定する
    .env(&amp;quot;HELLO&amp;quot;, &amp;quot;hello, world&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;hello, world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは実行するディレクトリも指定出来ます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;ls&amp;quot;)
    // プロセスを実行するディレクトリを指定する
    .current_dir(&amp;quot;/&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
boot
cdrom
core
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;出力&#34;&gt;出力&lt;/h1&gt;

&lt;p&gt;上の例では &lt;code&gt;output&lt;/code&gt; でstdio,stderr, exitstatus取り出していますが、子プロセスとして実行することも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut child = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // outputではなくspawnを使う
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);
let status = child.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin  boot  cdrom  core  dev  etc  home  initrd.img  initrd.img.old  lib  lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  sys  tmp  usr  var  vmlinuz  vmlinuz.old
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、子プロセスはRustへではなく直接stdoutへ出力するのでSIGPIPEが送られません。&lt;/p&gt;

&lt;p&gt;あるいは出力先を手で指定することも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let child = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // stdoutをnullにする
    .stdout(Stdio::null())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);
let status = child.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではstdoutをnull ioに指定しています。他には&lt;code&gt;inherit&lt;/code&gt;で親プロセスのものを引き継ぐか、&lt;code&gt;piped&lt;/code&gt;で次のプロセスに渡すことも出来ます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// 1つめのプロセスを作る
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // 出力は親プロセスへパイプする
    .stdout(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);

// 2つめのプロセスを作る
let mut child2 = Command::new(&amp;quot;grep&amp;quot;)
    .arg(&amp;quot;bin&amp;quot;)
    // 入力は親プロセスへパイプする
    .stdin(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);

{
    // Someと分かっているのでunwrapする。
    // この辺はrustの型システテムの限界。
    let out = child1.stdout.as_mut().unwrap();
    let in_ = child2.stdin.as_mut().unwrap();
    // 1つめのプロセスの出力から2つめのプロセスの入力へデータをコピーする
    io::copy(out, in_).unwrap();
}


let status1 = child1.wait().unwrap();
let status2 = child2.wait().unwrap();
println!(&amp;quot;{}, {}&amp;quot;, status1, status2);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
sbin
exit code: 0, exit code: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと繋ぎ込みが面倒ですし&lt;code&gt;io::copy&lt;/code&gt;を使って手でコピーしてるのが頂けませんね。&lt;/p&gt;

&lt;h1 id=&#34;unix&#34;&gt;Unix&lt;/h1&gt;

&lt;p&gt;Unixに依存することを認めてしまえばもうちょっと色々なことが出来ます。&lt;/p&gt;

&lt;p&gt;1つには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::process::CommandExt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するといくつか追加のメソドが生えてくる仕組みになってます。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;exec&lt;/code&gt; が使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let error = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // execを呼ぶ
    .exec();

println!(&amp;quot;after exec!!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;した後はRustのプロセスを別のものに置き換えてしまうので&lt;code&gt;println!(&amp;quot;after exec!!&amp;quot;);&lt;/code&gt;の行が実行されません。
されるとしたら何らかの理由で&lt;code&gt;exec&lt;/code&gt;に失敗した場合だけです。なので面白いことに&lt;code&gt;exec&lt;/code&gt;の返り値はエラーのみです。&lt;/p&gt;

&lt;p&gt;あるいは、&lt;code&gt;unsafe&lt;/code&gt;なコードを認めるなら先のプロセスの繋ぎ込みはもうちょっとスマートに書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::io::{AsRawFd, FromRawFd};
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // 標準出力をパイプする
    .stdout(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

let mut child2 = Command::new(&amp;quot;grep&amp;quot;)
    .arg(&amp;quot;bin&amp;quot;)
    // 標準入力は手で作ったStdioオブジェクトにする。
    // ここでは1つめのプロセスの標準出力を直接繋ぐ。
    .stdin(unsafe{Stdio::from_raw_fd(child1.stdout.as_ref().unwrap().as_raw_fd())})
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

// 直接繋いでしまったのでコピーの必要はない

let status1 = child1.wait().unwrap();
let status2 = child2.wait().unwrap();
println!(&amp;quot;{}, {}&amp;quot;, status1, status2);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
sbin
exit code: 0, exit code: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Stdio&lt;/code&gt;がfdと行き来出来るのでそれを経由することでパイプを作れます。&lt;/p&gt;

&lt;p&gt;もちろん、ファイルに書き出すことも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::io::{AsRawFd, FromRawFd};

let file = File::create(&amp;quot;test.txt&amp;quot;).unwrap();
// ファイルからFDを経由してStdioを作る
let out = unsafe{Stdio::from_raw_fd(file.as_raw_fd())};
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    .stdout(out)
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

let status1 = child1.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status1);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat test.txt
bin
boot
cdrom
core
dev
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;最初は思ったよりCのプロセス回りのAPIと違って戸惑いますが馴れてしまえば使いやすいAPIでしょう。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>新しいコンパイラバックエンドcretonne</title>
      <link>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</link>
      <pubDate>Fri, 02 Dec 2016 14:00:11 +0900</pubDate>
      
      <guid>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;3日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。先日、Rustの開発者フォーラムに新しいバックエンドして&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;cretonne&lt;/a&gt;が&lt;a href=&#34;https://internals.rust-lang.org/t/possible-alternative-compiler-backend-cretonne/4275&#34;&gt;提案されていました&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ちょっと気になったのでそれを紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;概略&#34;&gt;概略&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/index.html&#34;&gt;ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;フォーラムによると、WebAssemblyをエンコードするために作られたコンパイラバックエンドで、FirefoxのJSエンジンであるSpiderMonkeyに載せる予定だそうです。JITが主な目的？&lt;/p&gt;

&lt;p&gt;LLVMのように最適化を頑張る方ではなくてコードを吐くまでのレイテンシを気にして作られているとのこと。なのでcretonne自身は最適化を行いません。&lt;/p&gt;

&lt;p&gt;特徴はドキュメントの&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/compare-llvm.html&#34;&gt;LLVMとの比較&lt;/a&gt;によくまとまってますが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LLVMは複数種類の中間言語を持つのに対してcretonneは1種類&lt;/li&gt;
&lt;li&gt;アセンブラもディスアセンブラもない

&lt;ul&gt;
&lt;li&gt;コードジェネレータが吐く命令だけサポート&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中間言語はISA非依存で、legalization / instruction selectionをするとISA固有のアノテーションが付く&lt;/li&gt;
&lt;li&gt;最大抽象単位が関数(LLVMはモジュール)。cretonneは関数のインライン化とかもしない。&lt;/li&gt;
&lt;li&gt;Extended Basic Blockを使う(LLVMはBasic Block)。

&lt;ul&gt;
&lt;li&gt;ebbは分岐命令のfalse branchを指定せず、fall throughする。よくあるマシン語に近い。&lt;/li&gt;
&lt;li&gt;分岐の合流はebbに引数を持たせることで行う(LLVMはphi nodeを使う)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;undefined behaviorが存在しない&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なんとなくWebAssemblyを意識した仕様ですね。&lt;/p&gt;

&lt;h1 id=&#34;雰囲気&#34;&gt;雰囲気&lt;/h1&gt;

&lt;p&gt;以下のCのコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;float
average(const float *array, size_t count)
{
    double sum = 0;
    for (size_t i = 0; i &amp;lt; count; i++)
        sum += array[i];
    return sum / count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のcretonneのIRに落ちるそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss1 = stack_slot 8, align 4   ; Stack slot for ``sum``.

ebb1(v1: i32, v2: i32):
    v3 = f64const 0x0.0
    stack_store v3, ss1
    brz v2, ebb3                  ; Handle count == 0.
    v4 = iconst.i32 0
    br ebb2(v4)

ebb2(v5: i32):
    v6 = imul_imm v5, 4
    v7 = iadd v1, v6
    v8 = heap_load.f32 v7         ; array[i]
    v9 = fext.f64 v8
    v10 = stack_load.f64 ss1
    v11 = fadd v9, v10
    stack_store v11, ss1
    v12 = iadd_imm v5, 1
    v13 = icmp ult v12, v2
    brnz v13, ebb2(v12)           ; Loop backedge.
    v14 = stack_load.f64 ss1
    v15 = cvt_utof.f64 v2
    v16 = fdiv v14, v15
    v17 = ftrunc.f32 v16
    return v17

ebb3:
    v100 = f32const qNaN
    return v100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ、実際はファイルヘッダとかも付きますがこんな感じです。&lt;/p&gt;

&lt;p&gt;ebbに引数があったりebbの途中で平気でブランチしてたり中々やんちゃですね。&lt;/p&gt;

&lt;h1 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h1&gt;

&lt;p&gt;コードを吐くところまでやりたかったのですがまだ絶賛開発中ということもあってそのような操作が見当りませんでした。&lt;/p&gt;

&lt;p&gt;ということでファイルの方を扱ってると面白みがないのでRust APIの方で関数を構築して正当性を検証してから中間言語を吐き出してみます。&lt;/p&gt;

&lt;h2 id=&#34;一歩&#34;&gt;一歩&lt;/h2&gt;

&lt;p&gt;まずはcretonneをcloneしてきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new cretonne-sample --bin
$ cd cretonne-sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んでCargo.tomlのdependenciesに&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cretonne = {path = &amp;quot;path/cretonne/lib/cretonne/&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加します。どうやらトップレベルのプロジェクトはただのユーティリティのようでした。本体は&lt;code&gt;lib/cretonne/&lt;/code&gt;以下にいます。&lt;/p&gt;

&lt;p&gt;そしてmainファイルの中身はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate cretonne;
use cretonne::ir::*;
use cretonne::ir::{types as ty};
use cretonne::ir::{immediates as imm};
use cretonne::isa;
use cretonne::settings::{self, Configurable};
use cretonne::{write_function, legalize_function, verify_function};

fn main() {
    let mut func = {
        let name = FunctionName::new(&amp;quot;average&amp;quot;);
        let mut sig = Signature::new();
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.return_types.push(ArgumentType::new(ty::F32));
        Function::with_name_signature(name, sig)
    };

    let isa = {
        let mut b = settings::builder();
        b.set(&amp;quot;opt_level&amp;quot;, &amp;quot;fastest&amp;quot;).unwrap();
        let f = settings::Flags::new(&amp;amp;b);
        let builder = isa::lookup(&amp;quot;intel&amp;quot;).unwrap();
        builder.finish(f)
    };
    verify_function(&amp;amp;func).unwrap();
    legalize_function(&amp;amp;mut func, isa.as_ref());
    let mut o = String::new();
    write_function(&amp;amp;mut o, &amp;amp;func, Some(isa.as_ref())).unwrap();
    println!(&amp;quot;{}&amp;quot;, o);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;function average(i32, i32) -&amp;gt; f32 {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おおまかには&lt;code&gt;func&lt;/code&gt;を構築して&lt;code&gt;isa&lt;/code&gt;を決めて&lt;code&gt;verify_function&lt;/code&gt;で検証、さらに&lt;code&gt;legalize_function&lt;/code&gt;で今回のアーキテクチャ向けに微調整、&lt;code&gt;write_function&lt;/code&gt;で書き出しです。&lt;/p&gt;

&lt;h2 id=&#34;スタックスロットの追加&#34;&gt;スタックスロットの追加&lt;/h2&gt;

&lt;p&gt;まあ、スタック領域ですね。8byteの領域を確保します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;にstack_slotsフィールドがあるのでそこにpushします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;push&lt;/code&gt;の返り値はスタック領域を指すキーです。&lt;/p&gt;

&lt;h2 id=&#34;ebbの追加&#34;&gt;EBBの追加&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;構造体のフィールドに&lt;code&gt;dfg&lt;/code&gt;がいて、そいつを色々いじります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let ebb0 = func.dfg.make_ebb();
        let v1 = func.dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = func.dfg.append_ebb_arg(ebb0, types::I32);

        cur.insert_ebb(ebb0);
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

ebb0(vx0: i32, vx1: i32):
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EBBの追加にはカーソルを決めてあげて、dfgにebbを作ってあげて、カーソルの位置にebbの追加という形になります。&lt;/p&gt;

&lt;p&gt;EBBには任意に引数を追加出来ます。&lt;code&gt;append_ebb_arg&lt;/code&gt;の返り値はSSAの変数です。&lt;/p&gt;

&lt;h2 id=&#34;命令を追加する&#34;&gt;命令を追加する&lt;/h2&gt;

&lt;p&gt;命令はpythonのスクリプトによって生成されるので補完が効かず、中々扱いづらいですが頑張ります。&lt;/p&gt;

&lt;p&gt;さて、今回コードの検証を入れているので以下のようなコードは検証に落ちてしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);

        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Error { location: Ebb(Ebb(0)), message: &amp;quot;block does not end in a terminator instruction!&amp;quot; }&#39;, ../src/libcore/result.rs:799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の命令が定数であるため、正常なブロックと見做されないのです。&lt;/p&gt;

&lt;p&gt;ひとまずv3を返すことで凌ぎます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        ....
        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     return v0
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令の頭に付いてる &lt;code&gt;[-]&lt;/code&gt;はlegalizeすると付くようです。&lt;/p&gt;

&lt;h2 id=&#34;ブランチ&#34;&gt;ブランチ&lt;/h2&gt;

&lt;p&gt;もう1つebbを追加してあげる必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let ebb3 = dfg.make_ebb();  // &amp;lt;- ebb3を作成
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new()); // &amp;lt;-ebb3にジャンプ

        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);

        cur.insert_ebb(ebb3); // &amp;lt;- ebb3を追加
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     brz vx1, ebb1
[-]                     return v0

                    ebb1:
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;残り&#34;&gt;残り&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;

        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb2 =  dfg.make_ebb();
        let v5 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb3 = dfg.make_ebb();

        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new());
        let v4 = dfg.ins(cur).iconst(types::I32, 0);
        let mut ebb2_arg = VariableArgs::new();
        ebb2_arg.push(v4);
        dfg.ins(cur).jump(ebb2, ebb2_arg);

        cur.insert_ebb(ebb2);
        let v6 = dfg.ins(cur).imul_imm(v5, 4);
        let v7 = dfg.ins(cur).iadd(v1, v6);
        dfg.ins(cur).jump(ebb3, VariableArgs::new());

        cur.insert_ebb(ebb3);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで進めていこうと思いましたがどうやらまだstack/heapを触る命令がない？？ようなので詰みました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;コンパイラバックエンドcretonneについて紹介しました&lt;/li&gt;
&lt;li&gt;cretonneのRust APIを触ってみましたがダメでした。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustでバイト列を扱う時のtips</title>
      <link>/blog/2016/12/01/rustdebaitoretsuwoatsukautokinotips</link>
      <pubDate>Thu, 01 Dec 2016 14:29:33 +0900</pubDate>
      
      <guid>/blog/2016/12/01/rustdebaitoretsuwoatsukautokinotips</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;2日目の記事です。&lt;/p&gt;

&lt;p&gt;Rustはシステムプログラミング言語なのでバイト列をあれこれしたいことがあると思います。その時にイテレータでバイト列を舐める以外にも色々方法があるなと気付いたので。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;read-と-write&#34;&gt;&lt;code&gt;Read&lt;/code&gt; と &lt;code&gt;Write&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;私には割と衝撃だったのですが&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;や&lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt;、&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;は直接&lt;code&gt;Read&lt;/code&gt;や&lt;code&gt;Write&lt;/code&gt;のインスタンスになってます。
例えば&lt;code&gt;Read&lt;/code&gt;ならこういう風に使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes: &amp;amp;[u8] = &amp;amp;[1, 2, 3, 4, 5, 6];
let mut buf = [0;3];
bytes.read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;read: [1, 2, 3], rest: [4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは &lt;code&gt;.bytes()&lt;/code&gt;でbyteのイテレータを取り出してもいいですし、如何様にも扱えます。&lt;/p&gt;

&lt;p&gt;少し注意が必要なのは&lt;code&gt;Vec&lt;/code&gt;は &lt;code&gt;Read&lt;/code&gt; を実装してないので一旦スライスに変換してあげる必要がありますが、やり方を工夫する必要があります。&lt;/p&gt;

&lt;p&gt;以下は少しびっくりする例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = vec![1, 2, 3, 4, 5, 6];
let mut buf = [0;3];
(&amp;amp;bytes[..]).read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;read: [1, 2, 3], rest: [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦スライスを取り出してその場で捨てているので&lt;code&gt;bytes&lt;/code&gt;は消費されません。&lt;/p&gt;

&lt;p&gt;そうやりたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = vec![1, 2, 3, 4, 5, 6];
let mut bytes = &amp;amp;bytes[..];
let mut buf = [0;3];
bytes.read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように一旦スライスを束縛してから使います。&lt;/p&gt;

&lt;p&gt;Writeの方も似ていて、そのまま&lt;code&gt;write&lt;/code&gt;出来ますし、消費されます。ただ、書き込み領域が空になってもそのままスルーされるので注意です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mut bytes: &amp;amp;mut [u8] = &amp;amp;mut [0; 6];
let data = &amp;amp;[1, 2, 3];
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;data: [1, 2, 3], buf: [0, 0, 0, 0, 0, 0]
data: [1, 2, 3], buf: [0, 0, 0]
data: [1, 2, 3], buf: []
data: [1, 2, 3], buf: []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後、バッファが空になった状態で書き込んでも無言で書き込みが終了しています。そして書き込んだデータへのアクセスは出来てないですね。&lt;/p&gt;

&lt;p&gt;こうすると出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes:[u8; 6] =  [0; 6];
let data = &amp;amp;[1, 2, 3];
{
    let mut buf: &amp;amp;mut [u8] = &amp;amp;mut bytes;
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
    buf.write(data).unwrap();
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
    buf.write(data).unwrap();
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
}
println!(&amp;quot;bytes: {:?}&amp;quot;, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [1, 2, 3], buf: [0, 0, 0, 0, 0, 0]
data: [1, 2, 3], buf: [0, 0, 0]
data: [1, 2, 3], buf: []
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあ面倒ですね。というかそもそも固定長のバッファに書き込みたいという需要が少ない。&lt;/p&gt;

&lt;p&gt;でもこれは&lt;code&gt;Vec&lt;/code&gt;を使えば解決します。可変長ですし&lt;code&gt;Write&lt;/code&gt; も実装しているので便利です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes: Vec&amp;lt;u8&amp;gt; = Vec::new();
let data = &amp;amp;[1, 2, 3];
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
println!(&amp;quot;bytes: {:?}&amp;quot;, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [1, 2, 3], buf: []
data: [1, 2, 3], buf: [1, 2, 3]
data: [1, 2, 3], buf: [1, 2, 3, 1, 2, 3]
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cursor&#34;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、上で見た通り、なんとなく生のバイト列だと扱いづらそうな場面がありそうですよね。
そこで &lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/struct.Cursor.html&#34;&gt;&lt;code&gt;std::io::Cursor&lt;/code&gt;&lt;/a&gt;を使うと便利です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Cursor&lt;/code&gt;はコンストラクタで引数の所有権を奪うタイプの、ラッパーオブジェクト的構造体です。&lt;/p&gt;

&lt;p&gt;readだとこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: &amp;amp;[u8] = &amp;amp;[1,2,3,4,5,6];
let data: &amp;amp;mut [u8] = &amp;amp;mut [0;3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
cur.read_exact(data).unwrap();
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
cur.read_exact(data).unwrap();
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
println!(&amp;quot;bytes: {:?}&amp;quot;, cur.into_inner());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [0, 0, 0], position 0
data: [1, 2, 3], position 3
data: [4, 5, 6], position 6
bytes: [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポジションが取れるのと元のオブジェクトが無事なのが違いますね。&lt;/p&gt;

&lt;p&gt;Writeも同様です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: &amp;amp;mut [u8] = &amp;amp;mut [0;6];
let data: &amp;amp;[u8] = &amp;amp;[1, 2, 3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
println!(&amp;quot;bytes: {:?}&amp;quot;, cur.into_inner());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;data: [0, 0, 0, 0, 0, 0], position 0
data: [1, 2, 3, 0, 0, 0], position 3
data: [1, 2, 3, 1, 2, 3], position 6
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この&lt;code&gt;Cursor&lt;/code&gt;の面白いのは&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;でなく&lt;code&gt;AsRef&amp;lt;[u8]&amp;gt;&lt;/code&gt;で&lt;code&gt;Read&lt;/code&gt;を実装していますし&lt;code&gt;std::io::Seek&lt;/code&gt;も実装しているのでこういうことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = Vec::new();
let data: &amp;amp;[u8] = &amp;amp;[1, 2, 3];
let buf: &amp;amp;mut [u8] = &amp;amp;mut [0; 3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.seek(SeekFrom::Start(0)).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.read(buf).unwrap();
println!(&amp;quot;bytes: {:?}, position {}, buf: {:?}&amp;quot;, cur.get_ref(), cur.position(), buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bytes: [], position 0
bytes: [1, 2, 3], position 3
bytes: [1, 2, 3, 1, 2, 3], position 6
bytes: [1, 2, 3, 1, 2, 3], position 0  // &amp;lt;- 0にシークした
bytes: [1, 2, 3, 1, 2, 3], position 3, buf: [1, 2, 3] // &amp;lt;- 0からリード出来てる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生の&lt;code&gt;Vec&lt;/code&gt;では出来なかったread and writeが実現出来ています。そして好きにカーソルをシーク出来ます。
ここまでくるとほとんどファイルと変わらなく扱えますね。&lt;/p&gt;

&lt;h1 id=&#34;おりに&#34;&gt;おりに&lt;/h1&gt;

&lt;p&gt;ちょっとしたTipsですが道具箱にこういうのを増やしておくと便利ですよね！！&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Read.html&#34;&gt;std::io::Read - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Write.html&#34;&gt;std::io::Write - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/struct.Cursor.html&#34;&gt;std::io::Cursor - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Seek.html&#34;&gt;std::io::Seek - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/enum.SeekFrom.html&#34;&gt;std::io::SeekFrom - Rust&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>マクロやコンパイラプラグインの実装方法色々</title>
      <link>/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou</link>
      <pubDate>Thu, 01 Dec 2016 13:29:52 +0900</pubDate>
      
      <guid>/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;2日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。マクロなどのコンパイル時に何か処理をしてコード生成する機構の実現方法が言語によって様々にあるなぁと思ったのでちょっと探ってみます&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;なんか文字だけ並んでても味気ないのでサンプルマクロも付けときますね。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラにマクロ専用言語のインタプリタ機能を付けるやつ&#34;&gt;コンパイラにマクロ専用言語のインタプリタ機能を付けるやつ&lt;/h1&gt;

&lt;p&gt;Rustの&lt;code&gt;macro_rules&lt;/code&gt;やSchemeの&lt;code&gt;syntax-rules&lt;/code&gt;が該当します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-syntax define-protocol
  (syntax-rules ()
    ((define-protocol (name type ...) (method arg ...) ...)
     (begin
       (define method
         (make-generic))
       ...
       (define name
         (lambda (type ...)
           (lambda methods
             (add-methods methods (list (list method arg ...) ...)))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;制限が強い上に無駄にコンパイラの機能が増えるので個人的にはあまり好きじゃないですね…。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラでもホスト言語を動かすやつ&#34;&gt;コンパイラでもホスト言語を動かすやつ&lt;/h1&gt;

&lt;p&gt;コンパイラとランタイムが一緒になっているCommon Lispなんかで使われる方法です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(defmacro dotimes-unroll ((i n unroll) &amp;amp;body body)
  (let ((n_      (gensym &amp;quot;n&amp;quot;)))
    `(let ((,n_ ,n))
       (do ((,i 0))
           ((&amp;lt; ,n_ (the fixnum (+ ,unroll ,i)))
            (do ((,i ,i (the fixnum (1+ ,i))))
                ((&amp;lt; ,n_ (the fixnum (1+ ,i))))
              ,@body
              ))
         ,@(loop :repeat unroll :append (append body `((setq ,i (the fixnum (1+ ,i))))))))))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;マクロがなくなるまで再帰的にマクロ展開をします。
ユーザが好き勝手書けてしかも手軽に使えるので割と好きです。まあ、でも言語を選びますね。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラプラグインとしてdlopenするやつ&#34;&gt;コンパイラプラグインとしてdlopenするやつ&lt;/h1&gt;

&lt;p&gt;Rustのコンパイラプラグインが相当します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[lib]
crate-type = [&amp;quot;dylib&amp;quot;]
plugin = true
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn codegen&amp;lt;&#39;cx&amp;gt;(cx: &amp;amp;&#39;cx mut ExtCtxt, text: String, file: String)
        -&amp;gt; Box&amp;lt;MacResult + &#39;cx&amp;gt; {
    let mut output = Vec::new();
    let doc = Document::parse(&amp;amp;text)
        .expect(&amp;quot;failed to parse thrift file&amp;quot;)
        .expect(&amp;quot;EOF while parsing thrift file&amp;quot;);
    {
        let ns = find_rust_namespace(&amp;amp;doc).expect(&amp;quot;cannot find namespace&amp;quot;);
    output.write_all(format!(&amp;quot;mod {} {{&amp;quot;, ns.module).as_ref()).expect(&amp;quot;internal error failed to write the vec&amp;quot;);
    }
    compile(doc, &amp;amp;mut output).expect(&amp;quot;failed to generate code&amp;quot;);
    output.write_all(format!(&amp;quot;}}&amp;quot;).as_ref()).expect(&amp;quot;internal error failed to write the vec&amp;quot;);
    let output = match std::str::from_utf8(&amp;amp;output) {
        Ok(s) =&amp;gt; s,
        Err(_) =&amp;gt; &amp;quot;&amp;quot;,
    };

    trace!(&amp;quot;{}&amp;quot;, output);


    let parser = new_parser_from_source_str(cx.parse_sess(), file, output.to_string());

    struct ExpandResult&amp;lt;&#39;a&amp;gt; {
        p: parse::parser::Parser&amp;lt;&#39;a&amp;gt;,
    }
    impl&amp;lt;&#39;a&amp;gt; base::MacResult for ExpandResult&amp;lt;&#39;a&amp;gt; {
        fn make_items(mut self: Box&amp;lt;ExpandResult&amp;lt;&#39;a&amp;gt;&amp;gt;)
                      -&amp;gt; Option&amp;lt;SmallVector&amp;lt;ptr::P&amp;lt;ast::Item&amp;gt;&amp;gt;&amp;gt; {
            let mut ret = SmallVector::zero();
            while self.p.token != token::Eof {
                match panictry!(self.p.parse_item()) {
                    Some(item) =&amp;gt; ret.push(item),
                    None =&amp;gt; panic!(self.p.diagnostic().span_fatal(self.p.span,
                                                                  &amp;amp;format!(&amp;quot;expected item, found `{}`&amp;quot;,
                                                                           self.p.this_token_to_string())))
                }
            }
            Some(ret)
        }
    }

    Box::new(ExpandResult { p: parser })

}


fn macro_thrift&amp;lt;&#39;cx&amp;gt;(cx: &amp;amp;&#39;cx mut ExtCtxt, sp: Span, tts: &amp;amp;[TokenTree])
                     -&amp;gt; Box&amp;lt;MacResult + &#39;cx&amp;gt; {

    let text = match get_single_str_from_tts(cx, sp, tts, &amp;quot;thrift!&amp;quot;) {
        Some(f) =&amp;gt; f,
        None =&amp;gt; return DummyResult::expr(sp),
    };

    codegen(cx, text, &amp;quot;trift!&amp;quot;.to_string())
}


#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;amp;mut Registry) {
    reg.register_macro(&amp;quot;thrift&amp;quot;, macro_thrift);
    reg.register_macro(&amp;quot;thrift_file&amp;quot;, macro_thrift_file);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦dllを作ってそれをプラグインとしてロードするという手間もありますし、ユーザが触れるASTも複雑なのであまり好きではないです。
まあ、これは準クオートだとかのユーザインターフェースの問題だったりするんですが。
ただ表現力はホスト言語が使えるので自由に使えます。&lt;/p&gt;

&lt;h1 id=&#34;言語の仕組みを使ってライブラリをコンパイラにロードする&#34;&gt;言語の仕組みを使ってライブラリをコンパイラにロードする&lt;/h1&gt;

&lt;p&gt;私が地味に好きな言語に&lt;a href=&#34;http://www.mirah.org/&#34;&gt;mirah&lt;/a&gt;というのがあります。その言語での実現方法が少し好きでした。
mirahはJVMで動くRuby風言語で、コンパイラは既にセルフホストされています。つまりコンパイラもJVMで動く訳です。&lt;/p&gt;

&lt;p&gt;Javaには&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html&#34;&gt;SPI&lt;/a&gt;というものがあって明示的にクラスやインスタンスを指定しなくてもJVMが実装を捜してくれる機能があります。
その機能にのっかることでマクロを.classファイルにコンパイルしてクラスパスに置いておくだけでマクロが使えるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;$ExtensionsRegistration[[&#39;java.util.Map&#39;]]
class MapExtensions
  macro def [](key)
    quote { `@call.target`.get(`key`) }
  end
end

class Builtins implements ExtensionsProvider

  def register(type_system:ExtensionsService):void
    type_system.macro_registration(MapExtensions.class)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中々面白いですね。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;なんか実装コード1つない雑な記事で申し訳ありませんがmirahのマクロの仕組みがちょっと気に入ったので書こうと思った次第です。&lt;/p&gt;

&lt;p&gt;あとはOCamlのppxやHaskellのTHも気になるのですが調べきれませんでした。はい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>4年間続いたShibuya.lispのLispMeetUp</title>
      <link>/blog/2016/12/01/4nenkantsuzuitashibuya_lispnolispmeetup</link>
      <pubDate>Thu, 01 Dec 2016 12:40:08 +0900</pubDate>
      
      <guid>/blog/2016/12/01/4nenkantsuzuitashibuya_lispnolispmeetup</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/event-management&#34;&gt;IT勉強会/コミュニティ運営 Advent Calendar 2016 - Qiita&lt;/a&gt;2日目の記事です。&lt;/p&gt;

&lt;p&gt;Shibuya.lispの開催しているlispmeetupは約4年間毎月開催しました（現46回開催）。
そこまで長く続いているコミュニティ活動はそんなに多くないのではないでしょうか。
lispmeetupがどうして続いたのかちょっと考察してみます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;因みにlispmeetupを開催しているのは第2期運営で、Shibuya.lisp自体はそれより前から活動しています。&lt;/p&gt;

&lt;p&gt;私は2期運営に途中から入った人でmeetup第6回から参加し始めて確か19回くらいから運営になったと思います。&lt;/p&gt;

&lt;h1 id=&#34;会場が安定的に確保出来た&#34;&gt;会場が安定的に確保出来た&lt;/h1&gt;

&lt;p&gt;安定してるかは若干怪しいですが毎月会場確保が出来ていたのは事実です。
最初の頃は天井から木の根が出てくるお粗末な会場だったそうですが、私が参加するころには毎回サイバーエージェントのセミナールームを使ってました。&lt;/p&gt;

&lt;h1 id=&#34;発表者がいなかったら運営が発表した&#34;&gt;発表者がいなかったら運営が発表した&lt;/h1&gt;

&lt;p&gt;勉強会に来たのに発表がなかったら残念ですよね。
どんな回でも少なくとも運営が発表するので2件くらいは発表がありました。
時間が余ったらライブコーディングしたりもしてました。&lt;/p&gt;

&lt;p&gt;因みに私も毎月発表してるからという理由で運営になったような気がします。&lt;/p&gt;

&lt;h1 id=&#34;テーマをローテした&#34;&gt;テーマをローテした&lt;/h1&gt;

&lt;p&gt;Lisp固有の事情かもしれませんがメジャーな方言にCommon Lisp、 Clojure、Schemeがあります。
参加者の中には全部いけるって人もそれなりにいますがClojureにしか興味がないって人もいます。
なので毎回テーマを決めてある程度発表者、参加者のゾーンニングをした方が満足度が高い訳です。&lt;/p&gt;

&lt;p&gt;ローテションというのもまあまあ重要で、まず運営が考えることが少なくて済む。
発表者は3ヶ月に1回くらいの頻度で自分の興味のある方言の回がやってくるのでそれなりに準備期間がある。
参加者も今月はClojureだから無理してでもいこおう、Common Lispだから今月はいいやみたいにメリハリが付けれる。&lt;/p&gt;

&lt;h1 id=&#34;平日開催した&#34;&gt;平日開催した&lt;/h1&gt;

&lt;p&gt;善し悪しだと思いますが平日開催に拘りました。平日にしか来れない人を集めたいという意向です。
逆に休日にしか来れない人は切り捨てちゃってますね。&lt;/p&gt;

&lt;p&gt;来れる人が渋谷近辺の人に限られてしまいますがまあ、Shibuya.lispなのでご愛嬌。
参加する人は地球の裏側からでも来ます。これは半分本当で、オランダとかからの参加者も過去にいました。&lt;/p&gt;

&lt;p&gt;仕事帰りに参加する人とか学生とかが多いようでした。&lt;/p&gt;

&lt;h1 id=&#34;運営の負荷を減らした&#34;&gt;運営の負荷を減らした&lt;/h1&gt;

&lt;p&gt;テーマをローテしたのところでも述べましたが、極力運営の負荷は減らした方がいいです。
運営が動かないと何も進まないので開催が億劫になるくらいなら負荷は減らしましょう。
lispmeetupでは開催報告やレポートをメーリスに投げていましたがやめてしまいました。
まあ、connpassが優秀だったのである程度そっちに頼れたというのもあります。&lt;/p&gt;

&lt;p&gt;また、最初のうちは懇親会で余ったお金を予算として持っていましたが、管理コストもかかるので掃き出してしまいました。&lt;/p&gt;

&lt;h1 id=&#34;とにかく毎月開催した&#34;&gt;とにかく毎月開催した&lt;/h1&gt;

&lt;p&gt;最初の頃は参加者が1ケタの時もありました。それでも毎月続けました。
するとある程度lispmeetupが定着したのかここ1年ほどは会場定員オーバーくらいまで人が集まるようになりました。&lt;/p&gt;

&lt;h1 id=&#34;懇親会を毎回やった&#34;&gt;懇親会を毎回やった&lt;/h1&gt;

&lt;p&gt;地味に重要だと思います。
発表者に質問にいったりあるいはふとした会話から次の発表のネタが産まれたりします。
新規参加者も重要ですがリピーターも重要です。&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;LispMeetUpは4年の節目で一旦終了します。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Shibuya.lispの現運営が引退するので &lt;a href=&#34;https://twitter.com/hashtag/lispmeetup?src=hash&#34;&gt;#lispmeetup&lt;/a&gt; がなくなります。引き継いでくれる方を募集しています。残りはClojure回、CL回です。Schemeは今月が最後でした。&lt;a href=&#34;https://t.co/o4vv9DRFal&#34;&gt;https://t.co/o4vv9DRFal&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/803599706475507716&#34;&gt;2016年11月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;今の運営が引退した後を引き継いでくれる人も集まりそうなので何らかの形では続くと思いますが、lispmeetupという形をとるのかTech Talkだけになるのかは次の運営次第です。&lt;/p&gt;

&lt;p&gt;お疲れ様でした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>サイバーエージェントを退職しました</title>
      <link>/blog/2016/11/30/saiba_e_jientowotaishokushimashita</link>
      <pubDate>Wed, 30 Nov 2016 15:51:38 +0900</pubDate>
      
      <guid>/blog/2016/11/30/saiba_e_jientowotaishokushimashita</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/1638&#34;&gt;Ex CyberAgent Developers Advent Calendar 2016 - Adventar&lt;/a&gt;1日目の記事です。
元サイバーエージェントの人がわいわいやります。&lt;/p&gt;

&lt;p&gt;κeenです。二年弱勤めたサイバーエージェントを退職したのでその旨について。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;サイバーエージェントの思い出&#34;&gt;サイバーエージェントの思い出&lt;/h1&gt;

&lt;p&gt;サイバーエージェントに興味をもつきっかけになったのも入社することになったのも学生の頃からずっと参加し続けていた&lt;a href=&#34;https://lisp.connpass.com&#34;&gt;LispMeetUp&lt;/a&gt;でした。
LispMeetUpでは長らく会場としてCAのセミナールームを使わせてもらっていました。
そこでエンジニアに対して気軽に施設を提供するCAや社員の&lt;a href=&#34;https://twitter.com/potix2&#34;&gt;@potix2&lt;/a&gt;さんを知って、そのまま@potix2さんの手引でCAに入社する運びとなりました。
「面接でLispは口にしない方が良い。100%落ちる。」なんて言ってた割にはLisp繋りで入社しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/04/10/cyberagentninyuushashimashita/&#34;&gt;CyberAgentに入社しました | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新卒で入社してからは3ヶ月ほど研修でした。
最初の2週間ほどあるビジネス職も含めた全体研修ではなるほど、ここがCAかと思いました。しかしエンジニア研修からは見慣れた光景に戻って静かに研修を受けてました。
エンジニア研修は割と長めにあるので同期のエンジニア同士の顔を覚える余地はありました。勉強会なんかもやりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://keens.github.io/slide/seitekinamemorikanrinohanashi/&#34;&gt;静的なメモリ管理の話。リージョン推論とλ計算からRustまで | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keens.github.io/slide/benkyoukaikudoubenkyoudetakeshibenkyou/&#34;&gt;勉強会駆動勉強で猛勉強 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keens.github.io/slide/21seikinoenjinianotamenoHTTP_2nyuumon/&#34;&gt;21世紀のエンジニアのためのHTTP/2入門 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などなど。Linux, C, Python, Go, Java, Web, iOS, フレームワーク, Android, チーム開発なんかをやりました。Python, Go, iOSあたりは自分じゃやらなかったので面白かったです。&lt;/p&gt;

&lt;p&gt;研修中は割と時間があったので他にも色々なことをやってました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/05/06/tarballbe_sunokeiryoubakkuapputsu_rutsukutta/&#34;&gt;tarballベースの軽量バックアップツール&amp;rsquo;Sheltar&amp;rsquo;を作った | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/05/26/onigmowosaidai49_kousokukashitahanashi/&#34;&gt;Onigmoを最大49%高速化した話 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou/&#34;&gt;第一級ラベルを持たない言語におけるDirect Threaded VMの実装 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この他にも研修期間中にブログエントリ十数本書いていたようです。下の代からは研修の内容が変わって忙しそうでした。&lt;/p&gt;

&lt;p&gt;研修のあとの配属は@potix2さんのいる&lt;a href=&#34;https://adtech.cyberagent.io/&#34;&gt;アドテクスタジオ&lt;/a&gt;のAMoAdでした。トレーナの清水さんを始めとしてチームの皆さんにお世話になりました。
AMoAdはその昔、外注していたシステムを巻き取ったものなのでやることが一杯あって、JavaやScalaを書いたり自動化をやったりしました。&lt;/p&gt;

&lt;p&gt;Scalaは全然いたことがなかったので練習がてら作ったのがこれでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/&#34;&gt;Scala初心者の新卒が頑張ってLispを作ってみた | Scala Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これのおかげで型クラスがただのimplpcit parameterに見えるようになったのでそれなりに収穫はあったな、と思ってます。&lt;/p&gt;

&lt;p&gt;AMoAdに限らずアドテクスタジオのエンジニアのボリュームゾーンは30代半ばなのでだいたい一回り近く年の離れたエンジニアに暖かく囲まれながら仕事をしていました。
どんな雰囲気なの？とたまに訊かれますがエンジニアが集う部署なのでだいたい工学部を想像して頂けたらと思います。&lt;/p&gt;

&lt;p&gt;さて、年が明けて2016年の1月になると、@potix2さんが新しいグループを立ち上げることになって別のグループに移動してしまいました。長らくお世話になりました。
と思いきや自分もそのグループに移動になったので相変わらずお世話になることになりました。基盤開発グループってところでした。仕事と仕事の境目は一瞬仕事がない期間が産まれたりしますが、その隙を使って始めたのがRustのドキュメントの翻訳です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/3b068769736e671805f0&#34;&gt;Rustのドキュメントの翻訳プロジェクトを開始します。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あたらしいチームでは社内向けマイクロサービスのようなものを作ることになりました。
私ともう一人ベテランのエンジニア(&lt;a href=&#34;https://twitter.com/atty303&#34;&gt;@atty303&lt;/a&gt;)でやる筈でしたが私のような雑草と違ってベテランは中々元のチームを抜けられないので1ヶ月ほど私一人でコードを書いてました。
Scalaにも馴れてない新卒一人で。1ヶ月後に&lt;a href=&#34;https://twitter.com/atty303&#34;&gt;@atty303&lt;/a&gt;さんがジョインすると、コードは書かずにインフラをやるとのことでした。なのでコードを書くのはやっぱり私一人。&lt;/p&gt;

&lt;p&gt;私が苦戦しつつコードを書いている間にconsulやnomad、terraform、dockerなんかでインフラが構築されていき、たまに朝来たら自分のコードが消えていたり（「君のコード書き直しといたよ」）して確か5月頃リリースだったような。&lt;/p&gt;

&lt;p&gt;因みにdockerを多く使うのにdocker-machineだと不便なのでUbuntuマシンが欲しいって言ったら却下されました。セキュリティ的に無理でした。結局VMでUbuntuを使ってました（使ってます）。&lt;/p&gt;

&lt;p&gt;リリースしてからは要求性能も満たしそこまで大きな障害もなく平和に暮らしました。めでたしめでたし。Ubuntuは使えなかったけど。&lt;/p&gt;

&lt;p&gt;まあ、あとは新卒研修を担当したり&lt;a href=&#34;https://www.cyberagent.co.jp/recruit/fresh/program_detail/id=11303&amp;amp;season=2016&#34;&gt;インターン&lt;/a&gt;を担当したり社内ハッカソンをやったりゼミでドローンを飛ばしたり新卒のトレーナーをやったりライブラリの選書をやってコンパイラの本を大量に入荷したりと本業以外も色々やってました。長くなるのでこの辺は省きますね。&lt;/p&gt;

&lt;h1 id=&#34;退職に際して&#34;&gt;退職に際して&lt;/h1&gt;

&lt;p&gt;よく、「合わなかったの？」と言われますがそんなことはないです。（少くとも）アドテクスタジオはエンジニアにとっては非常に働きやすい場所でしたし&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cyberagent.co.jp/features/detail/id=12837&#34;&gt;adtech studio - Photo Tour｜FEATURES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CAの一般的イメージはそういう部分だけ切り取ってメディアに出してるんだと思います。
エンジニアから見たら先述の通り工学部のような雰囲気です。Ubuntuは使えないけど。サーバもMacやWindowsで動いてるんですかね。&lt;/p&gt;

&lt;p&gt;むしろCAに入って良かったなと思える部分は一杯あって、ベテランのエンジニアに色々教えて貰ったりだとかVMwareのライセンスを買ってくれたりだとか&lt;a href=&#34;https://adtech.cyberagent.io/techblog?s=icfp&#34;&gt;ICFPに行かせてもらったり&lt;/a&gt;だとか。&lt;/p&gt;

&lt;p&gt;同期エンジニアの繋りというのもすごい良くて、得意分野も部署も（今となっては）会社も色々にある60人ほどいるエンジニアとの人脈が無条件に作れるというのは新卒で入らないと出来ないなと思います。
困ったことがあったら同期Slackに投げると数分で解決します。&lt;/p&gt;

&lt;p&gt;最後は雑草が枯れるように誰にも気付かれないように消えていくつもりでしたがそうもいかず、大勢の方々に送り出して頂きました。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;集合写真&#34; src=&#34;/images/ca/mall.jpg&#34; style=&#34;width: 100%&#34;&gt;&lt;/p&gt;

&lt;p&gt;私の周りにいるのがお世話になった開発責任者やトレーナー、トレーニーなどですね。&lt;/p&gt;

&lt;p&gt;色紙とプレゼントも頂きました。ありがとうございます。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;プレゼントの写真&#34; src=&#34;/images/ca/presents.jpg&#34; style=&#34;width: 100%&#34;&gt;&lt;/p&gt;

&lt;p&gt;退職の旨は業務上必要な方以外には知らせてなかったのでまさか色紙が来るとは思ってませんでした。
多分関係しそうな人にDMを送って集めたんだと思います。ありがとうございます。
プレゼントは麻の模様の風呂敷です。
私はカバン代わりにPCを入れるにも旅行に行くにも風呂敷を使う人です:)&lt;/p&gt;

&lt;p&gt;そして女性エンジニアの方(&lt;a href=&#34;https://twitter.com/iyunoriue&#34;&gt;@iyunoriue&lt;/a&gt;)からFOUNDRYの詰め合わせも頂きました。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;FOUNDRYの写真&#34; src=&#34;/images/ca/foundry.jpg&#34; style=&#34;width: 100%&#34;&gt;&lt;/p&gt;

&lt;p&gt;スイーツが好きなので非常に嬉しいです。ありがとうございます。抹茶と合いそう。&lt;/p&gt;

&lt;p&gt;また、退職に合わせて色々なものも引退することになりました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Shibuya.lispの現運営が引退するので &lt;a href=&#34;https://twitter.com/hashtag/lispmeetup?src=hash&#34;&gt;#lispmeetup&lt;/a&gt; がなくなります。引き継いでくれる方を募集しています。残りはClojure回、CL回です。Schemeは今月が最後でした。&lt;a href=&#34;https://t.co/o4vv9DRFal&#34;&gt;https://t.co/o4vv9DRFal&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/803599706475507716&#34;&gt;2016年11月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そろそろ私も野生のLisper引退した方がいい。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/803601106693521408&#34;&gt;2016年11月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;お世話になった方々本当にありがとうございました。&lt;/p&gt;

&lt;h1 id=&#34;次の話と退職理由&#34;&gt;次の話と退職理由&lt;/h1&gt;

&lt;p&gt;とりあえず12月中は有給消化で、1月から働きます。給料はまあまあ上がります。どうやらコンパイラ関係の仕事をしそうです。
世の中そんな仕事があるのか自分でも半信半疑ですがあるようです。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;そういえばICFPのときにкeenさんと話して「えっコンパイラが書けるシゴトあると思ってんの!?」と冗談半分で言われたな．&lt;/p&gt;&amp;mdash; gfn (@bd_gfngfn) &lt;a href=&#34;https://twitter.com/bd_gfngfn/status/780057500485681153&#34;&gt;2016年9月25日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;私のことを知ってる方なら「コンパイラの仕事があるから」で十分退職理由として納得頂けると思います。
技術的にも人生的にもチャレンジングですがまだ20代前半なので後先考えずに行動してもどうにかなるかな、とか思ってます。
地味に社内でRustも使われているようなのでそこも狙っていこうと思います。
あ、こういうのもやってます。興味のある方はお願いします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次の仕事についてはまた入社してから書こうと思いますが、ひとまずの報告として渋谷からは離れます。本郷キャンパスに近いところに引っ越す予定です。付近の人はなんか誘って下さい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://amzn.asia/0JcDzIf&#34;&gt;http://amzn.asia/0JcDzIf&lt;/a&gt;&lt;/p&gt;

&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;お疲れ様でした&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SML#をUbuntu 16.10で動かす</title>
      <link>/blog/2016/11/30/sml_woubuntu_16_10deugokasu</link>
      <pubDate>Wed, 30 Nov 2016 15:18:58 +0900</pubDate>
      
      <guid>/blog/2016/11/30/sml_woubuntu_16_10deugokasu</guid>
      <description>&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2016/ml&#34;&gt;ML Advent Calendar 2016 - Qiita&lt;/a&gt;の1日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。小ネタを。Ubuntu 16.10でSML#を動かそうと思ったら動かなかったので動かします。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;現象&#34;&gt;現象&lt;/h1&gt;

&lt;p&gt;リンカがエラーを吐く。バイナリが正しく作れてなさそう&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(callback.o): relocation R_X86_64_32 against `.text&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(control.o): relocation R_X86_64_32 against `.text&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(error.o): relocation R_X86_64_32 against `.bss&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(exn.o): relocation R_X86_64_32 against `.rodata.str1.8&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください 。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(finalize.o): relocation R_X86_64_32 against `.text&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(init.o): relocation R_X86_64_32 against `.rodata.str1.1&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(object.o): relocation R_X86_64_32 against `.rodata.str1.1&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(xmalloc.o): relocation R_X86_64_32 against `.rodata.str1.1&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてくだ さい。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(prim.o): relocation R_X86_64_32 against `.rodata&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(top.o): relocation R_X86_64_32 against `.text&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(dtoa.o): relocation R_X86_64_32 against `.rodata.str1.1&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a(heap_concurrent.o): relocation R_X86_64_32S against `.bss&#39; can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
/usr/bin/ld: 最終リンクに失敗しました: 出力に対応するセクションがありません
collect2: error: ld returned 1 exit status
uncaught exception: CoreUtils.Failed: gcc -Wl,-Bsymbolic-functions -Wl,-z,relro test/Main.o /tmp/tmp.IhaEmV/000/tmp_000.a lib/socket.o lib/inet.o lib/net_host_db.o /usr/lib/x86_64-linux-gnu/smlsharp/runtime/main.o /usr/lib/x86_64-linux-gnu/smlsharp/runtime/libsmlsharp.a -lpthread -lyajl -ldl -lgmp -lm  -o testRunner at src/compiler/toolchain/main/CoreUtils.sml:113
Makefile:50: ターゲット &#39;testRunner&#39; のレシピで失敗しました
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;原因&#34;&gt;原因&lt;/h1&gt;

&lt;p&gt;私もよく分かってないのですが、Ubuntu 16.10からGCC 6系になりましたが、そこでデフォルトの挙動が変わったらしいのでその辺らしいです。&lt;/p&gt;

&lt;h1 id=&#34;対策&#34;&gt;対策&lt;/h1&gt;

&lt;p&gt;たいていの言語で &lt;code&gt;-no-pie&lt;/code&gt; を付けることで解決しています。 Position Independent Executableだっけ？&lt;/p&gt;

&lt;p&gt;アドホックにやる方法と恒久的に解決する方法とがあります。&lt;/p&gt;

&lt;h2 id=&#34;アドホックな方&#34;&gt;アドホックな方&lt;/h2&gt;

&lt;p&gt;簡単で、SML#で &lt;strong&gt;リンクする時&lt;/strong&gt; に &lt;code&gt;-Xlinker -no-pie&lt;/code&gt; を付けてあげます。&lt;/p&gt;

&lt;h2 id=&#34;恒久的な方&#34;&gt;恒久的な方&lt;/h2&gt;

&lt;p&gt;SML#を自前でビルドします。そのとき &lt;strong&gt;configure時&lt;/strong&gt; に &lt;code&gt;LDFLAGS=-no-pie&lt;/code&gt; を付けてあげます。&lt;/p&gt;

&lt;h1 id=&#34;余談&#34;&gt;余談&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;-no-pie&lt;/code&gt; はGCC 6以降で、それ以前は &lt;code&gt;-nopie&lt;/code&gt; との噂をききましたがGCC 6系しか手元にないので真偽のほどは分かりません。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustの関連型の使いどころ</title>
      <link>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</link>
      <pubDate>Tue, 22 Nov 2016 18:26:47 +0900</pubDate>
      
      <guid>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</guid>
      <description>&lt;p&gt;κeenです。昨日は&lt;a href=&#34;https://rust.connpass.com/event/41467/&#34;&gt;RustのLT会！ Rust入門者の集い - connpass&lt;/a&gt;に参加してきました。
そこで&lt;a href=&#34;http://qiita.com/tacke_jp/items/9c7617971dc341146c0f&#34;&gt;関連型に関する発表&lt;/a&gt;があったので感化されて私も一筆。&lt;/p&gt;

&lt;p&gt;
馴れないと関連型はジェネリクスでいいじゃんと思えますが、両者は別の機能を提供するものです。
設計による使い分けではなくて実現したいことに応じた機能による使い分けをするので馴れてしまえば迷うことなくどちらを使うか判断出来ます。&lt;/p&gt;

&lt;p&gt;ということで関連型のパターンをいくつか。
もちろん、根底にある関連型という機能は共通なのでほとんど同じようなことを言ってますが気持としてパターンを知っておくと便利です。&lt;/p&gt;

&lt;h1 id=&#34;型レベルの関数として&#34;&gt;型レベルの関数として&lt;/h1&gt;

&lt;p&gt;「関連」型なのである型に関連する型を表現します。ちょっと見方を変えると型から型への写像、つまり関数になります。
例えばこういうのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ToUnsigned {
    type Counterpart;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart;
}

impl ToUnsigned for i32 {
    type Counterpart = u32;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart {
        self as u32
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;i32&lt;/code&gt; から &lt;code&gt;u32&lt;/code&gt; への関数になってそうなのが見えますかね？もちろん、 &lt;code&gt;i64&lt;/code&gt; から &lt;code&gt;u64&lt;/code&gt; などへの対応も作れます。
こういうのは例えば符号無し数にのみ演算が定義されている場合とかに便利ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn write_bigendian_signed&amp;lt;I, U&amp;gt;(i: I) -&amp;gt; ()
    where I: ToUnsigned&amp;lt;Counterpart = U&amp;gt;,
          U: ...,  {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;トレイト内で使う型を固定するため&#34;&gt;トレイト内で使う型を固定するため&lt;/h1&gt;

&lt;p&gt;これが一番目にするやつじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Handler {
    type Request;
    type Response;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}

struct HTTPHandler;

impl Handler for HTTPHandler {
    type Request = HTTPRequest;
    type Response = HTTPResponse;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定というか特殊化というか、トレイト自体は汎用的に作られていて、それを実装する型が特定の処理に特化するパターンです。
ジェネリクスで受け取る訳にはいかなくて、実装すべき型をトレイトの中で定義してあげる必要があるのは分かると思います。&lt;/p&gt;

&lt;h1 id=&#34;関数の返り値を一般化するため&#34;&gt;関数の返り値を一般化するため&lt;/h1&gt;

&lt;p&gt;これは現在のRust(rust-1.13.0)が &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1522&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;をサポートしていないために必要になるテクニックです。
関連型とトレイト境界を組み合わせて使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ReverseIter {
    type Item;
    type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;
    fn rev_iter(&amp;amp;self) -&amp;gt; Iter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの &lt;code&gt;type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt; の方です。
返り値のIteratorを抽象化したいのですが、現在のRustでは&lt;code&gt;fn rev_iter(&amp;amp;self) -&amp;gt; Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt;のような書き方が出来ないので仕方なく関連型を使ってあげる必要があります。&lt;/p&gt;

&lt;p&gt;ちょっと踏み込んだ話をすると、関数の引数の多相性は∀の量化、返り値の多相は∃の量化です。そしてトレイトのジェネリクスも∀の量化で関連型が∃の量化なのでそういう対応がある訳です。&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;結構理論的にも色々あるようなので調べてみると様々なブログポストが見付かると思います。&lt;/p&gt;

&lt;p&gt;ぱぱっと思いついたパターンを3つ挙げました。もしかしたら他にもパターンがあるかもしれません。&lt;/p&gt;

&lt;p&gt;これを知っておけば&lt;a href=&#34;https://github.com/tokio-rs/tokio-service&#34;&gt;tokio-service&lt;/a&gt;の&lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;Service&lt;/a&gt;みたいな関連型を多用するパターンでもひるまなくなります。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;h2 id=&#34;関連型とimpl-traitに関して&#34;&gt;関連型とimpl Traitに関して&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rust-lang-ja.org/rust-by-example/generics/assoc_items/the_problem.html&#34;&gt;関連型が必要になる状況 | Rust by Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ncameron.org/blog/abstract-return-types-aka-%60impl-trait%60/&#34;&gt;Abstract return types, aka &lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;応用&#34;&gt;応用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2016/02/28/rustnohigherkinded_type_trait/&#34;&gt;RustのHigher-Kinded type Trait | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;発展的な話題&#34;&gt;発展的な話題&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/02/associated-type-constructors-part-1-basic-concepts-and-introduction/&#34;&gt;Associated type constructors, part 1: basic concepts and introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/03/associated-type-constructors-part-2-family-traits/&#34;&gt;Associated type constructors, part 2: family traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/04/associated-type-constructors-part-3-what-higher-kinded-types-might-look-like/&#34;&gt;Associated type constructors, part 3: What higher-kinded types might look like&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/09/associated-type-constructors-part-4-unifying-atc-and-hkt/&#34;&gt;Associated type constructors, part 4: Unifying ATC and HKT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1598&#34;&gt;Associated type constructors (a form of higher-kinded polymorphism). by withoutboats · Pull Request #1598 · rust-lang/rfcs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustの型レベルLispっぽいの作った</title>
      <link>/blog/2016/11/06/rustnokatareberulispppoinotsukutta</link>
      <pubDate>Sun, 06 Nov 2016 11:49:43 +0900</pubDate>
      
      <guid>/blog/2016/11/06/rustnokatareberulispppoinotsukutta</guid>
      <description>&lt;p&gt;κeenです。ふとした気紛れでRustの型レベルLispっぽいの作りました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;実装自体は&lt;a href=&#34;https://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/&#34;&gt;去年Scalaで作た時&lt;/a&gt;とほぼ同じ。
ただしRustでコンパイル時に文字列を処理しようとするとコンパイラプラグインが必要になるので今回はあきらめて素のRustの式のまま。&lt;/p&gt;

&lt;p&gt;こんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;println!(&amp;quot;{}&amp;quot;, eval!(List3&amp;lt;Add, _2, _3&amp;gt;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lisp…？感ありますがLispと言い張ります。&lt;/p&gt;

&lt;p&gt;少しだけ工夫した点はシンボルをアルファベットのListにすることで任意の文字列を表現出来るようにした点、関数を&lt;code&gt;Fun&lt;/code&gt; 、 &lt;code&gt;Fun2&lt;/code&gt; といったトレイトで抽象化することでユーザも関数を定義出来るようにした点です。&lt;/p&gt;

&lt;p&gt;例えばフィボナッチ数列は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub type Fib = Symbol&amp;lt;Sym3&amp;lt;F, I, B&amp;gt;&amp;gt;;

impl Fun1&amp;lt;_0&amp;gt; for Fib {
    type Out = _1;
}

impl Fun1&amp;lt;_1&amp;gt; for Fib {
    type Out = _1;
}

impl &amp;lt;T1N: Num, N1_O: Num, N2_O: Num, NO: Num&amp;gt;Fun1&amp;lt;Number&amp;lt;Succ&amp;lt;Succ&amp;lt;T1N&amp;gt;&amp;gt;&amp;gt;&amp;gt; for Fib
    where Fib: Fun1&amp;lt;Number&amp;lt;Succ&amp;lt;T1N&amp;gt;&amp;gt;, Out = Number&amp;lt;N1_O&amp;gt;&amp;gt;,
          Fib: Fun1&amp;lt;Number&amp;lt;     T1N &amp;gt;, Out = Number&amp;lt;N2_O&amp;gt;&amp;gt;,
          Add: Fun2&amp;lt;Number&amp;lt;N1_O&amp;gt;, Number&amp;lt;N2_O&amp;gt;, Out = Number&amp;lt;NO&amp;gt;&amp;gt;
{
    type Out = Number&amp;lt;NO&amp;gt;;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義出来ます。&lt;/p&gt;

&lt;p&gt;ただし、Rustの型検査が許す再帰深度がかなり小さいため、&lt;code&gt;List2&amp;lt;Fib, _6&amp;gt;&lt;/code&gt;で音を上げます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Compiling rustlisp v0.1.0 (file:///home/kim/Rust/rustlisp)
error[E0275]: overflow evaluating the requirement `_: std::marker::Sized`
 --&amp;gt; &amp;lt;rustlisp macros&amp;gt;:1:20
  |
1 | ( $ t : ty ) =&amp;gt; { &amp;lt;&amp;lt; $ t as Eval &amp;gt; :: Out as Expr &amp;gt; :: to_string (  ) }
  |                    ^^^^^^^^^^^^^^^^^^^^^^
src/main.rs:18:20: 18:41 note: in this expansion of eval! (defined in &amp;lt;rustlisp macros&amp;gt;)
&amp;lt;std macros&amp;gt;:2:27: 2:58 note: in this expansion of format_args!
&amp;lt;std macros&amp;gt;:3:1: 3:54 note: in this expansion of print! (defined in &amp;lt;std macros&amp;gt;)
src/main.rs:18:5: 18:43 note: in this expansion of println! (defined in &amp;lt;std macros&amp;gt;)
  |
  = note: consider adding a `#![recursion_limit=&amp;quot;128&amp;quot;]` attribute to your crate
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun2&amp;lt;rustlisp::num::Number&amp;lt;_&amp;gt;, rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::A, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::D, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::fun::Fun1&amp;lt;rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;` for `rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::F, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::I, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::B, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;`
  = note: required because of the requirements on the impl of `rustlisp::eval::Eval` for `rustlisp::cons::ConsCell&amp;lt;rustlisp::symbol::Symbol&amp;lt;rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::F, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::I, rustlisp::symbol::SymCons&amp;lt;rustlisp::symbol::B, rustlisp::symbol::Eos&amp;gt;&amp;gt;&amp;gt;&amp;gt;, rustlisp::cons::ConsCell&amp;lt;rustlisp::num::Number&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Succ&amp;lt;rustlisp::num::Zero&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;, rustlisp::cons::Nil&amp;gt;&amp;gt;`

error: aborting due to previous error

error: Could not compile `rustlisp`.

To learn more, run the command again with --verbose.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スタックを作ってどうこう、とかも考えたのですが上手くいきませんでした。悲しい。&lt;/p&gt;

&lt;p&gt;ということで小ネタでした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>VMwareのUbuntuを16.10にしたら起動しなくなった</title>
      <link>/blog/2016/10/31/vmwarenoubuntuwo16_10nishitarakidoushinakunatta</link>
      <pubDate>Mon, 31 Oct 2016 22:06:17 +0900</pubDate>
      
      <guid>/blog/2016/10/31/vmwarenoubuntuwo16_10nishitarakidoushinakunatta</guid>
      <description>&lt;p&gt;κeenです。普段はネイティブのUbuntuを使ってますが会社では使えないのでVMwareにUbuntuを入れて使っています。
今日そのUbuntuを16.04から16.10にアップグレードしたら起動しなくなったので対策メモ。&lt;/p&gt;

&lt;p&gt;
現象は、Ubuntuを起動しようとするとゲストOSによってCPUがオフにされた旨の通知が来てフリーズします。
このリリースノート（&lt;a href=&#34;http://pubs.vmware.com/Release_Notes/en/fusion/8/fusion-851-release-notes.html&#34;&gt;VMware Fusion 8.5.1 Release Notes&lt;/a&gt;）を見れば分かりますが、Linux Kernel 4.7以上を使うと発生するバグのようです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Known Issues&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Virtual machines running Linux kernel version 4.7 or above may crash or hang on hosts with Intel CPUs

Virtual Machines running Linux kernel version 4.7 or above may crash during installation or during power-on with a crash in the intel_powerclamp driver. This issue has been reported with Ubuntu 16.10, but it is a generic Linux kernel issue.

Workaround: VMware is working with the OS vendors to have them fix their respective kernels. Until a fix is available, you can blacklist the intel_powerclamp driver so that the buggy code doesn&#39;t get loaded.

To blacklist the driver:

Add the kernel command-line option modprobe.blacklist=intel_powerclamp to the guest OS&#39;s default grub configuration or add it directly at the grub menu during boot.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;どうやらIntel CPUのホストだと特定のカーネルモジュールが誤動作してCPUをoffってしまうっぽい？OSベンダと協力して直していくと言っているのでVMwareのアップデートでは直らなそう。OSのアップデートはそもそも起動しないので出来ない、というかなりキツい状況です。
幸いにもワークアラウンドがあるのでそれを使って起動、修正します。&lt;/p&gt;

&lt;h1 id=&#34;ubuntuの起動&#34;&gt;Ubuntuの起動&lt;/h1&gt;

&lt;p&gt;誤動作するカーネルモジュールをロードしないようにしたら起動するっぽいです。&lt;/p&gt;

&lt;p&gt;今OSがハングしている状態ならとりあえず殺して、 &lt;code&gt;ESC&lt;/code&gt; キー(多分。もしかしたら &lt;code&gt;Shift&lt;/code&gt; かも)を押しながらUbuntuを起動します。そうするとgrub menuの画面に遷移する筈です。&lt;/p&gt;

&lt;p&gt;grub menuで（恐らく1番上にある）使用中のカーネルに選択肢を合わせた状態で&lt;code&gt;e&lt;/code&gt;を押すと起動シーケンスをいじれるようになります。&lt;/p&gt;

&lt;p&gt;Emacsっぽく操作出来る画面が出てくるので&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	linux	/vmlinuz-4.4.0-45-generic root=/dev/mapper/ubuntu--vg-root ro  quiet splash $vt_handoff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにLinuxカーネルを起動してるっぽい行に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	linux	/vmlinuz-4.4.0-45-generic root=/dev/mapper/ubuntu--vg-root ro  quiet splash $vt_handoff modprobe.blacklist=intel_powerclamp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と &lt;code&gt;modprobe.blacklist=intel_powerclamp&lt;/code&gt; を追加してあげれば起動します。&lt;/p&gt;

&lt;h1 id=&#34;起動オプションの変更&#34;&gt;起動オプションの変更&lt;/h1&gt;

&lt;p&gt;とりあえず今のでワンショットで起動出来るようになったので起動オプションの設定を変更して次回以降も起動出来るようにしておきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/default/grub&lt;/code&gt; をいじれば良いようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GRUB_CMDLINE_LINUX=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の行をこれまた&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GRUB_CMDLINE_LINUX=&amp;quot;modprobe.blacklist=intel_powerclamp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と &lt;code&gt;modprobe.blacklist=intel_powerclamp&lt;/code&gt; を追加するように書き換えてあげて、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo update-grub2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でgrubに変更を反映してあげればOKです。&lt;/p&gt;

&lt;h1 id=&#34;その他&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;Ubuntu 16.10を1日使ってみましたが特に不自由なく使えています。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのクロージャ3種を作って理解する</title>
      <link>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</link>
      <pubDate>Mon, 10 Oct 2016 16:48:43 +0900</pubDate>
      
      <guid>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</guid>
      <description>&lt;p&gt;κeenです。Rustのクロージャ、3種類もあって複雑ですよね。
こういう複雑なものはRustの気持になって考えれば理解出来たりします。ということで手でクロージャを作って理解してみましょう。&lt;/p&gt;

&lt;p&gt;尚、これはRustの1.12.0-stableと1.14.0-nightly (6e8f92f11 2016-10-07)で実験しています。
&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;関数 - 関数&lt;/li&gt;
&lt;li&gt;無名関数 - 名前のついていない関数&lt;/li&gt;
&lt;li&gt;自由変数 - そのスコープの中で束縛されていない変数&lt;/li&gt;
&lt;li&gt;クロージャ - 関数に、自由変数の値(環境)もくっつけてそれだけで閉じるようにしたもの&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;クロージャについては関数が閉じ込める環境だけを指してクロージャとする人もいますが、ここでは関数本体と環境を合わせてクロージャとします。&lt;/p&gt;

&lt;p&gt;よく、無名関数とクロージャ(関数閉包)を一緒くたにすることがありますが明確に区別しましょう。まあ、大抵の無名関数はクロージャになりますが、動的スコープの言語みたいにそうならないケースもあります。&lt;/p&gt;

&lt;p&gt;余談ですが「ラムダ式」は言語がよく無名関数に付ける名前です。「関数」も言語によって「手続き」だったり「メソッド」だったりしますね。&lt;/p&gt;

&lt;h1 id=&#34;fnonce-fnmut-fn&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、「作って理解する」なので例を出します。なんかよく分からないけど0から9の値に1を足して印字するプログラムです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = |arg|{ i + arg };
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無名関数を作って &lt;code&gt;cls&lt;/code&gt; という変数に束縛しています。 &lt;code&gt;cls&lt;/code&gt; は自由変数 &lt;code&gt;i&lt;/code&gt; を含みますので、 &lt;code&gt;cls&lt;/code&gt; のクロージャを取ると 「&lt;code&gt;cls&lt;/code&gt; の定義 + &lt;code&gt;i&lt;/code&gt; の定義」になります。&lt;/p&gt;

&lt;p&gt;では &lt;code&gt;i&lt;/code&gt; という変数を保持したオブジェクトを作りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Closure {
    i: isize,
}


fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // もちろん、Closureは関数でないので呼び出せない
        // println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このままだと &lt;code&gt;cls&lt;/code&gt; は呼び出せません。しかし &lt;code&gt;+&lt;/code&gt; なんかのオーバーロードを許しているRustはなんと関数呼び出し構文 &lt;code&gt;name(arg, ...)&lt;/code&gt; もオーバーロード出来ます。実装すべきトレイトは &lt;code&gt;std::ops::{FnOnce, FnMut, Fn}&lt;/code&gt; です。これがクロージャ3種です。&lt;/p&gt;

&lt;p&gt;これらは継承関係にあって、上から順に &lt;code&gt;FnOnce&lt;/code&gt;  &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait FnOnce&amp;lt;Args&amp;gt; {
    type Output;
    extern &amp;quot;rust-call&amp;quot; fn call_once(self, args: Args) -&amp;gt; Self::Output;
}

pub trait FnMut&amp;lt;Args&amp;gt;: FnOnce&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, args: Args) -&amp;gt; Self::Output;
}

pub trait Fn&amp;lt;Args&amp;gt;: FnMut&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, args: Args) -&amp;gt; Self::Output;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらの違いは &lt;code&gt;self&lt;/code&gt; をムーブして受け取るか &lt;code&gt;&amp;amp;mut&lt;/code&gt; で受けるか &lt;code&gt;&amp;amp;&lt;/code&gt; で受けるかです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;とりあえず先程の &lt;code&gt;Closure&lt;/code&gt; にこれを実装してみましょう。ちょいとunstableな機能なようなので &lt;code&gt;feature&lt;/code&gt; を使って、nightlyでコンパイルするようにしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

// 再掲
struct Closure {
    i: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
    type Output = isize;

    extern &amp;quot;rust-call&amp;quot; fn call_once(self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.i + arg
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで呼び出しが出来る筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = Closure {i: i};
        // 呼出せるようになる
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;勿論、これは以下のように明示的にメソッドを呼んでも同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // メソッドで呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls.call_once((x, )));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fnmut-fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;FnOnce&lt;/code&gt; で出来るんならなんで &lt;code&gt;FnMut&lt;/code&gt; と &lt;code&gt;FnMut&lt;/code&gt; が存在するかというと、クロージャが閉じ込めた環境の所有権の問題ですね。&lt;/p&gt;

&lt;p&gt;例えば以下のコードを手で実装してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = |arg| { x + arg};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程と同じ &lt;code&gt;Closure&lt;/code&gt; ではコンパイル出来ません（統一感のために &lt;code&gt;Closure&lt;/code&gt; のメンバ名を変えました）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

struct Closure {
    x: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
  // ...略
}


fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = Closure {x: x};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error[E0382]: use of moved value: `cls`
  --&amp;gt; closure.rs:45:28
   |
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ value moved here in previous iteration of loop
   |
   = note: move occurs because `cls` has type `Closure`, which does not implement the `Copy` trait

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1回目のループでは問題ないのですが &lt;code&gt;call_once(self, (arg, ): (isize,))&lt;/code&gt; の呼び出しでムーブしてしまうので2回目以降は呼べません。ということで1つ下のトレイト、 &lt;code&gt;FnMut&lt;/code&gt; も実装してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl FnMut&amp;lt;(isize,)&amp;gt; for Closure {

    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はこれでも怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:45:28
   |
43 |         let cls = Closure {x: x};
   |             --- use `mut cls` here to make mutable
44 |         for i in 0..10 {
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ cannot borrow mutably

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;mut&lt;/code&gt; を要求しているから。正確にはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略


fn main() {
    let x = 1;
    // `mut` を付ける
    let mut cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。しかしまあ、何か書き換えてる訳でもないのに &lt;code&gt;mut&lt;/code&gt; が付いているのは嫌ですね。&lt;code&gt;mut&lt;/code&gt; を要求しないように定義してあげようと思ったら &lt;code&gt;Fn&lt;/code&gt; が必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl Fn&amp;lt;(isize,)&amp;gt; for Closure {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, (arg,): (isize, )) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。&lt;/p&gt;

&lt;h2 id=&#34;整理&#34;&gt;整理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;クロージャとは関数とその環境のセットだよ&lt;/li&gt;
&lt;li&gt;環境にも所有権はあるよ&lt;/li&gt;
&lt;li&gt;Rustは所有権でクロージャの呼び出しを使い分けるよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;構文&#34;&gt;構文&lt;/h1&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; に対応するRustの構文を探っていきます。&lt;/p&gt;

&lt;h2 id=&#34;fn&#34;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;先程 &lt;code&gt;Fn&lt;/code&gt; まで実装しないとコンパイルが通らなかった&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    let cls = |arg| { x + arg};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は &lt;code&gt;||{}&lt;/code&gt; でコンパイルが通っているので &lt;code&gt;||{}&lt;/code&gt; は &lt;code&gt;Fn&lt;/code&gt; を作るようです。&lt;/p&gt;

&lt;h2 id=&#34;fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;call_mut&lt;/code&gt; を要求しそうにちょっと変えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、予想通りエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:37:13
   |
35 |         let cls = |arg|{ x += arg };
   |             --- use `mut cls` here to make mutable
36 |         for i in 0..10 {
37 |             cls(i);
   |             ^^^ cannot borrow mutably

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let cls = |arg|{ x += arg };
   |                   -----  - previous borrow occurs due to use of `x` in closure
   |                   |
   |                   mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to 2 previous errors

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程の &lt;code&gt;FnMut&lt;/code&gt; の例のように &lt;code&gt;cls&lt;/code&gt; に &lt;code&gt;mut&lt;/code&gt; を付けてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let mut cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これでもエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let mut cls = |arg|{ x += arg };
   |                       -----  - previous borrow occurs due to use of `x` in closure
   |                       |
   |                       mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;cls&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; を捕捉し続けているから。これは &lt;code&gt;cls&lt;/code&gt; のライフタイムを &lt;code&gt;println!&lt;/code&gt; の前で終わらせてあげると解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    {
        // `{}` でスコープを作ることでライフタイムをコントロールする
        let mut cls = |arg|{ x += arg };
        for i in 0..10 {
            cls(i);
        }
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FnMut&lt;/code&gt; は変数を &lt;code&gt;mut&lt;/code&gt; にする無名関数と同じなようです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce-1&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; は？ &lt;code&gt;std::mem::drop&lt;/code&gt; を使って所有権を無理矢理奪うクロージャを作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::drop;

fn main() {
    let x = String::new();
    let cls = || {drop(x)};
    cls();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、実はこれでOKです。冷静に考えたら &lt;code&gt;FnOnce&lt;/code&gt; を継承している &lt;code&gt;Fn&lt;/code&gt; を &lt;code&gt;||{}&lt;/code&gt; で作れた時点で問題ありませんでしたね。&lt;/p&gt;

&lt;h1 id=&#34;落穂拾い&#34;&gt;落穂拾い&lt;/h1&gt;

&lt;h2 id=&#34;move-クロージャ&#34;&gt;&lt;code&gt;move&lt;/code&gt; クロージャ&lt;/h2&gt;

&lt;p&gt;じゃあ、Rustが良い感じに使い分けてくれるなら &lt;code&gt;move&lt;/code&gt; クロージャって何のためにあるの？と思いますが、これは環境を捕捉する際に &lt;code&gt;Copy&lt;/code&gt; なんかが起こらないようにするためのものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; しない例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; する例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt; は環境 &lt;strong&gt;へ&lt;/strong&gt; 所有権を移すかどうか、 &lt;code&gt;FnOnce&lt;/code&gt; などは環境 &lt;strong&gt;から&lt;/strong&gt; 所有権を移すかどうかです。&lt;/p&gt;

&lt;h2 id=&#34;関数ポインタ&#34;&gt;関数ポインタ&lt;/h2&gt;

&lt;p&gt;クロージャを持たない関数は、 &lt;code&gt;fn(i32) -&amp;gt; i32&lt;/code&gt; のような型を持ちます。これは空の環境を持つクロージャと同じですね。空の環境に所有権も何もないのでプリミティブの &lt;code&gt;fn&lt;/code&gt; は &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; のいずれとしても振舞います。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;p&gt;ここまで書いて普通にドキュメントに詳しく載っているのに気付きました（汗&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/functions.html&#34;&gt;関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>SMLでモナド</title>
      <link>/blog/2016/10/10/smldemonado</link>
      <pubDate>Mon, 10 Oct 2016 11:05:38 +0900</pubDate>
      
      <guid>/blog/2016/10/10/smldemonado</guid>
      <description>&lt;p&gt;κeenです。ML Workshop 2016でなんかSMLで型クラスする発表があったらしいので追ってみます。&lt;/p&gt;

&lt;p&gt;implicit parameterをexplicitに渡すのではなく、モジュールとファンクタを使った実装です。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;前置き&#34;&gt;前置き&lt;/h1&gt;

&lt;p&gt;Haskell風の中置演算子を使うので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;infix 4 &amp;lt;$&amp;gt; &amp;lt;$ $&amp;gt;  &amp;lt;*&amp;gt; &amp;lt;* *&amp;gt;
infix 1 &amp;gt;&amp;gt;= &amp;gt;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を予め宣言しておきます。&lt;/p&gt;

&lt;h1 id=&#34;最初の試み&#34;&gt;最初の試み&lt;/h1&gt;

&lt;p&gt;さて、(MLの機能の方ではない)functorを考えましょうか。functorには &lt;code&gt;fmap&lt;/code&gt; が要求され、&lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; なんかが実装されます。それを素直に表したらこうなるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature FUNCTOR_MIN = sig
    type &#39;a t
    val fmap: (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature FUNCTOR = sig
    include FUNCTOR_MIN
    val &amp;lt;$&amp;gt; : (&#39;a -&amp;gt; &#39;b) * &#39;a t -&amp;gt; &#39;b t
    val &amp;lt;$ : &#39;a *  &#39;b t -&amp;gt;  &#39;a t
    val $&amp;gt; : &#39;a t *  &#39;b  -&amp;gt;  &#39;b t
    val void: &#39;a t -&amp;gt; unit t
end

functor MkFunctor(Fun: FUNCTOR_MIN): FUNCTOR = struct
    open Fun

    fun f &amp;lt;$&amp;gt; fa = fmap f fa
    fun a &amp;lt;$ fb =  (fn _ =&amp;gt; a) &amp;lt;$&amp;gt; fb
    fun fa $&amp;gt; b = b &amp;lt;$ fa
    fun void fa = () &amp;lt;$ fa
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、さらにそのサブクラスのapplicativeも作ります。 &lt;code&gt;include&lt;/code&gt; を使うことで &lt;code&gt;FUNCTOR&lt;/code&gt; を継承することを表します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature APPLICATIVE_MIN = sig
    include FUNCTOR

    val pure: &#39;a -&amp;gt; &#39;a t
    val ap : (&#39;a -&amp;gt; &#39;b) t -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature APPLICATIVE = sig
    include APPLICATIVE_MIN

    val &amp;lt;*&amp;gt; : (&#39;a -&amp;gt; &#39;b) t * &#39;a t -&amp;gt; &#39;b t
    val *&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
    val &amp;lt;* : &#39;a t * &#39;b t -&amp;gt; &#39;a t
end

functor MkApplicative(App: APPLICATIVE_MIN): APPLICATIVE = struct
    open App

    fun af &amp;lt;*&amp;gt; aa = ap af aa
    fun aa *&amp;gt; ab = pure (fn _ =&amp;gt; fn x =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
    fun aa &amp;lt;* ab = pure (fn x =&amp;gt; fn _ =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにmonadも作りましょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature MONAD_MIN = sig
    include APPLICATIVE

    val bind : &#39;a t -&amp;gt; (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
end

signature MONAD = sig
    include MONAD_MIN

    val return: &#39;a -&amp;gt; &#39;a t
    val &amp;gt;&amp;gt;= : &#39;a t * (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
    val &amp;gt;&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
end


functor MkMonad(M: MONAD_MIN): MONAD = struct
    open M

    val return = pure
    fun ma &amp;gt;&amp;gt;= f = bind ma f
    fun ma &amp;gt;&amp;gt; mb = ma &amp;gt;&amp;gt;= (fn _ =&amp;gt; mb)

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと使ってみましょう。1つ1つインスタンスを作ってあげます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;structure OptionFunc = MkFunctor(
  struct
      type &#39;a t = &#39;a option
      fun fmap f = Option.map f
  end)

structure OptionApp = MkApplicative(
  struct
      open OptionFunc
      fun pure x = SOME(x)
      fun ap af aa = case (af, aa) of
                         (SOME(f), SOME(a)) =&amp;gt; SOME(f a)
                       | _ =&amp;gt; NONE
  end)

structure OptionMonad = MkMonad(
  struct
      open OptionApp
      fun bind ma f = case ma of
                          SOME(a) =&amp;gt; f a
                        | NONE =&amp;gt; NONE
  end)


local
    open OptionMonad
in
    fun add x y = x + y
    fun println s = print (s ^ &amp;quot;\n&amp;quot;)

    val ret1 = add &amp;lt;$&amp;gt; SOME(1) &amp;lt;*&amp;gt; SOME(2)
    val ret2 = SOME(1) &amp;gt;&amp;gt;= (fn x =&amp;gt;
               SOME(2) &amp;gt;&amp;gt;= (fn y =&amp;gt;
               return (x + y)))
    val () = Option.app (println o Int.toString) ret1 (* =&amp;gt; 3 *)
    val () = Option.app (println o Int.toString) ret2 (* =&amp;gt; 3 *)
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きました。&lt;/p&gt;

&lt;p&gt;さて、一見これで良さそうですがML Workshopでの発表では問題点を2点指摘しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Monadのインスタンスが欲しいだけなのにFunctorまで遡って作らないといけない&lt;/li&gt;
&lt;li&gt;ダイアモンド継承が起きた時に共通の親クラスの実装の一貫性を保障出来ない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とのことです。私はこの問題点自体割と疑問なのですがまあ、問題らしいです。&lt;/p&gt;

&lt;h1 id=&#34;解決案&#34;&gt;解決案&lt;/h1&gt;

&lt;p&gt;継承のやり方をちょいと変えます。&lt;code&gt;Functor&lt;/code&gt; までは先程と同じなのですが、Applicativeは
APPLICATIVE_MINにFUNCTORをincludeしません。また、衝突の問題から型が &lt;code&gt;applicative&lt;/code&gt;になります（同じと言っちゃいましたがFunctorの方も &lt;code&gt;functor_&lt;/code&gt; になってます）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature APPLICATIVE_MIN = sig
    type &#39;a applicative
    val pure: &#39;a -&amp;gt; &#39;a applicative
    val ap : (&#39;a -&amp;gt; &#39;b) applicative -&amp;gt; &#39;a applicative -&amp;gt; &#39;b applicative
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてAPPLICATIVEの方でincludeします。ここで &lt;code&gt;sharing&lt;/code&gt; 制約を付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature APPLICATIVE = sig
    include FUNCTOR APPLICATIVE_MIN
    sharing type functor_ = applicative

    val &amp;lt;*&amp;gt; : (&#39;a -&amp;gt; &#39;b) applicative * &#39;a applicative -&amp;gt; &#39;b applicative
    val *&amp;gt; : &#39;a applicative * &#39;b applicative -&amp;gt; &#39;b applicative
    val &amp;lt;* : &#39;a applicative * &#39;b applicative -&amp;gt; &#39;a applicative
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、 &lt;code&gt;APPLICATIVE_MIN&lt;/code&gt; から &lt;code&gt;FUNCTOR_MIN&lt;/code&gt; を生成するファンクタを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;functor ApplicativeMinToFunctorMin(A: APPLICATIVE_MIN): FUNCTOR_MIN = struct
    open A
    type &#39;a functor_ = &#39;a applicative
    fun fmap f = ap (pure f)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;applicativeからfunctor????感ありますがとりあえず進みます。&lt;/p&gt;

&lt;p&gt;で、 &lt;code&gt;MkApplicative&lt;/code&gt; は一旦内部で &lt;code&gt;Functor&lt;/code&gt; を作ってそれを &lt;code&gt;open&lt;/code&gt; します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;functor MkApplicative(App: APPLICATIVE_MIN): APPLICATIVE = struct
    type &#39;a applicative = &#39;a App.applicative

    structure FunctorMin = ApplicativeMinToFunctorMin(App)
    structure Functor = MkFunctor(FunctorMin)
    open App Functor

    fun af &amp;lt;*&amp;gt; aa = ap af aa
    fun aa *&amp;gt; ab = pure (fn _ =&amp;gt; fn x =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
    fun aa &amp;lt;* ab = pure (fn x =&amp;gt; fn _ =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モナドも同じですね。ただ、 &lt;code&gt;MONAD_MIN&lt;/code&gt; から &lt;code&gt;APPLICATIVE_MIN&lt;/code&gt; を生成する必要があるので &lt;code&gt;MONAD_MIN&lt;/code&gt; のシグネチャに &lt;code&gt;return&lt;/code&gt; が増えてます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;signature MONAD_MIN = sig
    type &#39;a monad
    val return: &#39;a -&amp;gt; &#39;a monad
    val bind : &#39;a monad -&amp;gt; (&#39;a -&amp;gt; &#39;b monad) -&amp;gt; &#39;b monad
end

signature MONAD = sig
    include APPLICATIVE MONAD_MIN
    sharing type applicative = monad
    val &amp;gt;&amp;gt;= : &#39;a monad * (&#39;a -&amp;gt; &#39;b monad) -&amp;gt; &#39;b monad
    val &amp;gt;&amp;gt; : &#39;a monad * &#39;b monad -&amp;gt; &#39;b monad
end

functor MonadMinToApplicativeMin(M: MONAD_MIN): APPLICATIVE_MIN = struct
    open M
    type &#39;a applicative = &#39;a monad
    val pure = return
    fun ap mf ma =  bind mf (fn f =&amp;gt;
                    bind ma (fn a =&amp;gt;
                    return (f a)))
end

functor MkMonad(M: MONAD_MIN): MONAD = struct
    type &#39;a monad = &#39;a M.monad
    structure AppMin = MonadMinToApplicativeMin(M)
    structure App = MkApplicative(AppMin)
    open M App

    fun ma &amp;gt;&amp;gt;= f = bind ma f
    fun ma &amp;gt;&amp;gt; mb = ma &amp;gt;&amp;gt;= (fn _ =&amp;gt; mb)

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと &lt;code&gt;ap&lt;/code&gt; の実装イケてないなぁと思いつつ先に進みます。&lt;/p&gt;

&lt;p&gt;さて、使ってみましょう。今度はファンクタの適用は一回で済みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;structure ListMonad = MkMonad(struct
                                   type &#39;a monad = &#39;a list
                                   fun return x = [x]
                                   fun bind ma f = List.concat (List.map f ma)
                              end)
local
    open ListMonad
in
    val ret = [1, 2, 3] &amp;gt;&amp;gt;= (fn x =&amp;gt;
              [4, 5, 6] &amp;gt;&amp;gt;= (fn y =&amp;gt;
              return (x + y)))
    fun println s = print (s ^ &amp;quot;\n&amp;quot;)

    val () = List.app (println o Int.toString) ret
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きます。
ご覧の通り、ファンクタの適用は1回で済んでますし、親クラスのインスタンス全て自分で生成しているので実装の一貫性も保障出来ます。ダイアモンド継承が来ても安心ですね！&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;私は最初のアプローチの方が好きですね（率直）。&lt;/p&gt;

&lt;p&gt;それぞれのクラスのインスタンスを作るのは自然だと思いますし実はWorkshopのアプローチは表層上の問題でダイアモンド継承を解決出来ていません。名前衝突が起きます。モジュールの名前衝突ならまだ気合で( &lt;code&gt;val &amp;gt;&amp;gt;= = Monad.&amp;gt;&amp;gt;=&lt;/code&gt; のように全て手で)解決出来ますが、シグネチャの方は解決策はなさそうです(いや、シグネチャを使わずに全て手で書き直すとかは可能ですが)。どうせ完全には解決出来てない問題のために実装が曲がるのは好みではないです。&lt;/p&gt;

&lt;h1 id=&#34;付録a-ダイアモンド継承に強そうなアプローチ&#34;&gt;付録A ダイアモンド継承に強そうなアプローチ&lt;/h1&gt;

&lt;p&gt;単純に親クラスのインクルードをやめます。んで親クラスは名前空間の汚染を防ぐためにモジュールに入ったまま受け取ることにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;infix 4 &amp;lt;$&amp;gt; &amp;lt;$ $&amp;gt;  &amp;lt;*&amp;gt; &amp;lt;* *&amp;gt;
infix 1 &amp;gt;&amp;gt;= &amp;gt;&amp;gt;

signature FUNCTOR_MIN = sig
    type &#39;a t
    val fmap: (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature FUNCTOR = sig
    include FUNCTOR_MIN
    val &amp;lt;$&amp;gt; : (&#39;a -&amp;gt; &#39;b) * &#39;a t -&amp;gt; &#39;b t
    val &amp;lt;$ : &#39;a *  &#39;b t -&amp;gt;  &#39;a t
    val $&amp;gt; : &#39;a t *  &#39;b  -&amp;gt;  &#39;b t
    val void: &#39;a t -&amp;gt; unit t
end

functor MkFunctor(Fun: FUNCTOR_MIN): FUNCTOR = struct
    open Fun

    fun f &amp;lt;$&amp;gt; fa = fmap f fa
    fun a &amp;lt;$ fb =  (fn _ =&amp;gt; a) &amp;lt;$&amp;gt; fb
    fun fa $&amp;gt; b = b &amp;lt;$ fa
    fun void fa = () &amp;lt;$ fa
end

signature APPLICATIVE_MIN = sig
    type &#39;a t
    val pure: &#39;a -&amp;gt; &#39;a t
    val ap : (&#39;a -&amp;gt; &#39;b) t -&amp;gt; &#39;a t -&amp;gt; &#39;b t
end

signature APPLICATIVE = sig
    include APPLICATIVE_MIN

    val &amp;lt;*&amp;gt; : (&#39;a -&amp;gt; &#39;b) t * &#39;a t -&amp;gt; &#39;b t
    val *&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
    val &amp;lt;* : &#39;a t * &#39;b t -&amp;gt; &#39;a t
end

functor MkApplicative(App: sig
                          structure Functor: FUNCTOR
                          include APPLICATIVE_MIN
                          sharing type Functor.t = t
                         end): APPLICATIVE = struct
    open App
    type &#39;a t = &#39;a t

    fun af &amp;lt;*&amp;gt; aa = ap af aa
    fun aa *&amp;gt; ab = pure (fn _ =&amp;gt; fn x =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
    fun aa &amp;lt;* ab = pure (fn x =&amp;gt; fn _ =&amp;gt; x) &amp;lt;*&amp;gt; aa &amp;lt;*&amp;gt; ab
end


signature MONAD_MIN = sig
    type &#39;a t
    val return: &#39;a -&amp;gt; &#39;a t
    val bind : &#39;a t -&amp;gt; (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
end

signature MONAD = sig
    include MONAD_MIN
    val &amp;gt;&amp;gt;= : &#39;a t * (&#39;a -&amp;gt; &#39;b t) -&amp;gt; &#39;b t
    val &amp;gt;&amp;gt; : &#39;a t * &#39;b t -&amp;gt; &#39;b t
end


functor MkMonad(M: sig
                    structure Applicative: APPLICATIVE
                    include MONAD_MIN
                    sharing type Applicative.t = t
                end): MONAD = struct
    open M
    type &#39;a t = &#39;a t

    fun ma &amp;gt;&amp;gt;= f = bind ma f
    fun ma &amp;gt;&amp;gt; mb = ma &amp;gt;&amp;gt;= (fn _ =&amp;gt; mb)

end


structure ListFunctor = MkFunctor(struct
                                       type &#39;a t = &#39;a list
                                       val fmap = List.map end)
structure ListApplicative = MkApplicative(struct
                                               structure Functor = ListFunctor
                                               type &#39;a t = &#39;a list
                                               fun pure x = [x]
                                               fun ap af aa = List.concat (List.map (fn a =&amp;gt; List.map (fn f =&amp;gt; f a) af) aa)
                                           end)
structure ListMonad = MkMonad(struct
                                   structure Applicative = ListApplicative
                                   type &#39;a t = &#39;a list
                                   fun return x = [x]
                                   fun bind ma f = List.concat (List.map f ma)
                               end)
local
    open ListFunctor
    open ListApplicative
    open ListMonad
in
    fun add x y = x + y
    val ret1 = [1, 2, 3] &amp;gt;&amp;gt;= (fn x =&amp;gt;
               [4, 5, 6] &amp;gt;&amp;gt;= (fn y =&amp;gt;
               return (x + y)))
    val ret2 = add &amp;lt;$&amp;gt; [1, 2, 3] &amp;lt;*&amp;gt; pure 1
    fun println s = print (s ^ &amp;quot;\n&amp;quot;)

    val () = List.app (println o Int.toString) ret1
    val () = List.app (println o Int.toString) ret2
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;付録b-do記法&#34;&gt;付録B do記法&lt;/h1&gt;

&lt;p&gt;ちょっと &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; が入り乱れるのはつらいですね。&lt;a href=&#34;https://github.com/br0ns/PreML&#34;&gt;PreML&lt;/a&gt;というSMLのプリプロセッサがあって、do記法（など）のシンタックスシュガーを提供してくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;val ret = do with ListMonad;
    x &amp;lt;- [1, 2, 3];
    y &amp;lt;- [4, 5, 6];
    return (x + y)
end
fun println s = print (s ^ &amp;quot;\n&amp;quot;)

val () = List.app (println o Int.toString) ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成されるコードはこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-standard-ml&#34;&gt;val ret = let infix 0 &amp;gt;&amp;gt;= val op&amp;gt;&amp;gt;= = ListMonad.&amp;gt;&amp;gt;= val return = ListMonad.return in ( 
         [1, 2, 3] ) &amp;gt;&amp;gt;= (fn  x =&amp;gt; ( 
         [4, 5, 6] ) &amp;gt;&amp;gt;= (fn  y =&amp;gt; 
    return (x + y) ) ) end 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;マシになりましたね。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>