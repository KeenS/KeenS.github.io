<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on κeenのHappy Hacκing Blog </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>/post/index.xml/</link>
    <language>en-us</language>
    
    
    <updated>Sat, 07 Feb 2015 14:27:58 UTC</updated>
    
    <item>
      <title>就活について思ったことをここに書き記す</title>
      <link>/blog/2015/02/07/shuukatsunitsuiteomottakotowokokonikakishirusu</link>
      <pubDate>Sat, 07 Feb 2015 14:27:58 UTC</pubDate>
      
      <guid>/blog/2015/02/07/shuukatsunitsuiteomottakotowokokonikakishirusu</guid>
      <description>

&lt;p&gt;私は今4年生なので去年の今頃は就活なんてものをしていた。下の代から若干日程が変わっているがそろそろ就活ムードが出てきているのでなんか吐いておく。思い出かもしれないし愚痴かもしれないし毒かもしれない。経験かもしれないし他人の代弁かもしれない。後輩の役に立つかもしれないし人事の方に向けたメッセージかもしれない。&lt;/p&gt;

&lt;p&gt;念のために書いておくが私はIT系の会社のプログラマ、エンジニア職ばかり応募していた。他の業界、職種に当て嵌まるとは限らない。&lt;/p&gt;

&lt;p&gt;注意&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;良かった企業は名前を出す、悪かった企業はここには名前を書かない方針にする。悪かった企業の具体名が知りたかったら&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt;に訊いて下さい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;リクナビ、メール&lt;/h1&gt;

&lt;p&gt;周りの流れに乗せられてリクナビに登録することになる。個人情報を大量に打ち込む。すると大量のメールが届く。正直、情報量はゼロに近い。メールは受信しないにチェックした方が良い。&lt;/p&gt;

&lt;p&gt;リクナビの価値は3割くらいがポータルサイトとしての価値、残り7割くらいがリクナビ経由でしか募集してない企業にエントリーするためだけのもの。そういう企業にエントリーしないならリクナビにはあまり近寄らない方が良い。リクナビのサイトは非常に良く出来ていて、不安を煽る情報を的確に伝えてくる。本当にその辺の企業のサイトに爪の垢を煎じて飲ませてやりたいくらいに良く出来ている。&lt;/p&gt;

&lt;p&gt;一応何社かはリクナビ経由で知ってエントリーした。一々個人情報を手打することなくワンクリックでエントリー出来るのは負担を軽減してくれる。統一されたUIで情報を見れるのにはそれなりの価値はある。でもあまり齧りつきすぎると毒に冒される。2週間程放置しておくと「企業からの特別オファー」なる量産メッセージが1000通くらい溜まる。&lt;/p&gt;

&lt;p&gt;Twitterや勉強会で社員と知り合って採用情報などを得られるならそっちを頼った方が良い。Twitterに流れてくる情報の方が有用。&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;説明会&lt;/h1&gt;

&lt;p&gt;エントリーに必須でない限り行かなかった。少なくともIT系企業ならWebページの採用情報が一番情報が充実して然るべきだ。&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;マイページ、エントリーシート、性格診断&lt;/h1&gt;

&lt;p&gt;リクナビ経由でエントリーしても結局は企業毎のマイページなるものに登録し、そこで情報を得ないといけない。エントリーシートの提出や面接の登録など。&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;マイページ&lt;/h2&gt;

&lt;p&gt;IT系の企業ならまずはそのマイページが評価基準になる。外注としても最低限のラインというのがある筈だ。マイページ登録にもまた個人情報を大量に打ち込む。まずエントリー時点でそこまで情報が必要なのか、とか大量の情報を入力させるに当たってどこまでUXを考えてるかとか。&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;事例1 とあるグローバル人材を求める企業&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;入力項目の説明に日本語と英語を併記していた。半分はゴミ情報なので酷く見づらかった&lt;/li&gt;
&lt;li&gt;最初に出身大学が国内か海外かのラジオボタンがあった。その次に出身大学を選ぶウィザードがあった。ウィザードの最初の質問は「出身大学は国内ですか？海外ですか？」のラジオボタン。&lt;/li&gt;
&lt;li&gt;住所と郵便番号も同じようなウィザードだった。住所をウィザードで選んでいくと郵便番号が自動で入力される。その次の項目は住所を手入力だった。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;事例2 Yahoo! JAPAN&lt;/h3&gt;

&lt;p&gt;具体的には覚えてないけど入力補完があった。郵便番号を入力すると住所も自動で入力された。一番使い易かった。&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;事例3 ワークスアプリケーションズ テクノロジスペシャリスト採用&lt;/h3&gt;

&lt;p&gt;そもそもマイページは必要なかった。エントリーには2〜3個のフォーム入力と返信用のメールアドレスのみで良かった。最高。&lt;/p&gt;

&lt;p&gt;次にマイページの内容。クッキーを焼いて「こんにちはn回目の訪問ですね」なんてやってたら即切る。大抵対応ブラウザも書いてあるからそこも見る。モダンブラウザはサポート外とか言ってたら渋い顔になる。私の就活後半は丁度Windows XPのサポートが切れた時期なのでその辺でまだIE 6のサポートをしてたらやっぱり渋い顔になる。対応OSがWindowsとOS Xとか書いてたらキレる。IT系でLinuxユーザは相手にしないだと？&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;エントリーシート&lt;/h2&gt;

&lt;p&gt;割と企業の個性が出る。熱意とか意気込みとかはコピペなりでどうにでもなってしまうので適当に書く。そればっか訊いてくるところはエントリーをやめる。書くのに手間が書かるのにまともな基準で評価されてるか分からないから。簡単に詐称可能でしょ…&lt;/p&gt;

&lt;p&gt;これまでの実績とかを訊いてきたらGithubアカウントとかTwitterアカウントとかブログとか大会実績とか過去のLT資料とかを張る。興味のある分野を書く。大抵Markdown形式で書いたがどこもプレビューで改行エスケープをしてなかったので箇条書きが酷く見辛かった。字数は気にしない。&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;性格診断&lt;/h2&gt;

&lt;p&gt;最悪の体験。まず、Windows+IEかOS X+Safariにしか対応してない。単に対応してないだけじゃなくてご丁寧にUAを見てそれ以外を弾く。IT系ならLinuxユーザも居るだろうに。そして内容だが、似たような質問を何度も繰り返す。ただでさえWindowsを使わされてイライラさせられているのに更に追い討ちを掛けてくる。さっきも答えただろ、と悪態をつきながら地獄の20分に耐えることになる。SAN値がほぼ0になる。あれをやらせてる人事の方々は一回体験してみた方が良いと思いますよ。その上であの性格診断が必要か判断して下さい。どっかの企業で性格診断無視してたら普通にそのまま選考進んだ。マジで存在価値が分かならい。&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;筆記試験&lt;/h2&gt;

&lt;p&gt;SPだっけ？IS？なんかそんなやつ。一回だけ受けた。さんすうとこくごの問題をひたすら解く。英語もあったっけ？覚えてないや。指定の会場じゃないと受けられないし順番待ちがあるしクソみたいな問題しか出ないし2回目は受けたくない。何の判断に使われるかもイマイチ分からない。必要ないなら止めて欲しい。&lt;/p&gt;

&lt;p&gt;それではなくて情報技術/科学に関する問題を出してきたところがあった。LINE。カバー範囲が広く、全ての問題に正当することは要求しない。回答を見て適正を決めて次の面接官を決めてたらしい。非常に良い。出来れば問題用紙を持ち帰らせてくれれば後学に使えたのにと思った。問題使い回してるのかな？&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;プログラミング課題&lt;/h2&gt;

&lt;p&gt;課してくるところは少なかった。楽しいプログラミングかと思いきやそうでもなかった。&lt;/p&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;事例1&lt;/h3&gt;

&lt;p&gt;言語指定があった。Java。しかもJavaで解くには凡そ不向きな問題。つながりのある複数の問題だったのに1問につき1ファイル指定で共通する機能をクラスに切り出すことも許されなかった。因みにお題は「共通化を考えながら解け」。&lt;/p&gt;

&lt;h3 id=&#34;toc_12&#34;&gt;事例2&lt;/h3&gt;

&lt;p&gt;仕様があいまいだった。「与えられた入力に対して」。入力はどう与えられるの？標準入力？コマンドライン引数？関数の引数？どれでも良いならそう書いて欲しい。さらに悪いことに時間指定があった。4時間。それは良いんだけど40分くらいで解いて提出したらログインセッションが切れてた。もう一回ログインしたらもう一回課題を受けれた。既に手元に回答は準備してあるので即座に提出したら普通に受理された。よくわからない。ちなみにその企業は唯一エントリーシートで落ちた。&lt;/p&gt;

&lt;h1 id=&#34;toc_13&#34;&gt;面接&lt;/h1&gt;

&lt;p&gt;自分の話じゃないけどエントリーしまくってた友人は交通費で破産しかけてた。交通費は出してくれると嬉しいけど手続面倒だよねー。Skype面接とか？自分は近場の企業を、それも少数だけにしかエントリーしない方針で凌いだ。1つ落ちたら1つ新たにエントリーした。&lt;/p&gt;

&lt;p&gt;スーツはあまり着たくない。特にIT系なら勤務も私服だし面接も私服OKなところが多い。服装に言及がないとかスーツ必須とかだと悪目立ちする。服装に言及がないときは募集ページのプログラマが私服かどうかで判断していた。一回、募集ページは私服なのに面接官はスーツを着ていることがあった。面接だから、とのこと。学生相手にそこまで気を遣う必要はないと思うのだがお作法なのだろうか。あとエレベータホールまで見送りにきてさらにエレベータの扉が閉まるまで深々と御辞儀されるのも恐縮だ。&lt;/p&gt;

&lt;p&gt;内容はまあいいや。変な質問をされたことはない。こちら一人に対して面接官3人とか4人とかは圧迫感があって嫌だった。あ、一回「スクリプト言語でもディスクIOバウンドやネットワークIOバウンドなら高速なアプリケーションを書ける」と言ったら面接官に「は？」って言われたのが気になった。CPUバウンドじゃないならアーキテクチャの問題だからむしろアプリを簡単に書き換えられるLLで記述すべきでしょ。因みにその面接で落ちた。&lt;/p&gt;

&lt;p&gt;面接でLispは口にしない方が良い。100%落ちる。&lt;/p&gt;

&lt;p&gt;最後に質問はあるかと聞かれる。そんなものはない。エントリーした時点で公開情報で十分納得してある。内定が出たら即座に決めるつもりだ。もう情報は必要ない。面接が早く終われば授業に間に合うかもしれない。早く帰してくれ。聞ける場を用意してくれるのは非常に良いことなんだが質問の内容で評価するのは止めてほしい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;その他の事も色々言いたい。&lt;/p&gt;

&lt;h1 id=&#34;toc_14&#34;&gt;時間&lt;/h1&gt;

&lt;p&gt;なんか大学生なんだから暇でしょみたいな雰囲気になってる。そんな訳はない。普通に授業がある。遊んでる大学生はごく一部だ。少なくともうちの大学だと遊べるのは1、2年までで3、4年からが勉強の本番になる。空き時間はレポートなりゼミの準備なりバイトなりサークルなりのために空けてある。面接と往復の時間を考えたら授業を1つ2つ犠牲にする必要がある。一応空いてる時間を訊いてくるがこちらが指定しても「それだとこちらが都合が悪いので他を指定して下さい」となって結局授業を潰すことになる。面接にしろ試験にしろ無駄なステップは省いて欲しい。学生の本分は勉強だ。&lt;/p&gt;

&lt;h1 id=&#34;toc_15&#34;&gt;時刻&lt;/h1&gt;

&lt;p&gt;機械送信のメッセージの他に手動で送られてくるメールや電話がある。あれの時間は結構気にする。まず、電話はやめて欲しい。電話で連絡取るにしても掛け直すときは前回とは時間帯をずらすとかしてほしい。学生なのだから毎日時間割ベースで活動している。電話をとれない時間帯は固定されている。前日と同じ、電話をとれない時間に電話が掛かってきたら正直バカなの？と思ってしまう。&lt;/p&gt;

&lt;p&gt;あと遅い時間や休日に連絡が来るとあまり良い顔にはならない。困る訳じゃなくて社員がその時間に活動しているということは残業や休出があるということだ。出来ればそういう会社は避けたい。&lt;/p&gt;

&lt;h1 id=&#34;toc_16&#34;&gt;OB訪問&lt;/h1&gt;

&lt;p&gt;ある企業でマイページ作ったらOB(というか同じ大学出身なだけの全く関係のない社員)と会う場をセッティングされそうになった。しかし相手は人事。話をしたいとしたらエンジニアだ。人事の方には興味はない。無駄な時間は使いたくない。&lt;/p&gt;

&lt;h1 id=&#34;toc_17&#34;&gt;エントリーする企業の決め方&lt;/h1&gt;

&lt;p&gt;Twitterや勉強会で知った人とかあるいは興味の湧くスライドを書いた人とかの会社を採用ページを見るところから始める。募集要項を見て気に入れば他のPRページも見る。気に入ればエントリーする。あとはGithub採用やってるところはとりあえず出す。他は名前知ってる有名企業とか。&lt;/p&gt;

&lt;p&gt;見るところは勤務形態の自由さ、年収、技術力。技術職なのだから自分の技術力を発揮出来てそれが評価されてまた仕事でスキルアップ出来る所が良い。&lt;/p&gt;

&lt;p&gt;自分の技術力を発揮出来るというのはつまらない規約で制限されないか。スーツ着用とかありえない。合理的理由が全くない。袖のボタンがキーボードに引っかかって作業し辛い。環境を自分の好きに選べるか。椅子、ディスプレイ、キーボード、OS、エディタ等々。バランスボールがオフィスにあると評価が上がる。&lt;/p&gt;

&lt;p&gt;評価されるというのは具体的には年収。札束で頬を引っ張たけばエンジニアは集まる。&lt;/p&gt;

&lt;p&gt;技術力は恐らく会社のWebページでは評価出来ない。中のエンジニアを勉強会で知った、スライドを見た、有名OSSのコミッタが居る、会社のGithubレポジトリの内容。鮎の友釣みたいにエンジニアを自由にさせておけば他のエンジニアも集まる。技術力を求めるのは自分のスキルアップという積極的な理由もあるし、クソコードをレビューしたくないという消極的な理由もある。&lt;/p&gt;

&lt;p&gt;割と年収が決め手だったりする。初任給は高く見えるように書いておいた方が良い。見た目は低くても手当てを入れると手取りがそれなりになるなら参考年収とかを書くと分かり易い。&lt;/p&gt;

&lt;p&gt;因みに会社の将来性は気にしてない。転職が盛んな職種なのだから傾いたら出ていく。&lt;/p&gt;

&lt;p&gt;正直経団連の企業は上の条件を満たしていそうにないので目も呉れてない。向こうも私のような人は求めてないだろうし多分棲み分けが出来てる。主にベンチャーを見ていた。&lt;/p&gt;

&lt;h1 id=&#34;toc_18&#34;&gt;コーディング面接&lt;/h1&gt;

&lt;h2 id=&#34;toc_19&#34;&gt;事例1&lt;/h2&gt;

&lt;p&gt;面接で予告なくコーディングがあった。まあ、それは良い。与えられた環境はWindows XP + Eclipseだった。その時点で既にXPのサポートは切れてた。椅子蹴っ飛ばして帰ろうかと思った。一応受けたけどEmacs入ってないしqwertyだしjp配列だしCaps Lockのままだしなんか数分に1回警告が出て邪魔されるし最悪だった。環境固定はありえないなと思った。&lt;/p&gt;

&lt;h2 id=&#34;toc_20&#34;&gt;事例2 pixiv&lt;/h2&gt;

&lt;p&gt;抜き打ちでホワイトボードコーディングをやった。リファレンスや補完が無くても書ける程度の問題だったし「多分この問題はここを訊いてると思うんですが…」「おぉ？！」とか盛り上がってたし楽しかった。シェル芸も披露した。上がり性の人にはつらいのかもしれないけど個人的には積極的にやって欲しい。&lt;/p&gt;

&lt;h2 id=&#34;toc_21&#34;&gt;事例3&lt;/h2&gt;

&lt;p&gt;採用フローにオンサイトのプログラミング試験があるところがあった。用意される環境はMac ProとJava 7とEclipseとJava 7のリファレンスだったかな？リファレンスが用意されてる時点でお察しと思うがインターネット接続禁止。なんでや。ググり力が一番大事でしょ。あと環境固定は最悪だって。それ見て受けるのやめた。&lt;/p&gt;

&lt;h1 id=&#34;toc_22&#34;&gt;Github採用&lt;/h1&gt;

&lt;p&gt;積極的にやってほしい。こちらの負担は軽いから。が、エンジニアへの負担がどれほどなのか分からない。あと(学部生なら)Githubを覚え始める頃と就活を始める頃が重なると思うので「これから伸びる」も考慮してくれると嬉しいなー。自分のGithubアカウントが充実し出したのは就活が終わってからだった。&lt;/p&gt;

&lt;p&gt;一定期間アカウントを観察して行動を見て決めるのなら期間を考えて欲しい。観察期間と試験期間が重なって観察期間中1コミットも出来ないことがあった。&lt;/p&gt;

&lt;p&gt;採用側のコストが低いなら一番推奨されるべき。&lt;/p&gt;

&lt;h1 id=&#34;toc_23&#34;&gt;プロコン採用&lt;/h1&gt;

&lt;p&gt;あまり感心しない。&lt;a href=&#34;http://keens.github.io/blog/2014/12/18/saiensugaenziniaringu/&#34;&gt;前にもポエム書いた&lt;/a&gt;ようにあれはサイエンスであってエンジニアの採用に有用とは思わない。むしろプロコン採用をやってるところはその辺分かってなさそうで評価が下がる。勿論、動画コーデックの開発をしているドワンゴのようにそういう人材が実際に必要なところはその限りではない。そういうところは積極的にアピールしてくれると誤認が少なくて助かる。&lt;/p&gt;

&lt;p&gt;一応言うとプログラマの中から適性のあるプログラマを見出す方法としては感心しない、と言っている。プログラマ志望の中からプログラム書けるプログラマを見出す方法としてはアリなんじゃないですかね。世の中プログラムの書けないプログラマがどの程度居るのか分かりませんが。&lt;/p&gt;

&lt;h1 id=&#34;toc_24&#34;&gt;&lt;a href=&#34;http://isucon.net&#34;&gt;ISUCON&lt;/a&gt;採用&lt;/h1&gt;

&lt;p&gt;めっちゃやって欲しい。インフラ系の即戦力って結構稀だと思います。はい。&lt;/p&gt;

&lt;p&gt;因みに私は1件だけオファーがありました。その頃は自分にそのオファーに見合うだけの技術があるとは思ってなくて、深く考えずに断っちゃいましたけど。今考えるとそこで内定貰って「ISUCONで内定貰ったぜ！ヒャッハ〜」って言ってれば流れ変わったのかな。&lt;/p&gt;

&lt;h1 id=&#34;toc_25&#34;&gt;&lt;a href=&#34;https://acaric.jp/&#34;&gt;アカリク&lt;/a&gt;採用&lt;/h1&gt;

&lt;p&gt;自分は行ってないけどめっちゃ良さそう。推奨されるべき。&lt;/p&gt;

&lt;h1 id=&#34;toc_26&#34;&gt;インターン&lt;/h1&gt;

&lt;p&gt;一番毒吐きたいところ。&lt;/p&gt;

&lt;p&gt;優秀な学生をインターンで獲得すると言っている企業をちらほら見掛ける。ふざけている。優秀な学生がインターンをしてる暇があると思ってるのか？やはりここにも学生なんだから暇でしょという雰囲気を感じる。&lt;/p&gt;

&lt;p&gt;参考に普通の学生たる私の3年生の時の夏休みの日程を挙げる。8月1日から強化錬、間を空けずに合宿、2日休んで合宿、すぐさま試験準備、試験、直後に帰省。東京に戻ってきたのは9月30日。夏休み中の休みは合宿の合間の2日のみ。&lt;/p&gt;

&lt;p&gt;色々突っ込みたいだろうが予想されるものには反論しておく。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;夏休みの真ん中に試験がある大学にいるのが悪い
: これは私からはどうしようもない。高校生の時にそこまで考える人はいないだろう。悪いというならうちの大学を切り捨てればいい。1学年3000人居る。因みに私は夏休みの前半はサークルに勤しんでいたが本来ならそれら全てを試験勉強に充てる。お察しの通り私の試験の出来は良くなかった。その期間にインターンに行きたがる人はそう多くないだろう。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;サークル3つやってるのが悪い
: 私の場合サークルばかりだが他の人でもサークルの他にバイト2つ3つ掛け持ちとかはザラにある。しかもその内の少なくとも1つは大抵教育系なので夏期講習で忙しい。夏期講習で働けなかった分の皺寄せで他のバイトも日程がつまる。夏休みに知人に会うと10連勤明けで死んだ目をしている。サークルやバイトの他にも高校の部活絡みだとか学外活動だとか要因は色々ある。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;就活のためならサークルを犠牲にすればいい
: 副将をやってるとそうもいかない。参加者ではなく主催者になる。それとも主催者の責務を放り出すような人を採りたいのか？副将になったのが悪いという批判も当を得てない。なぜならサークルの同期は9人いて3人が主副将になる。1/3だ。流石に1/3が外れ値と言う人はいないだろう。それに優秀な人こそ責任者になりやすい筈だ。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;インターンでお金貰えるんだからバイトは辞めるなり休むなりすれば良いのでは
: そうも言ってられない。最近のバイトは中々辞めさせてくれないし、休むと言っても勝手にシフトを入れてくる。辞めるには1ヶ月、2ヶ月前に辞意を伝えておかないといけない。インターンにも選考はある訳で、確実に行けると決まるのは夏休み直前だったりする。あるか無いか分からないもののためにリスクは冒したくない。それに一時収入のために定常収入を失う訳にはいかない。辞めるかも、なんて言葉が勝手にシフトを入れてくるような所に通用する訳がない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;帰省は個人の都合では
: そうでもない。多くの大学生は親の扶養下にある。定期的に家族に挨拶をしないと東京で生かしてもらえない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空きの2日を使ってインターンに行けば良いのでは
: インターンが2日で済むのは文系の話だ。理系ならば最低でも2週間、普通1ヶ月。2ヶ月のものもよく見掛ける。学んで動いて成果を出すには2日は短かすぎる。空きの2日どころか合宿をすっぽかしたところでインターンには行けない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;普通の学生じゃなくて優秀な学生の話をしているんだ
: 確かに。ここに書いたのは普通の学部生の日程だ。しかし優秀な人は他人より多くのことをこなすから優秀なのではないか？ならば優秀な人はさらに忙しいのではないか？私の周りの(私が思う)優秀な人は忙しそうにしている。忙しいとは言ってないが暇と言ってるのは見たことない。
院生のスケジュールは研究室次第だろう。何とも言えない。やる事やってるなら他は関知しない、というところもあれば夏休みにもコアタイムのある研究室もあると聞く。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;勿論、ここに書いたことが全ての学生に当て嵌る訳ではない。中には夏休みに時間のある人もいる。だがその人がインターンに行くか、という問題もある。優秀な人は優れた指導教官の下に居る筈だ。その指導教官の下を離れてまでインターンに行く価値があるか。あるいは優秀ならば指導教官がいなくても自ら学べる人は多い。本人の自主学習速度を上回る体験を提供出来るか。優秀な人は職が欲しいなら先のアカリクなどで座して待つだけでやってくる。内定直結は別に魅力ではない。&lt;/p&gt;

&lt;p&gt;私がここまで毒を吐いたのはインターンそのものではない。時間のある学生を集めてインターンを開きたいならそれはそれで良し。両者得をすることがあるだろう。毒を吐いているのはインターンで優秀な学生を獲得すると言っている企業、採用プロセスにインターンを組み込む企業だ。少数、時間のある優秀な学生もいるだろうが多くの優秀な人を自らフィルタしていることに気付かないのか。&lt;/p&gt;

&lt;h1 id=&#34;toc_27&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;常体で書いた上に普段使わない汚ない言葉遣い、自分の価値観に合わないものを全力で否定する内容だったので酷く毒毒しいエントリになってしまった。飽くまで個人の日記で毒を吐いただけなので皆さんマジレスしないで下さいね。&lt;/p&gt;

&lt;p&gt;企業は利益のために採用活動をするのに対して大学生はその露命をつなぐために就職活動をする。立場上も身分上も大学生が下手に出るべきだが上から目線な記述が散見される。ここは一つ個人の日記ということで赦して下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mlyaccを使ってみてハマったところ</title>
      <link>/blog/2015/01/31/mlyaccwotsukattemitehamattatokoro</link>
      <pubDate>Sat, 31 Jan 2015 11:55:51 UTC</pubDate>
      
      <guid>/blog/2015/01/31/mlyaccwotsukattemitehamattatokoro</guid>
      <description>

&lt;p&gt;κeenです。前回の&lt;a href=&#34;http://keens.github.io/blog/2014/12/10/mllexwoshi-tutemiru/&#34;&gt;mllexの記事&lt;/a&gt;の続きです。今回はmlyaccを使ってみました。&lt;/p&gt;

&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;前回はprologをパースするためにこのようなmllexのコードを書いたのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;datatype lexresult =
         Comment of string
       | LeftParen
       | RightParen
       | LeftBracket
       | RightBracket
       | Comma
       | Dot
       | Bar
       | Medaka
       | UnderScore
       | String of string
       | Number of int
       | Variable of string
       | EOF

val linenum = ref 1
val error = fn x =&amp;gt; print (x ^ &amp;quot;\n&amp;quot;)
val eof = fn () =&amp;gt; EOF
%%
%structure PrologLex                      

alphanum = [A-Za-z0-9];
alpha    = [A-Za-z];
digit    = [0-9];
ws       = [\ \t\n];

%%

{ws}+            =&amp;gt; (lex());
%(.*)\n          =&amp;gt; (Comment yytext);
&amp;quot;(&amp;quot;              =&amp;gt; (LeftParen);
&amp;quot;)&amp;quot;              =&amp;gt; (RightParen);
&amp;quot;[&amp;quot;              =&amp;gt; (LeftBracket);
&amp;quot;]&amp;quot;              =&amp;gt; (RightBracket);
&amp;quot;,&amp;quot;              =&amp;gt; (Comma);
&amp;quot;.&amp;quot;              =&amp;gt; (Dot);
&amp;quot;|&amp;quot;              =&amp;gt; (Bar);
&amp;quot;:-&amp;quot;             =&amp;gt; (Medaka);
&amp;quot;_&amp;quot;              =&amp;gt; (UnderScore);
[a-z]{alphanum}* =&amp;gt; (String yytext);
{digit}+         =&amp;gt; (Number (foldl (fn(a, r)=&amp;gt; (ord(a)-ord(#&amp;quot;0&amp;quot;)) + 10*r) 0 (explode yytext)));
[A-Z]{alphanum}* =&amp;gt; (Variable yytext);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでトークナイズしたトークンをパースすることを考えます。結果はAST作るのが面倒なので文字列にします。&lt;/p&gt;

&lt;p&gt;とりあえずコードを晒してから解説します。prologの仕様を読まずに書いたので用語や文法は誤りを含みます。今度直すので今回はこれで勘弁して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
%%
%name PrologParser
%pos int

%term  Comment of string | LeftParen | RightParen | LeftBracket | RightBracket | Comma | Dot | Bar | Medaka | UnderScore | Number of int | String of string | Variable of string | EOF

%nonterm EXP of string | LIST of string | LISTEXPS of string | TOPDEFINITION of string | SUBDEFINITIONS of string | DEFINITION of string | ARG of string | NAME of string | STMT of string | ATOM of string | START of string

%left Comma
%right Bar
%eop EOF
%noshift EOF
%nodefault

%%

START : STMT (STMT)

STMT           : Comment STMT       (Comment ^ &amp;quot;\n&amp;quot; ^ STMT)
               | TOPDEFINITION STMT (TOPDEFINITION ^ &amp;quot;\n&amp;quot; ^ STMT)
               | (&amp;quot;&amp;quot;)

TOPDEFINITION  : DEFINITION Dot                       (DEFINITION ^ &amp;quot;.&amp;quot;)
               | DEFINITION Medaka SUBDEFINITIONS Dot (DEFINITION ^ &amp;quot;:-\n&amp;quot; ^ SUBDEFINITIONS ^ &amp;quot;.&amp;quot;)

SUBDEFINITIONS : DEFINITION Comma SUBDEFINITIONS      (DEFINITION ^ &amp;quot;,\n&amp;quot; ^SUBDEFINITIONS)
               | DEFINITION                           (&amp;quot;  &amp;quot; ^ DEFINITION)

DEFINITION     : NAME ARG (NAME ^ ARG)

NAME           : String     (String)

               
ARG            : LeftParen EXP RightParen (&amp;quot;(&amp;quot; ^ EXP ^ &amp;quot;)&amp;quot;)
               
               
EXP            : EXP Comma EXP  (EXP1 ^ &amp;quot;, &amp;quot; ^ EXP2)
               | LIST           (LIST)
               | ATOM           (ATOM)

LIST           : LeftBracket LISTEXPS RightBracket ( &amp;quot;[&amp;quot; ^ LISTEXPS ^ &amp;quot;]&amp;quot;)

LISTEXPS       : ATOM Bar LISTEXPS (ATOM ^ &amp;quot; | &amp;quot; ^ LISTEXPS)
               | ATOM (ATOM)

ATOM           : UnderScore               (&amp;quot;_&amp;quot;)
               | Number                   (Int.toString Number)
               | String                   (String)
               | Variable                 (Variable)
               | LeftBracket RightBracket (&amp;quot;[]&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全体はやはり&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;補助コード
%%
補助ルール
%%
パースルール
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;/p&gt;

&lt;p&gt;トークンに切り出す部分がないので補助コードはあまり書く必要はないようです。ASTを組み立てる時に必要なことがあるのかな？&lt;/p&gt;

&lt;p&gt;補助ルールは、主なものは終端記号(term)と非終端記号(nonterm)の記述です。パーサに馴染のない人には聞き慣れない言葉かもしれませんが、ASTの葉が終端記号で、節が非終端記号です。あとはパースの終わりの記号にeop、パースの区切にnonshiftを指定しましょう。パースの区切はEOFの他にREPLならNewlineなども候補かもしれません。posの型も必須です。leftやrightは中置演算子があればそれの結合の左右を指定します。複数書くと後の方が優先順位が高くなるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%left Add Sub
%left Mul Div
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように。&lt;/p&gt;

&lt;p&gt;パースルールは見て察して下さい。&lt;/p&gt;

&lt;p&gt;これをprolog.yaccなどと名前をつけて(.grmがよく使われるそうですが。)、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mlyacc prolog.yacc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするとprolog.yacc.smlとprolog.yacc.sigが出来ます。&lt;/p&gt;

&lt;p&gt;追記:
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; あと拡張子ですが、compilation managerは.grmをmlyaccのファイルと認識してくれるはずなので手間が少なそうです。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/561515838461583361&#34;&gt;2015, 1月 31&lt;/a&gt;&lt;/blockquote&gt;
大人しく.grmを使いましょう。&lt;/p&gt;

&lt;p&gt;シグネチャは.sigが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;signature PrologParser_TOKENS =
  sig
    type (&#39;a,&#39;b) token
    type svalue
    val EOF : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Variable : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val String : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Number : int * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val UnderScore : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Medaka : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Bar : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Dot : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Comma : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val RightBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val LeftBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val RightParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val LeftParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
    val Comment : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
  end
signature PrologParser_LRVALS =
  sig
    structure Tokens :
      sig
        type (&#39;a,&#39;b) token
        type svalue
        val EOF : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Variable : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val String : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Number : int * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val UnderScore : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Medaka : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Bar : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Dot : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Comma : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val RightBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val LeftBracket : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val RightParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val LeftParen : &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
        val Comment : string * &#39;a * &#39;a -&amp;gt; (svalue,&#39;a) token
      end
    structure ParserData :
      sig
        type pos
        type svalue
        type arg
        type result
        structure LrTable : &amp;lt;sig&amp;gt;
        structure Token : &amp;lt;sig&amp;gt;
        structure Actions : &amp;lt;sig&amp;gt;
        structure EC : &amp;lt;sig&amp;gt;
        val table : LrTable.table
        sharing LrTable = Token.LrTable
      end
    sharing type Tokens.svalue = ParserData.svalue
    sharing type Tokens.token = ParserData.Token.token
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、.smlが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor PrologParserLrValsFun(&amp;lt;param&amp;gt;: sig
                                         structure Token : &amp;lt;sig&amp;gt;
                                       end) :
                             sig
                               structure ParserData : &amp;lt;sig&amp;gt;
                               structure Tokens : &amp;lt;sig&amp;gt;
                             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;な感じです。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;問題点&lt;/h1&gt;

&lt;p&gt;これ、以前のlexのコードと組み合わせても動きません。パーサはレキサが吐いたトークン列をパースするのでレキサとパーサで同じdatatypeを共有している必要があります。パーサはtermの指定からTokensを自動で生成してしまうのでレキサの方を修正する必要があります。&lt;/p&gt;

&lt;p&gt;こうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;structure Tokens = Tokens

type pos = int
type svalue = Tokens.svalue
type (&#39;a, &#39;b) token = (&#39;a, &#39;b) Tokens.token
type lexresult = (svalue,pos) token
(* datatype lexresult = *)
(*          Comment of string *)
(*        | LeftParen *)
(*        | RightParen *)
(*        | LeftBracket *)
(*        | RightBracket *)
(*        | Comma *)
(*        | Dot *)
(*        | Bar *)
(*        | Medaka *)
(*        | UnderScore *)
(*        | Number of int *)
(*        | String of string *)
(*        | Variable of string *)
(*        | EOF *)
val pos = ref 0
val linenum = ref 1
val error = fn x =&amp;gt; print (x ^ &amp;quot;\n&amp;quot;)
val eof = fn () =&amp;gt; Tokens.EOF(!pos, !pos)

%%
%header (functor PrologLexFun(structure Tokens: PrologParser_TOKENS));

alphanum = [A-Za-z0-9];
alpha    = [A-Za-z];
digit    = [0-9];
ws       = [\ \t\n];

%%

{ws}+            =&amp;gt; (lex());
%(.*)\n          =&amp;gt; (Tokens.Comment(yytext, !pos, !pos));
&amp;quot;(&amp;quot;              =&amp;gt; (Tokens.LeftParen(!pos, !pos));
&amp;quot;)&amp;quot;              =&amp;gt; (Tokens.RightParen(!pos, !pos));
&amp;quot;[&amp;quot;              =&amp;gt; (Tokens.LeftBracket(!pos, !pos));
&amp;quot;]&amp;quot;              =&amp;gt; (Tokens.RightBracket(!pos, !pos));
&amp;quot;,&amp;quot;              =&amp;gt; (Tokens.Comma(!pos, !pos));
&amp;quot;.&amp;quot;              =&amp;gt; (Tokens.Dot(!pos, !pos));
&amp;quot;|&amp;quot;              =&amp;gt; (Tokens.Bar(!pos, !pos));
&amp;quot;:-&amp;quot;             =&amp;gt; (Tokens.Medaka(!pos, !pos));
&amp;quot;_&amp;quot;              =&amp;gt; (Tokens.UnderScore(!pos, !pos));
[a-z]{alphanum}* =&amp;gt; (Tokens.String(yytext, !pos, !pos));
{digit}+         =&amp;gt; (Tokens.Number ((foldl (fn(a, r)=&amp;gt; (ord(a)-ord(#&amp;quot;0&amp;quot;)) + 10*r) 0 (explode yytext)), !pos, !pos));
[A-Z]{alphanum}* =&amp;gt; (Tokens.Variable(yytext, !pos, !pos));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モジュールではなくてファンクタを生成するようになります。シグネチャはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor PrologLexFun(&amp;lt;param&amp;gt;: sig
                                structure Tokens : &amp;lt;sig&amp;gt;
                              end) :
                    sig
                      structure UserDeclarations : &amp;lt;sig&amp;gt;
                      exception LexError
                      structure Internal : &amp;lt;sig&amp;gt;
                      structure YYPosInt : &amp;lt;sig&amp;gt;
                      val makeLexer : (int -&amp;gt; string)
                                      -&amp;gt; unit -&amp;gt; Internal.result
                    end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;組み合わせる&lt;/h1&gt;

&lt;p&gt;まず、必要なモジュールやシグネチャをmlyaccから読み込みます。前回同様mltonのmlyaccを使って、SML/NJで動作確認を行ないました。&lt;/p&gt;

&lt;p&gt;私は分かってないのですが、useってもしかしてSML/NJの固有の機能なんですかね。&lt;/p&gt;

&lt;p&gt;追記:
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;useはThe Standard ML Basis Libraryに記載があるのでSML/NJ固有の機能ではないですが、implementation dependentと書いてあるのでまぁそういう事なんでしょう&lt;/p&gt;&amp;mdash; ろんだ (@fetburner) &lt;a href=&#34;https://twitter.com/fetburner/status/561514796734877698&#34;&gt;2015, 1月 31&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; useは標準ですが意味は実装依存ですね&amp;gt; &lt;a href=&#34;http://t.co/fPC38xtD1X&#34;&gt;http://t.co/fPC38xtD1X&lt;/a&gt; (例外の直後辺り)&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/561515332469137408&#34;&gt;2015, 1月 31&lt;/a&gt;&lt;/blockquote&gt;
とのことなので処理系依存の機能ではなかった模様。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/base.sig&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/join.sml&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/lrtable.sml&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/stream.sml&amp;quot;;
use &amp;quot;/home/kim/compile/mlton/lib/mlyacc-lib/parser2.sml&amp;quot;;
use &amp;quot;prolog.yacc.sig&amp;quot;;
use &amp;quot;prolog.yacc.sml&amp;quot;;
use &amp;quot;prolog.lex.sml&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mlyacc-libの場所は各自異なるので適宜書き換えて下さい。SML/NJはインストール場所を表わすシンボルを持っているようですが、私はmltonのものを参照しているのでいずれにせよ関係ないですね。&lt;/p&gt;

&lt;p&gt;さて、この.yacc.smlに入ってるファンクタです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor PrologParserLrValsFun(&amp;lt;param&amp;gt;: sig
                                         structure Token : &amp;lt;sig&amp;gt;
                                       end) :
                             sig
                               structure ParserData : &amp;lt;sig&amp;gt;
                               structure Tokens : &amp;lt;sig&amp;gt;
                             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故こうなってるのかは分からないのですがTokenを欲しがってますね。あげましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParserLrVals =
PrologParserLrValsFun(structure Token = LrParser.Token)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LrValsって言ってるのでLRパーサーで使うデータ型が用意出来たのかな？&lt;/p&gt;

&lt;p&gt;これでレキサで使うTokensとパーサで使うParserDataを持つモジュールが出来たのでレキサのファンクタの餌が用意出来ました。食べさせてあげましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologLex =
PrologLexFun(structure Tokens = PrologParserLrVals.Tokens)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは普通にレキサを生成します。&lt;/p&gt;

&lt;p&gt;んで最後にLRパーサとLRパーサで使うデータ型(?)とLRパーサに渡すトークンを生成するレキサを組み合わせます。なんかsharingなる機能を使って組み合わせるらしいのでそれ専用のファンクタが用意されています。sharingなんぞ。いつか&lt;a href=&#34;https://github.com/SMLFamily/The-Definition-of-Standard-ML-Revised&#34;&gt;The Definition of Standard ML Revised&lt;/a&gt;読まねば。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やっぱり&lt;code&gt;LrParser&lt;/code&gt;を使ってるのが腑に落ちませんね。どうして生成した時点で含んでないのかな。複数のパーサを作ったときに無駄を無くすため？自前のパーサが使えるようにするため？&lt;code&gt;LrParser.Token&lt;/code&gt;はまだパーサとsharingしてる必要がありそうなので納得出来ますが。&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;使ってみる&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;makeLexer&lt;/code&gt;と&lt;code&gt;parse&lt;/code&gt;を使うようです。&lt;code&gt;makeLexer&lt;/code&gt;は呼ぶ度にトークンを返すものではなく、トークンのストリームを返すものになってるらしいです。&lt;/p&gt;

&lt;p&gt;prologファイル名を受け取ってその中身をパースして、中身を整形した文字列にするコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun invoke lexstream =
    let
        fun print_error (s, _, _) =
            TextIO.output(TextIO.stdOut,
                          &amp;quot;Error: &amp;quot; ^ s ^ &amp;quot;\n&amp;quot;)
    in
        PrologParser.parse(0, lexstream, print_error, ())
    end

fun parse filename =
    let
        val f = TextIO.openIn filename
        val lexer = PrologParser.makeLexer
                        (fn i =&amp;gt; TextIO.inputN(f, i))
        fun run lexer =
            let
                val (result,lexer) = invoke lexer
            in
                TextIO.output(TextIO.stdOut,
                              &amp;quot;result = &amp;quot; ^ result ^ &amp;quot;\n&amp;quot;)
            end
    in
        run lexer
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回はposのアップデートをサボったので&lt;code&gt;print_error&lt;/code&gt;内では無視してますが本来は&lt;code&gt;print_error&lt;/code&gt;は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;print_error (s, start:int, end:int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として受けるべきです。この時startとendはトークンの開始位置と終了位置です。&lt;/p&gt;

&lt;p&gt;他にも説明が足りてない部分がありますが、マニュアルや&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/education/lectures/compiler/code/mlyaccKaisetsu.pdf&#34;&gt;東北大のPDF&lt;/a&gt;を参照して下さい。&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;mlyaccの使い方を書いた&lt;/li&gt;
&lt;li&gt;mllexとmlyaccの組み合わせ方を書いた&lt;/li&gt;
&lt;li&gt;疑問が残った&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次回はASTでも作ってみますが、smlsharpにSMLFormatなるdatatypeの定義とそのプリティプリンタの定義を同時に出来るツールがあるようなのでそれを使ってみます。いくつも中間表現を作ろうと思ったら途中経過も欲しいのでプリティプリンタ重要ですよね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AsciiDocを使ってお手軽manページ生成</title>
      <link>/blog/2015/01/24/generate-manpage</link>
      <pubDate>Sat, 24 Jan 2015 10:58:29 UTC</pubDate>
      
      <guid>/blog/2015/01/24/generate-manpage</guid>
      <description>

&lt;p&gt;コマンドラインツールを作ってるみなさん、man書いてますか？コマンドラインツールを使う人は時代の変化に取り残された遺物なのでWebにドキュメント置いても読んでくれませんよ。&lt;/p&gt;

&lt;p&gt;いや、私のようにmanだけを頼りにツールを使う人もいるのでちゃんと書いて下さいね。面倒だって?AsciiDocを使えば簡単に書けますよ!&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Manとは&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;man hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で見れるやつですね。&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;troff&lt;/h2&gt;

&lt;p&gt;manはtroffというフォーマットで書く必要があります。どんな感じかというと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-troff&#34;&gt;.ie n \{\
\h&#39;-04&#39;\(bu\h&#39;+03&#39;\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
use the latest sbcl
.RE
.sp
.if n \{\
.RS 4
.\}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。人間が書くものではないですね。なので別の形式(AsciiDoc)から変換することを考えます。&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;セクションナンバー&lt;/h2&gt;

&lt;p&gt;コマンド（など）はセクションに分かれています。manを書くときに必要になる知識なので覚えておきましょう。コマンドラインから使うものの他、Cの関数やコンフィグファイルについての項目もあります。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;一般コマンド&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;システムコール&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ライブラリ関数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;デバイス&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ファイルフォーマット（コンフィグファイル）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ゲーム&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;その他&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;システムメンテナンス(sudoとか)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;カーネル&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;一般デベロッパが使うのは1、5、6、8あたりでしょうか。6のゲームには普通のゲームの他、phase of moon、盈虚(えいきょ、月齢のこと)を表示する&lt;code&gt;pom&lt;/code&gt;コマンドなどがあります。&lt;/p&gt;

&lt;p&gt;manを書くときにはmanを必ずどこかのセクションに割り当てます。&lt;/p&gt;

&lt;p&gt;manを使う時は&lt;code&gt;man hoge&lt;/code&gt;だと全てのセクションのhogeのmanを捜しますが&lt;code&gt;man 1 hoge&lt;/code&gt;だとセクション1のみから捜します。割とセクション1と2で同名のmanがあることがあるので重宝します。また、そのような混同を防ぐためにコマンドやシステムコールの後には括弧書きでセクションナンバーを書くのが慣習です。manならman(1)のように。&lt;/p&gt;

&lt;p&gt;因みに&lt;code&gt;man n intro&lt;/code&gt;とするとセクションナンバーnの説明が見れます。&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;AsciiDoc&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.methods.co.nz/asciidoc/&#34;&gt;AsciiDoc Home Page&lt;/a&gt;
MarkdownとかrSTとかの類いです。リーダブルなAsciiなDocを書いて色々な形式に変換出来ます。HTMLやDocBookなどの形式に変換出来ます。普通にそのままのテキストでも十分リーダブルだと思います。拡張子は.txtを使います。そのままでも読めるんだぜオーラが出てますね。&lt;/p&gt;

&lt;p&gt;有名どころだとgitが使ってるとか。バッククォートをあまり使わないので個人的にはリーダブルさが他より高い気がします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://powerman.name/doc/asciidoc&#34;&gt;ここ&lt;/a&gt;にチートシートがあるのでだいたいはそこを見てもらえば良いのですが、例を出すと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asciidoc&#34;&gt;TITLE
=====
keen mail@address
0.0.1, 2015-01-24

Header
------
[source, lisp]
(write-line &amp;quot;Hello, World&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;な感じです。
タイトル、=で下線のあとにファイルの属性がきます。Author、Mail、Revision、Dateはよく使うのでこのようにリーダブルに書けます。他の属性は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:attr: value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように書く必要があります。Authorなどもこのように書いても構いません。&lt;/p&gt;

&lt;p&gt;独特なのがパラグラフ毎にマークアップしていくところですね。パラグラフの区切は空行です。上の&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asciidoc&#34;&gt;[source, lisp]
(write-line &amp;quot;Hello, World&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにパラグラフの前にマークアップコマンドを置けます。1パラグラフに収まらないものは例えばソースコードなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asciidoc&#34;&gt;----
(defun hello (name)
  (format t &amp;quot;Hello, ~a~%&amp;quot; name))

(hello &amp;quot;κeen&amp;quot;)
----
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;-&lt;/code&gt;4つで囲む、などの記法もあります。&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;manのフォーマット&lt;/h1&gt;

&lt;p&gt;さて、話戻ってmanのフォーマットです。みなさん見慣れてるかと思いますが、manは最初はNAME、SYNOPSIS、DESCRIPTIONのセクションが並ぶことを要求します。&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;AsciiDocからman生成&lt;/h1&gt;

&lt;p&gt;manが一定のフォーマットを要求するのでAsciiDoc側も一定のフォーマットで書いてやる必要があります。&lt;/p&gt;

&lt;p&gt;NAME、SYNOPSIS、DESCRIPTIONは勿論のこと、タイトルが「コマンド名(n)」となっている必要があります。コマンド名にはスペースが入ってはいけません。gitのようにサブコマンドに分かれているものはハイフンで繋ぐようです。nはセクションナンバーですね。&lt;/p&gt;

&lt;p&gt;NAMEについて捕捉しておくと、NAMEの書式も決まっていて、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command-name - one line description
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のフォーマットである必要があります。&lt;code&gt;apropos(1)&lt;/code&gt;で表示するためでしょうね、きっと。&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;例&lt;/h2&gt;

&lt;p&gt;実際に私が書いたものを載せますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asciidoc&#34;&gt;cim-use(1)
==========
keen(@blackenedgold) 3han5chou7@gmail.com
:man manual: CIM Manual

NAME
----
cim-use -  Use specified impl as &#39;cl&#39; command&#39;s backend.

SYNOPSIS
--------
[verse]
cim use &amp;lt;impl[-version]&amp;gt; [--default]

DESCRIPTION
-----------

Use &amp;lt;impl&amp;gt; as background for cl command. It also affects bare lisp command.
If version is not given, use latest version.
If --default is given, use the specified implementation at initial state.

EXAMPLES
--------
* use the latest sbcl
----
$ cim use sbcl
$ sbcl --version
SBCL 1.1.14
----

* use old sbcl
----
$ cim use sbcl-1.1.10
$ sbcl --version
SBCL 1.1.10
----

* use ccl-1.9 and set it default
----
$ cim use ccl-1.9 --default
----

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:man manual:の属性はヘッダに表示されるものです。&lt;/p&gt;

&lt;p&gt;んで変換は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a2x  --doctype manpage --format manpage filename.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;。&lt;/p&gt;

&lt;p&gt;これ、ファイル名に関らずcim-use.1というファイルを生成します。&lt;/p&gt;

&lt;p&gt;んでファイルの内容は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;man ./cim-use.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で見れます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CIM-USE(1)			  CIM Manual			    CIM-USE(1)



NAME
       cim-use - Use specified impl as &#39;cl&#39; command&#39;s backend.

SYNOPSIS
       cim use &amp;lt;impl[-version]&amp;gt;	[--default]

DESCRIPTION
       Use &amp;lt;impl&amp;gt; as background	for cl command.	It also	affects	bare lisp
       command.	If version is not given, use latest version. If	--default is
       given, use the specified	implementation at initial state.

EXAMPLES
       o   use the latest sbcl

	   $ cim use sbcl
	   $ sbcl --version
	   SBCL	1.1.14

       o   use old sbcl

	   $ cim use sbcl-1.1.10
	   $ sbcl --version
	   SBCL	1.1.10

       o   use ccl-1.9 and set it default

	   $ cim use ccl-1.9 --default

AUTHOR
       keen(@blackenedgold) 3han5chou7@gmail.com
	   Author.



				  01/21/2015			    CIM-USE(1)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他の例だと、&lt;a href=&#34;https://github.com/git/git/tree/master/Documentation&#34;&gt;gitのドキュメント&lt;/a&gt;を見るとよさそうです。あそこはWEB用にもビルドしてるのでAsciiDocのコンフィグ書いてWEBとmanで条件分岐するマクロとかも書いてます。変態ですね。&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;ビルド&lt;/h1&gt;

&lt;p&gt;私は以下のようなスクリプトを書いてビルドしてます。並列ビルド、タイムスタンプセンシティブビルド対応。DOC_ROOTはデファルトでそのスクリプトが置いてあるディレクトリです。環境変数で制御出来ます。make.shって名前で保存したなら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ DOC_ROOT=your/root ./make.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように。その他AUTO_POLLなども設定出来ます。必要ならお使い下さい。&lt;a href=&#34;https://github.com/KeenS/CIM&#34;&gt;CIM&lt;/a&gt;の配布物に含まれるのでBSDライセンスです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh

: ${DOC_ROOT:=$(cd $(dirname $0); pwd)}
: ${MAN_DIR:=${DOC_ROOT}/man/man1}
: ${AUTO_POLL:=false}
: ${POLL_INTERVAL:=5}

txt2man(){
    if [ ! -e &amp;quot;${MAN_DIR}/$(basename $1 .txt).1&amp;quot; ] || [ &amp;quot;$1&amp;quot; -nt &amp;quot;${MAN_DIR}/$(basename $1 .txt).1&amp;quot; ]; then
        echo &amp;quot;Building $1&amp;quot;
        if a2x -v  --doctype manpage --format manpage -D &amp;quot;${MAN_DIR}&amp;quot; &amp;quot;$1&amp;quot; &amp;gt; &amp;quot;log/$(basename $1 .txt).log&amp;quot; 2&amp;gt;&amp;amp;1
        then
            echo &amp;quot;O Built $1&amp;quot;
        else
            echo &amp;quot;X Bulid failed: $1. See log/$(basename $1 .txt).log&amp;quot;
            return 1
        fi
    fi
}

cd &amp;quot;${DOC_ROOT}&amp;quot;
while &amp;quot;${AUTO_POLL}&amp;quot;; do
      for f in *.txt; do
          txt2man &amp;quot;$f&amp;quot; &amp;amp;
      done

      wait
      if  &amp;quot;${AUTO_POLL}&amp;quot;; then
          sleep &amp;quot;${POLL_INTERVAL}&amp;quot;
      fi
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;運用&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;man&lt;/code&gt;はMANPATH環境変数を元にmanを捜します。捜すのはMANPATH直下ではなく、セクションナンバー1なら/man/path/man1/name.1を捜します。それっぽいところに置きましょう。&lt;/p&gt;

&lt;p&gt;因みにFreeBSDではちょっと面倒です。詳しくは&lt;code&gt;manpath(1)&lt;/code&gt;を見て下さい。&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;manpageは重要&lt;/li&gt;
&lt;li&gt;だけど手で書くものではない&lt;/li&gt;
&lt;li&gt;AsciiDoc使うと便利!&lt;/li&gt;
&lt;li&gt;便利なスクリプト用意しといたよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>印刷フォマット済みのテキストファイルをPDF化する</title>
      <link>/blog/2015/01/24/a2pdf</link>
      <pubDate>Sat, 24 Jan 2015 10:23:00 UTC</pubDate>
      
      <guid>/blog/2015/01/24/a2pdf</guid>
      <description>&lt;p&gt;小ネタ。古いドキュメントやらポータブルな仕様を落としてくると中身が印刷フォーマット済み(ページネーションやヘッダ、フッタをアスキーアートで表現してる)であることがあります。
それらを普通のテキスト形式だと読みづらいのでPDF化する話。&lt;/p&gt;

&lt;p&gt;結論から言うと&lt;a href=&#34;http://search.cpan.org/~jonallen/a2pdf-1.11/lib/Script/a2pdf.pm&#34;&gt;a2pdf - search.cpan.org&lt;/a&gt;を使いました。選んだ理由は&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;余計な装飾を付与しない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^L&lt;/code&gt;(pagebreak)でちゃんと改ページする&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;です。使い方は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ a2pdf --noheader --noperl-syntax --noline-numbers  foo.txt -o foo.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でok。本当は&lt;code&gt;--nofooter&lt;/code&gt;も付けたいんですがそれつけるとエラー出たのでやむなくフッタは甘受。元々perlのソースコードをPDF化するためのものらしく、デフォルトでそのような設定になってるので無効化する必要があります。&lt;/p&gt;

&lt;p&gt;生成速度なんですけどPDF化すると105ページあるテキストの変換に73秒かかりました。少し遅いですね。このくらいだったらサクっとCommon Lispで書いてしまった方が速かったのかなぁ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispのポータビリティとユニバーサリティ</title>
      <link>/blog/2015/01/22/common-lisp-portability-and-univesality</link>
      <pubDate>Thu, 22 Jan 2015 07:51:02 UTC</pubDate>
      
      <guid>/blog/2015/01/22/common-lisp-portability-and-univesality</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://clfreaks.org/post/108341635899/1-cim-vs-roswell&#34;&gt;clfreaks&lt;/a&gt;の収録時に他のLisperと話してて価値観というか目標を共有出来てないなと思ったのでここで心情を語る次第。今のCommon Lispの使われ方には問題がある。&lt;/p&gt;

&lt;p&gt;Common Lispにはポータビリティというかユニバーサリティというか、そういうものがない。いや、処理系の作者達はしっかり作ってるのだけどLisperがそういう使い方をしていない。&lt;/p&gt;

&lt;p&gt;例えば、Rubyで出来たアプリケーションを使いたいとしよう。Jekyllがいいかな。大抵のシステムには入ってるだろうが一応処理系のインストールから始めてみる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aptなりpkgなりyumなりで処理系をインストールする。それが気に入らなければソースからインストールしてもいい。&lt;/li&gt;
&lt;li&gt;処理系をインストールするとgemがついてくるので&lt;code&gt;gem install jekyll&lt;/code&gt;を叩く。&lt;/li&gt;
&lt;li&gt;あとはJekyllを使うだけ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あるいは、Octopressなら処理系のインストールのあとは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git cloneしてくる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gem install bundler&lt;/code&gt;でbundlerをインストールする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bundle install&lt;/code&gt;で依存gemをインストールする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bundle exec rake preview&lt;/code&gt;でサーバーが起動する。&lt;/li&gt;
&lt;li&gt;止めたければCtrl-Cで止まる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Common Lispで出来たアプリケーションを使いたいとしよう。&lt;a href=&#34;https://github.com/vsedach/cliki2&#34;&gt;cliki&lt;/a&gt;。がいいかな。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;処理系のインストールはRubyと同じくパッケージマネージャで入る。あるいはソースからインストールしてもいい。この際処理系選びは既に終わっているとする。&lt;/li&gt;
&lt;li&gt;clikiをgit cloneしてくる。&lt;/li&gt;
&lt;li&gt;ASDFに読んでもらうために~/common-lisp以下にclikiを移動する。&lt;/li&gt;
&lt;li&gt;依存パッケージのインストールのためにquicklispをインストールする。

&lt;ul&gt;
&lt;li&gt;quicklisp.lispをダウンロードしてくる。&lt;/li&gt;
&lt;li&gt;REPLを起動する。どうやって？処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;li&gt;Lispの式をいくつか評価してquicklispをインストールする。~/quicklispが出現するがこの際目を瞑る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;REPLで&lt;code&gt;(ql:quickload :cliki)&lt;/code&gt;を評価して依存パッケージをインストールする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(start-cliki-server port homedir wikis)&lt;/code&gt;でサーバーが起動する。REPLも起動しっぱなし。&lt;/li&gt;
&lt;li&gt;止めたければ

&lt;ul&gt;
&lt;li&gt;Ctrl-Cでinteractive-interruptコンディションを発生させる。デバッガが起動する。&lt;/li&gt;
&lt;li&gt;デバッガからREPLのtoplevelに戻る。デバッガの操作?処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;li&gt;REPLを終了する。どうやって？処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「アプリケーションは~/common-lispじゃなくて/var/wwwに置きたいんだけど」 - 「コンフィグ書いたら変えられるよ。ASDFのコンフィグ書いてね。コンフィグの書き方はLisperの常識だよね」&lt;br /&gt;
「~/quicklisp邪魔なんだけど」 - 「ああ、それも変えられるよ。好きな場所に移動して処理系の初期化ファイル書き直してね。初期化ファイル？処理系依存だから自分で調べろ。どう直すか？簡単なLispの式だから自分で直せるよね？」&lt;/p&gt;

&lt;p&gt;多分言いたいことは伝わったかと思う。コマンドラインから扱えないとかパッケージマネージャが我が儘とか色々あるんだけど全ては「Lisperのためだけのものになっている」の一言で表せられる。&lt;/p&gt;

&lt;p&gt;quicklispが我が儘なのはまだ許せる。インストール先のディレクトリが固定されてないと管理しづらいから。しかしASDFがライブラリじゃなくてアプリケーションにまで特定のパスにあることを要求してくるのは納得がいかない。コンパイルやらロードやらテストやらの機能があるんだから.asdファイルのあるディレクトリをルートとしてそこだけで完結してほしい。以前、&lt;a href=&#34;/blog/2014/11/30/quicklisp/&#34;&gt;こんな記事&lt;/a&gt;を書いた所為でASDFの信者と思われているみたいだが、どっちかというとASDFの方が嫌いだ。ASDFが憖っか依存関係の解決までするがためにアプリケーションの置き場まで制約を受ける。手を広げたがために本来の機能が使い辛くなっている。Lisperが制約を受けるのはまだいい。アプリケーションのユーザにまで制約が及ぶのは耐えられない。&lt;/p&gt;

&lt;p&gt;コマンドラインから扱えない問題は多分ノウハウがなかったからだと思う。&lt;a href=&#34;/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/&#34;&gt;以前の記事&lt;/a&gt;で紹介した方法は多分知られていなかった。あとは複雑で使い辛いと評判(だった)のcl-launchか。アプリケーションはおろかquicklispすらREPLに入らないと使えない。ユーザがLispを微塵も知らない可能性すらあるのに。さらに、コマンドラインから使えないということは他のUnixツール群と組み合わせることも困難になる。また、&lt;a href=&#34;http://blog.8arrow.org/entry/20120323/1332516342&#34;&gt;ここ&lt;/a&gt;にあるようにREPLでアプリケーションを起動していると問題もある。&lt;/p&gt;

&lt;p&gt;私はこの問題を解決するためにCIMを作った。clfreaksの時にも喋ったがCIMのメインの機能は&lt;code&gt;cl&lt;/code&gt;コマンドと&lt;code&gt;ql&lt;/code&gt;コマンドだ。&lt;code&gt;cim&lt;/code&gt;コマンドはただの付加価値のためにつけたおまけである。&lt;/p&gt;

&lt;p&gt;もしclコマンドが広く使われるようになればshebangにclを使うだけで実行可能ファイルが作れて、コマンドラインから使えるようになる。qlを使えばREPLに入らずにパッケージをインストール出来る。スクリプトがエラーを出してもデバッガに入るようなことはない。Ctrl-Cでちゃんと止まる。&lt;/p&gt;

&lt;p&gt;これで一部ユニバーサリティの問題は解決出来たんだけだまだまだ未解決問題がある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CIMのインストールが必要になる。&lt;/li&gt;
&lt;li&gt;コマンドラインツールは解決したにしてもディレクトリ丸ごと持ってくるようなアプリケーションはASDFの制約をうける&lt;/li&gt;
&lt;li&gt;コンパイルの問題&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1はやっぱりLispを知らない人に使ってもらいたいならCIMのインストールは省きたい。処理系とquicklispだけ入れたら使えてほしい。やっぱりquicklispに変わってもらうしかないのかな。配布物に実行可能形式を含めてたらPATHも通して欲しいし。&lt;/p&gt;

&lt;p&gt;2のASDFの制約の問題はASDFを環境変数で制御出来るようなのでうまいことする方法を考えている。良い方法があったらまたアウトプットする。&lt;/p&gt;

&lt;p&gt;3は現状CIMで扱いかねてる問題。マクロ展開の問題からコンパイルするのが望ましいんだけどコンパイル後のファイルに互換性がない。しかも互換性がないのに同じ拡張子を使う。そこを上手く扱ってくれるのはASDFなんだけどやっぱり奴は我が儘だし何よりコンパイルしてしまうとAllegroを除いてshebangが効かなくなる。&lt;/p&gt;

&lt;p&gt;解決案はいくつか上がってるんだけどまだ決定的なものはない。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;コンパイルをあきらめる&lt;/li&gt;
&lt;li&gt;本体だけASDFでコンパイルしてエントリポイントになるスクリプトはコンパイルしない&lt;/li&gt;
&lt;li&gt;スタンドアロンバイナリ配布する&lt;/li&gt;
&lt;li&gt;ECLを使ってCのファイルを配布する&lt;/li&gt;
&lt;li&gt;ユーザー側にスタンドアロンバイナリを作らせる&lt;/li&gt;
&lt;li&gt;特定の処理系を要求する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1は下の策。&lt;/p&gt;

&lt;p&gt;2は個人的に推したいところだけどやっぱりASDFが憎い。&lt;/p&gt;

&lt;p&gt;3はクロスコンパイルが壊滅的なCommon Lispでは現実的ではない。&lt;/p&gt;

&lt;p&gt;4はCommon Lispの利点の一つにSBCLやCCLやCMU CLの速度が速いというのがあるから出来れば自由に処理系を選ばせたい。あとECLのランタイムのインストールが必要になる。&lt;/p&gt;

&lt;p&gt;5はやっぱりASDFが憎い。それに依存ライブラリもロードするにはquicklispもロードする必要があって、以前の記事の通りバイナリに邪魔なものが入るしそうでなくてもバイナリが素で60MBとかになる。stripするとアプリケーションとして動かなくなるからstripも出来ない。&lt;/p&gt;

&lt;p&gt;6はコンパイル後のファイルがポータブルな処理系はABCL、CLISP、XCLあたりだが、起動の遅いABCL、微妙に仕様に従ってなくて開発も停滞気味なCLISP、既に開発されていない上にマイナーでライブラリのサポートも薄いXCLとあまり選びたくないものばかり。&lt;/p&gt;

&lt;p&gt;因みに非Lispユーザにも使われているCommon LispアプリケーションにStumpWMがあるが、5の方法を採用している。しかしASDFを使わずにMakefileでコンパイルしている。依存ライブラリも手でインストールする必要がある。出来ればCommon Lispのツールチェーンに載せたまま配布したいところ…&lt;/p&gt;

&lt;p&gt;研究が必要。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>picrinのcodegenプロセスを説明してみる</title>
      <link>/blog/2015/01/10/picrin-codegen-explanation</link>
      <pubDate>Sat, 10 Jan 2015 09:40:51 UTC</pubDate>
      
      <guid>/blog/2015/01/10/picrin-codegen-explanation</guid>
      <description>

&lt;p&gt;今、picrinのcodegenプロセスに手を入れる機運が高まってます。picrinはバイトコードインタプリタなのでS式を渡されたらそれをバイトコードに変換する作業が必要です。それがcodegen。本当はcompileなんだけどpicrinのCのソースコードのコンパイルと紛らわしいからcodegen。私も完全にはプロセスを理解してないので説明して理解度を試しつつ問題点を洗い出します。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;関連ファイル&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;extlib/benz/codegen.c&lt;/li&gt;
&lt;li&gt;extlib/benz/macro.c&lt;/li&gt;
&lt;li&gt;(extlib/benz/read.c)&lt;/li&gt;
&lt;li&gt;(extlib/benz/vm.c)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;おおまかな流れ&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;(&lt;code&gt;read&lt;/code&gt;する)&lt;/li&gt;
&lt;li&gt;マクロ展開する&lt;/li&gt;
&lt;li&gt;コードの解析をする&lt;/li&gt;
&lt;li&gt;バイトコードを生成する&lt;/li&gt;
&lt;li&gt;(実行する)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;今回説明するのは2~4です。&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;マクロ展開&lt;/h1&gt;

&lt;p&gt;入力:Schemeの式&lt;br /&gt;
出力:マクロ展開済みのS式&lt;br /&gt;
副作用:マクロテーブルの更新、ライブラリテーブルの更新、その他マクロ毎の副作用&lt;/p&gt;

&lt;p&gt;extlib/benz/macro.cに処理があります。&lt;/p&gt;

&lt;p&gt;メインの部分はこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
macroexpand_node(pic_state *pic, pic_value expr, struct pic_senv *senv)
{
  switch (pic_type(expr)) {
  case PIC_TT_SYMBOL: {
    return macroexpand_symbol(pic, pic_sym(expr), senv);
  }
  case PIC_TT_PAIR: {
    pic_value car;
    struct pic_macro *mac;

    if (! pic_list_p(expr)) {
      pic_errorf(pic, &amp;quot;cannot macroexpand improper list: ~s&amp;quot;, expr);
    }

    car = macroexpand(pic, pic_car(pic, expr), senv);
    if (pic_sym_p(car)) {
      pic_sym tag = pic_sym(car);

      if (tag == pic-&amp;gt;rDEFINE_SYNTAX) {
        return macroexpand_defsyntax(pic, expr, senv);
      }
      else if (tag == pic-&amp;gt;rLAMBDA) {
        return macroexpand_defer(pic, expr, senv);
      }
      else if (tag == pic-&amp;gt;rDEFINE) {
        return macroexpand_define(pic, expr, senv);
      }
      else if (tag == pic-&amp;gt;rQUOTE) {
        return macroexpand_quote(pic, expr);
      }

      if ((mac = find_macro(pic, tag)) != NULL) {
        return macroexpand_node(pic, macroexpand_macro(pic, mac, expr, senv), senv);
      }
    }

    return pic_cons(pic, car, macroexpand_list(pic, pic_cdr(pic, expr), senv));
  }
  default:
    return expr;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;S式を行きがけ順でマクロ展開していきます。&lt;/p&gt;

&lt;p&gt;リストの先頭にあるものをマクロと疑って展開しようとしますが、見ての通り&lt;code&gt;define-syntax&lt;/code&gt;、&lt;code&gt;lambda&lt;/code&gt;、&lt;code&gt;define&lt;/code&gt;、&lt;code&gt;quote&lt;/code&gt;だけは特別扱いされています。このスペシャルフォーム達は引数に括弧つきのものを取ったり引数を全く触ってほしくなかったりするのでマクロ展開時に特別な処理がされるんですね。他はシンボルは変数名(identifier)として処理し、リストとシンボル以外のものはそのまま返します。&lt;/p&gt;

&lt;p&gt;ここに1つ問題があります。&lt;code&gt;find_macro&lt;/code&gt;です。&lt;a href=&#34;https://github.com/picrin-scheme/picrin/issues/234&#34;&gt;イシューにも挙げられて&lt;/a&gt;いますが、マクロを定義したあと同じ名前の手続を定義したら手続で上書きされる筈なのにマクロとして展開されてしまいます。これはマクロと手続きで別のテーブルを持っていることに起因します。ちゃんと上書きされるようにするにはマクロも変数束縛テーブルに登録すれば解決出来るのかなと思ってます。&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;シンボル&lt;/h2&gt;

&lt;p&gt;変なことはしてません。スコープを遡っていき、最初に見付かったインターンされたシンボルを返します。見付からなかった(=未定義のシンボルだった)ときは新たなgensymを返します。&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;&lt;code&gt;define-syntax&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
macroexpand_defsyntax(pic_state *pic, pic_value expr, struct pic_senv *senv)
{
  pic_value var, val;
  pic_sym sym, rename;

  if (pic_length(pic, expr) != 3) {
    pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
  }

  var = pic_cadr(pic, expr);
  if (! pic_sym_p(var)) {
    pic_errorf(pic, &amp;quot;binding to non-symbol object&amp;quot;);
  }
  sym = pic_sym(var);
  if (! pic_find_rename(pic, senv, sym, &amp;amp;rename)) {
    rename = pic_add_rename(pic, senv, sym);
  } else {
    pic_warnf(pic, &amp;quot;redefining syntax variable: ~s&amp;quot;, pic_sym_value(sym));
  }

  val = pic_cadr(pic, pic_cdr(pic, expr));

  pic_try {
    val = pic_eval(pic, val, pic-&amp;gt;lib);
  } pic_catch {
    pic_errorf(pic, &amp;quot;macroexpand error while definition: %s&amp;quot;, pic_errmsg(pic));
  }

  if (! pic_proc_p(val)) {
    pic_errorf(pic, &amp;quot;macro definition \&amp;quot;~s\&amp;quot; evaluates to non-procedure object&amp;quot;, var);
  }

  define_macro(pic, rename, pic_proc_ptr(val), senv);

  return pic_none_value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;手を入れる候補。やってることは単純で、&lt;code&gt;(define-syntax &amp;lt;name&amp;gt; &amp;lt;definition&amp;gt;)&lt;/code&gt;の形で引数を渡される筈だからnameをdefinitionに関連づけてマクロとして登録します。返り値はnone。返り値はnone。大事なことなので2回言いました。&lt;/p&gt;

&lt;p&gt;一応実行時にはマクロ展開は全て終了してる筈なので&lt;code&gt;define-syntax&lt;/code&gt;をマクロ展開時に消し去っても良い筈なんですが、気持ち悪いですよね。コアを小さくするという意味では正解なんですが…。あとファイルのコンパイルを考えた時に&lt;code&gt;define-syntax&lt;/code&gt;をファイルの外に持ち出せなくなるという実用上の問題もあります。&lt;/p&gt;

&lt;p&gt;あと、definitionがマクロ展開だけで止まってしまうと困るのでdefinitionだけはevalしているのもキモいポイントですね。&lt;/p&gt;

&lt;p&gt;改善案は&lt;code&gt;define&lt;/code&gt;と同じようにすること。そのためにはマクロ展開後の処理(analyze、codegen、VM命令)にも&lt;code&gt;define-syntax&lt;/code&gt;用の処理を入れる必要があって、面倒。&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt;の扱いは面倒です。一番分かり易い例は再帰マクロですかね。マクロの定義中に定義中のマクロが見えてる必要があります。この解決策として&lt;code&gt;lambda&lt;/code&gt;だけはマクロ展開を遅延(defer)します。じゃあいつ遅延されたマクロが展開されるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;pic_value
pic_macroexpand(pic_state *pic, pic_value expr, struct pic_lib *lib)
{
  struct pic_lib *prev;
  pic_value v;

#if DEBUG
  puts(&amp;quot;before expand:&amp;quot;);
  pic_debug(pic, expr);
  puts(&amp;quot;&amp;quot;);
#endif

  /* change library for macro-expansion time processing */
  prev = pic-&amp;gt;lib;
  pic-&amp;gt;lib = lib;

  lib-&amp;gt;env-&amp;gt;defer = pic_nil_value(); /* the last expansion could fail and leave defer field old */

  v = macroexpand(pic, expr, lib-&amp;gt;env);

  macroexpand_deferred(pic, lib-&amp;gt;env);

  pic-&amp;gt;lib = prev;

#if DEBUG
  puts(&amp;quot;after expand:&amp;quot;);
  pic_debug(pic, v);
  puts(&amp;quot;&amp;quot;);
#endif

  return v;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;macroexpand&lt;/code&gt;の後です。&lt;code&gt;macroexpand&lt;/code&gt;は&lt;code&gt;macroexpand_node&lt;/code&gt;の薄いラッパと思って下さい。&lt;/p&gt;

&lt;p&gt;遅延されたマクロ展開は&lt;code&gt;senv-&amp;gt;defer&lt;/code&gt;にpushされ、&lt;code&gt;macroexpand_deferred&lt;/code&gt;で1つずつ&lt;code&gt;macroexpand_lambda&lt;/code&gt;されます。&lt;code&gt;macroexpand_lambda&lt;/code&gt;はまあ、想像通りです。formalをα変換したあとformalとbodyをマクロ展開します。α変換は&lt;code&gt;senv&lt;/code&gt;にシンボル -&amp;gt; gensymのキーペアを突っ込むだけです。返り値は&lt;code&gt;(lambda formal body)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;define&lt;/h2&gt;

&lt;p&gt;比較的単純です。&lt;code&gt;(define name value)&lt;/code&gt;の他に&lt;code&gt;(define (name formal) body)&lt;/code&gt;のMIT記法にも対応する必要があるのでマクロ展開時に特別扱いされてます。&lt;code&gt;(define name value)&lt;/code&gt;を返り値として返します。MIT記法もこの形に正規化されます。&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;quote&lt;/h2&gt;

&lt;p&gt;特に語る事はないです。&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;他のマクロ&lt;/h2&gt;

&lt;p&gt;Schemeのマクロ展開は簡単で、マクロ手続をbody、展開場所の環境、定義場所の環境の3つを引数として呼び出せば終りです。勿論&lt;code&gt;macroexpand_node&lt;/code&gt;を見て分かるように最後まで展開します。picrinはCommon Lisp風の伝統的マクロもサポートしてるので伝統的マクロだった時はbodyだけを引数として呼び出します。&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;蛇足&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;define-syntax&lt;/code&gt;だけを指摘しましたが、マクロ展開後にnoneになるマクロは他にもあります。library関係全部です。個人的にはやつらもVM命令まで残すべきだと思ってます。&lt;/p&gt;

&lt;p&gt;因みにもう1つlibrary関係の問題があります。&lt;code&gt;define-library&lt;/code&gt;直下の&lt;code&gt;begin&lt;/code&gt;についてです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-library (hoge)
  (begin
    (define foo ...)
    (define bar ...)
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようなコードを考えます。&lt;code&gt;define-library&lt;/code&gt;直下の&lt;code&gt;begin&lt;/code&gt;は他とセマンティクスが違って、&lt;code&gt;begin&lt;/code&gt;内のコードをトップレベルで定義されたかのように扱う必要があります。しかしpicrinは普通の&lt;code&gt;begin&lt;/code&gt;と同じように扱っています。これがどのような違いを産むかというと、コンパイル順を見れば分かり易いです。&lt;/p&gt;

&lt;p&gt;仕様: fooのマクロ展開-&amp;gt;fooの解析-&amp;gt;fooのコード生成-&amp;gt;barのマクロ展開-&amp;gt;barの解析-&amp;gt;barのコード生成&lt;br /&gt;
picrin: fooのマクロ展開-&amp;gt;barのマクロ展開-&amp;gt;fooの解析-&amp;gt;barの解析-&amp;gt;fooのコード生成-&amp;gt;barのコード生成&lt;/p&gt;

&lt;p&gt;picrinのコンパイル順序だとマクロ展開を先にやってしまうのでマクロ展開中に同じ&lt;code&gt;begin&lt;/code&gt;内で&lt;code&gt;define&lt;/code&gt;されたシンボルが見えなくなってしまいます。尚、後述しますが今のpicrinはこのコンパイル順序のおかげで手続の相互参照が可能になってます。ここもどうにかしないといけない。&lt;/p&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;コード解析&lt;/h1&gt;

&lt;p&gt;入力:マクロ展開済みのS式&lt;br /&gt;
出力:中間表現&lt;br /&gt;
副作用:無し&lt;/p&gt;

&lt;p&gt;extlib/benz/codegen.cに処理があります。&lt;/p&gt;

&lt;p&gt;ここの処理ではS式をVM命令に近いS式に書き換えます。&lt;code&gt;(+ 1 x)&lt;/code&gt;が&lt;code&gt;(+ (quote 1) (gref x))&lt;/code&gt;になるなど。この解析後のS式は特に呼び名はなさそうなので中間表現と呼んでおきます。&lt;/p&gt;

&lt;p&gt;中間表現には&lt;code&gt;cons&lt;/code&gt;、&lt;code&gt;car&lt;/code&gt;などの16の基本的な手続に対応する命令や&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;define&lt;/code&gt;などの6つのスペシャルフォームの他、&lt;code&gt;call&lt;/code&gt;、&lt;code&gt;tailcall&lt;/code&gt;、&lt;code&gt;call-with-values&lt;/code&gt;、&lt;code&gt;tailcall-with-values&lt;/code&gt;の4つの手続呼び出し命令、&lt;code&gt;gref&lt;/code&gt;、&lt;code&gt;lref&lt;/code&gt;、&lt;code&gt;cref&lt;/code&gt;の3つの変数参照、&lt;code&gt;return&lt;/code&gt;があります。合計30の命令です。JIT化も視野に入れてるので基本命令は少なくする方針なんでしょう。また、組み込みも意識しているのでその気になればコアを小さく出来るようにする意味もあるのかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gref&lt;/code&gt;はグローバル変数、&lt;code&gt;lref&lt;/code&gt;はローカル変数、&lt;code&gt;cref&lt;/code&gt;はクcaptured変数を参照します。ここでピンときた方も居るかと思いますが、コード解析がスコープ周りを担当しています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;analyze_*&lt;/code&gt;系は&lt;code&gt;analyze_state&lt;/code&gt;を持ち回ししますが、こいつはpicrin VMとスコープを表現する構造体の他に中間命令のシンボル(の一部)のキャッシュや中間命令にそのまま翻訳されるべき手続(&lt;code&gt;cons&lt;/code&gt;や&lt;code&gt;car&lt;/code&gt;)のキャッシュを持ちます。手続はライブラリに属するのでキャッシュを捜すときに少し特別な処理が入ってますね。中間命令のシンボルのキャッシュが一部だけなのは他は&lt;code&gt;pic_state&lt;/code&gt;構造体が既に持ってるからですね。&lt;/p&gt;

&lt;p&gt;さて、本体はやはり&lt;code&gt;analyze_node&lt;/code&gt;ですが30命令分のifを持つので少し大きいですね。載せるのをやめて面白いやつだけ取り上げましょうか。どうでもいいけどこれ、caseじゃなくてif elseなので並び換えたら高速化しそうですね。&lt;/p&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;変数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;analyze_var&lt;/code&gt;がスコープの深さでgref、lref、crefに振り分けます。&lt;code&gt;analyze_*_var&lt;/code&gt;はgref、lref、crefを返すだけの関数。&lt;/p&gt;

&lt;p&gt;スコープを遡って変数を捜していき、変数が見付かったスコープの深さ=今いるスコープの深さならグローバル変数、、今いるスコープならローカル変数、それ以外なら捕捉変数です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_var(analyze_state *state, pic_sym sym)
{
  pic_state *pic = state-&amp;gt;pic;
  int depth;

  if ((depth = find_var(state, sym)) == -1) {
    pic_errorf(pic, &amp;quot;unbound variable %s&amp;quot;, pic_symbol_name(pic, sym));
  }

  if (depth == state-&amp;gt;scope-&amp;gt;depth) {
    return analyze_global_var(state, sym);
  } else if (depth == 0) {
    return analyze_local_var(state, sym);
  } else {
    return analyze_free_var(state, sym, depth);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにこれ、変数が見付からなかったらエラー出してますけどSchemeは仕様上は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (foo) (bar))
(define (bar) ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように後から定義することも可能なので仕様に準拠してないことになります。ここが手を入れるポイント2つ目。&lt;/p&gt;

&lt;p&gt;改善案は見付からなかった変数は一旦NOWHEREとかに束縛しておいてanalyze時にはエラーを出さない。実行時にNOWHEREに束縛された変数が出てくればエラー。&lt;/p&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;define&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_define(analyze_state *state, pic_value obj)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value var, val;
  pic_sym sym;

  if (pic_length(pic, obj) != 3) {
    pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
  }

  var = pic_list_ref(pic, obj, 1);
  if (! pic_sym_p(var)) {
    pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
  } else {
    sym = pic_sym(var);
  }
  var = analyze_declare(state, sym);

  if (pic_pair_p(pic_list_ref(pic, obj, 2))
      &amp;amp;&amp;amp; pic_sym_p(pic_list_ref(pic, pic_list_ref(pic, obj, 2), 0))
      &amp;amp;&amp;amp; pic_sym(pic_list_ref(pic, pic_list_ref(pic, obj, 2), 0)) == pic-&amp;gt;rLAMBDA) {
    pic_value formals, body_exprs;

    formals = pic_list_ref(pic, pic_list_ref(pic, obj, 2), 1);
    body_exprs = pic_list_tail(pic, pic_list_ref(pic, obj, 2), 2);

    val = analyze_defer(state, pic_sym_value(sym), formals, body_exprs);
  } else {
    if (pic_length(pic, obj) != 3) {
      pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
    }
    val = analyze(state, pic_list_ref(pic, obj, 2), false);
  }

  return pic_list3(pic, pic_symbol_value(pic-&amp;gt;sSETBANG), var, val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;手続を&lt;code&gt;define&lt;/code&gt;するときに上の後から定義(interreferencial definitionという)を一部の状況で実現するために束縛する値がlambdaかどうかで場合分けしています。lambdaの場合は&lt;code&gt;analyze_defer&lt;/code&gt;を使います。そうすることで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(begin
  (define (foo) (bar))
  (define (bar) ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けばbegin -&amp;gt; define foo -&amp;gt; define bar -&amp;gt; (analyze deferred) -&amp;gt; foo本体 -&amp;gt; bar本体
の順番に解析されることになるのでコンパイルが通ります。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;define&lt;/code&gt;された手続に名前をつける(シンボルと手続を関連付けるのではない)役割もあります。&lt;/p&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;lambda&lt;/h2&gt;

&lt;p&gt;また例の再帰定義とかで面倒なやつです。&lt;code&gt;analyze_lambda&lt;/code&gt;が引数のチェックだけしたら&lt;code&gt;analyze_defer&lt;/code&gt;に丸投げして、&lt;code&gt;analyze_defer&lt;/code&gt;はモックのエントリーポイントだけ返してdeferリストに処理をpushします。&lt;/p&gt;

&lt;p&gt;んで後から呼ばれる&lt;code&gt;analyze_deferred&lt;/code&gt;が1つずつ&lt;code&gt;analyze_procedure&lt;/code&gt;します。マクロ展開と微妙に名前が違うのが気になりますね。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;analyze_procedure&lt;/code&gt;が本体になるのですが、スコープを作るので少しややこしいことになってます。&lt;/p&gt;

&lt;h3 id=&#34;toc_14&#34;&gt;スコープと変数&lt;/h3&gt;

&lt;p&gt;スコープの解説をしてませんでしたね。変数を参照するときはスコープの関係で4種類出てきます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;グローバル変数 : トップレベルで&lt;code&gt;define&lt;/code&gt;されたもの&lt;/li&gt;
&lt;li&gt;ローカル変数 : lambda内で&lt;code&gt;define&lt;/code&gt;されたもの&lt;/li&gt;
&lt;li&gt;自由変数 : lambdaの外かつトップレベルでない変数&lt;/li&gt;
&lt;li&gt;引数 : lambdaの引数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;captureについて: 変数を導入した側から見たら「捕捉された変数」で、変数を参照する側から見たら「自由変数」です。&lt;/p&gt;

&lt;p&gt;さて、変数の種類を見たところで&lt;code&gt;analyze_procedure&lt;/code&gt;の定義を見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_procedure(analyze_state *state, pic_value name, pic_value formals, pic_value body_exprs)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value args, locals, varg, captures, body;

  assert(pic_sym_p(name) || pic_false_p(name));

  if (push_scope(state, formals)) {
    analyze_scope *scope = state-&amp;gt;scope;
    pic_sym *var;
    size_t i;

    args = pic_nil_value();
    for (i = xv_size(&amp;amp;scope-&amp;gt;args); i &amp;gt; 0; --i) {
      var = xv_get(&amp;amp;scope-&amp;gt;args, i - 1);
      pic_push(pic, pic_sym_value(*var), args);
    }

    varg = scope-&amp;gt;varg
      ? pic_true_value()
      : pic_false_value();

    /* To know what kind of local variables are defined, analyze body at first. */
    body = analyze(state, pic_cons(pic, pic_sym_value(pic-&amp;gt;rBEGIN), body_exprs), true);

    analyze_deferred(state);

    locals = pic_nil_value();
    for (i = xv_size(&amp;amp;scope-&amp;gt;locals); i &amp;gt; 0; --i) {
      var = xv_get(&amp;amp;scope-&amp;gt;locals, i - 1);
      pic_push(pic, pic_sym_value(*var), locals);
    }

    captures = pic_nil_value();
    for (i = xv_size(&amp;amp;scope-&amp;gt;captures); i &amp;gt; 0; --i) {
      var = xv_get(&amp;amp;scope-&amp;gt;captures, i - 1);
      pic_push(pic, pic_sym_value(*var), captures);
    }

    pop_scope(state);
  }
  else {
    pic_errorf(pic, &amp;quot;invalid formal syntax: ~s&amp;quot;, args);
  }

  return pic_list7(pic, pic_sym_value(pic-&amp;gt;sLAMBDA), name, args, locals, varg, captures, body);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコープを作ったあとは最初に引数をスコープに登録して本体内ででcapture出来るようにしてます。んで本体をanalyzeしてローカル変数と捕捉された変数を洗い出してます。&lt;/p&gt;

&lt;p&gt;因みにvargというのはCommon Lispでいう&amp;amp;restや&amp;amp;optionalを引っ括めたものです。&lt;/p&gt;

&lt;h2 id=&#34;toc_15&#34;&gt;begin&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_begin(analyze_state *state, pic_value obj, bool tailpos)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value seq;
  bool tail;

  switch (pic_length(pic, obj)) {
  case 1:
    return analyze(state, pic_none_value(), tailpos);
  case 2:
    return analyze(state, pic_list_ref(pic, obj, 1), tailpos);
  default:
    seq = pic_list1(pic, pic_symbol_value(pic-&amp;gt;sBEGIN));
    for (obj = pic_cdr(pic, obj); ! pic_nil_p(obj); obj = pic_cdr(pic, obj)) {
      if (pic_nil_p(pic_cdr(pic, obj))) {
        tail = tailpos;
      } else {
        tail = false;
      }
      seq = pic_cons(pic, analyze(state, pic_car(pic, obj), tail), seq);
    }
    return pic_reverse(pic, seq);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そんなに大したコードじゃないんですけど末尾呼出最適化のためのコードが垣間見えたので載せました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;自身が末尾位置にいれば&lt;code&gt;begin&lt;/code&gt;の最後の式は末尾位置になりますがそれ以外は必ず非末尾位置になるよねーってコードです。&lt;/p&gt;

&lt;h1 id=&#34;toc_16&#34;&gt;バイトコード生成&lt;/h1&gt;

&lt;p&gt;入力:中間表現&lt;br /&gt;
出力:バイトコード&lt;br /&gt;
副作用:無し&lt;/p&gt;

&lt;p&gt;extlib/benz/codegen.cに処理があります。&lt;/p&gt;

&lt;p&gt;ここの処理では中間表現をスタックベースのpicrin VM命令に変換します。&lt;/p&gt;

&lt;h2 id=&#34;toc_17&#34;&gt;VM命令やlambdaの内部表現&lt;/h2&gt;

&lt;h3 id=&#34;toc_18&#34;&gt;VM命令フォーマット&lt;/h3&gt;

&lt;p&gt;フォーマットは3種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct pic_code {
  enum pic_opcode insn;
  union {
    int i;
    char c;
    struct {
      int depth;
      int idx;
    } r;
  } u;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見ての通り命令番号(opcode)+&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;char&lt;/li&gt;
&lt;li&gt;int2つ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;になっています。因みに普通使われるのは1. intで、2. charはOP_PUSHCHARのみ、3. int2つはOP_CREFとOP_CSETのみに使われます。また、引数(?)を全く持たない命令もあります(スタックマシンなため)。&lt;/p&gt;

&lt;h3 id=&#34;toc_19&#34;&gt;愉快なVM命令たち&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;enum pic_opcode {
  OP_NOP,
  OP_POP,
  OP_PUSHNIL,
  OP_PUSHTRUE,
  OP_PUSHFALSE,
  OP_PUSHINT,
  OP_PUSHCHAR,
  OP_PUSHCONST,
  OP_GREF,
  OP_GSET,
  OP_LREF,
  OP_LSET,
  OP_CREF,
  OP_CSET,
  OP_JMP,
  OP_JMPIF,
  OP_NOT,
  OP_CALL,
  OP_TAILCALL,
  OP_RET,
  OP_LAMBDA,
  OP_CONS,
  OP_CAR,
  OP_CDR,
  OP_NILP,
  OP_ADD,
  OP_SUB,
  OP_MUL,
  OP_DIV,
  OP_MINUS,
  OP_EQ,
  OP_LT,
  OP_LE,
  OP_STOP
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大体名前から分かるかと思います。&lt;code&gt;quote&lt;/code&gt;は&lt;code&gt;OP_PUSH*&lt;/code&gt;系になります。&lt;code&gt;OP_STOP&lt;/code&gt;はあるのに&lt;code&gt;OP_START&lt;/code&gt;がないのは分かりますね。開始はユーザーの操作から始まるのに対して停止はプログラム側が行うからです。&lt;/p&gt;

&lt;h3 id=&#34;toc_20&#34;&gt;lambdaとか&lt;/h3&gt;

&lt;p&gt;lambdaとかのエントリポイント付きのコード1まとまりはirepと呼ばれています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct pic_irep {
  PIC_OBJECT_HEADER
  pic_sym name;
  pic_code *code;
  int argc, localc, capturec;
  bool varg;
  struct pic_irep **irep;
  pic_valuel *pool;
  size_t clen, ilen, plen;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PIC_OBJECT_HEADER&lt;/code&gt;: オブジェクトタイプのタグ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;: 名前（あれば）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*code&lt;/code&gt;: VM命令たち&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argc&lt;/code&gt;、 &lt;code&gt;localc&lt;/code&gt;、 &lt;code&gt;capturec&lt;/code&gt;: 引数数、ローカル変数数、捕捉された変数数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;varg&lt;/code&gt;: &amp;amp;rest引数を持つか&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**irep&lt;/code&gt;: irepプール&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*pool&lt;/code&gt;: 定数プール&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clen&lt;/code&gt;、&lt;code&gt;ilen&lt;/code&gt;、&lt;code&gt;plen&lt;/code&gt;: *code、**irep、*poolの長さ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スコープを作るので変数を格納するpoolを持ちます。そしてlambdaだけは定数プールとは別にirepに格納します。&lt;/p&gt;

&lt;h2 id=&#34;toc_21&#34;&gt;コード生成&lt;/h2&gt;

&lt;p&gt;本体は&lt;code&gt;codegen&lt;/code&gt;なんですがこれまた長いので掻い摘んで。帰りがけ順でコード生成します。&lt;/p&gt;

&lt;h3 id=&#34;toc_22&#34;&gt;cons&lt;/h3&gt;

&lt;p&gt;まずは肩馴らし。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sCONS) {
    codegen(state, pic_list_ref(pic, obj, 1));
    codegen(state, pic_list_ref(pic, obj, 2));
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_CONS;
    cxt-&amp;gt;clen++;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数1と引数2を生成する命令を吐いてから&lt;code&gt;OP_CONS&lt;/code&gt;命令を吐きます。引数1と引数2は自ら値をスタックにPUSHします。&lt;/p&gt;

&lt;h3 id=&#34;toc_23&#34;&gt;quote&lt;/h3&gt;

&lt;p&gt;少し長いですが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sQUOTE) {
    int pidx;

    obj = pic_list_ref(pic, obj, 1);
    switch (pic_type(obj)) {
    case PIC_TT_BOOL:
      if (pic_true_p(obj)) {
        cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHTRUE;
      } else {
        cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHFALSE;
      }
      cxt-&amp;gt;clen++;
      return;
    case PIC_TT_INT:
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHINT;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = pic_int(obj);
      cxt-&amp;gt;clen++;
      return;
    case PIC_TT_NIL:
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHNIL;
      cxt-&amp;gt;clen++;
      return;
    case PIC_TT_CHAR:
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHCHAR;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.c = pic_char(obj);
      cxt-&amp;gt;clen++;
      return;
    default:
      if (cxt-&amp;gt;plen &amp;gt;= cxt-&amp;gt;pcapa) {
        cxt-&amp;gt;pcapa *= 2;
        cxt-&amp;gt;pool = pic_realloc(pic, cxt-&amp;gt;pool, sizeof(pic_value) * cxt-&amp;gt;pcapa);
      }
      pidx = (int)cxt-&amp;gt;plen++;
      cxt-&amp;gt;pool[pidx] = obj;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHCONST;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = pidx;
      cxt-&amp;gt;clen++;
      return;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リテラルや定数をPUSHする命令を吐いてますね。&lt;/p&gt;

&lt;h3 id=&#34;toc_24&#34;&gt;REF系&lt;/h3&gt;

&lt;p&gt;local、captureはirep構造体についてるのpoolを参照します。globalはVMのシンボルテーブルから直接引きます。因みにpicrinのシンボルはただのintです。&lt;/p&gt;

&lt;p&gt;captureは上位のスコープで既に出てきた変数を参照するだけなので「n個上位のm番目のcaptured変数」と指定するだけなので簡単ですが、localはarg、普通のlocal、下位スコープにcaptureされたlocal、の3つに分けて置いているので少し面倒です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  if (sym == state-&amp;gt;sGREF) {
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_GREF;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = pic_sym(pic_list_ref(pic, obj, 1));
    cxt-&amp;gt;clen++;
    return;
  } else if (sym == state-&amp;gt;sCREF) {
    pic_sym name;
    int depth;

    depth = pic_int(pic_list_ref(pic, obj, 1));
    name  = pic_sym(pic_list_ref(pic, obj, 2));
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_CREF;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.r.depth = depth;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.r.idx = index_capture(state, name, depth);
    cxt-&amp;gt;clen++;
    return;
  } else if (sym == state-&amp;gt;sLREF) {
    pic_sym name;
    int i;

    name = pic_sym(pic_list_ref(pic, obj, 1));
    if ((i = index_capture(state, name, 0)) != -1) {
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_LREF;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = i + (int)xv_size(&amp;amp;cxt-&amp;gt;args) + (int)xv_size(&amp;amp;cxt-&amp;gt;locals) + 1;
      cxt-&amp;gt;clen++;
      return;
    }
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_LREF;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = index_local(state, name);
    cxt-&amp;gt;clen++;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにset系もほぼ同じようなコードです。&lt;/p&gt;

&lt;h3 id=&#34;toc_25&#34;&gt;lambda&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sLAMBDA) {
    int k;

    if (cxt-&amp;gt;ilen &amp;gt;= cxt-&amp;gt;icapa) {
      cxt-&amp;gt;icapa *= 2;
      cxt-&amp;gt;irep = pic_realloc(pic, cxt-&amp;gt;irep, sizeof(struct pic_irep *) * cxt-&amp;gt;icapa);
    }
    k = (int)cxt-&amp;gt;ilen++;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_LAMBDA;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = k;
    cxt-&amp;gt;clen++;

    cxt-&amp;gt;irep[k] = codegen_lambda(state, obj);
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;codegen_lambda&lt;/code&gt;に投げているのでこの部分は簡単です。irepプールにコードを置いてそれを参照する命令を吐くだけ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;codegen_lambda&lt;/code&gt;はというとそこまで長くなくて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static struct pic_irep *
codegen_lambda(codegen_state *state, pic_value obj)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value name, args, locals, closes, body;
  bool varg;

  name = pic_list_ref(pic, obj, 1);
  args = pic_list_ref(pic, obj, 2);
  locals = pic_list_ref(pic, obj, 3);
  varg = pic_true_p(pic_list_ref(pic, obj, 4));
  closes = pic_list_ref(pic, obj, 5);
  body = pic_list_ref(pic, obj, 6);

  /* inner environment */
  push_codegen_context(state, name, args, locals, varg, closes);
  {
    /* body */
    codegen(state, body);
  }
  return pop_codegen_context(state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;単純に本体に対して&lt;code&gt;codegen&lt;/code&gt;を呼んで出来た命令を取り出してるだけです。&lt;/p&gt;

&lt;h3 id=&#34;toc_26&#34;&gt;if&lt;/h3&gt;

&lt;p&gt;schemeはほとんどの制御を継続に任せているのでなんとjmp命令を吐くのはifだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sIF) {
    int s, t;

    codegen(state, pic_list_ref(pic, obj, 1));

    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_JMPIF;
    s = (int)cxt-&amp;gt;clen++;

    /* if false branch */
    codegen(state, pic_list_ref(pic, obj, 3));
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_JMP;
    t = (int)cxt-&amp;gt;clen++;

    cxt-&amp;gt;code[s].u.i = (int)cxt-&amp;gt;clen - s;

    /* if true branch */
    codegen(state, pic_list_ref(pic, obj, 2));
    cxt-&amp;gt;code[t].u.i = (int)cxt-&amp;gt;clen - t;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_27&#34;&gt;call&lt;/h3&gt;

&lt;p&gt;思ったより短いです。単純に引数を評価する命令を吐いたあと引数の数を指定して呼ぶだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == state-&amp;gt;sCALL || sym == state-&amp;gt;sTAILCALL) {
    int len = (int)pic_length(pic, obj);
    pic_value elt;

    pic_for_each (elt, pic_cdr(pic, obj)) {
      codegen(state, elt);
    }
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = (sym == state-&amp;gt;sCALL) ? OP_CALL : OP_TAILCALL;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = len - 1;
    cxt-&amp;gt;clen++;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_28&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;これを書くのに半日掛かりましたがちゃんとコンパイルプロセスを理解して問題を洗い出すことが出来ました。良かった。&lt;/p&gt;

&lt;p&gt;今のところ中間表現までS式なのでS式操作に長けたSchemeでコンパイラ書けないかなとか考えてますが現状マクロ展開で副作用があるので厳しいですね。&lt;/p&gt;

&lt;p&gt;因みに気付いた方もいらっしゃるかと思いますが今のpicrinは最適化をtco以外は行っていません。行うとしたら&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;マクロ展開後にコンパイラマクロ展開を挟む&lt;/li&gt;
&lt;li&gt;中間表現から一旦ssa形式の第二中間表現に落して定数伝播や畳み込みなどの一般的な最適化を行なう&lt;/li&gt;
&lt;li&gt;生成されたvm命令に対して覗き穴最適化を行なう&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;あたりかなと思います。1. は楽しそうですけど普通のマクロ展開のバグとか問題に悩んでる今入れるべきではないですし、2. は効果高いですしjit化の布石にもなりますが実装コストが高いのでwasabiz次第かなといったところ、3. は今どの程度非効率な命令が吐かれてるのか分からないので効果が見えにくいですね。&lt;/p&gt;

&lt;p&gt;いずれにせよ最適化は仕様準拠してからにしますか。&lt;/p&gt;

&lt;p&gt;何か質問や突っ込みがあれば@blackenedgoldまで。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FreeBSDの環境構築</title>
      <link>/blog/2015/01/08/freebsd-environment-setups</link>
      <pubDate>Thu, 08 Jan 2015 14:37:36 UTC</pubDate>
      
      <guid>/blog/2015/01/08/freebsd-environment-setups</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;/blog/2014/12/27/freebsd/&#34;&gt;以前の記事&lt;/a&gt;の続編。FreeBSDで普通の(Ubuntuで使っていたのと同程度の)環境を整えようとしたときの話。普通ならPC BSDを使えば苦労しないんだろうけど私のラップトップは少し古いのか癖があるのかGPTパーティションに対応してなくてPC BSDのインストーラが使えなかったのでFreeBSDを入れてデスクトップ環境を一から構築した。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;キーボード&lt;/h1&gt;

&lt;p&gt;デフォルトでdvorakにしてるのに起動時にはqwertyになってる問題。なんかいつのまにか解決してた。多分だけど /etc/rc.confに&lt;code&gt;keymap=&amp;quot;jp.106&amp;quot;&lt;/code&gt;書いてから直った気がする。LANGの設定かも。&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Firefox&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;漢字が汚ない問題&lt;/h2&gt;

&lt;p&gt;フォントの問題と思ってたらアンチエイリアスの方だった。KDEの設定で[システム設定]-&amp;gt;[アプリケーションの外観]-&amp;gt;[フォント]-&amp;gt;アンチエイリアスの設定-&amp;gt;[スタイルのヒント]をなしにすると漢字にもアンチエイリアスが掛かる。しかしHelveticaが汚ない問題は直らなかった。というか今度はアンチエイリアスが掛かりすぎてぼやけてしまうようになった。&lt;a href=&#34;https://wiki.archlinux.org/index.php/Firefox_(%E6%97%A5%E6%9C%AC%E8%AA%9E&#34;&gt;Firefox (日本語) - ArchWiki&lt;/a&gt;)に解決策があった。ビットマップフォントを拒否すれば良いらしい。&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;メニューが日本語にならない問題&lt;/h2&gt;

&lt;p&gt;クイックロケールチェンジャーみたいなのがいつの間にか入ってたのでそれを使った。それを見るとロケールに日本語が入ってるのにデフォルトで英語を使うようになってたので英語のロケールを削除して日本語だけにしたらメニューも日本語になった。&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Flash&lt;/h2&gt;

&lt;p&gt;一応&lt;a href=&#34;https://www.freebsd.org/doc/ja/books/handbook/desktop-browsers.html&#34;&gt;公式ハンドブック&lt;/a&gt;に設定方法が載ってるが、これでは動かなかった。linuxの互換レイヤーがカーネルパニック起こしてた。
&lt;code&gt;sudo sysctl compat.linux.osrelease=2.6.18&lt;/code&gt;したらwww/linux-c6-flashplugin11のコンパイルと&lt;code&gt;nspluginwrapper -a -v -i&lt;/code&gt;が通った。勿論後でcompat.linux.osrelease=2.6.18は/etc/sysctl.confに書き足した。あと/ect/rc.confにlinux_enable=YESも書いてある。多分必要。&lt;/p&gt;

&lt;p&gt;蛇足だけどlinux-c6がCentOS6互換レイヤ、linux-f10がFedora10互換レイヤらしい。排他的っぽい。&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Dropbox&lt;/h1&gt;

&lt;p&gt;DropboxのデスクトップアプリはFreeBSDをサポートしないものの、pkgにdropboxのAPIを叩くコマンドラインスクリプトがある。dropbox-api-commandって名前。手動でsyncすることになるけど実際スマホと写真のやりとに使ってる程度なので必要なときに手動でsyncしてる。unisonみたいな使い方。&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Wifi&lt;/h1&gt;

&lt;p&gt;KDEにデフォルトでセットアップアプリケーションがついてこないっぽいのでwifimgrを入れた。&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;SSH Key&lt;/h1&gt;

&lt;p&gt;ksshaskpassを導入、~/.xprofileに&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export LANG=ja_JP.UTF-8
export LC_CTYPE=ja_JP.UTF-8
export LANG=ja_JP.UTF-8
export SSH_ASKPASS=/usr/local/bin/ksshaskpass
eval $(ssh-agent) &amp;gt;&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加、~/.kde/Autostart/に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
export SSH_ASKPASS=/usr/local/bin/ksshaskpass
/usr/bin/ssh-add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行権限付きでssh-addという名前で保存してあとはKDE Walletをポチポチやったらログイン時にマスターパスワードを聞かれて、ログイン後はパスワード不要になった。&lt;/p&gt;

&lt;p&gt;また蛇足。Xの起動時に読まれる設定ファイルは.xinitrc、.xprofile、.xsessionなどがある。.xsessionは過去の遺物、.xinitrcは&lt;code&gt;startx&lt;/code&gt;された後ウィンドウマネージャの起動まで管理するスクリプトで由緒あるが最近は使われないことが多い、.xprofileは設定だけでウィンドウマネージャの起動まではしない設定ファイルで、gdm、kdmなどのウィンドウマネージャから読まれるとのこと。.xinitrcに.xprofileを読みにいく行を書いておけばXに関連する主な設定は.xprofileに書いておけば良い。&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Emacsでximが使えない問題&lt;/h1&gt;

&lt;p&gt;uim-ximが起動してなかった。&lt;/p&gt;

&lt;p&gt;.xprofileに&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export XIM=&amp;quot;uim&amp;quot;
export GTK_IM_MODULE=uim
export QT_IM_MODULE=uim
export XMODIFIERS=&#39;@im=uim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を書いて、.kde4/Autostart/に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
exec /usr/local/bin/uim-xim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を置いておけば使えるようになった。&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;残った問題&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;スリープからの復帰時にディスプレイが点かない&lt;/li&gt;
&lt;li&gt;ラップトップ内のwifiが使えない&lt;/li&gt;
&lt;li&gt;音が鳴らない&lt;/li&gt;
&lt;li&gt;KVM相当のものが使えない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;やっぱうちのラップトップ(TOSHIBAのDynabook)特殊なのかなあ。&lt;/p&gt;

&lt;p&gt;※ 2015-1-10 追記
アプリケーションで音が鳴らない問題は、ドライバを確認したところ適切にロード出来てる。&lt;code&gt;echo aaa &amp;gt; /dev/dsp0.0&lt;/code&gt;も動く（音がなる）ので訝してると、デフォルトの&amp;rdquo;出力&amp;rdquo;デバイスがマイク（！）になってました。
よくみると電源問題で色々いじってたときに/etc/sysctl.confに&lt;code&gt;hw.snd.default_unit=1&lt;/code&gt;を書いてました。これを0にしてやるとちゃんとスピーカから音が出ました。めでたしめでたし。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSお引っ越しの時のデータ移行の自分用注意点</title>
      <link>/blog/2015/01/04/migration-memo</link>
      <pubDate>Sun, 04 Jan 2015 05:26:25 UTC</pubDate>
      
      <guid>/blog/2015/01/04/migration-memo</guid>
      <description>

&lt;p&gt;自分用。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;コピー&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cp -R&lt;/code&gt;じゃだめ。タイムスタンプが変わる。アーカイブ専用に&lt;code&gt;cp -a&lt;/code&gt;がある。あるいは&lt;code&gt;rsync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移動するのは

&lt;ul&gt;
&lt;li&gt;非隠しフォルダ/ファイル

&lt;ul&gt;
&lt;li&gt;但しDownloads/は除く。あれはプラットフォーム依存なバイナリなんかも含む&lt;/li&gt;
&lt;li&gt;Dropbox/はどっちでも良い。コピーせずにDropboxの同期に任せた方が確実&lt;/li&gt;
&lt;li&gt;Desktop/はどうせ空だからコピーしてしまっても害はない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;.ssh/&lt;/li&gt;
&lt;li&gt;.emacs.d/&lt;/li&gt;
&lt;li&gt;.twittering-mode.gpg&lt;/li&gt;
&lt;li&gt;.gitconfig&lt;/li&gt;
&lt;li&gt;.thunderbird/&lt;/li&gt;
&lt;li&gt;.config/&lt;/li&gt;
&lt;li&gt;残りの隠しファイルはdot.filesにある&lt;/li&gt;
&lt;li&gt;もしかしたら.mozilla/もコピーしておくといいかも&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;compile/以下は&lt;code&gt;make clean&lt;/code&gt;しておく。オブジェクトファイルがプラットフォーム依存だからコピーする意味ない&lt;/li&gt;
&lt;li&gt;compile/以下はファイル数が多くて時間かかるので要らないものはこの際削除&lt;/li&gt;
&lt;li&gt;同じ理由で.cim/, .rvm/, .nvm/, .opam/なんかもコピーしない&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;コピーが終わったら&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Emacsをビルドして起動、動作確認&lt;/li&gt;
&lt;li&gt;Thunderbirdをインストール、動作確認&lt;/li&gt;
&lt;li&gt;gitをインストール、githubとの接続確認&lt;/li&gt;
&lt;li&gt;CIMをインストール、&lt;code&gt;cim install sbcl&lt;/code&gt;の動作確認&lt;/li&gt;
&lt;li&gt;rustをビルドするときは&lt;code&gt;./configure&lt;/code&gt;から始める&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;いつかやる&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;tarballにコピーするファイルを詰め込んどく

&lt;ul&gt;
&lt;li&gt;理想的にはメインのHDDとは別の記憶媒体にtarballを保存&lt;/li&gt;
&lt;li&gt;定期実行が面倒になるくらいなら~/.backupにでも。気が向いた時に別の媒体にコピー&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;どうもappendオプションを使えばヒストリ付きのアーカイバとして使えるらしい&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>新年の挨拶及び内部実装変更のお知らせ</title>
      <link>/blog/2015/01/01/new-year-greeting</link>
      <pubDate>Thu, 01 Jan 2015 06:44:31 UTC</pubDate>
      
      <guid>/blog/2015/01/01/new-year-greeting</guid>
      <description>&lt;p&gt;新年明けましておめでとう御座います。κeenです。私から一つお知らせが御座います。&lt;/p&gt;

&lt;p&gt;私、本名を金舜琳といいますが今年から日本に帰化して志村舜琳と名乗ります。アルファベット表記もSunrim KIMからSunrin SHIMURAに変更致します。Sunrinも微妙に変化します。
尚、外部インターフェースのκeenは変らず、内部のみの変更になるので多くの方には影響は無いかと思います。
さらに正式に日本国籍を取得するまでは本名の金舜琳と通称名の志村舜琳両方で呼び出せるのでこの期間に移行下さい。&lt;/p&gt;

&lt;p&gt;さて、帰化の理由についてですが、主に外国人参政権に関連します。昔は私も外国人に参政権を渡せと叫んでおりましたが最近考え方が変わりました。権利が欲いなら国籍とればくれてやる、国籍を取る事は認める。それで良いと思います。韓国の権利よりも日本の権利が欲い、なら日本国籍を取る。筋は通っていると思います。書類上の変更で血筋が変わる訳でもありませんし。父親の世代は在日韓国人というだけで日本の社会から拒絶され、帰化＝屈服だったそうで今でも帰化には否定的なようですが特に反対はありませんでした。私と同世代の姉は、もっと歴史を勉強して納得してから決めると言っています。価値感はそれぞれでしょう。&lt;/p&gt;

&lt;p&gt;それでは皆様、今年も一年κeenこと志村舜琳を宜くお願い致します。&lt;/p&gt;

&lt;p&gt;P.S.&lt;br /&gt;
志村舜琳ってDQNネームっぽくて嫌だなぁ。下の名前も変えようかなぁ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OctopressからHugoに移行した</title>
      <link>/blog/2014/12/30/migration-from-octopress-to-hugo</link>
      <pubDate>Tue, 30 Dec 2014 03:26:58 UTC</pubDate>
      
      <guid>/blog/2014/12/30/migration-from-octopress-to-hugo</guid>
      <description>

&lt;p&gt;κeenです。年末ですね。&lt;a href=&#34;http://deeeet.com/writing/2014/12/25/hugo/&#34;&gt;こちらのブログ&lt;/a&gt;にもあるようにOctopressの生成の遅さに閉口してたのでHugoに移行しました。
出来るだけブログのURLは変えないようにしました。でもどっかでリンク切れちゃってるかも。&lt;/p&gt;

&lt;p&gt;Octopressは遲い以外にもテンプレートのファイルが多い、Rubyのインストールと&lt;code&gt;bundle install&lt;/code&gt;が必要、柔軟性がない、など不満があったのですがバイナリ配布のHugoは~/binに置くだけで良いですしテーマが気に入らなければユーザーがオーバーライドする仕組みもあるので好きにいじれます。まあ、結局テーマをフォークしちゃったんですけどね。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;作業&lt;/h1&gt;

&lt;p&gt;Markdownとメタデータは概ね互換性があるのでcontent/post/に突っ込んで先のブログのワンライナーを回せばとりあえず動きます。URL互換性を保つために&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd content/post
for f in *.markdown; do mv ${f} $(basename ${f#*-*-*-} .markdown).md;done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなのを回します。ヒストリ搜すの面倒なので今即興で書きました。&lt;/p&gt;

&lt;p&gt;んで記事にカテゴリのタグが欲いのと日付をISOっぽくしたかったのでテンプレートをオーバーライド。あ、テンプレートは&lt;a href=&#34;https://github.com/eliasson/liquorice/&#34;&gt;liquorice&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;シンタックスハイライト&lt;/h1&gt;

&lt;p&gt;Hugoはデフォルトでは提供しません。サーバーサイドでやろうとするとpygmentsが遲いから。クライアントサイドだと複数あるらしいので&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;にしてみました。Clojure REPLとか絶妙なものがあって良いですね。個人的にはコマンドラインのハイライトが欲かった…&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;スライド&lt;/h1&gt;

&lt;p&gt;Octopressの時はテーマに手を入れるわreveal.jsのテーマは自作するわちょっと表には出せないアドホックでダーティーなプラグインを作るわしてreveal.jsに無理やりブログのテーマを載せてました。&lt;/p&gt;

&lt;p&gt;今回はHugoテーマをフォークしてslide用のテンプレート書いて、Octopressの時に使っていたreveal.jsの自作テーマを少しいじるだけで済みました。しかもブロクにreveal.jsを埋め込む形になってます。この際&lt;a href=&#34;http://remarkjs.com/&#34;&gt;remark.js&lt;/a&gt;にしようかとも思ったのですがまたスライドのテーマ作るの面倒だったのでreveal.jsのままで。remark.jsだったら苦労せずとも導入出来たのかなぁ。&lt;/p&gt;

&lt;p&gt;一番の問題はreveal.jsにはmarkdownを食わせるのですが、Hugoがmarkdownをレンダリングしちゃうところですね。Octopressではプラグインで先にスライドだけ処理しちゃってOctopressには触らせないことで実現してました。&lt;/p&gt;

&lt;p&gt;Hugoはgoのテンプレートを使っているのですがこれまた癖があって文脈に応じてそのまま出したりレンダリングしたりHTMLエスケープしたりJSエスケープしたりします。試行錯誤する内に &lt;em&gt;markdown 全体を&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;で囲むとレンダリングされない&lt;/em&gt; というバグっぽい挙動を見付けました。というこで汚ないんですがスライドは各記事を手動で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;section data-markdown
    data-separator=&amp;quot;\n\n&amp;quot;
    data-vertical=&amp;quot;\n\n&amp;quot;
    data-notes=&amp;quot;^Note:&amp;quot;&amp;gt;
&amp;lt;script type=&amp;quot;text/template&amp;quot;&amp;gt;


&amp;lt;/script&amp;gt;
&amp;lt;/section&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で囲むことにしました。&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;雑感&lt;/h1&gt;

&lt;p&gt;速いし導入楽だしもうOctopressに戻りたいとは思わないです。あとauto refleshが便利すぎる。変更したらビルドしてブラウザのリロードまでやってくれます。デュアルディスプレイだと捗りそうですね。&lt;/p&gt;

&lt;p&gt;不満はウィジェットが少ない、コマンド１発でデプロイ出来無い、octomacsが使えない。ソーシャルアイコン気に入ってたのに。&lt;/p&gt;

&lt;p&gt;あと折角なのでブログエントリ全体見返して細かな修正行いました。カテゴリの統一とか。&lt;/p&gt;

&lt;p&gt;これで今年の大掃除終わり！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FreeBSDに移行した</title>
      <link>/blog/2014/12/27/freebsd</link>
      <pubDate>Sat, 27 Dec 2014 00:00:00 UTC</pubDate>
      
      <guid>/blog/2014/12/27/freebsd</guid>
      <description>

&lt;p&gt;κeenです。Ubuntuのaptが古いのが我慢ならなくなってきたのでFreeBSDに移行しました。pkgのsbclが1.2.6ですよ！&lt;/p&gt;

&lt;p&gt;最初は踏ん切りがつかなかったのでメインの500GBのHDDではなく、ジャンクで買った128Gのものにインストール。様々な問題に当ったものの、どうにか使えてます。今はHDD換装してメインになってます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;問題の半分はKDEを導入したら直った（最初はCinnamon入れようとした。UbuntuではUnity使ってた）&lt;/li&gt;
&lt;li&gt;２日くらいはつぶす覚悟&lt;/li&gt;
&lt;li&gt;Xorgの設定を手で畫くことになるとは&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;良いところ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;速い気がする。ufsのお陰？（HDDの問題？）&lt;/li&gt;
&lt;li&gt;Firefoxが全然CPU食わなくなった（プラグインの問題？）&lt;/li&gt;
&lt;li&gt;pkg使い易い！&lt;/li&gt;
&lt;li&gt;Ubuntuで使ってたソフトウェア大体動く&lt;/li&gt;
&lt;li&gt;portsもある！！&lt;/li&gt;
&lt;li&gt;Dtraceとかjailとか便利そうじゃね？&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;問題&lt;/h1&gt;

&lt;p&gt;たいてい解決or妥協してるのですが、どうにもならない点がいくつか&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;skkservがセグフォる。multiskkserv使えない。今は辞書直読みで対応してる。&lt;/li&gt;
&lt;li&gt;Wifiのデバドラがない。今はUSBのアダプタ使ってる（そっちのドライバはある）&lt;/li&gt;
&lt;li&gt;sleepすると復帰したときにディスプレイが点かない&lt;/li&gt;
&lt;li&gt;メインのHDDにデュアルブートでバックポート出来無かった&lt;/li&gt;
&lt;li&gt;日本語キーボードのモディファイアキーを認識しない: のたうち回ってpolykitの設定とかsysctlとか書いてる内に直った。でもen配列だと無理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特に3番が痛い。&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;解決/妥協した問題&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;インプットメソッド、ログインマネージャ、タイムゾーン: KDEを導入したら直った&lt;/li&gt;
&lt;li&gt;データの移行: fusefs_ext4でUbuntuのHDDマウントしてコピー、権限変更、&lt;code&gt;chmod u+w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;フォント: &lt;code&gt;sudo pkg install $(pkg search ja-font)&lt;/code&gt;の力技。あとはXorgの設定書いてKDEとFirefoxで好みのフォントを選んだ&lt;/li&gt;
&lt;li&gt;キーボードdvorakにしてるのにqwertyになる: qwertyで妥協。やりたければ&lt;code&gt;sekxkbd&lt;/code&gt;とかあるし&lt;/li&gt;
&lt;li&gt;ロケールが日本語になんなくてFirefoxとかが全部英語: ま、いっか&lt;/li&gt;
&lt;li&gt;タッチパッドでスクロールが出来無い: Xorgの設定書いた。ドライバもなんか設定書いた気がする&lt;/li&gt;
&lt;li&gt;kvmが使えない: むしろBHyVeを試してみるチャンス！開発中のVMMを提供してくれたFreeBSDに圧倒的感謝！！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;デバドラとかハードウェア周りがつらい。ソフトウェアは統合デスクトップ環境が吸収してくれますね。&lt;/p&gt;

&lt;p&gt;EmacsとFirefoxとThunderbirdが動くので今のところ問題ないですね。今後また問題が出て来るかも。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>独学のプログラミング</title>
      <link>/blog/2014/12/18/du-xue-falsepuroguramingu</link>
      <pubDate>Thu, 18 Dec 2014 23:51:27 UTC</pubDate>
      
      <guid>/blog/2014/12/18/du-xue-falsepuroguramingu</guid>
      <description>&lt;p&gt;誰向けなのか分からない。多分5年後くらの初心を忘れた自分が読めば良いと思う。あるいは、独学でプログラミングを始めようとしてる人が参考にするのかもしれない。&lt;/p&gt;

&lt;p&gt;私はプログラミングを独学で学んだ。&lt;/p&gt;

&lt;p&gt;初めて触ったのは中学生のとき、ネットゲームのギルドのホームページを作ろうとなってHTML、CSS、JavaScriptという存在を知った。&lt;a href=&#34;http://www.red.oit-net.jp/tatsuya/java/&#34;&gt;イヌでもわかるJavaScript講座&lt;/a&gt;を見てメモ帳で書いた20行くらいのスクリプトが当時の最高傑作だった。&lt;/p&gt;

&lt;p&gt;それから名前の訊いたことのあったC言語を学ぼうとしたが、Vijuaru Stajioのインストールが出来なくて挫折した。CとC++とC#の違いも分ってなかった。&lt;/p&gt;

&lt;p&gt;その後、ネットゲームもしなくなり高校の間は全くプログラミングに触れずに大学に入った。&lt;/p&gt;

&lt;p&gt;1年夏学期の情報の授業でシェルを知った。最初は慣れなかったが次第に使えるようになって、家でもコマンドプロンプトを使うようになった。冬学期の情報科学でrubyを知った。あくまで情報科学であってプログラミングの授業ではなかったが、rubyに興味を持った。&lt;a href=&#34;http://www.rubylife.jp/ini/&#34;&gt;Ruby入門&lt;/a&gt;を見ながら覚えた。メソッド、クラス、オブジェクト指向…。カタカナ語が多くて中々頭に入らなかった。&lt;/p&gt;

&lt;p&gt;一つ、ターニングポイントになったと思うのは&lt;a href=&#34;http://www.amazon.co.jp/Ruby%E9%80%86%E5%BC%95%E3%81%8D%E3%83%8F%E3%83%B3%E3%83%89%E3%83%96%E3%83%83%E3%82%AF-%E3%82%8B%E3%81%B3%E3%81%8D%E3%81%A1/dp/4863540221&#34;&gt;Ruby逆引きハンドブック&lt;/a&gt;を買った時だと思う。どんな本かも分からずに買った。そして最初から最後まで読んだ。これで一通りプログラミング言語で何が出来るのか分かった気がする。手札の確認というか。逆引きを買ったのが1年生の冬学期の終わりだったかな？そしてバッチファイルで書いていた処理をrubyで置き換えたりしていた。&lt;/p&gt;

&lt;p&gt;その頃にはラップトップにCygwinが入っていた気がする。そしてEmacsをCygwin内で使っていた。いや、怪しいな。Cygwinのbinにパスを通してコマンドプロンプトからEmacsを使っていたかもしれない。&lt;/p&gt;

&lt;p&gt;春休みにプログラミングのバイトに応募してみた。それまでは個別指導をしていたが、兄弟会社でバイトを募集していると告知されたからだ。プログラミング試験はrubyで書いて恐る恐る提出すると合格だった。面談の結果Androidチームに入った。Javaは一行も書けない。最初のミーティングまでにJavaを覚えようとしたが間に合わなかった。戦々恐々と出社したが、仕事がみんなに降ってきて、自分の出来そうな仕事をして相応の報酬を貰う制度だったのでとりあえずのところ書けなくても困らなかった。&lt;/p&gt;

&lt;p&gt;2年生の夏学期。JavaとAndroidとEmacsを勉強していた。PC系サークルにも入った。確かこの頃Ubuntuを使い始めた。バイトはまだ一度もアサインされたことはなかったがどんな仕事はどんな人が持っていくのかはなんとなく分かってきた。Emacsの設定を触るうちにLispに興味を持ったのもこの辺じゃなかったかな。&lt;/p&gt;

&lt;p&gt;2年生の夏休み。合宿と強化練に忙殺されていたがバイトのタスクアサインに初めて手を挙げた気がする。君にはこの仕事はまだ早いと言われ、貰えなかった。もう一つ、ここで進路の決断を迫られた。大学に入ったときは数学科に行くつもりだったが情報系も検討した。最後まで悩んだ挙句数学科を選んだ。今思えば大失敗だったが後悔先に立たず。&lt;/p&gt;

&lt;p&gt;2年生の冬学期。学科の周りの人を見て絶望した。レベルが違い過ぎる。高校の数学が少し得意程度の人が来るべきところではなかった。数学者になる夢はここで潰えた。この時期は授業が少ないので我武者羅にプログラミング関係の情報を集めた。この頃にはRuby、Common Lisp、Javaが使えた筈。でもJavaが嫌いでAndroidアプリをJava以外で書く方法を捜してた。JRubyとRubotを試したけど遅すぎてダメだった。Clojure、Scala、Haskell、OCamlなどの名前もこの辺で知った。Clojureは少し触ってみた気がする。バイトで初めてのタスクアサインを受けたのもこの頃。プログラムを書く仕事ではなくテスターだったが。&lt;/p&gt;

&lt;p&gt;これ以降、順調に学んでいった。QtRubyで胃に穴が空きそうになったり、どうしてもCommon Lispが気になって6月にShibuya.lispに初めて参加したり。&lt;/p&gt;

&lt;p&gt;2つ目のターニングポイントはISUCONだった。ISUCONの案内はPC系サークルのOBから来た。学生枠を設けるから講習会を開くとの案内。その頃は腕に覚えがあったのでバリバリスコア伸ばすつもりで夏期講習に参加した。コテンパンにやられた。手も足も出なかった。Webアプリケーションがどんなものかは分かっているつもりだったがSQLも知らないしNginXの設定も3時間くらい格闘して結局出来なかった。悔しいので予選でリベンジしようと思った。懇親会に出ると同じような人が何人かいて、チームを組むことになった。予選でも手も足も出なかった。私がNginXの担当になったがチューニング方法も全く分からなかった。神風が吹いて上位の学生チームがFailして本戦に出場することになった。流石に本戦で恥かしい思いはしまいと&lt;a href=&#34;http://isucon.net/archives/32976287.html&#34;&gt;公式ブログの解答例&lt;/a&gt;を二人で復習した。NginX、SQL、Capistranoなどの知識を得た。そして本戦。善戦した。他の学生チームが全てFailするというまさかのオチで学生賞をとった。&lt;/p&gt;

&lt;p&gt;ISUCONで学生賞を取ったのとISUCON関係でフォローした人の影響でOpsの方にも興味を持った。&lt;/p&gt;

&lt;p&gt;そういえばこの頃、睡眠時間を気にせずIT系の情報を漁っていたら体調を酷く崩してバイトを辞めた。&lt;/p&gt;

&lt;p&gt;思い出せばこの頃に色々と変わった。変わったというか壁を破ったというか。それまでコンスタントに参加していたShibuya.lispのLisp Meet Upで初めてLTをした。初めてのまともなOSSであるCIMを作った。プロコンに参加してみた。&lt;/p&gt;

&lt;p&gt;そしてそれから1年、勉強会で喋ってGithubで活動してISUCONに出て若干コンピュータサイエンスに興味を持った今の私になった。4年生では数学科らしからずパタヘネとMINIX本を講究でやっている。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これで大体合ってる筈なんだが書きたかったのはこういう事じゃなかった気がする。何がきっかけで殻を破ったか、どうやって独学で身につけたか。時系列は無視して書き連ねていく。&lt;/p&gt;

&lt;p&gt;上でも書いたように逆引きRubyが1つのターニングポイントだった。でも、どうしても書きたいものがあまりなくてソースコードを読んだ。WEBRicks。その頃はまだHTTPサーバーの仕組みを分かってなかったから理解出来なかったけど雰囲気は分かった。それとrush。今では死んだプロジェクトだけどrubyで書かれたシェルに夢を抱いてソースを読んだ。&lt;/p&gt;

&lt;p&gt;最初の頃は何でもググってた気がする。英語はスルーしてた。Common Lispを始めた時にはマイナー言語の宿命で英語は避けて通れなかったので肚を括った。しかしドキュメントも無いプロジェクトも多数あって、結局ソースをかなり読んだ。&lt;/p&gt;

&lt;p&gt;WEB上の情報も頼りにしてたが、やっぱり書籍が便利だった。ディスプレイが1つしか無いからブラウザとEmacsを行き来するのが面倒だったというのもあるかもしれない。今数えると50数冊持っていた。図書館で借りて読んだ本もあるから読んだ本だともうちょっと。&lt;/p&gt;

&lt;p&gt;上には出てこなかったがFreeBSDをKVM上で動かしている。FreeBSDを触り始めた時にはマニュアルを頼りにしろ、と書いてあった。成程、便利だ。それ以来ググるより先に公式ドキュメントやmanページを先に引くようになった。特にmanを引けるようになったのは大きかった気がする。&lt;/p&gt;

&lt;p&gt;「Lisperは一度はLisp処理系を書く」と言われて言語処理系に興味を持った。Rubyやmrubyのコードを読んで図書館でそれっぽい本（後にドラゴンブックと分かる）を手にとった。就活でプログラミング課題が出たときにJavaを書きたくなくてLispを実装してLispで解いた。初めてのLisp処理系だった。それからpicrinを見かけてpicrinにコミットし始めた。言語処理系が中で何をやっているか、そして一番GCなどのメモリ管理について理解が深まったのは大きかったと思う。&lt;/p&gt;

&lt;p&gt;低レベルの世界はパタヘネが導いてくれた。picrinにコミットし始めてCをゴリゴリ書いたのもある。高速なコードを書こうと思った時にアセンブラやCを知っていると全然違った。どうすれば速くてどこが遅くなる原因なのか。勿論、ドラゴンブックで最適化も学んだのでどの程度は処理系がやってくれるのかも少しは分っていた。&lt;/p&gt;

&lt;p&gt;デバッガはpicrinを開発してるときに覚えた。WEBにいくらでも資料がある。実はそれまではずっとprintfデバッグしかしたことがなかった。それからCommon Lispでも少し使うようになった。他の言語はまだ使っていない。&lt;/p&gt;

&lt;p&gt;理論の世界はOCamlとプロコンが入口だった。プロコンは賞金が出るらしいときいてリクルートプロコンに出た。4/10問解けてそれなりに満足して、少し興味を持った。chokudaiさんの講座を受けたり蟻本を買ったりして学んだ。Common Lispで実装しようとしてたらアルゴリズムイントロダクションを勧められた。図書館で借りた本だったので逃げてしまったが道具箱のカタログには入った。
OCamlは、「数学科の主な就職先は金融」「金融では主にOCamlが使われている」と訊いて始めた。OCaml界隈を追ってると、型だとかTaPLだとかCoqだとかが聴こえてきた（主に名古屋の方面から）。少し齧った。そこから関数型言語の世界に入った。HaskellもRWHをざっと読んでモナドを知り、SML#からSMLに入って、SMLも追ってみた。主に研究に使われているらしく、面白い機能を持った処理系がいっぱいあった。型安全pickling、リージョン推論、モジュールのコンパイル時畳み込み…。だいたい論文にリンクが貼ってあって、そこから論文を読むことを覚えた。&lt;/p&gt;

&lt;p&gt;バージョン管理システムは.emacsの管理をsvnで始めたのが最初だった。バイト先が最初svnだったから。DropBoxにsvnサーバを置いてちまちま使っていた。init.elだけはRCSで管理してた時期もあった気がする。バイト先がgitになってから手元もgitに以降した。gitbreakに.emacsを置いた。この時点ではまだGithuはソース読もうと思ったら良く出てくるダウンロードUIが最悪なサイトだった。しかししょっちゅう出てくるので義務感に刈られてアカウントを作った。Shibuya.lispでLTするにあたり、サンプルコードを置くのに初めてpushした。いや、Octopressのブログが先だったか？いずれにせよ3年生の9月あたりからコミットを始めた。gitは経験とWEBで覚えた。今は&lt;code&gt;git help&lt;/code&gt;を参照している。&lt;/p&gt;

&lt;p&gt;OSについてはLinuxディストリを試して回ったときに学んだ。最初はUSBに焼くことしか知らず、同じUSBに何度も色々なディストリを焼いた。Ubuntuの次はArch、Gentoo、FreeBSD、 OpenSUSE。Gentooはブートローダやパーティションについて知る良い機会だった。PCを何度も再起動するのが耐えられなくて回避策を捜したらKVMが出てきた。三つ子の魂なんとやら、今でもコマンドラインから&lt;code&gt;kvm&lt;/code&gt;コマンドで仮想マシンを起動している。そして今はMINIX本でもうちょっと詳しくOSについて学んでいる。&lt;/p&gt;

&lt;p&gt;AIはLispをやってると自然と行きつく。WEBを参考にしながらオセロのAIを作った。そのとき初めてSchemeを触った。なんでSchemeを選んだのかは覚えてない。SICPの影響だったかPC系サークルで部誌を書くにあたりSchemeのチュートリアルがあってそれに乗っかって選んだのか。ほぼGaucheのマニュアルだけでやりきった。魔法のように見えたAIが人工無能であることを理解した。探索、MiniMax、αβ法なんかも理解した。将棋のAI、碁のAIの本も買った。そこで機械学習を知った。&lt;/p&gt;

&lt;p&gt;データ解析はビッグデータの流れから本を捜して学んだ。R。正直そんなに身に入ってないが心には留めている。&lt;/p&gt;

&lt;p&gt;機械学習はAIの流れとデータ解析の流れの合流地点だった。WEB、データ解析の本、AIの本などで断片的に知識を仕入れた。これもあまり身に入ってないがディープラーニングや画像処理の話題についていける程度にはなった。&lt;/p&gt;

&lt;p&gt;画像処理はAIの流れだった。五目並べに似たConnect 6というドマイナーなゲームのAIを作ろうとした。棋譜を打ち込むのが面倒だから画像処理でやろうとした。結局処理は出来なかったけど画像処理が裏で何をやっているのか、OpenCVで何が出来るのか、機械学習がどう使われるのかなどが分かった。公式マニュアルとWEBとオライリーのOpenCVも図書館で借りた気がする。道具箱に入った。&lt;/p&gt;

&lt;p&gt;ネットワークは自宅サーバを立てようとしてルータをいじった時に少し覚えた。WEBで情報を得た。OSをインストールするときにも最初に設定が必要になる。正直まだまだ知識が足りてない。TCP/IPの本を流し読みしたけど覚え切れなかった。&lt;/p&gt;

&lt;p&gt;UnicodeやエンコードはpicrinをUnicode対応させようとしたときに調べた。WEBだとどうしても表面しか書いてない記事が多くて欲しい情報を探しきれなかったので本を買った。&lt;/p&gt;

&lt;p&gt;上に書いたことだと、勉強会はShibuya.lispが暖かく受け入れてくれたことから始まった。怖がらないことが大事。そしてLTを録画してくれるので見直して喋り方やスライドも改善した。&lt;/p&gt;

&lt;p&gt;OpsはISUCONがきっかけだった。Twitterで流れてくる情報を追った。運用に興味を持った。でも、自分で運用しているサービスなんてない。サーバもない。多分だから早くエンジニアになりたいと思ってるんだと思う。&lt;/p&gt;

&lt;p&gt;データベースもISUCONがきっかけだった。SQLも然り。そこからNoSQLに行って7つのDB7つの世界を読んだ。道具箱のカタログの中身が増えた。データベースの実装が気になって少しRDBを作ってみた。トランザクションとかバックアップとかクラスタリングとかはまだどう実装するのか理解していない。&lt;/p&gt;

&lt;p&gt;Linuxプログラミングは自然に覚えた。シェルが内側で何をやっているか、高速なWEBサーバの背後にあるのは何か。データベースを効率的に実装するには何が必要か。picrinに機能を追加する時に最終的に何を使うのか。&lt;/p&gt;

&lt;p&gt;ここで上に書いたものを改めて見てみる。何が必要で何が必要でないか分からない。全然足りない気がする。CPU作ったこともコンパイラ書いたこともデバイスドライバ書いたこともない。同年代の情報系の人は何を学んでいるのか。情報科学科と情報工学科でどれくらいの違いがあるのか。エンジニアに必要なスキルは何なのか。やっぱり見えない敵と戦っている。&lt;/p&gt;

&lt;p&gt;文系からエンジニアになったという人を見掛けた。見てると、大学に入り直して情報科学を体系的に学びたいと言っていた。彼女も多分見えない敵と戦ってるんだと思う。&lt;/p&gt;

&lt;p&gt;何だろう。大学を出るまであと3~4ヶ月。あと何を勉強しておけば良いのかな。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>サイエンスかエンジニアリングか</title>
      <link>/blog/2014/12/18/saiensugaenziniaringu</link>
      <pubDate>Thu, 18 Dec 2014 23:03:41 UTC</pubDate>
      
      <guid>/blog/2014/12/18/saiensugaenziniaringu</guid>
      <description>&lt;p&gt;最近、エンジニアリングかサイエンスかという分類を教えてもらった。それが出てきたのはGoがエンジニアリングから出た言語だと言われた時だった。&lt;/p&gt;

&lt;p&gt;その時私はRustを推していたのでRustはサイエンスから出た言語だと言った。&lt;/p&gt;

&lt;p&gt;Goが出た時は「コンパイルの速いシステム記述言語」という触れ込みだった気がする。C++のコンパイルが遅いからGoを作った、ならエンジニアリングから出た言語と言える。
Rustは触れ込みがあった気はしないが代数的データ型やトレイト、リージョン推論（ライフタイム）などサイエンスの成果を反映している。サイエンスから出た言語と言って良いと思う。&lt;/p&gt;

&lt;p&gt;サイエンスとエンジニアリング。この言葉を知ってから随分ともやもやを説明出来るようになった。&lt;/p&gt;

&lt;p&gt;先のGoとRustの話に関連して。Goがここ15年のプログラミング言語の歴史を無視しているだとか、平ぺったい言語だとか言われるのを良く聞く。Goがサイエンスの成果をあまり取り入れなかったからだろう。
折しも関数型言語が流行っている今、サイエンス寄りになったエンジニアには物足りないのだと思う。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;私が競技プログラミングをあまり好きになれない（※個人の感想です）のはあれがサイエンスの一部分を競技化したものだからだ、と説明出来る。何故かというと私が興味があるのはエンジニアリングだから。エンジニアの募集に競プロを使うのは違う気がしていたのもそこなんだな、と気付いた。プログラムの書けないプログラマがどの程度いるのか知らないけど少しずれてる気がする。&lt;/p&gt;

&lt;p&gt;まあ、競プロが好きになれないのは他にも&amp;rdquo;コード&amp;rdquo;という広い意味の単語を競技プログラミングの意味で使ってるだとか私の好きな言語が使えないだとか勝てないだとかの理由もあるのだが。一応、補足しておくと私も競プロは競技としては楽しむ。&lt;/p&gt;

&lt;p&gt;逆に、以前後輩にISUCONのことを説明したらサイエンスの大会と理解されたようだった。違う。あれはエンジニアリングの大会だ。多くのエンジニアが腕を競う。実際にやってみないとエンジニアリングで何十倍も高速化するというのが理解出来ないかったのだろう。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;偶に院進を勧められることがある。理学部に居るし、普通なら院進する。特に父親は心配していた。その時は「なんとなく違う」と返していたが今ではちゃんと説明出来る。私がやりたいのはエンジニアリングだ。実際に手を動かさないと出来ない経験をしたい。エンジニアリングのためのサイエンスをやることはあるがサイエンスのためのサイエンスはしない。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>実用Common Lispを読んだ</title>
      <link>/blog/2014/12/14/shi-yong-common-lispwodu-nda</link>
      <pubDate>Sun, 14 Dec 2014 00:00:00 UTC</pubDate>
      
      <guid>/blog/2014/12/14/shi-yong-common-lispwodu-nda</guid>
      <description>&lt;p&gt;以前&lt;a href=&#34;/blog/2014/10/20/lisp-ja/&#34;&gt;Common Lispの勉強の手引の記事&lt;/a&gt;を書いたときに実用Common Lispの名を挙げたが読んだことはなかった。&lt;/p&gt;

&lt;p&gt;一応名前を挙げた責任として読んでみた。&lt;/p&gt;

&lt;p&gt;読んだとは言ってもソースはざっくりしか見てないし、演習には目もくれてないので「一通り目を通した」程度。
買った本は逃げないのだし一回で理解する必要はない。最初に一通り内容を掴んで主張を理解してから、あとで気になった時につぶさに読むのが私の読み方。&lt;/p&gt;

&lt;p&gt;最初の感想を言うと、古い。Common Lispもcltl2とANSI両方に配慮されて書かれているし、紹介されているAIの事例も1970~1980年代のもの。
古典といった感じ。ただし、その時代はCommon LispとAIの最盛期なのでこの本を読めばCommon LispがAIで名を馳せた理由が良く分かる。&lt;/p&gt;

&lt;p&gt;Common Lispの内容は初級程度。まえがきにもあるようにプログラマとしては中級だがLispは初心者レベルの人向に書かれている。基本的なところを押えたらあとはどんどん進んでいく。
プログラミングの経験があればそれでも問題ない筈。心配ならWeb上にいくらでもあるチュートリアルをこなせば良い。&lt;/p&gt;

&lt;p&gt;ライブラリなどに関しては本の中で完結しているので良く言えば1から10まで教えてくれる。悪く言えば最近のCommon Lispの動向は全く分からない。その意味では実践入門ではなく学習図書。陳腐化はしない。&lt;/p&gt;

&lt;p&gt;AIについては、やはり古い。今では手法が確立されてAIの分野とは扱われないものも含まれている。ただし、これは意図したものなのかもしれない。
古いものというのは単純だ。最初に2部で単純なものを通して「肩馴らし」をしてから3部で手駒を増やして4部で踏み込んだ内容に入る。&lt;/p&gt;

&lt;p&gt;また、AIの分野としては扱われていなものも含む、ということはこの本が情報科学の広い範囲をカバーする、ということでもある。900ベージは伊達じゃない。量もあればバラエティもある。&lt;/p&gt;

&lt;p&gt;現実にある様々な難解な問題をCommon Lispという強力な道具で快刀乱麻解決していく。ソフトウェア開発手法を学びながらCommon Lispの強力さを思い知るための一冊。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mllexを使ってみる。あるいはlexユーザーに対するmllexの解説</title>
      <link>/blog/2014/12/10/mllexwoshi-tutemiru</link>
      <pubDate>Wed, 10 Dec 2014 00:00:00 UTC</pubDate>
      
      <guid>/blog/2014/12/10/mllexwoshi-tutemiru</guid>
      <description>

&lt;p&gt;このエントリーは&lt;a href=&#34;http://qiita.com/advent-calendar/2014/ml&#34;&gt;ML Advent Calendar 10日目&lt;/a&gt;の記事です。&lt;br /&gt;
前 &lt;a href=&#34;http://h-sakurai.hatenablog.com/entry/2014/12/09/144655&#34;&gt;OCamlで作ったgoma言語 - h_sakurai&amp;rsquo;s diary&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ふと思い立ってPrologのコンパイラかインタプリタかを作ってみようとして、その第一段でlexerに着手しました。&lt;/p&gt;

&lt;p&gt;ちょ、SML分かる人はmllexくらい常識的に知ってるなんて言わないで下さい。私は初めて触りました。&lt;/p&gt;

&lt;p&gt;ちょっと変則的なんですが、smlsharpの配布物にあるドキュメントを読みながらmlton付属のmllexを使い、sml/nj上で動作を確認しました。SMLの処理系管理ガバガバですね。&lt;/p&gt;

&lt;p&gt;まあ、初めて使ってみたとは言ってもほぼC版のlexのCを書く部分をそのままSMLで書けば良いだけなので簡単ですね。&lt;/p&gt;

&lt;p&gt;因みにPrologの文法は以下のようなもの。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;%reverse a list into X
reverse([], []).

reverse([Hd|Tl], X):-
    reverse(Tl, Y),
    append(Y, [Hd], X).

reverse(List, X):-
    reverse(List, []).

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;だいたいの部分は見れば分かるかと思うのですが、小文字で始まるのがリテラル（文字列？識別子？）で大文字から始まるのが変数です。&lt;/p&gt;

&lt;p&gt;で、これをイメージしながらlexファイルを書いていきます。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Lexファイル&lt;/h1&gt;

&lt;p&gt;全体はこのようになっています。lexと同じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SMLの補助コード部分

%%

補助ルールの記述

%%

解析ルールの記述

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SMLの補助コードの部分は典型的には&lt;code&gt;datatype&lt;/code&gt;を書きます。あとはどうも&lt;code&gt;error : string -&amp;gt; unit&lt;/code&gt;と &lt;code&gt;eof : unit -&amp;gt; &#39;a&lt;/code&gt;が必要みたいですね（マニュアルちゃんと読んでない）。&lt;code&gt;&#39;a&lt;/code&gt;というのは他の解析ルールと同じ型です。&lt;/p&gt;

&lt;p&gt;補助ルールはlexとだいたい同じです。生成した関数やらデータ型を収めるstructureの指定とかもします。&lt;/p&gt;

&lt;p&gt;解析ルールもだいたいlexと同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pattern =&amp;gt; (SMLのコード);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような形をしてます。&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;実際のコード&lt;/h1&gt;

&lt;p&gt;結構適当です。あ、カットのこと忘れてた。ほら、適当だった。&lt;/p&gt;

&lt;p&gt;このコードをprolog.lexとして保存します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype lexresult =
         Comment of string
       | LeftParen
       | RightParen
       | LeftBracket
       | RightBracket
       | Comma
       | Dot
       | Bar
       | Medaka
       | UnderScore
       | String of string
       | Number of int
       | Variable of string
       | EOF

val linenum = ref 1
val error = fn x =&amp;gt; print (x ^ &amp;quot;\n&amp;quot;)
val eof = fn () =&amp;gt; EOF
%%
%structure PrologLex                      

alphanum = [A-Za-z0-9];
alpha    = [A-Za-z];
digit    = [0-9];
ws       = [\ \t\n];

%%

{ws}+            =&amp;gt; (lex());
%(.*)\n          =&amp;gt; (Comment yytext);
&amp;quot;(&amp;quot;              =&amp;gt; (LeftParen);
&amp;quot;)&amp;quot;              =&amp;gt; (RightParen);
&amp;quot;[&amp;quot;              =&amp;gt; (LeftBracket);
&amp;quot;]&amp;quot;              =&amp;gt; (RightBracket);
&amp;quot;,&amp;quot;              =&amp;gt; (Comma);
&amp;quot;.&amp;quot;              =&amp;gt; (Dot);
&amp;quot;|&amp;quot;              =&amp;gt; (Bar);
&amp;quot;:-&amp;quot;             =&amp;gt; (Medaka);
&amp;quot;_&amp;quot;              =&amp;gt; (UnderScore);
[a-z]{alphanum}* =&amp;gt; (String yytext);
{digit}+         =&amp;gt; (Number (foldl (fn(a, r)=&amp;gt; (ord(a)-ord(#&amp;quot;0&amp;quot;)) + 10*r) 0 (explode yytext)));
[A-Z]{alphanum}* =&amp;gt; (Variable yytext);
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;実際に使ってみる。&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ mllex prolog.lex

Number of states = 19
Number of distinct rows = 8
Approx. memory size of trans. table = 1032 bytes
$ rlwrap sml
Standard ML of New Jersey v110.77 [built: Thu Sep  4 12:32:33 2014]
- use &amp;quot;prolog.lex.sml&amp;quot;;
[opening prolog.lex.sml]
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[autoloading done]
structure PrologLex :
  sig
    structure UserDeclarations : &amp;lt;sig&amp;gt;
    exception LexError
    structure Internal : &amp;lt;sig&amp;gt;
    structure YYPosInt : &amp;lt;sig&amp;gt;
    val makeLexer : (int -&amp;gt; string) -&amp;gt; unit -&amp;gt; Internal.result
  end
val it = () : unit
- val lexer = PrologLex.makeLexer (fn i =&amp;gt; TextIO.inputN(TextIO.openIn &amp;quot;reverse.pl&amp;quot;, i));
val lexer = fn : unit -&amp;gt; PrologLex.Internal.result
- lexer();
val it = Comment &amp;quot;%reverse a list into X\n&amp;quot; : PrologLex.Internal.result
- lexer();
val it = String &amp;quot;reverse&amp;quot; : PrologLex.Internal.result
- lexer();
val it = LeftParen : PrologLex.Internal.result
- lexer();
val it = LeftBracket : PrologLex.Internal.result
- lexer();
val it = RightBracket : PrologLex.Internal.result
- 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コメントの扱い失敗してますね。この辺はどうしようもないのかなあ&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;困ったところ&lt;/h1&gt;

&lt;p&gt;ドキュメントが古いSML/NJのものらしく、SMLのコードをそのまま書いても動かなかった。&lt;code&gt;revfold&lt;/code&gt;とか&lt;code&gt;inputc&lt;/code&gt;とか。&lt;/p&gt;

&lt;p&gt;次回はmlyaccでも触ってみますか。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>