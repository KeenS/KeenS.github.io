<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/post/</link>
    <description>Recent content in Posts on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Jan 2016 18:52:56 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ATS2の観が整理出来た</title>
      <link>http://keens.github.io/blog/2016/01/01/ats2nokangaseiridekita</link>
      <pubDate>Fri, 01 Jan 2016 18:52:56 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2016/01/01/ats2nokangaseiridekita</guid>
      <description>

&lt;p&gt;κeenです。ATS2には3つの世界があります。動的な世界、静的な世界、証明の世界。
&lt;a href=&#34;http://keens.github.io/blog/2015/12/29/ats2noizongatawotsukatteavlki/&#34;&gt;前回&lt;/a&gt;の記事では静的な世界を色々扱ってみました。
今回は証明の世界である観について少し。&lt;/p&gt;

&lt;h1 id=&#34;観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;観&lt;/h1&gt;

&lt;p&gt;観(view)は、線形型によるリソース管理をするための仕組みです。
静的な世界と同様コンパイル時に検査されたらバイナリには現われませんが関数の引数として渡したり観を扱う関数(証明関数)を定義出来たり
動的な世界と似た部分があります。&lt;/p&gt;

&lt;h1 id=&#34;注観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;注観&lt;/h1&gt;

&lt;p&gt;at-viewの和訳だそうです。これは観の中でも特に特定のアドレスにデータが存在することの証明を現わす観です。
線形型の主な管理対象がメモリなので特別扱いされているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;抽象観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;抽象観&lt;/h1&gt;

&lt;p&gt;任意のリソース管理に使っていい観。これ自体は実体を持たないので後述のデータ観などで実体を与える必要があります。
ドキュメントではロックの管理だとかに使う例が載っていました。&lt;/p&gt;

&lt;h1 id=&#34;観型:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;観型&lt;/h1&gt;

&lt;p&gt;ただ単に観と型をくっつけたものです。「あると便利なのは分かるけど…」と思ってましたが、だんだん理解が追いついてきました。&lt;/p&gt;

&lt;p&gt;1つには観と型を1つの記法で現わせるので記述が楽になる。もう1つにはある型に対して必ず線形型によるリスース管理がされることを保証出来る。&lt;/p&gt;

&lt;p&gt;もう1つの用途が思い浮かんだらなるほど、となりました。&lt;/p&gt;

&lt;p&gt;こちらは注観に限らず任意の観と任意の型を組み合わせれるようです。&lt;/p&gt;

&lt;h1 id=&#34;データ観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;データ観&lt;/h1&gt;

&lt;p&gt;動的な世界でのデータ型のように、静的な世界でのデータ種のように、証明の世界にもデータ観というものがあります。&lt;/p&gt;

&lt;p&gt;例えば、あるかもしれないしないかもしれないリソースを現わすのにオプショナル観が使えそうだ、など。&lt;/p&gt;

&lt;p&gt;これ自体は新しい観を作るためのものです。&lt;/p&gt;

&lt;h1 id=&#34;データ観型:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;データ観型&lt;/h1&gt;

&lt;p&gt;これは動的な世界と証明の世界両方に跨るものです。おおざっぱにはデータ型とデータ観を組み合わせたものです。
つまり、データ型であり、データ観であり、両方合わさってるので観型でもあります。&lt;/p&gt;

&lt;p&gt;「データ型を観で管理しようとしたら同じようなデータ観を作ることになるしまとめて作れたら嬉しいよね」が一番分かりやすい説明でしょうか。&lt;/p&gt;

&lt;p&gt;データ観型専用のシンタックスなどもあるようなので単なるシンタックスシュガーではなさそうです。&lt;/p&gt;

&lt;p&gt;こちらは注観というかメモリ管理の観が割り当てられるみたいです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Rustと比べると随分リッチなリソース管理が出来ますね。&lt;/p&gt;

&lt;h1 id=&#34;まだ良く分かってない部分:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;まだ良く分かってない部分&lt;/h1&gt;

&lt;p&gt;ATS2にはprop（命題）というものもあります。「観はpropの線形バージョン」と書いてあるのですがどう分けられているのでしょうか。
例えば観型にpropは渡せなそうな気がしますが、証明関数には命題も観も渡せそうな気がします。&lt;/p&gt;

&lt;p&gt;微妙に命題と観が共存していたり排他的であったりします。動的な世界のdatatyp, 静的な世界のdatasort, 証明の世界のdataviewという理解でいるとdatapropの居場所がなくなります。&lt;/p&gt;

&lt;p&gt;今のところ、証明の世界も普通の命題であるpropと線形の命題であるviewに分かれていて、
それらはsortが違うので一部では排他的であり、どちらのsortに対しても対応しているものもあるので共存してるようにも見えるという仮説を立てています。&lt;/p&gt;

&lt;p&gt;ドキュメントにも種viewや種propという記述があるので種がsortが違うのは正しそうです。&lt;/p&gt;

&lt;p&gt;しかしそうするとdatasortとかで新しく作った種はどこの世界に住むことになるんでしょうか。静的な世界?証明の世界に住む新しい種を定義出来ない?&lt;/p&gt;

&lt;p&gt;ビルトインの種viewと種propの静的な項(の静的な項)だけが証明の世界の住人になれる?&lt;/p&gt;

&lt;p&gt;datasortとかで作った新しい種は依存型や依存命題(?)、依存観(?)で使うためにある?&lt;/p&gt;

&lt;p&gt;分からないことが多いですね。もう少しATS2の世界の整理をつけたい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ATS2の依存型を使ってAVL木</title>
      <link>http://keens.github.io/blog/2015/12/29/ats2noizongatawotsukatteavlki</link>
      <pubDate>Tue, 29 Dec 2015 23:40:45 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/29/ats2noizongatawotsukatteavlki</guid>
      <description>

&lt;p&gt;κeenです。少しばかりATS2を触ってみたので成果報告でも。&lt;/p&gt;

&lt;p&gt;AVL木は左右のノードの高さが高々1しか違わない平衡二分木です。OCamlやSMLでナイーブに実装すると本当に1しか違わないことを保証するのは難しく、精々テストなどで部分的に検査するだけです。&lt;/p&gt;

&lt;p&gt;ところがSMLに似た文法を持つATS2には依存型があり、左右のノードの高さが高々1しか違わないことを型で保証出来ます。
つまり、左右のノードの高さが2以上違う木を作ろうとしてもコンパイルエラーになるのでコンパイルが通れば高さについてはバグがないこと保証されます。&lt;/p&gt;

&lt;p&gt;そういうAVL木を使ってTreeSetを作ってみたので紹介します。&lt;/p&gt;

&lt;p&gt;私のブログ(のこの記事)の読者ならATS2も依存型もAVL木も知ってそうですが一応説明します。&lt;/p&gt;

&lt;h1 id=&#34;ats2って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;ATS2って何?&lt;/h1&gt;

&lt;p&gt;詳しい説明は&lt;a href=&#34;http://jats-ug.metasepi.org/#document&#34;&gt;日本ATSユーザグループ&lt;/a&gt;に譲るとして、この記事にて重要な点を挙げます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SMLに似た文法を持つML方言&lt;/li&gt;
&lt;li&gt;型の部分に型以外の項（例えば整数とか）が使える&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E5%9E%8B&#34;&gt;依存型&lt;/a&gt;を持つ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他にももっと素晴しい型システムや機能、特徴があるのですがとりあえずのところは上記の特徴を押えておいて下さい。&lt;/p&gt;

&lt;h1 id=&#34;依存型って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;依存型って何?&lt;/h1&gt;

&lt;p&gt;先程も述べた通り、ざっくり言うと型の部分に型以外の項が使える型システムです。&lt;/p&gt;

&lt;p&gt;例えば、次のSMLのコードを考えてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Array.get(arr: int array, index: int): int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型から読み取れるのは「&lt;code&gt;int&lt;/code&gt;の配列&lt;code&gt;arr&lt;/code&gt;と整数&lt;code&gt;index&lt;/code&gt;を受け取って&lt;code&gt;int&lt;/code&gt;の値を返す」関数です。
しかしこの関数は&lt;code&gt;index&lt;/code&gt;が&lt;code&gt;arr&lt;/code&gt;の長さよりも大きい時に実行時例外を上げます。内部でメモリを護るために境界チェックをして、チェックに落ちた時に例外を挙げている筈です。。
配列アクセスの度に実行時例外をハンドルするのはコード上もパフォーマンス上も避けたいですよね。
こういうものをコンパイル時に防ぎたくありませんか？無駄な境界チェックを省きたくありまんか？依存型を使えばそれが出来ます。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;array_get{n, i: nat| i &amp;lt; n}(arr: arrayref(int, n), index: int(i)): int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは「長さ&lt;code&gt;n&lt;/code&gt;の&lt;code&gt;int&lt;/code&gt;配列&lt;code&gt;arr&lt;/code&gt;と&lt;code&gt;n&lt;/code&gt;以下の自然数&lt;code&gt;index&lt;/code&gt;を受け取って&lt;code&gt;int&lt;/code&gt;の値を返す」関数です。
正しい入力しか受け取らないので実行時例外が起きませんし内部で境界チェックも必要ありません。面白くないですか？&lt;/p&gt;

&lt;p&gt;私も大して型システムに詳しくないのでこのくらいの例しか挙げることが出来ませんがきっとさらに面白い世界が広がっているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;avl木って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;AVL木って何？&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/AVL%E6%9C%A8&#34;&gt;Wikipedia&lt;/a&gt;を参照すると詳しいことが載っています。前の説明を繰り返すと、左右のノードの高さが高々1しか違わない平衡二分木です。自身の高さは左右の高さの高い方+1です。
データ構造は左右の木、ノードの保持する値の他にそのノードの高さを保持します。&lt;/p&gt;

&lt;p&gt;なので平衡度は赤黒木より高く、検索が高速な一方、要素数を変更する操作の度に平衡を取らないといけないので挿入や削除は赤黒木に負けるそうです。
OCamlのstdlibのMap/Setの実装に使われています。(OCamlは左右の高さが高々2違う木なので厳密にはAVL木ではないのですがアルゴリズムは同じです。)&lt;/p&gt;

&lt;p&gt;因みにAVLは人の名前の頭文字みたいです。&lt;/p&gt;

&lt;h1 id=&#34;作ってみよう:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;作ってみよう&lt;/h1&gt;

&lt;p&gt;今回、ATS2の依存型に関係ない機能、関数テンプレートなどは理解（読解）の妨げになると判断してそれらを使わないコード例を出します。
(関数テンプーレートを使わなくても多相型を使えば良さそうですが、ATS wayではなさそうです。)&lt;/p&gt;

&lt;p&gt;ということで、整数を格納するSetを作ってみましょう。&lt;/p&gt;

&lt;p&gt;実装に先立って、&lt;a href=&#34;https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml&#34;&gt;OCamlのSet&lt;/a&gt;や&lt;a href=&#34;https://tech.bezoomnyville.com/2015/12/07/A-GADT-implementation-of-AVL-tree.html&#34;&gt;GADTを使ったAVLの実装&lt;/a&gt;を読んでおくと比較が出来るかと思います。&lt;/p&gt;

&lt;p&gt;今回OCamlのSetを参考にして作ったので比較のためにコードを載せたいのですがOCamlは確かコードの再配布に厳しいライセンスだった気がするのでやめておきます。(スニペットくらいなら著作権は発生せず、ライセンス関係なしに使えるのですが念のため。)&lt;/p&gt;

&lt;h2 id=&#34;おまじない:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;おまじない&lt;/h2&gt;

&lt;p&gt;標準的な操作を取り込むため、以下をファイルの先頭に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;#include &amp;quot;share/atspre_staload.hats&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;データ型:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;データ型&lt;/h2&gt;

&lt;p&gt;高さnのAVL木を表わすデータ型を考えます。このデータ型は、&amp;rdquo;型パラメータとして&amp;rdquo;木の高さnを取ります。&lt;/p&gt;

&lt;p&gt;書き出しはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続けて、Emptyを書きます。Emptyは高さ0です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
    Empty(0)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いて、Nodeですが、左の木の高さと右の木の高さを表わす変数を導入します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat} Node of ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このクルクル括弧&lt;code&gt;{}&lt;/code&gt;で囲まれた部分は「任意の&lt;code&gt;nat&lt;/code&gt;なる&lt;code&gt;l&lt;/code&gt;,&lt;code&gt;m&lt;/code&gt;に対して」と読めば読み易いです。&lt;/p&gt;

&lt;p&gt;データ構造は、左右の木、値、高さを持つのでした。ここで、高さは&lt;code&gt;n&lt;/code&gt;であると型で制約されてます。ということでこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat} Node of (avlt(l), int, avlt(m), int(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の高さの部分で&lt;code&gt;int(n)&lt;/code&gt;となっているのは、&lt;code&gt;n&lt;/code&gt;は種&lt;code&gt;int&lt;/code&gt;であって型ではないので「整数&lt;code&gt;n&lt;/code&gt;の&lt;code&gt;int&lt;/code&gt;&amp;ldquo;型&amp;rdquo;」にする為に&lt;code&gt;int()&lt;/code&gt;を適用する必要があるのです。依存型だと「ただの整数値」だけでなく「整数3」などの型も作れるのです。&lt;/p&gt;

&lt;p&gt;さて、このままだと左右の木の高さが高々1しか違わないということを表わせていません。さらにいうと、自身の高さについての制約も書けていません。これらの制約はこう書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat | &amp;lt;制約&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回の制約はこうなりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat |
    (l + 2 == n &amp;amp;&amp;amp; m + 1 == n) || // 右が左より1高い 又は
    (l + 1 == n &amp;amp;&amp;amp; m + 1 == n) || // 左右同じ高さ 又は
    (l + 1 == n &amp;amp;&amp;amp; m + 2 == n)    // 左が右より1高い
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果、データ型はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
    Empty(0)
  | {l, m: nat |
    (l + 2 == n &amp;amp;&amp;amp; m + 1 == n) ||
    (l + 1 == n &amp;amp;&amp;amp; m + 1 == n) ||
    (l + 1 == n &amp;amp;&amp;amp; m + 2 == n)
} Node of (avlt(l), int, avlt(m), int(n))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中々複雑ですね。&lt;/p&gt;

&lt;h2 id=&#34;height:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;軽い関数から作っていきましょう。まずは木の高さを返す関数&lt;code&gt;height&lt;/code&gt;です。高さ&lt;code&gt;n&lt;/code&gt;の木を受け取って整数&lt;code&gt;n&lt;/code&gt;を返します。&lt;/p&gt;

&lt;p&gt;書き出しはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;code&gt;n&lt;/code&gt;を導入します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数は「高さ&lt;code&gt;n&lt;/code&gt;の木」ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n))...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値は「整数&lt;code&gt;n&lt;/code&gt;」です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n)): int(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数本体は普通です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n)): int(n) = 
  case+ tree of
  | Empty () =&amp;gt; 0
  | Node (_, _, _, n) =&amp;gt; n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで使っている&lt;code&gt;case+&lt;/code&gt;ですが、普通の&lt;code&gt;case&lt;/code&gt;より強くて網羅性検査に落ちるとコンパイルエラーになります。&lt;/p&gt;

&lt;h2 id=&#34;create:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;これから&lt;code&gt;insert&lt;/code&gt;を実装していく訳ですが、ユーティリティから少しづつ実装していきます。まずは高さが高々1しか違わない木2つと値を1つ受け取って新たな木を作る&lt;code&gt;create&lt;/code&gt;です。&lt;code&gt;Node&lt;/code&gt;を生で使うのに比べて高さの計算が必要なくなります。&lt;/p&gt;

&lt;p&gt;これは先に実装を与えて、後で型を考えましょう。先程の&lt;code&gt;height&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create??(l: ??, v: int, r: ??): ?? = let
  val hl = height l
  val hr = height r
in
  if hl &amp;gt;= hr
  then Node(l, v, r, hl + 1)
  else Node(l, v, r, hr + 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、型を考えていきます。まずは&lt;code&gt;l&lt;/code&gt;と&lt;code&gt;r&lt;/code&gt;はある高さを持つ木です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{l, m: nat} (l: avlt(l), v: int, r: avlt(m)): ?? = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、左右で高さが高々1しか違わないことを制約したいです。これは&lt;code&gt;Node&lt;/code&gt;の定義を参考にすると書けるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{
  l, m: nat |
  l + 1 == m ||
  l == m + 1 ||
  l == m
  } (l: avlt(l), v: int, r: avlt(m)): ?? = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に返り値の型を考えます。返り値は「&lt;code&gt;l&lt;/code&gt;か&lt;code&gt;m&lt;/code&gt;どちらか大きい方+1の高さを持つ木」です。私は最初、それをこう表現していました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create...(...): [n: nat | n == m + 1 || n == l + 1] avlt(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[n: nat | n == m + 1 || n == l + 1] avlt(n)&lt;/code&gt;の部分を読み下すと、「&lt;code&gt;n = m + 1&lt;/code&gt;又は&lt;code&gt;n = l + 1&lt;/code&gt;を満たす&lt;code&gt;n&lt;/code&gt;に対して&lt;code&gt;avlt(n)&lt;/code&gt;」という型になります。これは、間違ってはいないのですが正確ではありませんでした。なぜならこの型に忠実に従うと&lt;code&gt;l = m + 1&lt;/code&gt;の時に&lt;code&gt;n = m + 1&lt;/code&gt;、すなわち&lt;code&gt;n = l&lt;/code&gt;もありえてしまいます。勿論そんなことはなく、&lt;code&gt;l = m + 1&lt;/code&gt;ならば&lt;code&gt;n = l + 1&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;よって正しい型は&lt;code&gt;[n: nat | (m &amp;gt; l &amp;amp;&amp;amp; n == m + 1) || (l &amp;gt;= m &amp;amp;&amp;amp; n == l + 1)] avlt(x, n)&lt;/code&gt;です。やたら長いですね。&lt;/p&gt;

&lt;p&gt;全体を載せると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{
  l, m: nat |
  l + 1 == m ||
  l == m + 1 ||
  l == m
  } (l: avlt(l), v: int, r: avlt(m)): [n: nat | (m &amp;gt; l &amp;amp;&amp;amp; n == m + 1) || (l &amp;gt;= m &amp;amp;&amp;amp; n == l + 1)] avlt(n) = let
  val hl = height l
  val hr = height r
in
  if hl &amp;gt;= hr
  then Node(l, v, r, hl + 1)
  else Node(l, v, r, hr + 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;rotate:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;rotate&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;OCamlのSetでは1まとめに&lt;code&gt;bal&lt;/code&gt;としていますが、条件分岐が多すぎて読みづらいので&lt;code&gt;right&lt;/code&gt;と&lt;code&gt;left&lt;/code&gt;に分離することにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rotate_xxx&lt;/code&gt;は、左右で高さがちょうど2違う木と値を受け取って、バランスのとれた木を作って返す関数です。
&lt;code&gt;rotate_right&lt;/code&gt;なら左の木が右の木より2高い木を受け取って上手い具合に木の付け替えをして新たな木を返します。&lt;/p&gt;

&lt;p&gt;返り値の木は左の木と同じ高さかあるいはそれより1高い木です。&lt;/p&gt;

&lt;p&gt;そろそろ慣れてきたと思うので型までを一気に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、さらに左側の木の左右の高さでも場合分けが必要になるのでまずは色々バラします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let
  val+ Node(ll, lv, lr, _) = l
  val hll = height ll
  val hlr = height lr
in
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、ここが一番面白い所です。&lt;code&gt;val+ Node(ll, lv, lr, _) = l&lt;/code&gt;に注目して下さい。 OCamlでは&lt;code&gt;match l with Empty -&amp;gt; invalid_arg &amp;quot;Set.bal&amp;quot; | Node (ll, lv, lr, _) -&amp;gt; ...&lt;/code&gt;となっていた部分です。
型制約から、&lt;code&gt;l&lt;/code&gt;は高さ2以上の木であることが分かっているので&lt;code&gt;Empty&lt;/code&gt;でないことが保証されます。なので &lt;strong&gt;&lt;code&gt;Node&lt;/code&gt;だけで網羅出来ているとコンパイラが理解してくれ&lt;/strong&gt; ます。マッチが1節しかないので&lt;code&gt;val&lt;/code&gt;のパターンマッチで代用出来ますね。
&lt;code&gt;val+&lt;/code&gt;は&lt;code&gt;case+&lt;/code&gt;と同じく網羅性検査に落ちるとコンパイルエラーになるバージョンの&lt;code&gt;val&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;残りの実装をまとめると、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let
  val+ Node(ll, lv, lr, _) = l
  val hll = height ll
  val hlr = height lr
in
  if  hll &amp;gt;= hlr
  then create(ll, lv, create(lr, v, r))
  else let
       val+ Node(lrl, lrv, lrr, _) =  lr
  in
    create(create(ll, lv, lrl), lrv, create(lrr, v, r))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rotate_left&lt;/code&gt;はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_left{hl, hr: nat |
  hl + 2 == hr
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hr || n == hr + 1] avlt(n) = let
  val+ Node(rl, rv, rr, _) = r
  val hrl = height rl
  val hrr = height rr
in
  if  hrr &amp;gt;= hrl
  then create(create(l, v, rl), rv, rr)
  else let
    val+ Node(rll, rlv, rlr, _) =  rl
  in
    create(create(l, v, rll), rlv, create(rlr, rv, rr))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bal:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;bal&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;rotate_right&lt;/code&gt;, &lt;code&gt;rotate_left&lt;/code&gt;, &lt;code&gt;create&lt;/code&gt;を1まとめにして左右の高さの差が高々2の2つの木と値を受け取ってバランスのとれた木を作って返す&lt;code&gt;bal&lt;/code&gt;を作りましょう。&lt;/p&gt;

&lt;p&gt;型がエグいことになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun bal{hl, hr: nat |
  ~2 &amp;lt;= hl - hr  &amp;amp;&amp;amp; hl - hr &amp;lt;= 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat|
 (hl == hr - 2 &amp;amp;&amp;amp; n == hr    ) ||
 (hl == hr - 2 &amp;amp;&amp;amp; n == hr + 1) ||
 (hl == hr - 1 &amp;amp;&amp;amp; n == hr + 1) ||
 (hl == hr     &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 1 &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 2 &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 2 &amp;amp;&amp;amp; n == hl    )
] avlt(n) = let
  val hl = height l
  val hr = height r
in
  if hl = hr + 2
  then rotate_right(l, v, r)
  else if hl = hr - 2
  then rotate_left(l, v, r)
  else create(l, v, r)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cmp:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;さて、本来のOCamlのSetはファンクタで出来てますがATS2には原始的なファンクタしかないのでファンクタを使わずにこれまで実装してきました。
あまりよろしくありませんが&lt;code&gt;cmp&lt;/code&gt;もベタっと実装してしまいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun cmp(x: int, y: int): int = x - y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;empty-singleton:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;singleton&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun empty(): avlt(0) = Empty()
fun singleton(x: int): avlt(1) = Node(Empty, x, Empty, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insert:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ここまで辿りついたらもう難しいところはありません。&lt;code&gt;insert&lt;/code&gt;した結果、木の高さが変わらないか1増えるだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun insert{m: nat}(x: int, tree: avlt(m)): [n: nat | n == m || n == m + 1]avlt(n) =
  case+ tree of
  | Empty () =&amp;gt; singleton(x)
  | t as Node(l, v, r, _) =&amp;gt; let
    val c = cmp(x, v)
  in
    if c = 0 then t
    else if c &amp;lt; 0
    then bal(insert(x, l), v, r)
    else bal(l, v, insert(x, r))
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mem:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;mem&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun mem{m: nat}(x: int, tree: avlt(m)): bool =
  case+ tree of
  | Empty () =&amp;gt; false
  | Node(l, v, r, _) =&amp;gt; let
    val c = cmp(x, v)
  in
    if c = 0
    then true
    else if c &amp;lt; 0
    then mem(x, r)
    else mem(x, l)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;遊ぶ:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;遊ぶ&lt;/h1&gt;

&lt;p&gt;さて、少しばかり遊んでみましょう&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;
implement
main0 () =  {
  val tree = Empty
  val tree = insert(1, tree)
  val tree = insert(2, tree)
  val tree = insert(4, tree)
  val b = mem(2, tree)
  val c = mem(3, tree)
  val () = fprintln!(stdout_ref, b)
  val () = fprintln!(stdout_ref, c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これまでのファイルを&lt;code&gt;avlset_int.dat&lt;/code&gt;に保存して、以下のようにコンパイル/実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ patscc avlset.dats -DATS_MEMALLOC_LIBC
$ ./a.out
true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと動いているようです。(GCをリンクしてないのでメモリリークしてる気がしますが、GCのリンクの仕方が分からなかったのでこのままにします。)&lt;/p&gt;

&lt;p&gt;追記: GCのリンクの仕方を教えてもらいました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; GC付きコンパイルには -DATS_MEMALLOC_GCBDW -lgc を使うようです。僕も今知りました。。。 / master · githwxi/ATS-Postiats-contrib &lt;a href=&#34;https://t.co/4DPotHeUJ1&#34;&gt;https://t.co/4DPotHeUJ1&lt;/a&gt;&lt;/p&gt;&amp;mdash; Myu-Myu- ATS-tan! (@masterq_mogumog) &lt;a href=&#34;https://twitter.com/masterq_mogumog/status/682142334704717824&#34;&gt;2015, 12月 30&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;まとめ:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;依存型を持つATS2を使うことでAVL木の高さに関する要件を必ず満たす木を作ることが出来ました。
これは変な入力がないことを保証するばかりでなく、自らの実装がバグっていないことの確認にも使えます。
また、&lt;code&gt;val+&lt;/code&gt;の例で見た通り、パターンマッチについてもより厳格な検査が出来るので無意味なコードを書かなくて済みました。&lt;/p&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/avlset&#34;&gt;こちら&lt;/a&gt;に置いておきます。また、関数テンプレートを使ったよりジェネリックな実装もあります。&lt;/p&gt;

&lt;h1 id=&#34;ノート:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;今回型レベルで保証したのは高さに対する要件だけでした。
「ノードの左側の木にはそのノードの保持する値より小さい値しか入っていない」「一度&lt;code&gt;insert&lt;/code&gt;した値は&lt;code&gt;mem&lt;/code&gt;すると&lt;code&gt;true&lt;/code&gt;が返ってくる」などの要件については無保証のままです。
実はATS2には&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/c2849.html&#34;&gt;定理証明器&lt;/a&gt;も付いており、そのような振舞に関しても保証出来ます。&lt;/li&gt;
&lt;li&gt;ATS2には依存型の他にも&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/p3301.html&#34;&gt;線形型&lt;/a&gt;を持っていて、GCに頼らないメモリ管理が可能です。
今回のコードも線形型を使ってメモリリークしないように出来るでしょう。&lt;/li&gt;
&lt;li&gt;関数テンプレートを使ったAVL木の実装には若干危い点があります。関数テンプレートは実装をアドホックに変更出来るので
比較関数を差し替えれてしまいます。&lt;code&gt;cmp(x, y) = x - y&lt;/code&gt;で木を作った後に&lt;code&gt;cmp(x, y) = y - x&lt;/code&gt;にしてさらに要素を挿入したら大惨事になるでしょう。
そこまで気にするようなら&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/x1974.html&#34;&gt;ファンクタ&lt;/a&gt;を使うべきです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;その他:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;その他&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CoqやAgdaのように依存型も定理証明器もある言語がありますが、それらと違ってATS2は「汎用プログラミング言語に表現力の高い依存型を付けて、ついでに定理証明器もついてる」くらいです。
本格的な証明には向かない一方汎用プログラミングにはATS2の方が向いているでしょう。&lt;/li&gt;
&lt;li&gt;しかしCoqと似ている面もあり、ATS2の世界で依存型や線形型、証明などで強い保証を付けた後は一旦Cのコードをエクストラクトして、それをコンパイルしています。&lt;/li&gt;
&lt;li&gt;Cにエクストラクトされるということで、ATS2はCとの相互連携が出来ます。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、ATS2には心躍る特徴がたくさんあります。依存型で実行時検査をコンパイル時検査に持ち上げ、定理証明器でバグも潰せて、
線形型でボックス/アンボックデータの扱いやGCに頼らないリソース管理やデータ競合の回避が出来、
並列プログラミングもサポート、低レベルなCのコードを呼べてバイナリサイズも小さいなどなど。&lt;/p&gt;

&lt;p&gt;しかし、これらの機能を得るのにATS2は1つだけ代償を払いました。学習コストです。
私はCも書きますしSMLも書きます。依存型のあるCoqや線形型より少し弱いアフィン型のあるRustも書いたことがあります。そんな私にもATS2は難解です。
最近難解な言語として名高くなってきたRustですら足元に及ばないでしょう。&lt;/p&gt;

&lt;p&gt;それでも、急峻な学習曲線の崖をよじ登った先には素晴しい世界が広がっているのです。1つ、修行だと思ってトライしてみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://fumieval.tumblr.com/post/28324791101/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%81%AE%E5%8C%BA%E5%88%86&#34;&gt;プログラマの区分&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#とCプリプロセッサの連携</title>
      <link>http://keens.github.io/blog/2015/12/26/sml_tocpuripurosessanorenkei</link>
      <pubDate>Sat, 26 Dec 2015 20:09:24 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/26/sml_tocpuripurosessanorenkei</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第3段はSML#とCプリプロセッサで連携する話。&lt;/p&gt;

&lt;p&gt;SML#のC FFIを使ってるとマクロで定義された値などを触りたくなるのですが、触れないのでどうにかしようかと。&lt;/p&gt;

&lt;p&gt;発想自体は単純で、SMLファイルの中でCのヘッダをインクルードしてCプリプロセッサを呼んであげればどうにかなります。&lt;/p&gt;

&lt;h1 id=&#34;簡単な例:17ab4ed508953994d38c55ce3a68a752&#34;&gt;簡単な例&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi/&#34;&gt;JITを作る話&lt;/a&gt;の時のように、定数に触りたいとします。
その時、以下のように.smlファイルを記述して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* 
#include&amp;lt;sys/mman.h&amp;gt;
*)

(* ====END_OF_HEADER==== *)
datatype dummy = $ of int
              
val $PROT_READ  = $ PROT_READ
val $PROT_WRITE = $ PROT_WRITE
val $PROT_EXEC  = $ PROT_EXEC
val $PROT_NONE  = $ PROT_NONE

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E cpp_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; cpp.sml 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントを挙げると、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;smlファイルに&lt;code&gt;#include&lt;/code&gt;を書く。lintでエラーが出ないように&lt;code&gt;#include&lt;/code&gt;はコメントで囲む&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt;をコメントで囲ったところで安全でない( インクルードしたファイルに&amp;rsquo;&lt;code&gt;*)&lt;/code&gt;&amp;lsquo;、例えば &lt;code&gt;int f(char *);&lt;/code&gt;とかが入ってるとコメントが終端される)ので、&lt;code&gt;include&lt;/code&gt;の部分は後で削除する。
そのための識別子として、&lt;code&gt;====END_OF_HEADER====&lt;/code&gt;を置いておく(これも完全には安全ではないが比較的マシ)。&lt;/li&gt;
&lt;li&gt;Cのマクロと同じ識別子を使おうとすると識別子も置換されてしまうので左辺にダミーで&lt;code&gt;$&lt;/code&gt;をつけておく。スペースは空けない。
逆に右辺は置換されてほしいので&lt;code&gt;$&lt;/code&gt;の後にスペースを空ける。&lt;/li&gt;
&lt;li&gt;最後にCプリプロセッサを呼び、sedでヘッダ部分や無駄に追加されたCのコメントを除く。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ちょっと&lt;code&gt;$&lt;/code&gt;の部分がこの方式だとintにしか使えないのでイケてませんがないよりマシでしょう。因みに処理結果はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype dummy = $ of int

val $PROT_READ = $ 
                   0x1

val $PROT_WRITE = $ 
                   0x2

val $PROT_EXEC = $ 
                   0x4

val $PROT_NONE = $ 
                   0x0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ifdef:17ab4ed508953994d38c55ce3a68a752&#34;&gt;&lt;code&gt;ifdef&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;一旦発想さえ得てしまえば話は簡単です。次は&lt;code&gt;ifdef&lt;/code&gt;を使う例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* ====END_OF_HEADER==== *)


(* 
#ifdef Debug
*)
val debug = true
(* 
#else
*)
val debug = false

(* 
#endif
*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E -DDebug ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;Debug&lt;/code&gt;を定義して処理すればifdef.smlの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*

*)
val debug = true
(*






*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となりますし、定義せずに&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
``` sh
cpp -pipe -E ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と処理すれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*





*)
val debug = false

(*

*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってどちらでもSMLとして有効な文法になります。&lt;code&gt;ifndef&lt;/code&gt;だったり、&lt;code&gt;elif&lt;/code&gt;があったとしても有効な文法のままです。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:17ab4ed508953994d38c55ce3a68a752&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CプリプロセッサでSMLファイルを処理する方法を提示したよ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifdef&lt;/code&gt;も使えるよ&lt;/li&gt;
&lt;li&gt;関数マクロは使えないよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#のオレオレREPLを作る話 初級</title>
      <link>http://keens.github.io/blog/2015/12/26/sml_nooreorereplwotsukuruhanashi_shokyuu</link>
      <pubDate>Sat, 26 Dec 2015 19:48:30 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/26/sml_nooreorereplwotsukuruhanashi_shokyuu</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第2段はSML#のオレオレREPLを作る話の初級。&lt;/p&gt;

&lt;p&gt;SML#にはFFIがあり、任意のオブジェクトファイル/ライブラリをリンクしてC関数を呼び出すことが出来ますが、REPLで試そうとしてもREPLにリンクされていないので呼び出せません。
そこで呼び出したいオブジェクトファイルをリンクしたREPLを作れば捗るよね、という発想です。&lt;/p&gt;

&lt;h1 id=&#34;事前に必要なもの:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;事前に必要なもの&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;SML#のビルド時に使ったLLVMのパス&lt;/li&gt;
&lt;li&gt;SML#をビルドした時のオブジェクトファイルの残骸（一部）&lt;/li&gt;
&lt;li&gt;SML#のソーコード（一部）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;コマンド:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;コマンド&lt;/h1&gt;

&lt;p&gt;まず、普通のREPLを作るだけならこれだけです。（コンパイラも一緒にくっついてきますが面倒なのでそのままにしてます。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o oreore_repl &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot;  &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは最後のリンクコマンドにフラグを足せばいいでしょう。注意点として、64bit OSを使ってるならちゃんと32bitでビルドしたライブラリをリンクしましょう。例えばlibuvをリンクするならこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o smlsharp_uv &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot; -L /opt/libuv32/lib -luv &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;終わりに:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;終わりに&lt;/h1&gt;

&lt;p&gt;やり方さえ分かってしまえば簡単ですが見付けるのが難しい小ネタでした。因みに今回初級ですが、REPLにlibeditを統合するなどの上級ネタはいつか気が向いたら書くかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustのロガーを作る</title>
      <link>http://keens.github.io/blog/2015/12/26/rustnoroga_wotsukuru</link>
      <pubDate>Sat, 26 Dec 2015 19:18:31 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/26/rustnoroga_wotsukuru</guid>
      <description>&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第1段はRustのロガーを作る話。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar&lt;/a&gt;の&lt;a href=&#34;http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru/&#34;&gt;初日&lt;/a&gt;でロガーはfacadと実装に分かれてると書きましたが、実装を作る話ですね。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/log/log/index.html&#34;&gt;ドキュメント&lt;/a&gt;を見てもらえば分かる通り、logは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Log: Sync + Send {
    fn enabled(&amp;amp;self, metadata: &amp;amp;LogMetadata) -&amp;gt; bool;
    fn log(&amp;amp;self, record: &amp;amp;LogRecord);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とだけインターフェースが定まっているのでそこを実装してあげれば終わりです。
なぜまたloggerを作ろうとしたのかというと、Rust公式の&lt;a href=&#34;https://crates.io/crates/env_logger/&#34;&gt;env_logger&lt;/a&gt;は標準出力にしか出せず、crates.ioを捜しても（作ろうと思った時点ではパっと見）ファイルに書き出せるものがなさそうだったからです。&lt;/p&gt;

&lt;p&gt;私が作ったのは&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logger&lt;/a&gt;といいます。まだcrates.ioには出してません。TOMLでコンフィグを書けるようになったら出そうかと思うのですがもう既にファイルに書きだせるものが他にありますかね。&lt;/p&gt;

&lt;p&gt;今回作るにあたって目指したのは1つのことにだけ集中する他と組み合わせられるライブラリです。
logはロガーをグローバル変数に代入して使い回してるので同時に1つしかロガーを登録出来ません。そこでロガーアグリケーターのようなものを作ってそれに複数のロガーを登録することが考えられます。
調べきれてませんが恐らく既にいくつか存在するでしょう。アグリゲータの存在を仮定してしまえばアグリゲータに任せれる部分は任せてしまうのが良いでしょう。&lt;/p&gt;

&lt;p&gt;ということで次のことを最初に決めました&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ログフォーマットは柔軟性を持たせる&lt;/li&gt;
&lt;li&gt;ログメッセージの内容に応じて出力を制御出来るフィルターを入れる。(アグリゲータが無差別にログを流し込んで来た時のため)&lt;/li&gt;
&lt;li&gt;複数ファイルへのログはサポートしない。アグリゲータに任せる&lt;/li&gt;
&lt;li&gt;プラグインはサポートしない。アグリゲータに任せる&lt;/li&gt;
&lt;li&gt;ログローテーションはしない。&lt;code&gt;Write&lt;/code&gt;の実装に任せる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一応file loggerですがWriteをすべからく受け取れるので実際はストリームにも使えたりします。今書き出してみたらフォーマッタとかフィルタとかもアグリゲータに任せた方がいいのかなって気がしてきた。
しかし単体での利便性を考えると仕方ない。&lt;/p&gt;

&lt;p&gt;実装は大したことをやっていなくて、精々ログフォーマットを文字列で書けるように（TOMLで設定を書きたいため）フォーマットのパーサを書いた程度でしょうか。&lt;/p&gt;

&lt;p&gt;もう少し考えてからリリースします。あとFile Lotating Writerも一緒に出さなきゃ片手落ちですかね…&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Drillの不自然な挙動</title>
      <link>http://keens.github.io/blog/2015/12/20/apache_drillnofushizennakyodou</link>
      <pubDate>Sun, 20 Dec 2015 23:04:37 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/20/apache_drillnofushizennakyodou</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/drill&#34;&gt;Apache Drill Advent Calendar 2015&lt;/a&gt;21日目のエントリです&lt;/p&gt;

&lt;p&gt;最初は備忘録がてら普段使うMySQL、BigQuery、SQLite、Apache DrillのSQLシンタックスの違いでも書こうかと思ったのですが調査が思ったより大変だったのでやめました。ANSI SQLも色々変わってるということは理解出来ました。&lt;/p&gt;

&lt;p&gt;ということでApache Drillを使ってて「ん？」と思った挙動をいくつか出してみようかと。1.4時点での情報です。&lt;/p&gt;

&lt;h1 id=&#34;select-1:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;&lt;code&gt;SELECT 1&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;シェルで手持ち無沙汰に&lt;code&gt;ls&lt;/code&gt;や&lt;code&gt;pwd&lt;/code&gt;を打つようにSQLプロンプトで&lt;code&gt;SELECT 1;&lt;/code&gt;を打つ訳ですが、Apache Drillはこれを受け付けてくれません。&lt;/p&gt;

&lt;p&gt;まあ、これは不自然というかそういう仕様なのですが正しくは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT 1 FROM (VALUES(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。手持ち無沙汰に打つには少し面倒ですね。そうでなくても日付関数の挙動を確かめたい時にも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT NOW();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとやりたい訳ですがそれにも&lt;code&gt;FROM (VALUES(1));&lt;/code&gt;とダミーの&lt;code&gt;FROM&lt;/code&gt;句を付けてあげる必要があります。面倒ですね。&lt;/p&gt;

&lt;h1 id=&#34;union-と-union-all:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;&lt;code&gt;UNION&lt;/code&gt;と&lt;code&gt;UNION ALL&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;UNION&lt;/code&gt;はテーブル同士のレコード間で重複を取り除いた集合を、&lt;code&gt;UNION ALL&lt;/code&gt;は重複を取り除かない集合を返します。Apache Drillでも試してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM (VALUES (1, 2, 3) UNION VALUES(4, 5, 6) UNION VALUES(7, 8, 9) UNION VALUES(1, 2, 3));
SELECT * FROM (VALUES (1, 2, 3) UNION ALL VALUES(4, 5, 6) UNION ALL VALUES(7, 8, 9) UNION ALL VALUES(1, 2, 3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのクエリはどういう結果になるでしょうか。答えはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT * FROM (VALUES (1, 2, 3) UNION VALUES(4, 5, 6) UNION VALUES(7, 8, 9) UNION VALUES(1, 2, 3));
+---------+---------+---------+
| EXPR$0  | EXPR$1  | EXPR$2  |
+---------+---------+---------+
| 1       | 2       | 3       |
+---------+---------+---------+
1 row selected (0.416 seconds)
0: jdbc:drill:zk=local&amp;gt; SELECT * FROM (VALUES (1, 2, 3) UNION ALL VALUES(4, 5, 6) UNION ALL VALUES(7, 8, 9) UNION ALL VALUES(1, 2, 3));
+---------+---------+---------+
| EXPR$0  | EXPR$1  | EXPR$2  |
+---------+---------+---------+
| 7       | 8       | 9       |
| 7       | 8       | 9       |
| 7       | 8       | 9       |
| 7       | 8       | 9       |
+---------+---------+---------+
4 rows selected (0.115 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うーん。これはバグだと思うんですよね。定数テーブルをキャッシュするようにしてたら全てのレコードで同じ値を参照しちゃって値を書き換えてしまったとか。
&lt;code&gt;UNION&lt;/code&gt;が&lt;code&gt;UNION ALL&lt;/code&gt;の結果から&lt;code&gt;DISTINCT&lt;/code&gt;相当の処理をするなら2番目の結果を見れば最初の結果が従うのもうなずけますし。&lt;/p&gt;

&lt;h1 id=&#34;ヘッダ付きcsv:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;ヘッダ付きCSV&lt;/h1&gt;

&lt;p&gt;Drill 1.4からヘッダ付きCSVの扱いが楽になりましたね。拡張子が&lt;code&gt;csv&lt;/code&gt;のままヘッダ付きCSVにクエリを投げられます。ちょっと試しましょう。&lt;/p&gt;

&lt;p&gt;次のようなCSVファイルを用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/Csv/test.csv
foo,bar,baz
1,1.0,&amp;quot;a&amp;quot;
2,2.0,&amp;quot;b&amp;quot;
3,3.0,&amp;quot;c&amp;quot;
4,4.0,&amp;quot;d&amp;quot;
5,5.0,&amp;quot;e&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリを投げてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT * FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+------+------+
| foo  | bar  | baz  |
+------+------+------+
| 1    | 1.0  | a    |
| 2    | 2.0  | b    |
| 3    | 3.0  | c    |
| 4    | 4.0  | d    |
| 5    | 5.0  | e    |
+------+------+------+
5 rows selected (0.12 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。じゃあ今度は&lt;code&gt;baz&lt;/code&gt;カラムだけ取り出してみましょう。ここで、会社のMacだと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT baz FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+------+------+
| foo  | bar  | baz  |
+------+------+------+
| 1    | 1.0  | a    |
| 2    | 2.0  | b    |
| 3    | 3.0  | c    |
| 4    | 4.0  | d    |
| 5    | 5.0  | e    |
+------+------+------+
5 rows selected (0.12 seconds)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにカラムを指定しているのにも関らず全てのデータが返ってきていました。その旨を書こうと思ったのですが手元のLinuxマシンだと正しい結果が返ってくるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT `bar` FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+
| bar  |
+------+
| 1.0  |
| 2.0  |
| 3.0  |
| 4.0  |
| 5.0  |
+------+
5 rows selected (0.088 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと会社で見たのが幻覚だったかもしれないので要調査ですね。&lt;/p&gt;

&lt;h1 id=&#34;mysqlへの接続:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;MySQLへの接続&lt;/h1&gt;

&lt;p&gt;以下のようなSQLを投げた所、ひどく時間が掛かりました。投げた対象はプロダクションのデータが入ってる分析用のDBで、結構な量のデータが入ってます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM mysql.mydb.`test` LIMIT 20;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache Drill自体レスポンスが悪いのでクエリによってはそんなものかな、と思って最初はそのままにしたのですがふと気になって&lt;code&gt;EXPLAIN&lt;/code&gt;してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=localhost:2181&amp;gt; EXPLAIN PLAN FOR SELECT * FROM mysql.mydb.`test` LIMIT 20;
+------+------+
| text | json |
+------+------+
| 00-00    Screen
00-01      Project(columns....)
00-02        SelectionVectorRemover
00-03          Limit(fetch=[20])
00-04            Limit(fetch=[20])
00-05              Jdbc(sql=[SELECT * FROM `mydb`.`test`])
| {
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Jdbc(sql=[SELECT * FROM mydb.test])&lt;/code&gt; とあるのでなんとMySQLに&lt;code&gt;LIMIT&lt;/code&gt;をつけずにクエリを投げてます。そしてさらに何故か&lt;code&gt;Limit(fetch=[20])&lt;/code&gt;を2回やっています。&lt;/p&gt;

&lt;p&gt;まあ、内部でLimitを2回やってるのは良いとしてもMySQLにLimit無しで投げるのはいただけないですね。
分散モデルのDrillからしたら「分散してる俺らの方が処理が速いから全部俺らでやってやるよ」という気概なのかもしれませんがこちらとしてはDBへの負荷も考えて欲しいものです。
まあ、かといって&lt;code&gt;WHERE&lt;/code&gt;句にインデックスが付く/付かないだとかその他の句によってMySQLのへの負荷も変わるのでなんとも言えないといえばそうなんですが簡単な場合にpush downしてくれるか
あるいは手動でpush down出来る仕組みが欲しいですね。&lt;code&gt;FORCE INDEX&lt;/code&gt;みたいに。&lt;/p&gt;

&lt;p&gt;さて、色々気になる点はありましたがApache Drillは面白いプロダクトです。
主にビッグデータ分析に使われるようですが私は大きなテーブルからアドホックに抽出したCSVとMySQLにあるマスターデータをJOINするなどの目的で使っていきたいなと思っています。&lt;/p&gt;

&lt;p&gt;皆様良いデータ分析ライフを！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最近作ってるLispの話</title>
      <link>http://keens.github.io/blog/2015/12/20/saikintsukutterulispnohanashi</link>
      <pubDate>Sun, 20 Dec 2015 22:40:16 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/20/saikintsukutterulispnohanashi</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lisp&#34;&gt;Lisp Advent Calendar 2015&lt;/a&gt;21日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。最近あまりLispを書いてなくてネタがないので最近作ってるLispの話でもしようかと。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/kappaLisp&#34;&gt;κLisp&lt;/a&gt;といいます。まだまだ完成には程遠いです。現在、&lt;a href=&#34;https://github.com/KeenS/kappaLisp/blob/master/src/eval.rs#L378&#34;&gt;ここら辺&lt;/a&gt;くらいの式なら評価出来ます。&lt;/p&gt;

&lt;p&gt;このLispはSKK辞書に使われているS式を評価するために作られました。
SKKは様々な場所に移植されているのでマルチプラットフォームで動いて他の言語と協調が出来る言語で作るのが望ましいのですが、今回はRustを選びました。
最初はCにしようかと思ったのですがちょいとRustを試してみようかと(当時Rustほとんど書いたことがない初心者)。&lt;/p&gt;

&lt;p&gt;SKKに書かれているS式を処理出来るLisp処理系はあるのですがGPLでライセンスされており、それを使ったiOSアプリをAppStoreに登録出来ないという問題があるそうです。
なのでMITライセンスで作り始めました。&lt;/p&gt;

&lt;p&gt;さて、Lisp処理系くらい簡単に作れそうなものですが、いくつかの点で詰まっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;そもそもRustが難しい&lt;/li&gt;
&lt;li&gt;関数ポインタが思うように扱えない&lt;/li&gt;
&lt;li&gt;やろうとした事がborrow checkに引っ掛かって出来なかった&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この詰まった点はRustが悪い訳ではなくて単に私がRustに合わせた設計が出来なかっただけですね。そろそろRustにも少しづつですが慣れて来たのでどこかのタイミングでリファクタリングして進めていきたいですね。&lt;/p&gt;

&lt;p&gt;一応現状でも進めようと思えば進めれるのですが&lt;a href=&#34;https://github.com/KeenS/kappaLisp/blob/master/src/eval.rs#L232&#34;&gt;ここ&lt;/a&gt;のように明らかにイケてないコードが続くので進めるモチベーション起きませんよね。&lt;/p&gt;

&lt;p&gt;設計とかの話をすると、最終的にはC APIでS式の文字列を受け取ったらそれを評価した結果の文字列を返す関数を晒せばいいかな、と思ってます。
ちゃんとiOSへのクロスコンパイルも出来ますしObj-C, Swift双方C FFIがあるのでそれで十分でしょう。(CF &lt;a href=&#34;http://qiita.com/moriturus/items/1190614dcbbe31ecfc2f&#34;&gt;http://qiita.com/moriturus/items/1190614dcbbe31ecfc2f&lt;/a&gt; , &lt;a href=&#34;http://safx-dev.blogspot.jp/2014/06/rustios.html&#34;&gt;http://safx-dev.blogspot.jp/2014/06/rustios.html&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;パーサは手書きで、実行はインタプリタ、Emacs Lispに則ってLisp2のダイナミックスコープです。設計がクソなのでメモリ管理らしいメモリ管理はやってませんがRustのメモリ管理のお陰でメモリリークはしてません。
ちゃんと設計してReference Countなメモリ管理でもしようかと。フットプリントの軽さ大事。&lt;/p&gt;

&lt;p&gt;全然まとまりませんがいつか使えるようになってAquaSKKやFlickSKKに取り込まれるかもしれないのでその時には裏でこのLispが動いてるかもと思い出してあげて下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>travisとappveyorでクロスプラットフォームなCIする話</title>
      <link>http://keens.github.io/blog/2015/12/20/travistoappveyerdekurosupurattofo_munacisuruhanashi</link>
      <pubDate>Sun, 20 Dec 2015 22:19:21 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/20/travistoappveyerdekurosupurattofo_munacisuruhanashi</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt;20日目の記事です。
日付を覚え間違っていて、締切ギリギリに書いてます。&lt;/p&gt;

&lt;p&gt;κeenです。ものすごい小ネタですがRustでCIする話でも。&lt;/p&gt;

&lt;p&gt;Rustはクロスプラットフォームな言語なのでLinux, Macそしてあまり聞き慣れませんがWindowsというOSでも動きます。
とは言っても普段の開発環境がLinux、運悪くMacを使わざるを得ない人はMacで開発をしているとそれらでの動作検証は出来るでしょうが他のOSでの動作検証が難しいでしょう。&lt;/p&gt;

&lt;p&gt;そこでCIしましょう。Travis CIはLinuxと、あまり使われていませんがMacでのCI環境を、AppveyorでWindowsというOSでのCI環境を作ります。&lt;/p&gt;

&lt;p&gt;しかしクロスプラットフォームでしかもテスト方法がCargoで統一されているRustではそこまで難しいこともなく、以下の設定をコピペするだけです。&lt;/p&gt;

&lt;p&gt;travis&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: rust
rust:
  - nightly
  - beta
  - stable
os:
  - linux
  - osx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;appveyor&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;branches:
  except:
    - gh-pages

platform:
  - x64
environment:
  RUST_INSTALL_DIR: C:\Rust
  matrix:
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: 1.4.0
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: beta
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: nightly
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: 1.4.0
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: beta
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: nightly

install:
  - ps: Start-FileDownload &amp;quot;https://static.rust-lang.org/dist/rust-${env:RUST_VERSION}-${env:RUST_INSTALL_TRIPLE}.exe&amp;quot;
  - cmd: rust-%RUST_VERSION%-%RUST_INSTALL_TRIPLE%.exe /VERYSILENT /NORESTART /DIR=&amp;quot;%RUST_INSTALL_DIR%&amp;quot;
  - cmd: SET PATH=%PATH%;%RUST_INSTALL_DIR%\bin
  - rustc --version
  - cargo --version

build: false
test_script:
  - cargo build --verbose
  - cargo test --verbose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バッジとかは適当に持ってきましょう。&lt;/p&gt;

&lt;p&gt;サンプルが欲しければ&lt;a href=&#34;https://github.com/Stebalien/tempfile&#34;&gt;Stebalien/tempfile&lt;/a&gt;あたりを参考にしましょう。&lt;/p&gt;

&lt;p&gt;それではHave Happy Hacκings!&lt;/p&gt;

&lt;p&gt;※OS関連の煽りはただのネタです。また「あまり使われていませんがMacでのCI環境を」は「(travisの中では)あまり使われていません(のでもしかしたら使えることを知らない人がいるかもしれません)が」という意味です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでReactive Messaging Pattern</title>
      <link>http://keens.github.io/blog/2015/12/19/clojuredereactive_messaging_pattern</link>
      <pubDate>Sat, 19 Dec 2015 22:30:19 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/19/clojuredereactive_messaging_pattern</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/clojure&#34;&gt;Clojure Advent Calendar 2015&lt;/a&gt;の16日目の記事です（大遅刻）&lt;/p&gt;

&lt;p&gt;κeenです。ここのところ体調優れず、また、特に面白いネタもなくClojure Advent Calendarに遅刻したことをお詫び申し上げます。&lt;/p&gt;

&lt;p&gt;さて、今日はReactive Messaging PatternをClojureのcore.asyncでやってみたいと思います。Reactive Messaging Pattersは、Java/Scala向けActorシステムの&lt;a href=&#34;http://akka.io/&#34;&gt;Akka&lt;/a&gt;の作者が著した本、&lt;a href=&#34;http://www.amazon.co.jp/Reactive-Messaging-Patterns-Actor-Model-ebook/dp/B011S8YC5G&#34;&gt;Amazon.co.jp: Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&lt;/a&gt;で書かれているデザインパターンです。&lt;/p&gt;

&lt;p&gt;非常に興味深い本なのですがScala及びAkka初心者の私には中々辛いので一旦Clojureで試してみようかと。&lt;/p&gt;

&lt;p&gt;ところで、AkkaとClojureのcore.asynkには若干のモデルの違いがあります。詳しくは&lt;a href=&#34;http://blog.paralleluniverse.co/2015/05/21/quasar-vs-akka/&#34;&gt;ここ&lt;/a&gt;とかにあるのですが、一番大きくは非同期/同期モデルの違いがあります。
Akkaの場合はActorにメッセージを送っても届いたという保障はなく(「その瞬間に」届いてないだけでなく、届く前にActorが再起動したらメッセージがロストしてしまう!)、また、メッセージの受信も&lt;code&gt;receive&lt;/code&gt;というコールバック用のメソッドを用意してそこでハンドルすることになります。&lt;/p&gt;

&lt;p&gt;そういう違いがある中でどれだけClojureに翻訳出来るか多少不安ですがチャレンジしてみます。尚、原書には様々なパターンがあるのですが流石に本一冊分全部は紹介し切れないので面白そうでかつClojureでも役立ちそうなものだけ紹介することにします。このコードは原書のものをClojureに翻訳したものではなく、私が勝手に書いたものです。コードを参考にするのは雰囲気程度に留めて、実際を知りたかったら原書を読みましょう。&lt;/p&gt;

&lt;p&gt;今回、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject reactive-message-patterns &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.7.0&amp;quot;]
                 [org.clojure/core.async &amp;quot;0.2.374&amp;quot;]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というプロジェクト設定で試しました。また、ソースコードは&lt;a href=&#34;https://github.com/KeenS/reactive-message-patterns&#34;&gt;こちら&lt;/a&gt;で公開しています。&lt;/p&gt;

&lt;h1 id=&#34;messaging-with-actors:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Messaging With Actors&lt;/h1&gt;

&lt;h2 id=&#34;pipes-and-filters:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Pipes And Filters&lt;/h2&gt;

&lt;p&gt;メッセージが来る際に、そのまま受け取るのではなく一旦Filter用のActorで変換やvalidationをかけて本処理に入ります。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;Clojureなら&lt;code&gt;filter&amp;lt;&lt;/code&gt;/&lt;code&gt;filter&amp;gt;&lt;/code&gt;/ transducerで瞬殺&lt;/del&gt; Filter処理をActorに分離することで並列性やモジュール性が上がります。原書の例ではまずDecrypt Filterを噛ませてAuthenticate Filterで認証出来たら De-dup Filterで重複を取り除いてメッセージをクリーンにしてから処理を始める、とういうように非常に実用的な例が出ています。&lt;/p&gt;

&lt;p&gt;また、(transformでなく、篩い分けの)Filterを分離することでFilterした後の処理、例えばinvalidなメッセージが来たらログに出すなどの柔軟性を得ることが出来ます。&lt;/p&gt;

&lt;p&gt;これを実装してみましょう。すごい適当ですがメッセージが来たらそれを2倍するfilterを作ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(use &#39;clojure.core.async)

(defn filter-actor
  ([f]
   (let [in (chan)
         out (chan)]
     (do
       (filter-actor f in out)
       [in out])))
  ([f in out]
   (go-loop []
     (if-let [v (&amp;lt;! in)]
       (if-let [ret (f v)]
         (if (&amp;gt;! out ret)
           (recur)))
       (close! out)))))

(let [[in out] (filter-actor (fn [x] (* x 2)))]
  (go
    ;; producer
    (doseq [v (range 1 10)]
      (&amp;gt;! in v))
    (close! in))
  (go-loop []
    ;; consumer
    (if-let [v (&amp;lt;! out)]
      (do
        (println v)
        (recur))
      (close! out))))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単ですね。チャネルが終わったかどうか調べるのに一々&lt;code&gt;if-let&lt;/code&gt;を使うのが面倒ですがリストに対する再帰関数もそんな感じなのでまあ、こういうもんなんでしょう。&lt;/p&gt;

&lt;h2 id=&#34;その他:258416a532a86ac327ddeb3b653d90b7&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;他にもMessaging With ActorsにはMessage Router, Message Translator, Message Endpointsなどのパターンが載っているのですが割愛します。特にMessage Translatorは外部システム(HTTPリクエスト、MQ, SQLなど)とのやりとりの話なので簡単に試すには少し重すぎるようです。&lt;/p&gt;

&lt;h1 id=&#34;messaging-channels:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Messaging Channels&lt;/h1&gt;

&lt;p&gt;この章にはActor同士のメッセージのやりとりの方法が色々書かれています。
Point-to-Point Channel, Publish-Subscribe Channel, Datatype Channel, Invalid Message Channel, Dead Letter Channel, Guaranteed Delivery, Channel Adapter, Message Bridge, Message Bus。
中々多くのパターンが載っているのですが一部はAkka固有であったりClojureには必要なかったりしますので、私が興味を持ったものを紹介します。&lt;/p&gt;

&lt;h2 id=&#34;publish-subscribe:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Publish-Subscribe&lt;/h2&gt;

&lt;p&gt;定番ですね。概念自体の説明は不要と思います。core.asyncだとどうなるのかを見てみます。&lt;code&gt;pub&lt;/code&gt;と&lt;code&gt;sub&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [publisher (chan)
      publication (pub publisher :topic)
      subscriber1 (chan)
      subscriber2 (chan)]
  (sub publication :delete subscriber1)
  (sub publication :create subscriber1)

  (sub publication :update subscriber2)
  (sub publication :read subscriber2)

  ;; start subscribers before publish start
  (go-loop [] (when-let [v (&amp;lt;! subscriber1)] (printf &amp;quot;I&#39;m One, got %s\n&amp;quot; (:type v)) (recur)))
  (go-loop [] (when-let [v (&amp;lt;! subscriber2)] (printf &amp;quot;I&#39;m Two, got %s\n&amp;quot; (:type v)) (recur)))

  (go (onto-chan publisher [{:topic :update, :type &amp;quot;dog&amp;quot;}
                            {:topic :create, :type &amp;quot;cat&amp;quot;}
                            {:topic :read  , :type &amp;quot;fox&amp;quot;}]))
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おもちゃのような例ですがこれで動くようです。因みに原書ではここに結構なページ数が割かれていて、分散システムを念頭に、異なるシステムにメッセージを送る話なども扱っています。core.asyncだとそこまでは出来そうにないですね。&lt;/p&gt;

&lt;h2 id=&#34;invalid-message-channel:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Invalid Message Channel&lt;/h2&gt;

&lt;p&gt;とあるActorに予期しないメッセージが届いたらどうしましょうか。そのまま捨てますか？もしかしたらバグを潰せる好機かもしれないのにそのまま捨てるには勿体なすぎます。
かといって全てのActorにデバッグ用のコードを入れていては埒が明かないどころかコードが複雑化してしまいます。そこでInvalid Massage Channelを使いましょう。&lt;/p&gt;

&lt;p&gt;あるActorに予期しないメッセージが届いた時に、全てを放り投げるチャネルを用意しておいて、その先のActorでログを出すなりするのです。&lt;/p&gt;

&lt;p&gt;今回は&lt;code&gt;:price&lt;/code&gt;タグのついていないメッセージが届いた時にinvalid actorに放り投げ、ログを出すものを作りました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn invalid [data]
  {:data data
   :from (Thread/currentThread)})

(let [invalid-chan (chan)
      in (chan)
      tax 0.08]
  ;; invalid message processor
  (go-loop []
    (when-let [{data :data from :from} (&amp;lt;! invalid-chan)]
      (printf &amp;quot;invalid data %s from %s from\n&amp;quot; data from)
      (recur)))

  ;; main processing actor
  (go-loop []
    (when-let [v (&amp;lt;! in)]
      (if-let [price (:price v)]
        (printf &amp;quot;price: %f\n&amp;quot; (* price (+ 1 tax)))
        (&amp;gt;! invalid-chan (invalid v)))
      (recur)))

  (go (onto-chan in [{:goods &amp;quot;はじめてのClojure&amp;quot;
                      :price 1900}
                     {:goods &amp;quot;プログラミングClojure&amp;quot;
                      :price 3400}
                     {:goods &amp;quot;へび&amp;quot;
                      :description &amp;quot;にょろにょろ&amp;quot;}])))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;from&lt;/code&gt;についてはActorならアクターオブジェクトに対してリフレクションかけて何かしらの情報をとれるのですが&lt;code&gt;go&lt;/code&gt;に対するリフレクションが分からなかったので代わりにスレッド情報を使いました。
私はこの章を読んだ時にいたく完動しました。ログの扱いを集約出来るし地味にIOして非同期モデルのアクターの邪魔になるログをそれぞれのアクターに持たなくて済む。
しかしこれのActorが落ちたら、とかこのActor自身にinvalidなメッセージが来たら、とか色々考えたくなります。詳しくは原書を読みましょう。&lt;/p&gt;

&lt;h2 id=&#34;その他-1:258416a532a86ac327ddeb3b653d90b7&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;この章には他にも外部システムと連携するMessage Adapter、外部のメッセージングシステムと連携するMessage Bridge、複数のシステム間でメッセージをやりとりするMessage Busなどが載っていますが割愛します。&lt;/p&gt;

&lt;h1 id=&#34;message-construction:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Message Construction&lt;/h1&gt;

&lt;p&gt;この章にはCommand Message, Document Message, Event Message, Request-Reply, Return Address, Correlation Identifire, Message Sequence, Message Expiration, Format Indicatorなどのメッセージ自体にまつわる話題が載っています。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;疲れてきたため&lt;/del&gt; AkkaやScala特有の話題が多いので1つだけに絞ります。。まあ、だいたいErlangとかやってたら自然と覚えるやつらです。&lt;/p&gt;

&lt;h2 id=&#34;document-message:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Document Message&lt;/h2&gt;

&lt;p&gt;Command MessageやEvent Messageは良く見ますが、Document Messageとはどのようなものでしょうか。原書にはこう書いてあります&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Use a Document Message to convey information to a receiver, but without indicating how the data should be used.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「受取側に情報を伝えはするが、その情報がどのように扱われるべきかを指示しない時にDocument Messageを使います」Command Messageに付随する情報でもなくEvent Messageに付随する情報でもなくただ単なる情報です。&lt;/p&gt;

&lt;p&gt;これは例えばデータベースアダプタのような所で使うことになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [db [{:id 1 :name &amp;quot;Aho&amp;quot;} {:id 2 :name &amp;quot;Ulman&amp;quot;} {:id 3 :name &amp;quot;Sethi&amp;quot;}]
      in (chan)]
  (go-loop []
    (when-let [[id return] (&amp;lt;! in)]
      (&amp;gt;! return (some #(when (= id (:id %) ) %) db))
      (recur)))

  (let [chan-cache (chan)]
    (go-loop [id 1]
      (&amp;gt;! in [id chan-cache])
      (when-let [res (&amp;lt;! chan-cache)]
        (println res)
        (recur (+ id 1))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数のアクセスがあることを考えると双方向チャネルがあるからといってそれ1つを使うのは良くないでしょう。混線してしまいます。今回は返信用のチャネル自身も一緒に送ってしまってそこにDocumentを貰うことにしました。
ActorならActor ID(Ref)を送ることになるでしょう。&lt;/p&gt;

&lt;h1 id=&#34;message-routing:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Message Routing&lt;/h1&gt;

&lt;p&gt;この章は主にAkkaのクラスタ、分散実行に関る内容です。それ自体非常に興味深いのですがClojureだと試せないので飛ばします。
まあ、実際にはクラスタを組まなくてもいくつかのactorを使ってactor群同士でやりとりをすればいいのですが準備が中々面倒ですね。&lt;/p&gt;

&lt;p&gt;一応扱われているトピックを拾うとContent Based Router, Message Filter, Dynamic Router, Recipient List, Splitter,
Aggregator, Resequencer, Composed Message Processor, Scatter-Gather, Routing-Slip, Process Manager, Message Brokerです。
見ての通り非常に数が多く、ページ数もかなり割かれています。そして、よく使いそうなパターンが多く載っています。Scatter-Gatherとか重い処理する時に使いそうなんですけどね。&lt;/p&gt;

&lt;h1 id=&#34;などなど:258416a532a86ac327ddeb3b653d90b7&#34;&gt;などなど&lt;/h1&gt;

&lt;p&gt;ここまでで、4~7章を紹介しました。原書は10章まで続きます(1-3章は何故Actorが必要なのかなどを延々語ってます)が私はこの辺で筆を置くことにします。続きが気になる方は原書をお読み下さい。&lt;/p&gt;

&lt;p&gt;Advent Calendar遅刻して大変申し分けありませんでした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustでの日本語の扱い</title>
      <link>http://keens.github.io/blog/2015/12/13/rustdenonihongonoatsukai</link>
      <pubDate>Sun, 13 Dec 2015 17:14:18 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/13/rustdenonihongonoatsukai</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar&lt;/a&gt; 14日目の記事です&lt;br /&gt;
前:gifnksmさんの &lt;a href=&#34;http://gifnksm.hatenablog.jp/entry/2015/12/13/204655&#34;&gt;kcovを使ってRustプログラムのカバレッジを測定する - gifnksmの雑多なメモ&lt;/a&gt;&lt;br /&gt;
後:nacika_insさんのtimeこわい&lt;/p&gt;

&lt;p&gt;κeenです。当初の予定より小ネタになってしまいましたがRustでの日本語の扱いについて書こうかと。&lt;/p&gt;

&lt;p&gt;ご存じの通りRustはマルチバイト文字をサポートしていますが、その殆どがUTF-8だけです。しかし日本人にはUTF-8だけでは少し辛いものがありますのでどうにかして対応しようかと。&lt;/p&gt;

&lt;p&gt;ソースコード中でもマルチバイト文字を扱えますが、UTF-8である必要があります。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rs&#34;&gt;fn main() {
  println!(&amp;quot;あああ&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをISO-2022-JPで保存してrustcに食わせても、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error: couldn&#39;t read &amp;quot;src/main.rs&amp;quot;: stream did not contain valid UTF-8
Could not compile `japanese`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と無下もないエラーが出てしまいます。&lt;/p&gt;

&lt;p&gt;内部エンコーディングにもUTF-8が使われているのでRustの文字列をUTF-8以外で出力するにはなんとなく変換が必要そうなのは理解出来ますが、変に出入力をラップしてる関数を使うとまた意図せぬエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;

fn main() {
  let file = File::open(&amp;quot;japanese.txt&amp;quot;);
  let br = BufReader::new(&amp;amp;file);
  for line in br.lines() {
    matich line {
      Ok(l) =&amp;gt; println!(&amp;quot;Ok: {}&amp;quot;, l),
      Err(e) =&amp;gt; println!(&amp;quot;{:?}&amp;quot;, e)
    };
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもまた、&lt;code&gt;stream did not contain valid UTF-8&lt;/code&gt;エラーを出します。&lt;/p&gt;

&lt;p&gt;ReadもBufReadもbyte orientedって言ってるのに何故か文字列を扱えるのが若干気になりますがまあ、そういうもんなんでしょう。&lt;/p&gt;

&lt;h1 id=&#34;encoding:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;encoding&lt;/h1&gt;

&lt;p&gt;そこで救世主となるライブラリが&lt;a href=&#34;https://github.com/lifthrasiir/rust-encoding&#34;&gt;lifthrasiir/rust-encoding&lt;/a&gt;です。文字列のエンコーディングをサポートします。
READMEに詳しい使い方が載っているのですが、このライブラリは与えられたスライスに対して指定されたエンコーディングでエンコード/デコードします。&lt;/p&gt;

&lt;p&gt;なので先の例のようにISO-2022-JPで&lt;code&gt;&amp;quot;あああ&amp;quot;&lt;/code&gt;と出力したいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use encoding::{Encoding, EncoderTrap};
use encoding::all::ISO_2022_JP;
use std::io::Stdout;

fn main() {
  let bytes = ISO_2022_JP.encode(&amp;quot;あああ&amp;quot;, EncoderTrap::Ignore);
  Stdout.write_all(&amp;amp;bytes[..]);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出来るでしょう。(即興で書いてコンパイルすらしてないので本当に出来るかは分かりませんが)&lt;/p&gt;

&lt;p&gt;読み取りに関しては…………。そう、このライブラリはバッファに対してしか動作せず、ストリームに使えないのです。提供してくれたら良さそうなのですが、作者の方が忙しいようです。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; stream encoding/decodingは計画してはいるのですが、私が忙しくてなかなか作業をすることができません&amp;hellip; orz&lt;/p&gt;&amp;mdash; Kang Seonghoon (@senokay) &lt;a href=&#34;https://twitter.com/senokay/status/666516796942319616&#34;&gt;2015, 11月 17&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;余談ですがこの方は韓国の方のようですが、日本語もある程度分かるそうです。すごいですね。&lt;/p&gt;

&lt;p&gt;さて、ストリームに対して使えないと分かったなら自分で対応するまで。幸いにも我々が使っているのはRustです。新しいものを既存の仕組みに載せるのは造作もありません。
ストリームを良い感じにデコードするには&lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Read.html&#34;&gt;std::io::Read&lt;/a&gt;を実装した何かを作れば十分です。作っていきましょう。&lt;code&gt;Read&lt;/code&gt;トレイトを実装するには最低&lt;code&gt;read&lt;/code&gt;だけ実装してしまえば十分です。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;read&lt;/code&gt;ですが、ドキュメントを読むと中々制限が緩いようです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pull some bytes from this source into the specified buffer, returning how many bytes were read.&lt;/p&gt;

&lt;p&gt;This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an Err return value.&lt;/p&gt;

&lt;p&gt;If the return value of this method is Ok(n), then it must be guaranteed that 0 &amp;lt;= n &amp;lt;= buf.len(). A nonzero n value indicates that the buffer buf has been filled in with n bytes of data from this source. If n is 0, then it can indicate one of two scenarios:&lt;/p&gt;

&lt;p&gt;This reader has reached its &amp;ldquo;end of file&amp;rdquo; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will always no longer be able to produce bytes.
   The buffer specified was 0 bytes in length.&lt;/p&gt;

&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true. It is recommended that implementations only write data to buf instead of reading its contents.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「関数が呼ばれる際に&lt;code&gt;buf&lt;/code&gt;に対しては何如なる保証もなく、呼出側はバッファの内容に対して何如なる不変条件も期待してはいけません」とあります。つまり、4096 byteのバッファが与えられても1呼び出しにつき1バイトしか返さないような実装でも許容されます。
また、非同期ベースのIOのようにキャッシュにデータがなければIOブロッキングせずにエラーだとかの挙動もありえます。非常にシステムプログラミング言語らしい仕様ですね。&lt;/p&gt;

&lt;p&gt;今から作ろうとしているデコーディングストリームも読み出したバイト列がデコード後に何バイトになるのか予測がつかないのでこの仕様は有難いですね。&lt;/p&gt;

&lt;p&gt;さて、作っていきましょうか。まずは必要そうなライブラリを読み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use self::encoding::{EncodingRef, DecoderTrap};
use std::io::Read;
use std::io;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてメインとなる構造体です。とある&lt;code&gt;Read&lt;/code&gt;を実装した型をラップする形にしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct DecodingReader&amp;lt;R&amp;gt; {
    inner: R,
    encoding: EncodingRef,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;はトレイトなので&lt;code&gt;inner&lt;/code&gt;のところを&lt;code&gt;&amp;amp;R&lt;/code&gt;としなくて大丈夫です。&lt;code&gt;Read&lt;/code&gt;の実装側が調整します。&lt;/p&gt;

&lt;p&gt;そしてコンストラクタですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; DecodingReader&amp;lt;R&amp;gt; {
    pub fn new(coding: EncodingRef, read: R)-&amp;gt; Self {
        EncodingReader {
            inner: read,
            encoding: coding
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのままですね。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;の実装です。まずは&lt;code&gt;inner&lt;/code&gt;の&lt;code&gt;read&lt;/code&gt;を呼んで、その結果を一旦デコードしてからまたバイト列に変換します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; Read for DecodingReader&amp;lt;R&amp;gt; {
    fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;usize&amp;gt;{
        // TODO set appropriate buffer size
        let len = buf.len() / 2;
        let n = try!(self.inner.read(&amp;amp;mut buf[..len]));
        // TODO don&#39;t ignore input code
        let str = self.encoding.decode(&amp;amp;mut buf[..n], DecoderTrap::Ignore).unwrap();
        let mut i = 0;
        for (d, s) in buf.iter_mut().zip(str.bytes()) {
            *d = s;
            i+=1;
            if i == 0 {
                break
            };
        }
        assert!(i &amp;lt;= buf.len());
        Ok(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程も言った通りデコード読み込んだバイト列をUTF-8にした時にどれくらいバイト数が変わるか分からないので山勘で2倍くらいに膨らむだろうとして与えられたバッファ長の半分を使います。
ここはもう少し調整が必要ですね。エンコーディング毎に適切なバッファ長を設定したい…&lt;/p&gt;

&lt;p&gt;バッファを確保出来たら&lt;code&gt;let n = try!(self.inner.read(&amp;amp;mut buf[..len]));&lt;/code&gt;してそれっぽいサイズ読み込んで、読み込んだサイズをデコードにかけます。&lt;/p&gt;

&lt;p&gt;現在&lt;code&gt;DecoderTrap&lt;/code&gt;を&lt;code&gt;Ignore&lt;/code&gt;にして&lt;code&gt;unwrap&lt;/code&gt;してますが、これは少し雑すぎますね。例えば入力が全てvalidな文字を含んでいたとしても&lt;code&gt;read&lt;/code&gt;が多バイト文字の真ん中までしか読まなかった時にそれが無効なエンコーディングと判定されて無視されるのでユーザからしたら「合ってる筈なのに何故か1文字欠損するバグ」として現れます。今回即席で作ったので勘弁して下さい。&lt;/p&gt;

&lt;p&gt;変換は文字列にしか出来ないようなので一旦文字列に落してからまたバイト列として取り出し、バッファに書き出します。デコード後のバイト列が&lt;code&gt;read&lt;/code&gt;したバイト列より小さかったら一部&lt;code&gt;read&lt;/code&gt;したデータが残ってしまいそうですが、「何如なる不変条件も…」とあるので問題ないでしょう。返り値にデコード後のバイト列の長さを返していれば良い筈です。&lt;/p&gt;

&lt;p&gt;さて、エンコードのエラーハンドリングしてないだとか本当に読み込みのバッファ長が適切なのかとかの疑問はあるものの、一応ストリームのデコーダが出来ました。使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
extern crate japanese;

use encoding::{Encoding, DecoderTrap};
use encoding::all::ISO_2022_JP;

use std::fs::File;
use std::io::BufReader;
use std::io::BufRead;
use std::str::from_utf8;
use japanese::buf::DecodingReader;


fn main() {
    let file = File::open(&amp;quot;src/japanese.txt&amp;quot;).unwrap();
    let e = DecodingReader::new(ISO_2022_JP, &amp;amp;file);
    let mut br = BufReader::new(e);
    for line in br.lines() {
        println!(&amp;quot;{}&amp;quot;, line.unwrap());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでちゃんとISO-2022-JPのファイルを読めます。&lt;/p&gt;

&lt;p&gt;Javaに慣れてる人ならこういうIOに対するデコレータパターンは見覚えがあるでしょう。&lt;/p&gt;

&lt;p&gt;今更ですがiso-2022-jpはいわゆるjisエンコーディングです。rust-encodingはshift_jisの拡張にあたるwindows31jだとかeuc-jpも扱えます(&lt;a href=&#34;https://lifthrasiir.github.io/rust-encoding/encoding/codec/japanese/index.html&#34;&gt;参考&lt;/a&gt;)。&lt;/p&gt;

&lt;h1 id=&#34;今後:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;今後&lt;/h1&gt;

&lt;p&gt;ライブラリとして公開するか、あるいは作者の方がやる気はあるようなのでプルリクを送るかが終着点かな、と思っていますが如何せん雑にしか実装してないので微妙ですね。
例の境界とマルチバイトの問題は&lt;code&gt;Read&lt;/code&gt;じゃなく&lt;code&gt;BufRead&lt;/code&gt;を要求して1文字分読み切るまで来るまで1バイトずつ読むとかになると思います。ダルい。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Rust標準だけでUTF-8以外の文字列を使うのはつらいよ&lt;/li&gt;
&lt;li&gt;Rustのエンコーディングライブラリを紹介したよ&lt;/li&gt;
&lt;li&gt;エンコーディングライブラリを使ってストリームデコーダを実装してみたよ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/japanese&#34;&gt;こちら&lt;/a&gt;にあります&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#に学ぶコンパイラ言語におけるREPLの実装方法</title>
      <link>http://keens.github.io/blog/2015/12/12/sml_nimanabukonpairagengoniokerureplnojissouhouhou</link>
      <pubDate>Sat, 12 Dec 2015 19:42:52 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/12/sml_nimanabukonpairagengoniokerureplnojissouhouhou</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装 Advent Calendar 2015&lt;/a&gt;16日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。かねてより気になっていたREPLの実装方法について、SML#のソースコードを読んだのでその話でもします。&lt;/p&gt;

&lt;p&gt;さて、ソースコードを読みながらやっていきましょう。SML# 2.0.0のソースコードです。&lt;/p&gt;

&lt;p&gt;REPLのエントリポイントは&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/compiler/main/main/SimpleMain.sml#L949&#34;&gt;src/compiler/main/main/SimpleMain.smlL949&lt;/a&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      | Interactive (options, context) =&amp;gt;
        let
          val newContext =
              Top.loadInteractiveEnv
                {stopAt = Top.NoStop,
                 stdPath = [#systemBaseDir options],
                 loadPath = nil}
                context
                (Filename.concatPath
                   (#systemBaseDir options, Filename.fromString &amp;quot;prelude.smi&amp;quot;))
          val context =
              let
                val context = Top.extendContext (context, newContext)
                val context = Top.incVersion context
              in
                context
              end
          val _ = ReifiedTermData.init (#topEnv context)
                  handle e =&amp;gt; raise e
        in
          RunLoop.interactive options context;
          SUCCESS
        end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いろいろごちゃごちゃやってますがオプションと共に&lt;code&gt;RunLoop.interactive&lt;/code&gt;を呼んでるだけです。&lt;/p&gt;

&lt;p&gt;さて、RunLoop.smlはSimpleMain.smlと同じディレクトリにあります。&lt;code&gt;interactive&lt;/code&gt;関数は次のように定義されています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun interactive options context =
      let
        ...
        val state = initInteractive ()
        fun loop context input =
            if !(#eof state) then ()
            else
              (Counter.reset();
               NameEvalEnv.intExnConList();
               case run options context input of
                 SUCCESS newContext =&amp;gt;
                 ....
               | FAILED =&amp;gt;
                 loop (Top.incVersion context) (interactiveInput state)
              )
      in
        loop context (interactiveInput state)
      end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何やら状態を初期化した後は&lt;code&gt;interactiveInput&lt;/code&gt;で得られた結果を&lt;code&gt;run&lt;/code&gt;に渡しているようです。&lt;code&gt;run&lt;/code&gt;を見ましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun run ({stdPath, loadPath, LDFLAGS, LIBS, errorOutput, llvmOptions,
            ...}:options)
          context input =
      let
        fun puts s = TextIO.output (errorOutput, s ^ &amp;quot;\n&amp;quot;)
        val options = {stopAt = Top.NoStop,
                       baseFilename = NONE,
                       stdPath = stdPath,
                       loadPath = loadPath}
        val ({interfaceNameOpt, ...}, result) =
             Top.compile options context input
             handle e =&amp;gt;
             (
               case e of
                 UserError.UserErrors errs =&amp;gt;
                 app (fn e =&amp;gt; puts (userErrorToString e)) errs
               | UserError.UserErrorsWithoutLoc errs =&amp;gt;
                 app (fn (k,e) =&amp;gt; puts (userErrorToString (Loc.noloc,k,e))) errs
               | Bug.Bug s =&amp;gt; puts (&amp;quot;Compiler bug:&amp;quot; ^ s)
               | exn =&amp;gt; raise exn;
               raise CompileError
            )
        val (newContext, module) =
            case result of
              Top.RETURN (newContext, module) =&amp;gt; (newContext, module)
            | Top.STOPPED =&amp;gt; raise Bug.Bug &amp;quot;run&amp;quot;
      in
        let
          val objfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.OBJEXT ())
          val asmfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.ASMEXT ())
          val _ = #start Counter.llvmOutputTimeCounter()
          val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile,
                                            Filename.toString asmfile)
          val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile,
                                            Filename.toString objfile)
          val _ = #stop Counter.llvmOutputTimeCounter()
          val _ = LLVM.LLVMDisposeModule module
          val sofile = TempFile.create (SMLSharp_Config.DLLEXT ())
          val ldflags =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                [&amp;quot;-Wl,-out-implib,&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
              | SMLSharp_Config.Mingw =&amp;gt;
                [&amp;quot;-Wl,--out-implib=&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
          val libfiles =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
              | SMLSharp_Config.Mingw =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
          val _ = BinUtils.link
                    {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS
                             @ ldflags,
                     libs = libfiles @ LIBS,
                     objects = [objfile],
                     dst = sofile,
                     useCXX = false,
                     quiet = not (!Control.printCommand)}
          val so = DynamicLink.dlopen&#39; (Filename.toString sofile,
                                        DynamicLink.GLOBAL,
                                        DynamicLink.NOW)
                   handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} =
              GenerateMain.moduleName (interfaceNameOpt, #version context)
          val smap = DynamicLink.dlsym&#39; (so, stackMapSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val base = DynamicLink.dlsym&#39; (so, codeBeginSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val _ = sml_register_stackmap (smap, base)
          val ptr = DynamicLink.dlsym (so, mainSymbol)
                    handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          (*
           * Note that &amp;quot;ptr&amp;quot; points to an ML toplevel code. This toplevel code
           * should be called by the calling convention for ML toplevels of
           * ML object files.  __attribute__((fastcc,no_callback)) is an ad
           * hoc way of yielding this convention code; no_callback avoids
           * calling sml_control_suspend.  If we change how to compile
           * attributes in the future, we should revisit here and update the
           * __attribute__ annotation.
           *)
          val mainFn =
              ptr : _import __attribute__((fastcc,no_callback)) () -&amp;gt; ()
        in
          loadedFiles := sofile :: !loadedFiles;
          mainFn () handle e =&amp;gt; raise UncaughtException e;
          SUCCESS newContext
        end
        handle e =&amp;gt;
          (
            case e of
              UserError.UserErrors errs =&amp;gt;
              app (fn e =&amp;gt; puts (userErrorToString e)) errs
            | UserError.UserErrorsWithoutLoc errs =&amp;gt;
              app (fn (k,e) =&amp;gt; puts (userErrorToString (Loc.noloc,k,e))) errs
            | DLError s =&amp;gt;
              puts (&amp;quot;failed dynamic linking. Perhaps incorrect name in _import declaration: &amp;quot; ^ s)
            | UncaughtException exn =&amp;gt;
              puts (&amp;quot;uncaught exception &amp;quot; ^ exnMessage exn)
            | CoreUtils.Failed {command, message} =&amp;gt;
              (puts (&amp;quot;command failed: &amp;quot; ^ command); puts message)
            | _ =&amp;gt; raise e;
            FAILED
          )
      end
      handle CompileError =&amp;gt; FAILED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デカいですね。どうやら&lt;code&gt;run&lt;/code&gt;がREPLの本体のようです。少しずつ見ていきます。&lt;/p&gt;

&lt;p&gt;まずはコンパイルしているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;        val ({interfaceNameOpt, ...}, result) =
             Top.compile options context input
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして結果からcontextとmoduleを取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;        val (newContext, module) =
            case result of
              Top.RETURN (newContext, module) =&amp;gt; (newContext, module)
            | Top.STOPPED =&amp;gt; raise Bug.Bug &amp;quot;run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恐らくcontextが変数名とかを持っているのでしょう。
moduleに関しては&lt;code&gt;Top.compile&lt;/code&gt;が最後にLLVMEmitをしてるのでLLVMのmodule(コンパイルされる最大単位)のことだと思います。だとするとここまではまだコードはメモリ上にあるはずです。&lt;/p&gt;

&lt;p&gt;moduleを取り出した後どうしてるかというとオブジェクトファイルを作っているようです。ここでファイルに書き出されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          val objfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.OBJEXT ())
          val asmfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.ASMEXT ())
          val _ = #start Counter.llvmOutputTimeCounter()
          val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile,
                                            Filename.toString asmfile)
          val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile,
                                            Filename.toString objfile)
          val _ = #stop Counter.llvmOutputTimeCounter()
          val _ = LLVM.LLVMDisposeModule module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に呼んでるDisposeModuleはデストラクタですかね。ちゃんとお片付けしてます。&lt;/p&gt;

&lt;p&gt;さらに、ダイナミックリンクファイルを作るようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val sofile = TempFile.create (SMLSharp_Config.DLLEXT ())
          val ldflags =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                [&amp;quot;-Wl,-out-implib,&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
              | SMLSharp_Config.Mingw =&amp;gt;
                [&amp;quot;-Wl,--out-implib=&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
          val libfiles =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
              | SMLSharp_Config.Mingw =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
          val _ = BinUtils.link
                    {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS
                             @ ldflags,
                     libs = libfiles @ LIBS,
                     objects = [objfile],
                     dst = sofile,
                     useCXX = false,
                     quiet = not (!Control.printCommand)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時、Windowsでは何かしらの制約があるのか過去にリンクしたダイナミックリンクファイル(libfiles)も今回作るダイナミックリンクファイルにリンクしているようです。&lt;/p&gt;

&lt;p&gt;さて、ダイナミックリンクファイルを作った後は&lt;code&gt;dlopen&lt;/code&gt;を使ってダイナミックリンクします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val so = DynamicLink.dlopen&#39; (Filename.toString sofile,
                                        DynamicLink.GLOBAL,
                                        DynamicLink.NOW)
                   handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後はエントリポイントを捜してインポート、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} =
              GenerateMain.moduleName (interfaceNameOpt, #version context)
          val smap = DynamicLink.dlsym&#39; (so, stackMapSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val base = DynamicLink.dlsym&#39; (so, codeBeginSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val _ = sml_register_stackmap (smap, base)
          val ptr = DynamicLink.dlsym (so, mainSymbol)
                    handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val mainFn =
              ptr : _import __attribute__((fastcc,no_callback)) () -&amp;gt; ()
        in
          loadedFiles := sofile :: !loadedFiles;
          mainFn () handle e =&amp;gt; raise UncaughtException e;
          SUCCESS newContext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果を印字しているところが見当らないのですが吐かれたコードに印字部分も入っているんですかね。&lt;/p&gt;

&lt;p&gt;あとは&lt;code&gt;interactive&lt;/code&gt;に返ってコンテキストを拡張したりバージョンをインクリメントしたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;                   val context = Top.extendContext (context, newContext)
                   val context = Top.incVersion context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バージョンによってシンボル名を変えることで何度もsoファイルをロードしても大丈夫なようにしてるんですかね。&lt;/p&gt;

&lt;p&gt;ということでREPLの実装は入力を一旦ダイナミックリンクとしてコンパイルしてからロードしているようでした。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:7f851921bbb9914fa0252d9b589a6af0&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;REPLの入力部分は次のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;
  fun initInteractive () =
      let
        val lineCount = ref 1
        val eof = ref false
        fun read (isFirst, _:int) =
            let
              val prompt = if isFirst then &amp;quot;# &amp;quot; else &amp;quot;&amp;gt; &amp;quot;
              val _ = TextIO.output (TextIO.stdOut, prompt)
              val _ = TextIO.flushOut TextIO.stdOut
              val line = TextIO.inputLine TextIO.stdIn
              val _ = lineCount := !lineCount + 1
            in
              case line of NONE =&amp;gt; (eof := true; &amp;quot;&amp;quot;) | SOME s =&amp;gt; s
            end
      in
        {lineCount = lineCount, eof = eof, read = read}
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結構小さいので色々Hack出来ます。例えば&lt;a href=&#34;https://github.com/smlsharp/smlsharp/pull/13&#34;&gt;hskさんのように&lt;/a&gt;REPLを付けることも出来ます。&lt;/p&gt;

&lt;p&gt;このパッチで外部コマンドを呼ぶのが少し嫌な人はさらに&lt;code&gt;ioctl(2)&lt;/code&gt;を使ってrawモードにするパッチを当てるかlibeditなんかを使ってリッチな入力を実現するかをすればいいでしょう。
個人利用なら(他人に配布しないなら)GPLv3のreadlineも使えるんですかね（ライセンスに詳しくない）。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:7f851921bbb9914fa0252d9b589a6af0&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;REPLの実装にはダイナミックリンクを使う方法があるよ&lt;/li&gt;
&lt;li&gt;SML#のREPLはHack出来そうだよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#でJITコンパイラを作る軽い話</title>
      <link>http://keens.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi</link>
      <pubDate>Sat, 12 Dec 2015 17:26:24 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/848&#34;&gt;ML Advent Calendar 2015&lt;/a&gt;及び&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装 Advent Calendar 2015&lt;/a&gt;15日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。先日流れてきた&lt;a href=&#34;http://www.jonathanturner.org/2015/12/building-a-simple-jit-in-rust.html&#34;&gt;RustでJITコンパイラを作る話&lt;/a&gt;が面白かったのでSML#でもやってみます。&lt;/p&gt;

&lt;h1 id=&#34;jitコンパイラってなに:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;JITコンパイラってなに？&lt;/h1&gt;

&lt;p&gt;JITはJust In Timeで、日本語にすると「間に合って」になります。誤読されかねませんが「臨時コンパイラ」と訳すのが適当なのでしょうか。&lt;/p&gt;

&lt;p&gt;普通のインタプリタがソースコードを直接評価するのに対してJITコンパイラはソースコードを内部で一旦ネイティブコードにコンパイルして実行します。&lt;/p&gt;

&lt;p&gt;よく、JITコンパイラ/JITコンパイルのことをJITと略して呼びます。&lt;/p&gt;

&lt;h1 id=&#34;どこで使うの:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;どこで使うの？&lt;/h1&gt;

&lt;p&gt;主に、インタプリタの高速化の目的で使われるようです。他にはコンパイラをインタプリタ化させる(REPLの実装とか)でも使えそうな気がしますが、詳しくは知りません。&lt;/p&gt;

&lt;h1 id=&#34;jitってどうやって作るの:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;JITってどうやって作るの？&lt;/h1&gt;

&lt;p&gt;JIT &lt;strong&gt;でない&lt;/strong&gt; コンパイラが吐いたコードは一旦ディスクからメモリに読まれ、メモリ上で実行されます。&lt;/p&gt;

&lt;p&gt;JITコンパイラが吐くコードは直接メモリに吐かれ、メモリ上で実行されます。なので細かい条件を無視すれば&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;吐かれる命令のための(特殊な)メモリ領域を用意する&lt;/li&gt;
&lt;li&gt;そこに実行したい命令列を書き込む&lt;/li&gt;
&lt;li&gt;書き込んだ命令列を実行する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;だけです。
3.の「書き込んだ命令を実行する」が若干ふわっとしてますが、多くの場合は命令の書かれたメモリを関数ポインタとして扱って、その関数を呼び出す形で実行されます。
一応直接プログラムカウンタをいじって書き込んだ命令列を実行させることも出来ます。&lt;/p&gt;

&lt;h1 id=&#34;一緒に作ってみよう:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;一緒に作ってみよう&lt;/h1&gt;

&lt;p&gt;思ったより簡単そうですね。作ってみましょう。&lt;/p&gt;

&lt;h2 id=&#34;1-メモリ領域を準備する:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;1. メモリ領域を準備する&lt;/h2&gt;

&lt;p&gt;先に「特殊な」と付言しましたのでそれについて説明しましょう。プロセス上のメモリは、OSによって保護されています。
特に、そのままではそのメモリ上の命令列を実行出来ません。その保護を外すために&lt;code&gt;mprotect(2)&lt;/code&gt;システムコールを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int mprotect(void *addr, size_t len, int prot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SML#を使えば簡単に使えるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val mprotect = _import &amp;quot;mprotect&amp;quot;: (unit ptr, word, word) -&amp;gt; int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SML#は2.0.0時点では32bitでしか動かないのでsize_tをwordとしてしまって大丈夫です。また、bit演算をやりたいので&lt;code&gt;prot&lt;/code&gt;は本来はintですがwordにしました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mprotect(2)&lt;/code&gt;はPOSIX(SUSv4)的には引数の&lt;code&gt;addr&lt;/code&gt;がシステムのページの境界上にあることを要求しても良いことになっています。
実際、OS Xが要求するらしいです。また、メモリ保護はページ単位で行われるため、&lt;code&gt;len&lt;/code&gt;もページサイズの倍数である必要があります。
&lt;code&gt;prot&lt;/code&gt;は保護フラグですね。&lt;/p&gt;

&lt;p&gt;メモリの確保、特にページの境界にアラインメントされたメモリ領域を確保するにはSML#では厳しそうなのでこれもCの関数に頼ります。
Linuxならいくつか方法はありますが、ポータブルには&lt;code&gt;posix_memalign(3)&lt;/code&gt;を使うのが良いようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int posix_memalign(void **memptr, size_t alignment, size_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもSML#から簡単に使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val posix_memalign = _import &amp;quot;posix_memalign&amp;quot;: (unit ptr ref, word, word) -&amp;gt; int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにメモリの解放も必要ですね。&lt;code&gt;free(3)&lt;/code&gt;もインポートしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val free = _import &amp;quot;free&amp;quot;: unit ptr -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、メモリを確保するのにいくつかCのマクロで定義された定数を定義しましょう。今のところSML#にCのマクロを使う術はなさそうです。どうにかしてCプリプロセッサを使えれば良いのですが…。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val PROT_READ  = 0wx1
val PROT_WRITE = 0wx2
val PROT_EXEC  = 0wx4
val PROT_NONE  = 0wx0

val PAGE_SIZE = 0w4096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ページサイズは本当は&lt;code&gt;sysconf(3)&lt;/code&gt;を使って&lt;code&gt;sysconf(PAGESIZE)&lt;/code&gt;として取るのが作法ですが面倒なので4KiB決め打ちにしてしまいました。&lt;/p&gt;

&lt;p&gt;さて、これらを用いてJIT用のメモリは次のように確保します。&lt;code&gt;Pointer&lt;/code&gt;モジュールが必要なのでsmiファイルで&lt;code&gt;require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt;しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val op orb = Word.orb
infix 5 orb
val size = 0wx1
val msize = size * PAGE_SIZE
val pageRef: unit ptr ref = ref (Pointer.NULL ())
val ret = posix_memalign (pageRef, PAGE_SIZE, msize)
val page = if ret = 0
           then !pageRef
           else raise Fail &amp;quot;memory allocation failed&amp;quot;
val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC
val ret = mprotect (page, msize, PROT_RWEX)
val () = if ret = 0
         then ()
         else raise Fail &amp;quot;memory protection error&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;page&lt;/code&gt;に実行可能フラグが立ったメモリが確保出来ました。sizeは書き込みたい命令列に応じて変えます。&lt;/p&gt;

&lt;h1 id=&#34;2-命令列を書き込む:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;2. 命令列を書き込む&lt;/h1&gt;

&lt;p&gt;さて、ここらへんからアセンブラの世界になってきます。&lt;/p&gt;

&lt;p&gt;まず、安全のために件のメモリ領域を&lt;code&gt;ret&lt;/code&gt;命令で埋めます。
&lt;code&gt;ret&lt;/code&gt;命令は関数から戻る時に使われる命令で、変なことをしても&lt;code&gt;ret&lt;/code&gt;で元の場所に戻ればどうにかなる可能性があるのです。&lt;/p&gt;

&lt;p&gt;メモリを一気に埋めるには&lt;code&gt;memset(3)&lt;/code&gt;が便利です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void *memset(void *s, int c, size_t n);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをSMLにインポートして使いましょう。&lt;code&gt;ret&lt;/code&gt;命令に対応するマシン語は&lt;code&gt;0xc3&lt;/code&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val memset = _import &amp;quot;memset&amp;quot;: (unit ptr, word, word) -&amp;gt; unit ptr
val _ = memset (page, 0wxc3, msize)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃあ、命令を書き込んでいきましょう。最初はただ1を返すだけの関数に相当する命令です。
64bitマシンを使っていても32bitでコンパイルしたSML#を使っている限りはx86(IA32)のアセンブラを使います。
x86は値を&lt;code&gt;eax&lt;/code&gt;レジスタに入れることで返り値とします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;mov 1 eax
ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードを&lt;a href=&#34;https://defuse.ca/online-x86-assembler.htm#disassembly&#34;&gt;オンラインアセンブラ&lt;/a&gt;でアセンブルしてみると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0:  b8 01 00 00 00          mov    eax,0x1
5:  c3                      ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;との結果が返ってきました。これを真心込めて1つづつメモリに書き込んでいきます。
SML#からメモリに直接書き込むには内部APIっぽいものを触る必要があります。
タイプ数を減らすためにいくつかエイリアスを定義しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
val store = Pointer.store
val advance = Pointer.advance
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メモリにword8の値を書き込むのにキャストが必要になるので&lt;code&gt;fromUnitPtr&lt;/code&gt;を使います。
さて、書き込んでいきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val mem: word8 ptr = fromUnitPtr page
val () = store page 0wxb8
val mem = advance mem
val () = store page 0wx01
val mem = advance mem
val () = store page 0wx00
val mem = advance mem
val () = store mem 0wx00
val mem = advance mem
val () = store mem 0wx00
val mem = advance mem
val () = store mem 0wxc3
val _ = advance mem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;page&lt;/code&gt;に1を返すだけの命令列が書き込まれした。&lt;/p&gt;

&lt;h2 id=&#34;3-書き込んだ命令列を実行する:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;3. 書き込んだ命令列を実行する&lt;/h2&gt;

&lt;p&gt;書き込んだ命令列は関数にキャストして使うことが多いと言いました。今回もそのようにします。&lt;/p&gt;

&lt;p&gt;そのために、また内部APIっぽいものを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;codeptr&lt;/code&gt;型は関数ポインタを表すもののようです。&lt;code&gt;DynamicLink&lt;/code&gt;モジュールなどで使われています。&lt;/p&gt;

&lt;p&gt;さて、今回の1を返すだけの命令列は&lt;code&gt;() -&amp;gt; int&lt;/code&gt;型になりますね。
それをインポート、実行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val freturn1 = toCodePtr page: _import () -&amp;gt; int
val () = print ((Int.toString (freturn1 ())) ^ &amp;quot;\n&amp;quot;)
val _ = free page
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで見事&lt;code&gt;1&lt;/code&gt;が印字されたら成功です。&lt;/p&gt;

&lt;h1 id=&#34;さらに:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;さらに&lt;/h1&gt;

&lt;p&gt;先程のコードは繰り返しが多く、整理されていませんでした。もう少し整理しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure Emit = struct
    val posix_memalign = _import &amp;quot;posix_memalign&amp;quot;: (unit ptr ref, word, word) -&amp;gt; int
    val mprotect = _import &amp;quot;mprotect&amp;quot;: (unit ptr, word, word) -&amp;gt; int
    val memset = _import &amp;quot;memset&amp;quot;: (unit ptr, word, word) -&amp;gt; unit ptr
    val free = _import &amp;quot;free&amp;quot;: unit ptr -&amp;gt; ()
    val printf = _import &amp;quot;printf&amp;quot;: (string, unit ptr) -&amp;gt; ()

    (* 
#define PROT_READ	0x1		/* Page can be read.  */
#define PROT_WRITE	0x2		/* Page can be written.  */
#define PROT_EXEC	0x4		/* Page can be executed.  */
#define PROT_NONE	0x0		/* Page can not be accessed.  */
    *)

    val PROT_READ  = 0wx1
    val PROT_WRITE = 0wx2
    val PROT_EXEC  = 0wx4
    val PROT_NONE  = 0wx0

    val PAGE_SIZE = 0w4096

    type jitptr = word8 ptr
    val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
    val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr
    val toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr
    val store = Pointer.store
    val advance = Pointer.advance


    fun jitMemory size: jitptr = let
        val op orb = Word.orb
        infix 5 orb
        val msize = size * PAGE_SIZE
        val pageRef: unit ptr ref = ref (Pointer.NULL ())
        val ret = posix_memalign (pageRef, PAGE_SIZE, msize)
        val page = if ret = 0
                   then !pageRef
                   else raise Fail &amp;quot;memory allocation failed&amp;quot;
        val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC
        val ret = mprotect (page, msize, PROT_RWEX)
        val () = if ret = 0
                 then ()
                 else raise Fail &amp;quot;memory protection error&amp;quot;
        (* init with ret for safety *)
        val _ = memset (page, 0wxc3, msize)
    in
        fromUnitPtr page
    end

    fun freeJit (jitMem: jitptr) = free (SMLSharp_Builtin.Pointer.toUnitPtr jitMem)

    fun pushWord page (word: word8) = (store (page, word); advance (page, 1))
    fun pushWords (page: jitptr) l = List.foldl (fn(w,page) =&amp;gt; pushWord page w) page l

    val import: jitptr -&amp;gt; codeptr = toCodeptr o toUnitPtr

    fun fromMachineCode l = let
        val len = Word.fromInt(List.length l)
        val size = (len + PAGE_SIZE) div PAGE_SIZE
        val page = jitMemory size
        val _ = pushWords page l
    in
        import page
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のように使います。一回importした関数はfreeしないことにしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun println x = print (x ^ &amp;quot;\n&amp;quot;)
val return1  =
    (* 0:  b8 01 00 00 00          mov    eax,0x1  *)
    [
      0wxb8, 0wx01, 0wx00, 0wx00, 0wx00
    ] 
val freturn1 = Emit.fromMachineCode return1 :_import () -&amp;gt; int
val () = println (Int.toString (freturn1 ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引数を取る:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;引数を取る&lt;/h2&gt;

&lt;p&gt;もうアセンブラの話になります。&lt;/p&gt;

&lt;p&gt;x86では引数は右から順にスタックに積まれます。intを1つ取ってそれに1足して返す関数はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val add1 = 
    (* 0:  8b 44 24 04             mov    eax,DWORD PTR [esp+0x4] *)
    (* 4:  83 c0 01                add    eax,0x1 *)
    [
      0wx8b, 0wx44, 0wx24, 0wx04,
      0wx83, 0wxc0, 0wx01
    ]
val fadd1 = Emit.fromMachineCode add1 :_import (int) -&amp;gt; int
val () = println (Int.toString (fadd1 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常に動けば4が印字されます。&lt;/p&gt;

&lt;h1 id=&#34;つらい話:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;つらい話&lt;/h1&gt;

&lt;h2 id=&#34;バグ:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;バグ&lt;/h2&gt;

&lt;p&gt;最初、&lt;code&gt;Pointer.store&lt;/code&gt;でなく、&lt;code&gt;SMLSharp_Builtin.Pointer.store&lt;/code&gt;を使っていたら&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/43&#34;&gt;変なバグ&lt;/a&gt;踏みました。バグというか使い方が悪かった。&lt;/p&gt;

&lt;h2 id=&#34;デバッグ:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;デバッグ&lt;/h2&gt;

&lt;p&gt;デバッガがないので非常につらいです。書き出された命令列を見るのに困りました。gdbで見たかったので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val printf = _import &amp;quot;printf&amp;quot;: (string, unit ptr) -&amp;gt; int
val _ = pritnf (&amp;quot;page pointr: %p&amp;quot;, page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;して&lt;code&gt;printf&lt;/code&gt;にブレークポイントを張り、そこで止めつつページのアドレスを取得、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;(gdb) x/20xh 0x81ca000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとして見ていました。&lt;/p&gt;

&lt;h1 id=&#34;もっと:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;もっと&lt;/h1&gt;

&lt;p&gt;JITコンパイラが楽しかったのでアセンブラのDSLを作ってみました。1、2個の命令吐けるだけですがちゃんと動きました。今のところこのように書けます。Intel記法だとしんどそうだったのでAT&amp;amp;T記法っぽく書けるようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val freturn1&#39; = Emit.fromInsts [
        xorl eax eax,
        addl ($1) eax,
        ret
    ]:_import () -&amp;gt; int
val () = println (Int.toString (freturn1&#39; ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x86は命令フォーマットが1バイトから15バイトまでの可変長で、内部表現をどのようにするか決めるだけでも一苦労でした。x86つらい。&lt;/p&gt;

&lt;p&gt;アドレッシングが複雑なのも悩みどころで、複数のアドレッシングを統一的に扱えるようにオーバーロードされた関数を用意したのですがあえなくSML#のバグを踏んで死亡しました。本当はこういう記法が出来る筈だった…&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;addl (%eax) eax
addl eax (%eax)
addl eax (%(eax, ebx))
addl eax (%(eax, ebx, 4))
addl eax (%(4, eax))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/bin/smlsharp   -c -o main.o main.sml
uncaught exception: Bug.Bug: InferType: FIXME: user error: invalid instTy at src/compiler/typeinference2/main/InferTypes2.sml:47
Makefile:11: recipe for target &#39;main.o&#39; failed
make: *** [main.o] Error 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;movl&lt;/code&gt;を実装しようとしたらアドレッシングが動かなかったので萎えてまだ実装してません。&lt;/p&gt;

&lt;p&gt;よく考えたら&lt;code&gt;%&lt;/code&gt;ってミスリーディングだし名前変えよう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;JITを作るにはメモリ保護をいじれて関数ポインタのインポートが出来ればいいよ&lt;/li&gt;
&lt;li&gt;SML#でもJIT作れるよ&lt;/li&gt;
&lt;li&gt;アセンブラっぽいの作ったよ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/smljit&#34;&gt;こちら&lt;/a&gt;にあります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>リージョンについて</title>
      <link>http://keens.github.io/blog/2015/12/09/ri_jonnitsuite</link>
      <pubDate>Wed, 09 Dec 2015 22:16:50 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/09/ri_jonnitsuite</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装Advent Calendar 2015&lt;/a&gt; 10日目の記事です&lt;/p&gt;

&lt;p&gt;κeenです。今日はある程度gcに頼らずメモリを管理する手法、リージョンについて話そうと思います。
リージョン推論とそのアルゴリズムまで話せればよかったのですがサーベイが間に合わず…&lt;/p&gt;

&lt;h1 id=&#34;スタックベースのメモリ管理:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;スタックベースのメモリ管理&lt;/h1&gt;

&lt;p&gt;gcのない言語、例えばcでも自動で解放される類のメモリがあります。ローカル変数です。&lt;/p&gt;

&lt;p&gt;ローカル変数のメモリ確保/解放戦略は単純です。ブロックの開始に確保され、ブロックの終わりに解放されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{
  int x;         // &amp;lt;- xが確保される
  {
    int y = 2;   // &amp;lt;- yが確保される
    {
      int z = 3; // &amp;lt;- zが確保される
      x = y + z;
    }            // &amp;lt;- zが解放される
  }              // &amp;lt;- yが解放される
}                // &amp;lt;- xが解放される
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ブロックはネスト構造をとるのでメモリ管理はスタックがあれば十分で、概念としても実装としても非常にシンプルです。&lt;/p&gt;

&lt;p&gt;しかしシンプルな一方で柔軟性に欠ける部分もあります。
初心者の時に次のようなコードを書いてコンパイラに怒られた、あるいはバグらせたことは誰しもあるのではないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{
  int i;
  int *x;
  {
    int y[5] = {1, 2, 3, 4, 5};
    x = y + 1; 
  }     // &amp;lt;- yに割り当てられたメモリはここで解放されるため、外のブロックにあるxで参照出来ない
  for(i = 0; i &amp;lt; 4; ++i) {
    printf(&amp;quot;%i\n&amp;quot;, x[i]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとわざとらしい例ですがこのようにブロック内で確保されたメモリが必ずブロックが終わった時に解放されるのは嬉しくないケースがあります。&lt;/p&gt;

&lt;h1 id=&#34;リージョン:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;リージョン&lt;/h1&gt;

&lt;p&gt;リージョンはブロックと基本的には同じ考え方です。リージョンの開始でメモリが準備され、リージョンの終わりでメモリが解放される。そしてリージョンは入れ子構造を作る。
リージョンとブロックの違いはリージョンには名前があることと、メモリを割り当てる時にどのリージョンに置くかを指定できることです。&lt;/p&gt;

&lt;p&gt;リージョンについて説明するためにml風の小さな言語で説明しましょう。この言語にgcはありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;let
  x = [1, 2, 3]
in
  let
    l = let
      y = append ([4, 5], x)
    in
      y
    end 
  in
    len l
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコープによるメモリ管理を考えてみましょう。&lt;code&gt;y&lt;/code&gt;について考えます。先程の考え方でいくと一番内側のスコープで作られた&lt;code&gt;y&lt;/code&gt;はスコープの外まで生きていないので&lt;code&gt;l&lt;/code&gt;に渡すのは不正です。
これはつらいですね。代入を許さない言語だと値を返せなくなります。&lt;/p&gt;

&lt;p&gt;次に、リージョンを導入してみます。リージョンを作る構文として、&lt;code&gt;letregion&lt;/code&gt;を導入します。&lt;/p&gt;

&lt;p&gt;リージョン&lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;r2&lt;/code&gt;を導入するには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;letregion r1, r2 in
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きます。そしてリージョン&lt;code&gt;r1&lt;/code&gt;に&lt;code&gt;[1, 2, 3]&lt;/code&gt;をアロケートするには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;[1, 2, 3] at r1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きます。また、関数&lt;code&gt;f&lt;/code&gt;の返り値をリージョン&lt;code&gt;r1&lt;/code&gt;にアロケートするには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;f[r1] args ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きます。今回端折り気味の説明なのでこの記法の詳細は後回しにします。&lt;/p&gt;

&lt;p&gt;リージョンとこの記法を導入した時に、先程の何がしたいのか分からないプログラムは次のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;letregion r1, r2 in
  let
    x = [1, 2, 3] at r1
  in
    letregion r3, r4 in
      let
        l = let
          letregion r5 in
            y = append[r3] (([4, 5] at r4, x) at r5)
          end
        in
          y
        end 
      in
        len[r2] l
      end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このプログラムはちゃんと齟齬なく値を渡せていて、アロケートしたメモリも全て解放されています。
リージョンを導入することでこのような小さなプログラムならgc無しでもメモリ管理が出来るようになりました。
特に、このプログラムのメモリ管理は静的です。つまりメモリをアロケートする箇所と解放する箇所がコンパイル時に決定します。&lt;/p&gt;

&lt;h1 id=&#34;リージョンと関数:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;リージョンと関数&lt;/h1&gt;

&lt;p&gt;先程までは値の計算だけでした。今度は関数を定義してみましょう。
関数は返り値をどこかに返さないといけないので返り値の置き場となるリージョンを外から与える必要があります。
ということで関数はリージョンパラメータを取ります。先程の関数を返り値のリージョンを指定する構文は厳密には関数にリージョンを渡していた訳です。&lt;/p&gt;

&lt;p&gt;試しに&lt;code&gt;append&lt;/code&gt;を定義してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;letlec append[r1] p =
  let (xs, ys) = p
  in case xs of
      nil =&amp;gt; ys
    | x::xs&#39; =&amp;gt; (x::letregion r2 in
      (append[r1] ((xs&#39;, ys) at r2))
    end at r1)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数&lt;code&gt;append&lt;/code&gt;はリージョン&lt;code&gt;r1&lt;/code&gt;とタプル&lt;code&gt;p&lt;/code&gt;を受け取って、&lt;code&gt;r1&lt;/code&gt;にアロケートされた値を返します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(xs&#39;, ys)&lt;/code&gt;のように&lt;code&gt;append&lt;/code&gt;の呼び出しのためだけに作られたタプルは短命な&lt;code&gt;r2&lt;/code&gt;にアロケートしつつ、再帰呼び出しの&lt;code&gt;app&lt;/code&gt;の返り値は
関数全体の返り値の一部になるので&lt;code&gt;r1&lt;/code&gt;にアロケートしています。&lt;/p&gt;

&lt;p&gt;このように、リージョンさえなければ普通のmlと変わらないのにgcに頼らずメモリ管理が出来ています。&lt;/p&gt;

&lt;h1 id=&#34;リージョン推論:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;リージョン推論&lt;/h1&gt;

&lt;p&gt;さてさて、先程リージョンなしのml言語にリージョンを導入することでメモリを静的に管理出来ました。しかしリージョンを手で指定していくのは中々つらいものがあります。ということでリージョンをコンパイラで勝手に推論してしまおうというのがリージョン推論です。&lt;/p&gt;

&lt;p&gt;リージョン推論を導入することで今までgcでメモリを管理していたのをある程度静的に管理することが出来ます。
リージョン推論のアルゴリズムは冒頭で述べたようにサーベイが間に合いませんでした。&lt;/p&gt;

&lt;p&gt;sml処理系の&lt;a href=&#34;http://www.elsman.com/mlkit/&#34;&gt;ml kit&lt;/a&gt;はリージョン推論を導入することでgcをほとんど無くし、リアルタイム性に優れる処理系になりました。
先程から「ほとんど」といっているのは既存のプログラミング言語だとリージョンを綺麗に割り当てることが出来なくてほとんどのオブジェクトがトップレベルリージョンに推論されてしまい、あまり意味がなくなってしまうからだとか。丁度動的型付き言語に型推論を入れてもほとんどobject型になってしまうのと同じような話なんですかね。&lt;/p&gt;

&lt;h1 id=&#34;発展的話題:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;発展的話題&lt;/h1&gt;

&lt;h2 id=&#34;リージョンサイズ解析:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;リージョンサイズ解析&lt;/h2&gt;

&lt;p&gt;今まで、リージョンによるメモリの確保/解放については話してきましたが確保するサイズについては触れてきませんでした。
簡単には&lt;code&gt;malloc&lt;/code&gt; &lt;code&gt;realloc&lt;/code&gt; &lt;code&gt;free&lt;/code&gt;相当の機能を考えれば済むのですが、例えばコンパイル時点で最大確保サイズが分かっているのなら
コールスタックに載せて確保/解放を高速化することが出来ます。&lt;/p&gt;

&lt;p&gt;そのコンパイル時に出来るだけリージョンの最大サイズを判明させようというのがリージョンサイズ解析です。&lt;/p&gt;

&lt;h2 id=&#34;線形-アフィン型:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;線形/アフィン型&lt;/h2&gt;

&lt;p&gt;線形型は全てのリソースに対が必ず丁度1回消費されることを要求する型システムです。必ず消費されるのでメモリの解放が必ず行われることを型レベルで保障します。そして最大1回しか消費されないので他者が同じリソースを触って大惨事になるデータ競合を防ぐことが出来ます。
しかし推論は完全には出来ず、ユーザがちょくちょく整合性が取れていることの証明を書く必要があります。&lt;a href=&#34;http://www.ats-lang.org/&#34;&gt;ATS2&lt;/a&gt;は線形型を持っており、厳密なリソース管理が出来ます。&lt;/p&gt;

&lt;p&gt;アフィン型は線形型よりは少し緩い型システムで、リソースが最大でも1回しか消費されないことを要求します。メモリなどの管理は出来ませんがデータ競合を防ぐことは出来ます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt;はアフィン型を導入してるらしいです。多分所有権回りの話なんでしょう。リージョンも導入してるらしいです。生存期間回りの話なんでしょう。&lt;/p&gt;

&lt;p&gt;余談ですがリージョンとアフィン型の関係を調べようとしたら画像の特定領域に台形変換を掛ける話しかヒットしませんでした。ググラビリティ低い…&lt;/p&gt;

&lt;h1 id=&#34;まとめ:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;リージョンについて話した&lt;/li&gt;
&lt;li&gt;リージョン推論のアルゴリズムについては話さなかった&lt;/li&gt;
&lt;li&gt;リージョン以外にもリソースを管理する方法はあるよ&lt;/li&gt;
&lt;li&gt;みんなRust使おう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;全然理解が追い付かないまま期限が来て半知半解で書いてるので詳しい方&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;κeen&lt;/a&gt;までツッコみお願いします。&lt;/p&gt;

&lt;h1 id=&#34;参考文献:cc7b79e9bf38410840bdd39e0a1f3096&#34;&gt;参考文献&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.elsman.com/mlkit/pdf/ismm98.pdf&#34;&gt;A Brief Introduction to Regions&lt;/a&gt; 今回の記事はこの論文の内容をかい摘んで書いてある。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://melsman.github.io/mlkit/pdf/popl94.pdf&#34;&gt;Implementation of the Typed Call-by-value lambda-calculus using a Stack of Regions&lt;/a&gt; (多分)リージョンの初出論文&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://melsman.github.io/mlkit/pdf/toplas98.pdf&#34;&gt;A Region Inference Algorithm&lt;/a&gt; リージョン推論のアルゴリズム。70ページある…&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.elsman.com/mlkit/papers.html&#34;&gt;ML Kitの論文たち&lt;/a&gt; ここに色々論文ある。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SML#でDBに接続</title>
      <link>http://keens.github.io/blog/2015/12/05/sml_dedbnisetsuzoku</link>
      <pubDate>Sat, 05 Dec 2015 22:04:25 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/05/sml_dedbnisetsuzoku</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/848&#34;&gt;ML Advent Calendar&lt;/a&gt;6日目の記事です。&lt;br /&gt;
次はdico_leque先生で、「ML中心にしつつ何か」です。&lt;/p&gt;

&lt;p&gt;κeenです。SMl#はDB接続及びSQLを言語レベルでサポートしていることが大きな特徴ですが詳細な方法についてはあまり情報がなく、
実際に利用するのは難しい状況にあります。そこで私がなんとかソースコードを読んで得られた知識を少し共有したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;接続サーバ設定:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続サーバ設定&lt;/h1&gt;

&lt;p&gt;DBへの接続サーバ設定には&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_sqlserver serverLocation : τ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;式を使います。このserverLocationはDB毎に指定方法が異なります。公式のドキュメントにはデフォルトDBであるPostgreSQLへの接続方法しか書かれていませんが、いくつかのDBをサポートします。&lt;/p&gt;

&lt;p&gt;SML#はDB接続時にテーブルの型を要求します(上でいう型注釈の&lt;code&gt;τ&lt;/code&gt;がそれです。文法的に型注釈がないといけません。)。今回の例では公式ドキュメントにある通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE mydb;
CREATE TABLE Persons (
  name text not null,
  age int not null,
  salary int not null
);
USE mydb;
INSERT INTO Persons VALUES (&#39;Joe&#39;, 21, 10000);
INSERT INTO Persons VALUES (&#39;Sue&#39;, 31, 20000);
INSERT INTO Persons VALUES (&#39;Bob&#39;, 41, 30000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で作ったDBへ接続することにします。&lt;/p&gt;

&lt;h2 id=&#34;テーブルの型:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;テーブルの型&lt;/h2&gt;

&lt;p&gt;深追いしてないので分かりません。とりあえず今回使う&lt;code&gt;mydb&lt;/code&gt;は&lt;code&gt;{Persons:{name:string, age:int, salary :int}&lt;/code&gt;で接続出来るみたいです。これも追わねば…&lt;/p&gt;

&lt;p&gt;一応ソースを読む限りだとint, decimal, real32, float, real, string, bool, timestampがあるようです。NULLableなカラムにはoptionを使うようです。&lt;/p&gt;

&lt;p&gt;SMLで見慣れないdecimal, float, timestampはSML#が実装を持っているようです。&lt;/p&gt;

&lt;p&gt;float, decimalは内部表現は文字列で、文字列との相互及びrealとIEEERealへの変換が出来るようです。&lt;/p&gt;

&lt;p&gt;timestampは文字列との相互変換及び&lt;code&gt;now()&lt;/code&gt;関数, &lt;code&gt;defaultTimestamp&lt;/code&gt;が存在します(スキーマに&lt;code&gt;DEFAULT&lt;/code&gt;指定があった時用)。内部表現はunix timeなのか、intです。&lt;/p&gt;

&lt;p&gt;それぞれ&lt;code&gt;SQL.Float&lt;/code&gt;, &lt;code&gt;SQL.Decimal&lt;/code&gt;, &lt;code&gt;SQL.TimeStamp&lt;/code&gt;モジュールに入っています。&lt;/p&gt;

&lt;h2 id=&#34;postgresql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;PostgreSQL&lt;/h2&gt;

&lt;p&gt;デフォルト設定のpgのmydbというDBへ接続したいならこれで接続出来ると公式ドキュメントに書いてあるのですが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (dbname=&amp;quot;mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと最後の &lt;code&gt;}&lt;/code&gt;が1つ抜けている上、それを補っても&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(interactive):2.27-2.32 Error: (name evaluation &amp;quot;190&amp;quot;) unbound variable: dbname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と返してきます。正しくは(?)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。他のパラメータ、例えばホストやポート、パスワードを渡したい場合はスペース区切で渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb host=localhost password=hogehoge&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この文字列はそのままPostgreSQLの&lt;a href=&#34;http://www.fireproject.jp/feature/postgresql/programing_libpq/connect.html#2&#34;&gt;&lt;code&gt;PGconnectdb&lt;/code&gt;&lt;/a&gt;という関数に渡っているのでそのドキュメントに完全な受付可能なキーが書いてあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host: DBサーバ名&lt;/li&gt;
&lt;li&gt;hostaddr: DBサーバのIPアドレス&lt;/li&gt;
&lt;li&gt;user: DB接続時のユーザ名&lt;/li&gt;
&lt;li&gt;password: userに対するパスワード&lt;/li&gt;
&lt;li&gt;dbname: DB名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とのことです。&lt;/p&gt;

&lt;h2 id=&#34;mysql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;MySQL&lt;/h2&gt;

&lt;p&gt;ドキュメントはありませんがソースコードを読んである程度勘を効かせた上で色々書いて試行錯誤すれば接続方法は分かります。&lt;/p&gt;

&lt;p&gt;MySQLに接続するには以下のように&lt;code&gt;SQL.mysql&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = _sqlserver (SQL.mysql &amp;quot;dbname=mydb&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余談ですが&lt;code&gt;_sqlserver&lt;/code&gt;はオーバーロードされていて、backend型とstring型両方を受け付けます。
文字列が来た時には&lt;code&gt;SQL.default&lt;/code&gt;に渡されます。そして &lt;code&gt;val default = postgresql&lt;/code&gt;です。つまり、PostgreSQLの例は&lt;code&gt;_sqlserver (SQL.postgresql &amp;quot;dbname=mydb&amp;quot;)&lt;/code&gt;
としているのと同じです。&lt;/p&gt;

&lt;p&gt;閑話休題。MySQLの時に渡せるパラメータの話をしましょう。こちらはバックエンドの接続関数にそのまま渡してる訳ではないのですが、
SML#側でパーサを持っているのでPostgreSQLの時のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;SQL.mysql &amp;quot;dbname=mydb host=localhost&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで使えるキーは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val availableKeys = [&amp;quot;host&amp;quot;, &amp;quot;port&amp;quot;, &amp;quot;user&amp;quot;, &amp;quot;password&amp;quot;, &amp;quot;dbname&amp;quot;, &amp;quot;unix_socket&amp;quot;, &amp;quot;flags&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義されています&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。因みにこれはパースエラーにならない文字列の集合であって、&lt;code&gt;unix_socket&lt;/code&gt;を使おうとするとコネクションエラーになるようです(&lt;code&gt;raise Connect &amp;quot;unix_socket is not supported&amp;quot;&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;文法に関して深掘りすると、一応パーサ(&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/KeyValuePair.sml&#34;&gt;src/sql/main/KeyValuePair.sml&lt;/a&gt;)を読む限りだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;keyは &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;(&lt;code&gt;isAlphanum&lt;/code&gt; + &lt;code&gt;#&#39;_&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueはスペース以外の文字列(e.g. &lt;code&gt;hogehoge&lt;/code&gt;)又は&lt;code&gt;&#39;&lt;/code&gt;で囲まれた文字列(e.g. &lt;code&gt;&#39;hoge hoge&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueでは&lt;code&gt;\&lt;/code&gt;によるエスケープが可能(e.g. &lt;code&gt;hoge\ hoge&lt;/code&gt;, &lt;code&gt;&#39;a \&#39;quote\&#39;&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;\&lt;/code&gt;については文字列の中なので&lt;code&gt;\&lt;/code&gt;自身のエスケープが必要なことに注意して下さい。&lt;/p&gt;

&lt;h2 id=&#34;unixodbc:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;unixODBC&lt;/h2&gt;

&lt;p&gt;ご存知ない方に説明するとODBCはOpen Database Connectivityの略です。Microsoftが主導となって定めたDB接続のインターフェースです。また、そのインターフェースに従うドライバマネージャのことも指します。
一旦抽象化レイヤを挟むのでパフォーマンス面では生の接続に負けますが、豊富な接続先が魅力です。
MicroSoftのSQL ServerやMicroSoft Accessを始めとし、Oracle, MySQL, PostgreSQL, SQLite3, 果てはMongoDBなどにまで接続出来ます。
まあ、接続出来るからといって投げたクエリを正しく解釈、実行してくれるとは限りませんが…&lt;/p&gt;

&lt;p&gt;unixODBCはODBCのunix実装のようです。つまりODBCドライバを持つDBにunixから接続出来ます。&lt;/p&gt;

&lt;p&gt;さてさて、odbcに繋ぐには以下のようにします。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = (SQL.odbc &amp;quot;mydb username mypassword&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜ記法変えたし…。&lt;del&gt;しかも必ずスペースで区切るのでクォートも出来なければ空のユーザパスワードを渡すことも出来ません。もしかしたら&lt;code&gt;&amp;quot;&#39;&#39;&amp;quot;&lt;/code&gt;としたら後側で空の文字列と扱ってくれるかもしれませんが。&lt;/del&gt;
私が&lt;code&gt;String.fields&lt;/code&gt;の挙動を勘違いしてました。スペースで区切って空にしておけば空パスワードを渡せます(e.g. &lt;code&gt;&amp;quot;mydb username &amp;quot;&lt;/code&gt;)。あるいは空ユーザ名も(&lt;code&gt;&amp;quot;mydb  &amp;quot;&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;私自身ODBCに詳しくないのですが、ODBCに接続するときはData Source Nameと呼ばれるものがシステムの特定の場所に存在するので他の接続情報は必要ないみたいです。&lt;/p&gt;

&lt;h1 id=&#34;接続:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続&lt;/h1&gt;

&lt;p&gt;さっきまでは接続サーバの設定の話でした。今度は実際に接続する話です。DBMS固有の話はサーバ設定までなのでこれからは総のDBに共通です。&lt;/p&gt;

&lt;p&gt;接続するには公式のドキュメント通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val conn = SQL.connet myServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で繋げます。ここで各クライアントのダイナミックリンクライブラリがないとエラーになります。64dbit環境でSML#を32bitでビルドしている人はライブラリも32bitでビルドされていることを確認しましょう。&lt;/p&gt;

&lt;h1 id=&#34;クエリ:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;クエリ&lt;/h1&gt;

&lt;p&gt;これもドキュメント通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myQuery = _sql db =&amp;gt; select #P.name as name, #P.age as age
      from #db.Persons as P
      where SQL.&amp;gt;(#P.salary, 10000)
val rel = _sqleval myQuery conn
val result = SQL.fetchAll rel; (* =&amp;gt; [{age=32, name=&amp;quot;Sue&amp;quot;}, {age=41, name=&amp;quot;Bob&amp;quot;}] *)
val () = SQL.closeRel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;p&gt;可能な文法については主に&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch10.S5.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;を参考にしましょう。&lt;/p&gt;

&lt;p&gt;insert, update, deleteをサポートしている他、トランザクション(&lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt;)をサポートしているようです。詳しくは&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/compiler/parser2/main/iml.grm#L727&#34;&gt;BNF&lt;/a&gt;を読んで下さい。&lt;/p&gt;

&lt;p&gt;SQLを投げて返ってきたリレーションに対しては結果を総取得する&lt;code&gt;SQL.fetchAll&lt;/code&gt;、結果をoption型で1つ取得する&lt;code&gt;SQL.fetch&lt;/code&gt;、結果を1つ取得するか例外になる&lt;code&gt;SQL.fetchOne&lt;/code&gt;を使います。&lt;code&gt;fetchOne&lt;/code&gt;の上げる例外は&lt;code&gt;SQL.NotOne&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;クエリ結果を使い終わったら必ず&lt;code&gt;SQL.closeRel&lt;/code&gt;で開放しましょう。そしてコネクションも、終わったら&lt;code&gt;SQL.closeCon&lt;/code&gt;で開放しましょう。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;本当は実際に試してから記事を書きたかったのですが、32bitの壁に阻まれて出来ませんでした。しかしソースを読んで裏を取って書いてあるのでまあまあ信憑性のある内容だと思います。
SML# からデータベースに接続したい方の一助になれば幸いです。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Cargoの使い方</title>
      <link>http://keens.github.io/blog/2015/11/29/cargonotsukaikata</link>
      <pubDate>Sun, 29 Nov 2015 23:25:54 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/29/cargonotsukaikata</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 3日目の記事です。&lt;br /&gt;
前 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_/&#34;&gt;Rustで小さなツールを作ってみる(後編)&lt;/a&gt;&lt;br /&gt;
次  szkttyさん インデックス構文によるアクセスを実装する&lt;/p&gt;

&lt;p&gt;κeenです。Rustを使うにはCargoを使う必要がありますが、&lt;code&gt;cargo help&lt;/code&gt;を見てもあまり情報が載っていないので少しばかり書きましょう。&lt;/p&gt;

&lt;h1 id=&#34;new:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Create a new cargo package at &amp;lt;path&amp;gt;

Usage:
    cargo new [options] &amp;lt;path&amp;gt;
    cargo new -h | --help

Options:
    -h, --help          Print this message
    --vcs VCS           Initialize a new repository for the given version
                        control system (git or hg) or do not initialize any version
                        control at all (none) overriding a global configuration.
    --bin               Use a binary instead of a library template
    --name NAME         Set the resulting package name
    -v, --verbose       Use verbose output
    -q, --quiet         No output printed to stdout
    --color WHEN        Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはみなさんよく使うのでほとんど説明不要でしょう。&lt;code&gt;cargo new&lt;/code&gt;または&lt;code&gt;cargo new --bin&lt;/code&gt;の形でよく使います。
オプションを見て分かる通り、&lt;code&gt;cargo new foo-rs --name foo&lt;/code&gt;のようにパスとcrateの名前を変えたりデフォルトのvcsにmercurialを使うことも出来ます。&lt;/p&gt;

&lt;h1 id=&#34;build:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Compile a local package and all of its dependencies

Usage:
    cargo build [options]

Options:
    -h, --help               Print this message
    -p SPEC, --package SPEC  Package to build
    -j N, --jobs N           The number of jobs to run in parallel
    --lib                    Build only this package&#39;s library
    --bin NAME               Build only the specified binary
    --example NAME           Build only the specified example
    --test NAME              Build only the specified test target
    --bench NAME             Build only the specified benchmark target
    --release                Build artifacts in release mode, with optimizations
    --features FEATURES      Space-separated list of features to also build
    --no-default-features    Do not build the `default` feature
    --target TRIPLE          Build for the target triple
    --manifest-path PATH     Path to the manifest to compile
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never

If the --package argument is given, then SPEC is a package id specification
which indicates which package should be built. If it is not given, then the
current package is built. For more information on SPEC and its format, see the
`cargo help pkgid` command.

Compilation can be configured via the use of profiles which are configured in
the manifest. The default profile for this command is `dev`, but passing
the --release flag will use the `release` profile instead.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恐らく一番よく使うタスクですね。ビルド対象を色々指定できるのはいいとして、実は&lt;code&gt;-j&lt;/code&gt;オプションがあります。並行ビルド出来るやつですね。体感速度は変わりませんが。&lt;/p&gt;

&lt;h1 id=&#34;run:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Run the main binary of the local package (src/main.rs)

Usage:
    cargo run [options] [--] [&amp;lt;args&amp;gt;...]

Options:
    -h, --help              Print this message
    --bin NAME              Name of the bin target to run
    --example NAME          Name of the example target to run
    -j N, --jobs N          The number of jobs to run in parallel
    --release               Build artifacts in release mode, with optimizations
    --features FEATURES     Space-separated list of features to also build
    --no-default-features   Do not build the `default` feature
    --target TRIPLE         Build for the target triple
    --manifest-path PATH    Path to the manifest to execute
    -v, --verbose           Use verbose output
    -q, --quiet             No output printed to stdout
    --color WHEN            Coloring: auto, always, never

If neither `--bin` nor `--example` are given, then if the project only has one
bin target it will be run. Otherwise `--bin` specifies the bin target to run,
and `--example` specifies the example target to run. At most one of `--bin` or
`--example` can be provided.

All of the trailing arguments are passed to the binary to run. If you&#39;re passing
arguments to both Cargo and the binary, the ones after `--` go to the binary,
the ones before go to Cargo.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行可能ファイルのプロジェクトだった時に成果物を走らせます。あるいはexampleも走らせられます。とはいってもまだビルドしてなかったらビルドもするのでビルド向けのオプションがいっぱいありますね。&lt;/p&gt;

&lt;p&gt;実行可能ファイルが複数あるなら&lt;code&gt;cargo run --bin xxx&lt;/code&gt;で指定して走らせます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--release&lt;/code&gt;ビルドした成果物を走らせたかったら&lt;code&gt;cargo run --release&lt;/code&gt;しないといけません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cargo run -- args&lt;/code&gt;で成果物に引数を渡せます。&lt;/p&gt;

&lt;h1 id=&#34;test:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Execute all unit and integration tests of a local package

Usage:
    cargo test [options] [--] [&amp;lt;args&amp;gt;...]

Options:
    -h, --help               Print this message
    --lib                    Test only this package&#39;s library
    --bin NAME               Test only the specified binary
    --example NAME           Test only the specified example
    --test NAME              Test only the specified integration test target
    --bench NAME             Test only the specified benchmark target
    --no-run                 Compile, but don&#39;t run tests
    -p SPEC, --package SPEC  Package to run tests for
    -j N, --jobs N           The number of jobs to run in parallel
    --release                Build artifacts in release mode, with optimizations
    --features FEATURES      Space-separated list of features to also build
    --no-default-features    Do not build the `default` feature
    --target TRIPLE          Build for the target triple
    --manifest-path PATH     Path to the manifest to build tests for
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never
    --no-fail-fast           Run all tests regardless of failure

All of the trailing arguments are passed to the test binaries generated for
filtering tests and generally providing options configuring how they run. For
example, this will run all tests with the name `foo` in their name:

    cargo test foo

If the --package argument is given, then SPEC is a package id specification
which indicates which package should be tested. If it is not given, then the
current package is tested. For more information on SPEC and its format, see the
`cargo help pkgid` command.

The --jobs argument affects the building of the test executable but does
not affect how many jobs are used when running the tests.

Compilation can be configured via the `test` profile in the manifest.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テスト走らせるやつです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cargo test&lt;/code&gt;とだけすると全てのテストが走ります。地味にrustdocの中に書いたexampleも走ります。&lt;/p&gt;

&lt;h1 id=&#34;search:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;search&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Search packages in crates.io

Usage:
    cargo search [options] &amp;lt;query&amp;gt;
    cargo search [-h | --help]

Options:
    -h, --help               Print this message
    --host HOST              Host of a registry to search in
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;crates.ioからパッケージを捜してきてくれます。よく使いますね。インデックスのアップデートが地味に重い。&lt;/p&gt;

&lt;h1 id=&#34;fetch:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;だんだんニッチなタスクを紹介していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fetch dependencies of a package from the network.

Usage:
    cargo fetch [options]

Options:
    -h, --help               Print this message
    --manifest-path PATH     Path to the manifest to fetch dependencies for
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never

If a lockfile is available, this command will ensure that all of the git
dependencies and/or registries dependencies are downloaded and locally
available. The network is never touched after a `cargo fetch` unless
the lockfile changes.

If the lockfile is not available, then this is the equivalent of
`cargo generate-lockfile`. A lockfile is generated and dependencies are also
all updated.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dependenciesを全てローカルに持ってくるタスクです。&lt;/p&gt;

&lt;h1 id=&#34;generate-lockfile:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;generate_lockfile&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Generate the lockfile for a project

Usage:
    cargo generate-lockfile [options]

Options:
    -h, --help               Print this message
    --manifest-path PATH     Path to the manifest to generate a lockfile for
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cargo.lockの生成をします。&lt;code&gt;cargo update&lt;/code&gt;がロックファイルがないと怒ってくるのでそういう時に使うのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;package:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Assemble the local package into a distributable tarball

Usage:
    cargo package [options]

Options:
    -h, --help              Print this message
    -l, --list              Print files included in a package without making one
    --no-verify             Don&#39;t verify the contents by building them
    --no-metadata           Ignore warnings about a lack of human-usable metadata
    --manifest-path PATH    Path to the manifest to compile
    -v, --verbose           Use verbose output
    -q, --quiet             No output printed to stdout
    --color WHEN            Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cargoにはcrates.ioにデプロイする機能もあります。他にも&lt;code&gt;publish&lt;/code&gt;, &lt;code&gt;login&lt;/code&gt;, &lt;code&gt;yank&lt;/code&gt;も見ておきましょう。&lt;/p&gt;

&lt;h1 id=&#34;install:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;install&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Install a Rust binary
Usage:
    cargo install [options] [&amp;lt;crate&amp;gt;]
    cargo install [options] --list
Specifying what crate to install:
    --vers VERS               Specify a version to install from crates.io
    --git URL                 Git URL to install the specified crate from
    --branch BRANCH           Branch to use when installing from git
    --tag TAG                 Tag to use when installing from git
    --rev SHA                 Specific commit to use when installing from git
    --path PATH               Filesystem path to local crate to install
Build and install options:
    -h, --help                Print this message
    -j N, --jobs N            The number of jobs to run in parallel
    --features FEATURES       Space-separated list of features to activate
    --no-default-features     Do not build the `default` feature
    --debug                   Build in debug mode instead of release mode
    --bin NAME                Only install the binary NAME
    --example EXAMPLE         Install the example EXAMPLE instead of binaries
    --root DIR                Directory to install packages into
    -v, --verbose             Use verbose output
    -q, --quiet               Less output printed to stdout
    --color WHEN              Coloring: auto, always, never
This command manages Cargo&#39;s local set of install binary crates. Only packages
which have [[bin]] targets can be installed, and all binaries are installed into
the installation root&#39;s `bin` folder. The installation root is determined, in
order of precedence, by `--root`, `$CARGO_INSTALL_ROOT`, the `install.root`
configuration key, and finally the home directory (which is either
`$CARGO_HOME` if set or `$HOME/.cargo` by default).
There are multiple sources from which a crate can be installed. The default
location is crates.io but the `--git` and `--path` flags can change this source.
If the source contains more than one package (such as crates.io or a git
repository with multiple crates) the `&amp;lt;crate&amp;gt;` argument is required to indicate
which crate should be installed.
Crates from crates.io can optionally specify the version they wish to install
via the `--vers` flags, and similarly packages from git repositories can
optionally specify the branch, tag, or revision that should be installed. If a
crate has multiple binaries, the `--bin` argument can selectively install only
one of them, and if you&#39;d rather install examples the `--example` argument can
be used as well.
The `--list` option will list all installed packages (and their versions).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだリリースチャネルには来てませんが、&lt;code&gt;install&lt;/code&gt;も入る予定です。binプロジェクトをソースを持ってきてそのままビルド、インストールまでするやつです。勿論、ローカルのものもインストール出来ますよ。
&lt;a href=&#34;https://github.com/rust-lang-nursery/rustfmt&#34;&gt;rustfmt&lt;/a&gt;のようにREADMEのインストール方法に&lt;code&gt;cargo install&lt;/code&gt;を書いているものもあります。これが使えるようになると配布がぐっと楽になりますね。&lt;/p&gt;

&lt;h1 id=&#34;プラグイン:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;プラグイン&lt;/h1&gt;

&lt;p&gt;Cargoのサブコマンドを自分で作るのは簡単です。&lt;code&gt;cargo foo&lt;/code&gt;というタスクを作りたいのなら&lt;code&gt;cargo-foo&lt;/code&gt;という名前の実行可能ファイルをパスに置いておくだけです。&lt;/p&gt;

&lt;p&gt;試してみましょう&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF &amp;gt; ~/bin/cargo-foo
#!/bin/sh
echo args are: &amp;quot;\$@&amp;quot;
echo \\\$0 is: \$0
EOF
$ chmod +x  ~/bin/cargo-foo
$ cargo foo aa bb cc
args are: foo aa bb cc
$0 is: /home/kim/bin/cargo-foo
$ cargo help foo aa bb cc
args are: foo -h
$0 is: /home/kim/bin/cargo-foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと独特な引数の渡り方をしてますね。しかし予め了解しておけば特に問題はなさそうです。1つサブコマンドを作ってみましょう。&lt;/p&gt;

&lt;p&gt;指定した名前のパッケージをCargo.tomlのdependenciesに書き足してくれるサブコマンドです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
usage(){
    cat &amp;lt;&amp;lt;EOF
Add the dependency of crate to Cargo.toml

Usage:
    cargo use &amp;lt;crate&amp;gt; [version]
    cargo use -h | --help

Description:
    Add the dependency of crate to Cargo.toml.
    If vension is omitted, adopt the latest version.

EOF
}

version(){
    cargo search &amp;quot;$1&amp;quot; | grep -Eo &amp;quot;^$1 \(.*?\)&amp;quot; | sed &amp;quot;s/^$1 (\(.*\))/\1/&amp;quot;
}

find_cargo(){
    # TODO: look up parent directories
    ls | grep &#39;^Cargo.toml$&#39;
}

ensure_dep_exists(){
    cargo=&amp;quot;$1&amp;quot;
    if ! grep -F &#39;[dependencies]&#39; &amp;quot;$cargo&amp;quot; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then
        echo &#39;[dependencies]&#39; &amp;gt;&amp;gt; &amp;quot;$cargo&amp;quot;
    fi
}

insert_dep(){
    cargo=&amp;quot;$1&amp;quot;
    crate=&amp;quot;$2&amp;quot;
    version=&amp;quot;$3&amp;quot;
    # FIXME: Because Linux and Mac behaves defferently on null string argument, don&#39;t use it and adopt workaround.
    sed -i&#39;&#39; &amp;quot;/\[dependencies\]/{a\
$crate = \&amp;quot;$version\&amp;quot;
}&amp;quot; &amp;quot;$cargo&amp;quot;
}

run(){
    CARGO_TOML=&amp;quot;$(find_cargo)&amp;quot;
    if [ $? != 0 ]
    then
        echo &amp;quot;Cargo.toml not found&amp;quot; 1&amp;gt;&amp;amp;2
        exit 1
    fi

    if [ -z &amp;quot;$1&amp;quot; ]; then
        usage
        exit 1
    else
        CRATE=&amp;quot;$1&amp;quot;
    fi

    if [ -z &amp;quot;$2&amp;quot; ]; then
        VERSION=&amp;quot;$(version $1)&amp;quot;
    else
        VERSION=&amp;quot;$2&amp;quot;
    fi

    ensure_dep_exists &amp;quot;$CARGO_TOML&amp;quot;
    insert_dep &amp;quot;$CARGO_TOML&amp;quot; &amp;quot;$CRATE&amp;quot; &amp;quot;$VERSION&amp;quot;    
}

main(){
    # $1 is &amp;quot;use&amp;quot; when called as a cargo plugin
    if [ &amp;quot;$1&amp;quot; != use ]; then
        echo &amp;quot;Use this as a cargo plugin&amp;quot;
        usage
        exit 1
    fi
    shift
    if [ &amp;quot;$1&amp;quot; = -h ] || [ &amp;quot;$1&amp;quot; = --help ]; then
        usage
        exit
    else
        run &amp;quot;$@&amp;quot;
    fi
}


main &amp;quot;$@&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだ洗練されていませんがお気に入りのタスクです。誰かCLIからCargo.tomlをいじれるツール作ってくれないかな。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>