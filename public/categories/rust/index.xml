<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/rust/</link>
    <description>Recent content in Rust on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Dec 2015 22:19:21 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/rust/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>travisとappveyorでクロスプラットフォームなCIする話</title>
      <link>http://keens.github.io/blog/2015/12/20/travistoappveyerdekurosupurattofo_munacisuruhanashi</link>
      <pubDate>Sun, 20 Dec 2015 22:19:21 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/20/travistoappveyerdekurosupurattofo_munacisuruhanashi</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt;20日目の記事です。
日付を覚え間違っていて、締切ギリギリに書いてます。&lt;/p&gt;

&lt;p&gt;κeenです。ものすごい小ネタですがRustでCIする話でも。&lt;/p&gt;

&lt;p&gt;Rustはクロスプラットフォームな言語なのでLinux, Macそしてあまり聞き慣れませんがWindowsというOSでも動きます。
とは言っても普段の開発環境がLinux、運悪くMacを使わざるを得ない人はMacで開発をしているとそれらでの動作検証は出来るでしょうが他のOSでの動作検証が難しいでしょう。&lt;/p&gt;

&lt;p&gt;そこでCIしましょう。Travis CIはLinuxと、あまり使われていませんがMacでのCI環境を、AppveyorでWindowsというOSでのCI環境を作ります。&lt;/p&gt;

&lt;p&gt;しかしクロスプラットフォームでしかもテスト方法がCargoで統一されているRustではそこまで難しいこともなく、以下の設定をコピペするだけです。&lt;/p&gt;

&lt;p&gt;travis&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: rust
rust:
  - nightly
  - beta
  - stable
os:
  - linux
  - osx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;appveyor&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;branches:
  except:
    - gh-pages

platform:
  - x64
environment:
  RUST_INSTALL_DIR: C:\Rust
  matrix:
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: 1.4.0
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: beta
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: nightly
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: 1.4.0
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: beta
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: nightly

install:
  - ps: Start-FileDownload &amp;quot;https://static.rust-lang.org/dist/rust-${env:RUST_VERSION}-${env:RUST_INSTALL_TRIPLE}.exe&amp;quot;
  - cmd: rust-%RUST_VERSION%-%RUST_INSTALL_TRIPLE%.exe /VERYSILENT /NORESTART /DIR=&amp;quot;%RUST_INSTALL_DIR%&amp;quot;
  - cmd: SET PATH=%PATH%;%RUST_INSTALL_DIR%\bin
  - rustc --version
  - cargo --version

build: false
test_script:
  - cargo build --verbose
  - cargo test --verbose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バッジとかは適当に持ってきましょう。&lt;/p&gt;

&lt;p&gt;サンプルが欲しければ&lt;a href=&#34;https://github.com/Stebalien/tempfile&#34;&gt;Stebalien/tempfile&lt;/a&gt;あたりを参考にしましょう。&lt;/p&gt;

&lt;p&gt;それではHave Happy Hacκings!&lt;/p&gt;

&lt;p&gt;※OS関連の煽りはただのネタです。また「あまり使われていませんがMacでのCI環境を」は「(travisの中では)あまり使われていません(のでもしかしたら使えることを知らない人がいるかもしれません)が」という意味です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustでの日本語の扱い</title>
      <link>http://keens.github.io/blog/2015/12/13/rustdenonihongonoatsukai</link>
      <pubDate>Sun, 13 Dec 2015 17:14:18 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/13/rustdenonihongonoatsukai</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar&lt;/a&gt; 14日目の記事です&lt;br /&gt;
前:gifnksmさんの &lt;a href=&#34;http://gifnksm.hatenablog.jp/entry/2015/12/13/204655&#34;&gt;kcovを使ってRustプログラムのカバレッジを測定する - gifnksmの雑多なメモ&lt;/a&gt;&lt;br /&gt;
後:nacika_insさんのtimeこわい&lt;/p&gt;

&lt;p&gt;κeenです。当初の予定より小ネタになってしまいましたがRustでの日本語の扱いについて書こうかと。&lt;/p&gt;

&lt;p&gt;ご存じの通りRustはマルチバイト文字をサポートしていますが、その殆どがUTF-8だけです。しかし日本人にはUTF-8だけでは少し辛いものがありますのでどうにかして対応しようかと。&lt;/p&gt;

&lt;p&gt;ソースコード中でもマルチバイト文字を扱えますが、UTF-8である必要があります。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rs&#34;&gt;fn main() {
  println!(&amp;quot;あああ&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをISO-2022-JPで保存してrustcに食わせても、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error: couldn&#39;t read &amp;quot;src/main.rs&amp;quot;: stream did not contain valid UTF-8
Could not compile `japanese`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と無下もないエラーが出てしまいます。&lt;/p&gt;

&lt;p&gt;内部エンコーディングにもUTF-8が使われているのでRustの文字列をUTF-8以外で出力するにはなんとなく変換が必要そうなのは理解出来ますが、変に出入力をラップしてる関数を使うとまた意図せぬエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;

fn main() {
  let file = File::open(&amp;quot;japanese.txt&amp;quot;);
  let br = BufReader::new(&amp;amp;file);
  for line in br.lines() {
    matich line {
      Ok(l) =&amp;gt; println!(&amp;quot;Ok: {}&amp;quot;, l),
      Err(e) =&amp;gt; println!(&amp;quot;{:?}&amp;quot;, e)
    };
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもまた、&lt;code&gt;stream did not contain valid UTF-8&lt;/code&gt;エラーを出します。&lt;/p&gt;

&lt;p&gt;ReadもBufReadもbyte orientedって言ってるのに何故か文字列を扱えるのが若干気になりますがまあ、そういうもんなんでしょう。&lt;/p&gt;

&lt;h1 id=&#34;encoding:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;encoding&lt;/h1&gt;

&lt;p&gt;そこで救世主となるライブラリが&lt;a href=&#34;https://github.com/lifthrasiir/rust-encoding&#34;&gt;lifthrasiir/rust-encoding&lt;/a&gt;です。文字列のエンコーディングをサポートします。
READMEに詳しい使い方が載っているのですが、このライブラリは与えられたスライスに対して指定されたエンコーディングでエンコード/デコードします。&lt;/p&gt;

&lt;p&gt;なので先の例のようにISO-2022-JPで&lt;code&gt;&amp;quot;あああ&amp;quot;&lt;/code&gt;と出力したいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use encoding::{Encoding, EncoderTrap};
use encoding::all::ISO_2022_JP;
use std::io::Stdout;

fn main() {
  let bytes = ISO_2022_JP.encode(&amp;quot;あああ&amp;quot;, EncoderTrap::Ignore);
  Stdout.write_all(&amp;amp;bytes[..]);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出来るでしょう。(即興で書いてコンパイルすらしてないので本当に出来るかは分かりませんが)&lt;/p&gt;

&lt;p&gt;読み取りに関しては…………。そう、このライブラリはバッファに対してしか動作せず、ストリームに使えないのです。提供してくれたら良さそうなのですが、作者の方が忙しいようです。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; stream encoding/decodingは計画してはいるのですが、私が忙しくてなかなか作業をすることができません&amp;hellip; orz&lt;/p&gt;&amp;mdash; Kang Seonghoon (@senokay) &lt;a href=&#34;https://twitter.com/senokay/status/666516796942319616&#34;&gt;2015, 11月 17&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;余談ですがこの方は韓国の方のようですが、日本語もある程度分かるそうです。すごいですね。&lt;/p&gt;

&lt;p&gt;さて、ストリームに対して使えないと分かったなら自分で対応するまで。幸いにも我々が使っているのはRustです。新しいものを既存の仕組みに載せるのは造作もありません。
ストリームを良い感じにデコードするには&lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Read.html&#34;&gt;std::io::Read&lt;/a&gt;を実装した何かを作れば十分です。作っていきましょう。&lt;code&gt;Read&lt;/code&gt;トレイトを実装するには最低&lt;code&gt;read&lt;/code&gt;だけ実装してしまえば十分です。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;read&lt;/code&gt;ですが、ドキュメントを読むと中々制限が緩いようです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pull some bytes from this source into the specified buffer, returning how many bytes were read.&lt;/p&gt;

&lt;p&gt;This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an Err return value.&lt;/p&gt;

&lt;p&gt;If the return value of this method is Ok(n), then it must be guaranteed that 0 &amp;lt;= n &amp;lt;= buf.len(). A nonzero n value indicates that the buffer buf has been filled in with n bytes of data from this source. If n is 0, then it can indicate one of two scenarios:&lt;/p&gt;

&lt;p&gt;This reader has reached its &amp;ldquo;end of file&amp;rdquo; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will always no longer be able to produce bytes.
   The buffer specified was 0 bytes in length.&lt;/p&gt;

&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true. It is recommended that implementations only write data to buf instead of reading its contents.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「関数が呼ばれる際に&lt;code&gt;buf&lt;/code&gt;に対しては何如なる保証もなく、呼出側はバッファの内容に対して何如なる不変条件も期待してはいけません」とあります。つまり、4096 byteのバッファが与えられても1呼び出しにつき1バイトしか返さないような実装でも許容されます。
また、非同期ベースのIOのようにキャッシュにデータがなければIOブロッキングせずにエラーだとかの挙動もありえます。非常にシステムプログラミング言語らしい仕様ですね。&lt;/p&gt;

&lt;p&gt;今から作ろうとしているデコーディングストリームも読み出したバイト列がデコード後に何バイトになるのか予測がつかないのでこの仕様は有難いですね。&lt;/p&gt;

&lt;p&gt;さて、作っていきましょうか。まずは必要そうなライブラリを読み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use self::encoding::{EncodingRef, DecoderTrap};
use std::io::Read;
use std::io;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてメインとなる構造体です。とある&lt;code&gt;Read&lt;/code&gt;を実装した型をラップする形にしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct DecodingReader&amp;lt;R&amp;gt; {
    inner: R,
    encoding: EncodingRef,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;はトレイトなので&lt;code&gt;inner&lt;/code&gt;のところを&lt;code&gt;&amp;amp;R&lt;/code&gt;としなくて大丈夫です。&lt;code&gt;Read&lt;/code&gt;の実装側が調整します。&lt;/p&gt;

&lt;p&gt;そしてコンストラクタですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; DecodingReader&amp;lt;R&amp;gt; {
    pub fn new(coding: EncodingRef, read: R)-&amp;gt; Self {
        EncodingReader {
            inner: read,
            encoding: coding
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのままですね。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;の実装です。まずは&lt;code&gt;inner&lt;/code&gt;の&lt;code&gt;read&lt;/code&gt;を呼んで、その結果を一旦デコードしてからまたバイト列に変換します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; Read for DecodingReader&amp;lt;R&amp;gt; {
    fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;usize&amp;gt;{
        // TODO set appropriate buffer size
        let len = buf.len() / 2;
        let n = try!(self.inner.read(&amp;amp;mut buf[..len]));
        // TODO don&#39;t ignore input code
        let str = self.encoding.decode(&amp;amp;mut buf[..n], DecoderTrap::Ignore).unwrap();
        let mut i = 0;
        for (d, s) in buf.iter_mut().zip(str.bytes()) {
            *d = s;
            i+=1;
            if i == 0 {
                break
            };
        }
        assert!(i &amp;lt;= buf.len());
        Ok(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程も言った通りデコード読み込んだバイト列をUTF-8にした時にどれくらいバイト数が変わるか分からないので山勘で2倍くらいに膨らむだろうとして与えられたバッファ長の半分を使います。
ここはもう少し調整が必要ですね。エンコーディング毎に適切なバッファ長を設定したい…&lt;/p&gt;

&lt;p&gt;バッファを確保出来たら&lt;code&gt;let n = try!(self.inner.read(&amp;amp;mut buf[..len]));&lt;/code&gt;してそれっぽいサイズ読み込んで、読み込んだサイズをデコードにかけます。&lt;/p&gt;

&lt;p&gt;現在&lt;code&gt;DecoderTrap&lt;/code&gt;を&lt;code&gt;Ignore&lt;/code&gt;にして&lt;code&gt;unwrap&lt;/code&gt;してますが、これは少し雑すぎますね。例えば入力が全てvalidな文字を含んでいたとしても&lt;code&gt;read&lt;/code&gt;が多バイト文字の真ん中までしか読まなかった時にそれが無効なエンコーディングと判定されて無視されるのでユーザからしたら「合ってる筈なのに何故か1文字欠損するバグ」として現れます。今回即席で作ったので勘弁して下さい。&lt;/p&gt;

&lt;p&gt;変換は文字列にしか出来ないようなので一旦文字列に落してからまたバイト列として取り出し、バッファに書き出します。デコード後のバイト列が&lt;code&gt;read&lt;/code&gt;したバイト列より小さかったら一部&lt;code&gt;read&lt;/code&gt;したデータが残ってしまいそうですが、「何如なる不変条件も…」とあるので問題ないでしょう。返り値にデコード後のバイト列の長さを返していれば良い筈です。&lt;/p&gt;

&lt;p&gt;さて、エンコードのエラーハンドリングしてないだとか本当に読み込みのバッファ長が適切なのかとかの疑問はあるものの、一応ストリームのデコーダが出来ました。使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
extern crate japanese;

use encoding::{Encoding, DecoderTrap};
use encoding::all::ISO_2022_JP;

use std::fs::File;
use std::io::BufReader;
use std::io::BufRead;
use std::str::from_utf8;
use japanese::buf::DecodingReader;


fn main() {
    let file = File::open(&amp;quot;src/japanese.txt&amp;quot;).unwrap();
    let e = DecodingReader::new(ISO_2022_JP, &amp;amp;file);
    let mut br = BufReader::new(e);
    for line in br.lines() {
        println!(&amp;quot;{}&amp;quot;, line.unwrap());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでちゃんとISO-2022-JPのファイルを読めます。&lt;/p&gt;

&lt;p&gt;Javaに慣れてる人ならこういうIOに対するデコレータパターンは見覚えがあるでしょう。&lt;/p&gt;

&lt;p&gt;今更ですがiso-2022-jpはいわゆるjisエンコーディングです。rust-encodingはshift_jisの拡張にあたるwindows31jだとかeuc-jpも扱えます(&lt;a href=&#34;https://lifthrasiir.github.io/rust-encoding/encoding/codec/japanese/index.html&#34;&gt;参考&lt;/a&gt;)。&lt;/p&gt;

&lt;h1 id=&#34;今後:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;今後&lt;/h1&gt;

&lt;p&gt;ライブラリとして公開するか、あるいは作者の方がやる気はあるようなのでプルリクを送るかが終着点かな、と思っていますが如何せん雑にしか実装してないので微妙ですね。
例の境界とマルチバイトの問題は&lt;code&gt;Read&lt;/code&gt;じゃなく&lt;code&gt;BufRead&lt;/code&gt;を要求して1文字分読み切るまで来るまで1バイトずつ読むとかになると思います。ダルい。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Rust標準だけでUTF-8以外の文字列を使うのはつらいよ&lt;/li&gt;
&lt;li&gt;Rustのエンコーディングライブラリを紹介したよ&lt;/li&gt;
&lt;li&gt;エンコーディングライブラリを使ってストリームデコーダを実装してみたよ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/japanese&#34;&gt;こちら&lt;/a&gt;にあります&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cargoの使い方</title>
      <link>http://keens.github.io/blog/2015/11/29/cargonotsukaikata</link>
      <pubDate>Sun, 29 Nov 2015 23:25:54 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/29/cargonotsukaikata</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 3日目の記事です。&lt;br /&gt;
前 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_/&#34;&gt;Rustで小さなツールを作ってみる(後編)&lt;/a&gt;&lt;br /&gt;
次  szkttyさん インデックス構文によるアクセスを実装する&lt;/p&gt;

&lt;p&gt;κeenです。Rustを使うにはCargoを使う必要がありますが、&lt;code&gt;cargo help&lt;/code&gt;を見てもあまり情報が載っていないので少しばかり書きましょう。&lt;/p&gt;

&lt;h1 id=&#34;new:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Create a new cargo package at &amp;lt;path&amp;gt;

Usage:
    cargo new [options] &amp;lt;path&amp;gt;
    cargo new -h | --help

Options:
    -h, --help          Print this message
    --vcs VCS           Initialize a new repository for the given version
                        control system (git or hg) or do not initialize any version
                        control at all (none) overriding a global configuration.
    --bin               Use a binary instead of a library template
    --name NAME         Set the resulting package name
    -v, --verbose       Use verbose output
    -q, --quiet         No output printed to stdout
    --color WHEN        Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはみなさんよく使うのでほとんど説明不要でしょう。&lt;code&gt;cargo new&lt;/code&gt;または&lt;code&gt;cargo new --bin&lt;/code&gt;の形でよく使います。
オプションを見て分かる通り、&lt;code&gt;cargo new foo-rs --name foo&lt;/code&gt;のようにパスとcrateの名前を変えたりデフォルトのvcsにmercurialを使うことも出来ます。&lt;/p&gt;

&lt;h1 id=&#34;build:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Compile a local package and all of its dependencies

Usage:
    cargo build [options]

Options:
    -h, --help               Print this message
    -p SPEC, --package SPEC  Package to build
    -j N, --jobs N           The number of jobs to run in parallel
    --lib                    Build only this package&#39;s library
    --bin NAME               Build only the specified binary
    --example NAME           Build only the specified example
    --test NAME              Build only the specified test target
    --bench NAME             Build only the specified benchmark target
    --release                Build artifacts in release mode, with optimizations
    --features FEATURES      Space-separated list of features to also build
    --no-default-features    Do not build the `default` feature
    --target TRIPLE          Build for the target triple
    --manifest-path PATH     Path to the manifest to compile
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never

If the --package argument is given, then SPEC is a package id specification
which indicates which package should be built. If it is not given, then the
current package is built. For more information on SPEC and its format, see the
`cargo help pkgid` command.

Compilation can be configured via the use of profiles which are configured in
the manifest. The default profile for this command is `dev`, but passing
the --release flag will use the `release` profile instead.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恐らく一番よく使うタスクですね。ビルド対象を色々指定できるのはいいとして、実は&lt;code&gt;-j&lt;/code&gt;オプションがあります。並行ビルド出来るやつですね。体感速度は変わりませんが。&lt;/p&gt;

&lt;h1 id=&#34;run:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Run the main binary of the local package (src/main.rs)

Usage:
    cargo run [options] [--] [&amp;lt;args&amp;gt;...]

Options:
    -h, --help              Print this message
    --bin NAME              Name of the bin target to run
    --example NAME          Name of the example target to run
    -j N, --jobs N          The number of jobs to run in parallel
    --release               Build artifacts in release mode, with optimizations
    --features FEATURES     Space-separated list of features to also build
    --no-default-features   Do not build the `default` feature
    --target TRIPLE         Build for the target triple
    --manifest-path PATH    Path to the manifest to execute
    -v, --verbose           Use verbose output
    -q, --quiet             No output printed to stdout
    --color WHEN            Coloring: auto, always, never

If neither `--bin` nor `--example` are given, then if the project only has one
bin target it will be run. Otherwise `--bin` specifies the bin target to run,
and `--example` specifies the example target to run. At most one of `--bin` or
`--example` can be provided.

All of the trailing arguments are passed to the binary to run. If you&#39;re passing
arguments to both Cargo and the binary, the ones after `--` go to the binary,
the ones before go to Cargo.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行可能ファイルのプロジェクトだった時に成果物を走らせます。あるいはexampleも走らせられます。とはいってもまだビルドしてなかったらビルドもするのでビルド向けのオプションがいっぱいありますね。&lt;/p&gt;

&lt;p&gt;実行可能ファイルが複数あるなら&lt;code&gt;cargo run --bin xxx&lt;/code&gt;で指定して走らせます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--release&lt;/code&gt;ビルドした成果物を走らせたかったら&lt;code&gt;cargo run --release&lt;/code&gt;しないといけません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cargo run -- args&lt;/code&gt;で成果物に引数を渡せます。&lt;/p&gt;

&lt;h1 id=&#34;test:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Execute all unit and integration tests of a local package

Usage:
    cargo test [options] [--] [&amp;lt;args&amp;gt;...]

Options:
    -h, --help               Print this message
    --lib                    Test only this package&#39;s library
    --bin NAME               Test only the specified binary
    --example NAME           Test only the specified example
    --test NAME              Test only the specified integration test target
    --bench NAME             Test only the specified benchmark target
    --no-run                 Compile, but don&#39;t run tests
    -p SPEC, --package SPEC  Package to run tests for
    -j N, --jobs N           The number of jobs to run in parallel
    --release                Build artifacts in release mode, with optimizations
    --features FEATURES      Space-separated list of features to also build
    --no-default-features    Do not build the `default` feature
    --target TRIPLE          Build for the target triple
    --manifest-path PATH     Path to the manifest to build tests for
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never
    --no-fail-fast           Run all tests regardless of failure

All of the trailing arguments are passed to the test binaries generated for
filtering tests and generally providing options configuring how they run. For
example, this will run all tests with the name `foo` in their name:

    cargo test foo

If the --package argument is given, then SPEC is a package id specification
which indicates which package should be tested. If it is not given, then the
current package is tested. For more information on SPEC and its format, see the
`cargo help pkgid` command.

The --jobs argument affects the building of the test executable but does
not affect how many jobs are used when running the tests.

Compilation can be configured via the `test` profile in the manifest.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テスト走らせるやつです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cargo test&lt;/code&gt;とだけすると全てのテストが走ります。地味にrustdocの中に書いたexampleも走ります。&lt;/p&gt;

&lt;h1 id=&#34;search:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;search&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Search packages in crates.io

Usage:
    cargo search [options] &amp;lt;query&amp;gt;
    cargo search [-h | --help]

Options:
    -h, --help               Print this message
    --host HOST              Host of a registry to search in
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;crates.ioからパッケージを捜してきてくれます。よく使いますね。インデックスのアップデートが地味に重い。&lt;/p&gt;

&lt;h1 id=&#34;fetch:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;だんだんニッチなタスクを紹介していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fetch dependencies of a package from the network.

Usage:
    cargo fetch [options]

Options:
    -h, --help               Print this message
    --manifest-path PATH     Path to the manifest to fetch dependencies for
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never

If a lockfile is available, this command will ensure that all of the git
dependencies and/or registries dependencies are downloaded and locally
available. The network is never touched after a `cargo fetch` unless
the lockfile changes.

If the lockfile is not available, then this is the equivalent of
`cargo generate-lockfile`. A lockfile is generated and dependencies are also
all updated.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dependenciesを全てローカルに持ってくるタスクです。&lt;/p&gt;

&lt;h1 id=&#34;generate-lockfile:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;generate_lockfile&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Generate the lockfile for a project

Usage:
    cargo generate-lockfile [options]

Options:
    -h, --help               Print this message
    --manifest-path PATH     Path to the manifest to generate a lockfile for
    -v, --verbose            Use verbose output
    -q, --quiet              No output printed to stdout
    --color WHEN             Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cargo.lockの生成をします。&lt;code&gt;cargo update&lt;/code&gt;がロックファイルがないと怒ってくるのでそういう時に使うのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;package:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Assemble the local package into a distributable tarball

Usage:
    cargo package [options]

Options:
    -h, --help              Print this message
    -l, --list              Print files included in a package without making one
    --no-verify             Don&#39;t verify the contents by building them
    --no-metadata           Ignore warnings about a lack of human-usable metadata
    --manifest-path PATH    Path to the manifest to compile
    -v, --verbose           Use verbose output
    -q, --quiet             No output printed to stdout
    --color WHEN            Coloring: auto, always, never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cargoにはcrates.ioにデプロイする機能もあります。他にも&lt;code&gt;publish&lt;/code&gt;, &lt;code&gt;login&lt;/code&gt;, &lt;code&gt;yank&lt;/code&gt;も見ておきましょう。&lt;/p&gt;

&lt;h1 id=&#34;install:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;&lt;code&gt;install&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Install a Rust binary
Usage:
    cargo install [options] [&amp;lt;crate&amp;gt;]
    cargo install [options] --list
Specifying what crate to install:
    --vers VERS               Specify a version to install from crates.io
    --git URL                 Git URL to install the specified crate from
    --branch BRANCH           Branch to use when installing from git
    --tag TAG                 Tag to use when installing from git
    --rev SHA                 Specific commit to use when installing from git
    --path PATH               Filesystem path to local crate to install
Build and install options:
    -h, --help                Print this message
    -j N, --jobs N            The number of jobs to run in parallel
    --features FEATURES       Space-separated list of features to activate
    --no-default-features     Do not build the `default` feature
    --debug                   Build in debug mode instead of release mode
    --bin NAME                Only install the binary NAME
    --example EXAMPLE         Install the example EXAMPLE instead of binaries
    --root DIR                Directory to install packages into
    -v, --verbose             Use verbose output
    -q, --quiet               Less output printed to stdout
    --color WHEN              Coloring: auto, always, never
This command manages Cargo&#39;s local set of install binary crates. Only packages
which have [[bin]] targets can be installed, and all binaries are installed into
the installation root&#39;s `bin` folder. The installation root is determined, in
order of precedence, by `--root`, `$CARGO_INSTALL_ROOT`, the `install.root`
configuration key, and finally the home directory (which is either
`$CARGO_HOME` if set or `$HOME/.cargo` by default).
There are multiple sources from which a crate can be installed. The default
location is crates.io but the `--git` and `--path` flags can change this source.
If the source contains more than one package (such as crates.io or a git
repository with multiple crates) the `&amp;lt;crate&amp;gt;` argument is required to indicate
which crate should be installed.
Crates from crates.io can optionally specify the version they wish to install
via the `--vers` flags, and similarly packages from git repositories can
optionally specify the branch, tag, or revision that should be installed. If a
crate has multiple binaries, the `--bin` argument can selectively install only
one of them, and if you&#39;d rather install examples the `--example` argument can
be used as well.
The `--list` option will list all installed packages (and their versions).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだリリースチャネルには来てませんが、&lt;code&gt;install&lt;/code&gt;も入る予定です。binプロジェクトをソースを持ってきてそのままビルド、インストールまでするやつです。勿論、ローカルのものもインストール出来ますよ。
&lt;a href=&#34;https://github.com/rust-lang-nursery/rustfmt&#34;&gt;rustfmt&lt;/a&gt;のようにREADMEのインストール方法に&lt;code&gt;cargo install&lt;/code&gt;を書いているものもあります。これが使えるようになると配布がぐっと楽になりますね。&lt;/p&gt;

&lt;h1 id=&#34;プラグイン:e4bd6fb248740806b055cd17a0b9a9cc&#34;&gt;プラグイン&lt;/h1&gt;

&lt;p&gt;Cargoのサブコマンドを自分で作るのは簡単です。&lt;code&gt;cargo foo&lt;/code&gt;というタスクを作りたいのなら&lt;code&gt;cargo-foo&lt;/code&gt;という名前の実行可能ファイルをパスに置いておくだけです。&lt;/p&gt;

&lt;p&gt;試してみましょう&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF &amp;gt; ~/bin/cargo-foo
#!/bin/sh
echo args are: &amp;quot;\$@&amp;quot;
echo \\\$0 is: \$0
EOF
$ chmod +x  ~/bin/cargo-foo
$ cargo foo aa bb cc
args are: foo aa bb cc
$0 is: /home/kim/bin/cargo-foo
$ cargo help foo aa bb cc
args are: foo -h
$0 is: /home/kim/bin/cargo-foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと独特な引数の渡り方をしてますね。しかし予め了解しておけば特に問題はなさそうです。1つサブコマンドを作ってみましょう。&lt;/p&gt;

&lt;p&gt;指定した名前のパッケージをCargo.tomlのdependenciesに書き足してくれるサブコマンドです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
usage(){
    cat &amp;lt;&amp;lt;EOF
Add the dependency of crate to Cargo.toml

Usage:
    cargo use &amp;lt;crate&amp;gt; [version]
    cargo use -h | --help

Description:
    Add the dependency of crate to Cargo.toml.
    If vension is omitted, adopt the latest version.

EOF
}

version(){
    cargo search &amp;quot;$1&amp;quot; | grep -Eo &amp;quot;^$1 \(.*?\)&amp;quot; | sed &amp;quot;s/^$1 (\(.*\))/\1/&amp;quot;
}

find_cargo(){
    # TODO: look up parent directories
    ls | grep &#39;^Cargo.toml$&#39;
}

ensure_dep_exists(){
    cargo=&amp;quot;$1&amp;quot;
    if ! grep -F &#39;[dependencies]&#39; &amp;quot;$cargo&amp;quot; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then
        echo &#39;[dependencies]&#39; &amp;gt;&amp;gt; &amp;quot;$cargo&amp;quot;
    fi
}

insert_dep(){
    cargo=&amp;quot;$1&amp;quot;
    crate=&amp;quot;$2&amp;quot;
    version=&amp;quot;$3&amp;quot;
    # FIXME: Because Linux and Mac behaves defferently on null string argument, don&#39;t use it and adopt workaround.
    sed -i&#39;&#39; &amp;quot;/\[dependencies\]/{a\
$crate = \&amp;quot;$version\&amp;quot;
}&amp;quot; &amp;quot;$cargo&amp;quot;
}

run(){
    CARGO_TOML=&amp;quot;$(find_cargo)&amp;quot;
    if [ $? != 0 ]
    then
        echo &amp;quot;Cargo.toml not found&amp;quot; 1&amp;gt;&amp;amp;2
        exit 1
    fi

    if [ -z &amp;quot;$1&amp;quot; ]; then
        usage
        exit 1
    else
        CRATE=&amp;quot;$1&amp;quot;
    fi

    if [ -z &amp;quot;$2&amp;quot; ]; then
        VERSION=&amp;quot;$(version $1)&amp;quot;
    else
        VERSION=&amp;quot;$2&amp;quot;
    fi

    ensure_dep_exists &amp;quot;$CARGO_TOML&amp;quot;
    insert_dep &amp;quot;$CARGO_TOML&amp;quot; &amp;quot;$CRATE&amp;quot; &amp;quot;$VERSION&amp;quot;    
}

main(){
    # $1 is &amp;quot;use&amp;quot; when called as a cargo plugin
    if [ &amp;quot;$1&amp;quot; != use ]; then
        echo &amp;quot;Use this as a cargo plugin&amp;quot;
        usage
        exit 1
    fi
    shift
    if [ &amp;quot;$1&amp;quot; = -h ] || [ &amp;quot;$1&amp;quot; = --help ]; then
        usage
        exit
    else
        run &amp;quot;$@&amp;quot;
    fi
}


main &amp;quot;$@&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだ洗練されていませんがお気に入りのタスクです。誰かCLIからCargo.tomlをいじれるツール作ってくれないかな。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustで小さなツールを作ってみる(後編)</title>
      <link>http://keens.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_</link>
      <pubDate>Sun, 29 Nov 2015 13:54:39 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 2日目の記事です。&lt;br /&gt;
前 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru/&#34;&gt;Rustで小さなツールを作ってみる(前編)&lt;/a&gt;&lt;br /&gt;
次 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/cargonotsukaikata/&#34;&gt;Cargoの使い方&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。昨日の記事で作りかけだったIRCの生ログのDBへのインポートの続きです。今日はDBへのインポートをやります。&lt;/p&gt;

&lt;p&gt;とはいってもRustでDBを扱った経験がないので探り探りです。&lt;/p&gt;

&lt;h1 id=&#34;要件:b5100d6caeb6e32800002ace57fa8102&#34;&gt;要件&lt;/h1&gt;

&lt;p&gt;今回は簡単なのでORMは要らない気がしますが、サンプルということでORMも使いましょう。さらに、サンプルということでクエリビルダも使いましょう。&lt;/p&gt;

&lt;p&gt;…と思ったのですが中々良いライブラリがありませんでした。ドキュメントもろくにないまま放置されてる&lt;a href=&#34;https://github.com/deuterium-orm/deuterium&#34;&gt;deuterium&lt;/a&gt;と開発途中でまだpostgresしかサポートされていない&lt;a href=&#34;https://github.com/ivanceras/rustorm&#34;&gt;rustorm&lt;/a&gt;/&lt;a href=&#34;https://github.com/ivanceras/codegenta&#34;&gt;codegenta&lt;/a&gt;くらいしかないようです。うぅ。
最近話題になった&lt;a href=&#34;https://github.com/sgrif/diesel&#34;&gt;diesel&lt;/a&gt;もまだ若すぎるようです。&lt;/p&gt;

&lt;p&gt;ということでシンプルなDBIを使います。そろそろ牡蠣の美味しい季節ですしSQL生書きしましょう。当たると怖いですが。で、テスト用にsqlite3を、（今回は使いませんが）本番用（？）にMySQLを使える奴を捜しましょう。&lt;/p&gt;

&lt;h1 id=&#34;ライブラリ捜し:b5100d6caeb6e32800002ace57fa8102&#34;&gt;ライブラリ捜し&lt;/h1&gt;

&lt;p&gt;まずは&lt;a href=&#34;https://crates.io&#34;&gt;crates.io&lt;/a&gt;を捜します。&amp;rdquo;sqlite&amp;rdquo;で捜せばいいでしょうか。&lt;/p&gt;

&lt;p&gt;MySQLとSQLite3をサポートしているライブラリ…&lt;a href=&#34;https://github.com/sfackler/r2d2&#34;&gt;r2d2&lt;/a&gt;がそれのようです。
コネクションプールのライブラリなので何か違う気がしますが、mysqlもsqlite3も扱えて、結果コネクションを抽象化してくれるので大体大丈夫です。&lt;/p&gt;

&lt;p&gt;蛇足ですが、名前はJavaにc3p0というコネクションプールがあるのでそこから来ているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;スキーマ定義:b5100d6caeb6e32800002ace57fa8102&#34;&gt;スキーマ定義&lt;/h1&gt;

&lt;p&gt;SQLiteを使い慣れないのですが大したことやってないので大丈夫でしょう。&lt;code&gt;DATETIME&lt;/code&gt; 型がないのが苦しいですね。&lt;/p&gt;

&lt;p&gt;自然キーが文字列や複合キーなのでサロゲートキーを使って自然キーにUNIQUE制約をかけてますがちょっと気持悪いですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- _*_ mode: sql; sql-product: &#39;sqlite _*_

CREATE TABLE servers(
        id   INTEGER PRIMARY KEY,
        name  TEXT NOT NULL UNIQUE,
        address TEXT
        );
m
CREATE TABLE channels(
        id INTEGER PRIMARY KEY,
        server_id INTEGER REFERENCES servers(id) ON UPDATE CASCADE,
        name TEXT NOT NULL,
        UNIQUE(server_id, name)
        );

CREATE TABLE entries(
        id INTEGER PRIMARY KEY,
        channel_id INTEGER REFERENCES channels(id) ON UPDATE CASCADE,
        user_id INTEGER REFERENCES users(i) ON UPDATE CASCADE,
        type TEXT NOT NULL,
        body TEXT NOT NULL,
        created_at TEXT NOT NULL
        );

CREATE TABLE users(
        id INTEGER PRIMARY KEY,
        server_id INTEGER REFERENCES servers(id) ON UPDATE CASCADE,
        name TEXT NOT NULL,
        UNIQUE(server_id, name)
        );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをetc/schema.sqlに保存します。&lt;/p&gt;

&lt;h1 id=&#34;モデル定義:b5100d6caeb6e32800002ace57fa8102&#34;&gt;モデル定義&lt;/h1&gt;

&lt;p&gt;折角シンプルなツールを作っているのでモデルは使わない。&lt;/p&gt;

&lt;h1 id=&#34;コネクションまで:b5100d6caeb6e32800002ace57fa8102&#34;&gt;コネクションまで&lt;/h1&gt;

&lt;p&gt;あらかじめ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sqlite test.db &amp;lt; etc/schema.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてDBを作っておきましょう。&lt;/p&gt;

&lt;p&gt;Cargo.tomlのdependenciesには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;r2d2_sqlite = &amp;quot;0.0.3&amp;quot;
r2d2 = &amp;quot;0.6.1&amp;quot;
rusqlite = &amp;quot;0.4.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記。&lt;/p&gt;

&lt;p&gt;src/main.rsの先頭部分に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate r2d2;
extern crate r2d2_sqlite;
extern crate rusqlite;
use std::sync::Arc;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::SqliteError;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記しましょう。&lt;/p&gt;

&lt;p&gt;そしてmainの中に次を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let manager = SqliteConnectionManager::new(&amp;quot;test.db&amp;quot;).unwrap();
    let config = r2d2::Config::builder().pool_size(16).build();
    let pool = Arc::new(r2d2::Pool::new(config, manager).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで一旦コンパイル。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これが通れば良いです。&lt;/p&gt;

&lt;h1 id=&#34;はじめての挿入:b5100d6caeb6e32800002ace57fa8102&#34;&gt;はじめての挿入&lt;/h1&gt;

&lt;p&gt;INSERTを発行してみましょう。&lt;code&gt;on_channel_dir&lt;/code&gt;の引数を変える必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path, pool: Arc&amp;lt;r2d2::Pool&amp;lt;SqliteConnectionManager&amp;gt;&amp;gt;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;併せて、呼び出しも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        on_channel_dir(&amp;amp;path, pool.clone());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;/p&gt;

&lt;p&gt;そうしたら&lt;code&gt;on_channel_dir&lt;/code&gt;の中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていた辺でまずはserversへのインサートを発行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let conn = pool.get().unwrap();
    let server_id = match conn.execute(&amp;quot;INSERT INTO servers (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;server]) {
        // unique constraint failed
        Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM servers WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;server], |r| r.get(0)).unwrap(),
        Ok(_) =&amp;gt; conn.last_insert_rowid(),
        e =&amp;gt; {e.unwrap(); return}
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プールからコネクションを持ってきて&lt;code&gt;INSERT&lt;/code&gt;を発行します。成功するか既にUNIQUEな名前が存在していて失敗したらサーバのidを持ってきます。それ以外の失敗だったらそのままパニックしていいでしょう。&lt;/p&gt;

&lt;p&gt;しかしラッパがちょっと雑すぎやしませんかね。エラーステータスくらいenumでラップして欲しかった。&lt;/p&gt;

&lt;p&gt;同じくチャネルもインサートしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel_id = match conn.execute(&amp;quot;INSERT INTO channels (name, server_id) VALUES ($1, $2)&amp;quot;, &amp;amp;[&amp;amp;channel, &amp;amp;server_id]) {
        // unique constraint failed
        Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM channels WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;channel], |r| r.get(0)).unwrap(),
        Ok(_) =&amp;gt; conn.last_insert_rowid(),
        e =&amp;gt; {e.unwrap(); return}

    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こういうupsertというかinsert or get_idってどうやるのが正解なんでしょう。DB力が低い…&lt;/p&gt;

&lt;h1 id=&#34;エントリのインサート:b5100d6caeb6e32800002ace57fa8102&#34;&gt;エントリのインサート&lt;/h1&gt;

&lt;p&gt;同じく&lt;code&gt;on_log&lt;/code&gt;の引数を増やします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_log(log: &amp;amp;Path, channel_id: i64,  pool: Arc&amp;lt;r2d2::Pool&amp;lt;SqliteConnectionManager&amp;gt;&amp;gt;) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し側も。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let pool_ = pool.clone();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log, channel_id, pool_))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt;する前に&lt;code&gt;clone&lt;/code&gt;しないとダメですね。所有権難しい。&lt;/p&gt;

&lt;p&gt;さて、今度は色々することがあります。
まず、dateとtimeをくっつけてdatetimeにしましょう。timeがイミュータブルだったので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let mut time = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とし、その下で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        time.tm_mday = date.tm_mday;
        time.tm_mon = date.tm_mon;
        time.tm_year = date.tm_year;
        let created_at = time.to_timespec();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。わざわざ&lt;code&gt;to_timespec&lt;/code&gt;で変換してるのは&lt;code&gt;Timespec&lt;/code&gt;だとDBライブラリが良い感じに変換してくれるからですね。&lt;/p&gt;

&lt;p&gt;次にメッセージの抜き出し部分も値を返すように変更。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let (user, type_, body) = match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;sysmsg&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;join&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;part&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; (user, &amp;quot;msg&amp;quot;, body),
                None =&amp;gt; {
                    warn!(&amp;quot;cannot parse the entry; skipping&amp;quot;);
                    continue;
                }
            },
            _ =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;notice&amp;quot;, &amp;amp;msg[1..]),
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまで来たらあとはユーザとエントリをインサートするだけですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let conn = pool.get().unwrap();
        let user_id = match conn.execute(&amp;quot;INSERT INTO users (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;user]) {
            // unique constraint failed
            Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM users WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;user], |r| r.get(0)).unwrap(),
            Ok(_) =&amp;gt; conn.last_insert_rowid(),
            e =&amp;gt; {e.unwrap(); return}
        };
        conn.execute(&amp;quot;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)&amp;quot;, &amp;amp;[&amp;amp;channel_id, &amp;amp;user_id, &amp;amp;type_, &amp;amp;body, &amp;amp;created_at]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦これで走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#hongo@utmc/2015-02-15.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-08-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-12-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-02-26.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-05-23.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-04-30.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2013-10-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-14.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-01-19.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-08-12.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-06-03.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-02-05.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あちゃー。マルチスレッドでINSERTしてるのでロックが掛かってますね。SQLiteはファイルロックしか持たないので並列インサートはつらそう。&lt;/p&gt;

&lt;h1 id=&#34;トランザクション:b5100d6caeb6e32800002ace57fa8102&#34;&gt;トランザクション&lt;/h1&gt;

&lt;p&gt;はい、そういう時のトランザクションですよ。&lt;/p&gt;

&lt;p&gt;最後のユーザやエントリーをインサートしてる部分で使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let conn = pool.get().unwrap();
        let trx = conn.transaction().unwrap();
        let user_id = match conn.execute(&amp;quot;INSERT INTO users (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;user]) {
            // unique constraint failed
            Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM users WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;user], |r| r.get(0)).unwrap(),
            Ok(_) =&amp;gt; conn.last_insert_rowid(),
            e =&amp;gt; {e.unwrap(); return}
        };
        trx.commit();
        let trx = conn.transaction().unwrap();
        conn.execute(&amp;quot;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)&amp;quot;, &amp;amp;[&amp;amp;channel_id, &amp;amp;user_id, &amp;amp;type_, &amp;amp;body, &amp;amp;created_at]);
        trx.commit();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排他制御が目的なのでトランザクションを2回取ってます。&lt;/p&gt;

&lt;p&gt;これだとどうなるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#hongo@utmc/2015-02-15.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-08-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-12-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-02-26.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-05-23.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-04-30.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2013-10-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-14.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-01-19.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-08-12.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-06-03.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-02-05.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーは減ったもののまだ出ます。&lt;/p&gt;

&lt;h1 id=&#34;その他:b5100d6caeb6e32800002ace57fa8102&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;他にスレッドプールを使って並列度を下げる、ワーカースレッドを使ってSQLiteへの書き込みを1スレッドにするなども試したのですが上手く行きませんでした。&lt;/p&gt;

&lt;p&gt;スレッドプールについては、今回エラーハンドリングのためにスレッドを立てている訳ですが、パニックを出してスレッドが死ぬとあまり思わしくない挙動をするのでダメでした。&lt;/p&gt;

&lt;p&gt;ワーカースレッドは書き込んだ後にまたchannel_idなどを受け取らないといけないのでやめました。promiseなどを使えば上手くいきそうな気もしますが色々面倒そうなので止めておきます。&lt;/p&gt;

&lt;h1 id=&#34;コネクション:b5100d6caeb6e32800002ace57fa8102&#34;&gt;コネクション&lt;/h1&gt;

&lt;p&gt;並列度を下げる方法はもう1つあります。&lt;/p&gt;

&lt;p&gt;mainの中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let config = r2d2::Config::builder().pool_size(16).build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていたのを覚えていますでしょうか。これはコネクションプールに16個のコネクションを持っています。この数を落とせばなんとかならないでしょうか。&lt;/p&gt;

&lt;p&gt;結論からいうとダメでした。今度は複数スレッドがコネクションを取り合ってタイムアウトが発生してしまいます。&lt;/p&gt;

&lt;h1 id=&#34;並列度を下げる:b5100d6caeb6e32800002ace57fa8102&#34;&gt;並列度を下げる&lt;/h1&gt;

&lt;p&gt;最後の最後、本当に並列度を下げる方法があります。スレッドを立てていた部分で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let threads = logs.map(|log| {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log))
    }).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
    for thread in threads {
        let _ = thread.unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていました。これはファイル数分並列に実行してしまいます。ここを抑えましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    for log in logs {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        let pool_ = pool.clone();
        let _ = Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log, channel_id, pool_)).unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;spawn&lt;/code&gt;してそのまま&lt;code&gt;join&lt;/code&gt;します。こうすれば並列度を抑えつつパニックをスレッドに分離出来ます。&lt;/p&gt;

&lt;p&gt;これで実行するとどうなるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#lisp-ja@freenode/2015-04-08.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いくつかタイムアウトを出します。えー。並列度1でこれならもうどうしようもないでしょう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:b5100d6caeb6e32800002ace57fa8102&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;さて、小さなツールを作るというタイトルにしては後半(執筆が)重い内容になってしまいました。というか、sqlite3の問題もしますが。&lt;/p&gt;

&lt;p&gt;このブログの内容としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rustでディレクトリを扱った&lt;/li&gt;
&lt;li&gt;ファイルを扱った&lt;/li&gt;
&lt;li&gt;文字列を扱った&lt;/li&gt;
&lt;li&gt;日付を扱った&lt;/li&gt;
&lt;li&gt;スレッドを扱った&lt;/li&gt;
&lt;li&gt;ロガーライブラリを扱った&lt;/li&gt;
&lt;li&gt;エラーハンドリングをした&lt;/li&gt;
&lt;li&gt;パニックのハンドリングをした&lt;/li&gt;
&lt;li&gt;DBを扱った&lt;/li&gt;
&lt;li&gt;sqlite3に並列書き込みはつらい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ボツ案も含めれば私個人はORMやスレッドプール、チャネルも扱いましたが関係ないですね。&lt;/p&gt;

&lt;p&gt;こういう簡単なツールでも思ったより色々な機能を触れるのでみなさん試してみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;ソースコード全体は&lt;a href=&#34;https://github.com/KeenS/irc_log&#34;&gt;ここ&lt;/a&gt;においておきます。&lt;/p&gt;

&lt;p&gt;因みに本筋とは外れますが、今回のSQLiteの問題を扱うには一旦CSVファイルに書き出してからCSVインポートでバルクインサートが考えられます。
CSVに書き出すのはちまちまやってもいいし今回のデータ量ならオンメモリ構築して一気に書き出しも出来るでしょう。あるいはSQLiteをやめてMySQLを使う。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustで小さなツールを作ってみる(前編)</title>
      <link>http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru</link>
      <pubDate>Sat, 14 Nov 2015 23:57:43 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 1日目の記事です。&lt;br /&gt;
次 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_/&#34;&gt;Rustで小さなツールを作ってみる(後編)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。Rust Advent Calendar初日ということで軽い話から。
小さなツールって何だよって感じですが手元にIRCの生ログが大量にあるのでそれをDBにインポートしてみましょう。
あまりRustに向いた仕事じゃなさそうですが手始めとして。&lt;/p&gt;

&lt;p&gt;前編でログのパースを、後編でDBへのインポートをやります。&lt;/p&gt;

&lt;p&gt;IRCの生ログは&lt;a href=&#34;http://www.clovery.jp/tiarra/&#34;&gt;tiarra&lt;/a&gt;が吐いたものです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#emacs@freenode&lt;/code&gt;のように&lt;code&gt;チャネル名@サーバ名&lt;/code&gt;のディレクトリに入っていて、ファイル名は&lt;code&gt;YYYY-mm-dd.txt&lt;/code&gt;で、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;13:43:24 &amp;lt;#emacs@freenode:codingquark&amp;gt; Such key generation, much wow.
13:43:59 ! Vejeta` (Ping timeout: 264 seconds)
13:44:30 + jcazevedo (jcazevedo!~jcazevedo@a94-132-141-99.cpe.netcabo.pt) to #emacs@freenode
13:45:30 + quazimodo (quazimodo!~quazimodo@155.143.14.28) to #emacs@freenode
13:45:32 ! Hugehead_ (Read error: Connection reset by peer)
13:48:48 + favadi (favadi!~textual@113.190.4.106) to #emacs@freenode
13:51:06 wizzo -&amp;gt; bitchimightbe
13:52:23 bitchimightbe -&amp;gt; wizzo
13:53:05 - frost3772 from #emacs@freenode (&amp;quot;ERC (IRC client for Emacs 24.5.1)&amp;quot;)
13:56:37 ! chandan (Quit: WeeChat 1.2)
13:56:38 ! plunderous (Read error: Connection res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような形式で入ってます。先頭に&lt;code&gt;&amp;lt;&lt;/code&gt;が付いてるのが発言、&lt;code&gt;!&lt;/code&gt;がついてるのがなんかメッセージ(多分quitとかkillとか)、&lt;code&gt;+&lt;/code&gt;がjoin、&lt;code&gt;-&lt;/code&gt;がpart、無しがnickとかnoticeですかね。他にもログ取ってるircコマンドはあるのですが&lt;code&gt;!&lt;/code&gt;に内包されてそうですね(tiarraのマニュアルに載ってそうですが見るの面倒)&lt;/p&gt;

&lt;p&gt;因みにログ全体は&lt;code&gt;~/log&lt;/code&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;一応treeするとこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── #emacs@freenode
│   ├── 2014-04-11.txt
│   ├── 2014-04-12.txt
│   ├── 2014-04-13.txt
..  ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2014-04-11から2015-11-01までの間ロギングしてます。&lt;/p&gt;

&lt;h1 id=&#34;ディレクトリリスティングまで:a7315be0136fc976c0c4320441efd799&#34;&gt;ディレクトリリスティングまで&lt;/h1&gt;

&lt;p&gt;まずは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new irc_log --bin
$ cd irc_log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;code&gt;src/main.rs&lt;/code&gt;を開いて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs;

fn main() {
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, path.to_string_lossy().to_string());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きましょう。path path煩いですね。OSの返す文字列(Cの文字列)とRustの文字列の違いだとか一旦&lt;code&gt;Path&lt;/code&gt;で抽象化してるだとかで文字列を抜き出すのは一苦労です。&lt;/p&gt;

&lt;p&gt;さて、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でディレクトリ名が出てくればOK。&lt;/p&gt;

&lt;h1 id=&#34;ファイル名リスティング:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイル名リスティング&lt;/h1&gt;

&lt;p&gt;mainを&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs;

fn main() {
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        on_channel_dir(&amp;amp;path);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と置き換えてチャネルのディレクトリでの作業は&lt;code&gt;on_channel_dir&lt;/code&gt;でやりましょう。&lt;/p&gt;

&lt;h2 id=&#34;チャネル名とサーバ名の抜き出し:a7315be0136fc976c0c4320441efd799&#34;&gt;チャネル名とサーバ名の抜き出し&lt;/h2&gt;

&lt;p&gt;ディレクトリ名が&lt;code&gt;チャネル名@サーバ名&lt;/code&gt; の 形をしているので @の前後を抜き出せば良さそうです。&lt;/p&gt;

&lt;p&gt;src/main.rsの先頭に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::path::Path;
use std::str::from_utf8;
use std::os::unix::prelude::OsStrExt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でとりあえず&lt;code&gt;/&lt;/code&gt;の付かないディレクトリ名を取れそうです。難しい。やはりOSの返す文字列の扱いは面倒ですね。
しかし一旦Rustの文字列になってしまえばこちらのもの。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;@&lt;/code&gt;の位置を取得出来ます。&lt;code&gt;@&lt;/code&gt;がなかったらreturnして無視しておきましょう（実際そういう名前のディレクトリがあるのですが今回の集計の対象外なので）。&lt;/p&gt;

&lt;p&gt;あとは部分文字列を取るだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ファイルリスティング:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルリスティング&lt;/h2&gt;

&lt;p&gt;これは先程と同じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        let log = log.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, log.to_string_lossy().to_string());
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、&lt;code&gt;on_channel_dir&lt;/code&gt;全体はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        let log = log.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, log.to_string_lossy().to_string());
    };
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ファイルのパース:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルのパース&lt;/h1&gt;

&lt;p&gt;次にまた&lt;code&gt;println!&lt;/code&gt;の部分を&lt;code&gt;on_log&lt;/code&gt;としてファイルをパースしていきましょう。&lt;/p&gt;

&lt;h2 id=&#34;日付の抜き出し:a7315be0136fc976c0c4320441efd799&#34;&gt;日付の抜き出し&lt;/h2&gt;

&lt;p&gt;先程と似てますので飛ばし気味にいきます。&lt;/p&gt;

&lt;p&gt;簡単にやっても良いのですがお作法として日付ライブラリを使ってパースしましょう。
&lt;code&gt;Cargo.toml&lt;/code&gt;に以下を追記。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]
time = &amp;quot;*&amp;quot;
log = &amp;quot;0.3.3&amp;quot;
env_logger = &amp;quot;0.3.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本当はバージョンも指定した方が良いのですが書き捨てのコードなのでまあ、良いでしょう。因みにtimeライブラリ自体扱いづらいとか色々問題があるのですがそれは後のAdvent Calendarに譲りましょう。しれっとloggerも導入します。printfデバッグにlogger便利!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;してdependenciesをインストールします。因みに&lt;code&gt;log&lt;/code&gt;がlogger facadで&lt;code&gt;env_logger&lt;/code&gt;がloggerの実装です。使い方は後程。&lt;/p&gt;

&lt;p&gt;またsrc/main.rsの先頭に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[macro_use]
extern crate log;
extern crate env_logger;
extern crate time;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記。&lt;/p&gt;

&lt;p&gt;そして&lt;code&gt;on_log&lt;/code&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_log(log: &amp;amp;Path) {
    let datestr = from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();
    let date = time::strptime(&amp;amp;datestr, &amp;quot;%Y-%m-%d&amp;quot;).urwrap();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は失敗しないことが分かってるので全部&lt;code&gt;unwrap&lt;/code&gt;してます。本当は&lt;code&gt;try!&lt;/code&gt;を使って上流に委ねた方がいいのですが今回は面倒なのでこうしちゃってます。正しいエラーハンドリングはtrplの&lt;a href=&#34;https://doc.rust-lang.org/book/error-handling.html&#34;&gt;Error Handling&lt;/a&gt;を読みましょう。&lt;/p&gt;

&lt;h2 id=&#34;ファイルの読み出し:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルの読み出し&lt;/h2&gt;

&lt;h3 id=&#34;開く:a7315be0136fc976c0c4320441efd799&#34;&gt;開く&lt;/h3&gt;

&lt;p&gt;コードをいきなり載せると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let file = match fs::File::open(log) {
        Ok(f) =&amp;gt; f,
        Err(e) =&amp;gt; {
            error!(&amp;quot;could not open {}; skipping.&amp;quot;, log.display());
            return;
        }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。これはエラーハンドリングします。1つのファイルに失敗しても次があるので。ここで使ってる&lt;code&gt;error!&lt;/code&gt;がloggerのマクロです。&lt;/p&gt;

&lt;h2 id=&#34;行毎の読み出し:a7315be0136fc976c0c4320441efd799&#34;&gt;行毎の読み出し&lt;/h2&gt;

&lt;p&gt;行毎の読み出しはバッファーリーダーが必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io::BufReader;
use std::io::BufRead;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をsrc/main.rsの先頭部分に追記しましょう。因みに&lt;code&gt;BufRead&lt;/code&gt;がトレイトで、&lt;code&gt;BufReader&lt;/code&gt;が実装です。実装が必要なのは良いとして、トレイトまで必要なのはトレイトで定義された関数を呼び出すのにトレイトのインポートが必要だからですね。&lt;/p&gt;

&lt;p&gt;さてさて、行の読み出しを進めます。先程オープンしたファイルを&lt;code&gt;BufReader&lt;/code&gt;で包んでやればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let br = BufReader::new(&amp;amp;file);
    for line in br.lines() {
        let line = match line {
            Ok(l) =&amp;gt; l,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;ignoring error {}&amp;quot;, e);
                continue;
            }
        };
        ....
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行の読み出し結果もResultで返ってくるんですね。これも失敗したら読み飛ばせばいいので&lt;code&gt;urwrap&lt;/code&gt;せずに扱います。&lt;/p&gt;

&lt;h2 id=&#34;行のパース:a7315be0136fc976c0c4320441efd799&#34;&gt;行のパース&lt;/h2&gt;

&lt;h3 id=&#34;ガード:a7315be0136fc976c0c4320441efd799&#34;&gt;ガード&lt;/h3&gt;

&lt;p&gt;先頭部分の時間をパースする時に部分文字列を抜き出しますが、変な行だと10文字もなかったりするので一旦ガードを付けておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        if line.len() &amp;lt; 10 {
            warn!(&amp;quot;ignoring line {}&amp;quot;, line);
            continue;
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;時間のパース:a7315be0136fc976c0c4320441efd799&#34;&gt;時間のパース&lt;/h3&gt;

&lt;p&gt;これはファイル名の時とほぼ同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let time = match time::strptime(&amp;amp;line[0..8], &amp;quot;%H:%M:%S&amp;quot;) {
            Ok(t) =&amp;gt; t,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;Parse error {}; ignoring&amp;quot;, e);
                continue;

            }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度は変な行が紛れてそうな（実際、ログファイルにはよくある）のでエラーは無視します。&lt;/p&gt;

&lt;h3 id=&#34;メッセージのパース:a7315be0136fc976c0c4320441efd799&#34;&gt;メッセージのパース&lt;/h3&gt;

&lt;p&gt;0-8文字目に時間があって、1スペース挟むので9文字目からがメッセージですね。そして先頭の文字で判断出来るのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let msg = &amp;amp;line[9..];
        match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; println!(&amp;quot;sysmsg {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; println!(&amp;quot;join {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; println!(&amp;quot;part {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; println!(&amp;quot;user: {} body: {}&amp;quot;, user, body),
                None =&amp;gt; ()
            },
            _ =&amp;gt; println!(&amp;quot;info {}&amp;quot;, &amp;amp;msg[1..]),
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で判断出来そうです。パースした後の話は後回し。&lt;/p&gt;

&lt;h1 id=&#34;ソース全体:a7315be0136fc976c0c4320441efd799&#34;&gt;ソース全体&lt;/h1&gt;

&lt;p&gt;ソースの断片が続いたので一旦ここまでの全体像を出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[macro_use]
extern crate log;
extern crate env_logger;
extern crate time;
use std::str::from_utf8;
use std::io::BufReader;
use std::io::BufRead;
use std::fs;
use std::path::Path;
use std::os::unix::prelude::OsStrExt;


fn on_log(log: &amp;amp;Path) {
    let datestr = from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();
    let date = time::strptime(&amp;amp;datestr, &amp;quot;%Y-%m-%d&amp;quot;);
    let file = match fs::File::open(log) {
        Ok(f) =&amp;gt; f,
        Err(e) =&amp;gt; {
            error!(&amp;quot;could not open {}; skipping.&amp;quot;, log.display());
            return;
        }
    };
    let br = BufReader::new(&amp;amp;file);
    for line in br.lines() {
        let line = match line {
            Ok(l) =&amp;gt; l,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;ignoring error {}&amp;quot;, e);
                continue;
            }
        };
        if line.len() &amp;lt; 10 {
            warn!(&amp;quot;ignoring line {}&amp;quot;, line);
            continue;
        }
        let time = match time::strptime(&amp;amp;line[0..8], &amp;quot;%H:%M:%S&amp;quot;) {
            Ok(t) =&amp;gt; t,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;Parse error {}; ignoring&amp;quot;, e);
                continue;

            }
        };
        let msg = &amp;amp;line[9..];
        match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; println!(&amp;quot;sysmsg {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; println!(&amp;quot;join {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; println!(&amp;quot;part {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; println!(&amp;quot;user: {} body: {}&amp;quot;, user, body),
                None =&amp;gt; ()
            },
            _ =&amp;gt; println!(&amp;quot;info {}&amp;quot;, &amp;amp;msg[1..]),
        }
    }
}

fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        on_log(&amp;amp;log.unwrap().path());
    };
}


fn main(){
    env_logger::init().unwrap();
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        on_channel_dir(&amp;amp;path);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はmainの先頭で&lt;code&gt;env_logger::init().unwrap();&lt;/code&gt;でロガーの初期化してました。忘れてましたね。ごめんなさい。&lt;/p&gt;

&lt;p&gt;さて、これで一旦走らせてみましょう。動く筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動いてるようですが、遅い。出力が多くてターミナル側がボトルネックのようです。&lt;/p&gt;

&lt;h1 id=&#34;パニックハンドルとチューニング:a7315be0136fc976c0c4320441efd799&#34;&gt;パニックハンドルとチューニング&lt;/h1&gt;

&lt;p&gt;一旦メッセージを出力をやめて様子見してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;            &amp;quot;!&amp;quot; =&amp;gt; (),
            &amp;quot;+&amp;quot; =&amp;gt; (),
            &amp;quot;-&amp;quot; =&amp;gt; (),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; (),
            _ =&amp;gt; (),

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それでもまだ遅い上に謎のパニックが出てます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;/home/kim/log/#lisp@freenode&#39; panicked at &#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary&#39;, ../src/libcore/str/mod.rs:1311
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログを見てみましょう。env_loggerは環境変数からログレベルを渡してあげるとログを出します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ RUST_LOG=Trace cargo run
...
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意外と変な行が一杯あるのですね。しかしこれらはちゃんとエラーハンドリングしてるので問題ありません。&lt;/p&gt;

&lt;p&gt;各所で&lt;code&gt;unwrap&lt;/code&gt;してるせいな気もしますが、&lt;code&gt;urwrap&lt;/code&gt;のせいならそういうメッセージが出るので違います。&lt;/p&gt;

&lt;p&gt;実はこれ、非UTF-8のバイト列でrustの標準ライブラリが内部でパニックを出してます。
これの扱いも後のAdvent Calendarに譲るとして、ワークアラウンドを捜しましょう。rust1.4時点ではパニックをハンドルする手段はありません。&lt;/p&gt;

&lt;p&gt;パニックメッセージの先頭に&lt;code&gt;thread&lt;/code&gt;とついてるのでthreadで包めば良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;thread:a7315be0136fc976c0c4320441efd799&#34;&gt;Thread&lt;/h2&gt;

&lt;p&gt;まずはthreadをインポートします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::thread::Builder;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてon_channel_logを少し弄りましょう。無効なバイト列を含むファイルをざっくり切る感じで。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    for log in logs {
        on_log(&amp;amp;log.unwrap().path());
    };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていた部分を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let threads = logs.map(|log| {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log))
    }).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
    for thread in threads {
        let _ = thread.unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。一見複雑ですが、ファイル毎にスレッドを作って全部をvectorにして集めてそれぞれjoinを待ってるだけです。
そしてスレッド名を処理するファイル名にしたいのでスレッドビルダを使っています。&lt;/p&gt;

&lt;p&gt;さて、これで走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time cargo run
...
#lisp at freenode
thread &#39;/home/kim/log/#lisp@freenode/2014-08-18.txt&#39; panicked at &#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary&#39;, ../src/libcore/str/mod.rs:1311
#emacs at freenode
...
cargo run  327.21s user 8.71s system 630% cpu 53.289 total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lispチャネルの1ファイルだけに変なバイト列があることが分かりました。&lt;/p&gt;

&lt;p&gt;そしてパフォーマンスですが、とりあえず&lt;code&gt;top&lt;/code&gt;で見る限りCPUは最大770%使ってくれてます（8コアマシン）。ファイル毎にスレッド作ってるので若干リソースの食い合いが発生してますがこれだけ並列度があればスレッドプールを使うまでもないでしょう。&lt;/p&gt;

&lt;h2 id=&#34;さらなるチューニング:a7315be0136fc976c0c4320441efd799&#34;&gt;さらなるチューニング…？&lt;/h2&gt;

&lt;p&gt;しかしそれでもまだ遅いですね。ちょこっと書いては走らせるのサイクルを回すには耐えられません。&lt;/p&gt;

&lt;p&gt;そういえばログ全体のファイルサイズを確認してなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -h
...
774M   .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意外と小さい。まだチューニングの余地はありそうです。メモリアロケーションを減らしましょうか、それとも時間のパースを手書きでやりましょうか。&lt;/p&gt;

&lt;p&gt;いいえ。もっと簡単に速くする方法があります。&lt;code&gt;--release&lt;/code&gt;をつけて実行すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
...
cargo run --release  3.63s user 5.44s system 203% cpu 4.453 total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(/ 53.289 4.453);=&amp;gt; 11.966988547046935&lt;/code&gt; 。12倍速くなりました。1ディレクトリ700以上のファイルがあってそれぞれにスレッドを作っているのでそろそろそのオーバーヘッドが効いてきてますね。&lt;/p&gt;

&lt;p&gt;スレッドプールを試してみたい気もしますがひとまずこれで置いておきましょう。&lt;/p&gt;

&lt;p&gt;次は後編、DBへのインポートです。&lt;/p&gt;

&lt;p&gt;蛇足ですが行のパースのところは正規表現でも出来ましたね。そっちの方が好きな方は試してみて下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一時ファイルの作り方</title>
      <link>http://keens.github.io/blog/2015/11/08/ichijifairunotsukurikata</link>
      <pubDate>Sun, 08 Nov 2015 21:40:14 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/08/ichijifairunotsukurikata</guid>
      <description>

&lt;p&gt;Rustに&lt;a href=&#34;https://github.com/Stebalien/tempfile&#34;&gt;tempfile&lt;/a&gt;というライブラリがある。その名の通りテンポラリファイルを作るライブラリだ。
必要に迫られてそのライブラリにPRを送ろうとして実装を読んだのだが普段あまり意識しなかったテンポラリファイルの作り方を知ったのでちょっと解説してみる。&lt;/p&gt;

&lt;p&gt;Rustはほぼそのままの使い心地でCのライブラリを呼べるのでCが分かる人になら伝わると思う。&lt;/p&gt;

&lt;p&gt;ライブラリの構成として、src/*.rsにOS非依存なコードやユーザ向けのAPIがあり、src/imp/{windows,unix}.rsにOS依存なコードがある。
私はWindowsの実装には興味ないし詳しくもないのでunix向けの実装だけを見る。&lt;/p&gt;

&lt;p&gt;imp以下を見る前にこのライブライが提供するAPIを解説しておくと、大きく分けて&lt;code&gt;TempFile&lt;/code&gt;と&lt;code&gt;NamedTempFile&lt;/code&gt;がある。無名、Namedどちらにもデフォルトの一時ファイルディレクトリ下に一時ファイルを作るAPIと指定したディレクトリ以下に作るAPIとがある。
&lt;code&gt;TempFile&lt;/code&gt;が作るファイルは完全に匿名で、ファイルシステムに残らない。I/Oが出来るストリームだけを返す。定期的に/tmp以下を削除するジョブが走っていたとしても安全だし、他のプロセスに中身を読まれる危険性もない。
一方&lt;code&gt;NamedTempFile&lt;/code&gt;の方は予測不可能なファイル名でファイルを作るものの、ファイルシステムに残るので安全ではない。しかしファイル名を要求する関数や外部プロセスと協調する時に使える。&lt;/p&gt;

&lt;p&gt;それぞれで実装を見ていく。&lt;/p&gt;

&lt;h1 id=&#34;tempfile:047d25333d01b489b97d09f703fb9afe&#34;&gt;TempFile&lt;/h1&gt;

&lt;p&gt;これはLinuxとその他で実装が分かれる。ユーザーAPI側でテンポラリファイルを作るディレクトリの指定は吸収しているのでこちらではただ指定されたディレクトリ下にテンポラリファイルを作ればいい。&lt;/p&gt;

&lt;h2 id=&#34;linux:047d25333d01b489b97d09f703fb9afe&#34;&gt;Linux&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(target_os = &amp;quot;linux&amp;quot;)]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    const O_TMPFILE: libc::c_int = 0o20200000;
    match unsafe {
        libc::open(try!(cstr(dir)).as_ptr(), O_CLOEXEC | O_EXCL | O_TMPFILE | O_RDWR, 0o600)
    } {
        -1 =&amp;gt; create_unix(dir),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux 3.11から&lt;code&gt;O_TMPFILE&lt;/code&gt;が入ったので実装は直接的だ。&lt;code&gt;O_TMPFILE&lt;/code&gt;はテンポラリファイル向けにファイルシステムに名前が登録されない匿名のファイルを作る。Lispのgensymに似ている。
O_EXCLでリンクによる別名での参照を回避し、Linux 2.6.23以後で入ったO_CLOEXECで&lt;code&gt;exec(2)&lt;/code&gt;した時にfdを閉じるようにする。そうすれば関係のないプログラムからファイルが参照されるのを防げる。&lt;/p&gt;

&lt;p&gt;このライブラリコールが成功すればそのままFileを返す。&lt;/p&gt;

&lt;p&gt;Linux 3.11未満やO_TMPFILEをサポートしないファイルシステムだったら失敗し、-1が返るのでLinuxに依存しない汎用の&lt;code&gt;create_unix&lt;/code&gt;にフォールバックする。&lt;/p&gt;

&lt;h2 id=&#34;unix:047d25333d01b489b97d09f703fb9afe&#34;&gt;Unix&lt;/h2&gt;

&lt;p&gt;Unix向けの実装は恐らくPOSIX互換なシステムなら全てで動く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(not(target_os = &amp;quot;linux&amp;quot;))]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    create_unix(dir)
}

fn create_unix(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        let tmp_path = dir.join(&amp;amp;tmpname());
        return match create_named(&amp;amp;tmp_path) {
            Ok(file) =&amp;gt; {
                // I should probably tell the user this failed but the temporary file creation
                // didn&#39;t really fail...
                let _ = fs::remove_file(tmp_path);
                Ok(file)
            },
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        }
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;汎用の&lt;code&gt;create_unix&lt;/code&gt;では完全に無名のテンポラリファイルを作るのを諦めて、一旦ランダム生成な名前のファイルを作って開き、成功したらそのファイルを削除する。
1つでも開いてるプロセスがある時に削除されるとUnixのファイルはそのプロセスからは見れるが他のプロセスからは見れない状態になるので色々便利に使われている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;create_named&lt;/code&gt;は後程見るとして、ランダム生成なファイル名だと稀に既に存在するファイル名と被る可能性があるので何度かリトライしている。
リトライ回数はsrc/lib.rsで定義されていて、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const NUM_RETRIES: u32 = 1 &amp;lt;&amp;lt; 31;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。思ったよりえけつない回数リトライしている。もちろん、ファイル名が被った以外の理由でファイル生成が失敗したのならリトライに意味はないので大人しくreturnしている。&lt;/p&gt;

&lt;p&gt;で、&lt;code&gt;create_named&lt;/code&gt;だが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    match unsafe {
        libc::open(try!(cstr(&amp;amp;path)).as_ptr(), O_CLOEXEC | O_EXCL | O_RDWR | O_CREAT, 0o600)
    } {
        -1 =&amp;gt; Err(io::Error::last_os_error()),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。単に&lt;code&gt;create&lt;/code&gt;のフラグの&lt;code&gt;O_TMPFILE&lt;/code&gt;が&lt;code&gt;O_CREAT&lt;/code&gt;になっただけ。&lt;/p&gt;

&lt;h1 id=&#34;namedtempfile:047d25333d01b489b97d09f703fb9afe&#34;&gt;NamedTempFile&lt;/h1&gt;

&lt;p&gt;こちらはユーザーAPIの中から直接OS互換用コードを呼んでいる。src/named.rsに実装がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    /// Create a new temporary file in the specified directory.
    pub fn new_in&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(dir: P) -&amp;gt; io::Result&amp;lt;NamedTempFile&amp;gt; {
        for _ in 0..::NUM_RETRIES {
            let path = dir.as_ref().join(&amp;amp;util::tmpname());
            return match imp::create_named(&amp;amp;path) {
                Ok(file) =&amp;gt; Ok(NamedTempFile(Some(NamedTempFileInner { path: path, file: file, }))),
                Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
                Err(e) =&amp;gt; Err(e),
            }
        }
        Err(io::Error::new(io::ErrorKind::AlreadyExists,
                           &amp;quot;too many temporary directories already exist&amp;quot;))
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値をユーザAPI向けにラップしている以外は無名の一時ファイルと変わらない。余談だがここで使われているファイル名にユーザが干渉することが出来ず、完全にランダムなファイル名になっている。
ファイルの末尾(例えば拡張子)や先頭(例えばapp_nameなどの識別子)を挟めない。私が今作業してるパッチはその辺をもう少し自由にするものだ。&lt;/p&gt;

&lt;p&gt;閑話休題。似たような実装が2つもあるのは気になるので一応windows向けの実装も読んでみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const ACCESS: DWORD     = winapi::FILE_GENERIC_READ
                        | winapi::FILE_GENERIC_WRITE;
const SHARE_MODE: DWORD = winapi::FILE_SHARE_DELETE
                        | winapi::FILE_SHARE_READ
                        | winapi::FILE_SHARE_WRITE;
const FLAGS: DWORD      = winapi::FILE_ATTRIBUTE_HIDDEN
                        | winapi::FILE_ATTRIBUTE_TEMPORARY;


fn to_utf16(s: &amp;amp;Path) -&amp;gt; Vec&amp;lt;u16&amp;gt; {
    s.as_os_str().encode_wide().chain(Some(0).into_iter()).collect()
}

fn win_create(path: &amp;amp;Path,
                     access: DWORD,
                     share_mode: DWORD,
                     disp: DWORD,
                     flags: DWORD) -&amp;gt; io::Result&amp;lt;File&amp;gt; {

    let path = to_utf16(path);
    let handle = unsafe {
        CreateFileW(
            path.as_ptr(),
            access,
            share_mode,
            0 as *mut _,
            disp,
            flags,
            ptr::null_mut())
    };
    if handle == winapi::INVALID_HANDLE_VALUE {
        Err(io::Error::last_os_error())
    } else {
        Ok(unsafe { File::from_raw_handle(handle as RawHandle) })
    }
}

pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    win_create(path, ACCESS, SHARE_MODE, winapi::CREATE_NEW, FLAGS)
}

pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        return match win_create(
            &amp;amp;dir.join(&amp;amp;tmpname()),
            ACCESS,
            SHARE_MODE,
            winapi::CREATE_NEW,
            FLAGS | winapi::FILE_FLAG_DELETE_ON_CLOSE)
        {
            Ok(f) =&amp;gt; Ok(f),
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        };
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows向けの実装は必ずファイル名を指定する必要があり、リトライが必要そう？&lt;code&gt;NamedTempFile&lt;/code&gt;を作るには(理論的に)どの実装でもリトライが必要だからユーザAPI側で纏めたのかな？&lt;/p&gt;

&lt;h1 id=&#34;まとめ:047d25333d01b489b97d09f703fb9afe&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;テンポラリファイルを作るならまずは&lt;code&gt;O_TMPFILE&lt;/code&gt;を試す&lt;/li&gt;
&lt;li&gt;ダメならランダム生成なファイル名で成功するまでリトライ、成功したら即座にファイルを削除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作業中のコードをpushし忘れて土日に進捗出来なかったのでまたお茶を濁すはめになった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rust初心者へのガイド</title>
      <link>http://keens.github.io/blog/2015/09/23/rustwokakutokinochiken</link>
      <pubDate>Wed, 23 Sep 2015 22:43:14 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/09/23/rustwokakutokinochiken</guid>
      <description>

&lt;p&gt;シルバーウィークの進捗が芳しくなかったので雑な記事書いてお茶を濁しとく。rustをそれなりに（といっても1000行くらい）書いて溜まった知見をとりあえず出す。rust1.3時点。&lt;/p&gt;

&lt;p&gt;最初の方で熱く語ってるが多くの人にとって欲しい情報は下の方にあると思う。&lt;/p&gt;

&lt;h1 id=&#34;どんな言語:64b642c20ac103c85395c6858549d1b9&#34;&gt;どんな言語&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;から持ってくるとこんな感じ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;zero-cost abstractions

&lt;ul&gt;
&lt;li&gt;C++くらいの性能と思えばいい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;move semantics

&lt;ul&gt;
&lt;li&gt;他にはない難しい概念。しかしこれのおかげで様々な機能を教授出来る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;guaranteed memory safety

&lt;ul&gt;
&lt;li&gt;move semanticsにより安全でない操作はコンパイル時に弾ける。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;threads without data races

&lt;ul&gt;
&lt;li&gt;move semanticsその他により安全でない操作は(ry&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;trait-based generics

&lt;ul&gt;
&lt;li&gt;継承ベースとは違って開いている。型を定義した後に機能を追加出来る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;pattern matching

&lt;ul&gt;
&lt;li&gt;便利だよねー。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;type inference

&lt;ul&gt;
&lt;li&gt;(超)重量級言語ながらタイプ数は少なめ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;minimal runtime

&lt;ul&gt;
&lt;li&gt;move semanticsのお陰でGCがないので本当に小さい。hello, worldが277KBだった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;efficient C bindings

&lt;ul&gt;
&lt;li&gt;ABI的に良い感じなのでブリッジングコストがほぼない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、ここでは足りないことを書いておくと、現在Mozillaで開発されている言語で、LLVMバックエンドのネイティブコンパイル言語。LLVMにトラウマがある人もバイナリ配布されているので気軽に使える。
rustを使った大きなプロジェクトはレンダリングエンジンの&lt;a href=&#34;https://github.com/servo/servo&#34;&gt;Servo&lt;/a&gt;がある。&lt;/p&gt;

&lt;p&gt;レンダリングエンジンに使われているだけあって対応OS/アーキテクチャは広く、iOSやAndroidでも動く。C FFIもC APIもある。&lt;/p&gt;

&lt;p&gt;コミュニティは非常に活発で、インフラやライブラリは一通り揃った感じはする。マイナー言語を見てきた身としては1000ライラリくらい集まると一通りのことは出来るようになるかな、と思っているがrustは若い言語ながら3000ある。増えるペースも速いので欲しいものはまずあると思っていい。&lt;/p&gt;

&lt;p&gt;長らくAPIの破壊的変更をガンガンやる時期があって、1ヶ月前のhello worldが動かないとかもザラだったが2015年5月に1.0が出て以来見違えたように大人しくなって人が増え始めている。APIについてはunstable, stableだとかのラベルを付けるようになったので安心して使える。&lt;/p&gt;

&lt;p&gt;開発フローについてはFirefoxと同じく6週間毎に上流から新しいバージョンが降ってくる。ので今はもう1.3が出ている。1.0から1.3はコンパイル/実行時のパフォーマンス改善が主。新しい機能はPythonのPEPみたいにRFCで管理している。&lt;/p&gt;

&lt;p&gt;所有権や生存期間など新しい概念を導入していてとっつきにくいがこれらの概念のお陰で並列化しても安全だし、何よりメモリ管理を静的に解決出来るのでGCがなくてパフォーマンスが出るわ安定するわStop the Worldがないわで非常に良い言語。個人的にはデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。&lt;/p&gt;

&lt;p&gt;何指向言語かと言われると難しい。安全指向？継承はないがオブジェクト指向といえばそうだし函数型っぽくなくもない。並行を意識して作ってあるから並行指向と言えなくもない。継承を止めたC++のような所有権と副作用を入れたHaskellのような言語。副作用はバリバリ使うのであまり函数型言語として見ない方が幸せになれると思っている。&lt;/p&gt;

&lt;p&gt;traitがどんなものかというとHaskellの型クラスに（多分）同じ。しかもHaskellの&lt;code&gt;deriving Show&lt;/code&gt;みたいに&lt;code&gt;#[derive(Debug)]&lt;/code&gt;とかも書ける。便利。&lt;/p&gt;

&lt;p&gt;生存期間と所有権がどういうものかというと、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let foo = Foo::new(1);
println!(&amp;quot;{:?}&amp;quot;, foo);
let foo = Foo::new(2);
println!(&amp;quot;{:?}&amp;quot;, foo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;foo&lt;/code&gt;を&lt;code&gt;Foo::new(2)&lt;/code&gt;にバインドした時、&lt;code&gt;Foo::new(1)&lt;/code&gt;は所有者が居なくなるのでその時点で開放される。GCと違う点は、GCはその時点ではゴミになるだけで、次にGCが走った時にようやく開放されるが、rustはその場で開放される、&lt;code&gt;free&lt;/code&gt;を自動で挟む。そうなると、コンパイラは最適化で同じサイズを&lt;code&gt;free&lt;/code&gt;してまたアロケートするのを同じ領域を使うようにする筈だ。これで領域の節約とかアロケーションコストの節約の他に、「今使った」メモリを再利用出来るのでキャッシュに載ったままメモリを使える。ここまでの効率化を「自動で」やってくれるのはrustだけではないかと思っている。&lt;/p&gt;

&lt;p&gt;このように素晴しい言語機能があってコミュニティも活発で安定した言語なので流行ればいいなと思っている。とはいっても気軽に書ける言語ではないのであらゆる所で使われる言語とは思っていない。先に言ったようにデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。goがnext Cならrustはnext C++かな、と。&lt;/p&gt;

&lt;p&gt;rustは難しい。学習曲線が急峻だ。しかし手を動かしてその急峻な崖を乗り越えるだけの価値はある言語だと思うので是非試してみて欲しい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、情報セクションだ。&lt;/p&gt;

&lt;h1 id=&#34;ドキュメント:64b642c20ac103c85395c6858549d1b9&#34;&gt;ドキュメント&lt;/h1&gt;

&lt;h2 id=&#34;入門:64b642c20ac103c85395c6858549d1b9&#34;&gt;入門&lt;/h2&gt;

&lt;p&gt;trplと略される&lt;a href=&#34;https://doc.rust-lang.org/stable/book/&#34;&gt;The Rust Programming Language&lt;/a&gt;を読むととりあえず基本的な概念を一通り学習出来る。&lt;/p&gt;

&lt;h2 id=&#34;書き始めた:64b642c20ac103c85395c6858549d1b9&#34;&gt;書き始めた&lt;/h2&gt;

&lt;p&gt;文法とかをサクっと確認したいなら&lt;a href=&#34;https://doc.rust-lang.org/stable/reference.html&#34;&gt;The Rust Reference&lt;/a&gt;がある。&lt;/p&gt;

&lt;p&gt;標準ライブラリを調べたいなら&lt;a href=&#34;https://doc.rust-blang.org/stable/std/&#34;&gt;APIドキュメント&lt;/a&gt;がある。一見分かりづらいが一番上に検索窓があるので全体検索が出来る。&lt;/p&gt;

&lt;p&gt;コード例が欲しいなら&lt;a href=&#34;http://rustbyexample.com/&#34;&gt;Rust by Example&lt;/a&gt;がある。&lt;/p&gt;

&lt;h1 id=&#34;軽く試す:64b642c20ac103c85395c6858549d1b9&#34;&gt;軽く試す&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://play.rust-lang.org/&#34;&gt;Rust Playground&lt;/a&gt;を使えばWeb上で試せる。質問とか投げる時にサンプルコードをここに載せて渡すと捗る。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:64b642c20ac103c85395c6858549d1b9&#34;&gt;開発環境&lt;/h1&gt;

&lt;h2 id=&#34;コンパイラ:64b642c20ac103c85395c6858549d1b9&#34;&gt;コンパイラ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;から簡単にバイナリ落としてこれる。Macだとbrewでも入った気がする。FreeBSDだとpkgで入る。Debianのパッケージも出来たらしい(&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;)がUbuntuにはまだ(&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;)きてない。すぐ来るだろう。&lt;/p&gt;

&lt;p&gt;しかし後述のracerのためにソースが必要なので別途ソースはダウンロードする必要がある。&lt;/p&gt;

&lt;h2 id=&#34;エディタ:64b642c20ac103c85395c6858549d1b9&#34;&gt;エディタ&lt;/h2&gt;

&lt;p&gt;Emacs, Vim, Atomだったら&lt;a href=&#34;https://github.com/phildawes/racer&#34;&gt;racer&lt;/a&gt;を使う。
racerのソースを持ってきてコンパイルしてエディタプラグインをエディタに入れてrustコンパイラのソース持ってきて2行設定書けば使える。ソース補完と定義元ジャンプがある。ちゃんと型を見て補完候補出してくれるし標準ライブラリのソースにもジャンプ出来るので中々便利。&lt;/p&gt;

&lt;p&gt;gofmtのrust版、&lt;a href=&#34;https://github.com/nrc/rustfmt&#34;&gt;rustfmt&lt;/a&gt;は開発版のコンパイラを持ってこないとコンパイル出来ないので私は諦めているが使いたい人は試すといいと思う。少なくともEmacs向けのプラグインはある。&lt;/p&gt;

&lt;h1 id=&#34;ビルドツール:64b642c20ac103c85395c6858549d1b9&#34;&gt;ビルドツール&lt;/h1&gt;

&lt;p&gt;コンパイラと一緒に配布される(FreeBSDのpkgでは別になってる)Cagroがある。雛形作成、依存解決、ビルド、テスト、ベンチマークなどのタスクが出来る。クロスコンパイルとかも。&lt;/p&gt;

&lt;h1 id=&#34;パッケージ管理:64b642c20ac103c85395c6858549d1b9&#34;&gt;パッケージ管理&lt;/h1&gt;

&lt;p&gt;クライアント側はCargo。セントラルレポジトリ的なのは&lt;a href=&#34;https://crates.io/&#34;&gt;crates.io&lt;/a&gt;。crates.ioに登録されてなくてもCargoはgitから取ってくるとかも出来るので野良パッケージも使える。&lt;/p&gt;

&lt;h1 id=&#34;テスト:64b642c20ac103c85395c6858549d1b9&#34;&gt;テスト&lt;/h1&gt;

&lt;p&gt;関数に&lt;code&gt;#[test]&lt;/code&gt;アノテーションを付ければ良い。つまり、ソースとテストを同じファイルに書ける。結構便利。テスト用ビルドでのみコンパイルされて他のビルドだと無視される（と思う。）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn fib(n:isize) -&amp;gt; isize{
    if n &amp;lt; 2 {
       1 
    }
    else {
        fib(n - 1) + fib(n - 2)
    }
}

#[test]
fn test_fib(){
    assert(fib(1) == 1);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;これ便利とかここ躓いたとか。&lt;/p&gt;

&lt;h1 id=&#34;所有権:64b642c20ac103c85395c6858549d1b9&#34;&gt;所有権&lt;/h1&gt;

&lt;p&gt;分かってたけどやっぱり躓いた。局所的には「あ、ここ所有権必要だわ」とか分かるのだが大域的には難しい。&lt;/p&gt;

&lt;p&gt;例えばボトムアップで作っていくと、小さな関数で所有権が必要だがそれを呼び出そうとしたら呼出元が所有権を持っていなくて困るとか。小さな値とか状態を持たない値だったら&lt;code&gt;clone&lt;/code&gt;して渡すのだがそうでなければ手戻りが発生する。この辺は実際に書いて経験を積むしかなさそう。&lt;/p&gt;

&lt;p&gt;因みに代数的データ型と所有権でも困っている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
enum Value {
   Str(String),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とかすると&lt;code&gt;Str&lt;/code&gt;データコンストラクタがStringの所有権を持っているのでパターンマッチで取り出す時に所有権が貰えず、&lt;code&gt;match{Value::Str(ref str) =&amp;gt; ...,}&lt;/code&gt;と、&lt;code&gt;ref&lt;/code&gt;を使って借りるしかない。&lt;/p&gt;

&lt;p&gt;まだ経験が足りないので困ったまま。&lt;/p&gt;

&lt;h1 id=&#34;サイズ:64b642c20ac103c85395c6858549d1b9&#34;&gt;サイズ&lt;/h1&gt;

&lt;p&gt;rustはコンパイル時にメモリ管理を決定するのでコンパイル時にデータのメモリサイズが決まってないといけない。例えば以下のコードはコンパイルが通らない。Bazにおいて、fooのサイズが決定出来ないと言われる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Foo {

}


struct Bar {
}

impl Foo for Bar {

}


struct Baz {
  foo: Foo
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;Foo&lt;/code&gt;はただのインターフェースの定義であって、データを定義してないので実際にFooを実装したデータ型のサイズが分からないからだ(今後変更がある模様。)。次のようにパラメータにすれば解決出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Baz&amp;lt;T&amp;gt; {
  foo: T
}

impl &amp;lt;T:Foo&amp;gt; Baz&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに元の定義とは変わってデータの時点ではTで、implを書く時にFooに絞っているのは不要な所では不要な条件を付けないようにしているからだろうか。
変な値を入れられて困りそうだが、構造体のフィールドを公開しなければ勝手に値が作られることはなく、impl内に書いたコンストラクタを通してのみ値が作られるので心配無用である。&lt;/p&gt;

&lt;h1 id=&#34;t-と-vec-t-str-と-string:64b642c20ac103c85395c6858549d1b9&#34;&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt;と&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;str&lt;/code&gt;と&lt;code&gt;String&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;使い分けは&lt;a href=&#34;http://qiita.com/kondei/items/4a3496786fce0c1a1b43&#34;&gt;Rustの文字列のガイド - Qiita&lt;/a&gt;を見て欲しいが、相互変換で困ることがあったので。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;String&lt;/code&gt;から&lt;code&gt;&amp;amp;str&lt;/code&gt;に変換する時に「&lt;code&gt;as_slice&lt;/code&gt;はunstable」と言われる。こうしてやれば良いようだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let string = &amp;quot;String&amp;quot;.to_string();
let lent_str = &amp;amp;string[..]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vectorも同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let vector = vec![1, 2, 3];
let lent_slice = &amp;amp;vector[..]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hashmap:64b642c20ac103c85395c6858549d1b9&#34;&gt;HashMap&lt;/h1&gt;

&lt;p&gt;所有権周りで困る。例えば次のコードはコンパイルが通らない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;match hash.get(key) {
    Some(v) =&amp;gt; v,
    None =&amp;gt; {hash.insert(key, default); default}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matchの中でhashがborrowされてると判断されるのでNone節でhashにinsert出来ない。&lt;a href=&#34;http://stackoverflow.com/questions/28512394/how-to-lookup-from-and-insert-into-a-hashmap-efficiently&#34;&gt;ワークアラウンド&lt;/a&gt;
もあるが、どう考えてもイケてないので&lt;a href=&#34;http://blog.rust-lang.org/2015/08/14/Next-year.html&#34;&gt;改善される模様&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;データ型と参照:64b642c20ac103c85395c6858549d1b9&#34;&gt;データ型と参照&lt;/h1&gt;

&lt;p&gt;データ型の中で参照を使いづらい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Value {
   Str(&amp;amp;str),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、怒られる。&lt;code&gt;&amp;amp;str&lt;/code&gt;は自分の物ではないので生存期間が分からないからパラメータで受け取らないといけない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct &amp;lt;&#39;a&amp;gt;Value&amp;lt;&#39;a&amp;gt; {
   Str(&amp;amp;&#39;a str),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、やはり所有権を持っていないので次のようなメソッドを定義出来ない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;&#39;a&amp;gt;Value&amp;lt;&#39;a&amp;gt; {
    fn empty_str() -&amp;gt; &amp;lt;&#39;a&amp;gt; {
        Value::Str(&amp;quot;&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…と思ったらなんか出来ちゃった。今まで使い方が悪かったのかも。これはナシ。&lt;/p&gt;

&lt;h1 id=&#34;モナド:64b642c20ac103c85395c6858549d1b9&#34;&gt;モナド&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/TeXitoi/rust-mdo&#34;&gt;mdo&lt;/a&gt;というdo記法っぽく書けるマクロがあるがクロージャを作るとそのクロージャが変数の所有権を持っていって面倒だったのでそんなに良くなかった。optionモナドに関しては素直にmapとandThenを使った方が良い。&lt;/p&gt;

&lt;h1 id=&#34;try:64b642c20ac103c85395c6858549d1b9&#34;&gt;try!&lt;/h1&gt;

&lt;p&gt;rustのコードでは至る所でResult(Either)型が返ってくる。それに対して毎回パターンマッチするのはやってられない。かといって安全でない&lt;code&gt;unwrap()&lt;/code&gt;を各所で使うのも精神衛生に良くない。Errに対してunwrapを使うとpanicになるが、rustにはpanicをハンドルする方法はない。&lt;/p&gt;

&lt;p&gt;そこで&lt;code&gt;try!&lt;/code&gt;。返り値がErrだったらそのままErrで関数から抜け、Okだったらその値を返すマクロ。多分展開結果はこんな形になってる:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = try!(foo());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = match foo() {
   Ok(v) =&amp;gt; v,
   e @ Err(_) =&amp;gt; return e
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;。&lt;/p&gt;

&lt;p&gt;これの逆、成功したらその値で抜け、ErrだったらErrを返して処理を継続するやつとかオプション版とかも欲しい。&lt;/p&gt;

&lt;h1 id=&#34;最後に:64b642c20ac103c85395c6858549d1b9&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;Lisp処理系作ろうとしたけど完成しなかったのでそっとここに置いときますね&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/kappaLisp&#34;&gt;κLisp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustでstructのmutableなfieldあれこれ</title>
      <link>http://keens.github.io/blog/2015/06/14/rustdestructnomutablenafieldarekore</link>
      <pubDate>Sun, 14 Jun 2015 17:53:11 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/14/rustdestructnomutablenafieldarekore</guid>
      <description>

&lt;p&gt;κeenです。人々にRustを薦めておきながら本人は昨日ようやく入門しました。その時に困ったことをメモ。タイトルがルー語になってますが気にしない。&lt;/p&gt;

&lt;p&gt;因みにこれはRust 1.0の情報です。&lt;/p&gt;

&lt;h1 id=&#34;導入:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;導入&lt;/h1&gt;

&lt;p&gt;Rustを知らない人のために説明すると、Rustの値はデフォルトでイミュータブルです。デフォルトで、というのはもちろんミュータブルにすることも出来ます。
標準ライブラリにも値がイミュータブルであることを要求するものもあります。
そしてミュータビリティは&lt;code&gt;mut&lt;/code&gt;として型にも現れます。厳密に同じかは知りませんが&lt;code&gt;const&lt;/code&gt;の逆、と思えばいいでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Point {
    x: isize,
    y: isize
}

fn double(p: &amp;amp;mut Point) {
    p.x = p.x * 2;
    p.y = p.y * 2;
}

fn main(){
    let mut p1 = Point{x: 1, y: 2};
    let p2 = Point{x: 1, y: 2};
    double(&amp;amp;mut p1);
    double(&amp;amp;mut p2); // error! p2 is immutable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イミュータビリティは継承します。親のstructがイミュータブルなら子もイミュータルになります。因みにフィールドに&lt;code&gt;mut&lt;/code&gt;を指定することは出来ないようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::collections::HashMap;

struct IntHashMap {
    hash: HashMap&amp;lt;isize, isize&amp;gt;
}
fn main(){
    let h = IntHashMap{hash: HashMap::new()};
    h.hash.insert(1, 2);        // error! h.hash is immutable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、少し本筋とずれますがtraitについて。他の言語でいうインターフェースのようなものです。今回これで困ったので。&lt;/p&gt;

&lt;p&gt;例えばHTTPライブラリの&lt;a href=&#34;http://hyper.rs/hyper/hyper/server/trait.Handler.html&#34;&gt;hyper&lt;/a&gt;では次のようなトレイトを実装しているstructをrequest handlerとして登録できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Handler: Sync + Send {
    fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;);

    fn check_continue(&amp;amp;self, _: (&amp;amp;Method, &amp;amp;RequestUri, &amp;amp;Headers)) -&amp;gt; StatusCode { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを見て下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self&lt;/code&gt;に&lt;code&gt;mut&lt;/code&gt;がついてませんね。つまりhandlerはイミュータブルな値として渡されます。例えば先の例のようにフィールドにハッシュマップを持っていても更新出来ません。ちょっと困りますね。&lt;/p&gt;

&lt;h1 id=&#34;cell-refcell:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;Cell/RefCell&lt;/h1&gt;

&lt;p&gt;ということでフィールドにミュータビリティを入れるのが &lt;code&gt;std::cell::{Cell, RefCell}&lt;/code&gt; です。この辺のブログを参考に。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://saneyukis.hatenablog.com/entry/2014/05/30/230351&#34;&gt;#rustlang における構造体のmutabilityと&lt;code&gt;Cell/RefCell&lt;/code&gt; - snyk_s log&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;で、喜び勇んで使ったのですが次なるエラーが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyHandler {
    cache: RefCell&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;
}

impl Handler for MyHandler {
    fn handle&amp;lt;&#39;a, &#39;k&amp;gt;(&amp;amp;&#39;a self, Request&amp;lt;&#39;a, &#39;k&amp;gt;, Response&amp;lt;&#39;a, Fresh&amp;gt;){
        ....
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;the trait `core::marker::Sync` is not implemented for the type `core::cell::UnsafeCell&amp;lt;...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうも、hyperは複数スレッドでも動かせるのでハンドラにスレッドセーフであることが要求されるようです。そしてRustコンパイラはRefCellがスレッドセーフでない事を知っているのでコンパイルを弾きます。怖いですね。&lt;/p&gt;

&lt;h1 id=&#34;mutex:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;Mutex&lt;/h1&gt;

&lt;p&gt;無理っぽいので最早別の手段を捜し始めます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;キャッシュ用のアクター走らせるのが良い気がしてきた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/609471732970209280&#34;&gt;2015, 6月 12&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これはちょっと無理がありそうですね。&lt;/p&gt;

&lt;p&gt;しかし、別の方法があるようでした。&lt;a href=&#34;https://doc.rust-lang.org/std/sync/struct.Mutex.html&#34;&gt;std::sync::Mutex&lt;/a&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyHandler {
    cache: Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで&lt;code&gt;lock().unwrap()&lt;/code&gt;するだけで使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut cache = self.cache.lock().unwrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにロックの解除は不要です。Rustコンパイラは値の生存期間を知っているので値がこれ以上使われなくなった箇所にコンパイラがunlockを挟みます。(正確に言うとdrop(デストラクタ)が挿入され、dropがリソースの開放を行なう)&lt;/p&gt;

&lt;h1 id=&#34;まとめ:3ab5e7833b8f9de647371db38dc333a5&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;rustのイミュータビリティは継承する&lt;/li&gt;
&lt;li&gt;structのfieldに直接&lt;code&gt;mut&lt;/code&gt;は指定出来ない&lt;/li&gt;
&lt;li&gt;シングルスレッドでミュータブルなフィールドが欲しいなら&lt;code&gt;Cell&lt;/code&gt;/&lt;code&gt;RefCell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;マルチスレッドなら&lt;code&gt;Mutex&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>静的なメモリ管理の話。リージョン推論とλ計算からRustまで</title>
      <link>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</link>
      <pubDate>Tue, 21 Apr 2015 00:25:56 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/seitekinamemorikanrinohanashi.ri%5EjonsuirontolambdakeisankaraRustmade/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 静的なメモリ管理の話。リージョン推論とλ計算からRustまで
----------------------
サイバーエージェント新卒エンジニア勉強会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * 大学では非情報系学科。趣味のプログラマ。
   + 非ガチ勢なので優しくして下さい&gt;&lt;
 * Lisp, Ruby, OCaml, Shell Scriptあたりを書きます


# メモリ管理の話
---------------
(一般的ではない用語)

* 弱い静的メモリ管理
* 強い動的メモリ管理
* (弱い動的メモリ管理)
* 強い静的メモリ管理


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 静的 = コンパイル時にメモリ管理が決定する

### 例

* C言語


# メモリ管理の話
---------------
## 弱い静的メモリ管理
### 利点

* 実行時は安定している

### 欠点
* バグる
* 面倒
* 危険


# メモリ管理の話
---------------
## 強い動的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* GCのある言語全般

# メモリ管理の話
---------------
## 強い動的メモリ管理
### 利点

* メモリ管理からの開放

### 欠点

* 動作が不安定 (cf [これがCassandra](http://www.slideshare.net/TakehiroTorigaki/cassandra-21191674))
* パフォーマンスの問題
* リアルタイム性の問題


# メモリ管理の話
---------------
## (弱い動的メモリ管理)
### 特徴

* 弱い = ユーザがミスるとメモリ周りのエラーやリークが実行時に起きる
* 動的 = 実行時になるまでメモリの使われ方が分からない

### 例

* バグったGC
  + 普通はない
  + (参照カウント？)


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 特徴

* 強い = 基本的にメモリでエラーやリークが起きない
* 静的 = コンパイル時にメモリ管理が決定する


# メモリ管理の話
---------------
## 強い静的メモリ管理
### 利点

* メモリ管理からの開放
* 実行時は安定している
* リアルタイム
* パフォーマンスが出る

### 欠点

* 実現可能性は？


# 強い静的メモリ管理の話をしよう


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 強い静的メモリ管理の話をしよう
------------------------------

* まずは可能性の議論が必要
* 実現可能性
* 実用性


# 可能性の議論
-------------

* プログラミング言語の理論 ≒ λ計算
* そもそもλ計算はメモリのことを考慮してない
  + GCがあるかのように記述される


# 可能性の議論
-------------

* λ計算にメモリ管理まで含めて理論を立てたものは存在する（静的なメモリ管理）
  + リージョンというものをベースにしている [参考](http://www.elsman.com/mlkit/pdf/popl94.pdf)
* さらにリージョンを自動で推論する理論もある（強いメモリ管理）
  + リージョン推論という


# 軽くリージョンの話
-------------------

* 型と同じようにプログラム全体を伝わるメタデータ。
* データが保存される場所を指す。リージョンはいくつもある。
* リージョン推論でデータがどのリージョンに入るかが分かる
* さらにリージョンのサイズもある程度予想がつくので静的に管理出来る
* 関数などは引数のリージョンに対して多相になる「リージョン多相」などもある
* この辺は[Martin Elsmanの論文たち](http://www.elsman.com/mlkit/papers.html)を参考にして下さい
  + [A Brief Introduction to Regions](http://www.elsman.com/mlkit/pdf/ismm98.pdf)とか。



# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* 実現可能性
* 実用性

# 実現可能性

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 実現可能性
-----------

* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;Martin ElsmanによるSML処理系、[ML Kitに一部導入された](http://www.elsman.com/mlkit/pdf/pldi2002.pdf)（多分世界初）
  + 但し完全ではなく、GCと組み合わせてある
  + 動的型付き言語に無理矢理静的型を付けても完全には上手くいかないようなもの？
  + 多分リージョン推論を前提とした言語を設計する必要がある
* &lt;!--.element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;Cyclone というC likeな文法の言語が完全に[リージョン推論のみでメモリ管理を実現した](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf)


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* 実用性


# 実用性


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Rust言語
----------

* Mozillaが開発した言語
* 2008~
* Cycloneを参考にしたらしい。
* 活発に開発される
* 大きなプロジェクトに現行のレンダリングエンジン、Geckoを置き換えるべく開発された[Servo](https://github.com/servo/servo)がある
  + 既にC++製のGockoの3倍速い
  + 並列レンダリングすればさらに速い。


# Rust言語
----------

* リージョン推論(ライフタイム)でメモリを管理する
  - かなり賢くて、ヒープにアロケートする必要なけばスタックを使う。
* mallocとfreeは全てコンパイル時に自動で挿入される
* (多分)リージョン推論のみでメモリ管理するために所有権という概念がある。
  + 所有権自体は並列性の導入などにも有用だと思われる。
    -  競合状態の回避とか
* その他
  + 代数的データ型とパターンマッチ
  + トレイトベース(non-nominal)のジェネリクス

詳細は[公式ページ](http://www.rust-lang.org/)から


# 強い静的メモリ管理の話をしよう
------------------------------

* ✓ まずは可能性の議論が必要
* ✓ 実現可能性
* ✓ 実用性


# Rustのライフタイムと所有権
-------------------------


&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Cの例
-------

```c
{
    int *x = malloc(sizeof(int));

    // we can now do stuff with our handle x
    *x = 5;

    free(x);
}
```


# Rustに翻訳
------------

```rust
{
    let x = Box::new(5);
}
```


# 少しいじってみる
---------------

trivialに見える

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
---------------

printlnを追加してみる

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);

    println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 少しいじってみる
----------------

エラーになる。

```
error: use of moved value: `x`
   println!(&#34;{}&#34;, x);
                  ^
```


# 所有権
-------

`add_one` を呼んだ時点で所有権が `add_one` に移るので `println!` では使えない。

```rust
fn main() {
  let x = Box::new(5);

  add_one(x);

  println!(&#34;{}&#34;, x);
}

fn add_one(mut num: Box&lt;i32&gt;) {
    *num += 1;
}
```


# 所有権
-------
新たに値を返してもらえば使える。

```rust
fn main() {
  let x = Box::new(5);

  let y = add_one(x);

  println!(&#34;{}&#34;, y);
}

fn add_one(mut num: Box&lt;i32&gt;) -&gt; Box&lt;i32&gt; {
  *num += 1;

  num
}
```


# 所有権の貸し借り
---------------

* さっきの例は面倒。
* `add_one` が `x` を奪ったのが問題。
* `x` を「借り」ることが出来る。


# 所有権の貸し借り
----------------

```rust
fn main() {
  let mut x = 5;

  add_one(&amp;mut x);

  println!(&#34;{}&#34;, x);
}

fn add_one(num: &amp;mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

先の `add_one` はライフタイム(リージョン)アノテーションを省略していた。  
省略せずに書くとこうなる。(リージョン多相)

```rust
fn add_one&lt;&#39;a&gt;(num: &amp;&#39;a mut i32) {
  *num += 1;
}
```


# ライフタイム
------------

スコープの終わりでライフタイムが終わる。

```rust
fn main() {
  let y = &amp;5;     // -+ y goes into scope
                  //  |
  // stuff        //  |
                  //  |
}                 // -+ y goes out of scope
```


# LTの明示的宣言
--------------
こんな構造体を宣言したとする。 `x` はコンストラクタに渡された値のライフタイムを引き継ぐ。

```rust
struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}
```


# LTの明示的宣言
--------------
`f.x`のライフタイムが `y` のライフタイムに制限されるので
`y` より広いスコープにある `x` には代入出来ない。

```rust
fn main() {
  let x;                  // -+ x goes into scope
                          //  |
  {                       //  |
    let y = &amp;5;           // ---+ y goes into scope
    let f = Foo { x: y }; // ---+ f goes into scope
    x = &amp;f.x;             //  | | error here
  }                       // ---+ f and y go out of scope
                          //  |
  println!(&#34;{}&#34;, x);      //  |
}                         // -+ x goes out of scope
```


# まとめ
-------

* メモリ管理の性質についてまとめた
* 静的メモリ管理が出来れば
  + メモリ管理からの開放
  + 実行時は安定している
  + リアルタイム
  + パフォーマンスが出る
* 強い静的メモリ管理の手法としてリージョン推論がある
* Rust言語がリージョン推論を利用している。
* Rustをみんな使おう!


# 参考
* [ML Kit](http://www.elsman.com/mlkit/)
* [Rust](http://www.rust-lang.org/)
* [Allocators in Rust - Baby Steps](http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>