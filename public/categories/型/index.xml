<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/categories/%E5%9E%8B/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/%E5%9E%8B/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rustの関連型の使いどころ</title>
      <link>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</link>
      <pubDate>Tue, 22 Nov 2016 18:26:47 +0900</pubDate>
      
      <guid>/blog/2016/11/22/rustnokanrenkatanotsukaidokoro</guid>
      <description>&lt;p&gt;κeenです。昨日は&lt;a href=&#34;https://rust.connpass.com/event/41467/&#34;&gt;RustのLT会！ Rust入門者の集い - connpass&lt;/a&gt;に参加してきました。
そこで&lt;a href=&#34;http://qiita.com/tacke_jp/items/9c7617971dc341146c0f&#34;&gt;関連型に関する発表&lt;/a&gt;があったので感化されて私も一筆。&lt;/p&gt;

&lt;p&gt;
馴れないと関連型はジェネリクスでいいじゃんと思えますが、両者は別の機能を提供するものです。
設計による使い分けではなくて実現したいことに応じた機能による使い分けをするので馴れてしまえば迷うことなくどちらを使うか判断出来ます。&lt;/p&gt;

&lt;p&gt;ということで関連型のパターンをいくつか。
もちろん、根底にある関連型という機能は共通なのでほとんど同じようなことを言ってますが気持としてパターンを知っておくと便利です。&lt;/p&gt;

&lt;h1 id=&#34;型レベルの関数として&#34;&gt;型レベルの関数として&lt;/h1&gt;

&lt;p&gt;「関連」型なのである型に関連する型を表現します。ちょっと見方を変えると型から型への写像、つまり関数になります。
例えばこういうのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ToUnsigned {
    type Counterpart;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart;
}

impl ToUnsigned for i32 {
    type Counterpart = u32;
    fn to_unsigned(self) -&amp;gt; Self::Counterpart {
        self as u32
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;i32&lt;/code&gt; から &lt;code&gt;u32&lt;/code&gt; への関数になってそうなのが見えますかね？もちろん、 &lt;code&gt;i64&lt;/code&gt; から &lt;code&gt;u64&lt;/code&gt; などへの対応も作れます。
こういうのは例えば符号無し数にのみ演算が定義されている場合とかに便利ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn write_bigendian_signed&amp;lt;I, U&amp;gt;(i: I) -&amp;gt; ()
    where I: ToUnsigned&amp;lt;Counterpart = U&amp;gt;,
          U: ...,  {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;トレイト内で使う型を固定するため&#34;&gt;トレイト内で使う型を固定するため&lt;/h1&gt;

&lt;p&gt;これが一番目にするやつじゃないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Handler {
    type Request;
    type Response;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}

struct HTTPHandler;

impl Handler for HTTPHandler {
    type Request = HTTPRequest;
    type Response = HTTPResponse;
    fn handle(req: Self::Request, res: Self::Response) -&amp;gt; io::Result&amp;lt;()&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定というか特殊化というか、トレイト自体は汎用的に作られていて、それを実装する型が特定の処理に特化するパターンです。
ジェネリクスで受け取る訳にはいかなくて、実装すべき型をトレイトの中で定義してあげる必要があるのは分かると思います。&lt;/p&gt;

&lt;h1 id=&#34;関数の返り値を一般化するため&#34;&gt;関数の返り値を一般化するため&lt;/h1&gt;

&lt;p&gt;これは現在のRust(rust-1.13.0)が &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1522&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;をサポートしていないために必要になるテクニックです。
関連型とトレイト境界を組み合わせて使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait ReverseIter {
    type Item;
    type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;
    fn rev_iter(&amp;amp;self) -&amp;gt; Iter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの &lt;code&gt;type Iter: Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt; の方です。
返り値のIteratorを抽象化したいのですが、現在のRustでは&lt;code&gt;fn rev_iter(&amp;amp;self) -&amp;gt; Iterator&amp;lt;Item = Self::Item&amp;gt;;&lt;/code&gt;のような書き方が出来ないので仕方なく関連型を使ってあげる必要があります。&lt;/p&gt;

&lt;p&gt;ちょっと踏み込んだ話をすると、関数の引数の多相性は∀の量化、返り値の多相は∃の量化です。そしてトレイトのジェネリクスも∀の量化で関連型が∃の量化なのでそういう対応がある訳です。&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;結構理論的にも色々あるようなので調べてみると様々なブログポストが見付かると思います。&lt;/p&gt;

&lt;p&gt;ぱぱっと思いついたパターンを3つ挙げました。もしかしたら他にもパターンがあるかもしれません。&lt;/p&gt;

&lt;p&gt;これを知っておけば&lt;a href=&#34;https://github.com/tokio-rs/tokio-service&#34;&gt;tokio-service&lt;/a&gt;の&lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;Service&lt;/a&gt;みたいな関連型を多用するパターンでもひるまなくなります。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;h2 id=&#34;関連型とimpl-traitに関して&#34;&gt;関連型とimpl Traitに関して&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/associated-types.html&#34;&gt;関連型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rust-lang-ja.org/rust-by-example/generics/assoc_items/the_problem.html&#34;&gt;関連型が必要になる状況 | Rust by Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ncameron.org/blog/abstract-return-types-aka-%60impl-trait%60/&#34;&gt;Abstract return types, aka &lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;応用&#34;&gt;応用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keens.github.io/blog/2016/02/28/rustnohigherkinded_type_trait/&#34;&gt;RustのHigher-Kinded type Trait | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;発展的な話題&#34;&gt;発展的な話題&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/02/associated-type-constructors-part-1-basic-concepts-and-introduction/&#34;&gt;Associated type constructors, part 1: basic concepts and introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/03/associated-type-constructors-part-2-family-traits/&#34;&gt;Associated type constructors, part 2: family traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/04/associated-type-constructors-part-3-what-higher-kinded-types-might-look-like/&#34;&gt;Associated type constructors, part 3: What higher-kinded types might look like&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://smallcultfollowing.com/babysteps/blog/2016/11/09/associated-type-constructors-part-4-unifying-atc-and-hkt/&#34;&gt;Associated type constructors, part 4: Unifying ATC and HKT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1598&#34;&gt;Associated type constructors (a form of higher-kinded polymorphism). by withoutboats · Pull Request #1598 · rust-lang/rfcs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>幽霊型を知った</title>
      <link>/blog/2015/05/24/yuureikatawoshitta</link>
      <pubDate>Sun, 24 May 2015 22:38:47 +0900</pubDate>
      
      <guid>/blog/2015/05/24/yuureikatawoshitta</guid>
      <description>&lt;p&gt;κeenです。かねてより気になっていた幽霊型(Phantom Type)について知ったのでアウトプット。
&lt;a href=&#34;http://www.cs.rit.edu/~mtf/research/phantom-subtyping/jfp06/jfp06.pdf&#34;&gt;このPDF&lt;/a&gt;がベースになって
ます。&lt;/p&gt;

&lt;p&gt;余談ですが英語がファントム・タイプと中々中二な名前なので和訳も幻影型とかそういう方向に走って欲かったな。
&lt;/p&gt;

&lt;p&gt;「幽霊型」で調べると真っ先に&lt;a href=&#34;https://kagamilove0707.github.io/programming/2014/02/20/about-phantom-type/&#34;&gt;このサイト&lt;/a&gt;が出てくるのですが、ミスリーディングと言われていました。
別に間違ったことを書いている訳ではないのですが、幽霊型の応用例なのでこれこそが幽霊型だと思ってしまうと少し視野が狭くなってしまうようです。&lt;/p&gt;

&lt;h1 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h1&gt;

&lt;p&gt;ブーリアンと整数と条件分岐と足し算と比較が出来るミニ言語を考えてみます。自動で型変換は行わない(つまりintとboolの比較などは出来ない)言語とします。こんな感じでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype exp
  = Int of int
  | Bool of bool
  | If of exp * exp * exp
  | Plus of exp * exp
  | Equal of exp * exp

fun mkInt x = Int x
fun mkBool x = Bool x
fun mkIf cnd thn els = If(cnd, thn, els)
fun mkPlus x y = Plus(x, y)
fun mkEqual x y = Equal(x, y)

exception Type

fun evalIf cnd thn els =
  case eval cnd of
      Bool x =&amp;gt; if x then eval thn else eval els
    | _ =&amp;gt; raise Type

fun evalPlus x y =
  case (eval x, eval y) of
      (Int x&#39;, Int y&#39;) =&amp;gt; Int(x&#39; + y&#39;)
    | _  =&amp;gt; raise Type

fun evalEqual x y =
  case (eval x, eval y) of
      (Int x&#39;, Int y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
    | (Bool x&#39;, Bool y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
    | _  =&amp;gt; raise Type

fun eval exp =
  case exp of
      If(cnd, thn, els) =&amp;gt; evalIf cnd thn els
    | Plus(x, y) =&amp;gt; evalPlus x y
    | Equal(x, y) =&amp;gt; evalEqual x y
    | e =&amp;gt; e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この定義に従うと次のような自明に間違ったプログラムもコンパイルを通ってしまいます&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;mkEqual (mkInt 1) (mkBool false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;勿論、評価するとエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;eval (mkEqual (mkInt 1) (mkBool false));

uncaught exception Type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こういうものを極力コンパイル時に発見出来ないかとうのがモチベーションです。因みにこのモチベーションは変な型変換を行わない言語なら動的型付き言語でも同じで、SBCLで&lt;code&gt;(+ 1 t)&lt;/code&gt;を評価するとちゃんとコンパイルエラーになります。&lt;/p&gt;

&lt;h1 id=&#34;問題の分析&#34;&gt;問題の分析&lt;/h1&gt;

&lt;p&gt;今回、&lt;code&gt;Int&lt;/code&gt;だとか&lt;code&gt;Bool&lt;/code&gt;だとかの型情報をタグ、つまり値として持たせました。しかしコンパイル時に値にはアクセス出来ません。コンパイル時にアクセスできるのは型です。ということでメタデータとして型を付与しましょう。&lt;/p&gt;

&lt;h1 id=&#34;幽霊型&#34;&gt;幽霊型&lt;/h1&gt;

&lt;p&gt;メタデータとして型を付けたのが幽霊型です。名前的に&lt;code&gt;&#39;a texp&lt;/code&gt;ではなく&lt;code&gt;&#39;a&lt;/code&gt;の部分が幽霊型なんですかね。&lt;/p&gt;

&lt;p&gt;使い方は割と分かりやすくて、&lt;code&gt;datatype&lt;/code&gt;に余計な型をつけます。この&lt;code&gt;&#39;a&lt;/code&gt;は使われていませんがメタデータなのでそういうもんです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype &#39;a texp = E of exp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、&lt;code&gt;mkXxx&lt;/code&gt; にも型を付けます。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;mkInt&lt;/code&gt;なら返り値はIntなので&lt;code&gt;&#39;a&lt;/code&gt;の部分にその情報を詰め込みます。今回は&lt;code&gt;int&lt;/code&gt;が宜しいようです。
毎回&lt;code&gt;E&lt;/code&gt;がつくのが面倒ですが我慢して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun mkInt x: int texp = E (Int x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mkBool&lt;/code&gt;も同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun mkBool x: bool texp = E (Bool x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次は&lt;code&gt;mkIf&lt;/code&gt;ですが、condにはBool型、thenとelseには同じ型が来て欲しいです。そして返り値というかこのIfを
evalした型はthenやelseと同じ型なのでこのような型になります。Ifに渡す為に一旦&lt;code&gt;E&lt;/code&gt;を剥がしてます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun mkIf (E cnd: &#39;b texp) (E thn: &#39;a texp) (E els: &#39;a texp): &#39;a texp = E (If(cnd, thn, els))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じように考えたら&lt;code&gt;mkPlus&lt;/code&gt;や&lt;code&gt;mkEqual&lt;/code&gt;も型付け出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun mkPlus (E x: int texp) (E y: int texp): int texp = E (Plus(x, y))
fun mkEqual (E x: &#39;a texp) (E y: &#39;a texp): bool texp = E (Equal(x, y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ以後は変更ありません。一応修正後のプログラムを載せると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype exp
  = Int of int
  | Bool of bool
  | If of exp * exp * exp
  | Plus of exp * exp
  | Equal of exp * exp

datatype &#39;a texp = E of exp

fun mkInt x: int texp = E (Int x)
fun mkBool x: bool texp = E (Bool x)
fun mkIf (E cnd: &#39;b texp) (E thn: &#39;a texp) (E els: &#39;a texp): &#39;a texp = E (If(cnd, thn, els))
fun mkPlus (E x: int texp) (E y: int texp): int texp = E (Plus(x, y))
fun mkEqual (E x: &#39;a texp) (E y: &#39;a texp): bool texp = E (Equal(x, y))

exception Type

fun evalIf cnd thn els =
  case eval&#39; cnd of
      Bool x =&amp;gt; if x then eval&#39; thn else eval&#39; els
    | _ =&amp;gt; raise Type

and evalPlus x y =
    case (eval&#39; x, eval&#39; y) of
        (Int x&#39;, Int y&#39;) =&amp;gt; Int(x&#39; + y&#39;)
      | _  =&amp;gt; raise Type

and evalEqual x y =
    case (eval&#39; x, eval&#39; y) of
        (Int x&#39;, Int y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
      | (Bool x&#39;, Bool y&#39;) =&amp;gt; Bool(x&#39; = y&#39;)
      | _  =&amp;gt; raise Type

and eval&#39; exp =
    case exp of
        If(cnd, thn, els) =&amp;gt; evalIf cnd thn els
      | Plus(x, y) =&amp;gt; evalPlus x y
      | Equal(x, y) =&amp;gt; evalEqual x y
      | e =&amp;gt; e

fun eval (E x) = eval&#39; x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。ユーザインターフェースレベルでの変更はありません。
さて、ということで先の式をもう一度評価してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkEqual (mkInt 1) (mkBool false);
stdIn:1.2-1.34 Error: operator and operand don&#39;t agree [tycon mismatch]
  operator domain: int texp
  operand:         bool texp
  in expression:
    (mkEqual (mkInt 1)) (mkBool false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんとエラーが出ました。楽しいですね。&lt;/p&gt;

&lt;h1 id=&#34;発展1-任意の型&#34;&gt;発展1 - 任意の型&lt;/h1&gt;

&lt;p&gt;任意の型を作る手段としてタグ1つ、引数無しのタグ付き共用体を使う方法があります。それを使った技が先のPDFに載ってます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype tcp = TCP
datatype udp = UDP
datatype &#39;a safe_socket = W of Word32.word

fun mkTCP ....
fun mkUDP ....
fun sendTCP ...
fun sendUPD ...
fun close ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように型安全に、そして&lt;code&gt;close&lt;/code&gt;のように可能なものはジェネリックにプログラムを書くことが出来ます。&lt;/p&gt;

&lt;h1 id=&#34;発展2-サブタイプ&#34;&gt;発展2 - サブタイプ&lt;/h1&gt;

&lt;p&gt;次のようにヒエラルキーがある場合の話です。面倒なので言語を縮小しますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype num
  = Int of int
  | Real of real

datatype exp
  = Num of num
  | Bool of bool
  | Plus of exp * exp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、こうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype num
  = Int of int
  | Real of real

datatype exp
  = Num of num
  | Bool of bool
  | Plus of exp * exp

datatype &#39;a tnum = N
datatype &#39;a texp = E of exp

exception Type

fun mkInt x: (int tnum texp) = E (Num  (Int x))
fun mkReal x: (real tnum texp) = E (Num (Real x))
fun mkBool x: (bool texp) = E (Bool x)


fun mkPlus (E x: &#39;a tnum texp) (E y: &#39;a tnum texp): &#39;a tnum texp =
  case (x, y) of
      (Num (Int x&#39;), Num (Int y&#39;)) =&amp;gt; E (Num (Int (x&#39; + y&#39;)))
    | (Num (Real x&#39;), Num (Real y&#39;)) =&amp;gt; E (Num (Real (x&#39; + y&#39;)))
    | _ =&amp;gt; raise Type  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;疲れてきたので説明省略しますが型パラメータを入れ子にしたら上手い具合にサブタイプの親子関係を表せるよねって話です。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;幽霊型を使うと値レベルの話を一部型レベルに持ち上げれる（ってことで良いのかな？）&lt;/p&gt;

&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;どうしても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype &#39;a texp = E of exp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としている所の&lt;code&gt;E&lt;/code&gt;が気になりますね。型システム上必要っぽい(&lt;code&gt;type &#39;a texp = exp&lt;/code&gt;としてもダメだった)ので必要なコストだとは思うのですが
少くとも内部的にはゼロオーバーヘッドであって欲しいです。最適化で消せそうですが実際に消してる処理系はどれほどあるのでしょう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type &#39;a texp = exp&lt;/code&gt;でダメだった(型がミスマッチしてるのにコンパイルが通ってしまった)のも気になります。smlの&lt;code&gt;type&lt;/code&gt;ってただのエイリアスなんでしたっけ？&lt;/p&gt;

&lt;p&gt;若干のモヤモヤは残るものの一応幽霊型について知りました。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;因みにこのコードをSML#のREPLで評価すると返ってこなくなります。&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/24&#34;&gt;イシュー&lt;/a&gt;に上がってます。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>