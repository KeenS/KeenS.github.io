<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on </title>
    <link>/categories/git/</link>
    <description>Recent content in Git on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 14 Feb 2016 17:12:01 +0900</lastBuildDate>
    <atom:link href="/categories/git/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>分散VCSのモデル、あるいはPijulについて</title>
      <link>/post/DVCSnomoderu_aruihaPijulnitsuite/</link>
      <pubDate>Sun, 14 Feb 2016 17:12:01 +0900</pubDate>
      
      <guid>/post/DVCSnomoderu_aruihaPijulnitsuite/</guid>
      <description>

&lt;p&gt;先日、&lt;a href=&#34;pijul.org&#34;&gt;Pijul&lt;/a&gt;という分散VCSについて知って、それについて調べてみたら少し面白かったのでメモ。&lt;/p&gt;

&lt;p&gt;DVCSで一番有名なのは間違いなくGitだろう。あれは分散グラフ理論木モデルに基いているらしい。ベースになったモデルがあることに驚いたが、調べても出てこなかった。
Gitは高速で信頼性が高い一方、コミット同士をチェーンのように繋げてしまうので柔軟性を欠き、例えばCherry Pickなんかがやりづらい。
あるいはリモートのmasterを取り込まずにローカルのmasterにコミットすると互いに独立した変更であっても一旦remote masterをマージしないとプッシュ出来ず、コミットグラフが汚れてしまう。
また、CUIが直感的でなく、理解しづらいという声もある。それはこういう皮肉にも現れている&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://imgs.xkcd.com/comics/git.png&#34; alt=&#34;gitの皮肉&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まあ、言われてみれば私もこのスライドを見てようやく理解した。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/l0beYVXFDsBY3P&#34; width=&#34;595&#34; height=&#34;485&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/ktateish/git-concept1&#34; title=&#34;コンセプトから理解するGitコマンド&#34; target=&#34;_blank&#34;&gt;コンセプトから理解するGitコマンド&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/ktateish&#34; target=&#34;_blank&#34;&gt;ktateish&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;他のVCSにも色々特色はあって、歴史は神聖なるmercurial、履歴にアクセスしてこそのVCSなFossil、レポジトリとはパッチの集合であるDarcsなどなど。&lt;/p&gt;

&lt;p&gt;この中でもDarcsは大きく毛色が違うように思える。レポジトリは依存関係のあるパッチの集合で、互いに独立なパッチは相互作用しない。なので上に挙げたcherry pickだとかremote vs localの問題とかが起きない。
それにパッチベースの管理なのでメールでパッチを送り合うような古いシステムでも困らない。少なくともforkしてpull requestよりはパッチを送った方がなんぼか筋は良い気がする。他のVCSがsnapshot-basedなのに対してdarcsはpatch-basedになる。&lt;/p&gt;

&lt;p&gt;さて、このDarcs、そこまで知らない人も多いかと思うが古くはGHCの開発に使われていたり(gitに移行した)、common-lisp.netで使われていたり(リニューアルの時に内部がgitlabになってdarcsサポートはドロップされた)した。
Haskellで書かれていたのとモデルが(理論的には)綺麗なので函数型な人達には人気があったようだ。&lt;/p&gt;

&lt;p&gt;Darcsを使っていたプロジェクトがGitに移行したことから分かるように、Darcsにも問題があった(らしい)。1つはパフォーマンスの問題で、Haskellで書かれていたので流石にCで書かれたGitには勝てなかった。
さらには、勘の良い人は気付いたかもしれないが、パッチ同士の依存関係だけで管理してるとマージの時に最悪計算量が $O(2^n)$ になる(多くの場合は $O(n)$ で済むらしい)。&lt;/p&gt;

&lt;p&gt;その他のDarcsの問題についてはこちらを参考されれば。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://togetter.com/li/120640&#34;&gt;GHC の開発の darcs から git への移行 - Togetterまとめ&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;pijul:ea7808ae797e23f21c915a040fcfbb48&#34;&gt;Pijul&lt;/h1&gt;

&lt;p&gt;今回話題に出したPijulはDarcsに影響を受けている。レポジトリとは依存関係を持ったパッチの集合で、パッチ同士の関係はGitに比べれば薄いが、snapshot-basedとpatch-basedの両方の良い所を取り入れている。
Pijulの特色は&lt;a href=&#34;http://arxiv.org/abs/1311.3903&#34;&gt;A Categorical Theory of Patches&lt;/a&gt;の成果を取り入れていて、Darcsにあった計算量の問題が改善している。
この理論はファイルを対象、パッチを射とした圏を考えると、互いにコンフリクトしないパッチは同時に適用出来てかつ適用の順序に依らないことは圏論に於ける「押し出し」に一致することに着目している。
さらにこのパッチ圏を拡張(余完備化)することでコンフリクトが起きないように出来る。&lt;/p&gt;

&lt;p&gt;さて、Pijulにすると何が嬉しいのかというと、色々ある。
Darcsのようにパッチベースな点は言わずもがな、パッチベースなのでパッチを作った後でブランチを切ることが出来る。
実際に作業をしてみてブランチの名前が不適切だったな、とかブランチを切る前に名前を考えるのに一瞬手が止まったりすることがない。
尚、Pijulの現バージョン(0.2)では内部構造的にはブランチを扱えるものの、インターフェースのコマンドがないため事実上ブランチは作れないらしい。
また、データの持ち方的にgit blame相当の機能が速いなどそれなりの特色を出している。&lt;/p&gt;

&lt;p&gt;開発言語もOCaml、Scala、Haskell、Cなどを試して今はRustがベストフィットだと落ち着いたらしい。 &lt;code&gt;cargo install pijul&lt;/code&gt; でインストール出来る。
Rustで開発したお陰もあってDarcsより大分速いらしい。&lt;/p&gt;

&lt;p&gt;Darcsユーザには受けがいいようで、darcs to pijulブリッジも作られようとしているらしい。&lt;/p&gt;

&lt;p&gt;個人で使うには困らない程度にまで安定したら楽しみだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gitあれこれ</title>
      <link>/post/some-git-matters/</link>
      <pubDate>Wed, 18 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/some-git-matters/</guid>
      <description>

&lt;p&gt;githubで共同作業してたらいろいろ困ったことがあったのでそのときのメモ。はじめてやって困ったことなので経験ある人には常識なのかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;マスターリポジトリに追従する:2dca43de771e000956be34eb6f9f4ef2&#34;&gt;マスターリポジトリに追従する&lt;/h2&gt;

&lt;p&gt;マスターをフォークして自分のレポジトリで作業、終ったらマスターにpull-reqという流れで作業してました。するとマスターが変更されたときに自分のリポジトリに反映させる必要があります。そのときは &lt;a href=&#34;http://qiita.com/xtetsuji/items/555a1ef19ed21ee42873&#34;&gt;http://qiita.com/xtetsuji/items/555a1ef19ed21ee42873&lt;/a&gt;を参考に、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add upstream git@github.com:g000001/google-common-lisp-style-guide-ja.git
$ git fetch upstream
$ git merge upstream/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でできました。&lt;/p&gt;

&lt;h2 id=&#34;pull-reqを正しく送る:2dca43de771e000956be34eb6f9f4ef2&#34;&gt;Pull-Reqを正しく送る&lt;/h2&gt;

&lt;p&gt;まず、masterでpull-req送るととりこまれるまで自分のマスターへのコミットが反映され続けるんですね。それで一回失敗。&lt;/p&gt;

&lt;p&gt;じゃあ、ということでブランチを切ることに。するとまた問題が。まあ、自分がアホっていったらアホなんですけど&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_A_ _B_ _C_
*_/ ___\A&#39;/___ \B&#39;/___\C&#39;_HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなブランチの作り方してしまいました。&lt;code&gt;A&lt;/code&gt;,&lt;code&gt;B&lt;/code&gt;,&lt;code&gt;C&lt;/code&gt;それぞれでpull-req送ったんですけど当然&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A : A
B : B-A&#39;
C : C-B&#39;-A&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなヒストリのまま送られるわけです。&lt;code&gt;A&lt;/code&gt;,&lt;code&gt;B&lt;/code&gt;,&lt;code&gt;C&lt;/code&gt;は同じファイルの違う箇所への変更なのでヒストリを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_C_
      /_B_
     /_A_ 
*_/ ______ HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにしたいわけです。&lt;code&gt;magit.el&lt;/code&gt;さんにお助け願おうかと思いましたが、そもそも出来るか分らないのでTwitterで投げてみたところ、@mod_poppo氏に助けていただきました。&lt;code&gt;git reset&lt;/code&gt;と&lt;code&gt;git cherry-pick&lt;/code&gt;でできます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A&lt;/code&gt;のブランチは問題ないので&lt;code&gt;B&lt;/code&gt;でやると、まず私は&lt;code&gt;magit.el&lt;/code&gt;で必要な&lt;code&gt;B&lt;/code&gt;のコミットを調べておいて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset --hard *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;*&lt;/code&gt;に&lt;code&gt;HEAD&lt;/code&gt;を戻して&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;で加えた変更を全て破棄。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git cherry-pick B-commits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;B&lt;/code&gt;での変更のみ適用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push -f origin branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で自分のリポジトリに反映(=pull-reqにも反映)&lt;br /&gt;
としました。&lt;code&gt;*&lt;/code&gt;と&lt;code&gt;B-commits&lt;/code&gt;はそれぞれリビジョンIDを調べて下さいね。&lt;/p&gt;

&lt;p&gt;私の説明じゃ分りづらいと思うので &lt;a href=&#34;http://d.hatena.ne.jp/murank/20110327/1301224770&#34;&gt;http://d.hatena.ne.jp/murank/20110327/1301224770&lt;/a&gt; にあるすばらしい図を参考にして下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rails Tutorial</title>
      <link>/post/rails-tutorial/</link>
      <pubDate>Tue, 03 Sep 2013 22:15:00 +0000</pubDate>
      
      <guid>/post/rails-tutorial/</guid>
      <description>&lt;p&gt;夜中にコーヒー飲むと眠れなくなりますね。昨晩もコーヒー飲んだら朝まで眠れず、寝たのが朝8時半、起きたのが16時でした。明日提出のレポート終ってないのに…&lt;/p&gt;

&lt;p&gt;さて、かなり良いRuby on Railsのチュートリアルを見付けたので紹介します。&lt;br /&gt;
 &lt;a href=&#34;http://railstutorial.jp&#34;&gt;Ruby on Rails チュートリアル：実例を使ってRailsを学ぼう&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これはただのrailsの紹介ではなくてgitだとかherokuだとかを使ってかなり実践的にアプリケーションを作ていくものです。1, 2章で軽くrailsを動かしてみたあと、3章以降でテスト駆動開発でアプリケーションを構築していきます。&lt;/p&gt;

&lt;p&gt;このテスト駆動開発の環境がすばらしいのなんのって、最初動かしたとき思わずニヤリとしました。しかも何故か(何も設定してないのに)Emacsのモードバーの色がテストの結果に応じて変わるという。&lt;br /&gt;
マウス操作もキーストロークも無くコードの正しさを教えてくれるのは非常に快適でした。&lt;/p&gt;

&lt;p&gt;文体も訳本にありがちな片言の日本語ではなく読み易いですし、Ruby自体の解説もあり、「Scaffoldを使えば簡単にできるんだぜ~」じゃなくてちゃんとMVCの関係とかを解説して身に付いた上で「今後はScaffoldでより手軽に作れるよ」なのでRailsに限らずWeb開発のチュートリアルとして秀逸でした。&lt;/p&gt;

&lt;p&gt;私もまだ5章までしか進めてないのですが是非一度試してみて下さい&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Githubの変更を追う</title>
      <link>/post/rss-of-github/</link>
      <pubDate>Mon, 02 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/rss-of-github/</guid>
      <description>&lt;p&gt;こんばんは。κeenです。普段、Github上で最新のソースを追ってるプロジェクトはこまめにgit pullすることで更新を確認してたのですが、別の方法があることに気づきました。&lt;/p&gt;

&lt;p&gt;単純にWatchという便利な機能もあるのですが、RSSでソースを追うこともできるようです。RSSのアイコンが見当らなかったのでないものと思ってましたがちゃんとあるんですね。&lt;/p&gt;

&lt;p&gt;RSSのAPIはgithub.com/ORG/PROJECT/commits/BRANCH.atomになります。&lt;br /&gt;
たとえばMirahのmasterブランチの最新のコミットを受け取りたかったら、&lt;br /&gt;
 &lt;a href=&#34;https://github.com/mirah/mirah/commits/master.atom%20%20&#34;&gt;https://github.com/mirah/mirah/commits/master.atom&lt;/a&gt;になります。試してませんがcommitsのところをissuとかにすればissuを追えるのかもしれません。&lt;/p&gt;

&lt;p&gt;watchとの違いは、watchはwikiの変更やissuなど全てを追うところと、通知がメール and/or github上での通知なところですね。&lt;/p&gt;

&lt;p&gt;メールじゃなくてgithubの通知でもなくてRSSで受け取りたい方は試してみてはいかがでしょうか。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>