<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ジェネリクス on κeenのHappy Hacκing Blog</title>
    <link>/categories/%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%82%AF%E3%82%B9/index.xml</link>
    <description>Recent content in ジェネリクス on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%82%AF%E3%82%B9/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ジェネリクス勉強会補足</title>
      <link>/blog/2017/06/24/jienerikusubenkyoukaihosoku</link>
      <pubDate>Sat, 24 Jun 2017 23:22:16 +0900</pubDate>
      
      <guid>/blog/2017/06/24/jienerikusubenkyoukaihosoku</guid>
      <description>&lt;p&gt;κeenです。本日&lt;a href=&#34;https://connpass.com/event/56773/?utm_campaign=event_participate_to_owner&amp;amp;utm_source=notifications&amp;amp;utm_medium=email&amp;amp;utm_content=title_link&#34;&gt;ジェネリクス勉強会&lt;/a&gt;で発表したのですがいくつか拾いきれないコメントがあったのでここでお返事書きます&lt;/p&gt;

&lt;p&gt;発表スライドは&lt;a href=&#34;https://keens.github.io/slide/jienerikusu_disupatchi_omoteura/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;ジェネリクスの実装はポインタ方式とテンプレート方式だけじゃないよ&#34;&gt;ジェネリクスの実装はポインタ方式とテンプレート方式だけじゃないよ&lt;/h1&gt;

&lt;p&gt;もちろんです。
基本的な手法を大別しただけで、私の発表中にもポインタ方式でも最適化がありえるとの指摘がありましたし、ジェネリクス勉強会中でも.NETの実装の話も出てました。
勉強会全体を見ているならここで私がフォローするまでもないかと思いますが、念のため拾っておきます。&lt;/p&gt;

&lt;h1 id=&#34;クロージャの件が分からない&#34;&gt;クロージャの件が分からない&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;クロージャの型は関数型じゃないの？&lt;/li&gt;
&lt;li&gt;無名関数は関数に名前がないだけで型はあるんじゃないの？&lt;/li&gt;
&lt;li&gt;なんで(Iteratorのmapとかの)返り値に関数型がでてくるの&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rustの挙動を知らないとちょっと分かりづらかったですね。それとあとで見返したら私も発表中一箇所嘘いってました。
詳しいことをコード例を出しながら説明していきます&lt;/p&gt;

&lt;h2 id=&#34;rustのクロージャの型は匿名化された型&#34;&gt;Rustのクロージャの型は匿名化された型&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru/&#34;&gt;Rustのクロージャ3種を作って理解する | κeenのHappy Hacκing Blog&lt;/a&gt;や&lt;a href=&#34;http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/&#34;&gt;Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog&lt;/a&gt;
で若干説明しましたが、Rustではクロージャリテラル毎に型が作られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut x = 0;
let mut counter = || { x += 1; x}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こう書いたときにコンパイラは裏で以下のようなコードを生成します。（Rustを知らない人への説明のため、FnOnceの存在や実際は参照でキャプチャするなどを無視した疑似コードです）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct AnonymousClosure{x: i32}
impl FnMut&amp;lt;()&amp;gt; for AnonymousClosure {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (): ()) -&amp;gt; i32 {
        self.x += 1;
        x
    }
}
let mut x = 0;
let mut counter = AnnonymousClosure{x: x}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要点は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クロージャ自体はただのキャプチャしたデータの集まり&lt;/li&gt;
&lt;li&gt;関数本体は、メソッドとして定義される。 &lt;strong&gt;Rustは静的ディスパッチをする&lt;/strong&gt; ので &lt;strong&gt;関数ポインタはデータには含まれない&lt;/strong&gt;。コンパイラが解決する。

&lt;ul&gt;
&lt;li&gt;私が1つ嘘を言っていたというのはここです。関数ポインタもデータに含まれるって言っちゃってました。&lt;/li&gt;
&lt;li&gt;クロージャだけど関数ポインタを使わないんですね&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;1クロージャリテラルにつき1型を生成することでクロージャリテラル毎の関数本体を出し分けている&lt;/li&gt;
&lt;li&gt;キャプチャした変数をまとめた構造体自体はポインタ型になっていない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クロージャ自体の型は関数型ではなくて、関数っぽい振舞いをするトレイト(ここでは&lt;code&gt;FnMut&lt;/code&gt;)を実装しているだけのただの無名型です。&lt;/li&gt;
&lt;li&gt;無名関数だから型が無名という説明は確かにちょっとおかしかったですね。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;クロージャを返したい&#34;&gt;クロージャを返したい&lt;/h2&gt;

&lt;p&gt;ここから「なんで(Iteratorのmapとかの)返り値に関数型がでてくるの」へのお返事。&lt;/p&gt;

&lt;p&gt;説明の例として遅延評価するイテレータへのマップを書きたいと思います。
引数にはイテレータとクロージャを取ります。
実際には適用する訳ではないのでマップするイテレータとクロージャの組を返せばよさそうですね。
ここで思い出して欲しいのはクロージャはただの&lt;code&gt;FnMut&lt;/code&gt;を実装している構造体なのでした。
なのでこう書くのですが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn map&amp;lt;I, B, F&amp;gt;(i: I, f: F) -&amp;gt; (I, F)
where
  I: Iterator,
  F: FnMut(I::Item) -&amp;gt; B,
{
  (I, F)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にクロージャを渡したときには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn map(i: SomeIter, f: AnnonymousClosure) -&amp;gt; (SomeIter, AnnonymousClosure)
{
  (i, f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようになります。ここでも、クロージャデータにはポインタが挟まってないことに注意して下さい。そして型名が分かるのでクロージャを呼び出すときにはその関数が &lt;strong&gt;静的ディスパッチされます&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返り値にクロージャの型を書く = クロージャの関数本体が静的ディスパッチされる = 速い&lt;/p&gt;

&lt;p&gt;ということが伝わりますでしょうか。なのでRustではできるかぎり返り値にクロージャの型を書きたいのです。&lt;/p&gt;

&lt;p&gt;で、このパターンだと引数で受け取ったものを返り値で返すだけなので関数を呼んだときに得られた名前を書くだけです。たとえクロージャが匿名型であっても書くことができます。&lt;/p&gt;

&lt;h2 id=&#34;返り値にだけ書きたい&#34;&gt;返り値にだけ書きたい&lt;/h2&gt;

&lt;p&gt;ところが返り値にだけクロージャの型を書こうとすると、ダメです。先程の&lt;code&gt;map&lt;/code&gt;関数を関数の中で使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn inc&amp;lt;I&amp;gt;(i: I) -&amp;gt; ???
where
  I: Iterator&amp;lt;Item = i32&amp;gt;,
{
  map(i, |x| x + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすると型はこう解決されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;sturct AnnonymousClosure;
impl FnMut&amp;lt;(i32,)&amp;gt; for AnonymousClosure {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (x,): (i32,)) -&amp;gt; i32 {
        x + 1
    }
}

fn inc(i: SomeItr) -&amp;gt; (SomeItr, AnnonymousClosure)
{
  map(i, AnnonymousClosure::new())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値にだけ匿名型が出てきました。
先程のようにパラメータで受け取ってそのまま返すということができません。
なのでここで、返り値も匿名化する存在型が必要になるのです。&lt;/p&gt;

&lt;p&gt;ここまでくれば以下のコードにも存在型が必要な理由が分かりますでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn do_later() -&amp;gt; impl Future&amp;lt;Item = (), Err = Error&amp;gt; {
    do_something()
        // ここでクロージャが出てきた
        .and_then(|()| do_another_thing())
        // 本来の`and_then`の返り値は
        // `AndThen&amp;lt;Self, B, F&amp;gt;`だが
        // `F`の型が匿名化されていて書けない
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;存在型って-forallでできるよ&#34;&gt;存在型って、forallでできるよ&lt;/h1&gt;

&lt;p&gt;マジレスなのかただ知識を披露してるのかよく分からなかったのですが、いちおうお返事書いておきます。&lt;/p&gt;

&lt;p&gt;どの意味で「forall」でできるよと言っているのかよく分からなかったのですが、Coqの実装を見ていっているのなら見当違いです。
Coqの実装はこの辺が参考になりますかね。 &lt;a href=&#34;http://inkar-us-i.hatenablog.com/entry/2016/11/16/175844&#34;&gt;Coqで「任意のxについて…」「あるxが存在して…」を扱う - きくらげ観察日記&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;これをRustで書くとこうなるでしょうか。Rustにはトレイトをパラメータで受け取る手段がないのでひとまず量化する一階の述語を&lt;code&gt;Fn() -&amp;gt; ()&lt;/code&gt;トレイトにしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct FnExists&amp;lt;F: Fn() -&amp;gt; ()&amp;gt;(f: F)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは命題論理としては正しいのですが、型パラメータを取るので目的である匿名化を実現できていません。&lt;/p&gt;

&lt;p&gt;もう1つは、CPS変換の可能性もあります。
この辺が参考になりますかね。&lt;a href=&#34;http://myuon-myon.hatenablog.com/entry/2016/05/11/215734&#34;&gt;データ型のCPS変換について - Just $ A sandbox&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;直観論理でも以下が成り立ちます。&lt;/p&gt;

&lt;p&gt;\[
{}^\exists x P(x) \to \lnot ^\forall x \lnot P(x)
\]&lt;/p&gt;

&lt;p&gt;因みに逆は直観論理では成り立ちません（直感的な説明をすると存在しないことを否定しても実際の値を構成できないからです）。&lt;/p&gt;

&lt;p&gt;これは確かに正しいです。「&lt;code&gt;Tr&lt;/code&gt;トレイトを実装した型」という存在型は以下の疑似コードで書けるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Tr{}
fn exists() -&amp;gt; FnOnce&amp;lt;A&amp;gt;(FnOnce&amp;lt;T: Tr&amp;gt;(t: T) -&amp;gt; A) -&amp;gt; A {
  let tr = SomeTr::new();
  forall &amp;lt;A&amp;gt; move |cont: FnOnce&amp;lt;T: Tr&amp;gt;(t: T) -&amp;gt; A| -&amp;gt; A { cont(tr) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですがまあ、これは実際には無理です。
1つにはRustには型の高ランク多相がありません。ランク1多相だけです。
もしランクの概念を知らずにforallで書けると主張しているならそれは的外れです。
ランクの概念を知った上で高ランク多相を入れろという主張なら理解はできますが、無理です。
引数に渡す関数や返り値で返す関数、要はデータとして扱う関数はジェネリクスにできません。
スライドの中でRustはテンプレート方式と説明しましたが、ジェネリクスはテンプレートであって実際のデータではないので値として扱えないのです。
なのでRustのコンパイル方式を大きく変えるなどしないと実現できないでしょう。&lt;/p&gt;

&lt;p&gt;それにもう1つ、ランクとは関係なしにクリティカルな理由があります。
上で説明した通り、クロージャの実際の型は匿名データ型になります。なので返り値に型として書くことができません。
冷静になって考えれば返り値のクロージャの型を書かないようにするための存在型のために返り値にクロージャの型を書くのは土台無理です。&lt;/p&gt;

&lt;p&gt;さて、私の知識では全称型で存在型を構成する手法はこれくらいですがもし上記以外の構成方法が存在して、私が明後日な返事をしているなら連絡下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ジェネリクス ディスパッチ 表裏</title>
      <link>/slide/jienerikusu_disupatchi_omoteura/</link>
      <pubDate>Sat, 17 Jun 2017 22:25:35 +0900</pubDate>
      
      <guid>/slide/jienerikusu_disupatchi_omoteura/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# ジェネリクス ディスパッチ 表裏
----------------------
[ジェネリクス勉強会 - connpass](https://connpass.com/event/56773/?utm_campaign=event_participate_to_owner&amp;utm_source=notifications&amp;utm_medium=email&amp;utm_content=title_link)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# はじめに
-----------

* 例にはJavaとRustを使います
  + それ以外にあまり詳しくない
  + たまにScalaが出てくるかも
* 主に裏側で何が起きてるかに焦点を当てます
* 一般的な手法の比較と言語固有実装の比較がやや混じります
  + 実例重視
* 言語や機能を選ぶときの知識が増えればよし

===
# ジェネリクス
--------------

* 型でパラメータ化された何か
* パラメータ化する方法にいくつか方式が
  + 任意の型に対応する実装にする
    - Java
  + 使う型毎に実体をつくる
    - 型が引数になるイメージ
    - Rust
* 便宜上前者をポインタ方式、後者をテンプレート方式と呼ぶ

===
# 関数ジェネリクス
-----------------

* Javaコード


``` java
public class Generics {
    public static void main(String[] args) {
        Generics g = new Generics();
        System.out.println(g.id(&#34;hello&#34;));
    }

    &lt;T&gt; T id(T t) {
        return t;
    }
}
```

===

# 関数ジェネリクス
-----------------

* Javaアセンブリ

```
public class Generics {
  // ...
  // Tの中身に言及していない
  &lt;T&gt; T id(T);
    Code:
       0: aload_1
       1: areturn

```

===

# 関数ジェネリクス
-----------------

* Rustコード

``` rust
fn id&lt;T&gt;(t: T) -&gt; T {
    t
}


fn main() {
    println!(&#34;{}&#34;, id(&#34;hello&#34;));
}
```

===

# 関数ジェネリクス
-----------------

* Rustアセンブリ

``` llvm
define internal %str_slice @_ZN3tmp2id17hfe175cfdb5be0f46E(i8* noalias nonnull readonly, i64) unnamed_addr #0 {
start:
  ; str_sliceに特化した関数を生成している
  %2 = insertvalue %str_slice undef, i8* %0, 0
  %3 = insertvalue %str_slice %2, i64 %1, 1
  ret %str_slice %3
}
```

===

# 関数ジェネリクス
-----------------

* ポインタ方式は`void *`使ってるイメージ
  +  コンパイルされたコードがコンパクト
  + 必ずポインタ経由する
    + Javaのオブジェクトは参照になってるのであまり問題ない
* テンプレート方式は型毎に`id_XXX`関数を定義してるイメージ
  + 構造体の値渡しも可能
  + オブジェクトコードは大きくなる
  + 関数の使用箇所が分からないとコンパイルできない

===

# 返り値ジェネリクス
-------------------

* Rustは返り値のジェネリクスがある
  - コンテキストで返り値が決まる
  ```rust
  // str
  parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt; where
    F: FromStr;
  ```
  ```rust
  let addr: SocketAddr = &#34;127.0.0.1:8080&#34;.parse().unwrap();
  ```
* コンパイル中に実際の型が解決されるので関連関数（スタティックメソッド）が呼べる
* キモいけど便利


===

# データ型ジェネリクス
---------------------

* `ArrayList&lt;T&gt;`(Java) vs `Vec&lt;T&gt;`(Rust)
* だいたい関数のときと似たような特徴
* テンプレート方式はサイズやアラインメントまで考慮できる
  - `Vec&lt;u8&gt;`(バイト列型)が効率的
* Rustの場合は構造体定義はオブジェクトコードに出ないのでサイズは気にならない

===

# 制約とディスパッチ
-------------------

* パラメータ型に条件をつけたい
  + Javaならインターフェースで `T extends SomeInterface` とか
  + Rustならトレイトで `T: SomeTrait` とか
* さらにパラメータ型の詳細にアクセスしたい
  + `t.someMethod()` とか
* このメソッドってどっからやってくるの？

===

``` java
&lt;W extends Writer&gt; void writeHello(W w) throws IOException {
    // このwriteメソッドはどこから？
    w.write(&#34;Hello&#34;);
}
```

``` rust
fn write_hello&lt;W: io::Write&gt;(mut w: W) -&gt; io::Result&lt;()&gt; {
    // このwrite_allメソッドはどこから？
    w.write_all(b&#34;Hello&#34;)
}
```

===

# 動的ディスパッチ
-------------------
* Javaだとオブジェクトに紐付くメソッドテーブルを *実行時* に引く
  + テーブルもオブジェクトから *実行時* に取得する
   ``` java
   w.vtable[write](w, &#34;Hello&#34;);
   ```
* ダイナミックなことができる
  + サブクラスのインスタンスと入り交じっても問題無
    ```java
    Writer w = new MyWriter();
    obj.writeHello(w);
    ```
* vtable引くオーバーヘッドがかかる
  - [java - Virtual table/dispatch table - Stack Overflow](https://stackoverflow.com/questions/6606481/virtual-table-dispatch-table)
  - [jvm - Java method table - Stack Overflow](https://stackoverflow.com/questions/10225668/java-method-table)

===

# 静的ディスパッチ
-----------------
* Rustだとメソッドを *コンパイル時* に解決する
  + テーブルを静的に解決するだけじゃなくてテーブルのメソッドまで解決
  ```rust
   SomeWriter::write(w, b&#34;Hello&#34;)
  ```
  + 辞書オブジェクトはみんなの心の中にあるんだよ
    - (テーブルだけ静的に解決する方式もある)
* 速い
  + オーバーヘッドがない
  + メソッドのインライン化などの最適化ができる

===
# 動静まとめ
------------

* ポインタ方式で動的ディスパッチだとコンパクトだけど遅い
* テンプレート方式で静的ディスパッチだと速いけど嵩む
* 特徴は表裏な感じ


===
# Java固有の問題と解決
----------------------

* ジェネリクスとプリミティブ問題
* → ヴァルハラ
* → Scalaのspecialized
* → DottyのLinker

===

# ジェネリクスとプリミティブ問題
--------------------------------

* ジェネリクスは必ずポインタ経由
  + プリミティブはどうするの？
* 一旦オブジェクトに包む(ボクシングする)必要がある
  + 関数もデータ型も同じ問題
  + 関数は暗黙の変換があるので気付きづらい
* 割と深刻なパフォーマンス低下を招くこともある


===

``` java
public class Generics {
    public static void main(String[] args) {
        Generics g = new Generics();
        // プリミティブを渡す
        System.out.println(g.id(0));
    }

    &lt;T&gt; T id(T t) {
        return t;
    }
}

```


===

```
public class Generics {
  public static void main(java.lang.String[]);
   // ..
    Code:
      // ..
      // ここで一旦`Integer`を作る
      13: invokestatic  #5                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      16: invokevirtual #6                  // Method id:(Ljava/lang/Object;)Ljava/lang/Object;
      19: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
      22: return

  &lt;T&gt; T id(T);
    Code:
       0: aload_1
       1: areturn

}

```

===

# ヴァルハラ
------------

* [OpenJDK: Valhalla](http://openjdk.java.net/projects/valhalla/)
  + [JEP 169: Value Objects](http://openjdk.java.net/jeps/169)
  + [JEP 218: Generics over Primitive Types](http://openjdk.java.net/jeps/218) ← こっち
* プリミティブタイプもボクシングせずにジェネリクスに使える
* やったね
* いつ入るんだろうね。
* [JDK 9](http://openjdk.java.net/projects/jdk9/) にはまだっぽい？

===

# [scala.specialized](http://www.scala-lang.org/api/2.9.2/scala/specialized.html)
-------------

* ジェネリクスの他にプリミティブ毎に専用のメソッドを生成
* 半分テンプレート方式みたい
  ``` scala
  class MyList[@specialized T]  ...
  ```
* 実際には使われない型に対しても生成してしまう
  + → テンプレート方式よりも非効率
  + 型パラメータが3つあったら1000メソッドくらい出来てしまう
* &gt; 関数の使用箇所が分からないとコンパイルできない

  + JVMの分割コンパイル下では何が使われるか事前に分からない

===

# DottyのLinker
---------------

* &gt; 関数の使用箇所が分からないとコンパイルできない
* リンクフェーズを用意すれば使用箇所が全て分かる
* [Dotty Linker: Making your Scala applications smaller and faster](https://d-d.me/talks/scaladays2015/#/)
  + スライドを見る限りspecializeしといてDCE?
* 実際には生のバイトコードじゃ情報が足りないのでTASTYも付加
* Dottyはいつ使えるようになるんでしょうね。

===

# Rust固有の問題と解決
---------------------

* トレイト境界とヘテロな型の問題
  * ヘテロなVec
  * 分岐からのreturn
* → トレイトオブジェクト

===
# トレイト境界とヘテロな型の問題
-------------------------------

* ジェネリックデータ型に2つ以上の異なる型を入れられない
* つまり以下のようなコードが書けない
  ``` rust
  trait Processor {}
  let procs: Vec&lt;Processor&gt; = vec![
    TwProc::new(),
    FbProc::new(),
  ];
  ```
* トレイトは実際の型ではないので同じ振舞をしても共通の型として扱えない
* でも一緒に扱いたいケースがあるんだけど？？

===
# トレイト境界とヘテロな型の問題2
-------------------------------

* 分岐して型を出し分けるのも出来ない
  ```rust
  fn getProc() -&gt; Processor {
    if xxx {
      TwProc::new()
    } else {
      FbProc::new()
    }
  }
  ```

===

# トレイトオブジェクト
---------------------

* オプトインで動的ディスパッチする仕組み
* データとトレイトからvtableを作る
* `Box`や`&amp;`などポインタ型を通すと使える

===

``` rust
let procs: Vec&lt;Box&lt;Processor&gt;&gt; = vec![
  Box::new(TwProc::new()),
  Box::new(FbProc::new()),
];

```

``` rust

fn getProc() -&gt; Box&lt;Processor&gt; {
  if xxx {
    Box::new(TwProc::new())
  } else {
    Box::new(FbProc::new())
  }
}
```
===

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;span style=&#34;font-size:400%;&#34;&gt;裏&lt;/span&gt;

===

# ジェネリクスの双対
-------------------

* ジェネリクスは$\forall$の量化
  + 関数$T \to S$に対して${}^\forall x(T \to S)$
* $\exists$の量化があってもよくない？
  + 存在型と呼ばれる
  + 因みに${}^\exists x(T \to S)$は虚無

===

# 存在型
---------

* 「`P`を満たす`T`が存在する」ことを表わす型
* `P`とは？
  + 本来は型を引数にとる述語。
    + e.g.) 「`T`は`S`のサブタイプである」「`T`は`write`メソッドを持つ」
  + 実際は型の集合の方が便利
    - $P(x) \iff x \in \\{x| {}^\forall x, P(x) \\}$
  + Scala: `forSome`に続く何か
    - よく分からなかった。構造的superset?
  + Rust: トレイト境界
* 実際に使うときには`P`を満たす`T`を1つ与える
* 実際の型を変数`T`に匿名化してるとも見れる
  - Rustなら「トレイト`Tr`を実装しているとある型`T`」
===

# 引数の存在型
---------------

* Scalaの`forSome`
  ```scala
  def len(l: List[T] forSome {type T}): Int
  ```
* Rustのarg position `impl Trait`
  ```rust
  fn len(i: impl IntoIterator) -&gt; usize
  ```
* `R`が`x`を含まないなら
  \\\[{}^\forall x(A(x) \land x \to R) \leftrightarrow {}^\exists x (A(x) \land x) \to R \\\]
  なのでほぼジェネリクス
* 違い
  + 関数が型パラメータを持たなくなる
  + 量化した場所以外（他の引数や返り値）でその型変数を使えない

===
# 返り値の存在型
----------------

* Rustの`impl Trait`
  ```rust
  fn do_later() -&gt; impl Future&lt;Item = (), Err = Error&gt;
  ```
* 実際の型は関数の定義で決まっている
* 実質返り値を匿名化しているだけ
* 必要？

===
# 存在型の利点
--------------

* 何をしたいか伝わりやすい
  ```rust
  // Iterator
  map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; where ...
  ```
  vs
  ```rust
  map&lt;B, F&gt;(self, f: F) -&gt; impl Iterator where ...
  ```
* サブタイピングがあればアップキャストで終わる
* Rustでも動的ディスパッチを許せばトレイトオブジェクトがある
  + でも絶対動的ディスパッチをしたくない

===
# 存在型の必要性
----------------

* 存在型でないと書けない型が存在する
  + 匿名化した型を含む型
  + クロージャ、お前のことだ
* 以下の型はジェネリクスでは書けない
  ``` rust
  fn counter(x: isize) -&gt; impl FnMut() -&gt; isize;
  ```

* 動的ディスパッチを許せばトレイトオブジェクトで書ける
  + でも絶対動的ディスパッチをしたくない
  + 極端な話、関数抽象する度にパフォーマンスが落ちる

===

# ユースケース
--------------

* 実際そんなに必要なの？
* 極一部のケースだけじゃないの？
* 分岐したら結局トレイトオブジェクト必要なんじゃなかった？
* 動的ディスパッチで妥協できないの？

===

# `Iterator`
------------

* 標準ライブラリ
* 遅延評価
  * 融合変換するため
* `map`すると元のイテレータとmapする関数の組が返る
  ```rust
  // Iterator
  map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; where ...
  ```
* `impl Trait`で書くと分かりやすい
  ```rust
  map&lt;B, F&gt;(self, f: F) -&gt; impl Iterator where ...
  ```

===

# [futures-rs](https://github.com/alexcrichton/futures-rs)
-----------------

* 非同期処理を抽象化
* 実行時にはステートマシンになる
  + 動的ディスパッチを挟まない
* `Future`に`map`や`and_then`すると返り値に関数型が出てくる
  + 存在型がないと書けない
  + 引数でクロージャを受け取る訳ではないのでジェネリクスで書けない
* `Future`を使うほぼ全てのコードで存在型が必要になる

===
# futures-rs
------------

``` rust
fn do_later() -&gt; impl Future&lt;Item = (), Err = Error&gt; {
    do_something()
        // ここでクロージャが出てきた
        .and_then(|()| do_another_thing())
        // 本来の`and_then`の返り値は
        // `AndThen&lt;Self, B, F&gt;`だが
        // `F`の型が匿名化されていて書けない
}
```

===
# [transaction-rs](https://github.com/KeenS/transaction-rs)
------------------

* トランザクションを抽象化
* コンセプト的には`futures-rs`に似てる
* 分岐しても`branch` APIでトレイトオブジェクト回避
  + 直和型を信じろ
* [マイクロベンチマーク](https://github.com/KeenS/transaction-rs/blob/master/transaction-stm/benches/boxed_vs_branch.rs)だとトレイトオブジェクトをなくすと *13%* 高速化

===
# transaction-rs
----------------

```rust
fn find_and_delete() -&gt; impl Transaction&lt;Item = Option&lt;User&gt; ...&gt; {
  match find_user() {
    // 分岐の枝毎に違う型を返そうとしてるが、直和型を使えば問題無
    None =&gt; ok(none).branch().first()
    Some(user) =&gt;
      delete_user()
        .map(move|_| user)
        .branch()
        .second()
  }
}
```


===
# 存在型の深掘
--------------

* ユーザには匿名化された型の実体は分からない
* コンパイラは実際の型で扱う
* 色々エッジケースが出てきそう
  + 同じ関数から返る型は同じ型？
  + 違う関数でも実体が同じなら？
  + 関数がジェネリクスだったら？
    - 返り値もジェネリクスパターン
    - 引数だけジェネリクスパターン
  + トレイトのメソッドだったら？
* 例えば`vec![foo(), bar()]`って書けるの？

===

``` rust
fn foo&lt;T: Trait&gt;(t: T) -&gt; impl Trait {t}

fn bar() -&gt; impl Trait {123}

fn equal_type&lt;T&gt;(a: T, b: T) {}

equal_type(bar(), bar());                      // OK
equal_type(foo::&lt;i32&gt;(0), foo::&lt;i32&gt;(0));      // OK
equal_type(bar(), foo::&lt;i32&gt;(0));              // ERROR, `impl Trait {bar}` is not the same type as `impl Trait {foo&lt;i32&gt;}`
equal_type(foo::&lt;bool&gt;(false), foo::&lt;i32&gt;(0)); // ERROR, `impl Trait {foo&lt;bool&gt;}` is not the same type as `impl Trait {foo&lt;i32&gt;}`
// トレイトのメソッドには`impl Trait`は書けないらしい
```

===
# 話さなかったこと
-----------------

* 存在型のライフタイム
* Rustのfeatureとリリーススケジュール
  + 存在型はまだリリース版には入っていない
* 関連型と存在型の関係(なんか関係ありそう)

===

# まとめ
--------

* 総称を表わすジェネリクスというのがあるよ
* ジェネリクスの実装は2種類あるよ
* 存在を表わす存在型というのがあるよ
* 存在型の実装は2種類あるよ
* 2種類の実装は言語機能や型システムに密着してるよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>