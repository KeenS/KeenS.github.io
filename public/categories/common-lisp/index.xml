<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Common Lisp on κeenのHappy Hacκing Blog</title>
    <link>/categories/common-lisp/</link>
    <description>Recent content in Common Lisp on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Feb 2016 23:47:34 +0900</lastBuildDate>
    <atom:link href="/categories/common-lisp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Common Lispで高速行列演算</title>
      <link>/blog/2016/02/04/common_lispdekousokugyouretsuenzan</link>
      <pubDate>Thu, 04 Feb 2016 23:47:34 +0900</pubDate>
      
      <guid>/blog/2016/02/04/common_lispdekousokugyouretsuenzan</guid>
      <description>

&lt;p&gt;κeenです。Common Lispから線形代数ライブラリを使うポストで比較にCommon Lispのコードが出されていたのですがもう少し改良出来そうだったので少しばかり高速化してみました。&lt;/p&gt;

&lt;p&gt;そのポストはこちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://d.hatena.ne.jp/masatoi/20160204/1454519281&#34;&gt;Common Lispで行列演算: LLA(Lisp Linear Algebra)を使う - 翡翠はコンピュータに卵を生むか&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;圧倒的にCommon Lispが遅いですね。そのコードはこちらから。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tanakahx.hatenablog.com/entry/2015/09/25/070000&#34;&gt;Python (NumPy) と Common Lisp (LLA) で行列積の実行速度を比較する - 不確定特異点&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;行列計算(GEMM)部分を抜き出すとこうなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun simple-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))
      (dotimes (row rows)
        (dotimes (col cols)
          (dotimes (k cols)
            (incf (aref result row col)
                  (* (aref ma row k) (aref mb k col))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを&lt;code&gt;*N*&lt;/code&gt; = 256, で100回繰り返したら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   4.688 seconds of real time
;;   4.692000 seconds of total run time (4.688000 user, 0.004000 system)
;;   100.09% CPU
;;   13,564,728,093 processor cycles
;;   26,216,000 bytes consed

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とのこと。まあ、まだ高速化の余地はありそうです。&lt;/p&gt;

&lt;h1 id=&#34;キャッシュする:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;キャッシュする&lt;/h1&gt;

&lt;p&gt;内側のループをみるとこうなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;          (dotimes (k cols)
            (incf (aref result row col)
                  (* (aref ma row k) (aref mb k col))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;incf&lt;/code&gt;をばらすとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;          (dotimes (k cols)
            (setf (aref result row col)
                  (+ (aref result row col) (* (aref ma row k) (aref mb k col)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値として参照している方の&lt;code&gt;(aref result row col)&lt;/code&gt;は&lt;code&gt;k&lt;/code&gt;に依存しないのでループの外に出せます。
書き込んでいる方は場所だから仕方ない。&lt;/p&gt;

&lt;p&gt;これをキャッシュするようにすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun caching-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((cell (aref result row col)))
           (dotimes (k cols)
             (setf (aref result row col)
              (+ cell (* (aref ma row k) (aref mb k col)))))
           )))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じパラメータでベンチマークをとると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; 3.971 seconds of real time
;; 3.972000 seconds of total run time (3.972000 user, 0.000000 system)
;; 100.03% CPU
;; 11,491,319,119 processor cycles
;; 26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ループアンローリング:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;ループアンローリング&lt;/h1&gt;

&lt;p&gt;さて、先程の内側のループ、仕事が少ないですね。小さな仕事をチマチマループしてるとイテレーションコストが嵩みます。
1回のイテレーションでの仕事を増やすべく、ループアンローリングをしましょう。&lt;/p&gt;

&lt;p&gt;コピペはダルいのでまずはマクロを。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro dotimes-unroll ((i n unroll) &amp;amp;body body)
  (let ((n_      (gensym &amp;quot;n&amp;quot;)))
    `(let ((,n_ ,n))
       (do ((,i 0))
           ((&amp;lt; ,n_ (the fixnum (+ ,unroll ,i)))
            (do ((,i ,i (the fixnum (1+ ,i))))
                ((&amp;lt; ,n_ (the fixnum (1+ ,i))))
              ,@body
              ))
         ,@(loop :repeat unroll :append (append body `((setq ,i (the fixnum (1+ ,i))))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;少し試してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(dotimes-unroll (i 10 3)
  (format t &amp;quot;~%~a&amp;quot;) i)
0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。&lt;/p&gt;

&lt;p&gt;それではこれを使ってアンロールします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun loop-unroll-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((cell (aref result row col)))
           (dotimes-unroll (k cols 16)
             (setf (aref result row col)
              (+ cell (* (aref ma row k) (aref mb k col))))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アンロール数は16が一番パフォーマンス出たようでした。&lt;/p&gt;

&lt;p&gt;さて、ベンチマークをしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   3.847 seconds of real time
;;   3.848000 seconds of total run time (3.848000 user, 0.000000 system)
;;   [ Run times consist of 0.012 seconds GC time, and 3.836 seconds non-GC time. ]
;;   100.03% CPU
;;   11,128,993,432 processor cycles
;;   26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;辛うじて速くなってる…。因みにこれのパフォーマンスはCPUの命令キャッシュの状況に依存するので何度か試すとこれより速いスコアが出ることもあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Evaluation took:
  3.338 seconds of real time
  3.340000 seconds of total run time (3.332000 user, 0.008000 system)
  [ Run times consist of 0.020 seconds GC time, and 3.320 seconds non-GC time. ]
  100.06% CPU
  9,657,259,219 processor cycles
  26,248,768 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;メモリアクセスしない:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;メモリアクセスしない&lt;/h1&gt;

&lt;p&gt;さて、最初にキャッシュした時に書き込まれている方の &lt;code&gt;(aref result row col)&lt;/code&gt; は場所だからキャッシュ出来ないといいました。まあ、それは正しいのですがループの中で毎回書き込む必要はありません。&lt;/p&gt;

&lt;p&gt;レジスタ上で計算を済ませて最後に書き込んであげれば十分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun on-register-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let ((rows (array-dimension ma 0))
        (cols (array-dimension mb 1)))
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (row rows)
        (dotimes (col cols)
          (let ((res (aref result row col)))
           (dotimes-unroll (k cols 16)
             (setf res
                   (the single-float (+ res (* (aref ma row k) (aref mb k col))))))
           (setf (aref result row col) res))))
      result)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを試してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; Evaluation took:
;;   2.302 seconds of real time
;;   2.304000 seconds of total run time (2.300000 user, 0.004000 system)
;;   [ Run times consist of 0.008 seconds GC time, and 2.296 seconds non-GC time. ]
;;   100.09% CPU
;;   6,662,273,812 processor cycles
;;   26,216,000 bytes consed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;わお！急に速くなりました。 &lt;code&gt;(* 100 (- (/ 4.688 2.302) 1))&lt;/code&gt; ≒ 103、 100%近い高速化です。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;特に深い意味はなかったのですがパタヘネに載っていたやつを試してみたくて遊んでみました。&lt;/p&gt;

&lt;p&gt;普通に行列計算したいなら線形代数ライブラリ使った方が良いと思います。&lt;/p&gt;

&lt;h1 id=&#34;ノート:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ループアンローリングの部分をイテレーションコストで説明しましたが他にも1ループ内の命令数が増えると組み合わせパズルのピースが増えるので最適化されやすくなります。まあ、SBCLは覗き穴最適化をほとんどしないのであまり意味ありませんが。気になる方はディスアセンブルしてみて下さい。&lt;/li&gt;
&lt;li&gt;このあと、 &lt;code&gt;(aref mb k col)&lt;/code&gt; がCPUキャッシュを無駄にしているという話からキャッシュサイズ毎に行、列を分けて計算するやり方を紹介しようとしたのですが逆に遅くなってしまいました。付録Aにコードを置いておきます。うーむ。&lt;/li&gt;
&lt;li&gt;本当はさらにこのセグメント毎にスレッドに計算を投げて並列化したかったのですがセグメントで高速化しなかったので萎えて諦めました。&lt;/li&gt;
&lt;li&gt;パタヘネ的にはSIMDも使うのですが深夜に近付いてきて面倒になったのでこの辺でやめました。Common Lisp(SBCL)からSIMD命令を使うには&lt;a href=&#34;http://keens.github.io/blog/2014/12/02/vopdeyou-bu/&#34;&gt;私の過去のエントリ&lt;/a&gt;を参照して下さい。&lt;/li&gt;
&lt;li&gt;本気で行列計算をしたいなら今回の $O(n^3)$ のアルゴリズムだけでなくStrassenのアルゴリズムやCoppersmith-Winogradのアルゴリズムも検討すべきです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;付録a:ac3da300d14ff6fe33746d6ed93b7e0b&#34;&gt;付録A&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun segmented-gemm (ma mb)
  &amp;quot;Common Lispのみを使った行列積の計算&amp;quot;
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  (declare (type (simple-array single-float (* *)) ma mb))
  (let* ((segment 16)
         (rows (array-dimension ma 0))
         (cols (array-dimension mb 1))
         (rowseg (floor rows segment))
         (colseg (floor cols segment))
         rowtmp coltmp
         row col
         )
    (declare (type fixnum rows cols))
    (let ((result (make-matrix rows cols)))
      (declare (type (simple-array single-float (* *)) result))

      (dotimes (ri rowseg)
        (setf rowtmp (the fixnum (* ri segment)))
        (dotimes (ci colseg)
          (setf coltmp (the fixnum (* ci segment)))
          (dotimes (rs segment)
            (setf row (the fixnum (+ rowtmp rs)))
            (dotimes-unroll (cs segment 8)
              (setf col (the fixnum (+ coltmp cs)))
              (let ((res (aref result row col)))
                (dotimes-unroll (k cols 2)
                  (setf res
                        (the single-float (+ res (* (aref ma row k) (aref mb k col))))))
                (setf (aref result row col) res))))))
      result)))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>マクロについて整理してみる</title>
      <link>/blog/2015/07/04/makuronitsuiteseirishitemiru</link>
      <pubDate>Sat, 04 Jul 2015 15:34:46 +0900</pubDate>
      
      <guid>/blog/2015/07/04/makuronitsuiteseirishitemiru</guid>
      <description>

&lt;p&gt;何故Lisperがマクロについて語るのか。Lisperと議論してみても満足のいく答を得た人はそんなにいないと思う。
それはLisper自身便利とは思っていても何が便利なのかを意識してなくて他人に上手く説明出来ないからじゃないかと思った。
ちょっと思いついた範囲でまとめてみる。&lt;/p&gt;

&lt;p&gt;最近ではマクロシステムを持つ言語は珍しくない。Rust, Scala, Template Haskell, Mirahなどなど。最初にCommon Lispのマクロと他の言語のマクロとの違いを少し考えてみたい。&lt;/p&gt;

&lt;h1 id=&#34;unless:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Unless&lt;/h1&gt;

&lt;p&gt;まず、unlessをマクロで書くことを考えてみたい。単純にifにnotをつければいい。&lt;/p&gt;

&lt;p&gt;Common Lispではこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(if (not foo-p)
    bar)

(defmacro unless (cond then)
  `(if (not ,cond)
       ,then))

(unless foo-p
  bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rustだとこうなるだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
if ! isFoo {
    bar;
}

macro_rules! unless {
    ($cond:expr, $then:stmt) =&amp;gt; {{
        if ! $cond {
            $then
        }
    }};
}

unless!(isFoo, {
    bar;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいはmirahだとこうなる。unlessが予約語なので_unlessにした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if ! isFoo
  bar
end

macro def _unless(cond, block:Block)
  quote{
    if ! `cond`
      `block.body`
    end
  }
end

_unless isFoo do
  bar
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみにCだとこう出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;if(! is_foo)
  bar;

#define unless(cond) if(!(cond))

unless(is_foo)
  bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、上のマクロたちを見比べて欲しい。Common LispのマクロとCのマクロは違和感なく新たな制御構造を作れたのに対してRustとMirahはマクロ呼び出しが剥き出しになっている。&lt;/p&gt;

&lt;p&gt;ここで注意して欲しいのはCはともかくCommon Lisp、Rust、Mirahのマクロは全て引数に必要な構文木をとってそのまま用意したテンプレートにあてはめているだけだ。やっていることに違いはない。
何が違うかというとマクロ呼び出しの構文が制御構造の構文と同じか違うかという点だけだ。私の知る範囲ではそのような構文をした言語はLispしかない。だから「Lispの」マクロなのだ。&lt;/p&gt;

&lt;p&gt;もう一つ。どのマクロ定義も十分直感的に読めたと思う。この範囲なら &lt;strong&gt;S式だからマクロが簡単になるということはない&lt;/strong&gt; と思う。別にS式でなくてもquasiquoteがあれば十分読み易いマクロが書ける。&lt;/p&gt;

&lt;h1 id=&#34;case:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Case&lt;/h1&gt;

&lt;p&gt;caseを生成することを考えよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun fun1 (x)
  (let ((y (case x
             ((:foo) (hoge &amp;quot;foo&amp;quot;))
             ((:bar) (hoge &amp;quot;bar!&amp;quot;)))))
    ...))


(defun fun2 (x)
 (let ((y (case x
            ((:foo) (hoge &amp;quot;foo&amp;quot;))
            ((:baz) (hoge &amp;quot;baz!&amp;quot;)))))
   ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように似たような、しかし微妙に違うcaseが必要になったような時に必要だろう。この時、&lt;code&gt;&#39;(:foo (hoge &amp;quot;foo&amp;quot;) :bar (hoge &amp;quot;bar!&amp;quot;))&lt;/code&gt;のようにリテラルでそのまま書いてしまっては抽象化する意味がなくなる。例えばハッシュテーブルにKey-Valueペアを入れて必要な時に入れたり削除したりすればよい。そのようなマクロはこう書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro case-table (key hash)
  `(case ,key
     ,@(loop
          :for k :being :the :hash-key :of hash :using (hash-value v)
          :collect `((,k) ,v))))

(defparameter *table*)
(setf (gethash :foo *table*) &#39;(hoge &amp;quot;foo&amp;quot;))
(setf (gethash :bar *table*) &#39;(hoge &amp;quot;bar!&amp;quot;))

(defun fun1 (x)
  (let ((y (case-table x #.*table*)))
    ...))

(remhash :bar *table*)
(setf (gethash :baz &#39;(hoge &amp;quot;baz!&amp;quot;)))


(defun fun2 (x)
  (let ((y (case-table x #.*table*)))
    ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ハッシュテーブルを受け取ってリストを返す普通のloopマクロの力をマクロ展開時にも使える。また、ハッシュテーブルには&lt;code&gt;&#39;(hoge &amp;quot;foo&amp;quot;)&lt;/code&gt;などのただのリストを突っ込んだがそれをそのままASTとしても使っている。
Common Lispのマクロのもう1つの良いところはマクロの展開時にもCommon Lispの機能がフルで使えるところであり、マクロの引数に受け取るのが構文木でありデータ構造でもあるS式なところだ。ここでは &lt;strong&gt;S式の同図像性が重要なファクターになっている&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(case-table x #.*table*)&lt;/code&gt; で使っている &lt;code&gt;#.&lt;/code&gt; は &lt;em&gt;リードマクロ&lt;/em&gt; といってマクロ展開(コンパイル時)より前(リード時、構文解析時)に動作するマクロだ。このリードマクロはeval-when-readといってリード時に
値を評価する。その結果、&lt;code&gt;case-table&lt;/code&gt;に渡るのが &lt;code&gt;&#39;*table*&lt;/code&gt;というシンボルでなく&lt;code&gt;*table*&lt;/code&gt;に束縛されているハッシュテーブルになる。因みに &lt;em&gt;コンパイラマクロ&lt;/em&gt; というマクロ展開が終わった後に動作するマクロもある。&lt;/p&gt;

&lt;p&gt;マクロ1つではなくマクロの前後に動作するマクロもあってこそ初めて柔軟性を手にしている。あまりその点は議論されてないのではないだろうか。&lt;/p&gt;

&lt;h1 id=&#34;common-lispの設計:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Common Lispの設計&lt;/h1&gt;

&lt;p&gt;さて、各々言語には予約語や~構文というものがあると思う。メソッド定義構文など。Common Lispにもスペシャルフォームという名前で&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm&#34;&gt;25&lt;/a&gt;個存在する。
驚くべきことに、ここまでに出てきたCommon Lispのコードにはスペシャルフォームは3つしか出てこない。ifとletとquoteだ。setfやloop、defun、defmacro、case、defparameterなんかはマクロで出来ている。&lt;/p&gt;

&lt;p&gt;defunまでマクロで出来ているということはユーザがその気になれば関数定義の構文に手を入れたりも出来るということだ。
普通、そんなことをしたら阿鼻叫喚だがCommon Lispなら安全に出来る。マクロもシンボルに束縛されているので新たにマクロで上書きしたシンボルを名前空間にインポートしなければ今まで通りのdefunやloopが使える。&lt;/p&gt;

&lt;p&gt;もう1つ、普段使うものがマクロで出来ているということはマクロを被せてない機能は相当低レベルだということだ。マクロさえ書けば全く新しい言語機能を追加出来るということであり、あるいは&lt;a href=&#34;http://cl21.org/&#34;&gt;全く新しい言語も作れてしまう&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;このような設計はマクロで制御構造までも作れるから出来るのだ。関数定義構文をマクロで定義している言語はLisp以外に私は知らない。&lt;/p&gt;

&lt;h1 id=&#34;メタプログラミングとcommon-lisp:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;メタプログラミングとCommon Lisp&lt;/h1&gt;

&lt;p&gt;ところで、マクロに限らないメタプログラミングについて考えてみたい。メタプログラミングとは、プログラムを書くプログラムを書くことだ。プログラムはテキスト形式のソースコードから実行形式に至るまでの間に様々な中間形式から中間形式に変換される。メタプログラミングはそのどこかの形式を生成することと同義になる。通常、処理系内部で使う形式は変なことをされると困るのであまり外部に公開したくない。メタプログラミングを許すとしても構文解析などのフロントエンドに近い部分になるだろう。&lt;/p&gt;

&lt;p&gt;例えばyaccやlexのようなソースコードジェネレータ、rubyやDのような文字列ベースのメタプログラミングは公開APIであるところのパーサだけを使っているので安全性は高い。しかし文字列だけだと構造がないので書く側はつらい。一応、Common Lispにもread関数とeval関数があるのでCommon Lispのソースコード文字列を吐いてreadしてevalすれば文字列メタプログラミングは出来る。特に嬉しくないのでやらないが。&lt;/p&gt;

&lt;p&gt;次はトークンベースのメタプログラミングがある。Cのプリプロセッサなど。Common Lispでもリードマクロで可能だ。例えば正規表現リテラルを作ったりとかの例がある。&lt;/p&gt;

&lt;p&gt;次はASTベースのメタプログラミングがある。マクロだ。これは今まで見てきた。&lt;/p&gt;

&lt;p&gt;これより先はメタプログラミングとはあまり言わない気がする。JITと呼ぶのではないか。Common Lispにもeval関数やcompile関数があるからそういうことも出来る。正規表現ライブラリなんかが使っている。&lt;/p&gt;

&lt;p&gt;私が言いたいのはCommon Lispにはメタプログラミングの機構が一杯あるということではない。read, eval, compile…。気付いたかもしれないが、LispはLisp自身で出来ている。
Lispを書くとき、Lispを書いてるかもしれないしLispを構成するLispを書いているかもしれない。いくらでもメタプログラミングが出来るということだ。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;何やらCommon Lisp賛美歌になってしまったが一応まとめておく。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;簡単なマクロ定義ならS式である必要はない&lt;/li&gt;
&lt;li&gt;複雑なマクロ定義ならS式であると書き易い。恐らく他の構文でも書けないことはない。&lt;/li&gt;
&lt;li&gt;マクロ呼び出し構文はS式でないと重大な違いがある。&lt;/li&gt;
&lt;li&gt;マクロ以外にもリードマクロやパッケージなど他の言語機能があってこそマクロが活きる。&lt;/li&gt;
&lt;li&gt;言語機能だけでなくマクロを前提とした設計も重要である。&lt;/li&gt;
&lt;li&gt;LispはS式で出来ている以前にLispで出来ている。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>あなたの知らないShebang</title>
      <link>/blog/2015/06/26/anatanoshiranaishebang</link>
      <pubDate>Fri, 26 Jun 2015 23:24:44 +0900</pubDate>
      
      <guid>/blog/2015/06/26/anatanoshiranaishebang</guid>
      <description>

&lt;p&gt;κeenです。最近は何故かBlack君って呼ばれます。Shebangの書き方にはいくつかあって、それを利用したふと面白い方法を思い付いたので共有を。&lt;/p&gt;

&lt;p&gt;さて、ご存知Shebangといえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにファイルの1行目が&lt;code&gt;#!&lt;/code&gt;から始まっているとシェルがそれ以降の文字列を実行可能ファイルのパス名として捜して実行してくれるものですが、実は&lt;code&gt;#!&lt;/code&gt;は唯一のフォーマットではありません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#!&lt;/code&gt;がデファクトになる前なのかそもそもシェルにコメントがなかった時代のものなのかは知りませんが昔は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;: /bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;:&lt;/code&gt;で始めていたらしいです。因みに&lt;code&gt;:&lt;/code&gt;は「何もしないコマンド」です。実質的にコメントとして扱ったり副作用のある変数展開だけを行なったりプログラマティックコメントアウトだったりの用途で使われてます。&lt;/p&gt;

&lt;p&gt;さて、シェルは全て文字列なのでクォートしてもしなくても構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてもちゃんと動いてくれます。なぜわざわざクォートするかというと&lt;a href=&#34;//KeenS.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/&#34;&gt;割と処理系ポータブルなCommon Lisp実行可能ファイルを作る | κeenのHappy Hacκing Blog&lt;/a&gt;のように別の言語のスクリプトとして実行される時に文字列リテラルになってくれると単純に無視されるので互換性が高まるのです。&lt;/p&gt;

&lt;p&gt;ということで完全版ポータブルなCommon Lisp実行可能ファイルはこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;

#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abclとcclが利用可能になりました。あとCIMも捜すようにしました。roswellは作者に訊いて下さい。&lt;/p&gt;

&lt;p&gt;ちなみに、shebangの解釈はシェルに依存するのですが、B Shell, csh, tcsh, dash, Bash, zshで動作確認しました。古い機能なので新しいシェルほど切り捨てている可能性があったのですがBashやzshが大丈夫だったので良かったです。
一応非推奨な気がしますがこれしか方法がないので仕方ないですね。&lt;/p&gt;

&lt;p&gt;ということでみなさんスクリプト書きましょう。&lt;/p&gt;

&lt;h1 id=&#34;追記:97aff0076544159c37193ad080a89d0a&#34;&gt;追記&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangの解釈はシェルじゃなくてOSのexec()がやります。で、#!や認識できるバイナリ以外は、exec()がエラーを返した後でシェルがファイルを見て、テキストファイルならシェルスクリプトとして実行ってやってます。なので先頭が:の場合は(続&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614551978526445570&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangとしてではなく、シェルがシェルスクリプトとして読んでるだけなので、その後に/bin/shとか書いてあっても関係ないはず (シェルによってはそこも見るかもしれませんが)&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614552151759589376&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということで実験してみたところ、先頭の&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;はどのシェルも読み飛ばす模様(つまり、&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/usr/bin/ruby&amp;quot;&lt;/code&gt;と書いてもrubyが実行される訳ではない)。&lt;/p&gt;

&lt;p&gt;で、先程の 完全版から&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;を取り除いて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても動いたのでこれが最終版ということになります。&lt;/p&gt;

&lt;p&gt;大学の講究でMINIX本やったどころかexecのところ自分の担当だったのに恥かしい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Common Lisp処理系拡張の探求 SBCLのマルチスレッドサポート</title>
      <link>/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</link>
      <pubDate>Sat, 20 Jun 2015 18:30:52 +0900</pubDate>
      
      <guid>/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
### Common Lisp 処理系拡張の探求
SBCLのマルチスレッドサポート

----------------------
Lisp Meet Up #29

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# CLのマルチスレッド
----------------------------
## [bordeaux-threads](https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation)
* 色々な処理系のマルチスレッドサポートの抽象レイヤー
* デファクトスタンダード
  + スレッド
  + ロック
  + コンディションヴァリアル


# SBLCのマルチスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# SBLCのマルチスレッド
----------------------------

* スレッド
  + スレッド内エラー
* アトミック操作&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
  + CAS&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* 排他制御（ロック）
* セマフォ
* コンディションヴァリアル
* バリア
* キュー&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* メールボックス&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* ゲート&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* frlock&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;


# アトミック操作

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# アトミック操作
----------------
複雑な動作は同じデータに並行に動かすと壊れうる

```
        [var = 1]
[incf]      |      [decf]
 [1]&lt;-------|
  |         |------&gt;[1]
 [2]---&gt;[var = 2]    |
            |        | 
        [var = 0]&lt;--[0]
```

# アトミック操作
----------------

* `atomic-{incf, decf}`
  + 動作出来る場所が限られている
* `atomic-{pop, push, update}`
  + CASプロトコルを実装していればどこでも


# CASプロトコル
---------------
* compare and swap
* アトミック操作の基本中の基本
  + ハードウェアレベルのサポート
* ざっくり言うと並行版setf
* `(cas place old new env)`
  + もし`place`が`old`に等しければ`new`を代入
* `(defun (cas foo) (old new))`
  + `cas`版の`setf`定義
* 他にも`setf`相当の機能は揃ってる

# CASプロトコル
---------------

```lisp
(defvar *foo* nil)

(defun (cas foo) (old new)
  (cas (symbol-value &#39;*foo*) old new))
```


# キュー
--------

* 普通のキュー
* スレッドセーフ
* `enqueue`, `dequeue`が基本操作
* `dequeue`が多値で、ブロックしない
  + 空なら第二値がnilになる


# メールボックス
---------------

* キューとほぼ同じ
* スレッドセーフ
* `send-message`, `recieve-message`が基本操作
* `recieve-message`はブロックする
  + タイムアウトも設定出来る
* `recieve-message-no-hangはdequeue`と同じ挙動
* `recieve-pending-messages`もある


# ゲート
--------

* 複数のスレッドが1つのイベントを待つ時に使う
* `wait-on-gate`, `open-gate`, `close-gate`が基本操作


```
[gate (closed)]  [T1] [T2] [T3]
     |            |    |    |
     |     wait   |    |    |
     |&lt;----------------+----+
     |            |    .    .
     |     open   |    .    .
[gate (opened)]&lt;--+    .    .
     +----------------&gt;+---&gt;+
         go            |    |
                       V    V
```


# frlock
--------

* Fast Read Lock
* またの名をRead-Write Lock
* Read Lockは多重に取れる。Write Lockは1つしか取れない。
* 基本操作は`frlock-read`と`frlock-write`
* 普通のlockと違って複数のReadが速くなる


# まとめ
--------

* SBCLのマルチスレッドサポートはbordeaux-threadsよりもリッチ
* 処理系の独自サポート面白い
* 処理系に依存してしまってもいいんじゃないだろうか
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispで限定継続と遊ぶ</title>
      <link>/slide/Common_Lispdegenteikeizokutoasobu_/</link>
      <pubDate>Sun, 26 Apr 2015 21:09:07 +0900</pubDate>
      
      <guid>/slide/Common_Lispdegenteikeizokutoasobu_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Common Lispで限定継続と遊ぶ
----------------------
[Lisp Meet Up #27](https://atnd.org/events/64988)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# Agenda
--------

0. cl-contの紹介
1. 限定継続の話
2. 限定継続の使い方の話
3. 限定継続の実装の話


# CL-CONTの紹介

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CL-CONT
---------

* Common Lispの限定継続ライブラリ
* 結構古くからあるっぽい
* 割と色々なライブラリが使ってる

# CL-CONT
---------

![cl-cont dependers](/images/cl-cont-dependers.png)

# API
-----

* 継続を区切るマクロ
  + `with-call/cc`
  + `defun/cc`
  + `lambda/cc`
* 継続を取得するマクロ
  + `call/cc`
  + `let/cc`

※後で説明するので意味が分からなくても問題ないです。


# 限定継続の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後トップレベルに戻るまでの計算。
* Schemeが一級市民として扱えることで有名
* 値として取り出した時は0-1引数関数として振る舞う

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      □)))
```

# 継続とは
----------
あとはそれを関数にするだけ

```lisp
(lambda (k)
  (mapc #&#39;writ-line
        (loop :for x :in list
           :collect (if (evenp x)
                        k))))
```


# 限定継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後 *指定した位置* に戻るまでの計算。
* 継続がトップレベルまで戻るのに対して限定継続途中で止まる。それだけ。
* 部分継続などの言い方もある
  + 英語もpart contとdelimited contで分かれる


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(loop :for x :in list
           :collect (if (evenp x)
                        □))
```


# 限定継続とは
-------------

```lisp
(lambda (k)
  (loop :for x :in list
     :collect (if (evenp x)
                  k)))
```

# 限定継続の挙動
---------------
普通のやつ

```lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```

これは

```lisp
(+ 1 2)
```

と等価

# 限定継続の挙動
---------------
今度は継続を呼ばないでみる

```lisp
(with-call/cc
  (+ 1 (call/cc (lambda (k) 2))))
```

これは

```lisp
2
```

と等価

# 限定継続の挙動
---------------
もうちょっと呼ばない例  
(`(let/cc k ...)` = `(call/cc (lambda (k) ...))`)

```lisp
(with-call/cc
  (write-line &#34;hello&#34;)
  (let/cc k 1)
  (write-line &#34;world&#34;))
```

は

```lisp
(progn
  (write-line &#34;hello&#34;)
  1)
```

と等価


# 限定継続の使い方の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の使い方の話
---------------------

* グリーンスレッド
* コールバックを綺麗に書き換える
* 非決定性計算
* etc...


## グリーンスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


## グリーンスレッド
-----------------

* またの名をコルーチン
* またの名を強調スレッド



## グリーンスレッド
-----------------
```lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```

## グリーンスレッド
-----------------
実行結果

```
in thread A 1
in main thread 1
in thread A 2
in main thread 2
in thread A 2
in main thread 3

```


## コールバックの書き換え

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## コールバックの書き換え
----------------------
本当はこう書きたい

```lisp
(with-event-loop
    (format t &#34;Hello, ~a!~%&#34; (async-read stream)))
```

## コールバックの書き換え
----------------------
しかしライブラリがコールバック関数を要求してくる

```lisp
(with-event-loop
    (async-read stream (lambda (line)
                         (format t &#34;Hello, ~a!~%&#34; line))))
```

## コールバックの書き換え
-----------------------
コールバック = 限定継続（後述）なのでこうしてやれば良い。

```lisp
(with-event-loop
    (with-call/cc
      (format t &#34;Hello, ~a!~%&#34;
              (call/cc (lambda (k))
                       (async-read stream k)))))
```

## 非決定性計算

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## 非決定性計算
-------------
### ベースアイディア

* 継続を関数として取り出した後同じ処理を何回も実行出来るんじゃね？


## 非決定性計算
-------------
### ベースアイディア
複数回呼び出してみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (list (funcall c 1)
        (funcall c 2)
        (funcall c 3)))
```


## 非決定性計算
-------------
### ベースアイディア
普通の1引数関数として使ってみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (mapcar c (list 1 2 3)))
```

## 非決定性計算
-------------
### ベースアイディア
マクロでラップしてみる

```lisp
(defmacro for (&amp;body expr)
  `(with-call/cc ,@expr))
(defmacro in (m)
  `(let/cc k (apply #&#39;append (mapcar k ,m))))
(defun yield (x) (list x))
(defun unit () nil)
```


## 非決定性計算
-------------
使ってみる

```lisp
(for
  (let ((x (in &#39;(1 2 3)))
        (y (in &#39;(a b c))))
    (yield (cons x y))))
```

```
((1 . A) (1 . B) (1 . C) (2 . A) (2 . B) (2 . C) (3 . A) (3 . B) (3 . C))
```


# 限定継続の実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の実装の話
-------------------

* 継続は0~1引数関数として取り出せるのであった。
  + 実は機械的に取り出せる
* 継続は全ての式に暗黙に存在するのであった
  + 全ての式を継続を明示的に使うようにも出来る


# CPS変換

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CPS変換
---------

* 全ての関数の引数を1つ増やして、そこで継続を受け取る
* 値を返す時は暗黙のreturnを使うのではなく明示的に継続を呼ぶ
* 関数を呼ぶ時は必ず継続を渡す。呼び出し元には返ってこない（自然と末尾再帰になる）


# CPS変換
---------
例えば

```lisp
(with-call/cc
  (foo (call/cc
        (lambda (k)
          (funcall k 2)))))
```

は、取り出された継続が

```lisp
(lambda (k) (foo k))
```

。


# CPS変換
---------
よって

```lisp
((lambda (k) (foo k)) 2)
```

と変換される


# CPS変換
---------
再帰関数だと少し面倒

```lisp
(defun fact (n)
  (if (&lt;= n)
      1
      (* n (fact (- n 1))))))

```

が

```lisp
(defun fact (n c)
  (if (&lt;= n)
      (c 1)
      (fact (- n 1) (lambda (v) (* n v)))))
```

となる


# CPS変換
---------

* CPS変換を行なうことでいつでも継続を値として使える


# 限定継続の実装の話
-------------------

* CPS変換を裏で行なっている
* 自動で出来るのでマクロで変換をしている
  + 組み込み関数は変更出来ないので特別扱い
  + スペシャルフォームも気をつける必要がある
* `lambda`が乱立するのでパフォーマンスは酷い。


# まとめ
-------

* cl-contというライブラリがあって、限定継続が扱える
* 限定継続は処理を中断したり再開したり繰り返したりに使える
* 裏ではえげつないことをやっている
* パフォーマンスが必要なところでは使っちゃダメ


# 参考
------
* [picrin/partcont.scm at master · picrin-scheme/picrin](https://github.com/picrin-scheme/picrin)
* [cl-cont | Quickdocs](http://quickdocs.org/cl-cont/)
* [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)
* [継続渡しスタイル - Wikipedia](http://ja.wikipedia.org/wiki/%E7%B6%99%E7%B6%9A%E6%B8%A1%E3%81%97%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB)
* [M.Hiroi&#39;s Home Page / お気楽 Scheme プログラミング入門](http://www.geocities.jp/m_hiroi/func/abcscm20.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>caveman2、ningle…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト</title>
      <link>/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</link>
      <pubDate>Thu, 05 Mar 2015 13:18:44 +0900</pubDate>
      
      <guid>/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# caveman2、ningle、datafly…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト
----------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;ずっと俺のターン&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 問題
------
Common Lispは case

* Sensitive &lt;!--.element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;  
* Insensitive &lt;!--.element: class=&#34;fragment shrink&#34; data-fragment-index=&#34;1&#34; --&gt;

どっち?

# 問題
-------

あれ？

```lisp
(eql? &#39;CaseInsensitive &#39;caseinsensitive) ;=&gt; t
```


# 問題
-------

リーダがデフォルトで大文字にするだけ
```lisp
(eql? &#39;|CaseSensitive| &#39;|casesensitive|) ;=&gt; nil
```


# Caveman2
---------

```lisp
@route GET &#34;/hello&#34;
(defun say-hello (&amp;key (|name| &#34;Guest&#34;))
  (format nil &#34;Hello, ~A&#34; |name|))
```

# Ningle
--------

```lisp
(setf (ningle:route *app* &#34;/login&#34; :method :POST)
      #&#39;(lambda (params)
          (if (authorize (getf params :|username|)
                         (getf params :|password|))
            &#34;Authorized!&#34;
            &#34;Failed...Try again.&#34;)))
```

# 面倒…
----
デフォルトでそのままだたっらいいのに

# 魔法の`readtable-case`

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 魔法の`readtable-case`
-----------------------
```lisp
(setf (readtable-case *readtable*) :invert)
```
を使えばOK  
参考: [SBCLでclispとかallegroのmodern mode的なことをする - wasabizの日記](http://wasabiz.hatenablog.com/entry/20120929/1348889601)

# 例
----
```lisp
CL-USER&gt; :username
:USERNAME
CL-USER&gt; (setf (readtable-case *readtable*) :invert)
:invert
CL-USER&gt; :username
:username
```

# まとめ
--------
* `(setf (readtable-case *readtable*) :invert)`を使うと快適だよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>既存のテンプレートエンジンの問題点と再設計</title>
      <link>/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</link>
      <pubDate>Mon, 02 Mar 2015 23:36:03 +0900</pubDate>
      
      <guid>/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt;
.red {
color: red;
}
&lt;/style&gt;
# 既存のテンプレートエンジンの問題点と再設計、あるいはArrowsについて
-----------------------------------------------------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 野生のLisper
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

# Template Engines

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Existing Architeture
----------------------
0. (リクエスト)
1. アプリ
  0. 引数を計算
  1. テンプレートに引数を渡す
  2. レスポンスをレンダリング &lt;!--.element: class=&#34;fragment grow&#34;  --&gt;
4. レスポンスをサーバに渡す
5. (レスポンス)

# Rendering?
----------------------
* 結合した文字列はクライアントに返ったらその後はゴミ
 + GCへ負荷がかかる (後述)
* クライアントにとって1つの文字列である必要はない
* むしろ返せる部分だけ先に返した方が得（後述）

# GC Pressure (SBCL)
-----------------
* 世代別Copy GC
* 結合した文字列は比較的大きい
* `alloc_space`に入らない大きさならアロケートが遅い
* GCを頻繁に起動してしまう
* 16KBを越えると特別扱いされて遅い/メモリを喰う
* LispのWebアプリはレスポンスタイムの分散が大きい（要出展）

参考: [SBCL GENCGC @ x86 Linux](http://cl-www.msi.co.jp/reports/sbcl-gc-memo.html)

# Split Response
---------------
例えば、こんなの

&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot; xml:lang=&amp;quot;en&amp;quot; lang=&amp;quot;en-us&amp;quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://localhost:1313//reveal.js/lib/css/xcode.css&amp;quot;&amp;gt;
        &amp;lt;script src=&amp;quot;//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
        ....
        &amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body class=&amp;quot;li-body&amp;quot;&amp;gt;
    &amp;lt;header&amp;gt;{{ header }}&amp;lt;/header&amp;gt;
    {{ body }}
    ...
&lt;/code&gt;&lt;/pre&gt;

# Split Response
---------------
1. `{{ header }}`の前に先頭から`&lt;header&gt;`までを返す
2. `{{ header }}`を返す
3. `&lt;/header&gt;`を返す
4. `{{ body }}`を返す

...


# Pros of Split Response
------------------------
* `header`を計算してる間にクライアントにhead部分が渡る
  + 先に`&lt;link&gt;`や`&lt;script&gt;`を要求出来る
  + サーバ側のスループットやレスポンスタイムは変わらないが
    クライアントのレンダリング完了までの時間は大幅に短縮出来る
* 文字列を結合する必要がない
* 定数部分については長さが判ってるので最適化し易い

# How TEs Work 
---------------------------
## Compilation
1. テンプレート文字列
 + パーサ &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
 + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数

# How TEs Work 
---------------------------
## Rendering
1. レンダリング関数
 + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列

# Misc Problems
---------------
* サーバに渡すのは文字列なのにソケットに書き込む時はオクテット？
  + 文字列で返す？オクテットで返す？（デバッグがー）
  + オクテットの変換はいつ？
* ストリームが遅い？
  + POSIX APIが使える&#34;なら&#34;fdの方が速い？
* ユーザが用意したバッファに書き出したい？
* テンプレートに渡す引数が定数文字列なら畳み込める筈？
* リクエストの度にテンプレートパースするのは筋悪だけど開発中は毎回コンパイルするのは面倒？

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;

# Arrows

Template flies like an arrow

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Arrows
--------
* [KeenS/arrows](https://github.com/KeenS/arrows)
* 現在開発中のテンプレートエンジン
* 複数のテンプレートが選べる（予定）
* 複数のバックエンドが選べる
* バックエンドに依ってはnon-consing

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Compilation
1. テンプレート文字列&lt;span class=&#34;red&#34;&gt; + 定数引数&lt;/span&gt;
  + パーサ&lt;span class=&#34;red&#34;&gt;(default, cl-emd互換...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
  + &lt;span class=&#34;red&#34;&gt;最適化(const folding, concat, convert...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
  + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数&lt;span class=&#34;red&#34;&gt;(string, octets, stream, fast-io ...)&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Rendering
1. レンダリング関数
  + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列&lt;span class=&#34;red&#34;&gt;、オクテット列、ストリーム書き出し、fast-io…&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How compiled
--------------
```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を
```lisp
(compile-template-string :xxx
  &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34; ())
```
とコンパイル

# Stream backend
----------------
&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* ほとんどアロケートしない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Octet backend
----------------
```lisp
(lambda (&amp;key name)
  (with-fast-output (buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;&lt;h1&gt;Hi &#34;)
       buffer)
    (fast-write-sequence
      (string-to-octets
        (encode-for-tt (princ-to-string name)))
                       buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;!&lt;/h1&gt;&#34;)
      buffer)))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を

```lisp
(compile-template-string :stream
   &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34;
   &#39;(:known-args (:name &#34;&lt;κeen&gt;&#34;)))
```
とコンパイル

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## variable folding
```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string (encode-for-tt &#34;&lt;κeen&gt;&#34;) stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 既知の引数は畳み込む
* 文字列なら`princ-to-string`しない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## const folding
```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string &#34;&amp;lt;κeen&amp;gt;&#34; stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 定数のエスケープはコンパイル時に済ませる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## append sequence
```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &amp;lt;κeen&amp;gt;!&lt;/h1&gt;&#34;
                stream))
```
* 複数シーケンスの書き出しは1つにまとめる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
* 引数計算の遅延
* 引数計算の並列化
* 非同期化
* HTML compction

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の遅延
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は必要になったら値を計算する(Promise パターン)
```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の並列化
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は並列に計算して必要になったら値を要求する(Futureパターン)
```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 非同期化
* 単純にwriteを非同期にする
* 他にFutureもブロックするので非同期Futureを使う

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## HTML compction
```html
&lt;ol&gt;
  &lt;li&gt; item 1 &lt;/li&gt;
  &lt;li&gt; item 2 &lt;/li&gt;
  &lt;li&gt; item 3 &lt;/li&gt;
&lt;/ol&gt;

```
を
```html
&lt;ol&gt;&lt;li&gt;item 1&lt;/li&gt;&lt;li&gt;item 2&lt;/li&gt;&lt;li&gt;item 3&lt;/li&gt;&lt;/ol&gt;

```
* DOM構造が変わってしまう


&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# TODOs
-------
* 設計上複数シンタックスをサポート可能だがまだしてない
* 既存のテンプレートエンジンとの比較ベンチマーク
* 高速化
* 多機能化
  + テンプレート
  + 最適化
  + バックエンド
* clackとの連携
  + clackのAPIはメモリアロケーションが多めに必要になる

# Summary
---------
* 既存のテンプレートエンジンは非効率
  + メモリを無駄遣いしていた
  + ユーザーのことを考えてなかった
* 新しいテンプレートエンジンを設計した
  + メモリアロケーションをあまりしない
  + ユーザー側の速度まで考慮した
  + 柔軟
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispのポータビリティとユニバーサリティ</title>
      <link>/blog/2015/01/22/common-lisp-portability-and-univesality</link>
      <pubDate>Thu, 22 Jan 2015 07:51:02 +0000</pubDate>
      
      <guid>/blog/2015/01/22/common-lisp-portability-and-univesality</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://clfreaks.org/post/108341635899/1-cim-vs-roswell&#34;&gt;clfreaks&lt;/a&gt;の収録時に他のLisperと話してて価値観というか目標を共有出来てないなと思ったのでここで心情を語る次第。今のCommon Lispの使われ方には問題がある。&lt;/p&gt;

&lt;p&gt;Common Lispにはポータビリティというかユニバーサリティというか、そういうものがない。いや、処理系の作者達はしっかり作ってるのだけどLisperがそういう使い方をしていない。&lt;/p&gt;

&lt;p&gt;例えば、Rubyで出来たアプリケーションを使いたいとしよう。Jekyllがいいかな。大抵のシステムには入ってるだろうが一応処理系のインストールから始めてみる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aptなりpkgなりyumなりで処理系をインストールする。それが気に入らなければソースからインストールしてもいい。&lt;/li&gt;
&lt;li&gt;処理系をインストールするとgemがついてくるので&lt;code&gt;gem install jekyll&lt;/code&gt;を叩く。&lt;/li&gt;
&lt;li&gt;あとはJekyllを使うだけ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あるいは、Octopressなら処理系のインストールのあとは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git cloneしてくる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gem install bundler&lt;/code&gt;でbundlerをインストールする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bundle install&lt;/code&gt;で依存gemをインストールする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bundle exec rake preview&lt;/code&gt;でサーバーが起動する。&lt;/li&gt;
&lt;li&gt;止めたければCtrl-Cで止まる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Common Lispで出来たアプリケーションを使いたいとしよう。&lt;a href=&#34;https://github.com/vsedach/cliki2&#34;&gt;cliki&lt;/a&gt;。がいいかな。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;処理系のインストールはRubyと同じくパッケージマネージャで入る。あるいはソースからインストールしてもいい。この際処理系選びは既に終わっているとする。&lt;/li&gt;
&lt;li&gt;clikiをgit cloneしてくる。&lt;/li&gt;
&lt;li&gt;ASDFに読んでもらうために~/common-lisp以下にclikiを移動する。&lt;/li&gt;
&lt;li&gt;依存パッケージのインストールのためにquicklispをインストールする。

&lt;ul&gt;
&lt;li&gt;quicklisp.lispをダウンロードしてくる。&lt;/li&gt;
&lt;li&gt;REPLを起動する。どうやって？処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;li&gt;Lispの式をいくつか評価してquicklispをインストールする。~/quicklispが出現するがこの際目を瞑る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;REPLで&lt;code&gt;(ql:quickload :cliki)&lt;/code&gt;を評価して依存パッケージをインストールする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(start-cliki-server port homedir wikis)&lt;/code&gt;でサーバーが起動する。REPLも起動しっぱなし。&lt;/li&gt;
&lt;li&gt;止めたければ

&lt;ul&gt;
&lt;li&gt;Ctrl-Cでinteractive-interruptコンディションを発生させる。デバッガが起動する。&lt;/li&gt;
&lt;li&gt;デバッガからREPLのtoplevelに戻る。デバッガの操作?処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;li&gt;REPLを終了する。どうやって？処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「アプリケーションは~/common-lispじゃなくて/var/wwwに置きたいんだけど」 - 「コンフィグ書いたら変えられるよ。ASDFのコンフィグ書いてね。コンフィグの書き方はLisperの常識だよね」&lt;br /&gt;
「~/quicklisp邪魔なんだけど」 - 「ああ、それも変えられるよ。好きな場所に移動して処理系の初期化ファイル書き直してね。初期化ファイル？処理系依存だから自分で調べろ。どう直すか？簡単なLispの式だから自分で直せるよね？」&lt;/p&gt;

&lt;p&gt;多分言いたいことは伝わったかと思う。コマンドラインから扱えないとかパッケージマネージャが我が儘とか色々あるんだけど全ては「Lisperのためだけのものになっている」の一言で表せられる。&lt;/p&gt;

&lt;p&gt;quicklispが我が儘なのはまだ許せる。インストール先のディレクトリが固定されてないと管理しづらいから。しかしASDFがライブラリじゃなくてアプリケーションにまで特定のパスにあることを要求してくるのは納得がいかない。コンパイルやらロードやらテストやらの機能があるんだから.asdファイルのあるディレクトリをルートとしてそこだけで完結してほしい。以前、&lt;a href=&#34;/blog/2014/11/30/quicklisp/&#34;&gt;こんな記事&lt;/a&gt;を書いた所為でASDFの信者と思われているみたいだが、どっちかというとASDFの方が嫌いだ。ASDFが憖っか依存関係の解決までするがためにアプリケーションの置き場まで制約を受ける。手を広げたがために本来の機能が使い辛くなっている。Lisperが制約を受けるのはまだいい。アプリケーションのユーザにまで制約が及ぶのは耐えられない。&lt;/p&gt;

&lt;p&gt;コマンドラインから扱えない問題は多分ノウハウがなかったからだと思う。&lt;a href=&#34;/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/&#34;&gt;以前の記事&lt;/a&gt;で紹介した方法は多分知られていなかった。あとは複雑で使い辛いと評判(だった)のcl-launchか。アプリケーションはおろかquicklispすらREPLに入らないと使えない。ユーザがLispを微塵も知らない可能性すらあるのに。さらに、コマンドラインから使えないということは他のUnixツール群と組み合わせることも困難になる。また、&lt;a href=&#34;http://blog.8arrow.org/entry/20120323/1332516342&#34;&gt;ここ&lt;/a&gt;にあるようにREPLでアプリケーションを起動していると問題もある。&lt;/p&gt;

&lt;p&gt;私はこの問題を解決するためにCIMを作った。clfreaksの時にも喋ったがCIMのメインの機能は&lt;code&gt;cl&lt;/code&gt;コマンドと&lt;code&gt;ql&lt;/code&gt;コマンドだ。&lt;code&gt;cim&lt;/code&gt;コマンドはただの付加価値のためにつけたおまけである。&lt;/p&gt;

&lt;p&gt;もしclコマンドが広く使われるようになればshebangにclを使うだけで実行可能ファイルが作れて、コマンドラインから使えるようになる。qlを使えばREPLに入らずにパッケージをインストール出来る。スクリプトがエラーを出してもデバッガに入るようなことはない。Ctrl-Cでちゃんと止まる。&lt;/p&gt;

&lt;p&gt;これで一部ユニバーサリティの問題は解決出来たんだけだまだまだ未解決問題がある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CIMのインストールが必要になる。&lt;/li&gt;
&lt;li&gt;コマンドラインツールは解決したにしてもディレクトリ丸ごと持ってくるようなアプリケーションはASDFの制約をうける&lt;/li&gt;
&lt;li&gt;コンパイルの問題&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1はやっぱりLispを知らない人に使ってもらいたいならCIMのインストールは省きたい。処理系とquicklispだけ入れたら使えてほしい。やっぱりquicklispに変わってもらうしかないのかな。配布物に実行可能形式を含めてたらPATHも通して欲しいし。&lt;/p&gt;

&lt;p&gt;2のASDFの制約の問題はASDFを環境変数で制御出来るようなのでうまいことする方法を考えている。良い方法があったらまたアウトプットする。&lt;/p&gt;

&lt;p&gt;3は現状CIMで扱いかねてる問題。マクロ展開の問題からコンパイルするのが望ましいんだけどコンパイル後のファイルに互換性がない。しかも互換性がないのに同じ拡張子を使う。そこを上手く扱ってくれるのはASDFなんだけどやっぱり奴は我が儘だし何よりコンパイルしてしまうとAllegroを除いてshebangが効かなくなる。&lt;/p&gt;

&lt;p&gt;解決案はいくつか上がってるんだけどまだ決定的なものはない。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;コンパイルをあきらめる&lt;/li&gt;
&lt;li&gt;本体だけASDFでコンパイルしてエントリポイントになるスクリプトはコンパイルしない&lt;/li&gt;
&lt;li&gt;スタンドアロンバイナリ配布する&lt;/li&gt;
&lt;li&gt;ECLを使ってCのファイルを配布する&lt;/li&gt;
&lt;li&gt;ユーザー側にスタンドアロンバイナリを作らせる&lt;/li&gt;
&lt;li&gt;特定の処理系を要求する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1は下の策。&lt;/p&gt;

&lt;p&gt;2は個人的に推したいところだけどやっぱりASDFが憎い。&lt;/p&gt;

&lt;p&gt;3はクロスコンパイルが壊滅的なCommon Lispでは現実的ではない。&lt;/p&gt;

&lt;p&gt;4はCommon Lispの利点の一つにSBCLやCCLやCMU CLの速度が速いというのがあるから出来れば自由に処理系を選ばせたい。あとECLのランタイムのインストールが必要になる。&lt;/p&gt;

&lt;p&gt;5はやっぱりASDFが憎い。それに依存ライブラリもロードするにはquicklispもロードする必要があって、以前の記事の通りバイナリに邪魔なものが入るしそうでなくてもバイナリが素で60MBとかになる。stripするとアプリケーションとして動かなくなるからstripも出来ない。&lt;/p&gt;

&lt;p&gt;6はコンパイル後のファイルがポータブルな処理系はABCL、CLISP、XCLあたりだが、起動の遅いABCL、微妙に仕様に従ってなくて開発も停滞気味なCLISP、既に開発されていない上にマイナーでライブラリのサポートも薄いXCLとあまり選びたくないものばかり。&lt;/p&gt;

&lt;p&gt;因みに非Lispユーザにも使われているCommon LispアプリケーションにStumpWMがあるが、5の方法を採用している。しかしASDFを使わずにMakefileでコンパイルしている。依存ライブラリも手でインストールする必要がある。出来ればCommon Lispのツールチェーンに載せたまま配布したいところ…&lt;/p&gt;

&lt;p&gt;研究が必要。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>実用Common Lispを読んだ</title>
      <link>/blog/2014/12/14/shi-yong-common-lispwodu-nda</link>
      <pubDate>Sun, 14 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/12/14/shi-yong-common-lispwodu-nda</guid>
      <description>&lt;p&gt;以前&lt;a href=&#34;/blog/2014/10/20/lisp-ja/&#34;&gt;Common Lispの勉強の手引の記事&lt;/a&gt;を書いたときに実用Common Lispの名を挙げたが読んだことはなかった。&lt;/p&gt;

&lt;p&gt;一応名前を挙げた責任として読んでみた。&lt;/p&gt;

&lt;p&gt;読んだとは言ってもソースはざっくりしか見てないし、演習には目もくれてないので「一通り目を通した」程度。
買った本は逃げないのだし一回で理解する必要はない。最初に一通り内容を掴んで主張を理解してから、あとで気になった時につぶさに読むのが私の読み方。&lt;/p&gt;

&lt;p&gt;最初の感想を言うと、古い。Common Lispもcltl2とANSI両方に配慮されて書かれているし、紹介されているAIの事例も1970~1980年代のもの。
古典といった感じ。ただし、その時代はCommon LispとAIの最盛期なのでこの本を読めばCommon LispがAIで名を馳せた理由が良く分かる。&lt;/p&gt;

&lt;p&gt;Common Lispの内容は初級程度。まえがきにもあるようにプログラマとしては中級だがLispは初心者レベルの人向に書かれている。基本的なところを押えたらあとはどんどん進んでいく。
プログラミングの経験があればそれでも問題ない筈。心配ならWeb上にいくらでもあるチュートリアルをこなせば良い。&lt;/p&gt;

&lt;p&gt;ライブラリなどに関しては本の中で完結しているので良く言えば1から10まで教えてくれる。悪く言えば最近のCommon Lispの動向は全く分からない。その意味では実践入門ではなく学習図書。陳腐化はしない。&lt;/p&gt;

&lt;p&gt;AIについては、やはり古い。今では手法が確立されてAIの分野とは扱われないものも含まれている。ただし、これは意図したものなのかもしれない。
古いものというのは単純だ。最初に2部で単純なものを通して「肩馴らし」をしてから3部で手駒を増やして4部で踏み込んだ内容に入る。&lt;/p&gt;

&lt;p&gt;また、AIの分野としては扱われていなものも含む、ということはこの本が情報科学の広い範囲をカバーする、ということでもある。900ベージは伊達じゃない。量もあればバラエティもある。&lt;/p&gt;

&lt;p&gt;現実にある様々な難解な問題をCommon Lispという強力な道具で快刀乱麻解決していく。ソフトウェア開発手法を学びながらCommon Lispの強力さを思い知るための一冊。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>割と処理系ポータブルなCommon Lisp実行可能ファイルを作る</title>
      <link>/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru</link>
      <pubDate>Mon, 08 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru</guid>
      <description>&lt;p&gt;κeenです。Lisp Advent Calendarはもう枠埋まっちゃったので普通にブログで。&lt;/p&gt;

&lt;p&gt;コマンドラインから実行可能なLispファイルをそれなりに多くの処理系で動くように作る話。&lt;/p&gt;

&lt;p&gt;この話はCIMの生い立ちとも関連するんだけどシェルからLispを使いたいときは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env sbcl --script

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんて書いてた人も多いんじゃないかと思うんだけどこれは色々問題がある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;envは環境に依っては/usr/local/bin/envだったりする&lt;/li&gt;
&lt;li&gt;envは環境に依っては複数引数を取れない。&amp;rdquo;sbcl &amp;ndash;script&amp;rdquo;という名前のファイルを捜しにいく&lt;/li&gt;
&lt;li&gt;sbclでしか動かない&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;この問題の扱いは一応解決策がある&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh

#|
exec sbcl --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
|#

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3行目の&lt;code&gt;#|&lt;/code&gt;がシェルのコメントでありLispのブロックコメントであるのがポイント。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;シェルは&lt;code&gt;#!/bin/sh&lt;/code&gt;を見てシェルスクリプトとして実行する&lt;/li&gt;
&lt;li&gt;1,3行目はコメントなのでシェルは無視&lt;/li&gt;
&lt;li&gt;4行目でsbclにそのファイルを引数として与えてexecする。execしたあとはシェルには戻らないのでその後何が書いてあっても構わない&lt;/li&gt;
&lt;li&gt;sbclを&lt;code&gt;--script&lt;/code&gt;付きで読んでるので1行目の&lt;code&gt;#!&lt;/code&gt;で始まる行は無視する&lt;/li&gt;
&lt;li&gt;3~5行目はブロックコメントなのでsbclは無視&lt;/li&gt;
&lt;li&gt;それ以降がLispとして実行される&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;というカラクリになっている。こういうのをピジン言語っていうんだけ？&lt;/p&gt;

&lt;p&gt;まあいいや。&lt;/p&gt;

&lt;p&gt;ところでこのブロックコメントの中にはシェルスクリプト書き放題だよね？そのシェルスクリプト内でどのLisp使うか決めたらポータブルになりそうじゃない？&lt;/p&gt;

&lt;p&gt;こういうのはどう？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;#!/bin/sh

#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
|#

(write-line (lisp-implementation-type))
(force-output)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cclとabclは1行目のシェバンを読み飛ばせなかった&amp;amp;評価結果をエコーバックしない方法が見当らなかったからパス。CMUCLは自分の環境で動かないから検証出来てない。&lt;/p&gt;

&lt;p&gt;これでポータブルに実行は可能。コマンドライン引数の扱いとかはライブラリを頼ってくれ。因みにCIMでは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  #+allegro  (cdr (system:command-line-arguments))
  #+sbcl (do*  ((var sb-ext:*posix-argv* (cdr list))
                (list var var))
               ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+clisp ext:*args*
  #+ecl (do*  ((var (si:command-args) (cdr list))
               (list var var))
              ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+abcl extensions:*command-line-argument-list*
  #+gcl (do*  ((var si::*command-args* (cdr list))
               (list var var))
              ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+cmu ext:*command-line-words*
  #+ccl ccl:*unprocessed-command-line-arguments*
  #+mkcl (do*  ((var (si:command-args) (cdr list))
               (list var var))
              ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+lispworks system:*line-arguments-list*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としている。参考までに。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>claspがアップデートされたよ</title>
      <link>/blog/2014/12/06/claspgaatupudetosaretayo</link>
      <pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/12/06/claspgaatupudetosaretayo</guid>
      <description>

&lt;p&gt;このエントリーは&lt;a href=&#34;http://qiita.com/advent-calendar/2014/lisp&#34;&gt;Lisp Advent Calendar 2014&lt;/a&gt;6日目の記事です。&lt;br /&gt;
前: nobkzさんで &lt;a href=&#34;http://qiita.com/nobkz/items/2be2b6806237d8ea6e21&#34;&gt;lfe - (lisp (flavored (erlang)))について基本その1 - Qiita&lt;/a&gt;&lt;br /&gt;
後: 私で &lt;a href=&#34;/blog/2014/12/07/h2onipicrinworong-kasu/&#34;&gt;H2Oにpicrinを溶かす | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。アドベントカレンダーめっちゃ書いてますね。&lt;/p&gt;

&lt;h1 id=&#34;clasp:77e635c8bfc030775f1dbb8efa5b9863&#34;&gt;Clasp!&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/drmeister/clasp&#34;&gt;clasp&lt;/a&gt;のmasterに色々マージされました。リリースノートには、&lt;/p&gt;

&lt;p&gt;&lt;quote&gt;&lt;pre&gt;
Clasp version 0.11
* Added ASDF support.
This is still alpha. Compile the ASDF module using (core:compile-asdf).
After that you can load the module using (load &amp;ldquo;sys:kernel;asdf;build;asdf.bundle&amp;rdquo;).
It takes between 15-30 seconds to load (this is why I&amp;rsquo;m integrating Cleavir).
* Added the :CLASP &lt;em&gt;feature&lt;/em&gt; and removed the :ECL &lt;em&gt;feature&lt;/em&gt;.
Clasp will continue to mimic the underlying ECL functionality so that
Common Lisp code that supports ECL can be made to support Clasp by converting
#+ecl to #+(or ecl clasp) and #-ecl to #-(or ecl clasp)
* Added code to generate object files directly from Clasp.
The LLVM bitcode compiler &amp;ldquo;llc&amp;rdquo; no longer needs to be in the PATH
for Clasp to generate object files from Common Lisp source.
The &amp;ldquo;ld&amp;rdquo; linker does need to be accessible.
&lt;/pre&gt;&lt;/quote&gt;&lt;/p&gt;

&lt;p&gt;とあります。ASDFが使える！リリースノートには書いてませんがslimeサポートもmasterにコミットされてます。あとコミット読んだら最適化もされてるような…。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/slide/clasp.html&#34;&gt;以前&lt;/a&gt;二十数秒掛かっていた&lt;code&gt;(fib 29)&lt;/code&gt;ですが、今回はなんと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 ... loading image... it takes a few seconds
Top level.
&amp;gt; (load &amp;quot;fib.lisp&amp;quot;)
1346269
real time : 34.294 secs
run time  : 38.844 secs
T
&amp;gt; (compile-file &amp;quot;fib.lisp&amp;quot;)

#P&amp;quot;/home/kim/Lisp/fib.bc&amp;quot;
NIL
NIL
&amp;gt; (load &amp;quot;fib.bc&amp;quot;)
1346269
real time : 21.355 secs
run time  : 25.785 secs
T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うわぁ。遅くなってる。&lt;/p&gt;

&lt;p&gt;因みに.bcファイルはLLVMの中間ファイルなのでClaspとは独立に&lt;code&gt;opt -f -O3 fib.bc &amp;gt; fib.opt.bc&lt;/code&gt;で最適化出来ます。それをやると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ opt -f -O3 fib.bc &amp;gt; fib.opt.bc
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 ... loading image... it takes a few seconds
Top level.
&amp;gt; (load &amp;quot;fib.opt.bc&amp;quot;)
1346269
real time : 34.981 secs
run time  : 37.986 secs
T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ？遅くなった。&lt;/p&gt;

&lt;p&gt;mpsはまだコンパイル中だから待ってね&lt;/p&gt;

&lt;h1 id=&#34;asdfを使ってみる:77e635c8bfc030775f1dbb8efa5b9863&#34;&gt;ASDFを使ってみる&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 ... loading image... it takes a few seconds
Top level.
&amp;gt; (time (core:compile-asdf))
zsh: segmentation fault (core dumped)  /usr/local/clasp/bin/clasp_boehm_o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。解散。因みに50分くらいは動いてた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VOPで遊ぶ</title>
      <link>/blog/2014/12/02/vopdeyou-bu</link>
      <pubDate>Tue, 02 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/12/02/vopdeyou-bu</guid>
      <description>

&lt;p&gt;(:meta&lt;br /&gt;
 ((:this &amp;ldquo;&lt;a href=&#34;http://qiita.com/advent-calendar/2014/lisp&#34;&gt;Lisp Advent Calendar 2014&lt;/a&gt;の3日目の記事&amp;rdquo;)&lt;br /&gt;
  (:prev (:author &amp;ldquo;tk_riple&amp;rdquo; :title &lt;a href=&#34;http://compassoftime.blogspot.jp/2014/12/r7rs.html&#34;&gt;&amp;ldquo;時の羅針盤＠blog: R7RSポータブルライブラリを書く際の落とし穴&amp;rdquo;&lt;/a&gt;))&lt;br /&gt;
  (:next (:author &amp;ldquo;nobkz&amp;rdquo; :tite &amp;ldquo;&lt;a href=&#34;http://qiita.com/nobkz/items/68ee2adbc13caf3eec6f&#34;&gt;Shenの基礎その1 基本的な型 - Qiita&lt;/a&gt;&amp;rdquo;))))&lt;/p&gt;

&lt;p&gt;κeenです。さっきまでVOPで遊んでたので当初の予定を変更してVOPの話をします。&lt;/p&gt;

&lt;h1 id=&#34;vopとは何か:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;VOPとは何か&lt;/h1&gt;

&lt;p&gt;SBCLやCMU CLで使われているネイティブコードを吐くための機構、要はインラインアセンブラです。&lt;/p&gt;

&lt;h1 id=&#34;vopとはどんなものか:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;VOPとはどんなものか&lt;/h1&gt;

&lt;p&gt;とりあえずコードをば。x86-64用です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package :cl-user)
(defpackage vop-sample
  (:use :cl :sb-ext :sb-c))
(in-package :vop-sample)

(defknown add (fixnum fixnum)          ; addのftypeを宣言
    fixnum
    (movable                            ; 副作用がない
     flushable                          ; デッドコードとして除去してよい
     foldable                           ; 定数畳み込みをしてよい
     always-translatable)               ; 必ずアセンブラコードになる
  :overwrite-fndb-silently t)           ; 関数上書きのエラーを出さない


(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::add)          ; VOP名
  (:translate vop-sample::add)         ; 関数名
  (:policy :fast-safe)                  ; declare optimize的な
  (:args (x :scs (signed-reg))          ; 引数宣言。後述
         (y :scs (signed-reg)))
  (:arg-types fixnum fixnum)            ; 引数の型宣言
  (:results (r :scs (signed-reg)))      ; 返り値宣言。後述
  (:result-types fixnum)                ; 返り値の型宣言
  (:generator 4                         ; 翻訳するときのコスト
              (move r x)                ; 返り値レジスタにxを移動
              (inst add r y)))          ; 返り値レジスタにyを足し込む
(in-package :vop-sample)

(defun add (x y)                        ; 安全なバージョンでラップする
  (add x y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとおまじないが多いですね。&lt;/p&gt;

&lt;p&gt;すこし解説すると引数は基本レジスタ渡しで、レジスタが足りなければスタックも使います。で、レジスタやスタックの値には型があります。それがストレージクラス(sc)です。この場合、x、y、rは&lt;code&gt;signed-reg&lt;/code&gt;と宣言されてますね。符号付きレジスタです。&lt;code&gt;:scs&lt;/code&gt;の最後のsは複数形のsです。今回は1つしか指定してませんが複数指定することも可能なのです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt;というのはアセンブラ命令ではなく、マクロかなんかです（適当）。VOPなのかな？どのストレージクラスからどのストレージクラスに移動するかを認知して適切な命令を吐きます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inst&lt;/code&gt;が付いてるのがアセンブラですね。&lt;/p&gt;

&lt;p&gt;このコード、xとrが等しいときに最適化出来るのですがそれはまあおいといて、こいつをディスアセンブルしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VOP-SAMPLE&amp;gt; (disassemble #&#39;add)
; disassembly for ADD
; Size: 43 bytes. Origin: #x1005C26416
; 16:       488BD3           MOV RDX, RBX                     ; no-arg-parsing entry point
; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
; 2E:       CC0A             BREAK 10                         ; error trap
; 30:       02               BYTE #X02
; 31:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 32:       9A               BYTE #X9A                        ; RCX
; 33:       CC0A             BREAK 10                         ; error trap
; 35:       04               BYTE #X04
; 36:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 37:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 3A:       CC0A             BREAK 10                         ; error trap
; 3C:       04               BYTE #X04
; 3D:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 3E:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要な部分はここです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ADD&lt;/code&gt;の他に無駄な命令がいくつかありますね。&lt;/p&gt;

&lt;p&gt;SBCLはintの下位1bitをGCのときのタグとして使ってるのでアセンブラに渡す前に算術右シフト(&lt;code&gt;SAR&lt;/code&gt;)して渡してます。
そして返るときはまた左シフト(&lt;code&gt;SHL&lt;/code&gt;)してます。&lt;/p&gt;

&lt;p&gt;その後の&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は関数から返るときのイディオム(スタックポインタを復元してフラグをクリアして呼び出し元に戻る)です。&lt;/p&gt;

&lt;p&gt;余談ですがLispマシンなどのタグマシンは下位ビットにあるタグを無視して計算出来るのでシフトが不要になります。なので速いんですね。&lt;/p&gt;

&lt;h1 id=&#34;シフトをなくす:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;シフトをなくす&lt;/h1&gt;

&lt;p&gt;さっきは&lt;code&gt;signed-reg&lt;/code&gt;を指定しました。つまり「（アセンブラの）intをくれ」と要求した訳です。
intの下位1bitは0なので足し算する分には別にシフトされなくても問題ありませんよね。シフトを殺しましょう。&lt;/p&gt;

&lt;p&gt;さっきのコードの下にこれを足します。&lt;code&gt;add&lt;/code&gt;は再定義しないと反映されないようでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::add/v2)        ; vop名は異なる
  (:translate vop-sample::add)          ; 関数名は同じ
  (:policy :fast-safe)
  (:args (x :scs (any-reg))             ; any-regになってる
         (y :scs (any-reg)))            ; any-regになってる
  (:arg-types fixnum fixnum)
  (:results (r :scs (any-reg)))         ; any-regになってる
  (:result-types fixnum)
  (:generator 3                         ; コストをさっきより低くすると優先して使ってくれる
              (move r x)
              (inst add r y)))

(in-package :vop-sample)

(defun add (x y)
  (add x y))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んで、ディスアセンブルしてみると&lt;/p&gt;

&lt;p&gt;VOP-SAMPLE&amp;gt; (disassemble #&amp;lsquo;add)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; disassembly for ADD
; Size: 31 bytes. Origin: #x1004C2AB83
; 83:       488BD1           MOV RDX, RCX                     ; no-arg-parsing entry point
; 86:       4801FA           ADD RDX, RDI
; 89:       488BE5           MOV RSP, RBP
; 8C:       F8               CLC
; 8D:       5D               POP RBP
; 8E:       C3               RET
; 8F:       CC0A             BREAK 10                         ; error trap
; 91:       02               BYTE #X02
; 92:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 93:       9A               BYTE #X9A                        ; RCX
; 94:       CC0A             BREAK 10                         ; error trap
; 96:       04               BYTE #X04
; 97:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 98:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 9B:       CC0A             BREAK 10                         ; error trap
; 9D:       04               BYTE #X04
; 9E:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 9F:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。見事にSARとSHLが消えましたね。&lt;/p&gt;

&lt;h1 id=&#34;もう少し複雑な型を扱う:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;もう少し複雑な型を扱う&lt;/h1&gt;

&lt;p&gt;アセンブラですし&lt;code&gt;(simple-array (unsigned-byte 8) (*))&lt;/code&gt;(以下octets)を扱いたいですよね。とりあえず難しいことは考えずにoctetsの0番目の要素にアクセスしてみましょう。とはいっても&lt;code&gt;simple-array&lt;/code&gt;は長さや要素の型の情報も持っていることが予想されるので少しデータを読み飛ばさないといけませんね。&lt;/p&gt;

&lt;p&gt;その辺の計算が分からなかったのでsbclのソースからそれっぽいものを参考にしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defknown access-simple-array-0 ((simple-array (unsigned-byte 8) (*)))
    (unsigned-byte 8)
    (movable flushable always-translatable)
  :overwrite-fndb-silently t)
(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::access-simple-array-0)
  (:translate vop-sample::access-simple-array-0)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg)))
  (:arg-types *)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4
              (inst movzx r 
               (make-ea :byte :base x
                        :disp (- (* vector-data-offset n-word-bytes)
                               other-pointer-lowtag)))))

(in-package :vop-sample)
(defvar *octets* (make-array 4
                             :element-type &#39;(unsigned-byte 8)
                             :initial-contents &#39;(10 11 12 13)))

(defun access-simple-array-0 (x)
  (access-simple-array-0 x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じになります。境界チェックとかはやってませんが許して下さい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;descriptor-reg&lt;/code&gt;というのがポインタが入ってるレジスタっぽいです。&lt;code&gt;movzx&lt;/code&gt;は8bitの値を64bitのレジスタに符号拡張しながらロードする命令です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make-ea&lt;/code&gt;というのがアドレッシングですね。&lt;code&gt;x&lt;/code&gt;レジスタを起点として&lt;code&gt;(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)&lt;/code&gt;バイト(？ワード？)先のメモリ1byteを指します。&lt;/p&gt;

&lt;p&gt;ディスアセンブルしてみましょう。みなさんもう慣れてきたと思うので主要部だけ抜き出します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 65:       0FB65101         MOVZX EDX, BYTE PTR [RCX+1]      ; no-arg-parsing entry point
; 69:       48D1E2           SHL RDX, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;短いですね。この&lt;code&gt;BYTE PTR [RCX+1]&lt;/code&gt;が&lt;code&gt;make-ea&lt;/code&gt;した値に対応します。&lt;code&gt;RCX&lt;/code&gt;は&lt;code&gt;x&lt;/code&gt;で&lt;code&gt;(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)&lt;/code&gt;の結果が1に現れてるんでしょう。補足しておくと、&lt;code&gt;EDX&lt;/code&gt;と&lt;code&gt;RDX&lt;/code&gt;は同じ場所を指します。32bitとして扱うときはE、64bitとして扱うときはRで指します。&lt;/p&gt;

&lt;p&gt;さて、私はx86のアドレッシングモードなんて全然知らないのですがコードを見る限りもうちょっと複雑なアドレッシングが出来るようです。&lt;/p&gt;

&lt;p&gt;配列のn番目にアクセスするコードが良い例のようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defknown access-simple-array-n ((simple-array (unsigned-byte 8) (*)) (unsigned-byte 64))
    (unsigned-byte 8)
    (movable flushable always-translatable)
  :overwrite-fndb-silently t)
(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::access-simple-array-n)
  (:translate vop-sample::access-simple-array-n)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg))
         (i :scs (unsigned-reg)))
  (:arg-types * unsigned-num)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4
              (inst movzx r 
               (make-ea :byte :base x
                        :scale 1
                        :index i
                        :disp (- (* vector-data-offset n-word-bytes)
                               other-pointer-lowtag)))))

(in-package :vop-sample)
(defun access-simple-array-n (x i)
  (access-simple-array-n x i))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新たに引数&lt;code&gt;i&lt;/code&gt;をとるようになったのと&lt;code&gt;make-ea&lt;/code&gt;の引数に&lt;code&gt;:scale 1 :index i&lt;/code&gt;が加わってます。&lt;/p&gt;

&lt;p&gt;ディスアセンブルしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 98:       0FB6543901       MOVZX EDX, BYTE PTR [RCX+RDI+1]  ; no-arg-parsing entry point
; 9D:       48D1E2           SHL RDX, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アドレッシングに&lt;code&gt;+RDI&lt;/code&gt;が加わりましたね。どうして&lt;code&gt;i&lt;/code&gt;(&lt;code&gt;RDI&lt;/code&gt;)を&lt;code&gt;RAS&lt;/code&gt;しなくていいのか気になりますがまあ、とりあえず正常に動いてるようです。&lt;/p&gt;

&lt;p&gt;おわかりかと思いますがアドレッシングが&lt;code&gt;x&lt;/code&gt;をベースにして今までの定数オフセット+新たにレジスタで指定したオフセットになってます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make-ea&lt;/code&gt;に渡した&lt;code&gt;:index&lt;/code&gt;は何か分かるとしても&lt;code&gt;:scale&lt;/code&gt;が気になりますよね。&lt;code&gt;scale&lt;/code&gt;を2にしてディスアセンブルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 58:       0FB6547901       MOVZX EDX, BYTE PTR [RCX+RDI*2+1]  ; no-arg-parsing entry point
; 5D:       48D1E2           SHL RDX, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。インデックスを定数倍するようですね。&lt;/p&gt;

&lt;h1 id=&#34;sseにチャレンジ:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;SSEにチャレンジ&lt;/h1&gt;

&lt;p&gt;インテルアーキテクチャにあるSSEとはStreaming SIMD Extensionsの略です。じゃあSIMDは何かというとSimple Instruction Mulitple Dataの略で、1命令で複数のデータを処理出来ます。&lt;/p&gt;

&lt;p&gt;この「複数のデータ」というのは64bit2つや32bit4つなどを128bitにまとめて渡します。128bitの値なんてどうやって作るんだよって感じですがsbcl-1.1.8から入った&lt;code&gt;sb-ext:%make-simd-pack-*&lt;/code&gt;が存在します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VOP-SAMPLE&amp;gt; (%make-simd-pack-ub32 1 2 3 4)
#&amp;lt;SIMD-PACK  01 00 00 00  02 00 00 00  03 00 00 00  04 00 00 00&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じです。x86_64がリトルエンディアンだったのを思い出させる表記ですね。ub32の他にub64、single、doubleが存在します。&lt;/p&gt;

&lt;p&gt;ストレージクラスも&lt;code&gt;*-sse-reg&lt;/code&gt;というものがあるのでこれを使いましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defknown simd-add ((simd-pack (unsigned-byte 64)) (simd-pack (unsigned-byte 64)))
    (simd-pack (unsigned-byte 32))
    (movable flushable always-translatable)
  :overwrite-fndb-silently t)
(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::simd-add)
  (:translate vop-sample::simd-add)
  (:policy :fast-safe)
  (:args (x :scs (int-sse-reg))
         (y :scs (int-sse-reg)))
  (:arg-types simd-pack-int simd-pack-int)
  (:results (r :scs (int-sse-reg)))
  (:result-types simd-pack-int)
  (:generator 4
              (move r x)
              (inst padddw r y)))

(in-package :vop-sample)
(defun simd-add (x y)
  (simd-add x y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。こんな感じですね。&lt;code&gt;paddw&lt;/code&gt;はparallel add wordですかね。これをディスアセンブルすると思ったより大きな命令になったので全部貼っときますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VOP-SAMPLE&amp;gt; (disassemble #&#39;simd-add)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;; disassembly for SIMD-ADD
; Size: 108 bytes. Origin: #x1006D64A21
; 21:       660F6FC2         MOVDQA XMM0, XMM2                ; no-arg-parsing entry point
; 25:       660FFDC1         PADDW XMM0, XMM1
; 29:       49896C2440       MOV [R12+64], RBP                ; thread.pseudo-atomic-bits
; 2E:       4D8B5C2418       MOV R11, [R12+24]                ; thread.alloc-region
; 33:       498D5320         LEA RDX, [R11+32]
; 37:       493B542420       CMP RDX, [R12+32]
; 3C:       7740             JNBE L2
; 3E:       4989542418       MOV [R12+24], RDX                ; thread.alloc-region
; 43:       498D530F         LEA RDX, [R11+15]
; 47: L0:   48C742F165030000 MOV QWORD PTR [RDX-15], 869
; 4F:       48C742F900000000 MOV QWORD PTR [RDX-7], 0
; 57:       660F7F4201       MOVDQA [RDX+1], XMM0
; 5C:       49316C2440       XOR [R12+64], RBP                ; thread.pseudo-atomic-bits
; 61:       7402             JEQ L1
; 63:       cc09             break 9                          ; pending interrupt trap
; 65: l1:   488be5           mov rsp, rbp
; 68:       f8               clc
; 69:       5d               pop rbp
; 6a:       c3               ret
; 6b:       cc0a             break 10                         ; error trap
; 6d:       02               byte #x02
; 6e:       19               byte #x19                        ; invalid-arg-count-error
; 6f:       9a               byte #x9a                        ; rcx
; 70:       cc0a             break 10                         ; error trap
; 72:       04               byte #x04
; 73:       32               byte #x32                        ; object-not-simd-pack-error
; 74:       fe1b01           byte #xfe, #x1b, #x01            ; rdx
; 77:       cc0a             break 10                         ; error trap
; 79:       04               byte #x04
; 7a:       32               byte #x32                        ; object-not-simd-pack-error
; 7b:       fe9b03           byte #xfe, #x9b, #x03            ; rdi
; 7e: l2:   6a20             push 32
; 80:       bac0854200       mov edx, 4359616                 ; alloc_tramp
; 85:       ffd2             call rdx
; 87:       5a               pop rdx
; 88:       80ca0f           or dl, 15
; 8b:       ebba             jmp l0
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なにやってるのやら。&lt;/p&gt;

&lt;h1 id=&#34;出来なかったこと:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;出来なかったこと&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;PCMPESTRI&lt;/code&gt;を使ってみたかったのですが扱いがトリッキーなので断念しました。具体的に言うと操作する値を格納するレジスタがEAXとECX固定なようなのです。
&lt;code&gt;:temporary&lt;/code&gt;節で内部で使うレジスタも要求出来るようなのですが名指しでもらえるんですかね。&lt;/p&gt;

&lt;p&gt;SSEの使い方とsimple-arrayから要素の配列を取り出す方法までは示したので誰かやって下さい。&lt;/p&gt;

&lt;p&gt;参考資料いっぱい置いときますね。&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;&lt;a href=&#34;http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/&#34;&gt;How to Define New Intrinsics in SBCL - Paul Khuong mostly on Lisp&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;VOPの使い方。最初の方に出てきたaddの最適化のやつとかも出てくる。(en)&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html&#34;&gt;Hacking SSE Intrinsics in SBCL (part 1) - Paul Khuong mostly on Lisp&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;SBCLのsimd-packの具体的解説(en)&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://www.pvk.ca/Blog/2013/06/05/fresh-in-sbcl-1-dot-1-8-sse-intrinsics/&#34;&gt;Fresh in SBCL 1.1.8: SSE Intrinsics! - Paul Khuong mostly on Lisp&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;SBCLでVOPとSSEを使ってマンデルブロ集合を計算する(en)&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;https://software.intel.com/en-us/node/514244&#34;&gt;Packed Compare Intrinsics&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;IntelのPCMPESTRIとかのマニュアル(en)&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb531465.aspx&#34;&gt;_mm_cmpestri&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;MicrosoftのPCMPESTRIのマニュアル。こっちの方が分かりやすい(en)&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://homepage1.nifty.com/herumi/prog/intel-opt.html&#34;&gt;Intel optimization&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;PCMPISTRIを使った&lt;code&gt;strlen&lt;/code&gt;の実装例(ja)&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://blog.kazuhooku.com/2014/12/improving-parser-performance-using-sse.html&#34;&gt;Kazuho&amp;rsquo;s Weblog: Improving Parser Performance using SSE Instructions (in case of PicoHTTPParser)&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;PCMPESTRIを使ってHTTPパーサーを高速化した話。これをやりたかった。(en)&lt;/dd&gt;
&lt;/dl&gt;

&lt;h1 id=&#34;おわりに:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;おつかれ様でした。たまには低レベルなことをやっても良いんじゃないでしょうか。&lt;/p&gt;

&lt;p&gt;明日はnobkzさんで、Shenについてです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>require, ASDF, quicklispを正しく使う</title>
      <link>/blog/2014/11/30/quicklisp</link>
      <pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/11/30/quicklisp</guid>
      <description>

&lt;p&gt;κeenです。最近のCommon Lispのパッケージ管理は&lt;code&gt;ql:quickload&lt;/code&gt;しか知らないという方も多いのではないでしょうか。しかしそれだけでは機能が足りないこともあります。Common Lispには様々な管理システムがあるので整理しましょう。&lt;/p&gt;

&lt;h1 id=&#34;provide-require:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;&lt;code&gt;provide&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;同じファイルを読み込まないための原始的なシステムです。Common Lispの標準の機能です。&lt;code&gt;(require &#39;foo)&lt;/code&gt;がファイルをロードし、ロードされたファイル内で&lt;code&gt;(provide &#39;foo)&lt;/code&gt;しておくと2回目以降の&lt;code&gt;(require &#39;foo&#39;)&lt;/code&gt;はファイルを読まずにすぐさま返ります。&lt;/p&gt;

&lt;p&gt;ここで問題なのが&lt;code&gt;require&lt;/code&gt;がどこのファイルを捜しにいくかは処理系依存なところですね。なので生の&lt;code&gt;require&lt;/code&gt;は使えないと思っておいた方が良いでしょう。&lt;/p&gt;

&lt;h1 id=&#34;asdf-3:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;ASDF 3&lt;/h1&gt;

&lt;p&gt;Another System Definition Facility。過去にはAnotherじゃないSystem Definition Facilityもあった模様。最新版は3系です。結構APIが変っているので必ず3の情報を捜しましょう。&lt;/p&gt;

&lt;p&gt;この「System」というのが聞き慣れませんが、ASDFの&lt;code&gt;defsystem&lt;/code&gt;で&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;systemに含まれるファイルの定義&lt;/li&gt;
&lt;li&gt;依存systemの記述&lt;/li&gt;
&lt;li&gt;その他作者、ライセンス、バージョンなどの記述&lt;/li&gt;
&lt;li&gt;systemのコンパイルやロード、テストなどの操作&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;が可能です。ASDFはCにとってのmake + ldを標榜しています。Makefile的なものは(systemname).asdになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;require&lt;/code&gt;との統合もされており、ASDFを適切に設定することで&lt;code&gt;defsystem&lt;/code&gt;されたsystemを&lt;code&gt;require&lt;/code&gt;でロードすることが出来ます。このときASDFは処理系に依存せずにASDFのパスに従って.asdファイルを捜しにいきます。&lt;/p&gt;

&lt;p&gt;また、ほとんどの処理系はASDFを標準添付していて、大抵&lt;code&gt;(require &#39;asdf)&lt;/code&gt;すれば使えるようになっています。&lt;/p&gt;

&lt;p&gt;尚、コンパイル後のファイルは処理系、バージョン毎に互換性がないので本来なら適切に管理する必要がありますが、ASDFが適切に~/.cache/common-lisp以下に管理してくれます。優秀ですね。&lt;/p&gt;

&lt;h1 id=&#34;quicklisp:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;quicklisp&lt;/h1&gt;

&lt;p&gt;lispプロジェクトのインストーラと微妙にパッケージマネージャ的な役割をします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://beta.quicklisp.org/quicklisp.lisp&#34;&gt;http://beta.quicklisp.org/quicklisp.lisp&lt;/a&gt; をダウンロードしてきてそのファイルを読み込んで&lt;code&gt;(quicklisp-quickstart:install)&lt;/code&gt;すれば~/quicklisp/以下にquicklispがインストールされ、ロードされます。処理系を再起動したあとまたquicklispをロードするには~/quicklisp/setup.lispを&lt;code&gt;load&lt;/code&gt;します。が、毎回それをやるのが面倒な人は&lt;code&gt;(ql:add-to-init-file)&lt;/code&gt;しておけば処理系の初期化ファイルに~/quicklisp/setup.lispを読み込む処理が書き加えられます。&lt;/p&gt;

&lt;p&gt;さて、このquicklispを扱う上で3つの概念を覚えておくと良いです。&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;dist&lt;/dt&gt;
&lt;dd&gt;releaseの配布元。普通は&amp;rsquo;quicklisp&amp;rsquo;のみだがほかのdistを使うことも可能。自前のやつとか。新たなdistを追加したり削除したり出来る。gitのremoteをイメージすればよい。&lt;/dd&gt;
&lt;dt&gt;release&lt;/dt&gt;
&lt;dd&gt;quicklispがダウンロードしてくる単位。ライブラリの作者が登録するときの単位。複数のsystemをもつこともある。&lt;/dd&gt;
&lt;dt&gt;system&lt;/dt&gt;
&lt;dd&gt;ASDFのsystem。ユーザーが使うときの単位。&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;さて、quicklispを使うときは通常使いたいシステムを&lt;code&gt;ql:quickload&lt;/code&gt;すればそのシステムと依存システムの含まれているリリースをダウンロード、展開、ロードまでしてくれます。&lt;/p&gt;

&lt;p&gt;開発中はREPLを立ち上げているので「あ、このライブライリ使おう」と思ったら&lt;code&gt;ql:quickload&lt;/code&gt;するだけで即座に使えるようになりますね。&lt;/p&gt;

&lt;p&gt;quicklispのリリースは毎月下旬にアップデートされていて、毎月ちゃんと全てのライブラリが対応処理系で動くことがテストされています。なのでメンテナが居なくなったライブラリはドロップします。代わりにquicklispの作者がテスト出来ないライブラリは登録させてもらえなかったりします（cl-cudaとか）&lt;/p&gt;

&lt;h1 id=&#34;quicklispの問題:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;quicklispの問題&lt;/h1&gt;

&lt;p&gt;既にCommon Lispのライブラリマネージャとしてデファクトスタンダード的位置を築きつつあるquicklispですが、私は結構不満があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;~/quicklisp/setup.lispを読み込むとquicklispの全てを読み込んでしまう: これには過去全てのバージョンのdistとreleaseとsystemのデータベース、HTTPクライアント、圧縮ファイルの解凍ライブラリなども含まれており、処理系の起動が非常に遅くなる&lt;/li&gt;
&lt;li&gt;特にデータベースはファイルに書かれていても高速に読める形式なのに初期化時に毎回全ての内容をLispのハッシュに変換するという愚行をする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(ql:add-to-init-file)&lt;/code&gt;が推奨されているが、前述の通り処理系の起動が遅くなってしまう。特に、（インストーラではなく、インストール済みの）ライブラリマネージャとして使いたくてもインストーラの機能までロードしてしまう。結構メモリを食うしアプリケーションには要らない。&lt;/li&gt;
&lt;li&gt;処理系に依っては初期化ファイルはlispファイルをスクリプトとして使うときは読み込まれないこともあるのでスクリプトには使えない。まあ、前述の通り使いたくもない。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のでライブラリマネージャにはASDFが向いてるのですが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;quicklispでインストールしたシステムはquicklispを一旦ロードするかASDFの設定をいじるかしなければASDFからは使えない&lt;/li&gt;
&lt;li&gt;quicklispはシステムのダウンロード/インストールだけすれば良いものをロードまでする&lt;/li&gt;
&lt;li&gt;要はASDFを隠す&lt;/li&gt;
&lt;li&gt;じゃASDFのラッパーかというとロードしかせず、コンパイルやテストなどはしない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;など様々な問題があります。&lt;/p&gt;

&lt;p&gt;一応quicklispの弁護をしておくと、Common Lispは他のスクリプト言語とはちょっと使い方が違って、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;初期化ファイルは大抵オレオレライブラリで埋め尽くされていてそもそも起動には時間がかかる&lt;/li&gt;
&lt;li&gt;Emacsのように一度REPLを立ち上げたら滅多に落とさない&lt;/li&gt;
&lt;li&gt;アプリケーションも基本的にはREPLの中で使う&lt;/li&gt;
&lt;li&gt;起動時間を気にするなら初期化ファイルを全てロードした、コアファイルをダンプしておいて使う&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった使い方をされることが多いのです。そのような人からしてみたら細々処理されるよりも起動時間とメモリは気にしないから速いやつをくれ、となるのです。&lt;/p&gt;

&lt;p&gt;じゃあそれなりにCommon Lispを使う私が何故そうしないかというと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;立ち上げっぱなしというのが性に合わない。立ち上がっているものを見るとすぐに落としたくなる。EmacsのヘビーユーザーだがEmacsもすぐ落とす。&lt;/li&gt;
&lt;li&gt;コマンドラインアプリケーションを作りたいため、起動時間が命になる。&lt;/li&gt;
&lt;li&gt;私はSBCLの開発版を使っていて、コアファイルはすぐに無効になるためコアダンプはしない（意味がない）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった理由があります。これは初心者にも共通する部分があるんじゃないでしょうか。REPLを立ち上げっぱなしにはしないし「コアダンプ？なにそれ？エラー出してんじゃん」状態でしょう。&lt;/p&gt;

&lt;h1 id=&#34;asdfを正しく使う:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;ASDFを正しく使う&lt;/h1&gt;

&lt;p&gt;ということでquicklispをあまり使わない方法を紹介します。&lt;/p&gt;

&lt;p&gt;前述の通り、quicklispでインストールしたシステムはquicklispを一旦ロードするかasdfの設定をいじるかしなければasdfからは使えません。具体的に言うと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ASDFのデフォルトパスは~/common-lisp以下&lt;/li&gt;
&lt;li&gt;quicklispのシステムのインストールパスは~/quicklisp/dists/(dist name)/software/以下&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なので~/quicklisp/dists/以下にパスを通します。少し無駄なディレクトリもパスに含まれてしまうので気にする人はそれぞれのdistについて~/quicklisp/dists/(dist name)/software/にパスを通しましょう。&lt;/p&gt;

&lt;p&gt;因みに拙作の&lt;a href=&#34;https://github.com/KeenS/CIM&#34;&gt;CIM&lt;/a&gt;は~/.cim/quicklisp以下にquicklispをインストールするのでCIM使いの方は~/.cim/quicklisp/dists/ですね。~/quicklispの方が混乱少ないかなあ。&lt;/p&gt;

&lt;p&gt;さて、ASDFの設定は&lt;a href=&#34;http://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems&#34;&gt;公式マニュアル&lt;/a&gt;を参照すれば良いのですが一応実際のものを書いておくと&lt;/p&gt;

&lt;p&gt;~/.config/common-lisp/source-registry.conf に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(:source-registry
  (:tree &amp;quot;~/quicklisp/dists/&amp;quot;)
  (:tree (:home &amp;quot;Lisp/&amp;quot;))
  :INHERIT-CONFIGURATION)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を書けばOKです。2つめのLisp/は私がCommon Lispファイルを置いているディレクトリですね。この書き方だとquicklispより自分のLispライブラリを優先して読みにいきます。開発版を使いたいときとかむしろ開発をするときとかに必須です。この設定をミスるといくら開発してもロードされてるのはリリース版で、機能が動かないとかの地獄を見ます。&lt;/p&gt;

&lt;p&gt;ここまでくれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;asdf)
(require &#39;hoge)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすればquicklispでインストールしたライブラリをロード出来ます。&lt;/p&gt;

&lt;h2 id=&#34;require以外のasdfの使い方:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;require以外のASDFの使い方&lt;/h2&gt;

&lt;p&gt;バージョンに依って使い方が異なるのですが、3系だと&lt;code&gt;(asdf:xxx-system &#39;hoge)&lt;/code&gt;などとします。具体的には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(asdf:load-system &#39;hoge)&lt;/code&gt; ( = &lt;code&gt;(require &#39;hoge)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(asdf:test-system &#39;hoge)&lt;/code&gt; (テストがあるときのみ)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(asdf:compile-system &#39;hoge)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を覚えておけば良いでしょう。他にもいくつか操作があるようですが私は使ったことがないです。&lt;code&gt;asdf:locate-system&lt;/code&gt;は名前的に便利そうではあるんですけどね。&lt;/p&gt;

&lt;p&gt;開発するときはまず.asdファイルを書いておいて(あるいはcl-projectから生成して)、&lt;code&gt;(require &#39;hoge)&lt;/code&gt;で始めて書いていき、ある程度進んだらテストを書いてテストの項目を.asdファイルに書き足して&lt;code&gt;(asdf:test-system &#39;hoge)&lt;/code&gt;、それなりに動くようになったら&lt;code&gt;(asdf:compile-system &#39;hoge)&lt;/code&gt;してコンパイルの様子を見たりコンパイル後のベンチマークを取ったりします。&lt;/p&gt;

&lt;h2 id=&#34;quickloadを成仏させる:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;quickloadを成仏させる&lt;/h2&gt;

&lt;p&gt;これでロードの処理はASDFで全てカバー出来るようになりました。じゃあquickloadのロード機能は邪魔ですね。quicklispをインストーラとしてのみ使いましょう。&lt;/p&gt;

&lt;p&gt;まず処理系の初期化ファイル(sbclなら~/.sbclrc)から&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;;; The following lines added by ql:add-to-init-file:
#-quicklisp
(let ((quicklisp-init (merge-pathnames &amp;quot;~quicklisp/setup.lisp&amp;quot;
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init :verbose nil)))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を削除します。quicklispを使いたいときだけ&lt;code&gt;(load &amp;quot;~/quicklisp/setup.lisp&amp;quot;)&lt;/code&gt;します。そして欲しいシステムをインストールするには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(ql::recursively-install &amp;quot;foo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;します。quickloadに比べて爆速です。ここにきて名前が文字列な上にexportされてないシンポル参照してますね。気持ち悪いという方は大人しくquickloadしましょう。&lt;/p&gt;

&lt;p&gt;拙作のCIMにはこれをコマンドラインから行なう&lt;code&gt;ql install&lt;/code&gt;なるコマンドが存在します。&lt;/p&gt;

&lt;h1 id=&#34;最後に:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;quicklispが嫌いなのは私の好みですがASDFを正しく使えて損はないと思うので知らなかった方々は是非試してみて下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lisp meet up #22でLTしてきた</title>
      <link>/blog/2014/11/28/lisp-meet-up-number-22deltsitekita</link>
      <pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/11/28/lisp-meet-up-number-22deltsitekita</guid>
      <description>

&lt;p&gt;κeenです。先日 Lisp Meet Up #22 でLTしてきたので報告です。&lt;/p&gt;

&lt;p&gt;LTは事前に登録されたのが2件、私が当日17時くらいに登録したの1件で、参加は20人募集の内20人応募、20人参加と最近中々の人気を見せてます。&lt;/p&gt;

&lt;h1 id=&#34;common-lispで高速なhttpパーサーを書く-仮:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;Common Lispで高速なHTTPパーサーを書く(仮)&lt;/h1&gt;

&lt;p&gt;LT1件目は深町さんより、「Common Lispで高速なHTTPパーサーを書く(仮)」。fast-httpを作ったときの話。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/42153462&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/fukamachi/writing-a-fast-http-parser&#34; title=&#34;Writing a fast HTTP parser&#34; target=&#34;_blank&#34;&gt;Writing a fast HTTP parser&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/fukamachi&#34; target=&#34;_blank&#34;&gt;fukamachi&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.google.com/file/d/0B_H0_8eqWuVARnhncWZpRFdUOWM/preview&#34;&gt;動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.8arrow.org/entries/2014/10/23&#34;&gt;深町さんのブログ&lt;/a&gt;に書かれていることの他、fast-httpが高速になるまでの経緯や実装方針などの話もありました。&lt;/p&gt;

&lt;p&gt;最初ベースにしたnode.jsのHTTPパーサ、http-parseは状態を持っていて、1文字読む毎に状態を保存していた。次にベースにしたpicohttpparseは状態を持たず、HTTPリクエストが全部届く前にパースを始めてしまった場合はあきらめて最初からパースするようにしていた。fast-httpは1行パースする毎に状態を保存するようにした。など。&lt;/p&gt;

&lt;p&gt;もう一つ、http-parseは&lt;code&gt;while&lt;/code&gt;ループの中に巨大な&lt;code&gt;case&lt;/code&gt;文があって、現在の状態で&lt;code&gt;case&lt;/code&gt;でディスパッチし、その節の中で読んだ文字に依って現在の状態を変え、またループで先頭に戻って状態に依ってディスパッチするという手法だったそうです。Common Lispの場合は&lt;code&gt;case&lt;/code&gt;が全て&lt;code&gt;(cond ((eql ..) ....) ...)&lt;/code&gt;に展開されて遅い&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a60a195e9e80913e6883fc5337a6bd1f:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a60a195e9e80913e6883fc5337a6bd1f:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;ので&lt;code&gt;while&lt;/code&gt;と&lt;code&gt;case&lt;/code&gt;じゃなくて&lt;code&gt;tagbody&lt;/code&gt;と&lt;code&gt;goto&lt;/code&gt;で実装したそうです。&lt;/p&gt;

&lt;p&gt;この手法は一般にDirect(Navive) ThreadingだとかThreaded Codeだとか呼ばれています。主にバイトコードインタプリタを実装する時にバイトコードに依るディスパッチの部分で使われるようです。Rubyの解説が丁寧だったようなので参考資料として置いておきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://magazine.rubyist.net/?0008-YarvManiacs&#34;&gt;Rubyist Magazine - YARV Maniacs 【第 3 回】 命令ディスパッチの高速化&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;会場からはアーキテクチャ依存の最適化はしないのかとの質問がありました。SBCLにはインラインアセンブラであるVOPなるものが存在するのでSIMD命令使えば、とかいう怖い話ですね。&lt;/p&gt;

&lt;h1 id=&#34;symbol-tree-diff:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;symbol tree diff&lt;/h1&gt;

&lt;p&gt;LT2件目はchikuさんより「symbol tree diff」。chikuさんが以前から取り組んでいるプログラムのdiffを構文レベルでとる話の進捗。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/42160384&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/samugari/symbol-treediff&#34; title=&#34;Symbol tree-diff&#34; target=&#34;_blank&#34;&gt;Symbol tree-diff&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/samugari&#34; target=&#34;_blank&#34;&gt;samugari&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.google.com/file/d/0B_H0_8eqWuVARUoxVGtiMlFrRVU/preview&#34;&gt;動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;diff自体はとれるようになったようですが見せ方に問題があり、見易い形式を模索中のようです。会場に見易い形式は何か投げ掛けましたが良い案を見付けるのは難しいようです。&lt;/p&gt;

&lt;h1 id=&#34;semantic-s式:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;Semantic S式&lt;/h1&gt;

&lt;p&gt;私から「Semantic S式」。括弧が多い方が嬉しいこともあるよねーというゆるい話。
&lt;a href=&#34;http://keens.github.io/slide/semantic-sshi.html&#34;&gt;Semantic S式 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.google.com/file/d/0B_H0_8eqWuVAQms2QkZDcnZfVlU/preview&#34;&gt;動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;会場からは半分同意、半分ツッコみたいとの反応が。plistをリテラルから&lt;code&gt;getf&lt;/code&gt;するやついないだろ、とか。&lt;/p&gt;

&lt;h1 id=&#34;懇親会:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;懇親会&lt;/h1&gt;

&lt;p&gt;私の発表で21時あたりだったのでそのまま解散して懇親会。隣にLand of Lispを読んでLispに興味持ってLispの授業をとってる方がいたのでどの本が入門に良いかなど。&lt;/p&gt;

&lt;p&gt;VOPの話の続きもしました。どうしても資料がないのがネックだよねー、と。私の知っているのは&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/&#34;&gt;How to Define New Intrinsics in SBCL - Paul Khuong mostly on Lisp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;や&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html&#34;&gt;Hacking SSE Intrinsics in SBCL (part 1) - Paul Khuong mostly on Lisp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;かな。日本語のやってみた系だとg1さんの&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://g000001.cddddr.org/2011-12-08&#34;&gt;#:g1: SBCLでVOPを使ってみよう&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;あたり。&lt;/p&gt;

&lt;h1 id=&#34;その他:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;テンプレートエンジンを作ってるって以前深町さんに話してたら「まだ出来ないんですか？」とさんざん煽られました。はい。頑張ります。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:a60a195e9e80913e6883fc5337a6bd1f:1&#34;&gt;&lt;code&gt;cond&lt;/code&gt;は先頭から順番に比較する仕様です。&lt;code&gt;case&lt;/code&gt;は&lt;code&gt;cond&lt;/code&gt;に展開されることが仕様で定められていた筈。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a60a195e9e80913e6883fc5337a6bd1f:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>claspを少し触ってみた</title>
      <link>/slide/clasp/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>/slide/clasp/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# claspを少し触ってみた
----------------------
Lisp Meet Up presented by Shibuya.lisp #21  
2014-10-29  
κeen(@blackenedgold)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:relative;right 0;&#34; --&gt;

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます


# clasp
-------

* Github: [drmeister/clasp](https://github.com/drmeister/clasp)
* 2014-09-18に0.1リリース(現在0.11プレビューが出ている)
* 今は0.11プレビューが出ている
* ANSI Common Lisp準拠を目指す(現在80 ~90%)
* ECLからのフォーク
* LLVMベースのJIT([MCJIT](http://llvm.org/docs/MCJITDesignAndImplementation.html))搭載
* C++とLispで書かれている
* C++との連携を意識

Note:
C++との連携の部分を強調。今回は0.11プレビューでの話


# メモリ管理
------------------

* Memory Pool Systemと Boehm GCから選べる
* ビルドするときにどっちかを選ぶ


# メモリ管理
------------------
## [Boehm GC](http://www.hboehm.info/gc/)

* Mark &amp;amp; Sweepのライブラリ
* 枯れた有名なライブラリ
* Lisp有名どころではGaucheが使う
* RedHat系だとこれを使ってないとrpmリジェクトされやすいらしい(?)

Note:
他にはMozilla, W3M, GNU GCJ, GNU Obj-Cなどなど

# メモリ管理
------------------
## [Memory Pool System](http://www.ravenbrook.com/project/mps/)

* 複数のGCアルゴリズムを組み合わせて使えるらしい
* since 1994
* あまり分からないです&amp;gt;&amp;lt;


# 依存ライブラリ
----------------------

* LLVM **3.6**
* LLVM/clang **3.5** compiler
* Boost build v2
* boost libraries ver 1.55
* Boehm 7.2
* gmp-6.0.0
* expat-2.0.1
* zlib-1.2.8
* readline-6.2


&lt;span style=&#34;font-size:600%&#34;&gt;無理&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# externals-clasp
--------------------------

* Github: [drmeister/externals-clasp](https://github.com/drmeister/externals-clasp)
* 依存ライブラリを揃えるのが難しいとの声から作られた
* 依存ライブラリを全てビルド&lt;!-- .element: class=&#34;fragment grow&#34; --&gt;


&lt;span style=&#34;font-size:300%&#34;&gt;＼LLVMをビルド／&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;＼Boostをビルド／&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:200%&#34;&gt;ビルド時間はお察しです&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 本体のビルド
------------------
Twitter実況をどうぞ↓↓

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangがメモリ6GB以上食い続けてて怖い。何やってんの。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526417151486205952&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangの起動時間1時間超えてますよ…&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526418636735401984&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;HDDプチプチ言ってるし今にも壊れそう&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526420001587068929&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/nobkz&#34;&gt;@nobkz&lt;/a&gt; claspのコンパイル中です。&amp;#10;clangなのにIOネックという謎の状態です。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526420473232367616&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangの消費メモリ7GB超えた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526423982992420864&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;ビルドは自己責任で&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 使ってみる
------------
## 起動オプション
```
/usr/local/clasp/bin/clasp_mps_o --help
clasp options
-I/--ignore-image    - Don&#39;t load the boot image/start with init.lsp
-i/--image file      - Use the file as the boot image
-N/--non-interactive - Suppress all repls
-v/--version         - Print version
-s/--verbose         - Print more info while booting
-f/--feature feature - Add the feature to *features*
-e/--eval {form}     - Evaluate a form
-l/--load {file}     - LOAD the file
-r/--norc            - Don&#39;t load the ~/.clasprc file
-n/--noinit          - Don&#39;t load the init.lsp (very minimal environment)
-s/--seed #          - Seed the random number generator
-- {ARGS}*           - Trailing are added to core:*command-line-arguments*
```

# 使ってみる
------------
## ASDF

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ASDFの処理系依存の部分(`#+`)の問題
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ECLと見做されるけどECLのコードは動かない

# 使ってみる
------------
## cl-ppcre

* [手動ロードスクリプト](https://gist.github.com/KeenS/4e25cb6e424ebe4e7a4a)
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;`schar`がない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ANSI Common Lispにあるのに…

# 使ってみる
------------
## C++との連携

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;ドキュメントがない
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;サンプルコードもない
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;遂行不能

# 使ってみる
------------
## LLVMの呼び出し
* [clasp/src/llvmo/demo.lisp](https://github.com/drmeister/clasp/blob/master/src/llvmo/demo.lsp)
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない

# 使ってみる
------------
&lt;style type=&#34;text/css&#34;&gt;
.graph{
  background:#aaa;
  border-radius:5px;
  white-space: nowrap;
  text-align: left;
}
td {
  white-space: nowrap;
}
&lt;/style&gt;

処理系              |  `(time (fib 29))`
--------------------|-----------------------------------------------------------------
clasp-0.1(boehm)    | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(264.3px * 3);&#34; data-fragment-index=&#34;1&#34;&gt;26.43s&lt;/div&gt;
clasp-0.1(mps)      | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(172.8px * 3);&#34; data-fragment-index=&#34;1&#34;&gt;17.28s&lt;/div&gt;
clasp-0.11(boehm)   | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(213.2px * 3);&#34; data-fragment-index=&#34;2&#34;&gt;21.32s&lt;/div&gt;
clasp-0.11(mps)     | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(187.9px * 3);&#34; data-fragment-index=&#34;2&#34;&gt;18.79s&lt;/div&gt;
ECL-13.5.1          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 16.0px * 3);&#34;&gt;1.603s&lt;/div&gt;
ECL-13.5.1(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  1.9px * 3);&#34;&gt;0.192s&lt;/div&gt;
ABCL-1.3.1          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 32.9px * 3);&#34;&gt;3.292s&lt;/div&gt;
ABCL-1.3.1(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  2.4px * 3);&#34;&gt;0.241s&lt;/div&gt;


# 使ってみる
------------

処理系              |  `(time (fib 29))`
--------------------|-----------------------------------------------------------------
CLISP-2.49          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 38.4px * 3);&#34;&gt;3.847s&lt;/div&gt;
CLISP-2.49(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  7.1px * 3);&#34;&gt;0.7146s&lt;/div&gt;
ccl-1.10            | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.4px * 3);&#34;&gt;0.04033s&lt;/div&gt;
sbcl-1.2.5          | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.6px * 3);&#34;&gt;0.06469s&lt;/div&gt;
alisp-9.0           | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  230px * 3);&#34;&gt;23.09s&lt;/div&gt;
alisp-9.0(compile)  | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.6px * 3);&#34;&gt;0.06194s&lt;/div&gt;

&lt;span style=&#34;font-size:200%&#34;&gt;LLVM/JITなのになぜ遅い？&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# LLVM/JITで遅い？
-------------------------

* LLVMって速いんじゃ？
* JIT搭載した○○が速いって聞いたよ
  + JVM
  + lua-jit
  + Rubinius
  + pypy


# 言葉の罠: LLVM
--------------------

* 遅いコードはどんなに頑張っても遅い
* ECLのバックエンドにClang(=LLVM)を使ってもSBCLに勝てないのと同じ


# 言葉の罠: JIT搭載
--------------------

* JIT(実行時コンパイル)の意味は広い
* 実行時にネイティブコードを吐けばJITと言える
* claspは実行直前にコンパイルするだけ
* 多くの速いJIT処理系はTracing JITを使う
  + またの名を適応的コンパイル
  + 実行時の情報に基いて実行中に最適化する
  + `(declare ...)` を自動生成してる的な


# Tracing JITへの道
--------------------

* LLVMのJITは実行直前にコンパイルするだけ
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;Tracing JITのバックエンドには使える
* 実行時最適化には最適化用のコードが必要
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;Common Lispでは`(declare ...)`用のコードを使い回せる
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;案外近い


# 結論
------

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;遅い
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;時期尚早
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;今後機能や速度改善があれば使えるようになるかも


&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>