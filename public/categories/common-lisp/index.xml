<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Common Lisp on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/common-lisp/</link>
    <description>Recent content in Common Lisp on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 26 Jun 2015 23:24:44 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/common-lisp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>あなたの知らないShebang</title>
      <link>http://keens.github.io/blog/2015/06/26/anatanoshiranaishebang</link>
      <pubDate>Fri, 26 Jun 2015 23:24:44 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/26/anatanoshiranaishebang</guid>
      <description>

&lt;p&gt;κeenです。最近は何故かBlack君って呼ばれます。Shebangの書き方にはいくつかあって、それを利用したふと面白い方法を思い付いたので共有を。&lt;/p&gt;

&lt;p&gt;さて、ご存知Shebangといえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにファイルの1行目が&lt;code&gt;#!&lt;/code&gt;から始まっているとシェルがそれ以降の文字列を実行可能ファイルのパス名として捜して実行してくれるものですが、実は&lt;code&gt;#!&lt;/code&gt;は唯一のフォーマットではありません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#!&lt;/code&gt;がデファクトになる前なのかそもそもシェルにコメントがなかった時代のものなのかは知りませんが昔は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;: /bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;:&lt;/code&gt;で始めていたらしいです。因みに&lt;code&gt;:&lt;/code&gt;は「何もしないコマンド」です。実質的にコメントとして扱ったり副作用のある変数展開だけを行なったりプログラマティックコメントアウトだったりの用途で使われてます。&lt;/p&gt;

&lt;p&gt;さて、シェルは全て文字列なのでクォートしてもしなくても構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてもちゃんと動いてくれます。なぜわざわざクォートするかというと&lt;a href=&#34;http://keens.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/&#34;&gt;割と処理系ポータブルなCommon Lisp実行可能ファイルを作る | κeenのHappy Hacκing Blog&lt;/a&gt;のように別の言語のスクリプトとして実行される時に文字列リテラルになってくれると単純に無視されるので互換性が高まるのです。&lt;/p&gt;

&lt;p&gt;ということで完全版ポータブルなCommon Lisp実行可能ファイルはこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;

#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abclとcclが利用可能になりました。あとCIMも捜すようにしました。roswellは作者に訊いて下さい。&lt;/p&gt;

&lt;p&gt;ちなみに、shebangの解釈はシェルに依存するのですが、B Shell, csh, tcsh, dash, Bash, zshで動作確認しました。古い機能なので新しいシェルほど切り捨てている可能性があったのですがBashやzshが大丈夫だったので良かったです。
一応非推奨な気がしますがこれしか方法がないので仕方ないですね。&lt;/p&gt;

&lt;p&gt;ということでみなさんスクリプト書きましょう。&lt;/p&gt;

&lt;h1 id=&#34;追記:97aff0076544159c37193ad080a89d0a&#34;&gt;追記&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangの解釈はシェルじゃなくてOSのexec()がやります。で、#!や認識できるバイナリ以外は、exec()がエラーを返した後でシェルがファイルを見て、テキストファイルならシェルスクリプトとして実行ってやってます。なので先頭が:の場合は(続&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614551978526445570&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangとしてではなく、シェルがシェルスクリプトとして読んでるだけなので、その後に/bin/shとか書いてあっても関係ないはず (シェルによってはそこも見るかもしれませんが)&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614552151759589376&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということで実験してみたところ、先頭の&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;はどのシェルも読み飛ばす模様(つまり、&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/usr/bin/ruby&amp;quot;&lt;/code&gt;と書いてもrubyが実行される訳ではない)。&lt;/p&gt;

&lt;p&gt;で、先程の 完全版から&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;を取り除いて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても動いたのでこれが最終版ということになります。&lt;/p&gt;

&lt;p&gt;大学の講究でMINIX本やったどころかexecのところ自分の担当だったのに恥かしい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Common Lisp処理系拡張の探求 SBCLのマルチスレッドサポート</title>
      <link>http://keens.github.io/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</link>
      <pubDate>Sat, 20 Jun 2015 18:30:52 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Common_Lispshorikeikakuchounotankyuu_SBCLnomaruchisureddosapo_to/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
### Common Lisp 処理系拡張の探求
SBCLのマルチスレッドサポート

----------------------
Lisp Meet Up #29

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# CLのマルチスレッド
----------------------------
## [bordeaux-threads](https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation)
* 色々な処理系のマルチスレッドサポートの抽象レイヤー
* デファクトスタンダード
  + スレッド
  + ロック
  + コンディションヴァリアル


# SBLCのマルチスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# SBLCのマルチスレッド
----------------------------

* スレッド
  + スレッド内エラー
* アトミック操作&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
  + CAS&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* 排他制御（ロック）
* セマフォ
* コンディションヴァリアル
* バリア
* キュー&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* メールボックス&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* ゲート&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;
* frlock&lt;!-- .element: class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34; --&gt;


# アトミック操作

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# アトミック操作
----------------
複雑な動作は同じデータに並行に動かすと壊れうる

```
        [var = 1]
[incf]      |      [decf]
 [1]&lt;-------|
  |         |------&gt;[1]
 [2]---&gt;[var = 2]    |
            |        | 
        [var = 0]&lt;--[0]
```

# アトミック操作
----------------

* `atomic-{incf, decf}`
  + 動作出来る場所が限られている
* `atomic-{pop, push, update}`
  + CASプロトコルを実装していればどこでも


# CASプロトコル
---------------
* compare and swap
* アトミック操作の基本中の基本
  + ハードウェアレベルのサポート
* ざっくり言うと並行版setf
* `(cas place old new env)`
  + もし`place`が`old`に等しければ`new`を代入
* `(defun (cas foo) (old new))`
  + `cas`版の`setf`定義
* 他にも`setf`相当の機能は揃ってる

# CASプロトコル
---------------

```lisp
(defvar *foo* nil)

(defun (cas foo) (old new)
  (cas (symbol-value &#39;*foo*) old new))
```


# キュー
--------

* 普通のキュー
* スレッドセーフ
* `enqueue`, `dequeue`が基本操作
* `dequeue`が多値で、ブロックしない
  + 空なら第二値がnilになる


# メールボックス
---------------

* キューとほぼ同じ
* スレッドセーフ
* `send-message`, `recieve-message`が基本操作
* `recieve-message`はブロックする
  + タイムアウトも設定出来る
* `recieve-message-no-hangはdequeue`と同じ挙動
* `recieve-pending-messages`もある


# ゲート
--------

* 複数のスレッドが1つのイベントを待つ時に使う
* `wait-on-gate`, `open-gate`, `close-gate`が基本操作



```
[gate (closed)]  [T1] [T2] [T3]
     |            |    |    |
     |     wait   |    |    |
     |&lt;----------------+----+
     |            |    .    .
     |     open   |    .    .
[gate (opened)]&lt;--+    .    .
     +----------------&gt;+---&gt;+
         go            |    |
                       V    V
```


# frlock
--------

* Fast Read Lock
* またの名をRead-Write Lock
* Read Lockは多重に取れる。Write Lockは1つしか取れない。
* 基本操作は`frlock-read`と`frlock-write`
* 普通のlockと違って複数のReadが速くなる


# まとめ
--------

* SBCLのマルチスレッドサポートはbordeaux-threadsよりもリッチ
* 処理系の独自サポート面白い
* 処理系に依存してしまってもいいんじゃないだろうか
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispで限定継続と遊ぶ</title>
      <link>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</link>
      <pubDate>Sun, 26 Apr 2015 21:09:07 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Common Lispで限定継続と遊ぶ
----------------------
[Lisp Meet Up #27](https://atnd.org/events/64988)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# Agenda
--------

0. cl-contの紹介
1. 限定継続の話
2. 限定継続の使い方の話
3. 限定継続の実装の話


# CL-CONTの紹介

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CL-CONT
---------

* Common Lispの限定継続ライブラリ
* 結構古くからあるっぽい
* 割と色々なライブラリが使ってる

# CL-CONT
---------

![cl-cont dependers](/images/cl-cont-dependers.png)

# API
-----

* 継続を区切るマクロ
  + `with-call/cc`
  + `defun/cc`
  + `lambda/cc`
* 継続を取得するマクロ
  + `call/cc`
  + `let/cc`

※後で説明するので意味が分からなくても問題ないです。


# 限定継続の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後トップレベルに戻るまでの計算。
* Schemeが一級市民として扱えることで有名
* 値として取り出した時は0-1引数関数として振る舞う

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      □)))
```

# 継続とは
----------
あとはそれを関数にするだけ

```lisp
(lambda (k)
  (mapc #&#39;writ-line
        (loop :for x :in list
           :collect (if (evenp x)
                        k))))
```


# 限定継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後 *指定した位置* に戻るまでの計算。
* 継続がトップレベルまで戻るのに対して限定継続途中で止まる。それだけ。
* 部分継続などの言い方もある
  + 英語もpart contとdelimited contで分かれる


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(loop :for x :in list
           :collect (if (evenp x)
                        □))
```


# 限定継続とは
-------------

```lisp
(lambda (k)
  (loop :for x :in list
     :collect (if (evenp x)
                  k)))
```

# 限定継続の挙動
---------------
普通のやつ

```lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```

これは

```lisp
(+ 1 2)
```

と等価

# 限定継続の挙動
---------------
今度は継続を呼ばないでみる

```lisp
(with-call/cc
  (+ 1 (call/cc (lambda (k) 2))))
```

これは

```lisp
2
```

と等価

# 限定継続の挙動
---------------
もうちょっと呼ばない例  
(`(let/cc k ...)` = `(call/cc (lambda (k) ...))`)

```lisp
(with-call/cc
  (write-line &#34;hello&#34;)
  (let/cc k 1)
  (write-line &#34;world&#34;))
```

は

```lisp
(progn
  (write-line &#34;hello&#34;)
  1)
```

と等価


# 限定継続の使い方の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の使い方の話
---------------------

* グリーンスレッド
* コールバックを綺麗に書き換える
* 非決定性計算
* etc...


## グリーンスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


## グリーンスレッド
-----------------

* またの名をコルーチン
* またの名を強調スレッド



## グリーンスレッド
-----------------

```lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```

## グリーンスレッド
-----------------
実行結果

```
in thread A 1
in main thread 1
in thread A 2
in main thread 2
in thread A 2
in main thread 3

```


## コールバックの書き換え

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## コールバックの書き換え
----------------------
本当はこう書きたい

```lisp
(with-event-loop
    (format t &#34;Hello, ~a!~%&#34; (async-read stream)))
```

## コールバックの書き換え
----------------------
しかしライブラリがコールバック関数を要求してくる

```lisp
(with-event-loop
    (async-read stream (lambda (line)
                         (format t &#34;Hello, ~a!~%&#34; line))))
```

## コールバックの書き換え
-----------------------
コールバック = 限定継続（後述）なのでこうしてやれば良い。

```lisp
(with-event-loop
    (with-call/cc
      (format t &#34;Hello, ~a!~%&#34;
              (call/cc (lambda (k))
                       (async-read stream k)))))
```

## 非決定性計算

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## 非決定性計算
-------------
### ベースアイディア

* 継続を関数として取り出した後同じ処理を何回も実行出来るんじゃね？


## 非決定性計算
-------------
### ベースアイディア
複数回呼び出してみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (list (funcall c 1)
        (funcall c 2)
        (funcall c 3)))
```


## 非決定性計算
-------------
### ベースアイディア
普通の1引数関数として使ってみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (mapcar c (list 1 2 3)))
```

## 非決定性計算
-------------
### ベースアイディア
マクロでラップしてみる

```lisp
(defmacro for (&amp;body expr)
  `(with-call/cc ,@expr))
(defmacro in (m)
  `(let/cc k (apply #&#39;append (mapcar k ,m))))
(defun yield (x) (list x))
(defun unit () nil)
```


## 非決定性計算
-------------
使ってみる

```lisp
(for
  (let ((x (in &#39;(1 2 3)))
        (y (in &#39;(a b c))))
    (yield (cons x y))))
```

```
((1 . A) (1 . B) (1 . C) (2 . A) (2 . B) (2 . C) (3 . A) (3 . B) (3 . C))
```


# 限定継続の実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の実装の話
-------------------

* 継続は0~1引数関数として取り出せるのであった。
  + 実は機械的に取り出せる
* 継続は全ての式に暗黙に存在するのであった
  + 全ての式を継続を明示的に使うようにも出来る


# CPS変換

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CPS変換
---------

* 全ての関数の引数を1つ増やして、そこで継続を受け取る
* 値を返す時は暗黙のreturnを使うのではなく明示的に継続を呼ぶ
* 関数を呼ぶ時は必ず継続を渡す。呼び出し元には返ってこない（自然と末尾再帰になる）


# CPS変換
---------
例えば

```lisp
(with-call/cc
  (foo (call/cc
        (lambda (k)
          (funcall k 2)))))
```

は、取り出された継続が

```lisp
(lambda (k) (foo k))
```

。


# CPS変換
---------
よって

```lisp
((lambda (k) (foo k)) 2)
```

と変換される


# CPS変換
---------
再帰関数だと少し面倒

```lisp
(defun fact (n)
  (if (&lt;= n)
      1
      (* n (fact (- n 1))))))

```

が

```lisp
(defun fact (n c)
  (if (&lt;= n)
      (c 1)
      (fact (- n 1) (lambda (v) (* n v)))))
```

となる


# CPS変換
---------

* CPS変換を行なうことでいつでも継続を値として使える


# 限定継続の実装の話
-------------------

* CPS変換を裏で行なっている
* 自動で出来るのでマクロで変換をしている
  + 組み込み関数は変更出来ないので特別扱い
  + スペシャルフォームも気をつける必要がある
* `lambda`が乱立するのでパフォーマンスは酷い。


# まとめ
-------

* cl-contというライブラリがあって、限定継続が扱える
* 限定継続は処理を中断したり再開したり繰り返したりに使える
* 裏ではえげつないことをやっている
* パフォーマンスが必要なところでは使っちゃダメ


# 参考
------
* [picrin/partcont.scm at master · picrin-scheme/picrin](https://github.com/picrin-scheme/picrin)
* [cl-cont | Quickdocs](http://quickdocs.org/cl-cont/)
* [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)
* [継続渡しスタイル - Wikipedia](http://ja.wikipedia.org/wiki/%E7%B6%99%E7%B6%9A%E6%B8%A1%E3%81%97%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB)
* [M.Hiroi&#39;s Home Page / お気楽 Scheme プログラミング入門](http://www.geocities.jp/m_hiroi/func/abcscm20.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>caveman2、ningle…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト</title>
      <link>http://keens.github.io/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</link>
      <pubDate>Thu, 05 Mar 2015 13:18:44 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# caveman2、ningle、datafly…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト
----------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;ずっと俺のターン&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 問題
------
Common Lispは case

* Sensitive &lt;!--.element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;  
* Insensitive &lt;!--.element: class=&#34;fragment shrink&#34; data-fragment-index=&#34;1&#34; --&gt;

どっち?

# 問題
-------

あれ？

```lisp
(eql? &#39;CaseInsensitive &#39;caseinsensitive) ;=&gt; t
```


# 問題
-------

リーダがデフォルトで大文字にするだけ

```lisp
(eql? &#39;|CaseSensitive| &#39;|casesensitive|) ;=&gt; nil
```


# Caveman2
---------

```lisp
@route GET &#34;/hello&#34;
(defun say-hello (&amp;key (|name| &#34;Guest&#34;))
  (format nil &#34;Hello, ~A&#34; |name|))
```

# Ningle
--------

```lisp
(setf (ningle:route *app* &#34;/login&#34; :method :POST)
      #&#39;(lambda (params)
          (if (authorize (getf params :|username|)
                         (getf params :|password|))
            &#34;Authorized!&#34;
            &#34;Failed...Try again.&#34;)))
```

# 面倒…
----
デフォルトでそのままだたっらいいのに

# 魔法の`readtable-case`

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 魔法の`readtable-case`
-----------------------

```lisp
(setf (readtable-case *readtable*) :invert)
```
を使えばOK  
参考: [SBCLでclispとかallegroのmodern mode的なことをする - wasabizの日記](http://wasabiz.hatenablog.com/entry/20120929/1348889601)

# 例
----

```lisp
CL-USER&gt; :username
:USERNAME
CL-USER&gt; (setf (readtable-case *readtable*) :invert)
:invert
CL-USER&gt; :username
:username
```

# まとめ
--------
* `(setf (readtable-case *readtable*) :invert)`を使うと快適だよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>既存のテンプレートエンジンの問題点と再設計</title>
      <link>http://keens.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</link>
      <pubDate>Mon, 02 Mar 2015 23:36:03 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt;
.red {
color: red;
}
&lt;/style&gt;
# 既存のテンプレートエンジンの問題点と再設計、あるいはArrowsについて
-----------------------------------------------------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 野生のLisper
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

# Template Engines

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Existing Architeture
----------------------
0. (リクエスト)
1. アプリ
  0. 引数を計算
  1. テンプレートに引数を渡す
  2. レスポンスをレンダリング &lt;!--.element: class=&#34;fragment grow&#34;  --&gt;
4. レスポンスをサーバに渡す
5. (レスポンス)

# Rendering?
----------------------
* 結合した文字列はクライアントに返ったらその後はゴミ
 + GCへ負荷がかかる (後述)
* クライアントにとって1つの文字列である必要はない
* むしろ返せる部分だけ先に返した方が得（後述）

# GC Pressure (SBCL)
-----------------
* 世代別Copy GC
* 結合した文字列は比較的大きい
* `alloc_space`に入らない大きさならアロケートが遅い
* GCを頻繁に起動してしまう
* 16KBを越えると特別扱いされて遅い/メモリを喰う
* LispのWebアプリはレスポンスタイムの分散が大きい（要出展）

参考: [SBCL GENCGC @ x86 Linux](http://cl-www.msi.co.jp/reports/sbcl-gc-memo.html)

# Split Response
---------------
例えば、こんなの

&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot; xml:lang=&amp;quot;en&amp;quot; lang=&amp;quot;en-us&amp;quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://localhost:1313//reveal.js/lib/css/xcode.css&amp;quot;&amp;gt;
        &amp;lt;script src=&amp;quot;//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
        ....
        &amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body class=&amp;quot;li-body&amp;quot;&amp;gt;
    &amp;lt;header&amp;gt;{{ header }}&amp;lt;/header&amp;gt;
    {{ body }}
    ...
&lt;/code&gt;&lt;/pre&gt;

# Split Response
---------------
1. `{{ header }}`の前に先頭から`&lt;header&gt;`までを返す
2. `{{ header }}`を返す
3. `&lt;/header&gt;`を返す
4. `{{ body }}`を返す

...


# Pros of Split Response
------------------------
* `header`を計算してる間にクライアントにhead部分が渡る
  + 先に`&lt;link&gt;`や`&lt;script&gt;`を要求出来る
  + サーバ側のスループットやレスポンスタイムは変わらないが
    クライアントのレンダリング完了までの時間は大幅に短縮出来る
* 文字列を結合する必要がない
* 定数部分については長さが判ってるので最適化し易い

# How TEs Work 
---------------------------
## Compilation
1. テンプレート文字列
 + パーサ &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
 + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数

# How TEs Work 
---------------------------
## Rendering
1. レンダリング関数
 + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列

# Misc Problems
---------------
* サーバに渡すのは文字列なのにソケットに書き込む時はオクテット？
  + 文字列で返す？オクテットで返す？（デバッグがー）
  + オクテットの変換はいつ？
* ストリームが遅い？
  + POSIX APIが使える&#34;なら&#34;fdの方が速い？
* ユーザが用意したバッファに書き出したい？
* テンプレートに渡す引数が定数文字列なら畳み込める筈？
* リクエストの度にテンプレートパースするのは筋悪だけど開発中は毎回コンパイルするのは面倒？

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;

# Arrows

Template flies like an arrow

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Arrows
--------
* [KeenS/arrows](https://github.com/KeenS/arrows)
* 現在開発中のテンプレートエンジン
* 複数のテンプレートが選べる（予定）
* 複数のバックエンドが選べる
* バックエンドに依ってはnon-consing

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Compilation
1. テンプレート文字列&lt;span class=&#34;red&#34;&gt; + 定数引数&lt;/span&gt;
  + パーサ&lt;span class=&#34;red&#34;&gt;(default, cl-emd互換...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
  + &lt;span class=&#34;red&#34;&gt;最適化(const folding, concat, convert...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
  + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数&lt;span class=&#34;red&#34;&gt;(string, octets, stream, fast-io ...)&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Rendering
1. レンダリング関数
  + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列&lt;span class=&#34;red&#34;&gt;、オクテット列、ストリーム書き出し、fast-io…&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How compiled
--------------

```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を

```lisp
(compile-template-string :xxx
  &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34; ())
```
とコンパイル

# Stream backend
----------------
&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* ほとんどアロケートしない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Octet backend
----------------

```lisp
(lambda (&amp;key name)
  (with-fast-output (buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;&lt;h1&gt;Hi &#34;)
       buffer)
    (fast-write-sequence
      (string-to-octets
        (encode-for-tt (princ-to-string name)))
                       buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;!&lt;/h1&gt;&#34;)
      buffer)))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------

```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を

```lisp
(compile-template-string :stream
   &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34;
   &#39;(:known-args (:name &#34;&lt;κeen&gt;&#34;)))
```
とコンパイル

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## variable folding

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string (encode-for-tt &#34;&lt;κeen&gt;&#34;) stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 既知の引数は畳み込む
* 文字列なら`princ-to-string`しない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## const folding

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string &#34;&amp;lt;κeen&amp;gt;&#34; stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 定数のエスケープはコンパイル時に済ませる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## append sequence

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &amp;lt;κeen&amp;gt;!&lt;/h1&gt;&#34;
                stream))
```
* 複数シーケンスの書き出しは1つにまとめる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
* 引数計算の遅延
* 引数計算の並列化
* 非同期化
* HTML compction

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の遅延
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は必要になったら値を計算する(Promise パターン)

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の並列化
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は並列に計算して必要になったら値を要求する(Futureパターン)

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 非同期化
* 単純にwriteを非同期にする
* 他にFutureもブロックするので非同期Futureを使う

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## HTML compction

```html
&lt;ol&gt;
  &lt;li&gt; item 1 &lt;/li&gt;
  &lt;li&gt; item 2 &lt;/li&gt;
  &lt;li&gt; item 3 &lt;/li&gt;
&lt;/ol&gt;

```
を

```html
&lt;ol&gt;&lt;li&gt;item 1&lt;/li&gt;&lt;li&gt;item 2&lt;/li&gt;&lt;li&gt;item 3&lt;/li&gt;&lt;/ol&gt;

```
* DOM構造が変わってしまう


&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# TODOs
-------
* 設計上複数シンタックスをサポート可能だがまだしてない
* 既存のテンプレートエンジンとの比較ベンチマーク
* 高速化
* 多機能化
  + テンプレート
  + 最適化
  + バックエンド
* clackとの連携
  + clackのAPIはメモリアロケーションが多めに必要になる

# Summary
---------
* 既存のテンプレートエンジンは非効率
  + メモリを無駄遣いしていた
  + ユーザーのことを考えてなかった
* 新しいテンプレートエンジンを設計した
  + メモリアロケーションをあまりしない
  + ユーザー側の速度まで考慮した
  + 柔軟
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispのポータビリティとユニバーサリティ</title>
      <link>http://keens.github.io/blog/2015/01/22/common-lisp-portability-and-univesality</link>
      <pubDate>Thu, 22 Jan 2015 07:51:02 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/01/22/common-lisp-portability-and-univesality</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://clfreaks.org/post/108341635899/1-cim-vs-roswell&#34;&gt;clfreaks&lt;/a&gt;の収録時に他のLisperと話してて価値観というか目標を共有出来てないなと思ったのでここで心情を語る次第。今のCommon Lispの使われ方には問題がある。&lt;/p&gt;

&lt;p&gt;Common Lispにはポータビリティというかユニバーサリティというか、そういうものがない。いや、処理系の作者達はしっかり作ってるのだけどLisperがそういう使い方をしていない。&lt;/p&gt;

&lt;p&gt;例えば、Rubyで出来たアプリケーションを使いたいとしよう。Jekyllがいいかな。大抵のシステムには入ってるだろうが一応処理系のインストールから始めてみる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aptなりpkgなりyumなりで処理系をインストールする。それが気に入らなければソースからインストールしてもいい。&lt;/li&gt;
&lt;li&gt;処理系をインストールするとgemがついてくるので&lt;code&gt;gem install jekyll&lt;/code&gt;を叩く。&lt;/li&gt;
&lt;li&gt;あとはJekyllを使うだけ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あるいは、Octopressなら処理系のインストールのあとは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git cloneしてくる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gem install bundler&lt;/code&gt;でbundlerをインストールする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bundle install&lt;/code&gt;で依存gemをインストールする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bundle exec rake preview&lt;/code&gt;でサーバーが起動する。&lt;/li&gt;
&lt;li&gt;止めたければCtrl-Cで止まる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Common Lispで出来たアプリケーションを使いたいとしよう。&lt;a href=&#34;https://github.com/vsedach/cliki2&#34;&gt;cliki&lt;/a&gt;。がいいかな。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;処理系のインストールはRubyと同じくパッケージマネージャで入る。あるいはソースからインストールしてもいい。この際処理系選びは既に終わっているとする。&lt;/li&gt;
&lt;li&gt;clikiをgit cloneしてくる。&lt;/li&gt;
&lt;li&gt;ASDFに読んでもらうために~/common-lisp以下にclikiを移動する。&lt;/li&gt;
&lt;li&gt;依存パッケージのインストールのためにquicklispをインストールする。

&lt;ul&gt;
&lt;li&gt;quicklisp.lispをダウンロードしてくる。&lt;/li&gt;
&lt;li&gt;REPLを起動する。どうやって？処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;li&gt;Lispの式をいくつか評価してquicklispをインストールする。~/quicklispが出現するがこの際目を瞑る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;REPLで&lt;code&gt;(ql:quickload :cliki)&lt;/code&gt;を評価して依存パッケージをインストールする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(start-cliki-server port homedir wikis)&lt;/code&gt;でサーバーが起動する。REPLも起動しっぱなし。&lt;/li&gt;
&lt;li&gt;止めたければ

&lt;ul&gt;
&lt;li&gt;Ctrl-Cでinteractive-interruptコンディションを発生させる。デバッガが起動する。&lt;/li&gt;
&lt;li&gt;デバッガからREPLのtoplevelに戻る。デバッガの操作?処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;li&gt;REPLを終了する。どうやって？処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「アプリケーションは~/common-lispじゃなくて/var/wwwに置きたいんだけど」 - 「コンフィグ書いたら変えられるよ。ASDFのコンフィグ書いてね。コンフィグの書き方はLisperの常識だよね」&lt;br /&gt;
「~/quicklisp邪魔なんだけど」 - 「ああ、それも変えられるよ。好きな場所に移動して処理系の初期化ファイル書き直してね。初期化ファイル？処理系依存だから自分で調べろ。どう直すか？簡単なLispの式だから自分で直せるよね？」&lt;/p&gt;

&lt;p&gt;多分言いたいことは伝わったかと思う。コマンドラインから扱えないとかパッケージマネージャが我が儘とか色々あるんだけど全ては「Lisperのためだけのものになっている」の一言で表せられる。&lt;/p&gt;

&lt;p&gt;quicklispが我が儘なのはまだ許せる。インストール先のディレクトリが固定されてないと管理しづらいから。しかしASDFがライブラリじゃなくてアプリケーションにまで特定のパスにあることを要求してくるのは納得がいかない。コンパイルやらロードやらテストやらの機能があるんだから.asdファイルのあるディレクトリをルートとしてそこだけで完結してほしい。以前、&lt;a href=&#34;http://KeenS.github.io/blog/2014/11/30/quicklisp/&#34;&gt;こんな記事&lt;/a&gt;を書いた所為でASDFの信者と思われているみたいだが、どっちかというとASDFの方が嫌いだ。ASDFが憖っか依存関係の解決までするがためにアプリケーションの置き場まで制約を受ける。手を広げたがために本来の機能が使い辛くなっている。Lisperが制約を受けるのはまだいい。アプリケーションのユーザにまで制約が及ぶのは耐えられない。&lt;/p&gt;

&lt;p&gt;コマンドラインから扱えない問題は多分ノウハウがなかったからだと思う。&lt;a href=&#34;http://KeenS.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/&#34;&gt;以前の記事&lt;/a&gt;で紹介した方法は多分知られていなかった。あとは複雑で使い辛いと評判(だった)のcl-launchか。アプリケーションはおろかquicklispすらREPLに入らないと使えない。ユーザがLispを微塵も知らない可能性すらあるのに。さらに、コマンドラインから使えないということは他のUnixツール群と組み合わせることも困難になる。また、&lt;a href=&#34;http://blog.8arrow.org/entry/20120323/1332516342&#34;&gt;ここ&lt;/a&gt;にあるようにREPLでアプリケーションを起動していると問題もある。&lt;/p&gt;

&lt;p&gt;私はこの問題を解決するためにCIMを作った。clfreaksの時にも喋ったがCIMのメインの機能は&lt;code&gt;cl&lt;/code&gt;コマンドと&lt;code&gt;ql&lt;/code&gt;コマンドだ。&lt;code&gt;cim&lt;/code&gt;コマンドはただの付加価値のためにつけたおまけである。&lt;/p&gt;

&lt;p&gt;もしclコマンドが広く使われるようになればshebangにclを使うだけで実行可能ファイルが作れて、コマンドラインから使えるようになる。qlを使えばREPLに入らずにパッケージをインストール出来る。スクリプトがエラーを出してもデバッガに入るようなことはない。Ctrl-Cでちゃんと止まる。&lt;/p&gt;

&lt;p&gt;これで一部ユニバーサリティの問題は解決出来たんだけだまだまだ未解決問題がある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CIMのインストールが必要になる。&lt;/li&gt;
&lt;li&gt;コマンドラインツールは解決したにしてもディレクトリ丸ごと持ってくるようなアプリケーションはASDFの制約をうける&lt;/li&gt;
&lt;li&gt;コンパイルの問題&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1はやっぱりLispを知らない人に使ってもらいたいならCIMのインストールは省きたい。処理系とquicklispだけ入れたら使えてほしい。やっぱりquicklispに変わってもらうしかないのかな。配布物に実行可能形式を含めてたらPATHも通して欲しいし。&lt;/p&gt;

&lt;p&gt;2のASDFの制約の問題はASDFを環境変数で制御出来るようなのでうまいことする方法を考えている。良い方法があったらまたアウトプットする。&lt;/p&gt;

&lt;p&gt;3は現状CIMで扱いかねてる問題。マクロ展開の問題からコンパイルするのが望ましいんだけどコンパイル後のファイルに互換性がない。しかも互換性がないのに同じ拡張子を使う。そこを上手く扱ってくれるのはASDFなんだけどやっぱり奴は我が儘だし何よりコンパイルしてしまうとAllegroを除いてshebangが効かなくなる。&lt;/p&gt;

&lt;p&gt;解決案はいくつか上がってるんだけどまだ決定的なものはない。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;コンパイルをあきらめる&lt;/li&gt;
&lt;li&gt;本体だけASDFでコンパイルしてエントリポイントになるスクリプトはコンパイルしない&lt;/li&gt;
&lt;li&gt;スタンドアロンバイナリ配布する&lt;/li&gt;
&lt;li&gt;ECLを使ってCのファイルを配布する&lt;/li&gt;
&lt;li&gt;ユーザー側にスタンドアロンバイナリを作らせる&lt;/li&gt;
&lt;li&gt;特定の処理系を要求する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1は下の策。&lt;/p&gt;

&lt;p&gt;2は個人的に推したいところだけどやっぱりASDFが憎い。&lt;/p&gt;

&lt;p&gt;3はクロスコンパイルが壊滅的なCommon Lispでは現実的ではない。&lt;/p&gt;

&lt;p&gt;4はCommon Lispの利点の一つにSBCLやCCLやCMU CLの速度が速いというのがあるから出来れば自由に処理系を選ばせたい。あとECLのランタイムのインストールが必要になる。&lt;/p&gt;

&lt;p&gt;5はやっぱりASDFが憎い。それに依存ライブラリもロードするにはquicklispもロードする必要があって、以前の記事の通りバイナリに邪魔なものが入るしそうでなくてもバイナリが素で60MBとかになる。stripするとアプリケーションとして動かなくなるからstripも出来ない。&lt;/p&gt;

&lt;p&gt;6はコンパイル後のファイルがポータブルな処理系はABCL、CLISP、XCLあたりだが、起動の遅いABCL、微妙に仕様に従ってなくて開発も停滞気味なCLISP、既に開発されていない上にマイナーでライブラリのサポートも薄いXCLとあまり選びたくないものばかり。&lt;/p&gt;

&lt;p&gt;因みに非Lispユーザにも使われているCommon LispアプリケーションにStumpWMがあるが、5の方法を採用している。しかしASDFを使わずにMakefileでコンパイルしている。依存ライブラリも手でインストールする必要がある。出来ればCommon Lispのツールチェーンに載せたまま配布したいところ…&lt;/p&gt;

&lt;p&gt;研究が必要。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>実用Common Lispを読んだ</title>
      <link>http://keens.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda</link>
      <pubDate>Sun, 14 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda</guid>
      <description>&lt;p&gt;以前&lt;a href=&#34;http://KeenS.github.io/blog/2014/10/20/lisp-ja/&#34;&gt;Common Lispの勉強の手引の記事&lt;/a&gt;を書いたときに実用Common Lispの名を挙げたが読んだことはなかった。&lt;/p&gt;

&lt;p&gt;一応名前を挙げた責任として読んでみた。&lt;/p&gt;

&lt;p&gt;読んだとは言ってもソースはざっくりしか見てないし、演習には目もくれてないので「一通り目を通した」程度。
買った本は逃げないのだし一回で理解する必要はない。最初に一通り内容を掴んで主張を理解してから、あとで気になった時につぶさに読むのが私の読み方。&lt;/p&gt;

&lt;p&gt;最初の感想を言うと、古い。Common Lispもcltl2とANSI両方に配慮されて書かれているし、紹介されているAIの事例も1970~1980年代のもの。
古典といった感じ。ただし、その時代はCommon LispとAIの最盛期なのでこの本を読めばCommon LispがAIで名を馳せた理由が良く分かる。&lt;/p&gt;

&lt;p&gt;Common Lispの内容は初級程度。まえがきにもあるようにプログラマとしては中級だがLispは初心者レベルの人向に書かれている。基本的なところを押えたらあとはどんどん進んでいく。
プログラミングの経験があればそれでも問題ない筈。心配ならWeb上にいくらでもあるチュートリアルをこなせば良い。&lt;/p&gt;

&lt;p&gt;ライブラリなどに関しては本の中で完結しているので良く言えば1から10まで教えてくれる。悪く言えば最近のCommon Lispの動向は全く分からない。その意味では実践入門ではなく学習図書。陳腐化はしない。&lt;/p&gt;

&lt;p&gt;AIについては、やはり古い。今では手法が確立されてAIの分野とは扱われないものも含まれている。ただし、これは意図したものなのかもしれない。
古いものというのは単純だ。最初に2部で単純なものを通して「肩馴らし」をしてから3部で手駒を増やして4部で踏み込んだ内容に入る。&lt;/p&gt;

&lt;p&gt;また、AIの分野としては扱われていなものも含む、ということはこの本が情報科学の広い範囲をカバーする、ということでもある。900ベージは伊達じゃない。量もあればバラエティもある。&lt;/p&gt;

&lt;p&gt;現実にある様々な難解な問題をCommon Lispという強力な道具で快刀乱麻解決していく。ソフトウェア開発手法を学びながらCommon Lispの強力さを思い知るための一冊。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>割と処理系ポータブルなCommon Lisp実行可能ファイルを作る</title>
      <link>http://keens.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru</link>
      <pubDate>Mon, 08 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru</guid>
      <description>&lt;p&gt;κeenです。Lisp Advent Calendarはもう枠埋まっちゃったので普通にブログで。&lt;/p&gt;

&lt;p&gt;コマンドラインから実行可能なLispファイルをそれなりに多くの処理系で動くように作る話。&lt;/p&gt;

&lt;p&gt;この話はCIMの生い立ちとも関連するんだけどシェルからLispを使いたいときは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env sbcl --script

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんて書いてた人も多いんじゃないかと思うんだけどこれは色々問題がある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;envは環境に依っては/usr/local/bin/envだったりする&lt;/li&gt;
&lt;li&gt;envは環境に依っては複数引数を取れない。&amp;rdquo;sbcl &amp;ndash;script&amp;rdquo;という名前のファイルを捜しにいく&lt;/li&gt;
&lt;li&gt;sbclでしか動かない&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;この問題の扱いは一応解決策がある&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh

#|
exec sbcl --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
|#

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3行目の&lt;code&gt;#|&lt;/code&gt;がシェルのコメントでありLispのブロックコメントであるのがポイント。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;シェルは&lt;code&gt;#!/bin/sh&lt;/code&gt;を見てシェルスクリプトとして実行する&lt;/li&gt;
&lt;li&gt;1,3行目はコメントなのでシェルは無視&lt;/li&gt;
&lt;li&gt;4行目でsbclにそのファイルを引数として与えてexecする。execしたあとはシェルには戻らないのでその後何が書いてあっても構わない&lt;/li&gt;
&lt;li&gt;sbclを&lt;code&gt;--script&lt;/code&gt;付きで読んでるので1行目の&lt;code&gt;#!&lt;/code&gt;で始まる行は無視する&lt;/li&gt;
&lt;li&gt;3~5行目はブロックコメントなのでsbclは無視&lt;/li&gt;
&lt;li&gt;それ以降がLispとして実行される&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;というカラクリになっている。こういうのをピジン言語っていうんだけ？&lt;/p&gt;

&lt;p&gt;まあいいや。&lt;/p&gt;

&lt;p&gt;ところでこのブロックコメントの中にはシェルスクリプト書き放題だよね？そのシェルスクリプト内でどのLisp使うか決めたらポータブルになりそうじゃない？&lt;/p&gt;

&lt;p&gt;こういうのはどう？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;#!/bin/sh

#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
|#

(write-line (lisp-implementation-type))
(force-output)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cclとabclは1行目のシェバンを読み飛ばせなかった&amp;amp;評価結果をエコーバックしない方法が見当らなかったからパス。CMUCLは自分の環境で動かないから検証出来てない。&lt;/p&gt;

&lt;p&gt;これでポータブルに実行は可能。コマンドライン引数の扱いとかはライブラリを頼ってくれ。因みにCIMでは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  #+allegro  (cdr (system:command-line-arguments))
  #+sbcl (do*  ((var sb-ext:*posix-argv* (cdr list))
                (list var var))
               ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+clisp ext:*args*
  #+ecl (do*  ((var (si:command-args) (cdr list))
               (list var var))
              ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+abcl extensions:*command-line-argument-list*
  #+gcl (do*  ((var si::*command-args* (cdr list))
               (list var var))
              ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+cmu ext:*command-line-words*
  #+ccl ccl:*unprocessed-command-line-arguments*
  #+mkcl (do*  ((var (si:command-args) (cdr list))
               (list var var))
              ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+lispworks system:*line-arguments-list*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としている。参考までに。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>claspがアップデートされたよ</title>
      <link>http://keens.github.io/blog/2014/12/06/claspgaatupudetosaretayo</link>
      <pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/06/claspgaatupudetosaretayo</guid>
      <description>

&lt;p&gt;このエントリーは&lt;a href=&#34;http://qiita.com/advent-calendar/2014/lisp&#34;&gt;Lisp Advent Calendar 2014&lt;/a&gt;6日目の記事です。&lt;br /&gt;
前: nobkzさんで &lt;a href=&#34;http://qiita.com/nobkz/items/2be2b6806237d8ea6e21&#34;&gt;lfe - (lisp (flavored (erlang)))について基本その1 - Qiita&lt;/a&gt;&lt;br /&gt;
後: 私で &lt;a href=&#34;http://KeenS.github.io/blog/2014/12/07/h2onipicrinworong-kasu/&#34;&gt;H2Oにpicrinを溶かす | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。アドベントカレンダーめっちゃ書いてますね。&lt;/p&gt;

&lt;h1 id=&#34;clasp:77e635c8bfc030775f1dbb8efa5b9863&#34;&gt;Clasp!&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/drmeister/clasp&#34;&gt;clasp&lt;/a&gt;のmasterに色々マージされました。リリースノートには、&lt;/p&gt;

&lt;p&gt;&lt;quote&gt;&lt;pre&gt;
Clasp version 0.11
* Added ASDF support.
This is still alpha. Compile the ASDF module using (core:compile-asdf).
After that you can load the module using (load &amp;ldquo;sys:kernel;asdf;build;asdf.bundle&amp;rdquo;).
It takes between 15-30 seconds to load (this is why I&amp;rsquo;m integrating Cleavir).
* Added the :CLASP &lt;em&gt;feature&lt;/em&gt; and removed the :ECL &lt;em&gt;feature&lt;/em&gt;.
Clasp will continue to mimic the underlying ECL functionality so that
Common Lisp code that supports ECL can be made to support Clasp by converting
#+ecl to #+(or ecl clasp) and #-ecl to #-(or ecl clasp)
* Added code to generate object files directly from Clasp.
The LLVM bitcode compiler &amp;ldquo;llc&amp;rdquo; no longer needs to be in the PATH
for Clasp to generate object files from Common Lisp source.
The &amp;ldquo;ld&amp;rdquo; linker does need to be accessible.
&lt;/pre&gt;&lt;/quote&gt;&lt;/p&gt;

&lt;p&gt;とあります。ASDFが使える！リリースノートには書いてませんがslimeサポートもmasterにコミットされてます。あとコミット読んだら最適化もされてるような…。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://KeenS.github.io/slide/clasp.html&#34;&gt;以前&lt;/a&gt;二十数秒掛かっていた&lt;code&gt;(fib 29)&lt;/code&gt;ですが、今回はなんと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 ... loading image... it takes a few seconds
Top level.
&amp;gt; (load &amp;quot;fib.lisp&amp;quot;)
1346269
real time : 34.294 secs
run time  : 38.844 secs
T
&amp;gt; (compile-file &amp;quot;fib.lisp&amp;quot;)

#P&amp;quot;/home/kim/Lisp/fib.bc&amp;quot;
NIL
NIL
&amp;gt; (load &amp;quot;fib.bc&amp;quot;)
1346269
real time : 21.355 secs
run time  : 25.785 secs
T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うわぁ。遅くなってる。&lt;/p&gt;

&lt;p&gt;因みに.bcファイルはLLVMの中間ファイルなのでClaspとは独立に&lt;code&gt;opt -f -O3 fib.bc &amp;gt; fib.opt.bc&lt;/code&gt;で最適化出来ます。それをやると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ opt -f -O3 fib.bc &amp;gt; fib.opt.bc
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 ... loading image... it takes a few seconds
Top level.
&amp;gt; (load &amp;quot;fib.opt.bc&amp;quot;)
1346269
real time : 34.981 secs
run time  : 37.986 secs
T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ？遅くなった。&lt;/p&gt;

&lt;p&gt;mpsはまだコンパイル中だから待ってね&lt;/p&gt;

&lt;h1 id=&#34;asdfを使ってみる:77e635c8bfc030775f1dbb8efa5b9863&#34;&gt;ASDFを使ってみる&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 ... loading image... it takes a few seconds
Top level.
&amp;gt; (time (core:compile-asdf))
zsh: segmentation fault (core dumped)  /usr/local/clasp/bin/clasp_boehm_o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。解散。因みに50分くらいは動いてた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VOPで遊ぶ</title>
      <link>http://keens.github.io/blog/2014/12/02/vopdeyou-bu</link>
      <pubDate>Tue, 02 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/02/vopdeyou-bu</guid>
      <description>

&lt;p&gt;(:meta&lt;br /&gt;
 ((:this &amp;ldquo;&lt;a href=&#34;http://qiita.com/advent-calendar/2014/lisp&#34;&gt;Lisp Advent Calendar 2014&lt;/a&gt;の3日目の記事&amp;rdquo;)&lt;br /&gt;
  (:prev (:author &amp;ldquo;tk_riple&amp;rdquo; :title &lt;a href=&#34;http://compassoftime.blogspot.jp/2014/12/r7rs.html&#34;&gt;&amp;ldquo;時の羅針盤＠blog: R7RSポータブルライブラリを書く際の落とし穴&amp;rdquo;&lt;/a&gt;))&lt;br /&gt;
  (:next (:author &amp;ldquo;nobkz&amp;rdquo; :tite &amp;ldquo;&lt;a href=&#34;http://qiita.com/nobkz/items/68ee2adbc13caf3eec6f&#34;&gt;Shenの基礎その1 基本的な型 - Qiita&lt;/a&gt;&amp;rdquo;))))&lt;/p&gt;

&lt;p&gt;κeenです。さっきまでVOPで遊んでたので当初の予定を変更してVOPの話をします。&lt;/p&gt;

&lt;h1 id=&#34;vopとは何か:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;VOPとは何か&lt;/h1&gt;

&lt;p&gt;SBCLやCMU CLで使われているネイティブコードを吐くための機構、要はインラインアセンブラです。&lt;/p&gt;

&lt;h1 id=&#34;vopとはどんなものか:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;VOPとはどんなものか&lt;/h1&gt;

&lt;p&gt;とりあえずコードをば。x86-64用です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package :cl-user)
(defpackage vop-sample
  (:use :cl :sb-ext :sb-c))
(in-package :vop-sample)

(defknown add (fixnum fixnum)          ; addのftypeを宣言
    fixnum
    (movable                            ; 副作用がない
     flushable                          ; デッドコードとして除去してよい
     foldable                           ; 定数畳み込みをしてよい
     always-translatable)               ; 必ずアセンブラコードになる
  :overwrite-fndb-silently t)           ; 関数上書きのエラーを出さない


(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::add)          ; VOP名
  (:translate vop-sample::add)         ; 関数名
  (:policy :fast-safe)                  ; declare optimize的な
  (:args (x :scs (signed-reg))          ; 引数宣言。後述
         (y :scs (signed-reg)))
  (:arg-types fixnum fixnum)            ; 引数の型宣言
  (:results (r :scs (signed-reg)))      ; 返り値宣言。後述
  (:result-types fixnum)                ; 返り値の型宣言
  (:generator 4                         ; 翻訳するときのコスト
              (move r x)                ; 返り値レジスタにxを移動
              (inst add r y)))          ; 返り値レジスタにyを足し込む
(in-package :vop-sample)

(defun add (x y)                        ; 安全なバージョンでラップする
  (add x y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとおまじないが多いですね。&lt;/p&gt;

&lt;p&gt;すこし解説すると引数は基本レジスタ渡しで、レジスタが足りなければスタックも使います。で、レジスタやスタックの値には型があります。それがストレージクラス(sc)です。この場合、x、y、rは&lt;code&gt;signed-reg&lt;/code&gt;と宣言されてますね。符号付きレジスタです。&lt;code&gt;:scs&lt;/code&gt;の最後のsは複数形のsです。今回は1つしか指定してませんが複数指定することも可能なのです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt;というのはアセンブラ命令ではなく、マクロかなんかです（適当）。VOPなのかな？どのストレージクラスからどのストレージクラスに移動するかを認知して適切な命令を吐きます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inst&lt;/code&gt;が付いてるのがアセンブラですね。&lt;/p&gt;

&lt;p&gt;このコード、xとrが等しいときに最適化出来るのですがそれはまあおいといて、こいつをディスアセンブルしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VOP-SAMPLE&amp;gt; (disassemble #&#39;add)
; disassembly for ADD
; Size: 43 bytes. Origin: #x1005C26416
; 16:       488BD3           MOV RDX, RBX                     ; no-arg-parsing entry point
; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
; 2E:       CC0A             BREAK 10                         ; error trap
; 30:       02               BYTE #X02
; 31:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 32:       9A               BYTE #X9A                        ; RCX
; 33:       CC0A             BREAK 10                         ; error trap
; 35:       04               BYTE #X04
; 36:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 37:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 3A:       CC0A             BREAK 10                         ; error trap
; 3C:       04               BYTE #X04
; 3D:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 3E:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要な部分はここです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ADD&lt;/code&gt;の他に無駄な命令がいくつかありますね。&lt;/p&gt;

&lt;p&gt;SBCLはintの下位1bitをGCのときのタグとして使ってるのでアセンブラに渡す前に算術右シフト(&lt;code&gt;SAR&lt;/code&gt;)して渡してます。
そして返るときはまた左シフト(&lt;code&gt;SHL&lt;/code&gt;)してます。&lt;/p&gt;

&lt;p&gt;その後の&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は関数から返るときのイディオム(スタックポインタを復元してフラグをクリアして呼び出し元に戻る)です。&lt;/p&gt;

&lt;p&gt;余談ですがLispマシンなどのタグマシンは下位ビットにあるタグを無視して計算出来るのでシフトが不要になります。なので速いんですね。&lt;/p&gt;

&lt;h1 id=&#34;シフトをなくす:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;シフトをなくす&lt;/h1&gt;

&lt;p&gt;さっきは&lt;code&gt;signed-reg&lt;/code&gt;を指定しました。つまり「（アセンブラの）intをくれ」と要求した訳です。
intの下位1bitは0なので足し算する分には別にシフトされなくても問題ありませんよね。シフトを殺しましょう。&lt;/p&gt;

&lt;p&gt;さっきのコードの下にこれを足します。&lt;code&gt;add&lt;/code&gt;は再定義しないと反映されないようでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::add/v2)        ; vop名は異なる
  (:translate vop-sample::add)          ; 関数名は同じ
  (:policy :fast-safe)
  (:args (x :scs (any-reg))             ; any-regになってる
         (y :scs (any-reg)))            ; any-regになってる
  (:arg-types fixnum fixnum)
  (:results (r :scs (any-reg)))         ; any-regになってる
  (:result-types fixnum)
  (:generator 3                         ; コストをさっきより低くすると優先して使ってくれる
              (move r x)
              (inst add r y)))

(in-package :vop-sample)

(defun add (x y)
  (add x y))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んで、ディスアセンブルしてみると&lt;/p&gt;

&lt;p&gt;VOP-SAMPLE&amp;gt; (disassemble #&amp;lsquo;add)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; disassembly for ADD
; Size: 31 bytes. Origin: #x1004C2AB83
; 83:       488BD1           MOV RDX, RCX                     ; no-arg-parsing entry point
; 86:       4801FA           ADD RDX, RDI
; 89:       488BE5           MOV RSP, RBP
; 8C:       F8               CLC
; 8D:       5D               POP RBP
; 8E:       C3               RET
; 8F:       CC0A             BREAK 10                         ; error trap
; 91:       02               BYTE #X02
; 92:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 93:       9A               BYTE #X9A                        ; RCX
; 94:       CC0A             BREAK 10                         ; error trap
; 96:       04               BYTE #X04
; 97:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 98:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 9B:       CC0A             BREAK 10                         ; error trap
; 9D:       04               BYTE #X04
; 9E:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 9F:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。見事にSARとSHLが消えましたね。&lt;/p&gt;

&lt;h1 id=&#34;もう少し複雑な型を扱う:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;もう少し複雑な型を扱う&lt;/h1&gt;

&lt;p&gt;アセンブラですし&lt;code&gt;(simple-array (unsigned-byte 8) (*))&lt;/code&gt;(以下octets)を扱いたいですよね。とりあえず難しいことは考えずにoctetsの0番目の要素にアクセスしてみましょう。とはいっても&lt;code&gt;simple-array&lt;/code&gt;は長さや要素の型の情報も持っていることが予想されるので少しデータを読み飛ばさないといけませんね。&lt;/p&gt;

&lt;p&gt;その辺の計算が分からなかったのでsbclのソースからそれっぽいものを参考にしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defknown access-simple-array-0 ((simple-array (unsigned-byte 8) (*)))
    (unsigned-byte 8)
    (movable flushable always-translatable)
  :overwrite-fndb-silently t)
(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::access-simple-array-0)
  (:translate vop-sample::access-simple-array-0)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg)))
  (:arg-types *)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4
              (inst movzx r 
               (make-ea :byte :base x
                        :disp (- (* vector-data-offset n-word-bytes)
                               other-pointer-lowtag)))))

(in-package :vop-sample)
(defvar *octets* (make-array 4
                             :element-type &#39;(unsigned-byte 8)
                             :initial-contents &#39;(10 11 12 13)))

(defun access-simple-array-0 (x)
  (access-simple-array-0 x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じになります。境界チェックとかはやってませんが許して下さい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;descriptor-reg&lt;/code&gt;というのがポインタが入ってるレジスタっぽいです。&lt;code&gt;movzx&lt;/code&gt;は8bitの値を64bitのレジスタに符号拡張しながらロードする命令です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make-ea&lt;/code&gt;というのがアドレッシングですね。&lt;code&gt;x&lt;/code&gt;レジスタを起点として&lt;code&gt;(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)&lt;/code&gt;バイト(？ワード？)先のメモリ1byteを指します。&lt;/p&gt;

&lt;p&gt;ディスアセンブルしてみましょう。みなさんもう慣れてきたと思うので主要部だけ抜き出します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 65:       0FB65101         MOVZX EDX, BYTE PTR [RCX+1]      ; no-arg-parsing entry point
; 69:       48D1E2           SHL RDX, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;短いですね。この&lt;code&gt;BYTE PTR [RCX+1]&lt;/code&gt;が&lt;code&gt;make-ea&lt;/code&gt;した値に対応します。&lt;code&gt;RCX&lt;/code&gt;は&lt;code&gt;x&lt;/code&gt;で&lt;code&gt;(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)&lt;/code&gt;の結果が1に現れてるんでしょう。補足しておくと、&lt;code&gt;EDX&lt;/code&gt;と&lt;code&gt;RDX&lt;/code&gt;は同じ場所を指します。32bitとして扱うときはE、64bitとして扱うときはRで指します。&lt;/p&gt;

&lt;p&gt;さて、私はx86のアドレッシングモードなんて全然知らないのですがコードを見る限りもうちょっと複雑なアドレッシングが出来るようです。&lt;/p&gt;

&lt;p&gt;配列のn番目にアクセスするコードが良い例のようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defknown access-simple-array-n ((simple-array (unsigned-byte 8) (*)) (unsigned-byte 64))
    (unsigned-byte 8)
    (movable flushable always-translatable)
  :overwrite-fndb-silently t)
(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::access-simple-array-n)
  (:translate vop-sample::access-simple-array-n)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg))
         (i :scs (unsigned-reg)))
  (:arg-types * unsigned-num)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4
              (inst movzx r 
               (make-ea :byte :base x
                        :scale 1
                        :index i
                        :disp (- (* vector-data-offset n-word-bytes)
                               other-pointer-lowtag)))))

(in-package :vop-sample)
(defun access-simple-array-n (x i)
  (access-simple-array-n x i))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新たに引数&lt;code&gt;i&lt;/code&gt;をとるようになったのと&lt;code&gt;make-ea&lt;/code&gt;の引数に&lt;code&gt;:scale 1 :index i&lt;/code&gt;が加わってます。&lt;/p&gt;

&lt;p&gt;ディスアセンブルしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 98:       0FB6543901       MOVZX EDX, BYTE PTR [RCX+RDI+1]  ; no-arg-parsing entry point
; 9D:       48D1E2           SHL RDX, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アドレッシングに&lt;code&gt;+RDI&lt;/code&gt;が加わりましたね。どうして&lt;code&gt;i&lt;/code&gt;(&lt;code&gt;RDI&lt;/code&gt;)を&lt;code&gt;RAS&lt;/code&gt;しなくていいのか気になりますがまあ、とりあえず正常に動いてるようです。&lt;/p&gt;

&lt;p&gt;おわかりかと思いますがアドレッシングが&lt;code&gt;x&lt;/code&gt;をベースにして今までの定数オフセット+新たにレジスタで指定したオフセットになってます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make-ea&lt;/code&gt;に渡した&lt;code&gt;:index&lt;/code&gt;は何か分かるとしても&lt;code&gt;:scale&lt;/code&gt;が気になりますよね。&lt;code&gt;scale&lt;/code&gt;を2にしてディスアセンブルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 58:       0FB6547901       MOVZX EDX, BYTE PTR [RCX+RDI*2+1]  ; no-arg-parsing entry point
; 5D:       48D1E2           SHL RDX, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。インデックスを定数倍するようですね。&lt;/p&gt;

&lt;h1 id=&#34;sseにチャレンジ:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;SSEにチャレンジ&lt;/h1&gt;

&lt;p&gt;インテルアーキテクチャにあるSSEとはStreaming SIMD Extensionsの略です。じゃあSIMDは何かというとSimple Instruction Mulitple Dataの略で、1命令で複数のデータを処理出来ます。&lt;/p&gt;

&lt;p&gt;この「複数のデータ」というのは64bit2つや32bit4つなどを128bitにまとめて渡します。128bitの値なんてどうやって作るんだよって感じですがsbcl-1.1.8から入った&lt;code&gt;sb-ext:%make-simd-pack-*&lt;/code&gt;が存在します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VOP-SAMPLE&amp;gt; (%make-simd-pack-ub32 1 2 3 4)
#&amp;lt;SIMD-PACK  01 00 00 00  02 00 00 00  03 00 00 00  04 00 00 00&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じです。x86_64がリトルエンディアンだったのを思い出させる表記ですね。ub32の他にub64、single、doubleが存在します。&lt;/p&gt;

&lt;p&gt;ストレージクラスも&lt;code&gt;*-sse-reg&lt;/code&gt;というものがあるのでこれを使いましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defknown simd-add ((simd-pack (unsigned-byte 64)) (simd-pack (unsigned-byte 64)))
    (simd-pack (unsigned-byte 32))
    (movable flushable always-translatable)
  :overwrite-fndb-silently t)
(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::simd-add)
  (:translate vop-sample::simd-add)
  (:policy :fast-safe)
  (:args (x :scs (int-sse-reg))
         (y :scs (int-sse-reg)))
  (:arg-types simd-pack-int simd-pack-int)
  (:results (r :scs (int-sse-reg)))
  (:result-types simd-pack-int)
  (:generator 4
              (move r x)
              (inst padddw r y)))

(in-package :vop-sample)
(defun simd-add (x y)
  (simd-add x y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。こんな感じですね。&lt;code&gt;paddw&lt;/code&gt;はparallel add wordですかね。これをディスアセンブルすると思ったより大きな命令になったので全部貼っときますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VOP-SAMPLE&amp;gt; (disassemble #&#39;simd-add)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;; disassembly for SIMD-ADD
; Size: 108 bytes. Origin: #x1006D64A21
; 21:       660F6FC2         MOVDQA XMM0, XMM2                ; no-arg-parsing entry point
; 25:       660FFDC1         PADDW XMM0, XMM1
; 29:       49896C2440       MOV [R12+64], RBP                ; thread.pseudo-atomic-bits
; 2E:       4D8B5C2418       MOV R11, [R12+24]                ; thread.alloc-region
; 33:       498D5320         LEA RDX, [R11+32]
; 37:       493B542420       CMP RDX, [R12+32]
; 3C:       7740             JNBE L2
; 3E:       4989542418       MOV [R12+24], RDX                ; thread.alloc-region
; 43:       498D530F         LEA RDX, [R11+15]
; 47: L0:   48C742F165030000 MOV QWORD PTR [RDX-15], 869
; 4F:       48C742F900000000 MOV QWORD PTR [RDX-7], 0
; 57:       660F7F4201       MOVDQA [RDX+1], XMM0
; 5C:       49316C2440       XOR [R12+64], RBP                ; thread.pseudo-atomic-bits
; 61:       7402             JEQ L1
; 63:       cc09             break 9                          ; pending interrupt trap
; 65: l1:   488be5           mov rsp, rbp
; 68:       f8               clc
; 69:       5d               pop rbp
; 6a:       c3               ret
; 6b:       cc0a             break 10                         ; error trap
; 6d:       02               byte #x02
; 6e:       19               byte #x19                        ; invalid-arg-count-error
; 6f:       9a               byte #x9a                        ; rcx
; 70:       cc0a             break 10                         ; error trap
; 72:       04               byte #x04
; 73:       32               byte #x32                        ; object-not-simd-pack-error
; 74:       fe1b01           byte #xfe, #x1b, #x01            ; rdx
; 77:       cc0a             break 10                         ; error trap
; 79:       04               byte #x04
; 7a:       32               byte #x32                        ; object-not-simd-pack-error
; 7b:       fe9b03           byte #xfe, #x9b, #x03            ; rdi
; 7e: l2:   6a20             push 32
; 80:       bac0854200       mov edx, 4359616                 ; alloc_tramp
; 85:       ffd2             call rdx
; 87:       5a               pop rdx
; 88:       80ca0f           or dl, 15
; 8b:       ebba             jmp l0
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なにやってるのやら。&lt;/p&gt;

&lt;h1 id=&#34;出来なかったこと:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;出来なかったこと&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;PCMPESTRI&lt;/code&gt;を使ってみたかったのですが扱いがトリッキーなので断念しました。具体的に言うと操作する値を格納するレジスタがEAXとECX固定なようなのです。
&lt;code&gt;:temporary&lt;/code&gt;節で内部で使うレジスタも要求出来るようなのですが名指しでもらえるんですかね。&lt;/p&gt;

&lt;p&gt;SSEの使い方とsimple-arrayから要素の配列を取り出す方法までは示したので誰かやって下さい。&lt;/p&gt;

&lt;p&gt;参考資料いっぱい置いときますね。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/&#34;&gt;How to Define New Intrinsics in SBCL - Paul Khuong mostly on Lisp&lt;/a&gt;
: VOPの使い方。最初の方に出てきたaddの最適化のやつとかも出てくる。(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html&#34;&gt;Hacking SSE Intrinsics in SBCL (part 1) - Paul Khuong mostly on Lisp&lt;/a&gt;
: SBCLのsimd-packの具体的解説(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pvk.ca/Blog/2013/06/05/fresh-in-sbcl-1-dot-1-8-sse-intrinsics/&#34;&gt;Fresh in SBCL 1.1.8: SSE Intrinsics! - Paul Khuong mostly on Lisp&lt;/a&gt;
: SBCLでVOPとSSEを使ってマンデルブロ集合を計算する(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://software.intel.com/en-us/node/514244&#34;&gt;Packed Compare Intrinsics&lt;/a&gt;
: IntelのPCMPESTRIとかのマニュアル(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb531465.aspx&#34;&gt;_mm_cmpestri&lt;/a&gt;
: MicrosoftのPCMPESTRIのマニュアル。こっちの方が分かりやすい(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://homepage1.nifty.com/herumi/prog/intel-opt.html&#34;&gt;Intel optimization&lt;/a&gt;
: PCMPISTRIを使った&lt;code&gt;strlen&lt;/code&gt;の実装例(ja)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.kazuhooku.com/2014/12/improving-parser-performance-using-sse.html&#34;&gt;Kazuho&amp;rsquo;s Weblog: Improving Parser Performance using SSE Instructions (in case of PicoHTTPParser)&lt;/a&gt;
: PCMPESTRIを使ってHTTPパーサーを高速化した話。これをやりたかった。(en)&lt;/p&gt;

&lt;h1 id=&#34;おわりに:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;おつかれ様でした。たまには低レベルなことをやっても良いんじゃないでしょうか。&lt;/p&gt;

&lt;p&gt;明日はnobkzさんで、Shenについてです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>require, ASDF, quicklispを正しく使う</title>
      <link>http://keens.github.io/blog/2014/11/30/quicklisp</link>
      <pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/11/30/quicklisp</guid>
      <description>

&lt;p&gt;κeenです。最近のCommon Lispのパッケージ管理は&lt;code&gt;ql:quickload&lt;/code&gt;しか知らないという方も多いのではないでしょうか。しかしそれだけでは機能が足りないこともあります。Common Lispには様々な管理システムがあるので整理しましょう。&lt;/p&gt;

&lt;h1 id=&#34;provide-require:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;&lt;code&gt;provide&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;同じファイルを読み込まないための原始的なシステムです。Common Lispの標準の機能です。&lt;code&gt;(require &#39;foo)&lt;/code&gt;がファイルをロードし、ロードされたファイル内で&lt;code&gt;(provide &#39;foo)&lt;/code&gt;しておくと2回目以降の&lt;code&gt;(require &#39;foo&#39;)&lt;/code&gt;はファイルを読まずにすぐさま返ります。&lt;/p&gt;

&lt;p&gt;ここで問題なのが&lt;code&gt;require&lt;/code&gt;がどこのファイルを捜しにいくかは処理系依存なところですね。なので生の&lt;code&gt;require&lt;/code&gt;は使えないと思っておいた方が良いでしょう。&lt;/p&gt;

&lt;h1 id=&#34;asdf-3:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;ASDF 3&lt;/h1&gt;

&lt;p&gt;Another System Definition Facility。過去にはAnotherじゃないSystem Definition Facilityもあった模様。最新版は3系です。結構APIが変っているので必ず3の情報を捜しましょう。&lt;/p&gt;

&lt;p&gt;この「System」というのが聞き慣れませんが、ASDFの&lt;code&gt;defsystem&lt;/code&gt;で&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;systemに含まれるファイルの定義&lt;/li&gt;
&lt;li&gt;依存systemの記述&lt;/li&gt;
&lt;li&gt;その他作者、ライセンス、バージョンなどの記述&lt;/li&gt;
&lt;li&gt;systemのコンパイルやロード、テストなどの操作&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;が可能です。ASDFはCにとってのmake + ldを標榜しています。Makefile的なものは(systemname).asdになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;require&lt;/code&gt;との統合もされており、ASDFを適切に設定することで&lt;code&gt;defsystem&lt;/code&gt;されたsystemを&lt;code&gt;require&lt;/code&gt;でロードすることが出来ます。このときASDFは処理系に依存せずにASDFのパスに従って.asdファイルを捜しにいきます。&lt;/p&gt;

&lt;p&gt;また、ほとんどの処理系はASDFを標準添付していて、大抵&lt;code&gt;(require &#39;asdf)&lt;/code&gt;すれば使えるようになっています。&lt;/p&gt;

&lt;p&gt;尚、コンパイル後のファイルは処理系、バージョン毎に互換性がないので本来なら適切に管理する必要がありますが、ASDFが適切に~/.cache/common-lisp以下に管理してくれます。優秀ですね。&lt;/p&gt;

&lt;h1 id=&#34;quicklisp:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;quicklisp&lt;/h1&gt;

&lt;p&gt;lispプロジェクトのインストーラと微妙にパッケージマネージャ的な役割をします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://beta.quicklisp.org/quicklisp.lisp&#34;&gt;http://beta.quicklisp.org/quicklisp.lisp&lt;/a&gt; をダウンロードしてきてそのファイルを読み込んで&lt;code&gt;(quicklisp-quickstart:install)&lt;/code&gt;すれば~/quicklisp/以下にquicklispがインストールされ、ロードされます。処理系を再起動したあとまたquicklispをロードするには~/quicklisp/setup.lispを&lt;code&gt;load&lt;/code&gt;します。が、毎回それをやるのが面倒な人は&lt;code&gt;(ql:add-to-init-file)&lt;/code&gt;しておけば処理系の初期化ファイルに~/quicklisp/setup.lispを読み込む処理が書き加えられます。&lt;/p&gt;

&lt;p&gt;さて、このquicklispを扱う上で3つの概念を覚えておくと良いです。&lt;/p&gt;

&lt;p&gt;dist
:    releaseの配布元。普通は&amp;rsquo;quicklisp&amp;rsquo;のみだがほかのdistを使うことも可能。自前のやつとか。新たなdistを追加したり削除したり出来る。gitのremoteをイメージすればよい。&lt;/p&gt;

&lt;p&gt;release
:    quicklispがダウンロードしてくる単位。ライブラリの作者が登録するときの単位。複数のsystemをもつこともある。&lt;/p&gt;

&lt;p&gt;system
:    ASDFのsystem。ユーザーが使うときの単位。&lt;/p&gt;

&lt;p&gt;さて、quicklispを使うときは通常使いたいシステムを&lt;code&gt;ql:quickload&lt;/code&gt;すればそのシステムと依存システムの含まれているリリースをダウンロード、展開、ロードまでしてくれます。&lt;/p&gt;

&lt;p&gt;開発中はREPLを立ち上げているので「あ、このライブライリ使おう」と思ったら&lt;code&gt;ql:quickload&lt;/code&gt;するだけで即座に使えるようになりますね。&lt;/p&gt;

&lt;p&gt;quicklispのリリースは毎月下旬にアップデートされていて、毎月ちゃんと全てのライブラリが対応処理系で動くことがテストされています。なのでメンテナが居なくなったライブラリはドロップします。代わりにquicklispの作者がテスト出来ないライブラリは登録させてもらえなかったりします（cl-cudaとか）&lt;/p&gt;

&lt;h1 id=&#34;quicklispの問題:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;quicklispの問題&lt;/h1&gt;

&lt;p&gt;既にCommon Lispのライブラリマネージャとしてデファクトスタンダード的位置を築きつつあるquicklispですが、私は結構不満があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;~/quicklisp/setup.lispを読み込むとquicklispの全てを読み込んでしまう: これには過去全てのバージョンのdistとreleaseとsystemのデータベース、HTTPクライアント、圧縮ファイルの解凍ライブラリなども含まれており、処理系の起動が非常に遅くなる&lt;/li&gt;
&lt;li&gt;特にデータベースはファイルに書かれていても高速に読める形式なのに初期化時に毎回全ての内容をLispのハッシュに変換するという愚行をする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(ql:add-to-init-file)&lt;/code&gt;が推奨されているが、前述の通り処理系の起動が遅くなってしまう。特に、（インストーラではなく、インストール済みの）ライブラリマネージャとして使いたくてもインストーラの機能までロードしてしまう。結構メモリを食うしアプリケーションには要らない。&lt;/li&gt;
&lt;li&gt;処理系に依っては初期化ファイルはlispファイルをスクリプトとして使うときは読み込まれないこともあるのでスクリプトには使えない。まあ、前述の通り使いたくもない。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のでライブラリマネージャにはASDFが向いてるのですが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;quicklispでインストールしたシステムはquicklispを一旦ロードするかASDFの設定をいじるかしなければASDFからは使えない&lt;/li&gt;
&lt;li&gt;quicklispはシステムのダウンロード/インストールだけすれば良いものをロードまでする&lt;/li&gt;
&lt;li&gt;要はASDFを隠す&lt;/li&gt;
&lt;li&gt;じゃASDFのラッパーかというとロードしかせず、コンパイルやテストなどはしない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;など様々な問題があります。&lt;/p&gt;

&lt;p&gt;一応quicklispの弁護をしておくと、Common Lispは他のスクリプト言語とはちょっと使い方が違って、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;初期化ファイルは大抵オレオレライブラリで埋め尽くされていてそもそも起動には時間がかかる&lt;/li&gt;
&lt;li&gt;Emacsのように一度REPLを立ち上げたら滅多に落とさない&lt;/li&gt;
&lt;li&gt;アプリケーションも基本的にはREPLの中で使う&lt;/li&gt;
&lt;li&gt;起動時間を気にするなら初期化ファイルを全てロードした、コアファイルをダンプしておいて使う&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった使い方をされることが多いのです。そのような人からしてみたら細々処理されるよりも起動時間とメモリは気にしないから速いやつをくれ、となるのです。&lt;/p&gt;

&lt;p&gt;じゃあそれなりにCommon Lispを使う私が何故そうしないかというと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;立ち上げっぱなしというのが性に合わない。立ち上がっているものを見るとすぐに落としたくなる。EmacsのヘビーユーザーだがEmacsもすぐ落とす。&lt;/li&gt;
&lt;li&gt;コマンドラインアプリケーションを作りたいため、起動時間が命になる。&lt;/li&gt;
&lt;li&gt;私はSBCLの開発版を使っていて、コアファイルはすぐに無効になるためコアダンプはしない（意味がない）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった理由があります。これは初心者にも共通する部分があるんじゃないでしょうか。REPLを立ち上げっぱなしにはしないし「コアダンプ？なにそれ？エラー出してんじゃん」状態でしょう。&lt;/p&gt;

&lt;h1 id=&#34;asdfを正しく使う:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;ASDFを正しく使う&lt;/h1&gt;

&lt;p&gt;ということでquicklispをあまり使わない方法を紹介します。&lt;/p&gt;

&lt;p&gt;前述の通り、quicklispでインストールしたシステムはquicklispを一旦ロードするかasdfの設定をいじるかしなければasdfからは使えません。具体的に言うと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ASDFのデフォルトパスは~/common-lisp以下&lt;/li&gt;
&lt;li&gt;quicklispのシステムのインストールパスは~/quicklisp/dists/(dist name)/software/以下&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なので~/quicklisp/dists/以下にパスを通します。少し無駄なディレクトリもパスに含まれてしまうので気にする人はそれぞれのdistについて~/quicklisp/dists/(dist name)/software/にパスを通しましょう。&lt;/p&gt;

&lt;p&gt;因みに拙作の&lt;a href=&#34;https://github.com/KeenS/CIM&#34;&gt;CIM&lt;/a&gt;は~/.cim/quicklisp以下にquicklispをインストールするのでCIM使いの方は~/.cim/quicklisp/dists/ですね。~/quicklispの方が混乱少ないかなあ。&lt;/p&gt;

&lt;p&gt;さて、ASDFの設定は&lt;a href=&#34;http://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems&#34;&gt;公式マニュアル&lt;/a&gt;を参照すれば良いのですが一応実際のものを書いておくと&lt;/p&gt;

&lt;p&gt;~/.config/common-lisp/source-registry.conf に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(:source-registry
  (:tree &amp;quot;~/quicklisp/dists/&amp;quot;)
  (:tree (:home &amp;quot;Lisp/&amp;quot;))
  :INHERIT-CONFIGURATION)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を書けばOKです。2つめのLisp/は私がCommon Lispファイルを置いているディレクトリですね。この書き方だとquicklispより自分のLispライブラリを優先して読みにいきます。開発版を使いたいときとかむしろ開発をするときとかに必須です。この設定をミスるといくら開発してもロードされてるのはリリース版で、機能が動かないとかの地獄を見ます。&lt;/p&gt;

&lt;p&gt;ここまでくれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;asdf)
(require &#39;hoge)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすればquicklispでインストールしたライブラリをロード出来ます。&lt;/p&gt;

&lt;h2 id=&#34;require以外のasdfの使い方:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;require以外のASDFの使い方&lt;/h2&gt;

&lt;p&gt;バージョンに依って使い方が異なるのですが、3系だと&lt;code&gt;(asdf:xxx-system &#39;hoge)&lt;/code&gt;などとします。具体的には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(asdf:load-system &#39;hoge)&lt;/code&gt; ( = &lt;code&gt;(require &#39;hoge)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(asdf:test-system &#39;hoge)&lt;/code&gt; (テストがあるときのみ)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(asdf:compile-system &#39;hoge)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を覚えておけば良いでしょう。他にもいくつか操作があるようですが私は使ったことがないです。&lt;code&gt;asdf:locate-system&lt;/code&gt;は名前的に便利そうではあるんですけどね。&lt;/p&gt;

&lt;p&gt;開発するときはまず.asdファイルを書いておいて(あるいはcl-projectから生成して)、&lt;code&gt;(require &#39;hoge)&lt;/code&gt;で始めて書いていき、ある程度進んだらテストを書いてテストの項目を.asdファイルに書き足して&lt;code&gt;(asdf:test-system &#39;hoge)&lt;/code&gt;、それなりに動くようになったら&lt;code&gt;(asdf:compile-system &#39;hoge)&lt;/code&gt;してコンパイルの様子を見たりコンパイル後のベンチマークを取ったりします。&lt;/p&gt;

&lt;h2 id=&#34;quickloadを成仏させる:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;quickloadを成仏させる&lt;/h2&gt;

&lt;p&gt;これでロードの処理はASDFで全てカバー出来るようになりました。じゃあquickloadのロード機能は邪魔ですね。quicklispをインストーラとしてのみ使いましょう。&lt;/p&gt;

&lt;p&gt;まず処理系の初期化ファイル(sbclなら~/.sbclrc)から&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;;; The following lines added by ql:add-to-init-file:
#-quicklisp
(let ((quicklisp-init (merge-pathnames &amp;quot;~quicklisp/setup.lisp&amp;quot;
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init :verbose nil)))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を削除します。quicklispを使いたいときだけ&lt;code&gt;(load &amp;quot;~/quicklisp/setup.lisp&amp;quot;)&lt;/code&gt;します。そして欲しいシステムをインストールするには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(ql::recursively-install &amp;quot;foo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;します。quickloadに比べて爆速です。ここにきて名前が文字列な上にexportされてないシンポル参照してますね。気持ち悪いという方は大人しくquickloadしましょう。&lt;/p&gt;

&lt;p&gt;拙作のCIMにはこれをコマンドラインから行なう&lt;code&gt;ql install&lt;/code&gt;なるコマンドが存在します。&lt;/p&gt;

&lt;h1 id=&#34;最後に:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;quicklispが嫌いなのは私の好みですがASDFを正しく使えて損はないと思うので知らなかった方々は是非試してみて下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lisp meet up #22でLTしてきた</title>
      <link>http://keens.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita</link>
      <pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/11/28/lisp-meet-up-number-22deltsitekita</guid>
      <description>

&lt;p&gt;κeenです。先日 Lisp Meet Up #22 でLTしてきたので報告です。&lt;/p&gt;

&lt;p&gt;LTは事前に登録されたのが2件、私が当日17時くらいに登録したの1件で、参加は20人募集の内20人応募、20人参加と最近中々の人気を見せてます。&lt;/p&gt;

&lt;h1 id=&#34;common-lispで高速なhttpパーサーを書く-仮:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;Common Lispで高速なHTTPパーサーを書く(仮)&lt;/h1&gt;

&lt;p&gt;LT1件目は深町さんより、「Common Lispで高速なHTTPパーサーを書く(仮)」。fast-httpを作ったときの話。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/42153462&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/fukamachi/writing-a-fast-http-parser&#34; title=&#34;Writing a fast HTTP parser&#34; target=&#34;_blank&#34;&gt;Writing a fast HTTP parser&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/fukamachi&#34; target=&#34;_blank&#34;&gt;fukamachi&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.google.com/file/d/0B_H0_8eqWuVARnhncWZpRFdUOWM/preview&#34;&gt;動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.8arrow.org/entries/2014/10/23&#34;&gt;深町さんのブログ&lt;/a&gt;に書かれていることの他、fast-httpが高速になるまでの経緯や実装方針などの話もありました。&lt;/p&gt;

&lt;p&gt;最初ベースにしたnode.jsのHTTPパーサ、http-parseは状態を持っていて、1文字読む毎に状態を保存していた。次にベースにしたpicohttpparseは状態を持たず、HTTPリクエストが全部届く前にパースを始めてしまった場合はあきらめて最初からパースするようにしていた。fast-httpは1行パースする毎に状態を保存するようにした。など。&lt;/p&gt;

&lt;p&gt;もう一つ、http-parseは&lt;code&gt;while&lt;/code&gt;ループの中に巨大な&lt;code&gt;case&lt;/code&gt;文があって、現在の状態で&lt;code&gt;case&lt;/code&gt;でディスパッチし、その節の中で読んだ文字に依って現在の状態を変え、またループで先頭に戻って状態に依ってディスパッチするという手法だったそうです。Common Lispの場合は&lt;code&gt;case&lt;/code&gt;が全て&lt;code&gt;(cond ((eql ..) ....) ...)&lt;/code&gt;に展開されて遅い&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a60a195e9e80913e6883fc5337a6bd1f:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a60a195e9e80913e6883fc5337a6bd1f:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;ので&lt;code&gt;while&lt;/code&gt;と&lt;code&gt;case&lt;/code&gt;じゃなくて&lt;code&gt;tagbody&lt;/code&gt;と&lt;code&gt;goto&lt;/code&gt;で実装したそうです。&lt;/p&gt;

&lt;p&gt;この手法は一般にDirect(Navive) ThreadingだとかThreaded Codeだとか呼ばれています。主にバイトコードインタプリタを実装する時にバイトコードに依るディスパッチの部分で使われるようです。Rubyの解説が丁寧だったようなので参考資料として置いておきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://magazine.rubyist.net/?0008-YarvManiacs&#34;&gt;Rubyist Magazine - YARV Maniacs 【第 3 回】 命令ディスパッチの高速化&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;会場からはアーキテクチャ依存の最適化はしないのかとの質問がありました。SBCLにはインラインアセンブラであるVOPなるものが存在するのでSIMD命令使えば、とかいう怖い話ですね。&lt;/p&gt;

&lt;h1 id=&#34;symbol-tree-diff:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;symbol tree diff&lt;/h1&gt;

&lt;p&gt;LT2件目はchikuさんより「symbol tree diff」。chikuさんが以前から取り組んでいるプログラムのdiffを構文レベルでとる話の進捗。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/42160384&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/samugari/symbol-treediff&#34; title=&#34;Symbol tree-diff&#34; target=&#34;_blank&#34;&gt;Symbol tree-diff&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/samugari&#34; target=&#34;_blank&#34;&gt;samugari&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.google.com/file/d/0B_H0_8eqWuVARUoxVGtiMlFrRVU/preview&#34;&gt;動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;diff自体はとれるようになったようですが見せ方に問題があり、見易い形式を模索中のようです。会場に見易い形式は何か投げ掛けましたが良い案を見付けるのは難しいようです。&lt;/p&gt;

&lt;h1 id=&#34;semantic-s式:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;Semantic S式&lt;/h1&gt;

&lt;p&gt;私から「Semantic S式」。括弧が多い方が嬉しいこともあるよねーというゆるい話。
&lt;a href=&#34;http://keens.github.io/slide/semantic-sshi.html&#34;&gt;Semantic S式 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.google.com/file/d/0B_H0_8eqWuVAQms2QkZDcnZfVlU/preview&#34;&gt;動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;会場からは半分同意、半分ツッコみたいとの反応が。plistをリテラルから&lt;code&gt;getf&lt;/code&gt;するやついないだろ、とか。&lt;/p&gt;

&lt;h1 id=&#34;懇親会:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;懇親会&lt;/h1&gt;

&lt;p&gt;私の発表で21時あたりだったのでそのまま解散して懇親会。隣にLand of Lispを読んでLispに興味持ってLispの授業をとってる方がいたのでどの本が入門に良いかなど。&lt;/p&gt;

&lt;p&gt;VOPの話の続きもしました。どうしても資料がないのがネックだよねー、と。私の知っているのは&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/&#34;&gt;How to Define New Intrinsics in SBCL - Paul Khuong mostly on Lisp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;や&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html&#34;&gt;Hacking SSE Intrinsics in SBCL (part 1) - Paul Khuong mostly on Lisp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;かな。日本語のやってみた系だとg1さんの&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://g000001.cddddr.org/2011-12-08&#34;&gt;#:g1: SBCLでVOPを使ってみよう&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;あたり。&lt;/p&gt;

&lt;h1 id=&#34;その他:a60a195e9e80913e6883fc5337a6bd1f&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;テンプレートエンジンを作ってるって以前深町さんに話してたら「まだ出来ないんですか？」とさんざん煽られました。はい。頑張ります。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:a60a195e9e80913e6883fc5337a6bd1f:1&#34;&gt;&lt;code&gt;cond&lt;/code&gt;は先頭から順番に比較する仕様です。&lt;code&gt;case&lt;/code&gt;は&lt;code&gt;cond&lt;/code&gt;に展開されることが仕様で定められていた筈。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a60a195e9e80913e6883fc5337a6bd1f:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>claspを少し触ってみた</title>
      <link>http://keens.github.io/slide/clasp/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/slide/clasp/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# claspを少し触ってみた
----------------------
Lisp Meet Up presented by Shibuya.lisp #21  
2014-10-29  
κeen(@blackenedgold)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:relative;right 0;&#34; --&gt;

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます


# clasp
-------

* Github: [drmeister/clasp](https://github.com/drmeister/clasp)
* 2014-09-18に0.1リリース(現在0.11プレビューが出ている)
* 今は0.11プレビューが出ている
* ANSI Common Lisp準拠を目指す(現在80 ~90%)
* ECLからのフォーク
* LLVMベースのJIT([MCJIT](http://llvm.org/docs/MCJITDesignAndImplementation.html))搭載
* C++とLispで書かれている
* C++との連携を意識

Note:
C++との連携の部分を強調。今回は0.11プレビューでの話


# メモリ管理
------------------

* Memory Pool Systemと Boehm GCから選べる
* ビルドするときにどっちかを選ぶ


# メモリ管理
------------------
## [Boehm GC](http://www.hboehm.info/gc/)

* Mark &amp;amp; Sweepのライブラリ
* 枯れた有名なライブラリ
* Lisp有名どころではGaucheが使う
* RedHat系だとこれを使ってないとrpmリジェクトされやすいらしい(?)

Note:
他にはMozilla, W3M, GNU GCJ, GNU Obj-Cなどなど

# メモリ管理
------------------
## [Memory Pool System](http://www.ravenbrook.com/project/mps/)

* 複数のGCアルゴリズムを組み合わせて使えるらしい
* since 1994
* あまり分からないです&amp;gt;&amp;lt;


# 依存ライブラリ
----------------------

* LLVM **3.6**
* LLVM/clang **3.5** compiler
* Boost build v2
* boost libraries ver 1.55
* Boehm 7.2
* gmp-6.0.0
* expat-2.0.1
* zlib-1.2.8
* readline-6.2


&lt;span style=&#34;font-size:600%&#34;&gt;無理&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# externals-clasp
--------------------------

* Github: [drmeister/externals-clasp](https://github.com/drmeister/externals-clasp)
* 依存ライブラリを揃えるのが難しいとの声から作られた
* 依存ライブラリを全てビルド&lt;!-- .element: class=&#34;fragment grow&#34; --&gt;


&lt;span style=&#34;font-size:300%&#34;&gt;＼LLVMをビルド／&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;＼Boostをビルド／&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:200%&#34;&gt;ビルド時間はお察しです&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 本体のビルド
------------------
Twitter実況をどうぞ↓↓

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangがメモリ6GB以上食い続けてて怖い。何やってんの。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526417151486205952&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangの起動時間1時間超えてますよ…&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526418636735401984&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;HDDプチプチ言ってるし今にも壊れそう&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526420001587068929&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/nobkz&#34;&gt;@nobkz&lt;/a&gt; claspのコンパイル中です。&amp;#10;clangなのにIOネックという謎の状態です。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526420473232367616&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

# 本体のビルド
------------------
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;clangの消費メモリ7GB超えた&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/526423982992420864&#34;&gt;2014, 10月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;ビルドは自己責任で&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 使ってみる
------------
## 起動オプション

```
/usr/local/clasp/bin/clasp_mps_o --help
clasp options
-I/--ignore-image    - Don&#39;t load the boot image/start with init.lsp
-i/--image file      - Use the file as the boot image
-N/--non-interactive - Suppress all repls
-v/--version         - Print version
-s/--verbose         - Print more info while booting
-f/--feature feature - Add the feature to *features*
-e/--eval {form}     - Evaluate a form
-l/--load {file}     - LOAD the file
-r/--norc            - Don&#39;t load the ~/.clasprc file
-n/--noinit          - Don&#39;t load the init.lsp (very minimal environment)
-s/--seed #          - Seed the random number generator
-- {ARGS}*           - Trailing are added to core:*command-line-arguments*
```

# 使ってみる
------------
## ASDF

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ASDFの処理系依存の部分(`#+`)の問題
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ECLと見做されるけどECLのコードは動かない

# 使ってみる
------------
## cl-ppcre

* [手動ロードスクリプト](https://gist.github.com/KeenS/4e25cb6e424ebe4e7a4a)
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;`schar`がない
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;ANSI Common Lispにあるのに…

# 使ってみる
------------
## C++との連携

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;ドキュメントがない
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;サンプルコードもない
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;遂行不能

# 使ってみる
------------
## LLVMの呼び出し
* [clasp/src/llvmo/demo.lisp](https://github.com/drmeister/clasp/blob/master/src/llvmo/demo.lsp)
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;動かない

# 使ってみる
------------
&lt;style type=&#34;text/css&#34;&gt;
.graph{
  background:#aaa;
  border-radius:5px;
  white-space: nowrap;
  text-align: left;
}
td {
  white-space: nowrap;
}
&lt;/style&gt;

処理系              |  `(time (fib 29))`
--------------------|-----------------------------------------------------------------
clasp-0.1(boehm)    | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(264.3px * 3);&#34; data-fragment-index=&#34;1&#34;&gt;26.43s&lt;/div&gt;
clasp-0.1(mps)      | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(172.8px * 3);&#34; data-fragment-index=&#34;1&#34;&gt;17.28s&lt;/div&gt;
clasp-0.11(boehm)   | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(213.2px * 3);&#34; data-fragment-index=&#34;2&#34;&gt;21.32s&lt;/div&gt;
clasp-0.11(mps)     | &lt;div class=&#34;graph fragment&#34; style=&#34;width:calc(187.9px * 3);&#34; data-fragment-index=&#34;2&#34;&gt;18.79s&lt;/div&gt;
ECL-13.5.1          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 16.0px * 3);&#34;&gt;1.603s&lt;/div&gt;
ECL-13.5.1(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  1.9px * 3);&#34;&gt;0.192s&lt;/div&gt;
ABCL-1.3.1          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 32.9px * 3);&#34;&gt;3.292s&lt;/div&gt;
ABCL-1.3.1(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  2.4px * 3);&#34;&gt;0.241s&lt;/div&gt;


# 使ってみる
------------

処理系              |  `(time (fib 29))`
--------------------|-----------------------------------------------------------------
CLISP-2.49          | &lt;div class=&#34;graph&#34; style=&#34;width:calc( 38.4px * 3);&#34;&gt;3.847s&lt;/div&gt;
CLISP-2.49(compile) | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  7.1px * 3);&#34;&gt;0.7146s&lt;/div&gt;
ccl-1.10            | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.4px * 3);&#34;&gt;0.04033s&lt;/div&gt;
sbcl-1.2.5          | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.6px * 3);&#34;&gt;0.06469s&lt;/div&gt;
alisp-9.0           | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  230px * 3);&#34;&gt;23.09s&lt;/div&gt;
alisp-9.0(compile)  | &lt;div class=&#34;graph&#34; style=&#34;width:calc(  0.6px * 3);&#34;&gt;0.06194s&lt;/div&gt;

&lt;span style=&#34;font-size:200%&#34;&gt;LLVM/JITなのになぜ遅い？&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# LLVM/JITで遅い？
-------------------------

* LLVMって速いんじゃ？
* JIT搭載した○○が速いって聞いたよ
  + JVM
  + lua-jit
  + Rubinius
  + pypy


# 言葉の罠: LLVM
--------------------

* 遅いコードはどんなに頑張っても遅い
* ECLのバックエンドにClang(=LLVM)を使ってもSBCLに勝てないのと同じ


# 言葉の罠: JIT搭載
--------------------

* JIT(実行時コンパイル)の意味は広い
* 実行時にネイティブコードを吐けばJITと言える
* claspは実行直前にコンパイルするだけ
* 多くの速いJIT処理系はTracing JITを使う
  + またの名を適応的コンパイル
  + 実行時の情報に基いて実行中に最適化する
  + `(declare ...)` を自動生成してる的な


# Tracing JITへの道
--------------------

* LLVMのJITは実行直前にコンパイルするだけ
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;Tracing JITのバックエンドには使える
* 実行時最適化には最適化用のコードが必要
  + &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;Common Lispでは`(declare ...)`用のコードを使い回せる
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;案外近い


# 結論
------

* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;遅い
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;時期尚早
* &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;今後機能や速度改善があれば使えるようになるかも


&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispの勉強をするには、あるいは情報を得るには</title>
      <link>http://keens.github.io/blog/2014/10/20/lisp-ja</link>
      <pubDate>Mon, 20 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/10/20/lisp-ja</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://blog.8arrow.org/entry/2014/09/05/062028&#34;&gt;深町さんのブログ&lt;/a&gt;で日本語でCommon Lispの質問をする方法が載ってましたが質問じゃなくて単に情報を得たい、勉強をしたいという場合が書かれてなかったので勝手に補遺。&lt;/p&gt;

&lt;h1 id=&#34;処理系選び:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;処理系選び&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://cl.cddddr.org/index.cgi?%BD%E8%CD%FD%B7%CF%3A%C1%AA%A4%D3%CA%FD%A4%CE%CC%DC%B0%C2&#34;&gt;処理系:選び方の目安 - Common LISP users jp&lt;/a&gt;や
&lt;a href=&#34;https://sites.google.com/site/shidoinfo/Home/programing-lang/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E/lisp/common-lisp/common-lisp-%E5%87%A6%E7%90%86%E7%B3%BB&#34;&gt;Common Lisp 処理系 - 紫藤のWiki&lt;/a&gt;が参考になるかと思います。&lt;/p&gt;

&lt;h1 id=&#34;開発環境構築:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;開発環境構築&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://modern-cl.blogspot.jp/&#34;&gt;Modern Common Lisp&lt;/a&gt;あたりですかね。著者がちょっと古くなってきたので更新するって言ってました。&lt;/p&gt;

&lt;p&gt;処理系のインストールなら*nix環境で使える拙作の&lt;a href=&#34;https://github.com/KeenS/CIM&#34;&gt;CIM&lt;/a&gt;もあります。解説は&lt;a href=&#34;http://KeenS.github.io/blog/2014/01/27/cim-explanation/&#34;&gt;こちら&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;入門:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;入門&lt;/h1&gt;

&lt;h2 id=&#34;web:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;Web&lt;/h2&gt;

&lt;p&gt;私の一番のおすすめはM.HiroiさんのWebページです。一応Common Lispではなくxyzzyですがここで紹介されている内容であればCommon Lispにも共通します。&lt;br /&gt;
&lt;a href=&#34;http://www.geocities.jp/m_hiroi/xyzzy_lisp.html&#34;&gt;M.Hiroi&amp;rsquo;s Home Page / xyzzy Lisp Programming&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;書籍:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;書籍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/%E5%AE%9F%E8%B7%B5Common-Lisp-Peter-Seibel/dp/4274067211&#34;&gt;実践Common Lisp&lt;/a&gt;は入門から実践までいけて素晴らしいです。内容の密度が濃いです。心無しか手にとってみると少し重いです。
loopやformatなど複雑な部分はしっかりベージを割いてるので入門が終わってもリファレンスとして役立ちます。私も今でも参照してます。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/Land-Lisp-M-D-Conrad-Barski/dp/4873115876&#34;&gt;Land of Lisp&lt;/a&gt;は挿絵が多く、少し学んでは実際に使ってみるのルーチンなので勉強のモチベーションを保ちやすいです。
内容は実践Common Lispに比べると細かな注釈が少ないかな？といったところ。さらっと読めて良いですね。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/4798118907/ref=pd_lpo_sbs_dp_ss_2?pf_rd_p=466449256&amp;amp;pf_rd_s=lpo-top-stripe&amp;amp;pf_rd_t=201&amp;amp;pf_rd_i=4873115876&amp;amp;pf_rd_m=AN1VRQENFRJN5&amp;amp;pf_rd_r=1YA4XCHT36XJD6ZEF9KC&#34;&gt;実用Common Lisp&lt;/a&gt;(通称PAIP本)はぶ厚くて高い本。AI系の内容らしい。私は読んだことが無いのですが、数理システムが入門書として使ってるそうです。
2014-12-14 追記 &lt;a href=&#34;http://KeenS.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda/&#34;&gt;読みました&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;何か作る:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;何か作る&lt;/h1&gt;

&lt;h2 id=&#34;web-1:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;Web&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.usamimi.info/~ide/programe/stg_doc/stg-commonlisp.pdf&#34;&gt;Common LispでSTGを作りますが何か&lt;/a&gt;は有名なPDF。STG(シューティングゲーム)を作る内容。多少古い(SDLが1.2系だとか)ものの、練習には十分です。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.8arrow.org/entry/2013/09/10/110632&#34;&gt;Common LispでWebAppの開発に必要なN個のこと - 八発白中&lt;/a&gt;はWeb Appを作るにあたって必要なライブラリを紹介している。紹介しているだけで作り方は書いてないのでどうにか頑張って下さい。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あんまり情報無いですね…Lisperのみなさんもっとアウトプットしましょう。&lt;/p&gt;

&lt;h1 id=&#34;リファレンス:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;リファレンス&lt;/h1&gt;

&lt;h2 id=&#34;web-2:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;Web&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Front/&#34;&gt;Common Lisp Hyper Spec&lt;/a&gt;はCommon Lispの機能をサンプルと共に網羅的に、詳細に紹介しています。英語です。
主に&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Front/Contents.htm&#34;&gt;コンテンツ&lt;/a&gt;からドリルダウンで調べていくと良いです。時間があればじっくり眺めても良いかも。
Common Lispをやる上では必ず必要になるので、英語ですが必ず友達になっておきましょう。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tips.cddddr.org/common-lisp/&#34;&gt;逆引きCommon Lisp&lt;/a&gt;は名前の通りやりたいことからCommon Lispの機能を調べられます。サンプルもあります。残念ながら網羅的ではないのですが凡その需要は満たせると思います。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://quickdocs.org/&#34;&gt;Quickdocs&lt;/a&gt;はライブラリのドキュメントサイト(英語)。ライブラリを捜す時にも良いと思います。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;書籍-1:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;書籍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/COMMON-LISP-%E7%AC%AC2%E7%89%88-Guy-L-Steele/dp/4320025881/ref=cm_lmf_tit_10&#34;&gt;COMMON LISP 第2版&lt;/a&gt;は通称cltl2と呼ばれるCommon Lispの原典の和訳です。一応紹介しました。今のCommon LispはANSI Common Lispになってるので少し違います。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ポータルサイト:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;ポータルサイト&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cl.cddddr.org/index.cgi&#34;&gt;Common LISP users jp&lt;/a&gt;は日本語で様々な情報が得られます。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.reddit.com/r/lisp_ja/&#34;&gt;redditの/r/lisp_ja&lt;/a&gt;にはLispに関連するWebページの情報が日々投稿されています。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cliki.net/&#34;&gt;CLiki&lt;/a&gt;はCommon Lispの総合Wiki(英語)。非常に有用な情報が溜まってます。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://common-lisp.net/&#34;&gt;Common-Lisp.net&lt;/a&gt;はCommon Lispのコミュニティ支援サイト(英語)。多くのプロジェクトをホストしていて、そのWebページなんかもあります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソースコードを読む:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;ソースコードを読む&lt;/h1&gt;

&lt;p&gt;κeenの適当チョイスです。他にお勧めがあれば教えて下さい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/keithj/alexandria&#34;&gt;alexandria&lt;/a&gt;は有名なユーティリティパッケージ。小さな関数やマクロで構成されてるのでイディオム集みたいな感じで読めると思います。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/7max/log4cl&#34;&gt;log4cl&lt;/a&gt;はログライブラリ。ドキュメント(英語)をしっかり書いてるので読み易いです。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/edicl/hunchentoot&#34;&gt;Hunchentoot&lt;/a&gt;はWebサーバ。ドキュメント(英語)を過剰に書いてるので読める筈。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ステップアップ:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;ステップアップ&lt;/h1&gt;

&lt;h2 id=&#34;web-3:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;Web&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/&#34;&gt;On Lisp&lt;/a&gt;は主にマクロについて書かれたCommon Lispプログラミングの指南書。書籍もありますが、Web版もあります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;書籍-2:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;書籍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/LET-OVER-LAMBDA-Edition-1-0/dp/4434133632&#34;&gt;Let Over Lambda&lt;/a&gt;(通称LOL)は過激とか狂気とか宗教とか言われるエッセイ。高速化の話とかクロージャの危ない使い方とかが書かれてます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;lisperとコミュニケーションをとる:a9be93b0b4fb16c2c0e10aa859a2df5f&#34;&gt;Lisperとコミュニケーションをとる&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://shibuya.lisp-users.org/&#34;&gt;Shibuya.lisp&lt;/a&gt;は渋谷を中心に半径2万kmを対象としたLispコミュニティ。毎月下旬の平日夜にLisp Meet Upをやってるのでひょこっとやってくると良いと思います。内容はCommon Lisp, Scheme, Clojureで回してるのでCommon Lisp回は3ヶ月に1回ですが毎回Common Lisperは来てるので別のLispの回でも構わず参加すると良いと思います。
#lispmeetup の情報は&lt;a href=&#34;https://atnd.org/users/51173&#34;&gt;ここ&lt;/a&gt;から入手するのが良いかな？あとは&lt;a href=&#34;https://twitter.com/shibuya_lisp&#34;&gt;Twitterアカウント&lt;/a&gt;もあります。Ustream配信もしてます。&lt;/li&gt;
&lt;li&gt;IRCの#lisp-ja@irc.freenode.orgと#common-lisp-ja@irc.freenode.orgにコミュニティがあります。常に誰かがいる訳ではないのですがちょくちょく見てる人はいるので発言してみると反応があるかもしれません。今もこの投稿に対して反応があってCIMとredditの項目を追加しました。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Shibuya.lisp Tech Talk #8を運営&amp;LTしてきました</title>
      <link>http://keens.github.io/blog/2014/09/16/lisp-tech-talk-8</link>
      <pubDate>Tue, 16 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/09/16/lisp-tech-talk-8</guid>
      <description>

&lt;p&gt;κeenです。レポートに追われ試験があり合宿に行きで2週間以上空きましたが8/30にShibuya.lisp TT #8の運営をしつつLT枠での参加もしてきたので報告です。何かそこそこ大きなイベントの運営をされる方の参考になれば。&lt;/p&gt;

&lt;h1 id=&#34;キックオフミーティング:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;キックオフミーティング&lt;/h1&gt;

&lt;p&gt;キックオフミーティングが6月にありました。集まったのは5人。potix2(@potix2)さん、chikuさん、深町(@nitro_idiot)さんかにたん(@kazh98)、私。Shibuya.lispの運営はもうちょい居る筈なんですけど引く手数多のLisper達はきっと忙しいんでしょうね。&lt;/p&gt;

&lt;p&gt;Shibuya.lisp TTを開催するかを含めて話し合いました。開催されるとなれば3年振りです。&lt;/p&gt;

&lt;p&gt;一番の懸案事項はTTをする人がいるかでした。招待講演のアテを話し合ったりTT枠とLT枠のバランスを話し合ったりして開催可能だろうと判断しました。その場で予想参加人数、タイムテーブルや役割分担、TT枠やLT枠が応募多寡になったときの対応、懇親会をどうするかなどを話し合いました。&lt;/p&gt;

&lt;p&gt;やっぱりその時点では会場が決まってないので不確定要素が多く、「会場次第」が多かったかと思います。そのときの予想や要求を元に会場の条件を絞った訳ですが。&lt;/p&gt;

&lt;p&gt;必要と判断された役職は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;懇親会&lt;/li&gt;
&lt;li&gt;司会&lt;/li&gt;
&lt;li&gt;誘導&lt;/li&gt;
&lt;li&gt;照明&lt;/li&gt;
&lt;li&gt;マイク&lt;/li&gt;
&lt;li&gt;受付&lt;/li&gt;
&lt;li&gt;会計&lt;/li&gt;
&lt;li&gt;広報&lt;/li&gt;
&lt;li&gt;動画&lt;/li&gt;
&lt;li&gt;タイムキーパ&lt;/li&gt;
&lt;li&gt;コーヒーのケータリングとかお茶とかお菓子の準備&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;でした。5人だとどうしても人数が足りないので運営手伝いも募集することになりました。&lt;/p&gt;

&lt;h1 id=&#34;会場決定:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;会場決定&lt;/h1&gt;

&lt;p&gt;mixi様より(鈴木さん経由で)会場を提供頂きました。スクリーン2枚、飲食OK、懇親会もその場でOK、ハンディカムの貸し出しありの至れり尽せりです。鈴木さんありがとう御座います。&lt;/p&gt;

&lt;h1 id=&#34;広報:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;広報&lt;/h1&gt;

&lt;p&gt;広報担当のかにたんがTwitterやMeet Upで宣伝したりchikuさんがTokyo.cljに参加して宣伝したりで広報活動を行なってきました。結果、60人の枠がほぼ埋まる(キャンセル含めれば超過)程度の人数が集りました。かにたんありがとう。&lt;/p&gt;

&lt;p&gt;懸案事項だったTTの発表者は早々に埋まり、むしろ応募多寡だろうと予想されたLT枠が半分しか埋まらなくて焦りました。&lt;/p&gt;

&lt;h1 id=&#34;ビデオ:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;ビデオ&lt;/h1&gt;

&lt;p&gt;映像に詳しいTOYOZUMIさんに相談したところ、発表者の映像出力をキャプチャする手段があるとのことなので&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;特殊機器による映像出力のキャプチャ&lt;/li&gt;
&lt;li&gt;ハンディカムによる発表者の録画&lt;/li&gt;
&lt;li&gt;WebカメラによるUstream配信&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;の3つを行ない、3.はリアルタイムに、1.、2.を合成したものを録画映像として配信することになりました。一応私がビデオ担当でしたが一人では無理なのでchikuさんやかにたんと一緒に予行演習を行ないました。&lt;/p&gt;

&lt;p&gt;扱いの分からぬ機器に悪戦苦闘し、一応動かすことは出来たものの不安が残るので、上手く動いたシナリオと動かなかったシナリオを用意しました。&lt;/p&gt;

&lt;h1 id=&#34;その他:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;懇親会の手配やら会計やらがどうだったかは分かりません。何も気にすることが無い程スムーズに進んでたんでしょう。potix2さんと深町さんありがとうございます。&lt;/p&gt;

&lt;h1 id=&#34;当日:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;当日&lt;/h1&gt;

&lt;h2 id=&#34;準備:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;準備&lt;/h2&gt;

&lt;p&gt;chikuさんと一緒に渋谷駅に集合し、ケータリングのコーヒーを持って会場入り。そのまま鈴木さんにお世話になりつつ会場設営。当初は私は会場設営はほどほどに、ビデオ関係の準備をしてる筈でしたが人が少ないのでそのまま設営をやってました。&lt;/p&gt;

&lt;p&gt;さらにThunderboltケーブルが不足ということでビックカメラまでダッシュ。雪駄+合宿で痛めた足で走るんじゃなかった。結局Thunderboltを買ってきても機器を上手く扱うことが出来ず、失敗した方のシナリオでオペレーションしてました。&lt;/p&gt;

&lt;p&gt;映像配信に関しては私のLinuxではUstream配信出来ないだとかWebカメラがスライドから遠くて見えないだとかがありましたが、全体は滞りなく進行。&lt;/p&gt;

&lt;h2 id=&#34;talk:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;Talk&lt;/h2&gt;

&lt;p&gt;TalkはLT枠は飛び入りが4人あり、結局良い感じに埋まりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;特別講演

&lt;ol&gt;
&lt;li&gt;笹川様 : 好きい夢の話 (&lt;a href=&#34;https://drive.google.com/file/d/0B_H0_8eqWuVAY25lWGdiTGE5RmM/edit?usp=sharing&#34;&gt;ビデオ&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;TT

&lt;ol&gt;
&lt;li&gt;athosさん : genuine-hilighterの話 (&lt;a href=&#34;https://drive.google.com/file/d/0B_H0_8eqWuVAZmJPaWpTMHZRUmc/edit?usp=sharing&#34;&gt;ビデオ&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;深町さん : cl21の話 (&lt;a href=&#34;https://drive.google.com/file/d/0B_H0_8eqWuVAcV91QXRzSC1JVXc/edit?usp=sharing&#34;&gt;ビデオ&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;豊住さん : 自作画像処理ライブラリの話 (&lt;a href=&#34;https://drive.google.com/file/d/0B_H0_8eqWuVATE5nZ0Z4V3Zwdms/edit?usp=sharing&#34;&gt;ビデオ&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;横田さん : 型宣言と最適化の話 (&lt;a href=&#34;https://drive.google.com/file/d/0B_H0_8eqWuVAYzhqZ2J5T0VKTXc/edit?usp=sharing&#34;&gt;ビデオ&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;LT (&lt;a href=&#34;https://drive.google.com/file/d/0B_H0_8eqWuVAaGNLTGpTWWh0ZFU/edit?usp=sharing&#34;&gt;ビデオ 1~4&lt;/a&gt;、&lt;a href=&#34;https://drive.google.com/file/d/0B_H0_8eqWuVAR21Pc2M4bmdpdlU/edit?usp=sharing&#34;&gt;ビデオ 4~9&lt;/a&gt;)

&lt;ol&gt;
&lt;li&gt;のぶかずさん : Shenの話&lt;/li&gt;
&lt;li&gt;κeen : moclの話&lt;/li&gt;
&lt;li&gt;かにたん : 床下LispとLisp Meet Upの話&lt;/li&gt;
&lt;li&gt;すてぃべあさん : EROSの話&lt;/li&gt;
&lt;li&gt;ねこはるさん : Clojureの型推論器の話&lt;/li&gt;
&lt;li&gt;Takagiさん: cl-cudaの話&lt;/li&gt;
&lt;li&gt;あんちべさん : Incanterの話&lt;/li&gt;
&lt;li&gt;TAKUFUKUSHIMAさん : Omの話&lt;/li&gt;
&lt;li&gt;zick_minohさん : 42の言語でLisp処理系を書いた話&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と様々な内容に分かれて行われました。私の発表スライドは&lt;a href=&#34;http://KeenS.github.io/slide/shibuya-dot-lisp-tt-number-8.html&#34;&gt;ここ&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;懇親会:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;懇親会&lt;/h2&gt;

&lt;p&gt;箸が足りない、ケータリングのボットを返却し忘れるなどとトラブルはあったものの概ね問題なく進みました。出されたのはアルコール、ソフトドリンク、寿司、ピザです。&lt;/p&gt;

&lt;p&gt;だいたい言語毎に島が出来てたようです。私は撮影したビデオを取り込みつつ色々な島に入っていきました。Common Lisperでcl21コミッタでScheme実装者でClojureワナビーなのでどこにも入れて良いですね。ただ、前日スライドの微調整などであまり寝てなかったのでちょいちょい居眠りしてました。&lt;/p&gt;

&lt;p&gt;片付けが終って外に出るとみなさんが待ってて下さったのでぞろぞろ帰りました。TOYOZUMIさんが2次会にカラオケに行こうと皆さん誘ってました。私は行こうかと思ったのですがカラオケはジェネレーションギャップがあるとつらいので大人しく帰りました。&lt;/p&gt;

&lt;h1 id=&#34;後日:49552f9ec6ef052f69ae99492e3fa9e0&#34;&gt;後日&lt;/h1&gt;

&lt;p&gt;返し忘れたケータリングのポットは後日chikuさんが返してくれました。&lt;/p&gt;

&lt;p&gt;録画した動画はちょいと梃摺りました。まず、長い動画なので動画サイズが4GBのところで切れてます。なのでその2つを結合し、さらにあまりにサイズが大きいので画質を落とす作業が必要でした。&lt;/p&gt;

&lt;p&gt;変換はavconv(ffmpegのフォーク。Ubuntuだとこれしか入らない)で行なったのですが、MPEG4をダイレクトには結合出来ないらしことに気付くまで何度も失敗しました(1つの動画の変換に4時間とか掛かるんですよ？しかもその間CPUは100%に張り付いてるのでPC使えない)。レポートやら試験やらの合間に行なったのでそれだけで数日使いました。最終的にはmpegtsなるフォーマットに変換してcatで結合すれば良いことが分かり、
    (MP4 + MP4) -&amp;gt; (mpegts + mpegts) -&amp;gt; mpegts -&amp;gt; MP4 -&amp;gt; MP4(low quality)
の手順を踏んで最終動画を得ました。それでも1トークあたり1GBくらいのサイズがあります。もうちょい画質落としても良かったのかな。&lt;/p&gt;

&lt;p&gt;で、今アップロード中ですが私のポンコツWiMAXルータは高負荷に耐えられず1動画数時間掛かってます。その間全くネットが使えません。はぁ。&lt;/p&gt;

&lt;p&gt;実は今回の運営は私も含めTech Talk初参加の人がそれなりに居たのですがなんとか乗り切れましたね。講演をして下さった笹川様、会場を提供して下さったmixi様と鈴木さん、運営の手伝いをして下さった方々、ありがとう御座いました。そして運営のみなさん、発表者のみなさんお疲れ様でした。&lt;/p&gt;

&lt;p&gt;次回もTT開催出来ると良いですね。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>