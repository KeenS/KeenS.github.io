<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>非同期 on κeenのHappy Hacκing Blog</title>
    <link>/categories/%E9%9D%9E%E5%90%8C%E6%9C%9F/index.xml</link>
    <description>Recent content in 非同期 on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/%E9%9D%9E%E5%90%8C%E6%9C%9F/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>非同期とノンブロッキングとあと何か</title>
      <link>/blog/2017/05/19/hidoukitononburokkingutoatonanika</link>
      <pubDate>Fri, 19 May 2017 20:51:46 +0900</pubDate>
      
      <guid>/blog/2017/05/19/hidoukitononburokkingutoatonanika</guid>
      <description>&lt;p&gt;κeenです。最近同期/非同期、ブロッキング/ノンブロッキング、直接形式/継続渡し形式あたりが混乱してきたので個人的に整理します。
あくまで私個人の理解を纏めただけなので誤謬などに注意して下さい。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;非同期とノンブロッキングはよく混同されます。また、非同期処理の記述形式として直接形式や継続渡し形式などがあります。
私自身違う言葉だなとは思いつつも混同したり違いを忘れたりしています。
非同期もノンブロッキングもナイーブなIOに比べると速い方式だな程度の理解でいてそんなに困らないと思ってますし混同や誤用に目くじらを立てるつもりもありません。
しかしながら3者を区別しないと意味を成さない文脈で3者を混同している技術を何度か見掛けたので（自分の中で）整理しようと思ったのがこの記事を書こうと思ったきっかけです。&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;p&gt;色々と調べましたが、以下のブログ記事が一番信頼できそうなのでこの記事の用語に従います。ここでは同期/非同期とブロッキング/ノンブロッキングとIOの多重化を区別しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.matsumoto-r.jp/?p=2030&#34;&gt;人間とウェブの未来 - 非同期I/OやノンブロッキングI/O及びI/Oの多重化について&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一部抜粋します&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ブロッキングI/O:
データ処理が完了するまで待つ&lt;/li&gt;
&lt;li&gt;ノンブロッキングI/O:
データ処理の完了を待たずに他の処理を行う&lt;/li&gt;
&lt;li&gt;synchronous I/O Operation:
データ処理の入出力が可能になった時点で通知
その後に同期的にデータの転送が必要。その処理をブロックあるいはノンブロック（別の処理をしつつ定期的に転送完了をチェックする）に行うかは自由であり、データの整合性は含まない&lt;/li&gt;
&lt;li&gt;Asynchronous I/O Operation:
データ処理の入出力が完了した時点で通知
非同期なので読込の場合は通知のあった段階で既にデータの転送は完了（I/O Completion）しバッファ内にデータがある。シグナルやコールバックによる通知があるまではユーザスペースでその他の処理が可能であるため、基本的にはノンブロック。別にやりたければ通知があるまでブロックしても良い、その辺りは自由&lt;/li&gt;
&lt;li&gt;I/Oの多重化:
I/O可能になったfdを通知（I/OはブロッキングI/O）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;これらはどのようにIOを行うかの問題で、 &lt;strong&gt;実行時&lt;/strong&gt; に関係する話題です。&lt;/p&gt;

&lt;p&gt;次に、直接形式と継続渡し形式について。非同期やノンブロッキングなIOをしようと思うと後続の処理、すなわち（限定）継続が必要になる。この（限定）継続をプログラマがどのように渡すかの問題。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Direct_style&#34;&gt;直接形式&lt;/a&gt;は（限定）継続がプログラムには陽には現れず、コンパイラが頑張るかコルーチンなどの言語機能、&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;などの構文を用いて実現されます。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Continuation-passing_style&#34;&gt;継続渡し形式&lt;/a&gt;(CPS)はプログラマが陽に（限定）継続を渡すスタイルで、コールバック形式などとも呼ばれます。&lt;/p&gt;

&lt;p&gt;これらは主に言語の問題で、 &lt;strong&gt;コンパイル時&lt;/strong&gt; に関係する話題です。
よく直接形式と同期処理が混同されて「同期プログラミングをすることで非同期プログラミングができます」などの矛盾した一文が書かれがちですが区別しましょう。&lt;/p&gt;

&lt;h2 id=&#34;誰が何を&#34;&gt;誰が何を&lt;/h2&gt;

&lt;p&gt;IO処理の話題はスレッドとカーネルとのやりとりに関することが多い気がしますが、Goのようにユーザランドで実行単位を持つと「ブロックする」といったときにスレッドがブロックするのかgoroutineがブロックするのか分かりづらいですね。
なのでこれ以後は誰が何をブロックするのかを出来る限り明示しながら書きたいと思います。例えば「カーネルがgoroutine Aを実行しているスレッドをブロックする」など。&lt;/p&gt;

&lt;h1 id=&#34;scala&#34;&gt;Scala&lt;/h1&gt;

&lt;p&gt;前職でScalaを書いていました。
Scalaの&lt;code&gt;Future&lt;/code&gt;そのものは&lt;code&gt;flatMap&lt;/code&gt;が関数をとるので継続渡し形式ですが、そのシンタックスシュガーの&lt;code&gt;for&lt;/code&gt;式は直接形式でプログラミングができます。
IOの実体についてはFutureで抽象化されているのでexecutorによります。&lt;/p&gt;

&lt;h1 id=&#34;go&#34;&gt;Go&lt;/h1&gt;

&lt;p&gt;前職の新卒研修で5日ほどGoを書いたことがあります。
多くの言語は比較的シンプルなIOモデルを持つので用語を意識しなくても問題ありませんが、Goは実行時に色々工夫しているので用語をちゃんと区別しないと齟齬が出るようです。
なのでGoを例に理解を深めようと思います。&lt;/p&gt;

&lt;p&gt;まず、Goは実行時に動作するコンポーネントが多いので整理します。
&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;ここの質問&lt;/a&gt;への回答によるとgoroutine実行用のスレッド、スケジューラ、GCに大別してよさそうです。
このうち、IOに関連するのはgoroutine実行用のスレッドとスケジューラなのでGCについては触れません。
あまりよく分かってないのですがスケジューラはgoroutine実行用のスレッド上で呼ばれるための関数（群）なんですかね。&lt;/p&gt;

&lt;p&gt;普段は1スレッドが複数のgoroutineの実行を受け持ち、goroutineが何かしらの理由でブロックしそうなタイミングで別のgoroutineにコンテキストスイッチするようです。
ブロックしそうなタイミングというのはやや古いですが&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;ここ&lt;/a&gt;に書かれてます。
直接形式で書きつつコンテキストスイッチをするということはどうにかして(限定)継続を取り出す必要がありますが、それこそgoroutineですね。goroutine自身でスタックを持つようですし。
C関数を呼ぶときなどはコンパイラが裏で呼び出す前と後に分割しているようです。&lt;/p&gt;

&lt;p&gt;さて、IOについてはファイルIOとネットワークIOで操作が異なるようです。&lt;/p&gt;

&lt;p&gt;ファイルIOでは普通に同期/ブロッキングなシステムコールを発効し、OSがスレッドをブロックする時間が長いようなら別スレッドで元スレッドの持っていたgoroutineを実行するようです。
信頼できる情報が出てこなかったのですが自身で長くなりそうと思っているシステムコールの場合はgoroutineの実行権限（プロセス）を手放してあとは他のプロセスがstealするに任せてる？
ファイルIOは、スレッドがシステムコールでブロックし同期的で、goroutineもシステムコールでブロックし同期的です。ただスケジューラのお陰で他のgoroutineに迷惑がかからないだけです。&lt;/p&gt;

&lt;p&gt;ネットワークIOはpollingを行なうようです。
スケジューラがfinbrunnableする中でブロックしない方のpoll(Linuxだとepollにノンブロッキングオプションつけたやつかな？)を呼んで、操作可能なfdがあればそれを待っているgoroutineを起こしている模様。
であれば上の分類に従うとネットワークIOはスレッドはブロックせず同期的でIOを多重化し、goroutineはスケジューラからブロックされ同期的で（特別に関数を呼ばなければ）IOの多重化もしません。&lt;/p&gt;

&lt;p&gt;この他にもgoroutine同士のコミュニケーションにチャネルがあります。そこまで重要じゃないかなと思って詳しく調べてないので間違いがあるかもしれないです。
チャネルへの操作は同期的ですね。チャネルへのread/writeはバッファがempty/fullだったらブロックするようなのでgoroutineはチャネルへの操作でブロックします。調べてないですが普通スレッドはブロックしないでしょう。&lt;/p&gt;

&lt;p&gt;チャネルへのselectはあまり情報が出てこなかったのですが恐らくスケジューラがIO可能なチャネルを調べて1つでもあればそれからランダムに選ぶ、1つもなくdefaultもなければスケジューラがgoroutineをブロックするんだと思います。
goのselectはチャネルからデータが取り出された状態でくるので上の定義に従えば非同期…？そしてIOの多重化ですね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Goの件について図にするとこうですかね。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;スレッド&lt;/th&gt;
&lt;th&gt;goroutine&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ファイル&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ネットワーク&lt;/td&gt;
&lt;td&gt;ノンブロック/同期/多重化&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルRW&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルselect&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/非同期/多重化&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Goで非同期プログラミングが楽になると言っているのをよくみかけますが、今回の私の理解では非同期操作はほとんどないようです。
Goはコンパイラが頑張ってgoroutineをコンテキストスイッチ可能にしているのと、スケジューラが頑張ってプロセス全体がブロックしないようにしているもののgoroutine自体はほとんどの操作でブロック/同期ですし、下のスレッドも同期かつネットワーク操作以外ではブロックするようです。
なので言うとしたら「Goはコンパイラとスケジューラのお陰で見掛け上ブロックしても全体への影響が小さい」ですかね。&lt;/p&gt;

&lt;p&gt;Goに詳しい人、コメントや誤り訂正お願いします。&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/issues&#34;&gt;GitHubのイシュー&lt;/a&gt;とか使えば良い気がします。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/36112445/golang-blocking-and-non-blocking&#34;&gt;multithreading - Golang blocking and non blocking - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/os/file_unix.go?s=#L224&#34;&gt;src/os/file_unix.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/proc.go?s=#L1795&#34;&gt;src/runtime/proc.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/faq#goroutines&#34;&gt;Frequently Asked Questions (FAQ) - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;channel - go routine blocking the others one - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/cgocall.go&#34;&gt;src/runtime/cgocall.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/32538438/how-does-channel-blocking-work-in-go&#34;&gt;select - How does channel blocking work in Go? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/ref/spec#Select_statements&#34;&gt;The Go Programming Language Specification - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;How does the Go runtime work? - Quora&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustで非同期Thriftしたい</title>
      <link>/slide/RustdehidoukiThriftshitai/</link>
      <pubDate>Sat, 26 Nov 2016 13:07:29 +0900</pubDate>
      
      <guid>/slide/RustdehidoukiThriftshitai/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Rustで非同期Thrift
----------------------
[歌舞伎座.tech#12「メッセージフォーマット/RPC勉強会」 - connpass](https://kbkz.connpass.com/event/40629/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

* &lt;span style=&#34;font-size:150%&#34;&gt;X&lt;/span&gt; RPCライブラリを使う話
* &lt;span style=&#34;font-size:150%&#34;&gt;O&lt;/span&gt; RPCライブラリを作る話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# RPC
-----

* Remote Procedure Call
* リモートで呼べる
* 言語跨げる
* シリアライズフォーマットが決まれば大体出来る
* Thrift, protobuf/gRPC, avro...
* 大抵バイナリ
  + JSONに比べて2倍くらい効率がいい

===

# Thrift
--------

* Facebook発(現apache)RPCフレームワーク
* IDLから複数の言語向けのコードを吐ける
* 対応言語多い
* 新しい言語はthriftレポジトリフォークして追加

===

# Thrift vs gRPC
----------------

\                       | Thrift | gRPC
------------------------|:------:|:----:
ベース                  | 自前   | HTTP/2
コード生成              | o      | o
プロトコルのアップデート | o      | o
通信の多重化            | トランスポート次第  | o (HTTP/2)
認証                    | x  | o
例外                    | ユーザ定義可能 | 事前定義のみ?
対応言語                | 多い   | ほどほど
その他                  | union  | timestamp, anyなど
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;

===

# 何故Thrift?
-------------

* 仕事で使ってたから
* 仕事は「gRPCかthrift、まあthriftでいっしょ」で決まった

===

# RustとThrift
--------------
いくつか実装がある

===

## [sgnr/rust-thrift](https://github.com/sgnr/rust-thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![sgnr/rust-thrift is deprecated](/images/thrift/sgnr-rust-thrift.png)

===

## [maximg/thrift](https://github.com/maximg/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![maximg/thrift is deprecated](/images/thrift/maximg-thrift.png)

===

## [terminalcloud/thrift](https://github.com/terminalcloud/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![terminalcloud/thrift is deprecated](/images/thrift/terminalcloud.png)

===

# [thehydroimpulse/thrust](https://github.com/thehydroimpulse/thrust)
---------------------------

* Thrift RPC in Rust (Async I/O)
* 非同期!!
* apache/thriftベースじゃない（フルスクラッチ）
* コンパイラプラグインサポートとかも
* 作りかけ
  + `Latest commit 0a37b77 on 11 Apr`

→ フォークすることに

===

# [Finagle](https://github.com/twitter/finagle)
---------

* **Scalaの** RPCフレームワーク
* [You Server as a Function](https://monkey.org/~marius/funsrv.pdf)
* Nettyベース
* サーバとクライアント両方サポート
* Twitter製
* 良くも悪くもTwitterべったり

===

# Finagle Client
--------

* クライアントが賢い
* RPCではTCPベースのLBが使えない
  + クライアントはコネクション張りっぱなし
* クライアントサイドロードバランシングが必要
* Finagleはそこまでカバー
* 他にもエラーが起きたサーバ外したり色々

===

# Tokio
--------

* **Rustの** RPCフレームワーク
* mioベース
* Finagleを参考に開発
  + **開発中**
* tokio-core
  + コア部分
* tokio-proto
  + プロトコル実装のサポート
  + 絶賛API変更中
* tokio-service
  + サービス実装のサポート


===

# TokioとFinagle
-----------------

  \           | Tokio       | Finagle
--------------|:-----------:|:-------:
コア          | [tokio-core](https://github.com/tokio-rs/tokio-core) | [finagle-core](https://github.com/twitter/finagle/tree/develop/finagle-core)
Future        | [future](https://github.com/alexcrichton/futures-rs) | [twitter util](https://github.com/twitter/util)
非同期エンジン | [mio](https://github.com/carllerche/mio) | [netty](http://netty.io/)
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;


===

# [mio](https://github.com/carllerche/mio)
------

* 非同期イベントループライブラリ
* イベントドリブン
* ループ内ゼロアロケーション
* `epoll` などの薄いラッパ
* libuv, libevent, libev2などのRust版
* ソケットだけでなく *ファイルIO* 、インメモリチャネルとかも監視出来る

===

# [future](https://github.com/alexcrichton/futures-rs)
--------------

* [Zero-cost futures in Rust · Aaron Turon](https://aturon.github.io/blog/2016/08/11/futures/)
* ゼロコスト
* 普通にFutureを使うとランタイムにステートマシンになる
* 「将来実行される」という「状態」を第一級の値として表現する大事な手段
* お型付けは大変
    + `map` したら `Map&lt;A, fn (A)-&gt;B&gt;` の型が返ったり
* ストリーミング指向のAPIもある

===

# [tokio-core](https://github.com/tokio-rs/tokio-core)
--------------

* 非同期IOのフレームワーク
* Futureベース
* フレームドIOとストリーミングIO
* フレームワークというよりユーティリティ？
  + mioとfutureを合わせて使う

===

# [tokio-proto](https://github.com/tokio-rs/tokio-proto)
-------------

* 主にバイナリ列&lt;-&gt;構造体の部分の面倒を見てくれる
* API変更中…
* バッファリングしてパースしやすくしてくれる
* プロトコルの多重化やってくれる(後述)

===

# [tokio-service](https://github.com/tokio-rs/tokio-service)
-----------------

* タスクサーバの面倒見てくれる
* 主にロードバランシング


===

# [Service](https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html)
-------------

``` rust
pub trait Service {
    type Request;
    type Response;
    type Error;
    type Future: Future&lt;Item=Self::Response, Error=Self::Error&gt;;
    fn call(&amp;self, req: Self::Request) -&gt; Self::Future;
}
```

===

# Service
----------

* いわゆるハンドラ
* インターフェースさえ満たせばいい
  + ミドルウェアもハンドラも同じ扱い

===

# [NewService](https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html)
--------------

```rust
pub trait NewService {
    type Request;
    type Response;
    type Error;
    type Instance: Service&lt;Request=Self::Request, Response=Self::Response, Error=Self::Error&gt;;
    fn new_service(&amp;self) -&gt; Result&lt;Self::Instance&gt;;
}

impl&lt;F, R&gt; NewService for F where F: Fn() -&gt; Result&lt;R&gt;, R: Service
```

===

# NewService
------------

* いわゆるAbstractServiceFactory的な存在
* コア数に応じてサービスを作ってくれる
* ただし`Service`を返す普通の関数も`NewService`になる
* [example](https://github.com/tokio-rs/tokio-line/blob/master/examples/echo_client_server.rs#L21)


===

# tokio-thrift
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# [tokio-thrift](https://github.com/KeenS/tokio-thrift)
--------------

* [KeenS/tokio-thrift](https://github.com/KeenS/tokio-thrift)
* この発表のために作った（作ってる）
* tokioベースのrustのthriftサポート
* thrustのフォーク
* 基本ツール全て
  + コードジェネレータ
  + コンパイラプラグイン
  + ランタイムライブラリ

===

# プロトコルスタック
-------------------

ユーザは実装に集中出来る仕組み

```
+------------------------------------------------+
| service   | tokio-service + 生成コード + ユーザ |
|------------------------------------------------|
| protocol  | tokio-proto   + tokio-thrift       |
|------------------------------------------------|
| transport | tokio-core                         |
+------------------------------------------------+
```

===

# サンプルコード
----------------

* [これ](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/main.rs)

===

# ユーザビリティ
---------------

* サーバ: ユーザはインターフェースに沿ったコードを書くだけ
* クライアント: インターフェース通りに呼べる
* 返り値はFuture
* サーバ: 非同期実装と相性がいい
* クライアント: 非同期通信をそのままエンコード

===

# 実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# Thriftのプロトコル
-------------------

* 現状binary protocolのみ
  + fork元が実装してあった
* compactとか需要ある？
* 因みにJSONはやめとけ

===

# 所有権とゼロコピー
-------------------

* プロトコルのパースの部分の話
* Rustっぽい部分
* バッファの所有権をパース結果に渡すことでデータのコピーを避ける

===

# 所有権とゼロコピー
-------------------
バッファをresultにパースして

```
buffer
  |
+-+---------------+
|                 |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 所有権とゼロコピー
-------------------
resultにデータの所有権を渡してしまう

```
 result   buffer
   |        |
+--+----++--+-----+
|       ||        |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 複数メソッド
-------------

* 複数メソッドだと複数の引数/返値の型を扱う
* コネクションのハンドラは1つ
* 複数型をどうやって扱う？
  + [enumを定義](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/thrift.rs#L67)
  + ゼロオーバーヘッド…

===

# 複数メソッド
-------------

```
 (methodA) (methodB)
     |         |
     +----+----+
          | &lt;----- enum化
      [client]
          |
      [server]
          | &lt;----- enumでディスパッチ
     +----+-----+
     |          |
(handlerA) (handlerB)
```

===

# つらい話
-----------------

* Thrift IDLのセマンティクスが書いてない
  + throws節のフィールドは直積？直和？
  + Javaで生成してみて推測するしかない
* フォークライブラリの実装が不完全
  + パーサはフルスクラッチで書き直した
  + [パーサコンビネータ便利](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-codegen/src/parser.rs#L517)
  + フォークした意味…
* Rustにエンコード出来ないthriftの機能もある
  + mapの定数は普通には無理
  + エラーどうしよう(`Error`トレイトの実装とEnum)
* 所有権の問題

===

# 言語との統合
-------------

* Rustには公式のシリアライズフレームワークがある
* [rustc-serialize](https://github.com/rust-lang-nursery/rustc-serialize)
* あるいはユーザ側のも
* [serde](https://github.com/serde-rs/serde)
* のっかりたいけどThriftに必要なデータがない
  + フィールドのシーケンス番号とか
* 今のところ自動生成に頼る
  + フレームワークにフィードバックした方がいい？

===

# コード生成の話
---------------

* [コンパイラプラグイン](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-macros/tests/service.rs#L10)微妙
  + 定義元ジャンプ、フィールド名補完などに難
* CLI生成は悪手
  + IDL変更する度CLI実行？
  + 生成コードはコミット？
    - CLIのバージョンがあるので基本はコミット。でも…
* ビルドツール統合が最良
  + FinagleにはScoogeがある
  + tokio-thriftでもやりたい
    - build.rsのサポート

===

# 多重化の話
------------

* 生のthrift on TCPだと通信を多重化出来ない
* tokio-proto側でpipelineやmultiplexなどをサポート
* pipeline: レスポンスを待たずに次のリクエスト
* multiplex: リクエストとレスポンスが入り乱れてもよい。プロトコルオーバーヘッドがある
* tokio-thriftは未対応

===

# Tokioの利点
-------------

* service: サーバとクライアント両方面倒見てくれる
  + サーバもCPUの数だけハンドラをクローンしてくれたりする
* protocol: 面倒毎が少ない(バッファ使ってくれる)
* Futureベースの非同期
* pipeline, multiplexによる多重化

===

# Tokioの欠点
-------------

* APIが不安定
  + tokio-thriftは今動かないorz
* thriftはストリーミング指向なのにバッファ使う
* Rustの痒い所に当たる
  + 返り値多相がない(`Future`を直接返せない)
  + アロケーションが必要になる
  + ダイナミックディスパッチが必要になる
  + 他言語と同水準のコスト

===

# まとめ
--------

* Thriftは広さで勝負
* コードジェネレータはビルドツールへの統合を
* IDLは既存のコードに乗っかった方が楽（上と競合）
* フレームワークを使うとみんな幸せ
* RPCはインターフェースベースであるべき
* 多重化はRPCより下のレイヤーで出来る

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>非同期処理の「その後」の話。goto、継続、限定継続、CPS、そしてコールバック地獄。</title>
      <link>/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</link>
      <pubDate>Sat, 25 Apr 2015 23:44:46 +0900</pubDate>
      
      <guid>/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 非同期処理の「その後」の話
----------------------
## goto、継続、限定継続、CPS、そしてコールバック地獄

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます
===
# 同期処理とは
-------------
通常、外部とやりとり(I/O)する時に待ち時間(ブロック)が発生する。

![sync task image](/images/sync.png)

===
# 非同期処理とは
---------------
待ち時間に(ブロックせずに)別の処理をしようという発想。

![async task image](/images/async.png)
===
# 非同期処理の裏側
-----------------
処理Aと処理Bの他にいつどっちを動かすかを決めるスケジューラが存在することが多い

![async scheduler image](/images/async_scheduler.png)

===
# どうやって戻る問題
-------------------
* 一時停止した後「その後」の処理にどうやって戻るか

![cont image](/images/cont.png)
===
# 「その後」とは
-----------
```C
...
fputc(c); // ここの処理でI/Oが入る
// 再開する時にここに戻ってきたい
printf(&#34;Work done&#34;);
...
```
===
# GOTO
------
`goto` を使えば戻れる
```C
...
  fputc(c); // ここの処理でI/Oが入る
  // 再開する時にここに戻ってきたい
RESTART:
  printf(&#34;Work done&#34;);
...
```
===
# GOTOの問題
------------
こういうコードだとGOTOでは困る

```C
if ((c = fgetc(f)) != -1)
...
```

===
# GOTOの問題
------------
こんな区切り方をしたい

![cont in code image](/images/codecont.png)

===
# GOTOの問題
------------

* 式の途中に入れない
* 値を返せない
* I/Oが終わった「その後」が思ったより複雑
===
# &#34;継続&#34;という概念
-----------------

* continuation
* ここで言ってる「その後」に名前をつけたもの
* その後に行なわれる全ての処理のこと
* 全ての言語に存在する

===
# (限定)継続を値として扱える言語
------------------------------
値としての継続はちょっとリッチになったGOTO程度。

* Scheme
* OchaCaml
* SML/NJ
* (Ruby)
* etc.

===
## 正確には限定継続
------------------

* 細かい話だが継続と言うと処理Aとスケジューラ全てを含んでしまうので
今回欲しいのは処理Aの中に限定した限定継続
* 継続を値として扱えれば限定継続を[実装出来る]()ので今回はそこまで深く違いを気にする必要はない

===
## 正確には限定継続
------------------

![continuation image](/images/continuation.png)

===
## 正確には限定継続
------------------

![partcont image](/images/partcont.png)

===
# 限定継続を使った非同期処理の例
------------------------------
Cの例をSchemeに翻訳してみる

```scheme
(if (/= (read-char f) -1)
    ...)
```

===
# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```

===
# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme

  (if (/= 
                  (async-read-char f  )
          -1)
      ...)

```

===
# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(if (/= (read-char f) -1)
    ...)
```

===
# ここまでのまとめ
-----------------

* 非同期処理を行なう時に継続という概念が出てくる
* 継続を値として扱える言語もある
* 値としての継続は1引数関数として振る舞う
* そのような言語ではユーザレベルで非同期処理をサポート出来る

===
# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 先に言ったように全ての言語に継続が存在する
  * マシン語レベルでjump命令とほぼ同じ
* 言語処理系レベルで継続を取り出せば使える
* 要は組込み機能

===
# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 処理系にそこまで求めるのは酷
  * バグり易い
  * デバッグし辛い
* 処理系はもっと別のことに専念すべき
* 機能が追加修正される度に処理系をアップグレードしないといけない

実は継続を値として扱えない言語でもユーザレベルで継続を値として取り出す方法がある

===
## Continuation Passing Style

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# CPS
-----

* 日本語にすると「継続渡し形式」
* 継続を関数として切り出して引数に渡す
  * 継続のために全ての関数の引数が1つ増える
* 継続渡し形式に変換することを「CPS変換という」
* CPS変換は機械的に出来る

===
# CPS変換
------------
先は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```

になった。
===
# CPS変換
------------
今回は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(async-read-char f
           (lambda (c) (if (/= c -1) ...)))
```

になる

===
# CPS変換
---------

* パっと見限定継続のコードの`lambda`の外側と内側が入れ替わる
* そんなり分かりやすくない

===
# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n)
  (if (&lt;= n 1)
      1
      (* n (fact (- n 1)))))
```

===
# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n c)
  (if (&lt;= n 1)
      (c 1)
      (fact (- n 1) (lambda (c) (* n c)))))
```
===
# CPS変換まとめ
--------------

* とりあえず機械的に変換できる
  + 実際、CPS変換をサポートする言語はいくつかある
    - Haskellのdo記法とか
* むしろ機械がやるべきで人間がやることではない

===
# コールバック地獄の正体

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも
```javascript
async_read_char(f, function(c){
    if(c === -1) {
        ...
    }
})

```

===
# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも
```javascript
function fact(n, callback) {
    if(n &lt;= 1)
        return callback(n);
    else
        return fact(n - 1, function(c){return n * c;})
}
```

===
# コールバック地獄の正体
-----------------------

* 人間が手でやることではない&#34;CPS変換&#34;を手でやらせた結果
* altJSは内部でCPS変換を行なうことで非同期プロミスなどを実現している
  + DeNAのJSXとか
===
# 非同期処理の実装まとめ
------------------------
下に行く程抽象度/汎用性が高い

* コールバックスタイル
  + JavaScript(&lt; ES6)とか
* 言語レベル組み込みサポート
  + C#とか
* 言語レベルCPS変換サポート
  + altJSとか
* 言語レベル(限定)継続サポート
  + Schemeとか
* ユーザーレベルでも限定継続(CPS変換)を実現出来るエレガントなマクロサポート
  * Lisp

※ネタです。マサカリ投げないで下さい。

===
# まとめ: なぜコールバック&#34;地獄&#34;なのか
------------------------------------

* そもそも難しいことをやろうとしている
* 難しいことをカバーするだけの言語の機能が足りてない

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>