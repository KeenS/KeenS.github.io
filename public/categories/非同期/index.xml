<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>非同期 on κeenのHappy Hacκing Blog</title>
    <link>/categories/%E9%9D%9E%E5%90%8C%E6%9C%9F/index.xml</link>
    <description>Recent content in 非同期 on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/%E9%9D%9E%E5%90%8C%E6%9C%9F/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ステートマシン抽象化としてのFuture</title>
      <link>/blog/2017/07/02/sute_tomashinchuushoukatoshitenofuture</link>
      <pubDate>Sun, 02 Jul 2017 12:31:07 +0900</pubDate>
      
      <guid>/blog/2017/07/02/sute_tomashinchuushoukatoshitenofuture</guid>
      <description>&lt;p&gt;κeenです。最近Futureと一口にいってもいくつか種類があるなと気付いたのでRustの&lt;a href=&#34;https://github.com/alexcrichton/futures-rs&#34;&gt;&lt;code&gt;futures-rs&lt;/code&gt;&lt;/a&gt;に実装されているFutureの挙動を紐解こうと思います。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;イベント駆動io&#34;&gt;イベント駆動IO&lt;/h1&gt;

&lt;p&gt;TCPサーバをノンブロッキングに書こうとすると、思いの他大変です。
ブロックせずにIOできるタイミングまで処理を溜めておいて、できるときに読み書きします。ブロックしないタイミングをみつけるのも一苦労なので大抵ライブラリに頼ってライブラリからイベントを通知してもらいます。Rustには&lt;a href=&#34;https://github.com/carllerche/mio&#34;&gt;mio&lt;/a&gt;というライブラリがあります。&lt;/p&gt;

&lt;p&gt;さて、これイベントの発見は書かなくてよくなりましたが、まだつらいです。リクエストがないのにレスポンスを返せる訳もないので処理とイベントに依存関係があって、「read readyイベントでデータを読み取って、足りれば処理開始、足りなければまだ読み取る。処理が終わればwrite readyイベントを待って書き込み。その後は次のリクエストに備えてread readyイベント待ち」などの複雑な条件分岐と処理をしなければなりません。しかもクライアントは1つじゃないのでそれらを複数管理しないといけません。やりきれませんね。私が昔書いた&lt;a href=&#34;https://github.com/KeenS/chat/blob/master/src/handler.rs#L32&#34;&gt;Websocketのechoサーバ&lt;/a&gt;を少し見ると大変そうなことが伝わると思います。（余談ですが、つらそうなコードを書いたのは抽象化ライブラリに頼らないコードを実感するためでした）&lt;/p&gt;

&lt;h1 id=&#34;ステートマシン&#34;&gt;ステートマシン&lt;/h1&gt;

&lt;p&gt;先程の複雑な条件分岐の例は、「ステート」があることに気付きます。「リクエストがまだ来てない」「リクエストの一部が届いたけど全部でない」「リクエストの処理中」「レスポンスの送信待ち」など。これを明確に「ステート」としてプログラムを書いてあげると綺麗に書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[リクエストがまだ来てない]&amp;lt;----------------+
  | read ready                            |
  +------------------------------------+  |
  |                                    |  |
[リクエストの一部がきたが全部でない]&amp;lt;-+  |  |
  | read ready                      |  |  |
  +---------------------------------+  |  |
  |                                    |  |
[リクエストの処理中]&amp;lt;-------------------+  |
  |                                       |
[レスポンスの書き出し待ち]                 |
  | write ready                           |
[レスポンスの書き出し完了]-----------------+

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このステートマシンを図に書く範囲では明瞭なのですが、実際のプログラムに落とすとやや見通しが悪いです。&lt;/p&gt;

&lt;p&gt;ナイーブな実装を疑似コードで書くとこうなるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum State = リクエストがまだ来てない
           | リクエストの一部がきたが全部でない
           | リクエストの処理中
           | レスポンスの書き出し待ち
           | レスポンスの書き出し完了

event arrived
  case (state, event)
    when (リクエストがまだ来てない, read ready)
      ...
      if request is complete
        state &amp;lt;- リクエストの処理中
        wait for write ready
      else
        state &amp;lt;- リクエストの一部がきたが全部でない
        wait for read ready
    when リクエストの一部がきたが全部でない
      ...
      if request is complete
        state &amp;lt;- リクエストの処理中
        wait for write ready
      else
        state &amp;lt;- リクエストの一部がきたが全部でない
        wait for read ready
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モデリングは上手くいっているものの実際のコードに落とすとみづらいですね。
ナイーブな実装方法の他に、デザインパターンのステートパターンを使う手もあります。まあ、そのまんまですね。
疑似コードにするとこうなるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;abstract class State
  method do returns (State, Event)

class リクエストがまだ来てないState
  method do returns (State, Event)
      ...
      if request is complete
        return (new リクエストの処理中State, write ready)
      else
        return (new リクエストの一部がきたが全部でないState, read ready)

class リクエストの一部がきたが全部でない
  method do returns (State, Event)
      ...
      if request is complete
        return (new リクエストの処理中State, write ready)
      else
        return (new リクエストの一部がきたが全部でないState, read ready)

event arrived
  if event equals waiting_event
    (next_state, waiting_event) &amp;lt;- state.do()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ステートと処理のかたまりで分離することができたのでコードの見通しもよくなりました。&lt;/p&gt;

&lt;p&gt;しかし、Rust的にはまだ問題があります。Stateのサブクラスでモデリングしてますが、それだとメソッドのディスパッチが動的ディスパッチになってしまって遅いです。Zero-cost abstractionできてません。&lt;/p&gt;

&lt;p&gt;もう1つ問題があって、これでもまだ直感的なコードとはかけ離れてます。本来ならこういうコードを書きたい筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request &amp;lt;- empty
until request is complete
  request &amp;lt;&amp;lt; input
response &amp;lt;- // do something with request
output &amp;lt;&amp;lt; response
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをどうにかできないでしょうか。&lt;/p&gt;

&lt;h1 id=&#34;future&#34;&gt;Future&lt;/h1&gt;

&lt;p&gt;そこでfutures-rsです。ゼロコストでステートマシンを抽象化してくれます。&lt;a href=&#34;https://aturon.github.io/blog/2016/08/11/futures/&#34;&gt;Zero-cost futures in Rust · Aaron Turon&lt;/a&gt;を読んだことのある人も多いでしょう。&lt;/p&gt;

&lt;p&gt;基本的なアイディアは、1つのステートとその時の処理を表わす&lt;code&gt;Future&lt;/code&gt;の他にステート同士を繋げるコンビネータを用意することで柔軟にプログラムを書けるようにするということです。そしてステートの処理関数が静的ディスパッチされるようにコンビネータを工夫する（基本的には型パラメータに情報を残して静的ディスパッチできるようにする）ことでゼロコスト抽象化を実現しています。&lt;/p&gt;

&lt;p&gt;先程のコードをfuturesを使って書くとこのような雰囲気になるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let f = loop_fn(Vec::new(), |mut buff| {
    input.read()
      .and_then(|data| {
        buff.append(data);
        match Request::parse(buff) {
          Ok(request) =&amp;gt; Ok(Loop::Break(request))
          Err(_) =&amp;gt; Ok(Loop::Continue((buff)))
        }
      })
  }).and_then(|request| {
    // do something with request
  }).and_then(|response| {
    output.write(response)
  });

run(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ダイレクトなコードに比べるとまだノイズが多いですが、ステートマシンを陽に作るコードよりは直感的になったと思います。&lt;/p&gt;

&lt;h1 id=&#34;他のfutureとの違い&#34;&gt;他のFutureとの違い&lt;/h1&gt;

&lt;p&gt;futuers-rsのFutureは1イベント起きる度に(&lt;a href=&#34;https://docs.rs/futures/0.1.14/futures/future/trait.Future.html#tymethod.poll&#34;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;が呼ばれてReadyになる度に)次のステートの処理をし、その次のステートに移るという流れが基本です。
次のステートに移っても、即座にそののステートの処理が走る訳ではありません。次に&lt;code&gt;poll&lt;/code&gt;が呼ばれるまで処理をしません。つまりマルチスレッドの文脈で語ると、イベントが発火したスレッド &lt;em&gt;ではなく&lt;/em&gt; &lt;code&gt;poll&lt;/code&gt;を呼んだスレッド、おおむね &lt;strong&gt;Futureを所有しているスレッドで処理が走ります&lt;/strong&gt; 。Futureの処理がスレッドを飛び越えたりはしません。ある1つのFutureを別スレッドで計算したければ&lt;a href=&#34;https://github.com/alexcrichton/futures-rs/tree/master/futures-cpupool&#34;&gt;CPU Pool&lt;/a&gt;などが使えますが、その後（&lt;a href=&#34;https://docs.rs/futures-cpupool/0.1.5/futures_cpupool/struct.CpuPool.html#method.spawn&#34;&gt;spawn&lt;/a&gt;の返り値の新たなFuture）に続けた処理は今のスレッドで実行されます。&lt;/p&gt;

&lt;p&gt;一方他のFutureはほぼマルチスレッドと密結合したプロミスのようになっていて、&lt;/p&gt;

&lt;p&gt;1 Future = 別スレッドで実行される計算への先物。
コンビネータ(callback) = 別スレッドで実行される計算が終わったあとに同じスレッドで実行されるべき計算&lt;/p&gt;

&lt;p&gt;のようなものが多い印象です。要は1つ処理が終わるとそのまま次の処理、その次の処理と自動で発火していく。もちろん、ライブラリの作りによってスレッドとの関係性などにバリエーションはあるでしょうが、Rustのように&lt;a href=&#34;https://docs.rs/futures/0.1.14/futures/future/trait.Future.html#tymethod.poll&#34;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;を基本とした設計はあまりみません。&lt;/p&gt;

&lt;p&gt;このようにFutureにも色々あるうち、Rustでメジャーに使われているfutures-rsの&lt;code&gt;Future&lt;/code&gt;はステートマシンの抽象化になっているよ、というお話でした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>非同期とノンブロッキングとあと何か</title>
      <link>/blog/2017/05/19/hidoukitononburokkingutoatonanika</link>
      <pubDate>Fri, 19 May 2017 20:51:46 +0900</pubDate>
      
      <guid>/blog/2017/05/19/hidoukitononburokkingutoatonanika</guid>
      <description>&lt;p&gt;κeenです。最近同期/非同期、ブロッキング/ノンブロッキング、直接形式/継続渡し形式あたりが混乱してきたので個人的に整理します。
あくまで私個人の理解を纏めただけなので誤謬などに注意して下さい。&lt;/p&gt;

&lt;p&gt;追記: &lt;a href=&#34;https://twitter.com/tanaka_akr&#34;&gt;@tanaka_akr&lt;/a&gt;さんから&lt;a href=&#34;https://twitter.com/tanaka_akr/status/865722507281580032&#34;&gt;指摘&lt;/a&gt;されたのですが、用語の説明が間違っていそうだったので書き直しました。
diffは&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/commit/d46dad5282436eeaa615f31c160f892e6c724403&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;非同期とノンブロッキングはよく混同されます。また、非同期処理の記述形式として直接形式や継続渡し形式などがあります。
私自身違う言葉だなとは思いつつも混同したり違いを忘れたりしています。
非同期もノンブロッキングもナイーブなIOに比べると速い方式だな程度の理解でいてそんなに困らないと思ってますし混同や誤用に目くじらを立てるつもりもありません。
しかしながら3者を区別しないと意味を成さない文脈で3者を混同している技術を何度か見掛けたので（自分の中で）整理しようと思ったのがこの記事を書こうと思ったきっかけです。&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;p&gt;色々と調べましたが、&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html&#34;&gt;The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition&lt;/a&gt;の定義を使います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_77&#34;&gt;ブロッキング&lt;/a&gt;:
IO操作で、操作する前に待ちが発生するという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_240&#34;&gt;ノンブロッキング&lt;/a&gt;:
IO操作で、操作する前に待ちが発生しそうなら即座に関数から返るという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_378&#34;&gt;同期&lt;/a&gt;:
IO操作で、操作が終わるまでブロックするという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_29&#34;&gt;非同期&lt;/a&gt;:
IO操作で、IO操作を発効したスレッド自体がブロックせずに別のCPU処理を行えるという性質&lt;/li&gt;
&lt;li&gt;IOの多重化: 複数のfdに対して監視を行ない、ブロックせずに操作可能なfdを通知する仕組み。
調べると「複数のfdに対してブロックできる」という記述があるのですがノンブロッキングなオプションもありますよね&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらはどのようにIOを行うかの問題で、 &lt;strong&gt;実行時&lt;/strong&gt; に関係する話題です。&lt;/p&gt;

&lt;p&gt;次に、直接形式と継続渡し形式について。非同期やノンブロッキングなIOをしようと思うと後続の処理、すなわち（限定）継続が必要になる。この（限定）継続をプログラマがどのように渡すかの問題。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Direct_style&#34;&gt;直接形式&lt;/a&gt;は（限定）継続がプログラムには陽には現れず、コンパイラが頑張るかコルーチンなどの言語機能、&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;などの構文を用いて実現されます。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Continuation-passing_style&#34;&gt;継続渡し形式&lt;/a&gt;(CPS)はプログラマが陽に（限定）継続を渡すスタイルで、コールバック形式などとも呼ばれます。&lt;/p&gt;

&lt;p&gt;これらは主に言語の問題で、 &lt;strong&gt;コンパイル時&lt;/strong&gt; に関係する話題です。
よく直接形式と同期処理が混同されて「同期プログラミングをすることで非同期プログラミングができます」などの矛盾した一文が書かれがちですが区別しましょう。&lt;/p&gt;

&lt;h2 id=&#34;誰が何を&#34;&gt;誰が何を&lt;/h2&gt;

&lt;p&gt;IO処理の話題はスレッドとカーネルとのやりとりに関することが多い気がしますが、Goのようにユーザランドで実行単位を持つと「ブロックする」といったときにスレッドがブロックするのかgoroutineがブロックするのか分かりづらいですね。
なのでこれ以後は誰が何をブロックするのかを出来る限り明示しながら書きたいと思います。例えば「カーネルがgoroutine Aを実行しているスレッドをブロックする」など。&lt;/p&gt;

&lt;h1 id=&#34;scala&#34;&gt;Scala&lt;/h1&gt;

&lt;p&gt;前職でScalaを書いていました。
Scalaの&lt;code&gt;Future&lt;/code&gt;そのものは&lt;code&gt;flatMap&lt;/code&gt;が関数をとるので継続渡し形式ですが、そのシンタックスシュガーの&lt;code&gt;for&lt;/code&gt;式は直接形式でプログラミングができます。
IOの実体についてはFutureで抽象化されているのでexecutorによります。&lt;/p&gt;

&lt;h1 id=&#34;go&#34;&gt;Go&lt;/h1&gt;

&lt;p&gt;前職の新卒研修で5日ほどGoを書いたことがあります。
多くの言語は比較的シンプルなIOモデルを持つので用語を意識しなくても問題ありませんが、Goは実行時に色々工夫しているので用語をちゃんと区別しないと齟齬が出るようです。
なのでGoを例に理解を深めようと思います。&lt;/p&gt;

&lt;p&gt;まず、Goは実行時に動作するコンポーネントが多いので整理します。
&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;ここの質問&lt;/a&gt;への回答によるとgoroutine実行用のスレッド、スケジューラ、GCに大別してよさそうです。
このうち、IOに関連するのはgoroutine実行用のスレッドとスケジューラなのでGCについては触れません。
あまりよく分かってないのですがスケジューラはgoroutine実行用のスレッド上で呼ばれるための関数（群）なんですかね。&lt;/p&gt;

&lt;p&gt;普段は1スレッドが複数のgoroutineの実行を受け持ち、goroutineが何かしらの理由でブロックしそうなタイミングで別のgoroutineにコンテキストスイッチするようです。
ブロックしそうなタイミングというのはやや古いですが&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;ここ&lt;/a&gt;に書かれてます。
直接形式で書きつつコンテキストスイッチをするということはどうにかして(限定)継続を取り出す必要がありますが、それこそgoroutineですね。goroutine自身でスタックを持つようですし。
C関数を呼ぶときなどはコンパイラが裏で呼び出す前と後に分割しているようです。&lt;/p&gt;

&lt;p&gt;さて、IOについてはファイルIOとネットワークIOで操作が異なるようです。&lt;/p&gt;

&lt;p&gt;ファイルIOでは普通に同期/ブロッキングなシステムコールを発効し、OSがスレッドをブロックする時間が長いようなら別スレッドで元スレッドの持っていたgoroutineを実行するようです。
信頼できる情報が出てこなかったのですが自身で長くなりそうと思っているシステムコールの場合はgoroutineの実行権限（プロセス）を手放してあとは他のプロセスがstealするに任せてる？
ファイルIOは、スレッドがシステムコールでブロックし同期的で、goroutineもシステムコールでブロックし同期的です。ただスケジューラのお陰で他のgoroutineに迷惑がかからないだけです。&lt;/p&gt;

&lt;p&gt;ネットワークIOはポーリングを行なうようです。
スケジューラがfinbrunnableする中でブロックしない方のpoll(Linuxだとepollにノンブロッキングオプションつけたやつかな？)を呼んで、操作可能なfdがあればそれを待っているgoroutineを起こしている模様。
であれば上の分類に従うとネットワークIOはスレッドはブロックせず同期的でIOを多重化し、goroutineはスケジューラからブロックされ同期的で（特別に関数を呼ばなければ）IOの多重化もしません。ただ、操作可能なfdに操作しているのでgoroutineはカーネルからはブロックされません。&lt;/p&gt;

&lt;p&gt;この他にもgoroutine同士のコミュニケーションにチャネルがあります。そこまで重要じゃないかなと思って詳しく調べてないので間違いがあるかもしれないです。
チャネルへの操作は同期的ですね。チャネルへのread/writeはバッファがempty/fullだったらブロックするようなのでgoroutineはチャネルへの操作でブロックします。調べてないですが普通スレッドはブロックしないでしょう。&lt;/p&gt;

&lt;p&gt;チャネルへのselectはあまり情報が出てこなかったのですが恐らくスケジューラがIO可能なチャネルを調べて1つでもあればそれからランダムに選ぶ、1つもなくdefaultもなければスケジューラがgoroutineをブロックするんだと思います。
同期的でIOの多重化をしていますね。&lt;/p&gt;

&lt;p&gt;Goroutineやスレッドレベルでは同期的ですが、Goのプロセス全体でみるとGOMAXPROC分のスレッドは常にCPUを使っているので非同期なんですかね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Goの件について表にするとこうですかね。非同期処理をやろうと思ったら大抵処理単位を分ける必要がありますが、Goの最小処理単位がgoroutineなのでよく考えたらgoroutineが全て同期するのはあたりまえですね。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;スレッド&lt;/th&gt;
&lt;th&gt;goroutine&lt;/th&gt;
&lt;th&gt;Goプロセス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ファイル&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;非同期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ネットワーク&lt;/td&gt;
&lt;td&gt;ノンブロック/同期/多重化&lt;/td&gt;
&lt;td&gt;ノンブロック/同期/&lt;/td&gt;
&lt;td&gt;非同期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルRW&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルselect&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/同期/多重化&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ということでGoのIOについては「goroutineを直接形式で同期的な書き方をしても裏でスケジューラが動いているからCPUを効率的に使えてGoプロセス全体でみれば非同期」になるんですかね。&lt;/p&gt;

&lt;p&gt;Goに詳しい人、コメントや誤り訂正お願いします。&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/issues&#34;&gt;GitHubのイシュー&lt;/a&gt;とか使えば良い気がします。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/36112445/golang-blocking-and-non-blocking&#34;&gt;multithreading - Golang blocking and non blocking - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/os/file_unix.go?s=#L224&#34;&gt;src/os/file_unix.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/proc.go?s=#L1795&#34;&gt;src/runtime/proc.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/faq#goroutines&#34;&gt;Frequently Asked Questions (FAQ) - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;channel - go routine blocking the others one - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/cgocall.go&#34;&gt;src/runtime/cgocall.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/32538438/how-does-channel-blocking-work-in-go&#34;&gt;select - How does channel blocking work in Go? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/ref/spec#Select_statements&#34;&gt;The Go Programming Language Specification - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;How does the Go runtime work? - Quora&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustで非同期Thriftしたい</title>
      <link>/slide/RustdehidoukiThriftshitai/</link>
      <pubDate>Sat, 26 Nov 2016 13:07:29 +0900</pubDate>
      
      <guid>/slide/RustdehidoukiThriftshitai/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Rustで非同期Thrift
----------------------
[歌舞伎座.tech#12「メッセージフォーマット/RPC勉強会」 - connpass](https://kbkz.connpass.com/event/40629/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * サイバーエージェントのエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

* &lt;span style=&#34;font-size:150%&#34;&gt;X&lt;/span&gt; RPCライブラリを使う話
* &lt;span style=&#34;font-size:150%&#34;&gt;O&lt;/span&gt; RPCライブラリを作る話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# RPC
-----

* Remote Procedure Call
* リモートで呼べる
* 言語跨げる
* シリアライズフォーマットが決まれば大体出来る
* Thrift, protobuf/gRPC, avro...
* 大抵バイナリ
  + JSONに比べて2倍くらい効率がいい

===

# Thrift
--------

* Facebook発(現apache)RPCフレームワーク
* IDLから複数の言語向けのコードを吐ける
* 対応言語多い
* 新しい言語はthriftレポジトリフォークして追加

===

# Thrift vs gRPC
----------------

\                       | Thrift | gRPC
------------------------|:------:|:----:
ベース                  | 自前   | HTTP/2
コード生成              | o      | o
プロトコルのアップデート | o      | o
通信の多重化            | トランスポート次第  | o (HTTP/2)
認証                    | x  | o
例外                    | ユーザ定義可能 | 事前定義のみ?
対応言語                | 多い   | ほどほど
その他                  | union  | timestamp, anyなど
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;

===

# 何故Thrift?
-------------

* 仕事で使ってたから
* 仕事は「gRPCかthrift、まあthriftでいっしょ」で決まった

===

# RustとThrift
--------------
いくつか実装がある

===

## [sgnr/rust-thrift](https://github.com/sgnr/rust-thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![sgnr/rust-thrift is deprecated](/images/thrift/sgnr-rust-thrift.png)

===

## [maximg/thrift](https://github.com/maximg/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![maximg/thrift is deprecated](/images/thrift/maximg-thrift.png)

===

## [terminalcloud/thrift](https://github.com/terminalcloud/thrift)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

![terminalcloud/thrift is deprecated](/images/thrift/terminalcloud.png)

===

# [thehydroimpulse/thrust](https://github.com/thehydroimpulse/thrust)
---------------------------

* Thrift RPC in Rust (Async I/O)
* 非同期!!
* apache/thriftベースじゃない（フルスクラッチ）
* コンパイラプラグインサポートとかも
* 作りかけ
  + `Latest commit 0a37b77 on 11 Apr`

→ フォークすることに

===

# [Finagle](https://github.com/twitter/finagle)
---------

* **Scalaの** RPCフレームワーク
* [You Server as a Function](https://monkey.org/~marius/funsrv.pdf)
* Nettyベース
* サーバとクライアント両方サポート
* Twitter製
* 良くも悪くもTwitterべったり

===

# Finagle Client
--------

* クライアントが賢い
* RPCではTCPベースのLBが使えない
  + クライアントはコネクション張りっぱなし
* クライアントサイドロードバランシングが必要
* Finagleはそこまでカバー
* 他にもエラーが起きたサーバ外したり色々

===

# Tokio
--------

* **Rustの** RPCフレームワーク
* mioベース
* Finagleを参考に開発
  + **開発中**
* tokio-core
  + コア部分
* tokio-proto
  + プロトコル実装のサポート
  + 絶賛API変更中
* tokio-service
  + サービス実装のサポート


===

# TokioとFinagle
-----------------

  \           | Tokio       | Finagle
--------------|:-----------:|:-------:
コア          | [tokio-core](https://github.com/tokio-rs/tokio-core) | [finagle-core](https://github.com/twitter/finagle/tree/develop/finagle-core)
Future        | [future](https://github.com/alexcrichton/futures-rs) | [twitter util](https://github.com/twitter/util)
非同期エンジン | [mio](https://github.com/carllerche/mio) | [netty](http://netty.io/)
&lt;!-- .element: style=&#34; margin-right:auto; margin-left:auto&#34;--&gt;


===

# [mio](https://github.com/carllerche/mio)
------

* 非同期イベントループライブラリ
* イベントドリブン
* ループ内ゼロアロケーション
* `epoll` などの薄いラッパ
* libuv, libevent, libev2などのRust版
* ソケットだけでなく *ファイルIO* 、インメモリチャネルとかも監視出来る

===

# [future](https://github.com/alexcrichton/futures-rs)
--------------

* [Zero-cost futures in Rust · Aaron Turon](https://aturon.github.io/blog/2016/08/11/futures/)
* ゼロコスト
* 普通にFutureを使うとランタイムにステートマシンになる
* 「将来実行される」という「状態」を第一級の値として表現する大事な手段
* お型付けは大変
    + `map` したら `Map&lt;A, fn (A)-&gt;B&gt;` の型が返ったり
* ストリーミング指向のAPIもある

===

# [tokio-core](https://github.com/tokio-rs/tokio-core)
--------------

* 非同期IOのフレームワーク
* Futureベース
* フレームドIOとストリーミングIO
* フレームワークというよりユーティリティ？
  + mioとfutureを合わせて使う

===

# [tokio-proto](https://github.com/tokio-rs/tokio-proto)
-------------

* 主にバイナリ列&lt;-&gt;構造体の部分の面倒を見てくれる
* API変更中…
* バッファリングしてパースしやすくしてくれる
* プロトコルの多重化やってくれる(後述)

===

# [tokio-service](https://github.com/tokio-rs/tokio-service)
-----------------

* タスクサーバの面倒見てくれる
* 主にロードバランシング


===

# [Service](https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html)
-------------

``` rust
pub trait Service {
    type Request;
    type Response;
    type Error;
    type Future: Future&lt;Item=Self::Response, Error=Self::Error&gt;;
    fn call(&amp;self, req: Self::Request) -&gt; Self::Future;
}
```

===

# Service
----------

* いわゆるハンドラ
* インターフェースさえ満たせばいい
  + ミドルウェアもハンドラも同じ扱い

===

# [NewService](https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html)
--------------

```rust
pub trait NewService {
    type Request;
    type Response;
    type Error;
    type Instance: Service&lt;Request=Self::Request, Response=Self::Response, Error=Self::Error&gt;;
    fn new_service(&amp;self) -&gt; Result&lt;Self::Instance&gt;;
}

impl&lt;F, R&gt; NewService for F where F: Fn() -&gt; Result&lt;R&gt;, R: Service
```

===

# NewService
------------

* いわゆるAbstractServiceFactory的な存在
* コア数に応じてサービスを作ってくれる
* ただし`Service`を返す普通の関数も`NewService`になる
* [example](https://github.com/tokio-rs/tokio-line/blob/master/examples/echo_client_server.rs#L21)


===

# tokio-thrift
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# [tokio-thrift](https://github.com/KeenS/tokio-thrift)
--------------

* [KeenS/tokio-thrift](https://github.com/KeenS/tokio-thrift)
* この発表のために作った（作ってる）
* tokioベースのrustのthriftサポート
* thrustのフォーク
* 基本ツール全て
  + コードジェネレータ
  + コンパイラプラグイン
  + ランタイムライブラリ

===

# プロトコルスタック
-------------------

ユーザは実装に集中出来る仕組み

```
+------------------------------------------------+
| service   | tokio-service + 生成コード + ユーザ |
|------------------------------------------------|
| protocol  | tokio-proto   + tokio-thrift       |
|------------------------------------------------|
| transport | tokio-core                         |
+------------------------------------------------+
```

===

# サンプルコード
----------------

* [これ](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/main.rs)

===

# ユーザビリティ
---------------

* サーバ: ユーザはインターフェースに沿ったコードを書くだけ
* クライアント: インターフェース通りに呼べる
* 返り値はFuture
* サーバ: 非同期実装と相性がいい
* クライアント: 非同期通信をそのままエンコード

===

# 実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# Thriftのプロトコル
-------------------

* 現状binary protocolのみ
  + fork元が実装してあった
* compactとか需要ある？
* 因みにJSONはやめとけ

===

# 所有権とゼロコピー
-------------------

* プロトコルのパースの部分の話
* Rustっぽい部分
* バッファの所有権をパース結果に渡すことでデータのコピーを避ける

===

# 所有権とゼロコピー
-------------------
バッファをresultにパースして

```
buffer
  |
+-+---------------+
|                 |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 所有権とゼロコピー
-------------------
resultにデータの所有権を渡してしまう

```
 result   buffer
   |        |
+--+----++--+-----+
|       ||        |
-------------------
| | | | | ... | | | &lt;- バイト列
-------------------
```

===

# 複数メソッド
-------------

* 複数メソッドだと複数の引数/返値の型を扱う
* コネクションのハンドラは1つ
* 複数型をどうやって扱う？
  + [enumを定義](https://github.com/KeenS/tokio-thrift/blob/master/example/simple_server_client/src/thrift.rs#L67)
  + ゼロオーバーヘッド…

===

# 複数メソッド
-------------

```
 (methodA) (methodB)
     |         |
     +----+----+
          | &lt;----- enum化
      [client]
          |
      [server]
          | &lt;----- enumでディスパッチ
     +----+-----+
     |          |
(handlerA) (handlerB)
```

===

# つらい話
-----------------

* Thrift IDLのセマンティクスが書いてない
  + throws節のフィールドは直積？直和？
  + Javaで生成してみて推測するしかない
* フォークライブラリの実装が不完全
  + パーサはフルスクラッチで書き直した
  + [パーサコンビネータ便利](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-codegen/src/parser.rs#L517)
  + フォークした意味…
* Rustにエンコード出来ないthriftの機能もある
  + mapの定数は普通には無理
  + エラーどうしよう(`Error`トレイトの実装とEnum)
* 所有権の問題

===

# 言語との統合
-------------

* Rustには公式のシリアライズフレームワークがある
* [rustc-serialize](https://github.com/rust-lang-nursery/rustc-serialize)
* あるいはユーザ側のも
* [serde](https://github.com/serde-rs/serde)
* のっかりたいけどThriftに必要なデータがない
  + フィールドのシーケンス番号とか
* 今のところ自動生成に頼る
  + フレームワークにフィードバックした方がいい？

===

# コード生成の話
---------------

* [コンパイラプラグイン](https://github.com/KeenS/tokio-thrift/blob/master/tokio-thrift-macros/tests/service.rs#L10)微妙
  + 定義元ジャンプ、フィールド名補完などに難
* CLI生成は悪手
  + IDL変更する度CLI実行？
  + 生成コードはコミット？
    - CLIのバージョンがあるので基本はコミット。でも…
* ビルドツール統合が最良
  + FinagleにはScoogeがある
  + tokio-thriftでもやりたい
    - build.rsのサポート

===

# 多重化の話
------------

* 生のthrift on TCPだと通信を多重化出来ない
* tokio-proto側でpipelineやmultiplexなどをサポート
* pipeline: レスポンスを待たずに次のリクエスト
* multiplex: リクエストとレスポンスが入り乱れてもよい。プロトコルオーバーヘッドがある
* tokio-thriftは未対応

===

# Tokioの利点
-------------

* service: サーバとクライアント両方面倒見てくれる
  + サーバもCPUの数だけハンドラをクローンしてくれたりする
* protocol: 面倒毎が少ない(バッファ使ってくれる)
* Futureベースの非同期
* pipeline, multiplexによる多重化

===

# Tokioの欠点
-------------

* APIが不安定
  + tokio-thriftは今動かないorz
* thriftはストリーミング指向なのにバッファ使う
* Rustの痒い所に当たる
  + 返り値多相がない(`Future`を直接返せない)
  + アロケーションが必要になる
  + ダイナミックディスパッチが必要になる
  + 他言語と同水準のコスト

===

# まとめ
--------

* Thriftは広さで勝負
* コードジェネレータはビルドツールへの統合を
* IDLは既存のコードに乗っかった方が楽（上と競合）
* フレームワークを使うとみんな幸せ
* RPCはインターフェースベースであるべき
* 多重化はRPCより下のレイヤーで出来る

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>非同期処理の「その後」の話。goto、継続、限定継続、CPS、そしてコールバック地獄。</title>
      <link>/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</link>
      <pubDate>Sat, 25 Apr 2015 23:44:46 +0900</pubDate>
      
      <guid>/slide/hidoukishorino_sononochi_nohanashi_goto_keizoku_genteikeizoku_CPS_soshiteko_rubakkujigoku_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 非同期処理の「その後」の話
----------------------
## goto、継続、限定継続、CPS、そしてコールバック地獄

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます
===
# 同期処理とは
-------------
通常、外部とやりとり(I/O)する時に待ち時間(ブロック)が発生する。

![sync task image](/images/sync.png)

===
# 非同期処理とは
---------------
待ち時間に(ブロックせずに)別の処理をしようという発想。

![async task image](/images/async.png)
===
# 非同期処理の裏側
-----------------
処理Aと処理Bの他にいつどっちを動かすかを決めるスケジューラが存在することが多い

![async scheduler image](/images/async_scheduler.png)

===
# どうやって戻る問題
-------------------
* 一時停止した後「その後」の処理にどうやって戻るか

![cont image](/images/cont.png)
===
# 「その後」とは
-----------
```C
...
fputc(c); // ここの処理でI/Oが入る
// 再開する時にここに戻ってきたい
printf(&#34;Work done&#34;);
...
```
===
# GOTO
------
`goto` を使えば戻れる
```C
...
  fputc(c); // ここの処理でI/Oが入る
  // 再開する時にここに戻ってきたい
RESTART:
  printf(&#34;Work done&#34;);
...
```
===
# GOTOの問題
------------
こういうコードだとGOTOでは困る

```C
if ((c = fgetc(f)) != -1)
...
```

===
# GOTOの問題
------------
こんな区切り方をしたい

![cont in code image](/images/codecont.png)

===
# GOTOの問題
------------

* 式の途中に入れない
* 値を返せない
* I/Oが終わった「その後」が思ったより複雑
===
# &#34;継続&#34;という概念
-----------------

* continuation
* ここで言ってる「その後」に名前をつけたもの
* その後に行なわれる全ての処理のこと
* 全ての言語に存在する

===
# (限定)継続を値として扱える言語
------------------------------
値としての継続はちょっとリッチになったGOTO程度。

* Scheme
* OchaCaml
* SML/NJ
* (Ruby)
* etc.

===
## 正確には限定継続
------------------

* 細かい話だが継続と言うと処理Aとスケジューラ全てを含んでしまうので
今回欲しいのは処理Aの中に限定した限定継続
* 継続を値として扱えれば限定継続を[実装出来る]()ので今回はそこまで深く違いを気にする必要はない

===
## 正確には限定継続
------------------

![continuation image](/images/continuation.png)

===
## 正確には限定継続
------------------

![partcont image](/images/partcont.png)

===
# 限定継続を使った非同期処理の例
------------------------------
Cの例をSchemeに翻訳してみる

```scheme
(if (/= (read-char f) -1)
    ...)
```

===
# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```

===
# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme

  (if (/= 
                  (async-read-char f  )
          -1)
      ...)

```

===
# 限定継続を使った非同期処理の例
------------------------------
`lambda`は限定継続を`k`として受け取り、関数として使える。(今回はコールバックとして使っている)  
`reset`、`shift`、`lambda`、`k`を無視すれば以前のコードと一致する。

```scheme
(if (/= (read-char f) -1)
    ...)
```

===
# ここまでのまとめ
-----------------

* 非同期処理を行なう時に継続という概念が出てくる
* 継続を値として扱える言語もある
* 値としての継続は1引数関数として振る舞う
* そのような言語ではユーザレベルで非同期処理をサポート出来る

===
# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 先に言ったように全ての言語に継続が存在する
  * マシン語レベルでjump命令とほぼ同じ
* 言語処理系レベルで継続を取り出せば使える
* 要は組込み機能

===
# 継続を値として扱えない言語での非同期処理
----------------------------------------

* 処理系にそこまで求めるのは酷
  * バグり易い
  * デバッグし辛い
* 処理系はもっと別のことに専念すべき
* 機能が追加修正される度に処理系をアップグレードしないといけない

実は継続を値として扱えない言語でもユーザレベルで継続を値として取り出す方法がある

===
## Continuation Passing Style

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# CPS
-----

* 日本語にすると「継続渡し形式」
* 継続を関数として切り出して引数に渡す
  * 継続のために全ての関数の引数が1つ増える
* 継続渡し形式に変換することを「CPS変換という」
* CPS変換は機械的に出来る

===
# CPS変換
------------
先は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(reset
  (if (/= (shift (lambda (k)
                   (async-read-char f k)))
          -1)
      ...))
```

になった。
===
# CPS変換
------------
今回は

```scheme
(if (/= (read-char f) -1)
    ...)
```

が

```scheme
(async-read-char f
           (lambda (c) (if (/= c -1) ...)))
```

になる

===
# CPS変換
---------

* パっと見限定継続のコードの`lambda`の外側と内側が入れ替わる
* そんなり分かりやすくない

===
# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n)
  (if (&lt;= n 1)
      1
      (* n (fact (- n 1)))))
```

===
# もっとCPS変換
---------------
階乗関数の例

```scheme
(define fact (n c)
  (if (&lt;= n 1)
      (c 1)
      (fact (- n 1) (lambda (c) (* n c)))))
```
===
# CPS変換まとめ
--------------

* とりあえず機械的に変換できる
  + 実際、CPS変換をサポートする言語はいくつかある
    - Haskellのdo記法とか
* むしろ機械がやるべきで人間がやることではない

===
# コールバック地獄の正体

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも
```javascript
async_read_char(f, function(c){
    if(c === -1) {
        ...
    }
})

```

===
# コールバック地獄の正体
-----------------------
先のCPS変換のコードをJSで書くと分かるかも
```javascript
function fact(n, callback) {
    if(n &lt;= 1)
        return callback(n);
    else
        return fact(n - 1, function(c){return n * c;})
}
```

===
# コールバック地獄の正体
-----------------------

* 人間が手でやることではない&#34;CPS変換&#34;を手でやらせた結果
* altJSは内部でCPS変換を行なうことで非同期プロミスなどを実現している
  + DeNAのJSXとか
===
# 非同期処理の実装まとめ
------------------------
下に行く程抽象度/汎用性が高い

* コールバックスタイル
  + JavaScript(&lt; ES6)とか
* 言語レベル組み込みサポート
  + C#とか
* 言語レベルCPS変換サポート
  + altJSとか
* 言語レベル(限定)継続サポート
  + Schemeとか
* ユーザーレベルでも限定継続(CPS変換)を実現出来るエレガントなマクロサポート
  * Lisp

※ネタです。マサカリ投げないで下さい。

===
# まとめ: なぜコールバック&#34;地獄&#34;なのか
------------------------------------

* そもそも難しいことをやろうとしている
* 難しいことをカバーするだけの言語の機能が足りてない

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>