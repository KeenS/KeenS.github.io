<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cli on κeenのHappy Hacκing Blog</title>
    <link>//KeenS.github.io/categories/cli/</link>
    <description>Recent content in Cli on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 20 Oct 2015 00:30:42 +0900</lastBuildDate>
    <atom:link href="//KeenS.github.io/categories/cli/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>REST APIのテストにはwgetが便利かもしれない</title>
      <link>//keens.github.io/blog/2015/10/20/apinotesutonihawgetgabenrikamoshirenai</link>
      <pubDate>Tue, 20 Oct 2015 00:30:42 +0900</pubDate>
      
      <guid>//keens.github.io/blog/2015/10/20/apinotesutonihawgetgabenrikamoshirenai</guid>
      <description>

&lt;p&gt;寝れずに悶々としていたので書いてみる。REST APIを叩くときはデフォルトで結果を標準出力に吐くcURLがよく使われるがテストにはwgetが向いてるかもしれない。&lt;/p&gt;

&lt;p&gt;理由は簡単。exit statusだ。シェルのテストをする時は&lt;a href=&#34;https://github.com/kward/shunit2&#34;&gt;shunit2&lt;/a&gt;を使うことになるかと思うが、exit statusでテストをしたくなる。
cURLはHTTPサーバーがエラーステータスを返してもexit status 0で終了するのに対してwgetは所定の値を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXIT STATUS
       Wget may return one of several error codes if it encounters problems.

       0   No problems occurred.

       1   Generic error code.

       2   Parse error---for instance, when parsing command-line options, the .wgetrc or .netrc...

       3   File I/O error.

       4   Network failure.

       5   SSL verification failure.

       6   Username/password authentication failure.

       7   Protocol errors.

       8   Server issued an error response.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;少し試してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sL google.com/teapot &amp;gt; /dev/null
$ echo $?
0
$ wget -qO /dev/null google.com/teapot
$ echo $?
8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと違いが出ている。余談だが &lt;code&gt;wget -O /dev/null&lt;/code&gt;は便利なので覚えておくと幸せになれる。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:67650a6fc4fa81318fe87d2796b2dbeb&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;HTTPのエラーを全部1つのステータスに纏めるのはちょっと乱暴な気がする。wgetはHTTP以外のプロトコルにも対応してるのでまあ仕方がないのだろうが。
ということで任意のHTTPレスポンスを抜き出してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sIL google.com/teapot | grep -E &#39;^HTTP/[0-9](\.[0-9])? [0-9]{3}&#39;
HTTP/1.1 301 Moved Permanently
HTTP/1.1 418 I&#39;m a Teapot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本当にstatusだけ抜き出したかったらこうだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sIL google.com/teapot | grep -E &#39;^HTTP/[0-9](\.[0-9])? [0-9]{3}&#39; | grep -o -E &#39;[0-9]{3}&#39;
301
418
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数回HTTPリクエストを飛ばしているので複数statusが返ってくるのは諦めよう。最後のやつだけ欲しければ &lt;code&gt;tail -n 1&lt;/code&gt;すればいい。&lt;/p&gt;

&lt;p&gt;HTTPの仕様を読まずに書いたのでバージョンのマッチの部分が冗長かもしれないがとりあえず動く。というかcURLを使った。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:67650a6fc4fa81318fe87d2796b2dbeb&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;cURL使おう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ddでPCの引っ越しをしたら起動しなかった</title>
      <link>//keens.github.io/blog/2015/10/05/dd_depcnohikkoshiwoshitarakidoushinakatta</link>
      <pubDate>Mon, 05 Oct 2015 21:30:06 +0900</pubDate>
      
      <guid>//keens.github.io/blog/2015/10/05/dd_depcnohikkoshiwoshitarakidoushinakatta</guid>
      <description>

&lt;p&gt;κeenです。この間長年使ってたDynabookからThink Padに乗り換えました。引っ越しの時に困ったのでメモ。&lt;/p&gt;

&lt;p&gt;元々あるのが&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dynabook&lt;/li&gt;
&lt;li&gt;外付けハードディスクカバー&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新たに購入したのが&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Think Pad (HDDモデル)&lt;/li&gt;
&lt;li&gt;SSD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SSDだけ先に手元に来たのでまずSSDへ引っ越しを済ませ、Think Padが届いたらHDDとSSDを交換することに。&lt;/p&gt;

&lt;h1 id=&#34;dynabookのhddからssdへの引っ越し:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;DynabookのHDDからSSDへの引っ越し&lt;/h1&gt;

&lt;p&gt;Ubuntuをインストールしてバックアップから復元しても良かったのですがHDDもSSDも512GBだったので&lt;code&gt;dd&lt;/code&gt;を使って引っ越ししました。&lt;/p&gt;

&lt;p&gt;事前に出来る限りプロセスは殺す。本来は別ディスクから立ち上げたOSでやるのが良いんだろうけど面倒だったので引越し対象のOSから実行しました。。コマンドはすごいシンプル。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ dd if=/dev/sda of=/dev/sdb bs=512k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外付けハードディスクカバーとDynabookがUSB2.0までにしか対応してないからか20MB/sしか出ず、一晩掛かりました。しかし終わったあとDynabookのHDDとSSDを交換して起動してみると何の問題もなく起動しました。素晴しい。&lt;/p&gt;

&lt;h1 id=&#34;ssdをthink-padに移植:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;SSDをThink Padに移植&lt;/h1&gt;

&lt;p&gt;一瞬ハードディスクの外し方が分からず苦戦するもネットで調べると分解マニュアルが出てきたので楽に換装。しかしThink Padの電源を入れても起動しなかった。&lt;/p&gt;

&lt;h1 id=&#34;biosとuefi:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;BIOSとUEFI&lt;/h1&gt;

&lt;h2 id=&#34;bios:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;BIOS&lt;/h2&gt;

&lt;p&gt;BIOSといえばコンビュータの電源をポチっと入れた瞬間に起動するソフトウェアで、Basic I/O Systemの略かと思っていましたがBasic I/O Systemの実装の1つの名前でもあるらしいです。&lt;/p&gt;

&lt;p&gt;BIOSはディスクの先頭にあるMaster Boot Recordを読みにいきます。そこからパーティションテーブルの情報を得てgrubなどを起動します。（Master Boot RecordのことをMBRと略すこともあるしMaster Boot Recordを使うパーティションテーブルのことをMBRと呼ぶこともある…？）。昔、&lt;a href=&#34;//KeenS.github.io/blog/2015/01/08/freebsd-environment-setups/&#34;&gt;GPTを使うと起動しなかった経験がある&lt;/a&gt;ので私のDynabookのBasic I/O SystemにはBIOSが使われていた模様。&lt;/p&gt;

&lt;h2 id=&#34;uefi:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;UEFI&lt;/h2&gt;

&lt;p&gt;UEFIはBIOSに代わるBasic I/O Systemらしいです。MBRの他、GPTもサポートします。GPTは &lt;strong&gt;MBR を使わず&lt;/strong&gt; 、EFI System Partitionなるものを使うらしいです。Think PadのBasic I/O Systemはこれだったようです。&lt;/p&gt;

&lt;h1 id=&#34;原因-対策-今後:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;原因、対策、今後&lt;/h1&gt;

&lt;p&gt;ということでUEFIがGPTを期待していたのにこちらはBIOS向けのMBRを用意していたのでダメだった模様。(いわゆる従来)BIOS画面(と呼ばれていたもの)に入って起動タイプをUEFIからLegacyにすることで起動出来ました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 可能ですよ。WindowsでもLinuxでもBSDでも、です。&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647688708661972992&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; gptgenなどを用いてパーティションをMBRからGPTに変換すること、FAT32のパーティションを作り(先頭パーティションであることが好ましい)パーティションタイプを0xEF00にすること、そしてブートローダーをそのパーティションにインストールする&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647692419090112512&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 以上があらましになります。FAT32のこのパーティションはEFI System Partition, ESPと呼ばれ、従来ファイルシステムから不可視な先頭セクタにインストールされていたブートローダーはただの実行ファイルとしてESPに置かれます&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647692825853755392&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; ブートローダーをESPに入れる手段としては、ArchWikiのUEFIの項をご覧ください。また、この時efibootmgrコマンドを用いてブートローダーのパスをUEFIに記録させておくと、UEFIのブートデバイス選択画面にブートローダーが出現します。&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647693202737098757&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; GRUBの場合efibootmgrコマンドを使うべき操作は自動でしてくれます。&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647693310149025792&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;とのことですがまあ、SSDの先頭のスペース空いてないしちょっとミスったら即死だしどうしましょうね。
一旦SSDの中身を元のHDDに退避してSSDにUEFIで起動するパーティション作ってそのパーティションに元のパーティションをddでコピーとかで出来ますかね…&lt;/p&gt;

&lt;p&gt;サルでも分かる操作マニュアルが欲しい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>