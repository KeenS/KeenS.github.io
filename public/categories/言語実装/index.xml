<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>言語実装 on κeenのHappy Hacκing Blog</title>
    <link>/categories/%E8%A8%80%E8%AA%9E%E5%AE%9F%E8%A3%85/index.xml</link>
    <description>Recent content in 言語実装 on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/categories/%E8%A8%80%E8%AA%9E%E5%AE%9F%E8%A3%85/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ジェネリクス勉強会補足</title>
      <link>/blog/2017/06/24/jienerikusubenkyoukaihosoku</link>
      <pubDate>Sat, 24 Jun 2017 23:22:16 +0900</pubDate>
      
      <guid>/blog/2017/06/24/jienerikusubenkyoukaihosoku</guid>
      <description>&lt;p&gt;κeenです。本日&lt;a href=&#34;https://connpass.com/event/56773/?utm_campaign=event_participate_to_owner&amp;amp;utm_source=notifications&amp;amp;utm_medium=email&amp;amp;utm_content=title_link&#34;&gt;ジェネリクス勉強会&lt;/a&gt;で発表したのですがいくつか拾いきれないコメントがあったのでここでお返事書きます&lt;/p&gt;

&lt;p&gt;発表スライドは&lt;a href=&#34;https://keens.github.io/slide/jienerikusu_disupatchi_omoteura/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;ジェネリクスの実装はポインタ方式とテンプレート方式だけじゃないよ&#34;&gt;ジェネリクスの実装はポインタ方式とテンプレート方式だけじゃないよ&lt;/h1&gt;

&lt;p&gt;もちろんです。
基本的な手法を大別しただけで、私の発表中にもポインタ方式でも最適化がありえるとの指摘がありましたし、ジェネリクス勉強会中でも.NETの実装の話も出てました。
勉強会全体を見ているならここで私がフォローするまでもないかと思いますが、念のため拾っておきます。&lt;/p&gt;

&lt;h1 id=&#34;クロージャの件が分からない&#34;&gt;クロージャの件が分からない&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;クロージャの型は関数型じゃないの？&lt;/li&gt;
&lt;li&gt;無名関数は関数に名前がないだけで型はあるんじゃないの？&lt;/li&gt;
&lt;li&gt;なんで(Iteratorのmapとかの)返り値に関数型がでてくるの&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rustの挙動を知らないとちょっと分かりづらかったですね。それとあとで見返したら私も発表中一箇所嘘いってました。
詳しいことをコード例を出しながら説明していきます&lt;/p&gt;

&lt;h2 id=&#34;rustのクロージャの型は匿名化された型&#34;&gt;Rustのクロージャの型は匿名化された型&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru/&#34;&gt;Rustのクロージャ3種を作って理解する | κeenのHappy Hacκing Blog&lt;/a&gt;や&lt;a href=&#34;http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/&#34;&gt;Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog&lt;/a&gt;
で若干説明しましたが、Rustではクロージャリテラル毎に型が作られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut x = 0;
let mut counter = || { x += 1; x}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こう書いたときにコンパイラは裏で以下のようなコードを生成します。（Rustを知らない人への説明のため、FnOnceの存在や実際は参照でキャプチャするなどを無視した疑似コードです）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct AnonymousClosure{x: i32}
impl FnMut&amp;lt;()&amp;gt; for AnonymousClosure {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (): ()) -&amp;gt; i32 {
        self.x += 1;
        x
    }
}
let mut x = 0;
let mut counter = AnnonymousClosure{x: x}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要点は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クロージャ自体はただのキャプチャしたデータの集まり&lt;/li&gt;
&lt;li&gt;関数本体は、メソッドとして定義される。 &lt;strong&gt;Rustは静的ディスパッチをする&lt;/strong&gt; ので &lt;strong&gt;関数ポインタはデータには含まれない&lt;/strong&gt;。コンパイラが解決する。

&lt;ul&gt;
&lt;li&gt;私が1つ嘘を言っていたというのはここです。関数ポインタもデータに含まれるって言っちゃってました。&lt;/li&gt;
&lt;li&gt;クロージャだけど関数ポインタを使わないんですね&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;1クロージャリテラルにつき1型を生成することでクロージャリテラル毎の関数本体を出し分けている&lt;/li&gt;
&lt;li&gt;キャプチャした変数をまとめた構造体自体はポインタ型になっていない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クロージャ自体の型は関数型ではなくて、関数っぽい振舞いをするトレイト(ここでは&lt;code&gt;FnMut&lt;/code&gt;)を実装しているだけのただの無名型です。&lt;/li&gt;
&lt;li&gt;無名関数だから型が無名という説明は確かにちょっとおかしかったですね。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;クロージャを返したい&#34;&gt;クロージャを返したい&lt;/h2&gt;

&lt;p&gt;ここから「なんで(Iteratorのmapとかの)返り値に関数型がでてくるの」へのお返事。&lt;/p&gt;

&lt;p&gt;説明の例として遅延評価するイテレータへのマップを書きたいと思います。
引数にはイテレータとクロージャを取ります。
実際には適用する訳ではないのでマップするイテレータとクロージャの組を返せばよさそうですね。
ここで思い出して欲しいのはクロージャはただの&lt;code&gt;FnMut&lt;/code&gt;を実装している構造体なのでした。
なのでこう書くのですが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn map&amp;lt;I, B, F&amp;gt;(i: I, f: F) -&amp;gt; (I, F)
where
  I: Iterator,
  F: FnMut(I::Item) -&amp;gt; B,
{
  (I, F)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にクロージャを渡したときには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn map(i: SomeIter, f: AnnonymousClosure) -&amp;gt; (SomeIter, AnnonymousClosure)
{
  (i, f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようになります。ここでも、クロージャデータにはポインタが挟まってないことに注意して下さい。そして型名が分かるのでクロージャを呼び出すときにはその関数が &lt;strong&gt;静的ディスパッチされます&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返り値にクロージャの型を書く = クロージャの関数本体が静的ディスパッチされる = 速い&lt;/p&gt;

&lt;p&gt;ということが伝わりますでしょうか。なのでRustではできるかぎり返り値にクロージャの型を書きたいのです。&lt;/p&gt;

&lt;p&gt;で、このパターンだと引数で受け取ったものを返り値で返すだけなので関数を呼んだときに得られた名前を書くだけです。たとえクロージャが匿名型であっても書くことができます。&lt;/p&gt;

&lt;h2 id=&#34;返り値にだけ書きたい&#34;&gt;返り値にだけ書きたい&lt;/h2&gt;

&lt;p&gt;ところが返り値にだけクロージャの型を書こうとすると、ダメです。先程の&lt;code&gt;map&lt;/code&gt;関数を関数の中で使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn inc&amp;lt;I&amp;gt;(i: I) -&amp;gt; ???
where
  I: Iterator&amp;lt;Item = i32&amp;gt;,
{
  map(i, |x| x + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすると型はこう解決されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;sturct AnnonymousClosure;
impl FnMut&amp;lt;(i32,)&amp;gt; for AnonymousClosure {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (x,): (i32,)) -&amp;gt; i32 {
        x + 1
    }
}

fn inc(i: SomeItr) -&amp;gt; (SomeItr, AnnonymousClosure)
{
  map(i, AnnonymousClosure::new())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値にだけ匿名型が出てきました。
先程のようにパラメータで受け取ってそのまま返すということができません。
なのでここで、返り値も匿名化する存在型が必要になるのです。&lt;/p&gt;

&lt;p&gt;ここまでくれば以下のコードにも存在型が必要な理由が分かりますでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn do_later() -&amp;gt; impl Future&amp;lt;Item = (), Err = Error&amp;gt; {
    do_something()
        // ここでクロージャが出てきた
        .and_then(|()| do_another_thing())
        // 本来の`and_then`の返り値は
        // `AndThen&amp;lt;Self, B, F&amp;gt;`だが
        // `F`の型が匿名化されていて書けない
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;存在型って-forallでできるよ&#34;&gt;存在型って、forallでできるよ&lt;/h1&gt;

&lt;p&gt;マジレスなのかただ知識を披露してるのかよく分からなかったのですが、いちおうお返事書いておきます。&lt;/p&gt;

&lt;p&gt;どの意味で「forall」でできるよと言っているのかよく分からなかったのですが、Coqの実装を見ていっているのなら見当違いです。
Coqの実装はこの辺が参考になりますかね。 &lt;a href=&#34;http://inkar-us-i.hatenablog.com/entry/2016/11/16/175844&#34;&gt;Coqで「任意のxについて…」「あるxが存在して…」を扱う - きくらげ観察日記&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;これをRustで書くとこうなるでしょうか。Rustにはトレイトをパラメータで受け取る手段がないのでひとまず量化する一階の述語を&lt;code&gt;Fn() -&amp;gt; ()&lt;/code&gt;トレイトにしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct FnExists&amp;lt;F: Fn() -&amp;gt; ()&amp;gt;(f: F)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは命題論理としては正しいのですが、型パラメータを取るので目的である匿名化を実現できていません。&lt;/p&gt;

&lt;p&gt;もう1つは、CPS変換の可能性もあります。
この辺が参考になりますかね。&lt;a href=&#34;http://myuon-myon.hatenablog.com/entry/2016/05/11/215734&#34;&gt;データ型のCPS変換について - Just $ A sandbox&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;直観論理でも以下が成り立ちます。&lt;/p&gt;

&lt;p&gt;\[
{}^\exists x P(x) \to \lnot ^\forall x \lnot P(x)
\]&lt;/p&gt;

&lt;p&gt;因みに逆は直観論理では成り立ちません（直感的な説明をすると存在しないことを否定しても実際の値を構成できないからです）。&lt;/p&gt;

&lt;p&gt;これは確かに正しいです。「&lt;code&gt;Tr&lt;/code&gt;トレイトを実装した型」という存在型は以下の疑似コードで書けるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Tr{}
fn exists() -&amp;gt; FnOnce&amp;lt;A&amp;gt;(FnOnce&amp;lt;T: Tr&amp;gt;(t: T) -&amp;gt; A) -&amp;gt; A {
  let tr = SomeTr::new();
  forall &amp;lt;A&amp;gt; move |cont: FnOnce&amp;lt;T: Tr&amp;gt;(t: T) -&amp;gt; A| -&amp;gt; A { cont(tr) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですがまあ、これは実際には無理です。
1つにはRustには型の高ランク多相がありません。ジェネリクスだけです。
もしランクの概念を知らずにforallで書けると主張しているならそれは的外れです。
ランクの概念を知った上で高ランク多相を入れろという主張なら理解はできますが、無理です。
引数に渡す関数や返り値で返す関数、要はデータとして扱う関数はジェネリクスにできません。
スライドの中でRustはテンプレート方式と説明しましたが、ジェネリクスはテンプレートであって実際のデータではないので値として扱えないのです。
なのでRustのコンパイル方式を大きく変えるなどしないと実現できないでしょう。&lt;/p&gt;

&lt;p&gt;それにもう1つ、ランクとは関係なしにクリティカルな理由があります。
上で説明した通り、クロージャの実際の型は匿名データ型になります。なので返り値に型として書くことができません。
冷静になって考えれば返り値のクロージャの型を書かないようにするための存在型のために返り値にクロージャの型を書くのは土台無理です。&lt;/p&gt;

&lt;p&gt;さて、私の知識では全称型で存在型を構成する手法はこれくらいですがもし上記以外の構成方法が存在して、私が明後日な返事をしているなら連絡下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ジェネリクス ディスパッチ 表裏</title>
      <link>/slide/jienerikusu_disupatchi_omoteura/</link>
      <pubDate>Sat, 17 Jun 2017 22:25:35 +0900</pubDate>
      
      <guid>/slide/jienerikusu_disupatchi_omoteura/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# ジェネリクス ディスパッチ 表裏
----------------------
[ジェネリクス勉強会 - connpass](https://connpass.com/event/56773/?utm_campaign=event_participate_to_owner&amp;utm_source=notifications&amp;utm_medium=email&amp;utm_content=title_link)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# はじめに
-----------

* 例にはJavaとRustを使います
  + それ以外にあまり詳しくない
  + たまにScalaが出てくるかも
* 主に裏側で何が起きてるかに焦点を当てます
* 一般的な手法の比較と言語固有実装の比較がやや混じります
  + 実例重視
* 言語や機能を選ぶときの知識が増えればよし

===
# ジェネリクス
--------------

* 型でパラメータ化された何か
* パラメータ化する方法にいくつか方式が
  + 任意の型に対応する実装にする
    - Java
  + 使う型毎に実体をつくる
    - 型が引数になるイメージ
    - Rust
* 便宜上前者をポインタ方式、後者をテンプレート方式と呼ぶ

===
# 関数ジェネリクス
-----------------

* Javaコード


``` java
public class Generics {
    public static void main(String[] args) {
        Generics g = new Generics();
        System.out.println(g.id(&#34;hello&#34;));
    }

    &lt;T&gt; T id(T t) {
        return t;
    }
}
```

===

# 関数ジェネリクス
-----------------

* Javaアセンブリ

```
public class Generics {
  // ...
  // Tの中身に言及していない
  &lt;T&gt; T id(T);
    Code:
       0: aload_1
       1: areturn

```

===

# 関数ジェネリクス
-----------------

* Rustコード

``` rust
fn id&lt;T&gt;(t: T) -&gt; T {
    t
}


fn main() {
    println!(&#34;{}&#34;, id(&#34;hello&#34;));
}
```

===

# 関数ジェネリクス
-----------------

* Rustアセンブリ

``` llvm
define internal %str_slice @_ZN3tmp2id17hfe175cfdb5be0f46E(i8* noalias nonnull readonly, i64) unnamed_addr #0 {
start:
  ; str_sliceに特化した関数を生成している
  %2 = insertvalue %str_slice undef, i8* %0, 0
  %3 = insertvalue %str_slice %2, i64 %1, 1
  ret %str_slice %3
}
```

===

# 関数ジェネリクス
-----------------

* ポインタ方式は`void *`使ってるイメージ
  +  コンパイルされたコードがコンパクト
  + 必ずポインタ経由する
    + Javaのオブジェクトは参照になってるのであまり問題ない
* テンプレート方式は型毎に`id_XXX`関数を定義してるイメージ
  + 構造体の値渡しも可能
  + オブジェクトコードは大きくなる
  + 関数の使用箇所が分からないとコンパイルできない

===

# 返り値ジェネリクス
-------------------

* Rustは返り値のジェネリクスがある
  - コンテキストで返り値が決まる
  ```rust
  // str
  parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt; where
    F: FromStr;
  ```
  ```rust
  let addr: SocketAddr = &#34;127.0.0.1:8080&#34;.parse().unwrap();
  ```
* コンパイル中に実際の型が解決されるので関連関数（スタティックメソッド）が呼べる
* キモいけど便利


===

# データ型ジェネリクス
---------------------

* `ArrayList&lt;T&gt;`(Java) vs `Vec&lt;T&gt;`(Rust)
* だいたい関数のときと似たような特徴
* テンプレート方式はサイズやアラインメントまで考慮できる
  - `Vec&lt;u8&gt;`(バイト列型)が効率的
* Rustの場合は構造体定義はオブジェクトコードに出ないのでサイズは気にならない

===

# 制約とディスパッチ
-------------------

* パラメータ型に条件をつけたい
  + Javaならインターフェースで `T extends SomeInterface` とか
  + Rustならトレイトで `T: SomeTrait` とか
* さらにパラメータ型の詳細にアクセスしたい
  + `t.someMethod()` とか
* このメソッドってどっからやってくるの？

===

``` java
&lt;W extends Writer&gt; void writeHello(W w) throws IOException {
    // このwriteメソッドはどこから？
    w.write(&#34;Hello&#34;);
}
```

``` rust
fn write_hello&lt;W: io::Write&gt;(mut w: W) -&gt; io::Result&lt;()&gt; {
    // このwrite_allメソッドはどこから？
    w.write_all(b&#34;Hello&#34;)
}
```

===

# 動的ディスパッチ
-------------------
* Javaだとオブジェクトに紐付くメソッドテーブルを *実行時* に引く
  + テーブルもオブジェクトから *実行時* に取得する
   ``` java
   w.vtable[write](w, &#34;Hello&#34;);
   ```
* ダイナミックなことができる
  + サブクラスのインスタンスと入り交じっても問題無
    ```java
    Writer w = new MyWriter();
    obj.writeHello(w);
    ```
* vtable引くオーバーヘッドがかかる
  - [java - Virtual table/dispatch table - Stack Overflow](https://stackoverflow.com/questions/6606481/virtual-table-dispatch-table)
  - [jvm - Java method table - Stack Overflow](https://stackoverflow.com/questions/10225668/java-method-table)

===

# 静的ディスパッチ
-----------------
* Rustだとメソッドを *コンパイル時* に解決する
  + テーブルを静的に解決するだけじゃなくてテーブルのメソッドまで解決
  ```rust
   SomeWriter::write(w, b&#34;Hello&#34;)
  ```
  + 辞書オブジェクトはみんなの心の中にあるんだよ
    - (テーブルだけ静的に解決する方式もある)
* 速い
  + オーバーヘッドがない
  + メソッドのインライン化などの最適化ができる

===
# 動静まとめ
------------

* ポインタ方式で動的ディスパッチだとコンパクトだけど遅い
* テンプレート方式で静的ディスパッチだと速いけど嵩む
* 特徴は表裏な感じ


===
# Java固有の問題と解決
----------------------

* ジェネリクスとプリミティブ問題
* → ヴァルハラ
* → Scalaのspecialized
* → DottyのLinker

===

# ジェネリクスとプリミティブ問題
--------------------------------

* ジェネリクスは必ずポインタ経由
  + プリミティブはどうするの？
* 一旦オブジェクトに包む(ボクシングする)必要がある
  + 関数もデータ型も同じ問題
  + 関数は暗黙の変換があるので気付きづらい
* 割と深刻なパフォーマンス低下を招くこともある


===

``` java
public class Generics {
    public static void main(String[] args) {
        Generics g = new Generics();
        // プリミティブを渡す
        System.out.println(g.id(0));
    }

    &lt;T&gt; T id(T t) {
        return t;
    }
}

```


===

```
public class Generics {
  public static void main(java.lang.String[]);
   // ..
    Code:
      // ..
      // ここで一旦`Integer`を作る
      13: invokestatic  #5                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      16: invokevirtual #6                  // Method id:(Ljava/lang/Object;)Ljava/lang/Object;
      19: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
      22: return

  &lt;T&gt; T id(T);
    Code:
       0: aload_1
       1: areturn

}

```

===

# ヴァルハラ
------------

* [OpenJDK: Valhalla](http://openjdk.java.net/projects/valhalla/)
  + [JEP 169: Value Objects](http://openjdk.java.net/jeps/169)
  + [JEP 218: Generics over Primitive Types](http://openjdk.java.net/jeps/218) ← こっち
* プリミティブタイプもボクシングせずにジェネリクスに使える
* やったね
* いつ入るんだろうね。
* [JDK 9](http://openjdk.java.net/projects/jdk9/) にはまだっぽい？

===

# [scala.specialized](http://www.scala-lang.org/api/2.9.2/scala/specialized.html)
-------------

* ジェネリクスの他にプリミティブ毎に専用のメソッドを生成
* 半分テンプレート方式みたい
  ``` scala
  class MyList[@specialized T]  ...
  ```
* 実際には使われない型に対しても生成してしまう
  + → テンプレート方式よりも非効率
  + 型パラメータが3つあったら1000メソッドくらい出来てしまう
* &gt; 関数の使用箇所が分からないとコンパイルできない

  + JVMの分割コンパイル下では何が使われるか事前に分からない

===

# DottyのLinker
---------------

* &gt; 関数の使用箇所が分からないとコンパイルできない
* リンクフェーズを用意すれば使用箇所が全て分かる
* [Dotty Linker: Making your Scala applications smaller and faster](https://d-d.me/talks/scaladays2015/#/)
  + スライドを見る限りspecializeしといてDCE?
* 実際には生のバイトコードじゃ情報が足りないのでTASTYも付加
* Dottyはいつ使えるようになるんでしょうね。

===

# Rust固有の問題と解決
---------------------

* トレイト境界とヘテロな型の問題
  * ヘテロなVec
  * 分岐からのreturn
* → トレイトオブジェクト

===
# トレイト境界とヘテロな型の問題
-------------------------------

* ジェネリックデータ型に2つ以上の異なる型を入れられない
* つまり以下のようなコードが書けない
  ``` rust
  trait Processor {}
  let procs: Vec&lt;Processor&gt; = vec![
    TwProc::new(),
    FbProc::new(),
  ];
  ```
* トレイトは実際の型ではないので同じ振舞をしても共通の型として扱えない
* でも一緒に扱いたいケースがあるんだけど？？

===
# トレイト境界とヘテロな型の問題2
-------------------------------

* 分岐して型を出し分けるのも出来ない
  ```rust
  fn getProc() -&gt; Processor {
    if xxx {
      TwProc::new()
    } else {
      FbProc::new()
    }
  }
  ```

===

# トレイトオブジェクト
---------------------

* オプトインで動的ディスパッチする仕組み
* データとトレイトからvtableを作る
* `Box`や`&amp;`などポインタ型を通すと使える

===

``` rust
let procs: Vec&lt;Box&lt;Processor&gt;&gt; = vec![
  Box::new(TwProc::new()),
  Box::new(FbProc::new()),
];

```

``` rust

fn getProc() -&gt; Box&lt;Processor&gt; {
  if xxx {
    Box::new(TwProc::new())
  } else {
    Box::new(FbProc::new())
  }
}
```
===

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;span style=&#34;font-size:400%;&#34;&gt;裏&lt;/span&gt;

===

# ジェネリクスの双対
-------------------

* ジェネリクスは$\forall$の量化
  + 関数$T \to S$に対して${}^\forall x(T \to S)$
* $\exists$の量化があってもよくない？
  + 存在型と呼ばれる
  + 因みに${}^\exists x(T \to S)$は虚無

===

# 存在型
---------

* 「`P`を満たす`T`が存在する」ことを表わす型
* `P`とは？
  + 本来は型を引数にとる述語。
    + e.g.) 「`T`は`S`のサブタイプである」「`T`は`write`メソッドを持つ」
  + 実際は型の集合の方が便利
    - $P(x) \iff x \in \\{x| {}^\forall x, P(x) \\}$
  + Scala: `forSome`に続く何か
    - よく分からなかった。構造的superset?
  + Rust: トレイト境界
* 実際に使うときには`P`を満たす`T`を1つ与える
* 実際の型を変数`T`に匿名化してるとも見れる
  - Rustなら「トレイト`Tr`を実装しているとある型`T`」
===

# 引数の存在型
---------------

* Scalaの`forSome`
  ```scala
  def len(l: List[T] forSome {type T}): Int
  ```
* Rustのarg position `impl Trait`
  ```rust
  fn len(i: impl IntoIterator) -&gt; usize
  ```
* `R`が`x`を含まないなら
  \\\[{}^\forall x(A(x) \land x \to R) \leftrightarrow {}^\exists x (A(x) \land x) \to R \\\]
  なのでほぼジェネリクス
* 違い
  + 関数が型パラメータを持たなくなる
  + 量化した場所以外（他の引数や返り値）でその型変数を使えない

===
# 返り値の存在型
----------------

* Rustの`impl Trait`
  ```rust
  fn do_later() -&gt; impl Future&lt;Item = (), Err = Error&gt;
  ```
* 実際の型は関数の定義で決まっている
* 実質返り値を匿名化しているだけ
* 必要？

===
# 存在型の利点
--------------

* 何をしたいか伝わりやすい
  ```rust
  // Iterator
  map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; where ...
  ```
  vs
  ```rust
  map&lt;B, F&gt;(self, f: F) -&gt; impl Iterator where ...
  ```
* サブタイピングがあればアップキャストで終わる
* Rustでも動的ディスパッチを許せばトレイトオブジェクトがある
  + でも絶対動的ディスパッチをしたくない

===
# 存在型の必要性
----------------

* 存在型でないと書けない型が存在する
  + 匿名化した型を含む型
  + クロージャ、お前のことだ
* 以下の型はジェネリクスでは書けない
  ``` rust
  fn counter(x: isize) -&gt; impl FnMut() -&gt; isize;
  ```

* 動的ディスパッチを許せばトレイトオブジェクトで書ける
  + でも絶対動的ディスパッチをしたくない
  + 極端な話、関数抽象する度にパフォーマンスが落ちる

===

# ユースケース
--------------

* 実際そんなに必要なの？
* 極一部のケースだけじゃないの？
* 分岐したら結局トレイトオブジェクト必要なんじゃなかった？
* 動的ディスパッチで妥協できないの？

===

# `Iterator`
------------

* 標準ライブラリ
* 遅延評価
  * 融合変換するため
* `map`すると元のイテレータとmapする関数の組が返る
  ```rust
  // Iterator
  map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; where ...
  ```
* `impl Trait`で書くと分かりやすい
  ```rust
  map&lt;B, F&gt;(self, f: F) -&gt; impl Iterator where ...
  ```

===

# [futures-rs](https://github.com/alexcrichton/futures-rs)
-----------------

* 非同期処理を抽象化
* 実行時にはステートマシンになる
  + 動的ディスパッチを挟まない
* `Future`に`map`や`and_then`すると返り値に関数型が出てくる
  + 存在型がないと書けない
  + 引数でクロージャを受け取る訳ではないのでジェネリクスで書けない
* `Future`を使うほぼ全てのコードで存在型が必要になる

===
# futures-rs
------------

``` rust
fn do_later() -&gt; impl Future&lt;Item = (), Err = Error&gt; {
    do_something()
        // ここでクロージャが出てきた
        .and_then(|()| do_another_thing())
        // 本来の`and_then`の返り値は
        // `AndThen&lt;Self, B, F&gt;`だが
        // `F`の型が匿名化されていて書けない
}
```

===
# [transaction-rs](https://github.com/KeenS/transaction-rs)
------------------

* トランザクションを抽象化
* コンセプト的には`futures-rs`に似てる
* 分岐しても`branch` APIでトレイトオブジェクト回避
  + 直和型を信じろ
* [マイクロベンチマーク](https://github.com/KeenS/transaction-rs/blob/master/transaction-stm/benches/boxed_vs_branch.rs)だとトレイトオブジェクトをなくすと *13%* 高速化

===
# transaction-rs
----------------

```rust
fn find_and_delete() -&gt; impl Transaction&lt;Item = Option&lt;User&gt; ...&gt; {
  match find_user() {
    // 分岐の枝毎に違う型を返そうとしてるが、直和型を使えば問題無
    None =&gt; ok(none).branch().first()
    Some(user) =&gt;
      delete_user()
        .map(move|_| user)
        .branch()
        .second()
  }
}
```


===
# 存在型の深掘
--------------

* ユーザには匿名化された型の実体は分からない
* コンパイラは実際の型で扱う
* 色々エッジケースが出てきそう
  + 同じ関数から返る型は同じ型？
  + 違う関数でも実体が同じなら？
  + 関数がジェネリクスだったら？
    - 返り値もジェネリクスパターン
    - 引数だけジェネリクスパターン
  + トレイトのメソッドだったら？
* 例えば`vec![foo(), bar()]`って書けるの？

===

``` rust
fn foo&lt;T: Trait&gt;(t: T) -&gt; impl Trait {t}

fn bar() -&gt; impl Trait {123}

fn equal_type&lt;T&gt;(a: T, b: T) {}

equal_type(bar(), bar());                      // OK
equal_type(foo::&lt;i32&gt;(0), foo::&lt;i32&gt;(0));      // OK
equal_type(bar(), foo::&lt;i32&gt;(0));              // ERROR, `impl Trait {bar}` is not the same type as `impl Trait {foo&lt;i32&gt;}`
equal_type(foo::&lt;bool&gt;(false), foo::&lt;i32&gt;(0)); // ERROR, `impl Trait {foo&lt;bool&gt;}` is not the same type as `impl Trait {foo&lt;i32&gt;}`
// トレイトのメソッドには`impl Trait`は書けないらしい
```

===
# 話さなかったこと
-----------------

* 存在型のライフタイム
* Rustのfeatureとリリーススケジュール
  + 存在型はまだリリース版には入っていない
* 関連型と存在型の関係(なんか関係ありそう)

===

# まとめ
--------

* 総称を表わすジェネリクスというのがあるよ
* ジェネリクスの実装は2種類あるよ
* 存在を表わす存在型というのがあるよ
* 存在型の実装は2種類あるよ
* 2種類の実装は言語機能や型システムに密着してるよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>新しいコンパイラバックエンドcretonne</title>
      <link>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</link>
      <pubDate>Fri, 02 Dec 2016 14:00:11 +0900</pubDate>
      
      <guid>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;3日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。先日、Rustの開発者フォーラムに新しいバックエンドして&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;cretonne&lt;/a&gt;が&lt;a href=&#34;https://internals.rust-lang.org/t/possible-alternative-compiler-backend-cretonne/4275&#34;&gt;提案されていました&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ちょっと気になったのでそれを紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;概略&#34;&gt;概略&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/index.html&#34;&gt;ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;フォーラムによると、WebAssemblyをエンコードするために作られたコンパイラバックエンドで、FirefoxのJSエンジンであるSpiderMonkeyに載せる予定だそうです。JITが主な目的？&lt;/p&gt;

&lt;p&gt;LLVMのように最適化を頑張る方ではなくてコードを吐くまでのレイテンシを気にして作られているとのこと。なのでcretonne自身は最適化を行いません。&lt;/p&gt;

&lt;p&gt;特徴はドキュメントの&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/compare-llvm.html&#34;&gt;LLVMとの比較&lt;/a&gt;によくまとまってますが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LLVMは複数種類の中間言語を持つのに対してcretonneは1種類&lt;/li&gt;
&lt;li&gt;アセンブラもディスアセンブラもない

&lt;ul&gt;
&lt;li&gt;コードジェネレータが吐く命令だけサポート&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中間言語はISA非依存で、legalization / instruction selectionをするとISA固有のアノテーションが付く&lt;/li&gt;
&lt;li&gt;最大抽象単位が関数(LLVMはモジュール)。cretonneは関数のインライン化とかもしない。&lt;/li&gt;
&lt;li&gt;Extended Basic Blockを使う(LLVMはBasic Block)。

&lt;ul&gt;
&lt;li&gt;ebbは分岐命令のfalse branchを指定せず、fall throughする。よくあるマシン語に近い。&lt;/li&gt;
&lt;li&gt;分岐の合流はebbに引数を持たせることで行う(LLVMはphi nodeを使う)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;undefined behaviorが存在しない&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なんとなくWebAssemblyを意識した仕様ですね。&lt;/p&gt;

&lt;h1 id=&#34;雰囲気&#34;&gt;雰囲気&lt;/h1&gt;

&lt;p&gt;以下のCのコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;float
average(const float *array, size_t count)
{
    double sum = 0;
    for (size_t i = 0; i &amp;lt; count; i++)
        sum += array[i];
    return sum / count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のcretonneのIRに落ちるそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss1 = stack_slot 8, align 4   ; Stack slot for ``sum``.

ebb1(v1: i32, v2: i32):
    v3 = f64const 0x0.0
    stack_store v3, ss1
    brz v2, ebb3                  ; Handle count == 0.
    v4 = iconst.i32 0
    br ebb2(v4)

ebb2(v5: i32):
    v6 = imul_imm v5, 4
    v7 = iadd v1, v6
    v8 = heap_load.f32 v7         ; array[i]
    v9 = fext.f64 v8
    v10 = stack_load.f64 ss1
    v11 = fadd v9, v10
    stack_store v11, ss1
    v12 = iadd_imm v5, 1
    v13 = icmp ult v12, v2
    brnz v13, ebb2(v12)           ; Loop backedge.
    v14 = stack_load.f64 ss1
    v15 = cvt_utof.f64 v2
    v16 = fdiv v14, v15
    v17 = ftrunc.f32 v16
    return v17

ebb3:
    v100 = f32const qNaN
    return v100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ、実際はファイルヘッダとかも付きますがこんな感じです。&lt;/p&gt;

&lt;p&gt;ebbに引数があったりebbの途中で平気でブランチしてたり中々やんちゃですね。&lt;/p&gt;

&lt;h1 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h1&gt;

&lt;p&gt;コードを吐くところまでやりたかったのですがまだ絶賛開発中ということもあってそのような操作が見当りませんでした。&lt;/p&gt;

&lt;p&gt;ということでファイルの方を扱ってると面白みがないのでRust APIの方で関数を構築して正当性を検証してから中間言語を吐き出してみます。&lt;/p&gt;

&lt;h2 id=&#34;一歩&#34;&gt;一歩&lt;/h2&gt;

&lt;p&gt;まずはcretonneをcloneしてきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new cretonne-sample --bin
$ cd cretonne-sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んでCargo.tomlのdependenciesに&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cretonne = {path = &amp;quot;path/cretonne/lib/cretonne/&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加します。どうやらトップレベルのプロジェクトはただのユーティリティのようでした。本体は&lt;code&gt;lib/cretonne/&lt;/code&gt;以下にいます。&lt;/p&gt;

&lt;p&gt;そしてmainファイルの中身はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate cretonne;
use cretonne::ir::*;
use cretonne::ir::{types as ty};
use cretonne::ir::{immediates as imm};
use cretonne::isa;
use cretonne::settings::{self, Configurable};
use cretonne::{write_function, legalize_function, verify_function};

fn main() {
    let mut func = {
        let name = FunctionName::new(&amp;quot;average&amp;quot;);
        let mut sig = Signature::new();
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.return_types.push(ArgumentType::new(ty::F32));
        Function::with_name_signature(name, sig)
    };

    let isa = {
        let mut b = settings::builder();
        b.set(&amp;quot;opt_level&amp;quot;, &amp;quot;fastest&amp;quot;).unwrap();
        let f = settings::Flags::new(&amp;amp;b);
        let builder = isa::lookup(&amp;quot;intel&amp;quot;).unwrap();
        builder.finish(f)
    };
    verify_function(&amp;amp;func).unwrap();
    legalize_function(&amp;amp;mut func, isa.as_ref());
    let mut o = String::new();
    write_function(&amp;amp;mut o, &amp;amp;func, Some(isa.as_ref())).unwrap();
    println!(&amp;quot;{}&amp;quot;, o);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;function average(i32, i32) -&amp;gt; f32 {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おおまかには&lt;code&gt;func&lt;/code&gt;を構築して&lt;code&gt;isa&lt;/code&gt;を決めて&lt;code&gt;verify_function&lt;/code&gt;で検証、さらに&lt;code&gt;legalize_function&lt;/code&gt;で今回のアーキテクチャ向けに微調整、&lt;code&gt;write_function&lt;/code&gt;で書き出しです。&lt;/p&gt;

&lt;h2 id=&#34;スタックスロットの追加&#34;&gt;スタックスロットの追加&lt;/h2&gt;

&lt;p&gt;まあ、スタック領域ですね。8byteの領域を確保します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;にstack_slotsフィールドがあるのでそこにpushします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;push&lt;/code&gt;の返り値はスタック領域を指すキーです。&lt;/p&gt;

&lt;h2 id=&#34;ebbの追加&#34;&gt;EBBの追加&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;構造体のフィールドに&lt;code&gt;dfg&lt;/code&gt;がいて、そいつを色々いじります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let ebb0 = func.dfg.make_ebb();
        let v1 = func.dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = func.dfg.append_ebb_arg(ebb0, types::I32);

        cur.insert_ebb(ebb0);
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

ebb0(vx0: i32, vx1: i32):
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EBBの追加にはカーソルを決めてあげて、dfgにebbを作ってあげて、カーソルの位置にebbの追加という形になります。&lt;/p&gt;

&lt;p&gt;EBBには任意に引数を追加出来ます。&lt;code&gt;append_ebb_arg&lt;/code&gt;の返り値はSSAの変数です。&lt;/p&gt;

&lt;h2 id=&#34;命令を追加する&#34;&gt;命令を追加する&lt;/h2&gt;

&lt;p&gt;命令はpythonのスクリプトによって生成されるので補完が効かず、中々扱いづらいですが頑張ります。&lt;/p&gt;

&lt;p&gt;さて、今回コードの検証を入れているので以下のようなコードは検証に落ちてしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);

        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Error { location: Ebb(Ebb(0)), message: &amp;quot;block does not end in a terminator instruction!&amp;quot; }&#39;, ../src/libcore/result.rs:799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の命令が定数であるため、正常なブロックと見做されないのです。&lt;/p&gt;

&lt;p&gt;ひとまずv3を返すことで凌ぎます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        ....
        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     return v0
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令の頭に付いてる &lt;code&gt;[-]&lt;/code&gt;はlegalizeすると付くようです。&lt;/p&gt;

&lt;h2 id=&#34;ブランチ&#34;&gt;ブランチ&lt;/h2&gt;

&lt;p&gt;もう1つebbを追加してあげる必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let ebb3 = dfg.make_ebb();  // &amp;lt;- ebb3を作成
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new()); // &amp;lt;-ebb3にジャンプ

        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);

        cur.insert_ebb(ebb3); // &amp;lt;- ebb3を追加
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     brz vx1, ebb1
[-]                     return v0

                    ebb1:
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;残り&#34;&gt;残り&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;

        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb2 =  dfg.make_ebb();
        let v5 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb3 = dfg.make_ebb();

        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new());
        let v4 = dfg.ins(cur).iconst(types::I32, 0);
        let mut ebb2_arg = VariableArgs::new();
        ebb2_arg.push(v4);
        dfg.ins(cur).jump(ebb2, ebb2_arg);

        cur.insert_ebb(ebb2);
        let v6 = dfg.ins(cur).imul_imm(v5, 4);
        let v7 = dfg.ins(cur).iadd(v1, v6);
        dfg.ins(cur).jump(ebb3, VariableArgs::new());

        cur.insert_ebb(ebb3);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで進めていこうと思いましたがどうやらまだstack/heapを触る命令がない？？ようなので詰みました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;コンパイラバックエンドcretonneについて紹介しました&lt;/li&gt;
&lt;li&gt;cretonneのRust APIを触ってみましたがダメでした。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>マクロやコンパイラプラグインの実装方法色々</title>
      <link>/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou</link>
      <pubDate>Thu, 01 Dec 2016 13:29:52 +0900</pubDate>
      
      <guid>/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;2日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。マクロなどのコンパイル時に何か処理をしてコード生成する機構の実現方法が言語によって様々にあるなぁと思ったのでちょっと探ってみます&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;なんか文字だけ並んでても味気ないのでサンプルマクロも付けときますね。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラにマクロ専用言語のインタプリタ機能を付けるやつ&#34;&gt;コンパイラにマクロ専用言語のインタプリタ機能を付けるやつ&lt;/h1&gt;

&lt;p&gt;Rustの&lt;code&gt;macro_rules&lt;/code&gt;やSchemeの&lt;code&gt;syntax-rules&lt;/code&gt;が該当します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-syntax define-protocol
  (syntax-rules ()
    ((define-protocol (name type ...) (method arg ...) ...)
     (begin
       (define method
         (make-generic))
       ...
       (define name
         (lambda (type ...)
           (lambda methods
             (add-methods methods (list (list method arg ...) ...)))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;制限が強い上に無駄にコンパイラの機能が増えるので個人的にはあまり好きじゃないですね…。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラでもホスト言語を動かすやつ&#34;&gt;コンパイラでもホスト言語を動かすやつ&lt;/h1&gt;

&lt;p&gt;コンパイラとランタイムが一緒になっているCommon Lispなんかで使われる方法です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(defmacro dotimes-unroll ((i n unroll) &amp;amp;body body)
  (let ((n_      (gensym &amp;quot;n&amp;quot;)))
    `(let ((,n_ ,n))
       (do ((,i 0))
           ((&amp;lt; ,n_ (the fixnum (+ ,unroll ,i)))
            (do ((,i ,i (the fixnum (1+ ,i))))
                ((&amp;lt; ,n_ (the fixnum (1+ ,i))))
              ,@body
              ))
         ,@(loop :repeat unroll :append (append body `((setq ,i (the fixnum (1+ ,i))))))))))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;マクロがなくなるまで再帰的にマクロ展開をします。
ユーザが好き勝手書けてしかも手軽に使えるので割と好きです。まあ、でも言語を選びますね。&lt;/p&gt;

&lt;h1 id=&#34;コンパイラプラグインとしてdlopenするやつ&#34;&gt;コンパイラプラグインとしてdlopenするやつ&lt;/h1&gt;

&lt;p&gt;Rustのコンパイラプラグインが相当します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[lib]
crate-type = [&amp;quot;dylib&amp;quot;]
plugin = true
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn codegen&amp;lt;&#39;cx&amp;gt;(cx: &amp;amp;&#39;cx mut ExtCtxt, text: String, file: String)
        -&amp;gt; Box&amp;lt;MacResult + &#39;cx&amp;gt; {
    let mut output = Vec::new();
    let doc = Document::parse(&amp;amp;text)
        .expect(&amp;quot;failed to parse thrift file&amp;quot;)
        .expect(&amp;quot;EOF while parsing thrift file&amp;quot;);
    {
        let ns = find_rust_namespace(&amp;amp;doc).expect(&amp;quot;cannot find namespace&amp;quot;);
    output.write_all(format!(&amp;quot;mod {} {{&amp;quot;, ns.module).as_ref()).expect(&amp;quot;internal error failed to write the vec&amp;quot;);
    }
    compile(doc, &amp;amp;mut output).expect(&amp;quot;failed to generate code&amp;quot;);
    output.write_all(format!(&amp;quot;}}&amp;quot;).as_ref()).expect(&amp;quot;internal error failed to write the vec&amp;quot;);
    let output = match std::str::from_utf8(&amp;amp;output) {
        Ok(s) =&amp;gt; s,
        Err(_) =&amp;gt; &amp;quot;&amp;quot;,
    };

    trace!(&amp;quot;{}&amp;quot;, output);


    let parser = new_parser_from_source_str(cx.parse_sess(), file, output.to_string());

    struct ExpandResult&amp;lt;&#39;a&amp;gt; {
        p: parse::parser::Parser&amp;lt;&#39;a&amp;gt;,
    }
    impl&amp;lt;&#39;a&amp;gt; base::MacResult for ExpandResult&amp;lt;&#39;a&amp;gt; {
        fn make_items(mut self: Box&amp;lt;ExpandResult&amp;lt;&#39;a&amp;gt;&amp;gt;)
                      -&amp;gt; Option&amp;lt;SmallVector&amp;lt;ptr::P&amp;lt;ast::Item&amp;gt;&amp;gt;&amp;gt; {
            let mut ret = SmallVector::zero();
            while self.p.token != token::Eof {
                match panictry!(self.p.parse_item()) {
                    Some(item) =&amp;gt; ret.push(item),
                    None =&amp;gt; panic!(self.p.diagnostic().span_fatal(self.p.span,
                                                                  &amp;amp;format!(&amp;quot;expected item, found `{}`&amp;quot;,
                                                                           self.p.this_token_to_string())))
                }
            }
            Some(ret)
        }
    }

    Box::new(ExpandResult { p: parser })

}


fn macro_thrift&amp;lt;&#39;cx&amp;gt;(cx: &amp;amp;&#39;cx mut ExtCtxt, sp: Span, tts: &amp;amp;[TokenTree])
                     -&amp;gt; Box&amp;lt;MacResult + &#39;cx&amp;gt; {

    let text = match get_single_str_from_tts(cx, sp, tts, &amp;quot;thrift!&amp;quot;) {
        Some(f) =&amp;gt; f,
        None =&amp;gt; return DummyResult::expr(sp),
    };

    codegen(cx, text, &amp;quot;trift!&amp;quot;.to_string())
}


#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;amp;mut Registry) {
    reg.register_macro(&amp;quot;thrift&amp;quot;, macro_thrift);
    reg.register_macro(&amp;quot;thrift_file&amp;quot;, macro_thrift_file);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦dllを作ってそれをプラグインとしてロードするという手間もありますし、ユーザが触れるASTも複雑なのであまり好きではないです。
まあ、これは準クオートだとかのユーザインターフェースの問題だったりするんですが。
ただ表現力はホスト言語が使えるので自由に使えます。&lt;/p&gt;

&lt;h1 id=&#34;言語の仕組みを使ってライブラリをコンパイラにロードする&#34;&gt;言語の仕組みを使ってライブラリをコンパイラにロードする&lt;/h1&gt;

&lt;p&gt;私が地味に好きな言語に&lt;a href=&#34;http://www.mirah.org/&#34;&gt;mirah&lt;/a&gt;というのがあります。その言語での実現方法が少し好きでした。
mirahはJVMで動くRuby風言語で、コンパイラは既にセルフホストされています。つまりコンパイラもJVMで動く訳です。&lt;/p&gt;

&lt;p&gt;Javaには&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html&#34;&gt;SPI&lt;/a&gt;というものがあって明示的にクラスやインスタンスを指定しなくてもJVMが実装を捜してくれる機能があります。
その機能にのっかることでマクロを.classファイルにコンパイルしてクラスパスに置いておくだけでマクロが使えるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mirah&#34;&gt;$ExtensionsRegistration[[&#39;java.util.Map&#39;]]
class MapExtensions
  macro def [](key)
    quote { `@call.target`.get(`key`) }
  end
end

class Builtins implements ExtensionsProvider

  def register(type_system:ExtensionsService):void
    type_system.macro_registration(MapExtensions.class)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中々面白いですね。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;なんか実装コード1つない雑な記事で申し訳ありませんがmirahのマクロの仕組みがちょっと気に入ったので書こうと思った次第です。&lt;/p&gt;

&lt;p&gt;あとはOCamlのppxやHaskellのTHも気になるのですが調べきれませんでした。はい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのクロージャ3種を作って理解する</title>
      <link>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</link>
      <pubDate>Mon, 10 Oct 2016 16:48:43 +0900</pubDate>
      
      <guid>/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru</guid>
      <description>&lt;p&gt;κeenです。Rustのクロージャ、3種類もあって複雑ですよね。
こういう複雑なものはRustの気持になって考えれば理解出来たりします。ということで手でクロージャを作って理解してみましょう。&lt;/p&gt;

&lt;p&gt;尚、これはRustの1.12.0-stableと1.14.0-nightly (6e8f92f11 2016-10-07)で実験しています。
&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;関数 - 関数&lt;/li&gt;
&lt;li&gt;無名関数 - 名前のついていない関数&lt;/li&gt;
&lt;li&gt;自由変数 - そのスコープの中で束縛されていない変数&lt;/li&gt;
&lt;li&gt;クロージャ - 関数に、自由変数の値(環境)もくっつけてそれだけで閉じるようにしたもの&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;クロージャについては関数が閉じ込める環境だけを指してクロージャとする人もいますが、ここでは関数本体と環境を合わせてクロージャとします。&lt;/p&gt;

&lt;p&gt;よく、無名関数とクロージャ(関数閉包)を一緒くたにすることがありますが明確に区別しましょう。まあ、大抵の無名関数はクロージャになりますが、動的スコープの言語みたいにそうならないケースもあります。&lt;/p&gt;

&lt;p&gt;余談ですが「ラムダ式」は言語がよく無名関数に付ける名前です。「関数」も言語によって「手続き」だったり「メソッド」だったりしますね。&lt;/p&gt;

&lt;h1 id=&#34;fnonce-fnmut-fn&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、「作って理解する」なので例を出します。なんかよく分からないけど0から9の値に1を足して印字するプログラムです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = |arg|{ i + arg };
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無名関数を作って &lt;code&gt;cls&lt;/code&gt; という変数に束縛しています。 &lt;code&gt;cls&lt;/code&gt; は自由変数 &lt;code&gt;i&lt;/code&gt; を含みますので、 &lt;code&gt;cls&lt;/code&gt; のクロージャを取ると 「&lt;code&gt;cls&lt;/code&gt; の定義 + &lt;code&gt;i&lt;/code&gt; の定義」になります。&lt;/p&gt;

&lt;p&gt;では &lt;code&gt;i&lt;/code&gt; という変数を保持したオブジェクトを作りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Closure {
    i: isize,
}


fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // もちろん、Closureは関数でないので呼び出せない
        // println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このままだと &lt;code&gt;cls&lt;/code&gt; は呼び出せません。しかし &lt;code&gt;+&lt;/code&gt; なんかのオーバーロードを許しているRustはなんと関数呼び出し構文 &lt;code&gt;name(arg, ...)&lt;/code&gt; もオーバーロード出来ます。実装すべきトレイトは &lt;code&gt;std::ops::{FnOnce, FnMut, Fn}&lt;/code&gt; です。これがクロージャ3種です。&lt;/p&gt;

&lt;p&gt;これらは継承関係にあって、上から順に &lt;code&gt;FnOnce&lt;/code&gt;  &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait FnOnce&amp;lt;Args&amp;gt; {
    type Output;
    extern &amp;quot;rust-call&amp;quot; fn call_once(self, args: Args) -&amp;gt; Self::Output;
}

pub trait FnMut&amp;lt;Args&amp;gt;: FnOnce&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, args: Args) -&amp;gt; Self::Output;
}

pub trait Fn&amp;lt;Args&amp;gt;: FnMut&amp;lt;Args&amp;gt; {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, args: Args) -&amp;gt; Self::Output;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらの違いは &lt;code&gt;self&lt;/code&gt; をムーブして受け取るか &lt;code&gt;&amp;amp;mut&lt;/code&gt; で受けるか &lt;code&gt;&amp;amp;&lt;/code&gt; で受けるかです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;とりあえず先程の &lt;code&gt;Closure&lt;/code&gt; にこれを実装してみましょう。ちょいとunstableな機能なようなので &lt;code&gt;feature&lt;/code&gt; を使って、nightlyでコンパイルするようにしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

// 再掲
struct Closure {
    i: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
    type Output = isize;

    extern &amp;quot;rust-call&amp;quot; fn call_once(self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.i + arg
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで呼び出しが出来る筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // 無名関数を作る
        let cls = Closure {i: i};
        // 呼出せるようになる
        println!(&amp;quot;{}&amp;quot;, cls(x));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;勿論、これは以下のように明示的にメソッドを呼んでも同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    for i in 0..10 {
        // クロージャを作る
        let cls = Closure {i: i};
        // メソッドで呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls.call_once((x, )));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fnmut-fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;FnOnce&lt;/code&gt; で出来るんならなんで &lt;code&gt;FnMut&lt;/code&gt; と &lt;code&gt;FnMut&lt;/code&gt; が存在するかというと、クロージャが閉じ込めた環境の所有権の問題ですね。&lt;/p&gt;

&lt;p&gt;例えば以下のコードを手で実装してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = |arg| { x + arg};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程と同じ &lt;code&gt;Closure&lt;/code&gt; ではコンパイル出来ません（統一感のために &lt;code&gt;Closure&lt;/code&gt; のメンバ名を変えました）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(unboxed_closures)]
#![feature(fn_traits)]

use std::ops::{FnOnce, FnMut, Fn};

struct Closure {
    x: isize,
}

impl FnOnce&amp;lt;(isize,)&amp;gt; for Closure {
  // ...略
}


fn main() {
    let x = 1;
    // ループの外でクロージャを作る
    let cls = Closure {x: x};
    for i in 0..10 {
        // 複数回クロージャを呼ぶ
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error[E0382]: use of moved value: `cls`
  --&amp;gt; closure.rs:45:28
   |
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ value moved here in previous iteration of loop
   |
   = note: move occurs because `cls` has type `Closure`, which does not implement the `Copy` trait

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1回目のループでは問題ないのですが &lt;code&gt;call_once(self, (arg, ): (isize,))&lt;/code&gt; の呼び出しでムーブしてしまうので2回目以降は呼べません。ということで1つ下のトレイト、 &lt;code&gt;FnMut&lt;/code&gt; も実装してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl FnMut&amp;lt;(isize,)&amp;gt; for Closure {

    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (arg, ): (isize,)) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はこれでも怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:45:28
   |
43 |         let cls = Closure {x: x};
   |             --- use `mut cls` here to make mutable
44 |         for i in 0..10 {
45 |             println!(&amp;quot;{}&amp;quot;, cls(i));
   |                            ^^^ cannot borrow mutably

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;mut&lt;/code&gt; を要求しているから。正確にはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略


fn main() {
    let x = 1;
    // `mut` を付ける
    let mut cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。しかしまあ、何か書き換えてる訳でもないのに &lt;code&gt;mut&lt;/code&gt; が付いているのは嫌ですね。&lt;code&gt;mut&lt;/code&gt; を要求しないように定義してあげようと思ったら &lt;code&gt;Fn&lt;/code&gt; が必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// ...略

impl Fn&amp;lt;(isize,)&amp;gt; for Closure {
    extern &amp;quot;rust-call&amp;quot; fn call(&amp;amp;self, (arg,): (isize, )) -&amp;gt; Self::Output {
        self.x + arg
    }
}

fn main() {
    let x = 1;
    let cls = Closure {x: x};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで通ります。&lt;/p&gt;

&lt;h2 id=&#34;整理&#34;&gt;整理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;クロージャとは関数とその環境のセットだよ&lt;/li&gt;
&lt;li&gt;環境にも所有権はあるよ&lt;/li&gt;
&lt;li&gt;Rustは所有権でクロージャの呼び出しを使い分けるよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;構文&#34;&gt;構文&lt;/h1&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; に対応するRustの構文を探っていきます。&lt;/p&gt;

&lt;h2 id=&#34;fn&#34;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;先程 &lt;code&gt;Fn&lt;/code&gt; まで実装しないとコンパイルが通らなかった&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let x = 1;
    let cls = |arg| { x + arg};
    for i in 0..10 {
        println!(&amp;quot;{}&amp;quot;, cls(i));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は &lt;code&gt;||{}&lt;/code&gt; でコンパイルが通っているので &lt;code&gt;||{}&lt;/code&gt; は &lt;code&gt;Fn&lt;/code&gt; を作るようです。&lt;/p&gt;

&lt;h2 id=&#34;fnmut&#34;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;call_mut&lt;/code&gt; を要求しそうにちょっと変えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、予想通りエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot borrow immutable local variable `cls` as mutable
  --&amp;gt; closure.rs:37:13
   |
35 |         let cls = |arg|{ x += arg };
   |             --- use `mut cls` here to make mutable
36 |         for i in 0..10 {
37 |             cls(i);
   |             ^^^ cannot borrow mutably

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let cls = |arg|{ x += arg };
   |                   -----  - previous borrow occurs due to use of `x` in closure
   |                   |
   |                   mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to 2 previous errors

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程の &lt;code&gt;FnMut&lt;/code&gt; の例のように &lt;code&gt;cls&lt;/code&gt; に &lt;code&gt;mut&lt;/code&gt; を付けてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    let mut cls = |arg|{ x += arg };
    for i in 0..10 {
        cls(i);
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これでもエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --&amp;gt; closure.rs:39:24
   |
35 |         let mut cls = |arg|{ x += arg };
   |                       -----  - previous borrow occurs due to use of `x` in closure
   |                       |
   |                       mutable borrow occurs here
...
39 |         println!(&amp;quot;{}&amp;quot;, x);
   |                        ^ immutable borrow occurs here
40 |     }
   |     - mutable borrow ends here

error: aborting due to previous error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何故なら &lt;code&gt;cls&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; を捕捉し続けているから。これは &lt;code&gt;cls&lt;/code&gt; のライフタイムを &lt;code&gt;println!&lt;/code&gt; の前で終わらせてあげると解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut x = 1;
    {
        // `{}` でスコープを作ることでライフタイムをコントロールする
        let mut cls = |arg|{ x += arg };
        for i in 0..10 {
            cls(i);
        }
    }
    println!(&amp;quot;{}&amp;quot;, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FnMut&lt;/code&gt; は変数を &lt;code&gt;mut&lt;/code&gt; にする無名関数と同じなようです。&lt;/p&gt;

&lt;h2 id=&#34;fnonce-1&#34;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;じゃあ、 &lt;code&gt;FnOnce&lt;/code&gt; は？ &lt;code&gt;std::mem::drop&lt;/code&gt; を使って所有権を無理矢理奪うクロージャを作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::drop;

fn main() {
    let x = String::new();
    let cls = || {drop(x)};
    cls();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい、実はこれでOKです。冷静に考えたら &lt;code&gt;FnOnce&lt;/code&gt; を継承している &lt;code&gt;Fn&lt;/code&gt; を &lt;code&gt;||{}&lt;/code&gt; で作れた時点で問題ありませんでしたね。&lt;/p&gt;

&lt;h1 id=&#34;落穂拾い&#34;&gt;落穂拾い&lt;/h1&gt;

&lt;h2 id=&#34;move-クロージャ&#34;&gt;&lt;code&gt;move&lt;/code&gt; クロージャ&lt;/h2&gt;

&lt;p&gt;じゃあ、Rustが良い感じに使い分けてくれるなら &lt;code&gt;move&lt;/code&gt; クロージャって何のためにあるの？と思いますが、これは環境を捕捉する際に &lt;code&gt;Copy&lt;/code&gt; なんかが起こらないようにするためのものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; しない例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; する例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt; は環境 &lt;strong&gt;へ&lt;/strong&gt; 所有権を移すかどうか、 &lt;code&gt;FnOnce&lt;/code&gt; などは環境 &lt;strong&gt;から&lt;/strong&gt; 所有権を移すかどうかです。&lt;/p&gt;

&lt;h2 id=&#34;関数ポインタ&#34;&gt;関数ポインタ&lt;/h2&gt;

&lt;p&gt;クロージャを持たない関数は、 &lt;code&gt;fn(i32) -&amp;gt; i32&lt;/code&gt; のような型を持ちます。これは空の環境を持つクロージャと同じですね。空の環境に所有権も何もないのでプリミティブの &lt;code&gt;fn&lt;/code&gt; は &lt;code&gt;FnOnce&lt;/code&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;code&gt;Fn&lt;/code&gt; のいずれとしても振舞います。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;p&gt;ここまで書いて普通にドキュメントに詳しく載っているのに気付きました（汗&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/functions.html&#34;&gt;関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/closures.html&#34;&gt;クロージャ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>