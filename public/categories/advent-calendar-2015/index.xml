<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Advent Calendar 2015 on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/advent-calendar-2015/</link>
    <description>Recent content in Advent Calendar 2015 on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 05 Dec 2015 22:04:25 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/advent-calendar-2015/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SML#でDBに接続</title>
      <link>http://keens.github.io/blog/2015/12/05/sml_dedbnisetsuzoku</link>
      <pubDate>Sat, 05 Dec 2015 22:04:25 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/05/sml_dedbnisetsuzoku</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/848&#34;&gt;ML Advent Calendar&lt;/a&gt;6日目の記事です。&lt;br /&gt;
次はdico_leque先生で、「ML中心にしつつ何か」です。&lt;/p&gt;

&lt;p&gt;κeenです。SMl#はDB接続及びSQLを言語レベルでサポートしていることが大きな特徴ですが詳細な方法についてはあまり情報がなく、
実際に利用するのは難しい状況にあります。そこで私がなんとかソースコードを読んで得られた知識を少し共有したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;接続サーバ設定:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続サーバ設定&lt;/h1&gt;

&lt;p&gt;DBへの接続サーバ設定には&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_sqlserver serverLocation : τ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;式を使います。このserverLocationはDB毎に指定方法が異なります。公式のドキュメントにはデフォルトDBであるPostgreSQLへの接続方法しか書かれていませんが、いくつかのDBをサポートします。&lt;/p&gt;

&lt;p&gt;SML#はDB接続時にテーブルの型を要求します(上でいう型注釈の&lt;code&gt;τ&lt;/code&gt;がそれです。文法的に型注釈がないといけません。)。今回の例では公式ドキュメントにある通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE mydb;
CREATE TABLE Persons (
  name text not null,
  age int not null,
  salary int not null
);
USE mydb;
INSERT INTO Persons VALUES (&#39;Joe&#39;, 21, 10000);
INSERT INTO Persons VALUES (&#39;Sue&#39;, 31, 20000);
INSERT INTO Persons VALUES (&#39;Bob&#39;, 41, 30000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で作ったDBへ接続することにします。&lt;/p&gt;

&lt;h2 id=&#34;テーブルの型:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;テーブルの型&lt;/h2&gt;

&lt;p&gt;深追いしてないので分かりません。とりあえず今回使う&lt;code&gt;mydb&lt;/code&gt;は&lt;code&gt;{Persons:{name:string, age:int, salary :int}&lt;/code&gt;で接続出来るみたいです。これも追わねば…&lt;/p&gt;

&lt;p&gt;一応ソースを読む限りだとint, decimal, real32, float, real, string, bool, timestampがあるようです。NULLableなカラムにはoptionを使うようです。&lt;/p&gt;

&lt;p&gt;SMLで見慣れないdecimal, float, timestampはSML#が実装を持っているようです。&lt;/p&gt;

&lt;p&gt;float, decimalは内部表現は文字列で、文字列との相互及びrealとIEEERealへの変換が出来るようです。&lt;/p&gt;

&lt;p&gt;timestampは文字列との相互変換及び&lt;code&gt;now()&lt;/code&gt;関数, &lt;code&gt;defaultTimestamp&lt;/code&gt;が存在します(スキーマに&lt;code&gt;DEFAULT&lt;/code&gt;指定があった時用)。内部表現はunix timeなのか、intです。&lt;/p&gt;

&lt;p&gt;それぞれ&lt;code&gt;SQL.Float&lt;/code&gt;, &lt;code&gt;SQL.Decimal&lt;/code&gt;, &lt;code&gt;SQL.TimeStamp&lt;/code&gt;モジュールに入っています。&lt;/p&gt;

&lt;h2 id=&#34;postgresql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;PostgreSQL&lt;/h2&gt;

&lt;p&gt;デフォルト設定のpgのmydbというDBへ接続したいならこれで接続出来ると公式ドキュメントに書いてあるのですが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (dbname=&amp;quot;mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと最後の &lt;code&gt;}&lt;/code&gt;が1つ抜けている上、それを補っても&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(interactive):2.27-2.32 Error: (name evaluation &amp;quot;190&amp;quot;) unbound variable: dbname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と返してきます。正しくは(?)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。他のパラメータ、例えばホストやポート、パスワードを渡したい場合はスペース区切で渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb host=localhost password=hogehoge&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この文字列はそのままPostgreSQLの&lt;a href=&#34;http://www.fireproject.jp/feature/postgresql/programing_libpq/connect.html#2&#34;&gt;&lt;code&gt;PGconnectdb&lt;/code&gt;&lt;/a&gt;という関数に渡っているのでそのドキュメントに完全な受付可能なキーが書いてあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host: DBサーバ名&lt;/li&gt;
&lt;li&gt;hostaddr: DBサーバのIPアドレス&lt;/li&gt;
&lt;li&gt;user: DB接続時のユーザ名&lt;/li&gt;
&lt;li&gt;password: userに対するパスワード&lt;/li&gt;
&lt;li&gt;dbname: DB名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とのことです。&lt;/p&gt;

&lt;h2 id=&#34;mysql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;MySQL&lt;/h2&gt;

&lt;p&gt;ドキュメントはありませんがソースコードを読んである程度勘を効かせた上で色々書いて試行錯誤すれば接続方法は分かります。&lt;/p&gt;

&lt;p&gt;MySQLに接続するには以下のように&lt;code&gt;SQL.mysql&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = _sqlserver (SQL.mysql &amp;quot;dbname=mydb&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余談ですが&lt;code&gt;_sqlserver&lt;/code&gt;はオーバーロードされていて、backend型とstring型両方を受け付けます。
文字列が来た時には&lt;code&gt;SQL.default&lt;/code&gt;に渡されます。そして &lt;code&gt;val default = postgresql&lt;/code&gt;です。つまり、PostgreSQLの例は&lt;code&gt;_sqlserver (SQL.postgresql &amp;quot;dbname=mydb&amp;quot;)&lt;/code&gt;
としているのと同じです。&lt;/p&gt;

&lt;p&gt;閑話休題。MySQLの時に渡せるパラメータの話をしましょう。こちらはバックエンドの接続関数にそのまま渡してる訳ではないのですが、
SML#側でパーサを持っているのでPostgreSQLの時のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;SQL.mysql &amp;quot;dbname=mydb host=localhost&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで使えるキーは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val availableKeys = [&amp;quot;host&amp;quot;, &amp;quot;port&amp;quot;, &amp;quot;user&amp;quot;, &amp;quot;password&amp;quot;, &amp;quot;dbname&amp;quot;, &amp;quot;unix_socket&amp;quot;, &amp;quot;flags&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義されています&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。因みにこれはパースエラーにならない文字列の集合であって、&lt;code&gt;unix_socket&lt;/code&gt;を使おうとするとコネクションエラーになるようです(&lt;code&gt;raise Connect &amp;quot;unix_socket is not supported&amp;quot;&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;文法に関して深掘りすると、一応パーサ(&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/KeyValuePair.sml&#34;&gt;src/sql/main/KeyValuePair.sml&lt;/a&gt;)を読む限りだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;keyは &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;(&lt;code&gt;isAlphanum&lt;/code&gt; + &lt;code&gt;#&#39;_&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueはスペース以外の文字列(e.g. &lt;code&gt;hogehoge&lt;/code&gt;)又は&lt;code&gt;&#39;&lt;/code&gt;で囲まれた文字列(e.g. &lt;code&gt;&#39;hoge hoge&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueでは&lt;code&gt;\&lt;/code&gt;によるエスケープが可能(e.g. &lt;code&gt;hoge\ hoge&lt;/code&gt;, &lt;code&gt;&#39;a \&#39;quote\&#39;&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;\&lt;/code&gt;については文字列の中なので&lt;code&gt;\&lt;/code&gt;自身のエスケープが必要なことに注意して下さい。&lt;/p&gt;

&lt;h2 id=&#34;unixodbc:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;unixODBC&lt;/h2&gt;

&lt;p&gt;ご存知ない方に説明するとODBCはOpen Database Connectivityの略です。Microsoftが主導となって定めたDB接続のインターフェースです。また、そのインターフェースに従うドライバマネージャのことも指します。
一旦抽象化レイヤを挟むのでパフォーマンス面では生の接続に負けますが、豊富な接続先が魅力です。
MicroSoftのSQL ServerやMicroSoft Accessを始めとし、Oracle, MySQL, PostgreSQL, SQLite3, 果てはMongoDBなどにまで接続出来ます。
まあ、接続出来るからといって投げたクエリを正しく解釈、実行してくれるとは限りませんが…&lt;/p&gt;

&lt;p&gt;unixODBCはODBCのunix実装のようです。つまりODBCドライバを持つDBにunixから接続出来ます。&lt;/p&gt;

&lt;p&gt;さてさて、odbcに繋ぐには以下のようにします。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = (SQL.odbc &amp;quot;mydb username mypassword&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜ記法変えたし…。&lt;del&gt;しかも必ずスペースで区切るのでクォートも出来なければ空のユーザパスワードを渡すことも出来ません。もしかしたら&lt;code&gt;&amp;quot;&#39;&#39;&amp;quot;&lt;/code&gt;としたら後側で空の文字列と扱ってくれるかもしれませんが。&lt;/del&gt;
私が&lt;code&gt;String.fields&lt;/code&gt;の挙動を勘違いしてました。スペースで区切って空にしておけば空パスワードを渡せます(e.g. &lt;code&gt;&amp;quot;mydb username &amp;quot;&lt;/code&gt;)。あるいは空ユーザ名も(&lt;code&gt;&amp;quot;mydb  &amp;quot;&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;私自身ODBCに詳しくないのですが、ODBCに接続するときはData Source Nameと呼ばれるものがシステムの特定の場所に存在するので他の接続情報は必要ないみたいです。&lt;/p&gt;

&lt;h1 id=&#34;接続:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続&lt;/h1&gt;

&lt;p&gt;さっきまでは接続サーバの設定の話でした。今度は実際に接続する話です。DBMS固有の話はサーバ設定までなのでこれからは総のDBに共通です。&lt;/p&gt;

&lt;p&gt;接続するには公式のドキュメント通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val conn = SQL.connet myServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で繋げます。ここで各クライアントのダイナミックリンクライブラリがないとエラーになります。64dbit環境でSML#を32bitでビルドしている人はライブラリも32bitでビルドされていることを確認しましょう。&lt;/p&gt;

&lt;h1 id=&#34;クエリ:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;クエリ&lt;/h1&gt;

&lt;p&gt;これもドキュメント通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myQuery = _sql db =&amp;gt; select #P.name as name, #P.age as age
      from #db.Persons as P
      where SQL.&amp;gt;(#P.salary, 10000)
val rel = _sqleval myQuery conn
val result = SQL.fetchAll rel; (* =&amp;gt; [{age=32, name=&amp;quot;Sue&amp;quot;}, {age=41, name=&amp;quot;Bob&amp;quot;}] *)
val () = SQL.closeRel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;p&gt;可能な文法については主に&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch10.S5.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;を参考にしましょう。&lt;/p&gt;

&lt;p&gt;insert, update, deleteをサポートしている他、トランザクション(&lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt;)をサポートしているようです。詳しくは&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/compiler/parser2/main/iml.grm#L727&#34;&gt;BNF&lt;/a&gt;を読んで下さい。&lt;/p&gt;

&lt;p&gt;SQLを投げて返ってきたリレーションに対しては結果を総取得する&lt;code&gt;SQL.fetchAll&lt;/code&gt;、結果をoption型で1つ取得する&lt;code&gt;SQL.fetch&lt;/code&gt;、結果を1つ取得するか例外になる&lt;code&gt;SQL.fetchOne&lt;/code&gt;を使います。&lt;code&gt;fetchOne&lt;/code&gt;の上げる例外は&lt;code&gt;SQL.NotOne&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;クエリ結果を使い終わったら必ず&lt;code&gt;SQL.closeRel&lt;/code&gt;で開放しましょう。そしてコネクションも、終わったら&lt;code&gt;SQL.closeCon&lt;/code&gt;で開放しましょう。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;本当は実際に試してから記事を書きたかったのですが、32bitの壁に阻まれて出来ませんでした。しかしソースを読んで裏を取って書いてあるのでまあまあ信憑性のある内容だと思います。
SML# からデータベースに接続したい方の一助になれば幸いです。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Rustで小さなツールを作ってみる(後編)</title>
      <link>http://keens.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_</link>
      <pubDate>Sun, 29 Nov 2015 13:54:39 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 2日目の記事です。&lt;br /&gt;
前 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru/&#34;&gt;Rustで小さなツールを作ってみる(前編)&lt;/a&gt;&lt;br /&gt;
次 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/cargonotsukaikata/&#34;&gt;Cargoの使い方&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。昨日の記事で作りかけだったIRCの生ログのDBへのインポートの続きです。今日はDBへのインポートをやります。&lt;/p&gt;

&lt;p&gt;とはいってもRustでDBを扱った経験がないので探り探りです。&lt;/p&gt;

&lt;h1 id=&#34;要件:b5100d6caeb6e32800002ace57fa8102&#34;&gt;要件&lt;/h1&gt;

&lt;p&gt;今回は簡単なのでORMは要らない気がしますが、サンプルということでORMも使いましょう。さらに、サンプルということでクエリビルダも使いましょう。&lt;/p&gt;

&lt;p&gt;…と思ったのですが中々良いライブラリがありませんでした。ドキュメントもろくにないまま放置されてる&lt;a href=&#34;https://github.com/deuterium-orm/deuterium&#34;&gt;deuterium&lt;/a&gt;と開発途中でまだpostgresしかサポートされていない&lt;a href=&#34;https://github.com/ivanceras/rustorm&#34;&gt;rustorm&lt;/a&gt;/&lt;a href=&#34;https://github.com/ivanceras/codegenta&#34;&gt;codegenta&lt;/a&gt;くらいしかないようです。うぅ。
最近話題になった&lt;a href=&#34;https://github.com/sgrif/diesel&#34;&gt;diesel&lt;/a&gt;もまだ若すぎるようです。&lt;/p&gt;

&lt;p&gt;ということでシンプルなDBIを使います。そろそろ牡蠣の美味しい季節ですしSQL生書きしましょう。当たると怖いですが。で、テスト用にsqlite3を、（今回は使いませんが）本番用（？）にMySQLを使える奴を捜しましょう。&lt;/p&gt;

&lt;h1 id=&#34;ライブラリ捜し:b5100d6caeb6e32800002ace57fa8102&#34;&gt;ライブラリ捜し&lt;/h1&gt;

&lt;p&gt;まずは&lt;a href=&#34;https://crates.io&#34;&gt;crates.io&lt;/a&gt;を捜します。&amp;rdquo;sqlite&amp;rdquo;で捜せばいいでしょうか。&lt;/p&gt;

&lt;p&gt;MySQLとSQLite3をサポートしているライブラリ…&lt;a href=&#34;https://github.com/sfackler/r2d2&#34;&gt;r2d2&lt;/a&gt;がそれのようです。
コネクションプールのライブラリなので何か違う気がしますが、mysqlもsqlite3も扱えて、結果コネクションを抽象化してくれるので大体大丈夫です。&lt;/p&gt;

&lt;p&gt;蛇足ですが、名前はJavaにc3p0というコネクションプールがあるのでそこから来ているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;スキーマ定義:b5100d6caeb6e32800002ace57fa8102&#34;&gt;スキーマ定義&lt;/h1&gt;

&lt;p&gt;SQLiteを使い慣れないのですが大したことやってないので大丈夫でしょう。&lt;code&gt;DATETIME&lt;/code&gt; 型がないのが苦しいですね。&lt;/p&gt;

&lt;p&gt;自然キーが文字列や複合キーなのでサロゲートキーを使って自然キーにUNIQUE制約をかけてますがちょっと気持悪いですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- _*_ mode: sql; sql-product: &#39;sqlite _*_

CREATE TABLE servers(
        id   INTEGER PRIMARY KEY,
        name  TEXT NOT NULL UNIQUE,
        address TEXT
        );
m
CREATE TABLE channels(
        id INTEGER PRIMARY KEY,
        server_id INTEGER REFERENCES servers(id) ON UPDATE CASCADE,
        name TEXT NOT NULL,
        UNIQUE(server_id, name)
        );

CREATE TABLE entries(
        id INTEGER PRIMARY KEY,
        channel_id INTEGER REFERENCES channels(id) ON UPDATE CASCADE,
        user_id INTEGER REFERENCES users(i) ON UPDATE CASCADE,
        type TEXT NOT NULL,
        body TEXT NOT NULL,
        created_at TEXT NOT NULL
        );

CREATE TABLE users(
        id INTEGER PRIMARY KEY,
        server_id INTEGER REFERENCES servers(id) ON UPDATE CASCADE,
        name TEXT NOT NULL,
        UNIQUE(server_id, name)
        );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをetc/schema.sqlに保存します。&lt;/p&gt;

&lt;h1 id=&#34;モデル定義:b5100d6caeb6e32800002ace57fa8102&#34;&gt;モデル定義&lt;/h1&gt;

&lt;p&gt;折角シンプルなツールを作っているのでモデルは使わない。&lt;/p&gt;

&lt;h1 id=&#34;コネクションまで:b5100d6caeb6e32800002ace57fa8102&#34;&gt;コネクションまで&lt;/h1&gt;

&lt;p&gt;あらかじめ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sqlite test.db &amp;lt; etc/schema.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてDBを作っておきましょう。&lt;/p&gt;

&lt;p&gt;Cargo.tomlのdependenciesには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;r2d2_sqlite = &amp;quot;0.0.3&amp;quot;
r2d2 = &amp;quot;0.6.1&amp;quot;
rusqlite = &amp;quot;0.4.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記。&lt;/p&gt;

&lt;p&gt;src/main.rsの先頭部分に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate r2d2;
extern crate r2d2_sqlite;
extern crate rusqlite;
use std::sync::Arc;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::SqliteError;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記しましょう。&lt;/p&gt;

&lt;p&gt;そしてmainの中に次を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let manager = SqliteConnectionManager::new(&amp;quot;test.db&amp;quot;).unwrap();
    let config = r2d2::Config::builder().pool_size(16).build();
    let pool = Arc::new(r2d2::Pool::new(config, manager).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで一旦コンパイル。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これが通れば良いです。&lt;/p&gt;

&lt;h1 id=&#34;はじめての挿入:b5100d6caeb6e32800002ace57fa8102&#34;&gt;はじめての挿入&lt;/h1&gt;

&lt;p&gt;INSERTを発行してみましょう。&lt;code&gt;on_channel_dir&lt;/code&gt;の引数を変える必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path, pool: Arc&amp;lt;r2d2::Pool&amp;lt;SqliteConnectionManager&amp;gt;&amp;gt;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;併せて、呼び出しも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        on_channel_dir(&amp;amp;path, pool.clone());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;/p&gt;

&lt;p&gt;そうしたら&lt;code&gt;on_channel_dir&lt;/code&gt;の中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていた辺でまずはserversへのインサートを発行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let conn = pool.get().unwrap();
    let server_id = match conn.execute(&amp;quot;INSERT INTO servers (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;server]) {
        // unique constraint failed
        Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM servers WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;server], |r| r.get(0)).unwrap(),
        Ok(_) =&amp;gt; conn.last_insert_rowid(),
        e =&amp;gt; {e.unwrap(); return}
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プールからコネクションを持ってきて&lt;code&gt;INSERT&lt;/code&gt;を発行します。成功するか既にUNIQUEな名前が存在していて失敗したらサーバのidを持ってきます。それ以外の失敗だったらそのままパニックしていいでしょう。&lt;/p&gt;

&lt;p&gt;しかしラッパがちょっと雑すぎやしませんかね。エラーステータスくらいenumでラップして欲しかった。&lt;/p&gt;

&lt;p&gt;同じくチャネルもインサートしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel_id = match conn.execute(&amp;quot;INSERT INTO channels (name, server_id) VALUES ($1, $2)&amp;quot;, &amp;amp;[&amp;amp;channel, &amp;amp;server_id]) {
        // unique constraint failed
        Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM channels WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;channel], |r| r.get(0)).unwrap(),
        Ok(_) =&amp;gt; conn.last_insert_rowid(),
        e =&amp;gt; {e.unwrap(); return}

    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こういうupsertというかinsert or get_idってどうやるのが正解なんでしょう。DB力が低い…&lt;/p&gt;

&lt;h1 id=&#34;エントリのインサート:b5100d6caeb6e32800002ace57fa8102&#34;&gt;エントリのインサート&lt;/h1&gt;

&lt;p&gt;同じく&lt;code&gt;on_log&lt;/code&gt;の引数を増やします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_log(log: &amp;amp;Path, channel_id: i64,  pool: Arc&amp;lt;r2d2::Pool&amp;lt;SqliteConnectionManager&amp;gt;&amp;gt;) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し側も。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let pool_ = pool.clone();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log, channel_id, pool_))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt;する前に&lt;code&gt;clone&lt;/code&gt;しないとダメですね。所有権難しい。&lt;/p&gt;

&lt;p&gt;さて、今度は色々することがあります。
まず、dateとtimeをくっつけてdatetimeにしましょう。timeがイミュータブルだったので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let mut time = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とし、その下で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        time.tm_mday = date.tm_mday;
        time.tm_mon = date.tm_mon;
        time.tm_year = date.tm_year;
        let created_at = time.to_timespec();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。わざわざ&lt;code&gt;to_timespec&lt;/code&gt;で変換してるのは&lt;code&gt;Timespec&lt;/code&gt;だとDBライブラリが良い感じに変換してくれるからですね。&lt;/p&gt;

&lt;p&gt;次にメッセージの抜き出し部分も値を返すように変更。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let (user, type_, body) = match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;sysmsg&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;join&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;part&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; (user, &amp;quot;msg&amp;quot;, body),
                None =&amp;gt; {
                    warn!(&amp;quot;cannot parse the entry; skipping&amp;quot;);
                    continue;
                }
            },
            _ =&amp;gt; (&amp;quot;server&amp;quot;, &amp;quot;notice&amp;quot;, &amp;amp;msg[1..]),
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまで来たらあとはユーザとエントリをインサートするだけですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let conn = pool.get().unwrap();
        let user_id = match conn.execute(&amp;quot;INSERT INTO users (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;user]) {
            // unique constraint failed
            Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM users WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;user], |r| r.get(0)).unwrap(),
            Ok(_) =&amp;gt; conn.last_insert_rowid(),
            e =&amp;gt; {e.unwrap(); return}
        };
        conn.execute(&amp;quot;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)&amp;quot;, &amp;amp;[&amp;amp;channel_id, &amp;amp;user_id, &amp;amp;type_, &amp;amp;body, &amp;amp;created_at]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦これで走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#hongo@utmc/2015-02-15.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-08-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-12-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-02-26.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-05-23.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-04-30.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2013-10-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-14.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-01-19.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-08-12.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-06-03.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-02-05.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あちゃー。マルチスレッドでINSERTしてるのでロックが掛かってますね。SQLiteはファイルロックしか持たないので並列インサートはつらそう。&lt;/p&gt;

&lt;h1 id=&#34;トランザクション:b5100d6caeb6e32800002ace57fa8102&#34;&gt;トランザクション&lt;/h1&gt;

&lt;p&gt;はい、そういう時のトランザクションですよ。&lt;/p&gt;

&lt;p&gt;最後のユーザやエントリーをインサートしてる部分で使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let conn = pool.get().unwrap();
        let trx = conn.transaction().unwrap();
        let user_id = match conn.execute(&amp;quot;INSERT INTO users (name) VALUES ($1)&amp;quot;, &amp;amp;[&amp;amp;user]) {
            // unique constraint failed
            Err(SqliteError{code: 19, message:_}) =&amp;gt; conn.query_row(&amp;quot;SELECT id FROM users WHERE name = $1&amp;quot;, &amp;amp;[&amp;amp;user], |r| r.get(0)).unwrap(),
            Ok(_) =&amp;gt; conn.last_insert_rowid(),
            e =&amp;gt; {e.unwrap(); return}
        };
        trx.commit();
        let trx = conn.transaction().unwrap();
        conn.execute(&amp;quot;INSERT INTO entries (channel_id, user_id, type, body, created_at) VALUES ($1, $2, $3, $4, $5)&amp;quot;, &amp;amp;[&amp;amp;channel_id, &amp;amp;user_id, &amp;amp;type_, &amp;amp;body, &amp;amp;created_at]);
        trx.commit();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排他制御が目的なのでトランザクションを2回取ってます。&lt;/p&gt;

&lt;p&gt;これだとどうなるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#hongo@utmc/2015-02-15.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-08-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-12-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-13.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-02-26.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-05-23.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-04-30.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2013-10-18.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-10-14.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-01-19.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: SqliteError { code: 5, message: &amp;quot;database is locked&amp;quot; }&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-08-12.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2014-06-03.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
thread &#39;/home/kim/log/#hongo@utmc/2015-02-05.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーは減ったもののまだ出ます。&lt;/p&gt;

&lt;h1 id=&#34;その他:b5100d6caeb6e32800002ace57fa8102&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;他にスレッドプールを使って並列度を下げる、ワーカースレッドを使ってSQLiteへの書き込みを1スレッドにするなども試したのですが上手く行きませんでした。&lt;/p&gt;

&lt;p&gt;スレッドプールについては、今回エラーハンドリングのためにスレッドを立てている訳ですが、パニックを出してスレッドが死ぬとあまり思わしくない挙動をするのでダメでした。&lt;/p&gt;

&lt;p&gt;ワーカースレッドは書き込んだ後にまたchannel_idなどを受け取らないといけないのでやめました。promiseなどを使えば上手くいきそうな気もしますが色々面倒そうなので止めておきます。&lt;/p&gt;

&lt;h1 id=&#34;コネクション:b5100d6caeb6e32800002ace57fa8102&#34;&gt;コネクション&lt;/h1&gt;

&lt;p&gt;並列度を下げる方法はもう1つあります。&lt;/p&gt;

&lt;p&gt;mainの中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let config = r2d2::Config::builder().pool_size(16).build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていたのを覚えていますでしょうか。これはコネクションプールに16個のコネクションを持っています。この数を落とせばなんとかならないでしょうか。&lt;/p&gt;

&lt;p&gt;結論からいうとダメでした。今度は複数スレッドがコネクションを取り合ってタイムアウトが発生してしまいます。&lt;/p&gt;

&lt;h1 id=&#34;並列度を下げる:b5100d6caeb6e32800002ace57fa8102&#34;&gt;並列度を下げる&lt;/h1&gt;

&lt;p&gt;最後の最後、本当に並列度を下げる方法があります。スレッドを立てていた部分で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let threads = logs.map(|log| {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log))
    }).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
    for thread in threads {
        let _ = thread.unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていました。これはファイル数分並列に実行してしまいます。ここを抑えましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    for log in logs {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        let pool_ = pool.clone();
        let _ = Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log, channel_id, pool_)).unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;spawn&lt;/code&gt;してそのまま&lt;code&gt;join&lt;/code&gt;します。こうすれば並列度を抑えつつパニックをスレッドに分離出来ます。&lt;/p&gt;

&lt;p&gt;これで実行するとどうなるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
thread &#39;/home/kim/log/#lisp-ja@freenode/2015-04-08.txt&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: GetTimeout(())&#39;, ../src/libcore/result.rs:736
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いくつかタイムアウトを出します。えー。並列度1でこれならもうどうしようもないでしょう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:b5100d6caeb6e32800002ace57fa8102&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;さて、小さなツールを作るというタイトルにしては後半(執筆が)重い内容になってしまいました。というか、sqlite3の問題もしますが。&lt;/p&gt;

&lt;p&gt;このブログの内容としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rustでディレクトリを扱った&lt;/li&gt;
&lt;li&gt;ファイルを扱った&lt;/li&gt;
&lt;li&gt;文字列を扱った&lt;/li&gt;
&lt;li&gt;日付を扱った&lt;/li&gt;
&lt;li&gt;スレッドを扱った&lt;/li&gt;
&lt;li&gt;ロガーライブラリを扱った&lt;/li&gt;
&lt;li&gt;エラーハンドリングをした&lt;/li&gt;
&lt;li&gt;パニックのハンドリングをした&lt;/li&gt;
&lt;li&gt;DBを扱った&lt;/li&gt;
&lt;li&gt;sqlite3に並列書き込みはつらい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ボツ案も含めれば私個人はORMやスレッドプール、チャネルも扱いましたが関係ないですね。&lt;/p&gt;

&lt;p&gt;こういう簡単なツールでも思ったより色々な機能を触れるのでみなさん試してみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;ソースコード全体は&lt;a href=&#34;https://github.com/KeenS/irc_log&#34;&gt;ここ&lt;/a&gt;においておきます。&lt;/p&gt;

&lt;p&gt;因みに本筋とは外れますが、今回のSQLiteの問題を扱うには一旦CSVファイルに書き出してからCSVインポートでバルクインサートが考えられます。
CSVに書き出すのはちまちまやってもいいし今回のデータ量ならオンメモリ構築して一気に書き出しも出来るでしょう。あるいはSQLiteをやめてMySQLを使う。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustで小さなツールを作ってみる(前編)</title>
      <link>http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru</link>
      <pubDate>Sat, 14 Nov 2015 23:57:43 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt; 1日目の記事です。&lt;br /&gt;
次 &lt;a href=&#34;http://KeenS.github.io/blog/2015/11/29/rustdechiisanatsu_ruwotsukuttemiru_kouhen_/&#34;&gt;Rustで小さなツールを作ってみる(後編)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。Rust Advent Calendar初日ということで軽い話から。
小さなツールって何だよって感じですが手元にIRCの生ログが大量にあるのでそれをDBにインポートしてみましょう。
あまりRustに向いた仕事じゃなさそうですが手始めとして。&lt;/p&gt;

&lt;p&gt;前編でログのパースを、後編でDBへのインポートをやります。&lt;/p&gt;

&lt;p&gt;IRCの生ログは&lt;a href=&#34;http://www.clovery.jp/tiarra/&#34;&gt;tiarra&lt;/a&gt;が吐いたものです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#emacs@freenode&lt;/code&gt;のように&lt;code&gt;チャネル名@サーバ名&lt;/code&gt;のディレクトリに入っていて、ファイル名は&lt;code&gt;YYYY-mm-dd.txt&lt;/code&gt;で、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;13:43:24 &amp;lt;#emacs@freenode:codingquark&amp;gt; Such key generation, much wow.
13:43:59 ! Vejeta` (Ping timeout: 264 seconds)
13:44:30 + jcazevedo (jcazevedo!~jcazevedo@a94-132-141-99.cpe.netcabo.pt) to #emacs@freenode
13:45:30 + quazimodo (quazimodo!~quazimodo@155.143.14.28) to #emacs@freenode
13:45:32 ! Hugehead_ (Read error: Connection reset by peer)
13:48:48 + favadi (favadi!~textual@113.190.4.106) to #emacs@freenode
13:51:06 wizzo -&amp;gt; bitchimightbe
13:52:23 bitchimightbe -&amp;gt; wizzo
13:53:05 - frost3772 from #emacs@freenode (&amp;quot;ERC (IRC client for Emacs 24.5.1)&amp;quot;)
13:56:37 ! chandan (Quit: WeeChat 1.2)
13:56:38 ! plunderous (Read error: Connection res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような形式で入ってます。先頭に&lt;code&gt;&amp;lt;&lt;/code&gt;が付いてるのが発言、&lt;code&gt;!&lt;/code&gt;がついてるのがなんかメッセージ(多分quitとかkillとか)、&lt;code&gt;+&lt;/code&gt;がjoin、&lt;code&gt;-&lt;/code&gt;がpart、無しがnickとかnoticeですかね。他にもログ取ってるircコマンドはあるのですが&lt;code&gt;!&lt;/code&gt;に内包されてそうですね(tiarraのマニュアルに載ってそうですが見るの面倒)&lt;/p&gt;

&lt;p&gt;因みにログ全体は&lt;code&gt;~/log&lt;/code&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;一応treeするとこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── #emacs@freenode
│   ├── 2014-04-11.txt
│   ├── 2014-04-12.txt
│   ├── 2014-04-13.txt
..  ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2014-04-11から2015-11-01までの間ロギングしてます。&lt;/p&gt;

&lt;h1 id=&#34;ディレクトリリスティングまで:a7315be0136fc976c0c4320441efd799&#34;&gt;ディレクトリリスティングまで&lt;/h1&gt;

&lt;p&gt;まずは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new irc_log --bin
$ cd irc_log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;code&gt;src/main.rs&lt;/code&gt;を開いて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs;

fn main() {
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, path.to_string_lossy().to_string());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きましょう。path path煩いですね。OSの返す文字列(Cの文字列)とRustの文字列の違いだとか一旦&lt;code&gt;Path&lt;/code&gt;で抽象化してるだとかで文字列を抜き出すのは一苦労です。&lt;/p&gt;

&lt;p&gt;さて、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でディレクトリ名が出てくればOK。&lt;/p&gt;

&lt;h1 id=&#34;ファイル名リスティング:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイル名リスティング&lt;/h1&gt;

&lt;p&gt;mainを&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs;

fn main() {
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        on_channel_dir(&amp;amp;path);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と置き換えてチャネルのディレクトリでの作業は&lt;code&gt;on_channel_dir&lt;/code&gt;でやりましょう。&lt;/p&gt;

&lt;h2 id=&#34;チャネル名とサーバ名の抜き出し:a7315be0136fc976c0c4320441efd799&#34;&gt;チャネル名とサーバ名の抜き出し&lt;/h2&gt;

&lt;p&gt;ディレクトリ名が&lt;code&gt;チャネル名@サーバ名&lt;/code&gt; の 形をしているので @の前後を抜き出せば良さそうです。&lt;/p&gt;

&lt;p&gt;src/main.rsの先頭に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::path::Path;
use std::str::from_utf8;
use std::os::unix::prelude::OsStrExt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でとりあえず&lt;code&gt;/&lt;/code&gt;の付かないディレクトリ名を取れそうです。難しい。やはりOSの返す文字列の扱いは面倒ですね。
しかし一旦Rustの文字列になってしまえばこちらのもの。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;@&lt;/code&gt;の位置を取得出来ます。&lt;code&gt;@&lt;/code&gt;がなかったらreturnして無視しておきましょう（実際そういう名前のディレクトリがあるのですが今回の集計の対象外なので）。&lt;/p&gt;

&lt;p&gt;あとは部分文字列を取るだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ファイルリスティング:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルリスティング&lt;/h2&gt;

&lt;p&gt;これは先程と同じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        let log = log.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, log.to_string_lossy().to_string());
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、&lt;code&gt;on_channel_dir&lt;/code&gt;全体はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        let log = log.unwrap().path();
        println!(&amp;quot;{}&amp;quot;, log.to_string_lossy().to_string());
    };
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ファイルのパース:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルのパース&lt;/h1&gt;

&lt;p&gt;次にまた&lt;code&gt;println!&lt;/code&gt;の部分を&lt;code&gt;on_log&lt;/code&gt;としてファイルをパースしていきましょう。&lt;/p&gt;

&lt;h2 id=&#34;日付の抜き出し:a7315be0136fc976c0c4320441efd799&#34;&gt;日付の抜き出し&lt;/h2&gt;

&lt;p&gt;先程と似てますので飛ばし気味にいきます。&lt;/p&gt;

&lt;p&gt;簡単にやっても良いのですがお作法として日付ライブラリを使ってパースしましょう。
&lt;code&gt;Cargo.toml&lt;/code&gt;に以下を追記。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]
time = &amp;quot;*&amp;quot;
log = &amp;quot;0.3.3&amp;quot;
env_logger = &amp;quot;0.3.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本当はバージョンも指定した方が良いのですが書き捨てのコードなのでまあ、良いでしょう。因みにtimeライブラリ自体扱いづらいとか色々問題があるのですがそれは後のAdvent Calendarに譲りましょう。しれっとloggerも導入します。printfデバッグにlogger便利!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cargo update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;してdependenciesをインストールします。因みに&lt;code&gt;log&lt;/code&gt;がlogger facadで&lt;code&gt;env_logger&lt;/code&gt;がloggerの実装です。使い方は後程。&lt;/p&gt;

&lt;p&gt;またsrc/main.rsの先頭に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[macro_use]
extern crate log;
extern crate env_logger;
extern crate time;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追記。&lt;/p&gt;

&lt;p&gt;そして&lt;code&gt;on_log&lt;/code&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn on_log(log: &amp;amp;Path) {
    let datestr = from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();
    let date = time::strptime(&amp;amp;datestr, &amp;quot;%Y-%m-%d&amp;quot;).urwrap();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は失敗しないことが分かってるので全部&lt;code&gt;unwrap&lt;/code&gt;してます。本当は&lt;code&gt;try!&lt;/code&gt;を使って上流に委ねた方がいいのですが今回は面倒なのでこうしちゃってます。正しいエラーハンドリングはtrplの&lt;a href=&#34;https://doc.rust-lang.org/book/error-handling.html&#34;&gt;Error Handling&lt;/a&gt;を読みましょう。&lt;/p&gt;

&lt;h2 id=&#34;ファイルの読み出し:a7315be0136fc976c0c4320441efd799&#34;&gt;ファイルの読み出し&lt;/h2&gt;

&lt;h3 id=&#34;開く:a7315be0136fc976c0c4320441efd799&#34;&gt;開く&lt;/h3&gt;

&lt;p&gt;コードをいきなり載せると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let file = match fs::File::open(log) {
        Ok(f) =&amp;gt; f,
        Err(e) =&amp;gt; {
            error!(&amp;quot;could not open {}; skipping.&amp;quot;, log.display());
            return;
        }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。これはエラーハンドリングします。1つのファイルに失敗しても次があるので。ここで使ってる&lt;code&gt;error!&lt;/code&gt;がloggerのマクロです。&lt;/p&gt;

&lt;h2 id=&#34;行毎の読み出し:a7315be0136fc976c0c4320441efd799&#34;&gt;行毎の読み出し&lt;/h2&gt;

&lt;p&gt;行毎の読み出しはバッファーリーダーが必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io::BufReader;
use std::io::BufRead;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をsrc/main.rsの先頭部分に追記しましょう。因みに&lt;code&gt;BufRead&lt;/code&gt;がトレイトで、&lt;code&gt;BufReader&lt;/code&gt;が実装です。実装が必要なのは良いとして、トレイトまで必要なのはトレイトで定義された関数を呼び出すのにトレイトのインポートが必要だからですね。&lt;/p&gt;

&lt;p&gt;さてさて、行の読み出しを進めます。先程オープンしたファイルを&lt;code&gt;BufReader&lt;/code&gt;で包んでやればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let br = BufReader::new(&amp;amp;file);
    for line in br.lines() {
        let line = match line {
            Ok(l) =&amp;gt; l,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;ignoring error {}&amp;quot;, e);
                continue;
            }
        };
        ....
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行の読み出し結果もResultで返ってくるんですね。これも失敗したら読み飛ばせばいいので&lt;code&gt;urwrap&lt;/code&gt;せずに扱います。&lt;/p&gt;

&lt;h2 id=&#34;行のパース:a7315be0136fc976c0c4320441efd799&#34;&gt;行のパース&lt;/h2&gt;

&lt;h3 id=&#34;ガード:a7315be0136fc976c0c4320441efd799&#34;&gt;ガード&lt;/h3&gt;

&lt;p&gt;先頭部分の時間をパースする時に部分文字列を抜き出しますが、変な行だと10文字もなかったりするので一旦ガードを付けておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        if line.len() &amp;lt; 10 {
            warn!(&amp;quot;ignoring line {}&amp;quot;, line);
            continue;
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;時間のパース:a7315be0136fc976c0c4320441efd799&#34;&gt;時間のパース&lt;/h3&gt;

&lt;p&gt;これはファイル名の時とほぼ同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let time = match time::strptime(&amp;amp;line[0..8], &amp;quot;%H:%M:%S&amp;quot;) {
            Ok(t) =&amp;gt; t,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;Parse error {}; ignoring&amp;quot;, e);
                continue;

            }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度は変な行が紛れてそうな（実際、ログファイルにはよくある）のでエラーは無視します。&lt;/p&gt;

&lt;h3 id=&#34;メッセージのパース:a7315be0136fc976c0c4320441efd799&#34;&gt;メッセージのパース&lt;/h3&gt;

&lt;p&gt;0-8文字目に時間があって、1スペース挟むので9文字目からがメッセージですね。そして先頭の文字で判断出来るのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;        let msg = &amp;amp;line[9..];
        match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; println!(&amp;quot;sysmsg {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; println!(&amp;quot;join {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; println!(&amp;quot;part {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; println!(&amp;quot;user: {} body: {}&amp;quot;, user, body),
                None =&amp;gt; ()
            },
            _ =&amp;gt; println!(&amp;quot;info {}&amp;quot;, &amp;amp;msg[1..]),
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で判断出来そうです。パースした後の話は後回し。&lt;/p&gt;

&lt;h1 id=&#34;ソース全体:a7315be0136fc976c0c4320441efd799&#34;&gt;ソース全体&lt;/h1&gt;

&lt;p&gt;ソースの断片が続いたので一旦ここまでの全体像を出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[macro_use]
extern crate log;
extern crate env_logger;
extern crate time;
use std::str::from_utf8;
use std::io::BufReader;
use std::io::BufRead;
use std::fs;
use std::path::Path;
use std::os::unix::prelude::OsStrExt;


fn on_log(log: &amp;amp;Path) {
    let datestr = from_utf8(log.file_stem().unwrap().as_bytes()).unwrap().to_string();
    let date = time::strptime(&amp;amp;datestr, &amp;quot;%Y-%m-%d&amp;quot;);
    let file = match fs::File::open(log) {
        Ok(f) =&amp;gt; f,
        Err(e) =&amp;gt; {
            error!(&amp;quot;could not open {}; skipping.&amp;quot;, log.display());
            return;
        }
    };
    let br = BufReader::new(&amp;amp;file);
    for line in br.lines() {
        let line = match line {
            Ok(l) =&amp;gt; l,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;ignoring error {}&amp;quot;, e);
                continue;
            }
        };
        if line.len() &amp;lt; 10 {
            warn!(&amp;quot;ignoring line {}&amp;quot;, line);
            continue;
        }
        let time = match time::strptime(&amp;amp;line[0..8], &amp;quot;%H:%M:%S&amp;quot;) {
            Ok(t) =&amp;gt; t,
            Err(e) =&amp;gt; {
                warn!(&amp;quot;Parse error {}; ignoring&amp;quot;, e);
                continue;

            }
        };
        let msg = &amp;amp;line[9..];
        match &amp;amp;msg[0..1] {
            &amp;quot;!&amp;quot; =&amp;gt; println!(&amp;quot;sysmsg {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;+&amp;quot; =&amp;gt; println!(&amp;quot;join {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;-&amp;quot; =&amp;gt; println!(&amp;quot;part {}&amp;quot;, &amp;amp;msg[1..]),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; match msg.find(&#39;&amp;gt;&#39;).map(|e| (&amp;amp;msg[1..e], &amp;amp;msg[e+1..])) {
                Some((user, body)) =&amp;gt; println!(&amp;quot;user: {} body: {}&amp;quot;, user, body),
                None =&amp;gt; ()
            },
            _ =&amp;gt; println!(&amp;quot;info {}&amp;quot;, &amp;amp;msg[1..]),
        }
    }
}

fn on_channel_dir(path: &amp;amp;Path) {
    let dirname = from_utf8(path.file_name().unwrap().as_bytes()).unwrap().to_string();
    let at = match dirname.find(&#39;@&#39;) {
        Some(i) =&amp;gt; i,
        None =&amp;gt; return
    };
    let channel = &amp;amp;dirname[..at];
    let server = &amp;amp;dirname[at+1..];
    println!(&amp;quot;{} at {}&amp;quot;, channel, server);
    let logs = fs::read_dir(path).unwrap();
    for log in logs {
        on_log(&amp;amp;log.unwrap().path());
    };
}


fn main(){
    env_logger::init().unwrap();
    let paths = fs::read_dir(&amp;quot;/home/kim/log&amp;quot;).unwrap();
    for path in paths {
        let path = path.unwrap().path();
        on_channel_dir(&amp;amp;path);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はmainの先頭で&lt;code&gt;env_logger::init().unwrap();&lt;/code&gt;でロガーの初期化してました。忘れてましたね。ごめんなさい。&lt;/p&gt;

&lt;p&gt;さて、これで一旦走らせてみましょう。動く筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動いてるようですが、遅い。出力が多くてターミナル側がボトルネックのようです。&lt;/p&gt;

&lt;h1 id=&#34;パニックハンドルとチューニング:a7315be0136fc976c0c4320441efd799&#34;&gt;パニックハンドルとチューニング&lt;/h1&gt;

&lt;p&gt;一旦メッセージを出力をやめて様子見してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;            &amp;quot;!&amp;quot; =&amp;gt; (),
            &amp;quot;+&amp;quot; =&amp;gt; (),
            &amp;quot;-&amp;quot; =&amp;gt; (),
            &amp;quot;&amp;lt;&amp;quot; =&amp;gt; (),
            _ =&amp;gt; (),

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それでもまだ遅い上に謎のパニックが出てます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;/home/kim/log/#lisp@freenode&#39; panicked at &#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary&#39;, ../src/libcore/str/mod.rs:1311
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログを見てみましょう。env_loggerは環境変数からログレベルを渡してあげるとログを出します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ RUST_LOG=Trace cargo run
...
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
WARN:irc_log: ignoring error stream did not contain valid UTF-8
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意外と変な行が一杯あるのですね。しかしこれらはちゃんとエラーハンドリングしてるので問題ありません。&lt;/p&gt;

&lt;p&gt;各所で&lt;code&gt;unwrap&lt;/code&gt;してるせいな気もしますが、&lt;code&gt;urwrap&lt;/code&gt;のせいならそういうメッセージが出るので違います。&lt;/p&gt;

&lt;p&gt;実はこれ、非UTF-8のバイト列でrustの標準ライブラリが内部でパニックを出してます。
これの扱いも後のAdvent Calendarに譲るとして、ワークアラウンドを捜しましょう。rust1.4時点ではパニックをハンドルする手段はありません。&lt;/p&gt;

&lt;p&gt;パニックメッセージの先頭に&lt;code&gt;thread&lt;/code&gt;とついてるのでthreadで包めば良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;thread:a7315be0136fc976c0c4320441efd799&#34;&gt;Thread&lt;/h2&gt;

&lt;p&gt;まずはthreadをインポートします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::thread::Builder;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてon_channel_logを少し弄りましょう。無効なバイト列を含むファイルをざっくり切る感じで。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    for log in logs {
        on_log(&amp;amp;log.unwrap().path());
    };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としていた部分を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    let threads = logs.map(|log| {
        let log = log.unwrap().path();
        let pathname = log.to_string_lossy().to_string();
        Builder::new().name(pathname).spawn(move|| on_log(&amp;amp;log))
    }).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
    for thread in threads {
        let _ = thread.unwrap().join();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とします。一見複雑ですが、ファイル毎にスレッドを作って全部をvectorにして集めてそれぞれjoinを待ってるだけです。
そしてスレッド名を処理するファイル名にしたいのでスレッドビルダを使っています。&lt;/p&gt;

&lt;p&gt;さて、これで走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time cargo run
...
#lisp at freenode
thread &#39;/home/kim/log/#lisp@freenode/2014-08-18.txt&#39; panicked at &#39;index 0 and/or 8 in ` ;ZZZz;…,` do not lie on character boundary&#39;, ../src/libcore/str/mod.rs:1311
#emacs at freenode
...
cargo run  327.21s user 8.71s system 630% cpu 53.289 total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lispチャネルの1ファイルだけに変なバイト列があることが分かりました。&lt;/p&gt;

&lt;p&gt;そしてパフォーマンスですが、とりあえず&lt;code&gt;top&lt;/code&gt;で見る限りCPUは最大770%使ってくれてます（8コアマシン）。ファイル毎にスレッド作ってるので若干リソースの食い合いが発生してますがこれだけ並列度があればスレッドプールを使うまでもないでしょう。&lt;/p&gt;

&lt;h2 id=&#34;さらなるチューニング:a7315be0136fc976c0c4320441efd799&#34;&gt;さらなるチューニング…？&lt;/h2&gt;

&lt;p&gt;しかしそれでもまだ遅いですね。ちょこっと書いては走らせるのサイクルを回すには耐えられません。&lt;/p&gt;

&lt;p&gt;そういえばログ全体のファイルサイズを確認してなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -h
...
774M   .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意外と小さい。まだチューニングの余地はありそうです。メモリアロケーションを減らしましょうか、それとも時間のパースを手書きでやりましょうか。&lt;/p&gt;

&lt;p&gt;いいえ。もっと簡単に速くする方法があります。&lt;code&gt;--release&lt;/code&gt;をつけて実行すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run --release
...
...
cargo run --release  3.63s user 5.44s system 203% cpu 4.453 total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(/ 53.289 4.453);=&amp;gt; 11.966988547046935&lt;/code&gt; 。12倍速くなりました。1ディレクトリ700以上のファイルがあってそれぞれにスレッドを作っているのでそろそろそのオーバーヘッドが効いてきてますね。&lt;/p&gt;

&lt;p&gt;スレッドプールを試してみたい気もしますがひとまずこれで置いておきましょう。&lt;/p&gt;

&lt;p&gt;次は後編、DBへのインポートです。&lt;/p&gt;

&lt;p&gt;蛇足ですが行のパースのところは正規表現でも出来ましたね。そっちの方が好きな方は試してみて下さい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>