<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scala Meet Up on κeenのHappy Hacκing Blog</title>
    <link>/categories/scala-meet-up/</link>
    <description>Recent content in Scala Meet Up on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 24 May 2016 23:40:36 +0900</lastBuildDate>
    <atom:link href="/categories/scala-meet-up/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>DOT/dottyについて調べてみた</title>
      <link>/slide/DOT_dottynitsuiteshirabetemita/</link>
      <pubDate>Tue, 24 May 2016 23:40:36 +0900</pubDate>
      
      <guid>/slide/DOT_dottynitsuiteshirabetemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# DOT/dottyについて調べてみた
----------------------
サイバーエージェント Scala Meet Up  
2016-05-27

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループ
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# Scalaコンパイラ
----------------

* 型推論（特にimplicit）が遅い
* コンパイルフェーズが多い
  + 中間オブジェクトが多くて遅くなる
* 多くのクラスファイルを生成する
  + コンパイラのくせにディスクIOが多い
* 気を抜いてると `Any` に推論される  
  e.g.) `if(x) 1 else &#34;a&#34;`
* そもそものScalaの設計に起因する点が多い
  + 抜本的変更が必要

# Scala基礎
-----------

* Scalaが成立するのに最低限必要な機能って？
  + e.g.) `case class` はなくても `class` だけでどうにかなる
* 「最低限の機能」を減らせばコンパイラがシンプルになる
  + 他の機能はただのシンタックスシュガーになる
  + コンパイラのバグを減らせる
  + 機能追加時の矛盾確認が楽
* コア言語


# Featherlight Scala
---------------------

* Scalaのシンタックスシュガーを減らした感じ
* 小さな言語
* 元のScalaはこれをベースに議論されてきた


# 形式言語理論
-------------

* 最低限必要な機能を形式的にモデル化
  + 全ての動作は予め決められた「規則」に基く
  + 実際に書いて動かすものではない
* 形式的にすることで「証明」とかが出来る
  + 「型検査に通れば実行時に型エラーが起きない」
  + 「型検査が必ず終了する」
* 逆に、「このモデルだとこの機能は実現出来ない」とかも分かる


# Dependent Object Type
------

* Scalaのコアをモデル化したもの（要出典）
* 形式言語
* ジェネリクスもなければクラスも継承もない、パッケージもない。
* 小さい言語ながら表現力豊か
* 全ての値はオブジェクト。
  + オブジェクトのフィールドとメソッドと型メンバーだけ
  + 型はそのまま
* Path Dependent Type
* サブタイピング



# About DOT
---------

* 型付の健全性が証明された
* System F&lt;:より強力
  * System F&lt;: -&gt; System D&lt;: -&gt; DOT
* existential typeを自然に表現出来る
* 交差型と合併型
  + `A extends B` -&gt; `A &amp; B`
  + 合併型は主に型推論の結果に出てくる

```scala
package scala.collection.immutable trait List[+A] {
  def isEmpty: Boolean; def head: A; def tail: List[A]
}
object List {
  def nil: List[Nothing] = new List[Nothing] {
    def isEmpty = true; def head = head; def tail = tail /* infinite loops */
  }
  def cons[A](hd: A, tl: List[A]) = new List[A] {
    def isEmpty = false; def head = hd; def tail = tl
  }
}
```


```scala
object scala_collection_immutable { sci =&gt;
  trait List { self =&gt;
    type A
    def isEmpty: Boolean
    def head: self.A def
      tail: List{type A &lt;: self.A}
  }
  def nil: sci.List{type A = Nothing} = new List{ self =&gt;
    type A = Nothing
    def isEmpty = true
    def head: A = self.head
    def tail: List{type A = Nothing} = self.tail
  }
  def cons(x: {type A})(hd: x.A)(tl: sci.List{type A &lt;: x.A})
      : sci.List{type A &lt;: x.A} = new List{ self =&gt;
    type A = x.A
    def isEmpty = false
    def head = hd
    def tail = tl
  }
}
```



# dotty
--------

* DOTに影響を受けたコンパイラ
* いくつかの新しい機能
  + DOTの交差型、合併型も
  + Nullable = `T | Null`
  + `if (x) 1 else &#34;a&#34;` は `Int | String` に
* `forSome` が消えた
  + DOTのお陰


# dotty
--------

* Java8のラムダを使う
  + 生成するclassファイルの減少
* Implicitの探索アルゴリズムを改善
  + 反変implicitについても改善
* 型推論のアルゴリズムを改善
  + DOTのお陰
  + 特にサブタイピングが交差/合併型で楽に
* コンパイルパスをいくつか融合して高速化
* 値クラスについての改良
  + `implicit class(val x: T) extends AnyVal`


# TASTY/Linker
--------------

* classファイルを作るとScala固有の情報が落ちる
* プログラム全体を見渡すと不要なコードとかもコンパイルしないといけない
* かといって毎回プログラム全部をコンパイルし直すのは遅い
* → TASTY。型推論後のASTをシリアライズする
  + Scalaは型推論が遅いのでそこをスキップ出来るだけでそこそこ速くなる
* classファイルを跨げるようになったのでユーザが最適化とかも書ける
* Scala/Scala.js/Scala Native共通プラットフォーム化への布石？
* Javaエコシステムとの関係どうなるんだろう。
  + TASTY配布 vs class配布


# まとめ
--------

* Scalaの基礎にDOTがあるよ
* DOTを参考にdottyが作られたよ
* dottyで色々改善されるよ
* ついでにTASTY/Linkerについて話したよ


# 参考
------

* [The Essence of Dependent Object Types](https://infoscience.epfl.ch/record/215280/files/paper_1.pdf)
* [From F to DOT: Type Soundness Proofs with Definitional Interpreters](http://arxiv.org/pdf/1510.05216v2.pdf)
* [Dependent Object Types](http://www.cs.uwm.edu/~boyland/fool2012/papers/fool2012_submission_3.pdf)
* [Why is the Scala compiler so slow? - Quora](https://www.quora.com/Why-is-the-Scala-compiler-so-slow)
* [performance - Java compile speed vs Scala compile speed - Stack Overflow](http://stackoverflow.com/questions/3490383/java-compile-speed-vs-scala-compile-speed/3612212#3612212)
* [GHC doesn&#39;t do subtyping. I suspect that is the main reason why Scala is slow - ... | Hacker News](https://news.ycombinator.com/item?id=5008761)
* [A Core Calculus for Scala Type Checking](http://lampwww.epfl.ch/~odersky/papers/mfcs06.pdf)
* [namin/dot: formalization of the Dependent Object Types (DOT) calculus](https://github.com/namin/dot)
* [The DOT Calculus](http://lampwww.epfl.ch/%7Eamin/dot/current_rules.pdf)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>テストについて、Scalaと。</title>
      <link>/slide/tesutonitsuite_Scalato_/</link>
      <pubDate>Tue, 12 Apr 2016 22:31:51 +0900</pubDate>
      
      <guid>/slide/tesutonitsuite_Scalato_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# テストについて、Scalaと。
----------------------
サイバーエージェント アドテクスタジオ  
ScalaMeetUp テスト回

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
   + 基盤開発グループでScalaで基盤開発してます
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# Scalaのテスト
---------------

* ScalaTest
  + 機能豊富
  + 複数のテストスタイルを選べる
  + 他のフレームワークとの統合がある
* Specs2
  + 普通に使いやすい
* 他にもScalaCheck、JUnit、Gatlingなどなど


# ScalaTestのスタイルたち
-----------

* FunSuite
  + xUnitっぽいらしい
* FlatSpec
  + xUnitからBDDに移行した人向けらしい
* FunSpec
  + RSpecっぽいBDD用の


# ScalaTestのスタイルたち
-----------

* WordSpec
  + Specs2に似てる。
* FreeSpec
  + 何段にでもネスト出来る。自由。
* Spec
  + テスト=メソッド。速いらしい。


# ScalaTestのスタイルたち
-----------
* PropSpec
  + プロパティベースのテスト。ScalaCheckとの統合。
* FeatureSpec
  + シナリオテスト。

# その他の機能
-------------

* mockitoのシュガー
* Matcher DSL
* 複数のランナー（複数のツールとの統合）


# Axionのテスト
コード紹介を多めに
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 単体テスト
---------------

* 普通の単体テストはWordSpec
* ホーアの3つ組に基いて事前条件、コマンド、事後条件(不変条件)に分ける
  + 「{事前条件}が成り立つ時{コマンド}を実行し、停止するなら{事後条件(不変条件)}が成り立つ」の列挙
* [テストについて考えてみた | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2016/03/01/tesutonitsuitekangaetemita/)
* コマンドの実行と事後条件への表明を明確に分離
* テストの分け方に試行錯誤


# 事前条件
----------

* 基本的にはmockitoをフルに使う
* テストは並行に走るのでテストケース毎にモックを準備
* コンテキストの共有は基本的にはしない
  + 情報の局所性を上げて何をテストするかを理解しやすくする
  + 逆にノイズが乗ってわかりにくい？
* メソッドの実行に必要な引数と環境全てを構築する


# コマンドの実行
---------------

* 例外が起きないことだけ表明する
* 結果はvarに保存して外に持ち出す。


# 事後条件
----------

* コマンドを実行した結果に対する表明
* 環境に対する表明
  + 環境が変化した/しなかった
  + 依存オブジェクトのメソッドが呼ばれた/なかった


メソッド毎にテストケースをグルーピング

``` scala
&#34;Class#method&#34; when {
  &#34;precondition&#34; should {
    ...
    var ret: Type = null
    &#34;method invocation&#34; in {
      ret = ...
    }

    &#34;post conditions&#34; in {
      ...
    }
  }
}

```


# Tips
------

* エディタでテンプレートを用意しておくと楽
  + ensimeのテストテンプレートとか
* やや冗長でも頭を使わずに書ける/理解出来るテストを書く


# ユーティリ
---------------

* ユーティリティのテストはPropSpec
* ユーティリティ = 汎用的(文脈に依存しない)、副作用がない、小さい
  + まさにプロパティベースのテストに向く
* ほとんどGenerator Driven Test
  + 半分くらいScalaCheckの機能を使う
* 一部Tebale Driven Test
  + Generatorがコーナーケースを生成してくれない時がある


# 他のテスト
------------

* インテグレーションテスト/パフォーマンステストはGatling(の予定)
* Gatlingでエラーレート、パーセンタイル、レスポンスなどをテスト出来る
* パフォーマンステストは実行インスタンスを固定しないといけない問題が…
* シナリオテストはない(APIがReadのみなため)


# 他のテスト
---------------

* AxionはThriftプロトコルだがGatlingのAPIをいくつか実装すればGatlingを独自プロトコルに対応出来る
  + 実装量はほとんどない
  + 2~3個DSLを作るだけ
  + 簡単とはいってない(ドキュメントがないつらさ)
* Gatlingのおかげでパフォーマンスに対する表明やリクエスト毎のチェックなどが簡単
* そのうちノウハウを公開するかも？
  + 2.1.Xと2.2.XでAPIが違う問題も…


# まとめ
--------

* ScalaTestを紹介したよ
* ScalaTestの実用例を紹介したよ
* Gatlingについて紹介したよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>HAMT ~ イミュータブルで高速なハッシュマップ ~</title>
      <link>/slide/HAMT/</link>
      <pubDate>Sun, 31 Jan 2016 16:17:35 +0900</pubDate>
      
      <guid>/slide/HAMT/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# &lt;span style=&#34;font-size: 90%&#34;&gt;Hash-Array Mapped Trie&lt;/span&gt;
----------------------
 ~ イミュータブルで高速なハッシュマップ ~  
サイバーエージェント AdTech Scala Meetup LT大会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 基盤開発グループの新卒
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# &lt;span style=&#34;font-size: 60%&#34;&gt;scala.collections.immutable.HashMap&lt;/span&gt;
-------------------------------------

* 今日の話題。これの実装をみていく。
* イミュータブル
* キー-バリューペア
* 値を追加する度に新たなハッシュマップを作る &lt;!-- .element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;


# HashMap
----------------

* `O(1)`のアクセス効率
* 空間効率は悪い
* ハッシュ関数が定義出来れば何でもキーに使える
* 普通はミュータブルに使う
  + 大量のメモリをアロケートするのでコピーはつらい


# メモリ効率悪そう？
-------------------------

```scala
val hash = HashMap.empty + (3 -&gt; 1)
// +---+---+---+---+---+----
// | / | 3 | / | / | / | ...
// +---+---+---+---+---+----
//       |
//      +-+
//      |1|
//      +-+
```


# メモリ効率悪そう？
-------------------------

```scala
val hash2 = hash + (2 -&gt; 2)
// +---+---+---+---+---+----
// | / | 3 | / | / | / | ...
// +---+---+---+---+---+----
//       |
//      +-+
//      |1|
//      +-+
//  &gt; Copy &lt;
// +---+---+---+---+---+----
// | / | 3 | / | 2 | / | ...
// +---+---+---+---+---+----
//       |       |
//      +-+     +-+
//      |1|     |2|
//      +-+     +-+
```


# メモリ効率的データ構造?
----------------------------
## TreeMap

* O(log(n))のアクセス効率
* 空間効率はほどほど
  + イミュータブルに使えばかなり良い
  + 部分構造を再利用出来る
* 全順序関数が定義出来れば何でもキーに出来る
* キーが複数回比較される問題がある


# キー同士の比較
---------------
長いキー同士の比較がO(log(n))回走る可能性がある

```scala
treeMap.get(&#34;very long ... key1&#34;)

        ....
       /
&#34;very long ... key3&#34; -&gt; &#34;value3&#34;
       \
   &#34;very long ... key2&#34; -&gt; &#34;value2&#34;
         \
      &#34;very long ...key1&#34; -&gt; &#34;value1&#34;
```


# HashMap vs TreeMap
-----------------

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th&gt;HashMap&lt;/th&gt;&lt;th&gt;TreeMap&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;アクセス効率&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34; data-fragment-index=&#34;1&#34;&gt;`O(1)`&lt;/td&gt;&lt;td&gt;`O(log(n))`&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;イミュータブルな時の空間効率&lt;/th&gt;&lt;td&gt;悪い(毎回コピー)&lt;/td&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;良い(部分構造を共有)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;キーの比較&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;定数回&lt;/td&gt;&lt;td&gt;`O(log(n))`回&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;キーの要件&lt;/th&gt;&lt;td class=&#34;fragment highlight-red&#34;  data-fragment-index=&#34;1&#34;&gt;Hash関数が定義されている&lt;/td&gt;&lt;td&gt;全順序関数が定義されている&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

# &lt;span style=&#34;font-size: 90%&#34;&gt;Hash-Array Mapped Trie&lt;/span&gt;
------------------------

* `O(1)`のアクセス効率
* 部分構造を共有してメモリ効率も良い
* キーの比較は定数回
* Hash関数が定義されていればキーに出来る


# 動作
------

* ざっくり言うと、「Hashして分割してトライ」


# 動作
------
## Hashする

* 40bitくらいの値が生成される

``` scala
hash(&#34;key&#34;)
// =&gt; 0b10101101010101001010110101010100
```


# 動作
------
## 分割する

* 下位から5bit毎に分割する
  + 5bit = 0 ~ 31
  + 32分木になる

```
11111 00010 10110 10101 01001 01011 01010 10100
```


# 動作
------
## トライ

* 32分のトライ木になる
* トライ木の実装は32bitのbitmapを使ったArray Mapped Trieを使う


(図が分かりづらいというか不適切)

```
8     7     6     5     4     3     2     1
11111 00010 10110 10101 01001 01011 01010 10100

1    2    3  4
   ...
  /
10100     ...
  \        /
   \    01011
    \   /  \
     \ /   01001....
     01010
       \
        ...
```


# 特徴
------

* ハッシュ値が固定長なので`O(1)`で動作
* Treeなので部分構造の共有が簡単
* 木を辿る時の比較はhash値（の一部）なので高速
* キーに全順序がなくてもハッシュ関数さえ定義されていれば木を構築出来る


# まとめ
--------

* Scalaのimmutable.HashMapはコピーしても高速だよ
* 裏で動くアルゴリズムを紹介したよ
  + ざっくりなので本物はもう少し工夫してる
  + prefix treeになってる


# 参考
------

* PDF [Ideal Hash Trees](http://lampwww.epfl.ch/papers/idealhashtrees.pdf)
  + HAMTの元論文
* [HAMT(Hash Array Mapped Trie) - sileのブログ](http://sile.hatenablog.jp/entry/20100926/1285467529)
  + HAMTの解説ブログ
* PDF [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections](http://michael.steindorfer.name/publications/oopsla15.pdf)
  + HAMTを改善したCHAMPというデータ構造の論文。Clojureにこれが入りそう。
* [Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections | the morning paper](http://blog.acolyer.org/2015/11/27/hamt/)
  + CHAMPを解説したブログ

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>DSLとTagless Final</title>
      <link>/slide/DSLtoTagless_Final/</link>
      <pubDate>Sun, 13 Dec 2015 22:42:39 +0900</pubDate>
      
      <guid>/slide/DSLtoTagless_Final/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# DSLとTagless Final
----------------------
サイバーエージェント アドテクスタジオ  
Scala Meet Up 2015-12-18

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒エンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
   - Scalaは初心者 ※ [Scala初心者の新卒が頑張ってLispを作ってみた](http://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/)

# 注意
------

* Scala初心者なのでScalaではなくScalaっぽい疑似コードで説明します
  + ~~コード例動かす時間が無かっただけ~~
* Scala初心者なのでScalaのコードは少なめに説明します


# DSLを作る
-----------

以下のようなHTTPなユーザをエミュレートするDSLを考える

``` scala
val scenario = and(
  get(&#34;/&#34;),
  get(&#34;/users&#34;).andThen(res =&gt;
    post(&#34;/follow&#34;, first(users.getJsonData))))
val Right(_) = runScenario(scenario, &#34;user&#34;)
```


# DSLを作る
-----------

普通は以下のようなAST作ってをラップする

``` scala
trait ScenarioDSL
sealed case class Get(url: String) extends ScenarioDSL
sealed case class Post(url: String, data: JSON) extends ScenarioDSL
sealed case class And(first, ScenarioDSL, second ScenarioDSL) extends ScenarioDSL
sealed case class AndThen(first: ScenarioDSL,
   callBack: (Response) =&gt; ScenarioDSL) extends ScenarioDSL

def get(url: String): ScenarioDSL= Get(url)
....

```


# DSLを作る
-----------

そして`runScenario`を作る

``` scala
def runScenario(scenario: ScenarioDSL, user: String) = {
  scenario match {
    Get(url) =&gt; Client.getInstance(user).get(url)
    Post(url) =&gt; Client.getInstance(user).post(url)
    And(first, second) =&gt; {runSenario(first, user); runSenario(second, user)}
    ....
  }
}


```




# DSLを便利に
-------------

例えば、このDSLを`curl`コマンド関数を追加する

``` scala
def toCurl(scenario: ScenarioDSL, user: String) =
  val auth = makeAuth(user)
  scenario match {
    Get(url) =&gt; &#34;curl ${auth} ${SERVICE_HOST}/url&#34;
    Post(url) =&gt; &#34;curl ${auth} -XPOST ${SERVICE_HOST}/url&#34;
    And(first, second) =&gt; toCurl(first) + &#34;\n&#34; + toCurl(second)
    ....
  }
}

```


# DSLの拡張
-----------

このDSLに新たに`select`を追加する

``` scala
val scenario = and(
  get(&#34;/&#34;),
  select(get(&#34;/users&#34;),
         post(&#34;/update&#34;)))
val _ = runScenario(scenario, &#34;user&#34;)
```


# Expression Problem
-------------------

この時に問題が出る

* DSLを使う全てのコードに変更が必要
  + `runScenario`と`toCurl`で`select`に対応する
* DSLそのものに手を加える必要がある
  + DSLがsealed traitされてる
  + そもそも、DSLがライブラリだったら変更出来るの？
* 実際には使ってなくても全ての関数で新しい機能に対応しないといけない
  + `toCurl`では`select`に対応しないとか
  + 逆に、`toCurl`がプラグインでコードいじれなかったらどうしよう

# Tagless Finalで解決出来るよ
----------------------------

* 元のコードをいじらず
* 必要な所だけを記述して
* しかも元々の実装よりも速い

DSLの作り方があります。それは型クラスを使ったやり方です。


# 型クラスの復習
---------------

型クラスは

* 型の振る舞うインターフェースを定めて
* インスタンスの型ごとに「後付けで」実装を与えると
* 多相的に扱えるアドホックポリモーフィズム

でした


# 型クラスの復習
---------------

``` rust
trait Hello { //型クラス
  fn hello(&amp;self) -&gt; String;
}

impl Hello for isize { //isize型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;I&#39;m {} years old&#34;, self)}
}
impl &lt;&#39;a&gt;Hello for &amp;&#39;a str {//&amp;str型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;My name is {}&#34;, self)}
}
fn main() {
  println!(&#34;{}&#34;, 23.hello());     // =&gt; &#34;I&#39;m 23 years old&#34;
  println!(&#34;{}&#34;, &#34;κeen&#34;.hello()); // =&gt; &#34;My name is κeen&#34;
}
```


# DSLをRustに翻訳
-------------

Scalaで型クラスを説明するとややこしいので一旦先のDSL例をRustに翻訳します

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getJsonData().first)));
runScenario(scenario, &#34;user&#34;).unwrap();
```


# Rustに翻訳
-------------
DSLのASTはこうなります。

``` rust
enum ScenarioDSL {
  Get{url: String},
  Post{url: String, data: RequestData},
  And{first: Box&lt;ScenarioDSL&gt;, second: Box&lt;ScenarioDSL&gt;},
  AndThen{first: Box&lt;ScenarioDSL&gt;,
   callBack: FnOnce&lt;(Scenario, Request) -&gt; ScenarioDSL&gt;},
}
```

# Rustに翻訳
-------------
runScenarioはこうなります。

``` rust
fn runScenario(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; Result&lt;()&gt; {
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; Client::instance(user).get(url),
    &amp;ScenarioDSL::Post{ref url} =&gt; Client::instance(user).post(url),
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      try!(runSenario(first));
      runSenario(second)
    },
   ...
  };
}
```


# Rustに翻訳
-------------
`toCurl`はこうなります

``` rust
fn toCurl(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; String {
  let auth = makeAuth(user)
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; format!(&#34;curl {} {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::Post{ref url} =&gt; format!(&#34;curl {} -X POST {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      let first_str = toCurl(first, user);
      let second_str = toCurl(second, user);
      format!(&#34;{}\n{}&#34;, first_str, second_str)
    },
   ...
  }
}
```


# Tagless Final
---------------

Rustの準備が終わったのでTagless Finalの説明に入ります。


# Tagless Final
----------------

* ASTをデータではなく関数で表わす
* 同じ関数でも欲しい結果によって計算を変えるために型クラスを使う
* どの型クラスのインスタンスとして扱うかで結果を変える
  + そもそもASTは計算を抽象化してデータにしたもの。
  + 抽象的な計算があるならデータにする必要はない

* 型クラスでジェネリックに作って
* 欲しい型を伝えるだけで挙動が変わる


# 型クラス
----------
DSLの文法の型クラスを定義する。  
DSLっぽく見せるため、ラッパを書く(Rust特有)。


``` rust
trait ScenarioSYM {
  fn get(url: String) -&gt; Self;
  fn post(url: String) -&gt; Self;
  fn and(first: Self, second: Self) -&gt; Self;
  ...
}

fn get&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::get(url)}
fn post&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::post(url)}
fn and&lt;C: ScenarioSYM&gt;(first: C, second: C) -&gt; C {C::and(first, second)}
...
```



# `runScenario`
------
結果に`Result`型が結果として欲しいなら`Result`型に`ScenarioSYM`を実装する

```rust
impl ScenarioSYM for Result&lt;()&gt; {
  fn get(self,url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn runScenario(res: Result&lt;()&gt;) -&gt; Result&lt;()&gt; {
  res
}
```


# `toCurl`
----------
`String`が欲しいなら`String`に実装すれば良い。

``` rust
impl ScenarioSYM for String {
  fn get(self, url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn toCurl(str: String) -&gt; String {
  str
}
```


# 完成形
--------

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getData().iter().next())));
  // ↑ここまではジェネリックなScenarioSYM型
  // ↓ここで呼ばれることでResult&lt;()&gt;型にインスタンス化される
runScenario(scenario, &#34;user&#34;).unwrap();
```


# DSLの拡張
-----------

拡張したい文法のDSLを定義して、欲しいものに実装するだけ。

`runScenario`に変更は要らないしサポートしない`toCurl`は気にしなくて良い。

``` rust
trait SelectSYM {
  fn select(self, first: Self, second: Self) -&gt; Self;
}

impl SelectSYM for Result&lt;()&gt; {
  fn select(self, first: Self, second: Self) -&gt; Self {...}
}
```


# Tagless Finalまとめ
---------------------

* この方式だと実行時にタグでパターンマッチしないので速い
* DSLの拡張も機能の拡張も容易
* 型クラス便利


# ScalaでのTagless Final
------------------------
Rustで分かりやすく解説したのでScalaでどうなるか見ていきます。

まずは型クラスを定義

``` scala
trait ScenarioSYM[C] {
  def get(self: C, url: String): C
  def post(self: C, url: String): C
  ...
}
def get(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.get(self, url)
def post(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.post(self, url)
...
```


# `runScenario`
------

``` scala
implicit val resultScenario = new ScenarioSYM[Either[Err, ()]] {
  def get(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  def post(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  ...
}

def runScenario(ast: Either[Err, ()], user: String)
      (implicit i: ScenarioSYM[Either[Err, ()]]) = ast
```


# 完成形
--------
Scalaの型クラスの制約上最初の例と少し異なる
(`val`じゃなくて`implicit`を取る`def`になる)


``` scala
def scenario(implict i: ScenarioSYM[C]) = Scenario
   get(&#34;/&#34;)
   get(&#34;/users&#34;) andThen((scenario, res) =&gt;
    scenario post(&#34;/follow&#34;, first(users.getJsonData)))
val Right(_) = runScenario(scenario, &#34;user&#34;)

```


# まとめ
--------

* Expression Problemについて説明した
* Tagless Finalを紹介した
* 型クラス便利
* Rust便利
* [参考](http://okmij.org/ftp/tagless-final/course/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>