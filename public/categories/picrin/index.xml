<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Picrin on κeenのHappy Hacκing Blog</title>
    <link>//KeenS.github.io/categories/picrin/</link>
    <description>Recent content in Picrin on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sat, 10 Jan 2015 09:40:51 +0000</lastBuildDate>
    <atom:link href="//KeenS.github.io/categories/picrin/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>picrinのcodegenプロセスを説明してみる</title>
      <link>//keens.github.io/blog/2015/01/10/picrin-codegen-explanation</link>
      <pubDate>Sat, 10 Jan 2015 09:40:51 +0000</pubDate>
      
      <guid>//keens.github.io/blog/2015/01/10/picrin-codegen-explanation</guid>
      <description>

&lt;p&gt;今、picrinのcodegenプロセスに手を入れる機運が高まってます。picrinはバイトコードインタプリタなのでS式を渡されたらそれをバイトコードに変換する作業が必要です。それがcodegen。本当はcompileなんだけどpicrinのCのソースコードのコンパイルと紛らわしいからcodegen。私も完全にはプロセスを理解してないので説明して理解度を試しつつ問題点を洗い出します。&lt;/p&gt;

&lt;h1 id=&#34;関連ファイル:693fca136e4ca5c28a91dc5895343393&#34;&gt;関連ファイル&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;extlib/benz/codegen.c&lt;/li&gt;
&lt;li&gt;extlib/benz/macro.c&lt;/li&gt;
&lt;li&gt;(extlib/benz/read.c)&lt;/li&gt;
&lt;li&gt;(extlib/benz/vm.c)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;おおまかな流れ:693fca136e4ca5c28a91dc5895343393&#34;&gt;おおまかな流れ&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;(&lt;code&gt;read&lt;/code&gt;する)&lt;/li&gt;
&lt;li&gt;マクロ展開する&lt;/li&gt;
&lt;li&gt;コードの解析をする&lt;/li&gt;
&lt;li&gt;バイトコードを生成する&lt;/li&gt;
&lt;li&gt;(実行する)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;今回説明するのは2~4です。&lt;/p&gt;

&lt;h1 id=&#34;マクロ展開:693fca136e4ca5c28a91dc5895343393&#34;&gt;マクロ展開&lt;/h1&gt;

&lt;p&gt;入力:Schemeの式&lt;br /&gt;
出力:マクロ展開済みのS式&lt;br /&gt;
副作用:マクロテーブルの更新、ライブラリテーブルの更新、その他マクロ毎の副作用&lt;/p&gt;

&lt;p&gt;extlib/benz/macro.cに処理があります。&lt;/p&gt;

&lt;p&gt;メインの部分はこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
macroexpand_node(pic_state *pic, pic_value expr, struct pic_senv *senv)
{
  switch (pic_type(expr)) {
  case PIC_TT_SYMBOL: {
    return macroexpand_symbol(pic, pic_sym(expr), senv);
  }
  case PIC_TT_PAIR: {
    pic_value car;
    struct pic_macro *mac;

    if (! pic_list_p(expr)) {
      pic_errorf(pic, &amp;quot;cannot macroexpand improper list: ~s&amp;quot;, expr);
    }

    car = macroexpand(pic, pic_car(pic, expr), senv);
    if (pic_sym_p(car)) {
      pic_sym tag = pic_sym(car);

      if (tag == pic-&amp;gt;rDEFINE_SYNTAX) {
        return macroexpand_defsyntax(pic, expr, senv);
      }
      else if (tag == pic-&amp;gt;rLAMBDA) {
        return macroexpand_defer(pic, expr, senv);
      }
      else if (tag == pic-&amp;gt;rDEFINE) {
        return macroexpand_define(pic, expr, senv);
      }
      else if (tag == pic-&amp;gt;rQUOTE) {
        return macroexpand_quote(pic, expr);
      }

      if ((mac = find_macro(pic, tag)) != NULL) {
        return macroexpand_node(pic, macroexpand_macro(pic, mac, expr, senv), senv);
      }
    }

    return pic_cons(pic, car, macroexpand_list(pic, pic_cdr(pic, expr), senv));
  }
  default:
    return expr;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;S式を行きがけ順でマクロ展開していきます。&lt;/p&gt;

&lt;p&gt;リストの先頭にあるものをマクロと疑って展開しようとしますが、見ての通り&lt;code&gt;define-syntax&lt;/code&gt;、&lt;code&gt;lambda&lt;/code&gt;、&lt;code&gt;define&lt;/code&gt;、&lt;code&gt;quote&lt;/code&gt;だけは特別扱いされています。このスペシャルフォーム達は引数に括弧つきのものを取ったり引数を全く触ってほしくなかったりするのでマクロ展開時に特別な処理がされるんですね。他はシンボルは変数名(identifier)として処理し、リストとシンボル以外のものはそのまま返します。&lt;/p&gt;

&lt;p&gt;ここに1つ問題があります。&lt;code&gt;find_macro&lt;/code&gt;です。&lt;a href=&#34;https://github.com/picrin-scheme/picrin/issues/234&#34;&gt;イシューにも挙げられて&lt;/a&gt;いますが、マクロを定義したあと同じ名前の手続を定義したら手続で上書きされる筈なのにマクロとして展開されてしまいます。これはマクロと手続きで別のテーブルを持っていることに起因します。ちゃんと上書きされるようにするにはマクロも変数束縛テーブルに登録すれば解決出来るのかなと思ってます。&lt;/p&gt;

&lt;h2 id=&#34;シンボル:693fca136e4ca5c28a91dc5895343393&#34;&gt;シンボル&lt;/h2&gt;

&lt;p&gt;変なことはしてません。スコープを遡っていき、最初に見付かったインターンされたシンボルを返します。見付からなかった(=未定義のシンボルだった)ときは新たなgensymを返します。&lt;/p&gt;

&lt;h2 id=&#34;define-syntax:693fca136e4ca5c28a91dc5895343393&#34;&gt;&lt;code&gt;define-syntax&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
macroexpand_defsyntax(pic_state *pic, pic_value expr, struct pic_senv *senv)
{
  pic_value var, val;
  pic_sym sym, rename;

  if (pic_length(pic, expr) != 3) {
    pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
  }

  var = pic_cadr(pic, expr);
  if (! pic_sym_p(var)) {
    pic_errorf(pic, &amp;quot;binding to non-symbol object&amp;quot;);
  }
  sym = pic_sym(var);
  if (! pic_find_rename(pic, senv, sym, &amp;amp;rename)) {
    rename = pic_add_rename(pic, senv, sym);
  } else {
    pic_warnf(pic, &amp;quot;redefining syntax variable: ~s&amp;quot;, pic_sym_value(sym));
  }

  val = pic_cadr(pic, pic_cdr(pic, expr));

  pic_try {
    val = pic_eval(pic, val, pic-&amp;gt;lib);
  } pic_catch {
    pic_errorf(pic, &amp;quot;macroexpand error while definition: %s&amp;quot;, pic_errmsg(pic));
  }

  if (! pic_proc_p(val)) {
    pic_errorf(pic, &amp;quot;macro definition \&amp;quot;~s\&amp;quot; evaluates to non-procedure object&amp;quot;, var);
  }

  define_macro(pic, rename, pic_proc_ptr(val), senv);

  return pic_none_value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;手を入れる候補。やってることは単純で、&lt;code&gt;(define-syntax &amp;lt;name&amp;gt; &amp;lt;definition&amp;gt;)&lt;/code&gt;の形で引数を渡される筈だからnameをdefinitionに関連づけてマクロとして登録します。返り値はnone。返り値はnone。大事なことなので2回言いました。&lt;/p&gt;

&lt;p&gt;一応実行時にはマクロ展開は全て終了してる筈なので&lt;code&gt;define-syntax&lt;/code&gt;をマクロ展開時に消し去っても良い筈なんですが、気持ち悪いですよね。コアを小さくするという意味では正解なんですが…。あとファイルのコンパイルを考えた時に&lt;code&gt;define-syntax&lt;/code&gt;をファイルの外に持ち出せなくなるという実用上の問題もあります。&lt;/p&gt;

&lt;p&gt;あと、definitionがマクロ展開だけで止まってしまうと困るのでdefinitionだけはevalしているのもキモいポイントですね。&lt;/p&gt;

&lt;p&gt;改善案は&lt;code&gt;define&lt;/code&gt;と同じようにすること。そのためにはマクロ展開後の処理(analyze、codegen、VM命令)にも&lt;code&gt;define-syntax&lt;/code&gt;用の処理を入れる必要があって、面倒。&lt;/p&gt;

&lt;h2 id=&#34;lambda:693fca136e4ca5c28a91dc5895343393&#34;&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt;の扱いは面倒です。一番分かり易い例は再帰マクロですかね。マクロの定義中に定義中のマクロが見えてる必要があります。この解決策として&lt;code&gt;lambda&lt;/code&gt;だけはマクロ展開を遅延(defer)します。じゃあいつ遅延されたマクロが展開されるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;pic_value
pic_macroexpand(pic_state *pic, pic_value expr, struct pic_lib *lib)
{
  struct pic_lib *prev;
  pic_value v;

#if DEBUG
  puts(&amp;quot;before expand:&amp;quot;);
  pic_debug(pic, expr);
  puts(&amp;quot;&amp;quot;);
#endif

  /* change library for macro-expansion time processing */
  prev = pic-&amp;gt;lib;
  pic-&amp;gt;lib = lib;

  lib-&amp;gt;env-&amp;gt;defer = pic_nil_value(); /* the last expansion could fail and leave defer field old */

  v = macroexpand(pic, expr, lib-&amp;gt;env);

  macroexpand_deferred(pic, lib-&amp;gt;env);

  pic-&amp;gt;lib = prev;

#if DEBUG
  puts(&amp;quot;after expand:&amp;quot;);
  pic_debug(pic, v);
  puts(&amp;quot;&amp;quot;);
#endif

  return v;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;macroexpand&lt;/code&gt;の後です。&lt;code&gt;macroexpand&lt;/code&gt;は&lt;code&gt;macroexpand_node&lt;/code&gt;の薄いラッパと思って下さい。&lt;/p&gt;

&lt;p&gt;遅延されたマクロ展開は&lt;code&gt;senv-&amp;gt;defer&lt;/code&gt;にpushされ、&lt;code&gt;macroexpand_deferred&lt;/code&gt;で1つずつ&lt;code&gt;macroexpand_lambda&lt;/code&gt;されます。&lt;code&gt;macroexpand_lambda&lt;/code&gt;はまあ、想像通りです。formalをα変換したあとformalとbodyをマクロ展開します。α変換は&lt;code&gt;senv&lt;/code&gt;にシンボル -&amp;gt; gensymのキーペアを突っ込むだけです。返り値は&lt;code&gt;(lambda formal body)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;define:693fca136e4ca5c28a91dc5895343393&#34;&gt;define&lt;/h2&gt;

&lt;p&gt;比較的単純です。&lt;code&gt;(define name value)&lt;/code&gt;の他に&lt;code&gt;(define (name formal) body)&lt;/code&gt;のMIT記法にも対応する必要があるのでマクロ展開時に特別扱いされてます。&lt;code&gt;(define name value)&lt;/code&gt;を返り値として返します。MIT記法もこの形に正規化されます。&lt;/p&gt;

&lt;h2 id=&#34;quote:693fca136e4ca5c28a91dc5895343393&#34;&gt;quote&lt;/h2&gt;

&lt;p&gt;特に語る事はないです。&lt;/p&gt;

&lt;h2 id=&#34;他のマクロ:693fca136e4ca5c28a91dc5895343393&#34;&gt;他のマクロ&lt;/h2&gt;

&lt;p&gt;Schemeのマクロ展開は簡単で、マクロ手続をbody、展開場所の環境、定義場所の環境の3つを引数として呼び出せば終りです。勿論&lt;code&gt;macroexpand_node&lt;/code&gt;を見て分かるように最後まで展開します。picrinはCommon Lisp風の伝統的マクロもサポートしてるので伝統的マクロだった時はbodyだけを引数として呼び出します。&lt;/p&gt;

&lt;h2 id=&#34;蛇足:693fca136e4ca5c28a91dc5895343393&#34;&gt;蛇足&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;define-syntax&lt;/code&gt;だけを指摘しましたが、マクロ展開後にnoneになるマクロは他にもあります。library関係全部です。個人的にはやつらもVM命令まで残すべきだと思ってます。&lt;/p&gt;

&lt;p&gt;因みにもう1つlibrary関係の問題があります。&lt;code&gt;define-library&lt;/code&gt;直下の&lt;code&gt;begin&lt;/code&gt;についてです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-library (hoge)
  (begin
    (define foo ...)
    (define bar ...)
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようなコードを考えます。&lt;code&gt;define-library&lt;/code&gt;直下の&lt;code&gt;begin&lt;/code&gt;は他とセマンティクスが違って、&lt;code&gt;begin&lt;/code&gt;内のコードをトップレベルで定義されたかのように扱う必要があります。しかしpicrinは普通の&lt;code&gt;begin&lt;/code&gt;と同じように扱っています。これがどのような違いを産むかというと、コンパイル順を見れば分かり易いです。&lt;/p&gt;

&lt;p&gt;仕様: fooのマクロ展開-&amp;gt;fooの解析-&amp;gt;fooのコード生成-&amp;gt;barのマクロ展開-&amp;gt;barの解析-&amp;gt;barのコード生成&lt;br /&gt;
picrin: fooのマクロ展開-&amp;gt;barのマクロ展開-&amp;gt;fooの解析-&amp;gt;barの解析-&amp;gt;fooのコード生成-&amp;gt;barのコード生成&lt;/p&gt;

&lt;p&gt;picrinのコンパイル順序だとマクロ展開を先にやってしまうのでマクロ展開中に同じ&lt;code&gt;begin&lt;/code&gt;内で&lt;code&gt;define&lt;/code&gt;されたシンボルが見えなくなってしまいます。尚、後述しますが今のpicrinはこのコンパイル順序のおかげで手続の相互参照が可能になってます。ここもどうにかしないといけない。&lt;/p&gt;

&lt;h1 id=&#34;コード解析:693fca136e4ca5c28a91dc5895343393&#34;&gt;コード解析&lt;/h1&gt;

&lt;p&gt;入力:マクロ展開済みのS式&lt;br /&gt;
出力:中間表現&lt;br /&gt;
副作用:無し&lt;/p&gt;

&lt;p&gt;extlib/benz/codegen.cに処理があります。&lt;/p&gt;

&lt;p&gt;ここの処理ではS式をVM命令に近いS式に書き換えます。&lt;code&gt;(+ 1 x)&lt;/code&gt;が&lt;code&gt;(+ (quote 1) (gref x))&lt;/code&gt;になるなど。この解析後のS式は特に呼び名はなさそうなので中間表現と呼んでおきます。&lt;/p&gt;

&lt;p&gt;中間表現には&lt;code&gt;cons&lt;/code&gt;、&lt;code&gt;car&lt;/code&gt;などの16の基本的な手続に対応する命令や&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;define&lt;/code&gt;などの6つのスペシャルフォームの他、&lt;code&gt;call&lt;/code&gt;、&lt;code&gt;tailcall&lt;/code&gt;、&lt;code&gt;call-with-values&lt;/code&gt;、&lt;code&gt;tailcall-with-values&lt;/code&gt;の4つの手続呼び出し命令、&lt;code&gt;gref&lt;/code&gt;、&lt;code&gt;lref&lt;/code&gt;、&lt;code&gt;cref&lt;/code&gt;の3つの変数参照、&lt;code&gt;return&lt;/code&gt;があります。合計30の命令です。JIT化も視野に入れてるので基本命令は少なくする方針なんでしょう。また、組み込みも意識しているのでその気になればコアを小さく出来るようにする意味もあるのかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gref&lt;/code&gt;はグローバル変数、&lt;code&gt;lref&lt;/code&gt;はローカル変数、&lt;code&gt;cref&lt;/code&gt;はクcaptured変数を参照します。ここでピンときた方も居るかと思いますが、コード解析がスコープ周りを担当しています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;analyze_*&lt;/code&gt;系は&lt;code&gt;analyze_state&lt;/code&gt;を持ち回ししますが、こいつはpicrin VMとスコープを表現する構造体の他に中間命令のシンボル(の一部)のキャッシュや中間命令にそのまま翻訳されるべき手続(&lt;code&gt;cons&lt;/code&gt;や&lt;code&gt;car&lt;/code&gt;)のキャッシュを持ちます。手続はライブラリに属するのでキャッシュを捜すときに少し特別な処理が入ってますね。中間命令のシンボルのキャッシュが一部だけなのは他は&lt;code&gt;pic_state&lt;/code&gt;構造体が既に持ってるからですね。&lt;/p&gt;

&lt;p&gt;さて、本体はやはり&lt;code&gt;analyze_node&lt;/code&gt;ですが30命令分のifを持つので少し大きいですね。載せるのをやめて面白いやつだけ取り上げましょうか。どうでもいいけどこれ、caseじゃなくてif elseなので並び換えたら高速化しそうですね。&lt;/p&gt;

&lt;h2 id=&#34;変数:693fca136e4ca5c28a91dc5895343393&#34;&gt;変数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;analyze_var&lt;/code&gt;がスコープの深さでgref、lref、crefに振り分けます。&lt;code&gt;analyze_*_var&lt;/code&gt;はgref、lref、crefを返すだけの関数。&lt;/p&gt;

&lt;p&gt;スコープを遡って変数を捜していき、変数が見付かったスコープの深さ=今いるスコープの深さならグローバル変数、、今いるスコープならローカル変数、それ以外なら捕捉変数です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_var(analyze_state *state, pic_sym sym)
{
  pic_state *pic = state-&amp;gt;pic;
  int depth;

  if ((depth = find_var(state, sym)) == -1) {
    pic_errorf(pic, &amp;quot;unbound variable %s&amp;quot;, pic_symbol_name(pic, sym));
  }

  if (depth == state-&amp;gt;scope-&amp;gt;depth) {
    return analyze_global_var(state, sym);
  } else if (depth == 0) {
    return analyze_local_var(state, sym);
  } else {
    return analyze_free_var(state, sym, depth);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにこれ、変数が見付からなかったらエラー出してますけどSchemeは仕様上は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (foo) (bar))
(define (bar) ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように後から定義することも可能なので仕様に準拠してないことになります。ここが手を入れるポイント2つ目。&lt;/p&gt;

&lt;p&gt;改善案は見付からなかった変数は一旦NOWHEREとかに束縛しておいてanalyze時にはエラーを出さない。実行時にNOWHEREに束縛された変数が出てくればエラー。&lt;/p&gt;

&lt;h2 id=&#34;define-1:693fca136e4ca5c28a91dc5895343393&#34;&gt;define&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_define(analyze_state *state, pic_value obj)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value var, val;
  pic_sym sym;

  if (pic_length(pic, obj) != 3) {
    pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
  }

  var = pic_list_ref(pic, obj, 1);
  if (! pic_sym_p(var)) {
    pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
  } else {
    sym = pic_sym(var);
  }
  var = analyze_declare(state, sym);

  if (pic_pair_p(pic_list_ref(pic, obj, 2))
      &amp;amp;&amp;amp; pic_sym_p(pic_list_ref(pic, pic_list_ref(pic, obj, 2), 0))
      &amp;amp;&amp;amp; pic_sym(pic_list_ref(pic, pic_list_ref(pic, obj, 2), 0)) == pic-&amp;gt;rLAMBDA) {
    pic_value formals, body_exprs;

    formals = pic_list_ref(pic, pic_list_ref(pic, obj, 2), 1);
    body_exprs = pic_list_tail(pic, pic_list_ref(pic, obj, 2), 2);

    val = analyze_defer(state, pic_sym_value(sym), formals, body_exprs);
  } else {
    if (pic_length(pic, obj) != 3) {
      pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
    }
    val = analyze(state, pic_list_ref(pic, obj, 2), false);
  }

  return pic_list3(pic, pic_symbol_value(pic-&amp;gt;sSETBANG), var, val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;手続を&lt;code&gt;define&lt;/code&gt;するときに上の後から定義(interreferencial definitionという)を一部の状況で実現するために束縛する値がlambdaかどうかで場合分けしています。lambdaの場合は&lt;code&gt;analyze_defer&lt;/code&gt;を使います。そうすることで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(begin
  (define (foo) (bar))
  (define (bar) ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けばbegin -&amp;gt; define foo -&amp;gt; define bar -&amp;gt; (analyze deferred) -&amp;gt; foo本体 -&amp;gt; bar本体
の順番に解析されることになるのでコンパイルが通ります。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;define&lt;/code&gt;された手続に名前をつける(シンボルと手続を関連付けるのではない)役割もあります。&lt;/p&gt;

&lt;h2 id=&#34;lambda-1:693fca136e4ca5c28a91dc5895343393&#34;&gt;lambda&lt;/h2&gt;

&lt;p&gt;また例の再帰定義とかで面倒なやつです。&lt;code&gt;analyze_lambda&lt;/code&gt;が引数のチェックだけしたら&lt;code&gt;analyze_defer&lt;/code&gt;に丸投げして、&lt;code&gt;analyze_defer&lt;/code&gt;はモックのエントリーポイントだけ返してdeferリストに処理をpushします。&lt;/p&gt;

&lt;p&gt;んで後から呼ばれる&lt;code&gt;analyze_deferred&lt;/code&gt;が1つずつ&lt;code&gt;analyze_procedure&lt;/code&gt;します。マクロ展開と微妙に名前が違うのが気になりますね。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;analyze_procedure&lt;/code&gt;が本体になるのですが、スコープを作るので少しややこしいことになってます。&lt;/p&gt;

&lt;h3 id=&#34;スコープと変数:693fca136e4ca5c28a91dc5895343393&#34;&gt;スコープと変数&lt;/h3&gt;

&lt;p&gt;スコープの解説をしてませんでしたね。変数を参照するときはスコープの関係で4種類出てきます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;グローバル変数 : トップレベルで&lt;code&gt;define&lt;/code&gt;されたもの&lt;/li&gt;
&lt;li&gt;ローカル変数 : lambda内で&lt;code&gt;define&lt;/code&gt;されたもの&lt;/li&gt;
&lt;li&gt;自由変数 : lambdaの外かつトップレベルでない変数&lt;/li&gt;
&lt;li&gt;引数 : lambdaの引数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;captureについて: 変数を導入した側から見たら「捕捉された変数」で、変数を参照する側から見たら「自由変数」です。&lt;/p&gt;

&lt;p&gt;さて、変数の種類を見たところで&lt;code&gt;analyze_procedure&lt;/code&gt;の定義を見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_procedure(analyze_state *state, pic_value name, pic_value formals, pic_value body_exprs)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value args, locals, varg, captures, body;

  assert(pic_sym_p(name) || pic_false_p(name));

  if (push_scope(state, formals)) {
    analyze_scope *scope = state-&amp;gt;scope;
    pic_sym *var;
    size_t i;

    args = pic_nil_value();
    for (i = xv_size(&amp;amp;scope-&amp;gt;args); i &amp;gt; 0; --i) {
      var = xv_get(&amp;amp;scope-&amp;gt;args, i - 1);
      pic_push(pic, pic_sym_value(*var), args);
    }

    varg = scope-&amp;gt;varg
      ? pic_true_value()
      : pic_false_value();

    /* To know what kind of local variables are defined, analyze body at first. */
    body = analyze(state, pic_cons(pic, pic_sym_value(pic-&amp;gt;rBEGIN), body_exprs), true);

    analyze_deferred(state);

    locals = pic_nil_value();
    for (i = xv_size(&amp;amp;scope-&amp;gt;locals); i &amp;gt; 0; --i) {
      var = xv_get(&amp;amp;scope-&amp;gt;locals, i - 1);
      pic_push(pic, pic_sym_value(*var), locals);
    }

    captures = pic_nil_value();
    for (i = xv_size(&amp;amp;scope-&amp;gt;captures); i &amp;gt; 0; --i) {
      var = xv_get(&amp;amp;scope-&amp;gt;captures, i - 1);
      pic_push(pic, pic_sym_value(*var), captures);
    }

    pop_scope(state);
  }
  else {
    pic_errorf(pic, &amp;quot;invalid formal syntax: ~s&amp;quot;, args);
  }

  return pic_list7(pic, pic_sym_value(pic-&amp;gt;sLAMBDA), name, args, locals, varg, captures, body);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコープを作ったあとは最初に引数をスコープに登録して本体内ででcapture出来るようにしてます。んで本体をanalyzeしてローカル変数と捕捉された変数を洗い出してます。&lt;/p&gt;

&lt;p&gt;因みにvargというのはCommon Lispでいう&amp;amp;restや&amp;amp;optionalを引っ括めたものです。&lt;/p&gt;

&lt;h2 id=&#34;begin:693fca136e4ca5c28a91dc5895343393&#34;&gt;begin&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_begin(analyze_state *state, pic_value obj, bool tailpos)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value seq;
  bool tail;

  switch (pic_length(pic, obj)) {
  case 1:
    return analyze(state, pic_none_value(), tailpos);
  case 2:
    return analyze(state, pic_list_ref(pic, obj, 1), tailpos);
  default:
    seq = pic_list1(pic, pic_symbol_value(pic-&amp;gt;sBEGIN));
    for (obj = pic_cdr(pic, obj); ! pic_nil_p(obj); obj = pic_cdr(pic, obj)) {
      if (pic_nil_p(pic_cdr(pic, obj))) {
        tail = tailpos;
      } else {
        tail = false;
      }
      seq = pic_cons(pic, analyze(state, pic_car(pic, obj), tail), seq);
    }
    return pic_reverse(pic, seq);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そんなに大したコードじゃないんですけど末尾呼出最適化のためのコードが垣間見えたので載せました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;自身が末尾位置にいれば&lt;code&gt;begin&lt;/code&gt;の最後の式は末尾位置になりますがそれ以外は必ず非末尾位置になるよねーってコードです。&lt;/p&gt;

&lt;h1 id=&#34;バイトコード生成:693fca136e4ca5c28a91dc5895343393&#34;&gt;バイトコード生成&lt;/h1&gt;

&lt;p&gt;入力:中間表現&lt;br /&gt;
出力:バイトコード&lt;br /&gt;
副作用:無し&lt;/p&gt;

&lt;p&gt;extlib/benz/codegen.cに処理があります。&lt;/p&gt;

&lt;p&gt;ここの処理では中間表現をスタックベースのpicrin VM命令に変換します。&lt;/p&gt;

&lt;h2 id=&#34;vm命令やlambdaの内部表現:693fca136e4ca5c28a91dc5895343393&#34;&gt;VM命令やlambdaの内部表現&lt;/h2&gt;

&lt;h3 id=&#34;vm命令フォーマット:693fca136e4ca5c28a91dc5895343393&#34;&gt;VM命令フォーマット&lt;/h3&gt;

&lt;p&gt;フォーマットは3種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct pic_code {
  enum pic_opcode insn;
  union {
    int i;
    char c;
    struct {
      int depth;
      int idx;
    } r;
  } u;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見ての通り命令番号(opcode)+&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;char&lt;/li&gt;
&lt;li&gt;int2つ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;になっています。因みに普通使われるのは1. intで、2. charはOP_PUSHCHARのみ、3. int2つはOP_CREFとOP_CSETのみに使われます。また、引数(?)を全く持たない命令もあります(スタックマシンなため)。&lt;/p&gt;

&lt;h3 id=&#34;愉快なvm命令たち:693fca136e4ca5c28a91dc5895343393&#34;&gt;愉快なVM命令たち&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;enum pic_opcode {
  OP_NOP,
  OP_POP,
  OP_PUSHNIL,
  OP_PUSHTRUE,
  OP_PUSHFALSE,
  OP_PUSHINT,
  OP_PUSHCHAR,
  OP_PUSHCONST,
  OP_GREF,
  OP_GSET,
  OP_LREF,
  OP_LSET,
  OP_CREF,
  OP_CSET,
  OP_JMP,
  OP_JMPIF,
  OP_NOT,
  OP_CALL,
  OP_TAILCALL,
  OP_RET,
  OP_LAMBDA,
  OP_CONS,
  OP_CAR,
  OP_CDR,
  OP_NILP,
  OP_ADD,
  OP_SUB,
  OP_MUL,
  OP_DIV,
  OP_MINUS,
  OP_EQ,
  OP_LT,
  OP_LE,
  OP_STOP
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大体名前から分かるかと思います。&lt;code&gt;quote&lt;/code&gt;は&lt;code&gt;OP_PUSH*&lt;/code&gt;系になります。&lt;code&gt;OP_STOP&lt;/code&gt;はあるのに&lt;code&gt;OP_START&lt;/code&gt;がないのは分かりますね。開始はユーザーの操作から始まるのに対して停止はプログラム側が行うからです。&lt;/p&gt;

&lt;h3 id=&#34;lambdaとか:693fca136e4ca5c28a91dc5895343393&#34;&gt;lambdaとか&lt;/h3&gt;

&lt;p&gt;lambdaとかのエントリポイント付きのコード1まとまりはirepと呼ばれています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct pic_irep {
  PIC_OBJECT_HEADER
  pic_sym name;
  pic_code *code;
  int argc, localc, capturec;
  bool varg;
  struct pic_irep **irep;
  pic_valuel *pool;
  size_t clen, ilen, plen;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PIC_OBJECT_HEADER&lt;/code&gt;: オブジェクトタイプのタグ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;: 名前（あれば）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*code&lt;/code&gt;: VM命令たち&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argc&lt;/code&gt;、 &lt;code&gt;localc&lt;/code&gt;、 &lt;code&gt;capturec&lt;/code&gt;: 引数数、ローカル変数数、捕捉された変数数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;varg&lt;/code&gt;: &amp;amp;rest引数を持つか&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**irep&lt;/code&gt;: irepプール&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*pool&lt;/code&gt;: 定数プール&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clen&lt;/code&gt;、&lt;code&gt;ilen&lt;/code&gt;、&lt;code&gt;plen&lt;/code&gt;: *code、**irep、*poolの長さ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スコープを作るので変数を格納するpoolを持ちます。そしてlambdaだけは定数プールとは別にirepに格納します。&lt;/p&gt;

&lt;h2 id=&#34;コード生成:693fca136e4ca5c28a91dc5895343393&#34;&gt;コード生成&lt;/h2&gt;

&lt;p&gt;本体は&lt;code&gt;codegen&lt;/code&gt;なんですがこれまた長いので掻い摘んで。帰りがけ順でコード生成します。&lt;/p&gt;

&lt;h3 id=&#34;cons:693fca136e4ca5c28a91dc5895343393&#34;&gt;cons&lt;/h3&gt;

&lt;p&gt;まずは肩馴らし。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sCONS) {
    codegen(state, pic_list_ref(pic, obj, 1));
    codegen(state, pic_list_ref(pic, obj, 2));
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_CONS;
    cxt-&amp;gt;clen++;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数1と引数2を生成する命令を吐いてから&lt;code&gt;OP_CONS&lt;/code&gt;命令を吐きます。引数1と引数2は自ら値をスタックにPUSHします。&lt;/p&gt;

&lt;h3 id=&#34;quote-1:693fca136e4ca5c28a91dc5895343393&#34;&gt;quote&lt;/h3&gt;

&lt;p&gt;少し長いですが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sQUOTE) {
    int pidx;

    obj = pic_list_ref(pic, obj, 1);
    switch (pic_type(obj)) {
    case PIC_TT_BOOL:
      if (pic_true_p(obj)) {
        cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHTRUE;
      } else {
        cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHFALSE;
      }
      cxt-&amp;gt;clen++;
      return;
    case PIC_TT_INT:
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHINT;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = pic_int(obj);
      cxt-&amp;gt;clen++;
      return;
    case PIC_TT_NIL:
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHNIL;
      cxt-&amp;gt;clen++;
      return;
    case PIC_TT_CHAR:
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHCHAR;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.c = pic_char(obj);
      cxt-&amp;gt;clen++;
      return;
    default:
      if (cxt-&amp;gt;plen &amp;gt;= cxt-&amp;gt;pcapa) {
        cxt-&amp;gt;pcapa *= 2;
        cxt-&amp;gt;pool = pic_realloc(pic, cxt-&amp;gt;pool, sizeof(pic_value) * cxt-&amp;gt;pcapa);
      }
      pidx = (int)cxt-&amp;gt;plen++;
      cxt-&amp;gt;pool[pidx] = obj;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHCONST;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = pidx;
      cxt-&amp;gt;clen++;
      return;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リテラルや定数をPUSHする命令を吐いてますね。&lt;/p&gt;

&lt;h3 id=&#34;ref系:693fca136e4ca5c28a91dc5895343393&#34;&gt;REF系&lt;/h3&gt;

&lt;p&gt;local、captureはirep構造体についてるのpoolを参照します。globalはVMのシンボルテーブルから直接引きます。因みにpicrinのシンボルはただのintです。&lt;/p&gt;

&lt;p&gt;captureは上位のスコープで既に出てきた変数を参照するだけなので「n個上位のm番目のcaptured変数」と指定するだけなので簡単ですが、localはarg、普通のlocal、下位スコープにcaptureされたlocal、の3つに分けて置いているので少し面倒です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  if (sym == state-&amp;gt;sGREF) {
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_GREF;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = pic_sym(pic_list_ref(pic, obj, 1));
    cxt-&amp;gt;clen++;
    return;
  } else if (sym == state-&amp;gt;sCREF) {
    pic_sym name;
    int depth;

    depth = pic_int(pic_list_ref(pic, obj, 1));
    name  = pic_sym(pic_list_ref(pic, obj, 2));
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_CREF;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.r.depth = depth;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.r.idx = index_capture(state, name, depth);
    cxt-&amp;gt;clen++;
    return;
  } else if (sym == state-&amp;gt;sLREF) {
    pic_sym name;
    int i;

    name = pic_sym(pic_list_ref(pic, obj, 1));
    if ((i = index_capture(state, name, 0)) != -1) {
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_LREF;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = i + (int)xv_size(&amp;amp;cxt-&amp;gt;args) + (int)xv_size(&amp;amp;cxt-&amp;gt;locals) + 1;
      cxt-&amp;gt;clen++;
      return;
    }
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_LREF;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = index_local(state, name);
    cxt-&amp;gt;clen++;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにset系もほぼ同じようなコードです。&lt;/p&gt;

&lt;h3 id=&#34;lambda-2:693fca136e4ca5c28a91dc5895343393&#34;&gt;lambda&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sLAMBDA) {
    int k;

    if (cxt-&amp;gt;ilen &amp;gt;= cxt-&amp;gt;icapa) {
      cxt-&amp;gt;icapa *= 2;
      cxt-&amp;gt;irep = pic_realloc(pic, cxt-&amp;gt;irep, sizeof(struct pic_irep *) * cxt-&amp;gt;icapa);
    }
    k = (int)cxt-&amp;gt;ilen++;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_LAMBDA;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = k;
    cxt-&amp;gt;clen++;

    cxt-&amp;gt;irep[k] = codegen_lambda(state, obj);
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;codegen_lambda&lt;/code&gt;に投げているのでこの部分は簡単です。irepプールにコードを置いてそれを参照する命令を吐くだけ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;codegen_lambda&lt;/code&gt;はというとそこまで長くなくて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static struct pic_irep *
codegen_lambda(codegen_state *state, pic_value obj)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value name, args, locals, closes, body;
  bool varg;

  name = pic_list_ref(pic, obj, 1);
  args = pic_list_ref(pic, obj, 2);
  locals = pic_list_ref(pic, obj, 3);
  varg = pic_true_p(pic_list_ref(pic, obj, 4));
  closes = pic_list_ref(pic, obj, 5);
  body = pic_list_ref(pic, obj, 6);

  /* inner environment */
  push_codegen_context(state, name, args, locals, varg, closes);
  {
    /* body */
    codegen(state, body);
  }
  return pop_codegen_context(state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;単純に本体に対して&lt;code&gt;codegen&lt;/code&gt;を呼んで出来た命令を取り出してるだけです。&lt;/p&gt;

&lt;h3 id=&#34;if:693fca136e4ca5c28a91dc5895343393&#34;&gt;if&lt;/h3&gt;

&lt;p&gt;schemeはほとんどの制御を継続に任せているのでなんとjmp命令を吐くのはifだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sIF) {
    int s, t;

    codegen(state, pic_list_ref(pic, obj, 1));

    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_JMPIF;
    s = (int)cxt-&amp;gt;clen++;

    /* if false branch */
    codegen(state, pic_list_ref(pic, obj, 3));
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_JMP;
    t = (int)cxt-&amp;gt;clen++;

    cxt-&amp;gt;code[s].u.i = (int)cxt-&amp;gt;clen - s;

    /* if true branch */
    codegen(state, pic_list_ref(pic, obj, 2));
    cxt-&amp;gt;code[t].u.i = (int)cxt-&amp;gt;clen - t;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;call:693fca136e4ca5c28a91dc5895343393&#34;&gt;call&lt;/h3&gt;

&lt;p&gt;思ったより短いです。単純に引数を評価する命令を吐いたあと引数の数を指定して呼ぶだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == state-&amp;gt;sCALL || sym == state-&amp;gt;sTAILCALL) {
    int len = (int)pic_length(pic, obj);
    pic_value elt;

    pic_for_each (elt, pic_cdr(pic, obj)) {
      codegen(state, elt);
    }
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = (sym == state-&amp;gt;sCALL) ? OP_CALL : OP_TAILCALL;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = len - 1;
    cxt-&amp;gt;clen++;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;最後に:693fca136e4ca5c28a91dc5895343393&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;これを書くのに半日掛かりましたがちゃんとコンパイルプロセスを理解して問題を洗い出すことが出来ました。良かった。&lt;/p&gt;

&lt;p&gt;今のところ中間表現までS式なのでS式操作に長けたSchemeでコンパイラ書けないかなとか考えてますが現状マクロ展開で副作用があるので厳しいですね。&lt;/p&gt;

&lt;p&gt;因みに気付いた方もいらっしゃるかと思いますが今のpicrinは最適化をtco以外は行っていません。行うとしたら&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;マクロ展開後にコンパイラマクロ展開を挟む&lt;/li&gt;
&lt;li&gt;中間表現から一旦ssa形式の第二中間表現に落して定数伝播や畳み込みなどの一般的な最適化を行なう&lt;/li&gt;
&lt;li&gt;生成されたvm命令に対して覗き穴最適化を行なう&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;あたりかなと思います。1. は楽しそうですけど普通のマクロ展開のバグとか問題に悩んでる今入れるべきではないですし、2. は効果高いですしjit化の布石にもなりますが実装コストが高いのでwasabiz次第かなといったところ、3. は今どの程度非効率な命令が吐かれてるのか分からないので効果が見えにくいですね。&lt;/p&gt;

&lt;p&gt;いずれにせよ最適化は仕様準拠してからにしますか。&lt;/p&gt;

&lt;p&gt;何か質問や突っ込みがあれば@blackenedgoldまで。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>H2Oにpicrinを溶かす</title>
      <link>//keens.github.io/blog/2014/12/07/h2onipicrinworong-kasu</link>
      <pubDate>Sun, 07 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>//keens.github.io/blog/2014/12/07/h2onipicrinworong-kasu</guid>
      <description>

&lt;p&gt;このエントリーは&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/advent-calendar/2014/lisp&#34;&gt;Lisp Advent Calendar&lt;/a&gt; 7日目&lt;br /&gt;
兼&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/advent-calendar/2014/h2o&#34;&gt;H2O Advent Calendar&lt;/a&gt; 7日目&lt;br /&gt;
の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。タイトルの通りです。&lt;/p&gt;

&lt;h1 id=&#34;h2oとは:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;H2Oとは&lt;/h1&gt;

&lt;p&gt;水。&lt;/p&gt;

&lt;h1 id=&#34;picrinとは:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;picrinとは&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E3%83%94%E3%82%AF%E3%83%AA%E3%83%B3%E9%85%B8&#34;&gt;Wikipedia&lt;/a&gt;にあるように、フェノールのトリニトロ化合物で、水溶性があります。&lt;/p&gt;

&lt;h1 id=&#34;ではなくて:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;ではなくて&lt;/h1&gt;

&lt;p&gt;H2OはHTTP1, HTTP2, WebsocketをサポートするNginXより速いHTTPサーバです。&lt;a href=&#34;https://github.com/h2o/h2o&#34;&gt;Github&lt;/a&gt;で開発されています。開発者は@kazuhoさん。&lt;/p&gt;

&lt;p&gt;picrinは「速い、軽い、高機能」を目指して作られているScheme処理系です。&lt;a href=&#34;https://github.com/picrin-scheme/picrin&#34;&gt;Github&lt;/a&gt;で開発されています。開発者は@wasabizさん。&lt;/p&gt;

&lt;h1 id=&#34;混ぜる:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;混ぜる&lt;/h1&gt;

&lt;p&gt;picrinのように組込み向けで開発されている処理系は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;picrinからH2Oを使えるようにする&lt;/li&gt;
&lt;li&gt;H2Oにpicrinを埋め込む&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と、2種類考えられますが、今回は後者です。H2Oにpicrinを溶かしてる感じしますね。&lt;/p&gt;

&lt;p&gt;まあ、Apatch HTTPDやNginX宜しくmod_picrinを作れば済むでしょう。&lt;/p&gt;

&lt;h1 id=&#34;絶望:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;絶望&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; モジュラーにできるようにはしてるけど、まだsoをロードする仕組みはないです。というか、APIがまだunstableだし&lt;/p&gt;&amp;mdash; Kazuho Oku (@kazuho) &lt;a href=&#34;https://twitter.com/kazuho/status/540692011003559936&#34;&gt;2014, 12月 5&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;つらい&lt;/p&gt;

&lt;h1 id=&#34;solシステムの導入:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;solシステムの導入&lt;/h1&gt;

&lt;p&gt;mod_xxxにしようと思ったんですけど水だし溶液ってことでsol_xxxにします。&lt;/p&gt;

&lt;p&gt;H2Oにこんな感じのパッチ当てて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/src/main.c b/src/main.c
index 7fc4680..57804a6 100644
--- a/src/main.c
+++ b/src/main.c
@@ -30,6 +30,7 @@
 #include &amp;lt;signal.h&amp;gt;
 #include &amp;lt;stdio.h&amp;gt;
 #include &amp;lt;unistd.h&amp;gt;
+#include &amp;lt;dlfcn.h&amp;gt;
 #include &amp;lt;sys/stat.h&amp;gt;
 #include &amp;lt;sys/socket.h&amp;gt;
 #include &amp;lt;sys/types.h&amp;gt;
@@ -76,6 +77,8 @@ struct config_t {
     } state;
 };
 
+typedef int(*sol_init_fn)(h2o_configurator_command_t *, h2o_configurator_context_t *, const char *, yoml_t *);
+
 static unsigned long openssl_thread_id_callback(void)
 {
     return (unsigned long)pthread_self();
@@ -381,6 +384,43 @@ static int on_config_num_threads(h2o_configurator_command_t *cmd, h2o_configurat
     return h2o_config_scanf(cmd, config_file, config_node, &amp;quot;%u&amp;quot;, &amp;amp;conf-&amp;gt;num_threads);
 }
 
+static int on_config_use(h2o_configurator_command_t *cmd, h2o_configurator_context_t *ctx, const char *config_file, yoml_t *config_node)
+{
+  /* struct config_t *conf = H2O_STRUCT_FROM_MEMBER(struct config_t, global_config, ctx-&amp;gt;globalconf); */
+  char *sol_name;
+  sol_init_fn init_fn;
+  void *handle;
+
+  /* fetch solution name */
+  switch (config_node-&amp;gt;type) {
+  case YOML_TYPE_SCALAR:
+    sol_name = config_node-&amp;gt;data.scalar;
+    break;
+  default:
+    h2o_config_print_error(cmd, config_file, config_node, &amp;quot;value must be a string or a mapping (with keys: `port` and optionally `host`)&amp;quot;);
+    return -1;
+  }
+
+  char dl_name[strlen(&amp;quot;sol_.so&amp;quot;) + strlen(sol_name) + 1];
+  char init_fn_name[strlen(&amp;quot;init_sol_&amp;quot;) + strlen(sol_name) + 1];
+
+  sprintf(dl_name, &amp;quot;./sol_%s.so&amp;quot;, sol_name);
+  sprintf(init_fn_name, &amp;quot;init_sol_%s&amp;quot;, sol_name);
+  handle = dlopen(dl_name, RTLD_LAZY);
+  if (! handle){
+    h2o_config_print_error(cmd, config_file, config_node, &amp;quot;cannot load the solution&amp;quot;);
+    return -1;
+  }
+
+  init_fn = dlsym(handle, init_fn_name);
+  if(dlerror()){
+    h2o_config_print_error(cmd, config_file, config_node, &amp;quot;cannot find the initialize function&amp;quot;);
+    return -1;
+  }
+  return (*init_fn)(cmd, ctx, config_file, config_node);
+
+}
+
 static void usage_print_directives(h2o_globalconf_t *conf)
 {
     h2o_linklist_t *node;
@@ -606,6 +646,10 @@ int main(int argc, char **argv)
             c, &amp;quot;num-threads&amp;quot;, H2O_CONFIGURATOR_FLAG_GLOBAL,
             on_config_num_threads,
             &amp;quot;number of worker threads (default: 1)&amp;quot;);
+        h2o_config_define_command(
+            c, &amp;quot;use&amp;quot;, H2O_CONFIGURATOR_FLAG_GLOBAL,
+            on_config_use,
+            &amp;quot;use the solution&amp;quot;);
     }
 
     h2o_access_log_register_configurator(&amp;amp;config.global_config);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じのソリューション用意して&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;quot;picrin.h&amp;quot;
#include &amp;quot;picrin/pair.h&amp;quot;
#include &amp;quot;picrin/string.h&amp;quot;
#include &amp;quot;picrin/error.h&amp;quot;
#include &amp;quot;h2o.h&amp;quot;

pic_state *pic;
struct pic_lib *PICRIN_BASE;


void pic_init_contrib(pic_state *);
void pic_load_piclib(pic_state *);

static pic_value
pic_features(pic_state *pic)
{
  pic_get_args(pic, &amp;quot;&amp;quot;);

  return pic-&amp;gt;features;
}

static pic_value
pic_libraries(pic_state *pic)
{
  pic_value libs = pic_nil_value(), lib;

  pic_get_args(pic, &amp;quot;&amp;quot;);

  pic_for_each (lib, pic-&amp;gt;libs) {
    libs = pic_cons(pic, pic_car(pic, lib), libs);
  }

  return libs;
}

void
pic_init_picrin(pic_state *pic)
{
  const char *scheme =
    &amp;quot;(import (scheme base)&amp;quot;
    &amp;quot;        (scheme write))&amp;quot;
    &amp;quot;(define-syntax call-with-output-to-string&amp;quot;
    &amp;quot;  (syntax-rules ()&amp;quot;
    &amp;quot;    ((_ proc)&amp;quot;
    &amp;quot;     (let ((s (open-output-string)))&amp;quot;
    &amp;quot;       (proc s)&amp;quot;
    &amp;quot;       (get-output-string s)))))&amp;quot;
    &amp;quot;(define (-&amp;gt;string e)&amp;quot;
    &amp;quot;  (call-with-output-to-string&amp;quot;
    &amp;quot;   (lambda (s)&amp;quot;
    &amp;quot;     (display e s))))&amp;quot;;


  pic_add_feature(pic, &amp;quot;r7rs&amp;quot;);

  pic_deflibrary (pic, &amp;quot;(picrin library)&amp;quot;) {
    pic_defun(pic, &amp;quot;libraries&amp;quot;, pic_libraries);
  }

  pic_deflibrary (pic, &amp;quot;(scheme base)&amp;quot;) {
    pic_defun(pic, &amp;quot;features&amp;quot;, pic_features);

    pic_init_contrib(pic);
    pic_load_piclib(pic);
  }
  pic_deflibrary (pic, &amp;quot;(picrin base)&amp;quot;) {
    pic_load_cstr(pic, scheme);
  }
}

const char *
pic_eval_cstr_into_cstr(pic_state *pic, const char *input)
{
  pic_value v;


  v = pic_read_cstr(pic, input);
  v = pic_eval(pic, v, PICRIN_BASE);
  v = pic_funcall(pic, PICRIN_BASE, &amp;quot;-&amp;gt;string&amp;quot;, pic_list1(pic, v));
  return pic_str_cstr(pic_str_ptr(v));
}



int
on_picrin(h2o_configurator_command_t *cmd, h2o_configurator_context_t *ctx, const char *config_file, yoml_t *config_node)
{
  const char *sexp;
  
  switch (config_node-&amp;gt;type) {
  case YOML_TYPE_SCALAR:
    sexp = config_node-&amp;gt;data.scalar;
    break;
  default:
    h2o_config_print_error(cmd, config_file, config_node, &amp;quot;value must be a string&amp;quot;);
    return -1;
  }

  pic_try{
    puts(pic_eval_cstr_into_cstr(pic, sexp));
  }
  pic_catch{
    pic_print_backtrace(pic);
    return -1;
  }
  return 0;

}


int
init_sol_picrin(h2o_configurator_command_t *cmd, h2o_configurator_context_t *ctx, const char *config_file, yoml_t *config_node)
{


  h2o_configurator_t *c = cmd-&amp;gt;configurator;

  pic = pic_open(0, NULL, NULL);

  pic_init_picrin(pic);

  PICRIN_BASE = pic_find_library(pic, pic_read_cstr(pic, &amp;quot;(picrin base)&amp;quot;));

  h2o_config_define_command(
      c, &amp;quot;picrin&amp;quot;, H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
      on_picrin,
      &amp;quot;run picrin&amp;quot;);


  return 0;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んでコンフィグは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# to find out the configuration commands, run: h2o --help

use: picrin
listen:
  port:
listen:
  port: 8081
  ssl:
    certificate-file: examples/h2o/server.crt
    key-file: examples/h2o/server.key
picrin: &amp;quot;(string-append \&amp;quot;Hello, \&amp;quot; \&amp;quot;World\&amp;quot;)&amp;quot;
hosts:
  default:
    paths:
      /:
        file.dir: examples/doc_root
    access-log: /dev/stdout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして魔法のコマンドを叩いて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp ~/compile/picrin/src/{init_contrib.c,load_piclib.c} ./
$ gcc -c sol_picrin.c -std=c99   -o sol_picrin.o -I ~/compile/picrin/extlib/benz/include -I ~/compile/h2o/include -I ~/compile/h2o/deps/picohttpparser -I ~/compile/h2o/deps/yoml -DH2O_USE_LIBUV=0 -fPIC
$ gcc sol_picrin.o load_piclib.o init_contrib.o -L ~/compile/picrin/build/lib/ -l picrin -fPIC -shared -o sol_picrin.so
$ cp sol_picrin.so ~/compile/h2o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/compile/h2o
$ ./h2o --conf example/h2o/h2o.conf
Hello, Wold
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ヤッタ！&lt;/p&gt;

&lt;h1 id=&#34;標準出力かよ:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;標準出力かよ&lt;/h1&gt;

&lt;p&gt;ううっ。ごめんなさい。&lt;/p&gt;

&lt;h1 id=&#34;で-httpレスポンス版は:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;で、HTTPレスポンス版は？&lt;/h1&gt;

&lt;p&gt;ごめんなさい、まだです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;file.c&lt;/code&gt;をベースにして&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    paths:
      /:
        picrin.exp: &amp;quot;(string-append \&amp;quot;Hello, \&amp;quot; \&amp;quot;World\&amp;quot;)&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とかしたかったんですけど間に合いませんでした。&lt;/p&gt;

&lt;p&gt;ソリューションなりモジュールなりのシステムが出来たらまたトライします&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>#関数型なんたら で喋ってきた</title>
      <link>//keens.github.io/blog/2014/10/26/number-guan-shu-xing-nantara-nican-jia-sitekita</link>
      <pubDate>Sun, 26 Oct 2014 17:14:10 +0000</pubDate>
      
      <guid>//keens.github.io/blog/2014/10/26/number-guan-shu-xing-nantara-nican-jia-sitekita</guid>
      <description>

&lt;p&gt;κeenです。昨日&lt;a href=&#34;http://connpass.com/event/8634/&#34;&gt;函数型なんたらの集い&lt;/a&gt;に参加してきたので報告/感想です。&lt;/p&gt;

&lt;p&gt;会場提供はドワンゴということでトークはニコ生に流された模様。ちらっと覗いてみたらLinuxでも見れましたね。いつのまにかFlashのバグ直ってたんですね。
とはいえ私自身のトーク中のコメントが見れなかったのであまり意味はないのですが…&lt;/p&gt;

&lt;p&gt;プレミアム会員は放送後7日は生放送の内容を見れるそうですね。見れる方々は&lt;a href=&#34;http://live.nicovideo.jp/gate/lv196879029&#34;&gt;コチラ&lt;/a&gt;からどうぞ。次回からはタイムシフト予約しておこう。&lt;/p&gt;

&lt;h1 id=&#34;話した内容:2e493419d503b3224d2e59e7d010df63&#34;&gt;話した内容&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;//KeenS.github.io/slide/c6h6-plus-hno3.html&#34;&gt;C6H6+HNO3&lt;/a&gt;というタイトルで、picrinのbenzとnitrosについて。本当はnitrosの依存関係解決器sulfuricを完成させてそれについて話し、nitroを書こう!って言う予定だったんですが着手が遅れて完成しないまま発表になりました。&lt;/p&gt;

&lt;p&gt;普段関数型言語のヒトは型やらモナドで殴ってる印象があったのでマクロで殴ろうと思ったのですがマクロの話のところで焦ってしまって話が飛んでしまい、殴れずに終わりました。&lt;/p&gt;

&lt;p&gt;ガチの組み込み屋さんから組み込み機器で動作検証したのかとの質問がありましたがそもそも持ってないです。そろそろ1.0が出ると思うのでそのあたりでやります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GCがconservativeかとの質問に対して「はい」と答えてしまいましたが間違いでした。&lt;/strong&gt; conservativeなのはcall/ccでした。GCはexactですね。&lt;a href=&#34;http://picrin.readthedocs.org/en/latest/intro.html&#34;&gt;ドキュメント&lt;/a&gt;に載ってます。&lt;/p&gt;

&lt;p&gt;wasabizの名前に反応した人が多かったようですね。やっぱ有名人なのかぁ。&lt;/p&gt;

&lt;h1 id=&#34;興味深かった話:2e493419d503b3224d2e59e7d010df63&#34;&gt;興味深かった話&lt;/h1&gt;

&lt;h2 id=&#34;エンジニアとモナド-http-www-slideshare-net-ruiccrail-engineerusesmonads-ref-http-connpass-com-event-8634-presentation:2e493419d503b3224d2e59e7d010df63&#34;&gt;&lt;a href=&#34;http://www.slideshare.net/RuiccRail/engineerusesmonads?ref=http://connpass.com/event/8634/presentation/&#34;&gt;エンジニアとモナド&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;またモナドで殴る話かと思ったら全然違いました。トップダウンで設計するときにそれぞれを小さなDSLに分割してそれらをモナドで実装し、モナド変換子で組み合わせると良いよねとのこと。タスクアサインもモナド単位になるし分かり易い。スピードのために実際には単相化すると良いとか現実的な話をしてて非常に良かったです。&lt;/p&gt;

&lt;p&gt;Lispで考えるとこうはいかないなと思います。トップダウンで設計するのが他の言語以上に向いてない気がします。というか、ボトムアップに向きすぎてる。小っさく始めて抽象が欲しければマクロを書いて…って。オブジェクト指向で作るにしてもオブジェクトとメソッドが分離してるのでボトムアップと相性が良い。この辺はポールグレアムの「ハッカーと画家」に詳しいです。&lt;/p&gt;

&lt;h2 id=&#34;shapelessの紹介-http-xuwei-k-github-io-slides-functional-something-shapeless-0:2e493419d503b3224d2e59e7d010df63&#34;&gt;&lt;a href=&#34;http://xuwei-k.github.io/slides/functional-something-shapeless/#0&#34;&gt;shapelessの紹介&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;興味を持ったのはshaplessそのものではなくてヘテロなリストやヘテロなハッシュに型をつける話。&lt;code&gt;{ 1 =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; 2}&lt;/code&gt;に型がつくのは面白すぎます。「高度に多相化された静的型は動的型と区別がつかなくなる」っぽかったです。&lt;/p&gt;

&lt;h2 id=&#34;パターンマッチいろいろ:2e493419d503b3224d2e59e7d010df63&#34;&gt;パターンマッチいろいろ&lt;/h2&gt;

&lt;p&gt;議論を呼んだ発表。パターンマッチを拡張する話。例えば年月日に対して&lt;code&gt;YMD(y, 12 25)&lt;/code&gt;でクリスマスならそのときの年を取り出せるだとかさらにアンドを使えばHMSも一緒にマッチ出来るだとか。
そこからEgisonに話が飛んでEgisonの例のようにポーカーの役をScalaでパターンマッチする例の紹介。&lt;/p&gt;

&lt;p&gt;議論を呼んだというのはパターンマッチにガードが吸収されてる件ですね。データ型のコンストラクタとエクストラクタが一対一対応してこそパターンマッチは真価を発揮する派vsパターンマッチの表現力が高ければ高い方が良い派の対立ですね。さらに前者は型の表現力が足りてないのなら型をもっと複雑にすべき派とガードを付けて網羅性の証明をすれば良い派に分かれます。私はパターンマッチには表現力があればあるほど良いよね派。&lt;/p&gt;

&lt;p&gt;これはそもそもパターンに対する立場の違いがある気がするんですよね。私はパターンマッチは同じデータに対する条件判定のシンタックスシュガーとして捉えています。マッチと束縛を一緒に行なうのは便利なのとパフォーマンスのため。ガードが必要なのはパターンの表現力が足りないため。だからパターンがリッチならリッチな方が良い。そもそもLispでは網羅性のチェックは期待出来ませんので。そもそもの話動的言語はコンパイル時の検査をあきらめてその代わり表現力を得ようという思想ですからね。&lt;/p&gt;

&lt;p&gt;パターンが複雑になるとメモリが爆発するとの指摘がありましたがそれに直面した人がいるらしく、パターンによる分岐の枝を実行時に伸ばしていくようなパターンマッチライブラリも存在します。（Lispは実行時にもマクロが動いていて、実行時にコードを生成することも可能なのです。）&lt;/p&gt;

&lt;h1 id=&#34;懇親会その他:2e493419d503b3224d2e59e7d010df63&#34;&gt;懇親会その他&lt;/h1&gt;

&lt;p&gt;名古屋の&lt;s&gt;型々&lt;/s&gt;方々と色々喋れました。偶々でこれきさん、みずぴーさんと同じテーブルに座り、昼御飯も一緒に。普段休日出勤してる印象が強く、名古屋に行かないと会えないと思っていたブレイスさんといよさんも一緒でした。でこれき先生はやっぱり大先生だった。&lt;/p&gt;

&lt;p&gt;よんたさんにSML#のコードリーディング会開いて下さいって言ったら良いよって言ってもらいました。そろそろ64bit版も出るそうなのでリリース記念コードリーディング会&amp;amp;芋煮会やろうって話になりました。&lt;/p&gt;

&lt;p&gt;OCamlのユニコードライブラリを作ってる方とも話しました。内部でropeで持ってるらしく、その話を聞きました。ropeのユニコード化はどうやら普通に文字列をUTF-8で保持し、ropeに文字列長のフィールドを保たせるだけで良いよう。ただ、picrinはCとの連携のためちょくちょくCの文字列に変換してまた新たにropeを作って、とするので若干勝手というかボトルネックが違いそう。&lt;/p&gt;

&lt;p&gt;Schemeのネイティブコンパイラを作ってる方とも話しました。Schemeの実装について喋ったり、GCについて喋ったり。GCについては興味深いことを聴いたのでもう1本エントリー書きます。あとはプロセス代数とかモデル検査とか。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:2e493419d503b3224d2e59e7d010df63&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;楽しかった。どうしてもLispは関数型とはあまり言われない（し、私も関数型言語とは思ってない）のでLisperが少なかったのですが私自身はMLも好きなので楽しめました。GCとTaPLとHaskellとScalaとEgisonに対するモチベーションが上がりました。&lt;/p&gt;

&lt;p&gt;最後に開催して下さった主催の方々、会場を提供して下さったドワンゴ様、ありがとう御座いました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C6H6&#43;HNO3</title>
      <link>//keens.github.io/slide/c6h6-plus-hno3/</link>
      <pubDate>Fri, 24 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>//keens.github.io/slide/c6h6-plus-hno3/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# $\mathbf{C_6H_6+HNO_3}$
------------------------
関数型なんたらの集い &lt;2014-10-25&gt;  
κeen(@blackenedgold)
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# picrinについて
---------------
![ピクリン酸の構造式](/images/picrin/picrin-structure.png)  
化学式 $\mathbf{C_6H_3N_3O_7}$、示性式 $\mathbf{C_6H_2(OH)(NO_2)_3}$ で表される芳香族のニトロ化合物。  
一般にはフェノールのニトロ化によって得られる。

Note:
ニトロ化に硫酸を使うことを触れる。

![picrinのロゴ](/images/picrin/picrin-logo-fin01-02.png)  


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
----------

 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, ML, Shell Scriptあたりを書きます
 + [picrin](https://github.com/picrin-scheme/picrin)のコミッタです


# picrinについて
----------------

* github: picrin-scheme/picrin
* R7RS-small scheme 処理系
* 速い、軽い、高機能を目指す
* 組み込み向けを意識
* 1年くらい開発
* κeenがコミットし始めてから半年弱


# picrinの プロジェクト構成
---------------------------
コア(benz)はC、ビルドツールはCMake。

```
├── contrib (nitros)
   .......
├── docs
├── etc
├── extlib
│   └── benz
├── piclib
   ....
└── src
```

Note:
contribとextlib/benzを強調。
srcはほぼ空であることにも触れる。

# nitrosの紹介
---------------

* schemeやCで書かれている
* picrinのコンパイル時に一緒にlibpicrinに入る
* picrinと共にCMakeで管理されている

Note:
schemeファイルもlibpicrinにCの文字列として入ってることに触れる。
バイトコンパイルプロジェクトにも触れる。
nitrosも一緒にコンパイルされることを強調する。


# nitroの紹介
---------------
## [R7RS](https://github.com/picrin-scheme/picrin/tree/master/contrib/05.r7rs/scheme)

* picrinではr7rsもただのライブラリ
* 組み込みのときに必要なければ外せばよい

Note:
リンクを辿る必要はない。
スライドは下に続く。


# nitroの紹介
---------------
## [partcont](https://github.com/picrin-scheme/picrin/blob/master/contrib/10.partcont/piclib/partcont.scm)

* ただの限定継続ライブラリ
* ねこはるさんが詳しく話すと思うのでそちらに譲ります

Note:
リンクを辿ってソースを見せる。

# nitroの紹介
---------------
## [for](https://github.com/picrin-scheme/picrin/blob/master/contrib/20.for/piclib/for.scm)

* 非決定性計算ライブラリ
* またの名をListモナド

Note:
リンクを辿ってソースを見せる。

# nitroの紹介
---------------
## [regexp](https://github.com/picrin-scheme/picrin/blob/master/contrib/10.regexp/src/regexp.c)

* Unixのregexライブラリのバインディング
* Cで書かれている

Note:
リンクを辿ってソースを見せる。
詳細に説明する。

 + `regexp_t`型
 + dtor
 + GCに乗ることは強調


# nitroの依存関係の話
---------------------

* nitro同士に依存関係がある
* forはpartcontに依存する
* REPLはeditlineに依存する
* etc...


# picrinの依存関係解決法
-----------------------

[picrin/contrib](https://github.com/picrin-scheme/picrin/tree/master/contrib)

Note:

* リンクを辿る
* ディレクトリ名が数字で始まることを説明
* 03まできてそろそろ限界であることを説明


どう見ても&lt;span style=&#34;font-size:150%&#34;&gt;手動(ディレクトリ名)ソート&lt;/span&gt;ですね。  
本当にありがとうございました。

&lt;!-- .slide: class=&#34;center&#34; --&gt;



* さすがにどうにかしたい
* 依存関係解決ツールが欲しい
* なんかmrubyのmrbgemとかみたいにしたら楽しいんじゃね？
* 個々のnitroを別プロジェクトにも出来る!


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# sulfuricプロジェクト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# sulfuricプロジェクト
---------------------

* sulfuric acid = 硫酸
* nitro定義、依存解決、ビルドコンフィグ etc...
* 最終的にはCMakeと連携
* 定義ファイルはschemeで書きたい

Note:
個人案なことに触れる。
chikenのeggsやRacketのPlanetにも触れる。


# sulfuricプロジェクト
---------------------

* あれ？R7RSってnitroじゃね？
* そもそもschemeをビルドするためにschemeを書く…？
* てかCMakeとの連携どうするよ

Note:
進捗はまだinitial commitすら出来てない。
書いてる内に大きくなっていったことも説明。
最初は他のschemeでビルドする案やフェノールでビルドする案も話す。
solutionディレクトリに入れたいよねーも話す。
フェノールの合成にベンゼンスルホン酸が使われる


# picrinにコミットしよう
-----------------------

* picrinはまだ若い
  + ちょろっと覗くだけでコミット出来るところが見付かる
* 開発者全員日本人


# コミットはとっても簡単
------------

1. [issue](https://github.com/picrin-scheme/picrin/issues)を覗く
2. 簡単そうなのをサクっと実装
3. PR

Note:
イシューの中から

  + \#224 feature request: data structures
  + \#210 Add MQTT support

を見せる


# Q. なぜpicrin?
------------


# A. picrinの独自拡張
-----------------

* [ドキュメント](http://picrin.readthedocs.org/en/latest/)に色々書いてある
* C拡張の書き方も書いてある

Note:
arrayとdictionaryに触れる。
マクロに触れる
C APIの項目があることにも触れる。

# picrinのマクロ
----------------

* `syntax-rules` (R7RS)
* `sc-macro-transformer`
* `rsc-macro-transformer`
* `ir-macro-transformer`
* `er-macro-transformer`
* `define-macro` (Common Lisp)

参考: [様々な Hygienic Macro - 月の塵](http://d.hatena.ne.jp/leque/20080528/p1)


# picrinにコミットしよう
-----------------------

* issueに上がってなくても大歓迎
* Schemeの練習に
* 「便利なライブラリ書いたけどどこ置いたら良いの」



# picrinにコミットしよう


&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Lisp Meet Up #20でLTしてきました</title>
      <link>//keens.github.io/blog/2014/09/30/lisp-meet-up-number-20</link>
      <pubDate>Tue, 30 Sep 2014 09:35:05 +0000</pubDate>
      
      <guid>//keens.github.io/blog/2014/09/30/lisp-meet-up-number-20</guid>
      <description>

&lt;p&gt;κeenです。lisp meet up # 20に参加したのでレポートです。&lt;/p&gt;

&lt;p&gt;20人の募集に19人参加予定。会場は今回初めてのところでした。&lt;/p&gt;

&lt;h1 id=&#34;lt:5c76b21db64f9b2b4b6771d0db2da268&#34;&gt;LT&lt;/h1&gt;

&lt;p&gt;LTはTOYOZUMIさんが仕事で来れなくなったので私の1件のみ。内容はpicrinのチューニングの話と思わせてほとんどがその前振りのGCの話。&lt;/p&gt;

&lt;p&gt;スライドはこちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//KeenS.github.io/slide/picrin-gc.html&#34;&gt;Picrinのチューニングの話、もといGCの話 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TOYOZUMIさんのdocstringの話聞きたかった&lt;/p&gt;

&lt;h2 id=&#34;飛び入り:5c76b21db64f9b2b4b6771d0db2da268&#34;&gt;飛び入り&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ブラウザ上でbiwa schemeの環境(REPLだけでなくオートインデントとか)を作ってる&lt;/li&gt;
&lt;li&gt;関連して、websocketでswankと対話できるやつ作ってる&lt;/li&gt;
&lt;li&gt;関連して、ブラウザ上で動くLispに似てそうなBlockyというヴィジュアル言語がある
なんかの話がありました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;余った時間:5c76b21db64f9b2b4b6771d0db2da268&#34;&gt;余った時間&lt;/h1&gt;

&lt;p&gt;chikuさんが前でGCの話してました。んで話が尽きたあたりで私がpicrinの宣伝しました。&lt;code&gt;(picrin control list)&lt;/code&gt;の話です。非同期プロミス然りpicrinにはトリッキーな機能が多いですね。&lt;/p&gt;

&lt;p&gt;結局ライブコーディングはしませんでしたね。&lt;/p&gt;

&lt;h1 id=&#34;懇親会:5c76b21db64f9b2b4b6771d0db2da268&#34;&gt;懇親会&lt;/h1&gt;

&lt;p&gt;Raspberry Piの話とかちょいとGCの話とかVarnishの話とかaltJSとか。ブログの話題が出たのでOctopress推しといたり。なんでみんなGithub Pages + Octopress使わないん？便利ですやん。&lt;/p&gt;

&lt;p&gt;結構色々話してた気がするんですが覚えてないですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Picrinのチューニングの話、もといGCの話</title>
      <link>//keens.github.io/slide/picrin-gc/</link>
      <pubDate>Mon, 29 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>//keens.github.io/slide/picrin-gc/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# Picrinのチューニングの話、もといGCの話
---
Lisp Meet Up presented by Shibuya.lisp #20  
2014-09-29  
κeen(@blackenedgold)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 自己紹介
---
 + κeen
 + 東大数学科の4年生
 + ソーシャルアカウントは上のアイコン達から。
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます
 + [picrin](https://github.com/picrin-scheme/picrin)のコミッタです

# picrin
---
![picrin](/images/picrin/picrin-logo-fin01-02.png)

# picrin
---
* R7RS compatibility
* bytecode interpreter (based on stack VM)
* internal representation by nan-boxing
* conservative call/cc implementation (users can freely interleave native stack with VM stack)
* exact GC (simple mark and sweep, partially reference count is used as well)
* string representation by rope data structure

# picrin
---
* R7RS compatibility
* &lt;strong&gt;bytecode interpreter (based on stack VM)&lt;/strong&gt;
* internal representation by nan-boxing
* conservative call/cc implementation (users can freely interleave native stack with VM stack)
* &lt;strong&gt;exact GC (simple mark and sweep, partially reference count is used as well)&lt;/strong&gt;
* &lt;strong&gt;string representation by rope data structure&lt;/strong&gt;

# picrin開発者の不満
---
* picrinの起動が遅い&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
  + 2秒くらいかかる &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
* picrinのテストが遅い&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
  + 16秒くらいかかる &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;

# 少しGCの話
---
GC(ごみ集め)とは

* 使われていないオブジェクトを自動的に解法する
  + メモリ管理に煩わせられないで済む
  + メモリーリークを防ぐ。
* 「使われていないオブジェクト」を判定するのはいくつかアルゴリズムがある


# GCのアルゴリズム
---
## 主なGCのアルゴリズム
* マーク&amp;amp;スイープ
* 参照カウント
* Copying GC

# GCのアルゴリズム
---
## マーク&amp;amp;スイープ
 1. あらかじめ全てのオブジェクトはどこかで一元管理する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
 2. 一元管理元(ヒープ(ページ))でメモリが足りなくなったらGCを開始&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
 3. スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;
 4. そこから辿れるオブジェクトも再帰的にマークする&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;4&#34; --&gt;
 5. ヒープからマークされていないオブジェクトを開放する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;5&#34; --&gt;
 6. それでもメモリが足りなければ一ヒープのページを増やす&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;6&#34; --&gt;
 7. 増やせなければメモリを使い果したのでabort&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;7&#34; --&gt;

# GCのアルゴリズム
---
## マーク&amp;amp;スイープの特徴
 * そこそこ速い
 * 正確に集められる
 * GC以外ではメモリ管理を考えなくて良い(≒プラグインは書き易い)
 * 長生きのオブジェクトは何度もマークされる(=&gt;世代別GC)
 * 負荷は1点に集中する
 * メモリの断片化が起きる(=オブジェクトのアロケートが遅くなる)

# GCのアルゴリズム
---
## 参照カウント
 1. オブジェクトに他から参照されている数(参照カウント)を記憶させる&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
 2. オブジェクトの参照を変えるときはその都度参照カウントを変える&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
 3. 参照カウントが0になったら開放する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;

# GCのアルゴリズム
---
## 参照カウントの特徴
 * 負荷は分散する
 * GCの実装は楽
 * 少し遅い(必ずfreeする必要がある)
 * 正確でない(循環参照に弱い)(cf. 大相撲の星の回しあい)
 * プラグインは面倒

# GCのアルゴリズム
---
## Copying GC
 1. オブジェクトプールを2つ用意する(1, 2)とする&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
 2. オブジェクトを確保するときは必ず1に確保する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
 3. 1のメモリが足りなくなったらgcを開始&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;
 4. 1の生きているオブジェクトを再帰的に2に移動する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;4&#34; --&gt;
 5. 1に残っているものは全てゴミとして良い&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;5&#34; --&gt;
 6. 1、2のラベルを付け換える&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;6&#34; --&gt;

# GCのアルゴリズム
---
## Copying GCの特徴
 * 正確
 * メモリの断片化が起きない(Windowsのデフラグ)(=アロケートが速くなる)
 * 負荷は1点に集中する
 * 遅い(オブジェクトの移動が必要)
 * メモリ食う(オブジェクトプール2つ分)
 * ポインタも変わるため、ハッシュの再計算などが必要

# GCのアルゴリズム
---
## GCの主な属性
* 世代別
  + 新しいオブジェクトだけGCの対象にする&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;
* 正確
  + ゴミは必ず回収する&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34; --&gt;
* インクリメンタル
  + 一度にやらずに少しづつGCを進める&lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;3&#34; --&gt;

# picrinのGC
---
![picrin](/images/picrin/picrin-logo-fin01-02.png)

# picrinのGC
---
* 基本は普通の正確なマーク&amp;amp;スイープ
  + Copying GCはlightweightでない
* ropeには参照カウント
  + ropeには循環参照が起きない

# picrinのGC
---
 * 基本はマーク&amp;amp;スイープ

&gt; 3. スタックに載っているオブジェクト、変数に格納されているオブジェクトにマークする

 * schemeの変数はそのまま
 * Cの変数は読めないのでアリーナという場所を用意してC内ではそこに一時保管してもらう
   + スコープはFILOなのでスタックを用いればヒープより速くアロケート出来る

# picrinのチューニング
## プロファイルをとってみる
---
```
 % cumulative self self total
time seconds seconds calls s/call s/call name
37.14 0.78 0.78 13136494 0.00 0.00 XROPE_DECREF
23.81 1.28 0.50 1544 0.00 0.00 gc_sweep_phase
15.72 1.61 0.33 59344814 0.00 0.00 gc_mark_object
10.00 1.82 0.21 1544 0.00 0.00 gc_mark_phase
6.67 1.96 0.14 1544 0.00 0.00 gc_mark_trie
2.38 2.01 0.05 6523 0.00 0.00 pic_apply
```

&lt;span style=&#34;font-size:200%&#34;&gt;ほとんどGCですね。  
本当にありがとう御座いました。&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 解決案
---
* GCのアルゴリズムを変える
* オブジェクトをアロケートしないようにする
* パラメーターをいじる

# 解決案
---
* GCのアルゴリズムを変える
* オブジェクトをアロケートしないようにする
* &lt;strong&gt;パラメーターをいじる&lt;/strong&gt;

# GCに関連するパラメータ
---
元々tinyに設計されている
```C
/* アリーナのサイズ */
# define PIC_ARENA_SIZE 1000
/* ヒープページのサイズ */
# define PIC_HEAP_PAGE_SIZE 10000
/* シンボルプール(ハッシュ)のサイズ */
# define PIC_SYM_POOL_SIZE 128
```

# GCに関連するパラメータ
---
チューニング後
```C
/* アリーナのサイズ */
# define PIC_ARENA_SIZE 8 * 1024
/* ヒープページのサイズ */
# define PIC_HEAP_PAGE_SIZE 2 * 1024 * 1024
/* シンボルプール(ハッシュ)のサイズ */
# define PIC_SYM_POOL_SIZE 2048
```

# 結果
---
* 昔
  &gt; テストに16秒

* 変更後
  &gt; time make test-r7rs  
  &gt; make test-r7rs  &lt;strong&gt;1.68s&lt;/strong&gt; user 0.23s system 98% cpu 1.931 total
  &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34; --&gt;


# 今後
---
* GCのアルゴリズムを変える
 + 世代別GCにしたいよねー
 + そもそもマーク&amp;amp;スイープの実装が適当すぎるだとか。協議中。
 + 組み込み目指すならインクリメンタル性必要では？
* オブジェクトをアロケートしないようにする
  + バイトコンパイルするときにもめちゃくちゃアロケートしてる。その辺どうにかする。
  + [Fast Reader](https://github.com/picrin-scheme/picrin/pull/207)


# まとめ
---
* 基本的なGCの解説をした
* picrinのGCの戦略を話した
* GCチューニング大事

&lt;span style=&#34;font-size:600%&#34;&gt;以上&lt;/span&gt;  
何か質問あればどうぞ

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>