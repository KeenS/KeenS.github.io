<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sml on κeenのHappy Hacκing Blog</title>
    <link>/categories/sml/</link>
    <description>Recent content in Sml on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 29 Mar 2016 01:44:39 +0900</lastBuildDate>
    <atom:link href="/categories/sml/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SMLで函数型的正規表現マッチ</title>
      <link>/slide/SMLdekansuukatatekiseikihyougenmatchi/</link>
      <pubDate>Tue, 29 Mar 2016 01:44:39 +0900</pubDate>
      
      <guid>/slide/SMLdekansuukatatekiseikihyougenmatchi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLで函数型的正規表現マッチ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます


# 元ネタ
--------
[関数型的正規表現マッチ | Preferred Research](https://research.preferred.jp/2010/11/regexp-play/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 正規表現
----------

必要最小限の要素は5つだけ

1. 空文字
2. アルファベット1つ
3. 正規表現のOR結合
4. 正規表現のAND結合
5. 正規表現の繰り返し


# SMLで表してみる
-----------------

``` sml
datatype  reg
  = Empty
  | Sym of t
  | Or of reg * reg
  | And of reg * reg
  | Rep of reg
```

# 本当に大丈夫？

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# `/(a|b)*c/`
-----------

``` sml
And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)
```


# `/https?:\/\/[a-z]*/`
-----------

``` sml
val a_z = Or(Sym&#34;a&#34;, Or(Sym &#34;b&#34;, Or(Sym &#34;d&#34;, ...)))
And(Sym &#34;http&#34;, And(Or(Sym &#34;s&#34;, Empty), And(Sym &#34;://&#34;, Rep a_z)))
```


# 実装してみる

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# `Empty`, `Sym`, `Or`
----------------
trivial

``` sml
fun match Empty u = isEmpty u
  | match (Sym a) u = a = u
  | match (Or(p, q)) u = match p u orelse match q u
```


# `And`
--------

`And(p, q)` に入力が`u`の時`p`がどこまでマッチするか分からないので

* `u` から一部取ってきて`p`にマッチするか確認
* 残りの文字列が`q`にマッチするか確認


# `And`
--------
`match (And (Sym &#34;a&#34;, Sym &#34;b&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;&#34;)、(Sym &#34;b&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;b&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;b&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;abd&#34;)、(Sym &#34;b&#34;と&#34;&#34;)



# `And`
--------

``` sml
  | match (And(p, q)) u = 
    withSprits u (fn (u1, u2) =&gt; 
      match p u1 andalso match q u2)

```

`withSprits u f` は`u`を2分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。


# `Rep`
-------

`Rep(r)` に入力が`u`の時、`r`がどこまでマッチするかも`Rep`が何回繰り返すかも分からないので

* `u` を任意の個数に分割し
* その全てが`r`にマッチするか確認



# `Rep`
--------
`match (Rep (Sym &#34;a&#34;)) &#34;abd&#34;` の時

* (Sym &#34;a&#34;と&#34;abd&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;bd&#34;)
* (Sym &#34;a&#34;と&#34;ab&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)
* (Sym &#34;a&#34;と&#34;a&#34;)、(Sym &#34;a&#34;と&#34;b&#34;)、(Sym &#34;a&#34;と&#34;d&#34;)




# `Rep`
--------

``` sml
  | match (Rep(r)) u =
    withParts u (fn input =&gt;
      List.all (match r) input)
```

`withParts u f` は`u`を分割するパターン全通りに対して`f`を呼び、最初に`true`になったものを返す。



# チェック
----------

```
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbca&#34;;
val it = false : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;ababbc&#34;;
val it = true : bool
# match (And(Rep(Or(Sym &#34;a&#34;, Sym &#34;b&#34;)), Sym &#34;c&#34;)) &#34;c&#34;;
val it = true : bool
```


# まとめ
--------

* 適当に実装したら正規表現も簡単に実装出来るよ
* SMLで正規表現実装したよ


# 参考
------

* [KeenS/regexp](https://github.com/KeenS/regexp)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SML#のpthreadバインディング作った</title>
      <link>/blog/2016/01/11/sml_nopthreadbaindingutsukutta</link>
      <pubDate>Mon, 11 Jan 2016 00:57:20 +0900</pubDate>
      
      <guid>/blog/2016/01/11/sml_nopthreadbaindingutsukutta</guid>
      <description>

&lt;p&gt;κeenです。またしても深夜になってしまいましたがSML#のpthreadバインディングを作ったのでその報告を。&lt;/p&gt;

&lt;p&gt;SML#はC FFIを簡単に書け、さらにランタイムがnon Moving GCなのでSML#自体はサポートしていないもののランタイムそのものはマルチスレッドに対応しているという大変興味深い特徴を持っています。
処理系側としてもマルチスレッドが欲しいならpthreadのFFIを使って好きにやってくれというスタンスのようです。&lt;/p&gt;

&lt;p&gt;ということでさまざまなマルチスレッドアプリケーションの下地になるべくpthreadのバインディングを作りました。とはいってもまだ不完全ですが。&lt;/p&gt;

&lt;p&gt;どういうものが用意出来ているかは&lt;a href=&#34;https://github.com/KeenS/smlsharp_pthread/blob/master/src/pthread.smi&#34;&gt;こちら&lt;/a&gt;が一覧として機能しています。&lt;/p&gt;

&lt;p&gt;SML的には改善の余地がある(例えば、排他的なフラグをdatatypeで定義するとか)のですが、あくまで低レベルなバインディングに徹するためにintのままで残してあります。&lt;/p&gt;

&lt;p&gt;他にはCのマクロで実現されていたものはインポート出来ないのでどうにかしてあったりどうにかしてなかったりしてます。
例えば&lt;code&gt;PTHREAD_XXX_INITIALIZER&lt;/code&gt;はマクロで定義された初期値ですが、SMLからは参照出来ないのであきらめました。
代わりに&lt;code&gt;pthread_xxx_new&lt;/code&gt;関数を用意したので&lt;code&gt;pthread_xxx_init&lt;/code&gt;と併せて使うことでそれらの値を初期化出来ます。
メモリ確保と初期化同時にやれよとの声が聞こえてきそうですが繰り返すとあくまで低レベルなバインディングなのでそういうのは他に譲ることにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pthread_cleanup_{pop/push}&lt;/code&gt;はバインディングが書けませんでした。
それらはマクロとして実現されていて、しかも&lt;code&gt;pthread_cleanup_push&lt;/code&gt;で開き括弧を挿入して&lt;code&gt;pthread_cleanup_pop&lt;/code&gt;で閉じるというエグい実装なので移植は無理でしょう。
POSIX的にもマクロとして実現して良いことになっているので文句は言えません。&lt;/p&gt;

&lt;h1 id=&#34;サンプルコード:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;サンプルコード&lt;/h1&gt;

&lt;p&gt;レポジトリにも入ってますが、スレッドを作る小さな例だとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;open PThread
fun exit reason = (
    print (reason ^ &amp;quot;\n&amp;quot;);
    OS.Process.exit OS.Process.failure
)


val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr
(* durty hack *)
val sml_str_new = _import &amp;quot;sml_str_new&amp;quot;: (string) -&amp;gt; char ptr

fun threadFunc (arg:unit ptr): unit ptr = let
    val cp: char ptr = fromUnitPtr arg
    val s = Pointer.importString cp
    val () = print s
    (* val ret =ref _NULL *)
    (* val () = ret := (String.size s) *)
in
    (* ret *)
    _NULL
end
                   
val () = let
    val tattr = ref (pthread_attr_new())
    val s = pthread_attr_init(tattr)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;pthread_attr_init&amp;quot;
             else ()
    val thread_ref = ref (pthread_new())
    val arg = sml_str_new &amp;quot;Hello world\n&amp;quot;
    val s = pthread_create(thread_ref, tattr, threadFunc, toUnitPtr arg)
    val t1 = !thread_ref
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;thread creation failed&amp;quot;
             else ()
    val s = pthread_attr_destroy(tattr)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;pthread_attr_destroy&amp;quot;
             else ()
    val () = print &amp;quot;Message from main()\n&amp;quot;;
    val resRef = ref (Pointer.NULL ())
    val s = pthread_join(t1, resRef)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;thread creation failed&amp;quot;
             else ()
    (* val () = print (&amp;quot;Thread returned&amp;quot; ^ Int.toString  (!resRef) ^ &amp;quot;\n&amp;quot;) *)
in
    ()
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;言わずとも雰囲気で読み取れそうですがこの例はCのサンプルをそのまま移植しました。Cだと&lt;code&gt;(void *)&lt;/code&gt;と文字列で相互変換が出来るのですがSML#だと一筋縄では出来ないので内部APIを叩くとかのかなりアレなハックしてます。
&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/45&#34;&gt;SML#にイシューに上げ&lt;/a&gt;ましたが&lt;code&gt;(void *)&lt;/code&gt;が強敵ですね。&lt;/p&gt;

&lt;h1 id=&#34;可搬性の話:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;可搬性の話&lt;/h1&gt;

&lt;p&gt;ところで、pthreadはp(POSIX)の名が付いている通り様々なプラットフォームで利用出来、そしてそれぞれのプラットフォーム毎に実装が異なります。
勿論、POSIXで定められているのでAPIレベルでは互換性がある(≒関数のバインディングは問題ない)のですが、ABI、データの表現に互換性がありません(≒データ型のバインディングに問題がある)&lt;/p&gt;

&lt;p&gt;実はその辺で苦労がありました。今のところ手元の環境(Linux)でしか移植が済んでません。しかし他のプラットフォームの移植は書ける形になっています。
これは&lt;a href=&#34;//KeenS.github.io/blog/2015/12/26/sml_tocpuripurosessanorenkei/&#34;&gt;以前&lt;/a&gt;書いたSMLのファイルにCのプリプロセッサを適用するというなんともいえないハックを使うことで実現しています。
他のプラットフォームに移植するには&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;どういうマクロが定義されている時にどのプラットフォームのpthreadを使っているかの対応を調べる&lt;/li&gt;
&lt;li&gt;そのプラットフォームの&lt;code&gt;pthread.h&lt;/code&gt;を入手してデータ型を移植する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;手順が必要です。私は手元の環境で動かすのが精一杯なのでMacとかで動かしたい方がいればプルリクを頂けると。
前述の通り、関数のバインディングは可搬性があるので必要なのはデータ型と定数の移植です。ある程度はプリプロセッサも使えるのでほぼヘッダファイルを移植する感じですね。&lt;/p&gt;

&lt;p&gt;まあ、実をいうと関数の移植も細々したものが面倒なので放置していたりします。ここら辺は作業ゲーなので気が向いたらやります。&lt;/p&gt;

&lt;p&gt;あとは若干迷っているのが必ずしも実装されているとは限らないオプショナルな機能の移植ですね。
バリアやリードライトロック、スピンロックがそれにあたります。
可搬性とはいってもSML#自身が動く環境が限られているのでMacでもそれらが使えるなら移植してしまおうかと思っていますがまだ調べきれてません。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;pthreadのバインディング作ったよ&lt;/li&gt;
&lt;li&gt;まだバインドが書かれてない関数もあるよ&lt;/li&gt;
&lt;li&gt;Macの移植パッチ待ってるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#とCプリプロセッサの連携</title>
      <link>/blog/2015/12/26/sml_tocpuripurosessanorenkei</link>
      <pubDate>Sat, 26 Dec 2015 20:09:24 +0900</pubDate>
      
      <guid>/blog/2015/12/26/sml_tocpuripurosessanorenkei</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第3段はSML#とCプリプロセッサで連携する話。&lt;/p&gt;

&lt;p&gt;SML#のC FFIを使ってるとマクロで定義された値などを触りたくなるのですが、触れないのでどうにかしようかと。&lt;/p&gt;

&lt;p&gt;発想自体は単純で、SMLファイルの中でCのヘッダをインクルードしてCプリプロセッサを呼んであげればどうにかなります。&lt;/p&gt;

&lt;h1 id=&#34;簡単な例:17ab4ed508953994d38c55ce3a68a752&#34;&gt;簡単な例&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;//KeenS.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi/&#34;&gt;JITを作る話&lt;/a&gt;の時のように、定数に触りたいとします。
その時、以下のように.smlファイルを記述して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* 
#include&amp;lt;sys/mman.h&amp;gt;
*)

(* ====END_OF_HEADER==== *)
datatype dummy = $ of int
              
val $PROT_READ  = $ PROT_READ
val $PROT_WRITE = $ PROT_WRITE
val $PROT_EXEC  = $ PROT_EXEC
val $PROT_NONE  = $ PROT_NONE

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E cpp_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; cpp.sml 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントを挙げると、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;smlファイルに&lt;code&gt;#include&lt;/code&gt;を書く。lintでエラーが出ないように&lt;code&gt;#include&lt;/code&gt;はコメントで囲む&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt;をコメントで囲ったところで安全でない( インクルードしたファイルに&amp;rsquo;&lt;code&gt;*)&lt;/code&gt;&amp;lsquo;、例えば &lt;code&gt;int f(char *);&lt;/code&gt;とかが入ってるとコメントが終端される)ので、&lt;code&gt;include&lt;/code&gt;の部分は後で削除する。
そのための識別子として、&lt;code&gt;====END_OF_HEADER====&lt;/code&gt;を置いておく(これも完全には安全ではないが比較的マシ)。&lt;/li&gt;
&lt;li&gt;Cのマクロと同じ識別子を使おうとすると識別子も置換されてしまうので左辺にダミーで&lt;code&gt;$&lt;/code&gt;をつけておく。スペースは空けない。
逆に右辺は置換されてほしいので&lt;code&gt;$&lt;/code&gt;の後にスペースを空ける。&lt;/li&gt;
&lt;li&gt;最後にCプリプロセッサを呼び、sedでヘッダ部分や無駄に追加されたCのコメントを除く。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ちょっと&lt;code&gt;$&lt;/code&gt;の部分がこの方式だとintにしか使えないのでイケてませんがないよりマシでしょう。因みに処理結果はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype dummy = $ of int

val $PROT_READ = $ 
                   0x1

val $PROT_WRITE = $ 
                   0x2

val $PROT_EXEC = $ 
                   0x4

val $PROT_NONE = $ 
                   0x0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ifdef:17ab4ed508953994d38c55ce3a68a752&#34;&gt;&lt;code&gt;ifdef&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;一旦発想さえ得てしまえば話は簡単です。次は&lt;code&gt;ifdef&lt;/code&gt;を使う例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* ====END_OF_HEADER==== *)


(* 
#ifdef Debug
*)
val debug = true
(* 
#else
*)
val debug = false

(* 
#endif
*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E -DDebug ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;Debug&lt;/code&gt;を定義して処理すればifdef.smlの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*

*)
val debug = true
(*






*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となりますし、定義せずに&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
``` sh
cpp -pipe -E ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と処理すれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*





*)
val debug = false

(*

*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってどちらでもSMLとして有効な文法になります。&lt;code&gt;ifndef&lt;/code&gt;だったり、&lt;code&gt;elif&lt;/code&gt;があったとしても有効な文法のままです。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:17ab4ed508953994d38c55ce3a68a752&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CプリプロセッサでSMLファイルを処理する方法を提示したよ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifdef&lt;/code&gt;も使えるよ&lt;/li&gt;
&lt;li&gt;関数マクロは使えないよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#のオレオレREPLを作る話 初級</title>
      <link>/blog/2015/12/26/sml_nooreorereplwotsukuruhanashi_shokyuu</link>
      <pubDate>Sat, 26 Dec 2015 19:48:30 +0900</pubDate>
      
      <guid>/blog/2015/12/26/sml_nooreorereplwotsukuruhanashi_shokyuu</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第2段はSML#のオレオレREPLを作る話の初級。&lt;/p&gt;

&lt;p&gt;SML#にはFFIがあり、任意のオブジェクトファイル/ライブラリをリンクしてC関数を呼び出すことが出来ますが、REPLで試そうとしてもREPLにリンクされていないので呼び出せません。
そこで呼び出したいオブジェクトファイルをリンクしたREPLを作れば捗るよね、という発想です。&lt;/p&gt;

&lt;h1 id=&#34;事前に必要なもの:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;事前に必要なもの&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;SML#のビルド時に使ったLLVMのパス&lt;/li&gt;
&lt;li&gt;SML#をビルドした時のオブジェクトファイルの残骸（一部）&lt;/li&gt;
&lt;li&gt;SML#のソーコード（一部）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;コマンド:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;コマンド&lt;/h1&gt;

&lt;p&gt;まず、普通のREPLを作るだけならこれだけです。（コンパイラも一緒にくっついてきますが面倒なのでそのままにしてます。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o oreore_repl &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot;  &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは最後のリンクコマンドにフラグを足せばいいでしょう。注意点として、64bit OSを使ってるならちゃんと32bitでビルドしたライブラリをリンクしましょう。例えばlibuvをリンクするならこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o smlsharp_uv &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot; -L /opt/libuv32/lib -luv &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;終わりに:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;終わりに&lt;/h1&gt;

&lt;p&gt;やり方さえ分かってしまえば簡単ですが見付けるのが難しい小ネタでした。因みに今回初級ですが、REPLにlibeditを統合するなどの上級ネタはいつか気が向いたら書くかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#に学ぶコンパイラ言語におけるREPLの実装方法</title>
      <link>/blog/2015/12/12/sml_nimanabukonpairagengoniokerureplnojissouhouhou</link>
      <pubDate>Sat, 12 Dec 2015 19:42:52 +0900</pubDate>
      
      <guid>/blog/2015/12/12/sml_nimanabukonpairagengoniokerureplnojissouhouhou</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装 Advent Calendar 2015&lt;/a&gt;16日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。かねてより気になっていたREPLの実装方法について、SML#のソースコードを読んだのでその話でもします。&lt;/p&gt;

&lt;p&gt;さて、ソースコードを読みながらやっていきましょう。SML# 2.0.0のソースコードです。&lt;/p&gt;

&lt;p&gt;REPLのエントリポイントは&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/compiler/main/main/SimpleMain.sml#L949&#34;&gt;src/compiler/main/main/SimpleMain.smlL949&lt;/a&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      | Interactive (options, context) =&amp;gt;
        let
          val newContext =
              Top.loadInteractiveEnv
                {stopAt = Top.NoStop,
                 stdPath = [#systemBaseDir options],
                 loadPath = nil}
                context
                (Filename.concatPath
                   (#systemBaseDir options, Filename.fromString &amp;quot;prelude.smi&amp;quot;))
          val context =
              let
                val context = Top.extendContext (context, newContext)
                val context = Top.incVersion context
              in
                context
              end
          val _ = ReifiedTermData.init (#topEnv context)
                  handle e =&amp;gt; raise e
        in
          RunLoop.interactive options context;
          SUCCESS
        end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いろいろごちゃごちゃやってますがオプションと共に&lt;code&gt;RunLoop.interactive&lt;/code&gt;を呼んでるだけです。&lt;/p&gt;

&lt;p&gt;さて、RunLoop.smlはSimpleMain.smlと同じディレクトリにあります。&lt;code&gt;interactive&lt;/code&gt;関数は次のように定義されています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun interactive options context =
      let
        ...
        val state = initInteractive ()
        fun loop context input =
            if !(#eof state) then ()
            else
              (Counter.reset();
               NameEvalEnv.intExnConList();
               case run options context input of
                 SUCCESS newContext =&amp;gt;
                 ....
               | FAILED =&amp;gt;
                 loop (Top.incVersion context) (interactiveInput state)
              )
      in
        loop context (interactiveInput state)
      end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何やら状態を初期化した後は&lt;code&gt;interactiveInput&lt;/code&gt;で得られた結果を&lt;code&gt;run&lt;/code&gt;に渡しているようです。&lt;code&gt;run&lt;/code&gt;を見ましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun run ({stdPath, loadPath, LDFLAGS, LIBS, errorOutput, llvmOptions,
            ...}:options)
          context input =
      let
        fun puts s = TextIO.output (errorOutput, s ^ &amp;quot;\n&amp;quot;)
        val options = {stopAt = Top.NoStop,
                       baseFilename = NONE,
                       stdPath = stdPath,
                       loadPath = loadPath}
        val ({interfaceNameOpt, ...}, result) =
             Top.compile options context input
             handle e =&amp;gt;
             (
               case e of
                 UserError.UserErrors errs =&amp;gt;
                 app (fn e =&amp;gt; puts (userErrorToString e)) errs
               | UserError.UserErrorsWithoutLoc errs =&amp;gt;
                 app (fn (k,e) =&amp;gt; puts (userErrorToString (Loc.noloc,k,e))) errs
               | Bug.Bug s =&amp;gt; puts (&amp;quot;Compiler bug:&amp;quot; ^ s)
               | exn =&amp;gt; raise exn;
               raise CompileError
            )
        val (newContext, module) =
            case result of
              Top.RETURN (newContext, module) =&amp;gt; (newContext, module)
            | Top.STOPPED =&amp;gt; raise Bug.Bug &amp;quot;run&amp;quot;
      in
        let
          val objfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.OBJEXT ())
          val asmfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.ASMEXT ())
          val _ = #start Counter.llvmOutputTimeCounter()
          val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile,
                                            Filename.toString asmfile)
          val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile,
                                            Filename.toString objfile)
          val _ = #stop Counter.llvmOutputTimeCounter()
          val _ = LLVM.LLVMDisposeModule module
          val sofile = TempFile.create (SMLSharp_Config.DLLEXT ())
          val ldflags =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                [&amp;quot;-Wl,-out-implib,&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
              | SMLSharp_Config.Mingw =&amp;gt;
                [&amp;quot;-Wl,--out-implib=&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
          val libfiles =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
              | SMLSharp_Config.Mingw =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
          val _ = BinUtils.link
                    {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS
                             @ ldflags,
                     libs = libfiles @ LIBS,
                     objects = [objfile],
                     dst = sofile,
                     useCXX = false,
                     quiet = not (!Control.printCommand)}
          val so = DynamicLink.dlopen&#39; (Filename.toString sofile,
                                        DynamicLink.GLOBAL,
                                        DynamicLink.NOW)
                   handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} =
              GenerateMain.moduleName (interfaceNameOpt, #version context)
          val smap = DynamicLink.dlsym&#39; (so, stackMapSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val base = DynamicLink.dlsym&#39; (so, codeBeginSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val _ = sml_register_stackmap (smap, base)
          val ptr = DynamicLink.dlsym (so, mainSymbol)
                    handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          (*
           * Note that &amp;quot;ptr&amp;quot; points to an ML toplevel code. This toplevel code
           * should be called by the calling convention for ML toplevels of
           * ML object files.  __attribute__((fastcc,no_callback)) is an ad
           * hoc way of yielding this convention code; no_callback avoids
           * calling sml_control_suspend.  If we change how to compile
           * attributes in the future, we should revisit here and update the
           * __attribute__ annotation.
           *)
          val mainFn =
              ptr : _import __attribute__((fastcc,no_callback)) () -&amp;gt; ()
        in
          loadedFiles := sofile :: !loadedFiles;
          mainFn () handle e =&amp;gt; raise UncaughtException e;
          SUCCESS newContext
        end
        handle e =&amp;gt;
          (
            case e of
              UserError.UserErrors errs =&amp;gt;
              app (fn e =&amp;gt; puts (userErrorToString e)) errs
            | UserError.UserErrorsWithoutLoc errs =&amp;gt;
              app (fn (k,e) =&amp;gt; puts (userErrorToString (Loc.noloc,k,e))) errs
            | DLError s =&amp;gt;
              puts (&amp;quot;failed dynamic linking. Perhaps incorrect name in _import declaration: &amp;quot; ^ s)
            | UncaughtException exn =&amp;gt;
              puts (&amp;quot;uncaught exception &amp;quot; ^ exnMessage exn)
            | CoreUtils.Failed {command, message} =&amp;gt;
              (puts (&amp;quot;command failed: &amp;quot; ^ command); puts message)
            | _ =&amp;gt; raise e;
            FAILED
          )
      end
      handle CompileError =&amp;gt; FAILED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デカいですね。どうやら&lt;code&gt;run&lt;/code&gt;がREPLの本体のようです。少しずつ見ていきます。&lt;/p&gt;

&lt;p&gt;まずはコンパイルしているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;        val ({interfaceNameOpt, ...}, result) =
             Top.compile options context input
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして結果からcontextとmoduleを取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;        val (newContext, module) =
            case result of
              Top.RETURN (newContext, module) =&amp;gt; (newContext, module)
            | Top.STOPPED =&amp;gt; raise Bug.Bug &amp;quot;run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恐らくcontextが変数名とかを持っているのでしょう。
moduleに関しては&lt;code&gt;Top.compile&lt;/code&gt;が最後にLLVMEmitをしてるのでLLVMのmodule(コンパイルされる最大単位)のことだと思います。だとするとここまではまだコードはメモリ上にあるはずです。&lt;/p&gt;

&lt;p&gt;moduleを取り出した後どうしてるかというとオブジェクトファイルを作っているようです。ここでファイルに書き出されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          val objfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.OBJEXT ())
          val asmfile = TempFile.create (&amp;quot;.&amp;quot; ^ SMLSharp_Config.ASMEXT ())
          val _ = #start Counter.llvmOutputTimeCounter()
          val _ = LLVM.compile llvmOptions (module, LLVM.AssemblyFile,
                                            Filename.toString asmfile)
          val _ = LLVM.compile llvmOptions (module, LLVM.ObjectFile,
                                            Filename.toString objfile)
          val _ = #stop Counter.llvmOutputTimeCounter()
          val _ = LLVM.LLVMDisposeModule module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に呼んでるDisposeModuleはデストラクタですかね。ちゃんとお片付けしてます。&lt;/p&gt;

&lt;p&gt;さらに、ダイナミックリンクファイルを作るようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val sofile = TempFile.create (SMLSharp_Config.DLLEXT ())
          val ldflags =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                [&amp;quot;-Wl,-out-implib,&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
              | SMLSharp_Config.Mingw =&amp;gt;
                [&amp;quot;-Wl,--out-implib=&amp;quot;
                 ^ Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; sofile)]
          val libfiles =
              case SMLSharp_Config.HOST_OS_TYPE () of
                SMLSharp_Config.Unix =&amp;gt; nil
              | SMLSharp_Config.Cygwin =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
              | SMLSharp_Config.Mingw =&amp;gt;
                map (fn x =&amp;gt; Filename.toString (Filename.replaceSuffix &amp;quot;lib&amp;quot; x))
                    (!loadedFiles)
          val _ = BinUtils.link
                    {flags = SMLSharp_Config.RUNLOOP_DLDFLAGS () :: LDFLAGS
                             @ ldflags,
                     libs = libfiles @ LIBS,
                     objects = [objfile],
                     dst = sofile,
                     useCXX = false,
                     quiet = not (!Control.printCommand)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時、Windowsでは何かしらの制約があるのか過去にリンクしたダイナミックリンクファイル(libfiles)も今回作るダイナミックリンクファイルにリンクしているようです。&lt;/p&gt;

&lt;p&gt;さて、ダイナミックリンクファイルを作った後は&lt;code&gt;dlopen&lt;/code&gt;を使ってダイナミックリンクします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val so = DynamicLink.dlopen&#39; (Filename.toString sofile,
                                        DynamicLink.GLOBAL,
                                        DynamicLink.NOW)
                   handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後はエントリポイントを捜してインポート、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val {mainSymbol, stackMapSymbol, codeBeginSymbol, ...} =
              GenerateMain.moduleName (interfaceNameOpt, #version context)
          val smap = DynamicLink.dlsym&#39; (so, stackMapSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val base = DynamicLink.dlsym&#39; (so, codeBeginSymbol)
                     handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
          val _ = sml_register_stackmap (smap, base)
          val ptr = DynamicLink.dlsym (so, mainSymbol)
                    handle OS.SysErr (msg, _) =&amp;gt; raise DLError msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;          val mainFn =
              ptr : _import __attribute__((fastcc,no_callback)) () -&amp;gt; ()
        in
          loadedFiles := sofile :: !loadedFiles;
          mainFn () handle e =&amp;gt; raise UncaughtException e;
          SUCCESS newContext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果を印字しているところが見当らないのですが吐かれたコードに印字部分も入っているんですかね。&lt;/p&gt;

&lt;p&gt;あとは&lt;code&gt;interactive&lt;/code&gt;に返ってコンテキストを拡張したりバージョンをインクリメントしたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;                   val context = Top.extendContext (context, newContext)
                   val context = Top.incVersion context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バージョンによってシンボル名を変えることで何度もsoファイルをロードしても大丈夫なようにしてるんですかね。&lt;/p&gt;

&lt;p&gt;ということでREPLの実装は入力を一旦ダイナミックリンクとしてコンパイルしてからロードしているようでした。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:7f851921bbb9914fa0252d9b589a6af0&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;REPLの入力部分は次のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;
  fun initInteractive () =
      let
        val lineCount = ref 1
        val eof = ref false
        fun read (isFirst, _:int) =
            let
              val prompt = if isFirst then &amp;quot;# &amp;quot; else &amp;quot;&amp;gt; &amp;quot;
              val _ = TextIO.output (TextIO.stdOut, prompt)
              val _ = TextIO.flushOut TextIO.stdOut
              val line = TextIO.inputLine TextIO.stdIn
              val _ = lineCount := !lineCount + 1
            in
              case line of NONE =&amp;gt; (eof := true; &amp;quot;&amp;quot;) | SOME s =&amp;gt; s
            end
      in
        {lineCount = lineCount, eof = eof, read = read}
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結構小さいので色々Hack出来ます。例えば&lt;a href=&#34;https://github.com/smlsharp/smlsharp/pull/13&#34;&gt;hskさんのように&lt;/a&gt;REPLを付けることも出来ます。&lt;/p&gt;

&lt;p&gt;このパッチで外部コマンドを呼ぶのが少し嫌な人はさらに&lt;code&gt;ioctl(2)&lt;/code&gt;を使ってrawモードにするパッチを当てるかlibeditなんかを使ってリッチな入力を実現するかをすればいいでしょう。
個人利用なら(他人に配布しないなら)GPLv3のreadlineも使えるんですかね（ライセンスに詳しくない）。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:7f851921bbb9914fa0252d9b589a6af0&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;REPLの実装にはダイナミックリンクを使う方法があるよ&lt;/li&gt;
&lt;li&gt;SML#のREPLはHack出来そうだよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#でJITコンパイラを作る軽い話</title>
      <link>/blog/2015/12/12/sml_dejitwotsukurukaruihanashi</link>
      <pubDate>Sat, 12 Dec 2015 17:26:24 +0900</pubDate>
      
      <guid>/blog/2015/12/12/sml_dejitwotsukurukaruihanashi</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/848&#34;&gt;ML Advent Calendar 2015&lt;/a&gt;及び&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lang_dev&#34;&gt;言語実装 Advent Calendar 2015&lt;/a&gt;15日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。先日流れてきた&lt;a href=&#34;http://www.jonathanturner.org/2015/12/building-a-simple-jit-in-rust.html&#34;&gt;RustでJITコンパイラを作る話&lt;/a&gt;が面白かったのでSML#でもやってみます。&lt;/p&gt;

&lt;h1 id=&#34;jitコンパイラってなに:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;JITコンパイラってなに？&lt;/h1&gt;

&lt;p&gt;JITはJust In Timeで、日本語にすると「間に合って」になります。誤読されかねませんが「臨時コンパイラ」と訳すのが適当なのでしょうか。&lt;/p&gt;

&lt;p&gt;普通のインタプリタがソースコードを直接評価するのに対してJITコンパイラはソースコードを内部で一旦ネイティブコードにコンパイルして実行します。&lt;/p&gt;

&lt;p&gt;よく、JITコンパイラ/JITコンパイルのことをJITと略して呼びます。&lt;/p&gt;

&lt;h1 id=&#34;どこで使うの:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;どこで使うの？&lt;/h1&gt;

&lt;p&gt;主に、インタプリタの高速化の目的で使われるようです。他にはコンパイラをインタプリタ化させる(REPLの実装とか)でも使えそうな気がしますが、詳しくは知りません。&lt;/p&gt;

&lt;h1 id=&#34;jitってどうやって作るの:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;JITってどうやって作るの？&lt;/h1&gt;

&lt;p&gt;JIT &lt;strong&gt;でない&lt;/strong&gt; コンパイラが吐いたコードは一旦ディスクからメモリに読まれ、メモリ上で実行されます。&lt;/p&gt;

&lt;p&gt;JITコンパイラが吐くコードは直接メモリに吐かれ、メモリ上で実行されます。なので細かい条件を無視すれば&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;吐かれる命令のための(特殊な)メモリ領域を用意する&lt;/li&gt;
&lt;li&gt;そこに実行したい命令列を書き込む&lt;/li&gt;
&lt;li&gt;書き込んだ命令列を実行する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;だけです。
3.の「書き込んだ命令を実行する」が若干ふわっとしてますが、多くの場合は命令の書かれたメモリを関数ポインタとして扱って、その関数を呼び出す形で実行されます。
一応直接プログラムカウンタをいじって書き込んだ命令列を実行させることも出来ます。&lt;/p&gt;

&lt;h1 id=&#34;一緒に作ってみよう:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;一緒に作ってみよう&lt;/h1&gt;

&lt;p&gt;思ったより簡単そうですね。作ってみましょう。&lt;/p&gt;

&lt;h2 id=&#34;1-メモリ領域を準備する:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;1. メモリ領域を準備する&lt;/h2&gt;

&lt;p&gt;先に「特殊な」と付言しましたのでそれについて説明しましょう。プロセス上のメモリは、OSによって保護されています。
特に、そのままではそのメモリ上の命令列を実行出来ません。その保護を外すために&lt;code&gt;mprotect(2)&lt;/code&gt;システムコールを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int mprotect(void *addr, size_t len, int prot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SML#を使えば簡単に使えるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val mprotect = _import &amp;quot;mprotect&amp;quot;: (unit ptr, word, word) -&amp;gt; int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SML#は2.0.0時点では32bitでしか動かないのでsize_tをwordとしてしまって大丈夫です。また、bit演算をやりたいので&lt;code&gt;prot&lt;/code&gt;は本来はintですがwordにしました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mprotect(2)&lt;/code&gt;はPOSIX(SUSv4)的には引数の&lt;code&gt;addr&lt;/code&gt;がシステムのページの境界上にあることを要求しても良いことになっています。
実際、OS Xが要求するらしいです。また、メモリ保護はページ単位で行われるため、&lt;code&gt;len&lt;/code&gt;もページサイズの倍数である必要があります。
&lt;code&gt;prot&lt;/code&gt;は保護フラグですね。&lt;/p&gt;

&lt;p&gt;メモリの確保、特にページの境界にアラインメントされたメモリ領域を確保するにはSML#では厳しそうなのでこれもCの関数に頼ります。
Linuxならいくつか方法はありますが、ポータブルには&lt;code&gt;posix_memalign(3)&lt;/code&gt;を使うのが良いようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int posix_memalign(void **memptr, size_t alignment, size_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもSML#から簡単に使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val posix_memalign = _import &amp;quot;posix_memalign&amp;quot;: (unit ptr ref, word, word) -&amp;gt; int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにメモリの解放も必要ですね。&lt;code&gt;free(3)&lt;/code&gt;もインポートしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val free = _import &amp;quot;free&amp;quot;: unit ptr -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、メモリを確保するのにいくつかCのマクロで定義された定数を定義しましょう。今のところSML#にCのマクロを使う術はなさそうです。どうにかしてCプリプロセッサを使えれば良いのですが…。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val PROT_READ  = 0wx1
val PROT_WRITE = 0wx2
val PROT_EXEC  = 0wx4
val PROT_NONE  = 0wx0

val PAGE_SIZE = 0w4096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ページサイズは本当は&lt;code&gt;sysconf(3)&lt;/code&gt;を使って&lt;code&gt;sysconf(PAGESIZE)&lt;/code&gt;として取るのが作法ですが面倒なので4KiB決め打ちにしてしまいました。&lt;/p&gt;

&lt;p&gt;さて、これらを用いてJIT用のメモリは次のように確保します。&lt;code&gt;Pointer&lt;/code&gt;モジュールが必要なのでsmiファイルで&lt;code&gt;require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt;しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val op orb = Word.orb
infix 5 orb
val size = 0wx1
val msize = size * PAGE_SIZE
val pageRef: unit ptr ref = ref (Pointer.NULL ())
val ret = posix_memalign (pageRef, PAGE_SIZE, msize)
val page = if ret = 0
           then !pageRef
           else raise Fail &amp;quot;memory allocation failed&amp;quot;
val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC
val ret = mprotect (page, msize, PROT_RWEX)
val () = if ret = 0
         then ()
         else raise Fail &amp;quot;memory protection error&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;page&lt;/code&gt;に実行可能フラグが立ったメモリが確保出来ました。sizeは書き込みたい命令列に応じて変えます。&lt;/p&gt;

&lt;h1 id=&#34;2-命令列を書き込む:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;2. 命令列を書き込む&lt;/h1&gt;

&lt;p&gt;さて、ここらへんからアセンブラの世界になってきます。&lt;/p&gt;

&lt;p&gt;まず、安全のために件のメモリ領域を&lt;code&gt;ret&lt;/code&gt;命令で埋めます。
&lt;code&gt;ret&lt;/code&gt;命令は関数から戻る時に使われる命令で、変なことをしても&lt;code&gt;ret&lt;/code&gt;で元の場所に戻ればどうにかなる可能性があるのです。&lt;/p&gt;

&lt;p&gt;メモリを一気に埋めるには&lt;code&gt;memset(3)&lt;/code&gt;が便利です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void *memset(void *s, int c, size_t n);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをSMLにインポートして使いましょう。&lt;code&gt;ret&lt;/code&gt;命令に対応するマシン語は&lt;code&gt;0xc3&lt;/code&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val memset = _import &amp;quot;memset&amp;quot;: (unit ptr, word, word) -&amp;gt; unit ptr
val _ = memset (page, 0wxc3, msize)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃあ、命令を書き込んでいきましょう。最初はただ1を返すだけの関数に相当する命令です。
64bitマシンを使っていても32bitでコンパイルしたSML#を使っている限りはx86(IA32)のアセンブラを使います。
x86は値を&lt;code&gt;eax&lt;/code&gt;レジスタに入れることで返り値とします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;mov 1 eax
ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードを&lt;a href=&#34;https://defuse.ca/online-x86-assembler.htm#disassembly&#34;&gt;オンラインアセンブラ&lt;/a&gt;でアセンブルしてみると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0:  b8 01 00 00 00          mov    eax,0x1
5:  c3                      ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;との結果が返ってきました。これを真心込めて1つづつメモリに書き込んでいきます。
SML#からメモリに直接書き込むには内部APIっぽいものを触る必要があります。
タイプ数を減らすためにいくつかエイリアスを定義しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
val store = Pointer.store
val advance = Pointer.advance
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メモリにword8の値を書き込むのにキャストが必要になるので&lt;code&gt;fromUnitPtr&lt;/code&gt;を使います。
さて、書き込んでいきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val mem: word8 ptr = fromUnitPtr page
val () = store page 0wxb8
val mem = advance mem
val () = store page 0wx01
val mem = advance mem
val () = store page 0wx00
val mem = advance mem
val () = store mem 0wx00
val mem = advance mem
val () = store mem 0wx00
val mem = advance mem
val () = store mem 0wxc3
val _ = advance mem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;page&lt;/code&gt;に1を返すだけの命令列が書き込まれした。&lt;/p&gt;

&lt;h2 id=&#34;3-書き込んだ命令列を実行する:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;3. 書き込んだ命令列を実行する&lt;/h2&gt;

&lt;p&gt;書き込んだ命令列は関数にキャストして使うことが多いと言いました。今回もそのようにします。&lt;/p&gt;

&lt;p&gt;そのために、また内部APIっぽいものを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;codeptr&lt;/code&gt;型は関数ポインタを表すもののようです。&lt;code&gt;DynamicLink&lt;/code&gt;モジュールなどで使われています。&lt;/p&gt;

&lt;p&gt;さて、今回の1を返すだけの命令列は&lt;code&gt;() -&amp;gt; int&lt;/code&gt;型になりますね。
それをインポート、実行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val freturn1 = toCodePtr page: _import () -&amp;gt; int
val () = print ((Int.toString (freturn1 ())) ^ &amp;quot;\n&amp;quot;)
val _ = free page
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで見事&lt;code&gt;1&lt;/code&gt;が印字されたら成功です。&lt;/p&gt;

&lt;h1 id=&#34;さらに:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;さらに&lt;/h1&gt;

&lt;p&gt;先程のコードは繰り返しが多く、整理されていませんでした。もう少し整理しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure Emit = struct
    val posix_memalign = _import &amp;quot;posix_memalign&amp;quot;: (unit ptr ref, word, word) -&amp;gt; int
    val mprotect = _import &amp;quot;mprotect&amp;quot;: (unit ptr, word, word) -&amp;gt; int
    val memset = _import &amp;quot;memset&amp;quot;: (unit ptr, word, word) -&amp;gt; unit ptr
    val free = _import &amp;quot;free&amp;quot;: unit ptr -&amp;gt; ()
    val printf = _import &amp;quot;printf&amp;quot;: (string, unit ptr) -&amp;gt; ()

    (* 
#define PROT_READ	0x1		/* Page can be read.  */
#define PROT_WRITE	0x2		/* Page can be written.  */
#define PROT_EXEC	0x4		/* Page can be executed.  */
#define PROT_NONE	0x0		/* Page can not be accessed.  */
    *)

    val PROT_READ  = 0wx1
    val PROT_WRITE = 0wx2
    val PROT_EXEC  = 0wx4
    val PROT_NONE  = 0wx0

    val PAGE_SIZE = 0w4096

    type jitptr = word8 ptr
    val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
    val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr
    val toCodeptr = SMLSharp_Builtin.Pointer.toCodeptr
    val store = Pointer.store
    val advance = Pointer.advance


    fun jitMemory size: jitptr = let
        val op orb = Word.orb
        infix 5 orb
        val msize = size * PAGE_SIZE
        val pageRef: unit ptr ref = ref (Pointer.NULL ())
        val ret = posix_memalign (pageRef, PAGE_SIZE, msize)
        val page = if ret = 0
                   then !pageRef
                   else raise Fail &amp;quot;memory allocation failed&amp;quot;
        val PROT_RWEX = PROT_READ orb PROT_WRITE orb PROT_EXEC
        val ret = mprotect (page, msize, PROT_RWEX)
        val () = if ret = 0
                 then ()
                 else raise Fail &amp;quot;memory protection error&amp;quot;
        (* init with ret for safety *)
        val _ = memset (page, 0wxc3, msize)
    in
        fromUnitPtr page
    end

    fun freeJit (jitMem: jitptr) = free (SMLSharp_Builtin.Pointer.toUnitPtr jitMem)

    fun pushWord page (word: word8) = (store (page, word); advance (page, 1))
    fun pushWords (page: jitptr) l = List.foldl (fn(w,page) =&amp;gt; pushWord page w) page l

    val import: jitptr -&amp;gt; codeptr = toCodeptr o toUnitPtr

    fun fromMachineCode l = let
        val len = Word.fromInt(List.length l)
        val size = (len + PAGE_SIZE) div PAGE_SIZE
        val page = jitMemory size
        val _ = pushWords page l
    in
        import page
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のように使います。一回importした関数はfreeしないことにしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun println x = print (x ^ &amp;quot;\n&amp;quot;)
val return1  =
    (* 0:  b8 01 00 00 00          mov    eax,0x1  *)
    [
      0wxb8, 0wx01, 0wx00, 0wx00, 0wx00
    ] 
val freturn1 = Emit.fromMachineCode return1 :_import () -&amp;gt; int
val () = println (Int.toString (freturn1 ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引数を取る:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;引数を取る&lt;/h2&gt;

&lt;p&gt;もうアセンブラの話になります。&lt;/p&gt;

&lt;p&gt;x86では引数は右から順にスタックに積まれます。intを1つ取ってそれに1足して返す関数はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val add1 = 
    (* 0:  8b 44 24 04             mov    eax,DWORD PTR [esp+0x4] *)
    (* 4:  83 c0 01                add    eax,0x1 *)
    [
      0wx8b, 0wx44, 0wx24, 0wx04,
      0wx83, 0wxc0, 0wx01
    ]
val fadd1 = Emit.fromMachineCode add1 :_import (int) -&amp;gt; int
val () = println (Int.toString (fadd1 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常に動けば4が印字されます。&lt;/p&gt;

&lt;h1 id=&#34;つらい話:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;つらい話&lt;/h1&gt;

&lt;h2 id=&#34;バグ:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;バグ&lt;/h2&gt;

&lt;p&gt;最初、&lt;code&gt;Pointer.store&lt;/code&gt;でなく、&lt;code&gt;SMLSharp_Builtin.Pointer.store&lt;/code&gt;を使っていたら&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/43&#34;&gt;変なバグ&lt;/a&gt;踏みました。バグというか使い方が悪かった。&lt;/p&gt;

&lt;h2 id=&#34;デバッグ:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;デバッグ&lt;/h2&gt;

&lt;p&gt;デバッガがないので非常につらいです。書き出された命令列を見るのに困りました。gdbで見たかったので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val printf = _import &amp;quot;printf&amp;quot;: (string, unit ptr) -&amp;gt; int
val _ = pritnf (&amp;quot;page pointr: %p&amp;quot;, page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;して&lt;code&gt;printf&lt;/code&gt;にブレークポイントを張り、そこで止めつつページのアドレスを取得、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;(gdb) x/20xh 0x81ca000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとして見ていました。&lt;/p&gt;

&lt;h1 id=&#34;もっと:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;もっと&lt;/h1&gt;

&lt;p&gt;JITコンパイラが楽しかったのでアセンブラのDSLを作ってみました。1、2個の命令吐けるだけですがちゃんと動きました。今のところこのように書けます。Intel記法だとしんどそうだったのでAT&amp;amp;T記法っぽく書けるようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val freturn1&#39; = Emit.fromInsts [
        xorl eax eax,
        addl ($1) eax,
        ret
    ]:_import () -&amp;gt; int
val () = println (Int.toString (freturn1&#39; ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x86は命令フォーマットが1バイトから15バイトまでの可変長で、内部表現をどのようにするか決めるだけでも一苦労でした。x86つらい。&lt;/p&gt;

&lt;p&gt;アドレッシングが複雑なのも悩みどころで、複数のアドレッシングを統一的に扱えるようにオーバーロードされた関数を用意したのですがあえなくSML#のバグを踏んで死亡しました。本当はこういう記法が出来る筈だった…&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;addl (%eax) eax
addl eax (%eax)
addl eax (%(eax, ebx))
addl eax (%(eax, ebx, 4))
addl eax (%(4, eax))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/bin/smlsharp   -c -o main.o main.sml
uncaught exception: Bug.Bug: InferType: FIXME: user error: invalid instTy at src/compiler/typeinference2/main/InferTypes2.sml:47
Makefile:11: recipe for target &#39;main.o&#39; failed
make: *** [main.o] Error 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;movl&lt;/code&gt;を実装しようとしたらアドレッシングが動かなかったので萎えてまだ実装してません。&lt;/p&gt;

&lt;p&gt;よく考えたら&lt;code&gt;%&lt;/code&gt;ってミスリーディングだし名前変えよう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:adcfd48c9789a206f0f1cfad72bd4b5a&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;JITを作るにはメモリ保護をいじれて関数ポインタのインポートが出来ればいいよ&lt;/li&gt;
&lt;li&gt;SML#でもJIT作れるよ&lt;/li&gt;
&lt;li&gt;アセンブラっぽいの作ったよ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/smljit&#34;&gt;こちら&lt;/a&gt;にあります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#でDBに接続</title>
      <link>/blog/2015/12/05/sml_dedbnisetsuzoku</link>
      <pubDate>Sat, 05 Dec 2015 22:04:25 +0900</pubDate>
      
      <guid>/blog/2015/12/05/sml_dedbnisetsuzoku</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://www.adventar.org/calendars/848&#34;&gt;ML Advent Calendar&lt;/a&gt;6日目の記事です。&lt;br /&gt;
次はdico_leque先生で、「ML中心にしつつ何か」です。&lt;/p&gt;

&lt;p&gt;κeenです。SMl#はDB接続及びSQLを言語レベルでサポートしていることが大きな特徴ですが詳細な方法についてはあまり情報がなく、
実際に利用するのは難しい状況にあります。そこで私がなんとかソースコードを読んで得られた知識を少し共有したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;接続サーバ設定:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続サーバ設定&lt;/h1&gt;

&lt;p&gt;DBへの接続サーバ設定には&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_sqlserver serverLocation : τ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;式を使います。このserverLocationはDB毎に指定方法が異なります。公式のドキュメントにはデフォルトDBであるPostgreSQLへの接続方法しか書かれていませんが、いくつかのDBをサポートします。&lt;/p&gt;

&lt;p&gt;SML#はDB接続時にテーブルの型を要求します(上でいう型注釈の&lt;code&gt;τ&lt;/code&gt;がそれです。文法的に型注釈がないといけません。)。今回の例では公式ドキュメントにある通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE mydb;
CREATE TABLE Persons (
  name text not null,
  age int not null,
  salary int not null
);
USE mydb;
INSERT INTO Persons VALUES (&#39;Joe&#39;, 21, 10000);
INSERT INTO Persons VALUES (&#39;Sue&#39;, 31, 20000);
INSERT INTO Persons VALUES (&#39;Bob&#39;, 41, 30000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で作ったDBへ接続することにします。&lt;/p&gt;

&lt;h2 id=&#34;テーブルの型:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;テーブルの型&lt;/h2&gt;

&lt;p&gt;深追いしてないので分かりません。とりあえず今回使う&lt;code&gt;mydb&lt;/code&gt;は&lt;code&gt;{Persons:{name:string, age:int, salary :int}&lt;/code&gt;で接続出来るみたいです。これも追わねば…&lt;/p&gt;

&lt;p&gt;一応ソースを読む限りだとint, decimal, real32, float, real, string, bool, timestampがあるようです。NULLableなカラムにはoptionを使うようです。&lt;/p&gt;

&lt;p&gt;SMLで見慣れないdecimal, float, timestampはSML#が実装を持っているようです。&lt;/p&gt;

&lt;p&gt;float, decimalは内部表現は文字列で、文字列との相互及びrealとIEEERealへの変換が出来るようです。&lt;/p&gt;

&lt;p&gt;timestampは文字列との相互変換及び&lt;code&gt;now()&lt;/code&gt;関数, &lt;code&gt;defaultTimestamp&lt;/code&gt;が存在します(スキーマに&lt;code&gt;DEFAULT&lt;/code&gt;指定があった時用)。内部表現はunix timeなのか、intです。&lt;/p&gt;

&lt;p&gt;それぞれ&lt;code&gt;SQL.Float&lt;/code&gt;, &lt;code&gt;SQL.Decimal&lt;/code&gt;, &lt;code&gt;SQL.TimeStamp&lt;/code&gt;モジュールに入っています。&lt;/p&gt;

&lt;h2 id=&#34;postgresql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;PostgreSQL&lt;/h2&gt;

&lt;p&gt;デフォルト設定のpgのmydbというDBへ接続したいならこれで接続出来ると公式ドキュメントに書いてあるのですが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (dbname=&amp;quot;mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと最後の &lt;code&gt;}&lt;/code&gt;が1つ抜けている上、それを補っても&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(interactive):2.27-2.32 Error: (name evaluation &amp;quot;190&amp;quot;) unbound variable: dbname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と返してきます。正しくは(?)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。他のパラメータ、例えばホストやポート、パスワードを渡したい場合はスペース区切で渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val myServer = _sqlserver (&amp;quot;dbname=mydb host=localhost password=hogehoge&amp;quot;) : {Persons:{name:string, age:int, salary :int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この文字列はそのままPostgreSQLの&lt;a href=&#34;http://www.fireproject.jp/feature/postgresql/programing_libpq/connect.html#2&#34;&gt;&lt;code&gt;PGconnectdb&lt;/code&gt;&lt;/a&gt;という関数に渡っているのでそのドキュメントに完全な受付可能なキーが書いてあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host: DBサーバ名&lt;/li&gt;
&lt;li&gt;hostaddr: DBサーバのIPアドレス&lt;/li&gt;
&lt;li&gt;user: DB接続時のユーザ名&lt;/li&gt;
&lt;li&gt;password: userに対するパスワード&lt;/li&gt;
&lt;li&gt;dbname: DB名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とのことです。&lt;/p&gt;

&lt;h2 id=&#34;mysql:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;MySQL&lt;/h2&gt;

&lt;p&gt;ドキュメントはありませんがソースコードを読んである程度勘を効かせた上で色々書いて試行錯誤すれば接続方法は分かります。&lt;/p&gt;

&lt;p&gt;MySQLに接続するには以下のように&lt;code&gt;SQL.mysql&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = _sqlserver (SQL.mysql &amp;quot;dbname=mydb&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余談ですが&lt;code&gt;_sqlserver&lt;/code&gt;はオーバーロードされていて、backend型とstring型両方を受け付けます。
文字列が来た時には&lt;code&gt;SQL.default&lt;/code&gt;に渡されます。そして &lt;code&gt;val default = postgresql&lt;/code&gt;です。つまり、PostgreSQLの例は&lt;code&gt;_sqlserver (SQL.postgresql &amp;quot;dbname=mydb&amp;quot;)&lt;/code&gt;
としているのと同じです。&lt;/p&gt;

&lt;p&gt;閑話休題。MySQLの時に渡せるパラメータの話をしましょう。こちらはバックエンドの接続関数にそのまま渡してる訳ではないのですが、
SML#側でパーサを持っているのでPostgreSQLの時のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;SQL.mysql &amp;quot;dbname=mydb host=localhost&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで使えるキーは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val availableKeys = [&amp;quot;host&amp;quot;, &amp;quot;port&amp;quot;, &amp;quot;user&amp;quot;, &amp;quot;password&amp;quot;, &amp;quot;dbname&amp;quot;, &amp;quot;unix_socket&amp;quot;, &amp;quot;flags&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義されています&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。因みにこれはパースエラーにならない文字列の集合であって、&lt;code&gt;unix_socket&lt;/code&gt;を使おうとするとコネクションエラーになるようです(&lt;code&gt;raise Connect &amp;quot;unix_socket is not supported&amp;quot;&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;文法に関して深掘りすると、一応パーサ(&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/KeyValuePair.sml&#34;&gt;src/sql/main/KeyValuePair.sml&lt;/a&gt;)を読む限りだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;keyは &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;(&lt;code&gt;isAlphanum&lt;/code&gt; + &lt;code&gt;#&#39;_&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueはスペース以外の文字列(e.g. &lt;code&gt;hogehoge&lt;/code&gt;)又は&lt;code&gt;&#39;&lt;/code&gt;で囲まれた文字列(e.g. &lt;code&gt;&#39;hoge hoge&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;valueでは&lt;code&gt;\&lt;/code&gt;によるエスケープが可能(e.g. &lt;code&gt;hoge\ hoge&lt;/code&gt;, &lt;code&gt;&#39;a \&#39;quote\&#39;&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;\&lt;/code&gt;については文字列の中なので&lt;code&gt;\&lt;/code&gt;自身のエスケープが必要なことに注意して下さい。&lt;/p&gt;

&lt;h2 id=&#34;unixodbc:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;unixODBC&lt;/h2&gt;

&lt;p&gt;ご存知ない方に説明するとODBCはOpen Database Connectivityの略です。Microsoftが主導となって定めたDB接続のインターフェースです。また、そのインターフェースに従うドライバマネージャのことも指します。
一旦抽象化レイヤを挟むのでパフォーマンス面では生の接続に負けますが、豊富な接続先が魅力です。
MicroSoftのSQL ServerやMicroSoft Accessを始めとし、Oracle, MySQL, PostgreSQL, SQLite3, 果てはMongoDBなどにまで接続出来ます。
まあ、接続出来るからといって投げたクエリを正しく解釈、実行してくれるとは限りませんが…&lt;/p&gt;

&lt;p&gt;unixODBCはODBCのunix実装のようです。つまりODBCドライバを持つDBにunixから接続出来ます。&lt;/p&gt;

&lt;p&gt;さてさて、odbcに繋ぐには以下のようにします。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myServer = (SQL.odbc &amp;quot;mydb username mypassword&amp;quot;) : {Persons:{name: string, age: int, salary: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜ記法変えたし…。&lt;del&gt;しかも必ずスペースで区切るのでクォートも出来なければ空のユーザパスワードを渡すことも出来ません。もしかしたら&lt;code&gt;&amp;quot;&#39;&#39;&amp;quot;&lt;/code&gt;としたら後側で空の文字列と扱ってくれるかもしれませんが。&lt;/del&gt;
私が&lt;code&gt;String.fields&lt;/code&gt;の挙動を勘違いしてました。スペースで区切って空にしておけば空パスワードを渡せます(e.g. &lt;code&gt;&amp;quot;mydb username &amp;quot;&lt;/code&gt;)。あるいは空ユーザ名も(&lt;code&gt;&amp;quot;mydb  &amp;quot;&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;私自身ODBCに詳しくないのですが、ODBCに接続するときはData Source Nameと呼ばれるものがシステムの特定の場所に存在するので他の接続情報は必要ないみたいです。&lt;/p&gt;

&lt;h1 id=&#34;接続:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;接続&lt;/h1&gt;

&lt;p&gt;さっきまでは接続サーバの設定の話でした。今度は実際に接続する話です。DBMS固有の話はサーバ設定までなのでこれからは総のDBに共通です。&lt;/p&gt;

&lt;p&gt;接続するには公式のドキュメント通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val conn = SQL.connet myServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で繋げます。ここで各クライアントのダイナミックリンクライブラリがないとエラーになります。64dbit環境でSML#を32bitでビルドしている人はライブラリも32bitでビルドされていることを確認しましょう。&lt;/p&gt;

&lt;h1 id=&#34;クエリ:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;クエリ&lt;/h1&gt;

&lt;p&gt;これもドキュメント通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val myQuery = _sql db =&amp;gt; select #P.name as name, #P.age as age
      from #db.Persons as P
      where SQL.&amp;gt;(#P.salary, 10000)
val rel = _sqleval myQuery conn
val result = SQL.fetchAll rel; (* =&amp;gt; [{age=32, name=&amp;quot;Sue&amp;quot;}, {age=41, name=&amp;quot;Bob&amp;quot;}] *)
val () = SQL.closeRel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;p&gt;可能な文法については主に&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch10.S5.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;を参考にしましょう。&lt;/p&gt;

&lt;p&gt;insert, update, deleteをサポートしている他、トランザクション(&lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt;)をサポートしているようです。詳しくは&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/compiler/parser2/main/iml.grm#L727&#34;&gt;BNF&lt;/a&gt;を読んで下さい。&lt;/p&gt;

&lt;p&gt;SQLを投げて返ってきたリレーションに対しては結果を総取得する&lt;code&gt;SQL.fetchAll&lt;/code&gt;、結果をoption型で1つ取得する&lt;code&gt;SQL.fetch&lt;/code&gt;、結果を1つ取得するか例外になる&lt;code&gt;SQL.fetchOne&lt;/code&gt;を使います。&lt;code&gt;fetchOne&lt;/code&gt;の上げる例外は&lt;code&gt;SQL.NotOne&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;クエリ結果を使い終わったら必ず&lt;code&gt;SQL.closeRel&lt;/code&gt;で開放しましょう。そしてコネクションも、終わったら&lt;code&gt;SQL.closeCon&lt;/code&gt;で開放しましょう。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:266f018cfddfb35ef84ed8e5e46d71a6&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;本当は実際に試してから記事を書きたかったのですが、32bitの壁に阻まれて出来ませんでした。しかしソースを読んで裏を取って書いてあるのでまあまあ信憑性のある内容だと思います。
SML# からデータベースに接続したい方の一助になれば幸いです。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/MySQLBackend.sml#L184&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;a href=&#34;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&#34;&gt;https://github.com/smlsharp/smlsharp/blob/master/src/sql/main/ODBCBackend.sml#L270&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:266f018cfddfb35ef84ed8e5e46d71a6:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>SMLでPNGデコーダを作ろうとして分かったこと</title>
      <link>/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</link>
      <pubDate>Fri, 04 Sep 2015 06:45:19 +0900</pubDate>
      
      <guid>/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLでPNGデコーダを作ろうとして分かったこと
------------------------------------------
サイバーエージェント アドテクスタジオ  
エンジニア月初会
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
----------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒
 + Lisp, ML, Shell Scriptあたりを書きます


&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うーむ。画像フォーマットの扱い一回くらい書いてみないとなーと思ってたけどやっぱり既存なんだよなー。Common LispかSMLあたりならフロンティアになれそう。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639303085240643584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 仕様を理解するためにデコーダから実装するのがオススメです&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639304790766305281&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; そんな詳しいわけではないんですが、jpegかpngがおすすめです。webpは動画コーデック由来で難しいと思います。tiffは画像コンテナみたいな立ち位置なので画像フォーマット感がないかなと。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639307400244137984&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

明日の朝までに  
&lt;span style=&#39;font-size:150%;&#39;&gt;SMLでpngデコーダを実装しよう&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Standard ML
-------------

* ML系の函数型言語
* 文法はOCamlよりF#に似てる（というかF#が似せてきた）
* 結構書き易い
* 仕様は SML&#39;90とSML&#39;97がある
* 仕様で言語のformal semanticsが定められてたりする
* 要は研究向き
  + **ライブラリほぼなし**
  + **コミュニティほぼなし**


&lt;span style=&#39;font-size:250%;&#39;&gt;＞　無理ゲー　＜&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 一応フォーマットを調べる
------------------------


```
+-----------------+
|     Chunk       | 画像はChunkの集合。
++---------------++ Chunk自体は簡単なフォーマット
|| length | name ||
|+---------------+|
||    data       ||
||    ...        ||
|+---------------+|
||    CRC        ||
++---------------++
|    Chunk        |
|    ...          |
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
意外と単純？
&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# とりあえず書いてみる
---------------------

```sml
structure PNG = struct
    fun readChunk data i = ...
end
```


# 案外苦戦
------------
* 型が厳密なので型の行き来が面倒
  + 8bit &lt;-&gt; 32bit
  + 符号付き &lt;-&gt; 符号無し
  + byte &lt;-&gt; char

```sml
val op &lt;&lt; = Word.&lt;&lt;
val op &gt;&gt; = Word.&gt;&gt;

fun nameToWord name = CharVector.foldl (fn(c, acc) =&gt; &lt;&lt;(acc, 0w8) + (Word.fromInt (ord c))) 0w0 name
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
3時間後
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;さて、メインのデータ抜き出すところまでは行ったけど次復号だ。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639501771430211584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 今更PNGについて
----------------

* GIFの特許問題を回避するために作られたフォーマット
  + LZ77がマズいらしい
* **可逆圧縮アルゴリズムを使う** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + **アルゴリズムは1つとは限らない** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
  + 但し仕様で指定されているのはzlibのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
* フィルタを噛ませることでプログレッシブな表示も可能


# SMLのZLibライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
zlib……実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ZLib
------

* RFC-1950
* zipやpngで使われるフォーマット
* ZLib自体は圧縮データのコンテナで **圧縮アルゴリズム自体は1つとは限らない**  &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + 但し仕様で指定されているのはdeflateのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;


# SMLのDeflateライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
deflate…実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Deflate
---------

* RFC-1951
* ハフマン符号の変種の可逆圧縮アルゴリズム
  + **3種類の符号化方式を自由に使ってよい** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;



&lt;span style=&#39;font-size:250%;&#39;&gt;(心)ボキッ&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 学んだこと
-----------

* PNGは一晩でデコーダを書ける程柔じゃない
  + 事前調査も大事
* 書き易い言語でもコミュニティが大事
* 1晩でLTの準備はつらい


# 付録
------

* [今回のコード](https://github.com/KeenS/sml-png)
* [SMLのパッケージマネージャ](https://github.com/standardml/smackage)
* [PNG](http://www.w3.org/TR/2003/REC-PNG-20031110/)
* [RFC-1950 ZLIB](https://www.ietf.org/rfc/rfc1950.txt)
* [RFC-1951 DEFLATE](https://www.ietf.org/rfc/rfc1950.txt)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>TCOと例外ハンドル</title>
      <link>/blog/2015/05/31/tcotoreigaihandoru</link>
      <pubDate>Sun, 31 May 2015 21:02:08 +0900</pubDate>
      
      <guid>/blog/2015/05/31/tcotoreigaihandoru</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou&#34;&gt;先日のエントリー&lt;/a&gt;の最後でループ内で例外ハンドルをすると極端に遅くなるということを書きましたが、それについて。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/604235677337714689&#34;&gt;2015, 5月 29&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; うーん、ちょっと例外のことは詳しくないんですが、予想だと例外ハンドラをループ内にいれると毎回スタックに積むんで外す操作がはさまることになるのでレジスタで完結してるようなループ処理だと露骨に遅くなるかもしれません&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604537509771501569&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; あーありえますね。ジャンプで済むところを戻ってきてスタックに積んだのを除去しないといけませんからね。ちょっと手元にマシンが無いのですがネイティブコードで実験してみますー&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604540519188815872&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; ocamlでも例外ハンドラのはさみ方で末尾再帰になったり、ならなかったりするというのは聞いたことがあるので多分あたりな気がします&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/604545844000325632&#34;&gt;2015, 5月 30&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということで実験してみましょう。&lt;/p&gt;

&lt;p&gt;次のような何がしたいのか分からないループのベンチマークを取ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は無限ループではなく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uncaught exception: Subscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、境界外アクセスの例外が出ます。因みにSubscripは添字って意味だそうです。&lt;/p&gt;

&lt;p&gt;これではベンチマークがとれないので、例外が起きたらループを抜けるようにしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Subscript =&amp;gt; ()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 5 ms/1calls
  [Average] 5.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一瞬ですね。では、末尾呼び出し位置でhandleしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(100, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        loop ()
        handle Subscript =&amp;gt; ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                 )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 1729 ms/1calls
  [Average] 1729.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふーむ。やはり大分遅くなってますね。しかしループ内で例外をハンドルした所為かもしれないのでループ内で非末尾位置で例外をハンドルしてみます。大域脱出に例外使いますがまあ、パフォーマンスに問題ないでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;exception Exit
val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1)
        handle Subscript =&amp;gt; raise Exit;
        i := (!i) + 1;
        loop ()
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Exit =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 11 ms/1calls
  [Average] 11.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やはり多少は遅くなってますが末尾位置の時のように極端には遅くなってないようです。&lt;/p&gt;

&lt;p&gt;最後に非末尾再帰ループの速度を測っておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val arr = Array.array(1000000, 0)
    val i = ref 0
    fun loop () = (
        Array.update(arr, !i, 1);
        i := (!i) + 1;
        1 + (loop ())
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop()
                                     handle Subscript =&amp;gt; 0
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 403 ms/1calls
  [Average] 403.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思ったより遅いですね。ループか末尾例外ハンドルかというと末尾例外ハンドルに近いスコア。&lt;/p&gt;

&lt;h1 id=&#34;考察:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;考察&lt;/h1&gt;

&lt;p&gt;末尾位置で例外をハンドルすると遅くなる原因はTCOが効かないから、で合ってそうです。&lt;/p&gt;

&lt;p&gt;しかしそれにしても遅いですね。例外ハンドラをスタックに積むのが1関数呼び出しくらいならせいぜい倍くらいの遅さで済む筈です。
もしかしたらループ展開とかの外の最適化も掛からなくなるのかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;結論:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;結論&lt;/h1&gt;

&lt;p&gt;例外をハンドルする時は位置に気をつけましょうね。&lt;/p&gt;

&lt;h1 id=&#34;付録a:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;ベンチマーカはこんなコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure Benchmark =
struct
fun repeat 0 f = ()
  | repeat n f =  (f ();repeat (n - 1) f)
 
fun bench n f = let
    val startTime = Time.now ()
    val _ = repeat n f
    val endTime = Time.now ()
in
    Time.toMilliseconds (Time.-(endTime, startTime))
end
 
fun benchmark name n f = let
    val time = bench n f
in
    print (name ^ &amp;quot;\n&amp;quot;);
    print (&amp;quot; Time:\n&amp;quot;);
    print (&amp;quot;    [Total] &amp;quot; ^ (LargeInt.toString time) ^ &amp;quot; ms/&amp;quot; ^ (Int.toString n) ^ &amp;quot;calls\n&amp;quot;);
    print (&amp;quot;  [Average] &amp;quot; ^ (Real.toString((Real.fromLargeInt time) / (Real.fromInt n))) ^ &amp;quot; ms/call\n&amp;quot;)
end

fun nChars n char = CharArray.vector(CharArray.array(n, char))

fun toWidth width str = let
    val len = String.size str
in
    if len &amp;lt; width
    then str ^ (nChars (width - len) #&amp;quot; &amp;quot;)
    else str
end

fun histLine width base value =
  (nChars (Int.fromLarge(width * value div base)) #&amp;quot;*&amp;quot;) ^ &amp;quot;\n&amp;quot;

fun benchset name n fs = let
    val res = List.map (fn (label, f) =&amp;gt; (label, bench n f)) fs
    val max = List.foldl (fn ((_, time), m) =&amp;gt; LargeInt.max(time, m)) 0 res
    val maxLen = List.foldl (fn ((label, _), m) =&amp;gt; Int.max(String.size label,  m)) 0 fs
in
    print &amp;quot;name:\n&amp;quot;;
    print ((nChars ((String.size &amp;quot; &amp;quot;) + maxLen) #&amp;quot;-&amp;quot;) ^ &amp;quot;+&amp;quot; ^ (nChars ((String.size &amp;quot;|&amp;quot;) +  50) #&amp;quot;-&amp;quot;) ^ &amp;quot;\n&amp;quot;);
    app (fn (label, time) =&amp;gt; print(&amp;quot; &amp;quot; ^ (toWidth maxLen label) ^ &amp;quot;|&amp;quot; ^(histLine (50:LargeInt.int) max time))) res;
    print ((nChars ((String.size &amp;quot; &amp;quot;) + maxLen) #&amp;quot;-&amp;quot;) ^ &amp;quot;+&amp;quot; ^ (nChars ((String.size &amp;quot;|&amp;quot;) +  50) #&amp;quot;-&amp;quot;) ^ &amp;quot;\n&amp;quot;)
end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;付録b:f585d8bf5500b51a365c4e77d660ffa5&#34;&gt;付録B&lt;/h1&gt;

&lt;p&gt;元々、なんでこの問題が生じたかというと一々境界チェックして配列にアクセスするより例外出させといた方が速いんじゃね？ってことでそういうコードを書いたからです。
例外が出るってことは内部でも境界チェックしてる筈ですから。&lt;/p&gt;

&lt;p&gt;ということでどちらが速いか確認してみましょう。&lt;/p&gt;

&lt;p&gt;まず例外ハンドル方式。先程のままだと数ミリ秒で終わってたので配列の大きさを10倍しました。あと。実際に書きそうな書き方に変えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val len = 10000000
    val arr = Array.array(len, 0)
    fun loop i = (
        Array.update(arr, i, 1);
        loop (i + 1)
    )
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop 0
                                     handle Subscript =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 48 ms/1calls
  [Average] 48.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ、こんなもんですね。&lt;/p&gt;

&lt;p&gt;次にifで分岐するやりかた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val () = let
    val len = 10000000
    val arr = Array.array(len, 0)
    fun
    loop i = if i &amp;lt; len
             then (
                 Array.update(arr, i, 1);
                 loop (i + 1))
             else ()
in
    Benchmark.benchmark &amp;quot;loop&amp;quot; 1 (fn () =&amp;gt; 
                                     loop 0
                                     handle Subscript =&amp;gt; ()
                                 ) 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;loop
 Time:
    [Total] 96 ms/1calls
  [Average] 96.0 ms/call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;倍くらい遅くなってますね。&lt;/p&gt;

&lt;p&gt;ということでみだりに境界チェックするより例外を出させといた方が速いようです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第一級ラベルを持たない言語におけるDirect Threaded VMの実装</title>
      <link>/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou</link>
      <pubDate>Fri, 29 May 2015 20:26:41 +0900</pubDate>
      
      <guid>/blog/2015/05/29/daiikkyuuraberuwomotanaigengoniokerudirect_threaded_vmnojissou</guid>
      <description>

&lt;p&gt;こんにちは。κeenです。このブログでちょくちょく出てくるDirect Threaded VMについて。
SMLのようにgotoがない言語だとDT VMの実装出来ないよなー、と思ってた所、ふとアイディアが浮かんだのでそれについて。&lt;/p&gt;

&lt;h1 id=&#34;序論:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;序論&lt;/h1&gt;

&lt;p&gt;DSL、例えば正規表現などの処理系を実装することを考えてみて下さい。&lt;/p&gt;

&lt;p&gt;言語処理系において最も素朴な実装はインタプリタですが、速度面で不利なので一旦仮想命令にコンパイルして仮想命令実行器(VM)で実行することが一般的です。
コンパイラのように複雑な記号処理をするプログラムはCommon LispやMLのような記号処理に強い高級言語が得意とする分野です。
一方、ランタイムには低レベルなことが出来て処理速度の速いCommon LispやCを使いたくなるでしょう。&lt;/p&gt;

&lt;p&gt;Common Lisp以外の言語ではコンパイラとランタイムを分離するのが妥当な選択肢のようですが、高級言語とcの間のブッジングが必要になり、少なからぬコストを支払う必要があります。
また、ffiを持たない言語ではブリッジ出来ないのでランタイムもその言語で実装する必要があります。つまり、高級言語でVMを実装する必要があるケースが存在します。&lt;/p&gt;

&lt;p&gt;VMの実行を高速化する技術の一つとしてDirect Threadingというものがあります。
命令ディスパッチのループを短絡することで余計なオーバーヘッドが減り、また、命令毎にジャンプ命令を持つことで分岐予測も効きやすくなるのでVMが高速化します。
しかしDTの実装にはgotoのラベルを第一級オブジェクトとして保存する必要があり、gccやclangのように拡張されたcコンパイラなど、限られた言語でしか実現出来ません。まあ、Common Lispなら&lt;code&gt;eval&lt;/code&gt;と&lt;code&gt;compile&lt;/code&gt;を使えばJITが出来るので不要ですが。&lt;/p&gt;

&lt;p&gt;そこで、gotoのない言語でDirect Threadingを実現してみたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;direct-threading:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;Direct Threading&lt;/h1&gt;

&lt;p&gt;Direct Threaded &lt;em&gt;でない&lt;/em&gt; VMは大抵次のような構造をしています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loop {
  op = fetchNextOp
  switch(op) {
    case op1:
     ....
     break
    case op2:
     ....
     break
    ....
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;次の命令を取得する&lt;/li&gt;
&lt;li&gt;命令でディスパッチする&lt;/li&gt;
&lt;li&gt;命令に対応するコードを実行する&lt;/li&gt;
&lt;li&gt;ディスパッチを抜ける&lt;/li&gt;
&lt;li&gt;1.に戻る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という動きをします。自然に思えるかもしれませんが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;命令のディスパッチはlogオーダの時間が掛かる（可能性がある）。&lt;/li&gt;
&lt;li&gt;4. 5. のステップが不要&lt;/li&gt;
&lt;li&gt;2. で毎回違う命令にディスパッチするので分岐予測がほぼ意味を成さない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という無駄があります。それを改良したのがDirect Threaded VMで、オペコードではなくgotoのラベルを使うことで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;label = fetchNextLabel
goto label
label1:
  ...
  label = fetchNextLabel
  goto label
label2:
  ...
  label = fetchNextLabel
  goto label
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;次のラベルを取得する&lt;/li&gt;
&lt;li&gt;ラベルにgotoする&lt;/li&gt;
&lt;li&gt;命令に対応するコードを実行する&lt;/li&gt;
&lt;li&gt;次のラベルを取得する&lt;/li&gt;
&lt;li&gt;ラベルにgotoする(次の処理は3. 相当)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;と、ループ内の2ステップを飛ばした他、ディスパッチもなくなるので高速になります。
また、ラベル毎にgotoがついていて、それぞれのgotoに分岐予測があるので普通のVMに比べて分岐予測がある程度効きます。&lt;/p&gt;

&lt;h1 id=&#34;第一級ラベルを持たない言語におけるdirect-threaded-vm:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;第一級ラベルを持たない言語におけるDirect Threaded VM&lt;/h1&gt;

&lt;p&gt;結論から言うと関数の配列を使います。ラベルの代わりに配列のインデックス、gotoの代わりに配列へのアクセスとcallを使います。
ランダムアクセスでアドレスの取得をするために配列を、任意コードへのジャンプのために関数を使えばエミュレート出来るよねって発想です。&lt;/p&gt;

&lt;h1 id=&#34;実装:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;実装&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/SML-VM&#34;&gt;ソースコード全体&lt;/a&gt;はGithuに上げてます。SML/NJで動きます。SML#向けのインターフェースファイルを書いていますが何故かコンパイルが通りません。&lt;/p&gt;

&lt;p&gt;次のようなASTを実行するインタプリタ、VM、Direct Threaded VMを実装しました。但し、VMとDTVMはクロージャをサポートしていません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype monoop
  = Not

datatype binop
  = Equal
  | GreaterThan
  | Add

datatype t
  = Int of int
  | Bool of bool
  | MonoOp of monoop * t
  | BinOp of binop * t * t
  | Bind of t * t
  | If of t * t * t
  | Var of string
  | Lambda of t list * t
  | Call of t * t list
  | Progn of t list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インタプリタはこのASTを解釈実行、VMはいくつかの中間表現を経てオペコードにコンパイルし、それを実行します。尚、最適化は行いません。&lt;/p&gt;

&lt;p&gt;VMのディスパッチ部分は次のような実装になっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;    fun aux () = (
        case  (Array.sub(ops, !pc)) of
            O.Not =&amp;gt; (case pop vm of
                         V.Bool x =&amp;gt; push vm (V.Bool (not x))
                       | _ =&amp;gt; raise Type)
          | O.Add =&amp;gt; (case (pop vm, pop vm) of
                         (V.Int x, V.Int y) =&amp;gt; push vm (V.Int (x + y))
                       | _ =&amp;gt; raise Type)
          | O.Eq =&amp;gt; (case (pop vm, pop vm) of
                        (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x = y))
                      | (V.Bool x, V.Bool y) =&amp;gt; push vm (V.Bool (x = y))
                      | _ =&amp;gt; raise Type)
          | O.Gt =&amp;gt; (case (pop vm, pop vm) of
                        (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x &amp;lt; y))
                      | _ =&amp;gt; raise Type)
          | O.Jump label =&amp;gt; pc := (label - 1)
          | O.Jtrue label =&amp;gt; (case pop vm of
                                 V.Bool true =&amp;gt; pc := (label - 1)
                               | V.Bool false =&amp;gt; ()
                               | _ =&amp;gt; raise Type)
          | O.Call i =&amp;gt; (case (pop vm) of
                            V.Lambda label =&amp;gt; (
                             pushCi vm;
                             fp := (!fp) - i;
                             pc := (label - 1))
                          | _ =&amp;gt; raise Type)
          | O.Ret =&amp;gt; (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1));
                     popCi vm;
                     pc := (!pc))
          | O.Push v =&amp;gt; push vm v
          | O.Pop =&amp;gt; (pop vm;())
          | O.Lref i =&amp;gt; push vm (Array.sub(stack, (!fp) + i))
          | O.Lset i =&amp;gt;  ((Array.update(stack, (!fp) + i, pop vm));
                         push vm (V.Bool true))
          | O.Gref i =&amp;gt; push vm (Array.sub(pool, i))
          | O.Gset i =&amp;gt;  (Array.update(pool, i, pop vm); push vm (V.Bool true))
          | O.Nop =&amp;gt; ()
          | O.End =&amp;gt; raise Exit
      ;
        pc := (!pc) + 1;
      aux ())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DT VMではこれを次のように書き換えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun next () = let
    val () = pc := (!pc) + 1;
    val (index, arg) = Array.sub(cops, !pc) in
    Array.sub(opArray, index) arg
end

Array.fromList [
            (* Not *)
            fn _ =&amp;gt;
                (case pop vm of
                    V.Bool x =&amp;gt; push vm (V.Bool (not x))
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Add *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Int (x + y))
                  | _ =&amp;gt; raise Type;
                 next ()),
            (* Eq *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x = y))
                  | (V.Bool x, V.Bool y) =&amp;gt; push vm (V.Bool (x = y))
                  | _ =&amp;gt; raise Type;
                  next ()),
            (* Gt *)
            fn _ =&amp;gt;
                (case (pop vm, pop vm) of
                    (V.Int x, V.Int y) =&amp;gt; push vm (V.Bool (x &amp;lt; y))
                  | _ =&amp;gt; raise Type;
                 next ()),
            (* Jump *)
            fn ({int = label, ...}: oparg) =&amp;gt;
               (pc := (label - 1);
               next ()),
            (* Jtrue *)
            fn ({int = label, ...}: oparg) =&amp;gt;
                (case pop vm of
                    V.Bool true =&amp;gt; pc := (label - 1)
                  | V.Bool false =&amp;gt; ()
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Call *)
            fn ({int = i, ...}: oparg) =&amp;gt;
                (case (pop vm) of
                    V.Lambda label =&amp;gt; (
                     pushCi vm;
                     fp := (!fp) - i;
                     pc := (label - 1))
                  | _ =&amp;gt; raise Type;
                next ()),
            (* Ret *)
            fn _ =&amp;gt;
                (Array.update(stack, !fp, Array.sub(stack, (!sp) - 1));
                 popCi vm;
                 pc := (!pc);
                next ()),
            (* Push *)
            fn ({vmvalue = v, ...}: oparg) =&amp;gt;
               (push vm v;
               next ()),
            (* Pop *)
            fn _ =&amp;gt;
               (pop vm;
                next ()),
            (* Lref *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (push vm (Array.sub(stack, (!fp) + i));
               next ()),
            (* Lset *)
            fn ({int = i, ...}: oparg) =&amp;gt;
                ((Array.update(stack, (!fp) + i, pop vm));
                 push vm (V.Bool true);
                next ()),
            (* Gref *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (push vm (Array.sub(pool, i));
               next ()),
            (* Gset *)
            fn ({int = i, ...}: oparg) =&amp;gt;
               (Array.update(pool, i, pop vm);
                push vm (V.Bool true);
               next ()),
            (* Nop *)
            (fn _ =&amp;gt;
                next ()),
            (fn _ =&amp;gt;
                raise Exit)
        ]

fun aux () = let val (index, arg) = Array.sub(cops, !pc) in
                 Array.sub(opArray, index) arg
             end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1引数を受け取ってunitを返す関数の配列としてVMを表しています。
1つ注意点として、前処理としてタグ付き共用体として表されている命令をタグ(配列のインデックス)と共用体に分解するのですが、SMLに共用体はないので構造体で代用しています。 &lt;code&gt;oparg&lt;/code&gt; 型がそれにあたります。&lt;/p&gt;

&lt;p&gt;ディスパッチを関数&lt;code&gt;next&lt;/code&gt;に括り出していて、一見すると分岐予測に関する利点が失われるように思われますが、
&lt;code&gt;next&lt;/code&gt;は小さいのでインライン化されるだろうと踏んでそのままにしています。実際、手動でインライン化しても速度に変化はありませんでした。&lt;/p&gt;

&lt;p&gt;今回のメインの話はVMなのでインタプリタについては省略します。&lt;/p&gt;

&lt;h1 id=&#34;実行速度:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;実行速度&lt;/h1&gt;

&lt;h2 id=&#34;予測:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;予測&lt;/h2&gt;

&lt;p&gt;普通のVMはディスパッチをlogオーダーの時間で行ないますがDT VMは定数オーダーの時間で行ないます。しかし配列の参照と関数呼び出しを挟むので定数倍の部分は大きくなります。
どちらが速いでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;計測:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;計測&lt;/h2&gt;

&lt;p&gt;今回、次のようなフィボナッチ数列を計算するコードの実行速度を計測しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun fib n = (Progn [
                Bind (Var &amp;quot;fib&amp;quot;,
                      Lambda([Var &amp;quot;n&amp;quot;],
                               (If (BinOp(GreaterThan,
                                          (Int 2),
                                          (Var &amp;quot;n&amp;quot;)),
                                    Int(1),
                                    BinOp(Add,
                                          Call(Var &amp;quot;fib&amp;quot;, [BinOp(Add,
                                                                 Var &amp;quot;n&amp;quot;,
                                                                 Int ~1)]),
                                          Call(Var &amp;quot;fib&amp;quot;, [BinOp(Add,
                                                                 Var &amp;quot;n&amp;quot;,
                                                                 Int ~2)])))))),
                Call(Var &amp;quot;fib&amp;quot;, [Int n])])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンパイラは以下のような命令列を吐きます。命令の内部表現が違うだけで命令列自体はVMとDTVMで共通です。
繰り返しますが、最適化はしてないのでL25で次の命令にジャンプしてるだとか目に見えて無駄なコードもあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0	Push Lambda 7
1	Gset 0
2	Pop
3	Push 35
4	Gref 0
5	Call 1
6	End
7	Push 2
8	Lref 0
9	Gt
10	Jtrue 12
11	Jump 14
12	Push 1
13	Jump 26
14	Lref 0
15	Push ~1
16	Add
17	Gref 0
18	Call 1
19	Lref 0
20	Push ~2
21	Add
22	Gref 0
23	Call 1
24	Add
25	Jump 26
26	Ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;計測には次のようなコードを使いました。コンパイラは実行効率を無視して書いたのでベンチマークには含めていません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val target = (AST.fib 35)
val compiled = VM.compile target
val dtcompiled = DTVM.compile target
val vm = VM.new ()
val dtvm = DTVM.new ()

val _ = Benchmark.benchset &amp;quot;fib 35&amp;quot; 1 [
        (&amp;quot;Interpreter&amp;quot;,
         fn () =&amp;gt; (Interp.run target; ())),
        (&amp;quot;Normal VM&amp;quot;,
         fn () =&amp;gt; (VM.run vm compiled; ())),
        (&amp;quot;Direct Threaded VM&amp;quot;,
         fn () =&amp;gt; (DTVM.run dtvm dtcompiled; ()))
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;結果:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;Intel Core i5 M450 2.4GHz 2コア4スレッド、Ubunt 15.04、SML/NJ v110.77で実行しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-------------------+---------------------------------------------------
 Interpreter       |********************************************* 47170ms
 Normal VM         |****************** 19170ms
 Direct Threaded VM|************************************************** 51460ms
-------------------+---------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ダントツで速いのがVMで、インタプリタに比べてかなりの性能向上が見られます。一方DT VMはインタプリタより遅いという結果になりました。&lt;/p&gt;

&lt;h1 id=&#34;考察:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;考察&lt;/h1&gt;

&lt;p&gt;冷静に考えたらインタプリタは毎回関数呼び出して遅いよねってことからループで処理を済ませるのがVMなのにVMで毎回関数を呼び出してたら遅いに決まってるじゃん。
というかこれ、Direct Threaded VMじゃないじゃん。死にたい。&lt;/p&gt;

&lt;h1 id=&#34;余談:96964fcf74a77b030eea88ce12e9c90c&#34;&gt;余談&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ループ内でExceptionをhandleしてる所為だった。ループの外に出したら超速になってインタプリタの方が20倍遅くなった。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/604235677337714689&#34;&gt;2015, 5月 29&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;尚、このつぶやきはfibの引数を小さくして繰り返しを増やした時のものです。多分コンパイルを外に出してるので繰り返しが多いとその分のオーバーヘッドの差が効いてくるのでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val target = (AST.fib 24)
val compiled = VM.compile target
val dtcompiled = DTVM.compile target
val vm = VM.new ()
val dtvm = DTVM.new ()

val _ = Benchmark.benchset &amp;quot;fib 24&amp;quot; 10 [
        (&amp;quot;Interpreter&amp;quot;,
         fn () =&amp;gt; (Interp.run target; ())),
        (&amp;quot;Normal VM&amp;quot;,
         fn () =&amp;gt; (VM.run vm compiled; ())),
        (&amp;quot;Direct Threaded VM&amp;quot;,
         fn () =&amp;gt; (DTVM.run dtvm dtcompiled; ()))
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-------------------+---------------------------------------------------
 Interpreter       |************************************************** 2052ms
 Normal VM         |** 104ms
 Direct Threaded VM|***** 238ms
-------------------+---------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SMLを書くLisperの悩み</title>
      <link>/blog/2015/05/03/smlwokakulispernonayami</link>
      <pubDate>Sun, 03 May 2015 13:23:17 +0900</pubDate>
      
      <guid>/blog/2015/05/03/smlwokakulispernonayami</guid>
      <description>&lt;p&gt;SMLばっかり書いてたら「お前Lisperじゃないだろ」って怒られたとかそういう話ではなく。&lt;/p&gt;

&lt;p&gt;ML系の言語は関数は1つの引数しかとれません。じゃあ複数の値を受け取りたい時はどうするかというと 1. 値を組(タプル)にして受け取る 2. 関数を返す関数((を返す関数)*)にして1つづつ受け取る の2種類の方法があります。
それに纏わる話。&lt;/p&gt;

&lt;p&gt;それぞれの記法を例示すると&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;値を組(タプル)にして受け取る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun add (x, y) = x + y
add (1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは、手続型言語に似せて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;add(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするスタイルもあります&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;関数を返す関数((を返す関数)*)に(カリー化)して1つづつ受け取る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun add x y = x + y
add x y  (*= ((add x) y)  *)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。勿論、2.のように何度も関数を呼び出すよりは1.のように一度で全ての値を渡してしまった方が速い筈です。なのでプリミティブっぽい関数はタプル式にした方が良さそうです。
また、無名関数を定義する時にSMLでは&lt;code&gt;fun&lt;/code&gt;のように自動でカリー化してくれる構文がないので複数の引数を受け付ける関数を引数にとる高階関数を定義するときはタプル式の方が都合が良いでしょう。&lt;/p&gt;

&lt;p&gt;例えば二項演算子はタプル式で定義しなければなりませんし、&lt;code&gt;List.foldl&lt;/code&gt;のシグネチャも&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(&#39;a * &#39;b -&amp;gt; &#39;b) -&amp;gt; &#39;b -&amp;gt; &#39;a list -&amp;gt; &#39;b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;p&gt;勿論、積極的に最適化を行なうコンパイラではuncurry optimizationや、closure eliminationでカリー化によるオーバーヘッドはなくなります。
むしろ、カリー化した方が部分適用が出来るので利便性は上がります。となると後は無名関数の問題ですが、OCamlやHaskellなど無名関数にもカリー化した定義が出来る構文のある言語だとそれも問題なく、タプル式の引数の渡し方はしないようです。&lt;/p&gt;

&lt;p&gt;SMLは流石に&amp;rsquo;Standard&amp;rsquo;なので最適化を仮定したり余計な構文を突っ込んだりはしづらいのでしょう。なのでこの問題はSML特有のようです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ここまで、なぜタイトルがML系言語ではなくSML限定なのかの前置き。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;こういう関数呼び出しがあるとします。&lt;code&gt;sub: string * int -&amp;gt; char&lt;/code&gt;は文字列の0番目の文字を取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;sub(str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに&lt;code&gt;Char.isAlpha : char -&amp;gt; bool&lt;/code&gt;を適用します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Char.isAlpha sub(str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ、コンパイルエラーになります。みなさん何でか分かりますか？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sub(str, 0)&lt;/code&gt;はあくまで&lt;code&gt;sub&lt;/code&gt;に&lt;code&gt;(str, 0)&lt;/code&gt;というタプルを渡している文なのでコンパイラはこう解釈するのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(Char.isAlpha sub) (str, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回このようなエラーを出すのが面倒なので関数の呼び出しには全て手続き型言語のように括弧をつけることを考え始めます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Char.isAlpha(sub(str, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしそうは問屋が卸さないのがカリー化された関数。&lt;code&gt;String.isPrefix: string -&amp;gt; string -&amp;gt; bool&lt;/code&gt;に次のような呼び出しをすると勿論怒られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;String.isPrefix(&amp;quot;/usr/local&amp;quot; path)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必ず&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;String.isPrefix &amp;quot;/usr/local&amp;quot; path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としないといけません。これまた関数呼び出しがネストすると面倒で、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;app (fn s =&amp;gt; print (s ^ &amp;quot;\n&amp;quot;)) (List.filter (String.isPrefix &amp;quot;/usr/local&amp;quot;) paths)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように毎回括弧が付き纏います。ここまでくるとS式みたく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(app (fn s =&amp;gt; print (s ^ &amp;quot;\n&amp;quot;)) (List.filter (String.isPrefix &amp;quot;/usr/local&amp;quot;) paths))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書きたくなってくるのがLisperの心情。これなら慣れないデータコンストラクタや関数呼び出しや中置演算子の優先順位問題も解決!やったね!!と思ったのですがやっぱりタプル式の関数呼出が行く手を阻むのでした。
&lt;code&gt;(sub(str, i))&lt;/code&gt; とか訳分からなすぎる。括弧多すぎる。&lt;/p&gt;

&lt;p&gt;ということでどっちに揃えたら良いのかさえ分かってないのにどっちにも揃えられてないSMLに対して悩みを抱えるLisperの悩みでした。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;は&lt;code&gt;Char.isAlpha()&lt;/code&gt;のような書き方は無駄な括弧がついてると怒ってきます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#をMacでビルドする</title>
      <link>/blog/2015/04/29/smlsharpwomacdebirudosuru</link>
      <pubDate>Wed, 29 Apr 2015 16:09:08 +0900</pubDate>
      
      <guid>/blog/2015/04/29/smlsharpwomacdebirudosuru</guid>
      <description>

&lt;p&gt;κeenです。SML#2.0.0を文鎮と化していたMBAにインストールしたのでメモをば。&lt;/p&gt;

&lt;p&gt;基本は&lt;a href=&#34;http://d.hatena.ne.jp/keita44_f4/20140412/1397279451&#34;&gt;よんたさんの記事&lt;/a&gt;をMacに翻訳した感じです。&lt;/p&gt;

&lt;p&gt;モチベーションは、&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/ja/?Download&#34;&gt;公式の配布物&lt;/a&gt;がMac版だとMacPorts版しかなく、
portsとhomebrewの混在は避けた方が良いと聞いたのでどうにかして自前ビルドしようとしたことです。&lt;/p&gt;

&lt;h1 id=&#34;注意書き:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;注意書き&lt;/h1&gt;

&lt;p&gt;冒頭にも書いてあるようにMBAは普段使ってなくて、このエントリーもMBAじゃないマシンから書いているのでコマンド類はコピペでなく写経してます。
typoがあるかもしれないのでコピペして動かなかったら一応この記事のtypoを疑って下さい。&lt;/p&gt;

&lt;h1 id=&#34;gmp32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;GMP32bitの準備&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ brew install gmp --32-bit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で終わり。バージョン6.0.0aが入りました。
既にインストールされていたら多分64bit版が入っているので一旦 &lt;code&gt;brew remove gmp&lt;/code&gt; してから再度インストールすると良いです。尚、バイナリ版はないようで、ビルドが始まります。checkに時間が掛かる。&lt;/p&gt;

&lt;h1 id=&#34;llvm34-32bitの準備:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;LLVM34 32bitの準備&lt;/h1&gt;

&lt;p&gt;骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://llvm.org/releases/3.4.2/llvm-3.4.2.src.tar.gz
$ gzcat llvm-3.4.2.src.tar.gz | tar xf -
$ cd llvm-3.4.2.src
$ ./configure --build=i686-mac-darwin CC=&#39;gcc -m32&#39; CXX=&#39;g++ -m32&#39; --prefix=/usr/local/Cellar/llvm34/3.4.2a
$ make -j4
$ make -j4 install
$ cd ../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら上手くいきました。何故上手くいったんでしょうねー。あとprefixは割と気持悪いのでみなさん適切な場所にインストールしましょうね。&lt;/p&gt;

&lt;h1 id=&#34;sml-のビルド:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;SML# のビルド&lt;/h1&gt;

&lt;p&gt;これが一番骨が折れるところですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.pllab.riec.tohoku.ac.jp/smlsharp/download/smlsharp-2.0.0.tar.gz
$ gzcat smlsharp-2.0.0.tar.gz | tar xf -
$ cd smlsharp-2.0.0
$ ./configure --with-llvm=/usr/local/Cellar/llvm34/3.4.2a/      \
               LDFLAGS=&#39;-L/usr/local/Cellar/gmp/6.0.0a/lib&#39;     \
              CPPFLAGS=&#39;-I/usr/local/Cellar/gmp/6.0.0a/include&#39; \
                    CC=&#39;gcc -m32&#39;                               \
                   CXX=&#39;g++ -m32&#39;
$ make -j4
$ make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としたら出来ました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:d4eee8946023292eeefbfeb9ba252a7c&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;誰かhomebrewにして。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpを使ってSMLのon-the-flyエラーチェック</title>
      <link>/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</link>
      <pubDate>Thu, 23 Apr 2015 23:01:17 +0900</pubDate>
      
      <guid>/blog/2015/04/23/smlsharpwotsukattesmlnoon-the-flyerrorchekkingu</guid>
      <description>

&lt;p&gt;κeenです。最近SMLを結構書いてるのですが中置演算子が乱立する言語はLisperにはつらくて、しょっちゅうコンパイルエラーを出します。
そこでSML#をflymakeで動かしてOn The Flyにエラーチェックをします。&lt;/p&gt;

&lt;p&gt;なぜSML#かというと &lt;code&gt;-ftypecheck-only&lt;/code&gt; オプションがあって、シンタックスと型エラーのチェックだけを行なえるからです。&lt;/p&gt;

&lt;p&gt;色々試したのですが設定はこれだけで済みました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(eval-after-load &#39;flymake
  &#39;(progn 
    (add-to-list &#39;flymake-allowed-file-name-masks &#39;(&amp;quot;.+\\.sml$&amp;quot;
                                                    (lambda ()
                                                      (list &amp;quot;/usr/local/bin/smlsharp&amp;quot; (list &amp;quot;-ftypecheck-only&amp;quot; (buffer-file-name))))
                                                    (lambda () nil)))
    (add-to-list &#39;flymake-err-line-patterns &#39;(&amp;quot;^\\([^: ]*\\):\\([0-9]+\\)\\.\\([0-9]+\\)-[0-9]+\\.[0-9]+ \\(Error\\|Warning\\):&amp;quot;
                                              1 2 3 4))))
(add-hook &#39;sml-mode-hook #&#39;flymake-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;/usr/local/bin/smlsharp&amp;quot;&lt;/code&gt; のところは各自書き換えて下さい。尚、SML#はエラーメッセージを複数行に跨って出すのですがそれがflymakeと相性が悪いのでエラーメッセージの取得は諦めました。&lt;/p&gt;

&lt;p&gt;多くの場合、 &lt;code&gt;flymake-simple&lt;/code&gt; という枠組みの中で設定を書くのですがテンポラリファイルを作る構造がどうしてもインターフェースファイルと相性が悪かったので生のflymakeを使ってます。
というかflymakeは元々 &lt;code&gt;-ftypecheck-only&lt;/code&gt; みたいなのを前提に作られてたのに実際にコンパイル走らせないとエラーメッセージ取得出来ない言語が多過ぎてフレームワークが出来たのでこれが本来の使い方です。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:311ce9d5e51e732b1928a84bcceb27a3&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nrnrnr/SML-Lint&#34;&gt;SML-Lint&lt;/a&gt;というものがあって、スタイルワーニングを出してくれます。ただ、これはパッチを当てないと使えなかったりスタイルワーニングのみしか出さなかったりするので気が向いた時に紹介します&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SMLSharpでFFIバインディングを書く時の知見</title>
      <link>/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</link>
      <pubDate>Sun, 19 Apr 2015 13:51:33 +0900</pubDate>
      
      <guid>/blog/2015/04/19/smlsharpdeffibaindinguwokakutokinochiken</guid>
      <description>

&lt;p&gt;κeenです。最近頻繁にSML#を使ってます。SML#のメイン機能の1つであるC連携ですが、ちょっと複雑なことをやろうとするとテクニックが必要になるので共有します。&lt;/p&gt;

&lt;p&gt;Twitterとかにコメントや突っ込みお願いします。&lt;/p&gt;

&lt;h1 id=&#34;簡単な型:017736760057fcde64c6904c3e916b13&#34;&gt;簡単な型&lt;/h1&gt;

&lt;p&gt;型が簡単な関数なら普通に&lt;code&gt;_import&lt;/code&gt;で済みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;val puts = _import &amp;quot;puts&amp;quot;: string -&amp;gt; ()
val () = puts &amp;quot;Hello, C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尚、簡単な型とは&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch9.S2.xhtml&#34;&gt;公式ドキュメント&lt;/a&gt;にある通り、いわゆる即値、即値の組（タプル）、即値の配列、即値の参照、それらを引数、返り値に持つ関数などです。&lt;/p&gt;

&lt;p&gt;又、以下のような制約もあります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C関数全体の型は，引数リストを組型とするMLの関数型に対応付けられます． ただし，C関数の引数や返り値に書ける相互運用型には，以下の制約があり ます．
   配列型や組型など，Cのポインタ型に対応する相互運用型を，C関数の返り値の 型として指定することはできません．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恐らくGCとの兼ね合いでしょうがつらいですね。stringすら返り値で受け取れません。&lt;/p&gt;

&lt;p&gt;それにこの制約がどこまで効いてるのかが不明で、同じ型でも型付けに成功したり失敗したりすることがあります。例えば上の例でstring型を引数にとる関数をインポートしましたが関数に依ってはstringが相互運用型でないとか怒られることがあります。タプルの配列やタプルの参照などは確実にダメみたいです。&lt;/p&gt;

&lt;p&gt;尚、string型はCでいう &lt;code&gt;const char *&lt;/code&gt; 、タプルは変更不能な構造体へのポインタになるそうです。構造体の即値は扱えないんですね…。また、参照とは別に &lt;code&gt;ptr&lt;/code&gt; 型も存在します。SML#側からは作れず、Cとの相互運用のためだけに存在するようです。&lt;/p&gt;

&lt;h1 id=&#34;魔法の-unit-ptr:017736760057fcde64c6904c3e916b13&#34;&gt;魔法の &lt;code&gt;unit ptr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;じゃあ複雑な型はインポート出来ないのかというとそうでもなく、 &lt;code&gt;unit ptr&lt;/code&gt; 型にしておけばとりあえずインポート出来ます。Cで言うところの &lt;code&gt;void *&lt;/code&gt; です。
邪悪な雰囲気を感じますね。しかしそこは型安全言語、ちゃんと型安全に &lt;code&gt;unit ptr&lt;/code&gt; を扱えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;type file = unit ptr
val fopen = _import &amp;quot;fopen&amp;quot;: (string, string) -&amp;gt; file
val fgetc = _import &amp;quot;fgetc&amp;quot;: (file) -&amp;gt; int
val fclose = _import &amp;quot;fclose&amp;quot;: (file) -&amp;gt; int
val () = let
      val f = fopen(&amp;quot;test&amp;quot;, &amp;quot;r&amp;quot;)
      val c = fgetc(f)
    in
      print(str(chr c));
      fclose(f)
    end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。単に &lt;code&gt;type&lt;/code&gt; で名前をつけてあげれば大丈夫です。SML#側ではポイント先が何であるかには関知せず、インポートしたC関数の間で完結してれば問題ありません。多くのライブラリはそのようなAPIになっているのではないでしょうか。&lt;/p&gt;

&lt;h1 id=&#34;ポインタを扱う:017736760057fcde64c6904c3e916b13&#34;&gt;ポインタを扱う&lt;/h1&gt;

&lt;p&gt;とはいえ時にポインタを扱う必要もあります。構造体の配列を扱えないのでその辺で。&lt;/p&gt;

&lt;p&gt;そういった時に便利なのが &lt;code&gt;SMLSharp_Builtin.Pointer&lt;/code&gt; と &lt;code&gt;Pointer&lt;/code&gt; です。 &lt;code&gt;Pointer&lt;/code&gt; の方は .smi ファイルの中で &lt;code&gt;_require &amp;quot;ffi.smi&amp;quot;&lt;/code&gt; してから使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure SMLSharp_Builtin
  structure Pointer =
  struct
    val identityEqual = _builtin val IdentityEqual : boxed * boxed -&amp;gt; bool
    val advance = _builtin val Ptr_advance : &#39;a ptr * int -&amp;gt; &#39;a ptr
    val deref = _builtin val Ptr_deref : &#39;a ptr -&amp;gt; &#39;a
    val store = _builtin val Ptr_store : &#39;a ptr * &#39;a -&amp;gt; unit

    val toUnitPtr = _builtin val Cast : &#39;a ptr -&amp;gt; unit ptr
    val fromUnitPtr = _builtin val Cast : unit ptr -&amp;gt; &#39;a ptr
    val toCodeptr = _builtin val BitCast : unit ptr -&amp;gt; codeptr
  end
  end

structure Pointer =
struct
  val advance = SMLSharp_Builtin.Pointer.advance

  val load =
      case &#39;a in &#39;a ptr -&amp;gt; &#39;a of
        int =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | char =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.deref
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.deref

  val store =
      case &#39;a in &#39;a ptr * &#39;a -&amp;gt; unit of
        int =&amp;gt; SMLSharp_Builtin.Pointer.store
      | word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Word8.word =&amp;gt; SMLSharp_Builtin.Pointer.store
      | char =&amp;gt; SMLSharp_Builtin.Pointer.store
      | real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | SMLSharp_Builtin.Real32.real =&amp;gt; SMLSharp_Builtin.Pointer.store
      | &#39;b ptr =&amp;gt; SMLSharp_Builtin.Pointer.store

  val isNull : &#39;a ptr -&amp;gt; bool
  val NULL : unit -&amp;gt; &#39;a ptr

  val importBytes : SMLSharp_Builtin.Word8.word ptr * int
                    -&amp;gt; SMLSharp_Builtin.Word8.word vector
  val importString : char ptr -&amp;gt; string
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 、 &lt;code&gt;store&lt;/code&gt; 、 &lt;code&gt;deref&lt;/code&gt; 、 &lt;code&gt;advance&lt;/code&gt; あたりを良く使いそうですね。&lt;/p&gt;

&lt;p&gt;実際にあった話。 &lt;code&gt;struct header { const char *name; int name_len; const char *value; int value_len}&lt;/code&gt; の配列(&lt;code&gt;struct header *&lt;/code&gt;)を扱う必要がありました。
その配列をCの関数に渡して書き換えてもらって、後で値を取り出したいという状況がです。その時値を取り出すコードがこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;fun getHeader headers i =
      let
          val header_ptr : char ptr ptr = fromUnitPtr(headers)
          val header_ptr = advance(header_ptr, i * 2)
          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val header_ptr = advance(header_ptr , i * 2)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val name = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val nameLen = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : char ptr ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val value = deref(header_ptr)
          val header_ptr = advance(header_ptr, 1)

          val header_ptr : int ptr =
              fromUnitPtr(toUnitPtr(header_ptr))
          val valueLen = deref(header_ptr)
      in
          if isNull name
          then (NONE, String.substring(importString(value), 0, valueLen))
          else (SOME(String.substring(importString(name), 0, nameLen)),
                String.substring(importString(value), 0, valueLen))
      end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、タプルは構造体へのポインタなので今回の &lt;code&gt;struct header *&lt;/code&gt; は &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではありません。それは &lt;code&gt;struct header **&lt;/code&gt; になってしまいます。
また、ポインタを扱う関数が &lt;code&gt;ptr&lt;/code&gt; 型しか受け付けないので &lt;code&gt;string&lt;/code&gt; ではなく &lt;code&gt;char ptr&lt;/code&gt; にしておいて後から &lt;code&gt;importString&lt;/code&gt; で文字列にする戦略をとります。&lt;/p&gt;

&lt;p&gt;そして配列のi番目にアクセスしたかったら先述の通り &lt;code&gt;(string * int * string * int) ptr&lt;/code&gt; ではないので地道に &lt;code&gt;char ptr ptr&lt;/code&gt; 2*i個分、 &lt;code&gt;int ptr&lt;/code&gt; 2*i個分ポインタを進めます。
ポインタの型を変える時はダイレクトには変換出来ないようなので一旦 &lt;code&gt;unit ptr&lt;/code&gt; を経由してから変換。そして次のメンバにアクセスするために &lt;code&gt;advance&lt;/code&gt; という形をとります。&lt;/p&gt;

&lt;p&gt;そこまでしたら後は &lt;code&gt;deref&lt;/code&gt; してあげれば欲しい値がとれます。&lt;/p&gt;

&lt;h1 id=&#34;replからのimportと-dynamiclink:017736760057fcde64c6904c3e916b13&#34;&gt;REPLからのimportと &lt;code&gt;DynamicLink&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;SML#のREPLからも勿論インポート出来ますが、SML#のランタイムにリンクされてないライブラリのものはインポート出来ないのでダイナミックリンクを使います。 &lt;code&gt;DynamicLink&lt;/code&gt; にCの &lt;code&gt;dl*&lt;/code&gt; と同じ関数群が用意されているのでそれらを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure DynamicLink =
struct
  type lib (= ptr)
  datatype scope = LOCAL | GLOBAL
  datatype mode = LAZY | NOW
  val dlopen : string -&amp;gt; lib
  val dlopen&#39; : string * scope * mode -&amp;gt; lib
  val dlsym : lib * string -&amp;gt; codeptr
  val dlsym&#39; : lib * string -&amp;gt; unit ptr
  val dlclose : lib -&amp;gt; unit
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;val lib = dlopen(&amp;quot;libawsome.so&amp;quot;)&lt;/code&gt; でライブラリのオープン、 &lt;code&gt;dlsym(lib, &amp;quot;awm_function&amp;quot;): _import () -&amp;gt;unit&lt;/code&gt; で読み込みです。&lt;/p&gt;

&lt;p&gt;これでインポートする関数は必要になった時に読み込んで欲しいのですがトップレベルで &lt;code&gt;val&lt;/code&gt; でバインドすると即読み込まれてしまいます。その辺を上手くやるテクニックがSML#のソースにありました。MySQLのバインディングの部分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;  fun lazy f =
      let
        val r = ref NONE
      in
        fn () =&amp;gt;
           case !r of
             SOME x =&amp;gt; x
           | NONE =&amp;gt;
             let val x = f ()
             in r := SOME x; x
             end
      end

  val lib =
      lazy (fn _ =&amp;gt;
               DynamicLink.dlopen
                 (case OS.Process.getEnv &amp;quot;SMLSHARP_LIBMYSQLCLIENT&amp;quot; of
                    NONE =&amp;gt; &amp;quot;libmysqlclient.16.&amp;quot; ^ SMLSharp_Config.DLLEXT ()
                  | SOME x =&amp;gt; x))

  fun find s = DynamicLink.dlsym(lib (), s)
  val mysql_init =
      lazy (fn _ =&amp;gt; find &amp;quot;mysql_init&amp;quot;
                    : _import (MYSQL) -&amp;gt; MYSQL)


...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遅延評価してますね。これ。呼び出す時は &lt;code&gt;mysql_init () (mysql)&lt;/code&gt; みたいに一旦lazyを剥がさないといけないので注意です。&lt;/p&gt;

&lt;h1 id=&#34;問題とか:017736760057fcde64c6904c3e916b13&#34;&gt;問題とか&lt;/h1&gt;

&lt;h2 id=&#34;cの仕様:017736760057fcde64c6904c3e916b13&#34;&gt;Cの仕様&lt;/h2&gt;

&lt;p&gt;確かCの仕様上構造体のメモリ上の表現にはメンバ以外のものも置いていいことになっていた筈です。
上の方法では変なコンパイラでコンパイルしたコードだと動きそうにないですね。GCCやClangは大丈夫な筈。&lt;/p&gt;

&lt;p&gt;そもそもSML#自体GCCとABI互換なコンパイラでコンパイルしたものじゃないとリンク出来なそうな気がするので杞憂ですかね。&lt;/p&gt;

&lt;h2 id=&#34;メモリ確保:017736760057fcde64c6904c3e916b13&#34;&gt;メモリ確保&lt;/h2&gt;

&lt;p&gt;Cの関数から構造体のポインタが返ってくるケースだと良いんですが自分で構造体を用意してCの関数に渡すケースだとメモリの確保が問題になります。現状、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct header
*prepare_headers(int n)
{
  return malloc(n * sizeof(struct header));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなヘルパ関数を用意して凌いでますが欲しい構造体毎に書かないといけないのであまり嬉しくないです。 &lt;code&gt;sizeof&lt;/code&gt; をSML#側でとれれば単に &lt;code&gt;malloc&lt;/code&gt; をバインドするだけで済むのに。
もう少し欲を言うと &lt;code&gt;malloc&lt;/code&gt; したらGCから外れそうな気がするので明示的に &lt;code&gt;free&lt;/code&gt; する必要がありそうです。GCに載るメモリ確保関数も欲しいですね。
さらに欲を言うとスタックアロケートする版のメモリ確保関数も欲しい。もしかしたら &lt;code&gt;alloca&lt;/code&gt; で大丈夫なんでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;define:017736760057fcde64c6904c3e916b13&#34;&gt;&lt;code&gt;#define&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ヘッダファイル内で定数を &lt;code&gt;#define&lt;/code&gt; してあることが多々あります。それらは地道に手書きでSML#側に持ってくることになりますが気になるのが互換性の問題。
特にOSのヘッダファイルには名前は同じだけどOS毎に値が異なるものが存在します。シグナルとか。OSで条件分岐するか理想的にはプリプロセッサのサポートがあればどうにかなりそうなんですけどねぇ。
現状だとCで定数を返すgetter関数を書いてSML#側でインポートして…ってやればどうにか出来そうですけどやりたくないですね。&lt;/p&gt;

&lt;h2 id=&#34;変数:017736760057fcde64c6904c3e916b13&#34;&gt;変数&lt;/h2&gt;

&lt;p&gt;私はまだ遭遇してないのですがライブラリによってはグローバル変数にアクセスしないといけないものが存在します。これもgetterとsetterを書いて…ってやるとどうにか出来そうですがどうせなら変数のインポートも出来ると良いですよね。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:017736760057fcde64c6904c3e916b13&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SML#でCのバインドを書く時は少しテクニックが必要&lt;/li&gt;
&lt;li&gt;SML#にはポインタを直接扱える関数もある&lt;/li&gt;
&lt;li&gt;それでも機能が足りない時はCでヘルパ関数を書こう。&lt;/li&gt;
&lt;li&gt;ダイナミックリンクライブラリも扱えるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SMLのファンクタに少し踏み込んだ</title>
      <link>/blog/2015/04/12/smlnofankutanisukoshifumikonda</link>
      <pubDate>Sun, 12 Apr 2015 19:49:41 +0900</pubDate>
      
      <guid>/blog/2015/04/12/smlnofankutanisukoshifumikonda</guid>
      <description>

&lt;p&gt;κeenです。&lt;a href=&#34;https://github.com/bleis-tift/SmlSharpContrib&#34;&gt;SmlSharpContrib&lt;/a&gt;にコントリビュートしてます。そこでファンクタを使う用事があったのですが少し踏み込んだ使い方をしようとしたらハマったのでメモ。&lt;/p&gt;

&lt;h1 id=&#34;ファンクタおさらい:921b7b3c7820999b28763bd2de5241d3&#34;&gt;ファンクタおさらい&lt;/h1&gt;

&lt;p&gt;SMLの&lt;code&gt;functor&lt;/code&gt;は&lt;code&gt;structure&lt;/code&gt;に引数がついたもので、モジュールを引数にとり、モジュールを返します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (Args : sig type elem end) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(struct type elem = int end)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;複雑なファンクタ:921b7b3c7820999b28763bd2de5241d3&#34;&gt;複雑なファンクタ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;blog/2015/01/31/mlyaccwotsukattemitehamattatokoro/&#34;&gt;以前mlyaccを使った時&lt;/a&gt;に&lt;code&gt;Join&lt;/code&gt;なる3つのモジュールを引数にとるファンクタが登場したのでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの定義を覗いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数のモジュールの他に&lt;code&gt;sharing&lt;/code&gt;なるキーワードも出てきています。それに&lt;code&gt;structure&lt;/code&gt;キーワードもプリフィクスされています。&lt;/p&gt;

&lt;p&gt;先程の例とは大分離れてますね。何があったのでしょう。&lt;code&gt;structure&lt;/code&gt;を付けとけば複数書ける…？&lt;/p&gt;

&lt;h1 id=&#34;省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;省略記法&lt;/h1&gt;

&lt;p&gt;実はファンクタの引数の中では省略記法が使えます。引数のモジュール名と&lt;code&gt;sig ... end&lt;/code&gt;が省略可能なのです。さらに適用の時も&lt;code&gt;struct ... end&lt;/code&gt;も省略可能なのです。&lt;/p&gt;

&lt;p&gt;つまり、最初の例はこうも書けるのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor List (type elem) =
struct
  type elem = Args.elem
  datatype list = Nil | Cons of elem * list
  fun length Nil = 0
    | length (Cons (x, xs)) = 1 + length xs
end

structure IntList = List(type elem = int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;モジュール内モジュールと省略記法:921b7b3c7820999b28763bd2de5241d3&#34;&gt;モジュール内モジュールと省略記法&lt;/h1&gt;

&lt;p&gt;そうです。複雑怪奇な&lt;code&gt;Join&lt;/code&gt;ファンクタは省略記法で書かれていたのでした。省略せずに書くと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;structure PrologParser =
Join(struct
     structure LrParser = LrParser
     structure ParserData = PrologParserLrVals.ParserData
     structure Lex = PrologLex
     end)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;functor Join(X: sig
             structure Lex : LEXER
             structure ParserData: PARSER_DATA
             structure LrParser : LR_PARSER
             sharing ParserData.LrTable = LrParser.LrTable
             sharing ParserData.Token = LrParser.Token
             sharing type Lex.UserDeclarations.svalue = ParserData.svalue
             sharing type Lex.UserDeclarations.pos = ParserData.pos
             sharing type Lex.UserDeclarations.token = ParserData.Token.token
             end)
                 : PARSER =
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。形式的には引数のモジュールは1つでありながら事実上複数のモジュールを渡していたのです。&lt;code&gt;structure&lt;/code&gt;が付いていたのはモジュール内モジュールだったから、&lt;code&gt;sharing&lt;/code&gt;はモジュール内モジュールに対する制約宣言です。&lt;/p&gt;

&lt;p&gt;なぜこれでハマったかというとSML#のインターフェースファイルでは省略記法が使えなかったからです。地雷の数だけ強くなれるよ♪&lt;/p&gt;

&lt;h1 id=&#34;参考:921b7b3c7820999b28763bd2de5241d3&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://walk.wgag.net/sml/module.html&#34;&gt;モジュール - ウォークスルー Standard ML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/Ch11.S6.xhtml&#34;&gt;ファンクタのサポート in Ch.11. SML#分割コンパイルシステム in プログラミング言語SML#解説&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>