<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>言語処理系 on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/%E8%A8%80%E8%AA%9E%E5%87%A6%E7%90%86%E7%B3%BB/</link>
    <description>Recent content in 言語処理系 on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 17 May 2015 01:33:39 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/%E8%A8%80%E8%AA%9E%E5%87%A6%E7%90%86%E7%B3%BB/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>実装から理解するクロージャ</title>
      <link>http://keens.github.io/slide/jissoukararikaisurukuro_ja/</link>
      <pubDate>Sun, 17 May 2015 01:33:39 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/jissoukararikaisurukuro_ja/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 実装から理解するクロージャ
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# クロージャとは？
-----------------

* 日本語にすると（関数）閉包
* 関数が外側のローカル変数を補足する
* 補足されたローカル変数は無限の生存期間を持つ
  + ローカル変数は本来スコープを抜けると生存期間が終わる
  + 言い換えるとグローバル変数みたいになる
  + でもあくまでスコープはローカル

# コード例
---------

```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p = genpower(2);
```

# コード例
----------

```js
p()  // =&gt; 2
p()  // =&gt; 4
p()  // =&gt; 8
x * 2 // x is not defined
```


# コード例
----------

* `p`が`n`と`x`を補足しているので関数を抜けた後も`x`と`n`は使える。
  + 関数の仮引数もローカル変数。
* でもローカル変数なので外からは見えない。



```
+-----------------------+
| function genpower(n){ |
|   var x = 1;          |
| ...   ^               |
| }     |               |
+-----------------------+
        |
 +------+
 |
+-------------+
||function(){ |
|+-- x *= n;  |
|   return x; |
| };          |
+-------------+
```



# コード例2
----------

```js
function incdec(){
    var x = 0;
    return [function(){ return ++x;},
            function(){ return --x;}];
}
var fs = incdec();
var inc = fs[0];
var dec = fs[1];
```

# コード例2
----------

```js
inc() // =&gt; 1
inc() // =&gt; 2
dec() // =&gt; 1
inc() // =&gt; 2
```

# コード例2
----------

* 同じタイミングで作られたクロージャ群は捕捉変数を共有する



```
+--------------------+
| function incdec(){ |
|   var x = 0;       |
|   ... ^            |
| }     |            |
+--------------------+
        +--------------+----+
                       |    |
+----------------------|---+|
| function(){ return ++x;} ||
+--------------------------+|
                       +----+
+----------------------|---+
| function(){ return --x;} |
+--------------------------+
```

# コード例3
----------

```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p1 = genpower(2);
var p2 = genpower(2);
```

# コード例3
----------

```js
p1()  // =&gt; 2
p1()  // =&gt; 4
p2()  // =&gt; 2
p2()  // =&gt; 4
```

# コード例3
----------

* 逆に、同じ関数から生まれても違うタイミングなら共有しない。



```
+-----------------------+ +-----------------------+
| function genpower(n){ | | function genpower(n){ |
|   var x = 1;          | |   var x = 1;          |
| ...   ^               | | ...   ^               |
| }     |               | | }     |               |
+-----------------------+ +-----------------------+
        |                         |
 +------+                  +------+
 |                         |
+-------------+           +-------------+
||function(){ |           ||function(){ |
|+-- x *= n;  |           |+-- x *= n;  |
|   return x; |           |   return x; |
| };          |           | };          |
+-------------+           +-------------+

```

# 実装方法
----------

* ここでは複数ある実装方法のうちの1つを紹介する。
* 言語はVM型のインタプリタ（大抵のインタプリタの実装に同じ）を仮定する


# 用語整理
----------
* `outer`から見たら`x`は捕捉(Captured)変数
  + `inner`から捕捉されてるから
* `inner`から見たら`x`は自由(Free)変数
  + `inner`からしたら`x`は知らない子だから

```js
function outer(x) {
    function inner(y){
        return x * y;
    }
}
```


# 実装概要
----------

* **クロージャとは捕捉変数の集まり**
  + つまり、捕捉した側ではなくされた側が作る
  + 捕捉した側は作られたものを参照するだけ

# 変数の話
---------

* グローバル変数はヒープ領域に置かれる
  + グローバル DB（大抵巨大なハッシュテーブル）に登録される
* ローカル変数はコールスタックに置かれる
  + 配列が作られ、インデックスでアクセスされる感じ。
  + ローカル変数の数は関数定義時に決定するので配列で管理出来る
  + 関数の実引数も同じように置かれる

# 捕捉変数の話
-------------

* 捕捉変数はヒープ領域に置かれる
  + 簡単には小さなハッシュテーブルに登録される
    - つまり、グローバル変数と同じ
    - 捕捉変数も関数定義時に決定するので配列でも管理出来る
  + ハッシュテーブル/配列はクロージャ毎に作られる

※ [本気出した実装](http://practical-scheme.net/docs/stack-j.html)だとコールスタックでどうにかすることもある


```js
var g = 1;
function sample(a) {
    var l = 2;
    var c = 3;
    return function(){ return c;};
}
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;



```
| ....          |
|---------------|
| args[0] = _   | a
|---------------| 
| locals[0] = 1 | var l
|---------------|--コールスタック↑--
| ....          |
| ....          |
|---------------|--ヒープ領域↓--
| caps[c] = 3   | var c = 3
|---------------|
| global[g] = 1 | var g = 1
| global[_] = _ |
| ....          |
| ....          |

```


```js
function incdec(){
    var x = 0;
    return [function(){ return ++x;},
            function(){ return --x;}];
}
var fs = incdec();
var inc = fs[0];
var dec = fs[1];
```


```
| ....          |
|---------------|--ヒープ領域↓--
| caps[x] = 0 &lt;-++------------------------+
|---------------|| +----------------------|---+
| global[_] = _ || | function(){ return ++x;} |
| ....          || +--------------------------+
| ....          |+------------------------+
| ....          |  +----------------------|---+
| ....          |  | function(){ return --x;} |
| ....          |  +--------------------------+
| ....          |
| ....          |
| ....          |

```


```js
function genpower(n){
    var x = 1;
    return function(){
        x *= n;
        return x;
    };
}
var p1 = genpower(2);
var p2 = genpower(2);
```

AA略

```
| ....          |
|---------------|--ヒープ領域↓--
| caps[x] = 0 &lt;-+-|p1|
|---------------|
| caps[x] = 0 &lt;-+-|p2|
|---------------|
| global[_] = _ |
| ....          |
| ....          |

```


# 捕捉変数の実装
-----------------

* クロージャ毎にcapturedが作られる
* capturedとlocalはソース上の見た目は似ているが実装は大きく異なる
  + 多分この所為で分かりづらい
* グローバルアクセス出来ないだけでグローバル変数に似ている

# まとまってないけどまとめ
-------------------------

* クロージャについて説明した
* クロージャの正体は捕捉変数の集まり
* 捕捉変数はヒープ領域に置かれるローカルスコープな変数

※あくまで実装の1例です

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>誰がUTF-32が使われてないなんて言ったんだ</title>
      <link>http://keens.github.io/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</link>
      <pubDate>Tue, 31 Mar 2015 19:41:05 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/03/31/daregautf-32gatsukawaretenainanteitsuttanda</guid>
      <description>

&lt;p&gt;最近ではUTF-8でソースコードを書いてUTF-8で出入力をする。それ以外のエンコーディングは使われていない。…だと？誰がそんなこと言ったんだ&lt;/p&gt;

&lt;h1 id=&#34;asciiと古いunicodeと新しいunicode:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;ASCIIと古いUnicodeと新しいUnicode&lt;/h1&gt;

&lt;p&gt;少し長くなるが文字コードの話から始まる。ASCIIはお馴染み最低7bitあればASCIIの定義する文字集合を表せる。&lt;/p&gt;

&lt;p&gt;古いUnicodeは16bitで全ての文字を表わすことを目標に作られた。&lt;/p&gt;

&lt;p&gt;新しいUnicodeは文字(主に漢字)が多過ぎて16bitでは表せなかったので21bitに拡張された。&lt;/p&gt;

&lt;h1 id=&#34;文字コードとエンコーディング:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;文字コードとエンコーディング&lt;/h1&gt;

&lt;p&gt;文字コードをどういう形式で表すかがエンコーディングだ。文字コードが7bit、16bit、21bitだからといってそのままのサイズで表わす訳ではない。ASCIIは普通8bitの型で表わすし21bitの型を用意するよりは32bitの型に格納した方が扱い易そうだ。あるいは8bit型の配列に16bitや21bitを収めるとプログラムコードの変更が少なそうだ。&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8とUTF-16とUTF-32&lt;/h1&gt;

&lt;p&gt;さて、ここまで来ればお分かりだろう。UTF-8はASCIIとの互換性を保つ8bitベースのエンコーディング、UTF-16は古いUnicodeの時に作られて新しいUnicodeにも対応した16bitベースのエンコーディング、UTF-32は新しいUnicodeのために作られた32bitベースのエンコーディングだ。
ここで注意して欲しいのはUTF-8とUTF-16は8bitや16bitの単位を複数使うことで新しいUnicodeの範囲も扱える点、逆に言えば1単位が1文字に対応しない点だ。日本語を含んだ文字列に対して&lt;code&gt;length&lt;/code&gt;を使うと正しい結果が帰って来ないなどの経験は誰しもあるだろう&lt;/p&gt;

&lt;h1 id=&#34;utf-8とutf-16とutf-32それぞれの特徴:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8とUTF-16とUTF-32それぞれの特徴&lt;/h1&gt;

&lt;h2 id=&#34;utf-8:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-8&lt;/h2&gt;

&lt;p&gt;8bit(オクテット)の配列に文字列を収めることになる。16bitや21bitの範囲の文字を表す時は8bitに対してASCIIは7bitしか使わないのでその1bitを使って次に続くことを表わす。最大4オクテットまで使うことがある。 UTF-8の特徴はなんと言ってもASCIIとの互換性があること。UTF-8でASCIIの範囲のみの文字をエンコードするとASCIIと同一になるし、ASCIIでエンコードされたものはUTF-8で読んでも同じ内容になる。なのでどんなエンコードか分からないものはとりあえずUTF-8で読んでおくと間違いが少ない。よって冒頭で書いたように出入力、保存ファイル、GUIに表示する文字列などに使われる。&lt;/p&gt;

&lt;p&gt;UTF-8にも欠点はあり、ASCII外の文字を大量に扱うと空間効率が悪い。さらに先頭から順番に辿らないとどのオクテットが何文字目かも分からないので(配列長が既知であっても)文字列へのlengthやランダムアクセスなどの多くの操作がO(n)になってしまう点だ。文字の置換に至ってはin placeでは出来ないことすらある。&lt;/p&gt;

&lt;h2 id=&#34;utf-16:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-16&lt;/h2&gt;

&lt;p&gt;16bitの配列に文字列を収める。21bitまで扱うために特定の範囲の値が来たら次の16bitも読んで2つ併わせて1つの文字とみなす。このペアをサロゲートペアという。C言語には&lt;code&gt;wchar&lt;/code&gt;なるマルチバイト文字用の型があるが、仕様では最低で16bitという要求になっているのでwcharを使う時はUTF-16でエンコードする（と思う）。UTF-16もUTF-8と同じく文字列操作がO(n)になる。Unicode公式のエンコーディングであるという点を除いて特に良い点が見当たらないので後方互換性の必要な場面でないと使われてなさそうな気がする。例えばWindowsのファイルシステムはファイル名をUTF-16で保持しているらしい。&lt;/p&gt;

&lt;p&gt;尚、16bitのエンディアンは指定されてないのでファイルの先頭にバイトオーダーマーク(BOM)と呼ばれる空白文字を置いてそれでエンディアンを指定/判別する慣習になっている。&lt;/p&gt;

&lt;h2 id=&#34;utf-32:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;UTF-32&lt;/h2&gt;

&lt;p&gt;32bitの配列に文字列を収める。必ず32bitで1文字を表すので文字列操作が効率的に行なえる。欠点はASCIIの範囲の文字が多いとメモリを無駄にし易い点。どんな文字列を扱うか分からない(ASCIIの範囲が多いとは言い切れない)汎用ライブラリや言語処理系そのものでよく使われる。&lt;/p&gt;

&lt;h1 id=&#34;言語処理系の内部表現と外部エンコーディング:559e2d3ac35d44cd1f9d0f0d2cb45597&#34;&gt;言語処理系の内部表現と外部エンコーディング&lt;/h1&gt;

&lt;p&gt;ここで罠になるのがソースコードをUTF-8で書いて出入力をUTF-8で行なう処理系でも内部では先述の理由でUTF-8以外を使うことがあることだ。メジャーな言語について少し調べてみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SBCL(Common Lispのメジャーな処理系)はUTF-32を使う&lt;/li&gt;
&lt;li&gt;SpiderMonkey(FirefoxのJavaScript処理系)はUTF-8を使う。HTMLはマルチバイト文字を使う言語で書かれていても大半がASCIIになるからとのこと。また、文字列をropeで表現しており、UTF-8のデメリットを軽減出来る。&lt;/li&gt;
&lt;li&gt;Rubyは多言語対応の時に内部表現はなんでもアリ(渡された文字列そのまま)になった&lt;/li&gt;
&lt;li&gt;PerlはUTF-8を使う&lt;/li&gt;
&lt;li&gt;PythonはconfigureのオプションでUCS2(ほぼUTF-16に同じ)やUCS4(UTF-32形式のUnicodeと概ね互換)が選べる。FedoraやUbuntuはUCS4でビルドしている&lt;/li&gt;
&lt;li&gt;PHPは言語で動的に変更出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ソースコードをUTF-8で書いて出入力をUTF-8で行なうから変換コストなんてないと思ったら大間違いだ。裏ではUTF-32が使われていて、出入力の度に変換が走る。誰がUTF-32が使われてないなんて言ったんだ。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>