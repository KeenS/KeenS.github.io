<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gc on κeenのHappy Hacκing Blog</title>
    <link>//KeenS.github.io/categories/gc/</link>
    <description>Recent content in Gc on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 24 Jun 2018 15:11:23 +0900</lastBuildDate>
    
	<atom:link href="//KeenS.github.io/categories/gc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GCと1bit</title>
      <link>//KeenS.github.io/slide/gcto1bit/</link>
      <pubDate>Sun, 24 Jun 2018 15:11:23 +0900</pubDate>
      
      <guid>//KeenS.github.io/slide/gcto1bit/</guid>
      <description># GCと1bit ---------------------- [TCFMミートアップ](https://techplay.jp/event/680870) === # About Me --------- ![κeenのアイコン](/images/kappa.png) * κeen * [@blackenedgold](https://twitter.com/blackenedgold) * Github: [KeenS](https://github.com/KeenS) * [Idein Inc.](https://idein.jp/)のエンジニア * Lisp, ML, Rust, Shell Scriptあたりを書きます * 言語処理系が好き === # GCと(メタ)情報 -------------- * レジスタ/スタック上の値のpointer or not * Mark and Sweepのマーク * ヒープ上オブジェクトの「どこにポインタがいるか」 これらを節約する話 === # レジスタ中のポインタ ------------- * レジスタ上の値がポインタか数値か + GCのrootsetなので判断が必要 + 1bitの情報量が必要 * 多くはLSBをタグに使う + ポインタは0 + 4バイトアラインメントされてると自然にそうなる + 数値は1にする - 数値が31bit/63bitになる - タグを外して計算して戻すので遅い * bit stealしない方法は？ === ## レジスタ分別 --------------- * レジスタを半分に分ける + 片方はポインタ用 + もう片方は値用 * 物理的に1bit取らなくても1bitの情報量が確保できる * ただしレジスタが多いアーキじゃないと死ぬ === # Mark Bit ---------- * マーク済みかどうかのメタデータ + 1bitの情報量 * 素朴にはセルのメタデータに1byte確保 ``` +---+-------+---+-------+-- | 0 | .</description>
    </item>
    
    <item>
      <title>WebAssemblyでGC</title>
      <link>//KeenS.github.io/blog/2017/12/07/webassemblynogc/</link>
      <pubDate>Thu, 07 Dec 2017 23:19:41 +0900</pubDate>
      
      <guid>//KeenS.github.io/blog/2017/12/07/webassemblynogc/</guid>
      <description>&lt;p&gt;κeenです。この記事は&lt;a href=&#34;https://qiita.com/advent-calendar/2017/webassembly&#34;&gt;WebAssembly Advent Calendar 2017&lt;/a&gt; 8日目の記事です。WebAssemblyでガーベジコレクションする話。
2017-12-08: ページサイズに関する誤りを訂正しました。その他加筆。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>GCの話</title>
      <link>//KeenS.github.io/blog/2014/10/26/gcfalsehua/</link>
      <pubDate>Sun, 26 Oct 2014 19:13:45 +0000</pubDate>
      
      <guid>//KeenS.github.io/blog/2014/10/26/gcfalsehua/</guid>
      <description>&lt;p&gt;#関数型なんたら でGCの話を聴いて、&lt;a href=&#34;http://www.pllab.riec.tohoku.ac.jp/papers/icfp2011UenoOhoriOtomoAuthorVersion.pdf&#34;&gt;SML#のGCの論文&lt;/a&gt;を読んで色々感じたのでエントリー。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Picrinのチューニングの話、もといGCの話</title>
      <link>//KeenS.github.io/slide/picrin-gc/</link>
      <pubDate>Mon, 29 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>//KeenS.github.io/slide/picrin-gc/</guid>
      <description># Picrinのチューニングの話、もといGCの話 --- Lisp Meet Up presented by Shibuya.lisp #20 2014-09-29 κeen(@blackenedgold) # 自己紹介 --- + κeen + 東大数学科の4年生 + ソーシャルアカウントは上のアイコン達から。 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます + [picrin](https://github.com/picrin-scheme/picrin)のコミッタです # picrin --- ![picrin](/images/picrin/picrin-logo-fin01-02.png) # picrin --- * R7RS compatibility * bytecode interpreter (based on stack VM) * internal representation by nan-boxing * conservative call/cc implementation (users can freely interleave native stack with VM stack) * exact GC (simple mark and sweep, partially reference count is used as well) * string representation by rope data structure # picrin --- * R7RS compatibility * bytecode interpreter (based on stack VM) * internal representation by nan-boxing * conservative call/cc implementation (users can freely interleave native stack with VM stack) * exact GC (simple mark and sweep, partially reference count is used as well) * string representation by rope data structure # picrin開発者の不満 --- * picrinの起動が遅い+ 2秒くらいかかる * picrinのテストが遅い+ 16秒くらいかかる # 少しGCの話 --- GC(ごみ集め)とは * 使われていないオブジェクトを自動的に解法する + メモリ管理に煩わせられないで済む + メモリーリークを防ぐ。 * 「使われていないオブジェクト」を判定するのはいくつかアルゴリズムがある # GCのアルゴリズム --- ## 主なGCのアルゴリズム * マーク&amp;amp;スイープ * 参照カウント * Copying GC # GCのアルゴリズム --- ## マーク&amp;amp;スイープ 1.</description>
    </item>
    
  </channel>
</rss>