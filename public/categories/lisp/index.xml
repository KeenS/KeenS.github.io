<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lisp on κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/categories/lisp/</link>
    <description>Recent content in Lisp on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 07 Jun 2015 16:56:51 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/categories/lisp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ClojureでOpenCV 3.0と戯れる</title>
      <link>http://keens.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru</link>
      <pubDate>Sun, 07 Jun 2015 16:56:51 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/07/clojuredeopencv3_0totawamureru</guid>
      <description>

&lt;p&gt;κeenです。先日OpenCV 3.0がリリースされましたね。
ちょっと触ってみようと思ったのですが公式バインディングがC++、C、Java、Pythonと中々つらい言語ばっかりなので扱いやすいClojureから触った時のメモです。&lt;/p&gt;

&lt;p&gt;2系とはAPIが変わってる部分もあるらしく、苦労しました。
UbuntuでやってるのでMacの人は適当に読み替えて下さい。&lt;/p&gt;

&lt;h1 id=&#34;準備:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;準備&lt;/h1&gt;

&lt;h2 id=&#34;opencv:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;OpenCV&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://opencv.org/&#34;&gt;公式&lt;/a&gt;からOpenCV 3.0をダウンロードしてきましょう。展開してからは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-3.0.0
$ cmake .
$ make -j4
$ sudo make -j4 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインストールまでしてくれます。&lt;/p&gt;

&lt;h2 id=&#34;imshow:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;ImShow&lt;/h2&gt;

&lt;p&gt;どうも3.0からHighguiというQtベースのGUIツール群のJavaバインディングが作られなくなったそうです。Swing使えと。&lt;/p&gt;

&lt;p&gt;ということでOpenCVとSwingのブリッジしてくれる軽いライブラリが&lt;a href=&#34;https://github.com/master-atul/ImShow-Java-OpenCV&#34;&gt;ImShow-Java-OpenCV&lt;/a&gt;
です。.javaファイル1枚なので本当に軽いです。&lt;/p&gt;

&lt;p&gt;.jarもレポジトリに入ってるのですがソースコードより古いらしく、自分でビルドする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:master-atul/ImShow-Java-OpenCV.git
$ cd ImShow-Java-OpenCV/ImShow_JCV/src
$ javac com/atul/JavaOpenCV/Imshow.java
$ jar -cf Imshow.jar com/atul/JavaOpenCV/Imshow.class
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lein-プロジェクト:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;lein プロジェクト&lt;/h2&gt;

&lt;p&gt;Clojureのプロジェクト管理ツールの&lt;a href=&#34;http://leiningen.org/&#34;&gt;Leiningen&lt;/a&gt;を使います。知らない人は適当にググって下さい。&lt;/p&gt;

&lt;p&gt;まずプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein new opencv-play
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んで、mavenでいうところのpom.xmlにあたるproject.cljをいじります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd opencv-play
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]])
$ edit project.clj
$ cat project.clj
(defproject opencv-play &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.6.0&amp;quot;]
                 [cider/cider-nrepl &amp;quot;0.9.0-SNAPSHOT&amp;quot;]]
  :jvm-opts [&amp;quot;-Djava.library.path=./lib&amp;quot;]
  :resource-paths [&amp;quot;./lib/opencv-300.jar&amp;quot;
                   &amp;quot;./lib/Imshow.jar&amp;quot;]
  :injections [(clojure.lang.RT/loadLibrary org.opencv.core.Core/NATIVE_LIBRARY_NAME)])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしたら先程のライブラリ達を配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir lib
$ cp /usr/local/share/OpenCV/java/* lib
$ cp /path/to/ImShow-Java-OpenCV/ImShow_JCV/src/Imshow.jar lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにlenaも呼びましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir img
$ cp /path/to/src/of/opencv-3.0.0/samples/data/lena.jpg img
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;遊ぶ:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;遊ぶ&lt;/h1&gt;

&lt;p&gt;準備完了ってことでREPLを起動しましょう。ちょっと遅いですが我慢。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein repl
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar 
nREPL server started on port 52301 on host 127.0.0.1 - nrepl://127.0.0.1:52301
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_25-b17
    Docs: (doc function-name-here)
          (find-doc &amp;quot;part-of-name-here&amp;quot;)
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このままREPLを使ってもいいですが私はEmacsから&lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt;でnREPLにつなぎます。
REPLでも補完は効くのでEmacsやらのエディタの設定が面倒ならこのままでも十分ですよ。&lt;/p&gt;

&lt;p&gt;まずは画像のロードから。2系とは違ってImagecodecを使うようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.imgcodecs Imgcodecs])
org.opencv.imgcodecs.Imgcodecs
user&amp;gt; (def lena (Imgcodecs/imread &amp;quot;img/lena.jpg&amp;quot;))
#&#39;user/lena
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いじる前に表示してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [com.atul.JavaOpenCV Imshow])
com.atul.JavaOpenCV.Imshow
user&amp;gt; (def is (Imshow. &amp;quot;Lena&amp;quot;))
#&#39;user/is
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/show-lena.png&#34; alt=&#34;lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;よしよし。表示されましたね。ではこの辺を参考に顔認識してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/woxtu/items/bf39e3d53cbf60396d2c&#34;&gt;Clojure - 二次元絵の顔を検出する - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずは必要なパッケージの読み込み&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core Mat CvType])
org.opencv.core.CvType
user&amp;gt; (import [org.opencv.imgproc Imgproc])
org.opencv.imgproc.Imgproc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前処理のグレースケール変換からヒストグラムの均一化まで一気にやってしまいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def buffer (Mat. 512 512 CvType/CV_8UC3))
#&#39;user/buffer
user&amp;gt; (Imgproc/cvtColor lena buffer Imgproc/COLOR_RGB2GRAY)
nil
user&amp;gt; (Imgproc/equalizeHist buffer buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで一旦画像の確認。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is buffer)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/gray-hist-lena.png&#34; alt=&#34;gray-hist-lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ふむふむ。ではでは顔を認識しますか。&lt;/p&gt;

&lt;p&gt;まずは色々準備します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [org.opencv.core MatOfRect])
org.opencv.core.MatOfRect
user&amp;gt; (import [org.opencv.objdetect CascadeClassifier])
org.opencv.objdetect.CascadeClassifier
user&amp;gt; (def faces (MatOfRect.))
#&#39;user/faces
user&amp;gt; (def classifier (CascadeClassifier.))
#&#39;user/classifier
user&amp;gt; (.load classifier &amp;quot;/usr/local/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml&amp;quot;)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに分類器のデータのロードは成功がtrueで失敗がfalseだそうです。例外投げないんですね。ハマった。パス名に&lt;code&gt;~&lt;/code&gt;を使うと(ホームを省略表記すると)ロードに失敗するようなのでお気をつけて。&lt;/p&gt;

&lt;p&gt;それでは実行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.detectMultiScale classifier buffer faces)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、顔の位置がとれたので画像に重ねるのですがここではSwing(AWT)の描画を使ってみましょう。
OpenCVの描画は画像に描画するのでファイルに書き出しても残っているのに対してSwingのだと表示しているフレームに描画するので書き出した画像には残りません。また、リフレッシュすれば消えるのでインタラクティブに実験するのに向いてます。&lt;/p&gt;

&lt;p&gt;一旦準備。フレームをレナの元画像に戻しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (import [java.awt Rectangle Color])
java.awt.Color
user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImshowのWndowというパブリックなメンバにJFrameが入ってるのでそれを操作します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (def g2 (.getGraphics (.Window is)))
#&#39;user/g2
user&amp;gt; (.setColor g2 Color/GREEN)
nil
user&amp;gt; (doseq [face (.toList faces)]
  (let [rect (Rectangle.)]
    (do
      (.setRect rect (.width face) (.height face) (.x face) (.y face))
      (.draw g2 rect))))
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://KeenS.github.io/images/clojure-opencv/face-recognized-lena.png&#34; alt=&#34;face recognized lena&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;パチパチパチ&lt;/p&gt;

&lt;p&gt;因みに四角形を消すには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user&amp;gt; (.showImage is lena)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で十分です。ミスっても何回でもやり直せますね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:f3a429adc3106e7ec83e1e87bf1a8a30&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;因みに3.0のドキュメントが探しづらいのですが、masterにあるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.opencv.org/master/&#34;&gt;OpenCV: OpenCV&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OpenCVをインタラクティブに扱えると楽しいのでみなさんClojure使いましょう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Transducerについて</title>
      <link>http://keens.github.io/slide/transducernitsuite/</link>
      <pubDate>Wed, 03 Jun 2015 22:29:50 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/transducernitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Transducerについて
----------------------
サイバーエージェント  
朝の3分スピーチ
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます

# Transducerって？
------------------

* Clojure 1.7で入るフレームワーク
* 関数のパイプライン化を簡単にする
* 入力、出力には依存しない


# Reduce関数について
-------------------

* `reduce: (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* `(&#39;a -&gt; &#39;b -&gt; &#39;a)` でシーケンスを集約する
* `(reduce + 0 &#39;(1 2 3)) ;=&gt; 6`
* 要はreduceは関数を使って集約する。

# Transducerについて
-------------------

* `transduce:((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a)) (&#39;a -&gt; &#39;b -&gt; &#39;a) &#39;a -&gt; &#39;b list`
* 集約関数を変換する関数もとる
* `(transduce xf + 0 &#39;(1 2 3))`
* transducerで集約する前に処理を挟める

# すごいところ
-------------------------
## コンポーサビリティ

* `((&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;a))`
* 変換関数は入力と出力が同じ。
* つまり変換関数を合成出来る
* ex) `(comp (filter odd?) (map inc))`


# すごいところ2
--------------------------
## 汎用性

* 各関数は入力や出力について知る必要はない
  + シーケンスではなく要素に対して定義される
* シーケンスだけでなく遅延シーケンス、ストリーム、チャネルなどなどにも使える
* 中間シーケンスを作らない
  + 遅延シーケンスやストリームには大きなメリット
* 集約先をシーケンスなどにすることも出来る
  + 関数の汎用性が上がる

# すごいところ3
--------------
## 並列/非同期

* core.asyncもtransducerをサポート
* 各変換関数を並列/非同期に実行が可能
* さらに各関数に割り当てるプロセッサの数も細かく制御出来る


&lt;span style=&#34;font-size: 500%;&#34;&gt;変換して&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 500%;&#34;&gt;集約する&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 300%;&#34;&gt;何かに似てない？&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 600%;&#34;&gt;MapReduce&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; ozaさんの近しい環境というとHadoop...多段Mapreduceをtransdecerみたいにしようってはなしとかですか？&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605368356393218048&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; まさにその通りです．MapReduce には Combiner という中間集約をする API があるのですが，それをもっと汎用的にしようという話です． &lt;a href=&#34;http://t.co/injEiPjePG&#34;&gt;http://t.co/injEiPjePG&lt;/a&gt;&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605369771505221633&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/oza_x86&#34;&gt;@oza_x86&lt;/a&gt; すごい楽しそうですね。Clojure向けのAPIがtransducerのバッグエンドになって普段書いてるコードがそのままHadoopで動いたりしたら、とか夢が無限に広がります&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/605370461476646912&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; おお，その案は良いですね！！&lt;/p&gt;&amp;mdash; oza (@oza_x86) &lt;a href=&#34;https://twitter.com/oza_x86/status/605370619509637121&#34;&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 200%;&#34;&gt;Clojure 1.7 + Transducer&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size: 400%;&#34;&gt;Comming Soon&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 参考
------
* [Clojure 1.7のtransducersを動かしてみよう - Qiita](http://qiita.com/tokomakoma123/items/1ca3fb0dddc5b901b032)
* [core.async+transducers Shibuya.lisp #21](http://www.slideshare.net/ktsujister/coreasynctransducers-shibuyalisp-21)
* [Hadoop Combinerメモ(Hishidama&#39;s Hadoop Combiner Memo)](http://www.ne.jp/asahi/hishidama/home/tech/apache/hadoop/Combiner.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispで限定継続と遊ぶ</title>
      <link>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</link>
      <pubDate>Sun, 26 Apr 2015 21:09:07 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Common_Lispdegenteikeizokutoasobu_/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Common Lispで限定継続と遊ぶ
----------------------
[Lisp Meet Up #27](https://atnd.org/events/64988)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 渋谷のエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# Agenda
--------

0. cl-contの紹介
1. 限定継続の話
2. 限定継続の使い方の話
3. 限定継続の実装の話


# CL-CONTの紹介

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CL-CONT
---------

* Common Lispの限定継続ライブラリ
* 結構古くからあるっぽい
* 割と色々なライブラリが使ってる

# CL-CONT
---------

![cl-cont dependers](/images/cl-cont-dependers.png)

# API
-----

* 継続を区切るマクロ
  + `with-call/cc`
  + `defun/cc`
  + `lambda/cc`
* 継続を取得するマクロ
  + `call/cc`
  + `let/cc`

※後で説明するので意味が分からなくても問題ないです。


# 限定継続の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後トップレベルに戻るまでの計算。
* Schemeが一級市民として扱えることで有名
* 値として取り出した時は0-1引数関数として振る舞う

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```

# 継続とは
----------
`foo`の継続は、`foo`を虫食いにしたものと思えば良い。

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      □)))
```

# 継続とは
----------
あとはそれを関数にするだけ

```lisp
(lambda (k)
  (mapc #&#39;writ-line
        (loop :for x :in list
           :collect (if (evenp x)
                        k))))
```


# 限定継続とは
---------

* &#34;その後&#34;の計算を表わす概念。
* 値が決定した後 *指定した位置* に戻るまでの計算。
* 継続がトップレベルまで戻るのに対して限定継続途中で止まる。それだけ。
* 部分継続などの言い方もある
  + 英語もpart contとdelimited contで分かれる


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(mapc #&#39;writ-line
      (loop :for x :in list
         :collect (if (evenp x)
                      (foo x))))
```


# 限定継続とは
-------------
先の例を`loop`までの限定継続にすると

```lisp
(loop :for x :in list
           :collect (if (evenp x)
                        □))
```


# 限定継続とは
-------------

```lisp
(lambda (k)
  (loop :for x :in list
     :collect (if (evenp x)
                  k)))
```

# 限定継続の挙動
---------------
普通のやつ

```lisp
(with-call/cc
  (+ 1 (call/cc
        (lambda (k)
          (funcall k 2)))))
```

これは

```lisp
(+ 1 2)
```

と等価

# 限定継続の挙動
---------------
今度は継続を呼ばないでみる

```lisp
(with-call/cc
  (+ 1 (call/cc (lambda (k) 2))))
```

これは

```lisp
2
```

と等価

# 限定継続の挙動
---------------
もうちょっと呼ばない例  
(`(let/cc k ...)` = `(call/cc (lambda (k) ...))`)

```lisp
(with-call/cc
  (write-line &#34;hello&#34;)
  (let/cc k 1)
  (write-line &#34;world&#34;))
```

は

```lisp
(progn
  (write-line &#34;hello&#34;)
  1)
```

と等価


# 限定継続の使い方の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の使い方の話
---------------------

* グリーンスレッド
* コールバックを綺麗に書き換える
* 非決定性計算
* etc...


## グリーンスレッド

&lt;!-- .slide: class=&#34;center&#34; --&gt;


## グリーンスレッド
-----------------

* またの名をコルーチン
* またの名を強調スレッド



## グリーンスレッド
-----------------

```lisp
(let (c)
  (setf c (with-call/cc
            (write-line &#34;in thread A 1&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 2&#34;)
            (let/cc k k)
            (write-line &#34;in thread A 3&#34;)))
  (write-line &#34;in main thread 1&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 2&#34;)
  (setq c (funcall c))
  (write-line &#34;in main thread 3&#34;))
```

## グリーンスレッド
-----------------
実行結果

```
in thread A 1
in main thread 1
in thread A 2
in main thread 2
in thread A 2
in main thread 3

```


## コールバックの書き換え

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## コールバックの書き換え
----------------------
本当はこう書きたい

```lisp
(with-event-loop
    (format t &#34;Hello, ~a!~%&#34; (async-read stream)))
```

## コールバックの書き換え
----------------------
しかしライブラリがコールバック関数を要求してくる

```lisp
(with-event-loop
    (async-read stream (lambda (line)
                         (format t &#34;Hello, ~a!~%&#34; line))))
```

## コールバックの書き換え
-----------------------
コールバック = 限定継続（後述）なのでこうしてやれば良い。

```lisp
(with-event-loop
    (with-call/cc
      (format t &#34;Hello, ~a!~%&#34;
              (call/cc (lambda (k))
                       (async-read stream k)))))
```

## 非決定性計算

&lt;!-- .slide: class=&#34;center&#34; --&gt;

## 非決定性計算
-------------
### ベースアイディア

* 継続を関数として取り出した後同じ処理を何回も実行出来るんじゃね？


## 非決定性計算
-------------
### ベースアイディア
複数回呼び出してみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (list (funcall c 1)
        (funcall c 2)
        (funcall c 3)))
```


## 非決定性計算
-------------
### ベースアイディア
普通の1引数関数として使ってみる

```lisp
(let (c)
  (setf c (with-call/cc
            (+ 1 (* 2 (- 3 (let/cc k k))))))
  (mapcar c (list 1 2 3)))
```

## 非決定性計算
-------------
### ベースアイディア
マクロでラップしてみる

```lisp
(defmacro for (&amp;body expr)
  `(with-call/cc ,@expr))
(defmacro in (m)
  `(let/cc k (apply #&#39;append (mapcar k ,m))))
(defun yield (x) (list x))
(defun unit () nil)
```


## 非決定性計算
-------------
使ってみる

```lisp
(for
  (let ((x (in &#39;(1 2 3)))
        (y (in &#39;(a b c))))
    (yield (cons x y))))
```

```
((1 . A) (1 . B) (1 . C) (2 . A) (2 . B) (2 . C) (3 . A) (3 . B) (3 . C))
```


# 限定継続の実装の話

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 限定継続の実装の話
-------------------

* 継続は0~1引数関数として取り出せるのであった。
  + 実は機械的に取り出せる
* 継続は全ての式に暗黙に存在するのであった
  + 全ての式を継続を明示的に使うようにも出来る


# CPS変換

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# CPS変換
---------

* 全ての関数の引数を1つ増やして、そこで継続を受け取る
* 値を返す時は暗黙のreturnを使うのではなく明示的に継続を呼ぶ
* 関数を呼ぶ時は必ず継続を渡す。呼び出し元には返ってこない（自然と末尾再帰になる）


# CPS変換
---------
例えば

```lisp
(with-call/cc
  (foo (call/cc
        (lambda (k)
          (funcall k 2)))))
```

は、取り出された継続が

```lisp
(lambda (k) (foo k))
```

。


# CPS変換
---------
よって

```lisp
((lambda (k) (foo k)) 2)
```

と変換される


# CPS変換
---------
再帰関数だと少し面倒

```lisp
(defun fact (n)
  (if (&lt;= n)
      1
      (* n (fact (- n 1))))))

```

が

```lisp
(defun fact (n c)
  (if (&lt;= n)
      (c 1)
      (fact (- n 1) (lambda (v) (* n v)))))
```

となる


# CPS変換
---------

* CPS変換を行なうことでいつでも継続を値として使える


# 限定継続の実装の話
-------------------

* CPS変換を裏で行なっている
* 自動で出来るのでマクロで変換をしている
  + 組み込み関数は変更出来ないので特別扱い
  + スペシャルフォームも気をつける必要がある
* `lambda`が乱立するのでパフォーマンスは酷い。


# まとめ
-------

* cl-contというライブラリがあって、限定継続が扱える
* 限定継続は処理を中断したり再開したり繰り返したりに使える
* 裏ではえげつないことをやっている
* パフォーマンスが必要なところでは使っちゃダメ


# 参考
------
* [picrin/partcont.scm at master · picrin-scheme/picrin](https://github.com/picrin-scheme/picrin)
* [cl-cont | Quickdocs](http://quickdocs.org/cl-cont/)
* [コルーチンをCommon Lispで簡単に定義 - さくらんぼのlambda日記](http://lambdasakura.hatenablog.com/entry/20111026/1319598590)
* [継続渡しスタイル - Wikipedia](http://ja.wikipedia.org/wiki/%E7%B6%99%E7%B6%9A%E6%B8%A1%E3%81%97%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB)
* [M.Hiroi&#39;s Home Page / お気楽 Scheme プログラミング入門](http://www.geocities.jp/m_hiroi/func/abcscm20.html)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>caveman2、ningle…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト</title>
      <link>http://keens.github.io/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</link>
      <pubDate>Thu, 05 Mar 2015 13:18:44 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/caveman2-ningle...Common-LispnoWebmawarinofure-muwa-kuwokaitekinitsukautatta1tsunokoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# caveman2、ningle、datafly…Common LispのWeb周りのフレームワークを快適に使うためのたった1つのコト
----------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#34;font-size:300%&#34;&gt;ずっと俺のターン&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 問題
------
Common Lispは case

* Sensitive &lt;!--.element: class=&#34;fragment grow&#34; data-fragment-index=&#34;1&#34; --&gt;  
* Insensitive &lt;!--.element: class=&#34;fragment shrink&#34; data-fragment-index=&#34;1&#34; --&gt;

どっち?

# 問題
-------

あれ？

```lisp
(eql? &#39;CaseInsensitive &#39;caseinsensitive) ;=&gt; t
```


# 問題
-------

リーダがデフォルトで大文字にするだけ

```lisp
(eql? &#39;|CaseSensitive| &#39;|casesensitive|) ;=&gt; nil
```


# Caveman2
---------

```lisp
@route GET &#34;/hello&#34;
(defun say-hello (&amp;key (|name| &#34;Guest&#34;))
  (format nil &#34;Hello, ~A&#34; |name|))
```

# Ningle
--------

```lisp
(setf (ningle:route *app* &#34;/login&#34; :method :POST)
      #&#39;(lambda (params)
          (if (authorize (getf params :|username|)
                         (getf params :|password|))
            &#34;Authorized!&#34;
            &#34;Failed...Try again.&#34;)))
```

# 面倒…
----
デフォルトでそのままだたっらいいのに

# 魔法の`readtable-case`

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 魔法の`readtable-case`
-----------------------

```lisp
(setf (readtable-case *readtable*) :invert)
```
を使えばOK  
参考: [SBCLでclispとかallegroのmodern mode的なことをする - wasabizの日記](http://wasabiz.hatenablog.com/entry/20120929/1348889601)

# 例
----

```lisp
CL-USER&gt; :username
:USERNAME
CL-USER&gt; (setf (readtable-case *readtable*) :invert)
:invert
CL-USER&gt; :username
:username
```

# まとめ
--------
* `(setf (readtable-case *readtable*) :invert)`を使うと快適だよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Lispエイリアンの矢印作った</title>
      <link>http://keens.github.io/blog/2015/03/03/lispeiriannoyajirushitsukutta</link>
      <pubDate>Tue, 03 Mar 2015 21:30:13 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/03/03/lispeiriannoyajirushitsukutta</guid>
      <description>&lt;p&gt;κeenです。勉強会などで役立ちそうなLispエイリアンの矢印を作りました。&lt;/p&gt;

&lt;p&gt;Lispエイリアンの元データは&lt;a href=&#34;http://www.lisperati.com/logo.html&#34;&gt;こちら&lt;/a&gt;でPNGやSVGで公開されているのでInkscapeの練習がてらそれをいじりました。&lt;/p&gt;

&lt;p&gt;どうぞ&lt;br /&gt;
&lt;img src=&#34;http://KeenS.github.io/images/lisplogo_alien_arrow.svg&#34; alt=&#34;lisplogo_alien_arrow.svg&#34; /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://KeenS.github.io/images/lisplogo_alien_arrow.svg&#34;&gt;lisplogo_alien_arrow.svg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ライセンスは元データに倣ってパブリックドメインとします。&lt;/p&gt;

&lt;p&gt;PNG形式のもの必要…ですか？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>既存のテンプレートエンジンの問題点と再設計</title>
      <link>http://keens.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</link>
      <pubDate>Mon, 02 Mar 2015 23:36:03 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/kizonnotenpure-toenjinnomondaitentosaisekkeiaruihaArrowsnitsuite/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt;
.red {
color: red;
}
&lt;/style&gt;
# 既存のテンプレートエンジンの問題点と再設計、あるいはArrowsについて
-----------------------------------------------------------------
Clack Meet Up #1  
2015-03-05 @サムライト

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + 野生のLisper
 + Lisp, Ruby, OCaml, Shell Scriptあたりを書きます

# Template Engines

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Existing Architeture
----------------------
0. (リクエスト)
1. アプリ
  0. 引数を計算
  1. テンプレートに引数を渡す
  2. レスポンスをレンダリング &lt;!--.element: class=&#34;fragment grow&#34;  --&gt;
4. レスポンスをサーバに渡す
5. (レスポンス)

# Rendering?
----------------------
* 結合した文字列はクライアントに返ったらその後はゴミ
 + GCへ負荷がかかる (後述)
* クライアントにとって1つの文字列である必要はない
* むしろ返せる部分だけ先に返した方が得（後述）

# GC Pressure (SBCL)
-----------------
* 世代別Copy GC
* 結合した文字列は比較的大きい
* `alloc_space`に入らない大きさならアロケートが遅い
* GCを頻繁に起動してしまう
* 16KBを越えると特別扱いされて遅い/メモリを喰う
* LispのWebアプリはレスポンスタイムの分散が大きい（要出展）

参考: [SBCL GENCGC @ x86 Linux](http://cl-www.msi.co.jp/reports/sbcl-gc-memo.html)

# Split Response
---------------
例えば、こんなの

&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot; xml:lang=&amp;quot;en&amp;quot; lang=&amp;quot;en-us&amp;quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://localhost:1313//reveal.js/lib/css/xcode.css&amp;quot;&amp;gt;
        &amp;lt;script src=&amp;quot;//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
        ....
        &amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body class=&amp;quot;li-body&amp;quot;&amp;gt;
    &amp;lt;header&amp;gt;{{ header }}&amp;lt;/header&amp;gt;
    {{ body }}
    ...
&lt;/code&gt;&lt;/pre&gt;

# Split Response
---------------
1. `{{ header }}`の前に先頭から`&lt;header&gt;`までを返す
2. `{{ header }}`を返す
3. `&lt;/header&gt;`を返す
4. `{{ body }}`を返す

...


# Pros of Split Response
------------------------
* `header`を計算してる間にクライアントにhead部分が渡る
  + 先に`&lt;link&gt;`や`&lt;script&gt;`を要求出来る
  + サーバ側のスループットやレスポンスタイムは変わらないが
    クライアントのレンダリング完了までの時間は大幅に短縮出来る
* 文字列を結合する必要がない
* 定数部分については長さが判ってるので最適化し易い

# How TEs Work 
---------------------------
## Compilation
1. テンプレート文字列
 + パーサ &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
 + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数

# How TEs Work 
---------------------------
## Rendering
1. レンダリング関数
 + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列

# Misc Problems
---------------
* サーバに渡すのは文字列なのにソケットに書き込む時はオクテット？
  + 文字列で返す？オクテットで返す？（デバッグがー）
  + オクテットの変換はいつ？
* ストリームが遅い？
  + POSIX APIが使える&#34;なら&#34;fdの方が速い？
* ユーザが用意したバッファに書き出したい？
* テンプレートに渡す引数が定数文字列なら畳み込める筈？
* リクエストの度にテンプレートパースするのは筋悪だけど開発中は毎回コンパイルするのは面倒？

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;

# Arrows

Template flies like an arrow

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Arrows
--------
* [KeenS/arrows](https://github.com/KeenS/arrows)
* 現在開発中のテンプレートエンジン
* 複数のテンプレートが選べる（予定）
* 複数のバックエンドが選べる
* バックエンドに依ってはnon-consing

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Compilation
1. テンプレート文字列&lt;span class=&#34;red&#34;&gt; + 定数引数&lt;/span&gt;
  + パーサ&lt;span class=&#34;red&#34;&gt;(default, cl-emd互換...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 抽象構文木
  + &lt;span class=&#34;red&#34;&gt;最適化(const folding, concat, convert...)&lt;/span&gt; &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
  + コードエミット &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
3. レンダリング関数&lt;span class=&#34;red&#34;&gt;(string, octets, stream, fast-io ...)&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How Arrows Works
------------------
## Rendering
1. レンダリング関数
  + 引数 &lt;!-- .element: style=&#34;list-style-image: url(/images/arrow_down.svg);&#34; --&gt;
2. 文字列&lt;span class=&#34;red&#34;&gt;、オクテット列、ストリーム書き出し、fast-io…&lt;/span&gt;

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How compiled
--------------

```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を

```lisp
(compile-template-string :xxx
  &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34; ())
```
とコンパイル

# Stream backend
----------------
&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* ほとんどアロケートしない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Octet backend
----------------

```lisp
(lambda (&amp;key name)
  (with-fast-output (buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;&lt;h1&gt;Hi &#34;)
       buffer)
    (fast-write-sequence
      (string-to-octets
        (encode-for-tt (princ-to-string name)))
                       buffer)
    (fast-write-sequence
      #.(string-to-octets &#34;!&lt;/h1&gt;&#34;)
      buffer)))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------

```html
&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;
```
を

```lisp
(compile-template-string :stream
   &#34;&lt;h1&gt;Hi {{var name}}!&lt;/h1&gt;&#34;
   &#39;(:known-args (:name &#34;&lt;κeen&gt;&#34;)))
```
とコンパイル

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## variable folding

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string (encode-for-tt &#34;&lt;κeen&gt;&#34;) stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 既知の引数は畳み込む
* 文字列なら`princ-to-string`しない

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## const folding

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string &#34;&amp;lt;κeen&amp;gt;&#34; stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```
* 定数のエスケープはコンパイル時に済ませる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# How optimized
---------------
## append sequence

```lisp
(lambda (stream)
  (write-string &#34;&lt;h1&gt;Hi &amp;lt;κeen&amp;gt;!&lt;/h1&gt;&#34;
                stream))
```
* 複数シーケンスの書き出しは1つにまとめる

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
* 引数計算の遅延
* 引数計算の並列化
* 非同期化
* HTML compction

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の遅延
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は必要になったら値を計算する(Promise パターン)

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 引数計算の並列化
* `name`の計算が重いときに先に`&#34;&lt;h1&gt;Hi &#34;`を返す。
* `name`は並列に計算して必要になったら値を要求する(Futureパターン)

```lisp
(lambda (stream &amp;key name)
  (write-string &#34;&lt;h1&gt;Hi &#34; stream)
  (write-string
    (encode-for-tt (princ-to-string name))
    stream)
  (write-string &#34;!&lt;/h1&gt;&#34; stream))
```

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## 非同期化
* 単純にwriteを非同期にする
* 他にFutureもブロックするので非同期Futureを使う

&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# Further Ideas
---------------
## HTML compction

```html
&lt;ol&gt;
  &lt;li&gt; item 1 &lt;/li&gt;
  &lt;li&gt; item 2 &lt;/li&gt;
  &lt;li&gt; item 3 &lt;/li&gt;
&lt;/ol&gt;

```
を

```html
&lt;ol&gt;&lt;li&gt;item 1&lt;/li&gt;&lt;li&gt;item 2&lt;/li&gt;&lt;li&gt;item 3&lt;/li&gt;&lt;/ol&gt;

```
* DOM構造が変わってしまう


&lt;!-- .slide: data-background=&#34;/images/arrows.jpg&#34; --&gt;
# TODOs
-------
* 設計上複数シンタックスをサポート可能だがまだしてない
* 既存のテンプレートエンジンとの比較ベンチマーク
* 高速化
* 多機能化
  + テンプレート
  + 最適化
  + バックエンド
* clackとの連携
  + clackのAPIはメモリアロケーションが多めに必要になる

# Summary
---------
* 既存のテンプレートエンジンは非効率
  + メモリを無駄遣いしていた
  + ユーザーのことを考えてなかった
* 新しいテンプレートエンジンを設計した
  + メモリアロケーションをあまりしない
  + ユーザー側の速度まで考慮した
  + 柔軟
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>面接でLispを口にして落ちない企業、私気になります！</title>
      <link>http://keens.github.io/blog/2015/02/10/mensetsudelispwokuchinishiteochinaikigyouwatashikininarimasu</link>
      <pubDate>Tue, 10 Feb 2015 08:01:35 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/02/10/mensetsudelispwokuchinishiteochinaikigyouwatashikininarimasu</guid>
      <description>

&lt;p&gt;κeenです。先日の記事がやたら拡散しました。その中で&lt;/p&gt;

&lt;p&gt;「面接でLispは口にしない方が良い。100%落ちる。」&lt;/p&gt;

&lt;p&gt;の一文がえらく気に入られたようです。Lispの風評被害を防ぐために1つアンケートにご協力下さい。&lt;/p&gt;

&lt;p&gt;このスプレッドシートです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1dUUOSpKqPK_tMqboxzAfPaL1eAEVwAdYy4AP_5HWeVw/edit?usp=sharing&#34;&gt;面接でLispを口にして落ちない企業調査表 - Google スプレッドシート&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;「うちの会社は面接でLispを口にしても落ちないぜ」って方はお手隙ならば書いて下さると嬉しいです。単純な興味目的のゆるふわなアンケートです。調査項目は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;会社名&lt;/li&gt;
&lt;li&gt;会社のURL&lt;/li&gt;
&lt;li&gt;書いた人(本名、スクリーンネーム、なんかのIDかは任意。IDにすると連絡がとれて便利かも)&lt;/li&gt;
&lt;li&gt;コメント、会社のアピールなど(長文可、任意)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;で。&lt;/p&gt;

&lt;p&gt;利用規約(？)は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;社員が書く。会社に全く書かない人は勝手に書かない。&lt;/li&gt;
&lt;li&gt;改竄を防ぐために一度書いたら同じ人しか編集してはいけない。同じ会社の人でもダメ。&lt;/li&gt;
&lt;li&gt;どっかのメディアに掲載されても怒らない。&lt;/li&gt;
&lt;li&gt;メディア側は改竄なしでリスト全部を引用し、引用した日時も付記する。あるいはURLにリンクを張る。二次引用は禁止する。&lt;/li&gt;
&lt;li&gt;問題が生じたら管理者(@blackenedgold)がこのスプレッドシートを非公開にする。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こんなもんですかね。ゆるふわアンケートなので書く側もゆるふわな気持でお願いします。&lt;/p&gt;

&lt;h1 id=&#34;補足:9e6d9857d06fd9b1ba5f4a8582464265&#34;&gt;補足&lt;/h1&gt;

&lt;h1 id=&#34;面接でlispは口にしない方が良い-100-落ちる-について補足:9e6d9857d06fd9b1ba5f4a8582464265&#34;&gt;「面接でLispは口にしない方が良い。100%落ちる。」について補足&lt;/h1&gt;

&lt;p&gt;振り返ってみるとそんなことはありませんでした。就活のある時点までは確かに真で、次の面接でLispを口にしなかったら落ちなかったのでそんなイメージになってました。
しかしよく考えたら私が内定頂いたところはむしろ全部Lispのおかげで内定頂きました。こっちの情報の方が大事だった。拝承。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Common Lispのポータビリティとユニバーサリティ</title>
      <link>http://keens.github.io/blog/2015/01/22/common-lisp-portability-and-univesality</link>
      <pubDate>Thu, 22 Jan 2015 07:51:02 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/01/22/common-lisp-portability-and-univesality</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://clfreaks.org/post/108341635899/1-cim-vs-roswell&#34;&gt;clfreaks&lt;/a&gt;の収録時に他のLisperと話してて価値観というか目標を共有出来てないなと思ったのでここで心情を語る次第。今のCommon Lispの使われ方には問題がある。&lt;/p&gt;

&lt;p&gt;Common Lispにはポータビリティというかユニバーサリティというか、そういうものがない。いや、処理系の作者達はしっかり作ってるのだけどLisperがそういう使い方をしていない。&lt;/p&gt;

&lt;p&gt;例えば、Rubyで出来たアプリケーションを使いたいとしよう。Jekyllがいいかな。大抵のシステムには入ってるだろうが一応処理系のインストールから始めてみる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aptなりpkgなりyumなりで処理系をインストールする。それが気に入らなければソースからインストールしてもいい。&lt;/li&gt;
&lt;li&gt;処理系をインストールするとgemがついてくるので&lt;code&gt;gem install jekyll&lt;/code&gt;を叩く。&lt;/li&gt;
&lt;li&gt;あとはJekyllを使うだけ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あるいは、Octopressなら処理系のインストールのあとは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git cloneしてくる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gem install bundler&lt;/code&gt;でbundlerをインストールする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bundle install&lt;/code&gt;で依存gemをインストールする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bundle exec rake preview&lt;/code&gt;でサーバーが起動する。&lt;/li&gt;
&lt;li&gt;止めたければCtrl-Cで止まる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Common Lispで出来たアプリケーションを使いたいとしよう。&lt;a href=&#34;https://github.com/vsedach/cliki2&#34;&gt;cliki&lt;/a&gt;。がいいかな。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;処理系のインストールはRubyと同じくパッケージマネージャで入る。あるいはソースからインストールしてもいい。この際処理系選びは既に終わっているとする。&lt;/li&gt;
&lt;li&gt;clikiをgit cloneしてくる。&lt;/li&gt;
&lt;li&gt;ASDFに読んでもらうために~/common-lisp以下にclikiを移動する。&lt;/li&gt;
&lt;li&gt;依存パッケージのインストールのためにquicklispをインストールする。

&lt;ul&gt;
&lt;li&gt;quicklisp.lispをダウンロードしてくる。&lt;/li&gt;
&lt;li&gt;REPLを起動する。どうやって？処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;li&gt;Lispの式をいくつか評価してquicklispをインストールする。~/quicklispが出現するがこの際目を瞑る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;REPLで&lt;code&gt;(ql:quickload :cliki)&lt;/code&gt;を評価して依存パッケージをインストールする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(start-cliki-server port homedir wikis)&lt;/code&gt;でサーバーが起動する。REPLも起動しっぱなし。&lt;/li&gt;
&lt;li&gt;止めたければ

&lt;ul&gt;
&lt;li&gt;Ctrl-Cでinteractive-interruptコンディションを発生させる。デバッガが起動する。&lt;/li&gt;
&lt;li&gt;デバッガからREPLのtoplevelに戻る。デバッガの操作?処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;li&gt;REPLを終了する。どうやって？処理系依存だから自分で調べろ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「アプリケーションは~/common-lispじゃなくて/var/wwwに置きたいんだけど」 - 「コンフィグ書いたら変えられるよ。ASDFのコンフィグ書いてね。コンフィグの書き方はLisperの常識だよね」&lt;br /&gt;
「~/quicklisp邪魔なんだけど」 - 「ああ、それも変えられるよ。好きな場所に移動して処理系の初期化ファイル書き直してね。初期化ファイル？処理系依存だから自分で調べろ。どう直すか？簡単なLispの式だから自分で直せるよね？」&lt;/p&gt;

&lt;p&gt;多分言いたいことは伝わったかと思う。コマンドラインから扱えないとかパッケージマネージャが我が儘とか色々あるんだけど全ては「Lisperのためだけのものになっている」の一言で表せられる。&lt;/p&gt;

&lt;p&gt;quicklispが我が儘なのはまだ許せる。インストール先のディレクトリが固定されてないと管理しづらいから。しかしASDFがライブラリじゃなくてアプリケーションにまで特定のパスにあることを要求してくるのは納得がいかない。コンパイルやらロードやらテストやらの機能があるんだから.asdファイルのあるディレクトリをルートとしてそこだけで完結してほしい。以前、&lt;a href=&#34;http://KeenS.github.io/blog/2014/11/30/quicklisp/&#34;&gt;こんな記事&lt;/a&gt;を書いた所為でASDFの信者と思われているみたいだが、どっちかというとASDFの方が嫌いだ。ASDFが憖っか依存関係の解決までするがためにアプリケーションの置き場まで制約を受ける。手を広げたがために本来の機能が使い辛くなっている。Lisperが制約を受けるのはまだいい。アプリケーションのユーザにまで制約が及ぶのは耐えられない。&lt;/p&gt;

&lt;p&gt;コマンドラインから扱えない問題は多分ノウハウがなかったからだと思う。&lt;a href=&#34;http://KeenS.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/&#34;&gt;以前の記事&lt;/a&gt;で紹介した方法は多分知られていなかった。あとは複雑で使い辛いと評判(だった)のcl-launchか。アプリケーションはおろかquicklispすらREPLに入らないと使えない。ユーザがLispを微塵も知らない可能性すらあるのに。さらに、コマンドラインから使えないということは他のUnixツール群と組み合わせることも困難になる。また、&lt;a href=&#34;http://blog.8arrow.org/entry/20120323/1332516342&#34;&gt;ここ&lt;/a&gt;にあるようにREPLでアプリケーションを起動していると問題もある。&lt;/p&gt;

&lt;p&gt;私はこの問題を解決するためにCIMを作った。clfreaksの時にも喋ったがCIMのメインの機能は&lt;code&gt;cl&lt;/code&gt;コマンドと&lt;code&gt;ql&lt;/code&gt;コマンドだ。&lt;code&gt;cim&lt;/code&gt;コマンドはただの付加価値のためにつけたおまけである。&lt;/p&gt;

&lt;p&gt;もしclコマンドが広く使われるようになればshebangにclを使うだけで実行可能ファイルが作れて、コマンドラインから使えるようになる。qlを使えばREPLに入らずにパッケージをインストール出来る。スクリプトがエラーを出してもデバッガに入るようなことはない。Ctrl-Cでちゃんと止まる。&lt;/p&gt;

&lt;p&gt;これで一部ユニバーサリティの問題は解決出来たんだけだまだまだ未解決問題がある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CIMのインストールが必要になる。&lt;/li&gt;
&lt;li&gt;コマンドラインツールは解決したにしてもディレクトリ丸ごと持ってくるようなアプリケーションはASDFの制約をうける&lt;/li&gt;
&lt;li&gt;コンパイルの問題&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1はやっぱりLispを知らない人に使ってもらいたいならCIMのインストールは省きたい。処理系とquicklispだけ入れたら使えてほしい。やっぱりquicklispに変わってもらうしかないのかな。配布物に実行可能形式を含めてたらPATHも通して欲しいし。&lt;/p&gt;

&lt;p&gt;2のASDFの制約の問題はASDFを環境変数で制御出来るようなのでうまいことする方法を考えている。良い方法があったらまたアウトプットする。&lt;/p&gt;

&lt;p&gt;3は現状CIMで扱いかねてる問題。マクロ展開の問題からコンパイルするのが望ましいんだけどコンパイル後のファイルに互換性がない。しかも互換性がないのに同じ拡張子を使う。そこを上手く扱ってくれるのはASDFなんだけどやっぱり奴は我が儘だし何よりコンパイルしてしまうとAllegroを除いてshebangが効かなくなる。&lt;/p&gt;

&lt;p&gt;解決案はいくつか上がってるんだけどまだ決定的なものはない。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;コンパイルをあきらめる&lt;/li&gt;
&lt;li&gt;本体だけASDFでコンパイルしてエントリポイントになるスクリプトはコンパイルしない&lt;/li&gt;
&lt;li&gt;スタンドアロンバイナリ配布する&lt;/li&gt;
&lt;li&gt;ECLを使ってCのファイルを配布する&lt;/li&gt;
&lt;li&gt;ユーザー側にスタンドアロンバイナリを作らせる&lt;/li&gt;
&lt;li&gt;特定の処理系を要求する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1は下の策。&lt;/p&gt;

&lt;p&gt;2は個人的に推したいところだけどやっぱりASDFが憎い。&lt;/p&gt;

&lt;p&gt;3はクロスコンパイルが壊滅的なCommon Lispでは現実的ではない。&lt;/p&gt;

&lt;p&gt;4はCommon Lispの利点の一つにSBCLやCCLやCMU CLの速度が速いというのがあるから出来れば自由に処理系を選ばせたい。あとECLのランタイムのインストールが必要になる。&lt;/p&gt;

&lt;p&gt;5はやっぱりASDFが憎い。それに依存ライブラリもロードするにはquicklispもロードする必要があって、以前の記事の通りバイナリに邪魔なものが入るしそうでなくてもバイナリが素で60MBとかになる。stripするとアプリケーションとして動かなくなるからstripも出来ない。&lt;/p&gt;

&lt;p&gt;6はコンパイル後のファイルがポータブルな処理系はABCL、CLISP、XCLあたりだが、起動の遅いABCL、微妙に仕様に従ってなくて開発も停滞気味なCLISP、既に開発されていない上にマイナーでライブラリのサポートも薄いXCLとあまり選びたくないものばかり。&lt;/p&gt;

&lt;p&gt;因みに非Lispユーザにも使われているCommon LispアプリケーションにStumpWMがあるが、5の方法を採用している。しかしASDFを使わずにMakefileでコンパイルしている。依存ライブラリも手でインストールする必要がある。出来ればCommon Lispのツールチェーンに載せたまま配布したいところ…&lt;/p&gt;

&lt;p&gt;研究が必要。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>picrinのcodegenプロセスを説明してみる</title>
      <link>http://keens.github.io/blog/2015/01/10/picrin-codegen-explanation</link>
      <pubDate>Sat, 10 Jan 2015 09:40:51 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2015/01/10/picrin-codegen-explanation</guid>
      <description>

&lt;p&gt;今、picrinのcodegenプロセスに手を入れる機運が高まってます。picrinはバイトコードインタプリタなのでS式を渡されたらそれをバイトコードに変換する作業が必要です。それがcodegen。本当はcompileなんだけどpicrinのCのソースコードのコンパイルと紛らわしいからcodegen。私も完全にはプロセスを理解してないので説明して理解度を試しつつ問題点を洗い出します。&lt;/p&gt;

&lt;h1 id=&#34;関連ファイル:693fca136e4ca5c28a91dc5895343393&#34;&gt;関連ファイル&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;extlib/benz/codegen.c&lt;/li&gt;
&lt;li&gt;extlib/benz/macro.c&lt;/li&gt;
&lt;li&gt;(extlib/benz/read.c)&lt;/li&gt;
&lt;li&gt;(extlib/benz/vm.c)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;おおまかな流れ:693fca136e4ca5c28a91dc5895343393&#34;&gt;おおまかな流れ&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;(&lt;code&gt;read&lt;/code&gt;する)&lt;/li&gt;
&lt;li&gt;マクロ展開する&lt;/li&gt;
&lt;li&gt;コードの解析をする&lt;/li&gt;
&lt;li&gt;バイトコードを生成する&lt;/li&gt;
&lt;li&gt;(実行する)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;今回説明するのは2~4です。&lt;/p&gt;

&lt;h1 id=&#34;マクロ展開:693fca136e4ca5c28a91dc5895343393&#34;&gt;マクロ展開&lt;/h1&gt;

&lt;p&gt;入力:Schemeの式&lt;br /&gt;
出力:マクロ展開済みのS式&lt;br /&gt;
副作用:マクロテーブルの更新、ライブラリテーブルの更新、その他マクロ毎の副作用&lt;/p&gt;

&lt;p&gt;extlib/benz/macro.cに処理があります。&lt;/p&gt;

&lt;p&gt;メインの部分はこれです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
macroexpand_node(pic_state *pic, pic_value expr, struct pic_senv *senv)
{
  switch (pic_type(expr)) {
  case PIC_TT_SYMBOL: {
    return macroexpand_symbol(pic, pic_sym(expr), senv);
  }
  case PIC_TT_PAIR: {
    pic_value car;
    struct pic_macro *mac;

    if (! pic_list_p(expr)) {
      pic_errorf(pic, &amp;quot;cannot macroexpand improper list: ~s&amp;quot;, expr);
    }

    car = macroexpand(pic, pic_car(pic, expr), senv);
    if (pic_sym_p(car)) {
      pic_sym tag = pic_sym(car);

      if (tag == pic-&amp;gt;rDEFINE_SYNTAX) {
        return macroexpand_defsyntax(pic, expr, senv);
      }
      else if (tag == pic-&amp;gt;rLAMBDA) {
        return macroexpand_defer(pic, expr, senv);
      }
      else if (tag == pic-&amp;gt;rDEFINE) {
        return macroexpand_define(pic, expr, senv);
      }
      else if (tag == pic-&amp;gt;rQUOTE) {
        return macroexpand_quote(pic, expr);
      }

      if ((mac = find_macro(pic, tag)) != NULL) {
        return macroexpand_node(pic, macroexpand_macro(pic, mac, expr, senv), senv);
      }
    }

    return pic_cons(pic, car, macroexpand_list(pic, pic_cdr(pic, expr), senv));
  }
  default:
    return expr;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;S式を行きがけ順でマクロ展開していきます。&lt;/p&gt;

&lt;p&gt;リストの先頭にあるものをマクロと疑って展開しようとしますが、見ての通り&lt;code&gt;define-syntax&lt;/code&gt;、&lt;code&gt;lambda&lt;/code&gt;、&lt;code&gt;define&lt;/code&gt;、&lt;code&gt;quote&lt;/code&gt;だけは特別扱いされています。このスペシャルフォーム達は引数に括弧つきのものを取ったり引数を全く触ってほしくなかったりするのでマクロ展開時に特別な処理がされるんですね。他はシンボルは変数名(identifier)として処理し、リストとシンボル以外のものはそのまま返します。&lt;/p&gt;

&lt;p&gt;ここに1つ問題があります。&lt;code&gt;find_macro&lt;/code&gt;です。&lt;a href=&#34;https://github.com/picrin-scheme/picrin/issues/234&#34;&gt;イシューにも挙げられて&lt;/a&gt;いますが、マクロを定義したあと同じ名前の手続を定義したら手続で上書きされる筈なのにマクロとして展開されてしまいます。これはマクロと手続きで別のテーブルを持っていることに起因します。ちゃんと上書きされるようにするにはマクロも変数束縛テーブルに登録すれば解決出来るのかなと思ってます。&lt;/p&gt;

&lt;h2 id=&#34;シンボル:693fca136e4ca5c28a91dc5895343393&#34;&gt;シンボル&lt;/h2&gt;

&lt;p&gt;変なことはしてません。スコープを遡っていき、最初に見付かったインターンされたシンボルを返します。見付からなかった(=未定義のシンボルだった)ときは新たなgensymを返します。&lt;/p&gt;

&lt;h2 id=&#34;define-syntax:693fca136e4ca5c28a91dc5895343393&#34;&gt;&lt;code&gt;define-syntax&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
macroexpand_defsyntax(pic_state *pic, pic_value expr, struct pic_senv *senv)
{
  pic_value var, val;
  pic_sym sym, rename;

  if (pic_length(pic, expr) != 3) {
    pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
  }

  var = pic_cadr(pic, expr);
  if (! pic_sym_p(var)) {
    pic_errorf(pic, &amp;quot;binding to non-symbol object&amp;quot;);
  }
  sym = pic_sym(var);
  if (! pic_find_rename(pic, senv, sym, &amp;amp;rename)) {
    rename = pic_add_rename(pic, senv, sym);
  } else {
    pic_warnf(pic, &amp;quot;redefining syntax variable: ~s&amp;quot;, pic_sym_value(sym));
  }

  val = pic_cadr(pic, pic_cdr(pic, expr));

  pic_try {
    val = pic_eval(pic, val, pic-&amp;gt;lib);
  } pic_catch {
    pic_errorf(pic, &amp;quot;macroexpand error while definition: %s&amp;quot;, pic_errmsg(pic));
  }

  if (! pic_proc_p(val)) {
    pic_errorf(pic, &amp;quot;macro definition \&amp;quot;~s\&amp;quot; evaluates to non-procedure object&amp;quot;, var);
  }

  define_macro(pic, rename, pic_proc_ptr(val), senv);

  return pic_none_value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;手を入れる候補。やってることは単純で、&lt;code&gt;(define-syntax &amp;lt;name&amp;gt; &amp;lt;definition&amp;gt;)&lt;/code&gt;の形で引数を渡される筈だからnameをdefinitionに関連づけてマクロとして登録します。返り値はnone。返り値はnone。大事なことなので2回言いました。&lt;/p&gt;

&lt;p&gt;一応実行時にはマクロ展開は全て終了してる筈なので&lt;code&gt;define-syntax&lt;/code&gt;をマクロ展開時に消し去っても良い筈なんですが、気持ち悪いですよね。コアを小さくするという意味では正解なんですが…。あとファイルのコンパイルを考えた時に&lt;code&gt;define-syntax&lt;/code&gt;をファイルの外に持ち出せなくなるという実用上の問題もあります。&lt;/p&gt;

&lt;p&gt;あと、definitionがマクロ展開だけで止まってしまうと困るのでdefinitionだけはevalしているのもキモいポイントですね。&lt;/p&gt;

&lt;p&gt;改善案は&lt;code&gt;define&lt;/code&gt;と同じようにすること。そのためにはマクロ展開後の処理(analyze、codegen、VM命令)にも&lt;code&gt;define-syntax&lt;/code&gt;用の処理を入れる必要があって、面倒。&lt;/p&gt;

&lt;h2 id=&#34;lambda:693fca136e4ca5c28a91dc5895343393&#34;&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt;の扱いは面倒です。一番分かり易い例は再帰マクロですかね。マクロの定義中に定義中のマクロが見えてる必要があります。この解決策として&lt;code&gt;lambda&lt;/code&gt;だけはマクロ展開を遅延(defer)します。じゃあいつ遅延されたマクロが展開されるかというと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;pic_value
pic_macroexpand(pic_state *pic, pic_value expr, struct pic_lib *lib)
{
  struct pic_lib *prev;
  pic_value v;

#if DEBUG
  puts(&amp;quot;before expand:&amp;quot;);
  pic_debug(pic, expr);
  puts(&amp;quot;&amp;quot;);
#endif

  /* change library for macro-expansion time processing */
  prev = pic-&amp;gt;lib;
  pic-&amp;gt;lib = lib;

  lib-&amp;gt;env-&amp;gt;defer = pic_nil_value(); /* the last expansion could fail and leave defer field old */

  v = macroexpand(pic, expr, lib-&amp;gt;env);

  macroexpand_deferred(pic, lib-&amp;gt;env);

  pic-&amp;gt;lib = prev;

#if DEBUG
  puts(&amp;quot;after expand:&amp;quot;);
  pic_debug(pic, v);
  puts(&amp;quot;&amp;quot;);
#endif

  return v;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;macroexpand&lt;/code&gt;の後です。&lt;code&gt;macroexpand&lt;/code&gt;は&lt;code&gt;macroexpand_node&lt;/code&gt;の薄いラッパと思って下さい。&lt;/p&gt;

&lt;p&gt;遅延されたマクロ展開は&lt;code&gt;senv-&amp;gt;defer&lt;/code&gt;にpushされ、&lt;code&gt;macroexpand_deferred&lt;/code&gt;で1つずつ&lt;code&gt;macroexpand_lambda&lt;/code&gt;されます。&lt;code&gt;macroexpand_lambda&lt;/code&gt;はまあ、想像通りです。formalをα変換したあとformalとbodyをマクロ展開します。α変換は&lt;code&gt;senv&lt;/code&gt;にシンボル -&amp;gt; gensymのキーペアを突っ込むだけです。返り値は&lt;code&gt;(lambda formal body)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;define:693fca136e4ca5c28a91dc5895343393&#34;&gt;define&lt;/h2&gt;

&lt;p&gt;比較的単純です。&lt;code&gt;(define name value)&lt;/code&gt;の他に&lt;code&gt;(define (name formal) body)&lt;/code&gt;のMIT記法にも対応する必要があるのでマクロ展開時に特別扱いされてます。&lt;code&gt;(define name value)&lt;/code&gt;を返り値として返します。MIT記法もこの形に正規化されます。&lt;/p&gt;

&lt;h2 id=&#34;quote:693fca136e4ca5c28a91dc5895343393&#34;&gt;quote&lt;/h2&gt;

&lt;p&gt;特に語る事はないです。&lt;/p&gt;

&lt;h2 id=&#34;他のマクロ:693fca136e4ca5c28a91dc5895343393&#34;&gt;他のマクロ&lt;/h2&gt;

&lt;p&gt;Schemeのマクロ展開は簡単で、マクロ手続をbody、展開場所の環境、定義場所の環境の3つを引数として呼び出せば終りです。勿論&lt;code&gt;macroexpand_node&lt;/code&gt;を見て分かるように最後まで展開します。picrinはCommon Lisp風の伝統的マクロもサポートしてるので伝統的マクロだった時はbodyだけを引数として呼び出します。&lt;/p&gt;

&lt;h2 id=&#34;蛇足:693fca136e4ca5c28a91dc5895343393&#34;&gt;蛇足&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;define-syntax&lt;/code&gt;だけを指摘しましたが、マクロ展開後にnoneになるマクロは他にもあります。library関係全部です。個人的にはやつらもVM命令まで残すべきだと思ってます。&lt;/p&gt;

&lt;p&gt;因みにもう1つlibrary関係の問題があります。&lt;code&gt;define-library&lt;/code&gt;直下の&lt;code&gt;begin&lt;/code&gt;についてです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-library (hoge)
  (begin
    (define foo ...)
    (define bar ...)
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようなコードを考えます。&lt;code&gt;define-library&lt;/code&gt;直下の&lt;code&gt;begin&lt;/code&gt;は他とセマンティクスが違って、&lt;code&gt;begin&lt;/code&gt;内のコードをトップレベルで定義されたかのように扱う必要があります。しかしpicrinは普通の&lt;code&gt;begin&lt;/code&gt;と同じように扱っています。これがどのような違いを産むかというと、コンパイル順を見れば分かり易いです。&lt;/p&gt;

&lt;p&gt;仕様: fooのマクロ展開-&amp;gt;fooの解析-&amp;gt;fooのコード生成-&amp;gt;barのマクロ展開-&amp;gt;barの解析-&amp;gt;barのコード生成&lt;br /&gt;
picrin: fooのマクロ展開-&amp;gt;barのマクロ展開-&amp;gt;fooの解析-&amp;gt;barの解析-&amp;gt;fooのコード生成-&amp;gt;barのコード生成&lt;/p&gt;

&lt;p&gt;picrinのコンパイル順序だとマクロ展開を先にやってしまうのでマクロ展開中に同じ&lt;code&gt;begin&lt;/code&gt;内で&lt;code&gt;define&lt;/code&gt;されたシンボルが見えなくなってしまいます。尚、後述しますが今のpicrinはこのコンパイル順序のおかげで手続の相互参照が可能になってます。ここもどうにかしないといけない。&lt;/p&gt;

&lt;h1 id=&#34;コード解析:693fca136e4ca5c28a91dc5895343393&#34;&gt;コード解析&lt;/h1&gt;

&lt;p&gt;入力:マクロ展開済みのS式&lt;br /&gt;
出力:中間表現&lt;br /&gt;
副作用:無し&lt;/p&gt;

&lt;p&gt;extlib/benz/codegen.cに処理があります。&lt;/p&gt;

&lt;p&gt;ここの処理ではS式をVM命令に近いS式に書き換えます。&lt;code&gt;(+ 1 x)&lt;/code&gt;が&lt;code&gt;(+ (quote 1) (gref x))&lt;/code&gt;になるなど。この解析後のS式は特に呼び名はなさそうなので中間表現と呼んでおきます。&lt;/p&gt;

&lt;p&gt;中間表現には&lt;code&gt;cons&lt;/code&gt;、&lt;code&gt;car&lt;/code&gt;などの16の基本的な手続に対応する命令や&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;define&lt;/code&gt;などの6つのスペシャルフォームの他、&lt;code&gt;call&lt;/code&gt;、&lt;code&gt;tailcall&lt;/code&gt;、&lt;code&gt;call-with-values&lt;/code&gt;、&lt;code&gt;tailcall-with-values&lt;/code&gt;の4つの手続呼び出し命令、&lt;code&gt;gref&lt;/code&gt;、&lt;code&gt;lref&lt;/code&gt;、&lt;code&gt;cref&lt;/code&gt;の3つの変数参照、&lt;code&gt;return&lt;/code&gt;があります。合計30の命令です。JIT化も視野に入れてるので基本命令は少なくする方針なんでしょう。また、組み込みも意識しているのでその気になればコアを小さく出来るようにする意味もあるのかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gref&lt;/code&gt;はグローバル変数、&lt;code&gt;lref&lt;/code&gt;はローカル変数、&lt;code&gt;cref&lt;/code&gt;はクcaptured変数を参照します。ここでピンときた方も居るかと思いますが、コード解析がスコープ周りを担当しています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;analyze_*&lt;/code&gt;系は&lt;code&gt;analyze_state&lt;/code&gt;を持ち回ししますが、こいつはpicrin VMとスコープを表現する構造体の他に中間命令のシンボル(の一部)のキャッシュや中間命令にそのまま翻訳されるべき手続(&lt;code&gt;cons&lt;/code&gt;や&lt;code&gt;car&lt;/code&gt;)のキャッシュを持ちます。手続はライブラリに属するのでキャッシュを捜すときに少し特別な処理が入ってますね。中間命令のシンボルのキャッシュが一部だけなのは他は&lt;code&gt;pic_state&lt;/code&gt;構造体が既に持ってるからですね。&lt;/p&gt;

&lt;p&gt;さて、本体はやはり&lt;code&gt;analyze_node&lt;/code&gt;ですが30命令分のifを持つので少し大きいですね。載せるのをやめて面白いやつだけ取り上げましょうか。どうでもいいけどこれ、caseじゃなくてif elseなので並び換えたら高速化しそうですね。&lt;/p&gt;

&lt;h2 id=&#34;変数:693fca136e4ca5c28a91dc5895343393&#34;&gt;変数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;analyze_var&lt;/code&gt;がスコープの深さでgref、lref、crefに振り分けます。&lt;code&gt;analyze_*_var&lt;/code&gt;はgref、lref、crefを返すだけの関数。&lt;/p&gt;

&lt;p&gt;スコープを遡って変数を捜していき、変数が見付かったスコープの深さ=今いるスコープの深さならグローバル変数、、今いるスコープならローカル変数、それ以外なら捕捉変数です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_var(analyze_state *state, pic_sym sym)
{
  pic_state *pic = state-&amp;gt;pic;
  int depth;

  if ((depth = find_var(state, sym)) == -1) {
    pic_errorf(pic, &amp;quot;unbound variable %s&amp;quot;, pic_symbol_name(pic, sym));
  }

  if (depth == state-&amp;gt;scope-&amp;gt;depth) {
    return analyze_global_var(state, sym);
  } else if (depth == 0) {
    return analyze_local_var(state, sym);
  } else {
    return analyze_free_var(state, sym, depth);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにこれ、変数が見付からなかったらエラー出してますけどSchemeは仕様上は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (foo) (bar))
(define (bar) ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように後から定義することも可能なので仕様に準拠してないことになります。ここが手を入れるポイント2つ目。&lt;/p&gt;

&lt;p&gt;改善案は見付からなかった変数は一旦NOWHEREとかに束縛しておいてanalyze時にはエラーを出さない。実行時にNOWHEREに束縛された変数が出てくればエラー。&lt;/p&gt;

&lt;h2 id=&#34;define-1:693fca136e4ca5c28a91dc5895343393&#34;&gt;define&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_define(analyze_state *state, pic_value obj)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value var, val;
  pic_sym sym;

  if (pic_length(pic, obj) != 3) {
    pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
  }

  var = pic_list_ref(pic, obj, 1);
  if (! pic_sym_p(var)) {
    pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
  } else {
    sym = pic_sym(var);
  }
  var = analyze_declare(state, sym);

  if (pic_pair_p(pic_list_ref(pic, obj, 2))
      &amp;amp;&amp;amp; pic_sym_p(pic_list_ref(pic, pic_list_ref(pic, obj, 2), 0))
      &amp;amp;&amp;amp; pic_sym(pic_list_ref(pic, pic_list_ref(pic, obj, 2), 0)) == pic-&amp;gt;rLAMBDA) {
    pic_value formals, body_exprs;

    formals = pic_list_ref(pic, pic_list_ref(pic, obj, 2), 1);
    body_exprs = pic_list_tail(pic, pic_list_ref(pic, obj, 2), 2);

    val = analyze_defer(state, pic_sym_value(sym), formals, body_exprs);
  } else {
    if (pic_length(pic, obj) != 3) {
      pic_errorf(pic, &amp;quot;syntax error&amp;quot;);
    }
    val = analyze(state, pic_list_ref(pic, obj, 2), false);
  }

  return pic_list3(pic, pic_symbol_value(pic-&amp;gt;sSETBANG), var, val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;手続を&lt;code&gt;define&lt;/code&gt;するときに上の後から定義(interreferencial definitionという)を一部の状況で実現するために束縛する値がlambdaかどうかで場合分けしています。lambdaの場合は&lt;code&gt;analyze_defer&lt;/code&gt;を使います。そうすることで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(begin
  (define (foo) (bar))
  (define (bar) ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けばbegin -&amp;gt; define foo -&amp;gt; define bar -&amp;gt; (analyze deferred) -&amp;gt; foo本体 -&amp;gt; bar本体
の順番に解析されることになるのでコンパイルが通ります。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;define&lt;/code&gt;された手続に名前をつける(シンボルと手続を関連付けるのではない)役割もあります。&lt;/p&gt;

&lt;h2 id=&#34;lambda-1:693fca136e4ca5c28a91dc5895343393&#34;&gt;lambda&lt;/h2&gt;

&lt;p&gt;また例の再帰定義とかで面倒なやつです。&lt;code&gt;analyze_lambda&lt;/code&gt;が引数のチェックだけしたら&lt;code&gt;analyze_defer&lt;/code&gt;に丸投げして、&lt;code&gt;analyze_defer&lt;/code&gt;はモックのエントリーポイントだけ返してdeferリストに処理をpushします。&lt;/p&gt;

&lt;p&gt;んで後から呼ばれる&lt;code&gt;analyze_deferred&lt;/code&gt;が1つずつ&lt;code&gt;analyze_procedure&lt;/code&gt;します。マクロ展開と微妙に名前が違うのが気になりますね。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;analyze_procedure&lt;/code&gt;が本体になるのですが、スコープを作るので少しややこしいことになってます。&lt;/p&gt;

&lt;h3 id=&#34;スコープと変数:693fca136e4ca5c28a91dc5895343393&#34;&gt;スコープと変数&lt;/h3&gt;

&lt;p&gt;スコープの解説をしてませんでしたね。変数を参照するときはスコープの関係で4種類出てきます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;グローバル変数 : トップレベルで&lt;code&gt;define&lt;/code&gt;されたもの&lt;/li&gt;
&lt;li&gt;ローカル変数 : lambda内で&lt;code&gt;define&lt;/code&gt;されたもの&lt;/li&gt;
&lt;li&gt;自由変数 : lambdaの外かつトップレベルでない変数&lt;/li&gt;
&lt;li&gt;引数 : lambdaの引数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;captureについて: 変数を導入した側から見たら「捕捉された変数」で、変数を参照する側から見たら「自由変数」です。&lt;/p&gt;

&lt;p&gt;さて、変数の種類を見たところで&lt;code&gt;analyze_procedure&lt;/code&gt;の定義を見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_procedure(analyze_state *state, pic_value name, pic_value formals, pic_value body_exprs)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value args, locals, varg, captures, body;

  assert(pic_sym_p(name) || pic_false_p(name));

  if (push_scope(state, formals)) {
    analyze_scope *scope = state-&amp;gt;scope;
    pic_sym *var;
    size_t i;

    args = pic_nil_value();
    for (i = xv_size(&amp;amp;scope-&amp;gt;args); i &amp;gt; 0; --i) {
      var = xv_get(&amp;amp;scope-&amp;gt;args, i - 1);
      pic_push(pic, pic_sym_value(*var), args);
    }

    varg = scope-&amp;gt;varg
      ? pic_true_value()
      : pic_false_value();

    /* To know what kind of local variables are defined, analyze body at first. */
    body = analyze(state, pic_cons(pic, pic_sym_value(pic-&amp;gt;rBEGIN), body_exprs), true);

    analyze_deferred(state);

    locals = pic_nil_value();
    for (i = xv_size(&amp;amp;scope-&amp;gt;locals); i &amp;gt; 0; --i) {
      var = xv_get(&amp;amp;scope-&amp;gt;locals, i - 1);
      pic_push(pic, pic_sym_value(*var), locals);
    }

    captures = pic_nil_value();
    for (i = xv_size(&amp;amp;scope-&amp;gt;captures); i &amp;gt; 0; --i) {
      var = xv_get(&amp;amp;scope-&amp;gt;captures, i - 1);
      pic_push(pic, pic_sym_value(*var), captures);
    }

    pop_scope(state);
  }
  else {
    pic_errorf(pic, &amp;quot;invalid formal syntax: ~s&amp;quot;, args);
  }

  return pic_list7(pic, pic_sym_value(pic-&amp;gt;sLAMBDA), name, args, locals, varg, captures, body);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコープを作ったあとは最初に引数をスコープに登録して本体内ででcapture出来るようにしてます。んで本体をanalyzeしてローカル変数と捕捉された変数を洗い出してます。&lt;/p&gt;

&lt;p&gt;因みにvargというのはCommon Lispでいう&amp;amp;restや&amp;amp;optionalを引っ括めたものです。&lt;/p&gt;

&lt;h2 id=&#34;begin:693fca136e4ca5c28a91dc5895343393&#34;&gt;begin&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static pic_value
analyze_begin(analyze_state *state, pic_value obj, bool tailpos)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value seq;
  bool tail;

  switch (pic_length(pic, obj)) {
  case 1:
    return analyze(state, pic_none_value(), tailpos);
  case 2:
    return analyze(state, pic_list_ref(pic, obj, 1), tailpos);
  default:
    seq = pic_list1(pic, pic_symbol_value(pic-&amp;gt;sBEGIN));
    for (obj = pic_cdr(pic, obj); ! pic_nil_p(obj); obj = pic_cdr(pic, obj)) {
      if (pic_nil_p(pic_cdr(pic, obj))) {
        tail = tailpos;
      } else {
        tail = false;
      }
      seq = pic_cons(pic, analyze(state, pic_car(pic, obj), tail), seq);
    }
    return pic_reverse(pic, seq);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そんなに大したコードじゃないんですけど末尾呼出最適化のためのコードが垣間見えたので載せました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;自身が末尾位置にいれば&lt;code&gt;begin&lt;/code&gt;の最後の式は末尾位置になりますがそれ以外は必ず非末尾位置になるよねーってコードです。&lt;/p&gt;

&lt;h1 id=&#34;バイトコード生成:693fca136e4ca5c28a91dc5895343393&#34;&gt;バイトコード生成&lt;/h1&gt;

&lt;p&gt;入力:中間表現&lt;br /&gt;
出力:バイトコード&lt;br /&gt;
副作用:無し&lt;/p&gt;

&lt;p&gt;extlib/benz/codegen.cに処理があります。&lt;/p&gt;

&lt;p&gt;ここの処理では中間表現をスタックベースのpicrin VM命令に変換します。&lt;/p&gt;

&lt;h2 id=&#34;vm命令やlambdaの内部表現:693fca136e4ca5c28a91dc5895343393&#34;&gt;VM命令やlambdaの内部表現&lt;/h2&gt;

&lt;h3 id=&#34;vm命令フォーマット:693fca136e4ca5c28a91dc5895343393&#34;&gt;VM命令フォーマット&lt;/h3&gt;

&lt;p&gt;フォーマットは3種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct pic_code {
  enum pic_opcode insn;
  union {
    int i;
    char c;
    struct {
      int depth;
      int idx;
    } r;
  } u;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見ての通り命令番号(opcode)+&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;char&lt;/li&gt;
&lt;li&gt;int2つ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;になっています。因みに普通使われるのは1. intで、2. charはOP_PUSHCHARのみ、3. int2つはOP_CREFとOP_CSETのみに使われます。また、引数(?)を全く持たない命令もあります(スタックマシンなため)。&lt;/p&gt;

&lt;h3 id=&#34;愉快なvm命令たち:693fca136e4ca5c28a91dc5895343393&#34;&gt;愉快なVM命令たち&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;enum pic_opcode {
  OP_NOP,
  OP_POP,
  OP_PUSHNIL,
  OP_PUSHTRUE,
  OP_PUSHFALSE,
  OP_PUSHINT,
  OP_PUSHCHAR,
  OP_PUSHCONST,
  OP_GREF,
  OP_GSET,
  OP_LREF,
  OP_LSET,
  OP_CREF,
  OP_CSET,
  OP_JMP,
  OP_JMPIF,
  OP_NOT,
  OP_CALL,
  OP_TAILCALL,
  OP_RET,
  OP_LAMBDA,
  OP_CONS,
  OP_CAR,
  OP_CDR,
  OP_NILP,
  OP_ADD,
  OP_SUB,
  OP_MUL,
  OP_DIV,
  OP_MINUS,
  OP_EQ,
  OP_LT,
  OP_LE,
  OP_STOP
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大体名前から分かるかと思います。&lt;code&gt;quote&lt;/code&gt;は&lt;code&gt;OP_PUSH*&lt;/code&gt;系になります。&lt;code&gt;OP_STOP&lt;/code&gt;はあるのに&lt;code&gt;OP_START&lt;/code&gt;がないのは分かりますね。開始はユーザーの操作から始まるのに対して停止はプログラム側が行うからです。&lt;/p&gt;

&lt;h3 id=&#34;lambdaとか:693fca136e4ca5c28a91dc5895343393&#34;&gt;lambdaとか&lt;/h3&gt;

&lt;p&gt;lambdaとかのエントリポイント付きのコード1まとまりはirepと呼ばれています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct pic_irep {
  PIC_OBJECT_HEADER
  pic_sym name;
  pic_code *code;
  int argc, localc, capturec;
  bool varg;
  struct pic_irep **irep;
  pic_valuel *pool;
  size_t clen, ilen, plen;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PIC_OBJECT_HEADER&lt;/code&gt;: オブジェクトタイプのタグ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;: 名前（あれば）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*code&lt;/code&gt;: VM命令たち&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argc&lt;/code&gt;、 &lt;code&gt;localc&lt;/code&gt;、 &lt;code&gt;capturec&lt;/code&gt;: 引数数、ローカル変数数、捕捉された変数数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;varg&lt;/code&gt;: &amp;amp;rest引数を持つか&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**irep&lt;/code&gt;: irepプール&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*pool&lt;/code&gt;: 定数プール&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clen&lt;/code&gt;、&lt;code&gt;ilen&lt;/code&gt;、&lt;code&gt;plen&lt;/code&gt;: *code、**irep、*poolの長さ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スコープを作るので変数を格納するpoolを持ちます。そしてlambdaだけは定数プールとは別にirepに格納します。&lt;/p&gt;

&lt;h2 id=&#34;コード生成:693fca136e4ca5c28a91dc5895343393&#34;&gt;コード生成&lt;/h2&gt;

&lt;p&gt;本体は&lt;code&gt;codegen&lt;/code&gt;なんですがこれまた長いので掻い摘んで。帰りがけ順でコード生成します。&lt;/p&gt;

&lt;h3 id=&#34;cons:693fca136e4ca5c28a91dc5895343393&#34;&gt;cons&lt;/h3&gt;

&lt;p&gt;まずは肩馴らし。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sCONS) {
    codegen(state, pic_list_ref(pic, obj, 1));
    codegen(state, pic_list_ref(pic, obj, 2));
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_CONS;
    cxt-&amp;gt;clen++;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数1と引数2を生成する命令を吐いてから&lt;code&gt;OP_CONS&lt;/code&gt;命令を吐きます。引数1と引数2は自ら値をスタックにPUSHします。&lt;/p&gt;

&lt;h3 id=&#34;quote-1:693fca136e4ca5c28a91dc5895343393&#34;&gt;quote&lt;/h3&gt;

&lt;p&gt;少し長いですが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sQUOTE) {
    int pidx;

    obj = pic_list_ref(pic, obj, 1);
    switch (pic_type(obj)) {
    case PIC_TT_BOOL:
      if (pic_true_p(obj)) {
        cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHTRUE;
      } else {
        cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHFALSE;
      }
      cxt-&amp;gt;clen++;
      return;
    case PIC_TT_INT:
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHINT;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = pic_int(obj);
      cxt-&amp;gt;clen++;
      return;
    case PIC_TT_NIL:
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHNIL;
      cxt-&amp;gt;clen++;
      return;
    case PIC_TT_CHAR:
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHCHAR;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.c = pic_char(obj);
      cxt-&amp;gt;clen++;
      return;
    default:
      if (cxt-&amp;gt;plen &amp;gt;= cxt-&amp;gt;pcapa) {
        cxt-&amp;gt;pcapa *= 2;
        cxt-&amp;gt;pool = pic_realloc(pic, cxt-&amp;gt;pool, sizeof(pic_value) * cxt-&amp;gt;pcapa);
      }
      pidx = (int)cxt-&amp;gt;plen++;
      cxt-&amp;gt;pool[pidx] = obj;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_PUSHCONST;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = pidx;
      cxt-&amp;gt;clen++;
      return;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リテラルや定数をPUSHする命令を吐いてますね。&lt;/p&gt;

&lt;h3 id=&#34;ref系:693fca136e4ca5c28a91dc5895343393&#34;&gt;REF系&lt;/h3&gt;

&lt;p&gt;local、captureはirep構造体についてるのpoolを参照します。globalはVMのシンボルテーブルから直接引きます。因みにpicrinのシンボルはただのintです。&lt;/p&gt;

&lt;p&gt;captureは上位のスコープで既に出てきた変数を参照するだけなので「n個上位のm番目のcaptured変数」と指定するだけなので簡単ですが、localはarg、普通のlocal、下位スコープにcaptureされたlocal、の3つに分けて置いているので少し面倒です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  if (sym == state-&amp;gt;sGREF) {
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_GREF;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = pic_sym(pic_list_ref(pic, obj, 1));
    cxt-&amp;gt;clen++;
    return;
  } else if (sym == state-&amp;gt;sCREF) {
    pic_sym name;
    int depth;

    depth = pic_int(pic_list_ref(pic, obj, 1));
    name  = pic_sym(pic_list_ref(pic, obj, 2));
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_CREF;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.r.depth = depth;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.r.idx = index_capture(state, name, depth);
    cxt-&amp;gt;clen++;
    return;
  } else if (sym == state-&amp;gt;sLREF) {
    pic_sym name;
    int i;

    name = pic_sym(pic_list_ref(pic, obj, 1));
    if ((i = index_capture(state, name, 0)) != -1) {
      cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_LREF;
      cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = i + (int)xv_size(&amp;amp;cxt-&amp;gt;args) + (int)xv_size(&amp;amp;cxt-&amp;gt;locals) + 1;
      cxt-&amp;gt;clen++;
      return;
    }
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_LREF;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = index_local(state, name);
    cxt-&amp;gt;clen++;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みにset系もほぼ同じようなコードです。&lt;/p&gt;

&lt;h3 id=&#34;lambda-2:693fca136e4ca5c28a91dc5895343393&#34;&gt;lambda&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sLAMBDA) {
    int k;

    if (cxt-&amp;gt;ilen &amp;gt;= cxt-&amp;gt;icapa) {
      cxt-&amp;gt;icapa *= 2;
      cxt-&amp;gt;irep = pic_realloc(pic, cxt-&amp;gt;irep, sizeof(struct pic_irep *) * cxt-&amp;gt;icapa);
    }
    k = (int)cxt-&amp;gt;ilen++;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_LAMBDA;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = k;
    cxt-&amp;gt;clen++;

    cxt-&amp;gt;irep[k] = codegen_lambda(state, obj);
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;codegen_lambda&lt;/code&gt;に投げているのでこの部分は簡単です。irepプールにコードを置いてそれを参照する命令を吐くだけ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;codegen_lambda&lt;/code&gt;はというとそこまで長くなくて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static struct pic_irep *
codegen_lambda(codegen_state *state, pic_value obj)
{
  pic_state *pic = state-&amp;gt;pic;
  pic_value name, args, locals, closes, body;
  bool varg;

  name = pic_list_ref(pic, obj, 1);
  args = pic_list_ref(pic, obj, 2);
  locals = pic_list_ref(pic, obj, 3);
  varg = pic_true_p(pic_list_ref(pic, obj, 4));
  closes = pic_list_ref(pic, obj, 5);
  body = pic_list_ref(pic, obj, 6);

  /* inner environment */
  push_codegen_context(state, name, args, locals, varg, closes);
  {
    /* body */
    codegen(state, body);
  }
  return pop_codegen_context(state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;単純に本体に対して&lt;code&gt;codegen&lt;/code&gt;を呼んで出来た命令を取り出してるだけです。&lt;/p&gt;

&lt;h3 id=&#34;if:693fca136e4ca5c28a91dc5895343393&#34;&gt;if&lt;/h3&gt;

&lt;p&gt;schemeはほとんどの制御を継続に任せているのでなんとjmp命令を吐くのはifだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == pic-&amp;gt;sIF) {
    int s, t;

    codegen(state, pic_list_ref(pic, obj, 1));

    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_JMPIF;
    s = (int)cxt-&amp;gt;clen++;

    /* if false branch */
    codegen(state, pic_list_ref(pic, obj, 3));
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = OP_JMP;
    t = (int)cxt-&amp;gt;clen++;

    cxt-&amp;gt;code[s].u.i = (int)cxt-&amp;gt;clen - s;

    /* if true branch */
    codegen(state, pic_list_ref(pic, obj, 2));
    cxt-&amp;gt;code[t].u.i = (int)cxt-&amp;gt;clen - t;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;call:693fca136e4ca5c28a91dc5895343393&#34;&gt;call&lt;/h3&gt;

&lt;p&gt;思ったより短いです。単純に引数を評価する命令を吐いたあと引数の数を指定して呼ぶだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  else if (sym == state-&amp;gt;sCALL || sym == state-&amp;gt;sTAILCALL) {
    int len = (int)pic_length(pic, obj);
    pic_value elt;

    pic_for_each (elt, pic_cdr(pic, obj)) {
      codegen(state, elt);
    }
    cxt-&amp;gt;code[cxt-&amp;gt;clen].insn = (sym == state-&amp;gt;sCALL) ? OP_CALL : OP_TAILCALL;
    cxt-&amp;gt;code[cxt-&amp;gt;clen].u.i = len - 1;
    cxt-&amp;gt;clen++;
    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;最後に:693fca136e4ca5c28a91dc5895343393&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;これを書くのに半日掛かりましたがちゃんとコンパイルプロセスを理解して問題を洗い出すことが出来ました。良かった。&lt;/p&gt;

&lt;p&gt;今のところ中間表現までS式なのでS式操作に長けたSchemeでコンパイラ書けないかなとか考えてますが現状マクロ展開で副作用があるので厳しいですね。&lt;/p&gt;

&lt;p&gt;因みに気付いた方もいらっしゃるかと思いますが今のpicrinは最適化をtco以外は行っていません。行うとしたら&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;マクロ展開後にコンパイラマクロ展開を挟む&lt;/li&gt;
&lt;li&gt;中間表現から一旦ssa形式の第二中間表現に落して定数伝播や畳み込みなどの一般的な最適化を行なう&lt;/li&gt;
&lt;li&gt;生成されたvm命令に対して覗き穴最適化を行なう&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;あたりかなと思います。1. は楽しそうですけど普通のマクロ展開のバグとか問題に悩んでる今入れるべきではないですし、2. は効果高いですしjit化の布石にもなりますが実装コストが高いのでwasabiz次第かなといったところ、3. は今どの程度非効率な命令が吐かれてるのか分からないので効果が見えにくいですね。&lt;/p&gt;

&lt;p&gt;いずれにせよ最適化は仕様準拠してからにしますか。&lt;/p&gt;

&lt;p&gt;何か質問や突っ込みがあれば@blackenedgoldまで。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>実用Common Lispを読んだ</title>
      <link>http://keens.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda</link>
      <pubDate>Sun, 14 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda</guid>
      <description>&lt;p&gt;以前&lt;a href=&#34;http://KeenS.github.io/blog/2014/10/20/lisp-ja/&#34;&gt;Common Lispの勉強の手引の記事&lt;/a&gt;を書いたときに実用Common Lispの名を挙げたが読んだことはなかった。&lt;/p&gt;

&lt;p&gt;一応名前を挙げた責任として読んでみた。&lt;/p&gt;

&lt;p&gt;読んだとは言ってもソースはざっくりしか見てないし、演習には目もくれてないので「一通り目を通した」程度。
買った本は逃げないのだし一回で理解する必要はない。最初に一通り内容を掴んで主張を理解してから、あとで気になった時につぶさに読むのが私の読み方。&lt;/p&gt;

&lt;p&gt;最初の感想を言うと、古い。Common Lispもcltl2とANSI両方に配慮されて書かれているし、紹介されているAIの事例も1970~1980年代のもの。
古典といった感じ。ただし、その時代はCommon LispとAIの最盛期なのでこの本を読めばCommon LispがAIで名を馳せた理由が良く分かる。&lt;/p&gt;

&lt;p&gt;Common Lispの内容は初級程度。まえがきにもあるようにプログラマとしては中級だがLispは初心者レベルの人向に書かれている。基本的なところを押えたらあとはどんどん進んでいく。
プログラミングの経験があればそれでも問題ない筈。心配ならWeb上にいくらでもあるチュートリアルをこなせば良い。&lt;/p&gt;

&lt;p&gt;ライブラリなどに関しては本の中で完結しているので良く言えば1から10まで教えてくれる。悪く言えば最近のCommon Lispの動向は全く分からない。その意味では実践入門ではなく学習図書。陳腐化はしない。&lt;/p&gt;

&lt;p&gt;AIについては、やはり古い。今では手法が確立されてAIの分野とは扱われないものも含まれている。ただし、これは意図したものなのかもしれない。
古いものというのは単純だ。最初に2部で単純なものを通して「肩馴らし」をしてから3部で手駒を増やして4部で踏み込んだ内容に入る。&lt;/p&gt;

&lt;p&gt;また、AIの分野としては扱われていなものも含む、ということはこの本が情報科学の広い範囲をカバーする、ということでもある。900ベージは伊達じゃない。量もあればバラエティもある。&lt;/p&gt;

&lt;p&gt;現実にある様々な難解な問題をCommon Lispという強力な道具で快刀乱麻解決していく。ソフトウェア開発手法を学びながらCommon Lispの強力さを思い知るための一冊。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>割と処理系ポータブルなCommon Lisp実行可能ファイルを作る</title>
      <link>http://keens.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru</link>
      <pubDate>Mon, 08 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru</guid>
      <description>&lt;p&gt;κeenです。Lisp Advent Calendarはもう枠埋まっちゃったので普通にブログで。&lt;/p&gt;

&lt;p&gt;コマンドラインから実行可能なLispファイルをそれなりに多くの処理系で動くように作る話。&lt;/p&gt;

&lt;p&gt;この話はCIMの生い立ちとも関連するんだけどシェルからLispを使いたいときは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env sbcl --script

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんて書いてた人も多いんじゃないかと思うんだけどこれは色々問題がある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;envは環境に依っては/usr/local/bin/envだったりする&lt;/li&gt;
&lt;li&gt;envは環境に依っては複数引数を取れない。&amp;rdquo;sbcl &amp;ndash;script&amp;rdquo;という名前のファイルを捜しにいく&lt;/li&gt;
&lt;li&gt;sbclでしか動かない&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;この問題の扱いは一応解決策がある&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh

#|
exec sbcl --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
|#

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3行目の&lt;code&gt;#|&lt;/code&gt;がシェルのコメントでありLispのブロックコメントであるのがポイント。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;シェルは&lt;code&gt;#!/bin/sh&lt;/code&gt;を見てシェルスクリプトとして実行する&lt;/li&gt;
&lt;li&gt;1,3行目はコメントなのでシェルは無視&lt;/li&gt;
&lt;li&gt;4行目でsbclにそのファイルを引数として与えてexecする。execしたあとはシェルには戻らないのでその後何が書いてあっても構わない&lt;/li&gt;
&lt;li&gt;sbclを&lt;code&gt;--script&lt;/code&gt;付きで読んでるので1行目の&lt;code&gt;#!&lt;/code&gt;で始まる行は無視する&lt;/li&gt;
&lt;li&gt;3~5行目はブロックコメントなのでsbclは無視&lt;/li&gt;
&lt;li&gt;それ以降がLispとして実行される&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;というカラクリになっている。こういうのをピジン言語っていうんだけ？&lt;/p&gt;

&lt;p&gt;まあいいや。&lt;/p&gt;

&lt;p&gt;ところでこのブロックコメントの中にはシェルスクリプト書き放題だよね？そのシェルスクリプト内でどのLisp使うか決めたらポータブルになりそうじゃない？&lt;/p&gt;

&lt;p&gt;こういうのはどう？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;#!/bin/sh

#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
|#

(write-line (lisp-implementation-type))
(force-output)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cclとabclは1行目のシェバンを読み飛ばせなかった&amp;amp;評価結果をエコーバックしない方法が見当らなかったからパス。CMUCLは自分の環境で動かないから検証出来てない。&lt;/p&gt;

&lt;p&gt;これでポータブルに実行は可能。コマンドライン引数の扱いとかはライブラリを頼ってくれ。因みにCIMでは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  #+allegro  (cdr (system:command-line-arguments))
  #+sbcl (do*  ((var sb-ext:*posix-argv* (cdr list))
                (list var var))
               ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+clisp ext:*args*
  #+ecl (do*  ((var (si:command-args) (cdr list))
               (list var var))
              ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+abcl extensions:*command-line-argument-list*
  #+gcl (do*  ((var si::*command-args* (cdr list))
               (list var var))
              ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+cmu ext:*command-line-words*
  #+ccl ccl:*unprocessed-command-line-arguments*
  #+mkcl (do*  ((var (si:command-args) (cdr list))
               (list var var))
              ((string= (car list) &amp;quot;--&amp;quot;) (return (cdr list))))
  #+lispworks system:*line-arguments-list*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としている。参考までに。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>H2Oにpicrinを溶かす</title>
      <link>http://keens.github.io/blog/2014/12/07/h2onipicrinworong-kasu</link>
      <pubDate>Sun, 07 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/07/h2onipicrinworong-kasu</guid>
      <description>

&lt;p&gt;このエントリーは&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/advent-calendar/2014/lisp&#34;&gt;Lisp Advent Calendar&lt;/a&gt; 7日目&lt;br /&gt;
兼&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/advent-calendar/2014/h2o&#34;&gt;H2O Advent Calendar&lt;/a&gt; 7日目&lt;br /&gt;
の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。タイトルの通りです。&lt;/p&gt;

&lt;h1 id=&#34;h2oとは:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;H2Oとは&lt;/h1&gt;

&lt;p&gt;水。&lt;/p&gt;

&lt;h1 id=&#34;picrinとは:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;picrinとは&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E3%83%94%E3%82%AF%E3%83%AA%E3%83%B3%E9%85%B8&#34;&gt;Wikipedia&lt;/a&gt;にあるように、フェノールのトリニトロ化合物で、水溶性があります。&lt;/p&gt;

&lt;h1 id=&#34;ではなくて:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;ではなくて&lt;/h1&gt;

&lt;p&gt;H2OはHTTP1, HTTP2, WebsocketをサポートするNginXより速いHTTPサーバです。&lt;a href=&#34;https://github.com/h2o/h2o&#34;&gt;Github&lt;/a&gt;で開発されています。開発者は@kazuhoさん。&lt;/p&gt;

&lt;p&gt;picrinは「速い、軽い、高機能」を目指して作られているScheme処理系です。&lt;a href=&#34;https://github.com/picrin-scheme/picrin&#34;&gt;Github&lt;/a&gt;で開発されています。開発者は@wasabizさん。&lt;/p&gt;

&lt;h1 id=&#34;混ぜる:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;混ぜる&lt;/h1&gt;

&lt;p&gt;picrinのように組込み向けで開発されている処理系は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;picrinからH2Oを使えるようにする&lt;/li&gt;
&lt;li&gt;H2Oにpicrinを埋め込む&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と、2種類考えられますが、今回は後者です。H2Oにpicrinを溶かしてる感じしますね。&lt;/p&gt;

&lt;p&gt;まあ、Apatch HTTPDやNginX宜しくmod_picrinを作れば済むでしょう。&lt;/p&gt;

&lt;h1 id=&#34;絶望:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;絶望&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; モジュラーにできるようにはしてるけど、まだsoをロードする仕組みはないです。というか、APIがまだunstableだし&lt;/p&gt;&amp;mdash; Kazuho Oku (@kazuho) &lt;a href=&#34;https://twitter.com/kazuho/status/540692011003559936&#34;&gt;2014, 12月 5&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;つらい&lt;/p&gt;

&lt;h1 id=&#34;solシステムの導入:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;solシステムの導入&lt;/h1&gt;

&lt;p&gt;mod_xxxにしようと思ったんですけど水だし溶液ってことでsol_xxxにします。&lt;/p&gt;

&lt;p&gt;H2Oにこんな感じのパッチ当てて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/src/main.c b/src/main.c
index 7fc4680..57804a6 100644
--- a/src/main.c
+++ b/src/main.c
@@ -30,6 +30,7 @@
 #include &amp;lt;signal.h&amp;gt;
 #include &amp;lt;stdio.h&amp;gt;
 #include &amp;lt;unistd.h&amp;gt;
+#include &amp;lt;dlfcn.h&amp;gt;
 #include &amp;lt;sys/stat.h&amp;gt;
 #include &amp;lt;sys/socket.h&amp;gt;
 #include &amp;lt;sys/types.h&amp;gt;
@@ -76,6 +77,8 @@ struct config_t {
     } state;
 };
 
+typedef int(*sol_init_fn)(h2o_configurator_command_t *, h2o_configurator_context_t *, const char *, yoml_t *);
+
 static unsigned long openssl_thread_id_callback(void)
 {
     return (unsigned long)pthread_self();
@@ -381,6 +384,43 @@ static int on_config_num_threads(h2o_configurator_command_t *cmd, h2o_configurat
     return h2o_config_scanf(cmd, config_file, config_node, &amp;quot;%u&amp;quot;, &amp;amp;conf-&amp;gt;num_threads);
 }
 
+static int on_config_use(h2o_configurator_command_t *cmd, h2o_configurator_context_t *ctx, const char *config_file, yoml_t *config_node)
+{
+  /* struct config_t *conf = H2O_STRUCT_FROM_MEMBER(struct config_t, global_config, ctx-&amp;gt;globalconf); */
+  char *sol_name;
+  sol_init_fn init_fn;
+  void *handle;
+
+  /* fetch solution name */
+  switch (config_node-&amp;gt;type) {
+  case YOML_TYPE_SCALAR:
+    sol_name = config_node-&amp;gt;data.scalar;
+    break;
+  default:
+    h2o_config_print_error(cmd, config_file, config_node, &amp;quot;value must be a string or a mapping (with keys: `port` and optionally `host`)&amp;quot;);
+    return -1;
+  }
+
+  char dl_name[strlen(&amp;quot;sol_.so&amp;quot;) + strlen(sol_name) + 1];
+  char init_fn_name[strlen(&amp;quot;init_sol_&amp;quot;) + strlen(sol_name) + 1];
+
+  sprintf(dl_name, &amp;quot;./sol_%s.so&amp;quot;, sol_name);
+  sprintf(init_fn_name, &amp;quot;init_sol_%s&amp;quot;, sol_name);
+  handle = dlopen(dl_name, RTLD_LAZY);
+  if (! handle){
+    h2o_config_print_error(cmd, config_file, config_node, &amp;quot;cannot load the solution&amp;quot;);
+    return -1;
+  }
+
+  init_fn = dlsym(handle, init_fn_name);
+  if(dlerror()){
+    h2o_config_print_error(cmd, config_file, config_node, &amp;quot;cannot find the initialize function&amp;quot;);
+    return -1;
+  }
+  return (*init_fn)(cmd, ctx, config_file, config_node);
+
+}
+
 static void usage_print_directives(h2o_globalconf_t *conf)
 {
     h2o_linklist_t *node;
@@ -606,6 +646,10 @@ int main(int argc, char **argv)
             c, &amp;quot;num-threads&amp;quot;, H2O_CONFIGURATOR_FLAG_GLOBAL,
             on_config_num_threads,
             &amp;quot;number of worker threads (default: 1)&amp;quot;);
+        h2o_config_define_command(
+            c, &amp;quot;use&amp;quot;, H2O_CONFIGURATOR_FLAG_GLOBAL,
+            on_config_use,
+            &amp;quot;use the solution&amp;quot;);
     }
 
     h2o_access_log_register_configurator(&amp;amp;config.global_config);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じのソリューション用意して&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;quot;picrin.h&amp;quot;
#include &amp;quot;picrin/pair.h&amp;quot;
#include &amp;quot;picrin/string.h&amp;quot;
#include &amp;quot;picrin/error.h&amp;quot;
#include &amp;quot;h2o.h&amp;quot;

pic_state *pic;
struct pic_lib *PICRIN_BASE;


void pic_init_contrib(pic_state *);
void pic_load_piclib(pic_state *);

static pic_value
pic_features(pic_state *pic)
{
  pic_get_args(pic, &amp;quot;&amp;quot;);

  return pic-&amp;gt;features;
}

static pic_value
pic_libraries(pic_state *pic)
{
  pic_value libs = pic_nil_value(), lib;

  pic_get_args(pic, &amp;quot;&amp;quot;);

  pic_for_each (lib, pic-&amp;gt;libs) {
    libs = pic_cons(pic, pic_car(pic, lib), libs);
  }

  return libs;
}

void
pic_init_picrin(pic_state *pic)
{
  const char *scheme =
    &amp;quot;(import (scheme base)&amp;quot;
    &amp;quot;        (scheme write))&amp;quot;
    &amp;quot;(define-syntax call-with-output-to-string&amp;quot;
    &amp;quot;  (syntax-rules ()&amp;quot;
    &amp;quot;    ((_ proc)&amp;quot;
    &amp;quot;     (let ((s (open-output-string)))&amp;quot;
    &amp;quot;       (proc s)&amp;quot;
    &amp;quot;       (get-output-string s)))))&amp;quot;
    &amp;quot;(define (-&amp;gt;string e)&amp;quot;
    &amp;quot;  (call-with-output-to-string&amp;quot;
    &amp;quot;   (lambda (s)&amp;quot;
    &amp;quot;     (display e s))))&amp;quot;;


  pic_add_feature(pic, &amp;quot;r7rs&amp;quot;);

  pic_deflibrary (pic, &amp;quot;(picrin library)&amp;quot;) {
    pic_defun(pic, &amp;quot;libraries&amp;quot;, pic_libraries);
  }

  pic_deflibrary (pic, &amp;quot;(scheme base)&amp;quot;) {
    pic_defun(pic, &amp;quot;features&amp;quot;, pic_features);

    pic_init_contrib(pic);
    pic_load_piclib(pic);
  }
  pic_deflibrary (pic, &amp;quot;(picrin base)&amp;quot;) {
    pic_load_cstr(pic, scheme);
  }
}

const char *
pic_eval_cstr_into_cstr(pic_state *pic, const char *input)
{
  pic_value v;


  v = pic_read_cstr(pic, input);
  v = pic_eval(pic, v, PICRIN_BASE);
  v = pic_funcall(pic, PICRIN_BASE, &amp;quot;-&amp;gt;string&amp;quot;, pic_list1(pic, v));
  return pic_str_cstr(pic_str_ptr(v));
}



int
on_picrin(h2o_configurator_command_t *cmd, h2o_configurator_context_t *ctx, const char *config_file, yoml_t *config_node)
{
  const char *sexp;
  
  switch (config_node-&amp;gt;type) {
  case YOML_TYPE_SCALAR:
    sexp = config_node-&amp;gt;data.scalar;
    break;
  default:
    h2o_config_print_error(cmd, config_file, config_node, &amp;quot;value must be a string&amp;quot;);
    return -1;
  }

  pic_try{
    puts(pic_eval_cstr_into_cstr(pic, sexp));
  }
  pic_catch{
    pic_print_backtrace(pic);
    return -1;
  }
  return 0;

}


int
init_sol_picrin(h2o_configurator_command_t *cmd, h2o_configurator_context_t *ctx, const char *config_file, yoml_t *config_node)
{


  h2o_configurator_t *c = cmd-&amp;gt;configurator;

  pic = pic_open(0, NULL, NULL);

  pic_init_picrin(pic);

  PICRIN_BASE = pic_find_library(pic, pic_read_cstr(pic, &amp;quot;(picrin base)&amp;quot;));

  h2o_config_define_command(
      c, &amp;quot;picrin&amp;quot;, H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
      on_picrin,
      &amp;quot;run picrin&amp;quot;);


  return 0;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んでコンフィグは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# to find out the configuration commands, run: h2o --help

use: picrin
listen:
  port:
listen:
  port: 8081
  ssl:
    certificate-file: examples/h2o/server.crt
    key-file: examples/h2o/server.key
picrin: &amp;quot;(string-append \&amp;quot;Hello, \&amp;quot; \&amp;quot;World\&amp;quot;)&amp;quot;
hosts:
  default:
    paths:
      /:
        file.dir: examples/doc_root
    access-log: /dev/stdout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして魔法のコマンドを叩いて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp ~/compile/picrin/src/{init_contrib.c,load_piclib.c} ./
$ gcc -c sol_picrin.c -std=c99   -o sol_picrin.o -I ~/compile/picrin/extlib/benz/include -I ~/compile/h2o/include -I ~/compile/h2o/deps/picohttpparser -I ~/compile/h2o/deps/yoml -DH2O_USE_LIBUV=0 -fPIC
$ gcc sol_picrin.o load_piclib.o init_contrib.o -L ~/compile/picrin/build/lib/ -l picrin -fPIC -shared -o sol_picrin.so
$ cp sol_picrin.so ~/compile/h2o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/compile/h2o
$ ./h2o --conf example/h2o/h2o.conf
Hello, Wold
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ヤッタ！&lt;/p&gt;

&lt;h1 id=&#34;標準出力かよ:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;標準出力かよ&lt;/h1&gt;

&lt;p&gt;ううっ。ごめんなさい。&lt;/p&gt;

&lt;h1 id=&#34;で-httpレスポンス版は:690b2abdf7ac2fac599d62c94dd0ea87&#34;&gt;で、HTTPレスポンス版は？&lt;/h1&gt;

&lt;p&gt;ごめんなさい、まだです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;file.c&lt;/code&gt;をベースにして&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    paths:
      /:
        picrin.exp: &amp;quot;(string-append \&amp;quot;Hello, \&amp;quot; \&amp;quot;World\&amp;quot;)&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とかしたかったんですけど間に合いませんでした。&lt;/p&gt;

&lt;p&gt;ソリューションなりモジュールなりのシステムが出来たらまたトライします&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>claspがアップデートされたよ</title>
      <link>http://keens.github.io/blog/2014/12/06/claspgaatupudetosaretayo</link>
      <pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/06/claspgaatupudetosaretayo</guid>
      <description>

&lt;p&gt;このエントリーは&lt;a href=&#34;http://qiita.com/advent-calendar/2014/lisp&#34;&gt;Lisp Advent Calendar 2014&lt;/a&gt;6日目の記事です。&lt;br /&gt;
前: nobkzさんで &lt;a href=&#34;http://qiita.com/nobkz/items/2be2b6806237d8ea6e21&#34;&gt;lfe - (lisp (flavored (erlang)))について基本その1 - Qiita&lt;/a&gt;&lt;br /&gt;
後: 私で &lt;a href=&#34;http://KeenS.github.io/blog/2014/12/07/h2onipicrinworong-kasu/&#34;&gt;H2Oにpicrinを溶かす | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;κeenです。アドベントカレンダーめっちゃ書いてますね。&lt;/p&gt;

&lt;h1 id=&#34;clasp:77e635c8bfc030775f1dbb8efa5b9863&#34;&gt;Clasp!&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/drmeister/clasp&#34;&gt;clasp&lt;/a&gt;のmasterに色々マージされました。リリースノートには、&lt;/p&gt;

&lt;p&gt;&lt;quote&gt;&lt;pre&gt;
Clasp version 0.11
* Added ASDF support.
This is still alpha. Compile the ASDF module using (core:compile-asdf).
After that you can load the module using (load &amp;ldquo;sys:kernel;asdf;build;asdf.bundle&amp;rdquo;).
It takes between 15-30 seconds to load (this is why I&amp;rsquo;m integrating Cleavir).
* Added the :CLASP &lt;em&gt;feature&lt;/em&gt; and removed the :ECL &lt;em&gt;feature&lt;/em&gt;.
Clasp will continue to mimic the underlying ECL functionality so that
Common Lisp code that supports ECL can be made to support Clasp by converting
#+ecl to #+(or ecl clasp) and #-ecl to #-(or ecl clasp)
* Added code to generate object files directly from Clasp.
The LLVM bitcode compiler &amp;ldquo;llc&amp;rdquo; no longer needs to be in the PATH
for Clasp to generate object files from Common Lisp source.
The &amp;ldquo;ld&amp;rdquo; linker does need to be accessible.
&lt;/pre&gt;&lt;/quote&gt;&lt;/p&gt;

&lt;p&gt;とあります。ASDFが使える！リリースノートには書いてませんがslimeサポートもmasterにコミットされてます。あとコミット読んだら最適化もされてるような…。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://KeenS.github.io/slide/clasp.html&#34;&gt;以前&lt;/a&gt;二十数秒掛かっていた&lt;code&gt;(fib 29)&lt;/code&gt;ですが、今回はなんと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 ... loading image... it takes a few seconds
Top level.
&amp;gt; (load &amp;quot;fib.lisp&amp;quot;)
1346269
real time : 34.294 secs
run time  : 38.844 secs
T
&amp;gt; (compile-file &amp;quot;fib.lisp&amp;quot;)

#P&amp;quot;/home/kim/Lisp/fib.bc&amp;quot;
NIL
NIL
&amp;gt; (load &amp;quot;fib.bc&amp;quot;)
1346269
real time : 21.355 secs
run time  : 25.785 secs
T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うわぁ。遅くなってる。&lt;/p&gt;

&lt;p&gt;因みに.bcファイルはLLVMの中間ファイルなのでClaspとは独立に&lt;code&gt;opt -f -O3 fib.bc &amp;gt; fib.opt.bc&lt;/code&gt;で最適化出来ます。それをやると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ opt -f -O3 fib.bc &amp;gt; fib.opt.bc
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 ... loading image... it takes a few seconds
Top level.
&amp;gt; (load &amp;quot;fib.opt.bc&amp;quot;)
1346269
real time : 34.981 secs
run time  : 37.986 secs
T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あれ？遅くなった。&lt;/p&gt;

&lt;p&gt;mpsはまだコンパイル中だから待ってね&lt;/p&gt;

&lt;h1 id=&#34;asdfを使ってみる:77e635c8bfc030775f1dbb8efa5b9863&#34;&gt;ASDFを使ってみる&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 ... loading image... it takes a few seconds
Top level.
&amp;gt; (time (core:compile-asdf))
zsh: segmentation fault (core dumped)  /usr/local/clasp/bin/clasp_boehm_o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。解散。因みに50分くらいは動いてた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VOPで遊ぶ</title>
      <link>http://keens.github.io/blog/2014/12/02/vopdeyou-bu</link>
      <pubDate>Tue, 02 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/12/02/vopdeyou-bu</guid>
      <description>

&lt;p&gt;(:meta&lt;br /&gt;
 ((:this &amp;ldquo;&lt;a href=&#34;http://qiita.com/advent-calendar/2014/lisp&#34;&gt;Lisp Advent Calendar 2014&lt;/a&gt;の3日目の記事&amp;rdquo;)&lt;br /&gt;
  (:prev (:author &amp;ldquo;tk_riple&amp;rdquo; :title &lt;a href=&#34;http://compassoftime.blogspot.jp/2014/12/r7rs.html&#34;&gt;&amp;ldquo;時の羅針盤＠blog: R7RSポータブルライブラリを書く際の落とし穴&amp;rdquo;&lt;/a&gt;))&lt;br /&gt;
  (:next (:author &amp;ldquo;nobkz&amp;rdquo; :tite &amp;ldquo;&lt;a href=&#34;http://qiita.com/nobkz/items/68ee2adbc13caf3eec6f&#34;&gt;Shenの基礎その1 基本的な型 - Qiita&lt;/a&gt;&amp;rdquo;))))&lt;/p&gt;

&lt;p&gt;κeenです。さっきまでVOPで遊んでたので当初の予定を変更してVOPの話をします。&lt;/p&gt;

&lt;h1 id=&#34;vopとは何か:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;VOPとは何か&lt;/h1&gt;

&lt;p&gt;SBCLやCMU CLで使われているネイティブコードを吐くための機構、要はインラインアセンブラです。&lt;/p&gt;

&lt;h1 id=&#34;vopとはどんなものか:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;VOPとはどんなものか&lt;/h1&gt;

&lt;p&gt;とりあえずコードをば。x86-64用です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package :cl-user)
(defpackage vop-sample
  (:use :cl :sb-ext :sb-c))
(in-package :vop-sample)

(defknown add (fixnum fixnum)          ; addのftypeを宣言
    fixnum
    (movable                            ; 副作用がない
     flushable                          ; デッドコードとして除去してよい
     foldable                           ; 定数畳み込みをしてよい
     always-translatable)               ; 必ずアセンブラコードになる
  :overwrite-fndb-silently t)           ; 関数上書きのエラーを出さない


(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::add)          ; VOP名
  (:translate vop-sample::add)         ; 関数名
  (:policy :fast-safe)                  ; declare optimize的な
  (:args (x :scs (signed-reg))          ; 引数宣言。後述
         (y :scs (signed-reg)))
  (:arg-types fixnum fixnum)            ; 引数の型宣言
  (:results (r :scs (signed-reg)))      ; 返り値宣言。後述
  (:result-types fixnum)                ; 返り値の型宣言
  (:generator 4                         ; 翻訳するときのコスト
              (move r x)                ; 返り値レジスタにxを移動
              (inst add r y)))          ; 返り値レジスタにyを足し込む
(in-package :vop-sample)

(defun add (x y)                        ; 安全なバージョンでラップする
  (add x y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとおまじないが多いですね。&lt;/p&gt;

&lt;p&gt;すこし解説すると引数は基本レジスタ渡しで、レジスタが足りなければスタックも使います。で、レジスタやスタックの値には型があります。それがストレージクラス(sc)です。この場合、x、y、rは&lt;code&gt;signed-reg&lt;/code&gt;と宣言されてますね。符号付きレジスタです。&lt;code&gt;:scs&lt;/code&gt;の最後のsは複数形のsです。今回は1つしか指定してませんが複数指定することも可能なのです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;move&lt;/code&gt;というのはアセンブラ命令ではなく、マクロかなんかです（適当）。VOPなのかな？どのストレージクラスからどのストレージクラスに移動するかを認知して適切な命令を吐きます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inst&lt;/code&gt;が付いてるのがアセンブラですね。&lt;/p&gt;

&lt;p&gt;このコード、xとrが等しいときに最適化出来るのですがそれはまあおいといて、こいつをディスアセンブルしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VOP-SAMPLE&amp;gt; (disassemble #&#39;add)
; disassembly for ADD
; Size: 43 bytes. Origin: #x1005C26416
; 16:       488BD3           MOV RDX, RBX                     ; no-arg-parsing entry point
; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
; 2E:       CC0A             BREAK 10                         ; error trap
; 30:       02               BYTE #X02
; 31:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 32:       9A               BYTE #X9A                        ; RCX
; 33:       CC0A             BREAK 10                         ; error trap
; 35:       04               BYTE #X04
; 36:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 37:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 3A:       CC0A             BREAK 10                         ; error trap
; 3C:       04               BYTE #X04
; 3D:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 3E:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要な部分はここです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ADD&lt;/code&gt;の他に無駄な命令がいくつかありますね。&lt;/p&gt;

&lt;p&gt;SBCLはintの下位1bitをGCのときのタグとして使ってるのでアセンブラに渡す前に算術右シフト(&lt;code&gt;SAR&lt;/code&gt;)して渡してます。
そして返るときはまた左シフト(&lt;code&gt;SHL&lt;/code&gt;)してます。&lt;/p&gt;

&lt;p&gt;その後の&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;は関数から返るときのイディオム(スタックポインタを復元してフラグをクリアして呼び出し元に戻る)です。&lt;/p&gt;

&lt;p&gt;余談ですがLispマシンなどのタグマシンは下位ビットにあるタグを無視して計算出来るのでシフトが不要になります。なので速いんですね。&lt;/p&gt;

&lt;h1 id=&#34;シフトをなくす:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;シフトをなくす&lt;/h1&gt;

&lt;p&gt;さっきは&lt;code&gt;signed-reg&lt;/code&gt;を指定しました。つまり「（アセンブラの）intをくれ」と要求した訳です。
intの下位1bitは0なので足し算する分には別にシフトされなくても問題ありませんよね。シフトを殺しましょう。&lt;/p&gt;

&lt;p&gt;さっきのコードの下にこれを足します。&lt;code&gt;add&lt;/code&gt;は再定義しないと反映されないようでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::add/v2)        ; vop名は異なる
  (:translate vop-sample::add)          ; 関数名は同じ
  (:policy :fast-safe)
  (:args (x :scs (any-reg))             ; any-regになってる
         (y :scs (any-reg)))            ; any-regになってる
  (:arg-types fixnum fixnum)
  (:results (r :scs (any-reg)))         ; any-regになってる
  (:result-types fixnum)
  (:generator 3                         ; コストをさっきより低くすると優先して使ってくれる
              (move r x)
              (inst add r y)))

(in-package :vop-sample)

(defun add (x y)
  (add x y))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んで、ディスアセンブルしてみると&lt;/p&gt;

&lt;p&gt;VOP-SAMPLE&amp;gt; (disassemble #&amp;lsquo;add)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; disassembly for ADD
; Size: 31 bytes. Origin: #x1004C2AB83
; 83:       488BD1           MOV RDX, RCX                     ; no-arg-parsing entry point
; 86:       4801FA           ADD RDX, RDI
; 89:       488BE5           MOV RSP, RBP
; 8C:       F8               CLC
; 8D:       5D               POP RBP
; 8E:       C3               RET
; 8F:       CC0A             BREAK 10                         ; error trap
; 91:       02               BYTE #X02
; 92:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 93:       9A               BYTE #X9A                        ; RCX
; 94:       CC0A             BREAK 10                         ; error trap
; 96:       04               BYTE #X04
; 97:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 98:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 9B:       CC0A             BREAK 10                         ; error trap
; 9D:       04               BYTE #X04
; 9E:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 9F:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。見事にSARとSHLが消えましたね。&lt;/p&gt;

&lt;h1 id=&#34;もう少し複雑な型を扱う:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;もう少し複雑な型を扱う&lt;/h1&gt;

&lt;p&gt;アセンブラですし&lt;code&gt;(simple-array (unsigned-byte 8) (*))&lt;/code&gt;(以下octets)を扱いたいですよね。とりあえず難しいことは考えずにoctetsの0番目の要素にアクセスしてみましょう。とはいっても&lt;code&gt;simple-array&lt;/code&gt;は長さや要素の型の情報も持っていることが予想されるので少しデータを読み飛ばさないといけませんね。&lt;/p&gt;

&lt;p&gt;その辺の計算が分からなかったのでsbclのソースからそれっぽいものを参考にしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defknown access-simple-array-0 ((simple-array (unsigned-byte 8) (*)))
    (unsigned-byte 8)
    (movable flushable always-translatable)
  :overwrite-fndb-silently t)
(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::access-simple-array-0)
  (:translate vop-sample::access-simple-array-0)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg)))
  (:arg-types *)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4
              (inst movzx r 
               (make-ea :byte :base x
                        :disp (- (* vector-data-offset n-word-bytes)
                               other-pointer-lowtag)))))

(in-package :vop-sample)
(defvar *octets* (make-array 4
                             :element-type &#39;(unsigned-byte 8)
                             :initial-contents &#39;(10 11 12 13)))

(defun access-simple-array-0 (x)
  (access-simple-array-0 x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じになります。境界チェックとかはやってませんが許して下さい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;descriptor-reg&lt;/code&gt;というのがポインタが入ってるレジスタっぽいです。&lt;code&gt;movzx&lt;/code&gt;は8bitの値を64bitのレジスタに符号拡張しながらロードする命令です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make-ea&lt;/code&gt;というのがアドレッシングですね。&lt;code&gt;x&lt;/code&gt;レジスタを起点として&lt;code&gt;(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)&lt;/code&gt;バイト(？ワード？)先のメモリ1byteを指します。&lt;/p&gt;

&lt;p&gt;ディスアセンブルしてみましょう。みなさんもう慣れてきたと思うので主要部だけ抜き出します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 65:       0FB65101         MOVZX EDX, BYTE PTR [RCX+1]      ; no-arg-parsing entry point
; 69:       48D1E2           SHL RDX, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;短いですね。この&lt;code&gt;BYTE PTR [RCX+1]&lt;/code&gt;が&lt;code&gt;make-ea&lt;/code&gt;した値に対応します。&lt;code&gt;RCX&lt;/code&gt;は&lt;code&gt;x&lt;/code&gt;で&lt;code&gt;(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)&lt;/code&gt;の結果が1に現れてるんでしょう。補足しておくと、&lt;code&gt;EDX&lt;/code&gt;と&lt;code&gt;RDX&lt;/code&gt;は同じ場所を指します。32bitとして扱うときはE、64bitとして扱うときはRで指します。&lt;/p&gt;

&lt;p&gt;さて、私はx86のアドレッシングモードなんて全然知らないのですがコードを見る限りもうちょっと複雑なアドレッシングが出来るようです。&lt;/p&gt;

&lt;p&gt;配列のn番目にアクセスするコードが良い例のようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defknown access-simple-array-n ((simple-array (unsigned-byte 8) (*)) (unsigned-byte 64))
    (unsigned-byte 8)
    (movable flushable always-translatable)
  :overwrite-fndb-silently t)
(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::access-simple-array-n)
  (:translate vop-sample::access-simple-array-n)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg))
         (i :scs (unsigned-reg)))
  (:arg-types * unsigned-num)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4
              (inst movzx r 
               (make-ea :byte :base x
                        :scale 1
                        :index i
                        :disp (- (* vector-data-offset n-word-bytes)
                               other-pointer-lowtag)))))

(in-package :vop-sample)
(defun access-simple-array-n (x i)
  (access-simple-array-n x i))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新たに引数&lt;code&gt;i&lt;/code&gt;をとるようになったのと&lt;code&gt;make-ea&lt;/code&gt;の引数に&lt;code&gt;:scale 1 :index i&lt;/code&gt;が加わってます。&lt;/p&gt;

&lt;p&gt;ディスアセンブルしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 98:       0FB6543901       MOVZX EDX, BYTE PTR [RCX+RDI+1]  ; no-arg-parsing entry point
; 9D:       48D1E2           SHL RDX, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アドレッシングに&lt;code&gt;+RDI&lt;/code&gt;が加わりましたね。どうして&lt;code&gt;i&lt;/code&gt;(&lt;code&gt;RDI&lt;/code&gt;)を&lt;code&gt;RAS&lt;/code&gt;しなくていいのか気になりますがまあ、とりあえず正常に動いてるようです。&lt;/p&gt;

&lt;p&gt;おわかりかと思いますがアドレッシングが&lt;code&gt;x&lt;/code&gt;をベースにして今までの定数オフセット+新たにレジスタで指定したオフセットになってます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make-ea&lt;/code&gt;に渡した&lt;code&gt;:index&lt;/code&gt;は何か分かるとしても&lt;code&gt;:scale&lt;/code&gt;が気になりますよね。&lt;code&gt;scale&lt;/code&gt;を2にしてディスアセンブルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 58:       0FB6547901       MOVZX EDX, BYTE PTR [RCX+RDI*2+1]  ; no-arg-parsing entry point
; 5D:       48D1E2           SHL RDX, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。インデックスを定数倍するようですね。&lt;/p&gt;

&lt;h1 id=&#34;sseにチャレンジ:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;SSEにチャレンジ&lt;/h1&gt;

&lt;p&gt;インテルアーキテクチャにあるSSEとはStreaming SIMD Extensionsの略です。じゃあSIMDは何かというとSimple Instruction Mulitple Dataの略で、1命令で複数のデータを処理出来ます。&lt;/p&gt;

&lt;p&gt;この「複数のデータ」というのは64bit2つや32bit4つなどを128bitにまとめて渡します。128bitの値なんてどうやって作るんだよって感じですがsbcl-1.1.8から入った&lt;code&gt;sb-ext:%make-simd-pack-*&lt;/code&gt;が存在します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VOP-SAMPLE&amp;gt; (%make-simd-pack-ub32 1 2 3 4)
#&amp;lt;SIMD-PACK  01 00 00 00  02 00 00 00  03 00 00 00  04 00 00 00&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じです。x86_64がリトルエンディアンだったのを思い出させる表記ですね。ub32の他にub64、single、doubleが存在します。&lt;/p&gt;

&lt;p&gt;ストレージクラスも&lt;code&gt;*-sse-reg&lt;/code&gt;というものがあるのでこれを使いましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defknown simd-add ((simd-pack (unsigned-byte 64)) (simd-pack (unsigned-byte 64)))
    (simd-pack (unsigned-byte 32))
    (movable flushable always-translatable)
  :overwrite-fndb-silently t)
(in-package &amp;quot;SB-VM&amp;quot;)
(define-vop (vop-sample::simd-add)
  (:translate vop-sample::simd-add)
  (:policy :fast-safe)
  (:args (x :scs (int-sse-reg))
         (y :scs (int-sse-reg)))
  (:arg-types simd-pack-int simd-pack-int)
  (:results (r :scs (int-sse-reg)))
  (:result-types simd-pack-int)
  (:generator 4
              (move r x)
              (inst padddw r y)))

(in-package :vop-sample)
(defun simd-add (x y)
  (simd-add x y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。こんな感じですね。&lt;code&gt;paddw&lt;/code&gt;はparallel add wordですかね。これをディスアセンブルすると思ったより大きな命令になったので全部貼っときますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VOP-SAMPLE&amp;gt; (disassemble #&#39;simd-add)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;; disassembly for SIMD-ADD
; Size: 108 bytes. Origin: #x1006D64A21
; 21:       660F6FC2         MOVDQA XMM0, XMM2                ; no-arg-parsing entry point
; 25:       660FFDC1         PADDW XMM0, XMM1
; 29:       49896C2440       MOV [R12+64], RBP                ; thread.pseudo-atomic-bits
; 2E:       4D8B5C2418       MOV R11, [R12+24]                ; thread.alloc-region
; 33:       498D5320         LEA RDX, [R11+32]
; 37:       493B542420       CMP RDX, [R12+32]
; 3C:       7740             JNBE L2
; 3E:       4989542418       MOV [R12+24], RDX                ; thread.alloc-region
; 43:       498D530F         LEA RDX, [R11+15]
; 47: L0:   48C742F165030000 MOV QWORD PTR [RDX-15], 869
; 4F:       48C742F900000000 MOV QWORD PTR [RDX-7], 0
; 57:       660F7F4201       MOVDQA [RDX+1], XMM0
; 5C:       49316C2440       XOR [R12+64], RBP                ; thread.pseudo-atomic-bits
; 61:       7402             JEQ L1
; 63:       cc09             break 9                          ; pending interrupt trap
; 65: l1:   488be5           mov rsp, rbp
; 68:       f8               clc
; 69:       5d               pop rbp
; 6a:       c3               ret
; 6b:       cc0a             break 10                         ; error trap
; 6d:       02               byte #x02
; 6e:       19               byte #x19                        ; invalid-arg-count-error
; 6f:       9a               byte #x9a                        ; rcx
; 70:       cc0a             break 10                         ; error trap
; 72:       04               byte #x04
; 73:       32               byte #x32                        ; object-not-simd-pack-error
; 74:       fe1b01           byte #xfe, #x1b, #x01            ; rdx
; 77:       cc0a             break 10                         ; error trap
; 79:       04               byte #x04
; 7a:       32               byte #x32                        ; object-not-simd-pack-error
; 7b:       fe9b03           byte #xfe, #x9b, #x03            ; rdi
; 7e: l2:   6a20             push 32
; 80:       bac0854200       mov edx, 4359616                 ; alloc_tramp
; 85:       ffd2             call rdx
; 87:       5a               pop rdx
; 88:       80ca0f           or dl, 15
; 8b:       ebba             jmp l0
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なにやってるのやら。&lt;/p&gt;

&lt;h1 id=&#34;出来なかったこと:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;出来なかったこと&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;PCMPESTRI&lt;/code&gt;を使ってみたかったのですが扱いがトリッキーなので断念しました。具体的に言うと操作する値を格納するレジスタがEAXとECX固定なようなのです。
&lt;code&gt;:temporary&lt;/code&gt;節で内部で使うレジスタも要求出来るようなのですが名指しでもらえるんですかね。&lt;/p&gt;

&lt;p&gt;SSEの使い方とsimple-arrayから要素の配列を取り出す方法までは示したので誰かやって下さい。&lt;/p&gt;

&lt;p&gt;参考資料いっぱい置いときますね。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/&#34;&gt;How to Define New Intrinsics in SBCL - Paul Khuong mostly on Lisp&lt;/a&gt;
: VOPの使い方。最初の方に出てきたaddの最適化のやつとかも出てくる。(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html&#34;&gt;Hacking SSE Intrinsics in SBCL (part 1) - Paul Khuong mostly on Lisp&lt;/a&gt;
: SBCLのsimd-packの具体的解説(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pvk.ca/Blog/2013/06/05/fresh-in-sbcl-1-dot-1-8-sse-intrinsics/&#34;&gt;Fresh in SBCL 1.1.8: SSE Intrinsics! - Paul Khuong mostly on Lisp&lt;/a&gt;
: SBCLでVOPとSSEを使ってマンデルブロ集合を計算する(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://software.intel.com/en-us/node/514244&#34;&gt;Packed Compare Intrinsics&lt;/a&gt;
: IntelのPCMPESTRIとかのマニュアル(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb531465.aspx&#34;&gt;_mm_cmpestri&lt;/a&gt;
: MicrosoftのPCMPESTRIのマニュアル。こっちの方が分かりやすい(en)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://homepage1.nifty.com/herumi/prog/intel-opt.html&#34;&gt;Intel optimization&lt;/a&gt;
: PCMPISTRIを使った&lt;code&gt;strlen&lt;/code&gt;の実装例(ja)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.kazuhooku.com/2014/12/improving-parser-performance-using-sse.html&#34;&gt;Kazuho&amp;rsquo;s Weblog: Improving Parser Performance using SSE Instructions (in case of PicoHTTPParser)&lt;/a&gt;
: PCMPESTRIを使ってHTTPパーサーを高速化した話。これをやりたかった。(en)&lt;/p&gt;

&lt;h1 id=&#34;おわりに:3d713dfef9193402cbf3ea064dc287c5&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;おつかれ様でした。たまには低レベルなことをやっても良いんじゃないでしょうか。&lt;/p&gt;

&lt;p&gt;明日はnobkzさんで、Shenについてです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>require, ASDF, quicklispを正しく使う</title>
      <link>http://keens.github.io/blog/2014/11/30/quicklisp</link>
      <pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://keens.github.io/blog/2014/11/30/quicklisp</guid>
      <description>

&lt;p&gt;κeenです。最近のCommon Lispのパッケージ管理は&lt;code&gt;ql:quickload&lt;/code&gt;しか知らないという方も多いのではないでしょうか。しかしそれだけでは機能が足りないこともあります。Common Lispには様々な管理システムがあるので整理しましょう。&lt;/p&gt;

&lt;h1 id=&#34;provide-require:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;&lt;code&gt;provide&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;同じファイルを読み込まないための原始的なシステムです。Common Lispの標準の機能です。&lt;code&gt;(require &#39;foo)&lt;/code&gt;がファイルをロードし、ロードされたファイル内で&lt;code&gt;(provide &#39;foo)&lt;/code&gt;しておくと2回目以降の&lt;code&gt;(require &#39;foo&#39;)&lt;/code&gt;はファイルを読まずにすぐさま返ります。&lt;/p&gt;

&lt;p&gt;ここで問題なのが&lt;code&gt;require&lt;/code&gt;がどこのファイルを捜しにいくかは処理系依存なところですね。なので生の&lt;code&gt;require&lt;/code&gt;は使えないと思っておいた方が良いでしょう。&lt;/p&gt;

&lt;h1 id=&#34;asdf-3:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;ASDF 3&lt;/h1&gt;

&lt;p&gt;Another System Definition Facility。過去にはAnotherじゃないSystem Definition Facilityもあった模様。最新版は3系です。結構APIが変っているので必ず3の情報を捜しましょう。&lt;/p&gt;

&lt;p&gt;この「System」というのが聞き慣れませんが、ASDFの&lt;code&gt;defsystem&lt;/code&gt;で&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;systemに含まれるファイルの定義&lt;/li&gt;
&lt;li&gt;依存systemの記述&lt;/li&gt;
&lt;li&gt;その他作者、ライセンス、バージョンなどの記述&lt;/li&gt;
&lt;li&gt;systemのコンパイルやロード、テストなどの操作&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;が可能です。ASDFはCにとってのmake + ldを標榜しています。Makefile的なものは(systemname).asdになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;require&lt;/code&gt;との統合もされており、ASDFを適切に設定することで&lt;code&gt;defsystem&lt;/code&gt;されたsystemを&lt;code&gt;require&lt;/code&gt;でロードすることが出来ます。このときASDFは処理系に依存せずにASDFのパスに従って.asdファイルを捜しにいきます。&lt;/p&gt;

&lt;p&gt;また、ほとんどの処理系はASDFを標準添付していて、大抵&lt;code&gt;(require &#39;asdf)&lt;/code&gt;すれば使えるようになっています。&lt;/p&gt;

&lt;p&gt;尚、コンパイル後のファイルは処理系、バージョン毎に互換性がないので本来なら適切に管理する必要がありますが、ASDFが適切に~/.cache/common-lisp以下に管理してくれます。優秀ですね。&lt;/p&gt;

&lt;h1 id=&#34;quicklisp:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;quicklisp&lt;/h1&gt;

&lt;p&gt;lispプロジェクトのインストーラと微妙にパッケージマネージャ的な役割をします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://beta.quicklisp.org/quicklisp.lisp&#34;&gt;http://beta.quicklisp.org/quicklisp.lisp&lt;/a&gt; をダウンロードしてきてそのファイルを読み込んで&lt;code&gt;(quicklisp-quickstart:install)&lt;/code&gt;すれば~/quicklisp/以下にquicklispがインストールされ、ロードされます。処理系を再起動したあとまたquicklispをロードするには~/quicklisp/setup.lispを&lt;code&gt;load&lt;/code&gt;します。が、毎回それをやるのが面倒な人は&lt;code&gt;(ql:add-to-init-file)&lt;/code&gt;しておけば処理系の初期化ファイルに~/quicklisp/setup.lispを読み込む処理が書き加えられます。&lt;/p&gt;

&lt;p&gt;さて、このquicklispを扱う上で3つの概念を覚えておくと良いです。&lt;/p&gt;

&lt;p&gt;dist
:    releaseの配布元。普通は&amp;rsquo;quicklisp&amp;rsquo;のみだがほかのdistを使うことも可能。自前のやつとか。新たなdistを追加したり削除したり出来る。gitのremoteをイメージすればよい。&lt;/p&gt;

&lt;p&gt;release
:    quicklispがダウンロードしてくる単位。ライブラリの作者が登録するときの単位。複数のsystemをもつこともある。&lt;/p&gt;

&lt;p&gt;system
:    ASDFのsystem。ユーザーが使うときの単位。&lt;/p&gt;

&lt;p&gt;さて、quicklispを使うときは通常使いたいシステムを&lt;code&gt;ql:quickload&lt;/code&gt;すればそのシステムと依存システムの含まれているリリースをダウンロード、展開、ロードまでしてくれます。&lt;/p&gt;

&lt;p&gt;開発中はREPLを立ち上げているので「あ、このライブライリ使おう」と思ったら&lt;code&gt;ql:quickload&lt;/code&gt;するだけで即座に使えるようになりますね。&lt;/p&gt;

&lt;p&gt;quicklispのリリースは毎月下旬にアップデートされていて、毎月ちゃんと全てのライブラリが対応処理系で動くことがテストされています。なのでメンテナが居なくなったライブラリはドロップします。代わりにquicklispの作者がテスト出来ないライブラリは登録させてもらえなかったりします（cl-cudaとか）&lt;/p&gt;

&lt;h1 id=&#34;quicklispの問題:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;quicklispの問題&lt;/h1&gt;

&lt;p&gt;既にCommon Lispのライブラリマネージャとしてデファクトスタンダード的位置を築きつつあるquicklispですが、私は結構不満があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;~/quicklisp/setup.lispを読み込むとquicklispの全てを読み込んでしまう: これには過去全てのバージョンのdistとreleaseとsystemのデータベース、HTTPクライアント、圧縮ファイルの解凍ライブラリなども含まれており、処理系の起動が非常に遅くなる&lt;/li&gt;
&lt;li&gt;特にデータベースはファイルに書かれていても高速に読める形式なのに初期化時に毎回全ての内容をLispのハッシュに変換するという愚行をする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(ql:add-to-init-file)&lt;/code&gt;が推奨されているが、前述の通り処理系の起動が遅くなってしまう。特に、（インストーラではなく、インストール済みの）ライブラリマネージャとして使いたくてもインストーラの機能までロードしてしまう。結構メモリを食うしアプリケーションには要らない。&lt;/li&gt;
&lt;li&gt;処理系に依っては初期化ファイルはlispファイルをスクリプトとして使うときは読み込まれないこともあるのでスクリプトには使えない。まあ、前述の通り使いたくもない。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のでライブラリマネージャにはASDFが向いてるのですが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;quicklispでインストールしたシステムはquicklispを一旦ロードするかASDFの設定をいじるかしなければASDFからは使えない&lt;/li&gt;
&lt;li&gt;quicklispはシステムのダウンロード/インストールだけすれば良いものをロードまでする&lt;/li&gt;
&lt;li&gt;要はASDFを隠す&lt;/li&gt;
&lt;li&gt;じゃASDFのラッパーかというとロードしかせず、コンパイルやテストなどはしない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;など様々な問題があります。&lt;/p&gt;

&lt;p&gt;一応quicklispの弁護をしておくと、Common Lispは他のスクリプト言語とはちょっと使い方が違って、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;初期化ファイルは大抵オレオレライブラリで埋め尽くされていてそもそも起動には時間がかかる&lt;/li&gt;
&lt;li&gt;Emacsのように一度REPLを立ち上げたら滅多に落とさない&lt;/li&gt;
&lt;li&gt;アプリケーションも基本的にはREPLの中で使う&lt;/li&gt;
&lt;li&gt;起動時間を気にするなら初期化ファイルを全てロードした、コアファイルをダンプしておいて使う&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった使い方をされることが多いのです。そのような人からしてみたら細々処理されるよりも起動時間とメモリは気にしないから速いやつをくれ、となるのです。&lt;/p&gt;

&lt;p&gt;じゃあそれなりにCommon Lispを使う私が何故そうしないかというと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;立ち上げっぱなしというのが性に合わない。立ち上がっているものを見るとすぐに落としたくなる。EmacsのヘビーユーザーだがEmacsもすぐ落とす。&lt;/li&gt;
&lt;li&gt;コマンドラインアプリケーションを作りたいため、起動時間が命になる。&lt;/li&gt;
&lt;li&gt;私はSBCLの開発版を使っていて、コアファイルはすぐに無効になるためコアダンプはしない（意味がない）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった理由があります。これは初心者にも共通する部分があるんじゃないでしょうか。REPLを立ち上げっぱなしにはしないし「コアダンプ？なにそれ？エラー出してんじゃん」状態でしょう。&lt;/p&gt;

&lt;h1 id=&#34;asdfを正しく使う:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;ASDFを正しく使う&lt;/h1&gt;

&lt;p&gt;ということでquicklispをあまり使わない方法を紹介します。&lt;/p&gt;

&lt;p&gt;前述の通り、quicklispでインストールしたシステムはquicklispを一旦ロードするかasdfの設定をいじるかしなければasdfからは使えません。具体的に言うと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ASDFのデフォルトパスは~/common-lisp以下&lt;/li&gt;
&lt;li&gt;quicklispのシステムのインストールパスは~/quicklisp/dists/(dist name)/software/以下&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なので~/quicklisp/dists/以下にパスを通します。少し無駄なディレクトリもパスに含まれてしまうので気にする人はそれぞれのdistについて~/quicklisp/dists/(dist name)/software/にパスを通しましょう。&lt;/p&gt;

&lt;p&gt;因みに拙作の&lt;a href=&#34;https://github.com/KeenS/CIM&#34;&gt;CIM&lt;/a&gt;は~/.cim/quicklisp以下にquicklispをインストールするのでCIM使いの方は~/.cim/quicklisp/dists/ですね。~/quicklispの方が混乱少ないかなあ。&lt;/p&gt;

&lt;p&gt;さて、ASDFの設定は&lt;a href=&#34;http://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems&#34;&gt;公式マニュアル&lt;/a&gt;を参照すれば良いのですが一応実際のものを書いておくと&lt;/p&gt;

&lt;p&gt;~/.config/common-lisp/source-registry.conf に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(:source-registry
  (:tree &amp;quot;~/quicklisp/dists/&amp;quot;)
  (:tree (:home &amp;quot;Lisp/&amp;quot;))
  :INHERIT-CONFIGURATION)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を書けばOKです。2つめのLisp/は私がCommon Lispファイルを置いているディレクトリですね。この書き方だとquicklispより自分のLispライブラリを優先して読みにいきます。開発版を使いたいときとかむしろ開発をするときとかに必須です。この設定をミスるといくら開発してもロードされてるのはリリース版で、機能が動かないとかの地獄を見ます。&lt;/p&gt;

&lt;p&gt;ここまでくれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;asdf)
(require &#39;hoge)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすればquicklispでインストールしたライブラリをロード出来ます。&lt;/p&gt;

&lt;h2 id=&#34;require以外のasdfの使い方:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;require以外のASDFの使い方&lt;/h2&gt;

&lt;p&gt;バージョンに依って使い方が異なるのですが、3系だと&lt;code&gt;(asdf:xxx-system &#39;hoge)&lt;/code&gt;などとします。具体的には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(asdf:load-system &#39;hoge)&lt;/code&gt; ( = &lt;code&gt;(require &#39;hoge)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(asdf:test-system &#39;hoge)&lt;/code&gt; (テストがあるときのみ)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(asdf:compile-system &#39;hoge)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を覚えておけば良いでしょう。他にもいくつか操作があるようですが私は使ったことがないです。&lt;code&gt;asdf:locate-system&lt;/code&gt;は名前的に便利そうではあるんですけどね。&lt;/p&gt;

&lt;p&gt;開発するときはまず.asdファイルを書いておいて(あるいはcl-projectから生成して)、&lt;code&gt;(require &#39;hoge)&lt;/code&gt;で始めて書いていき、ある程度進んだらテストを書いてテストの項目を.asdファイルに書き足して&lt;code&gt;(asdf:test-system &#39;hoge)&lt;/code&gt;、それなりに動くようになったら&lt;code&gt;(asdf:compile-system &#39;hoge)&lt;/code&gt;してコンパイルの様子を見たりコンパイル後のベンチマークを取ったりします。&lt;/p&gt;

&lt;h2 id=&#34;quickloadを成仏させる:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;quickloadを成仏させる&lt;/h2&gt;

&lt;p&gt;これでロードの処理はASDFで全てカバー出来るようになりました。じゃあquickloadのロード機能は邪魔ですね。quicklispをインストーラとしてのみ使いましょう。&lt;/p&gt;

&lt;p&gt;まず処理系の初期化ファイル(sbclなら~/.sbclrc)から&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;;; The following lines added by ql:add-to-init-file:
#-quicklisp
(let ((quicklisp-init (merge-pathnames &amp;quot;~quicklisp/setup.lisp&amp;quot;
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init :verbose nil)))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を削除します。quicklispを使いたいときだけ&lt;code&gt;(load &amp;quot;~/quicklisp/setup.lisp&amp;quot;)&lt;/code&gt;します。そして欲しいシステムをインストールするには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(ql::recursively-install &amp;quot;foo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;します。quickloadに比べて爆速です。ここにきて名前が文字列な上にexportされてないシンポル参照してますね。気持ち悪いという方は大人しくquickloadしましょう。&lt;/p&gt;

&lt;p&gt;拙作のCIMにはこれをコマンドラインから行なう&lt;code&gt;ql install&lt;/code&gt;なるコマンドが存在します。&lt;/p&gt;

&lt;h1 id=&#34;最後に:fbd07b03fdd0ad8c65f2c74efdd4ba1e&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;quicklispが嫌いなのは私の好みですがASDFを正しく使えて損はないと思うので知らなかった方々は是非試してみて下さい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>