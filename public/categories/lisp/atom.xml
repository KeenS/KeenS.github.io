<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp | κeenのHappy Hacκing Blog]]></title>
  <link href="http://KeenS.github.io/categories/lisp/atom.xml" rel="self"/>
  <link href="http://KeenS.github.io/"/>
  <updated>2014-12-19T15:28:27+09:00</updated>
  <id>http://KeenS.github.io/</id>
  <author>
    <name><![CDATA[κeen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[実用Common Lispを読んだ]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda/"/>
    <updated>2014-12-14T21:45:23+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/14/shi-yong-common-lispwodu-nda</id>
    <content type="html"><![CDATA[<p>以前<a href="http://keens.github.io/blog/2014/10/20/lisp-ja/">Common Lispの勉強の手引の記事</a>を書いたときに実用Common Lispの名を挙げたが読んだことはなかった。</p>

<p>一応名前を挙げた責任として読んでみた。</p>

<!-- more -->


<p>読んだとは言ってもソースはざっくりしか見てないし、演習には目もくれてないので「一通り目を通した」程度。
買った本は逃げないのだし一回で理解する必要はない。最初に一通り内容を掴んで主張を理解してから、あとで気になった時につぶさに読むのが私の読み方。</p>

<p>最初の感想を言うと、古い。Common Lispもcltl2とANSI両方に配慮されて書かれているし、紹介されているAIの事例も1970~1980年代のもの。
古典といった感じ。ただし、その時代はCommon LispとAIの最盛期なのでこの本を読めばCommon LispがAIで名を馳せた理由が良く分かる。</p>

<p>Common Lispの内容は初級程度。まえがきにもあるようにプログラマとしては中級だがLispは初心者レベルの人向に書かれている。基本的なところを押えたらあとはどんどん進んでいく。
プログラミングの経験があればそれでも問題ない筈。心配ならWeb上にいくらでもあるチュートリアルをこなせば良い。</p>

<p>ライブラリなどに関しては本の中で完結しているので良く言えば1から10まで教えてくれる。悪く言えば最近のCommon Lispの動向は全く分からない。その意味では実践入門ではなく学習図書。陳腐化はしない。</p>

<p>AIについては、やはり古い。今では手法が確立されてAIの分野とは扱われないものも含まれている。ただし、これは意図したものなのかもしれない。
古いものというのは単純だ。最初に2部で単純なものを通して「肩馴らし」をしてから3部で手駒を増やして4部で踏み込んだ内容に入る。</p>

<p>また、AIの分野としては扱われていなものも含む、ということはこの本が情報科学の広い範囲をカバーする、ということでもある。900ベージは伊達じゃない。量もあればバラエティもある。</p>

<p>現実にある様々な難解な問題をCommon Lispという強力な道具で快刀乱麻解決していく。ソフトウェア開発手法を学びながらCommon Lispの強力さを思い知るための一冊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[割と処理系ポータブルなCommon Lisp実行可能ファイルを作る]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/"/>
    <updated>2014-12-08T06:17:12+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru</id>
    <content type="html"><![CDATA[<p>κeenです。Lisp Advent Calendarはもう枠埋まっちゃったので普通にブログで。</p>

<p>コマンドラインから実行可能なLispファイルをそれなりに多くの処理系で動くように作る話。</p>

<!-- more -->


<p>この話はCIMの生い立ちとも関連するんだけどシェルからLispを使いたいときは</p>

<p>```</p>

<h1>!/usr/bin/env sbcl &mdash;script</h1>

<p>&hellip;
```</p>

<p>なんて書いてた人も多いんじゃないかと思うんだけどこれは色々問題がある。</p>

<ol>
<li>envは環境に依っては/usr/local/bin/envだったりする</li>
<li>envは環境に依っては複数引数を取れない。"sbcl &mdash;script"という名前のファイルを捜しにいく</li>
<li>sbclでしか動かない</li>
</ol>


<p>この問題の扱いは一応解決策がある</p>

<p>```</p>

<h1>!/bin/sh</h1>

<h1>|</h1>

<p>exec sbcl &mdash;script &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
|#</p>

<p>&hellip;
```</p>

<p>3行目の<code>#|</code>がシェルのコメントでありLispのブロックコメントであるのがポイント。</p>

<ol>
<li>シェルは<code>#!/bin/sh</code>を見てシェルスクリプトとして実行する</li>
<li>1,3行目はコメントなのでシェルは無視</li>
<li>4行目でsbclにそのファイルを引数として与えてexecする。execしたあとはシェルには戻らないのでその後何が書いてあっても構わない</li>
<li>sbclを<code>--script</code>付きで読んでるので1行目の<code>#!</code>で始まる行は無視する</li>
<li>3~5行目はブロックコメントなのでsbclは無視</li>
<li>それ以降がLispとして実行される</li>
</ol>


<p>というカラクリになっている。こういうのをピジン言語っていうんだけ？</p>

<p>まあいいや。</p>

<p>ところでこのブロックコメントの中にはシェルスクリプト書き放題だよね？そのシェルスクリプト内でどのLisp使うか決めたらポータブルになりそうじゃない？</p>

<p>こういうのはどう？</p>

<p>```lisp</p>

<h1>!/bin/sh</h1>

<h1>|</h1>

<p>run_if_exists(){
 command -v $1 > /dev/null 2>&amp;1 &amp;&amp; exec &ldquo;$@&rdquo;
}
 run_if_exists sbcl &mdash;noinform &mdash;no-sysinit &mdash;no-userinit &mdash;script &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
 run_if_exists clisp -norc &mdash;quiet &mdash;silent -on-error exit  &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
 run_if_exists ecl -norc -q -shell &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
 run_if_exists mkcl -norc -q -shell &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
 run_if_exists alisp -qq &ndash;#! &ldquo;$0&rdquo; &mdash; &ldquo;$@&rdquo;
|#</p>

<p>(write-line (lisp-implementation-type))
(force-output)
```</p>

<p>cclとabclは1行目のシェバンを読み飛ばせなかった&amp;評価結果をエコーバックしない方法が見当らなかったからパス。CMUCLは自分の環境で動かないから検証出来てない。</p>

<p>これでポータブルに実行は可能。コマンドライン引数の扱いとかはライブラリを頼ってくれ。因みにCIMでは</p>

<p>```lisp
  #+allegro  (cdr (system:command-line-arguments))
  #+sbcl (do<em>  ((var sb-ext:</em>posix-argv* (cdr list))</p>

<pre><code>            (list var var))
           ((string= (car list) "--") (return (cdr list))))
</code></pre>

<p>  #+clisp ext:<em>args</em>
  #+ecl (do*  ((var (si:command-args) (cdr list))</p>

<pre><code>           (list var var))
          ((string= (car list) "--") (return (cdr list))))
</code></pre>

<p>  #+abcl extensions:<em>command-line-argument-list</em>
  #+gcl (do<em>  ((var si::</em>command-args* (cdr list))</p>

<pre><code>           (list var var))
          ((string= (car list) "--") (return (cdr list))))
</code></pre>

<p>  #+cmu ext:<em>command-line-words</em>
  #+ccl ccl:<em>unprocessed-command-line-arguments</em>
  #+mkcl (do*  ((var (si:command-args) (cdr list))</p>

<pre><code>           (list var var))
          ((string= (car list) "--") (return (cdr list))))
</code></pre>

<p>  #+lispworks system:<em>line-arguments-list</em>
```</p>

<p>としている。参考までに。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H2Oにpicrinを溶かす]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/07/h2onipicrinworong-kasu/"/>
    <updated>2014-12-07T22:37:00+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/07/h2onipicrinworong-kasu</id>
    <content type="html"><![CDATA[<p>このエントリーは<br/>
<a href="http://qiita.com/advent-calendar/2014/lisp">Lisp Advent Calendar</a> 7日目<br/>
兼<br/>
<a href="http://qiita.com/advent-calendar/2014/h2o">H2O Advent Calendar</a> 7日目<br/>
の記事です。</p>

<p>κeenです。タイトルの通りです。</p>

<!-- more -->


<h1>H2Oとは</h1>

<p>水。</p>

<h1>picrinとは</h1>

<p><a href="http://ja.wikipedia.org/wiki/%E3%83%94%E3%82%AF%E3%83%AA%E3%83%B3%E9%85%B8">Wikipedia</a>にあるように、フェノールのトリニトロ化合物で、水溶性があります。</p>

<h1>ではなくて</h1>

<p>H2OはHTTP1, HTTP2, WebsocketをサポートするNginXより速いHTTPサーバです。<a href="https://github.com/h2o/h2o">Github</a>で開発されています。開発者は@kazuhoさん。</p>

<p>picrinは「速い、軽い、高機能」を目指して作られているScheme処理系です。<a href="https://github.com/picrin-scheme/picrin">Github</a>で開発されています。開発者は@wasabizさん。</p>

<h1>混ぜる</h1>

<p>picrinのように組込み向けで開発されている処理系は</p>

<ul>
<li>picrinからH2Oを使えるようにする</li>
<li>H2Oにpicrinを埋め込む</li>
</ul>


<p>と、2種類考えられますが、今回は後者です。H2Oにpicrinを溶かしてる感じしますね。</p>

<p>まあ、Apatch HTTPDやNginX宜しくmod_picrinを作れば済むでしょう。</p>

<h1>絶望</h1>

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/blackenedgold">@blackenedgold</a> モジュラーにできるようにはしてるけど、まだsoをロードする仕組みはないです。というか、APIがまだunstableだし</p>&mdash; Kazuho Oku (@kazuho) <a href="https://twitter.com/kazuho/status/540692011003559936">2014, 12月 5</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>つらい</p>

<h1>solシステムの導入</h1>

<p>mod_xxxにしようと思ったんですけど水だし溶液ってことでsol_xxxにします。</p>

<p>H2Oにこんな感じのパッチ当てて</p>

<p>```
diff &mdash;git a/src/main.c b/src/main.c
index 7fc4680..57804a6 100644
&mdash;&ndash; a/src/main.c
+++ b/src/main.c
@@ -30,6 +30,7 @@
 #include &lt;signal.h>
 #include &lt;stdio.h>
 #include &lt;unistd.h>
+#include &lt;dlfcn.h>
 #include &lt;sys/stat.h>
 #include &lt;sys/socket.h>
 #include &lt;sys/types.h>
@@ -76,6 +77,8 @@ struct config_t {</p>

<pre><code> } state;
</code></pre>

<p> };</p>

<p>+typedef int(<em>sol_init_fn)(h2o_configurator_command_t </em>, h2o_configurator_context_t <em>, const char </em>, yoml_t *);
+
 static unsigned long openssl_thread_id_callback(void)
 {</p>

<pre><code> return (unsigned long)pthread_self();
</code></pre>

<p>@@ -381,6 +384,43 @@ static int on_config_num_threads(h2o_configurator_command_t *cmd, h2o_configurat</p>

<pre><code> return h2o_config_scanf(cmd, config_file, config_node, "%u", &amp;conf-&gt;num_threads);
</code></pre>

<p> }</p>

<p>+static int on_config_use(h2o_configurator_command_t <em>cmd, h2o_configurator_context_t </em>ctx, const char <em>config_file, yoml_t </em>config_node)
+{
+  /<em> struct config_t </em>conf = H2O_STRUCT_FROM_MEMBER(struct config_t, global_config, ctx->globalconf); <em>/
+  char </em>sol_name;
+  sol_init_fn init_fn;
+  void <em>handle;
+
+  /</em> fetch solution name <em>/
+  switch (config_node->type) {
+  case YOML_TYPE_SCALAR:
+    sol_name = config_node->data.scalar;
+    break;
+  default:
+    h2o_config_print_error(cmd, config_file, config_node, &ldquo;value must be a string or a mapping (with keys: <code>port</code> and optionally <code>host</code>)&rdquo;);
+    return -1;
+  }
+
+  char dl_name[strlen(&ldquo;sol<em>.so&rdquo;) + strlen(sol_name) + 1];
+  char init_fn_name[strlen(&ldquo;init_sol</em>&rdquo;) + strlen(sol_name) + 1];
+
+  sprintf(dl_name, &ldquo;./sol<em>%s.so&rdquo;, sol_name);
+  sprintf(init_fn_name, &ldquo;init_sol</em>%s&rdquo;, sol_name);
+  handle = dlopen(dl_name, RTLD_LAZY);
+  if (! handle){
+    h2o_config_print_error(cmd, config_file, config_node, &ldquo;cannot load the solution&rdquo;);
+    return -1;
+  }
+
+  init_fn = dlsym(handle, init_fn_name);
+  if(dlerror()){
+    h2o_config_print_error(cmd, config_file, config_node, &ldquo;cannot find the initialize function&rdquo;);
+    return -1;
+  }
+  return (</em>init_fn)(cmd, ctx, config_file, config_node);
+
+}
+
 static void usage_print_directives(h2o_globalconf_t *conf)
 {</p>

<pre><code> h2o_linklist_t *node;
</code></pre>

<p>@@ -606,6 +646,10 @@ int main(int argc, char **argv)</p>

<pre><code>         c, "num-threads", H2O_CONFIGURATOR_FLAG_GLOBAL,
         on_config_num_threads,
         "number of worker threads (default: 1)");
</code></pre>

<ul>
<li><pre><code> h2o_config_define_command(
</code></pre></li>
<li><pre><code>     c, "use", H2O_CONFIGURATOR_FLAG_GLOBAL,
</code></pre></li>
<li><pre><code>     on_config_use,
</code></pre></li>
<li><pre><code>     "use the solution");
</code></pre>

<p> }</p>

<p> h2o_access_log_register_configurator(&amp;config.global_config);
```</p></li>
</ul>


<p>こんな感じのソリューション用意して</p>

<p>```C</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;pthread.h></h1>

<h1>include &ldquo;picrin.h&rdquo;</h1>

<h1>include &ldquo;picrin/pair.h&rdquo;</h1>

<h1>include &ldquo;picrin/string.h&rdquo;</h1>

<h1>include &ldquo;picrin/error.h&rdquo;</h1>

<h1>include &ldquo;h2o.h&rdquo;</h1>

<p>pic_state <em>pic;
struct pic_lib </em>PICRIN_BASE;</p>

<p>void pic_init_contrib(pic_state <em>);
void pic_load_piclib(pic_state </em>);</p>

<p>static pic_value
pic_features(pic_state *pic)
{
  pic_get_args(pic, &ldquo;&rdquo;);</p>

<p>  return pic->features;
}</p>

<p>static pic_value
pic_libraries(pic_state *pic)
{
  pic_value libs = pic_nil_value(), lib;</p>

<p>  pic_get_args(pic, &ldquo;&rdquo;);</p>

<p>  pic_for_each (lib, pic->libs) {</p>

<pre><code>libs = pic_cons(pic, pic_car(pic, lib), libs);
</code></pre>

<p>  }</p>

<p>  return libs;
}</p>

<p>void
pic_init_picrin(pic_state <em>pic)
{
  const char </em>scheme =</p>

<pre><code>"(import (scheme base)"
"        (scheme write))"
"(define-syntax call-with-output-to-string"
"  (syntax-rules ()"
"    ((_ proc)"
"     (let ((s (open-output-string)))"
"       (proc s)"
"       (get-output-string s)))))"
"(define (-&gt;string e)"
"  (call-with-output-to-string"
"   (lambda (s)"
"     (display e s))))";
</code></pre>

<p>  pic_add_feature(pic, &ldquo;r7rs&rdquo;);</p>

<p>  pic_deflibrary (pic, &ldquo;(picrin library)&rdquo;) {</p>

<pre><code>pic_defun(pic, "libraries", pic_libraries);
</code></pre>

<p>  }</p>

<p>  pic_deflibrary (pic, &ldquo;(scheme base)&rdquo;) {</p>

<pre><code>pic_defun(pic, "features", pic_features);

pic_init_contrib(pic);
pic_load_piclib(pic);
</code></pre>

<p>  }
  pic_deflibrary (pic, &ldquo;(picrin base)&rdquo;) {</p>

<pre><code>pic_load_cstr(pic, scheme);
</code></pre>

<p>  }
}</p>

<p>const char *
pic_eval_cstr_into_cstr(pic_state <em>pic, const char </em>input)
{
  pic_value v;</p>

<p>  v = pic_read_cstr(pic, input);
  v = pic_eval(pic, v, PICRIN_BASE);
  v = pic_funcall(pic, PICRIN_BASE, &ldquo;&ndash;>string&rdquo;, pic_list1(pic, v));
  return pic_str_cstr(pic_str_ptr(v));
}</p>

<p>int
on_picrin(h2o_configurator_command_t <em>cmd, h2o_configurator_context_t </em>ctx, const char <em>config_file, yoml_t </em>config_node)
{
  const char *sexp;</p>

<p>  switch (config_node->type) {
  case YOML_TYPE_SCALAR:</p>

<pre><code>sexp = config_node-&gt;data.scalar;
break;
</code></pre>

<p>  default:</p>

<pre><code>h2o_config_print_error(cmd, config_file, config_node, "value must be a string");
return -1;
</code></pre>

<p>  }</p>

<p>  pic_try{</p>

<pre><code>puts(pic_eval_cstr_into_cstr(pic, sexp));
</code></pre>

<p>  }
  pic_catch{</p>

<pre><code>pic_print_backtrace(pic);
return -1;
</code></pre>

<p>  }
  return 0;</p>

<p>}</p>

<p>int
init_sol_picrin(h2o_configurator_command_t <em>cmd, h2o_configurator_context_t </em>ctx, const char <em>config_file, yoml_t </em>config_node)
{</p>

<p>  h2o_configurator_t *c = cmd->configurator;</p>

<p>  pic = pic_open(0, NULL, NULL);</p>

<p>  pic_init_picrin(pic);</p>

<p>  PICRIN_BASE = pic_find_library(pic, pic_read_cstr(pic, &ldquo;(picrin base)&rdquo;));</p>

<p>  h2o_config_define_command(</p>

<pre><code>  c, "picrin", H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
  on_picrin,
  "run picrin");
</code></pre>

<p>  return 0;</p>

<p>}
```</p>

<p>んでコンフィグは</p>

<p>```</p>

<h1>to find out the configuration commands, run: h2o &mdash;help</h1>

<p>use: picrin
listen:
  port:
listen:
  port: 8081
  ssl:</p>

<pre><code>certificate-file: examples/h2o/server.crt
key-file: examples/h2o/server.key
</code></pre>

<p>picrin: &ldquo;(string-append \"Hello, \&rdquo; \&ldquo;World\&rdquo;)&ldquo;
hosts:
  default:</p>

<pre><code>paths:
  /:
    file.dir: examples/doc_root
access-log: /dev/stdout
</code></pre>

<p>```</p>

<p>そして魔法のコマンドを叩いて</p>

<p><code>
$ cp ~/compile/picrin/src/{init_contrib.c,load_piclib.c} ./
$ gcc -c sol_picrin.c -std=c99   -o sol_picrin.o -I ~/compile/picrin/extlib/benz/include -I ~/compile/h2o/include -I ~/compile/h2o/deps/picohttpparser -I ~/compile/h2o/deps/yoml -DH2O_USE_LIBUV=0 -fPIC
$ gcc sol_picrin.o load_piclib.o init_contrib.o -L ~/compile/picrin/build/lib/ -l picrin -fPIC -shared -o sol_picrin.so
$ cp sol_picrin.so ~/compile/h2o
</code></p>

<p>実行すると</p>

<p><code>
$ cd ~/compile/h2o
$ ./h2o --conf example/h2o/h2o.conf
Hello, Wold
</code></p>

<p>ヤッタ！</p>

<h1>標準出力かよ</h1>

<p>ううっ。ごめんなさい。</p>

<h1>で、HTTPレスポンス版は？</h1>

<p>ごめんなさい、まだです。</p>

<p><code>file.c</code>をベースにして</p>

<p>```yaml</p>

<pre><code>paths:
  /:
    picrin.exp: "(string-append \"Hello, \" \"World\")"
</code></pre>

<p>```</p>

<p>とかしたかったんですけど間に合いませんでした。</p>

<p>ソリューションなりモジュールなりのシステムが出来たらまたトライします</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[claspがアップデートされたよ]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/06/claspgaatupudetosaretayo/"/>
    <updated>2014-12-06T23:29:46+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/06/claspgaatupudetosaretayo</id>
    <content type="html"><![CDATA[<p>κeenです。アドベントカレンダーめっちゃ書いてますね。</p>

<!-- more -->


<h1>Clasp!</h1>

<p><a href="https://github.com/drmeister/clasp">clasp</a>のmasterに色々マージされました。リリースノートには、</p>

<blockquote><p>Clasp version 0.11
* Added ASDF support.
This is still alpha. Compile the ASDF module using (core:compile-asdf).
After that you can load the module using (load &ldquo;sys:kernel;asdf;build;asdf.bundle&rdquo;).
It takes between 15-30 seconds to load (this is why I&rsquo;m integrating Cleavir).
* Added the :CLASP <em>feature</em> and removed the :ECL <em>feature</em>.
Clasp will continue to mimic the underlying ECL functionality so that
Common Lisp code that supports ECL can be made to support Clasp by converting</p>

<h1>+ecl to #+(or ecl clasp) and #-ecl to #&ndash;(or ecl clasp)</h1>

<ul>
<li>Added code to generate object files directly from Clasp.
The LLVM bitcode compiler &ldquo;llc&rdquo; no longer needs to be in the PATH
for Clasp to generate object files from Common Lisp source.
The &ldquo;ld&rdquo; linker does need to be accessible.</li>
</ul>
</blockquote>

<p>とあります。ASDFが使える！リリースノートには書いてませんがslimeサポートもmasterにコミットされてます。あとコミット読んだら最適化もされてるような…。</p>

<p><a href="http://keens.github.io/slide/clasp.html">以前</a>二十数秒掛かっていた<code>(fib 29)</code>ですが、今回はなんと</p>

<p>```
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 &hellip; loading image&hellip; it takes a few seconds
Top level.</p>

<blockquote><p>(load &ldquo;fib.lisp&rdquo;)
1346269
real time : 34.294 secs
run time  : 38.844 secs
T
(compile-file &ldquo;fib.lisp&rdquo;)</p></blockquote>

<h1>P"/home/kim/Lisp/fib.bc"</h1>

<p>NIL
NIL</p>

<blockquote><p>(load &ldquo;fib.bc&rdquo;)
1346269
real time : 21.355 secs
run time  : 25.785 secs
T
```</p></blockquote>

<p>うわぁ。遅くなってる。</p>

<p>因みに.bcファイルはLLVMの中間ファイルなのでClaspとは独立に<code>opt -f -O3 fib.bc &gt; fib.opt.bc</code>で最適化出来ます。それをやると</p>

<p>```
$ opt -f -O3 fib.bc > fib.opt.bc
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 &hellip; loading image&hellip; it takes a few seconds
Top level.</p>

<blockquote><p>(load &ldquo;fib.opt.bc&rdquo;)
1346269
real time : 34.981 secs
run time  : 37.986 secs
T
```
あれ？遅くなった。</p></blockquote>

<p>mpsはまだコンパイル中だから待ってね</p>

<h1>ASDFを使ってみる</h1>

<p>```
$ /usr/local/clasp/bin/clasp_boehm_o
Starting Clasp 0.11 &hellip; loading image&hellip; it takes a few seconds
Top level.</p>

<blockquote><p>(time (core:compile-asdf))
zsh: segmentation fault (core dumped)  /usr/local/clasp/bin/clasp_boehm_o
```</p></blockquote>

<p>はい。解散。因みに50分くらいは動いてた。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VOPで遊ぶ]]></title>
    <link href="http://KeenS.github.io/blog/2014/12/02/vopdeyou-bu/"/>
    <updated>2014-12-02T23:38:26+09:00</updated>
    <id>http://KeenS.github.io/blog/2014/12/02/vopdeyou-bu</id>
    <content type="html"><![CDATA[<p>(:meta<br/>
 ((:this &ldquo;<a href="http://qiita.com/advent-calendar/2014/lisp">Lisp Advent Calendar 2014</a>の3日目の記事&rdquo;)<br/>
  (:prev (:author &ldquo;tk_riple&rdquo; :title <a href="http://compassoftime.blogspot.jp/2014/12/r7rs.html">&ldquo;時の羅針盤＠blog: R7RSポータブルライブラリを書く際の落とし穴&rdquo;</a>))<br/>
  (:next (:author &ldquo;nobkz&rdquo; :tite &ldquo;Shenについて&rdquo;))))</p>

<p>κeenです。さっきまでVOPで遊んでたので当初の予定を変更してVOPの話をします。</p>

<!-- more -->


<h1>VOPとは何か</h1>

<p>SBCLやCMU CLで使われているネイティブコードを吐くための機構、要はインラインアセンブラです。</p>

<h1>VOPとはどんなものか</h1>

<p>とりあえずコードをば。x86-64用です。</p>

<p>```lisp
(in-package :cl-user)
(defpackage vop-sample
  (:use :cl :sb-ext :sb-c))
(in-package :vop-sample)</p>

<p>(defknown add (fixnum fixnum)          ; addのftypeを宣言</p>

<pre><code>fixnum
(movable                            ; 副作用がない
 flushable                          ; デッドコードとして除去してよい
 foldable                           ; 定数畳み込みをしてよい
 always-translatable)               ; 必ずアセンブラコードになる
</code></pre>

<p>  :overwrite-fndb-silently t)           ; 関数上書きのエラーを出さない</p>

<p>(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::add)          ; VOP名
  (:translate vop-sample::add)         ; 関数名
  (:policy :fast-safe)                  ; declare optimize的な
  (:args (x :scs (signed-reg))          ; 引数宣言。後述</p>

<pre><code>     (y :scs (signed-reg)))
</code></pre>

<p>  (:arg-types fixnum fixnum)            ; 引数の型宣言
  (:results (r :scs (signed-reg)))      ; 返り値宣言。後述
  (:result-types fixnum)                ; 返り値の型宣言
  (:generator 4                         ; 翻訳するときのコスト</p>

<pre><code>          (move r x)                ; 返り値レジスタにxを移動
          (inst add r y)))          ; 返り値レジスタにyを足し込む
</code></pre>

<p>(in-package :vop-sample)</p>

<p>(defun add (x y)                        ; 安全なバージョンでラップする
  (add x y))
```</p>

<p>ちょっとおまじないが多いですね。</p>

<p>すこし解説すると引数は基本レジスタ渡しで、レジスタが足りなければスタックも使います。で、レジスタやスタックの値には型があります。それがストレージクラス(sc)です。この場合、x、y、rは<code>signed-reg</code>と宣言されてますね。符号付きレジスタです。<code>:scs</code>の最後のsは複数形のsです。今回は1つしか指定してませんが複数指定することも可能なのです。</p>

<p><code>move</code>というのはアセンブラ命令ではなく、マクロかなんかです（適当）。VOPなのかな？どのストレージクラスからどのストレージクラスに移動するかを認知して適切な命令を吐きます。</p>

<p><code>inst</code>が付いてるのがアセンブラですね。</p>

<p>このコード、xとrが等しいときに最適化出来るのですがそれはまあおいといて、こいつをディスアセンブルしてみましょう。</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'add)
; disassembly for ADD
; Size: 43 bytes. Origin: #x1005C26416
; 16:       488BD3           MOV RDX, RBX                     ; no-arg-parsing entry point
; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
; 2E:       CC0A             BREAK 10                         ; error trap
; 30:       02               BYTE #X02
; 31:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 32:       9A               BYTE #X9A                        ; RCX
; 33:       CC0A             BREAK 10                         ; error trap
; 35:       04               BYTE #X04
; 36:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 37:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 3A:       CC0A             BREAK 10                         ; error trap
; 3C:       04               BYTE #X04
; 3D:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 3E:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
</code></pre>

<p>主要な部分はここです。</p>

<pre><code>; 19:       48D1FA           SAR RDX, 1
; 1C:       488BF9           MOV RDI, RCX
; 1F:       48D1FF           SAR RDI, 1
; 22:       4801FA           ADD RDX, RDI
; 25:       48D1E2           SHL RDX, 1
; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
</code></pre>

<p><code>ADD</code>の他に無駄な命令がいくつかありますね。</p>

<p>SBCLはintの下位1bitをGCのときのタグとして使ってるのでアセンブラに渡す前に算術右シフト(<code>SAR</code>)して渡してます。
そして返るときはまた左シフト(<code>SHL</code>)してます。</p>

<p>その後の</p>

<pre><code>; 28:       488BE5           MOV RSP, RBP
; 2B:       F8               CLC
; 2C:       5D               POP RBP
; 2D:       C3               RET
</code></pre>

<p>は関数から返るときのイディオム(スタックポインタを復元してフラグをクリアして呼び出し元に戻る)です。</p>

<p>余談ですがLispマシンなどのタグマシンは下位ビットにあるタグを無視して計算出来るのでシフトが不要になります。なので速いんですね。</p>

<h1>シフトをなくす</h1>

<p>さっきは<code>signed-reg</code>を指定しました。つまり「（アセンブラの）intをくれ」と要求した訳です。
intの下位1bitは0なので足し算する分には別にシフトされなくても問題ありませんよね。シフトを殺しましょう。</p>

<p>さっきのコードの下にこれを足します。<code>add</code>は再定義しないと反映されないようでした。</p>

<p>```lisp
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::add/v2)        ; vop名は異なる
  (:translate vop-sample::add)          ; 関数名は同じ
  (:policy :fast-safe)
  (:args (x :scs (any-reg))             ; any-regになってる</p>

<pre><code>     (y :scs (any-reg)))            ; any-regになってる
</code></pre>

<p>  (:arg-types fixnum fixnum)
  (:results (r :scs (any-reg)))         ; any-regになってる
  (:result-types fixnum)
  (:generator 3                         ; コストをさっきより低くすると優先して使ってくれる</p>

<pre><code>          (move r x)
          (inst add r y)))
</code></pre>

<p>(in-package :vop-sample)</p>

<p>(defun add (x y)
  (add x y))</p>

<p>```</p>

<p>んで、ディスアセンブルしてみると</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'add)

; disassembly for ADD
; Size: 31 bytes. Origin: #x1004C2AB83
; 83:       488BD1           MOV RDX, RCX                     ; no-arg-parsing entry point
; 86:       4801FA           ADD RDX, RDI
; 89:       488BE5           MOV RSP, RBP
; 8C:       F8               CLC
; 8D:       5D               POP RBP
; 8E:       C3               RET
; 8F:       CC0A             BREAK 10                         ; error trap
; 91:       02               BYTE #X02
; 92:       19               BYTE #X19                        ; INVALID-ARG-COUNT-ERROR
; 93:       9A               BYTE #X9A                        ; RCX
; 94:       CC0A             BREAK 10                         ; error trap
; 96:       04               BYTE #X04
; 97:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 98:       FE1B01           BYTE #XFE, #X1B, #X01            ; RDX
; 9B:       CC0A             BREAK 10                         ; error trap
; 9D:       04               BYTE #X04
; 9E:       08               BYTE #X08                        ; OBJECT-NOT-FIXNUM-ERROR
; 9F:       FE9B03           BYTE #XFE, #X9B, #X03            ; RDI
NIL
</code></pre>

<p>はい。見事にSARとSHLが消えましたね。</p>

<h1>もう少し複雑な型を扱う</h1>

<p>アセンブラですし<code>(simple-array (unsigned-byte 8) (*))</code>(以下octets)を扱いたいですよね。とりあえず難しいことは考えずにoctetsの0番目の要素にアクセスしてみましょう。とはいっても<code>simple-array</code>は長さや要素の型の情報も持っていることが予想されるので少しデータを読み飛ばさないといけませんね。</p>

<p>その辺の計算が分からなかったのでsbclのソースからそれっぽいものを参考にしました。</p>

<p>```lisp
(defknown access-simple-array-0 ((simple-array (unsigned-byte 8) (*)))</p>

<pre><code>(unsigned-byte 8)
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::access-simple-array-0)
  (:translate vop-sample::access-simple-array-0)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg)))
  (:arg-types *)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4</p>

<pre><code>          (inst movzx r 
           (make-ea :byte :base x
                    :disp (- (* vector-data-offset n-word-bytes)
                           other-pointer-lowtag)))))
</code></pre>

<p>(in-package :vop-sample)
(defvar <em>octets</em> (make-array 4</p>

<pre><code>                         :element-type '(unsigned-byte 8)
                         :initial-contents '(10 11 12 13)))
</code></pre>

<p>(defun access-simple-array-0 (x)
  (access-simple-array-0 x))
```</p>

<p>こんな感じになります。境界チェックとかはやってませんが許して下さい。</p>

<p><code>descriptor-reg</code>というのがポインタが入ってるレジスタっぽいです。<code>movzx</code>は8bitの値を64bitのレジスタに符号拡張しながらロードする命令です。</p>

<p><code>make-ea</code>というのがアドレッシングですね。<code>x</code>レジスタを起点として<code>(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)</code>バイト(？ワード？)先のメモリ1byteを指します。</p>

<p>ディスアセンブルしてみましょう。みなさんもう慣れてきたと思うので主要部だけ抜き出します。</p>

<pre><code>; 65:       0FB65101         MOVZX EDX, BYTE PTR [RCX+1]      ; no-arg-parsing entry point
; 69:       48D1E2           SHL RDX, 1
</code></pre>

<p>短いですね。この<code>BYTE PTR [RCX+1]</code>が<code>make-ea</code>した値に対応します。<code>RCX</code>は<code>x</code>で<code>(- (* vector-data-offset n-word-bytes) other-pointer-lowtag)</code>の結果が1に現れてるんでしょう。補足しておくと、<code>EDX</code>と<code>RDX</code>は同じ場所を指します。32bitとして扱うときはE、64bitとして扱うときはRで指します。</p>

<p>さて、私はx86のアドレッシングモードなんて全然知らないのですがコードを見る限りもうちょっと複雑なアドレッシングが出来るようです。</p>

<p>配列のn番目にアクセスするコードが良い例のようです。</p>

<p>```lisp
(defknown access-simple-array-n ((simple-array (unsigned-byte 8) (*)) (unsigned-byte 64))</p>

<pre><code>(unsigned-byte 8)
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::access-simple-array-n)
  (:translate vop-sample::access-simple-array-n)
  (:policy :fast-safe)
  (:args (x :scs (descriptor-reg))</p>

<pre><code>     (i :scs (unsigned-reg)))
</code></pre>

<p>  (:arg-types * unsigned-num)
  (:results (r :scs (unsigned-reg)))
  (:result-types unsigned-num)
  (:generator 4</p>

<pre><code>          (inst movzx r 
           (make-ea :byte :base x
                    :scale 1
                    :index i
                    :disp (- (* vector-data-offset n-word-bytes)
                           other-pointer-lowtag)))))
</code></pre>

<p>(in-package :vop-sample)
(defun access-simple-array-n (x i)
  (access-simple-array-n x i))
```</p>

<p>新たに引数<code>i</code>をとるようになったのと<code>make-ea</code>の引数に<code>:scale 1 :index i</code>が加わってます。</p>

<p>ディスアセンブルしてみましょう。</p>

<pre><code>; 98:       0FB6543901       MOVZX EDX, BYTE PTR [RCX+RDI+1]  ; no-arg-parsing entry point
; 9D:       48D1E2           SHL RDX, 1
</code></pre>

<p>アドレッシングに<code>+RDI</code>が加わりましたね。どうして<code>i</code>(<code>RDI</code>)を<code>RAS</code>しなくていいのか気になりますがまあ、とりあえず正常に動いてるようです。</p>

<p>おわかりかと思いますがアドレッシングが<code>x</code>をベースにして今までの定数オフセット+新たにレジスタで指定したオフセットになってます。</p>

<p><code>make-ea</code>に渡した<code>:index</code>は何か分かるとしても<code>:scale</code>が気になりますよね。<code>scale</code>を2にしてディスアセンブルしてみます。</p>

<pre><code>; 58:       0FB6547901       MOVZX EDX, BYTE PTR [RCX+RDI*2+1]  ; no-arg-parsing entry point
; 5D:       48D1E2           SHL RDX, 1
</code></pre>

<p>はい。インデックスを定数倍するようですね。</p>

<h1>SSEにチャレンジ</h1>

<p>インテルアーキテクチャにあるSSEとはStreaming SIMD Extensionsの略です。じゃあSIMDは何かというとSimple Instruction Mulitple Dataの略で、1命令で複数のデータを処理出来ます。</p>

<p>この「複数のデータ」というのは64bit2つや32bit4つなどを128bitにまとめて渡します。128bitの値なんてどうやって作るんだよって感じですがsbcl-1.1.8から入った<code>sb-ext:%make-simd-pack-*</code>が存在します。</p>

<pre><code>VOP-SAMPLE&gt; (%make-simd-pack-ub32 1 2 3 4)
#&lt;SIMD-PACK  01 00 00 00  02 00 00 00  03 00 00 00  04 00 00 00&gt;
</code></pre>

<p>こんな感じです。x86_64がリトルエンディアンだったのを思い出させる表記ですね。ub32の他にub64、single、doubleが存在します。</p>

<p>ストレージクラスも<code>*-sse-reg</code>というものがあるのでこれを使いましょう。</p>

<p>```lisp
(defknown simd-add ((simd-pack (unsigned-byte 64)) (simd-pack (unsigned-byte 64)))</p>

<pre><code>(simd-pack (unsigned-byte 32))
(movable flushable always-translatable)
</code></pre>

<p>  :overwrite-fndb-silently t)
(in-package &ldquo;SB-VM&rdquo;)
(define-vop (vop-sample::simd-add)
  (:translate vop-sample::simd-add)
  (:policy :fast-safe)
  (:args (x :scs (int-sse-reg))</p>

<pre><code>     (y :scs (int-sse-reg)))
</code></pre>

<p>  (:arg-types simd-pack-int simd-pack-int)
  (:results (r :scs (int-sse-reg)))
  (:result-types simd-pack-int)
  (:generator 4</p>

<pre><code>          (move r x)
          (inst padddw r y)))
</code></pre>

<p>(in-package :vop-sample)
(defun simd-add (x y)
  (simd-add x y))
```</p>

<p>はい。こんな感じですね。<code>paddw</code>はparallel add wordですかね。これをディスアセンブルすると思ったより大きな命令になったので全部貼っときますね。</p>

<pre><code>VOP-SAMPLE&gt; (disassemble #'simd-add)

; disassembly for SIMD-ADD
; Size: 108 bytes. Origin: #x1006D64A21
; 21:       660F6FC2         MOVDQA XMM0, XMM2                ; no-arg-parsing entry point
; 25:       660FFDC1         PADDW XMM0, XMM1
; 29:       49896C2440       MOV [R12+64], RBP                ; thread.pseudo-atomic-bits
; 2E:       4D8B5C2418       MOV R11, [R12+24]                ; thread.alloc-region
; 33:       498D5320         LEA RDX, [R11+32]
; 37:       493B542420       CMP RDX, [R12+32]
; 3C:       7740             JNBE L2
; 3E:       4989542418       MOV [R12+24], RDX                ; thread.alloc-region
; 43:       498D530F         LEA RDX, [R11+15]
; 47: L0:   48C742F165030000 MOV QWORD PTR [RDX-15], 869
; 4F:       48C742F900000000 MOV QWORD PTR [RDX-7], 0
; 57:       660F7F4201       MOVDQA [RDX+1], XMM0
; 5C:       49316C2440       XOR [R12+64], RBP                ; thread.pseudo-atomic-bits
; 61:       7402             JEQ L1
; 63:       cc09             break 9                          ; pending interrupt trap
; 65: l1:   488be5           mov rsp, rbp
; 68:       f8               clc
; 69:       5d               pop rbp
; 6a:       c3               ret
; 6b:       cc0a             break 10                         ; error trap
; 6d:       02               byte #x02
; 6e:       19               byte #x19                        ; invalid-arg-count-error
; 6f:       9a               byte #x9a                        ; rcx
; 70:       cc0a             break 10                         ; error trap
; 72:       04               byte #x04
; 73:       32               byte #x32                        ; object-not-simd-pack-error
; 74:       fe1b01           byte #xfe, #x1b, #x01            ; rdx
; 77:       cc0a             break 10                         ; error trap
; 79:       04               byte #x04
; 7a:       32               byte #x32                        ; object-not-simd-pack-error
; 7b:       fe9b03           byte #xfe, #x9b, #x03            ; rdi
; 7e: l2:   6a20             push 32
; 80:       bac0854200       mov edx, 4359616                 ; alloc_tramp
; 85:       ffd2             call rdx
; 87:       5a               pop rdx
; 88:       80ca0f           or dl, 15
; 8b:       ebba             jmp l0
nil
</code></pre>

<p>なにやってるのやら。</p>

<h1>出来なかったこと</h1>

<p><code>PCMPESTRI</code>を使ってみたかったのですが扱いがトリッキーなので断念しました。具体的に言うと操作する値を格納するレジスタがEAXとECX固定なようなのです。
<code>:temporary</code>節で内部で使うレジスタも要求出来るようなのですが名指しでもらえるんですかね。</p>

<p>SSEの使い方とsimple-arrayから要素の配列を取り出す方法までは示したので誰かやって下さい。</p>

<p>参考資料いっぱい置いときますね。</p>

<p>VOPの使い方。最初の方に出てきたaddの最適化のやつとかも出てくる。(en)
: <a href="http://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/">How to Define New Intrinsics in SBCL &ndash; Paul Khuong mostly on Lisp</a></p>

<p>SBCLのsimd-packの具体的解説(en)
: <a href="http://pvk.ca/Blog/Lisp/hacking_SSE_intrinsics-part_1.html">Hacking SSE Intrinsics in SBCL (part 1) &ndash; Paul Khuong mostly on Lisp</a></p>

<p>SBCLでVOPとSSEを使ってマンデルブロ集合を計算する(en)
<a href="http://www.pvk.ca/Blog/2013/06/05/fresh-in-sbcl-1-dot-1-8-sse-intrinsics/">Fresh in SBCL 1.1.8: SSE Intrinsics! &ndash; Paul Khuong mostly on Lisp</a></p>

<p>IntelのPCMPESTRIとかのマニュアル(en)
: <a href="https://software.intel.com/en-us/node/514244">Packed Compare Intrinsics</a></p>

<p>MicrosoftのPCMPESTRIのマニュアル。こっちの方が分かりやすい(en)
<a href="http://msdn.microsoft.com/en-us/library/bb531465.aspx">_mm_cmpestri</a></p>

<p>PCMPISTRIを使った<code>strlen</code>の実装例(ja)
: <a href="http://homepage1.nifty.com/herumi/prog/intel-opt.html">Intel optimization</a></p>

<p>PCMPESTRIを使ってHTTPパーサーを高速化した話。これをやりたかった。(en)
: <a href="http://blog.kazuhooku.com/2014/12/improving-parser-performance-using-sse.html">Kazuho&rsquo;s Weblog: Improving Parser Performance using SSE Instructions (in case of PicoHTTPParser)</a></p>

<h1>おわりに</h1>

<p>おつかれ様でした。たまには低レベルなことをやっても良いんじゃないでしょうか。</p>

<p>明日はnobkzさんで、Shenについてです。</p>
]]></content>
  </entry>
  
</feed>
