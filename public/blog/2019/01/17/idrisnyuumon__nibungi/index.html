<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="Idris入門: 二分木 | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="κeenです。Idris入門: 数当てゲーム | κeenのHappy Hacκing Blogに続いて入門記事を書いてみます。
前回はバイナリを作ったので今回はライブラリを作ります。題材は(非平衡)二分木。

非平衡なのは平衡にすると複雑になるのと、平衡にするときは別のネタ(依存型)があるのでそれまでとっておくためです。" />

        <title>Idris入門: 二分木 | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css' />
        <link rel="stylesheet" href="//KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="//KeenS.github.io/css/liquorice.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="//KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="//KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="//KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="//KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
        <link rel="apple-touch-icon-precomposed" href="//KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="alternate" href="" type="application/rss+xml" title="κeenのHappy Hacκing Blog" />
        
        <script>
         (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
             (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

         ga('create', 'UA-43779888-1', 'auto');
         ga('send', 'pageview');

        </script>
        
        <link rel="stylesheet" href="//KeenS.github.io/highlight.js/styles/monokai.css" />
<script src="//KeenS.github.io/highlight.js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<link rel="stylesheet" href="//unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css">

    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="//KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="//KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="//KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="//KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="//KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="//KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                    <header class="li-article-header">
                        <h1 class="li-article-title">Idris入門: 二分木</h1>
                        <div class="li-article-meta">
    <time class="li-article-date">2019-01-17</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="//KeenS.github.io/categories/idris">Idris</a>
        </li>
    
        <li>
            <a href="//KeenS.github.io/categories/idris%e5%85%a5%e9%96%80">Idris入門</a>
        </li>
    
</ul>

</div>

                    </header>
                    <section>
                        <p>κeenです。<a href="https://keens.github.io/blog/2019/01/07/idrisnyuumon__kazuatege_mu/">Idris入門: 数当てゲーム | κeenのHappy Hacκing Blog</a>に続いて入門記事を書いてみます。
前回はバイナリを作ったので今回はライブラリを作ります。題材は(非平衡)二分木。

非平衡なのは平衡にすると複雑になるのと、平衡にするときは別のネタ(依存型)があるのでそれまでとっておくためです。</p>

<p>対象読者は前回の数当てゲームのチュートリアルを終えた人に設定します。</p>

<p>今回のコード全体像は<a href="https://gitlab.com/blackenedgold/idris-btree">こちら</a>にあります。</p>

<h1 id="プロジェクト作成">プロジェクト作成</h1>

<p>以下のような構成でディレクトリを作りましょう。</p>

<pre><code class="language-text">├── btree.ipkg
└── src
    └── BTree.idr
</code></pre>

<p>btree.ipkgには以下を書きます。</p>

<pre><code class="language-text">package btree

sourcedir = src

modules = BTree
</code></pre>

<p>そして <code>BTree.idr</code> に今から二分木を実装していきます。</p>

<h1 id="二分木とは">二分木とは</h1>

<p>二分木はデータ構造です。
値の保持、検索、削除ができるので集合やKey-Valueストアの実装に使われます。
手続き型言語ではそれらの実装にハッシュセットやハッシュマップがよく使われますが、関数型言語では二分木の方がよく使われるようです。</p>

<p>二分木はノード(節)とリーフ(葉)からなります。リーフは何もデータを持ちません。 ノードは1つの値と2つ(左右)の子(部分木)を持ちます。
ノードには「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい。」という条件が成つように作ります。</p>

<p>図にするとこんな感じでしょうか</p>

<p><img src="//KeenS.github.io/images/btree/btree.png" alt="btreeの図" /></p>

<p>1, 2, 3, 4, 5がノードに保持されている値です。一番上にあるノード(ここでは3を保持しているノード)を根と呼びます。
「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい。」という条件もちゃんと成り立っています。</p>

<p><img src="//KeenS.github.io/images/btree/ordering.png" alt="btreeの順序の図" /></p>

<p>今回は非平衡二分木なので条件はここまでです。
平衡二分木だとここからさらに「左右が大体同じくらいの高さ」という条件が付きます。</p>

<h1 id="二分木への操作">二分木への操作</h1>

<p>まずは検索と挿入を説明しましょう。</p>

<h2 id="検索">検索</h2>

<p>検索は二分探索をそのまま行えます。
例えば先程の1, 2, 3, 4, 5を保持している木に2が含まれるか検索してみましょう。</p>

<p>まず3と2を比較します。2は3より小さいので、あるとしたら左の子にあるはずです。右の子は3より大きい値しか保持していないので絶対ありません。左の子を見てみましょう。</p>

<p><img src="//KeenS.github.io/images/btree/member_1.png" alt="btreeの検索の図1" /></p>

<p>左の子は1を保持しています。2は1より大きいのであるとしたら右の子にあるはずです。右の子をみてましょう。</p>

<p><img src="//KeenS.github.io/images/btree/member_2.png" alt="btreeの検索の図2" /></p>

<p>右の子は2を保持しています。検索している値が見つかったのでこの木に2が含まれることが分かります。</p>

<p><img src="//KeenS.github.io/images/btree/member_3.png" alt="btreeの検索の図3" /></p>

<p>同様の検索をして、葉に行き当たったら検索している値はなかったということが分かります。</p>

<h2 id="挿入">挿入</h2>

<p>挿入も検索と似たようなことをします。先程の木に6という値を挿入してみましょう。</p>

<p><img src="//KeenS.github.io/images/btree/insert_1.png" alt="btreeの挿入の図1" /></p>

<p>6は3より大きいので右の子を見ます。</p>

<p><img src="//KeenS.github.io/images/btree/insert_2.png" alt="btreeの挿入の図2" /></p>

<p>右の子を見ると6は4より大きいのでさらに右の子を見ます。</p>

<p><img src="//KeenS.github.io/images/btree/insert_3.png" alt="btreeの挿入の図3" /></p>

<p>6は5より大きいので更に右の子を見ます。</p>

<p><img src="//KeenS.github.io/images/btree/insert_4.png" alt="btreeの挿入の図4" /></p>

<p>右の子はリーフなのでこの木には6がいないことが分かりました。
そこで6だけを保持する <strong>新しいノードを作ります</strong>。</p>

<p><img src="//KeenS.github.io/images/btree/insert_5.png" alt="btreeの挿入の図5" /></p>

<p>5を保持するノードの右の子を今作ったノードにした <strong>新しいノードを作ります</strong>。</p>

<p><img src="//KeenS.github.io/images/btree/insert_6.png" alt="btreeの挿入の図6" /></p>

<p>4を保持するノードの右の子を今作ったノードにした <strong>新しいノードを作ります</strong>。</p>

<p><img src="//KeenS.github.io/images/btree/insert_7.png" alt="btreeの挿入の図7" /></p>

<p>3を保持するノードの右の子を今作ったノードにした <strong>新しいノードを作ります</strong>。</p>

<p><img src="//KeenS.github.io/images/btree/insert_8.png" alt="btreeの挿入の図8" /></p>

<p>これで更新が完了しました。</p>

<p>更新というよりは挿入する値も保持した新しい木を作る操作ですね。
Idrisは純粋関数型言語なので破壊的変更ができません。
なので更新ではなく新しい値を作ることになります。そういったときに部分構造を共有できる二分木は無駄が少なく、効率的なデータ構造になるのです。
また、更新したあとも古い値が使える、データが順に保持される、などのおまけ付きです。</p>

<h1 id="二分木の実装">二分木の実装</h1>

<p>さて、座学はこのくらいにして実装していきましょう。</p>

<h2 id="データ型の定義">データ型の定義</h2>

<p>まずはデータ構造の定義です。二分木とはリーフ、または2つの子と値を持ったノードからなるのでした。
BTree.idrに以下を実装します。</p>

<pre><code class="language-idris">module BTree

data BTree a = Leaf
             | Node (BTree a) a (BTree a)
</code></pre>

<p>これは<a href="http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#data-types">データ型</a>の定義です。<code>BTree a</code> というのは <code>a</code> 型の値を保持するBTreeという意味です。ジェネリクスになってますね。
定義の中身は <code>Leaf</code> または <code>Node</code> です。 <code>Leaf</code> はデータを持ちません。 <code>Node</code> は2つの子(<code>BTree a</code>)と 値(<code>a</code>)を持ちます。
<code>Leaf</code> や <code>Node</code> のことをヴァリアントだとか列挙子だとかコンストラクタだとか呼びます。
コンストラクタの別名のとおり、<code>BTree</code> の値を作るにはこれらのコンストラクタを使います。<code>Leaf</code> は値のように、 <code>Node</code> は関数のように使えます。
数当てゲームのところで <code>Either</code> などを扱ったので馴染んでいますね。</p>

<p>REPLで少し遊んでみましょう。
まずは <code>Leaf</code> はBTreeです。</p>

<pre><code class="language-text">λΠ&gt; Leaf
(input):Can't infer argument a to Leaf
</code></pre>

<p>おっと、いきなり起こられました。<code>BTree</code> は多相(ジェネリクス)なので <code>Leaf</code> だけではパラメータの部分、 <code>BTree a</code> の <code>a</code> の部分の型が決まらないのです。
<code>BTree Integer</code> であることを明示しましょう。それには <code>the 型名 式</code> が使えます。</p>

<pre><code class="language-text">λΠ&gt; the (BTree Integer) Leaf
Leaf : BTree Integer
</code></pre>

<p>余談ですが <code>the</code> はキーワードではなくただの関数です。</p>

<pre><code class="language-text">λΠ&gt; :t the
the : (a : Type) -&gt; a -&gt; a
</code></pre>

<p>型を関数の引数に渡せてしまうところがIdrisの特徴です。</p>

<p>閑話休題。ノードの方を試してみましょう。ノードを使うといくらでも複雑な構造を作れます。</p>

<pre><code class="language-text">λΠ&gt; Node Leaf 1 Leaf
Node Leaf 1 Leaf : BTree Integer
λΠ&gt; Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf)
Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf) : BTree Integer
</code></pre>

<p>必ず最後は <code>Leaf</code> になってることが分かるかと思います。</p>

<p>ところで、以下のような定義も実行できてしまいます。</p>

<pre><code class="language-text">λΠ&gt; Node (Node Leaf 1 Leaf) 3 (Node Leaf 2 Leaf)
Node (Node Leaf 1 Leaf) 3 (Node Leaf 2 Leaf) : BTree Integer
</code></pre>

<p>これは3の右の子に2がきているので今回扱おうとしている二分木としては不適格です。</p>

<p>不適格なデータを作れてしまう問題はデータ型だけではどうしようもないのでプログラマが気をつける必要があります。</p>

<h2 id="挿入-1">挿入</h2>

<p>このデータ型に対して挿入を実装してみましょう。まずは型は木 <code>BTree a</code> と値 <code>a</code> を受け取って新しい <code>BTree a</code> を返すのでこうなりそうです。</p>

<pre><code class="language-idris">insert : BTree a -&gt; a -&gt; BTree a
</code></pre>

<p>実装の方はリーフかノードかで分岐が発生します。
以下のように書けるでしょう。</p>

<pre><code class="language-idris">insert tree x = case tree of
                  Leaf =&gt; -- ...
                  Node l v r =&gt; -- ...
</code></pre>

<p>しかし引数で分岐するときは別の記法があります。以下のように書けるのです。</p>

<pre><code class="language-idris">insert Leaf         x = -- ...
insert (Node l v r) x = -- ...
</code></pre>

<p>こちらの方がより宣言的で読みやすいスタイルだとされています。
数学の記法に似ていますね。</p>

<p>\[
\begin{align}
0! &amp; = &amp; 0 <br />
n! &amp; = &amp; n * (n-1)!
\end{algin}
\]</p>

<h3 id="余談-エディタサポート">余談: エディタサポート</h3>

<p>今の実装は実は自動化できます。
型を書いたところまで巻き戻ってみましょう。</p>

<pre><code class="language-idris">insert : BTree a -&gt; a -&gt; BTree a
</code></pre>

<p>この状態で<code>insert</code>にカーソルを合わせてaddclauseと呼ばれるコマンド(Emacsなら<code>C-c C-s</code>, Vimなら <code>\d</code>)を打つとこうなります。</p>

<pre><code class="language-idris">insert :  BTree a -&gt;  a -&gt; BTree a
insert x y = ?insert_rhs
</code></pre>

<p>変数名が適当ですが定義のモックが自動生成されました。<code>?</code> マークで始まるのは穴(Hole)と呼ばれ、「あとで実装する」のマークです。詳しくは<a href="http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#holes">ドキュメント</a>を読んで下さい。</p>

<p>名前はおいておいて、エディタサポートの話を続けます。ここでの <code>x</code> で分岐したいのでした。
<code>x</code> にカーソルを合わせてcasesplitと呼ばれるコマンド(Emacsなら <code>C-c C-c</code>, Vimなら <code>\c</code>)を打つとこうなります。</p>

<pre><code class="language-idris">insert :  BTree a -&gt;  a -&gt; BTree a
insert Leaf y = ?insert_rhs_1
insert (Node x z w) y = ?insert_rhs_2
</code></pre>

<p>ここまで自動生成できました。</p>

<p>自動生成はできたので満足ですが、生成された変数の名前が <code>x</code>, <code>y</code> と適当なのが気になりますよね。
自動生成される名前を制御するにはこのチュートリアルを大きく超える内容が必要です。
型には <code>%name</code> ディレクティブを、ヴァリアントにはGADTを使ってそれぞれこう定義したら目的を達成できます。</p>

<pre><code class="language-idris">data BTree : (a : Type) -&gt; Type where
  Leaf : BTree a
  Node : (l: BTree a) -&gt; (v: a) -&gt; (r: BTree a) -&gt; BTree a

%name BTree tree, tree1, tree2
</code></pre>

<p>これで生成したコードは以下です。</p>

<pre><code class="language-idris">insert:  BTree a -&gt;  a -&gt; BTree a
insert Leaf x = ?insert_rhs_1
insert (Node l v r) x = ?insert_rhs_2
</code></pre>

<p>記法やコンパイラ補助の違いだけで、元の記法もこちらの記法も同じデータ型を定義しているので盲目的に定義を置き換えてしまうのも手です。</p>

<hr />

<p>さて、これから実装していきましょう。
まずは<code>Leaf</code>の方です。<code>Leaf</code> なら新しい値を持ったノードで置き換えるのでした。
<code>Leaf</code> はこう実装できるでしょう。</p>

<pre><code class="language-idris">insert: Ord a =&gt; BTree a -&gt;  a -&gt; BTree a
insert Leaf x = Node Leaf x Leaf
insert (Node l v r) x = ...
</code></pre>

<p><code>Node</code> の方は大きいか小さいかで分岐が発生しますね。
先程は触れませんでしたが既に同じ値がある場合も新しくノードを作って返すことにします。
比較の3種類の分岐は <code>compare</code> が便利でした。早速こう書いてみましょう。</p>

<pre><code class="language-idris">insert: Ord a =&gt; BTree a -&gt;  a -&gt; BTree a
insert Leaf x = Node Leaf x Leaf
insert (Node l v r) x = case compare x v of
  LT =&gt; ?LT
  EQ =&gt; ?EQ
  GT =&gt; ?GT
</code></pre>

<p>しかしこれはエラーになります。</p>

<pre><code class="language-text">- + Errors (1)
 `-- BTree.idr line 18 col 24:
     When checking right hand side of insert with expected type
             BTree a
     
     Can't find implementation for Ord a

</code></pre>

<p>少し分かりづらいですが、「<code>a</code> に <code>Ord</code> の実装がない」と言っています。
ジェネリクス <code>a</code> はなんでも受け取れます。どんな型がくるか分からないので値の比較が出来る保証もありません。
比較可能かも分からない <code>a</code> を比較しているのでエラーが出ている、というのが直接的原因です。
ではどうやったら修正できるか、はインターフェースの知識が必要なのでインターフェースについて説明します。</p>

<h3 id="インターフェース">インターフェース</h3>

<p><a href="http://docs.idris-lang.org/en/latest/tutorial/interfaces.html">インターフェース</a>はデータ型間で共通の操作を定義する機能です。
インターフェースは以下の構文で定義でます。</p>

<pre><code class="language-idris">-- わかりやすさのため微妙に嘘をついてます
interface インターフェース名 対象の型 where
    関数1 : 型
    関数2 : 型
    ...
    デフォルト実装(あれば)
    ...
</code></pre>

<p><code>where</code> 以降はオフサイドルールですね。インターフェースの関数はメソッドと呼びます。
例えば色々な型の値を文字列として表示可能にするインターフェース <code>Show</code> はこう定義されています。</p>

<pre><code class="language-idris">interface Show a where
    show : a -&gt; String
</code></pre>

<p>あるいは同値比較のインターフェース <code>Eq</code> はこう定義されています。</p>

<pre><code class="language-idris">-- 括弧がついている関数名は中置記法で使われる(あまり気にしなくていいです)
interface Eq a where
    (==) : a -&gt; a -&gt; Bool
    (/=) : a -&gt; a -&gt; Bool

    x /= y = not (x == y)
    x == y = not (x /= y)
</code></pre>

<p>インターフェースは以下の構文で個々のデータ型に実装できます。</p>

<pre><code class="language-idris">インターフェース名 対象の型 where
    関数1 = 実装
    関数2 = 実装
</code></pre>

<p>適当なデータ型を定義して <code>Show</code> と <code>Eq</code> を実装してみましょう。</p>

<pre><code class="language-idris">data Camellia = Japonica | Sasanqua

Eq Camellia where
  (==) Japonica Japonica = True
  (==) Sasanqua Sasanqua = True
  (==) _        _        = False

Show Camellia where
  show Japonica = &quot;Japonica&quot;
  show Sasanqua = &quot;Sasanqua&quot;
</code></pre>

<p>そして「<code>Show</code> を実装した型を受け取る」はこう書けます。型定義の前に <code>Show a =&gt;</code> を置くのです。</p>

<pre><code class="language-idris">print : Show a =&gt; a -&gt; IO ()
print = putStr $ show
</code></pre>

<p>この型定義を読み下すなら「<code>Show</code> を実装した型 <code>a</code> に対して、 <code>a</code> を受け取って <code>IO ()</code> を返す関数」となるでしょう。</p>

<hr />

<p>ということで先程の答えが出ました。 <code>Ord</code> が目的のインターフェースなので <code>Ord a =&gt;</code> を追加すればよさそうです。
<code>insert</code> 関数の型定義に戻って <code>Ord a =&gt;</code> を追加しましょう。</p>

<pre><code class="language-idris">insert: Ord a =&gt; BTree a -&gt;  a -&gt; BTree a
</code></pre>

<p>これで比較ができるようになったのであとは実装するだけです。
等しい場合は簡単ですね。そのまま作り直すだけです。</p>

<pre><code class="language-idris">insert (Node l v r) x = case compare x v of
  LT =&gt; ?LT
  EQ =&gt; Node l v r
  GT =&gt; ?GT
</code></pre>

<p>小さい場合は左の子(<code>l</code>)を、それに <code>x</code> 挿入したもので置き換えるのでした。大きい場合はその対称ですね。
つまり実装はこうなります。</p>

<pre><code class="language-idris">insert (Node l v r) x = case compare x v of
  LT =&gt; Node (insert l x) v r
  EQ =&gt; Node         l    v r
  GT =&gt; Node         l    v (insert r x)
</code></pre>

<p><code>insert</code> が実装できました。</p>

<p>検索の方は簡単なので適当に実装して下さい。</p>

<pre><code class="language-idris">member : Ord a =&gt; BTree a -&gt; a -&gt; Bool
member Leaf x = False
member (Node l v r) x = case compare x v of
  LT =&gt; member l x
  EQ =&gt; True
  GT =&gt; member r x
</code></pre>

<p>さて、ひとまずデータを入れて検索するところまでいけました。</p>

<p>地味に、空の木を表す <code>empty</code> も作っておきましょう。</p>

<pre><code class="language-idris">empty : BTree a
empty = Leaf
</code></pre>

<p>関数ではなく値です。Idrisは純粋関数型言語なので更新される心配がなく、<code>empty</code> を値として定義して使いまわしても何も問題がありません。</p>

<p>少しREPLで試してみて下さい。 <code>:let</code> で束縛を作れるのでそれを使うと良いでしょう。</p>

<pre><code class="language-text">λΠ&gt; :let tree = insert empty 1
defined
λΠ&gt; tree
Node Leaf 1 Leaf : BTree Integer
λΠ&gt; member tree 1
True : Bool
λΠ&gt; member tree 2
False : Bool
λΠ&gt; :let tree = insert tree 3
defined
λΠ&gt; tree
Node Leaf 1 (Node Leaf 3 Leaf) : BTree Integer
λΠ&gt; member tree 1
True : Bool
λΠ&gt; member tree 2
False : Bool
λΠ&gt; member tree 3
True : Bool

</code></pre>

<h1 id="テスト">テスト</h1>

<p>機能するものができたので自動テストをしてみましょう。
テストは2, 3個の例を試して正しく動くか試す、ソフトウェアの品質検査法です。
数学の試験で2, 3個の例を試して正しい、などと書いたら正解になりませんが、明らかな誤りを見つけるにはこれでも効果はあります。</p>

<p>新しくテストディレクトリを作り、そこに <code>BTree.idr</code> を作りましょう。</p>

<pre><code class="language-text">├── btree.ipkg
└── src
    ├── BTree.idr
    └── Tests
        └── BTree.idr
</code></pre>

<p>そして <code>btree.ipkg</code> を編集します。</p>

<pre><code class="language-text">package btree

sourcedir = src

modules = BTree
        , Tests.BTree

tests = Tests.BTree.test

pkgs = contrib
</code></pre>

<p>テストモジュールをモジュールリストに加える、テストのエントリーポイントを指定する、依存パッケージにcontribを追加する、をやっています。</p>

<p><a href="https://www.idris-lang.org/docs/current/contrib_doc/">contrib</a>はIdrisコンパイラと一緒に配布されているパッケージですが、デフォルトではリンクされません。
idrisは標準ライブラリへの機能追加に保守的な方針を取っています。まずはcontribライブラリに入れ、誰が見ても必要だと判断できたらデフォルトでリンクされるpreludeやbaseに入ります。
今回はcotribにあるテストライブラリを使います。</p>

<p>さて、テストを書いていくのですが、その前に先程定義したデータ型を公開しないといけません。</p>

<h2 id="モジュールと可視性">モジュールと可視性</h2>

<p>前回のチュートリアルでモジュールについては学習したと思います。まだの人は<a href="http://docs.idris-lang.org/en/latest/tutorial/modules.html">ドキュメント</a>を読んでおいて下さい。</p>

<p>Idrisには3つの可視性の修飾子があります。</p>

<ul>
<li><code>private</code> - モジュール内でのみ見える</li>
<li><code>export</code> - モジュール外から型が見える。他言語でいうパブリックに近い</li>
<li><code>public export</code> - モジュール外から型と実装が見える。つまり実装の詳細まで公開APIになる</li>
</ul>

<p><code>public export</code> はかなり危険ですが、データ型だとコンストラクタまで公開したいケースは多々あるので便利でしょう。
今回は二分木に「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい。」という条件があります。
ユーザにコンストラクタまで公開すると条件を満たさない木を作られかねないので <code>public export</code> ではなく <code>export</code> にします。
今ある4つの定義に <code>export</code> をつけましょう。</p>

<pre><code class="language-idris">export
data BTree ..

export
empty: BTree a
...

export
insert: Ord a =&gt; BTree a -&gt;  a -&gt; BTree a

export
member : Ord a =&gt; BTree a -&gt; a -&gt; Bool
</code></pre>

<hr />

<p>さて、これでテストが書けます。
<a href="https://www.idris-lang.org/docs/current/contrib_doc/docs/Test.Unit.Assertions.html">Test.Unit.Assertions</a>を使ってテストを書いてみましょう。
Tests/BTree.idrにこう書きます。</p>

<pre><code class="language-idris">module Tests.BTree

import BTree
import Test.Unit.Assertions


testInsertMember : IO ()
testInsertMember =
  let tree = insert empty 1 in
  let tree = insert tree 5 in
  let tree = insert tree 3 in
  do
    assertTrue $ member tree 1
    assertTrue $ member tree 5
    assertTrue $ member tree 3
    pure ()

</code></pre>

<p><code>assertTrue</code> を使って <code>insert</code> して <code>member</code> したら存在するということをテストしています。
<code>let 変数 = 式1 in 式2</code> はローカル変数を導入する構文です。
ネストするときはこのようにインデントを揃えると見慣れたコードに近くなります。</p>

<p>最後にテストのエントリーポイントを書きます。</p>

<pre><code class="language-idris">export
test : IO ()
test = do
  testInsertMember
</code></pre>

<p><code>test</code> はipkgで指定した名前です。</p>

<p>このテストを走らせます。コマンドラインで <code>idris --testpkg btree.ipkg</code> を打つとテストが走ります。</p>

<pre><code class="language-console">$ idris --testpkg btree.ipkg
Entering directory `./src'
Type checking /tmp/idris74355-0.idr
Test: Assert True
Test: Assert True
Test: Assert True
Leaving directory `./src'
</code></pre>

<p>上手くいっているようです。</p>

<p>テストをもう少し追加しましょう。 <code>insert</code> してない値を <code>member</code> したら <code>False</code> になるテストです。
テストを書き、</p>

<pre><code class="language-idris">testNotInsertMember : IO ()
testNotInsertMember =
  let tree = insert empty 1 in
  let tree = insert tree 5 in
  let tree = insert tree 3 in
  do
    assertFalse $ member tree 2
    assertFalse $ member tree 4
    pure ()
</code></pre>

<p>エントリーポイントに追加し、</p>

<pre><code class="language-idris">export
test : IO ()
test = do
  testInsertMember
  testNotInsertMember
</code></pre>

<p>実行します。</p>

<pre><code class="language-console">$ idris --testpkg btree.ipkg
Entering directory `./src'
Type checking ./Tests/BTree.idr
Type checking /tmp/idris74537-0.idr
Test: Assert True
Test: Assert True
Test: Assert True
Test: Assert False
Test: Assert False
Leaving directory `./src'
</code></pre>

<p>問題ないですね。</p>

<h1 id="削除">削除</h1>

<p>削除はまず検索と同じ要領で要素を見つけます。
例えば3を削除するとしましょう。3は簡単に見つかります。</p>

<p><img src="//KeenS.github.io/images/btree/delete_1.png" alt="btreeの削除の図1" /></p>

<p>ここから3以外(要は左右の子)で新しく木を作ります。</p>

<p><img src="//KeenS.github.io/images/btree/delete_2.png" alt="btreeの削除の図2" /></p>

<p>ノードを1つ追加すれば出来るのですが、ノードに保持する値が必要です。
左の子の最大値を持ってきてあげると上手くいきます。</p>

<p><img src="//KeenS.github.io/images/btree/delete_3.png" alt="btreeの削除の図3" /></p>

<p>これにはサブルーチン、<code>popMax</code>を使います。 「ノードの値が木の最大値である⇒右の子がリーフ」なので簡単に発見、削除できます。
ずっと右の子を辿っていって右の子がリーフであるノードを見つけたらそのノードの値が最大値です。
空の木の場合は最大値がないので注意しましょう。</p>

<pre><code class="language-idris">export
popMax : BTree a -&gt; (BTree a, Maybe a)
popMax Leaf = (Leaf, Nothing)
popMax (Node l v Leaf) = (l, Just v)
popMax (Node l v r) = let (r', max) = popMax r in
                         (Node l v r', max)
</code></pre>

<p>ここで <code>(BTree a, Maybe a)</code> と書いてあるのはタプル(組)の型です。 簡易版構造体のようなもので、複数の値をひとまとめにできます。そして <code>(Leaf, Nothing)</code> のように書いてあるのがタプルの値です。
今更ですが、ちょくちょく出てきていた <code>()</code> は空のタプルのことでした。</p>

<p>この <code>popMax</code> を使うと <code>delete</code> はこう書けます。 <code>member</code> とほとんど似た見た目ですが <code>EQ</code> の腕で <code>popMax</code> を呼ぶようになっています。</p>

<pre><code class="language-idris">export
delete : Ord a =&gt; BTree a -&gt; a  -&gt; BTree a
delete Leaf x = Leaf
delete (Node l v r) x = case compare x v of
  LT =&gt; Node (delete l x)  v r
  GT =&gt; Node l v (delete r x)
  EQ =&gt; case popMax l of
        (l', Just max) =&gt; Node l' max r
        (l', Nothing) =&gt; r -- l' = Leaf
</code></pre>

<p>これもテストしておきましょう。</p>

<pre><code class="language-idris">testDelete : IO ()
testDelete =
  let tree = insert (the (BTree Integer) empty) 1 in
  let tree = insert tree 5 in
  let tree = insert tree 3 in
  do
    assertTrue $ member tree 1
    let tree = delete tree 1
    assertFalse $ member tree 1
    pure ()

testPopMax : IO ()
testPopMax =
  let tree = insert empty 1 in
  let tree = insert tree 5 in
  let tree = insert tree 3 in
  do
    let (tree, max) = popMax tree
    assertEquals max (Just 5)
    let (tree, max) = popMax tree
    assertEquals max (Just 3)
    let (tree, max) = popMax tree
    assertEquals max (Just 1)
    let (tree, max) = popMax tree
    assertEquals max Nothing
    pure ()


export
test : IO ()
test = do
  -- ...
  testPopMax
  testDelete

</code></pre>

<p>練習問題として <code>popMin</code> も実装してみて下さい。</p>

<h1 id="雑多な操作">雑多な操作</h1>

<p>二分木には色々な操作ができます。</p>

<h2 id="最大値-最小値">最大値、最小値</h2>

<p>例えば最大値、最小値は簡単に求まります。<code>popMax</code>, <code>popMin</code> の亜種ですね。</p>

<pre><code class="language-idris">export
max: BTree a -&gt; Maybe a
max Leaf = Nothing
max (Node _ v Leaf) = Just v
max (Node _ _ r) = max r

export
min: BTree a -&gt; Maybe a
min Leaf = Nothing
min (Node Leaf v _) = Just v
min (Node l _ _) = min l
</code></pre>

<h2 id="分割">分割</h2>

<p>木を分割してみましょう。値 <code>x</code> を取り、「<code>x</code> より小さい値を含んだ木、<code>x</code> が含まれれば <code>x</code> 、 <code>x</code> より大きい値を含んだ木」の3つ組を返します。</p>

<pre><code class="language-text">export
split: Ord a =&gt; BTree a -&gt; a -&gt; (BTree a, Maybe a, BTree a)
split Leaf x = (Leaf, Nothing, Leaf)
split (Node l v r) x = case compare x v of
  LT =&gt; let (ll, lv, lr) = split l x in (ll, lv, Node lr v r)
  EQ =&gt; (l, Just v, r)
  GT =&gt; let (rl, rv, rr) = split r x in (Node l v rl, rv, rr)
</code></pre>

<h2 id="foldabe"><code>Foldabe</code></h2>

<p><a href="https://www.idris-lang.org/docs/current/base_doc/docs/Prelude.Foldable.html"><code>Foldable</code></a> というインターフェースがプレリュードで定義されています。</p>

<pre><code class="language-idris">||| The `Foldable` interface describes how you can iterate over the
||| elements in a parameterised type and combine the elements
||| together, using a provided function, into a single result.
|||
||| @t The type of the 'Foldable' parameterised type.
interface Foldable (t : Type -&gt; Type) where

  ||| Successively combine the elements in a parameterised type using
  ||| the provided function, starting with the element that is in the
  ||| final position i.e. the right-most position.
  |||
  ||| @func  The function used to 'fold' an element into the accumulated result.
  ||| @input The parameterised type.
  ||| @init  The starting value the results are being combined into.
  foldr : (func : elem -&gt; acc -&gt; acc) -&gt; (init : acc) -&gt; (input : t elem) -&gt; acc

  ||| The same as `foldr` but begins the folding from the element at
  ||| the initial position in the data structure i.e. the left-most
  ||| position.
  |||
  ||| @func  The function used to 'fold' an element into the accumulated result.
  ||| @input The parameterised type.
  ||| @init  The starting value the results are being combined into.
  foldl : (func : acc -&gt; elem -&gt; acc) -&gt; (init : acc) -&gt; (input : t elem) -&gt; acc
  foldl f z t = foldr (flip (.) . flip f) id t z

</code></pre>

<p><code>foldl</code> 、 <code>foldr</code> は概ねループをする関数です。<code>foldl</code> が左から、 <code>foldre</code> が右からの巡回です。
<code>foldl</code> は数当てゲームで使いましたね。
<code>Foldable</code> は他言語でいう <code>Iterable</code> みたいなものです。ただし関数型風味です。
変更可能な状態を持てないので外部イテレータではなく内部イテレータで定義されています。そしてループの途中の計算状態 <code>acc</code> を持ち回ります。</p>

<p>これを二分木に実装しましょう。<code>foldl</code> は 「まず左、値、そして右」の順(通りがけ順)に走査していけばよさそうです。</p>

<p><img src="//KeenS.github.io/images/btree/inorder.png" alt="btreeのfoldlの図" /></p>

<p><code>foldr</code> はその対称ですね。
素直にこう実装できます。</p>

<pre><code class="language-idris">Foldable BTree where
  foldr f init Leaf = init
  foldr f init (Node l v r) =
    let r = foldr f init r in
    let v = f v r in
    foldr f v l
  foldl f init Leaf = init
  foldl f init (Node l v r) =
    let l = foldl f init l in
    let v = f l v in
    foldl f v r
</code></pre>

<p>これを用いてリストとの相互変換を実装してみましょう。
煩雑だった値の構築が少し楽になります。</p>

<pre><code class="language-idris">export
toList: BTree a -&gt; List a
toList tree = foldr (::) [] tree

export
toTree: Ord a =&gt; List a -&gt; BTree a
toTree xs = foldl insert empty xs
</code></pre>

<p>ここで、 <code>(::)</code> はリストのコンストラクタです。</p>

<pre><code class="language-text">λΠ&gt; the (List Integer) $ 1 :: 2 :: 3 :: []
[1, 2, 3] : List Integer
</code></pre>

<h2 id="fold"><code>fold</code></h2>

<p>先程の <code>foldr</code>, <code>foldl</code> とは別に <code>fold</code> という関数が定義できます。
<code>BTree</code> は以下のように定義されているのでした。</p>

<pre><code class="language-idris">data BTree a = Leaf
             | Node (BTree a) a (BTree a)

</code></pre>

<p><code>BTree</code> は定数 <code>Leaf</code> と3引数関数 <code>Node</code> で構成されているとも読めます。<code>fold</code> は この構成子を別の定数と3引数関数で置き換えてあげる操作です。
リストは <code>foldr</code> がそのまま <code>fold</code> に対応するのですが <code>BTree</code> はそうではないので自分で定義します。</p>

<pre><code class="language-idris">export
fold: BTree a -&gt; b -&gt; (b -&gt; a -&gt; b -&gt; b) -&gt; b
fold  Leaf  x f = x
fold  (Node l v r)  x f = f (fold  l x f) v (fold r x f)
</code></pre>

<p><code>Leaf</code> -&gt; <code>x</code> 、 <code>Node</code> -&gt; <code>f</code> を再帰的にやっているのが見て取れると思います。</p>

<p><code>fold</code> を使っていくつか関数を定義してみましょう。</p>

<p>木のサイズ(保持している要素数)はこう定義できます。</p>

<pre><code class="language-idris">export
size : BTree a -&gt; Integer
size tree = fold tree 0 (\l, _, r =&gt; l + 1 + r)
</code></pre>

<p>木の高さは以下のように定義できます</p>

<ul>
<li>リーフの高さは0である</li>
<li>ノードの高さは左右の子の高さのうち大きい方+1である</li>
</ul>

<p>これも同様に <code>fold</code> で求められます。</p>

<pre><code class="language-idris">export
height : BTree a -&gt; Integer
height t = fold t 0 (\lh,_,rh =&gt; (max lh rh) + 1)
</code></pre>

<p>これは一番深い方を求めています。浅い方を求めるのも考えられるのでそれも実装してみましょう。</p>

<pre><code class="language-idris">export
maxHeight : BTree a -&gt; Integer
maxHeight t = fold t 0 (\lh,_,rh =&gt; (max lh rh) + 1)

export
minHeight : BTree a -&gt; Integer
minHeight t = fold t 0 (\lh,_,rh =&gt; (min lh rh) + 1)

export
height : BTree a -&gt; Integer
height = maxHeight
</code></pre>

<h3 id="余談-fold-の一般化">余談: <code>fold</code> の一般化</h3>

<p><code>fold</code> は<code>BTree</code>やリストに限らず色々なデータ型にも定義できますが、それをインターフェースで一般化するのはかなり難易度が上がります。
列挙子に応じて引数の数や型が変わるので共通のインターフェースが定められないのです。
やるとしたらデータ型の定義ごと管理下に置くような仕組みが必要になるでしょう。
そういうのは&rdquo;recursion scheme&rdquo;という名前で色々整備されているようです。<code>fold</code> はcatamorphismと呼ばれます。
resursion schemeは日本語でもいくつか解説があるようですが以下のブログを紹介しておきます。
<a href="http://d.hatena.ne.jp/KeisukeNakano/20060803/1153821754">#003 代数的データ型 - λx.x K S K ＠ はてな</a></p>

<h2 id="集合操作">集合操作</h2>

<p>二分木は集合のように扱えるので合併、交叉、差分などの操作も欲しくなりますよね。</p>

<p><code>foldl</code> を使うと簡単に実装できます。</p>

<pre><code class="language-idris">union : Ord a =&gt; BTree a -&gt; BTree a -&gt; BTree a
union tree1 tree2 = foldl insert tree1 tree2

-- `if` 式は `if 条件 then 式 else 式` で書く
intersection : Ord a =&gt; BTree a -&gt; BTree a -&gt; BTree a
intersection tree1 tree2 = foldl (\acc,elm =&gt; if member tree1 elm
                                              then insert acc elm
                                              else acc)
                                 empty tree2

difference : Ord a =&gt; BTree a -&gt; BTree a -&gt; BTree a
difference tree1 tree2 = foldl delete tree1 tree2

</code></pre>

<p><code>union</code> は少し良くない点があるのですが気にしないことにしましょう。</p>

<hr />

<p>さて、これらの雑多な操作のテストも書いておきましょう。</p>

<pre><code class="language-idris">testToTreeMember : IO ()
testToTreeMember =
  let tree = toTree [1, 5, 3] in
  do
    assertTrue $ member tree 1
    assertTrue $ member tree 5
    assertTrue $ member tree 3
    pure ()

testToTreeToList : IO ()
testToTreeToList =
  let tree = toTree [1, 5, 3] in
  let list = toList tree in
  do
    assertEquals list [1, 3, 5]
    pure ()

testMax : IO ()
testMax =
  let tree = toTree [1, 4, 3, 5, 2] in
  do
    assertEquals (max tree) (Just 5)
    pure ()

testMin : IO ()
testMin =
  let tree = toTree [1, 4, 3, 5, 2] in
  do
    assertEquals (min tree) (Just 1)
    pure ()

testSplit1 : IO ()
testSplit1 =
  let tree = toTree [1, 5, 3, 2, 4] in
  let (l, v ,r) = split tree 3 in
  do
    assertEquals (toList l) [1, 2]
    assertEquals v (Just 3)
    assertEquals (toList r) [4, 5]
    pure ()

testSplit2 : IO ()
testSplit2 =
  let tree = toTree [1, 5, 2, 4] in
  let (l, v ,r) = split tree 3 in
  do
    assertEquals (toList l) [1, 2]
    assertEquals v Nothing
    assertEquals (toList r) [4, 5]
    pure ()

testSplit3 : IO ()
testSplit3 =
  let tree = toTree [1, 5, 2, 4] in
  let (l, v ,r) = split tree 6 in
  do
    assertEquals (toList l) [1, 2, 4, 5]
    assertEquals v Nothing
    assertEquals (toList r) []
    pure ()

testSplit4 : IO ()
testSplit4 =
  let tree = toTree [1, 5, 2, 4] in
  let (l, v ,r) = split tree 0 in
  do
    assertEquals (toList l) []
    assertEquals v Nothing
    assertEquals (toList r) [1, 2, 4, 5]
    pure ()


testSplit : IO ()
testSplit = do
  testSplit1
  testSplit2
  testSplit3
  testSplit4


testUnion : IO ()
testUnion =
  let tree1 = toTree [1, 3, 5] in
  let tree2 = toTree [2, 3, 4] in
  let tree = union tree1 tree2 in
  do
    assertEquals (toList tree) [1, 2, 3, 4, 5]
    pure ()


export
test : IO ()
test = do
  -- ...
  testToTreeMember
  testToTreeToList
  testMax
  testMin
  testSplit
  testUnion

</code></pre>

<h1 id="パッケージを整える">パッケージを整える</h1>

<p>btree.ipkgには最低限の内容しか書いてませんでした。色々埋めましょう。</p>

<pre><code class="language-text">brief = &quot;A non-balanced Binary Tree library&quot;
version = &quot;0.1.0&quot;
readme = &quot;README.md&quot;
license = &quot;MIT&quot;
author = &quot;κeen&quot;
maintainer = &quot;κeen&quot;
sourceloc = &quot;https://gitlab.com/blackenedgold/idris-btree&quot;
bugtracker = &quot;https://gitlab.com/blackenedgold/idris-btree/issues&quot;
</code></pre>

<p>ドキュメントを生成してみましょう。</p>

<pre><code class="language-console">$ idris --mkdoc btree.ipkg
</code></pre>

<p><code>btree_doc/index.html</code> を開くとドキュメントを確認できます。</p>

<p>あとは <code>.gitignore</code> を書いて適当にコミットしましょう。</p>

<pre><code class="language-gitignore">*.ibc
btree_doc
</code></pre>

<p>コードホスティングサービスにGitLabを使うならGitLab CIで以下のようにテスト/ドキュメント生成ができます。</p>

<pre><code class="language-yaml"># インターネットに転がっていたイメージ
# 得体のしれないイメージを使いたくない人は自分でイメージを作ると良い
image: mmhelloworld/idris:1.3.1

test:
  script:
    - idris --testpkg btree.ipkg

pages:
  script:
    - idris --mkdoc btree.ipkg
    # docker内で生成するとパーミッションの問題が発生するらしく、ディレクトリを一旦作り直すと解決する
    - mkdir public
    - cp -R btree_doc/* public
  artifacts:
    paths:
      - public
  only:
    - master
</code></pre>

<p>生成されたドキュメントは<a href="https://blackenedgold.gitlab.io/idris-btree/">こちら</a>。
GitHubでも外部サービスやGitHub Actionsで同様にはできると思います。ドキュメントの方はGitLab Pagesとは違って一苦労必要そうですが。</p>

<h1 id="まとめ">まとめ</h1>

<p>このチュートリアルでは二分木のライブラリを作りつつIdrisでのデータ型の定義、インターフェース、テスト、パッケージなどについて学びました。</p>
                    </section>
                </article>
            </div>
        </div>

        <div class="row li-author">
    <div class="sixteen columns">
        Written by <strong>κeen</strong>
    </div>
</div>


        <div class="row li-pagination">
            <div class="eight columns">
                <div class="li-pagination-previous">
                    
                        Later article<br />
                        <a href="//KeenS.github.io/blog/2019/01/21/puroguraminguwomokutekinishitemoiitoomou/"> プログラミングを目的にしてもいいと思う</a>
                    
                </div>
            </div>
            <div class="eight columns">
                <div class="li-pagination-next">
                    
                        Older article<br />
                        <a href="//KeenS.github.io/slide/void/"> void</a>
                    
                </div>
            </div>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2019. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="https://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

    <script type="text/javascript">
    <!--
    function toggle(id) {
        var e = document.getElementById(id);
        e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
    }
    
    </script>
    <script type="text/javascript">
     <!--
                                   var _gaq = _gaq || [];
     _gaq.push(['_setAccount', ""]);
     _gaq.push(['_trackPageview']);

     (function() {
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
     })();
    
    </script>
    <script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>

