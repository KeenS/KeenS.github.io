<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="Idris入門: 二分木 | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="κeenです。Idris入門: 数当てゲーム | κeenのHappy Hacκing Blogに続いて入門記事を書いてみます。
前回はバイナリを作ったので今回はライブラリを作ります。題材は(非平衡)二分木。" />
        <meta property="og:title" content="Idris入門: 二分木 | κeenのHappy Hacκing Blog" />
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https://https://KeenS.github.io/blog/2019/01/17/idrisnyuumon__nibungi/" />
        <meta property="og:description" content="κeenです。Idris入門: 数当てゲーム | κeenのHappy Hacκing Blogに続いて入門記事を書いてみます。
前回はバイナリを作ったので今回はライブラリを作ります。題材は(非平衡)二分木。" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta property="og:image" content="https://KeenS.github.io/images/ogp/post/Idrisnyuumon__nibungi.png" />
        <meta name="twitter:image" content="https://KeenS.github.io/images/ogp/post/Idrisnyuumon__nibungi.png" />
        
        <meta property="og:article:published_time" content="2019-01-17 23:34:55 &#43;0900 JST" />
        <meta property="og:article:modified_time" content="2019-01-17 23:34:55 &#43;0900 JST" />
        
        <meta property="og:article:author" content="κeen" />

        <title>Idris入門: 二分木 | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css' />
        <link rel="stylesheet" href="https://KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/liquorice.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="https://KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="https://KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="https://KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
        <link rel="apple-touch-icon-precomposed" href="https://KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/syntax-monokai.css" />
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<link rel="stylesheet" href="//unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css">

    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="https://KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="https://KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="https://KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                    <header class="li-article-header">
                        <h1 class="li-article-title">Idris入門: 二分木</h1>
                        <div class="li-article-meta">
    <time class="li-article-date">2019-01-17</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="https://KeenS.github.io/categories/idris">Idris</a>
        </li>
    
        <li>
            <a href="https://KeenS.github.io/categories/idris%e5%85%a5%e9%96%80">Idris入門</a>
        </li>
    
</ul>

</div>

                    </header>
                    <section>
                        <p>κeenです。<a href="https://keens.github.io/blog/2019/01/07/idrisnyuumon__kazuatege_mu/">Idris入門: 数当てゲーム | κeenのHappy Hacκing Blog</a>に続いて入門記事を書いてみます。
前回はバイナリを作ったので今回はライブラリを作ります。題材は(非平衡)二分木。</p>

<p>非平衡なのは平衡にすると複雑になるのと、平衡にするときは別のネタ(依存型)があるのでそれまでとっておくためです。</p>

<p>対象読者は前回の数当てゲームのチュートリアルを終えた人に設定します。</p>

<p>今回のコード全体像は<a href="https://gitlab.com/blackenedgold/idris-btree">こちら</a>にあります。</p>

<h1 id="プロジェクト作成">プロジェクト作成</h1>

<p>以下のような構成でディレクトリを作りましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">├── btree.ipkg
└── src
    └── BTree.idr</code></pre></div>
<p>btree.ipkgには以下を書きます。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">package btree

sourcedir = src

modules = BTree</code></pre></div>
<p>そして <code>BTree.idr</code> に今から二分木を実装していきます。</p>

<h1 id="二分木とは">二分木とは</h1>

<p>二分木はデータ構造です。
値の保持、検索、削除ができるので集合やKey-Valueストアの実装に使われます。
手続き型言語ではそれらの実装にハッシュセットやハッシュマップがよく使われますが、関数型言語では二分木の方がよく使われるようです。</p>

<p>二分木はノード(節)とリーフ(葉)からなります。リーフは何もデータを持ちません。 ノードは1つの値と2つ(左右)の子(部分木)を持ちます。
ノードには「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい。」という条件が成つように作ります。</p>

<p>図にするとこんな感じでしょうか</p>

<p><img src="https://KeenS.github.io/images/btree/btree.png" alt="btreeの図" /></p>

<p>1, 2, 3, 4, 5がノードに保持されている値です。一番上にあるノード(ここでは3を保持しているノード)を根と呼びます。
「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい。」という条件もちゃんと成り立っています。</p>

<p><img src="https://KeenS.github.io/images/btree/ordering.png" alt="btreeの順序の図" /></p>

<p>今回は非平衡二分木なので条件はここまでです。
平衡二分木だとここからさらに「左右が大体同じくらいの高さ」という条件が付きます。</p>

<h1 id="二分木への操作">二分木への操作</h1>

<p>まずは検索と挿入を説明しましょう。</p>

<h2 id="検索">検索</h2>

<p>検索は二分探索をそのまま行えます。
例えば先程の1, 2, 3, 4, 5を保持している木に2が含まれるか検索してみましょう。</p>

<p>まず3と2を比較します。2は3より小さいので、あるとしたら左の子にあるはずです。右の子は3より大きい値しか保持していないので絶対ありません。左の子を見てみましょう。</p>

<p><img src="https://KeenS.github.io/images/btree/member_1.png" alt="btreeの検索の図1" /></p>

<p>左の子は1を保持しています。2は1より大きいのであるとしたら右の子にあるはずです。右の子をみてましょう。</p>

<p><img src="https://KeenS.github.io/images/btree/member_2.png" alt="btreeの検索の図2" /></p>

<p>右の子は2を保持しています。検索している値が見つかったのでこの木に2が含まれることが分かります。</p>

<p><img src="https://KeenS.github.io/images/btree/member_3.png" alt="btreeの検索の図3" /></p>

<p>同様の検索をして、葉に行き当たったら検索している値はなかったということが分かります。</p>

<h2 id="挿入">挿入</h2>

<p>挿入も検索と似たようなことをします。先程の木に6という値を挿入してみましょう。</p>

<p><img src="https://KeenS.github.io/images/btree/insert_1.png" alt="btreeの挿入の図1" /></p>

<p>6は3より大きいので右の子を見ます。</p>

<p><img src="https://KeenS.github.io/images/btree/insert_2.png" alt="btreeの挿入の図2" /></p>

<p>右の子を見ると6は4より大きいのでさらに右の子を見ます。</p>

<p><img src="https://KeenS.github.io/images/btree/insert_3.png" alt="btreeの挿入の図3" /></p>

<p>6は5より大きいので更に右の子を見ます。</p>

<p><img src="https://KeenS.github.io/images/btree/insert_4.png" alt="btreeの挿入の図4" /></p>

<p>右の子はリーフなのでこの木には6がいないことが分かりました。
そこで6だけを保持する <strong>新しいノードを作ります</strong>。</p>

<p><img src="https://KeenS.github.io/images/btree/insert_5.png" alt="btreeの挿入の図5" /></p>

<p>5を保持するノードの右の子を今作ったノードにした <strong>新しいノードを作ります</strong>。</p>

<p><img src="https://KeenS.github.io/images/btree/insert_6.png" alt="btreeの挿入の図6" /></p>

<p>4を保持するノードの右の子を今作ったノードにした <strong>新しいノードを作ります</strong>。</p>

<p><img src="https://KeenS.github.io/images/btree/insert_7.png" alt="btreeの挿入の図7" /></p>

<p>3を保持するノードの右の子を今作ったノードにした <strong>新しいノードを作ります</strong>。</p>

<p><img src="https://KeenS.github.io/images/btree/insert_8.png" alt="btreeの挿入の図8" /></p>

<p>これで更新が完了しました。</p>

<p>更新というよりは挿入する値も保持した新しい木を作る操作ですね。
Idrisは純粋関数型言語なので破壊的変更ができません。
なので更新ではなく新しい値を作ることになります。そういったときに部分構造を共有できる二分木は無駄が少なく、効率的なデータ構造になるのです。
また、更新したあとも古い値が使える、データが順に保持される、などのおまけ付きです。</p>

<h1 id="二分木の実装">二分木の実装</h1>

<p>さて、座学はこのくらいにして実装していきましょう。</p>

<h2 id="データ型の定義">データ型の定義</h2>

<p>まずはデータ構造の定義です。二分木とはリーフ、または2つの子と値を持ったノードからなるのでした。
BTree.idrに以下を実装します。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">module</span> <span class="nn">BTree</span>

<span class="kr">data</span> <span class="kt">BTree</span> a <span class="ow">=</span> <span class="kt">Leaf</span>
             <span class="ow">|</span> <span class="kt">Node</span> <span class="ow">(</span><span class="kt">BTree</span> a<span class="ow">)</span> a <span class="ow">(</span><span class="kt">BTree</span> a<span class="ow">)</span></code></pre></div>
<p>これは<a href="http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#data-types">データ型</a>の定義です。<code>BTree a</code> というのは <code>a</code> 型の値を保持するBTreeという意味です。ジェネリクスになってますね。
定義の中身は <code>Leaf</code> または <code>Node</code> です。 <code>Leaf</code> はデータを持ちません。 <code>Node</code> は2つの子(<code>BTree a</code>)と 値(<code>a</code>)を持ちます。
<code>Leaf</code> や <code>Node</code> のことをヴァリアントだとか列挙子だとかコンストラクタだとか呼びます。
コンストラクタの別名のとおり、<code>BTree</code> の値を作るにはこれらのコンストラクタを使います。<code>Leaf</code> は値のように、 <code>Node</code> は関数のように使えます。
数当てゲームのところで <code>Either</code> などを扱ったので馴染んでいますね。</p>

<p>REPLで少し遊んでみましょう。
まずは <code>Leaf</code> はBTreeです。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">λΠ&gt; Leaf
(input):Can&#39;t infer argument a to Leaf</code></pre></div>
<p>おっと、いきなり起こられました。<code>BTree</code> は多相(ジェネリクス)なので <code>Leaf</code> だけではパラメータの部分、 <code>BTree a</code> の <code>a</code> の部分の型が決まらないのです。
<code>BTree Integer</code> であることを明示しましょう。それには <code>the 型名 式</code> が使えます。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">λΠ&gt; the (BTree Integer) Leaf
Leaf : BTree Integer</code></pre></div>
<p>余談ですが <code>the</code> はキーワードではなくただの関数です。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">λΠ&gt; :t the
the : (a : Type) -&gt; a -&gt; a</code></pre></div>
<p>型を関数の引数に渡せてしまうところがIdrisの特徴です。</p>

<p>閑話休題。ノードの方を試してみましょう。ノードを使うといくらでも複雑な構造を作れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">λΠ&gt; Node Leaf 1 Leaf
Node Leaf 1 Leaf : BTree Integer
λΠ&gt; Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf)
Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf) : BTree Integer</code></pre></div>
<p>必ず最後は <code>Leaf</code> になってることが分かるかと思います。</p>

<p>ところで、以下のような定義も実行できてしまいます。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">λΠ&gt; Node (Node Leaf 1 Leaf) 3 (Node Leaf 2 Leaf)
Node (Node Leaf 1 Leaf) 3 (Node Leaf 2 Leaf) : BTree Integer</code></pre></div>
<p>これは3の右の子に2がきているので今回扱おうとしている二分木としては不適格です。</p>

<p>不適格なデータを作れてしまう問題はデータ型だけではどうしようもないのでプログラマが気をつける必要があります。</p>

<h2 id="挿入-1">挿入</h2>

<p>このデータ型に対して挿入を実装してみましょう。まずは型は木 <code>BTree a</code> と値 <code>a</code> を受け取って新しい <code>BTree a</code> を返すのでこうなりそうです。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">insert</span> <span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a</code></pre></div>
<p>実装の方はリーフかノードかで分岐が発生します。
以下のように書けるでしょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">insert tree x <span class="ow">=</span> <span class="kr">case</span> tree <span class="kr">of</span>
                  <span class="kt">Leaf</span> <span class="ow">=&gt;</span> <span class="c1">-- ...</span>
                  <span class="kt">Node</span> l v r <span class="ow">=&gt;</span> <span class="c1">-- ...</span></code></pre></div>
<p>しかし引数で分岐するときは別の記法があります。以下のように書けるのです。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">insert <span class="kt">Leaf</span>         x <span class="ow">=</span> <span class="c1">-- ...</span>
insert <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> x <span class="ow">=</span> <span class="c1">-- ...</span></code></pre></div>
<p>こちらの方がより宣言的で読みやすいスタイルだとされています。
数学の記法に似ていますね。</p>

<p>\[
\begin{align}
0! &amp; = &amp; 0 \\<br />
n! &amp; = &amp; n * (n-1)!
\end{align}
\]</p>

<h3 id="余談-エディタサポート">余談: エディタサポート</h3>

<p>今の実装は実は自動化できます。
型を書いたところまで巻き戻ってみましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">insert</span> <span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a</code></pre></div>
<p>この状態で<code>insert</code>にカーソルを合わせてaddclauseと呼ばれるコマンド(Emacsなら<code>C-c C-s</code>, Vimなら <code>\d</code>)を打つとこうなります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">insert</span> <span class="ow">:</span>  <span class="kt">BTree</span> a <span class="ow">-&gt;</span>  a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
insert x y <span class="ow">=</span> <span class="ow">?</span>insert_rhs</code></pre></div>
<p>変数名が適当ですが定義のモックが自動生成されました。<code>?</code> マークで始まるのは穴(Hole)と呼ばれ、「あとで実装する」のマークです。詳しくは<a href="http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#holes">ドキュメント</a>を読んで下さい。</p>

<p>名前はおいておいて、エディタサポートの話を続けます。ここでの <code>x</code> で分岐したいのでした。
<code>x</code> にカーソルを合わせてcasesplitと呼ばれるコマンド(Emacsなら <code>C-c C-c</code>, Vimなら <code>\c</code>)を打つとこうなります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">insert</span> <span class="ow">:</span>  <span class="kt">BTree</span> a <span class="ow">-&gt;</span>  a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
insert <span class="kt">Leaf</span> y <span class="ow">=</span> <span class="ow">?</span>insert_rhs_1
insert <span class="ow">(</span><span class="kt">Node</span> x z w<span class="ow">)</span> y <span class="ow">=</span> <span class="ow">?</span>insert_rhs_2</code></pre></div>
<p>ここまで自動生成できました。</p>

<p>自動生成はできたので満足ですが、生成された変数の名前が <code>x</code>, <code>y</code> と適当なのが気になりますよね。
自動生成される名前を制御するにはこのチュートリアルを大きく超える内容が必要です。
型には <code>%name</code> ディレクティブを、ヴァリアントにはGADTを使ってそれぞれこう定義したら目的を達成できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">BTree</span> <span class="ow">:</span> <span class="ow">(</span>a <span class="ow">:</span> <span class="kt">Type</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="nf">Leaf</span> <span class="ow">:</span> <span class="kt">BTree</span> a
  <span class="nf">Node</span> <span class="ow">:</span> <span class="ow">(</span>l<span class="ow">:</span> <span class="kt">BTree</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>v<span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>r<span class="ow">:</span> <span class="kt">BTree</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">BTree</span> a

<span class="ow">%</span>name <span class="kt">BTree</span> tree, tree1, tree2</code></pre></div>
<p>これで生成したコードは以下です。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">insert</span><span class="ow">:</span>  <span class="kt">BTree</span> a <span class="ow">-&gt;</span>  a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
insert <span class="kt">Leaf</span> x <span class="ow">=</span> <span class="ow">?</span>insert_rhs_1
insert <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> x <span class="ow">=</span> <span class="ow">?</span>insert_rhs_2</code></pre></div>
<p>記法やコンパイラ補助の違いだけで、元の記法もこちらの記法も同じデータ型を定義しているので盲目的に定義を置き換えてしまうのも手です。</p>

<hr />

<p>さて、これから実装していきましょう。
まずは<code>Leaf</code>の方です。<code>Leaf</code> なら新しい値を持ったノードで置き換えるのでした。
<code>Leaf</code> はこう実装できるでしょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">insert</span><span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span>  a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
insert <span class="kt">Leaf</span> x <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Leaf</span> x <span class="kt">Leaf</span>
insert <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> x <span class="ow">=</span> <span class="ow">...</span></code></pre></div>
<p><code>Node</code> の方は大きいか小さいかで分岐が発生しますね。
先程は触れませんでしたが既に同じ値がある場合も新しくノードを作って返すことにします。
比較の3種類の分岐は <code>compare</code> が便利でした。早速こう書いてみましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">insert</span><span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span>  a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
insert <span class="kt">Leaf</span> x <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Leaf</span> x <span class="kt">Leaf</span>
insert <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> x <span class="ow">=</span> <span class="kr">case</span> compare x v <span class="kr">of</span>
  <span class="kt">LT</span> <span class="ow">=&gt;</span> <span class="ow">?</span><span class="kt">LT</span>
  <span class="kt">EQ</span> <span class="ow">=&gt;</span> <span class="ow">?</span><span class="kt">EQ</span>
  <span class="kt">GT</span> <span class="ow">=&gt;</span> <span class="ow">?</span><span class="kt">GT</span></code></pre></div>
<p>しかしこれはエラーになります。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">- + Errors (1)
 `-- BTree.idr line 18 col 24:
     When checking right hand side of insert with expected type
             BTree a
     
     Can&#39;t find implementation for Ord a</code></pre></div>
<p>少し分かりづらいですが、「<code>a</code> に <code>Ord</code> の実装がない」と言っています。
ジェネリクス <code>a</code> はなんでも受け取れます。どんな型がくるか分からないので値の比較が出来る保証もありません。
比較可能かも分からない <code>a</code> を比較しているのでエラーが出ている、というのが直接的原因です。
ではどうやったら修正できるか、はインターフェースの知識が必要なのでインターフェースについて説明します。</p>

<h3 id="インターフェース">インターフェース</h3>

<p><a href="http://docs.idris-lang.org/en/latest/tutorial/interfaces.html">インターフェース</a>はデータ型間で共通の操作を定義する機能です。
インターフェースは以下の構文で定義でます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">-- わかりやすさのため微妙に嘘をついてます</span>
interface インターフェース名 対象の型 <span class="kr">where</span>
    <span class="nf">関数1</span> <span class="ow">:</span> 型
    <span class="nf">関数2</span> <span class="ow">:</span> 型
    <span class="ow">...</span>
    デフォルト実装<span class="ow">(</span>あれば<span class="ow">)</span>
    <span class="ow">...</span></code></pre></div>
<p><code>where</code> 以降はオフサイドルールですね。インターフェースの関数はメソッドと呼びます。
例えば色々な型の値を文字列として表示可能にするインターフェース <code>Show</code> はこう定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">interface <span class="kt">Show</span> a <span class="kr">where</span>
    <span class="nf">show</span> <span class="ow">:</span> a <span class="ow">-&gt;</span> <span class="kt">String</span></code></pre></div>
<p>あるいは同値比較のインターフェース <code>Eq</code> はこう定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">-- 括弧がついている関数名は中置記法で使われる(あまり気にしなくていいです)</span>
interface <span class="kt">Eq</span> a <span class="kr">where</span>
    <span class="ow">(==)</span> <span class="ow">:</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="ow">(/=)</span> <span class="ow">:</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Bool</span>

    x <span class="ow">/=</span> y <span class="ow">=</span> not <span class="ow">(</span>x <span class="ow">==</span> y<span class="ow">)</span>
    x <span class="ow">==</span> y <span class="ow">=</span> not <span class="ow">(</span>x <span class="ow">/=</span> y<span class="ow">)</span></code></pre></div>
<p>インターフェースは以下の構文で個々のデータ型に実装できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">インターフェース名 対象の型 <span class="kr">where</span>
    関数1 <span class="ow">=</span> 実装
    関数2 <span class="ow">=</span> 実装</code></pre></div>
<p>適当なデータ型を定義して <code>Show</code> と <code>Eq</code> を実装してみましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Camellia</span> <span class="ow">=</span> <span class="kt">Japonica</span> <span class="ow">|</span> <span class="kt">Sasanqua</span>

<span class="kt">Eq</span> <span class="kt">Camellia</span> <span class="kr">where</span>
  <span class="ow">(==)</span> <span class="kt">Japonica</span> <span class="kt">Japonica</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="ow">(==)</span> <span class="kt">Sasanqua</span> <span class="kt">Sasanqua</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="ow">(==)</span> <span class="kr">_</span>        <span class="kr">_</span>        <span class="ow">=</span> <span class="kt">False</span>

<span class="kt">Show</span> <span class="kt">Camellia</span> <span class="kr">where</span>
  show <span class="kt">Japonica</span> <span class="ow">=</span> <span class="s">&#34;Japonica&#34;</span>
  show <span class="kt">Sasanqua</span> <span class="ow">=</span> <span class="s">&#34;Sasanqua&#34;</span></code></pre></div>
<p>そして「<code>Show</code> を実装した型を受け取る」はこう書けます。型定義の前に <code>Show a =&gt;</code> を置くのです。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">print</span> <span class="ow">:</span> <span class="kt">Show</span> a <span class="ow">=&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="ow">()</span>
print <span class="ow">=</span> putStr <span class="ow">$</span> show</code></pre></div>
<p>この型定義を読み下すなら「<code>Show</code> を実装した型 <code>a</code> に対して、 <code>a</code> を受け取って <code>IO ()</code> を返す関数」となるでしょう。</p>

<hr />

<p>ということで先程の答えが出ました。 <code>Ord</code> が目的のインターフェースなので <code>Ord a =&gt;</code> を追加すればよさそうです。
<code>insert</code> 関数の型定義に戻って <code>Ord a =&gt;</code> を追加しましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">insert</span><span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span>  a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a</code></pre></div>
<p>これで比較ができるようになったのであとは実装するだけです。
等しい場合は簡単ですね。そのまま作り直すだけです。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">insert <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> x <span class="ow">=</span> <span class="kr">case</span> compare x v <span class="kr">of</span>
  <span class="kt">LT</span> <span class="ow">=&gt;</span> <span class="ow">?</span><span class="kt">LT</span>
  <span class="kt">EQ</span> <span class="ow">=&gt;</span> <span class="kt">Node</span> l v r
  <span class="kt">GT</span> <span class="ow">=&gt;</span> <span class="ow">?</span><span class="kt">GT</span></code></pre></div>
<p>小さい場合は左の子(<code>l</code>)を、それに <code>x</code> 挿入したもので置き換えるのでした。大きい場合はその対称ですね。
つまり実装はこうなります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">insert <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> x <span class="ow">=</span> <span class="kr">case</span> compare x v <span class="kr">of</span>
  <span class="kt">LT</span> <span class="ow">=&gt;</span> <span class="kt">Node</span> <span class="ow">(</span>insert l x<span class="ow">)</span> v r
  <span class="kt">EQ</span> <span class="ow">=&gt;</span> <span class="kt">Node</span>         l    v r
  <span class="kt">GT</span> <span class="ow">=&gt;</span> <span class="kt">Node</span>         l    v <span class="ow">(</span>insert r x<span class="ow">)</span></code></pre></div>
<p><code>insert</code> が実装できました。</p>

<p>検索の方は簡単なので適当に実装して下さい。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">member</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Bool</span>
member <span class="kt">Leaf</span> x <span class="ow">=</span> <span class="kt">False</span>
member <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> x <span class="ow">=</span> <span class="kr">case</span> compare x v <span class="kr">of</span>
  <span class="kt">LT</span> <span class="ow">=&gt;</span> member l x
  <span class="kt">EQ</span> <span class="ow">=&gt;</span> <span class="kt">True</span>
  <span class="kt">GT</span> <span class="ow">=&gt;</span> member r x</code></pre></div>
<p>さて、ひとまずデータを入れて検索するところまでいけました。</p>

<p>地味に、空の木を表す <code>empty</code> も作っておきましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">empty</span> <span class="ow">:</span> <span class="kt">BTree</span> a
empty <span class="ow">=</span> <span class="kt">Leaf</span></code></pre></div>
<p>関数ではなく値です。Idrisは純粋関数型言語なので更新される心配がなく、<code>empty</code> を値として定義して使いまわしても何も問題がありません。</p>

<p>少しREPLで試してみて下さい。 <code>:let</code> で束縛を作れるのでそれを使うと良いでしょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">λΠ&gt; :let tree = insert empty 1
defined
λΠ&gt; tree
Node Leaf 1 Leaf : BTree Integer
λΠ&gt; member tree 1
True : Bool
λΠ&gt; member tree 2
False : Bool
λΠ&gt; :let tree = insert tree 3
defined
λΠ&gt; tree
Node Leaf 1 (Node Leaf 3 Leaf) : BTree Integer
λΠ&gt; member tree 1
True : Bool
λΠ&gt; member tree 2
False : Bool
λΠ&gt; member tree 3
True : Bool</code></pre></div>
<h1 id="テスト">テスト</h1>

<p>機能するものができたので自動テストをしてみましょう。
テストは2, 3個の例を試して正しく動くか試す、ソフトウェアの品質検査法です。
数学の試験で2, 3個の例を試して正しい、などと書いたら正解になりませんが、明らかな誤りを見つけるにはこれでも効果はあります。</p>

<p>新しくテストディレクトリを作り、そこに <code>BTree.idr</code> を作りましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">├── btree.ipkg
└── src
    ├── BTree.idr
    └── Tests
        └── BTree.idr</code></pre></div>
<p>そして <code>btree.ipkg</code> を編集します。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">package btree

sourcedir = src

modules = BTree
        , Tests.BTree

tests = Tests.BTree.test

pkgs = contrib</code></pre></div>
<p>テストモジュールをモジュールリストに加える、テストのエントリーポイントを指定する、依存パッケージにcontribを追加する、をやっています。</p>

<p><a href="https://www.idris-lang.org/docs/current/contrib_doc/">contrib</a>はIdrisコンパイラと一緒に配布されているパッケージですが、デフォルトではリンクされません。
idrisは標準ライブラリへの機能追加に保守的な方針を取っています。まずはcontribライブラリに入れ、誰が見ても必要だと判断できたらデフォルトでリンクされるpreludeやbaseに入ります。
今回はcotribにあるテストライブラリを使います。</p>

<p>さて、テストを書いていくのですが、その前に先程定義したデータ型を公開しないといけません。</p>

<h2 id="モジュールと可視性">モジュールと可視性</h2>

<p>前回のチュートリアルでモジュールについては学習したと思います。まだの人は<a href="http://docs.idris-lang.org/en/latest/tutorial/modules.html">ドキュメント</a>を読んでおいて下さい。</p>

<p>Idrisには3つの可視性の修飾子があります。</p>

<ul>
<li><code>private</code> - モジュール内でのみ見える</li>
<li><code>export</code> - モジュール外から型が見える。他言語でいうパブリックに近い</li>
<li><code>public export</code> - モジュール外から型と実装が見える。つまり実装の詳細まで公開APIになる</li>
</ul>

<p><code>public export</code> はかなり危険ですが、データ型だとコンストラクタまで公開したいケースは多々あるので便利でしょう。
今回は二分木に「ノードの左の子に保持されている全ての値よりもノードの保持している値の方が大きい。ノードの右の子に保持されている全ての値よりも値の方が小さい。」という条件があります。
ユーザにコンストラクタまで公開すると条件を満たさない木を作られかねないので <code>public export</code> ではなく <code>export</code> にします。
今ある4つの定義に <code>export</code> をつけましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="kr">data</span> <span class="kt">BTree</span> <span class="ow">..</span>

export
<span class="nf">empty</span><span class="ow">:</span> <span class="kt">BTree</span> a
<span class="ow">...</span>

export
<span class="nf">insert</span><span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span>  a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a

export
<span class="nf">member</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> <span class="kt">Bool</span></code></pre></div>
<hr />

<p>さて、これでテストが書けます。
<a href="https://www.idris-lang.org/docs/current/contrib_doc/docs/Test.Unit.Assertions.html">Test.Unit.Assertions</a>を使ってテストを書いてみましょう。
Tests/BTree.idrにこう書きます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">module</span> <span class="nn">Tests.BTree</span>

<span class="kr">import</span> <span class="nn">BTree</span>
<span class="kr">import</span> <span class="nn">Test.Unit.Assertions</span>


<span class="nf">testInsertMember</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testInsertMember <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert empty <span class="mi">1</span> <span class="kr">in</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert tree <span class="mi">5</span> <span class="kr">in</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert tree <span class="mi">3</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertTrue <span class="ow">$</span> member tree <span class="mi">1</span>
    assertTrue <span class="ow">$</span> member tree <span class="mi">5</span>
    assertTrue <span class="ow">$</span> member tree <span class="mi">3</span>
    pure <span class="ow">()</span></code></pre></div>
<p><code>assertTrue</code> を使って <code>insert</code> して <code>member</code> したら存在するということをテストしています。
<code>let 変数 = 式1 in 式2</code> はローカル変数を導入する構文です。
ネストするときはこのようにインデントを揃えると見慣れたコードに近くなります。</p>

<p>最後にテストのエントリーポイントを書きます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">test</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
test <span class="ow">=</span> <span class="kr">do</span>
  testInsertMember</code></pre></div>
<p><code>test</code> はipkgで指定した名前です。</p>

<p>このテストを走らせます。コマンドラインで <code>idris --testpkg btree.ipkg</code> を打つとテストが走ります。</p>
<pre><code class="language-console" data-lang="console">$ idris --testpkg btree.ipkg
Entering directory `./src&#39;
Type checking /tmp/idris74355-0.idr
Test: Assert True
Test: Assert True
Test: Assert True
Leaving directory `./src&#39;</code></pre>
<p>上手くいっているようです。</p>

<p>テストをもう少し追加しましょう。 <code>insert</code> してない値を <code>member</code> したら <code>False</code> になるテストです。
テストを書き、</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">testNotInsertMember</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testNotInsertMember <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert empty <span class="mi">1</span> <span class="kr">in</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert tree <span class="mi">5</span> <span class="kr">in</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert tree <span class="mi">3</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertFalse <span class="ow">$</span> member tree <span class="mi">2</span>
    assertFalse <span class="ow">$</span> member tree <span class="mi">4</span>
    pure <span class="ow">()</span></code></pre></div>
<p>エントリーポイントに追加し、</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">test</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
test <span class="ow">=</span> <span class="kr">do</span>
  testInsertMember
  testNotInsertMember</code></pre></div>
<p>実行します。</p>
<pre><code class="language-console" data-lang="console">$ idris --testpkg btree.ipkg
Entering directory `./src&#39;
Type checking ./Tests/BTree.idr
Type checking /tmp/idris74537-0.idr
Test: Assert True
Test: Assert True
Test: Assert True
Test: Assert False
Test: Assert False
Leaving directory `./src&#39;</code></pre>
<p>問題ないですね。</p>

<h1 id="削除">削除</h1>

<p>削除はまず検索と同じ要領で要素を見つけます。
例えば3を削除するとしましょう。3は簡単に見つかります。</p>

<p><img src="https://KeenS.github.io/images/btree/delete_1.png" alt="btreeの削除の図1" /></p>

<p>ここから3以外(要は左右の子)で新しく木を作ります。</p>

<p><img src="https://KeenS.github.io/images/btree/delete_2.png" alt="btreeの削除の図2" /></p>

<p>ノードを1つ追加すれば出来るのですが、ノードに保持する値が必要です。
左の子の最大値を持ってきてあげると上手くいきます。</p>

<p><img src="https://KeenS.github.io/images/btree/delete_3.png" alt="btreeの削除の図3" /></p>

<p>これにはサブルーチン、<code>popMax</code>を使います。 「ノードの値が木の最大値である⇒右の子がリーフ」なので簡単に発見、削除できます。
ずっと右の子を辿っていって右の子がリーフであるノードを見つけたらそのノードの値が最大値です。
空の木の場合は最大値がないので注意しましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">popMax</span> <span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="ow">(</span><span class="kt">BTree</span> a, <span class="kt">Maybe</span> a<span class="ow">)</span>
popMax <span class="kt">Leaf</span> <span class="ow">=</span> <span class="ow">(</span><span class="kt">Leaf</span>, <span class="kt">Nothing</span><span class="ow">)</span>
popMax <span class="ow">(</span><span class="kt">Node</span> l v <span class="kt">Leaf</span><span class="ow">)</span> <span class="ow">=</span> <span class="ow">(</span>l, <span class="kt">Just</span> v<span class="ow">)</span>
popMax <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="ow">(</span>r&#39;, max<span class="ow">)</span> <span class="ow">=</span> popMax r <span class="kr">in</span>
                         <span class="ow">(</span><span class="kt">Node</span> l v r&#39;, max<span class="ow">)</span></code></pre></div>
<p>ここで <code>(BTree a, Maybe a)</code> と書いてあるのはタプル(組)の型です。 簡易版構造体のようなもので、複数の値をひとまとめにできます。そして <code>(Leaf, Nothing)</code> のように書いてあるのがタプルの値です。
今更ですが、ちょくちょく出てきていた <code>()</code> は空のタプルのことでした。</p>

<p>この <code>popMax</code> を使うと <code>delete</code> はこう書けます。 <code>member</code> とほとんど似た見た目ですが <code>EQ</code> の腕で <code>popMax</code> を呼ぶようになっています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">delete</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> a  <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
delete <span class="kt">Leaf</span> x <span class="ow">=</span> <span class="kt">Leaf</span>
delete <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> x <span class="ow">=</span> <span class="kr">case</span> compare x v <span class="kr">of</span>
  <span class="kt">LT</span> <span class="ow">=&gt;</span> <span class="kt">Node</span> <span class="ow">(</span>delete l x<span class="ow">)</span>  v r
  <span class="kt">GT</span> <span class="ow">=&gt;</span> <span class="kt">Node</span> l v <span class="ow">(</span>delete r x<span class="ow">)</span>
  <span class="kt">EQ</span> <span class="ow">=&gt;</span> <span class="kr">case</span> popMax l <span class="kr">of</span>
        <span class="ow">(</span>l&#39;, <span class="kt">Just</span> max<span class="ow">)</span> <span class="ow">=&gt;</span> <span class="kt">Node</span> l&#39; max r
        <span class="ow">(</span>l&#39;, <span class="kt">Nothing</span><span class="ow">)</span> <span class="ow">=&gt;</span> r <span class="c1">-- l&#39; = Leaf</span></code></pre></div>
<p>これもテストしておきましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">testDelete</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testDelete <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert <span class="ow">(</span>the <span class="ow">(</span><span class="kt">BTree</span> <span class="kt">Integer</span><span class="ow">)</span> empty<span class="ow">)</span> <span class="mi">1</span> <span class="kr">in</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert tree <span class="mi">5</span> <span class="kr">in</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert tree <span class="mi">3</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertTrue <span class="ow">$</span> member tree <span class="mi">1</span>
    <span class="kr">let</span> tree <span class="ow">=</span> delete tree <span class="mi">1</span>
    assertFalse <span class="ow">$</span> member tree <span class="mi">1</span>
    pure <span class="ow">()</span>

<span class="nf">testPopMax</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testPopMax <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert empty <span class="mi">1</span> <span class="kr">in</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert tree <span class="mi">5</span> <span class="kr">in</span>
  <span class="kr">let</span> tree <span class="ow">=</span> insert tree <span class="mi">3</span> <span class="kr">in</span>
  <span class="kr">do</span>
    <span class="kr">let</span> <span class="ow">(</span>tree, max<span class="ow">)</span> <span class="ow">=</span> popMax tree
    assertEquals max <span class="ow">(</span><span class="kt">Just</span> <span class="mi">5</span><span class="ow">)</span>
    <span class="kr">let</span> <span class="ow">(</span>tree, max<span class="ow">)</span> <span class="ow">=</span> popMax tree
    assertEquals max <span class="ow">(</span><span class="kt">Just</span> <span class="mi">3</span><span class="ow">)</span>
    <span class="kr">let</span> <span class="ow">(</span>tree, max<span class="ow">)</span> <span class="ow">=</span> popMax tree
    assertEquals max <span class="ow">(</span><span class="kt">Just</span> <span class="mi">1</span><span class="ow">)</span>
    <span class="kr">let</span> <span class="ow">(</span>tree, max<span class="ow">)</span> <span class="ow">=</span> popMax tree
    assertEquals max <span class="kt">Nothing</span>
    pure <span class="ow">()</span>


export
<span class="nf">test</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
test <span class="ow">=</span> <span class="kr">do</span>
  <span class="c1">-- ...</span>
  testPopMax
  testDelete</code></pre></div>
<p>練習問題として <code>popMin</code> も実装してみて下さい。</p>

<h1 id="雑多な操作">雑多な操作</h1>

<p>二分木には色々な操作ができます。</p>

<h2 id="最大値-最小値">最大値、最小値</h2>

<p>例えば最大値、最小値は簡単に求まります。<code>popMax</code>, <code>popMin</code> の亜種ですね。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">max</span><span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">Maybe</span> a
max <span class="kt">Leaf</span> <span class="ow">=</span> <span class="kt">Nothing</span>
max <span class="ow">(</span><span class="kt">Node</span> <span class="kr">_</span> v <span class="kt">Leaf</span><span class="ow">)</span> <span class="ow">=</span> <span class="kt">Just</span> v
max <span class="ow">(</span><span class="kt">Node</span> <span class="kr">_</span> <span class="kr">_</span> r<span class="ow">)</span> <span class="ow">=</span> max r

export
<span class="nf">min</span><span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">Maybe</span> a
min <span class="kt">Leaf</span> <span class="ow">=</span> <span class="kt">Nothing</span>
min <span class="ow">(</span><span class="kt">Node</span> <span class="kt">Leaf</span> v <span class="kr">_</span><span class="ow">)</span> <span class="ow">=</span> <span class="kt">Just</span> v
min <span class="ow">(</span><span class="kt">Node</span> l <span class="kr">_</span> <span class="kr">_</span><span class="ow">)</span> <span class="ow">=</span> min l</code></pre></div>
<h2 id="分割">分割</h2>

<p>木を分割してみましょう。値 <code>x</code> を取り、「<code>x</code> より小さい値を含んだ木、<code>x</code> が含まれれば <code>x</code> 、 <code>x</code> より大きい値を含んだ木」の3つ組を返します。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">export
split: Ord a =&gt; BTree a -&gt; a -&gt; (BTree a, Maybe a, BTree a)
split Leaf x = (Leaf, Nothing, Leaf)
split (Node l v r) x = case compare x v of
  LT =&gt; let (ll, lv, lr) = split l x in (ll, lv, Node lr v r)
  EQ =&gt; (l, Just v, r)
  GT =&gt; let (rl, rv, rr) = split r x in (Node l v rl, rv, rr)</code></pre></div>
<h2 id="foldabe"><code>Foldabe</code></h2>

<p><a href="https://www.idris-lang.org/docs/current/base_doc/docs/Prelude.Foldable.html"><code>Foldable</code></a> というインターフェースがプレリュードで定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">||| The `Foldable` interface describes how you can iterate over the</span>
<span class="c1">||| elements in a parameterised type and combine the elements</span>
<span class="c1">||| together, using a provided function, into a single result.</span>
<span class="c1">|||</span>
<span class="c1">||| @t The type of the &#39;Foldable&#39; parameterised type.</span>
interface <span class="kt">Foldable</span> <span class="ow">(</span>t <span class="ow">:</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span><span class="ow">)</span> <span class="kr">where</span>

  <span class="c1">||| Successively combine the elements in a parameterised type using</span>
  <span class="c1">||| the provided function, starting with the element that is in the</span>
  <span class="c1">||| final position i.e. the right-most position.</span>
  <span class="c1">|||</span>
  <span class="c1">||| @func  The function used to &#39;fold&#39; an element into the accumulated result.</span>
  <span class="c1">||| @input The parameterised type.</span>
  <span class="c1">||| @init  The starting value the results are being combined into.</span>
  <span class="nf">foldr</span> <span class="ow">:</span> <span class="ow">(</span>func <span class="ow">:</span> elem <span class="ow">-&gt;</span> acc <span class="ow">-&gt;</span> acc<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>init <span class="ow">:</span> acc<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>input <span class="ow">:</span> t elem<span class="ow">)</span> <span class="ow">-&gt;</span> acc

  <span class="c1">||| The same as `foldr` but begins the folding from the element at</span>
  <span class="c1">||| the initial position in the data structure i.e. the left-most</span>
  <span class="c1">||| position.</span>
  <span class="c1">|||</span>
  <span class="c1">||| @func  The function used to &#39;fold&#39; an element into the accumulated result.</span>
  <span class="c1">||| @input The parameterised type.</span>
  <span class="c1">||| @init  The starting value the results are being combined into.</span>
  <span class="nf">foldl</span> <span class="ow">:</span> <span class="ow">(</span>func <span class="ow">:</span> acc <span class="ow">-&gt;</span> elem <span class="ow">-&gt;</span> acc<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>init <span class="ow">:</span> acc<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>input <span class="ow">:</span> t elem<span class="ow">)</span> <span class="ow">-&gt;</span> acc
  foldl f z t <span class="ow">=</span> foldr <span class="ow">(</span>flip <span class="ow">(.)</span> <span class="ow">.</span> flip f<span class="ow">)</span> id t z</code></pre></div>
<p><code>foldl</code> 、 <code>foldr</code> は概ねループをする関数です。<code>foldl</code> が左から、 <code>foldre</code> が右からの巡回です。
<code>foldl</code> は数当てゲームで使いましたね。
<code>Foldable</code> は他言語でいう <code>Iterable</code> みたいなものです。ただし関数型風味です。
変更可能な状態を持てないので外部イテレータではなく内部イテレータで定義されています。そしてループの途中の計算状態 <code>acc</code> を持ち回ります。</p>

<p>これを二分木に実装しましょう。<code>foldl</code> は 「まず左、値、そして右」の順(通りがけ順)に走査していけばよさそうです。</p>

<p><img src="https://KeenS.github.io/images/btree/inorder.png" alt="btreeのfoldlの図" /></p>

<p><code>foldr</code> はその対称ですね。
素直にこう実装できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kt">Foldable</span> <span class="kt">BTree</span> <span class="kr">where</span>
  foldr f init <span class="kt">Leaf</span> <span class="ow">=</span> init
  foldr f init <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> <span class="ow">=</span>
    <span class="kr">let</span> r <span class="ow">=</span> foldr f init r <span class="kr">in</span>
    <span class="kr">let</span> v <span class="ow">=</span> f v r <span class="kr">in</span>
    foldr f v l
  foldl f init <span class="kt">Leaf</span> <span class="ow">=</span> init
  foldl f init <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span> <span class="ow">=</span>
    <span class="kr">let</span> l <span class="ow">=</span> foldl f init l <span class="kr">in</span>
    <span class="kr">let</span> v <span class="ow">=</span> f l v <span class="kr">in</span>
    foldl f v r</code></pre></div>
<p>これを用いてリストとの相互変換を実装してみましょう。
煩雑だった値の構築が少し楽になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">toList</span><span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">List</span> a
toList tree <span class="ow">=</span> foldr <span class="ow">(::)</span> <span class="ow">[]</span> tree

export
<span class="nf">toTree</span><span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">List</span> a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
toTree xs <span class="ow">=</span> foldl insert empty xs</code></pre></div>
<p>ここで、 <code>(::)</code> はリストのコンストラクタです。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">λΠ&gt; the (List Integer) $ 1 :: 2 :: 3 :: []
[1, 2, 3] : List Integer</code></pre></div>
<h2 id="fold"><code>fold</code></h2>

<p>先程の <code>foldr</code>, <code>foldl</code> とは別に <code>fold</code> という関数が定義できます。
<code>BTree</code> は以下のように定義されているのでした。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">BTree</span> a <span class="ow">=</span> <span class="kt">Leaf</span>
             <span class="ow">|</span> <span class="kt">Node</span> <span class="ow">(</span><span class="kt">BTree</span> a<span class="ow">)</span> a <span class="ow">(</span><span class="kt">BTree</span> a<span class="ow">)</span></code></pre></div>
<p><code>BTree</code> は定数 <code>Leaf</code> と3引数関数 <code>Node</code> で構成されているとも読めます。<code>fold</code> は この構成子を別の定数と3引数関数で置き換えてあげる操作です。
リストは <code>foldr</code> がそのまま <code>fold</code> に対応するのですが <code>BTree</code> はそうではないので自分で定義します。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">fold</span><span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> b <span class="ow">-&gt;</span> <span class="ow">(</span>b <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> b <span class="ow">-&gt;</span> b<span class="ow">)</span> <span class="ow">-&gt;</span> b
fold  <span class="kt">Leaf</span>  x f <span class="ow">=</span> x
fold  <span class="ow">(</span><span class="kt">Node</span> l v r<span class="ow">)</span>  x f <span class="ow">=</span> f <span class="ow">(</span>fold  l x f<span class="ow">)</span> v <span class="ow">(</span>fold r x f<span class="ow">)</span></code></pre></div>
<p><code>Leaf</code> -&gt; <code>x</code> 、 <code>Node</code> -&gt; <code>f</code> を再帰的にやっているのが見て取れると思います。</p>

<p><code>fold</code> を使っていくつか関数を定義してみましょう。</p>

<p>木のサイズ(保持している要素数)はこう定義できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">size</span> <span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">Integer</span>
size tree <span class="ow">=</span> fold tree <span class="mi">0</span> <span class="ow">(\</span>l, <span class="kr">_</span>, r <span class="ow">=&gt;</span> l <span class="ow">+</span> <span class="mi">1</span> <span class="ow">+</span> r<span class="ow">)</span></code></pre></div>
<p>木の高さは以下のように定義できます</p>

<ul>
<li>リーフの高さは0である</li>
<li>ノードの高さは左右の子の高さのうち大きい方+1である</li>
</ul>

<p>これも同様に <code>fold</code> で求められます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">height</span> <span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">Integer</span>
height t <span class="ow">=</span> fold t <span class="mi">0</span> <span class="ow">(\</span>lh,_,rh <span class="ow">=&gt;</span> <span class="ow">(</span>max lh rh<span class="ow">)</span> <span class="ow">+</span> <span class="mi">1</span><span class="ow">)</span></code></pre></div>
<p>これは一番深い方を求めています。浅い方を求めるのも考えられるのでそれも実装してみましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">export
<span class="nf">maxHeight</span> <span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">Integer</span>
maxHeight t <span class="ow">=</span> fold t <span class="mi">0</span> <span class="ow">(\</span>lh,_,rh <span class="ow">=&gt;</span> <span class="ow">(</span>max lh rh<span class="ow">)</span> <span class="ow">+</span> <span class="mi">1</span><span class="ow">)</span>

export
<span class="nf">minHeight</span> <span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">Integer</span>
minHeight t <span class="ow">=</span> fold t <span class="mi">0</span> <span class="ow">(\</span>lh,_,rh <span class="ow">=&gt;</span> <span class="ow">(</span>min lh rh<span class="ow">)</span> <span class="ow">+</span> <span class="mi">1</span><span class="ow">)</span>

export
<span class="nf">height</span> <span class="ow">:</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">Integer</span>
height <span class="ow">=</span> maxHeight</code></pre></div>
<h3 id="余談-fold-の一般化">余談: <code>fold</code> の一般化</h3>

<p><code>fold</code> は<code>BTree</code>やリストに限らず色々なデータ型にも定義できますが、それをインターフェースで一般化するのはかなり難易度が上がります。
列挙子に応じて引数の数や型が変わるので共通のインターフェースが定められないのです。
やるとしたらデータ型の定義ごと管理下に置くような仕組みが必要になるでしょう。
そういうのは&rdquo;recursion scheme&rdquo;という名前で色々整備されているようです。<code>fold</code> はcatamorphismと呼ばれます。
resursion schemeは日本語でもいくつか解説があるようですが以下のブログを紹介しておきます。
<a href="http://d.hatena.ne.jp/KeisukeNakano/20060803/1153821754">#003 代数的データ型 - λx.x K S K ＠ はてな</a></p>

<h2 id="集合操作">集合操作</h2>

<p>二分木は集合のように扱えるので合併、交叉、差分などの操作も欲しくなりますよね。</p>

<p><code>foldl</code> を使うと簡単に実装できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">union</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
union tree1 tree2 <span class="ow">=</span> foldl insert tree1 tree2

<span class="c1">-- `if` 式は `if 条件 then 式 else 式` で書く</span>
<span class="nf">intersection</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
intersection tree1 tree2 <span class="ow">=</span> foldl <span class="ow">(\</span>acc,elm <span class="ow">=&gt;</span> <span class="kr">if</span> member tree1 elm
                                              <span class="kr">then</span> insert acc elm
                                              <span class="kr">else</span> acc<span class="ow">)</span>
                                 empty tree2

<span class="nf">difference</span> <span class="ow">:</span> <span class="kt">Ord</span> a <span class="ow">=&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a <span class="ow">-&gt;</span> <span class="kt">BTree</span> a
difference tree1 tree2 <span class="ow">=</span> foldl delete tree1 tree2</code></pre></div>
<p><code>union</code> は少し良くない点があるのですが気にしないことにしましょう。</p>

<hr />

<p>さて、これらの雑多な操作のテストも書いておきましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">testToTreeMember</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testToTreeMember <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">1</span>, <span class="mi">5</span>, <span class="mi">3</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertTrue <span class="ow">$</span> member tree <span class="mi">1</span>
    assertTrue <span class="ow">$</span> member tree <span class="mi">5</span>
    assertTrue <span class="ow">$</span> member tree <span class="mi">3</span>
    pure <span class="ow">()</span>

<span class="nf">testToTreeToList</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testToTreeToList <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">1</span>, <span class="mi">5</span>, <span class="mi">3</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">let</span> list <span class="ow">=</span> toList tree <span class="kr">in</span>
  <span class="kr">do</span>
    assertEquals list <span class="ow">[</span><span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">5</span><span class="ow">]</span>
    pure <span class="ow">()</span>

<span class="nf">testMax</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testMax <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">1</span>, <span class="mi">4</span>, <span class="mi">3</span>, <span class="mi">5</span>, <span class="mi">2</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertEquals <span class="ow">(</span>max tree<span class="ow">)</span> <span class="ow">(</span><span class="kt">Just</span> <span class="mi">5</span><span class="ow">)</span>
    pure <span class="ow">()</span>

<span class="nf">testMin</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testMin <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">1</span>, <span class="mi">4</span>, <span class="mi">3</span>, <span class="mi">5</span>, <span class="mi">2</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertEquals <span class="ow">(</span>min tree<span class="ow">)</span> <span class="ow">(</span><span class="kt">Just</span> <span class="mi">1</span><span class="ow">)</span>
    pure <span class="ow">()</span>

<span class="nf">testSplit1</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testSplit1 <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">1</span>, <span class="mi">5</span>, <span class="mi">3</span>, <span class="mi">2</span>, <span class="mi">4</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="ow">(</span>l, v ,r<span class="ow">)</span> <span class="ow">=</span> split tree <span class="mi">3</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertEquals <span class="ow">(</span>toList l<span class="ow">)</span> <span class="ow">[</span><span class="mi">1</span>, <span class="mi">2</span><span class="ow">]</span>
    assertEquals v <span class="ow">(</span><span class="kt">Just</span> <span class="mi">3</span><span class="ow">)</span>
    assertEquals <span class="ow">(</span>toList r<span class="ow">)</span> <span class="ow">[</span><span class="mi">4</span>, <span class="mi">5</span><span class="ow">]</span>
    pure <span class="ow">()</span>

<span class="nf">testSplit2</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testSplit2 <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">1</span>, <span class="mi">5</span>, <span class="mi">2</span>, <span class="mi">4</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="ow">(</span>l, v ,r<span class="ow">)</span> <span class="ow">=</span> split tree <span class="mi">3</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertEquals <span class="ow">(</span>toList l<span class="ow">)</span> <span class="ow">[</span><span class="mi">1</span>, <span class="mi">2</span><span class="ow">]</span>
    assertEquals v <span class="kt">Nothing</span>
    assertEquals <span class="ow">(</span>toList r<span class="ow">)</span> <span class="ow">[</span><span class="mi">4</span>, <span class="mi">5</span><span class="ow">]</span>
    pure <span class="ow">()</span>

<span class="nf">testSplit3</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testSplit3 <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">1</span>, <span class="mi">5</span>, <span class="mi">2</span>, <span class="mi">4</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="ow">(</span>l, v ,r<span class="ow">)</span> <span class="ow">=</span> split tree <span class="mi">6</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertEquals <span class="ow">(</span>toList l<span class="ow">)</span> <span class="ow">[</span><span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">4</span>, <span class="mi">5</span><span class="ow">]</span>
    assertEquals v <span class="kt">Nothing</span>
    assertEquals <span class="ow">(</span>toList r<span class="ow">)</span> <span class="ow">[]</span>
    pure <span class="ow">()</span>

<span class="nf">testSplit4</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testSplit4 <span class="ow">=</span>
  <span class="kr">let</span> tree <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">1</span>, <span class="mi">5</span>, <span class="mi">2</span>, <span class="mi">4</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="ow">(</span>l, v ,r<span class="ow">)</span> <span class="ow">=</span> split tree <span class="mi">0</span> <span class="kr">in</span>
  <span class="kr">do</span>
    assertEquals <span class="ow">(</span>toList l<span class="ow">)</span> <span class="ow">[]</span>
    assertEquals v <span class="kt">Nothing</span>
    assertEquals <span class="ow">(</span>toList r<span class="ow">)</span> <span class="ow">[</span><span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">4</span>, <span class="mi">5</span><span class="ow">]</span>
    pure <span class="ow">()</span>


<span class="nf">testSplit</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testSplit <span class="ow">=</span> <span class="kr">do</span>
  testSplit1
  testSplit2
  testSplit3
  testSplit4


<span class="nf">testUnion</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
testUnion <span class="ow">=</span>
  <span class="kr">let</span> tree1 <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">5</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">let</span> tree2 <span class="ow">=</span> toTree <span class="ow">[</span><span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span><span class="ow">]</span> <span class="kr">in</span>
  <span class="kr">let</span> tree <span class="ow">=</span> union tree1 tree2 <span class="kr">in</span>
  <span class="kr">do</span>
    assertEquals <span class="ow">(</span>toList tree<span class="ow">)</span> <span class="ow">[</span><span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>, <span class="mi">5</span><span class="ow">]</span>
    pure <span class="ow">()</span>


export
<span class="nf">test</span> <span class="ow">:</span> <span class="kt">IO</span> <span class="ow">()</span>
test <span class="ow">=</span> <span class="kr">do</span>
  <span class="c1">-- ...</span>
  testToTreeMember
  testToTreeToList
  testMax
  testMin
  testSplit
  testUnion</code></pre></div>
<h1 id="パッケージを整える">パッケージを整える</h1>

<p>btree.ipkgには最低限の内容しか書いてませんでした。色々埋めましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">brief = &#34;A non-balanced Binary Tree library&#34;
version = &#34;0.1.0&#34;
readme = &#34;README.md&#34;
license = &#34;MIT&#34;
author = &#34;κeen&#34;
maintainer = &#34;κeen&#34;
sourceloc = &#34;https://gitlab.com/blackenedgold/idris-btree&#34;
bugtracker = &#34;https://gitlab.com/blackenedgold/idris-btree/issues&#34;</code></pre></div>
<p>ドキュメントを生成してみましょう。</p>
<pre><code class="language-console" data-lang="console">$ idris --mkdoc btree.ipkg</code></pre>
<p><code>btree_doc/index.html</code> を開くとドキュメントを確認できます。</p>

<p>あとは <code>.gitignore</code> を書いて適当にコミットしましょう。</p>
<pre><code class="language-gitignore" data-lang="gitignore">*.ibc
btree_doc</code></pre>
<p>コードホスティングサービスにGitLabを使うならGitLab CIで以下のようにテスト/ドキュメント生成ができます。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># インターネットに転がっていたイメージ</span><span class="w">
</span><span class="w"></span><span class="c"># 得体のしれないイメージを使いたくない人は自分でイメージを作ると良い</span><span class="w">
</span><span class="w"></span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">mmhelloworld/idris:1.3.1</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">test</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">script</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">idris --testpkg btree.ipkg</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">pages</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">script</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">idris --mkdoc btree.ipkg</span><span class="w">
</span><span class="w">    </span><span class="c"># docker内で生成するとパーミッションの問題が発生するらしく、ディレクトリを一旦作り直すと解決する</span><span class="w">
</span><span class="w">    </span>- <span class="l">mkdir public</span><span class="w">
</span><span class="w">    </span>- <span class="l">cp -R btree_doc/* public</span><span class="w">
</span><span class="w">  </span><span class="nt">artifacts</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">paths</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">public</span><span class="w">
</span><span class="w">  </span><span class="nt">only</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">master</span></code></pre></div>
<p>生成されたドキュメントは<a href="https://blackenedgold.gitlab.io/idris-btree/">こちら</a>。
GitHubでも外部サービスやGitHub Actionsで同様にはできると思います。ドキュメントの方はGitLab Pagesとは違って一苦労必要そうですが。</p>

<h1 id="まとめ">まとめ</h1>

<p>このチュートリアルでは二分木のライブラリを作りつつIdrisでのデータ型の定義、インターフェース、テスト、パッケージなどについて学びました。</p>
                    </section>
                </article>
            </div>
        </div>

        <div class="row li-author">
    <div class="sixteen columns">
        Written by <strong>κeen</strong>
    </div>
</div>


        <div class="row li-pagination">
            <div class="eight columns">
                <div class="li-pagination-previous">
                    
                        Later article<br />
                        <a href="https://KeenS.github.io/blog/2019/01/21/puroguraminguwomokutekinishitemoiitoomou/"> プログラミングを目的にしてもいいと思う</a>
                    
                </div>
            </div>
            <div class="eight columns">
                <div class="li-pagination-next">
                    
                        Older article<br />
                        <a href="https://KeenS.github.io/slide/void/"> void</a>
                    
                </div>
            </div>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2021. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="https://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>

