<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="Idrisで正しいモノイドを定義したい | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="κeenです。俺たちのAdevnt Calendarはまだまだ終わらないぜ！
Idrisの標準ライブラリを含め、世間でモノイド（などの代数構造）とされる型クラスって正しくないよねという話と、正しい定義をする話をします。" />
        <meta property="og:title" content="Idrisで正しいモノイドを定義したい | κeenのHappy Hacκing Blog" />
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https://https://KeenS.github.io/blog/2020/12/26/idrisdetadashiimonoidowoteigishitai/" />
        <meta property="og:description" content="κeenです。俺たちのAdevnt Calendarはまだまだ終わらないぜ！
Idrisの標準ライブラリを含め、世間でモノイド（などの代数構造）とされる型クラスって正しくないよねという話と、正しい定義をする話をします。" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta property="og:image" content="https://KeenS.github.io/images/ogp/post/Idrisdetadashiimonoidowoteigishitai.png" />
        <meta name="twitter:image" content="https://KeenS.github.io/images/ogp/post/Idrisdetadashiimonoidowoteigishitai.png" />
        
        <meta property="og:article:published_time" content="2020-12-26 11:19:00 &#43;0900 JST" />
        <meta property="og:article:modified_time" content="2020-12-26 11:19:00 &#43;0900 JST" />
        
        <meta property="og:article:author" content="κeen" />

        <title>Idrisで正しいモノイドを定義したい | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css' />
        <link rel="stylesheet" href="https://KeenS.github.io/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/liquorice.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="https://KeenS.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="https://KeenS.github.io/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="https://KeenS.github.io/manifest.json">
        <link rel="mask-icon" href="https://KeenS.github.io/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
        <link rel="apple-touch-icon-precomposed" href="https://KeenS.github.io/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="stylesheet" href="https://KeenS.github.io/css/syntax-monokai.css" />
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<link rel="stylesheet" href="//unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css">

    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="https://KeenS.github.io/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="https://KeenS.github.io/about/"> About </a></li>
                        
                            <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                        
                            <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                        
                            <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="https://KeenS.github.io/about/"> About </a></li>
                    
                        <li><a href="https://KeenS.github.io/index.xml"> Atom </a></li>
                    
                        <li><a href="https://KeenS.github.io/post/"> Blog </a></li>
                    
                        <li><a href="https://KeenS.github.io/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                    <header class="li-article-header">
                        <h1 class="li-article-title">Idrisで正しいモノイドを定義したい</h1>
                        <div class="li-article-meta">
    <time class="li-article-date">2020-12-26</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="https://KeenS.github.io/categories/idris">Idris</a>
        </li>
    
</ul>

</div>

                    </header>
                    <section>
                        <p>κeenです。俺たちのAdevnt Calendarはまだまだ終わらないぜ！
Idrisの標準ライブラリを含め、世間でモノイド（などの代数構造）とされる型クラスって正しくないよねという話と、正しい定義をする話をします。</p>

<h1 id="モノイドの定義">モノイドの定義</h1>

<p>集合 $S$ とその上の二項演算 $\cdot : S \times S \to S$ が以下の2つの条件を満たすときモノイドという</p>

<ul>
<li>結合律： $S$ の任意の元 $a$ 、 $b$ 、 $c$ に対して $(a \cdot b) \cdot c = a \cdot (b \cdot c)$ が成り立つ</li>
<li>単位元: $S$ の元 $e$ が存在して、 $S$ の任意の元 $a$ に対して $e \cdot a = a \cdot e = a$ が成り立つ</li>
</ul>

<p>ポイントはモノイドは集合と演算の組に対して定義されている点と、モノイドであるためにはある程度の性質を満たさないといけない点です。</p>

<p>例えば自然数と <code>+</code> の組はモノイドですし、 自然数 と <code>*</code> の組もモノイドです。</p>

<h1 id="よくあるモノイドの定義">よくあるモノイドの定義</h1>

<p>Idrisのプレリュードにも定義はありますが、半群を継承していて話がややこしくなるので1まとめにした定義を出します。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">interface <span class="kt">Monoid</span> ty <span class="kr">where</span>
  <span class="nf">neutral</span> <span class="ow">:</span> ty
  <span class="ow">(&lt;+&gt;)</span> <span class="ow">:</span> ty <span class="ow">-&gt;</span> ty <span class="ow">-&gt;</span> ty</code></pre></div>
<p>これを見て「うん、モノイドだね」と思った方はかなり毒されてます。
モノイドの定義に全然従ってないですよね。</p>

<h1 id="よくあるモノイドの定義の問題点">よくあるモノイドの定義の問題点</h1>

<h2 id="定義の対象が違う">定義の対象が違う</h2>

<p>本来のモノイドは集合と演算の組に対して定義されるのに対して、こちらは型（=集合）に対してのみ定義しています。</p>

<p>これは結構な問題で、例えば自然数には <code>+</code> や <code>*</code> 、あるいは <code>max</code> などの演算で複数のモノイド構造があるのにそれを表現できません（Idrisではインタフェースの実装は原則1型につき1つ）。</p>

<p>標準ライブラリではどうしているかというと、自然数をラップする新しい型を定義して、それぞれに別の演算を定義しています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">record</span> <span class="kt">Multiplicative</span> <span class="kr">where</span>
  constructor <span class="kt">GetMultiplicative</span>
  <span class="nf">_</span> <span class="ow">:</span> <span class="kt">Nat</span>

<span class="kr">record</span> <span class="kt">Additive</span> <span class="kr">where</span>
  constructor <span class="kt">GetAdditive</span>
  <span class="nf">_</span> <span class="ow">:</span> <span class="kt">Nat</span>

<span class="kt">Monoid</span> <span class="kt">Multiplicative</span> <span class="kr">where</span>
  <span class="ow">(&lt;+&gt;)</span> left right <span class="ow">=</span> <span class="kt">GetMultiplicative</span> <span class="ow">$</span> left&#39; <span class="ow">*</span> right&#39;
    <span class="kr">where</span>
      <span class="nf">left&#39;</span>  <span class="ow">:</span> <span class="kt">Nat</span>
      left&#39;  <span class="ow">=</span>
       <span class="kr">case</span> left <span class="kr">of</span>
          <span class="kt">GetMultiplicative</span> m <span class="ow">=&gt;</span> m

      <span class="nf">right&#39;</span> <span class="ow">:</span> <span class="kt">Nat</span>
      right&#39; <span class="ow">=</span>
        <span class="kr">case</span> right <span class="kr">of</span>
          <span class="kt">GetMultiplicative</span> m <span class="ow">=&gt;</span> m
  neutral <span class="ow">=</span> <span class="kt">GetMultiplicative</span> <span class="ow">$</span> <span class="kt">S</span> <span class="kt">Z</span>

<span class="kt">Monoid</span> <span class="kt">Additive</span> <span class="kr">where</span>
  left <span class="ow">&lt;+&gt;</span> right <span class="ow">=</span> <span class="kt">GetAdditive</span> <span class="ow">$</span> left&#39; <span class="ow">+</span> right&#39;
    <span class="kr">where</span>
      <span class="nf">left&#39;</span>  <span class="ow">:</span> <span class="kt">Nat</span>
      left&#39;  <span class="ow">=</span>
        <span class="kr">case</span> left <span class="kr">of</span>
          <span class="kt">GetAdditive</span> m <span class="ow">=&gt;</span> m

      <span class="nf">right&#39;</span> <span class="ow">:</span> <span class="kt">Nat</span>
      right&#39; <span class="ow">=</span>
        <span class="kr">case</span> right <span class="kr">of</span>
          <span class="kt">GetAdditive</span> m <span class="ow">=&gt;</span> m
  neutral <span class="ow">=</span> <span class="kt">GetAdditive</span> <span class="kt">Z</span></code></pre></div>
<p>めちゃくちゃ使いづらそうですよね。</p>

<p>一応Idrisにはインタフェースの<a href="http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#named-implementations">名前つき実装</a>というのがあって、別々のインスタンスを作ることもできます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="ow">[</span><span class="kt">MultNatMonoid</span><span class="ow">]</span> <span class="kt">Monoid</span> <span class="kt">Nat</span> <span class="kr">where</span>
  neutral <span class="ow">=</span> <span class="kt">S</span> <span class="kt">Z</span>
  <span class="ow">(&lt;+&gt;)</span> <span class="ow">=</span> mult
<span class="ow">[</span><span class="kt">AddNatMonoid</span><span class="ow">]</span> <span class="kt">Monoid</span> <span class="kt">Nat</span> <span class="kr">where</span>
  neutral <span class="ow">=</span> <span class="kt">Z</span>
  <span class="ow">(&lt;+&gt;)</span> <span class="ow">=</span> plus</code></pre></div>
<p>ですがこれはこれで問題です。
何故なら同じ演算子に対して複数のインスタンスを作れてしまうからです。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="ow">[</span><span class="kt">AddNatMonoid</span><span class="ow">]</span> <span class="kt">Monoid</span> <span class="kt">Nat</span> <span class="kr">where</span>
  neutral <span class="ow">=</span> <span class="kt">Z</span>
  <span class="ow">(&lt;+&gt;)</span> <span class="ow">=</span> plus

<span class="ow">[</span><span class="kt">AddNatMonoid2</span><span class="ow">]</span> <span class="kt">Monoid</span> <span class="kt">Nat</span> <span class="kr">where</span>
  neutral <span class="ow">=</span> <span class="kt">Z</span>
  <span class="ow">(&lt;+&gt;)</span> <span class="ow">=</span> plus</code></pre></div>
<p>さらに、これを使うときに面倒です。
<code>concat @{AddNatMonoid}</code> のように名前を指定しないといけなくなります。
できれば型から良い感じに推測してほしいですよね。</p>

<h2 id="条件を表現できていない">条件を表現できていない</h2>

<p>まあ、これは分かりやすいでしょう。
結合律と単位元の満たすべき条件が表現できていません。</p>

<p>これら2つの問題を解決したモノイドを定義したい、というのが今回の趣旨です。</p>

<h1 id="パラメータに演算を">パラメータに演算を</h1>

<p>真っ先に思い付くのはインタフェースのパラメータで演算まで受け取ってしまうものですよね。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">interface <span class="kt">CorrectMonoid</span> s <span class="ow">(</span>op <span class="ow">:</span> s <span class="ow">-&gt;</span> s <span class="ow">-&gt;</span> s<span class="ow">)</span> <span class="kr">where</span></code></pre></div>
<p>これで定義の対象が違う問題が解決します。</p>

<p>そして続く中身は以下のようになります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris">interface <span class="kt">CorrectMonoid</span> s <span class="ow">(</span>op <span class="ow">:</span> s <span class="ow">-&gt;</span> s <span class="ow">-&gt;</span> s<span class="ow">)</span> <span class="kr">where</span>
  <span class="nf">unit</span> <span class="ow">:</span> s
  <span class="nf">unitNeutral</span> <span class="ow">:</span> <span class="ow">(</span>x <span class="ow">:</span> s<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>op unit x <span class="ow">=</span> x,  op x unit <span class="ow">=</span> x<span class="ow">)</span>
  <span class="nf">monoidAssociative</span> <span class="ow">:</span> <span class="ow">(</span>x, y, z <span class="ow">:</span> s<span class="ow">)</span> <span class="ow">-&gt;</span>  op x <span class="ow">(</span>op y z<span class="ow">)</span> <span class="ow">=</span> op <span class="ow">(</span>op x y<span class="ow">)</span> z</code></pre></div>
<ol>
<li>（よくある定義と同じように）単位元を定義に持つ</li>
<li>（よくある定義と異なり）演算は定義にない</li>
<li>2つの条件を定義に持つ。要は証明オブジェクトを要求する。</li>
</ol>

<p>これはコンパイルが通ります。</p>

<p>よさそうなので例えば <code>(Nat, plus)</code> の組に定義してみましょう。
小文字はじまりのシンボルは勝手に型パラメータ扱いされるので <code>Prelude.Nat.plus</code> と完全修飾名を使っています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kt">CorrectMonoid</span> <span class="kt">Nat</span> <span class="kt">Prelude</span><span class="ow">.</span><span class="kt">Nat</span><span class="ow">.</span>plus <span class="kr">where</span>
  unit <span class="ow">=</span> <span class="kt">Z</span>
  unitNeutral n <span class="ow">=</span> <span class="ow">(</span>plusZeroLeftNeutral n, plusZeroRightNeutral n<span class="ow">)</span>
  monoidAssociative <span class="ow">=</span> plusAssociative</code></pre></div>
<p>残念ながらこれはコンパイルエラーです。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">- + Errors (1)
 `-- correctMonoid.idr line 8 col 0:
     plus  cannot be a parameter of Main.CorrectMonoid
     (Implementation arguments must be type or data constructors)</code></pre></div>
<p>いくらIdrisといっても関数を型パラメータに書くことはできません。
型パラメータに書けるのは型や型コンストラクタ、データ型から作った値などです。
多分関数の同一性の問題とかそのあたりの制約なんでしょう。</p>

<p>という訳で試み1は失敗しました。</p>

<h1 id="演算に対応する型">演算に対応する型</h1>

<p>関数を直接置けないなら関数と対応関係にあるダミーの型を作ってそれを置けばいいじゃんという発想に至ります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Add</span>

interface <span class="kt">Op</span> s o <span class="kr">where</span>
  <span class="ow">(&lt;&gt;)</span> <span class="ow">:</span> s <span class="ow">-&gt;</span> s <span class="ow">-&gt;</span> s

<span class="kt">Op</span> <span class="kt">Nat</span> <span class="kt">Add</span> <span class="kr">where</span>
  <span class="ow">(&lt;&gt;)</span> <span class="ow">=</span> plus

interface <span class="kt">Op</span> s o <span class="ow">=&gt;</span> <span class="kt">CorrectMonoid</span> s o <span class="kr">where</span>
  <span class="nf">unit</span> <span class="ow">:</span> s
  <span class="nf">unitNeutral</span> <span class="ow">:</span> <span class="ow">(</span>x <span class="ow">:</span> s<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>unit <span class="ow">&lt;&gt;</span> x <span class="ow">=</span> x, x <span class="ow">&lt;&gt;</span> unit <span class="ow">=</span> x<span class="ow">)</span>
  <span class="nf">monoidAssociative</span> <span class="ow">:</span> <span class="ow">(</span>x, y, z <span class="ow">:</span> s<span class="ow">)</span> <span class="ow">-&gt;</span>  x <span class="ow">&lt;&gt;</span> <span class="ow">(</span>y <span class="ow">&lt;&gt;</span> z<span class="ow">)</span> <span class="ow">=</span> <span class="ow">(</span>x <span class="ow">&lt;&gt;</span> y<span class="ow">)</span> <span class="ow">&lt;&gt;</span> z</code></pre></div>
<p>残念ながらこれもコンパイルが通りません。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">- + Errors (1)
 `-- correctMonoid.idr line 22 col 10:
     When checking type of Main.unitNeutral:
     Can&#39;t find implementation for Op s o</code></pre></div>
<p>どうやら <code>interface Op s o</code> の <code>o</code> がどこでも使われていないことで解決に失敗するようです。</p>

<p>インタフェースを使った方法は難しいようですね。別の方法を探しましょう。</p>

<h1 id="自作インタフェース">自作インタフェース</h1>

<p>次に思い付くのはインタフェースの仕組みを1から作ればどうにかできるんじゃないかということですよね。</p>

<p>インタフェースは実装レベルではただのレコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">record</span> <span class="kt">CorrectMonoid</span> a o <span class="kr">where</span>
  constructor <span class="kt">MkCorrectMonoid</span>
  <span class="nf">_unit</span> <span class="ow">:</span> a
  <span class="nf">_op</span> <span class="ow">:</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> a
  <span class="nf">_unitNeutral</span> <span class="ow">:</span> <span class="ow">(</span>x <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>_op _unit x <span class="ow">=</span> x, _op x _unit <span class="ow">=</span> x<span class="ow">)</span>
  <span class="nf">_opAssociative</span> <span class="ow">:</span> <span class="ow">(</span>x, y, z <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> _op x <span class="ow">(</span>_op y z<span class="ow">)</span> <span class="ow">=</span> _op <span class="ow">(</span>_op x  y<span class="ow">)</span> z</code></pre></div>
<p>ここまではよいでしょう。</p>

<p>では <code>CorrectMonoid a o =&gt; ...</code> という制約はどう書くんだとなります。
これは事実上自動で渡されるimplicit argumentsですよね。
Idrisには<a href="http://docs.idris-lang.org/en/latest/tutorial/miscellany.html#auto-implicit-arguments">auto implicit arguments</a>があります。
それを使えば以下のように各関数が作れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">name</span>space <span class="kt">CorrectMonoid</span>
  <span class="nf">unit</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a o<span class="ow">}</span> <span class="ow">-&gt;</span> a
  unit <span class="ow">{</span>impl<span class="ow">}</span> <span class="ow">=</span> _unit impl

  <span class="nf">op</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a o<span class="ow">}</span> <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> a
  op <span class="ow">{</span>impl<span class="ow">}</span> <span class="ow">=</span> _op impl

  <span class="nf">unitNeutral</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a o<span class="ow">}</span> <span class="ow">-&gt;</span> <span class="ow">(</span>x <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">((</span>_op impl<span class="ow">)</span> <span class="ow">(</span>_unit impl<span class="ow">)</span> x <span class="ow">=</span> x, <span class="ow">(</span>_op impl<span class="ow">)</span> x <span class="ow">(</span>_unit impl<span class="ow">)</span> <span class="ow">=</span> x<span class="ow">)</span>
  unitNeutral <span class="ow">{</span>impl<span class="ow">}</span> <span class="ow">=</span> _unitNeutral impl

  <span class="nf">opAssociative</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a o<span class="ow">}</span> <span class="ow">-&gt;</span> <span class="ow">(</span>x, y, z <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>_op impl<span class="ow">)</span> x <span class="ow">((</span>_op impl<span class="ow">)</span> y z<span class="ow">)</span> <span class="ow">=</span> <span class="ow">(</span>_op impl<span class="ow">)</span> <span class="ow">((</span>_op impl<span class="ow">)</span> x  y<span class="ow">)</span> z
  opAssociative <span class="ow">{</span>impl<span class="ow">}</span> <span class="ow">=</span> _opAssociative impl</code></pre></div>
<p>それではこのインスタンスを作ってみましょう。
<code>%hint</code> ディレクティブをつけるとauto implicit argumentsの探索対象に入ります。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Add</span>

<span class="ow">%</span>hint
<span class="nf">natAddCorrectMonoid</span> <span class="ow">:</span> <span class="kt">CorrectMonoid</span> <span class="kt">Nat</span> <span class="kt">Add</span>
natAddCorrectMonoid <span class="ow">=</span> <span class="kt">MkCorrectMonoid</span> unit op unitNeutral opAssociative
<span class="kr">where</span>
  <span class="nf">unit</span> <span class="ow">:</span> <span class="kt">Nat</span>
  unit <span class="ow">=</span> <span class="mi">0</span>
  <span class="nf">op</span> <span class="ow">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span>
  op <span class="ow">=</span> plus
  <span class="nf">unitNeutral</span> <span class="ow">:</span> <span class="ow">(</span>x <span class="ow">:</span> <span class="kt">Nat</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>op unit x <span class="ow">=</span> x, op x unit <span class="ow">=</span> x<span class="ow">)</span>
  unitNeutral n <span class="ow">=</span> <span class="ow">(</span>plusZeroLeftNeutral n, plusZeroRightNeutral n<span class="ow">)</span>
  <span class="nf">opAssociative</span> <span class="ow">:</span> <span class="ow">(</span>x, y, z <span class="ow">:</span> <span class="kt">Nat</span><span class="ow">)</span> <span class="ow">-&gt;</span> op x <span class="ow">(</span>op y z<span class="ow">)</span> <span class="ow">=</span> op <span class="ow">(</span>op x  y<span class="ow">)</span> z
  opAssociative <span class="ow">=</span> plusAssociative</code></pre></div>
<p>ここまで問題なく定義できます。
もう1つくらいインスタンスを作ってみます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Max</span>

<span class="ow">%</span>hint
<span class="nf">natMaxCorrectMonoid</span> <span class="ow">:</span> <span class="kt">CorrectMonoid</span> <span class="kt">Nat</span> <span class="kt">Max</span>
natMaxCorrectMonoid <span class="ow">=</span> <span class="kt">MkCorrectMonoid</span> unit op unitNeutral opAssociative
<span class="kr">where</span>
  <span class="nf">unit</span> <span class="ow">:</span> <span class="kt">Nat</span>
  unit <span class="ow">=</span> <span class="mi">0</span>
  <span class="nf">op</span> <span class="ow">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span>
  op <span class="ow">=</span> maximum
  <span class="nf">unitNeutral</span> <span class="ow">:</span> <span class="ow">(</span>x <span class="ow">:</span> <span class="kt">Nat</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>op unit x <span class="ow">=</span> x, op x unit <span class="ow">=</span> x<span class="ow">)</span>
  unitNeutral n <span class="ow">=</span> <span class="ow">(</span>maximumZeroNRight n, maximumZeroNLeft n<span class="ow">)</span>
  <span class="nf">opAssociative</span> <span class="ow">:</span> <span class="ow">(</span>x, y, z <span class="ow">:</span> <span class="kt">Nat</span><span class="ow">)</span> <span class="ow">-&gt;</span> op x <span class="ow">(</span>op y z<span class="ow">)</span> <span class="ow">=</span> op <span class="ow">(</span>op x  y<span class="ow">)</span> z
  opAssociative <span class="ow">=</span> maximumAssociative</code></pre></div>
<p>これを使う関数も定義してみましょう。
ここでもauto implicit argumentsを使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">foldAll</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a o<span class="ow">}</span> <span class="ow">-&gt;</span> <span class="kt">List</span> a <span class="ow">-&gt;</span> a
foldAll <span class="ow">=</span> foldl op unit</code></pre></div>
<p>もうちょっと踏み込んでみましょう。演算を <code>Add</code> に限定した <code>sum</code> も定義してみます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">sumAll</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a <span class="kt">Add</span><span class="ow">}</span> <span class="ow">-&gt;</span> <span class="kt">List</span> a <span class="ow">-&gt;</span> a
sumAll <span class="ow">=</span> foldAll</code></pre></div>
<p>これを使ってみます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kt">Idris</span><span class="ow">&gt;</span> sumAll <span class="ow">[</span><span class="kt">Z</span>, <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span><span class="ow">]</span>
<span class="nf">6</span> <span class="ow">:</span> <span class="kt">Nat</span></code></pre></div>
<p>デフォルトでIntegerに推論されるので無理矢理 <code>Nat</code> にするために <code>Z</code> を突っ込んでますが、おおむね自然に使えてますね。</p>

<p><code>foldAll</code> のように演算が決まってない関数は <code>o</code> のimplicit argumentsに使いたい演算（と対応関係にある型）を渡してあげるとそれを使ってくれます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kt">Idris</span><span class="ow">&gt;</span> foldAll <span class="ow">{</span>o <span class="ow">=</span> <span class="kt">Max</span><span class="ow">}</span> <span class="ow">[</span><span class="kt">Z</span>, <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span><span class="ow">]</span>
<span class="nf">3</span> <span class="ow">:</span> <span class="kt">Nat</span></code></pre></div>
<p>どうやらauto implicit argumentsとインタフェースでは探索する条件が違うっぽくて、auto implicit argumentsを使えばちゃんとインスタンスをさがせるようです。
多分インタフェースが関数から型を逆算してるのに対してauto implicit argumentsは最初に書いた型から探索してて探しやすいんですかね。</p>

<p>ひとまず正しいモノイドが定義でたようです。</p>

<h2 id="インタフェースを拡張する">インタフェースを拡張する</h2>

<p>モノイドと定義できて満足したあなたはモノイドを拡張して可換モノイドも定義したくなりましたね。
ちょっとボイラープレートが多いですがそれも可能です。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">record</span> <span class="kt">CorrectCommMonoid</span> a o <span class="kr">where</span>
  constructor <span class="kt">MkCorrectCommMonoid</span>
  <span class="nf">_super</span> <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a o
  <span class="nf">_opCommutative</span> <span class="ow">:</span> <span class="ow">(</span>x, y <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>_op _super<span class="ow">)</span> x y <span class="ow">=</span> <span class="ow">(</span>_op _super<span class="ow">)</span> y x

<span class="kr">name</span>space <span class="kt">CorrectCommMonoid</span>
  <span class="nf">fromCorrectMonoid</span> <span class="ow">:</span> <span class="ow">(</span>super <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a o<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">((</span>x, y <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>_op super<span class="ow">)</span> x y <span class="ow">=</span> <span class="ow">(</span>_op super<span class="ow">)</span> y x<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">CorrectCommMonoid</span> a o
  fromCorrectMonoid super _opCommutative <span class="ow">=</span> <span class="kt">MkCorrectCommMonoid</span>
    super
    _opCommutative

  <span class="nf">unit</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectCommMonoid</span> a o<span class="ow">}</span> <span class="ow">-&gt;</span> a
  unit <span class="ow">{</span>impl<span class="ow">}</span> <span class="ow">=</span> _unit <span class="ow">(</span>_super impl<span class="ow">)</span>

  <span class="nf">op</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectCommMonoid</span> a o<span class="ow">}</span> <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> a <span class="ow">-&gt;</span> a
  op <span class="ow">{</span>impl<span class="ow">}</span> <span class="ow">=</span> _op <span class="ow">(</span>_super impl<span class="ow">)</span>

  <span class="nf">unitNeutral</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectCommMonoid</span> a o<span class="ow">}</span>
                <span class="ow">-&gt;</span> <span class="ow">(</span>x <span class="ow">:</span> a<span class="ow">)</span>
                <span class="ow">-&gt;</span> <span class="ow">((</span>_op <span class="ow">(</span>_super impl<span class="ow">))</span> <span class="ow">(</span>_unit <span class="ow">(</span>_super impl<span class="ow">))</span> x <span class="ow">=</span> x, <span class="ow">(</span>_op <span class="ow">(</span>_super impl<span class="ow">))</span> x <span class="ow">(</span>_unit <span class="ow">(</span>_super impl<span class="ow">))</span> <span class="ow">=</span> x<span class="ow">)</span>
  unitNeutral <span class="ow">{</span>impl<span class="ow">}</span> <span class="ow">=</span> _unitNeutral <span class="ow">(</span>_super impl<span class="ow">)</span>

  <span class="nf">opAssociative</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectCommMonoid</span> a o<span class="ow">}</span> <span class="ow">-&gt;</span> <span class="ow">(</span>x, y, z <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>_op <span class="ow">(</span>_super impl<span class="ow">))</span> x <span class="ow">((</span>_op <span class="ow">(</span>_super impl<span class="ow">))</span> y z<span class="ow">)</span> <span class="ow">=</span> <span class="ow">(</span>_op <span class="ow">(</span>_super impl<span class="ow">))</span> <span class="ow">((</span>_op <span class="ow">(</span>_super impl<span class="ow">))</span> x  y<span class="ow">)</span> z
  opAssociative <span class="ow">{</span>impl<span class="ow">}</span> <span class="ow">=</span> _opAssociative <span class="ow">(</span>_super impl<span class="ow">)</span>

  <span class="nf">opCommutative</span> <span class="ow">:</span> <span class="ow">{</span><span class="kr">auto</span> impl <span class="ow">:</span> <span class="kt">CorrectCommMonoid</span> a o<span class="ow">}</span> <span class="ow">-&gt;</span> <span class="ow">(</span>x, y <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>_op <span class="ow">(</span>_super impl<span class="ow">))</span> x y <span class="ow">=</span> <span class="ow">(</span>_op <span class="ow">(</span>_super impl<span class="ow">))</span> y x
  opCommutative <span class="ow">{</span>impl<span class="ow">}</span> <span class="ow">=</span> _opCommutative impl

<span class="ow">%</span>hint
<span class="nf">natAddCorrectCommMonoid</span> <span class="ow">:</span> <span class="kt">CorrectCommMonoid</span> <span class="kt">Nat</span> <span class="kt">Add</span>
natAddCorrectCommMonoid <span class="ow">=</span> fromCorrectMonoid natAddCorrectMonoid opCommutative
<span class="kr">where</span>
  <span class="nf">opCommutative</span> <span class="ow">:</span> <span class="ow">(</span>x, y <span class="ow">:</span> <span class="kt">Nat</span><span class="ow">)</span> <span class="ow">-&gt;</span> plus x y <span class="ow">=</span> plus y x
  opCommutative <span class="ow">=</span> plusCommutative

<span class="ow">%</span>hint
<span class="nf">natMaxCorrectCommMonoid</span> <span class="ow">:</span> <span class="kt">CorrectCommMonoid</span> <span class="kt">Nat</span> <span class="kt">Max</span>
natMaxCorrectCommMonoid <span class="ow">=</span> fromCorrectMonoid natMaxCorrectMonoid opCommutative
<span class="kr">where</span>
  <span class="nf">opCommutative</span> <span class="ow">:</span> <span class="ow">(</span>x, y <span class="ow">:</span> <span class="kt">Nat</span><span class="ow">)</span> <span class="ow">-&gt;</span> maximum x y <span class="ow">=</span> maximum y x
  opCommutative <span class="ow">=</span> maximumCommutative</code></pre></div>
<p>かくして目的が達成できました。</p>

<h1 id="余談">余談</h1>

<h2 id="その1">その1</h2>

<p><code>foldAll</code> はインタフェースのように <code>CorrectMonoid a o =&gt;</code> で書くこともできます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">foldAll</span> <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a o <span class="ow">=&gt;</span> <span class="kt">List</span> a <span class="ow">-&gt;</span> a
foldAll <span class="ow">=</span> foldl op unit</code></pre></div>
<p>多分「インタフェースが暗黙の引数になる」+「auto implicit parametersはローカル変数からも探索する」の合わせ技だと思います。
これだけならOKです。</p>

<p>ですがそれをやると <code>sumAll</code> で死にます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">sumAll</span> <span class="ow">:</span> <span class="kt">CorrectMonoid</span> a <span class="kt">Add</span> <span class="ow">=&gt;</span> <span class="kt">List</span> a <span class="ow">-&gt;</span> a
sumAll <span class="ow">=</span> foldAll</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">- + Errors (1)
 `-- correctMonoid.idr line 59 col 9:
     When checking right hand side of sumAll with expected type
             List a -&gt; a
     
     Can&#39;t find implementation for CorrectMonoid a o</code></pre></div>
<p>暗黙の引数の探索まわりは謎が多いです。</p>

<h2 id="その2">その2</h2>

<p>Idrisのcontribには既存の（正しくない）代数構造を継承して演算に課される条件の証明を持つようにしたインタフェース群が定義されています。</p>

<p><a href="https://www.idris-lang.org/docs/current/contrib_doc/docs/Interfaces.Verified.html">IdrisDoc: Interfaces.Verified</a></p>

<p>実装する対象が違う問題は名前付き実装を使っているようです。</p>

<h1 id="まとめ">まとめ</h1>

<p>Idrisで正しいモノイドを定義する方法を模索しました。
その過程でインタフェースやauto implicit argumentsなどの詳細に踏み込みました。</p>
                    </section>
                </article>
            </div>
        </div>

        <div class="row li-author">
    <div class="sixteen columns">
        Written by <strong>κeen</strong>
    </div>
</div>


        <div class="row li-pagination">
            <div class="eight columns">
                <div class="li-pagination-previous">
                    
                        Later article<br />
                        <a href="https://KeenS.github.io/blog/2020/12/27/ronbunmemo_the_third_homomorphism_theorem/"> 論文メモ：The Third Homomorphism Theorem</a>
                    
                </div>
            </div>
            <div class="eight columns">
                <div class="li-pagination-next">
                    
                        Older article<br />
                        <a href="https://KeenS.github.io/blog/2020/12/25/rustnomutexnopoisoning/"> RustのMutexのPoisoning</a>
                    
                </div>
            </div>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2021. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="https://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>

