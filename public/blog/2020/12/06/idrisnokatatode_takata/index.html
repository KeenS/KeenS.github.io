<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-43779888-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-43779888-1');
        </script>
        

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <meta name="twitter:site" content="@blackenedgold" />
        <meta name="twitter:title" content="Idrisの型とデータ型 | κeenのHappy Hacκing Blog"/>
        <meta name="twitter:description" content="このエントリはIdris Advent Calendar 2020の7日目の記事です。
前はrigh1113さんで自然数の加法の交換法則 by Idrisでした。

κeenです。今日は型とデータ型を紹介します。" />
        <meta property="og:title" content="Idrisの型とデータ型 | κeenのHappy Hacκing Blog" />
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https:///blog/2020/12/06/idrisnokatatode_takata/" />
        <meta property="og:description" content="このエントリはIdris Advent Calendar 2020の7日目の記事です。
前はrigh1113さんで自然数の加法の交換法則 by Idrisでした。

κeenです。今日は型とデータ型を紹介します。" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta property="og:image" content="https://KeenS.github.io/images/ogp/post/Idrisnokatatode_takata.png" />
        <meta name="twitter:image" content="https://KeenS.github.io/images/ogp/post/Idrisnokatatode_takata.png" />
        
        <meta property="og:article:published_time" content="2020-12-06 16:13:22 &#43;0900 JST" />
        <meta property="og:article:modified_time" content="2020-12-06 16:13:22 &#43;0900 JST" />
        
        <meta property="og:article:author" content="κeen" />

        <title>Idrisの型とデータ型 | κeenのHappy Hacκing Blog</title>
        <link rel="stylesheet" href='//fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css' />
        <link rel="stylesheet" href="/libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="/css/liquorice.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
        <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="/manifest.json">
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
        <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-144-precomposed.png" sizes="144x144" />
        <link rel="stylesheet" href="/css/syntax-monokai.css" />
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<link rel="stylesheet" href="//unpkg.com/mermaid@7.0.4/dist/mermaid.forest.min.css">

    </head>
    <body class="li-body">

<header class="li-page-header" id="page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="/">κeenのHappy Hacκing Blog</a> | Lispエイリアンの狂想曲</div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="/about/"> About </a></li>
                        
                            <li><a href="/index.xml"> Atom </a></li>
                        
                            <li><a href="/post/"> Blog </a></li>
                        
                            <li><a href="/slide/"> Slide </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="/about/"> About </a></li>
                    
                        <li><a href="/index.xml"> Atom </a></li>
                    
                        <li><a href="/post/"> Blog </a></li>
                    
                        <li><a href="/slide/"> Slide </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>






    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                    <header class="li-article-header">
                        <h1 class="li-article-title">Idrisの型とデータ型</h1>
                        <div class="li-article-meta">
    <time class="li-article-date">2020-12-06</time>
    <ul class="li-article-tag">
    
        <li>
            <a href="/categories/idris">Idris</a>
        </li>
    
        <li>
            <a href="/categories/idris-advent-calendar">Idris Advent Calendar</a>
        </li>
    
        <li>
            <a href="/categories/advent-calendar-2020">Advent Calendar 2020</a>
        </li>
    
        <li>
            <a href="/categories/advent-calendar">Advent Calendar</a>
        </li>
    
</ul>

</div>

                    </header>
                    <section>
                        <p>このエントリは<a href="https://qiita.com/advent-calendar/2020/idris">Idris Advent Calendar 2020</a>の7日目の記事です。
前はrigh1113さんで<a href="https://righ1113.hatenablog.com/entry/2020/12/05/074034">自然数の加法の交換法則 by Idris</a>でした。</p>

<p>κeenです。今日は型とデータ型を紹介します。</p>

<h1 id="プリミティブ">プリミティブ</h1>

<p>先日紹介したとおり、プリミティブは以下です。</p>

<table>
<thead>
<tr>
<th>名前</th>
<th>説明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>Int</code></td>
<td>固定長整数</td>
</tr>

<tr>
<td><code>Integer</code></td>
<td>多倍長整数</td>
</tr>

<tr>
<td><code>Double</code></td>
<td>倍精度浮動小数点数</td>
</tr>

<tr>
<td><code>Char</code></td>
<td>文字</td>
</tr>

<tr>
<td><code>String</code></td>
<td>文字列</td>
</tr>

<tr>
<td><code>Ptr</code></td>
<td>FFI用</td>
</tr>
</tbody>
</table>

<p>Haskellに慣れている方に注意ですが、 <code>String</code> は <code>List Char</code> ではありません。</p>

<h1 id="データ型">データ型</h1>

<p>先日紹介したとおり、データ型は <code>data 名前 = 定義</code> の構文で定義します。
定義のところには <code>ヴァリアント | ヴァリアント…</code> と書きます。
ヴァリアントには <code>コンストラクタ 引数の型 …</code> と書きます。
ヴァリアントは少なくとも1つ、コンストラクタの引数は0以上を書きます。</p>

<p>例：引数のないコンストラクタのヴァリアントを2つ持つデータ型</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">True</span> <span class="ow">|</span> <span class="kt">False</span></code></pre></div>
<p>例：引数の2つあるコンストラクタのヴァリアントを1つ持つデータ型</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">MkPerson</span> <span class="kt">Int</span> <span class="kt">String</span></code></pre></div>
<p>引数ありのコンストラクタのヴァリアントを1つ持つデータ型は頻出パターンで、構造体のように使えます。
そのときのコンストラクタが構造体のコンストラクタのようになります。こういうときは <code>MkHoge</code> と <code>Mk</code> （makeの略）を前置するのが慣例です。</p>

<p>例： 引数のあるコンストラクタや引数のないコンストラクタのヴァリアントのあるデータ型</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">FizzBuzz</span> <span class="ow">=</span> <span class="kt">F</span> <span class="ow">|</span> <span class="kt">B</span> <span class="ow">|</span> <span class="kt">FB</span> <span class="ow">|</span> <span class="kt">I</span> <span class="kt">Integer</span></code></pre></div>
<p>データ型は自身を定義に使う再帰的定義もできます。</p>

<p>例：任意個の整数を保持できる型の定義</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">IntList</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="kt">Int</span> <span class="kt">IntList</span> <span class="ow">|</span> <span class="kt">Nil</span>

<span class="kt">Cons</span> <span class="mi">1</span> <span class="ow">(</span><span class="kt">Cons</span> <span class="mi">2</span> <span class="ow">(</span><span class="kt">Cons</span> <span class="mi">3</span> <span class="kt">Nil</span><span class="ow">))</span></code></pre></div>
<h2 id="データ型とパターンマッチ">データ型とパターンマッチ</h2>

<p>データ型のコンストラクタは値を構築するときだけでなく分解するときにも使います。
パターンマッチでそのままマッチできるのです。</p>

<p>例： <code>Person</code> 型から1つ目の引数、2つ目の引数の値を取り出す関数の定義</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">age</span> <span class="ow">:</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
age <span class="ow">(</span><span class="kt">MkPerson</span> age <span class="kr">_</span><span class="ow">)</span> <span class="ow">=</span> age

<span class="kr">name</span> <span class="ow">:</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="kr">name</span> <span class="ow">(</span><span class="kt">MkPerson</span> <span class="kr">_</span> name<span class="ow">)</span> <span class="ow">=</span> name</code></pre></div>
<p><code>|</code> で複数のバリアントを定義しているデータ型には分岐を使うことになるでしょう。</p>

<p>例： 複数バリアントのあるデータ型へのパターンマッチで分岐するコード</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">show</span> <span class="ow">:</span> <span class="kt">FizzBuzz</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
show <span class="kt">F</span>     <span class="ow">=</span> <span class="s">&#34;fizz&#34;</span>
show <span class="kt">B</span>     <span class="ow">=</span> <span class="s">&#34;buzz&#34;</span>
show <span class="kt">FB</span> <span class="ow">=</span> <span class="s">&#34;fizzbuzz&#34;</span>
show <span class="ow">(</span><span class="kt">I</span> n<span class="ow">)</span>  <span class="ow">=</span> toString n
<span class="c1">-- toStringは実際は存在しないが、説明の簡単さのために使う。</span></code></pre></div>
<p>再帰的データ型なら呼応するように再帰関数を使うことになります。</p>

<p>例： 再帰関数を用いて <code>IntList</code> の長さを求めるコード</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">length</span> <span class="ow">:</span> <span class="kt">IntList</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
length <span class="kt">Nil</span>         <span class="ow">=</span> <span class="mi">0</span>
length <span class="ow">(</span><span class="kt">Cons</span> <span class="kr">_</span> tl<span class="ow">)</span> <span class="ow">=</span> <span class="mi">1</span> <span class="ow">+</span> <span class="ow">(</span>length tl<span class="ow">)</span></code></pre></div>
<p>このようにデータ型からプログラムの構造が自然と決まるのでデータ型は便利かつ重要な機能です。</p>

<h1 id="ジェネリクス">ジェネリクス</h1>

<p>上記の <code>IntList</code> は <code>Int</code> の値のみ保持できました。
これを任意のデータを保持できるようにするにはジェネリクスを使います。
つまり <code>IntList</code> を保持するデータ型について一般化するのです。</p>

<p>一般化したときの型は引数で受け取れるようにし、それを型変数で表します。</p>

<p>ジェネリクスで使う型変数は関数の引数のように <code>List a</code> と置きます。
小文字の変数が自動で型変数として扱われます。
そして <code>List</code> の定義のところで <code>Int</code> だった部分を <code>a</code> で置き換えます。</p>

<p>例：任意の型について、その型の値を任意個保持できるデータ型の定義</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">List</span> a <span class="ow">=</span> <span class="kt">Cons</span> a <span class="kt">IntList</span> <span class="ow">|</span> <span class="kt">Nil</span>

<span class="kt">Cons</span> <span class="mi">1</span> <span class="ow">(</span><span class="kt">Cons</span> <span class="mi">2</span> <span class="ow">(</span><span class="kt">Cons</span> <span class="mi">3</span> <span class="kt">Nil</span><span class="ow">))</span>
<span class="kt">Cons</span> <span class="sc">&#39;a&#39;</span> <span class="ow">(</span><span class="kt">Cons</span> <span class="sc">&#39;b&#39;</span> <span class="ow">(</span><span class="kt">Cons</span> <span class="sc">&#39;c&#39;</span> <span class="kt">Nil</span><span class="ow">))</span></code></pre></div>
<p>関数定義も同様にジェネリクスにできます。
関数定義は特に引数などを導入せずにそのまま小文字の変数を使うだけでジェネリクスになります。</p>

<p>例： <code>List a</code> の長さを求めるコード</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">length</span> <span class="ow">:</span> <span class="kt">List</span> a <span class="ow">-&gt;</span> <span class="kt">Int</span>
length <span class="kt">Nil</span>         <span class="ow">=</span> <span class="mi">0</span>
length <span class="ow">(</span><span class="kt">Cons</span> <span class="kr">_</span> tl<span class="ow">)</span> <span class="ow">=</span> <span class="mi">1</span> <span class="ow">+</span> <span class="ow">(</span>length tl<span class="ow">)</span></code></pre></div>
<h1 id="レコード">レコード</h1>

<p><code>Person</code> 型のように事実上構造体として扱うデータ型の定義は専用の便利構文が用意されています。</p>

<p><code>Person</code> 型とそのメンバーへのアクセサは以下のように定義されているのでした。</p>

<p>例：データ型を構造体のように使うコード（再掲）</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">MkPerson</span> <span class="kt">Int</span> <span class="kt">String</span>

<span class="nf">age</span> <span class="ow">:</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
age <span class="ow">(</span><span class="kt">MkPerson</span> age <span class="kr">_</span><span class="ow">)</span> <span class="ow">=</span> age

<span class="kr">name</span> <span class="ow">:</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="kr">name</span> <span class="ow">(</span><span class="kt">MkPerson</span> <span class="kr">_</span> name<span class="ow">)</span> <span class="ow">=</span> name</code></pre></div>
<p>これとほぼ同等のことを <code>record</code> 構文でできます。
レコードは <code>record 名前 [型引数…] where 本体</code> で定義します。
本体には <code>constructor コンストラクタ名</code> か <code>フィールド, …: 型</code> を書きます。
例えば以下のように使います。</p>

<p>例： <code>MkPerson</code> をレコードで定義するコード</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">record</span> <span class="kt">Person</span> <span class="kr">where</span>
  constructor <span class="kt">MkPerson</span>
  <span class="nf">age</span><span class="ow">:</span> <span class="kt">Int</span>
  <span class="kr">name</span><span class="ow">:</span> <span class="kt">String</span></code></pre></div>
<p>これは裏では以下のようなコードが生成されているようです。</p>

<p>例： <code>MkPerson</code> をレコードで定義するコードを展開したイメージ</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">MkPerson</span> <span class="kt">Int</span> <span class="kt">String</span>

<span class="nf">age</span> <span class="ow">:</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
age <span class="ow">(</span><span class="kt">MkPerson</span> age <span class="kr">_</span><span class="ow">)</span> <span class="ow">=</span> age

<span class="kr">name</span> <span class="ow">:</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="kr">name</span> <span class="ow">(</span><span class="kt">MkPerson</span> <span class="kr">_</span> name<span class="ow">)</span> <span class="ow">=</span> name

<span class="nf">set_age</span> <span class="ow">:</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Person</span>
set_age age <span class="ow">(</span><span class="kt">MkPerson</span> <span class="kr">_</span> name<span class="ow">)</span> <span class="ow">=</span> <span class="kt">MkPerson</span> age name

<span class="nf">set_name</span> <span class="ow">:</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Person</span>
set_name name <span class="ow">(</span><span class="kt">MkPerson</span> age <span class="kr">_</span><span class="ow">)</span> <span class="ow">=</span> <span class="kt">MkPerson</span> age name</code></pre></div>
<p>Idrisは純粋関数型言語なので値を変更することはできません。
代わりにフィールドの値の違う新しい値を返します。</p>

<h2 id="レコードの関数型更新構文">レコードの関数型更新構文</h2>

<p><code>set_xxx</code> を呼び出すだけですが、レコードを更新する（フィールドの値を変更した新しい値を返す）構文が用意されています。
<code>record { … }</code> の形をしています。 <code>…</code> の中に入る構文はいくつか種類があります。</p>

<p>例： レコードの関数型更新構文のいくつか</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">-- フィールド = 値</span>
<span class="kr">record</span> <span class="ow">{</span> age <span class="ow">=</span> <span class="mi">29</span> <span class="ow">}</span>

<span class="c1">-- フィールド $= 更新関数</span>
<span class="kr">record</span> <span class="ow">{</span> age <span class="ow">$=</span> <span class="ow">(+</span> <span class="mi">1</span><span class="ow">)</span> <span class="ow">}</span>
<span class="c1">-- (+ 1) は1を足す関数</span>

<span class="c1">-- 複数のフィールドの更新</span>
<span class="kr">record</span> <span class="ow">{</span> age <span class="ow">$=</span> <span class="ow">(+</span> <span class="mi">1</span><span class="ow">)</span>, name <span class="ow">=</span> <span class="s">&#34;anonymous&#34;</span> <span class="ow">}</span></code></pre></div>
<p>他にもネストしたフィールドの更新構文なんかもあります。</p>

<p>さて、これらの構文は関数へと展開されます。</p>

<p>例：関数型更新構文が関数として振る舞うことがわかる例</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">incAge</span><span class="ow">:</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Person</span>
incAge <span class="ow">=</span> <span class="kr">record</span> <span class="ow">{</span> age <span class="ow">$=</span> <span class="ow">$(+</span> <span class="mi">1</span><span class="ow">)</span> <span class="ow">}</span></code></pre></div>
<p>なので実際に使うときは <code>record { age $= (+ 1) } p</code> のようにレコード <code>p</code> を引数として渡すことになります。</p>

<h1 id="関数の型">関数の型</h1>

<p>先日関数の型は <code>引数1の型 -&gt; 引数2の型 -&gt; … -&gt; 引数nの型 -&gt; 返り値の型</code> と紹介しましたが、あれは嘘です。
嘘というか事実上は合ってるんですが、厳密には異ります。</p>

<p>Idrisの関数の型は <code>引数の型 -&gt; 返り値の型</code> のみです。
じゃあ <code>Int -&gt; Int -&gt; Int</code> とかの型は何というと、 <code>-&gt;</code> が右結合なので <code>Int -&gt; (Int -&gt; Int)</code> と解釈される訳です。</p>

<p>同じく、関数の適用も <code>関数 引数</code> のみです。 <code>関数 引数1 引数2</code> は <code>(関数 引数) 引数</code> と解釈されます。</p>

<p>さらに、関数定義の構文 <code>関数名 引数1 … 引数n = 本体</code> もこれ以外の定義もありえます。
結果として型の帳尻さえあっていれば引数の個数は柔軟です。
例えば以下の <code>add</code> の定義は全て同等です。</p>

<p>例： <code>add</code> を関数定義構文やラムダ式やその組み合わせで定義するコード</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">-- 関数定義構文による定義</span>
<span class="nf">add</span><span class="ow">:</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
add x y <span class="ow">=</span> x <span class="ow">+</span> y

<span class="c1">-- 引数を1つ関数定義構文で受け取り、1つラムダ式で受け取る定義</span>
<span class="nf">add</span><span class="ow">:</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
add x <span class="ow">=</span> <span class="ow">\</span>y <span class="ow">=&gt;</span> x <span class="ow">+</span> y

<span class="c1">-- 引数を全てラムダ式で受け取る定義</span>
<span class="nf">add</span><span class="ow">:</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
add <span class="ow">=</span> <span class="ow">\</span>x <span class="ow">=&gt;</span> <span class="ow">\</span>y <span class="ow">=&gt;</span> x <span class="ow">+</span> y

<span class="c1">-- 複数引数をとるラムダ式による定義</span>
<span class="nf">add</span><span class="ow">:</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
add <span class="ow">=</span> <span class="ow">\</span>x, y <span class="ow">=&gt;</span> x <span class="ow">+</span> y</code></pre></div>
<p>ところで <code>Int -&gt; (Int -&gt; Int)</code> は「 <code>Int</code> を与えると <code>Int -&gt; Int</code> を返す関数」 です。
試してみましょう。 <code>add</code> に引数を1つだけ与えてみます。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">inc</span><span class="ow">:</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
inc <span class="ow">=</span> add <span class="mi">1</span></code></pre></div>
<p>つまり <code>add 1 2</code> は一度 <code>add 1</code> を計算して、その結果の関数を <code>2</code> に適用しているということになります。
毎回関数を作っては適用してを繰り返したら遅いじゃないかと思われるかもしれませんが、コンパイラの作者もそれは百も承知です。
ちゃんと最適化でそこら辺のコードは綺麗に消えます。</p>

<p>関数の引数を1つにして、代わりに「関数を返す関数を返す関数を…」とすることで言語のシンプルサを保っています。
また、そのオマケとして <code>inc</code> の定義のように引数を部分適用した関数も作りやすくなっています。</p>

<h1 id="便利な型">便利な型</h1>

<p>処理系を起動したときに最初から使える型をいくつか紹介したいと思います。</p>

<p>処理系を起動したときに最初から使える型はいくつかの場所で定義されています。</p>

<table>
<thead>
<tr>
<th>名前</th>
<th>説明</th>
</tr>
</thead>

<tbody>
<tr>
<td>プリミティブ</td>
<td>コンパイラに組込まれている</td>
</tr>

<tr>
<td>ビルトイン</td>
<td>定義は組み込みではないが、コンパイラに特別扱いされる</td>
</tr>

<tr>
<td>プレリュード</td>
<td>起動時に読み込まれるファイルで定義されている</td>
</tr>
</tbody>
</table>

<p>プリミティブとビルトインはあまり区別しないでいいかもしれません。</p>

<p>プレリュードとは何なのかについては日を改めて説明するとしましょう。
ここではプレリュードが何なのかについては触れずにそこで定義されている型を紹介するだけに留めます。</p>

<p>プミティブは冒頭で紹介したのでビルトインとプレリュードで定義された型を紹介します。</p>

<h2 id="ビルトイン">ビルトイン</h2>

<p>ビルトインで定義されているデータ型を紹介します。</p>

<h3 id="ユニット">ユニット</h3>

<p>意味のある値がないことを表わすときに使う型です。
Cなどにある <code>void</code> と似ていますが、ユニットは値を持ちます。</p>

<p>値も型も <code>()</code> で表わします。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">unit</span> <span class="ow">:</span> <span class="ow">()</span>
unit <span class="ow">=</span> <span class="ow">()</span></code></pre></div>
<p>よく使う値なのでそのうち出てきます。</p>

<h3 id="タプル">タプル</h3>

<p>値の組を表わす型です。
異なる型の値の組を保持できます。
リストなどと違って分割したり結合したりするものではないです。</p>

<p><code>(値, 値, …, 値)</code> の構文で記述します。型も <code>(型, 型, …, 型)</code> と書きます。</p>

<p>例：タプルの値と型</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">triple</span> <span class="ow">:</span> <span class="ow">(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Bool</span><span class="ow">)</span>
triple <span class="ow">=</span> <span class="ow">(</span><span class="mi">1</span>, <span class="s">&#34;string&#34;</span>, <span class="kt">True</span><span class="ow">)</span></code></pre></div>
<h3 id="その他">その他</h3>

<p>込み入った説明が必要になるので詳しくは解説しませんが、いくつか興味深いビルトインの型を紹介します。</p>

<ul>
<li>依存ペア（<code>a: Type ** P a</code>）: 依存ペア。存在量化に相当する。</li>
<li><code>Void</code> ： 値がないことを表わす。矛盾に相当する。</li>
<li><code>Lazy a</code> ：遅延計算に使う</li>
</ul>

<h2 id="プレリュード">プレリュード</h2>

<p>プレリュードで定義されている型を紹介します。</p>

<h3 id="bool">Bool</h3>

<p>ブール型です。以下のように定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">||| Boolean Data Type</span>
<span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">False</span> <span class="ow">|</span> <span class="kt">True</span></code></pre></div>
<p>Idrisはかなり色々な機能をもつのでブール値をライブラリで定義してしまえます。
例えば <code>if ~ then ~ else ~</code> やショートサーキット演算子 <code>&amp;&amp;</code> / <code>||</code> なんかもライブラリ定義です。
これはアドベントカレンダーのどこかで紹介できたらなと思います。</p>

<h3 id="either">Either</h3>

<p>「どちらか」 を表わす型です。おおむね以下のように定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">||| A sum type</span>
<span class="kr">data</span> <span class="kt">Either</span> a b <span class="ow">=</span>
  <span class="c1">||| One possibility of the sum, conventionally used to represent errors</span>
  <span class="kt">Left</span> a <span class="ow">|</span>
  <span class="c1">||| The other possibility, conventionally used to represent success</span>
  <span class="kt">Right</span> b</code></pre></div>
<p>典型的にはエラーを表わすのに使います。</p>

<p>例： <code>Either</code> を使ってエラーを表わすコード</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">divide</span><span class="ow">:</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
divide <span class="kr">_</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&#34;division by zero&#34;</span>
divide m n <span class="ow">=</span> <span class="kt">Right</span> <span class="ow">(</span>m `div` n<span class="ow">)</span></code></pre></div>
<p>慣例的に、 <code>Left</code> がエラー、 <code>Right</code> が正しい値を表わします。
よく、 「<code>Right</code> がright（正しい）と覚えましょう」と言われてます。</p>

<h3 id="list">List</h3>

<p>任意の型について、その型の値を任意個保持できるコレクションです。</p>

<p>おおむね以下のように定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="kr">infixr</span> <span class="mi">7</span> <span class="ow">::</span>

<span class="c1">||| Generic lists</span>
<span class="kr">data</span> <span class="kt">List</span> elem <span class="ow">=</span>
  <span class="c1">||| Empty list</span>
  <span class="kt">Nil</span> <span class="ow">|</span>
  <span class="c1">||| A non-empty list, consisting of a head element and the rest of</span>
  <span class="c1">||| the list.</span>
  <span class="ow">(::)</span> elem <span class="ow">(</span><span class="kt">List</span> elem<span class="ow">)</span></code></pre></div>
<p>上の方で定義した <code>List</code> とほぼ同じですね。
ただし <code>Cons</code> の代わりに中置演算子 <code>::</code> が用いられています。</p>

<p>紹介し忘れましたがデータ型のコンストラクタは関数と同等に振る舞うので関数と同様に中置演算子として扱えます。
パターンマッチするときにも中置のままパターンマッチできます。
例をみてみましょう。</p>

<p>例： <code>List</code> 型のパターンマッチと構築を行うコード</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">addAll</span> <span class="ow">:</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="kt">Int</span>
addAll <span class="kr">_</span> <span class="kt">Nil</span>     <span class="ow">=</span> <span class="kt">Nil</span>
addAll a <span class="ow">(</span>x<span class="ow">::</span>xs<span class="ow">)</span> <span class="ow">=</span> <span class="ow">(</span>a <span class="ow">+</span> x<span class="ow">)</span> <span class="ow">::</span> <span class="ow">(</span>addAll a xs<span class="ow">)</span></code></pre></div>
<p>関数の引数で <code>Nil</code> と <code>::</code> へのパターンマッチを、 関数の本体で <code>Nil</code> と <code>::</code> の構築を行っています。</p>

<h4 id="listの構文">Listの構文</h4>

<p>さて、 <code>List</code> にはいくつか特別な構文が用意されています。</p>

<p><code>[1, 2, 3]</code> と書くと <code>1 :: 2 :: 3 :: Nil</code> と書いたのと同じことになります（<code>::</code> は右結合の演算子なので <code>1 :: 2 :: 3 :: Nil</code> は <code>1 :: (2 :: (3 :: Nil))</code> と解釈されます）。
これは値としてもパターンとしても使えます。</p>

<p><code>[start..end]</code> と書くとstartからendまで（endを含む）の値のリスト返します。</p>

<p>例：1, 2, 3のリストの構築</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="ow">[</span><span class="mi">1</span><span class="ow">..</span><span class="mi">3</span><span class="ow">]</span></code></pre></div>
<p>刻み幅を変更することもできます。</p>

<p>例：1から2つ飛ばしで10以下の値、1, 3, 5, 7, 9を含むリストの構築</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="ow">[</span><span class="mi">1</span>, <span class="mi">3</span><span class="ow">..</span><span class="mi">10</span><span class="ow">]</span></code></pre></div>
<p>また、PythonやHaskellにあるリスト内包表記もあります。
<code>[式 | 修飾]</code> の構文です。
修飾に書ける構文は <code>変数 &lt;- リスト</code> をカンマ区切りで置けるなどがあります。
例えば九九を生成するリスト内包表記は以下です。</p>

<p>例：1×1〜9×9までの結果を生成するリスト内包表記</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="ow">[</span> i <span class="ow">*</span> j <span class="ow">|</span> i <span class="ow">&lt;-</span> <span class="ow">[</span><span class="mi">1</span><span class="ow">..</span><span class="mi">9</span><span class="ow">]</span>, j <span class="ow">&lt;-</span> <span class="ow">[</span><span class="mi">1</span><span class="ow">..</span><span class="mi">9</span><span class="ow">]]</span></code></pre></div>
<p>あるいは、修飾の部分に条件式を書くことでその条件に合った値のみを集めることもできます。</p>

<p>例：2, 4, 6, 8, 10のリストを生成するリスト内包表記</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="ow">[</span>n <span class="ow">|</span> n <span class="ow">&lt;-</span> <span class="ow">[</span><span class="mi">1</span><span class="ow">..</span><span class="mi">10</span><span class="ow">]</span>, n `mod` <span class="mi">2</span> <span class="ow">==</span> <span class="mi">0</span><span class="ow">]</span></code></pre></div>
<h3 id="maybe">Maybe</h3>

<p><code>Maybe</code> は「値があるか、あるいはない」を表わす型です。おおむね以下のように定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">||| An optional value. This can be used to represent the possibility of</span>
<span class="c1">||| failure, where a function may return a value, or not.</span>
<span class="kr">data</span> <span class="kt">Maybe</span> a <span class="ow">=</span>
    <span class="c1">||| No value stored</span>
    <span class="kt">Nothing</span> <span class="ow">|</span>
    <span class="c1">||| A value of type `a` is stored</span>
    <span class="kt">Just</span> a</code></pre></div>
<p><code>Just x</code> のとき値があり、 <code>Nothing</code> のとき値がないことを表わします。
例えばリストの先頭を取り出す関数 <code>head'</code> は以下のように定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">head&#39;</span> <span class="ow">:</span> <span class="ow">(</span>l <span class="ow">:</span> <span class="kt">List</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> a
head&#39; <span class="ow">[]</span>      <span class="ow">=</span> <span class="kt">Nothing</span>
head&#39; <span class="ow">(</span>x<span class="ow">::</span>xs<span class="ow">)</span> <span class="ow">=</span> <span class="kt">Just</span> x</code></pre></div>
<p><code>[]</code> だと先頭の値がないので <code>Nothing</code> を返しています。</p>

<p>失敗を表わすという意味では <code>Either</code> と似ています。
実際、最初に <code>Maybe</code> で書き始めた関数が失敗するケースが増えてきて <code>Either</code> に書き直すなどはよくあります。</p>

<h3 id="nat">Nat</h3>

<p>ちょっとここで紹介するか迷いましたが、よく出てくるので先に紹介しておきましょう。
<code>Nat</code> は自然数を表わす型です。0からはじまり無限に続きます。
以下のように定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">||| Natural numbers: unbounded, unsigned integers which can be pattern</span>
<span class="c1">||| matched.</span>
<span class="kr">data</span> <span class="kt">Nat</span> <span class="ow">=</span>
  <span class="c1">||| Zero</span>
  <span class="kt">Z</span> <span class="ow">|</span>
  <span class="c1">||| Successor</span>
  <span class="kt">S</span> <span class="kt">Nat</span></code></pre></div>
<p>これのどこが自然数なんだと思うかもしれません。
これは<a href="https://ja.wikipedia.org/wiki/ペアノの公理">ペアノの公理</a>に基く定義です。
ペアノの公理とは以下のような記述です。</p>

<blockquote>
<p>自然数は次の5条件を満たす</p>

<ol>
<li>自然数 0 が存在する。</li>
<li>任意の自然数 a にはその後者 (successor)、suc(a) が存在する（suc(a) は a + 1 の &ldquo;意味&rdquo;）。</li>
<li>0 はいかなる自然数の後者でもない（0 より前の自然数は存在しない）。</li>
<li>異なる自然数は異なる後者を持つ：a ≠ b のとき suc(a) ≠ suc(b) となる。</li>
<li>0 がある性質を満たし、a がある性質を満たせばその後者 suc(a) もその性質を満たすとき、すべての自然数はその性質を満たす。</li>
</ol>
</blockquote>

<p>このうち1. は <code>Z</code> 、 <code>2</code> は <code>S</code> が担当しています。
Idrisのデータ型では3.、4.は自動で満たされます。5はIdrisの型システムが担当します。</p>

<p>ということで上記 <code>Nat</code> は自然数とみなしてよさそうです。
<code>Nat</code> を直接使って数字を表わすのは以下のようにします。</p>

<p>例： <code>S</code> と <code>Z</code> を使って <code>Nat</code> の3を構築</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">three</span> <span class="ow">:</span> <span class="kt">Nat</span>
three <span class="ow">=</span> <span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> <span class="ow">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="ow">))</span></code></pre></div>
<p><code>S</code> が <code>1 +</code> 相当なので <code>S</code> の数を数えれば何の数値か分かります。
ですがコンパイラの方で数値から <code>Nat</code> へ変換してくれるので以下のようにも書けます。</p>

<p>例：数値リテラルを使って<code>Nat</code> の3を構築</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">three</span> <span class="ow">:</span> <span class="kt">Nat</span>
three <span class="ow">=</span> <span class="mi">3</span></code></pre></div>
<p>自然数はインデックスや長さとして使われたりします。
例えばリストの長さを求める関数 <code>length</code> は以下のように定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">length</span> <span class="ow">:</span> <span class="kt">List</span> a <span class="ow">-&gt;</span> <span class="kt">Nat</span>
length <span class="ow">[]</span>      <span class="ow">=</span> <span class="kt">Z</span>
length <span class="ow">(</span>x<span class="ow">::</span>xs<span class="ow">)</span> <span class="ow">=</span> <span class="kt">S</span> <span class="ow">(</span>length xs<span class="ow">)</span></code></pre></div>
<h1 id="型の型">型の型？</h1>

<p>さて、以前Idrisは値を型の一部として扱えると書きましたが、型を値の一部としても扱えます。
すると関数や変数の型を書くときに「型の型」も必要になります。
「型の型」は <code>Type</code> です。</p>

<h2 id="型エイリアス">型エイリアス</h2>

<p>「型とデータ型」というタイトルでありながら、いままで型エイリアスの紹介がありませんでしたね。
それもそのはず、Idrisには型エイリアスの機能がありません。
いや、あるんですが、「型エイリアス」という機能としては存在しません。</p>

<p>どういうことかというと、型も値として扱えるので、グローバル変数を束縛してしまえばそのまま型エイリアスとして機能するのです。</p>

<p>例：型を変数に束縛して型エイリアスとして使うコード</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="nf">IntList</span> <span class="ow">:</span> <span class="kt">Type</span>
<span class="kt">IntList</span> <span class="ow">=</span> <span class="kt">List</span> <span class="kt">Int</span></code></pre></div>
<h2 id="型アノテーション">型アノテーション</h2>

<p>いくつかの言語では式中で <code>1 : Int</code> のように式がどの型になるかを明示する機能があります。
しかしIdrisにはありません。
型エイリアスと同じく「型アノテーション」という機能としては存在しません。</p>

<p>型アノテーションは関数として書けてしまいます。
プレリュードで <code>the</code> という関数として定義されています。</p>
<div class="highlight"><pre class="chroma"><code class="language-idris" data-lang="idris"><span class="c1">||| Manually assign a type to an expression.</span>
<span class="c1">||| @ a the type to assign</span>
<span class="c1">||| @ value the element to get the type</span>
<span class="nf">the</span> <span class="ow">:</span> <span class="ow">(</span>a <span class="ow">:</span> <span class="kt">Type</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>value <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> a
the <span class="kr">_</span> <span class="ow">=</span> id</code></pre></div>
<p>例えば <code>the Nat 3</code> のように使えます。</p>

<h1 id="まとめ">まとめ</h1>

<p>Idrisのデータ型やレコードの構文を紹介しました。
関数の型についても解説し、1引数1返り値の関数型を組み合わせて複数引数の型のように扱っていることも紹介しました。
また、デフォルトで使えるデータ型をいくつか紹介し、データ型の利用例としました。</p>

<p>まだインターフェースや名前空間系の機能を紹介できてないのですが、次回は一旦手を動かす回にしようかなと思います。</p>
                    </section>
                </article>
            </div>
        </div>

        <div class="row li-author">
    <div class="sixteen columns">
        Written by <strong>κeen</strong>
    </div>
</div>


        <div class="row li-pagination">
            <div class="eight columns">
                <div class="li-pagination-previous">
                    
                        &nbsp;
                    
                </div>
            </div>
            <div class="eight columns">
                <div class="li-pagination-next">
                    
                        Older article<br />
                        <a href="/blog/2020/12/03/smldebakkukuo_tokihouwojitsugensuru/"> SMLでバッククォート記法を実現する</a>
                    
                </div>
            </div>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2020. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class=""><a href="https://github.com/eliasson/liquorice/">liquorice</a> is a theme for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

<script type="text/javascript">
 function toggle(id) {
     var e = document.getElementById(id);
     e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
 }
</script>
<script src="https://unpkg.com/mermaid@7.0.4/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true
     });</script>

    </body>
</html>

