<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 22 Jan 2017 13:35:46 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>コンパイラの人からみたWebAssembly</title>
      <link>/slide/konpairanoninkaramitaWebAssembly/</link>
      <pubDate>Sun, 22 Jan 2017 13:35:46 +0900</pubDate>
      
      <guid>/slide/konpairanoninkaramitaWebAssembly/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# コンパイラの人からみたWebAssembly
----------------------
[コンパイラ勉強会 - connpass](https://connpass.com/event/46850/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# アジェンダ
------------

* WebAssemblyの概要
* 具体的な話
* WebAssembly吐こうとした話

===

# WebAssemblyの概要

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===

# JavaScript
-------------

* ブラウザ上で動くスクリプト言語
* 動的型付
* 高級
* GCとかある
* 今までブラウザで動く唯一の言語だった
* 遅い
  + 各ブラウザJITなどで補強

===

# [asm.js](http://asmjs.org/)
------------

* プラウザ上で動く言語
* 低級
* GCなし
* JSのサブセット
  + asm.jsをサポートしないプラウザでも動かせる
* コンパイラから生成されることを想定
  + emscriptenなど

===

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===
# asm.jsの問題点
---------------

* JS互換文法なため嵩張る
* パースも遅い
* そもそもコンパイラが吐くならバイナリでも良いのでは？

===

# WebAssembly
--------------

* ブラウザ上で動く言語
  + 仮想機械命令？
* 低級
* バイナリフォーマット
  + ロード、パース時間が短かい
  + パース20倍くらい速いらしい
* wasm32とwasm64がある
* セマンティクスは（今のところ）ams.jsをほぼ踏襲
  + 実行エンジンは既存のものを使える
* 将来SIMD、スレッドなどの拡張が入る

===

# WASMのゴール
--------------------

* ポータブルでコンパクトで速い
* 仕様策定と実装をインクリメンタルにやっていく
  + 今はとりあえずC/C++をターゲットに
* 既存のJS環境と協調する
  + JSとの相互呼び出しとか
* ブラウザ以外への組込みもサポート
  + Node.jsとか
* プラットフォームになる
  + ツール類のサポートとか

===

# なぜWebAssembly?
------------------

* 実行までのレイテンシが短かい
* asm.jsより速度を出しやすい設計
* クライアントヘビーにしやすい？
* **JSを補完する存在**
* non-determinismが少ない
* LLVM IRと比べてデコードが速くてコンパクト
* (**code generator IR** vs optimization IR)
* 余計なことをしない
  + fast mathとかはない
  + 既に最適化されたコードが吐かれる前提

===
# WebAssemblyの現状
-------------------

* Minimum Viable Product(MVP)
* 機能を削ってとりあえず動くものを作ってる
* 今はC/C++からLLVMを通して吐けるのが目標
* 今後SIMDとかスレッドとかDOM APIとか増えていく
* ChromeとFirefoxでオプトインで使える
  + そろそろFirefoxで普通に動く

===

# 具体的な話
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# セマンティクス
---------------

* https://github.com/WebAssembly/spec
* 形式的定義されている
* 実行以外にも静的バリデーションもある
* 1ファイル1モジュール
  + JSのモジュールと同じ概念

===
# 実行モデル
--------------

* i32,i64,f32,f64のみ
  + bitエンコーディングは指定
* スタックマシン
  + 命令のオペランドや関数の引数はスタック経由で渡す
  + バイナリがコンパクト+雑にコンパイルしても速い
* 無限のローカル変数が使える
  + 型がある
* 関数の引数はローカル変数経由で渡される
* コントロールフローはgotoじゃなくてstructured
  + 静的検証がしやすい

===

# wasm、wast
------------

* バイナリフォーマットだけでは人間が読めない
* テキストフォーマットも欲しい
* バイナリ: wasm
  + コンパクト
  + intとかもパッキングする
* テキスト: wast
  + 人間可読+機械可読=S式
  + 低級にもちょっと高級にも書ける

===

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (get_local 0)
    (get_local 1)
    (call 1)
    (get_local 1)
    (get_local 0)
    (i64.sub)
    (f64.convert_s/i64)
    (f64.div)
    (call 2))
  ...)
```

===

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (call 2
      (f64.div
       (call 1 (get_local 0) (get_local 1))
       (f64.convert_s/i64
        (i64.sub
         (get_local 1)
         (get_local 0))))))
  ...)
```

===

```
0000000: 0061 736d                                 ; WASM_BINARY_MAGIC
0000004: 0d00 0000                                 ; WASM_BINARY_VERSION
; section &#34;TYPE&#34; (1)
0000008: 01                                        ; section code
0000009: 00                                        ; section size (guess)
000000a: 03                                        ; num types
; type 0
000000b: 60                                        ; func
000000c: 02                                        ; num params
000000d: 7e                                        ; i64
000000e: 7e                                        ; i64
000000f: 01                                        ; num results
0000010: 7c                                        ; f64
; type 1
0000011: 60                                        ; func
0000012: 02                                        ; num params
0000013: 7e                                        ; i64
0000014: 7e                                        ; i64
0000015: 01                                        ; num results
0000016: 7c                                        ; f64
; type 2
0000017: 60                                        ; func
0000018: 01                                        ; num params
0000019: 7c                                        ; f64
000001a: 01                                        ; num results
000001b: 7c                                        ; f64
0000009: 12                                        ; FIXUP section size
; section &#34;FUNCTION&#34; (3)
000001c: 03                                        ; section code
000001d: 00                                        ; section size (guess)
000001e: 03                                        ; num functions
000001f: 00                                        ; function 0 signature index
0000020: 01                                        ; function 1 signature index
0000021: 02                                        ; function 2 signature index
000001d: 04                                        ; FIXUP section size
; section &#34;CODE&#34; (10)
000002e: 0a                                        ; section code
000002f: 00                                        ; section size (guess)
0000030: 03                                        ; num functions
; function body 0
0000031: 00                                        ; func body size (guess)
0000032: 00                                        ; local decl count
0000033: 20                                        ; get_local
0000034: 00                                        ; local index
0000035: 20                                        ; get_local
0000036: 01                                        ; local index
0000037: 10                                        ; call
0000038: 01                                        ; func index
0000039: 20                                        ; get_local
000003a: 01                                        ; local index
000003b: 20                                        ; get_local
000003c: 00                                        ; local index
000003d: 7d                                        ; i64.sub
000003e: b9                                        ; f64.convert_s/i64
000003f: a3                                        ; f64.div
0000040: 10                                        ; call
0000041: 02                                        ; func index
0000042: 0b                                        ; end
0000031: 11                                        ; FIXUP func body size
...
```

===

# JS API
---------

``` javascript
var importObj = {js: {
    import1: () =&gt; console.log(&#34;hello,&#34;),
    import2: () =&gt; console.log(&#34;world!&#34;)
}};
fetch(&#39;demo.wasm&#39;).then(response =&gt;
    response.arrayBuffer()
).then(buffer =&gt;
    WebAssembly.instantiate(buffer, importObj)
).then(({module, instance}) =&gt;
    instance.exports.f()
```

===

# メモリ
------------

* メモリアドレスが0から始まって飛びのない **リニアメモリ**
  + 命令で伸び縮み出来る
  + 将来複数のリニアメモリとか出てくるかも
* メモリサイズは32bit(wasm32)か64bit(wasm64)が選べる
  + 現状はwasm32のみ
  + 1つのモジュールでメモリ4GiBバイトも使わないから普通は32bitで十分
* アドレッシングは `アドレス+オフセット`
* アラインメントは必須ではない（した方が速い）
* コード列のメモリは見えない
* スタックスキャンも出来ない

===

# 例外とか
----------

* Trap -- WebAssemblyのインスタンスが異常終了する
  + 例えばメモリの範囲外アクセスとか
* スタックオーバーフロー
  + オーバーフローするとインスタンスが異常終了する
  + 処理系/環境毎にスタック長は違う
    - non-determinism

===

# テーブル
----------

* 要素の配列的なもの
  + 整数インデックスでアクセス出来る
* 今のところ関数を入れてindrect callするため
* 将来的にはOSのハンドラとかGCの参照とか

===

# ローカル変数
--------------

* 無限にある型付きストレージ
* 0 初期化
* 関数の引数もローカル変数に入る

===

# グローバル変数
---------------

* 型付きストレージ
* 可変/不変がある
* 不変Globにsetするとvalidationエラー
* リニアメモリとは違うメモリ領域

===
# import / export
-----------------

* 他のモジュールから色々インポート出来る
* 関数
* テーブル
* グローバル変数
* リニアメモリ
* 勿論exportも

===
# 一旦まとめ
------------

* WASMは1ファイル1モジュール
* WASMには以下がある
  + 関数
    - 関数内ローカル変数
  + リニアメモリ
  + グローバル変数
  + テーブル
  + importテーブル
  + exportテーブル

===

# 命令の話
----------

* コントロールフロー
* Call
* パラメトリック
* 変数アクセス
* メモリ関連
* 定数
* 比較
* 数値
* 変換
* 再解釈

===

# コントロールフロー
-------------------

* `loop` + `br` (名前付き)
* `block` + `br` (名前付き)
* `br_if` or `br_table`
* `if` + `else` + `end`
* `return`
* 等

===

# コントロールフロー
-------------------

* gotoがない
  + `br` はブランチじゃなくてブレイク
* gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
    + loop, block, br, br_ifを使う
* 高級言語から変換するなら `if` を使う
  + ifが2系統あることになる

===

# Call
------

* `call`
* `call_indirect`
  + 関数テーブルを使った呼び出し
  + ダイナミックな関数ディスパッチに

===

# パラメトリック
------

* `drop`
* `select`
  + 三項演算子相当


===

# 変数アクセス
--------------

* `get/set_local`
* `get/set_global`
* `tee_local`
  + スタックに値を残しつつset

===

# メモリ関連
------------

* `{i,f}{32,64}.load{,8,16,32,64}{,_s,_u}`
* `{i,f}{32,64}.store{,8,16,32}`
* `current_memory`
* `grow_memory`
  + メモリを増やす命令もある

===
# 定数
------

* `{i,f}{32,64}.const`

===
# 比較
-------

* 各種 `eq`, `eqz`, `ne`,`lt`, `le`, `gt`, `ge`

===

# 数値
-------

* 四則(`i32.add`とか)
* 論理(`i64.popcnt`とか)
* 丸め,最{大,小}(`f32.ceil`とか)
* ルート(`f64.sqrt`とか)

===

# 変換
------

* `f32.convert_s/i32`とか
* `i32.wrap/i64`とか

===

# 再解釈
--------

* `i32.reinterpret/f32`とか
* ビットキャスト
* ビットエンコーディングが定まってるのでwell-defined

===
# WASM吐こうとした話

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 作ったやつ
-------------

* なんかコンパイラ作ろうと思い立った
* [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml)
* とりあえずSMLのサブセット
* Rust製
* 未完成
  + 正月気抜いてたら進捗ダメでした

===
# やりたかったこと
------------------

* ブラウザで動くコンパイラ作ってみたい
  + Rustはemscripten通せる
* WebAssembly面白そう
* SML処理系作りたかった
* 最適化書く練習

===
# 中身
------------

* パーサ、AST, HIR, MIR, LIR
* LIRがレジスタマシンなのでそれをWASMに変換したい
* オンメモリで生成するためにアセンブラ自作
  + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs)
  + ブラウザで動かすのに必要
* 最適化はまだ

===
# コード生成
-----------

* (ほぼ)SSAの1変数 = 1ローカル変数
  + どうせエンジン側でレジスタ割り当てするでしょ
* スタックはほぼ使わない
* gotoを構造化制御フローにする
  +  一応出来る
  + [Reloop](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
  + 何言ってるのかよく分からない
  + ステートマシンは勿論可能
* →自分で考えた
* なんかつらいので詳解します
* みんな基本ブロックとCFGは分かるかな？

===
# blockと前方ジャンプ
------------

* `block` + `break` で前方ジャンプ
* 閉じ括弧の位置にジャンプ
* `block` の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  ...
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

# loopと前方ジャンプ
------------


* `loop` + `break`で後方ジャンプ
  + `loop` からの `break` はいわゆる `continue`
* 開き括弧の位置にジャンプ
* 閉じ括弧の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  ...
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===
# ジャンプのクロス
------------------

* 単一gotoは割り当て出来る
* 複数のgotoが入り組んだら？

===
# 前前
------

```
   [ ]--+
    |   |
+--[ ]  |
|   |   |
|  [ ]&lt;-+
|   |
+-&gt;[ ]
```

===
# 前前
------

```
(block
  (block
    ...
    (br 0)-+
    ...    |
    (br 1)-+-+
  )&lt;-------+ |
)&lt;-----------+
```

===
# 後後
------


```
   [ ]&lt;-+
    |   |
+-&gt;[ ]  |
|   |   |
|  [ ]--+
|   |
+--[ ]
```

===
# 後後
------

```
(loop&lt;-----+
  (loop&lt;---+-+
    ...    | |
    (br 1)-+ |
    ...      |
    (br 0)---+
  )
)
```

===
# 後前
------


```
   [ ]&lt;-+
    |   |
+--[ ]  |
|   |   |
|  [ ]--+
|   |
+-&gt;[ ]
```

===
# 後前
------

```
(block
  (loop&lt;---+
    ...    |
    (br 1)-+-+
    ...    | |
    (br 0)-+ |
  )          |
)&lt;-----------+
```

===
# 前後
------

```
   [ ]--+
    |   |
+-&gt;[ ]  |
|   |   |
|  [ ]&lt;-+
|   |
+--[ ]
```

===
# 前後
------

* 出来ない…？
* 部分的にステートマーシン作る？
* ブロック組み換えたら出来る…？
* emscriptenはステートマシンっぽい？
* どうすればいいか不明
* もはやCPS変換して全部Callにする？
  + Compiling With Continuations!!!

===
# ランタイム
------------

* スタック走査出来ない
* GC書けないのでは？？？
* 今のところターゲットはC/C++なので問題ない
* 将来はGC Integration入るかも

===
# 現状の解
----------

1. メモリの自動管理を諦める
2. リージョン推論や線形型で静的管理する
3. スタックを使わないコードにする
  + Compiling With Continuations!!!

===
# まとめ
--------

* ブラウザでアセンブリっぽいコードが動くよ
* バイナリはコンパクトだよ
* コントロールフロー難しいよ
* ランタイム難しいよ
* Compiling With Continuations

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Sun, 22 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>

&lt;h2 id=&#34;me&#34;&gt;Me&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2011-04 - 2013-03 東京大学理科I類&lt;/li&gt;
&lt;li&gt;2013-04 - 2015-03 東京大学理学部数学科(中退)&lt;/li&gt;
&lt;li&gt;2015-04 - 2016-12 サイバーエージェント(エンジニア)&lt;/li&gt;
&lt;li&gt;2017-01 - 現在    Idein Inc. (エンジニア)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;activities&#34;&gt;Activities&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014-06 - 2017-01 &lt;a href=&#34;http://shibuya.lisp-users.org/&#34;&gt;Shibuya.lisp&lt;/a&gt;の運営&lt;/li&gt;
&lt;li&gt;2016-02 - 現在    &lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/&#34;&gt;Rustドキュメント翻訳プロジェクト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2013 &lt;a href=&#34;http://isucon.net&#34;&gt;ISUCON3&lt;/a&gt; 学生賞&lt;/li&gt;
&lt;li&gt;2014 &lt;a href=&#34;http://isucon.net&#34;&gt;ISUCON4&lt;/a&gt; 学生賞&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その他いくつかのOSSの開発者/コミッタ/コントリビュータ&lt;/p&gt;

&lt;h2 id=&#34;sns-accounts&#34;&gt;SNS accounts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Twitter: &lt;a href=&#34;http://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub: &lt;a href=&#34;https://github.com/KeenS&#34;&gt;KeenS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;COOKPAD: &lt;a href=&#34;http://cookpad.com/kitchen/3303629&#34;&gt;κeen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Qiita: &lt;a href=&#34;https://qiita.com/blackenedgold&#34;&gt;blackenedgold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SlideShare: &lt;a href=&#34;http://www.slideshare.net/blackenedgold&#34;&gt;blackenedgold&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;main-interests&#34;&gt;Main Interests&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Emacs&lt;/li&gt;
&lt;li&gt;Lisp&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;ML (Meta Language)&lt;/li&gt;
&lt;li&gt;言語処理系(主にインタプリタ)

&lt;ul&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;最適化&lt;/li&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;λ計算&lt;/li&gt;
&lt;li&gt;継続&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;li&gt;システムプログラミング&lt;/li&gt;
&lt;li&gt;数学基礎論&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rustのモジュールの使い方</title>
      <link>/blog/2017/01/15/rustnomoju_runokirikata</link>
      <pubDate>Sun, 15 Jan 2017 20:52:14 +0900</pubDate>
      
      <guid>/blog/2017/01/15/rustnomoju_runokirikata</guid>
      <description>&lt;p&gt;κeenです。たまにRustのモジュールが分かりづらいとの声を聞くので解説しますね。&lt;/p&gt;

&lt;p&gt;
とりあえずサンプルプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new module
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;エラいのは-lib-rs-と-main-rs&#34;&gt;エラいのは &lt;code&gt;lib.rs&lt;/code&gt; と &lt;code&gt;main.rs&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;モジュールの話をする前にクレートの話をしないといけません。
クレートはRustのプログラムの一番大きな単位です。
大きく分けてライブラリを作るlibクレートと実行可能ファイルを作るbinクレートがあります。&lt;/p&gt;

&lt;p&gt;libクレートならば&lt;code&gt;lib.rs&lt;/code&gt;が、binクレートならば&lt;code&gt;main.rs&lt;/code&gt;がルートにあたるファイルです。ここから辿れるモジュールが全てです。プロジェクトにファイルが存在していてもこれらから辿れなかったらコンパイルされません。&lt;/p&gt;

&lt;h1 id=&#34;モジュールの作り方は3種類&#34;&gt;モジュールの作り方は3種類&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;ファイルの中にインラインで作る&lt;/li&gt;
&lt;li&gt;1ファイルで作る&lt;/li&gt;
&lt;li&gt;1ディレクトリで作る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;のやり方があります。 1.はそんなに使われなくて、説明のために1ファイルにまとめたい時や、可視性でアレコレする時のテクニックなんかに使われます。&lt;/p&gt;

&lt;p&gt;2.と3.の境界はサブモジュールを持つかどうかです。&lt;/p&gt;

&lt;p&gt;2.のファイルで作る時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように作っておいて、lib.rsの中を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod new_module;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;mod&lt;/code&gt;で参照してあげれば使えます。&lt;/p&gt;

&lt;p&gt;3.のディレクトリの時もそんなに変わらなくて、&lt;code&gt;lib.rs&lt;/code&gt;は変わらず、ファイルを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module
src/new_module/mod.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにしてあげます。&lt;code&gt;mod.rs&lt;/code&gt;の名前はこれでないといけません。丁度サブモジュールの&lt;code&gt;new_module&lt;/code&gt;にとっての&lt;code&gt;lib.rs&lt;/code&gt;のような存在が&lt;code&gt;mod.rs&lt;/code&gt;な訳です。&lt;/p&gt;

&lt;h1 id=&#34;兄弟モジュール同士の可視性&#34;&gt;兄弟モジュール同士の可視性&lt;/h1&gt;

&lt;h2 id=&#34;モジュールの身分&#34;&gt;モジュールの身分&lt;/h2&gt;

&lt;p&gt;さて、次のように2つのモジュールを作ってみましょう。lib.rsには&lt;code&gt;module_a&lt;/code&gt;のみ&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;module_a.rs&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build
   Compiling module v0.1.0 (file:///home/kim/Rust/module)
error[E0432]: unresolved import `module_a`
 --&amp;gt; src/lib.rs:1:5
  |
1 | use module_a;
  |     ^^^^^^^^ no `module_a` in the root

error: aborting due to previous error

error: Could not compile `module`.

To learn more, run the command again with --verbose.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と怒られます。一番エラいのは&lt;code&gt;lib.rs&lt;/code&gt;ですから、身分の低い &lt;code&gt;module_a&lt;/code&gt;では&lt;code&gt;mod&lt;/code&gt;宣言出来ません。&lt;/p&gt;

&lt;h2 id=&#34;君の名は&#34;&gt;君の名は&lt;/h2&gt;

&lt;p&gt;同じ設定で、&lt;code&gt;lib.rs&lt;/code&gt;に&lt;code&gt;module_a&lt;/code&gt;と&lt;code&gt;module_b&lt;/code&gt;両方を&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時、&lt;code&gt;module_b&lt;/code&gt;が&lt;code&gt;lib.rs&lt;/code&gt;から見た時と&lt;code&gt;module_a.rs&lt;/code&gt;から見た時で名前が変わります。&lt;/p&gt;

&lt;p&gt;lib.rsから見た時は、以下の3つが使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use self::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self&lt;/code&gt;というのは予約語で、ディレクトリでいうところの&lt;code&gt;.&lt;/code&gt;に相当します。&lt;/p&gt;

&lt;p&gt;module_a.rsからは同じく3つが使えますが、相対パスが変わります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;super&lt;/code&gt;も予約語で、&lt;code&gt;..&lt;/code&gt;に相当します。
ファイルが同じディレクトリにいるので分かりづらいですが、libが1つ上の階層で、その下にmodule_aとmodule_bがぶら下がってる感じですね。&lt;/p&gt;

&lt;h1 id=&#34;おじさんと隠し子&#34;&gt;おじさんと隠し子&lt;/h1&gt;

&lt;p&gt;次のように、サブモジュールを作ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$src
src/lib.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この時&lt;code&gt;sumbmodule&lt;/code&gt;から見た&lt;code&gt;module_b&lt;/code&gt;の名前はどうなるでしょうか。もうお分かりかと思いますが、以下の3つです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃ、逆に&lt;code&gt;module_b&lt;/code&gt;から見た&lt;code&gt;submodule&lt;/code&gt;はどうなるでしょうか。実は、&lt;code&gt;module_b&lt;/code&gt;から&lt;code&gt;submodule&lt;/code&gt;は見えません（lib.rsからも見えません）。&lt;code&gt;module_a&lt;/code&gt;1つで所帯を持っているので子である&lt;code&gt;submodule&lt;/code&gt;を外に出すかは&lt;code&gt;module_a&lt;/code&gt;の一存で決まります。今回は隠し子にしている訳ですね。いくら兄弟モジュールとはいえ家庭にまでは入り込めないのです。&lt;/p&gt;

&lt;p&gt;子供をちゃんと公開するには&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていたモジュール宣言を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてあげればOKです。そうすると&lt;code&gt;module_b&lt;/code&gt;からも見えて、以下の3種類で参照出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a::submodule;
use module_a::submodule;
use super::module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;木箱の外から&#34;&gt;木箱の外から&lt;/h1&gt;

&lt;p&gt;さて、今までは1クレート内での話でした。クレートの外から見るとどうなるでしょうか。&lt;/p&gt;

&lt;p&gt;新たに&lt;code&gt;main.rs&lt;/code&gt;を追加しましょう。先程 &lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;がエラいと話しましたが、どちらも別々のクレートを作るので&lt;code&gt;main.rs&lt;/code&gt;は完全にクレートの外です。&lt;/p&gt;

&lt;p&gt;こんな感じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/main.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、外部のクレートを参照するには&lt;code&gt;extern crate&lt;/code&gt;を書く必要があります。あとまあ、binクレートなので&lt;code&gt;main&lt;/code&gt;関数も必要ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.rs
extern carte module;
fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、&lt;code&gt;module_b&lt;/code&gt;はどういう名前で見えるでしょうか。見えません。一番エラい&lt;code&gt;lib.rs&lt;/code&gt;が&lt;code&gt;module_b&lt;/code&gt;を&lt;code&gt;pub&lt;/code&gt;にしていないのでクレートの外からは見えなくなっています。見たければ、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにします。&lt;/p&gt;

&lt;p&gt;さて、これでmain.rsからどのように見えるかというと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module::module_b;
use module::module_b;
use self::module::module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように気持的にルート直下にクレートがモジュールとして配置されたように見えます。&lt;/p&gt;

&lt;h1 id=&#34;家出&#34;&gt;家出&lt;/h1&gt;

&lt;p&gt;さて、同じように&lt;code&gt;lib.rs&lt;/code&gt;で&lt;code&gt;module_a&lt;/code&gt;を&lt;code&gt;pub mod&lt;/code&gt;すれば&lt;code&gt;module::module_a::submodule&lt;/code&gt;も参照出来るようになります。ところで、例えば&lt;code&gt;module_a&lt;/code&gt;は外に出さずに&lt;code&gt;submodule&lt;/code&gt;だけを公開したい時にはどうしたらいいでしょうか。そんなケースあるのかと疑問に思うかもしれませんが、あります。同じクレートであっても&lt;code&gt;pub&lt;/code&gt;にしないとサブモジュールにアクセス出来ないことを思い出して下さい。そうすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub mod submodule;
pub mod internal_submodule_a;
pub mod internal_submodule_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなケースが発生するのは想像出来ると思います。そういう時は、&lt;code&gt;lib.rs&lt;/code&gt;側でどうにかいじれます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていると思いますが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、&lt;code&gt;pub use&lt;/code&gt; を加えてあげることで&lt;code&gt;module_a&lt;/code&gt;の下から出すことが出来ます。&lt;/p&gt;

&lt;p&gt;これを&lt;code&gt;main.rs&lt;/code&gt;から使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように名字の&lt;code&gt;module_a&lt;/code&gt;が取れます。&lt;/p&gt;

&lt;p&gt;さらに踏み込めば、&lt;code&gt;use&lt;/code&gt;は&lt;code&gt;as&lt;/code&gt;を使ってリネーム出来るので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule as module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにリネーム&lt;code&gt;use&lt;/code&gt;してあげれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように参照することも出来ます。完全に籍を外れて名前の上では別人ですね。&lt;/p&gt;

&lt;p&gt;実装する時の都合とAPIとして公開する時の都合が違うので公開用にいじれる作りになってるんですね。&lt;/p&gt;

&lt;h1 id=&#34;lib-rsとmain-rs&#34;&gt;lib.rsとmain.rs&lt;/h1&gt;

&lt;p&gt;上では&lt;code&gt;lib.rs&lt;/code&gt;を使って説明しましたが、&lt;code&gt;main.rs&lt;/code&gt;でも同じことが出来ます。&lt;/p&gt;

&lt;p&gt;さて、ここからはスタイルの話ですが、私がRustを書く時は&lt;code&gt;main.rs&lt;/code&gt;の中に&lt;code&gt;mod&lt;/code&gt;を書くことはないです。必ず&lt;code&gt;lib.rs&lt;/code&gt;を作って、そこでライブラリとしてまとめてから&lt;code&gt;main.rs&lt;/code&gt;で使います。「アプリケーションはアプリケーションを記述するための巨大なDSLとそれを使った小さな実装からなる」という思想ですね。明示的に境界を作ることで自然とAPIを設計出来るのでコードが整理しやすくなります。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;が一番エラい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mod&lt;/code&gt; で「モジュールがある」宣言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub mod&lt;/code&gt; で加えて上位のモジュールにも公開&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt;と&lt;code&gt;super&lt;/code&gt;の予約語&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub use&lt;/code&gt; で改名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;力尽きてテストのためのモジュールの話が出来なかったので&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/testing.html#tests-%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB&#34;&gt;ドキュメント&lt;/a&gt;を読んでみて下さい。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;https://github.com/BurntSushi/fst/blob/master/src/lib.rs&#34;&gt;これ&lt;/a&gt;のようにテクニックが詰まった&lt;code&gt;lib.rs&lt;/code&gt;ファイルなんかも存在するので参考にどうぞ。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>頑張らないLinuxデスクトップ環境</title>
      <link>/blog/2017/01/10/linuxdesukutoppukankyou</link>
      <pubDate>Tue, 10 Jan 2017 22:07:31 +0900</pubDate>
      
      <guid>/blog/2017/01/10/linuxdesukutoppukankyou</guid>
      <description>&lt;p&gt;κeenです。みんなカスタマイズしてLinux使っているようなのであまりカスタマイズしてない私のものも紹介しますね。&lt;/p&gt;

&lt;p&gt;因みに私は会社でMac使ってたら使いにくすぎてVMに逃げたくらいのLinuxユーザです。家では勿論Linuxしか使ってないです。
&lt;/p&gt;

&lt;h1 id=&#34;ディストリ&#34;&gt;ディストリ&lt;/h1&gt;

&lt;p&gt;Ubuntu。定番。色々言う人がいるけど何も不満はない。&lt;/p&gt;

&lt;h1 id=&#34;ウィンドウマネージャ-統合デスクトップ環境&#34;&gt;ウィンドウマネージャ（統合デスクトップ環境）&lt;/h1&gt;

&lt;p&gt;Unity。デフォルト。&lt;/p&gt;

&lt;h1 id=&#34;im&#34;&gt;IM&lt;/h1&gt;

&lt;p&gt;uim-skk。何故uim-かというと最初にたまたまそれを使ったから。&lt;/p&gt;

&lt;h1 id=&#34;ブラウザ&#34;&gt;ブラウザ&lt;/h1&gt;

&lt;p&gt;FireFox。確かデフォルト。入れてる拡張はkeysnailのみ。&lt;/p&gt;

&lt;h1 id=&#34;twitterクライアント&#34;&gt;Twitterクライアント&lt;/h1&gt;

&lt;p&gt;公式Web。新機能の追加が一番早くて便利。&lt;/p&gt;

&lt;h1 id=&#34;ターミナルエミュレータ&#34;&gt;ターミナルエミュレータ&lt;/h1&gt;

&lt;p&gt;gnome-terminal。デフォルト。速いし簡単に背景半透明に出来るし何も不満はない。tmuxと一緒に使ってる。&lt;/p&gt;

&lt;h1 id=&#34;エディタ&#34;&gt;エディタ&lt;/h1&gt;

&lt;p&gt;Emacs。デフォルトではない。毎日masterをコンパイルして使う。&lt;/p&gt;

&lt;h1 id=&#34;キーバインド変更&#34;&gt;キーバインド変更&lt;/h1&gt;

&lt;p&gt;xmodmap + &lt;a href=&#34;https://github.com/k0kubun/xremap&#34;&gt;xremap&lt;/a&gt;。これ CF &lt;a href=&#34;http://k0kubun.hatenablog.com/entry/xkremap&#34;&gt;Linux向けの最強のキーリマッパーを作った - k0kubun&amp;rsquo;s blog&lt;/a&gt;。
CapsLockとctrlのスワップにxmodmapを、Emacs風バインドを作るためにxremapを使ってる。xremapは別になくてもどうにかなる。&lt;/p&gt;

&lt;h1 id=&#34;メーラ&#34;&gt;メーラ&lt;/h1&gt;

&lt;p&gt;Thunderbird。確かデフォルト。でもUbuntuのパッケージは更新が遅いので手でインストールしてる。&lt;/p&gt;

&lt;h1 id=&#34;カレンダー&#34;&gt;カレンダー&lt;/h1&gt;

&lt;p&gt;Thunderbird + Lightening拡張。Googlカレンダーと同期出来るし便利。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;このくらいかな？フォントもデフォルト。あとはSlackに公式クライアントだとか偶に音楽再生にrythmbox（デフォルト）だとか画像表示にeog（デフォルト）だとかPDF表示にevice（デフォルト）だとかファイラにnautilus（デフォルト）スクリーンショットにgnome-screenshot（デフォルト）だとかを使うけどこの辺は当たり前なので書かなくていいかな。&lt;/p&gt;

&lt;p&gt;ということでそんなにカスタマイズしなくてもLinuxは便利なのでみなさん使いましょう。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Idein Incに入社しました</title>
      <link>/blog/2017/01/06/idein_incninyuushashimashita</link>
      <pubDate>Fri, 06 Jan 2017 20:53:12 +0900</pubDate>
      
      <guid>/blog/2017/01/06/idein_incninyuushashimashita</guid>
      <description>&lt;p&gt;κeenです。本日を以ちまして&lt;a href=&#34;http://idein.jp/&#34;&gt;Idein Inc.&lt;/a&gt;に入社したので報告します。&lt;/p&gt;

&lt;p&gt;退職エントリは&lt;a href=&#34;http://keens.github.io/blog/2016/11/30/saiba_e_jientowotaishokushimashita/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;経緯&#34;&gt;経緯&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Lisp Meet Upで社長の&lt;a href=&#34;https://twitter.com/9_ties&#34;&gt;@9_ties&lt;/a&gt;さんと知り合う&lt;/li&gt;
&lt;li&gt;その他勉強会で何度か一緒になってよく喋るようになる&lt;/li&gt;
&lt;li&gt;オフィス訪問に誘われて行ったら入社を誘われる（7月末）&lt;/li&gt;
&lt;li&gt;入社することにする（9月半ば）&lt;/li&gt;
&lt;li&gt;入社（現在）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;わさびずとideinに遊びに来たよ。噂のpi zero&lt;br&gt;クラスタとかPEZYとかあった。熱い。 &lt;a href=&#34;https://t.co/MEc7qdosrk&#34;&gt;pic.twitter.com/MEc7qdosrk&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/759655196628615168&#34;&gt;2016年7月31日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;結構前から水面下で話は進んでました。&lt;/p&gt;

&lt;p&gt;割と「PEZYに行くの？」という質問が多かったのですが中らずとも遠からずといったところでしょうか。PEZY Computingとも取引があったりする会社です。&lt;/p&gt;

&lt;h1 id=&#34;どんな会社&#34;&gt;どんな会社？&lt;/h1&gt;

&lt;p&gt;私が7人目（バイトを抜いたら6人目）の社員になる、少数精鋭なスタートアップです。全社員に1つのチャットで連絡が取れます。
この規模ながらフルタイムのリサーチャがいるなど、かなり技術寄りな会社です。創業者も全員技術者です。社員の中ではクソザコクラスになるので明日から人権があるか心配ですがどうにか上手くやっていきます。&lt;/p&gt;

&lt;p&gt;今3期目とのことです。&lt;/p&gt;

&lt;p&gt;社長に「なんて紹介したらいいですか」って言ったら「うーん、困るなぁ」と言われました（苦笑。
Big Pictureとしてはコンピュテーショナルセンサーを使って世の中に起きているあらゆる事象をソフトウェアで扱えるようにしたい、というもの。ざっくり言ってしまえばIoTの会社になるんですかね。
でもじゃあ電子工作ばっかやってるのかというとそういう訳でもなくて、例えばカメラから得られた画像から色々な情報を抜き出すために機械学習やらディープラーニングやらをやっていたり、さらにそれをセンサーデバイス（Rasp Piとか）上で走らせるために効率化したりとソフトウェア技術のウェイトがかなり大きいです。&lt;/p&gt;

&lt;p&gt;例えばニューラルネットワークの学習済みデータを最適化（軽量化）してさらにコンパイル（！！）して組込みデバイス上でも満足な速度で動かすための技術開発なんかをやっています。&lt;/p&gt;

&lt;p&gt;あるいはセンサーから取得したデータを使えるプラットフォームなんかも。&lt;/p&gt;

&lt;h1 id=&#34;どんな仕事するの&#34;&gt;どんな仕事するの？&lt;/h1&gt;

&lt;p&gt;私の仕事もそういう文脈からきていて、例えばニューラルネットをコンパイルしてRasp PiのGPUで動かすだとか、あるいはもうちょっと特化したデバイス（ぼかしてる）のためのコンパイラを作るだとかの仕事になります。
自分で書いておきながらやっぱり「ニューラルネットをコンパイルする」っていう字面がパワーある。
今、（学習ではなくて予測に）使われているのはほとんどがモデルと実行器が分けらています。要はインタプリタなのでそれをコンパイルしてあげて高速に実行するというのが可能なんですね。
ニューラルネットの圧縮のために数学が必要そうな雰囲気で、数学出来ない私は震え上がってます。&lt;/p&gt;

&lt;p&gt;会社全体としてはデバイスの開発も一応やりつつ、データを処理するための技術開発、共同研究、技術開発も含めた受託案件、あるいは開発した技術を使った受託案件なんかもやっています。
かなり技術開発への投資が強いイメージですが、今期は黒字予定と案外バランスの取れた運営をしているようです（結構色々な会社が興味を持ってくれているようです。
センサーだとかの文脈になるのでお客さんはハードウェアの会社が多いようです。&lt;/p&gt;

&lt;h1 id=&#34;初日の感想は&#34;&gt;初日の感想は？&lt;/h1&gt;

&lt;p&gt;会社が移転した（前のオフィスだと私のスペースがなかった）のでほとんど環境構築でした。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;環境構築してる &lt;a href=&#34;https://t.co/6HLHbnOmi6&#34;&gt;pic.twitter.com/6HLHbnOmi6&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/817252587703414789&#34;&gt;2017年1月6日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;オフィス引っ越し中 &lt;a href=&#34;https://t.co/MnrNUxxUP7&#34;&gt;pic.twitter.com/MnrNUxxUP7&lt;/a&gt;&lt;/p&gt;&amp;mdash; y͛amaday͛ (@yamaday) &lt;a href=&#34;https://twitter.com/yamaday/status/817203674036305921&#34;&gt;2017年1月6日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;落ち着いたあとはQiita::Teamを全部読んでました。社長も技術者なので事業プランや資金計画（売り上げ）なんかもQiita::Teamに上がってるのが新鮮でした。&lt;/p&gt;

&lt;p&gt;社員に2名ほどRustをやってる人がいて「κeen君来たし仕事でRust使っていくかー」みたいな感じになりました。使えそうな案件があったら積極的に使っていきたいですね。&lt;/p&gt;

&lt;h1 id=&#34;結びに&#34;&gt;結びに&lt;/h1&gt;

&lt;p&gt;前回転職祝いを沢山頂いたので今回は例のURLは控えさせて頂きます。
前回送りそびれたのでどうしてもという方は&lt;a href=&#34;http://keens.github.io/blog/2016/11/30/saiba_e_jientowotaishokushimashita/&#34;&gt;退職エントリ&lt;/a&gt;の方から辿って頂けると幸いです。&lt;/p&gt;

&lt;p&gt;また、Ideinではエンジニアを募集しています&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;募集職種&#34;&gt;募集職種&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ソフトウェアエンジニア（画像処理）
画像処理に関する基本的な知識を持っている方（画像処理の実装経験がある方歓迎）&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（バックエンド）
分散システムの構築やDevOpsに興味があり、最新の技術の動向を追っている方。場合によっては自ら実装が出来る方&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（フロントエンド）
最新の技術動向に明るく、移り変わりの激しい技術のコンテキストを理解して吸収でき、UXを考慮した実装が出来る方&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（組み込み）
計算機を低いレイヤーまで理解し、ハードウェアの仕様を読み解いて必要機能の実装が出来る方&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（言語処理系）
計算機アーキテクチャや数値計算アルゴリズムに精通しており、最適化コンパイラやプログラミング環境をフルスクラッチで実装出来る方&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下のスキルセットを持っている方を歓迎します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++, Python, Haskell,Rust, etc&amp;hellip;&lt;/li&gt;
&lt;li&gt;Git（分散VCS）&lt;/li&gt;
&lt;li&gt;DevOps関連技術(Docker,Ansible,etc&amp;hellip;)&lt;/li&gt;
&lt;li&gt;GPU&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;すべての職種に一貫して、現在のスキルセットよりは以下に挙げるような事柄への知識や興味を優先します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;アルゴリズムとデータ構造&lt;/li&gt;
&lt;li&gt;計算機&lt;/li&gt;
&lt;li&gt;プログラミング言語&lt;/li&gt;
&lt;li&gt;ソフトウェア工学&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;待遇-給与&#34;&gt;待遇・給与&lt;/h1&gt;

&lt;p&gt;社保完備 月収60万円〜（正社員）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因みに私はポテンシャル採用されたタイプで「壁に当たっても自分で調べて乗り越えていけそう」だとか「コンパイラを書いてると心が折れそうになる瞬間があるけどそこで折れないような人が大事だ」とか言われました。頑張ります。&lt;/p&gt;

&lt;p&gt;ということで皆様の応募お待ちしております！！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>QUICの中身が分からないから仕様読んでみた</title>
      <link>/blog/2017/01/02/quicnonakamigawakaranaikarashiyouyondemita</link>
      <pubDate>Mon, 02 Jan 2017 10:46:39 +0900</pubDate>
      
      <guid>/blog/2017/01/02/quicnonakamigawakaranaikarashiyouyondemita</guid>
      <description>&lt;p&gt;κeenです。先日同期と話しててQUICの中身ってあまり知らないよねってことでQUICの仕様（ドラフト）を読んだのでまとめますね。あまりまとめきれてませんが。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;strong&gt;※ドラフトは既に古くなっているのでこのブログの内容は現行では正しくない可能性があります。というか一部既に正しくないことが判明しています。ご注意下さい&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;後で新しいドラフトを発見したので内容を書き換えました。とりあえずリンクを貼ってあるドラフトの内容までは反映出来ています。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;仕様を読む前にQUICの背景から。
HTTP/2でHTTPにストリームという概念が入りました。
1つのコンテンツ毎に順にやりとりするのではなく、複数のコンテンツを並行して通信する仕組みです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 今まで
[]--CCCBBBAAA--&amp;gt;[]

# HTTP/2
[]--ACCBCABBA--&amp;gt;[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の図でいえば例えばAのコンテンツがサーバの都合で遅くてもBやCのコンテンツが支える（Head of Line Blocking）ことなくクライアントに届きます。&lt;/p&gt;

&lt;p&gt;ところで、この通信はTCP上で行われています。TCPは到達順序を保障するので例えば1パケット欠損したらそれ以後のパケットは（実際にはクライアントに到着しているにも関らず）待たされます(TCP Head of Line Blocking)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[]--ACCBCABB-X--&amp;gt;[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この図でいえばAのパケットが欠損してますが、HTTP/2的にはAは無視してBやCのコンテンツをユーザに届けることは可能な訳です。
この辺を改善したいというのがQUICのモチベーション。&lt;/p&gt;

&lt;p&gt;もうちょっと言うとTCPの3way hand shakeだとかその上のTLS hand shakeだとかのオーバーヘッドの削減の目的もあります。
TCPやTLSもRTTを減らそうと努力はしていますが、もっと抜本的な解決が必要とのことです。&lt;/p&gt;

&lt;p&gt;ということでHTTP/2に特化してTCP+TLSを置き換えるための通信プロトコルとしてUDPベースのQUICが産まれました。&lt;/p&gt;

&lt;p&gt;ここまではよくあるQUICの説明。でも、これだけだと情報が少なくてもやもやしますよね。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP/2に特化とはいうけどどこまで特化してるの？他のアプリケーションで使えないの？&lt;/li&gt;
&lt;li&gt;どうしてTLSも統合してしまったの？分離出来なかったの？&lt;/li&gt;
&lt;li&gt;UDPベースでどうやってコネクションの維持や輻輳制御してるの？&lt;/li&gt;
&lt;li&gt;上記以外でQUICに特徴はないの？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などなど。これらの疑問を解決すべくQUICのドラフトを読んでいきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;quic&#34;&gt;QUIC&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/draft-tsvwg-quic-protocol-02&#34;&gt;これ&lt;/a&gt;を読んでいきます。Expires July 16, 2016とのこと。&lt;/p&gt;

&lt;h2 id=&#34;イントロ&#34;&gt;イントロ&lt;/h2&gt;

&lt;p&gt;QUICはHTTP/2のストリーム分割やフローコントロール、TLSのセキュリティ、TCPのコネクションセマンティクスや信頼性、輻輳制御を提供します。&lt;/p&gt;

&lt;p&gt;QUICはUDPベースの通信プロトコルなので、完全にユーザーランドで完結します。
これは重要な話で、レガシーなネットーワーク中間機器の上でもちゃんと通信出来ることを意味します。
仕様化する前に実証実験をする上でとても重要な性質です。&lt;/p&gt;

&lt;h2 id=&#34;用語&#34;&gt;用語&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;クライアント: QUICコネクションを開始する端&lt;/li&gt;
&lt;li&gt;サーバ: QUICコネクションを受け付ける端&lt;/li&gt;
&lt;li&gt;エンドポイント: サーバ、またはクライアント&lt;/li&gt;
&lt;li&gt;ストリーム: QUICコネクションの論理チャネル内を双方向に流れるバイト列の流れ&lt;/li&gt;
&lt;li&gt;コネクション: 単一の暗号コンテキスト下のQUICエンドポイント同士のやりとり。複数のストリームを持つ。&lt;/li&gt;
&lt;li&gt;コネクションID: QUICコネクションのID&lt;/li&gt;
&lt;li&gt;QUIC Packet: QUICでパース可能な有効なUDPペイロード。QUICのパケットサイズとはUDPのペイロードのサイズを指す。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;QUIC(+HTTP/2)のTCP+TLS(+HTTP/2)に対する利点は以下を改善することです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コネクション確立のレイテンシ&lt;/li&gt;
&lt;li&gt;柔軟な輻輳制御&lt;/li&gt;
&lt;li&gt;Head of Line Blockingなしに多重化&lt;/li&gt;
&lt;li&gt;ヘッダやペイロードが認証/暗号化されている&lt;/li&gt;
&lt;li&gt;ストリーム及びコネクションフローコントーロール&lt;/li&gt;
&lt;li&gt;前方エラー訂正&lt;/li&gt;
&lt;li&gt;コネクション移行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思ったより特徴ありますね。コネクション移行とか面白そう。
さて、それぞれ見ていきます。忙しい人は概要まででもそれなりに役立つでしょう。&lt;/p&gt;

&lt;h3 id=&#34;コネクション確立のレイテンシ&#34;&gt;コネクション確立のレイテンシ&lt;/h3&gt;

&lt;p&gt;通常TCP+TLSだと1-3RTT必要なのに対してQUICは多くの場合0 RTTでコネクション確立出来ます。つまり、いきなりデータを送れる。&lt;/p&gt;

&lt;p&gt;0 RTTで接続出来ない場合、つまりハンドシェイクが必要な場合もある訳ですが、ハンドシェイクの詳細はQUIC Cryptoの方に投げられています。
さらにQUIC CryptoはTLS 1.3に置き換えられる予定なのでほぼTLS 1.3のハンドシェイクだと思っておいて良いようです。&lt;/p&gt;

&lt;h3 id=&#34;柔軟な輻輳制御&#34;&gt;柔軟な輻輳制御&lt;/h3&gt;

&lt;p&gt;QUICはプラガブルな輻輳制御を持っており、TCPより豊富なシグナルがあるのでTCPの輻輳制御アルゴリズムより賢く振る舞うことが出来ます。
とはいっても現状の（ドラフト時点の）GoogleではTCPのアルゴリズムを流用しており別のアプローチを実験中とのこと。&lt;/p&gt;

&lt;p&gt;詳細は&lt;a href=&#34;https://tools.ietf.org/html/draft-quic-loss-recovery&#34;&gt;ここ&lt;/a&gt;にあるとのことでしたが、リンク切れなのか真っ白なページしかありません。&lt;/p&gt;

&lt;p&gt;さて、シグナルが豊富とのことでしたが、1例を出すとパケットの元のものと再送されたものでシーケンス番号が異ります(私はTCPの詳細を知らないのでよく分かりませんが輻輳制御のためにシーケンス番号を振っているのでしょう)。
元と再送のものを区別出来るようになるのでTCPの曖昧性問題（というのがあるのでしょう）を解決出来るとのこと。&lt;/p&gt;

&lt;p&gt;また、パケットを受け取ってからackを送るまでの時差と単調増加するシーケンス番号も一緒に送るのでRTTを計算することが出来ます。&lt;/p&gt;

&lt;p&gt;最後に、ACKが256 NACKまでサポートする（らしい）のでTCPのSACKよりもリオーダリングに弾力性があり、パケロスやリオーダリングがある環境下でもパケット密度を高めることが出来るとのこと。これは後程記述があります。&lt;/p&gt;

&lt;p&gt;この辺はTCPの輻輳制御から勉強しないと利点が分からないですね。宿題。&lt;/p&gt;

&lt;h3 id=&#34;ストリーム及びコネクションフローコントーロール&#34;&gt;ストリーム及びコネクションフローコントーロール&lt;/h3&gt;

&lt;p&gt;順番が前後しますがストリームの話。そういえばHTTP/2にバックプレッシャーありましたね。&lt;/p&gt;

&lt;p&gt;ストリームレベル、コネクションレベルでのフロー制御が出来ます。
ほぼHTTP/2と同等のストリーム制御が可能です。&lt;/p&gt;

&lt;p&gt;ストリームレベルの制御は、まず、受け取り側がストリーム内のデータのどのオフセットまでを受け取るかを広報します。
ストリームにデータが届いたら、WINDOW_UPDATEのフレームを投げて、受け取り可能なオフセットを更新します。&lt;/p&gt;

&lt;p&gt;コネクションレベルの制御は、ストリーム合計でのバッファを制限するために使います。
単純にストリームでやっている制御をコネクションレベルでやるだけです。&lt;/p&gt;

&lt;p&gt;また、TCPにあるようにreceive-windowのオートチューニングもやるそうです。&lt;/p&gt;

&lt;p&gt;この辺、HTTP/2に合わせた仕様なんですね。&lt;/p&gt;

&lt;h3 id=&#34;多重化&#34;&gt;多重化&lt;/h3&gt;

&lt;p&gt;TCP head of line blockingしない。因みにHTTP/2のヘッダはHPACKで圧縮して送るのでここはhead of line blockingします。&lt;/p&gt;

&lt;h3 id=&#34;ヘッダやペイロードが認証-暗号化されている&#34;&gt;ヘッダやペイロードが認証/暗号化されている&lt;/h3&gt;

&lt;p&gt;そもそもの話、TCPは平文で通信するのでreceive-windowの更新やらシーケンス番号を上書きしたりやらの攻撃が可能です（尤も、通信の最適化のために中間機器で行うこともありますが）。&lt;/p&gt;

&lt;p&gt;QUICは一部のヘッダを除き暗号化されています。暗号化されていない部分も受理側によって認証されるのでインジェクションを阻止出来ます。&lt;/p&gt;

&lt;p&gt;ここでTLSも統合している理由が分かりました。認証のためにTLSが必要なんですね。&lt;/p&gt;

&lt;h3 id=&#34;前方エラー訂正&#34;&gt;前方エラー訂正&lt;/h3&gt;

&lt;p&gt;Forward Error Correction (FEC)。シンプルなXORベースのFECをやるそうです。FECグループ内の1パケットがロスしてもFECパケットから復元出来るとのこと。すごい。&lt;/p&gt;

&lt;h3 id=&#34;コネクション移行&#34;&gt;コネクション移行&lt;/h3&gt;

&lt;p&gt;TCPは4-tuple(source address, port, destinacion address, port)でコネクションを判別しますが、それだと例えばスマホが電話通信（って呼称でいいのかな？）からWifiに切り替わった時にIPが変わりますし、NAT下でポート番号が変わることもあるので突発的にコネクションが切れてしまう訳です。&lt;/p&gt;

&lt;p&gt;QUICはクライアントがランダム生成した64bitのコネクションIDで識別します。
じゃあ、コネクションIDを被せにいったらハイジャック出来るじゃんと思えますが、TLSを前提にしているのでクライアント認証も自動でついていて、その辺には耐性があります。&lt;/p&gt;

&lt;h2 id=&#34;パケットタイプとフォーマット&#34;&gt;パケットタイプとフォーマット&lt;/h2&gt;

&lt;p&gt;2種類の特殊パケットと2種類の通常パケットがあります。バージョンネゴシエーションパケットとパブリックリセットパケット、フレームパケットとFECパケットです。&lt;/p&gt;

&lt;p&gt;パケットはIPの断片化を防ぐためにパスのMTU（Message Transfer Unit）に収まる必要がありますが、MTUの発見はまだWIPだそうです。
今とのころIPv6で1350byte、IPv4で1370byteを使っているとのこと。&lt;/p&gt;

&lt;h3 id=&#34;バブリックヘッダ&#34;&gt;バブリックヘッダ&lt;/h3&gt;

&lt;p&gt;全てのQUICパケットにつくヘッダです。パブリックの名の通り暗号化されません。&lt;/p&gt;

&lt;p&gt;長さは2-19byteの間になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      0        1        2        3        4            8
+--------+--------+--------+--------+--------+---    ---+
| Public |    Connection ID (0, 8, 32, or 64)    ...    | -&amp;gt;
|Flags(8)|      (variable length)                       |
+--------+--------+--------+--------+--------+---    ---+

     9       10       11        12
+--------+--------+--------+--------+
|      QUIC Version (32)            | -&amp;gt;
|         (optional)                |
+--------+--------+--------+--------+

    13      14       15        16        17       18
+--------+--------+--------+--------+--------+--------+
|         Packet Number (8, 16, 32, or 48)            |
|                         (variable length)           |
+--------+--------+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;軽く説明しますね。それぞれの詳しい内容は仕様を読んで下さい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;public flagsにパケットタイプなどが入っています。&lt;/li&gt;
&lt;li&gt;コネクションIDが64bitだと過剰な場合はネゴって短かくすることも可能です。&lt;/li&gt;
&lt;li&gt;パケット番号はフレームパケットに付与されます。1から始まり1づつ大きくなります。&lt;/li&gt;
&lt;li&gt;パケット番号の下位64bitはTLSのnonceの一部に使われます。合理的ですね。&lt;/li&gt;
&lt;li&gt;内部的には64bitでシーケンス番号を管理するけどパケットに載せるのは48bitまで。&lt;/li&gt;
&lt;li&gt;48bit(n bit)でオーバーフローした時の曖昧性排除のために2^46個(2^(n-2)個)までしか同時にパケットを送れない&lt;/li&gt;
&lt;li&gt;シーケンス番号が2^64-1に逹したらシーケンス番号のリミットでコネクションクローズが走る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;パケットタイプを判別するフローチャートが載っていたので引用しますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Check the public flags in public header
                 |
                 |
                 V
           +--------------+
           | Public Reset |    YES
           | flag set?    |---------------&amp;gt; Public Reset Packet
           +--------------+
                 |
                 | NO
                 V
           +------------+          +-------------+
           | Version    |   YES    | Packet sent |  YES
           | flag set?  |---------&amp;gt;| by server?  |--------&amp;gt; Version Negotiation
           +------------+          +-------------+               Packet
                 |                        |
                 | NO                     | NO
                 V                        V
           Regular Packet         Regular Packet with
                              QUIC Version present in header
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;スペシャルパケット&#34;&gt;スペシャルパケット&lt;/h3&gt;

&lt;h4 id=&#34;バージョンネゴシエーションパケット&#34;&gt;バージョンネゴシエーションパケット&lt;/h4&gt;

&lt;p&gt;サーバからのみ送られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     0        1        2        3        4        5        6        7       8
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
| Public |    Connection ID (64)                                                 | -&amp;gt;
|Flags(8)|                                                                       |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+

     9       10       11        12       13      14       15       16       17
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
|      1st QUIC version supported   |     2nd QUIC version supported    |   ...
|      by server (32)               |     by server (32)                |
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特に順序に言及がないのでクライアントは良い感じに新しいやつ選ぶんですかね。&lt;/p&gt;

&lt;h4 id=&#34;パブリックリセットパケット&#34;&gt;パブリックリセットパケット&lt;/h4&gt;

&lt;p&gt;コネクションをクローズしようとしているのが本当に正しいクライアントなのか証明するための情報が載せられます。詳細は仕様を読んで下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     0        1        2        3        4         8
+--------+--------+--------+--------+--------+--   --+
| Public |    Connection ID (64)                ...  | -&amp;gt;
|Flags(8)|                                           |
+--------+--------+--------+--------+--------+--   --+

     9       10       11        12       13      14
+--------+--------+--------+--------+--------+--------+---
|      Quic Tag (32)                |  Tag value map      ... -&amp;gt;
|         (PRST)                    |  (variable length)
+--------+--------+--------+--------+--------+--------+---
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通常パケット&#34;&gt;通常パケット&lt;/h3&gt;

&lt;p&gt;通常パケットのペイロードは暗号化/認証されます。パブリックヘッダは暗号化されませんが認証されます。
通常パケットはPrivate Flagsから始まるプライベートヘッダを持ちます（そこからが暗号化されます）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     0        1
+--------+--------+
|Private | FEC (8)|
|Flags(8)|  (opt) |
+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このあとにAEAD (authenticated encryption and associated data)、つまり認証/暗号化されたペイロードが続きます。&lt;/p&gt;

&lt;h4 id=&#34;フレームパケット&#34;&gt;フレームパケット&lt;/h4&gt;

&lt;p&gt;プライベートヘッダに続いてこんな感じのデータが続きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+---...---+--------+---...---+
| Type   | Payload | Type   | Payload |
+--------+---...---+--------+---...---+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fecパケット&#34;&gt;FECパケット&lt;/h3&gt;

&lt;p&gt;プライベートヘッダに続いてこんな感じのデータが続きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-----...----+
| Redundancy |
+-----...----+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quicコネクションのライフサイクル&#34;&gt;QUICコネクションのライフサイクル&lt;/h2&gt;

&lt;h3 id=&#34;コネクションの確立&#34;&gt;コネクションの確立&lt;/h3&gt;

&lt;p&gt;クライアントがバージョン付きでデータを送って、サーバが処理出来るならそのままレスポンスを返してコネクション成立です。
もし処理出来ないなら、バージョンネゴシエーションパケットを送り返して、クライアントはそこから1つバージョンを選んで再送します。サーバから通常レスポンスが返ってきたらコネクション成立です（成立するまで繰り返します）。&lt;/p&gt;

&lt;p&gt;ダウングレード攻撃を避けるためにハンドシェイクにバージョン情報を載せたり頑張るようですが、細かいので仕様を読んで下さい。&lt;/p&gt;

&lt;h3 id=&#34;データ転送&#34;&gt;データ転送&lt;/h3&gt;

&lt;p&gt;多くは概要で説明した通り。
暗号化ハンドシェイクも含めてストリーム内でデータをやりとりしますが、ACKはQUICパケット単位です。&lt;/p&gt;

&lt;p&gt;シーケンス番号は輻輳制御を統合するためにコネクションを通して同じ番号空間を共有します。&lt;/p&gt;

&lt;p&gt;詳しくは付設のドキュメントを読めと書いてますが、リンク先が真っ白です。&lt;/p&gt;

&lt;h4 id=&#34;ストリームのライフサイクル&#34;&gt;ストリームのライフサイクル&lt;/h4&gt;

&lt;p&gt;ストリームはデータをストリームフレームに分割してデータ転送します。
ストリームフレームは互いに順序逆転可能です。
ストリームの生成/クローズはサーバ、クライアント両方から出来ます。
ほとんどHTTP/2のストリームと同じですね。&lt;/p&gt;

&lt;p&gt;ストリーム生成は特にネゴる必要なく簡単に可能です。ただ、ストリームIDが衝突しないようにサーバが作る時は偶数、クライアントが作る時は奇数を使います。
0は無効、1は暗号化ハンドシェイクのために予約、3はHTTPヘッダの通信のために予約とされています。ヘッダだけは順序保障が必要なんですね。
他の細かい規約は仕様を見て下さい。&lt;/p&gt;

&lt;p&gt;一旦ストリームが開いたらデータ転送に自由に使えます。&lt;/p&gt;

&lt;p&gt;ストリームの終了には3種類あります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;普通の終了: 双方向通信なのでFIN bitを立てて送信した後のhalf-closeとかの概念があります。&lt;/li&gt;
&lt;li&gt;突然の終了: 何かしらのエラーがあった時などにRST_STREAMフレームを送ると強制終了出来ます。&lt;/li&gt;
&lt;li&gt;コネクションが終了した時: まあ、当然ですね。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;コネクションの終了&#34;&gt;コネクションの終了&lt;/h3&gt;

&lt;p&gt;コネクションの終了にも2種類あります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;明示的な終了: CONNECTION_CLOSEを送ることでコネクションを終了出来ます。&lt;/li&gt;
&lt;li&gt;暗黙的な終了: タイムアウト（デフォルト30秒）したらクローズします。通常はCONNECTION_CLOSEを送りますが、モバイルで電波をonにしたくないなどの理由があればsilent closeも可能です。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;それ以外に、PUBLIC_RSTでコネクションをクローズ出来ます。TCPのRST相当（だそう）です。&lt;/p&gt;

&lt;h2 id=&#34;フレームタイプとフォーマット&#34;&gt;フレームタイプとフォーマット&lt;/h2&gt;

&lt;p&gt;前述の通りフレームパケットにはフレームが入っています。フレームタイプ毎にデータの解釈が変わります。
1フレームは必ず1パケットに収まる必要があります。&lt;/p&gt;

&lt;h3 id=&#34;フレームタイプ&#34;&gt;フレームタイプ&lt;/h3&gt;

&lt;p&gt;特殊フレームと通常フレームがあります。&lt;/p&gt;

&lt;p&gt;特殊フレームは以下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------------------+-----------------------------+
| Type-field value |     Control Frame-type      |
+------------------+-----------------------------+
|     1fdooossB    |  STREAM                     |
|     01ntllmmB    |  ACK                        |
|     001xxxxxB    |  CONGESTION_FEEDBACK        |
+------------------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常フレームは以下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------------------+-----------------------------+
| Type-field value |     Control Frame-type      |
+------------------+-----------------------------+
| 00000000B (0x00) |  PADDING                    |
| 00000001B (0x01) |  RST_STREAM                 |
| 00000010B (0x02) |  CONNECTION_CLOSE           |
| 00000011B (0x03) |  GOAWAY                     |
| 00000100B (0x04) |  WINDOW_UPDATE              |
| 00000101B (0x05) |  BLOCKED                    |
| 00000110B (0x06) |  STOP_WAITING               |
| 00000111B (0x07) |  PING                       |
+------------------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのタイプについて仕様に載っている順に軽く説明します。詳しくは仕様を読んで下さい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;STREAM: 暗黙的にstreamを作るのにもデータを送るのにも使います。&lt;/li&gt;
&lt;li&gt;ACK: ackです。受け取った最大シーケンス番号とそれまでで欠損している番号のリストを送ります。前述の通り受理からACKまでの時差を入れたりと複雑なので仕様を読んで下さい。&lt;/li&gt;
&lt;li&gt;STOP_WAITING: 特定以下のシーケンス番号のパケットを待たないように指示します。&lt;/li&gt;
&lt;li&gt;WINDOW_UPDATE: コネクション/ストリームいずれかのウィンドウ余白を通知します。Stream ID 0がコネクションレベルのアップデートです。&lt;/li&gt;
&lt;li&gt;BLOCKED: バックプレッシャーでこれ以上データを送信出来ない時に送ります。informational frameです(ほぼデバッグ用とのこと)。&lt;/li&gt;
&lt;li&gt;CONGESTION_FEEDBACK: experimentalで、not usedとのこと。&lt;/li&gt;
&lt;li&gt;PADDING: 0x00で埋められたデータを保持します。パケットをMTUまで埋めるのが目的なのかな？&lt;/li&gt;
&lt;li&gt;RST_STREAM: ストリームの異常終了用。&lt;/li&gt;
&lt;li&gt;PING: 生きてる？って訊くやつです。これを受けたらACKを返します。デフォルトで15秒毎に送ります。&lt;/li&gt;
&lt;li&gt;CONNECTION_CLOSE: closeを通知するやつです。&lt;/li&gt;
&lt;li&gt;GOAWAY: コネクションを止めるよ通知です。近くcloseするのでデータ送るのやめなよという通知です。新たなstreamが作れなくなります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;quicの通信上のパラメータ&#34;&gt;QUICの通信上のパラメータ&lt;/h2&gt;

&lt;p&gt;ハンドシェイクでネゴシエートすべきパラメータの列挙です。&lt;/p&gt;

&lt;h3 id=&#34;required&#34;&gt;Required&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SFCW - Stream Flow Control Window: ストリームレベルのコントロールフローウィンドウサイズ(バイト単位)です。&lt;/li&gt;
&lt;li&gt;SFCW - Connection Flow Control Window: コネクションレベルのコントロールフローウィンドウサイズ(バイト単位)です。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ほとんどルー語ですね。&lt;/p&gt;

&lt;h3 id=&#34;optional&#34;&gt;Optional&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SRBF - Socket receive buffer size in bytes: CWNDを受け取りバッファくらいに指定したい場合があるらしいのでそれ用。&lt;/li&gt;
&lt;li&gt;TCID - Connection ID truncation: クライアントのエフェメラルポートが単一コネクションにしか使われないと分かっている場合に便利らしいです。&lt;/li&gt;
&lt;li&gt;COPT - Connection Options are a repeated tag field: 実験的パラメータだそうです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;プライオリティ&#34;&gt;プライオリティ&lt;/h2&gt;

&lt;p&gt;HTTP/2のものを使うそうですが、まだ実装してないとのこと。&lt;/p&gt;

&lt;h2 id=&#34;quic上のhttp-2&#34;&gt;QUIC上のHTTP/2&lt;/h2&gt;

&lt;p&gt;いくつかHTTP/2と同じ機能を提供していますが、HTTP/2がQUICを使う時にどう統合するかのお話です。&lt;/p&gt;

&lt;h3 id=&#34;ストリームマネジメント&#34;&gt;ストリームマネジメント&lt;/h3&gt;

&lt;p&gt;QUICが代替機能を提供するのでHTTP/2レイヤで扱う必要はありません。HTTP/2のストリームIDはそのままQUICのストリームIDになります。&lt;/p&gt;

&lt;h3 id=&#34;ヘッダー圧縮&#34;&gt;ヘッダー圧縮&lt;/h3&gt;

&lt;p&gt;Stream ID 3で送ることになっている（QUICの仕様でHTTP/2のヘッダを扱うことになっている）。のでそれを使います。&lt;/p&gt;

&lt;h3 id=&#34;http-2ヘッダのパース&#34;&gt;HTTP/2ヘッダのパース&lt;/h3&gt;

&lt;p&gt;ヘッダのパースはHTTP/2の仕様に従います。&lt;/p&gt;

&lt;h3 id=&#34;永続コネクション&#34;&gt;永続コネクション&lt;/h3&gt;

&lt;p&gt;コネクションという概念がないのでHTTPにある&amp;rdquo;Connection&amp;rdquo;ヘッダが意味をなさない。ので、HTTPレベルでのコネクションハンドリングはしません。&lt;/p&gt;

&lt;p&gt;これ、&amp;rdquo;Connection: upgrade&amp;rdquo;はどうするんですかねって思ったら次に書いてました。&lt;/p&gt;

&lt;h3 id=&#34;httpでのquicネゴシエーション&#34;&gt;HTTPでのQUICネゴシエーション&lt;/h3&gt;

&lt;p&gt;クライアントが普通のHTTPでアクセスした時にサーバはQUICを使いませんか、とネゴシエーションすることが出来ます。それが&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Alternate-Protocol: 123:quic&amp;rdquo;&lt;/p&gt;

&lt;p&gt;です。同じホストの123ポートにQUICプロトコルでアクセスしにいきます。
中間機器がUDPをブロックすることも考えてTCPにgraceful fallbackしろ、と書かれてます。&lt;/p&gt;

&lt;h2 id=&#34;ハンドシェイクプロトコルへの要求&#34;&gt;ハンドシェイクプロトコルへの要求&lt;/h2&gt;

&lt;p&gt;ハンドシェイク自体はこのドキュメントでは扱ってませんが、ハンドシェイクが満たすべき性質を書いています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0-RTTでのコネクション確立&lt;/li&gt;
&lt;li&gt;ソースアドレスのなりすまし対策&lt;/li&gt;
&lt;li&gt;クライアントからソースアドレストークンが不透明なこと。トークンにいくつかのクライアント情報を埋め込むため。&lt;/li&gt;
&lt;li&gt;通信パラメータのネゴシエーション&lt;/li&gt;
&lt;li&gt;証明書の圧縮。REJも1350bytesに収めたい。&lt;/li&gt;
&lt;li&gt;サーバコンフィグのアップデート&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上が仕様の主だった記述です。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;HTTP/2に特化とはいうけどどこまで特化してるの？他のアプリケーションで使えないの？&lt;br /&gt;
→ ストリームやHTTP/2ヘッダなどが統合されているのでかなり扱いづらい。&lt;/li&gt;
&lt;li&gt;どうしてTLSも統合してしまったの？分離出来なかったの？&lt;br /&gt;
→ クライアント認証のために必要だった。TLS1.3からは分離出来る（？）&lt;/li&gt;
&lt;li&gt;UDPベースでどうやってコネクションの維持や輻輳制御してるの？&lt;br /&gt;
→ コネクションはコネクションIDで維持。輻輳制御は別の仕様（アクセス不可）に書いてある&lt;/li&gt;
&lt;li&gt;上記以外でQUICに特徴はないの？&lt;br /&gt;
→ 柔軟な輻輳制御、FEC、コネクション移行など&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新たに湧いた疑問&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ロードバランシングどうするんだろう。ミドルウェアレベルだとConnection ID見て振り分けるとして、アプリケーションレベルだとRubyとかでよくあるlistenしてforkしてacceptするようなやつは破綻しないかな。そもそもQUICを使わない？&lt;/li&gt;
&lt;li&gt;Connection IDが衝突したらどうなるんだろう。REJするのかな。仕様に書いてない。&lt;/li&gt;
&lt;li&gt;いくつかの仕様（HTTP/2ヘッダ）とかを無視して別のアプリケーションで使えないかな。あるいは想定してないのかな。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;宿題:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCPについても調べる。特に輻輳制御回り。&lt;/li&gt;
&lt;li&gt;QUICの輻輳制御について調べる。&lt;/li&gt;
&lt;li&gt;TLS1.3との統合について調べる&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>2017年注目していきたい技術</title>
      <link>/blog/2017/01/01/2017nenchuumokushiteikitaigijutsu</link>
      <pubDate>Sun, 01 Jan 2017 22:12:01 +0900</pubDate>
      
      <guid>/blog/2017/01/01/2017nenchuumokushiteikitaigijutsu</guid>
      <description>&lt;p&gt;κeenです。毎年これやっていく。個人的に注目していきたい技術と飛び込んでみたい技術書いく。&lt;/p&gt;

&lt;p&gt;あくまで個人的な内容。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;webassembly-http-webassembly-org&#34;&gt;&lt;a href=&#34;http://webassembly.org/&#34;&gt;WebAssembly&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;ブラウザ上で動く仮想アセンブラ。ブラウザ上でのJSの高速実行はブラウザでの至上命題である。
JIT技術を各ブラウザベンダが切磋琢磨していたがそれでも限界があるので&lt;a href=&#34;http://asmjs.org/&#34;&gt;asm.js&lt;/a&gt;なんかが産まれた。
これは例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;x|0&lt;/code&gt;と書くと&lt;code&gt;x&lt;/code&gt;が整数であることを表わす、などとしてJSのサブセットで型情報も付与出来るようにしたものだ。冗長なので人の手で書くことは意図していない。
これはある程度上手くいって、&lt;a href=&#34;https://github.com/kripken/emscripten&#34;&gt;emscripten&lt;/a&gt;のようにLLVMからjsへのコンパイラでも使われている。&lt;/p&gt;

&lt;p&gt;それでもまだ問題がある。1つに、JSよりも冗長な記法を使っているためファイルが嵩張る点。ロード時間やパース時間が長くなる。そもそも人の手で掛かないならバイナリフォーマットでもいい筈だ。
そしてもう1つに低レベルな処理、例えばSIMDなんかは扱えない点。&lt;/p&gt;

&lt;p&gt;WebAssemblyはこれらを解決する。仮想的な機械語でバイナリフォーマットがあるので低レベルなことが（将来）出来てコンパクトになっている。
計算モデルはスタックベースのマシンになっている。メモリや関数テーブルなどもある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (func (;0;) (type 0) (param i32 i32) (result i32)
    get_local 0
    get_local 1
    i32.add)
  (export &amp;quot;addTwo&amp;quot; (func 0)))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多くの人にとってWebAssemblyは意識して関るものではなく、emscriptenの吐くコードが効率的になる、程度のものだろう。
私はコンパイラを作る人なので意識する必要がある。
WebAssemblyにはundefined behaviourがないだとかThread API、 SIMD APIなどが入る予定だとかがあるのでLLVM経由で吐くよりも直接吐いた方が面白い。&lt;/p&gt;

&lt;p&gt;少し追っていきたい。&lt;/p&gt;

&lt;h1 id=&#34;quic-https-www-chromium-org-quic&#34;&gt;&lt;a href=&#34;https://www.chromium.org/quic&#34;&gt;QUIC&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;HTTP/2のための代替TCP。HTTP/2はもうリリースされてるので次はQUICを。
HTTP/2は1コネクションを複数のstreamに分割するが、stream内での到達順序保障は必要なもののstream同士ではそれが不要なのでTCPの到達順序保障が過剰要求になってしまう。
それを緩めるためにUDPベースでプロトコルを作ったのがQUIC。まあ、他にも色々改善点はあるが。&lt;/p&gt;

&lt;p&gt;これも基本的にはあまり追う必要はないが、自分の使いたい言語で実装がなかったら自分で実装することになる。
まだその辺の環境が整っていないので今後どうなるか注視する必要がある。&lt;/p&gt;

&lt;h1 id=&#34;idris-http-www-idris-lang-org&#34;&gt;&lt;a href=&#34;http://www.idris-lang.org/&#34;&gt;Idris&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;依存型のある言語。今年もRustに忙しい可能性があるが、ちょっとIdrisに興味が湧いた。
常々「多相があって正格評価で高階関数を簡単に扱えてサブタイピングのない、C FFIやThreadを扱える言語」を捜していて、それがATS2だったりSML#だったりRustだったりした。
最近はRustに落ち着いたが、今度は低レベルな部分、「C FFIやThreadを扱える」がなくてもいいから依存型が入ってる言語が欲しくなった。ATS2は置いといてIdrisかなーと。&lt;/p&gt;

&lt;p&gt;生の依存型だとつらいかな、と思っていたらtacticもあるようだったので機会があればやってみたい。&lt;/p&gt;

&lt;p&gt;CF &lt;a href=&#34;http://wkwkes.hatenablog.com/entry/2016/12/17/000000&#34;&gt;プログラミング言語 idris - wkwkesのやつ&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lean-http-leanprover-github-io&#34;&gt;&lt;a href=&#34;http://leanprover.github.io/&#34;&gt;Lean&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;MSRで開発されている定理証明支援系。よく「Coqでいいじゃん」「Agdaは？」と訊かれるが、&lt;a href=&#34;https://leanprover.github.io/theorem_proving_in_lean/index.html&#34;&gt;オンラインチュートリアル&lt;/a&gt;が良さげだったのと、Emacsから使えるのと、
&lt;a href=&#34;https://kha.github.io/2016/07/22/formally-verifying-rusts-binary-search.html&#34;&gt;RustからLeanへのトランスレートをやっている&lt;/a&gt;人がいたので興味湧いた。
そもそもCoqをある程度やってからにしろとは自分でも思う。&lt;/p&gt;

&lt;h1 id=&#34;coq-https-coq-inria-fr&#34;&gt;&lt;a href=&#34;https://coq.inria.fr/&#34;&gt;Coq&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;定理証明支援系。去年も上がっていたが、今年は酉年なので。「Agdaは？」。知らん。&lt;/p&gt;

&lt;h1 id=&#34;finagle-https-twitter-github-io-finagle&#34;&gt;&lt;a href=&#34;https://twitter.github.io/finagle/&#34;&gt;Finagle&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;RPCのクライアント/サーバフレームワーク。RPCをやる時にいくつか問題が出る。
1つはペイロードがRPC毎に違うのでフレームワークが定まりづらい点。
もう1つはロードバランシングがしづらい点。
ロードバランシングの方に言及しておくと、RPCをやる時は大抵コネクションを張りっぱなしなのでTCPロードバランサが使えない。
例えば順番にサーバを起動していくと最初に上がったサーバにコネクションが集中して以後バランスされない。&lt;/p&gt;

&lt;p&gt;これを解決するのがFinagleで、クライアントが全てのサーバにコネクションを貼って、クライアントサイドでロードバランシングをする。
さらにクライアントが複数のサーバを知っているのでサーバがエラーを返したら別のサーバにリクエストを投げることも出来る。
ペイロードの話は多相型で解決する。パーサとかその辺も含めたフレームワークになっている。&lt;/p&gt;

&lt;h1 id=&#34;tokio-https-github-com-tokio-rs-tokio&#34;&gt;&lt;a href=&#34;https://github.com/tokio-rs/tokio&#34;&gt;Tokio&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;FinagleのRust版。Rustは非同期IOに強いと思っているのでTokioがリリースされたらそこら辺のHTTPフレームワークも非同期化するのではと思っている。&lt;/p&gt;

&lt;h1 id=&#34;tidb-https-github-com-pingcap-tidb&#34;&gt;&lt;a href=&#34;https://github.com/pingcap/tidb&#34;&gt;TiDB&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;分散スケール可能なSQL DB。Rust製。&lt;a href=&#34;https://research.google.com/pubs/pub41344.html&#34;&gt;Google F1&lt;/a&gt;を参考に作られているらしい。
ストレージエンジン自体は&lt;a href=&#34;http://rocksdb.org/&#34;&gt;RocksDB&lt;/a&gt;を使っていて、その上に分散合意、MVCC、トランザクションを載せてさらにそれにSQLレイヤー、MySQLプロトコルレイヤーを載せている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pingcap.github.io/blog/assets/img/how-we-build-tidb-2.png&#34; alt=&#34;TiDBのアーキテクチャ画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アーキテクチャについては上の画像を引用した&lt;a href=&#34;https://pingcap.github.io/blog/2016/10/17/how-we-build-tidb/&#34;&gt;この記事&lt;/a&gt;が詳しい。&lt;/p&gt;

&lt;h1 id=&#34;tantivy-https-github-com-tantivy-search-tantivy&#34;&gt;&lt;a href=&#34;https://github.com/tantivy-search/tantivy&#34;&gt;tantivy&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;全文検索エンジンライブラリ。Rust製。アーキテクチャやアルゴリズムは&lt;a href=&#34;http://lucene.apache.org/core/&#34;&gt;Apache Lucene&lt;/a&gt;を参考に作られているらしいのでだいたいそのレイヤーのライブラリと思ってもらえれば。&lt;/p&gt;

&lt;p&gt;Rust製なのでインデックスの構築が速いのが一つの特徴。今後、自前でElastic SearchやApache Solrのようなレイヤーを作るのかLuceneの置き換えを狙ってJava APIを提供するのかは不明。&lt;/p&gt;

&lt;p&gt;注目したい理由はベースで使っている&lt;a href=&#34;https://github.com/BurntSushi/fst&#34;&gt;fstライブラリ&lt;/a&gt;の&lt;a href=&#34;http://blog.burntsushi.net/transducers/&#34;&gt;紹介記事&lt;/a&gt;が気に入ったから。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2016年注目していきたかった技術の振り返りと個人的振り返り</title>
      <link>/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri</link>
      <pubDate>Sat, 31 Dec 2016 16:57:48 +0900</pubDate>
      
      <guid>/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri</guid>
      <description>&lt;p&gt;κeenです。年始に&lt;a href=&#34;http://keens.github.io/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu/&#34;&gt;2016年注目していきたい技術 | κeenのHappy Hacκing Blog&lt;/a&gt;ってのを書いたので雑に振り返ります。あと個人的な一年の総括を。&lt;/p&gt;

&lt;p&gt;※個人メモなので雑多な記述が多いです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;apache-drill-https-drill-apache-org&#34;&gt;&lt;a href=&#34;https://drill.apache.org/&#34;&gt;Apache Drill&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;ちょっとづつ進化してるようだけどそこまで広まってる気配なし。因みに自分はチーム移動で使う用事がなくなったのであんまり使ってない&lt;/p&gt;

&lt;h1 id=&#34;rust-https-www-rust-lang-org-en-us&#34;&gt;&lt;a href=&#34;https://www.rust-lang.org/en-US/&#34;&gt;Rust&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;めっちゃ使った。大分進化してる。&lt;a href=&#34;https://rust.connpass.com/event/35122/&#34;&gt;ハンズオン&lt;/a&gt;のチュータやったり&lt;a href=&#34;https://rust.connpass.com/event/41467/&#34;&gt;LT会&lt;/a&gt;の玄人枠で発表したりもした。あと年明けに&lt;a href=&#34;https://rust.connpass.com/event/43893/&#34;&gt;ハンズオン第2回&lt;/a&gt;のチュータやる。&lt;/p&gt;

&lt;h1 id=&#34;apache-kafka-http-kafka-apache-org&#34;&gt;&lt;a href=&#34;http://kafka.apache.org/&#34;&gt;Apache Kafka&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;めっちゃ使った。便利。道具箱の中身が増えた。便利。&lt;/p&gt;

&lt;h1 id=&#34;floki-https-github-com-arthurprs-floki&#34;&gt;&lt;a href=&#34;https://github.com/arthurprs/floki&#34;&gt;Floki&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;5月で開発停止したっぽい。残念。&lt;/p&gt;

&lt;h1 id=&#34;robots-https-github-com-gamazeps-robots&#34;&gt;&lt;a href=&#34;https://github.com/gamazeps/RobotS&#34;&gt;RobotS&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;開発は続いてるようだけど流行ってはない。うーん、アクターいけると思ったんだけどなぁ。&lt;/p&gt;

&lt;h1 id=&#34;redox-http-www-redox-os-org&#34;&gt;&lt;a href=&#34;http://www.redox-os.org/&#34;&gt;Redox&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;開発は継続中。&lt;a href=&#34;https://github.com/redox-os/redox/releases&#34;&gt;ISOのリリース&lt;/a&gt;とかもあったしそれなりに進歩はしてる。多分もうちょっとウォッチ期間が必要。&lt;/p&gt;

&lt;h1 id=&#34;ats2-http-www-ats-lang-org&#34;&gt;&lt;a href=&#34;http://www.ats-lang.org/&#34;&gt;ATS2&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;使ってない。一回コンパイラのバグ踏んじゃって萎えてその後はRustばっか使ってる。面白いんだけどなぁ…&lt;/p&gt;

&lt;h1 id=&#34;r-https-www-r-project-org&#34;&gt;&lt;a href=&#34;https://www.r-project.org/&#34;&gt;R&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;チーム移動で用事がなくなったのであまり使ってない。
一応それなりには使ったけどあんまりRのこと覚えきれてない。例えるならEmacs初心者がEmacs Lispのスニペットをコピペでどうにか使ってるくらい。&lt;/p&gt;

&lt;h1 id=&#34;異常検知&#34;&gt;異常検知&lt;/h1&gt;

&lt;p&gt;チーム移動で(ry&lt;/p&gt;

&lt;h1 id=&#34;coq-https-coq-inria-fr&#34;&gt;&lt;a href=&#34;https://coq.inria.fr/&#34;&gt;Coq&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;それなりにやった。&lt;a href=&#34;http://proofcafe.org/sf/&#34;&gt;ソフトウェアの基礎&lt;/a&gt;のサブタイプまでやった。ProofGeneralのバグは&lt;a href=&#34;https://github.com/ProofGeneral/PG&#34;&gt;GitHubにある方のProofGeneral&lt;/a&gt;を使ったら解決した。あと&lt;a href=&#34;https://twitter.com/search?q=%23readcoqart&amp;amp;src=typd&amp;amp;lang=ja&#34;&gt;#readcoqart&lt;/a&gt;にも何度か参加した。&lt;/p&gt;

&lt;h1 id=&#34;isabelle-https-isabelle-in-tum-de&#34;&gt;&lt;a href=&#34;https://isabelle.in.tum.de/&#34;&gt;Isabelle&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;一応チュートリアルを少しやった。あと&lt;a href=&#34;https://keens.github.io/slide/tadashiiScalanoko_dogahoshii/&#34;&gt;社内勉強会で発表&lt;/a&gt;もした。Isabelle 2014までしかProofGeneralで使えないのでちょっと厳しくなってやらなくなった。つらい。&lt;/p&gt;

&lt;p&gt;いい加減Emacs以外のプラットフォームも使えるようにならないとなー。&lt;/p&gt;

&lt;h1 id=&#34;fortran&#34;&gt;Fortran&lt;/h1&gt;

&lt;p&gt;やってない。1ﾐﾘも触ってない。本当はある程度入門したらFortranコンパイラでも作るかって気分だったけど&lt;a href=&#34;http://no-maddojp.hatenablog.com/entry/2016/12/01/023624&#34;&gt;つらいらしい&lt;/a&gt;のでやらなくてよかった&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;じゃ、個人的総括。まず、個人ブログはこのエントリ含めて48。週1ペース守れなかった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu&#34;&gt;2016年注目していきたい技術&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/01/ATS2nokangaseiridekita&#34;&gt;ATS2の観が整理出来た&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/08/Rusttoiedoriso_sunokaihouhachuui&#34;&gt;Rustといえどリソースの解放は注意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/11/SML_nopthreadbaindingutsukutta&#34;&gt;SML#のpthreadバインディング作った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/12/Isabelleninyuumonshita&#34;&gt;Isabelleに入門した&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/17/dokugakudepuroguraminguwoyattekitanakadeyokattagijutsushowoageteiku&#34;&gt;独学でプログラミングをやってきた中で良かった技術書50選&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/17/puroguraminguwodokugakusurutokikosoinputtowofuyashitahougaii&#34;&gt;プログラミングを独学する時こそインプットを増やした方がいい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/27/Lisp_Meetup3shuunenniyosete&#34;&gt;Lisp Meetup3周年に寄せて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/31/Rustnopakke_jiwocrates_ionitourokusuru&#34;&gt;Rustのパッケージをcrates.ioに登録する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/04/Common_Lispdekousokugyouretsuenzan&#34;&gt;Common Lispで高速行列演算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/10/Nexus_5niUbuntu_Touchnoinsuto_ru&#34;&gt;Nexus 5にUbuntu Touchのインストール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/14/DVCSnomoderu_aruihaPijulnitsuite&#34;&gt;分散VCSのモデル、あるいはPijulについて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/14/readlinenotsukurikata&#34;&gt;readlineの作り方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/24/Bind_Addressnoimigayouyakuwakatta&#34;&gt;Bind Addressの意味がようやく分かった&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/27/druidtoiuriarutaimude_tabunsekitsu_ruwoshitta&#34;&gt;druidというリアルタイムデータ分析ツールを知った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/28/RustnoHigherKinded_type_Trait&#34;&gt;RustのHigher-Kinded type Trait&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/03/01/Rustnozerokosutochuushouka&#34;&gt;Rustのゼロコスト抽象化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/03/01/tesutonitsuitekangaetemita&#34;&gt;テストについて考えてみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/03/02/ri_jontoRustnokaerichi&#34;&gt;リージョンとRustの返り値&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/04/04/Mirahkanrentsu_rumatome&#34;&gt;Mirah関連ツールまとめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii&#34;&gt;LXDがリリースされたらしい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/05/04/RustdebeametaruRaspberry_PinoLchika&#34;&gt;RustでベアメタルRaspberry PiのLチカ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/05/14/cargo_profilerwotamesu&#34;&gt;cargo-profilerを試す&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru&#34;&gt;multirustが非推奨になったようなのでrustupに移行する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/06/19/Rustnoshoyuuken_myu_tabiriteinobunkatsu&#34;&gt;Rustの所有権/ミュータビリティの分割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/07/02/Container_Desgin_Patterns&#34;&gt;Container Desgin Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/07/13/shierugeijuuhachihan&#34;&gt;シェル芸十八般&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai&#34;&gt;私がコードを書くときテストは書かない&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/08/11/mirah_0_2gariri_susaremashita&#34;&gt;mirah 0.2がリリースされました。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/09/04/Rustdeshierutsukutta&#34;&gt;Rustでシェル作った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/09/29/Pijulnoinsuto_ruganan_idotakainodekaisetsusuru&#34;&gt;Pijulのインストールが難易度高いので解説する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/10/10/Rustnokuro_ja3tanewotsukutterikaisuru&#34;&gt;Rustのクロージャ3種を作って理解する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/10/10/SMLdemonado&#34;&gt;SMLでモナド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/10/31/VMwarenoUbuntuwo16_10nishitarakidoushinakunatta&#34;&gt;VMwareのUbuntuを16.10にしたら起動しなくなった&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/06/RustnokatareberuLispppoinotsukutta&#34;&gt;Rustの型レベルLispっぽいの作った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/22/Rustnokanrenkatanotsukaidokoro&#34;&gt;Rustの関連型の使いどころ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/30/SML_woUbuntu_16_10deugokasu&#34;&gt;SML#をUbuntu 16.10で動かす&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/30/saiba_e_jientowotaishokushimashita&#34;&gt;サイバーエージェントを退職しました&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/01/4nenkantsuzuitaShibuya_lispnoLispMeetUp&#34;&gt;4年間続いたShibuya.lispのLispMeetUp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/01/Rustdebaitoretsuwoatsukautokinotips&#34;&gt;Rustでバイト列を扱う時のtips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou&#34;&gt;マクロやコンパイラプラグインの実装方法色々&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/02/Rustnopurosesu&#34;&gt;Rustのプロセス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/02/atarashiikonpairabakkuendocretonne&#34;&gt;新しいコンパイラバックエンドcretonne&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/03/Rustnostructtotraittteniteruyone&#34;&gt;Rustのstructとtraitって似てるよね&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/14/Rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami&#34;&gt;Rustの所有権、ライフタイム、参照、型、しがらみ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/24/Rustnoraifutaimuwotsukattasuko_pukaiseki&#34;&gt;Rustのライフタイムを使ったスコープ解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/29/kizuitaraRustnokankyoukouchikugakanarirakuninatteta&#34;&gt;気付いたらRustの環境構築がかなり楽になってた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri&#34;&gt;2016年注目していきたかった技術の振り返りと個人的振り返り&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スライドは15。月1以上のペースだった。意外。ほとんど社内のScala勉強会で発表してるっぽい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/slide/HAMT&#34;&gt;HAMT ~ イミュータブルで高速なハッシュマップ ~&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/ClojuredeSSPwotsukuttahanashi&#34;&gt;ClojureでSSPを作った話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Rusttohananika_donnagengoka_&#34;&gt;Rustとは何か。どんな言語か。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni&#34;&gt;ビッグデータしないDrill、ローカルで快適に使うために&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/SMLdekansuukatatekiseikihyougenmatchi&#34;&gt;SMLで函数型的正規表現マッチ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/tesutonitsuite_Scalato_&#34;&gt;テストについて、Scalaと。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/kousokunakeizokuraiburarinimukete&#34;&gt;高速な継続ライブラリに向けて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/DOT_dottynitsuiteshirabetemita&#34;&gt;DOT/dottyについて調べてみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Socket_on_SML_&#34;&gt;Socket on SML#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/katakurasuwokoete&#34;&gt;型クラスを越えて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/tadashiiScalanoko_dogahoshii&#34;&gt;正しいScalaのコードが欲しい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Scala_2_12_0henkouten&#34;&gt;Scala 2.12.0変更点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Rustnohanashitoriso_sunohanashi&#34;&gt;Rustの話とリソースの話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/RustdehidoukiThriftshitai&#34;&gt;Rustで非同期Thriftしたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Schemedeclasstoprotocol&#34;&gt;SchemeでClassとProtocol&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その他外部に投稿したものは13。これも併わせたらブログはギリギリ週1ペースかな。仕事関連だったり仕事中に思い付いてブログにアクセス出来ないのでQiitaに投げたものが多い。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/3b068769736e671805f0&#34;&gt;Rustのドキュメントの翻訳プロジェクトを開始します。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/382704cc54c8e42819d0&#34;&gt;正規表現の先読み/後読みを「絞り込み」と理解してみる - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/c9e60e089974392878c8&#34;&gt;一瞬でシェルスクリプト作れるシェル関数作った - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/3231c8adec40b350cf33&#34;&gt;sedの-iオプションの非互換 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/4945a6eb5cceeb154b24&#34;&gt;Rustでサイコロで同じ目が100回連続で実際に出るか - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/4f91a174e0f63ee42699&#34;&gt;POSIXシェルで変数がセットされているか検査するイディオム - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1095&#34;&gt;ICFP及び関連イベント参加レポート – Haskell Day – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1099&#34;&gt;ICFP及び関連イベント参加レポート – ICFP併設ワークショップ – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1118&#34;&gt;ICFP及び関連イベント参加レポート – ICFP 1日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1125&#34;&gt;ICFP及び関連イベント参加レポート – ICFP 2日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1158&#34;&gt;ICFP及び関連イベント参加レポート – ICFP 3日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1200&#34;&gt;ICFP及び関連イベント参加レポート – 併設ワークショップ2日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1380&#34;&gt;ICFP及び関連イベント参加レポート – 併設ワークショップ3日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、OSSだと雑なスニペットとかもGitHubに上げてるのでカウントが難しいけど、主だったものだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/incubator-airflow&#34;&gt;airflow&lt;/a&gt;の&lt;a href=&#34;https://github.com/apache/incubator-airflow/blob/master/airflow/contrib/operators/ssh_execute_operator.py&#34;&gt;SSH Execute Operator&lt;/a&gt;を書いた&lt;/li&gt;
&lt;li&gt;Apache Drillの&lt;a href=&#34;https://github.com/KeenS/sql-drill.el&#34;&gt;Emacs Mode&lt;/a&gt;作った（リリースしてない）&lt;/li&gt;
&lt;li&gt;Rustの&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logger&lt;/a&gt;作った&lt;/li&gt;
&lt;li&gt;file_loggerと一緒に使うために&lt;a href=&#34;https://github.com/KeenS/rotate_file&#34;&gt;rotate_file&lt;/a&gt;作った（リリースしてない）&lt;/li&gt;
&lt;li&gt;インターン向けに作った&lt;a href=&#34;https://github.com/KeenS/s7p&#34;&gt;SSP&lt;/a&gt;を公開した。&lt;/li&gt;
&lt;li&gt;SML#の&lt;a href=&#34;https://github.com/KeenS/smlsharp_pthread&#34;&gt;pthreadバインディング&lt;/a&gt;作った。多分64bitで動かない。&lt;/li&gt;
&lt;li&gt;SML#の&lt;a href=&#34;https://github.com/KeenS/SmlSharpSocketSupport&#34;&gt;socketサポー&lt;/a&gt;作った。まだメモリ管理回りで処理系とのやりとりに上手くいってないので完成してない。&lt;/li&gt;
&lt;li&gt;Rustで&lt;a href=&#34;https://github.com/KeenS/igaguri&#34;&gt;シェル&lt;/a&gt;作った。雑に動く。&lt;/li&gt;
&lt;li&gt;Tokioの&lt;a href=&#34;https://github.com/KeenS/tokio-thrift&#34;&gt;Thrift対応&lt;/a&gt;フレームワーク作成中。Tokio側がリリースされたらこちらもリリース出来るくらいの進捗でやっていきたい。&lt;/li&gt;
&lt;li&gt;Rust公式ドキュメントの&lt;a href=&#34;https://github.com/rust-lang-ja/the-rust-programming-language-ja&#34;&gt;翻訳&lt;/a&gt;一応1.6は完了。今1.14まで来てるので更新せねば…。&lt;/li&gt;
&lt;li&gt;なんか適当な&lt;a href=&#34;https://github.com/KeenS/webml&#34;&gt;ML風言語のコンパイラ&lt;/a&gt;作り始めた。年内にコード吐くまでやりたかったけど最後の数日サボってしまったので間に合わない。&lt;/li&gt;
&lt;li&gt;コンパイラのために&lt;a href=&#34;[KeenS/WebAssembler-rs](https://github.com/KeenS/WebAssembler-rs)&#34;&gt;WebAssemblyをインメモリで吐くライブラリ&lt;/a&gt;作った。ブラウザでコンパイラ動かしたい時に使う。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;かな。&lt;a href=&#34;https://github.com/KeenS/cl-fast-cont&#34;&gt;限定継続ライブラリ&lt;/a&gt;みたいに途中で放置してるやつとか&lt;a href=&#34;https://github.com/KeenS/rust_os&#34;&gt;チュートリアル読んでOS作ってるやつ&lt;/a&gt;とかは入れてないので「活動」って意味だともう少し広いけど社会貢献はしてない。&lt;/p&gt;

&lt;p&gt;仕事も含めたGitHubの草はこんなもん。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;und&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://t.co/MVQag8h6qU&#34;&gt;pic.twitter.com/MVQag8h6qU&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/814449614967357440&#34;&gt;2016年12月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;引越しだとかICFPとかの週はほとんどコミット出来てないのでもうちょっと頑張りたい。あと顕著に土日にサボってるのもどうにかしたい。&lt;/p&gt;

&lt;p&gt;割と飽きっぽいというか他のものに浮気しがちというか適当に手を付けては壁に当たった/第一目標達成したあたりで次にいっちゃうので継続性がない。継続した方が社会貢献になるんだよなー。&lt;/p&gt;

&lt;p&gt;読書は正確にいつ買ったか覚えてないので正確じゃないけど、流し読みしたものも含めれば&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/gp/product/4535782148/&#34;&gt;線型論理入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4621063243/&#34;&gt;圏論の基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4535787204/&#34;&gt;圏論の歩き方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/gp/product/052103311X/&#34;&gt;Compiling with Continuations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798114685/&#34;&gt;最新コンパイラ構成技法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798134201/&#34;&gt;ガベージコレクション 自動的メモリ管理を構成する理論と実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798045365/&#34;&gt;独自CPU開発で学ぶコンピュータのしくみ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4797382228/&#34;&gt;暗号技術入門 第3版 秘密の国のアリス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798141100/&#34;&gt;その数式、プログラムできますか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4873116856/&#34;&gt;戦略的データサイエンス入門 ―ビジネスに活かすコンセプトとテクニック&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529153/&#34;&gt;ノンパラメトリックベイズ 点過程と統計的機械学習の数理 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529099/&#34;&gt;劣モジュラ最適化と機械学習 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529021/&#34;&gt;深層学習 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529080&#34;&gt;異常検知と変化検知 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/479813161X/&#34;&gt;実践ドメイン駆動設計 (Object Oriented SELECTION)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4048679880&#34;&gt;The Art of Multiprocessor Programming 並行プログラミングの原理から実践まで&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多分こんなもん。機械学習プロフェッショナルシリーズは去年読んだのも含んでるかもしれない。あんまり覚えてない。論文も挙げようと思ったけど面倒になったからいいや。十数綴から二十綴くらいじゃないかな。&lt;/p&gt;

&lt;p&gt;社会的には1回社内でチーム移動になって1回退職した。Shibuya.lispの運営から引退を発表して、rust-lang-ja（有志の翻訳コミュニティ？）の中の人になった。&lt;/p&gt;

&lt;p&gt;まだ社会人になって2年も経ってなくて情報科学/工学の基礎もないので基礎を付けるために勉強してるフェーズかなぁといったところ。
来年は専門性の高い仕事になるので今年以上に勉強が必要になりそう。多分本より論文に比重が傾く。&lt;/p&gt;

&lt;p&gt;年明けにまた注目していきたい技術書く。毎年書いていったら面白いかもしれない。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>気付いたらRustの環境構築がかなり楽になってた</title>
      <link>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</link>
      <pubDate>Thu, 29 Dec 2016 11:52:55 +0900</pubDate>
      
      <guid>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</guid>
      <description>&lt;p&gt;κeenです。ここのところRustの開発ツール回りでリリースが続いてセットアップが楽になってるようだったので最新の情報をお届けします。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;とりあえず私は既存の環境があるので一旦全て破棄してから再度セットアップしてみます。&lt;/p&gt;

&lt;h1 id=&#34;rustのインストール&#34;&gt;Rustのインストール&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;がリリースされたので以下で一発です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;source $HOME/.cargo/env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をシェルのrcファイルに書き加えたらOKです。
今のシェルにも反映するには同じく上記のコマンドを打ちます。&lt;/p&gt;

&lt;h1 id=&#34;周辺ツールのインストール&#34;&gt;周辺ツールのインストール&lt;/h1&gt;

&lt;p&gt;cargoがあるので楽ですね&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# コードフォーマッタ
$ cargo install rustfmt
# 補完、定義ジャンプなど
$ cargo install racer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあ時間がかかります。&lt;/p&gt;

&lt;h1 id=&#34;エディタ-emacs-の設定&#34;&gt;エディタ(Emacs)の設定&lt;/h1&gt;

&lt;p&gt;私がEmacsを使ってるのでEmacsの設定を。&lt;/p&gt;

&lt;p&gt;まず、必要パッケージをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;rustfmt&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。rust-modeにrustfmtの機能が含まれているようでした。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; rustfmtを emacsから使うの rust-modeが現在サポートしているので, rustfmt.elパッケージは不要ですね. rust-format-on-saveが non-nilなら保存時に rustfmtが実行されます.&lt;/p&gt;&amp;mdash; Syohei YOSHIDA (@syohex) &lt;a href=&#34;https://twitter.com/syohex/status/814354653672415232&#34;&gt;2016年12月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;;;; racerやrustfmt、コンパイラにパスを通す
(add-to-list &#39;exec-path (expand-file-name &amp;quot;~/.cargo/bin/&amp;quot;))
;;; rust-modeでrust-format-on-saveをtにすると自動でrustfmtが走る
(eval-after-load &amp;quot;rust-mode&amp;quot;
  &#39;(setq-default rust-format-on-save t))
;;; rustのファイルを編集するときにracerとflycheckを起動する
(add-hook &#39;rust-mode-hook (lambda ()
                            (racer-mode)
                            (flycheck-rust-setup)))
;;; racerのeldocサポートを使う
(add-hook &#39;racer-mode-hook #&#39;eldoc-mode)
;;; racerの補完サポートを使う
(add-hook &#39;racer-mode-hook (lambda ()
                             (company-mode)
                             ;;; この辺の設定はお好みで
                             (set (make-variable-buffer-local &#39;company-idle-delay) 0.1)
                             (set (make-variable-buffer-local &#39;company-minimum-prefix-length) 0)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とりあえずこれでセットアップ完了です。racerの最新版でrustのソースコードの位置を設定しなくてよくなったので簡潔になりましたね。&lt;/p&gt;

&lt;p&gt;racer-modeは補完をしてくれる他、&lt;code&gt;M-.&lt;/code&gt;で定義元ジャンプ、&lt;code&gt;M-,&lt;/code&gt;でジャンプ元に戻れます。
あとは&lt;code&gt;M-x racer-describe&lt;/code&gt;でポイント位置にあるシンボルのrustdocを(Emacs内で)表示してくれます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;おお! racerでEmacs内でrustdocレンダ出来るようになってる！便利！！&lt;br&gt;&lt;br&gt;Rustdoc Meets The Self-Documenting Editor&lt;a href=&#34;https://t.co/gDEHl2fSfx&#34;&gt;https://t.co/gDEHl2fSfx&lt;/a&gt; &lt;a href=&#34;https://t.co/sdrX9OoEnr&#34;&gt;pic.twitter.com/sdrX9OoEnr&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/770796719185408000&#34;&gt;2016年8月31日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;その他は放っておくと勝手に機能してくれるので考えることが少なくていいですね。&lt;/p&gt;

&lt;h1 id=&#34;その他便利ツール&#34;&gt;その他便利ツール&lt;/h1&gt;

&lt;p&gt;セットアップがあっけなかったのでついでに入れておくと便利なツールをいくつか紹介します。&lt;/p&gt;

&lt;h2 id=&#34;cargo-edit&#34;&gt;cargo-edit&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-edit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「libcクレートの最新版に依存したい」なんて時に一々libcの最新版を確認するのは面倒ですよね。そんなときにcargo-editがあれば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo add libc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で &lt;code&gt;Cargo.toml&lt;/code&gt; に追記してくれます。&lt;/p&gt;

&lt;h2 id=&#34;cargo-script&#34;&gt;cargo-script&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとした実験スクリプトとかをコンパイル→実行のステップを踏まずにいきなり実行出来ます。
&lt;code&gt;cargo script FILE&lt;/code&gt;でファイルを実行出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; hello.rs
fn main() {
    println!(&amp;quot;hello, script&amp;quot;)
}
EOF
$ cargo script hello.rs
   Compiling hello v0.1.0 (file:///home/kim/.cargo/.cargo/script-cache/file-hello-f6b1735a519bb659)
    Finished release [optimized] target(s) in 0.15 secs
hello, script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というふうに使います。&lt;/p&gt;

&lt;p&gt;シェルのrcファイルで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;alias rust=&#39;cargo-script&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としておくと吉。&lt;/p&gt;

&lt;h2 id=&#34;cargo-update&#34;&gt;cargo-update&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までインストールしたバイナリのアップデートを出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install-update -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのライフタイムを使ったスコープ解析</title>
      <link>/blog/2016/12/24/rustnoraifutaimuwotsukattasuko_pukaiseki</link>
      <pubDate>Sat, 24 Dec 2016 22:51:46 +0900</pubDate>
      
      <guid>/blog/2016/12/24/rustnoraifutaimuwotsukattasuko_pukaiseki</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;の25日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。大トリに小ネタで申し訳ないのですが最近書いたコードでちょっと便利だなと思ったテクニックを紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;次のような言語のインタプリタを作ることを考えます。意味論はエスパーして下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 1
y = 2
println(&amp;quot;x = &amp;quot;, x)
println(&amp;quot;y = &amp;quot;, y)

println(&amp;quot;--&amp;quot;)

{
    x = 3
    println(&amp;quot;x = &amp;quot;, x)
    println(&amp;quot;y = &amp;quot;, y)
}

println(&amp;quot;--&amp;quot;)

println(&amp;quot;x = &amp;quot;, x)
println(&amp;quot;y = &amp;quot;, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この実行結果は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になりますね。このインタプリタをRustで作りましょう。&lt;/p&gt;

&lt;h1 id=&#34;初期実装&#34;&gt;初期実装&lt;/h1&gt;

&lt;p&gt;雛形はこんなもんでしょうか。後でリファレンスが出てきてややこしくなるので値は全て所有権を貰っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Debug, Clone)]
struct AST(Vec&amp;lt;Stmt&amp;gt;);

#[derive(Debug, Clone)]
enum Stmt {
    Subst(String, Expr),
    Print(Vec&amp;lt;Expr&amp;gt;),
    Block(Vec&amp;lt;Stmt&amp;gt;),
}


#[derive(Debug, Clone)]
enum Expr {
    Str(String),
    Num(isize),
    Var(String),
}


struct Interpreter {
    // これを実装する
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{}
    }

    fn run(&amp;amp;mut self, ast: AST) {
        for stmt in ast.0 {
            self.run_stmt(stmt);
        }
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        // これを実装する
    }
}

fn main() {
    let ast = {
        use Stmt::*;
        use Expr::*;
        AST(
            vec![
                Subst(&amp;quot;x&amp;quot;.to_string(), Num(1)),
                Subst(&amp;quot;y&amp;quot;.to_string(), Num(2)),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Block(vec![
                    Subst(&amp;quot;x&amp;quot;.to_string(), Num(3)),
                    Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                    Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                ]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
            ]
        )
    };
    let mut interpreter = Interpreter::new();

    interpreter.run(ast);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(コンストラクタ関数作っときゃよかったかも)&lt;/p&gt;

&lt;p&gt;今回の本質ではないのでパーサは用意してません。&lt;/p&gt;

&lt;p&gt;さて、とりあえずのところ変数の管理のためにシンボルテーブルが必要です。実装しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;//...

use std::collections::HashMap;
struct Interpreter {
    symbol_table: HashMap&amp;lt;String, Expr&amp;gt;,
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{
            symbol_table: HashMap::new(),
        }
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        self.symbol_table.insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        self.symbol_table
            .get(name)
            .expect(&amp;quot;reference to unknown variable&amp;quot;)
            .clone()
    }

  //...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡略化のためにcloneやpanicしてますがご愛嬌。&lt;/p&gt;

&lt;p&gt;これがあれば&lt;code&gt;run_stmt&lt;/code&gt;のそれっぽい実装は出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            Subst(name, expr) =&amp;gt; {
                let expr = self.eval(expr);
                self.add_to_scope(name, expr);
            },
            Print(exprs) =&amp;gt; {
                for expr in exprs {
                    self.print_expr(expr);
                }
                println!(&amp;quot;&amp;quot;);
            },
            Block(stmts) =&amp;gt; {
                for stmt in stmts {
                    self.run_stmt(stmt);
                }
            },
        }

    }

    fn eval(&amp;amp;self, expr: Expr) -&amp;gt; Expr {
        use Expr::*;
        match expr {
            Var(v) =&amp;gt; self.find_scope(&amp;amp;v),
            e @ Str(_) |
            e @ Num(_) =&amp;gt; e
        }
    }

    fn print_expr(&amp;amp;self, expr: Expr) {
        use Expr::*;
        match self.eval(expr) {
            Str(ref s) =&amp;gt; print!(&amp;quot;{}&amp;quot;, s),
            Num(ref n) =&amp;gt; print!(&amp;quot;{}&amp;quot;, n),
            Var(_) =&amp;gt; panic!(&amp;quot;reference to unknown variable&amp;quot;) ,
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、これを走らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 3
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコープを実装していないので最後の&lt;code&gt;x&lt;/code&gt;が3になっていますね。スコープを実装しましょう。&lt;/p&gt;

&lt;p&gt;スコープを実装するには簡単にはハッシュテーブルを複数持てば良さそうです。
3段にネストしたスコープなら3つのハッシュテーブルを持ちます。
そしてスコープを抜けた時にそのスコープに対応するハッシュテーブルを消せば（忘れれば）良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Interpreter {
   // スコープに対応したテーブル達。
   symbol_tables: Vec&amp;lt;HashMap&amp;lt;String, Expr&amp;gt;&amp;gt;,
   // 今どのスコープを指しているか。
   // スコープを抜けてもベクトルは縮まないのでこれが必要。
   pos: usize,
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        // 新しいフィールドの初期化
        Interpreter{
            symbol_tables: Vec::new(),
            // ややこしくなるが、0で初期化しているのでpos-1番目のハッシュマップが現スコープのテーブルになる
            pos: 0,
        }
    }

    // スコープに入る処理。
    fn in_scope(&amp;amp;mut self) {
        let pos = self.pos;
        // スコープから抜けてもハッシュマップは消えないので
        // 入る → 出る → 入るをしたときに既にテーブルがある場合が出てくる。
        // 必要なテーブルが既にある場合とない場合で条件分岐
        if self.symbol_tables.len() &amp;lt;= pos {
            self.symbol_tables.push(HashMap::new())
        } else {
            // 既にテーブルがある場合は古い情報を消す
            self.symbol_tables[pos - 1].clear()
        }
        // ポジションは忘れずインクリメント
        self.pos += 1;
    }

    // スコープから抜ける処理
    fn out_scope(&amp;amp;mut self) {
        // スコープから抜けるのはデクリメントのみでOK
        self.pos -= 1;
    }

    pub fn run(&amp;amp;mut self, ast: AST) {
        // in_scope が増えた
        self.in_scope();
        for stmt in ast.0 {
            self.run_stmt(stmt);
        }
        // out_scope が増えた
        self.out_scope();
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        // 現在のスコープに変数を入れる
        let pos = self.pos - 1;
        self.symbol_tables[pos].insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        let pos = self.pos;
        // 一番内側(現在)のスコープから外側のスコープの順に調べていく。
        // `[0..pos]` や `rev()` に注意。
        for table in self.symbol_tables[0..pos].iter().rev() {
            if let Some(e) = table.get(name) {
                return e.clone()
            }
        }
        // どこにもなければ未定義変数
        panic!(&amp;quot;reference to unknown variable&amp;quot;)
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            // ..
            Block(stmts) =&amp;gt; {
                // in_scope が増えた
                self.in_scope();
                for stmt in stmts {
                    self.run_stmt(stmt);
                }
                // out_scope が増えた
                self.out_scope();
            },
        }

    }

    // ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで走らせてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。動きました。&lt;/p&gt;

&lt;h1 id=&#34;scope-の導入&#34;&gt;&lt;code&gt;Scope&lt;/code&gt; の導入&lt;/h1&gt;

&lt;p&gt;さて、上のコードでは&lt;code&gt;in_scope&lt;/code&gt;と&lt;code&gt;out_scope&lt;/code&gt;が対で現れました。というか現れないといけません。
でもプログラミングエラーで&lt;code&gt;out_scope&lt;/code&gt;を忘れるなんてことはよくある話です（現に私はこのサンプルを書いてて間違えかけました）。これをRustのライフタイムの仕組みに乗っけて自動で解決しようというのが今回のお話。&lt;/p&gt;

&lt;p&gt;手法は簡単で、とりあえず&lt;code&gt;Scope&lt;/code&gt;という型を用意します。そして&lt;code&gt;new&lt;/code&gt;する時に&lt;code&gt;in_scope&lt;/code&gt;を呼んであげて、&lt;code&gt;drop&lt;/code&gt;する時に&lt;code&gt;out_scope&lt;/code&gt;を呼んであげます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::Drop;
struct Scope&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a mut Interpreter);

impl &amp;lt;&#39;a&amp;gt;Scope&amp;lt;&#39;a&amp;gt; {
    fn new(inpr: &amp;amp;&#39;a mut Interpreter) -&amp;gt; Self {
        inpr.in_scope();
        Scope(inpr)
    }
}

impl &amp;lt;&#39;a&amp;gt;Drop for Scope&amp;lt;&#39;a&amp;gt; {
    fn drop(&amp;amp;mut self) {
        self.0.out_scope()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この&lt;code&gt;&amp;amp;mut Interpreter&lt;/code&gt;で参照しているというのが丁度良くて、Scopeの分岐というのを防ぐことが出来ます。こういうやつですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let scope1 = Scope::new(&amp;amp;mut intr);
let scope2 = Scope::new(&amp;amp;mut intr); // error: 既に&amp;amp;mut されている変数は&amp;amp;mut出来ない
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、これを使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    pub fn run(&amp;amp;mut self, ast: AST) {
        // in_scopeをScope::new()に置き換えた
        let scope = Scope::new(self);
        for stmt in ast.0 {
            // scopeに渡してしまったのでselfはsope.0で参照する必要がある
            scope.0.run_stmt(stmt);
        }
        // out_scopeは自動で呼ばれる
    }

    // run_stmtのBlockも同様に書き換える
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cargo run
x = 1
y = 2
--
x = 3
y = 2
--
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きました。でも、あまり&lt;code&gt;scope.0&lt;/code&gt;なんて使いたくないですよね。出来れば透過的に扱いたい。
そんなときのために&lt;code&gt;Deref&lt;/code&gt; と &lt;code&gt;DerefMut&lt;/code&gt; です。Rustは型が合わなければ自動で&lt;code&gt;deref&lt;/code&gt;を呼んでくれます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Deref&lt;/code&gt; と &lt;code&gt;DerefMut&lt;/code&gt; を実装しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::{Deref, DerefMut};
impl &amp;lt;&#39;a&amp;gt; Deref for Scope&amp;lt;&#39;a&amp;gt; {
    type Target = Interpreter;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Interpreter {
        self.0
    }
}

impl &amp;lt;&#39;a&amp;gt; DerefMut for Scope&amp;lt;&#39;a&amp;gt; {
    fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Interpreter {
        self.0
    }
}

impl Interpreter {
    // ..

    pub fn run(&amp;amp;mut self, ast: AST) {
        // deref_mutするために mutをつける
        let mut scope = Scope::new(self);
        for stmt in ast.0 {
            // scope.0しなくてもInterpreterのメソッドが呼べる
            scope.run_stmt(stmt);
        }
    }

   // ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;生成と消滅が対になるものはRustのオブジェクトで管理出来るよ&lt;/li&gt;
&lt;li&gt;シンプルなラッパー型は&lt;code&gt;Deref&lt;/code&gt;や&lt;code&gt;DerefMut&lt;/code&gt;を実装しておくと便利だよ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/drop.html&#34;&gt;Drop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/deref-coercions.html&#34;&gt;&lt;code&gt;Deref&lt;/code&gt; による型強制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;付録a&#34;&gt;付録A&lt;/h1&gt;

&lt;p&gt;最終的なソースコード全文を掲載します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Debug, Clone)]
struct AST(Vec&amp;lt;Stmt&amp;gt;);

#[derive(Debug, Clone)]
enum Stmt {
    Subst(String, Expr),
    Print(Vec&amp;lt;Expr&amp;gt;),
    Block(Vec&amp;lt;Stmt&amp;gt;),
}


#[derive(Debug, Clone)]
enum Expr {
    Str(String),
    Num(isize),
    Var(String),
}


use std::collections::HashMap;
struct Interpreter {
   symbol_tables: Vec&amp;lt;HashMap&amp;lt;String, Expr&amp;gt;&amp;gt;,
   pos: usize,
}

use std::ops::{Drop, Deref, DerefMut};
struct Scope&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a mut Interpreter);

impl &amp;lt;&#39;a&amp;gt;Scope&amp;lt;&#39;a&amp;gt; {
    fn new(inpr: &amp;amp;&#39;a mut Interpreter) -&amp;gt; Self {
        inpr.in_scope();
        Scope(inpr)
    }
}

impl &amp;lt;&#39;a&amp;gt;Drop for Scope&amp;lt;&#39;a&amp;gt; {
    fn drop(&amp;amp;mut self) {
        self.0.out_scope()
    }
}

impl &amp;lt;&#39;a&amp;gt; Deref for Scope&amp;lt;&#39;a&amp;gt; {
    type Target = Interpreter;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Interpreter {
        self.0
    }
}

impl &amp;lt;&#39;a&amp;gt; DerefMut for Scope&amp;lt;&#39;a&amp;gt; {
    fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Interpreter {
        self.0
    }
}

impl Interpreter {
    pub fn new() -&amp;gt; Self {
        Interpreter{
            symbol_tables: Vec::new(),
            pos: 0,
        }
    }

    fn in_scope(&amp;amp;mut self) {
        let pos = self.pos;
        if self.symbol_tables.len() &amp;lt;= pos {
            self.symbol_tables.push(HashMap::new())
        } else {
            self.symbol_tables[pos - 1].clear()
        }
        self.pos += 1;
    }

    fn out_scope(&amp;amp;mut self) {
        self.pos -= 1;
    }

    pub fn run(&amp;amp;mut self, ast: AST) {
        let mut scope = Scope::new(self);
        for stmt in ast.0 {
            scope.run_stmt(stmt);
        }
    }

    fn add_to_scope(&amp;amp;mut self, name: String, expr: Expr) {
        let pos = self.pos - 1;
        self.symbol_tables[pos].insert(name, expr);
    }

    fn find_scope(&amp;amp;self, name: &amp;amp;str) -&amp;gt; Expr {
        let pos = self.pos;
        for table in self.symbol_tables[0..pos].iter().rev() {
            if let Some(e) = table.get(name) {
                return e.clone()
            }
        }
        panic!(&amp;quot;reference to unknown variable&amp;quot;)
    }

    fn run_stmt(&amp;amp;mut self, stmt: Stmt) {
        use Stmt::*;

        match stmt {
            Subst(name, expr) =&amp;gt; {
                let expr = self.eval(expr);
                self.add_to_scope(name, expr);
            },
            Print(exprs) =&amp;gt; {
                for expr in exprs {
                    self.print_expr(expr);
                }
                println!(&amp;quot;&amp;quot;);
            },
            Block(stmts) =&amp;gt; {
                let scope = Scope::new(self);

                for stmt in stmts {
                    scope.0.run_stmt(stmt);
                }
            },
        }

    }

    fn eval(&amp;amp;self, expr: Expr) -&amp;gt; Expr {
        use Expr::*;
        match expr {
            Var(v) =&amp;gt; self.find_scope(&amp;amp;v),
            e @ Str(_) |
            e @ Num(_) =&amp;gt; e
        }
    }

    fn print_expr(&amp;amp;self, expr: Expr) {
        use Expr::*;
        match self.eval(expr) {
            Str(ref s) =&amp;gt; print!(&amp;quot;{}&amp;quot;, s),
            Num(ref n) =&amp;gt; print!(&amp;quot;{}&amp;quot;, n),
            Var(_) =&amp;gt; panic!(&amp;quot;reference to unknown variable&amp;quot;) ,
        }
    }
}

fn main() {
    let ast = {
        use Stmt::*;
        use Expr::*;
        AST(
            vec![
                Subst(&amp;quot;x&amp;quot;.to_string(), Num(1)),
                Subst(&amp;quot;y&amp;quot;.to_string(), Num(2)),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Block(vec![
                    Subst(&amp;quot;x&amp;quot;.to_string(), Num(3)),
                    Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                    Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
                ]),
                Print(vec![Str(&amp;quot;--&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;x = &amp;quot;.to_string()), Var(&amp;quot;x&amp;quot;.to_string())]),
                Print(vec![Str(&amp;quot;y = &amp;quot;.to_string()), Var(&amp;quot;y&amp;quot;.to_string())]),
            ]
        )
    };
    let mut interpreter = Interpreter::new();

    interpreter.run(ast);
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Rustの所有権、ライフタイム、参照、型、しがらみ</title>
      <link>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</link>
      <pubDate>Wed, 14 Dec 2016 11:19:12 +0900</pubDate>
      
      <guid>/blog/2016/12/14/rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami</guid>
      <description>&lt;p&gt;κeenです。Rustには所有権やらライフタイムやら参照やらがあって型システムが面倒ですよね。線形（アフィン）と言われてるのに「あれ？」と思う部分もあるので詳しく探っていこうと思います。&lt;/p&gt;

&lt;p&gt;尚、この記事は型システムに興味のある人向けです。単にRustを書きたい方に有用な情報があるかは分かりません。&lt;/p&gt;

&lt;p&gt;2016-212-14T15:28Z09:00 加筆訂正しました。diffは&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/commit/f86c03a3793fde1787a9c0eb47f8efda305c2be4&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;線形型-アフィン型&#34;&gt;線形型？アフィン型？&lt;/h1&gt;

&lt;p&gt;はじめにこの辺をハッキりさせておきたいです。
アフィン型は線形型に弱化規則を許す型です。
プログラミング的に言えば線形型は &lt;code&gt;free&lt;/code&gt; しないと型エラーになるけどアフィン型はそうでない。
Rustはご存知の通り &lt;code&gt;free&lt;/code&gt; 相当のものを手で書くことはないのでアフィンな気がしますし、昔のドキュメントにもそう書いてました。&lt;/p&gt;

&lt;p&gt;しかし実際に実行されるプログラムではコンパイラが差し込んだ &lt;code&gt;free&lt;/code&gt; が実行されるので &lt;code&gt;free&lt;/code&gt; を省略出来るというシンタックスシュガーの類な気もします。&lt;/p&gt;

&lt;p&gt;ただまあ、 &lt;code&gt;free&lt;/code&gt; を差し込む位置を特定するのに弱化規則を使った場所で推論している筈なのでアフィンを使ってる筈ですよね。&lt;/p&gt;

&lt;p&gt;ってことで今回の記事はアフィン型で統一したいと思います。&lt;/p&gt;

&lt;h1 id=&#34;参照も値&#34;&gt;参照も値&lt;/h1&gt;

&lt;p&gt;なんとなく、構文が用意されているので参照自体特別な存在な気がしますが、そんなことはありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_any&amp;lt;T&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように任意の値を取れる関数を用意してあげます。
すると、以下のように所有、参照、可変参照全て渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let mut s = take_any(s);
take_any(&amp;amp;s);
take_any(&amp;amp;mut s);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;は-copy-mut-は違う&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; は違う&lt;/h1&gt;

&lt;p&gt;先と同じように &lt;code&gt;Copy&lt;/code&gt; を実装した型を受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_copy&amp;lt;T: Copy&amp;gt;(t: T) -&amp;gt; T {
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに参照を渡してあげると、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
take_copy(&amp;amp;s);
take_copy(&amp;amp;mut s); // error[E0277]: the trait bound `&amp;amp;mut std::string::String: std::marker::Copy` is not satisfied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、 &lt;code&gt;Copy&lt;/code&gt; なので普通に何度も使えます。線形型でいう &lt;code&gt;!&lt;/code&gt; に近いですね。違いますけど。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
let ref_s = &amp;amp;s;
let x: &amp;amp;String = ref_s;
let y: &amp;amp;String = ref_s;
// Copy(が要求するClone)に実装されているメソッドを陽に呼ぶ
let z: &amp;amp;String = (&amp;amp;ref_s).clone();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、 &lt;code&gt;Copy&lt;/code&gt; への参照は参照外しが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x: isize = 1;
let ref_x = &amp;amp;x;
let x: isize = *x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; は &lt;code&gt;&amp;amp;&lt;/code&gt; への参照（&lt;code&gt;Copy&lt;/code&gt;への参照）なので &lt;code&gt;&amp;amp;&lt;/code&gt; へ参照外しが可能ですが、 &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; は&lt;code&gt;&amp;amp;mut&lt;/code&gt;への参照（&lt;code&gt;Copy&lt;/code&gt;ではない値への参照）なので参照外し出来ません。&lt;code&gt;&amp;amp;mut&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;&amp;amp;mut&lt;/code&gt; とややこしいですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
// &amp;amp;&amp;amp;
{
    let ref_ref_s = &amp;amp;&amp;amp;s;
    let ref_s: &amp;amp;String = *ref_refs;
}
// &amp;amp;mut &amp;amp;
{
    let refmut_ref_s = &amp;amp;mut &amp;amp; s;
    let reft_s: &amp;amp;String = *s;
}

// &amp;amp;&amp;amp;mut
{
    let ref_refmut_s = &amp;amp;&amp;amp;mut s;
    let refmut_s: &amp;amp;mut String = *s; // error[E0389]: cannot borrow data mutably in a `&amp;amp;` reference
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;T&lt;/code&gt; が &lt;code&gt;&amp;amp;T&lt;/code&gt; に参照外し出来る理由も分かったかと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-は-deref&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; は &lt;code&gt;Deref&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; がたまに &lt;code&gt;&amp;amp;&lt;/code&gt; のように振る舞うことがありますが、これは &lt;code&gt;Deref&lt;/code&gt; のせいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::Deref;

let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
{
    // derefを陽に呼ぶ
    let ref_s: &amp;amp;string = refmut_s.deref();
}

{
    // 暗黙のDerefによる型強制
    let ref_s: &amp;amp;string = refmut_s;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rustは&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/deref-coercions.html&#34;&gt;&lt;code&gt;deref&lt;/code&gt; による型強制&lt;/a&gt;を行うため、無言で &lt;code&gt;&amp;amp;mut&lt;/code&gt; を &lt;code&gt;&amp;amp;&lt;/code&gt; に変換することが出来ます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、ここまでで &lt;code&gt;&amp;amp;&lt;/code&gt; や &lt;code&gt;&amp;amp;mut&lt;/code&gt; もただの値であること、アフィン型に反しないことを調べました。
次はライフタイムについて探ります。&lt;/p&gt;

&lt;h1 id=&#34;ライフタイムとサブタイピング&#34;&gt;ライフタイムとサブタイピング&lt;/h1&gt;

&lt;p&gt;実は、Rustにはサブタイピングがあります。ライフタイムです。ライフタイムにはサブタイプ関係があるのです。&lt;/p&gt;

&lt;p&gt;このように、2つの引数が厳密に同じライフタイムであることを要求する関数を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_ref&amp;lt;&#39;a&amp;gt;(_: &amp;amp;&#39;a String, _: &amp;amp;&#39;a String) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに、違うライフタイムを持つ型を放り込んでみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
    let a = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;a;
    {
        let b = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;b;
        take_two_ref(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはコンパイルが通ります。明示的にライフタイムを書くとこうです。これは有効な構文ではないです（余談ですがラベル付きbreak文のための構文と衝突します）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {
    let a: &#39;a String = &amp;quot;aaa&amp;quot;.to_string();
    let ref_a = &amp;amp;&#39;a a;
    &#39;b: {
        let b: &#39;b String = &amp;quot;bbb&amp;quot;.to_string();
        let ref_b = &amp;amp;&#39;b b;
        take_two_ref::&amp;lt;&#39;b&amp;gt;(ref_a, ref_b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大は小を兼ねるので &lt;code&gt;&#39;a&lt;/code&gt; は &lt;code&gt;&#39;b&lt;/code&gt; のサブタイプになっています。
ちょっと言葉がややこしいのですが、スコープが狭いライフタイムの方が大きい型です。狭い方が大きい。この言い回しに馴れてない人に説明すると、上の例でいえば &lt;code&gt;&#39;b&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; と &lt;code&gt;&#39;b&lt;/code&gt; 2つありますが、 &lt;code&gt;&#39;a&lt;/code&gt; を要求する部分に渡せるのは &lt;code&gt;&#39;a&lt;/code&gt; だけです。 2つと1つだったら2つの方が大きいですよね。&lt;/p&gt;

&lt;p&gt;さて、今回の例ではちゃんとスコープの入れ子とサブタイプ関係が一致していました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;&#39;a: {----------
              |
              |
    &#39;b: {--   |
          |   |
          |   |
          |   |
    }------   |
}--------------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参照を取るときは参照のライフタイムが元のライフタイムのサブタイプになっている必要があります。&lt;/p&gt;

&lt;p&gt;この関係に反するとエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();
    ref_s = &amp;amp;s; // error: `s` does not live long enough
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;図示するとこうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let ref_s: &amp;amp;String;
{
    let s = &amp;quot;foo&amp;quot;.to_string();-----
    ref_s = &amp;amp;s; ----------------  |
                               |  |
}------------------------------+---
                               |
--------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ライフタイムといえどある種、型なんですね。余談ですが確かリージョンの論文には「リージョンはプログラム全体を静的に伝播する型のようなもの」と表現していた気がします。既存の型と直行するので型とは別とも言えますし、タプルのように両方並べたものを型と言うことも出来ますね。&lt;/p&gt;

&lt;h1 id=&#34;所有型とライフタイムと-static&#34;&gt;所有型とライフタイムと &lt;code&gt;&#39;static&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;適切な語彙がなかったので勝手に所有型と名付けましたが、参照でない型のことを指しています。（先の例で見せた通り、参照型にも所有権はあるので適切ではないですがひとまず我慢して下さい。）&lt;/p&gt;

&lt;p&gt;さて、なんとなくライフタイムと参照型は結び付いている気がしますが、参照じゃない型にもライフタイムはあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_two_value&amp;lt;&#39;a, T: &#39;a, S: &#39;a&amp;gt;(_: T, _: S){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、任意の2つの型を取るけども両方ともにライフタイムを要求する関数を書いてみます。&lt;/p&gt;

&lt;p&gt;これに、所有型を渡すことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let t = &amp;quot;t&amp;quot;.to_string();
{
    let s = &amp;quot;s&amp;quot;.to_string();
    let s_ref = &amp;amp;s;
    take_two_value(t, s_ref);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、所有型にもライフタイムはあります（多分）。&lt;/p&gt;

&lt;p&gt;ところで、ライフタイムのボトム型相当のものに &lt;code&gt;&#39;static&lt;/code&gt; というものがあります。
グローバル変数やリテラルなどに割り当てられるライフタイムで、プログラムが死ぬまで生き続けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&#39;static&lt;/code&gt; のみを受け取る関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn take_static&amp;lt;T: &#39;static&amp;gt;(_: T){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、先の例に出たstaticな値達を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;static foo: &amp;amp;&#39;static isize = &amp;amp;3;
static bar: isize = 3;

fn main() {
    let x: &amp;amp;&#39;static str = &amp;quot;x&amp;quot;;
    let ref_bar: &amp;amp;&#39;static isize = &amp;amp;bar;
    take_static(foo);
    take_static(x);
    take_static(ref_bar);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は、これに所有型を渡せます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、任意の参照型は渡せません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
take_static(&amp;amp;s); // error: `s` does not live long enough
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで所有型には &lt;code&gt;&#39;static&lt;/code&gt; というライフタイムが付いているようです（？）。
&lt;code&gt;&#39;static&lt;/code&gt; イメージとしては「自分がその値を保持している限り無効になることはない型」ですかね。&lt;/p&gt;

&lt;p&gt;これに関連するTipsとして関数や構造体のジェネリクスで所有型しか受け取らないようにするには &lt;code&gt;&amp;lt;T: &#39;static&amp;gt;&lt;/code&gt; が使えます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さてさて、これまた参照型は特別扱いされることなく他のRustの値と同じようにライフタイムで管理されていることを調べました。&lt;/p&gt;

&lt;p&gt;最後に今回到達出来なかった謎、「参照を取る」について考えたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;mut-の規則&#34;&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt; の規則&lt;/h1&gt;

&lt;p&gt;みなさん御存じの通り、&lt;code&gt;&amp;amp;mut&lt;/code&gt; を取ると値への他の操作が許されなくなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut s = &amp;quot;foo&amp;quot;.to_string();
let refmut_s = &amp;amp;mut s;
let t = s;  // error[E0505]: cannot move out of `s` because it is borrowed
let ref_s = &amp;amp;s; // error[E0502]: cannot borrow `s` as immutable because it is also borrowed as mutable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;mut T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; が相互排他的なのでこれは線形論理のシーケント計算っぽく書くと以下のような規則を考えれば良さそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Γ, T:&#39;a |- Σ
-------------- &amp;amp;mut-intro
Γ, (&amp;amp;&#39;a mut T): &#39;b |- Σ
where &#39;a &amp;lt;: &#39;b

Γ, (&amp;amp;&#39;a mut T):&#39;b |- (&amp;amp;&#39;a mut T): &#39;b, Σ
----------------------- &amp;amp;mut-elim
Γ, T: &#39;a |- Σ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型付け規則の書き方になれてないのでシーケント計算で書きましたがサブタイプの記述で困りましたね。&lt;/p&gt;

&lt;h1 id=&#34;の謎&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; の謎&lt;/h1&gt;

&lt;p&gt;さて、問題は &lt;code&gt;&amp;amp;&lt;/code&gt; です。 &lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; なのでそこら中に生えてきます。
なので &lt;code&gt;&amp;amp;-elim&lt;/code&gt; のような規則では対応出来ません。&lt;/p&gt;

&lt;p&gt;ただ、ライフタイムによる制約があるので「参照のライフタイムが死ぬときに元の値が復活する」ような規則を考えたくなります。&lt;/p&gt;

&lt;p&gt;しかし、それでもだめです。複数回 &lt;code&gt;&amp;amp;&lt;/code&gt; を取れてしまうので、以下のように複数のライフタイムを持つ場合で破綻します。&lt;code&gt;&amp;amp; T&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; の間でなにかしらのしがらみがある筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s = &amp;quot;foo&amp;quot;.to_string();
{
    let ref_s1 = &amp;amp;s;
    {
        let ref_s2 = &amp;amp;s;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それに、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; と &lt;code&gt;&amp;amp;&lt;/code&gt; が相互排他であることも説明出来る規則でないといけません。謎が多い。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;さて、Rustの型システムのリソース管理回りを探ってみました。とりあえず分かったことを纏めると&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;値には全てアフィン型が付く

&lt;ul&gt;
&lt;li&gt;参照型も例外ではない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;値には全てライフタイムが付く

&lt;ul&gt;
&lt;li&gt;所有型も例外ではないっぽい&lt;/li&gt;
&lt;li&gt;もしかしたら所有型はライフタイムを無視している？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「参照を取る」のセマンティクスが謎

&lt;ul&gt;
&lt;li&gt;勿論、直感的には分かる&lt;/li&gt;
&lt;li&gt;どういう規則なんだろう&lt;/li&gt;
&lt;li&gt;アフィン型とライフタイム両方が絡むはず。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特に論文も読んでないのでちょっと遠回りだったかもしれません。
もしかしたら論文漁ったら一発で解決するのかも。
詳しい方、 &lt;code&gt;&amp;amp;&lt;/code&gt; の謎を教えて下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのstructとtraitって似てるよね</title>
      <link>/blog/2016/12/03/rustnostructtotraittteniteruyone</link>
      <pubDate>Sat, 03 Dec 2016 22:06:18 +0900</pubDate>
      
      <guid>/blog/2016/12/03/rustnostructtotraittteniteruyone</guid>
      <description>&lt;p&gt;κeenです。関連型について考えてたらtraitがstructに見えてきたので一筆。小ネタです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;structは普通の構造体とtupl structと言われる形式二種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Color {
  r: u8,
  g: u8,
  b: u8,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Color(u8, u8, u8);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;traitはというと関連型と型パラメータ二種類あります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Into {
  type Item;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Into&amp;lt;T&amp;gt;{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インスタンス化も似てます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// struct
struct Color {
  r: 255,
  g: 0,
  b: 0,
}

struct Color(255, 0, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// trait
struct Dummy;

impl Into for Dummy {
  type Item = i8
}

impl Into&amp;lt;i8&amp;gt; for Dummy {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、両者の使い分けも名前で参照したいかor手軽に使いたいかで使い分けます。&lt;/p&gt;

&lt;p&gt;以上小ネタでした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのプロセス</title>
      <link>/blog/2016/12/02/rustnopurosesu</link>
      <pubDate>Fri, 02 Dec 2016 17:52:30 +0900</pubDate>
      
      <guid>/blog/2016/12/02/rustnopurosesu</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;3日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。Rustの&lt;a href=&#34;https://doc.rust-lang.org/std/process/index.html&#34;&gt;&lt;code&gt;std::process&lt;/code&gt;&lt;/a&gt;の扱い方を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;ビルダー&#34;&gt;ビルダー&lt;/h1&gt;

&lt;p&gt;これはビルダーになっていて、以下のように使えます。公式ドキュメントの例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;sh&amp;quot;)
    .arg(&amp;quot;-c&amp;quot;)
    .arg(&amp;quot;echo hello&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境変数も渡せます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;sh&amp;quot;)
    .arg(&amp;quot;-c&amp;quot;)
    // 環境変数を参照するコマンド
    .arg(&amp;quot;echo $HELLO&amp;quot;)
    // 環境変数を設定する
    .env(&amp;quot;HELLO&amp;quot;, &amp;quot;hello, world&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;hello, world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは実行するディレクトリも指定出来ます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let output = Command::new(&amp;quot;ls&amp;quot;)
    // プロセスを実行するディレクトリを指定する
    .current_dir(&amp;quot;/&amp;quot;)
    .output()
    .expect(&amp;quot;failed to execute process&amp;quot;);

let hello = output.stdout;
println!(&amp;quot;{}&amp;quot;, std::str::from_utf8(&amp;amp;hello).unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
boot
cdrom
core
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;出力&#34;&gt;出力&lt;/h1&gt;

&lt;p&gt;上の例では &lt;code&gt;output&lt;/code&gt; でstdio,stderr, exitstatus取り出していますが、子プロセスとして実行することも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut child = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // outputではなくspawnを使う
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);
let status = child.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin  boot  cdrom  core  dev  etc  home  initrd.img  initrd.img.old  lib  lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  sys  tmp  usr  var  vmlinuz  vmlinuz.old
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、子プロセスはRustへではなく直接stdoutへ出力するのでSIGPIPEが送られません。&lt;/p&gt;

&lt;p&gt;あるいは出力先を手で指定することも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let child = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // stdoutをnullにする
    .stdout(Stdio::null())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);
let status = child.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではstdoutをnull ioに指定しています。他には&lt;code&gt;inherit&lt;/code&gt;で親プロセスのものを引き継ぐか、&lt;code&gt;piped&lt;/code&gt;で次のプロセスに渡すことも出来ます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// 1つめのプロセスを作る
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // 出力は親プロセスへパイプする
    .stdout(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);

// 2つめのプロセスを作る
let mut child2 = Command::new(&amp;quot;grep&amp;quot;)
    .arg(&amp;quot;bin&amp;quot;)
    // 入力は親プロセスへパイプする
    .stdin(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to execute process&amp;quot;);

{
    // Someと分かっているのでunwrapする。
    // この辺はrustの型システテムの限界。
    let out = child1.stdout.as_mut().unwrap();
    let in_ = child2.stdin.as_mut().unwrap();
    // 1つめのプロセスの出力から2つめのプロセスの入力へデータをコピーする
    io::copy(out, in_).unwrap();
}


let status1 = child1.wait().unwrap();
let status2 = child2.wait().unwrap();
println!(&amp;quot;{}, {}&amp;quot;, status1, status2);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
sbin
exit code: 0, exit code: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと繋ぎ込みが面倒ですし&lt;code&gt;io::copy&lt;/code&gt;を使って手でコピーしてるのが頂けませんね。&lt;/p&gt;

&lt;h1 id=&#34;unix&#34;&gt;Unix&lt;/h1&gt;

&lt;p&gt;Unixに依存することを認めてしまえばもうちょっと色々なことが出来ます。&lt;/p&gt;

&lt;p&gt;1つには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::process::CommandExt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するといくつか追加のメソドが生えてくる仕組みになってます。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;exec&lt;/code&gt; が使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let error = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // execを呼ぶ
    .exec();

println!(&amp;quot;after exec!!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;した後はRustのプロセスを別のものに置き換えてしまうので&lt;code&gt;println!(&amp;quot;after exec!!&amp;quot;);&lt;/code&gt;の行が実行されません。
されるとしたら何らかの理由で&lt;code&gt;exec&lt;/code&gt;に失敗した場合だけです。なので面白いことに&lt;code&gt;exec&lt;/code&gt;の返り値はエラーのみです。&lt;/p&gt;

&lt;p&gt;あるいは、&lt;code&gt;unsafe&lt;/code&gt;なコードを認めるなら先のプロセスの繋ぎ込みはもうちょっとスマートに書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::io::{AsRawFd, FromRawFd};
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    // 標準出力をパイプする
    .stdout(Stdio::piped())
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

let mut child2 = Command::new(&amp;quot;grep&amp;quot;)
    .arg(&amp;quot;bin&amp;quot;)
    // 標準入力は手で作ったStdioオブジェクトにする。
    // ここでは1つめのプロセスの標準出力を直接繋ぐ。
    .stdin(unsafe{Stdio::from_raw_fd(child1.stdout.as_ref().unwrap().as_raw_fd())})
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

// 直接繋いでしまったのでコピーの必要はない

let status1 = child1.wait().unwrap();
let status2 = child2.wait().unwrap();
println!(&amp;quot;{}, {}&amp;quot;, status1, status2);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bin
sbin
exit code: 0, exit code: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Stdio&lt;/code&gt;がfdと行き来出来るのでそれを経由することでパイプを作れます。&lt;/p&gt;

&lt;p&gt;もちろん、ファイルに書き出すことも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::unix::io::{AsRawFd, FromRawFd};

let file = File::create(&amp;quot;test.txt&amp;quot;).unwrap();
// ファイルからFDを経由してStdioを作る
let out = unsafe{Stdio::from_raw_fd(file.as_raw_fd())};
let mut child1 = Command::new(&amp;quot;ls&amp;quot;)
    .current_dir(&amp;quot;/&amp;quot;)
    .stdout(out)
    .spawn()
    .expect(&amp;quot;failed to spawn a process&amp;quot;);

let status1 = child1.wait().unwrap();
println!(&amp;quot;{}&amp;quot;, status1);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat test.txt
bin
boot
cdrom
core
dev
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;最初は思ったよりCのプロセス回りのAPIと違って戸惑いますが馴れてしまえば使いやすいAPIでしょう。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>新しいコンパイラバックエンドcretonne</title>
      <link>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</link>
      <pubDate>Fri, 02 Dec 2016 14:00:11 +0900</pubDate>
      
      <guid>/blog/2016/12/02/atarashiikonpairabakkuendocretonne</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/lang_dev&#34;&gt;言語実装 Advent Calendar 2016 - Qiita&lt;/a&gt;3日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。先日、Rustの開発者フォーラムに新しいバックエンドして&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;cretonne&lt;/a&gt;が&lt;a href=&#34;https://internals.rust-lang.org/t/possible-alternative-compiler-backend-cretonne/4275&#34;&gt;提案されていました&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ちょっと気になったのでそれを紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;概略&#34;&gt;概略&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/stoklund/cretonne&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/index.html&#34;&gt;ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;フォーラムによると、WebAssemblyをエンコードするために作られたコンパイラバックエンドで、FirefoxのJSエンジンであるSpiderMonkeyに載せる予定だそうです。JITが主な目的？&lt;/p&gt;

&lt;p&gt;LLVMのように最適化を頑張る方ではなくてコードを吐くまでのレイテンシを気にして作られているとのこと。なのでcretonne自身は最適化を行いません。&lt;/p&gt;

&lt;p&gt;特徴はドキュメントの&lt;a href=&#34;http://cretonne.readthedocs.io/en/latest/compare-llvm.html&#34;&gt;LLVMとの比較&lt;/a&gt;によくまとまってますが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LLVMは複数種類の中間言語を持つのに対してcretonneは1種類&lt;/li&gt;
&lt;li&gt;アセンブラもディスアセンブラもない

&lt;ul&gt;
&lt;li&gt;コードジェネレータが吐く命令だけサポート&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中間言語はISA非依存で、legalization / instruction selectionをするとISA固有のアノテーションが付く&lt;/li&gt;
&lt;li&gt;最大抽象単位が関数(LLVMはモジュール)。cretonneは関数のインライン化とかもしない。&lt;/li&gt;
&lt;li&gt;Extended Basic Blockを使う(LLVMはBasic Block)。

&lt;ul&gt;
&lt;li&gt;ebbは分岐命令のfalse branchを指定せず、fall throughする。よくあるマシン語に近い。&lt;/li&gt;
&lt;li&gt;分岐の合流はebbに引数を持たせることで行う(LLVMはphi nodeを使う)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;undefined behaviorが存在しない&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なんとなくWebAssemblyを意識した仕様ですね。&lt;/p&gt;

&lt;h1 id=&#34;雰囲気&#34;&gt;雰囲気&lt;/h1&gt;

&lt;p&gt;以下のCのコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;float
average(const float *array, size_t count)
{
    double sum = 0;
    for (size_t i = 0; i &amp;lt; count; i++)
        sum += array[i];
    return sum / count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のcretonneのIRに落ちるそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss1 = stack_slot 8, align 4   ; Stack slot for ``sum``.

ebb1(v1: i32, v2: i32):
    v3 = f64const 0x0.0
    stack_store v3, ss1
    brz v2, ebb3                  ; Handle count == 0.
    v4 = iconst.i32 0
    br ebb2(v4)

ebb2(v5: i32):
    v6 = imul_imm v5, 4
    v7 = iadd v1, v6
    v8 = heap_load.f32 v7         ; array[i]
    v9 = fext.f64 v8
    v10 = stack_load.f64 ss1
    v11 = fadd v9, v10
    stack_store v11, ss1
    v12 = iadd_imm v5, 1
    v13 = icmp ult v12, v2
    brnz v13, ebb2(v12)           ; Loop backedge.
    v14 = stack_load.f64 ss1
    v15 = cvt_utof.f64 v2
    v16 = fdiv v14, v15
    v17 = ftrunc.f32 v16
    return v17

ebb3:
    v100 = f32const qNaN
    return v100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ、実際はファイルヘッダとかも付きますがこんな感じです。&lt;/p&gt;

&lt;p&gt;ebbに引数があったりebbの途中で平気でブランチしてたり中々やんちゃですね。&lt;/p&gt;

&lt;h1 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h1&gt;

&lt;p&gt;コードを吐くところまでやりたかったのですがまだ絶賛開発中ということもあってそのような操作が見当りませんでした。&lt;/p&gt;

&lt;p&gt;ということでファイルの方を扱ってると面白みがないのでRust APIの方で関数を構築して正当性を検証してから中間言語を吐き出してみます。&lt;/p&gt;

&lt;h2 id=&#34;一歩&#34;&gt;一歩&lt;/h2&gt;

&lt;p&gt;まずはcretonneをcloneしてきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new cretonne-sample --bin
$ cd cretonne-sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んでCargo.tomlのdependenciesに&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cretonne = {path = &amp;quot;path/cretonne/lib/cretonne/&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加します。どうやらトップレベルのプロジェクトはただのユーティリティのようでした。本体は&lt;code&gt;lib/cretonne/&lt;/code&gt;以下にいます。&lt;/p&gt;

&lt;p&gt;そしてmainファイルの中身はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate cretonne;
use cretonne::ir::*;
use cretonne::ir::{types as ty};
use cretonne::ir::{immediates as imm};
use cretonne::isa;
use cretonne::settings::{self, Configurable};
use cretonne::{write_function, legalize_function, verify_function};

fn main() {
    let mut func = {
        let name = FunctionName::new(&amp;quot;average&amp;quot;);
        let mut sig = Signature::new();
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.argument_types.push(ArgumentType::new(ty::I32));
        sig.return_types.push(ArgumentType::new(ty::F32));
        Function::with_name_signature(name, sig)
    };

    let isa = {
        let mut b = settings::builder();
        b.set(&amp;quot;opt_level&amp;quot;, &amp;quot;fastest&amp;quot;).unwrap();
        let f = settings::Flags::new(&amp;amp;b);
        let builder = isa::lookup(&amp;quot;intel&amp;quot;).unwrap();
        builder.finish(f)
    };
    verify_function(&amp;amp;func).unwrap();
    legalize_function(&amp;amp;mut func, isa.as_ref());
    let mut o = String::new();
    write_function(&amp;amp;mut o, &amp;amp;func, Some(isa.as_ref())).unwrap();
    println!(&amp;quot;{}&amp;quot;, o);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;function average(i32, i32) -&amp;gt; f32 {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おおまかには&lt;code&gt;func&lt;/code&gt;を構築して&lt;code&gt;isa&lt;/code&gt;を決めて&lt;code&gt;verify_function&lt;/code&gt;で検証、さらに&lt;code&gt;legalize_function&lt;/code&gt;で今回のアーキテクチャ向けに微調整、&lt;code&gt;write_function&lt;/code&gt;で書き出しです。&lt;/p&gt;

&lt;h2 id=&#34;スタックスロットの追加&#34;&gt;スタックスロットの追加&lt;/h2&gt;

&lt;p&gt;まあ、スタック領域ですね。8byteの領域を確保します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;にstack_slotsフィールドがあるのでそこにpushします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;push&lt;/code&gt;の返り値はスタック領域を指すキーです。&lt;/p&gt;

&lt;h2 id=&#34;ebbの追加&#34;&gt;EBBの追加&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;func&lt;/code&gt;構造体のフィールドに&lt;code&gt;dfg&lt;/code&gt;がいて、そいつを色々いじります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let mut func = {
        ....
    };


    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let ebb0 = func.dfg.make_ebb();
        let v1 = func.dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = func.dfg.append_ebb_arg(ebb0, types::I32);

        cur.insert_ebb(ebb0);
    }

    let isa = {
        ....
    };
    ....
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

ebb0(vx0: i32, vx1: i32):
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EBBの追加にはカーソルを決めてあげて、dfgにebbを作ってあげて、カーソルの位置にebbの追加という形になります。&lt;/p&gt;

&lt;p&gt;EBBには任意に引数を追加出来ます。&lt;code&gt;append_ebb_arg&lt;/code&gt;の返り値はSSAの変数です。&lt;/p&gt;

&lt;h2 id=&#34;命令を追加する&#34;&gt;命令を追加する&lt;/h2&gt;

&lt;p&gt;命令はpythonのスクリプトによって生成されるので補完が効かず、中々扱いづらいですが頑張ります。&lt;/p&gt;

&lt;p&gt;さて、今回コードの検証を入れているので以下のようなコードは検証に落ちてしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);

        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Error { location: Ebb(Ebb(0)), message: &amp;quot;block does not end in a terminator instruction!&amp;quot; }&#39;, ../src/libcore/result.rs:799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の命令が定数であるため、正常なブロックと見做されないのです。&lt;/p&gt;

&lt;p&gt;ひとまずv3を返すことで凌ぎます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    ....
    {
        ....
        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);
    }
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     return v0
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令の頭に付いてる &lt;code&gt;[-]&lt;/code&gt;はlegalizeすると付くようです。&lt;/p&gt;

&lt;h2 id=&#34;ブランチ&#34;&gt;ブランチ&lt;/h2&gt;

&lt;p&gt;もう1つebbを追加してあげる必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    {
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;
        let ebb0 = dfg.make_ebb();
        let ebb3 = dfg.make_ebb();  // &amp;lt;- ebb3を作成
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);
        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new()); // &amp;lt;-ebb3にジャンプ

        let mut varg = VariableArgs::new();
        varg.push(v3);
        let _ = dfg.ins(cur).return_(varg);

        cur.insert_ebb(ebb3); // &amp;lt;- ebb3を追加
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function average(i32, i32) -&amp;gt; f32 {
    ss0 = stack_slot 8

                    ebb0(vx0: i32, vx1: i32):
[-]                     v0 = f64const 0.0
[-]                     brz vx1, ebb1
[-]                     return v0

                    ebb1:
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;残り&#34;&gt;残り&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
        let k = func.stack_slots.push(StackSlotData::new(8));
        let cur = &amp;amp;mut Cursor::new(&amp;amp;mut func.layout);
        let dfg = &amp;amp;mut func.dfg;

        let ebb0 = dfg.make_ebb();
        let v1 = dfg.append_ebb_arg(ebb0, types::I32);
        let v2 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb2 =  dfg.make_ebb();
        let v5 = dfg.append_ebb_arg(ebb0, types::I32);

        let ebb3 = dfg.make_ebb();

        cur.insert_ebb(ebb0);
        let v3 = dfg.ins(cur).f64const(imm::Ieee64::new(0.0));
        dfg.ins(cur).brz(v2, ebb3, VariableArgs::new());
        let v4 = dfg.ins(cur).iconst(types::I32, 0);
        let mut ebb2_arg = VariableArgs::new();
        ebb2_arg.push(v4);
        dfg.ins(cur).jump(ebb2, ebb2_arg);

        cur.insert_ebb(ebb2);
        let v6 = dfg.ins(cur).imul_imm(v5, 4);
        let v7 = dfg.ins(cur).iadd(v1, v6);
        dfg.ins(cur).jump(ebb3, VariableArgs::new());

        cur.insert_ebb(ebb3);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで進めていこうと思いましたがどうやらまだstack/heapを触る命令がない？？ようなので詰みました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;コンパイラバックエンドcretonneについて紹介しました&lt;/li&gt;
&lt;li&gt;cretonneのRust APIを触ってみましたがダメでした。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rustでバイト列を扱う時のtips</title>
      <link>/blog/2016/12/01/rustdebaitoretsuwoatsukautokinotips</link>
      <pubDate>Thu, 01 Dec 2016 14:29:33 +0900</pubDate>
      
      <guid>/blog/2016/12/01/rustdebaitoretsuwoatsukautokinotips</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2016/rust-lang-2&#34;&gt;Rust その2 Advent Calendar 2016 - Qiita&lt;/a&gt;2日目の記事です。&lt;/p&gt;

&lt;p&gt;Rustはシステムプログラミング言語なのでバイト列をあれこれしたいことがあると思います。その時にイテレータでバイト列を舐める以外にも色々方法があるなと気付いたので。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;read-と-write&#34;&gt;&lt;code&gt;Read&lt;/code&gt; と &lt;code&gt;Write&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;私には割と衝撃だったのですが&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;や&lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt;、&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;は直接&lt;code&gt;Read&lt;/code&gt;や&lt;code&gt;Write&lt;/code&gt;のインスタンスになってます。
例えば&lt;code&gt;Read&lt;/code&gt;ならこういう風に使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes: &amp;amp;[u8] = &amp;amp;[1, 2, 3, 4, 5, 6];
let mut buf = [0;3];
bytes.read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;read: [1, 2, 3], rest: [4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは &lt;code&gt;.bytes()&lt;/code&gt;でbyteのイテレータを取り出してもいいですし、如何様にも扱えます。&lt;/p&gt;

&lt;p&gt;少し注意が必要なのは&lt;code&gt;Vec&lt;/code&gt;は &lt;code&gt;Read&lt;/code&gt; を実装してないので一旦スライスに変換してあげる必要がありますが、やり方を工夫する必要があります。&lt;/p&gt;

&lt;p&gt;以下は少しびっくりする例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = vec![1, 2, 3, 4, 5, 6];
let mut buf = [0;3];
(&amp;amp;bytes[..]).read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;read: [1, 2, 3], rest: [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦スライスを取り出してその場で捨てているので&lt;code&gt;bytes&lt;/code&gt;は消費されません。&lt;/p&gt;

&lt;p&gt;そうやりたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = vec![1, 2, 3, 4, 5, 6];
let mut bytes = &amp;amp;bytes[..];
let mut buf = [0;3];
bytes.read_exact(&amp;amp;mut buf).unwrap();
println!(&amp;quot;read: {:?}, rest: {:?}&amp;quot;, buf, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように一旦スライスを束縛してから使います。&lt;/p&gt;

&lt;p&gt;Writeの方も似ていて、そのまま&lt;code&gt;write&lt;/code&gt;出来ますし、消費されます。ただ、書き込み領域が空になってもそのままスルーされるので注意です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mut bytes: &amp;amp;mut [u8] = &amp;amp;mut [0; 6];
let data = &amp;amp;[1, 2, 3];
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;data: [1, 2, 3], buf: [0, 0, 0, 0, 0, 0]
data: [1, 2, 3], buf: [0, 0, 0]
data: [1, 2, 3], buf: []
data: [1, 2, 3], buf: []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後、バッファが空になった状態で書き込んでも無言で書き込みが終了しています。そして書き込んだデータへのアクセスは出来てないですね。&lt;/p&gt;

&lt;p&gt;こうすると出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes:[u8; 6] =  [0; 6];
let data = &amp;amp;[1, 2, 3];
{
    let mut buf: &amp;amp;mut [u8] = &amp;amp;mut bytes;
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
    buf.write(data).unwrap();
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
    buf.write(data).unwrap();
    println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, buf);
}
println!(&amp;quot;bytes: {:?}&amp;quot;, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [1, 2, 3], buf: [0, 0, 0, 0, 0, 0]
data: [1, 2, 3], buf: [0, 0, 0]
data: [1, 2, 3], buf: []
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあ面倒ですね。というかそもそも固定長のバッファに書き込みたいという需要が少ない。&lt;/p&gt;

&lt;p&gt;でもこれは&lt;code&gt;Vec&lt;/code&gt;を使えば解決します。可変長ですし&lt;code&gt;Write&lt;/code&gt; も実装しているので便利です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut bytes: Vec&amp;lt;u8&amp;gt; = Vec::new();
let data = &amp;amp;[1, 2, 3];
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
bytes.write(data).unwrap();
println!(&amp;quot;data: {:?}, buf: {:?}&amp;quot;, data, bytes);
println!(&amp;quot;bytes: {:?}&amp;quot;, bytes);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [1, 2, 3], buf: []
data: [1, 2, 3], buf: [1, 2, 3]
data: [1, 2, 3], buf: [1, 2, 3, 1, 2, 3]
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cursor&#34;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;さて、上で見た通り、なんとなく生のバイト列だと扱いづらそうな場面がありそうですよね。
そこで &lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/struct.Cursor.html&#34;&gt;&lt;code&gt;std::io::Cursor&lt;/code&gt;&lt;/a&gt;を使うと便利です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Cursor&lt;/code&gt;はコンストラクタで引数の所有権を奪うタイプの、ラッパーオブジェクト的構造体です。&lt;/p&gt;

&lt;p&gt;readだとこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: &amp;amp;[u8] = &amp;amp;[1,2,3,4,5,6];
let data: &amp;amp;mut [u8] = &amp;amp;mut [0;3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
cur.read_exact(data).unwrap();
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
cur.read_exact(data).unwrap();
println!(&amp;quot;data: {:?}, position {}&amp;quot;, data, cur.position());
println!(&amp;quot;bytes: {:?}&amp;quot;, cur.into_inner());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;data: [0, 0, 0], position 0
data: [1, 2, 3], position 3
data: [4, 5, 6], position 6
bytes: [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポジションが取れるのと元のオブジェクトが無事なのが違いますね。&lt;/p&gt;

&lt;p&gt;Writeも同様です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: &amp;amp;mut [u8] = &amp;amp;mut [0;6];
let data: &amp;amp;[u8] = &amp;amp;[1, 2, 3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
println!(&amp;quot;bytes: {:?}&amp;quot;, cur.into_inner());
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;data: [0, 0, 0, 0, 0, 0], position 0
data: [1, 2, 3, 0, 0, 0], position 3
data: [1, 2, 3, 1, 2, 3], position 6
bytes: [1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この&lt;code&gt;Cursor&lt;/code&gt;の面白いのは&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;でなく&lt;code&gt;AsRef&amp;lt;[u8]&amp;gt;&lt;/code&gt;で&lt;code&gt;Read&lt;/code&gt;を実装していますし&lt;code&gt;std::io::Seek&lt;/code&gt;も実装しているのでこういうことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let bytes: Vec&amp;lt;u8&amp;gt; = Vec::new();
let data: &amp;amp;[u8] = &amp;amp;[1, 2, 3];
let buf: &amp;amp;mut [u8] = &amp;amp;mut [0; 3];
let mut cur = Cursor::new(bytes);
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.write(data).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.seek(SeekFrom::Start(0)).unwrap();
println!(&amp;quot;bytes: {:?}, position {}&amp;quot;, cur.get_ref(), cur.position());
cur.read(buf).unwrap();
println!(&amp;quot;bytes: {:?}, position {}, buf: {:?}&amp;quot;, cur.get_ref(), cur.position(), buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bytes: [], position 0
bytes: [1, 2, 3], position 3
bytes: [1, 2, 3, 1, 2, 3], position 6
bytes: [1, 2, 3, 1, 2, 3], position 0  // &amp;lt;- 0にシークした
bytes: [1, 2, 3, 1, 2, 3], position 3, buf: [1, 2, 3] // &amp;lt;- 0からリード出来てる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生の&lt;code&gt;Vec&lt;/code&gt;では出来なかったread and writeが実現出来ています。そして好きにカーソルをシーク出来ます。
ここまでくるとほとんどファイルと変わらなく扱えますね。&lt;/p&gt;

&lt;h1 id=&#34;おりに&#34;&gt;おりに&lt;/h1&gt;

&lt;p&gt;ちょっとしたTipsですが道具箱にこういうのを増やしておくと便利ですよね！！&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Read.html&#34;&gt;std::io::Read - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Write.html&#34;&gt;std::io::Write - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/struct.Cursor.html&#34;&gt;std::io::Cursor - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/trait.Seek.html&#34;&gt;std::io::Seek - Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/stable/std/io/enum.SeekFrom.html&#34;&gt;std::io::SeekFrom - Rust&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>