<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 02 Jul 2017 12:31:07 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ステートマシン抽象化としてのFuture</title>
      <link>/blog/2017/07/02/sute_tomashinchuushoukatoshitenofuture</link>
      <pubDate>Sun, 02 Jul 2017 12:31:07 +0900</pubDate>
      
      <guid>/blog/2017/07/02/sute_tomashinchuushoukatoshitenofuture</guid>
      <description>&lt;p&gt;κeenです。最近Futureと一口にいってもいくつか種類があるなと気付いたのでRustの&lt;a href=&#34;https://github.com/alexcrichton/futures-rs&#34;&gt;&lt;code&gt;futures-rs&lt;/code&gt;&lt;/a&gt;に実装されているFutureの挙動を紐解こうと思います。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;イベント駆動io&#34;&gt;イベント駆動IO&lt;/h1&gt;

&lt;p&gt;TCPサーバをノンブロッキングに書こうとすると、思いの他大変です。
ブロックせずにIOできるタイミングまで処理を溜めておいて、できるときに読み書きします。ブロックしないタイミングをみつけるのも一苦労なので大抵ライブラリに頼ってライブラリからイベントを通知してもらいます。Rustには&lt;a href=&#34;https://github.com/carllerche/mio&#34;&gt;mio&lt;/a&gt;というライブラリがあります。&lt;/p&gt;

&lt;p&gt;さて、これイベントの発見は書かなくてよくなりましたが、まだつらいです。リクエストがないのにレスポンスを返せる訳もないので処理とイベントに依存関係があって、「read readyイベントでデータを読み取って、足りれば処理開始、足りなければまだ読み取る。処理が終わればwrite readyイベントを待って書き込み。その後は次のリクエストに備えてread readyイベント待ち」などの複雑な条件分岐と処理をしなければなりません。しかもクライアントは1つじゃないのでそれらを複数管理しないといけません。やりきれませんね。私が昔書いた&lt;a href=&#34;https://github.com/KeenS/chat/blob/master/src/handler.rs#L32&#34;&gt;Websocketのechoサーバ&lt;/a&gt;を少し見ると大変そうなことが伝わると思います。（余談ですが、つらそうなコードを書いたのは抽象化ライブラリに頼らないコードを実感するためでした）&lt;/p&gt;

&lt;h1 id=&#34;ステートマシン&#34;&gt;ステートマシン&lt;/h1&gt;

&lt;p&gt;先程の複雑な条件分岐の例は、「ステート」があることに気付きます。「リクエストがまだ来てない」「リクエストの一部が届いたけど全部でない」「リクエストの処理中」「レスポンスの送信待ち」など。これを明確に「ステート」としてプログラムを書いてあげると綺麗に書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[リクエストがまだ来てない]&amp;lt;----------------+
  | read ready                            |
  +------------------------------------+  |
  |                                    |  |
[リクエストの一部がきたが全部でない]&amp;lt;-+  |  |
  | read ready                      |  |  |
  +---------------------------------+  |  |
  |                                    |  |
[リクエストの処理中]&amp;lt;-------------------+  |
  |                                       |
[レスポンスの書き出し待ち]                 |
  | write ready                           |
[レスポンスの書き出し完了]-----------------+

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、このステートマシンを図に書く範囲では明瞭なのですが、実際のプログラムに落とすとやや見通しが悪いです。&lt;/p&gt;

&lt;p&gt;ナイーブな実装を疑似コードで書くとこうなるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum State = リクエストがまだ来てない
           | リクエストの一部がきたが全部でない
           | リクエストの処理中
           | レスポンスの書き出し待ち
           | レスポンスの書き出し完了

event arrived
  case (state, event)
    when (リクエストがまだ来てない, read ready)
      ...
      if request is complete
        state &amp;lt;- リクエストの処理中
        wait for write ready
      else
        state &amp;lt;- リクエストの一部がきたが全部でない
        wait for read ready
    when リクエストの一部がきたが全部でない
      ...
      if request is complete
        state &amp;lt;- リクエストの処理中
        wait for write ready
      else
        state &amp;lt;- リクエストの一部がきたが全部でない
        wait for read ready
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モデリングは上手くいっているものの実際のコードに落とすとみづらいですね。
ナイーブな実装方法の他に、デザインパターンのステートパターンを使う手もあります。まあ、そのまんまですね。
疑似コードにするとこうなるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;abstract class State
  method do returns (State, Event)

class リクエストがまだ来てないState
  method do returns (State, Event)
      ...
      if request is complete
        return (new リクエストの処理中State, write ready)
      else
        return (new リクエストの一部がきたが全部でないState, read ready)

class リクエストの一部がきたが全部でない
  method do returns (State, Event)
      ...
      if request is complete
        return (new リクエストの処理中State, write ready)
      else
        return (new リクエストの一部がきたが全部でないState, read ready)

event arrived
  if event equals waiting_event
    (next_state, waiting_event) &amp;lt;- state.do()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ステートと処理のかたまりで分離することができたのでコードの見通しもよくなりました。&lt;/p&gt;

&lt;p&gt;しかし、Rust的にはまだ問題があります。Stateのサブクラスでモデリングしてますが、それだとメソッドのディスパッチが動的ディスパッチになってしまって遅いです。Zero-cost abstractionできてません。&lt;/p&gt;

&lt;p&gt;もう1つ問題があって、これでもまだ直感的なコードとはかけ離れてます。本来ならこういうコードを書きたい筈です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request &amp;lt;- empty
until request is complete
  request &amp;lt;&amp;lt; input
response &amp;lt;- // do something with request
output &amp;lt;&amp;lt; response
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをどうにかできないでしょうか。&lt;/p&gt;

&lt;h1 id=&#34;future&#34;&gt;Future&lt;/h1&gt;

&lt;p&gt;そこでfutures-rsです。ゼロコストでステートマシンを抽象化してくれます。&lt;a href=&#34;https://aturon.github.io/blog/2016/08/11/futures/&#34;&gt;Zero-cost futures in Rust · Aaron Turon&lt;/a&gt;を読んだことのある人も多いでしょう。&lt;/p&gt;

&lt;p&gt;基本的なアイディアは、1つのステートとその時の処理を表わす&lt;code&gt;Future&lt;/code&gt;の他にステート同士を繋げるコンビネータを用意することで柔軟にプログラムを書けるようにするということです。そしてステートの処理関数が静的ディスパッチされるようにコンビネータを工夫する（基本的には型パラメータに情報を残して静的ディスパッチできるようにする）ことでゼロコスト抽象化を実現しています。&lt;/p&gt;

&lt;p&gt;先程のコードをfuturesを使って書くとこのような雰囲気になるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let f = loop_fn(Vec::new(), |mut buff| {
    input.read()
      .and_then(|data| {
        buff.append(data);
        match Request::parse(buff) {
          Ok(request) =&amp;gt; Ok(Loop::Break(request))
          Err(_) =&amp;gt; Ok(Loop::Continue((buff)))
        }
      })
  }).and_then(|request| {
    // do something with request
  }).and_then(|response| {
    output.write(response)
  });

run(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ダイレクトなコードに比べるとまだノイズが多いですが、ステートマシンを陽に作るコードよりは直感的になったと思います。&lt;/p&gt;

&lt;h1 id=&#34;他のfutureとの違い&#34;&gt;他のFutureとの違い&lt;/h1&gt;

&lt;p&gt;futuers-rsのFutureは1イベント起きる度に(&lt;a href=&#34;https://docs.rs/futures/0.1.14/futures/future/trait.Future.html#tymethod.poll&#34;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;が呼ばれてReadyになる度に)次のステートの処理をし、その次のステートに移るという流れが基本です。
次のステートに移っても、即座にそののステートの処理が走る訳ではありません。次に&lt;code&gt;poll&lt;/code&gt;が呼ばれるまで処理をしません。つまりマルチスレッドの文脈で語ると、イベントが発火したスレッド &lt;em&gt;ではなく&lt;/em&gt; &lt;code&gt;poll&lt;/code&gt;を呼んだスレッド、おおむね &lt;strong&gt;Futureを所有しているスレッドで処理が走ります&lt;/strong&gt; 。Futureの処理がスレッドを飛び越えたりはしません。ある1つのFutureを別スレッドで計算したければ&lt;a href=&#34;https://github.com/alexcrichton/futures-rs/tree/master/futures-cpupool&#34;&gt;CPU Pool&lt;/a&gt;などが使えますが、その後（&lt;a href=&#34;https://docs.rs/futures-cpupool/0.1.5/futures_cpupool/struct.CpuPool.html#method.spawn&#34;&gt;spawn&lt;/a&gt;の返り値の新たなFuture）に続けた処理は今のスレッドで実行されます。&lt;/p&gt;

&lt;p&gt;一方他のFutureはほぼマルチスレッドと密結合したプロミスのようになっていて、&lt;/p&gt;

&lt;p&gt;1 Future = 別スレッドで実行される計算への先物。
コンビネータ(callback) = 別スレッドで実行される計算が終わったあとに同じスレッドで実行されるべき計算&lt;/p&gt;

&lt;p&gt;のようなものが多い印象です。要は1つ処理が終わるとそのまま次の処理、その次の処理と自動で発火していく。もちろん、ライブラリの作りによってスレッドとの関係性などにバリエーションはあるでしょうが、Rustのように&lt;a href=&#34;https://docs.rs/futures/0.1.14/futures/future/trait.Future.html#tymethod.poll&#34;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;を基本とした設計はあまりみません。&lt;/p&gt;

&lt;p&gt;このようにFutureにも色々あるうち、Rustでメジャーに使われているfutures-rsの&lt;code&gt;Future&lt;/code&gt;はステートマシンの抽象化になっているよ、というお話でした。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ジェネリクス勉強会補足</title>
      <link>/blog/2017/06/24/jienerikusubenkyoukaihosoku</link>
      <pubDate>Sat, 24 Jun 2017 23:22:16 +0900</pubDate>
      
      <guid>/blog/2017/06/24/jienerikusubenkyoukaihosoku</guid>
      <description>&lt;p&gt;κeenです。本日&lt;a href=&#34;https://connpass.com/event/56773/?utm_campaign=event_participate_to_owner&amp;amp;utm_source=notifications&amp;amp;utm_medium=email&amp;amp;utm_content=title_link&#34;&gt;ジェネリクス勉強会&lt;/a&gt;で発表したのですがいくつか拾いきれないコメントがあったのでここでお返事書きます&lt;/p&gt;

&lt;p&gt;発表スライドは&lt;a href=&#34;https://keens.github.io/slide/jienerikusu_disupatchi_omoteura/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;ジェネリクスの実装はポインタ方式とテンプレート方式だけじゃないよ&#34;&gt;ジェネリクスの実装はポインタ方式とテンプレート方式だけじゃないよ&lt;/h1&gt;

&lt;p&gt;もちろんです。
基本的な手法を大別しただけで、私の発表中にもポインタ方式でも最適化がありえるとの指摘がありましたし、ジェネリクス勉強会中でも.NETの実装の話も出てました。
勉強会全体を見ているならここで私がフォローするまでもないかと思いますが、念のため拾っておきます。&lt;/p&gt;

&lt;h1 id=&#34;クロージャの件が分からない&#34;&gt;クロージャの件が分からない&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;クロージャの型は関数型じゃないの？&lt;/li&gt;
&lt;li&gt;無名関数は関数に名前がないだけで型はあるんじゃないの？&lt;/li&gt;
&lt;li&gt;なんで(Iteratorのmapとかの)返り値に関数型がでてくるの&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rustの挙動を知らないとちょっと分かりづらかったですね。それとあとで見返したら私も発表中一箇所嘘いってました。
詳しいことをコード例を出しながら説明していきます&lt;/p&gt;

&lt;h2 id=&#34;rustのクロージャの型は匿名化された型&#34;&gt;Rustのクロージャの型は匿名化された型&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2016/10/10/rustnokuro_ja3tanewotsukutterikaisuru/&#34;&gt;Rustのクロージャ3種を作って理解する | κeenのHappy Hacκing Blog&lt;/a&gt;や&lt;a href=&#34;http://keens.github.io/blog/2016/03/01/rustnozerokosutochuushouka/&#34;&gt;Rustのゼロコスト抽象化 | κeenのHappy Hacκing Blog&lt;/a&gt;
で若干説明しましたが、Rustではクロージャリテラル毎に型が作られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut x = 0;
let mut counter = || { x += 1; x}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こう書いたときにコンパイラは裏で以下のようなコードを生成します。（Rustを知らない人への説明のため、FnOnceの存在や実際は参照でキャプチャするなどを無視した疑似コードです）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct AnonymousClosure{x: i32}
impl FnMut&amp;lt;()&amp;gt; for AnonymousClosure {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (): ()) -&amp;gt; i32 {
        self.x += 1;
        x
    }
}
let mut x = 0;
let mut counter = AnnonymousClosure{x: x}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要点は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クロージャ自体はただのキャプチャしたデータの集まり&lt;/li&gt;
&lt;li&gt;関数本体は、メソッドとして定義される。 &lt;strong&gt;Rustは静的ディスパッチをする&lt;/strong&gt; ので &lt;strong&gt;関数ポインタはデータには含まれない&lt;/strong&gt;。コンパイラが解決する。

&lt;ul&gt;
&lt;li&gt;私が1つ嘘を言っていたというのはここです。関数ポインタもデータに含まれるって言っちゃってました。&lt;/li&gt;
&lt;li&gt;クロージャだけど関数ポインタを使わないんですね&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;1クロージャリテラルにつき1型を生成することでクロージャリテラル毎の関数本体を出し分けている&lt;/li&gt;
&lt;li&gt;キャプチャした変数をまとめた構造体自体はポインタ型になっていない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クロージャ自体の型は関数型ではなくて、関数っぽい振舞いをするトレイト(ここでは&lt;code&gt;FnMut&lt;/code&gt;)を実装しているだけのただの無名型です。&lt;/li&gt;
&lt;li&gt;無名関数だから型が無名という説明は確かにちょっとおかしかったですね。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;クロージャを返したい&#34;&gt;クロージャを返したい&lt;/h2&gt;

&lt;p&gt;ここから「なんで(Iteratorのmapとかの)返り値に関数型がでてくるの」へのお返事。&lt;/p&gt;

&lt;p&gt;説明の例として遅延評価するイテレータへのマップを書きたいと思います。
引数にはイテレータとクロージャを取ります。
実際には適用する訳ではないのでマップするイテレータとクロージャの組を返せばよさそうですね。
ここで思い出して欲しいのはクロージャはただの&lt;code&gt;FnMut&lt;/code&gt;を実装している構造体なのでした。
なのでこう書くのですが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn map&amp;lt;I, B, F&amp;gt;(i: I, f: F) -&amp;gt; (I, F)
where
  I: Iterator,
  F: FnMut(I::Item) -&amp;gt; B,
{
  (I, F)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にクロージャを渡したときには&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn map(i: SomeIter, f: AnnonymousClosure) -&amp;gt; (SomeIter, AnnonymousClosure)
{
  (i, f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようになります。ここでも、クロージャデータにはポインタが挟まってないことに注意して下さい。そして型名が分かるのでクロージャを呼び出すときにはその関数が &lt;strong&gt;静的ディスパッチされます&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返り値にクロージャの型を書く = クロージャの関数本体が静的ディスパッチされる = 速い&lt;/p&gt;

&lt;p&gt;ということが伝わりますでしょうか。なのでRustではできるかぎり返り値にクロージャの型を書きたいのです。&lt;/p&gt;

&lt;p&gt;で、このパターンだと引数で受け取ったものを返り値で返すだけなので関数を呼んだときに得られた名前を書くだけです。たとえクロージャが匿名型であっても書くことができます。&lt;/p&gt;

&lt;h2 id=&#34;返り値にだけ書きたい&#34;&gt;返り値にだけ書きたい&lt;/h2&gt;

&lt;p&gt;ところが返り値にだけクロージャの型を書こうとすると、ダメです。先程の&lt;code&gt;map&lt;/code&gt;関数を関数の中で使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn inc&amp;lt;I&amp;gt;(i: I) -&amp;gt; ???
where
  I: Iterator&amp;lt;Item = i32&amp;gt;,
{
  map(i, |x| x + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすると型はこう解決されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;sturct AnnonymousClosure;
impl FnMut&amp;lt;(i32,)&amp;gt; for AnonymousClosure {
    extern &amp;quot;rust-call&amp;quot; fn call_mut(&amp;amp;mut self, (x,): (i32,)) -&amp;gt; i32 {
        x + 1
    }
}

fn inc(i: SomeItr) -&amp;gt; (SomeItr, AnnonymousClosure)
{
  map(i, AnnonymousClosure::new())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値にだけ匿名型が出てきました。
先程のようにパラメータで受け取ってそのまま返すということができません。
なのでここで、返り値も匿名化する存在型が必要になるのです。&lt;/p&gt;

&lt;p&gt;ここまでくれば以下のコードにも存在型が必要な理由が分かりますでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn do_later() -&amp;gt; impl Future&amp;lt;Item = (), Err = Error&amp;gt; {
    do_something()
        // ここでクロージャが出てきた
        .and_then(|()| do_another_thing())
        // 本来の`and_then`の返り値は
        // `AndThen&amp;lt;Self, B, F&amp;gt;`だが
        // `F`の型が匿名化されていて書けない
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;存在型って-forallでできるよ&#34;&gt;存在型って、forallでできるよ&lt;/h1&gt;

&lt;p&gt;マジレスなのかただ知識を披露してるのかよく分からなかったのですが、いちおうお返事書いておきます。&lt;/p&gt;

&lt;p&gt;どの意味で「forall」でできるよと言っているのかよく分からなかったのですが、Coqの実装を見ていっているのなら見当違いです。
Coqの実装はこの辺が参考になりますかね。 &lt;a href=&#34;http://inkar-us-i.hatenablog.com/entry/2016/11/16/175844&#34;&gt;Coqで「任意のxについて…」「あるxが存在して…」を扱う - きくらげ観察日記&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;これをRustで書くとこうなるでしょうか。Rustにはトレイトをパラメータで受け取る手段がないのでひとまず量化する一階の述語を&lt;code&gt;Fn() -&amp;gt; ()&lt;/code&gt;トレイトにしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct FnExists&amp;lt;F: Fn() -&amp;gt; ()&amp;gt;(f: F)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは命題論理としては正しいのですが、型パラメータを取るので目的である匿名化を実現できていません。&lt;/p&gt;

&lt;p&gt;2017-06-25 追記:
よく考えたらCoqの実装とは異なりました。Coqに忠実にするならこうでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct FnExists(for&amp;lt;F: Fn() -&amp;gt; ()&amp;gt; f: F)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもダメです。Fの実際のサイズが分からないのでコンパイルできません。
これを実現できている言語ではポインタを使って実現しているのかと思います。
Rustでも説明の通りトレイトオブジェクトがあれば可能です。しかしながらオーバーヘッドがかかるので避けたいという話でした。
「型システムに表現能力がある」と「値レベルでのパフォーマンスを犠牲にしない表現能力がある」は別の話です。&lt;/p&gt;

&lt;p&gt;/追記&lt;/p&gt;

&lt;p&gt;もう1つは、CPS変換の可能性もあります。
この辺が参考になりますかね。&lt;a href=&#34;http://myuon-myon.hatenablog.com/entry/2016/05/11/215734&#34;&gt;データ型のCPS変換について - Just $ A sandbox&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;直観論理でも以下が成り立ちます。&lt;/p&gt;

&lt;p&gt;\[
{}^\exists x P(x) \to \lnot ^\forall x \lnot P(x)
\]&lt;/p&gt;

&lt;p&gt;因みに逆は直観論理では成り立ちません（直感的な説明をすると存在しないことを否定しても実際の値を構成できないからです）。&lt;/p&gt;

&lt;p&gt;これは確かに正しいです。「&lt;code&gt;Tr&lt;/code&gt;トレイトを実装した型」という存在型は以下の疑似コードで書けるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Tr{}
fn exists() -&amp;gt; FnOnce&amp;lt;A&amp;gt;(FnOnce&amp;lt;T: Tr&amp;gt;(t: T) -&amp;gt; A) -&amp;gt; A {
  let tr = SomeTr::new();
  forall &amp;lt;A&amp;gt; move |cont: FnOnce&amp;lt;T: Tr&amp;gt;(t: T) -&amp;gt; A| -&amp;gt; A { cont(tr) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですがまあ、これは実際には無理です。
1つにはRustには型の高ランク多相がありません。ジェネリクスだけです。
もしランクの概念を知らずにforallで書けると主張しているならそれは的外れです。
ランクの概念を知った上で高ランク多相を入れろという主張なら理解はできますが、無理です。
引数に渡す関数や返り値で返す関数、要はデータとして扱う関数はジェネリクスにできません。
スライドの中でRustはテンプレート方式と説明しましたが、ジェネリクスはテンプレートであって実際のデータではないので値として扱えないのです。
なのでRustのコンパイル方式を大きく変えるなどしないと実現できないでしょう。&lt;/p&gt;

&lt;p&gt;それにもう1つ、ランクとは関係なしにクリティカルな理由があります。
上で説明した通り、クロージャの実際の型は匿名データ型になります。なので返り値に型として書くことができません。
冷静になって考えれば返り値のクロージャの型を書かないようにするための存在型のために返り値にクロージャの型を書くのは土台無理です。&lt;/p&gt;

&lt;p&gt;さて、私の知識では全称型で存在型を構成する手法はこれくらいですがもし上記以外の構成方法が存在して、私が明後日な返事をしているなら連絡下さい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ジェネリクス ディスパッチ 表裏</title>
      <link>/slide/jienerikusu_disupatchi_omoteura/</link>
      <pubDate>Sat, 17 Jun 2017 22:25:35 +0900</pubDate>
      
      <guid>/slide/jienerikusu_disupatchi_omoteura/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# ジェネリクス ディスパッチ 表裏
----------------------
[ジェネリクス勉強会 - connpass](https://connpass.com/event/56773/?utm_campaign=event_participate_to_owner&amp;utm_source=notifications&amp;utm_medium=email&amp;utm_content=title_link)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# はじめに
-----------

* 例にはJavaとRustを使います
  + それ以外にあまり詳しくない
  + たまにScalaが出てくるかも
* 主に裏側で何が起きてるかに焦点を当てます
* 一般的な手法の比較と言語固有実装の比較がやや混じります
  + 実例重視
* 言語や機能を選ぶときの知識が増えればよし

===
# ジェネリクス
--------------

* 型でパラメータ化された何か
* パラメータ化する方法にいくつか方式が
  + 任意の型に対応する実装にする
    - Java
  + 使う型毎に実体をつくる
    - 型が引数になるイメージ
    - Rust
* 便宜上前者をポインタ方式、後者をテンプレート方式と呼ぶ

===
# 関数ジェネリクス
-----------------

* Javaコード


``` java
public class Generics {
    public static void main(String[] args) {
        Generics g = new Generics();
        System.out.println(g.id(&#34;hello&#34;));
    }

    &lt;T&gt; T id(T t) {
        return t;
    }
}
```

===

# 関数ジェネリクス
-----------------

* Javaアセンブリ

```
public class Generics {
  // ...
  // Tの中身に言及していない
  &lt;T&gt; T id(T);
    Code:
       0: aload_1
       1: areturn

```

===

# 関数ジェネリクス
-----------------

* Rustコード

``` rust
fn id&lt;T&gt;(t: T) -&gt; T {
    t
}


fn main() {
    println!(&#34;{}&#34;, id(&#34;hello&#34;));
}
```

===

# 関数ジェネリクス
-----------------

* Rustアセンブリ

``` llvm
define internal %str_slice @_ZN3tmp2id17hfe175cfdb5be0f46E(i8* noalias nonnull readonly, i64) unnamed_addr #0 {
start:
  ; str_sliceに特化した関数を生成している
  %2 = insertvalue %str_slice undef, i8* %0, 0
  %3 = insertvalue %str_slice %2, i64 %1, 1
  ret %str_slice %3
}
```

===

# 関数ジェネリクス
-----------------

* ポインタ方式は`void *`使ってるイメージ
  +  コンパイルされたコードがコンパクト
  + 必ずポインタ経由する
    + Javaのオブジェクトは参照になってるのであまり問題ない
* テンプレート方式は型毎に`id_XXX`関数を定義してるイメージ
  + 構造体の値渡しも可能
  + オブジェクトコードは大きくなる
  + 関数の使用箇所が分からないとコンパイルできない

===

# 返り値ジェネリクス
-------------------

* Rustは返り値のジェネリクスがある
  - コンテキストで返り値が決まる
  ```rust
  // str
  parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt; where
    F: FromStr;
  ```
  ```rust
  let addr: SocketAddr = &#34;127.0.0.1:8080&#34;.parse().unwrap();
  ```
* コンパイル中に実際の型が解決されるので関連関数（スタティックメソッド）が呼べる
* キモいけど便利


===

# データ型ジェネリクス
---------------------

* `ArrayList&lt;T&gt;`(Java) vs `Vec&lt;T&gt;`(Rust)
* だいたい関数のときと似たような特徴
* テンプレート方式はサイズやアラインメントまで考慮できる
  - `Vec&lt;u8&gt;`(バイト列型)が効率的
* Rustの場合は構造体定義はオブジェクトコードに出ないのでサイズは気にならない

===

# 制約とディスパッチ
-------------------

* パラメータ型に条件をつけたい
  + Javaならインターフェースで `T extends SomeInterface` とか
  + Rustならトレイトで `T: SomeTrait` とか
* さらにパラメータ型の詳細にアクセスしたい
  + `t.someMethod()` とか
* このメソッドってどっからやってくるの？

===

``` java
&lt;W extends Writer&gt; void writeHello(W w) throws IOException {
    // このwriteメソッドはどこから？
    w.write(&#34;Hello&#34;);
}
```

``` rust
fn write_hello&lt;W: io::Write&gt;(mut w: W) -&gt; io::Result&lt;()&gt; {
    // このwrite_allメソッドはどこから？
    w.write_all(b&#34;Hello&#34;)
}
```

===

# 動的ディスパッチ
-------------------
* Javaだとオブジェクトに紐付くメソッドテーブルを *実行時* に引く
  + テーブルもオブジェクトから *実行時* に取得する
   ``` java
   w.vtable[write](w, &#34;Hello&#34;);
   ```
* ダイナミックなことができる
  + サブクラスのインスタンスと入り交じっても問題無
    ```java
    Writer w = new MyWriter();
    obj.writeHello(w);
    ```
* vtable引くオーバーヘッドがかかる
  - [java - Virtual table/dispatch table - Stack Overflow](https://stackoverflow.com/questions/6606481/virtual-table-dispatch-table)
  - [jvm - Java method table - Stack Overflow](https://stackoverflow.com/questions/10225668/java-method-table)

===

# 静的ディスパッチ
-----------------
* Rustだとメソッドを *コンパイル時* に解決する
  + テーブルを静的に解決するだけじゃなくてテーブルのメソッドまで解決
  ```rust
   SomeWriter::write(w, b&#34;Hello&#34;)
  ```
  + 辞書オブジェクトはみんなの心の中にあるんだよ
    - (テーブルだけ静的に解決する方式もある)
* 速い
  + オーバーヘッドがない
  + メソッドのインライン化などの最適化ができる

===
# 動静まとめ
------------

* ポインタ方式で動的ディスパッチだとコンパクトだけど遅い
* テンプレート方式で静的ディスパッチだと速いけど嵩む
* 特徴は表裏な感じ


===
# Java固有の問題と解決
----------------------

* ジェネリクスとプリミティブ問題
* → ヴァルハラ
* → Scalaのspecialized
* → DottyのLinker

===

# ジェネリクスとプリミティブ問題
--------------------------------

* ジェネリクスは必ずポインタ経由
  + プリミティブはどうするの？
* 一旦オブジェクトに包む(ボクシングする)必要がある
  + 関数もデータ型も同じ問題
  + 関数は暗黙の変換があるので気付きづらい
* 割と深刻なパフォーマンス低下を招くこともある


===

``` java
public class Generics {
    public static void main(String[] args) {
        Generics g = new Generics();
        // プリミティブを渡す
        System.out.println(g.id(0));
    }

    &lt;T&gt; T id(T t) {
        return t;
    }
}

```


===

```
public class Generics {
  public static void main(java.lang.String[]);
   // ..
    Code:
      // ..
      // ここで一旦`Integer`を作る
      13: invokestatic  #5                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      16: invokevirtual #6                  // Method id:(Ljava/lang/Object;)Ljava/lang/Object;
      19: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
      22: return

  &lt;T&gt; T id(T);
    Code:
       0: aload_1
       1: areturn

}

```

===

# ヴァルハラ
------------

* [OpenJDK: Valhalla](http://openjdk.java.net/projects/valhalla/)
  + [JEP 169: Value Objects](http://openjdk.java.net/jeps/169)
  + [JEP 218: Generics over Primitive Types](http://openjdk.java.net/jeps/218) ← こっち
* プリミティブタイプもボクシングせずにジェネリクスに使える
* やったね
* いつ入るんだろうね。
* [JDK 9](http://openjdk.java.net/projects/jdk9/) にはまだっぽい？

===

# [scala.specialized](http://www.scala-lang.org/api/2.9.2/scala/specialized.html)
-------------

* ジェネリクスの他にプリミティブ毎に専用のメソッドを生成
* 半分テンプレート方式みたい
  ``` scala
  class MyList[@specialized T]  ...
  ```
* 実際には使われない型に対しても生成してしまう
  + → テンプレート方式よりも非効率
  + 型パラメータが3つあったら1000メソッドくらい出来てしまう
* &gt; 関数の使用箇所が分からないとコンパイルできない

  + JVMの分割コンパイル下では何が使われるか事前に分からない

===

# DottyのLinker
---------------

* &gt; 関数の使用箇所が分からないとコンパイルできない
* リンクフェーズを用意すれば使用箇所が全て分かる
* [Dotty Linker: Making your Scala applications smaller and faster](https://d-d.me/talks/scaladays2015/#/)
  + スライドを見る限りspecializeしといてDCE?
* 実際には生のバイトコードじゃ情報が足りないのでTASTYも付加
* Dottyはいつ使えるようになるんでしょうね。

===

# Rust固有の問題と解決
---------------------

* トレイト境界とヘテロな型の問題
  * ヘテロなVec
  * 分岐からのreturn
* → トレイトオブジェクト

===
# トレイト境界とヘテロな型の問題
-------------------------------

* ジェネリックデータ型に2つ以上の異なる型を入れられない
* つまり以下のようなコードが書けない
  ``` rust
  trait Processor {}
  let procs: Vec&lt;Processor&gt; = vec![
    TwProc::new(),
    FbProc::new(),
  ];
  ```
* トレイトは実際の型ではないので同じ振舞をしても共通の型として扱えない
* でも一緒に扱いたいケースがあるんだけど？？

===
# トレイト境界とヘテロな型の問題2
-------------------------------

* 分岐して型を出し分けるのも出来ない
  ```rust
  fn getProc() -&gt; Processor {
    if xxx {
      TwProc::new()
    } else {
      FbProc::new()
    }
  }
  ```

===

# トレイトオブジェクト
---------------------

* オプトインで動的ディスパッチする仕組み
* データとトレイトからvtableを作る
* `Box`や`&amp;`などポインタ型を通すと使える

===

``` rust
let procs: Vec&lt;Box&lt;Processor&gt;&gt; = vec![
  Box::new(TwProc::new()),
  Box::new(FbProc::new()),
];

```

``` rust

fn getProc() -&gt; Box&lt;Processor&gt; {
  if xxx {
    Box::new(TwProc::new())
  } else {
    Box::new(FbProc::new())
  }
}
```
===

&lt;!-- .slide: class=&#34;center&#34; --&gt;
&lt;span style=&#34;font-size:400%;&#34;&gt;裏&lt;/span&gt;

===

# ジェネリクスの双対
-------------------

* ジェネリクスは$\forall$の量化
  + 関数$T \to S$に対して${}^\forall x(T \to S)$
* $\exists$の量化があってもよくない？
  + 存在型と呼ばれる
  + 因みに${}^\exists x(T \to S)$は虚無

===

# 存在型
---------

* 「`P`を満たす`T`が存在する」ことを表わす型
* `P`とは？
  + 本来は型を引数にとる述語。
    + e.g.) 「`T`は`S`のサブタイプである」「`T`は`write`メソッドを持つ」
  + 実際は型の集合の方が便利
    - $P(x) \iff x \in \\{x| {}^\forall x, P(x) \\}$
  + Scala: `forSome`に続く何か
    - よく分からなかった。構造的superset?
  + Rust: トレイト境界
* 実際に使うときには`P`を満たす`T`を1つ与える
* 実際の型を変数`T`に匿名化してるとも見れる
  - Rustなら「トレイト`Tr`を実装しているとある型`T`」
===

# 引数の存在型
---------------

* Scalaの`forSome`
  ```scala
  def len(l: List[T] forSome {type T}): Int
  ```
* Rustのarg position `impl Trait`
  ```rust
  fn len(i: impl IntoIterator) -&gt; usize
  ```
* `R`が`x`を含まないなら
  \\\[{}^\forall x(A(x) \land x \to R) \leftrightarrow {}^\exists x (A(x) \land x) \to R \\\]
  なのでほぼジェネリクス
* 違い
  + 関数が型パラメータを持たなくなる
  + 量化した場所以外（他の引数や返り値）でその型変数を使えない

===
# 返り値の存在型
----------------

* Rustの`impl Trait`
  ```rust
  fn do_later() -&gt; impl Future&lt;Item = (), Err = Error&gt;
  ```
* 実際の型は関数の定義で決まっている
* 実質返り値を匿名化しているだけ
* 必要？

===
# 存在型の利点
--------------

* 何をしたいか伝わりやすい
  ```rust
  // Iterator
  map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; where ...
  ```
  vs
  ```rust
  map&lt;B, F&gt;(self, f: F) -&gt; impl Iterator where ...
  ```
* サブタイピングがあればアップキャストで終わる
* Rustでも動的ディスパッチを許せばトレイトオブジェクトがある
  + でも絶対動的ディスパッチをしたくない

===
# 存在型の必要性
----------------

* 存在型でないと書けない型が存在する
  + 匿名化した型を含む型
  + クロージャ、お前のことだ
* 以下の型はジェネリクスでは書けない
  ``` rust
  fn counter(x: isize) -&gt; impl FnMut() -&gt; isize;
  ```

* 動的ディスパッチを許せばトレイトオブジェクトで書ける
  + でも絶対動的ディスパッチをしたくない
  + 極端な話、関数抽象する度にパフォーマンスが落ちる

===

# ユースケース
--------------

* 実際そんなに必要なの？
* 極一部のケースだけじゃないの？
* 分岐したら結局トレイトオブジェクト必要なんじゃなかった？
* 動的ディスパッチで妥協できないの？

===

# `Iterator`
------------

* 標準ライブラリ
* 遅延評価
  * 融合変換するため
* `map`すると元のイテレータとmapする関数の組が返る
  ```rust
  // Iterator
  map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; where ...
  ```
* `impl Trait`で書くと分かりやすい
  ```rust
  map&lt;B, F&gt;(self, f: F) -&gt; impl Iterator where ...
  ```

===

# [futures-rs](https://github.com/alexcrichton/futures-rs)
-----------------

* 非同期処理を抽象化
* 実行時にはステートマシンになる
  + 動的ディスパッチを挟まない
* `Future`に`map`や`and_then`すると返り値に関数型が出てくる
  + 存在型がないと書けない
  + 引数でクロージャを受け取る訳ではないのでジェネリクスで書けない
* `Future`を使うほぼ全てのコードで存在型が必要になる

===
# futures-rs
------------

``` rust
fn do_later() -&gt; impl Future&lt;Item = (), Err = Error&gt; {
    do_something()
        // ここでクロージャが出てきた
        .and_then(|()| do_another_thing())
        // 本来の`and_then`の返り値は
        // `AndThen&lt;Self, B, F&gt;`だが
        // `F`の型が匿名化されていて書けない
}
```

===
# [transaction-rs](https://github.com/KeenS/transaction-rs)
------------------

* トランザクションを抽象化
* コンセプト的には`futures-rs`に似てる
* 分岐しても`branch` APIでトレイトオブジェクト回避
  + 直和型を信じろ
* [マイクロベンチマーク](https://github.com/KeenS/transaction-rs/blob/master/transaction-stm/benches/boxed_vs_branch.rs)だとトレイトオブジェクトをなくすと *13%* 高速化

===
# transaction-rs
----------------

```rust
fn find_and_delete() -&gt; impl Transaction&lt;Item = Option&lt;User&gt; ...&gt; {
  match find_user() {
    // 分岐の枝毎に違う型を返そうとしてるが、直和型を使えば問題無
    None =&gt; ok(none).branch().first()
    Some(user) =&gt;
      delete_user()
        .map(move|_| user)
        .branch()
        .second()
  }
}
```


===
# 存在型の深掘
--------------

* ユーザには匿名化された型の実体は分からない
* コンパイラは実際の型で扱う
* 色々エッジケースが出てきそう
  + 同じ関数から返る型は同じ型？
  + 違う関数でも実体が同じなら？
  + 関数がジェネリクスだったら？
    - 返り値もジェネリクスパターン
    - 引数だけジェネリクスパターン
  + トレイトのメソッドだったら？
* 例えば`vec![foo(), bar()]`って書けるの？

===

``` rust
fn foo&lt;T: Trait&gt;(t: T) -&gt; impl Trait {t}

fn bar() -&gt; impl Trait {123}

fn equal_type&lt;T&gt;(a: T, b: T) {}

equal_type(bar(), bar());                      // OK
equal_type(foo::&lt;i32&gt;(0), foo::&lt;i32&gt;(0));      // OK
equal_type(bar(), foo::&lt;i32&gt;(0));              // ERROR, `impl Trait {bar}` is not the same type as `impl Trait {foo&lt;i32&gt;}`
equal_type(foo::&lt;bool&gt;(false), foo::&lt;i32&gt;(0)); // ERROR, `impl Trait {foo&lt;bool&gt;}` is not the same type as `impl Trait {foo&lt;i32&gt;}`
// トレイトのメソッドには`impl Trait`は書けないらしい
```

===
# 話さなかったこと
-----------------

* 存在型のライフタイム
* Rustのfeatureとリリーススケジュール
  + 存在型はまだリリース版には入っていない
* 関連型と存在型の関係(なんか関係ありそう)

===

# まとめ
--------

* 総称を表わすジェネリクスというのがあるよ
* ジェネリクスの実装は2種類あるよ
* 存在を表わす存在型というのがあるよ
* 存在型の実装は2種類あるよ
* 2種類の実装は言語機能や型システムに密着してるよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustでエラーが出てないのにファイルに書き出せないときは</title>
      <link>/blog/2017/06/13/rustdeera_gadetenainonifairunikakidasenaitokiha</link>
      <pubDate>Tue, 13 Jun 2017 22:53:46 +0900</pubDate>
      
      <guid>/blog/2017/06/13/rustdeera_gadetenainonifairunikakidasenaitokiha</guid>
      <description>&lt;p&gt;κeenです。随分前から書こうと思いつつ先送りになっていた小ネタです。
&lt;/p&gt;

&lt;p&gt;例えばカレントディレクトリにある&lt;code&gt;some_file.txt&lt;/code&gt;に適当なデータを書き込もうとして、以下のようなコードを書いたとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs::File;
use std::io::prelude::*;
use std::io::BufWriter;

fn main() {
    let file = File::open(&amp;quot;some_file.txt&amp;quot;).unwrap();
    let mut w = BufWriter::new(file);
    // unwrapを呼んで書き込みエラーを検知
    write!(w, &amp;quot;hello&amp;quot;).unwrap();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ rustc write_file.rs
$ ./write_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特段エラーは出ません。しかしながら&lt;code&gt;some_file.txt&lt;/code&gt;の中身は特に書き変わっていません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat some_file.txt
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ、パッと原因分かりますか？&lt;/p&gt;

&lt;p&gt;直接の原因は&lt;a href=&#34;https://doc.rust-lang.org/std/fs/struct.File.html#method.open&#34;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt;です。&lt;code&gt;File::open&lt;/code&gt;はリードオンリーでファイルを開くので&lt;code&gt;File::open&lt;/code&gt;で開いたファイルに書き込もうとしても書き込めません（書き込みたいなら&lt;a href=&#34;https://doc.rust-lang.org/std/fs/struct.File.html#method.create&#34;&gt;&lt;code&gt;File::create&lt;/code&gt;&lt;/a&gt;を使います）。
じゃあなぜエラーが出ないかというと&lt;code&gt;BufWriter&lt;/code&gt;のせいです。
書き込んだ文字列&lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt;は短いので&lt;code&gt;write!&lt;/code&gt;を発効した時点ではまだデータはバッファに書き込まれるだけです。
このときにはまだエラーは出ません。
そして&lt;code&gt;main&lt;/code&gt;の末尾で&lt;code&gt;w&lt;/code&gt;のライフタイムが終わるときに&lt;code&gt;BufWrite&lt;/code&gt;の&lt;a href=&#34;https://doc.rust-lang.org/src/std/io/buffered.rs.html#511-518&#34;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;が呼ばれますが、ここではエラーが無視されるのでユーザにはエラーが起きてないように見える訳です。&lt;/p&gt;

&lt;p&gt;このような事故を防ぐために以下のように&lt;code&gt;flush&lt;/code&gt;を呼びましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs::File;
use std::io::prelude::*;
use std::io::BufWriter;

fn main() {
    let file = File::open(&amp;quot;some_file.txt&amp;quot;).unwrap();
    let mut w = BufWriter::new(file);
    // unwrapを呼んで書き込みエラーを検知
    write!(w, &amp;quot;hello&amp;quot;).unwrap();
    // flushを呼ぶことで書き込みエラーを全て拾える
    w.flush().unwrap();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ rustc write_file.rs
$ ./write_file
thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Error { repr: Os { code: 9, message: &amp;quot;Bad file descriptor&amp;quot; } }&#39;, /checkout/src/libcore/result.rs:859
note: Run with `RUST_BACKTRACE=1` for a backtrace.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://keens.github.io/blog/2016/01/08/rusttoiedoriso_sunokaihouhachuui/&#34;&gt;Rustといえどリソースの解放は注意 | κeenのHappy Hacκing Blog&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rustのトランザクション抽象化ライブラリ作った</title>
      <link>/blog/2017/06/06/rustnotoranzakushonchuushoukaraiburaritsukutta</link>
      <pubDate>Tue, 06 Jun 2017 18:20:52 +0900</pubDate>
      
      <guid>/blog/2017/06/06/rustnotoranzakushonchuushoukaraiburaritsukutta</guid>
      <description>&lt;p&gt;κeenです。最近&lt;a href=&#34;https://github.com/KeenS/transaction-rs&#34;&gt;KeenS/transaction-rs: The transaction abstraction library and its executors for rust&lt;/a&gt;というライブラリをリリースしたのでそれについて。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h1&gt;

&lt;p&gt;Rustでドメインロジックを書いていると以下のようなコードが出てきました。
(実際はもうちょっと複雑ですが本質ではないので簡略化します)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct GroupPgDao(r2d2::Pool&amp;lt;ConnectionManager&amp;lt;PgConnection&amp;gt;&amp;gt;);
impl GroupPgDao {
  fn get_conn(&amp;amp;self) -&amp;gt; &amp;amp;PgConnection { /*... */ }
  fn delete_user(&amp;amp;self, user: &amp;amp;User, group: &amp;amp;Group) -&amp;gt; Result&amp;lt;()&amp;gt; {
      let cn = self.get_conn();
      //...
  }
  fn add_user(&amp;amp;self, user: &amp;amp;User, group: &amp;amp;Group) -&amp;gt; Result&amp;lt;()&amp;gt; {
      let cn = self.get_conn();
      //...
  }
}

trait GroupService: HaveGroupDao {
  fn change_group(&amp;amp;self, user: &amp;amp;User, from: &amp;amp;Group, to: &amp;amp;Group) -&amp;gt; Result&amp;lt;()&amp;gt; {
     let service = self.group_dao();
     dao.delete_user(user, from)?;
     dao.add_user(user, to)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この&lt;code&gt;change_group&lt;/code&gt;はDBのトランザクション内で実行しないと困ります。&lt;code&gt;delete_user&lt;/code&gt;が成功して&lt;code&gt;add_user&lt;/code&gt;が失敗するとuserがどちらにも所属しなくなるからです。じゃあ&lt;code&gt;change_group&lt;/code&gt;の中でトランザクションを作って実行すればいいかというとそうでもなく、いくつか問題があります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;もっと外側でトランザクションが必要な操作が発生するかもしれない&lt;/li&gt;
&lt;li&gt;同一トランザクション内で実行するにはコネクションを共有しないといけないが、関数個々でプールからコネクションを取得している&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1に関しては誰がトランザクションを実行するのかという責任問題と、どの操作がトランザクションを必要とするのかという契約問題の2つが複合しています。
dieselのトランザクションはネストをサポートしているので必要そうな部分至るところトランザクションを作るというのも考えられますが、プログラマが目で責任と契約を追うことになりバグりかねません&lt;/p&gt;

&lt;p&gt;2つ目はインジェクションの問題ですね。これについてはシンプルに引数にコネクションを渡すというのも考えられますが持ち回るのは非常に大変です。&lt;/p&gt;

&lt;p&gt;これらを解決するために作ったのが冒頭に挙げたtransaction-rsです。&lt;/p&gt;

&lt;h1 id=&#34;transaction-rs&#34;&gt;transaction-rs&lt;/h1&gt;

&lt;p&gt;transaction-rsは非常に&lt;a href=&#34;https://github.com/alexcrichton/futures-rs&#34;&gt;future-rs&lt;/a&gt;に似ています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Transaction&amp;lt;Ctx&amp;gt; {
    type Item;
    type Err;
    fn run(&amp;amp;self, ctx: &amp;amp;mut Ctx) -&amp;gt; Result&amp;lt;Self::Item, Self::Err&amp;gt;;

    fn map&amp;lt;F, B&amp;gt;(self, f: F) -&amp;gt; Map&amp;lt;Self, F&amp;gt;
    where
        F: Fn(Self::Item) -&amp;gt; B,
        Self: Sized,
    { ... }
    fn and_then&amp;lt;F, B&amp;gt;(self, f: F) -&amp;gt; AndThen&amp;lt;Self, F, B&amp;gt;
    where
        B: Transaction&amp;lt;Ctx, Err = Self::Err&amp;gt;,
        F: Fn(Self::Item) -&amp;gt; B,
        Self: Sized,
    { ... }
    fn map_err&amp;lt;F, B&amp;gt;(self, f: F) -&amp;gt; MapErr&amp;lt;Self, F&amp;gt;
    where
        F: Fn(Self::Err) -&amp;gt; B,
        Self: Sized,
    { ... }
    fn or_else&amp;lt;F, B&amp;gt;(self, f: F) -&amp;gt; OrElse&amp;lt;Self, F, B&amp;gt;
    where
        B: Transaction&amp;lt;Ctx, Item = Self::Item&amp;gt;,
        F: Fn(Self::Err) -&amp;gt; B,
        Self: Sized,
    { ... }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt;や&lt;code&gt;and_then&lt;/code&gt;のある「よくあるパターン」です。&lt;code&gt;futures&lt;/code&gt;の他&lt;code&gt;Result&lt;/code&gt;や&lt;code&gt;Option&lt;/code&gt;にもありますね。
&lt;code&gt;Transaction&lt;/code&gt;を作った時点ではまだ計算は実行されません。DBへのクエリも実行されてません。&lt;code&gt;run&lt;/code&gt;が呼ばれた時点でようやく計算が実行され、結果を取り出すことができます。&lt;code&gt;future-rs&lt;/code&gt;と同じくこれは &lt;em&gt;ゼロコスト抽象化&lt;/em&gt; をしていて、トランザクションの関数を積んでいくと実行時にはオートマトンにまで落ちます。 詳しくはこちらをどうぞ&lt;a href=&#34;https://aturon.github.io/blog/2016/08/11/futures/&#34;&gt;Zero-cost futures in Rust · Aaron Turon&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;トランザクションの合成と要求&#34;&gt;トランザクションの合成と要求&lt;/h1&gt;

&lt;p&gt;話を冒頭のコードに戻しすと、transaction-rsを使うとDAOはこう書けるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct GroupPgDao;
impl GroupPgDao {
  fn delete_user(&amp;amp;self, user: &amp;amp;User, group: &amp;amp;Group) -&amp;gt; Box&amp;lt;Transaction&amp;lt;... ()&amp;gt; {
      with_conn(|cn| {
          //...
      })
      .boxed()
  }
  fn add_user(&amp;amp;self, user: &amp;amp;User, group: &amp;amp;Group) -&amp;gt; Box&amp;lt;Transaction&amp;lt;... ()&amp;gt; {
      with_conn(|cn| {
          //...
      })
      .boxed()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値の型がやや残念になるものの、中身はそれほど変わらないです。
&lt;code&gt;Transaction&lt;/code&gt;を返しているのでこのコードはトランザクション下で実行されることを要求しているのが分かりますね。&lt;/p&gt;

&lt;p&gt;そして自分で持っていたコネクションプールと&lt;code&gt;self.get_conn()&lt;/code&gt;が消え、変わりに&lt;code&gt;with_conn&lt;/code&gt;関数でコネクションを取得しています。この関数は付属の&lt;code&gt;transaction-diesel&lt;/code&gt;にて定義されています。何やら虚空からコネクションが沸いてるようにも見えますがちゃんと正規のルートで渡ってきています。これについては後で説明します。&lt;/p&gt;

&lt;p&gt;さらにサービスの方も書き換えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait GroupService&amp;lt;Ctx&amp;gt;: HaveGroupDao&amp;lt;Ctx {
  fn change_group(&amp;amp;self, user: &amp;amp;User, from: &amp;amp;Group, to: &amp;amp;Group) -&amp;gt; Box&amp;lt;Transaction&amp;lt;Ctx, ... ()&amp;gt;&amp;gt;&amp;gt; {
     let service = self.group_dao();
     dao.delete_user(user, from)
         .and_then(move|()| dao.add_user(user, to))
         .boxed()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;疑似コードなのでコンパイルが通るか分かりませんがまあ、こんなところになるでしょう。
このコードで分かるように、トランザクション同士の合成も可能なのです。
そして、&lt;code&gt;Transaction&lt;/code&gt;を返しているのでこのコード自身もまたトランザクションを要求していることが分かります。&lt;/p&gt;

&lt;p&gt;さて、気付いたでしょうか。これで上記の契約問題、責任問題、インジェクション問題が解決しています。&lt;/p&gt;

&lt;p&gt;契約問題については&lt;code&gt;Transaction&lt;/code&gt;を返す関数はトランザクションを要求するというシグナルですね。非常に分かりやすいです。
責任問題についても&lt;code&gt;Transaction&lt;/code&gt;を&lt;code&gt;run&lt;/code&gt;する関数にトランザクションの責任があります。&lt;code&gt;run&lt;/code&gt;しないと結果を取り出せないので結果が欲しい人がそのまま責任を持つ形になります。&lt;/p&gt;

&lt;p&gt;なんとなく、&lt;code&gt;unsafe&lt;/code&gt;に似ているのが分かりますか？&lt;code&gt;unsafe fn&lt;/code&gt;は内部でアンセーフなことをやるし、呼び出す関数に契約を満たすことを要求します。&lt;code&gt;unsafe&lt;/code&gt;ブロックはアンセーフな処理の契約に責任を持ちます。同じく&lt;code&gt;Transaction&lt;/code&gt;を返す関数は内部でトランザクションを要求する処理をするし、呼び出し側に契約を満たすことを要求します。&lt;code&gt;run&lt;/code&gt;がトランザクションという契約に責任を持ちます。&lt;/p&gt;

&lt;h1 id=&#34;インジェクションの仕組み&#34;&gt;インジェクションの仕組み&lt;/h1&gt;

&lt;p&gt;先のコードでマジカルにコネクションが外からやってきていました。この仕組みについて説明します。とはいっても複雑ではないです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Transaction&lt;/code&gt;のコードを思い出してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Transaction&amp;lt;Ctx&amp;gt; {
    fn run(&amp;amp;self, ctx: &amp;amp;mut Ctx) -&amp;gt; Result&amp;lt;Self::Item, Self::Err&amp;gt;;
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;run&lt;/code&gt;すると結果が取り出せるのでした。そして&lt;code&gt;run&lt;/code&gt;は引数&lt;code&gt;Ctx&lt;/code&gt;をとります。
これは抽象的なトランザクションなので抽象的な「コンテキスト」ですが、&lt;a href=&#34;https://github.com/Marthog/rust-stm&#34;&gt;STM&lt;/a&gt;ならSTM、データベースならコネクションがコンテキストです。
コンテキストを受け取って計算を実行するということは、&lt;code&gt;Transaction&lt;/code&gt;は見方を変えると&lt;code&gt;Ctx&lt;/code&gt;を引数にとる関数になっています。&lt;/p&gt;

&lt;p&gt;なので&lt;code&gt;with_conn&lt;/code&gt;関数は&lt;code&gt;run&lt;/code&gt;で受け取った引数を取り出しているだけです。&lt;/p&gt;

&lt;h1 id=&#34;小まとめ&#34;&gt;小まとめ&lt;/h1&gt;

&lt;p&gt;このtransaction-rsは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;トランザクションの契約と責任を型で表現している&lt;/li&gt;
&lt;li&gt;コネクションをインジェクトしている&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さらに、&lt;code&gt;run&lt;/code&gt;するまでは実際にはトランザクションは実行されていないので&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「トランザクションを必要とする計算とその合成」と「トランザクションの実行」を分離している&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というのが特徴です。大筋はこれがメインなのですが、実用の話をいくつか。&lt;/p&gt;

&lt;h1 id=&#34;つらい話と救いの話&#34;&gt;つらい話と救いの話&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Transaction&lt;/code&gt;で契約と責任は明確になりました。
では、便利になったかというとそうでもありません。例えばUserをCRUDしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn crud_user(dao: UserDao, ctx: Ctx) -&amp;gt; Result&amp;lt;()&amp;gt; {
    let tx = dao.create(&amp;quot;name&amp;quot;, 24)
      .and_then(move |id|
          dao.find(id)
              .and_then(move |user|
                  dao.update(None, user.age + 1)
                      .and_then(move |()|
                          dao.delete(user))));
    tx.run(ctx)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、&lt;code&gt;and_then&lt;/code&gt;がネストしてしまいます。コードが不要に複雑になっただけですね。つらい。&lt;/p&gt;

&lt;p&gt;しかしながら救いはあって、&lt;a href=&#34;https://github.com/TeXitoi/rust-mdo&#34;&gt;&lt;code&gt;mdo&lt;/code&gt;&lt;/a&gt;というライブラリがあります。
mがなんなのかやdoがどこからきたのかは気にしてはいけません。
&lt;code&gt;transaction-rs&lt;/code&gt;もこれをサポートしていて、マクロを使うことで以下のように書き換えられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn crud_user(dao: UserDao, ctx: Ctx) -&amp;gt; Result&amp;lt;()&amp;gt; {
    let tx = mdo! {
        id =&amp;lt;&amp;lt; dao.create(&amp;quot;name&amp;quot;, 24);
        user =&amp;lt;&amp;lt; dao.find(id);
        () =&amp;lt;&amp;lt; dao.update(None, user.age + 1);
        ret dao.delete(user)
    };

    tx.run(ctx)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本質的にはネストを代入っぽく書き換えただけですが、絶大な可読性の向上があります。
なので実際に&lt;code&gt;transaction&lt;/code&gt;を使うときは&lt;code&gt;mdo&lt;/code&gt;を併用することになるでしょう。&lt;/p&gt;

&lt;h1 id=&#34;futures-との違い&#34;&gt;&lt;code&gt;futures&lt;/code&gt;との違い&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;futures&lt;/code&gt;に非常によく似ていると言いましたが、逆に何が違うのかという話です。大きな違いは2つあります。&lt;/p&gt;

&lt;p&gt;1つには結果を取り出すメソッドの違いです。&lt;code&gt;Future&lt;/code&gt;の&lt;code&gt;poll&lt;/code&gt;は引数を取りませんが、&lt;code&gt;Transaction&lt;/code&gt;の&lt;code&gt;run&lt;/code&gt;は取ります。また、それに合わせてトレイトがジェネリクスになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Future {
    fn poll(&amp;amp;mut self) -&amp;gt; Poll&amp;lt;Self::Item, Self::Error&amp;gt;;
}

pub trait Transaction&amp;lt;Ctx&amp;gt; {
    fn run(&amp;amp;self, ctx: &amp;amp;mut Ctx) -&amp;gt; Result&amp;lt;Self::Item, Self::Err&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう1つはクロージャを取るメソッドの違いで、&lt;code&gt;Future&lt;/code&gt;は&lt;code&gt;FnOnce&lt;/code&gt;を取るのに対して&lt;code&gt;Transaction&lt;/code&gt;は&lt;code&gt;Fn&lt;/code&gt;を取ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Future {
    fn map&amp;lt;F, U&amp;gt;(self, f: F) -&amp;gt; Map&amp;lt;Self, F&amp;gt;
        where
            F: FnOnce(Self::Item) -&amp;gt; U,
            Self: Sized,
}

pub trait Transaction&amp;lt;Ctx&amp;gt; {
    fn map&amp;lt;F, B&amp;gt;(self, f: F) -&amp;gt; Map&amp;lt;Self, F&amp;gt;
    where
        F: Fn(Self::Item) -&amp;gt; B,
        Self: Sized,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Future&lt;/code&gt;は単純に計算の合成と実行を分離しているのに対して&lt;code&gt;Transaction&lt;/code&gt;はSTMのように失敗した計算のリトライにまで責任を持つことがあるので再実行可能でないといけません。さらに、再実行するということは羃等性の確保も必要です。羃等性を保つためコンテキスト以外への副作用も禁止する必要があって、&lt;code&gt;FnOnce&lt;/code&gt;でも&lt;code&gt;FnMut&lt;/code&gt;でもなく &lt;del&gt;&lt;code&gt;FnOnce&lt;/code&gt;を&lt;/del&gt; &lt;code&gt;Fn&lt;/code&gt; を要求します。（間違いを&lt;a href=&#34;https://twitter.com/so_zaneli/status/872271289636986880&#34;&gt;指摘された&lt;/a&gt;ので修正しました。）&lt;/p&gt;

&lt;p&gt;実はこのことが若干問題になるケースもあります。データベースのトランザクションなら別に再実行せずにロールバックするだけなので&lt;code&gt;FnOnce&lt;/code&gt;で十分なケースもあります。&lt;code&gt;FnOnce&lt;/code&gt;の方が所有権に寛容なので&lt;code&gt;FnOnce&lt;/code&gt;なら書けるのに&lt;code&gt;Fn&lt;/code&gt;が要求されて、実際には&lt;code&gt;FnOnce&lt;/code&gt;しか必要ない、というケースに何度か直面しました。いくつかのハックで乗り越えられましたが本質的ではない問題なので今後何か変更があるかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;他の問題点&#34;&gt;他の問題点&lt;/h1&gt;

&lt;p&gt;ちょっと説明するのが面倒なのでコードを出さないのですが、計算の合成と実行を分離すると合成の時点では生きているけど実行するときに生きてるか分からないオブジェクトが出てきたりします。
概ねライフタイム境界を明示的に書いてあげると解決するのですが、一部&lt;code&gt;join&lt;/code&gt;などを駆使してハックしないとコンパイルが通らないことがあり面倒です。&lt;/p&gt;

&lt;p&gt;返り値型が複雑なのも問題で、ひとまず&lt;a href=&#34;https://github.com/rust-lang/rust/issues/34511&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;がstableに降ってくるまではそもそも型を書けません（クロージャが匿名なせい）。
&lt;code&gt;Box&lt;/code&gt;に包むにしても少なくとも&lt;code&gt;Ctx&lt;/code&gt;が型引数に増えますし、&lt;code&gt;diesel&lt;/code&gt;と一緒に使うならコネクションのライフタイムも型に入れる必要があったりと&lt;code&gt;Result&lt;/code&gt;や&lt;code&gt;BoxFuture&lt;/code&gt;に比べてやや重くなっています。&lt;/p&gt;

&lt;p&gt;記法についても問題があります。&lt;code&gt;mdo&lt;/code&gt;を使うとある程度は解決しますが、早期リターンがしづらく、頑張って分岐のネストを書かないといけません。これは&lt;code&gt;futures&lt;/code&gt;も抱える問題です。
&lt;code&gt;futures&lt;/code&gt;についてはのジェネレータのパッチを当てることで&lt;a href=&#34;https://github.com/alexcrichton/futures-await&#34;&gt;&lt;code&gt;Result&lt;/code&gt;のように書けるデモ&lt;/a&gt;があるのですが、先述の通り&lt;code&gt;transaction&lt;/code&gt;では&lt;code&gt;FnOnce&lt;/code&gt;ではなく&lt;code&gt;Fn&lt;/code&gt;を取っているのでジェネレータにはエンコードできないのではないかと思っています（あまり調査してないです）。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;transaction-rs&lt;/code&gt;を作ったよ&lt;/li&gt;
&lt;li&gt;トランザクションの契約と責任を型で明示するよ&lt;/li&gt;
&lt;li&gt;コネクションをインジェクトするよ&lt;/li&gt;
&lt;li&gt;コードは複雑になるかもね&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mdo&lt;/code&gt;を使うと複雑さを抑えられるよ&lt;/li&gt;
&lt;li&gt;でもライフタイムとかの問題もあるよ&lt;/li&gt;
&lt;li&gt;将来どうにかするかもね&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;零れ話&#34;&gt;零れ話&lt;/h1&gt;

&lt;p&gt;これを作ったあとに&lt;a href=&#34;http://qiita.com/pab_tech/items/86e4c31d052c678f6fa6&#34;&gt;【ScalaMatsuriセッション当選御礼】ドワンゴ秘伝のトランザクションモナドを解説！ - Qiita&lt;/a&gt;を思い出して読んでみたらほぼ同じものを作ってましたね。
Scalaのpoor-man&amp;rsquo;s type classだと読み辛いですがほぼ同じです。&lt;/p&gt;

&lt;p&gt;相違点は1つには返り値が&lt;code&gt;Result&lt;/code&gt;か&lt;code&gt;Future&lt;/code&gt;か。実際、トランザクションモナドは成功と失敗両方に対してモナドになっている型であれば（こういうの名前ついてないのかな、重モナドとかそんなの）何にでも定義できます。要はトランスフォーマーとして定義可能です。
しかしながらRustには高階多相がなくてトランスフォーマーは書けないのでどちらかを選ぶ必要があり、&lt;code&gt;transaction-rs&lt;/code&gt;では&lt;code&gt;Result&lt;/code&gt;を選びました。外部ライブラリへの依存を減らしたいだとかウェブアプリケーションフレームワークにFutureを受け付けてくれるものがなくてあまり意味がないとかその辺です。
需要が発生したらトランスフォーマーマクロとか作るかもしれません。&lt;/p&gt;

&lt;p&gt;もう1つ相違点があって、fujitaskの方はRead/Writeを型で判別するようになっていますが&lt;code&gt;transaction-rs&lt;/code&gt;にはそういう機能はありません。
fujitaskを読み返すまではそれには思い至りませんでした。
で、存在を知った後に実装したかというと別にしてません。
Rustでも&lt;code&gt;Ctx&lt;/code&gt;に幽霊型を付ければ実装自体は可能なのですがデータベースライブラリがトランザクションの分離レベルの変更をサポートしていないのであまり意味がないからです。
データベース側でサポートされたらやるかもしれません。&lt;/p&gt;

&lt;p&gt;Scalaのfujitaskは便利そうで、概ねこちらもそのようなものなのですが、Rust特有の所有権/ライフタイムによる問題とScalaの&lt;code&gt;for&lt;/code&gt;式相当のものがないという理由でちょっとつらい感じになってます。つらい。&lt;/p&gt;

&lt;h1 id=&#34;追記&#34;&gt;追記&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ノリでジェネリクスにしたけど関連型の方が良かったのでは？&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/872093400417189888&#34;&gt;2017年6月6日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ひとまずmasterはそう書き直しました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>非同期とノンブロッキングとあと何か</title>
      <link>/blog/2017/05/19/hidoukitononburokkingutoatonanika</link>
      <pubDate>Fri, 19 May 2017 20:51:46 +0900</pubDate>
      
      <guid>/blog/2017/05/19/hidoukitononburokkingutoatonanika</guid>
      <description>&lt;p&gt;κeenです。最近同期/非同期、ブロッキング/ノンブロッキング、直接形式/継続渡し形式あたりが混乱してきたので個人的に整理します。
あくまで私個人の理解を纏めただけなので誤謬などに注意して下さい。&lt;/p&gt;

&lt;p&gt;追記: &lt;a href=&#34;https://twitter.com/tanaka_akr&#34;&gt;@tanaka_akr&lt;/a&gt;さんから&lt;a href=&#34;https://twitter.com/tanaka_akr/status/865722507281580032&#34;&gt;指摘&lt;/a&gt;されたのですが、用語の説明が間違っていそうだったので書き直しました。
diffは&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/commit/d46dad5282436eeaa615f31c160f892e6c724403&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;非同期とノンブロッキングはよく混同されます。また、非同期処理の記述形式として直接形式や継続渡し形式などがあります。
私自身違う言葉だなとは思いつつも混同したり違いを忘れたりしています。
非同期もノンブロッキングもナイーブなIOに比べると速い方式だな程度の理解でいてそんなに困らないと思ってますし混同や誤用に目くじらを立てるつもりもありません。
しかしながら3者を区別しないと意味を成さない文脈で3者を混同している技術を何度か見掛けたので（自分の中で）整理しようと思ったのがこの記事を書こうと思ったきっかけです。&lt;/p&gt;

&lt;h1 id=&#34;用語&#34;&gt;用語&lt;/h1&gt;

&lt;p&gt;色々と調べましたが、&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html&#34;&gt;The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition&lt;/a&gt;の定義を使います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_77&#34;&gt;ブロッキング&lt;/a&gt;:
IO操作で、操作する前に待ちが発生するという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_240&#34;&gt;ノンブロッキング&lt;/a&gt;:
IO操作で、操作する前に待ちが発生しそうなら即座に関数から返るという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_378&#34;&gt;同期&lt;/a&gt;:
IO操作で、操作が終わるまでブロックするという性質&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_29&#34;&gt;非同期&lt;/a&gt;:
IO操作で、IO操作を発効したスレッド自体がブロックせずに別のCPU処理を行えるという性質&lt;/li&gt;
&lt;li&gt;IOの多重化: 複数のfdに対して監視を行ない、ブロックせずに操作可能なfdを通知する仕組み。
調べると「複数のfdに対してブロックできる」という記述があるのですがノンブロッキングなオプションもありますよね&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらはどのようにIOを行うかの問題で、 &lt;strong&gt;実行時&lt;/strong&gt; に関係する話題です。&lt;/p&gt;

&lt;p&gt;次に、直接形式と継続渡し形式について。非同期やノンブロッキングなIOをしようと思うと後続の処理、すなわち（限定）継続が必要になる。この（限定）継続をプログラマがどのように渡すかの問題。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Direct_style&#34;&gt;直接形式&lt;/a&gt;は（限定）継続がプログラムには陽には現れず、コンパイラが頑張るかコルーチンなどの言語機能、&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;、&lt;code&gt;do&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;などの構文を用いて実現されます。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Continuation-passing_style&#34;&gt;継続渡し形式&lt;/a&gt;(CPS)はプログラマが陽に（限定）継続を渡すスタイルで、コールバック形式などとも呼ばれます。&lt;/p&gt;

&lt;p&gt;これらは主に言語の問題で、 &lt;strong&gt;コンパイル時&lt;/strong&gt; に関係する話題です。
よく直接形式と同期処理が混同されて「同期プログラミングをすることで非同期プログラミングができます」などの矛盾した一文が書かれがちですが区別しましょう。&lt;/p&gt;

&lt;h2 id=&#34;誰が何を&#34;&gt;誰が何を&lt;/h2&gt;

&lt;p&gt;IO処理の話題はスレッドとカーネルとのやりとりに関することが多い気がしますが、Goのようにユーザランドで実行単位を持つと「ブロックする」といったときにスレッドがブロックするのかgoroutineがブロックするのか分かりづらいですね。
なのでこれ以後は誰が何をブロックするのかを出来る限り明示しながら書きたいと思います。例えば「カーネルがgoroutine Aを実行しているスレッドをブロックする」など。&lt;/p&gt;

&lt;h1 id=&#34;scala&#34;&gt;Scala&lt;/h1&gt;

&lt;p&gt;前職でScalaを書いていました。
Scalaの&lt;code&gt;Future&lt;/code&gt;そのものは&lt;code&gt;flatMap&lt;/code&gt;が関数をとるので継続渡し形式ですが、そのシンタックスシュガーの&lt;code&gt;for&lt;/code&gt;式は直接形式でプログラミングができます。
IOの実体についてはFutureで抽象化されているのでexecutorによります。&lt;/p&gt;

&lt;h1 id=&#34;go&#34;&gt;Go&lt;/h1&gt;

&lt;p&gt;前職の新卒研修で5日ほどGoを書いたことがあります。
多くの言語は比較的シンプルなIOモデルを持つので用語を意識しなくても問題ありませんが、Goは実行時に色々工夫しているので用語をちゃんと区別しないと齟齬が出るようです。
なのでGoを例に理解を深めようと思います。&lt;/p&gt;

&lt;p&gt;まず、Goは実行時に動作するコンポーネントが多いので整理します。
&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;ここの質問&lt;/a&gt;への回答によるとgoroutine実行用のスレッド、スケジューラ、GCに大別してよさそうです。
このうち、IOに関連するのはgoroutine実行用のスレッドとスケジューラなのでGCについては触れません。
あまりよく分かってないのですがスケジューラはgoroutine実行用のスレッド上で呼ばれるための関数（群）なんですかね。&lt;/p&gt;

&lt;p&gt;普段は1スレッドが複数のgoroutineの実行を受け持ち、goroutineが何かしらの理由でブロックしそうなタイミングで別のgoroutineにコンテキストスイッチするようです。
ブロックしそうなタイミングというのはやや古いですが&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;ここ&lt;/a&gt;に書かれてます。
直接形式で書きつつコンテキストスイッチをするということはどうにかして(限定)継続を取り出す必要がありますが、それこそgoroutineですね。goroutine自身でスタックを持つようですし。
C関数を呼ぶときなどはコンパイラが裏で呼び出す前と後に分割しているようです。&lt;/p&gt;

&lt;p&gt;さて、IOについてはファイルIOとネットワークIOで操作が異なるようです。&lt;/p&gt;

&lt;p&gt;ファイルIOでは普通に同期/ブロッキングなシステムコールを発効し、OSがスレッドをブロックする時間が長いようなら別スレッドで元スレッドの持っていたgoroutineを実行するようです。
信頼できる情報が出てこなかったのですが自身で長くなりそうと思っているシステムコールの場合はgoroutineの実行権限（プロセス）を手放してあとは他のプロセスがstealするに任せてる？
ファイルIOは、スレッドがシステムコールでブロックし同期的で、goroutineもシステムコールでブロックし同期的です。ただスケジューラのお陰で他のgoroutineに迷惑がかからないだけです。&lt;/p&gt;

&lt;p&gt;ネットワークIOはポーリングを行なうようです。
スケジューラがfinbrunnableする中でブロックしない方のpoll(Linuxだとepollにノンブロッキングオプションつけたやつかな？)を呼んで、操作可能なfdがあればそれを待っているgoroutineを起こしている模様。
であれば上の分類に従うとネットワークIOはスレッドはブロックせず同期的でIOを多重化し、goroutineはスケジューラからブロックされ同期的で（特別に関数を呼ばなければ）IOの多重化もしません。ただ、操作可能なfdに操作しているのでgoroutineはカーネルからはブロックされません。&lt;/p&gt;

&lt;p&gt;この他にもgoroutine同士のコミュニケーションにチャネルがあります。そこまで重要じゃないかなと思って詳しく調べてないので間違いがあるかもしれないです。
チャネルへの操作は同期的ですね。チャネルへのread/writeはバッファがempty/fullだったらブロックするようなのでgoroutineはチャネルへの操作でブロックします。調べてないですが普通スレッドはブロックしないでしょう。&lt;/p&gt;

&lt;p&gt;チャネルへのselectはあまり情報が出てこなかったのですが恐らくスケジューラがIO可能なチャネルを調べて1つでもあればそれからランダムに選ぶ、1つもなくdefaultもなければスケジューラがgoroutineをブロックするんだと思います。
同期的でIOの多重化をしていますね。&lt;/p&gt;

&lt;p&gt;Goroutineやスレッドレベルでは同期的ですが、Goのプロセス全体でみるとGOMAXPROC分のスレッドは常にCPUを使っているので非同期なんですかね。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Goの件について表にするとこうですかね。非同期処理をやろうと思ったら大抵処理単位を分ける必要がありますが、Goの最小処理単位がgoroutineなのでよく考えたらgoroutineが全て同期するのはあたりまえですね。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;スレッド&lt;/th&gt;
&lt;th&gt;goroutine&lt;/th&gt;
&lt;th&gt;Goプロセス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ファイル&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;非同期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ネットワーク&lt;/td&gt;
&lt;td&gt;ノンブロック/同期/多重化&lt;/td&gt;
&lt;td&gt;ノンブロック/同期/&lt;/td&gt;
&lt;td&gt;非同期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルRW&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/同期/&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;チャネルselect&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ブロック/同期/多重化&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ということでGoのIOについては「goroutineを直接形式で同期的な書き方をしても裏でスケジューラが動いているからCPUを効率的に使えてGoプロセス全体でみれば非同期」になるんですかね。&lt;/p&gt;

&lt;p&gt;Goに詳しい人、コメントや誤り訂正お願いします。&lt;a href=&#34;https://github.com/KeenS/KeenS.github.io/issues&#34;&gt;GitHubのイシュー&lt;/a&gt;とか使えば良い気がします。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/36112445/golang-blocking-and-non-blocking&#34;&gt;multithreading - Golang blocking and non blocking - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/os/file_unix.go?s=#L224&#34;&gt;src/os/file_unix.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/proc.go?s=#L1795&#34;&gt;src/runtime/proc.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/faq#goroutines&#34;&gt;Frequently Asked Questions (FAQ) - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/17953269/go-routine-blocking-the-others-one&#34;&gt;channel - go routine blocking the others one - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/cgocall.go&#34;&gt;src/runtime/cgocall.go - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/32538438/how-does-channel-blocking-work-in-go&#34;&gt;select - How does channel blocking work in Go? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/ref/spec#Select_statements&#34;&gt;The Go Programming Language Specification - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quora.com/How-does-the-Go-runtime-work&#34;&gt;How does the Go runtime work? - Quora&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Rust風にデザインパターン23種</title>
      <link>/blog/2017/05/06/rustkazenidezainpata_n23tane</link>
      <pubDate>Sat, 06 May 2017 21:59:30 +0900</pubDate>
      
      <guid>/blog/2017/05/06/rustkazenidezainpata_n23tane</guid>
      <description>&lt;p&gt;κeenです。
GoFのデザインパターンは有名ですが、言語機能によっては単純化できたりあるいは不要だったりするのでRust風に書き換えたらどうなるか試してみます。

発端はこのツイート。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;デザインパターン、古いJavaの機能の足りなさのワークアラウンド的なテクニックも含まれてるからあまり宜しくないんだよね。enumやクロージャで十分なのもいくつかある。&lt;br&gt;&lt;br&gt;Rustで写経、デザインパターン23種 - Qiita&lt;a href=&#34;https://t.co/MhpS3Z2OlF&#34;&gt;https://t.co/MhpS3Z2OlF&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/860635079600513024&#34;&gt;2017年5月5日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;一応誤解のないように説明しておくと、該当のQiitaの記事に不満がある訳ではなくてGoFのデザインパターンついての言及です。&lt;/p&gt;

&lt;p&gt;リンク先のコードで十分な時にはここでは流すのでリンク先も同時に参照下さい。
また、比較しやすいようにサンプルコードはリンク先のものに則って書きます。&lt;/p&gt;

&lt;p&gt;一応デザインパターンの教科書として結城先生の本を参照しつつ書いていきます。&lt;/p&gt;

&lt;h1 id=&#34;command-パターン&#34;&gt;Command パターン&lt;/h1&gt;

&lt;p&gt;列挙型を使うところです。
Javaにまともなenumがないのでクラスが使われていますが、列挙型があるならそちらの方がデータとコードの分離ができて見通しがいいです。また、コマンドが1つの型に収まるのでトレイトオブジェクトを作る必要がなくなります。&lt;/p&gt;

&lt;p&gt;比較的マイナーな変更です。&lt;/p&gt;

&lt;p&gt;Lispだとクロージャで解決したりしますが、Rustだと列挙型の方がしっくりくるかなと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Command&amp;lt;T&amp;gt; {
    fn execute(&amp;amp;self, &amp;amp;mut T);
    fn undo(&amp;amp;self, &amp;amp;mut T);
}



struct Invoker&amp;lt;&#39;a, Cmd, T: &#39;a&amp;gt; {
    commands: Vec&amp;lt;Cmd&amp;gt;,
    target: &amp;amp;&#39;a mut T,
    current_index: usize,
}


impl&amp;lt;&#39;a, Cmd, T&amp;gt; Invoker&amp;lt;&#39;a, Cmd, T&amp;gt; {
    fn new(t: &amp;amp;&#39;a mut T) -&amp;gt; Self {
        Invoker {
            commands: Vec::new(),
            target: t,
            current_index: 0,
        }
    }


    fn target(&amp;amp;self) -&amp;gt; &amp;amp;T {
        self.target
    }

    fn append_command(&amp;amp;mut self, c: Cmd) {
        self.commands.push(c);
    }
}

impl&amp;lt;&#39;a, Cmd, T&amp;gt; Invoker&amp;lt;&#39;a, Cmd, T&amp;gt;
    where Cmd: Command&amp;lt;T&amp;gt;
{
    fn execute_command(&amp;amp;mut self) {
        if self.commands.len() &amp;lt;= self.current_index {
            // Nothing to do.
            return;
        }

        let c = &amp;amp;self.commands[self.current_index];
        let t = &amp;amp;mut *self.target;
        c.execute(t);

        self.current_index += 1;
    }

    fn execute_all_commands(&amp;amp;mut self) {
        for _ in self.current_index..self.commands.len() {
            self.execute_command();
        }
    }

    fn undo(&amp;amp;mut self) {
        if 0 == self.current_index {
            return;
        }

        self.current_index -= 1;

        let c = &amp;amp;self.commands[self.current_index];
        let t = &amp;amp;mut *self.target;
        c.undo(t);
    }
}


#[derive(Debug, Eq, PartialEq)]
struct Robot {
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
}


impl Robot {
    fn new() -&amp;gt; Robot {
        Robot {
            x: 0,
            y: 0,
            dx: 0,
            dy: 1,
        }
    }

    fn move_forward(&amp;amp;mut self) {
        self.x += self.dx;
        self.y += self.dy;
    }

    fn set_direction(&amp;amp;mut self, d: (i32, i32)) {
        self.dx = d.0;
        self.dy = d.1;
    }

    fn get_direction(&amp;amp;self) -&amp;gt; (i32, i32) {
        (self.dx, self.dy)
    }
}

enum RoboCommand {
    MoveForward,
    TurnRight,
    TurnLeft,
}

impl Command&amp;lt;Robot&amp;gt; for RoboCommand {
    fn execute(&amp;amp;self, r: &amp;amp;mut Robot) {
        use RoboCommand::*;
        match *self {
            MoveForward =&amp;gt; r.move_forward(),
            TurnRight =&amp;gt; {
                let (dx, dy) = r.get_direction();
                r.set_direction((dy, -dx))
            }
            TurnLeft =&amp;gt; {
                let (dx, dy) = r.get_direction();
                r.set_direction((-dy, dx));
            }

        }
    }
    fn undo(&amp;amp;self, r: &amp;amp;mut Robot) {
        use RoboCommand::*;
        match *self {
            MoveForward =&amp;gt; {
                let c1 = TurnRight;
                c1.execute(r);
                c1.execute(r);
                self.execute(r);
                c1.execute(r);
                c1.execute(r);
            }
            TurnRight =&amp;gt; {
                let c = TurnLeft;
                c.execute(r);
            }
            TurnLeft =&amp;gt; {
                let c = TurnRight;
                c.execute(r);

            }

        }
    }
}



fn main() {
    let mut r = Robot::new();

    let mut invoker = Invoker::new(&amp;amp;mut r);
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 0,
                   dy: 1,
               });

    {
        use RoboCommand::*;
        invoker.append_command(TurnRight);
        invoker.append_command(TurnLeft);
        invoker.append_command(MoveForward);
    }

    invoker.execute_all_commands();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 1,
                   dx: 0,
                   dy: 1,
               });

    invoker.undo();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 0,
                   dy: 1,
               });

    invoker.undo();
    assert_eq!(*invoker.target(),
               Robot {
                   x: 0,
                   y: 0,
                   dx: 1,
                   dy: 0,
               });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;stateパターン&#34;&gt;Stateパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。トレイトオブジェクトを使う代表的なケースだと思います。。
あるいは列挙型を使う可能性もあります。&lt;/p&gt;

&lt;h1 id=&#34;strategyパターン&#34;&gt;Strategyパターン&lt;/h1&gt;

&lt;p&gt;参照先でも説明されていますが、Rustにはクロージャがあるので不要です。&lt;/p&gt;

&lt;h1 id=&#34;template-methodパターン&#34;&gt;Template Methodパターン&lt;/h1&gt;

&lt;p&gt;そもそもトレイトを使った普通のプログラミングなのでRustでわざわざ名前をつけるほどかな？と個人的には思いますがあえて書くなら参照先のままです。
あるいはものによっては高階関数でも。&lt;/p&gt;

&lt;p&gt;個人的にはトレイトオブジェクトを作るより関連型を使った方が好みです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait AbstractFactory&amp;lt;&#39;a&amp;gt; {
    type ProdX: ProductX;
    type ProdY: ProductY;
    fn create_product_x(&amp;amp;self) -&amp;gt; Box&amp;lt;ProdX + &#39;a&amp;gt;;
    fn create_product_y(&amp;amp;self) -&amp;gt; Box&amp;lt;ProdY + &#39;a&amp;gt;;
}

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;mementoパターン&#34;&gt;Mementoパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです&lt;/p&gt;

&lt;h1 id=&#34;observerパターン&#34;&gt;Observerパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです&lt;/p&gt;

&lt;h1 id=&#34;visitorパターン&#34;&gt;Visitorパターン&lt;/h1&gt;

&lt;p&gt;参照先では簡単な例なので分かりづらいのですが、列挙型を使うところです。
まともな列挙型がない+シングルディスパッチしかなく引数はオーバーロードという二重苦によって生まれたパターンであり、まともな列挙型か多重ディスパッチがあれば複雑怪奇なプログラムは書かなくて済みます。&lt;/p&gt;

&lt;p&gt;ここでは参照先とは違ってもう少し複雑な例を出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Visitor&amp;lt;T&amp;gt; {
    fn visit(&amp;amp;mut self, &amp;amp;T);
}

enum Entity {
    File(String),
    Dir(String, Vec&amp;lt;Entity&amp;gt;),
}

struct ConcreteFileVisitor;

impl Visitor&amp;lt;Entity&amp;gt; for ConcreteFileVisitor {
    fn visit(&amp;amp;mut self, e: &amp;amp;Entity) {
        use Entity::*;
        match *e {
            File(ref name) =&amp;gt; println!(&amp;quot;file: {}&amp;quot;, name),
            Dir(ref name, ref files) =&amp;gt; {
                println!(&amp;quot;dir: {}&amp;quot;, name);
                for file in files {
                    self.visit(file)
                }
            }
        }
    }
}

fn main() {
    use Entity::*;
    let e = Dir(&amp;quot;/&amp;quot;.to_string(),
                vec![File(&amp;quot;etc&amp;quot;.to_string()), File(&amp;quot;usr&amp;quot;.to_string())]);
    let mut visitor = ConcreteFileVisitor;
    visitor.visit(&amp;amp;e);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特段パターンというほどの処理をしている感じがしませんね。&lt;/p&gt;

&lt;h1 id=&#34;iteratorパターン&#34;&gt;Iteratorパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;mediatorパターン&#34;&gt;Mediatorパターン&lt;/h1&gt;

&lt;p&gt;だいたい参照先のままです。複雑なことをしようと思うと&lt;code&gt;Colleague&lt;/code&gt;が複数種類出てきて列挙型かトレイトオブジェクトが必要になりそうな気がします。&lt;/p&gt;

&lt;h1 id=&#34;interpreterパターン&#34;&gt;Interpreterパターン&lt;/h1&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h1 id=&#34;builderパターン&#34;&gt;Builderパターン&lt;/h1&gt;

&lt;p&gt;あまりここまで抽象化してるのは見たことありませんがやるとしたら参照先のままです。
そもそもRustには継承がないので抽象化する意義があまりなく、型固有のBuilderパターンで十分です。&lt;/p&gt;

&lt;h1 id=&#34;prototypeパターン&#34;&gt;Prototypeパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;factoryパターン&#34;&gt;Factoryパターン&lt;/h1&gt;

&lt;p&gt;クロージャで十分です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Product {
    fn convert(&amp;amp;self, String) -&amp;gt; String;
}


struct Factory;

impl Factory {
    fn convert&amp;lt;P, F&amp;gt;(&amp;amp;self, s: String, create_product: F) -&amp;gt; String
        where P: Product,
              F: FnOnce() -&amp;gt; P
    {
        create_product().convert(s)
    }
}


struct ConcreteProductX;
impl Product for ConcreteProductX {
    fn convert(&amp;amp;self, s: String) -&amp;gt; String {
        s.to_uppercase()
    }
}


fn main() {
    let f = Factory;
    println!(&amp;quot;{}&amp;quot;,
             f.convert(&amp;quot;hogehoge piyopiyo&amp;quot;.to_string(), || ConcreteProductX))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;abstractfactoryパターン&#34;&gt;AbstractFactoryパターン&lt;/h1&gt;

&lt;p&gt;そもそもここまでやる？というのは置いといてやるとしたら参照先のままかなぁと思います。&lt;/p&gt;

&lt;p&gt;TemplateMethodパターンでも述べた通り個人的には関連型を使う方が好みです。&lt;/p&gt;

&lt;h1 id=&#34;chain-of-responsibility-cor-パターン&#34;&gt;Chain of Responsibility/CoR パターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;singletonパターン&#34;&gt;Singletonパターン&lt;/h1&gt;

&lt;p&gt;そもそもアンチパターンです。分かりづらいグローバル変数なだけです。あえてRustでやるとしたら&lt;a href=&#34;https://github.com/rust-lang-nursery/lazy-static.rs&#34;&gt;lazy_static&lt;/a&gt;かなと思います。&lt;/p&gt;

&lt;h1 id=&#34;adapterパターン&#34;&gt;Adapterパターン&lt;/h1&gt;

&lt;p&gt;これは捉え方が2種類あるかなーと思います。。&lt;/p&gt;

&lt;p&gt;1つにはクラスの定義時にしかインターフェースを実装できない窮屈な言語仕様へのワークアラウンドとして。
この捉え方では参照先のコードようにただトレイトを実装してしまえば終わりです。&lt;/p&gt;

&lt;p&gt;もう1つにはラッパーオブジェクトとして。&lt;code&gt;std::fs::File&lt;/code&gt;の実装とかがそれっぽいと思います。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct File {
    inner: fs_imp::File,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bridgeパターン&#34;&gt;Bridgeパターン&lt;/h1&gt;

&lt;p&gt;そもそも機能の追加とAPIの抽象化をどちらも継承に押し込める言語仕様が悪い。
それにRustでは継承しないので関係ないです。&lt;/p&gt;

&lt;h1 id=&#34;proxyパターン&#34;&gt;Proxyパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。&lt;/p&gt;

&lt;h1 id=&#34;facadeパターン&#34;&gt;Facadeパターン&lt;/h1&gt;

&lt;p&gt;参照先のままです。Rustにはモジュールや可視性の制御があって特別意識することなく普段からやっていることなのであまり名前をつけるほどのことではないと思ってます。&lt;/p&gt;

&lt;h1 id=&#34;flyweightパターン&#34;&gt;Flyweightパターン&lt;/h1&gt;

&lt;p&gt;所有権があるのでRustだとちょっと難しいパターンです。
参照だけなら参照先のように&lt;code&gt;HashMap&lt;/code&gt;にいれるか、オブジェクトを区別しないなら&lt;code&gt;Vec&lt;/code&gt;にいれるかなと思います。&lt;/p&gt;

&lt;p&gt;因みにLispとかでは&lt;code&gt;intern&lt;/code&gt;という名前で呼ばれてると思います。&lt;/p&gt;

&lt;h1 id=&#34;compositeパターン&#34;&gt;Compositeパターン&lt;/h1&gt;

&lt;p&gt;ただの列挙型の再実装です。&lt;/p&gt;

&lt;h1 id=&#34;decoratorパターン&#34;&gt;Decoratorパターン&lt;/h1&gt;

&lt;p&gt;よくあるやつです。参照先のコードの他、&lt;code&gt;std::io::WriteBuf&lt;/code&gt;のようなものが代表的です。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;デザインパターンをdisろうと思って書いたのですが案外多くのケースで便利でした。Rustで不要なものは10本指で数えられる程度でしたね。すごい。&lt;/p&gt;

&lt;p&gt;因みにLisperでAIの研究者（確か今GoogleのAI研究所の所長）のPeter Norvigは&lt;a href=&#34;http://www.norvig.com/design-patterns/design-patterns.pdf&#34;&gt;Design Patterns in Dynamic Languages&lt;/a&gt;で16個はLispの機能を使えばパターンという程のものではなくなると言ってます。
それぞれどの機能でどれが不要になるかを解説しているのですが、Rustは高階関数とモジュールの分に加えて列挙型の分で不要になってるかなと思います。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>メモリとスタックとヒープとプログラミング言語</title>
      <link>/blog/2017/04/30/memoritosutakkutohi_puto</link>
      <pubDate>Sun, 30 Apr 2017 09:09:50 +0900</pubDate>
      
      <guid>/blog/2017/04/30/memoritosutakkutohi_puto</guid>
      <description>&lt;p&gt;κeenです。
今回の話は別にRustに限ったものではないのですが、よくRustを始めたばかりの人がスタックとヒープが分からないと言っているのをみかけるので少しメモリの話をしますね。
厳密な話というよりは雰囲気を掴んで欲しいという感じです。
&lt;/p&gt;

&lt;h1 id=&#34;メモリは配列&#34;&gt;メモリは配列&lt;/h1&gt;

&lt;p&gt;プログラム（プロセス）のメモリには実行するプログラム（機械語）やグローバル変数/定数、関数の引数やローカル変数、その他プログラムで使うデータ領域などを置きます。
プロセスに割り当てられるメモリというのは、1つの巨大なのっぺらな配列みたいなものです。サイズも決まってます。64bit OSなら2^64 byteです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0                        2^64
+---------------     ----+
|  |  |  |  |    ~~   |  |
+---------------     ----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは仮想的なメモリなので実際の物理メモリに2^64 byteの配列がドンと確保される訳ではなくて、使った(使いたい)分だけ占有します。OSが賢いですね。&lt;/p&gt;

&lt;p&gt;ただまあこれだけだと使いづらいのである程度区切って「この辺にこれ系のデータを置く」みたいな使われ方をします。
プログラムを置く &lt;em&gt;text領域&lt;/em&gt; 、初期化されたグローバル変数を置く &lt;em&gt;data領域&lt;/em&gt; 、初期化されていない（データ領域だけ確保された）グローバル変数を置く &lt;em&gt;bss領域&lt;/em&gt; 、関数の引数やローカル変数を置く &lt;em&gt;stack領域&lt;/em&gt; 、プログラムのデータを置く &lt;em&gt;heap領域&lt;/em&gt; です。
グローバル変数って言っちゃいましたけど実はそれに限らなくて、例えばRustの文字列リテラルなんかもdata領域に置かれます。&lt;/p&gt;

&lt;p&gt;text、 data、 bssは実行する前からサイズが分かっているので問題ないのですが、heapとstackはプログラムの実行中にサイズが変わるものなのでどこにどう置いたら上手く配分できるか分かりませんね。
そこで以下のようにstackとheapを両端に配置して使いたい分だけ使用領域を伸ばせるようになってます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 簡略化するために嘘ついてたりしますがまあ、だいたい合ってます
+-------+ 2^64
| stack |
|   |   |
|   V   |
|       |
|   ^   |
|   |   |
| heap  |
+-------+
| bss   |
+-------+
| data  |
+-------+
| text  |
+-------+ 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;text、data、bssはそのままなのでstackとヒープについて話します。&lt;/p&gt;

&lt;h1 id=&#34;stackと関数&#34;&gt;Stackと関数&lt;/h1&gt;

&lt;p&gt;Stackは関数呼び出しのために使われます。
ネストした関数の呼び出しの系譜を関数の「コールスタック」と呼んだりするように、関数呼び出しはスタック構造になってますね。
なのでスタックを用いて管理すると具合が良いのです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+
| func 1 |
+--------+
| func 2 |
+--------+
| func 3 |
+--------+
| func 4 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、折角特別に用意したこのstackにはただの関数の呼び出し履歴だけではなく他のデータも入れたいですよね？
例えば関数ローカルな変数だとか。データの次にまた別のデータが置かれるのでサイズを変えたりはできませんが。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+
| func 1 |
|--------|
| data 1 |
|--------|
| data 2 |
+--------+
| func 2 |
|--------|
| data   |
| ...    |
+--------+
| func 3 |
|--------|
| data   |
| ...    |
+--------+
| func 4 |
|--------|
| data   |
| ...    |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;データの解放は簡単です。スタックを巻き戻せば自動的に消えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+
| func 1 |
|--------|
| data 1 |
|--------|
| data 2 |
+--------+
| func 2 |
|--------|
| data   |
| ...    |
+--------+
|        |
|        |
|        |
|        |
|        |
|        |
|        |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逆にいうと関数から抜けたら消えてしまうということでもありますが。&lt;/p&gt;

&lt;p&gt;という訳で、 「条件が限られるけど高速に扱えるデータ領域」がstackです。&lt;/p&gt;

&lt;p&gt;因みに、メモリは使った分だけしか確保されないと言いましたが、スタックを伸ばしすぎると確保されていない領域に到達してエラーが出ます。スタックオーバーフローです。&lt;/p&gt;

&lt;h1 id=&#34;heapとデータ&#34;&gt;Heapとデータ&lt;/h1&gt;

&lt;p&gt;heapにはstackに置けないデータが置かれます。
これの扱いは少し面倒です。何故ならデータの確保や解放の順番がバラバラなので、歯抜けな状態になってしまうからです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|        |
| data 4 |
+--------+
| data 3 |
+--------+
|        |
+--------+
| data 1 |
+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで「どかが使われていてどこが空いているか」を管理するシステムを導入します。
C言語では&lt;code&gt;malloc&lt;/code&gt;という関数をインターフェースとして管理しているので管理システム自体もmallocと呼ぶことが多いようです。
この実装方法はフリーリストを使った単純なものからサイズ毎のバケツを用意して〜といった方法まで様々にあるので気になる人は調べてみて下さい。
大抵、「メモリがこのくらい欲しい」と言われたら今管理している中からそれっぽい空きを捜してそこを渡してあげるような作りになっています。&lt;/p&gt;

&lt;p&gt;ちなみにこの領域管理には(mallocの場合)そこそこのコストが掛かります。でもその代わり自由に確保/解放できる他、サイズの変更もできるので自由度が高いです。&lt;/p&gt;

&lt;p&gt;という訳で「自由度が高いが少しコストがかかるデータ領域」がheapです。&lt;/p&gt;

&lt;h1 id=&#34;プログラミング言語とメモリ&#34;&gt;プログラミング言語とメモリ&lt;/h1&gt;

&lt;p&gt;では、具体的な言語がどのようにメモリを使っているかを簡単に紹介します。&lt;/p&gt;

&lt;p&gt;1つ注意しないといけないのが、ガーベジコレクション（GC）のある言語ではheapの上に構築した自前のメモリ管理システムのことをヒープと呼んでいたりするので両者をちゃんと区別しましょう。
同じく、スタックの使い方も言語独自でコールスタックと引数のスタックを分けたりもするので気をつけましょう。&lt;/p&gt;

&lt;h2 id=&#34;c言語&#34;&gt;C言語&lt;/h2&gt;

&lt;p&gt;先程説明したとおり、データ領域にheapを、関数呼び出しや関数ローカルなデータにstackを使っています。&lt;/p&gt;

&lt;p&gt;メモリの領域管理は先述の&lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;などをプログラマが手で書きます。手で管理するのでバグります。&lt;/p&gt;

&lt;h2 id=&#34;ruby&#34;&gt;Ruby&lt;/h2&gt;

&lt;p&gt;データ領域にはheapにmallocで確保した領域にヒープを確保し、その上にメモリ管理システム(GC)を構築して管理しています。&lt;/p&gt;

&lt;p&gt;関数呼び出しにはstackではなくheapに確保した自前のスタックを用意しています。
stackを使わないのはどうしてもC言語がstackを使うのでRubyも交ぜて使ってしまうと(Ruby自体C言語の上で動いていますね)問題が起こるだとかデータ構造として扱いづらいだとかGCとの兼ね合いだとかの理由だと思います。
また、そもそもRubyのメソッドとC言語の関数は別物という話もあります。&lt;/p&gt;

&lt;p&gt;また、実行用にスタックはありますが、データの実体はRubyのヒープに置かれます。Rubyのプログラムから高速なスタック領域を使うことができないのです。残念ですね。&lt;/p&gt;

&lt;p&gt;メモリの領域管理にはGCシステムを採用し、メモリ管理をユーザがすることはありません。
GCはmallocに少しデータを足したようなMark and Sweepです。メモリ確保はほぼmallocと同じで、気が向いたときに使っているデータにマークを付けていって、マークの付いていないデータを一括でfreeしてくれます。
メモリ確保（やポインタの扱い）がmallocに似ているのでC言語と協調するときに楽です。RubyはNative Extentionが作りやすいように設計されていますね。&lt;/p&gt;

&lt;p&gt;1つ注意しておくと、Rubyを実行するときにもメモリにtextやbss、dataなどの領域がありますが、それは「Rubyを実行するVMのための領域」であって「実行しているRubyスクリプトのための領域」ではありません。&lt;/p&gt;

&lt;h2 id=&#34;pythonやphp&#34;&gt;PythonやPHP&lt;/h2&gt;

&lt;p&gt;Rubyと同じようにヒープもスタックもheapに確保していると思います（面倒なのでソースを追っていない）。
メモリ管理システムはGCを使いますが、Rubyとは違って参照カウント方式を採用しています。&lt;/p&gt;

&lt;p&gt;参照カウントは、メモリ確保はmallocに似ていますが、確保した後の扱いが異なります。
値を参照する度にカウントを増やし、使わなくなったら参照を減らし、参照が0になったらfreeされます。
言語レベルでは意識するすることはありませんが、C言語のレイヤーでは一々参照の操作をしてあげないといけないので手間がかかります（たまに扱いを間違ってバグります）。
また、循環参照という問題もあって、たまに解放されないメモリがあったりします。（そのために結局たまにMark and Sweepのようなものが必要だったりします）&lt;/p&gt;

&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;

&lt;p&gt;Rubyと同じようにヒープもスタックもheapに確保しています(JVMのメモリについて調べてみると色々出てきます)。
30億のデバイスで走らせるための工夫ですね。&lt;/p&gt;

&lt;p&gt;同じくGCを使いますが、今度はCopy GC方式を採用しています（厳密にいうとHotSpot VMでの複数種類ある方式のうちの1つですが）。
Copy GCは面白くて、ヒープを2つに分割します。同時に使うのは1つだけです。メモリを確保するときは、使われていない領域などは無視して新たなスペースを確保します。
これはわざわざ空き領域を捜す必要がないので非常に高速です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------+
| data1 | data 2 | data 3 | -&amp;gt;    |
+---------------------------------+
+---------------------------------+
|                                 |
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてメモリが一杯になったら使っているデータだけもう1つの領域にコピーします。このとき、使っていなかった分は詰めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------+
|       | data 2 |                |
+---------------------------------+
+---------------------------------+
| data1 | data 3 | -&amp;gt;             |
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使っていなかったdata 2の存在を忘れて、2つを入れ替えたらメモリの回収完了です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------+
| data1 | data 3 | -&amp;gt;             |
+---------------------------------+
+---------------------------------+
|                                 |
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ヒープが半分しか使えないだとかデータが移動してしまうので扱いが難しいだとかの問題はあるのですが、確保が非常に高速で解放もかなり速い方式です。&lt;/p&gt;

&lt;p&gt;この方式はJavaの他にOCamlやHaskellなどの関数型言語でよく使われます。
データを頻繁にアロケートするのでメモリ確保が高速なこの方式が好まれるようです。&lt;/p&gt;

&lt;h2 id=&#34;rust&#34;&gt;Rust&lt;/h2&gt;

&lt;p&gt;RustはC言語と同じくデータ領域にheapを、関数呼び出しや関数ローカルなデータにstackを使っています。&lt;/p&gt;

&lt;p&gt;メモリの領域管理は&lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;などをコンパイラが自動で発効してくれます。なのでプログラマが自分で管理する必要はありません。&lt;/p&gt;

&lt;h1 id=&#34;高速なメモリの使い方&#34;&gt;高速なメモリの使い方&lt;/h1&gt;

&lt;p&gt;まず、一番速い方法は「そもそもメモリを確保しない」です。
これはコストが掛からないので高速です。
「何をふざけたことを」と思うかもしれませんが、プログラミングする上で「余計に確保しない」を意識するという意味で重要です。&lt;/p&gt;

&lt;p&gt;次はstackを使うと高速です。これはそもそもstackを意識して使える言語でないと選べない方法ですね。&lt;/p&gt;

&lt;p&gt;最後の手段としてheapを使います。&lt;/p&gt;

&lt;p&gt;GCのある言語ではGCの特性によってヒープの使い方も考える必要があります。
Mark and Sweepは生死に関らず確保したオブジェクトの数に比例してメモリ解放コストが掛かりますが、Copy GCでは生きているオブジェクトに比例してコストが掛かりますので、生きているオブジェクトを減らすと速くなります。
例えば使わないけど変数に束縛されているものがあるなら変数のスコープを狭めるだとか変数にnullを代入するだとか。
よほどメモリのせいで遅くなっていない限りあまりやりませんが（ゲームの人はよくやるらしい？）。&lt;/p&gt;

&lt;p&gt;また、最近の多くのGC（RubyもJavaも）には世代別GCといって、新しいデータと古いデータを分けて管理する方式が採用されているので作ったデータをすぐさま使ってすぐさま不要にすると速くなったりします。
例えばデータ列に対して個々のデータに処理1、2、3を適用したいなら処理1のループ、2のループ、3のループ、とするよりもループの中で処理1、2、3と適用した方が速くなります。
最近Scalaの次期コンパイラが高速化のためにそのような構成（phase fusioning）にしたらしいですね。
使っている言語でOld領域、New領域などの単語を聞いたことがあるなら多分世代別GCが使われています。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;スタックとヒープの話、そしてなぜスタックとヒープを意識したいかを説明しました。
ついでに、比較のためにGCのある言語についても少しだけ紹介しました。
けっこうふわふわとした説明なので「分かった気分」になりたいだけならこの記事で十分かと思いますが、もう少し踏み込んだことが知りたければ個別に調べてみて下さい。
また、メモリレイアウトについてはおおまかには合っているものの、結構嘘ついているのであまり鵜呑みにしないで下さい。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://th0x4c.github.io/blog/2012/10/10/os-virtual-memory-map/&#34;&gt;仮想メモリ空間のメモリマップを調べる - th0x4c 備忘録&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.valinux.co.jp/technologylibrary/document/linux/malloc0001/&#34;&gt;malloc(3)のメモリ管理構造 | VA Linux Systems Japan株式会社&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ruby/ruby/blob/trunk/gc.c#L7649&#34;&gt;rubyのメモリ確保にmallocを使っている部分&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ruby/ruby/blob/trunk/vm_core.h#L705&#34;&gt;rubyのスタックの定義部分&lt;/a&gt;。これは引数スタックかな？コールスタックどこだろう…&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Cargoのサブプロジェクトとreplace</title>
      <link>/blog/2017/04/05/cargonosabupurojiekutotoreplace</link>
      <pubDate>Wed, 05 Apr 2017 20:46:26 +0900</pubDate>
      
      <guid>/blog/2017/04/05/cargonosabupurojiekutotoreplace</guid>
      <description>&lt;p&gt;κeenです。最近Cargoのreplace機能を使おうとしてハマったのでメモを残しておきます。&lt;/p&gt;

&lt;p&gt;
最近何箇所かで喋ったのでご存知の方もいらっしゃるかと思いますが、Cargoにはワークスペース機能があります。
fat repositoryスタイルに便利な機能で、1つのディレクトリ下に複数のサブプロジェクトを配置しつつ&lt;code&gt;target/&lt;/code&gt;は共有するのでマイクロプロジェクトのモジュール性とモノリシックプロジェクトのコンパイルの速さを実現することが出来ます。&lt;/p&gt;

&lt;p&gt;さて、問題になるのはクレートを公開するときの依存関係の記述です。
サブプロジェクト同士で依存し合っているので&lt;code&gt;Cargo.toml&lt;/code&gt;には&lt;code&gt;my-project-lib = {path = &amp;quot;../my-project-lib&amp;quot;}&lt;/code&gt; のような依存の記述がある筈です。
しかしながらローカルのクレートに依存していると&lt;code&gt;crates.io&lt;/code&gt;に公開は出来ません。
そこで今回はそれをどうにかするお話。&lt;/p&gt;

&lt;h1 id=&#34;replace&#34;&gt;replace&lt;/h1&gt;

&lt;p&gt;Cargoには&lt;a href=&#34;http://doc.crates.io/manifest.html#the-replace-section&#34;&gt;replace&lt;/a&gt;という機能があります。
特定のライブラリの特定のバージョンを、crates.ioにあるものではなくてユーザが指定した場所にあるものを使うように指示します。
&lt;a href=&#34;http://doc.crates.io/specifying-dependencies.html#overriding-dependencies&#34;&gt;Specifying Dependencies&lt;/a&gt;のドキュメントによると、以下のように使えます。&lt;/p&gt;

&lt;p&gt;例えば&lt;code&gt;uuid&lt;/code&gt;クレートを使っているときにそれが依存している&lt;code&gt;rand&lt;/code&gt;クレートにバグを見付けて修正し、修正した結果を試したいとします。
その時にreplaceは以下のように使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# ワークスペースの親プロジェクト
...

[replace]
&amp;quot;rand:0.3.14&amp;quot; = { path = &amp;quot;./rand&amp;quot; }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# ワークスペースの子プロジェクト

[package]
name = &amp;quot;my-awesome-crate&amp;quot;
version = &amp;quot;0.2.0&amp;quot;
authors = [&amp;quot;The Rust Project Developers&amp;quot;]

[dependencies]
uuid = &amp;quot;0.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;間接的に依存してる&lt;code&gt;rand:0.3.14&lt;/code&gt;を、crates.ioにあるものではなく指定したパスにあるものを使うように指示しています。&lt;/p&gt;

&lt;p&gt;この仕組みを使って先のローカルパス問題を解決出来ないでしょうか。すなわち、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# 子プロジェクト
[dependencies]
my-project-lib = &amp;quot;0.1.0&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、見た目上はcrates.ioにあるものに依存しておきつつ実際は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# 親プロジェクト
[replace]
&amp;quot;my-project-lib:0.1.0&amp;quot; = { path = &amp;quot;./my-project-lib&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように実際の依存先をローカルのパスに向ければ問題を解決できないでしょうか。&lt;/p&gt;

&lt;p&gt;この答えは、半分no、半分yesになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;replace&lt;/code&gt;はあくまでcrates.ioにあるものを置き換えるのでまだ公開していないプロジェクトに対しては使えません。
一方、一度crates.ioに公開してしまえば上記のテクニックは可能になります。&lt;/p&gt;

&lt;p&gt;なので一番最初にcrates.ioに公開する時の手順はやや煩雑になります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;(ローカルサブプロジェクトへの依存の記述は&lt;code&gt;path = &amp;quot;...&amp;quot;&lt;/code&gt;のまま)&lt;/li&gt;
&lt;li&gt;どのプロジェクトにも依存しないローカルサブプロジェクトを公開する&lt;/li&gt;
&lt;li&gt;既に公開されたローカルサブプロジェクトへの依存は順次&lt;code&gt;replace&lt;/code&gt;に書き換える&lt;/li&gt;
&lt;li&gt;ローカルパスへの依存のなくなったローカルプロジェクトから順に公開していく&lt;/li&gt;
&lt;li&gt;全てのサブプロジェクトのローカルサブプロジェクトへの依存が&lt;code&gt;replace&lt;/code&gt;に置き換わったら以後はそのまま使える。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;このようなテクニックは例えばdieselなどで&lt;a href=&#34;https://github.com/diesel-rs/diesel/blob/master/Cargo.toml#L21&#34;&gt;使われています&lt;/a&gt;。
この辺、改善あるといいですね。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>関数型プログラマからみたRust</title>
      <link>/blog/2017/04/04/kansuugatapuroguramakaramitarust</link>
      <pubDate>Tue, 04 Apr 2017 21:38:57 +0900</pubDate>
      
      <guid>/blog/2017/04/04/kansuugatapuroguramakaramitarust</guid>
      <description>&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;C++からRustに入った人あたりから「関数型言語から来た人のRustの感想を知りたい」とたまに言われるのでいつかブログ書こうか。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/848900720573075458&#34;&gt;2017年4月3日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;イントロ&#34;&gt;イントロ&lt;/h1&gt;

&lt;p&gt;私はRustをやる前にはCommon LispやSMLを主に使っていましたが、仕事ではScalaを使っていましたし他にもOCamlやSchemeやClojureやATS2やHaskellなどを書くこともありました。&lt;/p&gt;

&lt;p&gt;私を含めた多くの関数型言語経験者人が一度は &lt;a href=&#34;http://science.raphael.poss.name/rust-for-functional-programmers.html&#34;&gt;Rust for functional programmers&lt;/a&gt; を読んだことがあるかと思います。
このように関数型言語と比較して書かれるといかにも似た言語に見えるので私は興味を持ちました。そこで私は実際にRustに触れ始めたのです。&lt;/p&gt;

&lt;h1 id=&#34;構文&#34;&gt;構文&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;let&lt;/code&gt; があるのでおよそOCamlなどに似ているという印象を受けました。
デフォルトでイミュータブルですしパターンマッチやシャドイングなもどするのでまさにMLの&lt;code&gt;let&lt;/code&gt;そのものです。
行末にセミコロンが要求されますが、&lt;code&gt;in&lt;/code&gt;の代わりだと思うことにして自分をなだめました。
式指向で&lt;code&gt;return&lt;/code&gt;を書かなくて済むのも関数型言語らしさを感じました。&lt;/p&gt;

&lt;p&gt;関数定義の構文は手続型言語風ですが手続き型言語に馴れた人に寄り添うために必要なんだと思って深くは気にしないことにしました。&lt;/p&gt;

&lt;p&gt;一方、ジェネリクスの構文については憤りすら感じました。
どうして &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; を採用したのか、そもそも比較演算子の &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;と紛らわしい上に&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;の扱いでも困ることは目に見えていました。
私はML風に前置、あるいは少なくともHaskellのように関数と引数のように書くべきだと思いましたし、少なくともScalaのように型と値でカッコを分けるくらいはできるはずです。
しかしながら、不平を言っても始まらないので我慢して次に進むことにしました。&lt;/p&gt;

&lt;h1 id=&#34;言語機能&#34;&gt;言語機能&lt;/h1&gt;

&lt;p&gt;トレイト、タプル、代数的データ型とマッチ式、高階関数、型推論。
これらは明らかに関数型言語から輸入されたものです。
これはとても喜ばしいことです、なぜなら今までしていた通りのプログラミングを新しい言語でもできるからです！
関数の引数と返り値に型宣言が必要なのはMLプログラマとしては少し残念でしたがHaskellやIdrisも同じようなスタイルなのでそういうものと自分で納得しました。
そして私はさっそく、倉庫番のゲームを作り始めました。あの、十分にシンプルで、コンソールで動かせて、楽しいゲームです。&lt;/p&gt;

&lt;p&gt;しかしすぐにそううまい話はないと気付きます。
再帰的データ型を定義するとすぐにエラーになりますし（&lt;code&gt;Box&lt;/code&gt;が必要と気付くまでしばらくかかりました）、ハッシュテーブルを使うとすぐミュータブルが必要になります（ハッシュテーブルの操作が破壊的ということをすっかり忘れていました）。
そして何より所有権のせいで思うようにプログラムが書けませんでした。
関数型プログラミングではメモリは無尽蔵にあると思ってプログラミングするのでRustのパラダイムとはとてつもない隔りがありました。
最初は、所有権についてはCleanやGHCにある一意型、あるいはATS2の線形型のようなものだと思えばそう難しくないと踏んでいましたが、実際のところ何もかも思い通りにいきませんでした。
プログラム全てで所有権を意識するのが思いの外難しかったのです。
それでもコンパイル時にコードの安全性を検査出来るのは喜ばしいことだと思って、&amp;rdquo;ボローチェッカとの戦い&amp;rdquo;を数日続けました。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;ボローチェッカとの戦い&amp;rdquo;をしばらく続けて気付いたのは、コンパイラは理不尽な理由で怒ったりしていないということでした。
関数型言語ではデータほとんどイミュータブルなのでデータをコピーしたいのか参照したいのかあまり区別する必要がありませんでしたがRustでは厳密に区別しているだけのことでした。
むしろ、所有権の概念は、一度コンパイラの気持ちを理解してしまえば所有権や参照を意識せずにプログラミングするのが気持ち悪いとさえ感じるほどに自然でした。&lt;/p&gt;

&lt;p&gt;それ以外の点ではトレイトや導出はMLプログラマからすると羨望の的でしたし（余談ですがRustの導出は昔はHaskell風に&lt;code&gt;#[deriving(Show)]&lt;/code&gt;と書いていましたが、いつからか&lt;code&gt;#[derive(Debug)]&lt;/code&gt;と書くようになったようです。）、
オブジェクト指向についても上手くやっていると感じました（関数型プログラミング言語でもオブジェクト指向はします！）。&lt;/p&gt;

&lt;p&gt;Lispプログラマから一言あるとすれば、マクロです。RustのマクロはSchemeの&lt;code&gt;syntax-rules&lt;/code&gt;相当の機能しかなく、Common Lispプログラマの私にはもの足りませんでした。
&lt;code&gt;macro_rules&lt;/code&gt;でも無いよりはましですし、C言語のマクロよりは素晴らしいものです。
それでもどうしても伝統的なマクロが欲しくなりますが、不安定なコンパイラプラグインの機能しか選択肢がありません（訳注: 現在のRustにはproc_macroが入ったので伝統的なマクロも書けます）。&lt;/p&gt;

&lt;h1 id=&#34;ツール&#34;&gt;ツール&lt;/h1&gt;

&lt;p&gt;私の好きなEmacsのサポートはしっかりしていましたし、大きな不満はありませんでした。
REPLこそありませんがむしろSMLに比べると補完や定義ジャンプなどリッチな機能さえありました。&lt;/p&gt;

&lt;p&gt;それよりも、ビルドツールについてです。
Rustは関数型プログラムで永遠のテーマだった分割コンパイルをするとインライン化が妨げられるが全プログラムコンパイルをするとコンパイル時間が掛かりすぎるという問題にモジュールより上位のクレートという単位を設けることで解決を見出したのです。
それに素晴らしきCargo。依存関係の地獄はありませんし、Makefileを書く必要もありません。パッケージインストーラがランタイムにまで侵入してくることもありません。
私達がプログラムを書くことに集中させてくれます。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;関数型プログラマがRustを使うと、所有権やミュータビリティ、メモリへの厳しさに最初は面くらうもののすぐに馴れて普段通りにプログラムを書けるようになります。
もちろん、Rustはむしろ手続き型な言語なので関数型プログラムそのまま、とはいきませんが普段使っている道具がそのまま使えるのでハードルは低いですし、むしろ手続き型プログラムに馴れた人が戸惑わないか心配にすらなります（初めてC++プログラマがRustをスラスラ書けると聞いたときには大変驚きました）。
Rustは関数型プログラマ、手続き型プログラマ問わず良い言語なのでみなさんも最初の一歩を踏み出しましょう！&lt;/p&gt;

&lt;h1 id=&#34;メタ&#34;&gt;メタ&lt;/h1&gt;

&lt;p&gt;私のブログは記事によって意識的に文体を変えているのですが、今回は新たな試みとして「海外でちょっと流行った記事の野良和訳」風に書いてみました。
なので海外風に「明らかに」などの強いワードを用いたり誤訳っぽいワードを埋めたいあまつさえ（訳注:〜）なんてものが出現しますが特に原文はないです。
案外疲れました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ソフトウェアエンジニアがFPGAやってみる</title>
      <link>/slide/sofutoueaenjiniagaFPGAyattemiru/</link>
      <pubDate>Tue, 28 Mar 2017 09:21:33 +0900</pubDate>
      
      <guid>/slide/sofutoueaenjiniagaFPGAyattemiru/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ソフトウェアエンジニアがPYNQでFPGAやってみる
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# よくある話
------------

&lt;div class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;&gt;「Lisperって自分のLispを作るらしいよ」 &lt;/div&gt;
&lt;div class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;&gt;「Lispって昔は専用ハードウェアで動いてたらしいよ」 &lt;/div&gt;
&lt;div class=&#34;fragment&#34; data-fragment-index=&#34;3&#34;&gt;「じゃあハードウェア作んなきゃ」 &lt;/div&gt;
&lt;div class=&#34;fragment&#34; data-fragment-index=&#34;4&#34;&gt;「FPGAやるかー」 &lt;/div&gt;

===

# FPGAって？
------------

* Field-Programmable Gate Array
* プログラマブルな集積回路
  + オレオレ設計のCPU作ったり
  + HDMI入力を直でmpg4にエンコードするデバイスとかも
* クロックはASIC(ふつうのCPU)より大分遅い
* でも上手く嵌れば100倍高速化とか

===

# PYNQって？
------------

* [PYNQ-Z1 Python Productivity for Zynq - Digilent](http://store.digilentinc.com/pynq-z1-python-productivity-for-zynq/)
* xilinxのFPGAとARMのチップが載ったSoC
* ARMで動いてるPython(Jupyter)からFPGAにロジック焼ける
  + 手軽にロジックを試せる
* FPGAとの通信はMMIO
  + 特定のアドレスのメモリにデータを書くとFPGAに送られる
  + メモリのデータを読むとFPGAからデータが送られる

===

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;会社にPYNQがきたよ！！azure倒したら遊ぶ！！！！ &lt;a href=&#34;https://t.co/ohJg7z4lxd&#34;&gt;pic.twitter.com/ohJg7z4lxd&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/828834126572589056&#34;&gt;2017年2月7日&lt;/a&gt;&lt;/blockquote&gt;

===

# ハードウェアロジック
---------------------

* ハードウェア記述言語(HDL)を使う
  + メジャーなのはVHDLとVerilog
  + 今回はVerilogの話
* クロックとかレジスタとかワイヤーとか駆使する
* 電気信号なのでロジックが並列で走る
* vivadoというツールでコンパイル
  + Tclで制御も出来る
* 回路設計とかも
* コンパイルは結構遅い…
* CPUと通信するときの規格とかも書かなきゃいけない
  * AXI LiteとかAXI Fullとか…
  * 一応自動で生成はしてくれる

===

![vivadoのスクショ](/images/fpga/vivado.png) &lt;!-- .element: width=&#34;100%&#34; --&gt;

===

# なんか作ってみる1
------------------

* Lチカ
* [Vivado and zybo linux勉強会資料3](https://www.slideshare.net/marsee101/vivado-and-zybo-linux3)
* ↑ロジック焼くとこ以外ほぼこれのまま
* ロジックで作ったワイヤーと実際のLEDのワイヤー結んだりして楽しい
* AXI LiteでCPUと繋がって間隔変えたり出来る

===

``` verilog
reg [3:0] LED_Display_Counter;
reg [31:0] LED_Interval_Counter;
reg slv_reg_wren_1d;

// slv_reg_wren_1d generate
always @(posedge S_AXI_ACLK) begin
   if (~S_AXI_ARESETN)
       slv_reg_wren_1d &lt;= 1&#39;b0;
   else
       slv_reg_wren_1d &lt;= slv_reg_wren;
end

// LED_Interval_Counter
always @(posedge S_AXI_ACLK) begin: proc_LED_Interval_Counter
   if (~S_AXI_ARESETN) begin
       LED_Interval_Counter &lt;= 32&#39;d0;
   end else begin
       if (slv_reg0[0]) begin // Enable
           if (LED_Interval_Counter == 32&#39;d0)
               LED_Interval_Counter &lt;= slv_reg3;
           else
               LED_Interval_Counter &lt;= LED_Interval_Counter - 32&#39;d1;
       end else
           LED_Interval_Counter &lt;= slv_reg3;
   end
end

/// Counters
// LED_Display_Counter
always @(posedge S_AXI_ACLK) begin: proc_LED_Display_Counter
   if (~S_AXI_ARESETN) begin
       LED_Display_Counter &lt;= 4&#39;d0;
   end else begin
       if (slv_reg_wren_1d &amp;&amp; axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 2&#39;h1) // Counter Load
           LED_Display_Counter &lt;= slv_reg1[3:0];
       else if (slv_reg0[0]) begin  // Enable
           if (LED_Interval_Counter == 32&#39;d0)
               LED_Display_Counter &lt;= LED_Display_Counter + 4&#39;d1;
       end
   end
end

assign LED4bit = LED_Display_Counter;
```

===

![jupyterのスクショ](/images/fpga/led4bit.png)&lt;!-- .element: width=&#34;100%&#34; --&gt;

===

# なんか作ってみる2
------------------

* 簡易計算機
* 渡された2値で演算
  + 四則演算とか論理演算とか
* AXI Liteで通信
  + AXI Liteはレジスタのみ通信可能

===

```verilog
reg [C_S_AXI_DATA_WIDTH-1:0] res;

always @(posedge S_AXI_ACLK) begin
   if (S_AXI_ARESETN == 1&#39;b0) begin
      res &lt;= 32&#39;h0;
   end else if (~ slv_reg_wren)
     begin
        if (slv_reg0[0]) begin
           case (slv_reg1)
             32&#39;h0: res &lt;= slv_reg2 + slv_reg3;
             32&#39;h1: res &lt;= slv_reg2 - slv_reg3;
             32&#39;h2: res &lt;= slv_reg2 * slv_reg3;
             default: res &lt;= res;
           endcase // case (slv_reg1)
        end
     end
end // always @ (posedge S_AXI_ACLK)

always @(posedge S_AXI_ACLK) begin
   slv_reg4 &lt;= res;
   slv_reg0 &lt;= 32&#39;b0;
end

```

===

![jupyterのスクショ](/images/fpga/alu.png) &lt;!-- .element: width=&#34;100%&#34; --&gt;


===

# なんか作ってみる3
------------------

* 命令列を受け取って計算
* 内部で16のレジスタ、プログラムカウンタなど
* CPUっぽい動き
* CPUとの通信はAXI Full
  + メモリに触れる

===

``` verilog
generate
   if (USER_NUM_MEM &gt;= 1)
 begin
    assign mem_select  = 1;
    assign mem_address = (axi_arv_arr_flag? axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:(axi_awv_awr_flag? axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:0));
 end
endgenerate

function [3:0] fop;
   input reg[C_S_AXI_DATA_WIDTH-1:0] opcode;
   fop = opcode[C_S_AXI_DATA_WIDTH-1 -: 4];
endfunction

function [3:0] fret;
   input reg[C_S_AXI_DATA_WIDTH-1:0] opcode;
   fret = opcode[C_S_AXI_DATA_WIDTH-5 -: 4];
endfunction

function [3:0] freg1;
   input reg[C_S_AXI_DATA_WIDTH-1:0] opcode;
   freg1 = opcode[C_S_AXI_DATA_WIDTH-9 -: 4];
endfunction

function [3:0] freg2;
   input reg[C_S_AXI_DATA_WIDTH-1:0] opcode;
   freg2 = opcode[C_S_AXI_DATA_WIDTH-13 -: 4];
endfunction

function [15:0] fconst1;
   input reg [C_S_AXI_DATA_WIDTH-1:0] opcode;
   fconst1 = opcode[C_S_AXI_DATA_WIDTH-13 -: 16];
endfunction

// implement Block RAM(s)
wire                                 mem_rden;
wire                                 mem_wren;
wire [C_S_AXI_DATA_WIDTH-1:0]        data_out;
wire [C_S_AXI_DATA_WIDTH-1:0]        start;
reg [C_S_AXI_DATA_WIDTH-1:0]         result;
reg [C_S_AXI_DATA_WIDTH-1:0]         r[0:15];
reg [C_S_AXI_ADDR_WIDTH-1:0]         pc;
reg [1:0]                            finish;
reg [C_S_AXI_DATA_WIDTH-1:0]         byte_ram [0 : 31];
reg [3:0]                            state;
reg [C_S_AXI_DATA_WIDTH-1:0]         opword;
reg [3:0]                            op;
reg [3:0]                            ret;
reg                                  reten;
reg [C_S_AXI_DATA_WIDTH-1:0]         retreg;
reg [C_S_AXI_DATA_WIDTH-1:0]         reg1;
reg [C_S_AXI_DATA_WIDTH-1:0]         reg2;
reg [15:0]                           const1;

assign mem_wren = axi_wready &amp;&amp; S_AXI_WVALID ;

assign mem_rden = axi_arv_arr_flag ; //&amp; ~axi_rvalid

assign data_out = byte_ram[mem_address];

assign start = byte_ram[1];

localparam integer PC_START = 2;

always @(posedge S_AXI_ACLK)
  begin
     if (S_AXI_ARESETN == 0 || start == 32&#39;b0)
       begin
          finish &lt;= 0;
          pc &lt;= PC_START;
          result &lt;= 0;
          state &lt;= 0;
          reten &lt;= 0;
          retreg &lt;= 0;
          ret &lt;= 0;
          reg1 &lt;= 0;
          reg2 &lt;= 0;
          const1 &lt;= 0;
          r[0] &lt;= 0; r[1] &lt;= 0;
          r[2] &lt;= 0; r[3] &lt;= 0;
          r[4] &lt;= 0; r[5] &lt;= 0;
          r[6] &lt;= 0; r[7] &lt;= 0;
          r[8] &lt;= 0; r[9] &lt;= 0;
          r[10] &lt;= 0; r[11] &lt;= 0;
          r[12] &lt;= 0; r[13] &lt;= 0;
          r[14] &lt;= 0; r[15] &lt;= 0;
       end
     else if (finish != 2&#39;d2)
       begin
          case (state)
            // fetch
            4&#39;d0: begin
               opword &lt;= byte_ram[pc];
               state &lt;= 4&#39;d1;
            end
            // decode
            4&#39;d1: begin
               op &lt;= fop(opword);
               ret &lt;= fret(opword);
               reg1 &lt;= r[freg1(opword)];
               reg2 &lt;= r[freg2(opword)];
               const1 &lt;= fconst1(opword);
               state &lt;= 4&#39;d2;
            end
            //execute
            4&#39;d2: begin
               case (op)
                 // add
                 4&#39;b0000: begin
                    retreg &lt;= reg1 + reg2;
                    reten &lt;= 1;
                 end
                 // sub
                 4&#39;b0001: begin
                    retreg &lt;= reg1 - reg2;
                    reten &lt;= 1;
                 end
                 // mul
                 4&#39;b0010: begin
                    retreg &lt;= reg1 * reg2;
                    reten &lt;= 1;
                 end
                 // or
                 4&#39;b0011: begin
                    retreg &lt;= reg1 | reg2;
                    reten &lt;= 1;
                 end
                 // and
                 4&#39;b0100: begin
                    retreg &lt;= reg1 &amp; reg2;
                    reten &lt;= 1;
                 end
                 // xor
                 4&#39;b0101: begin
                    retreg &lt;= reg1 ^ reg2;
                    reten &lt;= 1;
                 end
                 // add imm
                 4&#39;b1000: begin
                    retreg &lt;= reg1 + const1;
                    reten &lt;= 1;
                 end
                 // sub imm
                 4&#39;b1001: begin
                    retreg &lt;= reg1 - const1;
                    reten &lt;= 1;
                 end
                 // mul imm
                 4&#39;b1010: begin
                    retreg &lt;= reg1 * const1;
                    reten &lt;= 1;
                 end
                 // or imm
                 4&#39;b1011: begin
                    retreg &lt;= reg1 | const1;
                    reten &lt;= 1;
                 end
                 // and imm
                 4&#39;b1100: begin
                    retreg &lt;= reg1 &amp; const1;
                    reten &lt;= 1;
                 end
                 // jz
                 4&#39;b1101: begin
                    if (reg1 == 32&#39;b0)
                      pc &lt;= const1 - 1 + PC_START;
                    reten &lt;= 0;
                 end
                 // j
                 4&#39;b1110: begin
                    pc &lt;= const1 - 1 + PC_START;
                    reten &lt;=0;
                 end
                 // exit
                 4&#39;b1111: begin
                    pc &lt;= PC_START - 1;
                    result &lt;= reg1;
                    finish &lt;= 1;
                    reten &lt;= 0;
                 end
                 // error
                 default: begin
                    pc &lt;= PC_START - 1;
                    result &lt;= op;
                    finish &lt;= 1;
                    reten &lt;= 0;
                 end
               endcase
               state &lt;= 3;
            end
            // write back
            4&#39;d3: begin
               pc &lt;= pc + 1;
               if (reten)
                 r[ret] &lt;= retreg;
               if (finish == 1)
                 finish &lt;= 2;
               state &lt;= 0;
            end

          endcase
       end
  end

always @( posedge S_AXI_ACLK )
  begin
 if (mem_rden)
   begin
          if (mem_address == 0)
        mem_data_out[0] &lt;= result;
          else
            mem_data_out[0] &lt;= data_out;
   end
  end


generate
   for(mem_byte_index=0; mem_byte_index&lt;= (C_S_AXI_DATA_WIDTH/8-1); mem_byte_index=mem_byte_index+1)
 begin:BYTE_BRAM_GEN
    wire [8-1:0] data_in ;
    integer      j;

    //assigning 8 bit data
    assign data_in  = S_AXI_WDATA[(mem_byte_index*8+7) -: 8];

    always @( posedge S_AXI_ACLK )
      begin
         if (mem_wren &amp;&amp; S_AXI_WSTRB[mem_byte_index])
           begin
              byte_ram[mem_address][(mem_byte_index*8+7) -: 8] &lt;= data_in;
           end
      end
 end
endgenerate
//Output register or memory read data

always @( mem_data_out, axi_rvalid)
  begin
 if (axi_rvalid)
   begin
      // Read address mux
      axi_rdata &lt;= mem_data_out[0];
   end
 else
   begin
      axi_rdata &lt;= 32&#39;h00000000;
   end
  end
```

===


![jupyterのスクショ](/images/fpga/alu2.png) &lt;!-- .element: width=&#34;100%&#34; --&gt;


===

# まとめ
--------

* FPGA楽しいよ
* CPUっぽいの作れるよ
* PYNQ便利だよ


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rust in Production</title>
      <link>/slide/Rust_in_Production/</link>
      <pubDate>Wed, 22 Mar 2017 19:57:28 +0900</pubDate>
      
      <guid>/slide/Rust_in_Production/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rust in Production
----------------------
[Rust プログラマーミートアップ / Rust programmers&#39; meetup - connpass](https://rust.connpass.com/event/49304/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * 若者
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# Rust採用までの流れ
--------------------

Ω＜「κeen君継続的ベンチマークサーバ作って」&lt;!-- .element: style=&#34;color:#a00;text-align:left;&#34; --&gt;  
Ω＜「GitHubにpushする度ベンチマーク走る感じで」&lt;!-- .element: style=&#34;color&#34;:#a00;text-align:left;&#34; --&gt;  
Ω＜「GPUとRaspberry Piでベンチマークするから」&lt;!-- .element: style=&#34;color:#a00;text-align:left;&#34; --&gt;  
Ω＜「全部任せるね」&lt;!-- .element: style=&#34;color:#a00;text-align:left;&#34; --&gt;  

⸜( ¯⌓¯ )⸝「Rustで書くか」&lt;!-- .element: style=&#34;color:#00a;text-align:left;&#34; --&gt;  


やったこととか知見とかトピック毎にかいつまんで話します

&lt;!-- .slide: class=&#34;left&#34; --&gt;

===
# Rustのメリット
---------------

* κeenが馴れてる
* 社員の半分くらい書ける
* Linux, Mac, Raspberry Piで動く
* テスト書かなくてもそんなにバグらなそう
* 将来のために小さいところでノウハウ溜めていきたい
* シングルバイナリで楽に動きそう
* **単純に使いたかった**
* ※今回は速度や安全性は必要ない

===
# コンポーネント
---------------

* CLIクライアント
  + 各自の手元やCIサーバから起動
* アグリゲータ
  + ワーカに仕事を投げ、結果を受け取る
  + ジョブ管理
* ワーカ
  + GPUマシンやRSPiなどでベンチマーク
  + 結果をアグリゲータに返す
* ブラウザ
  + ベンチマーク結果の閲覧

===
# プロジェクト構成
-------------------

* [ワークスペース](http://doc.crates.io/manifest.html#the-workspace--field-optional)を使ってサブプロジェクトに分割
  + モノリシックだとビルドが重かった
  + targetは全てのプロジェクトで共有する
* CLI, aggregator, worker, browserの他にmodel, api
* modelはaggregatorとbrowserで共有
* apiはaggergatorとcliとworkerで共有
* コード

===

# プロジェクト構成
-------------------


```
Cargo.lock
Cargo.toml
README.md
bench_aggregator/
bench_api/
bench_browser/
bench_cli/
bench_model/
bench_worker/
build.sh
circle.yml
docker-compose-deploy.yml
docker-compose.yml
migrations
rustfmt.toml
src/
static/
target/
```

===
# プロジェクト構成
-------------------

![構成のイメージ](/images/rust-in-production/composition.png)&lt;!--  width=&#34;100%&#34; --&gt;


===
# パーサ
--------

* workerで使う
* timeやgprofの結果を数値で欲しい
* →パースするか…
  + フォーマット
* timeはbash固定
  + シェルコマンドなのでシェル毎にフォーマットが違う
* gprofは`-b`オプションでの結果をパース
  + gmon.outではない

===
# パーサ
--------

* パーサコンビネータ [nom](https://github.com/Geal/nom)
* サクっと作れた
* デバッグつらい
  + gprofが思ったより変なフォーマットしてた
  + nomがバイト指向なのと位置を保存しない
  + 自力でどうにかする？
  + [combine](https://github.com/Marwes/combine)使うか手書きにするかで書き直したい
* コード

===

# CLIオプション
---------------

* workerとcliで必要
* 多機能な[clap](https://github.com/kbknapp/clap-rs)を採用
* 特に困らない
* 採用プロジェクトも多くてliving exampleに事欠かない
* CLIツールに思考停止で採用していいと思う
* コード

===
# HTTPクライアント
------------------

* CLIとworkerで使う
* [hyper](https://github.com/hyperium/hyper) vs [reqwest](https://github.com/seanmonstar/reqwest)
* 非同期な必要はないのでreqwest使いたかった
* reqwestにmultipart対応がない→生hyper+[multipart](https://github.com/abonander/multipart)
* コネクションの管理とかjsonの扱いとかそこそこ面倒だった…
* reqwestにmultipart対応入ったら乗り換えるかも

===
# HTTPサーバ
------------

* aggregatorとbrowserで使う
* 簡単なREST API
* 生hyper vs [nickel](https://github.com/nickel-org/nickel.rs) vs [iron](https://github.com/iron/iron)
* 生hyperはすぐつらくなる→やめた
* **nickelとironはそんなに変わらなかった**
* nickel(agregator)+iron(browser)
  + aggregatorはなんとなくでnickel選んじゃった
  + browserは結局[rustc-perf](https://github.com/rust-lang-nursery/rustc-perf)からフォークしたためironだった

===

# HTTPサーバ(Nickel)
------------

* サーバデータの扱いがちょっと特殊？
  ```rust
    let data = req.server_data();
  ```
* 400 BadRequestと500 InternalServerErrorのマクロ作った
  + `validate!(res, serde_json::from_str(field));`
  + `server_try_with!(res, serde_json::to_string(&amp;ret));`
  + 「エラー出たら処理終了」が他の言語と比べて書きづらい？
* 非同期IOしない…
  + ポーリングでコネクション張りっぱなしなのでクライアント分スレッドが必要（ハマった）
* マルチスレッド→DBコネクションにロックが必要
* コード

===
# APIモデル
-----------

* apiクレートを分けた
  + バイナリ毎に別クレートに分けるために必要だった
* [serde](https://github.com/serde-rs/serde)と[serde_json](https://github.com/serde-rs/json)でjson化
* proc-macroがstableになって格段に使いやすくなった
* モジュール分けて`Request`と`Response`を作ってAPIが分かりやすく
* コード

===
# DB
-----

* aggergatorとbrowserで必要
* ほぼ[diesel](https://github.com/diesel-rs/diesel)一択
  + コネクション、マイグレーション、ORMなど
  + proc-macroで大分楽に
* [仕事でdiesel使ってみた | κeenのHappy Hacκing Blog](https://keens.github.io/slide/shigotodedieseltsukattemita/)
* DBはPostgreSQL
  + 半分dieselのため、もう半分機能のため
* 開発時はdocker-composeで立てる
  + CF [docker-composeでmysql &amp; postgreSQL をサクッと起動 - Qiita](http://qiita.com/astrsk_hori/items/1e683a7a2f2b7189cb6e)

===
# diesel
-----

* Pros
  + SQLでスキーマ書ける
  + マイグレーションの面倒みてくれる
  + proc-macroのおかげで楽
  + クエリDSL案外普通に書けた
  + 最悪SQL生牡蠣出来る
  + CLI便利

===
# diesel
--------

* Cons
  + deriveいっぱいあって難しい
    - has_manyとbelongs_toあたりをどう書くか
  + enum扱えない
  + DSLで2重join書けない
  + 偶に機能足りない
    - ネットワークアドレス型サポートとか
  + SQL生牡蠣の型付けつらい
  + has_manyの扱いに難あり
    - eager loadingしない設計判断
    - `(User, Vec&lt;Tweets&gt;)` みたいなのを持ち回す羽目に
    - モデル設計にも影響

===
# マイグレーション
-----------------

* 普通のマイグレーション運用かな
* 最初のデプロイまでは`diesel database reset`で何度も初期化した
* 最初デプロイ後は手元で`diesel migration run`と`diesel migration revert`を何度か
* デプロイ時に雑に手元から本番サーバに `diesel migration run`
  + 本当はデプロイプロセスに組込みたい
  + diesel CLIの入ったdockerコンテナ…
* まだほとんど使われてないので雑運用


===
# マイグレーション(コード)
-----------------

* スキーマ変更したらコードの変更も必要
  + そもそも必要だからスキーマ変更するので割と自然に出来る
* `infer_schema` があるので先に開発環境のマイグレーションをしないといけない
* カラムの順番とフィールドの順番が一致する必要
  + 地味に面倒
  + 今後改善予定 CF [#747](https://github.com/diesel-rs/diesel/pull/747)
* SQL生牡蠣の対応がつらい
  + コンパイル時にカラム不足が分からない

===
# エラー管理
------------

* 全ての場所で必要
* [error_chain](https://github.com/brson/error-chain)を採用
* 公式ドキュメントの[エラーハンドリング](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/error-handling.html)のボイラプレートをマクロで生成
* `?`でのエラー処理が楽になる→ `unwrap`が消えた
* 全てのプロジェクトに思考停止で採用していいんじゃないかな

===

# ログ
------

* 全ての場所で必要
* nurseryの[log](https://github.com/rust-lang-nursery/log)と[env_logger](https://github.com/rust-lang-nursery/log)を採用
* `println!`より高機能な（on/offが出来る）ので`println!`の代わりに`debug!`を入れる
* あとたまにエラーハンドリングで`error!`使ったり
* `main`で一行`env_logger::init().expect(&#34;failed to init env logger&#34;);`を忘れずに
* 運用以前に開発に便利なので問答無用で入れていいと思う

===
# コンフィグ
------------

* [serde_yaml](https://github.com/dtolnay/serde-yaml) + [dotenv](https://github.com/slapresta/rust-dotenv)
* コンフィグファイルといえばyamlだよね
  + ちょこっといじって再起動がやりやすい
* dotenvはdockerと相性がいい気がする
* どっちがいいか判断出来なかったので両方実装
* プロダクションで動いてるのはdotenv（というか普通の環境変数）の方

===

# テスト
--------

* 全ての場所で必要
* 組込みの`#[test]`を使用
* 正直あまり出来てない
* 型強いし多少はなくてもバグらない…？
* 一応レイヤ(DB/ビジネスロジック/インタフェース)を跨ぐときにはtraitで抽象化
  + 出来てないところもいっぱい
* 今後の課題とさせて頂きます

===
# デバッグ
----------

* 基本はlogの`debug!`でトレース
* ちゃんと型つけときゃバグらない
* GDB使う…？
* デモ

===

# ビルド
--------

* cargoでサブプロジェクト全てをビルドするコマンドがなかった
  + 最近 `cargo build --all` が入った
* Raspberri Pi向けにクロスコンパイルが必要
* シェルスクリプトでビルドスクリプト
* クロスコンパイルはdockerを使う CF [dlecan/rust-crosscompiler-arm: Docker images for Rust dedicated to cross compilation for ARM v6 and more](https://github.com/dlecan/rust-crosscompiler-arm)
* 正解なのか分からない

===
# CI
----

* 全てのクレートで必要
* Circle CIを使ってる
* 普通にrustupでRustのインストール
  + travisならRustサポートあるけど…
* 普通に `cargo test --all`

===

# デプロイ
----------

* シングルバイナリだけど…
* シュっとdocker-swarmとかでデプロイしたい
* dockerイメージ作ってdocker-composeで管理
  + 開発も便利に
* raspberry piはバイナリだけ配る
* browserは`static/`もイメージに同梱

===
# Docker
--------

* ベースイメージはUbuntu
  + libcの扱いが面倒そうなのでalpineはやめといた
  + イメージサイズに困ってからどうにか考える
* swarmなのでdocker-composeの設定そのままで動かせる
* ログの管理もswarm任せ
  + env_loggerが標準出力に吐くのもそんなに困ってない

===
# Docker
--------

* rustのビルドからのdockerのビルドが面倒
* Dockerfileの管理も面倒
* 便利なの作った
* [KeenS/cargo-pack-docker: a cargo subcommand to package your application into a docker image](https://github.com/KeenS/cargo-pack-docker)
* DockerfileなしでRustのビルドからイメージ作成までやってくれる
* 今のところ使えてる
  + 作りが甘いことは認識してる…

===
# まとめ
---------

* Rustを仕事で使ったときの知見を話した
* 微妙に痒いところに手が届かないけど概ね揃ってる
* 開発が速いので問題は放置しとくと勝手に直るかも
* テストとかデプロイとかまだ知見が足りない


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>オーディナルの話とカーディナルの話</title>
      <link>/blog/2017/03/02/o_dinarunohanashitoka_dinarunohanashi</link>
      <pubDate>Thu, 02 Mar 2017 21:15:44 +0900</pubDate>
      
      <guid>/blog/2017/03/02/o_dinarunohanashitoka_dinarunohanashi</guid>
      <description>&lt;p&gt;ちょっとオーディナルの話をしよう。ついでにカーディナルの話もしよう。
特に何も知らなくても分かる内容。だけど文脈を知ってると伝えたいことが伝わる筈。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;まずは何もないところから始めよう。机もスマホもパソコンンもない。空気もないし数字もない、自然数もない。&lt;/p&gt;

&lt;p&gt;何もない。&lt;/p&gt;

&lt;p&gt;「何もない」、もうちょっと正確にいうと「何も要素がない集合」のことを覚えているだろうか。中学校で習った気もする。&lt;/p&gt;

&lt;p&gt;\[
\emptyset
\]&lt;/p&gt;

&lt;p&gt;と書く。
さて、ここから始める。何もないところから何か作れるだろうか。まずは $\emptyset$ を要素に持つ集合、&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset\}
\]&lt;/p&gt;

&lt;p&gt;がある。これは要素を1つだけ持つので $\emptyset$ とは異なる集合だ。これをさらに進められないだろうか。例えば&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \emptyset\}
\]&lt;/p&gt;

&lt;p&gt;とか。これではダメだ。結局2つの要素が同じ $\emptyset$ なので要素を取り出してみても $\{\emptyset\}$ から取り出したときと区別がつかない。
何か $\emptyset$ とは別のものが必要だ。 $\emptyset$ とは別のもの。既に出てきた。 $\{\emptyset\}$ だ。&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \{\emptyset\}\}
\]&lt;/p&gt;

&lt;p&gt;これで $\emptyset$ とも $\{\emptyset\}$ とも異なる集合が作れた。ここまできたらあとはもうパターンだ。「次」が欲しければ今までに出てきた集合を全部$\{\}$に放り込めばいい。&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\}
\]&lt;/p&gt;

&lt;p&gt;「次(Successor)」を求める手続を $\mathbf{succ}$ と書くとすると、集合の合併 $\cup$ を用いて&lt;/p&gt;

&lt;p&gt;\[
\mathbf{succ} (x) = x \cup \{x\}
\]&lt;/p&gt;

&lt;p&gt;と書ける。この $\mathbf{succ}$ 、必ず新たな集合を生み出している。これはつまり、任意の $x$ に対して $\mathbf{succ}(x)$ は $\emptyset$ にはならないし、 $x \not= y$ のとき $\mathbf{succ}(x) \not=\mathbf{succ}(y)$ でもある。
このようなものをご存知ないだろうか(細かいことを言うと帰納法の原理も必要だが飛ばす)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%9A%E3%82%A2%E3%83%8E%E3%81%AE%E5%85%AC%E7%90%86&#34;&gt;自然数&lt;/a&gt;だ。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$\emptyset$ がある&lt;/li&gt;
&lt;li&gt;任意の自然数 $x$ に $\mathbf{succ}(x)$ がある&lt;/li&gt;
&lt;li&gt;$\emptyset$ はいかなる自然数 $x$ の $\mathbf{succ}$ でもない&lt;/li&gt;
&lt;li&gt;$x \not= y$ のとき $\mathbf{succ}(x) \not=\mathbf{succ}(y)$&lt;/li&gt;
&lt;li&gt;(帰納法の原理が成り立つ)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これは、こういうことだ。&lt;/p&gt;

&lt;p&gt;\[
\begin{eqnarray}
0 &amp;amp; = &amp;amp; \emptyset \\\&lt;br /&gt;
1 &amp;amp; = &amp;amp; \{\emptyset\} \\\&lt;br /&gt;
2 &amp;amp; = &amp;amp; \{\emptyset, \{\emptyset\}\} \\\&lt;br /&gt;
3 &amp;amp; = &amp;amp; \{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\} \\\&lt;br /&gt;
  &amp;amp; \vdots &amp;amp;
\end{eqnarray}
\]&lt;/p&gt;

&lt;p&gt;ここでは &lt;a href=&#34;https://twitter.com/search?q=%230%E3%81%AF%E8%87%AA%E7%84%B6%E6%95%B0&amp;amp;src=typd&#34;&gt;#0は自然数&lt;/a&gt; としてある。
さて、今我々は何もないところから出発してDASH村のように自然数を作り上げた。&lt;/p&gt;

&lt;p&gt;この自然数、面白い性質がある。 0 は 1の要素( $0 \in 1$) だ。 1 は 2 の要素 ( $1 \in 2$ )だし、0も2の要素 $0 \in 2$ だ。もうちょっというと、 $x \in y$ かつ $y \in z$ のとき、 $x \in z$も成り立つ。
この関係で自然数には順序がつく。つまり、自然数は&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E9%A0%86%E5%BA%8F%E6%95%B0&#34;&gt;順序数&lt;/a&gt;(オーディナルナンバー)だ。再度、オーディナルナンバーであるところの自然数を列挙するとこうなる。&lt;/p&gt;

&lt;p&gt;\[
\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}, \{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\}, &amp;hellip;
\]&lt;/p&gt;

&lt;p&gt;これに見覚えがあるならオーディナルの話はこれで十分。&lt;/p&gt;

&lt;p&gt;さて、カーディナルの話をしよう。 $\emptyset$ は要素が0個。 $\{\emptyset\}$ は要素が1つ。 $\{\emptyset, \{\emptyset\}\}$ は要素が2つ。
要素数の話だ。これは別に自然数だけでなくて、 $\{2, 4\}$ のように自然数ではない集合でも要素数という概念はある。要素数をどう数えようか。一応要素数に&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%BF%83%E5%BA%A6_(%E6%95%B0%E5%AD%A6)&#34;&gt;濃度&lt;/a&gt;という名前もついている。
これにも自然数が使える。2と $\{2, 4\}$ を $\{2, 4\}$ を $2 -\emptyset$ と $4 - \{\emptyset\}$ と1対1に対応づければ、「$\{2, 4\}$と 2は同じ濃度を持つ」といえる。
このように濃度を数えるための数を&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0&#34;&gt;基数&lt;/a&gt;（カーディナルナンバー）という。&lt;/p&gt;

&lt;p&gt;手で数えられる（有限な）ものは面白みがない。無限なものについて考えよう。例えば今我々が作った自然数は常に $\mathbf{succ}$ がとれるので無限の要素がある。
まだ作ってないが、自然数だけでなく整数にも有理数にも実数にも無限の要素がある。これらの「無限」は全て同じ大きさなのだろうか、つまり同じ濃度なのだろうか。
結論からいうと自然数と整数と有理数は同じ濃度を持つ。全て自然数と1対1の対応が取れるということだ。一方&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB%E3%81%AE%E5%AF%BE%E8%A7%92%E7%B7%9A%E8%AB%96%E6%B3%95&#34;&gt;実数は対応が作れない&lt;/a&gt;。実数の濃度の方がずっと大きい訳だ。つまり、無限の間にも大小関係がある。実は自然数は無限の中でも一番小さい。この一番小さい基数のことをヘブライ文字からとって&lt;/p&gt;

&lt;p&gt;\[
\aleph_0
\]&lt;/p&gt;

&lt;p&gt;と書く。これも見覚えがあればカーディナルの話はこれにて重畳。&lt;/p&gt;

&lt;p&gt;そういえばこういう「紙の上でDASH村」を気に入ったならこの本がお勧め。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4791768515&#34;&gt;コンピュータは数学者になれるのか? -数学基礎論から証明とプログラムの理論へ- | 照井一成 |本 | 通販 | Amazon&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>仕事でdiesel使ってみた</title>
      <link>/slide/shigotodedieseltsukattemita/</link>
      <pubDate>Wed, 01 Mar 2017 10:57:38 +0900</pubDate>
      
      <guid>/slide/shigotodedieseltsukattemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 仕事でdiesel使ってみた
----------------------
[RustのLT会！ Rust入門者の集い #2 - connpass](https://rust.connpass.com/event/48826/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# [diesel.rs](diesel.rs)

![dieselのwebページ](/images/diesel/diesel-web.png)

===

# diesel
---------


* RustのORM
  * スキーマからコード自動生成
  * diesel_codegen
* クエリビルダ
* マイグレーション管理
* PostgreSQL, MySQL, SQLiteサポート

===

# 準備
-------

* [docker-composeでmysql &amp; postgreSQL をサクッと起動 - Qiita](http://qiita.com/astrsk_hori/items/1e683a7a2f2b7189cb6e)

```
cargo install diesel_cli
echo DATABASE_URL=postgres://username:password@localhost/hoge &gt; .env
diesel setup
diesel migration generate create_posts
```

===

# 準備
-------

``` toml
[dependencies]
chrono = &#34;0.3.0&#34;
diesel = {version = &#34;0.11.4&#34;, features = [&#34;chrono&#34;, &#34;postgres&#34;, &#34;serde_json&#34;]}
dotenv = &#34;0.8.0&#34;
serde_json = &#34;0.9.6&#34;
serde_derive = &#34;0.9.7&#34;
serde = &#34;0.9.7&#34;

[dependencies.diesel_codegen]
features = [&#34;postgres&#34;]
version = &#34;0.11.0&#34;
```

===
# プロジェクト構成
-----------------

* モデルのコンパイルが遅いので分離したい
* Cargoの[ワークスペース](http://doc.crates.io/manifest.html#the-workspace-section)機能を使う

===
# プロジェクト構成
-----------------

```
$ ls
Cargo.lock
Cargo.toml
hoge_model &lt;- diesel_derive使う
hoge_XXX   &lt;- diesel使う
hoge_YYY   &lt;- diesel使う
docker-compose.yml
migrations
...
```
===

# テーブル
---------

* up.sqlとdown.sqlを書く

``` sql
CREATE TABLE hoge_suites (
  id SERIAL PRIMARY KEY,
  hoge_entry_id INT NOT NULL,
  hostname VARCHAR NOT NULL,
  status INT NOT NULL DEFAULT 0,
  CONSTRAINT unique_hoge_entry_id_hostname
             UNIQUE (
                      hoge_entry_id,
                      hostname
                      -- and other matrix
                     ),
  CONSTRAINT fkey_hoge_entry_id
             FOREIGN KEY(hoge_entry_id)
             REFERENCES hoge_entries(id) MATCH SIMPLE
             ON UPDATE NO ACTION
             ON DELETE CASCADE
);

```

===
# モデル
--------

``` rust
// なんかいっぱいderive
// QueryableとInsertableは分ける
#[derive(Default, Queryable, Associations, Identifiable, Debug, Clone)]
// belongs_to関係のstruct
#[belongs_to(HogeEntry)]
// has_many関係のテーブル
#[has_many(hoge_results)]
#[table_name=&#34;hoge_suites&#34;]
pub struct HogeSuite {
    pub id: i32,
    pub bench_entry_id: i32,
    // String
    pub hostname: String,
    pub status: HogeStatus,
}

```

===

# モデル
--------

```
// Insertableの方
#[derive(Default, Insertable, Debug, Clone)]
#[table_name=&#34;hoge_suites&#34;]
pub struct NewHogeSuite&lt;&#39;a&gt; {
    pub hoge_entry_id: i32,
    // Stringではなく&amp;str
    pub hostname: &amp;&#39;a str,
}
```

===

# enumの扱い
-----------

* dieselはenumのcodegenをサポートしてない
* 気合

===

# enumの扱い
-----------

```rust
// Queryableとかはderive出来ない
#[derive(Debug, Clone)]
pub enum HogeStatus {
    Waiting,
    Running,
    Finished,
    Failed,
    Canceled,
}

// 手で実装
impl&lt;BE, QB, BC&gt; FromSql&lt;Integer, BE&gt; for HogeStatus
    where QB: QueryBuilder&lt;BE&gt;,
          BC: BindCollector&lt;BE&gt;,
          BE: Backend&lt;RawValue = [u8], QueryBuilder = QB, BindCollector = BC&gt;
{
    fn from_sql(bytes: Option&lt;&amp;&lt;Pg as Backend&gt;::RawValue&gt;)
                -&gt; Result&lt;Self, Box&lt;Error + Send + Sync&gt;&gt; {
        use self::HogeStatus::*;
        match &lt;i32 as FromSql&lt;Integer, Pg&gt;&gt;::from_sql(bytes)? {
            0 =&gt; Ok(Waiting),
            1 =&gt; Ok(Running),
            2 =&gt; Ok(Finished),
            3 =&gt; Ok(Failed),
            4 =&gt; Ok(Canceled),
            n =&gt; Err(format!(&#34;invalid status: {}&#34;, n).into()),
        }
    }
}

impl&lt;BE, QB, BC&gt; FromSqlRow&lt;Integer, BE&gt; for HogeStatus
    where QB: QueryBuilder&lt;BE&gt;,
          BC: BindCollector&lt;BE&gt;,
          BE: Backend&lt;RawValue = [u8], QueryBuilder = QB, BindCollector = BC&gt;
{
    fn build_from_row&lt;T: Row&lt;BE&gt;&gt;(row: &amp;mut T) -&gt; Result&lt;Self, Box&lt;Error + Send + Sync&gt;&gt; {
        use self::HogeStatus::*;
        match &lt;i32 as FromSqlRow&lt;Integer, BE&gt;&gt;::build_from_row(row)? {
            0 =&gt; Ok(Waiting),
            1 =&gt; Ok(Running),
            2 =&gt; Ok(Finished),
            3 =&gt; Ok(Failed),
            4 =&gt; Ok(Canceled),
            n =&gt; Err(format!(&#34;invalid status: {}&#34;, n).into()),
        }
    }
}
```

===
# クエリ
--------

* モデルプロジェクトとは別
* 各プロジェクトのdb.rsで関数を定義
* SQLよりRsutのイテレータを意識した書き方

===
# クエリ
--------

```rust
pub fn is_hoge_finished&lt;&#39;a, Cn&gt;(conn: &amp;Cn, entry_id: i32) -&gt; Result&lt;bool, Error&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use self::schema::hoge_suites::dsl::*;
    // SELECT ... じゃなくてsourceからfileterして最後にselect
    let ret = hoge_suites
        .filter(hoge_entry_id.eq(entry_id))
        .select(status)
        // ここまでクエリビルダ
        .load::&lt;i32&gt;(conn)?
        // ここからイテレータ
        .into_iter()
        .all(|i| [HogeStatus::Finished as i32, HogeStatus::Failed as i32].contains(&amp;i));
    Ok(ret)
}

```

===
# 複雑なクエリ
-------------

* トランザクション
* join
* order by

===

# 複雑なクエリ
-------------

``` rust
pub fn pic_suite&lt;Cn&gt;(conn: &amp;Cn,
                     query: &amp;api::worker_poll::Request)
                     -&gt; Result&lt;Option&lt;(HogeEntry, HogeSuite)&gt;, Error&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use self::schema::hoge_entries::dsl::*;
    use self::schema::hoge_suites::dsl::*;
    use self::schema::hoge_suites::dsl::id;
    // transaction
    conn.transaction(|| {
        let suite = hoge_suites
             // join
            .inner_join(hoge_entries)
            .filter(status.eq(HogeStatus::Waiting as i32)
                .and(hostname.eq(&amp;query.hostname)))
            // order by
            .order(created_at.asc())
            .select((id, hoge_entry_id, hostname, status))
            .first::&lt;HogeSuite&gt;(conn)
            // NotFoundErrorをOptionにできる
            .optional()?;
        // transactionの中で普通にrustの式が書ける
        if let Some(s) = suite {
            let entry = hoge_entries.find(s.hoge_entry_id)
                .first::&lt;HogeEntry&gt;(conn)?;
            let suite =
                diesel::update(hoge_suites.find(s.id)).set(status.eq(HogeStatus::Running as i32))
                    .get_result::&lt;HogeSuite&gt;(conn)?;
            Ok(Some((entry, suite)))

        } else {
            Ok(None)
        }
    })
}
```

===

# もっと複雑なクエリ
-------------------

* 2重join
* dieselは2重joinを扱えない…

===

# もっと複雑なクエリ
-------------------


``` rust
pub fn load_all_data&lt;&#39;a, Cn&gt;(conn: &amp;Cn)
                             -&gt; Result&lt;Vec&lt;(HogeEntry, Vec&lt;((HogeSuite, HogeResult), Vec&lt;HogeProfile&gt;)&gt;)&gt;&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use diesel::types::{Integer, Timestamp, VarChar, Double};
    use diesel::pg::types::sql_types::{Array, Jsonb};
    use diesel::expression::dsl::*;
    use diesel::select;

    let status = sql::&lt;Integer&gt;(&#34;s.status&#34;);
    let ret = select(sql::&lt;(
        (Integer, VarChar, VarChar, Array&lt;VarChar&gt;,Timestamp, VarChar, Integer, Jsonb),
        (Integer, Integer, VarChar, Integer),
        (Integer, Integer, VarChar, Integer, Integer, VarChar),
        (Integer, Integer, VarChar, Integer, Double))&gt;(
        &#34;
e.id, e.repo, e.committish, e.files, e.created_at, e.command, e.format, e.format_data,
s.id, s.hoge_entry_id, s.hostname, s.status,
r.id, r.hoge_suite_id, r.hoge_name, r.score, r.status, r.result,
p.id, p.hoge_result_id, p.function_name, p.score, p.percent
FROM hoge_profiles p
INNER JOIN hoge_results r on r.id = p.hoge_result_id
INNER JOIN hoge_suites s ON s.id = r.hoge_suite_id
INNER JOIN hoge_entries e ON e.id = s.hoge_entry_id&#34;))
    .filter(status.eq(HogeStatus::Finished as i32))
    .load::&lt;(HogeEntry, HogeSuite, HogeResult, HogeProfile)&gt;(conn)?;
    let mut hash = HashMap::new();
    for (e, s, r, p) in ret {
        let mut hash_entry1 = hash         .entry(e.id).or_insert((e, HashMap::new()));
        let mut hash_entry2 = hash_entry1.1.entry(r.id).or_insert(((s, r), Vec::new()));
        hash_entry2.1.push(p);
    }
    let ret = hash.into_iter().map(|(_, v)| (v.0,  v.1.into_iter().map(|(_, p)| p).collect())).collect();
    Ok(ret)
}

```

===

# テスト
-------

* ￣\＿(ツ)＿/￣

===

# まとめ
--------

* 案外普通に使えるよ
* モデルはちょっと面倒かもね
* クエリは困ったらSQL生牡蠣
* マイグレーションとかはまた今度

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>WebAssemblyとコンパイラとランタイム</title>
      <link>/slide/WebAssemblytokonpairatorantaimu/</link>
      <pubDate>Thu, 16 Feb 2017 15:46:21 +0900</pubDate>
      
      <guid>/slide/WebAssemblytokonpairatorantaimu/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# WebAssemblyとコンパイラとランタイム
----------------------
[emscripten night !! #3 - connpass](https://emsn.connpass.com/event/48100/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# 何の話
---------

* WebAssemblyをバックエンドに使う言語を作りたい
* [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml)
* 既に発表したものの補足記事的な
  + [コンパイラの人からみたWebAssembly | κeenのHappy Hacκing Blog](https://keens.github.io/slide/konpairanoninkaramitaWebAssembly/)
  + ある程度再度説明します

===
# アジェンダ
------------

* なぜWebAssembly
* コンパイラ
* コード生成
* ランタイム

===

# なぜWebAssembly

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# なぜWebAssembly
----------------

* なんかバイナリでテンション上がる
* ポータブルでコンパクトで速い
* 機能的にJSを越えるかもしれない…？
* コンパイラがブラウザで動くと言語導入のハードル下がる
  + 気軽に試せる
  + コンパイラだけでなく吐いたコードもブラウザで動かしたい

===
# WASM over LLVM
----------------

* 既存のJS環境と協調する
  + JSとの相互呼び出しとか
* **non-determinismが少ない**
* 細かいアラインメント考える必要がない
* **API安定しそう**

===

# WASM over asm.js
--------------------

* ブラウザ以外への組込みもサポート
  + Node.jsとか
  + **JITエンジンに使えそう**
* プラットフォーム
* 実行までのレイテンシが短かい
* asm.jsより速度を出しやすい設計
* テキストフォーマットで生成コードの文法エラーが怖い
* 将来機能が増えるかも

===
# WebAssemblyの現状
-------------------

* Minimum Viable Product(MVP)
* 機能を削ってとりあえず動くものを作ってる
* 今はC/C++からLLVMを通して吐けるのが目標
  + C/C++には不要でも自分の言語に欲しい機能は……
* 今後SIMDとかスレッドとかDOM APIとか増えていく

===

# コンパイラ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# WASM概要
----------

* WASMには以下がある
  + 関数
    - 関数内ローカル変数
  + リニアメモリ
  + グローバル変数
  + テーブル
  + importテーブル
  + exportテーブル

===
# WASM実行モデル
--------------

* i32,i64,f32,f64のみ
* **スタックマシン**
  + 命令のオペランドや関数の引数はスタック経由で渡す
  + 1 passのコード生成が楽そう
* 無限のローカル変数が使える
  + 型がある
* 関数の引数はローカル変数経由で渡される
* コントロールフローはgotoじゃなくてstructured
  + 静的検証がしやすいらしい
  + 安全だけどコンパイラ的には…

===

# コントロールフロー
-------------------

* `loop` + `br` (名前付き)
* `block` + `br` (名前付き)
* `br_if` or `br_table`
* `if` + `else` + `end`
* `return`
* 等

===

# コントロールフロー
-------------------

* gotoがない
  + `br` はブランチじゃなくてブレイク
* gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
    + loop, block, br, br_ifを使う
* 高級言語から変換するなら `if` を使う
  + ifが2系統あることになる

===
# サンプル
---------

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===
# サンプル
---------

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (get_local 0)
    (get_local 1)
    (call 1)
    (get_local 1)
    (get_local 0)
    (i64.sub)
    (f64.convert_s/i64)
    (f64.div)
    (call 2))
  ...)
```

===
# サンプル
---------

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (call 2
      (f64.div
       (call 1 (get_local 0) (get_local 1))
       (f64.convert_s/i64
        (i64.sub
         (get_local 1)
         (get_local 0))))))
  ...)
```

===

# WebMLコンパイラ
------------

* パーサ、AST、HIR、MIR、LIR
* LIRがRTLなのでそれをWASMに変換したい
* gotoからstructured control flow…

===

```
[コード]
   | パーサ
 [AST] 型推論とか
   | AST2HIR
 [HIR] 早期最適化、K正規化、A正規化など
   | HIR2MIR
 [MIR] 諸々の最適化
   | MIL2LIR
 [LIR] シリアライズ、レジスタ割り当てなど
   | コード生成
 [WASM]
```

===

# 変数
------

* LIRはレジスタで計算する
* LIRはCFG由来の大量の変数を使う
  + レジスタ割り当ては一旦置いとく
* WASMはスタックで計算する
* どうコード生成すると最適か？

===

```
fun main: () -&gt; i64 = {
    entry@0:
        r0: i64 &lt;- 1
        r1: i32 &lt;- 0
        r2: i64 &lt;- 1
        r3: i64 &lt;- 2
        r4: i64 &lt;- 3
        r5: i64 &lt;- r3 * r4
        r6: i64 &lt;- 4
        r7: i64 &lt;- r5 + r6
        r8: i64 &lt;- r2 + r7
        r9: i64 &lt;- 1
        r10: i64 &lt;- 2
        r11: i64 &lt;- r9 + r10
        r12: i64 &lt;- 3
        r13: i64 &lt;- r11 * r12
        r14: i64 &lt;- 4
        r15: i64 &lt;- r13 + r14
        r16: i32 &lt;- 1
        jump_if_zero r16 then@1
        jump else@2
    then@1:
        r17: i64 &lt;- r8
        jump join@3
    else@2:
        r17: i64 &lt;- r15
        jump join@3
    join@3:
        r18: i64 &lt;- 1
        r19: i64 &lt;- r18 + r15
        r20: i64 &lt;- 1
        r21: i64 &lt;- call d@9(r20, )
        r22: i64 &lt;- 2
        r23: i64 &lt;- call #g37(r22, )
        r24: i64 &lt;- 1
        r25: i64 &lt;- heapalloc(16)
        [r25+0] &lt;- &lt;anonfun&gt;@11
        [r25+8] &lt;- r24
        r26: i64 &lt;- 0
        ret r26
}
```

===

# 変数割り当て
--------------

* SSAの1変数 = WASMの1ローカル変数
* スタックの効率利用を完全に無視
* 計算はLV→スタック→LVに書き戻し
* どうせスタックもLVもレジスタ扱いにしてレジスタ割り当てされるでしょ
* （測ってないけど）多分速度は変わらない

===

# CFG
-----

* コンパイラが一旦gotoを使うコントロールフローグラフを作る
* WASMにはgotoがない
* どうやったら生成出来るか？
* そもそも生成出来るの？

===

# blockと前方ジャンプ
------------

* `block` + `break` で前方ジャンプ
* 閉じ括弧の位置にジャンプ
* `block` の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  ...
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

# loopと前方ジャンプ
------------


* `loop` + `break`で後方ジャンプ
  + `loop` からの `break` はいわゆる `continue`
* 開き括弧の位置にジャンプ
* 閉じ括弧の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  ...
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===
# ジャンプのクロス
------------------

* 単一gotoは割り当て出来る
* 複数のgotoが入り組んだら？

===

# 絶対出来る
------------

* チューリング完全なら必ず書ける
  + whileとswitchでステートマシン作ればいい
* 効率的とは限らない
* 効率的なコードを吐きたい

===
# ステートマシンはつらい
-----------------------

* これをナイーブに変換すると…

```c
#include &lt;stdio.h&gt;
int main() {
  int sum = 0;
  for (int i = 1; i &lt;= 100; i++)
    sum += i;
  printf(&#34;1+...+100=%d\n&#34;, sum);
  return 0;
}
```

===

```javascript
function _main() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    var __label__ = -1;
    while(1)
        switch(__label__) {
        case -1:
            ...
            __label__ = 0;
            break;
        case 0:
            ...
            if ($4) {
              __label__ = 1;
              break;
            } else {
              __label__ = 2;
              break;
            }
        case 1:
            ...
            __label__ = 3;
            break;
        case 3:
            ...
            __label__ = 0;
            break;
        case 2:
            ...
            return 0;
        }
}
```

===
# ステートマシンはつらい
----------------------

* どうにかする必要がある
  + emscriptenは[ReLoop](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)で最適化
* なんか気に食わなかった
* そもそもステートマシンを使わずに生成したい
* 複数のgotoが入り組んだパターンを自分で考えたの紹介します。
* CFGと基本ブロックは知ってるかな？

===
# 前前
------

```
[ ]--+
 |   |
[ ]--+-+
 |   | |
[ ]&lt;-+ |
 |     |
[ ]&lt;---+
```

===
# 前前
------

```
(block
  (block
    ...
    (br 0)-+
    ...    |
    (br 1)-+-+
  )&lt;-------+ |
)&lt;-----------+
```

===
# 後後
------


```
[ ]&lt;-+
 |   |
[ ]&lt;-+-+
 |   | |
[ ]--+ |
 |     |
[ ]----+
```

===
# 後後
------

```
(loop&lt;-----+
  (loop&lt;---+-+
    ...    | |
    (br 1)-+ |
    ...      |
    (br 0)---+
  )
)
```

===
# 後前
------


```
[ ]&lt;-+
 |   |
[ ]--+-+
 |   | |
[ ]--+ |
 |     |
[ ]&lt;---+
```

===
# 後前
------

```
(block
  (loop&lt;---+
    ...    |
    (br 1)-+-+
    ...    | |
    (br 0)-+ |
  )          |
)&lt;-----------+
```

===
# 前後
------

```
[ ]--+
 |   |
[ ]&lt;-+-+
 |   | |
[ ]&lt;-+ |
 |     |
[ ]----+
```

===
# 前後
------

* 素直には出来ない…？
* 部分的にステートマーシン作る？

===
# 部分的ステートマーシン
-------------------------

```
[1]--+
 |   |
[2]&lt;-+-+
 |   | |
[3]&lt;-+ |
 |     |
[4]----+
```

===
# 部分的ステートマーシン
-------------------------

```
   [1] label = 0
    |
+-&gt;[br]-+ if label == 0
|   |   | then goto 3
|   |   | else goto 2
|   |   |
|  [2]  |
|   |   |
|  [3]&lt;-+ label = 1
|   |
+--[4]
```

===
# コード生成

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===

# フォーマット
------------

* バイナリフォーマットとテキストフォーマットがある
* バイナリ: wasm
  + コンパクト
  + intとかもパッキングする
* テキスト: wast
  + 人間可読+機械可読=S式
  + 低級にもちょっと高級にも書ける
  + 一旦アセンブラ噛まさないと動かない

===

# アセンブラ
------------

* オンメモリで生成するためにアセンブラ自作
  + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs)
  + ブラウザで動かすのに必要
  + 既存のツールは使えない
* アセンブラ自体ブラウザで動かすのでRust製
* まだ動かしてない

===

```rust
let mut mb = ModuleBuilder::new();
let f = mb.new_function(FunctionBuilder::new(funtype!((i32, i32) -&gt; i32))
    .code(|cb, args| {
        cb.constant(2)
            .get_local(args[0])
            .i32_add()
    })
    .build());
mb.export(&#34;addTwo&#34;, f);
let module = mb.build();
```

===
# スタック領域
-------------

* Cでいう`struct foo x;`みたいにエフェメラルな多ワード領域が欲しい
* WebAssemblyのローカルストレージはLVだけ
  + 最大1ワードしか保存出来ない
* 可能性
  1. 諦めてメモリに確保（場合によっては最適化で消えるかも）
  2. ワード毎に分割してLVに保存（大変だけど速そう）

===
# ランタイム

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 言語のランタイム
-----------------

* 主にはGC
* その他データのメモリ表現
  + アラインメントも
* スタック領域
* FFI
* コンパイラなのでシンボルテーブルはなし

===
# メモリ
--------

* mallocとかはない
* ページ単位のアロケーションだけ
* 自前でGCを実装することになる

===
# GC
-----

* コールスタックを遡れない
  + コールスタックをGCルートに出来ない
* メモリonlyな走査なら可能
  + ポインタを都度メモリ領域(arena)にコピーすれば良い。
  + arenaもルートになる
  + コールスタックと連動するのでスタックで管理出来る。
  + CF [Matzにっき(2013-07-31)](http://www.rubyist.net/~matz/20130731.html)
  + ただしコンパイラなので関数全部をsave/restoreで囲んだりはしない。

===
# アロケータ
------------

* どうにか書いてブラウザでリンクする必要がある
  + ブラウザにもランタイムライブラリの時代…
  + WASMはライブラリ間でメモリ共有出来る
* とりあえずRustで書く方針
  + WASMのページアロケートとかどうすればいいんだろう
  + まだ色々未定

===

# メモリ表現
------------

* 出来れば楽して64bit統一したかった
  + i32やf32を抹殺したかった
* WASM32しかないのでポインタが32bit…
* 仕方ないので64bitアラインメントでパディングする
* 空いた32bitの使い道は未定
  + 静的型付だし型タグが要らない
  + 代数的データ型のタグ？

===

# 高階関数
----------

* WASMに関数ポインタがない
* テーブルに関数を登録してインデックス参照
  + C++のvtableのための機能
  + 型も動的チェック
* ちょっと遅そう
* 気合でインライン化を頑張ろう

===

# FFI
------

* JSの関数を呼びたい
* 細かいところどうなってるんだろう
  + 例外は？JSオブジェクトは？GCは？
* 型付…
* ノープラン

===
# 雑にまとめ
-------------

* WASMはちょっと高級なので最適化コンパイラは困るよ
  + 雑なコンパイラにはむしろ嬉しい
* コード生成は努力で解決
* GCは割とつらいよ
  + 将来楽になるかも
* JS連携や将来のスレッドとかはみんなで考えよう

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>