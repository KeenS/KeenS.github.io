<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Jan 2016 22:23:45 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Isabelleに入門した</title>
      <link>http://keens.github.io/blog/2016/01/12/isabelleninyuumonshita</link>
      <pubDate>Tue, 12 Jan 2016 22:23:45 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2016/01/12/isabelleninyuumonshita</guid>
      <description>

&lt;p&gt;κeenです。連休中にIsabelleを少しばかり触ったのでその時のまとめを。&lt;/p&gt;

&lt;h1 id=&#34;isabelleって:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;Isabelleって？&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://isabelle.in.tum.de/&#34;&gt;公式&lt;/a&gt;。定理証明支援系の一つ。SML処理系の1つ、Poly/MLで書かれている。
どうやらHOL(Higher Order Logic)に焦点を当てているようだが詳しいことは分かっていない。&lt;/p&gt;

&lt;p&gt;あと、Linuxが正式にはGNU/LinuxというようにIsabelleもIsabelle/Isar/HOLと言うべきらしいが、まだよく分かっていない。&lt;/p&gt;

&lt;h1 id=&#34;インストール:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;インストール&lt;/h1&gt;

&lt;p&gt;公式サイトからダウンロード出来るが、後述のProofGeneralの関係上Isabelle2014をインストールする。&lt;/p&gt;

&lt;h1 id=&#34;エディタ設定:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;エディタ設定&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ProofGeneral/PG&#34;&gt;ProofGeneral&lt;/a&gt;を使う。恐らくGitHub版を使った方がいい。設定は1行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(load (expand-file-name &amp;quot;/path/to/ProofGeneral/generic/proof-site&amp;quot;) nil t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くだけ。多分&lt;code&gt;prettify-symbol-mode&lt;/code&gt;も自動でonになる。(なってなかったらなんか適当に設定しておこう。global-prettify-symbols-modeとかで。)
Isabelleの古いドキュメントを見てるとX-Symbolsモードなるものが出てくるが、恐らく現在の&lt;code&gt;prettify-symbol-mode&lt;/code&gt;だと思う。&lt;/p&gt;

&lt;h1 id=&#34;はじめる:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;はじめる&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;isabelle.in.tum.de/doc/tutorial.pdf&#34;&gt;この&lt;/a&gt;チュートリアルを進めている。まだ途中。タクティックも&lt;code&gt;tactic_ind&lt;/code&gt;と&lt;code&gt;auto&lt;/code&gt;しか知らない。&lt;/p&gt;

&lt;p&gt;とりあえず拡張子は.thyにしとくとEmacsが認識してくれる。&lt;/p&gt;

&lt;h1 id=&#34;所感:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;所感&lt;/h1&gt;

&lt;p&gt;Coqを触ったことあるとそれなりにスムーズに入れた。ただしダブルクォートはキモい。
Coqも3つくらいの言語が混ってるらしいのでその内のGallinaの部分をクォートで囲っている感じなのだろうか。
クォートの部分はHOLがどうのこうの言ってた気がする。&lt;/p&gt;

&lt;p&gt;まだどんなことが出来るのか分からないのでCoqの方がマシじゃんという感想しかない。&lt;/p&gt;

&lt;h1 id=&#34;困ったところ:6b8d46c70d8b531bde7fec53a1ad6c6a&#34;&gt;困ったところ&lt;/h1&gt;

&lt;p&gt;チュートリアル中に数学記号が出てくる。∀とか∃とか¬とか。断りもなしにソースコード中にも。
最初、組版の都合上置き換えたのだろうとCoqのようにforall, exists, notと打っていたがエラーになった。じゃあ、とユニコードで打ってみてもエラーになった。
結局、TeXのようにコマンドを入力するとWYSIWYGのようにシンボルになるらしい。
さらにややこしいことにEmacsに特定のシーケンスでキーを入力するとそのコマンドを挿入してくれる機能がついている。&lt;/p&gt;

&lt;p&gt;とりあえず今のところ分かっているものをまとめる&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;見た目&lt;/th&gt;
&lt;th&gt;Emacsでの入力&lt;/th&gt;
&lt;th&gt;実際のタグ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;∀&lt;/td&gt;
&lt;td&gt;\forall&lt;/td&gt;
&lt;td&gt;&amp;lt;forall&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;∃&lt;/td&gt;
&lt;td&gt;\exists&lt;/td&gt;
&lt;td&gt;&amp;lt;exists&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;¬&lt;/td&gt;
&lt;td&gt;\not&lt;/td&gt;
&lt;td&gt;&amp;lt;not&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;∧&lt;/td&gt;
&lt;td&gt;\and, /&lt;/td&gt;
&lt;td&gt;&amp;lt;and&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;∨&lt;/td&gt;
&lt;td&gt;\or, \/&lt;/td&gt;
&lt;td&gt;&amp;lt;or&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;⇒&lt;/td&gt;
&lt;td&gt;\Rightarrow, =&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;Rightarrow&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;→&lt;/td&gt;
&lt;td&gt;\rightarrow, -&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;rightarrow&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;≡&lt;/td&gt;
&lt;td&gt;\equiv, ==&lt;/td&gt;
&lt;td&gt;&amp;lt;equiv&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;≠&lt;/td&gt;
&lt;td&gt;\noteq, ~=&lt;/td&gt;
&lt;td&gt;&amp;lt;noteq&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;なんかそれっぽい記号を連ねてみたら色々出てきた。けどユニコード入力出来ないから載せれないw。&lt;/p&gt;

&lt;p&gt;逆引きしたい。見た目からコマンドを知りたい。&lt;/p&gt;

&lt;p&gt;なんかまとまりないけどそんな所で。頭痛い。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#のpthreadバインディング作った</title>
      <link>http://keens.github.io/blog/2016/01/11/sml_nopthreadbaindingutsukutta</link>
      <pubDate>Mon, 11 Jan 2016 00:57:20 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2016/01/11/sml_nopthreadbaindingutsukutta</guid>
      <description>

&lt;p&gt;κeenです。またしても深夜になってしまいましたがSML#のpthreadバインディングを作ったのでその報告を。&lt;/p&gt;

&lt;p&gt;SML#はC FFIを簡単に書け、さらにランタイムがnon Moving GCなのでSML#自体はサポートしていないもののランタイムそのものはマルチスレッドに対応しているという大変興味深い特徴を持っています。
処理系側としてもマルチスレッドが欲しいならpthreadのFFIを使って好きにやってくれというスタンスのようです。&lt;/p&gt;

&lt;p&gt;ということでさまざまなマルチスレッドアプリケーションの下地になるべくpthreadのバインディングを作りました。とはいってもまだ不完全ですが。&lt;/p&gt;

&lt;p&gt;どういうものが用意出来ているかは&lt;a href=&#34;https://github.com/KeenS/smlsharp_pthread/blob/master/src/pthread.smi&#34;&gt;こちら&lt;/a&gt;が一覧として機能しています。&lt;/p&gt;

&lt;p&gt;SML的には改善の余地がある(例えば、排他的なフラグをdatatypeで定義するとか)のですが、あくまで低レベルなバインディングに徹するためにintのままで残してあります。&lt;/p&gt;

&lt;p&gt;他にはCのマクロで実現されていたものはインポート出来ないのでどうにかしてあったりどうにかしてなかったりしてます。
例えば&lt;code&gt;PTHREAD_XXX_INITIALIZER&lt;/code&gt;はマクロで定義された初期値ですが、SMLからは参照出来ないのであきらめました。
代わりに&lt;code&gt;pthread_xxx_new&lt;/code&gt;関数を用意したので&lt;code&gt;pthread_xxx_init&lt;/code&gt;と併せて使うことでそれらの値を初期化出来ます。
メモリ確保と初期化同時にやれよとの声が聞こえてきそうですが繰り返すとあくまで低レベルなバインディングなのでそういうのは他に譲ることにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pthread_cleanup_{pop/push}&lt;/code&gt;はバインディングが書けませんでした。
それらはマクロとして実現されていて、しかも&lt;code&gt;pthread_cleanup_push&lt;/code&gt;で開き括弧を挿入して&lt;code&gt;pthread_cleanup_pop&lt;/code&gt;で閉じるというエグい実装なので移植は無理でしょう。
POSIX的にもマクロとして実現して良いことになっているので文句は言えません。&lt;/p&gt;

&lt;h1 id=&#34;サンプルコード:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;サンプルコード&lt;/h1&gt;

&lt;p&gt;レポジトリにも入ってますが、スレッドを作る小さな例だとこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;open PThread
fun exit reason = (
    print (reason ^ &amp;quot;\n&amp;quot;);
    OS.Process.exit OS.Process.failure
)


val fromUnitPtr = SMLSharp_Builtin.Pointer.fromUnitPtr
val toUnitPtr = SMLSharp_Builtin.Pointer.toUnitPtr
(* durty hack *)
val sml_str_new = _import &amp;quot;sml_str_new&amp;quot;: (string) -&amp;gt; char ptr

fun threadFunc (arg:unit ptr): unit ptr = let
    val cp: char ptr = fromUnitPtr arg
    val s = Pointer.importString cp
    val () = print s
    (* val ret =ref _NULL *)
    (* val () = ret := (String.size s) *)
in
    (* ret *)
    _NULL
end
                   
val () = let
    val tattr = ref (pthread_attr_new())
    val s = pthread_attr_init(tattr)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;pthread_attr_init&amp;quot;
             else ()
    val thread_ref = ref (pthread_new())
    val arg = sml_str_new &amp;quot;Hello world\n&amp;quot;
    val s = pthread_create(thread_ref, tattr, threadFunc, toUnitPtr arg)
    val t1 = !thread_ref
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;thread creation failed&amp;quot;
             else ()
    val s = pthread_attr_destroy(tattr)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;pthread_attr_destroy&amp;quot;
             else ()
    val () = print &amp;quot;Message from main()\n&amp;quot;;
    val resRef = ref (Pointer.NULL ())
    val s = pthread_join(t1, resRef)
    val () = if s &amp;lt;&amp;gt; 0
             then exit &amp;quot;thread creation failed&amp;quot;
             else ()
    (* val () = print (&amp;quot;Thread returned&amp;quot; ^ Int.toString  (!resRef) ^ &amp;quot;\n&amp;quot;) *)
in
    ()
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;言わずとも雰囲気で読み取れそうですがこの例はCのサンプルをそのまま移植しました。Cだと&lt;code&gt;(void *)&lt;/code&gt;と文字列で相互変換が出来るのですがSML#だと一筋縄では出来ないので内部APIを叩くとかのかなりアレなハックしてます。
&lt;a href=&#34;https://github.com/smlsharp/smlsharp/issues/45&#34;&gt;SML#にイシューに上げ&lt;/a&gt;ましたが&lt;code&gt;(void *)&lt;/code&gt;が強敵ですね。&lt;/p&gt;

&lt;h1 id=&#34;可搬性の話:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;可搬性の話&lt;/h1&gt;

&lt;p&gt;ところで、pthreadはp(POSIX)の名が付いている通り様々なプラットフォームで利用出来、そしてそれぞれのプラットフォーム毎に実装が異なります。
勿論、POSIXで定められているのでAPIレベルでは互換性がある(≒関数のバインディングは問題ない)のですが、ABI、データの表現に互換性がありません(≒データ型のバインディングに問題がある)&lt;/p&gt;

&lt;p&gt;実はその辺で苦労がありました。今のところ手元の環境(Linux)でしか移植が済んでません。しかし他のプラットフォームの移植は書ける形になっています。
これは&lt;a href=&#34;http://keens.github.io/blog/2015/12/26/sml_tocpuripurosessanorenkei/&#34;&gt;以前&lt;/a&gt;書いたSMLのファイルにCのプリプロセッサを適用するというなんともいえないハックを使うことで実現しています。
他のプラットフォームに移植するには&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;どういうマクロが定義されている時にどのプラットフォームのpthreadを使っているかの対応を調べる&lt;/li&gt;
&lt;li&gt;そのプラットフォームの&lt;code&gt;pthread.h&lt;/code&gt;を入手してデータ型を移植する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;手順が必要です。私は手元の環境で動かすのが精一杯なのでMacとかで動かしたい方がいればプルリクを頂けると。
前述の通り、関数のバインディングは可搬性があるので必要なのはデータ型と定数の移植です。ある程度はプリプロセッサも使えるのでほぼヘッダファイルを移植する感じですね。&lt;/p&gt;

&lt;p&gt;まあ、実をいうと関数の移植も細々したものが面倒なので放置していたりします。ここら辺は作業ゲーなので気が向いたらやります。&lt;/p&gt;

&lt;p&gt;あとは若干迷っているのが必ずしも実装されているとは限らないオプショナルな機能の移植ですね。
バリアやリードライトロック、スピンロックがそれにあたります。
可搬性とはいってもSML#自身が動く環境が限られているのでMacでもそれらが使えるなら移植してしまおうかと思っていますがまだ調べきれてません。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:2d3ca0e3b6ad5447c7ddca19d53be02a&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;pthreadのバインディング作ったよ&lt;/li&gt;
&lt;li&gt;まだバインドが書かれてない関数もあるよ&lt;/li&gt;
&lt;li&gt;Macの移植パッチ待ってるよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rustといえどリソースの解放は注意</title>
      <link>http://keens.github.io/blog/2016/01/08/rusttoiedoriso_sunokaihouhachuui</link>
      <pubDate>Fri, 08 Jan 2016 00:50:31 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2016/01/08/rusttoiedoriso_sunokaihouhachuui</guid>
      <description>&lt;p&gt;κeenです。深夜にですが小ネタを。&lt;/p&gt;

&lt;p&gt;Rustを使っているとついついリソースの解放のことは忘れてしまうのですが、注意しないといけない類のリソースがあります。&lt;/p&gt;

&lt;p&gt;その1つが&lt;code&gt;BufWriter&lt;/code&gt;です。
バッファリングライター全般に言えることですが、奴らはメモリ上にまだ書き込まれてない値を保持しているので解放する前にそれらを掃き出す必要があります。
その時に書き込み例外が起き得るので、解放も安全な処理ではないのです。Javaのtry-with-resource文を使わないファイルの扱いについては悪名高いですが、あれは仕方ない話なのです。&lt;/p&gt;

&lt;p&gt;ところでRustのリソースの解放は&lt;code&gt;Drop&lt;/code&gt;トレイトの&lt;code&gt;drop&lt;/code&gt;が担っていますが、返り値は&lt;code&gt;void&lt;/code&gt;です。基本的には裏で動くので当然ですね。
そして、&lt;code&gt;drop&lt;/code&gt;はpanicを起こさないことが望ましいです。Rustは今のところ(1.5時点)panicから回復出来ないのでそれはそうでしょう。では、エラーを返り値でも返せない、panicも起こせない中&lt;code&gt;BufWrite&lt;/code&gt;はどうエラーを扱っているのでしょう。それは実装を見ると分かります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;W: Write&amp;gt; Drop for BufWriter&amp;lt;W&amp;gt; {
    fn drop(&amp;amp;mut self) {
        if self.inner.is_some() {
            // dtors should not panic, so we ignore a failed flush
            // 訳: dropはパニックすべきではない、だからflushの失敗は無視する
            let _r = self.flush_buf();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…はい。中々アレなことをやってくれますね。&lt;/p&gt;

&lt;p&gt;ということで&lt;code&gt;BufWrite&lt;/code&gt;を使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
  let file = File::create(&amp;quot;some_file.txt&amp;quot;).unwrap();
  let br = BufWrite::new(&amp;amp;file);

  // do something

  match br.flush_buf() {
    Ok(()) =&amp;gt; (),
    Err(e) =&amp;gt; // handle errors
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにライフタイムの終わりで&lt;code&gt;flush_buf&lt;/code&gt;を呼ぶのが作法的な方法です。
&lt;code&gt;unwrap&lt;/code&gt;と同じく掃き出せない時に無視されてもいいならそこまでする必要はありませんが、それでもスコープの終わりに意図的に&lt;code&gt;flush_buf&lt;/code&gt;を呼んでない旨を書くと丁寧でしょう。&lt;/p&gt;

&lt;p&gt;因みにスコープが大きすぎる時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;{
  let file = File::create(&amp;quot;some_file.txt&amp;quot;).unwrap();
  {
    let br = BufWrite::new(&amp;amp;file);
  
    // do something with br
  
    match br.flush_buf() {
      Ok(()) =&amp;gt; (),
      Err(e) =&amp;gt; // handle errors
    }
  }
  
  // do other things

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにスコープを作って不要なライフタイムを切り詰めるイディオムもあるので併せてどうぞ。&lt;/p&gt;

&lt;p&gt;余談ですが&lt;code&gt;std::fs::File&lt;/code&gt;の実体はCの&lt;code&gt;FILE&lt;/code&gt;構造体ではなくファイルディスクリプタなのでバッファリングはしてません。のでこちらは気にする必要はありません。&lt;/p&gt;

&lt;p&gt;という訳で小ネタでした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016年注目していきたい技術</title>
      <link>http://keens.github.io/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu</link>
      <pubDate>Fri, 01 Jan 2016 20:09:36 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu</guid>
      <description>

&lt;p&gt;2016年個人的に注目したいというか力を入れたいというか成行を見守りたいというか、そんな技術達を書き連ねていく。ものによっては「何を今更」と思うかもしれないがあくまで私にとって、だ。&lt;/p&gt;

&lt;p&gt;順不同。&lt;/p&gt;

&lt;h1 id=&#34;apache-drill:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Apache Drill&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://drill.apache.org/&#34;&gt;公式&lt;/a&gt;。様々なデータソースに対してANSI SQLでクエリを投げれるやつ。
ビッグデータの時代にETL無しで迅速にデータを分析出来るようにするために開発されてるらしい。&lt;/p&gt;

&lt;p&gt;様々なデータソースというのは本当に凄くて、CSVとJSONをJOIN出来たりする。
あるいはTSVの生ログとRDBにあるマスタデータをJOIN出来たりする。
個人的にはデータベースから抽出したCSVにクエリを投げたい時に便利かな、と思って注目してる。viewや一時テーブルを作る権限がないデータベースだってある。&lt;/p&gt;

&lt;p&gt;あるいは、Zookeeperを使って分散モードで実行も出来るのでBigQueryみたいなのをオンプレ環境で動かすのにも使えるようだ。
その時はデータフォーマットは&lt;a href=&#34;https://drill.apache.org/docs/parquet-format/&#34;&gt;Parquet&lt;/a&gt;で保存すると速いらしい。&lt;/p&gt;

&lt;h1 id=&#34;rust:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Rust&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;。言わずもがな。去年の5月に1.0が出て、今年で一周年を迎える。そろそろ安全なシステムプログラミング言語としての地位を築いて欲しい。
今までは安全なシステムプログラミング言語が不在で、不適切にも関らずJavaで代用されることが多かったように思える。&lt;/p&gt;

&lt;p&gt;やっぱりGCがあると安定性に心配が残るし、フルマネージングなランタイムシステムを持ってると他のランタイム、例えばlibuvなんかと相性が悪い。&lt;/p&gt;

&lt;p&gt;かといってC++やCだと安全でない。システムが巨大になった時にデバッグがつらくなる。&lt;/p&gt;

&lt;p&gt;Rustには是非Javaより速くて実行が安定しててC++よりも安全でCよりも抽象力があってマルチスレッドを使い始めても開発効率が落ちない言語として活躍して欲しい。&lt;/p&gt;

&lt;h1 id=&#34;kafka:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Kafka&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/&#34;&gt;公式&lt;/a&gt;。「ただのキュー」と言ってしまえばそれまでだが高トラフィックを捌ける信頼性の高いキューだ。
OSのキャッシュを上手く使ってるだとかJavaだからといって富豪的プログラミングをしてないだとか分かってる人が作った感じがしてすごくいい。&lt;/p&gt;

&lt;p&gt;fluentdとかでデータを流すにしてもバックプレッシャーをやりたい、流す先が落ちてた時の事を考えたい、バッチじゃなくてストリーム（ミニバッチでもいいけど）でやりたい、とかの要望に応えてくれる。&lt;/p&gt;

&lt;h1 id=&#34;floki:1c55afff208b866183fc0b210a2a3f36&#34;&gt;floki&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/arthurprs/floki&#34;&gt;Github&lt;/a&gt;。Rustで作られているキュー。
kafkaに言及しているがRedisプロトコルをベースとしていて、色々コマンドがあるようなのでkafkaとは少し毛色が違いそう。&lt;/p&gt;

&lt;p&gt;別にこれが次世代キューだ！なんて思ってる訳ではなくてRustで作られたミドルウェアがどうなっていくのか興味があるので観察対象に入っている。&lt;/p&gt;

&lt;h1 id=&#34;robots:1c55afff208b866183fc0b210a2a3f36&#34;&gt;RobotS&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gamazeps/RobotS&#34;&gt;Github&lt;/a&gt;。RustのActor System。ほぼakkaの移植みたいだ。&lt;/p&gt;

&lt;p&gt;Rustにアクターシステムが必要かは置いておいて、アクターシステムをRustの上に作るのは正解だと思ってる。
何故ならJVMや.NETのようにStop The Worldはないし、Erlangとは比べものにならないくらい速い。
さらに、もしかしたらだが、Rustなら所有権があるのでうまくすればメッセージを送るのにメモリコピーが起きないかもしれない。
まあ、Go使えばいいじゃんと言えばそれまでである。&lt;/p&gt;

&lt;h1 id=&#34;redox:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Redox&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.redox-os.org/&#34;&gt;公式&lt;/a&gt;。Rustで開発されているOS。まだまだ開発途上だがゆくゆくはMINIXくらいの地位は築いて欲しい。
コマンドは全然ないのにGUIは動いていたりZFSをサポートしていたりする。開発者は「本気でやってる」と言っていたのでそれなりのものは出来るんだろうと期待している。&lt;/p&gt;

&lt;p&gt;コマンド群は、Rustでcoreutilsを書き直そうという&lt;a href=&#34;https://github.com/uutils/coreutils&#34;&gt;coreutils&lt;/a&gt;というプロジェクトがある。それを使えると面白いんじゃないかと思っている。
こういう時ってまずはRustのコンパイラの移植をしないといけないのかな？よく分かってない。&lt;/p&gt;

&lt;h1 id=&#34;ats2:1c55afff208b866183fc0b210a2a3f36&#34;&gt;ATS2&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ats-lang.org/&#34;&gt;公式&lt;/a&gt;。線形型が肌で感じられる体になりたい。そのために修行したい。&lt;/p&gt;

&lt;p&gt;SML likeなシンタックスなので学習コストが低い。依存型の部分もCoqに似てる気がするのでそこも学習コストが低い。つまり線形型の学習に集中出来る。
ほとんど実用ではなく修行のために学習したい。もしかしたらアプリケーションくらい作れるのでは、とも思っている。
あとCとの相互連携が出来るのも良い。&lt;/p&gt;

&lt;h1 id=&#34;r:1c55afff208b866183fc0b210a2a3f36&#34;&gt;R&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.r-project.org/&#34;&gt;公式&lt;/a&gt;。最近データを扱うことが多くなった。そういう時に簡単に可視化が出来るこの言語は素晴しい。
まだほとんどコピペでしか動かしてないが、ちょこっとした分析くらいなら自分の手で書けるようになりたい。&lt;/p&gt;

&lt;h1 id=&#34;異常検知:1c55afff208b866183fc0b210a2a3f36&#34;&gt;異常検知&lt;/h1&gt;

&lt;p&gt;機械学習というとぼんやりしてるので絞ってみる。時系列データにスパイクがあったり、集団から外れた値があるのを検出する。
これが出来れば職人が手作業で検査していたものを自動化出来る。こういうのをやってみたいなぁとぼんやり願ってはいるがまだ遠い。&lt;/p&gt;

&lt;h1 id=&#34;coq:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Coq&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://coq.inria.fr/&#34;&gt;公式&lt;/a&gt;。&lt;a href=&#34;http://proofcafe.org/sf/&#34;&gt;ソフトウェアの基礎&lt;/a&gt;をずっとやっていたが、ProofGeneralのバグなのか、とある証明を食わせるとProofGeneralがフリーズするようになって以来途絶えている。
バグを直すか回避策を見付けるかして先に進みたい。こちらが終わったら次は&lt;a href=&#34;http://www.amazon.co.jp/Interactive-Theorem-Proving-Program-Development/dp/3540208542&#34;&gt;CoqArt&lt;/a&gt;がある。
&lt;a href=&#34;https://twitter.com/search?q=%23readcoqart&amp;amp;src=typd&amp;amp;lang=ja&#34;&gt;#readcoqart&lt;/a&gt;にも行く行く詐欺をしてるので行かねば。&lt;/p&gt;

&lt;h1 id=&#34;isabelle:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Isabelle&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://isabelle.in.tum.de/&#34;&gt;公式&lt;/a&gt;。SMLユーザとしてはCoqをやるならIsabelleもやらないとな、と思っている。
&lt;a href=&#34;http://qiita.com/myuon_myon/items/11bb5bfc2e274fdaea7c&#34;&gt;ここ&lt;/a&gt;によるとCoqとはまた違った証明のやりかたらしいのでそういう意味でもやる意味あるのかな、とか。
Coqが終わってさらに手が空いてたら、くらい。&lt;/p&gt;

&lt;h1 id=&#34;prolog:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Prolog&lt;/h1&gt;

&lt;p&gt;修行の1つとしてPrologをやりたい。というか、作りたい。その前にまずはPrologを書けるようになりたい。
少しやってみているが、GNU PrologもSWI PrologもただのPrologとしか呼ばれていなくて情報を見付けるのに苦難している。
Lispみたくそれっぽい見た目と挙動をしていたらPrologを主張出来るのだろう。&lt;/p&gt;

&lt;p&gt;今気になっているのは制約ソルバとPrologの関係。
もし制約ソルバでPrologを実装出来るなら実装をサボれるし制約ソルバを触ってみれる。ただ、制約ソルバがチューリング完全な気がしないので使えるとしても部分的な気がする。&lt;/p&gt;

&lt;h1 id=&#34;fortran:1c55afff208b866183fc0b210a2a3f36&#34;&gt;Fortran&lt;/h1&gt;

&lt;p&gt;神託の言語。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;κeen が 2016 年に新たに学ぶべき言語は『Fortran』です。&amp;#10;&lt;a href=&#34;https://twitter.com/hashtag/1year1lang?src=hash&#34;&gt;#1year1lang&lt;/a&gt;&amp;#10;&lt;a href=&#34;https://t.co/sDP4Kk2Vfx&#34;&gt;https://t.co/sDP4Kk2Vfx&lt;/a&gt;&amp;#10;&amp;#10;うっ。。ぐ。。。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/682535448124637184&#34;&gt;2015, 12月 31&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;まあ、ベクトル計算楽そうだし機械学習の手習いついでにアルゴリズムを実装してみるのも悪くないのかな、と思えてきた。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;思ったより言語の話題が多かった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ATS2の観が整理出来た</title>
      <link>http://keens.github.io/blog/2016/01/01/ats2nokangaseiridekita</link>
      <pubDate>Fri, 01 Jan 2016 18:52:56 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2016/01/01/ats2nokangaseiridekita</guid>
      <description>

&lt;p&gt;κeenです。ATS2には3つの世界があります。動的な世界、静的な世界、証明の世界。
&lt;a href=&#34;http://keens.github.io/blog/2015/12/29/ats2noizongatawotsukatteavlki/&#34;&gt;前回&lt;/a&gt;の記事では静的な世界を色々扱ってみました。
今回は証明の世界である観について少し。&lt;/p&gt;

&lt;p&gt;2016-1-2: いくつか誤植を直しました(用語で言えば、 注観→駐観 が正解でした)。&lt;/p&gt;

&lt;h1 id=&#34;観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;観&lt;/h1&gt;

&lt;p&gt;観(view)は、線形型によるリソース管理をするための仕組みです。
静的な世界と同様コンパイル時に検査されたらバイナリには現われませんが関数の引数として渡したり観を扱う関数(証明関数)を定義出来たり
動的な世界と似た部分があります。&lt;/p&gt;

&lt;h1 id=&#34;駐観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;駐観&lt;/h1&gt;

&lt;p&gt;at-viewの和訳だそうです。これは観の中でも特に特定のアドレスにデータが存在することの証明を表わす観です。
線形型の主な管理対象がメモリなので特別扱いされているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;抽象観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;抽象観&lt;/h1&gt;

&lt;p&gt;任意のリソース管理に使っていい観。これ自体は実体を持たないので後述のデータ観などで実体を与える必要があります。
ドキュメントではロックの管理だとかに使う例が載っていました。&lt;/p&gt;

&lt;h1 id=&#34;観型:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;観型&lt;/h1&gt;

&lt;p&gt;ただ単に観と型をくっつけたものです。「あると便利なのは分かるけど…」と思ってましたが、だんだん理解が追いついてきました。&lt;/p&gt;

&lt;p&gt;1つには観と型を1つの記法で表わせるので記述が楽になる。もう1つにはある型に対して必ず線形型によるリスース管理がされることを保証出来る。&lt;/p&gt;

&lt;p&gt;もう1つの用途が思い浮かんだらなるほど、となりました。&lt;/p&gt;

&lt;p&gt;こちらは駐観に限らず任意の観と任意の型を組み合わせれるようです。&lt;/p&gt;

&lt;h1 id=&#34;データ観:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;データ観&lt;/h1&gt;

&lt;p&gt;動的な世界でのデータ型のように、静的な世界でのデータ種のように、証明の世界にもデータ観というものがあります。&lt;/p&gt;

&lt;p&gt;例えば、あるかもしれないしないかもしれないリソースを表わすのにオプショナル観が使えそうだ、など。&lt;/p&gt;

&lt;p&gt;これ自体は新しい観を作るためのものです。&lt;/p&gt;

&lt;h1 id=&#34;データ観型:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;データ観型&lt;/h1&gt;

&lt;p&gt;これは動的な世界と証明の世界両方に跨るものです。おおざっぱにはデータ型とデータ観を組み合わせたものです。
つまり、データ型であり、データ観であり、両方合わさってるので観型でもあります。&lt;/p&gt;

&lt;p&gt;「データ型を観で管理しようとしたら同じようなデータ観を作ることになるしまとめて作れたら嬉しいよね」が一番分かりやすい説明でしょうか。&lt;/p&gt;

&lt;p&gt;データ観型専用のシンタックスなどもあるようなので単なるシンタックスシュガーではなさそうです。&lt;/p&gt;

&lt;p&gt;こちらは駐観というかメモリ管理の観が割り当てられるみたいです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Rustと比べると随分リッチなリソース管理が出来ますね。&lt;/p&gt;

&lt;h1 id=&#34;まだ良く分かってない部分:8a288297483f9c5eb0b6a24b376548e7&#34;&gt;まだ良く分かってない部分&lt;/h1&gt;

&lt;p&gt;ATS2にはprop（命題）というものもあります。「観はpropの線形バージョン」と書いてあるのですがどう分けられているのでしょうか。
例えば観型にpropは渡せなそうな気がしますが、証明関数には命題も観も渡せそうな気がします。&lt;/p&gt;

&lt;p&gt;微妙に命題と観が共存していたり排他的であったりします。動的な世界のdatatyp, 静的な世界のdatasort, 証明の世界のdataviewという理解でいるとdatapropの居場所がなくなります。&lt;/p&gt;

&lt;p&gt;今のところ、証明の世界も普通の命題であるpropと線形の命題であるviewに分かれていて、
それらはsortが違うので一部では排他的であり、どちらのsortに対しても対応しているものもあるので共存してるようにも見えるという仮説を立てています。&lt;/p&gt;

&lt;p&gt;ドキュメントにも種viewや種propという記述があるので種がsortが違うのは正しそうです。&lt;/p&gt;

&lt;p&gt;しかしそうするとdatasortとかで新しく作った種はどこの世界に住むことになるんでしょうか。静的な世界?証明の世界に住む新しい種を定義出来ない?&lt;/p&gt;

&lt;p&gt;ビルトインの種viewと種propの静的な項(の静的な項)だけが証明の世界の住人になれる?&lt;/p&gt;

&lt;p&gt;datasortとかで作った新しい種は依存型や依存命題(?)、依存観(?)で使うためにある?&lt;/p&gt;

&lt;p&gt;分からないことが多いですね。もう少しATS2の世界の整理をつけたい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ATS2の依存型を使ってAVL木</title>
      <link>http://keens.github.io/blog/2015/12/29/ats2noizongatawotsukatteavlki</link>
      <pubDate>Tue, 29 Dec 2015 23:40:45 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/29/ats2noizongatawotsukatteavlki</guid>
      <description>

&lt;p&gt;κeenです。少しばかりATS2を触ってみたので成果報告でも。&lt;/p&gt;

&lt;p&gt;AVL木は左右のノードの高さが高々1しか違わない平衡二分木です。OCamlやSMLでナイーブに実装すると本当に1しか違わないことを保証するのは難しく、精々テストなどで部分的に検査するだけです。&lt;/p&gt;

&lt;p&gt;ところがSMLに似た文法を持つATS2には依存型があり、左右のノードの高さが高々1しか違わないことを型で保証出来ます。
つまり、左右のノードの高さが2以上違う木を作ろうとしてもコンパイルエラーになるのでコンパイルが通れば高さについてはバグがないこと保証されます。&lt;/p&gt;

&lt;p&gt;そういうAVL木を使ってTreeSetを作ってみたので紹介します。&lt;/p&gt;

&lt;p&gt;私のブログ(のこの記事)の読者ならATS2も依存型もAVL木も知ってそうですが一応説明します。&lt;/p&gt;

&lt;h1 id=&#34;ats2って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;ATS2って何?&lt;/h1&gt;

&lt;p&gt;詳しい説明は&lt;a href=&#34;http://jats-ug.metasepi.org/#document&#34;&gt;日本ATSユーザグループ&lt;/a&gt;に譲るとして、この記事にて重要な点を挙げます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SMLに似た文法を持つML方言&lt;/li&gt;
&lt;li&gt;型の部分に型以外の項（例えば整数とか）が使える&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E5%9E%8B&#34;&gt;依存型&lt;/a&gt;を持つ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他にももっと素晴しい型システムや機能、特徴があるのですがとりあえずのところは上記の特徴を押えておいて下さい。&lt;/p&gt;

&lt;h1 id=&#34;依存型って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;依存型って何?&lt;/h1&gt;

&lt;p&gt;先程も述べた通り、ざっくり言うと型の部分に型以外の項が使える型システムです。&lt;/p&gt;

&lt;p&gt;例えば、次のSMLのコードを考えてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;Array.get(arr: int array, index: int): int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型から読み取れるのは「&lt;code&gt;int&lt;/code&gt;の配列&lt;code&gt;arr&lt;/code&gt;と整数&lt;code&gt;index&lt;/code&gt;を受け取って&lt;code&gt;int&lt;/code&gt;の値を返す」関数です。
しかしこの関数は&lt;code&gt;index&lt;/code&gt;が&lt;code&gt;arr&lt;/code&gt;の長さよりも大きい時に実行時例外を上げます。内部でメモリを護るために境界チェックをして、チェックに落ちた時に例外を挙げている筈です。。
配列アクセスの度に実行時例外をハンドルするのはコード上もパフォーマンス上も避けたいですよね。
こういうものをコンパイル時に防ぎたくありませんか？無駄な境界チェックを省きたくありまんか？依存型を使えばそれが出来ます。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;array_get{n, i: nat| i &amp;lt; n}(arr: arrayref(int, n), index: int(i)): int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは「長さ&lt;code&gt;n&lt;/code&gt;の&lt;code&gt;int&lt;/code&gt;配列&lt;code&gt;arr&lt;/code&gt;と&lt;code&gt;n&lt;/code&gt;以下の自然数&lt;code&gt;index&lt;/code&gt;を受け取って&lt;code&gt;int&lt;/code&gt;の値を返す」関数です。
正しい入力しか受け取らないので実行時例外が起きませんし内部で境界チェックも必要ありません。面白くないですか？&lt;/p&gt;

&lt;p&gt;私も大して型システムに詳しくないのでこのくらいの例しか挙げることが出来ませんがきっとさらに面白い世界が広がっているのでしょう。&lt;/p&gt;

&lt;h1 id=&#34;avl木って何:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;AVL木って何？&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/AVL%E6%9C%A8&#34;&gt;Wikipedia&lt;/a&gt;を参照すると詳しいことが載っています。前の説明を繰り返すと、左右のノードの高さが高々1しか違わない平衡二分木です。自身の高さは左右の高さの高い方+1です。
データ構造は左右の木、ノードの保持する値の他にそのノードの高さを保持します。&lt;/p&gt;

&lt;p&gt;なので平衡度は赤黒木より高く、検索が高速な一方、要素数を変更する操作の度に平衡を取らないといけないので挿入や削除は赤黒木に負けるそうです。
OCamlのstdlibのMap/Setの実装に使われています。(OCamlは左右の高さが高々2違う木なので厳密にはAVL木ではないのですがアルゴリズムは同じです。)&lt;/p&gt;

&lt;p&gt;因みにAVLは人の名前の頭文字みたいです。&lt;/p&gt;

&lt;h1 id=&#34;作ってみよう:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;作ってみよう&lt;/h1&gt;

&lt;p&gt;今回、ATS2の依存型に関係ない機能、関数テンプレートなどは理解（読解）の妨げになると判断してそれらを使わないコード例を出します。
(関数テンプーレートを使わなくても多相型を使えば良さそうですが、ATS wayではなさそうです。)&lt;/p&gt;

&lt;p&gt;ということで、整数を格納するSetを作ってみましょう。&lt;/p&gt;

&lt;p&gt;実装に先立って、&lt;a href=&#34;https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml&#34;&gt;OCamlのSet&lt;/a&gt;や&lt;a href=&#34;https://tech.bezoomnyville.com/2015/12/07/A-GADT-implementation-of-AVL-tree.html&#34;&gt;GADTを使ったAVLの実装&lt;/a&gt;を読んでおくと比較が出来るかと思います。&lt;/p&gt;

&lt;p&gt;今回OCamlのSetを参考にして作ったので比較のためにコードを載せたいのですがOCamlは確かコードの再配布に厳しいライセンスだった気がするのでやめておきます。(スニペットくらいなら著作権は発生せず、ライセンス関係なしに使えるのですが念のため。)&lt;/p&gt;

&lt;h2 id=&#34;おまじない:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;おまじない&lt;/h2&gt;

&lt;p&gt;標準的な操作を取り込むため、以下をファイルの先頭に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;#include &amp;quot;share/atspre_staload.hats&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;データ型:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;データ型&lt;/h2&gt;

&lt;p&gt;高さnのAVL木を表わすデータ型を考えます。このデータ型は、&amp;rdquo;型パラメータとして&amp;rdquo;木の高さnを取ります。&lt;/p&gt;

&lt;p&gt;書き出しはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続けて、Emptyを書きます。Emptyは高さ0です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
    Empty(0)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いて、Nodeですが、左の木の高さと右の木の高さを表わす変数を導入します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat} Node of ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このクルクル括弧&lt;code&gt;{}&lt;/code&gt;で囲まれた部分は「任意の&lt;code&gt;nat&lt;/code&gt;なる&lt;code&gt;l&lt;/code&gt;,&lt;code&gt;m&lt;/code&gt;に対して」と読めば読み易いです。&lt;/p&gt;

&lt;p&gt;データ構造は、左右の木、値、高さを持つのでした。ここで、高さは&lt;code&gt;n&lt;/code&gt;であると型で制約されてます。ということでこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat} Node of (avlt(l), int, avlt(m), int(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の高さの部分で&lt;code&gt;int(n)&lt;/code&gt;となっているのは、&lt;code&gt;n&lt;/code&gt;は種&lt;code&gt;int&lt;/code&gt;であって型ではないので「整数&lt;code&gt;n&lt;/code&gt;の&lt;code&gt;int&lt;/code&gt;&amp;ldquo;型&amp;rdquo;」にする為に&lt;code&gt;int()&lt;/code&gt;を適用する必要があるのです。依存型だと「ただの整数値」だけでなく「整数3」などの型も作れるのです。&lt;/p&gt;

&lt;p&gt;さて、このままだと左右の木の高さが高々1しか違わないということを表わせていません。さらにいうと、自身の高さについての制約も書けていません。これらの制約はこう書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat | &amp;lt;制約&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回の制約はこうなりますね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;  | {l, m: nat |
    (l + 2 == n &amp;amp;&amp;amp; m + 1 == n) || // 右が左より1高い 又は
    (l + 1 == n &amp;amp;&amp;amp; m + 1 == n) || // 左右同じ高さ 又は
    (l + 1 == n &amp;amp;&amp;amp; m + 2 == n)    // 左が右より1高い
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果、データ型はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;datatype avlt(n: int) =
    Empty(0)
  | {l, m: nat |
    (l + 2 == n &amp;amp;&amp;amp; m + 1 == n) ||
    (l + 1 == n &amp;amp;&amp;amp; m + 1 == n) ||
    (l + 1 == n &amp;amp;&amp;amp; m + 2 == n)
} Node of (avlt(l), int, avlt(m), int(n))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中々複雑ですね。&lt;/p&gt;

&lt;h2 id=&#34;height:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;軽い関数から作っていきましょう。まずは木の高さを返す関数&lt;code&gt;height&lt;/code&gt;です。高さ&lt;code&gt;n&lt;/code&gt;の木を受け取って整数&lt;code&gt;n&lt;/code&gt;を返します。&lt;/p&gt;

&lt;p&gt;書き出しはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;code&gt;n&lt;/code&gt;を導入します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数は「高さ&lt;code&gt;n&lt;/code&gt;の木」ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n))...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値は「整数&lt;code&gt;n&lt;/code&gt;」です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n)): int(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数本体は普通です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun height{n: nat}(tree: avlt(n)): int(n) = 
  case+ tree of
  | Empty () =&amp;gt; 0
  | Node (_, _, _, n) =&amp;gt; n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで使っている&lt;code&gt;case+&lt;/code&gt;ですが、普通の&lt;code&gt;case&lt;/code&gt;より強くて網羅性検査に落ちるとコンパイルエラーになります。&lt;/p&gt;

&lt;h2 id=&#34;create:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;これから&lt;code&gt;insert&lt;/code&gt;を実装していく訳ですが、ユーティリティから少しづつ実装していきます。まずは高さが高々1しか違わない木2つと値を1つ受け取って新たな木を作る&lt;code&gt;create&lt;/code&gt;です。&lt;code&gt;Node&lt;/code&gt;を生で使うのに比べて高さの計算が必要なくなります。&lt;/p&gt;

&lt;p&gt;これは先に実装を与えて、後で型を考えましょう。先程の&lt;code&gt;height&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create??(l: ??, v: int, r: ??): ?? = let
  val hl = height l
  val hr = height r
in
  if hl &amp;gt;= hr
  then Node(l, v, r, hl + 1)
  else Node(l, v, r, hr + 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、型を考えていきます。まずは&lt;code&gt;l&lt;/code&gt;と&lt;code&gt;r&lt;/code&gt;はある高さを持つ木です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{l, m: nat} (l: avlt(l), v: int, r: avlt(m)): ?? = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、左右で高さが高々1しか違わないことを制約したいです。これは&lt;code&gt;Node&lt;/code&gt;の定義を参考にすると書けるでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{
  l, m: nat |
  l + 1 == m ||
  l == m + 1 ||
  l == m
  } (l: avlt(l), v: int, r: avlt(m)): ?? = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に返り値の型を考えます。返り値は「&lt;code&gt;l&lt;/code&gt;か&lt;code&gt;m&lt;/code&gt;どちらか大きい方+1の高さを持つ木」です。私は最初、それをこう表現していました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create...(...): [n: nat | n == m + 1 || n == l + 1] avlt(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[n: nat | n == m + 1 || n == l + 1] avlt(n)&lt;/code&gt;の部分を読み下すと、「&lt;code&gt;n = m + 1&lt;/code&gt;又は&lt;code&gt;n = l + 1&lt;/code&gt;を満たす&lt;code&gt;n&lt;/code&gt;に対して&lt;code&gt;avlt(n)&lt;/code&gt;」という型になります。これは、間違ってはいないのですが正確ではありませんでした。なぜならこの型に忠実に従うと&lt;code&gt;l = m + 1&lt;/code&gt;の時に&lt;code&gt;n = m + 1&lt;/code&gt;、すなわち&lt;code&gt;n = l&lt;/code&gt;もありえてしまいます。勿論そんなことはなく、&lt;code&gt;l = m + 1&lt;/code&gt;ならば&lt;code&gt;n = l + 1&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;よって正しい型は&lt;code&gt;[n: nat | (m &amp;gt; l &amp;amp;&amp;amp; n == m + 1) || (l &amp;gt;= m &amp;amp;&amp;amp; n == l + 1)] avlt(x, n)&lt;/code&gt;です。やたら長いですね。&lt;/p&gt;

&lt;p&gt;全体を載せると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun create{
  l, m: nat |
  l + 1 == m ||
  l == m + 1 ||
  l == m
  } (l: avlt(l), v: int, r: avlt(m)): [n: nat | (m &amp;gt; l &amp;amp;&amp;amp; n == m + 1) || (l &amp;gt;= m &amp;amp;&amp;amp; n == l + 1)] avlt(n) = let
  val hl = height l
  val hr = height r
in
  if hl &amp;gt;= hr
  then Node(l, v, r, hl + 1)
  else Node(l, v, r, hr + 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;rotate:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;rotate&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;OCamlのSetでは1まとめに&lt;code&gt;bal&lt;/code&gt;としていますが、条件分岐が多すぎて読みづらいので&lt;code&gt;right&lt;/code&gt;と&lt;code&gt;left&lt;/code&gt;に分離することにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rotate_xxx&lt;/code&gt;は、左右で高さがちょうど2違う木と値を受け取って、バランスのとれた木を作って返す関数です。
&lt;code&gt;rotate_right&lt;/code&gt;なら左の木が右の木より2高い木を受け取って上手い具合に木の付け替えをして新たな木を返します。&lt;/p&gt;

&lt;p&gt;返り値の木は左の木と同じ高さかあるいはそれより1高い木です。&lt;/p&gt;

&lt;p&gt;そろそろ慣れてきたと思うので型までを一気に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、さらに左側の木の左右の高さでも場合分けが必要になるのでまずは色々バラします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let
  val+ Node(ll, lv, lr, _) = l
  val hll = height ll
  val hlr = height lr
in
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、ここが一番面白い所です。&lt;code&gt;val+ Node(ll, lv, lr, _) = l&lt;/code&gt;に注目して下さい。 OCamlでは&lt;code&gt;match l with Empty -&amp;gt; invalid_arg &amp;quot;Set.bal&amp;quot; | Node (ll, lv, lr, _) -&amp;gt; ...&lt;/code&gt;となっていた部分です。
型制約から、&lt;code&gt;l&lt;/code&gt;は高さ2以上の木であることが分かっているので&lt;code&gt;Empty&lt;/code&gt;でないことが保証されます。なので &lt;strong&gt;&lt;code&gt;Node&lt;/code&gt;だけで網羅出来ているとコンパイラが理解してくれ&lt;/strong&gt; ます。マッチが1節しかないので&lt;code&gt;val&lt;/code&gt;のパターンマッチで代用出来ますね。
&lt;code&gt;val+&lt;/code&gt;は&lt;code&gt;case+&lt;/code&gt;と同じく網羅性検査に落ちるとコンパイルエラーになるバージョンの&lt;code&gt;val&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;残りの実装をまとめると、こうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_right{hl, hr: nat |
  hl == hr + 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hl || n == hl + 1] avlt(n) = let
  val+ Node(ll, lv, lr, _) = l
  val hll = height ll
  val hlr = height lr
in
  if  hll &amp;gt;= hlr
  then create(ll, lv, create(lr, v, r))
  else let
       val+ Node(lrl, lrv, lrr, _) =  lr
  in
    create(create(ll, lv, lrl), lrv, create(lrr, v, r))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rotate_left&lt;/code&gt;はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun rotate_left{hl, hr: nat |
  hl + 2 == hr
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat| n == hr || n == hr + 1] avlt(n) = let
  val+ Node(rl, rv, rr, _) = r
  val hrl = height rl
  val hrr = height rr
in
  if  hrr &amp;gt;= hrl
  then create(create(l, v, rl), rv, rr)
  else let
    val+ Node(rll, rlv, rlr, _) =  rl
  in
    create(create(l, v, rll), rlv, create(rlr, rv, rr))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bal:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;bal&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;rotate_right&lt;/code&gt;, &lt;code&gt;rotate_left&lt;/code&gt;, &lt;code&gt;create&lt;/code&gt;を1まとめにして左右の高さの差が高々2の2つの木と値を受け取ってバランスのとれた木を作って返す&lt;code&gt;bal&lt;/code&gt;を作りましょう。&lt;/p&gt;

&lt;p&gt;型がエグいことになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun bal{hl, hr: nat |
  ~2 &amp;lt;= hl - hr  &amp;amp;&amp;amp; hl - hr &amp;lt;= 2
}(l: avlt(hl), v: int, r: avlt(hr)): [n: nat|
 (hl == hr - 2 &amp;amp;&amp;amp; n == hr    ) ||
 (hl == hr - 2 &amp;amp;&amp;amp; n == hr + 1) ||
 (hl == hr - 1 &amp;amp;&amp;amp; n == hr + 1) ||
 (hl == hr     &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 1 &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 2 &amp;amp;&amp;amp; n == hl + 1) ||
 (hl == hr + 2 &amp;amp;&amp;amp; n == hl    )
] avlt(n) = let
  val hl = height l
  val hr = height r
in
  if hl = hr + 2
  then rotate_right(l, v, r)
  else if hl = hr - 2
  then rotate_left(l, v, r)
  else create(l, v, r)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cmp:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;さて、本来のOCamlのSetはファンクタで出来てますがATS2には原始的なファンクタしかないのでファンクタを使わずにこれまで実装してきました。
あまりよろしくありませんが&lt;code&gt;cmp&lt;/code&gt;もベタっと実装してしまいましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun cmp(x: int, y: int): int = x - y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;empty-singleton:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;singleton&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun empty(): avlt(0) = Empty()
fun singleton(x: int): avlt(1) = Node(Empty, x, Empty, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insert:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ここまで辿りついたらもう難しいところはありません。&lt;code&gt;insert&lt;/code&gt;した結果、木の高さが変わらないか1増えるだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun insert{m: nat}(x: int, tree: avlt(m)): [n: nat | n == m || n == m + 1]avlt(n) =
  case+ tree of
  | Empty () =&amp;gt; singleton(x)
  | t as Node(l, v, r, _) =&amp;gt; let
    val c = cmp(x, v)
  in
    if c = 0 then t
    else if c &amp;lt; 0
    then bal(insert(x, l), v, r)
    else bal(l, v, insert(x, r))
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mem:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;&lt;code&gt;mem&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;fun mem{m: nat}(x: int, tree: avlt(m)): bool =
  case+ tree of
  | Empty () =&amp;gt; false
  | Node(l, v, r, _) =&amp;gt; let
    val c = cmp(x, v)
  in
    if c = 0
    then true
    else if c &amp;lt; 0
    then mem(x, r)
    else mem(x, l)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;遊ぶ:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;遊ぶ&lt;/h1&gt;

&lt;p&gt;さて、少しばかり遊んでみましょう&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ats2&#34;&gt;
implement
main0 () =  {
  val tree = Empty
  val tree = insert(1, tree)
  val tree = insert(2, tree)
  val tree = insert(4, tree)
  val b = mem(2, tree)
  val c = mem(3, tree)
  val () = fprintln!(stdout_ref, b)
  val () = fprintln!(stdout_ref, c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これまでのファイルを&lt;code&gt;avlset_int.dat&lt;/code&gt;に保存して、以下のようにコンパイル/実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ patscc avlset.dats -DATS_MEMALLOC_LIBC
$ ./a.out
true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと動いているようです。(GCをリンクしてないのでメモリリークしてる気がしますが、GCのリンクの仕方が分からなかったのでこのままにします。)&lt;/p&gt;

&lt;p&gt;追記: GCのリンクの仕方を教えてもらいました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; GC付きコンパイルには -DATS_MEMALLOC_GCBDW -lgc を使うようです。僕も今知りました。。。 / master · githwxi/ATS-Postiats-contrib &lt;a href=&#34;https://t.co/4DPotHeUJ1&#34;&gt;https://t.co/4DPotHeUJ1&lt;/a&gt;&lt;/p&gt;&amp;mdash; Myu-Myu- ATS-tan! (@masterq_mogumog) &lt;a href=&#34;https://twitter.com/masterq_mogumog/status/682142334704717824&#34;&gt;2015, 12月 30&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;まとめ:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;依存型を持つATS2を使うことでAVL木の高さに関する要件を必ず満たす木を作ることが出来ました。
これは変な入力がないことを保証するばかりでなく、自らの実装がバグっていないことの確認にも使えます。
また、&lt;code&gt;val+&lt;/code&gt;の例で見た通り、パターンマッチについてもより厳格な検査が出来るので無意味なコードを書かなくて済みました。&lt;/p&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/avlset&#34;&gt;こちら&lt;/a&gt;に置いておきます。また、関数テンプレートを使ったよりジェネリックな実装もあります。&lt;/p&gt;

&lt;h1 id=&#34;ノート:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;ノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;今回型レベルで保証したのは高さに対する要件だけでした。
「ノードの左側の木にはそのノードの保持する値より小さい値しか入っていない」「一度&lt;code&gt;insert&lt;/code&gt;した値は&lt;code&gt;mem&lt;/code&gt;すると&lt;code&gt;true&lt;/code&gt;が返ってくる」などの要件については無保証のままです。
実はATS2には&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/c2849.html&#34;&gt;定理証明器&lt;/a&gt;も付いており、そのような振舞に関しても保証出来ます。&lt;/li&gt;
&lt;li&gt;ATS2には依存型の他にも&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/p3301.html&#34;&gt;線形型&lt;/a&gt;を持っていて、GCに頼らないメモリ管理が可能です。
今回のコードも線形型を使ってメモリリークしないように出来るでしょう。&lt;/li&gt;
&lt;li&gt;関数テンプレートを使ったAVL木の実装には若干危い点があります。関数テンプレートは実装をアドホックに変更出来るので
比較関数を差し替えれてしまいます。&lt;code&gt;cmp(x, y) = x - y&lt;/code&gt;で木を作った後に&lt;code&gt;cmp(x, y) = y - x&lt;/code&gt;にしてさらに要素を挿入したら大惨事になるでしょう。
そこまで気にするようなら&lt;a href=&#34;http://jats-ug.metasepi.org/doc/ATS2/INT2PROGINATS/x1974.html&#34;&gt;ファンクタ&lt;/a&gt;を使うべきです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;その他:a9fa379dc667a22ee7846d6b4d72d2e0&#34;&gt;その他&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CoqやAgdaのように依存型も定理証明器もある言語がありますが、それらと違ってATS2は「汎用プログラミング言語に表現力の高い依存型を付けて、ついでに定理証明器もついてる」くらいです。
本格的な証明には向かない一方汎用プログラミングにはATS2の方が向いているでしょう。&lt;/li&gt;
&lt;li&gt;しかしCoqと似ている面もあり、ATS2の世界で依存型や線形型、証明などで強い保証を付けた後は一旦Cのコードをエクストラクトして、それをコンパイルしています。&lt;/li&gt;
&lt;li&gt;Cにエクストラクトされるということで、ATS2はCとの相互連携が出来ます。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、ATS2には心躍る特徴がたくさんあります。依存型で実行時検査をコンパイル時検査に持ち上げ、定理証明器でバグも潰せて、
線形型でボックス/アンボックデータの扱いやGCに頼らないリソース管理やデータ競合の回避が出来、
並列プログラミングもサポート、低レベルなCのコードを呼べてバイナリサイズも小さいなどなど。&lt;/p&gt;

&lt;p&gt;しかし、これらの機能を得るのにATS2は1つだけ代償を払いました。学習コストです。
私はCも書きますしSMLも書きます。依存型のあるCoqや線形型より少し弱いアフィン型のあるRustも書いたことがあります。そんな私にもATS2は難解です。
最近難解な言語として名高くなってきたRustですら足元に及ばないでしょう。&lt;/p&gt;

&lt;p&gt;それでも、急峻な学習曲線の崖をよじ登った先には素晴しい世界が広がっているのです。1つ、修行だと思ってトライしてみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://fumieval.tumblr.com/post/28324791101/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%81%AE%E5%8C%BA%E5%88%86&#34;&gt;プログラマの区分&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SML#とCプリプロセッサの連携</title>
      <link>http://keens.github.io/blog/2015/12/26/sml_tocpuripurosessanorenkei</link>
      <pubDate>Sat, 26 Dec 2015 20:09:24 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/26/sml_tocpuripurosessanorenkei</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第3段はSML#とCプリプロセッサで連携する話。&lt;/p&gt;

&lt;p&gt;SML#のC FFIを使ってるとマクロで定義された値などを触りたくなるのですが、触れないのでどうにかしようかと。&lt;/p&gt;

&lt;p&gt;発想自体は単純で、SMLファイルの中でCのヘッダをインクルードしてCプリプロセッサを呼んであげればどうにかなります。&lt;/p&gt;

&lt;h1 id=&#34;簡単な例:17ab4ed508953994d38c55ce3a68a752&#34;&gt;簡単な例&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://keens.github.io/blog/2015/12/12/sml_dejitwotsukurukaruihanashi/&#34;&gt;JITを作る話&lt;/a&gt;の時のように、定数に触りたいとします。
その時、以下のように.smlファイルを記述して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* 
#include&amp;lt;sys/mman.h&amp;gt;
*)

(* ====END_OF_HEADER==== *)
datatype dummy = $ of int
              
val $PROT_READ  = $ PROT_READ
val $PROT_WRITE = $ PROT_WRITE
val $PROT_EXEC  = $ PROT_EXEC
val $PROT_NONE  = $ PROT_NONE

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E cpp_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; cpp.sml 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントを挙げると、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;smlファイルに&lt;code&gt;#include&lt;/code&gt;を書く。lintでエラーが出ないように&lt;code&gt;#include&lt;/code&gt;はコメントで囲む&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt;をコメントで囲ったところで安全でない( インクルードしたファイルに&amp;rsquo;&lt;code&gt;*)&lt;/code&gt;&amp;lsquo;、例えば &lt;code&gt;int f(char *);&lt;/code&gt;とかが入ってるとコメントが終端される)ので、&lt;code&gt;include&lt;/code&gt;の部分は後で削除する。
そのための識別子として、&lt;code&gt;====END_OF_HEADER====&lt;/code&gt;を置いておく(これも完全には安全ではないが比較的マシ)。&lt;/li&gt;
&lt;li&gt;Cのマクロと同じ識別子を使おうとすると識別子も置換されてしまうので左辺にダミーで&lt;code&gt;$&lt;/code&gt;をつけておく。スペースは空けない。
逆に右辺は置換されてほしいので&lt;code&gt;$&lt;/code&gt;の後にスペースを空ける。&lt;/li&gt;
&lt;li&gt;最後にCプリプロセッサを呼び、sedでヘッダ部分や無駄に追加されたCのコメントを除く。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ちょっと&lt;code&gt;$&lt;/code&gt;の部分がこの方式だとintにしか使えないのでイケてませんがないよりマシでしょう。因みに処理結果はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;datatype dummy = $ of int

val $PROT_READ = $ 
                   0x1

val $PROT_WRITE = $ 
                   0x2

val $PROT_EXEC = $ 
                   0x4

val $PROT_NONE = $ 
                   0x0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ifdef:17ab4ed508953994d38c55ce3a68a752&#34;&gt;&lt;code&gt;ifdef&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;一旦発想さえ得てしまえば話は簡単です。次は&lt;code&gt;ifdef&lt;/code&gt;を使う例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;(* ====END_OF_HEADER==== *)


(* 
#ifdef Debug
*)
val debug = true
(* 
#else
*)
val debug = false

(* 
#endif
*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cpp -pipe -E -DDebug ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;Debug&lt;/code&gt;を定義して処理すればifdef.smlの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*

*)
val debug = true
(*






*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となりますし、定義せずに&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
``` sh
cpp -pipe -E ifdef_pre.sml | sed &#39;1,/====END_OF_HEADER====/d;/^#/d&#39; &amp;gt; ifdef.sml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と処理すれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sml&#34;&gt;

(*





*)
val debug = false

(*

*)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってどちらでもSMLとして有効な文法になります。&lt;code&gt;ifndef&lt;/code&gt;だったり、&lt;code&gt;elif&lt;/code&gt;があったとしても有効な文法のままです。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:17ab4ed508953994d38c55ce3a68a752&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CプリプロセッサでSMLファイルを処理する方法を提示したよ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifdef&lt;/code&gt;も使えるよ&lt;/li&gt;
&lt;li&gt;関数マクロは使えないよ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SML#のオレオレREPLを作る話 初級</title>
      <link>http://keens.github.io/blog/2015/12/26/sml_nooreorereplwotsukuruhanashi_shokyuu</link>
      <pubDate>Sat, 26 Dec 2015 19:48:30 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/26/sml_nooreorereplwotsukuruhanashi_shokyuu</guid>
      <description>

&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第2段はSML#のオレオレREPLを作る話の初級。&lt;/p&gt;

&lt;p&gt;SML#にはFFIがあり、任意のオブジェクトファイル/ライブラリをリンクしてC関数を呼び出すことが出来ますが、REPLで試そうとしてもREPLにリンクされていないので呼び出せません。
そこで呼び出したいオブジェクトファイルをリンクしたREPLを作れば捗るよね、という発想です。&lt;/p&gt;

&lt;h1 id=&#34;事前に必要なもの:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;事前に必要なもの&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;SML#のビルド時に使ったLLVMのパス&lt;/li&gt;
&lt;li&gt;SML#をビルドした時のオブジェクトファイルの残骸（一部）&lt;/li&gt;
&lt;li&gt;SML#のソーコード（一部）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;コマンド:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;コマンド&lt;/h1&gt;

&lt;p&gt;まず、普通のREPLを作るだけならこれだけです。（コンパイラも一緒にくっついてきますが面倒なのでそのままにしてます。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o oreore_repl &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot;  &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは最後のリンクコマンドにフラグを足せばいいでしょう。注意点として、64bit OSを使ってるならちゃんと32bitでビルドしたライブラリをリンクしましょう。例えばlibuvをリンクするならこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;SMLSHARP_SRC=/path/to/smlsharp
LLVM_HOME=/path/to/LLVM
cp ${SMLSHARP_SRC}/src/compiler/smlsharp.sml ./
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; smlsharp.smi
_require &amp;quot;prelude.smi&amp;quot;

_require &amp;quot;compiler/main/main/SimpleMain.smi&amp;quot;
EOF
smlsharp -c++ -o smlsharp_uv &amp;quot;${SMLSHARP_SRC}/src/compiler/smlsharp.smi&amp;quot; -L /opt/libuv32/lib -luv &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/llvm_support.o &amp;quot;${SMLSHARP_SRC}&amp;quot;/src/llvm/main/SMLSharpGC.o $(&amp;quot;${LLVM_HOME}/bin/llvm-config&amp;quot; --ldflags --libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;終わりに:25a90a3d9e2261c06baa6c7ce3911ca0&#34;&gt;終わりに&lt;/h1&gt;

&lt;p&gt;やり方さえ分かってしまえば簡単ですが見付けるのが難しい小ネタでした。因みに今回初級ですが、REPLにlibeditを統合するなどの上級ネタはいつか気が向いたら書くかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustのロガーを作る</title>
      <link>http://keens.github.io/blog/2015/12/26/rustnoroga_wotsukuru</link>
      <pubDate>Sat, 26 Dec 2015 19:18:31 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/26/rustnoroga_wotsukuru</guid>
      <description>&lt;p&gt;κeenです。Advent Calendarのためにネタやアイディアを用意したものの時間/場所的都合でAdvent Calendarとして出せなかったボツネタでも供養しようかと。
Advent Calendarが終わってしまったので投げやり気味ですね。
第1段はRustのロガーを作る話。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar&lt;/a&gt;の&lt;a href=&#34;http://keens.github.io/blog/2015/11/14/rustdechiisanatsu_ruwotsukuttemiru/&#34;&gt;初日&lt;/a&gt;でロガーはfacadと実装に分かれてると書きましたが、実装を作る話ですね。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/log/log/index.html&#34;&gt;ドキュメント&lt;/a&gt;を見てもらえば分かる通り、logは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Log: Sync + Send {
    fn enabled(&amp;amp;self, metadata: &amp;amp;LogMetadata) -&amp;gt; bool;
    fn log(&amp;amp;self, record: &amp;amp;LogRecord);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とだけインターフェースが定まっているのでそこを実装してあげれば終わりです。
なぜまたloggerを作ろうとしたのかというと、Rust公式の&lt;a href=&#34;https://crates.io/crates/env_logger/&#34;&gt;env_logger&lt;/a&gt;は標準出力にしか出せず、crates.ioを捜しても（作ろうと思った時点ではパっと見）ファイルに書き出せるものがなさそうだったからです。&lt;/p&gt;

&lt;p&gt;私が作ったのは&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logger&lt;/a&gt;といいます。まだcrates.ioには出してません。TOMLでコンフィグを書けるようになったら出そうかと思うのですがもう既にファイルに書きだせるものが他にありますかね。&lt;/p&gt;

&lt;p&gt;今回作るにあたって目指したのは1つのことにだけ集中する他と組み合わせられるライブラリです。
logはロガーをグローバル変数に代入して使い回してるので同時に1つしかロガーを登録出来ません。そこでロガーアグリケーターのようなものを作ってそれに複数のロガーを登録することが考えられます。
調べきれてませんが恐らく既にいくつか存在するでしょう。アグリゲータの存在を仮定してしまえばアグリゲータに任せれる部分は任せてしまうのが良いでしょう。&lt;/p&gt;

&lt;p&gt;ということで次のことを最初に決めました&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ログフォーマットは柔軟性を持たせる&lt;/li&gt;
&lt;li&gt;ログメッセージの内容に応じて出力を制御出来るフィルターを入れる。(アグリゲータが無差別にログを流し込んで来た時のため)&lt;/li&gt;
&lt;li&gt;複数ファイルへのログはサポートしない。アグリゲータに任せる&lt;/li&gt;
&lt;li&gt;プラグインはサポートしない。アグリゲータに任せる&lt;/li&gt;
&lt;li&gt;ログローテーションはしない。&lt;code&gt;Write&lt;/code&gt;の実装に任せる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一応file loggerですがWriteをすべからく受け取れるので実際はストリームにも使えたりします。今書き出してみたらフォーマッタとかフィルタとかもアグリゲータに任せた方がいいのかなって気がしてきた。
しかし単体での利便性を考えると仕方ない。&lt;/p&gt;

&lt;p&gt;実装は大したことをやっていなくて、精々ログフォーマットを文字列で書けるように（TOMLで設定を書きたいため）フォーマットのパーサを書いた程度でしょうか。&lt;/p&gt;

&lt;p&gt;もう少し考えてからリリースします。あとFile Lotating Writerも一緒に出さなきゃ片手落ちですかね…&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Drillの不自然な挙動</title>
      <link>http://keens.github.io/blog/2015/12/20/apache_drillnofushizennakyodou</link>
      <pubDate>Sun, 20 Dec 2015 23:04:37 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/20/apache_drillnofushizennakyodou</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/drill&#34;&gt;Apache Drill Advent Calendar 2015&lt;/a&gt;21日目のエントリです&lt;/p&gt;

&lt;p&gt;最初は備忘録がてら普段使うMySQL、BigQuery、SQLite、Apache DrillのSQLシンタックスの違いでも書こうかと思ったのですが調査が思ったより大変だったのでやめました。ANSI SQLも色々変わってるということは理解出来ました。&lt;/p&gt;

&lt;p&gt;ということでApache Drillを使ってて「ん？」と思った挙動をいくつか出してみようかと。1.4時点での情報です。&lt;/p&gt;

&lt;h1 id=&#34;select-1:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;&lt;code&gt;SELECT 1&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;シェルで手持ち無沙汰に&lt;code&gt;ls&lt;/code&gt;や&lt;code&gt;pwd&lt;/code&gt;を打つようにSQLプロンプトで&lt;code&gt;SELECT 1;&lt;/code&gt;を打つ訳ですが、Apache Drillはこれを受け付けてくれません。&lt;/p&gt;

&lt;p&gt;まあ、これは不自然というかそういう仕様なのですが正しくは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT 1 FROM (VALUES(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;です。手持ち無沙汰に打つには少し面倒ですね。そうでなくても日付関数の挙動を確かめたい時にも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT NOW();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとやりたい訳ですがそれにも&lt;code&gt;FROM (VALUES(1));&lt;/code&gt;とダミーの&lt;code&gt;FROM&lt;/code&gt;句を付けてあげる必要があります。面倒ですね。&lt;/p&gt;

&lt;h1 id=&#34;union-と-union-all:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;&lt;code&gt;UNION&lt;/code&gt;と&lt;code&gt;UNION ALL&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;UNION&lt;/code&gt;はテーブル同士のレコード間で重複を取り除いた集合を、&lt;code&gt;UNION ALL&lt;/code&gt;は重複を取り除かない集合を返します。Apache Drillでも試してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM (VALUES (1, 2, 3) UNION VALUES(4, 5, 6) UNION VALUES(7, 8, 9) UNION VALUES(1, 2, 3));
SELECT * FROM (VALUES (1, 2, 3) UNION ALL VALUES(4, 5, 6) UNION ALL VALUES(7, 8, 9) UNION ALL VALUES(1, 2, 3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのクエリはどういう結果になるでしょうか。答えはこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT * FROM (VALUES (1, 2, 3) UNION VALUES(4, 5, 6) UNION VALUES(7, 8, 9) UNION VALUES(1, 2, 3));
+---------+---------+---------+
| EXPR$0  | EXPR$1  | EXPR$2  |
+---------+---------+---------+
| 1       | 2       | 3       |
+---------+---------+---------+
1 row selected (0.416 seconds)
0: jdbc:drill:zk=local&amp;gt; SELECT * FROM (VALUES (1, 2, 3) UNION ALL VALUES(4, 5, 6) UNION ALL VALUES(7, 8, 9) UNION ALL VALUES(1, 2, 3));
+---------+---------+---------+
| EXPR$0  | EXPR$1  | EXPR$2  |
+---------+---------+---------+
| 7       | 8       | 9       |
| 7       | 8       | 9       |
| 7       | 8       | 9       |
| 7       | 8       | 9       |
+---------+---------+---------+
4 rows selected (0.115 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うーん。これはバグだと思うんですよね。定数テーブルをキャッシュするようにしてたら全てのレコードで同じ値を参照しちゃって値を書き換えてしまったとか。
&lt;code&gt;UNION&lt;/code&gt;が&lt;code&gt;UNION ALL&lt;/code&gt;の結果から&lt;code&gt;DISTINCT&lt;/code&gt;相当の処理をするなら2番目の結果を見れば最初の結果が従うのもうなずけますし。&lt;/p&gt;

&lt;h1 id=&#34;ヘッダ付きcsv:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;ヘッダ付きCSV&lt;/h1&gt;

&lt;p&gt;Drill 1.4からヘッダ付きCSVの扱いが楽になりましたね。拡張子が&lt;code&gt;csv&lt;/code&gt;のままヘッダ付きCSVにクエリを投げられます。ちょっと試しましょう。&lt;/p&gt;

&lt;p&gt;次のようなCSVファイルを用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/Csv/test.csv
foo,bar,baz
1,1.0,&amp;quot;a&amp;quot;
2,2.0,&amp;quot;b&amp;quot;
3,3.0,&amp;quot;c&amp;quot;
4,4.0,&amp;quot;d&amp;quot;
5,5.0,&amp;quot;e&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリを投げてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT * FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+------+------+
| foo  | bar  | baz  |
+------+------+------+
| 1    | 1.0  | a    |
| 2    | 2.0  | b    |
| 3    | 3.0  | c    |
| 4    | 4.0  | d    |
| 5    | 5.0  | e    |
+------+------+------+
5 rows selected (0.12 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。じゃあ今度は&lt;code&gt;baz&lt;/code&gt;カラムだけ取り出してみましょう。ここで、会社のMacだと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT baz FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+------+------+
| foo  | bar  | baz  |
+------+------+------+
| 1    | 1.0  | a    |
| 2    | 2.0  | b    |
| 3    | 3.0  | c    |
| 4    | 4.0  | d    |
| 5    | 5.0  | e    |
+------+------+------+
5 rows selected (0.12 seconds)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにカラムを指定しているのにも関らず全てのデータが返ってきていました。その旨を書こうと思ったのですが手元のLinuxマシンだと正しい結果が返ってくるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=local&amp;gt; SELECT `bar` FROM TABLE(dfs.`/home/kim/Csv/test.csv`(type =&amp;gt; &#39;text&#39;, fieldDelimiter =&amp;gt; &#39;,&#39;, extractHeader =&amp;gt; true));
+------+
| bar  |
+------+
| 1.0  |
| 2.0  |
| 3.0  |
| 4.0  |
| 5.0  |
+------+
5 rows selected (0.088 seconds)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっと会社で見たのが幻覚だったかもしれないので要調査ですね。&lt;/p&gt;

&lt;h1 id=&#34;mysqlへの接続:9fcdb67be54783fd9fe212856b3ef1e7&#34;&gt;MySQLへの接続&lt;/h1&gt;

&lt;p&gt;以下のようなSQLを投げた所、ひどく時間が掛かりました。投げた対象はプロダクションのデータが入ってる分析用のDBで、結構な量のデータが入ってます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM mysql.mydb.`test` LIMIT 20;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache Drill自体レスポンスが悪いのでクエリによってはそんなものかな、と思って最初はそのままにしたのですがふと気になって&lt;code&gt;EXPLAIN&lt;/code&gt;してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: jdbc:drill:zk=localhost:2181&amp;gt; EXPLAIN PLAN FOR SELECT * FROM mysql.mydb.`test` LIMIT 20;
+------+------+
| text | json |
+------+------+
| 00-00    Screen
00-01      Project(columns....)
00-02        SelectionVectorRemover
00-03          Limit(fetch=[20])
00-04            Limit(fetch=[20])
00-05              Jdbc(sql=[SELECT * FROM `mydb`.`test`])
| {
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Jdbc(sql=[SELECT * FROM mydb.test])&lt;/code&gt; とあるのでなんとMySQLに&lt;code&gt;LIMIT&lt;/code&gt;をつけずにクエリを投げてます。そしてさらに何故か&lt;code&gt;Limit(fetch=[20])&lt;/code&gt;を2回やっています。&lt;/p&gt;

&lt;p&gt;まあ、内部でLimitを2回やってるのは良いとしてもMySQLにLimit無しで投げるのはいただけないですね。
分散モデルのDrillからしたら「分散してる俺らの方が処理が速いから全部俺らでやってやるよ」という気概なのかもしれませんがこちらとしてはDBへの負荷も考えて欲しいものです。
まあ、かといって&lt;code&gt;WHERE&lt;/code&gt;句にインデックスが付く/付かないだとかその他の句によってMySQLのへの負荷も変わるのでなんとも言えないといえばそうなんですが簡単な場合にpush downしてくれるか
あるいは手動でpush down出来る仕組みが欲しいですね。&lt;code&gt;FORCE INDEX&lt;/code&gt;みたいに。&lt;/p&gt;

&lt;p&gt;さて、色々気になる点はありましたがApache Drillは面白いプロダクトです。
主にビッグデータ分析に使われるようですが私は大きなテーブルからアドホックに抽出したCSVとMySQLにあるマスターデータをJOINするなどの目的で使っていきたいなと思っています。&lt;/p&gt;

&lt;p&gt;皆様良いデータ分析ライフを！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最近作ってるLispの話</title>
      <link>http://keens.github.io/blog/2015/12/20/saikintsukutterulispnohanashi</link>
      <pubDate>Sun, 20 Dec 2015 22:40:16 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/20/saikintsukutterulispnohanashi</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/lisp&#34;&gt;Lisp Advent Calendar 2015&lt;/a&gt;21日目の記事です。&lt;/p&gt;

&lt;p&gt;κeenです。最近あまりLispを書いてなくてネタがないので最近作ってるLispの話でもしようかと。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/kappaLisp&#34;&gt;κLisp&lt;/a&gt;といいます。まだまだ完成には程遠いです。現在、&lt;a href=&#34;https://github.com/KeenS/kappaLisp/blob/master/src/eval.rs#L378&#34;&gt;ここら辺&lt;/a&gt;くらいの式なら評価出来ます。&lt;/p&gt;

&lt;p&gt;このLispはSKK辞書に使われているS式を評価するために作られました。
SKKは様々な場所に移植されているのでマルチプラットフォームで動いて他の言語と協調が出来る言語で作るのが望ましいのですが、今回はRustを選びました。
最初はCにしようかと思ったのですがちょいとRustを試してみようかと(当時Rustほとんど書いたことがない初心者)。&lt;/p&gt;

&lt;p&gt;SKKに書かれているS式を処理出来るLisp処理系はあるのですがGPLでライセンスされており、それを使ったiOSアプリをAppStoreに登録出来ないという問題があるそうです。
なのでMITライセンスで作り始めました。&lt;/p&gt;

&lt;p&gt;さて、Lisp処理系くらい簡単に作れそうなものですが、いくつかの点で詰まっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;そもそもRustが難しい&lt;/li&gt;
&lt;li&gt;関数ポインタが思うように扱えない&lt;/li&gt;
&lt;li&gt;やろうとした事がborrow checkに引っ掛かって出来なかった&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この詰まった点はRustが悪い訳ではなくて単に私がRustに合わせた設計が出来なかっただけですね。そろそろRustにも少しづつですが慣れて来たのでどこかのタイミングでリファクタリングして進めていきたいですね。&lt;/p&gt;

&lt;p&gt;一応現状でも進めようと思えば進めれるのですが&lt;a href=&#34;https://github.com/KeenS/kappaLisp/blob/master/src/eval.rs#L232&#34;&gt;ここ&lt;/a&gt;のように明らかにイケてないコードが続くので進めるモチベーション起きませんよね。&lt;/p&gt;

&lt;p&gt;設計とかの話をすると、最終的にはC APIでS式の文字列を受け取ったらそれを評価した結果の文字列を返す関数を晒せばいいかな、と思ってます。
ちゃんとiOSへのクロスコンパイルも出来ますしObj-C, Swift双方C FFIがあるのでそれで十分でしょう。(CF &lt;a href=&#34;http://qiita.com/moriturus/items/1190614dcbbe31ecfc2f&#34;&gt;http://qiita.com/moriturus/items/1190614dcbbe31ecfc2f&lt;/a&gt; , &lt;a href=&#34;http://safx-dev.blogspot.jp/2014/06/rustios.html&#34;&gt;http://safx-dev.blogspot.jp/2014/06/rustios.html&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;パーサは手書きで、実行はインタプリタ、Emacs Lispに則ってLisp2のダイナミックスコープです。設計がクソなのでメモリ管理らしいメモリ管理はやってませんがRustのメモリ管理のお陰でメモリリークはしてません。
ちゃんと設計してReference Countなメモリ管理でもしようかと。フットプリントの軽さ大事。&lt;/p&gt;

&lt;p&gt;全然まとまりませんがいつか使えるようになってAquaSKKやFlickSKKに取り込まれるかもしれないのでその時には裏でこのLispが動いてるかもと思い出してあげて下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>travisとappveyorでクロスプラットフォームなCIする話</title>
      <link>http://keens.github.io/blog/2015/12/20/travistoappveyerdekurosupurattofo_munacisuruhanashi</link>
      <pubDate>Sun, 20 Dec 2015 22:19:21 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/20/travistoappveyerdekurosupurattofo_munacisuruhanashi</guid>
      <description>&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar 2015&lt;/a&gt;20日目の記事です。
日付を覚え間違っていて、締切ギリギリに書いてます。&lt;/p&gt;

&lt;p&gt;κeenです。ものすごい小ネタですがRustでCIする話でも。&lt;/p&gt;

&lt;p&gt;Rustはクロスプラットフォームな言語なのでLinux, Macそしてあまり聞き慣れませんがWindowsというOSでも動きます。
とは言っても普段の開発環境がLinux、運悪くMacを使わざるを得ない人はMacで開発をしているとそれらでの動作検証は出来るでしょうが他のOSでの動作検証が難しいでしょう。&lt;/p&gt;

&lt;p&gt;そこでCIしましょう。Travis CIはLinuxと、あまり使われていませんがMacでのCI環境を、AppveyorでWindowsというOSでのCI環境を作ります。&lt;/p&gt;

&lt;p&gt;しかしクロスプラットフォームでしかもテスト方法がCargoで統一されているRustではそこまで難しいこともなく、以下の設定をコピペするだけです。&lt;/p&gt;

&lt;p&gt;travis&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: rust
rust:
  - nightly
  - beta
  - stable
os:
  - linux
  - osx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;appveyor&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;branches:
  except:
    - gh-pages

platform:
  - x64
environment:
  RUST_INSTALL_DIR: C:\Rust
  matrix:
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: 1.4.0
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: beta
    - RUST_INSTALL_TRIPLE: i686-pc-windows-msvc
      RUST_VERSION: nightly
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: 1.4.0
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: beta
    - RUST_INSTALL_TRIPLE: x86_64-pc-windows-msvc
      RUST_VERSION: nightly

install:
  - ps: Start-FileDownload &amp;quot;https://static.rust-lang.org/dist/rust-${env:RUST_VERSION}-${env:RUST_INSTALL_TRIPLE}.exe&amp;quot;
  - cmd: rust-%RUST_VERSION%-%RUST_INSTALL_TRIPLE%.exe /VERYSILENT /NORESTART /DIR=&amp;quot;%RUST_INSTALL_DIR%&amp;quot;
  - cmd: SET PATH=%PATH%;%RUST_INSTALL_DIR%\bin
  - rustc --version
  - cargo --version

build: false
test_script:
  - cargo build --verbose
  - cargo test --verbose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バッジとかは適当に持ってきましょう。&lt;/p&gt;

&lt;p&gt;サンプルが欲しければ&lt;a href=&#34;https://github.com/Stebalien/tempfile&#34;&gt;Stebalien/tempfile&lt;/a&gt;あたりを参考にしましょう。&lt;/p&gt;

&lt;p&gt;それではHave Happy Hacκings!&lt;/p&gt;

&lt;p&gt;※OS関連の煽りはただのネタです。また「あまり使われていませんがMacでのCI環境を」は「(travisの中では)あまり使われていません(のでもしかしたら使えることを知らない人がいるかもしれません)が」という意味です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでReactive Messaging Pattern</title>
      <link>http://keens.github.io/blog/2015/12/19/clojuredereactive_messaging_pattern</link>
      <pubDate>Sat, 19 Dec 2015 22:30:19 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/19/clojuredereactive_messaging_pattern</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/clojure&#34;&gt;Clojure Advent Calendar 2015&lt;/a&gt;の16日目の記事です（大遅刻）&lt;/p&gt;

&lt;p&gt;κeenです。ここのところ体調優れず、また、特に面白いネタもなくClojure Advent Calendarに遅刻したことをお詫び申し上げます。&lt;/p&gt;

&lt;p&gt;さて、今日はReactive Messaging PatternをClojureのcore.asyncでやってみたいと思います。Reactive Messaging Pattersは、Java/Scala向けActorシステムの&lt;a href=&#34;http://akka.io/&#34;&gt;Akka&lt;/a&gt;の作者が著した本、&lt;a href=&#34;http://www.amazon.co.jp/Reactive-Messaging-Patterns-Actor-Model-ebook/dp/B011S8YC5G&#34;&gt;Amazon.co.jp: Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&lt;/a&gt;で書かれているデザインパターンです。&lt;/p&gt;

&lt;p&gt;非常に興味深い本なのですがScala及びAkka初心者の私には中々辛いので一旦Clojureで試してみようかと。&lt;/p&gt;

&lt;p&gt;ところで、AkkaとClojureのcore.asynkには若干のモデルの違いがあります。詳しくは&lt;a href=&#34;http://blog.paralleluniverse.co/2015/05/21/quasar-vs-akka/&#34;&gt;ここ&lt;/a&gt;とかにあるのですが、一番大きくは非同期/同期モデルの違いがあります。
Akkaの場合はActorにメッセージを送っても届いたという保障はなく(「その瞬間に」届いてないだけでなく、届く前にActorが再起動したらメッセージがロストしてしまう!)、また、メッセージの受信も&lt;code&gt;receive&lt;/code&gt;というコールバック用のメソッドを用意してそこでハンドルすることになります。&lt;/p&gt;

&lt;p&gt;そういう違いがある中でどれだけClojureに翻訳出来るか多少不安ですがチャレンジしてみます。尚、原書には様々なパターンがあるのですが流石に本一冊分全部は紹介し切れないので面白そうでかつClojureでも役立ちそうなものだけ紹介することにします。このコードは原書のものをClojureに翻訳したものではなく、私が勝手に書いたものです。コードを参考にするのは雰囲気程度に留めて、実際を知りたかったら原書を読みましょう。&lt;/p&gt;

&lt;p&gt;今回、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject reactive-message-patterns &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.7.0&amp;quot;]
                 [org.clojure/core.async &amp;quot;0.2.374&amp;quot;]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というプロジェクト設定で試しました。また、ソースコードは&lt;a href=&#34;https://github.com/KeenS/reactive-message-patterns&#34;&gt;こちら&lt;/a&gt;で公開しています。&lt;/p&gt;

&lt;h1 id=&#34;messaging-with-actors:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Messaging With Actors&lt;/h1&gt;

&lt;h2 id=&#34;pipes-and-filters:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Pipes And Filters&lt;/h2&gt;

&lt;p&gt;メッセージが来る際に、そのまま受け取るのではなく一旦Filter用のActorで変換やvalidationをかけて本処理に入ります。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;Clojureなら&lt;code&gt;filter&amp;lt;&lt;/code&gt;/&lt;code&gt;filter&amp;gt;&lt;/code&gt;/ transducerで瞬殺&lt;/del&gt; Filter処理をActorに分離することで並列性やモジュール性が上がります。原書の例ではまずDecrypt Filterを噛ませてAuthenticate Filterで認証出来たら De-dup Filterで重複を取り除いてメッセージをクリーンにしてから処理を始める、とういうように非常に実用的な例が出ています。&lt;/p&gt;

&lt;p&gt;また、(transformでなく、篩い分けの)Filterを分離することでFilterした後の処理、例えばinvalidなメッセージが来たらログに出すなどの柔軟性を得ることが出来ます。&lt;/p&gt;

&lt;p&gt;これを実装してみましょう。すごい適当ですがメッセージが来たらそれを2倍するfilterを作ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(use &#39;clojure.core.async)

(defn filter-actor
  ([f]
   (let [in (chan)
         out (chan)]
     (do
       (filter-actor f in out)
       [in out])))
  ([f in out]
   (go-loop []
     (if-let [v (&amp;lt;! in)]
       (if-let [ret (f v)]
         (if (&amp;gt;! out ret)
           (recur)))
       (close! out)))))

(let [[in out] (filter-actor (fn [x] (* x 2)))]
  (go
    ;; producer
    (doseq [v (range 1 10)]
      (&amp;gt;! in v))
    (close! in))
  (go-loop []
    ;; consumer
    (if-let [v (&amp;lt;! out)]
      (do
        (println v)
        (recur))
      (close! out))))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単ですね。チャネルが終わったかどうか調べるのに一々&lt;code&gt;if-let&lt;/code&gt;を使うのが面倒ですがリストに対する再帰関数もそんな感じなのでまあ、こういうもんなんでしょう。&lt;/p&gt;

&lt;h2 id=&#34;その他:258416a532a86ac327ddeb3b653d90b7&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;他にもMessaging With ActorsにはMessage Router, Message Translator, Message Endpointsなどのパターンが載っているのですが割愛します。特にMessage Translatorは外部システム(HTTPリクエスト、MQ, SQLなど)とのやりとりの話なので簡単に試すには少し重すぎるようです。&lt;/p&gt;

&lt;h1 id=&#34;messaging-channels:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Messaging Channels&lt;/h1&gt;

&lt;p&gt;この章にはActor同士のメッセージのやりとりの方法が色々書かれています。
Point-to-Point Channel, Publish-Subscribe Channel, Datatype Channel, Invalid Message Channel, Dead Letter Channel, Guaranteed Delivery, Channel Adapter, Message Bridge, Message Bus。
中々多くのパターンが載っているのですが一部はAkka固有であったりClojureには必要なかったりしますので、私が興味を持ったものを紹介します。&lt;/p&gt;

&lt;h2 id=&#34;publish-subscribe:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Publish-Subscribe&lt;/h2&gt;

&lt;p&gt;定番ですね。概念自体の説明は不要と思います。core.asyncだとどうなるのかを見てみます。&lt;code&gt;pub&lt;/code&gt;と&lt;code&gt;sub&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [publisher (chan)
      publication (pub publisher :topic)
      subscriber1 (chan)
      subscriber2 (chan)]
  (sub publication :delete subscriber1)
  (sub publication :create subscriber1)

  (sub publication :update subscriber2)
  (sub publication :read subscriber2)

  ;; start subscribers before publish start
  (go-loop [] (when-let [v (&amp;lt;! subscriber1)] (printf &amp;quot;I&#39;m One, got %s\n&amp;quot; (:type v)) (recur)))
  (go-loop [] (when-let [v (&amp;lt;! subscriber2)] (printf &amp;quot;I&#39;m Two, got %s\n&amp;quot; (:type v)) (recur)))

  (go (onto-chan publisher [{:topic :update, :type &amp;quot;dog&amp;quot;}
                            {:topic :create, :type &amp;quot;cat&amp;quot;}
                            {:topic :read  , :type &amp;quot;fox&amp;quot;}]))
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おもちゃのような例ですがこれで動くようです。因みに原書ではここに結構なページ数が割かれていて、分散システムを念頭に、異なるシステムにメッセージを送る話なども扱っています。core.asyncだとそこまでは出来そうにないですね。&lt;/p&gt;

&lt;h2 id=&#34;invalid-message-channel:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Invalid Message Channel&lt;/h2&gt;

&lt;p&gt;とあるActorに予期しないメッセージが届いたらどうしましょうか。そのまま捨てますか？もしかしたらバグを潰せる好機かもしれないのにそのまま捨てるには勿体なすぎます。
かといって全てのActorにデバッグ用のコードを入れていては埒が明かないどころかコードが複雑化してしまいます。そこでInvalid Massage Channelを使いましょう。&lt;/p&gt;

&lt;p&gt;あるActorに予期しないメッセージが届いた時に、全てを放り投げるチャネルを用意しておいて、その先のActorでログを出すなりするのです。&lt;/p&gt;

&lt;p&gt;今回は&lt;code&gt;:price&lt;/code&gt;タグのついていないメッセージが届いた時にinvalid actorに放り投げ、ログを出すものを作りました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn invalid [data]
  {:data data
   :from (Thread/currentThread)})

(let [invalid-chan (chan)
      in (chan)
      tax 0.08]
  ;; invalid message processor
  (go-loop []
    (when-let [{data :data from :from} (&amp;lt;! invalid-chan)]
      (printf &amp;quot;invalid data %s from %s from\n&amp;quot; data from)
      (recur)))

  ;; main processing actor
  (go-loop []
    (when-let [v (&amp;lt;! in)]
      (if-let [price (:price v)]
        (printf &amp;quot;price: %f\n&amp;quot; (* price (+ 1 tax)))
        (&amp;gt;! invalid-chan (invalid v)))
      (recur)))

  (go (onto-chan in [{:goods &amp;quot;はじめてのClojure&amp;quot;
                      :price 1900}
                     {:goods &amp;quot;プログラミングClojure&amp;quot;
                      :price 3400}
                     {:goods &amp;quot;へび&amp;quot;
                      :description &amp;quot;にょろにょろ&amp;quot;}])))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;from&lt;/code&gt;についてはActorならアクターオブジェクトに対してリフレクションかけて何かしらの情報をとれるのですが&lt;code&gt;go&lt;/code&gt;に対するリフレクションが分からなかったので代わりにスレッド情報を使いました。
私はこの章を読んだ時にいたく完動しました。ログの扱いを集約出来るし地味にIOして非同期モデルのアクターの邪魔になるログをそれぞれのアクターに持たなくて済む。
しかしこれのActorが落ちたら、とかこのActor自身にinvalidなメッセージが来たら、とか色々考えたくなります。詳しくは原書を読みましょう。&lt;/p&gt;

&lt;h2 id=&#34;その他-1:258416a532a86ac327ddeb3b653d90b7&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;この章には他にも外部システムと連携するMessage Adapter、外部のメッセージングシステムと連携するMessage Bridge、複数のシステム間でメッセージをやりとりするMessage Busなどが載っていますが割愛します。&lt;/p&gt;

&lt;h1 id=&#34;message-construction:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Message Construction&lt;/h1&gt;

&lt;p&gt;この章にはCommand Message, Document Message, Event Message, Request-Reply, Return Address, Correlation Identifire, Message Sequence, Message Expiration, Format Indicatorなどのメッセージ自体にまつわる話題が載っています。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;疲れてきたため&lt;/del&gt; AkkaやScala特有の話題が多いので1つだけに絞ります。。まあ、だいたいErlangとかやってたら自然と覚えるやつらです。&lt;/p&gt;

&lt;h2 id=&#34;document-message:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Document Message&lt;/h2&gt;

&lt;p&gt;Command MessageやEvent Messageは良く見ますが、Document Messageとはどのようなものでしょうか。原書にはこう書いてあります&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Use a Document Message to convey information to a receiver, but without indicating how the data should be used.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「受取側に情報を伝えはするが、その情報がどのように扱われるべきかを指示しない時にDocument Messageを使います」Command Messageに付随する情報でもなくEvent Messageに付随する情報でもなくただ単なる情報です。&lt;/p&gt;

&lt;p&gt;これは例えばデータベースアダプタのような所で使うことになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [db [{:id 1 :name &amp;quot;Aho&amp;quot;} {:id 2 :name &amp;quot;Ulman&amp;quot;} {:id 3 :name &amp;quot;Sethi&amp;quot;}]
      in (chan)]
  (go-loop []
    (when-let [[id return] (&amp;lt;! in)]
      (&amp;gt;! return (some #(when (= id (:id %) ) %) db))
      (recur)))

  (let [chan-cache (chan)]
    (go-loop [id 1]
      (&amp;gt;! in [id chan-cache])
      (when-let [res (&amp;lt;! chan-cache)]
        (println res)
        (recur (+ id 1))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数のアクセスがあることを考えると双方向チャネルがあるからといってそれ1つを使うのは良くないでしょう。混線してしまいます。今回は返信用のチャネル自身も一緒に送ってしまってそこにDocumentを貰うことにしました。
ActorならActor ID(Ref)を送ることになるでしょう。&lt;/p&gt;

&lt;h1 id=&#34;message-routing:258416a532a86ac327ddeb3b653d90b7&#34;&gt;Message Routing&lt;/h1&gt;

&lt;p&gt;この章は主にAkkaのクラスタ、分散実行に関る内容です。それ自体非常に興味深いのですがClojureだと試せないので飛ばします。
まあ、実際にはクラスタを組まなくてもいくつかのactorを使ってactor群同士でやりとりをすればいいのですが準備が中々面倒ですね。&lt;/p&gt;

&lt;p&gt;一応扱われているトピックを拾うとContent Based Router, Message Filter, Dynamic Router, Recipient List, Splitter,
Aggregator, Resequencer, Composed Message Processor, Scatter-Gather, Routing-Slip, Process Manager, Message Brokerです。
見ての通り非常に数が多く、ページ数もかなり割かれています。そして、よく使いそうなパターンが多く載っています。Scatter-Gatherとか重い処理する時に使いそうなんですけどね。&lt;/p&gt;

&lt;h1 id=&#34;などなど:258416a532a86ac327ddeb3b653d90b7&#34;&gt;などなど&lt;/h1&gt;

&lt;p&gt;ここまでで、4~7章を紹介しました。原書は10章まで続きます(1-3章は何故Actorが必要なのかなどを延々語ってます)が私はこの辺で筆を置くことにします。続きが気になる方は原書をお読み下さい。&lt;/p&gt;

&lt;p&gt;Advent Calendar遅刻して大変申し分けありませんでした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DSLとTagless Final</title>
      <link>http://keens.github.io/slide/DSLtoTagless_Final/</link>
      <pubDate>Sun, 13 Dec 2015 22:42:39 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/DSLtoTagless_Final/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# DSLとTagless Final
----------------------
サイバーエージェント アドテクスタジオ  
Scala Meet Up 2015-12-18

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒エンジニア
 + Lisp, ML, Rust, Shell Scriptあたりを書きます
   - Scalaは初心者 ※ [Scala初心者の新卒が頑張ってLispを作ってみた](http://adtech.cyberagent.io/scalablog/2015/12/05/scala-lisp/)

# 注意
------

* Scala初心者なのでScalaではなくScalaっぽい疑似コードで説明します
  + ~~コード例動かす時間が無かっただけ~~
* Scala初心者なのでScalaのコードは少なめに説明します


# DSLを作る
-----------

以下のようなHTTPなユーザをエミュレートするDSLを考える

``` scala
val scenario = and(
  get(&#34;/&#34;),
  get(&#34;/users&#34;).andThen(res =&gt;
    post(&#34;/follow&#34;, first(users.getJsonData))))
val Right(_) = runScenario(scenario, &#34;user&#34;)
```


# DSLを作る
-----------

普通は以下のようなAST作ってをラップする

``` scala
trait ScenarioDSL
sealed case class Get(url: String) extends ScenarioDSL
sealed case class Post(url: String, data: JSON) extends ScenarioDSL
sealed case class And(first, ScenarioDSL, second ScenarioDSL) extends ScenarioDSL
sealed case class AndThen(first: ScenarioDSL,
   callBack: (Response) =&gt; ScenarioDSL) extends ScenarioDSL

def get(url: String): ScenarioDSL= Get(url)
....

```


# DSLを作る
-----------

そして`runScenario`を作る

``` scala
def runScenario(scenario: ScenarioDSL, user: String) = {
  scenario match {
    Get(url) =&gt; Client.getInstance(user).get(url)
    Post(url) =&gt; Client.getInstance(user).post(url)
    And(first, second) =&gt; {runSenario(first, user); runSenario(second, user)}
    ....
  }
}


```




# DSLを便利に
-------------

例えば、このDSLを`curl`コマンド関数を追加する

``` scala
def toCurl(scenario: ScenarioDSL, user: String) =
  val auth = makeAuth(user)
  scenario match {
    Get(url) =&gt; &#34;curl ${auth} ${SERVICE_HOST}/url&#34;
    Post(url) =&gt; &#34;curl ${auth} -XPOST ${SERVICE_HOST}/url&#34;
    And(first, second) =&gt; toCurl(first) + &#34;\n&#34; + toCurl(second)
    ....
  }
}

```


# DSLの拡張
-----------

このDSLに新たに`select`を追加する

``` scala
val scenario = and(
  get(&#34;/&#34;),
  select(get(&#34;/users&#34;),
         post(&#34;/update&#34;)))
val _ = runScenario(scenario, &#34;user&#34;)
```


# Expression Problem
-------------------

この時に問題が出る

* DSLを使う全てのコードに変更が必要
  + `runScenario`と`toCurl`で`select`に対応する
* DSLそのものに手を加える必要がある
  + DSLがsealed traitされてる
  + そもそも、DSLがライブラリだったら変更出来るの？
* 実際には使ってなくても全ての関数で新しい機能に対応しないといけない
  + `toCurl`では`select`に対応しないとか
  + 逆に、`toCurl`がプラグインでコードいじれなかったらどうしよう

# Tagless Finalで解決出来るよ
----------------------------

* 元のコードをいじらず
* 必要な所だけを記述して
* しかも元々の実装よりも速い

DSLの作り方があります。それは型クラスを使ったやり方です。


# 型クラスの復習
---------------

型クラスは

* 型の振る舞うインターフェースを定めて
* インスタンスの型ごとに「後付けで」実装を与えると
* 多相的に扱えるアドホックポリモーフィズム

でした


# 型クラスの復習
---------------

``` rust
trait Hello { //型クラス
  fn hello(&amp;self) -&gt; String;
}

impl Hello for isize { //isize型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;I&#39;m {} years old&#34;, self)}
}
impl &lt;&#39;a&gt;Hello for &amp;&#39;a str {//&amp;str型のインスタンス
  fn hello(&amp;self) -&gt; String {format!(&#34;My name is {}&#34;, self)}
}
fn main() {
  println!(&#34;{}&#34;, 23.hello());     // =&gt; &#34;I&#39;m 23 years old&#34;
  println!(&#34;{}&#34;, &#34;κeen&#34;.hello()); // =&gt; &#34;My name is κeen&#34;
}
```


# DSLをRustに翻訳
-------------

Scalaで型クラスを説明するとややこしいので一旦先のDSL例をRustに翻訳します

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getJsonData().first)));
runScenario(scenario, &#34;user&#34;).unwrap();
```


# Rustに翻訳
-------------
DSLのASTはこうなります。

``` rust
enum ScenarioDSL {
  Get{url: String},
  Post{url: String, data: RequestData},
  And{first: Box&lt;ScenarioDSL&gt;, second: Box&lt;ScenarioDSL&gt;},
  AndThen{first: Box&lt;ScenarioDSL&gt;,
   callBack: FnOnce&lt;(Scenario, Request) -&gt; ScenarioDSL&gt;},
}
```

# Rustに翻訳
-------------
runScenarioはこうなります。

``` rust
fn runScenario(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; Result&lt;()&gt; {
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; Client::instance(user).get(url),
    &amp;ScenarioDSL::Post{ref url} =&gt; Client::instance(user).post(url),
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      try!(runSenario(first));
      runSenario(second)
    },
   ...
  };
}
```


# Rustに翻訳
-------------
`toCurl`はこうなります

``` rust
fn toCurl(scenario: &amp;ScenarioDSL, user: &amp;str)-&gt; String {
  let auth = makeAuth(user)
  match scenario {
    &amp;ScenarioDSL::Get{ref url} =&gt; format!(&#34;curl {} {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::Post{ref url} =&gt; format!(&#34;curl {} -X POST {}{}&#34;, auth, SERVICE_HOST, url)
    &amp;ScenarioDSL::And{ref first, ref second} =&gt; {
      let first_str = toCurl(first, user);
      let second_str = toCurl(second, user);
      format!(&#34;{}\n{}&#34;, first_str, second_str)
    },
   ...
  }
}
```


# Tagless Final
---------------

Rustの準備が終わったのでTagless Finalの説明に入ります。


# Tagless Final
----------------

* ASTをデータではなく関数で表わす
* 同じ関数でも欲しい結果によって計算を変えるために型クラスを使う
* どの型クラスのインスタンスとして扱うかで結果を変える
  + そもそもASTは計算を抽象化してデータにしたもの。
  + 抽象的な計算があるならデータにする必要はない

* 型クラスでジェネリックに作って
* 欲しい型を伝えるだけで挙動が変わる


# 型クラス
----------
DSLの文法の型クラスを定義する。  
DSLっぽく見せるため、ラッパを書く(Rust特有)。


``` rust
trait ScenarioSYM {
  fn get(url: String) -&gt; Self;
  fn post(url: String) -&gt; Self;
  fn and(first: Self, second: Self) -&gt; Self;
  ...
}

fn get&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::get(url)}
fn post&lt;C: ScenarioSYM&gt;(url: String) -&gt; C {C::post(url)}
fn and&lt;C: ScenarioSYM&gt;(first: C, second: C) -&gt; C {C::and(first, second)}
...
```



# `runScenario`
------
結果に`Result`型が結果として欲しいなら`Result`型に`ScenarioSYM`を実装する

```rust
impl ScenarioSYM for Result&lt;()&gt; {
  fn get(self,url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn runScenario(res: Result&lt;()&gt;) -&gt; Result&lt;()&gt; {
  res
}
```


# `toCurl`
----------
`String`が欲しいなら`String`に実装すれば良い。

``` rust
impl ScenarioSYM for String {
  fn get(self, url: String) -&gt; Self {...}
  fn post(self, url: String) -&gt; Self {...}
  fn and(self, url: String) -&gt; Self {...}
}

fn toCurl(str: String) -&gt; String {
  str
}
```


# 完成形
--------

``` rust
let scenario = and(
  get(&#34;/&#34;.to_string()),
  get(&#34;/users&#34;.to_string()).andThen(|req|
    post(&#34;/follow&#34;.to_string(), req.getData().iter().next())));
  // ↑ここまではジェネリックなScenarioSYM型
  // ↓ここで呼ばれることでResult&lt;()&gt;型にインスタンス化される
runScenario(scenario, &#34;user&#34;).unwrap();
```


# DSLの拡張
-----------

拡張したい文法のDSLを定義して、欲しいものに実装するだけ。

`runScenario`に変更は要らないしサポートしない`toCurl`は気にしなくて良い。

``` rust
trait SelectSYM {
  fn select(self, first: Self, second: Self) -&gt; Self;
}

impl SelectSYM for Result&lt;()&gt; {
  fn select(self, first: Self, second: Self) -&gt; Self {...}
}
```


# Tagless Finalまとめ
---------------------

* この方式だと実行時にタグでパターンマッチしないので速い
* DSLの拡張も機能の拡張も容易
* 型クラス便利


# ScalaでのTagless Final
------------------------
Rustで分かりやすく解説したのでScalaでどうなるか見ていきます。

まずは型クラスを定義

``` scala
trait ScenarioSYM[C] {
  def get(self: C, url: String): C
  def post(self: C, url: String): C
  ...
}
def get(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.get(self, url)
def post(self: C, url: String)(implicit i: ScenarioSYM[C]): C = i.post(self, url)
...
```


# `runScenario`
------

``` scala
implicit val resultScenario = new ScenarioSYM[Either[Err, ()]] {
  def get(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  def post(self: Either[Err, ()], url: STring): Either[Err, ()] = ...
  ...
}

def runScenario(ast: Either[Err, ()], user: String)
      (implicit i: ScenarioSYM[Either[Err, ()]]) = ast
```


# 完成形
--------
Scalaの型クラスの制約上最初の例と少し異なる
(`val`じゃなくて`implicit`を取る`def`になる)


``` scala
def scenario(implict i: ScenarioSYM[C]) = Scenario
   get(&#34;/&#34;)
   get(&#34;/users&#34;) andThen((scenario, res) =&gt;
    scenario post(&#34;/follow&#34;, first(users.getJsonData)))
val Right(_) = runScenario(scenario, &#34;user&#34;)

```


# まとめ
--------

* Expression Problemについて説明した
* Tagless Finalを紹介した
* 型クラス便利
* Rust便利
* [参考](http://okmij.org/ftp/tagless-final/course/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Rustでの日本語の扱い</title>
      <link>http://keens.github.io/blog/2015/12/13/rustdenonihongonoatsukai</link>
      <pubDate>Sun, 13 Dec 2015 17:14:18 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/12/13/rustdenonihongonoatsukai</guid>
      <description>

&lt;p&gt;このエントリは&lt;a href=&#34;http://qiita.com/advent-calendar/2015/rust-lang&#34;&gt;Rust Advent Calendar&lt;/a&gt; 14日目の記事です&lt;br /&gt;
前:gifnksmさんの &lt;a href=&#34;http://gifnksm.hatenablog.jp/entry/2015/12/13/204655&#34;&gt;kcovを使ってRustプログラムのカバレッジを測定する - gifnksmの雑多なメモ&lt;/a&gt;&lt;br /&gt;
後:nacika_insさんのtimeこわい&lt;/p&gt;

&lt;p&gt;κeenです。当初の予定より小ネタになってしまいましたがRustでの日本語の扱いについて書こうかと。&lt;/p&gt;

&lt;p&gt;ご存じの通りRustはマルチバイト文字をサポートしていますが、その殆どがUTF-8だけです。しかし日本人にはUTF-8だけでは少し辛いものがありますのでどうにかして対応しようかと。&lt;/p&gt;

&lt;p&gt;ソースコード中でもマルチバイト文字を扱えますが、UTF-8である必要があります。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rs&#34;&gt;fn main() {
  println!(&amp;quot;あああ&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをISO-2022-JPで保存してrustcに食わせても、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;error: couldn&#39;t read &amp;quot;src/main.rs&amp;quot;: stream did not contain valid UTF-8
Could not compile `japanese`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と無下もないエラーが出てしまいます。&lt;/p&gt;

&lt;p&gt;内部エンコーディングにもUTF-8が使われているのでRustの文字列をUTF-8以外で出力するにはなんとなく変換が必要そうなのは理解出来ますが、変に出入力をラップしてる関数を使うとまた意図せぬエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;

fn main() {
  let file = File::open(&amp;quot;japanese.txt&amp;quot;);
  let br = BufReader::new(&amp;amp;file);
  for line in br.lines() {
    matich line {
      Ok(l) =&amp;gt; println!(&amp;quot;Ok: {}&amp;quot;, l),
      Err(e) =&amp;gt; println!(&amp;quot;{:?}&amp;quot;, e)
    };
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもまた、&lt;code&gt;stream did not contain valid UTF-8&lt;/code&gt;エラーを出します。&lt;/p&gt;

&lt;p&gt;ReadもBufReadもbyte orientedって言ってるのに何故か文字列を扱えるのが若干気になりますがまあ、そういうもんなんでしょう。&lt;/p&gt;

&lt;h1 id=&#34;encoding:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;encoding&lt;/h1&gt;

&lt;p&gt;そこで救世主となるライブラリが&lt;a href=&#34;https://github.com/lifthrasiir/rust-encoding&#34;&gt;lifthrasiir/rust-encoding&lt;/a&gt;です。文字列のエンコーディングをサポートします。
READMEに詳しい使い方が載っているのですが、このライブラリは与えられたスライスに対して指定されたエンコーディングでエンコード/デコードします。&lt;/p&gt;

&lt;p&gt;なので先の例のようにISO-2022-JPで&lt;code&gt;&amp;quot;あああ&amp;quot;&lt;/code&gt;と出力したいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use encoding::{Encoding, EncoderTrap};
use encoding::all::ISO_2022_JP;
use std::io::Stdout;

fn main() {
  let bytes = ISO_2022_JP.encode(&amp;quot;あああ&amp;quot;, EncoderTrap::Ignore);
  Stdout.write_all(&amp;amp;bytes[..]);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出来るでしょう。(即興で書いてコンパイルすらしてないので本当に出来るかは分かりませんが)&lt;/p&gt;

&lt;p&gt;読み取りに関しては…………。そう、このライブラリはバッファに対してしか動作せず、ストリームに使えないのです。提供してくれたら良さそうなのですが、作者の方が忙しいようです。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; stream encoding/decodingは計画してはいるのですが、私が忙しくてなかなか作業をすることができません&amp;hellip; orz&lt;/p&gt;&amp;mdash; Kang Seonghoon (@senokay) &lt;a href=&#34;https://twitter.com/senokay/status/666516796942319616&#34;&gt;2015, 11月 17&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;余談ですがこの方は韓国の方のようですが、日本語もある程度分かるそうです。すごいですね。&lt;/p&gt;

&lt;p&gt;さて、ストリームに対して使えないと分かったなら自分で対応するまで。幸いにも我々が使っているのはRustです。新しいものを既存の仕組みに載せるのは造作もありません。
ストリームを良い感じにデコードするには&lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Read.html&#34;&gt;std::io::Read&lt;/a&gt;を実装した何かを作れば十分です。作っていきましょう。&lt;code&gt;Read&lt;/code&gt;トレイトを実装するには最低&lt;code&gt;read&lt;/code&gt;だけ実装してしまえば十分です。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;read&lt;/code&gt;ですが、ドキュメントを読むと中々制限が緩いようです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pull some bytes from this source into the specified buffer, returning how many bytes were read.&lt;/p&gt;

&lt;p&gt;This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an Err return value.&lt;/p&gt;

&lt;p&gt;If the return value of this method is Ok(n), then it must be guaranteed that 0 &amp;lt;= n &amp;lt;= buf.len(). A nonzero n value indicates that the buffer buf has been filled in with n bytes of data from this source. If n is 0, then it can indicate one of two scenarios:&lt;/p&gt;

&lt;p&gt;This reader has reached its &amp;ldquo;end of file&amp;rdquo; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will always no longer be able to produce bytes.
   The buffer specified was 0 bytes in length.&lt;/p&gt;

&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true. It is recommended that implementations only write data to buf instead of reading its contents.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「関数が呼ばれる際に&lt;code&gt;buf&lt;/code&gt;に対しては何如なる保証もなく、呼出側はバッファの内容に対して何如なる不変条件も期待してはいけません」とあります。つまり、4096 byteのバッファが与えられても1呼び出しにつき1バイトしか返さないような実装でも許容されます。
また、非同期ベースのIOのようにキャッシュにデータがなければIOブロッキングせずにエラーだとかの挙動もありえます。非常にシステムプログラミング言語らしい仕様ですね。&lt;/p&gt;

&lt;p&gt;今から作ろうとしているデコーディングストリームも読み出したバイト列がデコード後に何バイトになるのか予測がつかないのでこの仕様は有難いですね。&lt;/p&gt;

&lt;p&gt;さて、作っていきましょうか。まずは必要そうなライブラリを読み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
use self::encoding::{EncodingRef, DecoderTrap};
use std::io::Read;
use std::io;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてメインとなる構造体です。とある&lt;code&gt;Read&lt;/code&gt;を実装した型をラップする形にしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct DecodingReader&amp;lt;R&amp;gt; {
    inner: R,
    encoding: EncodingRef,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;はトレイトなので&lt;code&gt;inner&lt;/code&gt;のところを&lt;code&gt;&amp;amp;R&lt;/code&gt;としなくて大丈夫です。&lt;code&gt;Read&lt;/code&gt;の実装側が調整します。&lt;/p&gt;

&lt;p&gt;そしてコンストラクタですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; DecodingReader&amp;lt;R&amp;gt; {
    pub fn new(coding: EncodingRef, read: R)-&amp;gt; Self {
        EncodingReader {
            inner: read,
            encoding: coding
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのままですね。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt;の実装です。まずは&lt;code&gt;inner&lt;/code&gt;の&lt;code&gt;read&lt;/code&gt;を呼んで、その結果を一旦デコードしてからまたバイト列に変換します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;R: Read&amp;gt; Read for DecodingReader&amp;lt;R&amp;gt; {
    fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;usize&amp;gt;{
        // TODO set appropriate buffer size
        let len = buf.len() / 2;
        let n = try!(self.inner.read(&amp;amp;mut buf[..len]));
        // TODO don&#39;t ignore input code
        let str = self.encoding.decode(&amp;amp;mut buf[..n], DecoderTrap::Ignore).unwrap();
        let mut i = 0;
        for (d, s) in buf.iter_mut().zip(str.bytes()) {
            *d = s;
            i+=1;
            if i == 0 {
                break
            };
        }
        assert!(i &amp;lt;= buf.len());
        Ok(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程も言った通りデコード読み込んだバイト列をUTF-8にした時にどれくらいバイト数が変わるか分からないので山勘で2倍くらいに膨らむだろうとして与えられたバッファ長の半分を使います。
ここはもう少し調整が必要ですね。エンコーディング毎に適切なバッファ長を設定したい…&lt;/p&gt;

&lt;p&gt;バッファを確保出来たら&lt;code&gt;let n = try!(self.inner.read(&amp;amp;mut buf[..len]));&lt;/code&gt;してそれっぽいサイズ読み込んで、読み込んだサイズをデコードにかけます。&lt;/p&gt;

&lt;p&gt;現在&lt;code&gt;DecoderTrap&lt;/code&gt;を&lt;code&gt;Ignore&lt;/code&gt;にして&lt;code&gt;unwrap&lt;/code&gt;してますが、これは少し雑すぎますね。例えば入力が全てvalidな文字を含んでいたとしても&lt;code&gt;read&lt;/code&gt;が多バイト文字の真ん中までしか読まなかった時にそれが無効なエンコーディングと判定されて無視されるのでユーザからしたら「合ってる筈なのに何故か1文字欠損するバグ」として現れます。今回即席で作ったので勘弁して下さい。&lt;/p&gt;

&lt;p&gt;変換は文字列にしか出来ないようなので一旦文字列に落してからまたバイト列として取り出し、バッファに書き出します。デコード後のバイト列が&lt;code&gt;read&lt;/code&gt;したバイト列より小さかったら一部&lt;code&gt;read&lt;/code&gt;したデータが残ってしまいそうですが、「何如なる不変条件も…」とあるので問題ないでしょう。返り値にデコード後のバイト列の長さを返していれば良い筈です。&lt;/p&gt;

&lt;p&gt;さて、エンコードのエラーハンドリングしてないだとか本当に読み込みのバッファ長が適切なのかとかの疑問はあるものの、一応ストリームのデコーダが出来ました。使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate encoding;
extern crate japanese;

use encoding::{Encoding, DecoderTrap};
use encoding::all::ISO_2022_JP;

use std::fs::File;
use std::io::BufReader;
use std::io::BufRead;
use std::str::from_utf8;
use japanese::buf::DecodingReader;


fn main() {
    let file = File::open(&amp;quot;src/japanese.txt&amp;quot;).unwrap();
    let e = DecodingReader::new(ISO_2022_JP, &amp;amp;file);
    let mut br = BufReader::new(e);
    for line in br.lines() {
        println!(&amp;quot;{}&amp;quot;, line.unwrap());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでちゃんとISO-2022-JPのファイルを読めます。&lt;/p&gt;

&lt;p&gt;Javaに慣れてる人ならこういうIOに対するデコレータパターンは見覚えがあるでしょう。&lt;/p&gt;

&lt;p&gt;今更ですがiso-2022-jpはいわゆるjisエンコーディングです。rust-encodingはshift_jisの拡張にあたるwindows31jだとかeuc-jpも扱えます(&lt;a href=&#34;https://lifthrasiir.github.io/rust-encoding/encoding/codec/japanese/index.html&#34;&gt;参考&lt;/a&gt;)。&lt;/p&gt;

&lt;h1 id=&#34;今後:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;今後&lt;/h1&gt;

&lt;p&gt;ライブラリとして公開するか、あるいは作者の方がやる気はあるようなのでプルリクを送るかが終着点かな、と思っていますが如何せん雑にしか実装してないので微妙ですね。
例の境界とマルチバイトの問題は&lt;code&gt;Read&lt;/code&gt;じゃなく&lt;code&gt;BufRead&lt;/code&gt;を要求して1文字分読み切るまで来るまで1バイトずつ読むとかになると思います。ダルい。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:e3d3c2e4aaee703e1a1583ece8aa80f1&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Rust標準だけでUTF-8以外の文字列を使うのはつらいよ&lt;/li&gt;
&lt;li&gt;Rustのエンコーディングライブラリを紹介したよ&lt;/li&gt;
&lt;li&gt;エンコーディングライブラリを使ってストリームデコーダを実装してみたよ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回のコードは&lt;a href=&#34;https://github.com/KeenS/japanese&#34;&gt;こちら&lt;/a&gt;にあります&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>