<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>/index.xml</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Wed, 22 Mar 2017 19:57:28 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rust in Production</title>
      <link>/slide/Rust_in_Production/</link>
      <pubDate>Wed, 22 Mar 2017 19:57:28 +0900</pubDate>
      
      <guid>/slide/Rust_in_Production/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Rust in Production
----------------------
[Rust プログラマーミートアップ / Rust programmers&#39; meetup - connpass](https://rust.connpass.com/event/49304/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * 若者
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# Rust採用までの流れ
--------------------

Ω＜「κeen君継続的ベンチマークサーバ作って」&lt;!-- .element: style=&#34;color:#a00;text-align:left;&#34; --&gt;  
Ω＜「GitHubにpushする度ベンチマーク走る感じで」&lt;!-- .element: style=&#34;color&#34;:#a00;text-align:left;&#34; --&gt;  
Ω＜「GPUとRaspberry Piでベンチマークするから」&lt;!-- .element: style=&#34;color:#a00;text-align:left;&#34; --&gt;  
Ω＜「全部任せるね」&lt;!-- .element: style=&#34;color:#a00;text-align:left;&#34; --&gt;  

⸜( ¯⌓¯ )⸝「Rustで書くか」&lt;!-- .element: style=&#34;color:#00a;text-align:left;&#34; --&gt;  


やったこととか知見とかトピック毎にかいつまんで話します

&lt;!-- .slide: class=&#34;left&#34; --&gt;

===
# Rustのメリット
---------------

* κeenが馴れてる
* 社員の半分くらい書ける
* Linux, Mac, Raspberry Piで動く
* テスト書かなくてもそんなにバグらなそう
* 将来のために小さいところでノウハウ溜めていきたい
* シングルバイナリで楽に動きそう
* **単純に使いたかった**
* ※今回は速度や安全性は必要ない

===
# コンポーネント
---------------

* CLIクライアント
  + 各自の手元やCIサーバから起動
* アグリゲータ
  + ワーカに仕事を投げ、結果を受け取る
  + ジョブ管理
* ワーカ
  + GPUマシンやRSPiなどでベンチマーク
  + 結果をアグリゲータに返す
* ブラウザ
  + ベンチマーク結果の閲覧

===
# プロジェクト構成
-------------------

* [ワークスペース](http://doc.crates.io/manifest.html#the-workspace--field-optional)を使ってサブプロジェクトに分割
  + モノリシックだとビルドが重かった
  + targetは全てのプロジェクトで共有する
* CLI, aggregator, worker, browserの他にmodel, api
* modelはaggregatorとbrowserで共有
* apiはaggergatorとcliとworkerで共有
* コード

===

# プロジェクト構成
-------------------


```
Cargo.lock
Cargo.toml
README.md
bench_aggregator/
bench_api/
bench_browser/
bench_cli/
bench_model/
bench_worker/
build.sh
circle.yml
docker-compose-deploy.yml
docker-compose.yml
migrations
rustfmt.toml
src/
static/
target/
```

===
# プロジェクト構成
-------------------

![構成のイメージ](/images/rust-in-production/composition.png)&lt;!--  width=&#34;100%&#34; --&gt;


===
# パーサ
--------

* workerで使う
* timeやgprofの結果を数値で欲しい
* →パースするか…
  + フォーマット
* timeはbash固定
  + シェルコマンドなのでシェル毎にフォーマットが違う
* gprofは`-b`オプションでの結果をパース
  + gmon.outではない

===
# パーサ
--------

* パーサコンビネータ [nom](https://github.com/Geal/nom)
* サクっと作れた
* デバッグつらい
  + gprofが思ったより変なフォーマットしてた
  + nomがバイト指向なのと位置を保存しない
  + 自力でどうにかする？
  + [combine](https://github.com/Marwes/combine)使うか手書きにするかで書き直したい
* コード

===

# CLIオプション
---------------

* workerとcliで必要
* 多機能な[clap](https://github.com/kbknapp/clap-rs)を採用
* 特に困らない
* 採用プロジェクトも多くてliving exampleに事欠かない
* CLIツールに思考停止で採用していいと思う
* コード

===
# HTTPクライアント
------------------

* CLIとworkerで使う
* [hyper](https://github.com/hyperium/hyper) vs [reqwest](https://github.com/seanmonstar/reqwest)
* 非同期な必要はないのでreqwest使いたかった
* reqwestにmultipart対応がない→生hyper+[multipart](https://github.com/abonander/multipart)
* コネクションの管理とかjsonの扱いとかそこそこ面倒だった…
* reqwestにmultipart対応入ったら乗り換えるかも

===
# HTTPサーバ
------------

* aggregatorとbrowserで使う
* 簡単なREST API
* 生hyper vs [nickel](https://github.com/nickel-org/nickel.rs) vs [iron](https://github.com/iron/iron)
* 生hyperはすぐつらくなる→やめた
* **nickelとironはそんなに変わらなかった**
* nickel(agregator)+iron(browser)
  + aggregatorはなんとなくでnickel選んじゃった
  + browserは結局[rustc-perf](https://github.com/rust-lang-nursery/rustc-perf)からフォークしたためironだった

===

# HTTPサーバ(Nickel)
------------

* サーバデータの扱いがちょっと特殊？
  ```rust
    let data = req.server_data();
  ```
* 400 BadRequestと500 InternalServerErrorのマクロ作った
  + `validate!(res, serde_json::from_str(field));`
  + `server_try_with!(res, serde_json::to_string(&amp;ret));`
  + 「エラー出たら処理終了」が他の言語と比べて書きづらい？
* 非同期IOしない…
  + ポーリングでコネクション張りっぱなしなのでクライアント分スレッドが必要（ハマった）
* マルチスレッド→DBコネクションにロックが必要
* コード

===
# APIモデル
-----------

* apiクレートを分けた
  + バイナリ毎に別クレートに分けるために必要だった
* [serde](https://github.com/serde-rs/serde)と[serde_json](https://github.com/serde-rs/json)でjson化
* proc-macroがstableになって格段に使いやすくなった
* モジュール分けて`Request`と`Response`を作ってAPIが分かりやすく
* コード

===
# DB
-----

* aggergatorとbrowserで必要
* ほぼ[diesel](https://github.com/diesel-rs/diesel)一択
  + コネクション、マイグレーション、ORMなど
  + proc-macroで大分楽に
* [仕事でdiesel使ってみた | κeenのHappy Hacκing Blog](https://keens.github.io/slide/shigotodedieseltsukattemita/)
* DBはPostgreSQL
  + 半分dieselのため、もう半分機能のため
* 開発時はdocker-composeで立てる
  + CF [docker-composeでmysql &amp; postgreSQL をサクッと起動 - Qiita](http://qiita.com/astrsk_hori/items/1e683a7a2f2b7189cb6e)

===
# diesel
-----

* Pros
  + SQLでスキーマ書ける
  + マイグレーションの面倒みてくれる
  + proc-macroのおかげで楽
  + クエリDSL案外普通に書けた
  + 最悪SQL生牡蠣出来る
  + CLI便利

===
# diesel
--------

* Cons
  + deriveいっぱいあって難しい
    - has_manyとbelongs_toあたりをどう書くか
  + enum扱えない
  + DSLで2重join書けない
  + 偶に機能足りない
    - ネットワークアドレス型サポートとか
  + SQL生牡蠣の型付けつらい
  + has_manyの扱いに難あり
    - eager loadingしない設計判断
    - `(User, Vec&lt;Tweets&gt;)` みたいなのを持ち回す羽目に
    - モデル設計にも影響

===
# マイグレーション
-----------------

* 普通のマイグレーション運用かな
* 最初のデプロイまでは`diesel database reset`で何度も初期化した
* 最初デプロイ後は手元で`diesel migration run`と`diesel migration revert`を何度か
* デプロイ時に雑に手元から本番サーバに `diesel migration run`
  + 本当はデプロイプロセスに組込みたい
  + diesel CLIの入ったdockerコンテナ…
* まだほとんど使われてないので雑運用


===
# マイグレーション(コード)
-----------------

* スキーマ変更したらコードの変更も必要
  + そもそも必要だからスキーマ変更するので割と自然に出来る
* `infer_schema` があるので先に開発環境のマイグレーションをしないといけない
* カラムの順番とフィールドの順番が一致する必要
  + 地味に面倒
  + 今後改善予定 CF [#747](https://github.com/diesel-rs/diesel/pull/747)
* SQL生牡蠣の対応がつらい
  + コンパイル時にカラム不足が分からない

===
# エラー管理
------------

* 全ての場所で必要
* [error_chain](https://github.com/brson/error-chain)を採用
* 公式ドキュメントの[エラーハンドリング](https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/error-handling.html)のボイラプレートをマクロで生成
* `?`でのエラー処理が楽になる→ `unwrap`が消えた
* 全てのプロジェクトに思考停止で採用していいんじゃないかな

===

# ログ
------

* 全ての場所で必要
* nurseryの[log](https://github.com/rust-lang-nursery/log)と[env_logger](https://github.com/rust-lang-nursery/log)を採用
* `println!`より高機能な（on/offが出来る）ので`println!`の代わりに`debug!`を入れる
* あとたまにエラーハンドリングで`error!`使ったり
* `main`で一行`env_logger::init().expect(&#34;failed to init env logger&#34;);`を忘れずに
* 運用以前に開発に便利なので問答無用で入れていいと思う

===
# コンフィグ
------------

* [serde_yaml](https://github.com/dtolnay/serde-yaml) + [dotenv](https://github.com/slapresta/rust-dotenv)
* コンフィグファイルといえばyamlだよね
  + ちょこっといじって再起動がやりやすい
* dotenvはdockerと相性がいい気がする
* どっちがいいか判断出来なかったので両方実装
* プロダクションで動いてるのはdotenv（というか普通の環境変数）の方

===

# テスト
--------

* 全ての場所で必要
* 組込みの`#[test]`を使用
* 正直あまり出来てない
* 型強いし多少はなくてもバグらない…？
* 一応レイヤ(DB/ビジネスロジック/インタフェース)を跨ぐときにはtraitで抽象化
  + 出来てないところもいっぱい
* 今後の課題とさせて頂きます

===
# デバッグ
----------

* 基本はlogの`debug!`でトレース
* ちゃんと型つけときゃバグらない
* GDB使う…？
* デモ

===

# ビルド
--------

* cargoでサブプロジェクト全てをビルドするコマンドがなかった
  + 最近 `cargo build --all` が入った
* Raspberri Pi向けにクロスコンパイルが必要
* シェルスクリプトでビルドスクリプト
* クロスコンパイルはdockerを使う CF [dlecan/rust-crosscompiler-arm: Docker images for Rust dedicated to cross compilation for ARM v6 and more](https://github.com/dlecan/rust-crosscompiler-arm)
* 正解なのか分からない

===
# CI
----

* 全てのクレートで必要
* Circle CIを使ってる
* 普通にrustupでRustのインストール
  + travisならRustサポートあるけど…
* 普通に `cargo test --all`

===

# デプロイ
----------

* シングルバイナリだけど…
* シュっとdocker-swarmとかでデプロイしたい
* dockerイメージ作ってdocker-composeで管理
  + 開発も便利に
* raspberry piはバイナリだけ配る
* browserは`static/`もイメージに同梱

===
# Docker
--------

* ベースイメージはUbuntu
  + libcの扱いが面倒そうなのでalpineはやめといた
  + イメージサイズに困ってからどうにか考える
* swarmなのでdocker-composeの設定そのままで動かせる
* ログの管理もswarm任せ
  + env_loggerが標準出力に吐くのもそんなに困ってない

===
# Docker
--------

* rustのビルドからのdockerのビルドが面倒
* Dockerfileの管理も面倒
* 便利なの作った
* [KeenS/cargo-pack-docker: a cargo subcommand to package your application into a docker image](https://github.com/KeenS/cargo-pack-docker)
* DockerfileなしでRustのビルドからイメージ作成までやってくれる
* 今のところ使えてる
  + 作りが甘いことは認識してる…

===
# まとめ
---------

* Rustを仕事で使ったときの知見を話した
* 微妙に痒いところに手が届かないけど概ね揃ってる
* 開発が速いので問題は放置しとくと勝手に直るかも
* テストとかデプロイとかまだ知見が足りない


&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>オーディナルの話とカーディナルの話</title>
      <link>/blog/2017/03/02/o_dinarunohanashitoka_dinarunohanashi</link>
      <pubDate>Thu, 02 Mar 2017 21:15:44 +0900</pubDate>
      
      <guid>/blog/2017/03/02/o_dinarunohanashitoka_dinarunohanashi</guid>
      <description>&lt;p&gt;ちょっとオーディナルの話をしよう。ついでにカーディナルの話もしよう。
特に何も知らなくても分かる内容。だけど文脈を知ってると伝えたいことが伝わる筈。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;まずは何もないところから始めよう。机もスマホもパソコンンもない。空気もないし数字もない、自然数もない。&lt;/p&gt;

&lt;p&gt;何もない。&lt;/p&gt;

&lt;p&gt;「何もない」、もうちょっと正確にいうと「何も要素がない集合」のことを覚えているだろうか。中学校で習った気もする。&lt;/p&gt;

&lt;p&gt;\[
\emptyset
\]&lt;/p&gt;

&lt;p&gt;と書く。
さて、ここから始める。何もないところから何か作れるだろうか。まずは $\emptyset$ を要素に持つ集合、&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset\}
\]&lt;/p&gt;

&lt;p&gt;がある。これは要素を1つだけ持つので $\emptyset$ とは異なる集合だ。これをさらに進められないだろうか。例えば&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \emptyset\}
\]&lt;/p&gt;

&lt;p&gt;とか。これではダメだ。結局2つの要素が同じ $\emptyset$ なので要素を取り出してみても $\{\emptyset\}$ から取り出したときと区別がつかない。
何か $\emptyset$ とは別のものが必要だ。 $\emptyset$ とは別のもの。既に出てきた。 $\{\emptyset\}$ だ。&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \{\emptyset\}\}
\]&lt;/p&gt;

&lt;p&gt;これで $\emptyset$ とも $\{\emptyset\}$ とも異なる集合が作れた。ここまできたらあとはもうパターンだ。「次」が欲しければ今までに出てきた集合を全部$\{\}$に放り込めばいい。&lt;/p&gt;

&lt;p&gt;\[
\{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\}
\]&lt;/p&gt;

&lt;p&gt;「次(Successor)」を求める手続を $\mathbf{succ}$ と書くとすると、集合の合併 $\cup$ を用いて&lt;/p&gt;

&lt;p&gt;\[
\mathbf{succ} (x) = x \cup \{x\}
\]&lt;/p&gt;

&lt;p&gt;と書ける。この $\mathbf{succ}$ 、必ず新たな集合を生み出している。これはつまり、任意の $x$ に対して $\mathbf{succ}(x)$ は $\emptyset$ にはならないし、 $x \not= y$ のとき $\mathbf{succ}(x) \not=\mathbf{succ}(y)$ でもある。
このようなものをご存知ないだろうか(細かいことを言うと帰納法の原理も必要だが飛ばす)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%9A%E3%82%A2%E3%83%8E%E3%81%AE%E5%85%AC%E7%90%86&#34;&gt;自然数&lt;/a&gt;だ。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$\emptyset$ がある&lt;/li&gt;
&lt;li&gt;任意の自然数 $x$ に $\mathbf{succ}(x)$ がある&lt;/li&gt;
&lt;li&gt;$\emptyset$ はいかなる自然数 $x$ の $\mathbf{succ}$ でもない&lt;/li&gt;
&lt;li&gt;$x \not= y$ のとき $\mathbf{succ}(x) \not=\mathbf{succ}(y)$&lt;/li&gt;
&lt;li&gt;(帰納法の原理が成り立つ)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これは、こういうことだ。&lt;/p&gt;

&lt;p&gt;\[
\begin{eqnarray}
0 &amp;amp; = &amp;amp; \emptyset \\\&lt;br /&gt;
1 &amp;amp; = &amp;amp; \{\emptyset\} \\\&lt;br /&gt;
2 &amp;amp; = &amp;amp; \{\emptyset, \{\emptyset\}\} \\\&lt;br /&gt;
3 &amp;amp; = &amp;amp; \{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\} \\\&lt;br /&gt;
  &amp;amp; \vdots &amp;amp;
\end{eqnarray}
\]&lt;/p&gt;

&lt;p&gt;ここでは &lt;a href=&#34;https://twitter.com/search?q=%230%E3%81%AF%E8%87%AA%E7%84%B6%E6%95%B0&amp;amp;src=typd&#34;&gt;#0は自然数&lt;/a&gt; としてある。
さて、今我々は何もないところから出発してDASH村のように自然数を作り上げた。&lt;/p&gt;

&lt;p&gt;この自然数、面白い性質がある。 0 は 1の要素( $0 \in 1$) だ。 1 は 2 の要素 ( $1 \in 2$ )だし、0も2の要素 $0 \in 2$ だ。もうちょっというと、 $x \in y$ かつ $y \in z$ のとき、 $x \in z$も成り立つ。
この関係で自然数には順序がつく。つまり、自然数は&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E9%A0%86%E5%BA%8F%E6%95%B0&#34;&gt;順序数&lt;/a&gt;(オーディナルナンバー)だ。再度、オーディナルナンバーであるところの自然数を列挙するとこうなる。&lt;/p&gt;

&lt;p&gt;\[
\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}, \{\emptyset, \{\emptyset\}, \{\emptyset, \{\emptyset\}\}\}, &amp;hellip;
\]&lt;/p&gt;

&lt;p&gt;これに見覚えがあるならオーディナルの話はこれで十分。&lt;/p&gt;

&lt;p&gt;さて、カーディナルの話をしよう。 $\emptyset$ は要素が0個。 $\{\emptyset\}$ は要素が1つ。 $\{\emptyset, \{\emptyset\}\}$ は要素が2つ。
要素数の話だ。これは別に自然数だけでなくて、 $\{2, 4\}$ のように自然数ではない集合でも要素数という概念はある。要素数をどう数えようか。一応要素数に&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%BF%83%E5%BA%A6_(%E6%95%B0%E5%AD%A6)&#34;&gt;濃度&lt;/a&gt;という名前もついている。
これにも自然数が使える。2と $\{2, 4\}$ を $\{2, 4\}$ を $2 -\emptyset$ と $4 - \{\emptyset\}$ と1対1に対応づければ、「$\{2, 4\}$と 2は同じ濃度を持つ」といえる。
このように濃度を数えるための数を&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0&#34;&gt;基数&lt;/a&gt;（カーディナルナンバー）という。&lt;/p&gt;

&lt;p&gt;手で数えられる（有限な）ものは面白みがない。無限なものについて考えよう。例えば今我々が作った自然数は常に $\mathbf{succ}$ がとれるので無限の要素がある。
まだ作ってないが、自然数だけでなく整数にも有理数にも実数にも無限の要素がある。これらの「無限」は全て同じ大きさなのだろうか、つまり同じ濃度なのだろうか。
結論からいうと自然数と整数と有理数は同じ濃度を持つ。全て自然数と1対1の対応が取れるということだ。一方&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB%E3%81%AE%E5%AF%BE%E8%A7%92%E7%B7%9A%E8%AB%96%E6%B3%95&#34;&gt;実数は対応が作れない&lt;/a&gt;。実数の濃度の方がずっと大きい訳だ。つまり、無限の間にも大小関係がある。実は自然数は無限の中でも一番小さい。この一番小さい基数のことをヘブライ文字からとって&lt;/p&gt;

&lt;p&gt;\[
\aleph_0
\]&lt;/p&gt;

&lt;p&gt;と書く。これも見覚えがあればカーディナルの話はこれにて重畳。&lt;/p&gt;

&lt;p&gt;そういえばこういう「紙の上でDASH村」を気に入ったならこの本がお勧め。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4791768515&#34;&gt;コンピュータは数学者になれるのか? -数学基礎論から証明とプログラムの理論へ- | 照井一成 |本 | 通販 | Amazon&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>仕事でdiesel使ってみた</title>
      <link>/slide/shigotodedieseltsukattemita/</link>
      <pubDate>Wed, 01 Mar 2017 10:57:38 +0900</pubDate>
      
      <guid>/slide/shigotodedieseltsukattemita/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# 仕事でdiesel使ってみた
----------------------
[RustのLT会！ Rust入門者の集い #2 - connpass](https://rust.connpass.com/event/48826/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===

# [diesel.rs](diesel.rs)

![dieselのwebページ](/images/diesel/diesel-web.png)

===

# diesel
---------


* RustのORM
  * スキーマからコード自動生成
  * diesel_codegen
* クエリビルダ
* マイグレーション管理
* PostgreSQL, MySQL, SQLiteサポート

===

# 準備
-------

* [docker-composeでmysql &amp; postgreSQL をサクッと起動 - Qiita](http://qiita.com/astrsk_hori/items/1e683a7a2f2b7189cb6e)

```
cargo install diesel_cli
echo DATABASE_URL=postgres://username:password@localhost/hoge &gt; .env
diesel setup
diesel migration generate create_posts
```

===

# 準備
-------

``` toml
[dependencies]
chrono = &#34;0.3.0&#34;
diesel = {version = &#34;0.11.4&#34;, features = [&#34;chrono&#34;, &#34;postgres&#34;, &#34;serde_json&#34;]}
dotenv = &#34;0.8.0&#34;
serde_json = &#34;0.9.6&#34;
serde_derive = &#34;0.9.7&#34;
serde = &#34;0.9.7&#34;

[dependencies.diesel_codegen]
features = [&#34;postgres&#34;]
version = &#34;0.11.0&#34;
```

===
# プロジェクト構成
-----------------

* モデルのコンパイルが遅いので分離したい
* Cargoの[ワークスペース](http://doc.crates.io/manifest.html#the-workspace-section)機能を使う

===
# プロジェクト構成
-----------------

```
$ ls
Cargo.lock
Cargo.toml
hoge_model &lt;- diesel_derive使う
hoge_XXX   &lt;- diesel使う
hoge_YYY   &lt;- diesel使う
docker-compose.yml
migrations
...
```
===

# テーブル
---------

* up.sqlとdown.sqlを書く

``` sql
CREATE TABLE hoge_suites (
  id SERIAL PRIMARY KEY,
  hoge_entry_id INT NOT NULL,
  hostname VARCHAR NOT NULL,
  status INT NOT NULL DEFAULT 0,
  CONSTRAINT unique_hoge_entry_id_hostname
             UNIQUE (
                      hoge_entry_id,
                      hostname
                      -- and other matrix
                     ),
  CONSTRAINT fkey_hoge_entry_id
             FOREIGN KEY(hoge_entry_id)
             REFERENCES hoge_entries(id) MATCH SIMPLE
             ON UPDATE NO ACTION
             ON DELETE CASCADE
);

```

===
# モデル
--------

``` rust
// なんかいっぱいderive
// QueryableとInsertableは分ける
#[derive(Default, Queryable, Associations, Identifiable, Debug, Clone)]
// belongs_to関係のstruct
#[belongs_to(HogeEntry)]
// has_many関係のテーブル
#[has_many(hoge_results)]
#[table_name=&#34;hoge_suites&#34;]
pub struct HogeSuite {
    pub id: i32,
    pub bench_entry_id: i32,
    // String
    pub hostname: String,
    pub status: HogeStatus,
}

```

===

# モデル
--------

```
// Insertableの方
#[derive(Default, Insertable, Debug, Clone)]
#[table_name=&#34;hoge_suites&#34;]
pub struct NewHogeSuite&lt;&#39;a&gt; {
    pub hoge_entry_id: i32,
    // Stringではなく&amp;str
    pub hostname: &amp;&#39;a str,
}
```

===

# enumの扱い
-----------

* dieselはenumのcodegenをサポートしてない
* 気合

===

# enumの扱い
-----------

```rust
// Queryableとかはderive出来ない
#[derive(Debug, Clone)]
pub enum HogeStatus {
    Waiting,
    Running,
    Finished,
    Failed,
    Canceled,
}

// 手で実装
impl&lt;BE, QB, BC&gt; FromSql&lt;Integer, BE&gt; for HogeStatus
    where QB: QueryBuilder&lt;BE&gt;,
          BC: BindCollector&lt;BE&gt;,
          BE: Backend&lt;RawValue = [u8], QueryBuilder = QB, BindCollector = BC&gt;
{
    fn from_sql(bytes: Option&lt;&amp;&lt;Pg as Backend&gt;::RawValue&gt;)
                -&gt; Result&lt;Self, Box&lt;Error + Send + Sync&gt;&gt; {
        use self::HogeStatus::*;
        match &lt;i32 as FromSql&lt;Integer, Pg&gt;&gt;::from_sql(bytes)? {
            0 =&gt; Ok(Waiting),
            1 =&gt; Ok(Running),
            2 =&gt; Ok(Finished),
            3 =&gt; Ok(Failed),
            4 =&gt; Ok(Canceled),
            n =&gt; Err(format!(&#34;invalid status: {}&#34;, n).into()),
        }
    }
}

impl&lt;BE, QB, BC&gt; FromSqlRow&lt;Integer, BE&gt; for HogeStatus
    where QB: QueryBuilder&lt;BE&gt;,
          BC: BindCollector&lt;BE&gt;,
          BE: Backend&lt;RawValue = [u8], QueryBuilder = QB, BindCollector = BC&gt;
{
    fn build_from_row&lt;T: Row&lt;BE&gt;&gt;(row: &amp;mut T) -&gt; Result&lt;Self, Box&lt;Error + Send + Sync&gt;&gt; {
        use self::HogeStatus::*;
        match &lt;i32 as FromSqlRow&lt;Integer, BE&gt;&gt;::build_from_row(row)? {
            0 =&gt; Ok(Waiting),
            1 =&gt; Ok(Running),
            2 =&gt; Ok(Finished),
            3 =&gt; Ok(Failed),
            4 =&gt; Ok(Canceled),
            n =&gt; Err(format!(&#34;invalid status: {}&#34;, n).into()),
        }
    }
}
```

===
# クエリ
--------

* モデルプロジェクトとは別
* 各プロジェクトのdb.rsで関数を定義
* SQLよりRsutのイテレータを意識した書き方

===
# クエリ
--------

```rust
pub fn is_hoge_finished&lt;&#39;a, Cn&gt;(conn: &amp;Cn, entry_id: i32) -&gt; Result&lt;bool, Error&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use self::schema::hoge_suites::dsl::*;
    // SELECT ... じゃなくてsourceからfileterして最後にselect
    let ret = hoge_suites
        .filter(hoge_entry_id.eq(entry_id))
        .select(status)
        // ここまでクエリビルダ
        .load::&lt;i32&gt;(conn)?
        // ここからイテレータ
        .into_iter()
        .all(|i| [HogeStatus::Finished as i32, HogeStatus::Failed as i32].contains(&amp;i));
    Ok(ret)
}

```

===
# 複雑なクエリ
-------------

* トランザクション
* join
* order by

===

# 複雑なクエリ
-------------

``` rust
pub fn pic_suite&lt;Cn&gt;(conn: &amp;Cn,
                     query: &amp;api::worker_poll::Request)
                     -&gt; Result&lt;Option&lt;(HogeEntry, HogeSuite)&gt;, Error&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use self::schema::hoge_entries::dsl::*;
    use self::schema::hoge_suites::dsl::*;
    use self::schema::hoge_suites::dsl::id;
    // transaction
    conn.transaction(|| {
        let suite = hoge_suites
             // join
            .inner_join(hoge_entries)
            .filter(status.eq(HogeStatus::Waiting as i32)
                .and(hostname.eq(&amp;query.hostname)))
            // order by
            .order(created_at.asc())
            .select((id, hoge_entry_id, hostname, status))
            .first::&lt;HogeSuite&gt;(conn)
            // NotFoundErrorをOptionにできる
            .optional()?;
        // transactionの中で普通にrustの式が書ける
        if let Some(s) = suite {
            let entry = hoge_entries.find(s.hoge_entry_id)
                .first::&lt;HogeEntry&gt;(conn)?;
            let suite =
                diesel::update(hoge_suites.find(s.id)).set(status.eq(HogeStatus::Running as i32))
                    .get_result::&lt;HogeSuite&gt;(conn)?;
            Ok(Some((entry, suite)))

        } else {
            Ok(None)
        }
    })
}
```

===

# もっと複雑なクエリ
-------------------

* 2重join
* dieselは2重joinを扱えない…

===

# もっと複雑なクエリ
-------------------


``` rust
pub fn load_all_data&lt;&#39;a, Cn&gt;(conn: &amp;Cn)
                             -&gt; Result&lt;Vec&lt;(HogeEntry, Vec&lt;((HogeSuite, HogeResult), Vec&lt;HogeProfile&gt;)&gt;)&gt;&gt;
    where Cn: Connection&lt;Backend = Pg&gt;
{
    use diesel::types::{Integer, Timestamp, VarChar, Double};
    use diesel::pg::types::sql_types::{Array, Jsonb};
    use diesel::expression::dsl::*;
    use diesel::select;

    let status = sql::&lt;Integer&gt;(&#34;s.status&#34;);
    let ret = select(sql::&lt;(
        (Integer, VarChar, VarChar, Array&lt;VarChar&gt;,Timestamp, VarChar, Integer, Jsonb),
        (Integer, Integer, VarChar, Integer),
        (Integer, Integer, VarChar, Integer, Integer, VarChar),
        (Integer, Integer, VarChar, Integer, Double))&gt;(
        &#34;
e.id, e.repo, e.committish, e.files, e.created_at, e.command, e.format, e.format_data,
s.id, s.hoge_entry_id, s.hostname, s.status,
r.id, r.hoge_suite_id, r.hoge_name, r.score, r.status, r.result,
p.id, p.hoge_result_id, p.function_name, p.score, p.percent
FROM hoge_profiles p
INNER JOIN hoge_results r on r.id = p.hoge_result_id
INNER JOIN hoge_suites s ON s.id = r.hoge_suite_id
INNER JOIN hoge_entries e ON e.id = s.hoge_entry_id&#34;))
    .filter(status.eq(HogeStatus::Finished as i32))
    .load::&lt;(HogeEntry, HogeSuite, HogeResult, HogeProfile)&gt;(conn)?;
    let mut hash = HashMap::new();
    for (e, s, r, p) in ret {
        let mut hash_entry1 = hash         .entry(e.id).or_insert((e, HashMap::new()));
        let mut hash_entry2 = hash_entry1.1.entry(r.id).or_insert(((s, r), Vec::new()));
        hash_entry2.1.push(p);
    }
    let ret = hash.into_iter().map(|(_, v)| (v.0,  v.1.into_iter().map(|(_, p)| p).collect())).collect();
    Ok(ret)
}

```

===

# テスト
-------

* ￣\＿(ツ)＿/￣

===

# まとめ
--------

* 案外普通に使えるよ
* モデルはちょっと面倒かもね
* クエリは困ったらSQL生牡蠣
* マイグレーションとかはまた今度

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>WebAssemblyとコンパイラとランタイム</title>
      <link>/slide/WebAssemblytokonpairatorantaimu/</link>
      <pubDate>Thu, 16 Feb 2017 15:46:21 +0900</pubDate>
      
      <guid>/slide/WebAssemblytokonpairatorantaimu/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# WebAssemblyとコンパイラとランタイム
----------------------
[emscripten night !! #3 - connpass](https://emsn.connpass.com/event/48100/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# 何の話
---------

* WebAssemblyをバックエンドに使う言語を作りたい
* [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml)
* 既に発表したものの補足記事的な
  + [コンパイラの人からみたWebAssembly | κeenのHappy Hacκing Blog](https://keens.github.io/slide/konpairanoninkaramitaWebAssembly/)
  + ある程度再度説明します

===
# アジェンダ
------------

* なぜWebAssembly
* コンパイラ
* コード生成
* ランタイム

===

# なぜWebAssembly

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# なぜWebAssembly
----------------

* なんかバイナリでテンション上がる
* ポータブルでコンパクトで速い
* 機能的にJSを越えるかもしれない…？
* コンパイラがブラウザで動くと言語導入のハードル下がる
  + 気軽に試せる
  + コンパイラだけでなく吐いたコードもブラウザで動かしたい

===
# WASM over LLVM
----------------

* 既存のJS環境と協調する
  + JSとの相互呼び出しとか
* **non-determinismが少ない**
* 細かいアラインメント考える必要がない
* **API安定しそう**

===

# WASM over asm.js
--------------------

* ブラウザ以外への組込みもサポート
  + Node.jsとか
  + **JITエンジンに使えそう**
* プラットフォーム
* 実行までのレイテンシが短かい
* asm.jsより速度を出しやすい設計
* テキストフォーマットで生成コードの文法エラーが怖い
* 将来機能が増えるかも

===
# WebAssemblyの現状
-------------------

* Minimum Viable Product(MVP)
* 機能を削ってとりあえず動くものを作ってる
* 今はC/C++からLLVMを通して吐けるのが目標
  + C/C++には不要でも自分の言語に欲しい機能は……
* 今後SIMDとかスレッドとかDOM APIとか増えていく

===

# コンパイラ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

===
# WASM概要
----------

* WASMには以下がある
  + 関数
    - 関数内ローカル変数
  + リニアメモリ
  + グローバル変数
  + テーブル
  + importテーブル
  + exportテーブル

===
# WASM実行モデル
--------------

* i32,i64,f32,f64のみ
* **スタックマシン**
  + 命令のオペランドや関数の引数はスタック経由で渡す
  + 1 passのコード生成が楽そう
* 無限のローカル変数が使える
  + 型がある
* 関数の引数はローカル変数経由で渡される
* コントロールフローはgotoじゃなくてstructured
  + 静的検証がしやすいらしい
  + 安全だけどコンパイラ的には…

===

# コントロールフロー
-------------------

* `loop` + `br` (名前付き)
* `block` + `br` (名前付き)
* `br_if` or `br_table`
* `if` + `else` + `end`
* `return`
* 等

===

# コントロールフロー
-------------------

* gotoがない
  + `br` はブランチじゃなくてブレイク
* gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
    + loop, block, br, br_ifを使う
* 高級言語から変換するなら `if` を使う
  + ifが2系統あることになる

===
# サンプル
---------

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===
# サンプル
---------

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (get_local 0)
    (get_local 1)
    (call 1)
    (get_local 1)
    (get_local 0)
    (i64.sub)
    (f64.convert_s/i64)
    (f64.div)
    (call 2))
  ...)
```

===
# サンプル
---------

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (call 2
      (f64.div
       (call 1 (get_local 0) (get_local 1))
       (f64.convert_s/i64
        (i64.sub
         (get_local 1)
         (get_local 0))))))
  ...)
```

===

# WebMLコンパイラ
------------

* パーサ、AST、HIR、MIR、LIR
* LIRがRTLなのでそれをWASMに変換したい
* gotoからstructured control flow…

===

```
[コード]
   | パーサ
 [AST] 型推論とか
   | AST2HIR
 [HIR] 早期最適化、K正規化、A正規化など
   | HIR2MIR
 [MIR] 諸々の最適化
   | MIL2LIR
 [LIR] シリアライズ、レジスタ割り当てなど
   | コード生成
 [WASM]
```

===

# 変数
------

* LIRはレジスタで計算する
* LIRはCFG由来の大量の変数を使う
  + レジスタ割り当ては一旦置いとく
* WASMはスタックで計算する
* どうコード生成すると最適か？

===

```
fun main: () -&gt; i64 = {
    entry@0:
        r0: i64 &lt;- 1
        r1: i32 &lt;- 0
        r2: i64 &lt;- 1
        r3: i64 &lt;- 2
        r4: i64 &lt;- 3
        r5: i64 &lt;- r3 * r4
        r6: i64 &lt;- 4
        r7: i64 &lt;- r5 + r6
        r8: i64 &lt;- r2 + r7
        r9: i64 &lt;- 1
        r10: i64 &lt;- 2
        r11: i64 &lt;- r9 + r10
        r12: i64 &lt;- 3
        r13: i64 &lt;- r11 * r12
        r14: i64 &lt;- 4
        r15: i64 &lt;- r13 + r14
        r16: i32 &lt;- 1
        jump_if_zero r16 then@1
        jump else@2
    then@1:
        r17: i64 &lt;- r8
        jump join@3
    else@2:
        r17: i64 &lt;- r15
        jump join@3
    join@3:
        r18: i64 &lt;- 1
        r19: i64 &lt;- r18 + r15
        r20: i64 &lt;- 1
        r21: i64 &lt;- call d@9(r20, )
        r22: i64 &lt;- 2
        r23: i64 &lt;- call #g37(r22, )
        r24: i64 &lt;- 1
        r25: i64 &lt;- heapalloc(16)
        [r25+0] &lt;- &lt;anonfun&gt;@11
        [r25+8] &lt;- r24
        r26: i64 &lt;- 0
        ret r26
}
```

===

# 変数割り当て
--------------

* SSAの1変数 = WASMの1ローカル変数
* スタックの効率利用を完全に無視
* 計算はLV→スタック→LVに書き戻し
* どうせスタックもLVもレジスタ扱いにしてレジスタ割り当てされるでしょ
* （測ってないけど）多分速度は変わらない

===

# CFG
-----

* コンパイラが一旦gotoを使うコントロールフローグラフを作る
* WASMにはgotoがない
* どうやったら生成出来るか？
* そもそも生成出来るの？

===

# blockと前方ジャンプ
------------

* `block` + `break` で前方ジャンプ
* 閉じ括弧の位置にジャンプ
* `block` の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  ...
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

# loopと前方ジャンプ
------------


* `loop` + `break`で後方ジャンプ
  + `loop` からの `break` はいわゆる `continue`
* 開き括弧の位置にジャンプ
* 閉じ括弧の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  ...
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===
# ジャンプのクロス
------------------

* 単一gotoは割り当て出来る
* 複数のgotoが入り組んだら？

===

# 絶対出来る
------------

* チューリング完全なら必ず書ける
  + whileとswitchでステートマシン作ればいい
* 効率的とは限らない
* 効率的なコードを吐きたい

===
# ステートマシンはつらい
-----------------------

* これをナイーブに変換すると…

```c
#include &lt;stdio.h&gt;
int main() {
  int sum = 0;
  for (int i = 1; i &lt;= 100; i++)
    sum += i;
  printf(&#34;1+...+100=%d\n&#34;, sum);
  return 0;
}
```

===

```javascript
function _main() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    var __label__ = -1;
    while(1)
        switch(__label__) {
        case -1:
            ...
            __label__ = 0;
            break;
        case 0:
            ...
            if ($4) {
              __label__ = 1;
              break;
            } else {
              __label__ = 2;
              break;
            }
        case 1:
            ...
            __label__ = 3;
            break;
        case 3:
            ...
            __label__ = 0;
            break;
        case 2:
            ...
            return 0;
        }
}
```

===
# ステートマシンはつらい
----------------------

* どうにかする必要がある
  + emscriptenは[ReLoop](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)で最適化
* なんか気に食わなかった
* そもそもステートマシンを使わずに生成したい
* 複数のgotoが入り組んだパターンを自分で考えたの紹介します。
* CFGと基本ブロックは知ってるかな？

===
# 前前
------

```
[ ]--+
 |   |
[ ]--+-+
 |   | |
[ ]&lt;-+ |
 |     |
[ ]&lt;---+
```

===
# 前前
------

```
(block
  (block
    ...
    (br 0)-+
    ...    |
    (br 1)-+-+
  )&lt;-------+ |
)&lt;-----------+
```

===
# 後後
------


```
[ ]&lt;-+
 |   |
[ ]&lt;-+-+
 |   | |
[ ]--+ |
 |     |
[ ]----+
```

===
# 後後
------

```
(loop&lt;-----+
  (loop&lt;---+-+
    ...    | |
    (br 1)-+ |
    ...      |
    (br 0)---+
  )
)
```

===
# 後前
------


```
[ ]&lt;-+
 |   |
[ ]--+-+
 |   | |
[ ]--+ |
 |     |
[ ]&lt;---+
```

===
# 後前
------

```
(block
  (loop&lt;---+
    ...    |
    (br 1)-+-+
    ...    | |
    (br 0)-+ |
  )          |
)&lt;-----------+
```

===
# 前後
------

```
[ ]--+
 |   |
[ ]&lt;-+-+
 |   | |
[ ]&lt;-+ |
 |     |
[ ]----+
```

===
# 前後
------

* 素直には出来ない…？
* 部分的にステートマーシン作る？

===
# 部分的ステートマーシン
-------------------------

```
[1]--+
 |   |
[2]&lt;-+-+
 |   | |
[3]&lt;-+ |
 |     |
[4]----+
```

===
# 部分的ステートマーシン
-------------------------

```
   [1] label = 0
    |
+-&gt;[br]-+ if label == 0
|   |   | then goto 3
|   |   | else goto 2
|   |   |
|  [2]  |
|   |   |
|  [3]&lt;-+ label = 1
|   |
+--[4]
```

===
# コード生成

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===

# フォーマット
------------

* バイナリフォーマットとテキストフォーマットがある
* バイナリ: wasm
  + コンパクト
  + intとかもパッキングする
* テキスト: wast
  + 人間可読+機械可読=S式
  + 低級にもちょっと高級にも書ける
  + 一旦アセンブラ噛まさないと動かない

===

# アセンブラ
------------

* オンメモリで生成するためにアセンブラ自作
  + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs)
  + ブラウザで動かすのに必要
  + 既存のツールは使えない
* アセンブラ自体ブラウザで動かすのでRust製
* まだ動かしてない

===

```rust
let mut mb = ModuleBuilder::new();
let f = mb.new_function(FunctionBuilder::new(funtype!((i32, i32) -&gt; i32))
    .code(|cb, args| {
        cb.constant(2)
            .get_local(args[0])
            .i32_add()
    })
    .build());
mb.export(&#34;addTwo&#34;, f);
let module = mb.build();
```

===
# スタック領域
-------------

* Cでいう`struct foo x;`みたいにエフェメラルな多ワード領域が欲しい
* WebAssemblyのローカルストレージはLVだけ
  + 最大1ワードしか保存出来ない
* 可能性
  1. 諦めてメモリに確保（場合によっては最適化で消えるかも）
  2. ワード毎に分割してLVに保存（大変だけど速そう）

===
# ランタイム

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 言語のランタイム
-----------------

* 主にはGC
* その他データのメモリ表現
  + アラインメントも
* スタック領域
* FFI
* コンパイラなのでシンボルテーブルはなし

===
# メモリ
--------

* mallocとかはない
* ページ単位のアロケーションだけ
* 自前でGCを実装することになる

===
# GC
-----

* コールスタックを遡れない
  + コールスタックをGCルートに出来ない
* メモリonlyな走査なら可能
  + ポインタを都度メモリ領域(arena)にコピーすれば良い。
  + arenaもルートになる
  + コールスタックと連動するのでスタックで管理出来る。
  + CF [Matzにっき(2013-07-31)](http://www.rubyist.net/~matz/20130731.html)
  + ただしコンパイラなので関数全部をsave/restoreで囲んだりはしない。

===
# アロケータ
------------

* どうにか書いてブラウザでリンクする必要がある
  + ブラウザにもランタイムライブラリの時代…
  + WASMはライブラリ間でメモリ共有出来る
* とりあえずRustで書く方針
  + WASMのページアロケートとかどうすればいいんだろう
  + まだ色々未定

===

# メモリ表現
------------

* 出来れば楽して64bit統一したかった
  + i32やf32を抹殺したかった
* WASM32しかないのでポインタが32bit…
* 仕方ないので64bitアラインメントでパディングする
* 空いた32bitの使い道は未定
  + 静的型付だし型タグが要らない
  + 代数的データ型のタグ？

===

# 高階関数
----------

* WASMに関数ポインタがない
* テーブルに関数を登録してインデックス参照
  + C++のvtableのための機能
  + 型も動的チェック
* ちょっと遅そう
* 気合でインライン化を頑張ろう

===

# FFI
------

* JSの関数を呼びたい
* 細かいところどうなってるんだろう
  + 例外は？JSオブジェクトは？GCは？
* 型付…
* ノープラン

===
# 雑にまとめ
-------------

* WASMはちょっと高級なので最適化コンパイラは困るよ
  + 雑なコンパイラにはむしろ嬉しい
* コード生成は努力で解決
* GCは割とつらいよ
  + 将来楽になるかも
* JS連携や将来のスレッドとかはみんなで考えよう

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>RustのちょっとやりすぎなBuilderパターン</title>
      <link>/blog/2017/02/09/rustnochottoyarisuginabuilderpata_n</link>
      <pubDate>Thu, 09 Feb 2017 23:03:45 +0900</pubDate>
      
      <guid>/blog/2017/02/09/rustnochottoyarisuginabuilderpata_n</guid>
      <description>&lt;p&gt;κeenです。Rustでちょっとやりすぎだけど使う側の自由度が高くて安全なBuilderパターンを思い付いたので紹介しますね。&lt;/p&gt;

&lt;p&gt;※2017-02-11T13:18:58Z+09:00 最下部に追記しました
&lt;/p&gt;

&lt;h1 id=&#34;目的コード&#34;&gt;目的コード&lt;/h1&gt;

&lt;p&gt;以下のような構造体のビルダーを作りたいとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-struct&#34;&gt;#[derive(Debug)]
struct Person {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;雑にやると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilder {
    id: Option&amp;lt;u32&amp;gt;,
    name: Option&amp;lt;String&amp;gt;,
    age: Option&amp;lt;u32&amp;gt;,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilder {
  pub fn new() -&amp;gt; Self { ... }
  pub fn id(self, id: u32) -&amp;gt; Self { ... }
  pub fn name(self, name: String) -&amp;gt; Self { ... }
  pub fn age(self, id: u32) -&amp;gt; Self { ... }
  pub fn address(self, address: String) -&amp;gt; Self { ... }
  pub fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // 返り値がOption型になってしまう
  pub fn build(self) -&amp;gt; Option&amp;lt;Person&amp;gt; {
    // try_opt!は標準ライブラリには存在しませんが各所で使われてるので動きは分かると思います
    Person {
       id: try_opt!(self.id),
       name: try_opt!(self.name),
       age: try_opt!(self.age),
       address: self.address,
       zipcode: self.zipcode,
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とbuildの返り値が&lt;code&gt;Option&lt;/code&gt;型になってしまい、あまりうれしくありません。
さらには例えば&lt;code&gt;id&lt;/code&gt;を2回呼んだらどうなるんだとかツッコミどころが数多くあります。&lt;/p&gt;

&lt;p&gt;ということで色々な回避策を先人達は考えてきました。&lt;/p&gt;

&lt;h1 id=&#34;不自由なコード&#34;&gt;不自由なコード&lt;/h1&gt;

&lt;p&gt;普通にやるなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilder {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilder {
  fn new(id: u32, name: String, age: String) -&amp;gt; Self { ... }
  fn address(self, address: String) -&amp;gt; Self { ... }
  fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // 返り値がOptionじゃない
  fn build(self) -&amp;gt; Person { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;Option&lt;/code&gt;でないフィールドをコンストラクタで受け取れば安全に作れますが、コンストラクタを呼ぶ時点でいくつかフィールドが揃っている必要がある、そもそも元の構造体と何が違うんだ、など色々問題があります。&lt;/p&gt;

&lt;h1 id=&#34;少しマシなコード&#34;&gt;少しマシなコード&lt;/h1&gt;

&lt;p&gt;オートマトンのようにビルダーが状態遷移するコードを使うと、1つ1つの引数をビルドしつつ安全なコードが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct PersonBuilderId;
struct PersonBuilderName{id: u32}
struct PersonBuilderAge{id: u32, name: String}
struct PersonBuilder {
    id: u32,
    name: String,
    age: u32,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}

impl PersonBuilderId {
  pub fn new() -&amp;gt; Self { ... }
  // idの次はname
  pub fn id(self, id: u32) -&amp;gt; PersonBuilderName {
    PersonBuilderName { id: id }
  }
}

impl PersonBuilderName {
  // nameの次はage
  pub name(self, name: String) -&amp;gt; PersonBuilderAge {
    PersonBuilderAge {
      id: self.id,
      name: name,
    }
  }
}
impl PersonBuilderAge {
  // ageは最後
  pub name(self, age: u32) -&amp;gt; PersonBuilder {
    PersonBuilder {
      id: self.id,
      name: self.name,
      age: age,
      address: None,
      zipcode: None,
    }
  }
}

impl PersonBuilder {
  // 気持ち悪いけど PersonBuilderIdを返す
  pub fn new -&amp;gt; PersonBuilderId { ... }
  pub fn address(self, address: String) -&amp;gt; Self { ... }
  pub fn zipcode(self, zipcode: String) -&amp;gt; Self { ... }
  // これまたOptionじゃなくなってる
  pub fn build(self) -&amp;gt; Person { ... }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは以下のように&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
  let person = PersonBuilder::new()
         .id(1)
         .name(&amp;quot;κeen&amp;quot;.to_string())
         .age(24)
         .address(&amp;quot;Tokyo&amp;quot;.to_string())
         .build();
  println!(&amp;quot;{:?}&amp;quot;, person)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と使えます(即興で書いたので試してないけど)。&lt;/p&gt;

&lt;p&gt;とりあえず使えそうな気がしますが、型レベルで状態遷移をハードコードしているのでメソッドを呼び出す順番が固定されてしまいます。
なので以下はエラーです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
  let person = PersonBuilder::new()
         // nameとidを逆順に呼び出してみる
         .name(&amp;quot;κeen&amp;quot;.to_string())
         .id(1)
         .age(24)
         .address(&amp;quot;Tokyo&amp;quot;.to_string())
         .build();
  println!(&amp;quot;{:?}&amp;quot;, person)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは単純に&lt;code&gt;struct PersonBuilderId&lt;/code&gt;、&lt;code&gt;struct PersonBuilderName{id: u32}&lt;/code&gt;、&lt;code&gt;struct PersonBuilderAge{id: u32, name: String}&lt;/code&gt;と作っていくのが面倒という話もあります。&lt;/p&gt;

&lt;p&gt;今回はそれを改善したいという話&lt;/p&gt;

&lt;h1 id=&#34;幽霊型を使ったフィールド状態&#34;&gt;幽霊型を使ったフィールド状態&lt;/h1&gt;

&lt;p&gt;今回提案するビルダー型はこれです。提案するといってもどうせ既に誰かが考えてるでしょうが。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::marker::PhantomData;
struct Empty;
struct Filled;

struct PersonBuilder&amp;lt;Id, Name, Age&amp;gt; {
    id: Option&amp;lt;u32&amp;gt;,
    id_state: PhantomData&amp;lt;Id&amp;gt;,
    name: Option&amp;lt;String&amp;gt;,
    name_state: PhantomData&amp;lt;Name&amp;gt;,
    age: Option&amp;lt;u32&amp;gt;,
    age_state: PhantomData&amp;lt;Age&amp;gt;,
    address: Option&amp;lt;String&amp;gt;,
    zipcode: Option&amp;lt;String&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/marker/struct.PhantomData.html&#34;&gt;PhantomData&lt;/a&gt;という特殊な型を使ってビルダーに余計な型を付けています。&lt;/p&gt;

&lt;p&gt;この型、最初は&lt;code&gt;Empty&lt;/code&gt;から出発します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl PersonBuilder&amp;lt;Empty, Empty, Empty&amp;gt; {
    pub fn new() -&amp;gt; Self {
        PersonBuilder {
            id: None,
            id_state: PhantomData,
            name: None,
            name_state: PhantomData,
            age: None,
            age_state: PhantomData,
            address: None,
            zipcode: None,
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてフィールドが埋められると対応する型がEmptyからFilledになります。&lt;/p&gt;

&lt;p&gt;フィールドに&lt;code&gt;Some&lt;/code&gt;が埋められるのと同時に対応する&lt;code&gt;_state&lt;/code&gt;フィールドを&lt;code&gt;Empty&lt;/code&gt;から&lt;code&gt;Filled&lt;/code&gt;にすると整合性が崩れません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Id以外、つまりNameとAgeはいじらないのでジェネリクスに
impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        PersonBuilder {
            id: Some(id),
            id_state: PhantomData,
            name: self.name,
            name_state: self.name_state,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
impl&amp;lt;Id, Age&amp;gt; PersonBuilder&amp;lt;Id, Empty, Age&amp;gt; {
    // 地味なテクニックとして、SringではなくてInto&amp;lt;String&amp;gt;で受けることでリテラルのStringとかも受け取れる。
    pub fn name&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(self, name: S) -&amp;gt; PersonBuilder&amp;lt;Id, Filled, Age&amp;gt; {
        PersonBuilder {
            id: self.id,
            id_state: self.id_state,
            name: Some(name.into()),
            name_state: PhantomData,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}

impl&amp;lt;Id, Name&amp;gt; PersonBuilder&amp;lt;Id, Name, Empty&amp;gt; {
    pub fn age(self, age: u32) -&amp;gt; PersonBuilder&amp;lt;Id, Name, Filled&amp;gt; {
        PersonBuilder {
            id: self.id,
            id_state: self.id_state,
            name: self.name,
            name_state: self.name_state,
            age: Some(age),
            age_state: PhantomData,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt;のままで構わないフィールドについては雑で構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;Id, Name, Age&amp;gt; PersonBuilder&amp;lt;Id, Name, Age&amp;gt; {
    pub fn address&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(mut self, address: S) -&amp;gt; Self {
        self.address = Some(address.into());
        self
    }

    pub fn zipcode&amp;lt;S: Into&amp;lt;String&amp;gt;&amp;gt;(mut self, zipcode: S) -&amp;gt; Self {
        self.zipcode = Some(zipcode.into());
        self
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして必須フィールド全てが満たされた時にだけ&lt;code&gt;build&lt;/code&gt;が呼べます。&lt;code&gt;unwrap&lt;/code&gt;を呼んでますが安全であることに注意して下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl PersonBuilder&amp;lt;Filled, Filled, Filled&amp;gt; {
    pub fn build(self) -&amp;gt; Person {
        Person {
            id: self.id.unwrap(),
            name: self.name.unwrap(),
            age: self.age.unwrap(),
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、呼び出しが非常に自由になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() {
    let person = PersonBuilder::new()
        .age(24)
        .id(1)
        .address(&amp;quot;Tokyo&amp;quot;)
        .name(&amp;quot;κeen&amp;quot;)
        .build();
    println!(&amp;quot;{:?}&amp;quot;, person);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メソッドは自由に組み換えられますが、必須フィールドがなかったら&lt;code&gt;build&lt;/code&gt;が呼べません（コンパイルエラー）になります。&lt;/p&gt;

&lt;p&gt;これは応用も出来て、それぞれの状態が独立しているので例えば「2つのVector合計3つ以上要素が入っていたら」、とか「R、G、BあるいはH、S、Vの3つが揃っていたら」とかオートマトンではエンコードしづらいものでも比較的楽に書けます。&lt;/p&gt;

&lt;p&gt;ということで便利なbuilderが出来ました。めでたしめでたし。といいたいところですが、ちょっとコードが冗長ですよね。マクロで生成なんかも出来るのですがあまりやりたくありません。ということで「ちょっとやりすぎな」Builderパターンでした。&lt;/p&gt;

&lt;h1 id=&#34;some-like-it-unsafe&#34;&gt;Some like it unsafe&lt;/h1&gt;

&lt;p&gt;上のコード、実はもうちょっと短く書けます。ただし&lt;code&gt;unsafe&lt;/code&gt;な機能を使いますが。&lt;/p&gt;

&lt;p&gt;こう書いていたものが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        PersonBuilder {
            id: Some(id),
            id_state: PhantomData,
            name: self.name,
            name_state: self.name_state,
            age: self.age,
            age_state: self.age_state,
            address: self.address,
            zipcode: self.zipcode,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/mem/fn.transmute.html&#34;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;を使うことで2行になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::mem::transmute;

impl&amp;lt;Name, Age&amp;gt; PersonBuilder&amp;lt;Empty, Name, Age&amp;gt; {
    pub fn id(mut self, id: u32) -&amp;gt; PersonBuilder&amp;lt;Filled, Name, Age&amp;gt; {
        self.id = Some(id);
        unsafe { transmute(self) }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すごいですね。
しかし、案外しょっちゅうtransmuteはミスなどで間違った変換をしてしまう（上記で言えばidフィールドを更新したのにname_stateの型を変更してしまう）上に型検査で弾けないので個人的にはあまりおすすめ出来ません。
これも「ちょっとやりすぎ」なTipsでした。&lt;/p&gt;

&lt;h1 id=&#34;2017-02-11t13-18-58z-09-00-追記&#34;&gt;2017-02-11T13:18:58Z+09:00 追記&lt;/h1&gt;

&lt;p&gt;qnighyさんからもっと便利な方法の提案がありました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;こう &lt;a href=&#34;https://t.co/undNgEM2IQ&#34;&gt;https://t.co/undNgEM2IQ&lt;/a&gt; やったらunwrapしなくてすみそう？ / “RustのちょっとやりすぎなBuilderパターン | κeenのHappy Hacκing Blog” &lt;a href=&#34;https://t.co/ogDOpYifjh&#34;&gt;https://t.co/ogDOpYifjh&lt;/a&gt;&lt;/p&gt;&amp;mdash; Masaki⊣Hara (@qnighy) &lt;a href=&#34;https://twitter.com/qnighy/status/830053476096843776&#34;&gt;2017年2月10日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;実際のコードはこちら。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/qnighy/e7a833eebd57ef778eaff3a8ab3649d7.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;transmuteを使ったサボった実装は出来なくなるけどそもそも余計なフィールドを使う必要がなくなるので手軽ですね。&lt;/p&gt;

&lt;p&gt;qnighyさんありがとうございました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Deprecating CIM</title>
      <link>/blog/2017/01/29/deprecating_cim</link>
      <pubDate>Sun, 29 Jan 2017 22:18:24 +0900</pubDate>
      
      <guid>/blog/2017/01/29/deprecating_cim</guid>
      <description>&lt;p&gt;I&amp;rsquo;m κeen. I have a sad news, I&amp;rsquo;ll stop the development of &lt;a href=&#34;https://github.com/KeenS/CIM&#34;&gt;CIM&lt;/a&gt; and no more updates for new lisp impls will be provided.

It has been months from when I stopped developping CIM and only providing updates for new lisp impl versions.
From that point, CIM is a half-dead product. I know there are still someone using CIM though, so I kept updating.
For present CIM users, I recomend to migrate to &lt;a href=&#34;https://github.com/roswell/roswell&#34;&gt;roswell&lt;/a&gt;, also a lisp installer and manager, which is well-maintained.&lt;/p&gt;

&lt;p&gt;CIM has been developed in my studenthood for my practice in shell scripts. This is my first OSS.
The reason why I wrote CIM in shell script other than for practice is that shell scripts are the most portable and available script language on Unix-like systems.
The original purpose of writing a new manager is to provide a consistent way of launching CLs from CLI.
To realize that, managing lisp impls, including installing is needed so CIM has started to manage impls.
At some point, CIM was used such products like &lt;a href=&#34;https://github.com/luismbo/cl-travis&#34;&gt;cl-travis&lt;/a&gt;.
But CIM lacked flexibility of development as it is written in ugly shell script, and lacked Windows support.
As I got a job and got interests other than lisp such as Rust, I have no more time to spend for maintaining CIM.&lt;/p&gt;

&lt;p&gt;Thus &lt;a href=&#34;https://github.com/snmsts&#34;&gt;@snmsts&lt;/a&gt;, the author of roswell, started to develop roswell to support Windows.
Roswell is written mainly in Lisp though booting from C, so many of Lispers may be able to hack it.
Roswell is well-maintained because stmsts is, unlike me, a hobby Lisper, professional lisper and he uses roswell in daily work.
Besides roswell is well-maintained, roswell is more feature-rich than CIM.
It searchs for new lisp versions for itself so there is no need to update manager itself to update your local lisp impls.
It is distributed from package managers such like homebrew and AUR so you don&amp;rsquo;t need to care about updating it.
Using &lt;code&gt;dump&lt;/code&gt; feature of roswell, you can create an executable binary from a lisp script in a command.
And so on. There are many reasons to use roswell even if CIM would be kept maintained.&lt;/p&gt;

&lt;p&gt;Anyway I wish CIM users to keep using lisp via roswell. Thank you for staying with me for a long time.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>コンパイラの人からみたWebAssembly</title>
      <link>/slide/konpairanoninkaramitaWebAssembly/</link>
      <pubDate>Sun, 22 Jan 2017 13:35:46 +0900</pubDate>
      
      <guid>/slide/konpairanoninkaramitaWebAssembly/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n===\n&#34;
    data-vertical=&#34;\n---\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# コンパイラの人からみたWebAssembly
----------------------
[コンパイラ勉強会 - connpass](https://connpass.com/event/46850/)

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# About Me
---------
![κeenのアイコン](/images/kappa.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; width=&#34;20%&#34; --&gt;

 * κeen
 * [@blackenedgold](https://twitter.com/blackenedgold)
 * Github: [KeenS](https://github.com/KeenS)
 * [Idein Inc.](https://idein.jp/)のエンジニア
 * Lisp, ML, Rust, Shell Scriptあたりを書きます

===
# アジェンダ
------------

* WebAssemblyの概要
* 具体的な話
* WebAssembly吐こうとした話

===

# WebAssemblyの概要

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===

# JavaScript
-------------

* ブラウザ上で動くスクリプト言語
* 動的型付
* 高級
* GCとかある
* 今までブラウザで動く唯一の言語だった
* 遅い
  + 各ブラウザJITなどで補強

===

# [asm.js](http://asmjs.org/)
------------

* プラウザ上で動く言語
* 低級
* GCなし
* JSのサブセット
  + asm.jsをサポートしないプラウザでも動かせる
* コンパイラから生成されることを想定
  + emscriptenなど

===

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===
# asm.jsの問題点
---------------

* JS互換文法なため嵩張る
* パースも遅い
* そもそもコンパイラが吐くならバイナリでも良いのでは？

===

# WebAssembly
--------------

* ブラウザ上で動く言語
  + 仮想機械命令？
* 低級
* バイナリフォーマット
  + ロード、パース時間が短かい
  + パース20倍くらい速いらしい
* wasm32とwasm64がある
* セマンティクスは（今のところ）ams.jsをほぼ踏襲
  + 実行エンジンは既存のものを使える
* 将来SIMD、スレッドなどの拡張が入る

===

# WASMのゴール
--------------------

* ポータブルでコンパクトで速い
* 仕様策定と実装をインクリメンタルにやっていく
  + 今はとりあえずC/C++をターゲットに
* 既存のJS環境と協調する
  + JSとの相互呼び出しとか
* ブラウザ以外への組込みもサポート
  + Node.jsとか
* プラットフォームになる
  + ツール類のサポートとか

===

# なぜWebAssembly?
------------------

* 実行までのレイテンシが短かい
* asm.jsより速度を出しやすい設計
* クライアントヘビーにしやすい？
* **JSを補完する存在**
* non-determinismが少ない
* LLVM IRと比べてデコードが速くてコンパクト
* (**code generator IR** vs optimization IR)
* 余計なことをしない
  + fast mathとかはない
  + 既に最適化されたコードが吐かれる前提

===
# WebAssemblyの現状
-------------------

* Minimum Viable Product(MVP)
* 機能を削ってとりあえず動くものを作ってる
* 今はC/C++からLLVMを通して吐けるのが目標
* 今後SIMDとかスレッドとかDOM APIとか増えていく
* ChromeとFirefoxでオプトインで使える
  + そろそろFirefoxで普通に動く

===

# 具体的な話
&lt;!-- .slide: class=&#34;center&#34; --&gt;

===

# セマンティクス
---------------

* https://github.com/WebAssembly/spec
* 形式的定義されている
* 実行以外にも静的バリデーションもある
* 1ファイル1モジュール
  + JSのモジュールと同じ概念

===
# 実行モデル
--------------

* i32,i64,f32,f64のみ
  + bitエンコーディングは指定
* スタックマシン
  + 命令のオペランドや関数の引数はスタック経由で渡す
  + バイナリがコンパクト+雑にコンパイルしても速い
* 無限のローカル変数が使える
  + 型がある
* 関数の引数はローカル変数経由で渡される
* コントロールフローはgotoじゃなくてstructured
  + 静的検証がしやすい

===

# wasm、wast
------------

* バイナリフォーマットだけでは人間が読めない
* テキストフォーマットも欲しい
* バイナリ: wasm
  + コンパクト
  + intとかもパッキングする
* テキスト: wast
  + 人間可読+機械可読=S式
  + 低級にもちょっと高級にも書ける

===

``` javascript
function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
...
```

===

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (get_local 0)
    (get_local 1)
    (call 1)
    (get_local 1)
    (get_local 0)
    (i64.sub)
    (f64.convert_s/i64)
    (f64.div)
    (call 2))
  ...)
```

===

```wasm
(module
  (type (;0;) (func (param i64 i64) (result f64)))
  (type (;1;) (func (param i64 i64) (result f64)))
  (type (;2;) (func (param f64) (result f64)))
  (func (;0;) (type 0) (param i64 i64) (result f64)
    (call 2
      (f64.div
       (call 1 (get_local 0) (get_local 1))
       (f64.convert_s/i64
        (i64.sub
         (get_local 1)
         (get_local 0))))))
  ...)
```

===

```
0000000: 0061 736d                                 ; WASM_BINARY_MAGIC
0000004: 0d00 0000                                 ; WASM_BINARY_VERSION
; section &#34;TYPE&#34; (1)
0000008: 01                                        ; section code
0000009: 00                                        ; section size (guess)
000000a: 03                                        ; num types
; type 0
000000b: 60                                        ; func
000000c: 02                                        ; num params
000000d: 7e                                        ; i64
000000e: 7e                                        ; i64
000000f: 01                                        ; num results
0000010: 7c                                        ; f64
; type 1
0000011: 60                                        ; func
0000012: 02                                        ; num params
0000013: 7e                                        ; i64
0000014: 7e                                        ; i64
0000015: 01                                        ; num results
0000016: 7c                                        ; f64
; type 2
0000017: 60                                        ; func
0000018: 01                                        ; num params
0000019: 7c                                        ; f64
000001a: 01                                        ; num results
000001b: 7c                                        ; f64
0000009: 12                                        ; FIXUP section size
; section &#34;FUNCTION&#34; (3)
000001c: 03                                        ; section code
000001d: 00                                        ; section size (guess)
000001e: 03                                        ; num functions
000001f: 00                                        ; function 0 signature index
0000020: 01                                        ; function 1 signature index
0000021: 02                                        ; function 2 signature index
000001d: 04                                        ; FIXUP section size
; section &#34;CODE&#34; (10)
000002e: 0a                                        ; section code
000002f: 00                                        ; section size (guess)
0000030: 03                                        ; num functions
; function body 0
0000031: 00                                        ; func body size (guess)
0000032: 00                                        ; local decl count
0000033: 20                                        ; get_local
0000034: 00                                        ; local index
0000035: 20                                        ; get_local
0000036: 01                                        ; local index
0000037: 10                                        ; call
0000038: 01                                        ; func index
0000039: 20                                        ; get_local
000003a: 01                                        ; local index
000003b: 20                                        ; get_local
000003c: 00                                        ; local index
000003d: 7d                                        ; i64.sub
000003e: b9                                        ; f64.convert_s/i64
000003f: a3                                        ; f64.div
0000040: 10                                        ; call
0000041: 02                                        ; func index
0000042: 0b                                        ; end
0000031: 11                                        ; FIXUP func body size
...
```

===

# JS API
---------

``` javascript
var importObj = {js: {
    import1: () =&gt; console.log(&#34;hello,&#34;),
    import2: () =&gt; console.log(&#34;world!&#34;)
}};
fetch(&#39;demo.wasm&#39;).then(response =&gt;
    response.arrayBuffer()
).then(buffer =&gt;
    WebAssembly.instantiate(buffer, importObj)
).then(({module, instance}) =&gt;
    instance.exports.f()
```

===

# メモリ
------------

* メモリアドレスが0から始まって飛びのない **リニアメモリ**
  + 命令で伸び縮み出来る
  + 将来複数のリニアメモリとか出てくるかも
* メモリサイズは32bit(wasm32)か64bit(wasm64)が選べる
  + 現状はwasm32のみ
  + 1つのモジュールでメモリ4GiBバイトも使わないから普通は32bitで十分
* アドレッシングは `アドレス+オフセット`
* アラインメントは必須ではない（した方が速い）
* コード列のメモリは見えない
* スタックスキャンも出来ない

===

# 例外とか
----------

* Trap -- WebAssemblyのインスタンスが異常終了する
  + 例えばメモリの範囲外アクセスとか
* スタックオーバーフロー
  + オーバーフローするとインスタンスが異常終了する
  + 処理系/環境毎にスタック長は違う
    - non-determinism

===

# テーブル
----------

* 要素の配列的なもの
  + 整数インデックスでアクセス出来る
* 今のところ関数を入れてindrect callするため
* 将来的にはOSのハンドラとかGCの参照とか

===

# ローカル変数
--------------

* 無限にある型付きストレージ
* 0 初期化
* 関数の引数もローカル変数に入る

===

# グローバル変数
---------------

* 型付きストレージ
* 可変/不変がある
* 不変Globにsetするとvalidationエラー
* リニアメモリとは違うメモリ領域

===
# import / export
-----------------

* 他のモジュールから色々インポート出来る
* 関数
* テーブル
* グローバル変数
* リニアメモリ
* 勿論exportも

===
# 一旦まとめ
------------

* WASMは1ファイル1モジュール
* WASMには以下がある
  + 関数
    - 関数内ローカル変数
  + リニアメモリ
  + グローバル変数
  + テーブル
  + importテーブル
  + exportテーブル

===

# 命令の話
----------

* コントロールフロー
* Call
* パラメトリック
* 変数アクセス
* メモリ関連
* 定数
* 比較
* 数値
* 変換
* 再解釈

===

# コントロールフロー
-------------------

* `loop` + `br` (名前付き)
* `block` + `br` (名前付き)
* `br_if` or `br_table`
* `if` + `else` + `end`
* `return`
* 等

===

# コントロールフロー
-------------------

* gotoがない
  + `br` はブランチじゃなくてブレイク
* gotoからstructuredに[変換出来る](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
    + loop, block, br, br_ifを使う
* 高級言語から変換するなら `if` を使う
  + ifが2系統あることになる

===

# Call
------

* `call`
* `call_indirect`
  + 関数テーブルを使った呼び出し
  + ダイナミックな関数ディスパッチに

===

# パラメトリック
------

* `drop`
* `select`
  + 三項演算子相当


===

# 変数アクセス
--------------

* `get/set_local`
* `get/set_global`
* `tee_local`
  + スタックに値を残しつつset

===

# メモリ関連
------------

* `{i,f}{32,64}.load{,8,16,32,64}{,_s,_u}`
* `{i,f}{32,64}.store{,8,16,32}`
* `current_memory`
* `grow_memory`
  + メモリを増やす命令もある

===
# 定数
------

* `{i,f}{32,64}.const`

===
# 比較
-------

* 各種 `eq`, `eqz`, `ne`,`lt`, `le`, `gt`, `ge`

===

# 数値
-------

* 四則(`i32.add`とか)
* 論理(`i64.popcnt`とか)
* 丸め,最{大,小}(`f32.ceil`とか)
* ルート(`f64.sqrt`とか)

===

# 変換
------

* `f32.convert_s/i32`とか
* `i32.wrap/i64`とか

===

# 再解釈
--------

* `i32.reinterpret/f32`とか
* ビットキャスト
* ビットエンコーディングが定まってるのでwell-defined

===
# WASM吐こうとした話

&lt;!-- .slide: class=&#34;center&#34; --&gt;
===
# 作ったやつ
-------------

* なんかコンパイラ作ろうと思い立った
* [KeenS/webml: An ML like toy language compiler](https://github.com/KeenS/webml)
* とりあえずSMLのサブセット
* Rust製
* 未完成
  + 正月気抜いてたら進捗ダメでした

===
# やりたかったこと
------------------

* ブラウザで動くコンパイラ作ってみたい
  + Rustはemscripten通せる
* WebAssembly面白そう
* SML処理系作りたかった
* 最適化書く練習

===
# 中身
------------

* パーサ、AST, HIR, MIR, LIR
* LIRがレジスタマシンなのでそれをWASMに変換したい
* オンメモリで生成するためにアセンブラ自作
  + [KeenS/WebAssembler-rs: An in memory wasm assembler for Rust](https://github.com/KeenS/WebAssembler-rs)
  + ブラウザで動かすのに必要
* 最適化はまだ

===
# コード生成
-----------

* (ほぼ)SSAの1変数 = 1ローカル変数
  + どうせエンジン側でレジスタ割り当てするでしょ
* スタックはほぼ使わない
* gotoを構造化制御フローにする
  +  一応出来る
  + [Reloop](https://github.com/kripken/emscripten/blob/master/docs/paper.pdf)
  + 何言ってるのかよく分からない
  + ステートマシンは勿論可能
* →自分で考えた
* なんかつらいので詳解します
* みんな基本ブロックとCFGは分かるかな？

===
# blockと前方ジャンプ
------------

* `block` + `break` で前方ジャンプ
* 閉じ括弧の位置にジャンプ
* `block` の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;block&lt;/span&gt;
  ...
  ...
  ...
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...     |
  )&lt;------+
&lt;/code&gt;
&lt;/pre&gt;

===

# loopと前方ジャンプ
------------


* `loop` + `break`で後方ジャンプ
  + `loop` からの `break` はいわゆる `continue`
* 開き括弧の位置にジャンプ
* 閉じ括弧の位置は自由

===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===

&lt;pre&gt;
&lt;code&gt;
(&lt;span class=&#39;hljs-keyword&#39;&gt;loop&lt;/span&gt;&lt;----+
  ...     |
  (&lt;span class=&#39;hljs-keyword&#39;&gt;br&lt;/span&gt; 0)--+
  ...
  ...
  ...
  )
&lt;/code&gt;
&lt;/pre&gt;


===
# ジャンプのクロス
------------------

* 単一gotoは割り当て出来る
* 複数のgotoが入り組んだら？

===
# 前前
------

```
   [ ]--+
    |   |
+--[ ]  |
|   |   |
|  [ ]&lt;-+
|   |
+-&gt;[ ]
```

===
# 前前
------

```
(block
  (block
    ...
    (br 0)-+
    ...    |
    (br 1)-+-+
  )&lt;-------+ |
)&lt;-----------+
```

===
# 後後
------


```
   [ ]&lt;-+
    |   |
+-&gt;[ ]  |
|   |   |
|  [ ]--+
|   |
+--[ ]
```

===
# 後後
------

```
(loop&lt;-----+
  (loop&lt;---+-+
    ...    | |
    (br 1)-+ |
    ...      |
    (br 0)---+
  )
)
```

===
# 後前
------


```
   [ ]&lt;-+
    |   |
+--[ ]  |
|   |   |
|  [ ]--+
|   |
+-&gt;[ ]
```

===
# 後前
------

```
(block
  (loop&lt;---+
    ...    |
    (br 1)-+-+
    ...    | |
    (br 0)-+ |
  )          |
)&lt;-----------+
```

===
# 前後
------

```
   [ ]--+
    |   |
+-&gt;[ ]  |
|   |   |
|  [ ]&lt;-+
|   |
+--[ ]
```

===
# 前後
------

* 出来ない…？
* 部分的にステートマーシン作る？
* ブロック組み換えたら出来る…？
* emscriptenはステートマシンっぽい？
* どうすればいいか不明
* もはやCPS変換して全部Callにする？
  + Compiling With Continuations!!!

===
# アルゴリズム
--------------

1. loopを良い感じに割り当てる
  + 最初はジャンプ位置と一番最後のgotoで作って、境界がクロスしないようにendを伸ばす
2. blockを外側のloopめいっぱい使って割り当てる
  + loopと同じく最小に割り当てて、blockをloopまで伸ばす

===
# ランタイム
------------

* スタック走査出来ない
* GC書けないのでは？？？
* 今のところターゲットはC/C++なので問題ない
* 将来はGC Integration入るかも

===
# 現状の解
----------

1. メモリの自動管理を諦める
2. リージョン推論や線形型で静的管理する
3. スタックを使わないコードにする
  + Compiling With Continuations!!!

===
# まとめ
--------

* ブラウザでアセンブリっぽいコードが動くよ
* バイナリはコンパクトだよ
* コントロールフロー難しいよ
* ランタイム難しいよ
* Compiling With Continuations

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Sun, 22 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>

&lt;h2 id=&#34;me&#34;&gt;Me&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2011-04 - 2013-03 東京大学理科I類&lt;/li&gt;
&lt;li&gt;2013-04 - 2015-03 東京大学理学部数学科(中退)&lt;/li&gt;
&lt;li&gt;2015-04 - 2016-12 サイバーエージェント(エンジニア)&lt;/li&gt;
&lt;li&gt;2017-01 - 現在    Idein Inc. (エンジニア)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;activities&#34;&gt;Activities&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014-06 - 2017-01 &lt;a href=&#34;http://shibuya.lisp-users.org/&#34;&gt;Shibuya.lisp&lt;/a&gt;の運営&lt;/li&gt;
&lt;li&gt;2016-02 - 現在    &lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/&#34;&gt;Rustドキュメント翻訳プロジェクト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2013 &lt;a href=&#34;http://isucon.net&#34;&gt;ISUCON3&lt;/a&gt; 学生賞&lt;/li&gt;
&lt;li&gt;2014 &lt;a href=&#34;http://isucon.net&#34;&gt;ISUCON4&lt;/a&gt; 学生賞&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その他いくつかのOSSの開発者/コミッタ/コントリビュータ&lt;/p&gt;

&lt;h2 id=&#34;sns-accounts&#34;&gt;SNS accounts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Twitter: &lt;a href=&#34;http://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub: &lt;a href=&#34;https://github.com/KeenS&#34;&gt;KeenS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;COOKPAD: &lt;a href=&#34;http://cookpad.com/kitchen/3303629&#34;&gt;κeen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Qiita: &lt;a href=&#34;https://qiita.com/blackenedgold&#34;&gt;blackenedgold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SlideShare: &lt;a href=&#34;http://www.slideshare.net/blackenedgold&#34;&gt;blackenedgold&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;main-interests&#34;&gt;Main Interests&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Emacs&lt;/li&gt;
&lt;li&gt;Lisp&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;ML (Meta Language)&lt;/li&gt;
&lt;li&gt;言語処理系(主にインタプリタ)

&lt;ul&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;最適化&lt;/li&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;λ計算&lt;/li&gt;
&lt;li&gt;継続&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;li&gt;システムプログラミング&lt;/li&gt;
&lt;li&gt;数学基礎論&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rustのモジュールの使い方</title>
      <link>/blog/2017/01/15/rustnomoju_runokirikata</link>
      <pubDate>Sun, 15 Jan 2017 20:52:14 +0900</pubDate>
      
      <guid>/blog/2017/01/15/rustnomoju_runokirikata</guid>
      <description>&lt;p&gt;κeenです。たまにRustのモジュールが分かりづらいとの声を聞くので解説しますね。&lt;/p&gt;

&lt;p&gt;
とりあえずサンプルプロジェクトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo new module
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;エラいのは-lib-rs-と-main-rs&#34;&gt;エラいのは &lt;code&gt;lib.rs&lt;/code&gt; と &lt;code&gt;main.rs&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;モジュールの話をする前にクレートの話をしないといけません。
クレートはRustのプログラムの一番大きな単位です。
大きく分けてライブラリを作るlibクレートと実行可能ファイルを作るbinクレートがあります。&lt;/p&gt;

&lt;p&gt;libクレートならば&lt;code&gt;lib.rs&lt;/code&gt;が、binクレートならば&lt;code&gt;main.rs&lt;/code&gt;がルートにあたるファイルです。ここから辿れるモジュールが全てです。プロジェクトにファイルが存在していてもこれらから辿れなかったらコンパイルされません。&lt;/p&gt;

&lt;h1 id=&#34;モジュールの作り方は3種類&#34;&gt;モジュールの作り方は3種類&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;ファイルの中にインラインで作る&lt;/li&gt;
&lt;li&gt;1ファイルで作る&lt;/li&gt;
&lt;li&gt;1ディレクトリで作る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;のやり方があります。 1.はそんなに使われなくて、説明のために1ファイルにまとめたい時や、可視性でアレコレする時のテクニックなんかに使われます。&lt;/p&gt;

&lt;p&gt;2.と3.の境界はサブモジュールを持つかどうかです。&lt;/p&gt;

&lt;p&gt;2.のファイルで作る時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように作っておいて、lib.rsの中を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod new_module;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;mod&lt;/code&gt;で参照してあげれば使えます。&lt;/p&gt;

&lt;p&gt;3.のディレクトリの時もそんなに変わらなくて、&lt;code&gt;lib.rs&lt;/code&gt;は変わらず、ファイルを&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/new_module
src/new_module/mod.rs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにしてあげます。&lt;code&gt;mod.rs&lt;/code&gt;の名前はこれでないといけません。丁度サブモジュールの&lt;code&gt;new_module&lt;/code&gt;にとっての&lt;code&gt;lib.rs&lt;/code&gt;のような存在が&lt;code&gt;mod.rs&lt;/code&gt;な訳です。&lt;/p&gt;

&lt;h1 id=&#34;兄弟モジュール同士の可視性&#34;&gt;兄弟モジュール同士の可視性&lt;/h1&gt;

&lt;h2 id=&#34;モジュールの身分&#34;&gt;モジュールの身分&lt;/h2&gt;

&lt;p&gt;さて、次のように2つのモジュールを作ってみましょう。lib.rsには&lt;code&gt;module_a&lt;/code&gt;のみ&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;module_a.rs&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo build
   Compiling module v0.1.0 (file:///home/kim/Rust/module)
error[E0432]: unresolved import `module_a`
 --&amp;gt; src/lib.rs:1:5
  |
1 | use module_a;
  |     ^^^^^^^^ no `module_a` in the root

error: aborting due to previous error

error: Could not compile `module`.

To learn more, run the command again with --verbose.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と怒られます。一番エラいのは&lt;code&gt;lib.rs&lt;/code&gt;ですから、身分の低い &lt;code&gt;module_a&lt;/code&gt;では&lt;code&gt;mod&lt;/code&gt;宣言出来ません。&lt;/p&gt;

&lt;h2 id=&#34;君の名は&#34;&gt;君の名は&lt;/h2&gt;

&lt;p&gt;同じ設定で、&lt;code&gt;lib.rs&lt;/code&gt;に&lt;code&gt;module_a&lt;/code&gt;と&lt;code&gt;module_b&lt;/code&gt;両方を&lt;code&gt;mod&lt;/code&gt;宣言しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/module_a.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時、&lt;code&gt;module_b&lt;/code&gt;が&lt;code&gt;lib.rs&lt;/code&gt;から見た時と&lt;code&gt;module_a.rs&lt;/code&gt;から見た時で名前が変わります。&lt;/p&gt;

&lt;p&gt;lib.rsから見た時は、以下の3つが使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use self::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;self&lt;/code&gt;というのは予約語で、ディレクトリでいうところの&lt;code&gt;.&lt;/code&gt;に相当します。&lt;/p&gt;

&lt;p&gt;module_a.rsからは同じく3つが使えますが、相対パスが変わります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;super&lt;/code&gt;も予約語で、&lt;code&gt;..&lt;/code&gt;に相当します。
ファイルが同じディレクトリにいるので分かりづらいですが、libが1つ上の階層で、その下にmodule_aとmodule_bがぶら下がってる感じですね。&lt;/p&gt;

&lt;h1 id=&#34;おじさんと隠し子&#34;&gt;おじさんと隠し子&lt;/h1&gt;

&lt;p&gt;次のように、サブモジュールを作ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$src
src/lib.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、この時&lt;code&gt;sumbmodule&lt;/code&gt;から見た&lt;code&gt;module_b&lt;/code&gt;の名前はどうなるでしょうか。もうお分かりかと思いますが、以下の3つです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a;     // 絶対パス
use module_a;       // 省略絶対パス
use super::super::module_a; // 相対パス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃ、逆に&lt;code&gt;module_b&lt;/code&gt;から見た&lt;code&gt;submodule&lt;/code&gt;はどうなるでしょうか。実は、&lt;code&gt;module_b&lt;/code&gt;から&lt;code&gt;submodule&lt;/code&gt;は見えません（lib.rsからも見えません）。&lt;code&gt;module_a&lt;/code&gt;1つで所帯を持っているので子である&lt;code&gt;submodule&lt;/code&gt;を外に出すかは&lt;code&gt;module_a&lt;/code&gt;の一存で決まります。今回は隠し子にしている訳ですね。いくら兄弟モジュールとはいえ家庭にまでは入り込めないのです。&lt;/p&gt;

&lt;p&gt;子供をちゃんと公開するには&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていたモジュール宣言を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてあげればOKです。そうすると&lt;code&gt;module_b&lt;/code&gt;からも見えて、以下の3種類で参照出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ::module_a::submodule;
use module_a::submodule;
use super::module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;木箱の外から&#34;&gt;木箱の外から&lt;/h1&gt;

&lt;p&gt;さて、今までは1クレート内での話でした。クレートの外から見るとどうなるでしょうか。&lt;/p&gt;

&lt;p&gt;新たに&lt;code&gt;main.rs&lt;/code&gt;を追加しましょう。先程 &lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;がエラいと話しましたが、どちらも別々のクレートを作るので&lt;code&gt;main.rs&lt;/code&gt;は完全にクレートの外です。&lt;/p&gt;

&lt;p&gt;こんな感じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find src
src
src/lib.rs
src/main.rs
src/module_a
src/module_a/mod.rs
src/module_a/submodule.rs
src/module_b.rs
$ cat src/lib.rs
mod module_a;
mod module_b;
$ cat src/module_a/mod.rs
pub mod submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、外部のクレートを参照するには&lt;code&gt;extern crate&lt;/code&gt;を書く必要があります。あとまあ、binクレートなので&lt;code&gt;main&lt;/code&gt;関数も必要ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.rs
extern carte module;
fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、&lt;code&gt;module_b&lt;/code&gt;はどういう名前で見えるでしょうか。見えません。一番エラい&lt;code&gt;lib.rs&lt;/code&gt;が&lt;code&gt;module_b&lt;/code&gt;を&lt;code&gt;pub&lt;/code&gt;にしていないのでクレートの外からは見えなくなっています。見たければ、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにします。&lt;/p&gt;

&lt;p&gt;さて、これでmain.rsからどのように見えるかというと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use ::module::module_b;
use module::module_b;
use self::module::module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように気持的にルート直下にクレートがモジュールとして配置されたように見えます。&lt;/p&gt;

&lt;h1 id=&#34;家出&#34;&gt;家出&lt;/h1&gt;

&lt;p&gt;さて、同じように&lt;code&gt;lib.rs&lt;/code&gt;で&lt;code&gt;module_a&lt;/code&gt;を&lt;code&gt;pub mod&lt;/code&gt;すれば&lt;code&gt;module::module_a::submodule&lt;/code&gt;も参照出来るようになります。ところで、例えば&lt;code&gt;module_a&lt;/code&gt;は外に出さずに&lt;code&gt;submodule&lt;/code&gt;だけを公開したい時にはどうしたらいいでしょうか。そんなケースあるのかと疑問に思うかもしれませんが、あります。同じクレートであっても&lt;code&gt;pub&lt;/code&gt;にしないとサブモジュールにアクセス出来ないことを思い出して下さい。そうすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub mod submodule;
pub mod internal_submodule_a;
pub mod internal_submodule_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなケースが発生するのは想像出来ると思います。そういう時は、&lt;code&gt;lib.rs&lt;/code&gt;側でどうにかいじれます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていると思いますが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、&lt;code&gt;pub use&lt;/code&gt; を加えてあげることで&lt;code&gt;module_a&lt;/code&gt;の下から出すことが出来ます。&lt;/p&gt;

&lt;p&gt;これを&lt;code&gt;main.rs&lt;/code&gt;から使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::submodule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように名字の&lt;code&gt;module_a&lt;/code&gt;が取れます。&lt;/p&gt;

&lt;p&gt;さらに踏み込めば、&lt;code&gt;use&lt;/code&gt;は&lt;code&gt;as&lt;/code&gt;を使ってリネーム出来るので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;$ cat src/lib.rs
mod module_a;
pub mod module_b;

pub use module_a::submodule as module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにリネーム&lt;code&gt;use&lt;/code&gt;してあげれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use module::module_c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように参照することも出来ます。完全に籍を外れて名前の上では別人ですね。&lt;/p&gt;

&lt;p&gt;実装する時の都合とAPIとして公開する時の都合が違うので公開用にいじれる作りになってるんですね。&lt;/p&gt;

&lt;h1 id=&#34;lib-rsとmain-rs&#34;&gt;lib.rsとmain.rs&lt;/h1&gt;

&lt;p&gt;上では&lt;code&gt;lib.rs&lt;/code&gt;を使って説明しましたが、&lt;code&gt;main.rs&lt;/code&gt;でも同じことが出来ます。&lt;/p&gt;

&lt;p&gt;さて、ここからはスタイルの話ですが、私がRustを書く時は&lt;code&gt;main.rs&lt;/code&gt;の中に&lt;code&gt;mod&lt;/code&gt;を書くことはないです。必ず&lt;code&gt;lib.rs&lt;/code&gt;を作って、そこでライブラリとしてまとめてから&lt;code&gt;main.rs&lt;/code&gt;で使います。「アプリケーションはアプリケーションを記述するための巨大なDSLとそれを使った小さな実装からなる」という思想ですね。明示的に境界を作ることで自然とAPIを設計出来るのでコードが整理しやすくなります。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib.rs&lt;/code&gt;と&lt;code&gt;main.rs&lt;/code&gt;が一番エラい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mod&lt;/code&gt; で「モジュールがある」宣言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub mod&lt;/code&gt; で加えて上位のモジュールにも公開&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt;と&lt;code&gt;super&lt;/code&gt;の予約語&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pub use&lt;/code&gt; で改名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;力尽きてテストのためのモジュールの話が出来なかったので&lt;a href=&#34;https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/testing.html#tests-%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB&#34;&gt;ドキュメント&lt;/a&gt;を読んでみて下さい。&lt;/p&gt;

&lt;p&gt;因みに&lt;a href=&#34;https://github.com/BurntSushi/fst/blob/master/src/lib.rs&#34;&gt;これ&lt;/a&gt;のようにテクニックが詰まった&lt;code&gt;lib.rs&lt;/code&gt;ファイルなんかも存在するので参考にどうぞ。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>頑張らないLinuxデスクトップ環境</title>
      <link>/blog/2017/01/10/linuxdesukutoppukankyou</link>
      <pubDate>Tue, 10 Jan 2017 22:07:31 +0900</pubDate>
      
      <guid>/blog/2017/01/10/linuxdesukutoppukankyou</guid>
      <description>&lt;p&gt;κeenです。みんなカスタマイズしてLinux使っているようなのであまりカスタマイズしてない私のものも紹介しますね。&lt;/p&gt;

&lt;p&gt;因みに私は会社でMac使ってたら使いにくすぎてVMに逃げたくらいのLinuxユーザです。家では勿論Linuxしか使ってないです。
&lt;/p&gt;

&lt;h1 id=&#34;ディストリ&#34;&gt;ディストリ&lt;/h1&gt;

&lt;p&gt;Ubuntu。定番。色々言う人がいるけど何も不満はない。&lt;/p&gt;

&lt;h1 id=&#34;ウィンドウマネージャ-統合デスクトップ環境&#34;&gt;ウィンドウマネージャ（統合デスクトップ環境）&lt;/h1&gt;

&lt;p&gt;Unity。デフォルト。&lt;/p&gt;

&lt;h1 id=&#34;im&#34;&gt;IM&lt;/h1&gt;

&lt;p&gt;uim-skk。何故uim-かというと最初にたまたまそれを使ったから。&lt;/p&gt;

&lt;h1 id=&#34;ブラウザ&#34;&gt;ブラウザ&lt;/h1&gt;

&lt;p&gt;FireFox。確かデフォルト。入れてる拡張はkeysnailのみ。&lt;/p&gt;

&lt;h1 id=&#34;twitterクライアント&#34;&gt;Twitterクライアント&lt;/h1&gt;

&lt;p&gt;公式Web。新機能の追加が一番早くて便利。&lt;/p&gt;

&lt;h1 id=&#34;ターミナルエミュレータ&#34;&gt;ターミナルエミュレータ&lt;/h1&gt;

&lt;p&gt;gnome-terminal。デフォルト。速いし簡単に背景半透明に出来るし何も不満はない。tmuxと一緒に使ってる。&lt;/p&gt;

&lt;h1 id=&#34;エディタ&#34;&gt;エディタ&lt;/h1&gt;

&lt;p&gt;Emacs。デフォルトではない。毎日masterをコンパイルして使う。&lt;/p&gt;

&lt;h1 id=&#34;キーバインド変更&#34;&gt;キーバインド変更&lt;/h1&gt;

&lt;p&gt;xmodmap + &lt;a href=&#34;https://github.com/k0kubun/xremap&#34;&gt;xremap&lt;/a&gt;。これ CF &lt;a href=&#34;http://k0kubun.hatenablog.com/entry/xkremap&#34;&gt;Linux向けの最強のキーリマッパーを作った - k0kubun&amp;rsquo;s blog&lt;/a&gt;。
CapsLockとctrlのスワップにxmodmapを、Emacs風バインドを作るためにxremapを使ってる。xremapは別になくてもどうにかなる。&lt;/p&gt;

&lt;h1 id=&#34;メーラ&#34;&gt;メーラ&lt;/h1&gt;

&lt;p&gt;Thunderbird。確かデフォルト。でもUbuntuのパッケージは更新が遅いので手でインストールしてる。&lt;/p&gt;

&lt;h1 id=&#34;カレンダー&#34;&gt;カレンダー&lt;/h1&gt;

&lt;p&gt;Thunderbird + Lightening拡張。Googlカレンダーと同期出来るし便利。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;このくらいかな？フォントもデフォルト。あとはSlackに公式クライアントだとか偶に音楽再生にrythmbox（デフォルト）だとか画像表示にeog（デフォルト）だとかPDF表示にevice（デフォルト）だとかファイラにnautilus（デフォルト）スクリーンショットにgnome-screenshot（デフォルト）だとかを使うけどこの辺は当たり前なので書かなくていいかな。&lt;/p&gt;

&lt;p&gt;ということでそんなにカスタマイズしなくてもLinuxは便利なのでみなさん使いましょう。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Idein Incに入社しました</title>
      <link>/blog/2017/01/06/idein_incninyuushashimashita</link>
      <pubDate>Fri, 06 Jan 2017 20:53:12 +0900</pubDate>
      
      <guid>/blog/2017/01/06/idein_incninyuushashimashita</guid>
      <description>&lt;p&gt;κeenです。本日を以ちまして&lt;a href=&#34;http://idein.jp/&#34;&gt;Idein Inc.&lt;/a&gt;に入社したので報告します。&lt;/p&gt;

&lt;p&gt;退職エントリは&lt;a href=&#34;http://keens.github.io/blog/2016/11/30/saiba_e_jientowotaishokushimashita/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;経緯&#34;&gt;経緯&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Lisp Meet Upで社長の&lt;a href=&#34;https://twitter.com/9_ties&#34;&gt;@9_ties&lt;/a&gt;さんと知り合う&lt;/li&gt;
&lt;li&gt;その他勉強会で何度か一緒になってよく喋るようになる&lt;/li&gt;
&lt;li&gt;オフィス訪問に誘われて行ったら入社を誘われる（7月末）&lt;/li&gt;
&lt;li&gt;入社することにする（9月半ば）&lt;/li&gt;
&lt;li&gt;入社（現在）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;わさびずとideinに遊びに来たよ。噂のpi zero&lt;br&gt;クラスタとかPEZYとかあった。熱い。 &lt;a href=&#34;https://t.co/MEc7qdosrk&#34;&gt;pic.twitter.com/MEc7qdosrk&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/759655196628615168&#34;&gt;2016年7月31日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;結構前から水面下で話は進んでました。&lt;/p&gt;

&lt;p&gt;割と「PEZYに行くの？」という質問が多かったのですが中らずとも遠からずといったところでしょうか。PEZY Computingとも取引があったりする会社です。&lt;/p&gt;

&lt;h1 id=&#34;どんな会社&#34;&gt;どんな会社？&lt;/h1&gt;

&lt;p&gt;私が7人目（バイトを抜いたら6人目）の社員になる、少数精鋭なスタートアップです。全社員に1つのチャットで連絡が取れます。
この規模ながらフルタイムのリサーチャがいるなど、かなり技術寄りな会社です。創業者も全員技術者です。社員の中ではクソザコクラスになるので明日から人権があるか心配ですがどうにか上手くやっていきます。&lt;/p&gt;

&lt;p&gt;今3期目とのことです。&lt;/p&gt;

&lt;p&gt;社長に「なんて紹介したらいいですか」って言ったら「うーん、困るなぁ」と言われました（苦笑。
Big Pictureとしてはコンピュテーショナルセンサーを使って世の中に起きているあらゆる事象をソフトウェアで扱えるようにしたい、というもの。ざっくり言ってしまえばIoTの会社になるんですかね。
でもじゃあ電子工作ばっかやってるのかというとそういう訳でもなくて、例えばカメラから得られた画像から色々な情報を抜き出すために機械学習やらディープラーニングやらをやっていたり、さらにそれをセンサーデバイス（Rasp Piとか）上で走らせるために効率化したりとソフトウェア技術のウェイトがかなり大きいです。&lt;/p&gt;

&lt;p&gt;例えばニューラルネットワークの学習済みデータを最適化（軽量化）してさらにコンパイル（！！）して組込みデバイス上でも満足な速度で動かすための技術開発なんかをやっています。&lt;/p&gt;

&lt;p&gt;あるいはセンサーから取得したデータを使えるプラットフォームなんかも。&lt;/p&gt;

&lt;h1 id=&#34;どんな仕事するの&#34;&gt;どんな仕事するの？&lt;/h1&gt;

&lt;p&gt;私の仕事もそういう文脈からきていて、例えばニューラルネットをコンパイルしてRasp PiのGPUで動かすだとか、あるいはもうちょっと特化したデバイス（ぼかしてる）のためのコンパイラを作るだとかの仕事になります。
自分で書いておきながらやっぱり「ニューラルネットをコンパイルする」っていう字面がパワーある。
今、（学習ではなくて予測に）使われているのはほとんどがモデルと実行器が分けらています。要はインタプリタなのでそれをコンパイルしてあげて高速に実行するというのが可能なんですね。
ニューラルネットの圧縮のために数学が必要そうな雰囲気で、数学出来ない私は震え上がってます。&lt;/p&gt;

&lt;p&gt;会社全体としてはデバイスの開発も一応やりつつ、データを処理するための技術開発、共同研究、技術開発も含めた受託案件、あるいは開発した技術を使った受託案件なんかもやっています。
かなり技術開発への投資が強いイメージですが、今期は黒字予定と案外バランスの取れた運営をしているようです（結構色々な会社が興味を持ってくれているようです。
センサーだとかの文脈になるのでお客さんはハードウェアの会社が多いようです。&lt;/p&gt;

&lt;h1 id=&#34;初日の感想は&#34;&gt;初日の感想は？&lt;/h1&gt;

&lt;p&gt;会社が移転した（前のオフィスだと私のスペースがなかった）のでほとんど環境構築でした。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;環境構築してる &lt;a href=&#34;https://t.co/6HLHbnOmi6&#34;&gt;pic.twitter.com/6HLHbnOmi6&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/817252587703414789&#34;&gt;2017年1月6日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;オフィス引っ越し中 &lt;a href=&#34;https://t.co/MnrNUxxUP7&#34;&gt;pic.twitter.com/MnrNUxxUP7&lt;/a&gt;&lt;/p&gt;&amp;mdash; y͛amaday͛ (@yamaday) &lt;a href=&#34;https://twitter.com/yamaday/status/817203674036305921&#34;&gt;2017年1月6日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;落ち着いたあとはQiita::Teamを全部読んでました。社長も技術者なので事業プランや資金計画（売り上げ）なんかもQiita::Teamに上がってるのが新鮮でした。&lt;/p&gt;

&lt;p&gt;社員に2名ほどRustをやってる人がいて「κeen君来たし仕事でRust使っていくかー」みたいな感じになりました。使えそうな案件があったら積極的に使っていきたいですね。&lt;/p&gt;

&lt;h1 id=&#34;結びに&#34;&gt;結びに&lt;/h1&gt;

&lt;p&gt;前回転職祝いを沢山頂いたので今回は例のURLは控えさせて頂きます。
前回送りそびれたのでどうしてもという方は&lt;a href=&#34;http://keens.github.io/blog/2016/11/30/saiba_e_jientowotaishokushimashita/&#34;&gt;退職エントリ&lt;/a&gt;の方から辿って頂けると幸いです。&lt;/p&gt;

&lt;p&gt;また、Ideinではエンジニアを募集しています&lt;/p&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;募集職種&#34;&gt;募集職種&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ソフトウェアエンジニア（画像処理）
画像処理に関する基本的な知識を持っている方（画像処理の実装経験がある方歓迎）&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（バックエンド）
分散システムの構築やDevOpsに興味があり、最新の技術の動向を追っている方。場合によっては自ら実装が出来る方&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（フロントエンド）
最新の技術動向に明るく、移り変わりの激しい技術のコンテキストを理解して吸収でき、UXを考慮した実装が出来る方&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（組み込み）
計算機を低いレイヤーまで理解し、ハードウェアの仕様を読み解いて必要機能の実装が出来る方&lt;/li&gt;
&lt;li&gt;ソフトウェアエンジニア（言語処理系）
計算機アーキテクチャや数値計算アルゴリズムに精通しており、最適化コンパイラやプログラミング環境をフルスクラッチで実装出来る方&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下のスキルセットを持っている方を歓迎します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++, Python, Haskell,Rust, etc&amp;hellip;&lt;/li&gt;
&lt;li&gt;Git（分散VCS）&lt;/li&gt;
&lt;li&gt;DevOps関連技術(Docker,Ansible,etc&amp;hellip;)&lt;/li&gt;
&lt;li&gt;GPU&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;すべての職種に一貫して、現在のスキルセットよりは以下に挙げるような事柄への知識や興味を優先します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;アルゴリズムとデータ構造&lt;/li&gt;
&lt;li&gt;計算機&lt;/li&gt;
&lt;li&gt;プログラミング言語&lt;/li&gt;
&lt;li&gt;ソフトウェア工学&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;待遇-給与&#34;&gt;待遇・給与&lt;/h1&gt;

&lt;p&gt;社保完備 月収60万円〜（正社員）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因みに私はポテンシャル採用されたタイプで「壁に当たっても自分で調べて乗り越えていけそう」だとか「コンパイラを書いてると心が折れそうになる瞬間があるけどそこで折れないような人が大事だ」とか言われました。頑張ります。&lt;/p&gt;

&lt;p&gt;ということで皆様の応募お待ちしております！！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>QUICの中身が分からないから仕様読んでみた</title>
      <link>/blog/2017/01/02/quicnonakamigawakaranaikarashiyouyondemita</link>
      <pubDate>Mon, 02 Jan 2017 10:46:39 +0900</pubDate>
      
      <guid>/blog/2017/01/02/quicnonakamigawakaranaikarashiyouyondemita</guid>
      <description>&lt;p&gt;κeenです。先日同期と話しててQUICの中身ってあまり知らないよねってことでQUICの仕様（ドラフト）を読んだのでまとめますね。あまりまとめきれてませんが。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;strong&gt;※ドラフトは既に古くなっているのでこのブログの内容は現行では正しくない可能性があります。というか一部既に正しくないことが判明しています。ご注意下さい&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;後で新しいドラフトを発見したので内容を書き換えました。とりあえずリンクを貼ってあるドラフトの内容までは反映出来ています。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;仕様を読む前にQUICの背景から。
HTTP/2でHTTPにストリームという概念が入りました。
1つのコンテンツ毎に順にやりとりするのではなく、複数のコンテンツを並行して通信する仕組みです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 今まで
[]--CCCBBBAAA--&amp;gt;[]

# HTTP/2
[]--ACCBCABBA--&amp;gt;[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の図でいえば例えばAのコンテンツがサーバの都合で遅くてもBやCのコンテンツが支える（Head of Line Blocking）ことなくクライアントに届きます。&lt;/p&gt;

&lt;p&gt;ところで、この通信はTCP上で行われています。TCPは到達順序を保障するので例えば1パケット欠損したらそれ以後のパケットは（実際にはクライアントに到着しているにも関らず）待たされます(TCP Head of Line Blocking)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[]--ACCBCABB-X--&amp;gt;[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この図でいえばAのパケットが欠損してますが、HTTP/2的にはAは無視してBやCのコンテンツをユーザに届けることは可能な訳です。
この辺を改善したいというのがQUICのモチベーション。&lt;/p&gt;

&lt;p&gt;もうちょっと言うとTCPの3way hand shakeだとかその上のTLS hand shakeだとかのオーバーヘッドの削減の目的もあります。
TCPやTLSもRTTを減らそうと努力はしていますが、もっと抜本的な解決が必要とのことです。&lt;/p&gt;

&lt;p&gt;ということでHTTP/2に特化してTCP+TLSを置き換えるための通信プロトコルとしてUDPベースのQUICが産まれました。&lt;/p&gt;

&lt;p&gt;ここまではよくあるQUICの説明。でも、これだけだと情報が少なくてもやもやしますよね。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP/2に特化とはいうけどどこまで特化してるの？他のアプリケーションで使えないの？&lt;/li&gt;
&lt;li&gt;どうしてTLSも統合してしまったの？分離出来なかったの？&lt;/li&gt;
&lt;li&gt;UDPベースでどうやってコネクションの維持や輻輳制御してるの？&lt;/li&gt;
&lt;li&gt;上記以外でQUICに特徴はないの？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などなど。これらの疑問を解決すべくQUICのドラフトを読んでいきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;quic&#34;&gt;QUIC&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/draft-tsvwg-quic-protocol-02&#34;&gt;これ&lt;/a&gt;を読んでいきます。Expires July 16, 2016とのこと。&lt;/p&gt;

&lt;h2 id=&#34;イントロ&#34;&gt;イントロ&lt;/h2&gt;

&lt;p&gt;QUICはHTTP/2のストリーム分割やフローコントロール、TLSのセキュリティ、TCPのコネクションセマンティクスや信頼性、輻輳制御を提供します。&lt;/p&gt;

&lt;p&gt;QUICはUDPベースの通信プロトコルなので、完全にユーザーランドで完結します。
これは重要な話で、レガシーなネットーワーク中間機器の上でもちゃんと通信出来ることを意味します。
仕様化する前に実証実験をする上でとても重要な性質です。&lt;/p&gt;

&lt;h2 id=&#34;用語&#34;&gt;用語&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;クライアント: QUICコネクションを開始する端&lt;/li&gt;
&lt;li&gt;サーバ: QUICコネクションを受け付ける端&lt;/li&gt;
&lt;li&gt;エンドポイント: サーバ、またはクライアント&lt;/li&gt;
&lt;li&gt;ストリーム: QUICコネクションの論理チャネル内を双方向に流れるバイト列の流れ&lt;/li&gt;
&lt;li&gt;コネクション: 単一の暗号コンテキスト下のQUICエンドポイント同士のやりとり。複数のストリームを持つ。&lt;/li&gt;
&lt;li&gt;コネクションID: QUICコネクションのID&lt;/li&gt;
&lt;li&gt;QUIC Packet: QUICでパース可能な有効なUDPペイロード。QUICのパケットサイズとはUDPのペイロードのサイズを指す。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;QUIC(+HTTP/2)のTCP+TLS(+HTTP/2)に対する利点は以下を改善することです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コネクション確立のレイテンシ&lt;/li&gt;
&lt;li&gt;柔軟な輻輳制御&lt;/li&gt;
&lt;li&gt;Head of Line Blockingなしに多重化&lt;/li&gt;
&lt;li&gt;ヘッダやペイロードが認証/暗号化されている&lt;/li&gt;
&lt;li&gt;ストリーム及びコネクションフローコントーロール&lt;/li&gt;
&lt;li&gt;前方エラー訂正&lt;/li&gt;
&lt;li&gt;コネクション移行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思ったより特徴ありますね。コネクション移行とか面白そう。
さて、それぞれ見ていきます。忙しい人は概要まででもそれなりに役立つでしょう。&lt;/p&gt;

&lt;h3 id=&#34;コネクション確立のレイテンシ&#34;&gt;コネクション確立のレイテンシ&lt;/h3&gt;

&lt;p&gt;通常TCP+TLSだと1-3RTT必要なのに対してQUICは多くの場合0 RTTでコネクション確立出来ます。つまり、いきなりデータを送れる。&lt;/p&gt;

&lt;p&gt;0 RTTで接続出来ない場合、つまりハンドシェイクが必要な場合もある訳ですが、ハンドシェイクの詳細はQUIC Cryptoの方に投げられています。
さらにQUIC CryptoはTLS 1.3に置き換えられる予定なのでほぼTLS 1.3のハンドシェイクだと思っておいて良いようです。&lt;/p&gt;

&lt;h3 id=&#34;柔軟な輻輳制御&#34;&gt;柔軟な輻輳制御&lt;/h3&gt;

&lt;p&gt;QUICはプラガブルな輻輳制御を持っており、TCPより豊富なシグナルがあるのでTCPの輻輳制御アルゴリズムより賢く振る舞うことが出来ます。
とはいっても現状の（ドラフト時点の）GoogleではTCPのアルゴリズムを流用しており別のアプローチを実験中とのこと。&lt;/p&gt;

&lt;p&gt;詳細は&lt;a href=&#34;https://tools.ietf.org/html/draft-quic-loss-recovery&#34;&gt;ここ&lt;/a&gt;にあるとのことでしたが、リンク切れなのか真っ白なページしかありません。&lt;/p&gt;

&lt;p&gt;さて、シグナルが豊富とのことでしたが、1例を出すとパケットの元のものと再送されたものでシーケンス番号が異ります(私はTCPの詳細を知らないのでよく分かりませんが輻輳制御のためにシーケンス番号を振っているのでしょう)。
元と再送のものを区別出来るようになるのでTCPの曖昧性問題（というのがあるのでしょう）を解決出来るとのこと。&lt;/p&gt;

&lt;p&gt;また、パケットを受け取ってからackを送るまでの時差と単調増加するシーケンス番号も一緒に送るのでRTTを計算することが出来ます。&lt;/p&gt;

&lt;p&gt;最後に、ACKが256 NACKまでサポートする（らしい）のでTCPのSACKよりもリオーダリングに弾力性があり、パケロスやリオーダリングがある環境下でもパケット密度を高めることが出来るとのこと。これは後程記述があります。&lt;/p&gt;

&lt;p&gt;この辺はTCPの輻輳制御から勉強しないと利点が分からないですね。宿題。&lt;/p&gt;

&lt;h3 id=&#34;ストリーム及びコネクションフローコントーロール&#34;&gt;ストリーム及びコネクションフローコントーロール&lt;/h3&gt;

&lt;p&gt;順番が前後しますがストリームの話。そういえばHTTP/2にバックプレッシャーありましたね。&lt;/p&gt;

&lt;p&gt;ストリームレベル、コネクションレベルでのフロー制御が出来ます。
ほぼHTTP/2と同等のストリーム制御が可能です。&lt;/p&gt;

&lt;p&gt;ストリームレベルの制御は、まず、受け取り側がストリーム内のデータのどのオフセットまでを受け取るかを広報します。
ストリームにデータが届いたら、WINDOW_UPDATEのフレームを投げて、受け取り可能なオフセットを更新します。&lt;/p&gt;

&lt;p&gt;コネクションレベルの制御は、ストリーム合計でのバッファを制限するために使います。
単純にストリームでやっている制御をコネクションレベルでやるだけです。&lt;/p&gt;

&lt;p&gt;また、TCPにあるようにreceive-windowのオートチューニングもやるそうです。&lt;/p&gt;

&lt;p&gt;この辺、HTTP/2に合わせた仕様なんですね。&lt;/p&gt;

&lt;h3 id=&#34;多重化&#34;&gt;多重化&lt;/h3&gt;

&lt;p&gt;TCP head of line blockingしない。因みにHTTP/2のヘッダはHPACKで圧縮して送るのでここはhead of line blockingします。&lt;/p&gt;

&lt;h3 id=&#34;ヘッダやペイロードが認証-暗号化されている&#34;&gt;ヘッダやペイロードが認証/暗号化されている&lt;/h3&gt;

&lt;p&gt;そもそもの話、TCPは平文で通信するのでreceive-windowの更新やらシーケンス番号を上書きしたりやらの攻撃が可能です（尤も、通信の最適化のために中間機器で行うこともありますが）。&lt;/p&gt;

&lt;p&gt;QUICは一部のヘッダを除き暗号化されています。暗号化されていない部分も受理側によって認証されるのでインジェクションを阻止出来ます。&lt;/p&gt;

&lt;p&gt;ここでTLSも統合している理由が分かりました。認証のためにTLSが必要なんですね。&lt;/p&gt;

&lt;h3 id=&#34;前方エラー訂正&#34;&gt;前方エラー訂正&lt;/h3&gt;

&lt;p&gt;Forward Error Correction (FEC)。シンプルなXORベースのFECをやるそうです。FECグループ内の1パケットがロスしてもFECパケットから復元出来るとのこと。すごい。&lt;/p&gt;

&lt;h3 id=&#34;コネクション移行&#34;&gt;コネクション移行&lt;/h3&gt;

&lt;p&gt;TCPは4-tuple(source address, port, destinacion address, port)でコネクションを判別しますが、それだと例えばスマホが電話通信（って呼称でいいのかな？）からWifiに切り替わった時にIPが変わりますし、NAT下でポート番号が変わることもあるので突発的にコネクションが切れてしまう訳です。&lt;/p&gt;

&lt;p&gt;QUICはクライアントがランダム生成した64bitのコネクションIDで識別します。
じゃあ、コネクションIDを被せにいったらハイジャック出来るじゃんと思えますが、TLSを前提にしているのでクライアント認証も自動でついていて、その辺には耐性があります。&lt;/p&gt;

&lt;h2 id=&#34;パケットタイプとフォーマット&#34;&gt;パケットタイプとフォーマット&lt;/h2&gt;

&lt;p&gt;2種類の特殊パケットと2種類の通常パケットがあります。バージョンネゴシエーションパケットとパブリックリセットパケット、フレームパケットとFECパケットです。&lt;/p&gt;

&lt;p&gt;パケットはIPの断片化を防ぐためにパスのMTU（Message Transfer Unit）に収まる必要がありますが、MTUの発見はまだWIPだそうです。
今とのころIPv6で1350byte、IPv4で1370byteを使っているとのこと。&lt;/p&gt;

&lt;h3 id=&#34;バブリックヘッダ&#34;&gt;バブリックヘッダ&lt;/h3&gt;

&lt;p&gt;全てのQUICパケットにつくヘッダです。パブリックの名の通り暗号化されません。&lt;/p&gt;

&lt;p&gt;長さは2-19byteの間になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      0        1        2        3        4            8
+--------+--------+--------+--------+--------+---    ---+
| Public |    Connection ID (0, 8, 32, or 64)    ...    | -&amp;gt;
|Flags(8)|      (variable length)                       |
+--------+--------+--------+--------+--------+---    ---+

     9       10       11        12
+--------+--------+--------+--------+
|      QUIC Version (32)            | -&amp;gt;
|         (optional)                |
+--------+--------+--------+--------+

    13      14       15        16        17       18
+--------+--------+--------+--------+--------+--------+
|         Packet Number (8, 16, 32, or 48)            |
|                         (variable length)           |
+--------+--------+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;軽く説明しますね。それぞれの詳しい内容は仕様を読んで下さい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;public flagsにパケットタイプなどが入っています。&lt;/li&gt;
&lt;li&gt;コネクションIDが64bitだと過剰な場合はネゴって短かくすることも可能です。&lt;/li&gt;
&lt;li&gt;パケット番号はフレームパケットに付与されます。1から始まり1づつ大きくなります。&lt;/li&gt;
&lt;li&gt;パケット番号の下位64bitはTLSのnonceの一部に使われます。合理的ですね。&lt;/li&gt;
&lt;li&gt;内部的には64bitでシーケンス番号を管理するけどパケットに載せるのは48bitまで。&lt;/li&gt;
&lt;li&gt;48bit(n bit)でオーバーフローした時の曖昧性排除のために2^46個(2^(n-2)個)までしか同時にパケットを送れない&lt;/li&gt;
&lt;li&gt;シーケンス番号が2^64-1に逹したらシーケンス番号のリミットでコネクションクローズが走る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;パケットタイプを判別するフローチャートが載っていたので引用しますね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Check the public flags in public header
                 |
                 |
                 V
           +--------------+
           | Public Reset |    YES
           | flag set?    |---------------&amp;gt; Public Reset Packet
           +--------------+
                 |
                 | NO
                 V
           +------------+          +-------------+
           | Version    |   YES    | Packet sent |  YES
           | flag set?  |---------&amp;gt;| by server?  |--------&amp;gt; Version Negotiation
           +------------+          +-------------+               Packet
                 |                        |
                 | NO                     | NO
                 V                        V
           Regular Packet         Regular Packet with
                              QUIC Version present in header
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;スペシャルパケット&#34;&gt;スペシャルパケット&lt;/h3&gt;

&lt;h4 id=&#34;バージョンネゴシエーションパケット&#34;&gt;バージョンネゴシエーションパケット&lt;/h4&gt;

&lt;p&gt;サーバからのみ送られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     0        1        2        3        4        5        6        7       8
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
| Public |    Connection ID (64)                                                 | -&amp;gt;
|Flags(8)|                                                                       |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+

     9       10       11        12       13      14       15       16       17
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
|      1st QUIC version supported   |     2nd QUIC version supported    |   ...
|      by server (32)               |     by server (32)                |
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特に順序に言及がないのでクライアントは良い感じに新しいやつ選ぶんですかね。&lt;/p&gt;

&lt;h4 id=&#34;パブリックリセットパケット&#34;&gt;パブリックリセットパケット&lt;/h4&gt;

&lt;p&gt;コネクションをクローズしようとしているのが本当に正しいクライアントなのか証明するための情報が載せられます。詳細は仕様を読んで下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     0        1        2        3        4         8
+--------+--------+--------+--------+--------+--   --+
| Public |    Connection ID (64)                ...  | -&amp;gt;
|Flags(8)|                                           |
+--------+--------+--------+--------+--------+--   --+

     9       10       11        12       13      14
+--------+--------+--------+--------+--------+--------+---
|      Quic Tag (32)                |  Tag value map      ... -&amp;gt;
|         (PRST)                    |  (variable length)
+--------+--------+--------+--------+--------+--------+---
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通常パケット&#34;&gt;通常パケット&lt;/h3&gt;

&lt;p&gt;通常パケットのペイロードは暗号化/認証されます。パブリックヘッダは暗号化されませんが認証されます。
通常パケットはPrivate Flagsから始まるプライベートヘッダを持ちます（そこからが暗号化されます）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     0        1
+--------+--------+
|Private | FEC (8)|
|Flags(8)|  (opt) |
+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このあとにAEAD (authenticated encryption and associated data)、つまり認証/暗号化されたペイロードが続きます。&lt;/p&gt;

&lt;h4 id=&#34;フレームパケット&#34;&gt;フレームパケット&lt;/h4&gt;

&lt;p&gt;プライベートヘッダに続いてこんな感じのデータが続きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+---...---+--------+---...---+
| Type   | Payload | Type   | Payload |
+--------+---...---+--------+---...---+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fecパケット&#34;&gt;FECパケット&lt;/h3&gt;

&lt;p&gt;プライベートヘッダに続いてこんな感じのデータが続きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-----...----+
| Redundancy |
+-----...----+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quicコネクションのライフサイクル&#34;&gt;QUICコネクションのライフサイクル&lt;/h2&gt;

&lt;h3 id=&#34;コネクションの確立&#34;&gt;コネクションの確立&lt;/h3&gt;

&lt;p&gt;クライアントがバージョン付きでデータを送って、サーバが処理出来るならそのままレスポンスを返してコネクション成立です。
もし処理出来ないなら、バージョンネゴシエーションパケットを送り返して、クライアントはそこから1つバージョンを選んで再送します。サーバから通常レスポンスが返ってきたらコネクション成立です（成立するまで繰り返します）。&lt;/p&gt;

&lt;p&gt;ダウングレード攻撃を避けるためにハンドシェイクにバージョン情報を載せたり頑張るようですが、細かいので仕様を読んで下さい。&lt;/p&gt;

&lt;h3 id=&#34;データ転送&#34;&gt;データ転送&lt;/h3&gt;

&lt;p&gt;多くは概要で説明した通り。
暗号化ハンドシェイクも含めてストリーム内でデータをやりとりしますが、ACKはQUICパケット単位です。&lt;/p&gt;

&lt;p&gt;シーケンス番号は輻輳制御を統合するためにコネクションを通して同じ番号空間を共有します。&lt;/p&gt;

&lt;p&gt;詳しくは付設のドキュメントを読めと書いてますが、リンク先が真っ白です。&lt;/p&gt;

&lt;h4 id=&#34;ストリームのライフサイクル&#34;&gt;ストリームのライフサイクル&lt;/h4&gt;

&lt;p&gt;ストリームはデータをストリームフレームに分割してデータ転送します。
ストリームフレームは互いに順序逆転可能です。
ストリームの生成/クローズはサーバ、クライアント両方から出来ます。
ほとんどHTTP/2のストリームと同じですね。&lt;/p&gt;

&lt;p&gt;ストリーム生成は特にネゴる必要なく簡単に可能です。ただ、ストリームIDが衝突しないようにサーバが作る時は偶数、クライアントが作る時は奇数を使います。
0は無効、1は暗号化ハンドシェイクのために予約、3はHTTPヘッダの通信のために予約とされています。ヘッダだけは順序保障が必要なんですね。
他の細かい規約は仕様を見て下さい。&lt;/p&gt;

&lt;p&gt;一旦ストリームが開いたらデータ転送に自由に使えます。&lt;/p&gt;

&lt;p&gt;ストリームの終了には3種類あります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;普通の終了: 双方向通信なのでFIN bitを立てて送信した後のhalf-closeとかの概念があります。&lt;/li&gt;
&lt;li&gt;突然の終了: 何かしらのエラーがあった時などにRST_STREAMフレームを送ると強制終了出来ます。&lt;/li&gt;
&lt;li&gt;コネクションが終了した時: まあ、当然ですね。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;コネクションの終了&#34;&gt;コネクションの終了&lt;/h3&gt;

&lt;p&gt;コネクションの終了にも2種類あります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;明示的な終了: CONNECTION_CLOSEを送ることでコネクションを終了出来ます。&lt;/li&gt;
&lt;li&gt;暗黙的な終了: タイムアウト（デフォルト30秒）したらクローズします。通常はCONNECTION_CLOSEを送りますが、モバイルで電波をonにしたくないなどの理由があればsilent closeも可能です。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;それ以外に、PUBLIC_RSTでコネクションをクローズ出来ます。TCPのRST相当（だそう）です。&lt;/p&gt;

&lt;h2 id=&#34;フレームタイプとフォーマット&#34;&gt;フレームタイプとフォーマット&lt;/h2&gt;

&lt;p&gt;前述の通りフレームパケットにはフレームが入っています。フレームタイプ毎にデータの解釈が変わります。
1フレームは必ず1パケットに収まる必要があります。&lt;/p&gt;

&lt;h3 id=&#34;フレームタイプ&#34;&gt;フレームタイプ&lt;/h3&gt;

&lt;p&gt;特殊フレームと通常フレームがあります。&lt;/p&gt;

&lt;p&gt;特殊フレームは以下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------------------+-----------------------------+
| Type-field value |     Control Frame-type      |
+------------------+-----------------------------+
|     1fdooossB    |  STREAM                     |
|     01ntllmmB    |  ACK                        |
|     001xxxxxB    |  CONGESTION_FEEDBACK        |
+------------------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常フレームは以下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------------------+-----------------------------+
| Type-field value |     Control Frame-type      |
+------------------+-----------------------------+
| 00000000B (0x00) |  PADDING                    |
| 00000001B (0x01) |  RST_STREAM                 |
| 00000010B (0x02) |  CONNECTION_CLOSE           |
| 00000011B (0x03) |  GOAWAY                     |
| 00000100B (0x04) |  WINDOW_UPDATE              |
| 00000101B (0x05) |  BLOCKED                    |
| 00000110B (0x06) |  STOP_WAITING               |
| 00000111B (0x07) |  PING                       |
+------------------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのタイプについて仕様に載っている順に軽く説明します。詳しくは仕様を読んで下さい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;STREAM: 暗黙的にstreamを作るのにもデータを送るのにも使います。&lt;/li&gt;
&lt;li&gt;ACK: ackです。受け取った最大シーケンス番号とそれまでで欠損している番号のリストを送ります。前述の通り受理からACKまでの時差を入れたりと複雑なので仕様を読んで下さい。&lt;/li&gt;
&lt;li&gt;STOP_WAITING: 特定以下のシーケンス番号のパケットを待たないように指示します。&lt;/li&gt;
&lt;li&gt;WINDOW_UPDATE: コネクション/ストリームいずれかのウィンドウ余白を通知します。Stream ID 0がコネクションレベルのアップデートです。&lt;/li&gt;
&lt;li&gt;BLOCKED: バックプレッシャーでこれ以上データを送信出来ない時に送ります。informational frameです(ほぼデバッグ用とのこと)。&lt;/li&gt;
&lt;li&gt;CONGESTION_FEEDBACK: experimentalで、not usedとのこと。&lt;/li&gt;
&lt;li&gt;PADDING: 0x00で埋められたデータを保持します。パケットをMTUまで埋めるのが目的なのかな？&lt;/li&gt;
&lt;li&gt;RST_STREAM: ストリームの異常終了用。&lt;/li&gt;
&lt;li&gt;PING: 生きてる？って訊くやつです。これを受けたらACKを返します。デフォルトで15秒毎に送ります。&lt;/li&gt;
&lt;li&gt;CONNECTION_CLOSE: closeを通知するやつです。&lt;/li&gt;
&lt;li&gt;GOAWAY: コネクションを止めるよ通知です。近くcloseするのでデータ送るのやめなよという通知です。新たなstreamが作れなくなります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;quicの通信上のパラメータ&#34;&gt;QUICの通信上のパラメータ&lt;/h2&gt;

&lt;p&gt;ハンドシェイクでネゴシエートすべきパラメータの列挙です。&lt;/p&gt;

&lt;h3 id=&#34;required&#34;&gt;Required&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SFCW - Stream Flow Control Window: ストリームレベルのコントロールフローウィンドウサイズ(バイト単位)です。&lt;/li&gt;
&lt;li&gt;SFCW - Connection Flow Control Window: コネクションレベルのコントロールフローウィンドウサイズ(バイト単位)です。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ほとんどルー語ですね。&lt;/p&gt;

&lt;h3 id=&#34;optional&#34;&gt;Optional&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SRBF - Socket receive buffer size in bytes: CWNDを受け取りバッファくらいに指定したい場合があるらしいのでそれ用。&lt;/li&gt;
&lt;li&gt;TCID - Connection ID truncation: クライアントのエフェメラルポートが単一コネクションにしか使われないと分かっている場合に便利らしいです。&lt;/li&gt;
&lt;li&gt;COPT - Connection Options are a repeated tag field: 実験的パラメータだそうです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;プライオリティ&#34;&gt;プライオリティ&lt;/h2&gt;

&lt;p&gt;HTTP/2のものを使うそうですが、まだ実装してないとのこと。&lt;/p&gt;

&lt;h2 id=&#34;quic上のhttp-2&#34;&gt;QUIC上のHTTP/2&lt;/h2&gt;

&lt;p&gt;いくつかHTTP/2と同じ機能を提供していますが、HTTP/2がQUICを使う時にどう統合するかのお話です。&lt;/p&gt;

&lt;h3 id=&#34;ストリームマネジメント&#34;&gt;ストリームマネジメント&lt;/h3&gt;

&lt;p&gt;QUICが代替機能を提供するのでHTTP/2レイヤで扱う必要はありません。HTTP/2のストリームIDはそのままQUICのストリームIDになります。&lt;/p&gt;

&lt;h3 id=&#34;ヘッダー圧縮&#34;&gt;ヘッダー圧縮&lt;/h3&gt;

&lt;p&gt;Stream ID 3で送ることになっている（QUICの仕様でHTTP/2のヘッダを扱うことになっている）。のでそれを使います。&lt;/p&gt;

&lt;h3 id=&#34;http-2ヘッダのパース&#34;&gt;HTTP/2ヘッダのパース&lt;/h3&gt;

&lt;p&gt;ヘッダのパースはHTTP/2の仕様に従います。&lt;/p&gt;

&lt;h3 id=&#34;永続コネクション&#34;&gt;永続コネクション&lt;/h3&gt;

&lt;p&gt;コネクションという概念がないのでHTTPにある&amp;rdquo;Connection&amp;rdquo;ヘッダが意味をなさない。ので、HTTPレベルでのコネクションハンドリングはしません。&lt;/p&gt;

&lt;p&gt;これ、&amp;rdquo;Connection: upgrade&amp;rdquo;はどうするんですかねって思ったら次に書いてました。&lt;/p&gt;

&lt;h3 id=&#34;httpでのquicネゴシエーション&#34;&gt;HTTPでのQUICネゴシエーション&lt;/h3&gt;

&lt;p&gt;クライアントが普通のHTTPでアクセスした時にサーバはQUICを使いませんか、とネゴシエーションすることが出来ます。それが&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Alternate-Protocol: 123:quic&amp;rdquo;&lt;/p&gt;

&lt;p&gt;です。同じホストの123ポートにQUICプロトコルでアクセスしにいきます。
中間機器がUDPをブロックすることも考えてTCPにgraceful fallbackしろ、と書かれてます。&lt;/p&gt;

&lt;h2 id=&#34;ハンドシェイクプロトコルへの要求&#34;&gt;ハンドシェイクプロトコルへの要求&lt;/h2&gt;

&lt;p&gt;ハンドシェイク自体はこのドキュメントでは扱ってませんが、ハンドシェイクが満たすべき性質を書いています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0-RTTでのコネクション確立&lt;/li&gt;
&lt;li&gt;ソースアドレスのなりすまし対策&lt;/li&gt;
&lt;li&gt;クライアントからソースアドレストークンが不透明なこと。トークンにいくつかのクライアント情報を埋め込むため。&lt;/li&gt;
&lt;li&gt;通信パラメータのネゴシエーション&lt;/li&gt;
&lt;li&gt;証明書の圧縮。REJも1350bytesに収めたい。&lt;/li&gt;
&lt;li&gt;サーバコンフィグのアップデート&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上が仕様の主だった記述です。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;HTTP/2に特化とはいうけどどこまで特化してるの？他のアプリケーションで使えないの？&lt;br /&gt;
→ ストリームやHTTP/2ヘッダなどが統合されているのでかなり扱いづらい。&lt;/li&gt;
&lt;li&gt;どうしてTLSも統合してしまったの？分離出来なかったの？&lt;br /&gt;
→ クライアント認証のために必要だった。TLS1.3からは分離出来る（？）&lt;/li&gt;
&lt;li&gt;UDPベースでどうやってコネクションの維持や輻輳制御してるの？&lt;br /&gt;
→ コネクションはコネクションIDで維持。輻輳制御は別の仕様（アクセス不可）に書いてある&lt;/li&gt;
&lt;li&gt;上記以外でQUICに特徴はないの？&lt;br /&gt;
→ 柔軟な輻輳制御、FEC、コネクション移行など&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新たに湧いた疑問&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ロードバランシングどうするんだろう。ミドルウェアレベルだとConnection ID見て振り分けるとして、アプリケーションレベルだとRubyとかでよくあるlistenしてforkしてacceptするようなやつは破綻しないかな。そもそもQUICを使わない？&lt;/li&gt;
&lt;li&gt;Connection IDが衝突したらどうなるんだろう。REJするのかな。仕様に書いてない。&lt;/li&gt;
&lt;li&gt;いくつかの仕様（HTTP/2ヘッダ）とかを無視して別のアプリケーションで使えないかな。あるいは想定してないのかな。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;宿題:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCPについても調べる。特に輻輳制御回り。&lt;/li&gt;
&lt;li&gt;QUICの輻輳制御について調べる。&lt;/li&gt;
&lt;li&gt;TLS1.3との統合について調べる&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>2017年注目していきたい技術</title>
      <link>/blog/2017/01/01/2017nenchuumokushiteikitaigijutsu</link>
      <pubDate>Sun, 01 Jan 2017 22:12:01 +0900</pubDate>
      
      <guid>/blog/2017/01/01/2017nenchuumokushiteikitaigijutsu</guid>
      <description>&lt;p&gt;κeenです。毎年これやっていく。個人的に注目していきたい技術と飛び込んでみたい技術書いく。&lt;/p&gt;

&lt;p&gt;あくまで個人的な内容。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;webassembly-http-webassembly-org&#34;&gt;&lt;a href=&#34;http://webassembly.org/&#34;&gt;WebAssembly&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;ブラウザ上で動く仮想アセンブラ。ブラウザ上でのJSの高速実行はブラウザでの至上命題である。
JIT技術を各ブラウザベンダが切磋琢磨していたがそれでも限界があるので&lt;a href=&#34;http://asmjs.org/&#34;&gt;asm.js&lt;/a&gt;なんかが産まれた。
これは例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように&lt;code&gt;x|0&lt;/code&gt;と書くと&lt;code&gt;x&lt;/code&gt;が整数であることを表わす、などとしてJSのサブセットで型情報も付与出来るようにしたものだ。冗長なので人の手で書くことは意図していない。
これはある程度上手くいって、&lt;a href=&#34;https://github.com/kripken/emscripten&#34;&gt;emscripten&lt;/a&gt;のようにLLVMからjsへのコンパイラでも使われている。&lt;/p&gt;

&lt;p&gt;それでもまだ問題がある。1つに、JSよりも冗長な記法を使っているためファイルが嵩張る点。ロード時間やパース時間が長くなる。そもそも人の手で掛かないならバイナリフォーマットでもいい筈だ。
そしてもう1つに低レベルな処理、例えばSIMDなんかは扱えない点。&lt;/p&gt;

&lt;p&gt;WebAssemblyはこれらを解決する。仮想的な機械語でバイナリフォーマットがあるので低レベルなことが（将来）出来てコンパクトになっている。
計算モデルはスタックベースのマシンになっている。メモリや関数テーブルなどもある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (func (;0;) (type 0) (param i32 i32) (result i32)
    get_local 0
    get_local 1
    i32.add)
  (export &amp;quot;addTwo&amp;quot; (func 0)))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多くの人にとってWebAssemblyは意識して関るものではなく、emscriptenの吐くコードが効率的になる、程度のものだろう。
私はコンパイラを作る人なので意識する必要がある。
WebAssemblyにはundefined behaviourがないだとかThread API、 SIMD APIなどが入る予定だとかがあるのでLLVM経由で吐くよりも直接吐いた方が面白い。&lt;/p&gt;

&lt;p&gt;少し追っていきたい。&lt;/p&gt;

&lt;h1 id=&#34;quic-https-www-chromium-org-quic&#34;&gt;&lt;a href=&#34;https://www.chromium.org/quic&#34;&gt;QUIC&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;HTTP/2のための代替TCP。HTTP/2はもうリリースされてるので次はQUICを。
HTTP/2は1コネクションを複数のstreamに分割するが、stream内での到達順序保障は必要なもののstream同士ではそれが不要なのでTCPの到達順序保障が過剰要求になってしまう。
それを緩めるためにUDPベースでプロトコルを作ったのがQUIC。まあ、他にも色々改善点はあるが。&lt;/p&gt;

&lt;p&gt;これも基本的にはあまり追う必要はないが、自分の使いたい言語で実装がなかったら自分で実装することになる。
まだその辺の環境が整っていないので今後どうなるか注視する必要がある。&lt;/p&gt;

&lt;h1 id=&#34;idris-http-www-idris-lang-org&#34;&gt;&lt;a href=&#34;http://www.idris-lang.org/&#34;&gt;Idris&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;依存型のある言語。今年もRustに忙しい可能性があるが、ちょっとIdrisに興味が湧いた。
常々「多相があって正格評価で高階関数を簡単に扱えてサブタイピングのない、C FFIやThreadを扱える言語」を捜していて、それがATS2だったりSML#だったりRustだったりした。
最近はRustに落ち着いたが、今度は低レベルな部分、「C FFIやThreadを扱える」がなくてもいいから依存型が入ってる言語が欲しくなった。ATS2は置いといてIdrisかなーと。&lt;/p&gt;

&lt;p&gt;生の依存型だとつらいかな、と思っていたらtacticもあるようだったので機会があればやってみたい。&lt;/p&gt;

&lt;p&gt;CF &lt;a href=&#34;http://wkwkes.hatenablog.com/entry/2016/12/17/000000&#34;&gt;プログラミング言語 idris - wkwkesのやつ&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lean-http-leanprover-github-io&#34;&gt;&lt;a href=&#34;http://leanprover.github.io/&#34;&gt;Lean&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;MSRで開発されている定理証明支援系。よく「Coqでいいじゃん」「Agdaは？」と訊かれるが、&lt;a href=&#34;https://leanprover.github.io/theorem_proving_in_lean/index.html&#34;&gt;オンラインチュートリアル&lt;/a&gt;が良さげだったのと、Emacsから使えるのと、
&lt;a href=&#34;https://kha.github.io/2016/07/22/formally-verifying-rusts-binary-search.html&#34;&gt;RustからLeanへのトランスレートをやっている&lt;/a&gt;人がいたので興味湧いた。
そもそもCoqをある程度やってからにしろとは自分でも思う。&lt;/p&gt;

&lt;h1 id=&#34;coq-https-coq-inria-fr&#34;&gt;&lt;a href=&#34;https://coq.inria.fr/&#34;&gt;Coq&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;定理証明支援系。去年も上がっていたが、今年は酉年なので。「Agdaは？」。知らん。&lt;/p&gt;

&lt;h1 id=&#34;finagle-https-twitter-github-io-finagle&#34;&gt;&lt;a href=&#34;https://twitter.github.io/finagle/&#34;&gt;Finagle&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;RPCのクライアント/サーバフレームワーク。RPCをやる時にいくつか問題が出る。
1つはペイロードがRPC毎に違うのでフレームワークが定まりづらい点。
もう1つはロードバランシングがしづらい点。
ロードバランシングの方に言及しておくと、RPCをやる時は大抵コネクションを張りっぱなしなのでTCPロードバランサが使えない。
例えば順番にサーバを起動していくと最初に上がったサーバにコネクションが集中して以後バランスされない。&lt;/p&gt;

&lt;p&gt;これを解決するのがFinagleで、クライアントが全てのサーバにコネクションを貼って、クライアントサイドでロードバランシングをする。
さらにクライアントが複数のサーバを知っているのでサーバがエラーを返したら別のサーバにリクエストを投げることも出来る。
ペイロードの話は多相型で解決する。パーサとかその辺も含めたフレームワークになっている。&lt;/p&gt;

&lt;h1 id=&#34;tokio-https-github-com-tokio-rs-tokio&#34;&gt;&lt;a href=&#34;https://github.com/tokio-rs/tokio&#34;&gt;Tokio&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;FinagleのRust版。Rustは非同期IOに強いと思っているのでTokioがリリースされたらそこら辺のHTTPフレームワークも非同期化するのではと思っている。&lt;/p&gt;

&lt;h1 id=&#34;tidb-https-github-com-pingcap-tidb&#34;&gt;&lt;a href=&#34;https://github.com/pingcap/tidb&#34;&gt;TiDB&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;分散スケール可能なSQL DB。Rust製。&lt;a href=&#34;https://research.google.com/pubs/pub41344.html&#34;&gt;Google F1&lt;/a&gt;を参考に作られているらしい。
ストレージエンジン自体は&lt;a href=&#34;http://rocksdb.org/&#34;&gt;RocksDB&lt;/a&gt;を使っていて、その上に分散合意、MVCC、トランザクションを載せてさらにそれにSQLレイヤー、MySQLプロトコルレイヤーを載せている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pingcap.github.io/blog/assets/img/how-we-build-tidb-2.png&#34; alt=&#34;TiDBのアーキテクチャ画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アーキテクチャについては上の画像を引用した&lt;a href=&#34;https://pingcap.github.io/blog/2016/10/17/how-we-build-tidb/&#34;&gt;この記事&lt;/a&gt;が詳しい。&lt;/p&gt;

&lt;h1 id=&#34;tantivy-https-github-com-tantivy-search-tantivy&#34;&gt;&lt;a href=&#34;https://github.com/tantivy-search/tantivy&#34;&gt;tantivy&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;全文検索エンジンライブラリ。Rust製。アーキテクチャやアルゴリズムは&lt;a href=&#34;http://lucene.apache.org/core/&#34;&gt;Apache Lucene&lt;/a&gt;を参考に作られているらしいのでだいたいそのレイヤーのライブラリと思ってもらえれば。&lt;/p&gt;

&lt;p&gt;Rust製なのでインデックスの構築が速いのが一つの特徴。今後、自前でElastic SearchやApache Solrのようなレイヤーを作るのかLuceneの置き換えを狙ってJava APIを提供するのかは不明。&lt;/p&gt;

&lt;p&gt;注目したい理由はベースで使っている&lt;a href=&#34;https://github.com/BurntSushi/fst&#34;&gt;fstライブラリ&lt;/a&gt;の&lt;a href=&#34;http://blog.burntsushi.net/transducers/&#34;&gt;紹介記事&lt;/a&gt;が気に入ったから。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2016年注目していきたかった技術の振り返りと個人的振り返り</title>
      <link>/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri</link>
      <pubDate>Sat, 31 Dec 2016 16:57:48 +0900</pubDate>
      
      <guid>/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri</guid>
      <description>&lt;p&gt;κeenです。年始に&lt;a href=&#34;http://keens.github.io/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu/&#34;&gt;2016年注目していきたい技術 | κeenのHappy Hacκing Blog&lt;/a&gt;ってのを書いたので雑に振り返ります。あと個人的な一年の総括を。&lt;/p&gt;

&lt;p&gt;※個人メモなので雑多な記述が多いです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;apache-drill-https-drill-apache-org&#34;&gt;&lt;a href=&#34;https://drill.apache.org/&#34;&gt;Apache Drill&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;ちょっとづつ進化してるようだけどそこまで広まってる気配なし。因みに自分はチーム移動で使う用事がなくなったのであんまり使ってない&lt;/p&gt;

&lt;h1 id=&#34;rust-https-www-rust-lang-org-en-us&#34;&gt;&lt;a href=&#34;https://www.rust-lang.org/en-US/&#34;&gt;Rust&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;めっちゃ使った。大分進化してる。&lt;a href=&#34;https://rust.connpass.com/event/35122/&#34;&gt;ハンズオン&lt;/a&gt;のチュータやったり&lt;a href=&#34;https://rust.connpass.com/event/41467/&#34;&gt;LT会&lt;/a&gt;の玄人枠で発表したりもした。あと年明けに&lt;a href=&#34;https://rust.connpass.com/event/43893/&#34;&gt;ハンズオン第2回&lt;/a&gt;のチュータやる。&lt;/p&gt;

&lt;h1 id=&#34;apache-kafka-http-kafka-apache-org&#34;&gt;&lt;a href=&#34;http://kafka.apache.org/&#34;&gt;Apache Kafka&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;めっちゃ使った。便利。道具箱の中身が増えた。便利。&lt;/p&gt;

&lt;h1 id=&#34;floki-https-github-com-arthurprs-floki&#34;&gt;&lt;a href=&#34;https://github.com/arthurprs/floki&#34;&gt;Floki&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;5月で開発停止したっぽい。残念。&lt;/p&gt;

&lt;h1 id=&#34;robots-https-github-com-gamazeps-robots&#34;&gt;&lt;a href=&#34;https://github.com/gamazeps/RobotS&#34;&gt;RobotS&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;開発は続いてるようだけど流行ってはない。うーん、アクターいけると思ったんだけどなぁ。&lt;/p&gt;

&lt;h1 id=&#34;redox-http-www-redox-os-org&#34;&gt;&lt;a href=&#34;http://www.redox-os.org/&#34;&gt;Redox&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;開発は継続中。&lt;a href=&#34;https://github.com/redox-os/redox/releases&#34;&gt;ISOのリリース&lt;/a&gt;とかもあったしそれなりに進歩はしてる。多分もうちょっとウォッチ期間が必要。&lt;/p&gt;

&lt;h1 id=&#34;ats2-http-www-ats-lang-org&#34;&gt;&lt;a href=&#34;http://www.ats-lang.org/&#34;&gt;ATS2&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;使ってない。一回コンパイラのバグ踏んじゃって萎えてその後はRustばっか使ってる。面白いんだけどなぁ…&lt;/p&gt;

&lt;h1 id=&#34;r-https-www-r-project-org&#34;&gt;&lt;a href=&#34;https://www.r-project.org/&#34;&gt;R&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;チーム移動で用事がなくなったのであまり使ってない。
一応それなりには使ったけどあんまりRのこと覚えきれてない。例えるならEmacs初心者がEmacs Lispのスニペットをコピペでどうにか使ってるくらい。&lt;/p&gt;

&lt;h1 id=&#34;異常検知&#34;&gt;異常検知&lt;/h1&gt;

&lt;p&gt;チーム移動で(ry&lt;/p&gt;

&lt;h1 id=&#34;coq-https-coq-inria-fr&#34;&gt;&lt;a href=&#34;https://coq.inria.fr/&#34;&gt;Coq&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;それなりにやった。&lt;a href=&#34;http://proofcafe.org/sf/&#34;&gt;ソフトウェアの基礎&lt;/a&gt;のサブタイプまでやった。ProofGeneralのバグは&lt;a href=&#34;https://github.com/ProofGeneral/PG&#34;&gt;GitHubにある方のProofGeneral&lt;/a&gt;を使ったら解決した。あと&lt;a href=&#34;https://twitter.com/search?q=%23readcoqart&amp;amp;src=typd&amp;amp;lang=ja&#34;&gt;#readcoqart&lt;/a&gt;にも何度か参加した。&lt;/p&gt;

&lt;h1 id=&#34;isabelle-https-isabelle-in-tum-de&#34;&gt;&lt;a href=&#34;https://isabelle.in.tum.de/&#34;&gt;Isabelle&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;一応チュートリアルを少しやった。あと&lt;a href=&#34;https://keens.github.io/slide/tadashiiScalanoko_dogahoshii/&#34;&gt;社内勉強会で発表&lt;/a&gt;もした。Isabelle 2014までしかProofGeneralで使えないのでちょっと厳しくなってやらなくなった。つらい。&lt;/p&gt;

&lt;p&gt;いい加減Emacs以外のプラットフォームも使えるようにならないとなー。&lt;/p&gt;

&lt;h1 id=&#34;fortran&#34;&gt;Fortran&lt;/h1&gt;

&lt;p&gt;やってない。1ﾐﾘも触ってない。本当はある程度入門したらFortranコンパイラでも作るかって気分だったけど&lt;a href=&#34;http://no-maddojp.hatenablog.com/entry/2016/12/01/023624&#34;&gt;つらいらしい&lt;/a&gt;のでやらなくてよかった&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;じゃ、個人的総括。まず、個人ブログはこのエントリ含めて48。週1ペース守れなかった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/01/2016nenchuumokushiteikitaigijutsu&#34;&gt;2016年注目していきたい技術&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/01/ATS2nokangaseiridekita&#34;&gt;ATS2の観が整理出来た&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/08/Rusttoiedoriso_sunokaihouhachuui&#34;&gt;Rustといえどリソースの解放は注意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/11/SML_nopthreadbaindingutsukutta&#34;&gt;SML#のpthreadバインディング作った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/12/Isabelleninyuumonshita&#34;&gt;Isabelleに入門した&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/17/dokugakudepuroguraminguwoyattekitanakadeyokattagijutsushowoageteiku&#34;&gt;独学でプログラミングをやってきた中で良かった技術書50選&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/17/puroguraminguwodokugakusurutokikosoinputtowofuyashitahougaii&#34;&gt;プログラミングを独学する時こそインプットを増やした方がいい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/27/Lisp_Meetup3shuunenniyosete&#34;&gt;Lisp Meetup3周年に寄せて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/01/31/Rustnopakke_jiwocrates_ionitourokusuru&#34;&gt;Rustのパッケージをcrates.ioに登録する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/04/Common_Lispdekousokugyouretsuenzan&#34;&gt;Common Lispで高速行列演算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/10/Nexus_5niUbuntu_Touchnoinsuto_ru&#34;&gt;Nexus 5にUbuntu Touchのインストール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/14/DVCSnomoderu_aruihaPijulnitsuite&#34;&gt;分散VCSのモデル、あるいはPijulについて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/14/readlinenotsukurikata&#34;&gt;readlineの作り方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/24/Bind_Addressnoimigayouyakuwakatta&#34;&gt;Bind Addressの意味がようやく分かった&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/27/druidtoiuriarutaimude_tabunsekitsu_ruwoshitta&#34;&gt;druidというリアルタイムデータ分析ツールを知った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/02/28/RustnoHigherKinded_type_Trait&#34;&gt;RustのHigher-Kinded type Trait&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/03/01/Rustnozerokosutochuushouka&#34;&gt;Rustのゼロコスト抽象化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/03/01/tesutonitsuitekangaetemita&#34;&gt;テストについて考えてみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/03/02/ri_jontoRustnokaerichi&#34;&gt;リージョンとRustの返り値&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/04/04/Mirahkanrentsu_rumatome&#34;&gt;Mirah関連ツールまとめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/04/14/lxc_2_0_0gariri_susaretarashii&#34;&gt;LXDがリリースされたらしい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/05/04/RustdebeametaruRaspberry_PinoLchika&#34;&gt;RustでベアメタルRaspberry PiのLチカ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/05/14/cargo_profilerwotamesu&#34;&gt;cargo-profilerを試す&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/06/12/multirustgahisuishouninattayounanoderustupniikousuru&#34;&gt;multirustが非推奨になったようなのでrustupに移行する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/06/19/Rustnoshoyuuken_myu_tabiriteinobunkatsu&#34;&gt;Rustの所有権/ミュータビリティの分割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/07/02/Container_Desgin_Patterns&#34;&gt;Container Desgin Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/07/13/shierugeijuuhachihan&#34;&gt;シェル芸十八般&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/08/02/watashigako_dowokakutokitesutohakakanai&#34;&gt;私がコードを書くときテストは書かない&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/08/11/mirah_0_2gariri_susaremashita&#34;&gt;mirah 0.2がリリースされました。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/09/04/Rustdeshierutsukutta&#34;&gt;Rustでシェル作った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/09/29/Pijulnoinsuto_ruganan_idotakainodekaisetsusuru&#34;&gt;Pijulのインストールが難易度高いので解説する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/10/10/Rustnokuro_ja3tanewotsukutterikaisuru&#34;&gt;Rustのクロージャ3種を作って理解する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/10/10/SMLdemonado&#34;&gt;SMLでモナド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/10/31/VMwarenoUbuntuwo16_10nishitarakidoushinakunatta&#34;&gt;VMwareのUbuntuを16.10にしたら起動しなくなった&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/06/RustnokatareberuLispppoinotsukutta&#34;&gt;Rustの型レベルLispっぽいの作った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/22/Rustnokanrenkatanotsukaidokoro&#34;&gt;Rustの関連型の使いどころ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/30/SML_woUbuntu_16_10deugokasu&#34;&gt;SML#をUbuntu 16.10で動かす&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/11/30/saiba_e_jientowotaishokushimashita&#34;&gt;サイバーエージェントを退職しました&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/01/4nenkantsuzuitaShibuya_lispnoLispMeetUp&#34;&gt;4年間続いたShibuya.lispのLispMeetUp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/01/Rustdebaitoretsuwoatsukautokinotips&#34;&gt;Rustでバイト列を扱う時のtips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/01/makuroyakonpairapuraguinnojissouhouhou&#34;&gt;マクロやコンパイラプラグインの実装方法色々&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/02/Rustnopurosesu&#34;&gt;Rustのプロセス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/02/atarashiikonpairabakkuendocretonne&#34;&gt;新しいコンパイラバックエンドcretonne&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/03/Rustnostructtotraittteniteruyone&#34;&gt;Rustのstructとtraitって似てるよね&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/14/Rustnoshoyuuken_raifutaimu_sanshou_kata_shigarami&#34;&gt;Rustの所有権、ライフタイム、参照、型、しがらみ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/24/Rustnoraifutaimuwotsukattasuko_pukaiseki&#34;&gt;Rustのライフタイムを使ったスコープ解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/29/kizuitaraRustnokankyoukouchikugakanarirakuninatteta&#34;&gt;気付いたらRustの環境構築がかなり楽になってた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/2016/12/31/2016nenchuumokushiteikitakattagijutsunofurikaeritokojintekifurikaeri&#34;&gt;2016年注目していきたかった技術の振り返りと個人的振り返り&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スライドは15。月1以上のペースだった。意外。ほとんど社内のScala勉強会で発表してるっぽい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/slide/HAMT&#34;&gt;HAMT ~ イミュータブルで高速なハッシュマップ ~&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/ClojuredeSSPwotsukuttahanashi&#34;&gt;ClojureでSSPを作った話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Rusttohananika_donnagengoka_&#34;&gt;Rustとは何か。どんな言語か。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/biggude_tashinaiDrill_ro_karudekaitekinitsukautameni&#34;&gt;ビッグデータしないDrill、ローカルで快適に使うために&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/SMLdekansuukatatekiseikihyougenmatchi&#34;&gt;SMLで函数型的正規表現マッチ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/tesutonitsuite_Scalato_&#34;&gt;テストについて、Scalaと。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/kousokunakeizokuraiburarinimukete&#34;&gt;高速な継続ライブラリに向けて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/DOT_dottynitsuiteshirabetemita&#34;&gt;DOT/dottyについて調べてみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Socket_on_SML_&#34;&gt;Socket on SML#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/katakurasuwokoete&#34;&gt;型クラスを越えて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/tadashiiScalanoko_dogahoshii&#34;&gt;正しいScalaのコードが欲しい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Scala_2_12_0henkouten&#34;&gt;Scala 2.12.0変更点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Rustnohanashitoriso_sunohanashi&#34;&gt;Rustの話とリソースの話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/RustdehidoukiThriftshitai&#34;&gt;Rustで非同期Thriftしたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/slide/Schemedeclasstoprotocol&#34;&gt;SchemeでClassとProtocol&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その他外部に投稿したものは13。これも併わせたらブログはギリギリ週1ペースかな。仕事関連だったり仕事中に思い付いてブログにアクセス出来ないのでQiitaに投げたものが多い。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/3b068769736e671805f0&#34;&gt;Rustのドキュメントの翻訳プロジェクトを開始します。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/382704cc54c8e42819d0&#34;&gt;正規表現の先読み/後読みを「絞り込み」と理解してみる - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/c9e60e089974392878c8&#34;&gt;一瞬でシェルスクリプト作れるシェル関数作った - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/3231c8adec40b350cf33&#34;&gt;sedの-iオプションの非互換 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/4945a6eb5cceeb154b24&#34;&gt;Rustでサイコロで同じ目が100回連続で実際に出るか - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/blackenedgold/items/4f91a174e0f63ee42699&#34;&gt;POSIXシェルで変数がセットされているか検査するイディオム - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1095&#34;&gt;ICFP及び関連イベント参加レポート – Haskell Day – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1099&#34;&gt;ICFP及び関連イベント参加レポート – ICFP併設ワークショップ – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1118&#34;&gt;ICFP及び関連イベント参加レポート – ICFP 1日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1125&#34;&gt;ICFP及び関連イベント参加レポート – ICFP 2日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1158&#34;&gt;ICFP及び関連イベント参加レポート – ICFP 3日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1200&#34;&gt;ICFP及び関連イベント参加レポート – 併設ワークショップ2日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adtech.cyberagent.io/techblog/archives/1380&#34;&gt;ICFP及び関連イベント参加レポート – 併設ワークショップ3日目 – | Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、OSSだと雑なスニペットとかもGitHubに上げてるのでカウントが難しいけど、主だったものだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/incubator-airflow&#34;&gt;airflow&lt;/a&gt;の&lt;a href=&#34;https://github.com/apache/incubator-airflow/blob/master/airflow/contrib/operators/ssh_execute_operator.py&#34;&gt;SSH Execute Operator&lt;/a&gt;を書いた&lt;/li&gt;
&lt;li&gt;Apache Drillの&lt;a href=&#34;https://github.com/KeenS/sql-drill.el&#34;&gt;Emacs Mode&lt;/a&gt;作った（リリースしてない）&lt;/li&gt;
&lt;li&gt;Rustの&lt;a href=&#34;https://github.com/KeenS/file_logger&#34;&gt;file_logger&lt;/a&gt;作った&lt;/li&gt;
&lt;li&gt;file_loggerと一緒に使うために&lt;a href=&#34;https://github.com/KeenS/rotate_file&#34;&gt;rotate_file&lt;/a&gt;作った（リリースしてない）&lt;/li&gt;
&lt;li&gt;インターン向けに作った&lt;a href=&#34;https://github.com/KeenS/s7p&#34;&gt;SSP&lt;/a&gt;を公開した。&lt;/li&gt;
&lt;li&gt;SML#の&lt;a href=&#34;https://github.com/KeenS/smlsharp_pthread&#34;&gt;pthreadバインディング&lt;/a&gt;作った。多分64bitで動かない。&lt;/li&gt;
&lt;li&gt;SML#の&lt;a href=&#34;https://github.com/KeenS/SmlSharpSocketSupport&#34;&gt;socketサポー&lt;/a&gt;作った。まだメモリ管理回りで処理系とのやりとりに上手くいってないので完成してない。&lt;/li&gt;
&lt;li&gt;Rustで&lt;a href=&#34;https://github.com/KeenS/igaguri&#34;&gt;シェル&lt;/a&gt;作った。雑に動く。&lt;/li&gt;
&lt;li&gt;Tokioの&lt;a href=&#34;https://github.com/KeenS/tokio-thrift&#34;&gt;Thrift対応&lt;/a&gt;フレームワーク作成中。Tokio側がリリースされたらこちらもリリース出来るくらいの進捗でやっていきたい。&lt;/li&gt;
&lt;li&gt;Rust公式ドキュメントの&lt;a href=&#34;https://github.com/rust-lang-ja/the-rust-programming-language-ja&#34;&gt;翻訳&lt;/a&gt;一応1.6は完了。今1.14まで来てるので更新せねば…。&lt;/li&gt;
&lt;li&gt;なんか適当な&lt;a href=&#34;https://github.com/KeenS/webml&#34;&gt;ML風言語のコンパイラ&lt;/a&gt;作り始めた。年内にコード吐くまでやりたかったけど最後の数日サボってしまったので間に合わない。&lt;/li&gt;
&lt;li&gt;コンパイラのために&lt;a href=&#34;[KeenS/WebAssembler-rs](https://github.com/KeenS/WebAssembler-rs)&#34;&gt;WebAssemblyをインメモリで吐くライブラリ&lt;/a&gt;作った。ブラウザでコンパイラ動かしたい時に使う。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;かな。&lt;a href=&#34;https://github.com/KeenS/cl-fast-cont&#34;&gt;限定継続ライブラリ&lt;/a&gt;みたいに途中で放置してるやつとか&lt;a href=&#34;https://github.com/KeenS/rust_os&#34;&gt;チュートリアル読んでOS作ってるやつ&lt;/a&gt;とかは入れてないので「活動」って意味だともう少し広いけど社会貢献はしてない。&lt;/p&gt;

&lt;p&gt;仕事も含めたGitHubの草はこんなもん。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;und&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://t.co/MVQag8h6qU&#34;&gt;pic.twitter.com/MVQag8h6qU&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/814449614967357440&#34;&gt;2016年12月29日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;引越しだとかICFPとかの週はほとんどコミット出来てないのでもうちょっと頑張りたい。あと顕著に土日にサボってるのもどうにかしたい。&lt;/p&gt;

&lt;p&gt;割と飽きっぽいというか他のものに浮気しがちというか適当に手を付けては壁に当たった/第一目標達成したあたりで次にいっちゃうので継続性がない。継続した方が社会貢献になるんだよなー。&lt;/p&gt;

&lt;p&gt;読書は正確にいつ買ったか覚えてないので正確じゃないけど、流し読みしたものも含めれば&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/gp/product/4535782148/&#34;&gt;線型論理入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4621063243/&#34;&gt;圏論の基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4535787204/&#34;&gt;圏論の歩き方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/gp/product/052103311X/&#34;&gt;Compiling with Continuations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798114685/&#34;&gt;最新コンパイラ構成技法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798134201/&#34;&gt;ガベージコレクション 自動的メモリ管理を構成する理論と実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798045365/&#34;&gt;独自CPU開発で学ぶコンピュータのしくみ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4797382228/&#34;&gt;暗号技術入門 第3版 秘密の国のアリス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4798141100/&#34;&gt;その数式、プログラムできますか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4873116856/&#34;&gt;戦略的データサイエンス入門 ―ビジネスに活かすコンセプトとテクニック&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529153/&#34;&gt;ノンパラメトリックベイズ 点過程と統計的機械学習の数理 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529099/&#34;&gt;劣モジュラ最適化と機械学習 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529021/&#34;&gt;深層学習 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4061529080&#34;&gt;異常検知と変化検知 (機械学習プロフェッショナルシリーズ)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/479813161X/&#34;&gt;実践ドメイン駆動設計 (Object Oriented SELECTION)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4048679880&#34;&gt;The Art of Multiprocessor Programming 並行プログラミングの原理から実践まで&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多分こんなもん。機械学習プロフェッショナルシリーズは去年読んだのも含んでるかもしれない。あんまり覚えてない。論文も挙げようと思ったけど面倒になったからいいや。十数綴から二十綴くらいじゃないかな。&lt;/p&gt;

&lt;p&gt;社会的には1回社内でチーム移動になって1回退職した。Shibuya.lispの運営から引退を発表して、rust-lang-ja（有志の翻訳コミュニティ？）の中の人になった。&lt;/p&gt;

&lt;p&gt;まだ社会人になって2年も経ってなくて情報科学/工学の基礎もないので基礎を付けるために勉強してるフェーズかなぁといったところ。
来年は専門性の高い仕事になるので今年以上に勉強が必要になりそう。多分本より論文に比重が傾く。&lt;/p&gt;

&lt;p&gt;年明けにまた注目していきたい技術書く。毎年書いていったら面白いかもしれない。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>気付いたらRustの環境構築がかなり楽になってた</title>
      <link>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</link>
      <pubDate>Thu, 29 Dec 2016 11:52:55 +0900</pubDate>
      
      <guid>/blog/2016/12/29/kizuitararustnokankyoukouchikugakanarirakuninatteta</guid>
      <description>&lt;p&gt;κeenです。ここのところRustの開発ツール回りでリリースが続いてセットアップが楽になってるようだったので最新の情報をお届けします。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;とりあえず私は既存の環境があるので一旦全て破棄してから再度セットアップしてみます。&lt;/p&gt;

&lt;h1 id=&#34;rustのインストール&#34;&gt;Rustのインストール&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://rustup.rs/&#34;&gt;rustup.rs - The Rust toolchain installer&lt;/a&gt;がリリースされたので以下で一発です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://sh.rustup.rs -sSf | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;source $HOME/.cargo/env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をシェルのrcファイルに書き加えたらOKです。
今のシェルにも反映するには同じく上記のコマンドを打ちます。&lt;/p&gt;

&lt;h1 id=&#34;周辺ツールのインストール&#34;&gt;周辺ツールのインストール&lt;/h1&gt;

&lt;p&gt;cargoがあるので楽ですね&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# コードフォーマッタ
$ cargo install rustfmt
# 補完、定義ジャンプなど
$ cargo install racer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあまあ時間がかかります。&lt;/p&gt;

&lt;h1 id=&#34;エディタ-emacs-の設定&#34;&gt;エディタ(Emacs)の設定&lt;/h1&gt;

&lt;p&gt;私がEmacsを使ってるのでEmacsの設定を。&lt;/p&gt;

&lt;p&gt;まず、必要パッケージをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;rustfmt&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;racer&lt;/code&gt; &lt;code&gt;flycheck-rust&lt;/code&gt; をインストールします。rust-modeにrustfmtの機能が含まれているようでした。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; rustfmtを emacsから使うの rust-modeが現在サポートしているので, rustfmt.elパッケージは不要ですね. rust-format-on-saveが non-nilなら保存時に rustfmtが実行されます.&lt;/p&gt;&amp;mdash; Syohei YOSHIDA (@syohex) &lt;a href=&#34;https://twitter.com/syohex/status/814354653672415232&#34;&gt;2016年12月29日&lt;/a&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;;;; racerやrustfmt、コンパイラにパスを通す
(add-to-list &#39;exec-path (expand-file-name &amp;quot;~/.cargo/bin/&amp;quot;))
;;; rust-modeでrust-format-on-saveをtにすると自動でrustfmtが走る
(eval-after-load &amp;quot;rust-mode&amp;quot;
  &#39;(setq-default rust-format-on-save t))
;;; rustのファイルを編集するときにracerとflycheckを起動する
(add-hook &#39;rust-mode-hook (lambda ()
                            (racer-mode)
                            (flycheck-rust-setup)))
;;; racerのeldocサポートを使う
(add-hook &#39;racer-mode-hook #&#39;eldoc-mode)
;;; racerの補完サポートを使う
(add-hook &#39;racer-mode-hook (lambda ()
                             (company-mode)
                             ;;; この辺の設定はお好みで
                             (set (make-variable-buffer-local &#39;company-idle-delay) 0.1)
                             (set (make-variable-buffer-local &#39;company-minimum-prefix-length) 0)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とりあえずこれでセットアップ完了です。racerの最新版でrustのソースコードの位置を設定しなくてよくなったので簡潔になりましたね。&lt;/p&gt;

&lt;p&gt;racer-modeは補完をしてくれる他、&lt;code&gt;M-.&lt;/code&gt;で定義元ジャンプ、&lt;code&gt;M-,&lt;/code&gt;でジャンプ元に戻れます。
あとは&lt;code&gt;M-x racer-describe&lt;/code&gt;でポイント位置にあるシンボルのrustdocを(Emacs内で)表示してくれます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;おお! racerでEmacs内でrustdocレンダ出来るようになってる！便利！！&lt;br&gt;&lt;br&gt;Rustdoc Meets The Self-Documenting Editor&lt;a href=&#34;https://t.co/gDEHl2fSfx&#34;&gt;https://t.co/gDEHl2fSfx&lt;/a&gt; &lt;a href=&#34;https://t.co/sdrX9OoEnr&#34;&gt;pic.twitter.com/sdrX9OoEnr&lt;/a&gt;&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/770796719185408000&#34;&gt;2016年8月31日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;その他は放っておくと勝手に機能してくれるので考えることが少なくていいですね。&lt;/p&gt;

&lt;h1 id=&#34;その他便利ツール&#34;&gt;その他便利ツール&lt;/h1&gt;

&lt;p&gt;セットアップがあっけなかったのでついでに入れておくと便利なツールをいくつか紹介します。&lt;/p&gt;

&lt;h2 id=&#34;cargo-edit&#34;&gt;cargo-edit&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-edit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「libcクレートの最新版に依存したい」なんて時に一々libcの最新版を確認するのは面倒ですよね。そんなときにcargo-editがあれば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo add libc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で &lt;code&gt;Cargo.toml&lt;/code&gt; に追記してくれます。&lt;/p&gt;

&lt;h2 id=&#34;cargo-script&#34;&gt;cargo-script&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとした実験スクリプトとかをコンパイル→実行のステップを踏まずにいきなり実行出来ます。
&lt;code&gt;cargo script FILE&lt;/code&gt;でファイルを実行出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; hello.rs
fn main() {
    println!(&amp;quot;hello, script&amp;quot;)
}
EOF
$ cargo script hello.rs
   Compiling hello v0.1.0 (file:///home/kim/.cargo/.cargo/script-cache/file-hello-f6b1735a519bb659)
    Finished release [optimized] target(s) in 0.15 secs
hello, script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というふうに使います。&lt;/p&gt;

&lt;p&gt;シェルのrcファイルで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;alias rust=&#39;cargo-script&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としておくと吉。&lt;/p&gt;

&lt;h2 id=&#34;cargo-update&#34;&gt;cargo-update&lt;/h2&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install cargo-update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までインストールしたバイナリのアップデートを出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cargo install-update -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>