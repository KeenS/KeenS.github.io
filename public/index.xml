<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>κeenのHappy Hacκing Blog</title>
    <link>http://KeenS.github.io/</link>
    <description>Recent content on κeenのHappy Hacκing Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 08 Nov 2015 21:40:14 +0900</lastBuildDate>
    <atom:link href="http://KeenS.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>一時ファイルの作り方</title>
      <link>http://keens.github.io/blog/2015/11/08/ichijifairunotsukurikata</link>
      <pubDate>Sun, 08 Nov 2015 21:40:14 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/11/08/ichijifairunotsukurikata</guid>
      <description>

&lt;p&gt;Rustに&lt;a href=&#34;https://github.com/Stebalien/tempfile&#34;&gt;tempfile&lt;/a&gt;というライブラリがある。その名の通りテンポラリファイルを作るライブラリだ。
必要に迫られてそのライブラリにPRを送ろうとして実装を読んだのだが普段あまり意識しなかったテンポラリファイルの作り方を知ったのでちょっと解説してみる。&lt;/p&gt;

&lt;p&gt;Rustはほぼそのままの使い心地でCのライブラリを呼べるのでCが分かる人になら伝わると思う。&lt;/p&gt;

&lt;p&gt;ライブラリの構成として、src/*.rsにOS非依存なコードやユーザ向けのAPIがあり、src/imp/{windows,unix}.rsにOS依存なコードがある。
私はWindowsの実装には興味ないし詳しくもないのでunix向けの実装だけを見る。&lt;/p&gt;

&lt;p&gt;imp以下を見る前にこのライブライが提供するAPIを解説しておくと、大きく分けて&lt;code&gt;TempFile&lt;/code&gt;と&lt;code&gt;NamedTempFile&lt;/code&gt;がある。無名、Namedどちらにもデフォルトの一時ファイルディレクトリ下に一時ファイルを作るAPIと指定したディレクトリ以下に作るAPIとがある。
&lt;code&gt;TempFile&lt;/code&gt;が作るファイルは完全に匿名で、ファイルシステムに残らない。I/Oが出来るストリームだけを返す。定期的に/tmp以下を削除するジョブが走っていたとしても安全だし、他のプロセスに中身を読まれる危険性もない。
一方&lt;code&gt;NamedTempFile&lt;/code&gt;の方は予測不可能なファイル名でファイルを作るものの、ファイルシステムに残るので安全ではない。しかしファイル名を要求する関数や外部プロセスと協調する時に使える。&lt;/p&gt;

&lt;p&gt;それぞれで実装を見ていく。&lt;/p&gt;

&lt;h1 id=&#34;tempfile:047d25333d01b489b97d09f703fb9afe&#34;&gt;TempFile&lt;/h1&gt;

&lt;p&gt;これはLinuxとその他で実装が分かれる。ユーザーAPI側でテンポラリファイルを作るディレクトリの指定は吸収しているのでこちらではただ指定されたディレクトリ下にテンポラリファイルを作ればいい。&lt;/p&gt;

&lt;h2 id=&#34;linux:047d25333d01b489b97d09f703fb9afe&#34;&gt;Linux&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(target_os = &amp;quot;linux&amp;quot;)]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    const O_TMPFILE: libc::c_int = 0o20200000;
    match unsafe {
        libc::open(try!(cstr(dir)).as_ptr(), O_CLOEXEC | O_EXCL | O_TMPFILE | O_RDWR, 0o600)
    } {
        -1 =&amp;gt; create_unix(dir),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux 3.11から&lt;code&gt;O_TMPFILE&lt;/code&gt;が入ったので実装は直接的だ。&lt;code&gt;O_TMPFILE&lt;/code&gt;はテンポラリファイル向けにファイルシステムに名前が登録されない匿名のファイルを作る。Lispのgensymに似ている。
O_EXCLでリンクによる別名での参照を回避し、Linux 2.6.23以後で入ったO_CLOEXECで&lt;code&gt;exec(2)&lt;/code&gt;した時にfdを閉じるようにする。そうすれば関係のないプログラムからファイルが参照されるのを防げる。&lt;/p&gt;

&lt;p&gt;このライブラリコールが成功すればそのままFileを返す。&lt;/p&gt;

&lt;p&gt;Linux 3.11未満やO_TMPFILEをサポートしないファイルシステムだったら失敗し、-1が返るのでLinuxに依存しない汎用の&lt;code&gt;create_unix&lt;/code&gt;にフォールバックする。&lt;/p&gt;

&lt;h2 id=&#34;unix:047d25333d01b489b97d09f703fb9afe&#34;&gt;Unix&lt;/h2&gt;

&lt;p&gt;Unix向けの実装は恐らくPOSIX互換なシステムなら全てで動く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(not(target_os = &amp;quot;linux&amp;quot;))]
pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    create_unix(dir)
}

fn create_unix(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        let tmp_path = dir.join(&amp;amp;tmpname());
        return match create_named(&amp;amp;tmp_path) {
            Ok(file) =&amp;gt; {
                // I should probably tell the user this failed but the temporary file creation
                // didn&#39;t really fail...
                let _ = fs::remove_file(tmp_path);
                Ok(file)
            },
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        }
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;汎用の&lt;code&gt;create_unix&lt;/code&gt;では完全に無名のテンポラリファイルを作るのを諦めて、一旦ランダム生成な名前のファイルを作って開き、成功したらそのファイルを削除する。
1つでも開いてるプロセスがある時に削除されるとUnixのファイルはそのプロセスからは見れるが他のプロセスからは見れない状態になるので色々便利に使われている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;create_named&lt;/code&gt;は後程見るとして、ランダム生成なファイル名だと稀に既に存在するファイル名と被る可能性があるので何度かリトライしている。
リトライ回数はsrc/lib.rsで定義されていて、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const NUM_RETRIES: u32 = 1 &amp;lt;&amp;lt; 31;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。思ったよりえけつない回数リトライしている。もちろん、ファイル名が被った以外の理由でファイル生成が失敗したのならリトライに意味はないので大人しくreturnしている。&lt;/p&gt;

&lt;p&gt;で、&lt;code&gt;create_named&lt;/code&gt;だが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    match unsafe {
        libc::open(try!(cstr(&amp;amp;path)).as_ptr(), O_CLOEXEC | O_EXCL | O_RDWR | O_CREAT, 0o600)
    } {
        -1 =&amp;gt; Err(io::Error::last_os_error()),
        fd =&amp;gt; Ok(unsafe { FromRawFd::from_raw_fd(fd) }),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっている。単に&lt;code&gt;create&lt;/code&gt;のフラグの&lt;code&gt;O_TMPFILE&lt;/code&gt;が&lt;code&gt;O_CREAT&lt;/code&gt;になっただけ。&lt;/p&gt;

&lt;h1 id=&#34;namedtempfile:047d25333d01b489b97d09f703fb9afe&#34;&gt;NamedTempFile&lt;/h1&gt;

&lt;p&gt;こちらはユーザーAPIの中から直接OS互換用コードを呼んでいる。src/named.rsに実装がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;    /// Create a new temporary file in the specified directory.
    pub fn new_in&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(dir: P) -&amp;gt; io::Result&amp;lt;NamedTempFile&amp;gt; {
        for _ in 0..::NUM_RETRIES {
            let path = dir.as_ref().join(&amp;amp;util::tmpname());
            return match imp::create_named(&amp;amp;path) {
                Ok(file) =&amp;gt; Ok(NamedTempFile(Some(NamedTempFileInner { path: path, file: file, }))),
                Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
                Err(e) =&amp;gt; Err(e),
            }
        }
        Err(io::Error::new(io::ErrorKind::AlreadyExists,
                           &amp;quot;too many temporary directories already exist&amp;quot;))
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値をユーザAPI向けにラップしている以外は無名の一時ファイルと変わらない。余談だがここで使われているファイル名にユーザが干渉することが出来ず、完全にランダムなファイル名になっている。
ファイルの末尾(例えば拡張子)や先頭(例えばapp_nameなどの識別子)を挟めない。私が今作業してるパッチはその辺をもう少し自由にするものだ。&lt;/p&gt;

&lt;p&gt;閑話休題。似たような実装が2つもあるのは気になるので一応windows向けの実装も読んでみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const ACCESS: DWORD     = winapi::FILE_GENERIC_READ
                        | winapi::FILE_GENERIC_WRITE;
const SHARE_MODE: DWORD = winapi::FILE_SHARE_DELETE
                        | winapi::FILE_SHARE_READ
                        | winapi::FILE_SHARE_WRITE;
const FLAGS: DWORD      = winapi::FILE_ATTRIBUTE_HIDDEN
                        | winapi::FILE_ATTRIBUTE_TEMPORARY;


fn to_utf16(s: &amp;amp;Path) -&amp;gt; Vec&amp;lt;u16&amp;gt; {
    s.as_os_str().encode_wide().chain(Some(0).into_iter()).collect()
}

fn win_create(path: &amp;amp;Path,
                     access: DWORD,
                     share_mode: DWORD,
                     disp: DWORD,
                     flags: DWORD) -&amp;gt; io::Result&amp;lt;File&amp;gt; {

    let path = to_utf16(path);
    let handle = unsafe {
        CreateFileW(
            path.as_ptr(),
            access,
            share_mode,
            0 as *mut _,
            disp,
            flags,
            ptr::null_mut())
    };
    if handle == winapi::INVALID_HANDLE_VALUE {
        Err(io::Error::last_os_error())
    } else {
        Ok(unsafe { File::from_raw_handle(handle as RawHandle) })
    }
}

pub fn create_named(path: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    win_create(path, ACCESS, SHARE_MODE, winapi::CREATE_NEW, FLAGS)
}

pub fn create(dir: &amp;amp;Path) -&amp;gt; io::Result&amp;lt;File&amp;gt; {
    for _ in 0..::NUM_RETRIES {
        return match win_create(
            &amp;amp;dir.join(&amp;amp;tmpname()),
            ACCESS,
            SHARE_MODE,
            winapi::CREATE_NEW,
            FLAGS | winapi::FILE_FLAG_DELETE_ON_CLOSE)
        {
            Ok(f) =&amp;gt; Ok(f),
            Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists =&amp;gt; continue,
            Err(e) =&amp;gt; Err(e),
        };
    }
    Err(io::Error::new(io::ErrorKind::AlreadyExists,
                       &amp;quot;too many temporary directories already exist&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows向けの実装は必ずファイル名を指定する必要があり、リトライが必要そう？&lt;code&gt;NamedTempFile&lt;/code&gt;を作るには(理論的に)どの実装でもリトライが必要だからユーザAPI側で纏めたのかな？&lt;/p&gt;

&lt;h1 id=&#34;まとめ:047d25333d01b489b97d09f703fb9afe&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;テンポラリファイルを作るならまずは&lt;code&gt;O_TMPFILE&lt;/code&gt;を試す&lt;/li&gt;
&lt;li&gt;ダメならランダム生成なファイル名で成功するまでリトライ、成功したら即座にファイルを削除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作業中のコードをpushし忘れて土日に進捗出来なかったのでまたお茶を濁すはめになった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ClojureでDSPを作った話</title>
      <link>http://keens.github.io/slide/ClojuredeDSPwotsukuttahanashi/</link>
      <pubDate>Tue, 27 Oct 2015 21:04:20 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/ClojuredeDSPwotsukuttahanashi/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ClojureでDSPを作った話
----------------------
Lisp Meet Up #3
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# DSPとは
--------

* Demand Side Platform
* 広告主から広告を集めて広告の表示権を競り落し、適切な広告を出す
  0. 広告主を集めて
  1. 競りの通知を受け取って
  2. 一番コスパが良さそうな広告を選んで
  3. 入札して
  4. 落札通知を受け取る
  5. 落札したら広告を出す


 
# ひとりDSP
----------

* AdTech Studioの新卒研修
* 2ヶ月間、業務時間の20%を使ってDSPを作る
  + 実質8営業日
* 業務ロジックを理解することが目的
* 最後に新卒の作ったDSP同士で競争、利益が得点になる
* 他には最終発表での得点も
* **研修なので好きにやっていい**
  + Clojureで書くことに
* サーバーの他は広告主データと学習用データが与えられる



&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/92I5tQt6q6IjII&#34; width=&#34;425&#34; height=&#34;355&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/prir/ss-35918532&#34; title=&#34;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&#34; target=&#34;_blank&#34;&gt;日本におけるアドテク市場とサイバーエージェントのアドテク事業について&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/prir&#34; target=&#34;_blank&#34;&gt;CyberAgent, Inc.&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;


# 作るもの
---------

* 競りの通知を受け取って入札するJSON REST API
* 落札の通知を受け取るJSON REST API
  + 割とシンプル
* 「一番コスパが良さそうな広告を選ぶ」部分は色々と工夫する
* 今回は広告を出すところまではやらない
* クリック情報は落札通知に入ってる


# b11dについて
-------------

* 今回作ったDSP
* [KeenS/b11d](https://github.com/KeenS/b11d)
* Clojure製
* 5日くらいで作った
* あまりゴテゴテしない方針
  + 今回パフォーマンスは無視していい
  + Clojureに慣れてないので学習コストも抑えたい
* NginXとAppとMySQL構成+α
* DBは綺麗に設計したい
* 1リクエスト毎にDBを引きにいく素敵仕様


# WAP
-----

* Compojure
* Sinatra likeなやつ
* ringの上に乗っかてる
* かなりシンプルな部類だがJSON REST API程度ならこれで十分
* ringミドルウェアのでJSON部分も抽象化
* 学習コストが低いので気軽に始められる


# JSONライブラリ
--------------

* ring.middleware.json/wrap-json-{body, response}
  + JSON-&gt;マップとマップ-&gt;JSON
  + bodyの方はキーがStringになるのが微妙
    - セキュリティ的に仕方ない
  + Content-Typeを指定しないと動かない罠
* cheshire
  + 事前データをインポートするのに使った
  + ringのJSONミドルウェアの依存なのでそのまま使った
  + 自然で使い易いAPI


# データベース接続
----------------

* java.jdbc
* JDBCのClojure向けラッパ?
* DataSourceを自分で渡すのでコネクションプールも簡単
* SQL手書きしたら良い感じにマップを返してくれる
* Storeはカラムと値の対応を手書き
* 便利マクロもいくつか


# データベース接続
----------------

* eager loading面倒問題
  + 入れ子オブジェクトを保存する方も面倒だった
  + ORMの便利さを実感。
* bulk insert難しい問題
  + 実行時可変長引数難しい
* ORMはXXXを使うかJavaのやつをそのまま使う?
* JavaはXMLさえ我慢すれば割と良い奴揃ってる
* しかしレスポンスはマップで欲しいかも


# 運用
-----

* warに固めてTomcat vs スタンドアロンなfat jar
* 今回はfat jarを選択
* スタンドアロンだとsupervisordとかでの管理が楽
* Tomcatの運用経験がない
* Jetty中々優秀らしい
* jstatを使ってMackerelでメトリクス取った


# 非同期化
---------

* core.async/goで手軽に非同期
* DBへの書き込みを非同期にした
* DB書き込みでエラーが出ても500にならない恐怖
* 最初の方で支払いを記録出来てなくて予算管理が死亡
  + 予算管理失敗ペナルティで、大分点数引かれたらしい
* goroutineでの例外処理どうやるんだろう。


# 開発環境
---------

* nREPL + Emacs + CIDER
* 補完の設定上手くいかなかった
* 諸々地味に不便
* 起動遅い
* Emacs側からnREPL立ち上げたい
* サーバーのライブリロード欲しい
* 正解が欲しい



# その他Clojureについて
---------------------

* コンスのCarを取るのに`hd`か`head`か`car`か分かんなかった
  + 結局どれでもなくて`first`だった
* 引数のパターンマッチが便利
  + JSON REST APIだとリクエストに何を期待してるのか分かりづらい
  + パターンマッチがドキュメントになる
* やっぱJavaのライブラリ使えるの便利


# 落穂拾い
---------

* デプロイにはシェルスクリプト
  + お家芸
* 「一番コスパが良さそうな広告を選んで入札」で統計か機械学習が必要
  + 1回表示した時の収益の期待値を計算する
* 今回は事前データの統計を使った
  + 理想的には機械学習。時間変化についていける
* In Appでオンライン学習出来るライブラリが思ったよりない
  + 分散処理向けの大袈裟なのが多い
  + Weka? liblinear-java?
* 後で考えたらIncanter使えばよかった


# まとめ
-------

* 給料貰いながらLisp書いた
* ClojureでDSP作った
* Clojureで機械学習したかったけど間に合わなかった


# 参考
------

* [Internal of b11d | κeenのHappy Hacκing Blog](http://keens.github.io/slide/Internal_of_b11d/)

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>REST APIのテストにはwgetが便利かもしれない</title>
      <link>http://keens.github.io/blog/2015/10/20/apinotesutonihawgetgabenrikamoshirenai</link>
      <pubDate>Tue, 20 Oct 2015 00:30:42 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/10/20/apinotesutonihawgetgabenrikamoshirenai</guid>
      <description>

&lt;p&gt;寝れずに悶々としていたので書いてみる。REST APIを叩くときはデフォルトで結果を標準出力に吐くcURLがよく使われるがテストにはwgetが向いてるかもしれない。&lt;/p&gt;

&lt;p&gt;理由は簡単。exit statusだ。シェルのテストをする時は&lt;a href=&#34;https://github.com/kward/shunit2&#34;&gt;shunit2&lt;/a&gt;を使うことになるかと思うが、exit statusでテストをしたくなる。
cURLはHTTPサーバーがエラーステータスを返してもexit status 0で終了するのに対してwgetは所定の値を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXIT STATUS
       Wget may return one of several error codes if it encounters problems.

       0   No problems occurred.

       1   Generic error code.

       2   Parse error---for instance, when parsing command-line options, the .wgetrc or .netrc...

       3   File I/O error.

       4   Network failure.

       5   SSL verification failure.

       6   Username/password authentication failure.

       7   Protocol errors.

       8   Server issued an error response.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;少し試してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sL google.com/teapot &amp;gt; /dev/null
$ echo $?
0
$ wget -qO /dev/null google.com/teapot
$ echo $?
8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと違いが出ている。余談だが &lt;code&gt;wget -O /dev/null&lt;/code&gt;は便利なので覚えておくと幸せになれる。&lt;/p&gt;

&lt;h1 id=&#34;おまけ:67650a6fc4fa81318fe87d2796b2dbeb&#34;&gt;おまけ&lt;/h1&gt;

&lt;p&gt;HTTPのエラーを全部1つのステータスに纏めるのはちょっと乱暴な気がする。wgetはHTTP以外のプロトコルにも対応してるのでまあ仕方がないのだろうが。
ということで任意のHTTPレスポンスを抜き出してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sIL google.com/teapot | grep -E &#39;^HTTP/[0-9](\.[0-9])? [0-9]{3}&#39;
HTTP/1.1 301 Moved Permanently
HTTP/1.1 418 I&#39;m a Teapot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本当にstatusだけ抜き出したかったらこうだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sIL google.com/teapot | grep -E &#39;^HTTP/[0-9](\.[0-9])? [0-9]{3}&#39; | grep -o -E &#39;[0-9]{3}&#39;
301
418
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数回HTTPリクエストを飛ばしているので複数statusが返ってくるのは諦めよう。最後のやつだけ欲しければ &lt;code&gt;tail -n 1&lt;/code&gt;すればいい。&lt;/p&gt;

&lt;p&gt;HTTPの仕様を読まずに書いたのでバージョンのマッチの部分が冗長かもしれないがとりあえず動く。というかcURLを使った。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:67650a6fc4fa81318fe87d2796b2dbeb&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;cURL使おう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Internal of b11d</title>
      <link>http://keens.github.io/slide/Internal_of_b11d/</link>
      <pubDate>Mon, 19 Oct 2015 21:33:00 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Internal_of_b11d/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Internal of b11d
----------------------
サイバーエージェント新卒研修  
ひとりDSP最終発表会

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdのサーバーサイド（？）エンジニア
 + 趣味でLisp, ML, Shell Scriptあたりを書きます
 + 仕事でScalaとShell Scriptあたりを書きます


# 今回作ったもの
----------------

* b11d (ぶらっくんどごーるど)
* Clojure (compojure + middleware)製
  + + NginX + MySQL + Supervisord
* 出来る限りシンプルになるように作った
  + 310行
* デプロイその他はシェルスクリプト
* 監視はmackerel


# シンプルということ
-------------------

* アプリケーションは状態を持たない
* IO以外副作用を持たない
* つまり、キャッシュを持たない
  + キャッシュはパフォーマンス上の意味しかない
  + 早過ぎる最適化は諸悪の根源
* スケールアウトが容易
* compojureのミドルウェアを上手く使った


# シンプルということ2
--------------------

* データベースはだいたい第4正規形（ﾀﾌﾞﾝ）
  + 全てのカラムは`NOT NULL`
  + 広告主の所だけ拡張性を持たせるために第1正規形に落とした
  + 1広告主に対して複数の広告が持てるようになる
* 外部キー制約も全部付ける
* データが綺麗なのでアプリケーション側でのやることが少ない
* 分析する時にも活きる筈


# デプロイ
---------

* 全てシェルスクリプトでオペレーション出来る
* 手作業を無くしてミスを無くす
  + 「あれ？設定書き換えたのに反映されてない」 → 「再起動忘れてた」とかを防ぐ
* ☆秘伝☆のシェルテクニック満載！ 
* アプリケーションが1jarに収まるのでデプロイが楽。


# 監視
------

* mackerelで色々モニタリング
* Linux, NginX, MySQL, JVM, レスポンスステータス
* ほとんどMackerelに乗っかることで本質的でないことに労力を割かない
  + 本質 = 業務ロジックを理解すること
* アプリケーションの死活監視にはsupervisord
  + 本当はsystemdでやりたかったけどUbuntuのバージョンが古かった


# 落穂拾い
----------

* DBへの書き込みは非同期。Clojureなら簡単に書ける
  + `(go ...)` で囲むだけ
* だいたい1700qps。データが増えると多分もうちょい下がる。
  + キャッシュすればデータに依存しない速度。もう少しパフォーマンスも出る。
* アプリケーションサーバには組込みjettyを使った。
  + War + Tomcatでも出来るがデプロイ/運用が楽なのでこちらを採用
* コア数に対してスケールするのでスケールアップも出来る
* CTR予測は訓練データを 広告主xサイトxUA で統計を取って使う
  + 途中からシグモイド関数で変化をつける


# 改善点とか今後とか
---------

* win rate, 入札/落札価格, CTRとかをmackerelでモニタリングしたかった
* 管理画面的なの必要？
* フォールトトラレンス性はないのでその辺
  + MySQLが死ぬとヤバい。
* ホットデプロイしたかった
* 折角JVMだし機械学習したかった
* Unix Domain Socket使うの忘れてた
* データベースにタイムスタンプ入れるの忘れてた………orz

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ddでPCの引っ越しをしたら起動しなかった</title>
      <link>http://keens.github.io/blog/2015/10/05/dd_depcnohikkoshiwoshitarakidoushinakatta</link>
      <pubDate>Mon, 05 Oct 2015 21:30:06 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/10/05/dd_depcnohikkoshiwoshitarakidoushinakatta</guid>
      <description>

&lt;p&gt;κeenです。この間長年使ってたDynabookからThink Padに乗り換えました。引っ越しの時に困ったのでメモ。&lt;/p&gt;

&lt;p&gt;元々あるのが&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dynabook&lt;/li&gt;
&lt;li&gt;外付けハードディスクカバー&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新たに購入したのが&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Think Pad (HDDモデル)&lt;/li&gt;
&lt;li&gt;SSD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SSDだけ先に手元に来たのでまずSSDへ引っ越しを済ませ、Think Padが届いたらHDDとSSDを交換することに。&lt;/p&gt;

&lt;h1 id=&#34;dynabookのhddからssdへの引っ越し:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;DynabookのHDDからSSDへの引っ越し&lt;/h1&gt;

&lt;p&gt;Ubuntuをインストールしてバックアップから復元しても良かったのですがHDDもSSDも512GBだったので&lt;code&gt;dd&lt;/code&gt;を使って引っ越ししました。&lt;/p&gt;

&lt;p&gt;事前に出来る限りプロセスは殺す。本来は別ディスクから立ち上げたOSでやるのが良いんだろうけど面倒だったので引越し対象のOSから実行しました。。コマンドはすごいシンプル。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ dd if=/dev/sda of=/dev/sdb bs=512k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外付けハードディスクカバーとDynabookがUSB2.0までにしか対応してないからか20MB/sしか出ず、一晩掛かりました。しかし終わったあとDynabookのHDDとSSDを交換して起動してみると何の問題もなく起動しました。素晴しい。&lt;/p&gt;

&lt;h1 id=&#34;ssdをthink-padに移植:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;SSDをThink Padに移植&lt;/h1&gt;

&lt;p&gt;一瞬ハードディスクの外し方が分からず苦戦するもネットで調べると分解マニュアルが出てきたので楽に換装。しかしThink Padの電源を入れても起動しなかった。&lt;/p&gt;

&lt;h1 id=&#34;biosとuefi:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;BIOSとUEFI&lt;/h1&gt;

&lt;h2 id=&#34;bios:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;BIOS&lt;/h2&gt;

&lt;p&gt;BIOSといえばコンビュータの電源をポチっと入れた瞬間に起動するソフトウェアで、Basic I/O Systemの略かと思っていましたがBasic I/O Systemの実装の1つの名前でもあるらしいです。&lt;/p&gt;

&lt;p&gt;BIOSはディスクの先頭にあるMaster Boot Recordを読みにいきます。そこからパーティションテーブルの情報を得てgrubなどを起動します。（Master Boot RecordのことをMBRと略すこともあるしMaster Boot Recordを使うパーティションテーブルのことをMBRと呼ぶこともある…？）。昔、&lt;a href=&#34;http://KeenS.github.io/blog/2015/01/08/freebsd-environment-setups/&#34;&gt;GPTを使うと起動しなかった経験がある&lt;/a&gt;ので私のDynabookのBasic I/O SystemにはBIOSが使われていた模様。&lt;/p&gt;

&lt;h2 id=&#34;uefi:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;UEFI&lt;/h2&gt;

&lt;p&gt;UEFIはBIOSに代わるBasic I/O Systemらしいです。MBRの他、GPTもサポートします。GPTは &lt;strong&gt;MBR を使わず&lt;/strong&gt; 、EFI System Partitionなるものを使うらしいです。Think PadのBasic I/O Systemはこれだったようです。&lt;/p&gt;

&lt;h1 id=&#34;原因-対策-今後:4f443868b5278f746f06b6d7a35d2ab0&#34;&gt;原因、対策、今後&lt;/h1&gt;

&lt;p&gt;ということでUEFIがGPTを期待していたのにこちらはBIOS向けのMBRを用意していたのでダメだった模様。(いわゆる従来)BIOS画面(と呼ばれていたもの)に入って起動タイプをUEFIからLegacyにすることで起動出来ました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 可能ですよ。WindowsでもLinuxでもBSDでも、です。&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647688708661972992&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; gptgenなどを用いてパーティションをMBRからGPTに変換すること、FAT32のパーティションを作り(先頭パーティションであることが好ましい)パーティションタイプを0xEF00にすること、そしてブートローダーをそのパーティションにインストールする&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647692419090112512&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 以上があらましになります。FAT32のこのパーティションはEFI System Partition, ESPと呼ばれ、従来ファイルシステムから不可視な先頭セクタにインストールされていたブートローダーはただの実行ファイルとしてESPに置かれます&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647692825853755392&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; ブートローダーをESPに入れる手段としては、ArchWikiのUEFIの項をご覧ください。また、この時efibootmgrコマンドを用いてブートローダーのパスをUEFIに記録させておくと、UEFIのブートデバイス選択画面にブートローダーが出現します。&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647693202737098757&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; GRUBの場合efibootmgrコマンドを使うべき操作は自動でしてくれます。&lt;/p&gt;&amp;mdash; orumin (@kotatsu_mi) &lt;a href=&#34;https://twitter.com/kotatsu_mi/status/647693310149025792&#34;&gt;2015, 9月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;とのことですがまあ、SSDの先頭のスペース空いてないしちょっとミスったら即死だしどうしましょうね。
一旦SSDの中身を元のHDDに退避してSSDにUEFIで起動するパーティション作ってそのパーティションに元のパーティションをddでコピーとかで出来ますかね…&lt;/p&gt;

&lt;p&gt;サルでも分かる操作マニュアルが欲しい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>isucon にCommon Lispチームで出た</title>
      <link>http://keens.github.io/blog/2015/09/27/isucon_nicommon_lispchi_mudedeta</link>
      <pubDate>Sun, 27 Sep 2015 23:58:24 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/09/27/isucon_nicommon_lispchi_mudedeta</guid>
      <description>

&lt;p&gt;κeenです。 &lt;a href=&#34;isucon.net&#34;&gt;isucon&lt;/a&gt; に&lt;a href=&#34;https://twitter.com/i/notifications?lang=ja&#34;&gt;@nitro_idiot&lt;/a&gt;(深町さん)と&lt;a href=&#34;https://twitter.com/Rudolph_Miller?lang=ja&#34;&gt;@Rudolph_Miller&lt;/a&gt;のCommon Lispチームで出てきました。チーム名clfreaks。勿論Common Lispで再実装しました。&lt;/p&gt;

&lt;p&gt;因みに深町さんは今回使ったWebサーバーのwooを含めCommon Lispのライブラリを多数公開している&lt;a href=&#34;http://github-awards.com/users/search?login=fukamachi&#34;&gt;世界一のCommon Lisper&lt;/a&gt;、ルドルフさんは元Common Lispの会社のCTO。&lt;/p&gt;

&lt;h1 id=&#34;前日:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;前日&lt;/h1&gt;

&lt;p&gt;κeen 「あとはwooがunixソケット使えたら嬉しいんですがまあ、いいでしょう。」&lt;br /&gt;
fukamachi 「今からやれば明日には間に合うな」&lt;br /&gt;
fukamachi 「ローカルでは一応動いた。間に合いそうである」&lt;br /&gt;
fukamachi 「5倍ちょっとくらい速いかな」&lt;/p&gt;

&lt;p&gt;この間1時間半足らず。&lt;/p&gt;

&lt;p&gt;κeen 「練習してて気付いたんですけどデプロイツールってどうしましょう。」&lt;br /&gt;
fukamachi 「κeenさんが使い慣れてるツールで良いです」&lt;br /&gt;
κeen 「シェルスクリプトかー。」&lt;br /&gt;
fukamachi 「やめろ」&lt;/p&gt;

&lt;p&gt;結局capistranoを使うことに。&lt;/p&gt;

&lt;h1 id=&#34;当日の作業:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;当日の作業&lt;/h1&gt;

&lt;p&gt;私がマシン立ち上げてソースをgitに上げるまでやる。残りの二人はソースを読む、私はNginXやMySQLやCapistranの基本設定をする。&lt;/p&gt;

&lt;h2 id=&#34;午前中-common-lispでの再実装:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;午前中 Common Lispでの再実装&lt;/h2&gt;

&lt;p&gt;ルドルフさんが見付けた遅い部分を書き出し、深町さんがCommon Lispの実装を進める。&lt;/p&gt;

&lt;p&gt;私がmysqlの設定をするもなぜか反映されずに詰まる。ルドルフさんと一緒にやるも数時間やっても解決せず。結局新しいインスタンスを立ち上げたら動いた。my.cnfにsym linkを貼ったのが問題だったよう。/etc/my.cnfの問題ではない。&lt;/p&gt;

&lt;h2 id=&#34;午後-実装を進めつつチューニング:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;午後 実装を進めつつチューニング&lt;/h2&gt;

&lt;p&gt;私の方がどうにかなったのでルドルフさんも実装をすすめる。私はインデックスを張ろうとしてalterが帰ってこなくて諦めたりどうせ使わないけどunicornのワーカー数を増やして気分だけでもスコアを上げたりN+1クエリをJOINで書き直したり。&lt;/p&gt;

&lt;h2 id=&#34;comon-lispの実装がとりあえず終了:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;Comon Lispの実装がとりあえず終了&lt;/h2&gt;

&lt;p&gt;バグは残ってる、と言われつつCL実装をmasterにマージしたのがgitのログを見るに15:28。そこからデバッグ。色々ハマったりライブラリにバグがあったり（深町さんのライブラリだったのでその場でbug fix）してログイン処理が通ったのが17時くらい？そこからベンチマークを走らせるとまたtypoとかのバグがあってちまちま直していくも結局間に合わず0点のままFINISH。&lt;/p&gt;

&lt;h1 id=&#34;反省とか:b63483bc4957736680c2a5e5d35a6d40&#34;&gt;反省とか&lt;/h1&gt;

&lt;p&gt;思ったよりアプリケーションが重厚で再実装に時間取られすぎたなー、が一番。あとMysqlの設定でハマったのは本当にやりたくなかった。&lt;/p&gt;

&lt;p&gt;ベンチマーク走らせるとデータが溜まることに気付かずに大分走らせた後でインデックスを張ろうとしたら20分くらい待っても帰ってこなかったのでインデックスを諦めた。なのでruby実装のスコアも800点くらい。
やろうとしたことはN+1クエリを消すとかuserをメモリに載せるとか。&lt;/p&gt;

&lt;p&gt;かなり苦い思いはしたけどCommon Lispに足りないものとか今後の課題とかも見えたし出た価値はあったと思う。例えばデプロイの度にコンパイルが走るが、コンパイルの重いライブラリを使ってるとデプロイが遅くなるので並列ビルド欲しいよね、とか。ただ、大きな目的だったWeサーバーのチューニングまではいけなかった。&lt;/p&gt;

&lt;p&gt;今年は知り合いと出ちゃったので来年は知らない人とチームを組もうかと。&lt;/p&gt;

&lt;p&gt;運営、出題の方々、お疲れ様でした。来年こそは本戦出ます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rust初心者へのガイド</title>
      <link>http://keens.github.io/blog/2015/09/23/rustwokakutokinochiken</link>
      <pubDate>Wed, 23 Sep 2015 22:43:14 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/09/23/rustwokakutokinochiken</guid>
      <description>

&lt;p&gt;シルバーウィークの進捗が芳しくなかったので雑な記事書いてお茶を濁しとく。rustをそれなりに（といっても1000行くらい）書いて溜まった知見をとりあえず出す。rust1.3時点。&lt;/p&gt;

&lt;p&gt;最初の方で熱く語ってるが多くの人にとって欲しい情報は下の方にあると思う。&lt;/p&gt;

&lt;h1 id=&#34;どんな言語:64b642c20ac103c85395c6858549d1b9&#34;&gt;どんな言語&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;から持ってくるとこんな感じ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;zero-cost abstractions

&lt;ul&gt;
&lt;li&gt;C++くらいの性能と思えばいい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;move semantics

&lt;ul&gt;
&lt;li&gt;他にはない難しい概念。しかしこれのおかげで様々な機能を教授出来る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;guaranteed memory safety

&lt;ul&gt;
&lt;li&gt;move semanticsにより安全でない操作はコンパイル時に弾ける。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;threads without data races

&lt;ul&gt;
&lt;li&gt;move semanticsその他により安全でない操作は(ry&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;trait-based generics

&lt;ul&gt;
&lt;li&gt;継承ベースとは違って開いている。型を定義した後に機能を追加出来る。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;pattern matching

&lt;ul&gt;
&lt;li&gt;便利だよねー。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;type inference

&lt;ul&gt;
&lt;li&gt;(超)重量級言語ながらタイプ数は少なめ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;minimal runtime

&lt;ul&gt;
&lt;li&gt;move semanticsのお陰でGCがないので本当に小さい。hello, worldが277KBだった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;efficient C bindings

&lt;ul&gt;
&lt;li&gt;ABI的に良い感じなのでブリッジングコストがほぼない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて、ここでは足りないことを書いておくと、現在Mozillaで開発されている言語で、LLVMバックエンドのネイティブコンパイル言語。LLVMにトラウマがある人もバイナリ配布されているので気軽に使える。
rustを使った大きなプロジェクトはレンダリングエンジンの&lt;a href=&#34;https://github.com/servo/servo&#34;&gt;Servo&lt;/a&gt;がある。&lt;/p&gt;

&lt;p&gt;レンダリングエンジンに使われているだけあって対応OS/アーキテクチャは広く、iOSやAndroidでも動く。C FFIもC APIもある。&lt;/p&gt;

&lt;p&gt;コミュニティは非常に活発で、インフラやライブラリは一通り揃った感じはする。マイナー言語を見てきた身としては1000ライラリくらい集まると一通りのことは出来るようになるかな、と思っているがrustは若い言語ながら3000ある。増えるペースも速いので欲しいものはまずあると思っていい。&lt;/p&gt;

&lt;p&gt;長らくAPIの破壊的変更をガンガンやる時期があって、1ヶ月前のhello worldが動かないとかもザラだったが2015年5月に1.0が出て以来見違えたように大人しくなって人が増え始めている。APIについてはunstable, stableだとかのラベルを付けるようになったので安心して使える。&lt;/p&gt;

&lt;p&gt;開発フローについてはFirefoxと同じく6週間毎に上流から新しいバージョンが降ってくる。ので今はもう1.3が出ている。1.0から1.3はコンパイル/実行時のパフォーマンス改善が主。新しい機能はPythonのPEPみたいにRFCで管理している。&lt;/p&gt;

&lt;p&gt;所有権や生存期間など新しい概念を導入していてとっつきにくいがこれらの概念のお陰で並列化しても安全だし、何よりメモリ管理を静的に解決出来るのでGCがなくてパフォーマンスが出るわ安定するわStop the Worldがないわで非常に良い言語。個人的にはデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。&lt;/p&gt;

&lt;p&gt;何指向言語かと言われると難しい。安全指向？継承はないがオブジェクト指向といえばそうだし函数型っぽくなくもない。並行を意識して作ってあるから並行指向と言えなくもない。継承を止めたC++のような所有権と副作用を入れたHaskellのような言語。副作用はバリバリ使うのであまり函数型言語として見ない方が幸せになれると思っている。&lt;/p&gt;

&lt;p&gt;traitがどんなものかというとHaskellの型クラスに（多分）同じ。しかもHaskellの&lt;code&gt;deriving Show&lt;/code&gt;みたいに&lt;code&gt;#[derive(Debug)]&lt;/code&gt;とかも書ける。便利。&lt;/p&gt;

&lt;p&gt;生存期間と所有権がどういうものかというと、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let foo = Foo::new(1);
println!(&amp;quot;{:?}&amp;quot;, foo);
let foo = Foo::new(2);
println!(&amp;quot;{:?}&amp;quot;, foo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;foo&lt;/code&gt;を&lt;code&gt;Foo::new(2)&lt;/code&gt;にバインドした時、&lt;code&gt;Foo::new(1)&lt;/code&gt;は所有者が居なくなるのでその時点で開放される。GCと違う点は、GCはその時点ではゴミになるだけで、次にGCが走った時にようやく開放されるが、rustはその場で開放される、&lt;code&gt;free&lt;/code&gt;を自動で挟む。そうなると、コンパイラは最適化で同じサイズを&lt;code&gt;free&lt;/code&gt;してまたアロケートするのを同じ領域を使うようにする筈だ。これで領域の節約とかアロケーションコストの節約の他に、「今使った」メモリを再利用出来るのでキャッシュに載ったままメモリを使える。ここまでの効率化を「自動で」やってくれるのはrustだけではないかと思っている。&lt;/p&gt;

&lt;p&gt;このように素晴しい言語機能があってコミュニティも活発で安定した言語なので流行ればいいなと思っている。とはいっても気軽に書ける言語ではないのであらゆる所で使われる言語とは思っていない。先に言ったようにデータベースとかのパフォーマンスと信頼性が必要なミドルウェアを書くのに向いてるのではと思っている。goがnext Cならrustはnext C++かな、と。&lt;/p&gt;

&lt;p&gt;rustは難しい。学習曲線が急峻だ。しかし手を動かしてその急峻な崖を乗り越えるだけの価値はある言語だと思うので是非試してみて欲しい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、情報セクションだ。&lt;/p&gt;

&lt;h1 id=&#34;ドキュメント:64b642c20ac103c85395c6858549d1b9&#34;&gt;ドキュメント&lt;/h1&gt;

&lt;h2 id=&#34;入門:64b642c20ac103c85395c6858549d1b9&#34;&gt;入門&lt;/h2&gt;

&lt;p&gt;trplと略される&lt;a href=&#34;https://doc.rust-lang.org/stable/book/&#34;&gt;The Rust Programming Language&lt;/a&gt;を読むととりあえず基本的な概念を一通り学習出来る。&lt;/p&gt;

&lt;h2 id=&#34;書き始めた:64b642c20ac103c85395c6858549d1b9&#34;&gt;書き始めた&lt;/h2&gt;

&lt;p&gt;文法とかをサクっと確認したいなら&lt;a href=&#34;https://doc.rust-lang.org/stable/reference.html&#34;&gt;The Rust Reference&lt;/a&gt;がある。&lt;/p&gt;

&lt;p&gt;標準ライブラリを調べたいなら&lt;a href=&#34;https://doc.rust-blang.org/stable/std/&#34;&gt;APIドキュメント&lt;/a&gt;がある。一見分かりづらいが一番上に検索窓があるので全体検索が出来る。&lt;/p&gt;

&lt;p&gt;コード例が欲しいなら&lt;a href=&#34;http://rustbyexample.com/&#34;&gt;Rust by Example&lt;/a&gt;がある。&lt;/p&gt;

&lt;h1 id=&#34;軽く試す:64b642c20ac103c85395c6858549d1b9&#34;&gt;軽く試す&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://play.rust-lang.org/&#34;&gt;Rust Playground&lt;/a&gt;を使えばWeb上で試せる。質問とか投げる時にサンプルコードをここに載せて渡すと捗る。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:64b642c20ac103c85395c6858549d1b9&#34;&gt;開発環境&lt;/h1&gt;

&lt;h2 id=&#34;コンパイラ:64b642c20ac103c85395c6858549d1b9&#34;&gt;コンパイラ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;公式&lt;/a&gt;から簡単にバイナリ落としてこれる。Macだとbrewでも入った気がする。FreeBSDだとpkgで入る。Debianのパッケージも出来たらしい(&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;)がUbuntuにはまだ(&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;23&lt;/sub&gt;)きてない。すぐ来るだろう。&lt;/p&gt;

&lt;p&gt;しかし後述のracerのためにソースが必要なので別途ソースはダウンロードする必要がある。&lt;/p&gt;

&lt;h2 id=&#34;エディタ:64b642c20ac103c85395c6858549d1b9&#34;&gt;エディタ&lt;/h2&gt;

&lt;p&gt;Emacs, Vim, Atomだったら&lt;a href=&#34;https://github.com/phildawes/racer&#34;&gt;racer&lt;/a&gt;を使う。
racerのソースを持ってきてコンパイルしてエディタプラグインをエディタに入れてrustコンパイラのソース持ってきて2行設定書けば使える。ソース補完と定義元ジャンプがある。ちゃんと型を見て補完候補出してくれるし標準ライブラリのソースにもジャンプ出来るので中々便利。&lt;/p&gt;

&lt;p&gt;gofmtのrust版、&lt;a href=&#34;https://github.com/nrc/rustfmt&#34;&gt;rustfmt&lt;/a&gt;は開発版のコンパイラを持ってこないとコンパイル出来ないので私は諦めているが使いたい人は試すといいと思う。少なくともEmacs向けのプラグインはある。&lt;/p&gt;

&lt;h1 id=&#34;ビルドツール:64b642c20ac103c85395c6858549d1b9&#34;&gt;ビルドツール&lt;/h1&gt;

&lt;p&gt;コンパイラと一緒に配布される(FreeBSDのpkgでは別になってる)Cagroがある。雛形作成、依存解決、ビルド、テスト、ベンチマークなどのタスクが出来る。クロスコンパイルとかも。&lt;/p&gt;

&lt;h1 id=&#34;パッケージ管理:64b642c20ac103c85395c6858549d1b9&#34;&gt;パッケージ管理&lt;/h1&gt;

&lt;p&gt;クライアント側はCargo。セントラルレポジトリ的なのは&lt;a href=&#34;https://crates.io/&#34;&gt;crates.io&lt;/a&gt;。crates.ioに登録されてなくてもCargoはgitから取ってくるとかも出来るので野良パッケージも使える。&lt;/p&gt;

&lt;h1 id=&#34;テスト:64b642c20ac103c85395c6858549d1b9&#34;&gt;テスト&lt;/h1&gt;

&lt;p&gt;関数に&lt;code&gt;#[test]&lt;/code&gt;アノテーションを付ければ良い。つまり、ソースとテストを同じファイルに書ける。結構便利。テスト用ビルドでのみコンパイルされて他のビルドだと無視される（と思う。）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn fib(n:isize) -&amp;gt; isize{
    if n &amp;lt; 2 {
       1 
    }
    else {
        fib(n - 1) + fib(n - 2)
    }
}

#[test]
fn test_fib(){
    assert(fib(1) == 1);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;これ便利とかここ躓いたとか。&lt;/p&gt;

&lt;h1 id=&#34;所有権:64b642c20ac103c85395c6858549d1b9&#34;&gt;所有権&lt;/h1&gt;

&lt;p&gt;分かってたけどやっぱり躓いた。局所的には「あ、ここ所有権必要だわ」とか分かるのだが大域的には難しい。&lt;/p&gt;

&lt;p&gt;例えばボトムアップで作っていくと、小さな関数で所有権が必要だがそれを呼び出そうとしたら呼出元が所有権を持っていなくて困るとか。小さな値とか状態を持たない値だったら&lt;code&gt;clone&lt;/code&gt;して渡すのだがそうでなければ手戻りが発生する。この辺は実際に書いて経験を積むしかなさそう。&lt;/p&gt;

&lt;p&gt;因みに代数的データ型と所有権でも困っている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
enum Value {
   Str(String),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とかすると&lt;code&gt;Str&lt;/code&gt;データコンストラクタがStringの所有権を持っているのでパターンマッチで取り出す時に所有権が貰えず、&lt;code&gt;match{Value::Str(ref str) =&amp;gt; ...,}&lt;/code&gt;と、&lt;code&gt;ref&lt;/code&gt;を使って借りるしかない。&lt;/p&gt;

&lt;p&gt;まだ経験が足りないので困ったまま。&lt;/p&gt;

&lt;h1 id=&#34;サイズ:64b642c20ac103c85395c6858549d1b9&#34;&gt;サイズ&lt;/h1&gt;

&lt;p&gt;rustはコンパイル時にメモリ管理を決定するのでコンパイル時にデータのメモリサイズが決まってないといけない。例えば以下のコードはコンパイルが通らない。Bazにおいて、fooのサイズが決定出来ないと言われる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Foo {

}


struct Bar {
}

impl Foo for Bar {

}


struct Baz {
  foo: Foo
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;Foo&lt;/code&gt;はただのインターフェースの定義であって、データを定義してないので実際にFooを実装したデータ型のサイズが分からないからだ(今後変更がある模様。)。次のようにパラメータにすれば解決出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Baz&amp;lt;T&amp;gt; {
  foo: T
}

impl &amp;lt;T:Foo&amp;gt; Baz&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに元の定義とは変わってデータの時点ではTで、implを書く時にFooに絞っているのは不要な所では不要な条件を付けないようにしているからだろうか。
変な値を入れられて困りそうだが、構造体のフィールドを公開しなければ勝手に値が作られることはなく、impl内に書いたコンストラクタを通してのみ値が作られるので心配無用である。&lt;/p&gt;

&lt;h1 id=&#34;t-と-vec-t-str-と-string:64b642c20ac103c85395c6858549d1b9&#34;&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt;と&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;str&lt;/code&gt;と&lt;code&gt;String&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;使い分けは&lt;a href=&#34;http://qiita.com/kondei/items/4a3496786fce0c1a1b43&#34;&gt;Rustの文字列のガイド - Qiita&lt;/a&gt;を見て欲しいが、相互変換で困ることがあったので。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;String&lt;/code&gt;から&lt;code&gt;&amp;amp;str&lt;/code&gt;に変換する時に「&lt;code&gt;as_slice&lt;/code&gt;はunstable」と言われる。こうしてやれば良いようだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let string = &amp;quot;String&amp;quot;.to_string();
let lent_str = &amp;amp;string[..]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vectorも同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let vector = vec![1, 2, 3];
let lent_slice = &amp;amp;vector[..]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hashmap:64b642c20ac103c85395c6858549d1b9&#34;&gt;HashMap&lt;/h1&gt;

&lt;p&gt;所有権周りで困る。例えば次のコードはコンパイルが通らない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;match hash.get(key) {
    Some(v) =&amp;gt; v,
    None =&amp;gt; {hash.insert(key, default); default}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matchの中でhashがborrowされてると判断されるのでNone節でhashにinsert出来ない。&lt;a href=&#34;http://stackoverflow.com/questions/28512394/how-to-lookup-from-and-insert-into-a-hashmap-efficiently&#34;&gt;ワークアラウンド&lt;/a&gt;
もあるが、どう考えてもイケてないので&lt;a href=&#34;http://blog.rust-lang.org/2015/08/14/Next-year.html&#34;&gt;改善される模様&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;データ型と参照:64b642c20ac103c85395c6858549d1b9&#34;&gt;データ型と参照&lt;/h1&gt;

&lt;p&gt;データ型の中で参照を使いづらい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Value {
   Str(&amp;amp;str),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、怒られる。&lt;code&gt;&amp;amp;str&lt;/code&gt;は自分の物ではないので生存期間が分からないからパラメータで受け取らないといけない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct &amp;lt;&#39;a&amp;gt;Value&amp;lt;&#39;a&amp;gt; {
   Str(&amp;amp;&#39;a str),
   Int(isize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、やはり所有権を持っていないので次のようなメソッドを定義出来ない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl &amp;lt;&#39;a&amp;gt;Value&amp;lt;&#39;a&amp;gt; {
    fn empty_str() -&amp;gt; &amp;lt;&#39;a&amp;gt; {
        Value::Str(&amp;quot;&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…と思ったらなんか出来ちゃった。今まで使い方が悪かったのかも。これはナシ。&lt;/p&gt;

&lt;h1 id=&#34;モナド:64b642c20ac103c85395c6858549d1b9&#34;&gt;モナド&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/TeXitoi/rust-mdo&#34;&gt;mdo&lt;/a&gt;というdo記法っぽく書けるマクロがあるがクロージャを作るとそのクロージャが変数の所有権を持っていって面倒だったのでそんなに良くなかった。optionモナドに関しては素直にmapとandThenを使った方が良い。&lt;/p&gt;

&lt;h1 id=&#34;try:64b642c20ac103c85395c6858549d1b9&#34;&gt;try!&lt;/h1&gt;

&lt;p&gt;rustのコードでは至る所でResult(Either)型が返ってくる。それに対して毎回パターンマッチするのはやってられない。かといって安全でない&lt;code&gt;unwrap()&lt;/code&gt;を各所で使うのも精神衛生に良くない。Errに対してunwrapを使うとpanicになるが、rustにはpanicをハンドルする方法はない。&lt;/p&gt;

&lt;p&gt;そこで&lt;code&gt;try!&lt;/code&gt;。返り値がErrだったらそのままErrで関数から抜け、Okだったらその値を返すマクロ。多分展開結果はこんな形になってる:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = try!(foo());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let v = match foo() {
   Ok(v) =&amp;gt; v,
   e @ Err(_) =&amp;gt; return e
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;。&lt;/p&gt;

&lt;p&gt;これの逆、成功したらその値で抜け、ErrだったらErrを返して処理を継続するやつとかオプション版とかも欲しい。&lt;/p&gt;

&lt;h1 id=&#34;最後に:64b642c20ac103c85395c6858549d1b9&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;Lisp処理系作ろうとしたけど完成しなかったのでそっとここに置いときますね&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/KeenS/kappaLisp&#34;&gt;κLisp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>xhyveでFreeBSD guestを動かす</title>
      <link>http://keens.github.io/blog/2015/09/16/xhyvedefreebsd_guestwougokasu</link>
      <pubDate>Wed, 16 Sep 2015 21:55:25 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/09/16/xhyvedefreebsd_guestwougokasu</guid>
      <description>

&lt;p&gt;久しぶりですね。κeenです。最近はMacでもまともな仮想環境が整ってきたのでFreeBSDでも動かすかーといって試したやつを共有します。&lt;/p&gt;

&lt;p&gt;大部分は&lt;a href=&#34;http://blog.holidayworking.org/entry/2015/06/27/xhyve_%E3%81%A7_FreeBSD_%E3%82%92%E5%8B%95%E3%81%8B%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F&#34;&gt;ここ&lt;/a&gt;を参考にしてますが、ちゃんと動きます。&lt;/p&gt;

&lt;h1 id=&#34;xhyveとは:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;xhyveとは&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pagetable.com/?p=831&#34;&gt;xhyve – Lightweight Virtualization on OS X Based on bhyve | pagetable.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;FreeBSDのBHyVeをMac OS Xに移植したものです。Intel CPUの仮想化フレームワークを使うことで仮想化の実装が（比較的）が楽になるからやろうぜってプロジェクトです。
カーネルレベルでのサポートが必要になりますがyosemiteからHyervisor.frameworkが入っているのでそれが使えます。&lt;/p&gt;

&lt;p&gt;因みに開発はそんなに活発ではないです。&lt;/p&gt;

&lt;h1 id=&#34;動かす:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;動かす&lt;/h1&gt;

&lt;h2 id=&#34;xhyveの準備:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;xhyveの準備&lt;/h2&gt;

&lt;p&gt;FreeBSDのサポートは既にマージされているのでcloneしてきてそのまま使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone git@github.com:mist64/xhyve.git
cd xhyve
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FreeBSDのイメージの入手
イメージは現在10.2が出ているので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;fetch http://ftp.freebsd.org/pub/FreeBSD/releases/VM-IMAGES/10.2-RELEASE/amd64/Latest/FreeBSD-10.2-RELEASE-amd64.raw.xz
unxz FreeBSD-10.2-RELEASE-amd64.raw.xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で入手出来ます。&lt;/p&gt;

&lt;h2 id=&#34;起動スクリプトの準備:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;起動スクリプトの準備&lt;/h2&gt;

&lt;p&gt;参照ブログのままだとハードディスクが読めないのでIMG_HDDにもイメージを指定します。&lt;/p&gt;

&lt;p&gt;名前は何でも良いのですが&lt;code&gt;freebsd.sh&lt;/code&gt;として保存し、&lt;code&gt;chmod +x freebsd.sh&lt;/code&gt;します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh

USERBOOT=&amp;quot;test/userboot.so&amp;quot;
BOOTVOLUME=&amp;quot;FreeBSD-10.2-RELEASE-amd64.raw&amp;quot;
KERNELENV=&amp;quot;&amp;quot;

MEM=&amp;quot;-m 1G&amp;quot;
#SMP=&amp;quot;-c 2&amp;quot;
#NET=&amp;quot;-s 2:0,virtio-net&amp;quot;
#IMG_CD=&amp;quot;-s 3,ahci-cd,/somepath/somefile.iso&amp;quot;
IMG_HDD=&amp;quot;-s 4,virtio-blk,$BOOTVOLUME&amp;quot;
PCI_DEV=&amp;quot;-s 0:0,hostbridge -s 31,lpc&amp;quot;
LPC_DEV=&amp;quot;-l com1,stdio&amp;quot;
#UUID=&amp;quot;-U deadbeef-dead-dead-dead-deaddeafbeef&amp;quot;

build/xhyve -A $MEM $SMP $PCI_DEV $LPC_DEV $NET $IMG_CD $IMG_HDD $UUID -f fbsd,$USERBOOT,$BOOTVOLUME,&amp;quot;$KERNELENV&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;起動:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;起動&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./freebsd.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で起動します。&lt;/p&gt;

&lt;h1 id=&#34;その他:4a68f71d07908fb1bb9329656bb2afc9&#34;&gt;その他&lt;/h1&gt;

&lt;p&gt;FreeBSDのイメージを一杯作りたい人はダウンロードしてきたやつを&lt;code&gt;cp&lt;/code&gt;して使うと良いと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ISUCONこれまでの流れ</title>
      <link>http://keens.github.io/slide/ISUCONkoremadenonagare/</link>
      <pubDate>Fri, 04 Sep 2015 08:47:05 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/ISUCONkoremadenonagare/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# ISUCONこれまでの流れ
----------------------
雑に書き殴った
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + ISUCON3、 4の予選、本戦に出場（学生枠）

# ISUCON1 ブログ
---------------

* node perl ruby
* kazeburoの罠
* ブログのサイドバーが重いやつ
* 割と親切なルール


# ISUCON2 チケット予約サイト
---------------------------

* perl ruby node php java python
* 席ランダムにしてなくてもベンチマーカー通っちゃう
* 変更が1秒以内に反映されていること → 0.9秒毎に裏でバッチを回す
* JOINが3連になってる所があってみんなそこに引っ掛かったがボトルネックはそこじゃない
* ちょっとルールが雑になった


# ISUCON3予選 スニペット投稿サイト
--------------------------------
* go node perl python ruby php
* AWS1台
* Markdown変換がperl製の重いやつ
* AWSだとプロセスのフォークも重い
* titleの抜き出しも重い
* チェッカーが甘くてVarnishを導入しただけで点数爆上がり
* SQLの典型問題とかも
* workloadに気付かなかった人多数
* 学生枠が出来た
* ベンチマーカが通れば何でもアリな風潮


# ISUCON3本戦 画像SNS
--------------------
* go node perl python ruby
* オンプレ5台
* 画像の変換が重い
* 実は帯域もつらい
* 画像のチェッカがあってチェッカが通れば画質を落としても良かった
* 組長の罠
* ベンチマーカーに通れば何でもアリ
* 複数サーバーでのファイルの共有にWebDAVが盲点
* 点数計算の罠に嵌まる人多数
  + 基本点より追加点に目が眩む人がそれなりに
* 推測するな計測せよ
* nodeで初期パスワードが間違っているトラブル


# ISUCON4予選 銀行
--------------------------------------

* go node perl php python ruby
* AWS1台
* ワークロードを桁外れに指定するとベンチマーカーが走り続けるバグ
* ベンチマーカーにアクセスして行動パターンを解析した人が出る（その情報は使ってない。スポーツマンシップ。）
* テンプレートエンジンをやめて静的ファイル
* Go勢のon memory戦略が跋扈
* 「メモリに載せれば勝てるぜ」風潮
* 静的ファイルを返さない反則ギリギリのチューニング
* ベンチマーカーのチューニング
* Varnish潰し
* アプリをC++で書き換えて予選突破したチームも出る


# ISUCON4本戦 動画広告
----------------

* go perl php python ruby
* オンプレ3台
* 最初からRedisに動画が載ってる
* それ外したらスコア頭打ち(帯域がつまる)
* ベンチマーク同士が干渉しあう
* 実はCache-Controlをしたらスコアが爆上がり(上位2チームだけ気付いた)
* 3位のチームは外向きと内向きの2枚のNICを使って団子状のスコアから頭1つだけ出た


#ISUCON5予選 ???
----------------
* perl ruby node php python go java (scala)
* GCP 
* 今までの予選だとベンチマーカが競技者の手元に渡る問題があった。
* かといって外部からのベンチマークは安定しない。
* GCPならGoogleの謎の技術によって安定するらしい。
* @tagomoris 「もはやISUCONは予選で落ちる人の方が多くなった。その人達にとっては予選こそがISUCONなのだ」
  
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>SMLでPNGデコーダを作ろうとして分かったこと</title>
      <link>http://keens.github.io/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</link>
      <pubDate>Fri, 04 Sep 2015 06:45:19 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/SMLdePNGdeko_dawotsukuroutoshitewakattakoto/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# SMLでPNGデコーダを作ろうとして分かったこと
------------------------------------------
サイバーエージェント アドテクスタジオ  
エンジニア月初会
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
----------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + AMoAdの新卒
 + Lisp, ML, Shell Scriptあたりを書きます


&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うーむ。画像フォーマットの扱い一回くらい書いてみないとなーと思ってたけどやっぱり既存なんだよなー。Common LispかSMLあたりならフロンティアになれそう。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639303085240643584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; 仕様を理解するためにデコーダから実装するのがオススメです&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639304790766305281&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; そんな詳しいわけではないんですが、jpegかpngがおすすめです。webpは動画コーデック由来で難しいと思います。tiffは画像コンテナみたいな立ち位置なので画像フォーマット感がないかなと。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/639307400244137984&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

明日の朝までに  
&lt;span style=&#39;font-size:150%;&#39;&gt;SMLでpngデコーダを実装しよう&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# Standard ML
-------------

* ML系の函数型言語
* 文法はOCamlよりF#に似てる（というかF#が似せてきた）
* 結構書き易い
* 仕様は SML&#39;90とSML&#39;97がある
* 仕様で言語のformal semanticsが定められてたりする
* 要は研究向き
  + **ライブラリほぼなし**
  + **コミュニティほぼなし**


&lt;span style=&#39;font-size:250%;&#39;&gt;＞　無理ゲー　＜&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 一応フォーマットを調べる
------------------------


```
+-----------------+
|     Chunk       | 画像はChunkの集合。
++---------------++ Chunk自体は簡単なフォーマット
|| length | name ||
|+---------------+|
||    data       ||
||    ...        ||
|+---------------+|
||    CRC        ||
++---------------++
|    Chunk        |
|    ...          |
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
意外と単純？
&lt;/span&gt;


&lt;!-- .slide: class=&#34;center&#34; --&gt;

# とりあえず書いてみる
---------------------

```sml
structure PNG = struct
    fun readChunk data i = ...
end
```


# 案外苦戦
------------
* 型が厳密なので型の行き来が面倒
  + 8bit &lt;-&gt; 32bit
  + 符号付き &lt;-&gt; 符号無し
  + byte &lt;-&gt; char

```sml
val op &lt;&lt; = Word.&lt;&lt;
val op &gt;&gt; = Word.&gt;&gt;

fun nameToWord name = CharVector.foldl (fn(c, acc) =&gt; &lt;&lt;(acc, 0w8) + (Word.fromInt (ord c))) 0w0 name
```


&lt;span style=&#39;font-size:250%;&#39;&gt;
3時間後
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;さて、メインのデータ抜き出すところまでは行ったけど次復号だ。&lt;/p&gt;&amp;mdash; κeen (@blackenedgold) &lt;a href=&#34;https://twitter.com/blackenedgold/status/639501771430211584&#34;&gt;2015, 9月 3&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 今更PNGについて
----------------

* GIFの特許問題を回避するために作られたフォーマット
  + LZ77がマズいらしい
* **可逆圧縮アルゴリズムを使う** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + **アルゴリズムは1つとは限らない** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
  + 但し仕様で指定されているのはzlibのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;
* フィルタを噛ませることでプログレッシブな表示も可能


# SMLのZLibライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
zlib……実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ZLib
------

* RFC-1950
* zipやpngで使われるフォーマット
* ZLib自体は圧縮データのコンテナで **圧縮アルゴリズム自体は1つとは限らない**  &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;
  + 但し仕様で指定されているのはdeflateのみ &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;--&gt;


# SMLのDeflateライブラリ
--------------------

* ない &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;span style=&#39;font-size:250%;&#39;&gt;
deflate…実装するか
&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# Deflate
---------

* RFC-1951
* ハフマン符号の変種の可逆圧縮アルゴリズム
  + **3種類の符号化方式を自由に使ってよい** &lt;!-- .element: class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;--&gt;



&lt;span style=&#39;font-size:250%;&#39;&gt;(心)ボキッ&lt;/span&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 学んだこと
-----------

* PNGは一晩でデコーダを書ける程柔じゃない
  + 事前調査も大事
* 書き易い言語でもコミュニティが大事
* 1晩でLTの準備はつらい


# 付録
------

* [今回のコード](https://github.com/KeenS/sml-png)
* [SMLのパッケージマネージャ](https://github.com/standardml/smackage)
* [PNG](http://www.w3.org/TR/2003/REC-PNG-20031110/)
* [RFC-1950 ZLIB](https://www.ietf.org/rfc/rfc1950.txt)
* [RFC-1951 DEFLATE](https://www.ietf.org/rfc/rfc1950.txt)
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Method Drawでお手軽LGTM生成</title>
      <link>http://keens.github.io/slide/Method_DrawdeotegaruLGTMseisei/</link>
      <pubDate>Fri, 14 Aug 2015 00:55:37 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/Method_DrawdeotegaruLGTMseisei/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;
# Method Drawでお手軽LGTM生成
----------------------

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバーエージェントのエンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# Method Draw
-------------

* シンプルなSVG エディタ
* オープンソース
* [editor.method.ac](http://editor.method.ac/)


# デモ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 以上
------
Have a happy hacking life
&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>構文解析にまつわる小話たち</title>
      <link>http://keens.github.io/slide/koubunkaisekiarekore/</link>
      <pubDate>Sat, 08 Aug 2015 04:16:50 +0900</pubDate>
      
      <guid>http://keens.github.io/slide/koubunkaisekiarekore/</guid>
      <description>&lt;section data-markdown
    data-separator=&#34;\n\n&#34;
    data-vertical=&#34;\n\n&#34;
    data-notes=&#34;^Note:&#34;&gt;
&lt;script type=&#34;text/template&#34;&gt;

# 構文解析にまつわる小話たち
----------------------
[#peg_study](https://twitter.com/search?q=%23peg_study&amp;src=typd&amp;vertical=default&amp;f=tweets)

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# About Me
---------
![κeenのアイコン](/images/icon.png) &lt;!-- .element: style=&#34;position:absolute;right:0;z-index:-1&#34; --&gt;

 + κeen
 + [@blackenedgold](https://twitter.com/blackenedgold)
 + Github: [KeenS](https://github.com/KeenS)
 + サイバエージェントの新卒エンジニア
 + Lisp, ML, Shell Scriptあたりを書きます


# ウォームアップ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文解析はバッドノウハウ
-------------------------

* プログラム言語を使っているなら既にパーサはある
  + 文法も定義されてる
* 目の前のパーサを使え
  + パーサAPIがある言語もある(Lispとか)
* そうでなくても内部DSLを考えろ
  + 内部DSLで解決出来ないときだけ構文解析

# 本質はAST
-----------

* 結局はASTになればどんな文法でも同じ
* 文法はただの外皮、欲しいのはAST
* シンタックスシュガーは飾り
  + DRY出来るなら別
* S式を使え
  + ASTをそのまま書き下せる


# AST First
-----------

* 最初にASTを考える。そして文法を考える
* 何が欲しいのかイメージし易くなる
* 構文解析はAST生成の自動化。普段してないことを自動化するのは愚か。
* 早めに間違いに気付ける
  + `+`は二項演算子。じゃあ `&amp;&amp;` は？ `=` は？

Note: Lispだと+は関数、andはマクロ、setqはスペシャルフォーム


# 構文解析の流れ

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文解析の流れ
---------------

1. Lexer generaterからlexerを作る
  + Lexとか
2. Parser generaterからparserを作る
  + yaccとか
  + BNFという記法
3. ソースファイルをlexerで処理してトークン化する
4. トークン列をparserで処理してASTを作る



```
         [Lexer]        [parser]
[Source]-------&gt;[Tokens]------&gt;[AST]
```

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# LexerとParserを分ける意味
--------------------------

* (上向き構文解析だと分けないとつらい)
* 役割の分担
  + 困難は分割せよ
* 文字列をシンボル化して比較が高速に
* 思考のフレームワークとして



&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;字句解析器手づくりの簡単さに対して構文解析器手づくりはわりと人を殺しにかかる&lt;/p&gt;&amp;mdash; gfn (@bd_gfngfn) &lt;a href=&#34;https://twitter.com/bd_gfngfn/status/578908166785671168&#34;&gt;2015, 3月 20&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 正規表現の使いどころ
---------------------

* 高速な実装がある
* 部品化しにくい
* 括弧の対応とか入れ子構造(`if .. then .. else`とか)は扱えない
  + perlの正規表現は厳密には正規表現ではない
* 構文解析には向かない
  + 「マッチ」は出来ても「抜き出し」は面倒
* Lexerには向いてる
  + トークン自体末端の部品なので部品化する必要がない

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;依存型のある言語でlexとか作ったら出てくるトークンの型変数に正規表現出てくるのかな&lt;/p&gt;&amp;mdash; eld-r-esh-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/597772476244885505&#34;&gt;2015, 5月 11&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;「bnf = (大雑把に言って)正規表現+括弧の対応」というのはchomsky–schützenbergerの定理という結構マニアックな定理(ドラゴンブックには載ってないと思う)をさらに僕なりに超訳したものなのであまり知られてないと思います．&lt;/p&gt;&amp;mdash; ryoma sin&amp;#39;ya (@sinya8282) &lt;a href=&#34;https://twitter.com/sinya8282/status/597465565654024192&#34;&gt;2015, 5月 10&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 構文クラス

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 構文クラス
------------

* 学術的だが知っておくと幸せになれる
* 文脈自由文法を解析するためのものを話す
  + 多くのプログラム言語は文脈自由文法
  + 正規言語 ⊂ 文脈自由文法
* 大きく分けると上向き構文解析と下向き構文解析
* 詳しくは[ドラゴンブック](http://www.amazon.co.jp/%e3%82%b3%e3%83%b3%e3%83%91%e3%82%a4%e3%83%a9%e2%80%95%e5%8e%9f%e7%90%86%e3%83%bb%e6%8a%80%e6%b3%95%e3%83%bb%e3%83%84%e3%83%bc%e3%83%ab-information-computing-a-v-%e3%82%a8%e3%82%a4%e3%83%9b/dp/478191229x)参照


# LL(1)
----

* 下向き
  + 再帰降下パーサ
* 定義した言語しか厳密に受け取らない
* 線形線形時間でパース可能
* 手書きに向く
* パーサーコンビネータとかも


# LR(1)
----

* 上向き
  + トークンをくっつけて構文要素に、構文要素をくっつけてさらに上の構文要素に…
* LL(n)⊂LR(n)
* LRそのものの解析は難しくて、いくつかサブクラスがある
  + 単純LR (SLR):  貧弱
  + 先読みLR (LALR): パーサジェネレータでよく使われる
  + 正準LR: 計算コストが高い。メモリ喰う
* 事前計算のコスト（面倒くささ）が高い
  + パーサジェネレータ


# LRパーサジェネレータ
-----

* 基本はBNF(Backus-Naur-Form)
* いくつか方式がある
  + 演算子順位解析も合わせる
    - EmacsのSMIEとか
  + BNFだけでやる
    - 別の言語も受理する可能性がある ドラゴンブック 上 p. 247
    - 普通は問題にならない


# LRの限界とか
-------------

* `-`の単項演算子と二項演算子の衝突
  1. SMLみたいに諦める(単項の`-`を`~`で表す)
  2. Lexerで区別する
* 左再帰で無限ループ
  + 手動でどうにか出来る
  + 自動でどうにかしてくれるジェネレータもある
* BNFの書き方によっては文法があいまいになる
  + `if .. then .. if .. then .. else ..` とか
  + 自動ではどうにもできないので気をつけるしかない


# BNFとパーサージェネレータの良さ
------------

* BNFは言語を定義する。
  + 言語仕様にも使われる
* 要は「仕様からプログラムを生成する」
* 宣言的


# 複数文法のサポートとグローバル変数の衝突
---------------------------------------

* 複数の文法をサポートしたい時がある
  + 独自記法と互換記法とか
* 雑なパーサジェネレータ/コンビネータを使っているとグローバル変数が衝突する
  + パーサライブラリの作者は配慮して下さい。


# 言語仕様の配慮
---------------

* LispはLL
* Java 1.0はLALR
  + 今はLALRではないらしい
* PrologはLALRだった気がする


# 非文脈自由文法
----------------

* 文脈を持つ（雑）
* ひねりなくパーサージェネレータ使っただけじゃ解析出来ない言語のこと。


## sedのs///
-----------

* 実は `s|||`のように区切文字は何でもいい
  + パスネームの置換に便利
* 対応関係が文脈で変わるので非文脈自由


## Markdown
-----------

* 元々のperlの実装は正規表現
  + 再帰を使っているので正規言語ではなく文脈自由文法
* GFMなどのTable記法はカラム数という文脈があるので非文脈自由
* Table記法をサポートする時は覚悟を持って。


# その他
--------

* 関数の仮引数の数と実引数の数の一致
* 変数の使用の前に変数宣言
* 要は構文解析で出来ることには限界がある。


# パーサの実際

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# 速度と手軽さ
--------------

* 外部DSLやコンフィグファイルだとパーサの速度は必要ない
  + メインループで使われないので起動時間にしか影響しない。
  + むしろ手軽に作れた方がいい
* HTTPだとかメインループで使うものはどうやってでも速くしたい
  + 労力は惜しまない

# 手書きとジェネレータとコンビネータ
----------------------------------

* 速度が必要ならジェネレータ
* LLでないならジェネレータ
* 手軽さが欲しいならコンビネータ
* 色々手を加えたいなら手書き…かも


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;パーサ手書きするのダサイよなぁ。クラスが分からなくなる。&lt;/p&gt;&amp;mdash; ELD-R-ESH-2 (@eldesh) &lt;a href=&#34;https://twitter.com/eldesh/status/597751470834855938&#34;&gt;2015, 5月 11&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ジェネレータの扱いにくさ
--------------------------

* あんまり人気ない気がする
* 2回も前処理必要なのダサいよね
* 新たな文法覚える必要がある
* そもそも作るのにもコストが高い
  + 言語の文法に合わせたプリンタ
  + 拡張性持たせると厄介
* かといって正規表現はやめましょうね

# DSLパーサジェネレータ
----------------------

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;PEGが正規表現と違って辛いところは言語組み込みじゃないのとワンライナーに向かないことなんだよな… &lt;a href=&#34;https://twitter.com/hashtag/peg_study?src=hash&#34;&gt;#peg_study&lt;/a&gt;&lt;/p&gt;&amp;mdash; わかめ@TypeScriptカッコガチ (@vvakame) &lt;a href=&#34;https://twitter.com/vvakame/status/629881217320550401&#34;&gt;2015, 8月 8&lt;/a&gt;&lt;/blockquote&gt; 

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# DSLパーサジェネレータ
----------------------

* あったらそれなりに人気出そう
* メタプログラミングが出来る必要がある
* Common Lisp
  + 作者自身作ってる途中でジェネレータとコンビネータを勘違いする
  + ドキュメントでジェネレータといってるのに実際はコンビネータだったりする
* D
  + なんか作ってる人いるらしい


# 複雑性と分かりやすさ
---------------------

&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;オーバーエンジニアリングを「あいつは力に溺れた」と言い変えていくといいと思う&lt;/p&gt;&amp;mdash; イカid:mizchi0x (@mizchi) &lt;a href=&#34;https://twitter.com/mizchi/status/565662999063838720&#34;&gt;2015, 2月 12&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# 複雑性と分かりやすさ
---------------------
* パーサが複雑な文法に対応出来ても人間が追い付かない
* 周辺のサポートも必要になるのでやっぱりシンプルな方が良い。
  + LRよりLL
  + S式とかシンプルの極み
  + [Clojureシンタックスハイライター開発から考えるこれからのlispに必要なもの](http://www.slideshare.net/sohta/clojurelisp?ref=http://athos.hatenablog.com/entry/2015/07/29/222535)
* 「出来る」と「した方がいい」は別の話


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;S式はどう考えても読み易い……&lt;/p&gt;&amp;mdash; Ocamlアイドル (@no_maddo) &lt;a href=&#34;https://twitter.com/no_maddo/status/590528791677546496&#34;&gt;2015, 4月 21&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;


&lt;blockquote class=&#34;twitter-tweet&#34; align=&#34;center&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;}]))みたいなのを書いてると、括弧が一種類の言語、いいなぁ、と思ったりします。&lt;/p&gt;&amp;mdash; mzp (@mzp) &lt;a href=&#34;https://twitter.com/mzp/status/587941717451481088&#34;&gt;2015, 4月 14&lt;/a&gt;&lt;/blockquote&gt;

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# ソースロケーション保持法

&lt;!-- .slide: class=&#34;center&#34; --&gt;


# ソースロケーション保持法
-------------------------

* エラーメッセージを出すためにはソースロケーションを保持する必要がある
* flymakeの情報: ファイル名、開始行/列 終了行/列 エラーメッセージ
  + 最悪これがあればどうにかなる
  + 「分かりやすい」メッセージはツールに任せる
* 字句解析だけでなく意味解析、さらにはつまるところコンパイルが終わるまで保存する必要がある
  + トークンやASTにメンバが増える
  + オブジェクト指向のカプセル化って素晴らしい


# 1. インクルード
----------------------

* トークンのデータに入れてしまうパターン
* `datatype token = Plus of int * int | Symbol of int * int * string` ...
* OOPなら自然だが函数型だとパターンマッチがつらくなる


# 2. ラップ
--------

* ロケーションのレコードでトークンをラップする
* `{start:int, end: int, token: token}`
* パターンマッチは少し楽になる
  + 多相レコードがないとそもそもレコードつらいけどな！！
* MLtonがやってるらしい


# 3. テーブル
-------------

* ロケーションテーブルを持って、トークンにはテーブルへのキーだけ持たせる
* トークンが軽くなるので速そう
* でも面倒そう


# エラー処理
&lt;!-- .slide: class=&#34;center&#34; --&gt;

# エラーメッセージ
------------------------

* 一応ロケーションがとれればエラー箇所は出せる。
* メッセージの親切さはツールとヒューリスティックと根気
* clangとか頑張ってる

```
ERROR: expected tEnd before &#39;&lt;EOF&gt;&#39;
each do {}
          ^
```


# エラー回復
-------------

* シンタックスハイライターは壊れた文法も解析しないといけない
* 1回のコンパイルでできるだけ多くのエラーメッセージを出したい
* シンタックスエラーから回復したい


# Cの易しさ
-----------

* エラーがあってもセミコロンまで読み飛ばせば回復出来る
  + CやJavaは結構コンパイラが教えてくれる
* そういう言語設計も大事


# 拡張方法

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# リードマクロ
--------------

* トークンレベルの拡張
* 特定の「文字」がきた時にユーザ定義関数を使ってパースする
* リテラルをユーザが定義することが出来る
  + 正規表現リテラルとか
  + [Common Lispの正規表現](http://weitz.de/cl-interpol/)


# マクロ
--------

* ASTレベルの拡張
* LispとかScalaとかRustとか
  + Lispは自由度が高い
  + 関数マクロはないよりマシ程度
* ~衛生性~
* [マクロについて整理してみる | κeenのHappy Hacκing Blog](http://keens.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru/)


## Cのマクロ
------------

* プリプロセッサなのでコンパイラの拡張ではない
* プリプロセッサ自体レキサを持つ
  + パーサとレキサを分ける意味
* ASTに関知しないのでやりたい放題


# 中置演算子
-----------

* 新しい中置演算子と優先順位を定義できる言語は多い
  + Haskell, SML, Prolog…
* パーサをその場で書き換えるのは難しいので後で処理する
  + [\[コンパイラ\]\[Haskell\]\[OCaml\] Haskellのinfixの仕組み - mad日記](http://d.hatena.ne.jp/MaD/touch/20090108)
* シンタックスのプラグインをセマンティクスに入れてるのでちょっと無茶


# 中置演算子
-----------

* 人間が同時に覚えられるのは3つまで
  + 優先順位がいくつもあっても覚えられない
  + 優先度40とか900とか無理。
* 本質はAST
  + 文法に問題を抱えるくらいならS式を使え


# Coq
-----

Coqは謎のテクノロジーにより `Notation`を使えば新しい文法を定義出来る

```coq
Notation &#34;&#39;SKIP&#39;&#34; :=
  CSkip.
Notation &#34;X &#39;::=&#39; a&#34; :=
  (CAss X a) (at level 60).
Notation &#34;c1 ; c2&#34; :=
  (CSeq c1 c2) (at level 80, right associativity).
Notation &#34;&#39;WHILE&#39; b &#39;DO&#39; c &#39;END&#39;&#34; :=
  (CWhile b c) (at level 80, right associativity).
Notation &#34;&#39;IFB&#39; e1 &#39;THEN&#39; e2 &#39;ELSE&#39; e3 &#39;FI&#39;&#34; :=
  (CIf e1 e2 e3) (at level 80, right associativity).

Definition fact_in_coq : com :=
  Z ::= AId X;
  Y ::= ANum 1;
  WHILE BNot (BEq (AId Z) (ANum 0)) DO
    Y ::= AMult (AId Y) (AId Z);
    Z ::= AMinus (AId Z) (ANum 1)
  END.
```
  

# 雑な話題

&lt;!-- .slide: class=&#34;center&#34; --&gt;

# テスト
-------

* ASTのテストは案外難しい
  + 微妙な仕様変更で結果が変わる
  + でも言語の動作には関係なかったり

1. あきらめる
2. 不屈の精神でテストを直し続ける
3. 木に対するクエリ言語を使う


# 先読みと副作用
--------------

* 先読みしてバックトラックすると副作用があった時に困る
  1. 副作用を許さない
  2. 副作用は自己責任
  3. 一旦先読みで正しいパスを記憶してから正しいパスでもう一度パース
&lt;/script&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ファイル削除コマンド色々</title>
      <link>http://keens.github.io/blog/2015/07/05/fairusakujokomandoiroiro</link>
      <pubDate>Sun, 05 Jul 2015 14:18:37 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/07/05/fairusakujokomandoiroiro</guid>
      <description>

&lt;p&gt;ファイル生成/削除コマンドについて覚え書き。&lt;/p&gt;

&lt;h1 id=&#34;空ファイル生成:40d37f886c175b93db8e875ce685ddc6&#34;&gt;空ファイル生成&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ touch file
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;サイズ指定でファイル生成:40d37f886c175b93db8e875ce685ddc6&#34;&gt;サイズ指定でファイル生成&lt;/h1&gt;

&lt;p&gt;0埋め/高速なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/zero of=file bs=size count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ランダム/低速なら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/random of=file bs=size count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こっちは圧縮されてもサイズが極端に変わらない。&lt;/p&gt;

&lt;h1 id=&#34;ファイルの切り詰め:40d37f886c175b93db8e875ce685ddc6&#34;&gt;ファイルの切り詰め&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ truncate -s size file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記で作ったファイルのサイズを変えたりログファイルを一旦クリアしたりに便利。&lt;/p&gt;

&lt;h1 id=&#34;普通の削除:40d37f886c175b93db8e875ce685ddc6&#34;&gt;普通の削除&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ rm file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただしハードディスク上にはデータは残るのでセキュリティ的には完全ではない。&lt;/p&gt;

&lt;h1 id=&#34;ディスク上からも完全削除:40d37f886c175b93db8e875ce685ddc6&#34;&gt;ディスク上からも完全削除&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ shred -u file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-u&lt;/code&gt;がなかったらファイルを壊すが削除はしない。&lt;/p&gt;

&lt;p&gt;shredが出てこなかったので調べたついでにまとめた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>マクロについて整理してみる</title>
      <link>http://keens.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru</link>
      <pubDate>Sat, 04 Jul 2015 15:34:46 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/07/04/makuronitsuiteseirishitemiru</guid>
      <description>

&lt;p&gt;何故Lisperがマクロについて語るのか。Lisperと議論してみても満足のいく答を得た人はそんなにいないと思う。
それはLisper自身便利とは思っていても何が便利なのかを意識してなくて他人に上手く説明出来ないからじゃないかと思った。
ちょっと思いついた範囲でまとめてみる。&lt;/p&gt;

&lt;p&gt;最近ではマクロシステムを持つ言語は珍しくない。Rust, Scala, Template Haskell, Mirahなどなど。最初にCommon Lispのマクロと他の言語のマクロとの違いを少し考えてみたい。&lt;/p&gt;

&lt;h1 id=&#34;unless:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Unless&lt;/h1&gt;

&lt;p&gt;まず、unlessをマクロで書くことを考えてみたい。単純にifにnotをつければいい。&lt;/p&gt;

&lt;p&gt;Common Lispではこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(if (not foo-p)
    bar)

(defmacro unless (cond then)
  `(if (not ,cond)
       ,then))

(unless foo-p
  bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rustだとこうなるだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
if ! isFoo {
    bar;
}

macro_rules! unless {
    ($cond:expr, $then:stmt) =&amp;gt; {{
        if ! $cond {
            $then
        }
    }};
}

unless!(isFoo, {
    bar;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいはmirahだとこうなる。unlessが予約語なので_unlessにした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if ! isFoo
  bar
end

macro def _unless(cond, block:Block)
  quote{
    if ! `cond`
      `block.body`
    end
  }
end

_unless isFoo do
  bar
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみにCだとこう出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;if(! is_foo)
  bar;

#define unless(cond) if(!(cond))

unless(is_foo)
  bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、上のマクロたちを見比べて欲しい。Common LispのマクロとCのマクロは違和感なく新たな制御構造を作れたのに対してRustとMirahはマクロ呼び出しが剥き出しになっている。&lt;/p&gt;

&lt;p&gt;ここで注意して欲しいのはCはともかくCommon Lisp、Rust、Mirahのマクロは全て引数に必要な構文木をとってそのまま用意したテンプレートにあてはめているだけだ。やっていることに違いはない。
何が違うかというとマクロ呼び出しの構文が制御構造の構文と同じか違うかという点だけだ。私の知る範囲ではそのような構文をした言語はLispしかない。だから「Lispの」マクロなのだ。&lt;/p&gt;

&lt;p&gt;もう一つ。どのマクロ定義も十分直感的に読めたと思う。この範囲なら &lt;strong&gt;S式だからマクロが簡単になるということはない&lt;/strong&gt; と思う。別にS式でなくてもquasiquoteがあれば十分読み易いマクロが書ける。&lt;/p&gt;

&lt;h1 id=&#34;case:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Case&lt;/h1&gt;

&lt;p&gt;caseを生成することを考えよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun fun1 (x)
  (let ((y (case x
             ((:foo) (hoge &amp;quot;foo&amp;quot;))
             ((:bar) (hoge &amp;quot;bar!&amp;quot;)))))
    ...))


(defun fun2 (x)
 (let ((y (case x
            ((:foo) (hoge &amp;quot;foo&amp;quot;))
            ((:baz) (hoge &amp;quot;baz!&amp;quot;)))))
   ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように似たような、しかし微妙に違うcaseが必要になったような時に必要だろう。この時、&lt;code&gt;&#39;(:foo (hoge &amp;quot;foo&amp;quot;) :bar (hoge &amp;quot;bar!&amp;quot;))&lt;/code&gt;のようにリテラルでそのまま書いてしまっては抽象化する意味がなくなる。例えばハッシュテーブルにKey-Valueペアを入れて必要な時に入れたり削除したりすればよい。そのようなマクロはこう書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro case-table (key hash)
  `(case ,key
     ,@(loop
          :for k :being :the :hash-key :of hash :using (hash-value v)
          :collect `((,k) ,v))))

(defparameter *table*)
(setf (gethash :foo *table*) &#39;(hoge &amp;quot;foo&amp;quot;))
(setf (gethash :bar *table*) &#39;(hoge &amp;quot;bar!&amp;quot;))

(defun fun1 (x)
  (let ((y (case-table x #.*table*)))
    ...))

(remhash :bar *table*)
(setf (gethash :baz &#39;(hoge &amp;quot;baz!&amp;quot;)))


(defun fun2 (x)
  (let ((y (case-table x #.*table*)))
    ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ハッシュテーブルを受け取ってリストを返す普通のloopマクロの力をマクロ展開時にも使える。また、ハッシュテーブルには&lt;code&gt;&#39;(hoge &amp;quot;foo&amp;quot;)&lt;/code&gt;などのただのリストを突っ込んだがそれをそのままASTとしても使っている。
Common Lispのマクロのもう1つの良いところはマクロの展開時にもCommon Lispの機能がフルで使えるところであり、マクロの引数に受け取るのが構文木でありデータ構造でもあるS式なところだ。ここでは &lt;strong&gt;S式の同図像性が重要なファクターになっている&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(case-table x #.*table*)&lt;/code&gt; で使っている &lt;code&gt;#.&lt;/code&gt; は &lt;em&gt;リードマクロ&lt;/em&gt; といってマクロ展開(コンパイル時)より前(リード時、構文解析時)に動作するマクロだ。このリードマクロはeval-when-readといってリード時に
値を評価する。その結果、&lt;code&gt;case-table&lt;/code&gt;に渡るのが &lt;code&gt;&#39;*table*&lt;/code&gt;というシンボルでなく&lt;code&gt;*table*&lt;/code&gt;に束縛されているハッシュテーブルになる。因みに &lt;em&gt;コンパイラマクロ&lt;/em&gt; というマクロ展開が終わった後に動作するマクロもある。&lt;/p&gt;

&lt;p&gt;マクロ1つではなくマクロの前後に動作するマクロもあってこそ初めて柔軟性を手にしている。あまりその点は議論されてないのではないだろうか。&lt;/p&gt;

&lt;h1 id=&#34;common-lispの設計:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;Common Lispの設計&lt;/h1&gt;

&lt;p&gt;さて、各々言語には予約語や~構文というものがあると思う。メソッド定義構文など。Common Lispにもスペシャルフォームという名前で&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm&#34;&gt;25&lt;/a&gt;個存在する。
驚くべきことに、ここまでに出てきたCommon Lispのコードにはスペシャルフォームは3つしか出てこない。ifとletとquoteだ。setfやloop、defun、defmacro、case、defparameterなんかはマクロで出来ている。&lt;/p&gt;

&lt;p&gt;defunまでマクロで出来ているということはユーザがその気になれば関数定義の構文に手を入れたりも出来るということだ。
普通、そんなことをしたら阿鼻叫喚だがCommon Lispなら安全に出来る。マクロもシンボルに束縛されているので新たにマクロで上書きしたシンボルを名前空間にインポートしなければ今まで通りのdefunやloopが使える。&lt;/p&gt;

&lt;p&gt;もう1つ、普段使うものがマクロで出来ているということはマクロを被せてない機能は相当低レベルだということだ。マクロさえ書けば全く新しい言語機能を追加出来るということであり、あるいは&lt;a href=&#34;http://cl21.org/&#34;&gt;全く新しい言語も作れてしまう&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;このような設計はマクロで制御構造までも作れるから出来るのだ。関数定義構文をマクロで定義している言語はLisp以外に私は知らない。&lt;/p&gt;

&lt;h1 id=&#34;メタプログラミングとcommon-lisp:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;メタプログラミングとCommon Lisp&lt;/h1&gt;

&lt;p&gt;ところで、マクロに限らないメタプログラミングについて考えてみたい。メタプログラミングとは、プログラムを書くプログラムを書くことだ。プログラムはテキスト形式のソースコードから実行形式に至るまでの間に様々な中間形式から中間形式に変換される。メタプログラミングはそのどこかの形式を生成することと同義になる。通常、処理系内部で使う形式は変なことをされると困るのであまり外部に公開したくない。メタプログラミングを許すとしても構文解析などのフロントエンドに近い部分になるだろう。&lt;/p&gt;

&lt;p&gt;例えばyaccやlexのようなソースコードジェネレータ、rubyやDのような文字列ベースのメタプログラミングは公開APIであるところのパーサだけを使っているので安全性は高い。しかし文字列だけだと構造がないので書く側はつらい。一応、Common Lispにもread関数とeval関数があるのでCommon Lispのソースコード文字列を吐いてreadしてevalすれば文字列メタプログラミングは出来る。特に嬉しくないのでやらないが。&lt;/p&gt;

&lt;p&gt;次はトークンベースのメタプログラミングがある。Cのプリプロセッサなど。Common Lispでもリードマクロで可能だ。例えば正規表現リテラルを作ったりとかの例がある。&lt;/p&gt;

&lt;p&gt;次はASTベースのメタプログラミングがある。マクロだ。これは今まで見てきた。&lt;/p&gt;

&lt;p&gt;これより先はメタプログラミングとはあまり言わない気がする。JITと呼ぶのではないか。Common Lispにもeval関数やcompile関数があるからそういうことも出来る。正規表現ライブラリなんかが使っている。&lt;/p&gt;

&lt;p&gt;私が言いたいのはCommon Lispにはメタプログラミングの機構が一杯あるということではない。read, eval, compile…。気付いたかもしれないが、LispはLisp自身で出来ている。
Lispを書くとき、Lispを書いてるかもしれないしLispを構成するLispを書いているかもしれない。いくらでもメタプログラミングが出来るということだ。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:791da514bc52e2606dbc134b8c6e6cf7&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;何やらCommon Lisp賛美歌になってしまったが一応まとめておく。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;簡単なマクロ定義ならS式である必要はない&lt;/li&gt;
&lt;li&gt;複雑なマクロ定義ならS式であると書き易い。恐らく他の構文でも書けないことはない。&lt;/li&gt;
&lt;li&gt;マクロ呼び出し構文はS式でないと重大な違いがある。&lt;/li&gt;
&lt;li&gt;マクロ以外にもリードマクロやパッケージなど他の言語機能があってこそマクロが活きる。&lt;/li&gt;
&lt;li&gt;言語機能だけでなくマクロを前提とした設計も重要である。&lt;/li&gt;
&lt;li&gt;LispはS式で出来ている以前にLispで出来ている。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>あなたの知らないShebang</title>
      <link>http://keens.github.io/blog/2015/06/26/anatanoshiranaishebang</link>
      <pubDate>Fri, 26 Jun 2015 23:24:44 +0900</pubDate>
      
      <guid>http://keens.github.io/blog/2015/06/26/anatanoshiranaishebang</guid>
      <description>

&lt;p&gt;κeenです。最近は何故かBlack君って呼ばれます。Shebangの書き方にはいくつかあって、それを利用したふと面白い方法を思い付いたので共有を。&lt;/p&gt;

&lt;p&gt;さて、ご存知Shebangといえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにファイルの1行目が&lt;code&gt;#!&lt;/code&gt;から始まっているとシェルがそれ以降の文字列を実行可能ファイルのパス名として捜して実行してくれるものですが、実は&lt;code&gt;#!&lt;/code&gt;は唯一のフォーマットではありません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#!&lt;/code&gt;がデファクトになる前なのかそもそもシェルにコメントがなかった時代のものなのかは知りませんが昔は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;: /bin/sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と&lt;code&gt;:&lt;/code&gt;で始めていたらしいです。因みに&lt;code&gt;:&lt;/code&gt;は「何もしないコマンド」です。実質的にコメントとして扱ったり副作用のある変数展開だけを行なったりプログラマティックコメントアウトだったりの用途で使われてます。&lt;/p&gt;

&lt;p&gt;さて、シェルは全て文字列なのでクォートしてもしなくても構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてもちゃんと動いてくれます。なぜわざわざクォートするかというと&lt;a href=&#34;http://keens.github.io/blog/2014/12/08/ge-tochu-li-xi-potaburunacommon-lispshi-xing-ke-neng-huairuwozuo-ru/&#34;&gt;割と処理系ポータブルなCommon Lisp実行可能ファイルを作る | κeenのHappy Hacκing Blog&lt;/a&gt;のように別の言語のスクリプトとして実行される時に文字列リテラルになってくれると単純に無視されるので互換性が高まるのです。&lt;/p&gt;

&lt;p&gt;ということで完全版ポータブルなCommon Lisp実行可能ファイルはこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;

#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abclとcclが利用可能になりました。あとCIMも捜すようにしました。roswellは作者に訊いて下さい。&lt;/p&gt;

&lt;p&gt;ちなみに、shebangの解釈はシェルに依存するのですが、B Shell, csh, tcsh, dash, Bash, zshで動作確認しました。古い機能なので新しいシェルほど切り捨てている可能性があったのですがBashやzshが大丈夫だったので良かったです。
一応非推奨な気がしますがこれしか方法がないので仕方ないですね。&lt;/p&gt;

&lt;p&gt;ということでみなさんスクリプト書きましょう。&lt;/p&gt;

&lt;h1 id=&#34;追記:97aff0076544159c37193ad080a89d0a&#34;&gt;追記&lt;/h1&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangの解釈はシェルじゃなくてOSのexec()がやります。で、#!や認識できるバイナリ以外は、exec()がエラーを返した後でシェルがファイルを見て、テキストファイルならシェルスクリプトとして実行ってやってます。なので先頭が:の場合は(続&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614551978526445570&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/blackenedgold&#34;&gt;@blackenedgold&lt;/a&gt; shebangとしてではなく、シェルがシェルスクリプトとして読んでるだけなので、その後に/bin/shとか書いてあっても関係ないはず (シェルによってはそこも見るかもしれませんが)&lt;/p&gt;&amp;mdash; Kilo Kawai (@anohana) &lt;a href=&#34;https://twitter.com/anohana/status/614552151759589376&#34;&gt;2015, 6月 26&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ということで実験してみたところ、先頭の&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;はどのシェルも読み飛ばす模様(つまり、&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/usr/bin/ruby&amp;quot;&lt;/code&gt;と書いてもrubyが実行される訳ではない)。&lt;/p&gt;

&lt;p&gt;で、先程の 完全版から&lt;code&gt;&amp;quot;:&amp;quot; &amp;quot;/bin/sh&amp;quot;&lt;/code&gt;を取り除いて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;#|
run_if_exists(){
 command -v $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; exec &amp;quot;$@&amp;quot;
}
 run_if_exists cl &amp;quot;$0&amp;quot; &amp;quot;$@&amp;quot;
 run_if_exists sbcl --noinform --no-sysinit --no-userinit --script &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists clisp -norc --quiet --silent -on-error exit  &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ecl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists mkcl -norc -q -shell &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists alisp -qq -#! &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists ccl --no-init --quiet --batch --load &amp;quot;$0&amp;quot;  --eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 run_if_exists abcl --noinform --noinit --nosystem --batch --load &amp;quot;$0&amp;quot; -- &amp;quot;$@&amp;quot;
 run_if_exists lisp -quiet -noinit -batch -load &amp;quot;$0&amp;quot; -eval &#39;(quit)&#39; -- &amp;quot;$@&amp;quot;
 echo &amp;quot;No lisp implementation found&amp;quot;
 exit 1
|#

(write-line (lisp-implementation-type))
(force-output)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても動いたのでこれが最終版ということになります。&lt;/p&gt;

&lt;p&gt;大学の講究でMINIX本やったどころかexecのところ自分の担当だったのに恥かしい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>